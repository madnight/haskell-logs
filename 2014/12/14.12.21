00:08:11 * hackagebot http-client-streams 0.2.0.1 - http-client for io-streams supporting openssl  http://hackage.haskell.org/package/http-client-streams-0.2.0.1 (DavidJohnson)
00:08:11 * hackagebot sai-shape-syb 0.3.2 - Obtain homogeneous values from arbitrary values, transforming or culling data  http://hackage.haskell.org/package/sai-shape-syb-0.3.2 (AndrewSeniuk)
00:11:06 <halvorg> hm, I want to build a priority queue of a given length. if I attempt to insert an element that has a higher priority than any of the elements in the queue, I want to drop the lowest element. Are there any libraries I can use for this?
00:11:50 <halvorg> hm, pqueue looks good
00:43:06 * hackagebot yesod-bin 1.4.3.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.1 (MichaelSnoyman)
01:13:07 * hackagebot seqaid 0.1.6.0 - Dynamic strictness control, including space leak repair  http://hackage.haskell.org/package/seqaid-0.1.6.0 (AndrewSeniuk)
01:13:09 * hackagebot leaky 0.1.6.0 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.1.6.0 (AndrewSeniuk)
01:18:08 * hackagebot authenticate 1.3.2.11 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.2.11 (MichaelSnoyman)
01:18:10 * hackagebot authenticate-oauth 1.5.0.1 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.5.0.1 (MichaelSnoyman)
01:33:08 * hackagebot wai-handler-webkit 3.0.0.1 - Turn WAI applications into standalone GUIs using QtWebkit.  http://hackage.haskell.org/package/wai-handler-webkit-3.0.0.1 (MichaelSnoyman)
01:34:34 <monitority> Hi guys, need your help. Can you please upvote my new service? https://news.ycombinator.com/item?id=8779298 - It's a totally free website monitoring service
01:34:58 <pharpend> Testeree: stackage is stable hackage, so it's actually safer
01:35:08 <pharpend> Testeree: there are fewer packages, though
01:48:09 * hackagebot wai-frontend-monadcgi 3.0.0.1 - Run CGI apps on WAI.  http://hackage.haskell.org/package/wai-frontend-monadcgi-3.0.0.1 (MichaelSnoyman)
02:16:55 <untseac> Hello. Is haskell cross platform, gui included?
02:17:41 <pharpend> yes-ish
02:17:43 <pharpend> untseac:
02:18:02 <untseac> ish?
02:18:28 <pharpend> untseac: haskell works on most operating systems. I know there was some trouble on ARM, but I think that's been resolved
02:19:05 <untseac> ok, how about gui?
02:19:08 <pharpend> untseac: Given your question, I'm guessing you're used to Java?
02:19:20 <untseac> I am
02:19:48 <pharpend> untseac: There isn't anything like swing in Haskell. We have bindings to GTK+ and Qt.
02:20:37 <untseac> pharpend, that sounds good enough for me, as long as it is cross platform.
02:20:50 <untseac> thanks
02:21:19 <pharpend> untseac: what OS are you on?
02:21:54 <untseac> pharpend, I mostly use arch linux
02:22:04 <pharpend> okay
02:22:08 <pharpend> you'll be fine then
02:22:12 <dibblego> though, Java does not have a cross-platform UI library
02:22:50 <untseac> dibblego, ? swing is cross platform as is javafx
02:22:53 <sasasa>  ¬Ø¬∞¬∑.¬∏¬∏.¬∑¬∞¬Ø¬∞¬∑> Ciau  a  tt :))) <¬∑¬∞¬Ø¬∞¬∑.¬∏¬∏.¬∑¬∞¬Ø'
02:22:54 <sasasa> √û√û√û√û√û√û zauuuuuuuuu √û√û√û√û√û√û
02:22:55 <sasasa> ¬ß*__*¬ß RiEcCoMi TrA VoI ¬¥ . * . ` , ( ' ¬¥ * . ¬∑ ciau xD A TuTTi! ' ¬¥ . *) . ` , ' BeLLi E BruTTi AnChE OgGi SoNo ViVa ¬ß*__*¬ß
02:23:08 --- mode: ChanServ set +o dibblego
02:23:12 --- mode: dibblego set +b *!*sasasa@*.21-87-r.retail.telecomitalia.it
02:23:14 --- kick: sasasa was kicked by dibblego (sasasa)
02:23:36 <dibblego> untseac: It really isn't. You should try it. I have seen all sorts of contortions in response to the fact that swing (not javafx) are cross-platform.
02:23:40 --- mode: dibblego set -o dibblego
02:24:15 <dibblego> The last place I worked at, we had a licencing agreement with Sun/Oracle where we could "fork javax.swing" so that we coudl successfully run on Windows.
02:24:34 <untseac> well swing is crappy anyway
02:24:38 <dibblego> The place before that, I was working on the implementation itself at IBM. Again, compiled for each of the platforms.
02:24:46 <dibblego> that's because it's not cross-platform
02:25:30 <pharpend> Apologies if this is too lewd, but saying that java is nice because it's cross platform is like saying that anal sex is nice because it works on all genders
02:25:36 <dibblego> the Sun Certified Java Developer assignment, in 2004, required you to write a swing application, which was supposed to "run on many platforms", but when it came time to assess, of coruse it didn't ó it's swing!
02:26:20 <untseac> I guess but it doesn't really matter to me, I'm tired of anything JVM related including scala
02:26:37 <untseac> To much clutter on their ecosystem
02:26:39 <untseac> too*
02:27:36 <untseac> haskell reminds me of the times when there was no BS
02:28:37 <pharpend> haskell is pretty nice
02:28:58 <pharpend> the development environment reminds me a lot of lisp
02:29:15 <pharpend> ghci is just awesome
02:29:40 --- mode: ChanServ set +o dibblego
02:29:41 --- mode: dibblego set -b *!*sasasa@*.21-87-r.retail.telecomitalia.it
02:29:45 --- mode: dibblego set -o dibblego
02:37:17 <pharpend> untseac: Haskell doesn't have too much bs, but there is a lot of fighting the compiler
02:40:11 <untseac> pharpend, from what I've seen error messages are kind of cryptic but I'm still learning and so far it seems nice. I'm going to invest in it.
02:40:23 <pharpend> really, hmm
02:40:45 <pharpend> I don't remember Java, but Haskell's errors are pretty nice, compared to Python/Ruby/Perl
02:41:11 <pharpend> Haskell is nice, though, in that you very rarely get runtime errors
02:41:23 <pharpend> untseac:
02:42:03 <pharpend> I think in Java, syntax errors are the only compile-time errors, right?
02:43:10 * hackagebot auto-update 0.1.2.1 - Efficiently run periodic, on-demand actions  http://hackage.haskell.org/package/auto-update-0.1.2.1 (MichaelSnoyman)
02:43:12 * hackagebot mime-types 0.1.0.5 - Basic mime-type handling types and functions  http://hackage.haskell.org/package/mime-types-0.1.0.5 (MichaelSnoyman)
02:43:14 * hackagebot wai 3.0.2.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-3.0.2.1 (MichaelSnoyman)
02:43:15 <untseac> pharpend, yes they are
02:43:16 * hackagebot wai-app-static 3.0.0.5 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-3.0.0.5 (MichaelSnoyman)
02:43:18 * hackagebot wai-conduit 3.0.0.2 - conduit wrappers for WAI  http://hackage.haskell.org/package/wai-conduit-3.0.0.2 (MichaelSnoyman)
02:44:40 <pharpend> untseac: in haskell, you get compile time errors if your code doesn't make sense
02:44:52 <dhrosa> I have a bunch of lists of integers, and want to remove lists that have a sum greater than a certain amount, is there anyway for the compiler to be informed that the integers are all positive, and that the sum calculation can terminate early?
02:45:04 <dhrosa> besides writing my own filter predicate for this?
02:45:46 <pharpend> untseac: which is sometimes annoying, because you will spend 3 hours trying to get your code to compile, but then it compiles & works perfectly
02:45:50 <indiagreen> if you're not using Integer, it wouldn't even be right to do this optimisation
02:45:54 <indiagreen> due to overflowing
02:46:35 <dhrosa> I know in this particular
02:46:37 <untseac> pharpend, that sounds better than exploding at runtime. java has type errors too at compile time but that's it.
02:46:40 <dhrosa> oops forgot to finish typing
02:46:46 <indiagreen> also, this might not be an optimisation if you're using Integer as well
02:47:03 <indiagreen> because you have to do as many comparisons as there are numbers
02:47:14 <pharpend> untseac: but even then, Java isn't very good at type inference, so you will still occasionally get passive type errors
02:47:31 <indiagreen> and comparisons might be just as expensive as additions... maybe you should benchmark
02:47:54 <dhrosa> well, asymptotically yes it's the same number of ops
02:48:11 * hackagebot wai-extra 3.0.3.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.3.1 (MichaelSnoyman)
02:48:13 * hackagebot wai-handler-fastcgi 3.0.0.1 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-3.0.0.1 (MichaelSnoyman)
02:48:15 * hackagebot wai-handler-launch 3.0.0.1 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-3.0.0.1 (MichaelSnoyman)
02:48:17 * hackagebot wai-websockets 3.0.0.3 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-3.0.0.3 (MichaelSnoyman)
02:48:19 * hackagebot warp 3.0.4.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.4.1 (MichaelSnoyman)
02:49:03 <indiagreen> if there's a really big chance of early termination and the lists are long, you can use scanl to avoid having to write your own filter
02:49:14 <indiagreen> >¬†scanl (+) 0 [1..10]
02:49:36 <indiagreen> hm, what's up with lambdabot
02:50:08 <untseac> pharpend, yeah I did develop in scala which has sort of okaish type inference but haskell just looks better overall
02:50:45 <indiagreen> for instance, if the limit is 15, this will rule out [1..10] early:
02:50:46 <indiagreen> >¬†any (> 15) . scanl (+) 0 $ [1..10]
02:51:21 <untseac> pharpend, scala isn't purely functional and that is a big let down imo
02:53:21 * hackagebot warp-tls 3.0.1.1 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.1.1 (MichaelSnoyman)
03:28:12 * hackagebot hmatrix 0.16.1.2 - Numeric Linear Algebra  http://hackage.haskell.org/package/hmatrix-0.16.1.2 (AlbertoRuiz)
03:39:38 <rtpg> do we still need to add company-ghc to the company mode backends manually? when I try to follow the instructions in the readme, I'm getting a "company-ghc as symbol is void" error a lot but company is working
03:39:57 <rtpg> instructions say to do an (add-to-list 'company-backends 'company-ghc)
03:49:27 <Flonk> Say I have a function which works for all monoids but is rather inefficient compared to a concrete alternative that only works on lists - is there some way I can tell the compiler that the two definitions are equivalent but that it should use the concrete one instead of the more general one if possible?
03:56:22 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#rules
03:57:06 <geekosaur> or more to the point https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/rewrite-rules.html
04:02:12 <Flonk> geekosaur: Oh, that's cool. Thanks!
04:06:29 <_um> Hi! I have a baby question. Why is it that this: `main = do withFile "haiku.txt" ReadMode (\ h -> putStr =<< hGetContents h )` will output the contents of haku.txt but won't output if I try to bind the result of `withFile` to `putStr` instead of putting the latter in a lambda, like so: `main = putStr =<< withFile "haiku.txt" ReadMode hGetContents`?
04:06:53 <_um> s/haku.txt/haiku.txt
04:07:01 <_um> Sorry for the run-on sentence also.
04:08:10 <_um> To clarify my question, the first bit of code, using putStr in the lambda, will output, the second, binding the output of withFile to putStr, won't output. What am I missing?
04:08:22 <geekosaur> lazy I/O.
04:09:25 <geekosaur> the string produced by readFile reads the file "in the background" as stuff is requested from it, and the file is closed when withFile returns. so in the first one the putStr demands the data from the file while still inside readFile, so it works
04:09:56 <geekosaur> the second returns a string which is attached to a file which withFile has already closed, so it produces nothing
04:10:06 <geekosaur> lazy I/O is ... strange
04:10:20 <_um> geekosaur: thanks!
04:13:07 <_um> Yep that makes sense on reflection. "Learn You a Haskell..." might have even tried to explain this, but I didn't quite get it (because I was trying to use binds instead of do notation, I guess). Many thanks.
04:14:06 <zwer> this will work too btw: main = putStr =<< readFile "haiku.txt"
04:14:26 <_um> I think that's the next section zwer :)
04:14:53 <_um> Although, that opens a new mystery to me: why does readFile work but not withFile?
04:15:05 <pharpend> zwer: I initially read that as "this will not work too btw", and spent about 30 seconds reading that trying to figure out why it wouldn't work =p
04:15:13 <pharpend> :t withFile
04:15:14 <lambdabot>     Not in scope: ‚ÄòwithFile‚Äô
04:15:14 <lambdabot>     Perhaps you meant one of these:
04:15:14 <lambdabot>       ‚ÄòwriteFile‚Äô (imported from Prelude),
04:15:18 <pharpend> hmm
04:15:21 <geekosaur> because readFile doesn't have the bracketing behavior of withFile that closes the file when it returns
04:15:21 <pharpend> what is withFile
04:15:27 <zwer> pharpend :)
04:15:43 <geekosaur> readFile instead closes the file when it hits EOF
04:15:45 <zwer> _um readFile does not close the file after the call, withFile does.
04:15:55 <pharpend> hmm
04:15:59 <pharpend> is withFile something new?
04:16:05 <_um> Ah! readfile leaves the stream open.
04:16:10 <pharpend> or am I just not up-to-date on my file stuff?
04:16:25 <_um> And closes it implicitly when it's no longer needed?
04:16:26 <geekosaur> :t System.IO.withFile
04:16:27 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
04:16:28 <pharpend> _um: yeah, IO in haskell leaves quite a bit to be desired
04:16:38 <geekosaur> I think Prelude imports readFile but not withFile
04:16:44 <pharpend> makes sense
04:17:02 <geekosaur> and yes, a number of us dislike lazy I/O as default because of nonintuitive weirdness like this
04:17:16 <pharpend> _um: there are a couple of libraries, pipes and conduit, which try to alleviate it. I think edwardk is also working on some new IO magic
04:17:24 <geekosaur> on the other hand, the alternativs are generally difficult to understand
04:18:08 <pharpend> true
04:18:14 <indiagreen> withFile has been in System.IO since base 4.0.0.0 if not further than that
04:18:25 <pharpend> when I was a newbie, I thought IO in Haskell was extremely complicated
04:18:39 <pharpend> and now that I'm an oldbie, I think it's not complicated enough
04:18:46 <_um> geekosaur, pharpend: I'm far too green to have an opinion on the matter. Although I was reading up on some pro SML/OCaml stuff lately, that seemed to center on related issues.
04:19:32 <geekosaur> well, not exactly, as both those languages are strict. purity does figure into it somewhere but not quite the same way. it's Haskell's laziness that makes things really weird
04:20:57 <_um> geekosaur: I might be confused. What I was reading was targeting the laziness rather the purity issue. Not that it's very relevant... here :)
04:21:15 <_um> Thanks, all, for clarifying.
04:21:39 <_um> I'll look forward to playing with pipes/conduit once I farther along.
04:21:52 <_um> *rather than the
04:22:30 <geekosaur> but SML and OCaml are strict
04:23:51 <_um> geekosaur: yep. I'm sorry I'm not being very clear tonight: I had been reading something arguing that default laziness is problematic, and not preferable for a number of reasons.
04:24:56 <_um> geekosaur: I was basically just doing free association: I don't have a point to make. Sorry :)
04:27:20 <_um> I imagine it is well known material around these parts, but here's what I was talking about: https://existentialtype.wordpress.com/2011/05/01/of-course-ml-has-monads/
04:32:46 <arthur_> test
04:36:15 <ddellacosta> I'm having a ton of trouble with a homework question--I thought I got types but I am stumbling when I'm asked to define a function with the type sig ((a -> b) -> b) -> b
04:37:15 <ddellacosta> I can build something trivial using a specific 'b', so whatever 'a' I get I just get a 'b'.  But that is obviously missing the point.  However, I don't see how I can otherwise build this without actually executing the function I get as the first argument...I'm just totally stumped by this.
04:38:13 <Flonk> ddellacosta: I'm not really sure whether this can be done :/
04:38:21 <hexagoxel> @djinn ((a -> b) -> b) -> b
04:38:21 <lambdabot> -- f cannot be realized.
04:38:22 <Flonk> @djinn ((a -> b) -> b) -> b
04:38:22 <lambdabot> -- f cannot be realized.
04:38:27 <Narfinger> hiho, this is probably a really dumb question but can somebody point me to a tutorial on how to have a template for an html page as file, replace some stuff in it and serve it with happstack?
04:38:30 <Flonk> hexagoxel: ha!
04:38:35 <hexagoxel> :)
04:38:46 <Narfinger> this is my project to learn haskell and at the moment i only found automatically generated documentation which doesn't really help
04:38:55 <Flonk> :t fix
04:38:56 <lambdabot> (a -> a) -> a
04:39:04 <ddellacosta> argh, I'm dumb, it is just ((a -> b) -> b)
04:39:19 <indiagreen> ‚Äú((a -> b) -> b) -> b‚Äù is the same as ‚Äúa ->¬†b‚Äù
04:39:37 <ddellacosta> argh, no it's not nevermind
04:39:37 <indiagreen> and ((a -> b) -> b) is just ‚Äúa‚Äù
04:39:52 <indiagreen> if b is forall'd
04:40:09 <ddellacosta> sorry, b is not meant to be a type variable here, it's a specific thing
04:40:20 <ddellacosta> ((a -> B) -> B) -> B
04:40:36 <ddellacosta> ADT
04:41:28 <indiagreen> let f = undefined :: ((a ->¬†Int) -> Int) ->¬†Int
04:41:33 <ddellacosta> I'm obfuscating it to try to get to the essence of what I'm being confused by
04:41:36 <indiagreen> ouch
04:41:38 <indiagreen> @let f = undefined :: ((a ->¬†Int) -> Int) ->¬†Int
04:41:40 <lambdabot>  Defined.
04:41:50 <indiagreen> :t \a ->¬†f ($ a)
04:41:51 <lambdabot>     Ambiguous occurrence ‚Äòf‚Äô
04:41:51 <lambdabot>     It could refer to either ‚ÄòL.f‚Äô,
04:41:51 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:169:1
04:41:59 <indiagreen> :t \a ->¬†L.f ($ a)
04:42:00 <lambdabot> a -> Int
04:42:16 <indiagreen> see, you can go from your function to ‚Äúa -> B‚Äù trivially
04:42:33 <ddellacosta> indiagreen: I mean, I can do something trivially stupid like f x = 1, but obviously that's not what is wanted here.  I'm just stumped by this
04:43:16 <Flonk> ddellacosta: You should probably give us more context :) What are you trying to do?
04:43:18 <indiagreen> okay, look
04:43:22 <indiagreen> an explanation
04:43:38 <indiagreen> ‚Äú(a ->¬†Int) -> Int‚Äù ‚Äì this is a function which has some ‚Äúa‚Äù inside
04:43:45 <indiagreen> but it won't give it to you directly
04:44:21 <indiagreen> it will, however, give it to -the function you feed it- and let you have the result
04:45:01 <indiagreen> so, if you have a, you can construct ‚Äú(a -> B) -> B‚Äù
04:45:05 <indiagreen> for any B
04:46:21 <ddellacosta> indiagreen: So that last bit, how do I do that?  It seems like it should be obvious but it's not to me. Everything else you're saying is crystal clear.
04:46:37 <indiagreen> :t \a -> ($a)
04:46:38 <lambdabot> a -> (a -> b) -> b
04:46:48 <indiagreen> or ‚Äúa ->¬†((a -> b) ->¬†b)‚Äù
04:48:24 <ddellacosta> indiagreen: thank you very much, that was the clue I needed to wrap my head around this.
04:55:50 <leocassarani> Hi all. I'm using attoparsec (for the first time) and I'm trying to figure out how to build a parser for a single word made up of alphanumerical characters, which MUST start with an uppercase letter
04:56:24 <leocassarani> I've tried a combination of satisfy (inClass "A-Z") and takeWhile . inClass "A-Za-z0-9")
04:56:41 <leocassarani> I'm not quite sure how to put them together to get the resulting word out
05:01:21 <batchm> _um default lazy evaluation and lazy IO are two separate matters, and many haskellers like the former but dislike the latter. haskell's IO would be strict if standard library did not use unsafeInterlaveIO, and there are haskell libraries with strict IO
05:01:44 <batchm> as far as default strict vs non-strict evaluation goes, see this for a different view. http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
05:02:19 <indiagreen> leocassarani: you can get the 1st letter, then the rest, then cons
05:02:20 <gemurdock> what is haskell?
05:02:32 <vanila> its a cool programing language
05:02:57 <leocassarani> indiagreen: So something like (++) <*> firstLetter <*> option restOfTheLetters?
05:02:57 <gemurdock> vanila, used for what? is it harder than html? :P
05:03:06 <vanila> yes much harder
05:03:15 <indiagreen> except that ‚Äú:‚Äù instead of ‚Äú++‚Äù
05:03:22 <gemurdock> is it harder than assembly?
05:03:24 <indiagreen> and the 1st ‚Äú<*>‚Äù is ‚Äú<$>‚Äù
05:03:25 <leocassarani> indiagreen: ah k, will that work even with ByteStrings?
05:03:28 <vanila> no its a lot easier than assembly
05:03:29 <leocassarani> Yes sorry, good point
05:03:30 <vanila> its for ... almost anything
05:03:39 <gemurdock> can it replace html?
05:03:43 <vanila> no
05:03:45 <indiagreen> and it will work with bytestrings if you use B.cons instead
05:03:45 <_um> batchm: thanks for clarifying and for the resource! I had definitely conflated those two concepts. (Also, just be clear, I wasn't taking a position).
05:03:50 <vanila> its not that kind of language
05:03:51 <leocassarani> indiagreen: \o/ thank you
05:03:53 <indiagreen> or how-is-it-called
05:04:04 <_um> batchm: I'll look through that link now.
05:04:36 <vanila> gemurdock, it can replace javascript though
05:04:56 <vanila> someone wrote a compiler which turns it into javascript
05:07:03 <batchm> _um welcome
05:08:18 <Chathurga> What's a nice way to get zero without the literal and using as little from Prelude as possible?
05:08:37 <vanila> > length[]
05:08:38 <lambdabot>  0
05:08:40 <vanila> > 1-1
05:08:42 <lambdabot>  0
05:08:52 <Chathurga> Yeah I was thinking of that, I could use length
05:08:53 <gemurdock> vanila, i love java personally. use it for everything... unless i have too use c++... sell haskell to me like a salesman. :)
05:09:08 <Chathurga> No Num, weird constraints I know
05:09:10 <leocassarani> indiagreen: ok so, this seems to work
05:09:15 <leocassarani> nameParser = BS.cons <$> satisfy (inClass "A-Z") <*> (P.takeWhile . inClass) "A-Za-z0-9"
05:09:21 <vanila> gemurdock, I'm not really a salesman but if you have questions I'll be happy to tell you about it
05:09:23 <leocassarani> but it looks very messy ‚Äì is there anything I could do to simplify it?
05:09:38 <vanila> gemurdock, what I woudl say is that it is fun to use
05:10:20 <gemurdock> vanila, what other languages do you use?
05:10:40 <vanila> I like scheme and prolog and im learning forth
05:11:59 <_um> gemurdock: I'm leanring it because, aside form being fun and pretty, it has a solid and coherent theoretical basis, which means studying the language also teaches me about mathematical structures and type theory. I get to learn logic, math, and an elegant programming language all at the same time.
05:12:23 <_um> vanila: I like prolog a lot too.
05:12:36 <gemurdock> _um, sounds good. I may check this out then
05:12:40 <indiagreen> leocassarani: you can use do-notation to name separate parts of your parser
05:12:56 <indiagreen> or you can put them in a where/let
05:13:01 <vanila> _um, cool :D
05:13:24 <leocassarani> indiagreen: ok, but does the rest seem like the simplest solution? I feel like there might be a combinator I'm missing
05:13:24 <indiagreen> i.e. ‚ÄúnameParser = BS.cons <$> first <*> rest where first = ...; rest = blah‚Äù
05:13:28 <_um> gemurdock: vanila's point is important too, though, and Haskell's practical utility has been pretty well demonstrated.
05:13:34 <leocassarani> Ah yeah, that does read much better actually
05:14:14 <Chathurga> gemurdock: Haskell has extremely good type inference compared to most languages
05:14:30 <indiagreen> also, I'd say ‚ÄúP.takeWhile (inClass "A-Za-z0-9")‚Äù seems to convey the intent better
05:14:39 <Chathurga> I think going back to other languages that's what hits me the most
05:14:59 <gemurdock> Chathurga, you mean like char's it takes to complete a given task / amount of code?
05:15:05 <leocassarani> indiagreen: you're right, I usually really struggle with how point-free to make my expressions
05:15:55 <_um> Chathurga: is that because you leave functions un-annoated often, or more because of the information it gives you during compilation errors and such?
05:16:11 <Chathurga> gemurdock: No sorry, I mean that the compiler can figure out the type of a function, let's say, without you having to state it
05:16:47 <Chathurga> _um: Mostly when I'm doing various maps and filters, a lot of languages need help when it gets a bit complicated
05:16:50 <indiagreen> leocassarani: I usually write everything non-pointfree style until I can cleanly express the pointfree alternative in English
05:17:01 <Chathurga> Scala finds it hard to figure out types sometimes, usually when you want it to the most
05:17:07 <indiagreen> i.e. ‚Äú(+1)‚Äù reads as ‚Äúadd 1‚Äù, so this is pointfree
05:17:42 <indiagreen> ‚Äúbetween openParen closingParen‚Äù reads as it's written, so it's pointfree
05:17:56 <indiagreen> ‚Äúa . b . c‚Äù reads ‚Äúthis then that then that‚Äù, so it's pointfree too
05:17:59 <leocassarani> My Haskell lecturer at university used to forbid us from using ($), which I disagreed with, but I still feel pangs of guilt every time I replace a set of brackets with $ :)
05:18:18 <Chathurga> I've fallen out with $ for some reason
05:18:36 <gemurdock> Chathurga, ok
05:18:53 <_um> Chathurga: Oh that makes sense. I should probably give an older, imperative, statically typed language some attention before long so I can really appreciate what I'm missing. Aside from a brief bit of toying with go, all my experience is with dynamic languages, so I am digging types for the support and the way they clarify my thinking, but not properly appreciating the elegance of their implementation in haskell.
05:20:00 <_um> Chathurga: what's driving you away form $? (aside from it being an ugly glyph :P)
05:20:18 <_um> s/form/from
05:21:28 <Chathurga> I dunno, my flavor of the week syntax choice, I'll probably flip back soon
05:21:37 <Chathurga> I'm liking my brackets at the moment
05:22:45 <vanila> $ isnt nice
05:22:56 <indiagreen> why not
05:22:57 <vanila> sometimes you can avoid it by changing f x = p . q . r $ x to f = p . q . r
05:23:23 <indiagreen> I like ‚Äúp $ q $ r $ x‚Äù, what's wrong with me
05:23:36 <Chathurga> indiagreen: You're a pervert
05:23:50 <indiagreen> 'kay
05:24:50 <Flonk> I agree with indiagreen though, ($) is wonderful
05:25:00 <Flonk> Especially if you know what it's like to program in LISP
05:28:17 * hackagebot stackage 0.2.1.1 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.2.1.1 (MichaelSnoyman)
05:33:14 <gigabytes> staying in topic, is there any difference in performance for a function written in point-free style?
05:33:34 <gigabytes> I've read somewhere that GHC can only inline a function if it's fully applied
05:33:53 <gigabytes> fully applied with respect to the arity of the original definition
05:33:57 <gigabytes> is it true?
05:34:12 <gigabytes> so a function defined in point-free style should be more inlineable
05:35:24 <Chathurga> I doubt there's a difference in most cases but I don't have the knowledge to say for sure
05:36:00 <Chathurga> You could dump the intermediate language used during compilation and check if it's identical with and without pointfree
05:37:08 <Chathurga> The monomorphism restriction plays into this
05:53:18 * hackagebot yesod 1.4.1.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.4.1.3 (MichaelSnoyman)
05:53:20 * hackagebot yesod-auth 1.4.1.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.1.1 (MichaelSnoyman)
05:53:22 * hackagebot yesod-auth-oauth 1.4.0.1 - OAuth Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-oauth-1.4.0.1 (MichaelSnoyman)
05:53:24 * hackagebot yesod-core 1.4.7.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.7.1 (MichaelSnoyman)
05:53:26 * hackagebot yesod-eventsource 1.4.0.1 - Server-sent events support for Yesod apps.  http://hackage.haskell.org/package/yesod-eventsource-1.4.0.1 (MichaelSnoyman)
05:58:28 * hackagebot yesod-form 1.4.3.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.4.3.1 (MichaelSnoyman)
05:58:30 * hackagebot yesod-newsfeed 1.4.0.1 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-1.4.0.1 (MichaelSnoyman)
05:58:32 * hackagebot yesod-persistent 1.4.0.2 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.4.0.2 (MichaelSnoyman)
05:58:34 * hackagebot yesod-sitemap 1.4.0.1 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-1.4.0.1 (MichaelSnoyman)
05:58:35 <_um> batchm: I had a skim of post you linked--very informative for me. Over my head in parts, but I'll bookmark it to return to when I have better footing. I also learned that Haskell's laziness provides some of the advantages I've come to appreciate from Prolog's explicit-evaluation. Thanks again!
05:58:36 * hackagebot yesod-static 1.4.0.4 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.4.0.4 (MichaelSnoyman)
06:02:39 <quchen> gigabytes: Pointfree vs. pointful should be a concern of readability, by a huge margin.
06:03:10 <quchen> That GHC inlines only fully applied functions is correct though.
06:03:38 * hackagebot yesod-test 1.4.2.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.4.2.1 (MichaelSnoyman)
06:03:39 <quchen> Note that given `f x = \x -> ...`, `f 1` is fully applied in this context.
06:03:40 * hackagebot yesod-websockets 0.2.1.1 - WebSockets support for Yesod  http://hackage.haskell.org/package/yesod-websockets-0.2.1.1 (MichaelSnoyman)
06:04:00 <quchen> Eh, `f x = \y -> ...`
06:04:33 <quchen> So the term "fully applied" is a bit finnicky here.
06:07:46 <quchen> chrisdone: callCC. Nuff said
06:08:30 <quchen> chrisdone: But I think after this I've finished levelling up again ;-)
06:13:41 <zipper> So basically. A type stdGen holds random values. To interact with it is a typeclass RandomGen.
06:14:31 <zipper> So simple. it's shocking. Great docs  btw. About to start reading on "The global random number generator" and I'm afraid it's about to get hard.
06:15:05 <quchen> zipper: No, stdGen does not hold random values. stdGen holds the seed to generate a new random value.
06:15:09 <quchen> :t next
06:15:10 <lambdabot> RandomGen g => g -> (Int, g)
06:15:33 <zipper> The seed is a pair.
06:15:33 <quchen> This takes a RandomGen, for example a stdGen, and gives you an Int created using its contained seed, and a new generator with a new seed.
06:16:19 <zipper> *tuple
06:16:41 <zipper> stdGen is a type. next is just one of the functions in the typeclass RandomGen
06:16:55 <zipper> and stdGen is an instance of it
06:17:10 <zipper> quchen: Thanks for clearing that up for me.
06:17:13 <quchen> This is stdNext, the `next` implementation for `stdGen`: http://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#stdNext
06:17:52 <quchen> I assume the "two seeds" in stdGen are for ‚Ä¶ something. It certainly doesn't look like one is a random number that is returned directly though.
06:18:07 <barrucadu> "-- no statistical foundation for this!", heh
06:19:27 <quchen> barrucadu: It's a pseudo random generator. Not secure, maybe not uniform, nobody knows. I use System.Random mostly if I just want something that looks random to my eyes.
06:19:42 <barrucadu> Yeah, I know
06:19:59 <quchen> I treat it as carefully as I tread QuickCheck's arbitrary. Would not recommend to encrypt stuff ;-)
06:42:47 <zipper> Why isn't getStdGen >>= next :: (Int, StdGen) yet getStdGen :: IO StdGen and next :: RandomGen g => g -> (Int, g) and StdGen is an instance of RandomGen
06:43:44 <quchen> You're getting rid of the IO in your first example.
06:44:06 <zipper> quchen: Yes I want to take the StdGen out of the IO
06:44:20 <zipper> and feed it to next
06:44:33 <zipper> :t getStdGen
06:44:33 <lambdabot> IO StdGen
06:44:37 <quchen> :t getStdGen >>= \gen -> return (next gen)
06:44:38 <lambdabot> IO (Int, StdGen)
06:44:42 <quchen> or equivalently
06:44:48 <quchen> :t fmap next getStdGen
06:44:49 <lambdabot> IO (Int, StdGen)
06:44:58 <zipper> quchen: pause
06:46:04 <zipper> quchen: Oh Oh my issue is in not knowing the type >>= returned.
06:46:15 <zipper> :t >>=
06:46:15 <lambdabot> parse error on input ‚Äò>>=‚Äô
06:46:21 <zipper> :t (>>=)
06:46:22 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:46:30 <zipper> The result must also be a monad
06:46:38 <quchen> Typed holes to the rescue!
06:46:40 <quchen> getStdGen >>= _wat
06:46:42 <quchen> > getStdGen >>= _wat
06:46:43 <lambdabot>  Found hole ‚Äò_wat‚Äô with type: System.Random.StdGen -> GHC.Types.IO b
06:46:43 <lambdabot>  Where: ‚Äòb‚Äô is a rigid type variable bound by
06:46:43 <lambdabot>             the inferred type of it :: GHC.Types.IO b at Top level
06:47:02 <quchen> So you know that on the RHS of >>=, GHC expects a "StdGen -> IO b" valued function.
06:47:19 <quchen> Let's name the StdGen parameter there.
06:47:23 <quchen> > getStdGen >>= \gen -> _wat
06:47:24 <lambdabot>  Found hole ‚Äò_wat‚Äô with type: GHC.Types.IO b
06:47:24 <lambdabot>  Where: ‚Äòb‚Äô is a rigid type variable bound by
06:47:24 <lambdabot>             the inferred type of it :: GHC.Types.IO b at Top level
06:47:47 <zipper> quchen: I've never heard of typed holes.
06:48:19 <quchen> They were introduced in GHC 7.8 and they're really useful to ask "what type does this value have/what type should it have".
06:48:44 <quchen> Whenever an unbound variable starting with "_" is found, GHC prints a message like the above.
06:49:22 <quchen> So "Found hole ‚Äò_wat‚Äô with type: StdGen -> IO b" means "I found this _wat in there, and whatever you put there it should have type Found hole ‚Äò_wat‚Äô with type: StdGen -> IO b".
06:51:00 <quchen> Maybe a simpler example, suppose you have "1 + something" and you're not sure what to put in the "something" part.
06:51:03 <quchen> > 1 + _something
06:51:04 <m3rongiv1An> weird , never heard about tyoe holes either
06:51:04 <lambdabot>  Found hole ‚Äò_something‚Äô with type: a
06:51:05 <lambdabot>  Where: ‚Äòa‚Äô is a rigid type variable bound by
06:51:05 <lambdabot>             the inferred type of it :: a at Top level
06:51:50 <quchen> Oh, that doesn't look right. Uhmmm
06:51:55 <quchen> GHC you're drunk
06:52:18 <quchen> Anyway, typed holes are one of the killer features of GHC 7.8 (and I seem to have stumbled upon something weird here)
06:52:46 <barrucadu> I don't think the inferred type message includes constraints, which is unfortunate
06:54:36 <quchen> Right, the correct type for that hole would have been (Num a => a).
06:54:59 <zipper> quchen: Ok uh and why can't we just use typeclasses instead? and use f :: Typeclass =>... ?
06:55:01 <quchen> > (1::Int) + _something
06:55:02 <lambdabot>  Found hole ‚Äò_something‚Äô with type: GHC.Types.Int
06:55:25 <quchen> zipper: Instead of what?
06:55:33 <zipper> I think my issue is I have no idea what a hole is
06:55:44 <zipper> Is it supposed to represent a type?
06:55:53 <zipper> Instad of using typeholes
06:56:08 <quchen> A hole means "GHC I'm not sure what to put here, please tell me what you expect".
06:56:28 <quchen> It's a helper feature, not something found in working code.
06:56:59 <quchen> In your case, you don't know what to put on the right hand side of `makeStdGen >>=`.
06:57:12 <quchen> A hole lets you ask that in an easy way, namely by
06:57:22 <quchen> > makeStdGen >>= _whatShouldIPutHere
06:57:23 <lambdabot>  Not in scope: ‚ÄòmakeStdGen‚Äô
06:57:23 <lambdabot>  Perhaps you meant ‚ÄòmkStdGen‚Äô (imported from System.Random)
06:57:34 <quchen> > newStdGen >>= _whatShouldIPutHere
06:57:35 <lambdabot>  Found hole ‚Äò_whatShouldIPutHere‚Äô
06:57:35 <lambdabot>    with type: System.Random.StdGen -> GHC.Types.IO b
06:57:36 <lambdabot>  Where: ‚Äòb‚Äô is a rigid type variable bound by
06:58:27 <quchen> This tells you that instead of _whatShouldIPutHere, there should be a value of type StdGen -> IO b.
06:58:52 <zipper> quchen: Wow awesome
06:58:53 <quchen> \_ -> return "hello"   is such a value.
06:59:04 <quchen> :t newStdGen >>= \_ -> return "hello"
06:59:05 <lambdabot> IO [Char]
06:59:22 <quchen> Another value that fits that type would be   \gen -> return (next gen)
06:59:31 <quchen> :t newStdGen >>= \gen -> return (next gen)
06:59:32 <lambdabot> IO (Int, StdGen)
07:00:04 <zipper> quchen: I hope I don't forget about type holes
07:00:09 <quchen> Type*d* holes.
07:00:33 <quchen> It's a hole that has a type. A type hole would be, well, a hole for a type. That one comes with GHC 7.10 :-)
07:01:03 <quchen> (TypedHoles used to be called TypeHoles without "d" for some time, but this was corrected shortly before 7.8's release.)
07:01:34 <zipper> quchen: Awesome. As I read this lib I shall come back with more questions.
07:04:21 <chrisdone> quchen: callCC ftw =p
07:04:40 <quchen> chrisdone: I'm back to yesterday-at-midnight emotionally
07:04:54 <quchen> I have no idea how this thing works haha
07:05:01 <chrisdone> hahaha
07:05:14 <quchen> But since I realized I had a crappy tutorial for Cont in my articles repo I rewrote that.
07:05:19 <chrisdone> ‡≤†_‡≤∞‡≥É
07:05:25 <quchen> And it has a callCC section that's left open so far.
07:06:44 <chrisdone> ah well, being confused is a good sign you're learning something new =3
07:07:43 <quchen> Only when the confusion is in decline
07:07:52 <chrisdone> heh, rather than increasing
07:07:54 <quchen> I mean there's still Holey on the horizon somewhere
07:08:17 <quchen> So after I nail Cont (once again) I'll be concerned with indexed monads and then I can finally turn to the actual problem.
07:08:48 <chrisdone> the actual problem specifically is?
07:08:56 <quchen> How does Holey work
07:09:00 <chrisdone> ah, heh
07:09:18 <quchen> Consider me nerd sniped.
07:09:29 <quchen> I mean Holey is how much? 4 lines?
07:09:35 <chrisdone> callCC makes sense to me intuitively as i'm used to it from Scheme's call/cc, but the types gave me pause when i first saw it
07:09:44 <chrisdone> haha yeah, essentially =)
07:09:54 <quchen> I agree, using callCC is very easy
07:10:11 <quchen> But I'm having trouble understanding the implementation.
07:10:32 <quchen> I see that we inject the outer continuation into the inner one, but that's as far as my understanding goes.
07:10:39 <lpaste> bennofs pasted ‚ÄúHaskell Longest Path‚Äù at http://lpaste.net/116962
07:10:57 <chrisdone> i rememberred shachaf came up with a simpler version a couple years ago
07:11:22 <bennofs> Can this haskell program I just pasted be made faster? It's currently about 2.3x slower than the C++ version (https://github.com/logicchains/LPATHBench/blob/master/cpp.cpp)
07:11:34 <chrisdone> quchen: http://www.reddit.com/r/haskell/comments/14met7/oleg_typesafe_formatted_io/
07:11:47 <bennofs> I thought using vector, Haskell would be less than 2x C performance
07:12:16 <chrisdone> quchen: see shachaf's answer, those types might be a bit easier to grok and it uses regular function composition
07:13:21 <quchen> Needs Rank2 though
07:16:29 <quchen> Hm not rank2, but existential types ..?
07:16:35 <quchen> Well one of the forall extensions. :-D
07:17:51 <rcitu> Hi! How do I get the name of the component that is currently being built in cabal build hook?
07:19:02 <chrisdone> quchen: yeah rank-n
07:19:39 <chrisdone> rcitu: what data types do you have available?
07:20:38 <rcitu> chrisdone: signature of build hook is PackageDescription -> LocalBuildInfo -> UserHooks -> BuildFlags -> IO ()
07:21:26 <chrisdone> rcitu: hm, doesn't a build hook mean "build everything buildable"? is it really called per-component?
07:21:59 <rcitu> chrisdone: well I can run cabal as 'cabal build foo', at least according to the help
07:23:00 <chrisdone> rcitu: that sounds BuildFlags-y
07:23:23 <chrisdone> nope, nothing interesting in BuildFlags
07:23:54 <zipper> chrisdone: You're the one from the haskell cast hey o/
07:24:10 <chrisdone> zipper: hey! :3
07:25:42 <zipper> chrisdone:  The issue I had with the episode is that I don't know JS and I felt that that got in the way. WHat do you feel about typescript btw?
07:25:43 <chrisdone> rcitu: as a stab in the dark you could use allBuildInfo :: PackageDescription -> [BuildInfo] and then see which buildable :: Bool is True.
07:26:38 <sinelaw> chrisdone, hey, thanks for the haskell cast! was fun & informative
07:27:35 <chrisdone> zipper: typescript seems like a decent way to write some "low-level" JS for speed/size but still type-check it‚Ä¶ purescript seems to have similar advantages, but you could use it for more high-level code as it has a rich type system
07:28:09 <sinelaw> typescript doesn't protect against the most horrible JS bugs
07:28:18 <chrisdone> sinelaw: glad you liked =)
07:28:38 <chrisdone> sinelaw: oh? i haven't used it
07:28:59 <zipper> chrisdone: I liked it too.
07:29:01 <chrisdone> i made some non-trivial use of the google closure's type system, that was pretty decent
07:29:24 <chrisdone> zipper: \o/
07:29:29 <zipper> The one on Reactive Functional Programming had me understand just about nothing.
07:29:40 <zipper> I think I should learn more about it
07:30:15 <chrisdone> yeah, while i'm vaguely familiar with the topic, it seemed not too approachable without prior reading
07:30:40 <vanila> low level javascript :P
07:30:48 <chrisdone> but conal's great to listen to
07:31:02 <chrisdone> vanila: i "quoted" it =p
07:31:16 <sinelaw> chrisdone, typescript allows: var hoisting, implicit conversions (e.g. 1+'a' = '1a'), using 'delete' on variables, allows using the pointless 'void', doesn't abstract away the terrible 'this' behavior, etc.
07:32:23 <sinelaw> chrisdone, because TypeScript is a superset of JS, it contains all its bugs!
07:32:30 <chrisdone> sinelaw: you can consider that an advantage over purescript
07:33:07 <chrisdone> if you need to do some nastiness or take an existing codebase, typescript at least adds some analysis
07:33:25 <chrisdone> what's your intended use-case for your JS type system?
07:33:47 <chrisdone> basically purescript but retaining a subset of JS's syntax?
07:33:50 <sinelaw> chrisdone, google closure compiler does a better job. for one, the type annotations can be added as comments without breaking the tool chain (TS is not JS syntax compatible). Also, the compiler protects against more bugs
07:34:47 <chrisdone> i vaguely remember if you use a variable as more than one thing (like hoisting), clojure creates a none sum type like "X | Y". then if you try to pass it to a thing that only takes "X" it complains
07:35:17 <chrisdone> er, closure
07:35:18 <sinelaw> chrisdone, something like that. The idea of my checker is a subset of JS that is type-inferrable.
07:35:26 <sinelaw> but still valid JS
07:35:56 <sinelaw> if nobody wants to use it, maybe it could be used to verify code gen outputs :)
07:35:56 <vanila> that's a really cool idea
07:36:05 <vanila> sounds very practical
07:36:20 <vanila> is it free software?
07:36:22 <chrisdone> right. ghcjs could use it
07:36:35 <sinelaw> vanila, one big issue is getting it to work with existing code without jumping through hoops. worst case, it will be used only for new code.
07:36:55 <sinelaw> chrisdone, yeah, could be used to verify FFI bindings for example, maybe maybe maybe
07:36:58 <vanila> yeah i imagine it takes something very complex and difficult to handle existing code
07:37:06 <vanila> I think that's what gradual typing is about partly
07:37:15 <vanila> facebooks thing does that
07:37:18 <sinelaw> vanila, right. google closure does a good job at that
07:37:45 <chrisdone> i have this super fast JS that renders a hierarchical tree
07:37:52 <sinelaw> vanila, FB's thing seems like a google closure clone with +/- features, but without the syntax compatibility with plain JS (big mistake in my opinion)
07:37:52 <chrisdone> which i use from fay
07:37:53 <chrisdone> i'd like to type-check that at some point
07:38:06 <vanila> ah!
07:38:06 <sinelaw> chrisdone, link?
07:39:14 <luite> sinelaw: have you added a fallback mechanism, like an 'Any' type for things that you don't support?
07:39:40 <sinelaw> luite, no, it's not hard to add (I think) but would like to see how far you can get without it
07:40:02 <chrisdone> sinelaw: it won't compile with your thing. makes use of of `this' and DOM manipulation
07:40:11 <sinelaw> 'this' is supported
07:40:28 <chrisdone> cool =)
07:40:39 <sinelaw> I think :)
07:40:48 <chrisdone> https://gist.github.com/chrisdone/a3dee890bb5d1aa821a0
07:41:02 <luite> sinelaw: uh well, i'll probably only be actually interested in adding it if i know it doesn't completely break down in the presence of unsupported constructs :)
07:41:04 <chrisdone> we use it on fpco's ide
07:41:19 <chrisdone> originally we were using some jquery tree plugin. but it was very complicated and imperative
07:41:24 <sinelaw> chrisdone, thanks, I'll keep that as a test case when I support enough stuff
07:41:49 <chrisdone> so i just wrote this so it would be fast enough at rendering that any change to the tree would just re-render the whole thing in a couple millisecs
07:42:22 <Narfinger> hey, i am new to haskell and i want to have a function Foo: a->b and Foo: a->c->b but when i write them i just get the error of duplicate type signatures, is this not supported in haskell?
07:42:36 <sinelaw> Narfinger, not that way
07:42:53 <Narfinger> sinelaw: ok, how can i do it or can you point me to some documentation?
07:43:09 <sinelaw> Narfinger, you can get something similar with typeclasses but it won't be the same as your example.
07:43:17 <sinelaw> there is no overloading in the usual sense
07:43:49 <sinelaw> Narfinger, did you read a book / tutorial?
07:44:08 <Narfinger> mhhh ok to get a bit more concrete: my Foo: a->c->b is the main function and my Foo: d->b (sorry different type) just unpacks some stuff from a record and calls Foo
07:44:24 <Narfinger> no sorry, i try to learn by writing a small project, that is more fun
07:44:35 <Narfinger> and i have some experience in other function languages
07:45:09 <sinelaw> Narfinger, which other languages?
07:45:09 <nshepperd> hmm... if I have `newtype Foo t = Foo (Bar t)` and I have a `forall t. Foo t`, is it safe to use unsafeCoerce to extract a `forall t. Bar t`?
07:45:25 <Narfinger> lisp and some faint memories of sml
07:45:49 <sinelaw> Narfinger, I recommend you do read a bit... at least about type classes
07:45:55 <Narfinger> ok thanks
07:46:18 <sinelaw> Narfinger, this is pretty popular http://learnyouahaskell.com/types-and-typeclasses
07:47:35 <nshepperd> it seems like it should be okay, since the newtype constructor is a fiction anyway
07:47:57 <nshepperd> although
07:48:02 <sinelaw> nshepperd, but why?
07:48:08 <sinelaw> (are you doing this)
07:48:40 <SuperHotFire> Are there any websites that offers haskell tutorials? Learning the haskell system from scratch.
07:51:11 <agocorona> SuperHotFire: you mean starting from big bang theory?
07:51:24 <nshepperd> sinelaw: reimplementing the ST monad using ekmett's church encoded free monad for amusement
07:51:41 <sinelaw> nshepperd, ah :)
07:51:41 <nshepperd> sinelaw: so, I need to be able to write runST
07:52:04 <sinelaw> @where LYAH
07:52:04 <lambdabot> http://www.learnyouahaskell.com/
07:52:07 <sinelaw> SuperHotFire, ^^^
07:52:36 <SuperHotFire> LYAH, barely a turorial.. :S
07:53:00 <vanila> nshepperd, that's interesting - I would like to know if it's possible withotu unsafeCoerce
07:53:17 <vanila> nshepperd, Cale has a library that might be able to do it but I wasn't able to
07:53:48 <sinelaw> SuperHotFire, it's too long or too short?
07:54:09 <SuperHotFire> Too long, I've read it... too basic, doesn't really put the pieces together.
07:54:23 <indiagreen> there is lots of tutorials at School Of Haskell
07:54:38 <SuperHotFire> I mean, it just states several standard functions, doesn't really give me a hint what to do wit them or when you use them together.
07:55:10 <indiagreen> actually, if you want to know what to do with your functions, you might want to read a tutorial like ‚Äúhow to implement X using Haskell‚Äù
07:55:40 <indiagreen> where X is a game, or an interpreter, or a chat server, or anything which seems interesting to you
07:56:14 <sinelaw> @where RWH
07:56:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:56:17 <sinelaw> SuperHotFire, ^^^ :)
07:56:31 <sinelaw> SuperHotFire, that one's a bit more practical-oriented
07:56:33 <SuperHotFire> Hmm, I just want to know enough haskell to pass an exam.. :P
07:56:38 <indiagreen> ...ah
07:56:40 <sinelaw> SuperHotFire, can't help you with that
07:56:46 <indiagreen> should've said from the start
07:57:18 <indiagreen> then we've no idea how to help you unless you can describe your curriculum
07:57:48 <chrisdone> i'm working on a question-answer library for haskell for learning =)
07:59:53 <zipper> What do you guys suggest I read in readiness for Google Summer of Code next year?
08:01:17 <sinelaw> zipper, what's you project?
08:01:36 <sinelaw> *your project. do you have any idea? I don't even know if stuff has been assigned.
08:02:47 <gri_> der Haskellers, what might be a nice solution for reducing an ADT with a lot of constructors?
08:02:49 <nshepperd> vanila: oh, looks like I didn't actually need unsafeCoerce
08:03:22 <nshepperd> vanila: apparently pattern matching on the newtype constructor doesn't work, but using the newtype accessor (with record syntax) does
08:03:50 <gri_> is there a way to avoid passing along all those functions for each constructor?
08:05:08 <zipper> sinelaw: I have no idea
08:05:17 <zipper> All I'm doing is relearning haskell
08:05:46 <sinelaw> zipper, then I guess just learn what interests you. or find someone running a SoC project and ask them.
08:06:07 <dfeuer> int-e, thanks for pointing out the non-redundancy of `sm`.
08:06:28 <dfeuer> @tell int-e Thanks for pointing out the non-redundancy of `sm`.
08:06:28 <lambdabot> Consider it noted.
08:06:50 <dfeuer> nshepperd, work for what?
08:07:06 <dfeuer> gri_, if you give more details, you might get better answers.
08:07:21 <dfeuer> A proper example would help.
08:07:30 <gri_> dfeuer: thanks, just a sec
08:07:34 <dfeuer> If you can put it on lpaste.net, that would be bestest.
08:08:43 * dfeuer unsafely coerces nshepperd.
08:09:05 <int-e> dfeuer: see also  https://github.com/int-e/containers/compare/ap
08:10:07 <dfeuer> int-e, that's the sort of representation I was thinking about, yeah, but I was having trouble holding enough of it in my head at once.
08:10:12 <gri_> dfeuer: http://lpaste.net/116965 - a simple ADT
08:10:17 <nshepperd> dfeuer: extracting a `forall t. Inner t` from a `forall t. Wrap t`, where `newtype Wrap t = Wrap { unWrap :: Inner t }`
08:10:34 <int-e> dfeuer: (Proof of concept. I have not yet followed the size arithmetic.)
08:10:45 <gri_> dfeuer: I‚Äôm trying to implement a generic reduce, i.e. replacing each of the constructor by a function
08:10:58 <dfeuer> int-e, I was just looking at your ApState declaration.
08:11:54 <dfeuer> nshepperd, you've got me a bit confused with all the foralls. What are they for?
08:12:07 <int-e> dfeuer: in any case, this part of the code does not seem very performance critical, so the question is, does reducing the redundancy make the code easier to understand...
08:12:30 <nshepperd> dfeuer: runST
08:12:35 <dfeuer> int-e, yeah. My *guess* is that the approach of just replacing the middle tree with !Int is going to be easier to understand.
08:12:42 <dfeuer> But that might depend on the reader.
08:13:09 <arjanb> gri_: you could introduce a constructor and datatype for binary operations
08:13:24 <dfeuer> arjanb++
08:13:41 <dfeuer> And for consistency, one for unary ones too.
08:13:48 <gri_> arjanb: ok, I see - than implement reduce just for binaries and use it in reduce for Expr?
08:13:56 <arjanb> yep
08:13:57 <dfeuer> Yep.
08:14:16 <dfeuer> int-e++
08:14:56 <gri_> beeing a newbie with H, a followup q: reduce for bins/unitaries would then have to call reduce for Expr?
08:14:58 <int-e> dfeuer: it's also possible that the prl/sfr arguments should never be passed in in the first place; instead, the Deep (sl + sr + sm * size fs) (fmap firstf prl) ... ToNode prm) `consTree`  fmap (fmap lastf) mm))
08:15:04 <int-e> argh.
08:15:10 <besenwesen> is there a way to define a lazy list of all real numbers?
08:15:17 <dfeuer> int-e, the main performance issue with the code (by far) is that it can potentially produce badly balanced trees. Unfortunately, I don't think it's possible to avoid that without breaking the desired asymptotic bounds for incremental use.
08:15:21 <int-e> dfeuer: ... (fmap lastf sfr)  part could be left to the caller.
08:15:22 <barrucadu> besenwesen: No, there are uncomputable reals
08:16:07 * int-e will try that.
08:16:09 <barrucadu> besenwesen: http://math.stackexchange.com/questions/58036/are-some-real-numbers-uncomputable
08:16:11 <dfeuer> barrucadu, that's getting into too much detail.
08:17:00 <vanila> besenwesen, no there are a bigger infinity of reals than natural numbers
08:17:04 <dfeuer> Aside from some reals being uncomputable, the set of real numbers is plain old *uncountable*, so no list of any sort could contain all of them.
08:17:12 <vanila> and a list can only have 'natural number'-many elements
08:17:15 <vanila> computabiltiy is irrelevant here
08:17:33 <besenwesen> mh, pity. i was trying to memoize something
08:17:43 <dfeuer> besenwesen, details!
08:17:55 <barrucadu> Maybe there's an approach other than having every real at your disposal
08:18:03 <dfeuer> besenwesen, general real numbers rarely are needed.
08:18:08 <dfeuer> [in computer programming]
08:18:11 <besenwesen> to store a map of previous results. it seemed elegant, for ints, to just map the whole space, and have things computed when needed
08:18:13 <dfeuer> Very very rarely.
08:18:28 <dfeuer> besenwesen, what are you actually trying to do?
08:18:31 <besenwesen> i suppose with a space from reals, i‚Äôll have to explicitly manage a map and pass it when recursing
08:18:46 <dfeuer> besenwesen, how are you even representing these reals?
08:18:52 <besenwesen> i‚Äôm trying to store intermediate computations which will be needed in later recursion steps
08:19:10 <besenwesen> i have a structure that is a map from strings to probabilities
08:19:19 <dfeuer> Probabilities represented how?
08:19:23 <besenwesen> and a function from these maps to new maps
08:19:34 <besenwesen> reals in the interval 0 to 1
08:19:52 <besenwesen> stole a smart constructor from stack overflow
08:20:17 <zipper> sinelaw: Any idea who may be running a SOC project?
08:20:28 <dfeuer> int-e, if you're going to leave the initial deconstruction to the caller, consider making Digit12 and Digit23 proper types instead of synonyms. I tried to do that initially, but realized that it would require duplicating a good bit of logic just to deal with the topmost level of the tree.
08:20:53 <athan> What is a [safe] instance?
08:21:06 <dfeuer> But if you're going to do that anyway, using such types should add a lot of "obvious correctness" while only reducing speed a drop.
08:21:33 <dfeuer> besenwesen, how are you representing a single real number in the interval from 0 to 1?
08:22:08 <dfeuer> athan, context?
08:22:09 <besenwesen> dfeuer, sorry, float ;‚Äì; always mix up types of numbers
08:22:13 <gri_> arjanb: but won‚Äôt I still have to carry around a function for each constructor fo binary ops when implementing reduce for Exprs?
08:22:25 <dfeuer> besenwesen, Floats are *not* general real numbers at all.
08:22:32 <athan> dfeuer: The instance declarations of `Testable` in QuickCheck :s
08:22:33 <besenwesen> dfeuer, but the thing about being unable to define a lazy set of all floats still holds, does it?
08:22:38 <dfeuer> They're also rarely what you want for anything.
08:22:51 <sinelaw> zipper, sorry, I don't know but I google for the 2014 SoC info and find out who was involved last year
08:22:52 <dfeuer> You *can* define a lazy structure with all Floats or all Doubles, yes.
08:23:00 <sinelaw> zipper, also you could mail the haskell mailing list
08:23:02 <dfeuer> It will be very large.
08:23:11 <sinelaw> *I suggest you google :)
08:23:13 <dfeuer> But you can do it with no theoretical trouble.
08:23:16 <zipper> sinelaw: Thanks a ton
08:23:32 <sinelaw> no sweat
08:24:12 <gri_> dfeuer, arjanb: do you think there is a good example of how to implement a reduce function for ``nested‚Äô‚Äô ADTs?
08:24:13 <besenwesen> uh, how so? i guess when i just need to map a few float values, that won‚Äôt work well
08:24:28 <dfeuer> besenwesen, in the next version of the containers package, you will be able to use the newly-introduced `fromFunction` function to make a memoization table large enough to contain all the Floats. I'm not sure it'll accommodate all the Doubles.
08:24:47 <dfeuer> besenwesen, if you just need a few, this will be very inefficent.
08:25:31 <besenwesen> dfeuer, so the best way would be to pass a mapping into the function, and the function tries looking up previous results for some computation, adding them if needed, and passing a modified map on?
08:25:41 <dfeuer> gri_, yes, you should look around Hackage for Foldable instances.
08:25:55 <gri_> dfeuer: thanks a lot
08:26:03 <aijoe> hi all
08:26:06 <dfeuer> besenwesen, everything depends on what you're really actually trying to do.
08:26:31 <dfeuer> Also, I'm not an expert.
08:27:27 <besenwesen> well, i have a function that computes something and might recurse. within the recursion, sometimes i‚Äôll have to compute the same thing again. so i‚Äôd like to store results
08:27:33 <dfeuer> gri_, I'm pretty familiar with the ones in Data.Sequence, but those are "non-regular" data types, and will probably give you headaches or nightmares.
08:28:32 <besenwesen> and the computation which i want to store is Map String Float ‚Üí Map String Float
08:28:32 <gri_> dfeuer: I‚Äôm trying to look up just by googling, thank you for pronouncing the ``foldable‚Äô‚Äô word - it really seems to be what I need
08:28:41 <dfeuer> besenwesen, yeah, it sounds like passing a Map or some sort of trie through the recursion would probably make sense. Consider structuring this as a fold or using the State monad.
08:29:02 <besenwesen> dfeuer, right, state would make it more readable. thanks!
08:29:15 <dfeuer> besenwesen, always think twice about Map String _; long strings can be expensive to compare.
08:29:17 <ph88> hi guys
08:29:48 <gri_> dfeuer: what I‚Äôm trying to do is to emit code in different languages (Matlab, Latex, Python etc.) for my Exprs
08:29:49 <besenwesen> dfeuer, is Text better? i‚Äôll still need to look into that
08:29:49 <ph88> i used to put print in my main function, but now when i use fmap i see output without using print, why is this ?
08:30:07 <dfeuer> gri_, now you're reminding me of what johnw was talking about yesterday: free monads.
08:30:24 <gri_> dfeuer: and the problem I‚Äôm facing is that in LaTeX, for instance, a fraction is not always just a ``/‚Äò‚Äô between two exprs
08:30:25 <dfeuer> besenwesen, Text is better for certain purposes, but not so much for Map keys.
08:30:31 <gri_> dfeuer: I‚Äôm sorry I missed that
08:30:41 <dfeuer> Map keys should be things that are efficient to compare.
08:30:50 <besenwesen> i guess i could transform the map so that it maps ints
08:31:23 <dfeuer> besenwesen, how long are your strings? Some sort of trie structure may be appropriate if they can be long. Otherwise, consider hashing.
08:31:42 <besenwesen> very short. just labels for nodes in a graph, really
08:32:21 <dfeuer> gri_, he pointed me to an example in his code here: https://github.com/jwiegley/linearscan/blob/master/test/Test.hs#L248
08:32:39 <dfeuer> besenwesen, well, if they're short it doesn't matter.
08:32:44 <dfeuer> A Map will be fine.
08:32:51 <dfeuer> If they're arbitrarily long, that's another story.
08:33:01 <dfeuer> But if they're all known in advance, why not use an enum type?
08:33:21 <dfeuer> data Label = ThisLabel | ThatLabel | Bob'sLabel | SexyLabel
08:33:26 * hackagebot hasql-postgres 0.9.0 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.9.0 (NikitaVolkov)
08:33:34 <gri_> dfeuer: thanks a lot for the link
08:33:37 <dfeuer> NP.
08:33:42 <besenwesen> dfeuer, i sort of have this Graph value constructor, and i might want to construct graphs with arbitrary node labels
08:33:45 <gri_> dfeuer: I‚Äôve got a lot to read up now
08:33:54 <dfeuer> gri_, as do I!
08:34:00 <besenwesen> i guess i could make a type class
08:34:12 <endiruna> what is a good book to begin with haskell?
08:34:19 <dfeuer> besenwesen, no, probably not.
08:34:30 <dfeuer> @where lyah
08:34:31 <lambdabot> http://www.learnyouahaskell.com/
08:34:37 <dfeuer> endiruna, ^
08:34:44 <dfeuer> @where learnhaskell
08:34:44 <lambdabot> I know nothing about learnhaskell.
08:34:49 <dfeuer> gr
08:35:00 <gri_> dfeuer: but I‚Äôm still confused by the fact that my BinOps are parameterized by Exprs and my Exprs involve BinOps ctors
08:35:08 <bananagram> https://github.com/bitemyapp/learnhaskell
08:35:12 <gri_> dfeuer: as you suggested
08:35:13 <dfeuer> Yeah that.
08:35:35 <dfeuer> gri_, not parameterized by them. Just stick one inside the other.
08:36:09 <endiruna> thanks!
08:36:27 <ph88> hey guys, i used to use print before in my main function but ever since i started using fmap i see results without using print, why is that ?
08:36:37 <dfeuer> gri_, I seem to have misplaced the link to your thing.
08:36:42 <gri_> dfeuer: yes, thank you ‚Äî do I see it correctly that I have to make them both foldable?
08:36:50 <gri_> dfeuer: the github one?
08:36:58 <barrucadu> ph88: Example code?
08:37:19 <dfeuer> gri_, yeah, the sample.
08:37:44 <gri_> dfeuer: are you going to be there in 5 mins? Need to attend to smth in the kitchen before it burns
08:37:55 <dfeuer> Probably.
08:38:09 <ph88> barrucadu: amp g = fst (randomR (0 :: Double,1) g)       main = do    fmap amp getStdGen
08:40:43 <ph88> hmm
08:40:47 <barrucadu> Hmm, run `runhaskell` I get a result printed, but not when explicitly compiling with ghc and then running the binary
08:41:01 <barrucadu> I guess runhaskell treats main specially if it's not returning ()?
08:43:13 <ph88> barrucadu: that's right i was using runhaskell
08:45:20 <ph88> so in any case it's because i implicitely return the result of the fmap in the main's do-block ?
08:45:27 <barrucadu> Looking at runghc.hs on github, it looks like it's using the same evaluator as ghci, eg I see a ":set" in there
08:45:34 <barrucadu> And ghci does print the results of expressions, if it can
08:45:43 <Flonk> can you use cabal to install the newest ghc, or is that simply not how it works?
08:45:49 <barrucadu> It's not an implicit return - that's what main evaluates to
08:45:58 <barrucadu> main :: IO Double
08:46:58 <ph88> well if i put "return ()"  then i don't see anything anymore
08:47:03 <ph88> so i think   fmap amp getStdGen     is the same as    return fmap amp getStdGen
08:47:36 <barrucadu> "return" is a horrible name, because it's not an imperative-language-like return
08:47:40 <barrucadu> :t return
08:47:41 <lambdabot> Monad m => a -> m a
08:47:48 <barrucadu> It simply puts a value into a monad
08:47:51 <ph88> barrucadu: i'll be right back i need to switch the laptop battery
08:49:19 <barrucadu> "do { fmap amp getStdGen; return () }" is syntactic sugar for "fmap amp getStdGen >> return ()", where ">>" discards its first argument.
08:49:43 <barrucadu> You could write "do { return (); fmap amp getStdGen }" and get the same behaviour as before, the "return" doesn't terminate evaluation
08:49:50 <joe9> I am trying to use Text.JSON.Generic to parse a string where the field names are not quoted. (output here: http://www.google.com/finance/option_chain?q=GOOG&output=json&expy=2014&expm=12&expd=26 ) .  http://codepad.org/lSlgKShe is my attempt at it. http://codepad.org/jrUi5lJq is the error
08:50:14 <joe9> can anyone please help? Is it possible to use Text.JSON or Aeson to parse json with unquoted names?
08:50:44 <ph88_> bartavelle: how can i print the results of fmap? i get an error with this now
08:50:53 <ph88_> barrucadu *
08:51:13 <barrucadu> :t print
08:51:14 <lambdabot> Show a => a -> IO ()
08:52:50 <barrucadu> So, "fmap amp getStdGen" gives you a value of type "IO Double", but print needs the Double out of that
08:53:00 <barrucadu> Fortunately, we have a function for that
08:53:02 <barrucadu> :t (>>=)
08:53:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:53:35 <barrucadu> (>>=) (pronounced "bind") extracts a monadic value, applies a function to it, and then returns it.
08:53:51 <barrucadu> So we can write "fmap amp getStdGen >>= print"
08:53:51 <gri_> dfeuer: so do you think you sent me the correct link?
08:53:52 <ph88_> and repacks in a new monad ?
08:54:07 <dfeuer> gri_, I thought so. Search it for "free"
08:54:09 <barrucadu> The do-notation equivalent would be "do { foo <- fmap amp getStdGen; print foo }"
08:54:31 <ph88_> what's <- anyway ?
08:54:34 <barrucadu> Not so much packing, look at the second argument of (>>=) -- the function already handles the packing
08:54:57 <barrucadu> "do { foo <- bar; ... }" is syntactic sugar for "bar >>= \foo -> ..."
08:55:29 <ph88_> oh i thought the latter was syntactic sugar for the latter
08:55:41 <ph88_> i also saw it used in generators
08:57:27 <barrucadu> In [x | x <- xs] it can be read as "x takes every value from xs"
08:57:51 <barrucadu> It is actually the same <-, in the list monad, but that's not really important
08:58:27 * hackagebot hasql 0.5.0 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.5.0 (NikitaVolkov)
08:58:47 <ph88_> thx
08:58:51 <ph88_> be right back !
09:00:15 <wei2912> i wonder who came up with the do notation
09:00:24 <wei2912> it seems like a great solution
09:00:45 <Flonk> > [x | x <- Just 4]
09:00:46 <lambdabot>  Couldn't match expected type ‚Äò[t]‚Äô
09:00:46 <lambdabot>              with actual type ‚ÄòData.Maybe.Maybe a0‚Äô
09:01:10 <Flonk> Huh. Not sure what I expected to happen there
09:01:53 <exio4> MonadComprehesions isn't enabled in lambdabot,
09:03:29 <Flonk> exio4: Oh, there is an extension for that?
09:03:37 <exio4> yes, https://ghc.haskell.org/trac/ghc/wiki/MonadComprehensions
09:05:50 <dfeuer> Ping int-e
09:05:58 <Flonk> exio4: That actually sounds pretty useful
09:06:28 <int-e> dfeuer: yes?
09:06:59 <dfeuer> I was just wondering if you figured out a way to streamline it that's easier, rather than harder, to understand. And if you got my message about Digit12 and Digit23.
09:07:26 <int-e> dfeuer: I think so, I'm testing and cleaning up...
09:09:34 <dfeuer> int-e, to test, run cabal configure --enable-tests and then in dist/build/seq-properties, run seq-properties -j2 -t "<*>"  --maximum-unsuitable-generated-tests=3000 -s20 -a 2000   (and adjust -s upwards and -a downwards a few times)
09:10:27 <dfeuer> The test suite checks all the size annotations,as well as the elements.
09:14:31 <phaazon> hi
09:14:45 <phaazon> edwardk, there‚Äôs a weird behavior with your either package and my monad-journal
09:14:47 <int-e> dfeuer: done and pushed
09:14:48 <phaazon> see https://github.com/phaazon/monad-journal/issues/12
09:15:00 <dfeuer> int-e, I'll take a look.
09:15:01 <int-e> dfeuer: I could get rid of the ApState thing completely.
09:15:08 <phaazon> the issue is that cabal install --only-dependencies doesn‚Äôt install the latest either pacakeg
09:15:12 <phaazon> package
09:15:15 <phaazon> and I don‚Äôt get why
09:15:18 <dfeuer> int-e, well, yeah, just add more arguments.
09:15:18 <phaazon> I have to do something like
09:15:24 <phaazon> cabal install 'either-4.3'
09:15:27 <int-e> dfeuer: I mean, I did.
09:15:35 <int-e> dfeuer: without increasing the number of arguments
09:15:42 <dfeuer> Ooh. I will look now.
09:15:50 <phaazon> any one who knows that bug of cabal?
09:17:22 <bergmark> phaazon: there could be multiple reasons, what if you do --only-dependencies --constraint='either==4.3.2.1' --dry-run?
09:17:27 <ph88> would it be a good idea to combine these two functions, so that i can get rid of the wrapper function?      1.    inner x g = x * fst (randomR (0 :: Double,1) g) * x     2.   wrapper x = fmap (inner x) getStdGen
09:17:46 <phaazon> bergmark, that sounds weird
09:18:01 <phaazon> I‚Äôve always installed dependencies with cabal install --only-dependencies
09:18:03 <dfeuer> int-e, I still have much to read, but it's annoying that GHC complains if that impossible case is removed. By all rights it should be able to tell that it's impossible.
09:18:15 <phaazon> I don‚Äôt even get why cabal handles packages so weirdly
09:20:31 <phaazon> hm
09:20:54 <phaazon> I guess the error is that, now, we have a difference between type families and data families
09:21:01 <phaazon> I‚Äôll inquire about that later
09:24:55 <quchen> chrisdone: Sooo you probably know the reverse State Monad.
09:25:27 <quchen> I noticed something in the Cont Applicative. lalala: cf <*> cx = Cont $ \k -> runCont cx $ \x -> runCont cf $ \f -> k (f x)
09:25:40 <quchen> Meet the reverse Cont Applicative.
09:26:33 <quchen> I don't think that forms a Monad though, which is a pity.
09:26:46 <dfeuer> int-e, i'm still working through your code, but I am optimistic that it will be possible to make the type change I mentioned. Specifically, since you take care of the first and last digits right in apty, all the digits stripped off in aptyMiddle should be Ones and Twos, and can be represented as such, changing the type of thin.
09:27:41 <int-e> dfeuer: probably. I cannot do more than one refactoring step at a time :P
09:28:24 <dfeuer> int-e, like I said, I'm still reading it. The levels are weirder than in my version, but that may be okay. Yours is a lot shorter, which is a good thing.
09:29:07 <ph88> are there several ways to combine these functions into one function?   http://pastebin.com/1Mxrq9Jh
09:29:13 <int-e> dfeuer: you can also look at the individual patches in that branch, that way the relation to the original code should be clearer.
09:29:16 <quchen> Actually, that reverse Applicative might be equivalent to the normal one. The transformer version would show a different order of effects though. Even more devious.
09:31:28 <int-e> dfeuer: In any case feel free to take those changes and squash them into your commit.
09:31:54 <dfeuer> int-e, if Milan is okay with it, I'd prefer to submit one pull request with both commits.
09:32:05 <dfeuer> But he can be fussy.
09:32:09 <dfeuer> We'll see.
09:32:26 * dfeuer prefers to give credit where credit is due.
09:33:21 <dfeuer> int-e, quick question: how do I go about pulling your commit into my branch? I know very very little about git.
09:33:34 <int-e> dfeuer: Well I have 7 patches now, that's a bit excessive.
09:33:54 <dfeuer> int-e, yes, I think I know how to squash those.
09:34:00 <dfeuer> (with each other.)
09:35:00 <int-e> dfeuer: in principle, you could just  git pull  github.com:int-e/containers ap, though I'd prefer to  git remote add int-e github.com:int-e/containers  followed by  git remote update  and some local merging with the new  int-e/ap  branch.
09:35:27 <dfeuer> remote update?
09:35:53 <int-e> hmm.  git fetch  is essentially the same?
09:36:09 <dfeuer> I don't know.
09:36:35 <geekosaur> iirc git fetch is git remote update on the branch you're tracking followed by a merge with the local copy
09:36:41 <int-e> dfeuer: both update the remote branches from their source repos, without touching the local ones.
09:36:56 <quchen> geekosaur: Isn't that 'git pull'?
09:37:05 <geekosaur> mmm, right
09:37:06 <int-e> oh, right. fetch does update remote-tracking branches.
09:37:15 <OutlawStar> hello, I'm trying to compile ghc 7.8 and it can't seem to find deepseq 1.3, even though its listed by ghc-pkg. Any ideas?
09:37:17 <quchen> fetch only gets the remote branches
09:37:25 <quchen> I always remember "pull = fetch + merge/rebase"
09:37:33 <quchen> or FF or whatever. Something that moves my branches.
09:37:39 <geekosaur> anyway, yes, remote update is one of the lower level operations hiding behind fetch / pull
09:38:02 <int-e> quchen: the manpage says "Remote-tracking branches are updated [...]", now I'm confused. Sigh.
09:38:15 <quchen> int-e: Sure, the *remote* branches move.
09:38:27 <dfeuer> There seems to be a reason I find git confusing.
09:38:31 <geekosaur> int-e, git is showing its internals
09:38:58 <quchen> "git pull" will also move your own branches along with them. If you pull "master", it'll a) get the newest REMOTE/master, and b) move your master to that commit.
09:39:15 <quchen> If you fetch, all you get is a moved remote branch
09:39:21 <quchen> At least in my working experience.
09:39:43 <dfeuer> So what is it that I want to do to get int-e's commits on my machine so I can play with them?
09:39:54 <int-e> geekosaur: no, a remote tracking branch is a local branch that is set up to track a remote branch (e.g. created by  git checkout -b foo remote/baz).
09:40:02 <dfeuer> And add them to my branch etc.
09:40:12 <SuperHotFire> I have a question regarding haskell
09:40:16 <int-e> anyway, this is probably the wrong channel for this :/
09:40:48 <SuperHotFire> Can I just put out my question in the air and wait for someone to answer it? Sounds about right.
09:40:50 <geekosaur> int-e, except when it means the "hidden" branch remote/origin/somebranchname that is a local "copy" of a remote branch somewhere
09:40:57 <barrucadu> SuperHotFire: Don't ask to ask, just ask
09:41:07 <geekosaur> SuperHotFire, yes, and if you don't get an answer here consider subscribing tot he haskell-cafe mailing list and asking there
09:41:10 <Modius> I was going to ask to ask to ask
09:41:11 <dfeuer> SuperHotFire, that is generally the right way.
09:41:41 <SuperHotFire> Thinking recursively, asking to ask. That's about what haskell..is.
09:41:49 <dfeuer> int-e, I get "could not fetch int-e"
09:41:49 <SuperHotFire> Ok, now for the million dollarz question.
09:41:57 <quchen> > "C" ++ fix ("an I ask whether I c" ++)
09:41:58 <lambdabot>  "Can I ask whether I can I ask whether I can I ask whether I can I ask wheth...
09:42:20 <quchen> (Additional "I" for style purposes or something.)
09:42:56 <SuperHotFire> uwotmate :: Integer -> Integer
09:43:26 <SuperHotFire> If i have a list, and decide to split it, does this mean there will be ONE MORE element or what?
09:44:30 <quchen> SuperHotFire: I don't understand the question.
09:45:03 <SuperHotFire> (x:xs) == 2 elements || 1 element?
09:45:36 <quchen> x:xs has at least one element, that's all you can say about it.
09:46:04 <quchen> (x is that element. xs is the rest of the list.)
09:46:26 <SuperHotFire> Oh, I don't mean element. Sorry guys, I meant if I had to put out ONE EXTRA integer/string if I decide to split the list, another instance to save the splitted part in.
09:46:49 <quchen> What do you mean with "split"?
09:47:12 <quchen> What is it what you want to do anyway?
09:47:31 <SuperHotFire> (x:xs), does x and xs require two integers to be save in (or string, a etc)
09:47:44 <SuperHotFire> I don't know, just asking.
09:48:44 <quchen> Maybe describe your question in words, not Haskell code. There are a lot of terms there that don't belong together.
09:49:29 <ph88> quchen: can i ask you about the two functions i want to combine?
09:49:49 <ab9rf> i am unusually confused by the recent discussion
09:49:50 <quchen> ph88: You can ask anyone, sure
09:50:14 <ph88> well i did 20min ago, dont want to be spamming the channel
09:50:27 <quchen> This one? http://pastebin.com/1Mxrq9Jh
09:50:30 <ph88> i wanted to know if there are several ways to combine these two functions http://pastebin.com/1Mxrq9Jh
09:50:52 <quchen> Depends on what you mean with "combine". And what you want your code to do.
09:51:04 <ab9rf> there are many combinators :)
09:51:26 <ph88> 2 functions become 1 function
09:51:35 <ph88> i want it to do exactly the same
09:52:35 <quchen> You can use a 'let' to do this for you. http://lpaste.net/116967
09:53:29 * hackagebot stackage 0.2.1.2 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.2.1.2 (MichaelSnoyman)
09:53:37 <ph88> ah interesting !
09:54:01 <ab9rf> you just discard the updated generator
09:54:05 <ph88> thanks quchen
09:54:08 <ph88> if you know any other ways, -just for practice- would love to know too
09:54:13 <tempay> where's a good place to learn about concurrency in haskell?
09:54:17 <ab9rf> you realize that code will just generate the same random generator over and over again
09:54:19 <quchen> tempay: Marlow's book!
09:54:22 <ab9rf> er, random number
09:54:27 <quchen> @google marlow concurrent parallel
09:54:29 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
09:54:29 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
09:54:33 <ph88> ab9rf: eh no don't realise ??
09:54:56 <tempay> quchen: cool, I'll go get started :)
09:55:32 <quchen> tempay: Marlow used to be one of the core GHC authors, so he has some pretty deep knowledge of everything. It's quite a good book.
09:56:08 <ph88> quchen: maybe another solution would be a lambda ?
09:58:17 <quchen> ph88: Maybe. That code isn't very readable though, I'm not sure what its purpose is.
09:58:25 <quchen> Do you simply want to generate a random Double?
09:59:09 <quchen> It would help to decouple the random number generation from the multiplication with x too
09:59:59 <ph88> quchen: well actually i have that pushed down into another function, but i needed x in there because it resembles more my original function
10:02:56 <quchen> Please describe the problem you're trying to solve, not how you attempted to solve it. It's hard to guess the former from the latter.
10:04:07 <ph88> quchen: the entire problem ?
10:04:18 <ph88> quchen: the purpose of the program ?
10:04:24 <quchen> The purpose of that code snippet.
10:04:45 <ph88> it's just a dummy code for me to understand some things
10:05:31 <ph88> quchen: my train is arriving, got to go. thanks for the help
10:09:56 <chrisdone> ph88: platform 8 and 3/8ths? =p
10:13:30 * hackagebot HaTeX 3.16.0.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.16.0.0 (DanielDiaz)
10:13:32 * hackagebot hs-bibutils 5.5 - Haskell bindings to bibutils, the bibliography  conversion utilities.  http://hackage.haskell.org/package/hs-bibutils-5.5 (AndreaRossato)
10:20:22 <chrisdone> shellcheck seems like a nice popular haskell project
10:21:43 <quchen> chrisdone: Are you referring to the recent HN post?
10:24:32 <chrisdone> someone linked it internally, but it has a bunch of github stars
10:32:57 <tasker> I need to resize a load of different image formats. What libraries should I be looking at ?
10:33:09 <Chathurga> Oh that's written in Haskell, that's cool. Saw it on Reddit
10:33:10 <tasker> (a load of different files in different image formats*)
10:33:23 <Chathurga> Gonna check out the source now
10:34:59 <flebron> Hi. Is there a more idiomatic way of saying \x -> (f x) >> return x?
10:35:45 <mauke> I don't think so
10:35:58 <mauke> you can slightly generalize to \x -> f x *> pure x
10:36:20 <mauke> :t \x -> ?f x *> pure x
10:36:21 <lambdabot> (?f::b -> f a, Applicative f) => b -> f b
10:36:56 <arjanb> @pl \x -> (f x) >> return x
10:36:56 <lambdabot> liftM2 (>>) f return
10:37:00 <glguy> x <$ f x
10:37:04 <Chathurga> shellcheck has a comment "I apologize for nothing!" and then a function called lolHax
10:37:57 <flebron> Thanks :)
10:38:30 <mauke> :t (<$) <*> ?f
10:38:31 <lambdabot> (?f::a -> f b, Functor f) => a -> f a
10:43:31 * hackagebot cabal-src 0.2.4 - Alternative install procedure to avoid the diamond dependency issue.  http://hackage.haskell.org/package/cabal-src-0.2.4 (MichaelSnoyman)
10:47:02 <benzrf> mauke: oh nice
10:50:24 <hexagoxel> (<$$>) was the most-agreed-on flip of (<$>), right?
10:51:09 <benzrf> nonsense
10:51:13 <mauke> <&>?
10:53:04 <hexagoxel> benzrf: ?
10:54:08 <hexagoxel> mauke: ty
10:54:43 <quchen> hexagoxel: <**> is not flip (<*>)!
10:55:14 <quchen> (<**>) has the same order of effects as <*>, but the functiony parameter is in the second argument here.
10:55:29 <hexagoxel> good point
10:56:41 <benzrf> :t (<**>)
10:56:42 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
10:56:45 <benzrf> ah yes
11:03:32 * hackagebot appc 0.0.2 - app container types and tools  http://hackage.haskell.org/package/appc-0.0.2 (wereHamster)
11:06:14 <hexagoxel> `listToMaybe . catMaybes` or `getFirst . mconcat . map First`?
11:07:08 <vanila> safeHead [] = Nothing ; safeHead (x:_) = Just x
11:07:13 <dmj`> Fuuzetsu: ping
11:07:44 <glguy> :t ala First foldMap
11:07:44 <lambdabot> Foldable t => t (Maybe b) -> Unwrapped (First b)
11:08:07 <dmj`> do cpp flags break haddock?
11:08:13 <glguy> But I'd probably just recommend your first alternative
11:09:02 <vanila> oh I misunderstood the examples
11:09:23 <glguy> > ala First foldMap [Nothing, Just True, Just False]
11:09:25 <lambdabot>  Just True
11:12:10 <Flonk> :t ala
11:12:11 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
11:12:33 <Flonk> :(
11:13:05 <glguy> It's the automatic version of
11:13:12 <glguy> :t au
11:13:13 <lambdabot> AnIso s t a b -> ((s -> a) -> e -> b) -> e -> t
11:13:52 <chrisdone> that clarified it
11:13:58 <chrisdone> =p
11:14:16 <Flonk> > 1
11:14:17 <lambdabot>  1
11:14:17 <glguy> :t foldMap
11:14:18 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
11:14:37 <glguy> It takes an Iso and something like foldMap
11:14:59 <glguy> :t traverse
11:15:00 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:15:19 <glguy> Or traverse or mapM etc. This pattern happens a lot
11:19:21 <hrnz>  
11:19:30 <Flonk> Which module is ala from?
11:20:29 <hexagoxel> ah, so alternative 2 is `getFirst . foldMap First`
11:21:03 <zipper> Apparently you can't take a value out the IO monad and then perform computations on it and wrap it in a list monad.
11:21:07 <zipper> For example
11:21:11 <zipper> :t returns
11:21:12 <lambdabot>     Not in scope: ‚Äòreturns‚Äô
11:21:12 <lambdabot>     Perhaps you meant one of these:
11:21:12 <lambdabot>       ‚Äòreturn‚Äô (imported from Control.Monad.Writer),
11:21:13 <glguy> Flonk: comes from lens
11:21:24 <zipper> :t randoms
11:21:25 <lambdabot> (Random a, RandomGen g) => g -> [a]
11:21:37 <zipper> :t getStdGen
11:21:38 <lambdabot> IO StdGen
11:21:58 <Flonk> glguy: Everything comes from lens, I should probably start looking into it
11:21:58 <zipper> One can't getStdGen >>= randoms
11:22:20 <Chathurga> getStdGen >>= return . randoms
11:22:38 <glguy> Use newStdGen for than
11:22:43 <hexagoxel> glguy: thanks for the pointer, even if i am not using ala for now :)
11:22:44 <glguy> That*
11:22:56 <zipper> Chathurga: but randoms returns a list monad. Why do I have to wrap it in another monad?
11:23:02 <zipper> Chathurga: I assume IO moand
11:23:09 <zipper> :t newStdGen
11:23:10 <lambdabot> IO StdGen
11:23:12 <glguy> Hexagoxel: if you explore more later come ask in -lens
11:23:21 <Chathurga> zipper: You're not really allowed escape the IO Monad
11:23:41 <zipper> glguy: Why should newStdGen be different from getStdGen?
11:23:52 <glguy> Flying now chat later!
11:23:53 <zipper> Chathurga: Oh so this applies only to IO monad?
11:24:40 <Chathurga> zipper: It's a special behavior of IO yes, other types can have it too though
11:25:19 <Chathurga> But it's okay to deal with, that's why Functor etc exist
11:25:52 <Chathurga> You can apply functions to the things inside monads quite easily
11:26:52 <Chathurga> You might have something like: fmap (f . randoms) getStdGen >>= print
11:32:59 <flebron> If I've got a newtype X = X Integer, what's the easiest way to have a function f :: Integer -> Integer be raised to f :: X -> X?
11:33:20 <flebron> (Other than straight up writing \(X t) -> X (f t))
11:34:15 <shiona> umm, not sure if it's a good idea, but I guess you could write instance Num X
11:35:39 <athan> Will -XOverloadedRecordFields be available in 7.10?
11:36:13 <athan> nvm, I'll ask on #ghc
11:37:26 <geekosaur> does generalized newtype deriving work with Num?
11:38:04 <lain1> So in emacs if I use completion-at-point during a getLine call it causes emacs to hang. company-mode is calling completion-at-point automatically which means I have to disable it before testing my IO functions. Anyone know a way to avoid this?
11:38:37 <chrisdone> geekosaur: iirc, yes, but brings in a bunch of other instance requirements tho
11:38:47 <chrisdone> so you end up basically having the same type as before‚Ä¶
11:43:16 <zipper> :t getStdGen >>= return . x >>= (\(aa, _) -> return aa)
11:43:16 <lambdabot>     Couldn't match expected type ‚ÄòStdGen -> (b, t0)‚Äô
11:43:17 <lambdabot>                 with actual type ‚ÄòExpr‚Äô
11:43:17 <lambdabot>     In the second argument of ‚Äò(.)‚Äô, namely ‚Äòx‚Äô
11:44:40 <zipper> :t let x = (5 :: Int)  in mkStdGen x
11:44:41 <lambdabot> StdGen
11:45:11 <zipper> :t let x :: (StdGen -> (a, StdGen)) in  getStdGen >>= return . x >>= (\(aa, _) -> return aa)
11:45:12 <lambdabot>     The type signature for ‚Äòx‚Äô lacks an accompanying binding
11:45:48 <zipper> :t  getStdGen >>= return . random >>= (\(aa, _) -> return aa)
11:45:49 <lambdabot> Random b => IO b
11:46:22 <zipper> Why lambdabot why?
11:46:57 <Chathurga> zipper: That's also: fmap (fst . random) getStdGen
11:47:55 <zipper> Chathurga: It's getting harder and harder to see functors and applicatives after learning monads.
11:48:19 <chrisdone> zipper: you can think of fmap as equivalent to liftM
11:48:24 <chrisdone> :t liftM
11:48:25 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
11:48:30 <Chathurga> Whatever style you prefer, usually I replace (return .) with fmap but it works the same
11:48:30 <chrisdone> @src liftM
11:48:30 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:49:01 <chrisdone> :t fmap
11:49:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:49:38 <chrisdone> they're the same, but more things are instances of Functor than Monad, so fmap is more general
11:49:51 <zipper> chrisdone: Their signatures are about the same except expects a monad and the other a functor
11:51:22 <chrisdone> zipper: yeah. and all monads are functors
11:53:13 <chrisdone> zipper: you might find this fun http://chrisdone.com/fmap/
11:53:42 <zipper> chrisdone: Page is loading
11:58:19 <zipper> > fmap (a ++) (return "cat")
11:58:20 <lambdabot>  Couldn't match expected type ‚Äò[GHC.Types.Char]‚Äô
11:58:21 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
11:58:34 * hackagebot reactive-banana 0.8.0.3 - Library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.8.0.3 (HeinrichApfelmus)
11:58:46 <siddhu_> I have `f [a,b,c,d,e,f,g] = H <$> a <*> b <*> c <*> d <*> e <*> f <*> g`. Is there any way to generalize this to any number of elements in the list?
11:59:06 <vanila> siddhu_, maybe you could use recursion
11:59:10 <sinelaw> finally! got the damned 'new' to type infer correctly.
11:59:26 <benzrf> siddhu_: that's a partial function >:[
11:59:35 <benzrf> siddhu_: you should feel bad
11:59:50 <chrisdone> benzrf: down boy, down!
11:59:56 * chrisdone pulls lead
12:00:01 <benzrf> partial functions are eevil
12:00:04 <chrisdone> @botsnack
12:00:04 <lambdabot> :)
12:00:05 <zipper> > fmap ("a" ++) (return "cat")
12:00:06 <lambdabot>  No instance for (GHC.Show.Show (f0 [GHC.Types.Char]))
12:00:07 <lambdabot>    arising from a use of ‚ÄòM48327314362183972910291.show_M48327314362183972910...
12:00:07 <lambdabot>  The type variable ‚Äòf0‚Äô is ambiguous
12:00:19 <siddhu_> Oh. Well. I'm pretty new to Haskell, so maybe I did do something terrible.
12:00:22 <vanila> f (a:rest) = go (H <$> a) rest   where  go m [] = m ; go m (x:xs) = go (m <*> xs) xs
12:00:26 <zipper> :t ( "a" ++)
12:00:27 <lambdabot> [Char] -> [Char]
12:00:30 <benzrf> zipper: that doesnt type check
12:00:31 <chrisdone> zipper: the Functor instance you're doing is ambiguous there
12:00:35 <vanila> this code is kind of ugly but I think it captures the pattern you are using
12:00:45 <benzrf> er, wait
12:00:48 <vanila> although now that I think about it this probably wont typecheck
12:00:48 <benzrf> nvm
12:00:50 <chrisdone> > fmap ("a" ++) (return "cat") :: Maybe String
12:00:51 <lambdabot>  Just "acat"
12:01:02 <siddhu_> I apply it as: `getHeader = f <$> take 7 list`
12:01:04 <chrisdone> yay, cats
12:01:05 <zipper> benzrf: chrisdone So I see. There's a disconnect beterrn what's in my head and what I want
12:01:16 <zipper> Oh I got it
12:01:22 <zipper> > fmap ("a" ++) ("cat")
12:01:23 <siddhu_> and H is just a data value, declared with record syntax.
12:01:24 <lambdabot>  Couldn't match type ‚ÄòGHC.Types.Char‚Äô with ‚Äò[GHC.Types.Char]‚Äô
12:01:24 <lambdabot>  Expected type: [[GHC.Types.Char]]
12:01:24 <lambdabot>    Actual type: [GHC.Types.Char]
12:01:46 <zipper> Nope still wrong
12:01:49 <chrisdone> :t let what'sthis = fmap what'sthis "cat" in what'sthis
12:01:50 <lambdabot>     Couldn't match expected type ‚ÄòChar -> b1‚Äô with actual type ‚Äò[b1]‚Äô
12:01:50 <lambdabot>     Relevant bindings include
12:01:50 <lambdabot>       what'sthis :: [b1] (bound at <interactive>:1:5)
12:01:51 <siddhu_> vanilla: Thank you. I'll try that.
12:01:59 <chrisdone> oops
12:02:27 * sinelaw imagines shachaf grumbling about pm'ing lambdabot 
12:02:38 <zipper> :t ("a " :)
12:02:39 <sinelaw> oops, nick highlight. sorry :|
12:02:39 <lambdabot> [[Char]] -> [[Char]]
12:02:51 <zipper> :t ("a " ++)
12:02:52 <lambdabot> [Char] -> [Char]
12:03:01 <tdammers> oh boy, that was one debug fest
12:03:02 <sinelaw> zipper,  you can /msg lambdabot
12:03:02 <chrisdone> is lambdabot new enough to support typed holes?
12:03:15 <vanila> siddhu_, yeah im sorry this approach wil not wokr I think
12:03:17 <tdammers> took me two hours to track down the circular reference
12:03:20 <zipper> chrisdone: Yes he is
12:03:26 <chrisdone> :t fmap _f (Just 5)
12:03:26 <c_wraith> > _ 1
12:03:27 <lambdabot>     Found hole ‚Äò_f‚Äô with type: a0 -> b
12:03:27 <lambdabot>     Where: ‚Äòa0‚Äô is an ambiguous type variable
12:03:27 <lambdabot>            ‚Äòb‚Äô is a rigid type variable bound by
12:03:27 <lambdabot>  Found hole ‚Äò_‚Äô with type: a0 -> t
12:03:28 <lambdabot>  Where: ‚Äòa0‚Äô is an ambiguous type variable
12:03:28 <zipper> chrisdone: I used typed holes today
12:03:29 <lambdabot>         ‚Äòt‚Äô is a rigid type variable bound by
12:03:33 <chrisdone> grr!!
12:03:34 * hackagebot reactive-banana 0.8.0.4 - Library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.8.0.4 (HeinrichApfelmus)
12:03:37 * chrisdone tries again
12:03:50 <chrisdone> > fmap _f (Just ())
12:03:50 <tdammers> in the end, it was fieldNameP = try quotedFieldNameP <|> try fieldNameP <?> "field name"
12:03:51 <lambdabot>  Found hole ‚Äò_f‚Äô with type: () -> b
12:03:51 <lambdabot>  Where: ‚Äòb‚Äô is a rigid type variable bound by
12:03:51 <lambdabot>             the inferred type of it :: Data.Maybe.Maybe b at Top level
12:04:01 <chrisdone> zipper: see ^
12:04:06 * tdammers sobs
12:04:22 <chrisdone> > fmap _f "cat"
12:04:23 <lambdabot>  Found hole ‚Äò_f‚Äô with type: GHC.Types.Char -> b
12:04:23 <lambdabot>  Where: ‚Äòb‚Äô is a rigid type variable bound by
12:04:23 <lambdabot>             the inferred type of it :: [b] at Top level
12:04:45 <chrisdone> so you can't substitute _f with ("a" ++)
12:04:59 <Chathurga> Why isn't it Num a0 => a0 -> b?
12:05:02 <chrisdone> :t ("a" ++) -- because
12:05:03 <lambdabot> [Char] -> [Char]
12:05:22 <c_wraith> Chathurga: it would be in the rest of the message, which lambdabot chops off after a few lines
12:05:30 <Chathurga> Ah right
12:05:45 <zipper> chrisdone: Yesh I see that. I don't think there's a way to combine strings with fmap
12:06:03 <chrisdone> nope
12:16:11 <benzrf> > fmap _butt
12:16:13 <lambdabot>  Found hole ‚Äò_butt‚Äô with type: a -> b
12:16:13 <lambdabot>  Where: ‚Äòa‚Äô is a rigid type variable bound by
12:16:13 <lambdabot>             the inferred type of it :: f a -> f b at Top level
12:17:06 <tdammers> oh dear
12:17:09 <sinelaw> oy vey
12:17:47 <tdammers> that's what you get from hanging out with inferred types
12:33:35 * hackagebot ghcid 0.3.3 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.3.3 (NeilMitchell)
12:37:27 <zq> how come i can't automatically derive empty instances
12:38:56 <HeladoDeBrownie> zq, the deriving mechanism is not very open. It applies to only a select few typeclasses.
12:39:46 <HeladoDeBrownie> zq, however I'd say there's no real reason it *couldn't* derive things besides those specific classes it does. Just that isn't designed into the language (yet).
12:40:50 <tdammers> there's GeneralizedNewtypeDeriving...
12:41:22 <tdammers> but then, why would you ever need to derive an empty instance when you can just declare it?
12:41:41 <hseg> Anyone know where the pandoc channel is?
12:44:50 <begriffs> Is there a safe version of (!!) like Int -> [a] -> Maybe a ? Hoogle didn't find anything.
12:46:23 <supki> :t \n -> listToMaybe . drop n
12:46:24 <lambdabot> Int -> [a] -> Maybe a
12:47:18 <f-a> http://hackage.haskell.org/package/SDL-0.5.5/docs/Graphics-UI-SDL-Keysym.html <-- go to the bottom of the page. I am not getting what the instance `Enum SDLKey Word32` means
12:47:34 <f-a> sure it should be `Enum SDLKey` without the `Word32` part?
12:48:32 <f-a> my problem is `fromEnum SDLK_m` throws "No instance for (Enum SDLKey) arising ..."
12:48:54 <begriffs> supki: perfect, thanks
12:49:32 <hexagoxel> f-a: Graphics.UI.SDL.Utilities.Enum != Prelude.Enum
12:50:44 <f-a> argh, silly me. Thanks hexagoxel
12:53:38 <gilligan_> evening
12:57:45 <gabemc> Hey, I have a general question, and I thought this group might have some better answers than what I'm finding via google: other than mathoverflow, is there a good resource for asking questions about Category Theory?
12:58:10 <gabemc> I'm working through the first edition of Awodey's book, and I have a few questions.
13:02:53 <vanila> does anyone have experiences with stackage?
13:02:58 <vanila> Id' like to read about them
13:03:09 <christmasdotcode> When you're lifting a function, are you lifting the function "in" or lifting the function "over"?
13:03:11 <hexagoxel> gabemc: there is ##categorytheory
13:03:13 <christmasdotcode> I thought it was over
13:04:17 <gabemc> hexagoxel: Thanks! I didn't know that.
13:04:40 <HeladoDeBrownie> christmasdotcode, if you mean "lift" in the sense of what return and its ilk do, return :: a -> Maybe a is a function that lifts an a "into" Maybe. But this is only really an intuition, it doesn't really tell you what it does.
13:05:09 <gabemc> hexagoxel: Sadly, that room is empty :(. Thanks anyway. ~8')
13:05:13 <HeladoDeBrownie> (The type and the laws do that.)
13:05:59 <christmasdotcode> HeladoDeBrownie: I get the intuitition - I'm more curious about terminology. `liftIO foo`. Am I lifting foo "into" MonadIO, or am I lifting foo "over" MonadIO?
13:06:07 <HeladoDeBrownie> christmasdotcode, the former.
13:06:19 <christmasdotcode> Thank you.
13:06:24 <hexagoxel> gabemc: ##categorytheory has 74 users, currently
13:07:48 <hexagoxel> (gabemc: also, your client probably has a method of listing/search all channels)
13:10:16 <hexagoxel> (heh i think i made two other people join, and gabemc still has not found the channel :D)
13:21:46 <gabemc> hexagoxel: Yay! I've never seen the '##' sigil in chat rooms before. I thought it was a typo. I just tried '#categorytheory'. I'm in! Thanks!
13:22:21 <barrucadu> gabemc: "##" is for "topic" channels, "#" is for "official" channels
13:23:04 <christmasdotcode> is there a ##topic?
13:23:33 <trap_exit> is there a good way to do relational (as in CODD) programming in haskell ?
13:23:46 <barrucadu> christmasdotcode: Surprisingly not, as it turns out
13:23:47 <trap_exit> is there a good way to do relational (as in Codd / foundation of SQL) programming in haskell ?
13:24:04 <christmasdotcode> barrucadu: Guess they're not witty enough.
13:24:08 <christmasdotcode> :)
13:24:11 <trap_exit> is there a good way to do relational (as in Codd / foundation of SQL) programming in haskell ? Projection, Selection, Cross Product, seem like standard operators, but requires a bit more with type system.
13:24:49 * hexagoxel waits for the next version
13:24:57 <ryantrinkle1> any recommendations for a non-empty Map type?
13:25:05 <christmasdotcode> ryantrinkle1: Non-empty?
13:25:24 <brainacid> Hey everyone
13:25:29 <christmasdotcode> Hi
13:25:43 <ryantrinkle> christmasdotcode: Data.Map, except with the guarantee that size >= 1
13:26:18 <brainacid> I am just a hobby programmer
13:26:33 <brainacid> I started with the machine Assembly for x86 and some C
13:26:45 <brainacid> I have done some scripts with Perl and Python
13:27:00 <brainacid> made some of thos scripts in Racket
13:27:18 <christmasdotcode> ryantrinkle: As a type level constraint? There's always: `(>= 1) . size`
13:27:20 <brainacid> I heard Haskell was the most modern and advanced language
13:27:28 <christmasdotcode> brainacid: Yes, Haskell is awesome.
13:27:29 <brainacid> Im just curious
13:27:36 <christmasdotcode> If you're looking to learn, checkout learnyouahaskell.com
13:28:08 <ryantrinkle> christmasdotcode: yeah, i'm interested in a type-level guarantee, with things like toList :: NonEmptyMap k v -> Data.List.NonEmpty.NonEmpty (k, v)
13:28:20 <quchen> Haskell certainly is not the "most modern and advanced language". Many in here would certainly call it interesting, practical and worth learning though.
13:28:39 <quchen> Language elitism is rarely fruitful.
13:28:55 <ryantrinkle> quchen: i think it's definitely a contender for "most academically advanced language that you can actually use in production"
13:29:03 <ryantrinkle> but that's certainly a much weaker claim :P
13:29:10 <christmasdotcode> "Most" may be superlative, but I haven't seen a better type system on anything other than a haskell-inspired language.
13:29:13 <vamega> brainacid: You could look at https://github.com/bitemyapp/learnhaskell
13:29:15 <christmasdotcode> ryantrinkle: I know of nothing, then, sorry.
13:29:19 <vamega> Learn you a Haskell is mentioned there.
13:29:35 <christmasdotcode> Speaking of bitemyapp...
13:29:41 <brainacid> Yeah I have seen all the books
13:29:44 <brainacid> plenty of info
13:29:50 <Yawar> brainacid: haskell has many cool things to learn. the syntax starts out looking fairly strange but then you quickly come to appreciate its elegance
13:30:02 <vamega> Christmasdotcode: What of bitemyapp?
13:30:13 <brainacid> Yawar, yes as I appreaciate Racket
13:30:23 <christmasdotcode> I had to ping him on #haskell-infrastructure. You just reminded me, thanks.
13:30:30 <brainacid> I like the clean syntax
13:30:35 <christmasdotcode> I'm sure he's sleeping or something, though. So I have a while to wait.
13:30:49 <barrucadu> Nver sleeping, only waiting
13:30:53 <barrucadu> *Never
13:31:36 <Yawar> brainacid: yeah, the lisps have very cool syntax (or form) as well. but if you ever get tired of typing all those parens, you can take a break from them by typing some minimal-looking haskell code :-)
13:31:40 <christmasdotcode> Silently waiting...
13:32:34 <sinelaw> watching
13:32:53 <christmasdotcode> 'bitemyappman'?
13:33:03 <brainacid> Yawar, yeah I used Haskell a while back but started to re-learn from a different perspective
13:33:23 <brainacid> since I am just a hobbyist its hard for me to find anything longer than 30 lines to code
13:33:25 <brainacid> l0l
13:33:36 <christmasdotcode> brainacid: Do you know about the haskell subreddit?
13:33:55 <brainacid> christmasdotcode, havent looked at it
13:34:04 <christmasdotcode> brainacid: reddit.com/r/haskell
13:34:43 <Yawar> brainacid: that's ok, it's not 'go big or go home' :-) keep coding small things and learning. also check out jekor's channel on youtube where he walks through the design of some cool haskell programs
13:34:44 <christmasdotcode> geekosaur: Shouldn't the link to the sub be in the channel topic?
13:34:49 <christmasdotcode> I recall at one point it was.
13:35:29 <brainacid> Yawar, oh nice ... thanks... although I am not a youtuber... im more a trial and error
13:35:46 <geekosaur> probably. along with at least one other cleanup
13:36:11 <brainacid> i like Lisp and the interpreted python and perl they are quick and useful for most of my stupid ventures
13:36:16 --- mode: ChanServ set +o geekosaur
13:36:47 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org' by geekosaur
13:36:53 --- mode: geekosaur set -o geekosaur
13:37:07 <christmasdotcode> No description? Or is it self-explanatory?
13:37:15 <christmasdotcode> s/is it/do you think/
13:37:26 <christmasdotcode> s/is it/do you think it's/
13:37:38 <brainacid> well fellas thanks for your time
13:37:41 <brainacid> ill be away
13:37:50 <geekosaur> I think it's explanatory enough? the "haskell" part should be and I'm not sure it's our place to explain Reddit :p
13:37:51 <brainacid> my daughter wants to play with tuxpain
13:37:56 <brainacid> *tuxpaint
13:38:16 <Yawar> brainacid: yeah they are very useful. but i think haskell and other typed langs have a lot to offer. see e.g. scott wlaschin's video on domain driven design. it's f# but it's very similar to haskell and really sells the beauty of using types
13:38:38 <christmasdotcode> geekosaur: Can I add "helped beginners find relevant information about haskell" to my resume now? :)
13:38:52 <geekosaur> that I can't help with :)
13:39:07 <Yawar> brainacid, ciao, enjoy
13:39:13 <christmasdotcode> geekosaur: I meant with the topic change. Embellishment, of course.
13:39:22 <ryantrinkle> christmasdotcode: i've used IRC contributions to help decide who to hire before :)
13:39:31 <ryantrinkle> it definitely can matter
13:39:38 <ryantrinkle> but i'm not sure how to list it on a resume, lol
13:39:45 <ryantrinkle> maybe under hobbies
13:39:46 <besenwesen> is there a good way to run state concurrently? i found the mstate package which claimed to allow this, but it depends on monad-peel, which uses deprecated functions that won‚Äôt build anymore
13:39:57 <Chathurga> Haskell's type system lets you do things that seem almost dynamic but are well defined
13:40:18 <Chathurga> Things like return type polymorphism
13:40:22 <ryantrinkle> besenwesen: well, if you just want to parallelize computation, you can spark things off with par and seq
13:40:40 <christmasdotcode> ryantrinkle: "helped change topic channel in #haskell once"
13:40:41 <ryantrinkle> besenwesen: if you want actual nondeterminism, you'll probably need to stick to IO, in which case maybe STM would fit the bill
13:40:54 <ryantrinkle> christmasdotcode: haha
13:41:14 <besenwesen> ryantrinkle, the thing is i‚Äôm running the computation inside a state monad
13:41:25 <besenwesen> with some shared state
13:41:49 <besenwesen> it seems mstate managed state by implementing locks and all that, but apparently it‚Äôs now broken
13:42:11 <ryantrinkle> besenwesen: hmm, have you considered just using a ReaderT to pass around the mvar?
13:42:48 <ryantrinkle> you could also wrap that in a newtype and then implement MonadState
13:42:52 <besenwesen> ryantrinkle, you mean i would have to make my own threads? i haven‚Äôt done anything with reader yet, i‚Äôll look into it. thing is these are pure computations
13:42:56 <phaazon> hi
13:43:01 <trap_exit> quchen: who are you to call haskell not advanced
13:43:06 <trap_exit> quchen: what have you created ?
13:43:13 <ryantrinkle> besenwesen: ok, well if they're pure computations you shouldn't need to use MVars
13:43:36 <ryantrinkle> (i think they're too heavy for that)
13:43:42 <quchen> trap_exit: That is a misquote.
13:43:45 <ryantrinkle> also, if it's pure that means it's gotta be deterministic
13:43:56 <ryantrinkle> so i suspect that actual *threads* aren't the way to go in haskell
13:44:01 <trap_exit> quchen: ah, my apologies
13:44:18 <ryantrinkle> besenwesen: instead, you can use par and seq to make your pure computation *run* in parallel
13:44:30 <besenwesen> yea, i‚Äôm in over my head a bit. mstate seemed to be what i need, but it seems it needs old exception API
13:44:32 <ryantrinkle> https://www.haskell.org/haskellwiki/Par_and_seq
13:44:47 <kristof> I found a way to solve the problem of naming things
13:44:55 <ryantrinkle> if you don't mind expanding on the problem a bit, that might be helpful
13:44:59 <besenwesen> ryantrinkle, i looked into this a bit, but there‚Äôs no strategy for running state, it seems
13:45:01 <johannesbodannes> does anyone have enough experience with Cloud Haskell to know whether it's worth using for cloud-based applications? specifically Azure
13:45:02 <kristof> Create a SHA-1 hash of the description of the thing you're trying to name, and just use that as the name
13:45:19 <quchen> ?quote 26.variables
13:45:20 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
13:45:37 <christmasdotcode> Forgot about A-Z, eh?
13:45:47 <quchen> Those are not variable names.
13:45:48 <besenwesen> i have a function which fans out and recurses a lot. when computations re-appear, i share results via a map
13:45:52 <christmasdotcode> Whoops.
13:46:01 <geekosaur> aa, ab, ...
13:46:03 <johannesbodannes> or Cloud Haskell at all really
13:46:06 <christmasdotcode> a' a'' a'''...
13:46:30 <johannesbodannes> the goal is just software that i can build to scale "out"
13:46:43 <ryantrinkle> besenwesen: ah, ok; so the order in which things get added might be nondeterministic, but the result will be deterministic?
13:46:55 <johannesbodannes> on one hand i can just build a simple, monolitic application that i duplicate and run behind a load balancer BUT
13:47:08 <johannesbodannes> i'm thinking something more sophisticated than that with separate UI and worker roles
13:47:28 <barrucadu> besenwesen: The Par monad might be useful for you - it's for deterministic data parallelism
13:47:29 <johannesbodannes> especially since i'm planning something quite computationally-heavy
13:47:45 <besenwesen> ryantrinkle, yes. if i removed the shared state (the map of previous results, where work is shared), i could just use the existing stuff. but the state speeds things up quite a bit
13:48:10 <besenwesen> barrucadu, i came across that when googling. it seemed nice, but a bit intimidating. i‚Äôll have a look again
13:48:24 <ryantrinkle> besenwesen: yeah, that makes sense; you could try to finesse it using MemoTrie or something like that with par and seq, but the Par monad seems more likely
13:48:29 <ryantrinkle> or, you can just manually use an MVar
13:48:47 <quchen> ryantrinkle: Haskell has unspecified evaluation order anyway. rpar allows you to say "hey, when you want to evaluate this, why not in a separate thread".
13:48:47 <ryantrinkle> actually, since you only have one variable, an IORef is probably fine, using atomicModifyIORef
13:49:10 <Cale> johannesbodannes: I haven't had the occasion to obtain real experience with it, but I will say that it looks really well-designed.
13:49:13 <ryantrinkle> quchen: yeah, that might be useful for him, too
13:49:15 * besenwesen makes notes :)
13:50:08 <ryantrinkle> (IORefs are substantially faster than MVars)
13:50:43 <johannesbodannes> Cale: hm! cool, thanks
13:50:46 <quchen> For everything related to Haskell and concurrency, there's Marlows book. It's easy to read and boy has it saved me from some pitfalls
13:50:52 <Cale> johannesbodannes: Have you seen the talks?
13:50:53 <quchen> ‚Ä¶ and parallelism too
13:52:28 <besenwesen> basically i wanna parallelize the stuff after subsequent ‚Üê runListT $ do..  http://codepad.org/DOsoOANP
13:52:39 <besenwesen> if it was just a list it would probably be easy
13:52:43 <trap_exit> yeah
13:52:43 <trap_exit> yo
13:53:08 <Cale> There's this talk by Duncan Coutts https://www.youtube.com/watch?v=1jJ2paFuErM  which goes over a lot about how it works
13:53:24 <besenwesen> i found an evaluation strategy for traversables (which ListT is), but it requires that what‚Äôs contained has a strategy, which State doesn‚Äôt have
13:53:27 <sinelaw> Does anyone know of a good summary of Strachey denotational semantics?
13:53:35 <sinelaw> intro rather
13:54:27 <Cale> https://www.youtube.com/watch?v=ZiyDJEfXOXw I haven't seen this before, but it looks relevant to the question about experiences with distributed applications in Haskell :)
14:01:00 <pavonia> Can anyone tell me the location cabal is updating 00-index.tar from?
14:01:35 <phaazon> pavonia, on Windows?
14:01:42 <phaazon> %user%/AppData
14:01:45 <phaazon> or something like that
14:01:48 <phaazon> Local
14:01:49 <pavonia> No, I mean the URL
14:01:52 <phaazon> oh
14:01:55 <phaazon> I might have that
14:01:57 <phaazon> wait for a sec
14:02:34 <yac> I'd try strace or tcpdump if there would be nothing else to go on
14:02:46 <hexagoxel> see output of `cabal -v3 update`
14:02:54 <hexagoxel> pavonia: ^
14:03:08 <phaazon> hey
14:03:19 <phaazon> what‚Äôs the difference between type families and data families ?
14:03:39 <pavonia> hexagoxel: Ah, thank you!
14:06:22 <phaazon> also, something very weird:
14:06:24 <phaazon> http://lpaste.net/116971
14:06:28 <phaazon> why does that even happen?
14:06:49 <phaazon> the latest is 4.3.2
14:06:54 <phaazon> so why would cabal install 4.1.2
14:06:59 <phaazon> which does not make ANY damned sense
14:07:03 <phaazon> since in my .cabal file
14:07:28 <phaazon> I have either >= 4.1 && < 4.4
14:07:33 <phaazon> any idea?
14:07:57 <Cale> Are you sure that none of your other dependencies have a tighter upper bound on it?
14:08:16 <Cale> What happens if you change the .cabal to specify exactly 4.3.2?
14:08:34 <phaazon> Cale, I‚Äôm gonna test that with -v
14:10:37 <phaazon> _30] rejecting: either-4.3.2, 4.3.1, 4.3.0.2, 4.3.0.1, 4.3 (conflict: monad-control==1.0.0.1/installed-661..., either =
14:10:37 <phaazon>  monad-control>=0.3.2 && <0.4)
14:10:39 <phaazon> dammit
14:10:48 <phaazon> so it‚Äôs monad-control
14:12:31 <hvr> phaazon: what 'cabal' version do you have?
14:12:57 <phaazon> 1.18
14:13:05 <phaazon> I‚Äôm gonna update that yeah
14:13:23 <phaazon> though, that bug is weird
14:13:30 <phaazon> all my upper bounds are up to date
14:13:39 <phaazon> so that I target latest dependencies
14:13:48 <hvr> phaazon: wait... it's trying to install either-4.1.2 w/ monad-control==1.0.0.1?
14:14:06 <phaazon> http://packdeps.haskellers.com/feed?needle=monad-journal
14:14:22 <phaazon> hvr, yeah
14:14:36 <hvr> phaazon: have you run 'cabal update' lately?
14:14:45 <phaazon> hvr, yeah
14:15:41 <hvr> it should *not* try to install either-4.1.2 w/ monad-control=1, since I added a bound there: https://hackage.haskell.org/package/either-4.1.2/revisions/
14:15:52 <phaazon> yeah
14:16:04 <phaazon> but I don‚Äôt get why it installs that
14:16:19 <cesc> Hi! n00b question here. Where does "cabal init" get my email from by default? I was a bit shocked that it obtained it without me telling it... Thanks in advance!
14:16:30 <phaazon> cesc, git, maybe
14:16:45 <hvr> phaazon: can you paste that dry run w/ -v3 output?
14:16:53 <cesc> phaazon, ah! it checks out, I do have a .gitconfig  ...  Thank you!
14:17:02 <phaazon> hvr, sure
14:17:28 <phaazon> hvr, wait a sec
14:19:29 <lpaste> phaazon pasted ‚Äúcabal nistall either --dry-run -v3 ( hvr )‚Äù at http://lpaste.net/116972
14:19:32 <phaazon> hvr, ^
14:20:01 <hvr> phaazon: it's picking the right one now
14:20:06 <phaazon> yeah
14:20:12 <phaazon> maybe an error from cabal?
14:20:15 <phaazon> I just updated it
14:20:31 <hvr> if you ran 'cabal update', then you just had an outdated cabal index earlier
14:20:48 <hvr> either-4.3.2.1 was released only today
14:21:25 <phaazon> yeah
14:21:36 <phaazon> so I guess the error on my issues page is related to that
14:21:57 <fresheyeball> hey folks
14:22:04 <fresheyeball> I have an easy question
14:22:21 <fresheyeball> sometimes when I use a case statement
14:22:22 <HeladoDeBrownie> We'll see about that after you ask it ;)
14:22:43 <fresheyeball> I get a warning saying my binding shadows an existing binding
14:22:50 <fresheyeball> any way to get around that?
14:22:58 <HeladoDeBrownie> fresheyeball, use a different variable name
14:23:09 <HeladoDeBrownie> fresheyeball, got a specific example?
14:23:19 <fresheyeball> but I am testing for equality
14:23:25 <fresheyeball> its a pattern match to that element
14:23:36 <HeladoDeBrownie> And?
14:23:48 <fresheyeball> ok
14:23:53 <fresheyeball> https://hackage.haskell.org/package/http-types-0.8.5/docs/Network-HTTP-Types-Method.html
14:24:15 <fresheyeball> methodGet -> foo
14:24:18 <fresheyeball> in the case statment
14:24:51 <HeladoDeBrownie> I don't understand. Can you show the complete binding?
14:25:04 <fresheyeball> sec
14:25:08 <HeladoDeBrownie> or expression or whatnot
14:25:17 <barrucadu> fresheyeball: If you do case ... of methodGet -> ..., you're actually creating a new binding called methodGet
14:25:27 <barrucadu> Not comparing with the existing methodGet
14:25:35 <fresheyeball> right
14:25:43 <fresheyeball> http://lpaste.net/116973
14:26:03 <HeladoDeBrownie> Yeah barrucadu got it
14:26:12 <HeladoDeBrownie> Try an if expression instead
14:26:23 <HeladoDeBrownie> if requestMethod req == methodGet then ... else ...
14:26:36 <fresheyeball> well I want to use case
14:26:40 <barrucadu> Or if you do want to compare for equality with multiple things, and an if is a bit unwieldy, you can use guards
14:26:43 <fresheyeball> because there is going to be more than one
14:27:04 <geekosaur> you can't use case for this
14:27:13 <geekosaur> case can only compare constructors
14:27:20 <fresheyeball> interesting
14:27:24 <fresheyeball> it compiles fine
14:27:28 <HeladoDeBrownie> fresheyeball, https://ghc.haskell.org/trac/haskell-prime/wiki/MultiWayIf
14:27:39 <barrucadu> Yes, because it's creating a new binding called methodGet
14:27:42 <geekosaur> yes, it just doesn't do what you want, it does what it wants
14:27:44 <barrucadu> There is no equality checking going on there
14:28:00 <HeladoDeBrownie> Woops, wrong page
14:28:01 <barrucadu> I annotated the paste to show how you could use guards
14:28:04 <HeladoDeBrownie> I didn't read it before pasting >_<
14:28:36 <HeladoDeBrownie> fresheyeball, https://downloads.haskell.org/~ghc/7.6.2/docs/html/users_guide/syntax-extns.html#multi-way-if
14:29:07 <HeladoDeBrownie> fresheyeball, you can enable that with {-# LANGUAGE MultiWayIf #-} at the top of your source file
14:29:33 <HeladoDeBrownie> If you don't want to use an extension you can also use the translation it gives there
14:29:39 <HeladoDeBrownie> which is a bit ugly but works
14:34:27 <hexagoxel> fresheyeball: you probably should use `parseMethod`
14:34:56 <hexagoxel> because you can match on the StdMethod easily
14:35:01 <fresheyeball> :i parseMethod
14:36:02 <hexagoxel> (fresheyeball: it is not the hackage page you linked)
14:36:10 <fresheyeball> I see it now
14:36:25 <hexagoxel>  /s/not//
14:36:36 <hexagoxel> wait.. /s/not/on/
14:37:57 <hexagoxel> (replacing the replacement becomes a hassle, if done properly..)
14:41:45 <fresheyeball> ok
14:41:48 <fresheyeball> so here is what I got
14:41:51 <fresheyeball> http://lpaste.net/116976
14:41:54 <fresheyeball> works fine no warnings
14:41:56 <fresheyeball> ugly?
14:41:58 <fresheyeball> pretty?
14:43:31 <phaazon> ok, bug fixed :)
14:43:34 <phaazon> thank you hvr
14:43:41 * hackagebot monad-journal 0.6.0.1 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.6.0.1 (DimitriSabadie)
14:43:44 <phaazon> it should be out of hackahe in a few
14:43:44 <phaazon> ahah
14:43:46 <phaazon> it‚Äôs there :D
14:44:09 <hexagoxel> > let (Right a) = Left "something" in a -- fresheyeball
14:44:11 <lambdabot>  *Exception: <interactive>:3:5-32: Irrefutable pattern failed for pattern (Da...
14:44:53 <hexagoxel> case parseMethod $ requestMethod req of (Right GET) -> ...; (Right ..) -> ..; _ -> ..
14:45:00 <ski> fresheyeball : are you sure you want to use `let Right m = ... in ..m..' rather than `case ... of Right m -> ..m..; Left y -> ..y..' (so that you can handle the `Left' case and do something sensible there, instead of aborting the whole program) ?
14:45:42 <hexagoxel> ski explains what i tried to show :)
14:45:48 * ski mentions to hexagoxel that the brackets around `Right a' are redundant
14:46:12 <ski> hexagoxel : different approaches are good :)
14:46:22 <hexagoxel> :)
14:47:48 <quchen> fresheyeball: Here's my formatted version as an annotation. http://lpaste.net/116976
14:48:59 <quchen> Woops, secureStuff = handleSecure there.
14:49:22 <hexagoxel> (Right _ is "wrong/unhandled Method" and Left _ is "unknown Method")
14:50:05 <fresheyeball> oo I like your style
14:50:08 <fresheyeball> much cleaner
14:52:46 <quchen> fresheyeball: See https://github.com/quchen/articles/blob/master/haskell_style.md for some rationale behind it
14:54:27 <zq> why is haskell typeclass deduction so obtuse?
14:54:41 <zq> test case: class C c where { blah :: c -> Bool; blah = const True; }; instance C Int; j = blah 3
14:55:10 <zq> 3 is not ambiguous because the only type that satisfies both C and Num is Int
14:55:35 <k00mi> zq: that's not how instance resolution works
14:55:42 <ski> Haskell type class resolution uses "OWA" (Open World Assumption)
14:56:06 <k00mi> zq: new instances that could be created in the future should not break old code
14:56:28 <ski> just because *you* haven't (yet) made another instance of `C', that doesn't mean you (or someone else using that piece of code, e.g. as a library) won't, in the future
14:57:08 <ski> the design for type class resolution makes sure that sure future extensions can't make the existing code fail or behave differently
14:57:13 <zq> alright
14:57:18 <ski> s/that sure/that such/
14:57:23 <zq> is there a way to only specify part of a type sig
14:57:43 <zq> say, abc :: Int -> Int -> _ -> _ -> Bool
14:57:54 <ski> the other part of the problem here is that integral literals like `3' are overloaded
14:58:14 <quchen> zq: Not yet, but soon! https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures
14:58:23 <zq> meh
14:58:25 <ski> `3' can have type `Integer',`Rational',`Float',`Double',`Complex Double',&c.
14:58:33 <zq> so in the meanwhile, all i have is asTypeOf, right?
14:59:00 <ski> zq : if you say `j = blah (3 :: Int)', then i think there would be no ambiguity
14:59:12 <quchen> zq: asTypeOf is a value. Partial type signatures are on the type level.
14:59:43 <zq> quchen, ski: j = blah three where three = 3 `asTypeOf` (undefined :: Int)
14:59:46 <zq> holy shit that's verbose
15:00:19 <ski> zq : `j = blah three where three :: Int; three = undefined' would also work
15:00:30 <benzrf> ski: thats different
15:00:31 <zq> uh
15:00:32 <k00mi> j = blah (3 :: Int)
15:00:37 <zq> why would i want to call blah undefined :p
15:00:59 <zq> man i'm regretting incorporating type classes into my design
15:01:07 <zq> so mistake, many ugh
15:01:21 <ski> benzrf : oh, right. i misread zq's last snippet
15:01:42 <ski> zq : design ? of a language ?
15:01:51 <zq> ski: yah
15:04:01 <brainacid> I have been on IRC for many years
15:04:13 <benzrf> brainacid: same fsvo many
15:04:37 <brainacid> and its really rare to find super-hepful people
15:04:44 <brainacid> this channel is very helpful
15:04:48 <brainacid> benzrf, what?
15:05:10 <benzrf> brainacid: i have also been on IRC for many years, for some value of many
15:05:11 <brainacid> just installed haskell-platfomr on linux
15:06:07 <benzrf> brainacid: aw man dont use the platform, u should just install ghc and then fetch what you need with cabal-install
15:06:10 <brainacid> benzrf, man i remember hearing about 9/11 from a user on IRC when I first booted into RedHat 4
15:06:28 <brainacid> benzrf, i wasnt sure and I had the 500mb of space
15:06:37 <brainacid> does the platform include ghc?
15:06:42 <benzrf> yes
15:06:48 <brainacid> oh ok
15:07:07 <brainacid> well then I got my books and going to dive in later on
15:07:14 <brainacid> going to play PS3 with my brother
15:07:17 <brainacid> lol
15:09:01 <brainacid> well you know im just a hobby programmer
15:09:07 <ski> brainacid : Scheme (and Racket) is nice
15:09:13 <brainacid> i began several weeks ago learning C and Asm x86
15:09:27 <brainacid> ski, yes indeed I made the same program several different ways
15:09:47 <brainacid> ski, im still playing with it... i dont mind the () all the time and rather use []
15:09:52 <brainacid> its all the same to the reader
15:10:17 <brainacid> im sitll trying to learn how to load a text file with 653 lines
15:10:30 <brainacid> trying to make a search utility
15:10:52 <brainacid> i made it in python easy but i know very little of racket
15:11:40 <ski> brainacid : hehe, i have mixed feelings about using `[',`]' interchangably for `(',`)'
15:11:55 <brainacid> lol ski
15:12:13 <ski> (that's a specifically Racket thing)
15:12:38 <brainacid> like I said ski im really just a hobby man... i stay at home dad so i dont really have true applications to use the coding skills I gain
15:12:58 <ski> i have more sympathy for using `[',`]' for special forms (primitive syntax & defined syntax (aka macros))
15:13:08 <brainacid> true
15:13:12 <brainacid> t2yl
15:13:28 <ski> ("t2yl" ?)
15:14:10 <ski> brainacid : so you started learning programming a few weeks ago ?
15:14:17 <brainacid> yeah
15:14:26 <ski> making good progress, iiuc :)
15:14:29 <dfeuer> @tell int-e It sounds like your version must specialize quite a bit better than my original one; I wonder if mine wasn't getting as much out of the Elem coercions as it could.
15:14:30 <lambdabot> Consider it noted.
15:15:15 <dfeuer> Anyone remember Andrew Seniuk's nick?
15:15:19 <arianvp___> yo
15:15:34 <ski> you might also have some fun learning about how digital circuitry are constructed (at least out of the basic logical gates, `NOT',`AND',`OR' or `NAND' or `NOR')
15:15:55 <brainacid> i did ski
15:16:07 <dfeuer> Ah right. rasfar. Guess he's not here.
15:16:30 <Bynbo7> ski: The Elements of Computer Systems is excellent for that
15:16:56 <brainacid> i did some superficial studying since i did electronics
15:17:48 <athan> Is there a `numOption` for optparse-applicative?
15:19:23 <bennofs> athan: I think autoOption uses `read`, which works for numbers too?
15:19:26 <ski> Bynbo7 : ok
15:20:07 <athan> bennofs: Oh woah, okay I'll check it out
15:20:09 <athan> Thanks :)
15:20:26 <bennofs> athan: oh, seems autoOption doesn't exist
15:20:42 <athan> :s
15:20:54 <bennofs> athan: 'option auto' should work though
15:21:57 <athan> bennofs: Thank you, I had no idea this existed
15:23:22 <bennofs> athan: in case you haven't found it yet, this is the module where all those things are documented: http://hackage.haskell.org/package/optparse-applicative-0.11.0.1/docs/Options-Applicative-Builder.html (took me some time to find it was located under "Builder")
15:23:43 * hackagebot sbv 3.4 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-3.4 (LeventErkok)
15:23:47 <athan> *bookmarks*
15:23:55 <tommd> Wahoo, new sbv!
15:24:19 <brainacid> playing ps3 lol
15:32:30 <dfeuer> @tell int-e Oh, I see, your refactoring speeds up the ix test, without significant effects on the other tests. That makes a lot of sense.
15:32:30 <lambdabot> Consider it noted.
15:45:29 <fresheyeball> hey
15:45:41 <fresheyeball> so I have to send json to a server
15:45:58 <fresheyeball> what is the best way to represent a nested json structure as a type?
15:46:24 <mmmm> Use a regular haskell data type
15:46:46 <mmmm> and then use the generic functions in Data.Aeson
15:47:36 <mmmm> Say you want to send {a : "data", b : "data"} you would have data Payload = Payload {a :: Text, b :: Text} deriving Generic
15:47:52 <mmmm> then instance ToJSON Payload and encode (Payload a b)
15:48:09 <mmmm> or you can write a custom ToJSON instance by hand if that's easier for you
15:48:44 * hackagebot sound-collage 0.0 - Approximate a song from other pieces of sound  http://hackage.haskell.org/package/sound-collage-0.0 (HenningThielemann)
15:48:46 * hackagebot sound-collage 0.1 - Approximate a song from other pieces of sound  http://hackage.haskell.org/package/sound-collage-0.1 (HenningThielemann)
15:52:38 <pxqr> how to dump heap of a ghc compiled program?
15:55:46 <benzrf> no one knows that
15:59:38 <mgsloan> I haven't done anything like that, but it is certainly possible to make your program core dump and then use gdb to analyze it
16:01:17 <mgsloan> I haven't done it myself, but it's certainly possible to find where some ASM came from in the CMM, trace that back to core, and finally to your haskell (and probably a compiler bug, if your program actually core dumped without it being caused by a linked dependency)
16:03:48 <luite> there are some gdb scripts that help with debugging on the ghc wiki
16:15:24 <ReinH> It also helps to have cabal build the binary without stripping
16:25:06 <brainacid> Curious about everyones editor for making Haskell apps?
16:25:33 <vanila> GNU Emac
16:25:39 * bennofs too
16:25:41 <HeladoDeBrownie> Vim
16:27:31 <brainacid> So I dont need any IDE like that
16:27:32 <brainacid> Ok
16:28:59 <Axman6> ublime text is quite nice for haskell
16:29:03 <Axman6> sublime text*
16:33:03 <HeladoDeBrownie> Emacs and Vim can practically be IDEs with some extensions :)
16:33:14 <HeladoDeBrownie> But no, you don't *need* an IDE
16:34:11 <meretrix> Is the Binary Builder module able to append a new Foo to a serialized file of [Foo] without having to rewrite the entire file?
16:34:12 <christmasdotcode> Haskell is my IDE.
16:34:19 <christmasdotcode> Spellchecking, code correction...
16:34:58 <brainacid> lol
16:40:56 <rofer> Wow, I think I'm slowly actually getting Haskell
16:44:18 <shachaf> chrisdone: whoa, HoleyMonoid
17:05:58 <greymalkin> Is there a way to profile from within ghci?
17:10:41 <hexagoxel> greymalkin: there is `:set +s`; but ghci interprets, so it is not suitable for _real_ profiling
17:11:23 <greymalkin> hexagoxel: My runtime on this one module is so bad, I don't need anything but a kick in the right direction :)
17:11:27 <greymalkin> Thanks!
17:13:47 * hackagebot hasql-postgres-options 0.1.2 - An "optparse-applicative" parser for "hasql-postgres"  http://hackage.haskell.org/package/hasql-postgres-options-0.1.2 (NikitaVolkov)
17:16:39 <greymalkin> whoa.
17:17:23 <greymalkin> The inefficiency was all (I think) in marshalling data from a MonadResource (leveldb thing) to IO... once everything was in the MonadResource it screamed.
17:59:14 <gnusosa> Hi, I'm a little bit confused about the heavy usage of types. I can't seem to find a best practices guide or a how much is too much with regards types and data types. All I find is textbooks and presentations, expressing that it's better to create many types. Like this one, http://sencjw.com/talks/haskell_hearts_business_rules.pdf
17:59:24 <gnusosa> My main concern is performance.
18:00:32 <gnusosa> Real World Haskell seems to create and create types for everything for instance, the BookInfo example.
18:00:55 <benzrf> gnusosa: sounds like premature optimization to me
18:01:05 <carter> write code, use efficient algorithms, then benchmark
18:01:08 <carter> benzrf: is correct
18:01:38 <benzrf> gnusosa: why would using 2 types be more expensive than using 2 type anyway
18:01:49 <dmj`> Fuuzetsu: ping
18:01:49 <benzrf> nothing stops u from using the same runtime representation
18:02:33 <gnusosa> benzrf: carter: Thanks for the input. So I should try to balanced it out.
18:02:43 <carter> gnusosa: just do what seems pretty
18:02:50 <carter> then figure out / learn per later
18:02:53 <carter> *performance
18:03:02 <gnusosa> I like pretty
18:03:04 <carter> yes
18:03:08 <carter> focus on writing it pertty
18:03:10 <carter> *pretty
18:03:21 <carter> and then use profiling tools to figure out whats slow later
18:03:22 <benzrf> ‚ó¶¬∞Àö\(*‚ùõ‚Äø‚ùõ)/Àö¬∞‚ó¶
18:03:36 <carter> benzrf: is that a magical girl emoticon?
18:03:49 * hackagebot cron 0.2.3 - Cron datatypes and Attoparsec parser  http://hackage.haskell.org/package/cron-0.2.3 (MichaelXavier)
18:04:00 <dfeuer> carter, do you know about T5681?
18:04:03 <gnusosa> carter: benzrf: any hackage package that you think would be a good example to see there types usage.
18:04:10 <gnusosa> ?
18:04:12 <carter> gnusosa: just write code
18:04:18 <benzrf> carter: probably
18:04:19 <carter> dont worry about it till you hit a design problem
18:04:25 <benzrf> carter: i was lookin for a different one but i saw that first
18:04:29 <dfeuer> JUST WRITE CODE. LOTS OF CODE. PRETTTTTY CODE.
18:04:39 <carter> dfeuer: what perf test is that?
18:04:44 <dfeuer> carter, it's not.
18:04:53 <dfeuer> It's some optllvm thing.
18:05:20 <carter> ah
18:05:33 <carter> dfeuer: failing on harbor?
18:05:37 <dfeuer> No, locally.
18:05:45 <benzrf> (Ôæâ‚óï„ÉÆ‚óï)Ôæâ*:ÔΩ•Ôæü‚úß ‚úßÔæüÔΩ•: *„ÉΩ(‚óï„ÉÆ‚óï„ÉΩ) <- this is what i was looking for
18:05:54 <benzrf> er, just (Ôæâ‚óï„ÉÆ‚óï)Ôæâ*:ÔΩ•Ôæü‚úß
18:05:58 <carter> dfeuer: GHC HEAD ?
18:06:01 <carter> what version of llvm?
18:06:10 <dfeuer> carter, yeah. Uh.... I don't know from llvm.
18:06:29 <carter> dfeuer: opt --version
18:06:33 <carter> llc --version
18:06:42 <dfeuer> 3.4.2
18:06:45 <dfeuer> er..
18:06:54 <dfeuer> Yeah, that.
18:07:07 <dfeuer> But didn't GHC decide to bundle LLVM?
18:07:11 <dfeuer> Or is that not yet?
18:07:23 <carter> not yet
18:07:27 <dfeuer> Hrr
18:07:34 <dfeuer> What version is requiredededed?
18:07:36 <vanila> design question... How would you generate a maze in haskell?
18:08:13 <dfeuer> vanila, how would you generate a maze in #nothaskell?
18:08:25 <carter> dfeuer: i think bgamari-  has a good handle on a lott llvm stuff
18:08:42 <dfeuer> What's his number?
18:08:50 <bgamari-> dfeuer, 42
18:08:56 <dfeuer> HI BGAMARI
18:09:10 <bgamari-> dfeuer, hello!
18:09:55 <dfeuer> bgamari-, I'm trying to validate with a modified containers, and I'm getting failures of T5681. Any guesserations?
18:10:05 <bgamari-> hmm
18:10:07 <bgamari-> on HEAD?
18:10:10 <dfeuer> If you ask what the error message is, I will be sunk, because I totally lost it.
18:10:10 <bgamari-> or master rather
18:10:13 <dfeuer> Yes, on that.
18:10:22 <bgamari-> what LLVM version?
18:10:25 <dfeuer> Should I be looking on some other branch?
18:10:31 <dfeuer> LLVM version 3.4.2.
18:10:35 <bgamari-> oh dear
18:10:39 <bgamari-> hrmph
18:10:47 <dfeuer> Izzat the good version, or the bad version?
18:11:01 <bgamari-> that's a bad version but there is no way you could possibly be expected to know that
18:11:19 <dfeuer> Uh-huh.
18:11:22 <bgamari-> the error contains the word "section"?
18:11:39 <bgamari-> and probably .rodata
18:11:40 <carter> ohhhhh
18:11:41 <dfeuer> bgamari-, I think so. But I lost it. There were a number of errors, all of which looked similar.
18:11:42 <carter> ohhhhh
18:11:42 <dfeuer> YES.
18:11:44 <dfeuer> .rodata.
18:11:48 <dfeuer> That's familiar.
18:11:50 <bgamari-> dfeuer, yep
18:11:51 <bgamari-> arg
18:12:07 <bgamari-> yeah, this whole situation is just very unfortunate
18:12:10 <carter> bgamari-: so he needs to build the 7.8.4 RC
18:12:11 * dfeuer passes bgamari- four args, but bgamari- only takes 3, so dfeuer gets a type error.
18:12:12 <carter> then use that?
18:12:14 <bgamari-> 3.4 is unfortunately broken
18:12:18 <carter> oh?
18:12:19 <carter> 3.4 ?
18:12:30 <carter> 3.4 works with 7.8 though right?
18:12:36 <bgamari-> carter, yep
18:12:43 <dfeuer> That's not here, and nor is it there.
18:13:00 <bgamari-> dfeuer, the LLVM 3.5 rework exposed a bug in LLVM 3.4
18:13:19 <bgamari-> dfeuer, if you care to know more, see http://smart-cactus.org/~ben/posts/2014-11-28-state-of-llvm-backend.html
18:13:30 <bgamari-> dfeuer, but really, you shouldn't need to care
18:13:43 <dfeuer> I need to satisfy Milan Straka that my latest changes to Data.Sequence (and int-e's modifications thereof) don't break GHC validation in order to get it merged into RC3 or whatever.
18:14:08 <bgamari-> hmm
18:14:19 <bgamari-> dfeuer, native codegen isn't acceptable??
18:14:19 <carter> bgamari-  so dfeuer  needs llvm 3.5 installed and configure ghc head build to use that?
18:14:25 <dfeuer> So I'm running validation with and without, and will be satisfied when they fail the same way.
18:14:27 <bgamari-> carter, that would be onee solution
18:14:40 <bgamari-> dfeuer, I'd just use the native codegen if you can
18:14:55 <dfeuer> bgamari-, how do I do that?
18:15:06 <bgamari-> dfeuer, what architecture are you on?
18:15:19 <bgamari-> dfeuer, the native codegen ought to be the default
18:15:30 <dfeuer> Also, doesn't the validation keep going even if something fails? Or no?
18:15:31 <bgamari-> if you are on x86_64 at least
18:15:35 <dfeuer> I am on x86_64.
18:15:45 <bgamari-> I didn't think validate checked -fllvm
18:15:53 <dfeuer> WELL
18:15:59 <bgamari-> carter, did thoughtpolice add -fllvm to validate?
18:16:09 <carter> lets look
18:16:14 <bgamari-> let's
18:16:19 <dfeuer> I think we might actually be in the wrong channel.
18:16:22 <dfeuer> My fault.
18:53:33 <Pamelloes> If I have a type: data AType = Type1 String| Type2; is it possible to use a guard like |Type1 str?
18:54:25 <monochrom> no. use ordinary patterns.
18:55:39 <Pamelloes> Right now I have patterns nested about three layers. Is there a way to make each layer a separate satement?
18:57:18 <ReinH> Pamelloes: can you show an example?
18:57:47 <ReinH> (also manipulation of nested records is one of the things lens is intended for, fwiw)
18:59:07 <gcganley> ReinH: do you think lenses are hard to learn. I havent tried programming in them but I've heard a ton of the motivation and the use cases for them
19:00:26 <Pamelloes> data Type1 = A Int | B Integer; data Type2 = C Type1 | D Float; afunc :: Type2 -> Num; afunc D f = f; afunc C type1=...; Is there a way to then pattern match along type1?
19:00:33 <ReinH> I don't think they're hard to learn per se, but their documentation and other educational stuff around them could be better
19:01:42 <monochrom> lens is easy to learn if you meet the right tutorial
19:01:44 <Chathurga> When did pattern guards get added?
19:01:58 <monochrom> a bit before Haskell 2010
19:02:02 <gcganley> Chathurga: in the haskell language?
19:02:10 <gcganley> or ghc
19:02:38 <Hermit> which is the most lightweight / more strightforward  lib to read/generate xml?
19:03:11 <gcganley> @pl (\f g x -> (f x) || (g x))
19:03:11 <lambdabot> liftM2 (||)
19:03:18 <Chathurga> ghc I guess, I've just never really seen it used or referenced
19:03:22 <gcganley> :t liftM2
19:03:23 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:03:43 <gcganley> :t lift
19:03:44 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
19:04:29 <gcganley> can anyone see a better point-free implementation of (\f g x -> (f x) || (g x))
19:05:01 <gcganley> :t fmap . fmap
19:05:02 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:05:02 <Hermit> gcganley: I doubt it'll be even readable once point free
19:05:31 <gcganley> Hermit: it looks like it would be something that would be able to be made point free
19:05:51 <gcganley> :t (\f g x -> (||) (f x) (g x))
19:05:52 <lambdabot> (t -> Bool) -> (t -> Bool) -> t -> Bool
19:06:23 <Hermit> gcganley: I guess liftM2 (||) is the best you can get
19:06:46 <gcganley> :t liftM2 (||)
19:06:47 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
19:07:05 <gcganley> Hermit: it seems to strong though. im not working with monads at all
19:07:12 <Hermit> it uses the function monad
19:07:19 <Chathurga> gcganley: Functions are Monads
19:07:26 <gcganley> ohhhh it makes sense now
19:08:02 <ReinH> You're really only using the applicative
19:08:13 <gcganley> :t liftA2 (||)
19:08:14 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
19:08:35 <ReinH> \f g -> (||) <$> f <*> g = liftA2 (||)
19:09:12 <gcganley> @pl \f g -> (||) <$> f <*> g
19:09:12 <lambdabot> (((||) <$>) .) . (<*>)
19:09:24 <gcganley> wow ok
19:10:02 <gcganley> :t fmap fmap
19:10:03 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
19:10:09 <Hermit> gcganley: see what I meant with not readable?
19:10:29 <gcganley> Hermit: but liftA2 (||) is pretty readable
19:10:35 <gcganley> and i consider that pointless
19:10:42 * Hermit points to (((||) <$>) .) . (<*>)
19:11:16 <gcganley> Hermit: i gather that i was just curious what lambdabot would spit out
19:40:27 <SrPx> What is the fastest purely functional substitute for arrays when you want a lot of random sets/gets?
19:41:45 <Welkin> arrays
19:41:48 <Welkin> or vectors
19:41:52 <Welkin> or hash tables
19:42:00 <Welkin> in haskell, Maps
19:42:06 <Welkin> or Sets
19:45:14 <NemesisD> hey folks. looking for an abstraction that will fit my problem. The idea is kind of like a free monad with an interpreter to make a DSL, except every command in the language will have an inverse, so I should be able to take a sequence of actions and roll it back with their inverses
19:46:05 <HeladoDeBrownie> NemesisD, try describing the specifics first
19:46:23 <HeladoDeBrownie> So far it sounds like a generalized group? A groupoid?
19:47:43 <NemesisD> so IRL this will be in purescript. i'm going to have a little mini language that will let you describe some changes to make to an element on a web page: add this CSS class, insert text under this node. given this program, I should be able to back out the changes (remove text under this node, remove this css)
19:48:54 * hackagebot gl 0.6.2 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.6.2 (EdwardKmett)
19:50:15 <HeladoDeBrownie> What happens if you apply the "undo" without the "do"?
19:50:48 <NemesisD> it will likely be a noop, i.e. if the text isn't there, it won't do anything, if the css class isn't applied, there's nothing to remove
19:51:11 <HeladoDeBrownie> Seems like a one-sided inverse only then. Not a group nor even a group generalization.
19:51:31 <HeladoDeBrownie> Well, could be a group generalization, but not a "nice" one
19:52:03 <NemesisD> yeah, although, do >> undo >> do should be equivalent to do
19:52:20 <HeladoDeBrownie> What about undo >> do >> do?
19:52:51 <HeladoDeBrownie> Either way you are probably going to have a tough time finding an existing abstraction to encode this with, I think you could just stick with free monad + interpreter and leave some laws unspecified in types
19:53:43 <NemesisD> hmm, i think so far in the commands I'll have in the language, they should be idempotent, so undo >> do >> do = do >> do = do
20:42:16 <benzrf> > 3 `mod` 2
20:42:18 <lambdabot>  1
20:42:19 <benzrf> > 4 `mod` 2
20:42:21 <lambdabot>  0
21:01:17 <dpwright> Are there any users of diagrams-cairo in here?  I'm trying to use it to render some text, but as soon as I try to call `text` I get an out of memory error
21:03:24 <Fuuzetsu> dmj`: pong
21:12:45 <dmj`> Can anyone spot what is wrong with my CPP declaration? http://lpaste.net/116991
21:13:08 <Haskellfant> dpwright: iirc there is #diagrams, you might have mor luck getting help there
21:13:46 <dpwright> Haskellfant: ah, excellent, thanks!
21:16:34 <pavonia> dmj`: What is line 54?
21:17:13 <dmj`> pavonia: check line 16 of the paste, that is line 54
21:17:16 <dmj`> pavonia:   , module Network.HTTP.Client.TLS  -- LINE 54
21:21:37 <dmj`> pavonia: super weird, I changed "TLS" to "THING" and it works now...
21:22:19 <dmj`> wow so cool ! the docs change with it too
21:22:58 <pavonia> Btw, why do you use so many spaces at the end of each line?
21:23:06 <dmj`> pavonia: there has to be some weird rule that three lettered c flags are contraband
21:23:46 <dmj`> pavonia: what do you mean, where
21:24:27 <pavonia> dmj`: In the paste. If you mark the text after the code there are tons of space characters
21:26:13 <dmj`> pavonia: not sure, I use emacs haskell-mode, and I just ctrl-c / ctrl-v'd into the paste
21:26:54 <pavonia> Hhm, weird
21:29:40 <athan> Is there any way to make an associated type or data type in an instance a type variable?
21:31:55 <athan> or something equivalent? I'm trying to overload some monad reader transformers, where ideally my instance would just look like `instance (Monad m) => Foo prefix (ReaderT prefix m) where; type Result = m; runFoo :: forall b. ReaderT prefix m b -> prefix -> m b; runFoo = runReaderT}
21:32:14 <athan> erm, braket mismatch... I meant `
21:37:34 <drewbert> Does anybody else ever feel like haskell would be more elegant with postfix functions?   I feel like I'm always writing code right to left.
21:38:27 <drewbert> I'm a pretty new user though, so it could be that I'm not thinking about things correctly.
21:38:45 <Axman6> you can always define (|>) = flip (.) if you want and use the F# version of composition
21:39:01 <Axman6> but you get used to things being "backwards" pretty quickly
21:39:42 <rgrinberg> huh? (|>) isn't flip (.). i thought it was x |> f = f x
21:39:57 <Axman6> uh, flip ($)
21:44:54 <shock_one> Hi. Join can be defined in terms of >>= like this.
21:45:00 <shock_one> join :: Monad m => m (m a) -> m a
21:45:00 <shock_one> join x = x >>= id
21:46:06 <shock_one> But how does it happen that `id` can take place of the second argument for >>=, if id's type is a -> a, and the second argument of >>= must me a -> m a?
21:49:00 * hackagebot http-client-streams 0.3.0.0 - http-client for io-streams supporting openssl  http://hackage.haskell.org/package/http-client-streams-0.3.0.0 (DavidJohnson)
21:50:57 <pavonia> shock_one: It's not "a -> m a" but "a -> m b", so you can unify "a" and "m b"
21:51:50 <shock_one> Oh, right!
21:53:19 <shock_one> pavonia: thank you, now it makes sense.
21:53:32 <pavonia> No problem
21:54:56 <favetelinguis> if i have two sets A = {a,b} B = {1,2,3,4,5}, how many functions are there in the homset{A,B}?
21:57:04 <pavonia> favetelinguis: What is homset?
21:57:38 <favetelinguis> in chategory theory it is the set of morphisms between A and B
21:58:09 <favetelinguis> the answere shold be 32
22:01:32 <Welkin> chocolate theory
22:53:28 <Fuuzetsu> up to 32*
23:04:03 * hackagebot hspec-server 0.3.1 - Test Framework for Server's status  http://hackage.haskell.org/package/hspec-server-0.3.1 (junjihashimoto)
23:24:04 * hackagebot cabal-src 0.2.5 - Alternative install procedure to avoid the diamond dependency issue.  http://hackage.haskell.org/package/cabal-src-0.2.5 (MichaelSnoyman)
23:34:04 * hackagebot pretty 1.1.1.3 - Pretty-printing library  http://hackage.haskell.org/package/pretty-1.1.1.3 (DavidTerei)
23:58:59 <ReinH> favetelinguis: homsets are morphisms in a category
