00:16:00 * hackagebot brainfuck-tut 0.7.0.0 - A simple BF interpreter.  http://hackage.haskell.org/package/brainfuck-tut-0.7.0.0 (alcabrera)
00:30:26 <dmwit> torpet_: (++) traverses its second argument, but not its first.
00:30:44 <dmwit> sorry
00:30:56 <dmwit> torpet_: (++) traverses its *first* argument, but not its second. (derp!)
00:31:55 <srhb> torpet_: When you consider they are singly linked lists, this makes sense, because you have to traverse the first (left) list in order to find the [] that you need to change to a link to the first element of the second (right) list.
00:32:15 <dmwit> torpet_: So "a ++ (b ++ (c ++ ...))" is better than "((... ++ a) ++ b) ++ c" because the former traverses "a" once (while computing the outermost (++)), while the latter traverses "a" many times (once for each (++)).
00:32:21 <torpet_> ohhh so foldr is traversing again and again and again
00:32:28 <torpet_> *foldl
00:32:32 <srhb> torpet_: Yeah.
00:32:38 <torpet_> where as foldr concats exactly n times
00:34:32 <srhb> foldl traverses xs1, then xs1++xs2, then (xs1++xs2)++xs3 ...
00:45:39 <torpet_> dmwit: thanks guys
00:57:41 <trap_exit> does anyone have "AWS as a monad" ? i.e. I can jsut fire off AWS, send computations to it, and get answers back?
00:57:45 <trap_exit> like do // AWS monad
00:57:47 <trap_exit> m <- get machine
00:57:52 <trap_exit> y <- compute_on m (f x)
00:57:55 <trap_exit> return y
01:01:43 <dmwit> trap_exit: There's Cloud Haskell. No idea what its relationship with AWS is.
01:06:03 * hackagebot token-bucket 0.1.0.1 - Rate limiter using lazy bucket algorithm  http://hackage.haskell.org/package/token-bucket-0.1.0.1 (HerbertValerioRiedel)
01:07:02 <dmj`> trap_exit: you can run haskell programs on ec2 instances
01:09:55 <dmj`> trap_exit: how would compute_on work?
01:10:07 <trap_exit> i have no fucking clue
01:10:13 <trap_exit> but I suspect someone smarter than me can make it work
01:10:25 <trap_exit> ... that's basically been my entire experienc elearning haskell
01:13:14 <dmj`> trap_exit: you could run a cloud haskell app over a few instances on ec2. If using master-slave, the master could expose a tcp port and you could issue commands to it, it would then in turn send work for the slaves to do, and write back to you over tcp.
01:13:46 <trap_exit> yeah
01:13:49 <trap_exit> but then I ahve to do all serialization
01:14:14 <trap_exit> i'd like to write 1 haskell prog, and view the cluster sorta like numa
01:14:18 <dmj`> trap_exit: you can use ghc generics to serialize
01:15:09 <trap_exit> dmj`: this all sounds great
01:15:16 <trap_exit> but it requires work on my part
01:15:24 <trap_exit> I'd hop[e someone just builds this together, so I can just use it :-)
01:15:43 <dmj`> trap_exit: sometimes you must be the change you want to see
01:15:58 <trap_exit> i want to be the guy on irc who inspires dmj` to build it
01:16:20 <dmj`> trap_exit: i want to be the guy on irc who inspires trap_exit to build it
01:17:02 <trap_exit> given how well I know trap_exit, I recommend you pick something slightly more do-able
01:18:41 <Zemyla> @pl \r -> [((fromRational r), 1)]
01:18:41 <lambdabot> return . flip (,) 1 . fromRational
01:22:21 <dmj`> does 7.8.3 auto unpack strict fields?
01:22:43 <t4nk133> hello
01:23:24 <Taneb> dmj`, I think it does, at least sometimes
01:23:49 <shachaf> When you pass it -funbox-strict-fields
01:24:46 <t4nk133> i am working with Parsec and i need something like "changeUserState :: u -> ParsecT s u' m a -> ParsecT s u m a". I know it's possible using Parsec's internal representation but I can't get access to it
01:24:55 <t4nk133> anyone
01:27:24 * moriarty farts
01:27:35 <dmj`> Taneb, shachaf: thanks
01:28:32 <shachaf> moriarty: This is not appropriate behavior for this channel.
01:28:59 <moriarty> anyone here working for finance?
01:29:13 <moriarty> or are most of you just tots at school i mean university
01:30:11 <shachaf> moriarty: Please stop.
01:30:13 <dmwit> Belittling people isn't exactly appropriate behavior, either.
01:30:33 <moriarty> sorry i mean brilliant folks
01:30:35 <shachaf> Yes.
01:30:53 <moriarty> oh glorious ivory tower attendees
01:31:28 <shachaf> Looking through the logs suggests this behavior is a pattern, so consider this your last warning.
01:32:06 <dmwit> t4nk133: It might not be possible with the API provided.
01:33:26 <srhb> ParsecT is exported though, shouldn't that suffice?
01:33:33 <srhb> Or am I misunderstanding.
01:33:51 <srhb> Oh no, it isn't.
01:34:37 <dmwit> trap_exit: Er, I think Cloud Haskell does provide a way for you to just "ask for a function to be run elsewhere", provided both the "here" and the "there" are running the same program.
01:34:49 <dmwit> Like, all the serialization problems *have* been solved by somebody else.
01:34:52 <dmwit> right?
01:36:02 <srhb> dmwit: With some restrictions to which functions can be serialized, afair.
01:36:26 <dmwit> Sure. Fairly reasonable restrictions, too.
01:37:01 <srhb> Indeed.
01:40:41 <t4nk133> I'm working on using Parsec's compatibility functions "runParserT" and "mkPT" to achieve something of type "(u -> u') -> (u' -> u) -> ParsecT s u m a -> ParsecT s u' m a
01:42:45 <dmwit> That type looks fishy. If you can convert both directions... why bother converting?
01:44:24 <dmwit> (...said the guy who spent six years claiming that "converting in two directions" was a Pretty Good Idea)
01:44:48 <chrisdotcode> hi everyone
01:45:19 <chrisdotcode> if I do something like this: let (<//>) = (>>=), does (<//>) inherit bind's infixr (of 1)?
01:45:36 <chrisdotcode> *infixl
01:46:23 <srhb> chrisdotcode: I don't think fixity declarations are ever inherited.
01:46:47 <chrisdotcode> srhb: Okay, so I have to manually declare them, always?
01:46:54 <chrisdotcode> What's the default, then?
01:47:03 <dmwit> ?where report
01:47:04 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
01:47:24 <srhb> chrisdotcode: infixl 9
01:47:55 <chrisdotcode> srhb: Thanks. Knowing this has likely saved me hours and hours.
01:48:21 <srhb> chrisdotcode: The report is good advice. :)
01:48:31 <chrisdotcode> Oh, I didn't know that was for me, dmwit
01:48:34 <chrisdotcode> Thanks guys.
01:48:40 <dmwit> 4.4.2 "Any operator lacking a fixity declaration is assumed to be infixl 9"
01:48:44 <dmwit> It wasn't for you.
01:48:48 <dmwit> I was looking it up. =P
01:48:57 <chrisdotcode> Glad I can stump the gurus ;)
02:32:15 <Zemyla> @pl \a -> reverse (concat a)
02:32:16 <lambdabot> reverse . join
02:39:43 <giorgio2k14> salve a tutti
02:40:20 <giorgio2k14> !list
02:40:21 <monochrom> giorgio2k14: http://hackage.haskell.org/packages/archive/pkg-list.html
02:40:58 <ChristianS> i have this expression:  filter (\x -> head (fieldName x) /= '-') mylist  -- can i replace the lambda by something more elegant/pointfree?
02:41:22 <pavonia> @pl \x -> head (fieldName x) /= '-'
02:41:23 <lambdabot> ('-' /=) . head . fieldName
02:41:45 <dmwit> ?pl \x -> not ("-" `isPrefixOf` x)
02:41:46 <lambdabot> not . ("-" `isPrefixOf`)
02:41:48 <ChristianS> ah!
02:42:04 <shachaf> isn'tPrefixOf
02:42:17 <shachaf> Hmm, the way I wrote that makes it look like it actually exists. It doesn't.
02:42:28 <dramforever> ChristianS, I think you don't need to do that
02:42:28 <shachaf> I just like the opportunity to use apostrophes in Haskell identifiers.
02:42:34 <Haskellfant> there's surely something in acme php :P
02:42:35 <ChristianS> pavonia, dmwit didn't know that lambdabot can do that, thanks
02:42:35 <dmwit> > ("-" `isPrefixOf` "", head "" /= '-')
02:42:35 <dramforever> yep
02:42:37 <lambdabot>  (False,*Exception: Prelude.head: empty list
02:42:44 <wz1000> OK, I have some lists, and I need to find out the length of the list of minimum size that contains atleast one element from each list. Any ideas?
02:43:21 <wz1000> eg: for [[1,2],[2,3]], the length is 1([2])
02:44:26 <dmwit> So, like, a minimum cover problem.
02:44:32 <wz1000> dmwit: Yes
02:44:32 <dmwit> Aren't there solvers out there for that?
02:44:43 <wz1000> dmwit: I can't find any
02:45:06 <dmwit> http://hackage.haskell.org/package/set-cover maybe?
02:45:50 <pavonia> Isn't the result of that always 0 or 1?
02:46:09 * hackagebot rethinkdb-client-driver 0.0.11 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.11 (wereHamster)
02:46:12 <dramforever> how about this: first nub . sort the,
02:46:14 <dramforever> them
02:46:18 <dmwit> pavonia: I guess with [[1,2],[2,3],[3,4]] the minimal length would be at least 2.
02:46:29 <shachaf> thou shalt not cover thy neighbor's set
02:46:29 <dmwit> pavonia: e.g. [2,4] would be a minimal cover for that
02:46:38 <dramforever> hmm...
02:46:50 <pavonia> Hhm, I don't understand the problem then
02:46:53 <dramforever> sorry, that was just some random thought
02:47:25 <dmwit> pavonia: Took me a few reads through the problem statement to understand it, too.
02:48:12 <dramforever> find set A with minimum number of elements such that forall x
02:48:21 <dmwit> pavonia: It helped me to realize that "the list of minimum size" is quantified over *all* lists, not just lists in the input.
02:48:45 <dramforever> forall x in lists, exists a in A such that a is in x
02:49:46 <pavonia> dmwit: Ah, I think I got it. [2,3] would be another solution in your last example, right?
02:49:55 <dmwit> pavonia: right
02:50:07 <pavonia> Okay
02:51:03 <dmwit> wz1000: Well, in case set-cover won't do what you want, it seems Wikipedia has some hints about how to do it.
02:51:43 <dmwit> Google suggests there are some Haskell bindings to ILP solvers, so you might ship out to one of them.
02:57:34 <ChristianS> is there some ghci equivalent to lambdabot's ?pl ?
02:57:46 <shachaf> @hackage pointfree
02:57:47 <lambdabot> http://hackage.haskell.org/package/pointfree
02:58:10 <ChristianS> shachaf: ah, cool
03:06:25 <t4nk133> @djinn (a,b) -> (a,c) -> a -> b -> c
03:06:26 <lambdabot> f _ (_, a) _ _ = a
03:06:44 <t4nk133> hha
03:07:39 <t4nk133> @djinn ((a,b) -> (a,c)) -> a -> b -> c
03:07:39 <lambdabot> f a b c =
03:07:39 <lambdabot>     case a (b, c) of
03:07:39 <lambdabot>     (_, d) -> d
03:09:38 <dmwit> ?djinn ((a,b) -> (a,b)) -> a -> b -> b
03:09:38 <lambdabot> f a b c =
03:09:38 <lambdabot>     case a (b, c) of
03:09:38 <lambdabot>     (_, d) -> d
03:09:54 <dmwit> Despite the code being exactly the same, this one is more impressive to me.
03:10:10 <shachaf> Djinn tries to use as many of the arguments as it can.
03:10:15 <shachaf> Or something along those lines.
03:10:24 <dmwit> Yes.
03:10:57 <shachaf> @djinn (a -> a) -> (a -> a) -> a -> a
03:10:57 <lambdabot> f _ a b = a b
03:11:01 <shachaf> Hm.
03:11:21 <dmwit> Now we just need to teach djinn how to pick good names.
03:11:33 <dmwit> f _ g a = g a
03:11:44 <shachaf> Why didn't it use the first argument?
03:11:48 <shachaf> There were so many possibilities.
03:12:24 <dramforever> @djinn (a -> b -> c) -> (a -> b) -> (a -> c)
03:12:24 <lambdabot> f a b c = a c (b c)
03:12:38 <dramforever> @pl \a b c -> a c (b c)
03:12:38 <lambdabot> ap
03:13:04 <dramforever> it would be much more impressive if we had djinnpl
03:13:19 <t4nk133> it's the function >>= flipped
03:13:23 <dmwit> ?. pl djinn (a -> b -> c) -> (a -> b) -> (a -> c)
03:13:24 <lambdabot> f = ap
03:13:33 <dmwit> t4nk133: it's not
03:13:43 <t4nk133> I mean the >>= of the function monad instance
03:13:49 <dmwit> I know what you mean.
03:13:56 <dmwit> But it's not. It's ap.
03:14:08 <dmwit> ?src ap
03:14:08 <lambdabot> ap = liftM2 id
03:14:09 <shachaf> dmwit: It's also (>>=) with enough flipping.
03:14:14 <t4nk133> but fliped
03:14:20 <dmwit> :t (=<<)
03:14:21 <lambdabot> Monad m => (a -> m b) -> m a -> m b
03:14:21 <t4nk133> yes
03:14:30 <shachaf> You need to flip more than that, though.
03:14:35 <shachaf> m = (a ->)
03:15:03 <shachaf> But there are some situations where @pl generates (>>=) instead of ap where either would work.
03:15:44 <dmwit> Yes, okay.
03:15:55 <dmwit> It's (>>=) flipped, with its argument flipped.
03:16:03 <dmwit> Got it.
03:16:08 <t4nk133> a@djinn (a -> f a) -> (f b -> b) -> a -> b
03:16:20 <t4nk133> @djinn (a -> f a) -> (f b -> b) -> a -> b
03:16:21 <lambdabot> -- f cannot be realized.
03:16:39 <t4nk133> @djinn ((a -> f a) -> (f b -> b) -> a -> b) -> (a -> f a) -> (f b -> b) -> a -> b
03:16:39 <lambdabot> f a = a
03:17:39 <t4nk133> Hm.
03:20:58 <ThreeOfEight> t4nk133: what causes your confusion?
03:25:10 <indigo945> hi
03:25:18 <indigo945> how can i have mutually recursive data types in haskell?
03:25:37 <indigo945> data Unit = Unit {buttons :: [Button], ...}
03:25:50 <indigo945> data Button = Button {callback :: Unit -> Stuff, ...}
03:25:57 <indigo945> won't compile because "data constructor not in scope"
03:26:41 <shachaf> That's the whole thing GHC prints?
03:26:51 <haasn> Try putting them in the same module. Or recursively import their respective modules.
03:27:30 <indigo945> main.hs:41:26: Not in scope: type constructor or class `UnitData'
03:27:36 <indigo945> main.hs:42:30: Not in scope: type constructor or class `Button'
03:27:37 <indigo945> main.hs:45:24: Not in scope: type constructor or class `UnitData'
03:27:41 <indigo945> all the error messages i get
03:27:45 <indigo945> they are in the same file
03:28:05 <shachaf> You should go to hpaste.org and paste your full error message and full code.
03:28:12 <indigo945> will do
03:28:17 <shachaf> A type constructor is the opposite of a data constructor.
03:29:08 <indigo945> shachaf: yes, my bad
03:29:13 <indigo945> i've been doing haskell for like a week
03:29:17 <indigo945> this is the code
03:29:17 <indigo945> http://pastebin.com/SWNR6Pup
03:29:24 <indigo945> the entire error message i posted above
03:29:45 <indigo945> i know the code is grueling, i'm participating in ludum dare, no time for clean code ;)
03:30:10 <shachaf> OK, the error is coming from makeFields.
03:30:33 <shachaf> The issue is with Template Haskell, which is run in order, not with the Haskell data type definitions.
03:31:04 <indigo945> okay
03:31:16 <indigo945> can i get around having to the lenses manually, or do i just have to swallow that pill then?
03:31:36 <dmwit> Put the TH after all the recursive definitions.
03:31:39 <dmwit> Should be enough.
03:31:41 <shachaf> This is why you should post your whole code. If you knew where the problem was, you wouldn't be asking the question. :-)
03:31:48 <shachaf> And yes, what dmwit said should probably work.
03:31:54 <indigo945> okay, nice. thanks!
03:33:47 <gunnarsson> hello, does ghc supports J's method of notating negative numbers, i.e. _4 = -4
03:34:32 <int-e> no.
03:34:39 <gunnarsson> no plugin?
03:35:18 <int-e> > let f _1 _2 _3 = _1 in f 5 4 3 -- they're valid identifiers.
03:35:20 <lambdabot>  5
03:35:48 <gunnarsson> god, isn't that lovely, well, on I go
03:36:56 <dmwit> I don't think it's lovely necessarily. And I like the show of respect but it's not necessary to call me god.
03:37:33 <MP2E> hehe
03:37:42 <gunnarsson> no, just who in the name of _ would name their variable _3?
03:38:18 <dmwit> Well, GHC does have a handy mode where it will warn you if you name a variable and never use it.
03:38:24 <dmwit> And it doesn't warn you about names starting with _.
03:38:54 <dmwit> e.g. "null [] = True; null _xs = False"
03:39:40 <dmwit> Or a more compelling example is "foldr _f z [] = z; foldr f z (x:xs) = ...". The naming parallel is nice.
03:39:46 <raichoo> gunnarsson: http://hackage.haskell.org/package/lens-4.6.0.1/docs/Control-Lens-Tuple.html
03:40:26 <geekosaur> ^ autogenerated code, including lenses / generics, could be expected to do that
03:41:39 <gunnarsson> dmwit: i've nothing agaist variables starting with _, but that _\d* is completely valid
03:42:13 <shachaf> I've got nothing against variables starting with _, except if they also end in digits and have nothing else in between.
03:45:05 <gunnarsson> would it be wise to maybe add this as a feature request on trac? that a word in the form of _[0-9]* should interpreted as a negative number
03:45:47 <kvanb> I dont think so
03:45:59 <shachaf> J is not generally seen as a useful source of inspiration to take syntax from for most languages.
03:46:03 <indigo945> gunnarson: lens uses it pretty often, so probably not
03:46:14 <indigo945> well, lens uses it, and lots of people use lens
03:46:39 <kvanb> theres heaps of more useful stuff the GHC dev team can be doing
03:47:56 <geekosaur> there is a generic plugin interface in development, if someone really wants a mutant HaskellJ they could grab GHC HEAD and write their own plugin
03:49:17 <gunnarsson> well, i just really dislike the '-' creature, but i guess i'm not bothered enough to do something about it
03:51:51 <dmwit> What is so bad about '-'?
03:52:03 <dmwit> In a few rare cases, you have to type one or two more characters.
03:52:42 <dmwit> This is, like, not even in the top one thousand things that makes writing a program expensive.
03:53:41 <gunnarsson> dmwit: eugh, i dunno
03:55:02 <dmwit> gunnarsson: Well, with a strong motivating case like that... of course you should advocate for change! =P
03:56:20 <gunnarsson> dmwit: just as i replied to you i got a compilation error 'couse of it, just feels a wee-bit unclean/edge-casey
03:57:11 <MP2E> how is _ instead of - any less unclean? _ does not mean negative
03:57:22 <wei2912> in some languages it does
03:57:26 <gunnarsson> MP2E: using J as a model
03:57:34 <gunnarsson> MP2E: as bad as that sounds
03:57:41 <geekosaur> I'm not convinced switching the character would even work, since (a) what about unary minus, the operator? (b) and unary operators in general are not really parseable given the way Haskell parsing works
03:59:30 <gunnarsson> geekosaur: it would just be notation for negative numbers, if i understand your argument
04:01:27 <pavonia> gunnarsson: Would __1 be equal to 1?
04:01:33 <MP2E> h
04:01:38 <MP2E> oops
04:02:32 <gunnarsson> pavonia: no idea, i'd say a syntax error, but i truly don't know
04:03:15 <gunnarsson> pavonia: just wanted to argue with someone wether it'd be a good idea
04:04:44 <thebnq> i agree that its dislikeable, one operator gets such unique parsing status :s
04:05:05 <gunnarsson> though `negate' for negation, `-' for minus and `_34' for -34 seems the most attractive to me
04:05:11 <thebnq> overloading status too
04:15:54 <ThreeOfEight> I'm wondering what the easiest way is to write an efficient splitOn
04:16:01 <ThreeOfEight> my current code is this: http://lpaste.net/115797
04:16:44 <ThreeOfEight> the splitOn from Data.List.Split is quite a bit more complicated, I'm looking for something self-contained
04:19:04 <bitonic-> ThreeOfEight: I'd use a standard string search algorithm, e.g. Boyer-Moore
04:19:20 <bitonic-> if you're looking for performance
04:21:15 * hackagebot HueAPI 0.2.3 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0.2.3 (SjoerdVisscher)
04:22:27 <shachaf> Boyer-Moore on linked lists. This is the future we've built for ourselves.
04:24:22 <ThreeOfEight> bitonic-: I'm looking for something short and concise
04:24:26 <ThreeOfEight> but not too inefficient
04:24:46 <ThreeOfEight> and by "inefficient" I mean w.r.t. space leaks and stuff like that
04:24:55 <ThreeOfEight> and appending on the wrong end
04:26:01 <bitonic-> shachaf: that most of the time you're going to use `splitOn' with a small pattern on a long string.  I don't think Boyer-Moore would work too bad with linked lists in that case.  but yeah it's icky
04:26:43 <dimsuz> please explain why [1,2] ++ [[3,4]] is not an error considering ++ :: [a] -> [a] -> [a]
04:27:02 <bitonic-> :t [1,2]
04:27:03 <lambdabot> Num t => [t]
04:27:06 <bitonic-> :t [[3,4]]
04:27:07 <lambdabot> Num t => [[t]]
04:27:17 <bitonic-> dimsuz: what's `a'?
04:27:30 <ThreeOfEight> Linked lists are generally not a good idea with long texts, I would say
04:27:48 <ThreeOfEight> but I'm taking part in a competition which has /no/ extra packages installed on their evaluation server
04:27:55 <bitonic-> dimsuz: it is an error
04:28:09 <dimsuz> bitonic-: I don't get it... a is an integer in this case, why it accepts lists
04:28:22 <ThreeOfEight> bitonic-: no, it is not
04:28:26 <bitonic-> > [1::Integer, 2] ++ [[3,4]]
04:28:28 <lambdabot>  Couldn't match expected type ‘GHC.Integer.Type.Integer’
04:28:28 <lambdabot>              with actual type ‘[t0]’
04:28:30 <ThreeOfEight> dimsuz: no, they are not integers
04:28:35 <ThreeOfEight> numbers in Haskell are polymorphic
04:28:46 <ThreeOfEight> :t [1,2] ++ [[3,4]]
04:28:47 <lambdabot> (Num [t], Num t) => [[t]]
04:28:58 <bitonic-> right
04:29:03 <ThreeOfEight> Haskell has no problem typing this expression, provided that 3 is a list
04:29:06 <ThreeOfEight> which makes no sense
04:29:14 <dimsuz> I tried all this stuff with :t and still i can't get my head around that!
04:29:17 <ThreeOfEight> so, technically, this is a well-typed expression
04:29:24 <ThreeOfEight> but morally, it's not
04:29:29 <ThreeOfEight> dimsuz: look at this
04:29:32 <ThreeOfEight> :t 3
04:29:33 <lambdabot> Num a => a
04:29:33 <bitonic-> dimsuz: so the issue here is the overloading of number literals.  1 could be converted to some list
04:29:45 <ThreeOfEight> This means that 3 can be any numeric type
04:29:50 <dimsuz> so haskell just converts number into a list silently?
04:29:51 <ThreeOfEight> :t 1 + [3]
04:29:52 <lambdabot> (Num [t], Num t) => [t]
04:30:21 <ThreeOfEight> This means that in order for the expression to be well-typed, the 1 has to be a numeric type and the [3] has to be y numeric type
04:30:41 <ThreeOfEight> but in practice, there will simply not be a Num instance for lists, so this will not work
04:30:44 <bitonic-> dimsuz: it will if you have some instance `instance Num [a]'.  if you're not using some strange package you're not going to have such an instance
04:30:55 <ClaudiusMaximus> @let instance Num a => Num [a] where fromInteger i = [fromInteger i]
04:30:56 <lambdabot>  .L.hs:153:10: Warning:
04:30:57 <lambdabot>      No explicit implementation for
04:30:57 <lambdabot>        ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
04:30:57 <lambdabot>      In the instance declaration for ‘Num [a]’
04:30:57 <lambdabot>  
04:31:05 <ThreeOfEight> dimsuz: it does not convert them automatically, but it /could/ convert number literals to lists if you gave such an instance
04:31:07 <ClaudiusMaximus> > [1,2] ++ [[3,4]]
04:31:09 <lambdabot>  No instance for (GHC.Show.Show t0)
04:31:09 <lambdabot>    arising from a use of ‘M524505047594535391810158.show_M5245050475945353918...
04:31:09 <lambdabot>  The type variable ‘t0’ is ambiguous
04:31:09 <lambdabot>  Note: there are several potential instances:
04:31:09 <lambdabot>    instance [safe] GHC.Show.Show
04:31:09 <ThreeOfEight> which is probably not a good idea
04:31:15 * hackagebot JuicyPixels 3.2 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.2 (VincentBerthoux)
04:31:24 <dimsuz> ok, I can get why it is a well-typed expression, but then what 1 + [3] actually is? it can't print it, but is ok with it.
04:31:44 <ClaudiusMaximus> > [1,2] ++ [[3,4]] :: [[Integer]]
04:31:45 <lambdabot>  No instance for (GHC.Num.Num [GHC.Integer.Type.Integer])
04:31:45 <lambdabot>    arising from the literal ‘1’
04:31:59 <ThreeOfEight> What 1 + [3] is depends on the specific type 1 and 3 have
04:32:08 <ThreeOfEight> similarly, what 1 + 1 is depends on the type you have
04:32:16 <ThreeOfEight> if you use integers, 1 + 1 is 2
04:32:27 <ThreeOfEight> if you use floats, 1 + 1 is 2.0 (or something close to 2.0)
04:32:34 <dimsuz> and if 1 and 3 is integers, what is 1 + [3] ?
04:32:47 <dimsuz> how can i add value and a list?
04:32:51 <ThreeOfEight> if you use the residue class ring modulo 2, 1 + 1 is 0
04:32:58 <ThreeOfEight> if 1 and 3 are integers, 1 + [3] is not well-typed
04:33:07 <ThreeOfEight> because 1 :: Integer and [3] :: [Integer]
04:33:11 <bitonic-> > (1::Integer) + [3]
04:33:13 <lambdabot>  Couldn't match expected type ‘GHC.Integer.Type.Integer’
04:33:13 <lambdabot>              with actual type ‘[t0]’
04:33:26 <ThreeOfEight> yeah, in that case, 1 is an Integer and [3] is "list of something"
04:33:28 <ThreeOfEight> doesn't work
04:33:32 <dimsuz> ok, got it. but then when is this well typed?
04:33:41 <dimsuz> 1 + [3] I mean
04:33:49 <dimsuz> some concrete case
04:33:53 <ThreeOfEight> it's well-typed if you leave the type polymorphic
04:34:03 <ThreeOfEight> a concrete case would be if you gave a Num instance for lists
04:35:34 <dimsuz> this originated from me trying to understand how exactly this expression works '(map . (++)) [1,2] [[3,4],[5,6]]', so I figured that it first applies (++) to two args and then applies map to the result
04:35:41 <ThreeOfEight> http://lpaste.net/115800
04:35:45 <ThreeOfEight> Here's your concrete example
04:36:04 <ThreeOfEight> the instance says Haskell "I want to treat lists of numbers as numbers"
04:36:08 <dimsuz> but when I typed :t (++) [1,2] [[3,4],[5,6]], I got into this 'could not wrap my head around this" curve :)
04:36:15 * hackagebot free-functors 0.6.3.3 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.6.3.3 (SjoerdVisscher)
04:37:05 <bitonic-> dimsuz: that's a more legit example though.  you're prepending [1,2] to each of those lists
04:37:06 <ThreeOfEight> that has nothing to do with this
04:37:14 <bitonic-> > (map . (++)) [1::Integer,2] [[3,4],[5,6]]
04:37:16 <lambdabot>  [[1,2,3,4],[1,2,5,6]]
04:37:16 <bitonic-> so this works
04:37:17 <dimsuz> ThreeOfEight: thanks, I must give this some thought. I can't get it to 'click' for some reason...
04:37:35 <ThreeOfEight> "(map . (++)) xs ys" does the same as "map (xs ++) ys"
04:37:59 <ThreeOfEight> "(map . (++)) xs ys == map ((++) xs) ys == map (xs ++) ys"
04:38:19 <ThreeOfEight> i.e., as bitonic- said, it just prepends xs to all lists in ys
04:38:59 <ThreeOfEight> the expression "(++) xs ys" is something very different, that prepends xs to ys
04:39:01 <dimsuz> I had it in my head like this, but then went some other way for some reason :)
04:39:06 <ThreeOfEight> and for that, xs must have the same type as ys
04:39:15 <ThreeOfEight> Polymorphism can be a bit confusing
04:39:21 <ThreeOfEight> especially in combination with type classes
04:39:42 <ThreeOfEight> so perhaps it is better if you make stuff monomorphic whenever you try to understand what something does
04:39:48 <dimsuz> thank you very much for help
04:40:18 <ThreeOfEight> e.g. by typing "(++) [1::Integer,2] [[3::Integer,4],[5,6]]" instead of just "(++) [1,2] [[3,4],[5,6]]"
04:40:26 <ThreeOfEight> then Haskell will immediately give you a type error
04:40:37 <dimsuz> oh, I see
04:40:38 <bitonic-> dimsuz: so with `1 + [3]', GHC sees `1' and infers type `Num a => a' for it -- 1 can be any numeric type.  then sees `[3]' and infers `Num b => [b]' -- a list of any numeric type you want.  then sees `+' and it knows that the two types should be equal.  so it refines the `a' parameter for `1' to `[b]', and then equates the two, so that you get `Num b, Num [b] => [b]'
04:41:14 <bitonic-> well rather then equating the two, it makes `1' to a list of the right number type -- the `b' that it inferred for `[3]'
04:41:15 <dimsuz> bitonic-: oh! that is clear to me
04:41:16 * hackagebot FontyFruity 0.4 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.4 (VincentBerthoux)
04:42:29 <bitonic> dimsuz: it can be helpful to derive the type manually, and see if it makes sense
04:42:43 <bitonic> the basic algorithm is very easy, if you pretend all the fancy extensions don't exist :)
04:42:49 <dimsuz> bitonic: so it stays in this 'polymorphic' form until I try evaluating. And if at evaluation time those constraints will not be fulfilled (e.g. by some new instanse demoed by ThreeOfEight), it will be an error
04:43:52 <dimsuz> I might not be quite right with terminology here
04:44:29 <bitonic> dimsuz: no, it's not until you try evaluating, it's rather the fact that if you want lambdabot to come up with some number to print it needs a concrete instance to work on
04:44:40 <bitonic> but you can write and compile polymorphic functions, no problems
04:47:29 <bitonic> dimsuz: one nice way to see this polymorphic code is that those polymorphic functions, when compiled, have as the first argument a dictionary that holds the type-class methods that the function uses
04:47:32 <dimsuz> bitonic: I see. I mean there will be a time where my program will need to use this polymorphic funciton on some concrete type and in the example above it would better be some type which confroms to Num b, Num [b].
04:47:52 <bitonic> right
04:48:10 <dimsuz> yay, looks like I finally got it. thank you.
04:48:26 <bitonic> but the instantiation of the polymorphic variables doesn't happen when you "try to evaluate" the expression
04:48:33 <dimsuz> yes
04:49:12 <ThreeOfEight> In fact, it is  actually /exactly/ like what bitonic says
04:49:59 <ThreeOfEight> in the intermediate language Haskell compiles to, a Num constraint manifests itself as an additional parameter, which contains all the operations like (+), (-) and so on
04:50:18 <wei2912> what's the style guide for using as-patterns?
04:50:29 <wei2912> i've seen people on SO use `xs@(x:ix)`
04:51:42 <bitonic> wei2912: you mean the style for the variable names?
04:51:46 <wei2912> bitonic: yeh
04:53:05 <bitonic> wei2912: I try to use sensible names on a case-by-case basis.  I think these general rules for namings do more harm than good.  but that's my opinion :P
04:53:25 <wei2912> bitonic: i can't think of anything better though
04:53:28 <bitonic> and I'm not sure there are general rules in this case, apart from `x : xs' for lists
04:53:37 <wei2912> yeh
04:54:16 <bitonic> naming is surely hard
04:55:39 <wei2912> :(
04:58:54 <ChristianS> wei2912: i'd probably use something such as `words@(first:rest)`, where `words` is a plural-form word that describes the contents of the list. but tastes differ.
04:59:16 <wei2912> ChristianS: i see
04:59:23 <wei2912> i'd like something short.
04:59:40 <wei2912> i'm not really concerned with the name, tbf
05:00:03 <wz1000> Is there anyway I can use something like loeb to refer to relative positions?
05:06:17 * hackagebot aeson-streams 0.1.0 - An HTTP client library for JSON-based APIs  http://hackage.haskell.org/package/aeson-streams-0.1.0 (VoMinhThu)
05:07:29 <wz1000> NVM, got it
05:14:12 <wz1000> rloeb fs = fix $ \xs -> fmap ($ xs) (zipWith ($) fs [0..length fs]) is what I wrote if anyone's interested
05:14:27 <wz1000> I wonder if there is any way to generalize it...
05:15:01 <ion> zipWith ($) fs [0..] would work and also not iterate over fs twice.
05:15:21 <wz1000> ion: Thanks, missed that
05:17:11 <wz1000> ion: it will now work for streams as well!
05:18:08 <dreams> Hello nerds.
05:28:45 <ThreeOfEight> "if x == True then True else False"
05:28:53 <ThreeOfEight> Shit my students write.
05:29:39 <chrisdone> “Shit my teacher teaches.”
05:30:02 <ThreeOfEight> Not here they don't.
05:30:10 <nerium> Is there a way todo this in Haskell. [1,2] & [1,4,5] => [4,5]. Only return values from the second list that's not in the first one
05:30:12 <hvr> ThreeOfEight: maybe 'True' is not 'Prelude.True' =)
05:30:24 <mauke> > [1,4,5] \\ [1,2]
05:30:26 <lambdabot>  [4,5]
05:30:34 <ion> > [1,4,5,1] \\ [1,2]  -- note
05:30:36 <lambdabot>  [4,5,1]
05:30:50 <mauke> > [1,4,5,1] \\ [1,1,2]
05:30:52 <lambdabot>  [4,5]
05:31:05 <ThreeOfEight> > nub [1,4,5,1] \\ [1,2]
05:31:07 <lambdabot>  [4,5]
05:31:19 <ThreeOfEight> > filter (`notElem` [1,2]) [1,4,5,1]
05:31:21 <lambdabot>  [4,5]
05:31:21 <ion> [1,4,5] \\ cycle [1,2]  ;-)
05:32:05 <ThreeOfEight> I recommend using "filter (`notElem` [1,2]) [1,4,5,1] if you want to get [4,5] there
05:32:17 <ThreeOfEight> and "[1,4,5,1] \\ [1,2]" if you want to get [4,5,1].
05:32:48 <ThreeOfEight> hvr: then it probably wouldn't type check
05:32:56 <mauke> ThreeOfEight: now I'm thinking about rewrite rules to simplify that code
05:33:20 <mauke> x == True ==> x; x == False ==> not x
05:33:31 <mauke> if x then y else False ==> x && y
05:33:31 <Kaidelong> ThreeOfEight: that's a specialized id for Bools, they must be doing it to help the type inference engine
05:33:34 <Kaidelong> !!
05:33:41 <mauke> x && True ==> x
05:33:48 <ThreeOfEight> Kaidelong: pff, this isn't F# or Scala
05:33:52 <hvr> ThreeOfEight: when I learned Haskell, I used to write stuff w/ 'import Prelude hiding (True,False)' to cheat the stupid validation scripts of my course =)
05:34:08 <ThreeOfEight> Our type cheker doesn't need help
05:34:12 <ThreeOfEight> *checker
05:34:37 <ThreeOfEight> hvr: we have a pretty fancy test system
05:34:58 <ThreeOfEight> based on QuickCheck, SmallCheck, tasty, spoon, SafeHaskell, and cyp
05:35:11 <nerium> mauke: Thanks!
05:35:20 <ThreeOfEight> the last is a simple untyped equational theorem prover someone at our chair hacked together
05:35:45 <ThreeOfEight> (but it supports induction)
05:35:49 <Kaidelong> I've actually found that I've used things like `asTypeOf` in Haskell way more than I did in F#
05:36:36 <mauke> Haskell `asTypeOf` F#
05:36:54 <ThreeOfEight> I use that very rarely, when I want to specialise polymorphic functions
05:37:50 <wz1000> asTypeOf is a specialised const?
05:38:01 <Kaidelong> most of the time the stupid hack I have to use has been things in the form of where clauses that just say what types things are
05:38:21 <Kaidelong> wz1000: yeah, basically, instead of a -> b -> a it's a -> a -> a
05:38:31 <Kaidelong> so the type system can use the second argument to resolve the first
05:38:51 <ThreeOfEight> Kaidelong: I don't really see what you mean
05:38:54 <wz1000> Kaidelong: Thats what I figured
05:39:06 <cluid> hi
05:39:50 <cluid> I'm stuck with gtk haskell, does anyone know how to make a window with fixed size? Without ", windowResizable := False" this code http://lpaste.net/115801 almost works, but when I add it the window ends up having 1x1 pixel size
05:40:02 <mauke> resultOf :: (a -> b) -> b; resultOf = undefined; ... x `asTypeOf` resultOf f
05:40:26 <Kaidelong> ThreeOfEight: things in the form of "f x y z = __expr__ where x :: IDon'tWantToGiveTheFullTypeOffBecauseItIsHugeButHaskellCan'tInferIt"
05:40:47 <ThreeOfEight> Is f a top level function?
05:41:00 <ThreeOfEight> because if it is, you /should/ give its type in a type annotation
05:41:06 <Kaidelong> in this case it would be because I can't be arsed to write out the full syntax of where it actually would be
05:41:23 <Kaidelong> (another where clause, on a value that will be used as a parameter for it)
05:41:29 <ThreeOfEight> and if it's not a top level function, why do you have to restrict its type at all?
05:41:54 <chrisdone> :t asAppliedTo
05:41:55 <lambdabot> (a -> b) -> a -> a -> b
05:43:03 <Kaidelong> In practice when I was working on my harmony search code, it mostly showed up when I had to deal with ST, which involves rank-2
05:43:36 <Xeironis> @src asAppliedTo
05:43:36 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
05:43:52 <Kaidelong> I don't have enough of an understanding as to why that should break things but in practice I had to "help" the type system when I was working with ST, a lot
05:45:05 <Kaidelong> (harmony search is a deeply imperative algorithm, but it's really good at what it does)
05:45:29 <Kaidelong> (so I was stuck in ST all the time)
05:45:44 <ClaudiusMaximus> cluid: http://hackage.haskell.org/package/gtk-0.13.1/docs/Graphics-UI-Gtk-Windows-Window.html#v:windowSetDefaultSize perhaps, or set the size of the canvas with http://hackage.haskell.org/package/gtk-0.13.1/docs/Graphics-UI-Gtk-Abstract-Widget.html#v:widgetSetSizeRequest
05:46:03 <cluid> ok thank you!
05:46:29 <Kaidelong> anyway I can't say why it forced me to do that because to be honest I don't know enough about how type systems work but that was the thing I remember where I had to do the most work to fight against Haskell's type system
05:47:09 <ThreeOfEight> ah, yes, in ST, that can happen
05:47:24 <ThreeOfEight> well, generally with higher-ranked types
05:48:00 <ThreeOfEight> Also, phantom types.
05:48:12 <Kaidelong> I actually wonder if I should have just done that project in C
05:48:14 <ThreeOfEight> Maybe this will get a bit nicer with partial type signatures
05:48:19 <Kaidelong> I had to write C anyway for the CUDA parts
05:49:05 <Kaidelong> and having to deal with Haskell, MPI, C, and CUDA all together involved a lot of duct tape
05:49:32 <Kaidelong> and the bulk of my work was with unboxed integer arrays
05:49:51 <Kaidelong> I think I actually lost a lot of producitivity trying to do it in Haskell
05:50:25 <chrisdone> i get the impression you're hinting that you weren't satisfied with your haskell experience
05:50:33 * chrisdone contacts head office at once
05:50:47 <Kaidelong> that was one project where I think Haskell might not have been the right tool for the job
05:51:02 <Kaidelong> that said, I didn't try just implementing it in straight up C, maybe if I took that route I'd just have run into other problems
05:51:25 <chrisdone> maybe you could implement it with unsafeCoerce everywhere
05:51:42 <Kaidelong> mmm, that's true, unsafeCoerce might have made my life easier, unsafePerformIO too
05:51:43 <chrisdone> and then when you decide you want type-safety, go through the process of removing them
05:52:02 <Kaidelong> a lot of my operations were things I knew were pure but required a ton of destructive updates for sharing through destruction
05:53:01 <Kaidelong> but then I'd have to implement freeze/thaw myself
05:53:06 <chrisdone> it's a bit harder to do the reverse direction from c (unsafe to safe)
05:53:09 <Kaidelong> so I'd rather just have used MVector
05:53:17 <cluid> I'm confused because I import Graphics.UI.Gtk.Abstract.Widget but I'm getting Not in scope: `widgetGetDrawWindow'
05:53:26 <ThreeOfEight> There is a saying: Haskell doesn't make easy things hard. Other languages pretend that hard things are easy.
05:53:26 <cluid> I see it defined here https://hackage.haskell.org/package/gtk-0.13.1/docs/Graphics-UI-Gtk-Abstract-Widget.html#v:widgetGetDrawWindow
05:53:38 <cluid> so why can I not use it?
05:54:02 <Kaidelong> Well the algorithm that I was working with genuinely didn't expose a very pure functional interface, it was in the spirit of things like neural networks
05:54:06 <cluid> oh it was removed in Gtk3, but i dont know what to use instead
05:54:34 <Kaidelong> (people have told me that implementing neural networks in Haskell is a pain, too)
05:55:07 <Kaidelong> I guess the whole idea of computational intelligence kind of goes against the Haskell spirit
05:55:07 <cluid> all the example code uses it, so im lost
05:55:08 <ThreeOfEight> Well I don't see the problem as long as you do it in ST
05:55:22 <Kaidelong> you don't care about things being *correct* or *reproducible* or even *explainable*
05:55:42 <Kaidelong> you care that you get your results *fast* and that they asymptotically converge on a correct solution in polynomial time
05:55:42 <chrisdone> i hope that's a mischaracterization of the field
05:56:02 <ThreeOfEight> People not caring about things being correct is a general problem
05:56:17 <ThreeOfEight> I once read this statement from a JavaScript programmer who said that performance is more important than correctness
05:56:28 <Kaidelong> chrisdone: for very difficult optimization problems you can get asymptotic improvements if you accept results that are correct within a threshold rather than correct
05:56:32 <ThreeOfEight> Which is funny, because JavaScript does neither very well.
05:56:45 <chrisdone> Kaidelong: presumably your threshold function has to be correct
05:57:04 <Kaidelong> there are some strong results from continuous analysis that they generally are
05:57:06 <ThreeOfEight> I also cringe whenever people do computations with floats
05:57:15 <Kaidelong> but I've forgotten the proofs
05:57:21 <cluid> I think I need to usedraw :: WidgetClass self => Signal self (Render ()) but I dont know how to use signals
05:57:28 <ThreeOfEight> especially when the problem that they solve is of discrete nature
05:57:56 <Kaidelong> computational analysis basically seems to be about finding continuous approximations to discrete problems that are too difficult for traditional AI approaches
05:58:08 <Kaidelong> computational intelligence*
05:58:45 <Kaidelong> harmony search is one of the heuristics from that field, since the focus is so much more on speed than on correctness there is a heavy focus on getting the operational aspects right
05:59:12 <Kaidelong> (basically because you have these strong properties that another iteration brings it closer to the correct result, you want to do as many iterations as you can, as fast and possible)
05:59:22 <Kaidelong> as fast as possible*
05:59:22 <ThreeOfEight> Well, at least you should have /definitive/ error bounds
05:59:30 <hamishmack> cluid: https://github.com/gtk2hs/gtk2hs/blob/master/gtk/demo/fastdraw/FastDraw.hs#L66
05:59:41 <ThreeOfEight> there's nothing wrong with approximation as long as you are aware of the approximate nature of your algorithm
05:59:47 <ThreeOfEight> and you know how much of an error you will have
05:59:53 <cluid> ah! thanks a lot
05:59:58 <Kaidelong> I wasn't the person who had to calculate them, so I don't remember what it was exactly, I just handled the implementation
05:59:59 <ThreeOfEight> even probabilistic algorithms are fine as long as you know the probability of a wrong answer
06:00:20 <Kaidelong> I do remember that asymptotically, a polynomial increase in running time reduced the error exponentially
06:00:29 <ThreeOfEight> but what I can't stand is people just not caring whether their code is correct
06:00:49 <ThreeOfEight> who don't do tests, or don't do good tests
06:00:54 <ThreeOfEight> who thinks it's fine if a few unit tests fail
06:00:56 <ThreeOfEight> *think
06:01:10 <ThreeOfEight> who compare floats and don't think about rounding errors etc.
06:01:14 <Kaidelong> well we were working with the biochemistry of retroviruses so presumably there was verification of the model in a lab
06:01:20 <ThreeOfEight> a lot of students do these things and don't seem to think it's problematic
06:01:48 <ThreeOfEight> But I come from formal verification, so I have very standards when it comes to program correctness.
06:01:49 <cluid> http://lpaste.net/115802 im getting some really confusing errors
06:01:53 <Kaidelong> my dad was a big java advocate and taught me when I was a teenager to be very particular about trying to catch subtle errors and handle all cases
06:01:56 <cluid> any idea what is wrong here?
06:02:09 <Kaidelong> I think this has harmed me a lot, because now I can't stand things like Python or Javascript
06:02:19 <Kaidelong> where making code that doesn't die when you cough on it is impossible
06:03:20 <cluid> haskel is really difficult :(
06:03:24 <ThreeOfEight> I wouldn't call that "harmed"
06:03:37 <Kaidelong> oh whoops I didn't realize this was #haskell
06:03:46 <benmachine> :P
06:04:04 <ThreeOfEight> cluid: this seems to be some package version conflict
06:04:12 <cluid> I see :S
06:04:27 <cluid> so it might not be my codes fault?
06:04:35 <benmachine> indeed it might not
06:04:37 <ThreeOfEight> I can't say anything apart from that, I have no idea how this can occur
06:04:41 <benmachine> looks like you have two versions of cairo installed at once
06:05:00 <benmachine> this is OK, sometimes, but you can't use them together, they act like separate packages
06:05:04 <Kaidelong> cluid: now might be a good time to learn about cabal sandboxes if you haven't already
06:05:10 <cluid> I want to use GTK and Cairo together
06:05:11 <benmachine> if you use cabal for dependency management this gets easier
06:05:38 <bitonic> is it possible to haddock a single file in a cabal project?
06:06:32 <Kaidelong> cluid: in your case you may not even need a sandbox, just using cabal will let you pick which version of the package you want and resolve the ambiguity
06:06:46 <Kaidelong> but lemme link you a blog post on cabal sandboxes anyway
06:07:08 <Kaidelong> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html <- this is what I used
06:07:14 <bitonic> or at least just compile a piece of haddock markup to html
06:07:35 <ThreeOfEight> Maybe a "ghc-pkg unregister cairo-0.13.0.1" would be advisable
06:07:52 <ThreeOfEight> But that might break some dependencies
06:07:59 <ThreeOfEight> A sandbox would probably be advisable
06:09:48 <Kaidelong> a good way to start may just be to make a directory, use "cabal sandbox init" and then "cabal init"
06:10:01 <Kaidelong> then open up the resulting *.cabal file and take a peek at what is in there
06:10:22 <Kaidelong> (that was how I taught myself anyway)
06:11:17 <Kaidelong> if you're used to project systems for things like Visual Studio, it's similar to that, although human readable rather than a messy bunch of XML
06:12:17 <cluid> I got it running with that, thank you!
06:12:48 <cluid> i have drawing code in a draw Signal but it is just a blank window.. still its something
06:16:55 <stephen_> If I have a function which takes as argument a type T, where T is constructed with two other types, A, and B, how can I access all three of T, A, and B from within the function?
06:18:50 <stephen_> So the definition for T would be something like > data T = A B
06:19:26 <benmachine> stephen_: are you sure that's right? in that definition, A is not a type
06:19:56 <benmachine> think about e.g. data Maybe a = Nothing | Just a, where Just and Nothing are not types
06:20:19 <cluid> data T = T A B
06:20:42 <cluid> if this, you could f t@(T a b) = ...
06:20:59 <Xeironis> But wouldn't A and B have to be lower case?
06:21:16 <dfeuer> Moaning all!
06:21:24 <Boreeas> For the function parameters (pattern match) yes, since you want them as variables
06:21:38 <dfeuer> Merry Haskellmas and a happy brothday.
06:21:41 <Boreeas> In the type def, no, since you are enumerating the types that T consists of
06:21:45 <Xeironis> Oh, yeah, nevermind
06:21:50 <stephen_> clucid: Ahh, that's what I was looking for, I just couldn't remember the syntax. Thanks!
06:25:02 <stephen_> Boreeas: So, to be clear, was my first statement incorrect in any way?
06:33:30 <Boreeas> Your first one being?
06:40:02 <stephen_> In referring to A and B as types in the statement > data T = A B. To my understanding, they are precisely and nothing other than the types of the aruments to the constructor, but others above disagreed
06:41:21 <geekosaur> stephen_: `data T = A B` declares a type T with a constructor A which takes a parameter of type B
06:41:21 <ChristianS> stephen_: data T = A B  is a syntax error
06:41:47 <ChristianS> (unless B is already declared)
06:42:15 <geekosaur> the type B must aready have been declared; the data constructor A has no relation to any *type* constructor A
06:42:51 <stephen_> ChristianS: Of course! They're placeholders :P
06:42:59 <geekosaur> no
06:46:20 <geekosaur> your understanding is incorrect. "data T = A B", B is a type; A is a data constructor and has no relationship to any existing type A. you create a value of the new type T using the data constructor A.
06:46:29 <Boreeas> stephen_: T = A B has exactly one parameter, an instance of B. The first word in a type def is always the constructor name
06:47:31 <Boreeas> You would create an instance of T like 'let x = A b'. What I suspect you want is "T = T A B" and "let x = T a b"
06:48:50 <stephen_> geekosaur, Boreeas: Right, thank you; I just looked over that section in Learn You a Haskell again, so it's all clear now.
06:51:23 * hackagebot Rasterific 0.4 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.4 (VincentBerthoux)
06:55:57 <stephen_> ChristianS: No worries there; I'd been assuming that both A and B were types which had already been declared; I was just missing another name for the constructor to go in front of A and B.
06:56:24 * hackagebot ghc-events-analyze 0.2.1 - Analyze and visualize event logs  http://hackage.haskell.org/package/ghc-events-analyze-0.2.1 (EdskoDeVries)
07:23:40 <mizu_no_oto> How do you do sections (i.e. mywebsite/#section1 and <section id="section1">) in Yesod?
07:29:31 <johnw> mizu_no_oto: there is also a #yesod, if that helps
07:55:10 <t4nk460> @pl map (\(m, v) -> liftM ((,) m) v)
07:55:10 <lambdabot> map (uncurry (fmap . (,)))
07:55:36 <t4nk460> @pl map (\(m, v) -> liftM (m, ) v)
07:55:36 <lambdabot> (line 1, column 25):
07:55:36 <lambdabot> unexpected ","
07:55:36 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
07:56:18 <wei2912> @pl map \ (m, v) -> liftM (m ,) v
07:56:18 <lambdabot> (line 1, column 5):
07:56:18 <lambdabot> unexpected '\\'
07:56:18 <lambdabot> expecting variable, "(", operator or end of input
07:56:29 <wei2912> @pl \ (m, v) -> liftM (m ,) v
07:56:29 <lambdabot> (line 1, column 22):
07:56:29 <lambdabot> unexpected ","
07:56:29 <lambdabot> expecting variable, "(", operator or ")"
07:56:35 <wei2912> :P
07:56:54 <t4nk460> Oh well. Not everything works.
07:57:13 <dreams> Do we have a function that checks if an expression is in normal form, or weak head normal form?
08:01:59 <Saizan> iswhnf x = x `seq` True
08:02:10 * Saizan not being helpful
08:03:36 <dreams> Or a function that returns the outermost part
08:04:01 <divyanshu>  data X = X { a = String , b = Int } then I can say X <$> (Just "hello") <*> ( Just 1) . How I can say X <$> { a = Just "hello", b = Just 1 } ?
08:04:29 <t4nk460> @pl \m v -> liftM ((,) m) v
08:04:30 <lambdabot> fmap . (,)
08:06:31 <HeladoDeBrownie> divyanshu, you can't put a Just "hello" into a field expecting a String. But it seems like what you want is to match on the X constructor, something like this: f (X a b) = ... -- and then you can use a :: String and b :: Int freely
08:06:52 <HeladoDeBrownie> divyanshu, "hello" :: String, Just "hello" :: Maybe String
08:07:19 <stephenmac7> Any chance RWH will ever get updated?
08:07:31 <divyanshu> Is there way to use applicative like syntax with providing name of field ?
08:07:47 <johnw> is anyone here familiar with pipes-text?  I'm trying to determine if any line in a file contains a string.  This fails: runEffect $ Text.readFile path ^. Text.lines >-> P.any ("> " `isPrefixOf`)
08:07:56 <johnw> I haven't yet understood the lensy way it does things...
08:08:45 <HeladoDeBrownie> divyanshu, well, another way you can retrieve those values from the structure is by using the functions that are created alongside the data type. If you have x :: X, then you also have a x :: String and b x :: Int
08:09:04 <Kaidelong> divyanshu: haskell's record syntax doesn't provide any way to do that directly, but you could use the monad syntax with very little overhead in this case
08:09:08 <HeladoDeBrownie> divyanshu, that does use the field names, but I'm not sure in the way you meant. I think what you're asking might not be possible
08:09:26 <Kaidelong> do {x <- Just "hello"; y <- Just 1; return (X x y)}
08:10:01 <Kaidelong> diyanshu: you may be able to do this uses the lenses from makeLenses, if you're using lens
08:11:00 <Kaidelong> however I think the simplest solution for your case is just to use the Monad syntax, unless you really really have to demand applicative instead. In that case the brain dead simple solution is this:
08:11:08 <divyanshu> Kaidelong: Thanks, I was looking for applicative way to do this without using lens. I will use lens then.
08:11:29 * hackagebot apiary-memcached 1.2.1 - memcached client for apiary web framework.  http://hackage.haskell.org/package/apiary-memcached-1.2.1 (HirotomoMoriwaki)
08:12:07 <Kaidelong> (\x y -> X { a = x, b = y }) <$> Just "foo" <*> Just 1
08:12:19 <Kaidelong> IE, just use a lambda expression to make it positional again
08:13:30 <HeladoDeBrownie> Ah, the question confused me, I thought this was about deconstructing an X
08:13:36 <HeladoDeBrownie> Well looks like you've got it
08:14:28 * HeladoDeBrownie should have asked for clarification on what the imaginary syntax was supposed to do
08:15:56 <stephenmac7> What does import Control.Monad.MonadST() mean?
08:16:09 <HeladoDeBrownie> stephenmac7, import just the instances from that module
08:16:18 <stephenmac7> Got it. Thanks
08:16:28 <HeladoDeBrownie> (Instances get imported whether you like it or not)
08:17:05 <stephenmac7> HeladoDeBrownie: Is it better to have a space before the parenthesis?
08:17:23 <HeladoDeBrownie> I think the popular style does that, yes
08:18:44 <stephenmac7> Thanks. Old haskell code: so many warnings
08:25:17 <stephenmac7> How would I go about creating instances of Applicative for types that are already instances of Monad
08:25:32 <pixelfog> Hi, I saw this sentence in Learn You a Haskell: " So if there's an Eq class constraint for a type variable in a function, it uses == or /= somewhere inside its definition." So I tried it here  http://lpaste.net/115811   and I saw that the point-free version doesn't have a class constraint. Can anyone explain why?
08:26:28 <ion> pixelfog: Try running :set -XNoMonomorphismRestriction in ghci first. Feel free to add that as a line to ~/.ghci, too.
08:27:11 <ion> The monomorphism restriction makes value definitions without a parameter on the left hand side of = and without a type signature monomorphic.
08:27:36 <stephenmac7> ion: Why isn't that default?
08:27:56 <ion> It is the default in ghci since 7.8.something, i think.
08:28:17 <stephenmac7> :t (== 5.0)
08:28:17 <lambdabot> (Fractional a, Eq a) => a -> Bool
08:28:40 <stephenmac7> Looks like it is
08:29:00 <pixelfog__> ion: Thanks! I think it might take me a while to understand what a monomorphism isAt least I have a name for the phenonenon.
08:29:26 <stephenmac7> What is the Alternative typeclass?
08:31:03 <ion> pixelfog: A polymorphic type has one or more free variables, potentially with class constraints (such as Eq a => a -> Bool). A monomorphic type is fully concrete (such as Double -> Bool).
08:31:06 <ion> Oh, he left.
08:31:34 <ThreeOfEight> what on earth
08:31:40 <pixelfog> ion: I'm here. (fighting with xchat)
08:32:12 <ThreeOfEight> do {h <- openFile "meta.csv" ReadMode; s <- hGetContents h; hClose h; print s}
08:32:16 <ThreeOfEight> returns ""
08:32:34 <ThreeOfEight> do {h <- openFile "meta.csv" ReadMode; s <- hGetContents h; print s; hClose h}
08:32:37 <ThreeOfEight> returns the actual file contents
08:32:41 <ReinH> stephenmac7: pure = return; <*> = ap
08:32:44 <ThreeOfEight> What is going on here?
08:32:46 <k00mi> ThreeOfEight: the joys of lazy IO
08:32:48 <ion> threeofeight: hGetContents is evil like that, yeah.
08:33:03 <ThreeOfEight> Okay, this is really, really bad.
08:33:08 <ReinH> (<*>) = ap, that is
08:33:11 <ThreeOfEight> how do I avoid this?
08:33:16 <johnw> use pipes
08:33:18 <Adeon> don't use hGetContents
08:33:23 <ThreeOfEight> ReinH: he said Alternative, not Applicative
08:33:26 <stephenmac7> :t ap
08:33:27 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:33:33 <stephenmac7> ThreeOfEight: I asked about both
08:33:45 <ThreeOfEight> oh
08:33:48 <ion> threeofeight: hGetContents returns an evil kind of string with side effects that will read the file incrementally upon evaluation (and close it in the end). In the first example, you’re closing the handle before evaluating the string.
08:33:50 <ThreeOfEight> never mind then, I do apologise
08:34:10 <stephenmac7> It's fine. The Alternative question came after.
08:34:29 <ReinH> Alternative is described in the Applicative haddocks
08:34:33 <ion> stephenmac7: A popular example of where Alternative is useful is parsers. (foo <|> bar) parses a foo and falls back to bar.
08:34:44 <stephenmac7> Sounds like mplus
08:34:57 <stephenmac7> MonadPlus
08:35:11 <ion> Yes, Alternative is like MonadPlus but with an Applicative constraint instead of Monad.
08:35:11 <stephenmac7> > Just 5 `mplus` Nothing
08:35:13 <lambdabot>  Just 5
08:35:23 <stephenmac7> > Nothing `mplus` Just 7
08:35:25 <lambdabot>  Just 7
08:35:35 <stephenmac7> Interesting.
08:35:38 <k00mi> ThreeOfEight: hGetContents closes the handle once it's done reading, so there is no need for you to do that
08:35:42 <ReinH> stephenmac7: yep, Alternative is to Applicative as MonadPlus is to Monad
08:35:45 <ThreeOfEight> k00mi: yes, I just read that
08:35:49 <ThreeOfEight> that solves my problem, I suppose
08:36:00 <stephenmac7> Are there any cases where an Applicative can't be a monad?
08:36:13 <sivteck> lots
08:36:20 <k00mi> ThreeOfEight: the proper solution is to use a streaming abstraction such as conduit or pipes instead of lazy IO
08:36:34 <ReinH> stephenmac7: e.g., a multidimensional array
08:36:43 <k00mi> they make it explicit when IO is performed
08:36:54 <ThreeOfEight> k00mi: this is for teaching; I'd rather not introduce too many additional concepts
08:37:06 <k00mi> ah
08:37:07 <ReinH> You can't write join because of the dimension mismatch.
08:37:16 <ion> ZipList on lists of unrestricted length is Applicative but not Monad.
08:37:18 <stephenmac7> Hm. Whoever wrote this code made a monad that wasn't even a functor
08:37:19 <Adeon> if you want simple then you can use readFile from Data.ByteString or readFile from Data.Text.IO, depending on what data you want
08:37:37 <stephenmac7> ReinH: That's interesting. I'll have to look into it more.
08:37:43 <ReinH> stephenmac7: that's not possible
08:37:51 <stephenmac7> One of these days, I'm going to have to read the typeclassopedia
08:38:16 <ReinH> If it isn't an instance of Functor, it can't be an instance of Monad
08:38:17 <stephenmac7> ReinH: It used to compile before I added the applicative declaration
08:38:22 <pixelfog> If anyone else is interested in the MonomorphismRestriction issue, this page has an explanation http://lambda.jstolarek.com/2012/05/towards-understanding-haskells-monomorphism-restriction/
08:39:31 <ReinH> Sorry, what I mean is: if it can't be made an instance of Functor, it can't be made an instance of Monad
08:39:38 <ReinH> @src liftM
08:39:38 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:39:53 <stephenmac7> https://github.com/shujinarazaki/funsat/blob/master/src/Funsat/Monad.hs#L64
08:40:17 <ReinH> because you can define fmap for any Monad (it's called liftM)
08:41:09 <stephenmac7> ReinH: That's nice. Now I don't have to think :)
08:41:18 <stephenmac7> fmap = liftM
08:41:27 <ReinH> :)
08:42:04 <stephenmac7> Last thing to do before all the errors are gone: make my monadplus an Alternative
08:42:27 <ReinH> empty = mzero; (<|>) = mplus
08:42:43 <stephenmac7> I should have guessed that
08:44:38 <stephenmac7> What does seqList :: forall t. [t] -> [t] mean?
08:45:08 <ReinH> @hoogle seqList
08:45:10 <lambdabot> Control.Parallel.Strategies seqList :: Strategy a -> Strategy [a]
08:45:10 <lambdabot> Control.Seq seqList :: Strategy a -> Strategy [a]
08:45:10 <lambdabot> Control.Seq seqListN :: Int -> Strategy a -> Strategy [a]
08:45:23 <ReinH> Unsure. Where do you see it?
08:45:55 <stephenmac7> It's the type GHC suggested for https://github.com/shujinarazaki/funsat/blob/master/Main.hs#L157
08:46:34 <ReinH> oh, you're asking about the forall
08:46:44 <ThreeOfEight> in that case, the forall shouldn't mean anything
08:47:20 <ReinH> That's an explicit universal quantifier.
08:47:34 <ReinH> It says that seqList has type [t] -> [t] for all types t
08:47:51 <ThreeOfEight> which is basically the same as seqList :: [t] -> [t]
08:47:54 <ReinH> All polymorphic types are implicitly universally quantified
08:48:19 <ReinH> So it's the same as [t] -> [t], yes
08:48:22 <ThreeOfEight> the only difference is that if ScopedTypeVariables are enabled, t can also be used in the function body
08:48:28 <ThreeOfEight> if you write forall t.
08:48:57 <ReinH> Well, existentials and rank n types also change the behavior of forall
08:51:08 <stephenmac7> What on earth is an existential type?
08:51:55 <ReinH> https://www.haskell.org/haskellwiki/Existential_type
08:52:21 <johnw> that wiki page is really unclear, imho
08:52:51 <johnw> http://stackoverflow.com/questions/292274/what-is-an-existential-type
08:54:34 <stephenmac7> I'll read it
08:56:02 <ReinH> johnw: yeah :/
08:56:38 <Kaidelong> I actually find the second answer clearer than the accepted one
08:59:25 <stephenmac7> So, I fixed a package and still don't know how to use it :(
08:59:48 <ion> This may or may not be helpful. If this is just confusing, just ignore it. I’ll introduce a pseudo syntax, a value of type “{a} -> ... a ...” takes a type as a parameter such that given “x :: {a} -> Foo -> a -> Bar”, “x Int :: Foo -> Int -> Bar”. “x :: forall a. a” is like “x :: {a} -> a” (but with {a} filled in implicitly), i.e. the caller of “x” will dictate the type “a”. “x
08:59:50 <ion> :: exists a. a” is like “x :: ({a}, a)”, i.e. the one who defines x will dictate the type “a”. A possible definition would be “x :: ({a}, a); x = (Int, 42)”.
09:00:42 <stephenmac7> ?
09:00:56 <stephenmac7> I lost you after the first part
09:01:02 <stephenmac7> *during
09:01:27 <ion> Alright, better just ignore what i said. :-)
09:01:36 <stephenmac7> Thanks anyway
09:11:24 <ROsborn> is there a way to annotate a type with it’s “unfixed” version? perhaps with a typeclass?
09:15:26 <ROsborn> I think I want to do something like this, but it doesn’t seem to work http://lpaste.net/1757828697190039552
09:15:41 <quxbam> i've written a little library to extend emacs with haskell, is anybody interested?
09:16:23 <johnw> is it written in C, to link into emacs itself?
09:16:45 <byorgey> ROsborn: 'Base' has to take the type f as a parameter
09:16:47 <quxbam> no, it's written in elisp and wraps haskell executables
09:16:55 <stephen_> quxbam: that sounds promising! Do you have a link to the source handy?
09:17:11 <quxbam> https://github.com/knupfer/haskell-emacs
09:17:26 <quxbam> it's very easy to do multicore array stuff with it
09:17:29 <byorgey> ROsborn: see https://hackage.haskell.org/package/recursion-schemes-4.1/docs/Data-Functor-Foldable.html
09:19:28 <ReinH> quxbam: what makes this haskell-specific?
09:20:09 <quxbam> actually nothing, perhaps the assumption that the executable is pure
09:20:26 <quxbam> that the output depends only on the input
09:21:05 <quxbam> and that it spits the haskell source in the documentation of the elisp function
09:21:26 <quxbam> stephen_: first impressions?
09:22:10 <ReinH> quxbam: Well, I'm just thinking that this more a general "pipe emacs to a process" tool, which actually makes it more useful
09:22:33 <ReinH> Although I would be surprised if something like that didn't already exist...
09:23:10 <quxbam> at least i'm not aware of a such convenient version which allows multi-core stuff
09:27:51 <stephen_> I need a matrix. linear algebra, and numerical methods (mainly integration and differentiation) library for a project, and hmatrix seems to be well regarded, but cabal is complaining that it's unsafe (Maybe because it uses the GNU Scientific Library?). Is this a big deal? I could just disable checking the safety of packages, but that seems like a good thing to have. Is there any way to disable safety checking for the hmatrix package
09:27:51 <stephen_> alone? Perhaps the solution is to use another library. Any suggestions?
09:32:49 <ReinH> stephen_: I wouldn't worry about safety too much
09:35:39 <athan> has numerical-haskell made much progress yet? (ping carter?)
09:35:44 <carter> athan: yes
09:35:55 <carter> athan: i've accepted a pretty sweet gig that should support the work
09:36:04 <carter> while keeping numerical independent
09:36:14 <athan> carter: !!! Congrats! I'll have to lurk for a bit to catch up :)
09:36:24 <carter> athan: not much has happened in the past month
09:36:55 <carter> stephen_: my shit is awsome, but not quite ready for general consumption, but maybe theres going to be an alpha in time for the dr who xmas special
09:36:56 <athan> carter: I'm a noob at math, but I want to learn. Hopefully I can make myself useful :)
09:37:02 <carter> newbs are great!
09:37:05 <carter> they work hard and like laerning
09:37:11 <carter> and spelling
09:37:14 <athan> :P
09:37:40 <carter> stephen_: whats your problem domain
09:37:57 <carter> athan: you should lurk on #numerical-haskell
09:38:20 <athan> will do :)
09:41:32 <ReinH> carter: oh awesome! :D
09:56:23 <Jello_Raptor> which is the more canonical style in a do block
09:56:34 <Jello_Raptor> "let x = foo"
09:56:44 <Jello_Raptor> or "x <- return $ foo"
09:57:02 <exio4> let x = foo
09:57:21 <Jello_Raptor> exio4: thank you
09:57:42 <exio4> it is more concise and does less things than x ← return
09:58:02 <ROsborn> byorgey, thank you for that link. I’m trying to wrap my brain around the type acrobatics
09:58:08 <Jello_Raptor> it just feels a bit weird to have a 'let' in the do block. so I wasn't sure
10:13:23 <Black-Heaven> Hi, is there a difference between coproduct and sum type ? Thanks.
10:14:03 <monochrom> no, not to me
10:14:50 <monochrom> Cocartes says: coproduct ergo sum.
10:15:28 <recursion-ninja> monochrom: ha
10:21:01 <Kaidelong> is there any distinction with regards to whether min |x| |y| >= |x + y| <= |x| + |y| or if |x + y| == |x| + |y|?
10:22:37 <Kaidelong> it would strike me as silly if there is, but if you think of types as sets then the disjunction of () and () is (), which is not Either () ()
10:23:50 <Black-Heaven> monochrom: ok, that's what I have felt
10:25:54 <Kaidelong> okay the definition says that it's a disjoint union, so that would be a tagged union
10:26:11 <Kaidelong> so then a coproduct shouldn't be any different from a sum type
10:27:00 <ROsborn> Are there examples of types that are Foldable but not Unfoldable?
10:34:19 <mmachenry> I'm writing a TCP server using Conduit.Network and Aeson. Aeson.json creates a Parser which is great but the only encoder for that Parser is to Lazy.ByteString not a strict one. Conduit needs a strict ByteString. Should I write a lazy to strict bytestring encoder or is there a better way?
10:35:28 <simpson> mmachenry: The functions already exist in BS/LBS, called fromChunks and toChunks.
10:36:40 <mmachenry> simpson: Thank you. I wouldn't have known to search for the work chunks. I'll go check that out.
10:43:47 <benzrf> Kaidelong: /disjoint/ union
10:43:49 <Feuerbach> mmachenry: there are fromStrict/toStrict functions in D.B.Lazy
10:43:52 <benzrf> Kaidelong: not regular union
10:44:03 <benzrf> Kaidelong: oh soz
10:44:15 <nuttycom> Hey, all, I've been hoogling with no luck. Is there a simple way to do Rational -> Integer with half-even rounding?
10:44:32 <Feuerbach> long time ago they didn't exist and one had to use fromChunks/toChunks; but it's all over now
10:45:21 <sinelaw> Does Haskell have polymorphic recursion?
10:45:25 <Groutcho> I'm a bit lost here, I have the following line : f (f (f start 1) 2) 3, and I would like to generalize it to n like f (f (f start 1) 2) n), is fold the right tool for that ?
10:45:26 <sinelaw> "have"
10:45:52 <Feuerbach> sinelaw: yes, with typeclasses
10:45:58 <mauke> sinelaw: yes
10:46:01 <sinelaw> Feuerbach, and without?
10:46:18 <sinelaw> I just can't think off the top of my head of any simple example to test it
10:46:23 <mauke> > foldl f z [1 .. 3] :: Expr
10:46:25 <lambdabot>  f (f (f z 1) 2) 3
10:46:33 <nuttycom> Oh, never mind. round is half-even by default. :P
10:47:05 <Groutcho> @mauke : oh neat !
10:47:05 <lambdabot> Unknown command, try @list
10:47:17 <Groutcho> @mauke thank you, I'm going to test that
10:47:17 <lambdabot> Unknown command, try @list
10:47:25 <mauke> > let foo :: (Show a) => n -> a -> String; foo 0 x = show x; foo n x = foo (n - 1) (n, x) in foo 2 'a'
10:47:27 <lambdabot>  Could not deduce (GHC.Num.Num n) arising from the literal ‘0’
10:47:27 <sinelaw> Groutcho, don't use @
10:47:27 <lambdabot>  from the context (GHC.Show.Show a)
10:47:27 <lambdabot>    bound by the type signature for
10:47:27 <lambdabot>               foo :: GHC.Show.Show a => n -> a -> GHC.Base.String
10:47:27 <lambdabot>    at <interactive>:1:12-39
10:47:36 <mauke> > let foo :: (Show a) => Int -> a -> String; foo 0 x = show x; foo n x = foo (n - 1) (n, x) in foo 2 'a'
10:47:37 <lambdabot>  "(1,(2,'a'))"
10:47:42 <mauke> sinelaw: ^ ?
10:48:05 <sinelaw> cool
10:48:56 <Groutcho> mauke, ah ok
10:54:05 <sinelaw> mauke,
10:54:06 <sinelaw> > let foo :: Int -> a -> (); foo 0 x = (); foo n x = foo (n - 1) (n, x) in foo 2 'a'
10:54:08 <lambdabot>  ()
10:54:21 <sinelaw> without typeclasses too
10:54:27 <sinelaw> (useless program, but typechecks)
10:54:56 <sinelaw> mauke, but type inference doesn't work:
10:54:56 <sinelaw> > let foo 0 x = (); foo n x = foo (n - 1) (n, x) in foo 2 'a'
10:54:58 <lambdabot>  Couldn't match expected type ‘(t0, t1)’
10:54:58 <lambdabot>              with actual type ‘GHC.Types.Char’Occurs check: cannot construct ...
10:54:58 <lambdabot>  Relevant bindings include
10:54:58 <lambdabot>    x :: (t, t2) (bound at <interactive>:1:25)
10:54:58 <lambdabot>    n :: t (bound at <interactive>:1:23)
10:55:00 <shachaf> Polymorphic recursion is certainly useful without type classes.
10:55:10 <shachaf> And it's not inferrable.
10:55:27 <shachaf> You could learn this by reading the Haskell Report.
10:56:18 <sinelaw> shachaf, thanks. I think I did one day long ago. Should do it again.
10:56:42 <shachaf> Proposal: lambdabot outputs at most one line of text per command in the channel
10:59:37 <monochrom> I would weaken it to 3.
11:00:00 <ChristianS> 3 sounds good
11:02:06 <sinelaw> I found this in lambdabot-core:     where maxLines = 5 -- arbitrary, really
11:05:34 <ifesdjeen> hi everyone
11:06:00 <ifesdjeen> is it somehow possible to combine two services running in parallel to share on StateT ?
11:06:14 <shachaf> What is a service?
11:06:20 <johnw> ifesdjeen:  can you explain what you mean a little more?
11:06:23 <ifesdjeen> sure
11:06:56 <ifesdjeen> i have some common state in the application (database app), and I have 2 services: Http Acceptor that serves HTTP requests and a binary protocol that serves binary requests
11:08:18 <johnw> probably the easiest way to have to two views onto an aggregate state would be to use MonadState,  but I'm not sure if the libraries that you're using have that functionality
11:08:28 <ifesdjeen> now, both of them are reading in modifying state (e.g. created databases and other state)
11:08:28 <ifesdjeen> problem is, they're running in parallel, and if I use StateT DbContext IO (), I'm not 100% sure how to make the state available to both
11:08:32 <ifesdjeen> hm
11:09:16 <johnw>  for example, if you have StateT (a, b) IO (),  then this could satisfy both MonadState a IO and MonadState b IO
11:09:39 <ifesdjeen> ah, the both services are technically using StateT a IO ()
11:09:48 <ifesdjeen> the problem is visibility
11:09:57 <ifesdjeen> whether one will see the things modified by the other
11:10:16 <ifesdjeen> actually, I think I should just try ...
11:10:53 <johnw>  this may not be the right solution at all, but you also always have the option of storing an IORef or an MVar in the StateT
11:10:58 <stephen_> carter: It's a real-time embedded control system, built on top of Copilot, an embedded DSL which was contracted by NASA a while ago: https://hackage.haskell.org/package/copilot http://leepike.wordpress.com/2010/09/25/copilot-a-dsl-for-monitoring-embedded-systems/ . Copilot compiles to embedded C, so the core concept  is that Haskell makes the controls abstractions really simple, then Copilot turns it into a nice constant memory,
11:10:58 <stephen_> constant time binary. Actually, I hadn't thought of this before, but GSL - and by extenstion, hmatrix - will use dynamic allocation, so it shouldn't even be a candidate for us. (malloc has no time guarantees, so our system could hang at the worst time) Can anyone suggest other, pure haskell packages for lin alg and numerical methods?
11:11:23 <ifesdjeen> johnw: yup, i've prototyped with TVars tbh
11:11:27 <carter> stephen_: use a realtime malloc?
11:11:27 <johnw> but that's a little bit weird, since it's embedding state in state.  If you did need to go that route – and I'm not saying that you do – then you would put the variables in a ReaderT
11:11:32 <ifesdjeen> i just thought there may be a better solution
11:11:55 <carter> stephen_: i dont (yet) have numerical computing tools that i'd feel are fit for hard real time streaming uses, but i'm happy to discuss it
11:12:03 <Groutcho> I have a list range in the form [1..n] with n being of Integral typeclass (function sig : Integral a => a -> [a]. And the compiler throws an error that it can't deduce Int from Integral... Isn't it possible to have a list range generated from an Integral bound ?
11:12:11 <ifesdjeen> johnw: thanks!
11:12:34 <shachaf> Groutcho: No.
11:12:48 <shachaf> Groutcho: To find out what type is needed, take off the signature and let ghc infer it.
11:12:51 <shachaf> Or do it yourself:
11:12:52 <benzrf> Groutcho: is enum a superclass of integral
11:13:02 <shachaf> :t \n -> [1..n]
11:13:03 <lambdabot> (Num t, Enum t) => t -> [t]
11:13:32 <shachaf> Apparently you need Num and Enum. Integral doesn't give you Enum (you can find out by typing :i Integral in ghci).
11:13:35 <Groutcho> oh it's enum, it's not Int...
11:13:46 <Groutcho> shachaf, thank you, I never thought about hat
11:15:05 <Groutcho> So... What would be the best solution here ? Convert the input integral to an int ?
11:15:39 <shachaf> No, just give your function the type that GHC infers for it.
11:15:44 <shachaf> That's the best type.
11:18:07 <Groutcho> shachaf thanks, it works when I completely remove the type signature
11:18:21 <shachaf> Now add it back with the correct type.
11:18:38 <Groutcho> it stays : primes :: Integral t => Int -> [t]
11:19:35 <Groutcho> shachaf, thanks for the help :), very useful
11:20:33 <sinelaw> Groutcho, GHC can infer the most general (prinicpal) type , unless where you're using some "advanced" features/extensions
11:21:13 <Groutcho> sinelaw, indeed, I wasn't aware of this method of removing type signature and ask GHC what it infers, then putting this signature
11:22:05 <sinelaw> Groutcho, I wish there was a faster way though. Some IDEs configured correctly can do this. I haven't been able to get it to work properly in emacs
11:23:10 <Groutcho> sinelaw, it's a bit of a hack to go from the editor, to GHCi, then back in the editor... but well, it works
11:23:27 <Groutcho> sinelaw, I use Sublime Text
11:27:10 <stephen_> carter: I know, for example, the MISRA C and JPL Coding standards (http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf) both disallow heap allocation, except during initialization, so I'd rather avoid even a real-time malloc for our ongoing controls calculations, if possible. Here's a relevant article. http://mil-embedded.com/articles/justifiably-apis-militaryaerospace-embedded-code/
11:27:10 <stephen_> Even if your stuff isn't available now, What kind of schedule are you thinking of for the project? I could conceivably implement my stuff for now using hmatrix, then drop in your stuff when it's further along.
11:27:27 <carter> stephen_: ok
11:27:28 <carter> sooo
11:27:42 <carter> stephen_: what you'e wanting is the ability to guarantee that theres no dynamic memory allocation?
11:27:44 <carter> or very little?
11:28:23 <carter> stephen_: my apis are setup for actually making it clear when any memory allocation is happening
11:28:24 <stephen_> None is what we're really going for.
11:28:29 <carter> ok
11:28:42 <carter> well, if its in haskell, theres still some pointer bumping on the heap
11:28:49 <carter> plus the MMAP for the heap blocks
11:30:02 <stephen_> Fair enough. I was thinking more that Copilot would take care of the safety of anything written in haskell.
11:30:20 <benzrf> is the copilot the pilot on the return trip
11:30:44 <stephen_> That's awesome that your api's are so nice
11:31:10 <carter> stephen_: did you see my ICFP talk?
11:31:15 <carter> @google carter icfp hope locality array
11:31:16 <lambdabot> https://www.mpi-sws.org/~neelk/hope2014/
11:31:21 <carter> @google carter icfp hope locality array youtube
11:31:22 <lambdabot> http://www.youtube.com/watch?v=BntNBjDFfMs
11:31:32 <stephen_> benzrf: http://www.cs.indiana.edu/~lepike/pubs/copilot-cr.pdf
11:31:45 <carter> http://youtu.be/BntNBjDFfMs
11:31:55 <carter> stephen_: i do eve better than that
11:32:04 <stephen_> carter: no, I'll check them out now; thanks!
11:32:06 <carter> i have an WIP api that allows you to reason about memory locality
11:32:38 <carter> stephen_: what latency regime are you working on?
11:32:41 <carter> funsies or for work?
11:34:05 <stephen_> It's for a team with my University, so funsies, but with a deadline for everything done middle of this spring.
11:34:56 <carter> cool
11:35:02 <carter> i'm hoping ot have an alpha for xmasish
11:35:10 <carter> i finally have work stuff sorted out
11:37:41 <stephen_> carter: Solid, I'll probably be able to have an alpha with the rest of it using hmatrix by then, at which point I'll drop yours in and rework stuff a little
11:38:47 <carter> cool
11:38:51 <carter> thats what a few projects are doing
11:38:56 <carter> do you care about sparse matrices
11:38:57 <carter> or just desnse?
11:39:00 <sinelaw> shachaf, is inference of polymorphic recursion a generally undecidable problem?
11:40:17 <shachaf> @google polymorphic recursion inference decidable
11:40:17 <lambdabot> http://en.wikipedia.org/wiki/Polymorphic_recursion
11:40:17 <lambdabot> Title: Polymorphic recursion - Wikipedia, the free encyclopedia
11:41:11 <sinelaw> ok. "no" then
11:41:19 <sinelaw> I mean "yes". double negatives are confusing.
11:41:43 <stephen_> It's just pretty small, dense matrices for now
11:50:28 <Darwin226> Does anyone know any up to date OpenGL tutorial for Haskell?
11:50:57 <sinelaw> Darwin226, I highly recommend going the graphics-combinators way
11:51:07 <sinelaw> which is to say: abstract away the GL stuff
11:51:25 <sinelaw> graphics-drawingcombinators that is
11:51:36 <sinelaw> Darwin226, http://hackage.haskell.org/package/graphics-drawingcombinators-1.5/docs/Graphics-DrawingCombinators.html
11:52:00 <Darwin226> sinelaw: I've worked with OpenGL before so I don't mind, though I don't mind not having to bother either :D
11:52:13 <gunnarsson> Darwin226: this would be outdated? https://www.haskell.org/haskellwiki/OpenGLTutorial1
11:52:39 <sinelaw> Darwin226, the library I linked to makes life so much nicer and functional
11:52:44 <Darwin226> gunnarsson: I don't know what the state of opengl programming in haskell is, but all that is immediate mode opengl
11:52:59 <Darwin226> gunnarsson: Deprecated stuff.
11:53:06 <sinelaw> Darwin226, but doesn't support arbitrary opengl stuff, only whatever it supports
11:53:39 <gunnarsson> Darwin226: just thought it might be relevant
11:54:53 <Darwin226> sinelaw: I'll try it out. One more thing. How supported is it? I've had a ton of stuff not work on windows which is one of the reasons I was going with raw ogl
11:55:55 <sinelaw> Darwin226, I know one person who uses it (Peaker)
11:56:10 <sinelaw> Darwin226, but he doesn't do it on windows. I used it on windows but that was many versions ago
11:56:34 <ifesdjee_> is it possible, if I have an action (StateT a IO ()), and doing forkIO, to still be able to call `get` from the `StateMonad` ?...
11:57:08 <ifesdjee_> s/doing forkIO/doing forkIO inside of that action/g
11:57:49 <geekosaur> only if you rewrap it in the MonadState; note that that will then be a separate instance
11:58:44 <geekosaur> (that is, extract the state and then use runStateT inside the forkIO to re-apply it)
11:59:08 <joe9> need some help with using the correct data structure: http://codepad.org/lVFC3Xzk is my curreent source. Is there any other smarter data structure that I can use instead of all those ids?
11:59:29 <ifesdjee_> geekosaur: and separate instance would mean that I wouldn't have state shared, right?
11:59:37 <ifesdjee_> geekosaur: is there any alternative to that?
11:59:39 <ifesdjee_> geekosaur: I was wondering if creating a function in `let` statement which would run the action, and re-apply the result, maybe
11:59:39 <joe9> It is a pita to keep track of all those id's when deleting them, etc.
11:59:44 <geekosaur> correct. you cannot share state across threads that way
11:59:53 <ifesdjee_> ok
11:59:59 <geekosaur> unless you stow it in an IORef and instead of MonadState, use MonadReader to ship the IORef
12:00:00 <Zekka> I think you can use iorefs
12:00:07 <Zekka> oh, geeoksaur took the words out of my mouth
12:00:18 <ifesdjee_> thanks Zekka geekosaur
12:00:23 <ifesdjee_> very helpful :)
12:00:23 <geekosaur> note that updates can be indeterminate in that case; nothing prevents another thread from modifying the "state" out from under you
12:00:39 <Zekka> It's not necessarily a good idea because of the thing geekosaur just said before I could have
12:00:43 <geekosaur> (that being a good part of the reason why you can't do it more easily...)
12:00:51 <Zekka> but it probably does what you want if that's what you want
12:00:56 <ifesdjee_> so I guess my initial implementation with TRef was rather right
12:01:42 * hackagebot sws 0.2.0.0 - A simple web server for serving directories, similar to weborf.  http://hackage.haskell.org/package/sws-0.2.0.0 (DerekElkins)
12:01:47 <ifesdjee_> shoo, that's pretty sad :( probably I have to re-structure everything again
12:01:49 <ifesdjee_> thanks everyone!
12:02:06 <Zekka> ifesdjee_: Do you necessarily have to use multiple threads?
12:02:37 * geekosaur wonders if STM is helpful here...
12:02:49 <ifesdjee_> Zekka: yeah, I'm running a web server serving requests and another one running binary data, so unfortunately yes :(
12:03:01 <ifesdjee_> Zekka: they're basically interfacing same state
12:03:12 <ifesdjee_> trying to jam them into one loop would be almost impossible
12:03:28 <ifesdjee_> although i'll probably just wrap `get` and `modify` in closure, probably as atomic as it gets
12:03:53 <ifesdjee_> or will switch back to TVars
12:04:01 <ifesdjee_> which would probably be the best idea
12:04:02 <Jello_Raptor> I've got to be doing something really stupid :/
12:04:11 <ifesdjee_> but less atomic, I guess
12:04:11 <ifesdjee_> or no
12:04:42 <Jello_Raptor> I'm having that issue again where makeLenses both doesn't work and seems to delete any code inserted after that call.
12:05:39 <lericson> > Just 2
12:05:40 <lambdabot>  Just 2
12:05:45 <lericson> > Just 2 >> Nothing >> Just 3
12:05:47 <lambdabot>  Nothing
12:05:57 <lericson> kind of like that Jello_Raptor?
12:06:11 <lericson> also disregard me, i don't know enough about lenses to give you any sort of useful response
12:06:13 <trap_exit>  /join #fitness
12:06:20 <Jello_Raptor> lericson: no <_<
12:06:20 <geekosaur> makeLenses is top level Template Haskell evil
12:06:41 <Zekka> I'm pretty sure it makes definition order matter when ordinarily it wouldn't
12:06:44 <geekosaur> I am imagining it somehow becoming confused enough to hose the AST
12:06:49 <Jello_Raptor> geekosaur: why? also it's really convenient.
12:07:01 <geekosaur> or, the "delete the code" might just be stuff in the wrong order, yeh
12:07:12 <geekosaur> it's convenient, yes. it's also more than a bit arcane
12:07:19 <Zekka> Have you tried making your lenses at the end of the file?
12:07:52 <Jello_Raptor> Zekka: yes, then the lenses fail to get made, but everything else works
12:08:19 <Jello_Raptor> I had another file with the same problem (a happy parser) and had to fix it there by manually making the lenses
12:08:21 <Zekka> What does makeLenses do instead of working?
12:09:18 <Jello_Raptor> Zekka: nothing. There just aren't any definitions for the expected lenses. If there's any code that is after the "makeLenses" call, it seems to go missing.
12:09:41 <Zekka> That sounds like a bug! Although I've never personally experienced anything along those lines
12:10:07 <Jello_Raptor> Zekka: issue is it breaks on a few files in this project, and works fine in others
12:11:21 <Jello_Raptor> hmm, the only module other than control.lens both broken files share is Data.Time :/
12:11:47 <Jello_Raptor> so it's not likely something straightforward like some other module conflicting
12:12:23 <Jello_Raptor> ... I have no idea how to reduce this to a minimal example, so that I can file a bug report
12:18:46 <nkar> edwardk: could you show me how to parse recursive comments with trifecta?  for instance, /* foo /* bar */ */
12:19:42 <mauke> argh :-(
12:27:48 <atomx> if I have <<<data Term = Con Int | Div Term Term>>>, how can I define a show(Term) ? such that Show (Con 10) to print "Int = 10" ?
12:28:26 <atomx> ... and Show (Div (Con 10) (Con 10)) to print "10/10" ?
12:28:32 <simpson> atomx: It sounds like you want pretty-printing, which Show is not really meant for. Why not define a custom print method?
12:28:51 <atomx> I am _very_ new to haskell
12:29:02 <atomx> the compiler recommends as I said
12:29:05 <geekosaur> atomx, in general Show should produce something that is acceptable to Read, not something "pretty"
12:29:35 <geekosaur> if you insist, you can manually specify a Show instance instead of deriving it
12:29:55 <atomx> How to define it concretely ?
12:30:11 <atomx> No, sorry
12:30:29 <atomx> What is the syntax to define it ?
12:31:00 <mauke> what do you mean, the compiler recommends?
12:31:02 <Bor0> something like: instance Show Term where show Con x = "Int = " ++ show x
12:31:10 <mauke> the compiler knows nothing about pretty printing
12:31:34 <atomx> Bor0: thanks
12:33:23 <Jello_Raptor> is there a " read . show = id " law?
12:33:51 <leighman> hi, what should I use if I want a process that runs forever and checks an api every minute?
12:33:58 <leighman> is there some timer?
12:34:11 <atomx> got it.
12:34:19 <atomx> Bor0: show (Con x) = "Int = " ++ show x
12:34:26 <atomx> with parenthesis !
12:34:36 <atomx> without parenthesis it does not work
12:35:00 <geekosaur> Jello_Raptor, it's not a hard law, just strongly recommended + deriving Show instances automatically obeys it
12:35:23 <geekosaur> there's really at least three varieties of value printing: serialization (current Show), debugging, pretty printing
12:36:11 <k00mi> leighman: forever $ do stuff; threadDelay (60 * 10^6) -- microseconds
12:36:30 <geekosaur> Show tends to be used for the first two, and pretty printing libraries for the latter --- although newcomers often think they should be able to use Show that way, and then become confused when (a) they can't alter builtin types to match their idea of pretty printing (most commonly String), or (b) they later need to use Read on their types
12:37:14 <geekosaur> (or they want to use something else that uses Read and Show for serialization)
12:37:24 <leighman> k00mi: threadDelay, thanks
12:37:29 <atomx> Bor0: perfect, I finished. thanks again
12:37:39 <k00mi> leighman: it's in Control.Concurrent
12:37:45 <Bor0> atomx, no problem :)
12:37:54 <geekosaur> (and I m also ignoring things like that Show and Read, for all that they default to a serialization form, are lousy for serialization >.> )
12:38:41 <geekosaur> oh, he other not-a-rule-but-recommended-and-obeyed-by-deriving: they're valid Haskell code
12:39:18 <geekosaur> so assuming you have the appropriate types in scope, you could copy and paste the thing generated by `show` into ghci and get the original value back
12:39:32 <geekosaur> which makes it nice for debugging, as I previously mentioned
12:40:16 <monochrom> and serialization
12:41:25 <monochrom> "hello\n\tworld" is a pretty machine-friendly, robust way to transmit a string
12:42:14 <monochrom> the "robust" part means it also fits well in contexts such as "a tuple of a string and a boolean"
12:42:48 <monochrom> the human-friendly alternative is not robust.
12:43:04 <StoneCypher> robust except in damage resistance as a string literal
12:43:20 <StoneCypher> lose one backslash around a quote mark and potentially terrible things can happen
12:43:34 <monochrom> well yeah sure I should s/robust/compositional/
12:43:37 <geekosaur> well, yes, but something liek that is true of any serialization format
12:43:44 <StoneCypher> wooooo i was right in #haskell once
12:43:48 <geekosaur> mangle it and you can't generally recover
12:43:55 * StoneCypher hooks up thermoelectrics and makes electricity from hell freezing over
12:44:15 <geekosaur> I mean, drop that backslash in JSON sometime and see how it handles it
12:44:24 <StoneCypher> geekosaur: ya, it's a problem with most encodings
12:44:43 <StoneCypher> unicode is an exception; it's quite robust to byte loss
12:44:45 <k00mi> you really want length-prefixed strings in a serialization format
12:44:54 <StoneCypher> k00mi: wooo pascal strings
12:45:10 <geekosaur> (ASN.1 >.> )
12:45:58 <monochrom> error-correcting code such as used in space communication and once upon a time in every PC's RAM is an interesting subject
12:46:44 * hackagebot io-streams 1.2.1.1 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.2.1.1 (GregoryCollins)
12:52:47 <sinelaw> Darwin226, but he doesn't do it on windows. I used it on windows but that was many versions ago
12:52:51 <sinelaw> oops. wrong buffer.
13:00:46 <nkar> so, does anyone know how to tell trifecta to match until the last */ is found?  (string "/*" *> manyTill anyChar (string "*/")) returns /* for /*/**/*/ and (string "/*" *> many anyChar <* string "*/") goes until eof is reached (due to anyChar).
13:03:10 <Cale> nkar: For instance /**/*/ should match?
13:05:02 <nkar> Cale: yes, it's scala
13:05:04 <nomeata> Is there a tool that automatically recompiles my diagrams-based program and displays the result?
13:05:21 <nkar> Cale: I'm basically trying to extend puffnfresh's language-scala
13:05:33 <nkar> which doesn't parse comments at the moment
13:06:00 <ThreeOfEight> What on earth is this linker error
13:06:00 <ThreeOfEight> /tmp/tmp.wf3VTzmr56/Network.o: In function `sVv_info':
13:06:02 <ThreeOfEight> (.text+0x2e): undefined reference to `reflectionzm1zi5zi1_DataziReflection_given_info'
13:06:07 <ThreeOfEight> (I use Data.Reflection)
13:06:45 * hackagebot opn 0.1.2 - Open files or URLs using associated programs.  http://hackage.haskell.org/package/opn-0.1.2 (AndersClaesson)
13:07:38 <nkar> ThreeOfEight: stale files maybe?
13:08:38 <ThreeOfEight> Good suggestion. I'll rebuild everything.
13:09:45 <Cale> nkar: So I think you actually want to look for the first */ after the /* ? Isn't that how C-style comments work, or does Scala have nested comments?
13:09:58 <nkar> it allows nested comments
13:10:11 <oliffia> is haskell typechecking done in one pass in ghc?
13:11:21 <nkar> ThreeOfEight: sometimes I also get linking errors when I forget to expose modules in the cabal file.  but it's probably not relevant here
13:12:08 <nkar> Cale: scala-lang.org/files/archive/spec/2.11/13-syntax-summary.html
13:12:39 <heatsink> oliffia: Probably yes, depending on exactly what you mean.
13:12:50 <Cale> Right, so you'd want something along the lines of  comment = do try (string "/*"); many (comment <|> anyChar); string "*/"
13:13:21 <oliffia> heatsink: id say multiple passes would be that the (annotated) AST is processed more than once until no more type holes exist or no changes occur
13:13:27 <nkar> Cale: yeah, I've been thinking of recursion obviously, just haven't found a way to express it
13:13:40 <nkar> Cale: let me try your suggestion...
13:13:45 <heatsink> It's a single pass.
13:13:53 <oliffia> alright, thanks!
13:14:16 <heatsink> Type inference translates into a constraint solving problem, and a single pass is needed to extract the constraints from the program.
13:14:27 <heatsink> Constraints are solved on the fly at let/letrec points
13:15:07 <heatsink> There are some extensions, like Template Haskell, that require multiple passes.
13:19:20 <nkar> Cale: doesn't typecheck because comment is m String while anyChar is m Char
13:19:46 <Cale> oh, yeah, just discard the results
13:19:57 <Cale> Well, or capture them somehow
13:20:05 <atomx> what is the syntax of a lambda function with 0 parameters ?
13:20:20 <Cale> atomx: It's:
13:20:37 <Cale> atomx: There's no such thing as a function with 0 parameters
13:20:38 <nkar> Cale: so, do I need to add many to anyChar and bind the result of comment?
13:20:55 <Cale> nkar: fmap (:[]) anyChar  might do
13:20:55 <Bor0> > let f = 3 in f
13:20:56 <lambdabot>  3
13:20:58 <atomx> I need so "\ -> x+1", where x is free.
13:21:06 <Cale> atomx: use: x + 1
13:21:11 <atomx> ok
13:21:14 <atomx> great.
13:21:16 <atomx> thanks
13:21:31 <nkar> Cale: nope, it matches until eof
13:21:49 <Cale> nkar: hm
13:22:03 <Cale> nkar: Oh of course
13:22:24 <dreams> Cale: cafs are, no?
13:22:46 <Cale> nkar: anyChar will match the * in a */
13:23:01 <nkar> yes, I understand
13:23:31 <nkar> but if I forbid */ with 'notChar', it will fail earlier
13:23:32 <Cale> nkar: So you might want to use notFollowedBy (string "*/")
13:24:12 <Cale> If you want I'll install trifecta and mess with it a bit
13:25:01 <nkar> Cale: that'd be great.  I've spent quite a while playing around with it myself.  otherwise, I wouldn't ask here.
13:25:19 <Cale> nkar: With the string "*/" on the end though, it shouldn't just match all the way to eof
13:25:28 <Cale> It might fail
13:25:47 <Cale> But it shouldn't succeed in matching the whole thing
13:25:56 <Cale> unless there happens to be a */ at the end of file
13:25:56 <nkar> Cale: I was sloopy.  yes, it fails just before eof
13:26:05 <nkar> sloppy
13:26:42 <Cale> any luck with the notFollowedBy?
13:26:53 <nkar> haven't tried yet, will do in a sec
13:27:06 <Cale> (I'm still compiling dependencies)
13:27:16 <ajf> Hey, I have a question.
13:27:25 <ajf> Say I do:
13:27:35 <ajf> let is "yolisp" "cool" = True
13:27:56 <nkar> Cale: nope. type mismatch between a string and a unit, notFollowedBy discard the result
13:27:58 <nkar> s*
13:28:11 <ajf> if I do (is "foo") it doesn't error, I have to pass all parameters (is "foo" "bar") to get an error
13:28:11 <ajf> Why?
13:28:19 <Cale> nkar: yeah, of course it has type Parser ()
13:28:25 <Cale> nkar: it doesn't eat any of the input
13:28:38 <Cale> You just stick it in before matching anyChar
13:28:39 <nkar> Cale: can't lambdabot import trifecta?
13:28:50 <oliffia> ajf: it doesnt check that the function is undefined for "foo" until you pass it two arguments
13:28:57 <oliffia> because of lazy evaluation
13:29:27 <Cale> ajf: This is a subtlety of pattern matching multiple arguments at once
13:29:41 <ajf> oliffia: I guess, it just seems weird. You can reject this right off the bat with no consequences
13:29:43 <nkar> Cale: I don't follow, sorry, could you show the middle of the 'do'?
13:29:49 <triliyn> hmmm, that's interesting though, because it's a way that function definitions aren't equivalent to defining a lambda
13:29:58 <oliffia> ajf: its a feature not a bug
13:30:12 <ajf> oliffia: oh I don't think it's a bug
13:30:15 <Cale> triliyn: well, lambdas with multiple arguments work the same way
13:30:21 <oliffia> "bug"
13:30:25 <Cale> But not nested lambdas
13:30:42 <triliyn> > let is "yolisp" = \"cool" -> True in is "foo"
13:30:43 <lambdabot>  <[Char] -> Bool>
13:30:48 <triliyn> ...hmm
13:30:54 <Cale> > (\"foo" "bar" -> 0) "quux" `seq` 0
13:30:56 <lambdabot>  0
13:31:00 <Cale> > (\"foo" "bar" -> 0) "quux" "baz" `seq` 0
13:31:02 <lambdabot>  *Exception: <interactive>:3:2-18: Non-exhaustive patterns in lambda
13:31:13 <Cale> > (\"foo" -> \"bar" -> 0) "quux" `seq` 0
13:31:15 <lambdabot>  *Exception: <interactive>:3:2-22: Non-exhaustive patterns in lambda
13:31:25 <jmct> ajf: Think of it like this let is = \x y -> case x of "yolisp" -> ... etc
13:31:32 <triliyn> > let is "yolisp" = \"cool" -> True in is "foo" `seq` 0
13:31:33 <lambdabot>  *Exception: <interactive>:3:5-33: Non-exhaustive patterns in function is
13:31:41 <triliyn> oh, I see
13:31:50 <jmct> because of the way you've defined 'is' it needs both arguments before entering the function
13:31:54 <ajf> jmct: ?
13:31:55 <triliyn> The Show instance for functions in lambdabot doesn't evaluate
13:32:11 <ajf> jmct: but surely it enters it immediately as it's curried
13:32:27 <triliyn> instance Typeable a, Typeable b => Show (a -> b) where show _ = ...
13:32:28 <triliyn> Or something
13:32:37 <jmct> okay, let me do the curried version
13:32:52 <Cale> ajf: Not necessarily. If functions match on multiple arguments like this, the compiler may wait to receive all the arguments before really entering the body.
13:32:55 <jmct> ajf: let is = \x -> \y -> case x of "yolisp" -> ..
13:33:16 <jasonkuhrt> Hi, what is a pairwise operation?
13:33:17 <ajf> Cale: so if I defined it as foo "yolisp" _ = it'd error immediately?
13:33:25 <Cale> But yeah, even if curried, translating it like that so that the case is inside all the lambdas will work
13:33:30 <Cale> nope
13:33:36 <mauke> jasonkuhrt: in what context?
13:33:48 <Cale> but if you defined it as  foo "yolisp" = \x -> ...  then it would error
13:33:55 <jasonkuhrt> I've just encountered the term in the context of 1 + 2 etc.
13:34:00 <ajf> Alright
13:34:02 <jasonkuhrt> ^ @Cale
13:34:07 <atomx> type M a = State -> (a, State)
13:34:09 <ajf> So, because compiler optimisations, it won't immediately eror
13:34:09 <atomx> type State = Int
13:34:10 <jmct> ajf: Cale beat me to it. Exactly what he said
13:34:11 <ajf> *error
13:34:13 <jasonkuhrt> I mean @mauke
13:34:16 <atomx> How can I define a show for this ?
13:34:27 <mauke> jasonkuhrt: that wasn't really helpful
13:34:33 <atomx> this is type, not data
13:34:40 <oliffia> atomx: you cannot without newtype/data
13:34:41 <jmct> ajf: it's not an optimisation it has to do with how pattern matching is desugared
13:34:51 <jmct> ajf: and laziness
13:34:57 <atomx> hm ?
13:34:57 <mauke> "1 + 2 etc." doesn't even contain "pairwise"
13:34:59 <jasonkuhrt> mauke: what could it mean, then?
13:35:00 <nitrix> Is it possible to have a lazy IO? I'm doing `mapM` over a list of ios, and then I catMaybes and take 3 out of them, yet all the IO are still executed.
13:35:06 <triliyn> I don't think it's really related to laziness
13:35:23 <jasonkuhrt> mauke: I'm quite unfamiliar with the term so..
13:35:24 <atomx> No instance for (Show (M Int)) arising from a use of `print'
13:35:24 <triliyn> It's just that haskell, like almost every other language, doesn't try to evaluate under lambdas
13:35:28 <atomx> this is the error
13:35:45 <johnw> nitrix: is the list of type [Maybe (IO a)]?
13:35:57 <mauke> jasonkuhrt: give me the context
13:36:04 <jasonkuhrt> I see a lot of search results about pairwise comparators
13:36:42 <nitrix> johnw: Before the mapM or after?
13:36:43 <chrisdone> https://github.com/chrisdone/ghci-ng#find-uses
13:36:44 <chrisdone> :3
13:36:51 <jasonkuhrt> Slide 208 from there http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt?utm_source=hackernewsletter&utm_medium=email&utm_term=code
13:36:51 <johnw> nitrix: before
13:36:52 <jmct> triliyn: You're right, but in a lazy language it's semantically incorrect to do so, which isn't always true in a strict language
13:37:12 <jasonkuhrt> @mauke
13:37:13 <lambdabot> Unknown command, try @list
13:37:28 <triliyn> atomx: normally you can't define typeclass instances for type aliases. There is an extension to allow this, but it's not usually considered a good idea because it can make type checking and inference less effective
13:37:43 <Cale> nkar: let comment = do string "/*"; many (comment <|> (do notFollowedBy (string "*/"); anyChar; return ())); string "*/"; return ()
13:37:48 <triliyn> And in particular, because sometimes it might lead to a case where multiple typeclass instances match a particular invocation
13:37:56 <Cale> nkar: I just typed that into ghci, it seems to work
13:38:00 <jasonkuhrt> mauke: It seems to be used in the sense of, a function that normally operators on two arguments now operates on a list
13:38:00 <nitrix> johnw: Before it's a [Provider], after it becomes a [(Provider, Maybe PageId)]. The function doing the mapping has the type :: Provider -> IO (Provider, Maybe PageId)
13:38:10 <atomx> triliyn: thanks. Can I replace type with `data` ?
13:38:10 <mauke> jasonkuhrt: right
13:38:17 <mauke> jasonkuhrt: a pair of input values
13:38:21 <triliyn> atomx: If you really want to define a show instance for it, you might consider using data, yes
13:38:33 <atomx> ok
13:38:36 <jasonkuhrt> mauke: actually I think its trying to say something different
13:38:45 <Cale> nkar: Try it with parseTest (do comment; eof)
13:39:02 <triliyn> The other option is, if you want to keep it as a type alias but print it in a different way than other things of that type, you could just define your own function
13:39:10 <triliyn> Rather than using "show"
13:39:21 <jasonkuhrt> 1 + 2 | 1 + 2 + 3 | 1 + 2 + 3 + 4 -- "a pairwise operation has become an operation that works on lists!"
13:39:23 <johnw> nitrix: ah, I see, you really want a kind of foldM that stops when a condition is reached, such as three Just values
13:39:26 <atomx> I try : <<data M a = State -> (a, State)>>
13:39:27 <jasonkuhrt> ^ that's the full context
13:39:34 <atomx> monad-test-eval-2.hs:23:18: parse error on input `->'
13:39:36 <jasonkuhrt> @mauke
13:39:36 <lambdabot> Unknown command, try @list
13:39:39 <atomx> This is the error
13:39:43 <atomx> how to correct it ?
13:39:49 <triliyn> atomx: data types need constructors
13:39:52 <mauke> jasonkuhrt: why do you think it's something different?
13:39:59 <atomx> hups
13:40:03 <triliyn> So you can say "data M a = MkM (State -> (a, State))"
13:40:15 <nitrix> johnw: My application seems to do this a lot, stopping when there's X amount of success/failures out of a list. So your recommendation is foldM ?
13:40:16 <triliyn> Or whatever you'd like the constructor to be called
13:40:18 <atomx> I think I need to study classes before to adveture in advanced articles
13:40:28 <johnw> nitrix: foldM is the most basic building block, one second
13:40:50 <jasonkuhrt> mauke: I guess its just a different way to think about it, the function `+` is still is accepting only two arguments at once
13:41:09 <nitrix> johnw: To give a context, it tries to upload a resource to multiple Provider and return a tuple/association of the provider and the id of the resource created. It's a file system, and the optimistic goal is to keep 3 replications of each resources.
13:41:32 <nitrix> So you easily see how that logic will be repeated quite often :/
13:41:34 <sinelaw> How important is it to support polymorphic recursion?
13:41:47 <sinelaw> are there real use cases that aren't contrived or overly complex?
13:42:00 <nkar> Cale: yay, thank you!  now I need to understand how to capture the results
13:42:07 <triliyn> atomx: if you don't feel comfortable with classes, there's nothing wrong with just writing your own function of type M a -> String
13:42:20 <chrisdone> sinelaw: Data.Data loops springs to mind
13:42:23 <triliyn> It doesn't need to be part of the Show typeclass unless that makes something easier for you
13:42:36 <atomx> ok. thanks
13:42:48 <sinelaw> chrisdone, ok will look
13:43:21 <lpsmith> Axman6, no postgresql-simple doesn't particularly support PostGIS at the moment,  but it doesn't really get in your way either.
13:43:55 <Cale> nkar: You want a big String?
13:44:01 <chrisdone> sinelaw: e.g. gshow :: Data a => a -> String. this will recurse on subterms of the data type, but all the sub terms will not necssarily be the same type as 'a'
13:44:17 <lpsmith> (I happened to be playing around with ircbrowse just now,  in particular how it does it's searching,  and that's how I saw your question from many months ago that I didn't see...)
13:44:43 <chrisdone> lpsmith: ( ͡° ͜ʖ ͡°)
13:44:54 <sinelaw> chrisdone, so it's being used with existentials?
13:45:00 <nkar> Cale: I've solved it
13:45:25 <chrisdone> sinelaw: rank-n types usually
13:45:27 <chrisdone> :t gmapT
13:45:28 <lambdabot> Data a => (forall b. Data b => b -> b) -> a -> a
13:45:41 <chrisdone> ^ rank-n
13:45:43 <nkar> Cale: cs <- many [...] c <- anyChar; return [c]; [...] return $ concat cs
13:46:05 <sinelaw> I see
13:46:14 <chrisdone> lpsmith: ircbrowse uses sphinx in case you didn't already figure that out
13:46:28 <Cale> nkar: yeah, something like that'll do
13:47:06 <nkar> Cale: thanks again!  without your help, I'd still be struggling with it.
13:48:09 <lpsmith> chrisdone, yeah I know you were using some kind of adjunct...
13:48:48 <lpsmith> chrisdone, I was playing around with trying to solve a similar-ish problem today,  trying to see if the trigram index would be sufficient for my needs
13:49:02 <lpsmith> As far as I can tell,  not so much.  So maybe sphinx it is... :)
13:50:02 <chrisdone> lpsmith: although i don't use the haskell library as that was incompatible with the version of sphinx i had at the time of writing… i call out to the commandline program: https://github.com/chrisdone/ircbrowse/blob/master/src/Sphinx.hs
13:50:02 <chrisdone> lpsmith: i think running a server and connecting to it would have less overhead, but at this moment in time i don't feel updating it. probably today the haskell package for sphinx is more tight and usable
13:50:24 <lpsmith> hah, I know that feeling
13:51:00 <chrisdone> it seems non-trivial to do a live-running update of the index, i re-generate it once daily with sphinx
13:51:13 <chrisdone> if you figure out a trivial way to update it live, please send me an email =)
13:51:47 <chrisdone> i heard "Elastic Search" is decent, but haven't tried it
13:52:28 <lpsmith> I'm still calling out to the curl external process in a number of my production services,  because I needed a robust HTTP client with a sane-ish API to post a tiny bit of data to a url protected by digest authentication...
13:53:38 <lpsmith> I'm rewriting some of those services,  I'm thinking about keeping the call to curl the same, honestly.
13:53:55 <ionum> any emacs users here? if yes then what setup do you use?
13:55:12 <johnw> nitrix: here is a more principled way to do what you're asking: https://gist.github.com/5a67541e319ebe5aca3b
13:55:22 <chrisdone> lpsmith: heh, if it ain't broke =)
13:55:39 <johnw> nitrix: instead of lazy IO, we use proper streaming to pull out the first three non-Nothing values from your generated stream of ids
13:55:58 <chrisdone> ionum: https://github.com/chrisdone/chrisdone-emacs#im-just-here-to-see-your-haskell-config
13:56:12 <nitrix> johnw: That's the pipes library?
13:56:19 <chrisdone> hmm
13:56:24 <nitrix> module*
13:56:29 <johnw> it provides an alterantive to lazy IO with proper resource cleanup and constant memory use
13:56:30 <chrisdone> i might extract just the haskell-specific part of my emacs config into a clonable repo
13:56:35 <nitrix> I never used >-> before, interesting.
13:56:39 <johnw> yes, that's pipes
13:57:05 <nitrix> johnw: Appreciated, I'll check. Thanks a lot for the snippet.
13:57:11 <nitrix> :)
13:58:18 <chrisdone> ionum: i use haskell-mode + haskell-interactive-mode + structured-haskell-mode and ghci-ng
13:59:13 <chrisdone> i'mma make a git repo of that configuration so newbies can just emacs -Q -l it
14:00:10 <ionum> thanko
14:00:13 <ionum> thanks
14:00:27 <ionum> i will take a look at it
14:01:15 <chrisdone> strange that i never thought of doing that before
14:01:22 <chrisdone> seems obvious
14:01:40 <sinelaw> does anybody know when a version of language-ecmascript  that supports ES6 will be released?
14:05:28 <Jello_Raptor> hmm, what's the canonical way to insert an element into a map in a state monad with control.lens?
14:05:41 <Jello_Raptor> I've used "mapLens %= Map.Insert k v"
14:05:49 <jeltsch> carter: Are you around?
14:05:55 <carter> sometimes
14:05:57 <Peaker> Jello_Raptor: that works, but you can also use:  mapLens . at k %= v
14:06:03 <jeltsch> I meant: now. :-)
14:06:08 <Peaker> oops: mapLens . at k .= Just v
14:06:14 <Jello_Raptor> but shouldn't "mapLens . (at k) .= v "  work?
14:06:31 <Peaker> Jello_Raptor: I think "at" uses "Maybe" wrapper on value to allow for deletion
14:06:32 <jeltsch> carter: I’d like to come back to our topic of Thursday.
14:06:41 <Jello_Raptor> Peaker: why does it need to be in a may ... ahh I see
14:06:42 <carter> i dont remember thursday
14:06:52 <jeltsch> carter: Order maintenance.
14:06:56 <carter> order of what
14:06:57 <carter> ?
14:07:02 <carter> i literally dont recall this chat
14:07:15 <carter> refresh my mmemory :)
14:07:20 <Peaker> Jello_Raptor: it's nice because "at" replaces so many APIs at once :)
14:07:42 <chrisdone> carter: do you want a new keyboard for your birthday?
14:07:48 <carter> ??
14:07:51 <jeltsch> carter: Hmm. This was this problem where you want to maintain a total order. You can create new elements beside existing ones, delete elements, and query whether an element comes before another wone.
14:07:57 <carter> oh
14:07:59 <carter> frp thing
14:08:05 <carter> didyou ask people on #haskell-game?
14:08:08 <lpsmith> chrisdone, yeah for the time being,  and probably for the indefinite future, a daily rebuild of the sphinx index would probably be sufficient for my needs.
14:08:15 <Jello_Raptor> Peaker: yeah, I can see that. This is the first project I've used Control.Lens with, and it's got a lot of depth. I'd be in love if only I could understand what the hell is happening with the types.
14:08:18 <jeltsch> carter: Yes, FRP was one of the final applications.
14:08:22 <lpsmith> Out of curiousity,  do you know about how long it takes to reindex each day?
14:08:30 <carter> chrisdone: context of offer?
14:08:35 <carter> or was that  typoe?
14:08:50 <Peaker> Jello_Raptor: do you understand the "(a -> f b) -> s -> f t" formulation?
14:08:56 <jeltsch> carter: When I told you about order maintenance, you immediately guessed that I was looking at incremental sorting.
14:09:08 <carter> true
14:09:20 <carter> i'm good at guessing :)
14:09:33 <jeltsch> carter: I’m just curious how you knew. Did you look at incremental sorting yourself? Or is this so much folklore that everyone knows about this connection?
14:09:49 <Peaker> Jello_Raptor: SPJ has a nice talk about that formulation that explains it well
14:10:22 <toblerone> Hi all, I saw an example of dependent typing in haskell and I was wondering how you would declare type class instances on examples like this: http://lpaste.net/8539409640406908928
14:10:50 <shachaf> That's not dependent types. :-(
14:10:53 <toblerone> o
14:10:54 <toblerone> well
14:11:00 <carter> jeltsch: neither
14:11:05 <carter> i was totally guessing
14:11:07 <Jello_Raptor> Peaker: this one? https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
14:11:15 <jeltsch> carter: Amazing!
14:11:16 <carter> because people often ask proxy questions
14:11:20 <toblerone> shachaf: is it somewhat analogous to dependent typing?
14:11:23 <carter> instead of the real thing they wanna know
14:11:36 <carter> so its worth practicing figuring out "what do you really mean"
14:11:37 <carter> :)
14:11:49 * hackagebot hashtables 1.2.0.0 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.2.0.0 (GregoryCollins)
14:12:06 <Peaker> Jello_Raptor: yeah
14:12:17 <shachaf> Guessing is unhelpful to everybody.
14:12:32 <shachaf> toblerone: Well, it doesn't have types depending on values.
14:12:34 <johnw> Peaker: also at http://ftp.newartisans.com/pub/Lenses.mp4
14:12:51 <shachaf> You would be able to do something like it in a dependently typed language, sure, but it's not dependent types.
14:13:02 <sinelaw> johnw, thanks for that
14:13:09 <jeltsch> toblerone: I guess that this Tree type doesn’t fit the Haskell Monad class. Maybe it isn’t even a monad. It could be a relative monad though.
14:13:10 <carter> jeltsch: that said good incremental sorting / merging algorithms come up in many many problem domains
14:13:19 <carter> like... all of data basees
14:13:26 <Jello_Raptor> johnw: that's a lot more convenient, thank you.
14:14:00 <jeltsch> carter: I can imagine that the database folks need this every now and then. In particular, the big data people.
14:14:10 <toblerone> shachaf: It doesn't? Node (Leaf 1) (Leaf 2) has type Tree 1 Int. Whereas Leaf 1 has type Tree 0 Int
14:14:18 <carter> jeltsch: everyone needs fancy merging
14:14:27 <jeltsch> carter: Everyone?
14:14:28 <chrisdone> carter: your typos =p
14:14:29 <toblerone> jeltsch: Maybe isn't a monad?
14:14:29 <carter> yes
14:14:37 <carter> chrisdone: ohhhhhhhhhhh
14:14:49 <carter> its 'cause i'm lounging on a couch as I internet
14:15:00 <chrisdone> interlounging
14:15:09 <jeltsch> toblerone: Maybe is a monad, but maybe your Tree type isn’t a monad.
14:15:22 <jeltsch> Or: Your Tree type is maybe not a monad.
14:15:27 <toblerone> o
14:15:45 <Jello_Raptor> hmm, could you make Tree a monad by using it as a wrapper around a backtracking calculation?
14:16:19 <jeltsch> Jello_Raptor: I don’t understand this. Without the Nat parameters, Tree would be a monad.
14:16:23 <Jello_Raptor> nope :/ the model I'm thinking of would require the tree to hold arbitrary types
14:16:33 <toblerone> Well, I meant I wasn't sure how to even declare it an instance of any typeclass
14:17:37 <toblerone> And just to confirm, this isn't an example of dependent typing? I mean, it seems to me that the type depends on the value...
14:17:48 <jeltsch> toblerone: If the type class doesn’t mention the Nat kind, then you can only make applications of Tree type class members. For example: class Whatever (Tree 0). Or: class Whatever (Tree n) (∀ n).
14:18:00 <Jello_Raptor> actually, no with laziness the backtracking calculation monad is basically List
14:18:22 <carter> jeltsch: i realize i'm not giving you actionable suggesttions
14:18:33 <carter> but thats partly becuase you've not articulated your target workload
14:18:41 <toblerone> Ah, meaning I would have to define an instance for each type?
14:19:28 <jeltsch> toblerone: You could do the following, for example:
14:19:39 <jeltsch> toblerone: instance Eq (Tree n) where …
14:19:56 <jeltsch> You would essentially get an Eq instance for every n.
14:20:07 <jeltsch> You could then compare trees of the same height.
14:24:08 <toblerone> And is this dependent typing or not? : )
14:34:58 <Jello_Raptor> How do I write a type signature that requires two variables of the same type-class, but not necessarily of the same resolved type?
14:35:01 <johnw> toblerone: which type are you thinking might be a dependent type?
14:35:13 <johnw> Jello_Raptor: (Foo a, Foo b) => ...?
14:35:21 <Jello_Raptor> "foo :: Num a,b => a -> b -" ahh
14:35:32 <Jello_Raptor> johnw: thank you, that was weirdly hard to google
14:35:37 <johnw> yeah, I bet
14:35:46 <mauke> language reference > google
14:35:56 <mauke> usually
14:36:09 <johnw> and apparently #haskell > language reference
14:36:47 <mauke> irc channels are extremely good for questions with small, concrete answers
14:37:04 <mauke> including questions like "where can I find this in the reference?" :-)
14:37:05 <johnw> the Romans used concrete in their buildings
14:38:51 <lpaste> bananagram pasted “error in case?” at http://lpaste.net/115829
14:39:13 <mauke> bananagram: broken indentation
14:39:24 <bananagram> it's not broken in my file
14:39:43 <mauke> yes, it is
14:39:48 <mauke> 'let' triggers layout
14:40:05 <mauke> you need to indent all cases beyond the '(' of 'let (initx, ...'
14:40:18 <bananagram> oh, I see
14:41:18 <toblerone> johnw: Sorry, I didn't see you had responded. http://lpaste.net/8539409640406908928
14:41:37 <johnw> ah, that's not a true dependent type
14:41:58 <johnw> Nat is promoted to the type level, so that 0 is really a singleton type (whose value is also 0)
14:42:10 <bananagram> thanks
14:42:52 <mauke> the let/case thing is annoying
14:42:59 <bananagram> yeah
14:43:07 <mauke> I haven't found a good indentation rule for that yet
14:43:40 <johnw> toblerone: and that + in n+1 isn't the function plus, but a type operator that conveniently looks and feels like the function +
14:44:43 <gfixler> quick question: How far off is denotational semantics for someone with essentially 0 maths background?
14:44:56 <gfixler> Are we talking months, a year, a decade?
14:45:07 <johnw> I don't think you need formal mathematics at all
14:45:20 <gfixler> oh really?
14:45:33 <johnw> you can think about lists without thinking about how they are implemented
14:45:39 <johnw> so you can think denotational about lists
14:45:44 <gfixler> I heard the chatter in here yesterday, got excited, looked it up, and it was math everywhere
14:45:44 <johnw> *nally
14:46:00 <johnw> there is a lot of rigorous formalism, but you don't need it to get started
14:46:17 <gfixler> I started by trying to read wikipedia
14:46:21 <gfixler> it was a bit dense
14:47:02 <finishingmove> Guys, anyone here on Windows? haskellmode-vim keeps nagging to me about the location of haddock docs. Does anyone know what I should set g:haddock_docdir to? On Ubuntu the location was automatically picked up by the plugin
14:47:21 <johnw> gfixler: maybe this will introduce it better: http://www.cl.cam.ac.uk/teaching/1011/DenotSem/l1.pdf
14:48:03 <johnw> see also https://www.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/denote.pdf
14:48:11 <RchrdB> gfixler: wikipedia is *really* difficult to learn maths from because it's written much more like a reference rather than a tutorial.
14:48:43 <gfixler> johnw: I'll read through them - thanks!
14:49:14 <gfixler> RchrdB: interestingly, I ended up on a math-heavy page on Wikipedia recently and *could* (first time) read a lot of it, thanks to Haskell
14:49:27 <RchrdB> heh, neat! :)
14:49:52 <gfixler> it was like that scene in Spider-Man where he realizes he can climb walls, but I was understanding category theory stuff instead
14:50:20 <apo_> Spidermath, spidermath
14:50:52 <toblerone> johnw: hmm, okay... I really know very little about dependent types, so I probably can't appreciate the differences, but is the outcome not effectively the same in this example?
14:51:02 <johnw> gfixler: and of course, any video on the subject by Conal Elliott is worth watching (https://www.youtube.com/watch?v=Hp3v28ws1ps)
14:51:19 <gfixler> johnw: \o/ videos!
14:51:21 <johnw> toblerone: in this example, the notations do intersect
14:51:51 <johnw> toblerone: but in a dependently typed language, 'n + 1' would really be a value, not a singleton type masquerading as a value-like entity
14:52:24 <toblerone> right
14:52:35 <johnw> for one thing, the language of type operators avaliable to you in GHC is much smaller in breadth and scope than its language of regular functions.  In a dependently typed language, you'd have access to all the functions you've written
14:52:37 <toblerone> well can haskell achieve that?
14:52:52 <toblerone> I was under the impression that it can only fake it
14:53:06 <johnw> it's inching in that direction, for sure, but there are some capacities it will never have without giving up other things that we like a lot about Haskell (such as a great type inference)
14:54:01 <toblerone> hmm, so you can use functions on both the value and type level?
14:54:12 <johnw> in a DT language?  sure
14:54:16 <toblerone> that same functions that this
14:54:20 <toblerone> that is*
14:54:45 <johnw> for example: weirdLeaf :: a -> Tree (length [1,2,3]) a
14:55:02 <sinelaw> given type:
14:55:06 <sinelaw> data F = F (F -> F)
14:55:20 <sinelaw> is this type inhabited?
14:55:21 <johnw> you can write that in GHC, using the singletons library, but things get contorted quickly
14:55:23 <mauke> oh hello, lc
14:55:33 <johnw> sinelaw: you mean, besides by undefined?
14:55:36 <toblerone> And that function "length" needn't be defined specifically to operate on the type level?
14:55:39 <sinelaw> johnw, yes
14:55:46 <mauke> sinelaw: yes, F undefined :-)
14:56:07 <mauke> F id
14:56:15 <toblerone> sinelaw: I'm not sure what you mean be inhabited
14:56:17 <merijn> sinelaw: Wouldn't "F F" also inhabit it?
14:56:25 <sinelaw> oh right
14:56:33 <mauke> F :: (F -> F) -> F
14:56:38 <carter> data F =  F (F -> F) | L Int
14:56:43 <toblerone> You mean, Inhabited in the same way that Maybe is inhabited?
14:56:48 <merijn> mauke: oh right, I have a case of the dumbs
14:56:59 <johnw> toblerone: he means that values of that type can be constructed
14:57:04 <carter> my F can be inhabitit
14:57:09 <Peaker> sinelaw: I toyed with such types in GHC (to write the Y combinator), and then GHC hung. And then I saw a WONTFIX ticket about it
14:57:14 <toblerone> ah
14:57:19 <sinelaw> Peaker, ha
14:57:27 <mauke> F (\(F f) -> F (f . f))
14:57:30 <Peaker> sinelaw: basically the inliner loops infinitely
14:57:51 <carter> unless you NOINLINE ?
14:57:53 <Peaker> (expanding the Y combinator quine to itself)
14:58:00 <Peaker> probably, I don't remember :)
14:58:16 <sinelaw> mauke, hmm
14:58:17 <orion> https://hackage.haskell.org/package/cryptohash-cryptoapi-0.1.3/docs/src/Crypto-Hash-CryptoAPI.html#MD2 <-- here MultiParamTypeClasses are used. Aren't those frowned upon?
14:58:18 <sinelaw> yeah
14:58:38 <Peaker> MTPC's can still do things that TF's can't
14:58:45 <Clint>  /win 23
14:58:58 <johnw> mtl relies on MPTC's, and that's a pretty core library
14:59:11 <mauke> Peaker: oh, example?
14:59:43 <Peaker> mauke: you can't have a type family instance like:  instance Foo Bar where type M Bar = forall m. m
14:59:57 <Peaker> but you can say:  instance Foo Bar m where ...
15:00:09 <merijn> mauke: type families can never let you dispatch on types, so it seems fairly obvious MPTC can do things TF can't
15:00:12 <Peaker> (that's what I encountered recently, but maybe there's more)
15:01:11 <Peaker> merijn: oh, true, another way to put that - is that MPTC's let you avoid a fundep between the types, but type families require a fundep
15:01:42 <merijn> I don't see how that's true
15:01:59 <Peaker> merijn: the dispatch is possible because you have multiple independent type params to the class you can dispatch on independently
15:02:02 <merijn> type families let you do many things that fundeps let you do in the context of MPTC
15:02:26 <Peaker> merijn: if you have fundeps between the type params to the class - then you can no longer use it for dispatch
15:02:51 <Peaker> Yes, type families are like fundeps, but MTPC's without fundeps do things that type families can't
15:02:57 <merijn> Type families don't let you dispatch on types *at all*, so they don't event compete with ordinary typeclasses in that functionality, so obviously MPTC are even more powerful, since they generalise typeclasses
15:03:09 <Peaker> merijn: I'm agreeing with you, just rewording it :)
15:03:11 <carter> MTPC + fundeps == polymorphic things :)
15:03:35 <merijn> I much prefer typefamilies over fundeps, tbh
15:03:44 <merijn> I just don't "get" fundeps
15:04:05 <Peaker> merijn: Type families are nicer fundeps, but MPTC's (without fundeps) are just a different thing from families, apparently, so cannot be replaced by families
15:04:51 <merijn> Yes, my initial point was that I was baffled by how you could think that was even a reasonable question in the first place :p
15:05:34 <Peaker> merijn: we all have very different ideas of triviality :)
15:05:39 <merijn> I'm not disagreeing with your observation, I'm trying to figure out why that wasn't obvious :) (Since I'm giving a talk on typefamilies soon)
15:07:16 <orion> I read the description of tagged as follows: "Haskell 98 phantom types to avoid unsafely passing dummy arguments "
15:07:33 <Peaker> merijn: well, families are touted as a replacement for MTPC's and fundeps, not just for fundeps
15:07:35 <orion> Does that mean that the tagged library is no longer needed in Haskell2010?
15:07:53 <Peaker> merijn: and they can do most(all?) of what fundeps can do, so it can (wrongly) suggest they replace MTPC's entirely
15:08:02 <chrisdone> i tried to use type families in lucid first
15:08:17 <merijn> orion: If you're okay with extensions then GADTs are a much safer way of doing "safe" phantom types
15:08:21 <chrisdone> but due to the lack of dispatching on the return value went with multi param classes
15:08:35 <merijn> Peaker: Do you have a link where that was suggested?
15:08:40 <orion> merijn: Can you link me to an article explaning how to do this?
15:08:45 <merijn> orion: https://en.wikibooks.org/wiki/Haskell/GADT
15:08:54 <orion> thank you
15:09:04 <chrisdone> tho i will say i *really* enjoy the relationship between GADTs and type families, especially closed ones
15:09:04 <merijn> <3 GADTs
15:09:10 <merijn> chrisdone: Word.
15:09:11 <chrisdone> it's nice to just have a GADT type and some type functions
15:09:23 <Peaker> merijn: I don't off hand, sorry
15:09:23 <merijn> chrisdone: GADTs + TypeFamilies + DataKinds == <3
15:09:28 <chrisdone> <3
15:09:44 <chrisdone> i used this combination for a type-safe file path module at work t'other day
15:10:21 <chrisdone> pretty much similar to this http://hackage.haskell.org/package/data-filepath-2.0.0.0/docs/Data-FilePath.html
15:10:35 <merijn> orion: FYI, I think GADTs are one of the extensions that gives me the most practical benefit for writing Haskell
15:10:35 <chrisdone> although mine is stricter
15:11:10 <merijn> I really think GADTs should just be default, but afaik the main controversy is that this would imply ExistentialQuantification by default
15:11:21 <orion> I see.
15:11:32 <Peaker> merijn: why would that be controversial?
15:12:05 <merijn> Peaker: I don't know?
15:13:31 <sinelaw> how about this one?
15:13:32 <sinelaw> data F2 a = F2 (a -> F2 a)
15:13:33 <phaskell> F2: https://phabricator-files.haskell.org/file/data/ua7my4ghh76cx3t2xwji/PHID-FILE-sunt5wrp6dyuzghh7lbd/github_-profile.jpg - github_-profile.jpg
15:13:49 <sinelaw> phaskell, wtf.
15:14:08 <chrisdone> "F2"
15:14:21 <sinelaw> realized that. still, WTF
15:14:33 <johnw> merijn: throw in PolyKinds and TypeOperators too :)
15:14:36 <orion> merijn: Do you think that the cryptoapi's definition of "Hash" seen here: https://hackage.haskell.org/package/crypto-api-0.13.2/docs/src/Crypto-Classes.html could be improved upon with GADTs, or is there a good reason not to use them in this case?
15:15:09 <joe9>  need some help with using the correct data structure: http://codepad.org/lVFC3Xzk is my curreent source. Is there any other smarter data structure that I can use instead of all those ids? It is a pita to keep track of all those id's when deleting them, etc.
15:15:34 <merijn> orion: There's only 1 real reason to not use them: They're not standard haskell and therefore not portable to non-GHC compilers. Since, most likely, you don't care about non-GHC compilers anyway, no there's no real reason not to avoid them
15:15:38 <sinelaw> this time I can't see any value that can inhabit that (besides undefined)
15:16:50 <chrisdone> cabal repl sucks D:
15:17:53 <lpaste> chrisdone pasted “What the deuce” at http://lpaste.net/115830
15:18:19 <sinelaw> is there a way to ask djinn about this?
15:18:30 <sinelaw> doesn't understand data types AFAIK
15:19:39 <merijn> orion: Most GHC extensions are uncontroversial, i.e. they don't break correct code and any changes are detected at compile time.
15:22:57 <merijn> The only ones to be a bit careful with are OverlappingInstances/IncoherentInstances/UndecidableInstances/GeneralizedNewtypeDeriving and maybe ImplicitParameters. UndecidableInstances and ImplicitParameters are still ok (although they can often signal misdesigns), GeneralizedNewtypeDeriving is fine (but can, if you try, break type safty in gross way. The usual usecase is perfectly safe, though), Overlapping
15:23:03 <merijn> Instances is terrible, but safe. IncoherentInstances is danger territory, it can lead to changes in unrelated code breaking the functionality in a way you can't detect at compile time
15:23:21 --- mode: ChanServ set +o glguy_
15:23:59 --- kick: phaskell was kicked by glguy_ (Still responding to messages without prefix)
15:24:08 --- mode: glguy_ set -o glguy_
15:24:26 <sinelaw> there should be a different syntax or a naming convention for extensions that potentially break safety
15:24:27 <trap_exit> anyone know of good ear muffs for blocking human voice? I can't do ahskell unless I have silence, and most earplugs/earmuffs are designed to _allow human voice_
15:24:56 <oliffia> trap_exit: youll probably want noise cancelling headphones
15:25:08 <zomg> noise cancelling cans, or "closed" headphones yup
15:25:16 <glguy> Noise canceling headphones make it easier to hear people in my experience
15:25:17 <trap_exit> what are "closed" head phones?
15:25:25 <StoneCypher> trap_exit: http://www.pksafety.com/peltor-h10a.html?gclid=CLnUobbHssICFROTfgodZ7AAlw
15:25:32 <trap_exit> and do noise cancelling actually work better than, say http://www.amazon.com/3M-Peltor-X-Series-Earmuffs-X5A/dp/B00CPCHBCQ
15:25:33 <glguy> They block out the background noise and you hear the voices more clearly
15:25:33 <zomg> open headphones basically have holes in them which let sound out
15:25:46 <zomg> outside your ears that is
15:25:46 <StoneCypher> trap_exit: they do not
15:25:48 <zomg> closed ones don't
15:25:52 <zomg> that's the gist of it anyway =)
15:25:56 <trap_exit> StoneCypher: ha, I was about to also buy that one, it's 30db
15:25:58 <johnw> sinelaw: f2 = let x = F2 (\a -> x) in x
15:26:05 <StoneCypher> trap_exit: i have both an amazing pair of closed headphones and a sound isolation muff set
15:26:24 <trap_exit> StoneCypher: do you considr he 3M link a "sound isolation muff set" ?
15:26:25 <zomg> I highly doubt that any headphones will block sound as efficiently as something like that :P
15:26:27 <trap_exit> StoneCypher: what closed headphones do you have?
15:26:28 <StoneCypher> trap_exit: sound isolation muff sets don't have to sound good on your ears, so they can just focus on silence, and they're more comfortable too
15:26:53 * hackagebot unbound-generics 0.0.2 - Reimplementation of Unbound using GHC Generics  http://hackage.haskell.org/package/unbound-generics-0.0.2 (AlekseyKliger)
15:27:10 <StoneCypher> trap_exit: the v-moda crossfade m100s
15:27:25 <zomg> I recall Koss has some decent closed cans in the cheaper price-spectrum
15:27:59 <trap_exit> man, taht's expensive
15:27:59 <trap_exit> I'll stik with ear muffs
15:27:59 <StoneCypher> trap_exit: m-100s highly recommended as long as you aren't heat sensitive (they're warm) and as long as you like heavy bass (you do)
15:28:51 <StoneCypher> trap_exit: there are so many things i never heard in my music before i got these
15:29:09 <merijn> sinelaw: The user guide is pretty explicit about the safety of extensions
15:29:10 <trap_exit> i don't like music
15:29:11 <trap_exit> i like silence
15:29:28 <StoneCypher> well i have both because sometimes i need silence, but, if you don't like music, you probably don't need these :D
15:30:03 <sinelaw> merijn, that's good but it would be nice for extensions I'm not familiar with, that as soon as I see them in code or if someone suggests that I use them I can immediately tell if they're safe or not
15:30:13 <zomg> yeah if you don't need something that plays music, earmuffs are probably the cheapest way to silence
15:30:30 <sinelaw> merijn, basically to be able to tell this crucial fact about an extension from its name
15:30:45 <trap_exit> i think zombies are also a good way to achieve silence
15:30:47 <merijn> sinelaw: To be fair "incoherent" doesn't inspire much safety :p
15:30:50 <trap_exit> the walking dead zombies are attracted to noise
15:31:10 <johnw> i suddenly feel as if we're not talking about Haskell anymore...
15:31:15 <sinelaw> merijn, there's an inconsistency though
15:31:24 <bananagram> what's a good tool to manipulate BMPs, like to merge many small ones into one?
15:31:32 <trap_exit> johnw: point taken
15:31:43 <merijn> sinelaw: And GeneralizedNewtype deriving is only unsafe in the presence of GADTs and willfully trying to subvert it, i would rate it as "nearly impossible" to do accidentally
15:31:49 <johnw> bananagram: if I
15:31:50 <sinelaw> GeneralizedNewtypeDeriving is it absolutely safe or not?
15:32:02 <johnw> if all you need to do is merge them, without any interpretation, can you just load the byte streams?
15:32:27 <merijn> sinelaw: Basically, if you combine GeneralizedNewtypeDeriving + GADTs and overwrite the Typeable instance you can implement unsafeCoerce
15:32:32 <johnw> otherwise, there's the bitmap library
15:32:50 <bananagram> johnw: I want to do a little more complex things than that, as well
15:32:56 <johnw> sinelaw: did you see my answer to your F2 query?
15:33:02 <sinelaw> johnw, no
15:33:09 <johnw> f2 = let x = F2 (\a -> x) in x
15:33:11 <merijn> sinelaw: Still takes likes 1 extra datatype and a few helper functions, so like I said, pretty damn hard to do accidentally
15:33:21 <sinelaw> johnw, thanks
15:33:33 <johnw> tying the knots gives you inhabitants to many recursive types
15:33:55 <jeltsch> merijn: You do not need to overwrite the Typeable instance.
15:34:15 <sinelaw> johnw, that's what I was trying to get at...
15:34:25 <merijn> jeltsch: No? I forget the exact implementation, tbh
15:34:27 <sinelaw> thanks for clarifying how to do that
15:36:00 <trap_exit> so for achieving silence, can one do better than: (1) earplug + (2) http://www.amazon.com/3M-Peltor-X-Series-Earmuffs-X5A/dp/B00CPCHBCQ/ ?
15:36:46 <zomg> Outside of removing your ears I doubt it.. I mean those things are designed to remove as much noise as possible
15:37:11 <zomg> Possibly with more expensive muffs, although I suspect there is a limit to how much better they would get
15:37:52 <sinelaw> johnw, what i'm trying to figure out is, whether some functions that fail occurs check can be defined with an explicit data type
15:38:10 <joe9>  Regarding this question: http://codepad.org/lVFC3Xzk is my curreent source. Is there any other smarter data structure that I can use instead of all those ids? It is a pita to keep track of all those id's when deleting them, etc. Is there any place where I can find a list of haskell (or, implementable in haskell) data structures?
15:38:18 <sinelaw> johnw, apparently so
15:38:24 <gfixler> johnw: conal needs a pop filter
15:38:56 <johnw> gfixler: I'm eagerly awaiting the upload of his 2 hour LambdaJam presentation on the same topic
15:39:24 <merijn> joe9: I don't see a good way to avoid that, no. I'd just hide it by some nice interface functions
15:39:27 <gfixler> johnw: now I am too
15:39:47 <joe9> merijn: ok, thanks.
15:39:58 <johnw> gfixler: his slides from that presentation: http://conal.net/talks/lambdajam-2014.pdf
15:40:05 <sinelaw> and if that's the case, why can't the compiler avoid occurs check failure in those cases?
15:40:43 <gfixler> johnw: got 'em (link below the first vid) - I like how I can see the slide number in the corner of the screen
15:47:06 <joe9> merijn: I could probably use IntMap instead of Map
15:47:58 <codygman> Perhaps you haven't installed the "dyn" libraries for package ‘vector-0.10.12.1’: http://lpaste.net/115831 ???
15:48:48 <merijn> codygman: Looks like you're trying to build a dynamically linked binary while your existing libraries were installed without dynamic
16:00:23 <orion> merijn: I am struggling to determine how GADTs help me in this simple case: http://lpaste.net/2467858908014706688
16:01:40 <merijn> orion: That case doesn't have any phantom parameters, so the answer is most likely "it doesn't"
16:02:00 <Cale> orion: Why would you expect it to? I think maybe we need more detail about what you're trying to do.
16:02:13 <Cale> Sometimes you can replace usage of type classes with usage of GADTs
16:02:13 <orion> merijn: Isn't 'a' a phantom type since it's thrown out?
16:02:33 <orion> It won't compile without having it.
16:02:42 <Cale> orion: It's not a phantom type parameter to a datatype
16:02:46 <merijn> orion: Phantom types are types that don't exist at the value level
16:02:47 <Cale> Unless you're talking about ->
16:03:02 <merijn> "data Foo a = Foo Int" <- 'a' is a phantom type
16:03:20 <Cale> In (a -> b), it's sort of like the 'a' is phantom, but that's a weird case.
16:03:22 <merijn> Because it doesn't exist at the value level (i.e., it lacks a body, hence the ghost term)
16:03:51 <Cale> When you apply the x function in your code, you'll still supply a value of type Bar
16:03:55 <merijn> In case of 'a -> b' you need an actual 'a' to apply the function too, even if the 'a' might not be used inside the function
16:27:36 <orion> https://hackage.haskell.org/package/crypto-api-0.13.2/docs/src/Crypto-Classes.html <-- How would one evaluate outputLength for a given Hash, say, SHA512?
16:33:38 <chrisdone> anybody want to be a guinea pig? =) https://github.com/chrisdone/emacs-haskell-config
16:34:34 <monochrom> "You need GHC version GHC 7.8.3--7.8.3"?! :)
16:36:01 <chrisdone> thanks, fixed
16:40:31 <orion> merijn: Are you saying that GADTs are more safe than doing this?: http://lpaste.net/6946514778374275072
16:40:56 <eXeC64> Well, ghci has now replaced my go-to choice of interpreter when I want a calculator.
16:41:23 <eXeC64> *replaced python as
16:47:31 <Chathurga> Why is pure defined on Applicative Functor?
16:47:46 <merijn> orion: The advantage of GADTs is that they let you restrict what the valid tags for a value are
16:48:00 <merijn> Chathurga: Well, because that's how they're defined?
16:48:11 <merijn> Chathurga: I'm not sure I understand the question? :)
16:48:20 <Chathurga> Yes but why Ap Functor and not Functor
16:48:58 <merijn> Chathurga: Because pure is not a prerequisite of being a functor
16:48:59 <chrisdone> not all functors necessarily support a point
16:49:12 <merijn> Not all functors support "getting values in"
16:50:00 <Chathurga> But all Ap Functors do? That's actually interesting because I couldn't even think of something that is a functor but not an ap functor
16:54:01 <merijn> Chathurga: I can give you a simple example (that may not seem immediately obvious)
16:54:41 <merijn> There is "data Const a b = Const a", it's usefulness isn't obvious, but it plays a key part in, for example, lens so let's just focus on why it's a functor and not an Applicative rather than it's use
16:55:08 <merijn> The functor instance is easy: "instance Functor (Const a) where fmap f (Const x) = Const x" <- done
16:55:14 <shachaf> (,) is a simpler example for this.
16:55:38 <shachaf> (e,) is Applicative exactly when (Const e) is Applicative, and both are always Functor.
16:55:40 <merijn> shachaf: Oh, you're probably right
16:55:52 <merijn> Chathurga: Rewind, let's go with
16:55:55 <Chathurga> Const is fine, I've seen it used
16:56:00 <merijn> ok
16:56:22 <Chathurga> so is it because the type of b is unkown in ApFunctor
16:56:23 <merijn> Chathurga: So obviously we don't apply 'f', since the 'b' in "Const a b" is a phantom type and we can just change
16:56:30 <Zemyla> @pl \f n -> if n == 0 then 1 else n * f (n - 1)
16:56:30 <lambdabot> ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)
16:56:36 <Chathurga> yeah right, that's really cool
16:56:49 <chrisdone> http://chrisdone.com/fmap/ ← play the functor game =p
16:56:53 <merijn> Chathurga: If we try to implement "pure :: a -> Const x a" <- whoops
16:56:58 <orion> merijn: GADTs restrict what the valid tags for a value are... why not use typeclass contexts?
16:57:16 <merijn> Chathurga: We need an 'x' from somewhere, but we have no way to create an 'x'!
16:57:23 <Chathurga> merijn: Wow, thanks, makes a lot of sense
16:57:48 <merijn> Chathurga: Incidentally, you *can* do "instance Monoid x => Applicative (Const x)", can you see why?
16:58:13 <merijn> Chathurga: As shachaf points out, this applies equally well to the ((,) e) functor instance
16:58:22 <Chathurga> because the a - m b function supplies the second type parameter?
16:58:31 <merijn> :t mempty
16:58:32 <lambdabot> Monoid a => a
16:58:50 <merijn> Chathurga: Monoids have a default element and "mappend" obeys the Applicative laws
16:59:06 <Chathurga> oh woops you said monoid, sory
16:59:23 <merijn> "pure x = Const mempty; Const x <*> Const y = Const (mappend x y)"
17:00:13 <merijn> Similarly, for tuples it's "pure x = (mempty, x); (x, f) <*> (y, z) = (mappend x y, f z)"
17:01:44 <Chathurga> Oh weird, that relationship seems hard to encode in haskell
17:02:32 <merijn> Chathurga: You can't really encode it in haskell. Which is why we have laws for typeclasses. Laws are properties you can't encode, but "correct" instances are expected to follow
17:03:33 <merijn> For example "mappend x y = []" is a type correct implementation of mappend for lists, but it doesn't obey the Monoid law that "mappend x mempty == x"
17:07:20 <atomx> type M a = State -> (a, State)
17:07:20 <atomx> type State = Int
17:07:29 <atomx> How can I define this type as data ?
17:07:47 <atomx> such that they be identical ...
17:09:03 <merijn> atomx: You can't, data always has to have a constructor
17:09:19 <merijn> atomx: You can use a newtype, which will have a constructor in the source, but will be identical at runtime
17:09:30 <atomx> But I need to redefine them, otherwise I cannot continue ...
17:09:38 <atomx> The idea is that I made a test
17:09:59 <atomx>     No instance for (Show (M Int)) arising from a use of `print'
17:10:05 <atomx> and I get this error
17:10:18 <atomx> I understand that I cannot do a print on a type.
17:10:26 <atomx> I managed to print the data
17:10:41 <atomx> so, I need to convert the code from type to using data
17:10:52 <merijn> atomx: The problem is that you're trying to apply "print" to a value of type 'M a', i.e. a function
17:11:02 <merijn> Functions are not printable, therefor it's complaining
17:11:04 <atomx> yes
17:11:20 <atomx> I understand I cannot define print on that
17:11:27 <atomx> ... such that to see the result
17:11:27 <merijn> atomx: If you use a newtype you can implement show for the newtype
17:12:01 <atomx> type M a = State -> (a, State)
17:12:01 <atomx> type State = Int
17:12:08 <atomx> My type is defined so
17:12:20 <atomx> How can I define show for this type ?
17:12:31 <shachaf> You can't, because it's not a type.
17:12:32 <atomx> it is a type that is a function abstraction
17:12:35 <shachaf> It's just a synonym.
17:12:40 <merijn> type doesn't define a type, just an alias. Use "newtype M a = M (State -> (a, State)"
17:12:41 <atomx> ok
17:12:54 <atomx> is there a way to solve the problem in haskell?
17:12:55 <merijn> Then "instance Show (M a) where {- code here -}"
17:16:11 <atomx> now I see
17:16:22 <atomx> I managed to define the newtype
17:16:27 <atomx> I still have errors
17:16:50 <aspidites> is it possible to use ghc extensions that allow for nicer syntax without forcing clients to have to import those same extensions in order to use the syntax?
17:16:56 <aspidites> https://gist.github.com/aspidites/c0351f53196fcff0f712
17:17:28 <aspidites> feel free to interpret that as me asking the wrong question. Basically, i'd like to take as much of the syntactic clutter out of a file meant to describe decks
17:17:55 <aspidites> i suppose when i'm compiling the decks i could make sure that the appropriate extensions are enabled before its interpretted?
17:19:16 <merijn> aspidites: 1) No and 2) Dear god that would be awful
17:19:28 <merijn> aspidites: and 3) perhaps you should take a different approach :)
17:19:39 <merijn> aspidites: This looks like a job for quasiquoters
17:22:36 <aspidites> I thought about quasiquoters, but I don't understand how that's any better. Still using extensions, and if I understand correctly, that wouldn't be as safe as it would (I think) check at runtime, rather than compile time
17:22:48 <merijn> aspidites: Wut? No
17:22:57 <atomx> How can I define show : <instance Show (M a) where ... ??? ... >>
17:23:00 <atomx> for this type
17:23:07 <atomx> newtype M a = M(State -> (a, State))
17:23:07 <atomx> type State = Int
17:23:38 <merijn> aspidites: QuasiQuoters are functions that take a String and return a haskell expression/pattern/whatever, they're run *at compile time* and thus if they produce "wrong" output it'll be a compile error
17:24:09 <aspidites> Oh. Well what do the error messages look like for a bad parse?
17:24:12 <merijn> aspidites: Basically, anytime you want to take a String and parse it into something, but do so at compile time, you probably want quasiquoting
17:24:25 <aspidites> nm, i'll just google for that
17:24:30 <merijn> aspidites: You can do arbitrary IO in the Q monad (the quasiquotation monad)
17:24:39 <merijn> So you can do whatever custom error reporting you want
17:25:08 <merijn> aspidites: Look at this short intro: https://www.fpcomplete.com/user/marcin/quasiquotation-101
17:25:32 <ketcat> atomx, how do you want to show the function?
17:26:08 <merijn> aspidites: Although you should probably read a short TH intro too
17:26:11 <atomx> It does not matter. I just want to show clearly the values inside it.
17:26:23 <aspidites> i guess i'm concerned with *meaningful* error messages. Something that points to which line failed to parse, rather than something like "This big chunk didn't compile, but I can't tell you where or why."
17:26:27 <atomx> Whatever form of output, just to see what's inside
17:27:29 <ketcat> atomx, there's no general way of printing a function. You could define your own Show instance that outputted the value for a few interesting inputs
17:27:55 <atomx> I understand that.
17:28:01 <atomx> but I do not know the syntax
17:28:02 <merijn> aspidites: Right, but as I said you can do arbitrary IO at compile time while parsing :)
17:28:11 <aspidites> anyway, why is what I did "God awful". I knew writing it that it was probably a bad idea, but to a novice, it superficially looks like i'm replacing two ghc extensions with another two (TH and QQ)
17:28:13 <merijn> aspidites: So you can write whatever fancy error reporting you desire
17:28:23 <atomx> I cannot defineit ; the compiler throws errors all the time
17:28:41 <merijn> aspidites: I didn't say *that* was godawful, I said that "automatically enabling it in the code of users" was god awful
17:28:53 <ketcat> atomx, oh. instance Show a => Show (M a) where show (M fun) = "M(0)=" ++ show (fun 0) ++ "; M(1)=" ++ show (fun 1)
17:29:02 <merijn> aspidites: The last thing you want is libraries arbitrarily changing the universe you live in without you noticing :)
17:30:18 <aspidites> Ah. Moreso I just want to ensure that they can pass a "deck file" to a program and the program know which "world" it's supposed to be in without a lot of user intervention
17:30:21 <aspidites> oh well
17:31:52 <atomx> ketcat: Thanks ! It works !
17:31:55 <atomx> great
17:36:20 <khumba> Hmm, I just realized that I stopped receiving haskell@ and -cafe@ ML traffic after the maintenance on Nov 18...  Did this happen to others?
17:52:43 <mitchty> if i import System.IO, what is that named for build-depends in a cabal file
17:53:19 <Clint> mitchty: base
17:54:00 <mitchty> then i'm more confused
17:57:45 <dramforever> Hello everyone. Is there a good tutorial for grapefruit?
17:58:29 <dramforever> I'm interested in it, but I don't know where to start
17:58:51 <dramforever> the haddocks are very complicated
18:04:01 <mhall> hey guys, does cabal install with the `-j` option make things faster somehow?
18:04:24 <shachaf> Yes, if it can build multiple packages that don't depend on each other in parallel.
18:04:47 <shachaf> You'll see something like "Building X. Building Y. Installing X. Installing Y."
18:04:57 <mhall> shachaf: ah, thanks. i knew it had something to do with parallelism...is there a reason why it's not the default behavior i wonder?
18:05:21 <cschneid> is the built in time lib good enough to use? I need to do dates, without much care for time
18:05:43 <dramforever> parallel stuff aren't always faster
18:11:25 <torpet_> I am using http://ghcformacosx.github.io/
18:11:32 <torpet_> How can I install Test.HUnit?
18:13:20 <dramforever> torpet_: do you have cabal? (try typing that in terminal)
18:13:27 <torpet_> yup
18:13:49 <dramforever> that means yes? (I'm not a native English speaker)
18:13:59 <torpet_> yes :)
18:14:38 <dramforever> torpet_: first cabal update, then cabal install HUnit
18:15:09 <benzrf> torpet_: dramforever: fyi the cabal command comes from the package "cabal-install"
18:15:14 <benzrf> the cabal package itself is just a library
18:15:21 <torpet_> ok thanks
18:15:23 <torpet_> worked fine
18:15:24 <dramforever> yup :)
18:15:36 <torpet_> :P
18:15:55 <dramforever> the cabal update thing doesn't display it's progress
18:16:34 <dramforever> torpet_: fyi go to http://hackage.haskell.org and use the search there
18:16:56 <dramforever> then cabal install <package name> to install your package
18:22:05 <torpet_> thank you
18:22:17 <torpet_> are there local mirrors of hackage or is there only this single repos?
18:27:20 <merijn> @where hackage
18:27:20 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
18:27:23 <merijn> hmmm
18:27:33 <merijn> luite has a mirror, but I forget the URL
18:31:45 <hiptobecubic> What's the normal cross-platform way to get a monotonically increasing clock?
18:31:48 <benzrf> merijn: didnt they used to be in the logs
18:31:50 <torpet_> Ok well the default is fine for now. Thought there are tons of mirrors in each country
18:32:42 <torpet_> Is it possible to sort a list of tuples [(type deriving enum, Integer)] firstly by Integer
18:32:53 <torpet_> and then, by retaining the Integerorder, by the type deriving enum
18:33:08 <merijn> torpet_: I don't think there's more mirrors, mostly because hackage is tiny
18:33:16 <merijn> I think all of hackage is like a few hundred MB
18:33:22 <jle`> you can't really sort compare Enum's
18:33:26 <jle`> if they aren't Ord
18:33:31 <torpet_> they are
18:33:47 <jle`> ah, well that would be the more relevant thing to say :)
18:33:49 <torpet_> they derive show, ord, enum and eq
18:33:54 <torpet_> yeah lol my fail sorry
18:33:56 <jle`> :t sortBy
18:33:57 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
18:34:12 <jle`> :t sortBy (comparing snd)
18:34:14 <lambdabot> Ord a => [(a1, a)] -> [(a1, a)]
18:34:19 <jle`> :t sortBy (comparing snd <> comparing fst)
18:34:20 <lambdabot> (Ord a1, Ord a) => [(a1, a)] -> [(a1, a)]
18:34:56 <jle`> > sortBy (comparing snd <> comparing fst) [(5,3),(2,3),(6,1),(6,7)]
18:34:57 <lambdabot>  [(6,1),(2,3),(5,3),(6,7)]
18:35:02 <hiptobecubic> getPOSIXTime will do, probably
18:36:59 <gfixler> :t <>
18:37:00 <lambdabot> parse error on input ‘<>’
18:37:08 <gfixler> :t (<>)
18:37:09 <lambdabot> Monoid m => m -> m -> m
18:37:12 <jle`> it's mappend
18:37:15 <gfixler> ah, right
18:37:17 <jle`> > "hello" <> "world"
18:37:18 <lambdabot>  "helloworld"
18:37:59 <gfixler> that was a nice solution - easier than LYAH's Ordering instance of Monoid in chapter 11
18:39:15 <jle`> well, it does use the Monoid instance of Ordering
18:40:55 <gfixler> jle`: took me a moment to see it
18:41:05 <jle`> :)
18:41:35 <gfixler> I need more drills
18:41:47 <gfixler> like worksheets with 25 mappend-solvable problems only
18:41:59 <gfixler> for all the little things in Haskell
18:42:33 <hiptobecubic> gfixler, that would be interesting actually
18:43:00 <hiptobecubic> Just a battery of fluency practice questions
18:43:26 <gfixler> hiptobecubic: exactly - there are small problems in groups of a couple to a few, and larger problems to work through
18:45:11 <torpet_> I've been trying to understand what mappend does, but I don't get it
18:45:22 <jle`> torpet_: it's different for every instance
18:45:37 <jle`> kind of like (==), etc.
18:46:08 <jle`> for Ordering, it does a sort of lexical comparison
18:46:14 <gfixler> :t mappend
18:46:15 <lambdabot> Monoid a => a -> a -> a
18:46:22 <jle`> > LT <> EQ
18:46:23 <athan> :t (++)
18:46:23 <lambdabot>  LT
18:46:23 <lambdabot> [a] -> [a] -> [a]
18:46:31 <gfixler> take 2 as and make 1 a out of them
18:46:40 <hiptobecubic> gfixler, indeed
18:46:53 <jle`> like in a dictionary, if the next letter is "less" than the next, the entire thing is "less"
18:46:57 <gfixler> I think of it as smooshing - probably not a good thought
18:47:02 <hiptobecubic> gfixler, have you this? https://www.haskell.org/haskellwiki/Typeclassopedia#Monoid
18:47:03 <jle`> > LT <> GT
18:47:04 <lambdabot>  LT
18:47:13 <athan> gfixler: The important part are the properties of Monoids
18:47:25 <jle`> > EQ <> LT
18:47:27 <lambdabot>  LT
18:47:28 <athan> namely identity and associativity
18:47:35 <jle`> if the first letters are compared and they're equal, then you look at the next one.
18:47:37 <hiptobecubic> > mempty :: Ordering
18:47:38 <lambdabot>  EQ
18:47:40 <gfixler> hiptobecubic: haven't - keep getting a bit into typeclassopedia and then forgetting to go back :(
18:47:47 <jle`> LT <> _ = LT
18:47:49 <jle`> GT <> _ = GT
18:47:53 <jle`> EQ <> x = x
18:47:55 <hiptobecubic> gfixler, it was written to answer these questions i think
18:48:03 <hiptobecubic> Or it's just a spectacular coincidence
18:48:09 <hiptobecubic> either way, i recommend it
18:48:37 <jle`> the Monoid instance for (a -> b) will apply the `a` to both functions, and then (<>) the result
18:48:39 <gfixler> hiptobecubic: it's high on my list, in theory; I just keep completely forgetting about it for some reason
18:48:47 <jle`> > (show <> show) 5
18:48:48 <lambdabot>  "55"
18:48:48 <athan> > "foo" <> "bar"
18:48:50 <lambdabot>  "foobar"
18:48:50 <hiptobecubic> gfixler, now's a good time :)
18:49:07 <jle`> > ((show . (+3)) <> show) 10
18:49:09 <lambdabot>  "1310"
18:49:11 <gfixler> hiptobecubic: I need to parallelize my brain - so much input from this Haskell world
18:49:21 <jle`> > (reverse <> (show . length)) "hello"
18:49:23 <lambdabot>  "olleh5"
18:49:34 <jle`> > (reverse <> take 3) "hello"
18:49:36 <lambdabot>  "ollehhel"
18:49:42 <athan> jle`: So the monoid instance is like &&&?
18:49:48 <athan> er... :S
18:49:52 <jle`> it's like liftA2 (<>)
18:50:13 <athan> oh wait okay
18:50:14 <hiptobecubic> jle`, i always forget that Monoid a => (-> a) (right?) is a monoid
18:50:16 <jle`> (f <> g) x = f x <> g x
18:50:25 <jle`> hiptobecubic: close. watch your kinds :)
18:50:28 <athan> because <> :: String == ++
18:50:34 <hiptobecubic> balls
18:50:53 <jle`> so yeah, the definition of (<>) for functions is `f <> g = \x -> f x <> g x`
18:51:13 <jle`> > (comparing snd) (1,2) (3,4)
18:51:15 <lambdabot>  LT
18:51:26 <athan> It's probably an alternative, hiptobecubic
18:51:28 <jle`> comparing lets you compare two values by first applying a function to them
18:51:46 <jle`> > (comparing snd) (1, 2) (3, 2)
18:51:47 <lambdabot>  EQ
18:51:50 <jle`> > (comparing fst) (1, 2) (3, 2)
18:51:51 <lambdabot>  LT
18:52:03 <jle`> > (comparing snd <> comparing fst) (1, 2) (3, 2)
18:52:04 <lambdabot>  LT
18:52:32 <athan> :t <|> :: (a -> r) -> (b -> r) -> b -> r
18:52:33 <lambdabot> parse error on input ‘<|>’
18:52:41 <athan> :t (<|>) :: (a -> r) -> (b -> r) -> b -> r
18:52:42 <lambdabot>     Couldn't match type ‘a1’ with ‘b1’
18:52:43 <lambdabot>       ‘a1’ is a rigid type variable bound by
18:52:43 <lambdabot>            an expression type signature: (a1 -> r1) -> (b1 -> r1) -> b1 -> r1
18:52:46 <athan> :S
18:52:51 <athan> :t (<|>)
18:52:52 <lambdabot> Alternative f => f a -> f a -> f a
18:52:55 <benzrf> athan: sure you dont want (<>)
18:53:03 <athan> ?:(
18:53:03 <lambdabot> Maybe you meant: wn v rc pl id do bf @ ? .
18:53:14 <athan> :t (<>) :: (a -> r) -> (b -> r) -> b -> r
18:53:15 <lambdabot>     Couldn't match type ‘a1’ with ‘b1’
18:53:15 <lambdabot>       ‘a1’ is a rigid type variable bound by
18:53:15 <lambdabot>            an expression type signature: (a1 -> r1) -> (b1 -> r1) -> b1 -> r1
18:53:25 <athan> :t (<>) :: (a -> r) -> (a -> r) -> a -> r
18:53:26 <lambdabot>     No instance for (Monoid r1) arising from a use of ‘<>’
18:53:26 <lambdabot>     Possible fix:
18:53:26 <lambdabot>       add (Monoid r1) to the context of
18:53:39 <athan> :t (<>) :: Monoid r => (a -> r) -> (a -> r) -> a -> r
18:53:40 <lambdabot> Monoid r => (a -> r) -> (a -> r) -> a -> r
18:53:59 <athan> :t (<|>) :: Monoid r => (a -> r) -> (b -> r) -> b -> r
18:54:00 <lambdabot>     Could not deduce (a1 ~ b1)
18:54:00 <lambdabot>     from the context (Monoid r)
18:54:00 <lambdabot>       bound by the inferred type of
18:54:19 <athan> :t (<|>) :: Monoid r => (a -> r) -> (a -> r) -> a -> r
18:54:21 <lambdabot>     Could not deduce (Alternative ((->) a1))
18:54:21 <lambdabot>       arising from a use of ‘<|>’
18:54:21 <lambdabot>     from the context (Monoid r)
18:54:26 <jle`> you know, you can pm lambdabot :)
18:54:34 <athan> Sorry :(
18:59:08 <jle`> :t (<>) `asAppliedTo` (undefined :: a -> b)
18:59:09 <lambdabot> Monoid b => (a -> b) -> (a -> b) -> a -> b
18:59:17 <jle`> :t (<>) `asAppliedTo` (comparing snd)
18:59:18 <lambdabot> Ord a => ((a1, a) -> (a1, a) -> Ordering) -> ((a1, a) -> (a1, a) -> Ordering) -> (a1, a) -> (a1, a) -> Ordering
19:01:38 <RyanGlScott> Is there a way to look up a data instance constructor's type roles using Template Haskell?
19:03:55 <merijn> I don't think TH supports roles yet?
19:06:55 <RyanGlScott> merijn: It does as of template-haskell-2.9.0.0 http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#t:Role
19:08:07 <RyanGlScott> The problem is that reifyRoles only works on type constructors, so trying to determine phantom types in data instances might be impossible.
19:20:13 <zq> holy shit has anyone tried reading the source to opaleye
19:29:35 <hiptobecubic> i'm sure it's delicious
19:29:52 <hiptobecubic> Why is the monad transformer for Either ErrorT instead of EitherT?
19:31:33 <hiptobecubic> edwardk has written an EitherT it seems, but what's the deal there? It seems like that should have been the original. Why introduce error?
19:31:39 <merijn> hiptobecubic: Because there's two (or more) possible ways to transform EitherT and ErrorT is more semantic?
19:32:28 <merijn> hiptobecubic: For example, should the error value be: 1) the first Left 2) the last Left or 3) aggregate all Left's?
19:32:52 <merijn> I'm not sure what the laws say, but I remember people disagreeing
19:32:57 <shachaf> Look at the Monad instance.
19:33:00 <hiptobecubic> Sure, but that applies to a huge number of instances. Why is anything implemented the way it?
19:33:03 <hiptobecubic> it is*
19:33:29 <nshepperd> last time I read about this I think I was advised that EitherT is the way to go
19:34:52 <nshepperd> and that ErrorT was a mistake
19:34:53 <shachaf> I repeat my suggestion to look at the Monad instance.
19:35:09 <hiptobecubic> christ that's a lot of dependencies :D
19:35:11 <shachaf> instance (Monad m, Error e) => Monad (ErrorT e m)
19:35:14 <geekosaur> I would not say it was a mistake; it was a specific common use case
19:35:22 <geekosaur> that happens to not be yours, perhaps
19:35:45 <geekosaur> the problem was the riginal EitherT was in fact the current ErrorT but claimed to be EitherT
19:36:13 <geekosaur> (well, actually a defective ErrorT, but in basic behavior closer to ErrorT)
19:36:18 <goglosh> should I get hscurses or nanocurses?
19:36:56 <nshepperd> well, ErrorT provides a 'useful' definition of fail, through the (Error e) constraint
19:42:01 <merijn> goglosh: My advice, neither
19:42:07 * hackagebot text-show 0.3.1.0 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-0.3.1.0 (ryanglscott)
19:42:18 <merijn> goglosh: I would recommend vty + vty-ui for writing "curses-like" terminal UI
19:42:33 <merijn> curses is a Lovecraftian horror
19:42:45 <geekosaur> goglosh: "curses" was so named for a reason
19:42:49 <geekosaur> avoid if possible
19:51:44 <goglosh> merijn vty? I'll check that out
20:02:15 <dramforever> difference between C ans hs: C code built incrementally = a lot of weird mess, haskell code built incrementally = elegant, neat solution
20:02:24 <dramforever> and*
20:06:27 <stephenmac7> Is >>= return . or liftM considered better style?
20:07:46 <jle`> i've seen liftM more often, for cases where fmap is not available
20:08:05 <jle`> hopefully we don't have to be having this question in a year :)
20:10:12 <orion> Can the associates types within a class be exported?
20:18:14 <merijn> orion: They should be by default, I think
20:23:49 <TallerGhostWalt> ls
20:36:04 <prinsen> I have now moved my ECMA-262 interpreter into its own git repo. Could someone take a look at it before I mail it on Haskell cafe? https://github.com/fabianbergmark/ECMA-262
20:44:10 <prinsen> Anyone?
20:45:19 <benzrf> ecma more like eczema
20:45:47 <zq> not cool to belittle someone's work, mate
20:45:57 <zq> in-/directly
20:46:58 <Cale> prinsen: cool :)
20:47:13 <prinsen> Cale: thanks :) took about 6 weeks
20:47:30 <Cale> dat Interpret.hs
20:47:30 <prinsen> 8,3 k lines
20:48:12 <zq> interpret.hs froze my friedfox :<
20:48:16 <zwer> stephenmac7 (>>= return .) is code smell, IMO. fmap or liftM when needed
20:49:35 <prinsen> zq: clone it then :)
20:52:01 <dmwit> Cool, text-show looks handy.
20:52:05 <dmwit> I've wished for it many times.
20:52:57 <darkroom> Hello! This is my first time on here because I have a solution to a problem That i think is dirty does anyone want to give it a go?
20:53:25 <darkroom> Using Data.Matrix functions to perform a hadamard product
20:53:36 <Cale> darkroom: post something on lpaste.net or somewhere like that and we can all have a look if you want
20:53:46 <darkroom> k
20:54:54 <stephenmac7> zwer: Got it.
20:55:02 <stephenmac7> Never saw liftM until today
20:55:10 <stephenmac7> Or, I didn't really get it
20:55:18 <Cale> darkroom: Hadamard product would just be elementwise (*), right?
20:55:20 <darkroom> http://pastebin.com/kjmkWU8p
20:55:23 <darkroom> yep!
20:55:27 <geekosaur> liftM is just fmap for Monads that are missing Functor
20:55:32 <darkroom> my solution is a bad solution
20:55:45 <stephenmac7> geekosaur: It did look like I could have used fmap instead
20:55:51 <geekosaur> next ghc makor release that should no longer matter
20:55:56 <geekosaur> *major
20:56:02 <stephenmac7> Why not just get rid of liftM?
20:56:11 <Cale> If this is the right Data.Matrix: http://hackage.haskell.org/package/matrix-0.3.4.0/docs/Data-Matrix.html#v:elementwise
20:56:19 <dmwit> darkroom: Where is Matrix from?
20:56:24 <geekosaur> because there is a lot of code that uses it because it's not allowed to assume that Monad-s are Functor-s.
20:56:30 <stephenmac7> Guess it makes it clearer what instance the writer was thinking about
20:56:33 <Cale> stephenmac7: Because it gives you an easy way to implement fmap
20:56:37 <geekosaur> in ghc 7.10 that changes, but that won't automagically rewrite all existing code
20:56:49 <darkroom> *facepalms* how did i miss that
20:56:57 <Cale> stephenmac7: You can write  instance Functor MyMonad where fmap = liftM
20:56:58 <dmwit> Cale: Man, those two names are terrible. They should be unsafeElementwise and unsafeUnsafeElementwise. =P
20:57:15 <stephenmac7> Cale: That's nice, I guess
20:57:17 <geekosaur> and yes, for any existing Monad-s that are not already Functor-s, they can use liftM to quickly implement fmap to come into compliance with 7.10
20:57:28 <darkroom> and dmwit what cale posted
20:57:42 <darkroom> anyway thanks for the help :)
20:58:00 <stephenmac7> So, should I use liftM or fmap when writing code
20:58:13 <zwer> fmap when you can liftM when you have to
20:58:22 <dmwit> How lazy are you?
20:58:27 <stephenmac7> > liftM (+ 1) (Just 5)
20:58:29 <lambdabot>  Just 6
20:58:32 <stephenmac7> That just looks bad
20:58:37 <geekosaur> right now it is not strictly incorrect to define a Monad which is not a Functor, but your hand will be slapped. all Monad-s should be Functor-s, and you should use fmap
20:58:48 <nolrai66> Damn, the roman-numeral package is printing 3 as "LI", i.e. is treating it as if L was a symbol for 2.
20:58:53 <dmwit> Use fmap unless you are so lazy that you don't want to write (Functor m, Monad m) instead of just Monad m. ;-)
20:58:55 <nolrai66> Very weird.
20:58:57 <stephenmac7> geekosaur: What's with the -s?
20:59:04 <recursion-ninja> stephenmac7: fmap succ (Just 5)
20:59:09 <jle`> stephenmac7: use fmap
20:59:10 <geekosaur> if for some reason you must make use of a Monad that isn't a Functor, or you are writing polymorphically in Monad, you use liftM
20:59:12 <zwer> n some cases you have to use liftM though, if you are working with Monad m => m
20:59:14 <recursion-ninja> > fmap succ (Just 5)
20:59:16 <lambdabot>  Just 6
20:59:19 <jle`> stephenmac7: if you can
20:59:21 <zwer> m a
20:59:36 <zq> will 7.10 have typelits
20:59:44 <stephenmac7> dmwit: If I'm lazy... 7.10 will fix it
20:59:58 <geekosaur> 7.8 already has them to some extent, you just can't do much with them iirc
21:00:02 <jle`> sometimes you will write a function like foo :: Monad m => m a -> m b -> m blah
21:00:03 <stephenmac7> recursion-ninja: Didn't know succ existed
21:00:08 <jle`> in this case, you can't use `fmap`
21:00:09 <stephenmac7> > succ 1
21:00:10 <lambdabot>  2
21:00:11 <geekosaur> (typelits)
21:00:13 <dmwit> > succ <$> Just 5
21:00:15 <lambdabot>  Just 6
21:00:19 <recursion-ninja> :i succ
21:00:21 <jle`> because you can't guaruntee that `m` will be both an instance of Monad *and* an instance of Functor
21:00:27 <geekosaur> no :i in lambdabot
21:00:29 <geekosaur> use ghci
21:00:29 <dmwit> :t succ
21:00:30 <lambdabot> Enum a => a -> a
21:00:34 <jle`> it's like saying foo :: Ord a => a -> a
21:00:40 <jle`> you can't use (+) on your `a`
21:00:49 <prinsen> Could someone clone the repo and verify that they can run a simple program?
21:00:53 <jle`> because you are guarunteed that the Ord a => a is also a Num by coincidence
21:00:54 <dmwit> jle`: Not with that attitude.
21:01:07 <jle`> :)
21:01:11 <recursion-ninja> stephenmac7: succ & pred are from the Enum typeclass, they are quite nifty for countably finite types
21:01:12 <stephenmac7> jle`: But can you when it's 7.10?
21:01:24 <jle`> 7.10 won't let you be able to (+) Ord's
21:01:32 <stephenmac7> > data A = A | B deriving (Enum, Show); succ A
21:01:34 <lambdabot>  <hint>:1:1: parse error on input ‘data’
21:01:45 <jle`> the problem is that there is no "proof" that the Ord a that you are given is also a Num a
21:01:48 <stephenmac7> jle`: But fmap on Monad
21:01:51 <dmwit> ?let data A = A | B deriving (Enum, Show)
21:01:53 <lambdabot>  Defined.
21:01:54 <dmwit> > succ A
21:01:55 <lambdabot>  B
21:02:02 <jle`> right now, there is no "proof" that a Monad m you are given is also a Functor m, by coincidence
21:02:03 <stephenmac7> dmwit: Nice
21:02:05 <recursion-ninja> stephenmac7: baller huh?
21:02:13 <jle`> howerver, in 7.10, Monad will be rewritten so that the proof is built-in to the typeclass
21:02:20 <jle`> so you will be able to do such a thing.
21:02:21 <stephenmac7> Right, that's what I'm saying
21:02:24 <dmwit> stephenmac7: Yes, in 7.10, class Functor m => Monad m
21:02:45 <stephenmac7> Why wasn't that done from the beginning?
21:02:49 <dmwit> mistake
21:03:11 <jle`> i think when Monad was first put out there, there was no Functor typeclass to do such a thing with
21:03:15 <zwer> IIRC Monad was created before Functor
21:03:17 <stephenmac7> Someday, Haskell will have to say: forget breaking code, let's do this right.
21:03:33 <stephenmac7> Really? Functor sounds simpler
21:03:42 <stephenmac7> :t fmap
21:03:43 <recursion-ninja> That was all before Yorgey enlightened us with the Typeclassopedia
21:03:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:03:55 <stephenmac7> :t (>>=)
21:03:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:04:15 <orion> Does this code look ugly?: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Suite.hs
21:04:16 <stephenmac7> Nevermind, the complexity seems about the same
21:04:34 <jle`> when it comes to inventing things, the order is often pretty illogical :)
21:04:49 <dmwit> orion: You know about the crypto-api package?
21:04:59 <jle`> historically, at least
21:05:01 <zwer> stephenmac7 you were right, Functor is simpler
21:05:18 <recursion-ninja> orion: It's short but *not* ugly
21:05:23 <stephenmac7> zwer: It's really the instances of Monad, not Monad itself, that are confusing
21:05:49 <orion> dmwit: I know it exists. Is there more I should know?
21:05:57 <recursion-ninja> orion: record names should be more verbose to enable self-documenting code
21:06:04 <jle`> stephenmac7: i think the point was that the mathematical structure of functors can be said to be simpler than monads
21:06:15 <stephenmac7> Makes sense
21:06:16 <nolrai66> I have a hard time remembering when I found Monad confusing. Though the Applicative instance of State is a bit wonky. Feels backwards.
21:06:25 <recursion-ninja> orion: I would not be able to infir what the mean as of right now
21:06:29 <jle`> they're more generalized
21:06:31 <orion> recursion-ninja: Cool. I am a little worried about those polymorphic constants.
21:06:40 <jle`> monad implies more structure than functor
21:06:40 <stephenmac7> The weirdest monad I've found so far is ((->) r)
21:06:44 <prinsen> Cale: pls :)
21:06:48 <stephenmac7> Reader
21:06:57 <stephenmac7> Or, actually the applicative is weirder
21:07:11 <dmwit> orion: nope =)
21:07:28 <mietek> http://a.disquscdn.com/uploads/mediaembed/images/1463/5597/original.jpg
21:07:29 <mietek> This is pretty amazing.
21:07:47 <mietek> Has everyone seen http://www.fsd.it/fonts/pragmatapro.htm yet?
21:07:52 <recursion-ninja> orion: does dh stand for Diffie-Hielman?
21:07:56 <orion> recursion-ninja: yes
21:08:17 <orion> Search Results
21:08:17 <orion> Diffie–Hellman
21:08:21 <mietek> A font with special characters for Haskell, and even Agda!
21:08:49 <orion> (Not Diffie-Hielman)
21:08:53 <mietek> Makes me want to consider actually using Unicode for coding.
21:09:08 <stephenmac7> How could you type those?
21:09:14 <mietek> or hm... would that be necessary? I'm confused.
21:09:27 <recursion-ninja> orion: I'd verbosify that. I could only guess because I have a crypto background. Someone else, including you a year from now, might be taken aback by the naming. Make future readers of your code, including you, have to think as little as possible
21:09:28 <stephenmac7> It's not like an IME where it has a nice pronunciation
21:09:37 <mietek> Since they're ligatures, perhaps a smart enough editor just displays them, even if they're just ASCII characters.
21:09:48 <stephenmac7> mietek: Makes sense
21:09:51 <stephenmac7> Much better
21:11:35 <mietek> Yeah, that's what https://github.com/i-tu/Hasklig says
21:12:42 <schell> does it sound feasible to use the Cont monad to set up an event system?
21:13:16 <stephenmac7> Don't even get how this works...
21:13:17 <stephenmac7> > (+) <$> (+1) <*> (+1) $ 1
21:13:19 <lambdabot>  4
21:13:41 <orion> recursion-ninja: I see.
21:14:13 <haasn> stephenmac7: Applicative instance for ((->) r)
21:14:14 <geekosaur> stephenmac7, it's using the primitive reader monad aka ((->) e)
21:14:23 <geekosaur> applicative instance thereof, yes
21:14:37 <haasn> mietek: Now port it to Terminus :p
21:15:14 <stephenmac7> haasn: Yes, but I don't get the Applicative instance
21:15:15 <mietek> I'll get right on that...
21:15:37 <zwer> stephenmac7 <$> is fmap, so you just need to get <*>
21:15:50 <stephenmac7> Yes
21:15:58 <stephenmac7> Does <*> take precedence over <*> ?
21:16:04 <stephenmac7> <$> I mean
21:16:29 <jle`> it's easier for me to understand Applicative instances in terms of liftA1, liftA2, liftA3...
21:16:38 <jle`> liftA0
21:16:40 <haasn> No, that's parsed as ((+) <$> (+1)) <*> (+1)
21:16:51 <jle`> stephenmac7: you understand what liftA1 (a.k.a. fmap) does, right?
21:17:08 <haasn> > (+) <$> (*1000) <*> (*2) $ 1 -- mietek any clearer?
21:17:10 <lambdabot>  1002
21:17:14 <zwer> > (+) <$> Just 10 <*> Just 20
21:17:15 <lambdabot>  Just 30
21:17:23 <haasn> > (+) <$> (*1000) <*> (*2) $ x
21:17:24 <lambdabot>  x * 1000 + x * 2
21:17:27 <zwer> ^^ perhaps that is easier to understand
21:17:40 <stephenmac7> jle`: Yes
21:17:49 <haasn> sorry, that was for stephenmac7 not mietek
21:17:55 * mietek nods
21:18:34 <Buttons840> is there an existing function that would do something like: f "aab" = [('a', 2), ('b', 1)] ?  i haven't found anything on hoogle
21:18:51 <zwer> the result of (+) <$> Just 10 is a Maybe Function, and <*> then applies a Maybe function to a Maybe value
21:18:54 <stephenmac7> zwer: So, it evaluates in order
21:19:05 <stephenmac7> <$> then <*>
21:19:06 <zwer> yes
21:19:16 <jle`> stephenmac7: it takes one (k :: b -> c), and one (f :: a -> b), and returns a function that applies f and then k
21:19:26 <jle`> now let's imagine liftA2
21:19:33 <zwer> > Just (+) <*> Just 10 <*> Just 20
21:19:35 <lambdabot>  Just 30
21:19:57 <jle`> liftA2 :: (b -> c -> d) -> (a -> b) -> (a -> c) -> (a -> a -> d)
21:20:00 <stephenmac7> jle`: I have to go now. I'll ask about it tomorrow
21:20:00 <jle`> hm
21:20:07 <jle`> that was put rather weirdly
21:20:13 <jle`> i'd probably start over
21:20:22 <stephenmac7> Okay. Can't finish talking now though
21:20:24 <stephenmac7> Thanks for the help
21:20:26 <stephenmac7> Bye
21:20:28 <jle`> np
21:20:31 <jle`> i'm going to talk to the air
21:20:50 <jle`> liftA1 o f = \x -> o (f x)
21:20:58 <jle`> liftA2 o f g = \x -> o (f x) (g x)
21:21:08 <jle`> liftA3 o f g h = \x -> o (f x) (g x) (h x)
21:21:29 <jle`> liftA4 o f g h k = \x -> o (f x) (g x) (h x) (k x)
21:21:59 <jle`> that's the spirit of the Applicative instance for (->) a
21:22:20 <jle`> liftA0 o = \x -> o
21:22:53 <jle`> and you can use the fact that (<*>) = liftA2 ($) to transfer the intuition to the (<*>) formulation
21:33:33 <dspies> Can adding strictness to a program ever reduce the number of entries for a cost center?
21:34:03 <dspies> hello?
21:35:36 <dspies> > [1]
21:35:37 <lambdabot>  [1]
21:36:00 <MP2E> yes it can, generally posting the relevant snippet of code is the fastest way to get an answer here
21:36:32 <jle`> > take 0 [undefined..]
21:36:33 <lambdabot>  []
21:36:41 <lpaste> dspies pasted “Needs strictness to profile” at http://lpaste.net/115840
21:36:52 <jle`> what does that default to?
21:37:02 <jle`> oh, probably ()
21:37:14 <dspies> This code takes too long to profile unless I add strictness annotations in a lot of places
21:37:26 <dspies> However, to run it normally
21:37:31 <dspies> I don't need any strictness
21:38:02 <dspies> The input is here: http://challenge.csc.kth.se/2013/challenge-2013.tar.bz2
21:38:14 <dspies> It's the last instance for the cargame problem
21:39:00 <dspies> I'm trying to get it to run in under 5 seconds on https://open.kattis.com/problems/cargame
21:39:20 <schell> in my sleep deprivation i accidentally wrote “Typebabble” in place of Typeable, lol
21:41:26 <jle`> :P
21:41:28 <dspies> MP2E can you explain how adding strictness can decrease entries?
21:41:52 <jle`> can we have an IsUnit typeclass
21:42:10 <jle`> class IsUnit a where fromUnit :: a
21:42:30 <jle`> and {-# LANGUAGE OverloadedUnit #-}
21:42:36 <jle`> where () :: IsUnit a => a
21:42:43 <jle`> mk
21:43:01 <jle`> brb submitting patch
21:43:07 <MP2E> well, sometimes laziness can build up a bunch of thunks before evaluation, an easy example would be foldl vs foldl'. If you sum a large list with foldl you will get a ton of unevaluated thunks until the foldl recursion is finished, and then it will cram everything together. With foldl', the list stays in constant memory
21:43:22 <schell> jle`: overloading your unit sounds like a bad idea
21:43:29 <jle`> naaaaaah
21:43:31 <jle`> :)
21:43:42 <MP2E> it's odd that you only need strictness when profiling though, dspies, I'm thinking perhaps a list is being fused by a GHC optimization, and that GHC optimization isn't active during profiling
21:43:45 <schell> :)
21:43:58 <MP2E> that or strictness analysis made it strict
21:44:03 <MP2E> and didn't make it strict for profiling
21:44:07 <dspies> fused?
21:44:42 <dspies> by the way, I have no idea why I need strictness
21:44:51 <MP2E> List/stream fusion is a neat optimization that GHC can do sometimes when it sees you build and destroy a list for a calculation, as an example, consider making a list of all prime numbers up to 2 million then summing them
21:45:02 <MP2E> instead of actually making the intermediate list
21:45:08 <MP2E> it often will optimize it away
21:45:13 <dspies> i don't think that's happening
21:45:17 <dspies> it's not running out of memory
21:45:22 <dspies> it's just taking longer to run
21:45:39 <dspies> and it seems to be calling the buildchain function a lot more without strictneess
21:45:46 <dspies> (with profiling)
21:46:04 <dspies> *buildChain
21:46:51 <dspies> More than it should, but I don't know why
21:47:29 <dspies> Should I post the non-strict version?
21:48:00 <srhb> dspies: Yep.
21:48:03 <MP2E> sure, that'd make it easy to compare
21:48:31 <lpaste> dspies pasted “Without strictness” at http://lpaste.net/115841
21:51:35 <dspies> By the way, is there a list function something like (forceWHNF l = foldr seq l l)
21:51:44 <dspies> ?
21:52:41 <geekosaur> Control.Deepseq?
21:52:47 <dspies> That's too deep
21:53:00 <dspies> I only want each element of the list evaluated to WHNV
21:53:05 <dspies> *WHNF
21:53:28 <geekosaur> I think there are intermediate ones as well; it's the implementation details behhind Control.Parallel.Strategies which provides various levels of sequencing
21:54:28 <geekosaur> mm, maybe not. Control.Parallel.Strategies should allow you to do it though
21:54:29 <dspies> If you try to deepseq a WordChain, it has to traverse an exponential number of branches (since each child is contained multiple times), which is why I can't use deepseq here
21:55:10 <dspies> I don't think Kattis has Control.Parallel.Strategies
21:55:19 <dspies> It doesn't matter, it's just one line
21:58:31 <Royalgambino> Hi everyone!
21:58:33 <dspies> Has anyone else tried running it?  Do you get the same results?
21:58:50 <dspies> I'm on GHC 7.8.3
22:00:01 <srhb> Royalgambino: Hey there.
22:03:17 <dspies> > let kimberling = let interleave (x : xs) ys = x : interleave ys xs in interleave [1..] kimberling in kimberling
22:03:19 <lambdabot>  [1,1,2,1,3,2,4,1,5,3,6,2,7,4,8,1,9,5,10,3,11,6,12,2,13,7,14,4,15,8,16,1,17,9...
22:03:38 <adarc> anyone ever compile/run code using diagrams in fpcomplete IDE? wondering if you cando that in their IDE. every time I try to run this example diagrams code, it times out etc.
22:04:01 <trap_exit> is it possible to get fat on a high fiber diet?
22:04:41 <haasn> adarc: Try asking in #diagrams
22:04:49 <adarc> thnx
22:05:03 <begriffs> How do I convert Int to Word16 (truncating the number if necessary)?
22:05:13 <hodapp> trap_exit: I suspect so, yes.
22:05:20 <dspies> does fromIntegral work?
22:05:27 <trap_exit> wrong channel, sorry
22:05:30 <trap_exit> was meant for #fitness
22:06:06 <begriffs> dspies: it does indeed, thank you
22:06:45 <begriffs> I wonder why Integral isn't automatically Num as well.
22:06:55 <hodapp> trap_exit: regardless, you're going to get answers that are more mythology than science.
22:07:23 <srhb> hodapp: Wrong channel. :-)
22:08:40 <geekosaur> begriffs, it is
22:08:48 <geekosaur> it's just hidden
22:08:57 <geekosaur> Integral is Real, and Real is Num
22:09:15 <haasn> Real is such a terrible name.
22:09:53 <srhb> geekosaur: Isn't it the other way around? Num a, Ord a => Real a?
22:10:16 <srhb> Oh wait, that's what you said.
22:10:17 <trap_exit> i like Real
22:11:07 <nkar> Peaker: (reading the log) roconnor has a blogpost showing how to implement the y combinator, see r6.ca/blog
22:11:28 <zq> oh my god
22:11:40 <zq> is there a hep8 analogue to pep8
22:12:03 <srhb> zq: I doubt it. Why?
22:12:06 <haasn> zq: What's the PEP8?
22:12:17 <nkar> haasn: style guide
22:12:23 <haasn> Ah.
22:12:38 <geekosaur> PEP is python standards. PEP8 is the decreed style
22:12:40 <zq> people using tabs, using tabs at 8 spaces, mixing tabs and spaces
22:12:52 <haasn> There's https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md but it's hardly official
22:12:53 <srhb> zq: It's well accepted that you shouldn't use tabs in Haskell, ever.
22:12:53 <zq> like holy shit, i thought we were past this level of shenanigans
22:12:56 <haasn> It's more like “one way of doing things”
22:12:58 <geekosaur> there is no formal decreed style for haskell, and styles vary a lot within the constraints of layout
22:12:58 <srhb> :P
22:13:28 <zerkms> Guys, I'm trying to learn haskell and chose this kata as a task to implement: https://github.com/giorgiosironi/diamond-kata  and here is my quick-and-dirty implementation: http://pastebin.com/k4DpEy6X
22:13:31 <srhb> We should just disallow them in the parser... Or at least issue a massive warning. I wonder if that has ever been suggested to HQ...
22:13:41 <haasn> I think allowing tabs is fine.
22:13:43 <zq> srhb: yeah well until a more official decree is issued, counterexamples will abound
22:13:57 <zq> haasn: no no no no no no no no no no no no
22:14:02 <zerkms> keeping in mind it's my first haskell code ever after reading the book for 2 days - what would you suggest me (as an improvement or the worst sins I made in that code)
22:14:22 <srhb> zerkms: take n . repeat = replicate n
22:14:30 <zq> stuff like https://github.com/joeyh/propellor/blob/master/src/Propellor/Git.hs
22:14:39 <haasn> I would agree with a default warning stating that tabstops in Haskell are always 8 characters, though
22:14:45 <zq> just when i'm about to contribute, i head over and see the style guide
22:15:01 <zerkms> srhb: I knew I missed it thanks
22:15:22 <srhb> zerkms: I also would probably always use the String synonym over [Char] but meh
22:16:13 <haasn> zerkms: take n $ repeat x  =  replicate n x
22:16:21 <zerkms> haasn: yep, already fixed thanks
22:16:29 <zerkms> as well as s/[Char]/String
22:16:41 <zerkms> any other non-idiomatic stuff?
22:16:46 <haasn> zerkms: ‘tail’ is bad practice in general, since it's not a total function
22:16:49 <haasn> > tail []
22:16:51 <lambdabot>  *Exception: Prelude.tail: empty list
22:17:36 <haasn> perhaps something like mirror (x:xs) = reverse xs ++ [x] ++ xs  would be cleaner
22:17:38 <zerkms> haasn: I see, so I should pattern-match xs instead
22:17:58 <haasn> (with mirror [] = [] being the other case)
22:18:08 <zerkms> yep
22:18:39 <haasn> zerkms: instead of iterating from 0 to h and indexing over letters, I would directly iterate over letters
22:18:59 <LordBrain> is there a ghc command that simply tests for the presence of a module?
22:19:10 <haasn> It's also a good idea to avoid (!!) in most cases, list indexing is a slow thing since they're fundamentally like lazy linked lists
22:20:56 <HeladoDeBrownie> It's nice to think of lists as sort of "portable for loops"
22:21:41 <geekosaur> for loops as data, is how I usually put it
22:21:43 <haasn> zerkms: I would start solving this by defining map (`replicate` ' ') [1,3..]
22:21:52 <zerkms> "perhaps something like mirror (x:xs) = reverse xs ++ [x] ++ xs  would be cleaner" --- that function does: "abc" -> "abcba"
22:22:14 <haasn> And then combining that with ['A'..'Z'] or whatever other alphabet I want to use to generate an arbitrarily large triangle lazily
22:22:56 <haasn> zerkms: as far as I can tell that's equivalent to your version
22:23:22 <haasn> Oh, wait, yours would return "cbabc" ?
22:23:39 <zerkms> "abc" -> "abcba" is the correct
22:23:53 <zerkms> reverse xs ++ [x] ++ xs would produce cbabc from what I see
22:23:57 <haasn> Oh, yes
22:24:06 <zerkms> so I literally need to pick the last element
22:24:28 <zerkms> probably a match for 1 element and > 1 would save from tail issue then?
22:24:46 <haasn> That's bothersome. I would rather define my triangle upside down and use my version of “mirror”, but that's probably also just me
22:25:08 <haasn> Oh, but that's also bothersome
22:26:21 <haasn> You could forgot the intermediate list altogether and use something like:  diamond [] = return (); diamond (x:xs) = do print x; diamond xs; print x
22:26:26 <haasn> s/forgot/forgo/
22:26:47 <haasn> With a third case for a single element
22:26:55 <haasn> (In between the two I showed)
22:27:03 <zerkms> yes
22:27:47 <haasn> Oh well. It's not like performance matters at all here
22:31:43 <haasn> I wonder who started the Haskell trend of aligning the { ; and }, resp. [ , and ] for multi-line do-blocks / lists / whatever
22:31:45 <haasn> Was it spj?
22:32:36 <code_pod> Could somebody guide me about Information Flow and implementation of it in Haskell?
22:32:58 <wei2912> code_pod: dont ask to ask just asl
22:32:59 <wei2912> ask*
22:33:40 <code_pod> Well, first of all I searched the Haskell repo but couldn't find the implementation. Where can I find it? wei2912
22:34:04 <wei2912> code_pod: i'm not certain about that
22:35:22 <code_pod> Another question is that what is 4w declassifications? I did read about it but did not get it completely. (4w: What, who, where, and when)
22:55:37 <recursion-ninja> what/who is spj?
22:58:19 <sivteck> Simon Peyton Jones
22:58:34 <sivteck> @google Simon Peyton Jones
22:58:37 <lambdabot> http://research.microsoft.com/en-us/people/simonpj/
22:58:37 <lambdabot> Title: Simon Peyton Jones - Microsoft Research
22:58:59 <zerkms> guys, Real world haskell OR thinking functionally in with haskell (for a beginner)
22:59:06 <zerkms> s/in//
22:59:46 <quantum-mechanic> didnt you consider learn you a haskell ?
23:00:33 <zerkms> quantum-mechanic: I have re-read the chat recently and changed my mind
23:00:37 <zerkms> quantum-mechanic: I trust you
23:00:49 <haasn> read all three and then decide
23:01:04 <zerkms> decide what I should have been reading ?
23:01:12 <zerkms> it reminds me that xkcd about c++ in 21 days
23:01:28 <quantum-mechanic> that was abstruse goose iirc
23:02:23 <quantum-mechanic> zerkms: pick one and get going with it
23:03:13 <quantum-mechanic> dont worry too much about "the right book "
23:03:19 <zerkms> quantum-mechanic: I have actually checked "thinking functionally with hs" and I find it a bit sketchy
23:03:20 <srhb> RWH is a bit annoying because of the outdated bits, imo, but I guess that was mostly a problem because everything was hard beginning.
23:03:44 <zerkms> sometimes it just gives something without explanation or too simplified version
23:04:14 <quantum-mechanic> sometimes (especially in haskell) you think something is complicated but it really is simple
23:04:20 <zerkms> srhb: yep, that's why I picked the "thinking functionally ..." - just because it's newer
23:04:31 <srhb> I don't know the book. Perhaps it's nice. :)
23:05:24 <quantum-mechanic> zerkms ,yeah perhaps it is nice , ive not read the book either
23:06:31 <ab9rf> for me leaning haskell was more an effort to unlearn three decades of bad practices
23:07:00 <zerkms> ab9rf: that happened for me when I started with clojure
23:07:15 <zerkms> now it's more like I'm looking for haskell syntax things and idioms
23:07:18 <srhb> We all know that learning Haskell makes you a worse person. Or at least worse at coping with everything else. :-)
23:07:57 <zerkms> btw, also checked ocaml basics few days ago. It surprised me in a good way
23:10:03 <zerkms> out of curiocity, what guys do you write in hs?
23:10:13 <simpson> Games.
23:10:27 <simpson> That remains my main Haskell focus; pretty much everything else is Python/Monte.
23:10:46 <srhb> zerkms: Mostly web apps and some convenience things for myself.
23:10:57 <zerkms> sounds promising
23:11:19 <zerkms> (what I mean that is that it looks like HS is generic enough)
23:11:22 <srhb> I'd like to get into scientific number stuff at some point. I think Haskell has a future there.
23:11:46 <srhb> zerkms: Oh yes, very generic. Lack of tooling and libraries is sometimes a bit annoying, but writing C bindings is luckily super easy.
23:13:22 <ddellacosta> I'm failing to understand why a function defined with guards is giving me a "Non-exhaustive patterns in function" exception when I'm using otherwise--shouldn't the otherwise catch everything that falls through?
23:14:36 <heatsink> Is pattern matching used in the function signature?
23:14:38 <ddellacosta> oh, nevermind, I'm looking in the wrong place which I would have realized if I'd thought about it a minute longer...guess I have to embarrass myself on #haskell to figure stuff out. :-)
23:14:48 <ddellacosta> or, what heatsink said ^
23:16:31 <Peaker> zerkms: I'm writing everything in Haskell (from shell scripts to type inference and an IDE) :)
23:16:58 <srhb> ddellacosta: Embarrassing yourself on #haskell is 9001 times faster than rubberducking. :-)
23:16:59 <zerkms> Peaker: when you use it for shell-scripting, what are the target artifacts?
23:17:06 <Peaker> I sometimes think "If I write this script in Python, it'll be more accessible for my less Haskell inclined coworkers". and then mid-way through the script: "arrg.. Python can't even do that?! switching to Haskell"
23:17:13 <zerkms> Peaker: do you compile or deploy scripts?
23:17:22 <ddellacosta> srhb: good point. :-)
23:17:35 <Peaker> zerkms: Depends on whether they need to be fast. If not: I just #!runhaskell them
23:17:52 <srhb> A fast haskell interpreter would be nice, though.
23:18:03 <Peaker> yeah ghci is terribly slow
23:18:16 <Peaker> python beats it significantly even!
23:18:23 <srhb> :'(
23:18:31 * ddellacosta , who has been using Clojure for the last few years, sobs listening to this conversation
23:18:49 <srhb> ddellacosta: What's wrong with Clojure?
23:18:53 <zerkms> start time
23:18:57 <srhb> If I had to target the JVM, that would probably be my goto
23:18:58 <srhb> Ah.
23:19:01 <zerkms> don't expect it to start faster than 4-5 seconds
23:19:03 <ddellacosta> srhb: oh, I love it, but yeah, what zerkms says ^
23:19:49 <L8D> omg that's it
23:19:54 <L8D> that's what we need
23:20:03 <L8D> that's what has been holding this community back
23:20:14 <L8D> WE NEED A FAST INTERPRETER
23:20:33 <L8D> "no linking required"
23:20:39 <zerkms> as an experiment in FP I wanted to implement a tiny command line tool and chose clojure initially, since I've had some experience with it and it is a really nice language
23:21:07 <zerkms> I implemented may be 50% of functionality and found that: 1. it starts for 7 seconds 2. it consumes 170Mb of RAM
23:21:28 <zerkms> so I decided to choose something else. The candidates were ocaml and HS. So here I am :-)
23:21:50 <ddellacosta> It's got its good qualities but...yeah. :-/
23:21:57 <srhb> zerkms: Good for you! The dark side beckons... :-)
23:22:16 <L8D> So what's the big appeal of ML languages then?
23:22:30 <L8D> I mean... I've written literally one line of OCaml code
23:22:36 <srhb> L8D: Haskell is ML'y.
23:22:44 <L8D> (and it was fixing a typo in a comment)
23:22:45 <zerkms> and? I found ocaml very similar to HS
23:23:07 <L8D> What makes it different from Haskell? That's what I'm interested in
23:23:11 <srhb> Lack of typeclasses.
23:23:19 <srhb> (way) better module system
23:23:22 <L8D> Is it still pure and lazy?
23:23:27 <zerkms> I only decided to switch to HS because of 3rd party libraries and community (after a short research)
23:23:34 <srhb> I've only worked in strict MLs.
23:24:33 <srhb> I got frustrated when they bailed on the whole purity thing when it comes to IO, though
23:24:38 <srhb> "We're pure, as long as..."
23:24:44 <srhb> :(
23:24:48 <simpson> TBF, that's also how Haskell works.
23:25:15 <srhb> simpson: As long as you don't stick unsafePerformIO anywhere, but that's a fair warning.
23:25:49 <L8D> I'm pretty sure you can easily work around impure IO
23:25:58 <L8D> and just do it the same way you do in Haskell
23:26:04 <srhb> It's just fugly. Does this code do side effects? No idea.
23:26:14 <L8D> you shouldn't be using 'IO' more than once in your code
23:26:26 <simpson> srhb: Or unsafeInterleaveIO, or unsafeIOToST, or any non-total function. And don't get started on exceptions, because you can only stop if you remember to unmask them. :3
23:26:29 <L8D> err.... twice maybe if you're building an executable
23:26:31 <srhb> I know the Haskell idioms, L8D. The big deal is visibility.
23:26:49 <srhb> simpson: The situation is way better in Haskell than anywhere else.
23:26:57 <srhb> Well, at least in the ML world that I know of.
23:27:34 <L8D> You should just create your own types and representations and use those over IO, and have that one function that will turn it into IO
23:27:44 <simpson> srhb: Haskell's definitely the best in the ML family.
23:27:57 <L8D> I assume you would do the same in MLs, so you shouldn't have much of a problem
23:28:08 <srhb> I disagree, but whatever.
23:28:16 <L8D> (when it comes to impure IO)
23:52:32 <zerkms> guys, how much HS has changed between 6.8 and 7.6 (or just 6.x and 7.y)?
23:52:37 <zerkms> I mean syntactically
23:52:53 <srhb> zerkms: Syntactically? Almost nothing.
23:52:58 <zerkms> okay
23:53:18 <zerkms> rwh uses 6.8 wheras it's 7.6 in ubuntu trusty I'm using
23:53:33 <srhb> Yeah, 6.8 is pretty ancient. It's not a syntax thing though.
23:54:54 <homesitter> if I wanted to contribute to hackage, is "cabal init" enough for that package ?
23:56:01 <codygman> Can anyone explain to me why this error is happening, how the types work, and how to fix it? http://lpaste.net/115842
23:57:02 <shachaf> Maybe #snapframework would know.
23:57:09 <shachaf> That doesn't look like a complete GHC error at any rate.
23:58:54 <schell> I’m running into a roadblock using extensible-effects - does anyone have any dirty tricks for storing an arbitrary Eff r () action for later use?
23:59:27 <schell> i’m trying to write an event system for a game and i don’t yet know what kinds of actions will need to be performed
23:59:45 <schell> but i need to create them in one function and execute them in another
23:59:52 <srhb> codygman: Whole error please. :)
