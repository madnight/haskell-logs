00:10:30 <Tokenizer> hi, can someone please help with the mapTree function (line #11) of this post? it's mean to map a function f to a tree ... http://pastie.org/private/hpiz4r8x8iinnor83dsjq
00:12:13 <Adeon> you have parentheses where they should not be but otherwise it looks like it's correct
00:13:10 <Adeon> you have mapTree(f b) which is probably not what you want, you want mapTree f b which would be ((mapTree f) b) if we write out the parentheses
00:14:09 <Adeon> when you write mapTree (f b) it attempts to use mapTree as if took only one argument
00:14:13 <Adeon> but your mapTree takes two
00:14:30 <Adeon> the function and the tree it's working on
00:14:55 <Tokenizer> Adeon: thanks so much
00:42:28 <pkoerbitz> I am looking for some help debugging a ghc-mod issue
00:43:26 <pkoerbitz> As soon as I include 'mtl' in my build-depends list I get a 'cannot satisfy -package-id' error
00:43:43 <pkoerbitz> ghc-pkg check and 'cabal build' work fine
01:06:09 * hackagebot alarmclock 0.2.0.5 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.2.0.5 (dcturner)
01:11:12 <halldoro> Hi, I am a beginner in haskell and I have a question. I want to create a list [x, f x, f.f x, f.f.f x, f.f.f.f x, ...] using a recursive function
01:11:22 <halldoro> but I dont know how
01:12:28 <tdammers> halldoro: decompose the problem
01:12:44 <tdammers> halldoro: given x and f, how do you generate the first item of the list?
01:13:00 <halldoro> x
01:13:02 <tdammers> right
01:13:19 <Laquendi> > iterate (+1) 1
01:13:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
01:13:21 <tdammers> now, given x and f, how do you generate the second item
01:13:37 <halldoro> I would likt to have a function that reads     genList f x
01:13:46 <halldoro> that returns a list
01:13:50 <tdammers> yes, easy
01:14:03 <halldoro> huh
01:14:07 <tdammers> given a previous list element and f, how do you generate the next element?
01:14:30 <halldoro> type will be genList :: (x -> x) -> x -> [x]
01:14:35 <halldoro> righth
01:14:38 <tdammers> yes, we'll get there
01:15:03 <tdammers> so if I give you the "current" list elemnt and a function, how do you generate the next list element?
01:15:26 <halldoro> so genList f x = [ x, genList f x] ...
01:15:26 <halldoro> no
01:15:34 <tdammers> take a step back
01:15:52 <tdammers> how do you generate the n+1th list element when you have the nth element?
01:16:04 <halldoro> apply f
01:16:10 <tdammers> exactly
01:16:18 <tdammers> so we have x:f x:...
01:16:31 <halldoro> hmm
01:16:50 <tdammers> now here's the trick with recursion: you start by assuming that you already know the answer to the "..." part
01:17:02 <tdammers> so actually, you could write genList as:
01:17:15 <tdammers> genList f x = x:unknown
01:17:50 <tdammers> where 'unknown' is the part where we pretend we already know how to generate it
01:18:09 <halldoro> ok, I am almost there
01:18:15 <tdammers> so, any ideas how we could find 'unknown' with what we have?
01:18:30 <tdammers> (hint: 'what we have' includes 'genList' itself)
01:18:35 <halldoro> yes
01:18:39 <halldoro> so
01:19:04 <halldoro> genList f x = x:(f genList f x)
01:19:11 <tdammers> almost
01:19:16 <halldoro> hmm
01:19:40 <halldoro> genList f x = x:(f (genList f x))
01:20:07 <tdammers> what does genList f (f x) evaluate to?
01:20:23 <tdammers> (using our definition that involves 'unknown')
01:21:20 <halldoro> genList f (f x) will be (f x ):unknown
01:21:28 <tdammers> bingo
01:21:56 <tdammers> so if we insert that into our *first* equation for genList f x...
01:22:09 <halldoro> yes
01:22:30 <tdammers> genList f x = x:f x:unknown
01:22:56 <tdammers> can you do the substitution?
01:23:06 <halldoro> genList f x = x:(f . head genList f x)
01:23:13 <tdammers> much simpler
01:23:31 <tdammers> let me change the names of our unknowns, because we have two of them
01:23:34 <tdammers> we have:
01:23:43 <tdammers> genList f x = x:unknown1
01:23:57 <halldoro> ok
01:24:05 <tdammers> genList f (f x) = f x:unknown2
01:24:29 <tdammers> and we want to find unknown1 such that genList f x = x:f x:unknown2
01:24:44 <halldoro> hmm
01:24:56 <tdammers> genList f x = x:(f x:unknown2) -- is an alternative, but equivalent notation
01:25:12 <halldoro> yes ok
01:25:35 <tdammers> so in order to get rid of unknown2, we need to find something to substitute for f x:unknown2
01:25:55 <tdammers> and we have an equation that provides exactly that
01:26:30 <halldoro> genList f (f x) ...
01:26:33 <tdammers> yes
01:26:47 <tdammers> and that makes genList f x = ???
01:27:34 <halldoro> genList f x = x:genList f (f x)
01:27:39 <halldoro> err
01:27:49 <tdammers> no, it's perfect
01:27:54 <tdammers> let's try it
01:28:11 <tdammers> > let genList f x = x:genList f (f x) in genList (+2) 1
01:28:13 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
01:28:36 <tdammers> > let genList f x = x:genList f (f x) in genList (++ "woop") "And... "
01:28:38 <lambdabot>  ["And... ","And... woop","And... woopwoop","And... woopwoopwoop","And... woo...
01:28:39 <halldoro> wow that was nice
01:29:35 <halldoro> that is an infinite loop
01:29:44 <apo_> Now do one with 'untz' and 'wub'
01:29:44 <halldoro> very nice
01:30:04 <halldoro> I am still struggling with the recursive function definitions,
01:30:14 <halldoro> this was really helpful
01:30:15 <tdammers> yes, it's an infinite loop, but Haskell's lists are lazy, so you can still define and use them
01:30:16 <halldoro> many thanks
01:30:18 <tdammers> np
01:30:38 <tdammers> oh, and, next exercise; look through Prelude etc. and find an existing function that does this
01:31:33 <halldoro> tdammrs - thank you for teaching me the basics of haskell. I hope I can pay it forward some day -- goodby for now
01:31:42 <tdammers> np
01:36:10 * hackagebot elm-compiler 0.14 - Values to help with elm-package, elm-make, and elm-lang.org.  http://hackage.haskell.org/package/elm-compiler-0.14 (EvanCzaplicki)
01:36:12 * hackagebot elm-package 0.2 - Package manager for Elm libraries  http://hackage.haskell.org/package/elm-package-0.2 (EvanCzaplicki)
01:41:10 * hackagebot elm-make 0.1 - A build tool for Elm projects  http://hackage.haskell.org/package/elm-make-0.1 (EvanCzaplicki)
01:41:12 * hackagebot elm-repl 0.4 - a REPL for Elm  http://hackage.haskell.org/package/elm-repl-0.4 (EvanCzaplicki)
01:41:14 * hackagebot elm-reactor 0.2 - Interactive development tool for Elm programs  http://hackage.haskell.org/package/elm-reactor-0.2 (EvanCzaplicki)
01:41:23 <taruti> Pondering type families, IO and ST: given a "class Mut t where type M fixme...; mut :: t -> M s Int" I want some instances to be limited to IO and some instances work in all STs. There may be multiple instances per monad. Ideas?
01:46:14 <jfischoff> what do the ellipses stand for
01:47:11 <jfischoff> is type function M :: * -> * -> * ? and always has a second argument of Int?
01:47:22 <jfischoff> I just want to make sure I am reading it correctly
01:48:41 <taruti> jfischoff: some instances will be able to provide a "mut :: t -> IO Int" some, "mut :: forall st. t -> ST s Int", and trying to avoid making it a multiparameter typeclass and use families instead.
01:50:01 <taruti> the traditional MArray way would be to have "class Mut t m where mut :: t -> m Int" "instace Mut Foo IO where mut ..." "instance Mut Bar (ST s) where mut ..." but want to do it with families instead.
01:52:09 <tero-_> what is a typical cause for Haskell program crashing in "double free or corruption (!prev): 0x0000000003967d20"?
01:52:31 <jfischoff> I think will want to use: https://hackage.haskell.org/package/primitive-0.5.4.0/docs/Control-Monad-Primitive.html#t:PrimState
01:54:07 <tdammers> tero-_: my guess would be misbehaving FFI code
01:54:32 <taruti> jfischoff: yes, I am using primitive, but that is not enough :)
01:54:47 <solrize> @pl \x -> x < 5
01:54:47 <lambdabot> (< 5)
01:54:55 <solrize> @pl \x -> x > 1 && x < 5
01:54:56 <lambdabot> liftM2 (&&) (> 1) (< 5)
01:55:15 <solrize> wat
01:55:21 <mmmm> Is there a generic toJSON method?
01:56:03 <jfischoff> yes
01:56:07 <tdammers> mmmm: yes
01:56:50 <tdammers> mmmm: three ways, actually - you can use deriveJSON on your own types, or you can perform operations on Aeson's Value type directly, or you can use Generic
01:58:33 <tero-_> tdammers: ok. it occurs randomly. I'll have to look into how to debug FFI code
02:00:43 <tdammers> tero-_: using non-threadsafe C libraries in a threaded Haskell program is a popular cause
02:00:50 <tdammers> been bitten by that myself
02:02:26 <osa1> any tips&tricks to dump stg of one module only, using cabal?
02:03:53 <mmmm> tdammers: So if I derive Generic then there is an "instance ToJSON Generic where..." ?
02:04:32 <mmmm> or you get the idea.. not quite that type
02:05:24 <tdammers> mmmm: http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html#g:12
02:08:04 <bryanedds> In the state monad, is there a way to pull out a value computed from s without binding s into the scope of the do expression?
02:08:27 <bryanedds> I'm trying to avoid accidentally using state versions of s in my state monad usage.
02:08:37 <bryanedds> *stale versions of state
02:08:43 <pantsman> bryanedds: use gets instead of get?
02:10:13 <bryanedds> looks like that will work
02:10:34 <bryanedds> :t gets
02:10:35 <lambdabot> MonadState s m => (s -> a) -> m a
02:11:09 <bryanedds> that doesn't change the state, does it?
02:11:49 <bryanedds> ah, I suppose not
02:12:04 <bryanedds> is there a good way to find the source code of that function?
02:13:41 <pantsman> bryanedds: I use hoogle
02:13:55 <bryanedds> I haven't used that yet
02:14:04 <bryanedds> guess it's high time I familiarize myself with it :)
02:14:28 <pantsman> the instance hosted at https://www.fpcomplete.com/hoogle is good - it has more packages indexed than haskell.org/hoogle
02:18:19 <pantsman> or rather, I use the source links in the haddocks, and hoogle to find the haddocks :)
02:20:44 <bryanedds> ah, so I didn't understand why there was an 'a' type variable in state until I looked at gets!
02:21:05 <taruti> any place with examples of type families and ST?
02:21:11 * hackagebot hasql-postgres 0.7.3 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.7.3 (NikitaVolkov)
02:22:02 <JavaSucksMan> Hello?
02:22:13 <jfischoff> hello
02:22:16 <JavaSucksMan> I have a Monad question.
02:22:23 <jfischoff> ask it
02:22:47 <bryanedds> I'm not so sure why it's called 'gets' tho
02:22:48 <haasn> (This is also not a challenge for language bashing)
02:22:50 <bryanedds> any ideas
02:22:50 <JavaSucksMan> What is a good example of a type constructor that isn't also a Monad?
02:22:53 <haasn> s/challenge/channel/
02:23:09 <haasn> JavaSucksMan: data Example a = Example
02:23:17 <haasn> Okay, that one *is* a monad
02:23:22 <haasn> data Example a = Example Int
02:23:44 <tdammers> haasn: it's a monad, but it's only a Monad if you say so
02:24:02 <jfischoff> yes
02:24:11 <haasn> Exercise: Prove that Example can't be made a Monad
02:24:53 <jfischoff> try to write bind
02:25:17 <tdammers> the second Example, right?
02:25:23 <haasn> Yes
02:25:30 <jfischoff> yeah you can’t get an a, right?
02:25:34 <tdammers> 'cause the first one is rather trivial :)
02:25:38 <jfischoff> sure
02:25:50 <haasn> I think the first one might actually not be a Monad if you care about the distinction between Example and _|_
02:25:53 <haasn> But I'm not sure
02:26:06 <jfischoff> yeah I scrolled up
02:26:21 <jfischoff> I don’t see it, the obvious instance
02:26:24 <jfischoff> same problem
02:26:39 <haasn> jfischoff: The idea is that you can define _ >>= _ = Example
02:26:43 <JavaSucksMan> Why wouldn't you just use data Example = Example
02:26:49 <tdammers> the first Example is just a black hole
02:26:57 <JavaSucksMan> That doesn't seem like a good example....
02:26:59 <tdammers> so yeah, _ >>= _ = Example
02:27:03 <haasn> But this violates return 0 >>= \x -> case x of 0 -> undefined; 1 -> Example
02:27:23 <haasn> Which should by the monad laws be (\x -> case x of 0 -> undefined; ...) 0
02:27:27 <haasn> Ergo undefined
02:27:31 <haasn> But by definition is Example
02:27:37 <jfischoff> bottom
02:28:05 <haasn> JavaSucksMan: data Foo a b = Foo (b -> a)
02:28:19 * tdammers scratches head
02:28:48 <jfischoff> I don’t think that is in Hask
02:29:15 <jfischoff> actually what do I know
02:29:26 <jfischoff> I was thinking of a free monad of contravariant functors
02:29:55 <haasn> jfischoff: The free monad of a type is not the type itself, either way
02:30:01 <JavaSucksMan> I was hoping for an example from hackage....
02:30:22 <jfischoff> https://hackage.haskell.org/package/transformers-0.4.2.0/docs/Data-Functor-Constant.html
02:30:32 <haasn> JavaSucksMan: https://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad
02:30:38 <haasn> This has some more examples
02:30:54 <jfischoff> also does the bottom instance for Const break some of the monad laws?
02:31:11 <jfischoff> It offends me ;)
02:31:18 <haasn> What instance?
02:42:33 <luite> sinelaw: no
02:44:10 <sinelaw> luite, huh?
02:44:31 <luite> sinelaw: you asked if i generate for .. in with ghcjs
02:44:50 <sinelaw> luite, oh, heh. that was yesterday.
02:45:05 <sinelaw> luite, great, because I think I should just not allow it at all.
02:45:18 <Benzi-Junior> ok I am making a parser that parses and returns a number  so it ends with a "return (read x)" line is there a way to get where in the parse Prelude.read fails ?
02:45:42 <luite> sinelaw: i do allow it, but then it's the user supplying that
02:45:57 <bryanedds> what is the free monad?
02:46:03 <bryanedds> is it complicated?
02:46:38 <sinelaw> luite, I'm ok with not allowing it to the user
02:52:09 <meditans> hi, could I ask a question on diagrams? I would know the type of a function, and ghci tells me one it later complains about.
02:53:05 <lpaste> meditans pasted “What type does seatRowTrail have?” at http://lpaste.net/116153
02:57:20 <sinelaw> meditans, what type does ghc -Wall tell you?
02:58:26 <meditans> sinelaw: when I load the script I pasted in ghci, and ask about the type of seatRowTrails
02:58:59 <meditans> it responds with: seatRowTrail :: (TrailLike t, V t ~ R2) => Int -> Double -> t
02:59:22 <meditans> sinelaw: however, if I paste the signature into the file, ghc/i complains that
02:59:41 <meditans> Illegal equational constraint Diagrams.Core.V.V t
02:59:41 <meditans>                               ~ Diagrams.TwoD.Types.R2
03:00:06 <ClaudiusMaximus> meditans: adding the type suggested by ghci requires a language extension (I used {-# LANGUAGE TypeFamilies #-} but the other suggestion from ghci probably works too)
03:00:18 <ClaudiusMaximus> meditans: i annotated your paste
03:02:07 <meditans> ClaudiusMaximus: you're right. My emacs buffer error was small and I didn't read it all :$
03:02:23 <meditans> ClaudiusMaximus: sorry, but thank you!
03:02:44 <ClaudiusMaximus> meditans: :)
03:07:41 <bernalex> @djinn a -> (a, a)
03:07:41 <lambdabot> f a = (a, a)
03:07:48 <bernalex> does that function exist?
03:07:54 <jle`> join (,) i guess
03:08:05 <bernalex> yeah I know I can use join heh
03:08:06 <jle`> i'm not sure if it exists on its own tho
03:08:09 <jle`> hm
03:08:17 <bernalex> using join is not a big problem (it's what I do), but thought I'd ask
03:08:34 <jle`> i've seen this question asked here a bunch of times and i haven't really seen anything other than that, so :/
03:08:41 <jle`> it would be cool if there was though
03:10:14 <jle`> :t join (&&&) id
03:10:15 <lambdabot> c' -> (c', c')
03:10:16 <jle`> hehe
03:10:25 <sinelaw> ugh
03:12:54 <jle`> a quick scan of the logs shows that join (,) seems to be the best answer this room has seen
03:14:40 <jle`> hm.
03:15:21 <dibblego> @type over both
03:15:22 <lambdabot> Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
03:22:41 <ThreeOfEight> Having a weird issue wie ImpredicativeTypes here: http://lpaste.net/116156
03:22:43 <ThreeOfEight> *with
03:22:48 <ThreeOfEight> Why does this not work?
03:23:35 <ThreeOfEight> GHC somehow refuses to instantiate that universally-quantified type variable
03:37:19 <haasn> Uh oh, impredicative types?
03:37:47 <haasn> I think you should stop using that extension. I thought it was already removed/deprecated
03:38:17 <haasn> (Use an existential datatype instead, if you really want it)
03:39:56 <haasn> (Or a non-existential datatype, really)
03:40:32 <adamse> is a forall like a type lambda?
03:40:36 <augur_> adadad: no
03:40:44 <augur_> er, adamse ^
03:40:49 <haasn> ThreeOfEight: It works if you define a datatype newtype Fun = Fun (forall a. (a,a) -> (a,a))
03:40:55 <haasn> At least on my end.
03:41:01 <augur_> adadad: forall is like ->
03:41:07 <augur_> damnit >_<
03:41:09 <augur_> adamse: ^^
03:41:51 <adamse> hm, but it seems to me that is some kind of function over types, Lambda a . a -> a
03:42:05 <augur_> adamse: not quite
03:42:20 <augur_> adamse: you can think of `forall` as a -> for types, and functions with a `forall` as having a special type-lambda
03:42:43 <augur_> adamse: so imagine this: we have something like so:   \x -> x :: Int -> Int   yes?
03:42:51 <adamse> yep
03:43:26 <augur_> adamse: but notice that the argument is not visible in the type. the argument type is, but the value/parameter isn't visible in the type
03:43:49 <rlp10> If I have a type like "Thing = Thing { blah :: String }", could I replace String by a typeclass, rather than a type?
03:44:12 <augur_> adamse: `forall a. ...` is kind of like writing   `* -> ...`   only where the argument (which is a *, ie a type) is visible
03:44:28 <augur_> adamse: so secretly you can imagine there's a special "type lambda" like this:
03:44:43 <augur_> adamse:    /\a -> \x -> x :: forall a. a -> a
03:45:19 <augur_> adamse: the forall says "give me a type (call it `a` so that its visible in the scope of the forall) and i'll give you an `a -> a`
03:45:46 <adamse> yes, so forall a . a -> a, is a function on types, taking specifiec type T and returning a type T -> T
03:45:59 <augur_> well, no lets be precise
03:46:20 <augur_> just as Int -> Int is not a function, but rather a _type_ of functions
03:46:32 <augur_> so too is `forall a. a -> a` a _type_ of functions
03:47:07 <augur_> but yes, otherwise: its the type of functions which take an argument `a` with is a type, then an argument of type `a`, and returns a value of type `a`
03:47:33 <augur_> but to be clear, again, /\a -> \x -> x is the function, forall a. a -> a is a type of functions
03:48:06 <augur_> the only thing that haskell does with this tho is: you're not allowed to use /\ yourself. only haskell gets to use it
03:48:19 <augur_> thats actually how its implemented, IINM
03:50:48 <augur_> adamse: does that help?
03:53:15 <osa1> how do I get seconds/milliseconds of DiffTime?
03:53:20 <osa1> as Integer
03:53:48 <adamse> augur_: yes
03:56:01 <agundry> rlp10: no, because a typeclass isn't a type ;)
03:56:33 <adamse> augur_: my thought, in the type system a forall expresses abstraction over types, just like a lambda expresses abstraction over expressions
03:56:40 <agundry> rlp10: (more formally, a type like String has kind *, but a typeclass has kind ... -> Constraint)
03:56:47 <agundry> rlp10: what is it you actually want to do?
03:58:15 <augur_> adamse: well again, no, /\ is abstraction over types, \ is abstraction over expressions
03:58:35 <augur_> adamse: forall is merely the *type* of such type abstractions, while -> is the *type* of expression abstractions
03:58:47 <adamse> augur_: the /\ is abstraction over types on the expression level?
03:58:53 <agundry> osa1: you can use toRational to get seconds
03:59:03 <augur_> adamse: yes, /\ is capital lambda: abstraction over types
03:59:41 <augur_> adamse: as in, you could write this:   /\a -> \x -> (x :: a, 1 :: Int)
03:59:45 <adamse> augur_: on the expression level, but on the type level we express that abstraction using forall
04:00:01 <augur_> adamse: and just as 1 :: Int means "1, as in Int", x :: a means "x, as an a"
04:00:18 <rlp10> agundry: Thank you for replying. I want my Thing type to be able to house two different types in one of its attributes (wrong word?). I could use two different constructors and use that type for the thing attribute.
04:00:33 <augur_> adamse: thats correct, just as on the type level we express the abstraction \x -> ... using `->`
04:00:55 <adamse> well using \ and ->
04:01:07 <augur_> adamse: no, there is no \ at the TYPE level
04:01:14 <augur_> \ is a piece of expression-level syntax
04:01:23 <adamse> yes
04:01:25 <augur_> well, more specifically, \ ... -> ... is a mix-fix operator
04:01:37 <augur_> the choice of -> is mnemonic
04:01:56 <waressearcher2> is haskel good for writing games ?
04:02:11 <augur_> adamse: but just as `Int -> Int` is not a function, but rather the type of a function, `forall a. a -> a` is not a function
04:02:14 <waressearcher2> maybe its good as language but what about using it to write games ?
04:02:21 <waressearcher2> anyone tryed ?
04:02:47 <sinelaw> waressearcher2, there are games written in haskell.
04:02:56 <sinelaw> waressearcher2, what kind of game are you talking about?
04:03:17 <waressearcher2> say, very simple 3d FPS
04:03:26 <agundry> rlp10: I'm not quite sure what you mean (perhaps "field" instead of "attribute"?) but are you looking for a polymorphic type, e.g. data Thing a = Thing { blah :: a }?
04:03:35 <sinelaw> waressearcher2, take a look at this page: https://www.haskell.org/haskellwiki/Game_Development
04:03:41 <augur_> adamse: its the same as saying `Int` is not an Int, its a type. `0` is an Int.
04:03:51 <adamse> augur_: I'm not able to express my idea clearly enough, we are talking past eachother
04:03:52 <waressearcher2> also if I use haskel should I write entire game engine or I can use any other engines like OGRE for graphics ?
04:03:57 <augur_> adamse: do you see what im saying? there's a difference between types and expressions
04:04:34 <agundry> rlp10: then the Thing data constructor can take something of any type as an argument
04:04:38 <augur_> adamse: no i think i get your idea, but you're using terminology imprecisely, and unfortunately imprecision in this domain is very very bad
04:04:53 <sinelaw> waressearcher2, for 3d fps there is lambdacube-3d
04:04:57 <sinelaw> http://lambdacube3d.wordpress.com/
04:05:05 <sinelaw> https://github.com/csabahruska/lc-dsl
04:05:14 <augur_> adamse: you're more or less correct, but you keep wanting to describe `forall a. ...` as "kind of a function", but its not. functions are _expressions_
04:05:22 <sinelaw> waressearcher2, demo video https://www.youtube.com/watch?v=JleoASegUlk
04:05:26 <sinelaw> waressearcher2, and the links above
04:06:18 <adamse> augur_: ok, what I want to say perhaps: on the epxression level a function is an abstraction over expressions, on the type level the forall is an abstraction over types
04:07:01 <augur_> adamse: thats.. somewhat true, sure
04:07:06 <augur_> it depends on what you mean by abstraction
04:07:27 <augur_> what we might want to say, to avoid unintended implications, is that both lambda and forall are binders
04:07:30 <adamse> augur_: the box to the right sums ut up: http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Syntax
04:08:20 <augur_> yes, if by "abstraction" you mean "binder" then thats true
04:08:25 <sinelaw> adamse, not sure that forall is equivalent to lambda on types.
04:08:32 <sinelaw> adamse, pretty sure it isn't.
04:08:43 <augur_> sinelaw: it's not. type-level lambdas are a whole other beast
04:08:56 <sinelaw> indeed
04:08:59 <adamse> augur_: I have never use the word binders, in literature abstraction is the word I have come upon
04:09:30 <augur_> adamse: better to use binder, i would argue. it wont lead you astray
04:09:35 <augur_> there are many kinds of binders
04:09:51 <augur_> case and pattern matching are binders, existential quantifiers are binders
04:10:24 <sinelaw> "something that determines the scope and meaning of a name in a syntactic expression"
04:10:38 <sinelaw>  /s/meaning//
04:11:57 <augur_> i hesitate with "abstraction" because it suggests that the usage is some how "more general", but for things like existentials, its not the case at all
04:12:48 <augur_> for existential quantifiers, the exact opposite is true: the binder indicates that there will always be specificity, but you never get to know what the specifics are
04:13:04 <rlp10> agundry: Yes, field was the right word. I think what you're suggesting will work for me. Thanks for your help. :)
04:13:29 <augur_> adamse: consider the type  `exists a. a`  which says "there is some type `a` for which this is an `a`"
04:13:59 <augur_> adamse: for instance,   1 :: exists a. a    and also    "foo" :: exists a. a    and    True :: exists a. a
04:14:32 <augur_> adamse: because its definitely true that there is some type `a` for which 1 :: a, namely, a = Int, etc
04:14:54 <augur_> adamse: i would hesitate to call this "abstraction", however, but it's still a quantifier/binder
04:15:12 <agocorona> The definitive language will have only one  concept: Concept   (joke intended)
04:16:59 <augur_> agocorona: OISC
04:28:08 <Myt> Who can create me here a yahoo account ?
04:28:44 <ehamberg> it would be really nice to edit the text on the Haskell Platform page for OS X to change “10.10 beta” to “10.10”. does anyone know whom to ping?
04:31:34 <alt_ern> Could somebody please give me a hint why I am getting following error:     No instance for (GToJSON (GHC.Generics.Rep RoseTree2))
04:31:34 <alt_ern>       arising from a use of `aeson-0.7.0.6:Data.Aeson.Types.Class.$gdmtoJSON'
04:31:34 <alt_ern>     Possible fix:
04:31:34 <alt_ern>       add an instance declaration for
04:31:34 <alt_ern>       (GToJSON (GHC.Generics.Rep RoseTree2))
04:31:36 <alt_ern>     In the expression:
04:31:38 <alt_ern>       (aeson-0.7.0.6:Data.Aeson.Types.Class.$gdmtoJSON)
04:31:40 <alt_ern>     In an equation for `toJSON':
04:31:42 <alt_ern>         toJSON = (aeson-0.7.0.6:Data.Aeson.Types.Class.$gdmtoJSON)
04:31:44 <alt_ern>     In the instance declaration for `ToJSON RoseTree2'
04:31:55 <alt_ern> I am trying to write JSON parser for RoseTree
04:46:59 <tattsun> hi, i'm creating the server required high-performance. i must use huge array.
04:47:34 <tattsun> is there any way to handle them? i think it's better to use vector instead..
04:48:12 <tdammers> better than *what*?
04:48:34 <Adeon> mutable array? do you mean array as in Data.Array and friends?
04:48:46 <tattsun> sorry, i mean List
04:49:06 <tattsun> i must handle a huge list. but it seems to be slow.
04:50:01 <Adeon> what kind of operations do you perform on this list
04:50:10 <Adeon> you need to choose the data structure that suits your use
04:50:20 <tattsun> actually, i'm creating like mmo server.
04:50:32 <Adeon> if you do large amounts of random access on the list then list won't be fast
04:50:56 <tattsun> for example, [Player], [Enemy]
04:53:53 <Adeon> well if you are interested in performance then you need to consider which operations need to be fast
04:54:03 <Adeon> for a case like this I'd assume you want adding and removing players and enemies to be fast
04:54:09 <Adeon> and picking individual player or enemy to be fast
04:54:22 <Adeon> a data or set structure from Data.Map or Data.Set may be useful
04:54:39 <Adeon> but I can't know exactly how you are going to structure your program
04:56:07 <tattsun> thanks. i want to pick up individual player. so i have to use Data.Map
05:03:52 <ThreeOfEight> haasn: I am rather font of impredicative types
05:04:04 <ThreeOfEight> I successfully did something pretty much exactly like what I want to do here yesterday
05:04:12 <ThreeOfEight> and I don't really know why it works there but not here
05:27:13 <prinsen> If building and installing my package requires several steps (compiling with different flags, and calling external commands), can I do that in cabal?
05:48:38 <McManiaC> what ghc do i need for base >=4.7 ?
05:49:33 <k_bx> prinsen: I would guess no, only in makefile (or whatever)
05:53:28 <geekosaur> McManiaC, I think HEAD (upcoming 7.10)
05:54:36 <geekosaur> mm, maybe not, 4.6.0.1 was in 7.6.3, that would suggest a 7.8 for 4.7
05:55:17 <geekosaur> yeh. 7.8
06:01:49 <athan> Has anyone here had much luck / fun constraining GADT parameters? http://lpaste.net/116162
06:03:43 <prinsen> k_bx: But that does not work if I want to put it on hackage?
06:05:32 <Adeon> prinsen: you can write a custom Setup.hs file, change build-type in .cabal file to Custom and then modify Setup.hs
06:05:53 <Adeon> however, this can be quite tricky and non-straightforward but you should be able to do whatever you need to do
06:06:26 <Adeon> check out Distribution.Simple module in Cabal haddocks if you are going this route
06:07:49 <prinsen> Adeon: ok thanks
06:08:06 <prinsen> Im about to release a VERY cool package
06:08:10 <prinsen> ask me what it is
06:08:57 <moop> what it is
06:09:03 <indiagreen> what it is
06:09:56 <prinsen> Its a TH library that converts Open data tables and JSON schemas into data types, and a HTTP function
06:10:22 <prinsen> So you get typed API calls and decoding of the response
06:11:26 <prinsen> For any API that has an Open Data Table (over 1000)
06:12:20 <lpaste> biglama pasted “Simple example of instance” at http://lpaste.net/116163
06:12:41 <biglama> hi guys, i'm having trouble create a simple instance of a class (see paste above)
06:12:58 <eXeC64> Which operator(s) have a fixity of 5? +/- are 6, and (<$>)/(<*>) are 4.
06:13:10 <biglama> when I use yesno 0, ghci complains, while it works if I change "Int" to "Integer" in the instance declaration
06:13:38 <eXeC64> Int is a type, Integer is a type class
06:13:53 <eXeC64> I think
06:14:01 <geekosaur> no
06:14:23 <geekosaur> Int and Integer are both types
06:14:35 <tdammers> Integral is a typeclass
06:14:36 <eXeC64> Oops, I confused Integer with Num there
06:14:37 <biglama> the example is from LYAH btw
06:14:39 <geekosaur> so what is the "complaint"?
06:14:39 <eXeC64> as Integral
06:14:46 <eXeC64> s/as/ah/
06:15:03 <geekosaur> you should usually include the full error message in the paste when asking questions like this
06:16:32 <lpaste> biglama annotated “Simple example of instance” with “Simple example of instance (annotation)” at http://lpaste.net/116163#a116164
06:16:41 <biglama> geekosaur: here it is
06:16:55 <tdammers> biglama: ghc pretty much tells you what's happening
06:17:13 <tdammers> remember that integer literals are polymorphic in haskell
06:17:14 <geekosaur> ok, defaulting helps you with the Integer one, otherwise it's the fact that numeric literals are polymorphic
06:17:21 <tdammers> i.e., 0 can be Int, or Integer, or Double, or whatever
06:17:26 <MindIsAVortex> Hi there, doing an assignment on parsing for uni. We're told to use Alex and Happy to create our lexer and parser. Anyway, how do I use the output file generated by Alex in haskell?
06:17:39 <tdammers> try yesno (0 :: Int), for example
06:19:31 <k_bx> tdammers: `yesno (0::Integer)` in your case
06:21:15 <ab9rf> MindIsAVortex: alex an dhappy both generate a haskell source file, which you then compile with your preferred haskell compiler.
06:21:21 * hackagebot term-rewriting 0.1.2.1 - Term Rewriting Library  http://hackage.haskell.org/package/term-rewriting-0.1.2.1 (BertramFelgenhauer)
06:23:00 <nshepperd> athan: you left out an 'fmap fst'
06:24:09 <nshepperd> athan: because find returns the matching result, which is an (a, Vector a) in this case
06:24:32 <athan> nshepperd: Oh! that makes sense. Thank you
06:26:54 <biglama> tdammers: so here 0 is Integer, but there is no guarantee otherwise ?
06:26:59 <biglama> in other words, I got lucky ?
06:27:01 <joe9> chrisdone: This is my haskell-init.el for emacs. For some reason, the latest haskell-mode upgrade is failing with this error whenever I press "SPC". error: http://codepad.org/EY26FILJ
06:28:03 <biglama> tdammers: and follow-up, why can't I do something like : instance (Num a ) => YesNo a where
06:28:45 <tdammers> well, what does the compiler tell you?
06:28:50 <biglama> the same thing
06:29:05 <biglama> so i'm confused !
06:29:09 <sinelaw> does anyone have a clue why haste-boot fails with this cryptic error?
06:29:10 <sinelaw> haste-compiler$ haste-boot --local
06:29:11 <sinelaw> haste-boot: cabal: createProcess: runInteractiveProcess: exec: does not exist (No such file or directory)
06:29:14 <joe9> chrisdone: haskell-init file: http://codepad.org/JyWks8w9
06:29:34 <joe9> chrisdone: just want to check if you have any comments.
06:30:42 <biglama> tdammers: wait, the syntax is wrong
06:31:53 <SvenskFisk> Hey guys, I'm trying to learn about functors and I'm a little confused, I have the following code : http://lpaste.net/116165, I sort of understand how the commented lines work, but I'm having a bit of trouble with the uncommented line, can someone explain why it works?
06:32:01 <biglama> tdammers: okay, my question is actually : how can I make an instance which works for both Int and Integer ?
06:32:09 <biglama> should I make two instances ?
06:32:30 <sinelaw> :t (<$>)
06:32:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:32:35 <sinelaw> :t fmap
06:32:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:32:45 <sinelaw> SvenskFisk, ^^  you realize the <$> is just fmap, right?
06:33:23 <c_wraith> biglama: if you can write code that works equally correctly with any instance of Num, why is it a class in the first place?
06:33:53 <SvenskFisk> sinelaw: So if I replaced all the <$> with fmap it would still work?
06:34:11 <sinelaw> SvenskFisk, it will have to be `fmap` because of the infix position
06:34:17 <biglama> c_wraith: it's an exercise to understand how classes and instance work
06:34:39 <c_wraith> biglama: ah.  the answer is "not like that" :P
06:35:05 <c_wraith> biglama: the issue is that your instance would overlap every other instance
06:35:22 <biglama> c_wraith: can you explain how ?
06:36:16 <sinelaw> SvenskFisk, if you understand infix notation, you'll understand <$>
06:36:18 <sinelaw> > let f <@> xs = map f xs in (+1) <@> [1,2,3]
06:36:19 <lambdabot>  [2,3,4]
06:36:20 <c_wraith> biglama: "instance Num a => Foo a" tells the compiler "all types are instances of Foo, but add a Num instance requirement to type resolution"
06:36:49 <sinelaw> SvenskFisk, that code above defines '<@>' to be the same as 'map'. Then it uses it with (+1) and [1,2,3]
06:37:08 <sinelaw> SvenskFisk, <$> is defined in the same way.
06:37:10 <sinelaw> @src (<$>)
06:37:10 <lambdabot> f <$> a = fmap f a
06:37:11 <sinelaw> SvenskFisk, ^^^
06:37:12 <c_wraith> biglama: since classes are open, it can't mean anything else.  There's no guarantee that some other module won't add a Num instance for any specific type
06:38:23 <athan> Hey folks, I've got a strange cabal error happening: lpaste.net/116168
06:38:53 <athan> this is from `cabal repl`. `cabal install` works just fine
06:39:04 <athan> I've tried deleting and re-initializing the sandbox, too :/
06:40:04 <biglama> c_wraith: okay, I think I got it backwards "instance Num a => Foo a" meant that Foo derived from Num
06:40:14 <biglama> c_wraith: but that's the opposite right ?
06:41:52 <c_wraith> biglama: it's a declaration that every type is an instance of Foo (but the instance's definition depends on Num).  Generally (though not always) the sort of problem you're experiencing is the result of overuse of type classes
06:44:35 <biglama> c_wraith: okay, so I should only make an instance for each type (Int and Integer in my case) ?
06:45:10 <c_wraith> biglama: I'm still curious why you need a class at all, rather than just a couple functions.
06:46:04 <biglama> c_wraith: i'm struggling with the concept of instance, so I was experimenting with http://learnyouahaskell.com/making-our-own-types-and-typeclasses#a-yes-no-typeclass
06:49:51 <hodapp> I'm gonna try to figure out rank-N polymorphism again today...
06:50:00 <c_wraith> biglama: ah, yes.  I don't really like that exercise - the class is a bit too ad-hoc.  You kind of see that when you work with it, though.  Having to write a bunch of identical instances for types like Int and Integer is a kind of code smell.
06:50:14 <hodapp> the wiki had an explanation about the N being the number of nested foralls and it made little sense to me
06:50:39 <biglama> c_wraith: okay, so i'm not going to waste any more time over it. Thanks !
06:51:49 <c_wraith> hodapp: are you working on understanding what Rank-N types allow, or what the N means? :)
06:52:42 <hodapp> c_wraith: I was reading https://www.haskell.org/haskellwiki/Rank-N_types and just trying to get past 'About'
06:53:04 <hodapp> (forall a. a -> a) -> (forall b. b -> b)is a Rank-2 type because the latter
06:53:07 <hodapp> forall
06:53:08 <hodapp> ack. mispaste.
06:53:41 <sinelaw> hodapp, the way I understood it was by looking at a function that takes 'id' and applies it to a pair of arguments.
06:53:45 <c_wraith> yes, the latter forall can be floated, but the former cannot.
06:53:47 <sinelaw> hodapp, what type would such a function have?
06:54:03 <sinelaw> ?? -> a -> b -> (a,b)
06:54:03 <lambdabot>  -> a -> b -> (a,b)
06:54:18 <sinelaw> ugh, thanks lambdabot. :\
06:54:25 <hodapp> c_wraith: The Wiki says that the latter forall can be moved to the start, but the former one cannot.
06:54:46 <c_wraith> hodapp: don't worry about that.  Once you understand what the foralls mean, that stuff becomes kind of obvious.
06:55:01 <hodapp> c_wraith: They say 'moved to the start', not 'floated'. So I'm trying to interpret it as "the former one cannot be moved to the start".
06:55:18 <hodapp> c_wraith: and it looks to me like it's already *at* the start.
06:55:38 <sinelaw> hodapp, try writing a function that takes 'id' as a parameter and applies it to two arguments
06:55:45 <sinelaw> or just two values of different types
06:57:01 <c_wraith> I like this example, though it's basically the same...  "foo f = (f (0 :: Int), f (0 :: Double))".  I like that because you can often find yourself in a situation where you want to write something that works kind of like that.
06:57:27 <c_wraith> And getting that to type-check requires rank-n types
06:57:47 <sinelaw> precisely. but it isn't until you try describing the type of that 'foo' that you realize why.
06:58:49 <hodapp> c_wraith: Do you see the "(forall a. a -> a) -> (forall b. b -> b) is a Rank-2 type because the latter forall can be moved to the start but the former one cannot." that I am referencing?
06:59:12 <c_wraith> hodapp: yes.  Don't worry about it.  It's starting from the wrong side, in my opinion.
06:59:19 <ab9rf> i haven't had enough caffeine to make any sense of this
06:59:24 <hodapp> c_wraith: It says 'the former one cannot' - cannot what?
06:59:38 <lpaste> Ferdirand pasted “Type-level numbers” at http://lpaste.net/116169
06:59:38 <c_wraith> hodapp: can't be moved to the start of the signature.  It'd reduce the polymorphism
06:59:39 <sinelaw> hodapp, look at the 'foo' example above. what type does 'foo' have?
06:59:47 <sinelaw> hodapp, disregard that comment from the wiki for a moment
06:59:49 <hodapp> c_wraith: It's already *at* the start.
06:59:54 <c_wraith> hodapp: no, it's not
06:59:59 <sinelaw> hodapp, foo :)
07:00:15 <Ferdirand> hi all, can anyone explain why the error pasted above occurs ?
07:00:36 <hodapp> c_wraith: So 'forall a' is the former forall, and 'forall b' is the latter forall, right?
07:00:49 <c_wraith> Ferdirand: enable the ScopedTypeVariables extension
07:01:03 <Ferdirand> c_wraith: aah, thanks
07:01:20 <c_wraith> Ferdirand: (it was treating the inner `n` as a totally fresh type variable)
07:01:43 <dfeuer> I really wish ScopedTypeVariables were on by default.
07:02:08 <c_wraith> hodapp: that's correct, but really - ignore that text. It's not going to help you.
07:02:53 <sinelaw> I think that wiki page has been confusing people more than anything else
07:03:16 <sinelaw> the basic notion of rank-2 types is pretty simple, just needs a simple example.
07:03:55 <hodapp> c_wraith: I'm trying to figure out whether it's wrong, or just misleading.
07:04:11 <c_wraith> hodapp: it's neither wrong nor misleading.  It's just not useful.
07:05:45 <c_wraith> hodapp: to make it very explicit, it's saying "forall a. (a -> a) -> (forall b. b -> b)" is not the same as "(forall a. a -> a) -> (forall b. b -> b)."  The parens matter.  They control the scope of the quantification.
07:06:47 <serses> what was the command to compile the haskell file faster?
07:06:51 <c_wraith> hodapp: but it's not a useful example if you don't already know what it means.  It's nearly content-free
07:07:59 <c_wraith> hmm.  oh, look, it's a day that ends in 'y'.  Windows needs to be rebooted.  back later..
07:08:41 <hodapp> yeah, still sounds a bit misleading when they don't explain anything about the nesting.
07:09:52 <marchdown> How do I set up (ruby gem) guard so that it reruns tests every time I change something? I’m watching http://www.youtube.com/watch?v=ScS8Q32lMxA where it seems to just work in background with no explanation. Alternatively, _how should I go about testing my code_?
07:10:16 <purelazy> !1
07:10:24 <purelazy> :(
07:10:43 <purelazy> help lambdabot
07:11:01 <sivteck> > 1
07:11:03 <lambdabot>  1
07:11:05 <mmachenry> Does anyone know how to use either cabal or cabal-rpm to create an installation process that will put my code in /usr/bin as well as a symlink in another directory and a config file in /etc/ ?
07:11:18 <purelazy> sivteck: nice
07:11:24 <athan> Is there an easy way to duplicate  a newtype?
07:11:43 <athan> (not a type alias, I need to distinguish multiple copies)
07:11:52 <mmachenry> athan: What do you mean by duplicate?
07:12:15 <mmachenry> What two types do you want?
07:12:51 <tasker> I've been playing with criterion to try and benchmark some repa code. I'm not an expert in either, and have been trying to use nf in criterion to fully evaluate the calculation. Can I just have an orphan instance NFData for my datatype, and will it automatically implement rnf ? Or do I have to do it myself?
07:13:16 <EvanR> athan: theres generalized newtype deriving, im not sure how far it goes though
07:13:25 <athan> mmachenry: I'm trying to duplicate ReaderT
07:13:59 <athan> basically, the system I have going on is I would like to overload a class over monad transformers, where different monad transformers cause different effects
07:14:27 <athan> I'll have some code up in a little bit if you're interested :)
07:14:51 <mmachenry> Yeah I'm not sure what's going on. Code might help.
07:15:59 <athan> mmachenry: It's pretty simple. I've got a multiparameter class over a monad and some contents
07:16:11 <athan> I overload it with different _distinguished_ monad transformers
07:16:20 <purelazy> I just came across this new data constructor syntax, i.e. data Newtype =  SomeContructor { somefun :: SomeType }. What does it mean? Or where is a good explanation. Haven't come across it in any of my books. Thanks
07:16:29 <athan> and in my production code, I just type coerce to cause the different overloaded effects
07:16:40 <Soul-Burn> purelazy, that's record syntax
07:17:00 <Soul-Burn> https://ghc.haskell.org/trac/ghc/wiki/Records
07:17:11 <purelazy> Soul-Burn : OK
07:17:14 <Soul-Burn> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
07:17:25 <EvanR> somefun (SomeConstructor x) == x
07:17:39 <athan> purelazy: (SomeConstructor undefined) { somefun = id }
07:18:01 <athan> would make SomeConstructor id
07:18:01 <Soul-Burn> In general it gives names to the data in the datatype so you don't have to remember the first value is person and the second is ID etc
07:18:36 <Soul-Burn> In general lyah is a great book to learn from
07:18:50 <EvanR> you dont have to remember / dont have to type long annoying patterns involving lots of _
07:19:21 <Soul-Burn> yes, you can do stuff to pull values from the record or replace specific values
07:19:47 <Soul-Burn> purelazy, ignore hte first link I sent, use the second one
07:19:51 <athan> is there deriving primatives for applicative and monad?
07:19:53 <tasker> I don't get this. I run my criterion benchmark on a list, and I get some value of the mean time. I then run it on a list of lists, and get a smaller value - despite using nf on both :s
07:19:55 <purelazy> The actual example is data GameObject = GameObject { render :: IO () }
07:20:03 <athan> I know with -XDeriveFunctor we can derive functors :P
07:20:23 <EvanR> purelazy: so if you have a game object o, render o would be an IO ()
07:20:35 <athan> tasker: The best I can do is wish you luck :)
07:20:40 <Soul-Burn> if g is a GameObject, called render g will return the data inside that record
07:20:44 <tasker> athan :p
07:21:43 <Soul-Burn> I was reading some about functors, applicative, etc and about functions as applicative functors and was wondering
07:22:08 <Soul-Burn> if a function is an applicative, and <*> is the apply function
07:22:29 <Soul-Burn> whats make "function" so special that simple juxtaposition performs application for functions
07:22:31 <athan> Soul-Burn: remember, Applicatives have a kind *->*
07:22:36 <athan> flat data is of kind *
07:22:43 <athan> parametric data types are of kind *->*
07:22:56 <athan> the idea of a function itself (->) has kind *->*->*
07:23:37 <bernalex> @djinn (a, b, (c, d)) -> (a, b, c, d) -- is there some nice trick to do this?
07:23:37 <lambdabot> Cannot parse command
07:23:41 <bernalex> @djinn (a, b, (c, d)) -> (a, b, c, d)
07:23:41 <lambdabot> f (a, b, (c, d)) = (a, b, c, d)
07:24:03 <athan> ((->) r) ~ (r ->)
07:24:08 <ab9rf> hah
07:24:18 <Soul-Burn> and here my noobness strikes ^^``
07:24:32 <Soul-Burn> I'm not too strong in the kinds theory yet
07:24:34 <purelazy> Thanks people. I guess record syntax just slipped my mind.
07:24:56 <EvanR> well you need some syntax to apply functions normally
07:25:09 <EvanR> f $ x also works
07:25:10 <Adeon> @djinn (a, b, c, d) -> (a c, d b)
07:25:10 <lambdabot> Error: kind error: (KArrow (KVar 2) (KVar 4),KVar 0)
07:25:12 <Soul-Burn> purelazy, consider that making a record inserts the different functions into the scope.
07:25:42 <purelazy> Soul-Burn: I understand. Thanks
07:25:55 <Soul-Burn> what I say is that if "f x y" works, why won't "f x y" work if f, x and y are inside an applicative
07:26:25 <Soul-Burn> can't <*> become redundant?
07:26:31 <EvanR> you dont want it to implicitly doing things
07:26:48 <EvanR> the more ways you can write incorrect programs that it can detect, the more help you get from the checker
07:27:04 <joe9> chrisdone: sorry, had to fix my erc. not sure if you were looking for me.
07:27:05 <EvanR> this is in the same line of reasoning as automatically converting number types
07:27:10 <Soul-Burn> yes, but what if juxtaposition would simply be <*>
07:27:35 <Soul-Burn> it would still break if f x and y aren't applictives of the correct types
07:27:41 <Soul-Burn> f, x and y
07:27:52 <EvanR> you mean, implicitly lift all functions into whatever applicative?
07:28:09 <Soul-Burn> no
07:28:25 <EvanR> if f is the wrong type, it should fail rather than auto lift
07:28:36 <Soul-Burn> I'm not talking about auto lift
07:28:51 <Soul-Burn> but rather saying juxtaposition does "<*>"
07:29:00 <EvanR> there *is* special syntax to do f <$> x <*> y <*> ...
07:29:04 <EvanR> if you want to try it
07:29:18 <Soul-Burn> I'm talking about an f which is already in the applicative
07:29:31 <Soul-Burn> if f is not, then you'd have to do pure f x y
07:29:43 <Soul-Burn> or f <$> x y
07:29:58 <EvanR> so x next to y would be implicitly <*> ?
07:30:05 <Soul-Burn> but if f is already inside the applicative, then f x y should do what currently f <*> x <*> y does
07:30:25 <Soul-Burn> yes, and in the case of normal function application it would just be funciton application
07:30:33 <tasker> running this benchmark with whnf is slower than with nf.. that can't be right
07:30:57 <Soul-Burn> what I say is that <*> would become redundant
07:31:00 <EvanR> its selectively putting in <*> invisibly?
07:31:06 <Soul-Burn> not selectively
07:31:12 <Soul-Burn> all the time
07:31:18 <EvanR> then, between every single thing?
07:31:18 <chpatrick> and lifting to Identity?
07:31:25 <EvanR> and that
07:31:36 <Soul-Burn> yes, but that could be optimized away easily
07:31:47 <Soul-Burn> just a thought ^
07:31:57 <EvanR> you could also say that when not dealing with lists, everything gets implicitly encased in a singleton, and then optimized away
07:32:07 <EvanR> or a Just
07:32:23 <Soul-Burn> yes and no
07:32:32 <EvanR> in general i think wed rather it be exactly as we intend semantically
07:32:33 <Soul-Burn> because you could say there's a "" functor
07:32:41 <Soul-Burn> instead of lifting
07:32:53 <Soul-Burn> flat data would just "be" in the null functor
07:33:01 <EvanR> i think you just want special syntax sugar specifically for applicative, idiom brackets i think
07:33:06 <EvanR> https://www.haskell.org/haskellwiki/Idiom_brackets
07:33:16 <Soul-Burn> lessee
07:33:52 <Soul-Burn> well that's nice but doesn't make the code cleaner
07:33:58 <EvanR> ok i dont understand this
07:34:19 <chpatrick> ok but what are the criteria for being "flat data"?
07:34:20 <Soul-Burn> sorry gtg... but I'm glad there's a conversation going
07:34:38 <EvanR> https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html this one suggests (| f x y ... |)
07:34:39 <Soul-Burn> I really want to learn more about it
07:34:45 <EvanR> which looks more like banana brackets
07:36:24 * hackagebot servant 0.2.1 - A family of combinators for defining webservices APIs  http://hackage.haskell.org/package/servant-0.2.1 (AlpMestanogullari)
07:46:25 * hackagebot servant-server 0.2.1 - A family of combinators for defining webservices APIs and serving them  http://hackage.haskell.org/package/servant-server-0.2.1 (AlpMestanogullari)
07:47:41 <thebnq> whats "slicing", from trifecta
07:51:25 * hackagebot servant-docs 0.2.1 - generate API docs for your servant webservice  http://hackage.haskell.org/package/servant-docs-0.2.1 (AlpMestanogullari)
07:51:27 * hackagebot servant-jquery 0.2.1 - Automatically derive jquery-based javascript functions to query servant webservices  http://hackage.haskell.org/package/servant-jquery-0.2.1 (AlpMestanogullari)
07:56:25 * hackagebot servant-client 0.2.1 - automatical derivation of querying functions for servant webservices  http://hackage.haskell.org/package/servant-client-0.2.1 (AlpMestanogullari)
08:06:02 <sgronblo> I'm finishing up the last exercise of the edx Haskell course by trying to define fsum, fproduct :: (Foldable f, Num a) => f a -> a
08:06:27 <sgronblo> I was trying to use foldMap Sum for example but I get some error about a not being a Monoid instance.
08:06:59 <sgronblo> I thought my foldMap Sum would turn the a into a Sum which has a Monoid instance and then I could just fold the Foldable???
08:10:11 <ClaudiusMaximus> sgronblo: foldMap Sum gives you a Sum, when you want an a
08:10:33 <EvanR> :t foldMap
08:10:34 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
08:11:11 <EvanR> :t foldMap Sum
08:11:12 <lambdabot> (Foldable t, Num a) => t a -> Sum a
08:11:15 <k00mi> :t getSum
08:11:16 <lambdabot> Sum a -> a
08:12:13 <sgronblo> ClaudiusMaximus: yeah I finally figure out that the response was supposed to be a Num a => a and not Sum a
08:12:17 <sgronblo> Thanks though
08:18:04 <albeit> If I have a 32-bit bytestring in little-endian format (4 bytes), what's the fastest (in processing time, not development) way to convert it to an Int?
08:19:02 <rob__609> Does anyone know if duplication of Data.Bits.Extras in bits and bits-extras is intentional?
08:19:52 <rob__609> I'm getting an "Ambiguous module name" error and trying to understand if I should use one over the other.
08:20:27 <EvanR> albeit: unsafeCoerce? heh
08:22:13 <albeit> EvanR: Is that the only way to just interpret the raw value without processing? The other way I see cereal and Data.Binary doing it is taking each byte and shifting and combining appropriately...
08:22:48 <EvanR> some library might be doing this for you, in a safe manner
08:23:21 <EvanR> besides reinterpreting, you need to copy the four bytes out of the array into its own box
08:24:15 <EvanR> albeit: or you could leave it there, and you would want to be using an array of unboxed Ints
08:24:54 <EvanR> which you can get by reinterpreting a bytestring
08:25:14 <albeit> EvanR: Not sure I understand the last part there... you mean use it afterwards as an array of "Int8"s, not as a single Int32?
08:26:18 <EvanR> if you have an array of unboxed Int32s, you can use them alone, with some restrictions, for speed
08:26:40 <EvanR> https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/primitives.html
08:27:17 <albeit> Ah, I'll give that a read, thanks
08:27:21 <EvanR> so doing it this way does not involve conversions
08:28:10 <albeit> But I guess if I use the values later on, and I want to be decent Haskell, I should probably convert them to non-primitive types?
08:28:19 <albeit> (At the expense of a bit of speed)
08:28:53 <EvanR> at the point where you convert, it will copy the int
08:29:34 <prinsen> Can I get cabal to output the .so file of a library to a specific file? the -o GHC flag does not work
08:32:16 <luite> sclv: clearly 'puiq' would be superior to 'dnib' !
08:33:35 <sclv> Ahhhhaa
08:37:45 <albeit> In files with stuff like "#if defined(__GLASGOW_HASKELL__)" can I somehow check which ifs are true / what is defined?
08:51:03 <chpatrick> albeit: I haven't benchmarked it but this does what you want, super unsafely: http://lpaste.net/4957765266139250688
08:51:15 <dfeuer> I'm not getting this. I made a change that substantially reduces allocation, but the GC ends up doing substantially *more* work. What's the deal?
08:51:47 <chpatrick> albeit: in native order
08:53:05 <dfeuer> The mutator time goes down, but the GC time goes up more than enough to negate that improvement.
08:53:50 <dfeuer> Also, the "slop", whatever exactly that is, goes up from 246KB to 6.4MB.
08:54:05 <albeit> chpatrick: Cool thanks! I'll first understand it then compare it so what I'm using now
08:55:57 <_um_> hi!
08:56:37 <ksf> can someone tell me the deeper reasoning behind ekmett's machine's `Is` / forall dance?
08:56:44 <dfeuer> oh wait, I might've found something.
08:56:52 <ksf> or is it just for nicer error messages?
08:57:31 <t4nk648> could someone help me with haskell ? :x
08:57:58 <_um_> I'm going to throw out an abstract question, no offense will be taken if no answers are forthcoming: is it safe to just think of types as set extensions, for starters? Especially when trying to understand the category-theoretic side of monads?
08:58:22 <dfeuer> t4nk648, only if you ask a real question.
08:58:49 <ksf> types are pretty much sets a particular value of such a type can hold.
08:59:03 <ksf> (it might be possible to formulate that in a way that isn't circular)
08:59:13 <EvanR> a set of possible values
08:59:31 <ksf> err yes, *can be
08:59:42 <dfeuer> Bingo. I got it almost to where I want it now!
08:59:52 <EvanR> but then we talk about Maybe as "a type of kind * -> *" and this has no values of its own
09:00:01 <_um_> Okay. So actually, it almost sounds like I should think of types as *intensions*: they select out a set of objects.
09:00:08 <dredozubov> can i configure remote-repo for cabal on per-project basis somehow?
09:00:24 <dredozubov> using stackage-exclusive globally is major pain in the butt
09:00:33 <prinsen> Can one make cabal only generate the .so file, and redirect it to a file?
09:00:55 <pantsman> dredozubov: last time I looked, there was a cabal bug open about this
09:01:30 <dredozubov> pantsman: darn
09:01:33 <albeit> When using "W16#" I'm getting "parse error on input '#'"... is there an extension I need to enable?
09:01:34 <phaskell> W16 Harbormaster Buildables - https://phabricator.haskell.org/W16
09:01:51 <t4nk648> dfeuer, well I'm trying to implement  (elems :: Map k a -> [a])  from Data.Map as ADT i've created  a (data Map k a = Map (k -> Maybe a)  and trying to get the elements .. id be very happy if u could help me with this.
09:01:52 <ksf> here: https://github.com/ekmett/machines/blob/master/src/Data/Machine/Type.hs#L66    "k" is called with an existential type. as over elsewhere "data Is a b where Refl :: Is a a" is put in, all that "k t" means is, in effect, t. and instead of passing in k one could as well pass in t and leave out the existential.
09:01:56 <ksf> or did I miss anything?
09:02:00 <_um_> EvanR: The kind `* -> *` can be thought of as ranging over pairs of sets then? Where * and * each could be replaced with a "set of possible values"?
09:02:30 <dredozubov> pantsman: thanks, i'll check cabal issues
09:02:47 <ksf> _um_, a kind is not a type.
09:02:56 <ksf> a kind maps a type to a type.
09:03:03 <ksf> it's to types what types are to values.
09:03:21 <ksf> * -> * means "give me a type, and you shall have another type".
09:03:24 <ksf> such as
09:03:26 <ksf> :t Maybe
09:03:27 <lambdabot> Not in scope: data constructor ‘Maybe’
09:03:29 <ksf> :k Maybe
09:03:30 <lambdabot> * -> *
09:03:34 <ksf> :k Maybe Int
09:03:35 <lambdabot> *
09:03:52 <jpcooper_> hello
09:03:55 <EvanR> then i guess you wouldnt call Maybe a type
09:04:02 <jpcooper_> can anyone point me to some libraries to do SQL rewriting?
09:04:06 <pantsman> dredozubov: looks like it might be resolved: https://github.com/haskell/cabal/issues/1884
09:04:10 <EvanR> its function from types to types
09:04:38 <_um_> ksf: but if types are "sets of possible values" and * -> * maps from a type to a type, then doesn't it map from on possible "set of possible values" to another?
09:05:00 <EvanR> _um_: yes
09:05:05 <dredozubov> pantsman: good to hear
09:05:10 <dredozubov> it's annoying
09:05:22 <jpcooper_> oh, never mind
09:05:31 * ksf can't squeeze the formulation "ranges over a pair of sets" into his head, there.
09:05:37 <EvanR> {True, False} => {Nothing, Just True, Just False}
09:06:26 <ksf> _um_, for a bit more intuition, consider ADTs, set cardinality and why sum types and product types are called such.
09:06:28 * hackagebot names-th 0.0.1.0 - Manipulate name strings for TH  http://hackage.haskell.org/package/names-th-0.0.1.0 (KeiHibino)
09:06:30 * hackagebot sql-words 0.0.1.0 - Simple idea SQL keywords data constructor into OverloadedString  http://hackage.haskell.org/package/sql-words-0.0.1.0 (KeiHibino)
09:06:33 <_um_> EvanR: AH! Cool!
09:06:34 <ab9rf> i thought Maybe was a type constructor
09:07:20 <ksf> in particular, "Maybe" == "+ 1"
09:07:21 <EvanR> the result of applying Maybe is a type so yeah
09:07:31 <_um_> Maybe will take a set of possible values, and return a new set with Nothing added in and every value wrapped in a Just.
09:07:49 <ab9rf> well, no, it takes a type and generates a new type
09:08:02 <ksf> Either == +
09:08:09 <ksf> Tuple = *
09:08:39 <ab9rf> a type is not a set
09:08:49 <ksf> \x -> Either (Maybe x) x == \x -> (1+x) + x
09:09:12 <dfeuer> t4nk648, you can't implement that function with that type.
09:09:16 <_um_> ab9rf: that was my original question: whether it was "safe" to think about types as sets, at least initially to build up intuitions here.
09:09:34 <ab9rf> _um_: i wouldn't advise it
09:09:44 <dfeuer> t4nk648, there's no way to get the key values!
09:10:20 <_um_> ab9rf: could you maybe help point me in the direction of why it's a bad idea?
09:10:27 <ab9rf> a lot of types have effectively infinite spaces
09:10:45 <ksf> sets can have infinite cardinality.
09:10:50 <_um_> ab9rf: that's true of types too.
09:10:59 <ab9rf> yes, but i seem to recall that there are paradoxes lurking there
09:11:02 <flyingfisch> (=<<) is (>>=) flipped, correct?
09:11:10 <EvanR> so the suggestion here is that some types cant correspond with sets for some reason, maybe a paradox
09:11:12 <geekosaur> yes
09:11:16 <EvanR> but many types do
09:11:28 * hackagebot HDBC-session 0.0.1.0 - Bracketed connection for HDBC  http://hackage.haskell.org/package/HDBC-session-0.0.1.0 (KeiHibino)
09:11:29 <_um_> right.
09:11:30 * hackagebot persistable-record 0.0.1.0 - Binding between SQL database values and haskell records.  http://hackage.haskell.org/package/persistable-record-0.0.1.0 (KeiHibino)
09:11:32 * hackagebot relational-query 0.0.1.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.0.1.0 (KeiHibino)
09:11:34 * hackagebot relational-schemas 0.0.1.0 - RDBMSs' schema templates for relational-query  http://hackage.haskell.org/package/relational-schemas-0.0.1.0 (KeiHibino)
09:11:36 * hackagebot relational-query-HDBC 0.0.1.0 - HDBC instance of relational join and typed query for HDBC  http://hackage.haskell.org/package/relational-query-HDBC-0.0.1.0 (KeiHibino)
09:11:41 <ab9rf> also, you get into issues, i suspect, with types that correspond to machine types (e.g. Ptr)
09:11:52 * EvanR bahs
09:11:56 <_um_> so If I steer clear or "types of all types"?
09:11:57 <ksf> well yes but fast and loose reasoning is morally correct.
09:12:01 <ab9rf> well, Ptr is a type costructor
09:12:06 <ab9rf> but anthow
09:12:16 <ksf> _um_, can't have that in haskell, anyway.
09:12:55 <ab9rf> i dunno, maybe it's harmless
09:12:58 <cschneid> for practical "get things done" usage - should I use hackage, or stackage?  Building an end result website using snap
09:12:59 <EvanR> you can have an infinite hierarchy of type universes
09:13:07 <ab9rf> i'm not an expert in set theory or in type theory
09:13:29 <_um_> So I'm getting the sense that it's *roughly* okay to think of types as sets, but that I should be aware that this only goes so far and is limited (and obviously constrained by the initial motivation behind types as a tool to avoid Russell's paradox).
09:13:37 <ksf> Type : Type is fundamentally perverse.
09:13:43 <ab9rf> it's not how i think of types, but i'm only slightly less than completely incompetent
09:13:59 <ksf> formalists do such things in sectret under their desks.
09:14:08 <EvanR> in haskell it seems like things are more simple, ignoring bottom and machine stuff
09:14:29 <EvanR> theres no type of types, only kinds
09:14:33 <_um_> I just want to make sure I'm not going to screw up my understanding if I just--for the moment--ignore the fact that category theory isn't constrained to sets when I'm trying to puzzle out monads.
09:14:47 <ab9rf> bah, don't puzzle out monads
09:14:49 <ab9rf> just use them
09:14:56 <ksf> seconded
09:15:01 <EvanR> start by puzzling out Functor
09:15:06 <t4nk648> dfeuer, i see.. guess my prof won't be happy with this ..
09:15:09 <ksf> in the meantime, accept that they're burritos.
09:15:15 <ab9rf> also, agree with that.  monad is a poor place to start
09:15:20 <ksf> there's no reason to understand why, just suspend disbelief.
09:15:25 <ab9rf> ksf: dammit, now i want a burrito.
09:15:34 <EvanR> MonadSupply Burritos
09:15:36 <_um_> ab9rf: well, that's not what I'm after. I want Haskell for insight and practical value, but mostly the first.
09:15:47 <_um_> EvanR: will do.
09:15:54 <joe9> any emacs (evil + haskell-mode) users? The latest haskell-mode (1210 version) does not work with my configuration. Would you mind sharing your haskell configuration, please?
09:15:55 <ab9rf> _um_: still think yhou should start with Functor or Applicative, not MOnad
09:16:09 <ksf> _um_, you won't learn the groove by studying music theory.
09:16:14 <_um_> ab9rf: okay! I'll do that.
09:16:39 <ksf> fake it until you make it.
09:16:43 <_um_> ksf: that's not my style.
09:17:04 <ksf> shutup, take that guitar and start jamming :)
09:17:12 <_um_> ksf: but the encouragement is well taken and much appreciated.
09:17:42 <_um_> ksf, EvanR, ab9rf: thanks all for your help! The guidance is much appreciated.
09:18:03 <ab9rf> if monads are burritos, is there a monad analogy to a cilantro pocket?  https://medium.com/@luckyshirt/dear-guy-who-just-made-my-burrito-fd08c0babb57
09:18:10 <ksf> banging your head against some toy programs is really very much the "usual yoga" of haskell, and by extension monads.
09:19:09 <EvanR> and comonads are like nightclubs
09:19:16 <EvanR> apparently
09:19:50 <ab9rf> i hate toy programs
09:21:23 <_um_> ksf: I'm definitely playing around as I go too!
09:21:56 <_um_> ksf: I love toy programs, I just like to my play up with theory if I get a chance.
09:23:03 <ab9rf> it wasn't until i started actually writing real code that i started understanding what was really going on with applicatives and functors
09:24:15 <_um_> *mix my play up with
09:37:33 <bitemyapp> has anyone here used doctest-discover recently?
09:37:44 <bitemyapp> It's saying it's "passing", but doesn't seem to be loading my actual doctests :(
09:38:04 <bitemyapp> alternately, could someone tell me how to make the custom Setup.hs style of doctests work with OverloadedStrings?
09:42:27 <solrize> _um_ i found the haskell wikibook about categories to be very readable and it demystified monads for me.  http://en.wikibooks.org/wiki/Haskell/Category_theory
09:43:16 <solrize> after that, typeclassopedia is great
09:43:23 <ab9rf> 2whee
09:43:52 <supki_> bitemyapp: what's "custom Setup.hs style of doctests"?
09:44:11 <supki_> bitemyapp: you can have more luck asking this in #hspec
09:44:12 <bitemyapp> supki_: lens.
09:44:18 <bitemyapp> supki_: thanks
09:44:31 <_um_> solrize: thanks! I'll spend some time with the book! I've looked through typeclassopedia a bit, but I do think it'll be more helpful to me once I have a firmer grasp of the principles.
09:45:39 <_um_> solrize: that wikipedia book looks like it will be a perfect taste for me. I've been banging my head against the wiki articles on "category" "functor" "monad" and related terms, but it's hard to piece things together that way.
09:46:08 <_um_> I should probably just get a good book on the subject--which I'd like to do before long. Thanks
09:47:28 <solrize> _um_ the wikibook is imho more accessible than a CT book because it's haskell specific and connects more directly to programming
09:47:42 <jowens> Haskell has interesting internal data structures for List and Map that allow incremental updates, an example: "you have a data structure (List or Map) of 1M elements, you want to add 1k elements to that". I can understand in theory why this is useful, but: Where in practice is this useful? What kind of applications do incremental updates to Lists and Sets? I'd love to hear some suggestions.
09:48:30 <solrize> jowens, you mean like consing an element to the front of a list?
09:48:48 <solrize> or do you just mean why would you want a functional (persistent) data structure
09:48:56 <jowens> sure, although i'd rather hear examples that do more bulk-ish updates (more than one at a time)
09:49:17 <jowens> persistent data structures are useful for other reasons (e.g. storage)
09:49:36 <jowens> but i'd like an answer that doesn't worry about the persistence, simply an application that people care about in the real world.
09:49:43 <solrize> jowens, i'm not aware of list or map specifically supporting operations like that.  e.g. to add 1k elements to a list you have to cons them all or use ++
09:50:18 <solrize> persistence just means you can keep the old structure around when you add the new element
09:50:28 <jowens> i'm interested in doing a parallel implementation that *would* support such bulk operations.
09:50:34 <jowens> (GPUs)
09:50:49 <solrize> gpus are mostly for vectors represented as traditional arrays
09:50:58 <solrize> lists and maps aren't well suited
09:51:04 <jowens> that's what i aim to fix.
09:51:13 <jowens> that's the research question.
09:51:29 * hackagebot markup 0.0.1 - Abstraction for markup languages  http://hackage.haskell.org/package/markup-0.0.1 (athanclark)
09:51:59 <solrize> it's unclear what you have in mind, lists are a specific representation with specific, known characteristics, and if you want different characteristics you have to use a different data structure and then it's not a list
09:52:08 <solrize> haskell has some gpu support
09:52:28 <jowens> well, for instance, internally functional languages have picked finger trees or rrb trees to represent lists.
09:52:44 <jowens> there are multiple representations that would give (generally) desired list behavior.
09:52:56 <jowens> which includes fast indexing, efficient slicing and appending, that sort of thing.
09:53:19 <jowens> all i'm looking for here is "here's an application that would leverage such a data structure"
09:53:22 <solrize> haskell lists are like lisp lists.  haskell has a finger tree package but that's not a list
09:53:26 <ab9rf> typically such things are tradeoffs
09:53:28 <jowens> (I am familiar with the GPU work.)
09:53:37 <ab9rf> pick what you want to be fastest and optimize for that
09:53:43 <zerokarmaleft> amortized efficiency is likely not a performance characteristic you want when doing GPU work, eh?
09:54:09 <jowens> the state of the art on GPUs for data structures is "array" and "hash table". Neither is updatable.
09:54:10 <supki_> bitemyapp: I'm probably missing something but I don't see how what lens does changes how doctest works
09:54:19 <solrize> gpu cores have rather small local memory and aren't well suited to data representations with pointers, lots of random access, etc
09:54:19 <supki_> bitemyapp: do you have your project online somewhere?
09:54:22 <jowens> "updatable" in the sense of "I want to add elements to this without completely rebuilding it"
09:54:34 <supki_> bitemyapp: lens also has a number of doctests that use -XOverloadedStrings
09:54:41 <supki_> bitemyapp: e.g. https://github.com/ekmett/lens/blob/master/src/Data/Text/Lazy/Lens.hs
09:55:09 <jowens> solrize: I am familiar with the GPU field. I believe that I can build more interesting data structures that allow efficient updates. Where I would appreciate some ideas is "if we had those data structures, here's an application that would use them".
09:55:26 <solrize> how about a search engine where you want to add a new bunch of documents
09:55:43 <bitemyapp> supki_: have you looked at this before?
09:55:43 <jowens> text indexing is what you're saying.
09:55:51 <jowens> good use for a map.
09:55:54 <bitemyapp> supki_: https://github.com/ekmett/lens/blob/master/tests/doctests.hsc https://github.com/ekmett/lens/blob/master/Setup.lhs
09:56:02 <jowens> that makes sense.
09:56:02 <solrize> right, so now you want to add a document with 1000's more terms
09:56:09 <bitemyapp> supki_: I can't get OverloadedStrings to work if I reuse that doctests and Setup script.
09:56:24 <jowens> i like that idea.
09:56:27 <jowens> thank you.
09:56:57 <fragamus> OK, I have a filename that might be the empty string and I need to convert it to a IO Maybe String where it contains the contents of the file or Nothing
09:57:29 <solrize> database joins
09:57:30 <jowens> how about something that uses appends or slices on lists that benefits from updatability?
09:58:06 <jowens> (database joins: presumably with an updatable database, but generally that's an indexing problem as well. there's some nice work on joins in the GPU world already.)
09:58:23 <ab9rf> fragamus: if the filename a String or a Maybe String
09:58:32 <fragamus> string
09:58:46 <fragamus> but i see your point
09:58:52 <ab9rf> fragamus: not that hard
09:58:59 <solrize> cursors
09:59:03 <jowens> ?
09:59:07 <jowens> don't know cursors.
09:59:13 <ab9rf> case filename of "" -> Nothing; x -> Just x
09:59:52 <solrize> cursor points into a db table, like you want to page through 1000's of search results 50 at a time.  you get the first 50, then the next 50, etc,
10:00:29 <solrize> instead of having to read all 30000 results into memory all at once
10:00:33 <solrize> you use slices
10:00:45 <solrize> but the table could be changing while you page through it so you want persistence
10:00:53 <solrize> transactions in general
10:00:59 <jowens> oh! that's interesting. did not know that term.
10:01:34 <solrize> there's an okmij rant about them
10:02:48 <jowens> "streams"
10:02:52 <solrize> i'm trying to find it, it was sort of an antecedent to iteratees in retrospect
10:02:52 <solrize> yeah
10:03:25 <ab9rf> fragamus: and a combionation of withFile and hGetContents will read the file
10:03:35 <fragamus> ab9rf: I fixed it so it's a Maybe String, now I just have to do some maybe IO maybe baybe
10:03:46 <sinelaw> Peaker, yo
10:04:16 <unknown_1> hey guys
10:04:22 <fragamus> im using optparse applicative and I used the optional to get a maybe
10:04:24 <ab9rf> fragamus: write a function that takes a filename and returns its contents.  then use fmap to push it into the Maybe String
10:04:33 <EvanR> Maybe (IO (Maybe (Maybe (IO (Maybe (IO (IO (IO (...
10:04:48 <fragamus> :t readFile
10:04:49 <lambdabot> FilePath -> IO String
10:04:57 <bitemyapp> getting doctests to work is surprisingly non-trivial.
10:05:21 <sinelaw> bitemyapp, really? not my experience
10:05:34 <sinelaw> perhaps my use case was trivial
10:05:47 <bitemyapp> sinelaw: well.
10:06:06 <sinelaw> bitemyapp, what problems did you encounter?
10:06:07 <bitemyapp> sinelaw: I need overloaded strings to work. I can't get doctest-discover to discover anything and reusing lens' stuff I couldn't get to activate OverloadedStrings.
10:06:18 <sinelaw> ah.
10:06:21 <sinelaw> haven't tried any of that.
10:06:30 <bitemyapp> I added OverloadedStrings to the cabal doctest stanza, to the $setup block, to the modules themselves, everywhere.
10:06:41 <bitemyapp> still would puke on, "This is supposed to be Text, not [Char]!"
10:06:51 <ab9rf> fragamus: heh, so easy sometimes :)
10:07:06 <unknown_1> huh
10:07:20 <sinelaw> hmm
10:07:31 <jowens> solrize: thanks. i'll come back periodically to ask this question again, so ignore me when I do!
10:07:39 <solrize> heh
10:07:55 <rob__807> BTW, the error I
10:08:18 <rob__807> 'm seeing can be viewed here: http://lpaste.net/116178
10:08:39 <ab9rf> fragamus: if you have path :: Maybe FilePath, then fmap readFile path :: IO Maybe String
10:09:16 <rob__807> Are there any alternatives to hide-package in ghci?
10:09:49 <fragamus> ab9rf: super cool
10:11:14 <geekosaur> ghci -package bits-extras
10:11:15 <geekosaur> ?
10:13:45 <ab9rf> fragamus: i absolteuyl love using fmap to push inside Maybe
10:14:26 <ab9rf> hm, actually that's Maybe (IO String), you probably want IO (Maybe String)
10:14:41 <ab9rf> that requires some cleverness that i'm too tired to day to sort out
10:15:30 <glguy> Is there a way to query the type roles of a type in GHCi?
10:17:20 <kadoban> :t Data.Traversable.sequence
10:17:21 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
10:18:14 <rob__807> Thanks, geekosaur. I was hoping to remove one of the packages but I'm not sure how to do that.
10:20:48 <PoopDeck> Hi
10:21:28 <geekosaur> ghc-pkg unregisgter $packagename
10:21:28 <sinelaw> which profiling flags are suitable for CPU-bound programs?
10:21:33 <geekosaur> er
10:21:38 <geekosaur> ghc-pkg unregister $packagename
10:21:42 <sinelaw> (for figuring out what the cpu is doing, of course)
10:21:43 <geekosaur> i kan tipe gud
10:21:50 <EvanR> :t T.sequence
10:21:51 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
10:22:17 <EvanR> :t T.sequenceA
10:22:18 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
10:22:30 <supki_> bitemyapp: I can't reproduce your problem using lens' stuff
10:22:58 <supki_> bitemyapp: that is, lens stuff + $setup block works for me
10:23:42 <rob__807> thenk ewe!
10:25:09 <bitemyapp> supki_: I need OverloadedStrings.
10:25:14 <bitemyapp> supki_: are you using OverloadedStrings?
10:25:17 <supki_> yes
10:25:18 <bitemyapp> supki_: that's the part that didn't work with lens' code.
10:25:21 <bitemyapp> supki_: can you show me?
10:26:18 <fragamus> ab9rf: I think fmap is not going to cut it...    Maybe Filepath -> (FilePath -> IO String) -
10:26:30 <fragamus> oops hit return before i was done typing
10:26:32 <supki_> bitemyapp: https://github.com/supki/dumpsite
10:26:51 <fragamus> ab9rf: I think fmap is not going to cut it...    Maybe Filepath -> (FilePath -> IO String) -> IO Maybe String
10:27:24 <unknown_2> how come i cant set this up to auto join
10:31:51 <bitemyapp> supki_: thanks. I'll try this and see if I can make it behave.
10:38:23 <ab9rf> fragamus: yeah, you need some other magic
10:39:51 <cite-reader> let f p = runMaybeT $ MaybeT (return p) >>= lift . readFile
10:42:37 <ab9rf> yeah, makes sense that a monad transformer would do what you want there
10:43:19 <cite-reader> Alternatively, direct case analysis on the Maybe FilePath, but that's insufficiently fancy.
10:51:46 <bitemyapp> supki_: pCouldn't match expected type âTextâ with actual type â[Char]â
10:52:31 <bitemyapp> -- $setup
10:52:31 <bitemyapp> -- >>> :set -XOverloadedStrings
10:52:31 <bitemyapp> -- >>> import Database.Bloodhound
10:56:04 <bitemyapp> supki_: I think I've got it now. Had to add OverloadedStrings to the file preamble. Having it in the Cabal ain't enough.
10:57:39 <bitemyapp> supki_: thanks for your help!
11:01:32 * hackagebot webpage 0.0.1 - Organized and simple web page scaffold for blaze and lucid  http://hackage.haskell.org/package/webpage-0.0.1 (athanclark)
11:07:28 <Gay-champion> =° anyone can create me a yahoo account? é
11:08:53 <besenwesen> huh, when i do «:set -i/some/dir», and dir contains the tree «dir/Some/Module.hs», shouldn’t ghci be able to import «Some.Module»?
11:12:37 <athan_> Is there a way to hide a particular instance declaration in a module?
11:12:44 <geekosaur> no
11:12:52 <athan_> :(
11:12:58 <athan_> geekosaur: Thank you :)
11:13:08 <Gay-champion> anyone here is a programmer unity 3d?
11:21:28 <athan_> Can I make type-level lambdas? Say I have a monad transformer `foo :: * -> (* -> *) -> *`, how can I `instance Monad m => Monad (\x -> foo x m) where`?
11:22:18 <Cale> athan_: No, Haskell doesn't have type level lambdas
11:22:23 <Cale> athan_: You can make newtypes
11:22:32 <athan_> Cale: Ahh! Thank you
11:22:45 <Cale> But usually the solution is just to be careful about the order of type arguments
11:23:41 <xplat> newtypes can be very handy though, e.g. ListT in pipes
11:24:17 <xplat> there's a good reason the argument order is normally what it is, but there's a good reason to use the ListT order too
11:24:19 <Cale> The kind of a monad transformer should always be (* -> *) -> (* -> *), with any additional type arguments placed beforehand.
11:28:47 <chrisdotcode> Cale: Are nested monad transformers still called "monad transformers"?
11:29:02 <chrisdotcode> Is there anything to denote level in the name of a nested one?
11:31:38 <Cale> chrisdotcode: Nested in what way?
11:32:04 <Cale> chrisdotcode: You can compose monad transformers to get further monad transformers, but you sort of have to use a newtype to do it.
11:32:26 <chrisdotcode> Cale: Yeah, that's what I mean - is there any special name for that.
11:33:17 <Cale> chrisdotcode: I'd just say "composition of monad transformers"
11:33:27 <Haskellfant> I heard people calling nested monad transformers a transformer stack
11:33:48 <Cale> Yeah, I don't like that term in any case. Usually they're referring to the resulting monad.
11:33:56 <Haskellfant> yep
11:34:04 <gnusosa> Hi, quick question, is there a way to mark optional attributes for a type? define necessary attributes and the optional ones?
11:34:24 <Cale> We don't usually refer to f (g (h x)) as a "function stack"
11:34:40 <jfischoff> gnusosa: what kind of attribute?
11:34:54 <gnusosa> sorry, I might have the terminology wrong.
11:34:55 <monochrom> a type does not have any attribute
11:35:07 <Haskellfant> the stack term doesn't make much sense imho, just wanted to add it because I have seen it being used quite often
11:35:24 <jfischoff> data Foo = Foo Int String -- Would String be an attribute?
11:35:24 <gnusosa> jfischoff: sorry, basically add optional types to datatypes?
11:35:33 <jfischoff> yeah use Maybe
11:35:42 <jfischoff> data Foo = Foo Int (Maybe String)
11:36:15 <Gay-champion> Who is a transexual gay here ?
11:36:27 --- mode: ChanServ set +o monochrom
11:36:29 <ab9rf> you're in the wrong channel, dude
11:36:32 --- mode: monochrom set +b *!*@87.19.74.180
11:36:32 --- kick: Gay-champion was kicked by monochrom (Gay-champion)
11:36:42 <gnusosa> jfischoff: Thanks so much. That's brilliant. I don't know why I thought of Maybe as something for Error and Exception handling.
11:37:14 <jfischoff> Yeah it can be used for that, but usually Either ErrorType a is better
11:37:28 <jfischoff> or something similar so you get a message
11:37:36 <gnusosa> Noted. Thanks.
11:37:40 <gnusosa> Much to study. :D
11:37:41 <jfischoff> np
11:38:10 <jfischoff> you don't need to know that much to be dangerous ;)
11:38:14 --- mode: monochrom set -o monochrom
11:39:58 <purelazy> how can (on exit) Haskell send a code back to the OS, as with exit() in C
11:40:30 <geekosaur> @index exitWith
11:40:30 <lambdabot> System.Exit
11:40:31 <jfischoff> http://hackage.haskell.org/package/base-4.7.0.1/docs/System-Exit.html
11:40:51 <jfischoff> I googled "haskell exit code"
11:40:57 <jfischoff> first result
11:42:35 <purelazy> I googled haskell "return codes"
11:42:43 * jfischoff nods
11:42:47 <purelazy> My bad
11:43:24 <purelazy> geekosaur: Thanks
11:43:34 <purelazy> jfischoff: Well done
11:44:00 <jfischoff> it came off as rude, but I was just explaining the process I took
11:44:03 <jfischoff> np
11:44:34 <purelazy> jfischoff: No - you did better than me :)
11:44:41 <jfischoff> :)
11:55:36 <fugyk> Can we change the type of (==) or is it always fixed
11:56:04 <ab9rf> change it how?
11:56:08 <ab9rf> :t (==)
11:56:09 <lambdabot> Eq a => a -> a -> Bool
11:56:16 <ab9rf> you don't like that type?
11:56:45 <shachaf> You can "change" it by defining a different functinon with the same name and hiding the one in Prelude.
11:56:52 <ab9rf> you can always exclude (==) from the implicit Prelude import and define your own (==)
11:57:22 <fugyk> No, I am learning haskell and has a doubt if we can compare two different types using (==) operator
11:57:44 <ab9rf> fugyk: obviously you can't
11:57:57 <ab9rf> otherwise it would be a -> b -> Bool, and i'm not sure how you'd even define that
11:58:19 <Enigmagic> multi parameter type classes and incoherent instances :D
11:58:22 <ab9rf> well, ok, actually i have no f*****g idea how you'd define it
11:58:33 <fugyk> like for example 11 == "11"
11:59:02 <Enigmagic> the PHP is strong
11:59:07 <ab9rf> fugyk: unlike many language, haskell doesn't have implicit type promotions and the ambiguity that comes with them
11:59:25 <mmachenry> There might not be a way to define at expression with type "a -> b -> Bool" such that a != b and you don't exploit bottom.
11:59:51 <mmachenry> Oh no duh there is.
12:00:22 <mmachenry> :t \x y->True
12:00:23 <lambdabot> t -> t1 -> Bool
12:11:53 <ab9rf> not exactly useful, but yeah
12:11:55 <fugyk> What is the difference between the two:
12:11:59 <fugyk> 'instance Functor [] where fmap = map'
12:12:11 <fugyk> instance Functor [] where fmap = map
12:12:19 <fugyk> instance Functor [a] where fmap = map
12:12:28 <fugyk> sorry for first
12:13:35 <shachaf> "instance Functor [a]" is invalid
12:13:50 <ab9rf> i knew one was but i wasn't sure which :)
12:14:00 <pavonia> :kind Functor
12:14:37 <ab9rf> :k Functor
12:14:38 <lambdabot> (* -> *) -> Constraint
12:14:43 <ab9rf> :k []
12:14:44 <lambdabot> * -> *
12:14:49 <ab9rf> :k [a]
12:14:51 <lambdabot> Not in scope: type variable ‘a’
12:15:15 <exio4> :k ∀a. [a]
12:15:16 <lambdabot> *
12:15:19 <alt_ern> Is there someone who could explain why I am getting this error: RoseTree2.hs:10:10:
12:15:19 <alt_ern>     No instance for (GToJSON (GHC.Generics.Rep RoseTree2))
12:15:19 <alt_ern>       arising from a use of `aeson-0.7.0.6:Data.Aeson.Types.Class.$gdmtoJSON'
12:15:19 <alt_ern>     Possible fix:
12:15:19 <alt_ern>       add an instance declaration for
12:15:19 <alt_ern>       (GToJSON (GHC.Generics.Rep RoseTree2))
12:15:21 <alt_ern>     In the expression:
12:15:23 <EvanR> whats an example of a (* -> *) -> *
12:15:23 <alt_ern>       (aeson-0.7.0.6:Data.Aeson.Types.Class.$gdmtoJSON)
12:15:27 <alt_ern>     In an equation for `toJSON':
12:15:29 <alt_ern>         toJSON = (aeson-0.7.0.6:Data.Aeson.Types.Class.$gdmtoJSON)
12:15:31 <alt_ern>     In the instance declaration for `ToJSON RoseTree2'
12:15:33 <alt_ern> Failed, modules loaded: none.
12:15:35 <EvanR> as soon as alt_ern stops spamming
12:15:38 <ab9rf> alt_ern: please use a pastebin
12:15:45 <exio4> EvanR, data Fix f = f (Fix f)?
12:15:49 <shachaf> alt_ern: Please don't paste more than a couple of lines in the channel.
12:15:51 <alt_ern> EvanR, sorry
12:16:21 <exio4> data Fix f = F (f (Fix f)) -- fixed?
12:41:36 * hackagebot diversity 0.3.4.0 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.3.4.0 (GregorySchwartz)
12:45:22 <S11001001> @src Mu
12:45:22 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
12:45:27 <S11001001> exio4: ^^
12:46:23 <shachaf> S11001001: I'd prefer to call that type Fix.
12:46:26 <sinelaw> debugging aeson parse failures is a headache. must it?
12:47:00 <S11001001> shachaf: me too
12:47:03 <shachaf> There are established meanings for Mu -- newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r } -- and Nu -- data Nu f = forall x. Nu x (x -> f x)
12:47:06 <S11001001> is Mu just in caleskell?
12:47:22 <S11001001> (I mean the Mu that is Fix)
12:47:23 <shachaf> Who knows.
12:48:28 <S11001001> EvanR: you can also flip and apply any monad transformer and get a (* -> *) -> *
12:58:54 <exio4> S11001001, I knew about Mu, I also prefer to call it Fix, mainly because fix is ((a → a) → a) and Fix is ((* -> *) -> *) :P
12:59:30 <shachaf> Mu and Nu are also :: (* -> *) -> *
12:59:54 <shachaf> In fact they are isomorphic to Fix.
13:00:00 <exio4> oh, didn't see those
13:01:37 * hackagebot opaleye 0.3 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.3 (tomjaguarpaw)
13:19:16 <KangaAkale> Hello all I am writing a fumction that takes a string and returns an IO
13:19:27 <KangaAkale> but i am getting errors.
13:19:39 <KangaAkale> here is my function
13:19:46 <geekosaur> what is "an IO"?
13:19:50 <KangaAkale> retrieveFixtures :: String -> IO () retrieveFixtures team  = do conn <- connectSqlite3 "results.db"                             r <- quickQuery' conn "SELECT matchDate, homeTeam, oppTeam, ethg, etag FROM matchTable WHERE homeTeam = ? OR oppTeam = ? ORDER BY matchID "[toSql team]                             return r
13:20:05 <geekosaur> please don't paste into the channel like that.
13:20:06 <geekosaur> @paste
13:20:07 <lambdabot> Haskell pastebin: http://lpaste.net/
13:20:22 <KangaAkale> sorry about that
13:20:38 <dmj`> KangaAkale: you are returning r, not unit "()"
13:20:49 <KangaAkale> http://lpaste.net/3337988835161145344
13:21:11 <dmj`> KangaAkale: try "print r", instead of "return r"
13:21:36 <KangaAkale> ok, but i actually do not want to print it
13:22:02 <dmj`> KangaAkale: what do you want to do with the results after you print it?
13:22:20 <dmj`> KangaAkale: worst case scenario, remove the type signature altogether and let ghci infer it for you
13:22:41 <KangaAkale> I ok
13:22:43 <dmj`> if I do f r = print r, then f will be inferred as Show a => a -> IO ()
13:23:18 <dmj`> KangaAkale: s/print/retrieve
13:25:26 <dmj`> KangaAkale: find out the type quickQuery' returns, then place that type after IO
13:41:39 * hackagebot urlpath 0.0.4 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-0.0.4 (athanclark)
13:42:44 <sinelaw> painfully simple.
13:44:24 <pavonia> Do you know of a Haskell project that uses two different backends, preferably Gtk and console output? I'm having some trouble separating GUI and non-GUI functionality in my project and need a bit of inspiration
13:46:30 <pavonia> Specifically, I'd be interested in something that uses one of the TreeModel classes in the Gtk backend
13:49:17 <pecanpy> why isn't (..) an operator?
13:50:23 <jle`> you mean in enumeration syntax? as opposed to being syntax?
13:51:04 <pecanpy> yea. i guess i expected ":t (..)" to be "int -> int -> [int]"
13:51:30 <shachaf> And then [a..b] would be a list of lists of ints?
13:51:40 <shachaf> (Singleton list?)
13:52:14 <pecanpy> REKT.
13:52:48 <pecanpy> thats a good point. (a..b) would not be as nice
13:52:49 <jle`> in another world you might be able to imagine writing (a..b), but then...it precludes us from doing enumFromThen stuff like [1,3..]
13:52:55 <jle`> also [1..]
13:53:06 <jle`> so probably it's better off as it is now :)
13:53:18 <pecanpy> oh that to. i didn't think this through.
13:53:23 <jle`> it's ok
13:53:25 <pecanpy> ill just use enumFromTo then.
13:53:48 <jle`> > let (...) = enumFromTo in (3...10)
13:53:49 <lambdabot>  [3,4,5,6,7,8,9,10]
13:54:50 <pecanpy> W. T. A. F.
13:54:51 <dts|pokeball> 14
13:55:02 <pecanpy> i didnt realize you could Let operators
13:55:02 <dts|pokeball> 19
13:55:52 <oleo> that's like enumFromTo(3, 10)
13:56:34 <burp> > let (…) = enumFromTo in (3…10)
13:56:36 <lambdabot>  [3,4,5,6,7,8,9,10]
13:56:39 * hackagebot atlassian-connect-descriptor 0.2.0.0 - Code that helps you create a valid Atlassian Connect Descriptor.  http://hackage.haskell.org/package/atlassian-connect-descriptor-0.2.0.0 (RobertMassaioli)
13:57:43 <hypoon> hi all, how would I go about making a function which can have the types Double -> CDouble and Float -> CFloat, but not Double -> CFloat?
13:58:59 <ChristianS> hypoon: hmm, make two functions?
14:00:58 <hypoon> ChristianS: That's exactly what I'm trying to avoid. I have an entire module of functions that would work for floats OR doubles, but not a mix.
14:01:35 <pavonia> You can make a new class and add two instances for Float and Double
14:02:02 <jle`> do you just want to forbid users from Double -> CFloat?  is it like...not "allowed", semantically?
14:02:08 <hypoon> pavonia: that's exactly what I was thinking I would do, but I don't know how to work out the details
14:02:36 <jle`> i would advice against a typeclass but yea
14:03:05 <pavonia> jle`: Why?
14:03:15 <pavonia> hypoon: Do you already know about type classes?
14:03:16 <jle`> because typeclasses ;_;
14:03:23 <hypoon> jle`: I'm working with FFI, and if the user gives me a list of floats, I want to perform all the C computations using floats. I don't want Haskell to inadvertently convert the list of Floats to a list of CDoubles instead of CFloats.
14:03:25 <jle`> almost always the wrong idea for the situation
14:03:46 <jle`> but it's almost always the first thing to be thought about
14:04:06 <jle`> hm
14:04:49 <jle`> you could do it using type families, but i'm not sure if that's much better haha.
14:05:26 <hypoon> What I'm trying to do is this: I have a nice file in C with some functions that work for CFloats and for CDoubles, that return CFloats and CDoubles. If CFloats and Floats were the same thing, then it would be easy, and my Haskell functions would have simple types of a -> a, but CFloats and Floats are different.
14:05:52 <wyager> I posted this here like a week ago, but it's changed since then. It's a concurrent in-memory key/value store written in Haskell. The server is only ~175 lines, and it handles over a million requests per second. Thought you guys might be interested :) https://github.com/wyager/KVStore
14:06:00 <hypoon> It's like my function needs to be (a -> b, where b = CFloat if a = Float, or b = CDouble if a = Double)
14:06:40 * hackagebot urlpath 0.0.5 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-0.0.5 (athanclark)
14:07:05 <hypoon> So then I was thinking that I would do (FloDub a, CFloDub b) => a -> b, where FloDub is a typeclass with Float and Double as instances, but...
14:07:30 <gedringer> Hey guys ^^ I need some help with printing :<
14:07:54 <gedringer> So I'm making a 2-3-4 tree at the moment and I have already wrote the code for the data structure and all
14:08:02 <gedringer> now I want to make a function that will print it
14:08:16 <geekosaur> hypoon, if I felt that I really needed to do that, I'd use a typeclass with associated types. but I'd consider some other way first since typeclasses are often more trouble than they're worth
14:08:27 <gedringer> for now it prints in a row and I managed to print the integers as 2node 3node and 4node
14:08:57 <gedringer> in brakets but I don't know how to put each level in it's respective position in the herarchy
14:09:07 <gedringer> what I have so far is this
14:09:08 <gedringer> http://oi58.tinypic.com/2vm654z.jpg
14:09:12 <jle`> the typeclass approach would be class IsC c a where toC :: a -> c; instance IsC CDouble Double where toC = thefunction, i think
14:09:16 <pecanpy>   wyager: that's awesome. next step, haskell firebase?
14:09:19 <jle`> but
14:09:21 <gedringer> this is my code, and my output
14:09:22 <jle`> it's probably not worth the hassle
14:09:30 <geekosaur> why tinypic instead of a pastebin?!
14:09:48 <gedringer> cause it has pictures of my output
14:09:50 <gedringer> ^^
14:10:14 <pavonia> hypoon: What about something like http://lpaste.net/116203 ?
14:10:36 <geekosaur> so this is what cool kids do instead of cut and paste these days?
14:10:51 <jle`> the type family approach...
14:10:58 <wyager> pecanpy: Thanks! Hmm, that would be cool :)
14:11:14 <gedringer> at the bottom I show how I define my tree that you see on the picture
14:11:56 <ReinH> gedringer: It's much easier to print trees from left to right than top to bottom fwiw
14:11:57 <ReinH> Also there is an entire cottage industry of pretty printers designed to solve this sort of task
14:11:57 <ReinH> So what you should do next sort of depends on whether you're trying to write your own special pretty printer or you just want something that works
14:12:39 <gedringer> write my own :P
14:12:59 <jle`> the type family approach would be type family ToC a where ToC Float = CFloat; ToC Double = CDouble, etc.
14:13:18 <jle`> and then when you needed the "corresponding type", `ToC Float` will typecheck as CFloat
14:13:22 <jle`> i'm not sure if that's usable though
14:13:24 <jle`> hm.
14:13:33 <ReinH> You might look at Data.Map.Lazy.showTree for example
14:13:34 <ReinH> Some problems with the top-down approach are that you can't do it incrementally and it tends to get extremely wide even for relatively shallow trees
14:13:48 <pecanpy> wyager: why is the value sent back with the response?
14:13:54 <athan__> Hey everyone online right now - you're friggin awesome :D
14:14:00 <ReinH> Hmm, maybe I should describe this as the left-to-right approach, since it lists leaves from left to right.
14:14:11 <wyager> pecanpy: You mean the key? So people writing async code in node or whatever have an easier time
14:14:21 <ReinH> In any event, this way of printing trees isn't as good as the other way
14:14:33 <hypoon> geekosaur, jle`, pavonia: I think what pavonia posted looks like what I'm trying to do. I just don't want Haskell reforming my list of floats into doubles and passing doubles to C. The type family approach sounds like what I originally was thinking, but I didn't think type families were standard Haskell. I try to use as few extensions as possible.
14:14:50 <gedringer> i jsut want to make it look like it's a tree, doesn't matter if top -> down or left -> right, as long as it looks like a tree
14:15:15 <geekosaur> hypoon, with typeclasses you're using an extension no matter what: you need either fundeps or type families to make it work
14:15:15 <pecanpy> wyager: sorry, i misread. i confused the "get" response with the "your set went through" response.
14:15:30 <jle`> hypoon: you're not going to be able to do pavonia's example w/out extensions anyway :)
14:15:31 <ReinH> Then I'd suggest printing it the way Data.Map.Lazy.showTree does
14:15:35 <jle`> oh, already posted
14:15:36 <wyager> pecanpy: There's no response to a set
14:15:41 <wyager> Only gets have responses
14:15:54 <wyager> "Get K" response either "Found K V" or "NotFound K"
14:15:57 <ReinH> Which is also the way that, e.g., the `tree` unix tool prints them
14:16:12 <gedringer> Okay I'll have a look and get back to you if I have any problems (if that's alright with you of course ^^)
14:16:25 <wyager> Most people will throw away the K in the response, but I bet some people will want it
14:16:42 <wyager> It's easy to get rid of for speed, though. One of the benefits of tiny code :)
14:17:19 <ReinH> gedringer: Sure, just ask in here and someone will probably be able to help
14:17:34 <gedringer> Thank you!!! :D
14:17:37 <ReinH> gedringer: here's the source for reference: http://hackage.haskell.org/package/containers-0.5.5.1/docs/src/Data-Map-Base.html#showTreeWith
14:17:58 <gedringer> Thank you veeeeeeery much!!!!!! :D
14:18:15 <pecanpy> wyager: oh, then i misread the final sentence. firebase, calls a callback when a set is finished. i thought you were sending a "success" response as well, and including the key, which i thought was useful.
14:18:32 <wyager> pecanpy: Well, there's not really any way a set can fail
14:18:37 <ReinH> gedringer: Also, for a more general introduction to pretty printing (which is a really cool problem), Richard Bird's new Haskell book implements an entire pretty printing library in a really nice way as its conclusion
14:18:42 <wyager> At least, nothing that shouldn't *always* fail
14:18:43 <pecanpy> wyager: famous last words?
14:18:45 <pecanpy> lol
14:18:46 <wyager> haha
14:18:51 <wyager> Funny story actually
14:18:52 <ReinH> There have been a number of interesting papers on functional pretty printing as well
14:19:17 <chasm_> if anyone uses structured-haskell-mode... is there any way to make it automagically play nice with custom themes? the node highlighting is pretty out there for dark themes
14:19:28 <gedringer> That might come in handy, I'll have a look now :D
14:19:28 <hypoon> It seems like an awfully simple thing to try to do. I have a function in C, overloaded such that cfunc(floats) returns floats, and cfunc(doubles) returns doubles. I would like to make it accessible via FFI, as hfunc :: [Float] -> [Float] and hfunc :: [Double] -> [Double], which implies a simple signature of hfunc :: (FloatOrDouble a) => [a] -> [a], where FloatOrDouble is a type class with only Float and Double as instances. I just r
14:19:32 <ReinH> gedringer: This is also a sneaky way for me to recommend that you read what I think is the best book ever written on Haskell ;)
14:19:45 <gedringer> hahahaha
14:19:46 <gedringer> :D
14:19:47 <ReinH> It might fundamentally change the way you think about writing functional programs
14:19:50 <ReinH> It's really that good.
14:20:05 <jle`> Bird has a new haskell book?
14:20:05 <geekosaur> gedringer, I should probably mention that the reason I'm giving you a hard time about using screenshots is that trolls sometimes come in here and use gimmicked (e.g. porn or etc.) screenshots instead of pastes. at one point just using a screenshot got you summarily kicked.
14:20:07 <ReinH> The previous iteration of this book did that for me years ago.
14:20:08 <ReinH> jle`: Yeah
14:20:11 <geekosaur> so please use text cut and paste
14:20:12 <jle`> whaaaa
14:20:15 <ReinH> @google Thinking Functionally with Haskell Richard Bird
14:20:17 <lambdabot> http://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/thinking-functionally-haskell
14:20:17 <lambdabot> Title: Thinking Functionally with Haskell | Programming languages and applied logic ...
14:20:18 <wyager> I had an error message in my code "How the hell can a Word64 fail to decode?". Well, turns out that "hGet n" reads *up to* n bytes from the handle, but will fail silently if it can not. So I was trying to decode less than 8 bytes, which failed. So I got rid of that error message :_
14:20:18 <ReinH> jle`: Came out last month.
14:20:22 <jle`> whaaaaaaaaa
14:20:24 <jle`> t
14:20:32 <jle`> thanks
14:20:36 <ReinH> jle`: It's a rewrite of Intro to FP using Haskell, which is my previous "best FP book of all time".
14:20:46 <jle`> oh i haven't read that one either.
14:20:49 <ReinH> jle`: Yeah, it's great. I think even someone of your considerable skill would get a lot out of it.
14:20:52 <jle`> well time to buy a book for the holidays
14:20:54 <ReinH> I certainly did.
14:20:56 <jle`> ha ha considerable skill
14:21:12 <gedringer> geekosaur: ahhh I get it ^^ no worries I understand, will stick to pastebin then
14:21:16 <wyager> pecanpy: It would actually simplify the code to send a response to a "set" message. I could shave a few lines
14:21:40 * hackagebot doctest-discover 0.1.0.6 - Easy way to run doctests via cabal  http://hackage.haskell.org/package/doctest-discover-0.1.0.6 (karun012)
14:21:50 <pecanpy> wyager: meh. im not saying you need one. i just assumed it from my experience with fb
14:22:11 <wyager> Yeah, I'll see if anyone asks for it
14:22:17 <jle`> thanks for the rec :)
14:22:25 <ReinH> jle`: sure! I am trying to get everyone to read it ;)
14:22:40 <jle`> :D
14:23:27 <imalsogreg> Any org-mode, ob-haskell users around? I'm trying to figure out how to get rid of the pesky Prelude | Prelude | Prelude > part of the code-block execution results.
14:25:12 <jle`> ReinH: temporarily unavailable no date available ;___;
14:25:28 <ReinH> jle`: get the Kindle edition
14:25:29 <jle`> oh that's just the paperback
14:25:32 <ReinH> It's way cheaper too
14:25:38 <jle`> i see
14:25:43 <jle`> ty
14:25:47 <ReinH> Yep :)
14:26:12 <ReinH> imalsogreg: Well, I've never gotten the results to work properly so...
14:26:32 <imalsogreg> ReinH: Soooo close to being soooo awesome :P
14:27:36 <benzrf> ok gaise
14:27:52 <benzrf> why do i need impredicative types for "T (forall x. thing x -> other x)
14:27:53 <benzrf> "
14:34:41 <Shamar> Hi, being paranoid, I use a luks/lvm encrypted filesystem for r&d source code. How can I configure cabal sandboxes so that the output of builds goes to a specific directory instead of dist/build ?
14:35:02 <bitemyapp> can you use named chunks of documentation in module headers?
14:36:12 <gedringer> I'm trying to use \n in my strings but \n gets appended instead of new line being printed :(
14:36:21 <gedringer> say I write this:
14:36:42 <gedringer> printMyTree (TwoNode a left right) = printMyTree left ++ "[ " ++ show a ++ " ] \n" ++ printMyTree right
14:37:14 <gedringer> i googled this issue but no one gives a definitive solution
14:37:36 <Zekka> gedringer: Most likely your problem is coming in somewhere else
14:37:45 <Zekka> because Haskell's escape codes work fine and pretty much how you would expect
14:37:46 <geekosaur> if I had to guess, you are doing this in ghci and it's implicitly invoking show on the string
14:38:01 <geekosaur> try explicitly `putStrLn`-ing it
14:38:02 <Iceland_jack> gedringer: Your function doesn't print the string, it just returns it. Try using "putStrLn" on the output of printMyTree
14:38:08 <Zekka> geekosaur's is possible. You could also be using 'print' instead of 'putStrLn'
14:38:24 <Zekka> that is, assuming you're eventually printing the string
14:38:28 <gedringer> but then concatenation doesn't work :(
14:38:34 <Iceland_jack> gedringer: What do you mean?
14:38:35 <Zekka> What?
14:38:43 <geekosaur> you just need parentheses, I suspect
14:38:47 <gedringer> here's my code
14:39:05 <geekosaur> putStrLn takes a single String parameter; if you are using it with an expression, you need to put that expression in parentheses
14:39:06 <Iceland_jack>     ghci> putStrLn ("hello" ++ "\nworld")
14:39:06 <Iceland_jack>     hello
14:39:06 <Iceland_jack>     world
14:39:11 <bitemyapp> Iceland_jack: ever used doctest?
14:39:19 <bitemyapp> Iceland_jack: or know anything about Haddock for that matter?
14:39:34 <Iceland_jack> bitemyapp: In Python? Yes a bit
14:39:41 <Iceland_jack> What are you wondering?
14:39:45 <geekosaur> otherwise it things you are concatenating the result of putStrLn with the rest of the expression
14:39:47 <gedringer> http://pastebin.com/CiDLbGHr
14:39:51 <bitemyapp> Iceland_jack: no, Haskell.
14:40:01 <Iceland_jack> Then no
14:40:01 <Shamar> anyone can access https://www.haskell.org/cabal/users-guide/ ?
14:40:10 <bitemyapp> Iceland_jack: I have a $setup preamble for my doctests, I'd like Haddock to put that in the module description but I can't make it work :(
14:40:10 <Zekka> gedringer: That code does not print anything but it otherwise looks correct
14:40:10 <gedringer> when I changed the output of my function to
14:40:13 <gedringer> IO()
14:40:16 <geekosaur> Shamar, worked for me
14:40:22 <gedringer> I used the putStr but then this line
14:40:25 <Zekka> That code generates a string, which is different from printing a string
14:40:31 <gedringer> printMyTree (TwoNode a left right) = printMyTree left ++ "[ " ++ show a ++ " ] \n" ++ printMyTree right
14:40:36 <gedringer> throws me this error
14:40:39 <Zekka> gedringer: You can't concatenate IO ()s
14:40:45 <Zekka> They aren't lists
14:40:55 <gedringer> yes :/ so how should I use putStr then?
14:40:55 <Zekka> You can perform them sequentially with >>, I guess, but that probably isn't what you want
14:41:08 <Zekka> gedringer: You should name your function something reflective of what it does -- probably you should instantiate Show
14:41:25 <Shamar> geekosaur, strange I receive a 404
14:41:33 <Zekka> Then you should use print on your tree, which shows and then calls putStrLn
14:41:50 <ReinH> I would recommend writing explicit showTree and printTree methods
14:41:54 <Iceland_jack> bitemyapp: Shouldn't adding '-- $setup' just work?
14:41:54 <Zekka> Minding that it's not customary for show instances to use newlines so that's not strictly a good idea
14:41:58 <ReinH> Show should be used for things that can also be Read
14:42:11 <Shamar> I can't access https://www.haskell.org/ at all
14:42:18 <Zekka> ReinH: That's true: although his format is parseable he probably doesn't intend to write a parser for it
14:42:26 <bitemyapp> Iceland_jack: no, it just renders a literal "$setup"
14:42:36 <Iceland_jack> Huh odd
14:42:38 <bitemyapp> Iceland_jack: I've tried putting it in several parts of the module description.
14:43:04 <dfeuer> When you're not running the right test program, the results will not do what you expect.
14:43:08 <dfeuer> *headslap*
14:43:10 <Shamar> strange... https://status.haskell.org/ tells everything is ok
14:43:19 <ReinH> showTree constructs the string. printTree prints it, and can just be printTree tree = putStrLn (showTree tree) or printTree = putStrLn . showTree
14:43:25 <MP2E> yeah haskell.org works form e
14:43:27 <MP2E> for me*
14:43:35 <crobbins> Shamar: are you on vpn?
14:43:44 <Shamar> no
14:43:46 <crobbins> i've had issues with vpn messing up haskell.org
14:43:50 <crobbins> ok
14:43:56 <crobbins> worth a shot
14:43:58 <Shamar> ehm... well, fastweb vpn
14:44:04 <crobbins> hmmm
14:44:07 <Shamar> I mean
14:44:12 <crobbins> i don't know what that means
14:44:13 <dfeuer> Shamar, that's updated manually, so what it says is not always up to date. However, if everyone else is okay and you're not, the problem's on your end.
14:44:14 <crobbins> but...
14:44:21 <bitemyapp> Iceland_jack: I have to export something to use a named chunk of documentation, so I have a silly setup = undefined getting exported which I hate more than a little.
14:44:42 <Iceland_jack> That's understandable..
14:44:48 <crobbins> Shamar:  i would just close down any networking, proxying mumbo jumbo and make sure it's not interfering
14:45:01 <crobbins> pretty sure that's the technical term...yeah
14:45:03 <Shamar> my internet service provider "Fastweb" nat his user
14:45:12 <Shamar> :-)
14:45:19 <crobbins> Shamar: maybe try it via a proxy?
14:45:26 <Shamar> I've only XChat a cromium open
14:45:32 <Shamar> and cromium
14:45:38 <Shamar> on a Debian Wheezy
14:45:51 <crobbins> try an web proxy and see if you can hit it
14:46:14 <bitemyapp> whoa. weird things happen if I put $setup above the module description.
14:46:29 <Iceland_jack> What happens?
14:46:36 <crobbins> on a side note, any ideas why Closed Type Families is not working for me?  trying the examples from the docs
14:46:37 <crobbins> https://www.haskell.org/haskellwiki/GHC/Type_families#Closed_family_simplification
14:46:53 <crobbins> ClosedTypeFamilies.hs:9:7:
14:46:53 <crobbins>     Not in scope: type constructor or class ‘False’
14:46:53 <crobbins>     A data constructor of that name is in scope; did you mean DataKinds?
14:47:04 <crobbins> doesn't really make sense
14:47:19 <Iceland_jack> crobbins: Enable the DataKinds extension: {-# LANGUAGE DataKinds #-}
14:47:35 <Shamar> via webproxy it works...
14:47:39 <crobbins> Iceland_jack: ha, that was obvious
14:47:41 <crobbins> thanks!
14:47:47 <Iceland_jack> If you want to use True/False as types of kind Bool
14:47:52 <Iceland_jack> No problem
14:47:56 <crobbins> yeah now i get it
14:47:59 <crobbins> duh
14:48:07 <crobbins> hell, the compiler even told me to do that
14:48:20 <bitemyapp> Iceland_jack: it thinks the module should be Main instead of Database.Bloodhound.Client if I put $setup above the module description (running cabal haddock)
14:50:36 <bitemyapp> Iceland_jack: http://www.reddit.com/r/haskell/comments/2owull/having_trouble_getting_setup_preamble_for/
14:50:43 <Iceland_jack> bitemyapp: To make sure, you mean putting it above the module description {-| Module : ... -} and not just the module declaration?
14:51:17 <bitemyapp> Iceland_jack: it was above both.
14:51:22 <Iceland_jack> Interesting
14:51:23 <Shamar> btw, is there a way to configure the dist/ folder in cabal?
14:51:38 <bitemyapp> trying a different ordering
15:16:42 * hackagebot lmdb 0.1 - Lightning MDB bindings  http://hackage.haskell.org/package/lmdb-0.1 (dmbarbour)
15:16:44 * hackagebot lmdb 0.1.1 - Lightning MDB bindings  http://hackage.haskell.org/package/lmdb-0.1.1 (dmbarbour)
15:18:21 <Shamar> the answer was cabal build --builddir=distReplacement however is a bit annoing that in .cabal/config I can't redefine it
15:18:26 <jowens> sorry if solrize is still here, as we had a nice chat about this this morning, but hoping to get more thoughts from smart folks:
15:18:27 <jowens> Haskell has interesting internal data structures for List and Map that allow incremental updates, an example: "you have a data structure (List or Map) of 1M elements, you want to add 1k elements to that". I can understand in theory why this is useful, but: Where in practice is this useful? What kind of applications do incremental updates to Lists and Sets? I'd love to hear some suggestions.
15:20:03 <Cale> jowens: "updates" is a bit of a loaded term here -- the operations on lists and maps do *not* alter the original list or map.
15:20:07 <solrize> yeah i'm still here, your question was confusing in that it wasn't clear that you were specifically interested in adding lots of elements at once (i.e. it sounded like why would you want a functional DS in the first place).  anyway you could look at knuth vol 3 which is full of tons of merging examples
15:20:36 <Cale> jowens: But the operation to add an element to the beginning of a list is a primitive means of list construction
15:20:36 <jowens> @cale: i understand there's functional data structures under the hood.
15:20:36 <lambdabot> Unknown command, try @list
15:21:12 <jowens> solrize: well, there's 3 interesting scenarios from a parallel computing point of view.
15:21:26 <jowens> 1: add 1 element to large data structure
15:21:32 <jowens> 2: add a small number of elements to a large data structure
15:21:40 <Cale> So literally anything which uses lists in any fashion at all, unless it sticks only to empty ones, will involve (:) somehow.
15:21:42 <jowens> 3: merge 2 large data structures together
15:21:51 <jowens> 1 has no parallelism and the algorithms are well known
15:22:02 <jowens> 3 is probably better suited for "just rebuild both data structures together from scratch"
15:22:07 <jowens> 2 is more interesting from a research point of view
15:22:26 <jowens> from a non-List and -Set point of view, consider a spatial data structure like a BVH tree or k-d tree
15:22:38 <jowens> that represents a scene that you're trying to render
15:22:56 <jowens> the current state of the art is that if you move one object in a really complicated scene, you have to rebuild that spatial data structure from scratch
15:23:00 <jowens> (at least on GPUs)
15:23:05 <jowens> that is uncool
15:23:12 <gnusosa> Hi, another dumb and quick question, There is a way to create a type with validation? Like let's say can't construct the type if the Integer pass is longer than 10 digits.
15:23:23 <gnusosa> Sorry, I saw it somewhere but I can recalled from what book.
15:23:23 <jowens> cale: I'm looking for applications that might use, say, slicing and appending a lot.
15:23:40 <jowens> or concatenating, etc.
15:24:40 <Iceland_jack> gnusosa: You create a wrapper type and a "smart constructor" that performs the validation
15:24:42 <Cale> gnusosa: Generally, create a newtype, and hide the data constructor, instead only exposing a function which checks the property.
15:24:45 <jowens> cale: internally, functional languages appear to use RRB trees or finger trees or other data structures that are both a) functional and b) incrementally updatable
15:25:32 <Iceland_jack>     newtype MyInt = MkInt Int
15:25:32 <Iceland_jack>  
15:25:32 <Iceland_jack>     makeInt :: Int -> Maybe MyInt
15:25:32 <Iceland_jack>     makeInt n
15:25:36 <Iceland_jack>       | longerThan10Digits n = Just (MkInt n)
15:25:39 <Iceland_jack>       | otherwise            = Nothing
15:26:15 <Iceland_jack> Then as jowens said you hide the 'MkInt' constructor: this means that 'makeInt' is the only way to get a value of type MyInt
15:26:34 <Cale> Iceland_jack: maybe you mean me, not jowens :)
15:26:36 <jowens> ^jowens^Cale
15:26:45 <Iceland_jack> Yes
15:26:51 <Iceland_jack> as Cale said :)
15:27:12 <Cale> jowens: Yeah, Map and Set in particular are binary trees of bounded balance
15:27:39 <gnusosa> Oh that looks great Cale andIceland_jack.
15:27:43 <Iceland_jack> 'makeInt' would probably be called 'validate' something
15:28:08 <gnusosa> From looking at that syntax, I don't follow what calls makeInt in MyInt type.
15:28:17 <Cale> and I believe IntMap and IntSet (which are slightly more efficient but use only machine Int keys) use PATRICIA trees.
15:28:31 <Iceland_jack> gnusosa: 'MkInt n' creates a value of type MyInt
15:28:42 <jowens> Cale: Yes, and I'd like to think those are useful for doing incremental updates; but I'm trying to gather information on how those incremental updates are *actually used in practice*
15:28:54 <Cale> gnusosa: Note, what we're suggesting here is only for *runtime* checking
15:29:13 <jowens> (hi conal! he suggested ask here.)
15:29:33 <conal> jowens: (hi!)
15:29:42 <Cale> jowens: Well, are you asking why you'd want to insert a key/value pair into a Map?
15:29:51 <Cale> I'm confused :)
15:30:02 <jowens> i'm asking for an application scenario where that is actually done
15:30:14 <jowens> here's the problem for my research community:
15:30:16 <Cale> Okay, traversing a graph and collecting information about a path through it
15:30:41 <jowens> there aren't any apps that do dynamic data structure updates, because there are no data structures that support them, so no one writes those apps.
15:30:48 <Cale> Often you have a Map Vertex Vertex of predecessor relationships from which you can reconstruct the path afterward.
15:31:04 <piskrist> it appears hOpenPGP does not support assymetric encryption
15:31:11 <Cale> We use Map structures instead of mutable array-like structures all the time
15:31:17 <jowens> ok, for the purposes of ... subgraph isomorphism? greedy graph traversal?
15:31:26 <Cale> jowens: Or A* for instance
15:31:30 <jowens> yeahhh
15:31:32 <jowens> A* would be good
15:31:52 <Cale> http://hackage.haskell.org/package/astar-0.2.1/docs/src/Data-Graph-AStar.html#AStar
15:32:03 <jowens> ideally it would be something where we did bulk updates/inserts rather than one at a time, but then we might consider multiple A* paths at once.
15:32:04 <EvanR> you can use mutation i haskell if you think it would help
15:32:15 <Cale> You can look at my little A* implementation here, this record of mostly Maps is the state maintained by the algorithm
15:33:11 <Cale> Or for instance, maybe you want to represent finite automata
15:33:42 <flaggy> Hello. Instancing Random I need to create a randomR function, however, my data type has no meaningful range. Is there another Random class I should be looking at?
15:33:55 <lpaste> Cale pasted “Regular.hs” at http://lpaste.net/116209
15:34:26 * dfeuer offers Cale some hard pear cider.
15:34:29 <Cale> jowens: ^^ in that code, I use a bunch of Set values to represent an epsilon NFA
15:34:44 <jowens> cale: love it, that's a very nice example.
15:35:27 <gedringer> Is it possible in haskell to do: If a is true do b then c ?
15:35:45 <jowens> (does lpaste last for a long time?)
15:35:54 <Iceland_jack> gedringer: Control.Monad.when
15:35:55 <Iceland_jack>     when a $
15:35:55 <Iceland_jack>       b
15:35:55 <Iceland_jack>       c
15:35:58 <Iceland_jack>     
15:36:01 <Iceland_jack> is that what you're asking?
15:36:03 <gedringer> Cause I need to call my method again (recursion) and print a line of text but once I print the text I dont know how to call my method again :/
15:36:35 <Cale> jowens: I'm not sure how long. I've never visited a broken link to it, but I also wouldn't trust it to stay forever and ever.
15:36:37 <Iceland_jack> should have been, 'when a $ do'
15:36:49 <gedringer> not sure :P wait ok here's the line that gives me issues
15:37:05 <gedringer> printMyTree (TwoNode a left right) = printMyTree left ++ ( "[ " ++ show a ++ " ] " ) ++ printMyTree right
15:37:09 <EvanR> dfeuer: dont drink and deriving
15:37:15 <gedringer> So I want to put putstrln
15:37:30 <gedringer> on the brakets and show a, and after that
15:37:44 <gedringer> just run printMyTree left and then printMyTre right
15:37:47 <Iceland_jack> gedringer: The the parentheses aren't needed
15:37:49 <Cale> jowens: But yeah, whenever you want to represent a graph structure in Haskell, Map Vertex (Set Vertex) is a popular way to go.
15:38:12 <Cale> jowens: i.e. a map from vertices to their sets of neighbours
15:38:24 <EvanR> that works with cyclic graphs?
15:38:25 <dfeuer> EvanR, this isn't calculus!
15:38:32 <Cale> EvanR: yes
15:38:44 <jowens> cale: gotcha. thx.
15:38:48 <gedringer> okay so say I do this now: printMyTree (TwoNode a left right) = printMyTree left ++ putStrLn ( "[ " ++ show a ++ " ] " ) ++ printMyTree right
15:38:55 <EvanR> can you turn that into a container?
15:38:59 <EvanR> Functor instance
15:39:06 <gedringer> so putStrLn will work with whats in parentheseis
15:39:08 <Iceland_jack> gedringer: (++) works on lists/strings
15:39:10 <gedringer> but concatenation wont work
15:39:17 <Iceland_jack> putStrLn does not give you a String
15:39:25 <dfeuer> Cale, Joachim Breitner helped me out with that Data.Sequence <*> representation thing. Unfortunately, I haven't yet been able to get good constant factors out of it in monolithic contexts :-/
15:39:31 <Cale> jowens: Or more generally a lot of things which you'd be using pointers in the heap for, if nothing else, can be translated to use a Map instead of the heap.
15:39:35 <gedringer> yes, so how can I print the line and then run the rest of the code? which is printMyTree
15:39:37 <Iceland_jack> gedringer: something like this
15:39:37 <Iceland_jack>     printMyTree (TwoNode a left right) = do
15:39:37 <Iceland_jack>       putStrLn ("[ " ++ show a ++ " "])
15:39:37 <Iceland_jack>       printMyTree left
15:39:40 <Iceland_jack>       printMyTree right
15:39:50 <dfeuer> BBIAB.
15:39:59 <Cale> dfeuer: Well, it was probably worth trying anyway
15:40:21 <gedringer> :O I tried doing that but on one line maybe that was the problem, let me try again :P one sec
15:40:47 <jowens> cale: got it. that is a good lead for me thinking of more. incremental graphs certainly make sense (say, social network where friend links are established and deleted)
15:41:33 <Cale> jowens: The advantages of this being that you can easily undo anything. Recursive algorithms which do a lot of pointer arithmetic often waste a lot of time putting pointers back the way they were after recursive calls, and that isn't required if you're using structures that are designed to be efficiently immutable.
15:42:16 <Cale> (of course, you're also paying a lot up front for the space and reconstruction of the structure)
15:42:34 <jowens> cale: well, "efficient" and "mutable" graph traversal algorithms are pretty much mutually exclusive. :)
15:43:18 <gedringer> yayyy it works Iceland_jack :D Thank you a mill!!!!
15:43:27 <Iceland_jack> No problem gedringer
15:43:27 <Cale> More important I suppose is that it's much harder to screw up, while being not *that* much more costly.
15:43:56 <piskrist> how do I run a haskell code with library installed in sandbox?
15:44:20 <Cale> I'd much rather try to figure out the problem with a buggy algorithm that manipulated immutable Map structures than a buggy algorithm which manipulates pointers in the heap.
15:44:54 <piskrist> git clone git://blah/hs-lib; cd hs-lib; cabal install; echo "import hs-lib \n main = print 'do stuff'" > test.hs; runhaskell test.hs
15:45:01 <piskrist> can't find the hs-lib
15:45:25 <jowens> i think the highest-performing graph engines (e.g. Ligra, Galois) generally assume an immutable graph, and as you say, do work up front to put it in a compute-friendly structure.
15:45:37 <kadoban> piskrist: 'cabal exec runhaskell test.hs' should work
15:46:47 <piskrist> kadoban: fails with rc=127
15:46:51 <benzrf>     Illegal polymorphic or qualified type:
15:46:51 <benzrf>       forall t. ModInfo String t String -> EventMap String t String
15:46:51 <benzrf>     Perhaps you intended to use LiberalTypeSynonyms
15:46:58 <benzrf> afaik there are no synonyms here. wtf?
15:47:50 <piskrist> kadoban: thanks, looks like the 127 is some weird stuff with my compiler.
15:48:50 <piskrist> oh this is fun. I already have directory test/ so test.hs fails on that. But cabal exec is still failing with t.hs as well
15:51:11 <benzrf> p-please help
15:55:20 <piskrist> oh, it's cabal exec ghc t.hs
16:00:49 <mietek> Is @benarmston on IRC?
16:00:58 <mietek> By which I mean the GitHub username.
16:01:34 <gnusosa> Cale: Iceland_jack: again, with my past question, I finally understood what you meant, but I want something like:
16:01:44 * hackagebot lmdb 0.2.0 - Lightning MDB bindings  http://hackage.haskell.org/package/lmdb-0.2.0 (dmbarbour)
16:01:46 * hackagebot estimator 1.0.0.1 - State-space estimation algorithms such as Kalman Filters  http://hackage.haskell.org/package/estimator-1.0.0.1 (JameySharp)
16:01:50 <gedringer> Can anyone help me with this? :/ I tried figuring it out but just can't seem to
16:02:13 <gedringer> I need to print my 2-3-4 tree in either up-down fassion or left-right
16:02:17 <gedringer> but all I get is this
16:02:18 <gedringer> http://pastebin.com/if5P0RKv
16:02:22 <trap_exit> how does one build a query langauge (like SQL) with haskell types? SQL is not statically typed. I want the static typing of Haskell -- but operators like join/projection need to "create" new types, which seems probelmatic.
16:02:36 <benzrf> trap_exit: row types probly
16:02:43 <benzrf> er, row polymorphism i guess
16:02:44 <gnusosa> data ID = Id10
16:02:55 <trap_exit> benzrf: is this supported in haskell?
16:03:03 <gedringer> I tried using reinH suggestion but to no avail
16:03:06 <benzrf> probably not without fucktons of extensions and hacks =D
16:03:07 <gnusosa> where I pass Prelude> ID 1234568910
16:03:10 <gnusosa> and it errors
16:03:16 <trap_exit> wtf
16:03:17 <trap_exit> https://github.com/leonidas/codeblog/blob/master/2012/2012-02-17-concatenative-haskell.md ?
16:03:22 <cite-reader> No, Haskell doesn't have row polymorphism. There's Ermine, though I believe it's not yet fully baked.
16:03:25 <trap_exit> I have never even heard the term 'row polymorphism' until today
16:03:27 <benzrf> trap_exit: it's a type system feature that allows for interacting with key/value stuff basically
16:03:35 <benzrf> trap_exit: the idea is you can have a type like
16:03:46 <benzrf> {field1 :: Int, field2 :: String}
16:04:04 <geekosaur> gnusosa, I see there a type constructor ID and a data constructor Id10 not taking any parameters?
16:04:08 <trap_exit> yeah, we need sometign like that for joins / projections
16:04:13 <benzrf> ^this is the type of, i.e., {field1: 3, field2: "foo"} in json
16:04:21 <benzrf> er, e.g.
16:04:27 <benzrf> trap_exit: that's row types.
16:04:33 <gnusosa> geekosaur: sorry data ID = id10 Int
16:04:34 <benzrf> row /polymorphism/ looks like:
16:04:34 <trap_exit> wtf is ermine ?
16:04:34 <ReinH> gedringer: You need to keep track of indentation
16:04:38 <trap_exit> http://ermine-language.github.io/ermine/
16:04:48 <ReinH> starting at 0 and then increasing for each level in the tree
16:04:54 <geekosaur> then your data constructor is Id10, not ID
16:04:55 <trap_exit> benzrf: hmm, and in relation to haskell, what is the best haskell / sql dsls can do for this?
16:05:04 <benzrf> trap_exit: {field1 :: Int, field2 :: String | rest} -> {field1 :: String | rest}
16:05:11 <ReinH> and then use the indentation level to add space to the beginning of the line
16:05:24 <benzrf> trap_exit: that^'s parametric over the remainder of the value that isnt field1 or field2
16:05:30 <trap_exit> benzrf: yes! that's what the type signature needs to sorta look like
16:05:33 <geekosaur> ID is the name of the type, Id10 is the name of the data constructor. like Maybe is a type constructor and its data / value constructors are Nothing and Just
16:05:41 <benzrf> trap_exit: purescript does this for js interfacing
16:05:42 <trap_exit> benzrf: right, ... and what haskell extensions will let me do this? :-)
16:05:47 <benzrf> trap_exit: none of them :)
16:05:56 <gnusosa> geekosaur: oh ok so something like data id10 = id10 Int, but I want it to negate the creation of this type if the Integer passed is more than 10 digits long.
16:06:04 <trap_exit> benzrf: I bet template haskell, with some hacking, will
16:06:17 * benzrf ducks and covers
16:06:30 <gedringer> ReinH that's what I was thinking :( But how can I store a value like i = 0 and then increment it? I could use it somehow in an if statement, if i = 1 then it's root, if i = 2 print two elements with spacing between
16:06:59 <geekosaur> as someone told you earlier, you need to hide the data constructor and provide a smart constructor
16:07:29 <geekosaur> Haskell data constryctors cannot apply constraints unless they're expressible in the type system. you *could* express that one in the type system, with a number of extensions, but it's paunful
16:07:32 <trap_exit> cite-reader: wtf is ermine? I'm looking all over https://github.com/ermine-language/ermine ... and I don't see sample code / language features
16:07:51 <cite-reader> trap_exit: Yeah, that's kind of what I meant by "not fully baked".
16:08:00 <geekosaur> isn't that edwardk's pet language?
16:08:27 <cite-reader> geekosaur: Yep, that's the one. I brought it up because it uses row types to model SQL interaction.
16:08:27 <Iceland_jack> gnusosa: Use 'mkInt 1234568910', the code I posted earlier solves this
16:08:48 <gnusosa> oh ok
16:08:52 <piskrist> benzrf: is this related to the genericderivations of yaml?
16:08:54 <gnusosa> Thanks :)
16:09:05 <Iceland_jack> Then you get Nothing back once you've implemented the function longerThan10Digits :: Int -> Bool
16:10:32 <trap_exit> I do not know how I stumbled across https://github.com/leonidas/codeblog/blob/master/2012/2012-02-17-concatenative-haskell.md ... but it's fucking badass
16:10:43 <Iceland_jack> (The branches in my example should be reversed)
16:10:57 <trap_exit> benzrf: so what is the state of the art for a sql-like / datalog-like / query DSL in haskell ?
16:11:18 <gnusosa> Iceland_jack: geekosaur: It worked thanks so much.
16:11:22 <gnusosa> :D
16:11:30 <gnusosa> I understand now that I runned in the repl
16:12:32 <benzrf> trap_exit: heck if i know
16:12:33 <benzrf> ;)
16:12:52 <fragamus_> hi I need to generate pairwise combinations of a set of elements
16:13:37 <Iceland_jack> fragamus_: ?
16:13:37 <Iceland_jack> > liftA2 (,) [1..4] [1..4]
16:13:38 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
16:13:49 <fragamus_> http://stackoverflow.com/questions/8212253/most-efficient-way-to-create-the-data-set-of-all-pairs-of-elements-in-a-set
16:17:48 <piskrist> trap_exit: maybe you could use formatting to generate the sql in type safe way
16:20:48 <Lokathor> hey everyone. I'm working on a dice roller program thing
16:20:56 <Lokathor> so I've got a function, randInt low high = getStdRandom (randomR (low,high))
16:21:14 <Lokathor> and i want to be able to, given a number of dice and a number of sides, generate a list of results
16:21:34 <Iceland_jack> Lokathor: Look at "replicateM"
16:21:37 <Iceland_jack> @ty replicateM
16:21:37 <lambdabot> Monad m => Int -> m a -> m [a]
16:21:49 <Iceland_jack> You can also use "randomRIO (low, high)" instead of getStdRandom
16:22:07 <benzrf> idk which RIO i want
16:22:42 <Denommus> damn
16:22:46 <Lokathor> does RIO just always use the standard random?
16:22:57 <Denommus> I can't get ghcjs and ghc-mod working in the same global environment
16:23:20 <Iceland_jack> Lokathor: yes
16:23:40 <Iceland_jack> In fact this is the definition of 'randomRIO'
16:23:40 <Iceland_jack>   randomRIO :: (a,a) -> IO a
16:23:41 <Iceland_jack>   randomRIO range  = getStdRandom (randomR range)
16:25:14 <pecanpy> if i have a value in a where block, is it possible for it to be evaluated more than once?
16:25:48 <Lokathor> perfect, dice x y = replicateM x (randInt 1 y)
16:30:07 <Iceland_jack> pecanpy: With GHC the result will be shared (not guaranteed by the standard)
16:30:18 <pecanpy> thanks
16:31:09 <pecanpy> i thought i had read something about that previously. something like that being a motivation for the monomorphism restriction? that without it you might have to recompute values or something.
16:32:15 <Lokathor> does anyone know why i might not be able to install the network-fancy package on windows
16:32:19 <Lokathor> via cabal install
16:33:36 <nshepperd> the monomorphism restriction is because if you write something that's polymorphic by accident, it might be slower than expected, since values can't be shared
16:34:31 <pecanpy> yea: "it solves ... one semantic problem (without the restriction, there would be some repeated evaluation where a programmer might expect the evaluation to be shared)."
16:36:37 <nshepperd> a lot of people don't like the restriction apparently, but I think it's ok
16:37:11 <nguyeng> My cabal packages got seriously screwed up. What do i have to delete to wipe out the global and local packages on linux? New to haskell. Sorry.
16:38:04 <jfischoff> nguyeng: you can delete your user package db but do not mess with the global one
16:38:47 <jfischoff> well I guess I need to know what is in what
16:39:04 <jfischoff> but as a general rule, don't mess with your global dc
16:39:06 <jfischoff> db
16:39:24 <jfischoff> also you can just unregister the bad packages
16:39:30 <jfischoff> usually
16:39:50 <erikd> nguyeng: 'rm -rf ~/.cabal/lib/* ~/.ghc/*' is probably what you want
16:40:28 <jfischoff> until we know what is wrong, it won't be clear, paste the errors
16:40:31 <jfischoff> @lpaste
16:40:31 <lambdabot> Haskell pastebin: http://lpaste.net/
16:42:32 <nguyeng> jfischoff: no errors exactly. I was trying to use aeson and http-conduit. I couldn't import the two of them at the same time.
16:42:50 <jfischoff> well what was the error?
16:43:17 <jfischoff> worth pointing out that some packages cannot be used together
16:43:32 <jfischoff> If they have conflicting deps
16:43:46 <nguyeng> jfischoff: It would say unable to find module Data.Aeson, so i would cabal install aeson. Then it would switch to could not find module Network.HTTP.Conduit, so I would cabal install http-conduit. Then the process would repeat.
16:44:15 <jfischoff> hmm
16:44:26 <nguyeng> right after doing the cabal install importing them individually works in ghci
16:44:48 <jfischoff> are you using sandboxes?
16:46:34 <nguyeng> Yes, but after the problem started occuring I did everything outside of the project directory
16:46:42 <nguyeng> just using ghci to try importing
16:48:34 <jfischoff> So it worked out side of the sandbox if I understand correctly?
16:49:04 <nguyeng> No, it didn't work.
16:49:51 <jfischoff> brb
16:53:08 <marchelzo_> @pl \f g c -> f c + g c
16:53:09 <lambdabot> liftM2 (+)
16:53:21 <marchelzo_> >.<
16:59:59 <marchelzo_> Where is if' from?
17:01:27 <Iceland_jack> marchelzo_: It's defined in base as "bool", only flipped
17:01:30 <Iceland_jack> :t bool
17:01:30 <lambdabot> a -> a -> Bool -> a
17:01:46 <Iceland_jack> > bool 'f' 't' True
17:01:47 <lambdabot>  't'
17:01:49 <marchelzo_> ah, sweet
17:01:49 <Iceland_jack> > bool 'f' 't' False
17:01:50 <lambdabot>  'f'
17:01:50 <marchelzo_> thanks
17:02:01 <Iceland_jack> No problem
17:03:44 <wswiss> @pl \(p',w') -> return (go p' $! w <> w')
17:03:44 <lambdabot> uncurry ((return .) . (. (w <>)) . ($!) . go)
17:04:34 <Geekingfrog> Is there any way to see from ghci the instance implementation of a typeclass? For example `:i Maybe` gives me a list of instances, how can I see how they're implemented?
17:04:34 <wswiss> @pl \(p',w') -> go p' $! w <> w'
17:04:34 <lambdabot> uncurry ((. (w <>)) . ($!) . go)
17:05:03 <Iceland_jack> Geekingfrog: You normally read it on Hackage
17:05:39 <Iceland_jack> Although lambdabot has a very limited and sometimes not accurate feature
17:05:42 <Iceland_jack> @src [] fmap
17:05:42 <lambdabot> fmap = map
17:06:08 <Iceland_jack> afk
17:06:31 <Iceland_jack> (also)
17:06:32 <Iceland_jack> @src Maybe fmap
17:06:32 <lambdabot> fmap _ Nothing  = Nothing
17:06:32 <lambdabot> fmap f (Just a) = Just (f a)
17:07:27 <pecanpy> Iceland_jack: where is that bool function you were discussing?
17:07:33 <Iceland_jack> Data.Bool
17:08:05 <Iceland_jack> I should have mentioned that, also it's new in 7.8 I believe
17:08:34 <pecanpy> huh. thats weird. i searched it on Hoogle before asking and it was not there
17:08:51 <Iceland_jack> Hoogle is also not complete in that regard
17:08:55 <wswiss> @pl (\a  -> go (fa  a ) w)
17:08:55 <lambdabot> flip go w . fa
17:08:59 <pecanpy> oh :/
17:11:33 <waressearcher2> am I in freenode ?
17:11:48 <Geekingfrog> Iceland_jack, I don't find the implementation. On hackage I see all the instances of Maybe, and link to their typeclass but when clicking on applicative I land on the generic applicative definition.
17:11:49 <marchelzo_> waressearcher2: yes
17:12:29 <waressearcher2> I always forget second "l" and join #haskel
17:13:27 <Iceland_jack> Geekingfrog: If you want that specific one you can try Googling "instance Monad Maybe where"
17:14:13 <Geekingfrog> ok, I'll keep digging thanks for the hints
17:21:56 <pecanpy> waressearher2: dude, you're not supposed to tell people about #haskel
17:22:23 <pecanpy> its a secret. no one go there
17:23:59 <pecanpy> oh god. i was just kidding but: "#haskel Cannot join channel (+i) - you must be invited"
17:24:15 <ab9rf> so much for you ever getting invited, you spilled the beans
17:24:26 <pecanpy> noooooo
17:24:38 <pecanpy> o\
17:26:43 <Iceland_jack> Haha holy..
17:47:34 <pecanpy> over what time period is this page counting downloads? https://hackage.haskell.org/packages/top
17:51:52 * hackagebot hspec-core 2.1.1 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.1.1 (SimonHengel)
17:51:54 * hackagebot validation 0.4.2 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.4.2 (TonyMorris)
17:51:56 * hackagebot hspec-discover 2.1.1 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.1.1 (SimonHengel)
17:51:58 * hackagebot hspec 2.1.1 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.1.1 (SimonHengel)
18:26:53 * hackagebot hspec-core 2.1.2 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.1.2 (SimonHengel)
18:31:39 <lifter> Got an interesting problem. On Mac OS X, I'm using the ansi-terminal lib to change the title of the terminal window ever second. When I run my program in GHCi, the title updates. Outside of GHCi, the title never updates until I exit my program. Why might this be?
18:31:53 * hackagebot hspec-discover 2.1.2 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.1.2 (SimonHengel)
18:31:55 * hackagebot hspec 2.1.2 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.1.2 (SimonHengel)
18:33:19 <dfeuer> lifter, something about terminal modes maybe?
18:33:42 <dfeuer> Could GHCi already be putting it in the mode you want, and you need to do that yourself elsewhere?
18:33:49 <dfeuer> Purish speculation!
18:33:56 <lifter> yeah it must be something like that
19:13:11 <benzrf> ok pls help
19:13:28 <benzrf> isnt there an extn for deferring complaints about non-fully-applied type syns
19:23:58 <laptoa> when I run a program with main = putStrLn "Press any key" >> getLine >>= putStrLn
19:24:07 <laptoa> it prints after I press enter
19:24:28 <laptoa> why, and how can I have it not do that
19:24:35 <ReinH> laptoa: hSetBuffering stdout LineBuffering
19:24:41 <laptoa> thanks
19:24:41 <ReinH> http://hackage.haskell.org/package/base-4.7.0.1/docs/System-IO.html#v:hSetBuffering
19:25:27 <erikd> laptoa: you can also do "hFlush stdout" in the appropriate place
19:25:44 <laptoa> okay thanks
19:31:12 <recurrence> Haskell is pretty damn awesome
19:34:32 <pyed_> ...and complicated
19:35:06 <zomg> Not sure if it's really that complicated
19:35:21 <zomg> just different
19:36:44 <pyed_> I'm newbie, I read couple of books in the last 4 months or so, and took the FP101x, and the last lab made me hate my self, it was about (Concurrent)
19:37:08 <L8D> CONCURRENT WHAT?~!
19:37:35 <pyed_> I couldn't finish the homework my self and that made me feel bad about my self
19:38:02 <pyed_> concurrency
19:38:19 <L8D> so using mvars and tvars and threads?
19:38:27 <L8D> and additional abstractions
19:39:02 <pyed_> I couldn't understand the whole thing, but it's not as deep as you think
19:39:09 <pyed_> here's the solution I found
19:39:35 <pyed_> https://github.com/rogerturner/FP101x/blob/master/pmctemplate.hs
19:40:03 <pyed_> I was suppose to implement action, stop, atom, fork, par, (>>=) instance for Concurrent
19:40:18 <pyed_> and roundRobin
19:40:56 <pyed_> I was stuck on implementing atom
19:41:05 <pyed_> fork and par was fairly easy
19:41:35 <pyed_> >>= instance was impossible to me
19:42:07 <pyed_> I keep saying instance when I mean implementation for >>=, the instance is of Monad
19:42:34 <benzrf> pls   h  e l p
19:44:28 <benzrf> i need to know the extension where it lets you use non fully applied type synonyms if their final usages are fully applied or sth
19:44:37 <trap_exit> yo
19:44:51 <trap_exit> is there any type-safe query langauge for haskell ? instead of sql, which treates all as strings
19:47:46 <erikd> trap_exit: i really like esqueleto
19:48:22 <glguy> pyed_: Have you heard of the MTL?
19:48:29 <erikd> it an sql-like EDSL that is more type safe than sql
19:48:50 <codygman> What would be the best way to count how many times each distinct value in a hashmap occurs?
19:48:51 <pyed_> glguy, nope
19:49:11 <trap_exit> erikd: recommended reading for esqueleto that demonstrates its powers ?
19:49:28 <erikd> the hackage docs are probably the best
19:49:54 <pyed_> glguy, you mean Monad Transformer Library
19:49:59 <Hermit> I want to interact with a process and parser it's output, but it has context specific prompts I'd like to handle as they come out, since the rendering of the information depends on how they are answered. What parser library should I use, or how should I approach it in a tidy idiomatic way?
19:50:18 <pyed_> I think of it as advanced topic that I don't currently need
19:50:37 <pyed_> but I think I understand the idea of it
19:50:58 <glguy> pyed_: That's fine, if you knew any of it I was going to point out the connection between what it has and what you're doing
19:50:58 <pavonia> trap_exit: Have you checked out HaskellDB?
19:51:11 <glguy> but if you haven't explored it yet I won't distract
19:51:17 <trap_exit> pavonia: I have not
19:51:26 <pyed_> glguy, maybe I should
19:53:28 <indiagreen> benzrf: LiberalTypeSynonyms? it's the only one which seems to mention “partial” in its description, as reported by Ctrl-F
19:54:16 <glguy> ?unmtl Cont Action a
19:54:16 <lambdabot> (a -> Action) -> Action
19:54:56 <pyed_> o_O
19:55:29 <jle`> chrisdone: i too have publicly lamented the lack of a prefix version of (=<<) akin to (<$>)'s fmap. good job
19:55:38 <jle`> i probably should have just submitted a ticket too
19:58:58 <benzrf> indiagreen: thank u
19:59:53 <pyed_> glguy, the problem that I'm facing with haskell as newbie is that haskell is generally so abstract that I keep ask my self, will I ever need to do that ? and when ? and why ?
20:01:04 <glguy> Don't worry, you'll get that in lots of languages
20:01:27 <Taneb> glguy, how's that meant to make anyone stop worrying? :P
20:01:57 <pyed_> naah, I didn't feel the same way with many other languages I learned
20:02:28 <pyed_> Haskell is different, way too much
20:02:52 <pyed_> but it's beautiful tho, and that's what's keeping me going
20:03:12 <pyed_> and that's "aha" moments are priceless
20:04:38 <indiagreen> glguy: Haskell is great for DSLs, so lots of libraries naturally end up as DSLs composed of pieces one could've never thought of composing in the first place
20:05:34 <indiagreen> in most other languages, e.g. lenses would've either been baked into language or simply non-existent
20:05:46 <linocisco> DSL= Damn Small Linux?
20:06:01 <indiagreen> Domain Specific Language
20:06:24 <linocisco> what domain? not so clear
20:07:11 <zomg> zombo.com
20:07:31 <Taneb> linocisco, if you have a problem, sometimes it's possible to make a little language that is very good at solving that problem
20:07:43 <Taneb> Haskell is very good at letting you make these languages
20:07:56 <indiagreen> even if the problem is simply generation of PDF files or something like this
20:08:07 <trap_exit> haskell is the best
20:08:19 <trap_exit> I can not imagine using anything but haskell
20:08:29 <indiagreen> and we end up with a HTML-generating language, PDF-generating language, parsers-writing language, doing-math language (see numeric-prelude), etc.
20:08:31 <linocisco> why it is best?
20:08:43 <zomg> trap_exit: Congratulations, your indoctrination to the cult of Haskell is complete =)
20:10:11 <benzrf> trap_exit: but you cannot trap_exit in haskell
20:10:34 <trap_exit> I think you can, but it'll be IO a instead of being pure
20:18:10 <linocisco> ruby vs python vs Perl vs Java vs php vs C vs Redis vs Node.js
20:18:20 <linocisco> ruby vs python vs Perl vs Java vs php vs C vs Redis vs Node.js vs Haskell
20:19:35 <Cale> http://i.imgur.com/uZYVbMG.gif
20:20:50 <trap_exit> by vs, do you mean "is inferior to" ?
20:24:26 <hodapp> trap_exit: that'd be strange, Node is really high in that list
20:43:45 <zomg> hodapp: probably because you can run haskell on node with ghcjs ;)
20:46:11 <fragamus> question:    foo <$> bar <$> baz <$> quux   _is the same as_    (foo . bar . baz) <$> quux    _right?_
20:47:46 <exio4> <$> is fmap, which for functions is function composition; looks like so
20:48:01 <bms1> fragamus: yes
20:48:27 <fragamus> cool
20:48:50 <bms1> (as long as foo, bar, and baz are functions)
20:48:53 <fragamus> I think the   (foo . bar . baz) <$> quux     looks better
20:51:17 <L8D> @pl foo <$> bar <$> baz <$> quux
20:51:17 <lambdabot> foo <$> bar <$> baz <$> quux
20:51:32 <L8D> @pl (foo . bar . baz) <$> quux
20:51:33 <lambdabot> foo . bar . baz <$> quux
20:51:36 <L8D> -.-
20:52:13 <L8D> @pl (foo . bar . baz) `fmap` quux
20:52:14 <lambdabot> (foo . bar . baz) `fmap` quux
20:52:25 <exio4> there are no bound variables
20:52:35 <L8D> @pl foo `fmap` bar `fmap` baz `fmap` quux
20:52:35 <lambdabot> foo `fmap` bar `fmap` baz `fmap` quux
20:52:43 <exio4> all variables in that expression are free
20:52:46 <fragamus> how about       join $ allMaybes <$> fobarbaz <$> quux
20:52:47 <L8D> why is @pl never useful
20:53:05 <exio4> @pl \foo bar -> (foo (foo bar)) . (foo bar)
20:53:05 <lambdabot> ap =<< ((.) .) . join (.)
20:53:25 <fragamus> o.O
20:53:25 <exio4> :t \foo bar -> (foo (foo bar)) . (foo bar)
20:53:26 <lambdabot> ((a -> a) -> a -> a) -> (a -> a) -> a -> a
20:55:10 <fragamus>  join $ allMaybes <$> foobarbaz <$> quux      _or_      id =<< allMaybes <$> foobarbaz <$> quux
20:55:37 <jle`> fragamus: it's not exactly the same, as the first one is now parametric on foo and bar and baz and quuz
20:55:42 <jle`> *quux
20:55:53 <jle`> but if those things are already known to be functions, then yes
20:56:07 <jle`> oh, bms1 already said so
20:56:09 <fragamus> which looks nicer
20:56:29 <jle`> :t \f g h -> f <$> g <$> h
20:56:30 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
20:56:38 <jle`> :t \f g h -> f . g . h
20:56:38 <lambdabot> (b -> c) -> (b1 -> b) -> (a -> b1) -> a -> c
20:56:56 <jle`> we like to use . when we can
20:57:02 <jle`> just like we like to use map for lists instead of fmap
20:57:16 <benzrf> hmmmmm
20:57:40 <benzrf> why cant GHC figure out that `Monad (StateT s m)' implies `Monad m'
20:57:44 <fragamus> I do like .
20:57:54 <fragamus> not so sure about map
20:58:23 <Taneb> benzrf, it's not impossible to, with certain extensions, write "instance Monad (StateT s Set)"
20:58:33 <benzrf> shriek
20:58:40 <jle`> ah yeah.  someone might one day come along and write an instance like that
20:58:53 <jle`> cause all typeclasses are open
20:59:00 <benzrf> god fucking dammit
20:59:04 <jle`> ikr
21:00:47 <benzrf>     Could not deduce (Monad n) arising from a use of ‘return’
21:00:48 <benzrf>     from the context (Monad (StateT s n), Monad (StateT t n))
21:02:22 <benzrf> aha
21:02:26 <benzrf> i left out a monad constraint
21:05:25 <glguy> benzrf: You aren't writing Monad (StateT s n) =>  in your type signature, are you?
21:05:42 <benzrf> glguy: i am
21:05:59 <benzrf> glguy: well, not quite
21:06:02 <glguy> You can drop that, you only need to write: Monad n =>
21:06:10 <benzrf> glguy: StateT is instantiating a class
21:06:26 <benzrf> and the class sez `Monad (m s n)'
21:16:09 <benzrf> :t StateT
21:16:10 <lambdabot> (s -> m (a, s)) -> StateT s m a
21:16:14 <benzrf> hrumph
21:20:33 <benzrf> aauuuuuugh
21:20:37 <benzrf> why is my code so completely shit
21:20:42 <benzrf> i am clearly doing this wrong!!
21:21:39 <fragamus> be calm
21:21:45 <fragamus> the strippers are on their way
21:31:10 <benzrf> https://gist.github.com/376e7a9e7e4a8042baa4 what have i made
21:32:01 <dmj`> benzrf: you made twister
21:32:35 <dmj`> game or movie... that is the question
21:34:12 <benzrf> i was motivated to write that by thinking about what you'd need for per-pipe state in pipes
21:34:27 <benzrf> and i got thinkin about what the sufficient class would be
21:34:42 <benzrf> i wonder if theres a principled way to capture the behavior im looking for...
21:37:29 <gamegoblin> Why aren’t Double and Float members of Bounded?
21:38:05 <AlecTaylor> o.O Agda is interesting
21:39:39 <benzrf> night
21:40:56 <gamegoblin> Anyone? Ideas on why Double and Float aren’t members of Bounded?
21:41:24 <indiagreen> gamegoblin: no idea, but it was discussed on Haskell-cafe before
21:41:32 <indiagreen> https://www.haskell.org/pipermail/haskell-cafe/2007-November/035299.html
21:41:39 <indiagreen> going to read it now, I'm curious too
21:43:48 <indiagreen> “Basically, it's not Bounded, not for a particular reason, but just because it's rather broken from a Haskell point of view anyway, IMHO.”
21:45:06 <ab9rf> it was discussed in 2005 too :)
21:46:10 <ab9rf> defining succ and pred for float & double seems a bit fishy too
21:46:44 <crobbins> has anyone successfully built ghc to support OverloadedRecordFields?  tried to checkout the wip/orf-new branch but the build is failing on me...quite mysteriously
21:48:07 <gamegoblin> How can I get an IEEE floating point infinity in haskell? Only way I can think of it is `read "Infinity"` and that seems hacky
21:48:44 <Iceland_jack> > 1/0
21:48:46 <lambdabot>  Infinity
21:52:01 * hackagebot gitignore 1.0.1 - Apply GitHub .gitignore templates to already existing repositories.  http://hackage.haskell.org/package/gitignore-1.0.1 (RickyElrod)
21:57:01 * hackagebot relational-record 0.0.1.0 - Meta package of Relational Record  http://hackage.haskell.org/package/relational-record-0.0.1.0 (KeiHibino)
22:01:17 <gamegoblin> Iceland_jack: still seems a bit hacky...
22:01:24 <gamegoblin> Iceland_jack: is there no infinity constant defined somewhere?
22:01:53 <gamegoblin> :t 1/0
22:01:54 <lambdabot> Fractional a => a
22:04:39 <Iceland_jack>     pattern Infinity = 1/0
22:04:39 <Iceland_jack> ;)
22:06:56 <Iceland_jack> (anything like that won't work until we have explicitely bidirectional patterns though)
22:07:01 * hackagebot http-client-openssl 0.2.0.1 - http-client backend using the OpenSSL library.  http://hackage.haskell.org/package/http-client-openssl-0.2.0.1 (MichaelSnoyman)
22:07:11 <Iceland_jack> *explicitly
22:09:11 <Iceland_jack> pattern Infinity <- ((== 1/0) -> True) where
22:09:11 <Iceland_jack>         Infinity =  1/0
22:10:07 <jle`> does IEEE really have different infinities compare as equal
22:10:09 <Iceland_jack> 'infinity' is not part of base though (afaik)
22:10:30 <Iceland_jack> There are only two different infinities:
22:10:31 <Iceland_jack> > (1/0) == (-1/0)
22:10:33 <lambdabot>  False
22:10:35 <jle`> i always forget this
22:10:48 <jle`> > (1/0) == (2/0)
22:10:49 <lambdabot>  True
22:10:56 <Iceland_jack> It's the zero's the are equal
22:11:08 <jle`> hm?
22:11:32 <Iceland_jack> (1/0) and (2/0) are the same infinity
22:11:48 <jle`> yeah.  just seemed a bit odd
22:11:49 <jle`> oh well
22:11:55 <jle`> i guess not any odder than 1/0 == 1/0
22:12:11 <c_wraith> I'm sure one of them is twice the size of the other.
22:12:29 <jle`> :P
22:12:41 <Iceland_jack> They're not real numbers so scrap your intuition :)
22:13:02 <c_wraith> It's just that when you double the size of an infinity, it doesn't change anything.
22:13:16 <c_wraith> you need exponentials to get ugly!
22:13:48 <glguy> If 1/0::Float isn't big enough you can always go with Double :)
22:14:03 <jle`> but what if Double isn't big enough...
22:14:15 <jle`> import Data.Quadruple
22:17:02 * hackagebot conduit-extra 1.1.5 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.5 (MichaelSnoyman)
22:17:04 * hackagebot resourcet 1.1.3.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.3.1 (MichaelSnoyman)
22:23:41 <Welkin> jle`: then use Ratio
23:06:51 <pavonia> I'm compiling a Gtk GUI program with LD-Options -mwindows, so that the final binary doesn't start with an extra console window on Windows. The problem is, when my program quits, it crashes with an error message "<stdout>: hPutChar: invalid argument (Bad file descriptor)". How can this error be resolved?
23:17:04 * hackagebot relational-query 0.0.1.1 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.0.1.1 (KeiHibino)
23:19:38 <fugyk> What does (->) mean
23:21:22 <pavonia> In what context?
23:21:55 <Cale> fugyk: It's the type constructor for functions
23:21:55 <fugyk> instance Fluffy ((->) t) where furry = error "todo"
23:22:08 <Cale> (->) a b means the same thing as a -> b
23:22:15 <shachaf> "(->) a b" means the same as "a -> b"
23:24:34 <fugyk> But it is with type. How can type return another type
23:25:48 <tommd> fugyk: It isn't a type, it's a type constructor.
23:26:33 <trap_exit> are happstack questions appropriate here, or should they be a different channel?
23:27:05 * hackagebot persistable-record 0.0.1.1 - Binding between SQL database values and haskell records.  http://hackage.haskell.org/package/persistable-record-0.0.1.1 (KeiHibino)
23:27:08 <glguy_> fugyk: If you explain more about what you're trying to do or understand we might be able to help more
23:27:22 <fugyk> https://tonymorris.github.io/blog//posts/20-intermediate-haskell-exercises/
23:27:26 <fugyk> Exercise 3
23:27:32 <glguy_> trap_exit: You can certainly give it a shot. I don't know if there is a happstack specific channel, but in the worst case no one will know the answer
23:27:45 <pavonia> trap_exit: There is #happs
23:27:52 <trap_exit> so it's not offtopic
23:27:53 <trap_exit> good
23:28:29 <trap_exit> is there a good way to combine haste or fay with happstack? I want client side to be rich, rather than just static forms
23:29:01 <glguy_> fugyk: Bummer, github pages are down
23:29:22 <fugyk> class Fluffy f where furry :: (a -> b) -> f a -> f b
23:29:35 <fugyk> instance Fluffy (EitherLeft t) where furry = error "todo"
23:29:50 <fugyk> replace error "todo"
23:30:14 <glguy_> and what is EitherLeft?
23:30:52 <shachaf> glguy_: The github.io link works fine for me.
23:31:23 <glguy_> neat, works now. I did try when it was posted
23:32:17 <glguy_> fugyk: this might be a nice time to learn about typed holes
23:33:41 <glguy_> Try putting this in your file and loading with GHCi
23:33:41 <glguy_> instance Fluffy ((->) t) where
23:33:42 <glguy_>   furry f g = _
23:37:48 <texasmynsted> the haskell channels seem to be this busiest channels.  Heh
23:38:36 <Soul-Burn> :t f <*> x
23:38:36 <lambdabot>     Couldn't match expected type ‘f a0’ with actual type ‘Expr’
23:38:37 <lambdabot>     In the second argument of ‘(<*>)’, namely ‘x’
23:38:37 <lambdabot>     In the expression: f <*> x
23:38:53 <Soul-Burn> :t <*>
23:38:54 <lambdabot> parse error on input ‘<*>’
23:38:56 <glguy_> :t (<*>)
23:38:57 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:39:00 <Soul-Burn> ty <3
23:39:44 <Soul-Burn> Was thinking about making the juxtaposition "operator" be polymorphic
23:39:55 <Soul-Burn> i.e what happens when you do "f x"
23:40:24 <glguy_> Like this?
23:40:26 <glguy_> :t ($)
23:40:27 <lambdabot> (a -> b) -> a -> b
23:40:30 <jle`> i too have thought of this.
23:40:45 <Soul-Burn> in a way the you could define it to call <*> in order to have applicatives easily usable without <*>
23:41:19 <glguy_> Ah, you want to "overload" function application
23:41:20 <Soul-Burn> pure a x y instead of pure a <*> x <*> y (or a <$> x <*> y)
23:41:38 <Soul-Burn> a <$> x y
23:41:48 <Soul-Burn> if a is not lifted
23:42:05 <glguy_> why would pure a be special and not "pure <*> a"?
23:42:19 <Soul-Burn> :t pure
23:42:20 <lambdabot> Applicative f => a -> f a
23:42:34 <glguy_> If you have overloaded function application
23:42:57 <Soul-Burn> it would be, but for a simple function it would just apply the function
23:43:16 <Soul-Burn> pure <*> a <*> x <*> y
23:43:51 <Soul-Burn> the first <*> would be simple "pure" applied to "a"
23:44:11 <Soul-Burn> the second and third would be from Applicative f
23:44:29 <shachaf> I'll ask my question from a while ago again -- is there a convenient way of expressing "f <$> a <*> b <*> c <*> d" which is right-associated rather than left-associated?
23:44:43 <shachaf> (Primarily for performance reasons, since the Applicative laws force them to be equal, of course?)
23:45:07 <Soul-Burn> shachaf, it can't be right assosiative because the types are wrong
23:45:29 <Soul-Burn> just like "f a b c" can't be right associative
23:45:57 <Soul-Burn> "c <*> d" is not correct in terms of type
23:46:02 <shachaf> I should explain further.
23:46:11 <Soul-Burn> tasbir
23:46:54 <shachaf> ((a <> b) <> c) and (a <> (b <> c)) are equal, but the latter is often better.
23:47:22 <Soul-Burn> :t (<>)
23:47:23 <lambdabot> Monoid m => m -> m -> m
23:47:26 <shachaf> It's easy to write (f <$> a <*> b <*> c), but that ends up being associated to the left.
23:48:07 <Soul-Burn> (<>) is for monoids and (<*>) is for applicatives, it's a different world
23:48:17 <Soul-Burn> <*> is not defined to be associative
23:48:34 <shachaf> It's a very similar world.
23:48:38 <shachaf> (... <*> Const a <*> Const b <*> Const b)
23:49:06 <Soul-Burn> that depends on the ...
23:49:08 <shachaf> You have the exact same tree structure for Monoid and Applicative, the latter is just lifted.
23:49:18 <Soul-Burn> the order is different
23:49:32 <glguy_> maybe you can show some examples of the right associated computations you don't like, shachaf , to help Soul-Burn see what's going on?
23:49:58 <shachaf> I have an example in the documentation of nonfree: http://hackage.haskell.org/package/nonfree-0.1.0.0/docs/src/Data-Monoid-Nonfree.html
23:50:06 <Soul-Burn> (f <*> a <*> b <*> c) is much like (f a b c)
23:51:10 <glguy_> Soul-Burn: The thing he's talking about actually makes sense, check out the header of the module linked above to help see what's going on
23:51:21 <Soul-Burn> reading
23:51:33 <glguy_> The question isn't "can we blindly use the <*> operator with different parentheses"
23:53:14 <Soul-Burn> thing is that a <> b <> c would result in the same type that a b and c are. there might be a specific case where a <*> b <*> c result in the same type, but that's likely what this module does. I'll grok it further
23:54:45 <shachaf> If you've used Traversable a bunch this sort of thing is much easier to see.
23:55:12 <Soul-Burn> well, I'm still new in that world, I'd love to learn more
23:55:43 <glguy_> :t let (<@>) = liftA2 (,) in \f a b c -> (\(x,(y,z)) -> f x y z) <$> (a <@> (b <@> c))
23:55:44 <lambdabot> Applicative f => (t -> t1 -> t2 -> b) -> f t -> f t1 -> f t2 -> f b
23:56:10 <glguy_> :t \f a b c -> f <$> a <*> b <*> c
23:56:11 <lambdabot> Applicative f => (a2 -> a1 -> a -> b) -> f a2 -> f a1 -> f a -> f b
23:56:32 <glguy_> same computation, different association
23:56:49 <Soul-Burn> nice
23:57:53 <shachaf> That works but is very awkward and uses tuples.
23:58:07 <shachaf> It's also possible without tuples but I don't know how to do it without awkward.
23:58:15 <shachaf> @let liftA2' = let (<@>) = liftA2 (,) in \f a b c -> (\(x,(y,z)) -> f x y z) <$> (a <@> (b <@> c))
23:58:17 <lambdabot>  Defined.
23:58:47 <shachaf> Er.
23:58:50 <glguy_> 3?
23:58:51 <shachaf> @let liftA3' = let (<@>) = liftA2 (,) in \f a b c -> (\(x,(y,z)) -> f x y z) <$> (a <@> (b <@> c))
23:58:52 <lambdabot>  Defined.
