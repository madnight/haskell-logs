00:00:08 <bernalex> I have a "f g (A a) = A <$> f g a", so for my tuple f g (a, b) = (f g a, f g b) shooould work but idk. it doesn't at least.
00:00:22 <bernalex> could not deduce g ~ (,) (g a), heh
00:00:25 <bernalex> I guess I suck at lens
00:01:50 <Flonk> dibblego: I mean in a cat theory sense. "A cofree functor is right-adjoint to a forgetful functor" is a little too abstract
00:02:41 <bernalex> "cat theory" sounds like a cute discipline.
00:02:43 <shachaf> Flonk: Well, I think free functors are more common, so you might do better to understand those first.
00:03:40 <shachaf> "forgetful functor" is an almost meaningless term anyway.
00:03:58 <shachaf> How much do you know about adjunctions?
00:07:36 <bernalex> jle`: OK it's definitely not 100% correct
00:08:15 <jle`> well then :|
00:08:22 <glguy_> Bernalex what was your class?
00:09:47 <bernalex> glguy_: I found it mildly curious that "instance Foo a Bar => Foo (a, b) Bar where f = _1 . f" typechecks & works but not "instance (Foo a Bar, Foo b Bar) => Foo (a, b) Bar where f = _1 . f"
00:10:42 <glguy_> But what is the class?
00:10:44 <bernalex> glguy_: it's the good old tuple you know and love. ;-) I just want to make it typecheck & shut up real quick so I can work on something else that needs to be done right now.
00:11:03 <bernalex> glguy_: oh the class... hmmm... IDK. need to compile the package it's from and check.
00:11:16 <glguy_> Oh. OK
00:11:32 <bernalex> uhm how do I check even?
00:11:39 <bernalex> you can't :list or :info a typeclass
00:11:42 <jle`> not . odd
00:12:15 <glguy_> Info would work
00:12:29 <bernalex> oh yes it would
00:12:35 <bernalex> cabal repl instead of ghci might help heh
00:13:09 <bernalex> class Foo s a | s a -> a where f :: Functor fun => (a -> fun a) -> s -> f s
00:14:16 <glguy_> Did you copy that by hand?
00:14:36 <tempay> guys, isn't there some function like if except with the bool at the end? like a -> a -> Bool -> a?
00:14:46 <jle`> :t bool
00:14:47 <lambdabot> a -> a -> Bool -> a
00:14:49 <bernalex> glguy_: glguy_ fun a in the return
00:14:52 <bernalex> class Foo s a | s a -> a where f :: Functor fun => (a -> fun a) -> s -> fun s
00:14:57 <jle`> tempay: ^^
00:14:57 <bernalex> nice catch heh
00:15:11 <bernalex> tempay: it's in Data.Bool
00:15:13 <glguy_> And the fun dep is right?
00:15:20 <tempay> i'm not crazy! forgot to import, thanks
00:15:21 <bernalex> glguy_: fun dep?
00:15:33 <bernalex> glguy_: let me just copy the entire thing and join it to one line
00:15:37 <tempay> while i'm at it, is there a Bool->a->Maybe a?
00:15:41 <jle`> tempay: be aware that the function order is opposite of what you'd expect from `if` :)
00:15:48 <bernalex> glguy_: class HasRubbish s a | s -> a where rubbish :: Functor f => (a -> f a) -> s -> f s
00:15:50 <tempay> i can't seem to find these things on hoogle for some reason
00:16:17 <jle`> `\b x -> x <$ guard b` is what i always do, tempay
00:16:40 <tempay> right, okay, thanks
00:16:55 <bernalex> tempay: hm. that's interesting. a -> a -> Bool -> a didn't show up for me either.
00:17:02 <bernalex> jle`: I have if' and fi in my company's prelude heh
00:17:09 <jle`> nice one
00:17:20 <tempay> bernalex: yeah, haven't had much luck
00:17:27 <jle`> > 4 <$ guard True
00:17:28 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
00:17:29 <lambdabot>    arising from a use of ‘M126526431822814587312652.show_M1265264318228145873...
00:17:29 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
00:17:33 <jle`> > 4 <$ guard True :: Maybe Int
00:17:34 <lambdabot>  Just 4
00:17:36 <jle`> > 4 <$ guard False :: Maybe Int
00:17:38 <lambdabot>  Nothing
00:17:47 <jle`> you can also use mfilter if you want to do it by predicate
00:17:54 <jle`> > mfilter even (Just 4)
00:17:55 <bernalex> @let if' True = const; if' False = const id
00:17:56 <lambdabot>  Just 4
00:17:57 <lambdabot>  Defined.
00:18:08 <jle`> > mfilter odd (Just 4)
00:18:09 <lambdabot>  Nothing
00:19:19 <shiona> :t mfilter
00:19:20 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
00:19:57 <bernalex> > foldr (uncurry if') 0 [(True, 1), (False, 2), (True, 3)] -- heh
00:19:59 <lambdabot>  1
00:20:08 <jle`> undoubtedly useful
00:20:27 <jle`> oh :O
00:21:55 * hackagebot yesod-bin 1.4.1.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.1.2 (MichaelSnoyman)
00:22:27 <gamegoblin> Is there a good way to make a function that would do something like: f [1,2,3] [a,b,c,d,e,f] == [[a], [b,c], [d,e,f]]
00:22:42 <gamegoblin> that is, it grouped the given list into sublists of the given size
00:24:02 <bernalex> gamegoblin: f (x:xs) ys = take x ys : f xs (drop x ys); f [] ys = [
00:24:12 <gamegoblin> bernalex: excellent, thanks
00:24:13 <bernalex> ]
00:24:53 <bernalex> glguy_: did you understand anything from the class?
00:25:58 <bernalex> with "instance (Foo a Bar, Foo b Bar) => Foo (a, b) Bar where f = _1 . f", I get "could not deduce (Foo a Bar) arising from a use of f"
00:36:00 <bernalex> oh ok I fixed that at least
00:36:10 <bernalex> now to s/_1/whatever I need to apply it to both/
00:37:47 <bernalex> so I have "instance (Foo a Bar, Foo b Bar) => Foo (a, b) Bar where f g (a, b) = _1 . f", and I need to apply it to both rather than just the first. how do u evn lens? lol
00:42:36 <bernalex> I thought f g (a, b) = (,) <$> (f g a) (f g b) would be all happy days, but it's not because expected a0 -> (a, b) but got a0 -> b0 -> (a0, b0). I don't even.
00:45:55 <zq> i made it run as fast as cpp by staying in uarray land
00:46:02 <zq> woof
00:53:25 <bernalex> I would have thought that if _1 . f and _2 . f worked, then _1 . f . _2 . f should work. what intuition am I missing here?
00:54:05 <bernalex> oh
00:55:01 <bernalex> well at least I'm learning a lot about things that *won't* work
00:55:21 <bernalex> I just need to eliminate all of them
00:56:07 <bernalex> my next hunch was "f = (,) <$> (_1 . f) (_2 . f)" but I guess not
00:58:02 <bernalex> that's just an even more wrong "f g (a, b) = (,) <$> (f g a) (f g b)", heh. horribly wrong.
01:00:43 <bernalex> I just realised how much of a dunce I was
01:00:56 <bernalex> > (,) <$> Just 2 <*> Just 3 -- this is not (Just 2, Just 3)
01:00:57 <lambdabot>  Just (2,3)
01:01:04 <jle`> heh
01:01:55 * hackagebot machines-directory 0.0.0.2 - Directory (system) utilities for the machines library  http://hackage.haskell.org/package/machines-directory-0.0.0.2 (aloiscochard)
01:02:36 <bernalex> still wouldn't mind f g (a, b) = (f g a, f g b) working though
01:06:55 * hackagebot codex 0.2.0.3 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.2.0.3 (aloiscochard)
01:06:57 * hackagebot resource-pool 0.2.3.2 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.2.3.2 (BasVanDijk)
01:12:18 <aloiscochard> is there a way to publish to hackage from command line/cabal ?
01:12:30 <bernalex> aloiscochard: oh how I wish there were
01:12:47 <dcoutts_> aloiscochard: cabal upload
01:13:15 <bernalex> dcoutts_: well you delivered quickly. duly noted.
01:13:39 <dcoutts_> (it's been there since the very beginning)
01:13:40 <bernalex> this is what happens when UNIX programs do not have manpages.
01:13:52 <dcoutts_> cabal --help
01:13:53 <aloiscochard> dcoutts_: neat! just what I was looking for, ty :)
01:14:13 <bernalex> dcoutts_: everyone knows you only do that with | grep what-you-want-to-do, :-P
01:14:44 <edwardk> bernalex: f g (a, b) = (,) <$> f g a <*> f g b -- makes a traversal
01:14:45 <bernalex> I just didn't consider that cabal would have that capability, so I never looked for it.
01:14:54 <bernalex> edwardk: yeah
01:15:01 <dcoutts_> bernalex: :-)  $ cabal --help | grep -i hackage
01:15:17 <edwardk> bernalex: since to traverse two things, it won't be a lens =)
01:15:30 <bernalex> edwardk: so what am I looking for?
01:15:43 <bernalex> edwardk: I want to do what _1 . f will do, and what _2 . f will do :-P
01:15:56 <edwardk> then make the member in the class a traversal not a lens
01:16:01 <edwardk> then you can do both
01:16:09 <bernalex> edwardk: plshalp oh mighty lensgod?
01:16:47 <bernalex> edwardk: "member in the class" -- so for (a, b) I should make all as and bs traversals and then add a traversal context?
01:16:50 <haasn> “Edward Kmett, Mighty Lensgod” amusing business card
01:17:12 <edwardk> class Foo a b | a -> b where foo :: Traversal' a b | a -> b; instance (Foo a x, Foo b x) => Foo (a,b) x where foo f (a,b) = (,) <$> foo f a <*> foo f b
01:17:23 <bernalex> haasn: s/business card/tattoo
01:17:28 <edwardk> er drop the second | a -> b
01:17:42 <bernalex> edwardk: class Foo is generated by makeFields
01:17:42 <edwardk> class Foo a b | a -> b where foo :: Traversal' a b; instance (Foo a x, Foo b x) => Foo (a,b) x where foo f (a,b) = (,) <$> foo f a <*> foo f b
01:17:55 <edwardk> then you cannot has ;)
01:18:03 <edwardk> you need to write your own version of it that is more permissive
01:18:04 <kvanb> try "winner of all 10 first places in 'Most Complex Hackages 2014'"
01:18:09 <bernalex> edwardk: I see
01:18:29 <edwardk> kvanb: i'm branching out into other categories
01:18:46 <edwardk> now we have gl, which is trying to take all 10 places in the 'Largest Hackage Package 2014' =)
01:18:52 <kvanb> hehe
01:18:58 <kvanb> fwiw, I loved trifecta
01:19:27 <edwardk> i have some pending trifecta stuff that just needs a little bit of 'last mile' effort that should go out soon
01:19:43 <kvanb> I think it was a bit slow though, couldn't really tell
01:20:15 <kvanb> took 10ms or so to parse 100 lines of code with my pretty simple language
01:20:17 <edwardk> its a bit slow, but thats because it actually does errors. attoparsec blows my doors off because it doesn't try to sanely cull backtracking and it doesn't do any error reporting
01:20:34 <bernalex> edwardk: so am I understanding this correctly
01:20:43 <bernalex> class HasRubbish s a | s -> a
01:20:45 <bernalex> becomes
01:20:48 <bernalex> class Rubbishable a b | a -> b
01:21:07 <bernalex> what does "where Traversal' a b" even mean here?
01:21:25 <edwardk> you can keep the HasRubbish s a | s -> a nomenclature
01:21:36 <edwardk> ou can now just have multiple rubbishes
01:21:41 <edwardk> so field access becomes tricky
01:21:51 <edwardk> e.g. you have to modify and you can get the list of rubbish entries
01:22:01 <edwardk> but its not just that you get exactly one any more
01:22:46 <bernalex> well I get both HasRubbish and Rubbishable
01:22:56 <bernalex> so I can probably pick and choose if Rubbishable becomes unmanagable somewhere
01:23:07 <bernalex> this is all to manage a corner case real quickly while I work on other things
01:23:12 <bernalex> I might not do any of this in the end :-]
01:23:19 <edwardk> class HasRubbishes s a | s -> a where rubbishes :: Traversal' s a
01:23:45 <edwardk> class HasRubbishes s a => HasRubbish s a | s -> a where rubbish :: Lens' s a
01:23:59 <edwardk> though the 'a' there is probably overkill
01:24:08 <edwardk> if its always going to be 'Rubbish' or whatever it was
01:24:30 <edwardk> class HasRubbish s where rubbish :: Lens' s Rubbish
01:25:02 <Skye> Porting?
01:25:12 <bernalex> edwardk: erm
01:25:24 <bernalex> edwardk: ohh hasRbbuishes
01:25:27 <bernalex> HasRubbishes
01:25:29 <bernalex> different names
01:25:59 <bernalex> edwardk: ok no I'm not sure what you mean here
01:26:06 <edwardk> A traversal is just a lens with multiple targets
01:26:10 <bernalex> edwardk: why are there two class HasRubbishes?
01:26:19 <edwardk> > (1,2)^..both
01:26:21 <lambdabot>  [1,2]
01:26:23 <edwardk> > (1,2) & both +~ 1
01:26:24 <tdammers> edwardk: when you say it it all sounds so simple :P
01:26:25 <lambdabot>  (2,3)
01:26:41 <bernalex> edwardk: did you mean to have rubbish and rubbishes in the same class, right?
01:26:52 <bernalex> because you said class.... for both of them, and that won't work very well :-P
01:26:53 <edwardk> bernalex: no, re-read what i wrote
01:26:55 * hackagebot hspec-server 0.2.0 - Test Framework for Server's status  http://hackage.haskell.org/package/hspec-server-0.2.0 (junjihashimoto)
01:26:57 * hackagebot hspec-server 0.2.1 - Test Framework for Server's status  http://hackage.haskell.org/package/hspec-server-0.2.1 (junjihashimoto)
01:26:59 <aloiscochard> someone told me to put my libs on stackage, could someone point me to explaination on how/why/... ?
01:27:05 <edwardk> class HasRubbishes s a | s -> a where rubbishes :: Traversal' s a -- defines HasRubbishes
01:27:12 <edwardk> class HasRubbishes s a => HasRubbish s a | s -> a where rubbish :: Lens' s a -- defines HasRubbish
01:27:14 <edwardk> different class
01:27:20 <tdammers> aloiscochard: stackage or hackage?
01:27:24 <bernalex> it is?
01:27:36 <bernalex> edwardk: I get multiple declarations of HasRubbishes
01:27:42 <aloiscochard> tdammers: stackage (https://github.com/aloiscochard/machines-directory/pull/3#issuecomment-66030562) they already are on hackage
01:27:54 <edwardk> class (HasRubbishes s a) => HasRubbish s a | s -> a where rubbish :: Lens' s a
01:28:00 <edwardk> does that make it clearer that that is defining HasRubbish?
01:28:29 <bernalex> omg I see now what I was missing
01:28:41 <edwardk> i just removed the unnecessary parens
01:29:03 <jle`> that changes everything
01:29:32 <aloiscochard> seems like hackage would be a way to be sure my stuff work with multiple versions of machines or somethnig
01:29:41 <aloiscochard> stackage* damn
01:29:46 <edwardk> aloiscochard: the benefit of stackage to me is that i get really good feedback from snoyman et al when my packages go out of date and don't build with latest dependencies
01:29:49 <bernalex> edwardk: this needs -XMultiParamTypeClasses?
01:29:55 <edwardk> its giving me an entire community of folks doing testing
01:30:28 <edwardk> bernalex: MPTCs and fundeps for the version with an explicit 'a' argument, i don't remember if you actually needed that for the usecase you had though, or if the simpler one arg version i was suggesting later was more correct for you
01:30:38 <edwardk> you started with the MPTC version when you framed the question, so i ran with it
01:31:03 <aloiscochard> edwardk: sounds appealing indeed, I suppose the person who suggest it is from that community
01:31:13 <bernalex> edwardk: sure
01:31:28 <edwardk> aloiscochard: anyways, being on stackage is a great way to ensure that your packages fit into the whole warp and weft of the community, e.g. everything on stackage can build together in one install
01:31:40 <edwardk> it has done a _lot_ to ensure hackage works with itself.
01:31:44 <bernalex> edwardk: then you said 'instance (HasRubbish a x, HasRubbishes b x) => HasRubbishes (a, b) x where' or something like that?
01:31:46 <aloiscochard> oh I see
01:31:50 <edwardk> at least as long as you are willing to use the bleeding edge of everything
01:32:15 <aloiscochard> that's what I love
01:32:17 <edwardk> it was billed originally as a 'stable hackage' but really its more of a continuous integration server testing that nobody 'breaks the build'
01:32:18 <aloiscochard> ;-)
01:32:41 <bernalex> instance (HasRubbish a x, HasRubbishes b x) => HasRubbishes (a, b) x where rubbish f (a, b) = (,) <$> rubbish f a <*> rubbish f b -- doesn't appear to work
01:32:48 <edwardk> with the new 'long term support' model it may slowly transition towards its original goal
01:32:56 <aloiscochard> edwardk: how do I get there? I mean in stackage, is it a complex process or just kind of registration?
01:32:57 <bernalex> GHC suggests turning on UndecidableInstances eheh.
01:33:00 <edwardk> (,) <$> rubbishes f a <*> rubbishes f b
01:33:15 <jle`> 3 months is kind of a weird time period to call long-term though
01:33:17 <edwardk> aloiscochard: you send a patch to Stackage/Config.hs to snoyman
01:33:23 <edwardk> jle`: baby steps =)
01:33:34 <jle`> indeed
01:33:35 <edwardk> for haskell that is an eternity ;)
01:33:40 <jle`> haha
01:33:43 <jle`> yes sometimes i forget
01:33:56 <edwardk> 3 months ago i hated pattern synonyms
01:34:13 <edwardk> now i have gl =P
01:34:21 <aloiscochard> edwardk: awesome, thanks for your help
01:34:30 <edwardk> aloiscochard: np
01:35:08 <edwardk> aloiscochard: https://github.com/fpco/stackage/blob/master/build-constraints.yaml#L202
01:35:17 <edwardk> send a patch for that file to add you and your packages and done
01:35:40 <bernalex> edwardk: hmm
01:35:46 <bernalex> class HasRubbishes s a | s -> a where
01:35:48 <bernalex>   rubbishes :: Traversal' s a
01:35:50 <bernalex> class HasRubbishes s a => HasRubbish s a | s -> a where
01:35:52 <bernalex>   rubbish :: Lens' s a
01:35:54 <bernalex> instance (HasRubbish a x, HasRubbishes b x) => HasRubbishes (a, b) x where
01:35:56 <bernalex>   rubbish f (a, b) = (,) <$> rubbishes f a <*> rubbishes f b
01:35:59 <bernalex> this gives me that "rubbish is not a visible method"
01:36:03 <edwardk> rubbishes f (a,b)
01:36:07 <edwardk> you are using the wrong names =)
01:36:15 <bernalex> I am, yes
01:36:22 <edwardk> HasRubbishes has rubbishes, HasRubbish has rubbish
01:36:36 <bernalex> right
01:36:52 <bernalex> now what should my instance for Entity be?
01:36:59 <bernalex> it used to be
01:37:04 <bernalex> instance HasRubbish a (Maybe UTCTime) => HasRubbishes (Entity a) (Maybe UTCTime) where rubbishes f (Entity a b) = Entity a <$> rubbish f b
01:37:27 <bernalex> I guess I need to turn that into Rubbishes, so that I can make the (,) instance more specific so that it uh doesn't need UndecidableIntstances
01:39:02 <bernalex> oh right using Maybe UTCTime rather than just x
01:39:46 <bernalex> and then
01:39:47 <bernalex> instance HasRubbishes a (Maybe UTCTime) => HasRubbishes (Entity a) (Maybe UTCTime) where
01:39:50 <bernalex>   rubbishes f (Entity a b) = Entity a <$> rubbishes f b
01:39:52 <bernalex> ?
01:41:43 <edwardk> alternately if you are _always_ using Maybe UTCTime you can just drop the second parameter
01:42:06 <edwardk> class HasRubbishes s where rubbishes :: Traversal' s (Maybe UTCTime)
01:42:25 <edwardk> class HasRubbishes s => HasRubbish s where rubbish :: Lens' s (Maybe UTCTime)
01:42:32 <edwardk> now you need no MPTCs, no fundeps, nothin
01:42:33 <bernalex> edwardk: I am presently always using it, but meh
01:42:46 <bernalex> edwardk: will this define HasRubbish tho?
01:42:51 <bernalex> class HasRubbishes s a => HasRubbish s a | s -> a where
01:42:54 <bernalex>   rubbish :: Lens' s a
01:43:01 <edwardk> sure
01:43:03 <bernalex> yeah I suspected this. "conflicting exports"
01:43:11 <edwardk> but i'd personally simplify it to the one i mentioned
01:44:29 <edwardk> the two definitions i just gave don't conflict with each other, but i don't know the other crap you have in the file =P
01:47:44 <bernalex> edwardk: the problem is that I'm generating a bunch of HasStuff from the database, and since Tempuhs.Rubbish exports HasRubbish, it's getting mad that this new file also does it
01:48:31 <bernalex> and you can't just hide instances conveniently
01:48:43 <bernalex> or hmm maybe you can
01:49:01 <bernalex> OK that's convenient "enough". problem solved. maybe.
01:49:15 <edwardk> you can drop the fundep i was using between HasRubbishes and HasRubbish
01:49:29 <edwardk> i was offering it as what the logical relationship is
01:49:36 <edwardk> if you can supply a lens you can always supply a traversal
01:49:40 <edwardk> because a lens is a traversal
01:50:01 <edwardk> whether you choose to reify that relationship between the classes is entirely up to you
01:53:40 <bernalex> edwardk: yeah I see
01:54:13 <bernalex> edwardk: so what is the correct way to use rubbishes now? if I have (=^=) :: (HasRubbishes a (Maybe UTCTime), ToJSON a) => [a] -> [a] -> Bool
01:54:19 <bernalex> then I want to
01:54:28 <bernalex> (a:as) =^= (b:bs) = let rb = the rubbish of b
01:54:42 <edwardk> you no longer have 'the rubbish of b'
01:54:43 <bernalex> with the old HasRubbish I would do b ^. rubbish, I guess
01:54:46 <bernalex> exactly
01:54:46 <edwardk> you have 2 of them in the (a,b) case
01:55:03 <bernalex> so all of   let rb = b ^. rubbishes
01:55:05 <bernalex>   in  isJust rb && toJSON (a & rubbishes .~ rb) == toJSON b && as =^= bs
01:55:07 <bernalex> is just not going to happen
01:56:48 <bernalex> unless you can use that API, I'm not sure
02:03:04 <bernalex> OK I simplified them to make them only use Maybe UTCTime. it's nicer, I agree.
02:03:36 <bernalex> edwardk: so how would I do f of the rubbishes?
02:04:05 <bernalex> i.e. where I could do "f (a ^. rubbish)" when we had only one rubbish, instead of possibly more like now
02:06:37 <bernalex> traverse (^.)?
02:06:49 <edwardk> well now that you have more you need to decide how to deal with the situation where they disagree or somehow believe that they won't
02:07:13 <bernalex> aha
02:07:15 <bernalex> well
02:07:46 <bernalex> what I want is to run isJust on all of them, and check that they are all Just
02:08:58 <bernalex> I have two lists of as, where a honours HasRubbishes a (Maybe UTCTime)
02:09:11 <bernalex> so f (a:as) (b:bs)
02:09:21 <bernalex> I'd want to check first that all of b's rubbishes are Just
02:09:42 <bernalex> then I want to set all of uh-oh this won't work
02:11:52 <sgillis> Could someone explain me what is wrong with this function? http://lpaste.net/116574
02:11:55 <bernalex> edwardk: OK I decided wat bad hack to go with for the moment
02:12:33 <bernalex> check that all of b's rubbishes are just. then set all of a's rubbishes to [something]. then I'm ready at least.
02:14:37 <bergmark> sgillis: the return type is missing
02:16:13 <sgillis> bergmark: Ofcourse, thanks, was staring myself blind on that :)
02:17:08 <talw> Hello fellow Haskellers!
02:17:30 <talw> I want to ask a little question, if I may
02:17:52 <shachaf> Permission granted.
02:18:10 <shachaf> (In the future, just ask your question. Ask to ask is discouraged.)
02:18:31 <talw> I've been learning Haskell on and off for some time now. But only recently I started to actually code something in it
02:19:01 <talw> So I've written my first pet-pet-project
02:19:34 <talw> and I'd like to know where would be appropriate to seek guidance on what I did wrong or unidiomatic, writing it
02:19:46 <sivteck> `here
02:19:47 <talw> got you scachaf
02:20:13 <shachaf> If it's a small amount of code, put it up somewhere like hpaste.org and put the link here.
02:20:34 <talw> What if it's couple of hundreds of lines of code uploaded to github?
02:21:04 <shachaf> It's better to put the link here than wait for someone to volunteer to help you without seeing the link.
02:21:38 <talw> without seeing the link?
02:21:48 <shachaf> The code.
02:22:04 <ddellacosta> talw: you may get more traction if you can isolate specific pieces of code, even if they are part of a repo.  Or if you ask a general question about the structure of the repo that doesn't require people to read every file...all of this depends on the actual size you're talking about, of course
02:22:17 <ehiggs> Hi all. Is any function that takes one type and returns another classes as a "type constructor"? Or is there another distinction that exists?
02:22:19 <ddellacosta> talw: but I've had good luck here in the past with gist-size code samples when I've wanted feedback
02:22:59 <shachaf> ehiggs: What do you mean?
02:23:01 <talw> Is the irc channel a good place for this? Or would it be better to use the subreddit?
02:23:23 <ddellacosta> talw: I mean, based on my experience the IRC channel seems to be fine for that kind of thing.
02:23:26 <shachaf> talw: Either would work, but spending 8 lines to ask for permission to post your code in IRC is pretty silly. :-)
02:23:36 <talw> I understand
02:23:47 <ddellacosta> ha, and what shachaf said ^.  People value brevity here. :-)
02:24:07 <shachaf> If the very first thing you'd said was "I have this code -- ... -- does anyone have opinions on it?", people could have said "that's better to ask in place Y".
02:24:17 <talw> I understand you both, thanks!
02:24:18 <ehiggs> Well, a type constructor is of kind *->* and functions of type a -> b are also of kind *->* so I thought functions of type a->b are also called type constructors.
02:24:52 <talw> It's just that, I have specific parts of the code, but in order to understand everything fully you might need to consult other files in the reop
02:24:52 <shachaf> But this way even people who want to help you have to do the awkward dance where they don't outright volunteer (because they don't know whether they can help you at all) but suggest that maybe they can help.
02:25:16 <ddellacosta> talw: again, just try it and see--folks will ask if they don't get it.
02:25:39 <talw> I see what you mean shachaf. You have a point
02:25:47 <shachaf> ehiggs: Well, a function isn't a type constructor. A type constructor is on the type level.
02:26:03 <shachaf> ehiggs: A data constructor like Just can be a function -- Just :: a -> Maybe a
02:26:16 <shachaf> But there are lots of functions that aren't constructors on the value level.
02:26:17 <talw> but ddellacosta, wouldn't it be better to ask in a place where your messages don't float and disappear after a while?
02:26:30 <shachaf> talw: You're still doing it. Just post your link.
02:26:36 <ddellacosta> talw: sure, but now you're arguing against the nature of IRC...
02:27:02 <shachaf> ehiggs: On the type level in Haskell 2010, all type functions are constructors.
02:27:14 <talw> ok ok. I'll post it
02:27:16 <shachaf> With extensions like TypeFamilies that's less true.
02:27:34 <shachaf> I don't care whether you post it, but asking for permission to post it is very frustrating. :-)
02:27:38 <ddellacosta> talw: if you are afraid of that then use another medium.  It's a peril of IRC that folks may not understand.  Also, http://ircbrowse.net/haskell
02:27:42 <ehiggs> shachaf: and what is the definition of type function? something using abstract types?
02:27:50 <ddellacosta> *may not answer I mean
02:28:09 <shachaf> ehiggs: Often these things have multiple slightly different definitions. It's usually clear enough what people mean in context.
02:28:26 <shachaf> ehiggs: Maybe I'd say that a type function is something that has kind a -> b for some a and b.
02:28:47 <shachaf> And a [value] function is something that has type a -> b for some a and b.
02:29:21 <elfeck> heyoh, I am using haskell-mode and am trying to set a fixed module for reloading with C-u M-x haskell-process-load-or-reload ... but it's not working and always loading the current modue
02:29:51 <elfeck> anyone can help?
02:30:51 <ddellacosta> elfeck: you may also want to try in #emacs if you don't get a response here
02:30:56 <ehiggs> shachaf: thanks. I think it's a little bit clearer, but not completely as I thought these terms had precise meanings and I was just unaware. Knowing that there's a bit of context and different people have different notions helps me understand why it isn't/wasn't clear.
02:31:49 <shachaf> Some people would say that Maybe is a type, some would say that it isn't.
02:32:14 <shachaf> It doesn't matter too much as long as you're clear about what you mean.
02:32:42 <elfeck> ddellacosta: okay thanks
02:32:50 <talw> I've written my first pet-project in Haskell, and I'll be glad to receive some feedback as I never had a fellow Haskeller read my code before.
02:32:55 <ddellacosta> elfeck: yeah, sorry I don't know more about it. :-/
02:32:56 <talw> https://github.com/talw/quoridor-hs
02:33:49 <talw> The src/Quoridor.hs and src/Quoridor/Cmdline/Network.hs contains most of the beef I'd be really curious to know how I can improve
02:34:12 <talw> I'd be really *happy
02:34:54 <ddellacosta> talw: meta-comment: that seems like a good way to approach it to me. :-)
02:35:10 <talw> Thanks ddellacosta! and shachaf!
02:35:16 <ehiggs> so Maybe a isn't a nonreified type?
02:35:55 <ddellacosta> talw: unfortunately I'll have to defer to someone more experienced on giving you actual feedback...but hang out a bit and see--it may take a little time as folks check out the backlog (based on my experience)
02:36:12 <shachaf> Now is a bad time anyway since everyone is asleep.
02:36:17 <ddellacosta> there's that too
02:36:32 <ddellacosta> in North America at least
02:36:38 <talw> ddellacosta: ok, worst case I'll try the subreddit as well!
02:36:50 <ddellacosta> talw: good luck!
02:37:06 <talw> I see...
02:43:31 <asante> hi, I was given the following code http://lpaste.net/6150094306867675136 for a homework assignment. hlint says the duplication in line 9 should be reduced - but if I see this correctly, its in two different functions and I have no idea how to reduce the duplication then. can someone hint me to something? (this isn't needed to finish the assignment, I merely would like to fix hlints suggestions)
02:48:58 <jcpetruzza> asante: maybe put the common structure on a third function and write blueAdd and redAdd in terms of that one?
02:56:56 * hackagebot snowglobe 2.0.0.2 - randomized fractal snowflakes demo  http://hackage.haskell.org/package/snowglobe-2.0.0.2 (ClaudeHeilandAllen)
03:02:24 <matematikaadit> asante: probably something like this http://lpaste.net/6150094306867675136
03:14:54 <zipper> So I'm having problems understanding the question 3 in http://www.seas.upenn.edu/~cis194/hw/07-laziness.pdf
03:15:04 <zipper> How can I tell it to keep a thunk?
03:15:42 <zipper> I can't make a value of type Stream a all I'm making are type Stream a -> Stream a
03:17:33 <jle`> what function are you having trouble implementing?
03:17:42 <zipper> jle`: http://www.seas.upenn.edu/~cis194/hw/07-laziness.pdf Question 3
03:17:54 <zipper> Exercise 3
03:18:44 <jcpetruzza> zipper: an example value of type Stream Int is: allOnes = Cons 1 allOnes
03:18:47 <zipper> I feel that maybe he taught the concept of a stream in class and I just landed in the middle of it because I don't get the question or this type.
03:18:55 <jle`> streamToList (Cons x xs) = ...?
03:19:02 <jle`> what'are you trying to make?
03:19:06 <jle`> what si the result type?
03:19:23 <zipper> jle`: I tried that it told me cons has too few arguments
03:19:38 <jle`> really?
03:19:39 <zipper> jle`: So I decided to just make a value of type Stream but oh well
03:19:46 <zipper> jle`: Let me show you the code
03:19:52 <jle`> streamToList :: Stream a -> [a]
03:19:59 <jle`> streamToList (Cons x xs) = ...?
03:21:03 <zipper> jle`: This was mine -->  streamToList Cons x xs = x : streamToList xs
03:21:08 <jle`> you need the parentheses
03:21:17 <zipper> jle`: Why?
03:21:17 <jle`> otherwise it is like a function with three arguments
03:21:25 <zipper> jle`: Oh
03:21:42 <jle`> it's like streamToList Nothing x xs = ...
03:22:16 <jle`> like three different arguments
03:22:26 <zipper> jle`: I understand now
03:22:48 <zipper> Actually I understood the second you said "otherwise it is like a function with three arguments"
03:23:07 <jle`> :)
03:24:06 <zipper> jle`: I'm not smiling though. This is getting frustrating. And everyone tells me I won't use this lang in an actual job setting. :(
03:24:30 <jack_rabbit> zipper, there are lots of companies that use haskell.
03:25:18 <zipper> jack_rabbit: I sure hope you're right.
03:25:27 <tdammers> in all honesty though, the number of haskell job opening is tiny compared to, say, Java, PHP, .NET, etc.
03:25:40 <tdammers> *s
03:26:08 <ddellacosta> zipper: are you in undergrad still?
03:26:18 <stillwater> Hi everyone
03:26:20 <stillwater> newbie here
03:26:27 <ddellacosta> stillwater: hello
03:26:37 <stillwater> data List a = Nil | Cons a (List a)
03:26:46 <stillwater> I ve tried looking up but to no avail
03:26:50 <stillwater> what is Cons here
03:26:59 <jle`> do you know about algebraic data types?
03:27:00 <zipper> jcpetruzza: So I tried to form a value like Cons 5 (Stream 5) at which point it complained because Stream is a type constructor not a value constructor.
03:27:04 <jle`> it's called a constrcutor
03:27:11 <jle`> data Maybe a = Nothing | Just a
03:27:18 <zipper> ddellacosta: Yes I am
03:27:20 <stillwater> Cons is shorthand for Constructor?
03:27:28 <jle`> no, it's just a constructor
03:27:34 <jle`> do you recognize the Maybe declaration earlier?
03:27:38 <bernalex> jle`: you should explicitly say whether it's a data or type constructor IMO
03:27:41 <zipper> ddellacosta: The few haskell jobs I see talk about Masters and PHD
03:27:48 <jle`> ah, yes. it's a data constructor
03:27:55 <zipper> jle`: Are you talking to me?
03:27:57 <bernalex> jle`: because of the design mistake where they do not share namespace, people get about what is the type and what is the value
03:28:01 <ddellacosta> zipper: maybe you don't feel like it now but I believe you'll be happy that you got exposure to Haskell later on when you are working in a professional setting
03:28:03 <jle`> good point :)
03:28:06 <bernalex> *people get confused
03:28:06 <jle`> zipper: no, to stillwater
03:28:42 <stillwater> data IntList = Empty | Cons Int IntList
03:28:50 <stillwater> Here Intlist is either empty
03:28:53 <zipper> ddellacosta: Because it'll change the way I program? That's quite honestly the only reason I'm still holding on. :)
03:28:58 <stillwater> or is constructor that takes an int and an intlist?
03:29:01 <stillwater> is a *
03:29:02 <jle`> yeah
03:29:13 <jle`> data IntList  = Empty | IntCons Int IntList
03:29:20 <ddellacosta> zipper: I hope it will give you perspective on that, yeah--it's been really beneficial for me that way even though I don't use it day-to-day
03:29:33 <ddellacosta> wish I'd known about it sooner
03:29:49 <zipper> uh how do I form a value whose type is like "data Stream a = Cons a (Stream a)"
03:30:17 <zipper> ddellacosta: Well I think it gets really hard just before it gets easy so I'll fight on :)
03:30:20 <jle`> one common example is countFrom :: Int -> Stream Int
03:30:33 <ddellacosta> zipper: yes! good luck. :-)
03:30:37 <jle`> countFrom 0 is an infinite stream starting from 0
03:30:54 <jle`> so let's try making it
03:30:59 <jle`> countFrom x = ????
03:31:03 <zipper> jle`: I think this lecture notes should've explained streams first
03:31:13 <zipper> jle`: Give me a second
03:31:13 <bernalex> zipper: when I looked for haskellers to hire, I did not care about their uni diplomas. I don't think anyone will care if you have your experience from elsewhere.
03:31:24 <jle`> zipper: there's not too much more to explain here :)
03:31:33 <jle`> do you know about algebraic data types?
03:31:37 <jle`> data Maybe a = Nothing | Just a
03:32:24 <stillwater> My god haskell is painful
03:32:38 <sivteck> @smack haskell
03:32:38 <lambdabot> I won't; I want to go get some cookies instead.
03:33:54 <zipper> jle`: Yes I do. Anyway countFrom x = Stream x
03:34:17 <zipper> jle`: but I feel that's wrong because it doesn't show the continuation of the stream
03:34:24 <jle`> um
03:34:28 <jle`> that doesn't work
03:34:32 <jle`> Stream is not a data constructor
03:34:34 <jle`> it's a type constructor
03:34:43 <bernalex> jle`: something something told you so ;-)
03:34:46 <jle`> ;)
03:34:55 <zipper> jle`: Oh sorry lol
03:35:10 <asante> ah matematikaadit very nice thanks!
03:35:13 <jle`> you only have one constructor available
03:35:15 <jle`> for Stream
03:35:19 <jle`> so this one shouldn't be too hard?
03:35:21 <jle`> :)
03:35:26 <stillwater> Off Topic question Is Brent yorgey 's introductory course skipping over explaining some basic stuff?
03:35:47 <bernalex> stillwater: not sure how that is off-topic. and the answer depends on what you consider basic.
03:36:48 <stillwater> Off topic because somebody else was having a conversation. Did not want to interrupt.
03:36:56 <stillwater> well
03:38:30 <jle`> stillwater: nah, such is the nature of irc :)
03:38:46 <zipper> jle`: This would've been easier if I knew how to make values of type Stream a because all I have now is: countFrom x = Cons x (Cons countFrom ...)
03:38:57 <jle`> zipper: so, that's a good start
03:39:01 <jle`> countFrom x = Cons x _
03:39:12 <jle`> what are we expecting in the _?
03:39:21 <jle`> maybe it'd be nice to write cons in infix
03:39:26 <jle`> countFrom x = x `Cons` _
03:39:38 <zipper> jle`: No it's ok not being infix
03:39:38 <jle`> so countFrom 0 will be 0 `Cons` (1 `Cons` ...), right?
03:39:55 <jle`> so tell me, what "belongs" in that spot?
03:39:57 <BoR0> _ should be another Cons
03:40:05 <jle`> consFrom 0 = 0 `Cons` ???
03:40:09 <zipper> I am expecting something close to: map Cons [1..]
03:40:12 <jle`> can you describe quantatively what should go in that ??? ?
03:40:18 <jle`> like, what in words
03:40:57 <zipper> jle`: An infinite series of Cons and Ints
03:41:07 <jle`> okay, let's try another approach
03:41:13 <jle`> what does consFrom 0 represent?
03:41:17 <zipper> Cons 0 (Cons 1 (Cons 2))...
03:41:27 <jle`> like, give a function spec
03:41:31 <zipper> jle`: Infinite list from 0
03:41:37 <jle`> okay
03:41:42 <jle`> so consFrom 0 = 0 `Cons` ???
03:41:49 <jle`> what is ??? supposed to be?
03:42:10 <zipper> jle`: 1 Cons ...
03:42:15 <jle`> in words
03:42:25 <jle`> the same way you described what consFrom 0 was
03:42:57 <zipper> Inifinite series of ints and the value constructor "Cons"
03:43:06 <jle`> here's how you described consFrom 0:
03:43:10 <jle`> "an infinite list from 0"
03:43:19 <jle`> try to use the same teriminology/language
03:43:23 <BoR0> infinite is closely related with recursion :)
03:43:26 <jle`> consFrom 0 = 0 `Cons` ???
03:43:34 <jle`> ??? is also an infinite list, right?
03:43:41 <jle`> and what else can you say about its contents?
03:43:43 <zipper> Inifnite Stream from 1
03:43:55 <zipper> It's a Stream but...
03:44:00 <jle`> mhm
03:44:06 <zipper> I get what you mean.
03:44:09 <jle`> so ??? = an infinite stream from 1
03:44:14 <zipper> jle`: Yes
03:44:15 <jle`> do you now how to give me an infinie stream from 1
03:44:16 <ocharles> The Prelude documentation states that for Float: "Single-precision floating point numbers. It is desirable that this type be at least equal in range and precision to the IEEE single-precision type."
03:44:17 <jle`> ?
03:44:27 <ocharles> Is there a type that has *exactly* the precision of a IEEE single-precision float?
03:44:32 <zipper> jle`: map Cons [1..]
03:44:36 <jle`> hm
03:44:46 <jle`> what is consFrom 0?
03:45:21 <zipper> A function that yields an infinite stream of Ints starting at 0
03:45:28 <jle`> it's not a function
03:45:38 <zipper> Where a Stream is a series of Ints and Cons
03:45:42 <zipper> jle`: What is it?
03:45:46 <jle`> it's a value
03:45:48 <jle`> you said it earlier
03:45:53 <jle`> consFrom 0 :: Stream Int
03:45:54 <hpc> :t consFrom 0
03:45:55 <lambdabot> Not in scope: ‘consFrom’
03:46:04 <jle`> consFrom 0 is an infinite stream starting from 0
03:46:07 <zipper> jle`: True :)
03:46:20 <jle`> so
03:46:26 <jle`> what is countFrom 1 ?
03:46:56 * hackagebot criterion-plus 0.1.2 - Enhancement of the "criterion" benchmarking library  http://hackage.haskell.org/package/criterion-plus-0.1.2 (NikitaVolkov)
03:47:09 <zipper> A value. A stream starting at 1
03:47:14 <jle`> okay
03:47:16 <zipper> jle`: So then that's how to make a value of type Stream?
03:47:19 <jle`> so remember when we were implementing consFrom 0
03:47:25 <jle`> consFrom 0 = 0 `Cons` ???
03:47:27 <zipper> Using map?
03:47:33 <BoR0> don't think in terms of map because what it basically does is [Cons 1, Cons 2...] and those are not valid constructors
03:47:33 <jle`> *countFrom
03:47:41 <jle`> countFrom 0 = 0 `Cons` ???
03:47:47 <zipper> BoR0: OMG yes
03:47:55 <jle`> and we concluded that ??? had to be an infinite stream starting from 1
03:47:58 <BoR0> just read what jle is saying
03:47:58 <jle`> and....
03:48:04 <zipper> BoR0: So it'll give [Stream a]
03:48:06 <jle`> we also just found out
03:48:19 <jle`> that countFrom 1 gives you an infinite stream starting from 1
03:48:23 <jle`> so maybe that means that....?
03:48:26 <jle`> what can we put in ??? ?
03:48:49 <jle`> in summary: (1) countFrom 0 is an infinite stream from 0.
03:48:57 <jle`> (2) countFrom 0 = 0 `Cons` ????
03:49:01 <jle`> (3) that ??? has to be an infinite strema from 1
03:49:03 <zipper> jle`: 0 `Cons` 1 `Cons` 2
03:49:11 <jle`> (4) countFrom 1 happens to be an infinite stream from 1
03:49:15 <jle`> (5) so, what is ??? ?
03:49:29 <zipper> countFrom 2
03:49:38 <jle`> ??? is an infinite strema from 1
03:49:43 <zipper> jle`: countFrom 2 is what we put there
03:49:44 <jle`> but countFRom 2 is an infinite stream from 2
03:49:47 <jle`> so, maybe not
03:49:52 <jle`> we're looking for an infinite stream from 1
03:49:57 <jle`> but countFrom 2 is an infinite stream from 2
03:50:00 <zipper> countFrom 1
03:50:01 <jle`> you're getting close  :)
03:50:12 <jle`> ah
03:50:13 <jle`> perfect :D
03:50:13 <zipper> jle`: :)
03:50:18 <jle`> so
03:50:22 <jle`> countFrom 0 = 0 `Cons` ???
03:50:25 <jle`> can you finish it?
03:51:08 <zipper> jle`: Yes give me a second
03:51:21 <jle`> what did we say ??? was?
03:51:24 <jle`> just plug it in :)
03:51:47 <zipper> countFrom 1
03:51:52 <jle`> write it all out
03:51:54 <zipper> I'm trying to make something like
03:51:57 <jle`> countFrom 0 = ....
03:52:05 <jle`> just so i know you're following :)
03:52:59 <zipper> jle`: contFrom 0 = Cons 0 (countFrom [1..])
03:53:04 <jle`> hm
03:53:05 <jle`> wait
03:53:09 <jle`> you just said that ??? = countFrom 1
03:53:15 <jle`> so how come you put countFrom [1..] there?
03:53:38 <zipper> jle`: I'm trying to make countFrom get called infinitely.
03:53:44 <zipper> No wait
03:53:45 <BoR0> zipper, forget about map, and [1...]. think of recursion
03:53:53 <jle`> let's just take this one step at a time
03:53:59 <zipper> jle`: contFrom x = Cons 0 (countFrom [1..])
03:54:04 <jle`> 1) we thought about countFrom 0 = 0 `Cons` ???
03:54:08 <jle`> 2) we realized that ??? = countFrom 1
03:54:08 <zipper> Ah I see the flaw in my logic
03:54:15 <jle`> so then...?
03:54:19 <jle`> countFrom 0 = ....?
03:54:20 <Welkin> @let ??? = 42
03:54:20 <lambdabot>  Parse failed: Parse error: ???
03:54:25 <Welkin> @let f??? = 42
03:54:25 <lambdabot>  Parse failed: Parse error: =
03:54:39 <jle`> just plug in the blank
03:54:40 <zipper> countFrom 0
03:55:05 <jle`> countFrom 0 = ...?
03:55:10 <jle`> maybe the point of the ??? wasn't clear
03:55:48 <zipper> countFrom 0 = 0 `Cons` countFrom 1 `Cons` countFrom 2 ...
03:55:55 <jle`> hm
03:56:00 <jle`> you're overthinking this
03:56:05 <jle`> countFrom  0 = 0 `Cons` ???
03:56:09 <jle`> ??? = countFrom 1
03:56:11 <jle`> so
03:56:13 <jle`> countFrom  0 = ....?
03:56:24 <zipper> jle`: 0 `Cons`
03:56:28 <jle`> ....?
03:56:32 <jle`> and then what goes after?
03:56:43 <zipper> countFrom 1
03:56:46 <jle`> yes
03:56:47 <jle`> :D
03:56:49 <jle`> so write it all out
03:57:14 <zipper> countFrom 0 = 0 `Cons` countFrom 1 `Cons` countFrom 2 `Cons` countFrom 3....
03:57:19 <jle`> hm
03:57:31 <jle`> okay
03:57:33 <jle`> do you understand
03:57:36 <jle`> when we say something like
03:57:38 <BoR0> zipper, you need to smartly represent "...." in Haskell
03:57:41 <jle`> foo x = y ???
03:57:46 <jle`> and then we say ??? = 35
03:57:49 <jle`> then that means
03:57:52 <jle`> foo x = y 35
03:57:54 <jle`> right?
03:57:59 <zipper> BoR0: but you won't let me use [0..]
03:58:00 <jle`> you just take 35 and plug it in where ??? is
03:58:05 <jle`> right?
03:58:10 <BoR0> zipper, forget of that and map. read what jle is saying. think recursion
03:58:13 <jle`> let's try an exercise in plugging in values
03:58:16 <jle`> if i say
03:58:22 <jle`> foo y = Bar ???
03:58:28 <jle`> and i say ??? = baz
03:58:31 <jle`> then:
03:58:35 <jle`> foo y = Bar baz
03:58:39 <zipper> foo y = Bar baz
03:58:40 <jle`> right?
03:58:42 <jle`> okay
03:58:46 <jle`> countFrom 0 = 0 `Cons` ???
03:58:49 <jle`> ??? = countFrom 1
03:58:50 <jle`> so....?
03:59:08 <zipper> countFrom 0 = 0 `Cons` countFrom 1
03:59:13 <jle`> yes :D
03:59:27 <jle`> now let's define countFrom 1
03:59:33 <jle`> countFrom 1 = 1 `Cons` ...?
04:00:07 <zipper> jle`: countFrom 2 `Cons` ...
04:00:13 <jle`> hm
04:00:19 <jle`> countFrom 0 = 0 `Cons` countFrom 1
04:00:24 <jle`> countFrom 1 = 1 `Cons` ?????
04:00:38 <jle`> you might be able to notice a pattern
04:00:44 <zipper> jle`: 1 `Cons` countFrom 2
04:00:46 <jle`> yes
04:00:48 <jle`> :D
04:00:54 <jle`> countFrom 2 = 2 `Cons` ...?
04:00:58 <zipper> OMG epiphany
04:01:10 <jle`> finish it :)
04:01:11 <zipper> 2 `cons` countFrom 3
04:01:14 <jle`> okay
04:01:16 <jle`> so
04:01:18 <jle`> do you notice a pattern?
04:01:22 <jle`> countFrom n = n `Cons` ....?
04:01:45 <jle`> countFrom n = n `Cons` countFrom (???)
04:01:51 <zipper> countFrom n = n `Cons` countFrom n+1
04:01:55 <jle`> mhm
04:01:58 <jle`> but you need parentheses
04:01:59 <zipper> countFrom n = n `Cons` countFrom (n+1)
04:02:02 <zipper> Yes
04:02:02 <jle`> yes
04:02:04 <jle`> :D
04:02:08 <jle`> there ya go.
04:02:18 <zipper> OMG I think I know how to make these values now
04:02:39 <jle`> if you don't believe that that is the correct form, you can try evaluating it out by hand
04:02:45 <jle`> if you try evaluating out countFrom 100
04:02:53 <jle`> you get countFrom 100 = 100 `Cons` countFrom 101
04:02:55 <zipper> jle`: I believe it.
04:03:03 <jle`> = 100 `Cons` (101 `Cons` countFrom 102)
04:03:17 <jle`> = 100 `Cons` (101 `Cons` (102 `Cons` ...))
04:03:19 <jle`> etc.
04:03:31 <jle`> so there ya go
04:06:58 <jle`> sgillis: btw, that is forM_ from Data.Foldable
04:07:20 <jle`> hm, wait, nvm
04:07:42 <zipper> stillwater: It's the one I'm taking but the 2014 one. cs194 and this channel is where I run when things get tough
04:08:24 <zipper> bernalex: What do you guys develop? In which country? You can avoid these questions if they feel personal.
04:08:30 <prinsen> Any haskellers here from Facebook?
04:08:31 <zipper> bernalex: Ignore
04:09:06 <bernalex> zipper: currently we are working on backend Web stuff. in Norway.
04:09:31 <zipper> bernalex: Sweet. Wow sweet stuff in a sweet country.
04:09:43 <zipper> bernalex: Awesome. I hope it's going well.
04:09:47 <pyon> Is there any combination of GHC extensions (other than Template Haskell) that makes it possible to do polytypic programming without writing anything that looks like the implementing the Visitor pattern using type classes?
04:09:56 <bernalex> zipper: thank you!
04:19:38 <zipper> ski: I just got your message thanks.
04:36:56 * hackagebot apiary 1.2.1 - Simple and type safe web framework that generate web API documentation.  http://hackage.haskell.org/package/apiary-1.2.1 (HirotomoMoriwaki)
04:36:58 * hackagebot apiary-logger 1.2.1 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-1.2.1 (HirotomoMoriwaki)
04:37:00 * hackagebot apiary-persistent 1.2.1 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-1.2.1 (HirotomoMoriwaki)
04:37:02 * hackagebot apiary-authenticate 1.2.1 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-1.2.1 (HirotomoMoriwaki)
04:41:56 * hackagebot apiary-purescript 1.2.1 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-1.2.1 (HirotomoMoriwaki)
04:41:58 * hackagebot apiary-mongoDB 1.2.1 - mongoDB support for apiary web framework.  http://hackage.haskell.org/package/apiary-mongoDB-1.2.1 (HirotomoMoriwaki)
04:42:00 * hackagebot apiary-memcached 1.2.2 - memcached client for apiary web framework.  http://hackage.haskell.org/package/apiary-memcached-1.2.2 (HirotomoMoriwaki)
04:42:02 * hackagebot apiary-helics 1.2.1 - helics support for apiary web framework.  http://hackage.haskell.org/package/apiary-helics-1.2.1 (HirotomoMoriwaki)
04:45:54 <zipper> Hey there's this tool meant to log irc stuff that's usually written in haskell. I can't find it right now. Does anyone know what I'm talking about?
04:46:27 <capisce> what does "usually written" mean? :)
04:52:08 <zipper> I meant it's written in haskell
04:52:12 <zipper> My bad
05:02:19 <indiagreen> ircbrowse.net?
05:10:21 <zipper> indiagreen: I think it's the one thanks
05:14:31 <nkar> how can I pass an option to cabal test?  cabal test --test-option=--foo returns test: unrecognized option foo (I'm using hspec if it matters)
05:22:58 <mmachenry> I want to write a program that uses System.Daemonize, which produces a program that accepts command-line arguments. I also want to accept more arguments before I call that library. Is there a way strip what's in getArgs before I call it?
05:24:46 <geekosaur> withArgs?
05:27:14 <makalu> I've used "(setq haskell-process-type 'cabal-repl)" and when I load a file in the repl it still complains about missing packages that are installed in the sandbox
05:27:39 <geekosaur> oh, hm, that's unfortunate. the h-p docs show System.Environment from haskell2010, not from base
05:27:59 <geekosaur> http://hackage.haskell.org/package/base-4.7.0.1/docs/System-Environment.html#v:withArgs
05:29:35 <naxa> a language-agnostic question here, is there a name for such a high-order function that applies a list of functions one by one to a single data and produces a list from the results?
05:30:27 <naxa> (context: not hard to write one which I need in python and I'm asking around whether this thing has a name)
05:30:32 <znst> a mapping function, maybe
05:31:08 <naxa> znst: I'd like an exact specific name, maybe mapping function is too broad? I'd just like to avoid inventing names if there is one already
05:31:32 <znst> znst: ruby has good functions, similar to what you described, for arrays - http://www.ruby-doc.org/core-2.1.5/Array.html#method-i-map
05:31:44 <znst> naxa: ^ don't mind me, i have a habit of talking to myself
05:31:45 <Flonk> shachaf: sorry, had to attend a lengthy meeting
05:31:53 <naxa> I see I check it out thank you!
05:32:11 <Flonk> shachaf: I'll just read through some more articles on cat theory now, maybe I'll get the intuition
05:32:17 <vanila> map (flip ($)) does this
05:32:28 <vanila> since it's so easily derived from map it doesn't have a usual name
05:32:40 <naxa> I see...
05:32:53 <clrnd> naxa, fmap? functor maybe
05:32:59 <clrnd> functors are "mappable structures"
05:33:18 <makalu> chrisdone: here?
05:34:48 <clrnd> naxa, sorry read it badly, you have [a -> b] -> a -> [b]
05:35:42 <clrnd> so it's like Applicative
05:36:08 <bernalex> vanila: naxa: or just 'map ($ x) [f]'.
05:37:31 <bernalex> naxa: then there's 'zipWith ($) [f] [x]', which is also useful.
05:38:07 <bernalex> though [f] <*> [x] might make more sense in some cases
05:41:09 <vanila> made a mistake, it's map . flip ($)
05:42:38 <mmachenry> ReinH: Yay, listening to the new Haskell Cast. Thanks :)
05:43:10 <speak> Link mmachenry ?
05:43:10 <makalu> chrisdone: sorry for bothering, nvm
05:44:16 <makalu> I have installed accelerate 0.14, imported Data.Array.Accelerate and cabal build says "Not in scope: data constructor `DIM1'" what the heck?
05:45:53 <makalu> oh, it's a type, there's no constructor with that name
05:47:38 <mmachenry> speak: http://www.haskellcast.com/episode/009-conal-elliott-on-frp-and-denotational-design/
05:47:44 <mmachenry> There are nine of them.
05:48:05 <speak> Thanks mmachenry :)
05:48:28 <solirc> nkar: e.g. cabal test --test-option='-a 1000'
05:48:52 <naxa> bernalex: I see thank you!
05:49:08 <mmachenry> speak: ReinH is a regular on this IRC if you want to thank him. (or flame him of course)
05:49:24 <solirc> nkar: The unrecognized option foo message is from Hspec
05:49:28 <speak> mmachenry: Hehe alright :)
05:49:33 <bernalex> oh is the conal interview up again?
05:49:43 <bernalex> s/again/now/
05:49:51 <mmachenry> bernalex: Yes.
05:49:55 <mmachenry> Listening now.
05:50:15 <mmachenry> It's pretty good so far. All about FRP (which I'm learning he does like the name)
05:51:01 <bernalex> conal is awesome. the bob ross of functional programming.
05:51:07 <makalu> is there no shorthand for creating a vector from a list in accelerate? "use (fromList (Z :. length lst) lst)" is awfully long
05:51:56 * hackagebot containers 0.5.6.1 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.6.1 (MilanStraka)
05:52:59 <mmachenry> bernalex: Does he put a happy little second mouse cursor over hear in the top corner?
05:53:08 <mmachenry> *here*
05:53:42 <nkar> solirc: hi!  so, how do I tell hspec to recognize 'foo'?
05:54:09 <bernalex> we don't make mistakes in haskell; we just have accidents.
05:55:01 <makalu> happy little accidents
05:55:15 <bernalex> erm yes
05:55:30 <bernalex> we don't make mistakes in haskell; we just have happy accidents.
05:56:01 <bernalex> makalu: the actual quote I am referencing is not "little". which I think appropriate. I have had big accidents in haskell. they were happy though.
05:56:10 <solirc> nkar: What exactly do you want to do?
05:56:38 <makalu> bernalex: yeah, I only looked at the first google answer but the rest were without little :P
05:56:52 <makalu> sorry
05:57:17 <nkar> solirc: I have a number of tests, and I'd like to not run one of them by default; only when a certain option is specified.
05:57:39 <nkar> solirc: "test" as in "spec"
06:02:27 <solirc> nkar: I use environment variable for that
06:03:12 <solirc> nkar: command-line arguments are consumed by Hspec
06:03:27 <nkar> solirc: okay, I can live with that.  but please consider adding this feature.  'Config' looks like the right place for it.
06:05:38 <solirc> nkar: here is some code https://gist.github.com/sol/c6f5294bc6bf013c51e7
06:07:29 <solirc> nkar: Only runs wrapped specs when "WITH_SOLR=true cabal test"
06:07:52 <nkar> cool, thanks for sharing!
06:09:33 <solirc> nkar: Sadly my keyboard time is limited right now, but if you have a clear picture on how this feature you suggest should behave, you can open a ticket
06:11:00 <nkar> solirc: no worries, I'll think about it and add a ticket if I come up with a good model
06:14:12 <zmbmartin> I am drawing a blank here. I have `newtype UserEmail = UserEmail text` then I am trying to unpack that to string `T.unpack $ user_email j` but get an error expected T.Text got UserEmail
06:14:26 <zmbmartin> Just playing with different things with newtype.
06:14:48 <mauke> what are text, user_email, and j?
06:15:02 <zmbmartin> mauke: Sorry text should be T.Text
06:15:50 <zmbmartin> I user UserEmail in my `data User = User {user_id :: UserId, user_email :: UserEmail}`
06:16:10 <zmbmartin> j is the user json.
06:16:31 <mauke> ok, so you need to extract the Text from UserEmail
06:17:16 <zmbmartin> mauke: Yeah and I feel like I have done that before, but I am drawing a blank.
06:17:23 <mauke> pattern matching
06:17:36 <mauke> let UserEmail t = user_email j in ...
06:17:43 <mauke> or case user_email j of UserEmail t -> ...
06:17:51 <mauke> you could wrap it in a helper function
06:18:08 <mauke> textOfUserEmail (UserEmail t) = t
06:18:29 <zmbmartin> mauke: :) duh, I was going somewhere way different in my mind.
06:18:37 <zmbmartin> mauke: Thanks
06:18:38 <mauke> you could use record syntax to create that function: newtype UserEmail = UserEmail{ textOfUserEmail :: Text }
06:20:16 <zmbmartin> mauke: Great thanks again. I have been on a learning quest, but away for about 2 weeks with other languages and I feel like I forgot some things now.
06:25:45 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org (migrating) | http://downloads.haskell.org'
06:25:45 --- topic: set by geekosaur on [Tue Nov 18 16:03:41 2014]
06:25:45 --- names: list (clog_ Natch_z sebhoss_ OlegYch9 danthemyth mithsv Guest67581 mmachenry1 Azel rodlogic_ tromp xeno_ goldfire1 jo__ ibid Takle doodlehaus pyed ecthiender it0a DblZ zcourts Benzi-Junior RaceCondition perspectival SuneAlkaersig helgikrs pdpi byprdct mizu_no_oto prosper_ juhp_ _Vi juanpablo_ AncientPC tinchos cpennington fumieval felipedvorak platz stianhj _deepfire caumeslasal folone Guest67515 jvilla ifesdjeen sriprasanna Aune d_k PatrickRobotham eeLieAh exio4)
06:25:45 --- names: list (athan Oxyd zipper thawes phatle qxjit dfeuer takuan dgpratt g0r Gurkenglas Profpatsch knoxilla ruukasu jamiely e_svedang znst naxa _ashbreeze_ nominolo bam365 tristanp edsko jpfuentes2 favetelinguis yalue kdlv Rufflewind hatzopoulos_ jesyspa rufs eazar001 johannes__ Guest33017 jkarni1 umbriel sebhoss eXeC64 sea-gull- Stratege__ mmachenry edon psy_ bananagram hamishmack phischu jomg quantum-mechanic carlosgaldino zmbmartin usr Nshag Paprikachu nemesit|znc)
06:25:45 --- names: list (drdo Iskarlar1 xophmeister eacameron Svedrin Edoxile pnielsen dkbrk _ixti_ Ferroxide pwestlund_away Haskellfant hebz0rl Nickeeh alanz sohum ]OLI[ fnordbert jophish rtpg thirsteh Zeitgeist_ himikov bezirg edk jonrh_ michael-k aergus wei2912 aloiscochard tarcwynne__ lenstr Iskarlar tsenart_ carter_cloud amiri free_beard stereotype_ dlackty_ banister npcomp Drezil chrisdone tesuji monochrom predator117 lostman_ andreypopp_ idnar brennie electrogeek Raynos)
06:25:45 --- names: list (bcarrell Sebastien-L ikkebr thorkilnaur FofG thevishy cloudhead_ kgzm_ frogpunc_ Ralith_ chrisdotcode Hijiri sw1nn_ ocharles_ integral_ akahn rahul_ hongminh1e Claudius1aximus zpconn__________ stelleg purefn_ oldmanstanley___ Zekka_ Elsi lacrosse__ XMunkki_ platinuum anry vobi lectrick mattswe Chaoya1 msgodf mimi_vx clrnd jdeeburke solarus tridacty1a seancorfield SegFaultAX David JamesJRH_ bgyss Lacriatch sross_work|2 antinomy_ periodic_ liyang_ k4r1m)
06:25:45 --- names: list (joedevivo redeemed Guest47326 noam_ Sgeo_ jpll renekooi ipuustin hellertime tarruda_ rylev mjs2600 mungojelly Orwell84 yonson NightRa datalligator danten jcpetruzza rodlogic DanielDiaz agjacome arpunk bitonic ChadMiller-- havyan eslr Yuras indiagreen xificurC gienah tinyblak_ _aegis_ kapil__ fling trnh ZioCrocifisso Lowl3v3l tonbo blouerat ceii arianvp__ sheyll``` dkasak malllle tibell lritter_ peldan vlatkoB_ glguy__ indigo945 oish jzl sgillis autochthon)
06:25:45 --- names: list (_zxq9_ SoupEvil nomeata erikd Thhethssmuz CrankOne sbjorn dr__ macalimlim rgr silasm Plastefuchs lyxia nisstyre ventonegro marr horlicks_ ashnur jordanl bjz Lethalman tomku arenz kinslayer ThatOtherPerson jigglemaster1999 aarvar Natch mmmm albertid nilg sivteck silver kini slomo martintrojer manuel__ Jackneill Flonk djcoin raichoo funfunctor glguy_ thunderrd Mokosha_ shintah srenatus quchen2 stubborn_d0nkey greenbagels__ Chathurga Garner vili ThomasLocke)
06:25:45 --- names: list (DrCode danvet darkbolt dcoutts_ calvinx ddellacosta hackagebot sakirious eisbehr andjjj23 angerman hpc ryanakca cinimod` echo-area Longlius sxn` fishkandy charlie blicero_ croyd jmct bgamari angelicstrike petantik ggherdov kjanosz RchrdB zrl andbroby tazjin anttih_ neptunepink gws ZucchiniZe rsynnest otherchas Sorella biscarch joshsz asabil casual_ myyst u___ hiratara dreixel_ petermw_ dotsspwe mauke caseswitch visof otto_s_ davidstone shanse srcerer pyon)
06:25:45 --- names: list (Cr8 katsh thetallguy Khisanth dsfox1 dibblego Myk267 tobik cleamoon pks apaku plucas bb010g brent80_plow dabradley tgeeky sinopeus tv1 infinity0 cfloare zanchoPansa simonnn m00nlight __main__ mgsloan peterhil andrew__n TgMts MP2E dav poindontcare tsani dcoutts hazz tdammers tm512 octalsrc acln nuttycom jfhall agatam bonobo Ulrar clog nkar zz_log0ymxm favonia mceier zso n4x Jesin cmsmcq Romtam idupree bind ChristianS Sonderblade hbar hpd cjheath keltvek)
06:25:45 --- names: list (aaronweiss74 sleepynate JZTech101 finnrobi bjobjo mrshoe fabjan Eagle_Erwin pp^ Aquana Adeon lvh taktoa anannie sobaken_ ernst tromp__ dolio kofno k-u realli roo [swift] cynick DanZimm clementd natte irssi claudiyoh benbangert ggreg mlen Licenser tassmjau bvad shmookey Clint lokydor Freundlich ephess Antoine59 wayne chasecal1 ido myme owlglass2 Kaini ivoscc solirc qtplatypus dan64 arch_ s_e schlumpi Baughn statusfailed quaestor1 miasma d3lxa gnomnain` ezrios)
06:25:45 --- names: list (ahf glowcoil qz burp Ptival angryzor cjay proycon twopoint718 hhkb Chousuke_ sbrg Rylee haroldwu jlewis_ susmus simon chridal jlewis uwap betawaffle Philonous goldfire apo Crazypyro ethercrow centrinia gseitz Kabaka bjorkintosh pikaren tristero stepkut razorsharph Dzyan PierreM statusbot tharugrim posco ValicekB ilken unsymbol glguy estulticia kbeaty darthdeus agumonkey joehillen theshadow BeardedCoder spion tomboy64 Nik05 albeit mads- _5kg da-x c_wraith)
06:25:45 --- names: list (TrafficMan antoine`` myst|work mirsal stepcut zoglesby blicero araujo dmead oldmanmike inad922 Quashie__ ForNeVeR orion xinming juhp tumdedum michaelpj liamgoodacre L8D skrio netj GGMethos terlar krgn sh1ken lattenwald devll IanKelling OlegYch mankaev uber ehamberg mpw AlainODea hive-mind joefiorini teehemkay_ manytrees joefiori__ LQDHelium eristic_ hape01 ousado ps-auxw c74d3 ft howard nick1234abcd__ fr33domlover Kobata theanalyst isenmann Mortomes_ renzhi)
06:25:45 --- names: list (adamse zxq9 ivan\ petercommand sunnavy augur nshepperd davidfetter lifenoodles pieter brandonw ryu91835 _janne friden dodgems shergill dogmaT semigroup dropdrive plhk fiatjaf only_the_bear albel727 ldcn Jaak Church- jmcarthur john_not_jenny jaffachief Xack jedai untwisted flyingfisch jrib moop butyoudonot tg Deewiant rola Intensity jle` paf31_away StoneToad tnks mikeplus64 mgaare NotADJ testin wolf_mozart ktosiek skarn aseidl ConstantineXVI Klumben cschneid)
06:25:45 --- names: list (seliopou newsham Forkk Boreeas pii kalail_ mbrcknl blindscreen dkua chriswk____ mankyKitty huonw vikraman ThreeOfEight jroesch___ phaazon seagreen acharles rom1504 rfw Enigmagic pikhq shennyg_ zxtx Farow liuw Polarina staffehn Sornaensis btc__ dstockwell bjornars1 Spaceghost nitrix Guest72203 BlueTiktalik ttuegel machineslearn Reyu ReinH joelteon lericson pharpend NikolaiToryzin caasihuang emmanueloga wizonesolutions robotbrain stephenmac7 jonsterling)
06:25:45 --- names: list (ByronJohnson redtricycle cjwelborn mawuli morolin edran mrb_bk dpn` ab9rf acfoltzer drewdavis Hugglesworth werdna ChongLi m_george_ ortmage mitchty Bigcheese Xorlev hmax helgar shelling_ jabbslad aristid_ taniguchi Kneiva Fusxfaranto pjdelport jrslepak LordBrain mikeizbicki wjm sunfun chpatrick paraseba u-ou texasmynsted RevJohnnyHealey Zariel sofancy oconnore_ thomie jludwig_ absence_ cowtown karls zasimov Watcher7 Vbitz annulus superjudge TDJACR nille)
06:25:45 --- names: list (gbarboza FireFly AntiSpamMeta BlastHardcheese s4msung adlan raid Riviera Floyd_ peddie Blkt LordDeath Erstarrung iulian metaf5 haasn JPohlmann gdsx itsmonktastic callumacrae _rgn tawm magicman kungp dlundy Lutin` jdiez heaumer mokus srbaker cods bergmark yukko stvc maurer efm Spockz mattp_ zenzike dehflingus_ blast_hardcheese sordina3 kwantam koala_man sorind amontez prinsen eyem Nanar tromp_ barrucadu fvt agrif HylianSavior wires` mendez Saizan Walther tov)
06:25:45 --- names: list (naudiz|offline yam SwashBuckla KorriX mjrosenb Cathy dflemstr `micro_ kosmikus Starfire mietek BrianHV totte Ferdirand ephemeron dmilith ij SaBer liff supki SLi pfoetchen Guest6003 bernalex marienz dju okic_ julienXX jaspervdj Miciah Martty koninkje1away arianvp_ nexion orbital so ajcoppa vlopez keaml d-snp vermeille eL_Bart0 TheMoonMaster pdxleif mami thebnq paz__ taruti tero-_ gargawel brackets Desoxy_ osfameron wting_ xaimus_ Pucilowski swook sellout)
06:25:45 --- names: list (Preyer eamelink kloplop321 Taneb bolmar fuziontech____ joeytwiddle Gothmog_ larsen julmac seubert brisbin obiwahn zeroskillor jcp geal Twey Yawgmoth mgomes elfangor TakSuyu cryon adadad frawgie_ lpsmith pi8029 iota_ dunj3 froztbyte shapr go|dfish indigo shutdown_-h_now joe_k davesilva deni gidogeek spindas runde dustinswan bastian__ lassulus Gracenotes tomejaguar_away dawik luite drewr Tehnix hiredman joshc Ezku fold edwtjo futureperfect sgronblo)
06:25:45 --- names: list (therealklanni adarc scopedTV cross pharaun Laney poucet kragniz tstc yeltzooo GaveUp knyon mero ivan` swen aleator_ honza kgadek tych0 zebr mrd gridaphobe noplamodo Ke tomaw ormaaj mandu mmmpork ninzine `bps hrnz Belgarion0 ToRA bens McManiaC sipa fergusnoble idoru thomas mozmoney noidi bailon greymalkin Jaxan hsc JRoberts jlouis M-ou-se Jonno_FTW Zorg Eliel_ Dtgr_ defanor znutar DarkFox dougia_ MK_FG belst HugoDaniel yaopo shepheb notdan ParahSailin owa)
06:25:45 --- names: list (keko-2 saiam diprosaurus xtsee stiell lurker6_ jix_ Rutger`_ KitC kandinski frontend1oader DanToml_ `0660 vukcrni dmbaturin int-e eagleflo bcoppens Tordek inr_ Logiar johnw dav1d mathu Transfusion adnap smart_ptr knyppeldynan xandaros shiona dp_wiz_ enomies noctux nathanic comma8 wtw cosmicexplorer zariuq suvash_away milli` felixsch Noinia davidthomas cchalmers connerb Jello_Raptor alang japesinator shelf luzie lpaste cin fall_ rieper_ ziman wto tekacs)
06:25:45 --- names: list (Fuuzetsu zymurgy joehh1 Jactive|OFF bydo lyddonb Shandy Rembane otterdam bruston liste boegel|work conehead SuperTux88 xea imalsogreg hvr Fubar^ Vq teeteewhy perrier_ cic pygospa dschoepe yorick wollw Zemyla Liskni_si Talryn ljhms mrowe_away ryan_t KeelOfSteel gandr wormphle1m mitu heikkih Brando753 averell majoh geekosaur Zol_ Laquendi jasu0 hegge pyrtsa aivuk brixen flux thamz lahwran Athas SalamanderFood parallel21 gratimax maaku gds otulp magicflakes)
06:25:45 --- names: list (aaronlevin jcurbo zerokarmaleft qzzx alpounet rjsalts wjlroe vladan kakos monsieurp mortberg ketcat MasseR heurist dfranke jorj dabukalam jakutis catsup jlyndon puzza007_ etrepum si14 korpse MMuse______ hguux_ Tesseraction dutchie S11001001 edwardk moy arun canta RGamma Cerise ma82 mach rs0 eikonos honkfestival banjiewen wjt benzrf yrashk__ drbean_ zph segmond kirjs______ mno2_ seanparsons elgot Dykam pawnda somenick greeny_ paperManu dyreshark luigy eyenx)
06:25:45 --- names: list (samek matson andreasrx kloeri nakal sadgit emma jackhill DigitalKiwi sbauer322 vpm ixian kalloc demolithion dario` jrp6 ens_ kvieta mmaruseacph2 kalz kipras`away maw nesqi saurik eyck thoughtpolice grohne deavidsedice fyolnish ndeine jrp6^2 Dodek klugez Axman6 Gx00- hyPiRion linduxed srhb tismith Scorchin avdi hellschreiber cojy jzelinskie bkolera n1ftyn8 divyanshu lohkey CARAM_ tobiasgw Hafydd cstrahan_ MiracleBlue gnusosa saep l3dx falafel c9sould__)
06:25:45 --- names: list (NemesisD Adios Dyrim dagle CodyReichert sujeet troydm nmontecc Cale ThePhoeron Nimatek noddy zyla dj_ryan xeno Ornedan tomprince kav gspr gregburd_ joefiorini_ nyuszika7h atondwal heath jlamothe fryguybob stass jang1 MitchW timthelion Paks Lindrian dqd dgonyeo sssilver codeburg marchdown hc nik_89 omefire rofer nmashton larrytheliquid__ alphonse23_ leifw ircbrowse Plasmastar _ikke_ Maxdamantus dsantiago ahihi PHO theorbtwo qrada_ qr42 Draconxx zeiris_)
06:25:45 --- names: list (vincom2 tac-tics Th0mas sprang emlow fikusz hopnotch l3kn stomp guampoid eatman _br_ l_ch_nm_y_r gniourf Artpicre mjo dgvncsz0f phadej_ pqmodn_ estewei_off yrdz byorgey SHODAN Soft s00pcan stew slogsdon spacebug comboy fawku monty MilkWhistle Landon slobo carter sclv isomorphic mgomezch_ HeladoDeBrownie jstolarek milessabin Qfwfq mak` Wamanuz asjo jud mountaingoat Nahra uman ski FreeFull arrdem anders0 JokerDoom dmwit adimit alem0lars Meeh cdk_ @ChanServ)
06:25:45 --- names: list (shachaf chirpsalot kshannon nulpunkt_ LeaChim_ yumike bitemyapp codyopel timpani esssing zomg raek kish billymeter gx^ petterw aupo dv- xplat numberten seg pii4 heyj Mokosha bbee2 hodapp asm89 bitraten AleXoundOS_ MagBo _fritz_ igniting spwhitt_ robbert` CindyLinz mgregson royadav_ Fuco ZsoL_ Draggor LnL bartavelle coeus_ dredozub- mechairo` lamilami kmicu iteratee sivoais yonkie_ banyan Dashkal lambdabot diginet klarrt Internet13 andreass m4farrel cizra)
06:25:45 --- names: list (mickk_ C4Cypher davean xnyhps echo capisce zz_rabisg abh tessier_ martingale k00mi blenny_ marens eevar ilmig Boney ob Vorpal Jellydog cow-orker Willis speak Tene aristid ninegrid Nivim relrod bgamari_ wagle opqdonut sm itj_away sviterok tolt _d3f gnezdo AshyIsMe lispy dilinger neena c-rog dhrosa earthy josephle dh levi yukonjack jameseb yusukesuzuki pingu rtl ccasin eon` nwf thungsten bsmt iross krakrjak zq lieven jayne theDon fall` TallerGhostWalt antoniy)
06:25:45 --- names: list (Phillemann stbuehler piskrist cmn senseibaka mcbonz aleator Kruppe lucs dowski__ CosmicRay alinab andrewsw joeyh eikke kaol elij tlevine mrkishi DustyDingo agundry Razz bbastian- coconnor)
06:35:36 <zapper> Hi!
06:35:47 <zapper> is there an easy way to extract the fractional part of a double
06:35:52 <zapper> say, I got 5.666
06:36:00 <zapper> how to convert this int 0.666
06:36:19 <zapper> is there a special `rem` operator that works on Doubles?
06:37:18 <mauke_> @hoogle Double -> (Integer, Double)
06:37:20 <lambdabot> Control.Monad.Trans.State.Lazy runState :: State s a -> s -> (a, s)
06:37:20 <lambdabot> Control.Monad.Trans.State.Strict runState :: State s a -> s -> (a, s)
06:37:20 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
06:37:43 <mauke_> > properFraction 5.666
06:37:43 <benzrf> zapper: liftA2 subtract floor id?
06:37:45 <lambdabot>  (5,0.6660000000000004)
06:37:51 <mauke_> > snd (properFraction 5.666)
06:37:52 <lambdabot>  0.6660000000000004
06:37:54 <benzrf> oh that looks much better
06:38:09 <zapper> thanks! The first expression almost gave me a hear attack
06:38:32 <mauke> it's x - floor x
06:38:47 <mauke> only pointlessly obfuscated
06:39:13 <zapper> thanks
06:39:18 <mauke> @pl \x -> x - floor x
06:39:18 <lambdabot> ap (-) floor
06:39:47 <mauke> :t subtract =<< floor
06:39:48 <lambdabot> (RealFrac a, Integral a) => a -> a
06:40:35 <mauke> yeah, that doesn't work
07:26:43 <cbare__> Hello. Could anyone help me understand a bit of syntax?
07:27:06 <cbare__> I'm trying to read the Koen Claessen Functional Pearl paper. He uses lambda expressions with a dot in them, like this: \c. SomeExpression c
07:28:33 <clrnd> cbare__, I think the dot just separates the "arguments" from the "body"
07:28:49 <cbare__> equivalent to -> ?
07:29:25 <clrnd> cbare__, exactly
07:29:46 <clrnd> it's from math notation of lambda calculus
07:30:13 <cbare__> Is that legal syntax in Haskell or just using more formal mathy notation?
07:30:25 <clrnd> https://en.wikipedia.org/wiki/Lambda_calculus#Lambda_terms
07:30:56 <clrnd> afaik it isn't valid haskell, (.) is funciton composition in haskell
07:31:23 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org (migrating) | http://downloads.haskell.org'
07:31:23 --- topic: set by geekosaur on [Tue Nov 18 16:03:41 2014]
07:31:23 --- names: list (clog rribeiro guampoid RaceCondition DrCode oldk bam365 codesoup tsenart thawes jasonkuhrt Swizec vlatkoB mankaev_ ystael cbare__ micrypt EvanR SvenskFisk jakutis janne Yuras SilverKey Javran `^_^v smartPudding evanjs latro`a sross07 faveteli_ telser` krgn xivix M_o_C Iskarlar_ yano Thooms crobbins hsk5 eyck vijaykiran samrat mengu stiell__ oleo mtk Guest4798 Takle_ bezirg umbriel doomlord_1 Noldorin jang pdpi PragCypher amortimer ma82 thunderrd _aegis_)
07:31:23 --- names: list (ValicekB Brando753 ibid centrinia dkasak henrikhodne bananagram linduxed sinopeus aarvar n4x dju Xeironis ski aaronweiss74 pii4 {AS} dyreshark gratimax_ spwhitt JagaJaga monochrom dboik bergey paralle21_ ThePhoeron infinity0 David s00pcan_ Nimatek_ numberte1 funfunctor nik_89_ sw1nn Maxdaman1us otulp dv-_ fizbin predator217 XMunkki kish` a_ergus Preyer_ d-snp jstolare1 dgvncsz0` osa1 CindyLinz timpani_ mgaare_ LeNsTR|away glguy___ mauke stomp_ puzza007_)
07:31:23 --- names: list (pdxleif Natch_z sebhoss_ OlegYch9 danthemyth mmachenry1 Azel rodlogic_ tromp xeno_ goldfire1 jo__ doodlehaus ecthiender it0a DblZ zcourts Benzi-Junior perspectival SuneAlkaersig helgikrs mizu_no_oto _Vi juanpablo_ AncientPC cpennington felipedvorak platz stianhj _deepfire caumeslasal folone jvilla sriprasanna Aune d_k PatrickRobotham eeLieAh exio4 athan Oxyd qxjit dgpratt Gurkenglas Profpatsch knoxilla ruukasu jamiely e_svedang znst naxa _ashbreeze_ nominolo)
07:31:23 --- names: list (edsko jpfuentes2 yalue kdlv Rufflewind hatzopoulos_ jesyspa rufs eazar001 johannes__ Guest33017 jkarni1 eXeC64 sea-gull- Stratege__ edon psy_ hamishmack phischu quantum-mechanic carlosgaldino usr Nshag Paprikachu nemesit|znc drdo Iskarlar1 xophmeister eacameron Svedrin Edoxile pnielsen dkbrk _ixti_ Ferroxide pwestlund_away Haskellfant hebz0rl Nickeeh alanz sohum ]OLI[ fnordbert jophish rtpg thirsteh Zeitgeist_ himikov edk jonrh_ michael-k aloiscochard)
07:31:23 --- names: list (tarcwynne__ carter_cloud amiri free_beard stereotype_ dlackty_ banister npcomp Drezil chrisdone lostman_ andreypopp_ idnar brennie electrogeek Raynos bcarrell Sebastien-L ikkebr thorkilnaur FofG thevishy cloudhead_ kgzm_ frogpunc_ Ralith_ chrisdotcode Hijiri ocharles_ integral_ akahn rahul_ hongminh1e Claudius1aximus zpconn__________ stelleg purefn_ oldmanstanley___ Zekka_ Elsi lacrosse__ platinuum anry vobi lectrick mattswe Chaoya1 msgodf mimi_vx clrnd)
07:31:23 --- names: list (jdeeburke solarus tridacty1a seancorfield SegFaultAX JamesJRH_ bgyss Lacriatch periodic_ liyang_ k4r1m joedevivo redeemed noam_ Sgeo_ jpll renekooi ipuustin hellertime tarruda_ rylev mjs2600 mungojelly Orwell84 yonson NightRa datalligator danten jcpetruzza DanielDiaz agjacome arpunk bitonic ChadMiller-- eslr indiagreen xificurC gienah kapil__ fling trnh ZioCrocifisso Lowl3v3l tonbo blouerat ceii arianvp__ sheyll``` malllle tibell lritter_ peldan indigo945)
07:31:23 --- names: list (oish jzl sgillis autochthon _zxq9_ SoupEvil nomeata erikd Thhethssmuz CrankOne sbjorn dr__ macalimlim rgr silasm Plastefuchs lyxia nisstyre ventonegro marr horlicks_ ashnur jordanl bjz Lethalman tomku arenz kinslayer ThatOtherPerson jigglemaster1999 mmmm albertid nilg sivteck silver kini slomo martintrojer manuel__ Jackneill djcoin raichoo glguy_ Mokosha_ shintah srenatus quchen2 stubborn_d0nkey greenbagels__ Chathurga Garner vili ThomasLocke danvet dcoutts_)
07:31:23 --- names: list (hackagebot sakirious andjjj23 angerman hpc ryanakca cinimod` echo-area Longlius sxn` fishkandy charlie croyd jmct bgamari angelicstrike petantik ggherdov kjanosz RchrdB zrl andbroby tazjin anttih_ neptunepink gws ZucchiniZe rsynnest otherchas Sorella biscarch joshsz asabil casual_ myyst u___ hiratara dreixel_ petermw_ dotsspwe otto_s_ davidstone shanse srcerer pyon Cr8 katsh thetallguy Khisanth dsfox1 dibblego Myk267 tobik cleamoon pks apaku plucas bb010g)
07:31:23 --- names: list (brent80_plow dabradley tgeeky tv1 cfloare zanchoPansa simonnn m00nlight __main__ mgsloan peterhil andrew__n TgMts dav poindontcare tsani dcoutts hazz tdammers tm512 octalsrc acln nuttycom jfhall agatam bonobo Ulrar nkar zz_log0ymxm favonia mceier zso Jesin cmsmcq Romtam idupree bind ChristianS Sonderblade hbar hpd cjheath keltvek sleepynate JZTech101 finnrobi bjobjo mrshoe fabjan Eagle_Erwin pp^ Aquana Adeon lvh taktoa anannie sobaken_ ernst dolio kofno k-u)
07:31:23 --- names: list (realli roo [swift] cynick DanZimm clementd natte irssi claudiyoh benbangert ggreg mlen Licenser tassmjau bvad shmookey Clint lokydor Freundlich ephess Antoine59 wayne chasecal1 ido myme owlglass2 Kaini ivoscc solirc qtplatypus dan64 arch_ s_e schlumpi Baughn statusfailed quaestor1 miasma d3lxa gnomnain` ezrios ahf glowcoil qz burp Ptival angryzor cjay proycon twopoint718 hhkb Chousuke_ sbrg Rylee haroldwu jlewis_ susmus simon chridal jlewis uwap betawaffle)
07:31:23 --- names: list (Philonous apo Crazypyro ethercrow gseitz Kabaka bjorkintosh pikaren tristero stepkut razorsharph Dzyan PierreM statusbot tharugrim posco ilken unsymbol glguy estulticia kbeaty darthdeus agumonkey joehillen theshadow BeardedCoder spion Nik05 albeit mads- _5kg da-x c_wraith TrafficMan antoine`` myst|work mirsal stepcut zoglesby blicero araujo dmead oldmanmike inad922 Quashie__ ForNeVeR orion xinming juhp tumdedum michaelpj liamgoodacre L8D skrio netj GGMethos)
07:31:23 --- names: list (terlar sh1ken lattenwald devll IanKelling mankaev uber ehamberg mpw AlainODea hive-mind joefiorini teehemkay_ manytrees joefiori__ LQDHelium eristic_ hape01 ousado ps-auxw c74d3 ft howard nick1234abcd__ fr33domlover Kobata theanalyst isenmann Mortomes_ renzhi adamse zxq9 ivan\ petercommand sunnavy augur nshepperd davidfetter lifenoodles pieter brandonw ryu91835 friden dodgems dogmaT semigroup dropdrive plhk fiatjaf albel727 ldcn Jaak Church- jmcarthur)
07:31:23 --- names: list (john_not_jenny jaffachief Xack jedai untwisted flyingfisch jrib moop butyoudonot tg Deewiant rola Intensity jle` paf31_away StoneToad tnks mikeplus64 NotADJ testin wolf_mozart ktosiek skarn aseidl ConstantineXVI Klumben cschneid seliopou newsham Forkk Boreeas pii kalail_ mbrcknl blindscreen dkua chriswk____ mankyKitty huonw vikraman ThreeOfEight jroesch___ phaazon seagreen acharles rom1504 rfw Enigmagic pikhq shennyg_ zxtx Farow liuw Polarina staffehn)
07:31:23 --- names: list (Sornaensis btc__ dstockwell bjornars1 Spaceghost nitrix Guest72203 BlueTiktalik ttuegel machineslearn Reyu ReinH joelteon lericson pharpend NikolaiToryzin caasihuang emmanueloga wizonesolutions robotbrain stephenmac7 jonsterling ByronJohnson redtricycle cjwelborn mawuli morolin edran mrb_bk dpn` ab9rf acfoltzer drewdavis Hugglesworth werdna ChongLi m_george_ ortmage mitchty Bigcheese Xorlev hmax helgar shelling_ jabbslad aristid_ taniguchi Kneiva Fusxfaranto)
07:31:23 --- names: list (pjdelport jrslepak LordBrain mikeizbicki wjm sunfun chpatrick paraseba u-ou texasmynsted RevJohnnyHealey Zariel sofancy oconnore_ thomie jludwig_ absence_ cowtown karls zasimov Watcher7 Vbitz annulus superjudge TDJACR nille gbarboza FireFly AntiSpamMeta BlastHardcheese coconnor bbastian- Razz agundry DustyDingo mrkishi tlevine elij kaol eikke joeyh andrewsw alinab CosmicRay dowski__ lucs Kruppe aleator mcbonz senseibaka cmn piskrist stbuehler Phillemann)
07:31:23 --- names: list (antoniy TallerGhostWalt fall` theDon jayne lieven zq krakrjak iross bsmt thungsten nwf eon` ccasin rtl pingu yusukesuzuki jameseb yukonjack levi dh josephle earthy dhrosa c-rog neena dilinger lispy AshyIsMe gnezdo _d3f tolt sviterok itj_away sm opqdonut wagle bgamari_ relrod Nivim ninegrid aristid Tene speak Willis cow-orker Jellydog Vorpal ob Boney ilmig eevar marens blenny_ k00mi martingale tessier_ abh zz_rabisg capisce echo xnyhps davean C4Cypher mickk_)
07:31:23 --- names: list (cizra m4farrel andreass Internet13 klarrt diginet lambdabot Dashkal banyan yonkie_ sivoais iteratee kmicu lamilami mechairo` dredozub- coeus_ bartavelle LnL Draggor ZsoL_ Fuco royadav_ mgregson robbert` igniting _fritz_ MagBo AleXoundOS_ bitraten asm89 hodapp bbee2 Mokosha heyj seg xplat aupo petterw gx^ billymeter raek zomg esssing codyopel bitemyapp yumike LeaChim_ nulpunkt_ kshannon chirpsalot shachaf @ChanServ cdk_ Meeh alem0lars adimit dmwit JokerDoom)
07:31:23 --- names: list (anders0 arrdem FreeFull uman Nahra mountaingoat jud asjo Wamanuz mak` Qfwfq milessabin HeladoDeBrownie mgomezch_ sclv carter slobo Landon MilkWhistle monty fawku comboy spacebug slogsdon stew Soft SHODAN byorgey yrdz estewei_off pqmodn_ phadej_ mjo Artpicre gniourf l_ch_nm_y_r _br_ eatman l3kn hopnotch fikusz emlow sprang Th0mas tac-tics vincom2 zeiris_ Draconxx qr42 qrada_ theorbtwo PHO ahihi dsantiago _ikke_ Plasmastar ircbrowse leifw alphonse23_)
07:31:23 --- names: list (larrytheliquid__ nmashton rofer omefire hc marchdown sssilver dgonyeo dqd Lindrian Paks timthelion MitchW stass fryguybob jlamothe heath atondwal nyuszika7h joefiorini_ gregburd_ gspr kav tomprince Ornedan dj_ryan zyla noddy Cale nmontecc troydm sujeet CodyReichert dagle Dyrim Adios NemesisD c9sould__ falafel l3dx saep gnusosa MiracleBlue cstrahan_ Hafydd tobiasgw CARAM_ lohkey divyanshu n1ftyn8 bkolera jzelinskie cojy hellschreiber avdi Scorchin tismith)
07:31:23 --- names: list (srhb hyPiRion Gx00- Axman6 klugez Dodek jrp6^2 ndeine fyolnish deavidsedice grohne thoughtpolice saurik nesqi maw kipras`away kalz mmaruseacph2 kvieta ens_ jrp6 dario` demolithion kalloc ixian vpm sbauer322 DigitalKiwi jackhill emma sadgit nakal kloeri andreasrx matson samek eyenx luigy paperManu greeny_ somenick pawnda Dykam elgot seanparsons mno2_ kirjs______ segmond zph drbean_ yrashk__ benzrf wjt banjiewen honkfestival eikonos rs0 mach Cerise RGamma)
07:31:23 --- names: list (canta arun moy edwardk S11001001 dutchie Tesseraction hguux_ MMuse______ korpse si14 etrepum jlyndon catsup dabukalam jorj dfranke heurist MasseR ketcat mortberg monsieurp kakos vladan wjlroe rjsalts alpounet qzzx zerokarmaleft jcurbo aaronlevin magicflakes gds maaku SalamanderFood Athas lahwran thamz flux brixen aivuk pyrtsa hegge jasu0 Laquendi Zol_ geekosaur majoh averell heikkih mitu wormphle1m gandr KeelOfSteel ryan_t mrowe_away ljhms Talryn Liskni_si)
07:31:23 --- names: list (Zemyla wollw yorick dschoepe pygospa cic perrier_ teeteewhy Vq Fubar^ hvr imalsogreg xea SuperTux88 conehead boegel|work liste bruston otterdam Rembane Shandy lyddonb bydo Jactive|OFF joehh1 zymurgy Fuuzetsu tekacs wto ziman rieper_ fall_ cin lpaste luzie shelf japesinator alang Jello_Raptor connerb cchalmers davidthomas Noinia felixsch milli` suvash_away zariuq cosmicexplorer wtw comma8 nathanic noctux enomies dp_wiz_ shiona xandaros knyppeldynan smart_ptr)
07:31:23 --- names: list (adnap Transfusion mathu dav1d johnw Logiar inr_ Tordek bcoppens eagleflo int-e dmbaturin vukcrni `0660 DanToml_ frontend1oader kandinski KitC Rutger`_ jix_ lurker6_ xtsee diprosaurus saiam keko-2 owa ParahSailin notdan shepheb yaopo HugoDaniel belst MK_FG dougia_ DarkFox znutar defanor Dtgr_ Eliel_ Zorg Jonno_FTW M-ou-se jlouis JRoberts hsc Jaxan greymalkin bailon noidi mozmoney thomas idoru fergusnoble sipa McManiaC bens ToRA Belgarion0 hrnz `bps ninzine)
07:31:23 --- names: list (mmmpork mandu ormaaj s4msung adlan raid Riviera Floyd_ peddie Blkt LordDeath Erstarrung iulian metaf5 haasn JPohlmann gdsx itsmonktastic callumacrae _rgn tawm magicman kungp dlundy Lutin` jdiez heaumer mokus srbaker cods bergmark yukko stvc maurer efm Spockz mattp_ zenzike dehflingus_ blast_hardcheese sordina3 kwantam koala_man sorind amontez prinsen eyem Nanar tromp_ barrucadu fvt agrif HylianSavior wires` mendez Saizan Walther tov naudiz yam SwashBuckla)
07:31:23 --- names: list (KorriX mjrosenb Cathy dflemstr `micro_ kosmikus Starfire mietek BrianHV totte Ferdirand ephemeron dmilith ij SaBer liff supki SLi pfoetchen Guest6003 bernalex marienz okic_ julienXX jaspervdj Miciah Martty koninkje1away arianvp_ nexion orbital so ajcoppa vlopez keaml vermeille eL_Bart0 TheMoonMaster mami thebnq paz__ taruti tero-_ gargawel brackets Desoxy_ osfameron wting_ xaimus_ Pucilowski swook sellout eamelink kloplop321 Taneb bolmar fuziontech____)
07:31:23 --- names: list (joeytwiddle Gothmog_ larsen julmac seubert brisbin obiwahn zeroskillor jcp geal Twey Yawgmoth mgomes elfangor TakSuyu cryon adadad frawgie_ lpsmith pi8029 iota_ dunj3 froztbyte shapr go|dfish indigo shutdown_-h_now joe_k davesilva deni gidogeek spindas runde dustinswan bastian__ lassulus Gracenotes tomejaguar_away dawik luite drewr Tehnix hiredman joshc Ezku fold edwtjo futureperfect sgronblo therealklanni adarc scopedTV cross pharaun Laney poucet kragniz)
07:31:23 --- names: list (tstc yeltzooo GaveUp knyon mero tomaw Ke noplamodo gridaphobe mrd zebr tych0 kgadek honza aleator_ swen ivan`)
07:31:25 <clrnd> > (\x -> succ x) 4
07:31:26 <lambdabot>  5
07:32:56 <cbare__> Thanks clrnd!
07:33:04 <clrnd> you are welcome :D
07:38:31 <Myrl> how do you list the value constructors of a type?
07:39:09 <bitonic> Myrl: in GHCi, :info
07:39:25 <Myrl> bitonic: Ah, thanks.
07:39:49 <bitonic> there was a lambdabot way of doing that as well.  can't remember what it is though.
07:40:42 <clrnd> @info Monad
07:40:42 <lambdabot> Monad
07:40:44 <clrnd> ok
07:40:54 <Myrl> @info Maybe
07:40:54 <lambdabot> Maybe
07:40:55 <clrnd> @info Maybe
07:40:55 <lambdabot> Maybe
07:40:56 <clrnd> jaja
07:41:23 <Myrl> Is there also a way to make ghci print a short description of a function? And perhaps also search for a short description?
07:41:56 <saep> Myrl: hoogle can do that
07:42:12 <Myrl> saep: I'd need one for when I'm not in the internet.
07:42:26 <chrisdone> > dataTypeConstrs (dataTypeOf (undefined :: Maybe ()))
07:42:27 <lambdabot>  [Nothing,Just]
07:42:30 <texasmynsted> you can use hoogle locally
07:43:38 <saep> :def hoogle \s -> return $ ":! hoogle --count=15 \"" ++ s ++ "\""
07:43:39 <saep> :def doc \x -> return $ ":!hoogle --info \"" ++ x ++ "\""
07:44:00 <saep> Myrl: in your ~/.ghci
07:44:22 <texasmynsted> http://dev.stephendiehl.com/hask/#ghci  scroll down and it shows how to do this kind of thing in ghci
07:44:28 <chrisdone> Myrl: i'll be adding :search to ghci-ng eventually
07:44:51 <Claudius1aximus> > [Nothing,Just] -- chrisdone, i don't like the way it showed
07:44:52 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe a’
07:44:53 <lambdabot>              with actual type ‘a0 -> Data.Maybe.Maybe a0’
07:45:36 <solirc> nkar: btw, better use before_ instead of before in the code I gave you
07:46:45 <solirc> nkar: We may need a breaking change here to support arbitrary many arguments, before_ is more future proof
07:53:12 <albeit> :t ***
07:53:13 <lambdabot> parse error on input ‘***’
07:53:17 <albeit> :t (***)
07:53:18 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:54:44 <nkar> solirc: thanks for the followup.  I'm currently using just (when (cond::Bool) (spec::Spec)) since I need to run the whole spec or nothing.
07:55:43 <EvanR> :t (<*>)
07:55:44 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:55:46 <EvanR> :t (<**>)
07:55:47 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
07:57:11 <EvanR> :t (<&>)
07:57:12 <lambdabot> Functor f => f a -> (a -> b) -> f b
07:57:25 <johnw> EvanR: do you have a question?
07:57:37 <sgronblo> Is it possible through ghci or something to see the evaluation of an expression step by step?
07:58:09 <sgronblo> I'm checking out these final brainteasers of the edx course and think my precedence knowledge is not sufficient at the moment to get it
07:59:42 <johnw> sgronblo: there's been research to do things like that: http://wiki.science.ru.nl/tfpie/images/2/22/Tfpie2014_submission_4.pdf
08:00:03 <EvanR> where is <&> defined?
08:00:03 <indiagreen> sgronblo: there's stepeval
08:00:04 <johnw> oh, check out stepeval: http://chrisdone.com/posts/stepeval-hpaste
08:00:18 <indiagreen> EvanR: lens, I think
08:00:34 <EvanR> is there also a <& and &>
08:00:36 <geekosaur> hayoo agrees
08:01:01 <johnw> EvanR: you can "/query lambdabot" and then ask as much as you want
08:01:23 <chrisdone> stepeval is running at http://bm380.user.srcf.net/cgi-bin/stepeval.cgi
08:01:24 <EvanR> yeah its really crowded in here right now
08:02:36 * stepeval is cool!
08:02:42 <clrnd> this breaks hard: http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=foldl%27+%28-%29+7+[1%2C2%2C3%2C4%2C5]
08:03:53 <chrisdone> foldl' is not in its prelude
08:04:04 <johnw> nor is it in the Prelude
08:04:19 <clrnd> but it doesn't say it's undefined, weird,it does for [1..5]
08:04:29 <clrnd> anyways, very cool
08:04:51 <sivteck> foldl1 doesn't expand though
08:05:12 <chrisdone> look in the link called "Prelude" on the page you're looking at
08:05:34 <sivteck> ah
08:10:13 <izohask> I'm trying to understand Data.HashTable.IO (as H), more detailed how to use H.mapM_ or H.foldM
08:10:36 <izohask> e.g. I want to create a list from hashtable (without using "H.toList")
08:10:54 <sgronblo> Did anyone else here happen to finish FP101x?
08:11:10 <izohask> how can I achieve this by H.mapM_ ... How to get any result by using H.mapM_, when it returns "IO ()" ?
08:12:58 <geekosaur> izohask, if you want a result then you want mapM, not mapM_
08:13:43 <dmj`> izohask: why don't you want to use H.toList?
08:14:13 <izohask> I was trying to understant how to do something else...
08:14:23 <geekosaur> oh, hm, there isn't one. that seems odd.
08:14:57 <izohask> e.g. I have (BasicHashTable Sring Int) and I want a list of strings formed like (key++" "++ (show value))
08:15:08 <izohask> I thought this could be done by H.mapM_
08:15:36 <izohask> OK , I believe I can achieve this by using Control.Monad.mapM... but what is then H.mapM_ used for ?
08:16:11 <chrisdone> izohask: what is the type of H.mapM_? =)
08:16:18 <izohask> IO ()
08:16:24 <chrisdone> (°¬°)
08:16:32 <chrisdone> izohask: what is the *full* type of H.mapM_?
08:16:34 <johnw> it takes a function that receives the key and value
08:16:45 <chrisdone> johnw: ruinin' ma socratics
08:16:46 <izohask> chrisdone:   :: Data.HashTable.Class.HashTable h =>
08:16:47 <izohask>      ((k, v) -> IO a) -> IOHashTable h k v -> IO ()
08:18:02 <johnw> fmap (map (\(k, v) -> k ++ " " ++ show v)) (H.toList table) :: IO [String]
08:19:06 <sgronblo> yeah this stepeval is cool, but who could figure this out in their head http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+foldlx+f+a+bs+%3D+foldr+%28%5Cb+-%3E+%5Cg+-%3E+%28%5Ca+-%3E+g+%28f+a+b%29%29%29+id+bs+a+in+foldlx+%28-%29+0+%5B1%2C2%2C3%5D
08:19:16 <chrisdone> izohask: see johnw's answer for why H.mapM_ exists, its type differs to mapM_ in structure
08:20:20 <johnw> sgronblo: folding with a function as your fold variable is always a bit tricky to think through
08:20:59 <izohask> chrisdone: I'm trying to figure out "why H.mapM_ exists", "what can I do with this" ... ?
08:21:16 <johnw> izohask: you could print the member of the list more efficiently
08:21:34 <johnw> H.mapM_ (\k v -> putStrLn $ k ++ " " ++ show v) table :: IO ()
08:22:04 <johnw> or accumulate whatever effects are relevant
08:22:31 <sgronblo> johnw: yeah this is part of the final homework for Erik Meijers recent FP course. I feel like he might be trolling with this stuff.
08:23:21 <izohask> johnw: I understand, I can print the member list more efficiently... Is there anything else beside printing ?
08:23:34 <johnw> izohask: anything that you can do with IO
08:23:47 <johnw> mapM_ is a *very* useful function in general; H.mapM_ is specialized to hashtables
08:23:49 <izohask> johnw: aha.. write to file etc
08:24:59 <xplat> also things you can do in other monads, e.g. sum of all values with an allcaps key or something
08:25:25 <chrisdone> izohask: regular Control.Monad.mapM can't give you the key as well as the value, it can only give you the value
08:25:38 <slomo> sgronblo: yes (FP101x)
08:26:32 <chrisdone> izohask: (so you have to convert it to a list if you want to use regular mapM)
08:26:56 * hackagebot persistent 2.1.1.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.1.1 (MichaelSnoyman)
08:26:59 * hackagebot persistent-template 2.1.0.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.1.0.1 (MichaelSnoyman)
08:29:29 <Benzi-Junior> why oh why does show on a string not work with non ascii characters ?
08:30:46 <Benzi-Junior> show "Ö"
08:30:50 <clrnd> > show "ó"
08:30:51 <lambdabot>  "\"\\243\""
08:30:59 <clrnd> that looks okay
08:31:00 <vanila> > "\"\\243\"" == "ó"
08:31:01 <lambdabot>  False
08:31:05 <clrnd> lol
08:31:25 <Benzi-Junior> this is rather bothersome
08:31:32 <vanila> > read "\"\\243\"" == "ó"
08:31:33 <lambdabot>  True
08:31:35 <EvanR> show x /= x in general
08:31:48 <EvanR> read (show x) should be x though
08:32:31 <izohask> H.mapM_ (\(k,v) -> putStrLn $ k ++"=" ++ (show v)) m
08:32:36 <johnw> Benzi-Junior: can you exapnd on "not work"?
08:32:41 <EvanR> > read . read . show . show $ "foo"
08:32:43 <lambdabot>  *Exception: Prelude.read: no parse
08:32:59 <izohask> OK this works (print out hashtable)... But how can I get sum of elements , by using H.mapM_ ?
08:33:12 <johnw> izohask: you'd have to store the result in an IORef
08:33:13 <izohask> e.g. sum of all values (ignoring keys)
08:33:18 <Benzi-Junior> johnw: it doesnt show the character but instead this weird escape sequence
08:33:28 <izohask> IORef... Have to read something about this , thnx
08:33:29 <johnw> Benzi-Junior: where are you seeing the escape sequence?
08:33:40 <Benzi-Junior> > show "Ö"
08:33:41 <lambdabot>  "\"\\214\""
08:33:46 <johnw> so, in your IRC client?
08:34:05 <Benzi-Junior> johnw: no also ghci and as the output of compiled code
08:34:12 <johnw> "show" is designed to show something that "read" can turn back into the original data
08:34:19 <johnw> it's not for "what is prettiest"
08:34:42 <johnw> since showing the original character as you expect would presume an encoding, it's not the best choice for show
08:34:57 <Benzi-Junior> yes but read can read the non ascii characters
08:35:06 <johnw> sure it can, because it's just numbers
08:35:45 <xplat> > text "Ö"
08:35:47 <lambdabot>  Ö
08:36:12 <sgronblo> why was show and read not supposed to be used for serialization again?
08:36:28 <geekosaur> because it's an inefficient way to do serialization
08:36:52 <geekosaur> show and read kinda serve too many masters; they're trying to support serialization and support debug display
08:36:54 <chrisdone> that and it's not reliably bijective
08:36:59 <geekosaur> among other things
08:38:10 <xplat> chrisdone: but the only reason other things are more reliable in round-tripping is that few people only thing about one direction and make it to be pretty :)
08:38:13 <geekosaur> (the debugging bit is why show goes for the escaped version, which is "readable" even if you don't have a working utf8 environment)
08:38:18 <xplat> *think about
08:39:55 <izohask> johnw: Got it, thank you!!
08:40:46 <izohask> seems that using IORef will help me a lot now, with all the bunch of IO stuff :)
08:41:14 <johnw> note that IORef is rarely the right answer
08:41:43 <izohask> it seems so
08:41:45 <xplat> execState is the right answer?
08:41:47 <johnw> foldM is another way to produce a sum
08:42:05 <izohask> IORef seems like variable... it can ruin "functional" nature ?
08:42:21 <izohask> I mean, I can change it somewhere and use somewhere else etc..
08:42:24 <johnw> yep
08:42:37 <chrisdone> in IO, anyway
08:43:35 <EvanR> linked list implementation: Data X a = Nil | (IORef (X a)) ;)
08:43:46 <EvanR> IORefs in your IORefs
08:43:46 <steffen> I am struggeling hard trying to implement groupWith on Data.Vector Vector without using head! Can someone help me a little?
08:44:05 <chrisdone> EvanR: i heard you like trouble
08:44:34 <EvanR> or doing C in any language
08:44:56 <xplat> > execState (mapM_ $ \!v -> modify (\!s -> v+s)) [1..1000]
08:44:57 <lambdabot>  <hint>:1:20: parse error on input ‘\!’
08:45:11 <xplat> > execState (mapM_ $ \v -> modify (\s -> v+s)) [1..1000]
08:45:12 <lambdabot>  Couldn't match type ‘[s0] -> m0 ()’
08:45:13 <lambdabot>                with ‘Control.Monad.Trans.State.Lazy.StateT
08:45:13 <lambdabot>                        [t] Data.Functor.Identity.Identity a0’
08:45:15 <izohask> johnw: foldM is OK, it returns IO a , so can be used, thank you
08:46:08 <xplat> > execState ((mapM_ $ \v -> modify (\s -> v+s)) 0) [1..1000]
08:46:10 <lambdabot>  No instance for (GHC.Show.Show t0)
08:46:10 <lambdabot>    arising from a use of ‘M578579942776174921420225.show_M5785799427761749214...
08:46:10 <lambdabot>  The type variable ‘t0’ is ambiguous
08:46:32 <johnw> xplat: his mapM_ is in IO
08:46:46 <xplat> > execState ((mapM_ $ \v -> modify (\s -> v+s)) 0) [1..1000] :: Int
08:46:47 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
08:46:47 <lambdabot>              with actual type ‘[t0]’
08:47:17 <xplat> johnw: i fail so much anyway, but huh why?
08:47:27 <johnw> it's Data.HashTable.IO.mapM_
08:47:48 <xplat> oh, that hashtable :(
08:48:05 <johnw> yeah, it should just use Foldable :)
08:53:31 <xplat> installing newest git-annex is super problematic
08:53:39 <johnw> what happens?
08:53:53 <johnw> I'm using 20141203
08:55:28 <xplat> johnw: i need to install a bunch of stuff like MissingH just to cabal configure
08:55:40 <johnw> yes, it builds a custom Setup
08:55:43 <xplat> MissingH builds but oh god the warnings
08:55:55 <johnw> use Nix to install it ;)
08:56:20 <xplat> how do i know what packages i need to build Setup so i know what packages i need to actually build?  :-7
08:56:39 <johnw> --only-dependencies doesn't do the right thing?
08:57:23 <xplat> i need to configure first?
08:57:30 <johnw> shouldn't need to
08:57:55 <johnw> configuration always requires the dependencies to be installed
08:58:06 <johnw> (I think)
08:58:33 <xplat> but deps can depend on configuration flags
08:58:41 <johnw> ok, I may be wrong on that point
08:58:48 <johnw> i don't really use cabal anymore
09:00:58 <geekosaur> deps can depend on *cabal* configuration flags, which are part of the dependency solver. "cabal configure" is *package* configuration, which happens later and requires the dependencies already be installed
09:01:41 <johnw> thanks, geekosaur
09:01:56 <xplat> ah.  i've never really used flags in my own stuff
09:02:26 <pyon> In what module is fix defined?
09:02:51 <geekosaur> @index fix
09:02:51 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
09:03:07 <geekosaur> also Data.Function according to hayoo
09:03:14 <pyon> thanks!
09:04:21 <albeit> @pl \k v -> f v
09:04:21 <lambdabot> const f
09:29:09 <zol__> When writing loops, how will memory from the previous call be handled? Will it be kept in memory or will the GC release it if it's not used anymore? I'm wonder what will happen to the first simple server in http://chimera.labs.oreilly.com/books/1230000000929/ch12.html#sec_server-trivial, if you let it run for a while. Will it crash due to not enough memory?
09:29:22 <zol__> I'm wondering*
09:30:23 <dfeuer> ski?
09:30:39 <dfeuer> Cale?
09:30:54 <chris2> hi. i'm trying to bootstrap cabal-install 1.20.0.4, but i get this error: http://sprunge.us/UIGQ
09:31:40 <clrnd> zol__, the GC will destroy it
09:31:53 <clrnd> zol__, haskell being pure makes this very easy
09:32:17 <geekosaur> chris2, that has been reported
09:32:23 <zol__> clrnd: So only if I were concatenating data and reusing it in the next call would I need to worry about space?
09:32:36 <geekosaur> bootstrap script needs to be updated; I presume there will be a .5 sometime today
09:32:41 <chris2> ah great
09:32:47 <chris2> i guess i can wait a few days
09:32:56 <ReinH> mmachenry1: yay!
09:32:57 <clrnd> zol__, you'd have to worry about space in any language in that case
09:33:45 <zol__> clrnd: Yeah, but the call stack would grow larger in other languages in recursive calls, you're saying it won't in Haskell without any concatenation of data etc. ?
09:33:59 <lordmord> Hello, i got a problem whenever i try to compile something i get following error: "as: unrecognized option '--64' "
09:34:06 <clrnd> zol__, haskell implements tail recursion optimization
09:34:23 <zol__> clrnd: ooh, ok, great - thanks!
09:34:24 <lordmord> Has anybody seen this before google isn't of much help
09:34:45 <clrnd> that is, if the recursive call is in tail position, then it's memory (and I think cost too) free
09:34:57 <ReinH> clrnd: :(
09:35:02 <micrypt> lordmord: What's the full set of flags you're using?
09:35:19 <clrnd> ReinH, ?
09:35:29 <lordmord> micrypt just using "ghc something.hs"
09:35:32 <ReinH> When GHC reduces expressions in left-most outermost position, the STG uses a jump. These expressions don't have to be in "tail position", nor do they have to be "recursive".
09:35:38 <ReinH> This happens for every reduction
09:35:59 <ReinH> *STG machine
09:36:22 <ReinH> @src foldl
09:36:22 <lambdabot> foldl f z []     = z
09:36:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:36:24 <clrnd>  oh that's wayy cooler
09:36:44 <clrnd> @src foldl'
09:36:45 <lambdabot> foldl' f a []     = a
09:36:45 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:36:58 <ReinH> foldl is in left-most outermost position and will be reduced via a jump. Applications of f, however, will still result in the creation of thunks.
09:37:26 <clrnd> left-outermost position is almost like a cool way of saying tail position, though, right?
09:37:46 <ReinH> clrnd: "tail position" is somewhat confusing. What happens to the scrutinee of a case statement? Etc.
09:38:07 <ReinH> reduction of expressions in left-most outermost position is called "normal order evaluation" and is part of GHC's lazy evaluation strategy.
09:38:22 <clrnd> I see
09:38:37 <clrnd> thanks for clarifying that
09:38:38 <ReinH> Lots of people seem to like to say "tail position" and "tail calls" though
09:38:48 <clrnd> zol__, ^ that's a more correct answer then
09:39:25 <micrypt> lordmord: Is `something.hs` publicly available?
09:39:32 <ReinH> I think "tail position" is usually accurate, but recursion definitely isn't necessary
09:39:42 <clrnd> I guess because lazy languages aren't that popular, but TCO is
09:39:52 <ReinH> clrnd: Might be.
09:40:48 <lordmord> micrypt it happens with any file, noticed it the first time while trying to recompile xmonad
09:41:06 <clrnd> lordmord, care to paste the entire error?
09:41:43 <zol__> Hm.. I need to read up on what the definition of tail position, tail call, thunk, left-most outermost position, STG machine are. But thanks for painting a large picture. :D
09:42:12 <ReinH> zol__: It sounds like you were more interested in GC behavior
09:43:28 <ReinH> zol__: Here's a very nice rundown of GHC's garbage collection https://ghc.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
09:43:30 <lordmord> http://lpaste.net/116615 thats the error plus the contents of a simple test file
09:43:45 <ReinH> The TL;DR: is that GHC has an extremely efficient GC, which is necessary because immutable lazy languages produce a lot of garbage.
09:44:32 <zol__> ReinH: Yeah, that I was aware of, just not how to reason about it on my own when reading/writing long-term running applications.
09:44:59 <lordmord> Also if i use ghci to test Code it works fine not sure if that matters.
09:45:13 <geekosaur> lordmord; do you have /usr/lib/ghc/settings? if so, can you lpaste it?
09:45:16 <geekosaur> @paste
09:45:16 <lambdabot> Haskell pastebin: http://lpaste.net/
09:45:23 <clrnd> lordmord, very very weird, really sounds like an instalation error of some kind
09:45:46 <geekosaur> (if your ghc is /usr/local/bin/ghc then it'd probably be /usr/lib/ghc/settings, etc.)
09:47:05 <ReinH> zol__: Stack and heap memory usage are usually more of a problem
09:47:10 <lordmord> geekosaur here is the settings file http://lpaste.net/116618
09:47:18 <lordmord> and i already tried reinstalling
09:48:06 <zol__> ReinH: That was mainly what I was referring to, I think. I need to read up on how to profile my applications since I've never had the need for it before. Thanks for the input!
09:48:16 <mmmm> Are there any nice ways to ensure that all threads finish before the program exits?
09:48:29 <geekosaur> hrm. I think you'll need to ask the arch ghc maintainer about it
09:48:59 <clrnd> mmmm, there are severall concurrency mechanism, what are you using?
09:49:22 <ReinH> @where lazy
09:49:22 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
09:49:25 <ReinH> zol__: This is a very good read
09:49:47 <mmmm> stuff from Control.Concurrent.(MVar)
09:49:48 <ReinH> zol__: Here's the GHC user manual section on profiling: https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/profiling.html
09:50:02 <zol__> ReinH: Thanks!
09:50:09 <lordmord> clrnd not sure what you mean but i never touched that file.
09:50:10 <clrnd> mmmm, well, MVar has a blocking take method, that can be used to "wait"
09:50:33 <mmmm> There is a description there about how to do it but I was wondering if there were any nicer ways
09:50:55 <clrnd> lordmord, oh sorry, I was talking to mmmm, who has a confusing nickname (no ofense intended)
09:51:28 <lordmord> np guess ill ask again over on #archlinux-haskell
09:51:42 <clrnd> lordmord, I think what geekosaur said is correct
09:54:50 <clrnd> mmmm, something like https://hackage.haskell.org/package/async-2.0.1.6/docs/Control-Concurrent-Async.html ?
09:57:18 <mmmm> clrnd: Maybe, I think for my useage I can just use the methods suggested at the bottom of Control.Concurrent
09:57:49 <clrnd> okay :P
10:00:17 <chrisdone> what's the cabal syntax to apply --ghc-options only to a specific package?
10:00:58 <crobbins> chrisdone: hmmm...can you do that?
10:01:15 <crobbins> chrisdone: i know about --allow-newer, it can be used for a specific package
10:01:26 <crobbins> but didn't know about specific --ghc-options
10:01:35 <dcoutts_> chrisdone: there isn't such a feature I'm afraid
10:01:53 <crobbins> maybe you could do it during: cabal install <package> --ghc-option=foo
10:02:51 <chrisdone> dcoutts_: oh, ok, thanks =)
10:05:39 <dcoutts_> chrisdone: ooi, what's the use case?
10:08:57 <zacharypch> is tagsoup still a good choice for parsing html?  I just want something that can follow a few simple rules to get content from divs and suck
10:08:59 <zacharypch> such*
10:10:32 <chrisdone> dcoutts_: i was curious to see how cabal handled the arguments, as someone told me it did this
10:11:23 <dfeuer> chrisdone, I wasn't trying to bikeshed all over your parade; I just thought that the fact that if all the introductory Haskell material I could find used the word "bind" to refer to >>=, you probably shouldn't give that name to =<<.
10:12:29 <dfeuer> I can understand that that may have been a mistake way back, but we don't want to confuse too many people at once, I don't think.
10:13:03 <dcoutts_> chrisdone: the --$PROG-options flags are actually just generic program arguments for all invocations of $PROG
10:13:21 <dcoutts_> chrisdone: rather than something that's routed by any more complicated config
10:14:35 <dcoutts_> chrisdone: ie it's equivalent to using --with-$PROG=${a-shell-wrapper-that-uses-extra-args}
10:14:40 <Ouyang> are there any haskell projects that need donations?
10:15:14 <Ouyang> i.e. people improving on a package manager for haskell
10:17:16 <dfeuer> Yes, Ouyang, there surely are. haskell.org could surely use some, for instance.
10:17:24 <mmachenry1> Ouyang: Haskell.org accepts them
10:18:01 <dfeuer> I would venture to guess that haskell.org has at least some capacity to guide donations towards projects of general importance to the community.
10:18:22 <clrnd> haskell.org asked for donations in the mailing list last week, iirc
10:18:25 <dfeuer> But if you want something more specific, you might have to take that up with individual project maintainers.
10:18:25 <Ouyang> im just a little annoyed at cabal at the moment and want to help out
10:19:06 <dbp> I just installed ghcformacosx and for some reason cabal exec is giving 'inapropriate type' whenever it is passed an executable without an absolute path (so, for example, there are packages that try to cabal exec -- sh ... - they don't work).
10:19:14 <dbp> Is this a known problem? Or any tips on figuring out a solution?
10:20:19 <Ouyang> I will look into haskell.org thank you guys
10:21:03 <dcoutts_> Ouyang: or your time is of course valuable
10:21:13 <dcoutts_> Ouyang: but yes, donations to haskell.org can help
10:21:27 <Ouyang> My time is of negative value hahaha, im a beginner
10:22:04 <Ankhers> Is the platform something that should be used, or is it more of a "getting started" step?
10:22:58 <mmachenry> Ankhers: Haskell Platform?
10:23:50 <Ankhers> mmachenry: yes.
10:26:09 <mmachenry> Yeah that's the recommended installation for all users.
10:26:34 <mmachenry> I use Haskell Platform to build my production libraries.
10:27:05 <markus3> hi, haskell channel!
10:27:42 <clrnd> hi
10:28:06 <markus3> a question: is it possible to get the command line arguments passed to the program as a single text or bytestring?
10:28:19 <shapr> jfischoff: I've done TDD with Haskell!
10:28:41 <jfischoff> how was it?
10:29:15 <shapr> jfischoff: I started by hacking QuickCheck into saving the (seed,size) pair whenever a property failed, and trying that one again
10:29:31 <shapr> jfischoff: that got integrated into QC2, so there's explicit support for that
10:29:31 <clrnd> markus3, yeah, getLine returns [String]
10:29:40 <shapr> and now one of the testing frameworks supports doing that for you
10:29:50 <clrnd> then just Data.Text.pack . concat
10:29:56 <shapr> jfischoff: but standard unit testing TDD works also, I just prefer QC-TDD
10:30:27 <shapr> jfischoff: I don't remember which framework explicitly supports saving the failing QC inputs, but one of them does
10:30:44 <markus3> clrnd, it gets the line from stdin doesn't it?
10:30:48 <Iceland_jack> clrnd: Something like "unwords" surely
10:30:51 <jfischoff> right
10:30:58 <markus3> not the command line args
10:31:13 <clrnd> yeah, I also didn't mean getLine
10:31:20 <markus3> ah
10:31:22 <mmachenry> markus3: main = do { s <- liftM concat getArgs; print s }
10:31:25 <mmachenry> I think
10:31:38 <shapr> jfischoff: have you tried it ye?
10:31:40 <clrnd> but getArgs
10:31:41 <clrnd> that
10:31:58 * hackagebot irc 0.6.1.0 - A small library for parsing IRC messages.  http://hackage.haskell.org/package/irc-0.6.1.0 (TrevorElliott)
10:32:07 <markus3> what I'd like is the arg string as raw
10:32:11 <Iceland_jack> markus3: Are you talking about when you write:
10:32:11 <Iceland_jack>     $ ./foo a b c
10:32:11 <Iceland_jack> to get 'a b c'?
10:32:39 <clrnd> he wants text/bytestring so surely 'pack' goes around there
10:32:46 <Iceland_jack> markus3: That's not how it works
10:32:49 <jfischoff> shapr: nope. I’m trying something like it know
10:32:55 <markus3> the problem i'm having is that the more advanced cmdargs package doesn't respect quotes
10:33:00 <shapr> jfischoff: tweet or write about your thoughts?
10:33:02 <markus3> ah, ok
10:33:13 <markus3> its about how bash passes the args in then, right_
10:33:15 <Iceland_jack> markus3: The shell parses the arguments
10:33:17 <jfischoff> I did some exploratory work without formal tests, (little tests here and there)
10:33:18 <clrnd> right
10:33:26 <jfischoff> now I am going back and starting with testss
10:33:35 <clrnd> it's some OS level stuff magic
10:33:37 <Iceland_jack> and then passes them to some exec*-like functions as an array/list of strings
10:33:37 <jfischoff> I like it so far
10:33:43 <markus3> ok
10:33:48 <jfischoff> I think TDD helps dirve a good API
10:34:09 <Iceland_jack> Your best approximation is:
10:34:09 <Iceland_jack>     do args <- getArgs
10:34:09 <Iceland_jack>        ... unwords args ...
10:34:16 <markus3> anyway, the issue I was having was that the cmdargs package returned "'abc" "def'"
10:34:25 <shapr> jfischoff: I think so to
10:34:25 <markus3> i.e not respecting the single quotes
10:34:27 <shapr> too*
10:34:38 <markus3> but I think I need to go and test it broadly
10:35:11 <markus3> but I think it was like that, therefore I was thinking the raw approach
10:35:35 <markus3> anyway, I'll have another test go
10:36:44 <clrnd> markus3, getArgs reads 'quoted text' correctly, so no idea
10:37:59 <mmachenry> markus3: Put your code up on lpaste and we'll take a look
10:38:41 <xplat> never use cmdargs, use optparse-applicative instead
10:40:15 <markus3> xplat, dare I ask why?
10:40:51 <mmachenry> markus3: You will be able to use optparse to turn the cmd line args into a well-typed data structure easily.
10:41:10 <clrnd> what would be an advantage of cmdargs? I mean, why does it exist
10:41:15 <xplat> markus3: optparse-applicative is white magic, cmdargs is black magic
10:41:19 <mmachenry> Reading in as a string and checking if things equal whatever and that stuff is just reinventing the wheel.
10:41:23 <clrnd> optparse is certainly beautiful to use
10:41:41 <xplat> the advantage of cmdargs is that optparse-applicative didn't exist yet when cmdargs was written
10:41:47 <clrnd> oh lol
10:41:58 * hackagebot snowglobe 3 - randomized fractal snowflakes demo  http://hackage.haskell.org/package/snowglobe-3 (ClaudeHeilandAllen)
10:42:02 <markus3> we are talking about the cmdargs package, right?
10:42:30 <markus3> the magic derives from the typeable/data stuff, right?
10:42:37 <markus3> the dark magic
10:42:40 <jaseemab`> I'm working through the standard lisp tutorial and I've a constructor like `data LispVal =  List [LispVal]`. How can I pattern match for n arguments inside List? Now I have to match for List[n], List[n,m] etc. For some reason List[m:n] not working. Full code here https://github.com/jaseemabid/lisper/blob/master/Main.hs#L7
10:43:04 <Iceland_jack> jaseemab`: [m:n] means that it's a nested list
10:43:12 <clrnd> jaseemab`, List (x:xs)
10:44:06 <jaseemab`> Dont know why its not working. Looks like arguments inside List is not really a list. The pattern match is quite nested and creepy. https://github.com/jaseemabid/lisper/blob/master/Main.hs#L160
10:44:49 <jaseemab`> clrnd: Ah. That looks like what I want. Can you please have a look at https://github.com/jaseemabid/lisper/blob/master/Main.hs#L160 if you don't mind?
10:45:17 <clrnd> jaseemab`, is the problem in that line?
10:45:23 <mmachenry> markus3: https://hackage.haskell.org/package/optparse-applicative
10:45:52 <lordmord> geekosaur,clrnd: in case you are interested it wasn't a problem with ghc but with gcc after reinstalling that everying seems to be working fine
10:46:14 <mmachenry> It's the most well-liked. I use it myself for a reasonably large project at work. Admittedly it doesn't do much cmd line parsing, but that's never the biggest part of a program anyway :)
10:46:25 <clrnd> lordmord, oh that sounds weird :p glad you could work it out
10:46:59 <geekosaur> I kinda suspected as much
10:47:06 <lordmord> clrnd, yea some weird dependency/package got into my system.
10:47:11 <geekosaur> but don't know enough about the arch environment
10:47:25 <lordmord> And i just tried to build something completely unrelated and then gcc also had that error
10:47:44 <markus3> thanks mmachenr
10:50:16 <jaseemab`> clrnd: Yes. Let me test here for a second.
10:54:36 <jaseemab`> clrnd: Changing List[a,b] to List(a:b) worked. Thanks.
10:55:03 <Iceland_jack> jaseemab`: Also, depending on your GHC version you can create pattern synonyms for many things
10:55:12 <Iceland_jack> Like:
10:55:12 <Iceland_jack>     pattern If cond a b = List [Atom "if", cond, a, b]
10:55:41 <Iceland_jack> Which let's you write:
10:55:41 <Iceland_jack>     eval env (If cond a b) = ...
10:55:41 <Iceland_jack> rather than:
10:55:41 <Iceland_jack>     eval env (List [Atom "if", cond, a, b]) = ...
10:56:48 <tempay> potentially stupid question. why might my ghc not find Network or Network.Socket?
10:56:57 <Iceland_jack> Same for simpler patterns like 'pattern Nil = List []' which also allows you to change the representation later on
10:57:03 <jaseemab`> Iceland_jack: That would be cool. How do I do that?
10:57:19 <Iceland_jack> jaseemab`: You enable the PatternSynonyms extension:
10:57:19 <Iceland_jack>     {-# LANGUAGE PatternSynonyms #-}
10:57:32 <jaseemab`> Iceland_jack: I'll check that up.
10:57:40 <xplat> tempay: don't have the package in deps?
10:57:56 <Iceland_jack> jaseemab`: ocharles wrote a Christmas-y introduction to it :)
10:57:58 <Iceland_jack> @google ocharls pattern synonyms
10:57:59 <lambdabot> https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html
10:58:10 <geekosaur> tempay: the network package is not installed or is broken (or possibly incompatible with some other dependency). or at the cabal level, not listed in dependencies, possibly because network was changed to network-uri blindly
10:58:16 <Iceland_jack> And you can also look at:
10:58:17 <Iceland_jack> @google Iceland_jack pattern synonyms fpcomplete
10:58:18 <lambdabot> https://www.fpcomplete.com/user/icelandj/Pattern%20synonyms
10:58:22 <joelteon> ooh, do we get GHC extensions for christmas??
10:58:34 <joelteon> my favorite!
10:58:37 <Iceland_jack> :)
10:58:43 <timmy_tofu> I"m getting cannot satisfy package-id errors, I've destroyed and rebuilt the sandbox multiple times, the project compiles (and tests) file, but when running I get this error. This is becoming very incessant - anyone know how to deal with this? Sandboxes used to solve this for me unlike the bad old days
10:59:01 <tempay> uh oh, I haven't even looked at dependencies. I just updated ghc and the import worked before the update
10:59:04 <geekosaur> network is normally outside the sandbox
10:59:18 <xplat> on the first day of christmas, my true love gave to me: an extension to GHC
10:59:19 <tempay> geekosaur: is it just called network-uri now?
10:59:44 <jaseemab`> Iceland_jack: Thanks. This is enough info to keep me occupied for the rest of the night :)
10:59:50 <geekosaur> tempay: no, that's the possible problem. network-uri used to be part of network but didn't really need the rest of network, so it was split out
10:59:59 <Iceland_jack> Then my work is done
11:01:00 <tempay> geekosaur: I don't think I'm trying to import that, does it affect me?
11:01:07 <jaseemab`> Iceland_jack: Looks like defining nil to List [] would be a good idea then
11:01:41 <geekosaur> tempay, I am just guessing, I have no idea whatsoever what you are working with, what its dependencies are, or what they might need to be changed to
11:01:44 <jaseemab`> I patterned match with a variable and it just failed. This is cool
11:02:43 <Iceland_jack> jaseemab`: Other candidates include:
11:02:43 <Iceland_jack>     pattern Let a b = List [Atom "let", a b]
11:02:48 <tempay> geekosaur: okay. so I might need to explicitly add network to ghc's cabal dependencies?
11:02:51 <Iceland_jack> jaseemab`: Do you kow where the word "candidate" comes from?
11:03:08 <Iceland_jack> Its etymology is interesting
11:03:44 <jaseemab`> Iceland_jack: Nope
11:04:03 <Iceland_jack> jaseemab`: People running for public office in Rome would wear white togas
11:04:17 <geekosaur> ... "ghc's cabal dependencies"? what
11:04:24 <Iceland_jack> and 'candidus' is Latin for white
11:04:57 <tempay> geekosaur: Oh I'm dumb. I didn't realize it was a separate package I needed to install, I thought it came with ghc. Ignore the noob, thanks for your help
11:05:36 <geekosaur> network doesn't come with ghc, no. but most people install the platform unless they like things like this to happen
11:05:52 <jaseemab`> Iceland_jack: Thanks for the wisdom :) Just tried a if pattern and that looks neat
11:05:59 <xuinkrbin> Does Happy work with YACC files? Or is "massaging" of the file contents required first?
11:06:18 <geekosaur> 90% of yacc files contain C code...
11:07:27 <Iceland_jack> jaseemab`: The interesting use is allowing you to change the underlying representation
11:07:46 <Denommus> hi
11:07:53 <Iceland_jack> So you can continue using 'Nil' or 'If a b c' even if you completely change your AST
11:07:59 <clrnd> Iceland_jack, that's a nice origin for a word
11:08:29 <jaseemab`> Iceland_jack: Yep!
11:08:33 <clrnd> greeks think they cool or smthgn they inventing them words damn
11:08:43 <jaseemab`> Makes my pattern matching a lot more readable
11:08:44 <Iceland_jack> clrnd: Thanks, if it were up to me this channel would be 50:50 etymology:Haskell :)
11:09:02 <Iceland_jack> clrnd: 'sophomore' and 'oxymoron' are two interesting ones
11:09:18 <clrnd> Iceland_jack, jaja, I remember reading my fathers atymology dict while a a youngster and thinking it was way cooler than actually learning history :D
11:09:23 <clrnd> etymology*
11:09:26 <Iceland_jack> That being said, 'candidate' should really mean a date where you both have candy
11:09:28 <oleo> etymologically nuts!
11:09:29 <oleo> lol
11:10:46 <Iceland_jack> Well etymology /is/ history :)
11:11:19 <Ankhers> Could anyone tell me why this isn't installing? http://lpaste.net/116632
11:13:12 <johnw>  did you do a cabal update?
11:13:32 <geekosaur> <command line>: cannot satisfy -package-id parsec-3.1.5-04a4603ceb125469438c848f900bfe50
11:13:46 <geekosaur> something is wrong with your installed parsec package
11:14:31 <geekosaur> cabal knows it's there because it specified a package hash for an exact installed version; but ghc doesn't like it, so either cabal and ghc are looking at different package databases or the package is somehow broken
11:14:40 <geekosaur> `ghc-pkg check` might be enlightening
11:16:02 <Ankhers> geekosaur: I think I'm good now. I needed to `ghc-pkg recache`. Thanks.
11:17:25 <dfeuer> I just had an idea that is either really smart or really stupid. Next question is how long it might take me to figure out which.
11:21:44 <Benzi-Junior> hey I have a list of lines stored as a tuple of points that themselves are tuples so it's type is [((a,a),(a,a))] what would be the best way to get a list of just all the x values (the first coordinate in each tuple within the tuples)
11:22:24 <Denommus> I just gave scotty a try
11:22:28 <Denommus> I also didn't like it
11:22:43 <Denommus> it doesn't enforce correct URL parameters at compile-time
11:22:59 <Denommus> is there a library that does that?
11:23:00 <Benzi-Junior> the order of the list is irrelivant
11:23:03 <Denommus> is it even possible?
11:23:47 <Iceland_jack> Benzi-Junior: So for [((4, 0), (5, 2)), ((40, 0), (50, 2))] you would want something like [4,5,40,50]?
11:24:00 <Iceland_jack> Or would you want [(4,5),(40,50)]
11:24:02 <Benzi-Junior> Iceland_jack: yup
11:24:11 <Benzi-Junior> Iceland_jack: the first one
11:24:40 <Iceland_jack> There are several way, the simplest to understand would be:
11:24:40 <Iceland_jack> > concat [ [x1, x2] | ((x1, _), (x2, _)) <- [((4, 0), (5, 2)), ((40, 0), (50, 2))] ]
11:24:42 <lambdabot>  [4,5,40,50]
11:24:48 <geekosaur> um, isn't scotty a web server? you want to enforce runtime provided data at compile time?
11:25:40 <Benzi-Junior> Iceland_jack: ye the one I thought of was simlar except I extracted the x1 and x2 seperately and then concatenated the results
11:26:09 <Iceland_jack> *several ways
11:27:14 <jle`> if you can think of (f *** g) as "mapping f and go over both side sof the tuple, you can do map (fst *** fst)
11:27:18 <ClaudiusMaximus> Denommus: yesod has a two-way mapping between urls and types (or so i understand it), meaning you don't generate bad urls for other parts of your app  http://www.yesodweb.com/book/routing-and-handlers
11:27:33 <jle`> > ((+3) *** show)) (5,7)
11:27:34 <lambdabot>  <hint>:1:16: parse error on input ‘)’
11:27:41 <jle`> > ((+3) *** show) (5,7)
11:27:42 <lambdabot>  (8,"7")
11:27:55 <Benzi-Junior> Iceland_jack: BTW that Capabilities package you were working on is that still a work in progress or is it dead ?
11:28:19 <jle`> > map (fst *** fst) [((4,0),(5,2)),((40,0),(50,2))]
11:28:20 <lambdabot>  [(4,5),(40,50)]
11:29:18 <Iceland_jack> Benzi-Junior: It's as good as dead for now, I will probably be too busy to work on it for a while
11:29:27 <Black-Heaven> Hello, is there a way to declare a Kind-level fix point? Thanks.
11:29:36 <Denommus> ClaudiusMaximus: yes, but I'm more interested in having enforcements of the URL variables/parameters
11:29:49 <benzrf> > both first^..[((4,0),(5,2)),((40,0),(50,2))]
11:29:51 <lambdabot>  Couldn't match type ‘[((t0, t1), (t2, t3))]’
11:29:51 <lambdabot>                with ‘(a -> Control.Applicative.Const (Data.Monoid.Endo [a]) a)
11:29:51 <lambdabot>                      -> (r0 (a0 b0 c0) (a0 b0 c0) -> a0 (b0, d0) (r0 (c0, d0)...
11:30:09 <Denommus> ClaudiusMaximus: for instance, if my URL requires a parameter "bar", I want to have a compiler error in case I try to access it as foo
11:30:26 <sinelaw> Denommus, I think yesod does that, but see docs
11:31:02 <benzrf> > traverse.both first^..[((4,0),(5,2)),((40,0),(50,2))]
11:31:04 <lambdabot>  Couldn't match type ‘[((t1, t2), (t3, t4))]’
11:31:04 <lambdabot>                with ‘(a -> Control.Applicative.Const (Data.Monoid.Endo [a]) a)
11:31:04 <lambdabot>                      -> (r0 (b0 -> c0) (b0 -> c0)
11:31:20 <benzrf> pfft
11:31:55 <johnw> first wants a function, what are you trying to achieve?
11:33:08 <benzrf> shit
11:33:17 <benzrf> i confused with fst. and also with how to actually use both
11:33:28 <benzrf> its ok i got it
11:33:36 <benzrf> > traverse.both._1^..[((4,0),(5,2)),((40,0),(50,2))]
11:33:37 <lambdabot>  Couldn't match type ‘[((t1, t2), (t3, t4))]’
11:33:37 <lambdabot>                with ‘(a -> Control.Applicative.Const (Data.Monoid.Endo [a]) a)
11:33:37 <lambdabot>                      -> ((a1 -> f0 b1) -> t0 (r0 a0 a0) -> f0 (t0 (r0 b0 b0)))
11:33:38 <johnw>  I usually say used as: over both f <some tuple>
11:33:43 <benzrf> mfw i dont got it
11:33:44 <johnw> s/say/see it
11:33:45 <joelteon> /query
11:33:51 <johnw> yeah, query would be better
11:34:11 <benzrf> what's wrong with that though
11:34:14 <joelteon> /query lambdabot traverse.over both..^&#&#^& fst (1,2) ###
11:34:16 <johnw> playing with lambdabot in the main channel works best if you're trying to demonstrate something to someone else, rather than if you're just trying to understand something for yourself
11:34:29 <benzrf> i was initially trying to demonstrate
11:34:34 <joelteon> well, demonstration time is over
11:34:38 <benzrf> ok. sorry :(
11:34:47 <johnw> benzrf: ah, kk, I missed the context
11:34:52 <Iceland_jack> benzrf: You can try getting it to work in PM
11:35:07 <johnw> yeah, then you look awesome when it appears to work the very first time
11:35:09 <Iceland_jack> and then using the result on the main channel
11:35:12 <Iceland_jack> Exactly ;)
11:35:47 <benzrf> i thought i got it working in pm but then it turned out i didnt ;-;
11:36:19 <Iceland_jack> I read “demonstration time is over” in Arnold Schwarzenegger's voice
11:37:21 <Iceland_jack> Actually in Rainier's voice (https://www.youtube.com/watch?v=ekxn5KLv9XQ) </off topic>
11:38:04 <chaosmasttter> benzrf: the list should be the first argument to (^..)
11:38:37 <benzrf> wait.
11:38:38 <benzrf> ARGHHHHHH
11:38:44 <benzrf> CURSE YOU EDWARDK
11:39:07 <chaosmasttter> :O
11:39:12 <Benzi-Junior> Iceland_jack: shame it seems like it would be a nice thing to have
11:39:32 <benzrf> > [((4,0),(5,2)),((40,0),(50,2))]^..traverse.both._1
11:39:34 <lambdabot>  [4,5,40,50]
11:39:34 <benzrf> woot
11:40:39 <Denommus> sinelaw: can yesod be used inside a sandbox without that stupid binary that basically requires Stackage, though?
11:40:56 <Iceland_jack> Benzi-Junior: I use a more limited version of the same idea in some of my projects, but I will try to make time to work on it
11:41:04 <sinelaw> Denommus, I have absolutely no idea. sorry :)
11:41:21 <johnw> benzrf: see, now you look like a lens ninja ;)
11:42:20 <sinelaw> benzrf, I would be a bit more careful. never know where that cofree comonad coalgebra can hit you.
11:42:46 <sinelaw> :P
11:43:35 <benzrf> lens ninja. is that like a javascript ninja
11:44:05 <johnw> a javascript ninja is smoke, you are the dream of a hazy night under a dark moon
11:46:08 <johnw> ok
11:46:10 <johnw> oops
11:46:33 <kbeaty> So speaking of lenses, something I’ve been wondering but haven’t tested yet: Does ‘taking’, etc., early terminate the traversal or are subsequent items simply ignored?
11:48:36 <johnw> kbeaty: laziness should make it the former
11:48:46 <johnw> it's not that it early terminates, but that you fail to force evaluation of the remainder of the work
11:49:11 <kbeaty> Ah.  makes sense.  Thanks
11:57:17 <edwardk> > [1..]^..taking 10 traverse
11:57:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
11:57:23 <edwardk> ^- that terminates =)
11:57:37 <edwardk> getting that to terminate was hellish
11:57:43 <edwardk> but we made it work in the end
11:57:52 <haskell613> @pl \n f -> liftM ((,) n) . f
11:57:52 <lambdabot> (.) . fmap . (,)
11:57:55 <edwardk> > [1..] & taking 10 traverse +~ 1
11:57:56 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:58:24 <edwardk> ^- that also remains productive in the presence of a non-strict spine on the data type
11:58:31 * shapr hugs edwardk 
11:58:32 <vanila> why not just  take 10 [1..]
11:59:23 <edwardk> vanila: you can do that. now take the first 3 elements from a map where the keys start with the string "Fred"
11:59:33 <edwardk> vanila: and notice the second usecase wrote back
11:59:39 <edwardk> not just read
12:00:05 <edwardk> everything you can write with lens you can by definition write without lens
12:00:13 <edwardk> its just a question of verbosity and vocabulary
12:00:35 <edwardk> ok, well there are a few things that lens does that you'd be hard pressed to duplicate on your own, but they are pretty scary
12:01:13 <kbeaty> So is the secret to getting that to terminate by the use of Bazaar (Magma? … sorry working from memory)  … you fail to force the evaluation of the tail?
12:01:16 <edwardk> e.g. upon, the hitmap code in uniplate, etc.
12:01:25 <johnw> here's a real-world lens example that happened in some code: https://gist.github.com/b973677813518dba2f01
12:01:59 * hackagebot dockercook 0.4.0.0 - A build tool for multiple docker image layers  http://hackage.haskell.org/package/dockercook-0.4.0.0 (AlexanderThiemann)
12:02:04 <edwardk> kbeaty: the secret of termination there was the Bazaar being the forall f. Applicative f => (a -> f b) -> f t   version rather than the more direct ADT version
12:02:15 <johnw> sometimes lens feels like the Tai Chi saying, "Use an ounce to deflect a thousand pounds"
12:02:29 <vanila> the lense version there looks a lot better
12:04:40 <edwardk> kbeaty: the benefit there was we were able to make the cps'd bazaar productive, which is interesting because in the monad case the cps'd version is often less productive, e.g. no CPS'd state/writer exists
12:04:50 <pyon-gadt> What implementation trick is used so that show "foo" returns "\"foo\"", rather than "['f','o','o']" ?
12:05:24 <geekosaur> showList mthod of Show is specially implemented for Char
12:05:45 <haskell613> @pl \f -> f x
12:05:45 <lambdabot> ($ x)
12:05:46 <geekosaur> in fact that's the whole reason showList is a separate method
12:05:53 <albeit> @pl \_ -> False
12:05:53 <lambdabot> const False
12:06:10 <edwardk> class Show a where showsPrec :: Int -> a -> ShowS; showList :: [a] -> ShowS; show :: ...
12:06:16 <edwardk> showList is included in the class
12:06:23 <edwardk> then its used by the instance for Show a => Show [a]
12:06:43 <pyon-gadt> Ah!
12:06:54 <edwardk> instance Show a => Show [a]  where  showsPrec _         = showList
12:06:54 <pyon-gadt> Thanks!
12:07:13 <edwardk> this has the benefit of being entirely haskell 98 and an easily copied pattern
12:07:25 <pyon-gadt> It is not that obvious... :-|
12:07:33 <edwardk> there is that
12:07:55 <kbeaty> edwardk: interesting.  thanks for the insight.
12:09:14 <edwardk> on the plus side it means you can overload other lists of things to show nicely. e.g. if you unwisely format your error messages in the Show instance, you can make it so lists of them show multiple lines of errors rather than try to make a more direct list, but this is a fairly slippery slope
12:09:17 <bernalex> anyone know how to get whatever's in the xorg copy buffer?
12:10:45 <geekosaur> that's a more involved question than you think, because there is no such thing
12:10:55 <geekosaur> selections are a *negotiation*
12:11:19 <geekosaur> "I have a thing. ask me for it in some format and I'll tell you if I can provide it in that format"
12:11:49 <bernalex> oh I mean marked text specifically
12:11:52 <geekosaur> yes
12:11:54 <geekosaur> same answer
12:12:01 <bernalex> and I'm sure you know that's not very helpful
12:12:53 <geekosaur> everyone thinks there is a "copy buffer" and programs as if there is. the result is we're still tracking down deadlocks in xmonad involving contrib modules that "know" that there is a copy buffer, and leave no room for the necessary protocol negotiation
12:13:32 <albeit> @pl \(a,b) -> (a, f b)
12:13:33 <lambdabot> second f
12:13:34 <geekosaur> (even for "just a string": so is that ISO8859 string, UTF8 string, or formatted text (COMPOUND_TEXT, HTML, etc.)?
12:21:59 * hackagebot io-streams-http 0.1.0.0 - http-client for io-streams  http://hackage.haskell.org/package/io-streams-http-0.1.0.0 (DavidJohnson)
12:22:44 <ahri> hi, i'm trying to learn haskell (and enjoying it!) so i'm playing about a bit and have become confused (didn't take long...) - https://gist.github.com/ahri/f676a6937d574a9c7dc8 is my attempt at filtering a list of strings, only showing which ones are video files - i ever wrote a recursive function to compare the ends of the strings which i'm particularly proud of ;)
12:24:28 <mmachenry> ahri: What's wrong with this?
12:24:35 <ahri> however, when i try to do: filtered getDirectoryContents "."    ...... well it doesn't work:  Couldn't match expected type `[String]' with actual type `FilePath -> IO [FilePath]' -- i looked in the docs and FilePath = String, but i don't really understand the IO bit, and how i might coerce my program into working
12:25:15 <geekosaur> first off, you're missing some parentheses. more significantly, you can't operate on an IO value as if it were just a value
12:25:20 <geekosaur> @quote /bin/ls
12:25:20 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:25:35 <geekosaur> in this case, you want fmap
12:26:00 <ahri> interesting! i will go look up fmap
12:26:03 <geekosaur> fmap filtered (getDirectoryContents ".") --- should give you an IO [String]
12:26:20 <mmachenry> ahri: I find, when doing IO stuff, as a beginner it's easiest to get comfortable with the do notation
12:26:31 <mmachenry> Though geekosaur is correct you can also do this:
12:27:05 <mmachenry> main = do { files <- getDirectoryContents "dir"; print filtered files }
12:27:08 <mmachenry> Or something like that.
12:27:46 <geekosaur> parens, again: print (filtered files)
12:28:01 <ahri> ooh, very interesting indeed. fmap's docs mention a "functor" but i don't know what that is :\
12:28:12 <mmachenry> The rules for doing IO (and no other monad) using the do notation (and not functors or bind operator) are pretty straight forward and allow you to get to the pure coding fairly easily.
12:28:17 <geekosaur> have you gone through LYAH yet?
12:28:21 <geekosaur> @where LYAH
12:28:21 <lambdabot> http://www.learnyouahaskell.com/
12:29:10 <ahri> i'm part way through, found myself slowing down and fancied a practical challenge, i will continue it
12:29:49 <xplat> aw hail naw, git version too early for git-annex
12:29:49 <acowley> ahri: It's something that lets you turn a function (a -> b) into a function with type (f a -> f b) for some "Functor" f, such as IO. So this examples turns the function filtered with type [a] -> [a] into one with type IO [a] -> IO [a].
12:29:53 <ahri> mmachenry: thanks for suggesting the do notation as a more accessible alternative
12:29:59 <mmachenry> No problem.
12:30:17 <bernalex> I don't understand how flag conditionals work. how do I add a build-depend based on a flag?
12:30:57 <acowley> bernalex: if flag(foo) build-depends: blah
12:31:06 <bernalex> it seems I cannot have "build depends: a,\n b,\n if flag (f) { c, }\n, d,\n
12:31:07 <acowley> bernalex: But put a newline in there and indent the build-depends block
12:31:19 <geekosaur> afaik build-depends accumulate, so you can just have a separate build-depends line for the conditional one
12:31:27 <bernalex> acowley: here's my example as a paste
12:31:29 <bernalex>   build-depends:     base >=4.7 && <4.8,
12:31:29 <acowley> bernalex: You can have multiple build-depends blocks
12:31:31 <bernalex>                      if flag (clipboard) {
12:31:33 <bernalex>                        Hclip >=3 && <4,
12:31:35 <bernalex>                      }
12:31:37 <bernalex>                      HTTP >= 4000.2 && < 4000.3,
12:31:38 <geekosaur> don't paste into the channel
12:31:48 <bernalex> geekosaur: it's only five lines.
12:31:57 <acowley> bernalex: Just have a second build-depends that's guarded by teh flag
12:32:06 <bernalex> acowley: ah so I can't have it inside that one
12:32:07 <ahri> acowley: hrm, i sorta understand! i'll have to read that over a few times!
12:33:11 <acowley> ahri: That lifting of a function is a really common pattern. If you want to apply a function to every element of a list, you want to take your function with type (a -> b) and turn it into a function [a] -> [b] which you can apply directly to a list with type [a]
12:33:15 <bernalex> hm I guess I'm doing it wrong then because this doesn't work either: http://lpaste.net/9065335433843441664
12:33:37 <acowley> ahri: If you have an optional value with type Maybe a, you want to turn a function with type a -> b into one with type Maybe a -> Maybe a, so again you use fmap
12:33:52 <geekosaur> the if goes *outside* the build-depends
12:34:07 <acowley> ahri: It's possibly the most useful pattern in the language!
12:34:14 <geekosaur> you are conditionalizing a block, which consists of a build-depends stanza
12:34:16 <bernalex> geekosaur: ah ok thanks
12:34:53 <Ankhers> ahri: You might want to look into the function `isSuffixOf` from Data.List It does the same thing as your `endsWith` function.
12:35:11 <xplat> you know you're a haskeller when you write a function that is all fmaps
12:35:44 <ahri> acowley: thanks for that explanation... not grokking it just yet :D
12:35:48 <clrnd> functor may be the best thing since LISP "invented" lists
12:35:49 <bernalex> hm. how do  I specify flags when building?
12:36:05 <acowley> ahri: Don't worry about it, just let it stew around in your head
12:36:14 <HrafnA> functor is a container (most of the time)
12:36:22 <ahri> Ankhers: i assumed as much :) you've just obviated my greatest haskell achievement ;D
12:36:36 <bernalex> can you really only do it when installing? oh well
12:36:42 <HrafnA> fmap is usually "apply this function to what's in the container"
12:36:54 <ReinH> Except when it isn't.
12:36:57 <acowley> bernalex: You say cabal configure -f flag && cabal build
12:37:14 <bernalex> acowley: ah. a bit strange you can't just pass it to build imo. thanks.
12:37:15 <vanila> when isn't it?
12:37:30 <acowley> vanila: This started with using IO's Functor instance
12:37:40 <ReinH> vanila: Plenty of functors are not "containers"
12:37:40 <Ankhers> ahri: lol. don't get me wrong, duplicating functions is one of the ways I am learning Haskell. I just figured you might want to know about it.
12:37:44 <HrafnA> vanila: (->), IO
12:37:48 <clrnd> the container metaphor can get confusing ... you can see almost everything as a container
12:37:53 <matematikaadit> :t fmap (+2) (*3)
12:37:54 <lambdabot> Num a => a -> a
12:38:01 <tdammers> guys, I'm getting "cabal: Codec.Compression.Zlib: premature end of compressed stream" here
12:38:08 <tdammers> any ideas why that is?
12:38:33 <ahri> Ankhers: hehe seriously, thanks for letting me know
12:38:41 <tdammers> it doesn't happen consistently, when I run cabal install again it seems to continue where it left off
12:38:50 <sinelaw> eww
12:38:53 <bernalex> hm. IDK if my search-fu or my manual-fu is broken, or both, but if anyone wants to speed it up: feel free to tell me how tho use flags in the src
12:38:54 <xplat> :t fmap fmap fmap (+) (+)
12:38:56 <lambdabot> Num a => a -> a -> a -> a
12:39:35 <HrafnA> Should probably have said "some of the time", rather than "most of the time".
12:39:48 <xplat> > fmap fmap fmap (+) (+) 10 2 300
12:39:49 <lambdabot>  312
12:39:56 <tdammers> any ideas why that might be?
12:39:59 <Ankhers> That is too much...
12:40:07 <Chathurga> xplat: You're a pervert!
12:40:18 <bernalex> xplat: teehee
12:40:33 <geekosaur> tdammers, might ask in #haskell--infrastructure; I think the haskell.org stuff is still having load issues
12:40:40 <vanila> Bool -> x  is isomorphic to (x,x), you can think of (->) e as an e-tuple containing something
12:40:50 <xplat> mental masturbation sounds like 'fmap fmap fmap'
12:40:53 <geekosaur> and is not unlikely terminating downloads prematurely or something
12:41:04 <tdammers> sounds logical
12:41:06 <HrafnA> vanila: TIL
12:41:21 <tdammers> but before I complain, I'll do a clean checkout and try to build that
12:41:36 <bernalex> hm. *do* you use the cabal flags in the src? is that maybe why I can't find anything online? lol
12:42:08 <xplat> bernalex: i think you can get at them with CPP?
12:42:19 <bernalex> xplat: I think so too. I vaguely recall doing it, even. but IDR how.
12:42:25 <ReinH> vanila: If e is a set, but Hask is not locally small and its types are not sets.
12:42:46 <xplat> or maybe also from that generated foo_paths module
12:42:55 <bernalex> that's wher I get filenames at least
12:43:11 <ReinH> In any event, I think this is stretching the "container" metaphor pretty thin
12:43:19 <bernalex> but honestly the CPP lulz way of doing it would be the easiest way of doing it at least
12:43:32 <xplat> ReinH: Hask's types are hsets
12:43:34 <vanila> k -> v is a key value store
12:43:39 <ReinH> xplat: hsets?
12:44:10 <xplat> well, actually i suppose they are presets
12:44:14 <ReinH> vanila: I understand the intuition.
12:44:20 <Guest26438> how bad of an idea is it to try and make a game in haskell
12:44:21 <vanila> im not talking about sets or anything
12:44:29 <Guest26438> and what do you guys think of helm
12:44:35 <xplat> Guest26438: see #haskell-game
12:44:52 <ReinH> vanila: You said "you can think of (->) e as an e-tuple", which I took to mean "as an |e|-tuple", since I'm not sure what e-tuple would mean otherwise.
12:45:17 <tdammers> hmm, clean checkout seems to build fine
12:45:20 <xplat> Guest26438: there's a *whole channel* devoted to discussing how bad of an idea it is
12:45:25 <tdammers> strange strange strange...
12:45:34 <ReinH> xplat: lol
12:45:35 <Guest26438> xplat: what did they decide
12:45:50 <bernalex> I think it's nice to do game programming in haskell
12:46:17 <xplat> Guest26438: you're expecting for a channel full of ircers to decide something?  ;)
12:46:31 <vanila> I don't know how to explain it simpler
12:46:32 <geekosaur> afaik cabal does not itself define cpp macros for its flags, but you can conditionalize a -D,,, parameter based on a cabal flag in the cabal file
12:46:33 <ReinH> vanila: But you are ofc right that Hask does have the prod/hom isomorphism.
12:46:35 <Guest26438> good point
12:47:10 <geekosaur> (if it does do so, someone should update the cabal user manual or at least put a pointer somewhere in "Conditional compilation"
12:47:18 <xplat> vanila: you could try explaining it at greater length by linking ralf hinze's 'generalizing generic tries'
12:47:21 <ReinH> so e^2 = (e,e) is your Bool example
12:47:47 <bernalex> geekosaur: IDK what a -D parameter is
12:47:57 <ReinH> iow a^x is the x-fold cartesian product of a
12:48:12 <bernalex> geekosaur: ohwait I get what you mean
12:48:21 <bernalex> I thought you meant some secret cabal option or osmetihng
12:48:27 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-phases.html#c-pre-processor
12:48:54 <ReinH> vanila: at least in platonic Hask
12:49:52 <xplat> platonic hask, where partial functions like fromJust are replaced by total ones like maybeToMaybe
12:50:55 <ReinH> xplat: it's nice to work in a CCC
12:50:56 <bernalex> geekosaur: is there some other way you're supposed to use to access the flags?
12:51:17 <geekosaur> ?
12:51:31 <Guest26438> could you guys reccomend a tutorial for somebody whos never done any programming at all
12:51:31 <ReinH> vanila: my "is `e' a set though?" was a nitpick, so never mind that.
12:51:33 <geekosaur> as I said, I'm not aware of one
12:51:36 <Guest26438> not me but that doesnt really matter
12:51:41 <xplat> ReinH: yeah, but they're no grothendieck toposes
12:51:47 <ReinH> xplat: :p
12:51:49 <bernalex> that's weird/sad. I guess I'll read up and try to use CPP.
12:52:00 * hackagebot fft 0.1.8 - Bindings to the FFTW library.  http://hackage.haskell.org/package/fft-0.1.8 (HenningThielemann)
12:52:21 <johnw> I love a programming channel where grothendieck toposes legitimately comes up during the course of conversation
12:52:26 <ReinH> vanila: My concern is that if you define "container" in a sufficiently vague way, most things are indeed a container, but then the word is less useful as a result.
12:52:37 <ReinH> And I think we'd do better to just avoid the "functors are containers" false equivalence to begin with.
12:52:50 <ReinH> johnw: :)
12:52:54 <benzrf> jle` is the person to ask about netwire, right?
12:53:15 <xplat> there's also a technical use of containers, for which only some functors qualify
12:53:18 <johnw> ReinH: except that in dependent typing, viewing functors as containers becomes genuinely valuable: see http://www.cse.chalmers.se/~nad/repos/lib/src/Data/Container.agda
12:53:31 <ReinH> Besides which, any sentence that begins "functors are" will likely end in confusion anyway.
12:53:46 <xplat> although i like 'polynomial functor' or at least 'container functor' better than container for that
12:53:47 <johnw> although, this is not the sense of the word container that some people typically expect
12:54:03 <geekosaur> afaik flags are intended for dependencies, not for this kind of use.
12:54:05 <HrafnA> Functors are an object?
12:54:13 <johnw>  I think a lot of people think of containers as if they were physical cells sitting in memory
12:54:14 <benzrf> HrafnA: heck no
12:54:17 <ReinH> johnw: Yeah, this is sort of proving my point though. If you define container in such a way that functors are containers then yes, it is trivially true. But the word "container" isn't adding any meaning any more.
12:54:22 <benzrf> HrafnA: a functor is a mapping between categories!
12:54:34 <johnw> "container" in general is fairly meaningless, perhaps
12:55:15 <johnw> how do you "contain" anything anyway, either we are talking about value -- in which case they are mathematical entities -- or we're talking about memory cells, in which case we should probably just be saying memory cells
12:55:36 <xplat> i actually mean a cardboard box
12:55:44 <johnw> ooh, interesting, do continue
12:55:59 <benzrf> johnw: a container is an ADT that does not use functions as a hardcoded type and whose constructors may store values of its parameter
12:56:05 <benzrf> how's that :-)
12:56:15 <ReinH> benzrf: IO
12:56:17 <HrafnA> Most people can grok the intuitive notion of a box with a value in it, and map meaning "change the value without changing the box"
12:56:22 <benzrf> ReinH: is not a container
12:56:30 <johnw> benzrf: except when your ADT is somehow fused away during an evaluation
12:56:30 <ReinH> benzrf: but it's an instance of Functor
12:56:39 <benzrf> ReinH: yes, i was defining container, not functor
12:56:46 <HeladoDeBrownie> contents :: (Contains c a) => c -> [a] -- Probably the sanest commonality I can think of between things I've heard called "containers"
12:56:50 <ReinH> HrafnA: Yes, it's an attractive and intuitive notion, so let's ignore the part where it's wrong... ;)
12:56:55 <geekosaur> "functors... are." :p
12:56:56 <vanila> how is it wrong?
12:57:04 <benzrf> HeladoDeBrownie: isnt that just foldable.
12:57:12 <HeladoDeBrownie> benzrf, almost!
12:57:14 <xplat> i don't claim that all functors are containers.  just functors between slice categories that preserve filtered limits.
12:57:18 <geekosaur> (meanwhile I am thinking of the "simple, elegant, and wrong" quote >.> )
12:57:20 <benzrf> u w0t
12:57:22 <ReinH> xplat: :p
12:57:31 <HrafnA> ReinH: As with most pedagogical abstractions
12:57:55 <vanila> I don't understand the objection to this metaphor
12:58:16 <Guest26438> whats a good tutorial for someone whos never programmed before
12:58:17 <johnw> abstract bikeshedding
12:58:35 <Guest26438> i would give my friend learn you a haskell
12:58:37 <Guest26438> but
12:58:46 <Guest26438> i dont know if thats good for someone whos never programmed
12:58:56 <bernalex> Guest26438: likely not
12:58:59 <ReinH> My problem is if you say "functors are containers" then you just shift the burden to defining "containers"
12:59:10 <ReinH> Which most people seem to do by saying "things that have fmap", at which point you've just added indirection.
12:59:11 <Guest26438> so where should i start hhim?
12:59:15 <jle`> benzrf: technically the literal "the person" is mm_freak, but a lot of netwire people hang out on #haskell-game if you wanted to give it a shot there :)
12:59:20 <xplat> i don't know if there's a good haskell tutorial for someone who's never programmed in written-down form
12:59:21 <vanila> it's not a definition, it's just a way to help understand functor
12:59:25 <bernalex> Guest26438: someone who has never programmed really should have a mentor of sorts. figuring out a text editor, compiler, etc. is kind of hard. getting into the problemsolving mindset of searching for errors etc.
12:59:33 <Guest26438> i can mentor them
12:59:40 <Guest26438> but i dont know how to start them from the beginning
12:59:42 <benzrf> @let newtype AppMon f a = AppMon {runAM :: f a}
12:59:43 <lambdabot>  Defined.
13:00:18 <benzrf> @let instance (Applicative f, Monoid a) => Monoid (AppMon f a) where mempty = pure mempty; mappend = liftA2 mappend
13:00:19 <lambdabot>  .L.hs:175:18:
13:00:19 <lambdabot>      Could not deduce (Applicative (AppMon f))
13:00:19 <lambdabot>        arising from a use of ‘pure’
13:00:23 <xplat> a number of people have taught haskell to kids with single-digit ages though, so it's probably possible if you have the patience to sit down with your friend to teach them too
13:00:38 <vanila> The idea is that everyone has an rough idea of a container - and you can use to get a good start on understanding functor
13:00:38 <benzrf> @let instance (Applicative f, Monoid a) => Monoid (AppMon f a) where mempty = AppMon (pure mempty); mappend (AppMon x) (AppMon y) = AppMon (liftA2 mappend x y)
13:00:40 <lambdabot>  Defined.
13:00:41 <tdammers> ah, think I found the culprit
13:00:42 <shaykha> if there was a version of sicp which used haskell instead of scheme
13:00:50 <tdammers> filelock
13:00:50 <benzrf> cant i use this to monoid from functor
13:00:52 <shaykha> perhaps
13:00:54 <benzrf> wait never mind shit
13:01:07 <benzrf> f-forget i said anything
13:01:32 <ReinH> If nothing else, I would prefer to talk about which functor instances are like containers and which are not.
13:01:37 <benzrf> i was thinking that would let me traverse a foldable but then i forgot the main point
13:01:48 <vanila> which ones aren't?
13:01:57 <xplat> IO
13:02:13 <ReinH> vanila: Again, this depends on your definition of "container".
13:02:21 <mjrosenb> @hoogle Monad m => Bool -> m ()
13:02:23 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
13:02:23 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:02:23 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
13:02:36 <ReinH> FSVO "container", every functor is indeed a container, but these values of container are equivalent to "has fmap".
13:02:37 <vanila> well there is no definition of container, it's just a mental image
13:02:52 <vanila> this is used for intuition, not rigorious/formal work
13:03:13 <mjrosenb> do list comprehensions have anything like guard build in as syntactic sugar?
13:03:19 <bernalex> geekosaur: is there some common way of sending CPP opts via cabal?
13:04:33 <bennofs> `micro_: yes:
13:04:47 <bennofs> > [x | x <- [1..10], even x]
13:04:48 <lambdabot>  [2,4,6,8,10]
13:04:54 <bennofs> mjrosenb: ^^
13:04:54 <mjrosenb> @hoogle (a -> Bool) -> [a] -> ([a],[a])
13:04:55 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
13:04:55 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
13:04:55 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
13:05:01 <mjrosenb> bennofs: eeeeexcelent
13:05:21 <mjrosenb> > break even [1..10]
13:05:23 <lambdabot>  ([1],[2,3,4,5,6,7,8,9,10])
13:05:26 <shaykha> Guest26438: perhaps your friend should start from SICP and then move to haskell from lisp...it should be much easier than starting from java or C and moving to haskell, I suspect
13:05:30 <HrafnA> Best to take "container" as an analogy, rather than a description.
13:05:31 <mjrosenb> nooot quite :-/
13:05:34 <ReinH> IO and State-like things (Parser) are difficult to think about as being "containers", for instance
13:05:37 <mjrosenb> > span even [1..10]
13:05:39 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
13:05:40 <Guest26438>  shaykha i think thats a little to intense
13:05:45 <tdammers> yep, filelock is the culprit
13:05:47 <Guest26438> shaykha: having him read all of SICP
13:06:01 <xplat> mjrosenb: do you even span?
13:06:02 <geekosaur> afaik it's just something like:  if flag(myflag)\n  ghc-options: -DMYFLAG\n
13:06:06 <mjrosenb> also, I never imagined having 'break even' be a useful sequence of tokens
13:06:06 <HrafnA> Whether it's a useful or a harmful analogy is debatable.
13:06:11 <mjrosenb> xplat: evidently not!
13:06:17 <ReinH> And it definitely falls apart when you get to contravariant functors, but that's another matter
13:06:44 * mjrosenb wonders if he should hope that (filter f l, filter (not . f) l) will get list-fusioned into something better
13:07:18 <ReinH> There have been attempts to formalize "container" irt functors, for example http://www.cs.nott.ac.uk/~txa/publ/cont-tcs.pdf
13:07:49 <xplat> mjrosenb: that might be a bit beyond base's current fusion tech
13:08:05 <clrnd> I always wished for a kind of ahskell-oriented SICP
13:08:14 <clrnd> maybe Santa can make it happen
13:08:14 <mjrosenb> xplat: also, I really don't care about how many allocations it does
13:08:16 <HrafnA> Lazy folks' solution: Container = Traversable
13:08:20 <HrafnA> :P
13:08:26 <mjrosenb> these lists are bounded at like 30 elements.
13:08:41 <ptalbot> hi, is there a monad, similar to the Error monad, but with a third state, say PartialError, containing an error + value, but indicating that the computation can continue for now. Use case: compiling a code-source can continue even if some errors are encountered (with the goal to generate more errors) but we must remember that it previously failed.
13:09:12 <tdammers> ptalbot: you mean like compiler warnings?
13:09:18 <mjrosenb> ptalbot: not that I know of, but writing one should be pretty easy
13:09:20 <tdammers> ptalbot: I'd use WriterT for that or sth
13:09:25 <mjrosenb> tdammers: I think he means like make -k
13:09:29 <xplat> ptalbot: you might have some luck googling for that as like 'warning monad' or something
13:09:31 <tdammers> oh, ok
13:09:51 <pharpend> I'm trying to cabal install cabal-install
13:09:53 <pharpend> http://ix.io/3Sx
13:10:12 <pharpend> and some insane package has base < 4.3 as a dependency
13:10:12 <pharpend> how do I see which package this is?
13:10:16 <vanila> Yeah it doesn't work well for parser, you can pretend parser a contains an a or emits an a that it reads out a string, so fmap f will go in and change it to a b - but at this point I think you have to already understand things like the type of fmap, the laws to get that
13:10:31 <ptalbot> tdammers, xplat, not like warning, real error, but we can continue the computation, example: an error in a function doesn't not prevent the compiler to try to compile another function.
13:11:21 <ptalbot> mjrosenb, I'm in the Haskell channel but I'm not actually writing Haskell ^^' but I'd like to know how monad guys would have written this.
13:11:23 <dcoutts_> pharpend: -v
13:11:37 <johnw> what is a monad guy? :)
13:11:47 <ReinH> vanila: My experience is that if you start by saying "functors are like containers" then you end up by just explaining them "properly" anyway to get around the ambiguities the former introduces, so this explanation might be somewhat useful as an intuition pump, but it's very quickly outgrown.
13:12:00 * hackagebot monad-gen 0.3.0.1 - A simple monad for generating fresh integers  http://hackage.haskell.org/package/monad-gen-0.3.0.1 (jozefg)
13:12:02 * hackagebot lmdb 0.2.4 - Lightning MDB bindings  http://hackage.haskell.org/package/lmdb-0.2.4 (dmbarbour)
13:12:55 <johnw> "many things that behave like containers can be treated as functors"
13:13:04 <benzrf> lately ive been seriously thinking that maybe the best way to explain functors is to teach the idea of a monoid homomorphism, show the functor type as a mapping to another "monoidy thing with functions", and then illustrate that it's a homomorphism
13:13:16 <benzrf> er, fmap type
13:13:16 <ReinH> vanila: I usually describe Functor in terms of type constructors of kind * -> * and the type and laws of fmap, then describe some container-like functors to provide an intuition, then describe some not-very-container-like functors to help avoid fixating on a wrong model.
13:13:18 <HrafnA> My understanding of functor is "things what you can map over"
13:13:20 <spacevessel> what is going on here
13:13:33 <ptalbot> johnw, understanding monad should be enough to make you a "monad guy" ^^'
13:13:35 <Iceland_jack> I've never found Functor to be a difficult concept to teach
13:14:01 <johnw> ptalbot:  cool, it's like discovering I'm a member of a club that I never even knew about :-)
13:14:29 <johnw>  if anything, I've found that people jump too quickly to thinking that they completely understand what Functors are about
13:14:36 <ptalbot> johnw, lol
13:14:37 <vanila> I think that "Functor" in haskell (what we have been talking about today) is much simpler than actual Functor from category theory
13:14:52 <Iceland_jack> Yes, they're worlds apart
13:15:00 <HeladoDeBrownie> vanila, it is, in particular the "category" is always "Hask"
13:15:07 <HeladoDeBrownie> Hask → Hask
13:15:09 <ReinH> vanila: Identity, Maybe and [] are decent "containers", while ((->) r), IO and, Parser are good "non-containers" (if you have to introduce the prod/hom isomorphism to explain why ((->) r) is a container, it isn't very intuitively a container imo).
13:15:52 <tdammers> ReinH: the more I use Haskell, the less I think of [] as a container
13:16:07 <ptalbot> btw, for my question, should I implement a monad that does this particular job? I hoped there was a smart monad combinaison that'd elegantly solve this problem.
13:16:18 <ReinH> tdammers: I said "(although [] is a big sketchy)" and then deleted it to save space, actually.
13:16:23 <tdammers> hehe
13:16:27 <tdammers> ok then
13:16:29 <tdammers> :D
13:16:33 <ReinH> s/big/bit
13:17:19 <ReinH> vanila: You can also make some useful distinctions between functors that are also comonadic or copointed (have extract :: f a -> a), etc
13:19:08 <benzrf> ReinH: i used to think of the reader functor as if (a -> b) is Map a b
13:19:12 <benzrf> in fact in some sense i still do
13:23:38 <mjrosenb> this is weird, I'm using interactive-haskell-mode in emacs, and I'm getting the impression that there is some amount of state that it is not telling me about.
13:23:59 <ReinH> Sure, vanila was mentioning this before as well. It's reasonable to think of (a -> b) as a container of b's indexed by a's. And it's supported pretty well theoretically.
13:24:55 <mmachenry> ReinH: Nice Haskell Cast. :)
13:25:22 <ReinH> mmachenry: :)
13:25:45 <mmachenry> Seemed like it could have been 3-hours long. That guy had a lot to say.
13:25:47 <mjrosenb> sometimes I'll hit C-c C-l, and it'll just not respond
13:25:58 <mjrosenb> so far every time I've tried a second time, it works just fine.
13:26:02 <ReinH> mmachenry: Definitely. We'd like to get him back on next year.
13:26:14 <zerokarmaleft> mmachenry: read conal's papers and blog :D
13:27:28 <xplat> a monad guy is a guy who never takes off his clothes, just puts on more and treats the entire mass as a single outfit
13:27:59 <xplat> also thinks a birthday suit is a real suit
13:29:29 <steffen> Come on, is there really no duplication elimination (nub) on Data.Vector Vectors?!
13:29:37 <tdammers> a monad guy is just a regular guy, there is absolutely nothing special about him, he just happens to be the right guy for a lot of jobs
13:31:39 <indiagreen> steffen: if you end up writing your own, would be cool if you could get it into vector-algorithms
13:31:49 <Black-Heaven> Is it possible to declare a parametrized kind? like Maybe k with t k? Thanks by advance for your help.
13:32:08 <indiagreen> well, don't actually write nub, write a function to remove consecutive duplicates
13:32:09 <steffen> indiagreen: mhmm, okay xD
13:32:23 <indiagreen> because a O(n²) nub is worthless anyway
13:32:39 <indiagreen> and then it could be used with any of the sorts in vector-algorithms
13:33:49 <steffen> indiagreen: yes, you're right
13:34:07 <mjrosenb> indiagreen: what is the running tome of the stdlib's nub?
13:34:46 <indiagreen> mjrosenb: you mean the one in Data.List?
13:34:59 <indiagreen> or there's one in C++'s stdlib?
13:35:16 <mjrosenb> indiagreen: err, yes, Data.List.
13:35:22 <indiagreen> O(n²)
13:35:34 <mjrosenb> indiagreen: ok, that is what I thought.
13:35:54 <indiagreen> I think there was a proposal to get nubOrd into base
13:36:00 <mjrosenb> well, technically, O(mn), where m is the size of the result
13:39:29 <mjrosenb> Is there something like !!, but it returns a tuple of the nth element, and the list without the nth element?
13:39:49 <indiagreen> no, but you can use splitAt
13:40:46 <quchen> mjrosenb: drop pretty much does that.
13:41:06 <quchen> Leaves you with a (:), which is kind of a tuple of head and tail. Except when the list is empty of course.
13:41:34 <quchen> Oh, you mean the entire list, including leading parts. Nevermind.
13:41:35 <indiagreen> quchen: drop still requires you to take the first n−1 elements to recover the list
13:41:39 <indiagreen> yep
13:42:00 * hackagebot vinyl-utils 0.0.0.0 - Utilities for vinyl  http://hackage.haskell.org/package/vinyl-utils-0.0.0.0 (mjmrotek)
13:42:32 <quchen> carter: ping
13:43:16 <quchen> Black-Heaven: What's "t k"?
13:43:25 <carter> quchen: what
13:43:41 <quchen> carter: I randomly found your HN comment from a year ago, https://news.ycombinator.com/item?id=7475624
13:43:59 <quchen> I was wondering how much of that made it, be it 7.10 or in general
13:44:21 <carter> the prelim stack trace stuff is in the process of landing right now
13:44:37 <mjrosenb> > (\l -> zipWith (\ i (h:t) -> (h,i++t)) (inits l)  (init $ tails l)) [1,2,3]
13:44:38 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
13:44:45 <mjrosenb> close enough...
13:44:51 <carter> quchen: which things are you wondering about
13:45:17 <quchen> carter: The comment mentions stack traces on exceptions, and memory-sandboxed threads of some sort.
13:45:33 <quchen> The latter in particular is something I would love to have.
13:45:38 <carter> quchen: well, did you see my reddit remark about stack traces when you do a profiling build?
13:45:40 <mjrosenb> quchen: indiagreen: ^ that is actually what I want :-/
13:45:55 <mjrosenb> I'm sad that I need the init $ tails l
13:46:10 <carter> quchen: i dont think ezyang's work on resource limits has been merged in, but you shoudl ask him
13:46:14 <quchen> carter: I did not, I just found that comment in isolation
13:46:30 <carter> @google haskell reddit stack traces today
13:46:33 <lambdabot> http://www.reddit.com/r/haskell/comments/2fwwx3/how_to_get_approx_stack_traces_with_profiled/
13:46:33 <lambdabot> Title: How to get (approx) stack traces with profiled builds : haskell
13:46:51 <vanila> > let select [] = [] ; select (x:xs) = (x,xs) : do (y,ys) <- select xs ; return (y,x:ys) in select "foobar"
13:46:52 <lambdabot>  [('f',"oobar"),('o',"fobar"),('o',"fobar"),('b',"fooar"),('a',"foobr"),('r',...
13:47:02 <quchen> Excellent, thanks
13:50:23 <Black-Heaven> quchen: t can be Maybe and k any kind, like you'll have do it at type level for example
13:50:23 <mjrosenb> vanila: that's cute.
13:50:23 <dfeuer> carter, I had another, insaner idea :-)
13:50:47 <carter> quchen: the HPC stuff hasn'thappened yet midnyou
13:50:48 <carter> dfeuer: oh?
13:50:57 <quchen> Black-Heaven: When you enable PolyKinds you can construct poly-kinded types, e.g. `data Apply a b = Apply (a b)` has kind (k -> *) -> k -> *
13:51:18 <quchen> Without PolyKinds it defaults to k=*
13:51:44 <dfeuer> Yes, carter. A finger tree is kind of sort of related to a zipper. I can make one *more* like that, I think, and then zip it :-)
13:51:52 <quchen> All you need in the end is a type of kind * when fully applied
13:52:32 <dfeuer> carter, it's the sort of thing that balances on a knife edge, but I think I can just make it work.
13:52:38 <dfeuer> If I can, it will be *beautiful*.
13:56:19 <mjrosenb> @djinn a -> b -> c -> d -> (a,b) -> c -> d
13:56:20 <lambdabot> f _ _ _ a _ _ = a
13:56:27 <pharpend> dcoutts: here's ghc-pkg check
13:56:32 <mjrosenb> @djinn (a -> b -> c -> d) -> (a,b) -> c -> d
13:56:33 <lambdabot> f a (b, c) = a b c
13:56:52 <pharpend> http://ix.io/3SF
13:57:01 <mjrosenb> @pl \ a (b, c) -> a b c
13:57:01 <lambdabot> (`ap` snd) . (. fst)
13:57:05 <pharpend> ack no
13:57:08 <pharpend> that's \cabal install cabal-install -v3
13:58:43 <sinelaw> is there a monoid for bool using or?
13:58:47 <carter> dfeuer: so ... oooo
13:58:48 <carter> huh
13:58:52 <carter> i'll have to ask you abou tit more that evening
13:59:05 <dfeuer> OK.
13:59:27 <pharpend> sinelaw: no, there is for Maybe, though
13:59:39 <pharpend> oh apparently not
13:59:54 <sinelaw> pharpend, well I could reverse the meaning of nothing
14:00:02 <sinelaw> Nothing = Something, Just = Junk
14:00:03 <sinelaw> :)
14:00:14 <pharpend> You could write a monoid instance
14:00:15 <Black-Heaven> quchen: I know, but my end goal is to 'port' typeclasses to kind-level. For example: http://lpaste.net/116640 I can't produce a single open type family, I need parametric kinds. You see what I mean?
14:00:33 <sinelaw> pharpend, with a newtype :(
14:00:41 <pharpend> hmm?
14:01:13 <joe9> How do I get the haskell source for this module? https://hackage.haskell.org/package/filepath-1.3.0.2/docs/System-FilePath-Posix.html
14:01:44 <Clint> joe9: you could try clicking on "Source"
14:01:44 <joe9> It says it is internal.hs Not sure if I can get that file from ghc or if that file is just an FFI to a Posix C library.
14:02:01 <joe9> Clint: source gives this: https://hackage.haskell.org/package/filepath-1.3.0.2/docs/src/System-FilePath-Posix.html#pathSeparator
14:02:18 <Clint> joe9: ah, sorry
14:02:35 <geekosaur> I would suggest `cabal get filepath`
14:04:54 <dcoutts_> pharpend: have a look at the output of ghc-pkg check, from the cabal-install output it looks like base is borked
14:05:41 <joe9> geekosaur: cool, that helped. Thanks.
14:05:44 <pharpend> dcoutts_: http://ix.io/3SE
14:06:40 <joe9> geekosaur: this is the file with code http://codepad.org/BbUfulFi . Why is this different from other libraries which just show the Source.
14:07:08 <dcoutts> pharpend: ok, you should unregister those broken packages
14:08:47 <geekosaur> joe9: for whatever reason, they decided to simulate a parameterized module (something SML has but Haskell doesn't) using CPP
14:09:01 <joe9> geekosaur: ok, thanks.
14:09:18 <geekosaur> most people don't do that, but they can avoid it for Windows vs. Posix in part because of packages like this one that hide the differences. which means they
14:09:34 <geekosaur> re exposed in this module and it has to use trickery to deal with them, but callers mostly don't need to care
14:14:16 <Aruro> interact id, seems to parse input line by line
14:14:33 <Aruro> but if given other function interact seems to stop after first successful line\
14:14:38 <Aruro> why?
14:15:36 <Iceland_jack> Aruro: 'interact' processes the entire input, not just a single line
14:16:06 <Aruro> ok that i knew but why it seems line by line mode in id case?
14:16:33 <xplat> interact id actually processes character by character, the console driver delivers it line by line though so it looks line by line
14:16:36 <edwardk> carter: around?
14:16:51 <carter> edwardk: a wee bit
14:16:53 <carter> sup
14:16:54 <Aruro> can i use this line by line option for my purpose? :)
14:17:16 <geekosaur> Aruro, I think you need to show us this "other function"
14:17:31 <geekosaur> we have no idea what you are doing and have to guess as to what you are seeing
14:17:31 <Iceland_jack> Aruro: What xplat said refers to the buffering, it doesn't actually change the functionality
14:17:40 <Aruro> for example llength s = show . length $ (lines s)!!0
14:17:50 <Aruro> after typing 123 i expect 3 :)
14:17:51 <edwardk> wanted to brainstorm a primitive i'm looking for, but which to my knowledge i can't write from the surface language
14:17:52 <Iceland_jack> If you do 'interact reverse' you're not going to reverse the input line-by-line
14:17:53 <Aruro> on next line
14:18:01 <geekosaur> that eats the entire input
14:18:11 <geekosaur> lines consumes everything
14:18:30 <Aruro> yes it stops
14:18:32 <Aruro> after that
14:18:42 <Aruro> how can i do it line by line like in id case?
14:18:55 <geekosaur> id is not doing it line by line
14:19:03 <Aruro> try it
14:19:06 <Aruro> it does line by line
14:19:07 <geekosaur> it is not'
14:19:15 <Aruro> 123 give you 123 on next line
14:19:17 <xplat> llengths s = map (show . length) $ lines s
14:19:18 <geekosaur> it is doing character by character.
14:19:24 <geekosaur> it outputs at a newline due to line buffering
14:19:25 <carter> edwardk:this evening?
14:19:31 <carter> i can brain storm a wee bit righ tnow
14:19:37 <geekosaur> it is not itself line buffering
14:19:47 <carter> edwardk: looks like prefetchValue and friends are merged into HEAD fyi
14:19:54 <joe9> geekosaur: thanks.
14:19:55 <danilo2> Hello! Is there in haskell something like show that produces ByteString instead? Or the standard way is to do (fromString.show) ?
14:20:27 <Aruro> xplat type is not correct
14:20:31 <Aruro> it has to be just string
14:20:35 <Aruro> interact rejects it
14:20:35 <johnw> encodeUtf8 . pack . show
14:20:42 <geekosaur> note that this line buffering is an attribute of a filehandle (and changes as to the type of input; try piping to it, it'll be *block* buffered)
14:20:58 <geekosaur> if you want to do line oriented, you must do that yourself
14:20:59 <xplat> Aruro: ok, put 'unlines .' after the =
14:21:18 <geekosaur> oh, sigh, I had that typed out and wiped it
14:21:18 <danilo2> johnw: I think this is the same as fromString -am I wrong? anyway - producing string and then converting it to ByteString seems a little bit innefficient, isnt it ?
14:21:26 <geekosaur> if you want to do line by line processing, you may want something like interact (unlines . f . lines)
14:21:28 <johnw> not sure where fromString is from
14:21:30 <bernalex> is there a haskell-y/cabal-y way of doing "use this function if it exists" (i.e. if the library is installed)? or just CPP wow lol
14:21:35 <Iceland_jack> johnw: Data.String
14:21:35 <Iceland_jack>              
14:21:40 <edwardk> what i'm looking for is a way to take an Array# of STRef's and a MutableByteArray# of sizeOf IntPtr * the same length, and within one unsafe prim scribble in all their addresses while gc is blocked from screwing with it.
14:21:43 <danilo2> johnw: Data.String
14:22:00 <johnw> ah, cool
14:22:11 <edwardk> i'm looking to use this to let me take a bunch of operations i need to perform on STRefs/IORefs from O(n^2) down to O(n) using Fritz Henglein's trick
14:22:15 <geekosaur> there is nothing like Show for ByteString. if such a thing existed, it would be for Text anyway
14:22:24 <Iceland_jack> Yes
14:22:25 <geekosaur> wanting Show for ByteString sounds confused to me
14:22:38 <danilo2> geekosaur: hmm, is there any reason I should use text instead of ByteString ?
14:22:48 <edwardk> if i can get that i can shed a ton of things where i need to thread a useless integer id that is only used for purposes henglein's trick supplants
14:23:08 <Iceland_jack> danilo2: ByteString is basically a list of bytes, it should be called 'bytes'
14:23:18 <Aruro> ok thank you, this works -- llength s = unlines . map (show . length) $ lines s
14:23:23 <edwardk> carter: i don't care if immediately upon return all the addresses change on me
14:23:27 <Aruro> but i dont get why :)
14:23:35 <geekosaur> danilo2, I don't know what you are doing so I cannot answer that. but ByteString is an octet string, whereas Show is *conceptually* text
14:23:37 <edwardk> i just need their identities 'all at once'
14:23:42 <Aruro> all the magic happens in lines unlines?
14:23:47 <Iceland_jack> Aruro: Here is the definition of 'interact':
14:23:48 <Iceland_jack> interact        ::  (String -> String) -> IO ()
14:23:48 <Iceland_jack> interact f      =   do s <- getContents
14:23:48 <Iceland_jack>                        putStr (f s)
14:24:02 <carter> edwardk: i think this would be doable  with C today
14:24:04 <edwardk> so i can use that inside a safe trick that only cares about uniqueness of identities, not the particular identities
14:24:09 <Aruro> yes my question is why id does not stop?
14:24:25 <Iceland_jack> 'id' doesn't stop
14:24:28 <Aruro> in case of id or last fucntion with unlines
14:24:34 <geekosaur> wanting it to be ByteString is confusing levels, or possibly assuming that everyone in the world uses 0x20-0x7e as the extent of printable characters
14:24:38 <danilo2> geekosaur, Iceland_jack : hmm, I'm just generating text - by concatenating large amount of "text chunks" - in this scenario - should I use ByteString or Text?
14:24:47 <danilo2> I understand Text is as fast as ByteString?
14:24:49 <edwardk> carter: i don't recall if i can pass an unboxed MutableArray# to C/C-- from haskell
14:24:55 <carter> you can :)
14:24:59 <carter> unsafe c calls are safe
14:25:01 <Iceland_jack> danilo2: Text using a text builder
14:25:28 <danilo2> Iceland_jack: Ok, could you just tell me one more thing? How is it "better" than using ByteStringBuilder?
14:25:30 <carter> edwardk: later this evening i'm down to help prototype this
14:25:36 <Aruro> before people said that  (lines s )!!0 consumes all input, how unlines fixes that?
14:25:41 <carter> unsafe C call would do that
14:25:43 <geekosaur> danilo2, again, I do not know what you are doing. so let me ask you this: what do you want your code to do when confronted with Unicode outside the range U+0000 - U+007F ?
14:25:51 <Aruro> aand thats why interact stops
14:25:52 <edwardk> what would i pass as the arg?
14:25:56 <carter> edwardk: how big an array
14:26:02 <Iceland_jack> danilo2: You should really think of ByteString as being quite different from Text
14:26:07 <edwardk> potentially quite big
14:26:14 <carter> how big?
14:26:26 <carter> unsafe C calls block RTS
14:26:31 <edwardk> from 10 entries to 10 billion. somewhere in that range ;)
14:26:32 <geekosaur> Aruro: unlines isn't what's "fixing" that. lines is, by breaking up the single long String into a list of String on newlines
14:26:33 <carter> i guess it could be chunked
14:26:38 <edwardk> i can't chunk it
14:26:40 <carter> ok
14:26:41 <edwardk> it has to all go
14:26:41 <Iceland_jack> If you want to go from "þ" :: String to a ByteString you need to specify an encoding (encodeUtf8, ...)
14:26:44 <carter> ok
14:26:47 <danilo2> geekosaur: Hmm, It will not - the code just concatenates chunks of Strings / ByteStrings / Text based on some rules. I will not go over the range
14:26:51 <geekosaur> then you can operate on each of those String-s as an independent line. then you undo it because interact works with a single long String
14:26:57 <carter> edwardk: what Arches does it need to work on?
14:26:59 <edwardk> because the prim has to give me all the IDs while gc isn't moving them
14:27:02 <carter> just x86_64?
14:27:05 <edwardk> carter: preferably all
14:27:08 <carter> ook
14:27:13 <carter> i think that MIGHT be doable
14:27:55 <Aruro> hm ok i understood you geekosaur
14:28:06 <carter> edwardk: i think its totally doable
14:28:11 <carter> theres some subtleties
14:28:24 <carter> but i think all the C code needs to know is what the ghc word size is for a given arch
14:28:28 <Aruro> my question can be modified, how can i accept  two strings and then print their length using interact?
14:28:48 <carter> edwardk: you want the pointers from boxed Array  copied to the ByteArray?
14:28:48 <geekosaur> not easily, because interact doesn't work that way
14:28:52 <Aruro> here is function llength s = unlines . map (show . length) $ lines s
14:29:10 <edwardk> basically i'm starting from newtype Disc a = Disc { runDisc :: forall b. [(a,b)] -> [[b]] } -- with a = IORef r hen i need to ball up the array of IORefs from the first arguments, copy that into a bytearray, so i can then play sorting games using the bytearray
14:29:38 <Aruro> so collecting back all lines with unline forces interact to continue?
14:29:43 <edwardk> that in the end then recovers a radix sort like linear time clustering by pointer in a way that is stable regardless of ordering
14:29:50 <carter> huh
14:29:55 <geekosaur> if you modify that to apply to whatever number of lines is present, then: interact (unlines . map f . lines)
14:30:01 <geekosaur> and f is applied to each line
14:30:11 <geekosaur> perhaps what's confusing you here is lazy I/O
14:30:26 <carter> edwardk: whats the fritz heglein trick
14:30:28 <danilo2> Iceland_jack: Ok, I see. So lets assume I'm generating a code in UTF-8 from an AST. In such case it is better to use Text? I know they are different - I understand the underlying implementation, but still I'm looking for answer - when to use BS and when Text
14:30:38 <Aruro> yes maybe :) i dont get why (lines s) !! 0 which should be one line stops interact
14:30:39 <geekosaur> interact lazily consumes a single long string which eventually contains all of the input
14:30:43 <Iceland_jack> danilo2: You'd use Text then
14:30:47 <edwardk> carter: http://lpaste.net/116599#line59
14:30:58 <geekosaur> because you continue to believe that interact processes lines
14:31:05 <geekosaur> interact sees nothing whatsoever of lines
14:31:07 <Aruro> ok its better :)
14:31:24 <edwardk> carter: basically its just a generic-ified version of a stable radix-style sort of the data
14:31:34 <danilo2> Iceland_jack: Ok, but could you tell me why? How is it better from using ByteStringBuilder?
14:31:42 <edwardk> with the benefit that it works on arbitrarily complicated nesting when phrased right
14:31:51 <edwardk> its analogous to an american flag sort in that respect
14:31:55 <geekosaur> so that "lines s !! 0" consumes the entire string, produces a list of strings, and then you throw away all but the first string
14:31:55 <edwardk> just ADT'd
14:32:12 <geekosaur> at which point there is nothing left for interact to work with
14:32:21 <Iceland_jack> danilo2: If you're dealing with binary data, use ByteString
14:32:34 <edwardk> but importantly it doesn't 'leak' any details about how you subdivide the pointers or their relative order in memory when applied in the manner i described above
14:32:43 <Iceland_jack> If you want to operate on the level of bytes at all, use ByteString
14:32:50 <Aruro> ook now i understdood i think
14:33:04 <geekosaur> interact (unlines . map f . lines) --- now f is invoked on each line of the input
14:33:09 <danilo2> Iceland_jack: oh, now I understand that the name ByteString is just confusing ...
14:33:17 <edwardk> but it takes us down from Omega(n^2) best case to a tight Theta(n)
14:33:26 <geekosaur> danilo2: yes. it's something of a historical artifact
14:33:27 <Aruro> you say that interact applies f lazily thus giving the impression of line by line?
14:33:29 <Iceland_jack> danilo2: Yes, it should really not be used internally for "human-readable text"
14:33:31 <edwardk> so idealized abstraction and idealized time
14:33:48 <geekosaur> what gives the impression of line by line is that you're feeding it from a line-oriented terminal, whose input is buffered per line
14:33:52 <edwardk> used with IORefs i can do some fun things with syntax trees
14:34:07 <Iceland_jack> Aruro: Try substituting what geekosaur has given you ('unlines . map f . lines') for the argument in the definition of 'interact'
14:34:12 <danilo2> Iceland_jack, geekosaur: heh, ok, thank you :) And again - going back to my original question - is there something like show, that produces Text instead of String? Because using fromString seems inefficient
14:34:13 <matematikaadit> @pl f = interact (unlines . map f . lines)
14:34:13 <lambdabot> f = fix (interact . (unlines .) . (. lines) . map)
14:34:26 <geekosaur> lazy I/O misleads you into thinking that something else is going on, and you're seeing the terminal's line-oriented behavior as the something else
14:34:28 <matematikaadit> @pl x f = interact (unlines . map f . lines)
14:34:28 <lambdabot> x = interact . (unlines .) . (. lines) . map
14:35:01 <Aruro> ok i have more understanding now, but why (unlines . map f . lines)  does not consume ALL input?
14:35:14 <geekosaur> it does consume all input
14:35:18 <Aruro> as you mentioned in case of (lines s)!! 0
14:35:35 <Aruro> so interact should stop after first line?
14:35:36 <geekosaur> but each invocation of f is given one line (as produced by `lines`)
14:35:42 <Iceland_jack> Aruro:
14:35:42 <Iceland_jack>     interact (unlines . map f . lines)
14:35:42 <Iceland_jack>     =
14:35:42 <Iceland_jack>     do s <- getContents
14:35:45 <Iceland_jack>        putStr (unlines (map f (lines s)))
14:35:48 <Iceland_jack>  
14:35:53 <geekosaur> and then what your function operates on is only that line
14:36:05 <Aruro> hm
14:36:11 <Aruro> but the terminal does not close
14:36:18 <Aruro> in case !!0 termianl closes
14:37:10 <Aruro> and interact effectively works only onces
14:37:17 <Aruro> i understood everything you said
14:37:21 <geekosaur> you're still hung up on that lines thing
14:37:24 <Aruro> i just dont get this little detail
14:37:34 <Aruro> no
14:37:40 <Aruro> even if we think like you propose
14:37:55 <xplat> Aruro: in the !!0 case interact throws away its reference to the getContents string after it sees the first newline
14:37:59 <geekosaur> your lines s !! 0 consumes *all* input, not one line of input. the !!0 then returns only the first line and throws the rest away
14:38:07 <geekosaur> nothing else is left
14:38:13 <geekosaur> so there can't be another invocation
14:38:17 <xplat> Aruro: which causes lazy IO to close the terminal
14:38:24 <edwardk> carter: so basically i just crank up UnliftedFFITypes and try to make it sing?
14:39:01 <edwardk> oh neat, it even already biases past the array header
14:39:06 <xplat> Aruro: that's strictly a lazy IO thing, if you rewrite interact with strict IO it will read as many lines as you want to give it and then only print one output line
14:39:07 <Iceland_jack> Aruro: Here is what happens when you write 'interact (\s -> lines s !! 0)':
14:39:07 <Iceland_jack>     do s <- getContents
14:39:07 <Iceland_jack>        putStr (lines s !! 0)
14:39:11 <Iceland_jack> when you've entered the first line and pressed return, the program closes. This is what is bothering you right?
14:39:38 <Aruro> yes!
14:39:39 <Aruro> :)
14:39:49 <Aruro> ty guys im getting closer to see it :)
14:40:08 <Aruro> so !! 0 brakes the getContents function?
14:40:38 <matematikaadit> @src (!!)
14:40:38 <lambdabot> xs     !! n | n < 0 = undefined
14:40:38 <lambdabot> []     !! _         = undefined
14:40:38 <lambdabot> (x:_)  !! 0         = x
14:40:38 <lambdabot> (_:xs) !! n         = xs !! (n-1)
14:40:39 <Iceland_jack> Aruro: In a sense, do you realize that you program hasn't read the entire input into 's' before the second line runs?
14:40:58 <Iceland_jack> *that your
14:41:13 <carter> edwardk: i think you can totally do that with C / C-- and unlifted/unsafe ffi calls
14:41:13 <carter> yeah
14:41:19 <carter> edwardk: so you dont need any help ?
14:41:21 <mmachenry> Anyone know how to tell haddock to link to stuff on Hackage when it's not defined in my local library?
14:41:27 <edwardk> sounds right, just need to figure out how to stride past everything
14:41:37 <carter> yeah
14:41:41 <Aruro> well i did not think about that, now i think, if its lazy i guess not :)
14:41:45 <carter> theres a wiki pge on that stuff
14:41:49 <edwardk> i could probably use an extra set of eyes. right now i'm googling my way to glory
14:42:04 <carter> cool
14:42:06 <Iceland_jack> Aruro: Right, so every time you "demand" some part of the input 's', GHC will read it
14:42:07 <Aruro> matematik how does it help us? to see the definition of !!?
14:42:08 <carter> i'll be around later this evening
14:42:18 <Iceland_jack> Aruro: If you don't demand it, GHC doesn't read the input!
14:42:25 <Aruro> aaa!
14:42:27 <Aruro> eurica
14:42:45 <Iceland_jack> danilo2: http://stackoverflow.com/questions/10988253/is-there-an-equivalent-of-the-show-typeclass-for-data-text does this help
14:43:03 <Aruro> good point, uuff now i think we got it
14:45:57 <Aruro> ok you want to say that (lines s)!!0 does not take into account that s can increase, thus being a fixed result as long as you got first line
14:46:12 <danilo2> Iceland_jack: Oh, interesting! But as I see (but I can be wrong) we cannot use here something like "deriving (TextShow)" when declaring custom datatypes?
14:46:37 <Aruro> and since its a fixed result after first line ghc quits lazy evaluation
14:46:38 <Iceland_jack> danilo2: You can in GHC 7.10 :) but for now that's right
14:47:00 * hackagebot pregame 0.1.4.0 - Prelude counterpart  http://hackage.haskell.org/package/pregame-0.1.4.0 (jxv)
14:47:24 <danilo2> Iceland_jack: that sounds great! :D
14:48:12 <Iceland_jack> danilo2: It's really like a lot of things "for historical reasons"
14:49:09 <Iceland_jack> Aruro: If you disable buffering for stdin ('hSetBuffering stdin NoBuffering') and do:
14:49:09 <Iceland_jack>     main = interact (take 10)
14:49:09 <Iceland_jack> your program will echo the first 10 characters and then exit
14:49:28 <danilo2> Iceland_jack: I know, but I don't get why we cannot one day make Haskell2, use HaRe to refactor all the libraries nd change all the historical ugly things (like fmap -> map) to nice ones.
14:50:01 <Iceland_jack> There are a lot of considerations needed, some of that is happening right now actually :)
14:50:34 <danilo2> Iceland_jack: I've heard about it 1 and 2 years ago, but things are changing slow as far as I see
14:50:36 <Iceland_jack> danilo2: https://ghc.haskell.org/trac/ghc/ticket/9586 is called "burning bridges" for a reason
14:51:21 <dfeuer> carter, I'm having type headaches again, and I still don't know if they're a symptom of a more serious problem. Nested types suck.
14:51:36 <carter> polymorphic recursion IS mind boggling
14:51:48 <danilo2> Iceland_jack: the ticket seems nice and I would love to see cleaned stdlib in Haskell in one day! :))))
14:51:51 <dfeuer> carter, those off-by-one errors at the type level...
14:51:54 <johnw> dfeuer: why do nested types suck?
14:52:21 <dfeuer> johnw, they seem to make code rather hard to write, although it's usually not terrible to *read* it.
14:52:29 <johnw> example?
14:52:33 <Iceland_jack> danilo2: Breaking and retroactive changes are not as simple as you make them out to be, there are also standards (Haskell reports) that need to be taken into account
14:53:22 <dfeuer> johnw, Data.Sequence, which is what I'm banging my head against. See https://github.com/haskell/containers/issues/73#issuecomment-67229602 for the specific thing I'm trying to do.
14:53:33 <danilo2> Iceland_jack: Lets make a new Haskell2015 standard! :D I'm joking of course. Anyway I hope the things will be changed as fast af possible :)
14:56:40 <dfeuer> johnw, strange enough for you?
14:58:56 <dfeuer> johnw, the main remaining challenge (if in fact this is possible to do at all) is coming up with the right type signature for the function that does most of the work, after the thinning and mixed up in the squashing.
14:59:38 <lpaste> Aruro pasted “interact or not” at http://lpaste.net/116641
14:59:45 <johnw> ah, all that finger-tree stuff
14:59:52 <dfeuer> Yep.
15:00:04 <Aruro> why it does not work?
15:00:15 <Aruro> nothing is not getting printed
15:01:07 <dfeuer> Aruro, "interact" is a pretty lousy way to do IO.
15:01:21 <Iceland_jack> Aruro: it does work :) depending on what you want to do
15:01:22 <Aruro> i know
15:01:24 <dfeuer> Don't expect it to do anything remotely sane.
15:01:34 <Aruro> i provided a function string to string
15:01:44 <Aruro> and it does not print even otherwise case :)
15:01:46 <Iceland_jack> Aruro: 'length . lines' needs to read the *entire* input
15:02:00 * hackagebot tamper 0.4.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.4.0 (TobiasDammers)
15:02:15 <Aruro> so its not getting evaluated at all?
15:02:23 <dfeuer> Aruro, how are you using it?
15:02:29 <Aruro> terminal
15:02:37 <Aruro> typing 123
15:02:43 <Aruro> its gives me nothing
15:02:43 <dfeuer> Aruro, and ending the input with what?
15:02:44 <Iceland_jack> Aruro: Try typing ^D afterwards
15:02:45 <geekosaur> right, and it's waiting to see the rest of the oinput
15:03:04 <Aruro> hm
15:03:07 <Iceland_jack> or piping:
15:03:07 <Iceland_jack>     $ echo 'a\nb\nc\nd' | ...
15:03:07 <Iceland_jack>     1
15:03:10 <Iceland_jack> which should give you what you expect
15:03:27 <Iceland_jack>     $ echo 'blablablaa\nb\nc\nd' | ...
15:03:27 <Iceland_jack>     10
15:04:05 <Aruro> ok i think i got finally confused but i like it uses lazy io :)
15:04:07 <Iceland_jack> And if you do 'echo -n | ...' you get 'nothing' as expected
15:05:08 <Aruro> to sum up if i use just !!0 it brakes input after first line but giving result, if i use unlines . map f. lines it works line by line, and if i use last case it does not work :)
15:05:33 <Aruro> waiting forever for ctr d
15:06:04 <Iceland_jack> Aruro: Did you expect the last example to print the length of the first line immediately after the first newline?
15:06:18 <Aruro> yes :)
15:06:24 <Aruro> i wanted to emulate !!0
15:06:28 <Aruro> by ticking it
15:06:38 <Aruro> but i got tricked myself :)
15:06:46 <Aruro> tricking*
15:07:12 <Iceland_jack> Aruro: Consider the content 's', and consider how much of it gets evaluated
15:07:39 <Iceland_jack> When you compare 'length (lines s)' to 0, GHC needs the entire input of 's' to compute that
15:08:13 <Aruro> you want to say p does not get evaluated until ^d?
15:08:39 <Iceland_jack> It doesn't get fully evaluated until the entire input has been consumed yes
15:08:51 <Aruro> ok but why (lines s)!!0 works after first line?
15:09:00 <Aruro> now we are close to answer
15:09:01 <Aruro> i think
15:09:17 <Iceland_jack> Aruro: Assume that you have the input "a\nb\nc\n..."
15:09:26 <Aruro> yes
15:09:56 <Aruro> you want to say its kinda  infinite list?
15:10:06 <Aruro> and !!0 works on it by length does not?
15:10:51 <Iceland_jack> When you do 'lines s !! 0' you get:
15:10:51 <Iceland_jack>       lines "a\nb\nc\n..." !! 0
15:10:51 <Iceland_jack>     = ["a", ...] !! 0
15:10:51 <Iceland_jack>     = "a"
15:11:11 <Aruro> yes , ty i see now
15:11:19 <Iceland_jack> Aruro: So GHC only needs to read up until the first newline to compute 'lines s !! 0'
15:11:28 <Aruro> so everything boils down to how getContents is represented
15:11:42 <Iceland_jack> It boils down to how much you demand from the input
15:12:10 <Aruro> can i define my own length which will compute only up to  ... ? in the infinite list?
15:12:30 <Iceland_jack> Yes but don't
15:12:32 <Iceland_jack> just use "getLine"
15:12:35 <Aruro> :)
15:13:15 <Aruro> ok it seems interact was really done for piping not terminal
15:13:55 <dfeuer> johnw, I might've made some progress here.
15:14:13 <Iceland_jack> In the length case:
15:14:13 <Iceland_jack>       length (lines "a\nb\nc\n...")		/= 0
15:14:13 <Iceland_jack>     = length ("a" : lines "b\nc\n...")		/= 0
15:14:13 <Iceland_jack>     = 1 + length (lines "b\nc\n...")		/= 0
15:14:16 <Iceland_jack>     = 1 + 1 + length (lines "c\n...")		/= 0
15:14:19 <Iceland_jack>     = 1 + 1 + length ("c" : lines "...")	/= 0
15:14:22 <Iceland_jack>     = 1 + 1 + 1 + length (lines "...")		/= 0
15:14:26 <Iceland_jack>  
15:14:28 <dfeuer> It's f'ing ugly, so if it works, maybe someone else will be able to find a way to make it prettier.
15:14:35 <dfeuer> Or maybe I will.
15:14:49 <Iceland_jack> Aruro: If 'length' returned lazy natural numbers, that would work :)
15:16:10 <Aruro> let me wonder about last detail, in case length s u said it does not work because input is unfinished, but in case unlines . map f .lines it wroks because the result is defined even for unfinished s? right?
15:16:39 <geekosaur> because, as long as f is sufficiently lazy, it can produce output as it goes
15:16:48 <Aruro> ok
15:16:54 <geekosaur> actually not even that since you oinly get a single line handed to f
15:17:01 <Aruro> yes
15:17:03 <geekosaur> so it can be as strict as it wants; the rest is lazy enough to stream
15:17:29 <Aruro> ok
15:17:42 <Aruro> i consider it an interesting example of laziness :)
15:17:52 <Aruro> which need some talking too but accessible from start :)
15:18:10 <Aruro> talking into*
15:21:27 <Aruro> Iceland jack is it easy to make length which returns lazy results?
15:21:40 <Aruro> like you described before?
15:22:15 <chrisdone> with lazy numbers it's easy
15:22:28 <Iceland_jack> Aruro: Data.Text has a function called "compareLength"
15:22:34 <Iceland_jack> which basically does that
15:23:40 <Aruro> is there some other canonical example of trickyness of laziness?
15:23:45 <Zekka_> Anyone know what path format file-embed uses when embedding a directory recursively?
15:24:03 <Zekka_> I'm on unix now but will need to compile on Windows too and it's important that the path format be consistent
15:24:19 <Zekka_> (preferably consistently Windows, but if I know what the format is then it doesn't matter what it is)
15:24:49 <Zekka_> Also useful would be recognizing whether the path is a unix and windows format and converting it to a [FilePath] representation (where each name is a file/folder name) either way
15:24:58 <Zekka_> is a unix or windows format path*
15:25:02 <chrisdone> zekka_: it uses the filepath package, so i expect it works on unix or windows
15:25:19 <Zekka_> chrisdone: Yes, but does it consistently produce the same result on unix or windows?
15:25:52 <Zekka_> For instance, will it provide ("a\\b\\c.txt", "hah") built on Windows and ("a/b/c.txt", "hah") built on Linux?
15:26:18 <chrisdone> i expect so, but that should be fine if you are also using filepath or some other sensible OS-inspecific library
15:26:56 <chrisdone> if you build your path with "a" </> "b" </> "c" <.> "txt"
15:27:04 <Aruro> > let b = [1..]
15:27:05 <lambdabot>  not an expression: ‘let b = [1..]’
15:27:05 <Zekka_> chrisdone: The issue is that I need to split the path and then process it
15:27:07 <chrisdone> then it doesn't matter which OS it's compiled and run on
15:27:14 <Zekka_> > splitPath ["a\\b\\c"]
15:27:15 <lambdabot>  Not in scope: ‘splitPath’
15:27:15 <lambdabot>  Perhaps you meant one of these:
15:27:15 <lambdabot>    ‘BS.splitWith’ (imported from Data.ByteString),
15:27:21 <Zekka_> hm, not imported by default
15:27:29 <chrisdone> Zekka_: right, so filepath's split
15:27:40 <Zekka_> Wait, hold up a second
15:28:03 <Zekka_> Come to think of it, you're probably right, this may not actually matter
15:28:12 <chrisdone> you import System.FilePath, and then depending on whether you compile on posix or windows, it'll import the right System.FilePath.$OS module
15:28:14 <dfeuer> johnw, don't worry about it; I'm moderately sure I have it figured out :-)
15:28:28 <EvanR> funny how Bag module is its own top level module
15:28:43 <Zekka_> chrisdone: I think I got my wires crossed, because I actually knew that -- this program does a lot of windows-specific path processing in another related part
15:28:44 <chrisdone> EvanR: as is everything in the ghc api =p
15:28:49 <Aruro> > length [1..]
15:28:50 <Zekka_> and apparently I puzzled myself
15:28:53 <lambdabot>  mueval-core: Time limit exceeded
15:29:16 <EvanR> could make it tricky to find stuff, youd never expect it to be there right in your face ;)
15:29:53 <Aruro> why it can not say infinity in case of length [1..] ?
15:29:59 <Aruro> it a decided answer
15:30:06 <Aruro> is*
15:30:13 <Zekka_> Aruro: Because length doesn't know anything about the structure of the list
15:30:17 <chrisdone> zekka_: =)
15:30:19 <Zekka_> All it knows how to do is keep unconsing
15:30:22 <Aruro> but it does not matter
15:30:26 <Zekka_> Well, I can phrase that better
15:30:28 <Aruro> infinite list has infinite length
15:30:37 <EvanR> :t isInfinite
15:30:38 <lambdabot> RealFloat a => a -> Bool
15:30:38 <Zekka_> It doesn't know you expressed the list in a way that's sure to generate an infinite list
15:30:56 <Zekka_> Aruro: Try implementing length in a way that returns Infinity for an infinite list
15:31:00 <Zekka_> @src length
15:31:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:31:01 <xplat> Aruro: in general saying 'infinity' or a number in a finite time is as hard as the halting problem
15:31:14 <kadoban> Aruro: Trying to decide if a list is infinite is a hard problem, in general. It's actually undecidable...fun.
15:31:14 <Aruro> interesting
15:31:21 <Aruro> :)
15:31:22 <chrisdone> with lazy numbers you could have an infinite number in the same sense as an infinite list =)
15:31:25 <Zekka_> Haskell's existing implementation looks something like this: length [] = 0; length (x:xs) = 1 + length xs
15:31:26 <Aruro> wait
15:31:46 <Aruro> u mean in language there is no such thing as [1..] so its not possible to pattern match it?
15:31:54 <EvanR> chrisdone: like, many different versions of infinite numbers
15:32:02 <Zekka_> Aruro: There is such a thing as [1..], you just can't pattern-match beccause it's not a constructor
15:32:20 <Zekka_> You can't write length [x..] = Infinity because lists do not have a constructor [x..]
15:32:23 <Aruro> why list does not have infinite constructor?
15:32:38 <Aruro> for ord type classes?
15:32:39 <EvanR> you didnt define it yet
15:32:44 <xplat> you can encode the halting problem as a problem of deciding if a lazy list is infinite.  just make a list of the states a turing machine takes at each successive computation step
15:32:46 <Zekka_> Aruro: Because it's a hard representation to manipulate -- you can define a version that has one if you want
15:32:50 <EvanR> data List a = Nil | Finite [a] | Infinite [a]
15:33:08 <EvanR> now dont mess up
15:33:11 <Zekka_> But it will be possible to screw things up by putting an infinite list in the Finite branch or a Finite list in the Infinite one
15:33:24 <Zekka_> (using Evan's representation, that is)
15:33:28 <xplat> if the machine halts, the list will be finite
15:33:33 <Aruro> hm
15:33:33 <chrisdone> Aruro: maybe try updating your question from "why not X" to "how would X"
15:33:49 <Aruro> yes that too! chrisdone :)
15:34:22 <Zekka_> Aruro: You can define a similar representation o EvanR's like this
15:34:23 <Aruro> so making implementation like Evan did does not bring us far?
15:34:38 <Zekka_> data List a = NotNecessarilyInfinite [a] | DefinitelyInfinite [a]
15:34:51 <Aruro> yes, for example
15:34:55 <Zekka_> And then you can, being conservative about things, determine that some lists are definitely infinite
15:35:10 <Zekka_> But you can't determine that a list is *not* infinite, and you can't always determine that a given list is infinite
15:35:57 <Aruro> why i can not determine that list is infinite because of hardware? or IO?
15:36:00 <ReinH> Nothing stops me from defining wrong = DefinitelyInfinite []
15:36:12 <xplat> data List a = Finite [a] | PossiblyInfinite [a] | KindaInfinite [a] | ReallyInfinite [a] | ToInfinityAndBeyond [a] | InfinityOrBust (Stream a)
15:36:24 <Aruro> yes that is good list
15:36:30 <Zekka_> ReinH: This is true! It assumes that you are a nice person who will only create a DefinitelyInfinite for things that always, absolutely, totally, certainly produce infinite lists (always)
15:36:31 <Aruro> so now i can have length [1..] on it
15:36:40 <Zekka_> and will most of the time just create NotNecessarilyInfinite
15:36:46 <chrisdone> it's possible to define a type that is inherently infinite, but that's different
15:37:06 <ReinH> Aruro: You can't determine if a list is infinite because you can't execute an algorithm with an infinite number of steps
15:37:07 <EvanR> data Stream a = Stream a (Stream a) is nice because its definitely infinite, no messing around
15:37:14 <chrisdone> nod
15:37:41 <xplat> EvanR: unless there's a bottom
15:37:42 <Aruro> hm but length of list is not a computational question it is a question of its definition no?
15:37:42 <ReinH> Some structures are *never* infinite, but there's no way to know if a list has a [] constructor at some point you just haven't reached yet.
15:37:53 <ReinH> and some structures are *always* infinite
15:38:07 * EvanR throws bottom out with the bath water
15:38:27 <kadoban> Aruro: A list can be recursively defined though, so it's the same thing.
15:38:40 <EvanR> Aruro: some computations are not known to terminate, or to not terminate
15:39:00 <Aruro> so definition of list is equal to computing it in high theory?
15:39:03 <chrisdone> well, you can't use a method of determination whose number of steps grows with the size of the data structure's growth
15:39:25 <ReinH> Aruro: You asked for how to *determine* if a list is infinite, not how to define an infinite list.
15:39:46 <ReinH> It's quite easy to define things that you can't compute.
15:40:14 <Zekka_> Aruro: The discussion gets a little more complicated if you start talking about alternative representations of lists, but the short version is that for a linkedlist of length n, computing the length takes n steps
15:40:28 <xplat> > let doesNotCompute xs = tail xs in doesNotCompute [1..]
15:40:29 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
15:40:30 <Zekka_> So you can't determine that a list is infinite without performing an infinitely long computation
15:40:31 <ReinH> I have no problem defining the halting problem oracle.
15:40:36 <xplat> er.
15:40:48 <xplat> > let doesNotCompute xs = tail (doesNotCompute xs) in doesNotCompute [1..]
15:40:53 <lambdabot>  mueval-core: Time limit exceeded
15:40:53 <lambdabot>  mueval: ExitFailure 1
15:40:56 <ReinH> It's also quite easy to define pi
15:41:13 <xplat> ReinH: pi is what's called a computable real though
15:41:14 <Iceland_jack> Depends on the flavour
15:41:56 <ReinH> xplat: fsvo "computable".
15:42:00 <xplat> Omega is a noncomputable real you can define
15:42:23 <ReinH> xplat: but it's probably best not to equivocate.
15:42:31 <ReinH> An infinite list is computable using that definition as well btw
15:42:37 <ReinH> Since I can define (!! n) for any n
15:42:37 <Aruro> hm but i introduce a [1..] wouldnt i want to treat .. like an infinite natural numbers list constructor?
15:42:41 <Aruro> i=if
15:42:43 <ReinH> (define and compute)
15:42:48 <chrisdone> ReinH: is it ever best to equivocate? =p
15:42:54 <ReinH> chrisdone: shush you
15:42:59 <chrisdone> (now you answer: "maybe")
15:43:04 <chrisdone> =p
15:43:08 <Zekka_> Aruro: What you're basically suggesting is a list representation along the lines of data ArurosList a = Normal [a] | AllTheNaturalNumbersStartingFrom Int
15:43:11 <ReinH> chrisdone: Yes. Or perhaps no.
15:43:17 <chrisdone> :D
15:43:34 <Aruro> yes im suggesting that :) to treat normally the [1..] case
15:43:35 <xplat> Aruro: if you treat it as a constructor then you can define weird functions that act differently depending if you used [..] or defined an infinite list with identical elements directly
15:43:39 <Zekka_> Aruro: Which works for your specific case, but how do you generalize it? What if someone stuffs [1..] into the left side?
15:43:58 <chrisdone> perhaps you could define an opaque type
15:43:59 <Zekka_> You can't *always* determine that a list is infinite when it's really infinite
15:44:06 <Iceland_jack> Aruro: Are you okay with a user-defined [1..] to work differently from the built-in [1..]?
15:44:18 <Zekka_> (ignoring pedantry like list types that have no nil))
15:44:19 <ReinH> chrisdone: I believe those are called "abstract data types", not to be confused with the other ADT of course...
15:44:20 <chrisdone> which has a smart constructor a bit like unfoldr, and that would be a Stream
15:44:21 <Aruro> mm i dont know :)
15:44:28 <chrisdone> ReinH: =p
15:44:28 <Aruro> iceland_jack
15:44:50 <Aruro> my only wondering is if i start using [1..]
15:45:02 <Aruro> i immediately want it to be understandable to length function
15:45:09 <geekosaur> it won't be
15:45:11 <Aruro> otherwise i dont have  [1..]
15:45:22 <geekosaur> ???
15:45:35 <Zekka_> Aruro: I think your basic error here is you're assuming that if you can determine infinite length for some objects of infinite length, you can determine it for all objects of infinite length
15:45:36 <ReinH> Some lists do not have a length.
15:45:47 <ReinH> There are an infinite number of lists that don't have a length, in fact.
15:46:09 <ReinH> There are even an infinite number of lists of type [()] that don't have a computable length.
15:46:10 <Zekka_> Aruro: Are you going to special-case for instance "the list of the digits of pi"?
15:46:10 <chrisdone> data SomeList t a where
15:46:11 <chrisdone>   FiniteList :: [a] -> SomeList Finite a
15:46:11 <chrisdone>   InfiniteList :: Stream a -> SomeList Infinite a
15:46:33 <Zekka_> How about "the list of the digits of e"?
15:46:43 <joe9> Is there any haskell library function to squish this: "/test/test1/test2/../../../../../test" . I checked out "normalise" of System.FilePath but that does not remove the ".."
15:46:50 <chrisdone> then length (InfiniteList _) = Infinite
15:46:51 <chrisdone> cons :: (b -> (a,b)) -> b -> SomeList Infinite a
15:46:53 <chrisdone> or w/e
15:46:57 <Zekka_> chrisdone: Same problem, needless to say! Some FiniteLists will be infinite
15:46:59 <geekosaur> joe9: doing so is risky
15:47:12 <Zekka_> You can determine that an InfiniteList always has infinite length, but you can't determine that a FiniteList does
15:47:20 <HeladoDeBrownie> PotentiallyFiniteList*
15:47:21 <chrisdone> Zekka_: well, then you just s/Finite/Indefinite
15:47:23 <Aruro> yes but if .. would be constructor i could possible exclude unwated abusive cases? using pattern matching?
15:47:33 <HeladoDeBrownie> (:P)
15:47:34 <Aruro> or i would not be able to?
15:47:36 <geekosaur> joe9: how do you deal with symlinks to directories? how do you deal with Windows reparse points?
15:47:44 <joe9> geekosaur: I want an error if the ../../ go above the root. Hence, am wondering if there is a library that can do that.
15:47:55 <Zekka_> Aruro: Can you rephrase that? I don't quite understand
15:48:02 <geekosaur> backing up from either sends you someplace different from textual subsittution of /../
15:48:04 <joe9> geekosaur: oh, ok.
15:48:27 <joe9> geekosaur: makes sense. thanks.
15:48:35 <Aruro> i mean i could write like length [x..] = infinite
15:48:39 <Aruro> and that would be it
15:48:44 <ReinH> Aruro: It would not.
15:48:46 <ReinH> > let infinite n = n : infinite (n + 1) in take 5 (infinite 1)
15:48:47 <lambdabot>  [1,2,3,4,5]
15:48:53 <xplat> you could do List a = Nil | Cons a !(List a) | Swish (Stream a)
15:48:55 <ReinH> I did not use your ".. constructor".
15:49:17 <Zekka_> Aruro: ReinH's list has the same elements as yours -- however, you're back to the problem that you can't define a version of length that realizes your list is infinite
15:49:26 <xplat> that would be a List type that contained only lists that are definitely finite or definitely infinite
15:49:34 <chrisdone> xplat: i think with that form, Cons a (Swish …) would imply a non-infinite list
15:49:47 <chrisdone> xplat: which is why i added it in the type in my GADT =3
15:49:59 <xplat> but it would mean finite lists can't be lazy
15:50:17 <geekosaur> (actually reparse points are not guaranteed to do that, but they *could*. symlinks almost always will --- and the fact that bash tries to hide it just makes it even more confusing)
15:50:32 <xplat> chrisdone: Swish takes a Stream, not a List
15:50:39 <HeladoDeBrownie> I bet this would be easier if Haskell had distinct data and codata declarations
15:51:12 <HeladoDeBrownie> One notes that even data Nat = Zero | Succ Nat doesn't truly represent the naturals
15:51:20 <HeladoDeBrownie> (even ignoring _|_)
15:51:23 <ReinH> HeladoDeBrownie: indeed
15:51:42 <xplat> actually i should have done just List a = Finite !(SpineStrictList a) | Infinite (Stream a)
15:51:53 <Aruro> can i work always with lists which have a given length and treat list length as a special list element together with [] ?
15:52:11 <vanila> Aruro, stuff like that is possible but gets a bit difficult
15:52:14 <Zekka_> Aruro: You can, but this makes your lists much less powerful
15:52:14 <xplat> since otherwise you can distinguish different versions of the same infinite list by how many conses they start with
15:52:15 <ReinH> Aruro: Yes.
15:52:15 <chrisdone> xplat: yeah, that shifts the non-termination burden slightly
15:52:32 <Zekka_> You can't construct a list without knowing its entire length in advance, so you can't i.e. recursively define one
15:52:47 <Aruro> good point
15:52:58 <Aruro> no wait
15:53:05 <Zekka_> > let infinite n = n : infinite (n + 1) in infinite 1
15:53:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:53:08 <Aruro> there is a special length undefined
15:53:08 <xplat> anyway, with that (improved) datatype, yeah, you have to know at least whether your list is finite or infinite to even construct the first element
15:53:10 <Zekka_> You can't actually define this.
15:53:50 <Aruro> list length can be defined, undefined or infinite
15:53:55 <Aruro> seems complete
15:53:56 <xplat> and there are some lists you can't represent because it is not known whether they are finite or infinite
15:54:03 <hunter> how do i clean out cabal of all non essential packages?
15:54:07 <Aruro> undefined
15:54:09 <Zekka_> Aruro: If it's not tagged with length, then it still might be infinite
15:54:32 <Aruro> you mean undefined can be infinite
15:54:59 <xplat> Aruro: if you have 'undefined' then you get the problem of two distinguishable lists with all the same elements again
15:55:00 <Zekka_> Aruro: Yes, your latest version has the same problem as all these others have had
15:55:07 <chrisdone> hunter: rm your relevant ~/.ghc directory to remove all installed packages. ghc will re-initialize one next time you do something
15:55:14 <Aruro> interesting
15:55:16 <Zekka_> You can definitely determine that some infinite lists are really infinite, but you can't determine that all infinite lists are really infinite
15:55:27 <Zekka_> Which is what we've been trying to say for a little while, and you haven't seemed to understand
15:55:56 <Aruro> is this question has mathematical name or paper devoted to it? preferably titled - "How to define a list and be happy"
15:56:04 <xplat> if you can distinguish two lists that have the same elements, your type is not really a list type
15:56:07 <Zekka_> Aruro: This is just a flavor of the halting problem
15:56:29 <Aruro> which type is it then?
15:56:29 <ReinH> Aruro: Yes, it has quite a nice title: http://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf
15:56:39 <vanila> Aruro, data List a = Nil | Cons a (List a) should be fine
15:56:41 <Aruro> haaah :D ty ReinH :)
15:56:49 <Zekka_> You can write an algorithm that sometimes determine that a computation will definitely halt
15:56:53 <xplat> Aruro: a 'list plus some other junk' type
15:57:10 <Zekka_> But you can't determine that every computation that won't halt, won't halt
15:57:24 <Aruro> so halting problem prevents treating infinities in lists?
15:57:39 <Aruro> together with accepted length unbounded definition of list?
15:57:40 <Zekka_> Aruro: This is a case of it, yeah
15:58:06 <Aruro> so basically list is a function? if its length is undefined?
15:58:17 <Aruro> kinda IO?
15:58:18 <EvanR> you can also get around this by limiting the kind of language available to define the list
15:58:25 <Zekka_> What do you mean a list is basically a function? You can think of it as one if you want to
15:58:39 <EvanR> in which case you can ensure everything is finite, or specific things are definitely infinite
15:58:39 <Zekka_> :t foldr
15:58:40 <lambdabot> (a -> b -> b) -> b -> [a] -> b
15:58:46 <Aruro> i said wrong, i meant  list is an IO
15:59:07 <Aruro> operation which is not possible to predict at compilation
15:59:09 <Zekka_> You can think of a list as an (a -> b -> b) -> b -> b if you want (see the above -- it's a partial-application of foldr)
15:59:42 <Zekka_> Aruro: That's not what an IO operation is, really. You can pass any function values that aern't known at compile time
15:59:59 <Zekka_> do x <- readLn; print (x + 1)
16:00:13 <ReinH> How would values be "known" at compile-time in any sense?
16:00:16 <Zekka_> ^ (x + 1) is not known at compiletime,  but (+) is not an IO action
16:00:31 <Aruro> same as 2 is known, list is a data no?
16:00:53 <ReinH> What does it mean for a compiler to "know" about a value?
16:00:57 <Zekka_> I think Aruro thinks GHC does some kind of intensive static analysis to allow it to prove things about programs that just evaluation can't do
16:01:01 <Aruro> perhaps we should distinguish between defined lists and computed ones
16:01:09 <Gurkenglas> Zekka_, doesn't that only work for finite lists?
16:01:12 <Zekka_> for instance he seemed to think that [1..] would have a length of infinity because it's obvious
16:01:18 <ReinH> Aruro: How do you distinguish between defined lists and computed ones?
16:01:24 <xplat> Aruro: ah, you seem to have some concepts fused together in your head because of the languages you've used before
16:01:36 <Zekka_> Gurkenglas: In what sense? It nonterminates for infinite lists the same way a normal infinite list would nonterminate, right?
16:01:38 <Aruro> i did not use any language before :)
16:01:41 <Aruro> lol
16:02:05 <ReinH> Is xs = [1..] a "defined list" or a "computed list"?
16:02:07 <Aruro> so defined list can not be obscure
16:02:08 <Zekka_> > foldr (:) [] [1..]
16:02:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:02:10 <EvanR> adult language, viewer discretion advised
16:02:11 <Aruro> computed one can
16:02:16 <xplat> Aruro: 'literals', 'fully evaluated values'
16:02:19 <Aruro> [1..] defined
16:02:38 <xplat> also 'values'
16:02:43 <Gurkenglas> Hmm.
16:02:54 <Aruro> i think xplat knows more than me :)
16:02:56 <Aruro> yes that :)
16:03:03 <xplat> vs 'functions'
16:03:03 <ReinH> Aruro: what about xs = enumFrom 1
16:03:34 <xplat> functions are not the only place computation can happen
16:03:39 <Aruro> depends what is enumFrom is
16:03:47 <exio4> :t enumFrom
16:03:48 <lambdabot> Enum a => a -> [a]
16:03:51 <Zekka_> Aruro: It's a completely ordinary function
16:04:03 <Aruro> then enumFrom 1 is a defined list
16:04:07 <Aruro> not computed one
16:04:10 <EvanR> @src cycle
16:04:10 <lambdabot> cycle [] = undefined
16:04:10 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
16:04:29 <xplat> > cycle [1,2,3]
16:04:31 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
16:04:53 <ReinH> Aruro: I don't understand the distinction you are making between "defined" and "computed".
16:04:54 <Cr8> bitemyapp that time lib is working relative to "now"
16:05:25 <Aruro> same as between pure and not pure code
16:05:29 <Gurkenglas> > foldl' const 5 [1..]
16:05:33 <lambdabot>  mueval-core: Time limit exceeded
16:05:36 <ReinH> Aruro: That doesn't make sense either.
16:05:49 <Aruro> defined list is "visible" from start
16:05:52 <ReinH> What do lists have to do with unsafePerformIO?
16:05:56 <cojy> ReinH: well it does because cons in haskell is not pure, haskell is doing lots of mutation behind the scenes
16:06:12 <ReinH> cojy: ...
16:06:26 <exio4> nothing is pure behind the scenes
16:06:42 <chrisdone> exio4: or everything is =)
16:06:43 <Gurkenglas> > foldr (:) undefined [1..]
16:06:44 <Aruro> xplat you think cycle [1,2,3] is undefined list?
16:06:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:06:48 <ReinH> By that definition, nothing is ever pure, so there is again no distinction between pure and impure.
16:07:01 <Gurkenglas> Okay, makes sense. Cool, they're really isomorphic.
16:07:02 <chrisdone> for a sufficiently wide denotation
16:07:14 <bitemyapp> Cr8: https://twitter.com/bitemyapp/status/545005860657696768 I know. Thanks.
16:07:22 <Cr8> yeah
16:07:26 <bitemyapp> Cr8: I am too breezy in my use of my libraries.
16:07:26 <Cr8> saw that tweet just as I hit enter =P
16:07:29 <bitemyapp> Cr8: and need to read the damn comments.
16:07:30 <cojy> well that's not true because during compilation you can turn it into a pure value when not being held back by call-by-need
16:07:36 <bitemyapp> Cr8: OTOH, code is well commented.
16:07:40 <bitemyapp> Cr8: so I've got that going for me.
16:07:50 <Zekka_> chrisdone: I write 32-bit code, so I conceptualize my programs as Stateful operations on a tuple of (Byte, Byte, Byte... [about four billion], Byte)
16:08:01 * HeladoDeBrownie . o ( If the universe was coded in Haskell, does that mean everything is pure? )
16:08:41 * Gurkenglas invokes unsafePerformIO on the universe
16:08:46 <exio4> where is the source code of quantum mechanics?
16:09:00 <vanila> exio4: the schrodinger equation or something idk :p
16:09:05 <chrisdone> exio4: they're working on it
16:09:09 <EvanR> pure wave function, then IO collapse ;)
16:09:12 <Adeon> is there a memset()-like function somewhere in 'base' package foreign modules
16:09:31 <chrisdone> Adeon: for interfacing with C? there's one in Foreign.* somewhere iirc
16:09:42 <Adeon> yeah I'm trying to look for one but I can't find it
16:09:47 <Adeon> yes, interacting with foreign code
16:09:55 <HrafnA> The universe is actually one line of J
16:10:08 <Aruro> another aspect of laziness , it is possible to write a code which define an f function use it in main do block, but actually f will never get executed? and ghc has no errors?
16:10:08 <vanila> HrafnA, reminds me of game of life in APL
16:10:26 <chrisdone> Adeon: i seem to recall there is one like it, but named differently so that you can't find it
16:10:28 <Adeon> there is memcpy and memmove as copyBytes and moveBytes
16:10:32 <Adeon> hrmmm
16:10:35 <chrisdone> right
16:10:40 <athan> So GADTs turn into equality(ivalence?) constraints...?
16:11:03 * Adeon writes memset in Haskell
16:11:17 <chrisdone> Adeon: you can just import it from the ffi if you want it and it's not there
16:11:30 <vanila> athan, yeah
16:11:32 <chrisdone> foreign import ccall unsafe "string.h" memset  :: Ptr a -> a -> CSize -> IO (Ptr a)
16:11:35 <chrisdone> err
16:11:38 <chrisdone> stdlib.h
16:11:49 <vanila> and pattern matching will elim those equalities
16:11:53 <chrisdone> something along those  lines
16:12:08 <Adeon> okely dokely
16:12:28 <chrisdone> hidely hi, neighbor
16:14:16 <athan> vanila: Hmm, so constraints should solve superclass stuff, right? Just like normal?
16:14:47 <vanila> I don't  know what that is sorry
16:15:21 <heatsink> Constraints in GADT constructors mean you provide the class constraint when building it, and receive the class constraint when pattern matching
16:16:03 <athan> vanila: Wait, pattern matching doesn't keep the instances? Only on application?
16:16:32 <vanila> what instances?
16:17:13 <hunter> i came on here the other day asking about the overhead of the haskell runtime in executables
16:17:17 <hunter> how does that overhead scale?
16:17:27 <hunter> also frankly i didnt get a straight answer about what was causing it
16:18:42 <ReinH> hunter: causing what?
16:18:56 <hunter> the overhead in the size of executables
16:19:15 <ReinH> The size the binaries files take up on disk?
16:19:17 <ReinH> Or some other size?
16:19:24 <hunter> the disk size
16:19:29 <hunter> i couldnt think of a good way to phrase it
16:19:30 <hunter> to make that clear
16:19:49 <ReinH> hunter: Have you seen, e.g., http://stackoverflow.com/questions/12719207/why-are-haskell-ghc-executables-so-large-in-filesize and http://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary ?
16:19:54 <hunter> no
16:19:55 <ReinH> It's definitely known behavior...
16:20:09 <ReinH> cabal will strip the binaries, which helps somewhat.
16:20:11 <hunter> does it scale?
16:20:21 <hunter> the size inflation?
16:20:39 <ReinH> It scales with the number of Haskell libraries that need to be compiled in because GHC does not dynamically link them.
16:20:51 <dcoutts_> unless of course you use dynamic linking
16:21:07 <ReinH> The first answer here mentions this and mentions -dynamic, etc http://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
16:21:22 <dcoutts_> which cabal supports
16:21:34 <Aruro> how is [1..] defined internally?
16:21:44 <Aruro> @src (..)
16:21:44 <lambdabot> Source not found.
16:21:49 <hpc> enumFrom 1
16:21:58 <ReinH> Aruro: [x..] is syntax that is rewritten into fromEnum x
16:22:01 <hpc> @src Int Enum
16:22:01 <lambdabot> Source not found. That's something I cannot allow to happen.
16:22:03 <ReinH> it's called "syntactic sugar"
16:22:21 <Aruro> but how is it realized on the level of parser?
16:22:32 <dfeuer> I am tantalizingly close, but not quite there.
16:22:32 <Aruro> or i can write my own [1>>]
16:22:34 <dfeuer> HRM
16:22:49 <pharpend> dcoutts_: oh, thanks for all the help earlier. After hours of cabal hell, I finally got it all sorted out
16:23:04 <ReinH> Aruro: It is part of Haskell's syntax, yes.
16:23:06 <dcoutts_> pharpend: what was the ultimate cause?
16:23:11 <Aruro> ok
16:23:21 <pharpend> dcoutts_: portage has no idea how Haskell works
16:23:25 <Aruro> then how do we know its rewritten in fromEnum?
16:23:35 <ReinH> Aruro: Because the Haskell specification says so.
16:23:40 <Aruro> if there is no source
16:23:43 <Aruro> ook, clear
16:23:44 <dcoutts_> pharpend: ahh, upgrading/deleting things behind your back?
16:23:49 <vanila> There is source
16:23:56 <Aruro> where?
16:24:05 <vanila> GHC is free software
16:24:06 <pharpend> dcoutts_: I uninstalled darcs (which was the package with that insane dependency), and it thought it was a good idea to uninstall text and random while I was at it
16:24:11 <heatsink> @where Haskell report
16:24:11 <lambdabot> http://haskell.org
16:24:18 <ReinH> heatsink: not quite ;)
16:24:19 <dfeuer> I'm still fighting off-by-one sorts off errors, and I still have no definite sense of whether that's just a mistake or a deeper problem :-/
16:24:23 <indiagreen> @where report
16:24:24 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
16:24:24 <athan> vanila: Wait, I'm a dummy. I'm sorry :(
16:24:37 <ReinH> dfeuer: my theory is that off-by-one errors are always a deeper problem.
16:24:44 <pharpend> I eventually got it sorted out (there was a portage command I had to run).
16:25:06 <chrisdone> ReinH: yeah i put off-by-1 in the same category as boolean blindness
16:25:22 <exio4> chrisdone, what is "boolean blindness"?
16:25:31 <pharpend> ReinH: I just wanted to point something out. Listening to Haskell casts from about a year ago, you sounded like a newbie. Now, you're one of the more helpful people in the channel. It's very impressive
16:25:40 <ReinH> pharpend: :) thanks
16:25:41 <dfeuer> ReinH, well, I can start attacking them by adding a couple new datatypes so the compiler will barf on off-by-one, but yeah, the underlying problem is definitely my own insufficient understanding of the problem at hand.
16:25:57 <dfeuer> ReinH, in my own defense, it is a somewhat tricky problem.
16:26:03 <Aruro> why .. is part of syntax if its written using enumFrom, why it can not be defined as infix?
16:26:05 <chrisdone> exio4: short version: bools are too dumb and easy to make mistakes with. long version: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
16:26:09 <ReinH> dfeuer: Not sure why you need a defense. I'm not attacking you. ;)
16:26:39 <HeladoDeBrownie> Aruro, [1 ..] is very different from [1, 3 ..]
16:26:42 <pharpend> ReinH: this is irc. every statement is an attack.
16:27:03 <Aruro> mm
16:27:11 <ReinH> off-by-one errors are an indication that you are using the wrong abstraction :)
16:27:11 <dfeuer> ReinH, I'll try the type change I referred to. If I'm still a bit lost, I'm hoping maybe you'd be willing to help me a bit. But I don't know when this will happen.
16:27:17 <chrisdone> “As Conor McBride puts it, to make use of a Boolean you have to know its provenance so that you can know what it means.”
16:27:31 <vanila> That applies to everything,  not just booleans
16:27:39 <Aruro> how id [1,3 .. ] looks in enumFrom form?
16:27:41 <Aruro> is*
16:27:48 <HeladoDeBrownie> enumFromThen
16:27:49 <ReinH> dfeuer: Well, I'm not sure what you're working on. I'm happy to help, but right now I'm just making unhelpful general statements about off-by-one errors.
16:27:51 <HeladoDeBrownie> is what it uses
16:27:53 <Aruro> oh :)
16:27:55 <HeladoDeBrownie> @type enumFromThen
16:27:56 <lambdabot> Enum a => a -> a -> [a]
16:27:57 <chrisdone> pharpend: every statement is a defense, every reply is an attack
16:28:23 <chrisdone> pharpend: reminds me of Bob Ippito's blog on "charity" of audiences
16:28:33 * pharpend learned today that #haskell is actually filled with American politicians
16:28:42 <Aruro> why is it not realized as infix operator?
16:28:47 <HeladoDeBrownie> Aruro, so really the answer is they wanted to use the .. for all these different things and not all of them would be compatible with infix operators anyway
16:28:47 <dfeuer> ReinH, still working on that <*> for Data.Sequence. My current approach is to try to massage a 2-3 finger tree just enough to turn it into a 2-3 tree.
16:28:49 <Aruro> hoogle does not know (..)
16:29:08 <chrisdone> or maybe it was someone else
16:29:10 <Aruro> ok thank you
16:29:53 <heatsink> vanila, It's possible to have a "boolean" that tells you what information it carries.  For example, we could have (Bool, String) where the boolean tells you whether the String has useful data...
16:29:59 <chrisdone> ah it was paul chiusiano
16:30:00 <heatsink> or we could instead use Maybe String
16:30:01 <chrisdone> http://pchiusano.github.io/2014-10-11/defensive-writing.html
16:30:13 <chrisdone> ^ interesting post about how the internet makes us all defensive writers
16:30:15 <exio4> chrisdone, oh, I remember reading about something similar
16:30:29 <heatsink> where the "boolean" is built in to the choice between the Just and Nothing constructors
16:30:54 <heatsink> Patterns like the (Bool, String) example are common if your language doesn't support sum types.
16:31:02 <ReinH> dfeuer: ah
16:31:06 <exio4> heatsink, 2 * string isn't isomorphic to 1+string!
16:31:15 <vanila> heatsink, yeah and I see this applying to more than just booleans. E.g. map head . group works because I know group is emitting a list of nonempty lists
16:31:20 <athan> How do I sequence attoparsec parsers? S.T. `(string "foo") `then` (string "bar")` would only accept "foobar"?
16:31:31 <dfeuer> ReinH, I'm still not even sure it's possible to do it the way I'm trying to, but it's a very attractive idea.
16:31:38 <ReinH> heatsink: Also knows as Either String String ;)
16:31:45 <indiagreen> athan: *> or >>
16:31:45 <athan> or is `then` the actual control operator? (and `guards`, etc from HXT?)
16:31:50 <chrisdone> athan: applicative composition or monad composition
16:31:52 <ReinH> heatsink: because 2 * 1 = 1 + 1 ;)
16:32:03 <chrisdone> athan: string "foo" >> string "bar"
16:32:12 <vanila> you could switch to using group' :: Eq a => [a] -> [(a,[a])] and talk about 'empty blindness', but in programm you will generally have invariants in your code that aren't statically enforced
16:32:17 <vanila> programming
16:32:21 <athan> indiagreen: Thank you :)
16:32:29 <ReinH> chrisdone: don't call that monad composition waaaah
16:32:32 <heatsink> exio4: Sure, but sometimes people use a type that's larger than what they want.
16:32:34 <ReinH> chrisdone: :p
16:32:35 <Aruro> so in case [ a , generator ]   infix generator operator can not access a the first list element?
16:32:36 <athan> chrisdone: thank you too!
16:32:38 <dfeuer> ReinH, first I convert the 2-3 finger tree into one whose digits are all ones and twos. Then I apply a funky crushing squashing function to push the digits into the middle.
16:33:01 <dfeuer> Finally, I need to hope that when I get to the bottom, things are in the right configuration to work with.
16:33:01 <ReinH> Aruro: What do you mean by "infix generator operator"?
16:33:06 <athan> wait yeah that's application, specifically, right?
16:33:07 <Aruro> based on [1, ..] analogy
16:33:07 <dfeuer> Which I think they're not yet.
16:33:10 <athan> :t (>=>)
16:33:11 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
16:33:27 <Aruro> [1, .. ] goes to  [ a, generator ]
16:33:34 <heatsink> vanila, seems I misinterpreted your comment then.
16:33:48 <exio4> heatsink, true :P
16:34:07 <ReinH> Aruro: strictly speaking, there is only one way to construct a list: from the (:) and [] data constructors. In Haskell, things like [1,2,3] and [1..] and [1,2..] are *syntactic sugar* that correspond to various ways of building lists from these 2 constructors.
16:34:22 <heatsink> Yeah, it applies to lots of data.
16:34:46 <ReinH> Aruro: [1,2,3] is syntactic sugar for 1:2:3:[]
16:34:48 <ReinH> and so on
16:34:53 <ij> y
16:35:31 <Aruro> so can i have my own equivalent of  [1 .. ] ? like  [1__] ?
16:35:58 <Aruro> my question is can i defined my own  (..) operator which can be used same way
16:36:02 <ReinH> Aruro: No. The syntax of Haskell is not user-extensible.
16:36:08 <marchelzo_> How could I get something like this to work? "(+=) :: Num a => (b -> a) -> a -> State b ()" "v += x = modify $ \s -> s { v = (v s) + x }"
16:36:30 <Aruro> ok ty
16:37:02 <ReinH> marchelzo_: Are you aware of the lens library?
16:37:16 <marchelzo_> ReinH, Yeah, I just wanted to try writing a function like that for fun.
16:38:23 <geekosaur> sadly, record update syntax is not first class. in particular, as you found, field labels cannot be vatiables
16:38:30 <geekosaur> *variables
16:38:40 <chrisdone> ReinH: hm? you call it something else?
16:38:40 <marchelzo_> yeah, I didn't know that until just now when I tried.
16:38:59 <geekosaur> this is more or less what inspired lenses (and ultimately the lens package)
16:39:10 <ReinH> chrisdone: Well, for me monad composition is (<=<) or (>=>)
16:39:10 <geekosaur> but before that was fclabels and several others
16:39:46 <geekosaur> (lens kinda grew into an entire generics library on steroids and HGH)
16:39:50 <chrisdone> ReinH: i'd call that Kleisli composition
16:40:01 <ReinH> chrisdone: Ironically, I pronounce (>>) as "then", so string "foo" `then` string "bar" is almost already correct ;)
16:40:04 <marchelzo_> geekosaur, is there a simple way to implement that specific function without all the complexity of lens?
16:40:34 <glguy> What's HGH?
16:40:47 <geekosaur> haskell growth hormone, naturally
16:41:03 <geekosaur> (riffing on human growth hormone...)
16:41:09 <ReinH> geekosaur: ... we get it.
16:41:11 <ReinH> :p
16:41:16 <chrisdone> ReinH: yeah, i think (>>) as "then" is a usual pronunciation. the Prelude docs call >> and >>= composition, tho
16:41:22 <dfeuer> geekosaur++
16:41:26 <ReinH> chrisdone: prelude docs, stahp...
16:41:42 <geekosaur> marchelzo_, there's no truly simple way to do it. something like http://hackage.haskell.org/package/fclabels is lighter weight, but not really easier, than lens
16:41:58 <ReinH> Or lens-family?
16:42:10 <chrisdone> ReinH: stahp, stahp…
16:42:24 <ReinH> chrisdone: :p
16:42:29 <geekosaur> because it's ultimately the same thing; "lenses" in their various forms are the way around this problem
16:43:06 <chrisdone> fclabels is easier to grok
16:43:12 <vanila> marchelzo_, what do you want to do exactly?
16:43:12 <azazel_> Im new to haskell is there anywhere i should start
16:43:54 <mungojelly> yeah and is there a beginner/easy channel
16:44:06 <HeladoDeBrownie> azazel_, we tend to recommend Learn You A Haskell to newcomers
16:44:07 <ReinH> azazel_: Welcome! https://github.com/bitemyapp/learnhaskell is a good resource.
16:44:08 <HeladoDeBrownie> @where lyah
16:44:08 <lambdabot> http://www.learnyouahaskell.com/
16:44:10 <marchelzo_> vanila, Nothing. I'm familiar enough with lens to know that it has this exact function, but I just thought it would be fun to implement and then discovered it would be harder than I'd thought.
16:44:11 <HeladoDeBrownie> Also that
16:44:38 <azazel_> Thanks
16:45:22 <vanila> marchelzo_, I was asking in case I could give some suggestions
16:45:27 <chrisdone> geekosaur: what interested me about fclabels and functional references back in 2010 wasn't just easier update but making getters and setters
16:45:27 <searock> For the people who want to learn Haskell I recommend working through http://www.seas.upenn.edu/~cis194/lectures.html While reading LYAH
16:45:51 <ReinH> azazel_: If you're looking to get yourself a Chrismas present, Richard Bird published a Haskell book last month that is amazing: http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird-ebook/dp/B00O0RKGTO
16:45:52 <searock> The excersizes are a godsend, which is pretty much the only thing LYAH lacks.
16:46:25 <ReinH> *Christmas (or other seasonally appropriate gift giving excuse, for that matter)
16:46:45 <ReinH> The Kindle version is quite affordable compared to most textbooks as well
16:47:17 <ReinH> searock: Yes! Exercises are so important. (Bird's book has wonderful exercises with answers btw)
16:47:44 <marchelzo_> vanila, I wanted to write a function with the signature "Num a => (b -> a) -> a -> State b ()" that behaves like (+=) from lens but without using lenses. I don't think it's possible though.
16:48:03 <hunter> is there a good helm tutorial in existence?
16:48:16 <chrisdone> this 2009 version had composition of labels as part of its basic docs http://hackage.haskell.org/package/fclabels-0.4.0
16:48:36 <chrisdone> which i've no idea how to do with the lens package
16:49:15 <vanila> marchelzo_, the type signature doesn't make sense to me -could you describe what you want to do?
16:49:20 <geekosaur> afaik composition in lens is just (.) (or (#) which is flip (.))
16:50:07 <searock> ReinH: Yeah, currently working through the first week of the excersizes. I kept reading LYAH while barely excersizing the code I learned which got me nowhere.LYAH, RWH and other books are great references but one really got to program to learn.
16:50:25 <ReinH> marchelzo_: It's impossible to write a function with that type that behaves like (+=) from lens.
16:50:27 <marchelzo_> vanila, now that I think of it, the signature doesn't make sense to me either
16:50:32 <marchelzo_> yeah.
16:50:34 <vanila> good first step!
16:50:40 <ReinH> heh indeed!
16:51:09 <ReinH> searock: This is one of the reasons that I don't recommend LYAH any more, yeah
16:51:41 <ReinH> You can accurately judge a textbook (or similar) by the quality of its exercises.
16:51:47 <ReinH> And one that doesn't have any? Well...
16:54:17 <searock> ReinH: I do agree, the lack of excersizes really cripples the book. Having said that it simplifies things in a fantastic manner and is really easy to read. That is certainly a strength, and again it's great to use as a reference point. By the way, this is unrelated and you guys probably get this a lot but I love this language. Going from C# and Java to Haskell, it's amazing how "logic" works in this
16:54:19 <searock> paradigm. Stuff I do which I don't expect to work keep working. It's elementary, but it still feels great each time recursion works exactly as I wish.
16:54:38 <nshepperd> (+=) :: Num a => (b -> a, a -> b -> b) -> a -> State b ()
16:54:52 <vanila> can it be described with words?
16:54:59 <ReinH> searock: Indeed. It's nice to work in a language that expresses the curry-howard correspondence so directly
16:55:09 <nshepperd> you need a combination of a getter and a setter I guess
16:55:22 <vanila> well Lens has some clever trick to avoid that
16:55:40 <marchelzo_> nshepperd, yea, I suppose that would work
16:55:42 <vanila> I think it was known early on that just pairing up a getter and setter wouldn't be very nice
16:55:43 <ReinH> searock: Speaking of which, you might enjoy Dan Piponi's paper from The Monad Reader 6: https://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
16:56:27 <nshepperd> yeah lens does it with traversals and all instead of those pairs, which is smarter
16:57:47 <searock> ReinH: Thanks, I'll keep it bookmarked until I've finished the excersizes. Hopefully I can get side effects and IO within the week. I had to google curry-howard, but yeah. It's a blessing. By the way what Developing environment do you guys use? I use VIM and Syntastic at the moment, and it works great but just wanted to know what the preferred IDE for Haskell is..
16:58:53 <ReinH> searock: When I used vim I used http://haskelllive.com/environment.html, now I use emacs and https://github.com/chrisdone/emacs-haskell-config
16:59:09 <searock> Sweet, thanks!
17:02:16 <searock> ReinH: Much appreciated, just looking through Haskell Live and autocomplete is something I really am missing. Nice to find a way to get that feature into VIM. I have a habit of writing long function names..
17:07:38 <nshepperd> 'And most curiously of all - we see that within an ordinary textbook on logic is a secret hidden text on compiler writing and we only need to look through the Curry-Howard lens to reveal it!' reminds me of escardo's talk on getting free theorems about computability from topology textbooks
17:10:03 <ReinH> nshepperd: :)
17:16:05 <hunter> what terminal themes do you guys use
17:16:09 <heatsink> solarized
17:16:15 <hunter> fast response
17:16:33 <hunter> subquestion,which do you think looks the best with vims syntax highlighting for haskell?
17:16:53 <hpc> i like the putty default
17:16:53 <heatsink> I don't use vim with haskell
17:17:00 <hpc> with blue made a bit lighter
17:17:13 <hunter> hpc sounds the blue of solarized lighter?
17:17:24 <hunter> ignore the word sounds that was a typo
17:20:17 <aphorisme> hello! Can someone provide a running example for SDL2+OpenGL3.x? I've some issues with the libraries, running into seg faults. : /
17:21:48 <hunter> guys
17:21:57 <hunter> i just accidentally deleted my cabal.sandbox.config
17:22:16 <hunter> how do i recover access to the stuff i installed in that environment
17:22:32 <ReinH> hunter: you dun goofed :(
17:22:42 <hunter> actualy i think its ok
17:22:44 <hunter> i re-inited
17:22:48 <hunter> and since i hadnt written anything yet
17:22:55 <hunter> it just decided to use the folder that was already there
17:40:29 <hunter> what terminal do you guys use?
17:43:48 <jle`> aphorisme: you might have some luck in #haskell-game :)
17:43:55 <aphorisme> ah, thanks.  : )
17:44:17 <chrisdone> hunter: i try to minimize my time spent in a terminal so i don't care much
17:44:59 <Dashkal> rxvt-unicode-256color.  Going to switch at some point though.  Gets obnoxious having to copy a termcap file everywhere.
17:45:42 <hunter> Dashkal: why that?
17:45:57 <Dashkal> Specify which part the 'why' relates to?
17:46:06 <hunter> ive never heard of it
17:46:12 <hunter> so what about it makes you use it
17:46:23 <hunter> is that why theres so much confusion when i ask why questions here?
17:46:29 <hunter> because everyone thinks i know what im talking about
17:46:36 <hunter> and then thinks im questioning their opinion?
17:46:55 <Dashkal> I simply couldn't parse your question
17:47:18 <hunter> ok i think in some cases thats what happens though
17:47:21 <Dashkal> I like it because it behaves in a way I like.  Mostly minimal.  Has some cool extra features that I do care about.
17:47:31 <hunter> does it have tabs?
17:47:38 <hunter> and customizable colors?
17:47:43 <Dashkal> The downside is it uses the old termcap method of explaining how it works to terminal programs, which means the termcap has to be available on remote hosts.
17:48:03 <Dashkal> I think it has tabs, but I don't use them.  It does have free customization of color.
17:48:30 <Dashkal> The use case tabs are for I delegate to my terminal manager (tmux) or the window manager (xmonad)
17:48:49 <Dashkal> Mostly tmux.
17:48:51 <Iceland_jack> I also delegate them to Emacs + elscreen
17:48:53 <hunter> youre bad to the bone
17:48:53 <Dashkal> Tabs in xmonad are derpy.
17:48:56 <hunter> hardcore as they come
17:49:10 <Iceland_jack> I manage my tmux tabs through XMonad
17:49:18 <Dashkal> Meh.  I just have some rather custom desires, so gravatate towards tools that let me bend them to those desires.
17:49:34 <Dashkal> This workflow works for me.
17:49:36 <hunter> i wasnt mocking you
17:49:40 <hunter> i just think its cool
17:49:43 <Dashkal> Not feeling mocked.
17:49:49 <hunter> i hate the internet
17:49:53 <hunter> impossible to communicate tone
17:49:57 <Dashkal> Not so :P
17:49:58 <hunter> were becoming robots
17:51:04 <Iceland_jack> Is everyone becoming a robot?
17:52:17 <Dashkal> Reading the correct tone in a text-only medium takes some time.  And help from both sides.
17:54:58 <AshyIsMe> so the diagrams library is pretty fun
17:55:04 <AshyIsMe> i was messing around with the tutorial last night
17:55:22 <cmsmcq> what does it do?
17:56:31 <jle`> i wonder what definition the docs of Mathematica are using for "pure function"
17:56:36 <jle`> http://reference.wolfram.com/language/tutorial/PureFunctions.html
17:57:01 <jle`> from what it reads like, it sounds like they are describing what are called anonymous functions in haskell and other languages
17:57:11 <jle`> what sense of the word "pure" do they mean here
17:57:14 <jle`> ?
17:57:41 <heatsink> Sounds like anonymous functions
17:58:43 <jle`> but is this definition of "pure" used anywhere else?  or are they just pulling it out of nowhere
17:58:47 <heatsink> Not pure in the conventional sense
18:00:10 <jle`> oh, interesting http://mathematica.stackexchange.com/a/64624
18:00:27 <jle`> apparently this choice was written before the word "pure" became popular to describe nonsideffectufl functions
18:00:49 <jle`> so it really predates the now-common definition of "pure"
18:01:34 <AshyIsMe> cmsmcq: it's a simple 2d drawing api with an svg backend (and some other backends)
18:02:01 <AshyIsMe> circle 2 # fc red `atop` square 4  -- etc
18:03:23 <cmsmcq> SVG backend sounds attractive.
18:03:33 <jle`> i always thought that the word pure has been used to describe non sideffectful funtions since forever
18:03:52 <jle`> like in the days of euclid
18:12:35 <atomi> why does cabal give me cabal: unrecognized option `-j'
18:12:54 <atomi> when doing cabal install -j
18:14:20 <hiptobecubic> old cabal?
18:14:21 <atomi> hmmm maybe it's wrong version
18:14:38 <atomi> yeah
18:20:06 <codygman-> What should I use for generating a random sha1 hash?
18:20:15 <EvanR> "The garbage collector interferes with smooth performance. After Hugs and GHC are merged, this problem should not be noticeable." ;)
18:20:54 <athan> Is it possible to make a logical OR for constraints via DataKinds / ConstraintKinds?
18:20:58 <Iceland_jack> codygman-: A *random* hash?
18:21:26 <athan> where the tuple of constraints for a type signature is already AND
18:21:34 <Iceland_jack> You can use cryptohash
18:21:34 <Iceland_jack> @hackage cryptohash
18:21:34 <lambdabot> http://hackage.haskell.org/package/cryptohash
18:22:02 <Iceland_jack> codygman-: should be as simple as (hash "something" :: Digest SHA1)
18:25:40 <codygman-> What about if I want a random hash? What should the seed be? A random number?
18:26:23 <Iceland_jack> I'm not sure what you mean by a random hash, do you want a hash of a random sequence of bytes (ByteString) or a 512-bit random hash?
18:28:25 <codygman-> Iceland_jack: I have some files being uploaded by users. I guess I could just do "hash (uploadTimestamp)" couldn't I?
18:28:52 <Iceland_jack> What will you use the hash for?
18:29:13 <codygman-> for now, all the files uploaded by users will be in that directory so I need to avoid collissions.
18:29:48 <EvanR> i hope your hash function doesnt produce random results
18:30:31 <codygman-> actually I overthought this... I can just do the usual filename+timestamp
18:30:39 <EvanR> right
18:31:18 <Iceland_jack> I think I missed the conversation but it seems solved now
18:32:06 <codygman-> Iceland_jack: Yeah, I was being silly thinking I needed hashes to get collisionless filenames... instead of using tried/true filename from upload+timestamp
18:35:28 <EvanR> codygman-: are you adding a timestamp because you think there will be duplicate filenames for different files?
18:35:43 <EvanR> because timestamps might also be duplicated
18:36:53 <EvanR> do you want a hash of the file content?
18:42:43 <johnw> codygman-: if you're on UNIX, you can use the inode, it won't collide
18:43:33 <geekosaur> as long as you don't cross mountpoints (beware symlinks!)
18:43:39 <johnw> yes, true
18:43:48 <johnw> then mount device number + inode number
18:44:07 <EvanR> and dont remount
18:47:35 <codygman-> EvanR: Well, then what if two people upload the same file contents at the same time ;)
18:47:59 <codygman-> johnw: Oh, I can just use the mountpoint+inode number in the filename and it will always be unique?
18:48:11 <johnw> well, for that specific runtime environment
18:48:19 <johnw> not across reboots
18:48:28 <johnw> if you are generating the filenames, maybe use UUIDs then
18:48:55 <johnw> or hash the contents, since it doesn't matter if one person's upload overwrites another one
18:49:02 <EvanR> codygman-: well if they have the same content, they can share storage
18:49:19 <johnw> and if you're worried about SHA-512 collisions, don't
18:49:42 <johnw> that would be a completly theoretical worry
18:55:26 <codygman-> EvanR: good point ;)
18:55:55 <codygman-> johnw: Yeah.... hashing works ;)
18:56:52 <codygman-> Should I use cryptohash? I'm guessing it's actively maintained?
19:00:16 <johnw> i think that's what I last used
19:12:43 <athan> ...is there promoted `foldl`, `fmap`, etc. for DataKinda? o.O
19:12:55 <johnw> you use the singletons package
19:12:58 <johnw> http://hackage.haskell.org/package/singletons
19:13:03 <mhall> is there a way to index matrix/vector cells in the Linear package?
19:13:27 <mhall> or possibly to convert to Data.Vector?
19:22:05 * hackagebot hspec-server 0.2.2 - Test Framework for Server's status  http://hackage.haskell.org/package/hspec-server-0.2.2 (junjihashimoto)
19:22:10 <marchelzo_> Anyone have a nice way of doing the following with Parsec? I have a string like "4x-1/2x^2+9" and I want to parse it in chunks like: (4x) (-1/2x) (+9). sepBy ... (oneOf "+-") would work, but then I can't know which sign it was split on.
19:22:14 <gcganley> hey is there a place to tell if hackage is down or not
19:22:55 <johnw> gcganley: https://status.haskell.org
19:24:13 <gcganley> johnw: thank you
19:24:27 <athan> johnw: Thank you!!
19:26:39 <crobbins> here's an applicative/aeson question... i'm trying to create an instance of FromJSON using something like: fromJSON (Object o) = Rule <$> o .: "startDate" <*> o .: "endDate"
19:27:06 <crobbins> but dates need to be parsed, given a function: parseDay :: String -> Maybe Day
19:27:38 <crobbins> what's the best way to nest the applicatives to get the appropriate fail behavior on the Nothing case?
19:31:19 <Myrl> I broke ghc by deleting package.cache....
19:31:24 <Myrl> Why'd I even do that
19:31:55 <gcganley> Myrl: package.cache? is that in .ghc
19:32:18 <Myrl> gcganley: Yeah.
19:32:50 <gcganley> Myrl oh i delete that all the time just cabal update && cabal install cabal-install
19:33:05 <gcganley> then install all the stuff you need
19:33:35 <gcganley> although you should be using sandboxes if you are using cabal ;)
19:34:22 <gcganley> jonhw: I only just noticed status.haskell.org at the top of the IRC bar
19:34:52 <Myrl> gcganley: How?
19:35:20 <gcganley> Myrl: how do you use cabal sandboxes?
19:35:21 <Myrl> gcganley: Erm, actually, more like why.
19:35:32 <gcganley> Myrl: have you heard of cabal hell
19:35:36 <Myrl> gcganley: Nope.
19:35:38 <gcganley> its a very real place
19:35:41 <Myrl> I just started using ghci yesterday.
19:35:49 <johnw> I really wonder what cabal heaven looks like
19:35:55 <gcganley> Myrl: oh lol, welcome!
19:36:32 <Myrl> gcganley: Thanks.
19:36:40 <gcganley> johnw: cabal update takes a sane amount of time and all the packages install properly
19:36:53 <gcganley> Myrl: any reason to be interested in haskell?
19:37:05 <johnw> speeding up cabal update is not hard
19:37:34 <Myrl> gcganley: I guess it's because it's FP.
19:37:41 <johnw> use this instead: https://gist.github.com/5cae71e7e82312e0352d
19:37:43 <calvinx> I am a little confused about the do block syntax.  Why does this fail? http://lpaste.net/116652
19:37:48 <Myrl> And it takes some things which I don't like much about Lisp.
19:37:49 <gcganley> Myrl: what other languages have you used before
19:38:28 <calvinx> what I am trying to do is to print out some stuff in the stdout and after that return a json; in my Yesod Handler.
19:38:29 <heatsink> calvinx: Lines 5 and 6 are parsed as one statement because 6 is indented farther
19:38:29 <Myrl> gcganley: I've used Lisp, Lua and C.
19:38:45 <gcganley> Myrl: what dialect of lisp?
19:38:59 <calvinx> OOOOoooo
19:39:08 <Myrl> gcganley: Racket, mostly because I wanted to use Typed Racket afterwards.
19:39:37 <calvinx> heatsink: you are right. thanks
19:43:28 <gcganley> Myrl: racket seems nice, i used clojure
19:43:45 <glguy___> You can probably index them with:  \i -> preview (ix i)
19:44:09 <glguy_> view _y (V3 'a' 'b' 'c')     is 'b'
19:44:11 <mhall> hey guys, what method do you prefer to conditionally assign a variable in a 'where' or a 'let'? i guess you can write an if...else block, or else maybe write a lambda and call that? or can you use guard or case notation too?
19:44:29 <glguy_> preview (element 2) (V3 'a' 'b' 'c')   is 'c'
19:45:44 <gcganley> mhall: can you give us psudocode to understand what youre shooting for
19:46:03 <mhall> gcganley: 1 sec
19:46:09 <gcganley> mhall: mkay
19:46:39 <glguy_> do rawDate <- o .: "startDate"; parsedDate <- parseDate rawDate; ... ; return (Rule parsedDate ...)
19:46:53 <gcganley> Myrl: anywho what did you want from haskell. to learn FP or another language to learn for its practical side
19:47:47 <edwardk> geekosaur: (&) is flip ($), (#) is something else in lens =)
19:48:36 <benzrf> hm
19:48:39 <mhall> gcganley: something like this http://pastebin.com/g7JddGMe
19:48:39 <benzrf> > 3 # _Left
19:48:40 <lambdabot>  Could not deduce (Data.Profunctor.Choice p0)
19:48:40 <lambdabot>    arising from the ambiguity check for ‘e_13’
19:48:40 <lambdabot>  from the context (Data.Profunctor.Choice p,
19:48:45 <benzrf> :t (#)
19:48:46 <lambdabot> parse error on input ‘)’
19:48:50 <benzrf> u w0t
19:49:13 <gcganley> edwardk: is (&) lens specific?
19:49:24 <edwardk> currently. its going in Data.Function in 7.10
19:49:35 <edwardk> > _Left # 12
19:49:36 <gcganley> edwardk: nice
19:49:37 <lambdabot>  Left 12
19:49:50 <edwardk> (#) is used with a prism or iso to do 'construction'
19:49:55 <edwardk> > _Left . _Right # 12
19:49:56 <lambdabot>  Left (Right 12)
19:50:10 <gcganley> edwardk: is there any forum where i can see the progress of ghc and its libraries?
19:50:36 <edwardk> there is a ghc-devs mailing list, the trac, and the github repo for the main project
19:50:39 <gcganley> im always curious with 'whats next'
19:50:50 <edwardk> watching the trac is a good way to get a heads up on the status of bugs
19:50:56 <Myrl> I really forget that in xmonad, Windows+Shift+Q closes X.
19:51:10 <edwardk> watching phabricator is a good way to see all the minutiae of how the sausage gets made / code reviews, etc.
19:51:28 <gcganley> Myrl: i know, im so used to i3 that i close X all the time
19:52:12 <gcganley> edwardk: where do you find time to have a day job and contribute to the greater haskell community?
19:53:08 <Myrl> gcganley: Hahaha, turns out that I'm not the only one then. :D
19:53:27 <Myrl> gcganley: I decided to throw away i3 since I'm now learning Haskell.
19:53:44 <gcganley> Myrl: of course one could rebind them to i3 but that would be too clever
19:53:55 <gcganley> i3 like keybindings i mean
19:54:06 <Myrl> gcganley: True. That's too hard to do.
19:54:34 <gcganley> Myrl: i use vanilla xmonad just because i live in emacs for the most part
19:54:51 <Myrl> gcganley: That feeling. It's almost as if emacs itself is your WM.
19:56:02 <gcganley> Myrl: all kidding aside I only have to windows open, emacs and firefox/chrome (depending on how im feeling) and for the most part im in emacs with... something like 4 panes open
19:56:12 <gcganley> s/to/two/g
19:56:46 <gcganley> is there a sed implementation in haskell?
19:57:22 <marchelzo_> gcganley, Someone has a youtube series where they create exactly that
19:57:40 <marchelzo_> It's not very professional though
19:58:03 <marchelzo_> He's learning haskell as he makes it
19:58:52 <gcganley> marchelzo: all of my sed knowlege is on a by-need basis. i thought reading the source would give me a better understanding of whats going on. I'd like to learn something that edits text in a single line of code as well as sed or awk
19:59:52 <marchelzo_> oh well the same guy, Conner McDaniel, has videos where he explains in detail exactly how sed works.
20:00:01 <Myrl> gcganley: Do you have eyebrowse-mode in emacs? If you don't, you should get it, it's basically like workspaces.
20:00:26 <marchelzo_> It's a few videos each a few minutes but you'll learn a lot about sed
20:00:29 <gcganley> Myrl: no the only time i got super deep into emacs is for CIDER and haskell-mode
20:00:29 <Dongyancai> Hello, is it possible to just declear function in instance ... where , and implement elsewhere in the same source file?
20:00:51 <marchelzo_> Dongyancai, yes
20:01:34 <Dongyancai> marchelzo_: is there any example? I looked up, but did not found any.
20:01:55 <marchelzo_> it's exactly what you'd think
20:02:25 <marchelzo_> for example, "instance Monoid Int where { mappend = (+) }"
20:02:45 <marchelzo_> That uses (+) which is declared elsewhere to provide an implementation of mappend
20:03:01 <gcganley> Myrl: and i just use Ctr-x 3 and Ctr-x 2 and Ctr-x o to do all my moving around
20:04:20 <Dongyancai> so, by using another function do the real work and the function in where ... is just a `pointer`?
20:04:27 <edwardk> gcganley: giving up sleep helped
20:04:50 <ReinH> edwardk: Still haven't figured out how to do that :(
20:04:57 <Myrl> gcganley: Seems hard, I can't even properly tile my emacs.
20:05:07 <edwardk> gcganley: i also don't do much else beside code, travel to conferences, code some more, give a talk here and there, go back home, code for work on the flight, etc.
20:05:57 <marchelzo_> Dongyancai, conceptually you can think of it like that, I guess. Functions in Haskell are very much different than function pointers in C/C++, though.
20:06:08 <gcganley> edwardk: sorry if im getting to serious but are you happy with that lifestyle?
20:06:24 <Dongyancai> marchelzo_, thank you.
20:07:18 <benzrf> sounds delightful to me
20:07:24 <benzrf> :v
20:07:28 <edwardk> It works for me. I get to go all over the world and talk to folks about their problems and I have to constantly push myself to have fresh material because I hate giving the same talk twice, so it keeps it interesting, and the two things synthesize nicely.
20:08:26 <edwardk> On the other hand, ask me some time after I haven't just spent 24 hours in planes and airports flying back from australia. ;)
20:08:28 <gcganley> edwardk: i heard you were in australia earlier this month
20:08:31 <edwardk> Because right now I'm exhausted. =)
20:08:33 <danclien> edwardk: Is your talk or slides from YOW up somewhere?
20:08:42 <gcganley> oh hey theres my anser
20:08:46 <edwardk> danclien: the slides should be up in a day or two, the video will be online next month.
20:09:06 <gcganley> edwardk: do you want someone to sub the video?
20:09:07 <danclien> edwardk: Awesome! I kept seeing pictures of the slides. Curious to hear the whole thing. :)
20:09:44 <calvinx> what’s a simple code example of the usage of “>>=“ ?
20:10:19 <edwardk> I gave a version of my "functionally oblivious" talk for a general track which was a nice rebuttal to the notion that functional programmers don't care about performance, then for the keynote on the second day I talked a fair bit about how to maximize the number of problems you can pair with solutions in the presence of disheartening cognitive science
20:10:19 <edwardk> results about just how badly exponential the forgetting curve is.
20:10:39 <zwer> > getLine >>= putStrLn
20:10:40 <lambdabot>  <IO ()>
20:11:40 <gcganley> calvinx: new to haskell or new to monads
20:11:42 <edwardk> and I think I was able to drive home some good points about why we use abstraction as a tool to build upon and as a gateway to in some cases 40-70 years of pre-existing documentation rather, which is the opposite of using it as a tool for exclusion, but if we're not careful it can be.
20:12:17 <calvinx> gcganley: both. I am have been experimenting with haskell for the past week and trying to wrap my head around some concepts I have yet to fully grok.
20:12:52 <calvinx> zwer: so what does “getLine >>= putStrLn” do ?
20:13:11 <gcganley> calvinx: putStrLn
20:13:12 <edwardk> So overall, I'm pretty happy with the way the keynote went, especially from Brisbane on. (The first talk was a bit rough because I didn't know what the first day keynote talked about, because we were sold out and i didn't attend for fear of them running out of seating day 1, so I'd missed a few opportunities for effective rebuttal of a couple of functional
20:13:12 <edwardk> programmer myths)
20:13:22 <gcganley> puts the string onto the screen
20:13:38 <gcganley> and getLine gets the string from the screen
20:13:51 <calvinx> yup.
20:14:06 <calvinx> and what does >>= do ?
20:14:11 <gcganley> it basically reverses the action and you get the same string you started with
20:14:46 <calvinx> I don’t understand… http://lpaste.net/116656
20:15:07 <gcganley> (getLine >>= putStrLn) "hello"
20:15:18 <edwardk> calvinx: one way to think of >>= is as a 'sequencing' operator for IO. for other monads it can do different things, it denotes a dependency between what happens on the left and what happens on the right, but really its properties are very formally stated through the monad laws. it just captures a common recurring pattern we find throughout all sorts of
20:15:18 <edwardk> containers / effects / computations / trees / etc. in computer science.
20:15:23 <gcganley> :t (getLine >>= putStrLn) "hello"
20:15:24 <lambdabot>     Couldn't match expected type ‘[Char] -> t’ with actual type ‘IO ()’
20:15:24 <lambdabot>     The function ‘getLine >>= putStrLn’ is applied to one argument,
20:15:24 <lambdabot>     but its type ‘IO ()’ has none
20:15:26 <calvinx> http://lpaste.net/116657
20:15:27 <gcganley> woops
20:15:36 <edwardk> it is fairly painfully abstract, but you can always go back to the laws to reason with it
20:16:29 <calvinx> yea, I get the error on ghci as well, gcganely
20:16:33 <calvinx> *gcganley
20:16:38 <gcganley> calvinx: lets put it this way ive written countless instances of monad and i still dont understand it. you can get by pretty ok without groking it much
20:17:01 <calvinx> ok
20:17:20 <calvinx> but how do I get this getLine >>= putStrLn to work in one single statement (without manualy input)
20:17:25 <edwardk> a monad gives you return and >>= with some nice properties. return a >>= f = f a -- says that you can 'return' a value with no 'effects' and bind it to a function and you might as well have just applied the function its the same, m >>= return = m -- says that binding to return has no effect on what you've done.
20:17:29 <calvinx> *manual input
20:17:31 <gcganley> calvinx: not to say that i endorse my ignorance it is rather emabrissing but just so you dont feel alone
20:18:08 <edwardk> finally (m >>= f) >>= g ≡	m >>= (\x -> f x >>= ga)  -- says you can 'build functions' and group things up into little bits of reusable componentry without changing the meaning, you can gather up a sequence of operations in the monad into one function and call it.
20:18:22 <edwardk> er
20:18:33 <edwardk> (m >>= f) >>= g ≡	m >>= (\x -> f x >>= g)
20:19:07 <edwardk> so ultimate a monad is _anything_ that gives return and >>= that satisfies those laws
20:19:28 <edwardk> IO is one example, in that case >>= sequences operations and lets you build bigger programs with side effects from smaller ones
20:19:33 <calvinx> ok. I caught of glimpse of this understanding via this blog post http://www.dustingetz.com/2012/04/07/dustins-awesome-monad-tutorial-for-humans-in-python.html
20:19:56 <calvinx> but I still don’t uderstand it in terms of the getLine and putStrLn example above
20:19:58 <edwardk> [] is another example, in that case >>= takes each element of the list on the left, feeds it to the function on the right and flattens the resulting lists down into a single list to meet the laws.
20:20:16 <shachaf> calvinx: That monad tutorial seems to make a lot of the usual mistakes. :-(
20:20:45 <gcganley> calvinx: most people use the IO monad as an example because when people coming from other languages when they hear monad they think of haskell's IO system. I did at least. But monad can be used for any data structure. anything from Tree structures to the Maybe type
20:20:47 <edwardk> Maybe is another example, in that case >>= is given either Just a or Nothing on the left, in the first case it can call your function a -> Maybe b  on the right and take the answer, in the other case you have Nothing, and no 'a' to call the function with so all you can do is give it back.
20:21:04 <gcganley> i like the Maybe monad or even the Either monad
20:21:18 <gcganley> helped me understand it
20:21:19 <calvinx> yes. I actually understand the Maybe and Either monads
20:21:23 <calvinx> but I don’t understand the IO monad.
20:21:28 <edwardk> some monads feel more like containers, others feel more like computations (IO), or threading state, or syntax for embedded languages, etc.
20:21:39 <calvinx> I am having a lot of difficulties with Yesod because I don’t understand the IO Monad.
20:21:49 <Myrl> Hmmmm...
20:21:52 <gcganley> then there are monads like STM and i leave those alone
20:22:01 <dfeuer> Ping ski.
20:22:02 <Myrl> Wait, Maybe and Either are considered monads?
20:22:05 * hackagebot plot-lab 0.0.1.9 - A plotting tool with Mathematica like Manipulation abilities  http://hackage.haskell.org/package/plot-lab-0.0.1.9 (sumitsahrawat)
20:22:11 <gcganley> Myrl: oh hell yeah.
20:22:17 <shachaf> I think the fact that these things are monads isn't particularly important.
20:22:31 <tnks> calvinx: what don't you understand?
20:22:41 <tnks> I can give it a stab if you like.
20:22:43 <gcganley> whats important is what (>>=) and return do and how to use them
20:22:48 <calvinx> I have no clue what example Yesod code are doing when I see them
20:22:50 <Myrl> I should tally how many times I accidentally close X instead of a window.
20:23:09 <calvinx> for instance, what does getLine >>= putStrLn mean?
20:23:11 <gcganley> Myrl: do pushups everytime you close X
20:23:14 <calvinx> I know what’s putStrLn
20:23:17 <calvinx> I know what’s getLine
20:23:21 <dfeuer> I also tend to think it's more useful to think of things as functors than as monads.
20:23:21 <shachaf> IO is a type which happens to be a monad. It's worth understanding it independently, and then Monad just happens to be a convenient API for doing things with it.
20:23:21 <Myrl> gcganley: Lol.
20:23:22 <calvinx> but how does >>= fit in?
20:23:26 <tnks> calvinx: IO is just a type that indicates that there's a side effect that results in a value.
20:23:38 <kwf> Unexpected category theory -- Ezra Pound says: "Relations between things are more important than the things themselves."
20:23:53 <gcganley> kwf: exactly
20:23:59 <calvinx> So how do I understand the expression “getLine >>= putStrLn” ?
20:24:14 <calvinx> why is there a >>=?
20:24:18 <calvinx> what does it do in this context?
20:24:23 <tnks> calvinx: my recommendation is always to follow the types.
20:24:40 <tnks> > :t (>>=)
20:24:40 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:24:40 <gcganley> calvinx: do you know what >>= means in plain english? its pronounce 'bind'
20:24:48 <dfeuer> calvinx, "follow the instructions in getLine to obtain a result; apply that result to putStrLn to get some more instructions; follow those instructions"
20:24:51 <tnks> what's the syntax?
20:24:52 <calvinx> OOOOOooo
20:24:57 <Guest21000> dont try to pronounce haskell ;)
20:25:01 <johnw> no "> "
20:25:01 <calvinx> getLine binds to putStrLn !
20:25:02 <danclien> :t (>>=)
20:25:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:25:04 <johnw> in that case
20:25:10 <gcganley> calvinx: bingo baby
20:25:13 <calvinx> Now, *that* makes sense.
20:25:17 <tnks> calvinx: do you see that signature?
20:25:23 <calvinx> yes.
20:25:25 <gcganley> calvinx: we are talking IO monad now
20:25:27 <calvinx> I see the signature
20:25:34 <tnks> replace "m" with "IO" t osee it specialized for your type.
20:25:35 <dfeuer> This is the first time I've ever seen someone "get it" when they hear the word "bind".
20:25:43 <calvinx> Isn’t this <- “bind” as well?
20:25:52 <calvinx> so what makes “<-“ different from “>>=“ ?
20:25:54 <dfeuer> calvinx, <- is syntactic sugar.
20:25:55 <gcganley> Monad IO => IO a -> (a -> IO b) -> IO b
20:25:59 <Geekingfrog> I have a syntax question: is it possible to define a sub-function inside another one? Typically, the tail-recursive version. Example: tossNCoins gen n = tossNCoinsAcc gen n acc where ....
20:26:01 <dfeuer> It's not an operator at all.
20:26:02 <tnks> :t (getList >>=)
20:26:03 <lambdabot>     Not in scope: ‘getList’
20:26:03 <lambdabot>     Perhaps you meant one of these:
20:26:03 <lambdabot>       ‘getLast’ (imported from Data.Monoid),
20:26:10 <tnks> :t (getLine >>=)
20:26:11 <lambdabot> (String -> IO b) -> IO b
20:26:12 <kwf> do x <- foo; y <====> foo >>= \x -> y
20:26:14 <calvinx> dfeuer : syntactic sugar of?
20:26:18 <gcganley> calvinx: inside do notation? nothing
20:26:25 <dfeuer> calvinx, kwf just answered
20:26:37 <calvinx> AHHHHHHHH
20:26:38 <dfeuer> do notation itself is syntactic sugar.
20:26:39 <tnks> calvinx: so I applied an argument, and it specialized the type to IO and String -- see that?
20:26:39 <calvinx> thanks kwf
20:26:45 <dfeuer> And <- is part of that.
20:26:52 <kwf> calvinx: No problem!
20:27:00 <dfeuer> <- is also part of the very closely related list/monad comprehension notation.
20:27:00 <calvinx> “do x <- foo; y” is equivalent to “ foo >>= \x -> y"
20:27:12 <calvinx> shucks
20:27:13 <gcganley> calvinx: yes
20:27:13 <albeit> Geekingfrog: Yes, use where/let
20:27:17 <calvinx> I was so so confused.
20:27:22 <tnks> calvinx: yeah, it helps to know what do sugar desugars to.
20:27:23 <calvinx> all the arrows pointing everywhere. LOL.
20:27:47 <Kaidelong> I can't figure out how to get "cabal repl" to give me a ghci isntance with limited heap size
20:28:08 <kwf> calvinx: another aspect of do-notation you should know is that "do x; y" desugars to "x >> y" which is equivalent to "x >>= \_ -> y"
20:28:17 <Kaidelong> I'm helping someone who has a nasty heap exhaustion bug so this is pretty important
20:28:17 <dfeuer> edwardk, do you think you could take a glance at the idea in https://github.com/haskell/containers/issues/73#issuecomment-67229602 and tell me if you think it's relatively likely or relatively unlikely to be possible, and if you have any hints for making it happen if the former?
20:28:20 <calvinx> what does the “;” mean?
20:28:31 <dfeuer> calvinx, ; is syntax too.
20:28:34 <Kaidelong> well, not heap exhaustion, heap exhaustion would be better than what actually happens
20:28:45 <gcganley> calvinx: sugar for CRLF I belive
20:28:46 <calvinx> separate line where the second line doesn’t execute until the previous line executes?
20:28:48 <dfeuer> calvinx, ; separates ... certain things.
20:28:49 <kwf> calvinx: Haskell has optional explicit semicolons. It's the same as a line-break with proper indentation.
20:28:59 <Kaidelong> you cannot put RTS options in your .ghci
20:29:02 <calvinx> Right Right.
20:29:44 <calvinx> I need to write “do x <- foo; y” is equivalent to “ foo >>= \x -> y" and "do x; y" desugars to "x >> y" which is equivalent to "x >>= \_ -> y" and get that in my head
20:29:55 <calvinx> it’s everywhere in Yesod and I am completely lost.
20:30:20 <dfeuer> calvinx, lambdabot can be helpful:
20:30:30 <dfeuer> @undo do x <- foo; y
20:30:31 <lambdabot> foo >>= \ x -> y
20:30:44 <kwf> calvinx: so notice that this means that "do x; y" is equivalent to "do _ <- x; y"
20:30:45 <dfeuer> @undo do x; y
20:30:45 <lambdabot> x >> y
20:30:52 <calvinx> Wow. that’s a cool trick!
20:31:11 <calvinx> Is that built into ghci as well or it is a lambdabot specific trick?
20:31:20 <Welkin> lambdabot
20:31:29 <calvinx> Very nice!
20:31:29 <gcganley> calvinx: lambda bot but i bet someone has ported it
20:31:37 <dfeuer> calvinx, it's a lambdabot thing. You can actually install lambdabot locally, in ghci, but I don't know how.
20:32:17 <kwf> calvinx: And if you compile with -fwarn-unused-do-bind, you'll get a warning every time you "do x; y" when x has a return type of something other than ()
20:32:19 <Welkin> @undo do x <- getLine; y <- getLine; return (x, y)
20:32:19 <lambdabot> getLine >>= \ x -> getLine >>= \ y -> return (x, y)
20:32:24 <calvinx> very nice gents, it’s been really really helpful
20:32:32 <gcganley> seems lambdabot is on hackage
20:32:35 <calvinx> I think I made one small little step to understanding haskell today
20:32:40 <calvinx> many more steps to go...
20:32:49 <kwf> calvinx: How do you know all of us are gents?
20:33:01 <dfeuer> @ask edwardk Do you think you could take a glance at the idea in https://github.com/haskell/containers/issues/73#issuecomment-67229602 and tell me if you think it's relatively likely or relatively unlikely to be possible, and if you have any hints for making it happen if the former?
20:33:02 <lambdabot> Consider it noted.
20:33:02 <calvinx> ah ok.. thanks people :D
20:33:37 <kwf> calvinx: You're welcome. :)
20:33:49 <edwardk> dfeuer: i don't remember if there is an invariant like dangerous pointers not being next to dangerous pointers to prevent underflow forcing underflow that might complicate your desired construction
20:34:18 <Kaidelong> @src maximum
20:34:18 <lambdabot> maximum [] = undefined
20:34:18 <lambdabot> maximum xs = foldl1 max xs
20:34:30 <dfeuer> edwardk, the only invariants are encoded in the types. I'm just not sure if I'm going to get to quite where I want quite *when* I want to get there.
20:34:44 <Kaidelong> *why*
20:35:07 <gcganley> Kaidelong: why what
20:35:14 <Kaidelong> foldl1
20:35:20 <gcganley> :t foldl1
20:35:20 <lambdabot> (a -> a -> a) -> [a] -> a
20:35:21 <gcganley> :t foldl
20:35:23 <lambdabot> (b -> a -> b) -> b -> [a] -> b
20:35:28 <Kaidelong> I saw a blog post about how slow haskell was
20:35:29 <gcganley> see the difference
20:35:36 <Kaidelong> because maximum of a list is really slow
20:35:38 <dfeuer> edwardk, that's been what I've been banging my head against. I'm trying to turn a 2-3 finger tree inside out, and somehow I seem to end up one or two levels off from where I expect when I get it done.
20:35:49 <Kaidelong> apparently, it's because maximum is implemented with foldl
20:36:08 <Kaidelong> http://kaushikghose.wordpress.com/2014/09/26/maximum-1-1e6/
20:36:09 <gcganley> Kaidelong: meh im not sure if foldl1 has the same perf issues as foldl
20:36:18 <dfeuer> gcganley, yes, it does.
20:36:23 <dfeuer> foldl' does not.
20:36:44 <dfeuer> foldl1, as I recall, is actually relatively bad, compared to foldl.
20:36:48 <gcganley> yeah its due to a known issue with things building up to to lazyness
20:36:55 <edwardk> dfeuer: http://comonad.com/reader/wp-content/uploads/2010/04/Finger-Trees.pdf is an old presentation i gave on finger trees
20:36:58 <gcganley> which is often a good thing
20:36:59 <dfeuer> foldl is often not terrible, depending on how well it gets analyzed.
20:37:04 <dfeuer> edwardk, I already saw that :-)
20:37:07 <edwardk> its correct except for one bang pattern i had in there that is wrong
20:37:11 <gcganley> but not in the case of [1..1e6]
20:37:31 <Welkin> foldl' shouldn't be any faster than foldl
20:37:37 <Welkin> it uses less memory
20:37:50 <shachaf> Kaidelong: I'd guess that -O2 would catch that.
20:37:57 <Welkin> unless the evaluation of thunks takes significant cpu cycles
20:37:59 <dfeuer> edwardk, I hate slides. Is there something in particular that you think you cover better than Hinze and Paterson?
20:38:03 <shachaf> Using less memory means being faster. :-)
20:38:09 <dfeuer> I can jump to just that spot.
20:38:15 <shachaf> Kaidelong: So this person should compile with -O2.
20:38:35 <shachaf> (It certainly makes a big difference.)
20:38:35 <edwardk> The Redundancy and Slowing Down slide showing the transitions between safe and dangerous were what i was thinking of
20:39:00 <dfeuer> Welkin, it's much worse than that. When the strictness analysis fails, you end up with not only allocation but residency going way up.
20:39:01 <edwardk> i also spend a fair bit of time building up to finger trees by showing the naive version that is a real 2-3 tree you are kinda talking about
20:39:50 <gcganley> good night all
20:40:06 <dfeuer> edwardk, oh, okay. If I paste my current drafty experimental stuff, do you think you might be able to tell me what you think the implications are, and/or what I'm doing horribly stupidly?
20:40:40 <edwardk> dfeuer: kinda buried up to my elbows in something at the moment
20:40:56 <edwardk> long trip, just getting back, lots of fires to put out
20:41:18 <edwardk> i'd be happy to do so when i have more breathing room
20:41:29 <waxjar> is it possible to make for example an Even type, to restrict what input could be given to a function?
20:42:11 <dfeuer> edwardk, thanks. When you get a chance, it's at http://lpaste.net/5456003960924012544 and the bit that has me scratching my head is why I seem to need data Zipping a = Zipped (Node (Node a))  rather than maybe just = Zipped (Node a)
20:43:19 <dfeuer> Note that RigidFingerTree is a "real" 2-3 finger tree as opposed to the extra-flexy Hinze-Paterson ones.
20:46:09 <edwardk> yeah RigidFingerTree is what i talk about to set up the flexible Hinze-Paterson ones in my slides
20:47:22 <dfeuer> So I'm sort of trying to go backwards, so I can map over a 2-3 tree representation of the original finger tree once I get down to the appropriate level.
20:54:25 <Welkin> hm
20:54:40 <Welkin> foldl' is a bit faster than foldl
20:55:50 <Kaidelong> not a bit
20:55:59 <Kaidelong> if you're working with a large list, it can be a lot faster
20:56:23 <Kaidelong> actually I think it's actually asymptotically faster once you consider the overhead needed to manage building the thunk
20:56:30 <Kaidelong> foldl becomes n^2 rather than n
20:56:45 <Welkin> what about foldr?
20:56:57 <dfeuer> Kaidelong, yeah, it's major space change. But sometimes GHC is smart enough to strictify or fuse it.
20:57:11 <dfeuer> Welkin, foldr is perfectly fine when used with a properly lazy function.
20:57:18 <Kaidelong> foldr can be constant space if the operation its using is lazy enough
20:57:20 <nitrix> Out of curiosity, is there something in haskell that actually has an undefined behavior?
20:57:29 <dfeuer> nitrix, yes.
20:57:39 <nitrix> I'm aware of potential race conditions with threads. Any other examples?
20:57:41 <dfeuer> Arithmetic overflow is undefined in the Report.
20:57:45 <jle`> some things are defined to be undefined but that's kind of funny
20:57:51 <dfeuer> But GHC gets very specific about it.
20:57:55 <jle`> actually defined to be bottom but yeah
20:58:02 <dfeuer> o.O
20:58:07 <jle`> hooray for conflation of language
20:58:08 <Kaidelong> basically the rule of thumb is
20:58:20 <jle`> some things are defined to be bottom in the report, i believe
20:58:21 <Kaidelong> use foldl' for strict operations
20:58:26 <Kaidelong> foldr for lazy operations
20:58:29 <Kaidelong> foldl *never*
20:58:46 <Welkin> I stopped suing foldl a while ago and only use foldl' (or foldr)
20:58:55 <Kaidelong> I'm not aware of even contrived cases where foldl is better than foldl'
20:58:57 <dfeuer> Kaidelong, what if I want a lazy left fold over an Array or a Seq, huh?
20:58:59 <Welkin> but foldl can be used with a lazy function
20:59:02 <nitrix> What's bad with foldl vs foldr ?
20:59:07 <nitrix> Isn't just a different order?
20:59:09 <dfeuer> Kaidelong, edwardk here will be able to give an example.
20:59:16 <Welkin> nitrix: foldl' vs foldl
20:59:19 <Kaidelong> foldl still forces the whole thing to be evaluated
20:59:24 <dfeuer> nitrix, lists are not symmetrical.
20:59:30 <dfeuer> But folds aren't only for lists!
20:59:37 <jle`> nitrix: foldl' vs foldr is different tools for different situations.  foldl' vs foldl is, always use foldl'.
20:59:41 <Kaidelong> right, for other data structures, foldl might make more sense
20:59:42 <edwardk> dfeuer: still buried, not helping me get unburied =P
20:59:59 <jle`> are we making foldr Foldable now too? :P
21:00:03 <shachaf> dfeuer: Volunteering other people to help in IRC isn't very nice.
21:00:05 <edwardk> jle`: yes
21:00:10 <dfeuer> edwardk, right. I'll try to let you dig your way out.
21:00:14 <jle`> wait, really?
21:00:16 <shachaf> Kaidelong: There are certainly contrived and not-so-contrived cases.
21:00:19 <jle`> in prelude?
21:00:21 <edwardk> jle`: yes.
21:00:28 <jle`> for 7.10?"
21:00:31 <edwardk> jle`: yes.
21:00:36 <mmachenry1> When is 7.10 due out?
21:00:36 <jle`> oh
21:00:50 <edwardk> mmachenry1: the first release candidate will probably be out in a week or so
21:00:55 <Kaidelong> anyway the implementation of maximum in the prelude is definitely... not smart
21:00:56 <jle`> :O
21:00:59 <edwardk> mmachenry1: the actual release will take a fair bit longer
21:01:00 <mmachenry1> Oh wow. Cool.
21:01:02 <shachaf> > foldl (\x y -> y) (error "empty") [1,2,undefined,3]
21:01:04 <lambdabot>  3
21:01:05 <shachaf> > foldl' (\x y -> y) (error "empty") [1,2,undefined,3]
21:01:06 <lambdabot>  *Exception: Prelude.undefined
21:01:10 <shachaf> Kaidelong; ☝
21:01:15 <edwardk> shachaf: thanks
21:01:17 <dfeuer> The real answer is "when it's ready". There have been some blips in the release process :-/
21:02:05 <Kaidelong> > foldr (\x y -> y) (error "empty") [1,2,undefined,3]
21:02:06 <lambdabot>  *Exception: empty
21:02:07 <shachaf> Kaidelong: I agree that many Prelude functions would be better implemented with foldl', but very often GHC can figure this sort of thing out with -O2.
21:02:18 <lpvb> how am I supposed to install xmonad with stackage? It looks like the stackage authors only want it to be installed project local
21:02:39 <Kaidelong> shachaf: but a beginner opens GHCi and what they see is that maximum is slower than maximum in python
21:02:42 <dfeuer> 7.10 has a lot of good stuff coming, both in the compiler and the libraries, but that's made it hard to clean everything up properly to actually get it out.
21:02:43 <Kaidelong> and they get discouraged
21:03:23 <Kaidelong> it doesn't become a minor issue because a person who knows to compile with -O2 doesn't suffer from it
21:03:51 <dfeuer> Kaidelong, who cares so much about maximum?
21:03:53 <Welkin> slower than in python?
21:03:56 <Welkin> are you sure?
21:04:04 <Welkin> python is slow
21:04:14 <Welkin> unless you use a special compiler
21:04:23 <Kaidelong> Welkin: http://kaushikghose.wordpress.com/2014/09/26/maximum-1-1e6/comment-page-1/#comment-334
21:04:27 <jle`> i wouldn't be too surprised if foldl is slower than python
21:04:31 <Kaidelong> oh oops
21:04:39 <Kaidelong> it links you to my comment
21:04:41 <Kaidelong> just scroll up
21:05:20 <mmachenry> What's the best tutorial on when to use strict in Haskell both in data types, function parameters, and application?
21:05:53 <Welkin> hahaha
21:06:08 <edwardk> mmachenry: well the long version of it is to read Chris Okasaki's purely functional data structures, and use thunks when you can count how many things will accumulate in a position in the data structure ;)
21:06:13 <Welkin> that guy in the blog post was introduced to haskell by reading the typeclasses chapter in LYAH
21:06:17 <Welkin> oh boy
21:06:20 <Welkin> what a problem
21:06:46 <edwardk> the short version is 'if you only ever do small things to a value like bump/decrease a counter' make that strict
21:07:06 <mmachenry> edwardk: Not sure what you mean by "use thunks when you can count how many things"
21:07:08 <Kaidelong> hahahah let's laugh at beginners who are interested in Haskell and try it because they do what seems reasonable and things don't work as they expect for reasons that aren't even good reasons
21:07:14 <shachaf> Well, in particular "if you do strict things to a value", I think.
21:07:24 <mmachenry> Do you mean the lazy thunks that Haskell makes for me or my own lambdas?
21:07:35 <jle`> are we going to change lambdabot's @src text file when 7.10 comes out
21:07:40 <shachaf> E.g. if you're consing onto a list, that's fine, but if you're consing onto Data.Sequence or Data.Map, that's better with foldl'
21:07:54 <Kaidelong> @type max
21:07:55 <lambdabot> Ord a => a -> a -> a
21:07:56 <jle`> @src mapM
21:07:57 <lambdabot> mapM f as = sequence (map f as)
21:07:58 <jle`> wroooooong
21:08:00 <Kaidelong> Mmm
21:08:03 <Kaidelong> I guess
21:08:08 <Kaidelong> for some instances of Ord
21:08:16 <jle`> @src forM
21:08:17 <lambdabot> forM = flip mapM
21:08:20 <Kaidelong> foldl1 might theoretically work better than foldl'
21:08:23 <jle`> hm  i think that's still right
21:08:26 <edwardk> consider data Set a = Bin Int (Set a) a (Set a) | Tip   -- here the Int is just the count of children below you in the tree. if you don't support infinite sets then you should consider making it strict. every time you mutate the tree you'd otherwise accumulate another thunk in the chain that was just going to add to or decrease the value
21:08:33 <Kaidelong> I am wondering though
21:08:39 <Kaidelong> is this worth the hassle
21:08:43 <edwardk> when you finally looked at it, it'd be 'replaying' the chain of operations since the dawn of time more or less
21:08:50 <Kaidelong> when the strict version is *almost always* what people actually want
21:09:06 <edwardk> but each step was something that was a simple arithmetic operation
21:09:11 <jle`> for me it's usually not the strict version
21:09:14 <edwardk> you might as well have _done them_ rather than accumulated them
21:09:42 <Welkin> Kaidelong: I was laughing because the only thing he read was typeclasses which OOP people seem to love
21:09:55 <jle`> most of the time i'd rather have things be lazy than strict, and when things are better strict, i annotate them
21:09:56 <edwardk> if the answer is fixed sized or bounded and i'm going to do an unbounded amount of work with it, i tend to make it strict
21:09:59 <mmachenry> edwardk: Sure that makes a lot of sense. I have used strict data declarations that way.
21:10:02 <calvinx> I don’t understand why a function like this: “allPlus2 xs = do x <- xs; return (x + 2)” would work like map
21:10:05 <Kaidelong> that's not really what he said
21:10:18 <mmachenry> I was hoping there was some nice source for this sort of thing.
21:10:23 <jle`> calvinx: what part don't you understand? :)
21:10:31 <Kaidelong> he said that after he read the chapter on typeclasses, he became very interested in Haskell
21:10:41 <calvinx> why is “do” so magical that it can make every element in the list xs get added to 2
21:10:46 <mmachenry> Perhaps it's the yet-to-be-released book that ReinH and Chris Forno will convince someone to write on day :)
21:10:46 <Myrl> Well, turns out that my idea of Monads was very, very, very far off.
21:10:49 <jle`> calvinx: it's not magical
21:10:56 <jle`> it's just syntactic sugar
21:10:56 <shachaf> calvinx: do isn't magical
21:10:59 <Welkin> I found it ironic that he started with such a topic
21:11:11 <jle`> @undo do x <- xs; return (x + 2)
21:11:13 <lambdabot> xs >>= \ x -> return (x + 2)
21:11:17 <jle`> see, it's just normal functions
21:11:19 <Kaidelong> typeclasses are a pretty neat feature IMO, they remind me of aspect oriented programming
21:11:26 <shachaf> calvinx: You can ask: Why is "map" so magic, when you write "map (\x -> x + 2) ..."?
21:11:36 <jle`> calvinx: do you know about typeclasses?
21:11:38 <mmachenry> Kaidelong: Really? Huh. How?
21:11:38 <Kaidelong> I don't think it's too awful of a topic to get excited about
21:11:42 <calvinx> I understand “map"
21:11:48 <dmj`> I'm blanking, how do I get the name of a record in Haskell ? data A = A { x :: Int, b :: String } would return just "A"
21:11:51 <calvinx> it’s mapping a function to every element in the list :D
21:12:03 <shachaf> calvinx: In the case of lists, this is like a fancy version of map.
21:12:09 <jle`> you can use typeOf if A is typeable
21:12:12 <calvinx> yes jle` type classes is about assigning behavior to types
21:12:22 <dfeuer> shachaf, how do you cons onto a Map?
21:12:23 <jle`> calvinx: not *exactly*
21:12:24 <Kaidelong> mmachenry: they let you define operations that talk about particular aspects of a type and then compose them together from many locations in your code
21:12:28 <shachaf> calvinx: "do { x <- y; ... }" means "concat (map (\x -> ...) y)"
21:12:28 <jle`> you can think of it as a method of overloading
21:12:38 <Kaidelong> like we don't make a new Int for giving it orderings like OrdInt
21:12:41 <jle`> the Num class lets every type implement its own version of (+)
21:12:44 <Kaidelong> that's a subclass of Int
21:12:51 <Kaidelong> we just define what Ord means for Int
21:12:56 <jle`> the Monad typeclass lets different types implement their own versions of (>>=) and `return`
21:12:58 <mmachenry> Kaidelong: I see.
21:13:03 <jle`> for [], (>>=) = flip concatMap
21:13:07 <jle`> and return x = [x]
21:13:17 <jle`> so let's look again at the desugaring...
21:13:27 <jle`> xs >>= (\x -> return (x+2))
21:13:34 <jle`> for lists, (>>=) = flip concatMap
21:13:36 <jle`> so that is
21:13:46 <jle`> concatMap (\x -> return (x+2)) xs
21:13:52 <jle`> for lists, return x = [x]
21:13:54 <jle`> so that is
21:13:56 <shachaf> calvinx: (So it's fancy in the sense that you can "return multiple elements".)
21:14:03 <jle`> concatMap (\x -> [x]) xs
21:14:18 <jle`> calvinx: can you see how that is `map` from there?
21:14:22 <jle`> or do you want to go further
21:14:28 <mmachenry> edwardk: The meetup is tomorrow, isn't it?
21:14:28 <dfeuer> @pl xs >>= \x->return (x+2)
21:14:28 <lambdabot> (2 +) `fmap` xs
21:14:35 <calvinx> > :t concatMap
21:14:37 <lambdabot>  <hint>:1:1: parse error on input ‘:’
21:14:38 <edwardk> yep
21:14:44 <edwardk> 6-7 little lightning talks
21:14:45 <jle`> @src concatMap
21:14:45 <lambdabot> concatMap f = foldr ((++) . f) []
21:14:46 <edwardk> should be fun
21:14:48 <mmachenry> Sweet.
21:14:48 <dmj`> jle`: do you know?
21:14:53 <edwardk> mine'll be short
21:14:56 <jle`> how unuseful, heh
21:14:59 <jle`> concatMap f xs = concat (map f xs)
21:15:07 <calvinx> o
21:15:08 <mmachenry> edwardk: I almost tried to get one ready but I'm not really prepared.
21:15:09 <jle`> dmj`: if A is Typeable, you can use show . typeOf
21:15:14 <jle`> calvinx: so do you see what concatMap does?
21:15:20 <dmj`> jle`: sweet, thanks
21:15:22 <edwardk> mmachenry: no worries. i probably have ~5 minutes worth of material to talk about
21:15:25 <jle`> it maps the function, then concats the result
21:15:31 <calvinx> yes but it’s so many steps of thinking all compressed into one line
21:15:33 <mmachenry> edwardk: I'm hoping to give a demo of my project as a little CUFP-ish talk for the group.
21:15:34 <calvinx> gosh...
21:15:49 <jle`> calvinx: so what would concatMap (\x -> [x]) xs    do?
21:15:57 <edwardk> mmachenry: sure. when you are ready just ping me and/or joshcough
21:16:04 <mmachenry> Yeah will do.
21:16:14 <jle`> sorry, it was actually
21:16:18 <dfeuer> concatMap = foldMap id, I believe.
21:16:21 <calvinx> returns a list
21:16:23 <jle`> concatMap (\x -> [x + 2]) xs
21:16:31 <calvinx> applies the function and returns the list
21:16:55 <jle`> > concatMap (\x -> [x+2]) [5,7,9]
21:16:56 <lambdabot>  [7,9,11]
21:17:27 <calvinx> > map (+2) [5,7,9]
21:17:27 <lambdabot>  [7,9,11]
21:17:28 <calvinx> lol
21:17:30 <calvinx> same.
21:17:44 <Welkin> concat :: [[a]] -> [a]
21:17:51 <jle`> so, to recap: xs >>= (\x -> return (x+2))  ===>  concatMap (\x -> return (x+2)) xs  ==> concatMap (\x -> [x+2]) xs
21:17:55 <jle`> and from there you can see :)
21:18:03 <calvinx> my gawd.
21:18:05 <jle`> the trick is that (>>=) and `return` are "overloaded"
21:18:11 <calvinx> I am getting brain freeze
21:18:13 <jle`> so for every type, they have different implementations
21:18:13 <dfeuer> Alllllso, consider list comprehension notation instead of do notation.
21:18:39 <ogion>  /join ##crypto
21:18:45 <jle`> and for lists, xs >>= f = concatMap f xs, return x = [x]
21:18:57 <dfeuer> calvinx, don't worry. >>= and return do about the same thing for sequences as they do for lists!
21:27:34 <a2c> hi, does anyone know of a way to source a variable number of list comprehension variables or do something like this in the list monad?
21:28:23 <jle`> a2c: can you give an example of what you want to do?
21:28:40 <jle`> you can juse as many variables as you want
21:28:43 <a2c> the specific problem I’m trying to solve is to generate lists of n integers that satisfy a certain property
21:29:03 <dfeuer> a2c, the more specific you can be, the more likely that our answers will be appropriate.
21:29:32 <dfeuer> Good night, everybody.
21:29:42 <dmj`> dfeuer: good night !
21:29:45 <jle`> good night dfeuer
21:29:55 <a2c> a string of n balanced parantheses can be written as a string of n integers. integer e at position i represents an open paran followed by e close parens
21:30:08 <dmj`> a2c: is this homework?
21:30:19 <dmj`> a2c: or are you on xmas break
21:30:28 <a2c> no, just a problem that caught my interest
21:30:42 <a2c> dmj`: and yes, break
21:31:28 <dmj`> a2c: what have you tried so far
21:31:42 <codygman-> Anyone know how to fix this issue? I'm guessing I'm either using persistent wrong or snaplet-persistent. I asked in #snap but it's not so busy and I can't go to sleep until I'm finished. lol, :/ code:http://lpaste.net/116658
21:32:03 <a2c> I can get correct answers by manually writing out the list comprehensions, but I don’t know how to generalize
21:32:27 <jle`> a2c: give us what you have so far :)
21:32:45 <heatsink> Maybe give examples for length 2 and 3
21:33:03 <dmj`> codygman-: can you specify the module? ownerId Snap.Snaplet.Auth.SnapAuthUser
21:33:07 <dmj`> in the TH ?
21:33:11 <dmj`> er QQ
21:33:20 <a2c> i.e., for n = 3, [(a, b, c) | a <- [0..1], b <- [0..2], c <- [0..3], sum [a,b,c] == 3, sum [a, b] <= 2]
21:34:02 <a2c> that gives me all of the tuples that I want, and it’s easy to see how you can generalize the idea, but I don’t know how to do so in haskell =[
21:34:09 <heatsink> What is the constraint sum [a,b] <= 2 for?
21:34:39 <a2c> the string 120 represents () ()) ( which is not a valid string [parens unbalanced]
21:35:28 <codygman-> dmj`: Trying that
21:36:02 <a2c> to convert the string lists to actual strings I wrote this function: printParens (x:xs) = "(" ++ concat (replicate x ")") ++ printParens xs [is there a more elegant way of sharing code on here?]
21:36:34 <matematikaadit> @@ a2c @where lpaste
21:36:34 <lambdabot>  a2c http://lpaste.net/
21:37:27 <heatsink> Can you describe the problem in a divide and conquer way?  For a list of length L, if the first N elements are like this, then the last N elements must be like that...
21:37:30 <lpaste> a2c pasted “convert int strings to BP strings” at http://lpaste.net/116659
21:37:45 <heatsink> last L-N elements
21:38:41 <matematikaadit> @letpaste 116659
21:38:43 <lambdabot>  Defined.
21:38:56 <matematikaadit> > printParens [1,2,3]
21:38:57 <lambdabot>  "()())()))"
21:39:30 <heatsink> a2c: You can turn each Int to a separate string and concat them all
21:40:25 <a2c> heatsink: that would be fine in the printParens function, but as far as generating the integer lists goes I don’t see an application
21:40:29 <dmj`> codygman-: any luck?
21:41:38 <codygman-> dmj`: It got rid of all but one, which I think is from the code being generated by TH. lpaste: http://lpaste.net/116658
21:41:53 <heatsink> a2c: It's not clear to me what the general form is.  If you can describe what you're doing in that way, you can implement it as a recursive function.
21:41:56 <a2c> > map printParens [[a, b, c, d] | a <- [0..1], b <- [0..2], c <- [0..3], d <- [0..4], sum [a,b,c,d] == 4, sum [a,b] <= 2, sum [a,b,c] <= 3]
21:41:57 <lambdabot>  ["(((())))","((()()))","((())())","((()))()","(()(()))","(()()())","(()())()...
21:42:26 <heatsink> > concatMap (\n -> '(' : replicate n ')') [1,2,3]
21:42:28 <lambdabot>  "()())()))"
21:42:39 <a2c> a way to express the above list comprehension for general integer n is what I’m looking for
21:42:47 <jle`> ah i see
21:43:07 <jle`> that's interesting
21:43:18 <a2c> sorry, maybe I should have just said that earlier. still new to this channel
21:44:03 <heatsink> I see that the nth element should be in the range [0..n+1]
21:44:06 <matematikaadit> a2c: what is the base case, n = 1 ?
21:45:14 <heatsink> the sum up to the nth element should be less than n+1, and the total should be l
21:45:38 <matematikaadit> let say, you wanna a function: generate :: Int -> [[Int]]
21:46:10 <jle`> > inits [x,y,z]
21:46:12 <lambdabot>  Ambiguous occurrence ‘x’
21:46:12 <lambdabot>  It could refer to either ‘L.x’, defined at L.hs:182:1
21:46:12 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.x’,
21:46:17 <jle`> did someone really define x
21:46:21 <jle`> @undefine
21:46:21 <lambdabot> Undefined.
21:46:24 <jle`> > inits [x,y,z]
21:46:25 <a2c> heatsink: that’s correct. matematikaadit : here
21:46:25 <lambdabot>  [[],[x],[x,y],[x,y,z]]
21:46:33 <a2c> > map printParens [[a] | a <- [0..1], sum [a] == 1]
21:46:34 <lambdabot>  Not in scope: ‘printParens’
21:46:45 <a2c> oh. well, the list comprehension I gave is the base case anyway
21:46:46 <heatsink> > foldr (+) [y, z]
21:46:46 <matematikaadit> @letpaste 116659
21:46:47 <lambdabot>  Ambiguous occurrence ‘y’
21:46:47 <lambdabot>  It could refer to either ‘L.y’, defined at L.hs:153:1
21:46:47 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.y’,
21:46:47 <lambdabot>  Defined.
21:48:22 <jle`> you can probably use inits and then map (\xs -> sum xs <= length xs) to check for sums
21:48:39 <dmj`> codygman-: you're defining SnapAuthUser somewhere in the Dogs file
21:48:55 <heatsink> a2c: You can break the problem down into subproblems, such as taking a list shorter than what you want and finding everything you can append to it.
21:50:10 <a2c> dmj`: inits doesn’t give all of the combinations that need to be checked?
21:50:32 <a2c> heatsink: interesting idea, seeing where that goes
21:50:43 <codygman-> dmj`: Yeah, it's because of the mkPersist... now I see why they used "persistFileWith".
21:51:14 <heatsink> a2c: If you have a list [x, y] and you're building a list of length 4, what numbers can you append to it?
21:52:03 <dmj`> codygman-: so authEntityDefs contains SnapAuthUser ?
21:52:06 * hackagebot system-filepath 0.4.13 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.13 (MichaelSnoyman)
21:52:08 * hackagebot system-fileio 0.3.16 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.16 (MichaelSnoyman)
21:52:51 <dmj`> codygman-: why do you need to include those during generation?
21:52:58 <a2c> heatsink: [z] such that x + y + z <= 3 in this case, which will give us what we want assuming we have all of the valid [x, y] lists
21:54:14 <codygman-> dmj`: I need to create the authEntityDefs and my custom entityDefs in the right order, which runMigration does if you ++ the migrations together. The problem is when I call mkPersist Dogs.SnapAutherUserId is created
21:55:48 <heatsink> a2c: So [1, 0] ==> [[1, 0, 0], [1, 0, 1], [1, 0, 2]]
21:56:35 <a2c> right. and when you’re appending the last element it changes from <= to ==
21:56:49 <heatsink> You can write a function that does that.  It takes a list with N elements and the target length L, and returns all the valid lists with N+1 elements
21:56:59 <dmj`> codygman-: doesn't the error just say `SnapAuthUser`
21:57:07 <a2c> heatsink: gotcha. thanks for the help!
21:57:48 <dmj`> codygman-: I think what's happening is that Snap.Snaplet.Auth.Backends.Persistent is already generating SnapAuthUser, but your call to share [..] authEntityDefs .. generates it again
21:58:03 <brianpWins> I’m looking at a haskell homework question: The expression “Add (Val 1) (Val 2)” is a value of the datatype (multiple choice here). I don’t understand the question. What should I look for here?
21:58:08 <codygman-> dmj`: Correct... alright.. so for some reason things are working now
21:58:09 <dmj`> codygman-: can you remove the call to authEntityDefs ?
21:58:17 <dmj`> codygman-: did you remove it?
21:58:36 <codygman-> dmj`: Yes, I did remove... accidentally :)
21:58:49 <dmj`> codygman-: cool :)
21:58:54 <codygman-> but it is removed now
21:59:09 <dmj`> vundebar
21:59:18 <dmj`> merry christmas
22:00:02 <codygman-> dmj`: well it's not fixed, I need authEntityDefs
22:00:18 <codygman-> as they have to be migrated before my other data types
22:01:01 <codygman-> Oh, I found this: https://github.com/yesodweb/persistent/issues/116
22:01:24 <heatsink> brianpWins: The expression stands for a Haskell value, and it has a type.  You should use the types of And and Val to determine what type the expression has.
22:01:35 <dmj`> codygman-: boo :( just use acid-state it's easier
22:02:19 <brianpWins> heatsink: is there a way to bring those into scope? if I do :t Add it just yells back at me
22:03:00 <heatsink> Those are not standard Haskell library types.  They are probably defined as part of the homework.
22:03:30 <brianpWins> wouldn’t that be nice =/
22:03:33 <heatsink> I mean, they are not standard Haskell library data constructors.
22:04:05 <brianpWins> likely we’re supposed to abstract our way through the question. The idea we’re given anything is far fetched lol
22:06:34 <brianpWins> The multiple choice is also all with pipes. I’ve never seen that before
22:06:50 <brianpWins> choice 1: data Expr = Add | Val | Int
22:06:57 <brianpWins> I’ve never seen a type with pipes
22:07:04 <brianpWins> This class is the worst.
22:07:06 * hackagebot path-pieces 0.1.5 - Components of paths.  http://hackage.haskell.org/package/path-pieces-0.1.5 (MichaelSnoyman)
22:07:52 <codygman-> dmj`: I ended up fixing it, looks like the example gets around it by having two share instances
22:08:07 <dmj`> codygman-: did you have to use undecideable instances?
22:08:07 <codygman-> dmj`: the startup I'm making this for might not like needing that much ram ;)
22:08:40 <codygman-> nope, no undecideable instances
22:09:05 <srhb> brianpWins: It just means that Expr can be constructed by three different data constructors
22:09:17 <srhb> brianpWins: So Add :: Expr, Val :: Expr, Int :: Expr
22:09:37 <srhb> brianpWins: But consider that none of those constructors take an argument, so it would be difficult to construct a value like Val 1
22:09:53 <dmj`> codygman-: if you need auth, I'd use json web tokens, it's the new thing. Instead of storing sessions on the server you just compute a hash. http://jwt.io. Personally I'd roll my own auth from scratch with the scrypt pkg, then you can define your own userId's and roles, etc.
22:09:59 <srhb> brianpWins: Does that make sense?
22:10:22 <brianpWins> Yes and no. it helps
22:10:30 <srhb> brianpWins: Heh. :P Part of the way at least.
22:10:55 <srhb> brianpWins: Perhaps consider the canonical list example. data List a = Nil | Cons (List a)
22:10:58 <dmj`> codygman-: acid-state is basically a type-safe redis, with a transaction log instead of periodic snapshots
22:11:13 <srhb> brianpWins: Meaning: A list consists either of Nil (empty list) or a Cons cell with a List of a
22:11:30 <srhb> Oops
22:11:36 <srhb> data List a = Nil | Cons a (List a)
22:11:38 <dmj`> codygman-: and way more data structure choices
22:11:59 <srhb> brianpWins: Now I can make a list of Int like this: Cons 1 (Cons 2 (Cons 3 Nil))
22:12:18 <brianpWins> ohhhhh
22:12:24 <brianpWins> I think i understand that
22:12:36 <srhb> Great. :) Notice how we use List a to recursively define the datatype.
22:12:51 <srhb> This should help you choose the correct answer.
22:14:01 <codygman-> dmj`: all that sounds awesome and fun... but I have a day job and I'm already behind on this side freelancing project for this startup. acid-state is totally in ram memory though, right?
22:17:38 <dmj`> codygman-: yes
22:18:03 <dmj`> codygman-: but you can distribute the state amongst different machines, and use space-efficient data structures
22:19:27 <brianpWins> So I got the answer wrong still
22:19:43 <srhb> Ok, what did you answer?
22:20:04 <brianpWins> the correct answer was: data Expr = Add Expr Expr | Val Int
22:20:23 <srhb> Yes, but it's more giving to consider why your answer was wrong. :-)
22:20:35 <brianpWins> i answered: data Expr = Add | Val | Int
22:20:55 <brianpWins> Assuming Add took the values of Val or Int
22:21:03 <srhb> brianpWins: So notice in the value, Add takes two arguments
22:21:16 <srhb> Add (Val 1) (Val 2)
22:21:38 <srhb> In your example answer, Add is nullary, just like our Nil constructor (empty list)
22:23:08 <brianpWins> I clearly don’t get it
22:23:10 <brianpWins> at all
22:23:17 <srhb> brianpWins: Which part is confusing you?
22:23:34 <brianpWins> I would assume that something in a similar fashion like: Node (Leaf 1) (Leaf 2) would have a similiarly constructed answer
22:23:44 <brianpWins> but the choices available look nothing like the correct answer from the last question
22:23:46 <srhb> It would, but there Node takes two arguments as well
22:23:50 <srhb> And Leaf takes one
22:24:00 <srhb> So it's quite similar.
22:26:32 <srhb> in data Foo = MkFoo Int, MkFoo is a function that takes an Int as an argument and gives you a value of type Foo. In data Bar = MkBar, MkBar IS of type Bar.
22:26:36 <srhb> This seems to be what's confusing you.
22:26:58 <a2c> heatsink: still here?
22:27:44 <heatsink> yes
22:28:33 <lpaste> a2c pasted “balanced parens” at http://lpaste.net/116664
22:28:48 <brianpWins> It might be. I can see what you say when you give it by example. I can’t map it to the questions the same way though. Especially where the questions were essentially identacle and have completely different answers
22:28:52 <brianpWins> in my eyes
22:28:57 <a2c> heatsink: dedicating that solution to you =] how to load it?
22:28:58 <brianpWins> I don’t see their differences
22:29:21 <srhb> brianpWins: If you have 15 minutes we can take it to a private conversation and I can show you how to deduce the correct answer to that question.
22:30:11 <brianpWins> srhb: Can I possibly take you up on it shortly? HW has a deadline =/
22:30:15 <srhb> Sure thing.
22:30:21 <heatsink> @letpaste 116664
22:30:21 <lambdabot>  .L.hs:160:37:
22:30:22 <lambdabot>      Not in scope: ‘append’
22:30:22 <lambdabot>      Perhaps you meant one of these:
22:30:29 <a2c> !! sorry i forgot that function
22:30:43 <brianpWins> srhb: thanks
22:31:13 <lpaste> a2c revised “balanced parens”: “No title” at http://lpaste.net/116664
22:31:24 <a2c> @letpaste 116664
22:31:25 <lambdabot>  Defined.
22:31:45 <a2c> > map balancedParens [1, 2, 3]
22:31:47 <lambdabot>  [["()"],["(())","()()"],["((()))","(()())","(())()","()(())","()()()"]]
22:32:56 <a2c> heatsink: thanks again for the inspiration @ the append function, and thanks to everyone else who chipped in too!
22:33:27 <heatsink> Glad to help.
22:34:29 <Welkin> what's with Traversable?
22:34:36 <srhb> Welkin: Eh?
22:34:36 <Welkin> how is traverse any different from fmap?
22:34:54 <srhb> Welkin: It's also Foldable.
22:34:56 <Welkin> it seems that fmap works fine on my Tree
22:35:05 <Welkin> well, I defined Functor and Foldable instances for my Tree
22:35:08 <dibblego> traverse is fmap, but with a context in every return position
22:35:12 <Welkin> what advantage does Traversable give me?
22:35:31 <dibblego> traverse generalises fmap (fmap is recoverable with that context ~ Id)
22:36:14 <dibblego> fmap :: (a -> Id b) -> f a -> Id (f b)
22:36:19 <jle`> Welkin: if you want to fmap Applicative/Monadic functions onto your tree
22:36:27 <jle`> (a -> IO b) -> Tree a -> IO (Tree b)
22:36:28 <Welkin> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/Data-Traversable.html
22:36:38 <dibblego> @google the essence of the iterator pattern
22:36:39 <jle`> try doing that with your fmap ;)
22:36:39 <lambdabot> http://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
22:36:39 <lambdabot> Title: The Essence of the Iterator Pattern
22:36:41 <Welkin> I see in the example here it is implemented as an applicative
22:36:52 <dibblego> that paper is all about traverse
22:37:14 <Welkin> I just started exploring Foldable/Traversable
22:37:27 <Welkin> at first I tried to defined a foldTree function, but that didn't work out
22:37:30 <Welkin> define
22:38:31 <Welkin> okay, I see the point of Traversable
22:40:58 <Welkin> I nearly forgot about the typeclassopedia
22:41:12 <Welkin> I'll need to read it again
22:43:03 <glguy> iterator.pdf ++
22:45:23 <Welkin> yeah, I'm reading that now too
22:45:32 <Welkin> thanks jle` and dibblego
22:57:06 * hackagebot objective 0.6.3 - Extensible objects  http://hackage.haskell.org/package/objective-0.6.3 (FumiakiKinoshita)
23:02:06 * hackagebot call 0.1.2 - The call game engine  http://hackage.haskell.org/package/call-0.1.2 (FumiakiKinoshita)
23:04:49 <Myrl> Hmmm...
23:04:59 * Myrl wonders as to how one can make a game in Haskell.
23:05:39 <Myrl> Not that I would anyway.
23:09:52 <Welkin> Myrl: joing #haskell-game
23:09:55 <Welkin> join*
23:10:04 <Welkin> it's easy to make a game in haskell
23:10:56 <Kaidelong> Welkin: that has not been my experience at all
23:11:09 <Kaidelong> are you talking about making a game in gloss?
23:11:13 <Kaidelong> that actually is kind of easy
23:11:32 <Kaidelong> but marshalling SDL into playing nice with haskell style is hard
23:12:15 <Kaidelong> (I cannot get existing game engines to build because gtk2hs won't build on win64)
23:13:06 <Welkin> Kaidelong: I meant in general
23:13:11 <Welkin> a game doesn't need to have graphics
23:13:17 <Welkin> that is just one type of interface
23:13:26 <Welkin> the graphics are not the game
23:13:29 <Kaidelong> ah okay, yeah, Hunt the Wumpus is a pretty great haskell exercise
23:13:43 <Welkin> what si that?
23:13:47 <Kaidelong> particularly for learning about zippers and random variables
23:13:47 <Welkin> is*
23:13:54 <Myrl> Welkin: I will once I got the time.
23:14:02 <Kaidelong> Welkin: http://en.wikipedia.org/wiki/Hunt_the_Wumpus
23:14:03 <Welkin> the graphics stuff is actually not bad
23:14:06 <Myrl> Welkin: But I'm still currently learning Haskell.
23:14:10 <Welkin> I got sdl2 and opengl working together
23:14:24 <Kaidelong> Welkin: on windows?
23:14:32 <Welkin> I don't use windows
23:14:38 <Kaidelong> that might be why
23:14:44 <Myrl> Lol.
23:14:50 <Kaidelong> everything Haskell related is so much easier on Linux
23:14:59 <Myrl> Kaidelong: Anything programming-related*
23:15:04 <Kaidelong> that's not true
23:15:25 <Kaidelong> the Visual Basic implementation in mono isn't all that great or modern
23:15:29 <Welkin> I'm currently making a text-based rpg
23:15:46 <Myrl> Kaidelong: How about "Almost anything*"
23:16:41 <Kaidelong> I really think that would depend on what you are doing. Windows for example provides a GDI built into the operating system while Linux has the framebuffer, X, and the X DRI
23:16:54 <Kaidelong> seems like more support surface on the latter
23:17:30 <Myrl> Well, most things that I've done hasn't been related to programming, so I cannot judge.
23:17:38 <Myrl> to graphics programming*
23:47:18 <Myrl> Well, Learn You a Haskell didn't seem to talk about binding.
23:47:57 <shachaf> Binding?
23:51:33 <Myrl> shachaf: I don't know the gerund form of such action, but it's denoted by >>=
23:51:43 <shachaf> Ah.
23:51:56 <Myrl> Hmmm...
23:52:08 <shachaf> "bind" actually means something much more general, so calling (>>=) "bind" is a bit of a confusing idiom.
23:52:14 <Myrl> I've downloaded XMonad through my package manager, but I can't seem to :m + XMonad
23:52:15 <shachaf> Too late to do anything about that, anyway.
23:52:38 <Myrl> 'Could not find module ‘XMonad’'
23:52:55 <edwardk> shachaf: well, that ship has well and truly sailed ;)
23:52:56 <shachaf> In fact, when you use >>= directly, it's not the thing doing the binding. a >>= (\x -> ...) -- the argument of the lambda is bound to x.
23:53:20 <shachaf> edwardk: Sure, but I can still object when people call "using >>=" "binding".
23:53:27 <edwardk> fair
23:53:30 <shachaf> I think that'll confuse most people.
23:53:34 <Cale> Myrl: try  ghc-pkg list xmonad  at the commandline
23:53:39 <Cale> (i.e. not in ghci)
23:53:50 <shachaf> Myrl: That sounds like a your-package-manager thing.
23:54:21 <shachaf> (And possibly better for #xmonad, though it's OK here too.)
23:54:40 <Myrl> shachaf: I was planning on asking it on xmonad, but everyone seems to be asleep.
23:55:42 <Myrl> And it seems as though my xmonad.hs itself works.
23:56:04 <shachaf> Well, apply the Usual Debugging Strategy until the problem is resolved.
23:56:09 <shachaf> Cale gave you the first step.
23:56:09 <glguy> Did you open ghci before or after installing the package?
23:56:45 <Myrl> glguy: After.
23:57:08 <Myrl> I think I got the problem.
23:57:10 <glguy> OK, back to Cale's plan then :)
23:57:15 <Myrl> xmonad-0.11: dependency "X11-1.6.1.2-c9be4c2c454758e64c69f3cd8c7c1eb4" doesn't exist (use --force to override)
23:57:23 <Myrl> Maybe that's what I have to fix.
23:57:38 <Myrl> Most likely not a "Maybe"
23:58:55 <Myrl> It seems I've messed up that directory.
