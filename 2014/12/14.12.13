00:00:01 <Cale> I'm not sure if I agree with that, but that's what was said, anyway :)
00:02:31 <favetelinguis> Ok strang way of expressing it :)
00:08:00 <gamegoblin> @pl \a xs -> map (+a) xs
00:08:00 <lambdabot> map . (+)
00:08:33 <thang1> I interpreted the "sterile" sentence as meaning "least chance of getting a nobel prize"
00:08:52 <gamegoblin> @pl \xs a -> map (+a) xs
00:08:52 <lambdabot> flip (map . (+))
00:09:39 <trap_exit> i would ahve thought it be "least chance of getting a fields medal"
00:09:57 <thang1> Alternatively "a mathemetician who gets a PhD in CT is least likely, out of all of the types of mathemeticians, to get laid. This is a fact that is incredibly surprising considering that abstract multi-dimensional geometry exists, which is fiddling with imaginary shapes that can't exist, and then applying that to vague ideas using even more vague language"
00:10:01 <gamegoblin> @pl \a xs -> map (/a) xs
00:10:01 <lambdabot> map . flip (/)
00:10:43 * hackagebot relational-query-HDBC 0.0.1.1 - HDBC instance of relational join and typed query for HDBC  http://hackage.haskell.org/package/relational-query-HDBC-0.0.1.1 (KeiHibino)
00:10:43 * hackagebot vk-posix-pty 0.2.1 - Pseudo terminal interaction with subprocesses.  http://hackage.haskell.org/package/vk-posix-pty-0.2.1 (VladimirKirillov)
00:14:25 <thang1> I default to saying nobel prize just out of habit, but yeah it's fields medal my bad
00:15:24 <thang1> Why can't scientists be lazy and just go "well this prize here is exactly like the nobel prize... but for x path of science!" and then call it the nobel prize anyway because who has the time to remember the names of 15 different awards?
00:17:26 <trap_exit> so basically
00:17:35 <trap_exit> you're saying: a mathematican that studies category theory is likely to be sterle
00:18:40 <thang1> If you're sterile you can certainly get laid, don't worry about that :p
00:19:19 <thang1> I'm saying that category theory is a whole new level of academia as far as math is concerned (and mathemeticians are already made fun of for obsessing about needless details)
00:19:46 <thang1> So, you get a PhD and spend your entire life working on... categorizing objects. Not just any objects
00:19:48 <thang1> made up ones
00:19:51 <thang1> that you made up
00:20:12 <trap_exit> didn't the recently deceased alexander grothendeick do great things in category theory?
00:20:17 <trap_exit> I thought he used it to solve a bunch of open problems
00:20:23 <thang1> And now this categorization is extremely difficult to conceptualize, so to help you with that you invent an entirely new branch of math that uses other branches of math to help categorize... categories
00:20:49 <thang1> (I'm being sarcastic, really. I actually enjoy category theory)
00:21:24 <thang1> But you gotta admit, it sounds WAY stupider than most 'abstract/weird' types of math, at least to the uninitiated
00:21:43 <Fuuzetsu> you can make anything sound stupid
00:22:49 <sampletestme> hello
00:23:28 <thang1> namastate
00:23:51 <thang1> Fuuzetsu: some things are more fun to make sound stupid than others, though
00:24:11 <sampletestme> How is everyone?
00:24:20 <fizbin> Anyone here familiar with attoparsec?
00:25:15 <sampletestme> I know attoparsec!
00:25:26 <fizbin> I'm trying to figure out if there's any way in attoparsec to say "Don't backtrack beyond this spot"
00:26:06 <fizbin> I think, looking at the implementation briefly there ought to be a way, but can't find the combinator in the documentation.
00:26:14 <trap_exit> attoparsec is like parsec, except there's no <|> , there's only try
00:26:31 <sampletestme> try (string "foo") <|> string "for"
00:26:45 <Peaker> fizbin: maybe you could split your parse into multiple parses?
00:26:58 <Peaker> attoparsec supposedly "always" backtracks
00:27:05 <Peaker> trap_exit: in attoparsec, try=id
00:28:51 <fizbin> Well splitting it here is a bit ridiculous. I just want the parser to tell me that an escape sequence is unrecognized if it already saw a backslash and didn't recognize what went after that. I don't want it to continue to other alternatives.
00:30:50 <fizbin> E.g. suppose I want a tiny language that just results in a Parser String and has \n mean newline, \\ mean a single backslash, and every other character mean itself.
00:31:07 <fizbin> I would like to be able to write something like:
00:33:46 <fizbin> tinyPrsr = many1 (char '\\' *> ("n" *> return '\n' <|> "\\" *> return '\\') <|> anyChar)
00:36:14 <fizbin> The problem is, that parser accepts the string abcd\efg
00:36:22 <fizbin> I want \e to be an error.
00:36:46 <Peaker> fizbin: x *> return y  ==  y <$ x
00:36:49 <Fuuzetsu> you can't not backtrack, if you want extra handling then you have to code it in
00:37:18 <Peaker> fizbin: just disallow '\\' in the other option
00:37:58 <fizbin> Ugh. Then I have to very carefully make sure I've excluded all possible prefixes at every alternate.
00:38:25 <fizbin> Because of course, I don't just want this tiny language. I have the whole rest of the language this is just a piece of.
00:38:27 <gamegoblin> @pl \x -> (x-a)/b
00:38:27 <lambdabot> (/ b) . subtract a
00:38:42 <Peaker> fizbin: many1 (char '\\' *> ('\n' <$ char 'n' <|> '\\' <$ char '\\') <|> notChar '\\')
00:38:52 <Peaker> fizbin: ah
00:39:14 <Peaker> fizbin: Monadic parse combinators can be annoying :(  Is your language regular?
00:39:42 <fizbin> No, in that it involves parentheses that can be arbitrarily nested.
00:40:12 <c_wraith> that only means context-free.  You can do that with Applicative/Alternative combinators, still
00:40:26 <Peaker> there's regex-applicative.  Someone ought to make parse combinators like that that are based on Applicative + a fix-point for recursion, for CFG
00:40:58 <c_wraith> You only *need* monadic combinators if the language is context-sensitive
00:41:03 <Peaker> c_wraith: You also need recursion, if you do it at the Haskell-level, it'll make an infinite-sized parser that cannot be compiled, potentially
00:41:20 <fizbin> Right, it isn't regular, but I'm pretty sure my language is context-free
00:41:28 <Fuuzetsu> ???
00:41:42 <Fuuzetsu> you just said it's not context-free by wanting to match balanced parens
00:41:52 <c_wraith> balanced parens is fine in context-free
00:42:02 <c_wraith> it's just regular that can't handle balanced parens
00:42:07 <Fuuzetsu> ah
00:42:08 <Fuuzetsu> right
00:45:59 <osa1> why we don't have toList for unboxed mutable vectors http://hackage.haskell.org/package/vector-0.10.12.2/docs/Data-Vector-Unboxed-Mutable.html ?
00:46:40 <osa1> any easy ways to convert from unboxed mutable Word8 vector to ByteString?
00:48:09 <Peaker> fizbin: you could do a charCommit c parser = (char c *> parser) <|> (peekChar >>= \mc -> if mc == Just c then fail "Committed to c!")
00:48:42 <Peaker> s/if/when
00:49:07 <Peaker> hmm, no, that won't help
00:49:14 <fizbin> No, it won't.
00:49:38 <fizbin> And I don't want big error handling out of attoparsec.
00:49:54 <Peaker> parsec can easily express this :(
00:50:12 <Peaker> Someone needs to make a good CFG parsing package
00:50:17 <fizbin> All I want is something as minor as the kind of stuff perl allows in its regexes.
00:50:21 <Peaker> rather than monadic combinators
00:50:36 <fizbin> I just want a "okay, you're committed to this branch now" thing.
00:51:56 <Peaker> if you can CPS your parser somehow so that other parsing options are not <|>'d from the outside, but inserted into the peekChar-check branch...
00:52:10 <Peaker> (terrible parser structure though :-( )
00:52:22 <fizbin> It seems like such a small obvious thing - the kind of thing you'd naturally want - that I have to believe that either it exists, or there's some whole problem to approaching stuff this way that other people avoid by approaching it differently.
00:55:57 <pharpend> Hey, guys. I've been having this issue http://forums.gentoo.org/viewtopic-t-1006212-highlight-.html?sid=1f0f89264fe390a316aa0028680944ef for the last couple days. nobody on the forum has responded so far
00:59:39 <Fuuzetsu> pharpend: don't mix portage with user-installed packages
01:00:05 <Fuuzetsu> either use just portage or just cabal yourself
01:00:39 * hackagebot Deadpan-DDP 0.5.0.0 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.5.0.0 (LyndonMaydwell)
01:06:26 <fizbin> Huh. I guess I can rework stuff to make all my parsers be Parser (Either String RealThing); that is, essentially wrap them all in EitherT String.
01:06:48 <fizbin> And then just replace my parseOnly call with join . parseOnly
01:08:17 <Peaker> fizbin: why not use EitherT really?
01:11:21 <jle`> i'm having trouble writing zipWith in terms of foldr
01:11:26 <jle`> hm.
01:12:16 <fizbin> Well huh. That didn't work as expected.
01:12:38 <Peaker> jle`: foldr recurses on one list. zipWith wants to recurse on two lists. It's not easy to do it that way
01:12:58 <fizbin> I don't think that approach (or using EitherT directly, Peaker) is going to work.
01:13:00 <jle`> well how else am i supposed to write zipWith on church encoded lists
01:13:36 <Peaker> fizbin: it does sound like a nice idea -- why wouldn't it work?  If you want to "commit" to a parse option after failure, you "throw" in EitherT up to whereever where you catch and handle it correctly?
01:13:42 <jle`> ;_;
01:14:53 <fizbin> Peaker: because this happens:
01:14:55 <fizbin> λ: let yes = return . Right; no = return . Left; tinyPrsr = many1 (char '\\' *> ("n" *> yes '\n' <|> "\\" *> yes '\\' <|> do {x <- anyChar; no ("bad escape sequence " ++ [x])}) <|> Right <$> anyChar)
01:14:55 <fizbin> λ: parseOnly tinyPrsr "abcd"
01:14:56 <fizbin> Right [Right 'a',Right 'b',Right 'c',Right 'd']
01:15:46 <fizbin> I think the same would happen with EitherT, but let me try that too...
01:18:17 <Peaker> fizbin: but your tinyPrsr is being called on a valid "abcd" string?
01:18:25 <Peaker> fizbin: or are you bothered by the "Right" wrappers there?
01:18:32 <Peaker> (if it's the latter, then yeah, EitherT will solve that for you)
01:18:46 <Peaker> fizbin: left=no, return=yes   with EitherT :)
01:18:47 <fizbin> It's all the Right wrappers.
01:20:13 <Peaker> fizbin: though I think EitherT is deprecated now that ExceptT is in transformers?
01:20:58 <fizbin> EitherT the package is deprecated in favor of a different package, that also has an EitherT type.
01:21:15 <Peaker> Yeah, I know (I deprecated mine since edwardk had his either package)
01:21:19 <fizbin> ( https://hackage.haskell.org/package/either )
01:21:23 <Peaker> but now it's also in transformers
01:24:58 <edwardk> The either package isn't deprecated yet partially because of the poor reception the ExceptT type has had, partially because of missing instances, and partially because many many users can't upgrade to a new transformers, e.g. if they need to work with the ghc package.
01:25:36 <edwardk> Whether we eventually deprecate in favor of the ExceptT color of the bikeshed will be mostly up to the users of the package
01:26:03 <fizbin> It's still not clear to me though how I'd use EitherT on the tinyprsr above.
01:26:25 <edwardk> i didn't see your example
01:29:17 <fizbin> Well, my example didn't work...
01:29:19 <fizbin> λ: :set -XOverloadedStrings
01:29:19 <fizbin> λ: import Data.Attoparsec.Text
01:29:20 <fizbin> λ: let yes = return . Right; no = return . Left; tinyPrsr = many1 (char '\\' *> ("n" *> yes '\n' <|> "\\" *> yes '\\' <|> do {x <- anyChar; no ("bad escape sequence " ++ [x])}) <|> Right <$> anyChar)
01:29:20 <fizbin> λ: parseOnly tinyPrsr "abcd"
01:29:20 <fizbin> Right [Right 'a',Right 'b',Right 'c',Right 'd']
01:29:38 <fizbin> And I'd really wanted (Right "abcd")
01:30:06 <fizbin> But I think doing so requires rewriting many1.
01:31:39 <fizbin> This is me using Either to try and get around the fact that it seems impossible to tell attoparsec "no, you're committed to this branch now, do not backtrack beyond here"
01:35:20 <mgsloan> Hello! Anyone know why "Coercible" appears with different numbers of arguments here: https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Coerce.html#t:Coercible ?
01:35:54 <jle`> is there a better way to write tail with foldr than just folding it up with a tuple to keep state
01:35:56 <mgsloan> Looks to me like it may be a haddock rendering bug
01:36:47 <mgsloan> I'm also getting some funkiness with Coercible where if I reify an instance that uses it in a constraint, and then output a modified instance, it ends up with the wrong number of arguments (3 instead of 2)
01:36:47 <Peaker> fizbin: the "either" package has "left" to throw a Left in your EitherT
01:36:58 <Peaker> fizbin: so:  yes = return   and no = left
01:38:30 <shock_one> Hi. What for do we need an identity arrow in the category theory?
01:38:41 <fizbin> Peaker: Okay; how does this help me? I can't figure out how to transform my tinyPrsr above into something that'll typecheck.
01:39:35 <sivteck> :t C.id -- shock_one, do you mean in the Category typeclass?
01:39:36 <lambdabot> Category cat => cat a a
01:39:57 <Peaker> fizbin: the problem is that contravariant-parser positions like the parameter to "many1" don't like your EitherT, right?
01:40:39 <fizbin> Maybe? I'm not sure yet.
01:41:00 <jle`> shock_one: it's just the definition of a category
01:41:10 <shock_one> sivteck: I mean in any category. I can get why there are objects and arrows, and why arrows need to be composable, but I don't see any sense in having an identity arrow.
01:41:17 <jle`> why do we need a combining operator in monoid?
01:41:34 <jle`> that's just the definition of what a Category is
01:41:39 <jle`> why does monoid need mempty?
01:41:59 <jle`> there are category-like things without identities
01:42:41 <jle`> a monoid without an identity element is called a semigroup...the only requirement is that the combining operator is associative
01:44:51 <shock_one_> OK. In Euclid geometry parallel lines don't intersect. Despite the fact that opposite also works well, there is a certain reason we have this axiom: it allows us to prove that angles formed by a crossing line are equal. Why is identity useful?
01:45:21 <fizbin> Peaker: Huh. So apparently many1 can operate of EitherT lifted stuff, so I need to work on the first bit of my parser...
01:45:22 <Peaker> fizbin: hmm.. I think EitherT Parser  might behave incorrectly w.r.t <|> due to the broken (x*>empty)==empty law.
01:49:30 <fizbin> I'm not really that used to using monad transformers - what's the special combinator/function I need to apply parseOnly to tinyPrsrNoEsc here:
01:49:32 <fizbin> λ: let tinyPrsrNoEsc :: EitherT String Parser String; tinyPrsrNoEsc = many1 (lift anyChar)
01:49:32 <fizbin> λ: :t parseOnly
01:49:32 <fizbin> parseOnly :: Parser a -> Text -> Either String a
01:50:34 <Peaker> fizbin: you need to:  runEitherT tinyPrsrNoEsc
01:51:00 <Peaker> fizbin: to convert it from: EitherT String Parser a   to:   Parser (Either String a)
01:51:32 <fizbin> Well that was disappointing:
01:51:34 <fizbin> λ: parseOnly (runEitherT tinyPrsrNoEsc) "abcd"
01:51:35 <fizbin> Left "not enough input"
01:52:08 <fizbin> EitherT may indeed be broken w.r.t. <|> in parsing.
01:52:22 <fizbin> I think many1 is built on <|>
01:55:24 <Peaker> fizbin: eitherTparse1 <|> eitherTparse2  is a problem because <|> will let parse-effects from the left side "leak" after left-failure into the right side
01:55:49 <c_wraith> I..  hmm.  I have an opportunity to learn something here.  I tried to CPS-transform the argument to foldr, and I'm utterly baffled by what happened.
01:55:57 <tempay> I'm looking for a way to get a good working knowledge of category theory for Haskell
01:56:12 <tempay> Math-y is okay, but I don't need incredibly in depth
01:56:21 <tempay> can anyone point me at a good book?
01:57:33 <c_wraith> > foldr (\x f y z -> if x == ' ' then f (x:y) y else f (x:y) (x:z)) (const id) "one two three" [] []
01:57:35 <lambdabot>  "eerhtowt eno"
01:57:45 <fizbin> Peaker: Not only that. It doesn't even seem to want to fail over properly.
01:57:50 <c_wraith> Obviously I did something wrong. :)
01:59:01 <fizbin> λ: parseOnly (runEitherT $ (lift (string "asdf") <|> lift (string "abcd"))) "abcd"
01:59:01 <fizbin> Left "Failed reading: takeWith"
01:59:57 <c_wraith> fizbin: parsec or attoparsec?  That'll never work in parsec.
02:00:12 <fizbin> attoparsec.
02:00:33 <fizbin> I started out wanting something that "must be simple", right? Famous last words...
02:00:48 <fizbin> I get that attoparsec is backtracking by default.
02:00:56 <c_wraith> It's not backtracking by default
02:01:17 <c_wraith> It just *sometimes* matches full strings as a single unit, instead of character-by-character
02:01:20 <fizbin> But it seems that it isn't really backtracking by default, but backtracking by unchangeable decree that cannot be tweaked at all.
02:01:27 <c_wraith> Such that you think it's backtracking
02:02:07 <Fuuzetsu> fizbin: that's a weird way to write that, what's wrong with "asdf" <|> "abcd"?
02:02:30 <Fuuzetsu> disclaimer: I didn't read up
02:02:36 <c_wraith> attoparsec definitely does *not* backtrack by default.  That leads to accidental bad performance, and that library decided it's better to have your parser not work than be accidentally slow.
02:02:58 <fizbin> I "just" want a way to have an alternative branch committed to. The tiny example I was trying to work with was:
02:03:02 <fizbin> let tinyPrsr = many1 (char '\\' *> ("n" *> return '\n' <|> "\\" *> return '\\') <|> anyChar)
02:03:26 <c_wraith> fizbin: ah.  yep.  The problem is that you're using single-character primitives
02:03:35 <c_wraith> fizbin: if one of them matches, the branch is committed
02:03:49 <fizbin> Except no, it isn't:
02:03:57 <c_wraith> fizbin: and as I said, attoparsec *doesn't* backtrack.
02:04:17 <fizbin> λ: let tinyPrsr = many1 (char '\\' *> ("n" *> return '\n' <|> "\\" *> return '\\') <|> anyChar)
02:04:17 <fizbin> λ: parseOnly tinyPrsr "abcd\\efgh"
02:04:17 <fizbin> Right "abcd\\efgh"
02:04:33 <fizbin> See, I don't want that.
02:04:37 <Fuuzetsu> “attoparsec parsers always backtrack on failure.”
02:04:40 <Saizan> fizbin: c_wraith: http://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-Text.html#g:16
02:04:48 <fizbin> It should fail when I say \e
02:05:13 <fizbin> c_wraith: I want a way to do the "commit to this branch" thing that you seem to think happens.
02:05:15 <c_wraith> Hmm.  always-backtracking is new behavior, I guess.
02:05:23 <Fuuzetsu> new?
02:05:46 <c_wraith> yeah, it certainly didn't work that way when it was released.
02:06:05 <Saizan> it's been that way for years though
02:06:36 <fizbin> Really? I can't imagine the behavior would change with no way to explicitly commit to a branch.
02:06:53 <Fuuzetsu> at least since 2011
02:07:36 <fizbin> And yet, apparently that's the case: I find it impossible to build a parser that won't backtrack through that escape.
02:08:36 <fizbin> So I had started an attempt to have a parser that explicitly returned (Left errorMessage) when it hit an error I don't want it backtracking out of.
02:08:48 <c_wraith> Looks like that changed with 0.10, which..  wow, was years ago
02:09:11 <fizbin> That didn't work well when hand-rolling it, so Peaker suggested EitherT which was what I was fighting with when you came in.
02:09:43 <Saizan> EitherT won't work well with the combinators
02:10:00 <fizbin> No, we discovered that. It really, really doesn't.
02:11:14 <Saizan> i think you should still be able to write a loop by hand that checks which char you got after an \ and decides then what to do
02:12:10 <Saizan> maybe with lookAhead to not consume that char
02:12:21 <Saizan> but yeah, committing to a branch would be nice to have
02:13:27 <fizbin> Saizan: Right, but my problem is that my entire language isn't tinyPrsr, and doing what you suggest only solves the problem for one little bit.
02:16:06 <brbblnch> Hi, are scheme's continuations pure/functional ?
02:16:07 <fizbin> In general, I have a language that is: parser1 <|> parser2 <|> parser3 <|> (OtherText <$> anyChar)
02:17:16 <Saizan> fizbin: but do you need this committing behaviour everywhere?
02:17:26 <fizbin> And I'd really like to be able to have the "commit to this" stuff hidden in parser1, parser2, etc., and not have to pollute my top-level function with knowledge about what sequences mean "commit to parser2".
02:18:11 <fizbin> Saizan: Because my top-level function ends with <|> (OtherText <$> anyChar), yeah, I do.
02:18:44 <Saizan> well, you can still commit locally, but yeah, if you need deep in parser1 to be able to alter the control flow of the overall parser i suppose you'd better pick another lib
02:23:34 <Peaker> does uu-parsinglib "compile" the parsers to make use of their Applicative structure if no Monadic combinators are used?
02:24:04 <c_wraith> Peaker: it doesn't compile them - but it has a different internal representation for purely-applicative parsers, that the applicative combinators maintain
02:24:25 <c_wraith> Peaker: at least, that's what it did last time I looked at the code.  Apparently some of my knowledge is out of date.
02:24:34 <Peaker> c_wraith: What benefit does it derive from the internal repr?
02:25:04 <Peaker> I'd really like a parsing lib that lets me write my CFG parsers in a module fashion, not worry about backtracking/etc, and just compile them
02:25:13 <Peaker> The Monadic parsers are too strong. The Applicative parsers lack a fixpoint operator
02:25:35 <c_wraith> Did boomerang ever make it onto hackage?
02:25:42 * hackagebot jose 0.2.38.0 - Javascript Object Signing and Encryption and JSON Web Token library  http://hackage.haskell.org/package/jose-0.2.38.0 (frasertweedale)
02:25:45 <c_wraith> I think uu-parsinglib's applicative stuff is just about performance
02:29:29 <Peaker> c_wraith: by "compile" above, I just meant generate something like a NFA
02:29:44 <Peaker> otherwise I'm not sure how you get performance from the applicative-style?
02:30:39 <c_wraith> I think it may be doing something that's equivalent to some functional representation of an NFA
02:34:14 <c_wraith> Ok.  So..  if you CPS-transform the reducer function in a foldr, you get a foldl?
02:34:31 <c_wraith> Is that how it works?
02:43:40 <latermuse> Is it possible to use 'read' to convert a string into a Tree?
02:43:45 <latermuse> example: read "Node {rootLabel = "a", subForest = []}" :: Tree String
02:45:59 <shachaf> Yes.
02:46:13 <shachaf> Your example doesn't escape properly but other than that it's fine.
02:46:22 <latermuse> shachaf: oh!
02:46:36 <latermuse> silly me
02:46:37 <latermuse> thanks! :)
03:00:11 <pavonia> What is the function that returns the part after the comma of a floating point number?
03:00:43 <Cale> after the decimal point?
03:00:49 <c_wraith> x - floor x
03:00:59 <pavonia> Yes
03:01:06 <pavonia> Is ther enothing built-in?
03:01:41 <Cale> > properFraction pi
03:01:43 <lambdabot>  (3,0.14159265358979312)
03:01:49 <c_wraith> oh, that's neat.
03:02:26 <pavonia> Nice, thanks!
03:02:30 <ClaudiusMaximus> > properFraction (-pi)
03:02:32 <lambdabot>  (-3,-0.14159265358979312)
03:03:23 <ClaudiusMaximus> > (-pi) - fromIntegral (floor (-pi))
03:03:24 <lambdabot>  0.8584073464102069
04:37:14 <jle`> why can't i write a clean tail using foldr ;_;
04:37:20 <jle`> i feel like this shouldn't be that hard
04:37:45 <Peaker> jle`: well, tail is O(1), but I think with foldr you can only write an O(N) tail
04:38:01 <jle`> i see
04:38:21 <jle`> i'm trying to do tail on a church encoded list
04:39:14 <jle`> i'm having a more difficult time than i expected.  i didn't want to basically implement foldl and do foldl with a tuple with state
04:39:15 <jle`> ;_;
04:46:41 <Peaker> jle`: I have made "drop 1", but not "tail"
04:46:45 <Peaker> jle`: "drop 1" is fine I guess? :)
04:51:04 <Peaker> ok, made a nice tail
04:52:10 <jle`> darn
04:52:27 <jle`> thanks :)
04:52:31 <jle`> good to know it is possible
04:55:05 <jle`> well, should probably sleep anyway. thanks :)
04:55:49 * hackagebot elm-build-lib 0.14.0.0 - Compile Elm code to JS within Haskell  http://hackage.haskell.org/package/elm-build-lib-0.14.0.0 (jeremondi)
05:22:17 <huagl> Hello, I have a question. i have a function foo :: ( a -> Maybe b ) -> IO a -> IO b. The task is applying the function to a until i get "Just b", then return IO b. Currently, I have the case statement for matching the maybe and 'return b' in the "just b" case. I don't understand how to get a simple 'a' out of IO a so that i can apply my function to it. For clarification: I'm not searching for code, just an explanation
05:26:38 <Peaker> jle`: good night!
05:26:46 <jcpetruzza> huagl: have you tried using do-notation?
05:26:59 <Peaker> huagl: Use >>= to 'extract'
05:28:31 <renxx__> Whats the differenec between function and combinator in haskell. I know combinator is a function, but when a function is a combinator?
05:28:43 <chrisdone> usually when it takes other functions as arguments
05:28:48 <chrisdone> "combining"
05:29:03 <huagl> jcpetruzza: I tried, but I don't know how to do this correctly. My current, not working approach is foo f x = do y <- x
05:29:18 <huagl> and then next line case ...
05:29:24 <renxx__> so only higher order functions are combinators?
05:29:45 <jcpetruzza> huagl: sounds good to me, what's the problem with that?
05:29:48 <huagl> Peaker: How does this work? What does >>= do?
05:30:09 <huagl> ghci says there is a parse error
05:30:29 <jcpetruzza> huagl: do-notation desugars to >>=
05:31:21 <huagl> ah, so do is the same as >>= ?
05:31:26 <jcpetruzza> so do a <- x; rest ~~> (x >>= \a -> rest)
05:31:39 <chrisdone> @undo do x <- m; y <- g; return (x * y)
05:31:54 <capisce> ~~> ?
05:32:07 <chrisdone> ok, lambdabot usually does something there
05:32:14 <jcpetruzza> capisce: "rewrites to" :)
05:32:19 <capisce> haha, ok
05:32:28 <capisce> that looked awfully like it could be Haskell syntax
05:32:46 <capisce> but yeah, in hindsight that's rather obvious
05:32:55 <jcpetruzza> huagl: if you get a parse error, try aligning the case with with the "y"
05:34:12 <huagl> ah, aligning did it! i had indentations but I guess I have to do more of them
05:34:18 <huagl> thank you!
05:37:01 <chrisdone> huagl: IO values in haskell are just descriptions of what to do later. so there's no "IO a -> a" function. instead you just combine them with more IO values. a >> b combines two in sequence, m >>= f combines two but such that when executed the result of m would be passed into f. in the end someone (the ghc runtime, for example) takes the final big IO value and actually runs it
05:39:24 <huagl> chrisdone: Thank you for your explanation. So I can imagine (just for myself) that IO behaves like a list of commands that are executed by "a higher power"?
05:40:00 <chrisdone> huagl: right
05:40:29 <huagl> fine :)
05:46:03 <chrisdone> Peaker: i'm working on a haskell teaching tool :3 specifically the interesting part is making something like the combination of digestive-functors and quickcheck, to produce randomly generated self-validating questions
05:46:40 <Peaker> chrisdone: cool!
05:46:50 <Peaker> I'm still struggling with ghc to try and get -fno-code to behave :)
05:46:56 <chrisdone> hehe
05:47:35 <chrisdone> i'm thinking when i get something working i'll make it available as a bot so that the irc denizens can battle test it
05:49:39 <Peaker> I managed to backport a change from GHC HEAD to 7.8.3 that lets -fno-code generate interface files
05:50:00 <Peaker> but now -fno-code appears to never read these interface files
05:53:27 <cads> what's a language that code in a different way than haskell, but compiles down to haskell?
05:54:05 <cads> I know agda II, and some of the other dependendently typed studd
05:54:08 <cads> stuff*
06:35:53 * hackagebot relational-record 0.0.1.2 - Meta package of Relational Record  http://hackage.haskell.org/package/relational-record-0.0.1.2 (KeiHibino)
07:17:55 <sheyll> hello
07:31:10 <Peaker> bernalex: this is a more appropriate channel for quickcheck :)
07:33:15 <sheyll> could anyone clearify what 'cabal install' is meant to do, I am currently working on implementing https://github.com/haskell/cabal/issues/1493
07:33:26 <sheyll> I am not sure I 'get' cabal install
07:35:34 <Peaker> sheyll: what specifically?
07:35:54 <sheyll> so when is cabal install supposed to be called by the use
07:35:57 <sheyll> user
07:36:19 <sheyll> is used to install deps as well as the users code?
07:36:29 <Peaker> yeah
07:36:43 <Peaker> "cabal install" in a directory with a .cabal file will "cabal install" recursively all dependencies and then the current package
07:37:02 <sheyll> so install is supposed to be called after 'configure'
07:37:22 <Peaker> I'm pretty sure "install" calls configure on its own, and even overrides/forgets any prior configure flags
07:37:40 <Peaker> i.e: if you "cabal configure <options> && cabal install" it will actually install with no options
07:37:45 <Peaker> you need "cabal install <config options here>"
07:38:00 <sheyll> actually from looking at the code no, cabal install tries to read LocalBuildInfo
07:38:25 <sheyll> ... I think
07:39:32 <sheyll> Well looking at the code I see 'install' calls reconfigure, whith the previous LocalBuildInfo... I just do not get the 'big-picture'
07:40:36 <Saizan> "cabal install" is supposed to resolve deps from hackages and then do the job of configure, build, register and copy
07:40:47 <bernalex> if I have an f :: Integer -> [Integer] -> Property in quickcheck, with arguments named 'a' and 'bs', how do I check that 'g a' returns True for every element of 'bs' except when it the element is equal to 'a'?
07:41:16 <bernalex> hm that was an ill-formed sentence.
07:41:25 <Saizan> sheyll: but "./Setup install" (used to at least) do much less, basically only register and copy
07:41:40 <bernalex> I essentially mean. if a `elem` bs, then g a bs === True, else g a bs === False.
07:42:26 <mauke> a `elem` bs == g a bs
07:43:17 <sheyll> Saizan so 'cabal install' is the True  Great-Unified-Cabal-Command :) ?
07:44:12 <Saizan> sheyll: yeah, it tries to do "the right thing"
07:45:23 <bernalex> mauke: *mumbles something about forest something something trees*
07:45:25 <sheyll> So historically one had to get all the deps manually from hackage, and then this was automated and integrated into the 'install' Command?
07:45:26 <bernalex> mauke: thanks!
07:46:27 <Saizan> sheyll: yeah, historically there wasn't an hackage either
07:46:38 <sheyll> Ah..
07:47:01 <Saizan> we had darcs repos with .cabal files in them
07:47:28 <Saizan> and you would do this ./Setup configure/build/install dance in each of them in the right order
07:48:28 <sheyll> Ah thanks it helps me understand cabal a bit better
07:56:16 <bernalex> in quickcheck, what's the easiest way to a) only test positive integers (and 0), and b) to test a list of integers *but not []*?
07:57:07 <bernalex> let's say I have something like f :: [Integer] -> Property; f xs = g xs === maximum xs -- I need to exclude [] from this test.
07:57:23 <bernalex> I can think of a few ways, but I'm sure there's an idiomatic non-silly way of doing) it.
07:57:44 <Saizan> no idea about idiomatic
07:58:04 <Saizan> but yeah, simple ways are a) take the abs b) take an extra element and cons it
07:58:16 <Saizan> you could also specify your own generator with forAll
07:59:07 <bernalex> OK. I thought about these ideas. but just hearing someone else voice them means they might not be terrible after all. :-P
08:01:29 <adamse> bernalex: you have NonNegative wrapper, and NonEmptyList wrapper
08:02:38 <adamse> you would have f :: NonEmptyList (NonNegative Integer) -> Property
08:03:20 <adamse> http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck-Modifiers.html#t:NonEmptyList
08:07:33 <bernalex> adamse: ah, thanks
08:07:33 <aisqwe_> what is the design pattern to avoid "Multiple declarations of 'abc'"? forexample we have function override in imperative languages
08:08:27 <mauke> "design pattern"?!
08:08:46 <mauke> and you don't have "function override" in C
08:08:59 <wei2912> aisqwe_: type polymorphism
08:09:12 <aisqwe_> i have two different entities with the component Pos and i dont want to have entityAPos & entityBPos
08:10:05 <aisqwe_> i want to get the Position of both entities with a single Pos function
08:11:10 <wei2912> aisqwe_: define a typeclass Positionable
08:11:35 <wei2912> http://learnyouahaskell.com/making-our-own-types-and-typeclasses -- scroll down to "Typeclasses 102"
08:12:03 <wei2912> with the use of the typeclass, you can have the types define a function that returns their position
08:12:15 <Saizan> please don't suffix your classes with -able
08:12:29 <wei2912> :(
08:12:30 <Saizan> especially if you have to make up a word in the process
08:13:11 <wei2912> what's the problem with that?
08:13:34 <Saizan> i don't like it :)
08:13:37 <wei2912> :(
08:13:46 <wei2912> call it a Monoendofunctor
08:13:50 <aisqwe_> should i put the X and Y coordinates in the same places in both Types?
08:14:05 <Saizan> "HasPosition"
08:14:33 <athan> Saizan++
08:14:58 <athan> I've also found that completing to something is nice
08:14:59 <Saizan> aisqwe_: what do you mean by same place?
08:16:13 <aisqwe_> data Tank = Tank X Y deriving Positionable ; data Soldier = Soldier X Y deriving Positionable
08:16:22 <Saizan> aisqwe_: btw, if you're using lens there's some TH that can do this for you
08:16:33 <aisqwe_> X and Y should be the first and second components of bot types?
08:16:54 <aisqwe_> sorry, what does TH stand for?
08:17:01 <ReinH> makeFields
08:17:03 <Saizan> aisqwe_: your class won't be derivable, (unless you use Generics, i guess?)
08:17:16 <Saizan> aisqwe_: TemplateHaskell
08:19:22 <Saizan> anyhow you should probably start by defining your own class and your own instances
08:19:38 <Saizan> just to cut down complexity, it's not that much code
08:21:09 <aisqwe_> i want something like this, but it clearly throws a "Multiple declarations of 'pos'" , data Tank = Tank {pos::Position}; data Soldier = Soldier {pos::Position}
08:22:04 <aisqwe_> what is the workaround?
08:22:40 <wei2912> aisqwe_: do you know what the record syntax does?
08:23:03 <wei2912>  also, we already gave you the solution above
08:23:11 <aisqwe_> it produces pos :: Tank -> Position i guess
08:23:17 <wei2912> yep
08:23:32 <wei2912> and you notice that you defined `data Soldier = Solider {pos::Position}` too
08:23:38 <aisqwe_> and when it tries to do the same for the Soldier the two definitions collide
08:23:42 <wei2912> yep
08:24:19 <wei2912> as mentioned, the way to solve this is to use a typeclass
08:24:31 <aisqwe_> so what is the solution in these situations? how do i get the position of a tank and a soldier with just one pos function?
08:25:40 <wei2912> type polymorphism
08:25:46 <wei2912> do you know what is a typeclass?
08:25:51 <aisqwe_> yes
08:26:00 <wei2912> take for example
08:26:02 <wei2912> :t (+)
08:26:03 <lambdabot> Num a => a -> a -> a
08:26:35 <wei2912> we don't need to define (+) for Int, Integer, etc.
08:26:43 <wei2912> but just one definition works
08:26:46 <wei2912> it's the same concept
08:26:48 <Saizan> aisqwe_: class HasPosition a where pos :: a -> Position; data Tank = Tank Position; data Soldier = Soldier Position; instance HasPosition Tank where pos (Tank p) = p; instance HasPosition Soldier where pos (Soldier p) = p
08:27:21 --- mode: card.freenode.net set +o ChanServ
08:27:53 <aisqwe_> so both position datas should be placed in the same place in both types so pattern matching can find it?
08:28:16 <mauke> aisqwe_: no, that doesn't matter
08:29:16 <wei2912> aisqwe_: you appear to be confused about pattern matching
08:29:32 <Saizan> aisqwe_: since you write pos yourself you can write it like you want
08:30:02 <Saizan> aisqwe_: so, suppose data Tank = Tank Model Position; you can still write instance HasPosition where pos (Tank _ p) = p
08:31:56 <aisqwe_> oh, i see now, thank you Saizan & wei2912
08:38:14 <longs> How does zipWith ($) (cycle [id,(*2)]) work? Whats ($)
08:38:20 <mauke> @src ($)
08:38:20 <lambdabot> f $ x = f x
08:38:34 <longs> okay cool thanks
08:40:16 <athan> http://lpaste.net/116374 Why isn't `Constraint` in scope? :(
08:40:31 <hpc> :t zipWith ($) (cycle [id,(*2)])
08:40:32 <lambdabot> Num c => [c] -> [c]
08:40:43 <hpc> :t zipWith
08:40:44 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
08:41:26 <hpc> :t zipWith ($) -- applies a list of functions to a list of numbers
08:41:27 <lambdabot> [b -> c] -> [b] -> [c]
08:41:30 <athan> :t cycle
08:41:31 <lambdabot> [a] -> [a]
08:42:04 <athan> > cycle [1]
08:42:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:42:12 <athan> > cycle [1,2,3]
08:42:13 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
08:42:14 <mauke> athan: does anything change if you enable the extension?
08:42:30 <athan> mauke: In the compiler, you mean?
08:42:38 <mauke> ??
08:42:40 <athan> from the command line?
08:42:44 <athan> (derp) sorry
08:42:56 <athan> or even in the cabal file?
08:43:00 <hpc> add {-# LANGUAGE ConstraintKinds #-} to the top of your source file
08:43:03 <hsk88> Would you recommend Real World Haskell after LYAH?
08:43:04 <athan> I've enabled ConstraintKinds
08:43:04 <mauke> why not in the file itself
08:43:09 <athan> It's there... :(
08:43:15 <mauke> I'm not talking about ConstraintKinds
08:43:28 <mauke> look at the error message
08:43:53 <athan> wow
08:43:55 <athan> sorry
08:44:16 <hpc> heh, everyone does something like that occasionally
08:44:18 <athan> ><
08:44:53 <hpc> especially coming from something like C, where the standard way to deal with compiler errors is to read the top line and ignore everything afterward
08:46:47 <athan> hmm
08:48:42 <athan> well I've got something that's... not dumb: http://lpaste.net/116376
08:49:11 <athan> I still don't understand why Constraint isn't in scope :(
08:49:28 <mauke> probably because you need to import it from somewhere
08:50:40 <mauke> hmm, no
08:50:57 <mauke> oh, wait
08:51:08 <mauke> try 'import GHC.Exts (Constraint)'
08:51:18 <ReinH> Lenses using similar typeclasses can be generated with makeFields btw
09:01:38 <bernalex> I'm not sure I understand this
09:02:29 <bernalex> in quickcheck, how do I write an arbitrary instance for my Data type which is F String (Maybe UTCTime)? I assume I must use the arbitrary functions on String and Maybe, but what more do I need to do?
09:03:41 <bernalex> i.e. I want to use arbitrary for String and arbitrary for Maybe UTCTime, and then somehow get a random Gen F
09:08:46 <chrisdone> hmm
09:08:52 <chrisdone> bernalex: i'm also learning quickcheck right now
09:09:09 <liste> bernalex how about F <*> arbitrary <*> arbitrary ?
09:09:12 <bernalex> chrisdone: I assume there must be an easy way to make an arbitrary instance for a wrapper
09:09:22 <liste> i mean F <$> arbitrary <*> arbitrary
09:09:28 <chrisdone> bernalex: a literal newtype wrapper?
09:09:44 <bernalex> chrisdone: oh, no. a TH-generated database-entity-thingy-majingy.
09:10:10 <liste> <$> and <*> are in Control.Applicative
09:10:48 <bernalex> liste: so you mean 'arbitrary = F <$> arbitrary <*> arbitrary'?
09:10:59 <bernalex> oh lord
09:11:01 <liste> yeah, I didn't try so I'm not sure
09:11:13 <bernalex> there's no instance for Text (I thought it was String) nor for UTCTime
09:11:13 <chrisdone> if you don't care about your own behaviour, you could just re-use the tuple instances
09:11:23 <bernalex> I guess for Text I can just pack though
09:11:47 <liste> remember -f-no-warn-orphans
09:12:06 <liste> -fno-warn-orphans*
09:12:33 <chrisdone> e.g.
09:12:33 <chrisdone> arbitrary = fmap (\(x,y) -> F x y) arbitrary
09:12:33 <chrisdone> shrink = fmap (\(x,y) -> F x y) . shrink
09:13:06 <chrisdone> oh, it seems there's a simpler way!
09:13:26 <chrisdone> it seems like you can derive Generic
09:13:36 <chrisdone> and then use that
09:13:46 <bernalex> chrisdone: derive Generic where? in the ADT?
09:16:00 * hackagebot jsontsv 0.1.4.2 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.4.2 (DanielChoi)
09:16:02 * hackagebot jsonsql 0.1.0.1 - Interpolate JSON object values into SQL strings  http://hackage.haskell.org/package/jsonsql-0.1.0.1 (DanielChoi)
09:17:15 <lpaste> chrisdone pasted “Arbitrary instance” at http://lpaste.net/116380
09:17:28 <lpaste> chrisdone annotated “Arbitrary instance” with “Example” at http://lpaste.net/116380#a116381
09:17:47 <pharpend> thanks int-e
09:18:03 <chrisdone> bernalex: ^
09:18:33 <bernalex> chrisdone: that's very neat! thanks! I'll look into if this plays well with my persistent stuff
09:18:53 <bernalex> FWIW 'F <$> arbitrary <*> arbitrary' does work as well
09:19:44 <pharpend> @tell int-e thanks :)
09:19:44 <lambdabot> Consider it noted.
09:20:10 <lpaste> chrisdone annotated “Arbitrary instance” with “Just using tuples” at http://lpaste.net/116380#a116382
09:20:32 <chrisdone> bernalex: ^ this way you don't need all the deriving stuff
09:21:08 <bernalex> chrisdone: problem is though that neither of the things it wraps are instances of Arbitrary either. not sure how to go about UTCTime
09:22:00 <chrisdone> i think there's a package somewhere with instances for common data types
09:22:16 <chrisdone> http://hackage.haskell.org/package/quickcheck-instances-0.3.9/docs/Test-QuickCheck-Instances.html
09:22:44 <chrisdone> it seems to have UTCTime: https://github.com/aslatter/qc-instances/blob/master/src/Test/QuickCheck/Instances.hs#L289
09:23:15 <chrisdone> also Text
09:23:21 <bernalex> chrisdone: that does include UTCTime, so that's great
09:23:25 <chrisdone> https://github.com/aslatter/qc-instances/blob/master/src/Test/QuickCheck/Instances.hs#L110
09:23:33 <bernalex> his Text implementation is the exact same as mine :-]
09:23:43 <chrisdone> makes sense
09:23:49 <bernalex> thanks for the link, I'll just steal that then!
09:23:56 <bernalex> i.e. depend on it
09:23:58 <chrisdone> =)
09:27:43 <bernalex> hm. am I having a brainfart or what?
09:27:54 <bernalex> how do I actually make it find/understand the instances from that package?
09:28:23 <chrisdone> just import the module?
09:28:34 <bernalex> I mean with an explicit import
09:29:03 <liste> brenalex import Module()
09:29:10 <bernalex> aaah
09:29:13 <liste> imports just the instances
09:29:23 <bernalex> that was the brainfart I was speaking of. thanks!
09:29:29 <chrisdone> (゜。゜)
09:29:35 <liste> np
09:33:41 <bernalex> Test suite prop: PASS
09:33:45 <bernalex> liste: chrisdone: thanks guys
09:33:54 <chrisdone> welcome
09:34:24 <liste> no problem
09:47:31 <ski> thang1 : i did
09:47:44 <ski> (make it up, i.e.)
09:48:05 * ski doesn't really care for that particular concrete syntax, either
09:56:39 <sinelaw> dfeuer, about my SO q&a - why does my fix seem fragile? [1..10] :: [Int] is quite explicit
10:05:12 <pharpend> how do I define a factoid with lambdabot?
10:06:02 * hackagebot git-embed 0.0.1 - Use TH to embed Git repo information.  http://hackage.haskell.org/package/git-embed-0.0.1 (borsboom)
10:06:06 <monochrom> like "@where+ monochrom a very smart guy"
10:08:30 <sinelaw> any good sources for yes-cyclic unification?
10:09:01 <pavonia> I'm a bit lost with a problem about dates... Given a floating point number 0 <= t < 1, where t = 0 denotes January 1st of some year and t = 1 January 1st of the following year. Now I'm trying to find the date of a Friday that is the closest to the day represented by t.
10:09:28 <pavonia> Data.Time.Calendar.OrdinalDate seems to have some useful functions but I don't know how to put them together properly
10:10:11 <hpc> multiply t by the number of days in the year you are looking at
10:10:33 <hpc> round it and get the t-th day of that year
10:10:59 <hpc> then add a number based on the weekday
10:11:02 * hackagebot conduit-extra 1.1.5.1 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.5.1 (MichaelSnoyman)
10:11:14 <hpc> [(Friday, 0), (Saturday, -1), (Thursday, 1), ...]
10:12:42 <pavonia> Ah right, I don't even need to find the correct number of the week :/
10:12:43 <hpc> http://hackage.haskell.org/package/time-1.5/docs/Data-Time-Calendar-MonthDay.html -- see dayOfYearToMonthAndDay
10:13:33 <pavonia> Thank you, hpc!
10:23:23 <dfeuer> sinelaw, [1..10]::[Int] is explicit, but then it's turned to [Double], so you're relying on slightly better approximations, right?
10:23:49 <sinelaw> dfeuer, TimeDiff is not a floating point type
10:23:55 <sinelaw> DiffTime, whatever
10:24:09 <dfeuer> sinelaw, oh, so what am I missing? What was wrong with the original?
10:24:30 <sinelaw> DiffTime is a fixed-point with up to nano precision
10:24:50 <sinelaw> dfeuer, the original question? or what?
10:24:58 <dfeuer> sinelaw, yeah.
10:25:02 <dfeuer> I don't remember the details.
10:25:36 <sinelaw> it's just a pitfall, if you forget that DiffTime has nano-scale precision
10:25:43 <sinelaw> I expected [1,2,3] == [1..3]
10:26:03 * hackagebot wai-extra 3.0.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.3 (MichaelSnoyman)
10:26:07 <sinelaw> but [1..3] evalutes to all the values between 1 and 3, not just 1,2,3
10:30:32 <quxbam> can anyone point me to a minimal tutorial of atto-lisp?
10:36:03 * hackagebot retryer 0.1.0.0 - Small haskell app that takes a command, and continually re-runs it until it exits successfully  http://hackage.haskell.org/package/retryer-0.1.0.0 (dgonyeo)
10:40:56 <Tuplanolla> What would you recommend for parsing lots of Text without clear tokens and gathering data as I go? Parsec with State perhaps?
10:46:03 * hackagebot retryer 0.1.0.1 - Retry failed commands  http://hackage.haskell.org/package/retryer-0.1.0.1 (dgonyeo)
10:49:20 <trap_exit> is there something like jquery for nested ahskell data structures? i.e. I want to describe things like "select blah" or "select blah / modify it with foo"
10:49:50 <hpc> lens
10:52:57 <trap_exit> I don't think lens ever returns a list of elements
10:53:04 <trap_exit> jquery seems a bit more powerful on the query side
10:55:13 <Cale> any of the generic programming libraries
10:55:36 <Cale> e.g. syb
10:56:06 <monochrom> I don't understand why a list of elements is more powerful in this context.
10:56:39 <Cale> or uniplate
10:56:40 <monochrom> in fact in some cases I see that a list of elements is less powerful, not more.
10:57:23 <trap_exit> with lens I feel like you need to know the name of all the lements you are taking
10:57:23 <monochrom> for example, suppose your nested data structure is ((Int, Bool), Char), and you are querying for the Int there.
10:57:28 <trap_exit> in the 'path' from the root to the node in the tree
10:57:56 <monochrom> a good query would have type ((Int, Bool), Char) -> Int
10:59:05 <monochrom> a bad query would have type ((Int, Bool), Char) -> [Int]. why is this bad? because in all reality there is exactly one Int, but you insist on returning a list so the user has to deal with all other spurrious cases that shouldn't exist.
10:59:21 <joe9> Is there any way to get this definition to work: source: http://codepad.org/cpoxun4I , line with trouble: data Directory = FileSystemItem a => Directory Name Details (Map Name a) deriving Show
10:59:22 <k00mi> trap_exit: a Traversal can have multiple targets
10:59:50 <monochrom> ((Int, Bool), Char) -> [Int] is ambiguous and imprecise. this is why it is less powerful. less predictive power, to be exact. more unpredictable.
11:00:54 <chrisdone> trap_exit: check out `listify'
11:01:27 <chrisdone> very handy syb function for quickly grabbing a list of all things of a given type
11:01:41 <chrisdone> i'd link you to it but hackage is not loading properly for me
11:02:10 <sinelaw> How about this type for simple "objects":
11:02:10 <sinelaw> data Obj a = Obj { val :: a, method :: Obj a -> Int }
11:02:21 <chrisdone> http://www.stackage.org/haddock/2014-12-10-ghc78-exc/syb-0.4.2/Data-Generics-Schemes.html#v:listify
11:02:38 <sinelaw> let x = Obj { val = 0, method = \o -> val o }
11:03:04 <sinelaw> note "Obj" here is a recursive type
11:03:26 <shachaf> Oh boy, negative recursion.
11:03:51 <sinelaw> can one possibly write code that causes the compiler to infer such a type?
11:04:07 <sinelaw> without defining the type
11:04:47 <chrisdone> sinelaw: this is for type-checking javascript i take it
11:05:00 <sinelaw> chrisdone, yes
11:05:12 <sinelaw> my problem is the occurs check
11:05:33 <sinelaw> which I take is kinda worked around when explicitly defining recursive types
11:05:39 <hcore> i love haskell, was trying to map (read :: Int) over a list of strings and the solution is really just to tell haskell that map read takes a list of strings and returns a list of ints
11:05:50 <AleksejsHome> Hi, I did cabal install cabal-install, it showed that 1.20.* is installed, but 1.16 is still what is in path. How do I find where it installed 1.20?
11:06:03 <sinelaw> AleksejsHome, probably ~/.cabal
11:06:15 <sinelaw> check ~/.cabal/bin
11:06:28 <chrisdone> hcore: map (read :: String -> Int) also works
11:06:43 <AleksejsHome> sinelaw: yes, thanks!
11:06:52 <hcore> ooo so it does
11:07:00 <chrisdone> with the upcoming omissiong stuff i think you'll be able to write map (read :: _ -> String) because the _ is inferable
11:07:18 <hcore> at first i was trying to read x :: Int but that wouldn't work out
11:07:25 <hcore> upcoming changes to the haskell language?
11:07:36 <hcore> and that's even neater
11:07:36 <monochrom> (\x -> read x :: Int)
11:07:49 <hcore> a partially strict type?
11:07:52 <monochrom> because "read" alone is String -> Int, not Int alone
11:08:32 <monochrom> > map (\x -> read x :: Int) ["12", "13", "14"]
11:08:34 <lambdabot>  [12,13,14]
11:08:48 <hcore> monochrom, yeah im still wrapping my head around that but it makes sense now
11:09:25 <chrisdone> if lennart augustsson's proposal goes through, i think you could write map ((:: Int) . read)
11:10:23 <hcore> so haskell takes read x, infers String because that's what x is and then goes turns it into Int because we've told it that the type of read is Int
11:11:19 <hcore> that's cool but there's something so pretty about f :: [String] -> [Int] f = map read
11:11:43 <hcore> and f:: _ -> [Int] would be even neater
11:12:20 <chrisdone> https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures
11:12:28 <chrisdone> i can't access haskell.org at the moment, but i think that should be the right page
11:14:04 <hcore> chrisdone, yup, it is, thanks!
11:16:20 <monochrom> ((:: Int) . read) is scary and beautiful :)
11:16:53 <boostrez> Hey I'm trying to write a parser using parsec, that splits text into sentences
11:17:03 <boostrez> a sentence ends with a period or multiple newlines
11:17:11 <boostrez> one newline does not end a sentence
11:17:15 <boostrez> how do i do this?
11:17:29 <monochrom> it seems that you just need a regex
11:17:41 <monochrom> now of course parsec can do the equivalent of regex, too
11:18:07 <boostrez> Yeah, im using parsec because the parser will be more complicated later on
11:18:30 <boostrez> I can't figure out how to track if im hitting the second newline when i parse
11:18:59 <boostrez> I'm using attoparsec and takeWhile right now
11:20:01 <quxbam> count 2 '\n'
11:20:44 <jfischoff> is there a suffix tree package that has a values on the leafs? Something like https://hackage.haskell.org/package/suffixtree-0.2.2.1/docs/Data-SuffixTree.html but with a type like data STree a b = Node [Edge a b] | Leaf b
11:22:36 <boostrez> quxbam: not sure how to use that
11:25:22 <quxbam> well, i've used attoparsec yesterday the first time
11:25:40 <quxbam> but i think, you could do something like
11:26:08 <boostrez> is attoparsec greedy or non-greedy by default?
11:26:28 <quxbam> i think greedy
11:28:02 <quxbam> i would try
11:28:14 <ab9rf> attoparsec will do some backtracking.  parsec, iirc, does not.
11:28:24 <Phyx-> test
11:28:25 <Phyx-> hmm
11:28:29 <boostrez> play ill play around with it
11:28:41 <boostrez> ok ill*
11:28:44 <quxbam> sentence <- many anyChar <* char '\n'
11:28:56 <quxbam> but, i really don't know
11:29:34 <Phyx-> Hi all, I'm been having a bit of trouble with FFI I was hoping to get some help with, the code is http://lpaste.net/6240550441290039296 , the pointer I seem to be getting back in C is pointing at something NULL, but passing it back to another haskell function it works just fine..
11:29:49 <ab9rf> i've never written a meaningful parsec parser
11:29:57 <ab9rf> i ahve written meaningful attoparsec parsers :)
11:30:29 <ski> &wg 96
11:36:40 <joe9> error: http://codepad.org/7VqhEuiD, FileSystemItem.hs: http://codepad.org/T09Mx94j , testFileSystemItem.hs: http://codepad.org/zhpSYEC9 not sure if this type of data structures is even possible?
11:41:25 <joe9> Any thoughts, please?
11:43:25 <Welkin> how can I use Infinity?
11:43:43 <Welkin> for example, in a comparison
11:43:48 <Welkin> > Infinity > 0
11:43:50 <lambdabot>  Not in scope: data constructor ‘Infinity’
11:43:59 <Welkin> :i infinity
11:44:03 <Welkin> @i infinity
11:44:03 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password v @ ? .
11:44:10 <Welkin> :t infinity
11:44:11 <lambdabot> Natural
11:44:12 <sinelaw> shachaf, got a good resource on types with recursion in negative positions?
11:44:21 <Welkin> :t Infinity
11:44:22 <lambdabot> Not in scope: data constructor ‘Infinity’
11:44:39 <ClaudiusMaximus> > 1/0
11:44:40 <lambdabot>  Infinity
11:44:43 <Welkin> yes
11:44:46 <Welkin> but what is the type?
11:44:48 <Welkin> Integer?
11:44:49 <joe9> I get the same error when I change the Context to just a list of parent directories. I think it is something to do with insert of Map.
11:44:51 <Welkin> Fractional?
11:45:00 <ClaudiusMaximus> Floating i guess
11:45:04 <Welkin> well, Fractional a
11:45:19 <ClaudiusMaximus> Ratio is Fractional, but has no infinity
11:45:22 <Welkin> > 1/0 + 3
11:45:24 <lambdabot>  Infinity
11:45:28 <Welkin> > 1/0 > 0
11:45:30 <lambdabot>  True
11:45:33 <Welkin> > -1/0 > 0
11:45:35 <lambdabot>  False
11:45:40 <Phyx-> :t read
11:45:41 <lambdabot> Read a => String -> a
11:45:47 <Welkin> > -1/0 > (0 :: Double)
11:45:49 <lambdabot>  False
11:45:57 <Welkin> > -1/0 > (0 :: Integer)
11:45:58 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
11:45:58 <lambdabot>    arising from a use of ‘GHC.Real./’
11:46:13 <ClaudiusMaximus> > -1/0 > (0 :: Rational)
11:46:14 <lambdabot>  *Exception: Ratio has zero denominator
11:46:38 <Welkin> > -1/0 > (0 :: Ratio)
11:46:39 <Phyx-> > read "Infinity"::Double
11:46:39 <lambdabot>  Expecting one more argument to ‘GHC.Real.Ratio’
11:46:39 <lambdabot>  Expected a type, but ‘GHC.Real.Ratio’ has kind ‘* -> *’
11:46:40 <lambdabot>  Infinity
11:46:47 <Welkin> ah
11:46:48 <Phyx-> > read "Infinity"::Float
11:46:50 <lambdabot>  Infinity
11:47:13 <Welkin> so there is no way to write Infinity in a computation
11:47:37 <Welkin> other than implicitly through another computation
11:47:45 <Phyx-> not really sure, but you can always bind it to a variable and use that
11:48:14 <Welkin> let a = Infinity in a
11:48:19 <Welkin> > let a = Infinity in a
11:48:21 <lambdabot>  Not in scope: data constructor ‘Infinity’
11:48:21 <Phyx-> :t infinity
11:48:22 <lambdabot> Natural
11:48:27 <Phyx-> > infinity
11:48:33 <lambdabot>  mueval-core: Time limit exceeded
11:48:33 <lambdabot>  mueval: ExitFailure 1
11:48:39 <Welkin> hah
11:48:53 <Phyx-> prelude defined "infinty"
11:48:56 <Phyx-> as a Rational
11:49:01 <Phyx-> :t notANumber
11:49:02 <lambdabot>     Not in scope: ‘notANumber’
11:49:02 <lambdabot>     Perhaps you meant one of these:
11:49:02 <lambdabot>       ‘IM.notMember’ (imported from Data.IntMap),
11:50:12 <Welkin> hm
11:50:18 <Welkin> > 3 + mzero
11:50:20 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
11:50:20 <lambdabot>    arising from a use of ‘M117234451127904534522387.show_M1172344511279045345...
11:50:20 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
11:50:25 <Welkin> > 3 <> mzero
11:50:26 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
11:50:26 <lambdabot>    arising from a use of ‘M48435487181766437122401.show_M48435487181766437122...
11:50:26 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
11:50:46 <Welkin> > 3 <> mzero :: Integer
11:50:48 <lambdabot>  Couldn't match expected type ‘GHC.Integer.Type.Integer’
11:50:48 <lambdabot>              with actual type ‘m0 a0’
11:51:02 <Welkin> > (3 :: Integer) <> mzero
11:51:03 <lambdabot>  Couldn't match expected type ‘GHC.Integer.Type.Integer’
11:51:03 <lambdabot>              with actual type ‘m0 a0’
11:51:19 <Welkin> is there a bottom for numbers?
11:51:29 <glguy> Please experiment with the not in /msg
11:51:38 <glguy> Bot*
11:53:07 <glguy> mzero is the operation from MonadPlus. mempty is the one from Monoid. Integer can't be an instance of the first and isn't an instance if the second
12:03:01 * flaggy is trying to wrap his head around mfix
12:05:36 <lpaste> hcore pasted “No title” at http://lpaste.net/1377862127447965696
12:06:05 <stephen_> What's the best way to install a legacy version of the base libraries? I tried "$ cabal install base==4.6.0.1" but it fails with "rejecting: base-4.6.0.1 (only already installed instances can be used)"
12:07:21 <dcoutts_> stephen_: only way is to install and old ghc
12:07:48 <dcoutts_> stephen_: as the error message says, base cannot be installed from source, only already installed instances can be used
12:08:08 <Phyx-> I've always wondered why base is on hackage..
12:08:24 <Phyx-> is it just for the dependency resolution?
12:09:36 <dcoutts_> Phyx-: it's for the documentation
12:09:48 <Phyx-> ah ok, makes sense
12:10:20 <dcoutts_> think of all the types defined in base that crop up in other apis
12:11:24 <Phyx-> Yeah, and it's a good way to quickly look into the source
12:12:17 <stephen_> Alright, nice, I'll build the old version from the AUR git repo.
12:14:42 <stephen_> Hmm, if I were to avoid downgrading, how should I make sure that a package with ancient dependencies listed will still work?
12:26:47 <Phyx-> mhmm,, anyone have any ideas for me how to go about finding out why I can't read the Ptr value in C?, I haven't gotten very far using gdb
12:30:09 <flaggy> vs <- mfix (\ ~vs -> do { ss; return vs }) What is ~vs?  What does ~ mean?
12:30:26 <shachaf> @where hoogle will search for syntax like that
12:30:26 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
12:30:46 <JokerDoom> I'm learning functional programming by experimenting with a few different languages, and I was wondering if anyone could point me to a good analysis of the differences between Haskell and say F#, it seems like both are extremely powerful, and I am more drawn to F# at present, but I also get the feeling the Haskell is more powerful, but I'm having trouble searching out this intuition
12:31:07 * hackagebot json-extra 0.1.0.0 - Utility functions to extend Aeson  http://hackage.haskell.org/package/json-extra-0.1.0.0 (TobiasDammers)
12:32:18 <flaggy> I tried @where ~ on hoogle: Parse error: (line 1, column 9): unexpected end of input expecting "*", "(", letter or "::" Combination of operators and names
12:32:21 <hpc> flaggy: it means the match always "succeeds"
12:32:33 <hpc> and if it doesn't, that's on your head
12:33:02 <hpc> > let foo ~(Just x) = 6 in foo undefined
12:33:03 <lambdabot>  6
12:33:07 <hpc> > let foo ~(Just x) = x in foo undefined
12:33:08 <lambdabot>  *Exception: Prelude.undefined
12:33:12 <hpc> > let foo ~(Just x) = x in foo Nothing
12:33:14 <lambdabot>  *Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern (Da...
12:33:16 <shachaf> flaggy: No, @where is a lambdabot command. Just type ~ into Hoogle.
12:33:52 <hpc> in that specific case, i am not sure if the tilde is even needed
12:34:52 <flaggy> I see, thanks. It's mostly just to avoid a compiler warning when you know the pattern matching will succeed, right?
12:34:54 <shachaf> It isn't.
12:35:04 <hpc> it changes the semantics
12:35:10 <hpc> see the examples i gave to lambdabot
12:35:23 <shachaf> Those were pretty confusing examples.
12:35:31 <flaggy> hm
12:35:37 <shachaf> Fortunately the documentation that Hoogle links to is clearer.
12:35:56 <shachaf> The page it links to is https://www.haskell.org/haskellwiki/Keywords#.7E
12:37:29 <hpc> it's missing the other half of (~), where if the pattern match actually happens and fails, you get an error
12:39:47 <flaggy> I get it now. With that out of the way, let's see if I can get mdo figured out :P
12:42:53 <Snoxicle> hello?
12:43:46 <Snoxicle> I was wondering if anybody with more experience could point me in the right direction. I'm tryna deal with files but it seems writting to a file after readFile'ing it isn't perfect
12:44:09 <hpc> http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#v:readFile
12:44:13 <hpc> "The file is read lazily, on demand, as with getContents."
12:44:36 <hpc> when you do a readFile, the whole file isn't read right away
12:44:49 <Snoxicle> Well I do something like this: writeFile "somefile" =<< readFile "otherfile"
12:44:55 <Snoxicle> With a JPG
12:45:07 <hpc> that should work
12:45:08 <Snoxicle> And the output is still a valid JPG but the colours are all messed up
12:46:03 <hpc> you should read it in binary mode in case it's munging newlines(which you need Handle operations for)
12:46:22 <hpc> or use similar functions from ByteString to do what you want
12:47:21 <Snoxicle> K, how can I open it in binary mode? I saw some other functions which seemed more heavyweight (being me I just went for the easy readFIle/writeFile option) so I'm guessing that's how
12:47:30 <Snoxicle> Well thanks
12:47:59 <lericson> :t (=<<)
12:48:00 <lambdabot> Monad m => (a -> m b) -> m a -> m b
12:48:10 <lericson> @pl flip (>>=)
12:48:10 <lambdabot> (=<<)
12:51:08 * hackagebot rncryptor 0.0.2.0 - Haskell implementation of the RNCryptor file format  http://hackage.haskell.org/package/rncryptor-0.0.2.0 (AlfredoDiNapoli)
12:58:37 <monochrom> you will find that "f ~(Just x) = x" and "g (Just x) = x" behave the same. this is not where ~ makes a difference.
12:59:04 <monochrom> "f ~(Just x) = True" and "g (Just x) = True", however, will behave different.
12:59:25 <thomie> joe9: http://stackoverflow.com/questions/20997745/how-do-i-make-an-heterogeneous-list-in-haskell-originally-in-java
13:06:09 * hackagebot json-extra 0.1.0.1 - Utility functions to extend Aeson  http://hackage.haskell.org/package/json-extra-0.1.0.1 (TobiasDammers)
13:06:14 <thomie> joe9: don't try to store values of different type in a Map. Try 'Map Name Directory' instead
13:08:36 <monochrom> "fix (\ ~(x,y) -> (0:y, 1:x))" and "fix (\ (x,y) -> (0:y, 1:x))" give a glimpse of why ~ is needed
13:09:58 <monochrom> that may be a pretty involved example. you have to really know recursion to see what's going on.
13:11:10 <monochrom> "f ~(Just x) = (True, x)" and "g (Just x) = (True, x)". now ask for "fst (f undefined)" and "fst (g undefined)". this is a more transparent comparison.
13:11:52 <monochrom> I wonder if "\~(x,y)" is accepted
13:12:31 <monochrom> > let (xs, ys) = fix (\~(x,y) -> (0:y, 1:x)) in (take 4 xs, take 4 ys)
13:12:33 <lambdabot>  <hint>:1:29: parse error on input ‘->’
13:13:10 <monochrom> > let (xs, ys) = fix (\ ~(x,y) -> (0:y, 1:x)) in (take 4 xs, take 4 ys)
13:13:12 <lambdabot>  ([0,1,0,1],[1,0,1,0])
13:13:33 <monochrom> this is interesting lexing
13:14:35 <monochrom> ah, haskell.org is conveniently slow today
13:15:08 <monochrom> "he who waits for haskell.org to finish loading has the last laugh"
13:19:10 <monochrom> ah, if \\ is a legal operator, then \~ ought to be too. damn the Haskell committee.
13:19:53 <monochrom> this is the problem when programs are plain text files.
13:20:38 * monochrom is now known as monolog
13:21:06 <malllle> :D
13:21:28 <koala_man> monochrom: here's a reply so you can justify continuing
13:21:39 <lpaste> fluvian pasted “UseHandle failure” at http://lpaste.net/116399
13:21:58 <monochrom> actually it's time for tea so I'm afk
13:22:05 <fluvian> I'm not sure why I get a "pattern match failure" from this code.
13:22:18 <fluvian> There is no more info in the error message.
13:25:01 <fluvian> It seems very unintuitive that System.Process (createProcess) uses StdStream as inputs but Handle for outputs.
13:27:08 <malllle> @type (>=>)
13:27:09 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:35:06 <sedeki> damn, big channel
13:37:52 <flaggy> This thesis is amazing: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.1543 the use of Monads to abstract between draw and simulation should be in every introduction to monads article :)
13:41:10 * hackagebot binary 0.7.2.3 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.7.2.3 (LennartKolmodin)
13:49:34 <dfeuer> carter, I had a crazy, crazy idea that will probably either give magically amazing performance for <*> or be completely impossible to implement. I don't think there's much in between.
13:50:02 <thomie> fluvian: second createProcess returns (Nothing, .., .., ..)
13:50:59 <arog> hi everyone
13:51:16 <johnw> dfeuer: what is your idea?
13:51:20 <carter> oh?
13:52:15 <thomie> fluvian: also, use -Wall
13:52:38 <monochrom> magical performance are usually impossible to implement, yes :)
13:52:41 <Groutcho> I have the following function : max' :: Ord a => [a] -> Maybe a, and the first pattern : max' [] = Nothing. But ghc yells at me :  No instance for (Ord a0) arising from a use of max'. What should I do ?
13:53:02 <shachaf> Groutcho: Yells at you when you do what?
13:53:03 <dfeuer> johnw, this is for Data.Sequence.Seq. carter, the idea is to turn the second (right) argument into a 2-3 tree. Thinking backwards, from the bottom up (which is ultimately wrong, but not horrible), do something fmap-like to the left argument to replace the leaves with the appropriate 2-3 trees, and make all the size annotations atch.
13:53:11 <dfeuer> *match.
13:53:22 <shachaf> Groutcho: You should post your full code and full error message (on hpaste.org).
13:53:24 <Groutcho> shachaf : when I do max' []
13:53:27 <Groutcho> okay
13:53:31 <dfeuer> Then "stretch" the ends of the tree out using "splitTree" to make a proper sequence.
13:53:45 <shachaf> Groutcho: Oh, well, it's not sure what type [] has.
13:53:58 <shachaf> Groutcho: Try max' ([] :: [Int]) or something
13:54:03 <Groutcho> shachaf, indeed, is there a way to hint ghc on the type inference ?
13:54:11 <Groutcho> okay thanks
13:54:16 <dfeuer> Like I said, that's a bit backwards, and there's probably a way to do it forwards, but even that should give much better results than the current implementation. If, as I said, it is possible at all.
13:54:50 <monochrom> some handwritten types are necessary to resolve "but really, which instance do you want?"
13:55:11 <Groutcho> shachaf : it worked, thank you
13:56:17 <arog> hey could someone help me make (filter ((== snd a).fst) b)  work for tupels like   ((a1,a2),a3) and  [((b1,b2),b3)] it should be something like (filter ((== snd (first a)).fst fst) b) ?
14:01:58 <HeladoDeBrownie> arog, you might be better off writing it out explicitly as a lambda, pattern matching the nested tuples
14:02:21 <HeladoDeBrownie> filter (\((a1, a2), a3) -> ...)
14:02:42 <HeladoDeBrownie> That way when you come back to it later, I think you'll be more likely to know what's going on :)
14:02:54 <gedringer> Hey guys
14:03:19 <arog> okay i give it a try , ty
14:03:29 <gedringer> Can someone help me finish my last section of my insertion method for 2-3-4 tree?
14:03:53 <gedringer> I know I need to trace back up the tree to the parent to keep organizing the code but I can't figure it out
14:03:58 <gedringer> I have this so far
14:04:00 <gedringer> http://pastebin.com/BMTmjx2H
14:04:53 <gedringer> So I need to work on insertToTree key (FourNode a b c mostLeft left right mostRight)
14:06:03 <gedringer> So I have to split the FourNode into three node, take the mid value and push it up to the parent, if parent is ThreeNode then format it to Fournode and it's over, unless the parent is also a FourNode in which case I have to replace a value and keep going up to its parrent etc..
14:17:48 <Phyx-> Ok.. let's try this again.. I'm been having a bit of trouble with FFI I was hoping to get some help with, the code is http://lpaste.net/6240550441290039296 , the pointer I seem to be getting back in C is pointing at something NULL, but passing it back to another haskell function it works just fine..
14:20:56 <carter> Phyx-: are you meaning to export?
14:21:07 <carter> or are you meaning to import
14:21:13 <Phyx-> carter: I'm meaning to export
14:21:27 <carter> did you call hs_init or whaever first?
14:21:34 <Phyx-> carter: yes
14:21:36 <gedringer> Anyone able to help me with continuation passing in haskell? :3
14:22:00 <Phyx-> carter: the call itself works, I get a pointer back, just can't dereference it in C
14:22:14 <gedringer> I need to traverse my tree upwards but don't know how to store my parent :(
14:23:40 <dfeuer> carter, my brain is getting a little confused. I hope I can get it untangled.
14:23:40 <carter> Phyx-: ... testFoo :: Int -> Foo
14:23:50 <carter> Phyx-: that is not the type youre telling C
14:24:02 <dfeuer> gedringer, the way that's usually done in Haskell is to use something called a "zipper".
14:24:22 <carter> oh
14:24:25 <Phyx-> carter: correct, i'm telling it testFooA, which converts between the C and Haskell values
14:24:34 <dfeuer> gedringer, Learn You a Haskell has a very good explanation of zippers.
14:24:35 <carter> Phyx-: how are you allocating it
14:24:51 <carter> help me undestand that
14:24:52 <gedringer> dfeuer: thank you!!! :D
14:25:23 <dfeuer> gedringer, if you really want to be going up and down, that is. sometimes you can actually work top-down and that's more efficient.
14:26:15 <carter> Phyx-: wheres new defined/
14:26:20 <carter> @source new
14:26:20 <lambdabot> Unknown command, try @list
14:26:24 <carter> @src new
14:26:24 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:26:45 <dfeuer> carter, if you come over here and help me with this thing, I'll give you hot chocolate made from high-quality chocolate, and also pizza.
14:27:05 <carter> ahh
14:27:08 <carter> dfeuer: ok
14:27:10 <johnw> gedringer: Do you still want help with continuation passing?
14:27:12 <carter> tlak it out
14:27:15 <carter> *talk it out
14:27:16 <dfeuer> :)
14:27:20 <Phyx-> carter: I'm creating an enum to specify which constructor is being used, that's the first 4 bytes, then i'm reserving enough space for the largest constructor using malloc, I write the value of foo to the new pointer, and then wrote the enum value and the new pointer to the pointer given to me in poke
14:27:37 <carter> Phyx-: where are you mallocing?
14:27:42 <Phyx-> carter: new is in Foreign.Ptr I think
14:27:54 <Phyx-> carter: line 71 and 78
14:28:04 <gedringer> well johnw the thing is, I normally will work going downwards untill I stumble upon a node with 3 values in which case I have to go to parent and work with parent and the current node
14:28:11 <gedringer> will continuation passing do the trick?
14:28:23 <carter> Phyx-: its not in the dos
14:28:26 <dfeuer> carter, for the "is there any hope?" test, I want to replace each (Elem f) with (Node2 (Elem f x1) (Elem f x2))
14:28:33 <gedringer> but I might have to go up the tree couple of times as say my 3 nodes in a row might be 4-nodes
14:28:39 <dfeuer> Er ...
14:28:48 <Phyx-> carter: new :: Storable a => a -> IO (Ptr a)
14:28:56 <Phyx-> it's in Foreign.Marshal.Utils
14:29:01 <dfeuer> Sorry, I mean  replace each (Elem f) with (Node2 2 (Elem f x1) (Elem f x2))
14:29:10 <gedringer> so I might need to keep track of my tree upwards even up till my parent, and if by any chance i reach my root and still have to go up, then U have to create a new root
14:29:39 <dfeuer> And for each Node2 with a Node child, I want to double its size annotation.
14:30:05 <johnw> gedringer: a zipper may indeed suit you better,  but I wouldn't be able to say for sure until I had actually tried to write code
14:30:10 <carter> how does that preserver the count?
14:30:37 <Phyx-> carter: count?
14:30:43 <gedringer> from what I've heard now I think zipper will do :P I'm reading bout it now :P
14:30:43 <carter> Phyx-: i'm talking with df now
14:30:49 <Phyx-> ah ok
14:31:07 <dfeuer> gedringer, devils lie in details, most of the time.
14:31:12 <carter> Phyx-: i think bgamari  could help
14:31:23 <gedringer> :P
14:31:39 <dfeuer> carter, it doesn't preserve the count. It turns the tree into one with twice as many elements.
14:31:47 <carter> oh
14:31:50 <carter> what does?
14:31:52 <carter> why
14:31:58 <dfeuer> My operatin I'm trying to write.
14:32:13 <dfeuer> Well, I was thinking about  fs <*> fromList [x1,x2]
14:32:25 <carter> ohh
14:32:33 <boostrez> I can't figure out how to 'remember' the number of newlines I hit when using attoparsec
14:32:39 <dfeuer> What if I turn fromList [x1,x2] into a 2-3 tree?  Node2 2 x1 x2
14:32:50 <dfeuer> And then replace as described above?
14:32:52 <Phyx-> carter: ok, thanks for trying. If it helps the C struct i'm marshaling to is http://lpaste.net/6082622234663321600 . ANd I'm pretty sure this used to work before. last time I used it was in the late 6.x early 7.x ghcs. which is why I asked in #GHC
14:32:53 <boostrez> I need to match when I hit two in a row, but not when its only one
14:33:08 <carter> Phyx-: i'm already pretty out of it today
14:33:28 <carter> Phyx-: if you had a full running repro that'd be ideal of course
14:34:08 <carter> Phyx-: but this might be suitalbe for ghc-users emaling
14:34:11 <dfeuer> carter, every non-empty sequence can be expressed as a 2-3 tree at *some* depth. If I can make this work out, I think I should be able to get the asymptotics *and* the constant factors, which is what I meant by magic.
14:34:25 <Phyx-> carter: I do, I've narrowed it down to 1 haskell file and 2 c files.
14:35:16 <dfeuer> carter, I need to go cook half a pumpkin. I'll be back!
14:35:16 <carter> woot
14:35:25 <carter> yum
14:36:12 * hackagebot base-prelude 0.1.8 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.8 (NikitaVolkov)
14:36:20 <indiagreen> chrisdone: could #haskell-lens be added to ircbrowse.net?
14:38:20 <chrisdone> indiagreen: ask edwardk
14:39:17 <indiagreen> but if edwardk agrees, you don't have any objections?
14:41:12 * hackagebot time 1.5.0.1 - A time library  http://hackage.haskell.org/package/time-1.5.0.1 (AshleyYakeley)
14:51:31 <osa1> any ideas what does that mean "hpc: can not find Main in ["./.hpc"]" ?
14:52:35 <osa1> I installed my library with --enable-library-coverage and then run the test suite. this is happening when I run hpc on generated tix file
14:52:40 <chrisdone> indiagreen: i know he won't =)
14:52:54 <indiagreen> why?
14:53:05 <chrisdone> indiagreen: ask edwardk
14:53:22 * indiagreen finds this kinda mysterious
15:01:13 * hackagebot tdoc 0.4.6 - TDoc is a typed document builder with support for (X)HTML  http://hackage.haskell.org/package/tdoc-0.4.6 (NicolasPouillard)
15:03:15 <alem0lars> In XMonad using the function 'spawnOn' how can I get the pid of the spawned process?
15:13:46 --- mode: card.freenode.net set +o ChanServ
15:21:44 <Gurkenglas> http://pastebin.com/pHpguX6N <- Troubles with installing diagrams. (The computer may or may not have been "turned off" during the first command execution.)
15:22:45 <dmwit> Have you made sure to install LLVM like it says?
15:24:02 <kadoban> Is it me, or are chains of (.) kind of awkward to write in reverse? Has anyone done something like using some other name for (flip (.)) and then having their editor automatically reverse it into the usual (.)s ?
15:24:55 <dfeuer> carter, my brain seems to be working a bit better now. I think I got phase 1, the map-like thing, working.
15:25:03 <carter> sweeet!
15:25:35 <carter> @tell osa1 ttuegel  and I just tracked this won
15:25:35 <lambdabot> Consider it noted.
15:25:54 <carter> @tell osa1 just tracked it down
15:25:54 <lambdabot> Consider it noted.
15:26:35 <dmwit> kadoban: lens has another name for flip (.), I think, though I don't recall what it is
15:26:38 <dmwit> kadoban: (&), perhaps?
15:26:42 <dfeuer> carter, I predict the biggest challenge, if any of this really works, will be turning my upside-down thing right-side up. My plan is to try to write simple special cases first, and then see if I can find a way to generalize.
15:27:11 <carter> dfeuer: you're a better scientist that I
15:27:15 <dmwit> kadoban: I used (>>>) for a while (which is also flip (.)), but it's much more cumbersome to type than (.), and as stupid as that sounds I slowly stopped using it for that reason.
15:27:16 <carter> *computer scientist
15:27:24 <dfeuer> How's that, carter?
15:27:34 <carter> thats how computer science folks work
15:27:39 <kadoban> dmwit: Oh okay, thanks. That's one step of it. I'll try using that for a while. It just seems to much easier to write...
15:27:40 <dfeuer> Oh.
15:27:40 <carter> we solve all the easy problems
15:27:47 <carter> first
15:27:59 <carter> then we abstract
15:28:02 <dfeuer> I'm starting with 2.
15:28:06 <carter> cool
15:28:11 <dfeuer> Next will be 3, which should be the same.
15:28:23 <dfeuer> Then I'll look at 4--9.
15:28:58 <dfeuer> Then 10--27, probably.
15:29:56 <dmwit> 2?
15:29:59 <dmwit> is that even a number?
15:31:52 <shachaf> dmwit: If only lens had a name for flip (.). (&) is flip ($)
15:32:00 --- mode: card.freenode.net set +o ChanServ
15:32:07 <shachaf> I'm much less fond of it.
15:32:25 <dmwit> oh, dang
15:32:31 <shachaf> And now someone got (&) into base.
15:32:34 <shachaf> What a disaster.
15:32:49 <dmwit> P.S. I actually have no idea what "step 2" is for library proposals. Do you?
15:33:20 <Welkin> it's ???
15:33:25 <Welkin> after that, Profit!
15:33:27 <dmwit> (Step 1 was explain the problem and nobody complains.)
15:33:47 <shachaf> dmwit: I think it might be "make a Trac ticket".
15:33:55 <shachaf> That's what hvr kept bugging me to do about my proposal.
15:34:03 <nkar> shachaf: re &: what does it do?
15:34:07 <Welkin> what is happening with the PRelude anyway?
15:34:10 <shachaf> x & f = f x
15:34:14 <shachaf> It's terrible.
15:34:23 <Welkin> I find myself ignoring the prelude more and more
15:34:35 <nkar> shachaf: why?
15:34:39 <Welkin> and importing directly from the various modules
15:35:17 <dmwit> shachaf: Okay, will do. Thanks.
15:35:28 <shachaf> dmwit: What's the change you're talking about?
15:35:40 <dmwit> make asProxyTypeOf more polymorphic
15:35:51 <int-e> > (*2) <&> (+1) $ 100
15:35:53 <lambdabot>  201
15:36:09 <dmwit> :t (<&>)
15:36:10 <lambdabot> Functor f => f a -> (a -> b) -> f b
15:36:11 <shachaf> Oh, that.
15:36:26 <shachaf> dmwit: I think that's small enough that you could also just submit a patch directly.
15:36:28 <dmwit> Cute. Where's (<&>) from? C.Applicative?
15:36:37 <shachaf> Not that I know.
15:36:43 <shachaf> No, it's from lens.
15:36:53 <shachaf> If you already define (&) you might as well define (<&>)
15:36:59 <dmj`> flip fmap = (<&>)
15:37:15 <Welkin> why so many extraneous operators?
15:37:23 <dmwit> Aha! So I was right after all.
15:37:26 <shachaf> Why so many extraneous comments?
15:37:32 <Welkin> why not just use flip to make it explicit what is happening?
15:37:32 <int-e> dmwit: that was a direct reply to "If only lens had a name for flip (.)."
15:37:41 * dmwit thinks of that famous joke, "I thought I was wrong once, but I wasn't..."
15:37:45 <codygman> 2 Things: Could I turn 'printPermsToRoot' into something with foldM? Can I get some feedback on this code? code: http://lpaste.net/116403
15:38:00 <shachaf> dmwit: True, I guess (<&>) is flip (.)
15:38:18 <dmwit> int-e: If only IRC were threaded.
15:38:39 <int-e> dmwit: I guess I could've provided more context.
15:38:52 <mhl> I am now trying to use optparse-applicative for argument parsing. Is there a way to tell that two arguments are mutually exclusive?
15:38:53 <int-e> :t id -- but do comments work here?
15:38:54 <lambdabot> a -> a
15:39:20 <dmwit> int-e: (It looked like it could easily have been a response to the original query about "flip (.)", which was lens-agnostic.)
15:39:51 --- mode: card.freenode.net set +o ChanServ
15:39:53 <mhl> Or do I have to use optional from Alternative, and then manually check whether there are both of these arguments?
15:40:09 <dmwit> mhl: While negation does preserve regularity of a language, unfortunately most regex libraries don't offer it as an operation.
15:40:21 <int-e> dmwit: I'm glad we clarified that ;-)
15:40:36 <shachaf> int-e: Do you know how :t is implemented?
15:40:50 <shachaf> That sort of thing might scare one off running lambdabot.
15:41:20 <int-e> shachaf: yes. it invokes ghci, loads the L module, and then invokes :type  there. then it filters the output, trying to make it pretty.
15:41:25 <dmwit> codygman: You could use foldM, but maybe even mapM is better.
15:41:38 <pyed> :t foldM
15:41:39 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
15:41:48 <shachaf> It also filters newlines off the input.
15:42:06 <dmwit> codygman: Use "until" to generate the list of ever-shorter directories.
15:42:07 <shachaf> "stripComments ('\n':_)    = [] -- drop any newwline and rest. *security*"
15:42:08 <dmwit> :t until
15:42:09 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
15:42:14 <int-e> shachaf: I've thought about cleaning that code up but so far I have not worked up the courage to actually do it.
15:42:22 <shachaf> I'm not really confident about this \rainbow{security} claim.
15:42:37 <dmwit> Oops, not "until". =P
15:43:11 <int-e> shachaf: there's nothing running on that VM besides lambdabot, so it's *probably* fine.
15:43:20 <shachaf> OK then.
15:43:39 <shachaf> That's better than things used to be.
15:45:01 <nkar> shachaf: you haven't answered. what's wrong with (&)?  the fact that it doesn't "scale," e.g., you can't write 3&2&(+)?
15:47:30 <codygman> dmwit: My mind refuses to understand what I would be mapping over. How could I map over the ever-shorter directories? Ah, I would be mapping over (reducingFunction filePath) or similar?
15:47:56 <dmwit> codygman: Yep, the list to map over is something like ["/foo/bar", "/foo", "/"].
15:48:00 <int-e> shachaf: (the horrible :t code is also why lambdabot doesn't have a :i yet; following the same implementation route, :i needs to be quite a bit more clever about filtering the output.
15:48:01 <dfeuer> carter, the case for 2 works!
15:48:04 <int-e> )
15:48:06 <dmwit> codygman: Which is pretty easy to construct in a completely pure way.
15:48:14 <dfeuer> Perfectly.
15:48:22 <carter> woot
15:49:16 <dfeuer> carter, well, I mean the "upside down" version works. I still have to try turning it right side up.
15:49:39 <codygman> > mapM_ print (until (== "/") takeDirectory "/home/cody")
15:49:40 <lambdabot>  Not in scope: ‘takeDirectory’
15:50:12 <int-e> @type until
15:50:13 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
15:50:19 <dmwit> codygman: You might also like Numeric.readIntAtBase and Numeric.showInt
15:52:20 <dmwit> > let takeDirectory "/" = "/"; takeDirectory xs = reverse . drop 1 . dropWhile (/="/") . reverse $ xs in takeWhile (/= "/") . iterate takeDirectory $ "/foo/bar/baz"
15:52:22 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘GHC.Types.Char’
15:52:22 <lambdabot>  Expected type: [GHC.Types.Char]
15:52:22 <lambdabot>    Actual type: [[GHC.Types.Char]]Couldn't match type ‘GHC.Types.Char’ with ‘...
15:52:34 <dmwit> youch, what's with the GHC.Types clutter?
15:52:59 <dmj`> Is it safe to say that when type classes are defined, they are always assumed to be of kind * unless o/w specified or inferred?
15:53:23 <dmwit> ?let takeDirectory "/" = "/"; takeDirectory xs = reverse . drop 1 . dropWhile (/= "/") . reverse $ xs
15:53:24 <lambdabot>  .L.hs:167:5:
15:53:24 <lambdabot>      Couldn't match type ‘[Char]’ with ‘Char’
15:53:24 <lambdabot>      Expected type: [Char]
15:53:34 <dmwit> ?let takeDirectory "/" = "/"; takeDirectory xs = reverse . drop 1 . dropWhile (/= '/') . reverse $ xs
15:53:37 <lambdabot>  Defined.
15:53:50 <dmwit> > takeWhile (/= "/") . iterate takeDirectory $ "/foo/bar/baz"
15:53:52 <lambdabot>  ["/foo/bar/baz","/foo/bar","/foo","","","","","","","","","","","","","","",...
15:54:10 <dmwit> Okay, my implementation of takeDirectory isn't so hot. =)
15:54:54 <dmwit> dmj`: Er, "unless otherwise specified or inferred" pretty much means it's not safe to assume they're of kind *, right?
15:54:58 <dmwit> I mean that's a pretty big loophole.
15:55:04 <dmwit> "I assume they're of kind * unless they're not."
15:55:38 <dmj`> dmwit: here's an example
15:55:38 <dmj`> class Mutation m where; type Ref m :: * -> *
15:56:05 <dmj`> if I try to declare an instace for that instance Mutation IO; type Ref IO = IORef
15:56:16 <dmwit> Should work fine, with appropriate extensions.
15:56:31 <dmj`> I get: http://lpaste.net/116408
15:56:42 <dmwit> Turn on PolyKinds.
15:56:59 <dmwit> (In the module that defines the class.)
15:57:21 <dmj`> if I wrote out the functions in the typeclass body yes, it seems to infer it. But o/w I have to say class Mutation (m :: * -> *) where ..
15:57:33 <dmj`> and explicitly declare the kind
15:57:49 <codygman> dmwit: That works with the takeDirectory I have ;)
15:57:52 <dmwit> In H98 and H2010, there is a clause in the Report that says kinds which might otherwise be polymorphic are monomorphed to *.
15:57:52 <dmj`> dmwit: can types of the same kind only be associated?
15:58:04 <dmj`> dmwit: Ah, very cool :)
15:59:00 <dmwit> I'm not sure I understand the question, "Can types of the same kind only be associated?".
16:00:08 <dmwit> It might mean, "Do associated types have to have the same kind as their arguments?", in which case the answer is definitely "no".
16:02:35 <dmj`> that's awesome
16:02:38 <dmj`> dmwit: thank you
16:03:39 <dmj`> dmwit: can you specify the kind of the argument?
16:03:49 <dmj`> can you *only* specify the kind of the argument
16:05:17 <dmwit> type Foo (a :: k)
16:05:49 <dmwit> But why restrict it?
16:09:38 <dmj`> dmwit: true, guess the kind is inferred when the instance is defined. class Mutation m where; type Ref m :: (* -> *) -> *, so that could say Ref is a type function that takes a type constructor of kind (* -> *) and returns a concrete type
16:10:02 <RyanGlScott> Is there a way to reify what typeclasses a data type is an instance of using Template Haskell (i.e., like the :info command in GHCi)?
16:10:18 <dmwit> dmj`: Again, why restrict it?
16:10:28 <dmwit> dmj`: Why not just let it be polymorphic?
16:10:47 <dmwit> dmj`: Just turn on PolyKinds in the module that defines class Mutation and let GHC do its thang.
16:11:26 <dmj`> RyanGlScott: when you reify a typeclass the instances will be in there
16:11:32 <dmj`>  ClassI _ instances <- reify typ
16:11:37 <dfeuer> OK, carter, I got the 2 case right side up. Tell me if I'm driving you batty with the Twitter-like updates :-P
16:11:53 <carter> dfeuer: you should have seen how much i tweeted last year
16:12:00 <RyanGlScott> dmj`: Right, but can you do it the other way around? Reify a data type, and be given all of the typeclasses it inhabits as an instance.
16:12:27 <dmj`> dmwit: I'm not sure why we'd restrict it, just pondering, will let it do its thang :P
16:12:49 <RyanGlScott> dmj`: Something like reifyInstances dat >>= \(TypeClassTableI ...) -> ...
16:12:59 <shachaf> nkar: I don't know what 3&2&(+) would mean.
16:13:40 <shachaf> nkar: One thing is the usual "lack of composability" argument for ($) and (.) -- In "x & g & f" "g & f" isn't a separate thing.
16:13:45 <nkar> shachaf: I'm aware it doesn't make sense.  it's not the point.
16:13:56 <dmwit> RyanGlScott: Perhaps TH has a way to get all the Names that are currently in scope, which you could filter to just the classes.
16:13:56 <shachaf> I don't know what the point is.
16:14:05 <nkar> ugh
16:16:14 <RyanGlScott> dmwit: Is that what GHCi does? (e.g., :info Int)
16:16:28 <dmwit> shachaf: Hm. I'm not sure I buy that argument. "(&) is bad because it can be misused" doesn't sway me.
16:16:41 <dmwit> I like ($). I use it a lot. It can be misused in exactly the same way.
16:16:52 <shachaf> dmwit: But at least (.) exists.
16:17:01 <dmwit> RyanGlScott: I'm not sure!
16:17:08 <codygman> I have a cabal sandbox and several of my packages do not contain profiling versions of the library. How can I reinstall them with profiling? I tried cabal install -j --enable-library-profiling but it didn't seem to fix my issue.
16:17:08 <shachaf> When you add flip ($) and not flip (.), you're arguing for a particular use case pretty strongly.
16:17:13 <RyanGlScott> dmwit: Well, time to take a journey into the source code :P
16:17:29 <shachaf> dmwit: (And indeed code that uses & tends to be that way.)
16:17:36 <dmwit> shachaf: I see.
16:17:54 <dmwit> codygman: You have to list them all, and add --reinstall.
16:17:59 <shachaf> I also think (&) is a better name for flip (.) anyway -- "f and g".
16:18:05 <dmwit> codygman: This is why "profiling: True" is standard advice for cabal config files.
16:18:14 <shachaf> Well, maybe that makes more sense in the original lens context.
16:18:19 <dmwit> codygman: Fixing it later is way too annoying.
16:18:36 <codygman> dmwit: profiling: True in my global cabal config? ~/.cabal/config
16:18:44 <dmwit> yep
16:19:06 <dmwit> codygman: Actually, I guess it's "library-profiling: True" and "executable-profiling: True".
16:19:28 <codygman> dmwit: Yep, I was about to verify ;)
16:19:58 <dmwit> codygman: ...but you will still need to fix it in the way I said. Can't undo the past (we haven't coded up the UI for that yet).
16:21:17 * hackagebot elm-reactor 0.2.0.1 - Interactive development tool for Elm programs  http://hackage.haskell.org/package/elm-reactor-0.2.0.1 (EvanCzaplicki)
16:23:47 <dmj`> can't do reify in the IO monad :)
16:24:41 <joe9> http://codepad.org/XU09VH0m Is there a way to get this to work?
16:25:15 <joe9> On line 26, I want to get this: Map Name (any type that belongs to the FileSystemItem typeclass)
16:25:47 <dmj`> joe9: existential quantification might work
16:26:01 <joe9> dmj`: thanks.
16:27:29 <byorgey> joe9: why not just define   data FileSystemItem = FSI Name Details  ?
16:27:43 <byorgey> oh, well, that's just File
16:28:10 <ski> joe9 : you'll probably need more operations in `FileSystemItem' for that to be useful
16:28:16 <ski> also, if you haven't yet, read
16:28:18 <ski> @where existential-antipattern
16:28:18 <byorgey> joe9: how about   class FileSystemItem a where  toFile :: a -> File
16:28:18 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
16:28:24 <joe9> byorgey: I want to make the distinction between File datatype and the Directory datatype, so I can tailor my function definitions more precisely.
16:28:38 <dmj`> joe9: http://lpaste.net/116410
16:28:55 <joe9> byorgey: If I squish them with data FSItem = File .. | Directory, I am writing a few error clauses.
16:29:10 <joe9> to ensure that I am not doing a file operation on a directory, etc.
16:29:33 <orion> Hi. How do I get GHC to desugar code?
16:29:47 <joe9> I want to see if I can use the type system instead of using the error clauses and checking whether it is a file or folder in each relevant function
16:30:21 <ski> joe9 : either you need a way to rediscover than a value of type `a', where `FileSystemItem a' holds, is in fact a `Directory'; or you'll need extra abstract operations (basically OO) that can work on values of any type in `FileSystemItem'
16:30:28 <dmj`> orion: --ddump flags, https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/options-debugging.html
16:31:27 <orion> thank you, dmj`
16:31:42 <joe9> dmj`: I am reading up on the existential types, but, I doubt that the proposed solution in the paste above works as I would either have Cool File or Cool Directory.
16:31:53 * ski gets visions of <https://en.wikipedia.org/wiki/Visitor_pattern> here
16:32:22 <joe9> I am not sure if the solution in DataTypesAlaCarte is relevant to my issue here.
16:33:11 <ski> joe9 : i suppose one could also try to use GADTs to make the file system type apparent in the type of the item
16:34:56 <joe9> ski: the issue with GADTs or data FSItem = File .. | Dir .. pattern here is that I am writing quite a few error clauses to ensure that an operation meant for folders is not performed on files, etc.
16:35:27 <ski> joe9 : just to confirm : you want to be able to store values of different types `a' (given `FileSystemItem a' in each such case) in the same finite map, yes ?
16:36:05 <ski> joe9 : i'm not seeing how that applies to GADTs ?
16:36:06 <joe9> ski, yes, that is exactly what I (atleast) trying to do.
16:36:43 <ski> joe9 : good .. since it seemed dmj`'s suggestion implied they thought you only needed values of the same type `a' in any given finite map
16:36:56 <dmj`> joe9: it does work, I tested it
16:37:06 <dmj`> I didn't add the language pragma, but that's all it takes
16:37:32 <dmj`> it's a cheap way to constraint a type parameter in an ADT
16:37:39 <joe9> dmj`: your solution (I think) assumes that the map will only have directories or files. I want to have a map of either files or directories.
16:37:46 <dmj`> s/constraint/constrain
16:41:26 <joe9> dmj' : you are probably correct."Example: heterogeneous lists" of http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types seems to cover the issue in a simpler manner than the solution proposed in AlaCarte..
16:42:09 <ski> joe9 : anyway, i way thinking of something like `data FSItem t where File :: Name -> Details -> FSItem FileT; Dir :: Name -> Details -> Map Name AnyFSItem -> FSItem DirT'
16:42:12 <dmj`> joe9: so you want an FSItem to be a File or a Directory? Am I understaning?
16:42:35 <joe9> dmj`: yes, an FSItem can be either a File or a Directory.
16:43:23 <ski> joe9 : where `data AnyFSItem = forall filetype. WrapFSItem (FSIterm filetype)' or something like that
16:43:45 <joe9> ski, But, that does not help reducing the error clauses, correct? I cannot have a function definition of type (for example.): cd :: Dir -> ParentDir
16:44:05 <ski> .. it's not clear to me that this will necessarily make things any simpler, though
16:44:26 <ski> joe9 : it can reduce some error clauses
16:44:38 <joe9> ski, yes, makes sense.
16:44:48 <joe9> ski, it took me a while to understand it.
16:45:04 <ski> joe9 : for `foo :: FSItem DirT -> ...', you can't pass a `File aName aDetails' as argument, so you don't have to check for that
16:45:07 <marchelzo_> What is the best way to get a working haskell environment on Ubuntu? haskell-platform,?
16:45:36 <Welkin> marchelzo_: yes
16:45:42 <Welkin> is this local? or on a server?
16:45:45 <ski> joe9 : however, when lokking through your `Map Name AnyFSItem' in the `Dir' case, you again have to check both the `File' and the `Dir' case
16:45:49 <Welkin> if it's a server, use halcyon
16:45:51 <ski> s/lokking/looking/
16:46:07 <marchelzo_> nah it's local, but I want to make sure I get ghc 7.8.3
16:46:25 <dmj`> joe9: why not, data FSItem = File Details | Directory Details, but then why not make it recursive? data FS = File String  | Directory String [FS], a rose tree
16:47:12 <ski> joe9 : you could either define `data FileT; data DirT' (in this case `FSItem :: * -> *') .. or (nicer, imho) you could enable `DataKinds' and do `data FileType = FileT | DirT' .. in this case `FSItem :: FileType -> *'
16:47:50 <dmj`> joe9: You could probably use a trie
16:48:04 <joe9> ski, the existential types solution seems simpler.  http://codepad.org/u3O1CZoQ from the wiki
16:48:07 <ski> joe9 : however, the GADT is closed (just as an ordinary ADT would be). i dunno whether you want to allow later adding more alternatives
16:49:20 <ski> joe9 : well, if you do that, you can't *check* whether an `a' (where you only know `FileSystemItem a') inside your map is a `File' or a `Directory'
16:49:42 <ski> joe9 : which was why i said (above) "either you need a way to rediscover than a value of type `a', where `FileSystemItem a' holds, is in fact a `Directory';"
16:50:39 <ski> joe9 : and GADTs are a way to rediscover such things :) the version i proposed baked this info into the `FSItem' type, but it would also be possible to separate it out into another type (this can sometimes be useful)
16:52:17 <ski> joe9 : if you only know that some value has type `exists a. FileSystemItem a => a', then the *only* thing you know is that you have a value of a type that supports the `FileSystemItem' "interface" -- and since neither `name' or `details' can be used to rediscover the type of `a', you'd then need to add some more method to the type class
16:52:46 <ski> er, i should say `exists a. FileSystemItem a *> a' .. slip of fingers
16:53:02 <joe9> ski, this seems to work: http://codepad.org/Sg7rLdNA
16:53:18 <ski> joe9 : if you have `exists a. FileSystemItem a *> (a,..a..)', then you can not only use the methods and the value of type `a', but also the extra stuff of type `..a..'
16:54:27 <ski> joe9 : so far, yes
16:54:35 <joe9> ski, let me also get this to compile using GADTs too.
16:54:48 <ski> still, you can't write `checkIfDirectory :: FSItem -> Maybe Directory'
16:54:51 <joe9> then I can compare the differences
16:55:36 <joe9> ski, yes, good point.
16:55:58 <ski> as i mentioned, a more OO-y approach might work .. if you have a good idea of what basic operations you'll want to be able to apply to all `FSItem's
16:56:46 <joe9> ski, I do not know how that visitor pattern translates to haskell.
16:57:31 <joe9> ski, on a slightly different note, Would this not work with the approach mentioned in DataTypesAlaCarte (:+: operator)?
16:57:41 <joe9> map name (File :+: Directory)
17:00:47 <ski> joe9 : isn't that the same as `Map Name (Either File Directory)' ?
17:01:28 * ski has a vague memoory of what "DataTypesAlaCarte" was about
17:01:58 <joe9> ski, yes, it is almost the same
17:03:18 <ski> if you're fine with that, when go for it ?
17:03:29 * ski was assuming joe9 wanted something more/else
17:03:39 <ski> s/when/then/
17:04:16 <joe9> ski, yes, I want something else as I am learning and I think there might be a simpler approach than the AlaCarte approach. I like the GADT approach that you suggested.
17:04:37 <joe9> ski, I am putting it together (using GADT) as we speak
17:05:17 <ski> joe9 : (re visitor) well, one *could* add a method `accept :: FileSystemItem a => (a ~ File => o) -> (a ~ Dir => o) -> (a -> o)' .. though i'm not sure whether it would do much good here
17:06:37 * ski idly wonders whether there's anything useful hiding here
17:08:51 <jle`> i'm having way too much trouble defining tail in terms of foldr in a nice way ;_;
17:09:14 <Hafydd> Why would you want to do that?
17:09:38 <jle`> i'm trying to define tail for church encoded lists
17:09:41 <jle`> just for funsies
17:09:52 <joe9> ski: is this what you had in mind: http://codepad.org/G04nyo21
17:09:52 <Hafydd> I see.
17:10:06 <jle`> well my end goal is to define zipWith/zip
17:10:24 <jle`> but i can't even do tail or uncons
17:10:27 <jle`> i can do head though
17:10:29 <jle`> yipee
17:11:03 <ski> jle` : `tail :: (forall o. (a -> o -> o) -> o) -> (forall o. (a -> o -> o) -> o)' ?
17:11:25 <jle`> yes
17:11:50 <jle`> > let head' = foldr const undefined in head' [1,2,3]
17:11:51 <lambdabot>  1
17:11:53 <jle`> im so cool
17:11:56 <ski> jle` : .. i defined `zipWith' using no explicit recursion or pattern-matching on the list constructors, using `foldr' instead
17:12:11 <jle`> i tried zipWith with foldr/directly on the encoding
17:12:18 <jle`> but i could not do it so well
17:12:20 <jle`> hm
17:12:30 <jle`> knowing that it is possible gives me hope to try it again
17:14:08 <ski> joe9 : no
17:14:33 <ski>   Directory :: Name -> Details -> Map Name (FileSystemItem t) -> FileSystemItem DirT
17:14:41 <ski> will get elaborated into
17:14:51 <ski>   Directory :: forall t. Name -> Details -> Map Name (FileSystemItem t) -> FileSystemItem DirT
17:14:58 <ski> which logically is equivalent to
17:15:13 <ski>   Directory :: Name -> Details -> (exists t. Map Name (FileSystemItem t)) -> FileSystemItem DirT
17:15:29 <ski> which isn't what you want, because the same `t' will be used for all the values in the finite map
17:15:36 <chrisdone> i converted my filepath handling to a more well-typed filepath type and found a bug in my code =)
17:15:52 <joe9> ski, oh, that would be the same issue I had earlier.
17:15:53 <jle`> =)
17:16:01 <ski> joe9 : rather, you would probably want to encode something like
17:16:12 <ski>   Directory :: Name -> Details -> Map Name (exists t. FileSystemItem t) -> FileSystemItem DirT
17:16:21 <ski> and to do that, you can say
17:16:29 <ski>   Directory :: Name -> Details -> Map Name AnyFileSystemItem -> FileSystemItem DirT
17:16:32 <ski> if you define
17:16:37 <ski>   data AnyFileSystemItem
17:16:39 <ski>     where
17:16:50 <ski>     WrapFSItem :: FileSystemItem t -> AnyFileSystemItem
17:16:57 <ski> alternatively using the other syntax
17:17:11 <ski>   data AnyFileSystemItem = forall t. WrapFSItem (FileSystemItem t)
17:17:16 <ski> to define the same thing
17:18:20 <ski> this `AnyFileSystemItem' essentially means the same as the (pseudo-Haskell) `exists t. FileSystemItem t', and you can see this by noting that the signature for `WrapFSItem' elaborates into
17:18:30 <ski>   WrapFSItem :: forall t. FileSystemItem t -> AnyFileSystemItem
17:18:31 <ski> iow
17:18:39 <ski>   WrapFSItem :: (exists t. FileSystemItem t) -> AnyFileSystemItem
17:19:11 <ski> (and since this is the only constructor, `AnyFileSystemItem' is (ignoring bottoms) isomorphic to `exists t. FileSystemItem t')
17:19:21 <joe9> ski, ok, thanks.
17:20:06 <joe9> ski, I read from https://downloads.haskell.org/~ghc/6.6/docs/html/users_guide/gadt.html that deriving Show is not possible with GADTs (?)
17:20:07 <ski> joe9 : note that it's a logical law that `forall x. (P x -> Q)' is equivalent to `(exists x. P x) -> Q', where `Q' doesn't mention `x' (freely)
17:21:02 <joe9> ski, oh, I do not still understand the forall and exists usage. I will read up on it.
17:23:37 <ski> joe9 : GADTs can sometimes be derived, if you use `StandaloneDeriving'. not always, though
17:26:37 <joe9> ski, ok, thanks.
17:26:56 <ski> joe9 : i think if you say `data FSItem = forall i. (Show i,FileSystemItem i) => FSItem i', you'll probably be able to say `deriving instance Show FSItem'
17:27:48 <ski> joe9 : `foo :: forall a. ..a..' means that for any type `a', `foo' *can* have type `..a..' (iow, *can* be *used* at that type)
17:28:29 <ski> the implementation of `foo' will know nothing about the actual type `a' used, it has to work for any possible choice of an actual type in place of the type variable/placeholder `a'
17:28:48 <ski> this is ordinary polymorphism. `foo' is polymorphic, `forall a. ..a..' is a universal type
17:29:23 <ski> for `foo :: forall a. Blah a => ..a..', it can only be used on types `a' which are known to be instances of `Blah' (iow where `Blah a' is known to hold)
17:29:54 <ski> and when implementing `foo', nothing is known about `a' *except* that it belongs to the type class `Blah' (so the methods of `Blah' can be used for this type `a')
17:30:57 <ski> joe9 : so, a value of type `forall a. ..a..' requires the *user* to provide an actual type to use in place of `a'. and to construct such a value, you need to write code which will work for *any* such choice
17:31:07 <ski> joe9 : now, `exists' is just the opposite of this :
17:32:04 <ski> joe9 : to construct a value of type `exists a. ..a..', you can use *any* actual type in place of the type variable `A' you like. while to *use* it, you have to be prepared for *any* type, and so can assume nothing about that type
17:32:44 <joe9> ski, Thanks. I understand it.
17:33:00 <ski> joe9 : and for `exists a. Blah a *> ..a..', when constructing, you must make sure the type you select is in `Blah'; while when consuming/using, you know nothing *except* that the type is in `Blah'
17:33:55 <ski> (note that `Blah a => ..a..' means that the *user* has to provide evidence for `a' being in `Blah', while `Blah a *> ..a..' means that the *implementor* has to provide such evidence)
17:34:12 <ski> joe9 : now, consider
17:34:13 <ski>   data AnyFileSystemItem = forall t. WrapFSItem (FileSystemItem t)
17:34:21 <ski> why is this called `ExistentialQuantification' ?
17:35:21 <ski> (aside, i think it really ought to be called something like `ExistentialComponents', reserving `ExistentialQuantification' for a real `exists' syntax, if we ever get one (LHC has partial support for it, the easy case of `(exists a. ..a..) -> ...', i think))
17:35:35 <ski> well, what is the type of the data constructor, `WrapFSItem'
17:36:05 <d34df00d> Hi there!
17:36:23 <ski> the definition of `AnyFileSystemItem' is stating that `WrapFSItem', if applied to a value of type `FileSystemItem t', will yield a result of type `AnyFileSystemItem', for *all* types `t'
17:36:28 <ski> iow, for all types `t', we have
17:36:29 <d34df00d> I'm trying to memoize my own function of type (Int, Int) -> Int, and reading https://www.haskell.org/haskellwiki/Memoization#Memoization_with_recursion before that.
17:36:36 <d34df00d> Could please anyone explain how that really works?
17:36:37 <ski>   WrapFSItem :: FileSystemItem t -> AnyFileSystemItem
17:36:46 <ski> iow, `WrapFSItem' is polymorphic, and so
17:36:50 <ski>   WrapFSItem :: forall t. FileSystemItem t -> AnyFileSystemItem
17:37:05 <ski> and by the logical law mentioned above, this means the same as the (pseudo-Haskell)
17:37:12 <ski>   WrapFSItem :: (exists t. FileSystemItem t) -> AnyFileSystemItem
17:37:27 <ski> and there you have the `exists' in the extension `ExistentialQuantification' !
17:37:36 <ski> joe9 : does that help ?
17:38:25 <hpc> d34df00d: so, just for clarity we'll rewrite memoized_fib a bit
17:38:47 <hpc> memoized_fib = let theList = map fib [0..] in \n -> theList !! n
17:38:55 <hpc> where {- the rest is the same -}
17:39:06 <joe9> ski, Thanks a lot. I am a bit slow catching up. I need some more time to understand what you said. Thanks again.
17:39:25 <ski> joe9 : it may also help to know that `exists t. Blah t *> [t]' would be a list of values all of the same unknown type `t' (where it is known that `Blah t'), while `[exists t. Blah t *> t]' would be a list of values, where for each value there is some hidden type `t' such that (a) `Blah t' is known; and (b) the value is of type `t'
17:39:40 <hpc> d34df00d: so, the important thing here is that theList is defined /outside/ the lambda
17:40:17 <d34df00d> hpc: and that allows it to, well, "live" between the fib calls, so that fib can safely "pass" the recursion back to memoized_fib?
17:40:18 <hpc> giving it the same effective lifetime as memoized_fib (global, so forever)
17:40:21 <hpc> yes
17:40:22 <ski> joe9 : usually it's the latter alternative which is more sensible.. in you case you have `Map Name (exists i. FileSystemItem i *> i)' instead of `[exists i. ..i..]', but the same applies
17:40:49 <hpc> if it's inside the lambda it will get forgotten between calls, because that's just how functions work
17:40:54 <ski> joe9 : let's take one more example. let's assume for the sake of the argument that `class Show a where show :: a -> String'
17:41:49 <ski> joe9 : then `[exists a. Show a *> a]' is more or less the same as `[exists a. (a,a -> String)]' -- this is to hilight that you don't *need* to use typeclasses to get this OO-y effect, it's just *convenient*
17:43:03 <ski> joe9 : note that in this case, the only thing you can do with a value of type `exists a. (a,a -> String)' is pass the first pair component to the second pair component. so `[exists a. Show a *> a]' here is basically as good as `[String]' -- you need to have a more interesting case to have any real use of the existential
17:44:07 <ski> joe9 : .. which is why you should read that existential antipattern blag i mentioned before :)
17:44:46 <ski> don't overused existentials, don't use them when there's no need, it just overcomplicates stuff
17:45:06 <ski> joe9 : questions ?
17:47:33 <joe9> ski, yes, I will have questions. but, not now. maybe tomorrow. I need some time to digest this.
17:47:41 <ski> ok, no worry
17:48:39 <ski> just remember that this is related to object-orientation -- where the only stuff you can do with a given value is call operations in its interface
17:48:49 <joe9> ski, on a slightly different note, would I come across the issue if I used Idris or Agda for this FSItem representation? Or, will it be simpler?
17:49:19 <ski> (but there's nothing corresponding to `instanceof' or `typecase' here, since those features aren't really object-oriented)
17:50:00 <ski> joe9 : i'd say it'd be more or less the same. perhaps a little simpler, just generally due to having a more expressive type system
17:50:50 <dfeuer> carter, this is what 2 and 3 look like: https://github.com/haskell/containers/issues/73#issuecomment-66897917 . Still not sure where the rest are going.
17:51:22 * hackagebot hakyll-agda 0.1.9 - Wrapper to integrate literate Agda files with Hakyll  http://hackage.haskell.org/package/hakyll-agda-0.1.9 (FrancescoMazzoli)
17:51:22 * ski has a link to a paper talking about object-orientation and types that joe9 might have fun looking at
17:51:44 <joe9> ski, please paste the link. I will check it out.
17:55:46 <ski> joe9 : ok
17:56:24 <ski> "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf>
17:56:31 <ski> that's sortof a follow-up to
17:57:10 <ski> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
17:57:15 <ski> (also a good read)
17:58:58 <dfeuer> Does anyone know a good way to convert a sequence to a 2-3 tree of a given depth (when it's possible to do so)?
17:58:59 <d34df00d> hpc: hm, and why this one won't work?
17:59:10 <d34df00d> https://bpaste.net/show/f1cfe40cea82
17:59:46 <dfeuer> d34df00d, why not 1iv3f00d?
18:00:04 <monochrom> l0v3 f00d
18:00:20 <joe9> ski, thanks a lot for your time and patience.
18:00:21 <d34df00d> And why I don't get infinite recursion since I'm starting my array from (0, 0) which is not correclty handled by cPathsC?
18:00:29 <d34df00d> dfeuer: "iv" are not hexy enough :(
18:00:41 <ski> joe9 : that other paper also goes into how existential quantification corresponds to information hiding and abstract data types (which is a different *use* of existentials than the OO stuff)
18:00:54 <monochrom> when you call cPaths(4,5), it will be its own array. during that, it will call cPaths(3,5), which will build its own array, not use the array built by cPaths(4,5).
18:00:56 <hpc> d34df00d: cPathsC (0,0) is non-terminating, would be my guess
18:01:09 <hpc> oh, or that
18:01:16 <monochrom> yikes, there is a serious typo
18:01:25 <monochrom> when you call cPaths(4,5), it will build its own array. during that, it will call cPaths(3,5), which will build its own array, not use the array built by cPaths(4,5).
18:01:33 <ski> joe9 : in case you're also looking for an easier paper to start learning how to read the usual type inference rule notation, you could try "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)>
18:01:43 <ski> @unelite d34df00d
18:01:43 <lambdabot> D34Dph00D
18:02:08 <d34df00d> monochrom: hmm, so reason is that I have, well, arguments on the left hand of `=`?
18:02:22 <joe9> ski, thanks, I wanted something simpler to start of with. Something basic. The last link will probably be more helpful to get me started.
18:02:46 <dfeuer> d34df00d, good point.
18:02:50 <monochrom> no, "cPaths = \(m, n) -> array ..." will do the same thing.
18:02:51 <ski> d34df00d : you probably want to define the array recursively
18:03:03 <d34df00d> ski: hm, what do you mean?
18:03:17 <monochrom> so its rather, you have arguments on the left of your array.
18:03:30 <ski> d34df00d : you're attempting to do dynamic programming, yes ?
18:03:38 <d34df00d> ski: yes, kinda.
18:03:54 <d34df00d> monochrom: yes, that's better, thanks.
18:04:28 <d34df00d> I can't have Data.Array without an upper bound, can I?
18:04:42 <monochrom> it requires an upper bound
18:04:48 <joe9> ski, on a similar note, do you know of any basic material that covers the difference between the type systems of haskell vs idris/agda?
18:04:50 <ski>   cPaths (m,n) = arr ! (m,n)
18:04:52 <ski>     where
18:05:04 <monochrom> the package "memoize" is where you don't need a bound, lower or upper :)
18:05:21 <d34df00d> monochrom: yes, I've already googled that, but that hardly helps to understand how that works :)
18:05:28 <ski>     arr = listArray (m,n) [cPathsC (i,j) | (i,j) <- range (m,n)]
18:05:45 <ski>     cPathsC (1,_) = 1
18:05:51 <ski>     cPathsC (_,1) = 1
18:06:01 <monochrom> ok right, using basic arrays or lists is a good way to see the principle
18:06:14 <ski>     cPathsC (i,j) = arr ! (i - 1,j) + arr ! (i,j - 1)
18:06:19 <ski> d34df00d : something like that
18:07:30 <ski> d34df00d : this will build a single array `arr' (for the outer call to `cPaths'), rather than building a new array each time you (previously) recursively called `cPaths' (in `cPathsC')
18:07:47 <d34df00d> ski: sounds good!
18:07:59 <d34df00d> ski: and what if I wanted to decouple the memoization itself from the recursion?
18:08:30 <d34df00d> By restricting the signature of the helper cPathsC to, say, ((Int, Int) -> Int) -> (Int, Int) -> Int.
18:08:50 <ski> d34df00d : `arr' is recursively defined (if you really wanted to, you could inline `cPathsC' into the list comprehension, and then you'd see it explicitly) -- the array structure will be allocated directly, but the elements will only be filled in as needed (as determined from the initial access `arr ! (m,n)')
18:09:09 <ski> d34df00d : that should work finr
18:09:16 <ski> s/finr/fine/
18:09:27 <naudiz> Is there a way to treat Text like [Char] without running into conflicts?
18:09:52 <ski> joe9 : Agda is dependent. Haskell is not. i'm not familiar enough with Idris to tell, but i think it's also dependent
18:09:54 <naudiz> I don't like to write Text.foo everywhere
18:10:05 <hpc> idris is dependent
18:10:26 <Clint> naudiz: hide the string functions
18:10:43 <ski> joe9 : the Cardelli link has some starting text in the initial pages that should possibly be digestible without knowing that much about type systems and type theory
18:10:57 <naudiz> Clint: how do I do that? aren't string functions just list functions?
18:11:08 <naudiz> I still want to be able to use lists
18:13:32 <nkar> naudiz: are you aware of the OverloadedStrings pragma?
18:14:19 <naudiz> nkar: well... now I am, thanks :)
18:14:40 <ski> d34df00d : if you want to, you could define `memoFixArray :: Ix i => (i,i) -> ((i -> e) -> (i -> e)) -> (i -> e); memoFixArray ix f = (arr !) where arr = tabulate ix . f $ \i -> arr ! i', where `tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = listArray [f i | i <- range ix]' is a handy shorthand for making an array
18:14:48 <nkar> naudiz: also, why are you trying to treat Text like String?  usually, people want to do the opposite
18:16:29 <naudiz> nkar: I just don't want to write Text.foo everytime I use a function from the Text library
18:17:00 <nkar> ah, then you're doing the right thing, and the extension I mentioned should do the trick.
18:17:21 <ski> d34df00d : an alternative is to define `memoArray :: Ix i => (i,i) -> (i -> e) -> (i -> e); memoArray ix f = (arr !) where arr = tabulate ix $ \i -> arr ! i' and then to say something like `cPaths (m,n) = cPathsC where (memoArray (m,n) -> cPathsC) = \case (1,_) -> 1; (_,1) -> 1; (i,j) -> cPathsC (i - 1,j) + cPathsC (i,j - 1)'
18:17:51 <d34df00d> Eh, I'm not sure that's actually easier :)
18:18:00 * d34df00d sees `tabulate` for the first time BTW>
18:18:22 <augur> chrisdone: :|
18:18:25 <Kaidelong> alright so I'm going to bite the bullet and develop my haskell apps in a VM and cross compile for targeting windows
18:18:30 <augur> chrisdone: whyd you remove your ramble
18:18:31 <d34df00d> The concept, I mean.
18:18:41 <d34df00d> Seems useful and handy, yes.
18:18:45 <Kaidelong> I am going to be using GHC 7.8, should I use LLVM or GCC as the backend?
18:19:37 <mmmm> is there a canonical way to go from Word8 -> Char? or [Word8] -> Text
18:19:58 <hpc> depends on the encoding
18:19:59 <shachaf> There are lots of ways.
18:20:02 <nkar> w2c in Data.ByteString.Internal
18:20:05 <nkar> iirc
18:21:42 <shachaf> :-(
18:22:25 <ski> d34df00d : so, either `memoFixArray' or `memoArray' would achieve "decouple the memoization itself from the recursion" -- well, at least the latter would, the former would just hide both of them for you. with either you'd not have to see the array explicitly in the definition of `cPaths' anymore
18:24:30 <ski> (hm, ftr, the correct definition of `memoArray' is `memoArray ix f = (arr !) where arr = tabulate ix $ \i -> f i'. only `memoFixArray' was supposed to tie a recursive not. `memoArray' wasn't)
18:25:22 <shachaf> i,i recursive not
18:28:59 <carter> dfeuer: huh
18:30:36 * ski . o O ( "Not Knot" by A. K. Peters,&al. in 1995 at <http://www.geom.uiuc.edu/video/NotKnot/>,<https://www.youtube.com/watch?v=AGLPbSMxSUM> )
18:30:51 <carter> dfeuer: is this a road towards <*> tingy?
18:43:50 <dfeuer> carter, yes, this is a road towards <*> thingy. In particular, ap2 and ap3 represent <*> when the second argument has two or three elements.
18:44:45 <dfeuer> Do you happen to know anything about converting sequences to 2-3 trees?
18:45:09 <carter> nope
18:45:38 <carter> would it be easier if it were 2-3 trees from the outset?
18:45:56 <dfeuer> Well ... sort of?
18:46:34 <dfeuer> I need to draw some pictures and figure out better exactly what I need.
18:47:24 <isd> Hey all. I'm writing a simple little tool for my own backups, and it's choking when it hits a directory that starts with a period. I'm not sure why, but I imagine I'm misunderstanding the use of something. Here's the code: http://pastie.org/9779275
18:47:32 <isd> I'd wager the problem is in getFileTreeStatus
18:49:05 <isd> The specific error I get is something like: main: /fb-dev/rdfs: createDirectory: does not exist (No such file or directory)
18:49:30 <isd> where in that case, src </> "/fb-dev/rdfs" contains a directory called ".hg"
18:49:40 <isd> Thoughts?
18:52:38 <dfeuer> isd, sorry, no thoughts.
18:52:44 <dfeuer> I don't know anything about that.
18:56:06 <isd> stdout: http://pastie.org/9779286
18:57:54 <lachenmayer> isd: (`notElem` [".", ".."]))
18:57:59 <isd> On those last four lines -- everything is right except the last thing. I can't think of anything that could be going wrong except </> not doing the right thing, which makes zero sense.
18:58:45 <lachenmayer> you sure that does what you expect it to do?
18:58:56 <isd> lachenmayer: I figure it has to do with that. But shouldn't that just match directories that are *exactly* those names? My expectation was that ".hg" shouldn't match
18:59:41 <isd> or should -- ".hg" should make it through the filter
19:00:01 <isd> and it does return the right value; ".hg" `notElem` [".", ".."] is True
19:00:05 <lachenmayer> yeah definitely
19:04:42 <isd> lachenmayer: can you think of any way that stdout output could happen? dest is "/tmp/butest/dest/3", (dropRoot dir) is "/fb-dev/rdfs", how can (dest </> (dropRoot dir)) == (dropRoot dir) ?
19:04:59 <eachofwhich> Hi, guys. Why is the following pattern non-exhaustive?
19:05:00 <eachofwhich> isMonotone :: Ord a => [a] -> Bool
19:05:01 <eachofwhich> isMonotone [] = True
19:05:01 <eachofwhich> isMonotine (x:xs) = (x <= head xs) && (isMonotone xs)
19:05:15 <shachaf> eachofwhich: head is nonexhaustive
19:05:32 <lachenmayer> eachofwhich: isMonot__i__ne? :)
19:05:38 <eachofwhich> I tried replacing the body (with head) with = True
19:05:45 <shachaf> Oh.
19:05:49 <shachaf> It's what lachenmayer said.
19:05:57 <eachofwhich> It still was considered non-exhaustive
19:05:59 <shachaf> But head will also cause a problem.
19:06:18 <lachenmayer> yep, xs could be []
19:06:21 <isd> eachofwhich: you spelled one of those wrong.
19:06:26 <eachofwhich> Oh, wow.
19:06:27 <isd> isMonotine vs isMonotone
19:06:34 <eachofwhich> Thanks very much. This is just silly.
19:06:47 <isd> My issue is probably just as silly.
19:07:24 <eachofwhich> Great point on head, too.
19:10:39 <zerkms> guys, could someone please help me understanding a function from RWH: http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html#id624895
19:10:45 <isd> Okay, it's actually that </> isn't working. swapping it out for ++ "/" ++ does the trick.
19:10:46 <zerkms> it's the parseP5_take2 function
19:10:48 * isd is very confused.
19:11:05 <zerkms> I cannot get how they can access `width` symbol in the last expression
19:11:26 <lachenmayer> isd: ("/tmp/butest/dest/3" </> "/foo/bar/baz") == "/foo/bar/baz"
19:11:41 <lachenmayer> it doesn't like the starting /
19:12:07 <isd> Ah Combine two paths, if the second path isAbsolute, then it returns the second.
19:12:10 <isd> lachenmayer: yep
19:12:20 <isd> mystery solved.
19:17:24 <isd> While I'm here, do people have general style tips on the code I posted? I'm new to the language.
19:34:08 <ski> isd : you could use `let' in `do' on line `37'
19:34:32 <ski> isd : instead of `void $ forM ...' use `forM_ ...'
19:35:30 <isd> ski:  I don't think I follow wrt the let?
19:35:52 <ski> isd : instead of `forType files isDirectory (\dir -> do ...)' you could say `forType files isDirectory $ \dir -> do ...', and similarly for the other two calls to `forType' (this avoids the trailing close bracket at the end)
19:35:57 <ski> isd :
19:36:15 <ski>   forType files isRegularFile $ \filename -> do
19:36:22 <ski>     file <- B.readFile filename
19:36:38 <ski>     let blobname = blobs </> unpack (Hex.encode (SHA1.hashlazy file))
19:36:48 <ski>     have <- doesFileExist blobname
19:36:50 <ski>     ...
19:38:01 <ski> (personally i would also remove all `$'s, except the ones i suggested for the `forType' calls, iow just before `\'. but that's more personal style)
19:42:34 <isd> ski: thanks a bunch.
19:42:35 <ski> hm, perhaps instead of `drop', i'd use `stripPrefix' .. in case i wanted to make sure exactly `src' (and nothing else) was removed from the start of the strings
19:42:38 <ski> > let Just suffix = stripPrefix "foo" "foobar" in suffix
19:42:40 <lambdabot>  "bar"
19:42:45 <ski> > let Just suffix = stripPrefix "foo" "fubar" in suffix
19:42:46 <lambdabot>  "*Exception: <interactive>:3:5-43: Irrefutable pattern failed for pattern Da...
19:44:01 <ski> so `dropRoot path | Just relative <- stripPrefix root path = relative' or `dropRoot (stripPrefix root -> relative) = relative' or somesuch ..
19:45:41 <ski> isd : oh, i'd also drop the brackets in `(dest </> (dropRoot dir))'
19:46:01 <platinuum> haha ski i see you are in here as well
19:46:45 <platinuum> was gonna simultaneously ask a haskell question haha
19:46:48 <ski> an example of removing `$' : `map fst $ filter (pred . snd) files' could become either `map fst (filter (pred . snd) files)' (obvious) or `(map fst . filter (pred . snd)) files' (perhaps not quite as obvious to a novice)
19:46:48 <johnw> this is where I first came to know ski
19:47:05 <ski> this is where i first came to know IRC
19:47:41 <byorgey> I am recalling some relatively old paper with the word FIX in the title, which has a bunch of practical examples of the use of open recursion and the fix combinator
19:47:42 <platinuum> hmm well seems like you know it pretty well now judging from your whois hehe
19:47:52 <ReinH> byorgey: o/
19:47:53 <byorgey> does anyone have any idea which paper this is?
19:48:03 <ReinH> I bet johnw does
19:48:03 <byorgey> hi ReinH
19:48:39 <johnw> I don't actually
19:49:06 <ReinH> :(
19:50:04 <byorgey> I remember that the title is a clever pun
19:50:38 <shachaf> byorgey: How old?
19:50:48 <shachaf> I don't think I know, though.
19:51:26 <johnw> byorgey: http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/17num.pdf?
19:51:46 <byorgey> it's probably from the late 90's.  I recall it is not typeset with LaTeX.
19:51:50 <byorgey> johnw: nope, good try
19:52:18 <byorgey> although that does look interesting
19:52:32 <ReinH> scholar.google.com's search makes me sad
19:52:41 <platinuum> can anyone take a stab at this? http://imgur.com/1MMptWM   my implementation:  http://pastebin.com/7qMWeKvn
19:52:47 <platinuum> having trouble writing it tail recursively
19:52:49 <stephen_> ski: I'm curious about your example of removing the '$': do you have a document that explains it in further detail?
19:53:01 <ReinH> I want to search both title *and* body, not title *xor* body.
19:54:37 <ReinH> stephen_: You can work it out from the definition and fixity.
19:55:05 <ReinH> and the second example from the definition of (.) as well
19:55:43 <byorgey> hah, I found it: http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-375/
19:55:53 <byorgey> "That About Wraps it Up: Using FIX to Handle Errors Without Exceptions, and Other Programming Tricks"
19:56:00 <ReinH> byorgey: yay!
19:56:41 <byorgey> I was dead on re: late 90's
19:56:51 <byorgey> one reason I was having trouble finding it is that it uses SML, not Haskell!
19:56:58 <ReinH> ah
20:00:38 <stephen_> ReinH: So in each of the two versions, 'files' is defined with a different fixity, and that's the cause?
20:03:16 <ski> platinuum : `geometric(a r (n-1))' should presumably be `geometric a r (n-1)'
20:05:35 <ski> platinuum : the type signature is wrong
20:05:52 <ski> platinuum : missing formal parameters for `geometric_tr'
20:05:54 <platinuum> yeah should be Int -> Int -> [List]
20:06:01 <ReinH> stephen_: No.
20:06:19 <ski> platinuum : no. it is defined to accept three arguments, not two
20:06:40 <ski> platinuum : also, since it uses `(**)', the result type must be a numeric type that supports that operation
20:06:43 <ski> @type (**)
20:06:44 <lambdabot> Floating a => a -> a -> a
20:06:53 <ski> platinuum : e.g. `Double' or `Float', to keep it simple
20:07:03 <ski> (but not `Int')
20:07:16 <platinuum> Double -> Double -> Double -> Double
20:07:31 <ski> could perhaps work
20:07:32 <ReinH> stephen_: f $ a = (f) (a). In this case, f = map fst,  a = filter (pred . snd) files
20:07:59 <ski> platinuum : using `Int' for the last argument would probably be preferred, since you're comparing it with zero
20:08:22 <ReinH> and (map fst) (filter (pred . snd) files) = map fst (filter (pred . snd) files) because (f a) b = f a b
20:08:27 <ski> (you should try to avoid comparing floating-point numbers for equality/disequality)
20:08:49 <ski> platinuum : also, the recursive call in `geometric_tr_helper' isn't right (as i'm suspecting you already know)
20:09:12 <platinuum> yeah thats the issue i wa having, couldnt come up with something
20:09:43 <ski> platinuum : first, you need a counter. either counting down or up (your choice)
20:10:07 <ski> platinuum : next, you need to accumulator your intermediate results (here sums) in your accumulator argument (`acc')
20:10:29 <ski> s/to accumulator/to accumulate/
20:10:55 <platinuum> ok so lets count up, start the sum at 0
20:11:13 <platinuum> sum of 0th item will always be a
20:12:35 <hypoon> Alright guys, here's a humdinger for you: I'm using FFI with a few functions defined in C. I have one function that prepares a list, and another function that gets the next element of the list (which is called successively to get successive elements). I do not have a function that can get an arbitrary element of the list. Is it possible to use these functions through FFI to get the "entire" list in a lazy way in Haskell?
20:12:59 <ski> platinuum : ok
20:13:30 <stephen_> ReinH: Ahh, got it.
20:15:21 <orion> Could someone please explain the technical reason why "genKey" isn't callable?: http://lpaste.net/989957706523607040 -- it has 'a' in the type signature.
20:16:13 <glguy> orion: Type families aren't "injective" so that means that PublicKey Int and PublicKey Bool could both return Char
20:16:19 <glguy> (as an example, continuing)
20:16:37 <shachaf> i,i could both be Char
20:16:39 <glguy> So imagine if you said that PublicKey a was Char, there woudl be no way to know what a was
20:17:20 <glguy> and therefore no way to know what instance to use
20:18:05 <ski> byorgey : interesting. reminds me of <http://lpaste.net/10060>
20:18:21 <platinuum> ski: how does this look
20:18:47 <glguy> orion: You could, however, use an associated *data* family
20:18:59 <ReinH> stephen_: fixity doesn't change.
20:19:23 <ReinH> stephen_: For example, https://gist.github.com/reinh/059b596303cec950be21
20:19:26 <stephen_> ReinH: Yeah, I understand now
20:20:27 <glguy> shachaf, yes, you could both be char, too.
20:20:39 <ReinH> stephen_: ok :)
20:20:47 <ski> platinuum : ok
20:20:51 <orion> glguy: ah yes
20:20:53 <orion> injectivity
20:21:13 <platinuum> ski: great thanks for your simultaneous help
20:22:02 <glguy> orion, another way to make that callable would be to change genKey :: proxy a -> IO (PublicKey a, SecretKey a)
20:22:40 <stephen_> ReinH: Thanks!
20:22:42 <glguy> and then for example:   genKey (Proxy :: Proxy Noise255)
20:23:05 <orion> glguy: How could I leverage associated data families to solve this issue?
20:23:41 <ski> platinuum : got it to work ?
20:24:12 <glguy> change "type PublicKey p :: *" in the class definition to "data PublicKey p" and then "type PublicKey Noise255 = C.PublicKey Curve25519" to "data PublicKey Noise255 = Noise255PublicKey (C.PublicKey Curve25519)" (not validated in GHC)
20:24:27 <glguy> The difference here is that you need an explicit constructor and it makes a new, distinct type
20:24:55 <stephen_> platinuum: http://lpaste.net/116413
20:25:31 <hypoon> Can anyone point me to a resource for writing lazy IO functions like hGetContents?
20:26:14 <shachaf> hypoon: unsafeInterleaveIO is the magic function.
20:27:00 <glguy> hypoon, you'll probably need to use that and foriegnptr in order to do the clean-up so that it releases whatever resource that requires even if you don't use the whole lazy list
20:28:41 <ski> stephen_ : spoilsport (also, buggy)
20:28:41 <dramforever> I don't like those stuff like getContents. It's hard to manage
20:31:22 <ski> (clarification : platinuum might want to (perhaps is even required to) write the solution themselves. they'd probably learn better that way, rather than being served a solution)
20:32:58 <hypoon> shachaf, glguy, dramforever: I'm using functions implemented in C to read very large files (25Gb)... I'm starting to wonder whether I'm doing this the right way. The file format is a nightmare, so I'm using existing C code to read it, but the C implementation uses a struct to represent the file. It then has a function that updates the struct with the next chunk of the file. I'd rather represent the file as a list and grab each chunk 
20:33:00 <stephen_> ski: You're right; I'm sorry. platinuum: Sorry for depriving you.
20:35:51 <orion> glguy: Ok, I'll try that
20:36:06 <stephen_> ski: I suppose the entire function could be wrapped into a fold, but besides that, how might you improve it?
20:36:46 <dramforever> hypoon: can you easily know the size of each chunk?
20:37:06 <dramforever> I mean, for example reading the first few bytes
20:37:11 <dramforever> by reading*
20:37:27 <ski> stephen_ : platinuum apparently wanted to define two versions of it, one directly recursive (?) and one tail-recursive, using an accumulator
20:37:48 <platinuum> yep that was it, stephen your solution was good thanks
20:37:57 <ski> stephen_ : i suppose one could introduce a list to fold over (or did you mean folding over natural numbers ?)
20:38:00 <dramforever> hypoon: also how nightmare is the format?
20:38:17 <dramforever> maybe try attoparsec?
20:38:38 <ski> platinuum : it was buggy, afaics
20:39:00 <platinuum> ski: its ok, im just studying up for an exam so my mind is all over the place
20:39:03 <orion> glguy: Ok, I've done that. However, now the definition of genKey needs to change.
20:39:11 <platinuum> haskell, scala, erlang, prolog hah
20:39:28 <ski> stephen_ : anyway, apart from reassociating the `+'s, one could also do some (re)factoring of the `*'s, leading to a different solution
20:39:45 <orion> glguy: Currently, the actual type of genKey is IO (C.PublicKey Curve25519, C.SecretKey Curve25519)
20:39:52 <ski> platinuum : a "programming languages" or "programming language paradigms" course ?
20:40:19 <platinuum> functional programming course
20:40:26 <ski> oh
20:40:27 <orion> But since I'm creating a new type, I must change the definition. What's the best way to fix this?
20:40:27 <platinuum> not definitions of programming languags..
20:40:57 <dramforever> hmmm...
20:40:57 <ski> platinuum : well, Prolog isn't functional programming, it's logic programming (though both of those falls under declarative programming)
20:41:15 <platinuum> yeah sorry, course is called functional and logic programming ;)
20:41:28 <platinuum> you would think its a paradigms course tho with all the interpreter nonsense lol
20:44:06 <glguy_> Orion: just write the instance definition of genKey using the real genKey and add the constructors to it's result: do (x,y) <- genKey; return (Cp x, Cs y)
20:45:03 <ski> platinuum : so .. no constraint programming (e.g. constraint logic programming) then :/ ?
20:45:58 <platinuum> i mean is swipl not considered constraint programming?
20:48:06 <ski> SWI is one implementation of Prolog -- that also happens to come with packages for constraint (logic) programming
20:48:19 <ski> (CLP(FD),CLP(Q/R), at least)
20:49:19 <bananagram> is there a safe function for indexing a list, like !! but returning a Maybe?
20:49:21 <ski> Oz <http://www.mozart-oz.org/> is another logic programming language, also with support for constraint logic programming
20:50:34 <ski> ECL^{i}PS^{e} <http://eclipseclp.org/> is a Prolog-derivative that is mostly aimed for constraint logic programming
20:50:34 <bananagram> or I could use find, that does it
20:50:35 <glguy_> :t \i -> listToMaybe . drop i
20:50:36 <lambdabot> Int -> [a] -> Maybe a
20:50:54 <hypoon> Crap, walked away for a few minutes and missed dramforever. For anyone else listening, the file format is something that behaves well when read/written from Fortran. It's a /ton/ of binary numerical data. Specifically, it's the locations of atoms from a molecular dynamics simulation. The file is divided into timesteps, and each timestep has a three lists of floats for the x, y, and z coordinates of the 50k-200k atoms.
20:51:18 <ski> hypoon : you could `@tell dramforever blah ...' ...
20:51:29 <nuttycom> bananagram: you may want Safe
20:51:29 <ski> (assuming they'll be back, i.e.)
20:51:32 <nuttycom> it defines atMay
20:51:37 <nuttycom> http://hackage.haskell.org/package/safe-0.3.8/docs/Safe.html
20:51:48 <bananagram> okay
20:52:06 <glguy_> Hyphoon, the simplest solution would just be to leave the function for getting the next chunk in IO and write potentially pure connotations in those chunks
20:52:48 <glguy_> Computations (phone fail)
20:53:00 <hypoon> glguy_: "potentially pure connotations in those chunks", can you elaborate on that?
20:53:06 <hypoon> oh
20:53:11 <stephen_> ski: I think I know what you're envisioning, but we're we're explicitly told to use the ** operator, so swapping it out for recursive multiplication is less than kosher. platinuum: here's a closed-form algebraic solution for general interest: http://www.purplemath.com/modules/series5.htm
20:53:30 <ski> @wn connotation
20:53:31 <lambdabot> *** "connotation" wn "WordNet (r) 3.0 (2006)"
20:53:32 <lambdabot> connotation
20:53:32 <lambdabot>     n 1: what you must know in order to determine the reference of
20:53:32 <lambdabot>          an expression [syn: {intension}, {connotation}]
20:53:32 <lambdabot>     2: an idea that is implied or suggested
20:53:35 <ski> @wn conotation
20:53:36 <lambdabot> No match for "conotation".
20:54:03 <orion> glguy_: I think it's working. Thank you for your help!
20:54:10 <glguy_> There's a paper waiting to be written on the dual of notation
20:54:26 <glguy_> Orion: glad to hear it ^_^
20:55:04 <hypoon> ski: Regarding @tell, which bot handles that, and can I whisper it to the bot to avoid spamming the channel?
20:55:06 <ski> stephen_ : you could use `r ** 1' ;) but ok
20:55:28 <glguy_> Lambdabot does all @ commands
20:55:49 <glguy_> Also yes, it accepts private messages
20:56:24 <ski> there's also `/msg MemoServ send the_nick the message' ..
20:57:33 <ski> glguy_ : if notation is algebraic (well, ignoring alpha-conversion of bound variables, at least), is conotation then coalgebraic ?
20:57:42 <hypoon> glguy_: thanks!
20:58:08 <ski> (also `@ask' is the same as `@tell', spelled differently)
20:58:19 <shachaf> Almost the same.
20:59:27 <pharpend> edwardk: you around?
20:59:29 <hypoon> So lambdabot and MemoServ both relay messages?
20:59:38 <pharpend> yes, but lambdabot is better
20:59:48 <pharpend> mostly because MemoServ is rather unreliable
21:00:10 <hypoon> I don't see MemoServ in the list on the right.
21:00:21 <hypoon> (the list of chat participants)
21:00:30 <pharpend> it's not, it's a freenode thing
21:00:31 <glguy_> Memoserv is a network service
21:00:39 <pharpend> FreeNode in general is very unreliable
21:00:46 <hypoon> oooh, ok. That makes sense.
21:00:52 <pharpend> they've gotten significantly better in the last year
21:00:55 <pharpend> but still
21:01:01 <ski> MemoServ notifies people (a) when they identify next time; and (b) if they're still identified when the message is sent. but (b) can easily be missed in some far away window/tab
21:01:20 <ski> ((a) can also be missed if people don't pay attention to the server messages)
21:01:22 <pharpend> lambdabot will notify people when they talk
21:01:37 <ski> you can also poll it by `/msg MemoServ list'
21:01:38 <pharpend> and lambdabot is in 80-something channels across freenode, so ...
21:02:27 <ski> shachaf : ok, i thought they were the same. perhaps at some point they were ?
21:02:57 <shachaf> @@ (@tell ski demonstration) (@ask ski demonstration)
21:02:57 <lambdabot>  Consider it noted. Consider it noted.
21:03:02 <glguy_> @ask shachaf what's the difference?
21:03:02 <lambdabot> Consider it noted.
21:03:11 <shachaf> @messages-
21:03:11 <lambdabot> glguy_ asked 8s ago: what's the difference?
21:03:30 <glguy_> @tell shachaf I see it now
21:03:30 <lambdabot> Consider it noted.
21:03:42 <shachaf> @messages-, I guess.
21:03:42 <lambdabot> Maybe you meant: messages? messages
21:03:45 <shachaf> Oops.
21:03:50 <shachaf> @messages-
21:03:50 <lambdabot> glguy_ said 19s ago: I see it now
21:04:48 <glguy_> Please do your not commands in private message to avoid spamming the channel
21:04:55 <glguy_> Bot*
21:05:20 <shachaf> glguy_: Thanks, I'll keep that in mind.
21:05:36 <ski> `messages-' expands to `messages-loud' ?
21:05:43 <shachaf> Yes.
21:05:51 <shachaf> This is probably better for #-blah by now at any rate.
21:06:27 <osa1> any alternatives of HTTP that support https?
21:08:55 <hypoon> Bots are useful. :-) Thanks for the info. Now back to coding this interface... So glguy_: you mentioned about keeping the function that gets the next chunk in IO and running computations on the chunks. That feels very foreign to Haskell... I'd be essentially mapping a computation over a list (very haskell-ish), but I'd be doing it through some look-structure (not haskell-ish at all).
21:09:25 <hypoon> s/look-structure/loop-structure/
21:10:32 <hypoon> I actually don't remember how to loop in Haskell without just (ab)using recursion... but I can look that up.
21:11:18 <pharpend> hypoon: forM
21:11:30 <pharpend> hypoon: but it's really just recursion abuse
21:13:00 <hypoon> lol, just googled forM expecting to get haskell results... ("forM", "form", duh...)
21:13:59 <hypoon> forM takes a list, which is exactly what I don't have :-(
21:14:53 <hypoon> pharpend: Is forM really appropriate for my purposes? (I don't know if you've been following along)
21:14:59 <pharpend> no
21:15:07 <pharpend> I haven't been following
21:15:53 <pharpend> it looks appropriate
21:25:06 <glguy> hypoon, I think its "more Haskell" to not lie about the types (lazy IO) than to do so. If something needs to use IO it should have IO in its type
21:25:06 <glguy> but you should do it however works best for you
23:33:29 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org (migrating) | http://downloads.haskell.org'
23:33:29 --- topic: set by geekosaur on [Tue Nov 18 16:03:41 2014]
23:35:07 <ski>   getCountFromDCD = liftM fromIntegral cgetCountFromDCD
23:37:49 <ski> in `getNextFromDCD', i'd case on `mrs' instead
23:37:58 <hypoon> ski: Ooh, I'll definitely do that. The way I have it is inelegant, and I knew it when I wrote it, but I was lazy and in a hurry anyway.
23:38:14 <hypoon> ski: was referring to your liftM suggestion
23:38:37 <ski> and also `case' on `mnextElement'
23:40:16 <hypoon> ski: is there any difference between if/then/else and a case statement, other than elegance? (just curious, I'm going to make those changes as well)
23:40:35 <ski> you possibly want to raise `OTHER_ERROR' as an exception
23:42:02 <hypoon> ski: agree completely with you there... was looking for minimum working code first though. First priority is to make it work on correct and "normal" input. Second priority is to make it fail gracefully otherwise.
23:42:17 <ski> using `foo == []' or `foo == Nothing' is bad style in general, since that will require equality on the element type. better is to use `null foo' and `isNothing foo' (or `isJust foo', if you're negating it)
23:42:49 <hypoon> hLint suggested the same regarding isNothing.
23:43:03 <hypoon> I don't understand why "foo == []" is bad though.
23:43:22 <jle`> you need Eq a => [a]
23:43:23 <hypoon> oh, now I do.
23:43:31 <ski> but often pattern-matching, in the definiendums of defining equations or in a `case', will look nicer -- and the compiler has a better chance of warning for overlapping and inexhaustive cases then
23:45:43 <hypoon> ski: Hm, you're right. Good to know.
23:48:16 <ski> hypoon : anyway, you could possibly make an `readDCD :: FilePath -> IO [([Float],[Float],[Float])]'
23:50:06 <hypoon> ski: With what I've learned tonight, that seems like a manner more inline with how IO is generally done in Haskell. Don't explicitly open the file... don't explicitly close the file... if you're using Lazy IO, let all that be hidden behind the scenes, etc...
23:53:04 * ski is looking at <http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-300005.5>
23:59:22 <ski> hypoon : i suppose you'd change `Ptr' to `ForeignPtr' in `type DCDHandle = Ptr DCDHandleStruct'
