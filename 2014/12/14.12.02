00:00:03 <ThreeOfEight> hm, I just tried map Sum vs. coerce for summing a list of 10000000 elements
00:00:15 <ThreeOfEight> it took the same time, both with and without optimisation enabled
00:00:46 <jle`> huh
00:00:47 <haasn> Compare the Core/Cmm/asm
00:00:49 <jle`> hm
00:00:52 <jle`> good call
00:00:57 * jle` gets popcorn
00:00:58 <ThreeOfEight> but maybe my evaluation is just a bad example
00:01:04 <jle`> i could probably also just do it myself
00:01:23 <shachaf> If you're folding anyway maybe it's just getting fused and inlined.
00:01:28 <nshepperd> with list fusion, I think both things should be zero overhead
00:01:32 <nshepperd> in a pipeline
00:02:19 <nshepperd> map foo . map coerce . map bar --> map (foo . coerce . bar) --> map (foo . bar)
00:02:30 <jle`> foldr f z . map g = foldr (f . g) z, so if g = Sum then i guess that turns into foldr (f . Sum) z, which is foldr (f . coerce) z
00:02:56 <sivteck> foldMap
00:03:05 <jle`> which is foldr (\x -> f (Sum x)) z which is foldr (\x -> f x) z which is foldr f z
00:03:43 <ThreeOfEight> without optimisation, the map is still there in Core
00:03:57 <ThreeOfEight> with optimisation, I get a lot of unreadable rubbish ^^
00:04:12 <jle`> how does the unreadable rubbish compare in the two different versions?
00:04:22 <ThreeOfEight> same amount of time
00:04:38 <jle`> i mean, the core
00:04:50 <jle`> are they the same unreadable rubbish?
00:04:59 <ThreeOfEight> ah
00:05:02 <ThreeOfEight> I didn't check yet
00:05:11 <jle`> or are they both unreadable and very different
00:06:48 <ThreeOfEight> they quite different, apart from the beginning
00:06:59 <ThreeOfEight> the coercion version is slightly shorter
00:07:24 <jle`> what is life
00:08:54 <osa1> the fact that QuickCheck doesn't provide an easy way to report failures is very, very annoying. it forces users to define lots of newtypes and Arbitrary instances.
00:10:54 <ThreeOfEight> True, but I think in some cases, it is unavoidable.
00:11:25 <osa1> it also makes tracking the failure a lot harder because I can't provide any custom diagnostics
00:11:26 <ThreeOfEight> I recently had the problem that I had wanted to display not just the value itself, but also how it was constructed.
00:11:47 <Welkin> print the AST?
00:11:55 <osa1> ThreeOfEight: I think if it could let users specify failure messages it would be strictly more flexible.
00:12:01 <ThreeOfEight> but it would be nice to have some way to provide a custom show message
00:12:10 <ThreeOfEight> er, a custom show function
00:12:19 <ThreeOfEight> in fact, is there a newtype for this?
00:12:52 <osa1> I'm wondering if SmallCheck allows this
00:13:05 <ThreeOfEight> newtype Show a = Show (a, String)
00:13:08 <ThreeOfEight> something like this
00:13:24 <ThreeOfEight> with instance Show (Show a) where show (_, s) = s
00:13:55 <ThreeOfEight> and then you could have a wrapShow :: (a -> String) -> a -> Show a
00:13:58 <Maxdamantus> @check \a b -> error "foo"
00:14:00 <lambdabot>  No instance for (Test.QuickCheck.Property.Testable t0)
00:14:00 <lambdabot>  arising from a use of ‘Lambdabot.Plugin.Haskell.Check.ShowQ.myquickcheck’ Th...
00:14:39 <Maxdamantus> @check \a b -> error "foo" :: Bool
00:14:41 <lambdabot>  *** Failed! Exception: 'foo' (after 1 test):
00:14:41 <lambdabot>  () ()
00:25:36 * hackagebot react-haskell 1.1.0.0 - Haskell React bindings  http://hackage.haskell.org/package/react-haskell-1.1.0.0 (joelb)
00:25:36 * hackagebot nats 1 - Natural numbers  http://hackage.haskell.org/package/nats-1 (EdwardKmett)
00:40:32 * hackagebot semigroups 0.16 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.16 (EdwardKmett)
00:43:22 <ThreeOfEight> http://lpaste.net/115487
00:43:33 <ThreeOfEight> Does anyone else think something like this might be useful?
00:43:42 <ThreeOfEight> Or does it already exist and I just always failed to find it?
01:15:33 * hackagebot algebra 4.2 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-4.2 (EdwardKmett)
01:15:35 * hackagebot wl-pprint-extras 3.5.0.3 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-3.5.0.3 (EdwardKmett)
01:15:37 * hackagebot nats 0.1 - Haskell 98 natural numbers  http://hackage.haskell.org/package/nats-0.1 (HerbertValerioRiedel)
01:17:52 <yesthisisuser> It looks like the urlencoded package is missing a dependency for network-uri. Something happened to this library: "In network-2.6 the Network.URI module was split off from the network package into this package.". Where/how does one report this?
01:18:22 <yesthisisuser> email the maintainer or?
01:19:19 <Haskellfant> email the maintainer or if it there's some issue tracke
01:19:25 <Haskellfant> r e.g. github use that
01:19:55 <Haskellfant> which seems to be the case here
01:20:11 <Haskellfant> there is already an issue for that
01:20:15 <Haskellfant> https://github.com/pheaver/urlencoded/issues/2
01:20:29 <Haskellfant> last commit in 2012 hm
01:20:33 <yesthisisuser> ah. ok. well..
01:20:33 * hackagebot wl-pprint-terminfo 3.7.1.3 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.7.1.3 (EdwardKmett)
01:20:35 * hackagebot nats 0.1.2 - Haskell 98 natural numbers  http://hackage.haskell.org/package/nats-0.1.2 (HerbertValerioRiedel)
01:20:37 * hackagebot nats 0.1.3 - Natural numbers  http://hackage.haskell.org/package/nats-0.1.3 (HerbertValerioRiedel)
01:20:39 * hackagebot nats 0.2 - Natural numbers  http://hackage.haskell.org/package/nats-0.2 (HerbertValerioRiedel)
01:22:46 <yesthisisuser> Maybe there is another library that can parse www-form-urlencoded. I can always patch above mentioned, or roll my own, of course.
01:24:24 <dmj`> yesthisisuser: a lot of http-client libs come packed with [ (ByteString, ByteString) ] list to handle urlencoded parameters, what are you trying to do?
01:27:34 <yesthisisuser> i just want to parse them in a way which is standards-conforming..
01:28:29 <dmj`> ok so you're receiving them in the body of a request?
01:28:45 <dmj`> or response
01:29:48 <yesthisisuser> in the request
01:31:08 <osa1> wow. so I have a thread which calls an `IO ByteString` in a loop and sends results to some other thread and if I print the bytestring it reads, it's sending one extra message to other thread.
01:31:13 <osa1> all I change is printing
01:31:14 <solatis> you know, i really have a hard time doing event based programming in haskell... mainly because it doesn't exist
01:31:33 <yesthisisuser> i'll just cabal get urlencoded and install network-uri, for now
01:31:39 <solatis> i'm *so* used to doing callback-based things
01:44:20 <osa1> anyone here using this package http://hackage.haskell.org/package/strict-concurrency?
01:44:36 <osa1> I think it doesn't work with base 4.7
01:46:46 <solatis> osa1: i'm always wary about packages whose last updated date is 4 years ago...
01:46:51 <solatis> GHC changed a lot
01:47:09 <solatis> (and isn't necessarily backwards compatible)
01:47:51 <osa1> "2947 in last 30 days" that package is used though
01:48:07 <osa1> sorry, "136 in last 30 days"
01:48:11 <solatis> 1409 total (136 in last 30 days)
01:48:13 <solatis> that's what i see?
01:48:24 <osa1> yep, I looked to wrong package
01:48:29 <solatis> anyway
01:49:09 <solatis> it's not available in nixos, which automatically compiles everything available on hackage -- and rejects anything that doesn't compile
01:49:22 <solatis> mostly, not being on nix means not compatible with latest releases
01:49:41 <sivteck> everything? :-O
01:49:59 <sivteck> there's only ~1200 packages on Nix
01:50:34 * hackagebot void 0.1 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.1 (HerbertValerioRiedel)
01:50:37 * hackagebot void 0.2 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.2 (HerbertValerioRiedel)
01:50:38 * hackagebot void 0.3 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.3 (HerbertValerioRiedel)
01:50:40 * hackagebot void 0.4 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.4 (HerbertValerioRiedel)
01:50:42 * hackagebot void 0.5.0 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.0 (HerbertValerioRiedel)
01:50:50 <solatis> sivteck: i thought they automatically checked out everything haskell
01:51:28 <sivteck> i don't think so
01:51:32 <solatis> hmm
01:51:38 <shachaf> hvr: whoa, what's all this?
01:52:24 <thebnq> thats a fast release cycle
01:52:54 <osa1> uhh this is extremely annoying. I'm just changeing one print statement(just a putStrLn) in my program and some unrelated behavior is changing with that.
01:53:04 <dmj`> osa1: paste code?
01:53:07 <solatis> sivteck: this is what i see:
01:53:09 <solatis> nix-env -qaP \* | grep haskellPackages | wc -l
01:53:11 <solatis> 5458
01:53:20 <dmj`> osa1: lpaste.net
01:53:20 <solatis> so 5k haskell packages
01:53:28 <sivteck> no ;x
01:53:30 <osa1> dmj`: it's 1311 loc program with lots of files and modules :)
01:53:46 <sivteck> solatis, count no. of callPackage
01:53:47 <dmj`> osa1: I hope you made it modular :)
01:53:51 <osa1> one sec, I have it on github
01:54:09 <solatis> sivteck: oh geez, i'm a stupid retard
01:54:24 <solatis> one package is compiled many, many times
01:54:25 <osa1> dmj`: that's actually a good opportunity to get some reviews :)
01:54:29 <ChristianS> osa1: maybe your putStrLn refers to a value and hence forces its evaluation?
01:54:37 <osa1> ChristianS: yeah that's what I suspect
01:54:40 <solatis> one for each ghc version i want, one with profiling, one without, etc
01:55:00 <osa1> ChristianS: however when I use `force` it doesn't work as putStrLn
01:55:45 * hackagebot void 0.5.1 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.1 (HerbertValerioRiedel)
01:55:47 * hackagebot void 0.5.2 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.2 (HerbertValerioRiedel)
01:55:49 * hackagebot void 0.5.3 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.3 (HerbertValerioRiedel)
01:55:51 * hackagebot void 0.5.4 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.4 (HerbertValerioRiedel)
01:55:53 * hackagebot void 0.5.4.1 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.4.1 (HerbertValerioRiedel)
01:56:02 <osa1> https://github.com/osa1/rho-torrent/blob/master/src/Rho/Listener.hs#L118 if I put a `print bytes` after this line, it changes some behavior
01:56:07 <solatis> ix-env -qaP \* | grep haskellPackages | awk '{print $2}' | sort | uniq | wc -l
01:56:09 <solatis> 2664
01:56:10 <osa1> dmj`: ^
01:56:12 <solatis> i think that's more accurate :)
01:57:23 <dmj`> osa: torrent lib cool
01:57:30 <dmj`> osa1:
01:57:49 <solatis> osa1: wait, you're working on a torrent lib?
01:57:56 <solatis> i'm working on a torrent lib
01:58:05 <osa1> solatis: everyone working on a torrent lib nowadays :p
01:58:12 <osa1> this is not a lib but a program :)
01:58:15 <solatis> apparently
01:58:17 <solatis> aha
01:58:19 * dmj` wishes he was working on a torrent lib
01:58:48 <solatis> you use libtorrent as a backend or something?
01:58:58 <solatis> or you're rolling out your own full-blown torrent lib?
01:59:00 <osa1> solatis: from scratch, using only Haskell
01:59:19 <solatis> hmmm
01:59:41 <dmj`> hardcore
01:59:42 <solatis> well i'm currently writing a conduit transformer that transforms a bytestring to a torrent object
01:59:56 <gilligan_> hi
02:00:16 <solatis> parsing .torrent files can be a delicate thing
02:00:37 <solatis> damn looks like we share a lot of code :)
02:00:51 <edwardk> shachaf: its putting a bound on it to keep it from trying to install old void versions with base 4.8
02:00:55 * hackagebot void 0.5.4.2 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.4.2 (HerbertValerioRiedel)
02:00:57 * hackagebot void 0.5.4.3 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.4.3 (HerbertValerioRiedel)
02:00:59 * hackagebot void 0.5.5 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.5 (HerbertValerioRiedel)
02:01:01 * hackagebot void 0.5.5.1 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.5.1 (HerbertValerioRiedel)
02:01:03 * hackagebot void 0.5.6 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.6 (HerbertValerioRiedel)
02:01:08 <shachaf> edwardk: Ah. OK.
02:01:10 <osa1> solatis: where's yours?
02:01:36 <solatis> private git repo atm
02:01:47 <osa1> solatis: which part is shared with out project? Metainfo.hs?
02:02:06 <SwashBuckla> logically uninhabited?!
02:02:17 <SwashBuckla> something that logically has no home :(
02:02:33 <shachaf> It's also illogically inhabited, if that helps.
02:02:51 <solatis> osa1: parsing the .torrent file, mainly
02:02:53 <SwashBuckla> I don't think it does help
02:03:06 <solatis> (at the moment)
02:03:51 <solatis> yeah
02:03:56 <solatis> Metainfo.hs is it
02:04:26 <gilligan_> hm.. anyone good with details on ghc-mod here ? I am playing around with vim-watchdogs and ghc-mod integration. The plugin allows for automatic/async ghc-mod invocation even without buffer write (file change) ** however ** : This will write the contents to some temporary file and throw that at ghc-mod which will complain with something like '/tmp/vmWa37q/3' is not a module name or a source file' which is fair enough. This is a bit of a
02:04:26 <gilligan_>  broad question/issue but would anyone happen to have an idea on this ? Wonder how flycheck/emacs does that ?
02:04:43 <osa1> solatis: that file is copied from hstorrent, I initially wrote it for hstorrent but later decided to roll my own version :p
02:04:50 <osa1> I had to do a lot of modifications though
02:04:56 <solatis> hstorrent sucks
02:05:51 <dmj`> gillian_: I'd look into the ghc api
02:06:05 * hackagebot void 0.5.7 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.7 (HerbertValerioRiedel)
02:06:07 * hackagebot void 0.5.8 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.8 (HerbertValerioRiedel)
02:06:09 * hackagebot void 0.5.10 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.10 (HerbertValerioRiedel)
02:06:09 <osa1> so, any ideas about the bug?
02:06:11 * hackagebot void 0.5.11 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.11 (HerbertValerioRiedel)
02:06:13 * hackagebot void 0.5.12 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.12 (HerbertValerioRiedel)
02:06:33 <solatis> osa1: what's the error you get?
02:06:44 <solatis> hvr: what is going on?
02:06:48 <osa1> solatis: I'm not getting any errors, the print statement changes behavior
02:07:08 <solatis> could you elaborate on that?
02:08:14 <osa1> I'm tracking incoming messages using wireshark. I can see a message coming but it's only received by listener thread if I add a `print bytes` here: https://github.com/osa1/rho-torrent/blob/master/src/Rho/Listener.hs#L118
02:08:24 <centrinia> So if someone makes a program that updates hackage with mapM_ (\n -> contributeHackage $ "foobar-1.2." ++ show n) [1..], hackagebot would spam the channel? :(
02:08:43 <solatis> osa1: well to me that means that you're never evaluating the results of the function
02:08:47 <osa1> if I don't put print statement there, then I think it always ignores last message until another message comes
02:08:47 <solatis> thus haskell probably never executes it
02:09:00 <solatis> adding a print statement means it actually has to evaluate the code
02:09:39 <osa1> solatis: that's not the case, see rest of the code
02:09:59 <osa1> solatis: although if there is unsafeInterleaveIO or something like that involved that may be the case
02:11:00 <solatis> i think the only suggestion i can give is to keep on debugging... there is too much code involved for me to make a quick judgement without diving into it completely
02:11:02 <dmj`> centrinia: I'm assuming he's porting an old package to a new package name, but wants to preserve the history. So he's is reuploading old tarballs under new names.
02:11:15 * hackagebot void 0.6 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.6 (HerbertValerioRiedel)
02:11:17 * hackagebot void 0.6.1 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.6.1 (HerbertValerioRiedel)
02:11:19 * hackagebot void 0.7 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.7 (EdwardKmett)
02:11:21 * hackagebot amazonka-core 0.0.7 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.0.7 (BrendanHay)
02:11:23 * hackagebot amazonka 0.0.7 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.0.7 (BrendanHay)
02:11:30 <brnhy> centrinia: you can also /ignore hackagebot if it's too noisy.
02:12:10 <centrinia> Hmm.
02:16:25 * hackagebot amazonka-codedeploy 0.0.7 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.0.7 (BrendanHay)
02:16:27 * hackagebot amazonka-cognito-identity 0.0.7 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.0.7 (BrendanHay)
02:16:29 * hackagebot amazonka-cognito-sync 0.0.7 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.0.7 (BrendanHay)
02:16:31 * hackagebot amazonka-config 0.0.7 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.0.7 (BrendanHay)
02:16:33 * hackagebot amazonka-datapipeline 0.0.7 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.0.7 (BrendanHay)
02:17:43 <dmj`> osa1: I'd probably use an iteratee library like io-streams, makes network programming more deterministic
02:21:35 * hackagebot amazonka-directconnect 0.0.7 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.0.7 (BrendanHay)
02:21:37 * hackagebot amazonka-dynamodb 0.0.7 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.0.7 (BrendanHay)
02:21:39 * hackagebot amazonka-ec2 0.0.7 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.0.7 (BrendanHay)
02:21:41 * hackagebot amazonka-elasticache 0.0.7 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.0.7 (BrendanHay)
02:21:43 * hackagebot amazonka-elasticbeanstalk 0.0.7 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.0.7 (BrendanHay)
02:22:06 <LordBrain> I have a question about the last example here: https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/equality-constraints.html
02:22:21 <tasker> what's my best option for plotting a histogram in haskell ?
02:22:43 <edwardk> LordBrain: whats the question?
02:22:45 <LordBrain> the example one one line is class (F a ~ b) => C a b where type F a
02:23:02 <LordBrain> my question is, is this the same thing as
02:23:13 <dmj`> tasker: https://hackage.haskell.org/package/histogram-fill ?
02:23:30 <LordBrain> class C a b where type F a = b
02:23:48 <LordBrain> ?
02:23:52 <osa1> dmj`: what do you mean by more deterministic?
02:23:54 <tasker> dmj` Looks like that is for creating histograms, but I don't see anything about plotting :s
02:24:35 <LordBrain> if not, what is the difference?
02:25:15 <edwardk> LordBrain: its a bit stronger than you'd expect
02:25:19 <edwardk> lets consider a simpler class
02:25:29 <edwardk> class IsString a
02:25:34 <edwardk> so far so good?
02:25:38 <LordBrain> ok
02:25:46 <edwardk> instance IsString String -- seems plausible right? =)
02:25:49 <edwardk> we even have that in base
02:25:55 <LordBrain> right
02:25:56 <edwardk> but of course
02:26:00 <edwardk> String is a type synonym
02:26:05 <edwardk> so that is instance IsString [Char]
02:26:16 <edwardk> now what happens when you turn on OverloadedStrings
02:26:24 <edwardk> and ask   > length "foo"
02:26:26 <edwardk> ?
02:26:45 * hackagebot amazonka-elastictranscoder 0.0.7 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.0.7 (BrendanHay)
02:26:47 * hackagebot amazonka-elb 0.0.7 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.0.7 (BrendanHay)
02:26:49 * hackagebot amazonka-emr 0.0.7 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.0.7 (BrendanHay)
02:26:51 * hackagebot amazonka-iam 0.0.7 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.0.7 (BrendanHay)
02:26:53 * hackagebot amazonka-importexport 0.0.7 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.0.7 (BrendanHay)
02:27:00 <edwardk> well, length wants its argument to be a list of something, so it knows the arg is [a], but it doesn't know that a is Char per se
02:27:08 <edwardk> so it can't safely pick the instance IsString [Char]
02:27:11 <edwardk> so it complains at you
02:27:14 <edwardk> on the other hand
02:27:15 <edwardk> if we had
02:27:26 <edwardk> instance a ~ Char => IsString [a]
02:27:56 <edwardk> then what we'd get is 'once GHC figures out the argument has the form [a] it can automatically use the fact that a is a Char. that comes along for free
02:28:10 <edwardk> Now, lets return to your more complex example
02:28:21 <edwardk> class (F a ~ b) => C a b where type F a
02:28:35 <edwardk> that says b will _always_ match the second argument of b
02:28:41 <edwardk> any attempt to make it not match won't typecheck
02:29:05 <edwardk> we can't actually write type F a = b in there though, because type F a = ... is allowed to reference 'a'
02:29:20 <edwardk> you can write type F SomeA = SomeB in particular instances
02:29:33 <edwardk> but the line you asked about can't actually be written
02:29:48 <edwardk> that make any sense?
02:29:59 <LordBrain> so what i proposed wont compile?
02:30:03 <edwardk> correct
02:30:21 <edwardk> but also the thing that they say there is a bit stronger
02:30:42 <edwardk> because type Foo a = Bar in a class declaration for a class associated type is just setting the 'default'
02:30:54 <edwardk> you can still override it to be something else
02:31:35 <LordBrain> how do you override it?
02:31:55 * hackagebot amazonka-kinesis 0.0.7 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.0.7 (BrendanHay)
02:31:57 * hackagebot amazonka-kms 0.0.7 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.0.7 (BrendanHay)
02:31:59 * hackagebot amazonka-lambda 0.0.7 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.0.7 (BrendanHay)
02:32:01 * hackagebot amazonka-opsworks 0.0.7 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.0.7 (BrendanHay)
02:32:03 * hackagebot amazonka-rds 0.0.7 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.0.7 (BrendanHay)
02:32:10 <dmj`> osa1: the reading of a handle won't be tied to lazy evaluation. Iteratees process bytes incrementally, and can be composed. Look at the handleToInputStream function here: https://hackage.haskell.org/package/io-streams-1.2.0.1/docs/src/System-IO-Streams-Handle.html#handleToInputStream. It only reads 32kb at a time.
02:32:26 <dmj`> when you call read
02:32:40 <dmj`> strictly too
02:35:19 <LordBrain> they call that type statement appearing in the class definition a type function right?
02:36:26 <LordBrain> it seems to me that this is maybe a misnomer
02:37:05 * hackagebot amazonka-redshift 0.0.7 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.0.7 (BrendanHay)
02:37:07 * hackagebot amazonka-route53 0.0.7 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.0.7 (BrendanHay)
02:37:09 * hackagebot amazonka-route53-domains 0.0.7 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.0.7 (BrendanHay)
02:37:09 <LordBrain> i think of type function as something which takes types as arguments and gives a type as a result.
02:37:11 * hackagebot amazonka-s3 0.0.7 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.0.7 (BrendanHay)
02:37:13 * hackagebot amazonka-sdb 0.0.7 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.0.7 (BrendanHay)
02:37:41 <dmj`> how the heck did that guy cover the entire aws api
02:38:01 <shachaf> What type statement?
02:38:57 <SwashBuckla> dmj`: yes, that seems like a monumental accomplishment. The API is a beast
02:39:35 <LordBrain> shachaf, well if you scroll back to see the example i was discussing with edwardk, I'm referring to F.  as in class (F a ~ b) => C a b where type F a
02:39:49 <shachaf> Why isn't that a type function?
02:39:53 <shachaf> a is a type, and F a is a type.
02:40:04 <SwashBuckla> I've done some stuff with it and there are various legacy versions of each business object, all lumped into the same documentation
02:40:04 <LordBrain> well, yes in that case it is
02:40:32 <brnhy> dmj`: I generated it! Because I am lazy.
02:40:49 <SwashBuckla> brnhy: :O
02:41:11 <LordBrain> but in general, in the case of a type Foo a = Bar inside the class, where now Foo a doesn't necessarily give Bar ...
02:41:57 <dmj`> SwashBuckle: yea, indeed
02:42:06 <edwardk> LordBrain instance C A B where type F A = C
02:42:11 <LordBrain> shachaf, edwardk said it only defaults to Bar but might be overridden
02:42:15 * hackagebot amazonka-ses 0.0.7 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.0.7 (BrendanHay)
02:42:17 * hackagebot amazonka-sns 0.0.7 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.0.7 (BrendanHay)
02:42:19 * hackagebot amazonka-sqs 0.0.7 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.0.7 (BrendanHay)
02:42:21 * hackagebot amazonka-storagegateway 0.0.7 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.0.7 (BrendanHay)
02:42:23 * hackagebot amazonka-sts 0.0.7 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.0.7 (BrendanHay)
02:42:27 <shachaf> LordBrain: Right, which is why it's a function.
02:42:51 <shachaf> Maybe F Int = Char and F Double = Bool
02:43:15 <edwardk> the class (F a ~ b) => C a b where type F a :: * -- this version can never be given a definition of type F a = ... for anything other than b.
02:43:52 <LordBrain> i see now
02:43:53 <SwashBuckla> dmj`: oh, I meant the marketplace API. I've not done anything with the AWS api.
02:44:09 <shachaf> Maybe I missed the beginning of the conversation.
02:44:10 <SwashBuckla> just realised :P
02:44:30 <shachaf> Is this about translating funcitonal dependencies to associated types?
02:45:36 <dmj`> brnhy: how?
02:45:46 <dmj`> black magic
02:46:21 <LordBrain> I think, having not used this stuff in so long, I forgot it all, and when I saw that example,  i conflated type Blah = Blah in the class with type Blah = Blah in the instance
02:47:06 <brnhy> dmj`: AWS vendors JSON service descriptions they have generated internally of their services, with each SDK - https://github.com/aws/aws-sdk-net/tree/master/ServiceModels and https://github.com/boto/botocore/tree/develop/botocore/data/aws - for example. Some ghetto AST transformations + template rendering later and you have an API client.
02:47:25 * hackagebot amazonka-support 0.0.7 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.0.7 (BrendanHay)
02:47:27 * hackagebot amazonka-swf 0.0.7 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.0.7 (BrendanHay)
02:47:29 * hackagebot amazonka-core 0.0.7.1 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.0.7.1 (BrendanHay)
02:47:50 <brnhy> There has been talk about releasing the service descriptions as a standalone repository, but for now, it seems to be consistent across all their SDKs.
02:50:37 * hackagebot free 4.10.0.1 - Monads for free  http://hackage.haskell.org/package/free-4.10.0.1 (EdwardKmett)
02:54:12 <dmj`> brnhy: that's some serious transformation, dynamo uses json, s3 xml, everything seems to have come out just right though. Is your code-gen in the library too? Did you add a query dsl for dynamo per chance? Would you be open to supporting different backends? (pipes-http, http-streams)
02:55:37 * hackagebot egison 3.3.16 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.16 (SatoshiEgi)
02:56:47 <brnhy> dmj`: It's large, but there are consistencies (ignoring EC2/S3 specifics) - with Query, JSON, or XML serialisation, and either rest or non-rest request/response styles. The pain is mainly in edge cases, and that the service descriptions don't offer as much type information or refinements as you'd like in a language like Haskell.
02:57:24 <brnhy> dmj`: I won't add things like a query DSL for dynamodb, it'd be better to build that as an additional library/layer on top of.
02:58:10 <brnhy> And as for iostreams/pipes - I will at some point make the library streaming agnostic, it was just quicker to develop using conduit, as all my code on top of has a dependency there.
03:00:10 <dmj`> brnhy: bravo, it's quite a feat. Well done. Did you generate the V4 signing code as well?
03:00:37 * hackagebot free 4.9 - Monads for free  http://hackage.haskell.org/package/free-4.9 (HerbertValerioRiedel)
03:00:39 * hackagebot free 4.7 - Monads for free  http://hackage.haskell.org/package/free-4.7 (HerbertValerioRiedel)
03:00:41 * hackagebot free 4.7.1 - Monads for free  http://hackage.haskell.org/package/free-4.7.1 (HerbertValerioRiedel)
03:01:01 <brnhy> No, everything under https://github.com/brendanhay/amazonka/tree/develop/core is hand written, only the amazonka-<service> libraries are generated
03:01:18 <dmj`> brnhy: omg 5.7M++ lines committed
03:01:33 <brnhy> Yes, it's been a long (nearly) 2 years :)
03:01:41 <wei2912> brnhy: O_O
03:01:47 <dmj`> brnhy: bravo, well done
03:02:47 <brnhy> Thanks, hopefully when it approaches a more stable release some people will find it useful. I'm quite keen on infrastructure work in Haskell myself, so it'd be nice if others have the tools to do the same.
03:05:37 * hackagebot free 4.8.0.1 - Monads for free  http://hackage.haskell.org/package/free-4.8.0.1 (HerbertValerioRiedel)
03:05:39 * hackagebot free 4.8 - Monads for free  http://hackage.haskell.org/package/free-4.8 (HerbertValerioRiedel)
03:22:23 <SwashBuckla> http://json.org/ is one of the most beautiful sites
03:22:48 <dmj`> it's got nothin' on http://jwt.io/
03:23:02 <SwashBuckla> I love those grammar rule diagrams
03:25:26 <SwashBuckla> what are those diagrams on json.org called?
03:25:41 <SwashBuckla> production rules diagrams?
03:32:42 <bergmark> SwashBuckla: crockford calls them railroad diagrams
03:33:22 <SwashBuckla> hmph
03:33:25 <bergmark> SwashBuckla: https://plus.google.com/+DouglasCrockfordEsq/posts/VDof7dpYCn8
03:35:46 <agocorona> some magic tric for a monadic/applicative expression that writes itself to a string?
03:35:48 <lpaste_> mbuf pasted “Without” at http://lpaste.net/115492
03:35:52 <agocorona> trick
03:37:54 <SwashBuckla> bergmark: thanks for that. I now have http://jex.im/regulex/
03:39:19 <tasker> I've got an array from Data.Array that contains integers. Is there some way to plot/display this, like you would with imshow in python?
03:39:33 <tasker> well, numpy
03:40:02 <mbuf> why is the with 'parallel' construct code slower than the one without? http://lpaste.net/edit/115492
03:44:00 <kvanb> mbuf: intel cpu?
03:44:35 <kvanb> simple answer is shared resources
03:44:47 <kvanb> ALU etc
03:45:46 <jeltsch> When will GHC 7.10 be frozen?
03:46:09 <ski> SwashBuckla : here's some more syntax diagrams for you <http://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_10002.htm>,<http://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_7002.htm>
03:46:13 <ski> (<https://en.wikipedia.org/wiki/Syntax_diagram>)
03:46:39 <sivteck> mbuf, try ghc -threaded parallel.hs
03:47:35 <k00mi> tasker: sure, the easyplot package is good to get started
03:48:16 <kvanb> mbuf: actually thats a good point, I overlooked that
03:48:29 <kvanb> you need to build with -threaded enabled otherwise it's still just going to run on 1 core.
03:48:48 <k00mi> he does build with -threaded
03:49:11 <kvanb> Ah, yes he does.
03:49:12 <tasker> k00mi: Cool, that looks like good. I also noticed the diagrams package - would it be worth looking at for this ?
03:49:20 <sivteck> ah
03:49:24 * sivteck hides
03:49:40 <luite> jeltsch: ther eis no 7.10 branch yet, but it was delayed until last friday, from friday a week earlier, with an RC planned before christmas, so i'd treat it as 'any minute now' :)
03:50:22 <k00mi> tasker: diagrams is not really for plotting, more for creating images, but it is a really cool library that is worth looking at anyway :-)
03:50:31 <tasker> hmm okay.
03:50:39 <jeltsch> luite: So is it still possible to get some code into GHC 7.10? I am interested in having arrow variants of lambda case.
03:51:15 <k00mi> I suppose you can use it for plotting, but you'd have to do everything (bars, annotations, etc.) by hand
03:51:21 <luite> jeltsch: hehe ask thoughtpolice or hvr
03:51:28 <k00mi> unless someone already created a plotting library on top of diagrams
03:51:40 <ClaudiusMaximus> Chart has a diagrams backend iirc
03:51:48 <tasker> k00mi: I guess I'm not really plotting in the traditional sense, though. Just looking at a matrix of values.
03:52:43 <tasker> maybe Graphics.Rendering.Chart.Plot.Points would work..
03:52:44 <jeltsch> thoughtpolice, hvr: HI, is it still possible to get some code into GHC 7.10? I would like to have arrow variants of lambda case in GHC 7.10.
03:53:43 <SwashBuckla> ski: I've gone all tingly
03:53:57 <SwashBuckla> these syntax diagrams are nice
03:56:08 <matematikaadit> So, a few days ago I see this Regex Crosswords game: http://regexcrossword.com/. Now, I'm wondering whether similar game concept could be applied to Haskell. Something like matching an expression and it's Type in a Crosswords.
03:56:13 <k00mi> Chart does look really cool
04:14:58 <mbuf> kvanb, yes intel
04:15:27 <mbuf> sivteck, I tried with ghc -threaded parallel.hs, but, the time is higher than the code without parallel
04:15:59 <kvanb> mbuf: how many cores does your computer have and are they hyperthreaded
04:16:21 <mbuf> kvanb, 4 cores
04:16:31 <kvanb> have you tried building with -rtsotps
04:16:33 <mbuf> kvanb, how do I check for hyperthreaded?
04:16:36 <kvanb> and running with +RTS -N4
04:16:42 <epichero> what does everyone use for to code haskell ? emacs, vim, lighttable, Yi (i just saw)
04:16:53 <kvanb> epichero: Sublime Text
04:17:01 <kvanb> easy to pick up, easy to run with, works out the box
04:17:12 <kvanb> dont have to be a terminal hero to use it
04:17:36 <kvanb> power users work with emacs I've heard
04:17:51 <kvanb> although some professors on youtube show heavily modded vim
04:18:33 <chpatrick> epichero: sublime here too
04:18:37 <chpatrick> vim if it's something small
04:19:23 <epichero> i've setup emacs with evil mode and heavily modded bot emacs and vim. I haven't used sublime for a while tho hm
04:20:42 <kvanb> multiple cursors in sublime just feel like godmode for some haskell refactoring tasks
04:21:06 <kvanb> (cmd-click on OS X, ctrl-click everywhere else)
04:21:55 <tdammers> epichero: vim. vim for everything.
04:22:03 <sipa> mcedit
04:22:53 <k00mi> mbuf: hard to say without profiling, but the overhead for creating the threads might be larger than what is gained by doing the work in parallel
04:24:09 <kvanb> k00mi: not enough to make 0.1 seconds of difference
04:24:17 <sivteck> mbuf, fwiw, compiling with O2 flag i get http://lpaste.net/115493
04:25:20 <sivteck> (parallel is ~5 times faster ;o)
04:27:01 <k00mi> kvanb: I don't know how much overhead the threaded runtime adds, but it's useless to speculate without profiling
04:28:16 <kvanb> you can spawn millions of haskell tasks in seconds with almost no memory or CPU overhead
04:28:20 <kvanb> it's not a threading thing.
04:28:41 <kvanb> If you tried that in Java, C++ or Erlang, yeah it'd be a threading thing
04:29:33 <kvanb> But Haskell is optimised to hell around lightweight threads, and it's very very safe enough to assume they're 'approaching free' generally.
04:29:41 <kvanb> /s/haskell/ghc
04:30:25 <k00mi> kvanb: that's for green threads only, you still have to create a number of OS threads to take advantage of multiple cores
04:30:47 <ski> epichero : `emacs -nw' (or `emacsclient -nw') here
04:31:02 <epichero> thanks
04:31:04 <kvanb> runtime creates threads on boot and boots in less than actually measurable time.
04:31:42 <tdammers> doesn't erlang do pretty much the same? isolated green threads multiplexed onto OS threads?
04:31:44 <epichero> you are telling programmers they can't measure something... those sound like fighting words
04:31:46 <kvanb> there are some exceptions, like more OS threads are spawned when you heavily utilise certain types of FFI
04:31:59 <kvanb> but this code clearly doesn't do that
04:32:07 <kvanb> tdammers: kind of
04:32:20 <kvanb> ours is a lot lighter and generally all round better.
04:32:39 <tdammers> ours is typesafe :D
04:32:54 <kvanb> even the erlang book says "we designed it to handle this, but in reality if you spawn more than like 1000 you're screwed and our system will burn"
04:33:04 <kvanb> "design around it"
04:33:35 <kvanb> haskell greenthreads are free enough to not be a design consideration
04:33:36 <epichero> they are heavier
04:33:41 <epichero> yeah
04:33:46 <kvanb> heck, people spawn them like they spawn mutexes in C++
04:33:49 <kvanb> just to wait on other stuff
04:34:03 <kvanb> and they cost about the same
04:34:29 <kvanb> common idiom is snakes and ladders with MVars waiting in a chain where threads are just used like a C++ condition variable
04:36:02 <epichero> Should I go through a book first, or just start with tutorials?
04:36:09 <kvanb> so, a good book is
04:36:17 <kvanb> Simon Marlow
04:36:23 <kvanb> Parallel and Concurrent Programming in Haskell
04:36:37 <k00mi> kvanb: ok, you've convinced me
04:36:38 <kvanb> or you mean, to start Haskell?
04:36:55 <epichero> To start Haskell
04:37:14 <kvanb> @where lyah
04:37:14 <lambdabot> http://www.learnyouahaskell.com/
04:37:18 <epichero> k
04:37:18 <kvanb> this one is imo the best.
04:37:33 <kvanb> also, bitemyapp
04:37:35 <moop> @where moop
04:37:35 <lambdabot> I know nothing about moop.
04:37:38 <moop> :(
04:37:40 <epichero> That's what i've got open atm
04:37:43 <epichero> lyah
04:37:49 <kvanb> https://github.com/bitemyapp/learnhaskell
04:38:10 <kvanb> this is basically top to bottom noob to pro reading list
04:38:16 <kvanb> should do LYAH first though
04:38:40 <kvanb> theres also Real World Haskell
04:38:42 <sivteck> the wikibook is great too (use it as reference)
04:38:44 <kvanb> @where RWH
04:38:44 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:38:51 <sivteck> @where wikibook
04:38:51 <lambdabot> http://en.wikibooks.org/wiki/Haskell
04:38:51 <kvanb> RWH is a little outdated
04:39:13 <kvanb> it talks about monad libraries that dont even exist anymore and stuff
04:39:16 <kvanb> but aside from that, pretty good
04:39:58 <Aruro> how can i see precedence value of an operator from ghci?
04:40:43 <ClaudiusMaximus> Aruro: :info (+)  -- for example
04:41:50 <epichero> now instead of learning haskell, or doing any coding at all i will mess with vim to get multiple cursors working again...
04:41:57 <epichero> whoever brought that up must hate me
04:42:06 <wei2912> epichero: :(
04:42:33 <epichero> :)
04:42:51 <tdammers> vim can do multiball?
04:43:16 <epichero> vim can do anything, vim can do anything well as long as anything isn't a repl
04:43:32 <epichero> and if we are lucky neovim will do that
04:44:05 <Aruro> how can i define infixl in ghci?
04:44:09 <morvkala> vim scripting is turing complete, so if vim apparently can't do something, you're just not trying hard enough.
04:44:10 <Aruro> it does not seem to accept it
04:44:40 <osfameron> oh!  who is making neovim?
04:45:05 <Aruro> also by default infix operator seems left associative ?
04:45:12 <kvanb> I rip my travis scripts from neovim
04:45:22 <kvanb> best part of neovim is their build system
04:45:50 <wei2912> morvkala: can vim factorize huge numbers? :P
04:45:57 <epichero> it can
04:45:57 <wei2912> *ducks*
04:46:10 <morvkala> give infinite time and ram????
04:46:12 <bjornars1> vim can tell you if the program you are writing contains an infinite loop
04:46:13 <epichero> you didn't ask about speed
04:46:17 <wei2912> ehh
04:46:24 <wei2912> bjornars1: haha
04:46:28 <jle`> it can test if a number is prime too
04:46:37 <ClaudiusMaximus> Aruro: you have to declare fixity at the same time as the operator, in the same let statement for example
04:46:40 <wei2912> is vim more powerful than emacs?
04:46:43 <ski> Aruro : `let infixr 9 .:; (.:) = (.) . (.)'
04:46:49 <kvanb> wei2912: dont bring that up here
04:46:54 <kvanb> you'll get ousted out of the channel
04:47:01 <wei2912> D:
04:47:01 <morvkala> emacs is written in lisp, lisp is that thing which all the cool kids use, so obviously not.
04:47:03 <epichero> no point in trolling
04:47:07 <morvkala> emacs scripting, that is.
04:47:13 <kvanb> you could troll
04:47:17 <kvanb> but you'd have to be using emacs
04:47:21 <wei2912> haha
04:47:36 <kvanb> http://imgs.xkcd.com/comics/lisp.jpg
04:47:40 <Aruro> ty guys
04:47:48 <epichero> i have emacs setup to work like vim anyways heh
04:48:43 <morvkala> God seems like the type who'd go for imperative programming, to be honest.
04:48:55 <morvkala> Nice and procedural. Lots of creating objects explicitly.
04:49:06 <morvkala> And ordering his minions to do things 40 times, etc.
04:49:12 <Aruro> lol
04:49:23 <kvanb> universe is FRP
04:49:24 <morvkala> Also, I think he'd use some old man language nobody uses anymore, like pascal.
04:49:34 <epichero> cobol
04:49:35 <Aruro> basic
04:49:37 <Aruro> is better
04:49:38 <epichero> fortran
04:49:38 <morvkala> cobol
04:49:41 <morvkala> yeah, that's better.
04:49:48 <lieven> RPG IV
04:49:53 <epichero> algol58
04:49:54 <kvanb> &Walk F3
04:49:59 <kvanb> &Breath F4
04:50:08 * ski . o O ( obligatory editor comparision picture <http://mrozekma.com/editor-learning-curve.png> )
04:50:10 <wei2912> morvkala: cobol isn't enough, we need object oriented cobol!
04:50:21 <kvanb> coolbol?
04:50:27 <lieven> Add One to Cobol giving Cobol-Plus-One
04:50:33 <wei2912> lol
04:50:36 <Aruro> there is a lot of fp in language
04:50:44 <Aruro> so technically that gives escape :)
04:50:57 <Aruro> universe is filled with chatter
04:51:28 <Aruro> so 1 1 up to now :D
04:52:50 <Aruro> number of texts written should soon exceed everything what have been ever made by humans
04:53:07 <Aruro> number of words and sentences had done it long time ago :)
04:53:13 <Aruro> so universe is fp.
04:53:17 <Aruro> period.
04:53:30 <morvkala> ?
04:53:58 <wei2912> no idea either
04:54:13 <morvkala> my grok procedure just said something about a lemon and going on a vacation to saturn
04:54:25 <Aruro> man read what you wrote before
04:54:25 <morvkala> Can't even emit a proper error code anymore.
05:00:42 * hackagebot lens 4.6 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.6 (HerbertValerioRiedel)
05:00:44 * hackagebot lens 4.5 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.5 (HerbertValerioRiedel)
05:01:19 <luite> hm looks like i'm way behind on lens upper bound bumping
05:03:20 <shirt> Anyone ever get this error from http-conduit: TlsException (HandshakeFailed (Error_Protocol ("certificate rejected: chain doesn't match",True,CertificateUnknown)))
05:05:42 * hackagebot lens 4.4.0.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.4.0.2 (HerbertValerioRiedel)
05:06:49 <RchrdB> shirt: that sounds like your HTTP client thwarting a MITM attack for you ;)
05:08:15 <RchrdB> shirt: presumably either the server you're trying to connect to has a self-signed cert or a cert signed by some authority that your OS's root certificates bundle doesn't include...
05:08:51 <shirt> RchrdB: every browser handles the cert fine. only this haskell program bugs out on it, it's looking like a bug to me somewhere in the haskell stack
05:09:31 <RchrdB> shirt: ...or maybe your https client library isn't picking up the root cert bundle.
05:10:42 * hackagebot lens 4.4 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.4 (HerbertValerioRiedel)
05:10:44 * hackagebot lens 4.4.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.4.0.1 (HerbertValerioRiedel)
05:10:46 * hackagebot lens 4.3.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.3.3 (HerbertValerioRiedel)
05:10:48 * hackagebot lens 4.3.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.3.2 (HerbertValerioRiedel)
05:10:50 * hackagebot lens 4.3.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.3.1 (HerbertValerioRiedel)
05:11:26 <RchrdB> (cue a frantic dig through [http-conduit, http-client-tls, connection, tls, x509]
05:15:52 * hackagebot lens 4.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.3 (HerbertValerioRiedel)
05:16:21 <hvr> I think that should be enough for cabal trying to install lenses we know won't build w/ base-4.8
05:16:30 <hvr> +keeping from
05:18:20 <michaelt_> hvr: Ah, I see, I thought hackagebot was going backward in time. But that's sort of the point.
05:20:40 <aranea> I'm interested in implementing data structures like red-black trees and letting GHC prove that the implementation maintains the associated invariants. As a simple start, I'd like to implement a simple binary search tree this way. But I really can't wrap my head around how to.
05:22:19 <michaelt_> aranea: there is a demo of using the kind system to maintain invariants for red-black trees in the ghc test suite.
05:23:08 <aranea> Oh, really? I didn't know that. I've only found https://github.com/jstolarek/dep-typed-wbl-heaps-hs so far.
05:23:15 <aranea> I'll have a look, thanks!
05:24:05 <michaelt_> https://github.com/ghc/ghc/blob/master/testsuite/tests/polykinds/RedBlack.hs aranea. Or does that look like the kind of thing you mean?
05:28:56 <jkarni1> I know about the general constrained monad problem, but are there cleaner approaches when the class you're trying to use as a constraint holds of all types (i.e., it has a instance Cls a declaration)?
05:29:25 <jkarni1> I imagine not, but that seems unfortunate...
05:31:24 <shirt> RchrdB: something is definitely wrong with the haskell libs. A request to "https://www.mydomain.com/" works, but "https://www.mydomain.com/foo/" gives a TlsException
05:33:12 <RchrdB> shirt: offhand I have no idea, sorry.
05:33:26 <aranea> michaelt_: I'll have a look at all these tests. Thanks for that link!
05:33:49 <michaelt_> aranea, great
05:50:37 <oscar_toro> lets say a function 'compute' receive a list "ab1" :: [Char] and a number. I want to compute all the possible combinations for 2 or more characters [[Char]] including previous values.  computes 2 "ab1" = [['a','a'],['a','b'],['a','1'],['b','a'],['b','b'],['b','1'],['1','a'],['1','b'],['1','1']]. Do you give me some ideas?
05:55:44 * hackagebot lens 4.6.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.6.0.1 (EdwardKmett)
05:56:58 <zmbmartin> I am not really sure how mkWeak works. I really need this method mkWeakTMVar https://ghc.haskell.org/trac/ghc/ticket/9169 but it is not in stm yet. How can I create a mkWeakTMVar myself?
05:58:40 <favetelinguis> why is f not in scope on line 6? http://lpaste.net/115496
05:58:57 <favetelinguis> i have follwed the example exactly so is it wrong in the example?
06:01:19 <lieven> favetelinguis: indentation problem perhaps?
06:01:35 <favetelinguis> hmm yes probably is
06:02:37 <michaelt_> favetelinguis: I get a bit confused by this, but if you indent +++ one space further it will be on a level with the inner do block; as it is, you are comparing the whole do block with 'return f', but f only exists in the block
06:03:51 <gp5st1> I'm working on an application where I'd like multiple threads to access the same graph. Each edge of this graph will contain a weight that will only decrease as a result of the computation.  What would be the best way to deal with this? a CAS loop?
06:03:56 <favetelinguis> yes it looks strange to me to must have been a type in the lecture notes
06:05:26 <michaelt_> favetelinguis: when I do this, I usually line up the beginning of the operator with the break between d and o in "do" then the do block is one thing, and the stuff on the other side of the operator is another thing, linked by the operator
06:06:11 <gp5st1> I should say, should only decrease. Essentially I will be selecting the lowest of the current and a new candidate weight
06:07:06 <aranea> I'm playing around with GHC.TypeLits for type-level Nats. But I need singleton types, and there seems to be SNat, but it isn't exported.
06:07:22 <jkarni1> oscar_toro: sequence $ replicate n "ab1", I think
06:07:32 <jkarni1> > sequence $ replicate 2 "ab1"
06:07:33 <lambdabot>  ["aa","ab","a1","ba","bb","b1","1a","1b","11"]
06:10:07 <oscar_toro> jkarni1: thank you very much!!!!
06:10:49 <jkarni1> oscar_toro: glad to help
06:11:00 <osa1> so what happens if I recv from a closed socket? (using network package)
06:19:31 <hemlis> hi
06:19:38 <hemlis> is this a good lang to start with programming ?
06:19:56 <sivteck> yes.
06:20:38 <ij> It might be tough sometimes, but it's undoubtely doable. I taught it to my teenage brother.
06:20:43 <gp5st1> hemlis: sure. just be ware that it is very particular about what a correct program is.
06:21:16 <hemlis> but what a correct program is ?
06:22:53 <ij> If you were to say 5 + "an apple", it would say that it is not correct, because how would you add an integer to text? But it would allow 5 + 9.
06:23:17 <ij> hemlis, What are you going to read to learn it, though?
06:23:42 <ij> Also, there's #haskell-beginners
06:23:45 <pantsman> If you've not programmed before, you're not going to be surprised that you can't add the number 5 to an apple.
06:23:47 <hemlis> ij: online book ?
06:24:00 <michaelt_> pantsman++
06:24:16 <narendraj9> hemlis: If you have studied Physics, you must have used the dimensions trick to eliminate some options in a quiz. Haskell compiler uses it always.
06:24:21 <hemlis> but I want to know is haskell possible without any knowledge of imperative programming ?
06:24:31 <ij> Yeah, totally.
06:24:34 <hemlis> narendraj9: ah
06:24:52 <hemlis> ij: ok
06:24:53 <gp5st1> hemlis: languages like python (to a degree) and php (much much less) will let you do almost anything with almost anything. haskell has a very well defined type system specifying what can and cannot be done. Also, Haskell has immutable variables, which may throw you for a loop at first
06:24:54 <ij> narendraj9, That's a nice way to put it.
06:24:55 <narendraj9> hemlis: You add a length to a length not to a velocity.
06:25:20 <michaelt_> hemlis: emphatically yes. Anyone who didn't have a problem with high school algebra can learn elementary haskell.
06:25:45 * hackagebot units-parser 0.1.0.0 - A parser for units of measure  http://hackage.haskell.org/package/units-parser-0.1.0.0 (AdamGundry)
06:25:45 <hemlis> michaelt_: what is the scope of GUI prgramming in Haskell ?
06:27:07 <tobiasgw> any suggestions for a package that'll help me get signatures for functions and type declarations of a given Haskell module?
06:27:10 <michaelt_> scope?
06:28:17 <tobiasgw> I've been looking at Haddock, but it's a pretty big codebase
06:28:18 <michaelt_> tobiasgw: you mean, the output of :browse in ghci?
06:28:24 <tobiasgw> yes! Exactly
06:28:53 <bergmark> i forget it haskell-names includes type sigs that are in the ast
06:29:22 <tobiasgw> there doesn't seem to be a command line option equivalent for :browse you could pass to ghci?
06:29:48 <michaelt_> tobiasgw: it can be arranged, but it presupposes that the compiler has access to all the imports.
06:30:13 <tobiasgw> right
06:30:25 <tobiasgw> I think I can live with that, though
06:30:36 <pantsman> why is it that when a beginner joins and asks about Haskell, people seem to want to talk about Python instead. Weird.
06:32:00 <tobiasgw> bergmark: yeah, seems haskell-names might be able to do it
06:33:03 <luite> tobiasgw: you could try ghc-mod or ghci-ng
06:35:45 * hackagebot ede 0.2.4 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.4 (BrendanHay)
06:40:30 <moop> pantsman: python is basically haskell, but easier
06:42:06 <HugoDaniel> which in turn is basically brainf*ck
06:42:29 <moop> brainf* is just python for minimalists
06:42:47 <moop> and frugal people
06:42:56 <moop> can't waste them precious bytes
06:43:15 <lieven> the true connoisseur programs in malbolge
06:43:29 <lpaste_> michaelt pasted “get exports” at http://lpaste.net/115504
06:43:48 <michaelt_> tobiasgw: ^^^ this does it, for a diy solution
06:47:52 <michaelt_> tobiasgw: that is, given a module name on the command line, it spills out all the types classes and function signatures that are exported
06:49:25 <Procian> Anyone familiar with pipes(-safe)?
06:50:03 <michaelt_> Procian: pipes yes, pipes-safe ... not so much
06:51:07 <michaelt_> Procian: what's the problem?
06:51:50 <Procian> michaelt_: I'm trying: P.runSafeT $ P.toListM $ mapM_ (\f -> P.readFile f P.>-> P.take 1) fs)
06:52:07 <Procian> Sorry, I'll get rid of the P.
06:52:16 <Procian> michaelt_: I'm trying: runSafeT $ toListM $ mapM_ (\f -> readFile f >-> take 1) fs)
06:52:50 <Procian> Hang on. I see what I'm doing wrong.
06:53:38 <michaelt_> hm, fs will be clearer as a producer
06:53:47 <Procian> mapM_ (\f -> P.runSafeT $ P.toListM (P.readFile f P.>-> P.take 1)) fs
06:53:57 <Procian> I was just running out of file handles.
06:55:06 <Procian> michaelt_: Hmmm...let me think about that.
06:55:26 <shirt> anyone know what happened to "ResourceT" from Data.Conduit?
06:55:57 <Haskellfant> afaik it moved to http://hackage.haskell.org/package/resourcet
06:56:09 <Feuerbach> shirt: it's now in its own package (resourcet I think)
06:56:28 <shirt> thanks!
06:56:52 <Procian> michaelt_: Can I make fs a producer here?
06:57:50 <michaelt_> Procian: each fs, ... you'd write for (each fs) (\file -> ...)
06:58:21 <michaelt_> Procian: where are you getting readFile from, though, is the ordinary prelude readFile?
06:58:55 <Procian> michaelt_: It's in Pipes.Safe.Prelude.
06:59:05 <michaelt_> oh i forgot right
07:00:42 <michaelt_> so, e.g. x fs = runSafeT $ P.toListM $ for (each fs) (\f -> PS.readFile f >-> P.take 1)
07:01:02 <michaelt_> but I think runSafeT should be inside the `for` block, so to say?
07:02:47 <michaelt_> Procian: no that's not right. Hm.
07:04:24 <tobiasgw> michaelt_: oh wow, thanks. I'll try to find a library so I'll get structured/typed output, but that's a great place to start :)
07:07:43 <Procian> michaelt_: What I had before works using mapM. I'm not sure I can stay in Proxy this way. The only way to get out of Safe is to do runSafeT and runSafeP, which are no good unless I was just going for Effects.
07:08:07 <michaelt_> yes mapM) is fine y fs = P.toListM $ mapM_ (\f -> runSafeT (P.head (PS.readFile f))) fs
07:09:56 <GBrawl> can someone give me the easiest explanation ever about monads
07:10:39 <ion> A type class consisting of return :: a -> m a and (>>=) :: m a -> (a -> m b) -> m b with a set of laws.
07:10:59 <michaelt_> Procian: does something like that work? ^^ the idea is to get runSafeT (i.e. close all the handles etc.) so that it runs for each of the fs, rather than after all of them ...
07:11:34 <GBrawl> and what does the bind exactly stand for?
07:12:19 <michaelt_> GBrawl: it's going to be hard to beat the type-signature for lucidity
07:12:38 <ion> Pick a “m” and see what makes sense based on the type signature and the laws. Can you think of what [a] -> (a -> [b]) -> [b] might do?
07:13:11 <chpatrick> it's just a function with that type that follows the monad laws
07:13:12 <chpatrick> that's all
07:13:42 <pmade> GBrawl: study a few instances of the Monad typeclass like Maybe, then work your way up to continuations, then turn back to the abstraction that the Monad type class allows.
07:14:03 <chpatrick> but what it's good for intuitively is modifying a computation in a way that makes a new computation
07:14:17 <chpatrick> where "computation" is pretty vague
07:14:57 <GBrawl> okay ill do some research (i'll be back)
07:15:19 <pmade> GBrawl: There's a good video to watch too, let me dig it up.
07:15:27 <GBrawl> okay :D
07:16:29 <pmade> GBrawl: http://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads
07:18:30 <GBrawl> thanks for the video pmade
07:18:32 <GBrawl> you are the best
07:18:52 <pmade> GBrawl: that video helped my see how bind is a form of composition.
07:25:48 * hackagebot mailchimp-subscribe 1.0 - MailChimp subscription request handler  http://hackage.haskell.org/package/mailchimp-subscribe-1.0 (mietek)
07:47:39 <ski> GBrawl : `ma >>= amb' is an action that, when run, will first run `ma'. any result value `a' of that effectful computation will be passed to `amb' : `amb a'. this forms a new action that may depend on the value `a' computed by the former `ma' one. so next `amb a' is run, and any result `b' of that is the result of the whole effectful computation
07:48:53 <ski> GBrawl : btw, you shouldn't take "first","next" as referring to evaluation ordering, but as a conceptual ordering
07:49:39 <GBrawl> so you bind two computations together?
07:50:21 <GBrawl> ski: so you bind two computations together?
07:50:28 <ski> if we didn't also want the second part of the computation to possibly depend on the intermediate result computed by the first one, then we could just use `ma >> mb', which is just a simple (conceptual) ordering
07:51:37 <ski> GBrawl : so, `(>>)' connects two "actions / effectful computations" together, while `(>>=)' connects ("binds") one action together with a function that when given a result from the former will decide which following action it wants to be
07:52:13 <ski> GBrawl : depending on the monad `m', an `m'-action `ma' (of type `m a', for some particular type `a'), aka an effectful computation, will in general describe *more* than just a result value -- this (vague) "more" part is what i call the "effect" part of the computation
07:52:28 <ski> what the "effect" actually can be depends on the particular monad
07:52:59 <indigo945> (>>) a b = a >>= (\_ -> b)
07:53:05 <GBrawl> that effect is the side-effect of monad?
07:53:22 <indigo945> if you have a monad with "side-effects", yes
07:53:35 <saep> > Just 7 >>= \seven -> return (seven+4) >>= \eleven -> return (eleven * 9)
07:53:36 <lambdabot>  Just 99
07:53:41 <ski> for the monad `Maybe', a `Maybe'-action (of type `Maybe a', for some particular type in place of `a') will either compute a (single) result of type `a', or it will "fail" to compute a result (you can think of this roughly as an exception "No result")
07:53:42 <saep> > Right 7 >>= \seven -> return (seven+4) >>= \eleven -> return (eleven * 9)
07:53:43 <lambdabot>  Right 99
07:53:56 <ski> GBrawl : no, not "side-effect", but "effect"
07:54:02 <saep> > Identity 7 >>= \seven -> return (seven+4) >>= \eleven -> return (eleven * 9)
07:54:03 <lambdabot>  Identity {runIdentity = 99}
07:54:04 <GBrawl> do you always have to define both >> and >>= if you want to make a monad instance?
07:54:08 <GBrawl> oh ok
07:54:22 <opqdonut> >> is defined in terms of >>=, so you don't need to
07:54:26 <indigo945> i just defined >> in terms of >>= above :)
07:54:29 <indigo945> you only need >>= and return
07:54:40 <ski> GBrawl : it becomes a *side-*-effect, if we don't *account* for the effect in the *interface* of the operation (as happens in C, Java, Smalltalk, Ada, ...)
07:54:43 <indigo945> return takes a value and puts it "into" the monad, so for example for a list it could be
07:54:45 <indigo945> return a = [a]
07:55:01 <saep> > [7] >>= \seven -> return (seven+4) >>= \eleven -> return (eleven * 9)
07:55:03 <lambdabot>  [99]
07:55:41 <Freundlich> GBrawl: See "minimal complete definition" here http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#t:Monad
07:55:58 <ski> GBrawl : in Haskell, an expression that computes an integer has type `Integer', while an expression that computes an `Integer', while possibly doing I/O-effects has type `IO Integer' -- accounting for the I/O effects by the `IO' type is what allows it to *express* an "effect", rather than *having* a "side-effect"
07:56:04 <GBrawl> yeah I get that part, you define one and the relation to the other one
07:56:16 <lf94> I'm watching this (https://www.youtube.com/watch?v=ZhuHCtR3xq8) and just have a single question: So Monoids exist so that we can compose more complex functions? alsobrianbeckmaniscool
07:56:59 <GBrawl> ok thx ski, im starting to get a grasp of it
07:57:05 <ski> GBrawl : anyway, the "effect" part of the `Maybe' monad is : there might not be a result value (and you can detect that, if you want, otherwise the failure will automatically propagate in a short-circuiting way)
07:57:37 <ski> GBrawl : however, the "failure" here is (effectively) unnames. you can't distinguish between different kinds of failures
07:58:14 <ski> GBrawl : so, instead of `Maybe', you might want to use `Either MyError', where `MyError' is a type that expresses the kinds of failure that you're considering
07:59:19 <zmbmartin> Anyone that could help with my SO question http://stackoverflow.com/questions/27252953/mvar-to-tmvar-mkweakmvar-questions?
08:00:12 <ski> @let data MyError = ErrorA | ErrorB String deriving Show
08:00:13 <lambdabot>  Defined.
08:00:22 <ski> > return 3 >>= \m -> return 4 >>= \n -> return (m+n)   :: Either MyError Integer
08:00:23 <lambdabot>  Right 7
08:00:35 <ski> > return 3 >>= \m -> Left ErrorA >>= \n -> return (m+n)   :: Either MyError Integer
08:00:36 <lambdabot>  Left ErrorA
08:00:49 <ski> > Left (ErrorB "oops !") >>= \m -> Left ErrorA >>= \n -> return (m+n)   :: Either MyError Integer
08:00:50 <mmachenry> I have a forkFinally that is catching an exception but the children threads are still running. I've written a simple example. Is there an easy way to neatly clean up child threads from forkFinally? http://lpaste.net/115507
08:00:50 <lambdabot>  Left (ErrorB "oops !")
08:01:00 <ski> GBrawl : makes any sense ?
08:01:53 <GBrawl> yes, i made such a thing but as a Data, not a monad
08:02:06 <GBrawl> I dont really see the advantage of monads
08:02:16 <exio4> monads are a neat way for reducing boilerplate
08:02:31 <exio4> you could do this without monads, but it would take too much repeated code
08:03:07 <tdammers> GBrawl: there is no fundamental advantage to monads, other than that they are a convenient abstraction
08:03:12 <tdammers> a pattern, if you want
08:03:13 <exio4> monads also allow to hide "details" and provide neat abstractions (things like Parsec are an example)
08:04:06 <chpatrick> also there's a lot of stuff for working with any Monad
08:04:12 <ski> GBrawl : "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> is one of the oldest (perhaps the oldest ?) monad tutorial, but i think it's still nice. perhaps you could try it ?
08:05:42 <ski> GBrawl : in the case of `Maybe' (and `Either e'), the respective monadic bind operations allow you to remove the boilerplate that you'd otherwise have, which you propagate failure ("abort and return the error code, as soon as one sub-computation errors out", to speak in C analogies)
08:06:36 <GBrawl> boilerplate?
08:07:16 <ski> GBrawl : look at the definition just under `r :: Maybe Record', at the tutorial link above ?
08:07:45 <ski> there's a nested mess of `case's and `Nothing's
08:07:47 <michaelt_> Procian: sorry, I vanished. Here is a dumb example of getting the SafeT business inside http://lpaste.net/115508 does it seem wrong?
08:08:47 <michaelt_> Procian: it seems to show me the first line of every haskell program on my computer without file-handle problems
08:12:27 <ski> GBrawl : do you see what i'm referring to, or should i elaborate ?
08:12:49 <GBrawl> I'm looking at it right no
08:15:49 * hackagebot hakyll-contrib-hyphenation 0.1.0.2 - Automatic hyphenation for Hakyll  http://hackage.haskell.org/package/hakyll-contrib-hyphenation-0.1.0.2 (firegurafiku)
08:16:37 <nh2_work> is it possible to suppress GHC's TH "loading package" output?
08:18:08 <michaelt_> Procian: I forgot to say, it uses the `dirstream` package, which uses `system-filepath`.  The outer runSafeT corresponds to the directory traversal function from `dirstream`.   If I delete the inner `runSafeP` I run out of handles, so its location closes them as they come and go.
08:18:36 <michaelt_> Procian: I mean in http://lpaste.net/115508
08:18:52 <ski> GBrawl : do you want more time to think on it ? or would you prefer me attempting to explain more here ?
08:19:21 <GBrawl> yeah I think a little help would be welcome :)
08:20:35 <bitonic> nh2_work: from the source, the only way seems to be setting the verbosity to 0
08:20:40 <bitonic> e.g. making it quiet
08:20:57 <nh2_work> bitonic: but that silences everything, hmm
08:21:02 <bitonic> right
08:21:19 <nh2_work> oh well
08:21:47 <ski> GBrawl : anything in particular you're wondering about at the moment. or should i just try continuing what i had intended to say ?
08:21:54 <bitonic> nh2_work: | grep -v "^Loading package"
08:23:13 <gp5st1> I think I'm not thinking functionally enough.  I have a graph where each edge has a weight and a cumulative weight (initially set to infinity) and a set of starting nodes. From each starting node, I want to iterate over all the edges connected to that node, and then all of the edges connected to those nodes, summing the weights of the first and second edges in each path and setting that sum to the cumulative weight iff the sum i
08:23:16 <nh2_work> bitonic: that'd be possible but doesn't fit so well in our makefile
08:23:24 <nh2_work> I'll keep suffering for now
08:23:51 <nh2_work> gp5st1: for me your message is cut off after "weight iff the sum i"
08:24:05 <GBrawl> ski I'll try to learn it on my own for a bit, if I have any questions Ill ask them here, thanks for the enormous help :)
08:24:45 <gp5st1> nh2_work: thanks for the heads up
08:25:16 <gp5st1> ... weight iff the sum is < current the cumulative weight.  If the sum was less, continue on to all the nodes connected to the current one, otherwise there's no need to keep going. I'm not sure how to translate this into a more functional paradigm :-\
08:25:17 <ski> GBrawl : np. (i'll have to leave pretty soon, but perhaps if you're here later in the week we could continue. or someone else could)
08:25:29 <gp5st1> http://dpaste.com/2CDRQZG.txt for the whole message in one go
08:28:55 <GBrawl> thanks for your help ski, really appreciated
08:33:42 <gp5st1> it's more the whole "updating the cumulative weight" part that I can't figure out. Traversing the graph shouldn't be difficult to figure out.  There also seem to be some nice libs for that
08:43:26 <ski> gp5st1 : you want the cumulative weight of each edge set to the minimum summed weight of all paths ending in that edge, starting in a starting node ?
08:44:33 <gp5st1> ski: yes, essentially
08:45:05 <gp5st1> eventually there will be more starting nodes, but getting one to work would be nice :)
08:45:54 <ski> in what basic ways can you manipulate your graph's node and edges ? in case you're building the representation yourself, what is the representation ? in case you're using a library, which ?
08:47:19 <ski> in either case, i think one viable alternative might be to define the new (final) graph as a "mapped" version of the original one, but one where you *use* the final graph to compute the new annotation/weight on the edges to *define* the new(ly annotated) edges of the graph
08:47:48 <gp5st1> ski: I was thinking of using fgl, but if I need to write my own that's not an issue
08:48:09 <ski> gp5st1 : do you see what i mean ?
08:49:56 <gp5st1> ski: I think, but I'm still not clear what happens once I define the new edge with the new weight. (to use the most proper language: how do I stick the new thing into the graph if the edges and nodes are immutable)
08:50:06 <Taneb> QuickSpec is pretty cool
08:50:38 <gp5st1> or, I think I saw a method t remove an edge and then add a new one, but that doesn't seem like the correct approach
08:50:51 * hackagebot jsontsv 0.1.0.0 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.0.0 (DanielChoi)
08:51:05 <_1_MileStranger> hi
08:51:13 <ski> gp5st1 : use recursion to make the operation, that replaces an old edge with a new edge, *depend* on the *new* (to-be-constructed) graph !
08:51:51 <ski> that's called
08:51:55 <ski> @wiki Tying the knot
08:51:55 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_knot
08:52:10 <gp5st1> ski: I think I'm going to have to let that sink in
08:52:22 <ski> > let loeb :: [[a] -> a] -> [a]; loeb fs = as where as = map ($ as) fs in loeb [product . tail,length,(2 *) . (!! 1)]
08:52:24 <lambdabot>  [18,3,6]
08:52:26 <gp5st1> but prima facie I think I see what you mean
08:52:30 <ski> is a very simple example of that
08:52:44 <ski> `loeb' implements a very simple kind of "spreadsheet" behaviour
08:53:18 <ski> we have a list of functions, that when each given the final list will compute the individual value to be placed in place of the function
08:54:19 <ski> the middle function `length' get's passed the list `final = [?,?,?]', where the `?'s are as of yet unknown (but the length is known, it's the same as the length of the input list of functions)
08:54:46 <ski> and `length' computes `3' on that list (not caring about the elements), and so we now know `final = [?,3,?]'
08:55:11 <ski> the last function `(2 *) . (!! 1)' is the "extract the element at index `1', and then double the result" function
08:55:27 <ski> when given `final = [?,3,?]', it extracts `3', and doubles it, giving `6'
08:55:41 <ski> thus we now know that `final = [?,3,6]'
08:56:00 <johnw> another way of thinking of loeb is that, by way of lazy evaluation, it turns a list of evaluators into a list of pending evaluations
08:56:40 <ski> finally, the first function in the list `product . tail' takes the product of all but the first element of `final = [?,3,6]', so it computes `3 * 6' (carefully avoiding the `?', because of the `tail'), yielding `18'
08:56:42 <gp5st1> :-o
08:56:55 <ski> so, now we know `final = [18,3,16]'
08:57:18 <ski> in the definition of `loeb' above, `as' corresponds to `final' in the explanation just above
08:57:45 <ski> gp5st1 : makes any sense at all ? is it dizzying to be able to refer the the thing you want to compute ?
08:58:46 <Darwin226> Hey guys. I'm going through this article in MR 8 https://www.haskell.org/wikiupload/d/dd/TMR-Issue8.pdf called Type-level instant insanity. I'm at the part where we're implementing the "not equal" relation for some type level colors. The author does it by defining instances for all of the possible combinations of colors that are not equal.
08:59:12 <Darwin226> I was wondering if it would make more sense to define the equal colors and then define "not equal" as a negation of that
08:59:38 <gp5st1> ski: it feels like I'm teetering between epiphany and the void
08:59:45 <ski> gp5st1 : so, i'm suggesting you write a computation like `f ... = ... where finalGraph = mapGraph (\oldEdge -> ..oldEdge..finalGraph..) initialGraph'
09:00:54 <ski> gp5st1 : where `mapGraph' is just a simple function that applies a given callback function on every edge (or perhaps more properly, just to the annotation on it, iow it's weight), and constructs a new graph with the same structure, but with the annotations on the edges changed as desired
09:01:13 <samba1> I'm trying to get quickcheck to work testing multiple automatically. I've followed the directions on hackage but it's not working - http://lpaste.net/115513 - when I load this I get a message "prop_foo found in source file but was not in scope", same for prop_bar
09:01:24 <samba1> I've tried explicitly exporting them as well, same
09:01:38 <samba1> when I run runTests it just returns True
09:02:02 <ski> gp5st1 : and the crucial part is allowing `..oldEdge..finalGraph..' (which computes the (annotation on the) new edge) to depend not only on `oldEdge' (and perhaps also `initialGraph', if you want to), but also to depend on *`finalGraph'* !
09:03:11 <ski> gp5st1 : anyway, this is *one* approach, and a quite elegant one, i'd say, if you can make it work, since you define the new graph "all in one go", without having to compute several intermediate graphs inbetween
09:04:08 <gp5st1> ski: yeah
09:04:17 <ski> gp5st1 : however, if you prefer, you *can* also solve this with an approach more resembling the imperative approach you described, where you for each starting node compute a new intermediate graph, updating (some of) the edges reachable from that, until you're done all the starting nodes
09:05:15 <gp5st1> ski: then I'm left with the issue of updating a shared data structure
09:05:44 <ski> then you'd probably need some function that gets as argument the current version of the graph, and computes the next version as result, and this function is called recursively, threading the various versions/states of the graph through the computation, from the initial to the final
09:05:59 <gp5st1> also, I'm working on this partially because the tools I havn't weren't built for graphs the size of mine and also to learn haskell. and demystifying magic seems like a great way to learn :)
09:06:17 <ski>   percolate :: Node -> Graph -> Graph
09:06:20 <ski> or something like that
09:06:42 <saep> samba1: try putting the $quickcheckall thing at the bottom of the wile
09:06:55 <ski> and then for each starting node, you'd call `percolate', threading the result from the last call to `percolate' as input to the next one
09:07:12 <saep> samba1: Also, what's the point of that `return []` there?
09:08:03 <samba1> saep: oh dear god, thank you, that was it, it has to be below the prop_s. Ugh.
09:08:09 <samba1> saep: http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck-All.html#v%3aquickCheckAll
09:08:22 <ski> gp5st1 : it is also possible to go the mutable road, if you really want to. you can use `STRef'/`STArray' or `IORef'/`IOArray' -- but then you need to use either the `ST s' monad (preferable, in comparision) or the `IO' monad
09:08:52 <samba1> saep: If I remove it, I get the same problem as before, even with runTests below the prop_s
09:09:18 <ski> gp5st1 : it's not immediately obvious to me which approach would be better, complexity-wise, asymptotically speaking
09:09:18 <saep> samba1: Ah ok. I find hspec quite convenient to write tests. It is self-documenting and doesn't need Template-Haskell.
09:10:54 <ski> gp5st1 : perhaps one can do something clever with dynamic programming (which often/sometimes can be done in an elegant way in Haskell, using the same tying-the-knot technique as above, only usually recursively defining an array instead of some linked structure)
09:11:35 <samba1> saep: hspec is okay but a bit much for little things I'm working on, a lot of ceremony, but it avoids stuff like this, so maybe
09:11:39 <gp5st1> ski: yeah, I'd really like to do this in a more haskellish manner (not using mutable state)
09:11:50 <ski> gp5st1 : anyway, those are the main approaches that springs to my mind, not having tried to spell out the details of it, and its ramifications for performance
09:12:25 <ski> gp5st1 : using `ST' or `IO' is most similar to using mutable state (because it is using mutable state, both conceptually and operationally)
09:14:05 <ski> gp5st1 : threading the graph in and out of a (e.g.) `percolate' function is *conceptually* mutable state (made explicit), but will probably not operationally be implemented with update-in-place -- it can be worthwhile to do this, to familiarize oneself with the technique. and it doesn't feel, at least to an FP-newbie, that imperative
09:15:25 <ski> gp5st1 : the "recursively defining the result in terms of itself" solution i would say would feel the most elegant of the discussed alternatives. but quite possibly there's also other elegant alternatives (possibly depending on the graph primitives you have available)
09:15:52 * hackagebot cuda 0.6.5.1 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.6.5.1 (TrevorMcDonell)
09:16:26 <gp5st1> I'd agree that it does sound the most elegant and least complex to deal with (once I've dealt with it:-p)
09:17:05 <ski> for a large graph, the representation may make a difference. however since you're new, i'd suggest not worrying about that initially, instead revisiting the problem and comparing the performance of different alternatives when you've tried them
09:20:02 <ski> (having a `Map' (or even an association list, for small graphs) that maps edges to `(Node,Node,Annotation)' tuples would be one way. having a map that maps nodes to `(Node,Annotation)' would be another way)
09:20:10 <ski> gp5st1 : i hope this helps
09:20:21 <gp5st1> ski: it does! thank you so very much!
09:20:38 <gp5st1> lots of starting points and new ideas to play with! :)
09:20:47 <ski> i need to leave now. any final question for now ?
09:21:26 <gp5st1> ski: no, I'm still digesting everything. Thank you again! Cheers!
09:21:43 <ski> for the knot-tying / boot-strapping or what you want to call it, i think understanding how my `loeb' example above works may help. you can also try the wiki page i mentioned
09:22:02 <ski> gp5st1 : yw. good luck. perhaps we'll speak later in the week
09:23:50 <ski> here's a final example
09:24:06 <stephen_> Hey guys, I'm building a package using cabal-install, and I'm getting a type error. Here's the context and error: http://lpaste.net/115516. I think it may be similar to the issue on this thread, but I'm not sure how to get around it with someone else's package http://haskell.1045720.n5.nabble.com/What-is-a-rigid-type-variable-td3115462.html The package is Copilot: https://hackage.haskell.org/package/copilot
09:24:11 <ski> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)  in  fibs
09:24:13 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:25:02 <gp5st1> ski: thanks :)
09:25:52 * hackagebot parallel 3.2.0.5 - Parallel programming library  http://hackage.haskell.org/package/parallel-3.2.0.5 (HerbertValerioRiedel)
09:30:36 <jkarni1> stephen_: what happens if you just remove the type signature of typespec'?
09:38:01 <lf94> How do I print expanded decimals in haskell
09:38:14 <lf94> So instead of getting 412e3, I get 412000
09:38:17 <lf94> or whatever
09:38:27 <wei2912> > 412e3
09:38:30 <lambdabot>  412000.0
09:38:38 <wei2912> > 412e200
09:38:42 <lambdabot>  4.12e202
09:38:44 <lf94> lol
09:38:48 <glguy> lf94: http://hackage.haskell.org/package/base-4.7.0.1/docs/Numeric.html
09:39:00 <glguy> check out the various showEFloat, showFFloat, showGFloat
09:39:07 <glguy> for different ways to show them
09:39:22 <dmwit> :t (showEFloat, showFFloat, showGFloat)
09:39:24 <lambdabot> (RealFloat a2, RealFloat a1, RealFloat a) => (Maybe Int -> a -> ShowS, Maybe Int -> a1 -> ShowS, Maybe Int -> a2 -> ShowS)
09:39:53 <dmwit> > map (\f -> f Nothing 412e200 "") [showEFloat, showFFloat, showGFloat]
09:39:56 <lambdabot>  ["4.12e202","412000000000000000000000000000000000000000000000000000000000000...
09:40:07 <dmwit> right =P
09:40:17 <wei2912> :P
09:40:21 <dmwit> > map (\f -> f Nothing 412e10 "") [showEFloat, showFFloat, showGFloat]
09:40:24 <lambdabot>  ["4.12e12","4120000000000.0","4.12e12"]
09:40:31 <dmwit> > map (\f -> f Nothing 412e1 "") [showEFloat, showFFloat, showGFloat]
09:40:33 <lambdabot>  ["4.12e3","4120.0","4120.0"]
09:40:39 <lf94> What is ShowS?
09:40:50 <glguy> Type:    :i ShowS
09:40:52 <glguy> in your GHCi
09:40:53 <dmwit> type ShowS = String -> String
09:40:53 <lf94> Ah
09:41:03 <lf94> Yeah just saw that X)
09:41:11 <dmwit> It's a variant of String with efficient prepend and append.
09:41:18 <dmwit> ...but inefficient freezing. =)
09:45:13 <gilligan_> gah.. ghc-modi wtf is wrong with you
09:45:28 <lf94> haskell is so kickass
09:45:39 <lf94> i liked the idea of lisp but didnt like lisp
09:45:48 <lf94> i just wish haskell was more portable
09:47:26 <simpson> lf94: In what sense?
09:47:59 <lf94> simpson: lisp is a functional language too?
09:48:08 <lf94> simpson: or portability?
09:48:13 <simpson> lf94: In terms of portability.
09:48:24 <lf94> simpson: ghc in particular
09:48:31 <lf94> isn't it huge?
09:48:32 <exio4> scheme is more "functional" than the average "lisp" :P
09:48:38 <exio4> lf94, Haskell is huge
09:48:58 <exio4> lf94, take a look at jhc, though?
09:49:01 <simpson> lf94: Sure, but what does that have to do with portability?
09:49:02 <lf94> would it be a lot of work to port ghc to a new platform?
09:49:15 <exio4> most if it is written in Haskell
09:49:29 <simpson> Yes. GHC generates native code, so each target platform requires some specialized support code.
09:49:35 <gp5st1> lf94: it works in linux, bsd, and windows and iirc it uses llvm now
09:49:41 <exio4> if you have llvm for that platform I would guess it would be kinda easier
09:50:38 <dmwit> lf94: Which platform do you miss GHC on?
09:50:47 <lf94> starts with a p
09:50:48 <lf94> B)
09:50:58 <dmwit> PowerPC?
09:51:00 <lf94> (please dont kill me)
09:51:04 <lf94> plan 9
09:51:16 <simpson> Oh, an OS, not a CPU architecture.
09:51:25 <simpson> That shouldn't be too terribly hard, then.
09:51:36 <stephen_> jkarni1: I just tried pulling the source from github instead of using cabal-install, and it seems to be compiling fine now. Weird . . .
09:52:11 <dmwit> There are people who use plan 9? =P
09:52:41 <zmbmartin> is there a short syntax for `a <- res; case a of` I want to be able to case res of, but res is IO?
09:52:56 <dmwit> res >>= \case
09:53:18 <dmwit> It's a bit bulky, but the result of a *long* discussion.
09:54:28 <zmbmartin> dmwit: OK that will work. Thanks!
09:56:48 <ReinH> zmbmartin: (requires LambdaCase extension ofc)
09:57:38 <zmbmartin> ReinH: OK thanks!
10:14:15 <stephen_> How can I get around this order while installing a package via cabal-install?    Data.DList: Can't be safely imported! The module itself isn't safe.
10:14:24 <stephen_> ** error, that is
10:15:13 <heatsink> You could edit the package to remove safe haskell pragmas
10:15:39 <heatsink> Use cabal unpack to download a copy of the package
10:29:25 <steffen> How can I use the ffi to talk to a LISP? Does someone have experience with that? Or some links? Thanks
10:30:04 <heatsink> to interface between two high-level languages, you usually use glue code in C
10:30:08 <dcoutts_> steffen: standard approach is to go via C
10:30:10 <heatsink> talk to C from Haskell and Lisp
10:30:46 <steffen> So I call C code which iteself calls LISP?
10:32:29 <heatsink> Yes, there is probably documentation on how to call lisp from C
10:37:40 <hiptobecubic> steffen, although keep in mind that you'll probably just lie to both languages and *tell* them they are talking to C, when they are really talking to each other
10:38:09 <hiptobecubic> via their respective FFI's and support for the C calling convention
10:40:55 * hackagebot ghc-srcspan-plugin 0.1.0.0 - Generic GHC Plugin for annotating Haskell code with source  location data.  http://hackage.haskell.org/package/ghc-srcspan-plugin-0.1.0.0 (EricSeidel)
10:41:25 <mkscrg> GHC linking question: the current Homebrew (OS X) formula for GHC was built with CONF_GCC_LINKER_OPTS_STAGE2=-L/usr/local/lib
10:41:32 <mkscrg> that seems to wind up on all linker invocations by GHC: “clang -B/usr/local/lib -m64 -fno-stack-protector -DTABLES_NEXT_TO_CODE -L/usr/local/lib ..."
10:41:39 <mkscrg> and that mucks with any user-specified -optl-L arguments, since argument order matters for the library search path
10:41:49 <mkscrg> so, is there a way to suppress the “-L/usr/local/lib” without rebuilding GHC?
10:42:07 <geekosaur> it's required *somewhere* or you'll run into issues with e.g. iconv
10:43:12 <mkscrg> everything worked fine (at least on my machine :) before that env var was added to the ghc build (CONF_GCC_LINKER_OPTS_STAGE2=-L/usr/local/lib)
10:43:20 <mkscrg> recently reinstalled, now busted
10:45:31 <mkscrg> is it possible to set "stage2 linker opts" after ghc is built?
10:53:56 <haskellquestion> is this statement true? "every function in haskell takes 0 or 1 parameters and returns 1 value" (based on currying) i'm presenting haskell to my programming languages class tomorrow and want to make sure that's accurate
10:54:10 <jonazz> can somebody help me with gtk2 on windows?
10:55:21 <jonazz> because a package cairo won't link.. it just stops
10:55:26 <jonazz> no errors nothing
10:55:52 <jonazz> just my fans of my pc start spinning :p
10:55:55 * hackagebot tasty-hspec 1.0 - Hspec support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hspec-1.0 (mitchellwrosen)
10:56:20 <jonazz> however using ghc --make it works fine..
10:56:38 <jonazz> with ghci it loads some packages and stops at cairo ...
10:57:48 <int-e> haskellquestion: Ah, that's a question that has several answers. You can think of (+) :: Int -> Int -> Int as a function taking one number as its argument and returns a function that takes another argument and returns the sum of those two arguments. But one can also think of (+) as a function that takes two arguments and returns a number, and that furthermore allows partial application (so (+) 1 is a...
10:57:54 <int-e> ...function that still needs one more argument before it becomes a full application of (+))
10:58:56 <haskellquestion> int-e: yeah what i'm saying is that it's a function that takes an int and returns a function that takes an int etc. i'm more going for a mind-expanding technical explanation over a familiar one
10:59:08 <haskellquestion> i just want to make sure i'm technically right in saying that
10:59:30 <chpatrick> every function takes 1 value
10:59:38 <chpatrick> if something doesn't take any it's not a function
10:59:41 <kadoban> haskellquestion: The part about some functions taking 0 values isn't true.
10:59:45 <haskellquestion> oh ok
10:59:45 <kadoban> Yeah, that.
10:59:56 <haskellquestion> what if you just had a function like this? someFunction = 5
11:00:01 <haskellquestion> or like a random function or something
11:00:04 <chpatrick> then it's not a function
11:00:04 <kadoban> That's not a function.
11:00:05 <haskellquestion> that isn't a function?
11:00:06 <chpatrick> it's just an Int
11:00:13 <chpatrick> or whatever
11:00:18 <int-e> so a non-function value
11:00:19 <haskellquestion> what would random be called then?
11:00:29 <kadoban> :t random
11:00:30 <lambdabot> (Random a, RandomGen g) => g -> (a, g)
11:00:43 <haskellquestion> oh so even random takes a value ok
11:00:44 <chpatrick> random is a function that takes a generator state
11:00:51 <haskellquestion> so all things in haskell take one value and returns a value ok
11:00:52 <haskellquestion> thanks
11:00:56 * hackagebot yaml-light-lens 0.3.1.5 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.1.5 (AnthonyCowley)
11:01:01 <chpatrick> no that's not true
11:01:03 <chpatrick> only functions
11:01:05 <kadoban> All functions do at least.
11:01:06 <haskellquestion> er yeah
11:01:08 <exio4> :t randomRIO
11:01:09 <haskellquestion> functions yeah
11:01:09 <int-e> :t ()
11:01:09 <lambdabot> Random a => (a, a) -> IO a
11:01:10 <lambdabot> ()
11:01:11 <jle`> haskellquestion: functions have a well-defined meaning in haskell
11:01:21 <exio4> :t getLine
11:01:22 <lambdabot> IO String
11:01:22 <jle`> haskellquestion: functions are values of types involving the type constructor (->)
11:01:27 <chpatrick> IO is a function :)
11:01:30 <exio4> is "IO String" a function? :P
11:01:33 <chpatrick> yes
11:01:35 <c_wraith> chpatrick: no, IO is not a function
11:01:49 <jle`> IO String is not a function....
11:01:50 <haskellquestion> getLine is not a function?
11:02:01 <jle`> getLine is just a value
11:02:04 <jle`> a data type
11:02:05 <haskellquestion> hmmm ok
11:02:13 <Cale> Right, getLine isn't a function because its type is not of the form A -> B
11:02:14 <chpatrick> newtype IO a
11:02:15 <chpatrick>   = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld
11:02:15 <chpatrick>                   -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
11:02:18 <Cale> where A and B are types
11:02:18 <chpatrick> it is a function :)
11:02:19 <int-e> exio4: conceptually, no. as an implementation detail, yes, once you look inside the newtype wrapper (which does not change the representation).
11:02:35 <nh2_work> it depends; I think of getLine as a function without arguments, but in the strict sense, things that contain "->" are functions
11:02:36 <Cale> chpatrick: It's arguable even that the "->" in that type isn't really appropriate
11:02:45 <exio4> int-e, "implementation details", you said it
11:03:01 <Cale> chpatrick: Because the "functions" in that implementation detail are not really functions -- they're effectful.
11:03:05 <jle`> functions in haskell have a well-defined meaning: things of types involving (->)
11:03:16 <jle`> so foo :: String is not a function
11:03:21 <jle`> foo :: Bool -> Int is a function
11:03:22 <chpatrick> Cale: I know but I like it because it means nothing gets information out of thin air in haskell
11:03:29 <int-e> similarly, 5 :: Num a => a  is, conceptually, not a function, but its implementation in ghc is a function that takes a Num dictionary for a and returns a value of type a.
11:03:30 <haskellquestion> does anyone want to look over my powerpoint for my presentation to make sure i'm not misrepresenting haskell in some way?
11:03:42 <simpson> chpatrick: It is completely legal for a Haskell implementation to not have *any* constructors for IO.
11:03:43 <c_wraith> chpatrick: so does treating IO values as values.  They don't "get information" from anywhere.
11:03:45 <Cale> chpatrick: Well, GHC.Prim.State# GHC.Prim.RealWorld is a 0-bit wide token type
11:03:55 <chpatrick> I know it's just for sequencing
11:04:02 <jle`> haskell the language doesn't involve "getLine" as a function
11:04:12 <Cale> chpatrick: It's merely a hack to get GHC's dependency analyser to keep the order of the computation straight
11:04:18 <chpatrick> I'm aware
11:04:20 <jle`> GHC might implement it that way...but...it has nothing to do with haskell
11:04:25 <jle`> it has nothing to do with getLine
11:04:34 <jle`> it has nothing to do with IO
11:04:39 <Cale> Yeah, GHC's implementation of IO doesn't really teach anyone much about what IO is about :P
11:04:46 <c_wraith> chpatrick: have you looked at ermine's implementation of IO?  It has nothing resembling a function inside it
11:04:52 <johnw> jle`:  or even the price of tea in china
11:04:58 <chpatrick> sheesh I know already
11:05:02 <jle`> maybe the price of tea in china a little
11:05:08 <jle`> it's such a finnicky market
11:05:12 <Cale> A much better mental model would be something like an algebraic data type (or GADT) with constructors for various primitives and means of combining IO actions.
11:05:19 <chpatrick> I'm just saying that almost everything with a context is a function
11:05:26 <jle`> but...it's not a function
11:05:30 <c_wraith> chpatrick: don't confuse GHC's hack with the model.  The model makes way more sense without the implementation details.
11:05:31 <chpatrick> even if in the case of IO that's not how it gets its information
11:05:41 <Cale> and in that case, IO actions would not internally look anything like functions
11:05:54 <jle`> IO's with GADT's/data types are contexts, but not functions
11:06:00 <Cale> I believe Hugs might have used such a representation at some point
11:06:16 <jle`> IO itself does not involve anything having to do with functions
11:06:20 <int-e> I would actually be happy with calling () a zero-argument function. But this is taking the "all functions are curried" view, so it goes together with having n-ary functions for all natural numbers n, which can be partially applied.
11:06:21 <chpatrick> the old IO model still had responses coming in as a function parameter
11:06:22 <jle`> and not even all implementations use functions
11:06:26 <Cale> The idea being that the runtime would then contain an interpreter for such structures which would traverse them and carry out the effects described.
11:06:56 <Cale> int-e: Well, I'm okay with "0-ary function" not being a special case of "function" :)
11:06:56 <c_wraith> In fact, you can write up a free monad implementation of IO (like what ermine does) in about 10 lines.
11:07:15 <Cale> c_wraith: Indeed :)
11:07:19 <c_wraith> Assuming you make one of the constructors "arbitrary FFI"
11:07:34 <exio4> c_wraith, do you have any link to that implementation of IO? (ermine's)
11:07:47 <jle`> it's just weird because function actually has a meaning in haskell
11:07:49 <c_wraith> exio4: just what edwardk put in his blog posts.  let me find them
11:07:57 <chpatrick> I know it's stretching the analogy a bit but then don't you have something like Action (resultType -> a) in the free monad functor?
11:08:05 <chpatrick> there's still a function that receives the input
11:08:16 <Cale> chpatrick: Probably not.
11:08:28 <Cale> It depends on how you do it, but you can avoid function types altogether
11:08:37 <jle`> so calling a foo :: String a 0-ary function might be true for some definition of function, but definitely not the definition of function in haskell.  so it's a bit of a conflation of terms
11:08:57 <chpatrick> I think ekmett had something like IO (IOAction r) (r -> a)
11:09:06 <Cale> The trouble is that if you consider 0-ary functions to be functions, then all values are functions, and the term is synonymous with "value", which sucks.
11:09:09 <chpatrick> so you have an IOAction with a fixed r and a function that you can fmap
11:09:20 <c_wraith> exio4: http://comonad.com/reader/2011/free-monads-for-less-3/ is the part that talks about using it as a basis for IO
11:09:20 <jle`> that too
11:09:30 <chpatrick> and then yes, IOAction isn't a function
11:09:37 <Cale> Yeah, you can do a CPS encoding where IO actions will involve functions in part.
11:09:42 <exio4> thanks, will take a look at them!
11:10:05 <c_wraith> exio4: it's the third part in a series, though.  You might want to read the first two, also. :P
11:10:37 <jle`> i find it best to read serieses backwards
11:10:40 <c_wraith> chpatrick: the important part is that you can use the same mental model over differing implementations - so why bog down your mental model with GHC's hack?
11:10:46 <jle`> more mystery and suspense that way
11:10:49 <exio4> c_wraith, yeah, heh :P
11:11:44 <chpatrick> c_wraith: ok, it's not really relevant to IO
11:12:23 <int-e> Cale: I believe I have a solution for the dilemma ... let's just use Church encodings for everything.
11:12:24 <chpatrick> c_wraith: I was just trying to say that it's nice how usually data is passed around explicitly in the end
11:12:37 <chpatrick> c_wraith: even if in the case of IO the RealWorld is a metaphor
11:13:33 <int-e> () = id  can't be wrong.
11:15:56 * hackagebot roshask 0.2 - Haskell support for the ROS robotics framework.  http://hackage.haskell.org/package/roshask-0.2 (AnthonyCowley)
11:17:16 <haskellquestion> how do you provide an explicit type for a function in ghci? i keep getting the error "the type signature for 'functionName' lacks an accompanying binding"
11:17:24 <haskellquestion> can you not manually type it in?
11:18:03 <c_wraith> haskellquestion: let f :: foo -> bar ; f x = ...
11:18:37 <haskellquestion> oh you need to use a semicolon on the same line ok
11:18:50 <c_wraith> haskellquestion: you *can* use semicolons in haskell. You just usually do it for one-liners, like.. putting stuff in ghci. :)
11:19:12 <glguy> If you want to do multi-line things in GHCi you need to use this command   :{\n ..lines.. \n:}\n       multiline command
11:19:15 <rhllor> ever since learning Haskell, solving problems on project euler was a breeze
11:19:52 <glguy> Project Euler quickly stops being about programming and becomes about quirks of math
11:20:11 <tempey> has anyone played with hlearn? what was your experience?
11:20:21 <nh2_work> tempey: yes, I have
11:20:35 <glguy> If you're looking for some programming problems you might check out http://rosalind.info/problems/locations/
11:20:56 <tempey> nh2_work: cool. what did you think?
11:21:55 <rhllor> glguy thanks!
11:22:25 <nh2_work> tempey: the core point to take about is: it does many things on the type system level, which might be more than you want. E.g. in some cases the "features" of something are fixed by the type / use to be records, and when you want those to be flexible at run-time, you'll have a hard time. If you however have the features clearly set and want to make use of the typelevel information that it forces you to build up, then it's quite nicely done for that
11:23:42 <nh2_work> tempey: also, hlearn tends to focus on those ML things that are sensible to do with / gain big benefits of the type system. You might find that it lacks certain features that don't profit from type level stuff much.
11:24:26 <tempey> nh2_work: as in, it's difficult to write a workflow that's applicable to multiple types of features, i.e. string vs int etc?
11:24:45 <tempey> nh2_work: yeah, that was my main concern looking at the docs, it looks pretty incomplete
11:24:51 <Procian> michaelt_: Sorry for the delay. Yes, something like that works. I just had my runSafeTs in the wrong place.
11:25:03 <nh2_work> tempey: also, from the practical side, you need to be well versed in typeclassery to use it efficiently. Everything is a type class, and I find it harder to discover what I have to do in hlearn than in code that is less typeclassy
11:25:39 <rhllor> how do I get the index of an element in a list?
11:25:47 <nh2_work> tempey: yes, working across different types should be fine, but in non-typed ML you "just have a matrix of features that are usually float" and that's not so easy in hlearn
11:25:57 * hackagebot string-class 0.1.6.4 - String class library  http://hackage.haskell.org/package/string-class-0.1.6.4 (ByronJohnson)
11:25:59 * hackagebot monad-state 0.2.0.3 - Utility library for monads, particularly those involving state.  http://hackage.haskell.org/package/monad-state-0.2.0.3 (ByronJohnson)
11:26:01 * hackagebot meta-misc 0.1.0.3 - Utility library providing miscellaneous meta-programming utilities.  http://hackage.haskell.org/package/meta-misc-0.1.0.3 (ByronJohnson)
11:26:03 * hackagebot global 0.2.1.0 - Library enabling unique top-level declarations  http://hackage.haskell.org/package/global-0.2.1.0 (ByronJohnson)
11:26:05 * hackagebot cfipu 1.1.0.4 - cfipu processor for toy brainfuck-like language  http://hackage.haskell.org/package/cfipu-1.1.0.4 (ByronJohnson)
11:26:14 <rhllor> elem just tells if it's in it
11:26:21 <tempey> nh2_work: okay, sounds like a potentially significant learning curve (ha)
11:26:59 <nh2_work> tempey: I think the academic purpose of hlearn's author is to explore *especially* those things that benefit from the type system, so other bits don't have much focus; I don't think it tries to be a complete ML suite at the moment
11:27:29 <sevvie> good localtime. is there a way to get ghci on debian armhf without blood sacrifice?
11:28:00 <tempey> nh2_work: right. I thought I might try writing more methods for it if I liked the structure
11:28:10 <ByronJohnson> ^^ Just updated my old projects so that they build on a more modern Haskell ecosystem, which I wrote years ago as a relatively inexperienced functional programmer.  By my current standards, a few of them seem to be of low quality, sorry.
11:28:35 <ByronJohnson> But I suppose embarrassment signals progress. =)
11:29:10 <geekosaur> we all facepalm a bit at our early code
11:29:33 <dfeuer> ARGH
11:29:46 <sivteck> ARGH
11:30:04 <tempey> nh2_work: thanks for your input
11:30:09 <nh2_work> tempey: the cases where the type system might help are very useful though; e.g. if you know that your classifier has group structure, you can make cross validation much faster, like described in https://izbicki.me/blog/hlearn-cross-validates-400x-faster-than-weka
11:30:18 <geekosaur> (you want embarrassing? the first serious C program I wrote, back in 1985, I found out a couple years ago is "still in use". I am told it doesn't have much of the original code in it any more, at least... I can hope)
11:30:41 <johnw> geekosaur: what did it do?
11:30:49 <nh2_work> tempey: in any case, it is useful to read these blog post and build some basic things with hlearn so that you get an idea what hlearn forces you to do and what you gain from it
11:30:52 <ByronJohnson> Heh.
11:31:50 <geekosaur> it was a BBS program. in 1985 essentially the only Unix-based BBS was Picospan for $1000 so I wrote my own...
11:33:12 <tempey> nh2_work: right, i can see it being useful if i can discover some algebraic structure. i'll give that a read, thanks
11:33:34 <GBrawl> ski: I think I finally got a clue what monads are, but I still don't see the usefulnes of it
11:35:57 <nh2_work> GBrawl: for all of Haskell's constructs like Monads, Monoids, etc., a core practical benefit is abstraction. That means you don't have to care how exactly a thing that some dude on the internet wrote works; if you know it's a Monad/Applicative/Monoid/whatever, you immediately have an intuitive idea what it does and how you're supposed to use it
11:36:04 <c_wraith> GBrawl: it's an abstract interface lots of things support.  It lets you write polymorphic code that works with all of them
11:36:12 <mada> grepping #haskell's logs for 'nodejs' doesn't come up with any urls. Someone have a link to a blogpost/article/something that discusses nodejs from a haskellers perspective?
11:36:30 <mada> I tend to see a ultra negative opinion here and I'd like to read up on that.
11:37:05 <c_wraith> mada: it's mostly just that node's core feature is something GHC's IO manager does transparently without you having to contort all of your code.  Why torture yourself?
11:37:48 <nh2_work> GBrawl: for example, after you've worked with some Applicatives, and you want to do command line argument parsing with the optparse-applicative package, you can use it with almost 0 time spent learning about how it works, because you can just use it as an Applicative
11:38:13 <GBrawl> oh okay thanks alot
11:38:15 <pharpend> GBrawl: basically they're useful because you can have two elements of some sort of opaque data type, and you have a way to cleanly shove them together
11:38:17 <mada> c_wraith: I see. Maybe I need to read up on node itself first. Thank you
11:38:31 <Procian> GBrawl: Browse through Control.Monad, for instance. All those functions work for arbitrary monads (or MonadPlus instances). Once you've got a monad, you have all those functions for free, and for free, you have all the patterns of code you know which use those functions, and as you can write more functions that type-check for arbitrary monads, you get more free stuff.
11:39:01 <GBrawl> okay I get the abstract meaning of it
11:39:14 <GBrawl> just wanted to get a clear example but that's quite hard to give apparently :D
11:39:49 <nh2_work> GBrawl: you might also find this post interesting: http://neilmitchell.blogspot.de/2014/07/applicative-vs-monadic-build-systems.html It discusses the difference between Monadic and Applicative build systems, which suddenly makes it much easier to understand and use any build system
11:41:04 <pharpend> GBrawl: also the abstraction stuff. Think of it this way. File input (IO), computations that may fail (Maybe). and lists. All are monads. They are three very different concepts, but we have a uniform way of dealing with them. This is incredibly useful when you are learning a new library, and you see "oh, this data type is a monad, I can do x y and z with it."
11:41:27 <L8D> does someone mind explaining how quickcheck is useful?
11:41:50 <nh2_work> L8D: sure thing!
11:42:01 <pharpend> L8D: For the same reason unit testing is useful, it's just that quickcheck does it more solidly.
11:42:23 <L8D> does it not just verify the types?
11:42:27 <L8D> what else does it do?
11:42:33 <johnw> L8D: pseudo-randomized test generation, with efficiency reduction of failing cases down to their minimal reproducing case
11:42:35 <south> @ocharles Hey
11:42:36 <lambdabot> Unknown command, try @list
11:42:46 <mauke> verify the types? that's what the compiler does
11:42:52 <nh2_work> L8D: without quickcheck, you have to write your test cases by hand. You can write 1, 10 or maybe 50 if you are eager, but quickcheck gives you a principled and easy to use way to generate thousands of them
11:43:23 <pharpend> L8D: one thing with unit tests is, you eventually get bored writing tests (for me, after about 10 minutes), and the quality of your tests decrease over time. QuickCheck minimizes this, because I don't have to write 50 test cases, I have to write 1 property, and quickcheck randomly generates test cases.
11:43:54 <nh2_work> L8D: in addition to that, what johnw said: if it finds a failing test case ("a counterexample"), it tries to reduce it to the smallest counterexample that still fails, so that you can debug the issue easily (debugging failures on small inputs is easier)
11:44:02 <L8D> so it's useful because you can write assertions for randomized inputs?
11:44:24 <L8D> instead of using sample data
11:44:26 <c_wraith> L8D: quickcheck uses types to write randomized inputs for your assertions
11:44:33 <c_wraith> L8D: that's exactly what it does
11:44:43 <L8D> ah
11:44:44 <pharpend> @@ L8D @check (\x -> length (take 5 x) <= 5)
11:44:44 <nh2_work> L8D: the focus is rather that it makes it easy to generate these randomised inputs in a sensible fashion
11:44:46 <lambdabot>  L8D  +++ OK, passed 100 tests.
11:45:26 <bitemyapp> quickcheck is useful in part because it makes you think about whether you have any useful assertions to make about how your code works.
11:45:29 <bitemyapp> if you don't...well...
11:45:34 <L8D> so it's not something that you use on arbitrary code, you still have to write assertions
11:45:52 <mauke> yes
11:45:57 * hackagebot jsontsv 0.1.1.0 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.1.0 (DanielChoi)
11:46:02 <L8D> my friends are absolute idiots
11:46:03 <mauke> you have to write the properties that should hold
11:46:11 <nh2_work> L8D: yes, you first generate yourself some randomized input, and then you write the assertions that say what your code do on those inputs
11:46:27 <L8D> ok thank you all
11:46:45 <bitemyapp> L8D: why are your friends idiots?
11:47:03 <koala_man> lead painted toys
11:47:13 <Gurkenglas> Did they say quickcheck does abstract reasoning about the code you give it to see whether it does what its author probably intended?
11:47:16 <haskellquestion> what are some good online interpreters for haskell besides ideone?
11:47:27 <L8D> bitemyapp: because they still use ruby and node and it's 2014, and they explained quickcheck as something that supplies random input to arbitrary functions and checks if they function doesn't throw an error
11:47:39 <pharpend> L8D: really, the only reason we all learned Haskell is so we could feel smugly superior to our friends.
11:47:42 <crobbins> haskellquestion: tryhaskell.org
11:47:47 <c_wraith> L8D: that sounds more like a fuzzer
11:47:58 <haskellquestion> crobbins: tryhaskell doesn't work for defining functions though..?
11:48:21 <c_wraith> haskellquestion: I think it does, if you use it like ghci
11:48:25 <crobbins> haskellquestion: sure it does... `let foo x = blah in foo thing
11:48:26 <L8D> bitemyapp: I'm that kid with the hair from a week ago
11:48:33 <bitemyapp> L8D: I know.
11:48:34 <mauke> haskellquestion: https://www.fpcomplete.com/new-project
11:48:43 <bitemyapp> L8D: it's called property testing, not "does it throw an exception" testing :)
11:48:48 <pharpend> haskellquestion: you can also /q lambdabot
11:48:55 <nh2_work> pharpend: how did you write that check without saying what list type it shall actually generate? does @check default to Int?
11:49:19 <L8D> nh2_work: probably unit
11:49:27 <L8D> jk
11:49:32 <Gurkenglas> @@nh2_work @check (\x -> length (take 5 x) <= 5)
11:49:38 <haskellquestion> crobbins and c_wraith: if i do let x = x + 5 it doesn't work in tryhaskell.org
11:49:39 <Gurkenglas> @@ nh2_work @check (\x -> length (take 5 x) <= 5)
11:49:42 <lambdabot>  nh2_work  +++ OK, passed 100 tests.
11:49:47 <Gurkenglas> Wait, fail.
11:49:48 <mauke> nh2_work: it uses ()
11:49:51 <mauke> because of extended defaulting
11:49:54 <Gurkenglas> @@ nh2_work @check (\x -> length (take 5 x) /= 4)
11:49:56 <nh2_work> ah I see
11:49:57 <lambdabot>  nh2_work  *** Failed! Falsifiable (after 5 tests):
11:49:57 <lambdabot>  [(),(),(),()]
11:49:59 <crobbins> haskellquestion: mine was more of a joke, since i said `let ... in ...`
11:50:08 <crobbins> but lambdabot works well
11:50:10 <haskellquestion> so tryhaskell.org is bad then?
11:50:17 <crobbins> it's not bad, it's really good
11:50:24 <haskellquestion> can't even define a function..
11:50:24 <crobbins> just use lambdabot
11:50:27 <crobbins> ??
11:50:33 <haskellquestion> im not going to have the class use lambdabot during a presentation lol
11:50:35 <L8D> @check \x -> x >> x
11:50:37 <mauke> haskellquestion: x = x + 5 isn't a function, it's an infinite loop
11:50:38 <lambdabot>  No instance for (Test.QuickCheck.Arbitrary.Arbitrary (m0 b0))
11:50:38 <lambdabot>  arising from a use of ‘Lambdabot.Plugin.Haskell.Check.ShowQ.myquickcheck’ Th...
11:50:44 <L8D> whoops
11:50:50 <L8D> @check \x -> (x >> x) == x
11:50:53 <lambdabot>  No instance for (Test.QuickCheck.Arbitrary.Arbitrary (m0 b0))
11:50:53 <lambdabot>  arising from a use of ‘Lambdabot.Plugin.Haskell.Check.ShowQ.myquickcheck’ Th...
11:50:57 <L8D> aha!
11:50:58 * hackagebot jsontsv 0.1.1.1 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.1.1 (DanielChoi)
11:51:02 <nh2_work> haskellquestion: why not, that'd be funny flooding here :)
11:51:13 <L8D> @check \(x :: Maybe a) -> (x >> x) == x
11:51:15 <lambdabot>  <unknown>.hs: 1: 17:ScopedTypeVariables is not enabled
11:51:17 <haskellquestion> i'm sure the ip would get banned for spamming or something
11:51:19 <L8D> -.-
11:51:21 <crobbins> haskellquestion: i'm sure chrisdone wouldn't mind a pull request
11:51:22 <haskellquestion> 30 people in the class
11:52:20 <Gurkenglas> #haskell-overflow?
11:52:34 <Gurkenglas> Can you get lambdabot to join new channels?
11:52:59 <crobbins> haskellquestion: you could always run lambdabot on your own server :)
11:53:09 <sinelaw> Gurkenglas, someone with enough permissions can
11:53:16 <haskellquestion> ok i'll use ideone i guess i hope it works for 30 people
11:53:37 <Gurkenglas> sinelaw, why wouldn't we want anyone to be able to do that?
11:53:56 <sinelaw> Gurkenglas, it may annoy people on that channel
11:54:24 <Gurkenglas> You don't need specific bots if you want the people in a channel to be annoyed... but okay.
11:54:49 <Gurkenglas> (Maybe allow only someone with permissions on that channel to do it?)
11:55:13 <sinelaw> @join #channel-that-hates-lambdabot
11:55:14 <Gurkenglas> Oh, did you mean target channel permissions or lambdabot dev permissions?
11:55:14 <lambdabot> Not enough privileges
11:55:27 <sinelaw> Gurkenglas, lambdabot operator permissions
11:55:36 <sinelaw> Gurkenglas, you can run your own lambdabot
11:56:05 <sinelaw> I did that once
11:56:14 <L8D> or, y'know, just run your own irc bot
12:08:20 <Kathleen23>  High Quality photos and videos http://s0o.de/f4t4dss
12:08:56 <mauke> heh
12:13:25 <gp5st1> at the very least she could have told us what kind of photos and videos
12:13:37 <gp5st1> like, I'd be all over vintage Pennsylvania Railroad footage
12:19:03 <dmbarbour> Hello #haskell. I'm hoping someone can offer a quick answer: in the GHC Haskell FFI, is there an easy way to access a `#define FOO "hello #haskell"` type string?
12:20:34 <nh2_work> dmbarbour: I think you can just use the CPP language extension and include the relevant file, can't you?
12:21:56 <dmbarbour> @nh2_work: I'll try it.
12:21:57 <lambdabot> Unknown command, try @list
12:22:06 <dmbarbour> nh2_work: I'll try it.
12:22:44 <dmbarbour> nh2_work: no, just comes up as a "not in scope, data constructor `FOO'".
12:25:09 <mauke> dmbarbour: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi.html#ffi-capi
12:27:22 <nh2_work> dmbarbour: do you use hsc2hs?
12:27:49 <nh2_work> dmbarbour: I think you cannot get constants directly with just LANGUAGE CPP
12:28:10 <nh2_work> dmbarbour: with hsc2hs you'd say #const FOO
12:30:13 <dmbarbour> #const FOO gave me: "no instance of Num".
12:30:52 <nh2_work> dmbarbour: can you lpaste?
12:30:58 <dmbarbour> nh2_work: I'm going to try the 'capi' mentioned by mauke.
12:33:11 <wakalabis> Hi, guys. I've been toying with writing small interpreters. I was thinking of implementing Tiny Basic just for fun, but I don't know exactly how to model gotos. Do you guys have any ideas? I was thinking maybe the continuation monad would do.
12:35:59 * hackagebot wreq 0.3.0.0 - An easy-to-use HTTP client library.  http://hackage.haskell.org/package/wreq-0.3.0.0 (BryanOSullivan)
12:37:37 <flyingfisch> could someone refresh my memory? what exactly is going on here? data ZipList a = ZipList { getZipList :: [a] } 
12:37:44 <zmbmartin> Considering the WARNING in Weak 'WARNING: weak pointers to ordinary non-primitive Haskell types are particularly fragile…' would doing your own mkWeakPtr be fragile?
12:38:23 <kinslayer> hey, I have this annoying problem, I am writing something and want to split into several files but somehow when I refere to the name of one of the packages it cant find it (unless I load the file by name in ghci), is there a requirement with regards to names and being in subfolders in the project ?
12:38:41 <dmj`> kinslayer: do you have a folder named src?
12:38:55 <kinslayer> dmj: nope
12:39:05 <kinslayer> it is a `flat` structure
12:39:28 <mmachenry> Has anyone used the slave-thread package or dealt with ghost threads in Haskell? I'm getting some and I'm wondering if there's a recommended way to handle this.
12:39:29 <dmj`> you can tell ghci where to look, but by default it will search the top level directory
12:39:51 <flyingfisch> oh wait
12:39:53 <flyingfisch> now i remember
12:39:54 <Gurkenglas> flyingfisch, it is a simple wrapper that is good for having other implementations of typeclass instances
12:40:18 <kinslayer> dmj but how can I make it find something like App.Parser ?
12:40:21 <flyingfisch> Gurkenglas: yeah, just looked at another example that reminded me of what it does
12:54:25 <dmwit> kinslayer: Yes, GHC looks for Foo.Bar.Baz in Foo/Bar/Baz.[l]hs
12:54:37 <dmwit> kinslayer: This is not a restriction of the language, but of the implementation.
12:54:56 <dmwit> kinslayer: Other compilers may have their own restrictions. I think jhc allows you to specify a manifest mapping module names to file names.
12:54:59 <kinslayer> dmwit It seems common so it makes sense
12:55:15 <dmwit> Perhaps in the future we will use a database instead of the filesystem. ;-)
12:56:30 <dmj`> kinslayer: are you sure your folder hierarchy is correct with the module names?
12:56:52 <kinslayer> well that is what I am checking now
12:57:12 <dmj`> kinslayer: dump your tree output / module names
12:57:29 <dmwit> I think he can handle correcting it now.
12:57:35 <dmwit> He just didn't know the rule before.
12:57:57 <kinslayer> well I would if I had tree :D
12:58:11 <kinslayer> gee I like nix :D
13:00:56 <kinslayer> srsly is there a place where I can find this rule I cant make it do it here :(
13:01:00 * hackagebot hspec-snap 0.3.2.1 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.2.1 (DanielPatterson)
13:04:32 <dmj`> hspec-snap soooo nice omg
13:18:11 <jonaszz> please help
13:18:48 <jonaszz> how can i make like a layout in haskell with gtk? like split the window in 2 parts, like a top menu bar and a content pane
13:19:33 <Clint> use the gtk package?
13:19:43 <jonaszz> yeah, but i don't find which classes
13:20:26 <jonaszz> https://docs.oracle.com/javase/tutorial/figures/uiswing/layout/GridBagLayoutDemo.png
13:20:28 <jonaszz> something like that
13:21:14 <jonaszz> hmmm maybe ill just use a table
13:23:22 <Haskellfant> Graphics.UI.Layout looks like it is the thing you want
13:26:01 * hackagebot groundhog 0.7.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.7.0 (BorisLykah)
13:26:03 * hackagebot groundhog-sqlite 0.7.0 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.7.0 (BorisLykah)
13:26:05 * hackagebot groundhog-postgresql 0.7.0 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.7.0 (BorisLykah)
13:26:07 * hackagebot groundhog-mysql 0.7.0 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.7.0 (BorisLykah)
13:26:09 * hackagebot groundhog-th 0.7.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.7.0 (BorisLykah)
13:31:01 * hackagebot groundhog-inspector 0.7.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-inspector-0.7.0 (BorisLykah)
13:48:02 <jonaszz> no it's not correct
13:48:04 <jonaszz> i will use table
13:49:30 <javjarfer> hi there! anyone knows why i can't get a stackoverflow in ArchLinux ghc 7.8.3?
13:50:10 <erikd> i thought we try to avoid stack overflows :-)
13:50:14 <josephle> you're trying to induce a stack overflow in gch?
13:50:17 <josephle> *ghc?
13:50:35 <javjarfer> yep, exactly
13:51:28 <dkbrk> laziness can make it hard to deliberately get a stock overflow. Try deepseq
13:51:29 <javjarfer> simply beacuse i wanted to get it like a advice when i reach some memory threshold
13:51:46 <Haskellfant> ocharles: https://ocharles.org.uk/blog/pages/2014-12-01-24-days-of-hackage.html returns a 404
13:52:19 <javjarfer> dkbrk: that is what i thought, so i tested all noob codes that should produce a stackoverflow
13:52:27 <javjarfer> drbrk: no ones works
13:53:26 <Ice-x> + Please buy this game http://www.desura.com/games/WipeGround-Wpx +
13:53:58 --- mode: ChanServ set +o glguy
13:54:09 --- mode: glguy set +b *!*@host113-72-dynamic.246-95-r.retail.telecomitalia.it
13:54:16 --- kick: Ice-x was kicked by glguy (spam is offtopic)
13:54:21 <thebnq> javjarfer: try something like foldr1 (+) [1..9999999]
13:54:58 <ij> Monads exist without typeclasses, right? One just needs to the fin
13:55:04 <josephle> I'm not sure out-of-heap is quite the same result as a stack overflow
13:55:05 <thebnq> o, i needed 2 more 9s
13:55:13 <dkbrk> thebnq: or foldr1 (+) [1..]
13:55:22 <thebnq> well in ghci i get stack overflow :)
13:55:40 <thebnq> haha oh yes
13:55:44 <dkbrk> > foldr1 (+) [1..]
13:55:50 <lambdabot>  mueval: ExitFailure 1
13:56:20 <ij> Monads exist without typeclasses? One just needs to define the return/bind functions and a data type, right?
13:56:46 <thebnq> yeah, its how classes would be compiled as
13:56:55 <saep> ij: Yes, you can do everything without typeclasses.
13:57:13 <ij> But you'd have to change the function names whenever changing the monad you want to use?
13:57:31 <javjarfer> dkbrk: yep i have it, i haven't waited that much
13:58:11 <javjarfer> dkrbk: it has consume all the ram and heavy part of the swp
13:58:31 <saep> ij: You usually pass around a `Monad` data type that contains the monad functions by hand. I've read an article about this kind of topic. Let me see if I can find it.
13:58:52 <merijn> @google Gabriel Gonzalez Scrap Your Typeclasses
13:58:53 <javjarfer> dkbrk: i thought the pile for each process was 8M by default, no 3GB
13:58:53 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
13:58:53 <lambdabot> Title: Haskell for all: Scrap your type classes
13:59:06 <merijn> ij: See that article
13:59:14 <merijn> ij: I even believe it uses Monad as an example
14:00:28 <bulldog98> hi has someone an idea how to tell the build system to use the /usr/include, because I get the following http://lpaste.net/115531
14:01:17 <marchelzo_> bulldog98: you can use --extra-include-dirs=
14:01:36 <bulldog98> marchelzo_: ok I'll try that
14:01:46 <javjarfer> yep i have it, i haven't waited that much
14:01:52 <javjarfer>  it has consume all the ram and heavy part of the swp
14:02:00 <javjarfer>  i thought the pile for each process was 8M by default, no 3GB
14:02:15 <ocharles> Haskellfant: how did you get there?
14:02:57 <bulldog98> marchelzo_: in what program call?
14:03:18 <marchelzo_> bulldog98: it's a flag for cabal I think
14:03:43 <bulldog98> marchelzo_: how can I set that in a cross compile for ghc?
14:03:47 <Haskellfant> ocharles: go to https://ocharles.org.uk/blog/ and click on 24 days of ghc extensions
14:04:13 <ocharles> Oh... Odd. Let me take a look
14:04:29 <marchelzo_> bulldog98: are you sure you have the headers? It's sucessfully finding most of the standard headers which are probably in /usr/include
14:04:46 <Haskellfant> ocharles: that didn't happen about half an hour ago or so (yes I've been refreshing quite a lot :))
14:04:47 <jfischoff> is there an example for converting a ResourceT IO (ResumableSource (ResourceT IO) ByteString) to a StreamingBody?
14:04:51 <bulldog98> marchelzo_: yes I just checked that
14:05:10 <jfischoff> I keep trying to write one, and end up runResourceT twice
14:05:26 <jfischoff> err calling runResourceT twice
14:06:32 <bitemyapp> jfischoff: can't you traverse that?
14:06:47 <AleksejsHome> simple question: foo = "bar" -- Is foo a function?
14:06:59 <kadoban> AleksejsHome: No.
14:07:09 <erikd> jfischoff: i think you need to resume the ResumableSource to get a regular Source
14:07:24 <shachaf> Not unless you have a function instance for OverloadedStrings.
14:07:26 <jfischoff> ah
14:07:47 <marchelzo_> bulldog98: take a look at https://ghc.haskell.org/trac/ghc/ticket/7754
14:08:44 <jfischoff> erikd: Actually that doesn’t really help me
14:10:41 <merijn> @google conal elliott everything is a function haskell
14:11:08 <merijn> @botsnack
14:11:13 <merijn> :(
14:11:25 <kadoban> @botsmack
14:11:30 <kadoban> Darn
14:11:31 <indiagreen> http://conal.net/blog/posts/everything-is-a-function-in-haskell
14:11:40 <gcganley> for those working with scotty, do you use monoid sugar or monad sugar
14:12:01 <erikd> jfischoff: unwrapResumable :: MonadIO m => ResumableSource m o -> m (Source m o, m ()) from Data.Conduit.Internal ?
14:12:23 <jfischoff> I don’t see how that helps me
14:12:40 <jfischoff> when I make a http call from http-conduit
14:12:53 <jfischoff> I get a Response in the Resource
14:12:57 <jfischoff> ResourceT
14:13:22 <johnw> jfischoff: I don't think http-client (the successor to http-conduit) uses ResumableSource anymore
14:13:23 <jfischoff> and the Response body is ResumableSource in ResourceT
14:13:48 <jfischoff> johnw: is http-conduit deprecated?
14:14:14 <johnw> not officially, but I don't think it's a focus of development anymore
14:14:27 <erikd> johnw: snoyman said no to me. they will both be maintained for the forseeable future.
14:14:36 <johnw> ah, ok
14:14:37 <jfischoff> I think http-conduit was a “high level” interface to http-client
14:14:53 <jfischoff> anyway
14:15:08 <P4Titan> Hello all, is there a way to import hiding only the unqualified version of a single function
14:15:25 <P4Titan> And everything else be normal
14:15:33 <shachaf> import M hiding (f); import qualified M
14:15:35 <erikd> P4Titan: import Prelude hiding (x)
14:15:39 <lambdabot> Plugin `search' failed with: <<timeout>>
14:16:10 <jfischoff> So the response is in ResourceT and I have Source (ResourceT IO), I think if I run the ResourceT to get the body things are closed no?
14:16:53 <jfischoff> wait
14:16:59 <jfischoff> I think I see the confusion here
14:28:26 <jfischoff> No, no, I don’t understand how ResumableSource is meant to be used
14:29:28 <johnw> there's a special binding operator
14:29:35 <jfischoff> i know
14:29:44 <johnw> so, use it like a regular source, but with that operator
14:29:50 <jfischoff> I know
14:30:18 <jfischoff> but I thought the idea is you use it, because you want to delay closing a resource
14:30:46 <jfischoff> and it will close it, when the source is exhausted
14:31:44 <guest-1092> Are there any SMT solvers that are simpler than SBV and don't have external dependencies
14:34:56 <senoj> guest-1092: do you mean SMT solvers with a haskell API?
14:35:39 <senoj> or just SMT solvers period (b/c there are plenty of standalone those)
14:35:55 <guest-1092> senoj: Haskell libraries that solve SMT
14:36:04 * hackagebot bspack 0.0.4 - A simple and fast bytestring packer  http://hackage.haskell.org/package/bspack-0.0.4 (nicolasdp)
14:37:27 <guest-1092> senoj: So, with a haskell API
14:37:34 <guest-1092> But implemented in haskell
14:38:13 <b00> anyone have any recommendations on how to install an older version of ghc beside a recent one? I have the Haskell platform currently installed on Yosemite.
14:38:31 <b00> when i say beside i mean next to
14:38:55 <senoj> I'm not aware of any. There certainly aren't any with performance comparable to say Yices, CVC4, or Z3
14:39:24 <suvash> anybody here with an experience of using text-icu for regex on unicode ?
14:39:32 <suvash> or played around with it ?
14:39:45 <guest-1092> senoj: Hm. I'm making software that needs to be easy to distribute, so thought it would be best if it could be statically linked
14:40:01 <Darwin226> Hey guys. Is there a way to have a type constraint that only accepts types that are NOT a part of some class?
14:40:29 <monochrom> no
14:41:16 <Darwin226> :(
14:41:36 <ocharles> Haskellfant: the problem is that the homepage is cached
14:41:44 <ocharles> if you force refresh it should all work
14:41:45 <senoj> guest-1092: you can compile cvc4 to a static lib, there are debian packages that do
14:42:06 <Haskellfant> ocharles: ah k, it works now, thx!
14:42:27 <guest-1092> senoj: It also so happens that I can't find much information on sbv
14:42:36 <guest-1092> I have a hard time reading the haddock
14:45:12 <guest-1092> senoj: Thanks anyway
14:45:45 <senoj> guest-1092: I remember this talk being a good use of SBV: http://acowley.github.io/NYHUG/FunctionalRoboticist.pdf
14:46:05 * hackagebot Nomyx-Language 0.7.5 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.7.5 (CorentinDupont)
14:46:06 <senoj> guest-1092: talk video: http://vimeo.com/77164337
14:46:07 * hackagebot Nomyx-Core 0.7.5 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-Core-0.7.5 (CorentinDupont)
14:46:09 * hackagebot Nomyx-Web 0.7.5 - Web gui for Nomyx  http://hackage.haskell.org/package/Nomyx-Web-0.7.5 (CorentinDupont)
14:47:18 <guest-1092> senoj: A talk sounds good
14:47:20 <guest-1092> Thanks
14:47:56 <b00> anyone know how to install multiple versions of ghc?
14:48:11 <Welkin> b00: use a sandbox
14:48:12 <guest-1092> b00: Nix package manager?
14:48:27 <b00> im on osx btw
14:48:31 <guest-1092> Welkin: I thought a sandbox only helped for multiple sets of packages
14:49:28 <merijn> b00: Just install multiple versions of the binary release
14:49:37 <merijn> b00: GHC uses a per version package database
14:51:05 * hackagebot Nomyx 0.7.5 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.7.5 (CorentinDupont)
14:51:14 <merijn> b00: I just install in different versions into $HOME/ghc-7.6, $HOME/ghc-7.8, etc. and update my path to have the right one first
14:51:18 <senoj> b00: you can install multiple GHCs from the binary distribution for your platform and then adjust your $PATH depending
14:51:25 <merijn> cabal automatically uses the GHC on your path
14:52:26 <b00> im afraid of messing up my file system
14:53:13 <merijn> How so?
14:53:31 <merijn> Just do "./configure --prefix=/path/to/install && make install", done
14:54:44 <senoj> b00: you can do this using regular non-privledged user permissions
14:55:03 <hpc> you can also if you're extra paranoid do a regular old make, then copy the binary out
14:55:19 <hpc> (but don't do that)
14:56:05 * hackagebot hspec-webdriver 1.0.1 - Write end2end web application tests using webdriver and hspec  http://hackage.haskell.org/package/hspec-webdriver-1.0.1 (JohnLenz)
14:56:06 <senoj> b00: and all you have to do to reset everything is delete the directory you extract the tarball to and the directory /path/to/install
14:56:19 <senoj> (and reset your $PATH)
14:58:35 <ij> merijn, Thanks for the scrap-your-type-classes. The more I know.
15:03:23 <flyingfisch> are there any good videos on Monads?
15:06:18 <Welkin> why would you want videos?
15:06:24 <Welkin> there are plenty of good articles
15:06:35 <Welkin> flyingfisch: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
15:06:36 <annoyabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al..., http://tinyurl.com/cr2hvx
15:06:42 <Welkin> that is one of the best introductions to monads
15:06:50 <flyingfisch> Welkin: thank you
15:06:56 <Welkin> who is annoyabot ?
15:07:05 <shachaf> sinelaw: What's this bot about?
15:07:13 <Welkin> oh
15:07:13 <Fuuzetsu> We don't really need another bot do we?
15:07:15 <sinelaw> oops.
15:07:19 <Welkin> the chatterbot
15:07:19 <flyingfisch> I think I understand >>= and >>, but I need help with Reader and Writer, so I will take a look at that
15:07:27 <sinelaw> @quit
15:07:27 <lambdabot> Not enough privileges
15:11:05 * hackagebot pipes-http 1.0.2 - HTTP client with pipes interface  http://hackage.haskell.org/package/pipes-http-1.0.2 (GabrielGonzalez)
15:16:06 * hackagebot webdriver-angular 0.1.6 - Webdriver actions to assist with testing a webpage which uses Angular.Js  http://hackage.haskell.org/package/webdriver-angular-0.1.6 (JohnLenz)
15:20:45 <benzrf> @quit
15:20:46 <lambdabot> Not enough privileges
15:21:16 <sinelaw> bitch.
15:21:21 <benzrf> lambdabot: ill have u know that im a young white male from a middle class family
15:21:26 <benzrf> lambdabot: how much privilege do you WANT
15:23:28 <shachaf> sinelaw: Really?
15:23:34 <shachaf> sinelaw: Not appropriate for this channel.
15:23:58 <sinelaw> shachaf, noted, sorry.
15:26:07 <jmct> shachaf: Random question: how do you pronounce your name?
15:28:57 <ion> jmct: “fun-puns”
15:40:02 <mmmm> Is there a version of takeWhile which also takes the item which first matches the predicate?
15:40:30 <sinelaw> mmmm, type?
15:41:08 <mmmm> (a -> Bool) -> [a] -> [a]
15:41:18 <mmmm> the same as takeWhile but taking one extra element
15:42:49 <Iceland_jack> mmmm: Your best bet is probably to use 'span'
15:43:03 <Iceland_jack> > span isUpper "TESTing"
15:43:04 <lambdabot>  ("TEST","ing")
15:43:19 <Iceland_jack> and just grabbing the head of "ing"
15:46:07 * hackagebot snaplet-influxdb 1.0.1.1 - Snap framework snaplet for the InfluxDB library  http://hackage.haskell.org/package/snaplet-influxdb-1.0.1.1 (ParnellSpringmeyer)
15:50:29 <dfeuer> Hrrr... I'm getting an "index out of bounds" error. What's the best way to figure out where that's coming from?
15:51:11 <glguy> You might try https://www.haskell.org/haskellwiki/Debugging#Stack_trace
15:51:15 --- mode: glguy set -o glguy
15:51:32 <dfeuer> Thanks, glguy.
15:54:20 <dfeuer> Thanks, glguy, but I don't think it helps. It seems to be telling me I screwed up my arithmetic. Well, I already knew that.
15:54:43 <glguy> If you go through the process it'll help you figure out the place where you made that mistake
15:54:53 <glguy> or whomever
15:55:17 <glguy> Where the indexing was taking place in your program
15:56:07 * hackagebot hoist-error 0.1.0.2 - Some convenience facilities for hoisting errors into a monad  http://hackage.haskell.org/package/hoist-error-0.1.0.2 (JonSterling)
15:57:27 <Dulnes> Pep pep good creb
15:58:10 <dfeuer> glguy, yeah, I know where indexing is taking place, and it narrowed down which indexing operation it is (if I understand it correctly), but unfortunately that's one that has quite an involved calculation behind it.
15:58:40 <dfeuer> So there's a mistake in there, somewhere.
15:58:53 <exio4> do you have an external function that "does" the calculations?
15:58:56 <dfeuer> Well, sort of.
15:59:08 <exio4> I had a similar problem, and my way to debug it was a bruteforce of corner cases :P
15:59:12 <dfeuer> exio4, the index is always 0 there.
15:59:27 <dfeuer> It's the thing I'm indexing into that's supposed to have exactly one element..
15:59:54 <dfeuer> If it has less than one, it will give this error. More than one and it will give the wrong answer.
16:04:36 <Darwin226> Sorry for spamming with questions, but is there any way to get this to work? https://gist.github.com/45d41ad5ee756c58cf75
16:05:14 <Darwin226> It complains about conflicting dependencies, which makes sense since the first isntance claims x y make a True, and the second one claims x y make a False
16:05:29 <Darwin226> How do I get around this?
16:05:53 <Darwin226> I basically want "instance Equal x y True" if "x~y" and False in any other case
16:08:00 <glguy> Darwin226: With closed type families you should be able to do something like:  type Equal x y :: Bool where Equal x x = True; Equal x y = False
16:08:36 <Darwin226> glguy: I see. I was hoping I could get away with just fundeps. Without type families
16:08:40 <glguy> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Type-Equality.html
16:08:41 <Iceland_jack> Darwin226: You can, but you'd use closed type families (as glguy pointed out) to implement that
16:09:00 <Iceland_jack> It may be possible to do with fundeps, I'm not sure
16:11:32 <Darwin226> Iceland_jack: Well, I've been trying to crack it for a while now. I'd be really great if it's possible since I've implemented a lot of type-level magic already without using families
16:11:51 <Iceland_jack> Is there a reason for avoiding those?
16:12:42 <Darwin226> Iceland_jack: None except that I'm starting to get the hang of writting stuff with fundeps and I don't know how to use type families
16:14:53 <Iceland_jack> Ah, type families are much nicer to work with if you can
16:14:53 <Iceland_jack> Rather than expressing functions as relations
16:15:35 <Darwin226> Iceland_jack: One step at a time.
16:15:41 <Iceland_jack> Sure :)
16:17:10 <lpaste> Luke pasted “OpenSSL Segfault” at http://lpaste.net/115535
16:17:26 <Luke> ^^ can anyone help me with this ghci segfault i'm getting?
16:17:53 <Luke> this all started with me having issues with OpenSSL not working
16:17:58 <glguy> Darwin226: For you you'll have to use closed type families. The functionality you'd need to do it with fundeps is part of the "instance chains" proposal, but that isn't actually implemented
16:18:01 <Luke> so I tried just doing baselineContextSSL and now it segfaults
16:18:48 <Luke> I'm on OS X Yosemite
16:18:58 <glguy> Luke: You probably need to call the openssl initialization function first
16:19:10 <Luke> the withOpenSSL or whatever?
16:19:11 <glguy> http://hackage.haskell.org/package/HsOpenSSL-0.11/docs/OpenSSL.html
16:19:18 <Luke> yeah
16:20:09 <Luke> glguy: good call - that was it
16:20:11 <Luke> red herring then
16:20:12 <Luke> thanks
16:22:07 <Darwin226> glguy: Ok. Thanks for the info. I guess I'll have to learn type families sooner than I thought
16:23:13 <lpaste> Luke pasted “http-streams 502 Bad Gateway” at http://lpaste.net/115536
16:23:28 <Luke> ^^ here's the real issue I'm having
16:24:41 <Luke> when I browse to the URL it works fine
16:29:51 <Denommus> is there any simple web service framework/library for Haskell similar to Sinatra?
16:30:06 <bitemyapp> Denommus: Scotty
16:30:15 <bgamari> Does this have a name? https://gist.github.com/bgamari/812f1f4f97b7eeec6f91
16:30:24 <bitemyapp> Denommus: http://hackage.haskell.org/package/scotty http://bitemyapp.com/posts/2014-08-22-url-shortener-in-haskell.html http://bitemyapp.com/posts/2014-11-22-literate-url-shortener.html
16:30:29 <bgamari> StateA perhaps?
16:30:35 <bgamari> It's like an Applicative state I guess
16:30:57 <bgamari> and is it really true that it can't be a monad
16:31:00 <bitemyapp> bgamari: weird. How'd you trip into it?
16:31:49 <bgamari> bitemyapp, I needed a `StateT s (Free SomeFunctor) a` to construct an AST
16:31:50 <glguy> bgamari: That shape is used to implement indexing in the lens package
16:32:09 <bgamari> but I wanted to get the new state without running the Free
16:32:17 <bitemyapp> glguy: what's the name though?
16:33:20 <glguy> It isn't named, it's basically just:    Compose (State s)
16:33:37 <glguy> In lens the definition is inlined, however
16:33:41 <glguy> http://hackage.haskell.org/package/lens-4.6.0.1/docs/Control-Lens-Internal-Indexed.html#g:3
16:34:43 <bitemyapp> glguy: so indexing with a polymorphic indexing value?
16:34:44 <bgamari> glguy, Monad isn't possible?
16:37:00 <bgamari> I guess `Compose` there's probably a reason why Compose hasn't any Monad instance
16:37:31 <bgamari> although they language is "isn't always" so it's not entirely clear
16:37:34 <bitemyapp> >there's probably a reason why
16:37:43 <bitemyapp> bgamari: you're going to start another monad transformer whinefest
16:37:46 <bitemyapp> pls no
16:37:49 <glguy> :t runState . Data.Functor.Compose.getCompose
16:37:50 <lambdabot> Data.Functor.Compose.Compose (StateT s Identity) g a -> s -> (g a, s)
16:38:33 <bgamari> yep, that looks about right
16:39:51 <bgamari> glguy, but it seems that `Compose f g` never has a monad instance; is `Compose (State s) g` a monad if g is a `Monad`?
16:42:07 <bitemyapp> bgamari: that's asking if (State s) is a monad.
16:42:33 <bgamari> Is that all?
16:42:42 <bgamari> I would have thought there would be more to it than that
16:42:56 <bitemyapp> well when you reformulated into that Compose
16:42:57 <bgamari> as the composition of two monads doesn't always give you a monad
16:43:09 <bitemyapp> there's a little more to it than that.
16:43:18 <bgamari> I'm not entirely sure what the requirements are for composition
16:43:28 <bitemyapp> the rule of thumb, IIRC, is that the composition of two monads polymorphically do not necessarily give rise to another monad.
16:44:04 <bitemyapp> but if you have more information about *one* of them, and that one you have more information about is a monad, then you can usually get a monad modulo transformerication.
16:44:37 <bitemyapp> so to produce the combined monad, you use the polymorphic >>= for the one you don't know, then use specific information for the "inner" transformer data type wrapped in the polymorphic m
16:44:38 <bgamari> ahh, alright
16:45:50 <bgamari> In my case I actually know both monads
16:46:19 <bitemyapp> bgamari: the quickest way to understand why you need specific information for one is to try to write the monad instance for Compose. No way to combine polymorphic return/fmap/join in a way that'll collapse 'em properly.
16:46:30 <glguy> bgamari: I don't think it's possible for YourState s m a to be a monad
16:46:42 <glguy> that is for it to be a monad for all Monads m
16:46:45 <glguy> or whatever
16:47:26 <bgamari> bitemyapp, indeed that's what I ran into
16:48:05 <glguy> type S s m a = s -> (s,m a)   ;   join :: S s m (S s m a) -> S s m a    ===>   (s -> (s, m (s -> (s, m a)))) -> (s -> (s, m a))
16:48:28 <glguy> You'd need to find a way to look inside the arbitrary monad to figure out what it was doing to the state and pull that out
16:48:42 <bitemyapp> yeah but bgamari said he knew both monads concretely
16:48:43 <glguy> (That's not a formal argument)
16:48:57 <bitemyapp> bgamari: we know StateA, what's the m?
16:49:12 <bgamari> Free f
16:49:51 <bitemyapp> bgamari: basically, you're not going to achieve your goal of leaving Free alone and still get a monad/
16:51:14 <bgamari> to sketch out the problem, I want to build up an AST where you can place new variable bindings on the nodes; I was using Free to generate my AST and State to maintain a store of fresh variable IDs
16:51:34 <bgamari> This is roughly the state of the code, https://github.com/bgamari/model-fit/blob/master/Model.hs#L118
16:52:06 <bgamari> Param (line 66) is my variable
16:52:54 <bgamari> FitExpr (line 85) is the monad in which I generate my AST
16:53:12 <bgamari> It could just be a free applicative I suppose
16:53:53 <bgamari> I'm not really sure whether I need Monad; it's nice to be able to use do notation but I've not really needed monadic binding yet
16:59:13 <monochrom> Applicative may be a good middle ground
16:59:42 <monochrom> bind is very binding, as in, it comes with a pretty strong law.
17:08:21 <benzrf> join is where its at
17:08:24 <benzrf> j o I N
17:08:38 <bitemyapp> bgamari: time to enable applicative do syntax? :P
17:08:51 <bgamari> bitemyapp, indeed it would be nice
17:09:05 <benzrf> bitemyapp: i think most of the time we use do notation where all u need is applicative, combinators work better
17:11:17 <bitemyapp> benzrf: I agree for my own code, but people like do syntax.
17:11:51 <bitemyapp> bgamari: if you're hell-bent: http://hackage.haskell.org/package/applicative-quoters-0.1.0.7/docs/Control-Applicative-QQ-ADo.html
17:12:21 <bgamari> it's alright; as I said I haven't really needed do yet
17:12:23 <orion> In cereal, how do the default implementations of `get' and `put' work?
17:12:27 <bgamari> we'll see how things go
17:12:40 <bgamari> orion, I suspect they use Generics
17:12:47 <bgamari> that's what binary does at least
17:13:05 <bitemyapp> orion: it is indeed generics
17:13:13 <bitemyapp> orion: if your compiler doesn't support generics, you won't have defaults.
17:13:44 <bitemyapp> #ifdef GENERICS; default put :: (Generic t, GSerialize (Rep t)) => Putter t; put = gPut . from
17:13:55 <bitemyapp> default get :: (Generic t, GSerialize (Rep t)) => Get t; get = to <$> gGet; #endif
17:14:06 <orion> hmm, magic
17:14:50 <bitemyapp> if you think Generics are magic, sure.
17:15:23 <bitemyapp> but really Generics aren't that complicated
17:15:32 <hcore> hey simple question, what's the function in haskell to keep the part of a list that returns true on a boolean comparison?
17:15:38 <bitemyapp> you're just defining a fold of sums and products.
17:15:44 <bitemyapp> hcore: filter?
17:15:48 <hcore> that's it!
17:15:49 <hcore> thanks!
17:15:49 <bitemyapp> @ty filter
17:15:50 <lambdabot> (a -> Bool) -> [a] -> [a]
17:17:33 <orion> Let's say I have a record type: data Blah = Blah { f :: ByteString, g :: ByteString } -- if I add "deriving Generic" to it and provide a Serialize instance, will the final encoded ByteString be the output of `f' concatenated with the output of `g'?
17:18:19 <bitemyapp> orion: you'd need to look at the generic functions to verify, I don't know what cereal's actual binary representations tend to look like.
17:18:28 <orion> I see, ok.
17:18:34 <bitemyapp> orion: but it's not a bad guess. I'd surmise there's some preamble/header involved maybe, otherwise yeah sure.
17:19:57 <orion> If I need direct control over the format of every single field within the final output that cereal provides, all I have to do is provide a Serialize instance for every single data type, correct?
17:20:26 <bitonic> orion: thankfully, we can look at the code!  <https://github.com/GaloisInc/cereal/blob/master/src/Data/Serialize.hs#L504>
17:20:39 <bitonic> for a product, serialize the first and then the second element
17:20:50 <bitonic> for things with constructors, just serialize the content
17:21:09 <bitonic> (sums are a bit more involved)
17:21:58 <bitonic> so, how the field is going to be serialized depend on the instance for the field type.  but if you have some product type and you use the Generics instances, it's just going to write them one after the other
17:22:00 <orion> bitonic: Ah, cool.
17:22:32 <orion> Would it be correct to consider a record like I mentioned above to be a product type?
17:22:39 <bitonic> yes
17:22:43 <orion> Excellent.
17:23:17 <bitonic> I suggest you take a look at `-ddump-deriv'
17:23:38 <bitonic> it'll state plainly what type it's deriving for the Generic instance of your record type
17:23:44 <bitonic> so you won't have to trust me :)
17:23:53 <orion> Awesome, thank you for the tip.
17:24:40 <bitonic> but the important bit there is that that `M1' instance happily throws away the meta-information it's storing -- like constructor names and so on
17:25:08 <bitonic> now I don't even remember if field names are stored in GHC.Generics, but it's not using them
17:25:37 <nshepperd> if you need control over the wire format, you're probably better off using the Get and Put monads directly instead of writing Serialize instances-0.3.0.0
17:26:09 <nshepperd> whoops, middle clicked >_>
17:26:39 <t4nk891> @pl \f g x y -> f (x ++ g x) (g y)
17:26:39 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
17:27:21 <t4nk891> @pl \x -> (x `mod` 3) == 0 || (x `mod` 5) == 0
17:27:21 <lambdabot> ap ((||) . (0 ==) . (`mod` 3)) ((0 ==) . (`mod` 5))
17:27:33 <bitonic> I wonder if we can somehow collage the line noise generated by @pl in this channel into an art piece
17:28:52 <bitemyapp> bitonic: real question, would it execute in Perl 6?
17:30:14 <bitonic> will it Perl?  a new youtube show
17:30:28 * bitonic doesn't know much about Perl :(
17:30:33 <bitemyapp> just as well.
17:30:52 <gp5st> i wonder if ghc would accept a patch where every so often after you compile a file a bunch of times and there are still errors it would spit out an encouraging message
17:31:15 <gp5st> "Don't worry, I'm just super picky. You're doing great! Keep at it! I believe in you!"
17:31:47 <bitonic> picky?  throw an undefined and it'll eat anything
17:32:42 <hpc> make it an RPG
17:32:56 <hpc> save your stats in /tmp and compare with other users on the same box
17:33:02 <gp5st> :-p
17:33:04 <marchelzo_> throw in an unafeCoerce and it will really eat anything
17:33:05 <bitonic> didn't they actually do some crowfunded proofs?  if they didn't they should
17:33:10 <marchelzo_> unsafeCoerce*
17:33:35 <bitonic> the Agda compiler to Haskell actually `unsafeCoerce's every function and every argument of each function call
17:33:51 <hpc> it does
17:34:01 <johnw> it's already type-checked on the Agda side
17:34:03 <hpc> reading the output is an experience
17:34:10 <bitonic> must be a delight for the optimizer
17:34:12 <bitonic> NEXT!
17:34:30 <hpc> i think all the coerces make that pass do nothing at all
17:34:36 <bitonic> right
17:34:57 <hpc> except maybe the absolute simplest of optimizations
17:36:09 <torpet> how can i find the max in a [[Integer]] Type?
17:36:19 <Welkin> gp5st: yesod does exactly that
17:36:35 <Welkin> when you use yesod devel, during compilation it flashes inspirational messages
17:36:40 <monochrom> maximum (map maximum the_nested_list)
17:36:41 <bitonic> torpet: maximum . concat?
17:36:48 <gp5st> Welkin: wonderful :)
17:40:26 <Dulnes> Mmmm
17:55:46 <gp5st> http://hackage.haskell.org/package/fgl-5.5.0.1/docs/Data-Graph-Inductive-Graph.html#t:Graph in the signatures, graph looks like it's taking 2 args, does anyone know what they are or why they're there?
18:02:16 <ashleee22> Spy your Whatsapp contacts in http://www.checkwhatsapp.com
18:02:47 --- mode: ChanServ set +o geekosaur
18:02:54 --- mode: geekosaur set +b *!*@238.Red-88-0-136.dynamicIP.rima-tde.net
18:02:54 --- kick: ashleee22 was kicked by geekosaur (ashleee22)
18:03:01 --- mode: geekosaur set -o geekosaur
18:03:58 <geekosaur> gp5st, as I read that, it's a parameterized typeclass; a is the type of nodes and b is the type of edges. see for example the signature for mkGraph
18:05:09 <geekosaur> so you can annotate them, presumably
18:05:30 <gp5st> geekosaur: oi! Thank you. I think that makes sense /me was blinded by a bad first impression
18:13:28 <red__> is "cabal update" followed by "cabal install cabal-install
18:13:37 <red__> not the appropriate way to upgrade that guy?
18:14:04 <Welkin> yes
18:14:05 <red__> i want 1.18 for sandbox and that seems to be the easiest route
18:16:17 <red__> Installed cabal-install-1.20.0.3
18:16:17 <red__> red@house:~/tst$ cabal --version
18:16:17 <red__> cabal-install version 1.16.0.2
18:16:27 <red__> even if i restart..ugh?
18:17:16 <Welkin> you need to add it to your path
18:17:44 <Welkin> ~/.cabal/bin or ~/Library/Haskell/bin
18:17:50 <red__> ok ... /home/.../.cabal/bin
18:17:51 <Welkin> depending on your OS
18:18:07 <red__> cabal was somewhere else before? that my path included i assume
18:18:10 <red__> thanks...will do
18:18:18 <Welkin> yes
18:18:26 <Welkin> the global package installed by haskell platform
18:18:39 <Welkin> but when you use `cabal install` it installs into your home directory
18:19:26 <Welkin> you can specify whether you want the packages isntalled globally or locally with a flag
18:19:32 <Welkin> type cabal --help
18:19:52 <red__> got it .. thanks for the nudge . i'll look into it
18:21:12 * hackagebot data-clist 0.0.7.3 - Simple functional ring type.  http://hackage.haskell.org/package/data-clist-0.0.7.3 (jeremyjh)
18:28:17 <nobody__> hi
18:28:59 <nobody__> anyone have some ideas to parallelize this code?: http://en.literateprograms.org/Sieve_of_Eratosthenes_%28Haskell%29
18:32:57 <charlie> nobody__ ~ you can do different multiples in different threads
18:33:08 <charlie> on thread marks off multiples of two, another marks off multiples of three
18:33:57 <nobody__> yes, but given that they are only consumed one at a time by need a) will the IPC outweight the benefit? and b) how will the communication to/fro the threads occur?
18:34:04 <nobody__> ITC rather
18:34:05 <Iceland_jack> No need to use threads, Eval or Par monads will cover this
18:36:55 <nobody__> charlie: i.e., there would need to be a ‘chunking’ mechanism to offset the overhead of comms
18:37:01 <nobody__> [i think]
18:37:08 <charlie> maybe
18:37:12 <charlie> idk
18:38:58 <carter> nobody__: or use a more modern sieve!
18:39:07 <nobody__> carter: such as?
18:39:23 <Iceland_jack> Sieve2000™
18:39:44 <gcganley> Iceland_jack: the ^tm
18:39:53 <ReinH> nobody__: Have you seen SimonM's book on parallel and concurrent Haskell?
18:39:55 <carter> googling http://en.wikipedia.org/wiki/Sieve_of_Atkin
18:40:11 <ReinH> carter: o/
18:40:16 <carter> ReinH: sup
18:40:20 <gcganley> yeah if youre wondering about performence i would recomend Simons book
18:40:23 <nobody__> ReinH: just saw it after Googling but would require complete revamping i think
18:40:33 <carter> nobody__: thers a HUGE range sieve theory out there
18:41:00 <ReinH> nobody__: reading a book would require a complete revamping?
18:41:11 <gcganley> ReinH: revamp his head
18:41:11 <nobody__> ReinH: applying the knowledge in the book
18:41:21 <ReinH> nobody__: Ah, right, but probably worth it :)
18:42:27 <gcganley> ReinH: hey you talk about how you stick with vim but it seems like you view emacs as a sort of walled garden. what are some barriers with switching to emacs
18:42:34 <nobody__> carter: looks like Sieve of Atkin is merely an incremental improvement. would probably get more benefit by parallelizing any of these sieves (beyond naive) and scaling across a cluster
18:42:37 <lpaste> hcore pasted “primefacs” at http://lpaste.net/115543
18:42:47 <ReinH> gcganley: well, I'm using emacs now, so...
18:42:50 <carter> nobody__: idk
18:42:55 <carter> what makes you think that
18:42:56 <gcganley> ReinH: Go you!
18:43:09 <ReinH> gcganley: the usual learning curve of emacs + conflicts with your vim muscle memory
18:43:21 <gcganley> ReinH: sorry i get all my info from year old podcasts
18:43:23 <ReinH> gcganley: well, I still use vim for some things, but emacs for Haskell
18:43:26 <ReinH> gcganley: :)
18:43:42 <hcore> does notElem stop at the first occurrence of a value in a list?
18:43:46 <ReinH> I don't think the barriers are lower for emacs, but I've been doing vim for a decade so I've already paid that price
18:43:50 <gcganley> ReinH: how many times have you caught yourself running `vim ~/.emacs.d/init.el`
18:43:52 <ReinH> er, don't think they're higher
18:44:00 <ReinH> gcganley: a few times, less lately
18:44:25 <ReinH> Now I catch myself using emacs binds in vim...
18:44:34 <ddellacosta> ReinH: tried using evil?
18:44:48 <gcganley> ReinH: i went from Visual Studio to emacs
18:45:12 <ddellacosta> I've been (re-)learning vim via evil, and I'm liking it a lot
18:45:26 <nobody__> is ‘Cloud Haskell’ the accepted Erlang-style actor system for Haskell?
18:45:53 <gcganley> ddellacosta: i fond it just to be better to use emacs bindings because every so often you dont have access to evil, at least thats my opinion
18:46:07 <Windows> Hi
18:46:16 <gcganley> Windows: hello
18:46:20 <kvanb> I hate Windows
18:46:26 <ddellacosta> gcganley: yeah, I mean, I'm in a weird place because I'm a long-time emacs user who wanted to stop using my pinky so much
18:46:27 <lpaste> hcore revised “primefacs”: “No title” at http://lpaste.net/115543
18:46:31 <Windows> Thats the point
18:46:36 <gcganley> irony
18:46:40 <nobody__> I like Windows but only if it is Windows ME
18:46:49 <gcganley> Windows longhorn for life
18:46:51 <ddellacosta> gcganley: nothing's perfect, huh. ;-)
18:47:00 <hcore> super short story: I once shook a computer to death when it ran Windows ME
18:47:02 <gcganley> Arch: yay!
18:47:12 <hcore> after 3 or 4 years of aggrivation i just lost it
18:47:14 <Arch> Mmm spaghetti
18:47:32 <hcore> or aggravation
18:47:33 <trap_exit> is there any nice "prolog as a Haskell DSL" libraries out there?
18:47:36 <gcganley> hcore: wow, nerd rage much?
18:47:50 <trap_exit> is there any nice "prolog as a Haskell DSL" libraries out there? perferably somethign involving monads rather than Template Haskell
18:47:51 <hcore> i haven't nerd raged like that since
18:47:51 <gcganley> trap_exit: i would guess a boat load
18:47:54 <hcore> but seriously
18:48:00 <Arch> Well ME
18:48:04 <trap_exit> gcganley: which one do you use?
18:48:08 <Arch> Is pretty eh
18:48:11 <nobody__> I hate Arch Linux
18:48:30 <Arch> Liesss
18:49:00 <gcganley> trap_exit: i dont personally do that sort of programming but i've seen alot of that sorta thing on hackage ill pull up a link
18:49:12 <Arch> How can you hate it
18:49:22 <srhb> trap_exit: Didn't the monadic constraint programming paper authors churn out a DSL?
18:49:28 <nobody__> Arch: I don’t know it. And I hate what I don’t know
18:49:32 <trap_exit> gcganley: it does feel like the type of thing that is easy to code up in haskell, but I am not familiar with it and thus asking
18:49:41 <trap_exit> srhb: I have no idea, what is monadic constraint programming?
18:49:43 <nobody__> Arch: how does it compare to Ubuntu?
18:49:51 <Arch> Better
18:49:57 <srhb> nobody__, Arch: Can you take that topic off this channel, please. :)
18:50:08 <gcganley> trap_exit: go to hackage and Ctrl-f "prolog"
18:50:08 <Arch> Okey
18:50:27 <srhb> trap_exit: Well, I would assume constraint programming is Prolog, and monadic constraint programming is what you wanted.
18:50:28 <nobody__> srhb: sure. so, back to my Haskell question:  is ‘Cloud Haskell’ the accepted Erlang-style actor system for Haskell?
18:50:31 <trap_exit> gcganelY: http://hackage.haskell.org/ c-f prolog, found none
18:50:35 <srhb> nobody__: Yes.
18:50:36 <Arch> Gonn go back to eso
18:50:46 <nobody__> srhb: k, thx
18:51:10 <trap_exit> hmm, there's only like 4
18:51:18 <trap_exit> less than # of scheme interpreters
18:51:31 <gcganley> trap_exit: hackage.haskell.org/packages/#cat:Logic
18:51:36 <carter> srhb: nobody__  .... it is?
18:51:39 <carter> its just the one people talk about
18:51:42 <carter> its a bit heavy weight
18:51:43 <ReinH> nobody__: It's the only extant one. I'm not sure how accepted it is...
18:51:49 <carter> yes that
18:51:56 <carter> ReinH: ... there are more in the works, just not public yet
18:51:57 <carter> :)
18:51:58 <nobody__> ReinH: carter: lol
18:52:02 <ReinH> carter: :)
18:52:06 <srhb> trap_exit: http://users.ugent.be/~tschrijv/MCP/
18:52:09 <gcganley> :)
18:52:12 <ReinH> I do distsys stuff with Haskell and I don't use it so...
18:52:20 <nobody__> good to know
18:52:28 <ReinH> I'm not saying it's bad... but it isn't compelling for me
18:52:31 <nobody__> ReinH: what do you use?
18:52:34 <srhb> It really is big, indeed.
18:52:52 <ReinH> nobody__: I basically lean on someone else's raft protocol and punt on most of the problems
18:52:57 <trap_exit> srhb: studying the slides; thanks
18:53:01 <ReinH> The first rule of distsys is: whenever possible, don't build one.
18:53:03 <srhb> trap_exit: Sure thing.
18:53:07 <carter> ReinH: yes
18:53:21 <carter> ReinH: the job i see to be starting soon has the biggest serveers possible
18:53:24 <carter> *seem
18:53:31 <carter> like 1/2tb ram, and all the cores
18:53:54 <ReinH> carter: yepppp
18:54:12 <carter> thats cheaper than writing  a Dist Sys thing
18:54:15 <gcganley> carter: wow, what are they running
18:54:22 <carter> gcganley: software
18:54:26 <gcganley> carter: sick
18:54:31 <ReinH> carter: At $OLDJOB we hired one of the senior operations people from Motorola. He was bored because his job had essentially become ordering another $500,000 server and plugging it in.
18:54:49 <carter> gcganley: you can get a server with those kinds of specs for < 20k
18:55:01 <carter> an engineer costs > 60k even if they're fresh out of college
18:55:17 <carter> dist sys stuff requries dedicated engineeirng
18:55:17 <gcganley> carter: why not link up 64 RPi's?
18:55:23 <carter> because that'd be slow
18:55:25 <carter> and sad
18:55:29 <srhb> trap_exit: You probably want to smack some logic stuff on top of that, but I believe those libraries are easier to google
18:56:00 <ReinH> haha
18:56:12 <ReinH> srhb: "pour some logic on it"?
18:56:20 <carter> gcganley: point being, a dis sys wiill need >=2-3 engineers
18:56:24 <nobody__> carter: please take the discussion about hardware to another room
18:56:24 <srhb> ReinH: YES! :-)
18:56:34 <carter> nobody__: totally on topic :)
18:56:45 <carter> sinc ei'll be running haskell in those boxes, as does ReinH
18:56:53 <carter> ReinH: have you had the mega core heap thrashing issues?
18:57:31 <carter> the GHC rts doesnt like having more than ~10-15 cores
18:57:34 <carter> currently
18:57:38 <kvanb> GC for half a terabyte
18:57:41 <kvanb> kind of horrifying
18:58:47 <gcganley> carter: why is that?
19:00:36 <nobody__> gcganley: core count was stored in 4 bits
19:00:44 <ReinH> carter: not me
19:00:45 <jmcarthur> carter: i disagree that a distsys is so hard or requires so many engineers
19:01:01 <ReinH> I suffer from a paucity of cores
19:01:30 <merijn> jmcarthur: I would agree that it doesn't require many engineers, but I strongly disagree that it's not hard >.>
19:01:35 <gcganley> ReinH: how many cores would you want?
19:01:49 <jmcarthur> carter: well, it's *hard*, but not any harder than a large scaled uniprocess system... maybe even a bit easier
19:01:51 <nobody__> jmcarthur: the only diff between SMP and clusters is the bus type
19:02:07 <kvanb> nobody__: are you trollinh
19:02:12 <kvanb> or is that legit
19:02:17 <kvanb> because if so, thats funny
19:02:53 <nobody__> kvanb: not trolling. Mark Russinovich of MS Azure said pretty much exactly this [paraphrased]
19:02:57 <merijn> kvanb: Well, it's pretty accurate for IO bound throughput systems
19:02:58 <srhb> Totally legit, but also similar to "the only difference between driving a car and riding a plane is flying"
19:03:00 <nobody__> [Architect of Azure, i.e.]
19:03:16 <merijn> For raw compute it's bullcrap, of course
19:03:49 <gcganley> nobody__: are there azure bindings for haskell?
19:03:54 <kvanb> I wish there was a library that gave you lego for dist systems
19:04:08 <ReinH> gcganley: 8 cores should be enough for anyone
19:04:10 <nobody__> gcganley: not sure but you can run Linux on Azure regardless
19:04:11 <kvanb> "data store"
19:04:16 <kvanb> "proxy forwarder"
19:05:24 <gcganley> ReinH: I have a AMD-8120 and it's pretty good i guess
19:05:34 <gcganley> s/a/an/g
19:11:57 <merijn> ReinH: So you wouldn't like one of those nice, fancy SPARC T5/M7 machines? :p
19:12:05 <merijn> 1024 hardware threads, baby!
19:13:14 <gcganley> marijn: i wouldnt know what to do with 1024 threads...
19:14:33 <torpet> So, given a matrix [[PosRat]], PosRat being: http://lpaste.net/7915553400006115328
19:14:42 <torpet> How do  I convert (Nat, Nat) to Octal Numbers?
19:15:05 <torpet> given I need to use the following datatype for octal numbers: http://lpaste.net/6557644333405700096
19:16:33 <srhb> torpet: What's the N in OktoZiffern? I seem to have lost some German these last years...
19:16:41 <torpet> Zero
19:16:44 <torpet> Null
19:16:45 <torpet> :D
19:16:46 <srhb> Duh, of course.
19:17:00 <torpet> Basically I am trying to converting a matrix with "PosRat" values to Oct
19:17:05 <pikaren> "The bottom line is that constructing and proving correct program is hard, be it in a declarative or imperative language."
19:17:27 <torpet> thats how the instance Show of my Matrix type looks: http://lpaste.net/5281635611625652224
19:20:04 <torpet> MY idea: converting the Nats to real Integers, get the Octals and then convert them back to OktoZiffern
19:21:12 <ReinH> merijn: :)
19:21:18 <srhb> torpet: Sure, you can do that. That should make step one pretty simple for you
19:22:07 <torpet> How would I map [0,1,2] to [N,E,Zw] though
19:22:47 <srhb> torpet: toO 0 = N; toO 1 = E; ... -- but that's probably not how you want to do it.
19:22:56 <torpet> lol ok
19:23:07 <torpet> well that was my idea but i was too embarassed to mention it
19:23:09 <srhb> Well, maybe it is. :-) At least it's easy to make that function.
19:27:58 <pikaren> zzz
19:28:00 <pikaren> haha
19:28:57 <gcganley> in scotty when using the script_ combinator im having trouble binding link_ and title_ to it. ill get an lpaste of my code up in a moment
19:29:11 <gcganley> using mappend btw
19:30:49 <lpaste> gcganley pasted “scotty trial” at http://lpaste.net/115545
19:31:17 <gcganley> actually this is more a lucid question
19:31:19 <gcganley> sorry
19:31:50 <lpaste> gcganley revised “scotty trial”: “lucid question” at http://lpaste.net/115545
19:31:50 <torpet> *Main> toOZ $ decToOct 10
19:31:50 <torpet> [E,Zw]
19:31:54 <torpet> srhb: yay
19:32:04 <srhb> torpet: :)
19:33:04 <gcganley> does chris done frequent this channel much?
19:33:47 <srhb> gcganley: as chrisdone yes, also #haskell-emacs and #emacs, I think
19:34:18 <gcganley> srhb: im using one of his libraries for templating html and im getting a funny type error
19:34:53 <srhb> gcganley: What's the error? You didn't include it in the paste, I think
19:38:22 <lpaste> gcganley pasted “lucid question” at http://lpaste.net/115547
19:38:27 <gcganley> there we go
19:38:53 <gcganley> its an instance error i just have no clue what it means
19:40:13 <srhb> gcganley: Something like _script takes a TermRaw arg result, not Term arg result
19:43:37 <pikaren> is learning lambda calculus mandatory
19:43:42 <Iceland_jack> pikaren: nope
19:44:03 <gcganley> pikaren: just knowing what a lambda expression is and how to use it. no formal education needed
19:44:22 <pikaren> an anonymous function?
19:44:27 <gcganley> yes
19:49:12 <johnw> lambda calculus is way more simple than it sounds, btw
19:50:00 <ion> Lambda calculus sounds not simple?
19:50:06 <johnw> it didn't to me
19:50:38 <Iceland_jack> You can be an excellent Haskell programmer and fail a simple course on the lambda calculus as a model of computation
19:58:34 <ParahSailin> let's say i have a csv file that i am parsing rows into a record type that i know at compile time, but the order of the columns is only known at runtime; i could do that by putting the columns in a vector, list etc as strings and build the record by indexing and parsing those strings
19:59:02 <ParahSailin> but in lisp you might compile at runtime a function for parsing a row
20:00:05 <ParahSailin> i was playing around with the hint package to do the similar sort of "eval" to generate a parsing function in haskell, but that's really hackish
20:00:51 <ParahSailin> i think theres some value in the lispy approach of easy runtime eval
20:01:23 <ParahSailin> it would be pretty cool if you could make AST for an attoparsec parser for instance and compile and use at runtime
20:01:38 <johnw> ParahSailin: can the column order change dynamically, or do you want to "bake it in" at compile time?
20:01:54 <johnw> i mean, basing your parser on an ordering of columns from a text file is pretty easy with template haskell
20:02:14 <johnw> but it won't regen the parser for each new set of niputs
20:02:46 <ReinH> ParahSailin: does the CSV file contain a header line?
20:03:45 <ParahSailin> johnw: column order is not known at compile time, so dynamic in that sense
20:03:47 <Hrothen> I feel like there was an easy way to compile single functions at runtime, isn't that what ghci does?
20:04:43 <ParahSailin> ReinH: thats one way i might want to reorder columns
20:05:16 <ParahSailin> Hrothen: the ghc api is exposed at runtime, which is what hint wraps
20:05:42 <Hrothen> Yeah... I found it right after I posted :P
20:06:38 <ParahSailin> but in hint i was playing around defining functions in strings
20:07:11 <ParahSailin> it would be better if i could do it TH style with the AST
20:07:43 <ParahSailin> the ghc api might expose that, havent gone into the documentation very deeply yet
20:08:48 <pavonia> ParahSailin: At what point do you know in what order you have to parse the columns?
20:09:38 <ParahSailin> pavonia: lets say im just doing it off of the column names in the first line of the file
20:10:18 <pavonia> You could use attoparsec's Monad instance for that
20:11:37 <pavonia> Ah wait, different result types are a problem then :S
20:22:17 <Hrothen> I feel like rewriting all this nested structure crap with lenses is just trading vertical noise for horizontal
20:24:20 <bitemyapp> Hrothen: depends on how much refactoring of commonalities you're doing.
20:24:37 <bitemyapp> Hrothen: if you're reaching into the same structure/subsets of structure, you make functions out of that and reuse the names
20:25:49 <johnw> lenses really start to pay off when you begin manipulating sub-elements of traversals, for example
20:26:41 <Hrothen> I'm pretty much just using them as getters/setters, the other uses are too arcane for a regular reader to scan
20:30:02 <johnw> as _only_ getters/setters for records, I don't use them so much, unless there is deep nesting
20:32:41 <Hrothen> well, I've got a nesting depth of 4, which is irritating, but not to the point where hand writing getter/setters is actually infeasible
20:34:21 <Welkin> Hrothen: you can always normalize your data
20:34:40 <Welkin> deeply nested data *could* be a sign that it is more complex than it should be
20:35:11 <Hrothen> it's an html layout tree so it's probably more complex than it needs to be by design
20:36:17 * hackagebot vector 0.10.12.2 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.10.12.2 (DanDoel)
20:42:53 <cschneid> What do people use for vim integration now? Syntax checking, hlint, sandbox compatible is what I want
20:43:09 <cschneid> type help would be nice too :) "what type is this" stuff
20:43:29 <AshyIsMe> ghc-mod and syntastic
20:44:35 <cschneid> AshyIsMe: mind gisting me the relevant config section from your vimrc? pretty please? :)
20:47:10 <bananagram> that would be helpful to me too
20:47:26 <pikaren> does haskell make use of the fact that functional programs dont have to be executed in a fixed order
20:47:48 <Hrothen> basically every compiled language makes use of that
20:48:14 <pikaren> but imperative language has to be executed in a order, no?
20:48:24 <Hrothen> not in reality
20:48:30 <pikaren> how
20:48:43 <Hrothen> there have actually been some really nasty bugs over the years related to gcc reordering things
20:48:48 <simpson> pikaren: Side effect analysis.
20:48:59 <simpson> pikaren: Most languages define orders of externally-visible effects.
20:49:00 <piskrist> that's just optimization
20:49:41 <pikaren> so bottom down the order thing isn't that big of an advantage in haskell?
20:49:43 <piskrist> it's just that lazy evauated langs have this feature more visible
20:50:23 <Hrothen> it's an advantage in that haskell compilers can make more assumtptions than non-pure language compilers
20:50:50 <piskrist> it's just a part of what the lang offers
20:51:06 <Apocalisp> What's that principle that says that limiting the expressive power of programs increases the space of higher-order programs you can write that work on them?
20:51:19 <piskrist> eg. you can work with infite lists, but it's not that big a deal in practice
20:52:49 <pikaren> Hrothen, simpson: hmm got it thanks
20:52:55 <Hrothen> although, I think I remember reading somewhere that GHC doesn't actually take advantage of this as much as you'd think, because they're not really focusing heavily on code optimization ATM
20:53:06 <Apocalisp> or rather, the principle that a compiler can make more assumptions because the language is more constrained
20:53:35 * Apocalisp is not very articulate
20:53:46 <pikaren> so its just that the current implementation isn't that polished?
20:53:48 <piskrist> Apocalisp: ask rob pike, he knows all about restricting expressivity
20:54:52 <shachaf> piskrist: Is that really necessary?
20:56:14 <torpet> im having a custom datatype (Nat, Nat)
20:56:20 <pikaren> side effect - changes to variable made by expressions
20:56:29 <pikaren> is this a proper defintion
20:56:30 <torpet> i need to perform an operation on it with a function that already exists, but after that use a custom function on both (a, b)
20:56:34 <torpet> but i cannot use map
20:56:42 <Hrothen> pikaren: it's not so much that it's unpolished as that they don't really go past the medium-hanging fruit speedwise, in favor of implementing other stuff
20:56:46 <torpet> how would i solve that issue?
20:56:46 <piskrist> pikaren: no
20:57:26 <shachaf> torpet: Please describe the issue in more detail.
20:57:56 <torpet> shachaf: http://lpaste.net/258937865969336320
20:58:03 <torpet> mkCanPR works fine
20:58:09 <pikaren> piskrist: its come from a good book http://i.imgur.com/ABv3xtM.png
20:58:11 <torpet> but after that i still need to access  a and b which i cant
20:58:18 <shachaf> torpet: What's the custom data type here?
20:58:23 <Apocalisp> pikaren: A first approximation of "side effect" is that it's an effect of expression evaluation that violates referential transparency or breaks the substitution model
20:58:32 <noonan> is there an idiomatic Reader s a - > State s a, other than getting the state and sending it through runReader?
20:58:43 <shachaf> torpet: There's no function in base :: (a -> b) -> (a,a) -> (b,b)
20:59:03 <shachaf> torpet: There are various libraries that have it, such as bifunctors (by the name bimap).
20:59:07 <Iceland_jack> torpet: You can try: id *** id
20:59:10 <Iceland_jack> :t id *** id
20:59:10 <lambdabot> (a, c') -> (a, c')
20:59:13 <torpet> type PosRat (Nat, Nat)
20:59:22 <torpet> = (Nat, Nat)
20:59:28 <Iceland_jack> Sorry, some f not id
21:00:08 <Iceland_jack> :t (\f -> f *** f) :: (a -> b) -> (a,a) -> (b,b)
21:00:09 <lambdabot> (a -> b) -> (a, a) -> (b, b)
21:01:34 * hackagebot jsontsv 0.1.2.0 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.2.0 (DanielChoi)
21:01:39 <Iceland_jack> You could also write 'join (***)' if you want to win golf contests
21:03:58 <red__> i do not understand stackage .. i am trying to get yesod up and running and it has a billion dependency issues to get a startup project going. it looks like the "projname.cabal" lists the dependencies but am i supposed to go and find these older/acceptable versions?
21:04:26 <shachaf> Maybe #yesod would know.
21:04:30 <torpet> Hm, actually I just had a better idea
21:04:30 <torpet> show (M mat) = show $ map (map mkCanPR) mat
21:04:30 <torpet> can i do something like "show (M mat) = show $ map (map mkCanPR . functionX) mat"
21:04:50 <red__> aha! didn't think to look for another channel . thanks
21:05:01 <torpet> ok that works: show (M mat) = show $ map (map toOktopaar) $ map (map mkCanPR) mat
21:21:34 * hackagebot jsontsv 0.1.3.0 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.3.0 (DanielChoi)
21:21:36 * hackagebot jsontsv 0.1.3.1 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.3.1 (DanielChoi)
21:27:13 <torpet> whats the best way to compare two [[Integer]] lists?
21:27:37 <Iceland_jack> Compare for what? Ordering, equality, ...
21:28:13 <Iceland_jack> You can do an element-wise equality check:
21:28:14 <Iceland_jack> > [[1,2,3], [4]] == [[1,2,3], [4]]
21:28:15 <lambdabot>  True
21:29:21 <torpet> Yeah thats what I wanna do
21:29:30 <redtricycle> I'm trying to run xmonad in a sandbox, but and getting errors about it not finding the right directories
21:29:31 <Iceland_jack> Okay :)
21:29:35 <torpet> But how can I do that via functions?
21:29:37 <redtricycle> I am assuming it's looking in ~/.cabal or somesuch...
21:30:04 <redtricycle> https://www.haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#Installing_xmonad_in_a_sandbox says to set GHC_PACKAGE_PATH to /path/to/ghc/db
21:30:13 <redtricycle> but this doesnt exist in .cabal-sandbox
21:30:29 <redtricycle> "ghc: can't find package database at ~/.cabal-sandbox/packages"
21:30:32 <redtricycle> Any tips?
21:30:51 <torpet> func [(x:xs)]?
21:31:29 <simpson> torpet: Why not use (==)?
21:31:35 * hackagebot tasty-hspec 1.1 - Hspec support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hspec-1.1 (mitchellwrosen)
21:31:39 <torpet> I need to use my own comparing function
21:32:23 <simpson> So what's your signature like? [[Integer]] -> [[Integer]] -> Bool?
21:32:37 <torpet> something like that yeah
21:32:40 <torpet> i could use zipwith
21:32:46 <torpet> with my comparing function
21:33:08 <Iceland_jack> torpet: Is the comparison function 'a -> a -> Ordering'
21:33:09 <simpson> torpet: There is https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#g:24
21:33:32 <simpson> But I don't see (==) itself in there. Hm.
21:34:59 <torpet> I think I found out how im gonna do it
21:35:34 <Hrothen> length filter (==EQ) $ zipWith myComparator l1 l2 == 0 ?
21:36:43 <Iceland_jack> Hrothen: You'd rather use 'all'
21:37:00 <Iceland_jack> > all (== EQ) [EQ, EQ, LT, EQ]
21:37:01 <lambdabot>  False
21:37:03 <Iceland_jack> > all (== EQ) [EQ, EQ, EQ,EQ, EQ]
21:37:04 <lambdabot>  True
21:37:08 <Iceland_jack> > all (== EQ) [EQ, EQ, EQ, EQ, EQ]
21:37:10 <lambdabot>  True
21:37:16 <Hrothen> yeah
21:38:35 <torpet> that looks cool
21:38:42 <torpet> although how do i enter the "second" level of the array
21:38:45 <torpet> thats my problem
21:41:16 <Hrothen> torpet: you mean you have lists of lists?
21:41:22 <torpet> exactly
21:42:03 <Hafydd> all (all (== EQ)), presumably.
21:42:13 <torpet> hm that sounds pretty nitfy
21:42:16 <torpet> let me check
21:42:34 <Hrothen> compList f = all (==EQ) . zipWith f and then compNested = compList $ compList (==)
21:43:49 <Hrothen> wait, that won't work because it returns a Bool on the inner call
21:44:50 <Hrothen> compNested = and . zipWith compList (==)
21:45:25 <Hrothen> I think
21:47:24 <pikaren> how functional is python
21:47:52 <simpson> pikaren: Yes.
21:47:54 <sujeet> not purely
21:47:58 <shachaf> pikaren: Please don't try to start arguments in here.
21:48:02 <sujeet> but functions are 1st class
21:48:10 <simpson> pikaren: But you should probably go to #python to talk about Python.
21:48:27 <shachaf> Python is generally off topic, though if you have a specific question that's sort of Haskell-related and not likely to start arguments you could ask it in here.
21:48:31 <shachaf> But not something like that.
21:48:32 <pikaren> oh sorry didnt mean it
21:51:35 * hackagebot dbus 0.10.9 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.9 (JohnMillikin)
21:55:39 <pavonia> I'm trying to build the curl package using MinGW. However, it keeps telling me about "curl libraries not found" though I added --extra-include/lib-dirs to cabal configure. Any ideas why this is happening?
21:56:38 <pavonia> For the logs I can see that curl/curl.h is not found
21:57:15 <pavonia> *From
21:57:48 <catsup> what was your exact extra-include argumen?
21:58:08 <torpet> hm
21:58:16 <torpet> Hrothen:
21:58:18 <pavonia> catsup: /d/dev/curl-7.39.0-devel-mingw32/include
21:58:20 <torpet> Hrothen: http://lpaste.net/2925492011320475648
21:58:29 <torpet> The brackets are not redundant though
21:58:38 <catsup> pavonia: and /d/dev/curl-7.39.0-devel-mingw32/include/curl/curl.h exists?
21:58:46 <pavonia> Yes
21:59:14 <catsup> :/
22:01:44 <Hrothen> torpet: shouldn't that be all (==True) $ zipwith eqPR x y ?
22:02:07 <torpet> is that not what it is?
22:02:16 <Hrothen> you left out ($)
22:04:53 <dibblego> uncurry eqPR `all` zip x y
22:06:02 <Hrothen> dibblego: but eventually you reach a pint where it takes enough extra time to understand that the additional brevity is useless
22:06:27 <Hrothen> that is a remarkably appropriate typo
22:06:31 <dibblego> I have no idea what you just said.
22:07:47 <Hrothen> your suggestion is shorter but for a lot of people has enough additional mental overhead that it actually takes longer to parse
22:07:47 <octalsrc> Hrothen: :D
22:08:17 <torpet> Hrothen: doesnt work with $
22:08:19 <torpet> for some reason :/
22:08:20 <dibblego> hmm yeah no, I'm out.
22:08:25 <torpet> i have been coding haskell for 2-3 months now
22:08:38 <torpet> but sometimes whats going on with brackets, $ and . is still beyond me
22:08:47 <torpet> long live lpaste and its hints
22:08:49 <torpet> :D
22:12:03 <Hijiri> Is there a base library function that will round something to the nearest multiple of a specific value?
22:13:27 <davean> Hijiri: are you talking like subtracing the mod?
22:14:01 <shachaf> davean: That's more like floor than round.
22:14:30 <davean> shachaf: Which kinda why I'm asking - I don't know what they want from that description.
22:14:49 <shachaf> The answer is no at any rate, in base. As far as I know.
22:15:07 <Hijiri> floor is good enough for me
22:15:18 <Hijiri> if there isn't something that just goes to the nearest
22:15:27 <Hijiri> thanks davean, shachaf
22:16:31 <Hrothen> torpet: that's weird, it won't compile for me without the $
22:16:52 <torpet> i used brackets
22:17:07 <Hrothen> torpet: also, you need pattern matches for when the lists aren't the same size
22:17:43 <torpet> they are
22:17:44 <torpet> :D
22:17:50 <torpet> (M mat1) == (M mat2) = (length mat1 == length mat2) && ( (map length mat1)!!0 == (map length mat2)!!0 ) && eqMVal mat1 mat2
22:18:01 <torpet> but thanks for pointing it out, appreciate it
22:31:37 * hackagebot statsd 0.1 - StatsD API.  http://hackage.haskell.org/package/statsd-0.1 (mitchellwrosen)
22:36:37 * hackagebot statsd 0.1.0.1 - StatsD API.  http://hackage.haskell.org/package/statsd-0.1.0.1 (mitchellwrosen)
22:38:31 <gfixler> Prelude> ["a","b","c"]
22:38:36 <gfixler> *** Exception: getCurrentDirectory: does not exist (No such file or directory)
22:38:49 <gfixler> Anyone know what's going on here?
22:39:43 <gfixler> oh, nevermind - ghci didn't like that the current directory disappeared
22:39:55 <gfixler> every command was failing
22:59:02 <fread2282> how can I get GHC.Generics to optimize away? just throw INLINE pragmas everywhere?
23:01:03 <red_> stackage says i can download their cabal.config file and put it in my project directory. where do i put it if i want it to be global? ~?
23:01:27 * red_ not understanding stackage or cabal
23:05:31 <jle`> sometimes i feel like there should be a Show instance for Const
23:05:33 <jle`> is that just me
23:06:38 * hackagebot crypto-pubkey 0.2.5 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.2.5 (VincentHanquez)
23:07:13 <pavonia> Can anyone make sense of this cabal error message? http://lpaste.net/115551
23:10:00 <pavonia> The package seems to build fine but the registration fails for some reason
23:22:31 <torpet> could someone help me out here? http://lpaste.net/1470970528729661440
23:22:46 <torpet> https://www.dropbox.com/s/on27n5re3msu48z/Screenshot%202014-12-03%2008.20.23.png?dl=0
23:23:04 <torpet> for some reason i can absolutely not find out why PosRat is being found here instead of [Skalar]
23:23:18 <torpet> Skalar is just a typedef for PosRat
23:23:30 <dmj`> :t zipWith
23:23:31 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
23:23:38 <dmj`> what is the type of plusPR ?
23:24:09 <torpet> plusPR :: PosRat -> PosRat -> PosRat
23:25:47 <torpet> fyi: http://lpaste.net/316028946384683008
23:25:59 <Welkin> :t plusPR
23:26:00 <lambdabot> Not in scope: ‘plusPR’
23:26:13 <dmj`> torpet: is (Nat, Nat) PosRat?
23:26:23 <dmj`> oh
23:26:36 <Welkin> haha
23:26:40 <torpet> yeah
23:27:38 <dmj`> torpet: oh, x and y need to be lists
23:28:08 <dmj`> :t zipWith (+)
23:28:09 <lambdabot> Num c => [c] -> [c] -> [c]
23:28:23 <dmj`> torpet: in this part of the code
23:28:25 <dmj`> (zipWith plusPR x y
23:28:30 <dmj`> x and y are of type a not [a]
23:28:53 <torpet> they are not lists?
23:29:13 <dmj`> torpet: they are the head of your lists
23:29:15 <dmj`> (M (x:xs)) (M (y:ys))
23:29:22 <dmj`> you're pattern matching them out of the list
23:29:27 <torpet> nope because im working on lists of lists
23:29:28 <torpet> :D
23:29:29 <torpet> http://lpaste.net/2470094043355283456
23:29:34 <torpet> this code works flawlessly
23:29:39 <dmj`> the thick plottens
23:29:39 <torpet> whereas the one posted above does not
23:30:13 <torpet> (x:xs) = [[Skslar]]
23:30:23 <torpet> So x must be [Skalar] := [PosRat] no?
23:30:33 <dmj`> you're trying to (++) a [a] with a [[a]]
23:30:50 <dmj`> :t (++)
23:30:51 <lambdabot> [a] -> [a] -> [a]
23:31:41 <torpet> no zipWith [a] with [a]
23:31:47 <dmj`> zipWith is fine
23:31:55 <dmj`> what does addMatrics return
23:32:03 <dmj`> it returns a [[a]]
23:32:21 <dmj`> I would try to substitute (++) for (:)
23:32:24 <dmj`> :t (:)
23:32:25 <lambdabot> a -> [a] -> [a]
23:32:43 <torpet> oh you are right im an idiot
23:32:43 <torpet> ^^
23:32:52 <dmj`> torpet: shame on you !
23:33:00 <dmj`> torpet: for calling yourself and idiot
23:33:02 <dmj`> an*
23:33:16 <dmj`> I can't even spell and, that's how dumb I am :P
23:33:19 <dmj`> an*
23:33:20 <torpet> :D
23:33:23 <dmj`> lolol screwed up again
23:33:29 <torpet> hm but how does : concat lists?
23:33:36 <wei2912> if you were really an idiot, you'd have said "zipWiT?????????????????????????????????????"
23:33:44 <wei2912> wut is dat
23:33:50 <wei2912> etc,
23:34:04 <Iceland_jack> torpet: These two things are the same:
23:34:05 <Iceland_jack>     [a] ++ xs
23:34:05 <Iceland_jack>     a : xs
23:34:47 <wei2912> Iceland_jack: is prepending more efficient than conctenation?
23:34:47 <torpet> oh right
23:34:55 <wei2912> concatenation*
23:35:28 <dmj`> yes
23:35:29 <Iceland_jack> wei2912: (:) is a data constructor so that not really a computation
23:35:33 <Welkin> for a list, yes
23:35:48 <wei2912> Iceland_jack: ah, okay
23:35:50 <dmj`> (++) is linear
23:35:51 <Welkin> if the structure has constant time access, then no
23:36:04 <Welkin> so for a vector/array/sequence, they are the same
23:36:19 <Welkin> for al ist, Cons is much more efficient
23:36:22 <Welkin> a list*
23:36:24 <dmj`> torpet: did that work?
23:36:29 <Iceland_jack> wei2912: Just like 'Just' doesn't perform any computation when you write 'Just False'
23:36:33 <torpet> of course it did :D
23:36:36 <torpet> thank you
23:36:42 <torpet> and i understand why
23:36:56 <Iceland_jack> torpet: Good :)
23:37:30 <dmj`> yay :)
23:37:43 <Iceland_jack> Just to clarify how (++) performs a computation, when you have "[a] ++ xs" GHC needs to evaluate the following steps:
23:37:43 <Iceland_jack>       [a] ++ xs
23:37:43 <Iceland_jack>     = a : ([] ++ xs)
23:37:43 <Iceland_jack>     = a : xs
23:37:56 <Iceland_jack> Approximately of course
23:39:48 <dmj`> @src (++)
23:39:48 <lambdabot> []     ++ ys = ys
23:39:48 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
23:39:48 <lambdabot> -- OR
23:39:48 <lambdabot> xs ++ ys = foldr (:) ys xs
23:40:06 <dmj`> lambdabot alternative defintions ay
23:40:17 <Iceland_jack> You can see that both of those steps follow from the definition of (++), keeping in mind that [a] is the same as (a:[])
23:40:24 <wei2912> ah, that explains
23:41:56 <dmj`> Iceland_jack: foldr (:) ys xs, seems like a lot of redundant work. If only we could just append the tail pointer of xs to the head pointer of ys
23:42:37 <Iceland_jack> That's true, then it could be done in constant time
23:42:52 <Welkin> a circular list
23:43:18 <Welkin> how would you implement a circular list in haskell?
23:43:43 <Iceland_jack> Welkin: Depending on how you wish to use it the easiest way is to use lazy
23:43:45 <Iceland_jack> *laziness
23:47:38 <dmj`> Welkin: maybe a Circular a = [a] [a], and then a custom Enum that cycles through keeps cycling through each list.
23:47:54 <dmj`> keeps cycling*
23:49:59 <jle`> you'd still need to make a complete copy of the first list though
23:50:06 <jle`> with (++)
23:50:20 <jle`> you can't avoid it
23:51:02 <dmj`> @def cyclic = fix ([0,1] ++)
23:51:04 <lambdabot>  Defined.
23:51:07 <dmj`> take 10 cyclic
23:51:13 <dmj`> > take 10 cyclic
23:51:14 <lambdabot>  [0,1,0,1,0,1,0,1,0,1]
23:51:43 <dmj`> how do you append to a cyclic list? How do you jump on a moving merry go round?
23:51:46 <Iceland_jack> You can also define cyclic as 'cyclic = cycle [0,1]'
23:52:08 <wei2912> > 2 : cyclic
23:52:10 <lambdabot>  [2,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
23:52:14 <dmj`> Iceland_jack: yes, more elegant
23:53:00 <dmj`> wei2912: but the two doesn't keep cycling
23:53:11 <wei2912> dmj`: i was kidding
23:53:47 <wei2912> and that's prepending, not appending
23:54:27 <Iceland_jack> dmj`: You don't want to use them the nearly as often in Haskell as you might in other languages, but there is a package for what you're asking:
23:54:30 <Iceland_jack> @hackage data-clist
23:54:30 <lambdabot> http://hackage.haskell.org/package/data-clist
23:55:06 <Iceland_jack> Latest version uploaded today :)
23:56:22 <dmj`> Iceland_jack: very cool, data X = X [a] a [a] is a zipper isn't it?
23:56:23 <Procian> Not hugely different to the data-structure dmj` proposed above. It's a zipper.
23:56:32 <Iceland_jack> Yes
23:56:59 <Procian> I've definitely implemented this before, thinking it was useful for whatever I was working on.
23:57:27 <pavonia> Hasn't anyone an idea why this could be happening? http://lpaste.net/115551
23:57:34 <Iceland_jack> It is sometimes useful so it's good to know that a library implemention exists
23:57:52 <Dia1337> why should i use haskell?
23:57:54 <dmj`> What a great data structure and a novel use.
23:58:16 <Iceland_jack> Dia1337: Maybe you shouldn't :)
23:58:26 <dmj`> pavonia: you're on windows aren't you
23:58:31 <simpson> Dia1337: No particular reason. It's a language for building stuff. Maybe you want to build stuff.
23:58:36 <pavonia> dmj`: Yeah :(
23:58:54 <Dia1337> I dunno, can you work with CUDA?
23:59:32 <simpson> I typed in "haskell cuda" and got several good search results.
23:59:52 <pavonia> If I create the dir by hand the "doesn't exist or isn't a directory" message disappears, but it still can't find the build Haskell files
