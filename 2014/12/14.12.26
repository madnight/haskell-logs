00:00:23 <agibiansky> Alright, I need to sleep, it's 3 AM here
00:00:25 <agibiansky> good luck ij
00:00:49 <ij> Night night, agibiansky!
00:03:57 <neuroserpens> :wq
00:04:06 <neuroserpens> wtf
00:04:13 <neuroserpens> I need to sleep lmao
00:04:53 <ij> how much haskell have you written since the last time here?
00:06:11 <neuroserpens> I'm a noob. First 3 chapters of LYAH and first 2 chapters of RWH.
00:07:03 <neuroserpens> The thing is I was almost falling asleep and for some reason I thought weechat was vim.
00:08:11 <jle`> but why would you want to close us ;_;
00:08:15 <jle`> at least you save us before.
00:08:22 <neuroserpens> yea lol
00:09:21 * neuroserpens eats raisins to stay awake a bit more.
00:09:56 <jle`> you know, sleep isn't that bad :P
00:10:47 <neuroserpens> jle`: I know. I'll just finish some stuff.
00:12:02 <neuroserpens> jle`: Where are you from?
00:12:54 <jle`> california
00:13:34 <neuroserpens> jle`: Let's seeeee umm... It is currently 2:12 a.m. for you.
00:13:42 <jle`> not quite, but close :)
00:13:46 <neuroserpens> :p
00:13:54 <neuroserpens> 1:12?
00:14:14 <jle`> warmer.
00:14:30 * hackagebot pretty 1.1.2.0 - Pretty-printing library  http://hackage.haskell.org/package/pretty-1.1.2.0 (DavidTerei)
00:14:32 <neuroserpens> lol wtf you can't be that far west
00:14:36 <neuroserpens> 0:12???
00:14:49 <neuroserpens> 13 now lol
00:15:20 <neuroserpens> well... it is now 6:13 am for me.
00:15:24 * neuroserpens 's sleepy time
00:17:02 <jle`> yeah, my advice would be to sleep :)  but ianad of course.
00:18:29 <neuroserpens> jle`: I always sleep in the mornings. It feels better for me. I've been doing it for 9 ~ 10 years now.
00:19:33 <wei2912> :P
00:19:34 <neuroserpens> I HAVE TO HIDE FROM THE LIGHT AAAAARGH HERE COMES THE SUN
00:19:40 <jle`> can't argue with that body of evidence
00:20:02 <wei2912> wait, there's evidence that sleeping in the mornings is better?
00:20:02 <solatis> :)
00:20:17 <neuroserpens> wei2912: I have no idea lol. I just know I love it.
00:20:17 <solatis> yeah, this morning my iphone was overheating at 9am because it's too hot here
00:20:33 <solatis> does that count as third world problems? :)
00:20:40 <solatis> i had to put my iphone in the fridge in order for my personal hotspot to keep working
00:20:45 <neuroserpens> solatis No clue.
00:22:08 <jle`> wei2912: the evidence is that it's been 9/10 years and neuroserpens has yet to die
00:22:26 <neuroserpens> jle`: lmao
00:22:49 <neuroserpens> jle`: I don't see why I'd die from sleeping the normal 6~8 hours in another time of the day.
00:23:02 <wei2912> lol
00:23:24 <wei2912> neuroserpens: do you have https://en.wikipedia.org/wiki/Delayed_sleep_phase_disorder? :P
00:23:45 <solatis> i know many hackers that like to work during the night
00:24:04 <neuroserpens> But I have to say. In Brazil I have always felt the best temperature for sleeping is in the mornings.
00:24:06 <neuroserpens> So there's also that.
00:24:06 <solatis> personally i am most productive when i get up at 5AM, so i'm about the exact opposite
00:24:57 <neuroserpens> wei2912: I'll try to read it all lol
00:27:31 <neuroserpens> wei2912: Wow. It all fits.
00:28:20 <neuroserpens> wei2912: I also have a little bit of both adhd and depression lol :C
00:28:38 <neuroserpens> I wouldn't want to treat it though. I can never imagine myself sleeping during the nights
00:28:41 <neuroserpens> so FAKK it
00:28:52 <neuroserpens> xD
00:29:38 <gremble> o/
00:29:55 <neuroserpens>  /o
00:30:04 <neuroserpens> o\
00:30:08 <neuroserpens> What's the next one?
00:30:46 <gremble> I think you missed \o
00:30:53 <Geekingfrog> Is there a way to get at the same time the maximum in Ord a => [a] and its index? that is: ??? [10, 15, 11] returns (15, 1) ?
00:31:05 <neuroserpens> I didn't miss it dammit. It is the next one xD
00:31:13 <neuroserpens> You got the right answer.
00:31:22 <neuroserpens> You won the webernets
00:36:04 <lpaste> solatis pasted ‚ÄúWhich style is better?‚Äù at http://lpaste.net/117262
00:36:23 <solatis> ^^ is it acceptable behaviour to re-use variables outside of their 'strict' scope ?
00:36:32 <solatis> i'm not sure which style is better to be honest...
00:37:27 <solatis> the first one is less code, the second one makes it easier to see which function uses which variables
00:37:42 <gremble> Geekingfrog: Why don't you order the list with maximum and then return the head?
00:38:09 <neuroserpens> Good morning. Bye.
00:38:52 <Geekingfrog> gremble, I'm actually only concerned about the index of the maximum in the original list
00:39:06 <Geekingfrog> I don't really care about its value
00:39:36 <matematikaadit> > maximum  $ [10, 15, 11] `zip` [0..]
00:39:37 <lambdabot>  (15,1)
00:39:53 <matematikaadit> Geekingfrog: ^
00:40:43 <Geekingfrog> o‘ cool thanks matematikaadit
00:41:09 <matematikaadit> Geekingfrog: but it will choose the highest index though
00:41:20 <matematikaadit> > maximum  $ [10, 15, 11, 15] `zip` [0..]
00:41:21 <lambdabot>  (15,3)
00:41:32 <Geekingfrog> I'm cool with that
00:47:33 <gremble> length has a type declaration of length :: [a] -> Int. Does that mean lists longer than 2147483647 will cause length to overflow?
00:48:39 <MP2E> If you are on a 32-bit system, yes, if you are on a 64-bit system, it'll go up to 2^64-1 before overflow
00:49:07 <MP2E> note that there is genericLength
00:49:09 <matematikaadit> gremble: If you need something larger there are genericLength in Data.List
00:49:21 <gremble> Ah ok
01:38:21 <solatis> if i want to execute a (blocking) function in the background, and at a later stage wait for its return value, what are my options ? the future monad seems to be best suitable for this ?
01:38:48 <solatis> (but that hasn't been updated since 2009.. :/)
01:42:46 <solatis> hmmm, or wait... MVar's *are* futures
01:42:50 <solatis> (promises)
01:42:52 <solatis> right?
01:43:13 <solatis> or at least a superset of them (they are more flexible)
01:43:53 <pavonia> They are like IORefs but thread-safe and blocking
01:44:01 <solatis> right
01:44:27 <xinming> Hi, Just curious, No debate on init system of debian. Will systemd still be default init system for future debian releases?
01:44:48 <xinming> oops
01:44:49 <pavonia> solatis: You could fork a new thread and write the result into an MVar, and then later read that MVar
01:44:51 <xinming> sorry, wrong channel. >_<
01:44:59 <solatis> i'll just lay out my problem: i'm implementing a function that connects to a remote host -- this host might be unavailable, and i want it to retry until it is available, and upon succesful connection, fulfill some promise
01:45:18 <solatis> i think returning an MVar, and internally forkIO is a good aproach to this problem?
01:45:49 <solatis> pavonia: yeah that seems like a good aproach
01:47:02 <solatis> otoh, what about monad-par ?
01:47:06 <solatis> f <- spawnP (myBlockingFunc)
01:47:11 <solatis> r <- get f
01:47:50 <solatis> gah too many choices.. :/
01:51:20 <solatis> i guess i'll just implement a regular blocking version of my function, and an async variant that returns an MVar
01:52:34 <nkar> solatis: make something that works and change later if needed
01:53:04 <nkar> premature optimization and all that
01:59:18 <myanbar> Hello, I'm a beginner in Haskell and I had some question about foldl and foldr. To calculate the length of a list with foldl I write: len :: [a] -> Int            len lst = foldl (\count _ -> count + 1) 0 lst
01:59:27 <myanbar> len :: [a] -> Int
01:59:32 <myanbar> len lst = foldl (\count _ -> count + 1) 0 lst
01:59:39 <dgomez> Hello, can anyone help me to find the appropriate way to download all gtk libraries
01:59:54 <dgomez> https://gist.github.com/cartazio/1655271
02:00:09 <myanbar> However, for foldr I would switch the argument in the lambda to (\_ count -> count + 1) . Why is it that they differ?
02:00:21 <dgomez> Looked at this brew link cairo gettext fontconfig
02:00:40 <dgomez> but it won't retrieve anything
02:03:12 <jle`> myanbar: expand out the definitions of both, and you might be able to get some isnight :)
02:03:29 <jle`> on a sample l√≠t
02:03:32 <jle`> *list
02:03:43 <jle`> you'll see that the way they eventually get to the result is very different :)
02:03:59 <jle`> by expand out, i mean manually evaluate foldl, foldr, etc.
02:04:55 <jle`> there are actually some cases where just putting the "flipped" version will yield different results
02:06:12 <myanbar> with non associative functinos for example, right?
02:06:39 <jle`> hm
02:06:57 <jle`> ah, yeah. yes. but, i was thinking of something else :)
02:07:31 <jle`> > foldl (\c x -> c || x) False (repeat True)
02:07:36 <lambdabot>  mueval: ExitFailure 1
02:07:41 <myanbar> Is there a reason they flipped the arguments? Because it doesn't really add anything to the function as far as i know.
02:07:43 <jle`> ^ seeing if any of the elements are Tre
02:07:54 <jle`> > foldr (\x c -> x || c) False (repeat True)
02:07:55 <lambdabot>  True
02:07:58 <jle`> :O
02:08:44 <jle`> > let anyTrue1 = foldl (||) False in anyTrue1 (repeat True)
02:08:49 <lambdabot>  mueval: ExitFailure 1
02:08:54 <jle`> > let anyTrue2 = foldl (||) False in anyTrue2 (repeat True)
02:08:59 <lambdabot>  mueval: ExitFailure 1
02:09:00 <jle`> > let anyTrue2 = foldr (||) False in anyTrue2 (repeat True)
02:09:01 <lambdabot>  True
02:09:03 <jle`> oops
02:09:38 <jle`> if you tried doing what i said earlier and evaluating them out by hand, you'll see that foldl and foldr both lead to very very different evaluation strategies
02:09:55 <jle`> the strategy by which haskell evalutes the result
02:10:28 <jle`> while you could in theory simulate one with the other, it is more difficult to copy the others' evaluation strategies...and in one case it is even impossible
02:11:35 <myanbar> hm, ok
02:11:44 <myanbar> thank you for the help
02:11:53 <jle`> to really see what this actaully means, i don't think there is a better way than just getting out pen and paper
02:12:01 <jle`> and unfolding out the definitions by hand
02:12:06 <jle`> @src repeat
02:12:06 <lambdabot> repeat x = xs where xs = x : xs
02:12:09 <jle`> @src foldr
02:12:09 <lambdabot> foldr f z []     = z
02:12:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:12:54 <jle`> @src (||)
02:12:54 <lambdabot> True  || _ =  True
02:12:54 <lambdabot> False || x =  x
02:13:33 <jle`> foldr (||) False (repeat True) = foldr (||) False (True : repeat True) = True || (foldr (||) False (repeat True) = True
02:13:41 <jle`> @src foldr
02:13:42 <lambdabot> foldr f z []     = z
02:13:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:13:44 <jle`> @src foldl
02:13:44 <lambdabot> foldl f z []     = z
02:13:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:14:21 <BoR0> True || _ = True saved you there :P
02:14:38 <jle`> foldl (||) False (repeat True) = foldl (||) False (True : repeat True) = foldl (||) (False || True) (repeat True)
02:15:11 <jle`> = foldl (||) True (True : repeat True) = foldl (||) True (repeat True) = ...
02:15:16 <jle`> that one never ends
02:15:19 <jle`> :)
02:15:21 <jle`> BoR0: yup, that's the magic
02:16:27 <myanbar> one second
02:16:38 <myanbar> I'm wrapping my head around it
02:16:54 <jle`> btw, i'm using a more simple definiition of repeat
02:16:58 <jle`> repeat x = x : repeat x
02:21:34 <myanbar> and what would foldl' (||) False (repeat True) do ?
02:22:11 <myanbar> would it also never end?
02:25:07 <jle`> @src foldl'
02:25:08 <lambdabot> foldl' f a []     = a
02:25:08 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:26:22 <jle`> when reasoning about evaluation with 'seq', the trick is that `seq x y` = x if x is bottom (undefined, infinitely looping, error, etc.), and `seq x y` = y otherwise
02:26:38 <jle`> from there on you can do the same deal as you did with foldr, foldl :)
02:28:17 <jle`> i'll give you a hint and say that in this specific specific situation, seq x y = y for all occurences of seq you'll encounter. (as in, it evaluates to y)
02:28:46 <jle`> but feel free to manually evaluate it and check every time, if you want :)
02:45:49 <hamishmack> dgomez: I have added my recipe for installing Gtk+ on OS X to https://gist.github.com/cartazio/1655271
02:46:38 <hamishmack> dgomez: It might be worth trying if you get stuck with Brew
02:54:29 <hamishmack> I could not work out how to get GTK+3, WebKitGTK and Quartz support all working with brew.
02:54:55 <hamishmack> It is fairly easy to install them with MacPorts, but takes a long time to compile
02:55:20 <hamishmack> Rough instructions I added are here https://gist.github.com/cartazio/1655271#comment-1362188
03:21:50 <dgomez> I am not sure which would be more efficient to continue with GTK-OSX with Quartz OR Macports + ghcjs for the diagrams project that I want to start. DOes anybody have an opinion with working on either one?
03:23:32 <dgomez> I currently have quartz support but I am not sure how to integrate - https://wiki.gnome.org/Projects/GTK+/OSX/Integration
03:40:37 <phaazon> is there a tool to generate Haskell tags?
03:40:44 <phaazon> ghc-mod might do that, right?
03:41:30 <saep> phaazon: Do you mean something similar like ctags?
03:41:33 <bennofs> phaazon: there is hasktags
03:41:36 <phaazon> yeah
03:41:36 <bennofs> @hackage hasktags
03:41:36 <lambdabot> http://hackage.haskell.org/package/hasktags
03:41:40 <phaazon> thank you
03:41:43 <dgomez> Is there another channel where I should I be redirecting my questions?
03:41:50 <bennofs> ghci can also generate tags afaik
03:42:01 <phaazon> I hope atom will be able to read that
03:44:01 <kaiyin_> I am looking for a package that can do logistic regression and give back p values, any suggestions?
03:58:06 <McManiaC> http://puu.sh/dJY9b/5ebc1d7013.png what does the (~ (* -> *) b IO) in the instance definition mean?
03:59:05 <bennofs> McManiaC: a ~
03:59:20 <bennofs> McManiaC: sorry, pressed enter to eary
04:00:09 <bennofs> McManiaC: a ~ b is a constraint (constraints are things that may appear on the left side of =>, like Functor m) that says: "a and b must be the same type"
04:00:43 <bennofs> McManiaC: in this particular case, it means that the instance only works if b is IO
04:01:05 <McManiaC> is the ~ just in prefix notation?
04:01:09 <bennofs> yes
04:01:12 <McManiaC> how does that work with 3 parameterS?
04:02:04 <McManiaC> is it the same as (((* -> *) ~ b) IO) ?
04:02:14 <bennofs> McManiaC: well, ~ is polykinded. This means that in a ~ b, a and b don't have to be of kind * (kind * is the kind of the types that haskell values may have). The extra argument is the kind of the aarguments to ~
04:02:43 <bennofs> McManiaC: IO is of kind * -> *, because it takes one type of kind * as argument and then produces a type of kind *
04:03:49 <bennofs> :k (~)
04:03:50 <lambdabot> k -> k -> Constraint
04:04:30 <bennofs> Haddock displays the value of k also (if you look at the source of that instance, you will see that the source doesn't have that * -> * iirc)
04:04:55 <McManiaC> ooo
04:04:57 <McManiaC> okay
04:05:02 <McManiaC> that confused me
04:05:36 <McManiaC> ok yeah the source makes more sense
04:06:06 <bennofs> The haddock of polykinded things looks a bit confusing, I agree
04:35:24 <kaiyin_> http://lpaste.net/117267
04:35:52 <kaiyin_> Why can `fmap` be redefined and `==` can't?
04:36:13 <barrucadu> Because fmap is part of the Functor class
04:36:17 <barrucadu> == is part of the Eq class
04:37:36 <barrucadu> Also, that's not a valid fmap instance, as it breaks the property that fmap id = id
04:37:46 <barrucadu> Definition, not instance
04:39:14 <kaiyin_> What is an fmap instance? I thought it was a Functor instance.
04:39:54 <barrucadu> Yeah, sorry, I meant fmap definition
04:41:31 <kaiyin_> ok, I see, you mean fmap id Cjust 1 'a' == Cjust 2 'a'
04:41:50 <barrucadu> Yes
04:42:14 <kaiyin_> Thanks, barrucadu .
05:00:08 <BoR0> has anyone used scotty-session?
05:02:55 <besenwesen> say, i‚Äôve upgraded GHC, and now the packages installed via cabal-install don‚Äôt seem to work anymore. the upgrade-script suggested reinstalling. how is this best achieved? cabal-install world --reinstall?
05:03:12 <besenwesen> or can i just re-register the packages with GHC?
05:03:36 <CocoNuts89> hello all
05:09:42 * hackagebot wordpass 1.0.0.1 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-1.0.0.1 (MichalGajda)
05:09:44 * hackagebot json-autotype 0.2.5.2 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.2 (MichalGajda)
05:09:46 * hackagebot FenwickTree 0.1.2 - Data structure for fast query and update of cumulative sums  http://hackage.haskell.org/package/FenwickTree-0.1.2 (MichalGajda)
05:11:31 <srhb> coconnor: Hi.
05:11:54 <srhb> besenwesen: Reinstall just the packages you need, I'd say
05:12:40 <besenwesen> srhb, how come these have to be reinstalled, btw.? does this mean building them again? are libraries linked against a specific GHC version for the run-time?
05:13:06 <srhb> besenwesen: I don't know, to be honest.
05:13:13 <besenwesen> fair enough :) thanks
05:14:08 <srhb> But yes it does mean building them again. Maybe it's just superstition, but at least I know that that method works.
05:14:19 <srhb> And it seems the simplest (unless you're really interested in what goes on)
05:19:42 * hackagebot wordpass 1.0.0.2 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-1.0.0.2 (MichalGajda)
05:25:40 <BoR0> @pl \_ -> return x
05:25:40 <lambdabot> const (return x)
05:27:17 <Chath> I love you const
05:28:36 <besenwesen> don‚Äôt marry const, it‚Äôll never pay attention to you
05:39:38 <Chath> :(
05:42:15 <jiang42> :)
05:45:32 <dgomez> http://www.gtk.org/download/macos.php
05:49:55 <kaiyin_> How do you repeat previous command in the emacs haskell interpreter? I am looking for something similar to up and down keys in a bash session.
05:53:49 <bennofs> kaiyin_: does M-p and M-n work?
06:05:45 <indiagreen> kaiyin_: C-<up>/<down> work for me
06:20:37 <Intolerable> if i have a function f :: forall m n x. HasComponent (Labeled n x) m => Proxy n -> Collecting m x, does anyone know the right way for using someSymbolVal to get a function f' :: forall m n x. HasComponent (Labeled n x) m => String -> Collecting m x?
06:22:26 <shachaf> Hmm, someSymbolVal's API might be better in CPS form.
06:23:07 <shachaf> foo :: String -> (forall n. KnownSymbol n => Proxy n -> r) -> r
06:24:41 <Intolerable> yeah, that would be nice and simple
06:24:46 <shachaf> But your type seems kind of odd because n still exists.
06:26:37 <Intolerable> this is my current code: http://lpaste.net/117275
06:26:58 <Intolerable> i haven't used Proxy / TypeLits much
06:30:18 <kaiyin_> indiagreen, thanks!
06:32:05 <ddellacosta> is there a way to construct mappend for a tree?  i.e. I'm trying to grasp what an associative operation for a tree would be.
06:32:47 <t4nk480> Hey. Dumb question (I haven't used haskell for ages), what is the _ variable called in haskell?
06:33:15 <bennofs> t4nk480: wildcard? It's really just a throwaway variable that you can use if you don't need the value
06:33:29 <t4nk480> ok
06:38:51 <dgomez> extremely dumb question...add                     :: Integer -> Integer -> Integer
06:38:52 <dgomez> add x y                 =  x + y
06:38:55 <dgomez> is that a function?
06:39:04 <Intolerable> yes
06:39:14 <dgomez> and how would you red it explicitly?
06:39:29 <dgomez> bc i cant say that out loud...
06:39:48 <Intolerable> the function or the signature?
06:40:13 <dgomez> the function itself.
06:40:14 <Intolerable> "add has type integer to integer to integer"
06:40:24 <Intolerable> "add x y is x plus y"
06:40:44 <delphinas> confusing
06:40:52 <dgomez> oh wow.
06:41:07 <dgomez> well to me it looked foreign...
06:41:22 <srhb> dgomez: Well, we tend to think parens and commas are silly when defining functions
06:41:40 <srhb> dgomez: But perhaps (and you can write this, but its type is different) you would prefer add (x,y) = x + y
06:43:04 <dgomez> and such a curried function is just a different flavor of a Haskell funciton ?
06:43:24 <srhb> dgomez: Well instead of taking two arguments x and y, it takes one argument, a tuple (x,y)
06:44:02 <srhb> dgomez: So its type would change from Integer -> Integer -> Integer to (Integer, Integer) -> Integer
06:44:03 <dgomez> a tuple being explicitly defined by ( )
06:44:07 <srhb> Yes.
06:44:09 <dgomez> oh
06:44:37 <dgomez> can tuples have more than 2 arguments?
06:44:43 <srhb> dgomez: Yes.
06:45:10 <srhb> I don't recall the number of tuple types defined by default, but there are a lot, and if you run into the limit you're probably doing something wrong. :-)
06:46:36 <srhb> > (1,'a',"foo") :: (Int, Char, String)
06:46:37 <lambdabot>  (1,'a',"foo")
06:46:41 <srhb> etc.
06:47:30 <Intolerable> max tuple length is 62 iirc
06:47:41 <dgomez> lamdbabot is describing 3 different data types in his tuple?
06:47:53 <dgomez> got that.
06:48:10 <srhb> dgomez: Tuples are heterogenous. So that particularly type is a 3-tuple of Int, Char and String
06:49:38 <dgomez> (++)                    :: [a] -> [a] -> [a]
06:49:41 <dgomez> so this is..
06:49:45 <kaiyin_> Could anyone explain this a bit, I am very confused: http://lpaste.net/117282
06:49:45 <dgomez> tuple (++)
06:49:55 <dgomez> has  char a to a to a ?
06:49:57 <srhb> dgomez: No [a] is a list of elements of type a
06:50:01 <kaiyin_> What does <*> do exactly here?
06:50:01 <srhb> > [1,2,3]
06:50:02 <lambdabot>  [1,2,3]
06:50:20 <srhb> > [1,2,3] ++ [4,5,6]
06:50:21 <lambdabot>  [1,2,3,4,5,6]
06:51:12 <dgomez> what would you call tht operation <*>?
06:51:15 <srhb> kaiyin_: It's sort of composition, with (f <*> g) x being equal to f x (g x). What else is there to it?
06:51:41 <bennofs> kaiyin_: f :: r -> (a -> b) and g :: r -> a. Then f <*> g :: r -> b   is  just the function \x -> f x (g x)
06:52:41 <srhb> dgomez: Sometimes we call it ap.
06:52:44 <Intolerable> dgomez: <*> is usually ap
06:53:20 <Intolerable> there's a function ap too, which is the same but less general
06:53:22 <Intolerable> :t ap
06:53:23 <lambdabot> Monad m => m (a -> b) -> m a -> m b
06:53:23 <kaiyin_> Cool.  I got it. Why is it called ap?
06:53:43 <srhb> because it "applies" a function in a context to a value in a context. Ish.
06:53:51 <srhb> (I think)
06:53:51 <Intolerable> it applies a function that's inside a monad / applicative
06:54:25 <srhb> > Just (+1) <*> Just 2
06:54:26 <lambdabot>  Just 3
06:54:33 <dgomez> So ap allows for two seperate {monads?} to be joined together?
06:54:37 <srhb> No.
06:54:43 <srhb> The m or f stays the same
06:55:14 <srhb> In this case, I used <*> :: Maybe (a -> b) -> Maybe a -> Maybe b
06:55:18 <srhb> Where a ~ b ~ Int
06:55:19 <bennofs> :t liftA2 ($)
06:55:20 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
06:56:31 <dgomez> keyword Applicative instigates what? a monad f?
06:57:08 <srhb> dgomez: Applicative is somewhere between Functor and Monad. Every Monad can be made an Applicative, but not vice versa.
06:57:32 <simukis_> dgomez: Applicative as a category like Monad is.
06:57:45 <simukis_> different kind of category though.
06:58:48 <kaiyin_> >:t  (\x -> (\y -> x + y))
06:59:01 <srhb> kaiyin_: You need a space after >
06:59:08 <kaiyin_> > :t  (\x -> (\y -> x + y))
06:59:10 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
06:59:19 <kaiyin_> :t  (\x -> (\y -> x + y))
06:59:20 <lambdabot> Num a => a -> a -> a
06:59:20 <srhb> Er
06:59:21 <srhb> And that's just :t
06:59:21 <srhb> :-)
06:59:39 <dgomez> :t?
06:59:51 <srhb> dgomez: type of ...
07:00:18 <dgomez> kaiyin_: > :t  (\x -> (\y -> x + y))
07:00:35 <dgomez> the expression within parenthesis is considered a tuple?
07:00:44 <srhb> dgomez: No, it's a lambda function
07:00:47 <srhb> Which returns a lambda function
07:00:54 <srhb> dgomez: It's equivalent to add x y = x + y
07:01:12 <kaiyin_> :t  (\x -> (\y -> x + y)) <*> (+3)
07:01:13 <lambdabot> Num a => a -> a
07:01:56 <bennofs> > ((\x -> (\y -> x + y)) <*> (+3)) 5
07:01:58 <lambdabot>  13
07:02:01 <bennofs> > ((\x -> (\y -> x + y)) <*> (+3)) a
07:02:03 <lambdabot>  a + (a + 3)
07:02:12 <dgomez> kaiyin_: :t  (\x -> (\y -> x + y)) <*> (+3)  SO the output would be x + y + 3?
07:02:31 <dgomez> I would like to know how this lambda function is read
07:02:34 <kaiyin_> dgomez, yeah, I think so
07:02:39 <dgomez> what do the backward slashes signify
07:02:40 <dgomez> ?
07:02:43 <Intolerable> a lambda
07:02:58 <Intolerable> the actual lambda symbol is an alphanumeric unicode identifier
07:03:10 <Intolerable> and using ascii the best analog is a \
07:03:34 <vinit-ivar> ,\
07:03:36 <dgomez> ahh.
07:03:42 <Intolerable> i'd read that "x to y to x plus y"
07:04:23 <dgomez> mmmk seems simple enough atm
07:04:26 <srhb> dgomez: No, the function instance of Applicative is (f <*> g) x = f x (g x), so it's x + (x + 3)
07:04:35 <srhb> not x + (y + 3)
07:04:47 <bennofs> > ((\x -> (\y -> x + y)) <*> (+3)) x
07:04:49 <lambdabot>  x + (x + 3)
07:04:59 <srhb> Right.
07:05:08 <Intolerable> is there an extension that allows the unicode Œª to be used as the lambda symbol?
07:05:09 <srhb> I forget about using symbols in lambdabot.
07:05:20 <bennofs> Intolerable: UnicodeSyntax probably
07:05:54 <srhb> Why is haskell.org so slow these days?
07:05:58 <Intolerable> > let Œª = 5 in Œª + (5 :: Int)
07:05:59 <lambdabot>  10
07:06:19 <Intolerable> unicodesyntax doesn't allow lambdas since it's a valid lowercase identifier
07:06:41 <Intolerable> iirc there's another flag u can use tho
07:06:52 <kaiyin_> srhb, I was also wondering.
07:07:04 <dgomez> id rather stick to ascii for the meantime
07:07:09 <kaiyin_> it takes ages to open any page.
07:07:16 <dgomez> but flag refers to what?
07:07:27 <dgomez> Intolerable: > let Œª = 5 in Œª + (5 :: Int)
07:08:27 <srhb> dgomez: As in you can pass certain flags to the compiler to make it change behaviour in some cases.
07:08:39 <srhb> I don't believe there is a flag for lambda as a substitute for \ though
07:08:44 <Intolerable> when ur running ghc u can use flags like -XUnicodeSyntax to allow unicode symbols instead of stuff like (->) (=>)
07:09:03 <dgomez> I see. But I am not too certain what (\) lambda is doing when applied to the function
07:09:13 <srhb> dgomez: Applied to the function?
07:09:21 <Intolerable> srhb: nope, there isn't, the proposal was closed
07:09:30 <Intolerable> probably for the best
07:09:36 <srhb> dgomez: (\x y -> x + y) is a function just like add x y = x + y
07:09:49 <srhb> dgomez: It's just a way of defining anonymous (nameless, lambda) functions
07:10:19 <dgomez> I'm sorry I am simultaneously working on getting up with some environment issues I am having.
07:10:46 <srhb> dgomez: Well, all these questions are easily answered by any of the introductory texts anyway. :)
07:11:24 <dgomez> ok srhb...
07:11:59 --- mode: wilhelm.freenode.net set +o ChanServ
07:12:02 <kaiyin_> > (\x y -> show $ x + y) <*> (*3)
07:12:03 <lambdabot>  <Integer -> [Char]>
07:12:27 <kaiyin_> > ((\x y -> show $ x + y) <*> (*3)) 5
07:12:29 <lambdabot>  "20"
07:12:50 <pyon> Just wondering: Does every Arrow (in the sense of Control.Arrow) arise from the composition of a comonad and a monad? (That is, every arrowized value would be the composition of a co-Kleisli arrow "w a -> b" and a Kleisli arrow "b -> m c".)
07:12:53 <dgomez>  show $ -- What is this saying?
07:13:17 <barrucadu> "f $ x" is "f x", but $ has really low priority
07:13:19 <srhb> dgomez: try asking lambdabot for the type of show and the type of ($)
07:13:25 <dgomez> (literally in that statement)
07:13:38 <kaiyin_> $ says do these things on my right first. I think.
07:13:48 <shaykha> :t ($)
07:13:49 <lambdabot> (a -> b) -> a -> b
07:14:00 <pyon> dgomez: "f $ x" is just "f x" and "$" is right-associative and has low-precedence. So "show $ x + y" just means "show (x + y)".
07:14:16 <dgomez> lambdabot: could I see the type of show and the type of ($)
07:14:26 <kaiyin_> dgomez, here is some great stuff that I am reading: http://learnyouahaskell.com/
07:14:31 <srhb> dgomez: :t show in the channel or in a message to lambdabot
07:14:39 <dgomez> pyon: thanks for the clarification
07:15:04 <srhb> Like this:
07:15:07 <srhb> :t show
07:15:08 <lambdabot> Show a => a -> String
07:15:35 <dgomez> thanks srhb
07:15:55 <dgomez> :t ($)
07:15:56 <lambdabot> (a -> b) -> a -> b
07:16:02 <pyon> dgomez: (.) and ($) are useful to avoid lots of nested parentheses, e.g., "foo . bar . baz $ qux xyz" instead of "foo (bar (baz (qux xyz)))".
07:17:44 <dgomez> pyon: I see. Is this an example of where the concept of typesafety in Haskell is visible?
07:17:56 <athan> Is there a typeclass, like a monoid, but for idempotent overwrites? Where Maybe values are treated like leaving something alone? (kinda confusing myself here)
07:17:59 <pyon> dgomez: This is not so much about type safety, really. :-P
07:18:20 <pyon> dgomez: Infix operators are primarily syntactic sugar.
07:19:10 <pyon> dgomez: Haskell encourages you to write expressions that are more deeply nested than in other languages. If you had to use parentheses to control the nesting, code would quickly get ugly.
07:19:35 <Intolerable> athan: do u mean some class where f Nothing x = x?
07:19:51 <athan> Intolerable: Something like that
07:19:51 <Intolerable> and f (Just g) = g x or similar?
07:19:57 <athan> more for arbitrary records
07:20:19 <athan> where if a record field has a Maybe a type, the Nothing behaves like the Maybe instance of monoid
07:20:29 <athan> but, for all others, it overwrites like a setter
07:20:44 <Intolerable> there's probably something in lens like that
07:20:52 <athan> Intolerable: It's not like an alternative instance
07:21:03 <athan> I was thinking there would be, but it's for a small library
07:21:08 <athan> I might use lens-family for it
07:21:11 <dgomez> ...
07:21:11 <athan> thanks :_
07:21:13 <athan> :)*
07:21:36 <dgomez> *gulp...
07:21:45 <dgomez> I'll be back in exactly 15 min...
07:21:49 <dgomez> shit
07:21:57 <bennofs> > Just 3 & traverse +~ 4
07:21:59 <lambdabot>  Just 7
07:22:04 <bennofs> > Nothing & traverse +~ 4
07:22:06 <lambdabot>  Nothing
07:22:07 <bennofs> Like this athan ?
07:22:35 <Intolerable> i have a definition for this class somewhere i think
07:22:43 <athan> bennofs: Not quite, the second should've returned "4"
07:22:53 <athan> (at least, that's what I'm thinking)
07:23:08 <bennofs> > maybe 4 (+3) (Just 4)
07:23:09 <athan> its for options parsing & a config file, where they share the same "option" data type
07:23:10 <lambdabot>  7
07:23:11 <bennofs> > maybe 4 (+3) Nothing
07:23:13 <lambdabot>  4
07:23:14 <bennofs> ?
07:23:21 <athan> and that the config file will be overwritten by command-line options
07:23:29 <athan> bennofs: I think so]
07:23:37 <Intolerable> yeah i have the same exact use case
07:23:38 <Intolerable> one second
07:23:39 <athan> I'm going to use monoid instances for the maybe's
07:23:48 <athan> I think I might to some TH for it
07:24:03 <zett_zelett> I‚Äôm learning (untyped) Œª calculus ‚Äì does anyone know of a book/lecture notes in which the subject is introduced steeply, but elegantly?
07:24:39 <bennofs> athan: so it's neither (<|>), not traverse, nor 'maybe' what you're looking for?
07:24:44 <bennofs> > Just 3 <|> Nothing
07:24:46 <lambdabot>  Just 3
07:24:46 <zett_zelett> I‚Äôm especially looking for a treatise which handles the substitution/Œ±-conversion/capture-avoiding-badness well and with as little potential for confusion as possible.
07:24:58 <bennofs> > Nothing <|> Just 4
07:24:59 <Intolerable> athan: https://github.com/intolerable/multiproto/blob/master/src/Data/MultiProto/Protobuf/Example.hs
07:25:00 <lambdabot>  Just 4
07:25:05 <athan> bennofs: I haven't thought of using traverse, I'm nto sure what the behaviour is theree
07:25:08 <dgomez> what is alpha conversion?
07:25:09 <athan> sheesh, fingers
07:25:20 <simon> zett_zelett, http://mathoverflow.net/questions/69337/what-is-some-good-introduction-to-lambda-calculus
07:25:44 <Intolerable> athan: i don't have any th stuff for it, but it should be the same thing ur using it for
07:25:46 <athan> Intolerable: Ahh nice
07:25:53 <Intolerable> mine is just for protobuf defs
07:25:57 <athan> Intolerable: Yeah I think you're right :)
07:26:09 <zett_zelett> I‚Äôve had a look at that, simon, but it didn‚Äôt do it for me.
07:26:18 <zett_zelett> Thanks, nonetheless.
07:26:29 <athan> bennofs, but look at the case where you start with a `Just`:
07:26:36 <athan> > Just 4 <|> Just 5
07:26:37 <lambdabot>  Just 4
07:26:38 <zett_zelett> dgomez: Œ±-conversion: Œªx.x = Œªy.y ‚Äì renaming bound variables is OK.
07:26:49 <athan> I need it to overwrite :/
07:27:24 <Intolerable> look at Data.Semigroup.Last
07:27:59 <dgomez> zett_zelett: do you have an instance of its use??
07:28:04 <simon> zett_zelett, I've never had to read anything about the lambda calculus. there might be things I don't understand about it, but it more or less slipped silently into my mind after years of functional programming and courses on formal semantics and type theory.
07:30:38 <dgomez> Data.Map  insert :: Ord k => k -> a -> Map k a -> Map k a  ---> What makes this a container?
07:30:47 <zett_zelett> simon: Are you able to prove theorems like the Church‚ÄìRosser theorem?
07:34:18 <zett_zelett> dgomez: I don‚Äôt know ‚Äì it‚Äôs just a name for a rule satisfied by the equivalence of Œª terms. It‚Äôs probably good to have a name for it.
07:35:49 <quchen> dgomez: Consider shadowing, e.g. the expression "\x -> (\x -> x*2) x". It's pretty hard to read since two different variables with the name "x" appear in it. Alpha equivalence says that you can rewrite this to the clearer "\x -> (\y -> y*2) x".
07:36:14 <quchen> In other words, alpha equivalence is the law that allows you to rename things.
07:36:46 <casidiablo> Given a ADT like this: data Something = Foo | Bar | Baz; is there a way to associate Foo with 0, Bar with 1 and Baz with 2 automatically?
07:37:24 <srhb> casidiablo: deriving Enum, I believe
07:38:23 <quchen> dgomez: Things are made a container by providing an API to things you've previously stored in them.
07:38:48 <srhb> casidiablo: http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#t:Enum
07:39:05 <simon> dgomez, or if you want a lambda-expression within a lambda-expression to refer to the outer variable, but they're both called the same. then alpha equivalence makes that possible to write.
07:39:09 <casidiablo> Got it, thanks
07:39:27 <simon> dgomez, e.g. "\x -> (\y -> x+y)"
07:39:50 <dgomez> quchen: all right, let me try to understand that better.
07:41:01 <simon> zett_zelett, probably not without a significant level of preparation. I might have overstated my confidence with formal methods. :)
07:50:34 <kaiyin_> Can I load some hs file from lpaste.net into lambdabot ?
07:52:06 <dgomez> quchen: I'm sorry did you want me to state that I understand what you meant by alpha-sig. the variables were overwritten.
07:52:38 <dgomez> lhs vs hs? does lhs denote source code but arent they both source code files ?
07:52:51 <quchen> Renamed, not overwritten. (I don't know what "overwritten" means here.)
07:53:21 <quchen> Both lhs and hs are Haskell source files, but they have different syntax.
07:55:26 <kaiyin> > sequenceA [] = pure []
07:55:28 <lambdabot>  <hint>:1:14: parse error on input ‚Äò=‚Äô
07:55:36 <kaiyin> > sequenceA (x:xs) = (:) <$> x <*> sequenceA xs
07:55:38 <lambdabot>  <hint>:1:18: parse error on input ‚Äò=‚Äô
07:55:49 <kaiyin> > let sequenceA [] = pure []
07:55:51 <lambdabot>  not an expression: ‚Äòlet sequenceA [] = pure []‚Äô
07:55:52 <dgomez> quechen: you're saying that the variables in the expressions were renamed not overridden, but haven't their values been reassigned bc they have been renamed?
07:55:58 <kaiyin> > let sequenceA (x:xs) = (:) <$> x <*> sequenceA xs
07:56:00 <lambdabot>  not an expression: ‚Äòlet sequenceA (x:xs) = (:) <$> x <*> sequenceA xs‚Äô
07:56:01 <benzrf> kaiyin: @let
07:56:05 <burp_> lhs is like irc with lambdabot ;)
07:56:10 <kaiyin> @let sequenceA [] = pure []
07:56:13 <lambdabot>  Defined.
07:56:20 <kaiyin> @let sequenceA (x:xs) = (:) <$> x <*> sequenceA xs
07:56:21 <lambdabot>  Defined.
07:56:36 <benzrf> @let -- adds this to a file
07:56:39 <lambdabot>  Defined.
07:57:23 <kaiyin> benzrf, @let is like loading a file, and > is like ghci?
07:57:32 <quchen> dgomez: I don't understand. What I meant to say was that `\x -> (\x -> x*2) x` is the same as `\x -> (\y -> y*2) x` because of alpha equivalence.
07:57:33 <dgomez> :t sequenceA []
07:57:34 <lambdabot> Applicative f => f [t]
07:57:42 <benzrf> kaiyin: @let adds to a file
07:57:51 <benzrf> kaiyin: each @let becomes the next line, in it
07:58:16 <kaiyin> Is it some file on the irc server?
07:58:20 <benzrf> kaiyin: then > is ghci after loading the file witch you are adding to
07:58:27 <benzrf> kaiyin: no, lambdabot is a normal client just like yu or me
07:58:31 <benzrf> kaiyin: it's not part of irc
07:58:38 <benzrf> but yes it's a file on the server lambdabot runs from
07:59:01 <kaiyin> ok, cool.
07:59:16 <kaiyin> :t sequenceA [(+3), (+2)]
07:59:17 <lambdabot> Num a => a -> [a]
07:59:49 <kaiyin> I don't quite understand how sequenceA works on this list of functions/functors.
08:00:32 <kaiyin> :t (+3)
08:00:33 <lambdabot> Num a => a -> a
08:00:43 <quchen> kaiyin: Maybe this helps: https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
08:01:09 <bananagram> :t (+(1::Float))
08:01:10 <lambdabot> Float -> Float
08:03:10 <kaiyin> quchen, thanks, haven't arrived at the A fist of monads tutorial yet.
08:03:29 <kaiyin> > sequenceA [Just 3, Just 2, Just 1]
08:03:31 <lambdabot>  Just [3,2,1]
08:04:01 <kaiyin> This one is easy to understand, it turns a list of functors into a functor of list
08:04:11 <benzrf> a list of functorial values*
08:04:15 <quchen> kaiyin: sequence is probably more advanced than monads, at least in the usual "learn Haskell timeline".
08:04:18 <benzrf> Just 2 <- this is not a functor
08:04:22 <benzrf> Maybe <- this is a functor
08:04:31 <benzrf> quchen: you really only need applicative for it though
08:04:46 <benzrf> quchen: the "usual learn Haskell timeline" is poorly thought out >.<
08:04:52 <quchen> benzrf: And Traversable.
08:05:12 <benzrf> quchen: only for the generic forrm
08:05:29 <kaiyin> But how exactly does sequenceA operate on a list of functions?
08:05:55 <dgomez> :t sequenceA[]
08:05:56 <lambdabot> Applicative f => f [t]
08:06:11 <dgomez> and you are saying kaiyin?
08:06:36 <dgomez> but I need to take a look at quchen's link...
08:06:48 <kaiyin> :)
08:09:33 <kaiyin> ok, so sequenceA takes [(a->b)] and turns it into a -> [b]
08:09:47 <Nik05> sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
08:11:55 <dgomez> :t t(f a)
08:11:56 <lambdabot>     Couldn't match expected type ‚Äòt0 -> t‚Äô with actual type ‚ÄòExpr‚Äô
08:11:56 <lambdabot>     The function ‚Äòt‚Äô is applied to one argument,
08:11:56 <lambdabot>     but its type ‚ÄòExpr‚Äô has none
08:12:18 <quchen_> sequenceA is maybe a bit too generic for a beginner who doesn't know about Foldable/Traversable yet.
08:12:30 <quchen_> The specialized version for sequencing lists is
08:12:31 <quchen_> :t sequenceA `asAppliedTo` (undefined :: Functor f => [f a])
08:12:32 <lambdabot> Applicative f => [f t] -> f [t]
08:14:31 <dfeuer> :t sequenceA
08:14:32 <lambdabot> Applicative f => [f t] -> f [t]
08:14:36 <dgomez> :t f => [f a]
08:14:37 <lambdabot> parse error on input ‚Äò=>‚Äô
08:14:51 <quchen_> ?undef
08:14:51 <lambdabot> Undefined.
08:14:58 <quchen_> :t sequenceA
08:14:58 <lambdabot>     Not in scope: ‚ÄòsequenceA‚Äô
08:14:58 <lambdabot>     Perhaps you meant one of these:
08:14:58 <lambdabot>       ‚ÄòT.sequenceA‚Äô (imported from Data.Traversable),
08:15:00 <quchen_> Better.
08:15:31 <dfeuer> :t Data.Traversable.sequenceA
08:15:32 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
08:15:44 <quchen_> dfeuer: It's imported qualified as T
08:15:48 <quchen_> :t T.sequenceA
08:15:48 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
08:15:52 <kaiyin> quchen_, thanks. I will come back to this later.
08:16:48 <dfeuer> :t traverse
08:16:49 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
08:16:56 <dgomez> I'm here but I am just not sure what the Transversable class does.
08:17:08 <dfeuer> That's because it's confusing.
08:17:12 <dgomez> oh.
08:17:28 <dgomez> i mean that's understood‚Ä¶
08:18:03 <dfeuer> But the idea is that you're traversing a container of some sort. For each value in the container you perform some sort of action.
08:18:04 <quchen_> Traversable generalizes Prelude.{mapM,sequence} to work on data types other than [].
08:18:28 <dfeuer> Each action has a result. You collect together all the results into a new container with the same "shape" as the old one.
08:19:17 <athan> Generally speaking, which is faster - Data.Text, or a Builder?
08:19:53 <dgomez> ok dfeuer. So the class Prelude has that method mapM to allow it to traverse a sequence?
08:20:06 <dfeuer> athan, generally, it depends on what you're doing.
08:20:24 <dfeuer> dgomez, what?
08:20:40 <dfeuer> No....
08:21:17 <dgomez> Prelude.{mapM,sequence}  is class Tranversable?
08:21:27 <dgomez> but that doesn't make much sense to me.
08:21:43 <dfeuer> Prelude is not a class, but a module. mapM is just a regular function.
08:21:57 <athan> dfeuer: I had a feeling. For something like large amounts of data (streaming, or responding, like a web server), I think a builder would do better than a lazy text, right?
08:22:17 <dfeuer> athan, I believe builders are generally for building things.
08:22:44 <dfeuer> They tend to be (relatively) efficient for gluing pieces together, and not much good for anything else.
08:23:27 <athan> dfeuer: Thanks man
08:25:26 <dgomez> :t mempty
08:25:26 <lambdabot> Monoid a => a
08:25:46 <dgomez> :t mappend
08:25:47 <lambdabot> Monoid a => a -> a -> a
08:26:50 <dfeuer> dgomez, Monoid is a very nice class to help you get to understand what classes are about.
08:27:19 <dfeuer> It's very simple and also quite useful.
08:27:41 <dgomez> :t Monoid a
08:27:41 <lambdabot> Not in scope: data constructor ‚ÄòMonoid‚Äô
08:28:06 <dfeuer> dgomez, Monoid is not a type or type constructor. It's a class.
08:28:17 <dfeuer> There are many instances.
08:28:31 <dfeuer> > [1,2,3] `mappend` [4,5,6]
08:28:33 <lambdabot>  [1,2,3,4,5,6]
08:28:50 <freefall> anyone here anything on the psn network
08:28:51 <dgomez> dfeuer: got it.
08:29:50 * hackagebot pregame 0.1.4.3 - Prelude counterpart  http://hackage.haskell.org/package/pregame-0.1.4.3 (jxv)
08:30:07 <dfeuer> > Nothing `mappend` Just 5
08:30:09 <lambdabot>  No instance for (GHC.Show.Show a0)
08:30:09 <lambdabot>    arising from a use of ‚ÄòM138279653507293348518845.show_M1382796535072933485...
08:30:09 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
08:30:23 <dfeuer> > Nothing `mappend` Just (5::Int)
08:30:24 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
08:30:24 <lambdabot>    arising from a use of ‚ÄòData.Monoid.mappend‚Äô
08:30:29 <exio4> > Nothing `mappend` Just (Sum 5)
08:30:30 <lambdabot>  Just (Sum {getSum = 5})
08:30:34 <dfeuer> Whoops.
08:30:43 <dgomez> so an instance  of  [1,2] 'mempty' [1] [2]?
08:30:48 <dfeuer> Read the signature wrong.
08:31:36 <dfeuer> > ([1,2], [3,4]) `mappend` ([5,6,7],[8])
08:31:37 <lambdabot>  ([1,2,5,6,7],[3,4,8])
08:32:22 <benzrf> jjj
08:32:24 <benzrf> oops
08:32:36 <benzrf> here is a fun question for you
08:32:48 <benzrf> what is the identity element of Maybe (Sum Int)
08:33:43 <exio4> benzrf, Semigroup a => Monoid (Maybe a)!
08:33:57 <dgomez> yeah i am still not doing great with tht e syntax.
08:34:26 <dgomez> I don't know what identity element refers to.. benzrf
08:35:16 <dfeuer> > mempty :: String
08:35:17 <lambdabot>  ""
08:35:39 <dfeuer> > mempty :: Data.Sequence.Seq Integer
08:35:40 <lambdabot>  Not in scope: type constructor or class ‚ÄòData.Sequence.Seq‚Äô
08:35:44 <dfeuer> Bleh.
08:35:58 <srhb> dgomez: 0 is the identity element for sums, 1 for products, "" for string concatenation, ...
08:36:24 <dfeuer> I guess lambdabot doesn't have Data.Sequence?
08:36:45 <indiagreen> :t undefined :: S.Seq
08:36:46 <lambdabot>     Not in scope: type constructor or class ‚ÄòS.Seq‚Äô
08:36:46 <lambdabot>     Perhaps you meant ‚ÄòS.Set‚Äô (imported from Data.Set)
08:36:51 <indiagreen> hm, okay
08:37:07 <indiagreen> :t undefined :: Seq.Seq
08:37:08 <lambdabot>     Expecting one more argument to ‚ÄòSeq.Seq‚Äô
08:37:08 <lambdabot>     Expected a type, but ‚ÄòSeq.Seq‚Äô has kind ‚Äò* -> *‚Äô
08:37:08 <lambdabot>     In an expression type signature: Seq.Seq
08:37:10 <indiagreen> aha
08:37:23 <indiagreen> dfeuer: ^
08:39:15 <dfeuer> Ohhhh
08:39:27 <dfeuer> > mempty :: Seq.Seq Integer
08:39:28 <lambdabot>  fromList []
08:40:18 <dgomez> :t type
08:40:19 <lambdabot> parse error on input ‚Äòtype‚Äô
08:41:01 <dfeuer> type is a keyword used to introduce type synonyms.
08:41:17 <dgomez> :t Read
08:41:18 <lambdabot>     Not in scope: data constructor ‚ÄòRead‚Äô
08:41:18 <lambdabot>     Perhaps you meant ‚ÄòDead‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
08:41:47 <dfeuer> In Haskell, only values have types. Read is a class, not a value.
08:41:55 <dfeuer> :k Read
08:41:56 <lambdabot> * -> Constraint
08:42:07 <Nik05> :info Read
08:42:26 <dfeuer> Nik05, I don't think that works for lambdabot.
08:42:29 <Nik05> :)
08:44:51 * hackagebot twitch 0.1.6.1 - A high level file watcher DSL  http://hackage.haskell.org/package/twitch-0.1.6.1 (JonathanFischoff)
09:01:31 <dgomez> :t (Eq a)
09:01:32 <lambdabot>     Not in scope: data constructor ‚ÄòEq‚Äô
09:01:32 <lambdabot>     Perhaps you meant ‚ÄòEQ‚Äô (imported from Data.Ord)
09:04:36 <jesyspa> :k Eq a
09:04:37 <lambdabot> Not in scope: type variable ‚Äòa‚Äô
09:04:41 <jesyspa> dgomez: Did you mean that?
09:04:43 <jesyspa> Err.
09:05:23 <exio4> :k Eq
09:05:24 <lambdabot> * -> Constraint
09:05:28 <exio4> :k forall a. Eq a
09:05:29 <lambdabot> Constraint
09:07:50 <jesyspa> That, thanks.
09:14:52 * hackagebot higher-leveldb 0.2.1.0 - A rich monadic API for working with leveldb databases.  http://hackage.haskell.org/package/higher-leveldb-0.2.1.0 (jeremyjh)
09:56:54 <scaroo> Hi everyone. Speaking of REPL I am confronted with a strange issue with emacs haskell-mode interactive stuff: After loading my project in the REPL (C-c C-l) and being presented a nice lambda prompt in a new buffer, I am unable to validate my input there by pressing Enter. Unconvenient :)
09:59:14 <JonReed> Hi. I installed gchjs from the git repo,  and when I do ghcjs-boot, it gives me "fatal: cabal-install program /home/jon/library/projects/haskell/ghcjs/.cabal-sandbox/bin/cabal does not support GHCJS".  What might be the issue?
09:59:46 <JonReed> Cabal is "1.20.0.0"
10:00:57 <zq> ugh
10:00:59 <zq> i don't get this
10:01:17 <zq> why are consecutive readSTRefs not elided
10:09:09 <dgomez> JonReed: why didn't you go with GTX+ with the quartz back-end using homebrew?
10:12:33 <JonReed> dgomez: Probably you did not mean to respond to me. Because I'm confused how that relates to my issue.
10:18:15 <dgomez> well you'd typically avoid using MacPorts as your package manager if you have anything above Tiger? I'm curious why you are choosing to set up your environment with the ghcjs compiler?
10:18:27 <dgomez> JonReed
10:18:39 <geekosaur> *you* might typically. somew of us like stable environments
10:19:48 <trap_exit> https://gist.github.com/anonymous/33cb1e314599b23e22b3 <-- how do I make it so that after hitting "Module", there is backtracking? I.e. in Data.Attoparsec.Text, after hitting the "module" ... I want it to either complete or throw an error
10:21:02 <johnw> Nix is about to get excellent support for ghcjs, btw
10:21:47 <trap_exit> https://gist.github.com/anonymous/33cb1e314599b23e22b3 <-- how do I make it so that after hitting "Module", there is backtracking? I.e. in Data.Attoparsec.Text, after hitting the "module" ... I want it to either complete or throw an error
10:21:56 <JonReed> dgomez: I'm following the https://github.com/ghcjs/ghcjs intallation tutorial. There is the step that requires to execute ghcjs-boot. I'm on arch linux btw
10:23:37 <trap_exit> one can read through the haste source in the time it takes to install ghcjs :-)
10:24:40 <dgomez> JonReed #ghcjs
10:24:58 <Geraldus> Hi folks! Can I configure .cabal file to place generated executable to a specific project folder, or I should set up this kind of thing only with `cabal configure`?
10:24:59 <JonReed> dgomez: ok thx
10:25:43 <lilred> good evening
10:25:55 <vanila> hello
10:27:08 <Geraldus> evening!
10:27:44 <trap_exit> where is <|> defined in Data.Attoparsec.Text ?
10:28:25 <danilo2> Hello! I' reading edwark's article about bound variables (https://www.fpcomplete.com/user/edwardk/bound) and I owuld like to ask if anybody knows what does the "succ" function?
10:28:41 <simukis_> trap_exit: in Control.Applicative.
10:28:45 <simukis_> I think
10:28:50 <srhb> > succ False
10:28:52 <lambdabot>  True
10:28:52 <simukis_> if my memory‚Äôs not lying to me.
10:28:54 <srhb> > succ 0
10:28:55 <lambdabot>  1
10:28:56 <srhb> :t succ
10:28:57 <lambdabot> Enum a => a -> a
10:29:15 <srhb> So it basically gives you the successing value for any Enum
10:29:18 <Geraldus> it gives you next successor
10:29:24 <srhb> (assuming that's the same succ)
10:29:35 <danilo2> ahh!
10:29:38 <srhb> It's companion is pred, I believe
10:29:41 <srhb> > pred 1
10:29:42 <lambdabot>  0
10:29:45 <srhb> There we go.
10:29:51 <danilo2> thank you very much!
10:29:54 <srhb> Sure.
10:30:35 <trap_exit> surely Data.Attoparsec.Text.Parser has to do some stuff to specialize <|> ?
10:31:06 <trap_exit> i mean to ensure that if the first fails, it does not consume input, this seems like a 'standard' <|> won't 'just work'
10:31:21 <Geraldus> succ True
10:31:38 <ReinH> trap_exit: There's no "standard" <|>
10:31:48 <danilo2> srhb: Ok and do you understand what does the "succ" in the terms of variable binding resolution like in this paper? I think a lot of people are using this term in several papers but I havent found explanation for this yet
10:31:53 <trap_exit> how does Data.Attoparsec.Text gets "<|>" then ?
10:31:57 <ReinH> (<|>) is whatever you define it to be in each instance
10:32:11 <trap_exit> where is thea ctual implementation of Data.Attoparsec.Text.<|> ?
10:32:32 <ReinH> trap_exit: http://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-Types.html#t:Parser
10:33:47 <trap_exit> ReinH: ah, <|> i sjust plus in http://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/src/Data-Attoparsec-Internal-Types.html#Parser ... nice, thanks!
10:34:02 <ReinH> danilo2: You need to find the next available name, so you succ the previous name.
10:34:10 <ReinH> trap_exit: sure :)
10:34:41 <ReinH> danilo2: The secret sauce in the bound library is that you can succ the entire sub-tree rather than having to traverse to all the leaves
10:35:15 <ReinH> danilo2: see https://www.fpcomplete.com/user/edwardk/bound and http://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less
10:35:25 <danilo2> ReinH: Ok I was thinking this is it! Thank you :) Hmm, I understand that when writing custom cpompiler it is safe to use the bound li brary instead of trying other approaches like the GHC's rappier? :)
10:35:31 <shock_one> Hi. How would I test an executable, not a library?
10:35:36 <danilo2> ReinH: I'm just reading them! :)
10:35:42 <ReinH> danilo2: bound is an alternative to the rapier, yes
10:37:23 <danilo2> ReinH: thank you :) By the way - is here (on the irc) somebody I could talk about a compiler design in general? We've got here a very interesting small language developed and we are right now rewriting the compiler and looking for proven solutions. I'm just asking if is here anybody I can talk about this and that for 15 minutes one day :)
10:37:39 <Geraldus> does anybody know is there a way to configure executable dest dir in cabal file? :)
10:37:51 <ReinH> I'm sure a few people in here know about compiler design. edwardk, johnw, etc
10:38:14 <JonReed> How can I update cabal inside a sandbox? I have a sandbox with outdated version of cabal that I can't update. I both cabal install cabal-install"  and ".cabal-sandbox/bin/cabal install cabal-install." Update some cabal to 1.20, but ".cabal-sandbox/bin/cabal --version" still gives "1.18"
10:38:38 <lilred> danilo2: I'd love to have a chat with you. I've worked on a compiler before (Beluga), and it's my main research interest.
10:38:54 <lilred> danilo2: I'm currently stuck somewhere far and bored out of my mind.
10:39:07 <ReinH> danilo2: If you haven't read it, my favorite book on compilers is available for free from the author http://www.holub.com/software/compilerDesignInC.pdf
10:39:08 <danilo2> lilred: Great! So have you time now? :D
10:39:15 <ReinH> lilred: :)
10:39:17 <lilred> absolutely!
10:39:38 <danilo2> lilred: give me few seconds please :)
10:40:25 <ReinH> lilred: I might bother you later then. I'm rewriting the write yourself a scheme tutorial using modern tooling and eventually I want to compile it, possibly using LLVM...
10:40:58 <lllmmm> hi i need help
10:41:17 <lilred> lllmmm: don't ask to ask! What's up?
10:41:22 <vanila> ReinH, Cool! That was something I was planning to but I wont need to now :p  If you want me to proof-read I'd be happy too
10:41:30 <ReinH> vanila: yay :)
10:41:49 <ReinH> vanila: that would be wonderful. I'm very much an amateur when it comes to this stuff.
10:42:39 <vanila> the tutorial is sorely in need of an update, this will be great
10:43:01 <ReinH> vanila: it really is.
10:43:09 <ReinH> vanila: I'm using trifecta and bound :)
10:43:38 <ReinH> also trifecta is really great for parsing PL grammars...
10:45:30 <marchelzo_> I'm trying to install ghc-mod to write haskell in vim, and when I try to 'cabal install ghc-mod' it says that it would have to re-install all kinds of packages. I don't want to end up in cabal hell. What should I do?
10:47:11 <ReinH> marchelzo_: One option is to install in a sandbox and then copy or link the binary somewhere in $PAH
10:47:24 <ReinH> s/PAH/PATH
10:48:49 <marchelzo_> ReinH: ah, I figured the answer would involve sandboxes. Thanks :)
10:51:18 <trap_exit> in attoparsec, is there a way to get the column / row position?
10:51:27 <trap_exit> I'm parsing a haskell-like langauge, so whitespace effecst parsing
10:53:16 <Geraldus> marchelzo_: you also could use Stackage to avoid cabal hell :)
10:53:31 <ReinH> Geraldus: unsure if ghc-mod is in Stackage?
10:53:48 <indiagreen> trap_exit: I think there isn't
10:54:00 <trap_exit> wtf
10:54:03 <trap_exit> you are kidding me right?
10:54:08 <indiagreen> nope
10:54:11 <trap_exit> attoparsec does not auto store row/column info fo rme?
10:54:16 <indiagreen> it trades error reporting and stuff for performance
10:54:19 <trap_exit> does parsec store this info?
10:54:39 <indiagreen> yep
10:54:44 <Geraldus> ghc-mod is not, but it could be easily installed because of most its dependencies are in Stackage
10:55:04 <simukis_> current attoparsec implementation only stores offsets in input for backtracks
10:55:15 <trap_exit> great, looks like I am switching to parsec then
10:55:38 <ReinH> Geraldus: Oh, actually it seems to be? http://hackage.haskell.org/package/ghc-mod lists it
10:55:48 <ReinH> And http://www.stackage.org/package/ghc-mod
10:56:18 <ReinH> trap_exit: I wouldn't recommend attoparsec for parsing a PL grammar. You might try Parsec or Trifecta.
10:56:32 <trap_exit> yeah, I'm going parsec
10:56:33 <ReinH> Attoparasec is really defined for parsing machine-generated things like data formats
10:56:42 <ReinH> s/defined/designed
10:56:43 <Geraldus> I've added `ghc-mod` to Stackage myself, but I'm not sure is it still there :D
10:56:51 <trap_exit> i get the impression attoparsec is optimized for csvs and log files
10:57:22 <ReinH> trap_exit: You might like Trifecta. At one point, it actually had some support for parsing things with layout. Not sure what happened. edwardk would know.
10:57:43 <Geraldus> How can I put executables in specific project folder during cabal build (different from dist/build)?
10:59:01 <ReinH> Geraldus: Juat copy or link them from dist/build
10:59:04 <makalu> is there an IRC channel where I could get help with Accelerate?
10:59:05 <trap_exit> reinH: trifecta hackage docs seems sparse; do oyu have a good tutorila for trifecta ?
10:59:15 <ReinH> trap_exit: Well, a lot of it is moved to the parsers library.
10:59:15 <agibiansky> Geraldus: Not sure, but you might try using a custom Setup.hs and build type 'custom' with a hook postBuild (see UserHooks: https://downloads.haskell.org/~ghc/7.0.2/docs/html/libraries/Cabal-1.10.1.0/Distribution-Simple.html )
10:59:19 <makalu> or maybe there is someone here who knows about Accelerate?
10:59:25 <ReinH> @@ trap_exit @hackage parsers
10:59:25 <lambdabot>  trap_exit http://hackage.haskell.org/package/parsers
10:59:38 <ReinH> Which is a generic front-end for parsers
10:59:49 <ReinH> You could write Parsec using parsers, for example
10:59:57 * hackagebot uhc-light 1.1.8.3 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.8.3 (AtzeDijkstra)
11:00:11 <ReinH> makalu: If you ask your question, someone might know the answer
11:00:26 <Geraldus> okay, looks like hooks is what I need. I'm trying to use same cabal file to build both server side and client side code, one with ghc and another with ghcjs.
11:00:40 <ReinH> Geraldus: Ah, this isn't for ghc-mod. Sorry.
11:01:11 <ReinH> Geraldus: No idea why I thought you were asking about ghc-mod. My brain :(
11:01:31 <Geraldus> The problem is when I building server side code after client side code, generated javascript executables are being removed from dist/build
11:02:40 <Geraldus> ReinH: because irc chat is messy place :)
11:03:07 <Geraldus> thing could be easily messed up when reading a lot of talks
11:03:25 <ReinH> luite might be able to help
11:03:31 <jonazzzzzz> i've created a new thread using forkIO but it only updates when i click the gui, what is wrong?
11:03:46 <ReinH> jonazzzzzz: Hard to say. Can you share some code?
11:04:02 <jonazzzzzz> hmm i followed this tut https://www.haskell.org/haskellwiki/Gtk2Hs/Tutorials/ThreadedGUIs
11:04:28 <ReinH> Hmm. Are you compiling with -threaded and running with +RTS -N ?
11:04:57 <jonazzzzzz> nope just using ghc.. i'll try
11:04:57 * hackagebot hydrogen-parsing 0.11 - Hydrogen Parsing Utilities  http://hackage.haskell.org/package/hydrogen-parsing-0.11 (JulianFleischer)
11:04:59 * hackagebot hydrogen-syntax 0.11 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-syntax-0.11 (JulianFleischer)
11:05:01 <luite> Geraldus: it should keep the files, unless you manually run cabal clean or something. it's probably easiest to work with different executable names for the client and server
11:05:31 <jonazzzzzz> ghc app -threaded ?
11:05:36 <jonazzzzzz> it's not working
11:06:03 <luite> Geraldus: like this: http://lpaste.net/117299
11:07:40 <Geraldus> luite: I though about separate executable sections, but anyway I have to copy js code from dist/build to static/javascript to make it reachable for clients.
11:07:51 <Geraldus> *thought
11:08:30 <ReinH> jonazzzzzz: I'm not sure what the problem is since I can't see your code. It was just a thought.
11:08:31 <luite> Geraldus: you can do so with a copyHook in the Setup.hs for example
11:09:57 * hackagebot hydrogen-cli 0.11 - Hydrogen Data  http://hackage.haskell.org/package/hydrogen-cli-0.11 (JulianFleischer)
11:09:59 * hackagebot hydrogen-cli-args 0.11 - Hydrogen Command Line Arguments Parser  http://hackage.haskell.org/package/hydrogen-cli-args-0.11 (JulianFleischer)
11:10:01 <marchelzo_> I'm trying to use stackage, so I downloaded 'cabal.config' and did 'cabal update' as it says, but it doesn't download any package lists from stackage. It just tells me there is a new version of cabal available even thought I /just/ installed the newest version.
11:10:14 <marchelzo_> s/thought/though/
11:11:28 <JonReed> I had some strange experienc with cabal not wanting to update inside a sandbox
11:12:14 <agibiansky> marchelzo_: I haven't used Stackage, but a) is cabal using the config file? you probably have to stick it in ~/.cabal/config or in your sandbox config or whatever and b) make sure that your $PATH indicates the cabal-installed cabal over the old one (e.g. that ~/.cabal/bin comes before in your PATH of wherever your original cabal lived, probably in ghc somewhere)
11:13:04 <marchelzo_> agibiansky: ah, I bet that's it. I'm probably installing the new cabal and not running it. >.<
11:13:05 <makalu> how do I create an empty array in Accelerate? I used "fill" which seems stupid.
11:14:45 <srhb> makalu: Doesn't it use Vector underneath? Do they even support sparse arrays?
11:15:03 <makalu> an empty vector is sparse :)?
11:15:36 <srhb> makalu: Well, not if you mean a Vector with no elements.
11:15:57 <makalu> I mean "fromList []"
11:16:05 <srhb> Ah.
11:16:10 <makalu> and accelerate doesn't use vector
11:16:35 <marchelzo_> Okay It's no longer warning me about there being a new version of cabal, but I still don't get the packages from stackage. How do I make cabal use the config file that I downloaded? I followed the directions on the stackage website.
11:16:55 <agibiansky> marchelzo_: Are you doing this for your user config? e.g. for ~/.cabal/config?
11:17:49 <marchelzo_> agibiansky: yes. It said to put the downloaded 'cabal.config' next to that, which I assume means not replacing the old one.
11:18:25 <marchelzo_> ls -la
11:18:42 <marchelzo_> oops, heh
11:19:00 <toblerone> Hi all, I'm trying to install GHC-Mod and it fails with this error: http://lpaste.net/117300 any clue what my problem is?
11:19:40 <marchelzo_> I got the same error just a second ago when I tried to install it in a cabal sandbox
11:19:48 <jonazzzzzz>  i call it in my onbuttonpress function
11:20:06 <agibiansky> marchelzo_: What is the site you're looking at? I'm trying to load the stackage install page and it isn't loading for me
11:20:37 <marchelzo_> Just http://www.stackage.org/ the little 'quick start' thing in the top right.
11:21:58 <jonazzzzzz> http://lpaste.net/5393856011784159232 i call that function in my onbuttonpress, what am i doing wrong, it only prints ok when i click a button again and 1 second has passed
11:22:34 <agibiansky> marchelzo_: Oh, cool. That's nifty. Yeah, I'm afraid I don't know. Perhaps either a) make sure that the wget worked and that its in ~/.cabal/cabal.config or b) that you run `cabal update` in the same directory as the cabal.config file
11:22:52 <agibiansky> marchelzo_: Haven't installed anything via Stackage myself though so don't know, sorry
11:23:03 <JonReed> jonazzzzzz: http://stackoverflow.com/questions/13190314/haskell-do-monad-io-happens-out-of-order
11:23:10 <marchelzo_> agibiansky: thanks for the help anyway. I appreciate it :)
11:23:13 <JonReed> jonazzzzzz: That would be my guess
11:23:48 <JonReed> jonazzzzzz: I.e. do "hFlush stdout"
11:23:57 <JonReed> jonazzzzzz: After putStr
11:24:42 <jonazzzzzz> i don't need to print anything, i need to update a label
11:24:55 <jonazzzzzz> but i just tried with putstr to see if it worked but it doesn't
11:24:58 * hackagebot shell-monad 0.2.1 - shell monad  http://hackage.haskell.org/package/shell-monad-0.2.1 (JoeyHess)
11:26:17 <jonazzzzzz> i tried but it doesn't work
11:26:39 <JonReed> jonazzzzzz: I don't know then :(
11:26:57 <jonazzzzzz> no problem hehe
11:27:40 <jonazzzzzz> i thought i've read something about interleaving other threads, but i don't know anmore which command it was
11:28:56 <jonazzzzzz> do i need the forkos? https://www.haskell.org/haskellwiki/Gtk2Hs/Tutorials/ThreadedGUIs
11:31:13 <jonazzzzzz> ah i got it lol
11:31:29 <jonazzzzzz> i had to use ghc -threaded app instead of ghc app -threaded xd anyways it's working now
11:37:59 <jpsantos> Is there a better way to patter match this `oauth1Credentials@(OAuth1 _ _ _ _) =`?
11:38:20 <agibiansky> oauth1Credentials@(Oauth1{})
11:38:41 <jpsantos> That requires RecordWildCards?
11:38:46 <exio4> no, it doesn't
11:38:56 <agibiansky> Record wild cards would be Oauth1{..}
11:39:00 <agibiansky> Oauth1{} just ignores all the fields
11:39:10 <jpsantos> Nice. That's what I was looking for
11:39:24 <agibiansky> jpsantos: Do you use hlint?
11:39:29 <jpsantos> Even HLint told me, but I thought it needed require RecordWildCards
11:39:35 <agibiansky> Ah, ok
11:39:36 <jpsantos> Didn't know how to Google for it
11:39:41 <agibiansky> yeah, I learned about it from hlint too :)
11:39:53 <agibiansky> hlint is probably responsible for half my haskell coding habits
11:39:56 <jpsantos> HLint is so nice.
11:40:14 <jpsantos> I'm attempting to internalize everything HLint "knows" and become human HLint
11:41:06 <agibiansky> I wish hlint had a "let me teach you foldable/traversable" mode, too
11:41:15 <agibiansky> But that is a bit tricky to do, i guess
11:41:39 <agibiansky> I could do with someone grumbling at me to use foldMap and traverse more often
11:41:54 <agibiansky> also unfold...
11:42:36 <JonReed> Why "cabal --version" says that one version of cabal is installed but it uses another version. "cabal-install version 1.20.0.4 \n using version 1.20.0.3 of the Cabal library"?
11:43:02 <agibiansky> JonReed: Technically, cabal-install and Cabal are different things
11:43:18 <agibiansky> Cabal is a library for package management and such, cabal-install is the "cabal" command-line tool
11:43:38 <agibiansky> So I think that's normal ‚Äì I have the same
11:43:55 <JonReed> agibiansky: Oh
11:44:20 <Clint> i have 1.20.0.3 using 1.20.0.2
11:45:31 <jpsantos> I'm working on Wreq and found it surprising that bos doesn't appear to use HLint
11:46:02 <jpsantos> do statements with a single expression inside and stuff like that
11:48:48 <thebnq> using ST over IO (ref/array) seems way more faster, is this expected?
11:48:49 <Spackenzergie> Hi, I'm currently doing HW for my "intro to programming" class and we just started on Haskell before Christmas. Im trying to write a function that returns all permutations of a [Int], but I have trouble finding a concept on how to do it.
11:49:01 <Spackenzergie> Can someone give me a hint?
11:49:52 <agibiansky> Spackenzergie: Try answering this simpler question first...
11:50:25 <agibiansky> If i give you a value x :: Int and a list of values ys :: [Int], can you make a bunch of tuples (x,y) :: (Int, Int) where the value y comes from ys?
11:53:42 <whale> Hello.
11:53:48 <Spackenzergie> Hm, no. Im always falling back onto what I learned about Java, but iterating over a list ... I wouldnt know how to do it in Haskell. I mean I could do it recursively in Java, but not in Haskell.
11:54:19 <agibiansky> How are you trying to do it in Haskell?
11:54:27 <agibiansky> What have you tried and what hasn't worked?
11:54:33 <agibiansky> whale: Hello
11:55:59 <whale> I have read that Haskell is very useful in modelling pure-mathematical objects. Is there a specific reason for this?
11:56:31 <thebnq> depends what its being compared to
11:56:45 <monochrom> I do not know. I guess immutable data helps. because mathematical objects are immutable data, too.
11:56:54 <ReinH> whale: One factor is that Haskell's functions are similar to mathematical functions in that they are pure and referentially transparent.
11:57:00 <monochrom> it is not like, in math, you could mutate "5" to "6".
11:57:08 <agibiansky> whale: Hard to say exactly for me, but a lot of people use typeclasses and type families to do things that are somewhat logic-programming-ish
11:57:25 <monochrom> i.e., if x is defined to be 5, then you cannot mutate x to 6.
11:57:28 <jorr> whale: also, even the syntax is reasonably close to math function definitions sometimes
11:57:43 <agibiansky> Also, it is normal to have typeclasses (similar in style to Java interfaces) with laws ‚Äì so for instance you could have a "Group" typeclass and have associated laws that typeclass instances have to satisfy
11:57:57 <agibiansky> For example, check out the Monoid and Semigroup typeclasses
11:58:12 <whale> agibiansky: whoah, that's cool.
11:58:32 <Hijiri> well they don't *have* to satisfy them, but it's usually considered a bug if they don't
11:58:32 <Spackenzergie> Well, I havent really tried anything because I have no clue how I would go about it. In Java I would just make a variable for the index and extract the value via that index, but I dont know how one would do that in haskell without defining a second "helper"-function
11:59:06 <barrucadu> Spackenzergie: Do you know how to get the head and tail of a list?
11:59:19 <jorr> Spackenzergie: Well, the helper functions already exist.  Mostly you use map or a fold
11:59:36 <agibiansky> Probably start out with just recursion though :P
11:59:39 <Hijiri> if this was Agda or something you could require proof objects in your definitions of monoid etc
11:59:47 <Hijiri> and then you would really have to provide proofs
12:00:28 <JonReed> Spackenzergie: I'm not sure which kind of permutations you want to implement, but there is http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Data-List.html#permutations and http://stackoverflow.com/questions/24484348/what-does-this-list-permutations-implementation-in-haskell-exactly-do   And there is something similar on 99 problems https://www.haskell.org/haskellwiki/99_questions/Solutions/25  I would recommend checking 99 p
12:00:53 <codygman> Would this be a ghc bug or a hint bug. Where should I submit it? description in readme: https://github.com/codygman/hint-transformers-3-bug
12:01:10 <agibiansky> Spackenzergie: I would recommend starting by reading the first few chapters of Learn You a Haskell: http://learnyouahaskell.com/
12:01:32 <agibiansky> Spackenzergie: Haskell is the type of language where jumping in with no background can be a bit hard, and doing some reading up front really pays off
12:01:32 <juliohm> Haskell users are also on GitHub? Where I can find simple Haskell packages to contribute to?
12:01:42 <Spackenzergie> x:xs is the head; I dont know about tails (if the head isnt the tail as in x:[]); Also Im not allowed to use anything besides arithmetic (and mod/div) and the list operations : and ++
12:01:51 <agibiansky> juliohm: How about IHaskell :P
12:01:59 <JonReed> Spackenzergie: Permutations seems to be complex. There are easier problems to solve if you want to start immediately solving something https://www.haskell.org/haskellwiki/99_questions/1_to_10
12:02:16 <juliohm> agibiansky, IHaskell like IPython?
12:02:44 <agibiansky> juliohm: Yes, IHaskell is a Haskell backend for IPython (it's a shameless plug: https://github.com/gibiansky/IHaskell)
12:02:53 <Hijiri> a tuple could be modelled as a continuation
12:02:59 <barrucadu> Spackenzergie: In (x:xs), x is the head, and xs is the tail
12:03:05 <Hijiri> although you should need tuples for this
12:03:09 <Hijiri> shouldn't
12:03:21 <agibiansky> juliohm: If you're interested in getting some practice I am happy to accept PRs and provide some mentorship on features you would want to implement. There's also many other packages that are probably the same ‚Äì just find things on Hackage you want to improve and talk to the maintainers
12:03:28 <Spackenzergie> Ah, okay. Then I wasnt correct about the vocabulary, sorry!
12:03:58 <juliohm> agibiansky, thanks, I'm more interested in Engineering related packages, if you know any, let me know :)
12:04:09 <juliohm> Math & Engineering
12:04:11 <barrucadu> Spackenzergie: So, you can use that to recursively do something to a list, eg: foo (x:xs) = x : foo xs; foo [] = []
12:04:14 <agibiansky> juliohm: Take a look at accleerate and repa
12:04:21 <agibiansky> Those are array libraries
12:04:22 <juliohm> thanks
12:04:22 <barrucadu> That's a function which just walks through a list, without doing anything to it
12:04:23 <agibiansky> Also hmatrix
12:04:35 <juliohm> Why these names?
12:04:37 <agibiansky> And hlearn for machine learning?
12:04:38 <barrucadu> But you can of course apply functions to things
12:04:44 <whale> So, hypothetically, what mathematical objects are good to model in Haskell?
12:04:51 <agibiansky> accelerate -> accelerate stuff via GPU
12:04:58 <agibiansky> repa = regular parallel arrays
12:05:10 <juliohm> Why not simply matrix?
12:05:27 <Hijiri> you might think it's python matrix or java matrix
12:05:28 <agibiansky> juliohm: I dunno, maybe ease of googling?
12:05:32 <juliohm> and ParallelArrays
12:05:46 <Hijiri> so we need to stick h on to everything
12:06:13 <juliohm> Good names are really important, keep it simple is the philosophy I follow
12:06:15 <agibiansky> whale: Some common ones are functors and monads (from category theory), monoids, semigroups; other category theory ones are popular (see all the stuff that ekmett has done)
12:06:42 <agibiansky> juliohm: there's also ad, for automatic differentiation
12:06:54 <juliohm> cool
12:07:26 <whale> agibiansky: yeah, I remember reading a thread online where many people said that Haskell is close to category theory and used by category theorests.
12:08:21 <agibiansky> whale: I don't know that it's "close to category theory", really ‚Äì it's ultimately a useful real-world programming language and not a mathematical theory ‚Äì but it lets people play around with abstractions easily and the community has a bit of a historical relation to category theory
12:08:59 <whale> agibiansky: Interesting! I know a little, planning on learning more.
12:09:21 <whale> agibiansky: Haskell
12:09:36 <JonReed> agibiansky: How hard it would be to bring vim-bindings to IHaskell/IPython ? IIRC, IPython uses codemirror and codemirror has vim bindings (http://codemirror.net/demo/vim.html)
12:10:52 <agibiansky> JonReed: Hard to say exactly. There's been a fair amount of discussion about this already (https://github.com/ipython/ipython/issues/2319). But IPython is now modal ‚Äì so you have an edit mode and command mode where you can rearrange cells, change their modes, etc
12:11:04 <agibiansky> You'd now need to have 3 modes ‚Äì edit mode, command mode within a cell, and command mode outside a cell
12:11:25 <bernalex> whale: all programming languages are related to category theory. it is incredibly abstract. you could say that group theory and set theory are equally related to category theory.
12:11:25 <agibiansky> So I imagine the answer is ‚Äì possible with a bit of Javascript via a notebook extension, but hard to integrate into the design
12:11:57 <whale> bernalex: Hmm, yeah.
12:12:08 <Spackenzergie> Sorry, my PC just crashed. Someone sent me a few links to implementations of the permutations-question, could you send them again? Thanks!
12:12:20 <bernalex> whale: the thing about haskell, unlike let's say javascript, is that haskell leverages some of the intuitions we gain from category theory in a more obvious manner, even using the category theory terminology for it.
12:12:26 <agibiansky> Spackenzergie:
12:12:36 <agibiansky> Don't know if you saw the link, but learnyouahaskell.com
12:13:04 <Hijiri> Spackenzergie: also check out https://github.com/bitemyapp/learnhaskell (this isn't a permutation question link)
12:13:21 <bernalex> whale: however, you don't need to know any category theory to use haskell. not at all. but *if* you learn some category theory, it is more obvious how it relates to haskell than how it relates to e.g. C, since haskell makes the influence a bit more prominent.
12:13:50 <whale> bernalex: Awesome!
12:14:20 <Hijiri> Spackenzergie: http://lpaste.net/117303
12:14:25 <Hijiri> These are the links, I think
12:14:40 <Spackenzergie> Ew, thanks!
12:15:31 <athan> If you wanted to "cache" things, how would you do it?
12:16:43 <Zekka> athan: The simplest way is to apply the operation whose result you want to cache to every possible input and use laziness
12:17:23 <EvanR> if youre trying to cache in pure code
12:17:27 <EvanR> a pure value
12:17:38 <athan> Zekka: Hmm, alright. It's for web stuff - I'd like to process my css with an external command, then just serve that resulting text
12:17:49 <athan> EvanR: It's in IO :/
12:17:57 <athan> and could be _huge_ (potentially)
12:18:08 <athan> would just having the lazy text value be "enough" to cache it?
12:18:24 <EvanR> not if you re-run the command to reload the css
12:18:37 <EvanR> it cant know that the file didnt change
12:18:50 <athan> oh wait
12:18:57 <athan> okay, I think I get it
12:19:01 <athan> thanks EvanR :)
12:19:14 <athan> (and Zekka :3)
12:19:38 <Zekka> athan: I didn't say as much as might have been useful!
12:19:45 <Zekka> But it sounds like you figured out a lot of it yourself
12:19:47 <athan> :P
12:20:15 <athan> So who here makes 1-off web applications habitually?
12:20:26 <athan> I might have a late Christmas present :)
12:20:28 <agibiansky> athan: I do it sometimes, what sort of stuff?
12:20:44 <athan> agibiansky: https://github.com/athanclark/hi-basic-web-server
12:20:57 <athan> it's only working for scotty right now, but more to come :)
12:21:12 <Zekka> athan: I might start if your present is good
12:21:24 <agibiansky> athan: Oh, cool :) That might be useful, I didn't even know about 'hi'
12:21:26 <athan> I'm gonna add support for hastache and... (maybe less, idk) for front end stuff :)
12:21:37 <agibiansky> I've almost always just started with Snap and hacked stuff together from there
12:21:40 <athan> agibiansky: It's wicked useful :)
12:21:42 <agibiansky> Might try this next time :)
12:22:04 <athan> Zekka: It's the `hi` template :P
12:22:15 <athan> agibiansky: Jolly good year :P
12:22:27 <athan> erm, s/good/new
12:22:28 <agibiansky> I keep itching for a use case for optparse-applicative, too... I wrote my last cmdline UI via cmdargs
12:22:33 <agibiansky> :)
12:22:54 <athan> agibiansky: I'm actually working on an optparse package haha
12:23:07 <athan> agibiansky: I find lots of opportunities at work :P
12:23:30 <athan> I've got another template just with options parsing and quickcheck: https://github.com/athanclark/hi-optparse-qc
12:23:58 <athan> aaaand another that sports a little `Env` reader throughout your app: https://github.com/athanclark/hi-options-env-exe
12:23:59 <athan> :)
12:26:30 <EvanR> question, is there some way to specify a synonym constraint. just an empty class with a bunch of prereqs?
12:26:35 <agibiansky> JonReed: Looks like the vim+ipython thing has been done https://github.com/ivanov/ipython-vimception
12:26:46 <EvanR> rather than listing Num Ord Foo Bar Baz everytime
12:27:09 <agibiansky> EvanR: If you enable ConstraintKinds you can say type MySynonym a = (Num a, Ord a, ...)
12:27:19 <agibiansky> At least I think it's something like that :)
12:27:35 <EvanR> interesting
12:31:29 <mp> hi, regarding #9439, was it fixed in ghc-7.8.4? release notes at https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/release-7-8-4.html says so, but I get this: http://lpaste.net/3629598027724881920
12:33:42 <JonReed> agibiansky: Thx for the link. That looks great.
12:36:45 <nolrai66> Trying to decide wheather I should go buy combined headphone+microphone or go pick up my headphones.
12:36:49 <toblerone> how do you start ghci as super user while still loading ghci.conf? I can't find a flag specifying the configuration file
12:37:12 <nolrai66> SOrry wrong window.
12:37:51 <Spackenzergie> Okay
12:38:03 <Spackenzergie> Actually making progress :D
12:45:19 <athan> EvanR: The constraintKind way is the way to go, for sure :P
12:49:45 <chpatrick> anyone at 31c3?
12:50:34 * hodapp discovers JuicyPixelsa
12:55:45 <EvanR> hodapp: would like to know the thing used to make the pixel format conversion graph diagram
12:59:28 <lifter> How can I get the IP address of a client that has connected to my server when the connection was established w/ the "accept" function from the "Network" module? I'd like to get the IP address rather than hostname.
12:59:44 <hodapp> EvanR: what's this?
12:59:52 <hodapp> http://hackage.haskell.org/package/base-4.7.0.2/docs/GHC-Word.html - also, what's this? deprecated or something?
13:01:33 <hodapp> https://hackage.haskell.org/package/base - none of the 'GHC' links I've tried here are working :|
13:03:39 <EvanR> lifter: you know, the name is usually good enough, and it probably falls back to a numeric string when you cant figure out a reverse hostname
13:04:21 <lifter> EvanR: Like when I accept a connection from outside my LAN?
13:04:55 <EvanR> you can use the lower level version of accept which doesnt try to "pretty print" the address
13:05:30 <EvanR> or you can do a dns lookup on the hostname string
13:05:57 <lifter> hmm, right
13:06:06 <EvanR> just saying the non-numeric version is usually better
13:07:05 <lifter> EvanR: If a client connects from somewhere in the Internet, as oposed to from within my LAN, then do you know if it will always be numeric hostname?
13:07:44 <EvanR> lifter: no, it might be a reverse hostname like we have on irc
13:08:01 <EvanR> not everyone has reverse lookup working though
13:08:38 <EvanR> lifter: but the numeric ipv6 address is going to be long and ugly, if they are connecting via ipv6
13:09:22 <lifter> EvanR: Well really what I want is ideally a way to track my clients with an identifier that is unique as possible to each client
13:10:01 <EvanR> you mean, at a given moment in time
13:10:09 <EvanR> network addresses change, wireless etc
13:10:41 <EvanR> and if so, the unique numeric id you assign to each connection is unique enough for that purpose
13:10:53 <lifter> EvanR: Yeah... I am writing a multi-player online game and I would like to be able to ban players that continuously misbehave.
13:11:13 <EvanR> ah well just use the name that Network accept gives you for that
13:11:22 <lifter> EvanR: think so? ok
13:11:35 <EvanR> itll work just as well as ip address
13:11:41 <EvanR> which is to say, not 100% ;)
13:11:57 <lifter> EvanR: yeah I think that would be the best
13:12:04 <lifter> EvanR: Thanks !
13:30:04 * hackagebot iron-mq 0.1.0.0 - A client for IronMQ message queueing service  http://hackage.haskell.org/package/iron-mq-0.1.0.0 (arnoblalam)
13:30:10 <flexfit> What does "/=" check for when you use it to test for equality?
13:30:44 <lifter> flexfit: inequality
13:30:45 <EvanR> its a method of the Eq class
13:30:53 <EvanR> :t (/=)
13:30:53 <lambdabot> Eq a => a -> a -> Bool
13:31:21 <flexfit> Thanks. I'm going through the learnyousomeashaskell tutorial. I wasn't sure what that symbol meant.
13:31:37 <lifter> flexfit: you might know it as "!=" in other languages
13:31:52 <EvanR> not equal, its supposed to look like math ‚â†
13:32:04 <flexfit> I see. That makes sense.
13:32:46 <benzrf> bbl
13:33:01 <flexfit> Do you know what terminal the author of the learnyousomeahaskell uses? I've been using powershell, but his terminal looks so much more colorful
13:33:29 <indiagreen> flexfit: do you mean LYAH?
13:33:56 <indiagreen> can you give a link to some terminal screenshot from it?
13:34:39 <indiagreen> I only remember colorful code samples, but they're code samples after all and are highlighted with Pygments or something
13:34:49 <flexfit> http://i.imgur.com/6D4trAr.png
13:35:04 * hackagebot webpage 0.0.2 - Organized and simple web page scaffold for blaze and lucid  http://hackage.haskell.org/package/webpage-0.0.2 (athanclark)
13:35:13 <flexfit> I guess it was too good to be true
13:35:23 <indiagreen> no, why, you can get it
13:35:34 <indiagreen> look for ‚Äúghci highlighting‚Äù on Haskellwiki
13:36:27 <athan> ghci highlighting with hscolour is a pain :\
13:36:40 <athan> it caches lines or something
14:15:25 <L8D> What was the name for the type theory about supertypes and subtypes for sum types?
14:15:48 <L8D> there was a paper on it I saw a week or two ago
14:24:18 <lesmon> join
14:24:19 <lesmon> quit
14:30:06 * hackagebot criterion-plus 0.1.3 - Enhancement of the "criterion" benchmarking library  http://hackage.haskell.org/package/criterion-plus-0.1.3 (NikitaVolkov)
14:30:20 <gregnwosu> cabal install is showing error "Illegal bang-pattern (use BangPatterns):"
14:32:24 <statusfailed> What's the name of types like Monad and Functor that have an argument? Kind?
14:32:31 <statusfailed> or "higher order type"? something like that?
14:32:38 <gregnwosu> higher kinded
14:32:40 <exio4> higher kinded
14:32:50 <statusfailed> heh, thanks :)
14:33:07 <statusfailed> that is, in general, "types that take types as arguments"?
14:33:13 <exio4> yes
14:33:28 <statusfailed> thanks :)
14:34:47 <dhrosa> which order do you run monad transformers in... I have something of type EitherT Error (StateT MyState IO) a, how do I get out an IO (Either Error a) out of that?
14:35:06 <dhrosa> some combination of runEitherT and execStateT
14:35:17 <dhrosa> (given an initial state)
14:36:24 <neuroserpens> Aaaaah... Embrace the nightttt.
14:36:31 <ReinH> :t runEitherT
14:36:32 <lambdabot>     Not in scope: ‚ÄòrunEitherT‚Äô
14:36:32 <lambdabot>     Perhaps you meant ‚ÄòrunWriterT‚Äô (imported from Control.Monad.Writer)
14:36:40 <ReinH> :t execStateT
14:36:41 <lambdabot> Monad m => StateT s m a -> s -> m s
14:37:05 <ReinH> dhrosa: execStateT expects a StateT s m a, runEitherT expects an EitherT.
14:37:11 <ReinH> You have an EitherT, so which do you think you use first?
14:37:33 <dhrosa> so I guess execStateT (runEitherT x) initState ?
14:37:59 <dhrosa> oops I guess I wanted evalStateT
14:38:09 <dhrosa> heh oops
14:39:28 <ReinH> :t runWriterT . flip runStateT ()
14:39:29 <lambdabot> StateT () (WriterT w m) a -> m ((a, ()), w)
14:39:44 <ReinH> :t flip runStateT () . runWriterT
14:39:45 <lambdabot> WriterT w (StateT () m) a -> m ((a, w), ())
14:41:25 <tolt> brisbin: Hey! I'm using your google-oauth2 library but when I try to follow the link I get "Error: redirect_uri_mismatch" in chrome
14:49:27 <gcganley> what is the haskell/emacs specific channel?
14:50:52 <Haskellfant> gcganley: #haskell-emacs
14:51:00 <gcganley> Haskellfant: thank you
14:53:05 <u-ou> why isn't there a #haskell-vim? :(
14:53:21 <apo> u-ou: That's this' channel ;)
14:53:28 <u-ou> :D
14:54:00 <jpsantos_> Now if he had a decent way to check Haskell source within vim...
14:54:06 <jpsantos_> if we had*
14:55:10 <jpsantos_> hdevtools is the best you can do currently, but it crashes all the time.
14:55:44 <lpaste> gregnwosu pasted ‚Äúcan anyone help‚Äù at http://lpaste.net/117309
15:00:21 <gregnwosu> i have some leads, installing cabal, then im going to try and just download source
15:14:26 <johannesbodannes> are there good, existing methods in haskell for /creating/ distributed storage? comparable to acid-state, but scalable I guess. assuming that I didn't want to use some prepackaged solution like DynamoDB/DocumentDB/MongoDB
15:15:01 <johannesbodannes> structured data, I mean
15:17:03 <EvanR> wonders if those prepackaged solutions count as scalable or structured
15:17:26 <carter> johannesbodannes: what notion of distributed do you want
15:17:39 <carter> johannesbodannes: 1) if you dont need distributed, its a lot easier
15:17:50 <johannesbodannes> geared towards running across multiple virtual machines
15:17:56 <johannesbodannes> scaling out
15:17:58 <carter> 2) what workload
15:18:06 <johannesbodannes> so running on a cloud service
15:18:08 <carter> scalling out is a design pattern, not a workload :)
15:18:09 <kaiyin> I am wondering why div is not implemented like this:
15:18:10 <kaiyin> div1 :: Num a => a -> a -> Maybe a
15:18:10 <kaiyin> div1 _ 0 = Nothing
15:18:10 <kaiyin> div1 x y = Just $ x `div` y
15:18:36 <carter> johannesbodannes: if its read only, use bittorent? :)
15:19:06 <Lokathor> well, though many things should maybe be more type safe in the standard library, usability does take a mild hit with excessive Maybe and Eithering
15:19:21 <johannesbodannes> hm, not an option sadly, although I will definitely be able to separate read and update
15:19:32 <carter> johannesbodannes: what workload :)
15:19:39 <EvanR> > let x = 0.0 in case x of 0 -> ()
15:19:40 <lambdabot>  ()
15:19:50 <EvanR> > let x = 0:+0 in case x of 0 -> ()
15:19:51 <lambdabot>  ()
15:20:02 <johannesbodannes> well, storing a bunch of state from computations performed on tens of thousands of source repositories
15:20:06 <carter> johannesbodannes: what types of read/ write volume (what types of queries too?), what ltatency / throughputs
15:20:16 <carter> johannesbodannes: ahh, you can shard it then
15:20:25 <carter> johannesbodannes: the problem is that everyones distributed workload is unique
15:21:11 <EvanR> kaiyin: i think it would be better to statically verify or otherwise prove that an input to division is not zero than do a runtime check
15:21:25 <EvanR> which is more along the lines of dynamic typing
15:21:45 <johannesbodannes> is there a particularly excellent approach to sharding data in haskell?
15:21:46 <EvanR> in many cases, there is nothing you SHOULD do with a Nothing from that, because its impossible. so youd just put error "impossible!"
15:22:38 <johannesbodannes> abstracting the complexity of it away, I mean
15:24:17 <kaiyin> EvanR, what do you mean statically verify?
15:24:25 <carter> johannesbodannes: honestly, thats still something that doesnt have a good off the shelf solution
15:24:41 <Lokathor> verify using other knowledge about the program that a 0 will never be passed into your div
15:24:46 <johannesbodannes> ah, hm i'll have to think about building one possibly then. thanks, carter!
15:24:50 <kaiyin> :t div
15:24:51 <lambdabot> Integral a => a -> a -> a
15:25:04 <carter> johannesbodannes: theres a few different project currently or soon underway by various industrial haskellers that do dddress this
15:25:15 <carter> johannesbodannes: but remember, everyones distributed system IS unique
15:25:20 <EvanR> your version does a check at runtime for every division. in many cases that runtime check will always give Just, because of the nature of the code. but you still would have to handle the Nothing somehow, which would be unnatural
15:25:23 <carter> johannesbodannes: i think by this time next year theres gonna be a few
15:25:36 <johannesbodannes> that sounds promising
15:26:08 <kaiyin> EvanR, ok, I got your point. The type of div, for example, is dishonest.
15:26:10 <kaiyin> :t div
15:26:11 <lambdabot> Integral a => a -> a -> a
15:26:16 <EvanR> kaiyin: the reasons why it would be always Just arent handled by the type system in this case, like many other situations. its all in the programmers head
15:26:22 <kaiyin> It does not always return an Integeral.
15:26:35 <EvanR> kaiyin: more precisely, div is a partial function most of the time
15:26:53 <EvanR> in haskell every type has bottom, including Int or Float
15:27:02 <EvanR> (well except unboxed i guess)
15:28:46 <Myrl> > div 1.0 2.0
15:28:47 <lambdabot>  No instance for (GHC.Show.Show a0)
15:28:47 <lambdabot>    arising from a use of ‚ÄòM576440786353414151825038.show_M5764407863534141518...
15:28:47 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
15:28:53 <Myrl> :<
15:29:11 <EvanR> > 1.0 / 2.0
15:29:12 <lambdabot>  0.5
15:31:26 <Lokathor> question: when making a new module that's primarily adding some helper features to an existing standard library, should it be named as a sub-module of that standard module? eg: when making a dice rolling module, should it be named System.Random.Dice?
15:31:43 <Lokathor> or is that considered bad form
15:34:25 <EvanR> kaiyin: its possible to declare these kinds of facts about arguments with dependent types, you might want to look into
15:37:56 <kaiyin> EvanR, what should I look into? :-)
15:40:43 <EvanR> kaiyin: one way to make division a total function is to require evidence that the divisor isnt zero, as an extra argument. because the type of the evidence is parameterized by some numeric value, youd need dependent types
15:41:55 <kaiyin> EvanR, sounds advanced for me atm, will check that later. Thanks!
15:45:04 <EvanR> divMod' : (n:Nat) -> (m:Nat) -> NonZero m -> (Nat,Nat)
15:52:41 <adas> I have 2 functions fn1 and fn2. If I comment fn1, fn2 runs fine. But if I uncomment fn1, ghci shows errors in both fn1 and fn2. How is that possible? There is no explicit relationship between fn1 and fn2. They are 2 different functions doing 2 different things..
15:53:08 <exio4> do you have any example code?
15:53:41 <adas> yupp .. i can put it on lpaste
15:53:47 <adas> one moment
15:55:45 <lpaste> adas pasted ‚Äúconundrum‚Äù at http://lpaste.net/4602039697974231040
15:57:16 <adas> FN2 works when FN1 is commented. But FN2 and FN1 don't work when FN1 is uncommented.. even though there is no explicit relationship between them
15:57:52 <Pamelloes> Probably a syntax error in Fn 1, then. What error does ghc give you?
15:58:15 <exio4> adas, are you uncommenting them properly? (I just had to triple check when I tried to uncomment is here :P), and it typechecked (without the type signature)?
15:58:55 <EvanR> adas: you are doing x^n where x is a Double and n is an Int, right?
15:59:02 <EvanR> :t (^)
15:59:03 <lambdabot> (Num a, Integral b) => a -> b -> a
15:59:10 <EvanR> hmm right
15:59:19 <pavonia> adas: Btw, are you aware that {- ... -} also works for multiple lines?
15:59:43 <adas> pavonia: yup..the vim commenter i use comments it that way
15:59:54 <pavonia> Oh, okay
16:00:44 <EvanR> you are doing nu / d, where nu is a Double and d is an Int
16:00:47 <EvanR> :t (/)
16:00:48 <lambdabot> Fractional a => a -> a -> a
16:00:52 <lpaste> adas pasted ‚Äúerrors i get when both uncommented‚Äù at http://lpaste.net/2148589949971070976
16:01:20 <EvanR> in / the two operands must be the same type
16:01:31 <EvanR> the top error said that in so many words
16:02:14 <adas> EvanR: yes , i know there is an error in FN1. but why does it also spit out errors about FN2?
16:02:45 <Pamelloes> adas: Errors compound. Once one thing is screwed up, other things get screwed up, too.
16:03:13 <adas> Pamelloes: but those functions don't even call each other
16:03:55 <EvanR> somewhere else in the program these two functions might be used in the same place and its somehow interacting through type inference
16:04:26 <EvanR> it doesnt know if you screwed up FN1's implementation or type signature (just guessing) so who knows
16:05:03 <adas> EvanR: and about the error in FN1, why can't 'd' be inferred as a Double when the type returned by 'product' is "Num a"
16:05:10 * hackagebot iron-mq 0.1.1.0 - Iron.IO message queueing client library  http://hackage.haskell.org/package/iron-mq-0.1.1.0 (arnoblalam)
16:05:22 <EvanR> the way you wrote it, d is definitely a Double
16:05:36 <EvanR> errr definitely a Int
16:05:41 <EvanR> because n is an Int
16:06:07 <adas> EvanR: yup..sorry.. just noticed
16:06:14 <EvanR> there would need to be some implicit conversion somewhere, and in haskell thats eschewed
16:06:29 <pavonia> adas: Do the errors for FN2 go away if you replace one of the two 1s be another number literal?
16:07:23 <adas> pavonia: The errors in FN2 go away if I comment out FN1
16:07:36 <EvanR> fix f1 and continue
16:07:46 <pavonia> adas: Yeah, but that wasn't my question ;)
16:08:23 <adas> pavonia: oh sorry .. you mentioned "one of the two 1's" .. which "1" are you talking about?
16:08:41 <pavonia> It doesn't matter which
16:08:57 <pavonia> My guess is it's defaulting both to the same type
16:09:44 <dgomez_> :t fi
16:09:45 <lambdabot>     Not in scope: ‚Äòfi‚Äô
16:09:45 <lambdabot>     Perhaps you meant one of these:
16:09:45 <lambdabot>       ‚Äòpi‚Äô (imported from Prelude),
16:09:53 <dgomez_> :v
16:09:59 <dgomez_> :t v
16:09:59 <adas> pavonia: but why does it default to same type for both functions when they are not related
16:10:00 <lambdabot> Expr
16:10:13 <EvanR> your f2 function compiles fine
16:10:17 <adas> damn .. so confusing
16:10:24 <pavonia> adas: I don't know, somethimes GHC is weird
16:10:46 <EvanR> without some type annotation, numeric literals will default to Integer or Double depending on how its used
16:11:01 <pavonia> But actually that shouldn't be a problem because both are Ints here
16:11:16 <EvanR> the 1 in f2 is probably Integer
16:11:35 <EvanR> :t let x = 1 + 1 in x
16:11:35 <lambdabot> Num a => a
16:11:48 <EvanR> :t (\x -> 1 + x) 1
16:11:49 <lambdabot> Num a => a
16:11:50 <adas> EvanR: yup itss an integral because of the "even"
16:12:25 <EvanR> Integer i mean, its inconsequential
16:12:39 <EvanR> nothing wrong with that function in isolation
16:13:23 <Mikke> this is really my question
16:13:46 <adas> FN2 is still rigght when FN1 is uncommented. And no where in FN1 do I call FN2 or vice versa .. So i really don't understnad why uncommenting FN1, creates errors in FN2
16:14:51 <EvanR> adas: is there other code?
16:15:02 <EvanR> over here i cant reproduce that effect
16:15:59 <adas> yup .. let me paste the whole thing
16:16:37 <EvanR> > [1.0 .. ]
16:16:38 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0...
16:17:18 <EvanR> > [1 .. 3.0]
16:17:19 <lambdabot>  [1.0,2.0,3.0]
16:17:33 <adas> > [1.1 .. 1.5]
16:17:35 <lambdabot>  [1.1]
16:17:52 <EvanR> in helper, do nu / (fromIntegral d) to fix the first bug
16:18:47 <lpaste> adas pasted ‚Äúentire code‚Äù at http://lpaste.net/4670180071384809472
16:20:17 <EvanR> that code compiles when i uncomment helper and fix the one bug
16:20:30 <EvanR> ghc 7.6.3
16:21:17 <adas> EvanR: yup. if i fix FN1, all is fine.. its only when there is an error in FN1, ghci gives erros for FN2 as well
16:21:33 <adas> ghc 7.8.3
16:21:50 <EvanR> do you have a module declaration at the top
16:21:53 <Mikke> http://alexpetty.com/
16:22:13 <adas> EvanR: nothing. i have imported no modules ..
16:22:28 <EvanR> ok, deleting my module Main where
16:22:49 <Mikke> cool
16:22:57 <adas> the link to the last lpaste is the entire file
16:23:14 <Cale> > [1.1 .. 1.0] -- this part of the spec is a bit counterintuitive.
16:23:14 <EvanR> i get "main not defined in module Main"
16:23:15 <lambdabot>  [1.1]
16:23:25 <Cale> > [1.1 .. 0.8]
16:23:26 <lambdabot>  [1.1]
16:23:29 <Cale> > [1.1 .. 0.4]
16:23:31 <lambdabot>  []
16:23:38 <EvanR> oO
16:24:08 <adas> > [1.1 .. 1.5]
16:24:09 <lambdabot>  [1.1]
16:24:12 <adas> ^^ even that
16:24:22 <EvanR> well it goes up by 1
16:24:27 <Cale> Well, that makes sense -- the default step size is 1
16:24:42 <Cale> It's more what happens around the boundaries which is funny
16:24:47 <Cale> > [1.1 .. 1.7]
16:24:48 <lambdabot>  [1.1,2.1]
16:24:57 <EvanR> oO
16:25:38 <Cale> If it's within half a step size in either direction, you get that last element.
16:26:15 <Cale> Like, the value of the second endpoint only matters up to that level of granularity
16:27:16 <adas> so thats one quirkiness. and the code I paste on lpaste is another
16:27:36 <Mikke> !words 5
16:27:36 <EvanR> i cant reproduce your thing
16:27:49 <arnoblalam> hola!
16:28:00 <adas> EvanR: on 7.6.3, uncommenting FN1 does not create errors in FN2?
16:28:16 <EvanR> i cant get any errors in FN2 no matter what
16:28:32 <arnoblalam> I just published my first library on Hacakge: http://hackage.haskell.org/package/iron-mq-0.1.1.0
16:28:34 <adas> EvanR: regardless of whether FN1 is uncommented or not?
16:28:35 <EvanR> i get errors if i remove my module declaration to match your paste
16:28:44 <EvanR> yes, no matter what
16:28:47 <arnoblalam> (sorry for the spamming, I guess I‚Äôm excited)
16:29:22 <adas> can someone with 7.8.3 test it out please
16:29:35 <Mikke> :D
16:29:40 <adas> im using a sandbox .. but i don't think that would matter
16:30:48 <Mikke> :)
16:31:53 <Lokathor> so if i'm using (+) to fold a non-infinite list, it doesn't matter if i fold from the left or right, does it?
16:32:15 <EvanR> it has different performance characteristics
16:32:23 <n4x> and are for "different things"
16:32:33 <godel> Lokathor: it's faster to fold from left I think
16:32:53 <godel> or the other way round lol
16:32:57 <n4x> I really think a lazy foldl is useless
16:33:04 <Lokathor> well, isn't a strict fold the best for performance (I'm basically just adding a list of ints here nothing fancy)
16:33:06 <n4x> the only way to make a foldl useful is having it strict
16:33:08 <godel> Lokathor: http://stackoverflow.com/questions/3429634/foldl-is-tail-recursive-so-how-come-foldr-runs-faster-than-foldl
16:33:25 <EvanR> > foldr (+) 0 [1..10000]
16:33:26 <lambdabot>  50005000
16:33:40 <EvanR> > foldl (+) 0 [1..10000]
16:33:42 <lambdabot>  50005000
16:33:44 <EvanR> > foldl (+) 0 [1..100000]
16:33:46 <lambdabot>  5000050000
16:33:49 <EvanR> > foldl (+) 0 [1..10000000]
16:33:53 <lambdabot>  mueval-core: Time limit exceeded
16:34:16 <EvanR> > foldr (+) 0 [1..10000000]
16:34:21 <lambdabot>  mueval: ExitFailure 1
16:34:38 <EvanR> > foldl' (+) 0 [1..10000000]
16:34:40 <lambdabot>  50000005000000
16:35:45 <Iceland_jack> Poor lambdabot
16:35:49 <Cale> Sometimes foldr is faster, even on a non-infinite list, if part of the result can be computed using only part of the input list
16:36:43 <Lokathor> Soooo, strict left fold is the way to go here?
16:36:44 <Cale> You almost never want plain foldl, usually foldl' is really what you're after. GHC is often smart enough that if optimisations are turned on, an occurrence of foldl will turn into foldl' if it would be profitable though.
16:37:32 <karshan> > :t on
16:37:33 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
16:38:09 <karshan> :t on
16:38:09 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
16:38:26 <karshan> > data Row = Row { rowx :: Int, rowy :: Char }
16:38:27 <lambdabot>  <hint>:1:1: parse error on input ‚Äòdata‚Äô
16:41:17 <karshan> :t \a b -> and $ map (\x -> x a b) [((==) `on` ord), ((==) `on` toLower)]
16:41:18 <lambdabot> Char -> Char -> Bool
16:44:15 <gregnwosu> hi whats the command if i want to use cabal to download the source of a library but not to compile it
16:45:31 <johnw> cabal get
16:46:45 <gregnwosu> thanks
16:47:10 <simple_> hello is there a good hacker that has the time to answer some questions?
16:47:38 <n0n3such> simple_: haskell folk don't take kindly to being thought of as hackers
16:47:50 <simple_> ow
16:47:50 <n0n3such> simple_: this is the #pure channel
16:47:53 <simple_> sorry then
16:47:53 <n0n3such> lol
16:47:55 <n0n3such> np
16:47:59 <n0n3such> just kidding
16:48:25 <simple_> im a noob who wants to learn sql injection
16:48:26 <EvanR> n0n3such speaks for all haskellers, and all hackers ;)
16:48:29 <n0n3such> don't worry i am a scala type myself
16:48:31 <n0n3such> lol
16:48:39 <simple_> or other means of hacking a site
16:48:44 <simple_> to get data out of it
16:48:50 <simple_> like paypals and cc's
16:48:51 <EvanR> ok thats a different story
16:49:01 <Pamelloes> simple_: This is not the place for that.
16:49:11 <simple_> ow ok
16:49:13 <EvanR> ask in #freenode
16:49:15 <simple_> have a nice day
16:49:21 <simple_> thanks
16:49:47 <RchrdB> EvanR: *blinkblink* uh‚Ä¶
16:49:50 <neuroserpens> lmfao
16:50:12 <Pamelloes> EvanR: That is one solution.
16:50:14 <neuroserpens> n0n3such: I laughed so hard at that.
16:50:36 <hekmek> the term 'hacker' won't ever see its rehabilitation again -.-
16:50:58 <n0n3such> lol
16:51:17 <Pamelloes> I guess society needs to come up with a new term for the guy who chops my firewood.
16:52:04 <neuroserpens> Pamelloes: I don't think those guys were ever called hackers. Who says that? LoL.
16:52:18 <neuroserpens> I think the most common word is lumberjack.
16:52:27 <Pamelloes> neuroserpens: No one. Nope. Definitely not me. Who would do that? Ridiculous.
16:52:47 <hekmek> ' :D '
16:53:16 <neuroserpens> Pamelloes: Not sure if that's irony.
16:53:37 <Pamelloes> neuroserpens: Neither am I. Let's not look too close at it.
16:53:37 <EvanR> jack this site
16:53:45 <neuroserpens> EvanR: lol
16:53:52 <neuroserpens> Pamelloes: You're on drugs.
16:54:06 <Pamelloes> EvanR: haskell.org?
16:54:32 <EvanR> the planet
16:54:47 <Pamelloes> neuroserpens: No I'm not. I've just ingested substances that induce neural impairments and feelings of euphoria.
16:55:05 <EvanR> speaking of which im going to dinner
16:55:06 <neuroserpens> EvanR: Not enough ubiquity yet for the world to get... jacked
16:56:32 <gregnwosu> is there a successor to ffipkg aka hsffig
16:56:54 <gregnwosu> wont install for love nor money
16:57:54 <Buttons840> can someone recomend a good resource for learning the number typeclasses?
16:57:56 <gregnwosu> also note its about 3 years since it was touched
16:58:06 <EvanR> Buttons840: haskell report
16:59:25 <athan> If I'm doing lookups on a (pretty large data structure), what would be a good one to use? Aeson? Just a `Data.Map`? I'm looking for something that can handle concurrent requests well (from WAI), but not something that needs to be writable. Any ideas? :s
17:01:28 <EvanR> all immutable structures can do "concurrent requests" for free
17:01:43 <EvanR> Data.Map is a good general purpose structure for updates
17:02:11 <EvanR> Aeson is only for reading and writing json data
17:04:34 <Pamelloes> If I have  a placeholder function, what else do I need to write besides a type statement to compile?
17:04:49 <Rembane> Pamelloes: What should the placeholder function do?
17:05:09 <Pamelloes> Ideally absolutely nothing. Perhaps error, but it doesn't really matter.
17:05:51 <Hijiri> undefined is standard placeholder body
17:06:22 <Pamelloes> So just write "function = undefined"?
17:06:33 <Rembane> Yes
17:06:44 <Hijiri> @let tooLazyToWrite :: a -> b; tooLazyToWrite = undefined
17:06:46 <lambdabot>  Defined.
17:06:49 <athan> EvanR: That just blows my mind
17:07:03 <athan> Anyway, I'm gonna go balffle. Thanks :)
17:07:38 <karshan> hey I'm trying to create a heterogenous list using ExistentialQuantification but I'm running into errors, would appreciate some help: http://lpaste.net/117315
17:08:18 <karshan> specifically I'm trying to rewrite [((==) `on` f), ((==) `on` g)] as map ((==) `on`) [f, g]
17:08:33 <karshan> f :: a -> b, g :: a -> c
17:08:46 <athan> EvanR: If I force an aeson value to normal form, will it "return a value" faster?
17:10:01 <EvanR> athan: i guess, but you basically just moved the time to evaluate from one place to the other
17:10:08 <athan> hmm, okay
17:10:12 <athan> man, thank you
17:10:15 <athan> this is crazy
17:10:30 <EvanR> athan: you said it was huge, so by evaluating all of it, you might be taking up more space by forcing it all
17:10:51 <athan> karshan: Why not `map (\x -> (==) `on` x) [f,g]`?
17:11:05 <EvanR> (that by waiting until anyone cares about it)
17:11:06 <athan> EvanR: That's what I'm afraid of :\
17:11:43 <athan> erm... sorry ._.
17:11:46 <EvanR> the first time you evaluate some branch, it will be "cached" by lazy evaluation
17:12:11 <athan> Garbage collection is time based, or actually based on completing a computation?
17:13:07 <EvanR> theres the idle collector, and the one when you are running out of quick-to-allocate memory, but i dont know all the various strategies
17:13:19 <Buttons840> I'm looking at the FFI chapter from RWH. It looks like realToFrac :: Double -> CDouble ? has this changed since RWH was published?
17:13:55 <Welkin> :t realToFrac
17:13:56 <lambdabot> (Real a, Fractional b) => a -> b
17:14:01 <EvanR> you can force the gc to run whenever you want
17:14:14 <karshan> athan: those should be equivalent. the problem is that you can't create [f,g] because they have different types
17:16:06 <athan> karshan: Oh shoot, I see. Have you thought about using an HList? They're pretty robust, using dataKinds, but that's still really difficult for me so I can't really make garuntees :\
17:16:47 <athan> EvanR: Thank you so much, I'll try to not pester :) This is amazing stuff.
17:17:26 <EvanR> and Data.IntMap is a faster Data.Map if your keys are Ints
17:17:59 <Buttons840> Welkin: I know that; RWH has "fastsin x = realToFrac (c_sin (realToFrac x))", and c_sin :: CDouble -> CDouble and fastsin :: Double -> Double -- so I don't understand how that conversion is happening?
17:18:15 <Buttons840> unless things have changes since RWH was written? (I know this is often the case)
17:18:44 <athan> EvanR: Ahh makes sense. I've heard wonderful things of STM
17:19:05 <EvanR> realToFrac :: Double -> CDouble is a specialization of the more general polymorphic realToFracs
17:19:29 <EvanR> s/Fracs/Frac
17:21:10 <Buttons840> perhaps it's not working because I haven't used the FFI language pragma?
17:23:33 <EvanR> athan: this page has a whizbang chart of benchmarking speed of chans, TQueue is in there. STM is cool for general purpose "synchronization"
17:23:41 <EvanR> https://hackage.haskell.org/package/unagi-chan
17:24:24 <athan> EvanR: !! Thank you!!
17:25:06 <EvanR> but if you simply need a single "mutable variable" MVar is probably simpler
17:32:47 <Geekingfrog> I have a general question about stateful computations. I have a given state, and based on it, I should output one command. This will lead to a new state, and I shall repeat the process until some end condition is reached. I'm having trouble organizing this (I'm used to looping so here I'm a bit confused how to proceed)
17:33:24 <Geekingfrog> I'm trying to fit that into a state monad, but I don't know how to feed the new state to the same function over and over
17:34:02 <darthdeus_> hey guys, I'm having trouble setting up GHC path in emacs haskell-mode, getting "<- cabal: The program 'ghc' version >=6.4 is required but it could not be found."
17:34:14 <darthdeus_> though when I checked in "M-x shell" it is in the PATH
17:34:20 <Welkin> Geekingfrog: just fold over your inputs and get and set the state
17:35:16 <Geekingfrog> Welkin, can you elaborate? My input come from stdin
17:35:59 <Welkin> just read your input into some structure, like a list, and fold over the list
17:36:15 <neuroserpens> holy shit man... the more I read of LYAH and RWH the more I love this language... It's like it gives you a feeling that everything just fits and works.
17:37:00 <Geekingfrog> thanks Welkin I'll try that
17:37:01 * solatis just finally 'clicked' with fmap earlier this week and had a similar experience :)
17:37:11 <neuroserpens> type declarations are such efficient documentation by themselves it blows my mind
17:37:13 <Welkin> processInput :: MyState -> a -> MyState
17:37:48 <Welkin> processInput :: MyState -> [a] -> MyState
17:37:57 <Welkin> where [a] is your list of inputs
17:37:58 <EvanR> processInput :: MyState -> Input -> (Command, MyState)
17:38:05 <EvanR> he said
17:38:41 <Geekingfrog> cool, thanks
17:38:44 <EvanR> or :: Input -> State MyState Command
17:38:46 <EvanR> and then
17:39:02 <EvanR> forM inputs processInput :: State MyState [Command]
17:39:13 <EvanR> (if you already have all the inputs)
17:39:51 <Geekingfrog> what if I don't have them all at once?
17:40:15 <EvanR> well, you could try to use a lazy IO list which is reading them, but
17:40:35 <EvanR> where are you getting the inputs
17:40:37 <Geekingfrog> I'm playing around on codingame.com and the constraints are "you get some input and then you have to output your command"
17:40:42 <Geekingfrog> it comes from stdin
17:40:54 <Geekingfrog> I'll see how this works
17:40:57 <EvanR> ok, try getContents then
17:41:13 <EvanR> it produces input lazily using unsafeInterleaveIO
17:41:19 <EvanR> :t getContents
17:41:20 <lambdabot> IO String
17:41:43 <Geekingfrog> getContents should work, thanks, I'll try that
17:41:46 <EvanR> execute that, and treat the string as "the whole input"
17:43:19 <kaiyin> http://en.wikibooks.org/wiki/Haskell/Category_theory
17:43:53 <kaiyin> Could anyone explain why join can be expressed in terms of bind like this: join x = x >>= id ?
17:44:19 <EvanR> :t join
17:44:19 <lambdabot> Monad m => m (m a) -> m a
17:44:24 <EvanR> :t (>>=)
17:44:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:45:27 <Welkin> :t id
17:45:28 <lambdabot> a -> a
17:45:58 <EvanR> its tricky, the result of id is the same as its input, and the output is m a
17:46:00 <Welkin> x :: m (m a)
17:46:04 <EvanR> so you started with a m (m a)
17:46:20 <kaiyin> :t m (m a) >>= id
17:46:21 <lambdabot>     Couldn't match expected type ‚Äòt0 -> m (m b)‚Äô
17:46:21 <lambdabot>                 with actual type ‚ÄòExpr‚Äô
17:46:21 <lambdabot>     The function ‚Äòm‚Äô is applied to one argument,
17:46:37 <Welkin> `a >>= return . id` would produce m (m b)
17:46:50 <EvanR> :t (>>=) `asAppliedTo` id
17:46:51 <lambdabot> (a -> a) -> (a -> a -> b) -> a -> b
17:46:59 <EvanR> hmm
17:47:10 <EvanR> :t (flip (>>=)) `asAppliedTo` id
17:47:11 <lambdabot> Monad m => (m b -> m b) -> m (m b) -> m b
17:47:43 <kaiyin> :t (>>=) m (m a) id
17:47:44 <lambdabot>     Couldn't match expected type ‚Äò(a1 -> a1) -> a0‚Äô
17:47:44 <lambdabot>                 with actual type ‚ÄòExpr‚Äô
17:47:44 <lambdabot>     In the first argument of ‚Äò(>>=)‚Äô, namely ‚Äòm‚Äô
17:47:58 <Welkin> m (m a) is a type
17:48:30 <Welkin> :t (Just 4) >>= id
17:48:31 <lambdabot> Num (Maybe b) => Maybe b
17:48:33 <kaiyin> ok
17:49:19 <Welkin> > (Just (Just 4)) >>= id
17:49:21 <lambdabot>  Just 4
17:49:29 <Welkin> > (Just (Just 4)) >>= return . id
17:49:31 <lambdabot>  Just (Just 4)
17:49:38 <EvanR> > join (Just (Just 4))
17:49:39 <lambdabot>  Just 4
17:49:56 <Welkin> :t Just ( Just 4)
17:49:57 <lambdabot> Num a => Maybe (Maybe a)
17:50:38 <EvanR> > join Nothing
17:50:40 <lambdabot>  Nothing
17:50:50 <kaiyin> so the type sig of >>= is (>>=)  :: m a -> (a -> m b) -> m b
17:51:31 <kaiyin> if I feed a m (m a) and id to it, it should be something like (>>=) m (m a) -> id ->  m b
17:51:48 <kaiyin> while the type sig of join is
17:51:50 <kaiyin> :t join
17:51:51 <lambdabot> Monad m => m (m a) -> m a
17:52:07 <EvanR> :t (>>= id)
17:52:08 <lambdabot> Monad m => m (m b) -> m b
17:52:18 <EvanR> thats what happens if you feed id to it
17:52:27 <kaiyin> I don't understand how these two can agree with each other.
17:52:40 <kaiyin> But how did it happen?
17:52:53 <EvanR> so id in this case has the type
17:53:02 <EvanR> m a -> m a
17:53:10 <kaiyin> yes
17:53:20 <EvanR> rather, m b -> m b
17:53:26 <kaiyin> why?
17:53:32 <EvanR> the output must be m b
17:53:39 <pavonia> kaiyin: You feed id to the second argument of (>>=), so you have to match (a -> m b) and (c -> c)
17:54:14 <EvanR> c = m b, and c = c, so a = m b
17:54:22 <Welkin> (a -> m b) where a i actually m (m b)
17:54:28 <Welkin> a is*
17:54:30 <kaiyin> how did c come up?
17:54:37 <Welkin> er
17:54:40 <kaiyin> :t >>=
17:54:40 <lambdabot> parse error on input ‚Äò>>=‚Äô
17:54:45 <EvanR> no a in (a -> m b) is m b
17:54:47 <pavonia> kaiyin: That's the type of id
17:54:48 <kaiyin> :t (>>=)
17:54:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:54:50 <Welkin> :t (>>=)
17:54:50 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:55:00 <athan> EvanR: Yeah, it's a 1.5MB json file haha
17:55:13 <Welkin> yes EvanR
17:55:28 <kaiyin> :t id
17:55:29 <lambdabot> a -> a
17:55:57 <EvanR> athan: so ideally when you parse that thing, youll basically have a 1.5 meg bytestring sitting in memory with some thunks pointing into it in various places. and when you want to turn some of them into values, you do. but not all of them
17:56:18 <pavonia> kaiyin: The types of (>>=) and id both have an a, but they are different, you can't use them as the same type variable here
17:56:30 <Welkin> in this case, the m a is actually m (m a)
17:56:30 <athan> EvanR: Ahh, okay that makes sense
17:56:31 <kaiyin> pavonia, so I have to match c -> c with a -> m b
17:56:32 <athan> hmm
17:56:39 <pavonia> Yes
17:56:57 <kaiyin> where a is actually m a
17:57:05 <Welkin> in fact, replace a with m b
17:57:07 <EvanR> yeah rename all the variables at the start
17:57:26 <EvanR> or use de bruijn indices ;)
17:57:32 <kaiyin> ok, let's start over.
17:57:38 <kaiyin> (>>=)  :: m a -> (a -> m b) -> m b
17:57:47 <EvanR> ok, and id :: c -> c
17:57:50 <kaiyin> (>>=)  :: m m a -> (m a -> m b) -> m b
17:57:55 <kaiyin> right?
17:58:05 <kaiyin> since a has changed into m a
17:58:11 <pavonia> No
17:58:18 <EvanR> a changes to m b
17:58:42 <kaiyin> how come?
17:58:51 <EvanR> type inference
17:58:55 <Hijiri> because id is a -> a
17:58:58 <pavonia> kaiyin: You match (a -> m b) with (c -> c), so c = m b and c = a. Then follows a = m b
17:58:59 <Hijiri> the types have to be the same
17:59:04 <kaiyin> c -> c matches a -> mb
17:59:14 <n4x> EvanR: type inference? you mean unification?
17:59:17 <pavonia> kaiyin: Now you can replace each a by m b
17:59:20 <EvanR> yeah
17:59:36 <kaiyin> or I can replace m b with c
18:00:22 <EvanR> m b is better to show than c because its more descriptive
18:00:29 <kaiyin> ok
18:00:32 <kaiyin> got it
18:00:49 <kaiyin> Now it's (>>=)  :: m a -> (m b -> m b) -> m b
18:01:12 <kaiyin> then (>>=)  :: m m b -> (m b -> m b) -> m b
18:01:22 <kaiyin> since a = m b
18:01:26 <EvanR> thats a possible specialization of the full type of >>=
18:01:49 <EvanR> if you wanted to actually apply id on the left, (>>=) :: m (m b) -> m b
18:01:54 <EvanR> the middle part goes away
18:02:25 <EvanR> if you wanted to actually apply id on the left, (>>= id) :: m (m b) -> m b
18:02:40 <kaiyin> Now this is mysterious, how did it go away?
18:02:42 <EvanR> on the right :|
18:02:50 <EvanR> like this
18:02:55 <EvanR> :t (+)
18:02:56 <lambdabot> Num a => a -> a -> a
18:02:59 <EvanR> :t (+ 5)
18:02:59 <lambdabot> Num a => a -> a
18:03:45 <pavonia> kaiyin: You have a function :: x -> y and apply that to an argument :: x, so the result is :: y
18:04:21 <kaiyin> ok, but why does it have to id then?
18:04:23 <pavonia> kaiyin: Except that here you have a function with two arguments and you apply it to the second argeument, so that one goes away
18:04:30 <kaiyin> It can actually be any function.
18:04:47 <EvanR> not if its going to be generic
18:04:54 <pavonia> It can be any function that matches it's type
18:05:11 <pavonia> But if you use another function, you will get other results of course
18:05:26 <kaiyin> sure, anything like a -> m b
18:05:47 <EvanR> without knowing what a or b is, the options are limited
18:06:05 <EvanR> id works
18:06:20 <EvanR> (\x -> return x) would work
18:06:30 <EvanR> which is return
18:06:50 <kaiyin> Ok, I see, you need to some how convert m (m a) into m (m b), hence you need id.
18:07:24 <EvanR> converting m (m b) into a m b
18:07:35 <johnw> how does id come into play there?
18:07:48 <EvanR> for particular m, you can customize how this works, but youre situation is the generic one
18:08:00 <EvanR> your*
18:08:30 <EvanR> johnw: join can be (>>= id)
18:09:18 <johnw> ahh
18:09:59 <EvanR> :t (>>= return)
18:10:00 <lambdabot> Monad m => m b -> m b
18:10:07 <EvanR> nevermind, return would not work
18:10:18 <johnw> id still won't convert a -> b
18:10:31 <johnw> but the m (m b) -> m b, I see that
18:10:37 <kaiyin> Let's replay this thing:
18:10:38 <kaiyin> m a -> (a -> m b) -> m b
18:10:38 <kaiyin> Plug id in as the second arg, you get
18:10:38 <kaiyin> m (m b) -> (m b -> m b) -> m b
18:10:38 <kaiyin> Since the second arg is provided, now it's a partial function:
18:10:38 <kaiyin> m (m b) -> m b
18:10:48 <EvanR> it coerces the a in m a to be m b
18:10:54 <johnw> how?
18:11:01 <EvanR> since the output of >>= is m b
18:11:04 <johnw> you mean, it forces a ~ b
18:11:09 <EvanR> yeah
18:11:12 <EvanR> no
18:11:16 <EvanR> a -> m b
18:11:17 <pavonia> No, a ~ m b
18:11:22 <johnw> right, ok
18:11:32 <johnw> now I'm up to speed
18:12:09 <EvanR> kaiyin: by "plugging in" you mean ">>= as applied to id on the right"
18:12:11 <pavonia> kaiyin: A partial function is something different, here it's simply function application
18:13:21 <pavonia> (>>= id) is actually (\x -> (>>=) x id), not sure if that makes things more clear
18:13:43 <johnw> maybe saying \x -> x >>= id?
18:13:49 <EvanR> yeah the original question was about join x = x >>= id
18:14:27 <johnw> this is a case where nothing beats equational reasoning
18:14:33 <johnw> transform >>= until you have join x = join x
18:14:50 <EvanR> and it seems id is the only function you can put there to do it
18:14:56 <EvanR> satisfy joins type
18:15:14 <johnw> yes, because join only affects the context, never the type underneath
18:15:23 <kaiyin> (\x -> (>>=) x id), yeah, pavonia , that what I meant by partial function. Maybe the term is used incorrectly here.
18:15:48 <johnw> kaiyin: you meant an operator section, or a partial application
18:16:17 <kaiyin> Cool, thanks, johnw .
18:16:44 <EvanR> join is cool
18:16:45 <kaiyin> :t fmap
18:16:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:17:09 <EvanR> :t cojoin
18:17:10 <lambdabot>     Not in scope: ‚Äòcojoin‚Äô
18:17:10 <lambdabot>     Perhaps you meant one of these:
18:17:10 <lambdabot>       ‚Äòconjoin‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
18:17:31 <pavonia> :t conjoin
18:17:32 <lambdabot> Testable prop => [prop] -> Property
18:17:42 <johnw> :t duplicate
18:17:43 <lambdabot>     Not in scope: ‚Äòduplicate‚Äô
18:17:43 <lambdabot>     Perhaps you meant one of these:
18:17:43 <lambdabot>       ‚Äòreplicate‚Äô (imported from Data.List),
18:17:48 <johnw> :t Control.Comonad.duplicate
18:17:49 <lambdabot> Control.Comonad.Comonad w => w a -> w (w a)
18:19:35 <EvanR> :t Control.Comonad.extend id
18:19:35 <lambdabot> Control.Comonad.Comonad w => w a -> w (w a)
18:19:41 <EvanR> hot dog
18:19:54 <kaiyin> About this one: x >>= f = join (fmap f x)
18:20:24 <kaiyin> How does fmap a -> m b  m b work?
18:20:43 <Hijiri> f is a -> mb
18:20:45 <Hijiri> so fmap f is
18:20:53 <Hijiri> m a -> m (m b)
18:21:11 <Hijiri> fmap :: (a -> b) -> f a -> f b
18:21:23 <Hijiri> the b is specialized to m b
18:21:24 <kaiyin> cool.
18:21:35 <EvanR> different bs
18:21:39 <Hijiri> ^
18:22:11 <EvanR> this relies on the monad being defined already being a functor
18:22:27 <EvanR> without using the monad instance
18:25:36 <kaiyin> So the type sig of join (fmap f x) is (a -> mb) -> m a -> m b
18:25:52 <EvanR> no
18:25:58 <kaiyin> why not?
18:26:19 <johnw> it would be if the argument order was "f x"
18:26:21 <EvanR> you used join, so the result is m a
18:26:25 <EvanR> for some a
18:26:43 <jle`> ~.
18:26:46 <jle`> ~
18:26:51 <johnw> EvanR: join (fmap f x) is the same type signature as =<<
18:26:57 <johnw> :t (=<<)
18:26:58 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:27:12 <johnw> (assuming argument order of f before x)
18:27:19 <Welkin> well, it is liftM, not fmap
18:27:40 <Welkin> as was pointed out to me
18:27:46 <EvanR> :t join (fmap f x)
18:27:47 <lambdabot>     Couldn't match expected type ‚Äòm a0‚Äô with actual type ‚ÄòExpr‚Äô
18:27:47 <lambdabot>     In the second argument of ‚Äòfmap‚Äô, namely ‚Äòx‚Äô
18:27:47 <lambdabot>     In the first argument of ‚Äòjoin‚Äô, namely ‚Äò(fmap f x)‚Äô
18:27:56 <johnw> :t \f x -> join (fmap f x)
18:27:57 <lambdabot> (Functor m, Monad m) => (a1 -> m a) -> m a1 -> m a
18:28:09 <EvanR> ok thats different
18:28:20 <johnw> s/a1/a, s/a/b
18:28:23 <EvanR> implicit binding
18:28:26 <EvanR> ;)
18:28:46 <kaiyin> yeah, that's what I posted before.
18:29:06 <jle`> oh sorry
18:29:07 <EvanR> :t x + y
18:29:08 <lambdabot> Expr
18:29:20 <EvanR> :t \x y -> x + y
18:29:21 <lambdabot> Num a => a -> a -> a
18:29:37 <Welkin> :t liftM
18:29:37 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
18:29:40 <kaiyin> But if so, then it's sig is different from that of >>=, isn't it, johnw?
18:29:40 <Welkin> :t fmap
18:29:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:29:59 <kaiyin> :t >>=
18:30:00 <lambdabot> parse error on input ‚Äò>>=‚Äô
18:30:07 <EvanR> Welkin: you cant use liftM here to define >>= can you?
18:30:16 * hackagebot Zora 1.1.21 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.21 (bgwines)
18:31:00 <kaiyin> :t (>>=)
18:31:01 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:31:03 <johnw> kaiyin: correct
18:31:13 <johnw> (=<<) = flip (>>=)
18:31:13 <EvanR> :@src liftM
18:31:23 <EvanR> @src liftM
18:31:23 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:32:26 <kaiyin> Ok, I see, x >>= f = join (fmap f x)
18:32:27 <n4x> :t \f m -> m >>= return.f
18:32:28 <lambdabot> Monad m => (a -> b) -> m a -> m b
18:32:44 <kaiyin> The order of args are flipped here. Thanks, johnw.
18:33:10 <jle`> so is flip fmap going onto base for 7.10?
18:34:53 <Hijiri> what's flip fmap?
18:34:56 <Hijiri> >$< ?
18:35:02 <n4x> <&>?
18:35:57 <jle`> i'm not sure what the name would be
18:36:07 <jle`> it's (<&>) in lens i think
18:36:18 <jle`> but it would be nice sometimes
18:36:21 <edwardk> jle`: thats right
18:36:26 <EvanR> > [1, 2, 3] <&> succ
18:36:27 <lambdabot>  [2,3,4]
18:36:28 <edwardk> jle`: its not going in base though
18:36:35 <jle`> aw ok
18:36:37 <edwardk> its not on the list currently
18:36:42 <jle`> i remember there were some precedence issues with (<&>)
18:36:47 <jle`> but can't it just be like a normal name?
18:36:48 <digilord_> I am trying to install yi on OSX Yosemite and text-icu-0.7.0.0 can't be installed. Is there a brew package I need to resolve this?
18:36:51 <jle`> like forM to mapM
18:36:59 <edwardk> there isn't a good choice available
18:37:00 <n4x> > [1,2,3] <&> succ <&> predd
18:37:01 <lambdabot>  Not in scope: ‚Äòpredd‚Äô
18:37:01 <lambdabot>  Perhaps you meant ‚Äòpred‚Äô (imported from Prelude)
18:37:03 <n4x> > [1,2,3] <&> succ <&> predd
18:37:04 <lambdabot>  Not in scope: ‚Äòpredd‚Äô
18:37:04 <lambdabot>  Perhaps you meant ‚Äòpred‚Äô (imported from Prelude)
18:37:04 <edwardk> for is taken
18:37:05 <n4x> uh
18:37:12 <jle`> flapmap
18:37:20 <Welkin> flapjack
18:37:23 <EvanR> mapF
18:37:34 <edwardk> ehh, i'm not in a hurry to borrow more conventions from scala =)
18:37:38 <johnw> pamf
18:37:49 <jle`> i'm cool with pamf
18:38:23 <jle`> there are a lot of names we could just tack on an F too at the end, onF, withF, etc., but i actually am not too much of a fan of that whole trend
18:38:39 <EvanR> edulerP module where everything literally everything is reversed for your convenience
18:38:57 <johnw> EvanR: what about palindromic names?
18:39:06 <johnw> "ana" will collide
18:39:17 <johnw> (except it's not in base, though)
18:39:23 <EvanR> need to make sure we swap those out with commutative operations
18:39:38 <nkar> and what's the status of having foldable and traversable in prelude?
18:39:53 <EvanR> also, big endian number literals
18:40:04 <EvanR> 0001 + 1 = 1001
18:40:18 <hiptobecubic> I currently have some functions returning `ErrorT e IO a` that also need to share a token that expires and has to be renewed (which requires IO). Where should this thing live?
18:40:51 <jle`> what do you mean by shares token?  can you provide some examples?
18:41:06 <jle`> > pamf (Just 10) $ \x -> show (x + 3)
18:41:07 <lambdabot>  Just "13"
18:41:11 <johnw> hiptobecubic: in an IORef?
18:41:19 <hiptobecubic> jle`, working with a webapi that uses oauth
18:41:43 <hiptobecubic> so every call to the service must include the token, but the token only lasts a few minutes before it must be renewed
18:43:59 <hiptobecubic> johnw, so something like ErrorT a (StateT IORef IO) b, I guess?
18:49:44 <johnw> you only need ReaderT for an IORef
18:50:06 <hiptobecubic> Oh right, the ref is stored and you can write to the ref.
18:50:08 <johnw> if you want to use StateT, then you don't need to pass around an iORef
18:50:31 <johnw> but the performance may be easier to reason about with ReaderT+IORef
18:50:47 <hiptobecubic> Why would you need to pass around an ioref without StateT?
18:51:17 <johnw> usually it's more like a TVar
18:51:22 <johnw> where you get the extra functionality
18:51:26 <johnw> otherwise, no real reason
19:00:17 * hackagebot DigitalOcean 0.1.0.0 - A client library for the DigitalOcean API  http://hackage.haskell.org/package/DigitalOcean-0.1.0.0 (lclarkmichalek)
19:00:41 <agibiansky> I wish hackagebot would only post the link after docs were built
19:10:55 <Lokathor> so, how do we make the lambda bot show the source of a standard library function? specifically sequence
19:11:20 <zRecursive> :src sequence
19:11:21 <augur> @src sequence
19:11:21 <lambdabot> sequence []     = return []
19:11:21 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:11:21 <lambdabot> --OR
19:11:21 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
19:11:32 <augur> oh no who's made it happen?!
19:11:32 <augur> D:
19:11:35 <augur> @src sequence
19:11:35 <lambdabot> sequence []     = return []
19:11:35 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:11:35 <lambdabot> --OR
19:11:35 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
19:11:42 <augur> :src sequence
19:11:52 <augur> sorry zRecursive :(
19:12:04 <zRecursive> welcome
19:12:10 <Lokathor> okay cool, I want to do a conditional sequencing
19:12:18 <augur> Lokathor: explain
19:13:53 <Lokathor> I think my function's type will be ""processTreasures :: [(Int,IO Treasure)] -> IO [Treasure]"", I want to roll 1d100 for each treasure in the input list, and if it rolls below the Int within the tuple it should run that item and put it in the final list, otherwise move past it without adding it.
19:14:39 <augur> Lokathor: so you just want to filter the list first
19:15:19 <Lokathor> well kinda, each item will have a separate 1d100 roll to determine if it goes into the final list, so i can't do a normal filter
19:15:32 <Zekka> @hoogle filterM
19:15:33 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
19:15:33 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
19:15:36 <agibiansky> Lokathor: Separate this into individual bits
19:15:40 <augur> no you dont need filterM for this
19:15:41 <agibiansky> 1. Generate a list of random 1d100s
19:15:45 <Zekka> augur: You're right
19:15:51 <augur> Lokathor: sure you can do a normal filter
19:15:51 <agibiansky> 2. Zip them with the list
19:15:53 <agibiansky> 3. Filter the list
19:15:53 <Zekka> He can generate the random numbers and then purely filter
19:15:59 <Zekka> er, purely is not right
19:16:00 <agibiansky> 4. Run the IO actions
19:16:10 <Zekka> non-monadically filter
19:16:10 <augur> agibiansky's solution is the correct one
19:16:42 <Lokathor> hmm
19:16:43 <augur> the fact that your input list has IO actions is irrelevant since filtering doesnt care about the treasure
19:16:48 <augur> you only care about the associated int
19:16:56 <Lokathor> right, okay
19:17:04 <Lokathor> I'll try this
19:17:04 <augur> UNLESS
19:17:11 <augur> you want to run all the IO actions to make the treatures
19:17:26 <Pamelloes> How do I make a type with restrictions an instance of a class?
19:17:28 <augur> and ignore some of the treasures
19:17:53 <Hijiri> you could purify the dice-rolling a bit if you have them use a local random number generator instead of the global IO one
19:17:59 <Lokathor> well, running all of them and discarding them later isn't the worst, so it's fine
19:18:03 <Welkin> Pamelloes: put the constraints on your functions
19:18:10 <Hijiri> (you would still have to create the local one using IO though, but you could do this separately)
19:18:50 <Lokathor> Also, yes I've got a pure version of dice rolling, but it's a little fiddly for my purposes at the moment, which will just be a thing to print treasure table rolls to the terminal
19:18:51 <Pamelloes> Welkin: I have a type MyType a b that I want to make an instance of Eq, but only if a and b are instances of Eq. What's the syntax for that?
19:19:06 <Welkin> Pamelloes: the same for constraints in functions
19:19:31 <Welkin> instance Eq a, Eq b => Eq (MyType a b) where
19:19:34 <augur> Lokathor: it depends on what you want to do tho
19:19:42 <augur> if you want to run all of their actions, thats one algorithm
19:19:49 <augur> if you want to ignore some actions, thats another algorithm
19:19:51 <Pamelloes> Welkin: Ah, thanks! I was putting the restrictions after the intial Eq.
19:20:03 <augur> the choice is not a huge one, but you gotta pick
19:21:13 <Lokathor> true, true
19:22:26 <solatis> is there a built-in 'inifity' type in haskell? i want to have a function that accepts either a number, or 'infinity' as a parameter (and pattern match on that)
19:22:49 <agibiansky> solatis: Not that I know of
19:23:12 <solatis> ok, so I guess my parameter will look like data RetriesAmount = Infinity | Integer
19:23:13 <Lokathor> you could use a Maybe Int, and have "Nothing" represent the infinity option
19:23:16 <agibiansky> Make your own data declaration, probably
19:23:26 <augur> no dont do that
19:23:30 <augur> dont use Maybe for that
19:24:01 <solatis> right, I felt maybe wasn't a good choice for this too
19:24:12 <solatis> (since it goes against my self-documenting code principe)
19:24:20 <agibiansky> solatis: Yeah, RetriesAmount sounds good
19:25:18 * hackagebot shell-monad 0.3.0 - shell monad  http://hackage.haskell.org/package/shell-monad-0.3.0 (JoeyHess)
19:25:37 <Lokathor> Oh, yeah for retries "Nothing" wouldn't make sense
19:29:27 <godel> solatis: if you do something like "data Nat = Z | S Nat" then defining everything correctly (instance Ord) you can do "infinity = S infinity"
19:30:27 <solatis> godel: sorry i don't follow you
19:30:44 <solatis> i see there's some type of recursion there ?
19:30:46 <agibiansky> godel: I like that solution, it's cute
19:30:54 <agibiansky> solatis: It's an infinite data type, effectively
19:31:04 <agibiansky> kinda like saying inflist = 1 : inflist
19:31:04 <solatis> (sorry i'm still a noob)
19:31:10 <agibiansky> (which is an infinite list of ones)
19:31:19 <solatis> ohh!
19:31:26 <agibiansky> inf = S inf is just an infinite list of S's
19:31:43 <solatis> that is cute
19:31:56 <solatis> and what is Z ?
19:32:01 <agibiansky> zero
19:32:01 <Hijiri> zero
19:32:07 <solatis> hmm
19:32:16 <solatis> and how would that allow me to specify, say, 10 retries?
19:32:38 <agibiansky> iterate S Z !! 10?
19:32:39 <agibiansky> maybe
19:33:14 <solatis> hmm on one way this feels like an elegant solution, on the other hand it also feels like overengineering..
19:33:22 <agibiansky> yeah
19:35:52 <lpaste> Lokathor pasted ‚ÄúNo title‚Äù at http://lpaste.net/117316
19:36:27 <Lokathor> it works
19:42:39 <godel> solatis: yeah, I don't really know what you are doing
19:45:16 <solatis> godel: providing a # of retries to a socket connect function
19:45:55 <solatis> your solution sounds like a really elegant, mathematical solution, but makes the API unecessarily complicated
19:46:19 <godel> ahh, yeah, sure
19:46:59 <godel> solatis: you can do Either Int Something or Maybe Int
19:48:18 <EvanR> you can also define a custom data type for this: TryTimes Int | RetryForever
19:48:28 <agibiansky> guys, we're going in circles on this issue XD
19:48:34 <solatis> yes :)
19:48:37 <EvanR> isomorphic to Maybe but more descriptive
19:48:52 <EvanR> an infinite number of the form infinite = S infinite is hilarious
19:49:02 <godel> yeah, that works
19:49:10 <solatis> which is what i have now :)
19:49:12 <EvanR> a feature not a bug in haskells type system ;)
19:49:35 <nkar> solatis: but you wanted to pattern-match on the constructor, no?
19:49:45 <godel> EvanR: here's a working example by me : https://github.com/gciruelos/haskell-things/blob/master/numbers.hs
19:49:52 <nkar> this definition doesn't allow you to do that
19:50:15 <solatis> nkar: what i have now is this:
19:50:17 <solatis>             case attemptsLeft of
19:50:19 <solatis>              Attempts i -> connectLoop (Attempts (i - 1))
19:50:21 <solatis>              Infinity   -> connectLoop Infinity
19:50:46 <nkar> yeah, I'd use a sum type, I think.
19:51:04 <nkar> I mean a custom sum type, as you did.
19:51:24 <solatis> carter: you are working on numerical-haskell, you don't have an infinite number representation now, do you ? :)
19:51:43 <EvanR> godel: if it was a regular finite number type plus an extra element Omega then youd be able to detect you have one
19:52:01 <carter> solatis: what sorta infinite?
19:52:35 <solatis> data PossiblyInfinite = Infinite | NotInfinite Integer
19:52:50 <solatis> godel came up with quite a clever alternative
19:53:04 <solatis> data Nat = Z | S Nat
19:53:25 <EvanR> data Infinity = S Infinity ;)
19:53:32 <Cale> er
19:53:32 <EvanR> now we know its infinite
19:53:37 <Cale> heh
19:55:03 <EvanR> data Real = Plus Rational Real
19:56:00 <EvanR> data AddInfinity a = Finite a | Infinity
19:56:43 <solatis> yeah that looks more like a generalized definition
19:57:41 <solatis> anyway, so, my question originated from whether or not this was something that's inside Prelude
19:57:43 <haasn> newtype Number = Number { foldNum :: (a -> a) -> a -> a }
19:57:55 <solatis> i think my question is answered by now
19:58:11 <haasn> infinity = Number (\f _ -> fix f)
19:58:27 <godel> haasn can you explain that?
19:58:38 <haasn> church encoding
19:58:48 <haasn> zero = Number (\f x -> x)
19:58:51 <haasn> one = Number (\f x -> f x)
19:58:55 <haasn> two = Number (\f x -> f (f x))
19:58:58 <haasn> ...
19:59:05 <simon> what's the haskell chit-chat channel?
19:59:07 <haasn> infinity = Number (\f x -> f (f (f (f (f (f ...)))))
19:59:11 <godel> ahh nice
19:59:57 <solatis> simon: #haskell-blah
20:00:12 <simon> thanks!
20:00:22 <godel> haasn: that's nice
20:00:36 <godel> I never understood the the use of fix
20:01:08 <solatis> but but.. that requires me to hardcode every possible solution, right ?
20:01:14 <solatis> s/solution/argument/
20:02:15 <carter> what solution concepts/ problems are you actually trying to solve?
20:02:42 <EvanR> (fix (\loop n -> if n==0 then n:(loop (n-1)) else [])) 5
20:02:47 <EvanR> > (fix (\loop n -> if n==0 then n:(loop (n-1)) else [])) 5
20:02:49 <lambdabot>  []
20:02:53 <Welkin> :t fix
20:02:54 <lambdabot> (a -> a) -> a
20:03:04 <EvanR> > (fix (\loop n -> if n>0 then n:(loop (n-1)) else [])) 5
20:03:05 <lambdabot>  [5,4,3,2,1]
20:03:24 <haasn> > fix f
20:03:25 <lambdabot>  No instance for (GHC.Show.Show a0)
20:03:25 <lambdabot>    arising from a use of ‚ÄòM661033631778942214629495.show_M6610336317789422146...
20:03:25 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
20:03:28 <haasn> > fix f :: Expr
20:03:29 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
20:03:42 <Welkin> haasn: how do you apply that to an argument?
20:03:46 <godel> ahh now I understand
20:03:50 <haasn> Welkin: Apply what?
20:03:58 <Welkin> f
20:04:06 <Welkin> or does it not matter
20:04:08 <Welkin> since it's infinite
20:04:16 <EvanR> look at my use of fix above
20:04:20 <haasn> The argument of ‚Äòf‚Äô is ‚Äòfix f‚Äô
20:05:01 <Welkin> oh, you keep an internal state
20:05:06 <Welkin> like an auto
20:05:13 <haasn> For what?
20:05:36 <Welkin> haasn: for applying f multiple times
20:06:02 <EvanR> > fix (1:)
20:06:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:06:05 <haasn> I don't understand what the context is
20:06:07 <godel> but in order for that to be a fixpoint f has to fulfill some requirements right?
20:06:40 <godel> I mean, the name is misleading
20:06:56 <haasn> It's always a fixed point of f.
20:06:57 <EvanR> its the least defined fixed point of f
20:07:36 <Hafydd> If you disagree, give an example of an f for which f (fix f) does not equal fix f.
20:08:11 <godel> f x = e^x
20:08:15 <godel> mh
20:08:17 <godel> shit
20:08:34 <EvanR> e^(fix f)
20:08:50 <EvanR> bottom
20:08:53 <godel> yes, yes
20:09:00 <godel> no
20:09:05 <solatis> you guys seriously lost me in this conversation
20:09:07 <haasn> > fix exp
20:09:07 <godel> actually \infty
20:09:08 <EvanR> exp x
20:09:11 <lambdabot>  mueval-core: Time limit exceeded
20:09:23 <haasn> Actually, depends on your definition of ‚Äòexp‚Äô
20:09:24 <Hafydd> \infty?!
20:09:34 <EvanR> not Infinity since theres no base case
20:09:44 <Hafydd> It never terminates. That's not the same as infinity.
20:09:47 <haasn> But I think that for all real world definitions of exp, it's going to be bottom.
20:10:17 <EvanR> so if f is strict, fix f is bottom
20:10:47 <haasn> Yes.
20:11:00 <godel> ok, I'm thinking it more from the math side
20:11:07 <godel> but I get you
20:11:10 <EvanR> > fix id
20:11:14 <lambdabot>  mueval-core: Time limit exceeded
20:11:19 <EvanR> > fix (const 5)
20:11:20 <lambdabot>  5
20:11:54 <godel> how do you tell lambdabot to show the implementation of fix?
20:12:02 <haasn> @src fix
20:12:02 <lambdabot> fix f = let x = f x in x
20:12:06 <haasn> That doesn't always work.
20:12:08 <haasn> And it isn't always accurate.
20:12:09 <godel> nice
20:12:21 <haasn> I think it's just defined for stuff in Prelude, and the syntax can get weird for typeclass members
20:12:29 <agibiansky> @src ==
20:12:29 <lambdabot> x == y = not (x /= y)
20:12:31 <zq> @hoogle Expr
20:12:32 <lambdabot> Text.Parsec.Expr module Text.Parsec.Expr
20:12:32 <lambdabot> Text.ParserCombinators.Parsec.Expr module Text.ParserCombinators.Parsec.Expr
20:12:32 <lambdabot> package expression-parser
20:12:32 <haasn> A better method is to look them up on hackage
20:12:42 <zq> @info Expr
20:12:42 <lambdabot> Expr
20:12:43 <agibiansky> @src show
20:12:44 <lambdabot> show x = shows x ""
20:12:46 <godel> yes, haasn I'm just lazy
20:12:47 <zq> @src Expr
20:12:47 <lambdabot> Source not found. There are some things that I just don't know.
20:12:48 <agibiansky> @src shows
20:12:48 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:12:54 <zq> where's this thing defined
20:12:57 <EvanR> (iterate (const 5)) 2
20:12:58 <agibiansky> thanks lambdabot
20:13:05 <haasn> agibiansky: Please use lambdabot in a private query for these kinds of things
20:13:06 <EvanR> > (iterate (const 5)) 2
20:13:08 <lambdabot>  [2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
20:13:21 <haasn> zq: It's called simple-expr on hackage iirc
20:13:33 <Welkin> :t iterate
20:13:33 <lambdabot> (a -> a) -> a -> [a]
20:13:54 <Welkin> > iterate id $ 5
20:13:56 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
20:14:10 <Welkin> > iterate (+1) $ 5
20:14:11 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
20:14:11 <zq> haasn: peckej nawt fund
20:14:15 <EvanR> but id is strict, so its fixed point is bottom instead
20:14:22 <zq> haasn: not even showing up in search
20:14:37 <jle`> fix id :: forall a. a
20:14:49 <jle`> and the only thing of type forall a. a is bottom
20:14:56 <jle`> :t fix id
20:14:57 <lambdabot> a
20:15:18 <haasn> zq: Sorry, simple-reflect
20:15:48 <haasn> ‚Äòid‚Äô is a strict function, so by earlier reasoning, ‚Äòfix id‚Äô must be bottom
20:16:43 <godel> jle` so haskell has no inhabited type?
20:16:59 <godel> no noninhabited*
20:16:59 <EvanR> no uninhabited
20:17:14 <godel> yea, that, I'm not native, sorry
20:17:30 <EvanR> yeah only because of bottoms
20:18:10 <jle`> yes, all types are inhabited by at least bottom
20:18:25 <jle`> for a free bottom of any type, `fix id` works
20:18:51 <ggwy> fix id
20:19:08 <godel> jle` this is very interesting
20:19:17 <jle`> people typically use `undefined` in practice
20:19:43 <EvanR> undefined isnt a type though
20:19:48 <jle`> it's a value
20:19:53 <jle`> it's a free bottom of any type
20:20:01 <jle`> > [undefined, fix id, True]
20:20:02 <lambdabot>  [*Exception: Prelude.undefined
20:20:06 <jle`> :t [undefined, fix id, True]
20:20:07 <lambdabot> [Bool]
20:20:15 <godel> bottom :: forall a . a
20:20:15 <johnw> :t undefined :: Void
20:20:16 <lambdabot> Not in scope: type constructor or class ‚ÄòVoid‚Äô
20:20:21 * hackagebot shell-monad 0.3.1 - shell monad  http://hackage.haskell.org/package/shell-monad-0.3.1 (JoeyHess)
20:20:22 <EvanR> to use a type thats spiritually empty you can use Void ...
20:20:22 <Javran> so "fix id" is basically "let x = x in x"?
20:20:31 <EvanR> newtype Void = Void Void
20:20:35 <EvanR> but it has bottom
20:21:03 <jle`> @let data Void
20:21:05 <lambdabot>  Defined.
20:21:16 <jle`> :t fix id :: Void
20:21:16 <lambdabot> Void
20:21:30 <godel> nice
20:21:39 * EvanR casts grisgris on the value of type Void
20:21:45 <jle`> @src fix
20:21:45 <lambdabot> fix f = let x = f x in x
20:21:55 <jle`> Javran: yes, if you look above
20:21:57 <jle`> id x = x
20:22:07 <jle`> so fix id = let x = id x in x, so fix id = let x = x in x
20:22:13 <Javran> i see
20:22:44 <EvanR> fix f = let x = f x in x is hard to read
20:22:53 <EvanR> equationally
20:23:21 <Hafydd> I prefer: fix f = f (fix f)
20:23:31 <johnw> yeah, me too
20:23:53 <HeladoDeBrownie> i think the way they write it is an optimization over that
20:23:54 <johnw> matches up better with newtype Fix f a = Fix (f (Fix f a))
20:24:45 <roconnor> fix f = let x = f x in x is often more efficent than fix f = f (fix f)
20:25:04 <jle`> sharing is caring
20:25:21 <EvanR> can it be automatically rewritten?
20:25:56 <EvanR> i hate spelling things different to coerce the compiler to optimize differently
20:26:07 <roconnor> perhaps, but GHC doesn't do commone subexpression elimination under the nicest of circumstances.
20:26:21 <jle`> @src repeat
20:26:21 <lambdabot> repeat x = xs where xs = x : xs
20:26:28 <jle`> i prefer repeat x = x : repeat x
20:26:56 <jle`> i can see why the former is more efficient, but equivalent
20:27:05 <jle`> but i'd find it pretty hard to teach a compiler how to do so
20:27:07 <godel> why is that better?
20:27:27 <jle`> in the general case, that is
20:27:47 <roconnor> godel: using let (or where) will create a cyclic reference in the heap.
20:28:05 <godel> oh
20:28:26 <roconnor> otherwise the function will just be evaluated repeatedly as needed creating new heap entries.
20:29:00 <godel> I see
20:29:13 <godel> so it is more space-efficient
20:29:25 <roconnor> There are some rare cases when you prefer to call the function as needed.
20:29:57 <roconnor> For example, if the cyclic heap structure is really big and complicated, it may take up a lot of space.
20:30:18 <roconnor> and you'd rather trade that for repeatedly evaluating f and peeking at bits of the result at a time.
20:30:48 <godel> I understand
20:39:20 <hodapp> What is the standard mechanism of correcting a mistake in Hackage? Just emailing the maintainer?
20:42:00 <pavonia> I think so
20:49:19 <trap_exit> is there a channel here dedicated to minimalism ?
20:50:35 <roconnor> minimalism?
20:50:45 <solatis> what do you consider minimalism ? dense code ?
20:51:03 <jle`> the art style?
20:51:12 <solatis> the music style ?
20:51:38 <lifter> < is >
20:52:45 <trap_exit> minimalism = reducing the # of items one owns
20:53:04 <trap_exit> similar to writing code with fewest # of liens o code
20:53:23 <jle`> so, the lifestyle?
20:53:24 <carter> trap_exit: ONE LINE
20:53:26 <trap_exit> yes
20:53:30 <carter> just {;;;}
20:53:48 <trap_exit> carter: do you live life with just a laptop and nothing else?
20:53:59 <carter> nope
20:54:02 <lifter> the only bk I own is LYAH
20:54:02 <carter> i like things
20:54:09 <carter> lifter: thats sad
20:54:10 <carter> :)
20:54:12 <carter> or cute
20:54:14 <carter> idk which
20:54:16 <trap_exit> lifter: I gave my copy away after I read it
20:54:18 <lifter> it's a joke
20:54:29 * trap_exit is serious
20:55:28 <lifter> maybe try ##haskell-blah?
20:55:34 <trap_exit> ouch
21:02:53 <simon> why would you ever want to use a non-deterministic parser combinator library compared to a backtracking parser combinator library?
21:03:31 <dhrosa> hello, anyone here used aeson with generics? I'm wondering how to deal with record names that conflict with the language
21:03:47 <dhrosa> like, records named id and type
21:04:01 <dhrosa> do I have to manually write my own instances of FromJSON in these cases?
21:06:07 <Cale> There are a bunch of ways that you can customise the instances produced by the TH stuff in aeson
21:06:21 <Cale> http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-TH.html
21:06:44 <Cale> For example, you may want to use fieldLabelModifier to strip off the prefix
21:07:00 <dhrosa> do you reccomend using the TH aeson module instead of using the GHC generics ones
21:07:51 <Cale> Yes, I think so
21:08:05 <Cale> oh
21:08:23 <Cale> Actually you can use the generics one as well, it supports the same options
21:08:45 <Cale> http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html#t:GToJSON
21:10:32 <dhrosa> oh cool, now to learn how to use GFromJSON
21:10:34 <dhrosa> thanks
21:11:52 <glguy> Just use this as your parseJSON implementation genericParseJSON :: (Generic a, GFromJSON (Rep a)) => Options -> Value -> Parser a
21:12:01 <glguy> You don't use GFromJSON other than that
21:14:24 <dhrosa> I see, out of curiosity, any reason to use the TH version over the generics version? the generics seems a bit nicer
21:16:54 <dhrosa> from the docs it seems the TH willl probably a bit more efficient, I'll stick with the generics
21:20:25 * hackagebot mtl-prelude 1.0.2 - Reexports of most definitions from "mtl" and "transformers"  http://hackage.haskell.org/package/mtl-prelude-1.0.2 (NikitaVolkov)
21:21:27 <gammaton> http://lpaste.net/117323 Why can't Zero bind to t
21:24:06 <pavonia> Succ t means any type t, but you return Succ Zero
21:25:26 <pavonia> You even return different types
21:26:06 <gammaton> so can toTyped function can be acheived in haskell
21:27:13 <gammaton> so can toTyped function be acheived in haskell
21:29:03 <pavonia> I don't think so, but maybe you can with some language extentions
21:29:29 <pavonia> Even if you could, how would you use it?
21:32:22 <godel> the thing is that "Succ a" is isomorphic to "a", so why would you want that anyway?
21:33:31 <godel> gammaton: ^
21:34:51 <gammaton> I saw the example for GADT and it has almost same hack for number of elements in list. So I am wondering if we can add list.
21:35:14 <godel> gammaton: I don't get it
21:37:59 <dgomez_> literacy comes in differnt ways. ill be back.
21:41:17 <gammaton> http://lpaste.net/117325 Can we add this list
21:41:25 <gammaton> taken from http://www.haskellforall.com/2012/06/gadts.html
21:43:30 <pavonia> gammaton: Add in what way?
21:43:44 <gammaton> like (++)
21:44:34 <pavonia> You can write a concatenation function for this, yes
21:46:32 <gammaton> Can you write it as I have tried many ways and it all failed
21:47:04 <Lokathor> is there a library function that converts an int into a string but with commas separating the digits into groups?
21:47:56 <citrurb> hello. I am pretty new to haskell, trying to figure out Parsec. when defining your own parsers do you no top-level declarations, declarations with ParsecT type, Parsec alias or something else?
21:48:13 <Welkin> Lokathor: perhaps in Text.Printf?
21:48:32 <citrurb> *do you use no top-level declarations..
21:51:46 <nkar> citrurb: could you rephrase the question or show an example?  I don't understand what you're trying to say.  alternatively, you could search for parsec tutorials on the web to see how things are structured.
21:52:14 <BillyIII> gammaton: something like concat (a:as) b = Cons a (concat as b) ?
21:52:58 <BillyIII> gammaton: (replace a:as with Cons a as)
21:53:05 <glguy> gammaton: You'll need to use fundeps or type families to write the type for your ++ operation
21:53:12 <BillyIII> gammaton: (and add Nil case)
21:53:40 <glguy> (++) :: List n a -> List m a -> List (add n m) a
21:53:49 <Lokathor> printf doesn't seem to have what i'm looking for. Guess i'll have to go without commas for now
21:55:19 <citrurb> say that we have a bunch of parser, one example: fooOrBar = (string "foo") <|> (string "bat"). would you use explicit type declaration? foo :: Parsec ... (and what type you use, Parsec, ParsecT, something else), or would you just let ghc figure out the type by itself
21:55:37 <dhrosa> citrurb: most of the time you can just have the type declaration as Parser MyType
21:55:43 <gammaton> BillyIII: I have tried almost same approach but it didn't work
21:55:53 <dhrosa> citrurb: unless you're something something fancy, like maintaining your own internal state, or parsing something that's not a String
21:56:01 <dhrosa> doing something fancy*
21:56:31 <dhrosa> Parser is a type alias for ParsecT with the identity monad, string as the stream, etc. arguably the more common use-case
21:56:33 <nkar> citrurb: always use type signatures
21:57:10 <nkar> citrurb: unless it's a simple oneliner or just not important code
21:57:59 <citrurb> nkar I see
21:58:13 <gammaton> glguy: what does add m n in type mean
21:58:19 <nkar> citrurb: don't use ParserT unless you need to change the identity monad to something else
21:58:22 <citrurb> dhrosa: did you mistype that? I am getting "Not in scope, type constructor or class 'Parsex'"
21:58:32 <dhrosa> Parser
21:58:32 <citrurb> sorry, Parsec
21:58:39 <citrurb> yes Parser
21:58:51 <dhrosa> you have to import a specific Parsec module, I forget which, checking
21:59:23 <dhrosa> citrurb: I believe Text.Parsec.String
21:59:25 <citrurb> (and this is why one should copy/paste errors )
21:59:52 <citrurb> cool thanks. that worked
21:59:57 <glguy> gammaton: It means you're going to need to define a way to add naturals: type families or fundeps
22:00:35 <citrurb> I am just curious why is it considered a bad idea to leave out type signatures?
22:00:48 <dhrosa> citrurb: always use explicit type decls, you'll think you're writing a Parser String, and you'll actually have written the code for a Parser Char, and the type errors will confuse you
22:00:56 <BillyIII> citrurb: they are here for you own safety
22:01:13 <dhrosa> citrurb: the compiler might infer a type that you weren't expecting, usually because of your own mistake
22:01:20 <citrurb> ok
22:01:26 <citrurb> makes sense
22:01:38 <kranius> good guy compiler
22:02:08 <dhrosa> url :: String; url = 'c' will be cause an error right at the site of the url definition
22:02:26 <dhrosa> instead of 100 lines later in the code when you try to use url as a string, but the compiler thinks it's a char
22:03:06 <ticktock> gammaton: I don't think it's possible to write an append for vects in Haskell without using unsafeCoerce.
22:04:40 <Lokathor> is there a way to break up a long line in haskell? I've got a lot of ++ that I'm chaining together
22:05:00 <dhrosa> Lokathor: I think most people have an array of strings and then call unlines
22:05:04 <ticktock> gammaton: actually you can: https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
22:05:25 <Lokathor> unlines might be the key, thanks
22:06:18 <dhrosa> you could also do some evil stuff with RebindableSyntax :p
22:06:30 <gammaton> pavonia: glguy: ticktock: Can you please write the complete defination of concatenate function in that list data as I tried several ways and it all failed. It will be very grateful of you.
22:06:41 <dhrosa> replace >> with ++, and then you could write a long block of text in do-notation
22:07:07 <pavonia> gammaton: Show us what you have tried so far
22:08:34 <Welkin> dhrosa: unlines adds a newline between the values though
22:08:53 <enthropy> Lokathor: you know you can put newlines most places in an expression  (a ++ b ++ c ++ d), so long as stuff is indented enough to avoid getting an implied } messing things up?
22:09:41 <Welkin> > unwords ["learn you a", "haskell", "for great good!"]
22:09:42 <lambdabot>  "learn you a haskell for great good!"
22:09:51 <zwer_b> you can also usr unwords or concat depending on what behavior you want
22:09:53 <kadoban> Welkin: If you don't want them, then... concat or unwords or something. Yeah.
22:10:26 <Welkin> > concat ["learn you a", "haskell", "for great good!"]
22:10:27 <lambdabot>  "learn you ahaskellfor great good!"
22:10:33 <Welkin> > intercalate " " ["learn you a", "haskell", "for great good!"]
22:10:35 <lambdabot>  "learn you a haskell for great good!"
22:12:29 <lpaste> glguy annotated ‚ÄúSafe list‚Äù with ‚ÄúSafe list (annotation)‚Äù at http://lpaste.net/117325#a117326
22:12:41 <glguy> gammaton ^
22:13:02 <gammaton> I have tried approaches like BillyIII approach which didn't work. And then adding typed variables that has type that represent number and then converting number to typed number. I cannot even solve last problem which looks more simpler than first.
22:13:35 <gammaton> I have asked last problem first.
22:16:02 <gammaton> I did same mistake that I did in http://lpaste.net/117323 thinking that t can bind to any type.
22:16:25 <gammaton> Whereas it means that it binds to ALL types.
22:16:31 <pavonia> glguy: Is Nat here defined at type and kind level?
22:19:10 <ticktock> pavonia: With the 'DataKinds' extension, ghc makes the type-level version for you
22:19:49 <pavonia> You mean kind-level?
22:22:45 <ticktock> pavonia: Well you define the term-level nats, it defines type-level nats, ie 'data Z; data S n'. Is that kind-level?
22:23:27 <pavonia> No, Nat is
22:24:43 <pavonia> You define a new type and it automatically defines a corresponding kind, that's what I meant
22:25:44 <ticktock> Ah, I see
22:29:09 <citrurb> I dont understand a lot in haskell, but writing parsers is a lot of fun
22:29:43 <citrurb> code is very concise too
22:30:07 <rwiggins> parsec is awesome
22:30:21 <citrurb> yeah
22:31:43 <dhrosa> this is my first time using monad transformers: I have a stack (from the top-down) of EitherT -> StateT -> IO. I have a function that returns an Either, and I want to fit its type to my stack
22:31:54 <dhrosa> hoistEither gives me a type error:
22:33:32 <dhrosa> Expected type: Slack UserListResp, actual type: EitherT String m0 UserListResp
22:33:57 <dhrosa> Slack a is a newtype for EitherT String (StateT SlackState IO) a
22:34:29 <dhrosa> oops, this isn;t a monad transformer problem
22:34:41 <dhrosa> I just forgot how newtypes worked :p, I just forgot to wrap it in my constructor
22:39:23 <Welkin> user error is the most common error
22:39:39 <Welkin> especially in haskell
22:40:22 <Welkin> I recall debugging for hours because I had placed a (,) inapproriately and had not mnoticed it until hours later
22:40:22 <Welkin> I made sure to never do that again
22:40:28 <Welkin> and to read the type errors much more carefully
22:41:21 <gfixler> it's always possible that making sure never to do something again destabilizes other aspects of the brain
22:41:31 <gfixler> the brain is a mutable mess
22:41:52 <Welkin> the brain is ever-changing
22:42:52 <gfixler> it's made of bottoms
22:43:13 <gfixler> I think that's what they mean by "bottom-up thinking"
22:51:13 <trap_exit> in haskell, what is the easiest way to write a function that is Char -> Some Spec of a Font -> Image (of the Char of the Font)
22:51:30 <trap_exit> so something like " "f" ->  Times New Roman -> img "
22:52:00 <Welkin> why do you want an image?
22:52:12 <trap_exit> Why can't I ask for an image.
22:52:21 <trap_exit> I want to basically display all chars of fonts as images.
22:52:27 <trap_exit> Is this such an unreasonable request?
22:52:56 <Welkin> there might be an image library
22:52:58 <pavonia> You could use pango for rendering text
22:53:00 <kadoban> trap_exit: "Why?" isn't a challenge.
22:53:23 <trap_exit> kadoban: how should I respond to Welkin's "Why" ?
22:53:33 <Cale> trap_exit: Probably using Gtk2Hs would be the easiest way.
22:53:45 <trap_exit> I'm on OSX
22:53:48 <kadoban> trap_exit: With an answer, probably?
22:53:51 <trap_exit> gtkhs installatino would probably kill me
22:53:55 <Welkin> trap_exit: with the purpose of why you want an image, since perhaps you don't really want an image
22:53:59 <Cale> What?
22:54:04 <trap_exit> Welkin: waht do I wnat?
22:54:05 <Cale> No, it works on OSX
22:54:21 <Welkin> trap_exit: that was the point of the question
22:54:48 <Cale> Well, if you hate that idea, maybe you could use SDL-ttf
22:54:58 <Cale> http://hackage.haskell.org/package/SDL-ttf
23:06:11 <geekosaur> trap_exit, there used to be an interface to objective-c, which is required to speak to native OS X interfaces, but it bitrotted long ago (Apple changes things fairly often; since the original was written we've seen objc 2.0 with different low level interfaces, and moving from manual refcounting to garbage collection and then to automatic refcounting with both earlier ones at this point completely removed, among others)
23:07:11 <geekosaur> nobody has cared enough to try to keep up with os x native interfaces, so at the moment the best you can do is to find/use a gtk+pango for native os x or a native os x sdl port and sdl+sdl-ttf
23:08:27 <Welkin> sdl is easy to get working on osx
23:08:31 <citrurb> can I have a global mutable variable?
23:08:50 <geekosaur> apple doesn't really care about making it easy for third party tools and languages to access their APIs; they provide a toolkit and languages that they support, and that's enough as far as they are concerned
23:08:54 <dhrosa> citrurb: what are you trying to do?
23:08:55 <SharpGAF> citrurb: Why do you want one, out of curiosity
23:09:00 <SharpGAF> They're usually a really bad idea
23:09:08 <biinui> hi :), this is regarding aeson. i have a data that's just a tuple - data Road = Road (Coordinate, [Coordinate]). what's the best way to unwrap/convert Road into a normal Tuple?
23:09:09 <biinui> http://lpaste.net/117329
23:09:47 <biinui> i need to feed it into Map.fromList. in the link it's the second to the last line.
23:10:30 <dhrosa> biinui: why not roadTuple (Road tup) = tup ?, not really an aeson-specific thing
23:10:41 <dhrosa> or use a record field instead
23:10:49 <citrurb> I need to keep track of some things I parsed so far
23:10:55 <dhrosa> data Road = Road {roadPos :: (Coordinate, [Coordinate])}
23:10:58 <SharpGAF> Why does that have to be global?
23:11:23 <dhrosa> citrurb: biinui then roadPos becomes a function that takes a Road and returns a tuple
23:11:46 <Welkin> why not just use a State monad?
23:12:50 <biinui> dhrosa: snap *facepalm*, thanks! :)
23:15:12 <citrurb> Welkin: was that for me?
23:16:29 <dhrosa> citrurb: yes
23:17:16 <zq> hm
23:17:35 <zq> nvm
23:23:38 <zq> alright
23:24:01 <zq> why does ghc insist on checking the same set of facts about the same Int binding twice?
23:25:05 <sipa> checking facts?
23:26:22 <geekosaur> there are always ways to make haskell behave like other languages. however, to do so, you have to be good enough at haskell to know how to make it work... and if you're that good at haskell, you can usually find a more haskelly way to do it instead. whereas the folks who really want to make haskell behave like another language are usually those who don't understand haskell that well and are trying to force haskell to be some language they do
23:26:22 <geekosaur> know....
23:26:23 <zq> yes, for instance
23:26:46 <zq> geekosaur: was that for me?
23:26:49 <geekosaur> no
23:26:59 <pavonia> zq: What do you mean by fact here?
23:27:05 <zq> wait
23:27:08 <zq> i'll paste
23:27:20 <SharpGAF> geekosaur: Even in other languages, mutable global variables are usually a bad idea though :P
23:28:31 <zq> so, quotRem :: Int -> Int -> (Int, Int); quotRem a b | b == -1 = ... | b == 0 = ... | otherwise = -- do it
23:28:35 <geekosaur> I had to rewrite that wall of text several times to remove the implication that they might not actually know the other language that well either, if they were expecting to use globals that way :p
23:28:47 <geekosaur> of course, now I've said it anyway....
23:29:37 <zq> if you define, say, meh a b | b < 1 = error "nope." | otherwise = quotRem a b , then ghc will still go ahead and check that i) b < 1, ii) b != -1, iii) b != 0
23:29:39 <SharpGAF> Maybe if the other language is assembly
23:29:49 <zq> unless i'm reading the stg wrong
23:29:55 <zq> which is pretty lollable
23:30:04 <SharpGAF> *Maybe*
23:30:07 <zq> pavonia, sipa ^
23:30:42 <geekosaur> zq, what optimization level and is your quotRem exported?
23:31:31 <geekosaur> at low optimization, ghc probably won't bother optimizing it away; if it's exported, it *can't* because it can't know that there won't be other callers that don't check the preconditions first
23:31:40 <zq> geekosaur: -O9000
23:31:43 <zq> lol
23:31:51 <zq> i've tried -O{2..9000}
23:32:36 <zq> geekosaur: i don't understand the second half of your sentence
23:32:55 <zq> geekosaur: quotRem is exported by GHC.Real
23:33:03 <zq> it's in prelude
23:33:05 <zq> :t quotRem
23:33:05 <geekosaur> so you are not reimplementing it
23:33:06 <lambdabot> Integral a => a -> a -> (a, a)
23:33:09 <zq> ofc not
23:33:17 <geekosaur> so there are likely to be callers of quotRem that are not your "meh"
23:33:22 <zq> so what
23:33:24 <geekosaur> so the code for quotRem must still check
23:33:27 <zq> quotrem is inlined
23:33:47 <geekosaur> *quotRem* is, yes. custom rewrite of quoteRem?
23:33:56 <geekosaur> er quotRem
23:33:58 <zq> no no no
23:34:11 <zq> the redundant checks are showign up inside the stg for meh
23:34:16 <geekosaur> yes
23:34:20 <geekosaur> because it inlined quotRem
23:34:27 <geekosaur> it did not inline a custom rewrite of quotRem
23:34:41 <zq> thanks, i just said that. so no, the code for quotrem doesn't have to check because every call into that inlined version goes through meh.
23:35:12 * geekosaur senses that his point went flying high overhead
23:35:35 * zq senses that geekosaur lost track of zq's original question
23:35:47 * BillyIII senses sensing
23:36:04 <zq> how come ghc isn't smart enough to know that x >=  1 ==> x != 0 && x != -1
23:36:10 <zq> and how can i teach it to know
23:37:03 <geekosaur> I am not sure that you can, because the interaction between inlining, rewrite rules, and optimization is more than a bit hairy
23:37:24 <geekosaur> yes, I understand that you want it to rewrite the inlined quotRem for you
23:38:30 <wagle> is there a good/solid plotting package for numerical data for haskell?
23:38:52 <geekosaur> I also understand that ghc has some rather screwy behaviors in that area; sometimes it's possible to reorder inlining with respect to the other passes, other times that just makes things worse.
23:39:11 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#phase-control
23:42:41 <zq> even gcc knows to inline :\
23:42:54 <zq> oh well
23:44:25 <pavonia> Even if that quotRem is in another object file?
23:44:44 <Ralith> that depends on the type of object file!
23:45:02 <geekosaur> pavonia, one of the things in the .hi file is selected parts of inlineable source, so that it can do cross-module inlining
23:45:15 <citrurb> why cant I print inside a Parsec parser function?
23:45:34 <citrurb> to stdout
23:45:40 <geekosaur> (this in fact is the primary reason for what is miscalled "cabal hell"; cabal's the messenger, ghc is causing the mess)
23:46:09 <geekosaur> citrurb,, because you are in the Parsec monad, not the IO monad. liftIO may be of help
23:47:55 <geekosaur> anyway, one of the complications in this rewriting is that quotRem is polymorphic. this means, among other things, that literals like 1 are not literals; they're function calls
23:48:18 <geekosaur> and it cannot know that there won't be some Integral instance where that function call does something unexpected
23:51:27 <geekosaur> mmm, it can know that there is an Ord instance for anything which is Integral, but I'm not sure it can assume behavior based on that. notably, nothing stops there from being a newtype of, say, Down Integer with an Integral instance (so Ord behaves the reverse of what you expect)
23:52:16 <geekosaur> this is not something that can happen in C, so C compilers are allowed to make such assumptions
23:52:34 <zq> pavonia: yeah good point, it doesn't
23:52:42 <zq> pavonia: that'd be lto turf
23:52:42 <dhrosa> -XDisambiguateRecordFields doesn't seem to work the way I want, is there a way to have multiple data types in the same module with the same record name?
23:53:00 <geekosaur> (remember, open world assumption on typeclasses, it can't say that just because it doesn't see such an instance, there can't be one)
23:53:03 <dhrosa> I have two records with an ok :: Bool, (this makes life a lot easier with Aeson)
23:53:08 <geekosaur> dhrosa, not currently
23:53:15 <dhrosa> darn
23:53:31 <geekosaur> there's an extension in the works but it didn't make the cut for 7.10
23:54:13 <dhrosa> maybe instead I could make a polymorphic Response object that has an ok :: Bool, and do some Generic and FromJSON finageling
23:54:31 <narfinger> hiho, is it possible for happstack to only listen on localhost and not on 0.0.0.0?
23:54:43 <narfinger> i couldn't find anything in the docu
23:56:29 <dhrosa> how would you handle this? I'm working with a JSON API that always has an "ok", and an "error" field, and the other field varies depending on what method you called
23:57:32 <dhrosa> for example, the user.list request returns a JSON object with keys "ok", "error", and "users". channel.list requesr returns a JSON object with keys "ok",, "error", and "channels", etc...
23:58:25 <geekosaur> that sounds like a misdesigned API to me: under what circumstances would both "ok" and "error" be valid?
23:58:33 <zq> so, data APIResponse a = APIResponse { is_ok :: Bool, error_message :: String, unAPI :: a }?
23:58:38 <dhrosa> sorry, only one of those is present at a time
23:58:51 <dhrosa> but same deal, all the responses have shared keys
23:59:06 <zq> then wrap it as a maybe
