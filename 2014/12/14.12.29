00:02:25 <brianpWins> How do you access the first node in the data type “data Rose a = a :> [Rose a]”
00:03:11 <dgomez> i'll be back on tomorrow. sorry i didn't contribute anythign again. just don't know how to put everything i've read together as well as i thought. any other references or suggestions for being able to get the hang of writing out expression in a more "idiomatic" way?
00:03:39 <ddellacosta> brianpWins: how do you get the first value in a list in a function definition?  What is analogous in the Rose data type?
00:03:57 <dhrosa> brandonw: pattern match on its constructor
00:04:07 <ddellacosta> dhrosa: this is homework so don't give too much away
00:04:24 <dhrosa> the same way you'd extract the head of a list (without actually using the built-in head function)
00:04:31 <brianpWins> I figured it would work like list would so i though head or tail would work on it.
00:04:45 <ddellacosta> brianpWins: head and tail have what types though?
00:05:01 <brianpWins> Otherwise I think making a function that took (x:xs) when passed in might do the same?
00:05:21 <dhrosa> no
00:05:52 <brianpWins> Or a fucntion like “root Rose (a) = head a”
00:05:57 <ddellacosta> brianpWins: let me ask another way; what in the Rose data definition reminds of the list cons (:) operator?
00:06:10 <ddellacosta> brianpWins: again, you are not working with a list--think about the types
00:06:36 <ddellacosta> (*reminds you)
00:06:46 <brianpWins> The constructor reminds me of the list cons operator
00:06:49 <dhrosa> brianpWins: the colon isn't a special haskell syntax feature, it's actually just the constructor for a list
00:08:15 <dhrosa> the only actual special syntax haskell has for lists is the square brackets
00:08:17 <brianpWins> so yeah I got nothin else
00:09:02 * hackagebot hs-scrape 0.1.0.0 - Simple and easy web scraping and automation in Haskell.  http://hackage.haskell.org/package/hs-scrape-0.1.0.0 (codygman)
00:09:02 * hackagebot hPDB 1.2.0.2 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.2.0.2 (MichalGajda)
00:09:13 <ddellacosta> brianpWins: let me get as close as I can without actually telling you the answer: how do you attach the type var 'a' to the list of Rose a in the data definition for Rose a?
00:10:21 <brianpWins> yeah… I don’t even understand that question
00:10:43 <ddellacosta> data Rose a = a :> [Rose a]
00:11:08 <ddellacosta> brianpWins: haha, I'm not sure how much more explicit I can get without giving you the answer, and I'm not going to do that
00:12:04 <brianpWins> why not. I’m not asking to get taught. I’m asking how to do something explicit. Maybe I can reverse-engineer the process I need from there.
00:12:58 <dhrosa> brianpWins: how would you write the head function for lists?
00:13:21 <brianpWins> head (x:xs) = x
00:14:43 <ddellacosta> brianpWins: because I'm not going to tell you the answer to the homework question that I struggled over is why, that's all
00:15:15 <dhrosa> yes, what you;re doing is you're pattern matching on the list's constructor. List has two constructors, an empty list, and the (:) constructor. It looks something like data List a = Empty | a : (List a)
00:15:24 <paomian> test
00:17:03 <dhrosa> brianpWins: so how would you pattern match on your rose tree to get the head out?
00:17:14 <dhrosa> remember : is specific to lists, it's one of list's constructors
00:17:59 <brianpWins> root Rose (a) :> [_] = a
00:18:16 <dhrosa> yes
00:18:28 <dhrosa> exactly
00:18:33 <dhrosa> err
00:18:38 <dhrosa> almost
00:18:41 <ddellacosta> yeah, close
00:18:42 <brianpWins> Pattern error
00:18:43 <ddellacosta> not exactly
00:18:44 <ddellacosta> but very close
00:18:49 <dhrosa> root (a :> _) = a is what you want
00:18:55 <ddellacosta> d'oh
00:20:54 <brianpWins> hmmm thanks. Not sure why we don’t need “Rose” in there
00:21:06 <brianpWins> like root Rose (a :> _) = a
00:21:07 <dhrosa> Rose is not the name of the constructor, that's why
00:21:13 <dhrosa> the name of the constructor is :>
00:21:20 <brianpWins> ohhhhhh
00:21:27 <brianpWins> Compared to my other example
00:21:27 <dhrosa> like, when you pattern match on a Maybe, you never say Maybe in the pattern match
00:21:29 <brianpWins> I can see that now
00:21:33 <dhrosa> you say Nothing or Just
00:22:05 <brianpWins> Thanks dhrosa & ddellacosta
00:22:24 <ddellacosta> brianpWins: np, glad you figured it out!
00:23:37 <ddellacosta> I'm trying to get some binding to a C lib going, and I'm stumbling over the struct definition.  I've found this lib but it seems to take as much work to set up as it would for me just to figure out how to manually write the FFI code...does anyone have any suggestions on good references or approaches for FFI?  I'm using this one now: en.wikibooks.org/wiki/Haskell/FFI
00:24:11 <ddellacosta> It's generally good but a bit vague on the specifics for structs however
00:24:44 <ddellacosta> not sure why I need "Storable," for example
00:26:06 <dhrosa> I think Storable instructs things how to convert your datastructures into C primitives and the such
00:27:07 <ddellacosta> dhrosa: yeah, so that sounds like it's required no matter what when creating data types for C structs in FFI code?  That's the thing I'm confused about--is it just relevant in this example or a general thing you have to do?
00:31:58 <ddellacosta> ah, Stephen Diehl has a nice explanation here, nevermind: http://www.stephendiehl.com/what/#storable-arrays
00:38:57 * hackagebot unbounded-delays 0.1.0.9 - Unbounded thread delays and timeouts  http://hackage.haskell.org/package/unbounded-delays-0.1.0.9 (BasVanDijk)
01:03:16 <nmante> IRC and haskell newbie here
01:03:48 <nmante> anyone use Haskell platform on OS X?
01:10:43 <augur_> nmante_: probably most people here do!
01:10:45 <augur_> i certainly do
01:11:10 <moop> haskell aint hip enough for mac people
01:11:18 <moop> they use things like go
01:11:21 <moop> or nodejs
01:11:26 * moop trollbaits
01:11:46 <augur_> psh
01:11:49 <augur_> haskells so underground
01:11:59 <augur_> even the hipsters aint using it yet
01:12:06 <nmante> haha cool
01:12:44 <nmante> Anyone run into having to use sudo for using ghci?
01:13:35 <dhrosa> nmante: sounds like your installation is screwed p
01:14:19 <nmante> dhrosa: what i feared -__-
01:15:35 <nmante> dhrosa: i installed using homebrew. Everything seems to work fine.
01:16:05 <nmante> dhroa: Having to use sudoo just to start the interpreter is def weird
01:16:09 <augur_> nmante: i just install using the platform download
01:17:08 <nmante> augur_ I also tried that. I uninstalled the homebrew ghc stuff. Then installed with the platform download
01:17:55 <nmante> augur_: gave me the same result. As in, I have to start ghci with sudo
01:20:40 <lpaste> nmante pasted “Starting ghci without sudo on OS X yosemite” at http://lpaste.net/117408
01:36:18 <pavonia> nmante: Does building an running a simple binary with GHC work?
01:39:45 <nmante> pavoina: will try that. First day using haskell. Was just using the repl interface
01:39:58 <nmante> *pavonia
01:41:17 <Zemyla> :t \f -> ap f id
01:41:17 <lambdabot> (a -> a -> b) -> a -> b
01:41:45 <Zemyla> @pl \f -> ap f id
01:41:46 <lambdabot> join
01:43:54 <Zemyla> @pl \f g e -> g (f e) e
01:43:54 <lambdabot> flip flip id . (ap .) . flip (.)
01:44:17 <paomian> it look like intersting
01:44:23 <Zemyla> :t (flip flip id .)
01:44:23 <lambdabot> (a -> a1 -> (a2 -> a2) -> c) -> a -> a1 -> c
01:44:49 <Zemyla> :t flip flip id
01:44:50 <lambdabot> (a -> (a1 -> a1) -> c) -> a -> c
01:47:08 <rtpg_> I'm using company-ghc with a pretty vanilla config, and it doesn't seem to pick up symbols defined within the same file
01:47:20 <rtpg_> is there some secret switch I'm missing?
01:47:24 <Zemyla> @pl \p f g x -> if (p x) then (f x) else (g x)
01:47:24 <lambdabot> (ap .) . liftM2 if'
01:47:35 <Zemyla> :t if'
01:47:36 <lambdabot>     Not in scope: ‘if'’
01:47:36 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
01:48:44 <ddellacosta> do I have to do all the memory management if I'm writing FFI code, or does implementing Storable instances ensure that's taken care of for me?
01:51:46 <tharper> omg I am overwhelmed by the choices
01:51:52 <tharper> what should I sued to write REST endpoints
01:51:56 <tharper> use*
01:58:50 <nmante> pavonia: it works. created a simple hello world .hs file. compiled with ghc --make.  ran it in the terminal
01:59:30 <pavonia> And when you build with -dynamic?
02:01:48 <nmante> pavonia: i ran 'ghc -dynamic --make Hello.hs'. Then ran './Hello'.  That works as well
02:02:01 <nmante> pavonia: Is that what you mean?
02:02:21 <pavonia> Yes
02:02:42 <nmante> cool
02:03:25 <pavonia> And what if you rund your program with "ghc Hello.hs -e main"?
02:04:01 * hackagebot hasql-backend 0.4.0 - API for backends of "hasql"  http://hackage.haskell.org/package/hasql-backend-0.4.0 (NikitaVolkov)
02:04:45 <nmante> pavonia: What does that do?
02:05:06 <nmante> pavonia: That doesn't work
02:05:23 <pavonia> It runs main from the interactive environment
02:05:37 <nmante> pavonia: It gives the same error as if I try to run ghci without sudo
02:05:47 <nmante> I see
02:06:13 <pavonia> Could you run the same command with -v3 for debug information?
02:06:21 <nmante> This is the error 'can't load .so/.DLL for: libiconv.dylib (dlopen(libiconv.dylib, 9): image not found)'
02:06:28 <nmante> Sure I'll run with -v3
02:07:30 <pavonia> I'm wondering why it seems to work with -dynamic but not for the interactive version
02:08:30 <lpaste> nmante pasted “Ghc with -e main options/arguments” at http://lpaste.net/117409
02:09:01 * hackagebot hasql 0.7.0 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.7.0 (NikitaVolkov)
02:09:30 <nmante> Does dynamic invoke the interactive at all?
02:13:44 <pavonia> nmante: I have no idea what's going on, sorry
02:15:44 <nmante> pavonia: no problem. I think it's unix permissions thing. I'll continue looking tomorrow
02:16:34 <nmante> pavonia: thanks for the help, and useful command line tricks
02:16:39 <nmante> later
02:19:36 <nmante> pavonia: I figured it out
02:20:33 <pavonia> What was it?
02:21:58 <nmante> In my .bash_profile, i was appending some stuff to the dynamic linker's path (DYLD_FALLBACK_LIBRARY_PATH)
02:22:34 <nmante> I remember getting a warning when installing via homebrew that using that path can create some trouble
02:23:10 <pavonia> Heh
02:23:13 <nmante> I removed the line in my bash_profile where I was adding to the path, and everything worked
02:23:25 <nmante> *commented the line
02:23:34 <nmante> lol crazy stuff
02:24:17 <nmante> appended to the path all because of MATLAB too. -__-
02:24:49 <nmante> okay. Now I'm going to bed for real
02:25:25 <neuroserpens> Another curiosity... Is there an advantage to using if then else instead of just using guards all the time?
02:25:58 <neuroserpens> From what I see, using only guards would even make the code more easily maintainable as it's easier to add conditions.
02:26:15 <Taneb> > map (\x -> if even x then x `div` 2 else 3 * x + 1) [1..10]
02:26:16 <lambdabot>  [4,1,10,2,16,3,22,4,28,5]
02:27:08 <neuroserpens> Taneb: I guess you mean guards can't be used in there.
02:27:25 <Taneb> neuroserpens, they can, just it would be a lot more awkward
02:28:27 <neuroserpens> Taneb: Well... Now that's a matter of style. I think they are much more elegant by the way... But can you think of any performance issues?
02:28:47 <Taneb> No, I think they are equivalent
02:29:02 * hackagebot circle-packing 0.1.0.4 - Simple heuristic for packing discs of varying radii in a circle  http://hackage.haskell.org/package/circle-packing-0.1.0.4 (JoachimBreitner)
02:29:25 <neuroserpens> Taneb: Nice. Thank you very much for the input. I'll keep on reading LYAH and RWH then.
02:31:33 <matematikaadit> neuroserpens: if-then-else is an expression, so you can put it everywhere when an expression needed.
02:32:22 <numberten> anyone have experience with igraph?
02:32:43 <numberten> i'm having a ff problem whenever I try and use VertexSelectors
02:39:19 <solatis> ok
02:39:32 <solatis> why isn't there a monadic network library in haskell ?
02:39:44 <solatis> as in, that keeps track of all open sockets and closes them when needed
02:40:07 <solatis> is it a hard problem, or did people just not care enough to implement such a library ?
02:41:40 <solatis> i suppose a lot of people are using the conduit / pipes library for this kind of stuff..
02:44:28 <Haskellfant> there is also resourcet
02:45:15 <solatis> i thought resourcet was closely related to conduit?
02:45:32 <Haskellfant> I think conduit builds upon it
02:55:46 <slomo> solarus: ResourceT can be used without conduit
02:57:45 <ocharles_> Can anyone see why I'm having type checking problems in https://gist.github.com/ocharles/c62720f61db61780e5f3?
02:58:08 <ocharles_> For some reason, GHC begins by correctly identifying the type of a variable (that's a GADT), but when I pattern match on it I *lose* type information
02:58:14 <ocharles_> that is, some variables now become ambiguous
02:59:03 * hackagebot hasql-postgres 0.10.1 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.10.1 (NikitaVolkov)
03:05:05 <osa1> can I define an infix operator starting with character ':' ?
03:07:05 <Taneb> osa1, no, that is reserved for data constructors
03:12:04 <matematikaadit> > let xx :% xy = xx + xy + 1 in 1 :% 2
03:12:06 <lambdabot>  Not in scope: data constructor ‘:%’
03:12:06 <lambdabot>  Perhaps you meant one of these:
03:12:06 <lambdabot>    ‘:+’ (imported from Data.Complex),
03:12:52 <tsahyt> Does anyone know a way to find siblings in a tree quickly, when any given node doesn't know its parent?
03:13:46 <matematikaadit> tsahyt: what kind of tree? the one in Data.Tree from containers?
03:14:13 <tsahyt> A quadtree. I'll post some code in a pastebin
03:14:42 <matematikaadit> @@ tsahyt @where lpaste
03:14:42 <lambdabot>  tsahyt http://lpaste.net/
03:15:17 <tsahyt> http://lpaste.net/566571826327584768
03:15:57 <tsahyt> basically every cell has exactly four children which could either be cells or terminals and then there's some additional information stored in the tree, which shouldn't be important right now
03:20:16 <tsahyt> Since I have to find neighbors for every terminal, I'm currently building a map by doing adjacency checks for all terminals with each other, so I end up with O(n^2) which slows down the algorithm. In other languages I'd just have a pointer back to the parent and then use that to determine the sibling nodes, but as far as I understand that doesn't work very well in Haskell, since I update the tree a lot.
03:22:10 <ski> ocharles_ : you might need to match on `TList' with a named function with an explicit type signature
03:22:36 <ocharles_> ski: how annoying :(
03:26:15 <matematikaadit> tsahyt: have you looked at zipper?
03:26:26 <tsahyt> not yet
03:27:16 <ski> @let data Prod ab where {Pair :: a -> b -> Prod (a,b)}; deriving instance (Show a,Show b) => Show (Prod (a,b))
03:27:17 <lambdabot>  Defined.
03:27:23 <ski> > Pair 'a' False
03:27:24 <lambdabot>  Pair 'a' False
03:27:27 <ski> @type Pair 'a' False
03:27:28 <lambdabot> Prod (Char, Bool)
03:27:35 <ski> @type \(Pair a b) -> (a,b)
03:27:35 <lambdabot>     Couldn't match expected type ‘t’ with actual type ‘(a, b)’
03:27:35 <lambdabot>       because type variables ‘a’, ‘b’ would escape their scope
03:27:35 <lambdabot>     These (rigid, skolem) type variables are bound by
03:27:41 <ski> @type \ab -> case ab of Pair a b -> (a,b)
03:27:42 <lambdabot>     Couldn't match expected type ‘t’ with actual type ‘(a, b)’
03:27:42 <lambdabot>       because type variables ‘a’, ‘b’ would escape their scope
03:27:42 <lambdabot>     These (rigid, skolem) type variables are bound by
03:27:59 <ski> @type let f :: Prod ab -> ab; f (Pair a b) = (a,b) in f
03:27:59 <lambdabot> Prod ab -> ab
03:28:39 <ski> ocharles_ : i think that's probably the basic problem. i'm not sure if there's a more pointfree way to do it. perhaps with some type ascriptions somewhere
03:28:40 <tsahyt> Technically I need all cells that are geometrically adjacent to a the terminal I'm looking at. I might be able to use that to my advantage somehow. I'll have a look at zipper and check back later if I'm still stuck
03:29:01 <ski> hmm
03:29:04 <ski> @type (\(Pair a b) -> (a,b)) :: Prod ab -> ab
03:29:04 <lambdabot> Prod ab -> ab
03:29:18 <ski> ocharles_ : oh, that ^ worked
03:29:52 <ski> @type \(ab :: Prod ab) -> case ab of Pair a b -> (a,b) :: ab
03:29:53 <lambdabot> Prod ab -> ab
03:30:07 <ski> @type \(Pair a b :: Prod ab) -> (a,b) :: ab
03:30:07 <lambdabot> Prod ab -> ab
03:30:10 <ski> and those
03:30:17 <ocharles_> I know that some more "basic" stuff works fine
03:30:21 <ski> ocharles_ : perhaps you could try one of those variants ?
03:30:38 <ocharles_> in that example, destructing the list once does work fine - but only if it's in the body of the letrec ("consuming" the bindings list)
03:31:09 <sinelaw> Hi! Given two recursive expressions, with one "unrolled" more than the other, is there an algorithm to canonize them?
03:31:34 <sinelaw> for example: expression A = a->b->A and B = a->b->a->b->B
03:31:53 <ski> sinelaw : there's "rational tree matching"
03:33:55 <sinelaw> ski, thanks, can you point me to a reference? google yields a bunch of paywalled / unrelated stuff
03:34:31 <numberten> isn't there a way to make ordered values generated via range syntax?
03:34:37 <numberten> like [Monday..Friday] ?
03:34:52 <numberten> assuming the Day type has an Ord instance
03:34:58 <matematikaadit> numberten: derive Enum
03:34:59 <sinelaw> numberten, Enum
03:35:06 <numberten> ah thanks
03:36:32 <matematikaadit> @let data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
03:36:33 <lambdabot>  Defined.
03:36:40 <matematikaadit> @undefine
03:36:40 <lambdabot> Undefined.
03:36:46 <matematikaadit> @let data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving Enum
03:36:48 <lambdabot>  Defined.
03:36:55 <bernalex> numberten: '..' is just syntax sugar for enumFromTo. using ',' you get enumFromThen instead.
03:37:01 <bernalex> :t enumFromTo
03:37:01 <matematikaadit> > [ Monday .. Friday ]
03:37:02 <lambdabot> Enum a => a -> a -> [a]
03:37:02 <lambdabot>  No instance for (GHC.Show.Show L.Day)
03:37:02 <lambdabot>    arising from a use of ‘M209268501546784852120148.show_M2092685015467848521...
03:37:10 <BoR0> > map toEnum [0..3] :: [Day]
03:37:11 <lambdabot>  No instance for (GHC.Show.Show L.Day)
03:37:11 <lambdabot>    arising from a use of ‘M921726857716412640820160.show_M9217268577164126408...
03:37:20 <matematikaadit> @undefine
03:37:20 <lambdabot> Undefined.
03:37:26 <matematikaadit> @let data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Enum, Show)
03:37:27 <lambdabot>  Defined.
03:37:28 <bernalex> numberten: so when you know that, it becomes trivial to show that you need to derive the Enum typeclass. :-]
03:37:32 <matematikaadit> > [ Monday .. Friday ]
03:37:33 <lambdabot>  [Monday,Tuesday,Wednesday,Thursday,Friday]
03:37:36 <ski> sinelaw : hm, i'm not sure about a reference
03:37:36 <numberten> i see thanks :)
03:38:11 <ski> sinelaw : i only know that some Prolog implementations provide it. also the type checker/inferencer of O'Caml must also do it
03:38:22 <sinelaw> ski,  you mean for -frectypes?
03:38:26 <ski> yes
03:38:29 <sinelaw> hmm
03:38:47 <ski> to be able to check that your two types `A' and `B' are equal
03:38:58 <sinelaw> this seems to deal with it using unification in section 3 http://3e8.org/pub/scheme/doc/lisp-pointers/v5i1/p193-kaes.pdf
03:39:32 <moop> if you do a @let, for how long does lambdabot keep the definition?
03:40:12 <ski> matematikaadit : .. hereabouts, `Sunday' would be considered the initial day of the week. day zero, imho :)
03:40:15 <EvilTerran> hi guys... I was just idly wondering, is there a tool that takes a bunch of modules, and it creates a mapping from each identifier to where it's defined?
03:40:51 <EvilTerran> seems like it should be fairly straightforward with ghc-api
03:40:54 <sinelaw> EvilTerran, various IDE plugins seem to be able to do hat
03:41:03 <ski> EvilTerran : looks like you're asking for a cross referencing tool. i'm not aware of one
03:41:08 <sinelaw> I use chrisdone's emacs config and it can do it
03:41:25 <EvilTerran> sinelaw, yeah, I figured as much, I was just thinking they might all be based on some underlying tool
03:41:27 <sinelaw> it uses ghci-ng
03:41:40 <ski> moop : until someone does `@undefine' (or until lambdabot reboots), i think
03:41:58 <EvilTerran> sinelaw, righto - I'll have a look at how that does it. thanks!
03:42:24 <ski> > [Friday .. Monday]
03:42:25 <lambdabot>  []
03:42:34 <ski> matematikaadit : .. perhaps unintended (?)
03:42:37 <EvilTerran> (to go one step further, I was thinking something that converts the modules into hyperlinked (and maybe syntax highlighted) HTML could be pretty handy)
03:43:17 <sinelaw> EvilTerran, haddock?
03:43:27 <EvilTerran> ...does that do that?
03:43:32 <ski> sinelaw : .., well, even without `-rectypes', you still need it to some extent
03:43:36 <sinelaw> it creates hyperlinked documentation
03:43:40 <tsahyt> I think I've found a reasonably fast way that works well enough to build a Map Tree [Tree] for all adjacencies.
03:43:46 <sinelaw> EvilTerran, the docs on hackage are generated by haddock
03:43:52 <EvilTerran> yeah, I know that much
03:44:02 <sinelaw> so you want it for source code browsing?
03:44:08 <EvilTerran> yup
03:44:16 <sinelaw> hm
03:44:27 <tsahyt> I just need to keep track of the path to the root node when traversing the tree to enumerate all leaves. [Tree] will do for that
03:44:53 <EvilTerran> sinelaw, I was thinking I might make such a thing myself as a little project, but there wouldn't be much point if it had already been done
03:45:31 <sinelaw> ski, why do you still need it?
03:45:51 <ski> sinelaw : because object types can still be cyclic
03:46:11 <sinelaw> ski, you have then explicit iso-recursion, I'm guessing, so types are defined explicitly and they will not unify regardless
03:46:12 <ski> as long as the cycle go through at least one object type construction
03:46:19 <ski> no
03:46:29 <sinelaw> ski, example?
03:46:31 <ski> equi-recursive types
03:46:43 <sinelaw> even without -frectypes?
03:46:57 <ski> yes
03:46:59 <sinelaw> they implement classes with equi-recursion
03:47:06 <ski> yes
03:47:07 <sinelaw> you say
03:47:17 <ski> well, not classes. object types
03:47:22 <sinelaw> but they are declared
03:47:24 <sinelaw> explicitly
03:47:48 <sinelaw> I don't know that much about ocaml
03:47:55 <sinelaw> (should have pointed that out!)
03:48:45 <tsahyt> by the way, is there any way to get GHC to use syntax highlighting in its error messages?
04:04:02 <ski>   # let rotate (angle : float) (p : <get_x : float; get_y : float; new_x : float -> 'point; new_y : float -> 'point> as 'point) =
04:04:13 <ski>       (p#new_x (cos angle *. p#get_x -. sin angle *. p#get_y))#new_y (sin angle *. p#get_x +. cos angle *. p#get_y);;
04:04:50 <ski>   val rotate : float -> (< get_x : float; get_y : float; new_x : float -> 'a; new_y : float -> 'a > as 'a) -> 'a = <fun>
04:05:44 <ski> sinelaw : this function can be passed any object that supports the required methods of the appropriate types, regardless of which class may have constructed it (not all objects need to be constructed by a class, either)
04:06:15 <sinelaw> ski, nice!
04:06:21 <sinelaw> I'm implementing a similar system
04:06:32 <ski> i could have abbreviated the type  <get_x : float; get_y : float; new_x : float -> 'point; new_y : float -> 'point> as 'point  here, using a type synonym, but then it wouldn't show as clearly that you don't *need* to name it
04:07:13 <ski> fwiw, if i omit the type ascriptions on the parameters, i get
04:07:20 <ski>   # let rotate angle p = (p#new_x (cos angle *. p#get_x -. sin angle *. p#get_y))#new_y (sin angle *. p#get_x +. cos angle *. p#get_y);;
04:08:11 <ski>   val rotate : float -> < get_x : float; get_y : float; new_x : float -> < new_y : float -> 'a; .. >; .. > -> 'a = <fun>
04:08:46 <ski> where i think the two `..'s hide two row type variables
04:13:35 <ski> sinelaw : .. in O'Caml, classes can be thought of as "object factories". they can be used to construct ("instantiate") objects. apart from that, the main point of them is being able to define a new class by inheritance (even multiple inheritance) -- in some cases a subclass will generate objects whose object type aren't subtypes of the types of the objects generated by a parent class
04:14:26 <ski> if you don't need inheritance, you can make do with immediate objects, defining the methods inline for it
04:14:43 <ski> sinelaw : see <http://caml.inria.fr/pub/docs/manual-ocaml/objectexamples.html> for some more info
04:15:13 <sinelaw> great! thanks
04:15:34 <ski> it's possibly both to have mutable fields, as well as having them immutable, and instead cloning the object, replacing the value of some fields
04:15:40 <sinelaw> be right back
04:15:44 <EvilTerran> I've done a bit more digging ... the closest thing I can find is ghci's ability to generate ctags/etags. that seems to be what ghci-ng uses, but isn't quite what I'm after.
04:18:59 <matematikaadit> tsahyt: currently, there is no such thing. see https://ghc.haskell.org/trac/ghc/ticket/8809
04:20:36 <EvilTerran> looks like it'd be possible to roll something with GHC.parseModule and spidering the syntax tree. there'd be a hell of a lot of boilerplate though.
04:37:27 <rtpg> is else clause mandatory even in monadic do syntax?
04:38:20 <n4x> the else clause is mandatory _always_, you may want
04:38:22 <n4x> :t when
04:38:23 <lambdabot> Monad m => Bool -> m () -> m ()
04:38:54 <rtpg> shoulda checked out hoogle
04:38:54 <rtpg>  thanks
04:49:08 * hackagebot list-t 0.4.2 - ListT done right  http://hackage.haskell.org/package/list-t-0.4.2 (NikitaVolkov)
05:09:09 * hackagebot hasql 0.7.1 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.7.1 (NikitaVolkov)
05:20:26 <JonReed> Hi. Is there an alternative to the state monad transformer, if I need to keep state as well as do IO? With StateT one has to lift IO operations. So do notations looks pretty for the state operations, but it looks redundant for IO operations, because you have to put "lift" in front of every IO operation. It's should be possible to deduce which monad you're referring to, assuming that they are of different type.
05:21:13 <JonReed> So if I do IO, isn't there some language extension that can automatically lift all IO operations
05:21:35 <JonReed> Inside the do notation, it's obvious that if it's not a state operation, then it's IO
05:23:41 <ocharles_> JonReed: there isn't a language extension for that, but there is the `MonadIO` type class
05:23:54 <ocharles_> StateT IO is an instance of MonadIO, which automatically lifts things for you
05:24:17 <ocharles_> However, if you only have a `IO` value around, you will have to manually write `liftIO` (e.g., all the functions in the `base` library)
05:29:09 * hackagebot hmatrix 0.16.1.3 - Numeric Linear Algebra  http://hackage.haskell.org/package/hmatrix-0.16.1.3 (AlbertoRuiz)
05:33:20 <JonReed> ocharles_: Thx. I'm a bit confused what do you mean by "manually write `liftIO` all the functions in the `base` library". Will I need to re-implement all basic IO functions stuff like "print" "hPutStr" myself?
05:33:35 <ocharles_> JonReed: Well, take putStrLn, for example
05:33:37 <ocharles_> :t putStrLn
05:33:37 <lambdabot> String -> IO ()
05:33:53 <ocharles_> Because that specifically chooses `IO` as the monad, you will have to call `liftIO (putStrLn foo)`
05:33:58 <ocharles_> :t liftIO (putStrLn "Hello")
05:33:59 <lambdabot> MonadIO m => m ()
05:34:18 <ocharles_> What I was getting at is that you have to explicitly lift `IO` computations.
05:35:02 <fizbin> However, for any IO actions you've written yourself, you can make them pretty to use from inside your (StateT s IO) body by doing:
05:35:45 <fizbin> myAction = liftIO myAction' where myAction' = .... (what you had before)
05:36:16 <clrnd> :/ thats not much prettier
05:36:42 <JonReed> I was hoping to find something that would do that implicitly :(
05:36:57 <fizbin> An IO action that's been wrapped in "liftIO" can then be used from either an IO do-block or a (StateT s IO) block automatically.
05:37:13 <tsahyt> Is there any way to trace a stack overflow error?
05:37:15 <Chathurga> You could lift them all in a module and export them
05:38:11 <Chathurga> Oh wait thought someone else replied to something
05:38:38 <fizbin> So saying "liftIO" when you define the blocks is in fact slightly prettier, because it doesn't interfere with your pulling them together, and you can use them in anything that eventually wraps IO.
05:39:33 <fizbin> tsahyt: The general advice is to compile with -prof and then run with +RTS -xc ; see https://www.haskell.org/haskellwiki/Debugging
05:39:45 <fizbin> (warning: very slow page loading)
05:40:46 <fizbin> You may well want to actually compile with -prof -auto-all -caf-all
05:40:48 <moop> wow, what's up with haskell.org
05:40:50 <tsahyt> Okay, so I need all libraries with profiling enabled.
05:41:08 <fizbin> Fortunately, if you're using cabal this isn't so terrible to arrange.
05:41:28 <tsahyt> I'm more or less forcet to use an older cabal version without sandboxes though
05:41:38 <tsahyt> forced*
05:42:24 <tsahyt> Alternatively I could install Haskell Platform outside of my package manager, but that opens the door to all sorts of pain. Can profiling libraries coexist with normal ones?
05:42:24 <fizbin> Oh. Well, when I've needed to do that I first install cabal-dev. If I'm being extra paranoid, I first install cabal-dev to a per-project directory with:
05:45:21 <statusfailed> Anyone remember "Lambda bubble pop"? I'm looking for something similar to "debug" reduction of lambda calculus expressions
05:45:29 <fizbin> tsahyt: Here's a snippet from the Makefile I use to build profiling versions of my main haskell project at work on the older (pre-sandbox) haskell machines: http://lpaste.net/117411
05:46:01 <statusfailed> Specifically: I'm trying to figure out what happens when you apply one church numeral to another.
05:47:16 <fizbin> statusfailed: Isn't that church multiplication?
05:47:20 <fizbin> Or, wait...
05:47:28 <statusfailed> fizbin: dunno, I did it by hand with 2 1 and got 1
05:47:34 <statusfailed> so I'm not sure!
05:47:59 <barrucadu> I think it's addition
05:48:28 <tsahyt> Can I actually just install them globally or will I end up with name clashes? I need to do some profiling for this project anyway.
05:48:31 <statusfailed> Hm, I must have gone wrong.
05:48:42 <statusfailed> I was trying to write "succ", so addition makes most sense
05:49:28 <fizbin> Well, churchN (succ) (0) is the way to turn churchN into N in the normal integers.
05:49:45 <statusfailed> fizbin: SPOILERS!!!
05:49:52 <statusfailed> fizbin: :D
05:50:31 <fizbin> So churchN (succ) (churchM succ 0) would be N+M in the integers.
05:51:42 <fizbin> But the parens there confuse me, and prevent me from saying that therefore church addition is done with churchN succ churchM
05:52:15 <statusfailed> fizbin: yeah, if I cheat and look at wiki page, it seems like simple application couldn't possibly be equivalent to their definition
05:52:26 <statusfailed> but the question is: what IS it? Hmmm
05:52:37 <statusfailed> i'll manually reduce church2 church2 and see what happens
05:52:45 <fizbin> Part of the weirdness of course is that the church numerals only work in the *untyped* lambda calculus, and I've got types on the brain.
05:53:47 <statusfailed> fizbin: Yeah i'm having a bit of a brain meltdown about that too :)
05:53:56 <fizbin> tsahyt: I have no idea whether you can re-install profiling versions of the libraries globally.
05:54:18 <statusfailed> Untyped is a bit of a misnomer right? I read somewhere that every term in the "untyped" lambda calculus actuallly has a unique type
05:54:21 <statusfailed> not sure how true that is
05:55:06 <tsahyt> This is getting me deeper into cabal hell than I'm comfortable with. Might just as well get a new version of Haskell platform.
05:56:19 <clrnd> tsahyt, most linux distributions ofer prof versions of packages, and you can always reinstall cabal global libraries with profiling
05:56:22 <fizbin> The one weird thing about cabal-dev is that it doesn't compute dependencies properly for libraries that have had their descriptions updated through the hackage web interface without a new package being uploaded.
05:57:15 <fizbin> So that means that you tell cabal-dev to do something like install "snap-server" and it'll go install a version of text and of network that it later yells at you about.
05:59:11 <fizbin> Because what's happened is that the author of snap-server adjusted the version constraints when a newer version of text was published, but did so without pushing a new version of snap-server. So cabal-dev will pull the database, conclude "ah, snap-server can take the most recent version of text", install the most recent version, and then pull the snap-server package.
06:00:15 <fizbin> But the cabal file in the snap-server package will have the version constraints on text that snap-server uploaded with originally, so then cabal-dev will try to build and it'll say "wait, this version of text doesn't satisfy these constraints"
06:00:49 <fizbin> So you see how my cabal-dev line there has those maximum version constraints on network and text...
06:03:41 <fizbin> statusfailed: I think to see what church application does, you really should attempt to work out what church3 church2 is.
06:03:49 <tasker> I'm looking to generate some xlsx spreadsheets (as well as read from some existing spreadsheets), and would like to do so in haskell. I've found a few libraries on hackage, but was wondering if anyone had any experience with any of them?
06:05:26 <moop> why would you do this to yourself tasker
06:05:38 <tasker> because openpyxl is not fun :(
06:05:48 <tsahyt> Is there any way to check whether I have the profiling version for any given package?
06:06:00 <tasker> moop: oh, and also because I'm writing some stuff for a friend.
06:06:15 <moop> no, not that, the xlsx part
06:06:17 <fizbin> statusfailed: Huh. Contrary to my expectations, I just typed definitions of chruch0 through church3 into ghci, and (church3 church2 succ 0) actually worked.
06:06:38 <fizbin> tasker: Do you need formatting or formulas?
06:06:45 <tasker> fizbin: yes to both
06:07:02 <statusfailed> fizbin: I think because they are polymorphic, right?
06:07:04 <fizbin> Oh, crud. So something csv-like isn't an option.
06:07:23 <tasker> moop: xslx is the format they said they needed.. I don't know if there is some nicer alternative that is compattible with excel
06:07:41 <clrnd> csv, odf maybe
06:07:42 <tasker> fizbin: sadly not :(
06:08:05 <tasker> ah, that is compattible with excel and is able to produce formulae and formatting.
06:08:17 <fizbin> statusfailed: Well, it appears that all church numerals are of the type (t -> t) -> t -> t  (well, church1 and church0 are more general, but they fit that type)
06:08:23 <moop> tasker: the reason openpyxl so wonky is because it's just a wrapper around the com office libraries by microsoft
06:09:08 <tasker> moop: ah.
06:09:08 <moop> whatever haskell library you will go with will probably have the same everything
06:09:11 * hackagebot lifted-async 0.5.0.1 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.5.0.1 (MitsutoshiAoe)
06:09:30 <tasker> moop: tbh it is at least part that I just don't enjoy writing python any more
06:10:09 <tasker> also the python lib is slow as hell, not sure if this some fundamental limitation though
06:10:10 <statusfailed> fizbin: right, but t is polymorphic which allows it to work
06:11:10 <tasker> Thinking about it, I will probably need to create some basic GUI anyway, so it might be easier to just do it in python :(
06:12:11 <clrnd> so cabal just told me it can't find Data.String
06:12:16 <clrnd> something must be wrong I guess
06:13:11 <fizbin> clrnd: Are you possibly on a really old base version?
06:13:27 <clrnd> wait it said something about profiling, weird it's enabled in my global .cabal/config, let me double check
06:14:14 <flaggy> tasker: gtk2hs is ok or you could go web like all cool kids are doing :P
06:15:09 <clrnd> fizbin, nevermind, I now remember I installed new ghc and forgot about prof libs
06:15:16 <tasker> flaggy: i pretty much only need a wrapper that says where the input and output are tbh
06:15:16 <fizbin> flaggy: Because there's nothing to make you think "maybe python wasn't so bad after all" like coding your UI in javascript...
06:15:21 <clrnd> (apt does that aprt)
06:15:22 <tasker> haha
06:17:09 <statusfailed> fkz
06:17:12 <statusfailed> woops :)
06:17:37 <statusfailed> fizbin: weirdy, (c2 cN) == n^2
06:17:49 <statusfailed> fizbin: yeah looks like powers in general
06:17:53 <fizbin> statusfailed: Yep.
06:17:55 <statusfailed> fizbin: (cN cM) = M^N
06:17:57 <statusfailed> neat!
06:18:26 <fizbin> Which is why I suggested c3 c2 - I figured c2 c2 might lead you to the wrong conclusion.
06:18:51 <statusfailed> fizbin: oh sorry, must have missed that recommendation!
06:18:58 <tsahyt> After I cabal configure the project with --enable-executable-profiling, why does the program tell me that it wasn't compiled with profiling enabled when I run it with +RTS -p?
06:19:04 <statusfailed> Got sick of doing it by hand anyway and just printed a bunch using haskell :)
06:19:44 <fizbin> tsahyt: Not to ask the obvious, but you did rebuild after reconfiguring, right?
06:19:50 <tsahyt> yes
06:20:07 <tsahyt> It doesn't complain about missing profiling libraries when building either, although I'm sure I don't have them
06:20:36 <tsahyt> When I use --ghc-option=-prof with cabal, it complains during building, otherwise it doesn't
06:20:41 <tsahyt> although it should
06:21:06 <tsahyt> cabal-install version 1.16.0.2 if that helps
06:21:21 <bennofs> tsahyt: instead of using --ghc-option=prof, you should probably use cabal configure --enable-executable-profiling
06:21:27 <fizbin> Huh. So usually when I compile for profiling I use --enable-executable-profiling --enable-library-profiling in my configure line. I don't know what the difference there is between the two options, or what exactly happens when you only have one.
06:21:36 <tsahyt> bennofs: That's exactly the problem. The flag seems to do nothing at all
06:21:48 <bennofs> ah sorry, didn't read the backlog
06:22:00 <tsahyt> fizbin: I get the same result when using both. It's as if they weren't there
06:22:24 <fizbin> How are you running your program?
06:23:03 <bennofs> tsahyt: does it tell you that it wasn't compiled using profiling, or does it say that you should rebuild using -rtsopts to link?
06:23:05 <fizbin> What if you use "cabal run" to run your program?
06:23:26 <tsahyt> "the flag -p requires the program to be built with -prof"
06:23:56 <giovannino> ciao
06:23:59 <tsahyt> fizbin: "cabal: unrecognised command: run (try --help)"
06:23:59 <giovannino> !list
06:24:00 <monochrom> giovannino: http://hackage.haskell.org/packages/archive/pkg-list.html
06:24:19 <clrnd> lol
06:24:20 <giovannino> !list
06:24:35 <fizbin> tsahyt: Huh. So, obviously your cabal version recognizes the flags to configure.
06:24:54 <fizbin> tsahyt: I mean, if you try to configure again and typo a flag, it'll yell at you.
06:25:24 <tsahyt> Seems so, yes
06:25:25 <fizbin> tsahyt: So I'd suggest doing "cabal clean", then "cabal configure --enable-executable-profiling", then "cabal build"
06:25:33 <tsahyt> That's what I've been doing
06:25:41 <fizbin> tsahyt: In case your version of cabal isn't rebuilding...
06:25:43 <fizbin> huh.
06:26:10 <tsahyt> It's an older version, so it might be a bug that has been fixed since
06:26:27 <tsahyt> Fedora isn't exactly up to date with their haskell-platform package
06:27:26 <fizbin> What if, in addition to --enable-executable-profiling, you say --ghc-option=-fprof-auto
06:27:37 <fizbin> Just trying random stuff that's in my build.
06:27:57 <fizbin> But mine isn't for Fedora, but for an old Ubuntu (12.04 LTS)
06:28:59 <tsahyt> It's building, which it shouldn't because I don't have the profiling libraries. Still gives me the same error at runtime too.
06:29:28 <clrnd> why not create a local cabal.config
06:29:31 <clrnd> and add:
06:29:35 <clrnd> library-profiling: True
06:29:39 <clrnd> executable-profiling: True
06:29:46 <clrnd> just saying
06:30:05 <tsahyt> I think I'll install an up to date version of Haskell platform outside of the package-manager. I've been wanting to try sandboxes and some of the newer GHC features in 7.8 anyway.
06:30:21 <tsahyt> clrnd: Where would I create that file? In the project directory?
06:30:46 <clrnd> yeah exactly, where your cabal sandbox is ... wait you don't have a sandobx right?
06:30:54 <clrnd> nevermind
06:30:55 <tsahyt> Yes.
06:31:12 <clrnd> there is a ppa for ghc 7.8.4
06:31:19 <clrnd> it works charms
06:31:24 <clrnd> :P
06:31:52 <fizbin> clrnd: Unfortunately, tsahyt is over on redhat...
06:32:28 <clrnd> oh yolly, then no idea what'd be a practical way to install it
06:32:34 <tsahyt> I'll find out soon :) First I have to document this project though. It performs well enough for now anyway, I just wanted to check if there were any bottlenecks that could cause problems later on. It's not urgent though.
06:32:50 <tsahyt> Thanks for the help
06:47:45 <danilo2> Hello! Could anybody tell me why I get this strange error while using lenses? : http://lpaste.net/117417
06:48:15 <danilo2> it appears when trying to create instance of class IsPragma - namely the field xparse
06:48:33 <danilo2> without the instance the code works
06:49:56 <danilo2> ahh ,because this is not a Simple Lens! what is it ?
06:50:23 <bennofs> danilo2: the error indicates that it's only a Getter I think
06:50:47 <danilo2> bennofs: hmm, why makeLenses does not create setters there?
06:50:58 <bennofs> yeah, I'm also wondering about that
06:51:52 <danilo2> bennofs: I will ask on lens github - but for now - what "signature" should I use there?
06:54:25 <bennofs> danilo2: Simple Getter ... ?
06:54:35 <bennofs> ah no
06:54:37 <bennofs> :i Getter
06:54:48 <danilo2> bennofs: no, I tried it: should have kind ‘* -> * -> * -> * -> *’,       but ‘Getter’ has kind ‘* -> * -> *’
06:55:08 <bennofs> danilo2: just Getter ...   a Getter cannot be non-Simple :)
06:55:19 <danilo2> bennof: still no, the erro is the same
06:55:24 <danilo2> (as the first one)
06:55:38 <pranz> danilo2: try making the Pragma type not use any constraints
06:55:52 <pranz> but then in the instance for IsPragma have the constraints there
06:56:26 <danilo2> pranz: but then I have to parametrize the Pragma with m and I dont want to
06:56:44 <danilo2> pranz: this is existential field
06:56:54 <pranz> danilo2: oh right
06:57:16 <pranz> existential lenses can be a bit tricky
06:57:49 <danilo2> pranz: the type there is Contravariant f, ... => ((Pragma a0 -> m0 a0) -> f0 (Pragma a0 -> m0 a0))   -> Pragma a0 -> f0 (Pragma a0)
06:58:01 <danilo2> pranz: whatever it is :(
06:58:44 <tero_> can I use both stackage and hackage at the same time?
06:59:19 <tero_> in case one package is missing from stackage, to install it from hackage, I mean
06:59:21 <bennofs> tero_: yes. I think that's even the default (it's called inclusive, which means that cabal just falls back to hackage is a package isn't available from stackage)
06:59:41 <tero_> bennofs: sounds good
07:01:35 <tero_> ah, cabal.config contains only constraints by default and does not use stackage repo
07:07:03 <pranz> danilo2: sorry I can't come up with anything useful
07:07:38 <danilo2> pranz: It is a Getter! I was just talking with guys at #haskell-lens and it is Getter. I was trying it but by mistake the same error apeeared on other line :(
07:07:50 <danilo2> pranz: thank you so much for your help! and sorry for the confusion!
07:08:08 <athan> Is there a better way to write `traverse . map`?
07:08:23 <athan> er... actually.. why doesn
07:08:29 <athan> 't traverse work with monads?
07:08:46 <athan> (pre AMP, I mean)
07:09:56 <bennofs> :t Data.Traversable.mapM
07:09:57 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
07:10:01 <bennofs> for pre-AMP
07:12:56 <athan> bennofs: Ahh! Thank you!
07:16:40 <joroboro> Does anyone know how to fix "X11-1.6.1.2 failed during the configure step" error? I get it when I try to install snap
07:18:23 <mmmm_> joroboro: Can you paste the full log pls
07:18:52 <danilo2> rwbarton: anyway, when I try to just wrap a function, that previously was creating the existential field with newtpye, I got an error: http://lpaste.net/117418
07:19:04 <danilo2> sorry , not this window
07:19:23 * hackagebot partial-uri 0.2 - Datatype for passing around unresolved URIs.  http://hackage.haskell.org/package/partial-uri-0.2 (StephenWeber)
07:20:52 <joroboro> mmmm_: http://lpaste.net/8117117340488826880
07:25:07 <mmmm_> what platform are you on? joroboro
07:25:27 <joroboro> xubuntu
07:25:54 <mmmm_> do you have libghc-x11-dev installed?
07:26:14 <joroboro> I'll check
07:27:55 <joroboro> cabal: There is no package named 'libghc-x11-dev'.
07:28:06 <joroboro> that is the error I'm receiving
07:29:15 * hackagebot plivo 0.2.0.0 - Plivo API wrapper for Haskell  http://hackage.haskell.org/package/plivo-0.2.0.0 (StephenWeber)
07:29:17 * hackagebot simple-form 0.5.0 - Forms that configure themselves based on type  http://hackage.haskell.org/package/simple-form-0.5.0 (StephenWeber)
07:39:06 <athan> Is it common practice to fold over a list of IO actions with `concurrently` and sequence the effects together to get arbitrary concurrency?
07:39:38 <athan> erm, actually you don't need to sequence the effects, but you get my drift
07:41:50 <Adeon> is cabal-install included with the haskell platform, on windows?
07:41:58 <Adeon> I don't know if I'm blind but I can't find it
07:42:01 <athan> Adeon: Yep :)
07:42:14 <athan> it should just be the `cabal` command
07:42:47 <Adeon> er, uh, yes it is there
07:42:51 <Adeon> hrmmm
07:43:07 <Adeon> it's in PATH but I can't find the executable itself
07:43:28 <Adeon> my keen deductive skills tell me it is in one of the directories specified by PATH environment variable
07:50:39 <ddellacosta> what's the right way to handle an argument to a FFI function that should be NULL (in C-land)?
07:50:40 <rtpg_> are there nice ways to consolidate state monads with record syntax?
07:50:58 <rtpg_> currently my code is a lot of " curState <- get ; put $ curState { foo = bar }; "
07:52:50 <geekosaur> ddellacosta, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Foreign-Ptr.html#v:nullPtr ?
07:53:06 <mmmm_> rtpg_: lens :P
07:53:23 <rtpg_> ugh, lenses
07:53:44 <rtpg_> I've tried very hard to understand them but have a really hard time deciphering the type signatures
07:53:45 <ddellacosta> geekosaur: thanks, will give that a shot
07:54:08 <geekosaur> rtpg_, I think you're not supposed to try to understand the type signatures for lens :p
07:54:17 <ddellacosta> rtpg_: in an attempt to answer your question, I was poking at this blog post, have you seen it? http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html  Seems like a decent explanation, so far at least...
07:55:47 <rtpg_> oh, this seems clear
07:56:39 <rtpg_> geekosaur: the third party libraries, they come without docs. Read the types, they say. You read the types, and need docs to understand
07:57:07 <rtpg_> but seriously, it's so strange how little documentation you find on Hackage for extremely used libraries
07:57:14 <rtpg_> or anywhere really
07:57:31 <geekosaur> in most cases it's correct to try to understand the types. but lens is deep voodoo
07:57:35 <toblerone> Hi all. I've created a library that I want to use in various projects on my machine. I take it that I use "cabal register" to expose it on my system, but I'm not sure how it works with cabal sandbox. Also, running cabal register fails saying it can't find various object files etc
07:57:45 <toblerone> Whats the proper way to go about this?
07:58:33 <ddellacosta> rtpg_: I actually thought the main lens docs had decent docs, but to be fair I haven't really dug into them yet: http://lens.github.io/
07:58:45 <ddellacosta> *main lens docs were decent I should say
08:04:49 <athan> @type sequence . map
08:04:49 <lambdabot>     Couldn't match type ‘[a1] -> [b]’ with ‘[m a]’
08:04:50 <lambdabot>     Expected type: (a1 -> b) -> [m a]
08:04:50 <lambdabot>       Actual type: (a1 -> b) -> [a1] -> [b]
08:05:14 <athan> @type \f -> sequence . map f
08:05:15 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
08:05:26 <athan> @type traverse
08:05:27 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
08:05:39 <athan> cool beans :)
08:07:40 <athan> :t mapM
08:07:40 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
08:07:42 <athan> :t mapM_
08:07:42 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
08:07:46 <EvanR-work> :t T.sequence
08:07:47 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
08:10:20 <Procian> :t Data.Foldable.mapM_
08:10:20 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
08:12:16 <flexfit> maxBound :: Float
08:12:47 <flexfit> Why can't I used minBound or maxBound on Float or Double? Do they have no upper and lower bound?
08:13:31 <EvanR-work> > maxBound :: Float
08:13:32 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Types.Float)
08:13:32 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
08:13:34 <athan> Procian: We should make a super class for all of these!
08:13:45 <EvanR-work> flexfit: correct
08:14:07 <flexfit> > minBound :: Double
08:14:09 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Types.Double)
08:14:09 <lambdabot>    arising from a use of ‘GHC.Enum.minBound’
08:14:17 * hackagebot wai-util 0.8 - Collection of utility functions for use with WAI  http://hackage.haskell.org/package/wai-util-0.8 (StephenWeber)
08:14:17 <EvanR-work> no instance Bounded for Double
08:14:28 <EvanR-work> you can make one if you want
08:14:32 <EvanR-work> but im not sure it will help
08:15:16 <Procian> What would be the maxBound?
08:15:21 <flexfit> I'm just going through the LYAH tutorial and I wondering why Float or Double wasn't included in the Bounded typeclass.
08:15:21 <EvanR-work> > 1/0
08:15:23 <lambdabot>  Infinity
08:15:32 <Procian> > 0.0/0.0 < 1.0/0.0
08:15:34 <lambdabot>  False
08:15:50 <EvanR-work> so not a great max bound
08:16:09 <EvanR-work> float once again cant follow the laws
08:18:43 <Procian> EvanR-work: Saying that, my implied point would suggest that Float and Double should not even be instances of Eq.
08:18:51 <Procian> Or Ord.
08:19:04 <EvanR-work> float is the reason why Eq and Ord dont have any specified laws
08:19:12 <EvanR-work> or Num for that matter
08:19:51 <Procian> EvanR-work: Interesting. Is there a quote to that effect?
08:20:14 <EvanR-work> no it just follows from trying to assert some laws, and then someone pointing out how floats work
08:21:01 <EvanR-work> should + andor * distribute in Num? too bad because float
08:21:23 <Procian> EvanR-work: Yeah, but I think Num is pretty horrendous as a type class anyway.
08:21:40 <Procian> But Eq should be simple enough.
08:21:45 <EvanR-work> except for NaN
08:22:34 <EvanR-work> > let nan = 0/0 in nan == nan
08:22:35 <lambdabot>  False
08:23:09 <Procian> That sucks, but I don't mind bending the rules exactly once for IEE754.
08:23:29 <vanila> Does anyone have a beginners guide to setting up stackage? and is there a comparison against cabal sandboxes? I'm pretty lost on all this
08:23:41 <EvanR-work> well NaN would then break any code that took advantage of the laws
08:23:44 <merijn> vanila: Stackage has a different goal from cabal sandboxes
08:23:50 <bennofs> vanila: stackage is only a list of constraints for your package versions
08:24:00 <bennofs> vanila: which were tested to work well together
08:24:12 <merijn> vanila: Stackage is just a "stable set of tested constraints that compile"
08:24:24 <vanila> ok! It definitely sounds like stackage is what I wnat
08:24:30 <merijn> vanila: sandboxes are "compile stuff seperately from your user package database"
08:24:50 <merijn> vanila: stackage is mostly what you want for stable, user buildable applications
08:25:18 <merijn> sandboxes are what you want if you need a development tool that lets your work on something seperate from your installed stuff
08:25:38 <merijn> Procian: The haskell report actually includes even more misfeatures
08:25:41 <vanila> That's very clear, thank you :)
08:25:58 <merijn> Procian: Like requiring an Eq and Show superclass for Num (GHC doesn't follow the report in this)
08:26:12 <Procian> Wow.
08:26:25 <merijn> Procian: "It seemed like a good idea at the time"
08:26:59 <Procian> Surely they'd have noticed that they didn't actually need to use show or any functions polymorphic over that type class to define their Num instances?
08:27:26 <EvanR-work> does a sometimes/always bottom implementation of a class follow the laws? ;)
08:27:33 <merijn> Procian: It's not that it's *necessary*, but they figured "what good are non-printable numbers?"
08:27:36 <EvanR-work> (eq on CReal)
08:28:11 <merijn> Procian: And the report committee is rather conservative so they try to avoid changes, perhaps too much
08:28:26 <merijn> (See how long we were stuck without an applicative superclass for Monad)
08:28:43 <remdezx> Hello! Is there any equivalent of Control.Lens.Zipper in lens-4.6?
08:28:55 <Procian> merijn: That made sense. Back in 98, did anyone know tha applicative functors were a good idea?
08:29:02 <vanila> the instructions on http://www.stackage.org/ are a bit brief: Can I just make a directory anywhere and go 'cabal init' to set up a project, then copy that cabal.config file there? and is there a way to test/confirm that i'm "using stackage"
08:29:03 <Procian> *that
08:29:13 <merijn> Procian: They weren't invented until, I think, 2001 or 2004
08:29:18 * hackagebot ripple-federation 0.3 - Utilities and types to work with the Ripple federation protocol  http://hackage.haskell.org/package/ripple-federation-0.3 (StephenWeber)
08:29:20 <vanila> I also read about a server that you tell cabal about, bu tmaybe that was an earlier version
08:29:37 <bennofs> remdezx: zippers got separated into the zippers package
08:29:44 <bennofs> @hackage zippers
08:29:44 <lambdabot> http://hackage.haskell.org/package/zippers
08:29:46 <merijn> Procian: Hell, even monads were only added like a decade after haskell started :)
08:29:55 <remdezx> bennofs: thanks!
08:30:45 <merijn> Procian: Incidentally, I can recommend reading the actual Haskell report. It is probably one of the most readable language specs in existence
08:31:12 <merijn> Unlike, say, the C and C++ specs >.>
08:31:16 <nkar> does "associated types with class" contain all the information on type families?
08:31:17 <Procian> lol
08:31:26 <Rufflewind> merijn: haha
08:31:27 <nkar> or do I need to read other papers?
08:31:40 <merijn> nkar: Fun with Type Functions is another good type families paper
08:31:47 <Procian> merijn: Or any spec coming out of W3C.
08:31:59 <merijn> nkar: Unsure whether it covers anything different from "associated types with class", though
08:32:12 <nkar> merijn: which one would you recommend?
08:32:47 <merijn> nkar: I figured most of it out by just reading "Fun with Type Functions" + GHC manual + lots of trial and error :)
08:33:47 <merijn> nkar: See also my usual examples of neat type families abuse: https://gist.github.com/merijn/6130082 and https://gist.github.com/merijn/39dc86e345e87276c523
08:34:02 <nkar> oh, it's by oleg, simon, and ken.  will definitely read it
08:34:23 <nkar> thanks for all the pointers, merijn
08:34:27 <nkar> have to go now :)
08:39:18 * hackagebot wai-session 0.3 - Flexible session middleware for WAI  http://hackage.haskell.org/package/wai-session-0.3 (StephenWeber)
08:39:35 <toblerone> How do I make a library I wrote on my machine available throughout the system? I've tried cabal register, but I'm guessing that cabal sandbox is interfering and keeping it local
08:41:19 <kadoban> toblerone: cabal install --user  or cabal install --global  I believe
08:41:36 <kadoban> Oh library...maybe not.
08:42:40 <toblerone> ill give that a shot
08:43:28 <toblerone> yeah... still installed to the sandbox
08:49:03 <Fuuzetsu> mhm, I just bought a large toblerone block
08:50:30 <toblerone> a block?
08:50:43 <toblerone> i thought they were only rod shaped
08:51:44 <Fuuzetsu> well, a large rod-shaped piece
08:52:18 <toblerone> Fuuzetsu: you're knowledgable. :-) I have written a library and I've made use of cabal sandbox. I want to be able to use this library in other projects, but I can't figure out a way to install and register it outside of the sandbox
08:53:22 <flexfit> Is there a reason why length returns an Int instead of Num?
08:54:02 <Iceland_jack> There is 'genericLength'
08:54:03 <Iceland_jack> @ty genericLength
08:54:04 <lambdabot> Num i => [a] -> i
08:54:05 <toblerone> flexfit: legacy I think. there is a genericLength function i think
08:54:16 <Iceland_jack> But you should just use:
08:54:16 <Iceland_jack> from
08:54:18 <Iceland_jack> :t fromIntegral . length
08:54:19 <lambdabot> Num c => [a] -> c
08:54:31 <glguy> length can be more efficient when it knows the type
08:54:51 <ski> Iceland_jack : doesn't work for infinite lists
08:54:57 <saep> toblerone: You can add it as a source package. If it doesn't change (often), you can install it via `cabal install /path/to/library/library.cabal`.
08:55:21 <Iceland_jack> ski: Yup
08:55:21 <toblerone> saep: what happens if it changes?
08:55:35 <toblerone> glguy: When wouldn't it know the type?
08:55:51 <glguy> When it's implemented to work on any Num
08:56:09 <ski> `genericLength' could work on an infinite list
08:56:10 <toblerone> yeah, but at compile it knows the type
08:56:24 <Iceland_jack> Yes
08:56:24 <ski> toblerone : existentials
08:56:31 <saep> toblerone: `cabal sandbox add /path/to/library/library.cabal` will recompile the library it it changes.
08:56:32 <glguy> toblerone: That doesn't mean that a specialized version of the function would be instantiated
08:56:48 <saep> toblerone: You have to do that for every sandbox, though.
08:57:54 <toblerone> saep: So you mean to say, that if im in Sandbox A, and I want to include Sandbox B, it might be best to do 'cabal sandbox add /path/to/sandbox/B'
08:59:12 <saep> toblerone: You only incldue the library (i.e. the source code) that way and not the sandbox itself.
09:00:29 <toblerone> hmm... okay. How does this affect the cabal file? Would I have to pull in all of the other libraries dependencies as well?
09:00:55 <saep> You have to add the library as a dependency. The libraries dependencies are then included automatically.
09:01:04 <toblerone> ok
09:02:16 <Fuuzetsu> toblerone: cabal sandbox add-source or whatever the option is called nowadays; I don't use cabal directly anymore
09:03:11 <saep> toblerone: Yeah, it's `add-source` and not `add`. Sorry for that.
09:03:35 <NikolajK> I can't seem to find Lambdabot in the list, what's his name again?
09:03:58 <MP2E> > "hi"
09:04:00 <lambdabot>  "hi"
09:04:08 <NikolajK> I mean in a private window
09:04:12 <NikolajK> for @djinn stuff
09:04:24 <mauke> what list?
09:04:31 <kadoban> His name doesn't change for private message...
09:04:36 <ski> /msg lambdabot @djinn a -> a
09:05:14 * ski notes that lambdabot has traditionally been referred to as "she" or "it"
09:05:46 <kadoban> Oh
09:06:11 <NikolajK> ski, sorry bot
09:06:29 <ski> @botsnack
09:06:29 <lambdabot> :)
09:07:13 <mmachenry> Is there an easy way to get haddock to link to hackage.haskell.org when links are to code that's not in my project?
09:08:47 <pharpend> int-e: Are you around?
09:09:40 <NikolajK> what was negation again, on djinn?
09:10:17 <vanila> x -> Void
09:10:30 <vanila> remember its intuitionistic negation, not classical logic
09:10:47 <NikolajK> of course
09:11:54 <ski> @djinn (Either a (Not a) -> Not b) -> Not b
09:11:54 <lambdabot> f a b = void (a (Right (\ c -> a (Left c) b)) b)
09:13:24 <toblerone> Fuuzetsu what do you mean you don't use cabal?
09:15:55 <Fuuzetsu> I use nix
09:17:23 <toblerone> does nix match cabal's functionality? I thought it was just for package management
09:18:22 <int-e> pharpend: what's up?
09:18:33 <mmmm_> You still use cabal when you use nix
09:18:42 <mmmm_> but not to download and install package deps
09:18:55 <toblerone> yeah
09:18:57 <MP2E> that's not what he said though
09:19:00 <MP2E> he said he doesn't use cabal directly
09:20:54 <mmmm_> you still need a cabal file for instance..
09:21:26 <toblerone> yeah, but when he says he doesn't use it directly, what does that mean?
09:21:42 <toblerone> does nix know how to interface with cabal?
09:22:08 <mmmm_> yes, you can build packages using nix-build
09:22:30 <toblerone> ah
09:22:31 <toblerone> ok
09:22:37 <mmmm_> I don't exactly know how it works tbh, my usual workflow is to use nix-shell and then cabal repl
09:23:26 <mmmm_> I thought it was all very confusing until I started using it but it's actually quite painless
09:25:11 <mmmm_> I actually have a nixos vm rather than use nix on my main system
09:25:16 <pharpend> int-e: I was wondering if you would be so kind as to grace #lysa with lambdabot's presence?
09:25:40 <toblerone> does nix have similar interop capabilities with other languages?
09:26:55 <mmmm_> Judging by what's in nixpkgs, yes but I have never tried
09:27:13 <athan> Hey guys, so I'm trying to do some TH stuff... how can I use normal pure functions with `Q Exp` expressions? I can't even make a function `a -> Q Exp` and use it in my `$( runQ $ foo ...)` expression because the parameters that get applied to `foo` need to be imported... is there a school of thought for this?
09:36:06 <flaggy> what's the difference between :print and :type in ghci?
09:37:09 <toblerone> athan: sorry, I'd love to help but I know very little about Template Haskell... :-)
09:38:23 <Javran> :t \x -> msum (fmap return x)
09:38:24 <lambdabot> MonadPlus m => [a] -> m a
09:38:38 <Javran> @hoogle MonadPlus m => [a] -> m a
09:38:41 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
09:38:41 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
09:38:41 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
09:39:14 <Javran> @hoogle (MonadPlus m, Foldable f) => f a -> m a
09:39:14 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
09:39:14 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
09:39:14 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
09:49:20 <Marlin> is there a way to import by absolute file path rather than by module?
09:51:06 <alpounet> in ghci yes, you can use :load ../foo.hs (or just :l ../foo.hs) -- but within a haskell module itself no
09:56:42 <osa1> what's the fastest way to generate a bytestring from unboxed word8 vector? ((B.pack . UV.toList) `fmap` UV.freeze v) turned out to be too slow
09:58:57 <Fuuzetsu> is there no builtin for this?
09:59:21 * hackagebot microformats2-types 0.2.1 - Microformats 2 types for Haskell.  http://hackage.haskell.org/package/microformats2-types-0.2.1 (myfreeweb)
09:59:33 <Luke> anyone know of a Data.Serialized instance for UTCTime?
09:59:42 <Luke> otherwise i'll make my own
10:02:13 <Fuuzetsu> mmmm_: you don't *need* a cabal file just like you don't *need* cabal itself, it's just convenient ;P
10:07:11 <mmmm_> Fuuzetsu: How does nix-build work without a cabal file? Where do you specify all the options found in a cabal file?
10:10:37 <michaelt> osa1: you can just use V.foldr B.cons V.uncons, but vector doesnt have a predefined uncons
10:11:10 <michaelt> osa1: woops deleted a bit of that
10:11:19 <michaelt> osa1: V.foldr B.cons B.empty
10:13:46 <meditans> hi, lens question here. Let's say I have f :: Traversal' a b
10:14:11 <meditans> with a ^.. f I can get a list of bs. Is there a way to set the list of bs inside of an a?
10:15:16 <supki> > [1, 2, 3] & partsOf traverse .~ [4, 5, 6]
10:15:17 <lambdabot>  [4,5,6]
10:15:44 <meditans> supki: thanks!
10:15:51 <osa1> michaelt: 1) I'm converting from vector to bytestring, not the other way 2) that'd probably be super slow too, I need zero copying
10:16:21 <osa1> I found a library named spool which worked great
10:16:26 <osa1> I'm not sure how safe it is though
10:16:40 <michaelt> osa1: V,foldr B.cons B.empty is Vector -> ByteString
10:19:16 <michaelt> osa1: my experience is that conversions from Vector to Vector and Bytestring and Vector are very fast with unfoldr uncons , though with vector you have to write the uncons. If the Vector was Storable, of course you could just unwrap the bytestring
10:19:45 <osa1> michaelt: yeah I just did that storable trick
10:20:00 <osa1> michaelt: fold is not fast enough, I need zero-copying
10:20:19 <michaelt> osa1: oh I thought you had an unboxed, not a storable vector
10:20:50 <osa1> michaelt: I had unboxed at first, but I switched to storable one
10:21:01 <osa1> as far as I understand storable ones are unboxed too
10:21:23 <osa1> I have 1gb vector and if I use boxed I'm having memory overflow :F
10:21:24 <michaelt> osa1: oh ok.  there are several places where this is done, eg in the monotraversable package.
10:22:17 <michaelt> http://hackage.haskell.org/package/mono-traversable-0.7.0/docs/Data-ByteVector.html
10:24:49 <michaelt> osa1: the code is extremely short it's just converting the pointer see, e.g. https://github.com/basvandijk/vector-bytestring/blob/master/Data/Vector/Storable/ByteString/Legacy.hs
10:25:56 <michaelt> or https://github.com/snoyberg/mono-traversable/blob/master/src/Data/ByteVector.hs
10:38:48 <Denommus> hi
10:39:59 <osa1> uh, MultiWayIf and NondecreasingIndentation are not working together
10:43:25 <Chathurga> Wow that's a strong pragma name
10:49:23 * hackagebot base-prelude 0.1.9 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.9 (NikitaVolkov)
10:51:24 <toblerone> Okay, so I've tried using 'cabal sandbox add-source ../path/to/project/' 'cabal install --only-dependencies' but this fails with "Dependency tree exhaustively searched"
10:51:34 <toblerone> anything I should do differently?
10:51:54 <toblerone> I've verified that both projects have consistent dependencies
10:52:05 <toblerone> and each project only has the lower bounds specified
10:57:57 <athan> toblerone: Are you in a sandbox?
10:58:11 <athan> erm, derp
11:00:31 <athan> toblerone: All I've got is `--max-backjumps=-1` :/
11:05:39 <athan> Hey guys, so I've got a pattern I'm working with - a fold over a nested data structure, where the accumulator should support _total_ backtracking down to the root of the original structure. Is there a pattern for this?
11:06:03 <toblerone> athan: I figured out my mistake
11:06:12 <toblerone> thanks anyway :-)
11:19:14 <hrumph> hi
11:20:30 <hrumph> hi
11:20:43 <hrumph> gas everyone seen the following:
11:20:47 <hrumph> http://www.cse.chalmers.se/~nicsma/no-state-monad.html
11:21:01 <hrumph> i'm wondering if there are real world implications for this
11:21:13 <Cale> hrumph: Pretty much no
11:22:01 <Cale> hrumph: seq is something which basically breaks a lot of equational properties
11:22:30 <Cale> hrumph: This really has nothing to do with the state monad in particular -- many many equational properties get broken by the presence of seq.
11:23:03 <vanila> it's a monad if you only consider well defined values
11:23:16 <Cale> But see http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
11:23:48 <sinelaw> <ski>   # let rotate angle p = (p#new_x (cos angle *. p#get_x -. sin angle *. p#get_y))#new_y (sin angle *. p#get_x +. cos angle *. p#get_y);;
11:24:19 <sinelaw> ski, I can almost get that working now. I think the only thing blocking me is normalization of recursive types
11:25:16 <vanila> What is normalization of recursive types?
11:25:23 <sinelaw> vanila, a term I made up
11:26:13 <sinelaw> vanila, but what I mean is that if X = a -> b -> X, and Y = a -> b -> a -> b -> Y, then I should be able to tell that they are actually equal
11:26:50 <vanila> I guess this is undecidable in general, at least for nested recursive types
11:27:02 <vanila> it's similar to CFG equality testing isn't it?
11:27:10 <sinelaw> what's CFG?
11:27:20 <vanila> context free grammar
11:28:59 <sinelaw> vanila, because they allow recursion?
11:29:57 <vanila> yeah
11:30:55 <sinelaw> vanila, by nested you mean mutual recursion?
11:31:37 <vanila> I meant something else but mutual recursion is probably bad enough already
11:32:00 <hrumph> cale yes i know its a monad if everything is fully well-defined....if not could it interfere with the logic of a program somehow?
11:32:14 <hrumph> could it interfere with our expected opoeration of a monad?
11:32:17 <sinelaw> you meant: X = a -> Y -> X and Y = c -> Y?
11:32:50 <sinelaw> vanila, ^^^ that's not mutually recursive, is that what you meant?
11:33:40 <Cale> hrumph: Only if you have a tendency to use undefined State actions, which probably would mean that you've done something wrong anyway.
11:39:27 * hackagebot base-prelude 0.1.10 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.10 (NikitaVolkov)
11:41:32 <toblerone> Question about STM: I don't have a good sense about the exact behavior of its usage. Say I wanted a map that can be modified by several threads, and this map contains data that could be modified as well. Would I have to do something like "TVar (M.Map Key (TVar Val))"?
11:41:41 <toblerone> Is this a bad idea in general? :-)
11:42:10 <bergmark> toblerone: check out stm-containers
11:43:54 <toblerone> bergmark: hmm, looks good
11:43:58 <toblerone> thanks for the top
11:43:59 <toblerone> tip
11:45:00 <ski> sinelaw : i think it's decidable
11:46:18 <sinelaw> ski, that would be good new
11:46:20 <sinelaw> *news
11:47:44 <ski> sinelaw : add identity to each node in the graph, compare structure-wise, but if you reach the same node on both sides, succeed immediately
11:48:03 <arianvp___> Does anybody know how to fix this cabal problem? : http://lpaste.net/117425
11:48:53 <ski> sinelaw : hm, well, that only handles the case where you eventually get identical
11:49:04 <Intolerable> is there an XML / HTML parser that uses Text instead of String
11:49:25 <ReinH> hrumph: For example, can you write a Functor instance for data Maybe' a = Nothing' | Just' !a
11:49:32 <ski> sinelaw : i think you need to add a local assumption that the two current nodes are equal, when moving down recursively
11:50:44 <arianvp___> I've never ever been able to install ghc-mod :/
11:50:55 <supki> arianvp___: try with --constraint='Cabal == 1.18.1.3'?
11:51:07 <ski> sinelaw : basically : if `Gamma,alpha = beta |- sigma = tau' then `Gamma |- (fix alpha. sigma) = (fix beta. tau)'
11:51:25 <arianvp___> otherwise I can just bild ghc-mod in a sandbox right?
11:51:40 <supki> yeah, this works too
11:51:52 <arianvp___> yeh more errors
11:51:58 <arianvp___> im gonna do the sandbox approach
11:52:14 <toblerone> bergmark: I might be missing something but is there a way to get the keys from the map? :-)
11:52:22 <arianvp___> freakin cabal
11:52:27 <arianvp___> >:(
11:55:27 <arianvp___> supki: do I NEED to have a valid cabal project to use a sandbox? :S
11:55:51 <supki> no
11:56:04 <arianvp___> hmm I still get the same error inside a sandbox..
11:56:07 <arianvp___> weird
11:56:24 <arianvp___> http://lpaste.net/2939625705014558720
11:56:36 <supki> do you have Cabal 1.20 installed globally, perhaps?
11:56:45 <arianvp___> Cabal 1.22
11:56:52 <arianvp___> is that the problem?
11:57:13 <arianvp___> I think..
11:57:19 <arianvp___> how do I check versions I installed?
11:57:25 <supki> yeah, sandboxes still see the globally installed packages
11:57:30 <supki> ghc-pkg list
11:57:45 <arianvp___> Yeh I got Cabal 1.20 installed globally
11:59:09 <michaelt> arianvp___: you have the old 'transformers' wired to your ghc, so to say
11:59:52 <arianvp___> http://lpaste.net/1239009764663361536 that's what I got installed.
12:00:03 <arianvp___> I still dont really get how installing stuff can break other stuff.
12:00:38 <sinelaw> ski that was hard to read. is this what you wrote? http://quicklatex.com/cache3/ql_3ba75e58db571d0ba9ec74f6438c1c65_l3.png
12:02:03 <yonoid> arianvp___: if you can invest the time, using Docker containers you can sidestep most of those issues
12:02:13 <michaelt> arianvp___: but i wonder how you got that mtl in there doesnt it need the new transformers?
12:02:15 <sinelaw> ski, is that just alpha equivalence or am I missing something?
12:02:25 <arianvp___> yonoid: I was thinking using nix expressions. I guess they solve a similar problem
12:02:47 <arianvp___> michaelt: Don't ask me. I've had this install for 4 days
12:02:54 <arianvp___> I just installed stuff I needed :/
12:03:03 <michaelt> arianvp___: if you do ghc-pkg unregister mtl does it warn about a lot of breakage?
12:03:26 <michaelt> oh wait, this is a sandbox?
12:03:31 <arianvp___> michaelt: yeh. HTTP-4000, network-uri, parsec
12:03:37 <arianvp___> michaelt: and yes
12:03:45 <arianvp___> but it also happens outside a sandbox
12:06:39 <arianvp___> michaelt: How would I reset my ghc to a clean state?
12:06:44 <michaelt> arianvp___: yeah transformers 4 has to go. What I don't get why parsec & co. built with it.  There is a formula for the cabal config file about using existing packages
12:07:19 <michaelt> arianvp___: ghc is fine. the local stuff, some of it needs to be unregistered, if I'm understanding
12:08:43 <michaelt> arianvp___: first just try ghc-pkg unregister parsec ; ghc-pkg unregister network-uri then for HTTP-4000 and mtl
12:09:04 <arianvp___> michaelt: with --force I guess?
12:09:10 <michaelt> arianvp___: then try to install all of them together cabal install ghc-mod ...
12:09:22 <michaelt> arianvp___: you don't need force if you do it in order, but yes
12:10:13 <michaelt> arianvp___: usually I clean it out by cutting and pasting the local stuff and surrounding each line with ghc-pkg unregister $package --force in my editor.... but I'm a slob
12:11:08 <mrphy> Hello, friends! Just getting started with Haskell and jumping into the community :)
12:11:13 <michaelt> but you don't need to remove everything
12:11:21 <michaelt> hello mrphy!
12:11:52 <arianvp___> ok did all that
12:11:59 <arianvp___> still not working :(
12:12:18 <ski> sinelaw : hm, yes that's what i wrote
12:12:30 <arianvp___> http://lpaste.net/4154177533597712384
12:13:46 <ski> sinelaw : thinking again, i think we also need something more. possibly extra assumption that `alpha = (fix alpha. sigma)' and `beta = (fix beta. tau)'
12:14:03 <arianvp___> hey mrphy!
12:14:14 <mrphy> Thanks for the kind welcomes!
12:14:15 <michaelt> arianvp___: right,, you need bounds or the device I mentioned in the config file, just a src
12:14:25 <Marlin> I am in IO and I want to use throwIO instead of error, but I can't find an existing exception type that accepts a string. do I have to create my own exception type?
12:14:38 <ski> sinelaw : hmm
12:15:19 <sgillis> I have a typeclass Heap, which has operations "empty" and "merge". I can use these operations to make any instance of the Heap typeclass also an instance of Monoid. But is there a way to do this once instead of writing two instances for every instance of Heap?
12:15:39 <ski> sinelaw : nah, this can't be enough. we also need some rule for unrolling a `fix'
12:15:40 <michaelt> arianvp___: hah, the line I have in my .cabal/config is just " constraint: transformers installed "
12:15:49 <sinelaw> ski, how does that rule deal with my example? X= a->b->X,   Y=a->b->a->b->Y
12:15:57 <sinelaw> ski, yeah
12:16:02 <arianvp___> michaelt: I dont get it.  I have a clean ghc install now and it still happens... inside a sandbox
12:16:05 <arianvp___> :/
12:16:59 <michaelt> arianvp___: yes, it's because you aren't allowed to have a new transformers. the ghc package is already using 3.0
12:17:20 <michaelt> so you get an ugly triangle if ghc-mod also uses mtl + transformers 4
12:17:41 <geekosaur> arianvp_, sandbox only sandboxes user packages. there are also global packages... many of which are installed with, and must match, ghc itself.
12:18:04 <geekosaur> so you can't safely install a different version of transformers than came with your ghc
12:18:07 <yonoid> There is now an official Docker image for Haskell at https://registry.hub.docker.com/_/haskell/
12:18:18 <yonoid> You could just mount your working dir an make all this pain go away
12:18:55 <arianvp___> yonoid: Do you know of some good tutorials for docker? I wanted to introduce it to our work environment anyway for reproducible builds
12:19:39 <michaelt> arianvp___: so you need an mtl appropriate to your ghc. try cabal install mtl --constraint=2.*  (I think that's how you write it).  Or put the line " constraint: transformers installed " in $HOME/.cabal/config
12:19:58 <arianvp___> michaelt: the constraint fixed it :)
12:20:07 <yonoid> I got started with Docker this summer and I followed the interactive tutorial here https://www.docker.com/tryit/
12:20:13 <michaelt> arianvp___: right, I think that was the best plan.
12:20:41 <yonoid> After that I used the user guide and reference on the Docker website.  I never had a need to look outside of that
12:21:07 <arianvp___> yonoid: Are you on #haskell-blah?
12:21:34 <yonoid> no, didn't know about it
12:21:36 <michaelt> arianvp___: I think someone said this problem only comes up if your package wants to use the ghc api as ghc-mod does, or maybe some other way
12:22:21 <geekosaur> ghc api or (I have heard varying reports) TH
12:23:13 <geekosaur> but the other issue is that if you replace transformers in your sandbox, you must also install in your sandbox any global packages that were installed against the global transformers, installed against the new one
12:23:27 <arianvp___> one other minor thing. I notice cabal is only using one core when I compile
12:23:31 <geekosaur> (technically only those that uou need, but many of the global packages are rather widely used)
12:23:53 <arianvp___> orr maybe that was an illusion. nv
12:23:56 <arianvp___> nvm*
12:24:57 <arianvp___> ...  ghc-mod install failed silently with "ExitFailure 1"
12:25:05 <arianvp___> ughh I'm gonna pull my hair out for real now
12:25:08 <michaelt> right, that's the general principle, but I thought it was just a couple things that use transformers, among the boot packages or whatever theyre called. ghc api and maybe TH ...
12:25:17 <arianvp___> T_T
12:25:36 <arianvp___> http://lpaste.net/6019649372629762048
12:26:44 <michaelt> okay i'm trying it myself arianvp___
12:28:19 <michaelt> oh cpphs is instaling, suggesting some tricky work ahead...
12:31:20 <Marlin> would I need to write a Monad transformer for this? can you recommend some other solution? I want to abstract away a mess of cases and ifs every time I read a value from a config file. http://lpaste.net/117428
12:32:24 <michaelt> Marlin: this is the ReaderT monad, if you want the packaged solution.
12:33:52 <Marlin> michaelt I forgot to mention that readConfig returns IO, because it is reading the value from a file (config file can be updated during the runtime). would ReaderT still work?
12:34:52 <michaelt> Marlin: yes, but I think you need a different solution
12:36:36 <Marlin> such as?  I used  monad transformers once, and never wrote my own, so I am a bit lost if that (or what else) would be an idiomatic way of handling this in haskell
12:36:36 <michaelt> oh wait, that just means that in ReaderT Config IO x, the Config is really the file, it's ReaderT FilePath IO x
12:37:38 <Marlin> that sounds good.. so ReaderT is what I want
12:39:22 <michaelt> Marlin: it is if things get complicated, but of course it's just equivalent to making everythign depend on an extra parameter for the config file.
12:40:56 <Marlin> but what about behavior I posted in lpaste.. displaying a message box on fail
12:41:11 <Marlin> on a failture to read some value from a config file
12:41:36 <Marlin> will ReaderT actually give me that? i never used it before
12:41:57 <michaelt> Marlin, which is more straighforward ...   with ReaderT FilePath IO x, you would write    do cfg <- ask;  etc
12:43:52 <michaelt> then you reduce the whole block to regular io by doing iofunction config = runReaderT config $ readeriomonadaction
12:44:16 <greymalkin> Wow.. case statements are slow.
12:44:25 <arianvp___> Marlin: I would for example fix that this way:
12:44:29 <arianvp___> one moment. writing haskell
12:45:17 <greymalkin> I just changed a case (Maybe) statement into a maybe <default> id (Maybe) to make the code a bit more concise... and it drastically improved the performance.
12:45:43 <greymalkin> (it's used in a very tight loop)
12:50:12 <michaelt> greymalkin: that is surprising. But maybe it was just a stylistic preference that had me preferring explicit case there.
12:50:40 <greymalkin> Nevermind -- appears to be a couple commits back -- trying to isolate now.
12:56:17 <Marlin> arianvp_ I need to step away from the keyboard for a bit, but I'll take a look at your code. thanks in advance, thanks to you too michaelt
12:56:26 <arianvp___> Marlin: no problem :)
12:59:52 <arianvp___> Marlin: http://lpaste.net/117429
13:06:47 <arianvp___> michaelt: Have you been able to install it?
13:07:26 <CasW> Hey guys, can you help me? I have a class Monad m => MonadGamble m where toss :: m Coin and I have an instance Random Coin, now I want an instance MonadGamble IO where I define toss as taking a random coin (heads or tales), but how do I now get a random number generator to use in the Random Coin?
13:08:33 <arianvp___> CasW: FP at UU? :P
13:08:44 <arianvp___> I'm pretty sure I've done that exercise before
13:08:45 <CasW> Ghehe, yeah. Hey Arian :-P
13:10:28 <arianvp___> I'lll see if I can help you without giving too much away ;)
13:10:43 <toblerone> Casw: You say you have defined an instance of random for your monad?
13:11:26 <CasW> No, for the data type Coin, Random Coin is defined
13:12:43 <toblerone> Yeah, so somewhere 'random' and 'randomR' is defined for Coin... unless im missing something...
13:12:59 <CasW> Exactly. Coin's just not a monad ;-)
13:13:06 <michaelt> arianvp___: sorry, I totally forgot about it. Indeed it failed but over something that must be a mismatch between ghc-mod and whatever defined StM ... one of those MonadBaseControlCentre things
13:13:09 <toblerone> Oh sure
13:14:07 <toblerone> So with those functions defined you can make use of the rest of functions defined in the class. https://hackage.haskell.org/package/random-1.0.0.2/docs/System-Random.html#4
13:14:30 * hackagebot yesod-auth-hashdb 1.4.1.2 - Authentication plugin for Yesod.  http://hackage.haskell.org/package/yesod-auth-hashdb-1.4.1.2 (paulrouse)
13:15:18 <toblerone> If you look at the signatures of those, many of them take a RandomGen and return an 'a', which in your case is a Coin
13:19:18 <arianvp___> CasW:  you can use getStdGen to generate a StdGen and then call  random :: g -> (Coin,g)
13:19:21 <toblerone> that make sense? So for instance, because Random Coin has been defined, in ghci you could do something like "coin <- randomIO :: IO Coin" to get a coin using the global randomgen
13:19:38 <arianvp___> or indeed use randomIO which is a shorthand for that :P
13:20:03 <CasW> Yeah, I'll try that. Thanks!
13:27:10 <michaelt> arianvp___: ghc-mod doesn't have upper bounds for monad-control so I had to reinstall an older version of it like so http://sprunge.us/fTPS
13:27:22 <michaelt> arianvp___: then everything was fine
13:31:27 <Thrzsh> What's the easiest way to shuffle a list?
13:32:19 <arianvp___> easiest or most correct?
13:33:10 <Thrzsh> easiest, doesn't have to be perfect
13:33:20 <hodapp> If I have a pattern cropping up inside a monad that is like:  Foo.bar (a + 0) ... >> Foo.bar (a + 2) ... >> Foo.bar (a + 5) ...
13:33:34 <shapr> hodapp: sequence_ ?
13:33:38 <shapr> :t sequence
13:33:39 <lambdabot> Monad m => [m a] -> m [a]
13:34:32 <arianvp___> Thrzsh : easiest + most correct http://hackage.haskell.org/package/random-shuffle
13:34:42 <arianvp___> cabal install random-shuffle
13:34:46 <Peaker> hodapp: mapM_ ?
13:34:58 <shapr> yeah, mapM_
13:35:06 <hodapp> The other part is that the 0, 2, 5... are most meaningful in terms of their deltas
13:36:03 <danilo2> Hello! Is there in Haskell any typeclass that provides error messages? I mean - I've got a datatype that describes different errors. I want a standard way of generating error strings. This would be very simple typeclass, but I would love to use standrad one if such exist
13:36:16 <athan_> hodapp: traverse?
13:36:34 <Peaker> danilo2: class Pretty ?
13:36:54 <athan_> danilo2: MonadLogger?
13:36:59 <Peaker> hodapp: mapM_ (Foo.bar . (a+)) [0,2,5,...]
13:37:02 <Peaker> hodapp: ?
13:37:32 <eikke> in 'f v', do you say v is applied to f, or f is applied to v?
13:37:36 <hodapp> Peaker: what I mean is that those values are most meaningfully represented not as absolutes, but as an accumulation of deltas
13:37:56 <Peaker> hodapp: but that doesn't have anything to do with the Foo.bar or (a+) parts, right?
13:38:00 <Peaker> hodapp: it's just how you generate the pure list?
13:38:03 <athan_> Peaker: Form of, IRC helper guy!
13:38:11 <hodapp> Peaker: hmmm, I suppose so
13:38:21 <Peaker> athan_: what? :)
13:38:28 <kadoban> hodapp: Well, what input do you have? If you have the deltas in a list, it's pretty easy to generate the actual values from that.
13:38:30 <athan_> Peaker: Wonder twins!
13:38:33 <danilo2> Peaker, athan_ : I think I need something like Pretty more than the logger one. Peaker where can I found this? I've just searched over some repos but I didnt found a class named Pretty
13:38:37 <Peaker> hodapp: so you want something like iterate to generate the list?
13:38:51 <Peaker> danilo2: there are unfortunately multiple competing ones on Hackage
13:39:16 <Peaker> danilo2: https://hackage.haskell.org/package/pretty-class-1.0.1.1/docs/Text-PrettyPrint-HughesPJClass.html#t:Pretty <-- maybe this one?
13:39:25 <danilo2> Peaker: oh, I see. Which one is "the best"? I know "the best" is not clear, but maybe there is one that is a "stnadard" now
13:39:39 <athan_> hodapp: You might be able to capture the accumulation within the monad :s
13:39:52 <Peaker> danilo2: not sure - you can look up reverse dependencies and see which are the most widely used ones
13:40:07 <danilo2> Peaker: good idea! thank you!
13:40:13 <hodapp> athan_: well, I think it might be easier and more comprehensible to just use mapM_ and generate the absolute values
13:40:19 <Peaker> hodapp: does your list of deltas get built purely?
13:40:41 <hodapp> Peaker: yeah, it'll likely just be a pile of constants
13:40:45 <athan_> hodapp: (: ping me if you run into a weird idea that you can't really hurdle over and can't make a clear question about!
13:41:35 <Peaker> hodapp: so something like: mapM_ (someAction ...) $ iterate nextDelta firstDelta  ?
13:50:33 <hodapp> :t foldM
13:50:34 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:50:37 <hodapp> here we go!
13:53:48 <hodapp> well, maybe.
13:54:04 <Peaker> weird - "cabal configure" and "cabal build" use one Cabal version, whereas "cabal install" seems to be using a different Cabal version
14:37:43 <arianvp___> Marlin: did that example help?
14:40:55 <jperkins> hey!
14:41:00 <vanila> hi
14:41:13 <jperkins> I am still getting used to IRC
14:41:32 <jperkins> I am using  CIRC
14:41:49 <jperkins> anyone have any tips?
14:41:56 <jperkins> why is everyone leaving?
14:42:25 <jperkins> Irony...solace's connection was closed for inactivity
14:42:28 <arianvp___> jperkins: Those are netsplits.  IRC is a distributed networkk and sometimes people get moved to other servers
14:42:40 <jperkins> ok
14:42:49 <arianvp___> (that's usually when a lot of people leave at the same time)
14:42:49 <jperkins> thanks
14:42:55 <jperkins> ok
14:43:36 <jperkins> what are some active IRC channels for general chat?
14:44:10 <jperkins> ?
14:44:25 <platz> jperkins: reddit
14:45:12 <jperkins> Cannot join channel (+r) - you need to be identified with services.  What does this mean?
14:45:49 <jperkins> ?
14:46:21 <arianvp___> It means you need to register with NickServ. https://freenode.net/faq.shtml#plusr
14:46:41 <arianvp___> I don't think #haskell is the best place to discuss this stuff. I'm happy to help you in the channel #haskell-blah
14:46:48 <platz> jperkins: the #freenode channel is a good place too
14:47:03 <jperkins> thanks
14:47:41 <aisqwe> is there something like " theMatcher (theMatchee param1 _* ) " when theMatchee has many parameters after param1 and all of them get wildcard matched?
14:48:17 <jperkins> platz: is #freenode active?
14:50:36 <geekosaur> aisqwe, if you use record syntax to define the type then you can match a single field using record syntax or use the NamedFieldPuns extension, or the RecordWildCards extension to get all of them
14:51:28 <geekosaur> but I'm not quite clear on what you're trying to do, since what you quoted is invalid syntax
14:51:47 <aisqwe> geekosaur, do you mean {theMatcher:: bla bla,} cause in my case this does not work because i have to use theMatcher for other types
14:51:50 <Marlin> arian thanks, it does help figuring out ReadT, but I am not sure where I am supposed to handle errors (failing to fetch a value)?
14:52:10 <Intolerable> if i have a function f :: a -> Maybe b, is there some useful lens i can get from that?
14:52:17 <Peaker> aisqwe: theMatcher TheMatchee{param1} = ...
14:52:26 <geekosaur> aisqwe, pattern matching works by structure, you cannot capture a constructor that way. or, show a real example so I can understand what you are trying to say
14:52:35 <jperkins> I am trying to make my own channel, it says I am not logged in when i try to register
14:52:45 <Peaker> Intolerable: what kind of lens are you looking for?
14:52:46 <jperkins> (with chanserv)
14:53:25 <mmachenry> Is the runtime of "take n $ sort l" O(n*lg m) where m is the length of l?
14:53:48 <glguy> Intolerable: The best you can get from that is a "Fold"
14:53:51 <Peaker> Intolerable: I think you could get a fold
14:55:01 <Intolerable> how would i get a fold out of readMaybe then?
14:56:37 <Marlin> arian do I handle it manually in test? I wanted to avoid that, and have the withConfig function handle the errors to fetch values (or parse a file) automatically, reporting the error to the user and not performing IO
14:56:40 <glguy> folding readMaybe :: Read a => Fold String a
14:57:38 <aisqwe> geekosaur: for example a getPosition function that should work on " Turtle Pos Speed1 Speed2 Speed3 :: Animal deriving (Positionable)" and "Spaceship Pos Gun1 Gun2 :: Vehicle deriving (Positionable)" and i dont want to write _ _ _ but instead sth like _* to match useless parameters
14:58:26 <Intolerable> ty
14:59:06 <geekosaur> you cannot pattern match that
14:59:10 <Intolerable> is there some way of using applicative to write a parser kind of thing like you can with aeson / attoparsec / parsec?
14:59:18 <Marlin> withConfig $ do <get a bunch of values. if anything fails report to the user and abort> <if nothing failed, perform this IO action>
14:59:41 <hodapp> oh, that's awesome, the one time that I cannot seem to Ctrl-C my way out of something is the exact time I need to... which is when some library is using gigs and gigs of memory for no clear reason
15:06:55 <jperkins> join ##jperkins
15:09:28 <aisqwe> how are extensions implemented?
15:12:04 <agibiansky> Does anyone have any suggestions on where to host a very large application file? I want to release an application that bundles GHC/cabal/a ton of libraries and it all comes out to around 2 GB, though less when compressed, but either way could get a bit costly if a lot of people download it from S3...
15:13:31 <vanila> you could use a torrent
15:13:38 <vanila> that is very robust
15:14:15 <agibiansky> vanila: Yeah, thought about that, but how many haskell beginners really want to download a torrent to get started, seems like a bit of a weird flow :)
15:14:47 <jperkins> will someone explain to me about bots
15:14:47 <agibiansky> maybe just a dropbox link, guess i'll just look around on the internet some more :)
15:15:26 <vanila> jperkins, you should just ask about haskell here
15:15:38 <jperkins> ok
15:21:18 <jtanguy> aisqwe: if what you need is a polymorphic `getPosition` you could use a typeclass
15:23:40 <aisqwe> jtanguy: i have a Positionable class, but when i write the getPosition in my instances i would like to reduce the _ _ _ so that if i add another parameter to my types i dont have to modify all my getPosition implementations
15:24:37 <deech> Question about UndecidableInstances: if I'm certain that the typechecker will terminate and don't care about backtracking is it OK to use?
15:24:39 <geekosaur> aisqwe, I told you how to do that, record syntax. BUT, you seem to think you can apply this to a polymorphic value, and yoy cannot
15:25:10 <geekosaur> you are better off using a typeclass method in that case, and then you can use record syntax as I described
15:25:47 <aisqwe> geekosaur: i also want to avoid record syntax because i would have to name my polymorphic types with different names
15:25:47 <jtanguy> maybe derive the instances with th ?
15:26:05 <jtanguy> like the makeClassy stuff in lens
15:26:26 <geekosaur> in any case, no, there is no multiple wildcard like _*.
15:28:13 <pyry`> Anyone here super familiar with conduit?
15:28:58 <pyry`> This is probably just me having a brainfart but I'm trying to figure out how to actually get it to work with utf8-- there's the Data.Conduit:Text library, which has helpers for converting byte string to text and decoding/encoding
15:29:09 <pyry`> but thennnn, that doesn't seem to matter if AppSource only expects ByteStrings
15:29:50 <pyry`> unless this means i'm just supposed to make my own AppData with Source m Text, and such
15:30:56 <recursion-ninja> Hello Haskellers, I'm considering taking up maintainership of a hackage package. What should I know before making this commitment? Could you tell/link me the the responsibilities/expectations of a hackage package maintainer?
15:32:51 <jtanguy> recursion-ninja: there is an article about it on the wiki https://www.haskell.org/haskellwiki/Taking_over_a_package
15:33:40 <recursion-ninja> jtanguy: Yeah I read that, it doesn't cover expectations of the community though...
15:34:32 <recursion-ninja> jtanguy: That was more of a "How-To" then a "Best-Practices"
15:34:54 <recursion-ninja> I am looking to learn the latter if possible
15:35:41 <kadoban> recursion-ninja: It probably depends on the package, and on what you feel is necessary to keep the package useful to the community.
15:36:04 <recursion-ninja> kadoban: That's a fair answer
15:37:55 <recursion-ninja> kadoban: I'm considering the `random-shuffle` package. I assume that I would be implicitly responsible for staying up to date with all the radnom related packages and making sure that `random-shuffle` conforms to idoms and typeclasses. Does that seem right to you?
15:39:09 <kadoban> recursion-ninja: Sounds about right, sure. Probably something like handling/answering bug reports, accepting patches if you ever get any decent ones, and generally keeping it up-to-date if it ever breaks with new versions of whatever dependencies.
15:39:59 <recursion-ninja> kadoban: Would you say that the chief concern is "Keeping the package relevant to the comunity?"
15:40:37 <kadoban> recursion-ninja: Sounds reasonable to me.
15:41:02 <recursion-ninja> kadoban: Are you a maintaner of any packages?
15:41:07 <kadoban> Nope
15:42:22 <recursion-ninja> kadoban: Just wondering if you were speaking from experiance, or from a hackage user perspective
15:43:08 <recursion-ninja> Does anyone else have any input on what you expect from a package maintaner, or do as a package maintainer?
15:43:16 <kadoban> Mostly user. I do maintain a couple of minor tools/packages that aren't hackage related. I'd think it's probably pretty similar. Most of it consists of answering user emails when they can't get something working, and fixing bugs that someone notices.
15:44:37 * hackagebot eventstore 0.2.0.0 - EventStore Haskell TCP Client  http://hackage.haskell.org/package/eventstore-0.2.0.0 (YorickLaupa)
15:45:02 <recursion-ninja> kadoban: That's how I got proposed maintanership; I found a bug and when I contacted the maintainer he said he was aware but hasn't fixed it and has been looking to relinquish his status
15:46:08 <kadoban> Ahh
15:46:54 <recursion-ninja> kadoban: I think I'll probably "releive him" since it is a small and easy to maintaine package
15:47:31 <kadoban> Yeah, probably be a good experience if you're interested in it
15:53:59 <athan> Is syb one of the only ways we can make generics based on the shape of someone's data type? (And is that the actual goal of syb?)
15:54:52 <mmmm_> no there are lots of ways and syb is quite out of date
15:55:01 <mmmm_> uniplate is more modern
15:56:06 <athan> mmmm_: Ahh okay great, thanks :)
15:59:21 <mmmm_> If you want something more complex then try generics-sop
16:00:39 <ni291187> > sin pi
16:00:40 <lambdabot>  1.2246467991473532e-16
16:01:06 <davidstone> > cos sin tan pi
16:01:07 <lambdabot>  No instance for (GHC.Show.Show a0)
16:01:07 <lambdabot>    arising from a use of ‘M38014098800295984598262.show_M38014098800295984598...
16:01:07 <lambdabot>  The type variable ‘a0’ is ambiguous
16:01:14 <davidstone> Hmm
16:01:32 <ni291187> . ?
16:01:45 <vanila> > cos . sin . tan $ pi
16:01:47 <lambdabot>  1.0
16:02:09 <davidstone> Of course
16:02:25 * davidstone is still a newbie
16:02:43 <ni291187> > sin pi
16:02:44 <lambdabot>  1.2246467991473532e-16
16:02:51 <ni291187> > cos pi
16:02:53 <lambdabot>  -1.0
16:03:03 <ni291187> bug and luck
16:04:17 <ni291187> > pi
16:04:19 <lambdabot>  3.141592653589793
16:04:51 <ni291187> > cos 3.141592653589793
16:04:53 <lambdabot>  -1.0
16:07:54 <ni291187> > join (*) 5
16:07:56 <lambdabot>  25
16:07:58 <ReinH> ni291187: you can /msg lambdabot
16:08:14 <ni291187> i know
16:08:16 <athan> How do paramorphisms work?
16:08:57 <ReinH> athan: do you know how catamorphisms work?
16:09:06 <athan> vanila: That's surprisingly correct...
16:09:11 <athan> ReinH: I _think_ so
16:09:19 <athan> the f-algebra part is a little scary
16:09:24 <athan> but I think I understand it
16:09:28 <brainacid> hello everyone
16:09:43 <athan> brainacid: What's up :]
16:09:47 <ReinH> athan: This might be a good place to start http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf
16:09:49 <brainacid> not much
16:09:58 <brainacid> learning everyday a little more haskell
16:10:25 <athan> gulps
16:10:37 <athan> ReinH: Here we go :) Thank you!!
16:10:45 <ReinH> athan: :)
16:10:54 <athan> brainacid: It's like brain acid
16:10:58 <athan> :P
16:11:12 <brainacid> athan, :)
16:11:23 <athan> brainacid: What are you learning currently? :)
16:11:41 <ni291187> those who know explain everybody how join (*) works :)
16:11:59 <vanila> join (*) = \x -> x * x
16:12:00 <brainacid> athan, im an infant. Im going thru Hutton Programming Haskell book Chapter 4
16:12:04 <ni291187> yesterday people were confused
16:12:37 <brainacid> learning about types, func definitions rules, pattern matching, guards, basic Prelude library functions, lists, tuples ... the basics
16:12:37 <vanila> because join turns e -> (e -> r) into e -> r by applying the input twice
16:12:46 <brainacid> getting ready to tackle list comprehensions
16:12:52 <vanila> in this case, since it's the (->) e monad here
16:12:59 <ni291187> so e to r is a value?
16:13:07 <brainacid> running linux on xmonad
16:13:15 <ni291187> join is just function
16:13:39 <athan> brainacid: You'll get it, that was like the "wonderland" phase for me, then it was like BAM - strict ADTs, using ADTs as grammars, Kinds, then it's smooth sailing
16:13:42 <athan> ...kinda :P
16:13:59 <ReinH> ni291187: join for the ((->) r) instance of Monad is the only reasonable function of its type (r -> r -> a) -> (r -> a).
16:14:26 <brainacid> athan, well so far Im understanding well
16:14:29 <ni291187> yes but how does it double argument?
16:14:39 <ni291187> if result is just r to a
16:15:21 <ni291187> so join operates on type signature itself?
16:15:30 <ni291187> that is the question
16:15:33 <ReinH> No.
16:15:39 <ReinH> functions operate on values
16:15:55 <ni291187> so what is value for joun
16:15:55 <ni291187> join
16:16:05 <ReinH> I don't understand the question
16:16:06 <ni291187> vanila became quiet
16:16:07 <josephle> ni291197: suppose you have a function f :: r -> r -> a. Can you construct a function g :: r -> a?
16:16:12 <brainacid> i tasted ADT with another book by Serrano Mena Beginning Haskell Project based approach
16:16:28 <ni291187> i can cut it
16:16:36 <ni291187> construct i can not
16:16:39 <brainacid> ni291187, type signatures define the input/output of a func
16:16:40 <ni291187> can i?
16:16:55 <josephle> what about "g = \x -> f x x"?
16:17:04 <josephle> does that fulfill the type signature?
16:17:32 <athan> ReinH: So the "remaining constituents" provide the way for the functor to "eat it's argument, too"?
16:17:44 <ni291187> join does not modify function
16:17:56 <ni291187> join works on type signature itself
16:18:03 <ReinH> ni291187: Incorrect.
16:18:03 <ni291187> i dont see how though
16:18:10 <ni291187> prove
16:18:19 <ni291187> so far u just saying
16:18:20 <athan> :)
16:18:26 <josephle> \x -> f x x isn't a modification of f... it creates a new function that uses f
16:18:30 <ReinH> ni291187: It's impossible for a function to work on types
16:18:32 <ReinH> There's nothing to prove
16:18:40 <athan> O_O
16:18:44 * athan is the bad cop
16:18:47 <ni291187> then u did not get question
16:18:49 <ReinH> functions can't be modified, but functions can return other functions
16:18:50 <ni291187> think
16:18:50 <vanila> join has type Monad m => m (m a) -> m a
16:18:53 <ReinH> That's what join does
16:19:01 <vanila> when you do join (*), you're using the monad (->) e
16:19:08 <ReinH> join is a function that takes a function of type (r -> r -> a) and gives a function of type (r -> a)
16:19:11 <vanila> so in that case, that version of join has type  e -> (e -> a) -> (e -> a)
16:19:21 <athan> ni291187: Think in terms of getting to a result
16:19:25 <vanila> correction:  (e -> (e -> a)) -> (e -> a)
16:19:29 <ReinH> join is what is known as a "higher order function"
16:19:29 <ni291187> join does not care about function body
16:19:49 <athan> :x
16:20:01 <ReinH> join can't know anything about the definition of the function it is applied to. That is correct.
16:20:15 <ReinH> But that's true everywhere.
16:20:17 <ReinH> Functions are opaque
16:20:20 <ni291187> so what does it know?
16:20:29 <ni291187> vanila is close
16:20:29 <ReinH> It doesn't "know" anything
16:20:31 <ReinH> It has a definition
16:20:37 <vanila> close to what?
16:20:37 <ni291187> but i still dont see it
16:20:42 <ReinH> That definition is join f x = f x x
16:20:54 <ni291187> prove me that that monad exist outside of join?
16:21:03 <ReinH> What does that mean?
16:21:10 <ReinH> "exist outside of join"?
16:21:25 <ni291187> that means construct another function on it
16:21:29 <ni291187> like join
16:21:34 <ReinH> I don't understand.
16:21:37 <athan> ReinH: Readers cant be applicatives, can they?
16:21:45 <ReinH> athan: yes
16:22:02 <ni291187> reader monad is restricted to join ?
16:22:09 <ni291187> what u dont uderstand?
16:22:17 <ReinH> ni291187: pretty much anything you have said
16:22:28 <ReinH> what does "monad is restricted to join" mean?
16:22:36 <ni291187> well what can i say :)
16:22:53 <ReinH> All monads have a join function. That's part of what it means to be a monad.
16:23:24 <athan> They combine... into one.
16:23:34 * athan puts shades on
16:25:01 <ni291187> reinh make out of r to a function r to r to a function
16:25:06 <ni291187> extrq argument
16:25:17 <ni291187> using monad u are teaching me about
16:25:39 <ni291187> the process opposite to join
16:25:49 <ReinH> ni291187: Why do you think that should exist?
16:26:00 <ni291187> i did not think i asked
16:26:01 <ReinH> monads don't generally have such a function
16:26:08 <ni291187> u say does not exist?
16:26:50 <ReinH> I can write a function of type (a -> b) -> (a -> a -> b), but this has nothing to do with monads
16:26:53 <ReinH> @djinn (a -> b) -> (a -> a -> b)
16:26:53 <lambdabot> f a b _ = a b
16:27:51 <ReinH> @. pl djinn (a -> b) -> (a -> a -> b)
16:27:51 <lambdabot> f = (const .)
16:28:13 <ReinH> But this function has nothing to do with monads or the ((->) r) instance of Monad
16:29:03 <ni291187> lift another layer in ->r monad
16:30:52 <ReinH> "->r" is not a monad
16:31:02 <ReinH> And that function can also be written using return
16:31:11 <ni291187> do it
16:31:14 <ReinH> why?
16:31:17 <ni291187> dont be pedantic
16:31:21 <ReinH> It has nothing to do with monads
16:31:39 <ReinH> ni291187: I am not being pedantic. I am being precise.
16:31:46 <ni291187> lifting one layer has mothing to do with monads?
16:31:48 <ReinH> Part of the reason I am having trouble understanding you is that you are not being precise.
16:31:56 <brainacid> well well
16:32:07 <ReinH> Aside from return, no
16:32:10 * brainacid looks around the room
16:32:27 <ni291187> then join has nothing to do with monads too
16:32:49 <ni291187> sadly
16:33:03 <vanila> ni291187, you're being argumentative
16:33:29 <ReinH> ni291187: What? Of course join does.
16:33:35 <ReinH> Join is not for lifting.
16:33:41 <ReinH> Join is for the opposite of lifting
16:33:44 <ni291187> gosh :)
16:34:07 <ReinH> ni291187: If you know so much about monads, why are you struggling to understand something as simple as join for the ((->) r) monad?
16:34:22 <ReinH> And why am I bothering to try to explain to someone who obviously knows enough already
16:34:39 <ni291187> i do know what i know
16:34:48 <ni291187> for me its not enough :)
16:35:05 <ReinH> And you think that the best way to learn more is to tell people who do know more that they are wrong when they explain things to you?
16:35:06 <vanila> so anyway how is your scheme stuff coming along ReinH
16:35:41 <brainacid> jeez why the attitude ni291187
16:35:45 <brainacid> cool it
16:35:48 <ReinH> vanila: I've been doing holiday things but I have a parser for data and a pretty basic evaluator for a pretty small part of r6rs
16:35:55 <brainacid> people here are nice enough to give you the time of day
16:36:12 <brainacid> my 2 cents
16:36:14 <vanila> that's very cool, what kind of evaluator is it? do you use a transformer stack for it?
16:36:39 <ni291187> please lift me ((->) r) monad using return
16:36:40 <ReinH> vanila: I'm trying to decide whether I want to use a deep or shallow embedding for expressions
16:36:50 <ReinH> ni291187: What does "lift" mean?
16:37:30 <ReinH> vanila: Right now it's just a pretty basic shallow embedding using StateT for environment and ExceptT
16:37:45 <vanila> that sounds nice and simple
16:37:51 <ReinH> so, e.g., eval (List (Val "lambda", ...)
16:38:12 <ReinH> trying to decide if I want to reify the expressions as an IR: data Expr = ... | Lambda ... | IfThenElse ...
16:38:13 <vanila> (which is the best thing :) )
16:38:26 <ReinH> yeah, it's not too far from Write You a Scheme
16:39:00 <vanila> yeah its hard to say whether it's worth it, I would probably do so in haskell but not in scheme
16:39:18 <vanila> just because it gives you a nice way to frame syntax-analysis verifying the program is well formed
16:39:37 <ReinH> vanila: Also with macros you benefit less from a deep embedding, it seems
16:39:43 <ReinH> Since you always need to eval ad-hoc terms
16:40:16 <vanila> hmmm macros are very difficult
16:40:27 <ReinH> Yeah, I'm leaving those to the side for now
16:40:30 <ReinH> ;)
16:40:43 <ReinH> extensibility is a bit difficult in Haskell :/
16:41:00 <vanila> so the way I see it
16:41:17 <ni291187>  show me please how to make ((->) r) monad using return
16:41:36 <ReinH> ni291187: Are you asking for the definition of return for the ((->) r) instance of Monad?
16:41:57 <ni291187> no im asking example
16:42:03 <vanila> there's 3 'levels':  (A) just hard code some 'macros' into the actually haskell code   (B) actually have a [toy] macro system programmers can do stuff with   (C) proper macro system that's good enough to let programmers define their own macro systems with
16:42:04 <ni291187> a to M a
16:42:34 <ReinH> Ok.
16:42:37 <ReinH> :t return 1 :: a -> Int
16:42:37 <lambdabot> a -> Int
16:42:55 <Zekka> ni291187: Here's an example of the implications of his example
16:43:03 <Zekka> > (return 1) "corn"
16:43:04 <lambdabot>  1
16:43:12 <Zekka> > (return 1) "corn" "barley"
16:43:14 <lambdabot>  No instance for (GHC.Show.Show a0)
16:43:14 <lambdabot>    arising from a use of ‘M25607251463562573519045.show_M25607251463562573519...
16:43:14 <lambdabot>  The type variable ‘a0’ is ambiguous
16:43:14 <ReinH> Zekka: you don' t need the parens
16:43:22 <Zekka> ReinH: Oh, you're right!
16:43:28 <ReinH> > return 1 ()
16:43:30 <lambdabot>  1
16:43:48 <ReinH> vanila: right
16:43:52 <Zekka> > pure 1 "corn"
16:43:53 <lambdabot>  1
16:43:55 <Zekka> > pure 1 "corn" "barely"
16:43:56 <lambdabot>  No instance for (GHC.Show.Show a0)
16:43:57 <lambdabot>    arising from a use of ‘M85293858887569829959092.show_M85293858887569829959...
16:43:57 <lambdabot>  The type variable ‘a0’ is ambiguous
16:44:12 <ni291187> in this case monad is (->) Int ?
16:44:13 <brainacid> hello Zekka
16:44:27 <Romefeller> > reverse "hello"
16:44:28 <lambdabot>  "olleh"
16:44:29 <ReinH> ni291187: No, ((->) a)
16:44:32 <Romefeller> lol
16:44:42 <Zekka> Don't applicatives compose? I'm surprised it didn't just transform into -> b -> String
16:44:45 <Romefeller> ghci in that bot
16:44:49 <Zekka> into a -> b -> String*
16:44:56 <athan> Zekka: Maybe if there was... some data kind type level list, in a constraint kind so we could infer the least possible parameter...
16:45:24 * athan goes crazy
16:45:46 <Romefeller> > (\a \b -> a+b)4 5
16:45:47 <lambdabot>  <hint>:1:5: parse error on input ‘\’
16:45:56 <ReinH> ni291187: ((->) r) is a partially applied function type constructor (->). If Haskell had type-level lambdas you could say ((->) r) = \a -> r -> a
16:46:07 <Zekka> omefire1: Slight syntax error, idea is right though
16:46:16 <Zekka> > (\a -> \b -> a + b) 4 5
16:46:18 <lambdabot>  9
16:46:18 <Zekka> Whoops!
16:46:20 <Zekka> Romefeller*
16:46:40 <Romefeller> thx.
16:46:42 <Romefeller> nice bot
16:47:11 <ReinH> vanila: Well, what I would really like to be able to do is, e.g., define case and such in a library
16:47:20 <ReinH> That's a good first step
16:47:27 <ni291187> ok now its more clear
16:47:30 <ni291187> ty
16:47:58 <ni291187> took me like one hour to get that sentence out of u
16:48:21 <ReinH> ni291187: Well, since you never asked me that question, you might ask yourself why it took so long.
16:48:24 <Zekka> ni291187: He probably said it lots of other ways you didn't understand and he didn't know why you didn't understand them
16:48:49 <ni291187> possible everything is possible
16:48:49 <ReinH> ni291187: Hoping other people guess the secret question you want answered is a very inefficient way of getting help
16:48:58 <ni291187> nah
16:49:05 <ni291187> wrong
16:49:12 <ni291187> but i did help me at the end
16:49:16 <ReinH> ni291187: Ok, I'm done helping you. Your attitude is attrocious.
16:49:18 <ni291187> that is right
16:49:25 <Zekka> ni291187: I desperately need a seven-digit number, fast!
16:49:28 <ni291187> u did help me
16:49:44 <ni291187> i had typo above
16:49:49 <ReinH> I hope for others' sake that you learn to respect the people you are asking for help
16:50:10 <ni291187> i did respect u :) read above
16:50:40 <ni291187> u said seven times u dont understand
16:52:21 * vanila bored
16:52:32 <vanila> any ideas what i should do for 20 mins?
16:52:43 <ReinH> ni291187: I am not interested in having petty arguments with you either
16:53:11 <agibiansky> vanila: Do you happen to have a mac with mavericks or yosemite? :D
16:53:13 <ni291187> gosh everything is fine
16:53:15 <Romefeller> Is hard to use stencils with comonads? Like solving a laplace equation?
16:53:16 <ni291187> forget
16:53:20 <ni291187> u did help me
16:53:33 <ReinH> Romefeller: stencils?
16:53:48 <vanila> sorry im on GNU/linux
16:54:06 <agibiansky> vanila: aw ok :P
16:54:16 <ReinH> Romefeller: Ah, the numerical analysis stuff
16:54:16 <ni291187> your last sentence was most informative and clear, most pedagogical
16:54:24 <ni291187> that why i understood it
16:54:25 <Romefeller> ReinH Yeah. Like defining a computation in a matrix region and extending all over it
16:54:27 <ni291187> that is all
16:55:41 <ReinH> Romefeller: I'm not sure if finite matrices form a comonad
16:55:51 <ReinH> But Repa lets you use stencils
16:56:25 <edwardk> you can make a comonad that indexes to the current position into a finite matrix of course
16:56:54 <ReinH> edwardk: Hmm, and you don't have the dimensions issue as you do with monad
16:57:28 <Romefeller> i will search Repa
16:57:31 <edwardk> data Pointer a = Image (Vector (Vector a)) Int Int
16:57:40 <edwardk> that forms a comonad assuming the integers are in bounds on the vectors
16:57:46 <ReinH> Sure
16:58:01 <edwardk> and you can do relative or absolute addressing to model the 'stencil'
16:58:17 <Romefeller> edwardk Vector and Image type constructors ar just examples, right?
16:58:26 <ReinH> presumably Vector is Data.Vector
16:58:44 <edwardk> Romefeller: well you can use Data.Vector for Vector, and the Image constructor can be whatever you want to name it
16:58:53 <edwardk> you can write the Comonad instance for it based on the pointer comonad example i have
16:58:55 <vanila> trying to think of a mini haskell project to do or some thing
16:59:06 <ReinH> vanila: write a text adventure game
16:59:14 <edwardk> https://hackage.haskell.org/package/comonad-extras-4.0/docs/Control-Comonad-Store-Pointer.html
16:59:18 <ReinH> you can make a simple one in 30 minutes
16:59:32 <edwardk> ^- make that 2d and you get the comonad above
16:59:43 <vanila> the hardest part of that would be coming up with a story, it's a good idea
16:59:53 <ReinH> vanila: indeed
16:59:54 <Romefeller> edwardk thank you
17:00:41 <edwardk> then you can to things like define blur :: Image Double -> Double         blur w = (up w + down w + left w + right w) / 4
17:00:52 <ReinH> vanila: http://www.amazon.com/Twisty-Little-Passages-Approach-Interactive/dp/0262633183 :)
17:00:58 <edwardk> and extend blur  -- then produces the entire image you'd get from applying the blur kernel
17:01:08 <edwardk> another way to think of that image is to just view it as the store comonad
17:01:15 <vanila> thanks :)
17:01:20 <edwardk> data Store s a = Store (s -> a) s
17:01:35 <edwardk> Image = Store (Int,Int)
17:01:35 <ReinH> edwardk: But really an image is a continuous function R^2 -> Color ;)
17:01:41 <ReinH> (which is also a comonad)
17:02:03 <edwardk> you can use Double^2 -> Color if you want
17:02:10 <edwardk> but really even that is a lie =P
17:02:12 <Chathurga> Can someone help me understand some church encoding/lambda calculus stuff I've been working on: http://lpaste.net/117436
17:02:14 <ReinH> ;)
17:02:26 <Chathurga> Is there anyway to write p such that its type is Church a -> Church a
17:02:29 <edwardk> you probably want to have a window over which you sum, e.g. an fwidth for texture lookups =P
17:02:33 <EvanR-work> forget continuous, just go wild and its an arbitrary functions R^2 -> Color ;)
17:02:38 <Chathurga> And failing that, how would I make eq type check
17:02:58 <Elan10993245> Can someone help with understanding what ruby is?
17:03:08 <Romefeller> edwardk are you a numeric analyst?
17:03:10 <Zekka> Elan10993245: Do you mean the language other than Haskell or something else?
17:03:20 <edwardk> and yeah you can define 'relative-only' stenciling using the environment comonad
17:03:23 <ReinH> Romefeller: among other things
17:03:37 <edwardk> Romefeller: i wear a lot of hats, i'm a pretty crappy analyst but i can do basic stuff
17:03:55 <ReinH> Romefeller: edwardk is our resident renaissance Haskeller
17:04:01 <Elan10993245> @Zekka yes a different language
17:04:01 <lambdabot> Unknown command, try @list
17:04:11 <ReinH> Elan10993245: Try #ruby or #ruby-lang
17:04:41 * hackagebot th-orphans 0.8.3 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.8.3 (MichaelSloan)
17:04:43 * hackagebot sodium 0.11.0.3 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.11.0.3 (StephenBlackheath)
17:04:47 <Romefeller> edwardk My master dissertation is about conservative pdes and parallel multigrid. Im just wondering about that stuff in haskell. My project is done in FORTRAN
17:05:31 <ReinH> Romefeller: Well, Haskell is a good language for data parallelism, at least
17:05:35 <EvanR-work> what is the benefit of Env comonad over Reader?
17:06:50 <edwardk> i don't have much for differential equations. i have 'ad' which provides a framework for computing automatic differentiation, and 'integration' which provides tanh-sinh quadrature, and a bunch of code for computing metropolis-hastings and hybrid monte carlo integrals and some code for dealing with gathering up sets of constraints for stochastic differential
17:06:50 <edwardk> algebraic equations -- that last one I need to package up and ship -- but i don't have a good general purpose differential equation solver in haskell
17:06:52 <Romefeller> ReinH Yeah. I guess the algebra laws helps you to do thing in parallel
17:06:54 <Elan10993245> Thank you! I was looking more for web development
17:07:35 <edwardk> EvanR: the benefit there is that you can know that it is 'locationally invariant' the env comonad can only do relative indexing, so you can know that no point in the space is privileged over any other. the origin can't be found.
17:07:37 <Zekka> Elan10993245: Haskell also has web development libraries
17:07:38 <Romefeller> edwardk SDE are very cool.
17:07:54 <Zekka> have you looked into Yesod and/or Warp?
17:08:02 <ReinH> or Scotty, or Snap
17:08:05 <Zekka> (other folks who don't like Yesod will probably jump on me and tell me I mean other libraries)
17:08:24 <ReinH> I don't dislike Yesod, we just mostly use Scotty.
17:08:26 <edwardk> EvanR: https://www.fpcomplete.com/user/edwardk/cellular-automata/part-3 talks a bit about using env over store for some usecases, in that case its to work with cellular automata where we've connected parts of the space together.
17:08:39 <codygman> I uploaded some new docs for my package but I don't see an update yet or any build history, how long does it typically take?
17:08:51 <ReinH> edwardk: I never did get around to doing the small world topology stuff :(
17:08:53 <Romefeller> edwardk are you a PhD?
17:09:09 <edwardk> Romefeller: collected masters degrees and then went to hide in the real world =P
17:09:10 <sipa> a pigeon-harvesting dog?
17:09:15 <luite> codygman: usually been a few minutes and a few weeks
17:09:17 <ni291187> he should be
17:09:26 <Romefeller> edwardk Im on that way...
17:09:52 <Romefeller> edwardk I don't like to write too much. Im lazy like haskell lol
17:09:54 <EvanR> that sounds superficially pretty awesome
17:10:04 <ni291187> edwardk so u basically iplemented some cas stuff in haskell? is it on hackage?
17:10:07 <edwardk> ni291187: PhDs are depth, I really like breadth. I'm happiest taking a bunch of stuff other folks have written and applying a lot of spit and polish to it, and using it for things it was never intended for =P
17:10:08 <agibiansky> To chime in on the comonad stuff – I've been reading a lot of articles recently and tutorials on comonads, but it does seem like they are a somewhat niche thing. Do you think that this is something that will remain "small" (sort of like arrows...), or are there a lot of applications/abstractions waiting to be discovered there, sort of how applicative became used much more frequently?
17:10:39 <edwardk> ni291187: 'ad', 'integration', 'algebra', etc. lots of stuff I have in that space are on hackage.
17:11:00 <edwardk> agibiansky: i have some results that indicate they'll likely remain a relatively niche thing.
17:11:00 <ni291187> what package is it!
17:11:02 <ni291187> ?
17:11:09 <edwardk> ni291187: each one of those named was a different package =P
17:11:13 <EvanR> maybe that also has something to do with relative time FRP, where youd like to restrict expressions from referring to any point in time, only the current or immediately preceding time
17:11:17 <ni291187> :)
17:11:31 <edwardk> ni291187: https://github.com/ekmett?tab=repositories i have a few others
17:11:33 <ni291187> there is numbers package
17:12:04 <ni291187> for symbolic numbers but looks unfinished
17:12:11 <codygman> luite: lol alright
17:12:23 <edwardk> agibiansky: ultimately it turns out that there are 'fewer' comonads in haskell than there are monads, why? every comonad gives rise not only to a monad, but also to a monad transformer. but we have monads that do not have a transformer.
17:12:29 <luite> codygman: sorry just poking at the recent problems with the docs builder :)
17:12:45 <luite> usually it's within a few hours though
17:12:52 <luite> but not instantaneous
17:13:05 <edwardk> ni291187: you can use 'ad' with 'traced' or 'simple-reflect' to do symbolic differentiation
17:13:09 <dfeuer> Why hello, edwardk.
17:13:11 <EvanR> comonad -> monad?
17:13:24 <agibiansky> edwardk: Ah, and so the uses for comonads are somewhat superceeded and improved upon by monads... and so they're unlikely to be used since instead monads can be used in many cases?
17:13:38 <ReinH> agibiansky: no...
17:13:40 <edwardk> EvanR: yeah there is a non-obvious way to abuse a particular form of kan lift to get a comonad to monad-transformer transformer
17:13:40 * dfeuer wonders if edwardk has any ideas for zipping Seq more efficiently, but himself must go off and get ready for dinner :-/
17:13:46 <Zemyla> Does ghci automatically learn how to read imported classes with that instance Read?
17:14:00 <edwardk> agibiansky: well its not that they can be supercede by and improved on by monads so much as that there are fewer of them
17:14:00 <ni291187> ok edwardk ty i will look into that
17:14:06 <agibiansky> Ah, ok
17:14:09 <edwardk> agibiansky: there are still useful comonads
17:14:20 <ni291187> does somebody still work on haskell cas?
17:14:23 <ReinH> Zemyla: read works on any instances that are in scope
17:14:54 <edwardk> agibiansky: i'll give an example: https://www.fpcomplete.com/user/edwardk/cellular-automata/part-2 uses comonadic 'folds' to make resumable CRC calculations.
17:15:02 <Romefeller> EvanR comonad is a monad in C^op
17:15:43 <edwardk> ni291187: http://vimeo.com/60737699 is a talk by greg wright on 'wheeler' a CAS project he has IIRC
17:15:47 <EvanR> im not sure i understand Hask^op at the moment
17:16:15 <Romefeller> EvanR look th arrows backwards
17:16:18 <ni291187> ty edwardk will check it out :)
17:16:37 <edwardk> ni291187: i do a lot of things that are CAS-like in haskell, but I just don't care to solve the problem in its full generality. I tend to write little embedded domain specific languages for doing things that would normally be done by something like Mathematica or Maple.
17:16:41 <agibiansky> edwardk: Cool, I will take a look at the example. I was not doubting that there were useful comonads – read enough about them to have seen clearly useful examples – but was just trying to understand the logic for why what you said entailed that they would remain niche. It seems like "few comonads" does not necessarily imply "not important" – even if the only monads were RWS and IO, they would still be very prevalent, s
17:16:41 <agibiansky> it's not like we need a large number of instances to make an abstraction very useful.
17:17:38 <EvanR> only two instances of some class seems like the situation clojure is in
17:17:56 <edwardk> i was mostly just indicating why you won't be seeing comonads underneath all your code. in part duality works against us, you wind up using lots of little comonads in code if you use them at all, they tend not to be the glue that holds your whole program together, whereas with the sort of agglutinative nature of monads they tend to grow.
17:18:19 <slipwit> @help
17:18:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:18:27 <agibiansky> Cool, thanks :)
17:19:03 <edwardk> agibiansky: i do use the fold comonads in the 'folds' package a fair bit these days and things that look like them
17:19:41 * hackagebot distributed-process-execution 0.1.1 - Execution Framework for The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-execution-0.1.1 (TimWatson)
17:19:56 <edwardk> being able to give a single name to a comonadic 'bundle' that encompasses how to initialize, how to step and how to finalize any HMAC is kinda nice for instance.
17:20:17 <edwardk> and then you can merge those together to run multiple MAC's in parallel
17:20:29 <vanila> what!
17:20:29 <edwardk> e.g. if you wanted to compute SHA1 and MD5 at the same time in one pass
17:20:40 <edwardk> or a mean and variance, etc.
17:20:48 <vanila> so you're doign with crypto with comonads
17:20:49 <vanila> ?
17:20:55 <edwardk> sure, why not?
17:20:58 <EvanR> lol
17:20:59 <vanila> too cool!
17:21:03 <edwardk> the comonad makes the computation 'resumable'
17:21:09 <vanila> is there a blog somewhere about this please?
17:21:24 <slipwit> @pl \x y -> x y
17:21:24 <lambdabot> id
17:21:51 <edwardk> i wrote up the basics in that post i linked above about cellular automata showing you can make CRC calculations resumable.
17:22:02 <edwardk> i also wrote up a separate article on making CRC calculations monoidal
17:22:33 <edwardk> vanila: https://www.fpcomplete.com/user/edwardk/cellular-automata/part-2 https://www.fpcomplete.com/user/edwardk/parallel-crc
17:22:39 <edwardk> both of those talk about basic CRCs
17:22:50 <edwardk> but its not a big leap to see from there that you can do this for any HMAC.
17:22:59 <slipwit> @unpl id
17:22:59 <lambdabot> (\ a -> a)
17:23:01 <EvanR> im going to need to print out all these cellular automata posts and bring them on the street car
17:23:03 <edwardk> and that the 3 steps in a fold correspond perfectly to the common HMAC API
17:24:07 <slipwit> @type Data.Function
17:24:08 <lambdabot> Not in scope: data constructor ‘Data.Function’
17:24:42 * hackagebot distributed-process-task 0.1.1 - Task Framework for The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-task-0.1.1 (TimWatson)
17:24:44 * hackagebot jose 0.3.38.0 - Javascript Object Signing and Encryption and JSON Web Token library  http://hackage.haskell.org/package/jose-0.3.38.0 (frasertweedale)
17:26:47 <bananagram> why is id named id?
17:27:05 <shachaf> It's the identity function.
17:27:06 <slipwit> id is short for identity
17:27:23 <bananagram> I ran into trouble a few days ago because I made a variable named id, then I couldn't figure out why the function id wasn't working
17:27:34 <bananagram> id is a useful word
17:28:07 <vanila> you could define identity = id in your file
17:28:51 <agibiansky> bananagram: As a little more background which may or may not be useful, the word "identity" is used often to describe an element that doesn't do anything. e.g. In a category, you have an identity element (id) and elements of the category that you can compose (with . in haskell); in a group or a monoid, you add together elements. In all these cases the "identity" is the element that does nothign when combined with others, so 
17:28:52 <agibiansky> f == f . id == f for all functions f, just like mempty (the identity for monoids) has the rule mempty <> a == a <> mempty == a.
17:29:41 <bananagram> I see, thanks
17:30:22 <bananagram> so functions are a monoid where . is mappend and id is mempty?
17:31:09 <agibiansky> bananagram: Pretty close, actually. Functions form a category, which is effectively a "tagged" monoid – in monoids, you can combine ANY elements with <>, but in categories, you can only combine things where the tags match (which is why you can compose a -> b and b -> c, but not a -> b and c -> d)
17:31:58 <agibiansky> bananagram: So, not quite with regards to functions, but your intuition is right
17:32:34 <EvanR> bananagram: you can also shadow id in a let or function parameter list, but it might confuse people
17:32:36 <bananagram> oh, okay
17:34:20 <vanila> it says: Code failed to compile - Could not find module Data.Functor.Representable.Trie
17:34:26 <vanila> on the blog when you click run
17:39:50 <slipwit> anyone care to give me a hand with finding useful combinators?
17:40:03 <agibiansky> slipwit: Combinators for what?
17:40:08 <vanila> what do you mean
17:40:26 <ReinH> slipwit: Here are some http://combinators.info/
17:40:28 <slipwit> i'm looking for useful combinators for turning a basic haskell expression into point-free form on my own
17:40:37 <slipwit> but i know of almost none
17:40:37 <vanila> what is the expression?
17:41:06 <slipwit> just in general
17:41:11 <slipwit> ooh cool.
17:41:33 <mauke> slipwit: ap, const
17:41:35 <ReinH> bananagram: Particular functions form a monoid as you described: those of type a -> a
17:41:43 <slipwit> (by the way, i found this and thought it was cool http://conal.net/blog/posts/semantic-editor-combinators)
17:41:46 <mauke> also known as S, K
17:42:27 <agibiansky> I'm a bit fan of (.), it really gives my point-free expressions a point? In seriousness though it's hard to help without knowing exactly what you're working with :) >>= and =<< are often useful, as are <$> and <*> when working with effectful things
17:43:17 <Guest20518> I have a simple question regarding composition. When we have (init . tails) function, we say that "the result type of the function on the right of each (.) matches the type of parameter that the function on the left can accept". However tails :: [a] -> [[a]] which is unaaceptable to init
17:43:24 <mauke> :t ap const const
17:43:25 <lambdabot> a -> a
17:43:34 <Guest20518> init :: [a] -> [a]
17:43:51 <vanila> Guest20518, I can write a thing to explain this
17:44:06 <mauke> Guest20518: rename type variables for clarity
17:44:13 <EvanR> im getting that we can work polymorphically with "frozen applications" by using existentials
17:44:13 <Guest20518> thanks vanilla
17:44:26 <slipwit> ok, well, to be more specific then, i'm trying to evolve programs as pure combinators
17:44:29 <EvanR> maybe more naturally than closures
17:44:45 <mauke> init :: [b] -> [b]; tails :: [c] -> [[c]]
17:44:47 <slipwit> but i am trying to form a collection of useful combinators as a basis
17:44:56 <mauke> now let b = [c]
17:45:08 <slipwit> not just complete, but like minimize blowup and be general
17:45:16 <EvanR> edwardk's L type in the CRC post seems to be exploiting this
17:45:23 <EvanR> for folds
17:45:25 <Guest20518> so [b] will become list of list
17:45:29 <ReinH> slipwit: pointfree programming isn't about using esoteric combinators, it's a way of reasoning about program construction via function composition
17:46:05 <Guest20518> which init is not supposed to accept?
17:46:22 <ReinH> :t init
17:46:23 <lambdabot> [a] -> [a]
17:46:31 <ReinH> Guest20518: a can be [String], for instance
17:46:59 <mauke> > init [[[42]]]
17:46:59 <ReinH> Or, for that matter, a can be String, a.k.a. [Char]
17:47:00 <lambdabot>  []
17:47:06 <slipwit> reinh: do you mean that using purely combinators is somehow bad?
17:47:08 <ReinH> :t init `asAppliedto` ["foo", "bar"]
17:47:09 <lambdabot>     Not in scope: ‘asAppliedto’
17:47:09 <lambdabot>     Perhaps you meant ‘asAppliedTo’ (line 168)
17:47:14 <ReinH> :t init `asAppliedTo` ["foo", "bar"]
17:47:15 <lambdabot> [[Char]] -> [[Char]]
17:47:20 <Guest20518> init is supposed to accept a list not "list of lists" rite?
17:47:35 <ReinH> slipwit: They aren't bad, but using combinators to remove points isn't really the... point of this style of programming
17:47:41 <vanila> ah nevermind
17:47:43 <Adeon> how exactly is AutoDeriveTypeable supposed to work? I put {-# LANGUAGE AutoDeriveTypeable #-} in my source file but when I try to write 'instance Exception Blah' for Blah I defined in the file, it complains it's not Typeable
17:47:51 <mauke> Guest20518: a list of lists is a list
17:51:06 <Adeon> http://lpaste.net/117437 here's an example code
17:51:33 <Adeon> anyone happen to know how the extension actually works?
17:53:51 <toblerone> How would you do something like "(fromEnum minBound, fromEnum maxBound)"? I see how the types would be ambiguous here, but how could this be done?
17:54:36 <mauke> > fromEnum (minBound :: Char)
17:54:37 <lambdabot>  0
17:55:10 <toblerone> but you couldn't make it generic over all Bounded and Enums?
17:56:29 <mauke> I don't see why not
17:56:51 <athan> Is there a way to send in a flag to a haskell file (either as a CPP constant or something else) from cabal? Ideally from the `cabal install --flag=foo` command line?
17:57:21 <toblerone> How? The expression's type would be "foo :: (Enum a, Bounded a) => (Int,Int)"
17:57:23 <dysinger> athan yeah that’s a built in feature for cabal (.cabal files)
17:57:34 <mauke> ah, right
17:57:59 <mauke> toblerone: needs a dummy argument then, like proxy a
17:58:16 <athan> dysinger: Oh woah! Okay, I'll dig :) Thank you!
17:58:32 <dysinger> athan search github for .cabal files & you’ll see examples
17:58:39 <dysinger> Is there anything like open data types in haskell? I’ve been poking at extensions but don’t see the answer yet.
17:59:17 <toblerone> mauke: ya. I was thinking maybe there was some type system magic that would handle thing. I'm not too familiar with existentials or rankn but i don't see how it could be disambiguated
17:59:32 <toblerone> without another argument
17:59:43 * hackagebot persona 0.1.0.0 - Persona (BrowserID) library  http://hackage.haskell.org/package/persona-0.1.0.0 (frasertweedale)
18:00:01 <shachaf> Well, you want a type argument. But you can't pass type arguments in Haskell without using them in some value.
18:00:17 <mauke> foo :: (Enum a, Bounded a) => (Int,Int,a) also works :-)
18:00:21 <pavonia> Adeon: Does it work if you remove the deriving cluse?
18:00:27 <shachaf> So the proxy solution mauke mentioned is the best you can do.
18:00:31 <shachaf> Well, or that.
18:00:32 <Zemyla> @pl \a b c -> a ++ c
18:00:33 <lambdabot> const . (++)
18:00:43 <Adeon> pavonia: I was just about to try that
18:00:44 <Zemyla> :t (const .)
18:00:44 <mauke> as long as 'a' appears in the signature
18:00:45 <lambdabot> (a -> b) -> a -> b1 -> b
18:01:14 <agibiansky> Has anyone used Chart?
18:01:24 <Adeon> pavonia: it doesn't
18:01:37 <Adeon> pavonia: I'm going to make a stackoverflow question on it
18:01:39 <toblerone> heh, i might go with (Int,Int,a). Or better yet, but apply fromEnum elsewhere
18:02:39 <pavonia> Adeon: IIRC, it's somewhat broken on a certain GHC version
18:04:20 <pyon>  am trying to understand monad morphisms as morphisms of monoids. So here I have the commutative diagram for general monoid morphisms: https://www.dropbox.com/s/dwn1x5bfxxhrmlu/mmorph1.jpg?dl=0 . And here I have the monoid morphism laws in a way that can be seen as directly translated from the diagrams: https://www.dropbox.com/s/6ypetr5l0zm6ws0/mmorph2.jpg?dl=0 . Could anybody help me complete the second law?
18:04:29 <pavonia> Adeon: On GHC 7.8.3 apparently: https://ghc.haskell.org/trac/ghc/ticket/9575
18:05:16 <kwf> Slightly annoying thing: formatting of type-level list literals in some GHC messages lacks sufficient spacing for correct parsing
18:05:28 <Adeon> hrmm
18:05:34 <kwf> Example: Ask ghci: :t (Proxy :: Proxy '[ '[Int, Bool]])
18:05:34 <Adeon> I'm on GHC 7.8.4, I guess they didn't fix it for that
18:05:54 <kwf> And you get: (Proxy :: Proxy '[ '[Int,Bool]]) :: Proxy '['[Int, Bool]]
18:06:00 <pyon> :-O
18:06:02 <Adeon> actually it does say they fixed it
18:06:07 <Adeon> but why doesn't it work then
18:06:13 <kwf> But if you try: :t (Proxy :: Proxy '['[Int, Bool]])
18:06:27 <Adeon> ah, right, they fixed it in the documentation by saying it doesn't work
18:06:28 <kwf> You get a parse error
18:06:29 <Adeon> okay, mystery solved
18:06:35 <athan> dysinger: Hey, sorry to bug you. Is there any chance you'd have an example for me? All the ones I see are simple switches, I really need a cabal flag that I can set to a string value :/
18:07:10 <dysinger> athan: hmm ok once sec
18:08:29 <athan> thanks :)
18:08:53 <shachaf> pyon: Isn't it f . μ = μ' . (f ⊗ f)?
18:09:45 <shachaf> Which I guess is what you wrote in the second picture.
18:11:15 <shachaf> pyon: So f . join = join . (f . fmap f), or something like that?
18:11:49 <pyon> shachaf: Oh, yes, the second equation I got wrong in the first picture.
18:12:01 <pyon> shachaf: μ' should appear in front of (f ⊗ f).
18:13:04 <pyon> shachaf: The "standalone f" applies the natural transformation to the outermost M, whereas "fmap f" applies the natural transformation to the innermost M, right?
18:13:14 <dysinger> athan: I might have led you astray.  I see only flags too.  Not free form text.
18:13:51 <athan> nooooooo
18:13:58 <athan> dysinger: Thanks anyway :)
18:16:14 <shachaf> pyon: Yes.
18:16:20 <shachaf> pyon: You can also write fmap f . f
18:16:49 <pyon> shachaf: That is the tricky part! How do I know that they commute?
18:17:14 <pyon> In the case of monoids in Hask/Set, it is easy to see.
18:17:50 <codygman> How can I call my main function with stdin? I just have the trivial: main = interact (unlines . map f . lines) where f str = str ++ "!"
18:17:53 <shachaf> Well, if you're defining monads as monoids in the category of endofunctors, you have to show that it's a monoidal category, which means defining what f ⊗ g is.
18:18:28 <agibiansky> codygman: What do you mean by 'call your main function'? Can you compile and run the program?
18:19:40 <codygman> agibiansky: Yes. I'm sorry, I meant inside of ghci
18:19:56 <agibiansky> codygman: Enter 'main' into the terminal
18:20:01 <agibiansky> Does that do what you wait?
18:20:01 <pyon> shachaf: I guess that is my main problem. I cannot easily see what "f ⊗ g" is. "M ⊗ N" is just functor composition, but what does it even mean to take the tensor product of two natural transformations?
18:20:08 <agibiansky> what you want
18:20:23 <mauke> agibiansky: that'll exhaust stdin
18:20:33 <mauke> if it terminates at all
18:21:06 <agibiansky> mauke: No, it shouldn't terminate, i think
18:21:15 <codygman> mauke, agibiansky it doesn't terminate
18:21:27 <shachaf> pyon: "tensor product" means whatever you want it to mean.
18:22:11 <mauke> I wouldn't run that from ghci
18:23:20 <codygman> mauke: Alright.
18:23:46 <slipwit> @pl \x y -> h x y x y
18:23:47 <lambdabot> join . (flip =<< h)
18:24:02 <pyon> shachaf: Doesn't the tensor product on morphisms have to be in some way "compatible" with the tensor product on objects? For example, if I take Hask with Either as the monoidal product, then the tensor product on morphisms is (Control.Arrow.+++). But, if I take Hask with (,) as the monoidal product, then the tensor product is (Control.Arrow.***).
18:24:21 <shachaf> Of course.
18:24:33 <shachaf> ⊗ is a bifunctor, the behavior on arrows is the important part.
18:25:16 <codygman> should 'interact (unlines . map f . lines) where f str = str ++ "!"' terminate?
18:25:36 <pyon> So, here is the thing: In the category of Hask-endofunctors, once I have decided that ⊗ on objects is functor composition, how do I derive the meaning of ⊗ on natural transformations (seen as functor morphisms)?
18:25:51 <agibiansky> codygman: Well, sort of – it should terminate when stdin is exhausted and completely read
18:26:09 <agibiansky> In ghci it can't terminate b/c that would indicate that the session is done and ghci has to be closed
18:26:13 <shachaf> pyon: It's the other way around -- there could be multiple behaviors on arrows for the same behavior on objects -- though there's an obvious one in this case.
18:26:28 <codygman> agibiansky: interesting. I'm running it from the shell (not ghci) and it isn't terminating.
18:26:36 <shachaf> I need to go for a while. But just think of the types and it should come naturally. :-)
18:26:42 <pyon> shachaf: Okay, thanks!
18:26:42 <agibiansky> You have to tell it that stdin is closed, codygman, with Ctrl-D
18:27:52 <agibiansky> ugh, lazy IO
18:27:58 <codygman> agibiansky: so... how does that help me if I'm not there?
18:28:06 <agibiansky> agibiansky: Not where?
18:28:09 <dmj`> use io-streams
18:28:13 <agibiansky> i wish we could get rid of lazy IO :(
18:28:21 <agibiansky> even interact is lazy IO
18:28:40 <agibiansky> and i feel like every beginner gets bitten by it badly at some point
18:28:40 <dmj`> agibiansky: you can use streaming libraries
18:28:58 <agibiansky> dmj`: Yeah, I know, or just System.IO.Strict – I meant from Prelude
18:29:01 <geekosaur> codygman, I'm not even sure what you are asking. control-D is EOF on a terminal (on Unix; control-Z, ossibly followed by return, on Windows)
18:29:11 <codygman> dmj`: I can't use external libraries (it's for this coding games website)
18:29:21 <geekosaur> it's not a ghci thing, it's a unix thing
18:29:28 <dmj`> codygman: lame
18:29:54 <codygman> geekosaur: oh, I see what I was misunderstanding
18:29:56 <agibiansky> codygman: interact is only for running in a shell terminal (effectively) – what are you trying to use this for, could you explain in a bit more detail?
18:30:51 <slipwit> @pl \x y -> h x y x y
18:30:51 <lambdabot> join . (flip =<< h)
18:31:13 <acidjnk> hello
18:31:24 <agibiansky> hello
18:32:40 <acidjnk> what's the difference between "fmap half (Just 8)" and "Just 8 >>= half"?
18:33:00 <mauke> join
18:33:06 <agibiansky> acidjnk: when you use >>=, the function on the right has to return its value in the monad
18:33:09 <geekosaur> half can be pure in the fmap version, but must be in the Maybe monad in the second
18:33:39 <acidjnk> pure meaning no side effects, destructive updates or anything like that?
18:33:48 <mauke> :t Just 8 >>= ?half
18:33:49 <lambdabot> (?half::a -> Maybe b, Num a) => Maybe b
18:34:00 <geekosaur> "not in the monad", in this case. (not all monads are side effectful)
18:34:02 <benzrf> this is why we should teach join and not (>>=)
18:34:13 <mauke> :t fmap ?half (Just 8)
18:34:14 <lambdabot> (?half::a -> b, Num a) => Maybe b
18:34:44 <agibiansky> acidjnk: Look at the types that `half` would have to have in the two cases. In the first, it would be a -> a, whereas in the second it would be a -> Maybe a
18:35:05 <geekosaur> in particular, the Maybe monad has no side effects. but we still call not being in the monad "pure", because most of the other terminology sucks in other ways
18:35:14 <EvanR> i wonder if this makes sense as a comonad http://lpaste.net/117439
18:35:16 <acidjnk> I defined: let half x = if even x then Just (x `div` 2) else Nothing
18:35:21 <geekosaur> compare Control.Applicative's "pure"
18:35:29 <acidjnk> and in that case, either has the same output
18:35:32 <agibiansky> benzrf: Maybe someday we can even have join in the monad typeclass – then it'll really make sense to teach it that way. It's a bit weird to say 'join is fundamental to monads, but, uh, its not how you define them'...
18:35:38 <geekosaur> (which is the same as Monad's "return", but for Applicatives)
18:36:13 <mauke> acidjnk: then fmap half (Just 8) :: Maybe (Maybe Integer)
18:36:36 <mauke> > let half x = if even x then Just (x `div` 2) else Nothing in fmap half (Just 8)
18:36:37 <lambdabot>  Just (Just 4)
18:36:47 <mauke> double maybe
18:37:32 <Zemyla> :type $!
18:37:34 <acidjnk> > let half x = if even x then Just (x `div` 2) else Nothing in Just 8 >>= half
18:37:36 <lambdabot>  Just 4
18:37:39 <Zemyla> :t $!
18:37:40 <lambdabot> parse error on input ‘$!’
18:37:44 <dfeuer> :t ($!)
18:37:45 <lambdabot> (a -> b) -> a -> b
18:38:04 <Zemyla> @pl \f x -> x `seq` f x
18:38:05 <lambdabot> ap seq
18:38:19 <acidjnk> oh you are right, different output type. it's "double wrapped" without the monad
18:38:21 <Zemyla> @pl \f x -> f `seq` x `seq` f x
18:38:21 <lambdabot> ap =<< (seq .) . seq
18:38:30 <Javran> so after AMP, will pure replace return eventually?
18:38:46 <Zemyla> :t (seq .) . seq
18:38:46 <lambdabot> a -> b -> b1 -> b1
18:38:55 <dfeuer> Is there a way to ask lambdabot if two types unify?
18:39:00 <Zemyla> :t (ap =<<)
18:39:00 <lambdabot> Monad m => (m a -> m (a -> b)) -> m a -> m b
18:39:02 <acidjnk> thanks
18:39:13 <mauke> acidjnk: you could use join to collapse
18:39:16 <mauke> :t join
18:39:16 <dfeuer> Or if two expressions have types that unify?
18:39:17 <lambdabot> Monad m => m (m a) -> m a
18:39:28 <mauke> dfeuer: :t [x, y]
18:40:04 <dfeuer> mauke, oh, nice.
18:40:14 <dmj`> is ghc's garbage collector currently single threaded?
18:40:15 <Zemyla> @pl \x y -> [x, y]
18:40:15 <lambdabot> (. return) . (:)
18:40:22 <dfeuer> dmj`, no.
18:40:27 <dmj`> "The existing GC in GHC is a single threaded one"
18:40:34 <dfeuer> dmj`, er.... maybe there's only one GC thread.
18:40:37 <dmj`> https://ghc.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
18:40:43 <dmj`> dfeuer: it could be old docs?
18:40:48 <dfeuer> Maybe I'm confused, too.
18:41:04 <dmj`> 2006...
18:41:06 <geekosaur> parallel gc is recent and not the default; iirc it can produce significant slowdowns
18:41:07 <mauke> dmj`: AFAIK it stops all threads but uses multiple threads itself
18:41:07 <benzrf> Zemyla: just do that
18:41:14 <mauke> oh hmm
18:41:19 <toblerone> mauke: I think this is a similar issue, but here I can't see why. The compiler tells me the type of range is ambiguous when calling length, but shouldn't it be able to infer its type given the signature? http://lpaste.net/117440
18:41:42 <mauke> toblerone: error message?
18:41:48 <slipwit> \exit
18:42:08 <mauke> /quit
18:42:52 <geekosaur> mrrr. no, I don't see that signature producing a concrete type, and it will insist on one even though it arguably doesn't really "need" it there
18:42:58 * dfeuer breaks off a piece of toblerone and starts munching.
18:43:10 <dfeuer> geekosaur, why?
18:43:20 <geekosaur> what are you asking about?
18:43:21 <dmj`> geekosaur: if the GC is parallel does it have to stop other threads?
18:43:29 <dmj`> like the single-threaded model
18:43:30 <toblerone> mauk: here is the error
18:43:30 <toblerone> http://lpaste.net/117443
18:43:50 <slipwit> mauke: hah. thanks
18:43:51 <dfeuer> dmj`, incremental GC and concurrent GC are horribly complicated.
18:44:06 <dfeuer> I know nothing about them except that fact.
18:44:19 <dfeuer> And complicatedness tends to lead to slowdom.
18:44:19 <Iceland_jack> There has been work on making GHC's GC concurrent
18:44:37 <Iceland_jack> Which was not complicated at all, using some clever solutions
18:44:43 <dfeuer> Huh.
18:44:58 <geekosaur> toblerone, that is the error I would expect, yes
18:45:13 <mauke> hmm, it's ambiguous
18:45:21 <dfeuer> geekosaur, why can't it determine the type?
18:45:29 <mauke> is range itself polymorphic?
18:45:48 <dfeuer> OHhhhhh
18:45:48 <solatis> hmmm when i'm inside a monad (in my case, ResourceT monad), how do I avoid calling a gazillion lift $ putStrLn () - kind of statements ? is there an elegant way to automatically lift IO a to ResourceT IO a without calling lift ?
18:45:49 <dfeuer> I see.
18:46:07 <dmj`> IcelandJack: does 7.8.3 have a concurrent gc?
18:46:07 <dfeuer> Oh wait, I don't.
18:46:10 <geekosaur> oh, hm, no, on second thoyght that is not the one I was expecting....
18:46:21 <dfeuer> I don't see anything ambiguous about it.
18:46:38 <dfeuer> range must have type [b]
18:46:41 <toblerone> I still don't see why. I mean, I understand in that particular expression length $ enumFrom minBound is "Int"
18:47:00 <toblerone> but i later index range giving me back a "b"
18:47:15 <dfeuer> Yeah, I don't see ambiguousnessness either.
18:47:17 <toblerone> which should let it know that range is "[b]"
18:47:44 <mauke> dfeuer: no, it could be forall a. (Enum a, Bounded a) => [a]
18:48:03 <dfeuer> mauke, eh?
18:48:40 <mauke> <dfeuer> range must have type [b]  <- in response to
18:48:43 <geekosaur> I think range is allowed to be polymorphic there, so the range that is indexed is not guaranteed to be the same as the one you're taking length in
18:48:46 <geekosaur> *on
18:48:52 <dfeuer> mauke, I don't see where you're getting that from.
18:48:58 <dfeuer> Ohhhhhhh
18:49:03 <mauke> the error message
18:49:11 <dfeuer> Oh oh now I see. It's let generalization getting in the way?
18:49:24 <mauke> probably
18:49:29 <dfeuer> You want range to be monomorphic, and it's not.
18:49:32 <geekosaur> yes
18:49:38 <mauke> scoped type variables might help
18:49:43 <geekosaur> which needs, yes
18:49:43 <mauke> or case/of
18:49:56 <toblerone> I don't see what it's not monomorphic...
18:49:59 <toblerone> hmm
18:50:10 <dfeuer> Or in standard Haskell, couldn't you bind it with case instead?
18:50:11 <toblerone> err
18:50:12 <Zemyla> @pl \f g x = ap seq f (ap seq g x)
18:50:12 <lambdabot> (line 1, column 8):
18:50:12 <lambdabot> unexpected "="
18:50:12 <lambdabot> expecting pattern or "->"
18:50:17 <toblerone> why*
18:50:21 <Zemyla> @pl \f g x -> ap seq f (ap seq g x)
18:50:21 <lambdabot> (. ap seq) . (.) . ap seq
18:50:40 <geekosaur> because length breaks the association by itself, and let generalization allows range to be polymorphic, so ghc cannot assume it really is the same range (that is, has the same type)
18:51:06 <dfeuer> What happens if you change it to pickRand g = case enumFrom minBound of range -> ....  ?
18:51:13 <Zemyla> @pl \f g x -> f $! (g $! x)
18:51:13 <lambdabot> (. ($!)) . (.) . ($!)
18:51:20 <toblerone> hmm, ill have to read up on "let generalization"
18:51:51 <geekosaur> the type of range is (Enum a, Bounded a) => [a] --- instantiate it at a different type and it's a different value
18:52:10 <Zemyla> :t (. ($!)) . (.)
18:52:10 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:52:26 <geekosaur> and there's no way to link the types as written here; you need ScopedTypeVariables, or to rewrite it so that it's forced to be monomorphic
18:52:27 <dfeuer> toblerone, I also don't actually get an error when I compile your program.
18:52:41 <toblerone> really?
18:53:03 <dfeuer> Mmmhmm
18:54:10 <geekosaur> what ghc versions in each case?
18:54:19 <geekosaur> the behavior has changed in recent versions
18:54:27 <toblerone> im on 7.8.3
18:55:17 <geekosaur> (MonoLocalBinds comes to mind)
18:56:07 <dfeuer> I'm on 7.8.3
18:56:40 <dfeuer> toblerone, how are you trying to use the thing?
18:57:01 <dfeuer> RandomGen is from System.Random, right?
18:57:11 <toblerone> thats really strange. I made a new file and only included that function and it still gives the same error
18:57:13 <toblerone> and ye
18:57:13 <toblerone> s
18:57:46 <dfeuer> I have exactly that...  module PickRad where import System.Random   pickRand:: .......
18:57:53 <toblerone> like this?
18:57:54 <toblerone> http://lpaste.net/117444
18:59:00 <dfeuer> toblerone, yes, exactly that.
18:59:05 <dfeuer> (except for the module name)
18:59:16 <dfeuer> What do you get from ghc --version?
18:59:20 <geekosaur> so anyway, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#mono-local-binds is what to look at
18:59:20 <toblerone> 7.8.3
18:59:26 <dfeuer> o.O
18:59:38 <toblerone> yea, thats really strange...
18:59:42 <dfeuer> geekosaur, yeah, but that only comes into play when some extensions are enabled.
18:59:45 <geekosaur> although I wonder if one of you turns on MonoLocalBinds or one of the things implying it in .ghci]
18:59:50 <solatis> toblerone: that pickRand function almost seems like it should be in some standard library :)
18:59:55 <glguy> toblerone: probably want (0,len-1)
18:59:55 <geekosaur> assuming you are loading into ghci instead of compiling
19:00:06 <dfeuer> geekosaur, it doesn't happen to me with either ghc or ghci.
19:00:17 <solatis> glguy: good catch
19:00:24 <toblerone> ah true
19:00:26 <solatis> or...
19:00:26 <toblerone> but still
19:00:28 <solatis> maybe not ?
19:00:28 <dfeuer> I get a bounds error, yeah.
19:00:33 <siddhu> Is there a library that turns strings such as "1-5, 6-9" to lists like [1..5]++[6..9] ? I ended up writing a function to do this, but keep thinking there must be a library which already does this.
19:00:50 <solatis> most random libraries pick min <= n < max ?
19:00:52 <toblerone> dfeuer what os?
19:01:08 <dfeuer> toblerone, the type checker really should be the same regardless, but I'm on Fedora 20.
19:01:12 <toblerone> yeah i know
19:01:36 <solatis> this seems like a problem QuickCheck is able to test, tho
19:01:48 <toblerone> but i really can't think of any reason why it would work for you but not me.... : /
19:02:02 <dfeuer> toblerone, did you actually type ghc --version, or are you just assuming?
19:03:19 <toblerone> no i did. "ghc --version
19:03:19 <toblerone> The Glorious Glasgow Haskell Compilation System, version 7.8.3"
19:03:45 <toblerone> and when I load ghci "GHCi, version 7.8.3: http://www.haskell.org/ghc/  :? for help"
19:03:48 <glguy> toblerone: and if you're going to do this function you should probably be using random instead of randomR
19:04:03 <dfeuer> SO WEIRD
19:04:28 <dfeuer> Cosmic rays, man.
19:04:44 <dfeuer> (or woman, or other)
19:04:54 <toblerone> oops
19:04:58 <toblerone> i found the problem
19:05:08 <toblerone> geekosaur was correct
19:05:25 <dfeuer> toblerone, something in your .ghci?
19:05:28 <toblerone> I had "NoMonomorphismRestriction" set in my ghci config
19:05:49 <dfeuer> Oh, so mine only worked by accident.
19:06:00 <dfeuer> Well, it's not cosmic rays,
19:06:06 <dfeuer> but that's still not the "fix" you want.
19:06:15 <dfeuer> That just gives you Integers.
19:06:23 <dfeuer> You want to make the types match.
19:06:38 <dfeuer> Which you can totally do.
19:07:23 <dfeuer> [I think that's right, anyway]
19:07:58 <toblerone> with ScopedTypeVariables?
19:08:16 <dfeuer> Yes, it is right; the monomorphism restriction gets you Integers (yuck)
19:08:29 <EvanR> can any type of kind * -> * with a "working" extract :: f a -> a be made into a comonad in some trivial way?
19:08:31 <dfeuer> ScopedTypeVariables is a nice way to do it, but I'm pretty sure you can do it without.
19:08:35 <dfeuer> One sec...
19:08:46 <toblerone> glguy: Well I was hoping to define random instances for several data types, so I don't think i could use random there... right?
19:09:54 <agibiansky> So, I have a question to which I suspect the answer is "don't do it", but I'm going to ask anyways. I have a function line :: x -> Plot l x and a typeclass Renderable with the instance Renderable (Plot (Layout x) x). The output of `line` cannot be used as a member of the typeclass without a type annotation, because `l` is ambiguous. Is there anything I can do here to fix this (except for making `line` less polymorphic)? I am
19:09:55 <agibiansky> allowed to change the typeclass and anything else.
19:10:45 <agibiansky> I think this is one of those cases where I want "closed type classes" and use the existence of the typeclass to guide type inference, and so it's impossible given current Haskell...
19:10:49 <dfeuer> Oh wait, toblerone, there are Integers coming in some other way too?
19:11:15 <dfeuer> er..
19:11:19 <dfeuer> Sorry, I'm being silly.
19:11:41 <glguy> toblerone: If your goal is to implement the Random typeclass for your own enum types you'd be better off going via Enum than indexing into a list if that's an option for you,  but I didn't know you were implementing instances
19:11:41 <dfeuer> No, not that....... I'm confused.
19:12:01 * dfeuer needs to do some other things now.
19:12:32 <toblerone> glguy: Im not sure I understand. What do you mean going via Enum?
19:12:47 <glguy> :t toEnum
19:12:48 <lambdabot> Enum a => Int -> a
19:13:29 <toblerone> oh yeah
19:13:42 <toblerone> i did that earlier
19:13:55 <toblerone> oh
19:13:57 <toblerone> well no i didnt
19:14:45 <toblerone> yeah. thats a better option. i took this approach because I thought i was avoiding problems from ambiguous types
19:16:36 <toblerone> oh, no I'm not sure that would work. Are you suggesting doing something like "first toEnum $ randomR (0, fromEnum maxBound) g"?
19:17:04 <agibiansky> Continuing on my previous question, is there a deep technical reason why Haskell doesn't have closed typeclasses, or is it more of a "unexplored territory / unimplemented" thing?
19:17:51 <vanila> agibiansky, mostly because if you want a closed thing you can just make a data type and functions on it
19:18:27 <agibiansky> vanila: e.g. replace the indivial data types which would've implemented the typeclass with one data type?
19:18:38 <acidjnk> thanks mauke
19:19:12 <vanila> yeah
19:19:21 <agibiansky> So if you have (pardon the terrible example) a Shape typeclass which only allows circles and rectangles, and data Circle = ... / data Rect = ..., your approach suggests instead having data Shape = Circle ... | Rect ...
19:19:39 <agibiansky> Aren't we sacrificing type safety, though? Some functions only accept circles.
19:19:46 <agibiansky> I guess that's what GADTs could be used for.
19:19:58 <agibiansky> data Shape a where Circle :: ... -> Shape Circle
19:19:59 <dfeuer> agibiansky, you can have a Circle type and a Rect type
19:20:03 <vanila> well you can still have data Circle and Rect,  then dat Shape = CircleShape Circle | RectShape Rect
19:20:09 <dfeuer> and then Shape = C Circ | R Rect
19:20:12 <carter> yeah
19:20:14 <dfeuer> Yeah, what vanila said.
19:20:15 <agibiansky> Yeah, that too
19:20:15 <carter> or something
19:20:15 <vanila> I think that variants solve the problem you wanted, but they are more advanced
19:20:22 <vanila> haskell doesn't have this
19:20:29 <agibiansky> vanila: What are variants?
19:20:40 <vanila> its sort of like the dual of a record
19:20:51 <agibiansky> What does that mean?
19:20:56 <vanila> it lets you make 'Shape' in a nicer way
19:21:05 <carter> copattern matching?
19:21:10 <carter> i dont understand it very well mind you
19:21:49 <Buttons840> :t (***)
19:21:50 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:22:04 <agibiansky> Hmm, I guess the only issue with the approaches discussed so far is they add a layer of indirection to the API
19:22:10 <EvanR> class Circle c => Ellipse where
19:22:17 <carter> agibiansky: you need not EXPOSE it mind you
19:22:47 <agibiansky> carter: But if you refactor, you have to change your entire internal representation
19:22:55 <carter> so?
19:23:11 <carter> agibiansky: i have this funny idea that a library should eat pain once, so the users never have to
19:23:32 <carter> otoh, i also think breaking api changes are A OK as long as they're clearly documented and make shit better :)
19:23:44 <agibiansky> Yeah
19:23:56 <agibiansky> I am thinking about how the technique could be applied to my previous question, though
19:24:07 <agibiansky> And it seems like it would require a large change to the internal representation
19:24:19 <agibiansky> Which would they break other things horribly
19:24:22 <dfeuer> carter, what's your mom think of my proposal to move some things from Control.Monad to Data.List?
19:25:06 <agibiansky> Yeah, I don't think the proposed solutions actually work in this case, though I dunno that a closed typeclass would be the right answer...
19:25:33 <carter> agibiansky: is this for your rendering visual show layer?
19:25:48 <agibiansky> carter: This is working with the Chart library
19:25:52 <carter> oh
19:25:53 <carter> nvm :)
19:25:54 <joneshf-laptop> if you  have an `MVar`--say `foo`--being used by three things--say `x`, `y`, and `z`, how would this scenario play out: assuming `foo` is empty, `x` reads, then `y` takes, finally `z` puts
19:25:58 <agibiansky> The Chart library exposes a double state transformer
19:26:02 <agibiansky> EC l x
19:26:04 <carter> huh
19:26:09 <agibiansky> Which then is a pain to convert to a renderable
19:26:12 <agibiansky> yielding the question above
19:26:13 <joneshf-laptop> would `y` still take after `x` reads?
19:26:18 <agibiansky> you cannot refactor as you suggested, though
19:26:23 <agibiansky> because then EC l x would not be a state monad
19:26:28 <agibiansky> and so lens combinators would no longer work
19:26:36 <agibiansky> making it much worse to construct charts...
19:26:40 <carter> agibiansky: you should open a ticket with the author
19:26:53 <agibiansky> agibiansky: I have, but I have no good proposal for him here
19:26:57 <carter> ahh
19:27:02 <carter> still, thats phase 0 :)
19:27:20 <carter> http://hackage.haskell.org/package/Chart-1.3.2/docs/Graphics-Rendering-Chart-Drawing.html ?
19:27:23 <agibiansky> Yeah, he's open to changes (https://github.com/timbod7/haskell-chart/issues/67#issuecomment-68325194)
19:27:24 <carter> http://hackage.haskell.org/package/Chart-1.3.2/docs/Graphics-Rendering-Chart-Easy.html ?
19:27:36 <agibiansky> the latter, plus .State
19:27:50 <carter> ohh, the Stateful building things up api?
19:27:54 <agibiansky> aye
19:28:00 <carter> wheres that live again?
19:28:05 <carter> i heard about it, but havent seen it yet
19:28:06 <agibiansky> Graphics.Rendering.Chart.State
19:28:11 <carter> http://hackage.haskell.org/package/Chart-1.3.2/docs/Graphics-Rendering-Chart-State.html
19:28:19 <circ-user-Ik9bS> brief question guys (hi!) :) Alex working right now? I have a .x generating .hs code but that is not compiling (and the error shows up at a comment line)
19:28:38 <carter> agibiansky: have you looked at biapplicative/bittraverse?
19:28:45 <carter> maybe thats a thing?
19:29:03 <agibiansky> carter: No, how would those help?
19:29:07 <carter> not sure
19:29:10 <agibiansky> Oh
19:29:19 <carter> i'm just suggesting things that may have the right shape
19:29:22 <agibiansky> mhm
19:29:51 <carter> or you could just newtype wrap things and expose only the index you care about
19:30:05 <carter> or make up a lensy operation that does that hiding
19:30:25 <agibiansky> the issue is instance resolution... "lines" outputs something with a type parameter, whereas the instance can only exist for things where the type parameter is somewhat specialized. So without a type annotation resolution fails, because typeclasses can't guide inference...
19:30:32 <dfeuer> Newwwwwtypes.
19:30:33 <agibiansky> I guess replacing `toRenderable` would also work
19:30:47 <carter> :)
19:30:55 <carter> agibiansky: avoid the yak
19:30:58 <agibiansky> yak?
19:30:59 <carter> do the dumb thing that simple
19:31:02 <dfeuer> carter, can you use {-# UNPACK #-} to make your indexed lists compact, or dooes that not work?
19:31:03 <carter> *thats simple
19:31:15 <carter> dfeuer: unpack only works on monomorphic data types
19:31:16 <dfeuer> What is this about yaks anyway?
19:31:25 <carter> dfeuer: also in my use case, the lists evaporate
19:31:48 <carter> dfeuer: because i was able to write ALLL my combinators to be NOT recursive
19:31:49 <dfeuer> carter, why is that?
19:31:58 <carter> and compilers can optimize not recursive stuff like magic
19:32:13 <carter> dfeuer: and all my functor etc instances are inductively inlined wrt the static size
19:32:28 <carter> so i have unrolled fmaps and folds and stuff
19:32:32 <agibiansky> carter: I normally agree, but one of the nice things about plotting APIs like matplotlib is its immediate simplicity. It'd be nice if we could replicate that in Haskell, but sadly most of our solutions to "the types dont work" is "add more intermediate representations / functions", which tend to be effectively type-resolution line noise (which is an acceptable overhead for applications, but imho less pleasant for things like
19:32:33 <agibiansky> scripts and exploratory stuff)
19:32:48 <carter> agibiansky: aggree
19:33:01 <agibiansky> Could closed typeclasses reduce this?
19:33:02 <dfeuer> If I have   data Foo a = Foo !Int {-# UNPACK #-} !(Bar a)   what would get in the way of unpacking?
19:33:13 <agibiansky> I was excited for closed type families to guide inference, but without closed typeclasses they don't help
19:33:15 <carter> agibiansky: as suggested before, a closed type class means its just a da Data
19:33:27 <carter> agibiansky: ohhh, theres a way to fake closed classes
19:33:41 <agibiansky> Yes – it's isomorphic to a new data, but less syntactic overhead
19:33:47 <carter> no
19:33:50 <carter> theres a way to give a closed class
19:33:51 <agibiansky> carter: The issue with faking closed type classes is that they don't guide inference
19:33:54 <carter> no
19:33:57 <carter> oh
19:33:59 <carter> hahahahahaah
19:34:05 <carter> agibiansky: you want somethig like instance chanes?
19:34:12 <dfeuer> carter, did you see my unpacking question?
19:34:14 <agibiansky> chanes?
19:34:18 <carter> chains
19:34:23 <agibiansky> YEs
19:34:36 <carter> agibiansky: i think 7.10 has basic instance chains
19:34:41 <agibiansky> Eh?
19:34:42 <carter> @google ghc 7.10 instance chains
19:34:42 <agibiansky> How
19:34:42 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10
19:35:11 <carter> https://ghc.haskell.org/trac/ghc/ticket/9334
19:35:36 <carter> huh
19:35:41 <carter> idk if they ever got merged in
19:36:13 <dfeuer> carter, unpacking? Why not polymorphicish?
19:36:23 <carter> dfeuer: check the core
19:36:27 <carter> idk if it happens for that
19:36:42 <carter> dfeuer: that unpacking would only haappen if bar is single constructor I think
19:36:46 <carter> if at all
19:37:19 <agibiansky> carter: Huh, maybe... Step in the right direction I guess, I don't quite understand if that would do what i want, but cool stuff
19:37:21 <carter> dfeuer: but check the core
19:37:33 <carter> agibiansky: could you make up some fictional code
19:37:36 <dfeuer> carter, shouldn't it unpack what I tell it to? There's nothing inherently to stop it, is there? How will I tell from the core?
19:37:55 <carter> dfeuer: idk, i usually dont check for that
19:38:09 <carter> agibiansky: make up some fictional code illustrating how you'd like to write things
19:38:10 <dfeuer> HMMM
19:38:14 <carter> and ask on ghc-users or ghc-devs
19:38:22 <carter> agibiansky: and ask for suggestiions
19:38:25 <carter> or heck, haskell-cafe
19:38:48 <agibiansky> carter: Sounds good, might be a fun discussion :)
19:38:59 <carter> agibiansky:  i suspect theres a way to fake what you want today
19:39:14 <agibiansky> carter: If so I will be excited to see it
19:39:18 <dfeuer> The reason I was thinkin' about that were dat de Data.Sequence go through lotsa PAIN with the Digit type, which seems somewhat like a hand-rolled version of that sorta thing, sorta.
19:39:39 <dfeuer> But there may not be a way to deal with otherwise because less than anyway.
19:39:42 <paomian> test 中文
19:39:47 * hackagebot sws 0.3.0.0 - A simple web server for serving directories, similar to weborf.  http://hackage.haskell.org/package/sws-0.3.0.0 (DerekElkins)
19:40:17 <dfeuer> paomian, test failed.
19:40:58 <Nadrieril> paomian: worked for me
19:40:58 <paomian> dfeuer: what, you can't get the chinese?
19:41:21 <dfeuer> paomian, I don't know any Chinese at all. So your communication failed to communicate.
19:43:05 <paomian> dfeuer: Ha,I can speak English,but my English is poor,I'm a new to haskell
19:44:08 <dfeuer> paomian, my עברית is rather poor too. I'm mediumish to Haskell.
19:46:01 <pavonia> Is that Hebrew, or Chinese that only looks like Hebrew?
19:46:11 <flounders> It's Hebrew.
19:46:22 <paomian> dfeuer: Ok...
19:46:52 <flounders> My Hebrew used to be a lot better, but the majority of the vocab and grammar has slipped from me.
19:46:56 <benzrf> paomian: 你好
19:47:50 <paomian> I don't know how to express my thought
19:48:12 <paomian> benzrf: 你是中国人？
19:48:20 <benzrf> paomian: 不是
19:48:37 <benzrf> paomian: i barely know chinese
19:48:39 <benzrf> :p
19:48:59 <tinyblak_> : p
19:49:06 <benzrf> paomian: i don't even know how to say "I barely know chinese" in chinese
19:49:20 <dfeuer> flounders, the vocab is ever so much harder than the grammar, in every language I've ever encountered.
19:49:31 <dfeuer> You can always get by with broken grammar.
19:49:33 <benzrf> chinese grammar is remarkably easy
19:49:34 <paomian> benzrf: like this,我几乎不懂中文
19:50:00 <flounders> dfeuer: This is true. Greek isn't as bad, because it is used in a good portion of English rules.
19:50:05 <trap_exit> what is the best tools for doing scientific computing in haskell ?
19:50:31 <dfeuer> String words/signs together in any old order and people will usually be able to figure out most of what you mean.
19:50:52 <paomian> Can i take a question?
19:51:16 <benzrf> paomian: ok
19:51:19 * geekosaur wonders if that was intended to mean "ask a question"
19:51:32 <paomian> why you study haskell?
19:51:37 <geekosaur> "take a question", idiomatically, is the opposite...
19:51:46 <benzrf> paomian: because it's a great language
19:52:04 <paomian> It is can be used in real world?
19:52:32 <paomian> before I stady haskell ,I write clojure.
19:52:53 <geekosaur> type safety catches a lot of errors at compile time. learning the discipline of haskell types makes you a better programmer in general, in any language; there are companies that don't use Haskell but will consider Haskell fluency a big advantage
19:53:56 <geekosaur> (and given how many languages are sprouting FP-inspired features of late, you can even reuse many of the things you learn to do with Haskell)
19:54:01 <benzrf> paomian: yes, definitel
19:54:01 <benzrf> y
19:54:17 <benzrf> geekosaur: that's disingenuous
19:54:34 <benzrf> geekosaur: trying to do that will just lead to extreme frustration at it not working as well as in haskell :D
19:54:39 <paomian> Your means that is a good way to improve the code ability
19:54:52 <trap_exit> What is the best way to do scientific computing in Haskell ?
19:58:03 <pyon> How do I know when a MonadTrans would be a legitimate MMonad?
19:59:48 * hackagebot sws 0.3.0.1 - A simple web server for serving directories, similar to weborf.  http://hackage.haskell.org/package/sws-0.3.0.1 (DerekElkins)
19:59:50 * hackagebot conduit-extra 1.1.6 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.6 (MichaelSnoyman)
20:02:48 <glguy> pyon: I imagine you check that your instance satisfies the 3 documented laws and you're good to go
20:04:48 * hackagebot warp 3.0.5 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.5 (MichaelSnoyman)
20:05:27 <pyon> glguy: Normally, I do not find it terribly enlightening to read type class laws as identifications between Haskell terms. I need to start with a commutative diagram, and from there derive the Haskell equations.
20:06:29 <pyon> glguy: The fact Haskell uses (>>=) more than join also does not help. :-|
20:08:30 <arnoblalam> hi all
20:08:37 <arnoblalam> had a code review question for you
20:09:30 <arnoblalam> I am trying to figure out why my code is performing so poorly
20:09:34 <arnoblalam> the question is detailed here
20:09:35 <arnoblalam> https://stackoverflow.com/questions/27696738/why-is-my-haskell-code-so-slow
20:09:45 <arnoblalam> but basically, I have tried profiling the code
20:10:05 <arnoblalam> and it looks like much of the time is spent in decodeLenientWithTable function
20:10:08 <arnoblalam> which I am not calling
20:10:28 <arnoblalam> but I believe might be used by the TLS library?
20:10:47 <arnoblalam> wondering if anyone would want tot take a look and give some feedback
20:11:51 <fengshaun> what's the de facto method of debugging haskell code? should I just unit-test functions in ghci?
20:13:52 <arnoblalam> there’s no need for debugging
20:13:58 <arnoblalam> if it typechecks it’s correct
20:14:02 <arnoblalam> :-)
20:14:48 * hackagebot wai-extra 3.0.3.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.3.2 (MichaelSnoyman)
20:14:59 <pyon> fengshaun: probably using something like quickcheck will catch most of the bugs
20:15:07 <pyon> fengshaun: the nice thing is it autogenerates the test cases
20:15:43 <pyon> fengshaun: as opposed to you having to craft test cases that hopefully cover all code paths
20:16:32 <fengshaun> pyon: thanks
20:16:43 <fengshaun> arnoblalam: partly true, yes
20:16:50 <fengshaun> but not logic errors
20:19:12 <pyon> fengshaun: well, you should design your types so that they will catch as many errors as possible
20:19:37 <pyon> fengshaun: any error that can be caught with types will reliably not be there
20:19:49 * hackagebot yesod-auth 1.4.1.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.1.2 (MichaelSnoyman)
20:19:51 * hackagebot yesod-test 1.4.2.2 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.4.2.2 (MichaelSnoyman)
20:21:46 <fengshaun> I'll try my best :>
20:23:08 <glguy> fengshaun: I don't think that there's a "de facto method" for it, but there's a wiki page for some of the techniques depending on what you're trying to figure out: https://www.haskell.org/haskellwiki/Debugging
20:31:36 <jludwig> FordR: when you referenced Bach, were you referring to J.S. Bach?
20:32:26 <jludwig> er... wrong room, sorry
20:33:38 <arnoblalam> any idea about why this code runs slowly?
20:33:43 <arnoblalam> https://stackoverflow.com/questions/27696738/why-is-my-haskell-code-so-slow
20:34:03 <arnoblalam> sorry, I kep bringing it up, but I am shocked to run the Haskell code is running an order of magnitude slower
20:34:09 <arnoblalam> than python
20:35:23 <circ-user-Ik9bS> None of the Alex .x files I try produces code which compiles with ghc -c ... Is there a special trick?
20:35:30 <dfeuer> arnoblalam, Python is just soooo fast. Or, more likely, you're doing something wrong.
20:35:39 <arnoblalam> haha
20:35:42 <arnoblalam> I am pretty sure I am
20:36:07 <Welkin> arnoblalam: are you using `maximum`?
20:36:10 <arnoblalam> this is probably the first program I have written outside of the Real World Haskell book
20:36:19 <arnoblalam> no
20:36:42 <arnoblalam> I am just naming a vairabble max_
20:37:00 <Welkin> tip: either use foldr or foldl', but not foldl
20:37:48 <arnoblalam> oh, sorry, I misunderstood your comment, those are just general tips!
20:38:16 <circ-user-Ik9bS> no Alex users in here who could get me over this?
20:38:22 <arnoblalam> I am avoiding using Strings (i.e. [Char]) also
20:38:36 <agibiansky> arnoblalam: It seems like the majority of the issue is decodeLenient, which is in a library
20:38:44 <agibiansky> Rather than anything to do with your code.
20:38:51 <arnoblalam> and replacing a `append` b with concat [a, b] seems to be a bit faster
20:38:59 <agibiansky> It may help to place the python code as well?
20:39:12 <agibiansky> Perhaps Haskell just has a slow library for what you'd like to do :(
20:39:17 <arnoblalam> yeah, I think it might be used by the tls library for HTTPS communication
20:39:32 <agibiansky> Oh, I see, you're never actually using base64-bytestring yourself
20:39:49 <circ-user-Ik9bS> there are various sites which state that haskell is slower than python and f# and ocaml... no big news. If you want fast - dont use haskell ;)
20:40:16 <agibiansky> in my experience, Haskell *the language* is fast, but Haskell *the ecosystem* varies
20:40:35 <circ-user-Ik9bS> maybe haskell "the tool chain" is the problem not the language itself
20:41:09 <fengshaun> glguy: oh, that's really useful, thanks
20:41:11 <agibiansky> e.g. much of the ecosystem encourages lists, which are very slow; we lack some high performance libraries (for example, hash maps), compared to say, python, etc etc – so it can take some work to make things run fast
20:41:44 <lpaste> arnoblalam pasted “Python code” at http://lpaste.net/117446
20:41:54 <arnoblalam> corresponding python code
20:41:54 <circ-user-Ik9bS> @agibiansky On the sites I mentioned above, boxing and unboxing and heap operation abundancy are identified as the problems
20:41:54 <lambdabot> Unknown command, try @list
20:42:27 <glguy> arnoblalam: The next step is probably to profile your Haskell program to pinpoint what aspect of it is using the most time and then focus your attention there
20:42:35 <dfeuer> arnoblalam, it would be interesting to know what this decodeLenient stuff gets used for. That is, what operations you're doing that lead to it.
20:42:44 <agibiansky> glguy: I don't think that's an issue in this case
20:42:59 <arnoblalam> the profiler output is here: http://lpaste.net/117430
20:43:13 <dfeuer> circ-user-Ik9bS, boxing/unboxing stuff can be avoided in many cases. I don't know what "heap operation abundancy" means.
20:43:16 <agibiansky> It seems like the decodeLenient stuff is buried in the dependencies
20:43:21 <arnoblalam> it looks like a lot of time is being used by the decodeLenient (family of) functions
20:43:27 <arnoblalam> I am not calling this function
20:43:37 <circ-user-Ik9bS> well I currently toy with haskell to see a bit more if it is a "serious" language. My first program is supposed to parse a simple grammar with Alex and Happy and I am stuck with Alex generated code which does not compile. So much for "rapid prototyping"
20:43:47 <agibiansky> dfeuer: Probably in Network.Wreq
20:43:53 <sshine> agibiansky, as Haskell becomes used more in production, so will the efficient datatype libraries become more widespread, I think. maybe it's just due to my personal interests, but I've noticed more use of e.g. STArrays, and Text/ByteString through OverloadedStrings.
20:43:54 <arnoblalam> I am trying to generate a “call graph”? to see what is calling it (sorry if not the right term, not a CS guy)
20:44:02 <arnoblalam> but I have a suspicion it might be the tls library
20:44:48 <sshine> circ-user-Ik9bS, possibly because of broken indentation in the generated lexer?
20:44:53 <agibiansky> sshine: I agree
20:45:14 <agibiansky> sshine: I personally have had a lot of issues with hashmaps, that's my main gripe :P
20:45:18 <sshine> agibiansky, I'm not sure the use of lists are bad for learning FP.
20:45:22 <agibiansky> Turns out it's just hard to make a very performant hashmap
20:45:24 <arnoblalam> looking at this issue on Guthub: https://github.com/bos/base64-bytestring/issues/10
20:45:26 <ob_> what's haskell's main competitor?
20:45:26 <circ-user-Ik9bS> sshine that is it yes
20:45:28 <sshine> agibiansky, I've never used HashMaps in Haskell. :)
20:45:33 <arnoblalam> but looks quite old, so hopefully it has been resolved?
20:45:39 <circ-user-Ik9bS> but I have no idea how to fix it
20:45:52 <dfeuer> agibiansky, if there's good imperative hashmap code, why hasn't Haskell stolen it for ST yet?
20:45:56 <sshine> circ-user-Ik9bS, it can be avoided by not using whitespace-sensitive code blocks.
20:46:05 <circ-user-Ik9bS> I downloaed some other .x files which I gound on github and they also fail to compile
20:46:15 <circ-user-Ik9bS> found*
20:46:17 <sshine> circ-user-Ik9bS, e.g. instead of using indented do-blocks, use do { x <- foo; bar; baz }
20:46:20 <glguy> arnoblalam: Your profiler output suggests that most of your time is spent doing base64 decoding
20:46:35 <arnoblalam> the entire code base is here, btw: https://github.com/arnoblalam/iron_mq_haskell
20:46:39 <sshine> circ-user-Ik9bS, try and put your code in a pastebin.
20:46:44 <glguy> so that'll be a good place to look
20:47:04 <agibiansky> dfeuer: I don't know. There's the "hashtables" package, which is better than Data.Map type stuff, but is still not really on par with Python's dicts. I think it's just a lot of work to figure out a good library, and there are maybe issues with GHC's GC being mistuned for that sort of work?
20:47:24 <circ-user-Ik9bS> My .x file is as tiny as it can be with only 3 $ macros, 2 tokens and using posn wrapper. There is no real code in the module
20:47:27 <sshine> circ-user-Ik9bS, the thing is, even though it may look nicely indented in your lexer definition (.x file), it will end up somewhere random in the generated .hs file.
20:47:37 <sshine> circ-user-Ik9bS, oh...
20:47:46 <agibiansky> dfeuer: just to be clear, I'm not blaming anyone or haskell :) I think it can be done and hopefully will be, just is an area that needs work in its implementation
20:47:49 <dfeuer> agibiansky, yeah, the GC will be an issue, I guess, with boxed thingums.
20:47:59 <sshine> circ-user-Ik9bS, well, then the error you get when compiling your .hs file should be easy to comprehend?
20:48:04 <dfeuer> Data.Map is really only good if you need persistence.
20:48:15 <glguy> Oops, wrong a user name
20:48:20 <glguy> agibiansky: Your profiler output suggests that most of your time is spent doing base64 decoding
20:48:57 <agibiansky> glguy: That's arnoblalam's code – I was just clarifying something about his problem :) But yes, it seems like it's a performance issue with Network.Wreq
20:48:59 <EvanR> after playing with this, it seems like if you have a generic comonad value, you cant do anything with it that isnt just fmapping
20:49:11 <arnoblalam> yes it looks like it, but I am not calling this function form anywhere
20:49:13 <agibiansky> dfeuer: My experimentation with it was here, fyi: http://stackoverflow.com/questions/26765232/haskell-hashtable-performance
20:49:17 <sshine> circ-user-Ik9bS, feel free to post code.
20:49:21 <arnoblalam> trying to figure out what library is calling it
20:49:56 <ob_> what is FPComplete written in?
20:49:58 <EvanR> monad has generic things you can do like replicateM, i cant seem to write any generic non-functor comonad code
20:50:24 <arnoblalam> but, I definitely do not have the expertise to fix some of these big libraries (http-client, or tls, for example)...
20:50:42 <agibiansky> arnoblalam: I think it's https://hackage.haskell.org/package/http-client
20:51:00 <Welkin> ob_: yesod
20:51:06 <ob_> ah cool
20:51:12 <ob_> thanks, Welkin
20:51:55 <agibiansky> arnoblalam: You may want to file an issue on the http-client github
20:52:08 <arnoblalam> alright
20:52:15 <arnoblalam> I’ll check if there is an open issue already
20:52:19 <circ-user-Ik9bS> http://www.ipaste.org/2Qj
20:53:13 <circ-user-Ik9bS> oops...not sure if it pasted correctly o.,O
20:53:42 <Cale> circ-user-Ik9bS: maybe try http://lpaste.net/
20:54:10 --- mode: ChanServ set +o Cale
20:54:28 <agibiansky> arnoblalam: Not actually sure that it's http-client to be honest, just checked the source and could only find them doing encoding using Bsae64 bytestring... not decoding...
20:55:10 --- mode: Cale set +b *!*@90.174.2.198
20:55:10 --- kick: porkys was kicked by Cale (porkys)
20:55:15 <Cale> (spam)
20:55:19 <circ-user-Ik9bS> well there are some ( missing in the { tok ... } sections... fixing that this mini thing complles...so my bigger one might also have a problem which is hard to spot
20:55:20 --- mode: Cale set -o Cale
20:55:55 <Cale> oh, you did get that pasted correctly nevermind :)
20:56:04 <shachaf> pyon: Did you figure out your thing?
20:56:20 <arnoblalam> is there a way to figure out what piece of code is calling what other piece of code?
20:56:34 <arnoblalam> I don’t know what this is called? backtrace? call stack? call graph?
20:56:35 <circ-user-Ik9bS> the other .x file I did has the same bottom code section basically - only more tokens
21:00:29 <spearman> hey guys, i heard simon peyton-jones mention in a talk from late 2013 that record syntax was planned to be updated to allow records with the same name within the same namespace, does anyone know what the status of that is?
21:00:49 <spearman> (specifically the skills matter video on lenses)
21:05:06 <agibiansky> arnoblalam: I am also having trouble figuring out where decodeLenient is being called
21:05:47 <agibiansky> arnoblalam: Here is a list of reverse dependencies... http://packdeps.haskellers.com/reverse/base64-bytestring
21:05:56 <arnoblalam> I am using two functions: unpack and encodeUtf8 (from text library)
21:06:07 <arnoblalam> checking to see how these two are implemented...
21:07:39 <glguy> spearman: "Overloaded Record Fields" might be what you were thinking about, https://www.reddit.com/r/haskell/comments/2pnjdk/is_overloadedrecordfields_getting_it_into_7101/
21:07:46 <trap_exit> is there a decnet haskell repl anywhere?
21:08:25 <Cale> spearman: See https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
21:08:32 <Cale> trap_exit: GHCi
21:08:34 <spearman> glguy: thanks, i also found this wiki page https://ghc.haskell.org/trac/ghc/wiki/Records/NameSpacing
21:08:34 <glguy> spearman: TL;DR: Not in 7.10 and no promises about 7.12
21:08:40 <Cale> trap_exit: It comes with GHC :P
21:08:52 <trap_exit> do people do interactive dev in GHCI like people do lisp dev in a lisp repl?
21:09:04 <Cale> trap_exit: I tend to avoid it.
21:09:10 <trap_exit> GHCI seems very, "slightly better than hackage doc" and not so much "write code here interactively"
21:09:14 <spearman> what's "interactive dev"?
21:09:23 <Cale> trap_exit: But what I do is to open two windows, one with my editor, and the other with GHCi
21:09:44 <trap_exit> Cale: what do you use the GHCi one for? in thta case, I just write some code in emacs, then hit make, which runs ghc + runs the prog
21:09:48 <Cale> trap_exit: Definitions go in the editor, and then whenever I save, I just hit :r in GHCi to reload the file and try out my new definitions.
21:09:53 <trap_exit> Cale: what do you need GHCi at atll for?
21:10:01 <Cale> Trying things as I go
21:10:17 <Cale> It's important to make sure that your functions behave as you expected them to
21:10:20 <glguy> spearman: The link I sent you talks about the actual status of the extension rather than the features of it
21:10:28 <spearman> if you load your module with :l and then edit the file with :e it will automatically re-load the module when you exit the editor which is nice
21:10:36 <Cale> and often I'll write some expression interactively in GHCi and then turn it into a definition in my code
21:10:58 <Cale> Like, do a bunch of successive list transformations one after the other, building my way toward the result I want
21:11:08 <sshine> trap_exit, this may be of interest: http://www.youtube.com/watch?v=1OYljb_3Cdg
21:11:11 <Cale> and then once the expression is complete, make a definition out of it
21:11:23 <Cale> > group "mississippi"
21:11:24 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
21:11:33 <Cale> > map head . group $ "mississippi"
21:11:34 <lambdabot>  "misisipi"
21:11:41 <Cale> > sort . group $ "mississippi"
21:11:42 <lambdabot>  ["i","i","i","i","m","pp","ss","ss"]
21:11:45 <sshine> whoops. spearman: that youtube linke was for you.
21:11:46 <Cale> > map head . sort . group $ "mississippi"
21:11:47 <lambdabot>  "iiiimpss"
21:11:47 <trap_exit> hmm
21:11:58 <trap_exit> Cale: genrally, I write code in emacs
21:12:04 <trap_exit> and when I write a function, I figure out how to call it from my main prog
21:12:05 <Cale> > sort $ "mississippi"
21:12:06 <lambdabot>  "iiiimppssss"
21:12:11 <trap_exit> and when I compile/run it, it gets tested that way
21:12:22 <Cale> Playing around like this can be a useful way to find the program you're after
21:12:41 <trap_exit> Cale: oh whit, break points, that is pretty impressive (re youtube video)
21:13:05 <arnoblalam> I see the http-client library uses this
21:13:22 <trap_exit> sshine: oh, you posted the yotube video, thanks :-)
21:13:32 <arnoblalam> but I do not see anywhere in http-cleint code the decodeLenient function being called
21:13:32 <sshine> trap_exit, yw :)
21:13:41 <arnoblalam> neither in the wreq code
21:14:27 <Cale> trap_exit: I don't even use GHCi for that stuff very much, but I have somewhat of a hard time living without it :P
21:14:57 <Cale> trap_exit: Being able to immediately test the code you've written in isolation without integrating it into your whole program is very important.
21:15:13 <agibiansky> arnoblalam: Interestingly enough, I cannot find a decode being called anywhere
21:15:17 <agibiansky> What would a decode be used for?
21:15:27 <agibiansky> Where does your program potentially decode base64 data?
21:15:45 <Cale> trap_exit: Also, just seeing the result of evaluation directly without relying on the behaviour of the rest of the program to make it clear what it was that happened.
21:15:55 <arnoblalam> well, I am getting a bunch of JSON data
21:16:00 <trap_exit> well
21:16:02 <trap_exit> the function is pure
21:16:03 <arnoblalam> but I am pretty sure that is utf8
21:16:09 <trap_exit> so it's only dependnt on the input
21:16:15 <trap_exit> Cale: don't you use pure languages like Haskell? :-)
21:16:29 <Cale> trap_exit: That's exactly why such testing is so valuable
21:16:49 <Cale> In non-pure languages, testing things in isolation is often meaningless
21:17:12 <agibiansky> arnoblalam: Well, that's sure weird. In that case, maybe if we find out why the hell its decoding base64 data, we'll also find out why it's so slow...
21:17:27 <Cale> because they frequently rely on and influence a wider context of stuff, which is why people use debuggers to inspect that context before and after their code runs
21:17:51 <agibiansky> arnoblalam: Could you separate your program into multiple toplevel functions?
21:18:01 <agibiansky> Then maybe we can see in the profile which one of them takes the longest
21:18:11 <agibiansky> So we can see which bit of it actually does the decoding?
21:18:21 <Cale> Haskell's purity is exactly why being able to type expressions in at the GHCi prompt and see the results is meaningful, because you know you'll get the same results when those cases actually happen in your program
21:18:40 <glguy> Where am I supposed "-pgmlo=/usr/local/opt/llvm34/bin/opt-3.4" so that GHC always uses that path?
21:18:42 <arnoblalam> ok… let me try to separate it into a part that just does HTTP connections and another part that does the JSON stuff
21:18:53 <agibiansky> arnoblalam: Also, the profiling... is that of the criterion bit?
21:19:01 <agibiansky> Is that the profile of the criterion benchmark?
21:19:07 <agibiansky> Or of what?
21:19:45 <arnoblalam> no, I have another program main.hs, that just calls do stuff
21:19:48 <arnoblalam> the code is here
21:20:40 <lpaste> arnoblalam pasted “Main.hs” at http://lpaste.net/117452
21:21:07 <arnoblalam> that just calss `doStuff`
21:23:38 <agibiansky> arnoblalam: Perhaps if doStuff were separated into several functions they would show up in the profiling
21:23:59 <agibiansky> arnoblalam: Also, how are you running the profiling?
21:24:15 <arnoblalam> I am trying to break this out into several programs now, for profiling
21:24:21 <agibiansky> Ah, ok
21:24:48 <arnoblalam> at the shell I type in $ ./main +RTS -p
21:25:10 <agibiansky> and compile with ghc -prof -fprof-auto -rtsopts Main.hs ?
21:25:11 <arnoblalam> I have built the program using
21:26:47 <agibiansky> arnoblalam: like you can also insert your own 'cost centers' using  {-# SCC "name" #-} expression
21:26:58 <agibiansky> I don't know how to use that with IO, i guess
21:27:07 <arnoblalam> cabal clean && cabal configure —enable-library-profiling —enable-executable-profiling —enable-tests —enable-benchmarks —ghc-opts=-rtsopts
21:28:11 <arnoblalam> also, the cabal file says
21:28:13 <arnoblalam>   ghc-options:          -Wall
21:28:14 <arnoblalam>                         -O2
21:28:20 <arnoblalam> nit sure if that carries over
21:29:06 <agibiansky> try it without -O2, it might inline less and give more info?
21:29:16 <agibiansky> i am a bit out of my depth here too so don't take what I say on faith :)
21:34:53 * hackagebot indices 1.7.1 - Multi-dimensional statically bounded indices.  http://hackage.haskell.org/package/indices-1.7.1 (MikeLedger)
21:38:32 <simpson> Hi! I am considering parser combinators for a new parser that I am writing. However, the language is whitespace-sensitive (Python-style blocks) and I'm not sure whether there's a good combinator idiom for that. Any hints?
21:38:44 <arnoblalam> argh
21:38:55 <arnoblalam> looks like I have to reinstall a whole bunch of stuff now
21:39:05 <arnoblalam> since my local version of aeson was out of date
21:39:05 <sshine> simpson, besides running a stateful Parsec, I don't know.
21:39:22 <simpson> sshine: That was my thought as well.
21:39:34 <simpson> Also a stateful lexer could extract INDENT and DEDENT tokens...
21:39:38 <arnoblalam> thanks for all your help y'all
21:39:43 <arnoblalam> I will keep troubleshooting
21:39:45 <agibiansky> arnoblalam: good luck
21:39:56 <arnoblalam> I think the next step is to figure out what library is calling decodeLenient
21:40:33 <agibiansky> simpson: Even using parser combinators, you can separate out the lexing and parsing stage
21:41:11 <agibiansky> simpson: In the lexing stage, you can use state to generate INDENT and DEDENT tokens, as you said, and then parsing could use those as if they were braces
21:41:11 <simpson> agibiansky: Yes.
21:41:19 <agibiansky> simpson: But sounds like you knew this :)
21:41:26 <simpson> agibiansky: There is, of course, the question of how to build the lexer!
21:41:52 <sshine> agibiansky, do you mean to use parser combinators in two phases, or combined?
21:42:15 <agibiansky> sshine: Generate tokens, then use a parser combinator library on those tokens
21:42:19 <agibiansky> Instead of on Chars
21:44:11 <sshine> that would be pretty similar to running a classical lex/parse phase.
21:44:19 <agibiansky> sshine: Yes
21:56:41 <arnoblalam> yep
21:56:52 <arnoblalam> it seems my problem is coming from the Wreq libary
21:57:02 <arnoblalam> I just profiled a simple https get request
21:57:22 <agibiansky> only https?
21:57:24 <arnoblalam> decodeLenient is being called when the get request is executed
21:57:31 <arnoblalam> let me try it with http
21:58:47 <arnoblalam> by the way, what is the standard cabal approach to building my program?
21:58:53 <arnoblalam> cabal clean && cabal cinfigure && cabal build?
21:59:10 <agibiansky> Yes, though you don't need to clean and reconfigure each time
21:59:31 <agibiansky> and cabal install if you want to install any resulting binaries into a sandbox or global pkgs
22:00:06 <agibiansky> For non-profiling type stuff, you can also start up a repl with `cabal repl` and and then :reload every time you make a change, and then you can use the repl to call whatever functions you want
22:07:39 <lpaste> arnoblalam pasted “https request” at http://lpaste.net/117453
22:07:49 <arnoblalam> that’s the output from the https call
22:08:36 <lpaste> arnoblalam pasted “http output” at http://lpaste.net/2319357441638137856
22:08:48 <arnoblalam> and that’s the profiling output from the http call
22:09:00 <agibiansky> looks about the same
22:09:14 <agibiansky> whats the code?
22:09:33 <arnoblalam> decodeLenientWithTable/fill             Data.ByteString.Base64.Internal   0.6    1.3 for http vs. decodeLenient/look                      Data.ByteString.Base64.Internal   7.7   11.6 for https
22:09:56 <arnoblalam> https://mq-aws-us-east-1.iron.io/1/projects/myProjectId/queues/default?oauth=mytoken
22:10:03 <arnoblalam> sorry
22:10:18 <arnoblalam> import Network.Wreq
22:10:19 <arnoblalam> main = get "https://mq-aws-us-east-1.iron.io/1/projects/53f691bd45d4960005000082/queues/default?oauth=_B6KOfA16D4AmW2NwSCw12mgVxk"
22:10:29 <arnoblalam> ah...
22:10:37 <arnoblalam> oops, that’s my token and project ID
22:10:46 <arnoblalam> looks like I will have to get a new one
22:10:50 <agibiansky> lol XD
22:10:53 <agibiansky> oops
22:11:17 <agibiansky> File a bug for Newtork.Wreq, I guess
22:11:34 <agibiansky> Maybe not, i dunno
22:11:36 <agibiansky> hmmm
22:15:38 <agibiansky> arnoblalam: oh jees, what if its parseURL?
22:22:54 <agibiansky> arnoblalam: Do you think it might have to do with persisting a connection?
22:23:16 <agibiansky> Perhaps python automatically persists the connection?
22:23:18 <arnoblalam> yes, I am making new connections every time
22:23:27 <agibiansky> Does python do the same?
22:23:32 <arnoblalam> while the python program is not
22:23:50 <arnoblalam> but since this is 3 calls, I would expect the program to be 3 times as slow
22:23:54 <arnoblalam> not 10 times...
22:24:22 <agibiansky> Oh
22:24:25 <arnoblalam> I am using the official client libraries from Iron.IO people… but I think they might be presisting the conenctions
22:24:26 <EvanR> whats the right encoding of binary numerals? i forgot
22:24:28 <agibiansky> Why would you expect it to be 3 times as slow?
22:24:53 <EvanR> data Bin = One | I Bin | O Bin ? but im missing zero
22:25:07 <arnoblalam> if I assume that creating an http/htps connection takes the same time in Haskell and python
22:25:16 <agibiansky> hm ok
22:25:22 <arnoblalam> if my program has to make 3 http/https connection while the python program only makes one
22:25:29 <agibiansky> maybe haskell is 3x slower than python here?
22:25:32 <arnoblalam> I guess it might be 3 times as slow...
22:25:52 <arnoblalam> I am going to turn off https in my program for a bit
22:25:59 <arnoblalam> and see if that makes it faster as well
22:26:13 <arnoblalam> although this is not an option for production, I think
22:28:01 <agibiansky> wreq uses tls by default it seems
22:29:46 <agibiansky> arnoblalam: Alright, it's late here, I have to go – good luck
22:29:59 <arnoblalam> thank you for all your help!
22:30:18 <agibiansky> Make sure to file bugs on whatever you find – there's definitely rough edges in the library space and it really does help to have people bump into them and report them
22:30:39 <agibiansky> Even if you don't know exactly why it happens, definitely worth making sure it ends up on an issue tracker somewhere
22:31:16 <EvanR> data Bin = Zero | I Bin | O Bin works but covers zero extra times..
22:32:25 <EvanR> data Bin = Zero | Twice Bin | TwicePlusOne Bin  ;)
22:45:12 <circ-user-Ik9bS> I really don't get how that main = do { } stuff is supposed to work. I have a working version, add one line and it produces compiler errors
22:46:45 <dhrosa> circ-user-Ik9bS: paste an example and we'll help you?
22:47:38 <circ-user-Ik9bS> I have a putStrLn "bla bla" and then add another line with a print or a show and it starts complaining
22:47:54 <circ-user-Ik9bS> then I try to "return ()" to get the IO type back but not working
22:49:39 <dhrosa> unless you have a let in there, every line in a do block must be monadic (in this case, of type IO something), or it must be a pattern that binds a monadic value to a name, like "x <- getArgs"
22:49:49 <dhrosa> so you can't just put a show in a do block, because show returns a String
22:50:04 <circ-user-Ik9bS> really? But what if I have pure stuff in - between?
22:50:05 <dhrosa> you need to use print (show x)), or putStrLn (show x), both of which are IO (String)
22:50:14 <dhrosa> then use a let block
22:50:27 <dhrosa> or you can lift the function into the monad using fmap or liftM or any of the variants
22:50:28 <circ-user-Ik9bS> ah that I can try
22:50:53 <circ-user-Ik9bS> my main is with a let ... in { ... } form
22:51:09 <dhrosa> here's a silly example: fmap (+1) (return 5) returns an IO Int with a value 6 inside
22:51:16 <pavonia> Also, indentation is important, that could be another problem
22:51:19 <circ-user-Ik9bS> whereas coming from F# I have no idea what that "in" is supposed to accomplish
22:51:46 <circ-user-Ik9bS> trying print show - that I did not try yet :)
22:52:17 <dhrosa> you can have a let block in the middle of a do block, so that you can have expressions in the let depend on stuff from inside the do block
22:52:23 <pavonia> print already use show implicitely
22:52:28 <pavonia> :t print
22:52:29 <lambdabot> Show a => a -> IO ()
22:52:43 <dhrosa> oops yeah
22:53:00 <dhrosa> you want print x, or putStrLn (show x), which is just a more explicit form of the former
22:54:09 <dhrosa> is there any thing you could do with the Writer monad that you couldn't do with State? or is the purpose of Writer to give you a nicer interface, because it uses a monoid's mappend?
22:57:58 <circ-user-Ik9bS> http://www.ipaste.org/3Qj
22:58:23 <circ-user-Ik9bS> maybe someone can show me how it is usually done in haskell :)
22:58:58 <circ-user-Ik9bS> I am pretty sure as I use posn wrapper of alex, that that the tokens <- alexScanTokens thing is wrong
22:59:22 <dhrosa> your indentation is screwed up
22:59:37 <circ-user-Ik9bS> not mine - it is emacs doing it :) in haskell-mode
22:59:38 <solatis> i usually start with main = let .... in do ...
22:59:43 <solatis> but that might be personaly preference
23:00:00 <dhrosa> I mean the indentation is just plain wrong
23:00:13 <solatis> woa
23:00:19 <solatis> i didn't even notice how wrong the indentation was
23:00:23 <circ-user-Ik9bS> looks ugly to my eyes, too but that is what emacs does in this simple-indent mode
23:00:26 <dhrosa> the putStrLn and below should be indented to a block before the text = line
23:00:39 <dhrosa> circ-user-Ik9bS: sometimes emacs will offer you multiple indentation options if you tab
23:00:51 <dhrosa> or it screws up tabbing if there's a syntax / parse errors
23:00:54 <solatis> circ-user-Ik9bS: i'm pretty sure the 'in' should be on a new line and emacs will align it with the let
23:01:09 <dhrosa> oh I didn't notice the "in" at the end
23:01:12 <dhrosa> you don't need in there
23:01:18 <circ-user-Ik9bS> without the last 2 lines, compiler complains if putStrLn is not indented behind the  let block
23:01:22 <dhrosa> (I didn't even know you could put it there0
23:01:37 <circ-user-Ik9bS> lets without in also exist? :)
23:01:49 <pavonia> Only in do-blocks
23:02:01 <circ-user-Ik9bS> cryptic
23:02:29 <circ-user-Ik9bS> in f# I would write a let for each new variable I introduce
23:02:37 <circ-user-Ik9bS> but that does not seem to work in haskell
23:02:49 <pavonia> Have you already read an introduction to do-notation in Haskell?
23:03:05 <circ-user-Ik9bS> I have read too much in the past few days to remember it all :)
23:03:17 <erisco> > do let x = 5; let y = 6; 5 + 6;
23:03:18 <lambdabot>  <hint>:1:31: parse error on input ‘;’
23:03:26 <erisco> > do { let x = 5; let y = 6; 5 + 6; }
23:03:27 <lambdabot>  <hint>:1:33: parse error on input ‘;’
23:03:30 <circ-user-Ik9bS> do is a monad thingy which actually enforces imperative style of execution
23:03:33 <erisco> hmmmm
23:03:45 <sivteck> return
23:03:50 <LABurn> How do I pass flag options to ghc from a cabal sandbox when building with the command "cabal exec ghc /path/to/source"
23:03:51 <erisco> > do { let x = 5; let y = 6; 5 + 6 }
23:03:52 <lambdabot>  <hint>:1:34: parse error on input ‘}’
23:03:53 <Peaker> circ-user-Ik9bS: Do is just sugar for calls to (>>=) and (>>)
23:04:09 <pavonia> > do let {x = 5}; let {y = 6}; 5 + 6;
23:04:10 <lambdabot>  11
23:04:14 <Peaker> circ-user-Ik9bS: and (>>=) and (>>) can be used for imperative programming, but not just for that, so imperative isn't "enforced"
23:04:32 <circ-user-Ik9bS> yeah in f# you often do lambda chaining with ->
23:04:43 <Peaker> circ-user-Ik9bS: note that due to laziness variable introduction order doesn't matter, so lots of Haskellers prefer "where" clauses over "let"
23:04:52 <circ-user-Ik9bS> that I know but I thought I can simply write a sequence of lines , each being one execution step here
23:05:05 <erisco> > do { let {x = 5}; let {y = 6}; 5 + 6 }
23:05:07 <lambdabot>  11
23:05:11 <erisco> there, a let per binding
23:05:23 <Peaker> circ-user-Ik9bS: well, in F# multiple lines are imperative programming, they're basically all bound together with something like (>>=) of the IO type implicitly. In Haskell the effect type and binding are more explicit
23:05:38 <circ-user-Ik9bS> hm..
23:06:03 <erisco> @faq Can you write a "let" for each new variable you introduce?
23:06:03 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
23:06:09 <erisco> wrong module
23:06:22 <LABurn> Any advice?
23:06:49 <circ-user-Ik9bS> so in my main example I would write: main = let mFileName = ... ; let tokens = alexScanTokens text; in do { putStrLn mFileName; print (show (tokens) ) } ?
23:07:06 <LABurn> I can't seem to find any helpful resources on the internet that would help me solve my problem
23:07:13 <erisco> circ-user-Ik9bS, well I just demonstrated how you can use "let" in a do block
23:07:26 <pavonia> circ-user-Ik9bS: No, the first let is missing an in
23:07:43 <circ-user-Ik9bS> yeah but the issue goes deeper imho - it is about where to place pure stuff - and monadic stuff
23:08:05 <circ-user-Ik9bS> oh there I would need in every time as it is outside a monad, right?
23:08:38 <erisco> monadic does not mean impure
23:08:45 <pavonia> LABurn: Nothing helpful in "cabal exec --help"?
23:09:17 <LABurn> Well it says flags after exec, but those are flags for the exec command
23:09:41 <circ-user-Ik9bS> *silent thinking
23:09:59 <LABurn> and if I try passing flags to ghc after I specify I want to use ghc it simply says unrecognized exec option
23:10:09 <circ-user-Ik9bS> so in a let .. in I cannot do more than one assignment?
23:10:58 <erisco> IO happens to be a Monad and you can do side effects with it, but even then it is designed such that it is not impure
23:11:31 <dibblego> no you can't
23:11:36 <erisco> > do { let { x = 5; y = 6; }; x + y }
23:11:37 <lambdabot>  11
23:11:47 <erisco> circ-user-Ik9bS, looks like you can do more than one assignment
23:11:56 <dibblego> IO has nothing to do with side-effects.
23:12:03 <circ-user-Ik9bS> that is a matter of viewpoint. impure often is meant to say: side effects. do { detonateNuke; } clearly has a side effect :)
23:12:55 <circ-user-Ik9bS> ah let with a curly block - but that shoudl be the same as indent and multiple lines, right?
23:12:57 <vin-ivar> hello
23:13:07 <erisco> that is true, so by side effect I mean operations such as disk IO, and by not being impure I mean for same inputs you get same outputs
23:13:13 <vin-ivar> would any of you happen to know of a good book on FP?
23:13:14 <pavonia> LABurn: What have you tried so far?
23:13:18 <dibblego> vin-ivar: FP in Scala
23:13:26 <vin-ivar> certain things are hard for me to wrap my head around :'(
23:13:28 <dibblego> erisco: disk IO has nothing to do with side-effects
23:13:29 <erisco> and that is achieved with IO functions by never passing in the same inputs twice, which is neatly tucked away for you
23:13:39 <vin-ivar> nothing language-agnostic, dibblego?
23:13:42 <vin-ivar> but thanks
23:13:44 <dibblego> Haskell does not have side-effects, including all IO programs
23:14:00 <dibblego> vin-ivar: that book is as language-agnostic as it gets
23:14:14 <vin-ivar> cheers, I'll take a look
23:14:25 <vin-ivar> a question
23:14:27 <circ-user-Ik9bS> of course it has. Imagine a delete file , read file operation. delete file produces the side effect that the file no longer exists - so the next step read file would fail
23:14:28 <vin-ivar> It will then pass this input to the rest of the do block (which is also an action) under the name str when it (the rest) is executed. In Haskell you never assign to a variable, instead you bind a name to a value. When the action produced by the do block is executed, it binds the name str to the value returned by executing the action that was produced by getLine.
23:14:37 <vin-ivar> ^isn't this just a semantic difference
23:14:56 <erisco> dibblego, well if you want to draw a line in the sand such that you can say that, sure
23:14:57 <dibblego> circ-user-Ik9bS: No. That can be modelled as an IO effect that is not a side-effect, as in Haskell.
23:15:00 <LABurn> cabal exec ghc "--make -threaded /path/to/script"
23:15:00 <LABurn> cabal exec ghc --make -threaded /path/to/script
23:15:00 <LABurn> then I started googling
23:15:10 <dibblego> erisco: these are definitions, not lines in the sand
23:15:18 <erisco> yours
23:15:22 <solatis> haha oh god not the impure/pure discussion again :)
23:15:24 <dibblego> No.
23:15:31 <erisco> discuss all the things!
23:15:41 <sivteck> :Haskell does not have side-effects" <- that refers to Haskell, the language (2010 report) and not necessarily GHC Haskell implementation right? >.>
23:15:43 <solatis> i think this comes up, what, two times every day ?
23:15:49 <dibblego> solatis: this mistake occurs regularly, yes
23:16:05 <dibblego> sivteck: it refers specifically to SafeHaskell
23:16:07 <erisco> whatever the distinction is it cannot be that useful
23:16:15 <circ-user-Ik9bS> IO is a monad which allows manipulation of "world" and as such it is there to express side effects
23:16:17 <solatis> next up: FRP !
23:16:22 <dibblego> circ-user-Ik9bS: No.
23:16:33 <erisco> uh, Lithium is the new Sodium
23:16:35 <erisco> NEXT
23:16:36 <dibblego> to "express IO effects"
23:16:42 <dibblego> [] is a monad to express [] effects
23:16:43 <solatis> tabs are the new spaces?
23:16:47 <dibblego> there are no side-effects here
23:16:58 <davidthomas> This boils down to whether there is a difference between "effects" and "side effects"
23:17:05 <dibblego> I can do IO with the (Free Grammar) monad and again, no side-effects
23:17:13 <erisco> this is incredibly silly dibblego
23:17:13 <dibblego> davidthomas: of course there is
23:17:30 <dhrosa> circ-user-Ik9bS: writing code in the IO monad doesn't have side-effect unless it gets reached by main
23:17:35 <circ-user-Ik9bS> side effects are something which is being changed from code which is not within the realm of the return values...
23:17:40 <dibblego> It is a very important distinction.
23:17:41 <pavonia> LABurn: What about "cabal exec ghc -- --make -threaded /path/to/script"?
23:17:43 <sivteck> erisco, "dibblego> sivteck: it refers specifically to SafeHaskell"
23:17:55 <davidthomas> dibblego: I agree with you, but it's mostly a matter of definition
23:17:59 <solatis> ok guys, we really need a wiki page we can refer to when this discussion comes up again
23:18:04 <dibblego> circ-user-Ik9bS: No, side-effects refer specifically to expressions which when replaced with their value, alter the program.
23:18:07 <davidthomas> I even agree that our definitions are more useful...
23:18:11 <dhrosa> circ-user-Ik9bS: "f :: Int = let x = putStrLn "hello world" in 3" is valid code that will NOT print hello world to the screen
23:18:17 <dibblego> davidthomas: it is the only definition that is widely used, of course
23:18:21 <solatis> i see the same arguments being recycled all the time
23:18:24 <dibblego> (and this beginner mistake repeats itself, over and over)
23:18:25 <dhrosa> err, almost valid code, I'm missing a f = part :p
23:18:28 <davidthomas> dibblego: that's false
23:18:57 <circ-user-Ik9bS> yes because it is not executed (yet)
23:19:01 <dibblego> The book referred to above clears all of this up.
23:19:05 <LABurn> That worked, thanks man. I appreciate the help :)
23:19:09 <circ-user-Ik9bS> but once you execute (evaluate) x, that changes
23:19:12 <dhrosa> circ-user-Ik9bS: no, that code I wrote will NEVER execute the hello world part
23:19:22 <dibblego> circ-user-Ik9bS: here is a I/O program using C# without any side-effects https://gist.github.com/tonymorris/7817335
23:19:42 <dibblego> again, a side-effect is a property of an expression  blah blah
23:20:09 <solatis> i can see both points of view
23:20:11 <circ-user-Ik9bS> errm... that is like saying: every function not invoked is pure
23:20:12 <solatis> you are both correct
23:20:14 <solatis> and both incorrect
23:20:16 <erisco> I don't see anything inconsistent between that and what I said
23:20:23 <solatis> now make a silly dance please
23:20:27 * solatis hugs dibblego and circ-user-Ik9bS
23:20:43 <dibblego> I have a limit of patience for persistent beginner mistakes.
23:20:46 <dibblego> Bye.
23:20:49 <davidthomas> (also, any Haskell *implementation* will have additional side effects like memory use and heat generation :-P)
23:21:08 <circ-user-Ik9bS> indeed david
23:21:35 <solatis> this is a "in theory, practice and theory are the same, but in practice, they are not"-discussion
23:21:35 <EvanR> side effects are annoying, give me intentional effects
23:21:48 <SharpGAF> davidthomas: But what about reversible computing? :P
23:21:52 * SharpGAF ducks.
23:21:56 <solatis> SharpGAF: FRP please!!
23:22:01 <circ-user-Ik9bS> maybe , dibblego it is the monad concept as such and the terms used which are the problem. In old time C- embedded programming we spoke of "reentrant" functions when we wanted to make clear that "nothing outside the function is changed"
23:22:02 <davidthomas> EvanR: I'd rather heat generation be a side effect than managed explicitly, thank you :-P
23:22:09 <davidthomas> at least for most of my work...
23:22:27 * EvanR turns the heat off since its 80 degrees in louisiana winter
23:22:41 <davidthomas> heh
23:22:41 <dibblego> circ-user-Ik9bS: I would like to help you, but there are too many misconceptions being proposed, faster than they can be knocked out. Another IRC channel perhaps.
23:22:41 <solatis> hah, you are lucky
23:22:59 <erisco> so sour, why
23:23:03 <solatis> it's 104 degrees here
23:23:41 <circ-user-Ik9bS> in haskell org they advertise the language is "easy and intuitive" there is nothing intuitive about it f I cannot even print 2 lines in a row, one showing a sting, one the output of the scanner without ending in such discussions
23:23:52 <solatis> the fact that there is so much disagreement in #haskell about this subject should say enough, circ-user-Ik9bS
23:24:03 <dibblego> solatis: No there isn't.
23:24:16 <sivteck> perhaps #haskell-overflow
23:24:20 <erisco> I don't even see where the disagreement is happening
23:24:22 <dibblego> Again, a common beginner mistake, but it is quite well understood otherwise.
23:24:26 <solatis> i think rather #haskell-circlejerk
23:24:26 * EvanR wonders about advertisements saying its easy and intuitive
23:24:29 <erisco> I just see pedantic quibbling
23:24:36 <EvanR> "simple made easy" is bad enough
23:24:39 <dhrosa> davidthomas: we can make a more explicit version of everything. everything must be wrapped in the GeneratesHeatT and ComputerMayCrashT monad transformers
23:24:47 <dhrosa> and UsesMemoryT
23:24:53 <circ-user-Ik9bS> he insists on stating that IO monads are pure which is about the exact opposite of the function of IO monad
23:25:02 <bitemyapp> circ-user-Ik9bS: why are you here?
23:25:09 <dibblego> hi bitemyapp :)
23:25:16 <circ-user-Ik9bS> monads are there to make "impure things" possible i a "pure langage"
23:25:18 <bitemyapp> dibblego: I smelled blood.
23:25:31 <solatis> circ-user-Ik9bS: it's a semantics discussion -- the code you write is pure, the code the CPU executes is impure
23:25:32 <dibblego> circ-user-Ik9bS: would you like to learn why it is true? Of course, we can ignore the other comments, then we can make progress.
23:25:34 <davidthomas> circ-user-Ik9bS: The function of the IO monad is to sequence effects, and - arguably - to keep them from being *side* effects
23:25:43 <dibblego> solatis: that is not true
23:25:45 <erisco> circ-user-Ik9bS, but that is underselling monads, so if you say that kind of stuff you need to expect some discussion about it
23:25:50 <EvanR> > length [getLine, putStr "foo", print ()]
23:25:51 <lambdabot>  Couldn't match type ‘()’ with ‘[GHC.Types.Char]’
23:25:51 <lambdabot>  Expected type: GHC.Types.IO GHC.Base.String
23:25:51 <lambdabot>    Actual type: GHC.Types.IO ()Couldn't match type ‘()’ with ‘[GHC.Types.Char]’
23:25:51 <circ-user-Ik9bS> it...does...not execute what I write? :)
23:26:00 <dhrosa> circ-user-Ik9bS: the IO monad is actually pure. you can think of the IO monad as just a datastructure holding actions to run. The haskell runtime is what actually looks at the IO object in main and "executes" it
23:26:03 <EvanR> > length [getLine, putStr "foo"]
23:26:04 <lambdabot>  Couldn't match type ‘()’ with ‘[GHC.Types.Char]’
23:26:05 <lambdabot>  Expected type: GHC.Types.IO GHC.Base.String
23:26:05 <lambdabot>    Actual type: GHC.Types.IO ()
23:26:18 <solatis> the IO monad uses unsafe functions
23:26:21 <dibblego> circ-user-Ik9bS: No, just like it doesn't if I were to model your IO effects using some other mundane data type
23:26:21 <bitemyapp> davidthomas: very precarious explanation
23:26:25 <solatis> those unsafe functions are implemented in the GHC runtime
23:26:30 <solatis> those are impure
23:26:32 <bitemyapp> davidthomas: that requires knowing the difference between IO and its typeclass instances.
23:26:41 <solatis> but what is exposed is pure, so the IO monad is pure
23:26:44 <dhrosa> > length [void getLine, putStr "foo"]
23:26:44 <bitemyapp> davidthomas: people asking questions like this won't understand the distinction.
23:26:45 <lambdabot>  2
23:27:00 <bitemyapp> circ-user-Ik9bS: monads are not there to make "impure things possible"
23:27:06 <dibblego> bitemyapp: there is also profound confusion of "the IO type constructor" and "the IO monad", but we hadn't got to that
23:27:07 <bitemyapp> circ-user-Ik9bS: monads have nothing to do with "impure things"
23:27:15 <solatis> look at the Maybe monad
23:27:16 <bitemyapp> dibblego: yeah I was sorta...skimming off that topic.
23:27:19 <solatis> for an example of a pure Monad
23:27:21 <EvanR> > length [undefined, fix error, 9]
23:27:22 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
23:27:22 <lambdabot>    arising from the literal ‘9’
23:27:26 <dibblego> bitemyapp: it's going to be tough, good luck :)
23:27:35 <dhrosa> I like EvanR's example
23:27:40 <dibblego> also look at IO for an example of a pure monad
23:27:42 <davidthomas> bitemyapp: I don't see where typeclasses enter into it
23:27:51 <bitemyapp> davidthomas: pedagogy.
23:28:04 <bitemyapp> davidthomas: you can't lean on explanations that require the receiver understanding things they don't understand.
23:28:04 <dibblego> davidthomas: monad is a type-class, IO is a type constructor. That type-class is unrelated to this discussion
23:28:06 <circ-user-Ik9bS> I never understood why Maybe has to be monadic and not like in F# just a discriminated union
23:28:23 <EvanR> > length [undefined, last (let ones = 1:ones in ones) , 9]
23:28:24 <lambdabot>  3
23:28:29 <EvanR> hehe
23:28:30 <dibblego> anyway, too much for me, good luck bitemyapp
23:28:30 <dhrosa> what do you mean "has to be monadic", you're not forced to use Maybe as a monad
23:28:32 <davidthomas> hmm
23:28:42 <bitemyapp> dibblego: I'll bail not long after you.
23:28:50 <dhrosa> likewise you can do a lot of stuff in IO without actually using monad features
23:28:59 <solatis> circ-user-Ik9bS: there is also a List monad
23:29:01 <bitemyapp> dhrosa: you're not forced to use IO as a monad either.
23:29:04 <solatis> but List doesn't have to be monadic
23:29:38 <circ-user-Ik9bS> wait a minute - we come closer. What do you mean with "forced to use Maybe as a monad" Either Mabe is a monadic type or is it not, right?
23:29:50 <erisco> I see the problem
23:30:06 <bitemyapp> circ-user-Ik9bS: you don't know enough to have a cogent conversation about any of that.
23:30:09 <dhrosa> just because something is a monad doesn't mean you have to use do notation
23:30:10 <erisco> too much too fast. You'd be better to read Learn You A Haskell or something for a while longer and come back later
23:30:18 <bitemyapp> circ-user-Ik9bS: I suggest learning some Haskell as that will be faster than chasing your tail in IRC.
23:30:31 <davidthomas> bitemyapp: ah, I'd understood a deeper level of understanding :-P
23:30:36 <bitemyapp> circ-user-Ik9bS: I spent about 5 years being confuddled by all this, whereas I can teach Haskell to people in a couple of weeks.
23:30:41 <bitemyapp> circ-user-Ik9bS: so. 5 years or a couple of weeks?
23:31:00 <erisco> we have quorum and consensus has been reached. To the books!
23:31:01 <circ-user-Ik9bS> lol - I get my stuff working in f# - so  I would think I know a wee bit about programming. Only the haskell commuity is obscure. Just as when they say that partial function application is not currying. But they never manage to explain
23:31:08 <bitemyapp> circ-user-Ik9bS: https://github.com/bitemyapp/learnhaskell my guide is here. an IRC channel is mentioned there where you can seek help with the recommended course if you promise not to troll.
23:31:15 <bitemyapp> circ-user-Ik9bS: knowing F# has nothing to do with what is done in Haskell.
23:31:24 <bitemyapp> circ-user-Ik9bS: I can teach you things if you stop trying to get a rise out of people.
23:31:29 <dibblego> isn't it weird we so casually talk about "the IO monad", but we wouldn't dare say something equally irrelevant like, "the IO applicative"
23:31:30 <EvanR> circ-user-Ik9bS: thats just terminology malfunction
23:31:36 <bitemyapp> circ-user-Ik9bS: I'm a much less nice person than you are, you can't make me angry.
23:31:41 <circ-user-Ik9bS> I program since about 1983...
23:31:42 <bitemyapp> circ-user-Ik9bS: so focus on what's to be learnt.
23:31:46 <bitemyapp> circ-user-Ik9bS: none of that matters.
23:31:53 <bitemyapp> circ-user-Ik9bS: None of it. It's all in how you spend the time.
23:31:55 <dibblego> bitemyapp: FYI, F# does not permit the expression of the monad interface
23:32:05 <bitemyapp> circ-user-Ik9bS: you can spend a lifetime not learning the algebras...or you can spend a couple of weeks.
23:32:10 <erisco> circ-user-Ik9bS, I bet you do know a wee bit about programming, but all the same this is #haskell and you might equally suspect #haskell regulars know a wee bit about Haskell and thus a wee bit about when someone needs to learn more Haskell
23:32:13 <bitemyapp> dibblego: I know. Among a bunch of other things.
23:32:20 <bitemyapp> dibblego: crippled ML. I don't know why people bother.
23:32:34 <EvanR> im not used to seeing so many people up in arms in here
23:32:40 <circ-user-Ik9bS> okay now get down to bits and pieces please. What is the difference between f# monads and haskell monads?
23:32:48 <bitemyapp> circ-user-Ik9bS: don't bother with the comparative theology
23:32:51 * SharpGAF is hoping to learn something.
23:32:52 <EvanR> must be the euros breakfasttime ;)
23:33:00 <dhrosa> he burned our crops, poisoned our water supply, and delivered a plague unto our houses!!
23:33:05 <bitemyapp> circ-user-Ik9bS: you're asking us to believe you'll trust an answer from people you just spend the last however many units of time trolling.
23:33:12 <dibblego> circ-user-Ik9bS: F# does not have higher kinded polymorphism, so cannot express the abstraction (which is the entire point of many things, including monads)
23:33:15 <bitemyapp> circ-user-Ik9bS: I think it's more believable that you'll trust an answer you arrived at yourself.
23:33:23 <dhrosa> i don't think he's trolling
23:33:41 <EvanR> even better reason not to treat him like he is
23:33:57 <bitemyapp> dhrosa: I have adhere to a definition of trolling which includes unconstructive, attention-seeking disruptiveness.
23:34:13 <circ-user-Ik9bS> if you consider anyone asking questions trolling just because this proofs that haskell is not "intuitive" or "people fail to explain", you should do a tiny bit of learning. I am not trolling at all. Just asking and as anyone intelligent I assume things can be explained
23:34:16 <bitemyapp> dhrosa: it may not include out-and-out malice and name-calling, but it's still net-negative.
23:34:25 <dibblego> I think it is profound confusion. Let's just do our best in light of that.
23:34:28 <EvanR> nothing is intuitive
23:34:33 <dibblego> Let's assume the best of others.
23:34:34 <bitemyapp> circ-user-Ik9bS: I can get you your answers more quickly than by any means you think you can attain them
23:34:38 <bitemyapp> dibblego: very well.
23:34:46 <erisco> wheels are spinning in the mud now... how can we possibly recover from this point?
23:34:51 <solatis> maybe we should move this discussion to #haskell-beginner ?
23:34:57 <bitemyapp> solatis: HEY
23:35:05 <bitemyapp> solatis: don't dump him on us until he's more polite.
23:35:07 <bitemyapp> solatis: :P
23:35:17 <EvanR> #haskell-timeout
23:35:21 <circ-user-Ik9bS> okay - let vs let in - why 2 forms?
23:35:23 <bitemyapp> EvanR: that's #haskell-blah
23:35:37 <EvanR> theres no let
23:35:37 <bitemyapp> circ-user-Ik9bS: why is that important?
23:35:53 <circ-user-Ik9bS> if there are 2 forms not one there must be a difference, right?
23:35:54 <EvanR> nevermind, do notation
23:36:10 <solatis> circ-user-Ik9bS: yes, one is used within a do block, the other not
23:36:23 <solatis> the reason for that is that 'in' makes no sense in a do block
23:36:24 <circ-user-Ik9bS> and why would the normal let not work within a do block?
23:36:24 <bitemyapp> solatis: what
23:36:25 <dibblego> EvanR: There is; it isn't typed
23:36:40 <solatis> let ... in cannot be used in a do block, right ?
23:36:46 <EvanR> it can
23:36:48 <solatis> and let without in can only be used within a do block
23:36:52 <dibblego> solatis: to the right of <-
23:36:54 <erisco> > do { let x = 5 in x }
23:36:55 <lambdabot>  5
23:37:09 <solatis> > do let x = 5 in x
23:37:10 <lambdabot>  5
23:37:11 <bitemyapp> solatis: http://en.wikibooks.org/wiki/Haskell/do_Notation#Example:_user-interactive_program
23:37:13 <solatis> dammit
23:37:15 <circ-user-Ik9bS> yes but WHY did they introduce those 2 forms instead of having the let syntax be the same in both cases?
23:37:18 <solatis> i never used that
23:37:23 <bitemyapp> circ-user-Ik9bS: what does "two forms" mean?
23:37:31 <dhrosa> bitemyapp: one with in, one without in
23:37:33 <erisco> > do 5
23:37:35 <lambdabot>  5
23:37:35 <solatis> circ-user-Ik9bS: "let" does the same in both cases
23:37:41 <SharpGAF> Wait, why doesn't F# have higher kinded polymorphism?  Does it not have functors?
23:37:43 <erisco> I write all my literals that way
23:37:57 <sivteck> heh
23:38:01 <EvanR> > don't 5
23:38:02 <lambdabot>  Not in scope: ‘don't’
23:38:05 <dibblego> SharpGAF: the reasons are complicated and no it doesn't
23:38:06 <circ-user-Ik9bS> but why do I have to use "in" and indent in one case and not in the other?
23:38:17 <erisco> @let don't = id
23:38:18 <SharpGAF> dibblego: Hm, okay.
23:38:19 <lambdabot>  Defined.
23:38:19 <bitemyapp> dhrosa: I was asking a more philosophical question.
23:38:23 <calvinx> how do I use cabal? I keep getting the message “Warning: The package list for 'stackage' is 21 days old. Run 'cabal update' to get the latest list of available packages.” despite running `cabal update` a few times already.
23:38:23 <moop> EvanR: do or do not, there is no try
23:38:30 <EvanR> :t try
23:38:30 <lambdabot> Exception e => IO a -> IO (Either e a)
23:38:31 <dibblego> in fact, no .NET language has higher kinds (C#, F#, Nemerle, C omega)
23:38:32 <solatis> > don't 5
23:38:33 <lambdabot>  5
23:38:38 <bitemyapp> calvinx: you're using Stackage.
23:38:42 <SharpGAF> Is there some CLR limitation preventing it?
23:38:45 <solatis> @let don't = negate
23:38:46 <lambdabot>  .L.hs:169:1:
23:38:46 <lambdabot>      Multiple declarations of ‘don't’
23:38:46 <lambdabot>      Declared at: .L.hs:168:1
23:38:58 <calvinx> yes I am
23:38:59 <moop> @undef don't
23:39:00 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
23:39:06 <moop> @undefine don't
23:39:06 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
23:39:13 <solatis> @undefine
23:39:13 <lambdabot> Undefined.
23:39:16 <solatis> @let don't = negate
23:39:16 <circ-user-Ik9bS> two forms means here 2 syntaxi for the same idiom which is assign an expression to a variable (bind)
23:39:17 <lambdabot>  Defined.
23:39:19 <solatis> > don't 5
23:39:20 <lambdabot>  -5
23:39:23 <solatis> hah!
23:39:26 <dibblego> SharpGAF: there is a proposal to introduce it, but also, the creators of F# are unaware of the benefits of higher kinds. Erik Meijer and I discussed this early on.
23:39:28 <moop> > don't -5
23:39:29 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
23:39:29 <lambdabot>    arising from a use of ‘M47558776966555724115855.show_M47558776966555724115...
23:39:29 <lambdabot>  The type variable ‘a0’ is ambiguous
23:39:34 <solatis> > don't (-5)
23:39:36 <lambdabot>  5
23:40:03 <bitemyapp> dibblego: that's unfortunate.
23:40:04 <solatis> moop: NegativeLiterals language extension fixes this :)
23:40:04 <EvanR> @let don't = const (return ())
23:40:05 <lambdabot>  .L.hs:153:1:
23:40:05 <lambdabot>      Multiple declarations of ‘don't’
23:40:05 <lambdabot>      Declared at: .L.hs:152:1
23:40:06 <neuroserpens> don't (-(-(-(-(-(-(-(-(-(-5))))))))))
23:40:09 <circ-user-Ik9bS> in f# you can write the in but it is optional (and for the good reason, imho, that it really does not change a thing)
23:40:15 <neuroserpens> lol
23:40:25 <bitemyapp> circ-user-Ik9bS: so go use F#
23:40:33 <bitemyapp> circ-user-Ik9bS: godspeed.
23:40:46 <circ-user-Ik9bS> is it about "capture scope" rules which are different within monads and outside?
23:40:59 <solatis> guys, this is a nice channel, please refrain from passive aggressiveness
23:40:59 <EvanR> circ-user-Ik9bS: you can use an in if you want
23:41:01 <erisco> and in Idris you can use dependent typing but you don't see me coming here to complain do you?
23:41:04 <dibblego> you cannot write sequence in F# though. You have to write it over and over, for every applicative functor, and there are lots of those.
23:41:07 <erisco> teehee
23:41:13 <neuroserpens> erisco: lmao
23:41:38 <conal> circ-user-Ik9bS: maybe it'd help if you shared your motivation for your line of questioning. without, it's easy to assume you're trolling.
23:41:42 <moop> and in python you don't even need to define types
23:41:46 <EvanR> yeah, foreach loops, indespensible
23:41:51 <solatis> conal: elm is FRP!
23:42:01 <davidthomas> circ-user-Ik9bS: It's different in do-notation, specifically
23:42:06 <erisco> elm and, uh, what is it again
23:42:10 <bitemyapp> solatis: if people keep saying that to him every time he pops into IRC, we might see less of him.
23:42:13 <bitemyapp> solatis: please don't.
23:42:13 <circ-user-Ik9bS> interesting. But totally not obvious how that relates dibblego. "Binding and expression to an identifier" is what let (in f#) does. There is not more to it.
23:42:36 <dibblego> circ-user-Ik9bS: I am just making a point of note, relevant to the discussion about "monad", which cannot be expressed in F# at al.
23:42:56 <conal> solatis: oh? what makes you think so?
23:42:58 <circ-user-Ik9bS> um... f# also has monads
23:43:18 <dibblego> circ-user-Ik9bS: no, not in the way being discussed here, that is very pertinent to your misunderstandings earlier
23:43:21 <neuroserpens> I'm getting bored by LYAH and RWH. Someone entertain meh.
23:43:27 <circ-user-Ik9bS> and one of my earlier questions was "what is the difference between h-and f# monads" and the answer was "you troll"
23:43:28 <solatis> conal: i'm not saying, so you have to assume i'm trolling :)
23:43:34 <bitemyapp> neuroserpens: learn moar better: https://github.com/bitemyapp/learnhaskell
23:43:42 <conal> solatis: done. :)
23:43:50 <moop> neuroserpens: why is 6 afraid of 7?
23:43:54 <dibblego> circ-user-Ik9bS: I have answered that question. F# does not have higher kinds, and so cannot express the monad abstraction, and tehrefore, all the practical benefits of that ability.
23:44:00 <neuroserpens> bitemyapp: WAO. Much learn. Very fun. Lots doge.
23:44:02 <erisco> solatis, conal what is the joke?
23:44:06 <neuroserpens> bitemyapp: lol i'll check it out thanks
23:44:11 <bitemyapp> neuroserpens: give cis194 -> NICTA course a shot.
23:44:12 <neuroserpens> moop: No freaggin idea
23:44:20 <bitemyapp> neuroserpens: it's how we teach over in #haskell-beginners. Has worked v well for us.
23:44:24 <conal> moop: i love that joke.
23:44:29 <solatis> erisco: conal is an authority on the area of FRP. Elm is a language dedicated to FRP, but conal does not agree with that.
23:44:31 <circ-user-Ik9bS> so you say f# monads are not "real monads"?
23:44:32 <bitemyapp> neuroserpens: is usually less boring for people too :)
23:44:32 <frawgie_> neuroserpens: https://ocharles.org.uk/blog/ you can find a bunch of good libraries there on top of what they show you in the books you mentioned :)
23:44:41 <moop> because 7 is a strong beatiful woman who don't need no 6 in her life
23:44:48 <solatis> erisco: or at least, it is not fully FRP.
23:44:59 <EvanR> im glad to see ... anybody talking about FRP these days
23:45:02 <dibblego> circ-user-Ik9bS: they are "real", but not very practical, relatively speaking
23:45:06 <bitemyapp> circ-user-Ik9bS: would you say 6502 assembler has functions?
23:45:07 <erisco> solatis, I knew the first two but I have not read on why conal disagrees with Elm's choices
23:45:09 <neuroserpens> frawgie_: Nice. Thanks.
23:45:19 <neuroserpens> moop: You lost me...
23:45:29 <frawgie_> neuroserpens: not sure how entertaining it is though, but it helped me to get out of the bored-phases when I read the books
23:45:29 <bitemyapp> circ-user-Ik9bS: we're talking about a similar abstraction gap here where you can "use" a pattern without being able to reify, abstract, or reuse it.
23:45:29 * neuroserpens didn't understand the joke
23:45:31 <solatis> erisco: ah i believe one of the main points had to do with the notion of time in between events
23:45:35 <dibblego> circ-user-Ik9bS: in F#, you cannot write a function that works across all monads. This ability is the entire point of monads. (not side-effects, IO, etc)
23:45:40 <neuroserpens> frawgie_: That's great.
23:45:42 <conal> solatis: it's really that i don't like how the term "FRP" has become so diffuse/broad/imprecise.
23:46:00 <moop> @let frp = "Fibre-reinforced plastic"
23:46:01 <lambdabot>  Defined.
23:46:04 <moop> > frp
23:46:05 <lambdabot>  "Fibre-reinforced plastic"
23:46:08 <moop> cool
23:46:16 <solatis> conal: yeah, i understand. but it's a sad fact that that's how the non-academic world works.
23:46:21 <bitemyapp> circ-user-Ik9bS: this ability to write a "function that works across all monads" is rather important for code reuse, refactoring, and it simply fits into how people think about programmatic structure better.
23:46:29 <solatis> they want some easy-to-grasp buzzword
23:46:29 <neuroserpens> @let moop'sJoke = "Lameh... I didn't get it"
23:46:30 <lambdabot>  Defined.
23:46:31 <erisco> solatis, so if I told conal that bacon.js is FRP could I be a troll too?
23:46:36 <neuroserpens> > moop'sJoke
23:46:38 <lambdabot>  "Lameh... I didn't get it"
23:46:43 <bitemyapp> circ-user-Ik9bS: I know I want "sequenceA" not some specific nonsense. What if I want to change my data type? Must I change all my code too? That's silly.
23:46:50 <bitemyapp> @ty sequenceA
23:46:51 <lambdabot>     Not in scope: ‘sequenceA’
23:46:51 <lambdabot>     Perhaps you meant one of these:
23:46:51 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
23:46:53 <solatis> erisco: i bet you can!
23:46:55 <bitemyapp> gerd dermert
23:46:55 <conal> solatis: because blurring the term "FRP" (so broadly as to include things like elm, bacon, and even Rx) makes it easy for the fundamental properties of FRP (denotative and continuous) to get lost.
23:47:03 <bitemyapp> @ty T.traverse
23:47:04 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:47:14 <moop> neuroserpens: actually the real joke ends with 'because 7 8 9'
23:47:20 <solatis> conal: yeah, maybe you should rename it to TFRP (True) :)
23:47:22 <bitemyapp> There are no specific data types here. Just reusable structure.   (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:47:23 <numberten> @ty sequence
23:47:24 <lambdabot> Monad m => [m a] -> m [a]
23:47:24 <numberten> works too
23:47:25 <neuroserpens> moop: You lost me again.
23:47:27 <bitemyapp> That's terribly useful.
23:47:36 <bitemyapp> numberten: but undermines my point about "no specific data types"
23:47:42 <moop> neuroserpens: it's a deep mathematical joke
23:47:48 <erisco> there was once this acronym "MVC"
23:47:57 <numberten> ah
23:47:58 <solatis> erisco: oh, i know that one!
23:47:59 <numberten> something fully generic
23:48:00 <neuroserpens> LoL... I'm off to check bitemyapp and frawgie_ 's recommendations... You're lameh moop D:<
23:48:03 <solatis> RoR does it, right?!?!
23:48:16 <dibblego> neuroserpens: there is an IRC channel for the NICTA course if you choose to use that.
23:48:16 <SharpGAF> solatis: Now who's trolling :P
23:48:29 <solatis> haha i'm being obviously sarcastic :p
23:48:31 <bitemyapp> neuroserpens: #nicta-course
23:48:37 <bitemyapp> neuroserpens: nice people there as well.
23:48:46 <benzrf> conal: what about netwire
23:48:57 <EvanR> i noticed earlier you cant seem to write any "fully generic" comonad code that doesnt just do fmapping. so being able to write "fully generic" code against a class apparently isnt the whole point all the time
23:49:08 <neuroserpens> dibblego bitemyapp Nice. I'll check it out and if I like it I'll join it too.
23:49:22 <erisco> I think for a year end present conal should do a roundup of the top 10 FRP libraries  ;)
23:49:26 <neuroserpens> I'll finish reading lyah and rwh anyway too though
23:49:26 <conal> benzrf: i haven't looked at it much. do you know its status on my two fundamental properties of FRP?
23:49:39 <benzrf> conal: well, it supports continuity
23:49:44 <benzrf> conal: not sure how denotative it is though
23:49:58 <EvanR> i thought netwire was more about discrete steps
23:50:07 <benzrf> it is?
23:50:24 <EvanR> thats what i remember from irc at least
23:50:26 <benzrf> huhh
23:50:30 <benzrf> i gott sleep -_-
23:50:32 <benzrf> later
23:50:43 <circ-user-Ik9bS> wikipedia not very helpful here. They state the obvious and do as if it were something new. (higher kinds)
23:50:46 <solatis> conal: maybe you should open a bug report at Elm and provoke some discussion. :)
23:50:56 <EvanR> dont read wikipedia about haskell too much
23:51:02 <solatis> "please implement FRP correctly"
23:51:07 <bitemyapp> solatis: he's already talked to the creator of Elm.
23:51:16 <solatis> bitemyapp: let me guess, they don't care ?
23:51:22 <bitemyapp> solatis: he's had people bang his gong about this before.
23:51:24 <solatis> (or rather, "agree to disagree" ?)
23:51:34 <bitemyapp> solatis: I'm not going to say anything. I'd rather use GHCJS.
23:51:35 <dibblego> circ-user-Ik9bS: here is some C#, what is the type of expression? (f, a, b) => from aa in a; bb in b select f(aa, bb)
23:51:38 <bitemyapp> and pick my own abstractions.
23:51:40 <erisco> I used netwire for a bit, not long, and iirc it was oriented around discrete timesteps
23:51:50 <SharpGAF> circ-user-Ik9bS: Higher kinded polymorphism isn't actually all that complicated, I'd be surprised if you've been using F# for a long time and never wanted it
23:51:57 <SharpGAF> Maybe you didn't know it was what you wanted.
23:52:07 <circ-user-Ik9bS> template < typename X, typename Y > class Foo { public: void Combine( X x, Y y) {}  }; <<-- Higher kind. Constructed a new type from several types.
23:52:28 <dibblego> circ-user-Ik9bS: that is not higher kinds
23:52:31 <erisco> the idea of netwire is that you have a real time clock tick (from what I saw)
23:53:08 <circ-user-Ik9bS> then explainw hat you understand under "higher kinds" please
23:53:18 <EvanR> circ-user-Ik9bS: do you want to learn about haskell ?
23:53:23 <bitemyapp> circ-user-Ik9bS: "what you understand" as if he's the one that's crazy.
23:53:36 <bitemyapp> sorry, that was inappropriate. Let me reword crazy -> unreasonable/wrong
23:53:36 <EvanR> im only marginally interested in learning about f#
23:53:51 <dibblego> circ-user-Ik9bS: the question above
23:53:59 <bitemyapp> EvanR: occasionally I wonder what something would look like with modules, implement it in OCaml, laugh and go back to what I was doing.
23:54:00 <erisco> circ-user-Ik9bS, C++ is a bit painful to demonstrate higher kinded types in
23:54:23 <circ-user-Ik9bS> then state a practical example in words. That usually helps
23:54:26 <erisco> sorry, higher kinded polymorphism particularly
23:54:40 <conal> evan and i have talked. he started Elm with a much looser idea of what FRP was than my original semantic specification. he likes the looseness with which he and some others use the term. i wish he'd stop using "FRP" for Elm, but i don't think that's going to happen.
23:56:19 <EvanR> conal: what are you working on these days? that blog seems to be getting vintagey at this point
23:56:20 <conal> i'm not attached to the name "FRP". indeed, i find it misleading. what concerns me is helping people understand the fundamental differences between the original FRP and these follow-ons.
23:56:37 <EvanR> at least on frp
23:56:48 <conal> EvanR: yeah, it does. i have some nifty blog topics lined up but not quite ready to push out.
23:57:03 <bitemyapp> conal: I find your posts tend to age well anyway.
23:57:11 <conal> EvanR: i'm working on compiling haskell to dynamically reconfigurable hardware (similar to FPGAs).
23:57:22 <bitemyapp> conal: you have a knack for talking about things in FP which don't lose relevance very quickly.
23:57:53 <erisco> you just need to campaign conal, it is a marketing battle now. print off some t-shirts with "I like my FRP denotational and continuous"
23:57:58 <conal> bitemyapp: :)
23:58:12 <EvanR> like i like my women
23:58:18 <conal> :)
23:58:22 <earthy> *grin*
23:58:37 <bitemyapp> I wonder if it would be any harder to write something like a game with a continuous time model?
23:58:51 <EvanR> i dont think so
23:58:59 <bitemyapp> all the assumptions game developers operate on are built on soft real-time and discrete time windows.
23:59:24 <EvanR> they are operating on a ridiculously low level usually
23:59:25 <erisco> not quite
23:59:33 <conal> bitemyapp: at least the physics (or pseudo-physics) would be much more natural to express with continuous time--and can optimize better.
23:59:42 <bitemyapp> conal: that's definitely intriguing.
23:59:55 <erisco> some collision detection uses continuous solvers
