00:00:09 <bitemyapp> conal: a lot of physics engine bugs are due to finicky discretization
00:00:19 <erisco> that is all I can think of that is significant
00:00:20 <conal> erisco: i think collision detection must be done continuously in order not to miss collisions.
00:00:39 <bitemyapp> sometimes also floating point arithmetic gone awry :)
00:00:45 <EvanR> does interval analysis still apply?
00:00:54 <moop> neuroserpens: 6 is afraid of 7 because 7 eight 9
00:01:11 <conal> bitemyapp: yep. discretization is tricky. so it's more worthwhile to do it right once in the library, rather than badly in each application.
00:01:31 <conal> bitemyapp: which discrete-time systems like Elm end up doing.
00:01:51 <bitemyapp> conal: it particularly plagues more modern indie games where they're relying on physics to act as a core game mechanic rather than a visual flourish.
00:01:51 <erisco> conal, they play with other factors to abate that problem, such as setting a maximum speed and a minimum body size
00:01:52 <conal> bitemyapp: see remarks at https://github.com/conal/talk-2014-bayhac-denotational-design#why-continuous-time-matters
00:02:21 <bitemyapp> conal: I was at your workshop at LambdaJam, though I don't think I saw your BayHac presentation, I was there too in 2014.
00:02:41 <joneshf-laptop> whoa
00:02:45 <joneshf-laptop> bitemyapp, is here
00:02:50 * joneshf-laptop waves
00:03:02 <bitemyapp> conal: your workshop was the first time I'd given denotation and continuity any real thought. Thanks for that.
00:03:03 <conal> bitemyapp: ah yes. then you saw some of the arguments for continuous space and time.
00:03:05 <bitemyapp> joneshf-laptop: hi
00:03:06 <dhrosa> why is there both lift and liftIO?
00:03:10 <conal> bitemyapp: :) !
00:03:12 <bitemyapp> conal: yeah, I found them very interesting.
00:03:17 <Zemyla> @pl \(a, b) -> (length a, b)
00:03:18 <lambdabot> first length
00:03:26 <Zemyla> :t first
00:03:27 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
00:03:50 <EvanR> pl does arrows now
00:04:05 <Zemyla> @pl \(a, b) -> (a, length b)
00:04:05 <lambdabot> second length
00:04:17 <Zemyla> :t second
00:04:18 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
00:04:39 <conal> i wonder whether programmers have a harder time with the idea of continuous time (real-valued t) than continuous space (real-valued x,y).
00:05:01 <conal> even lazy functional programmers, who already manipulate infinite structures.
00:05:06 <bitemyapp> conal: it's possible spatial metaphors are easier to build intuitions for.
00:05:18 <bitemyapp> spatial models
00:05:44 <conal> bitemyapp: perhaps. and maybe experience also, as we've been using vector graphics for a while (outline fonts etc)
00:06:02 <bitemyapp> conal: non-scalable graphics on the desktop are a long-time peeve of mine.
00:06:33 <conal> bitemyapp: as temporally non-scalable behavior is a peeve of mine.
00:06:45 <conal> bitemyapp: (and graphics as well)
00:06:59 <erisco> continuity is nice until you have to approximate it with floating point numbers
00:07:06 <EvanR> even though arbitrary functions over the reals makes my head hurt, im completely on board with continuous time semantics. its just far enough out there to confuse enough people to entertain me
00:07:13 <bitemyapp> erisco: stay close to zero :)
00:07:37 <EvanR> not too close
00:07:38 <bitemyapp> could just not use floats.
00:07:55 <conal> erisco: indeed. floating point is generally problematic.
00:08:00 <SharpGAF> bitemyapp: That can mean sacrificing a lot of performance, at least in a game context.
00:08:28 <EvanR> conal will not accept that! performance is just an excuse!
00:08:29 <bitemyapp> SharpGAF: I don't think they're strictly needed outside of OpenGL.
00:08:43 <EvanR> we need a warp-drive like advance in arithmetic
00:08:44 <conal> erisco: at least with a continuous model of space and/or time, one can clearly express the question of how accurate the implementation is.
00:08:50 <bitemyapp> graphics are usually less finicky about float behavior than physics.
00:09:06 <SharpGAF> True.
00:09:09 <bitemyapp> and it's more mandatory in the case of graphics.
00:09:21 <bitemyapp> physics / game engine? You don't *really* need to be using floats unless you're using somebody else's kit.
00:09:34 <conal> i do hope we make progress away from badly-composing types like Double to nicely-composing exact real numbers.
00:10:10 <SharpGAF> And sure, performance is always an excuse for doing the wrong thing, you can say the same thing about denormalizing databases for that matter.
00:10:17 <EvanR> ive seen so many crazy things in this channel, i dont doubt something like that is possible
00:10:28 <bitemyapp> SharpGAF: I've seen people denorm a database before even trying to see if adding an index would help.
00:10:31 <neuroserpens> moop: It's even lamer now that I got it D:<
00:10:35 <neuroserpens> lol
00:10:39 <SharpGAF> bitemyapp: That makes me sad.
00:10:41 <conal> i'm hoping that dynamically reconfigurable hardware will make exact real computation more efficient than floating point.
00:11:06 <erisco> I haven't got a clue, but it would be great if creating a float is just an end step to peering into the continuous system (i.e. internally no such approximation is necessary)
00:11:11 <bitemyapp> SharpGAF: my career was very sad until a week and a half ago.
00:11:11 <ddellacosta> I'm trying to do some FFI stuff and I'm feeling a bit confused about how to wrap a struct in a pointer (Ptr).  I keep getting "Not in scope: data constructor ‘Ptr’" even though I'm importing Foreign.Ptr, and calling nullPtr (for example) elsewhere.
00:11:28 <erisco> in the same way you sample a finite portion of an infinite structure, in the end
00:11:33 <SharpGAF> Haha, congratulations on whatever the change was then!
00:11:51 <bitemyapp> SharpGAF: Using Haskell and working with cool people.
00:11:57 <conal> about performance of exact real computation, not that lazy functional programming was prohibitively slow for a good while. we're good at this stuff.
00:12:09 <wei2912> bitemyapp: that's great to hear :)
00:12:15 <bitemyapp> wei2912: thank you :)
00:12:31 <bitemyapp> wei2912: I'm independent now, but the client is an old friend and their code I'm porting isn't bad at all.
00:12:52 <EvanR> conal: do you know any references for this topic?
00:13:18 <conal> EvanR: probably no more helpful than googling "exact real computation"
00:13:27 <trap_exit> is there a way to do macros in haskell without using template haskell ?
00:13:30 <trap_exit> is there a way to do macros in haskell without using template haskell ?
00:13:32 <erisco> the research boonies
00:13:35 <ddellacosta> any pointers on what I may be doing wrong w/Ptr?
00:13:52 <alpounet> bitemyapp: ha, good news :)
00:13:59 <bitemyapp> alpounet: I'm certainly happy.
00:14:29 <bitemyapp> ddellacosta: all I can offer is an FFI tutorial to steal ideas from.
00:15:46 <dhrosa> ddellacosta: http://hackage.haskell.org/package/base-4.7.0.2/docs/Foreign-Ptr.html ?
00:15:50 <trap_exit> erisco: ?
00:15:54 <dhrosa> oh nvm
00:15:59 <dhrosa> you're importing Foreign.Ptr
00:15:59 <ddellacosta> dhrosa: yeah, that's what I'm using
00:16:00 <conal> bed time for me. later, haskellers!
00:16:03 <dhrosa> I thought you weren't
00:16:05 <ddellacosta> 'night
00:16:16 <bitemyapp> dhrosa: could you tell ddellacosta I've got an FFI tutorial I could link him to?
00:16:24 <bitemyapp> I think he has me blocked.
00:16:33 <bitemyapp> https://github.com/ifesdjeen/haskell-ffi-tutorial
00:16:47 <bitemyapp> with that, I'm off to bed. g'night y'all :)
00:17:31 <erisco> trap_exit, ? ?
00:17:47 <trap_exit> erisco: ? ? ?
00:17:55 <MP2E> lol
00:17:56 <erisco> you ?'d me first
00:18:07 <trap_exit> is there a way to do macros in haskell without using template haskell ?
00:18:21 <trap_exit> erisco: you responded with "the research boonies"
00:18:26 <trap_exit> to my question ;f:
00:18:29 <trap_exit> is there a way to do macros in haskell without using template haskell ?
00:19:05 <erisco> no I did not intend that as a response to your question, but my response would be "I have not heard of one"
00:20:04 <taksuyu> Wouldn't that be a typeclass? It's sorta like a macro..
00:20:23 <erisco> polymorphism is like a macro too
00:20:31 <dhrosa> trap_exit: what are you trying to do
00:20:45 <trap_exit> I want type checked macros
00:20:55 <trap_exit> not this TH black magic of compile, run , compile
00:22:03 <erisco> maybe an example of a macro you want would help, because I am not seeing how TH is not sufficiently type checked
00:27:19 <erisco> trap_exit, run this over your source files before compilation https://hackage.haskell.org/package/cpphs
00:27:41 <trap_exit> actually
00:27:50 <trap_exit> I was about to complain ... but I want ot be able to write my macros in haskell
00:27:55 <trap_exit> and then, I have just re-invented templat ehaskell
00:27:55 <trap_exit> fuck
00:28:22 <erisco> well it is a brilliant idea, so points for that
00:29:14 <erisco> maybe you can do more with type level programming than you think, though
00:29:34 <erisco> i.e. you might not really need macros in that sense at all
00:31:22 <trap_exit> no no, I wnat to create data types on the fly
00:31:24 <trap_exit> I need macros
00:31:46 <erisco> I am going to throw out there that code gen can be an ugly solution
00:32:51 <trap_exit> consider the join / union / projection oeprators of SQL
00:32:57 <trap_exit> one needs ot "define new types on the fly"
00:33:04 <erisco> what new types, exactly?
00:33:08 <trap_exit> err, consider _TYPED SQL OPS_
00:33:09 <trap_exit> this rquires black magic
00:33:26 <erisco> never heard of that
00:33:37 <trap_exit> data Student = (Name :: String, Age :: Int, Gender :: Bool)
00:33:41 <trap_exit> data class = .....
00:33:49 <trap_exit> then if you do a join, you need to invent a new data type
00:33:58 <trap_exit> join on types creates tables with new rows
00:34:09 <SharpGAF> That sounds vaguely like row polymorphism.
00:34:12 <trap_exit> which basically requires a new datattype if each row = a databatyepe
00:34:23 <trap_exit> sorry, 'join creates new cols', not rows
00:34:24 <erisco> trap_exit, you just need to append the tuples, no big deal
00:34:35 <trap_exit> erisco: you also nee d awya to tag the tuples
00:34:48 <erisco> you do?
00:34:54 <trap_exit> you need to track which elem of the tuple of the Name
00:34:59 <trap_exit> yeah
00:35:13 <SharpGAF> erisco: Technically yes, at least in the "real" relational model.
00:35:45 <solatis> erisco: there are always situations where macros / preprocessors are justified
00:36:27 <erisco> so how about  (StudentName, StudentAge, StudentGender)  where newtype StudentName = StudentName String  and so on
00:36:57 <trap_exit> the point is that when you do a join, and you create a new tuple
00:37:04 <trap_exit> you need to track "which elem is StudentAge" ?
00:37:12 <erisco> that is not a big deal
00:37:39 <trap_exit> i.e. suppose table A = [ (X, Y) ], table B = [ (X, Z) ], and you join A, B on X, you get new table = [ (X, Y, Z) ]
00:37:45 <trap_exit> this is a huge deal
00:37:54 <erisco> there is no tracking any more than tracking which element is 3 in [1,2,3,4,5]
00:38:29 <trap_exit> no, 3 is a value
00:38:29 <trap_exit> X is a TYPE
00:38:29 <erisco> well it is important, I am saying you can do this at the type level
00:38:39 <erisco> yup that is fine
00:38:41 <trap_exit> you need to track "which eleme of this TUPLE has type X"
00:38:53 <trap_exit> erisco: you are either brilliant or not understanding the problem
00:38:55 <erisco> well, wording aside, yes, you can do this
00:39:01 <trap_exit> I am either rational or not seeing your brilliance
00:39:16 <erisco> no I have just fallen down the right rabbit hole to understand your problem
00:39:23 <trap_exit> erisco: write me a typeD SQL DSL with join + projection, and I belive you
00:39:30 <erisco> I am working on one, sort of
00:39:34 <erisco> coincidence really
00:39:38 <trap_exit> well, bring up the carrot for all to see
00:39:41 <EvanR> if you are changing your schema so much, go with (E, A, V) tuples and have your schema be a dynamic layer on top of that
00:39:55 <trap_exit> alright, we'll call this delayed crhistmas gift
00:39:56 <trap_exit> you're like 4 days late
00:39:58 <SharpGAF> EvanR: (E,A,V) is kind of fundamentally opposed to the relational model.
00:40:06 <trap_exit> EvanR: what's E, A, V ?
00:40:33 <SharpGAF> Essentially, it's dynamic typing in SQL.
00:40:34 <erisco> but that is beside the point. I can dig up my rudimentary definition for tuple concatenation for you or you can take a looksie at type level programming yourself since you'll have to eventually anyways
00:40:44 <EvanR> relations can be implemented on top of this
00:41:06 <SharpGAF> They can't be type checked at the database level, you can't create proper foreign key relationships for example.
00:41:21 <trap_exit> SharpGAF: can you jump in on waht erisoc is saying
00:41:31 <trap_exit> SharpGAF: you seem to undertsand my problem -- can you analyze erisco 's solution ?
00:41:40 <EvanR> they can be typed checked, you cant enforce any relationships without extra stuff
00:41:43 <SharpGAF> I don't know what erisco is planning
00:41:47 <EvanR> SharpGAF: i wasnt referring to any sql database btw
00:41:52 <erisco> if you want to cut to the chase, use the singletons module
00:42:22 <trap_exit> erisco: convince SharpGA you're right, and I'll jump in
00:42:25 <erisco> if you don't want to be intimidated just play with closed type families for a bit, and GADTs, and you'll probably figure out how you can define this stuff
00:42:28 <SharpGAF> EvanR: In SQL, relationships like foreign keys *are* the types.  If you're saying there's a way to model this in Haskell, maybe.
00:42:38 <trap_exit> SharpGAF: listento what erisco is saying :-)
00:42:40 <trap_exit> erisco: go :-)
00:42:45 <EvanR> no i havent thought about how to do it in haskell
00:42:46 <erisco> um
00:43:04 <erisco> what am I supposed to demonstrate exactly? do you want me to concatenate tuples?
00:43:08 <EvanR> SharpGAF: by type checking i was thinking you were talking about not putting a VARCHAR into a INT field
00:43:29 <SharpGAF> EvanR: Nah, that's pretty rudimentary really
00:43:34 <SharpGAF> SQLite doesn't even enforce that.
00:43:38 <trap_exit> erisco: not just concat tuples, if we have (X, Y, Z) (A, X, B), it needs to outpu (X, Y, Z, A, B)
00:43:47 <trap_exit> so it's not just 'concat'; it finds what's in common, and builds on that
00:43:52 <EvanR> well you can at least have that much in sql, even though the basic type selection is really limited
00:44:03 <trap_exit> erisco: are you referring tro https://hackage.haskell.org/package/singletons ?
00:44:23 <erisco> trap_exit, well that problem is murkier only because it is not clearly defined to me. for example, what if more than one type is in common?
00:44:36 <SharpGAF> erisco: That's generally why you have attribute names.
00:44:37 <erisco> trap_exit, yes, that one
00:44:46 <EvanR> as for haskell interfacing to tuple outputs of an sql database, you can do that with type classes
00:44:52 <EvanR> i.e. its not tuples
00:44:54 <trap_exit> erisco: what SharpGAF said
00:45:15 <erisco> what was said
00:45:53 <trap_exit> 00:42] <SharpGAF> erisco: That's generally why you have attribute names.
00:46:13 <erisco> okay, well I don't know exactly what is meant by that
00:46:39 <SharpGAF> erisco: That's how you differentiate between two attribtues with the same type.
00:46:49 <erisco> but you can define a function such as  Join X (X, Y, Z) (A, X, B) = (X, Y, Z, A, B)
00:47:12 <erisco> well that is also not a huge deal
00:47:12 <trap_exit> erisco: how would you define such a function ?
00:47:34 <erisco> you can have   Property "Name" String   as a type, for example
00:47:36 <SharpGAF> erisco: I am not convinced you understand the operation trap_exit is trying for.  For starters, X, Y, and Z (and A, X, and B) are unordered.
00:47:36 <trap_exit> it would also need to work for Join X (X, Y) (A, X, B) = (X, Y, A, B)
00:47:50 <erisco> SharpGAF, yup, I understand they are unordered
00:47:59 <erisco> trap_exit, yup
00:48:08 <erisco> this is too fun
00:48:14 <erisco> like, you really don't believe me
00:48:51 <erisco> let me just say "there's an extension for that", or in this case several
00:49:29 <trap_exit> erisco: i have een searching for solution to this prob for past 2 wdeks
00:49:30 <trap_exit> I don't see how it can be done
00:49:39 <trap_exit> i don't doubt you, i just don't know how it's possible in haskell
00:49:42 <ahihi> on a tangential note, if you really need to store gender, please at least allow the option of "other" (and perhaps "prefer not to say")
00:49:50 <erisco> trap_exit, type level programming, aka meta programming, also related to dependent programming, also related to singletons
00:50:04 <trap_exit> i don't understand any of this
00:50:21 <EvanR> dont use tuples for that
00:51:02 <erisco> you should use '[]
00:51:11 <EvanR> in other news i "finally get" comonads, by getting this damn thing to follow the laws http://lpaste.net/117457
00:51:11 <trap_exit> erisco: also, is http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf as powerful as Coq? if so, why have i never heard of this? this seems a bit light for 'full dependent types
00:52:37 <erisco> trap_exit, I am still learning the extent of what singletons is, but it is not full dependent types. There are similar capabilities, however
00:52:45 <ddellacosta> So, I'm trying to get something like the unsafeToForeignPtr here: http://stackoverflow.com/a/19711488, but just for basic Storable instances.  Alternatively, I just want a way to create a freaking pointer from a Storable, and I'm completely stumped.  Help?
00:52:54 <erisco> and pragmatically you can do type level programming as you would value level
00:53:24 <erisco> so when you baffle at defining the join operations, just think about how simple it is if Int and String and (,...,) were values rather than types
00:54:22 <erisco> anywho, I can type up a simple example which defines a structure like '[] using tuples and then write the concatenation function
00:54:36 <erisco> I don't have it on this laptop so it will take me a few minutes
00:54:42 <erisco> but if that will help you get started I'd be glad to help
00:55:17 <trap_exit> erisco: I would like to see it
00:55:19 <trap_exit> just to understand what it todes
00:55:25 <trap_exit> and if we have the same problem in mind
00:55:34 <erisco> trap_exit, are you running GHC 7.8?
00:55:41 <trap_exit> yes
00:55:44 <erisco> good
00:55:50 <trap_exit> 7.8.3
01:02:39 <trap_exit> erisco : by 'few' minutes, how few is 'few' ?
01:02:51 <erisco> trap_exit, hm, maybe 5 more
01:03:16 <trap_exit> erisco: if not completed in 5 mins; I want double money back :-)
01:06:44 <erisco> it somehow got to be 4am, so my brain is doing all sorts of weird stuff
01:06:53 <erisco> anyways I eventually bumbled out this thing http://lpaste.net/117458
01:06:54 <neuroserpens> :t chain
01:06:55 <lambdabot> Not in scope: ‘chain’
01:07:03 <neuroserpens> wtf
01:07:17 <neuroserpens> Wrong xterm lmao
01:07:23 * neuroserpens needs sleep
01:07:49 <trap_exit> erisco: 1am here, let me take a look
01:07:52 <erisco> that is without most of the bells and whistles so hopefully it sparks the basic idea
01:08:25 <trap_exit> wtf, is this haskell or ascii art?
01:08:25 <erisco> if you were more serious you'd use '[] instead of the tuples, but it amounts to the same idea
01:08:36 <erisco> what is the difference lately?
01:09:22 <trap_exit> I have one more question
01:09:34 <trap_exit> erisco: can I then go on to define a function of type "A -> B -> A :++ B" ?
01:09:34 <erisco> okay
01:09:43 <erisco> sure, why not
01:10:00 <trap_exit> okay, so I lied; can you write such a function fo rme?
01:10:15 <trap_exit> I want to see how it would look in this 'type family / tye operator' world
01:10:50 <neuroserpens> Did anyone say ascii art?
01:10:54 <neuroserpens>          ,
01:10:57 <neuroserpens>         ()    /)
01:10:59 <neuroserpens> ----.---'----(  )
01:11:01 <neuroserpens>      \        \)
01:11:03 <neuroserpens>      ()
01:12:18 <dhrosa> no, they said ascii fart
01:12:33 <neuroserpens> o,0 how does that work?
01:12:34 <erisco> trap_exit, I have edited the paste
01:13:01 <moop> http://lpaste.net/117460
01:13:12 <trap_exit> erisco: ah, bhta tis for particular values of A, and B
01:13:27 <trap_exit> can we write generic A, B and a function of type "A -> B -> (A :++ B) " ?
01:13:37 <neuroserpens> moop: lol
01:13:49 <erisco> well that is at the value level which is a different story
01:13:56 <neuroserpens> moop: I want to fight skilentons.
01:14:10 <trap_exit> erisco: as in it can't be done ?
01:14:11 <erisco> to do that you'll have to have fun with type classing
01:14:14 <erisco> yes it can be done
01:14:57 <trap_exit> erisco: can you show me how to do it? :-)
01:15:20 <trap_exit> what's shown so far can be done in 'normal' haskell
01:15:27 <trap_exit> i.e. I can define example2 in normal haskell
01:19:25 <erisco> okay I have made another edit for you trap_exit http://lpaste.net/117458
01:19:58 <trap_exit> erisco: erisco is now my favorite programming language, it's English -> Haskell
01:20:43 <trap_exit> I think linew 23-24 need to be changed to make it more general
01:20:45 <erisco> trouble is that it is a lossy language
01:20:49 <trap_exit> instance Append (a, b) where
01:21:13 <trap_exit> append (a, b) c = (a, append (b, c))
01:21:22 <trap_exit> then we can get rid of 20-21
01:21:29 <pingu> trap_exit: that looks kind of what I tried to do the other day...
01:21:56 <erisco> trap_exit, see, you are figuring it out just fine
01:21:56 <trap_exit> pingu : pay erisco tuition :-)
01:22:06 <dhrosa> does anyone know why both lift and liftIO exist?
01:22:17 <trap_exit> erisco: well, I never said I'm an idiot; I just didn't know it was possible
01:22:23 <erisco> :t lift
01:22:23 <pingu> trap_exit: https://github.com/ekmett/lens/pull/508
01:22:24 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
01:22:27 <erisco> :t liftIO
01:22:27 <lambdabot> MonadIO m => IO a -> m a
01:22:27 <SharpGAF> Pretty neat.
01:22:34 <erisco> not the same types at all, that is why dhrosa
01:22:47 <pingu> trap_exit: if you look at the last few comments, you can define it in this instance in terms of the previous
01:23:08 <dhrosa> I mean, isn't liftIO a more specific case of lift?
01:23:22 <dhrosa> couldn't I lift (putStrLn "hi") into an MaybeT IO a ?
01:23:29 <trap_exit> pingu: are you the baby in the github picture? when did your parents start teaching you haskell ?
01:23:33 <dhrosa> oh wait
01:23:38 <trap_exit> were your first words english or haskell ?
01:23:42 <dhrosa> yes
01:23:50 <pingu> trap_exit: yes. -6.
01:24:27 <trap_exit> erisco: this is awesome
01:24:34 <trap_exit> erisco: thanks for helping me write this code at 4am ; much appreciated
01:24:56 <erisco> trap_exit, what you are going to find though is an overlapping instance problem if you do it that way
01:25:03 * hackagebot yarr 1.3.3 - Yet another array library  http://hackage.haskell.org/package/yarr-1.3.3 (DominicSteinitz)
01:25:20 <trap_exit> erisco: ? it's 1:30am , my brain is fried
01:25:42 <erisco> trap_exit, okay, well, first distinction to note is that classes are open
01:25:44 <moop> by popular demand i patched my skelington http://lpaste.net/117460
01:25:48 <erisco> that means that instances can be added whenever
01:25:57 <moop> feel free to copypasta
01:26:08 <erisco> which also has the effect that there is no particular order in which instances are preferred
01:26:14 <moop> GNU\Skelington
01:26:23 <trap_exit> moop: why aren't lines 18 and 19 numbered?
01:26:30 <erisco> which means that if two instances could match, it creates a conflict and GHC gives up
01:26:47 <erisco> and unfortunately  (a, b)  is a more general  (a, (b, c))  so it won't know which one to pick
01:27:10 <trap_exit> what if the only instances I have are () and (a, b) ?
01:27:27 <trap_exit> (), is like [], and (a, b) is like x:xs ... no ?
01:28:24 <trap_exit> okay; I have to sleep now
01:28:25 <trap_exit> way too tired
01:28:30 <trap_exit> erisco: thanks again for your help
01:28:33 <erisco> trap_exit, oh, well that is probably just fine
01:28:50 <erisco> there, you can take it from here
01:28:53 <erisco> you already know too much
01:29:07 <dhrosa> oh I see, liftIO basically shortcuts to the IO in your transformer stack
01:29:10 <dhrosa> lift just takes you up a level
01:29:15 <erisco> I was not thinking about the recursive nature of what you had defined
01:30:03 * hackagebot netwire 5.0.1 - Functional reactive programming library  http://hackage.haskell.org/package/netwire-5.0.1 (ErtugrulSoeylemez)
01:30:05 * hackagebot yarr 1.3.3.1 - Yet another array library  http://hackage.haskell.org/package/yarr-1.3.3.1 (DominicSteinitz)
01:30:12 <dhrosa> is there any thing you could do with the Writer monad that you couldn't do with State? or is the purpose of Writer to give you a nicer interface, because it uses a monoid's mappend?
01:30:18 <erisco> so, there we go, type list concatenation with a value level implementation with a closed type family, one type class, and two instances
01:30:30 <erisco> super simple
01:31:27 <dhrosa> also is ghc-mod fixed yet :(
01:31:48 <mm_freak_> hi there…  does hackage build the docs by itself nowadays, or do i still have to do it manually?
01:32:51 <dhrosa> It seems to do it by itself, I uploaded a package yesterday and got docs a few hours latter
01:34:30 <mm_freak_> alright, i'll wait then
01:34:31 <mm_freak_> thanks
01:39:41 <buckmaster> does anyone know if there's a haskell XML library that lets you parse directly to a custom type, like Aeson?
01:40:00 <buckmaster> from a cursory glance it seems like HXT and friends define their own XML data type then have you scrape it
01:40:03 * hackagebot base-prelude 0.1.11 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.11 (NikitaVolkov)
01:40:05 * hackagebot yarr 1.3.3.2 - Yet another array library  http://hackage.haskell.org/package/yarr-1.3.3.2 (DominicSteinitz)
01:42:10 <dhrosa> why doesn't Prelde expose <$> and <*>, but it exposes the monadic functions?
01:42:15 <dhrosa> and it exposes functor
01:47:45 <pavonia> dhrosa: Applicative was introduced after the Prelude had already been established
01:49:03 <osfameron> I wonder why it didn't get added at the "prime" revision of haskell though... is it generally problematic to add typeclass instances after the fact?
01:50:31 <dhrosa> the instances are there
01:50:39 <dhrosa> i'm complaining about it not being in prelude
01:51:30 <dhrosa> osfameron: I think all of the monads in base have an applicative instance as well. the problem with applicative is forcing an applicative constraint on monads, which might break some libraries out there
01:51:35 <dhrosa> even though it's sensible
01:55:05 <osa1> what are yellow and green lines in hpc reports?
01:55:15 <osa1> and red lines
02:02:58 <moop> :info Monad
02:03:06 <moop> D
02:03:08 <moop> D:
02:03:23 <Zemyla> Okay, why does my Haskell program have so much pinned data when I don't use the FFI at all?
02:19:19 <Darwin226> Hey guys. I'm working on a interpreter for a language and I need a mechanism for returning early. Is using EitherT for this purpose unidiomatic?
02:19:28 <Darwin226> As in, if either intended only to be used for errors?
02:19:32 <Darwin226> is*
02:20:59 <pnielsen> Darwin226: doesn't have to be, that's just the most common use case. The Left value should be your alternative value
02:21:36 <Darwin226> pnielsen: I'm worried because the words "fail" and "error" are even used in the documentation
02:22:23 <pnielsen> Darwin226: http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Either.html
02:22:44 <pnielsen> "The Either type is sometimes used to represent a value which is either correct or an error" :)
02:23:06 <Darwin226> pnielsen: I'm talking about this one https://hackage.haskell.org/package/either-3.4/docs/Control-Monad-Trans-Either.html
02:23:08 <pnielsen> it's really just something that can be either A or B. It's easier to make Right the "right" value because of the functor/applicative instances
02:24:06 <pnielsen> don't see any problem using it for something that isn't an "error"
02:25:35 <pnielsen> Darwin226: that is to say, it's just the docs for EitherT. Nothing about Either that makes it have to apply to errors
02:26:29 <Darwin226> pnielsen: Ok then. I know using exceptions in imperative languages would be a big no-no for this.
02:28:52 <pnielsen> Darwin226: what is it you're returning early?
02:29:35 <pavonia> Perhaps ContT is more idiomatic for complex control structures
02:36:22 <Darwin226> pnielsen: It's an interpreter for an imperative language so it's just normal returns
02:36:45 <Darwin226> pavonia: Well, continuations seem to bring a lot of overhead with them
02:38:46 <mmmm> I think the semantics will be different if you use Either instead of Cont?
02:39:06 <mmmm> something about state rolling back, trying to remember my class about this
02:40:06 * hackagebot type-aligned 0.9.4 - Various type-aligned sequence data structures.  http://hackage.haskell.org/package/type-aligned-0.9.4 (AtzeVanDerPloeg)
02:48:00 <moop> do i have to add `deriving` to a type before i can make an instance of it? for example, do i need to specify that my data is deriving from Eq before i can make it an instance of Eq and define behaviour?
02:48:28 <dhrosa> moop: no, deriving is if you DON'T want to make your own instance
02:48:35 <moop> oh
02:48:38 <dhrosa> moop: if you want to write your own instance, don't use deriving
02:48:47 <moop> what happens if i do both?
02:48:48 <dhrosa> deriving makes the compiler automatically generate the instance for you
02:49:01 <pnielsen> you can't, it's meaningless
02:49:03 <dhrosa> moop: no idea, try it :p. probably a compiler error of multiple instances or something
02:49:13 <pnielsen> deriving just spits out code that contains an instance for Eq
02:49:17 <moop> i'm scared
02:49:28 <dhrosa> moop: why?
02:55:10 <moop> oh, it just gives     Duplicate instance declarations:
02:55:17 <moop> duplicate instance errors
02:55:35 <dhrosa> reasonable enough
02:55:38 <moop> dhrosa: maybe that's how you open the portal to xen
02:55:57 <joneshf-laptop> pretty sure it has a cli
02:55:59 <moop> i mean, the half-life logo is lambda
02:57:00 <calvinx> does anyone know what’s the difference between cabal sandbox and hsenv (a 3rd party tool to isolate your cabal environment) ?
02:57:42 <altern> Hi. Why am I getting Not in scope: `HashMap.lookup' even though I have imported Data.HashMap
02:57:42 <altern> ?
02:58:28 <buckmaster> altern have you typed HashMap.lookup directly in your source?
02:58:31 <buckmaster> not just lookup?
02:58:56 <dhrosa> altern: I think you need to fully qualify it
02:59:02 <dhrosa> altern: Data.HashMap.lookup
02:59:43 <buckmaster> if it's imported qualified, right?
03:01:01 <dhrosa> err
03:01:13 <dhrosa> when you do "import Data.HashMap", lookup is just exposed bare
03:01:19 <dhrosa> buckmaster: just try lookup by itself
03:01:22 <altern> dhrosa, I am getting another error then:     Couldn't match type `Data.HashMap.Strict.HashMap T.Text JSON.Value'
03:01:22 <altern>                   with `Data.HashMap.Map k0 JSON.Value'
03:01:39 <buckmaster> dhrosa: it's altern who's asking ;P
03:01:50 <dhrosa> lol woops
03:02:36 <pavonia> altern: Show us the complete code, please
03:02:41 <buckmaster> altern: seems like the first parameter is ambiguous?
03:02:51 <buckmaster> or incorrect type for the map?
03:03:52 <altern> pavonia, here it is : http://lpaste.net/117463
03:04:22 <pnielsen> altern: that's Data.HashMap from unordered-containers, not the regular Data.HashMap
03:04:24 <pnielsen> altern: https://hackage.haskell.org/package/unordered-containers-0.2.5.1
03:05:25 <pnielsen> Data.HashMap.Strict (unordered-containers) is wholly different from Data.HashMap (hashmap)
03:06:20 <altern> pnielsen, how should I specify Data.HashMap package directly then?
03:07:11 <pavonia> aeson uses Data.HashMap.Strict.HashMap
03:08:36 <pnielsen> altern: You probably want to add unordered-containers to your cabal config and import Data.HashMap.Strict instead, and stop using Data.HashMap completely
03:09:11 <pnielsen> calvinx: hsenv existed before cabal got the sandbox feature
03:09:28 <dhrosa> cabal sandbox is relatively new, I think since 1.18
03:09:33 <dhrosa> like, a few months ago
03:09:45 <pnielsen> yep
03:11:50 <altern> pnielsen, I am confused now. should I use unordered-containers instead of Data.HashMap?
03:11:58 <pnielsen> altern: yes
03:12:18 <bonobo123> hi, are there any MonadBaseControl specialists here?
03:12:23 <pnielsen> unordered-containers contains the module Data.HashMap.Strict (completely different from Data.HashMap)
03:12:38 <bonobo123> I could use some help trying ot implement lifted version of  Control.Concurrent.Thread.Group
03:13:39 <altern> pnielsen, is it possible to do it without cabal configuration?
03:15:01 <pnielsen> altern: yes, but is pretty painful. cabal will make your life much easier in the long run
03:15:34 <dhrosa> hmm, how does ghc handle conflicting modues like that
03:15:49 <pnielsen> ghc doesn't care
03:16:12 <pavonia> There's an extension to add the package name before a module import
03:17:51 <pnielsen> dhrosa: if two packages exported modules with the same name, and you included them both, you might get into trouble
03:17:53 <pnielsen> never actually tried that
03:19:08 <dhrosa> pnielsen: how yould you indiciate that you want this packages' module and not the other?
03:19:30 <pnielsen> dhrosa: cabal config
03:19:33 <dhrosa> ah
03:19:39 <dhrosa> what if you had a bare haskell file?
03:20:06 <pnielsen> as long as you include unordered-containers in the build and not hashmap it should be fine
03:20:45 <pnielsen> but for this particular example it doesn't matter anyway since it's Data.HashMap vs. Data.HashMap.Strict, not 2x Data.HashMap
03:21:54 <calvinx> ok, so it’s better to use cabal sandbox.
03:23:15 <calvinx> thanks pnielsen, dhrosa
03:25:52 <dhrosa> http://lpaste.net/1844224537034489856 <-- is there a way to make line 7 look like lines 8 and 9, using some other applicative function?
03:26:13 <dhrosa> Train takes no arguments, but Echo and Imitate take a string
03:26:35 <luis1> ,qc
03:26:50 <luis1> sorry ^
03:28:18 <pavonia> dhrosa: Train <$ string "train"
03:29:32 <dhrosa> pavonia: aha, thanks!... also now I feel stupid, I could have just looked at Control.Applicative's docs
03:29:35 <dhrosa> I'm tired
03:35:22 <matematikaadit> I <*> Applicative
03:35:34 <moop> oh, man, i love ghc-mod
03:35:43 <dhrosa> moop: I just started using ghc-mod myself today
03:35:44 <osa1> any ideas how is coverage checking on inlined functions working?
03:35:54 <dhrosa> I've used haskell-mode for months, but nt with ghc-mod
03:36:47 <moop> https://github.com/eagletmt/neco-ghc + haskell = top sex
03:43:02 <dhrosa> anyone know hwo to make lamdabot evaluate stuff from the command line?
03:43:16 <adas> say there was a func "fn :: (Fractional b, Num a) => b -> a" and a func "fn' :: (Integral a) => a -> Int" .. would this type check "fn' (fn 3.14)"?
03:43:17 <dhrosa> I have a local installation of lambdabot
03:43:58 <dhrosa> 3.14 is not an integral?
03:44:26 <adas> dhrosa: yup is not
03:44:31 <adas> is not integral
03:44:49 <adas> fn takes a fractional
03:45:08 <moop> dhrosa: what's the diifference between lambdabot and ghci tho?
03:45:18 <dhrosa> entirely different things
03:45:24 <moop> pretty much the same
03:45:36 <dhrosa> lamdabot is a chat bot, that does more than what ghci does, and is less interactive
03:45:50 <Haskellfant> adas: should typecheck
03:45:59 <mmmm> Anyone know any good pprinting and casting libraries? ie a prettier version of Read and Show
03:46:00 <adas> moop: GHCi - GHC REPL. lambdabot - IRC bot
03:46:06 <dhrosa> oh there's an fn and fn', I didnn't notice
03:46:19 <dhrosa> mmmm: well for Read you probably want Parsec or Attoparsec
03:47:38 <adas> Haskellfant: but wouldn't that be wrong? what if fn returns a float or double?
03:48:55 <dhrosa> > fn :: (Fractional b, Num a) => b -> a; fn _ = 0; fn' :: (Integral a) => a -> Int; fn' _ = 0; fn' (fn 3.14)
03:48:56 <lambdabot>  <hint>:1:38: parse error on input ‘;’
03:49:10 <dhrosa> > let fn :: (Fractional b, Num a) => b -> a; fn _ = 0; fn' :: (Integral a) => a -> Int; fn' _ = 0 in fn' (fn 3.14)
03:49:11 <lambdabot>  0
03:50:24 <dhrosa> weird
03:50:29 <dhrosa> what type magic is going on here
03:51:03 <adas> is it correct that it typechecked or was it not supposed to have type checked?
03:51:09 <dhrosa> i'm not sure
03:51:49 <crufter> if anyone is interested in a Go article which compares Go to more ML like languages here is one https://news.ycombinator.com/item?id=8814202
03:51:59 <crufter> (sorry if considered spam)
03:52:15 <buckmaster> thanks crufter :)
03:52:50 <crufter> buckmaster: you are welcome :)
03:53:11 <dhrosa> > let fn :: (Fractional b, Num a) => b -> a; fn _ = 0; fn' :: (Integral a) => a -> Int; fn' _ = 0 in fn' (fn (3.14 :: Integer))
03:53:12 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
03:53:13 <lambdabot>    arising from a use of ‘fn’
03:53:33 <dhrosa> yeah I'm not sure how that's type-checking
03:54:38 <adas> can someone enlighten us?
03:54:55 <dhrosa> yeah I'd love to know what's going on here
03:55:45 <dhrosa> > let fn :: (Fractional b, Num a) => b -> a; fn _ = 0.2; fn' :: (Integral a) => a -> Int; fn' _ = 0.1 in fn' (fn 3.14)
03:55:46 <lambdabot>  Could not deduce (GHC.Real.Fractional GHC.Types.Int)
03:55:46 <lambdabot>    arising from the literal ‘0.1’
03:55:46 <lambdabot>  from the context (GHC.Real.Integral a)
03:55:56 <dhrosa> well there's some more information
03:56:10 <dhrosa> it's the fact that I used 0 as the return value that led to different type inference
03:56:15 <Haskellfant> adas: afaik if you return Num a => a the caller can decide on the type of the num which basically means that it needs to be some sort of Integer, if you return a fractional you need to add Fractional a to the type signature
03:56:20 <Haskellfant> but maybe I'm just too tired
03:57:07 <Haskellfant> that's why let fn :: Num a => b -> a; fn _ = 1.1; does not typecheck
03:57:35 <dhrosa> so because you didn't explicitly specify the type of the inner fn call, the compiler infered a integral type that would work
03:57:51 <dhrosa> but when I returned 0.1 instead, now the compiler can no longer choose an integral type as the return of that call of fn
03:58:28 <dhrosa> > let fn :: (Fractional b, Num a) => b -> a; fn _ = 0; fn' :: (Integral a) => a -> Int; fn' _ = 0 in fn' ((fn 3.14) :: Float)
03:58:30 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Float)
03:58:30 <lambdabot>    arising from a use of ‘fn'’
03:58:37 <dhrosa> yes, it seems I'm right
03:59:01 <lpaste> EvilTerran pasted “"cabal install alex happy" failure” at http://lpaste.net/117466
03:59:07 <EvilTerran> ^ my "cabal install" is having a tantrum, when it was working fine a couple of days ago :(
03:59:16 <adas> so when returning '0' it could choose any of the types in Num..
03:59:30 <adas> but in 0.1 it could choose only type from Fractional ..?
03:59:40 <adas> so the more generic Num in the type signature is invalid..
03:59:46 <adas> and thats why the error?
03:59:58 <Haskellfant> adas: if you have a general type signature it's up to the caller so fn' to decide which concrete type to use, so fn has to return something that can be treated as any instance of Num which includes Int
04:00:09 * hackagebot xml-extractors 0.3.0.0 - Wrapper over xml to extract data from parsed xml  http://hackage.haskell.org/package/xml-extractors-0.3.0.0 (holmisen)
04:00:33 <dhrosa> any integer literal can be converted to any type of NUm
04:00:39 <dhrosa> thanks to the fromIntegral function Num defineds
04:01:23 <EvilTerran> it looks like it's not even trying to install QuickCheck and MTL, then complaining when they aren't there
04:01:24 <Haskellfant> well that's not really the point here. in this case you have a Num and need an Integral not the other way around
04:01:28 <EvilTerran> why would it do that?
04:01:38 <Haskellfant> also the function is named fromInteger
04:03:10 <fread2282> is there a shorter way to write ((foo :: Maybe Int) >>= \a -> if a /= i them Just a else Nothing)   ?
04:03:48 <dhrosa> sounds like filterM almost
04:03:51 <dhrosa> :t filterM
04:03:51 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
04:04:00 <dhrosa> err
04:04:02 <dhrosa> not quite
04:05:09 * hackagebot sequence 0.9.0 - A type class for sequences and various sequence data structures.  http://hackage.haskell.org/package/sequence-0.9.0 (AtzeVanDerPloeg)
04:05:11 * hackagebot Spock-worker 0.2.1.3 - Background workers for Spock  http://hackage.haskell.org/package/Spock-worker-0.2.1.3 (AlexanderThiemann)
04:05:13 * hackagebot sequence 0.9.1 - A type class for sequences and various sequence data structures.  http://hackage.haskell.org/package/sequence-0.9.1 (AtzeVanDerPloeg)
04:05:18 <osa1> I'm generating a GET request URL and all I want to send that and read results. I'm trying to use HTTP library but it fails with an exception even though the URL is correct. (e.g. it works in command line)
04:05:28 <osa1> any ideas what might be going wrong?
04:05:34 <dhrosa> well whats the error
04:05:42 <osa1> "IOException of type NoSuchThing"
04:05:50 <dhrosa> paste code too?
04:05:52 <osa1> as usual a non-helpful error message
04:06:20 <gregnwosu> trying to use c2hs to link into a library that i have compiled
04:06:21 <osa1> dhrosa: https://github.com/osa1/rho-torrent/blob/master/src/Rho/TrackerComms/HTTP.hs#L30
04:06:35 <gregnwosu> think i may just lpaste my problem
04:08:21 <Fuuzetsu> o
04:08:53 <lpaste> gregnwosu pasted “ffi annoyance” at http://lpaste.net/117467
04:08:56 <EvilTerran> fread2282, (\a -> if p a then Just a else Nothing) can be written (\a -> guard (p a) >> return a), if that helps
04:10:09 * hackagebot reflection-without-remorse 0.9.5 - Efficient free and operational monads.  http://hackage.haskell.org/package/reflection-without-remorse-0.9.5 (AtzeVanDerPloeg)
04:10:40 <lpaste> gregnwosu revised “ffi annoyance”: “No title” at http://lpaste.net/117467
04:11:14 <osa1> dhrosa: any ideas?
04:11:21 <dhrosa> nope
04:11:40 <osa1> ok. any HTTP alternatives that are 1) easy to use 2) stable/widely-used?
04:12:25 <slomo> osa1: http-client?
04:12:32 <Haskellfant> wreq is pretty easy too
04:12:33 <slomo> osa1: http://hackage.haskell.org/package/http-client
04:12:39 <Haskellfant> I also liked http-conduit
04:13:03 <osa1> wreq looks good, thanks
04:13:11 <osa1> I knew http-client but didn't look like very easy to use to me
04:13:28 <osa1> get :: String -> IO (Response ByteString)
04:13:30 <osa1> I need this, awesome
04:13:46 <osa1> the problem with all other libraries is that they don't provide anything near that easy to use
04:14:45 <dhrosa> I've used http-conduit, super easy, I've only used one function from it
04:15:00 <dhrosa> simpleHttp "myurl.com", gives me an IO whatever
04:15:03 <Haskellfant> my only complaint about wreq is that it takes some time to install which can get annoying if you do clean builds in docker or on travis
04:15:12 <slomo> osa1: http://hackage.haskell.org/package/http-client-0.4.6.1/docs/Network-HTTP-Client.html#v:httpLbs is similarly easy and allows you to reuse connections
04:16:22 <dhrosa> oh yeah I like http-conduit because it's generalized to MonadIO, istead of just IO
04:16:32 <dhrosa> which was great for my application using a transformer stack
04:16:39 <dhrosa> returns an m ByteString
04:19:55 <gregnwosu> anyone know why my cabal cant find my external c library?
04:20:49 <osa1> Haskellfant: I'd expect other libs to be similarly hard to install (except maybe HTTP)
04:24:30 <dhrosa> does haskell not have a built-in safe version of (!!) that returns a Maybe?
04:24:34 <dhrosa> hoogle does not seem to think so
04:26:15 <gregnwosu> .
04:26:34 <osa1> dhrosa: http://hackage.haskell.org/package/safe-0.3.8/docs/Safe.html
04:26:51 <osa1> see atMay function
04:27:23 <dhrosa> I like how the library is called safe
04:27:30 <dhrosa> and involves fromJust :p
04:29:35 <EvilTerran> dhrosa, if you don't want any extra dependencies, you could do (case drop i xs of el:_ -> ...; [] -> ...)
04:29:50 <EvilTerran> > drop 10 [1,2,3]
04:29:51 <lambdabot>  []
04:30:03 <dhrosa> oo I see
04:30:14 <dhrosa> I just ended up writing a recursive !? operator in three lines
04:30:31 <EvilTerran> ?type (\i -> listToMaybe . drop i) -- or this, if you really want the Maybe
04:30:31 <lambdabot> Int -> [a] -> Maybe a
04:31:43 <dhrosa> oh that's clever too
04:32:53 <dhrosa> why is IO at the bottom of a transformer stack always?
04:32:56 <jarold> is lazy IO consequence of language semantics (lazyness) or a choice made by people who wrote System.IO?
04:34:05 <delrik> dhrosa? I’ve put the identity monad at the bottom of my stacks.
04:36:11 <dhrosa> I mean, when you use IO in a stack, why is it always at the bottom
04:37:09 <EvilTerran> jarold, it's closer to the latter... it actually kinda breaks the semantics, but at the time that was considered worth it in the name of making IO simpler to use. it's been a bit of a contraversial decision since.
04:37:18 <k00mi> dhrosa: there is no IO transformer, so it can't be anywhere else
04:37:34 <dhrosa> why couldn't there be one?
04:37:57 <pavonia> Because there's no runIO
04:37:58 <jarold> EvilTerran closer but not quite? curious what semantics does it break
04:38:58 <dhrosa> oh I think I see
04:39:23 <dhrosa> the other transformers have a way to "exit" or unwrap the transformer, so to speak, in pure code?
04:39:29 <dhrosa> like runIO if it existed
04:40:00 <EvilTerran> jarold, if you do something like... do str <- readFile "foo.txt"; removeFile "foo.txt"; print (length str)
04:40:33 <jarold> yeah i experienced something similar
04:40:52 <dhrosa> how do people normally force the execution of removeFIle in that case?
04:41:05 <EvilTerran> jarold, then you'll see that the side-effect of removeFile has affected the value of "str", even though str is type String, not IO String, so it should be pure & unaffected by side-effects
04:41:11 <dhrosa> or wait, what actually happens when you run that?
04:41:27 <dhrosa> does the file get deleted before you open it, because str isn't used till after the delete?
04:41:31 <Saizan> jarold: it's completely a choice, they inserted an unsafeInterleaveIO to get the reading from the file to happen as the resulting string is evaluated
04:41:35 <jarold> I expected to get "file in use" error, but i guess that depends on OS
04:42:26 <jarold> Saizan I see
04:44:13 <EvilTerran> jarold, yeah, that's what I get too. that's odd, I could've sworn in the past I got an error at the "length str"
04:44:58 <EvilTerran> the latter's probably what happens if you're in an environment without mandatory locks
04:45:11 <Saizan> dhrosa: readFile opens it early actually
04:45:50 <dhrosa> Saizan: so what happens then?
04:46:40 <Saizan> it depends on the OS/filesystem, i'd think
04:46:41 <jarold> so without explicit call to unsafeInterleaveIO IO would be strict in haskell?
04:47:02 <jarold> (in the implementation of readFile)
04:47:11 <Saizan> jarold: the execution of side effects would be "strict", yeah
04:47:38 <dhrosa> is there a library that has all the prelude IO functions "pre-lifted", so I don't have to call liftIO everywhere?
04:47:48 <dhrosa> if not, is this something people would like? :p
04:48:34 <jarold> Saizan meaning file would be read right after the readFile call, but chars would still not be evaluated?
04:48:42 <jarold> or something.. :)
04:49:06 <clrnd> @google hackage lifted io
04:49:07 <lambdabot> https://hackage.haskell.org/package/lifted-base
04:49:33 <Saizan> jarold: in this case the chars would probably be evaluated too, but IO actions can surely return values which are not fully evaluated
04:50:48 <dhrosa> clrnd: doesn't seem to have the basic ones like putStrLn?
04:51:37 <clrnd> dhrosa, seems it doesnt, lol
04:52:10 <dhrosa> bro do you even liftIO
04:54:03 <EvilTerran> dhrosa, here's another way to think about why IO couldn't work as a transformer:
04:54:04 <EvilTerran> > runStateT (do { put "never happened"; fail "because of failure" } `mplus` return "this happened instead") "initial state" :: Maybe (String, String)
04:54:06 <lambdabot>  Just ("this happened instead","initial state")
04:54:49 <EvilTerran> ^ you see there, the "put" in the StateT didn't actually have any effect, because of a failure that happened later
04:54:51 <dhrosa> EvilTerran: i don't really understand, why not?
04:55:03 <EvilTerran> now imagine it was IOT instead of StateT, and the put was a putStr
04:57:56 <dhrosa> EvilTerran: oops I didn't read one of your messages before I said "why not"
04:58:07 <EvilTerran> no worries :)
04:59:02 <dhrosa> actually I still don't really understand, does does fail for state roll-back the change by its MonadPLus instance, or some compiler magic?
04:59:32 <EvilTerran> StateT doesn't have fail, that's Maybe's fail
05:00:24 <dhrosa> where is Maybe involved here?
05:00:50 <EvilTerran> > fail "oh noes" :: Maybe Int
05:00:51 <lambdabot>  Nothing
05:00:59 <jarold> EvilTerran just throwing it out there without ever doing anything like this.. couldn't that be the desired behavior? not printing anything if something fails
05:00:59 <moop> :t (>>)
05:01:00 <lambdabot> Monad m => m a -> m b -> m b
05:01:24 <moop> :t (>>=)
05:01:25 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:01:35 <EvilTerran> jarold, what if the fail only happened depending on the result of some earlier IO effect?
05:02:30 <EvilTerran> what would this do?  (do putStrLn "output"; s <- readLine; if s == "fail" then fail "oh no!" else return ()) :: IOT Maybe ()
05:02:59 <jarold> EvilTerran I can see that being useful.. do value <- readFromDatabase; putStrLn $ "this is value from database: " ++ value
05:03:05 <mmmm> Anyone know if PolyKinds is meant to work with pattern synonyms
05:03:45 <jarold> Evil it wouldn't print "output"?
05:04:17 <EvilTerran> jarold, but that's not consistent with the behaviour of the StateT example, that's the thing
05:04:21 <fread2282> say I have foo :: a -> b -> m c  . how can I do applicative-like lifting? (with foo :: a -> b -> c, foo <$> theA <*> theB) ?
05:05:08 <prophile> fread2282: you mean turning a -> b -> m c into m a -> m b -> m c?
05:05:24 <matematikaadit> fread2282: liftA2 foo
05:05:42 <fread2282> :t liftA2
05:05:43 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:05:46 <Iceland_jack> fread2282: You can use do-notation where the final line is 'foo :: a -> b -> m c' or you can 'join' the result of liftA2
05:05:53 <prophile> matematikaadit: liftA2 has the wrong type
05:05:55 <fread2282> prophile: yep
05:06:01 <jarold> I can see how it could be confusing.. but still helpful in some cases. actually I think I asked about something like this yesterday. maybe IO transfer is the solution :)
05:06:02 <Iceland_jack>     do a <- ma
05:06:02 <Iceland_jack>        b <- mb
05:06:02 <Iceland_jack>        foo a b
05:06:05 <EvilTerran> jarold, if you have SomethingT Maybe, then (do ...side effects in SomethingT...; fail) means the side effects don't happen; but you can't "undo" real-world side-effects
05:06:12 <prophile> fread2282: what Iceland_jack said
05:06:51 <EvilTerran> jarold, and you can't, in general, defer side-effects until you know whether the whole monadic expression succeeds or fails, because whether that happens may depend on those same side-effects
05:07:10 <jarold> Evil oh, so printing would still happen?
05:07:28 <jarold> I thought your issue was that it wouldn't, while it looked like it would
05:07:36 <fread2282> :t (\f a b -> join $ liftA2 f a b)
05:07:37 <lambdabot> (Applicative m, Monad m) => (a1 -> b -> m a) -> m a1 -> m b -> m a
05:07:43 <fread2282> Iceland_jack: ty
05:07:44 <EvilTerran> jarold, well... it's a bit of a moot point what would happen exactly, because you can't construct an IO transformer.
05:08:02 <Iceland_jack> fread2282: or: join (liftA2 foo ma mb)
05:08:16 <EvilTerran> I'm afraid your question doesn't have a meaningful answer, that's the thing
05:08:39 <jarold> ok, i didn't realize that
05:08:48 <EvilTerran> conceptually, the print shouldn't happen; in practice, there'd be no way of stopping it from happening; and that's a demonstration of why you can't have IOT.
05:09:09 <prophile> type IOT = FreeT IO
05:09:44 <prophile> not quite the same thing
05:09:59 <prophile> but has some properties you might expect from IOT
05:10:48 <prophile> and you can set liftIO = liftF
05:15:52 <fread2282> how can I debug complex parsers?
05:20:13 <dhrosa> fread2282: <?>s everywhere?
05:21:50 <fread2282> dhrosa: yep, already doing that :|
05:27:32 <fread2282> is there any performance benefit to using applicative over monad when writing parsers (in parsec, attoparsec, or trifecta)?
05:27:34 <remdezx> Hello! When using Control.Zipper how can I move to an element of a list which matches some predicate?
05:38:39 <edwardk> dhrosa: what parsing library are you using?
05:39:24 <edwardk> fread2282: very little. i've got some work on making faster applicative parsers by exploiting swierstra and duponcheel's first set work locally in the parser, but i've never made it fast enough to warrant the complexity
05:40:28 <edwardk> in theory if a parser tracked the expected number of characters consumed statically and tracked its first set then i could in f <*> g in parallel start parsing both f and g.
05:40:39 <edwardk> the trick is they need to be big enough to warrant sparking something
05:40:49 <edwardk> and i need a conservative enough estimate of the size
05:40:59 <edwardk> or i need to use something like my speculation package to make it pay out
05:41:40 <edwardk> swierstra and duponcheel only tracked what the first character that would be recognized by the parser was, and a possible epsilon value to tell you if it could accept the empty string
05:41:52 <edwardk> its possible to write faster recognizers for applicative grammars as well
05:42:02 <edwardk> because you can represent the result multiset in smaller space
05:42:33 <freeman42> EclipseFP HLint question, maybe someone can help, thank you: http://stackoverflow.com/q/27706547/750216
05:42:40 <edwardk> and right seminearring homomorphisms can be used to 'count' parses cheaper than you can produce them
06:09:49 <delrik> hi all =) I’m working on my first project euler problem: I’m failing: http://lpaste.net/8587568507401535488
06:09:57 <delrik> I can’t see what I’m missing here.
06:09:58 <pyon> "23:50 <shachaf> pyon: Did you figure out your thing?" --> Sorry, I was away. I figured it out literally 3 minutes after you went away. Thank you very much!
06:10:14 <pyon> Oh, not here.
06:15:06 <mauke> delrik: what are you trying to do?
06:15:15 * hackagebot cabal-install 1.18.0.7 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.18.0.7 (JohanTibell)
06:15:21 <delrik> find the sum of all multiples of 3 or 5 less than 1000
06:15:46 <delrik> mauke: I’m expecting sum $ (mxbn 0 3 1000) ++ (mxbn 0 5 1000)   to yield the answer, but euler says its wrong
06:16:02 <mauke> yeah, because 15
06:16:08 <mauke> you're counting it twice
06:16:26 <delrik> -_____________________________________-
06:16:30 <shachaf> pyon: Ah, great. What was missing?
06:16:30 <delrik> thanks dude!
06:16:39 <delrik> or dudette?
06:16:45 <delrik> thx!
06:16:50 <mauke> > sum [n | n <- [1 .. 1000], n `mod` 3 == 0 || n `mod` 5 == 0]
06:16:51 <lambdabot>  234168
06:17:07 <aisqwe> does anyone know how are haskell extensions implemented?
06:17:19 <prophile> presumably the people who implement them do
06:17:41 <aisqwe> how do i find out more?
06:17:44 <mauke> > sum ([0, 3 .. 1000] ++ [0, 5 .. 1000]) - sum [0, 15 .. 1000]
06:17:45 <lambdabot>  234168
06:18:04 <delrik> mauke: nice use of lc!
06:18:15 <Saizan> aisqwe: the ghc trac should have some developer guide
06:18:30 <delrik> I did the mod version my first time around, but the jumping by 5, 3 version is cool too!
06:18:50 <delrik> did you use 15 as the inc on  the second on because it is shared by both?
06:19:54 <mauke> yeah, I'm subtracting all the numbers that were counted twice
06:20:08 <mauke> i.e. all numbers divisible by both 3 and 5, which is all numbers divisible by 15
06:20:16 * hackagebot cabal-install 1.20.0.5 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.20.0.5 (JohanTibell)
06:20:54 <delrik> nice! thx again, makes total sense now.
06:20:55 <pyon> "09:10 <shachaf> pyon: Ah, great. What was missing?" --> I am sad to say this, but I could not figure it out until I looked at how the functors acted on the objects of the base category. But then I abstracted them away: Given "f : M → N" and "g : P → Q", then "f ⊗ g = fQ . Mg : M.P → N.Q = M ⊗ P → N ⊗ Q". :-)
06:21:55 <delrik> mauke: btw, my answer came out diff from yours of 234168 @ 233168
06:22:02 <pyon> shachaf: M,N,P,Q all endofunctors, of course.
06:22:36 <pyon> (or 1-endomorphisms in a bicategory, generally)
06:22:59 <mauke> delrik: oh, "below 1000". change all 1000 in my code to 999
06:23:49 <delrik> yep!
06:28:01 <aisqwe> how do i learn concepts like endomorphisms endofunctors bicategory mentioned above?
06:29:30 <ddellacosta> what package is Data.Vector.Storable part of?  I am getting exceptions when I try to import it, but I thought it was a built-in
06:29:58 <Taneb> ddellacosta, it's in vector
06:30:16 <ddellacosta> Taneb: thanks, I guess I have to install that separately, huh?  Didn't realize...
06:30:16 * hackagebot sequence 0.9.2 - A type class for sequences and various sequence data structures.  http://hackage.haskell.org/package/sequence-0.9.2 (AtzeVanDerPloeg)
06:31:32 <shachaf> pyon: Right, it's probably easier to figure it out in the general case rather than when using the same natural transformation twice.
06:40:18 <edwardk> aisqwe: those come from category theory. https://www.quora.com/What-is-the-best-textbook-for-Category-theory?share=1
06:44:30 <ddellacosta> so, what ridiculously basic thing am I not doing so that Data.Vector.Storable is not showing up in my ghci session, or when I :l my file (which imports it)?  I've run cabal install vector, checked that my .cabal file has vector >= 0.10 && <0.11 in the build-depends, run cabal install --dependencies-only (seems like I've done redundant work here actually)...help?
06:45:36 <geekosaur> are you running in a sandbox? cabal repl instead of ghci
06:47:57 <d3lxa> Question: I got a list coming from SQLite.Simple of type FromRow a => [a] and I would like to just print them, problem is that the list is of dynamic type (known only at runtime), how can I make it work? do I have to resort to dynamic casting all known types until it succeed? doc https://hackage.haskell.org/package/sqlite-simple-0.4.8.0/docs/Database-SQLite-Simple.html#v:query any help is welcome
06:49:21 <ddellacosta> geekosaur: sorry, missed your message.  Yeah, now I realize I was using ghci so I could pass in some args for FFI...probably the entire problem
06:49:40 <geekosaur> maybe use cabal exec instead. cabal exec ghci your_args_here
06:51:32 <ddellacosta> geekosaur: thanks, let me give that a shot
06:53:10 <ddellacosta> geekosaur: that was what I needed!  thanks so much
06:54:12 <phpjunkie> I got a question for php. I ran a server *apache on a linux machine totally worked with .js, .php, .css, and .html files. however when I setup the same environment in my linux machine, its not displaying the webpage properly. need help anyone? :-)
06:55:01 <mauke> phpjunkie: so it works on linux but not on linux
06:55:12 <mauke> so you decided to ask a php question in #haskell
06:55:29 <ddellacosta> mauke: I was really confused for a second, because I thought you were answering seriously
06:55:34 <phpjunkie> Sorry mauke: it works on windows but not on linux
06:55:45 <ddellacosta> phpjunkie: try #php or something
06:55:55 <mauke> or #httpd, depending on how it "doesn't work"
06:56:03 <ddellacosta> yeah, or #apache?
06:56:09 <mauke> no, that's #httpd
06:56:12 <ddellacosta> not sure which one of those exists/is most appropriate
06:56:15 <ddellacosta> oh, sorry mauke, gotcha
06:56:27 <phpjunkie> I mean it works displays the page but not the the way I want it to. I tried there but I guess everyone is on christmas break or something.
06:56:35 <ddellacosta> phpjunkie: this is #haskell
06:56:56 <phpjunkie> I thought it was a hacking channel with programmers.
06:57:04 <ddellacosta> or...is it...do we possibly...have a troll?  No, couldn't be
06:57:16 <mauke> "this ford dealership is closed so I brought my car to starbucks"
06:57:26 <ddellacosta> how do we get the mods again?  I forgot
06:57:42 <mauke> you say "bloody mary" three times
06:57:47 <ddellacosta> hahaha
06:58:09 <mauke> phpjunkie: programmers who want to discuss haskell
06:58:11 <Iceland_jack>     @where ops
06:58:20 <ddellacosta> thanks Iceland_jack, gotta write that one down
06:58:41 <phpjunkie> Just needed help thats all.
06:58:51 <phpjunkie> thought anyone had ideas.
06:58:58 <phpjunkie> but thanks anyways.
06:59:08 <mauke> yeah, try a channel that's actually about your problem
06:59:21 <Iceland_jack> phpjunkie: We have ideas related to Haskell
06:59:22 <ddellacosta> phpjunkie: don't take it the wrong way--it's just not the right topic for #haskell.  Good luck
06:59:46 <phpjunkie> So wat do u guys talk about? just curious.
07:00:11 <ddellacosta> I'll give you one guess.  Maybe two
07:00:26 <mauke> (hint: haskell)
07:01:03 <Iceland_jack> Have you looked into Haskell phpjunkie?
07:01:05 <clrnd> phpjunkie, optical stuff
07:01:13 <clrnd> lenses, prisms, etc
07:01:24 <ddellacosta> haha...now now, no need to be a smartass. ;-)
07:01:46 <ddellacosta> although I guess I'm one to talk
07:01:56 <clrnd> I've never used lenses sorry, wasnt trying to
07:02:11 <ddellacosta> no, all in good fun
07:02:27 <Iceland_jack> phpjunkie: Have a look at Learn You a Haskell, it's freely available to read online:
07:02:27 <Iceland_jack> @where lyah
07:02:27 <lambdabot> http://www.learnyouahaskell.com/
07:02:30 <ddellacosta> phpjunkie: seriously, Haskell is really a wonderful language, you should check it out
07:02:42 <phpjunkie> @Iceland_jack, I'm reading it right now. didn't know it actually exited. I'll check it out though.
07:02:42 <lambdabot> Unknown command, try @list
07:02:55 <ajcoppa> hey, if you want to recommend learning resources for haskell, please direct people to #haskell-beginners
07:03:19 <phpjunkie> Does it have extensions for web development?
07:03:25 <Iceland_jack> phpjunkie: Yes join #haskell-beginners and ask some questions if you have problems
07:03:26 <ajcoppa> we have a pretty thorough guide to help newbies. we like to recommend the (free, online) CIS194 course instead of LYAH because the exercises help a lot more than just reading a book
07:03:29 <ddellacosta> phpjunkie: most definitely
07:03:59 <phpjunkie> oh cool wat about graphics library??
07:04:22 <phpjunkie> cause thats why I used java alot.
07:05:34 <clrnd> phpjunkie, yeah it has those too, but haskell is worth learning because of the new ideas it presents
07:05:35 <Iceland_jack> phpjunkie: Those things aren't Haskell's strong suit, if you're interested in playing around with graphics right away then Elm may be of interest: http://elm-lang.org/
07:06:59 <phpjunkie> Iceland_jack:But I think I found something I might need it for graphs. That was one of the projects I was working on with node.js
07:08:11 <fread2282> phpjunkie: hsqml ( http://www.gekkou.co.uk/software/hsqml/ ) is the new and fancy graphics library if you want widgets
07:12:48 <znst> does anyone have some resources regarding haskell and security work they could share, please?
07:12:56 <phpjunkie> Alright cool guys, thanks alot I'll do more research on this over the weekend. Found new interest by accident. be back soon.
07:14:38 <fread2282> does anyone know if ansi-wl-pprint has an identity for (<$>) ?
07:17:25 <srhb> fread2282: As in, split a document in two at the first empty line from the end, or something?
07:17:58 <fread2282> srhb: huh? I want (foo <$> a) == a and (a <$> foo) == a
07:19:24 <clrnd> ??
07:19:27 <srhb> fread2282: Ah. No, because it adds always adds a line in between
07:19:27 <clrnd>  :t fmap
07:19:33 <srhb> clrnd: It's not fmap.
07:19:33 <clrnd> :t fmap
07:19:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:19:35 <fread2282> srhb: :(
07:19:40 <clrnd> oh
07:19:42 <srhb> fread2282: See <>
07:19:43 <clrnd> lol
07:19:50 <srhb> clrnd: Yeah, the name is confusing. :P
07:20:06 <fread2282> srhb: yea, but I want <$> :(
07:20:25 <srhb> fread2282: There's no unit for <$>, sorry.
07:22:16 <srhb> fread2282: pretty has some operators that are more "mathy"
07:23:04 <srhb> fread2282: https://hackage.haskell.org/package/pretty-1.1.2.0/docs/Text-PrettyPrint.html#v:-36--43--36-
07:23:09 <srhb> That might be the operator you want.
07:34:25 <EvanR-work> is there really only (at most) one way to implement comonad for a given data structure, kind of like functor?
07:37:26 <ddellacosta> why the heck did I decide to do an FFI project as my first Haskell side-project...*sigh*
07:37:32 <ddellacosta> I hate C
07:37:50 <ddellacosta> I guess I have a bad attitude
07:38:52 <srhb> ddellacosta: I found it quite enjoyable. I had started missing segfaults. :-)
07:39:24 <ddellacosta> srhb: haha...yeah, I'm just knee-deep in a lot of fiddly stuff.  I think at the end of it I'll be pretty satisfied
07:40:02 <srhb> ddellacosta: I only did a small part of XKBlib bindings, and wading through the docs was the most painful thing of the project to be honest.
07:40:19 <ddellacosta> srhb: docs for FFI or XKBlib (not familiar with it)?
07:40:28 <srhb> Once I understood the whole f(&iWillFillThisSpaceWithResults) paradigm from C, I sort of got it.
07:40:32 <srhb> ddellacosta: XKBLib
07:40:36 <ddellacosta> I have to say, the docs for FFI are not awful but they are a bit scattered, I feel
07:40:40 <ddellacosta> ah, okay
07:41:19 <srhb> I kinda felt like there was almost nothing to FFI. I mean, it has such a small footprint that you basically need to learn to use one of the hs2c things and write FFI declarations, and you're done (if you did it right)
07:42:10 <ddellacosta> srhb: yeah, I think part of the problem is that I'm still not solid on some of the Haskell stuff.  As I've been working through things I've realized that mostly I've screwed up when I haven't been 100% on the *Haskell* concepts involved, actually
07:42:22 <ddellacosta> getting pointers out of IO was hard for me at first, for example
07:42:22 <srhb> ddellacosta: Ah. :)
07:42:52 <ddellacosta> hence my complaint that I chose an FFI project for my first side project...should have gone simpler I think...haha
07:43:05 <srhb> ddellacosta: :-) Not exciting if it doesn't challenge!
07:43:34 <ddellacosta> srhb: yeah, it's a tradeoff--on the other hand, I'm really psyched about getting this working--and you're right, having a challenge is great!
07:43:42 <srhb> Cool!
07:43:46 <ddellacosta> :-)
07:43:47 <Denommus> ddellacosta: yeah, C FFI is easier on a language with C's memory model, like Rust
07:43:51 <srhb> What are you doing?
07:44:00 <ddellacosta> Denommus: ah, yeah, that makes sense
07:44:12 <EvilTerran> ugh, my inside-MSYS2 installation of Cabal has trampled all over my pre-existing windows-native installation by trying to use the same directories
07:44:12 <ddellacosta> srhb: super super basic: I'm just writing a wrapper around libao
07:44:27 <ddellacosta> srhb: http://xiph.org/ao/
07:44:31 <srhb> ddellacosta: Right, so much the same as what I did. If on a larger scale
07:44:54 <ddellacosta> srhb: I mean, I think I chose well actually because the interface is quite small, and pretty straightforward
07:44:58 <EvilTerran> why would it be wandering around in C:\Users\Me\? shouldn't it just be working inside the MSYS root directory? :C
07:45:35 <ddellacosta> srhb: the thing that will be a bigger challenge for me is to figure out how to make it appropriately Haskell-y
07:45:40 <aminem> Hi 2 all, i need paypal account, anyone could help me?
07:45:57 <srhb> ddellacosta: Probably a quite fun part once you have the actual bindings hammered out. :)
07:46:49 <ddellacosta> srhb: yeah, that part will be the real interesting part I think
07:47:05 <ddellacosta> srhb: thanks for chatting, your attitude is encouraging. :-)
07:47:12 <srhb> Sure!
07:47:15 <srhb> Have fun :)
07:47:38 <ddellacosta> alright, going to see if I can get this last bit of example code working...wish me luck!
07:47:47 <srhb> good luck ^^
07:47:47 <ddellacosta> cheers srhb
07:51:14 <kristian1> exit
07:52:12 <fread2282> srhb: is there a version of indent that starts from the start of the line?
07:52:40 <srhb> fread2282: I don't know, sorry.
07:54:24 <joe9> need some help with line, please?  http://codepad.org/3enyhrjW , error: http://codepad.org/hvrfzFr3 . Doesn't overloadedStrings take care of this conversion?
07:58:16 <joe9> i can use ByteString.Char8.unpack
07:58:30 <joe9> but, am not sure if that is the correct way of going about it
08:00:58 <srhb> joe9: OverloadedStrings does not magically convert a ByteString into a String for you, so yes, you need to manually convert.
08:01:31 <srhb> joe9: If you have a UTF8 ByteString, you should probably use toString.
08:02:18 <joe9> srhb: I do not know if I am using a UTF8 bytestring. I am just using digits and "-" character in that data piece.
08:02:29 <slomo> joe9: http://hackage.haskell.org/package/utf8-string for converting UTF8 ByteString from/to String
08:03:20 <srhb> joe9: Depends what you will be calling fromField on.
08:03:38 <srhb> joe9: What do you expect the type of s to be?
08:04:10 <joe9> the type of s is a string with date in the format of "1999-12-10"
08:04:57 <srhb> Well, parseField :: Field -> Parser a
08:05:07 <srhb> And type Field = ByteString
08:05:57 <srhb> So it depends on the encoding of the file whether it should be decoded as a UTF8 ByteString or Char8, as far as I can see
08:06:10 <srhb> In the first case, use toString, in the latter use unpack (I think.)
08:06:13 <joe9> http://codepad.org/t8yVZfkE both BLC and BLU work.
08:06:22 <joe9> I am not sure though which is correct.
08:06:28 <srhb> joe9: Now throw a UTF8 character in your file.
08:06:54 <srhb> joe9: Here's one: ☭
08:06:59 <srhb> :-)
08:07:13 <joe9> srhb, so, I could just use BLU and it will work across both scenarios, correct?
08:07:34 <joe9> with BLU, Data.ByteString.UTF8
08:08:10 <srhb> There are no "both" scenarios. If you use BLU it will work with ASCII too, afair.
08:08:18 <joe9> ok, thanks.
08:08:23 <srhb> But there are other Char8 encodings that will give different results.
08:09:37 <srhb> I may be out of my depth, but if I remember correctly, the latin-1-* encodings use the last of the eight bits while ascii does not. So char8 might decode letters like æøå wrong. But I'm really not an expert on this encoding stuff, you should look it up. :)
08:10:21 * hackagebot type-aligned 0.9.5 - Various type-aligned sequence data structures.  http://hackage.haskell.org/package/type-aligned-0.9.5 (AtzeVanDerPloeg)
08:10:23 * hackagebot sequence 0.9.3 - A type class for sequences and various sequence data structures.  http://hackage.haskell.org/package/sequence-0.9.3 (AtzeVanDerPloeg)
08:11:14 <liyang> srhb: .Char8 will decode latin-1 encoding to the correct Chars.
08:11:34 <srhb> OK, so it defaults to latin-1?
08:11:40 <EvilTerran> srhb, that's about the size of it. ASCII proper is a 7-bit encoding - but people often say ASCII when they mean ISO-8859-1 or windows-1252
08:11:50 <EvilTerran> (or say ISO-8859-1 when they mean win-1252)
08:11:51 <srhb> EvilTerran: Right, thanks. :)
08:12:24 <liyang> The first 256 code points of Unicode correspond exactly to ISO-8859-1, or at least close enough. (Just covering my bases with the disclaimer.)
08:12:49 <srhb> Right. :)
08:12:53 <EvilTerran> they're subsets, every ASCII character is the same in iso-8859-1, but iso-8858-1 has some 8-bit characters - and every iso-8859-1 character is the same in windows-1252, but win-1252 has some more 8-bit characters
08:13:17 <srhb> So Char8 would decode wrongly were the file actually 8859-2?
08:13:18 <EvilTerran> to expand on liyang's disclaimer - the main thing that might catch you out is smartquotes
08:13:25 <liyang> ISO-8859-1 doesn't contain 256 code points?
08:14:09 <EvilTerran> 0x7F-0x9F are unassigned in iso-8859-1
08:14:20 <EvilTerran> compare: https://en.wikipedia.org/wiki/ISO/IEC_8859-1#Codepage_layout https://en.wikipedia.org/wiki/Windows-1252#Code_page_layout
08:14:24 <liyang> Wikipedia says: "The first 256 code points were made identical to the content of ISO-8859-1 so as to make it trivial to convert existing western text."
08:14:53 <albeit> I need an array-like structure for data that can up to 10 elements long, and will have fairly evenly divided insertions, deletions, and modifications at a specific index. At any point there may be between zero to ten elements filled, but if there are less than 10 (say 5), it will always be the indices 0-4. What is the best data-structure to use?
08:14:54 <xplat> EvilTerran: aren't they rather assigned to in-band control codes?
08:15:13 <slomo> liyang: only ASCII is a subset of UTF8, not all of ISO-8859-1. everything outside of ASCII has 2 or more bytes with UTF8
08:15:31 <EvilTerran> xplat, ... actually, yeah, maybe. they might as well be unassigned, if that's the case.
08:15:34 <srhb> slomo: That's contrary to what Wikipedia says?
08:15:49 <flux> srhb, it says "code points"
08:15:54 <srhb> Oh.
08:16:02 <srhb> Gah, why is this stuff so complicated. :-)
08:16:18 <EvilTerran> srhb, I think slomo means the byte streams would be different, even though the character streams could be the same
08:16:20 <flux> nevertheles, didn't know that, nice to know :-)
08:16:21 <liyang> slomo: I know that--we're talking about Data.ByteString.Char8 doing toEnum on the Word8 to turn it into a Char...
08:16:46 <liyang> and exactly what that will work correctly on.
08:17:03 <xplat> slomo: ISO-8859-1 is a subset of UTF8 at the code point level, but there is no official encoding of Unicode that is a superset of the default encoding of 8859-1 at the byte level afaik
08:17:24 <srhb> I'm sorry I started all this (again) :-)
08:17:46 <slomo> right, i missed the part about code points :) i was talking about the raw bytes
08:18:33 <srhb> My approach is to let the data provider deal with delivering UTF8, and not care about other encodings, anyway.
08:18:36 <liyang> Basically, use .Char8 if you only care about ASCII. If you have ISO-8859-1 encoded input... return it and ask for a refund.
08:19:08 <EvilTerran> and if you have windows-1252 encoded input, set it on fire and leave it on their doorstep :P
08:19:49 <liyang> I approve of this message.
08:19:58 <liyang> (But take no responsibility for it.)
08:20:11 <EvilTerran> (I've had no end of fun trying to process XML that claims to be iso-8859-1 but actually has windows-1252-encoded smartquotes in it. The very mention of that encoding gives me flashbacks.)
08:21:13 <srhb> EvilTerran: Like HTML5 in iso-8859-1? :-)
08:22:40 <EvilTerran> srhb, like clients copy-and-pasting from MSWord into their software that sends XML to our software, and their software not encoding the characters correctly
08:22:48 <srhb> Yummy.
08:23:38 <EvilTerran> srhb, and then we end up having to mangle the <?xml ... ?> decleration to have the right encoding attribute before parsing, because their software provider is completely unhelpful
08:24:11 <liyang> (I didn't know about the difference between ISO-8859-1 and Windows-1252. Thanks for the cautionary tale...)
08:24:33 <srhb> EvilTerran: I don't suppose there's a similar requirement in XML to HTML5 where ISO-8859-1 must actually be parsed as windows-1252?
08:24:57 <EvilTerran> srhb, if there is, our off-the-shelf XML parsing libraries don't know it
08:25:06 <srhb> Probably not then.
08:25:40 <EvilTerran> I think it's expat under the hood, so I wouldn't expect an oversight like that to slip through
08:29:06 <albeit> What is the "s" type variable in "data ST s a" and "data STArray s i e". ST mentions it is uninstantiated - what does that mean?
08:29:50 <geekosaur> it is a phantom type that exists solely to prevent leakage
08:30:43 <liyang> EvilTerran: Wikipedia says that ISO_8859-1:1987 does assign 0x80-0x9F to the C1 control range, so that means ISO_8859-1:1987 does correspond to the first 256 Unicode codepoints, if I'm reading this correctly.
08:30:50 <albeit> So If I want to do something like "type Foo = STArray s Int Bar", can I just leave "s" as "s"? or "_"?
08:31:19 <Iceland_jack> albeit: You could make it existential
08:31:20 <greymalkin> I'm trying to make an Enum with custom values/elements is there a O(1) way to do lookup from the enumerated value to the corresponding integer? I have it down to O(logn) using a map, but I need to translate these values in a very tight loop.
08:31:26 <Iceland_jack> But you don't want that here
08:31:34 <Iceland_jack>     type Foo s = STArray s Int Bar
08:31:47 <greymalkin> (The values are restricted to Word8 size; so there's only 156 of them.
08:31:50 <greymalkin> er... 256
08:31:53 <greymalkin> )
08:32:30 <indiagreen> greymalkin: what about an array
08:32:30 <EvilTerran> liyang, oh right. that's entirely likely, I'm just used to situations where those characters are always a sign of incorrect encoding
08:32:40 <albeit> Iceland_jack: Okay, thanks
08:33:00 <EvilTerran> > map fromEnum ['A' .. 'Z']
08:33:00 <greymalkin> indiagreen: Chicken and egg... what's the index into the array given data value Something.
08:33:01 <lambdabot>  [65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90]
08:33:15 <EvilTerran> greymalkin, fromEnum sounds like what you need
08:33:33 <indiagreen> EvilTerran: except that greymalking is trying to write fromEnum
08:33:38 <liyang> EvilTerran: https://en.wikipedia.org/wiki/ISO/IEC_8859-1#History , third paragraph: "... ISO-8859-1 (note the extra hyphen over ISO 8859-1) ..." O_o
08:33:41 <greymalkin> *nod*
08:33:57 <EvilTerran> ohhh, right. chicken, meet egg. :P
08:35:25 <EvilTerran> in that case, I think it'd depend on what your values were
08:35:36 <indiagreen> greymalkin: you can do it with a newtype and lose some convenience, or you can do it with something like unsafeCoerce and lose some safety, or you can do it with a Map and lose some speed
08:35:47 <greymalkin> Hmm... now that I'm thinking about it, I might not need to correlate the value of the enum with the value of the Word8...
08:35:47 <indiagreen> *or* I think you can do it with a “case” and it would be very fast
08:35:52 <EvilTerran> if you can pattern-match on them, the fastest option might be to just write a giant case/of
08:36:03 <indiagreen> because GHC optimises cases to lookup tables
08:36:05 <indiagreen> probably
08:36:11 <indiagreen> benchmark, always benchma-ark
08:36:22 <srhb> EvilTerran: Time for TH!
08:36:45 <greymalkin> indiagreen: Yeah, I've been profiling the heck out of my program, and this lookup is what's taking the most time.
08:36:52 <EvilTerran> would "deriving Enum" be cheating?
08:37:41 <liyang> indiagreen: I think GHC only does that for tags, not all cases (the table would be too big in the general case)...
08:38:05 <liyang> (But I'm guessing. I don't actually know for certain.)
08:39:42 <bestdew55> http://vividsx.blogspot.com/2014/12/hd-collection-adult-movies.html
08:40:22 * hackagebot type-aligned 0.9.6 - Various type-aligned sequence data structures.  http://hackage.haskell.org/package/type-aligned-0.9.6 (AtzeVanDerPloeg)
08:44:34 <athan> Is there a simple nat-sized list package/data type? I'm not sure if I want to go down the rabbit hole of datakinds & singletons...
08:45:22 * hackagebot sequence 0.9.4 - A type class for sequences and various sequence data structures.  http://hackage.haskell.org/package/sequence-0.9.4 (AtzeVanDerPloeg)
08:48:49 <EvanR-work> athan: seems more common to use Integer or Int, and in your mind pretend it is a Nat
08:49:25 <athan> EvanR-work: Yeah, that's a good point. Idk, I just don't like mixing promotion with haskell. I might just go down the agda road and ffi
08:49:56 <fiatjaf> why am I getting `cabal: out of memory (requested 1048576 bytes)`?
08:50:09 <fiatjaf> cabal-install version 1.20.0.2
08:50:14 <fiatjaf> The Glorious Glasgow Haskell Compilation System, version 7.6.3
08:50:31 <EvanR-work> athan: promotion?
08:50:58 <athan> EvanR-work: Yeah, like -XDataKinds, GADTs, TypeFamilies and the singletons library
08:51:08 <athan> Pushing `Integer` to the kind level
08:51:27 <EvanR-work> oh well if youre already doing that nevermind
08:51:39 <EvanR-work> you basically need Nat at the type level
08:51:43 <athan> fiatjaf: You should be using GHC >=7.8 with cabal-install >=1.18
08:51:50 <mmmm> athan: You know about GHC.TypeLits ?
08:51:57 <athan> EvanR-work: Yeah, i'm just gonna go with agda
08:52:02 <athan> mmmm: Hmm, no I don't!
08:52:14 <albeit> For a list of max 10 elements, with insertions, deletions, and modifications, will I see a performance improvement of switching form list to STArray? Just thinking the overhead with STArray may be to much for just max 10 elements
08:53:30 <athan> mmmm: Ahh, nice, I'm looking (ideally) for size-indexed lists - I don't really want to do all the plumbing myself :\
08:54:14 <mmmm> there must be something around
08:54:24 <fiatjaf> thank you, athan
08:54:52 <athan> fiatjaf: No prob :)
09:02:00 <carter> albeit: why would there an an overhead for an ST array?
09:03:29 <albeit> carter: Not sure! just assumed there would be because it is trickier than lists
09:04:52 <carter> hows it trickeir
09:06:29 <carter> albeit: use MVectors in Vector package
09:06:36 <carter> they can run in ST monad
09:06:53 <carter> albeit: or just try both and measure
09:07:58 <besenwesen> is there any quick fix to make lambdabot build? (it’s using control.oldexception)
09:09:51 <srhb> besenwesen: Follow the types, or find a friendly fork on github that works?
09:10:58 <besenwesen> do you know of one? i was trying to install ghci-on-acid, but maybe it’s not worth the hassle
09:11:34 <srhb> besenwesen: I don't, no
09:11:48 <carter> besenwesen: ... lambdabot on hackage should be buildable
09:11:50 <carter> with 7.8
09:11:52 <carter> afaik
09:12:09 <carter> @hackage lambdabot
09:12:09 <lambdabot> http://hackage.haskell.org/package/lambdabot
09:12:12 <besenwesen> i tried, but it failed me due to OldException not being found
09:12:23 <besenwesen> apparently that’s been deprecated or something
09:12:28 <carter> open a bug report
09:12:31 <carter> besenwesen: .... wait
09:12:34 <carter> what version of lambda bot
09:12:38 <carter> did cabal pick a weird older version
09:12:43 <carter> besenwesen: what ghc version are you on
09:13:12 <besenwesen> it’s trying to install 4.2.3.3. ah, that’s an old one, i see. i wonder why cabal selected that
09:13:44 <carter> besenwesen: explode ~/.ghc/yourghcversion
09:13:46 <carter> and try gain
09:14:33 <besenwesen> yea, i’ve been doing that frequently these last days ;3 i just did. maybe something i need is pinning a dependency, and the new lambdabot needs a newer version of that?
09:15:23 <srhb> besenwesen: That's what usually what happens.
09:15:29 <srhb> -what, any what.
09:15:57 <besenwesen> weird, when i ask for the newer version of lambdabot, it wants to downgrade mtl & co., and refuses
09:16:27 <besenwesen> hm, let’s annihilate ~/.ghc/… again
09:16:32 <besenwesen> ;—;
09:16:45 <srhb> besenwesen: One day, this will all be a bad memory. I hope. :-)
09:17:26 <besenwesen> is this what stackage is about? i’ve often seen references to it lately, and the page said something about it being a stable hackage
09:17:50 <srhb> I think Stackage is some kind of vetted version of Hackage that lets you compile Yesod, or something.
09:18:02 <carter> yeah
09:18:26 <carter> otoh, i like trying to make sure i have useful version constraints on everything that allows users to have CHOICE
09:18:37 <carter> nix and stackage are two approaches in that space
09:19:37 <fiatjaf> athan: same problem, now with ghc 7.8.3 and cabal 1.20.0.2
09:19:48 <fiatjaf> cabal: out of memory (requested 1048576 bytes)
09:19:57 <athan> fiatjaf: Shoot, how many gigs of ram does your computer have?
09:20:01 <srhb> fiatjaf: Are you really using the new cabal?
09:20:04 <athan> Usually you need >4G I think
09:20:24 <athan> (I got away with 1G on my laptop)
09:20:24 <carter> fiatjaf: make the swap space bigger
09:20:29 <athan> but amazon EC2s fail
09:20:33 <srhb> oh yeah, that's no space at all
09:20:45 <carter> most vms default to 0 swap
09:20:51 <carter> you have to reconfigure them to have more swap
09:21:37 <fiatjaf> I'm using a digital ocean droplet with 512MB
09:21:48 <fiatjaf> it is impossible to use haskell, then?
09:22:08 <zomg> fiatjaf: you can configure it to use hard disk space as swap
09:22:09 <fiatjaf> this doesn't make any sense.
09:22:16 <zomg> that will solve the problem of compiling requiring more ram than you have
09:22:34 <fiatjaf> is that really the problem?
09:22:37 <zomg> I had a low memory linode vps where I kept running into the same issue
09:22:42 <fiatjaf> no infinite loops, memory leaks?
09:22:46 <zomg> yes, it requires more ram.. just mount some temporary swap and it'll work
09:22:49 <zomg> uhh
09:22:50 <sfs> good afternoon. come to my company in the www.midnightchat.eu
09:22:51 <fiatjaf> I sure have more than 1048576 bytes
09:23:00 <sfs> good afternoon. come to my company in the www.midnightchat.eu
09:23:06 <indiagreen> @where ops
09:23:06 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:23:13 <zomg> fiatjaf: that's just the amount it requested when it failed, it might've requested all the other available memory before it
09:23:15 --- mode: ChanServ set +o monochrom
09:23:19 --- mode: monochrom set +b sfs!*@*
09:23:28 <carter> fiatjaf: default VMs DO NOT have swap
09:23:29 <monochrom> oh nevermind
09:23:32 <carter> you have to configer them to swap
09:23:35 --- mode: monochrom set -b sfs!*@*
09:23:36 <iElectric> is there a way to use a lambda function to partially construct type instance?
09:23:50 <carter> iElectric: show aht you mean plz
09:24:07 --- mode: monochrom set -b *!*@ip-109-43-8-94.web.vodafone.de
09:24:10 <iElectric> carter: like: let event = \more -> Event { eventTitle = "a" + more }
09:24:24 <bryanedds> if I have a lambda (a -> a) -> s, can I bind the (a -> a) portion to a variable?
09:24:38 <zomg> fiatjaf: follow the instructions here https://beeznest.wordpress.com/2010/02/05/howto-enable-temporary-swap-file-on-gnulinux/
09:24:53 <zomg> if you add 1 or 2 gigs of temporary swap with that, it oughta work
09:24:53 <crobbins> iElectric: sounds like you are after something like TypeCompose: http://stackoverflow.com/questions/4069840/lambda-for-type-expressions-in-haskell
09:24:55 <zomg> worked for me anyway
09:25:11 --- mode: monochrom set -bbb *!*@gateway/web/freenode/ip.94.71.* *!*@*.xyz *!*@87.19.74.180
09:25:19 --- mode: monochrom set -o monochrom
09:25:31 <carter> zomg ++
09:25:39 <carter> zomg yeah
09:25:42 <besenwesen> hm http://codepad.org/zfiPa5ux
09:25:46 <besenwesen> how to interpret this?
09:25:51 <iElectric> carter: tnx
09:26:04 <carter> iElectric: it sounds like you wrote what you wanted :)
09:26:24 <bryanedds> actually my full type is (a -> a) -> s -> s, but I suppose the principle is the same
09:26:40 <fiatjaf> how much memory will this need?
09:26:41 <bryanedds> any ideas?
09:26:51 <hodapp> woo, I used a monad transformer for the first time and didn't do crazy!
09:26:58 <hodapp> well... I used a monad transformer at least
09:27:10 <zomg> fiatjaf: you can try with 1 gig or 2 gigs, it shouldn't need any more than that
09:27:17 <besenwesen> why is it rejecting my ghc installation?
09:27:28 <zomg> I had 512mb ram on my linode box, and usually mounting 1 gig fixed any compilation memory usage issues
09:27:54 <fiatjaf> that's bad, I don't have much HD space
09:27:58 <fiatjaf> I'll have to think about it.
09:28:16 <zomg> you only need it during compiling the big bits though
09:28:21 <zomg> so you can free it once you're done
09:28:41 <zomg> if you're crazy you could probably do it with sshfs too but that would most likely be dreadfully slow :D
09:29:05 <monochrom> haha
09:29:14 <zomg> alternatively, compile your binaries in a compatible VM on your desktop
09:29:27 <fiatjaf> hm.
09:29:29 <monochrom> there is also a driver providing "gmail file system" :)
09:29:34 <carter> flux: 20GBSSD Disk
09:29:41 <carter> fiatjaf:
09:29:55 <carter> fiatjaf: DO tiny boxes have enough space for a 1gb swap file
09:30:16 <iElectric> carter: another solution is to use currying, I might go with that
09:30:25 <carter> iElectric: whagever floats your boat
09:30:26 <fiatjaf> maybe I'll just do everything in my desktop and, if it works (and I manage to get things running with haskell) I'll do these complex things
09:31:21 <carter> fiatjaf: .... read the linke zomg  gave you
09:31:22 <carter> its really easy
09:31:30 <fiatjaf> carter: I'm too messy. I'm currently using 17G there. all my fault (and npm's fault, their packages take a lot of space).
09:31:31 <carter> @where ops
09:31:31 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:31:36 <carter> porkys: is spamming
09:31:42 --- mode: ChanServ set +o monochrom
09:31:50 --- mode: monochrom set +b *!*@90.174.3.224
09:31:50 --- kick: porkys was kicked by monochrom (porkys)
09:32:02 --- mode: monochrom set -o monochrom
09:32:30 <fiatjaf> carter: I read it, but I also read https://www.digitalocean.com/community/tutorials/how-to-configure-virtual-memory-swap-file-on-a-vps#2, so I'm suspicious
09:32:32 <bryanedds> every time I see +o, i imagine mod going super-saiyen, then back to normal at -o
09:32:53 <carter> fiatjaf: both say do it
09:33:00 <bryanedds> hm, is my question not clear?
09:33:18 <bryanedds> it's hard to know why a question isn't being address in irc
09:33:20 <carter> fiatjaf: the reason vms default to no swap is so OOM kills things rather than server getting slow
09:33:25 <carter> bryanedds: what question
09:33:34 <carter> :t (>)
09:33:35 <lambdabot> Ord a => a -> a -> Bool
09:33:37 <carter> :t (.)
09:33:38 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:34:02 <bryanedds> if I have a lambda (a -> a) -> s, can I bind the (a -> a) portion to a variable?
09:34:24 <carter> bryanedds: wrapp it
09:34:28 <srhb> bryanedds: like \f -> ?
09:34:35 <carter> \f -> foo f
09:34:36 <carter> bam
09:34:52 <bryanedds> I think I need to pull it out of the wrapping
09:34:58 <clrnd> > (\f -> f 5 4) (+)
09:35:00 <lambdabot>  9
09:35:01 <carter> bryanedds: .... whats the problem?
09:35:03 <fiatjaf> ok, I'm doing it.
09:35:06 <carter> tell us your goal
09:35:11 <srhb> I don't understand the problem I think. :-)
09:35:11 <fiatjaf> it is working.
09:35:24 * hackagebot murmur-hash 0.1.0.8 - MurmurHash2 implementation for Haskell.  http://hackage.haskell.org/package/murmur-hash-0.1.0.8 (ThomasSchilling)
09:35:27 <bryanedds> okay, I'm in F#, so I may go a little slow by converting to haskell
09:35:35 <fiatjaf> thank you, carter and zomg.
09:35:47 <zomg> np
09:36:24 <bryanedds> I have a function of type (a -> a) -> s -> s and another of type (b -> b) -> s -> s
09:36:37 <srhb> bryanedds: Okay. :-) Sounds weird.
09:36:52 <carter> bryanedds: those are the same types
09:37:24 <srhb> sounds like const s id
09:37:37 <bryanedds> I want to build a combinator that takes those functions and produces a new function of type a -> b -> s -> s
09:37:45 <carter> bryanedds: then write them
09:37:47 <bryanedds> er wait
09:38:02 <bryanedds> I want to build a combinator that takes those functions and produces a new function of type (a -> b -> (a, b)) -> s -> s
09:38:04 <carter> bryanedds: take a break from the computer and write it down on paper
09:38:13 <carter> haha
09:38:24 <carter> the only function of the fomer is (,)
09:38:27 <carter> :t (,)
09:38:27 <lambdabot> a -> b -> (a, b)
09:38:35 <carter> tuple sections ftw
09:38:53 <carter> {-# LANGUAGE TupleSections#-}
09:39:00 <monochrom> so the whole thing has type ((a -> a) -> s -> s) -> ((b -> b) -> s -> s) -> (a -> b -> (a, b)) -> s -> s ?
09:39:01 <srhb> That's not a section though?
09:39:25 <bryanedds> I think so... but let me think about it a little more
09:40:15 <srhb> Am I being stupid or are those functions completely nonsensical? How does one do anything to an s with an a -> a or b -> b or even a -> b -> (a, b) ?
09:40:19 <monochrom> carter: you are given, rather than to build, a function of type (a -> b -> (a, b))
09:40:25 <srhb> I mean, all of them sound like some kind of cons.
09:40:28 <srhb> const
09:40:43 <bryanedds> basically, the combinator takes two state update functions and produces a single state update function
09:40:57 <srhb> or, s is short of some kind of (a,b) ?
09:40:59 <srhb> oh*
09:41:05 <srhb> or State a b
09:41:09 <bryanedds> it fuses two state update functions into one
09:41:13 <bryanedds> no, not State
09:41:26 <bryanedds> just state
09:41:36 <bryanedds> as in a context variable
09:41:57 <bryanedds> presumable it could generalize to State, but that's outside the scope of my concerns
09:42:04 <carter> this sounds like Profunctors / Bifunctors/ Arrow
09:42:50 <clrnd> bryanedds, still not sure what you want, maybe if you paste it down?
09:42:53 <clrnd> @where paste
09:42:53 <lambdabot> Haskell pastebin: http://lpaste.net/
09:42:59 <bryanedds> Here's the type signature in F# if it's helpful -     let combinator (updater : ('a -> 'a) -> 's -> 's) (updater2 : ('b -> 'b) -> 's -> 's) : ('a -> 'b -> ('a * 'b)) -> 's -> 's = ???
09:43:20 <bryanedds> er, let combinator (updater : ('a -> 'a) -> 's -> 's) (updater2 : ('b -> 'b) -> 's -> 's) : ('a -> 'b -> ('a * 'b)) -> 's -> 's
09:43:26 <srhb> Wow, I really don't understand F#/ :-)
09:44:20 <carter> srhb: 'a is just a in haskell land
09:44:24 <clrnd> you can write down exactly like that in haskell, except for the argument names
09:44:33 <srhb> And 's is not forall s
09:44:40 <srhb> ?
09:44:50 <monochrom> srhb: simply imagine ScopedTypeVariables, i.e., you can attach types to patterns, f (x :: Int) (y :: Bool) = answer :: Char
09:45:00 <srhb> Aha.
09:45:11 <monochrom> @djinn ((a -> a) -> s -> s) -> ((b -> b) -> s -> s) -> (a -> b -> (a, b)) -> s -> s
09:45:11 <lambdabot> f a b _ c = a (\ d -> d) (b (\ e -> e) c)
09:46:11 <clrnd> woah nice
09:46:41 <monochrom> I don't think there is a way to "tear apart" (a -> b -> (a, b)) into separately (a->a) and (b->b). since, in (a -> b -> (a,b)), there are extra dependencies allowed.
09:47:52 <bryanedds> so it's not possible to implement this combinator?
09:48:22 <monochrom> unless you accept plugging in \x->x into (a->a) and (b->b), and ignore the provided (a -> b -> (a,b))
09:48:32 <monochrom> the provided (a -> b -> (a,b)) is unusable.
09:50:20 <bryanedds> what is meant by \x->x
09:50:33 <srhb> id
09:50:35 <monochrom> the identity function
09:51:02 <monochrom> it's "lambda x: x" in python
09:51:19 <monochrom> probably "fun x -> x" in ML-like languages
09:51:46 <homovitruvius> >what is the advantage of a parse monad (as opposed for instance to a Parsec transformer with a monad stack for logging, state (incl name supply and symbol table))? same question for things like the TreverseMonad in language-c compared to a simple state monad. (I guess the question is handcrafted "bloated" monads compared with compostion of simpler monads)
09:51:47 <clrnd> let id x = x
09:53:01 <srhb> homovitruvius: There's (often?) a runtime cost associated with transformers.
09:53:07 <bryanedds> damn
09:55:25 * hackagebot HsOpenSSL 0.11.1 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.11.1 (MasatakeDaimon)
09:56:29 <bryanedds> yep, once again I'm stuck needing lenses
09:56:48 <clrnd> at least it's not PHP
09:57:24 <bryanedds> i could easily make that combinator with lenses
09:58:03 <lpaste> kadoban pasted “Longest Increasing Subseq” at http://lpaste.net/117480
09:58:20 <kadoban> Anyone have ideas to speed that up a tad? ^ It's just a little too slow :-/
09:58:28 <joe9> What function converts : String -> Data.ByteString.Lazy.ByteString?
09:58:46 <homovitruvius> srhb: so it would be a tenable proposition to start with transformer stacks and then refactor into an ad-hoc monad later if needed or stacks force you into a design that is then hard to modify? It looks to me that if you use one of the transformer libraries that don't force you to count the lifts, it should be esy to switch, but this would be my first ahskell program, as opposed to testbook exercises, so what do I know?
09:58:48 <joe9> I checked out D.B.L.pack, but that needs Word8
09:59:13 <bryanedds> thanks for the help y'all :)
09:59:14 <kadoban> joe9: Is there something called encode or something?
09:59:20 <bryanedds> at least I now know what I can't do
10:00:04 <kadoban> Hmm, apparently not...
10:00:09 <joe9> kadoban: I cannot find encode in D.B.L
10:01:47 <clrnd> kadoban, what does profiling say?
10:02:10 <bryanedds> cheers all!
10:02:34 <kadoban> joe9: What about this stuff, sounds right I think.  toLazyByteString . stringUtf8   maybe?
10:02:40 <kadoban> joe9: https://hackage.haskell.org/package/bytestring-0.10.4.1/docs/Data-ByteString-Builder.html
10:04:58 <clrnd> @hoogle String -> ByteString
10:04:59 <kadoban> clrnd: Hehe, trying to figure out now...so far nothing I can make much use of, but then I'm pretty bad at profiling/tuning haskell.
10:05:00 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
10:05:00 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
10:05:00 <lambdabot> Prelude error :: [Char] -> a
10:07:06 <bananagram> @hoogle Text -> ByteString
10:07:06 <lambdabot> Data.Text.Encoding encodeUtf16BE :: Text -> ByteString
10:07:07 <lambdabot> Data.Text.Lazy.Encoding encodeUtf16BE :: Text -> ByteString
10:07:07 <lambdabot> Data.Text.Encoding encodeUtf16LE :: Text -> ByteString
10:07:50 <srhb> homovitruvius: That is usually what people do, afaik. :)
10:08:19 <srhb> homovitruvius: As in, yes, starting with a transformer and then creating your custom monad later if needed is absolutely viable
10:12:03 <clrnd> kadoban, do you have a sample file for testing?
10:12:41 <kadoban> clrnd: Yeah, sec...  I'm stuck on profiling, I don't really know what it's telling me that's interesting :-/
10:16:29 <kadoban> clrnd: Input file: http://www.emptypath.com/longest.input.txt
10:22:12 <kadoban> I'm guessing a lot of the slowness is doing the delete and the lookupGE, which is a bit redundant...but then IntSet doesn't have a way to do it in one, of course...so I'd probably have to do the whole thing custom, which...ugh.
10:22:30 <clrnd> kadoban, i deleted the longestInc call, and it performs almost the same
10:23:01 <kadoban> Ah...meaning it's all the input handling I guess
10:23:08 <clrnd> I guess yeah
10:23:21 <clrnd> profiling said it spent most time there, too
10:23:45 <clrnd> or toInt
10:24:32 <clrnd> no, its not toInt
10:24:56 <kadoban> I think I need to read up more on how to interpret/use the profiling info. I seem to be really bad at reading that.
10:25:28 <clrnd> kadoban, Real World Haskell's is quite good, I think
10:25:55 <kadoban> Thanks, yeah I'll read that section again, hehe. Thanks for the help
10:27:32 <clrnd> kadoban, he it's complicated. I think I made a mistake too
10:27:53 <clrnd> input alone takes 50% here
10:28:20 <kadoban> Apparently part of the problem is that I'm an idiot too...my reading was that input took almost no time, which clearly should be impossible, so I probably should have realized /that/ wasn't right.
10:30:40 <clrnd> what can take a lot of time is packing/unpacking text
10:30:46 <paul_> where do i go for backtrack
10:31:10 <clrnd> bytestrings are faster too, try them insted of Text
10:31:51 <ij> paul_, You want to backtrack?
10:31:55 <kadoban> Yeah, that sounds like a plan.
10:32:30 <monochrom> you go to a place you visited in the past for backtracking.
10:33:17 <ij> The more I think of that sentence, the more giggles I make.
10:34:08 <paul_> lol good one mono
10:35:26 <paul_> which chat for backtrack
10:38:29 <ij> I wrote some stencil convolution code with repa. I'm not sure if it's the best way to go about it, but it works. Any critiques? http://sprunge.us/JOTf
10:41:43 <ij> paul_, Maybe you're thinking about backtrack linux, that pentesting thing(which I've never used)?
10:42:54 <kadoban> clrnd: Yeah, ByteString did the trick. Thanks again.
10:43:24 <clrnd> kadoban, oh great! no problem :D
10:44:42 <kadoban> I had no idea it was /that/ much faster. Apparently like...10 times as fast or so
10:45:15 <paul_> sorry yes cant you tell am new on here am using windows 8 getting board with it need a New Challenge
10:46:05 <ij> I've exactly no idea what you're talking about.
10:46:30 <clrnd> wow, yeah I think Text is for utf8 and actual text stuff
10:47:08 <clrnd> paul_, windows 8 seems quite slow, whats New Challenge why?
10:47:51 <kadoban> Yeah...which is actually kinda safer/more sane in general, but...still. Of course my old way was doing 'read . unpack' which is itself probably awful, but I haven't found a better way in Data.Text for parsing integers or other simple things.
10:47:55 <paul_> going from windows to linux
10:47:55 <josephle> clrnd: also utf16! I remember when there was a freenode server with a non-utf8 character in its welcome message -_-
10:48:41 <kadoban> Haha, really? That sounds funny/awful.
10:48:53 <clrnd> lol but does it support emoji?
10:49:15 <paul_> want  to learn  linux
10:49:16 * clrnd is cabal init'ing Data.Emoji brb
10:49:39 <Denommus> instead of Nothing we'd have a sad face
10:49:40 <clrnd> paul_, refer to #linux
10:49:59 <kadoban> Denommus: The poop emoji sounds appropriate
10:50:11 <paul_> ok thanks cirmd
10:50:15 <Denommus> kadoban: no, that's undefined
10:50:36 <kadoban> Hehe
10:51:15 <clrnd> no problem paulyd
10:51:21 <athan> holy beans, am I really supposed to build lambdabot with ghc 6.10.x?
10:52:16 <clrnd> @let 👍  = Left
10:52:16 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (128077) is outside of bounds (0,255)
10:52:21 <clrnd> :/
10:52:56 <kadoban> Hah
10:54:28 <clrnd> @let ✔ = Right
10:54:28 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (10004) is outside of bounds (0,255)
10:54:35 <clrnd> ok i give up
10:58:00 <Denommus> how can GHC not stack overflow on the intuitive definition of factorial?
10:58:25 <Denommus> that is, let factorial 0 = 1; factorial x = x * factorial (x-1)
10:58:48 <Norfair> well GHC doesn't calculate anything
10:58:58 <Norfair> your question is equivalent to
10:58:58 <josephle> for sufficiently large numbers, the program should run out of heap space
10:59:06 <clrnd> Denommus, afaik stack's overflow because they have a limited space, and afaik haskell doesn't have a 'stack space'
10:59:14 <clrnd> it jsut allocates more and more
10:59:19 <clrnd> that ^
10:59:19 <Norfair> why doesn't it take an infinite amout of time to compile let x = x
10:59:20 <clrnd> heap
10:59:20 <Denommus> ah
11:00:08 <clrnd> Norfair, well we can assume he asked for the value, main = print $ factorial 99999
11:00:28 * hackagebot cabal-install 1.20.0.6 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.20.0.6 (JohanTibell)
11:00:56 <wei2912> that took less than a minute to finish
11:00:57 <josephle> IIRC, there is a max heap usage set for the haskell runtime, but it can be modified via flags
11:01:05 <Denommus> Norfair: another language would stack overflow with the same algorithm
11:01:14 <Norfair> yes
11:01:16 <Norfair> at runtime
11:01:19 <Norfair> but you spoke of GHC
11:01:23 <Norfair> which is the compiler
11:01:30 <clrnd> i'd like to see it for a lazy language with a function stack
11:01:43 <josephle> Norfair, let's just assume that Denommus really means the runtime system :)
11:01:50 <Norfair> aha, okay :p
11:02:09 <Norfair> what clrnd said :p
11:04:54 <Denommus> Norfair: the runtime is part of the implementation, isn't it? :P
11:05:28 <Norfair> Not sure what you're asking me
11:05:28 * hackagebot lens 4.7 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.7 (EricMertens)
11:05:30 <Norfair> runtime is a moment
11:05:32 <edwardk> yay!
11:05:36 <edwardk> glguy++
11:05:47 <Norfair> an abstract* moment
11:06:23 <Saizan> Denommus: anyhow, binaries produced by a recent enough ghc just have unlimited stack by default
11:07:10 <Saizan> Norfair: runtime is also short for runtime system, which usually includes a GC and similar support stuff
11:07:34 <Denommus> GHC is an implementation of Haskell, and it comes with a runtime, doesn't it?
11:07:34 <Denommus> or is the runtime not a part of GHC?
11:07:44 <Norfair> I agree, but I sais _at_ runtime
11:07:45 <Norfair> said*
11:07:52 <Norfair> i didn't speak of _the_ runtime :p
11:07:59 <Norfair> sorry to bother you guys, I'm nitpicking
11:08:16 <Saizan> Denommus: ghc has its own runtime system
11:08:27 <Saizan> Denommus: iow, yes
11:09:16 <Denommus> well, I'm also nitpicking, and the runtime is part of GHC, so my question was technically right :-P
11:09:49 <Saizan> who cares who is right?:) we shared the needed information.
11:09:52 <Norfair> ABsolutely, but it was not on the topic of which I spoke, which makes it quite difficult to handle :p
11:10:19 <Norfair> Do you understand why your program doesn't cause a stack overflow now (though not thanks to me :p)
11:10:42 <Denommus> yes
11:11:37 <Norfair> great, sorry to be such an annoyance, was just trying to help
11:12:47 <clrnd> hey, anybody knows of another lazy language?
11:14:11 <johnw> do you mean "lazy by default evaluation", or just languages that support laziness in some way?
11:15:14 <ij> Is regex-tdfa the coolest implementation?
11:15:33 <clrnd> johnw, like haskell
11:16:49 <johnw> Haskell, the language, is neither strict nor lazy
11:17:00 <johnw> that's why I'm asking for a more precise question
11:17:22 <nolrai66> So is there a code repo associated with "Simply Easy!" I am re-reading it and cant find such..
11:17:52 <clrnd> johnw, care to explain why haskell is not lazy?
11:18:05 <exio4> it is non-strict
11:18:21 <johnw> "lazy evaluation" is an operational detail not addressed by the Haskell report
11:18:26 <clrnd> let me google this
11:18:28 <johnw> it's one way of implementing non-strictness
11:19:09 <Chathurga> clrnd: The way you're thinking of it, no, I can't think of a reasonably well used language that is lazy by default like GHC's Haskell
11:19:36 <clrnd> Chathurga, that's pretty weird I'd say
11:19:43 <exio4> so we're doomed to use Haskell?
11:20:22 <srhb> exio4: What terrible fate has befallen us?
11:20:59 <Chathurga> clrnd: It's actually a pretty bold move, and appears very high level to people I think
11:21:15 <clrnd> I'm guessing Idris is lazy
11:21:20 <Chathurga> No I don't think so
11:21:21 <clrnd> and or Agda?
11:21:22 <johnw> Idris is strict by default
11:21:23 <Norfair> That begs the question, is it possible to make an imperative lazy language?
11:21:29 <Chathurga> It can go lazy but it isn't by default
11:21:31 <clrnd> oh my that's interesting
11:22:20 <nolrai66> Norfair: yes but it would suck.
11:22:42 <Chathurga> I personally prefer lazy by default with a very easy way to be strict
11:23:04 <exio4> Norfair, side-effects make lazy evaluation painful
11:23:08 <nolrai66> Chathurga: I didn't agree with you at first, but now I do.
11:23:29 <Chathurga> Oh, and have the standard library strict when it should be
11:23:52 <Chathurga> I do not really believe in a non strict foldl, it shouldn't be the default
11:24:13 <quchen> johnw: I've heard that a couple of times now. What would be another way of implementing non-strictness?
11:25:08 <quchen> exio4: Side effects make strict evaluation painful as well ;-)
11:25:34 <johnw> quchen: good question
11:25:36 <exio4> is there anything that isn't ugly and painful with side-effects anyway ;P
11:25:39 <johnw> resources: http://stackoverflow.com/questions/7140978/haskell-how-does-non-strict-and-lazy-differ
11:25:42 <johnw> http://en.wikibooks.org/wiki/Haskell/Laziness
11:26:00 <nolrai66> Hmm. I wounder if the IO commonad wold be a good modle for lazy imperativeness.
11:28:01 <quchen> IO isn't a comonad.
11:28:38 <quchen> Its extract would be unsafePerformIO. Not a good start.
11:30:16 <nolrai66> Huh. That is true. Thats ironic given the very first paper on comonads I read used IO as the founding idea.
11:31:01 <quchen> Are you sure it's about *co*monads?
11:31:12 <clrnd> OI
11:31:31 <clrnd> it used unsafePerformIO iirc
11:31:45 <jefus> I'm working my way through a tutorial and have a quick(?) question: if someList is say, "[1,2,3]", is there a significant difference between "head someList" and "someList !! 0"?  Maybe I'll come across the answer anyways but asking while it's fresh
11:31:58 <nolrai66> Yep, I mean I read it a long time ago but it was a "Hey guys, you are all using Monads, I think Comonads are more awesome." type paper.
11:32:03 <Enzoray> Implement a function which returns the extension of a filename;
11:32:32 <quchen> jefus: No, those two are equivalent, they yield the first list element. And they both blow up your program when the list is empty.
11:32:36 <Enzoray> extension :: String -> String
11:32:42 <quchen> Head is probably a bit more efficient, but that's peanuts.
11:32:45 <clrnd> jefus, no there isn't
11:32:55 <jefus> quchen, clrnd: OK, thanks
11:32:57 <Denommus> jefus: besides the exception message if the list is empty, no
11:32:59 <Enzoray> extension :: String -> String
11:33:00 <Enzoray> extension a = '.' : (reverse (takeWhile (>'.') (reverse a)))
11:33:06 <Enzoray> What do you think about my solution?
11:33:09 <jefus> ah, wasn't sure if there were any hidden subleties
11:33:17 <clrnd> jefus, it's semantics, do you want the head or the xth element?
11:33:17 <jefus> thanks Denommus too
11:33:48 <jefus> right; specifically for the 0 index, they are identical I see
11:33:52 <trap_exit> when using parsec, how do I tell parsec ... if yuo see "module", then commit to this parsie route ... but if you only see "modul" ... it's okay to backtrack ?
11:34:23 <joe9> Is there an easy way to read back output from groom (of Text.Groom)?
11:34:31 <joe9> I cannot get a simple read to work.
11:35:16 <joe9> Or, is there a better serialize/deserialize library for Haskell? I read some data structures to a file and read them back later. But, I find that the default show output is not readable in the file.
11:35:33 <joe9> Hence, want to use groom or something that can show the data in a better structured manner.
11:35:58 <nolrai66> trap_exit : (try (string module) >> parseModule) <|> parseOtherStuff
11:36:08 <nolrai66> Should work iirc.
11:36:28 <trap_exit> nolrai66: that looks like .... "if it sees "module" ... and it fails to parse, then it can parseOtherStuff"
11:36:41 <trap_exit> I'm trying ot say ... "if you see "module" ... then you must either parse a Module or fail entirely"
11:36:57 <trap_exit> nolrai66: if I misunderstood, please enlighten me
11:37:01 <indiagreen> nolrai66: nope, because it won't backtrack
11:37:10 <indiagreen> ouch, I meant “trap_exit”
11:37:28 <quchen> trap_exit: You can do it without backtracking. http://lpaste.net/117484
11:37:29 <trap_exit> indiagreen: so you're saying nolrai66 is right ?
11:37:31 <indiagreen> if parseModule fails, it won't try parseOtherStuff
11:37:58 <trap_exit> indiagreen: can you explain to me why ?
11:38:00 <clrnd> wooo backtracking!
11:38:22 <indiagreen> because “a <|> b” doesn't try b if a has consumed input
11:38:24 <EvanR> joe9: theres Binary
11:39:00 <EvanR> or if you want readable serialization, pretty print JSON
11:39:36 <indiagreen> trap_exit: from description of <|>: “The parser [p <|> q] is called predictive since q is only tried when parser p didn't consume any input (i.e.. the look ahead is 1). This non-backtracking behaviour allows for both an efficient implementation of the parser combinators and the generation of good error messages.”
11:39:58 <joe9> EvanR, ok, thanks. I will check up on pretty print JSON.
11:40:05 <EvanR> check out aeson
11:40:07 <nolrai66> trap_exit: 'optional' does what you are thinking 'try' does. All try does is if the given parse fails, it doesn't count as having consumed input for '<|>'.
11:41:01 <trap_exit> indiagreen , nolrai66: so does 'try' (1) consume input, or (2) peek but does not consume input, or (3) consumes the input, but marks it as 'pretend I did not consume input' ?
11:41:20 <srhb> trap_exit: try p consumes no input iff p fails
11:41:48 <trap_exit> try p <-- if p succeeds, it consumes; if p fails, it consumes nothing ?
11:41:51 <srhb> Yes
11:41:54 <trap_exit> srhb: got it, this all makes sense now
11:42:00 <quchen> srhb: Not "iff": p might not consume input itself, but be successful. :-)
11:42:02 <trap_exit> srhb, indiagreen, nolrai66: got it all, thanks!
11:42:10 <srhb> quchen: Woops, thanks!
11:42:13 <trap_exit> parsec combinators -- gotta catch them all!
11:42:34 <EvanR> Data.Aviary combinators, gotta spot them all
11:43:21 <quchen> srhb: Trivial example, `try (return "foobar")`
11:43:38 <srhb> quchen: No, I know it, it was a brainfart :)
11:46:47 <quchen> srhb: The nice thing about "iff" is that you can always call it an accidential typo.
11:47:07 <srhb> quchen: Damn, I hadn't thought of that. Oh well, next time. ;)
11:47:19 <quchen> }:->
11:52:28 <ij> It's a bummer that lb doesn't have regex libs loaded.
11:53:02 <tom39291> Doors anybody know of any material that enumerates the ways of testing in Haskell, similar to http://blog.josephwilk.net/clojure/isolating-external-dependencies-in-clojure.html in clojure
11:53:15 <ij> Why doesn't "aa" =~ "a" :: [String] work or even typecheck w/ regex-tdfa?
11:54:12 <Zemyla> :t (/=)
11:54:13 <lambdabot> Eq a => a -> a -> Bool
11:55:30 * hackagebot folds-common 0.2.0.0 - A playground of common folds for folds  http://hackage.haskell.org/package/folds-common-0.2.0.0 (jozefg)
11:55:34 <ij> Zemyla, It's always amusing to read your nickname. :)
11:55:47 <edwardk> I just wrote up http://comonad.com/reader/2014/fast-circular-substitution/ -- can anyone throw me some feedback before the distribution gets too wide and everyone on the planet spots my typos?
11:58:43 <trap_exit> https://hackage.haskell.org/package/parsec-3.1.7 <-- what is the diff of Text.Parsec and Text.ParserCombinators ?
11:59:01 <indiagreen> the latter is for compatibility with parsec 2, I think
12:00:31 <trap_exit> so I want to use Text.Parsec
12:00:35 <trap_exit> and just ignore Text.ParserComibnators ?
12:02:46 <edwardk> trap_exit: yes
12:02:57 <trap_exit> edwardk: cool, thanks!
12:06:59 <trap_exit> oh wow parsec is fun
12:07:05 <trap_exit> i would ahve never had thought parsing = fun
12:07:07 <trap_exit> but parsec is something else
12:07:41 <EvanR-work> fun, i remember when fun stuff in haskell was described as head exploding
12:08:43 <Apocalisp> edwardk: With Bound, how do you deal with top-level declarations and recursive definitions?
12:09:32 <edwardk> Apocalisp: you can keep the top level declarations in the 'free' environment if you want, remember the variables can be anything you want.
12:09:39 <edwardk> strings referencing the environment, etc.
12:09:49 <Apocalisp> yeah, good point
12:09:52 <edwardk> you can do recursive definitions with something like
12:10:24 <edwardk> Let [Scope Int Expr a]  (Scope Int Expr a) -- now the terms in the let-rec style Let can reference each other, and the body on the right can also reference them all
12:11:05 <clrnd> reactjs is the first frontend thingy I can admit is actually a good idea
12:12:04 <Apocalisp> edwardk: Yeah, that's awesome
12:12:25 <Apocalisp> edwardk: The code before Bound: https://github.com/runarorama/extprot/blob/master/src/main/scala/compiler/Types.scala
12:12:35 <Apocalisp> (working on the "after")
12:13:18 <edwardk> apocalisp: did you see the article i just wrote?
12:14:28 <Chathurga> What do people use on the frontend here? I'm frozen in fear, I used to only code in JS/hybrids now I don't know what's going on
12:14:47 <sindikat> Is it possible to implement zip via fold elegantly? My intermediate try: zip :: [a] -> [b] -> [(a, b)] zip xs ys = snd $ foldr (\x ((y:ys),a) -> (ys,(x,y):a)) (reverse ys,[]) xs
12:15:01 <clrnd> Chathurga, I experienced a simillar moment 2 weeks ago, when they assigned this proyect to me :P
12:15:03 <Saizan> edwardk: no glaring typos :)
12:15:49 <Chathurga> I want to maybe pick elm but I don't know, I'm really clueless now
12:15:50 <clrnd> in one day I tried angular, meteor, backbone, ember and combinations, and felt really bad for the world
12:16:06 <Chathurga> Yeah same
12:16:15 <EvanR-work> theres ghcjs ;)
12:16:29 <clrnd> but reactjs is really smart (I ahd to learn about browserify and js build tools before)
12:16:49 <clrnd> I considered ghcjs and elm, even clojurescript
12:16:58 <Chathurga> I'm not sure I can add GHC as a dependency is the problem
12:17:40 <Chathurga> I compromised by building the site in Scala
12:17:50 <EvanR-work> how is that :S
12:17:52 <clrnd> but JS is not that bad, and my problem is quite simple and small
12:18:31 <EvanR-work> Chathurga: if youre a java shop... you could do like us and use react
12:19:29 <Chathurga> I'm just a me shop, got hired by a startup to rebuild everything because the last people were... bad
12:19:46 <Chathurga> I could swing Scala but I couldn't go full Haskell
12:20:09 <carter> Chathurga: make is a micro service architecture :)
12:20:13 <carter> and spec out the apis
12:20:20 <carter> and then wirte bits in haskell when its more convenient
12:20:21 <carter> :)
12:20:25 <EvanR-work> heh, "we got burned getting a dude write a bunch of custom php" "ok lets rebuild it all in scala"
12:20:31 * hackagebot ini 0.3.0 - Quick and easy configuration files in the INI format.  http://hackage.haskell.org/package/ini-0.3.0 (ChrisDone)
12:20:32 <carter> EvanR-work: lol
12:20:35 <carter> true though
12:20:43 <carter> people are bad at tech strategy
12:21:39 <clrnd> the twitter parable
12:22:27 <Chathurga> There isn't much chose for type safe web frameworks in functional (ish) languages
12:22:53 <Chathurga> Finding a replacement Haskell dev in my area would be near impossible
12:23:13 <EvanR-work> what about replacement scala?
12:24:19 <sgregory_> w/ enough java interop that's less of a stretch
12:24:22 <Chathurga> Much easier
12:27:09 <carter> Chathurga: where are you based
12:27:54 <Chathurga> Europe, not the big ones
12:28:20 <carter> not the big whats
12:28:30 <carter> all the cool fp folks are in europe!
12:28:39 <carter> schengen region?
12:29:07 <EvanR-work> luxembourg
12:29:13 <clrnd> maybe it's like, luxemburg
12:29:13 <Chathurga> Ireland
12:29:17 <clrnd> lol
12:29:27 <Norfair> Zurich :)
12:29:49 <Norfair> the Netherlands too
12:29:51 <clrnd> ireland, really ... isn't like half FPers from UK
12:30:02 <Norfair> and google has a haskell project in Munich
12:30:17 <carter> Chathurga: basically, theres more people than you probably expect
12:30:21 <ij> Why doesn't "aa" =~ "a" :: [String] work or even typecheck w/ regex-tdfa?
12:30:24 <carter> its just theyre in the closet because they want jobs
12:30:39 <hiptobecubic> I wouldn't mind going back to utrecht to take some courses
12:31:56 <EvanR-work> ij: well, whats the type of =~
12:32:28 <sm> Chathurga: I'm from there, I'll back you up
12:33:09 <carter> Chathurga: seeeeee :)
12:33:21 <sm> "random guy on irc said haskell would be fine" "ah lovely, go ahead then"
12:33:21 <carter> Chathurga: also if you hit a bug in ghc, its much easier to patch than the JVM
12:33:25 <Chathurga> The choice is already firmly made I'm afraid, didn't have the confidence at the time!
12:33:35 <EvanR-work> carter: they want jobs? meaning, hiding the fact because they think it will hurt job prospects?
12:33:41 <carter> yup
12:33:51 <EvanR-work> not that im disagreeing but wtf
12:33:57 <hiptobecubic> depends on the job
12:33:57 <carter> some employers have a strong anti weeny bias
12:34:06 <hiptobecubic> it's not just that
12:34:20 <kadoban> Is there any commonly recommended reading on GADTs to get started with exactly what they are and what they're useful for?
12:34:29 <hiptobecubic> sometimes you aren't going to be using haskell, and then it's important to know that the person you're hiring knows what's appropriate and what isn't
12:34:43 <carter> hiptobecubic: yes, but they dont ask that
12:34:49 <Chathurga> sm: What uni did you attend, if you don't mind me asking
12:35:04 <carter> hiptobecubic: so it bcomes managing what do people REALLY mean when they ask stuff in an interview
12:35:19 <carter> and it gets all touchy feely
12:35:57 <hiptobecubic> carter, well for me it was simply "do you know why or why not you'd use a functional style in python?"
12:36:03 <EvanR-work> "whats a closure"
12:36:06 <EvanR-work> "ha trick question!"
12:36:20 <carter> hah
12:36:21 <kadoban> "I wouldn't use functional style in python, because #python would yell at me"
12:36:35 <sm> Chathurga: TCD, engineering
12:36:42 <carter> a friend of mine actually things its esier to emulate monads in VBA than Python
12:36:50 <carter> because you have proper jumps in vba
12:36:53 <clrnd> jajaja
12:36:54 <hiptobecubic> kadoban, #python gets some things pretty wrong.
12:37:00 <Chathurga> "tail call optimization is unpythonic"
12:37:12 <EvanR-work> does python even have lexical scoping yet?
12:37:19 <clrnd> now they want type anotations, really weird
12:37:21 <kadoban> hiptobecubic: Yeah. Overall it's pretty good, but sometimes...yeah.
12:37:58 <carter> EvanR-work: nope
12:38:01 <pyon> carter: "easier to emulate monads in VBA" --> That is going too far. I use VBA in my day job, and, no, nothing of interest is easy.
12:38:01 <ij> EvanR-work, Right, I should've applied more thinking. I just looked at an example that was supposedly right and just stopped thinking.
12:38:15 <carter> pyon: i didnt' say the result was composable :)
12:38:17 <ij> Look at the typeclass instances, got it right.
12:39:01 <carter> pyon: i'm told that ermine can be used to target vba
12:39:03 * EvanR-work shocked and awed at pyon's day job
12:44:18 <platz> kadoban: https://www.haskell.org/haskellwiki/GADTs_for_dummies http://vimeo.com/12208838 http://en.wikibooks.org/wiki/Haskell/GADT http://www.seas.upenn.edu/~sweirich/talks/GADT.pdf (first 10 slides)
12:44:35 <kadoban> platz: Cool, thanks
12:45:16 <thebnq> edwardk: "Then we can use start off the..." not quite a typo
12:45:29 <edwardk> thx
12:45:47 <edwardk> fixed
12:50:16 <zoug> hey guys
12:50:26 <zoug> i'm wondering if i should start learning haskell
12:50:27 <clrnd> hi
12:50:31 <clrnd> yes you should
12:50:49 <zoug> i'm not sure it'll do me any good
12:50:52 <ajcoppa> zoug: there's a great channel at #haskell-beginners with a really helpful guide to help you get started
12:51:19 <clrnd> zoug, haskell is a non-strict, lazy by default pure functional language
12:51:32 <kadoban> zoug: It's a fun language, and even if you end up hating it, you'll learn some abstractions and general ideas that will stick with you.
12:51:46 <clrnd> you are saying you already know about those subjects?
12:52:04 <zoug> not much
12:52:16 <zoug> i've been introduced to those sort of things in university
12:52:49 <pyon> kadoban: A GADT can be used to implement something like a "closed type class" (nobody else can define more instances other than your own). Now, if you recall from the expression problem, the advantage of defining a closed family (e.g., an algebraic data type) is that you can safely case-analyse on its members. If all you have is open families (e.g., classes with inheritance), you need to use a workaround called "Vis
12:52:49 <pyon> itor pattern", which is notoriously verbose.
12:52:51 <zoug> thank you ajcoppa i'll go check it out:!
12:53:00 <clrnd> in my experience, it may well be the very best thing I learned in my life, next to bash and piano
12:53:25 <zoug> oh ok clrnd haha
12:53:40 <zoug> thanks for your answers!
12:53:41 <clrnd> zoug, hey it's not an overstatement, it opened my eyes in many ways
12:54:03 <clrnd> I wasn't even interested in programming before ahskell, thought all languages where the same ideas with different keywords
12:54:31 <zoug> yeah that's how i feel more or less!
12:55:02 <kadoban> pyon: Hmm, thanks for that summary, I think that makes sense, or at least more sense than the descriptions on wikipedia, haha.
12:55:10 <EvanR-work> haskell is a good starting point to find out how much else there is out there
12:55:24 <pyon> kadoban: For a concrete example, take this: http://zenzike.com/posts/2010-12-10-from-polymorphic-to-polytypic
12:55:40 <pyon> kadoban: It uses the visitor pattern at the type-class level. With GADTs, you could get rid of the visitor.
12:55:46 <clrnd> exactly, then you learn about idris, erlang, ocaml, scala, etc and programming becomes fun again!
12:56:46 <EvanR-work> or you get an advanced degree in mathematics or theoretical computer science as a side effect
12:57:21 <clrnd> yeah that too, I studied engeeniering before haskell, then I got into CS
12:57:25 <clrnd> literally
12:57:36 <EvanR-work> literally engeeniering?
12:58:02 <clrnd> they call it 'Informatics Engeeniering' here
12:58:19 <EvanR-work> ok engineering
12:58:22 <clrnd> it's a mix of OOP and project management
12:58:38 <clrnd> oh sorry
12:59:05 <clrnd> always misstype that one, it's different but not enough in spanish
13:00:05 <trap_exit> @hoogle M a -> (a -> b) -> M b
13:00:07 <lambdabot> Warning: Unknown type M
13:00:07 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:00:07 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
13:00:15 <trap_exit> @yahoo M a -> (a -> b) -> M b
13:00:15 <lambdabot> Unknown command, try @list
13:00:37 <trap_exit> @hayoo M a -> (a -> b) -> M b
13:00:37 <lambdabot> Unknown command, try @list
13:00:39 <sivteck> :t flip fmap
13:00:40 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:00:59 <nkar> you can query lambdabot, btw
13:01:13 <sivteck> trap_exit, that's flip fmap
13:01:17 <trap_exit> on wow ...
13:01:21 <EvanR-work> :t (<&>)
13:01:21 <trap_exit> I finally get fmap now
13:01:22 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:01:27 <trap_exit> I thought I wanted "lift" of some sort
13:01:27 <trap_exit> but I guess I want fmap
13:01:38 <EvanR-work> fmap is the bomb.com
13:01:57 <trap_exit> EvanR-work: you have been added to the NSA, CIA, and FBI lists
13:02:37 <EvanR-work> as an anarchist, ive been on those lists for years
13:03:05 <EvanR-work> imagine if you were the guy who owned the dang domain
13:03:43 <trap_exit> I can think of worse domains to own, like ....
13:03:43 <trap_exit> ocaml.com
13:03:59 <EvanR-work> i know right
13:05:33 * hackagebot hindent 4.1.0 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.1.0 (ChrisDone)
13:06:12 <xplat> ocaml sounds irish, arab, californian and canadian all at the same time
13:07:39 <xplat> and actually *is* french.  how could it be more unamerican?
13:08:20 <xplat> i guess it could be called kim jong ocaml
13:08:55 <trap_exit> ebola-caml
13:09:13 <nkar> could you please go to #haskell-blah?
13:10:49 <trap_exit> nkar: I don't understand the harm of humorous banter when there's not an actual haskell technical conversation going on
13:12:00 <nkar> trap_exit: maybe that's the reason why there aren't any technical conversations
13:12:26 <EvanR-work> every time you humorous banter god decapitates a kitten
13:12:26 <indiagreen> the harm might be in the fact that people pay less attention to the channel when there's banter
13:12:36 <indiagreen> so, legitimate questions end up not answered, because nobody looked
13:12:39 <trap_exit> if anyone has a technical question, please ask, I will do my best to help answer it
13:12:48 <indiagreen> on the other hand, no banter at all = the channel might die
13:13:17 * indiagreen always thought “seriousness” was a half-legitimate illness
13:14:27 <johnw> indiagreen: I've seen other good channels be killed by banter over time
13:14:30 <trap_exit> I ahve a tehcnical question:
13:14:50 <trap_exit> so I'm using Parsec, http://hackage.haskell.org/package/parsec ... but I'm not using "import", I'm only using "import qualified"
13:15:00 <trap_exit> so is there a way to say "import all of Text.Parsec as TP" ?
13:15:40 <trap_exit> right now, i"m lke "import qualified Text.Parsec.Char as TPC" "import qualified Tet.Parsec>Combinator as TPCo", "import qualified Text.Parsec.Text as TPT" ...
13:15:58 <indiagreen> you can just import all of them as “TP”
13:16:07 <xplat> trap_exit: you can use the same prefix in more than one 'import qualified'
13:16:09 <indiagreen> several modules can be imported under one qualified name
13:16:29 <clrnd> isnt haskell beautiful?
13:17:11 <trap_exit> xplat, indiagreen: taht is intresting, I have no idea why I assumed all qualified imports have to be different names
13:18:03 <indiagreen> I assumed it too until somebody mentioned it, so at least you're not alone
13:19:37 <clrnd> I ssume dit until I saw someone import al of blaze-hmtl under the same name
13:20:31 <trap_exit> what's a good tutorial on using parsec to parse _white space important_ languages, like haskell / python ?
13:20:33 * hackagebot RFC1751 0.3.0.1 - RFC-1751 library for Haskell  http://hackage.haskell.org/package/RFC1751-0.3.0.1 (XenoGenesis)
13:21:29 <EvanR-work> white space is important in most languages, a b c vs abc ;)
13:21:53 <mmmm> trap_exit: There is a library called "indent" or "indentation" or something like that
13:22:05 <trap_exit> mmmm : for parsing such languages?
13:22:10 <mmmm> yes
13:22:15 <mmmm> what exactly are you trying to parse?
13:22:53 <trap_exit> a mini Haskell -like language
13:22:59 <trap_exit> sorta like Fay
13:24:24 <zipper> Denommus: Hey would you mind a PM?
13:30:38 <trap_exit> man, parsing haskell is such a pain, white sspace parsing = urgh
13:35:16 <wavewave> hi.
13:38:28 <Denommus> trap_exit: that's one of the things I hate the most about Haskell, indeed
13:38:49 <trap_exit> well, I don't hate haskell
13:38:58 <trap_exit> I just think the existing primitives of regex / cfg
13:39:03 <trap_exit> are not very well suited for "white space is simportant"
13:39:39 <trap_exit> if I could have a two phase parsing of (1) de-sugar white space, and (2) parse, ... I'd be happy, but I don't think I can do (1) without parsing along the way
13:42:29 <trap_exit> hmm, is parsec even suited for parisn ghaskell?
13:42:32 <Denommus> trap_exit: I don't hate Haskell, I hate THAT about Haskell
13:42:35 <trap_exit> it's not obvious to me how to take white space / indentation into account via parsec
13:42:47 <Denommus> trap_exit: parsec is probably suited to parse anything :-P
13:43:07 <Denommus> you just need to combine the right parsers
13:43:59 <EvilTerran> trap_exit, perhaps a good place to start would be to count leading whitespace as a type of token?
13:43:59 <wavewave> pass indentation context across parsers.
13:45:14 <wavewave> i.e. parameterise your parser with indentation level as a parameter
13:45:18 <trap_exit> EvilTerran , wavewave: so instead of spaces = many (char ' ' <|> char '\t') ... what should I do ?
13:45:52 <wavewave> trap_exit: what do you want to parse now? definitely not spaces.
13:46:11 <EvilTerran> so your token ADT would include a constructor for your tokeniser to  generate when it encountered a newline followed by whitespace
13:46:12 <trap_exit> I'm writing a minimal haskell parser
13:46:19 <wavewave> trap_exit: some block statement.
13:46:21 <trap_exit> I have white space indentation in places like definitions of functions
13:46:23 <EvilTerran> data Token = ... | Indent Int
13:46:30 <EvilTerran> something like that
13:46:52 <trap_exit> I'm confused this look slike a token stage + parse stage
13:46:59 <trap_exit> I thought part of the point of parsec was "there is only one stage"
13:47:14 <EvilTerran> then, as wavewave suggests, your parser could take a current indentation depth as it recurses
13:47:28 <EvilTerran> trap_exit, as I understand it, the point is more "there *can* be only one stage"
13:47:39 <wavewave> yes.
13:47:41 <EvilTerran> nothing stops you writing a parsec parser that takes a [Token] instead of a [Char]
13:47:56 <trap_exit> EvilTerran: what does the type signature of "take the current indentation into account" look like?
13:48:12 <EvilTerran> you could pass around your current indentation as a parameter without having a tokenisation stage, it just might be more complicated
13:49:38 <EvilTerran> trap_exit, well... instead of parseExpr :: Parsec String Expr, it'd be parseExpr :: Int -> Parsec String Expr, I suppose
13:49:43 <wavewave> rule is simple: when you start to parse a new statement line, you need to know what indentation level you are in. then there must be a way to tell this to your parser function. easiest way is to give it as an explicit parameter.
13:54:51 <wavewave> of course you can make StateT on top of ParsecT to make this context passing implicit if you want. I don't recommend this until you really need it.
13:56:40 <EvilTerran> ReaderT might be suitable, even
13:58:14 <trap_exit> gentlemen, I figured this out
13:58:16 <trap_exit> I need a way to combine State + Parsec
13:58:20 <trap_exit> on right, wht wavewave just said
13:58:25 <trap_exit> how do I combine Parsec + State ?
13:58:26 <trap_exit> this is all I need
13:58:31 <gcganley> hey whats the current state of C# and haskell interaction?
13:58:48 <trap_exit> actually, EviLTerran is right, just reader + parsec sufices
13:59:00 <gcganley> im looking for a way to access haskell libraries from a .Net GUI app
13:59:12 <hiptobecubic>  Do we have that?
13:59:15 <hiptobecubic> I didn't think we did
13:59:27 <gcganley> because im much more experienced C# GUI developer than GTK or Qt developer
13:59:33 <hiptobecubic> gcganley, can you dip both ends into C-land?
14:00:04 <gcganley> hiptobecubic: ummm does C# allow native interop?
14:00:08 <gcganley> let me look
14:00:48 <hiptobecubic> gcganley, not that I think winforms or whatever it is is inherently bad, but knowing Qt is pretty useful.
14:00:50 <gcganley> i could import a dynamic library
14:01:15 <srhb> trap_exit: Parsec s u already has state u.
14:01:31 <gcganley> hiptobecubic: I'm working in a microsoft shop and we use visual studio lol
14:01:38 <trap_exit> srhb: this makes so much sense now
14:01:41 <hiptobecubic> gcganley, so grab one of the tutorials on writing a haskell library and using it from C, then write a C wrapper that handles the RTS and call it from C#
14:01:51 <srhb> trap_exit: Good :-)
14:01:52 <trap_exit> wavewave, evilterran, srhb: okay, this makes sense now, thanks!
14:02:03 <gcganley> hiptobecubic: sounds good i just wish it were easier :/
14:02:08 <trap_exit> who is porkys, and is anyone else getting pm-ed ?
14:02:19 <hiptobecubic> gcganley, sure :)  Although maybe for your own sake you might take a look. Someday you might want to deploy your projects to something other than windows.
14:03:00 <gcganley> hiptobecubic: I do, I'm use Arch linux at home everyday but in school we use winows
14:03:10 <hiptobecubic> gcganley, it's actually pretty straight forward from the haskell side I think.
14:03:23 <hiptobecubic> gcganley, really? Interesting, where is this?
14:03:47 <delrik> guys how do i shuffle an array in haskell?
14:03:49 <gcganley> hiptobecubic: the school?
14:03:56 <geekosaur> they were alread banned once
14:04:15 --- mode: ChanServ set +o geekosaur
14:04:21 --- mode: geekosaur set +b *!*@84.78.20.134
14:04:21 --- kick: porkys was kicked by geekosaur (porkys)
14:04:32 <geekosaur> probably be back under another nick later
14:04:45 <geekosaur> (again)
14:04:46 <gcganley> hiptobecubic: I'm not that good at coding GUI's by hand I've only used IDE's
14:05:03 --- mode: geekosaur set -o geekosaur
14:09:43 <platz> delrik: I have no idea how current this is or if there is a better way, but it probably works https://www.haskell.org/haskellwiki/Random_shuffle
14:10:07 <delrik> thx dude, I checked that out!
14:10:17 <delrik> I was hoping for something in prelude =)
14:14:33 <trevorriles> Is it recommended to use stackage over hackage?
14:17:44 <mmmm> trevorriles: depends who you ask
14:17:47 <Haskellfant> trevorriles: if you're trying to use yesod probably yes, apart from that hackage works (most of the time) just fine
14:20:36 * hackagebot text-ldap 0.1.1.1 - Parser and Printer for LDAP text data stream  http://hackage.haskell.org/package/text-ldap-0.1.1.1 (KeiHibino)
14:22:26 <Haskellfant> Is there a way to partially apply the nth argument in haskell? The first and second are obviously easy using flip or sections for the second one. You can also write functions to apply the third, fourth, … argument, but then you need a separate function for each n
14:22:47 <johnw> Haskellfant: lambdas
14:23:20 <Haskellfant> johnw: well, that is the same as writing a separate functions to apply the third, fourth, … argument
14:23:41 <johnw> well, except for not naming it
14:23:41 <Zekka> Haskellfant: There's not a builtin easy-to-use point-free trick AFAIK
14:24:14 <Zekka> Haskellfant: IIRC there's at least one library witten around things like that, let me find it
14:24:28 <johnw> pointless-fun has some combinators
14:24:32 <Thrzsh> Are there answers posted anywhere to the typeclassopedia exercises?
14:24:35 <johnw> but only for when the nth argument is the last argument
14:24:37 <EvilTerran> you could do it with template haskell, and Oleg's probably come up with something devious using typeclasses
14:24:38 <Zekka> I was thinking of 'plumbers'
14:24:38 <prophile> Haskellfant: how would the types line up for doing it on the nth argument?
14:24:47 <Zekka> https://hackage.haskell.org/package/plumbers <- that's here, but I haven't used it
14:24:48 <johnw> oh, yeah, plumbers...
14:24:57 <johnw> the package with the most operator names of any Haskell package :)
14:25:25 <Haskellfant> prophile: well you need a type a1->a2->…->an->an+1
14:25:30 <Haskellfant> Zekka: thx I'll take a look
14:25:44 <Haskellfant> johnw: more than lens? I'm scared to open it
14:25:52 <johnw> yeah, way more
14:25:59 <johnw> like, hundreds of them (most of them generated by template Haskell)
14:26:07 <Zekka> Haskellfant: There are 310 operators in Control.Plumbes
14:26:09 <Zekka> And that's not the only module
14:26:11 <Zekka> Plumbers*
14:26:46 <Zekka> Control.Plumbers.Monad contains probably a few more
14:27:01 <Zekka> I don't know exactly how many it expots and don't know how to count
14:30:37 <indiagreen> 621
14:30:49 <indiagreen> that's for Control.Plumbers.Monad
14:31:01 <indiagreen> counting “<<”
14:31:06 <Haskellfant> without descriptions, that's just crazy
14:31:36 <Zekka> 931 in total!
14:31:37 <Zekka> That's not bad!
14:31:59 <Zekka> Haskellfant: There's a pattern!
14:36:16 <EvilTerran> Haskellfant, you could do something like this in template haskell: flipN 0 = [| id |]; flipN n = [| \f x y -> $(flipN (n-1)) (f y) x |]
14:36:53 <Haskellfant> EvilTerran: ah cool, thx
14:37:13 <Haskellfant> Zekka: I think I'm too tired to figure the pattern out right now :D
14:37:16 <EvilTerran> Haskellfant, but you're not allowed to use it until you've figured out how it works! :P
14:37:43 <Haskellfant> EvilTerran: ofc, I don't want to use it anyway. I just wanted to know if it's possible and if so how :)
14:39:12 <EvilTerran> note  $(flipN 1)  =  \f x y -> $(flipN 0) (f y) x  =  \f x y -> id (f y) x  =  \f x y -> f y x  =  flip
14:42:29 <Haskellfant> EvilTerran: ah I think I got it, thanks again
14:42:43 <osa1> anyone here using cabal-db? how can I point it my library which is not on hackage?
14:42:49 <Twisol> How can I write a Cabal package so that it will check for and link against a dynamic library when installed?
14:43:17 <Twisol> By "dynamic library" I mean a preexisting C-based .so
14:43:50 <EvilTerran> Haskellfant, happy to help :)
14:45:36 * hackagebot yaml-light-lens 0.3.1.6 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.1.6 (AnthonyCowley)
14:51:07 <Intolerable> is it possible to compose lenses with applicative?
14:51:23 <Intolerable> like getting something useful out of (,) <$> to id <*> to id
14:51:38 <Intolerable> (i.e. for this example a Getter a (a, a))
14:51:47 <johnw> why not just to (join (,))?
14:52:23 <Intolerable> its a very simplified example
14:52:33 <Intolerable> ideally id be composing stuff that's a little more complex
14:54:21 <johnw> i'd try #haskell-lens
14:55:05 <Intolerable> ty
15:06:06 <Peaker> Intolerable: if you compose lenses with applicative:  foo f (Foo a b) = Foo <$> someLens f a <*> someLens2 f b   you get a traversal
15:07:40 <mgsloan> Haskellfant: They would have descriptions if TH allowed you to generated haddocks
15:07:52 <Haskellfant> mgsloan: fair enough
15:08:18 <mgsloan> Plumbers are very systematic, kinda like a mini language (it's actually an infinite set of operators), but I don't recommend their use
15:08:47 <mgsloan> My last release removed the "combinator" category etc and instead put them in "acme" where they belong
15:09:25 <mgsloan> Part of me wishes I'd gone with a cap of 2-arity, then people might actually use them.  3 arity is a bit much
15:09:52 <johnw> since probably no one uses the 3 arity stuff, you could just drop it with a major release
15:09:54 <mgsloan> Better to have an operator convention than coming up with operator names willy nilly
15:09:57 <mgsloan> true!
15:10:39 <mgsloan> In order to do that I'd have to actually start using them :P
15:10:44 <johnw> haha
15:10:59 <mgsloan> (otherwise it's a change without real world experience with em)
15:11:18 <johnw> well, at least it makes for an interesting outlier in any Hackage statistics
15:11:28 <mgsloan> hehe yuup
15:22:29 <greymalkin> Do cabal-defined executables always have to duplicate the build-depends of the library they're testing?
15:22:52 <greymalkin> (or at least the portions on which the portion they're testing depends?)
15:23:59 <lf94> OK, I am writing a directory walker, but would like to track how deep I am, and what file I'm at. What's the best way to pass this information around?
15:24:47 <mmmm> lf94: do you know about zippers?
15:24:50 <Peaker> lf94: you can either pass a simple parameter to your recursive call
15:24:59 <Peaker> lf94: or use a Reader monad
15:25:05 <Peaker> lf94: the former sounds simpler
15:25:43 <EvanR-work> comonads!
15:26:22 <lf94> Peaker: yeah, passing a parameter sounds better...
15:26:43 <lf94> mmmm: Yea I know about them but don't have a good understanding
15:27:57 <Peaker> mmmm: I don't think he needs zippers here
15:28:36 <lf94> Peaker: I thought using a Tree would be the best way to do this
15:29:23 <lf94> Peaker: but I decided against it- I don't want to save the data structure.
15:29:46 <EvanR-work> directories are already trees, this is about the process of traversing it with a recursive procedure
15:30:03 <EvanR-work> on each recursive call you pass in (n+1)
15:30:48 <lf94> EvanR-work: I thought n-1/+1 recursion was looked down upon
15:31:19 <EvanR-work> eh?
15:31:37 <kadoban> lf94: Do you mean n+k patterns? That's a different thing.
15:31:40 <fread2282> what are the other ways to implement an IO Monad? links?
15:32:10 <lf94> kadoban: Yeah that!
15:32:21 <lf94> Isn't this n+k
15:32:45 <Peaker> lf94: no.. you pass (1+depth) to recursive call
15:32:54 <Peaker> lf94: the "backtracking" is automatic, you don't need to subtract 1
15:33:09 <Peaker> Exiting the recursive call "loses" the 1+depth, and you gain back the old "depth" you had in that scope
15:33:20 <kadoban> lf94: Yeah, that's just a syntax for pattern matching that turned out to be a mistake. That doesn't mean you can't do recursion on n+1 or n-1, you just don't do it via pattern matching of exactly that type.
15:33:47 <Peaker> why would he recurse to n-1?
15:34:35 <kadoban> I was speaking in general, responding to his question about n-1/+1 recusion being looked down upon. I don't know what problem he's actually trying to solve.
15:40:39 * hackagebot text-ldap 0.1.1.2 - Parser and Printer for LDAP text data stream  http://hackage.haskell.org/package/text-ldap-0.1.1.2 (KeiHibino)
15:42:01 <Twisol> Is it possible to have Cabal statically link a C library into a library (not an application)? Or some other way to prevent the user of the library from having to explicitly pass the static library to ghc --make?
15:49:05 <greymalkin> either package is not building for me (clean sandbox)
15:50:46 <greymalkin> Wrong category of family instance; declaration was for a type synonym   In the newtype instance declaration for ‘StT’  In the instance declaration for ‘MonadTransControl (EitherT e)’
15:52:50 * gienah thought either-4.3.2.1 compiled with monad-control-1.0.0.1
15:52:54 <wyager> Why does "args <- getArgs; print args" work as expected, but "fmap print getArgs" does nothing?
15:53:27 <johnw> wyager: the resulting types mean different things
15:53:37 <EvanR-work> :t fmap print getArgs
15:53:38 <lambdabot> Not in scope: ‘getArgs’
15:53:53 <wyager> getArgs is in System.Environment
15:54:02 <johnw> the former is IO (), the latter is IO (IO ())
15:54:08 <EvanR-work> IO (IO ())
15:54:25 <EvanR-work> join (fmap print getArgs) should work
15:54:34 <EvanR-work> or just getArgs >>= print
15:54:36 <wyager> Oh, duh
15:54:39 <wyager> Yeah
15:55:21 <benzrf> foo >>= bar = join (fmap bar foo)
15:55:26 <ij> I'm trying to get regex-tdfa working w/ ByteString, what am I doing wrong? http://sprunge.us/GPKV
15:55:27 <kadoban> wyager: GHC should give you a warning about fmap print getArgs to the effect that you're discarding something you probably don't mean to, IIRC.
15:55:31 <benzrf> is how (>>=) would be defined if we had join as a method
15:55:31 <johnw> wyager: if you had specified a type for main, there would have been an informative error
15:55:32 <kadoban> wyager: Just as a hint
15:55:39 * hackagebot haddock-api 2.15.0.2 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-api-2.15.0.2 (MateuszKowalczyk)
15:55:41 * hackagebot haddock 2.15.0.2 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.15.0.2 (MateuszKowalczyk)
15:55:52 <wyager> thanks
15:56:13 <greymalkin> Nevermind.. it was because library-profiling: True
15:56:41 <EvanR-work> class Applicative m => Monad m where (>>=) :: m a -> (a -> m b) -> mb; join :: m (m a) -> m a
15:57:15 <EvanR-work> :t extract
15:57:16 <lambdabot> Not in scope: ‘extract’
15:57:23 <EvanR-work> :t Control.Comonad.extract
15:57:23 <ReinH> johnw: o/
15:57:24 <lambdabot> Control.Comonad.Comonad w => w a -> a
15:57:29 <ReinH> johnw: happy holidays!
15:57:40 <johnw> ReinH: you too!!
15:58:10 <ReinH> :)
16:06:38 <pyon> Not sure if this is the best place to ask, but does this look like a correct description of the rules for GADTs? http://mathb.in/25561
16:24:03 <aristid> johnw: gitlib is cool but i wish the docs were not hopelessly outdated :>
16:25:12 <lf94> How do I extract String from IO String (or any type for that matter)?
16:27:41 <Peaker> lf94: you can't extract stuff from IO -- but you can lift your computations INTO IO
16:28:08 <Peaker> or you could say you "extract" from IO into a callback that is also forced to run in IO (via >>=)
16:28:41 <lf94> Peaker: ah, ok
16:28:52 <lf94> So return lifts a type into the monad?
16:30:08 <benzrf> lf94: no, it lifts a value into the monad
16:30:29 <benzrf> Peaker: (>>=) does not extract any more than fmap does...
16:30:44 <benzrf> in fact, it extracts literally exactly as much
16:30:46 <lf94> benzrf: Well it is making a String into an IO String.
16:30:53 <lf94> I'd say that's lifting a type
16:30:56 <benzrf> lf94: yes, "a string"
16:30:57 <benzrf> thats a value
16:30:57 <benzrf> :)
16:30:58 <lf94> Anyways thanks!
16:31:01 <lf94> Ok ok :)
16:37:34 <Buttons840> I want to make an AI for the card game Coup in Haskell (coup is a bluffing card game). In an imperative language I would have a collection of player objects with a common interface and take turns consulting them about what move they want to make through the API....
16:37:43 <Buttons840> any suggestions how I might design it in haskell?
16:39:06 <Buttons840> a collection of functions instead of objects I guess?
16:42:10 <buckmaster> Buttons840: have you seen the recent rhead on reddit about a card game?
16:42:15 <buckmaster> might be a good example to follow
16:43:29 <buckmaster> Buttons840: http://www.reddit.com/r/haskell/comments/2qkpr8/beginner_question_sequentially_and_conditionally/
16:43:30 <Buttons840> buckmaster: no, thanks for mentioning it
16:47:51 <EvanR-work> Buttons840: as a basic alternative to oop, you might want to experiment with replacing your objects with threads which wait for requests, answer them, and then continue waiting
16:48:07 <adas> say I have "fn :: (Fractional a, Num b) => a -> b" and another "fn' :: (Integral a) => a -> Char" and I do "fnfn = fn' (fn 3.14)", it typechecks. No problem. My question is, since fn can return any one of "Int, Integer, Float, Double", what would happen if fn returns either "Float or Double" and fn' cannot take it anymore?
16:48:36 <EvanR-work> might be kind of clunky in haskell but it is more conceptually clear that is what the design is, and allows concurrency if necessary (replace AI with a human)
16:49:08 <adas> so shouldn't it not typecheck
16:49:32 <EvanR-work> the thread part is nice but the interface to make it nice to write the game application might take some elbow grease
16:50:11 <EvanR-work> modeling real-world scenarios might be one spiritual basis for oop design
16:56:22 <trap_exit> i'm confused by "sepBy p sep" ... does it assume that THE REST OF THE INPUT can be expressed by p's seprated by sep? (this is parsec)
16:56:50 <trap_exit> is there something like a "greedy sepby" ... i.e. do as many p sep p sep p sep p sep as you can ... but then when you can't any more, instead of error-ing, just stop ?
16:58:47 <benzrf> trap_exit: isn't that what it is
16:59:15 <ReinH> trap_exit: that's what setBy does...
16:59:20 <ReinH> *sepBy
16:59:29 <trap_exit> The first tool is the sepBy function. This function takes two functions as arguments: the first function parses some sort of content, while the second function parses a separator. sepBy starts by trying to parse content, then separators, and alternates back and forth until it can't parse a separator. It returns a list of all the content that it was able to parse.
16:59:41 <trap_exit> so it expects to 'fail to parse a sep' to end, but is unhappy when it 'fails to parse a p' to end
17:00:00 <ReinH> Correct
17:00:19 <ReinH> It's designed to parse things like lists
17:00:19 <trap_exit> ah, I thin kI wnat endBy
17:00:25 <trap_exit> and a new keyboard
17:00:28 <ReinH> where [foo, bar] should parse but [foo, bar,] shouldn't
17:01:16 <trap_exit> okay got it, I think I understand sepBy vs endBy now :-)
17:02:12 <gcganley> are there any good blog posts or guides for ffi and interoping with C?
17:02:38 <gcganley> i found real world haskell chapter 17
17:02:46 <gcganley> just curious if there is anything else
17:12:36 <ByronJohnson> New version of netwire! \o/
17:19:35 <dgomez> hello, any chance I could get some feedback on these pretty lame functor exercises >  then build onto some more complex functor expressions using types like Trees?
17:19:44 <dgomez> http://lpaste.net/117491
17:20:08 <dgomez> I think I am becoming a bit more comfortable with understanding the syntax more fluidly
17:22:22 <adas> is there a tool to understand why ghci thinks that a variable must have a certain type?
17:22:52 <dgomez> adas: isn't every value (thus every variable) in haskell a "type"?
17:23:20 <dgomez> adas: either from a type class or a type defined by data?
17:23:58 <HeladoDeBrownie> dgomez, you have some syntax and type errors. have you tried running your attempts?
17:24:22 <HeladoDeBrownie> adas, if it's something ghci is doing as opposed to (non-interactive) ghc, it might be due to defaulting. what's a specific example?
17:26:57 <EvanR> dgomez: not every value in haskell is a type. actually, types are not values in haskell
17:27:02 <kadoban> dgomez: In the Functor one, where did 'f' and 'g' come from on the right side?
17:27:13 <adas> HeladoDeBrownie: dgomez am in a situation where I think a var is a certain type. ghci tells me, it is another type..
17:27:30 <adas> HeladoDeBrownie: dgomez so I wanted to know how did ghci deduce that it was a different type
17:27:41 <adas> using holes helps "_"
17:27:43 <kazagistar> dgomez: I think you meant "every variable has a type" or something?
17:27:44 <HeladoDeBrownie> adas, yes, i'm asking what that situation is. i can more easily tell you what's going on if you tell me that
17:28:32 <adas> HeladoDeBrownie: oh .. i have a line of code like "product [1..n]". i know n is an Int. ghci tells me it should be a double
17:28:48 <adas> because im using the result of that in another division computation
17:29:00 <HeladoDeBrownie> adas, show some actual code, whatever is necessary to know n :: Int. use lpaste, mentioned in the topic
17:29:01 <adas> so im using fromIntegral
17:29:04 <kadoban> :t (/)
17:29:05 <lambdabot> Fractional a => a -> a -> a
17:29:10 <kadoban> :t div
17:29:10 <lambdabot> Integral a => a -> a -> a
17:29:18 <dgomez> <EvanR> all right. so then as <kazagistar> states variables must refer to a type?
17:29:58 <kazagistar> dgomez: that is exactly not what I said
17:30:02 <benzrf> dgomez: normally we dont put <> around nicks
17:30:09 <benzrf> dgomez: fyi
17:30:20 <dgomez>  <HeladoDeBrownie> I did run it through ghc; I got a parse error on line 8 but I tried placing a space in the arrow but it still doesn't parse through
17:30:38 <lpaste> adas pasted “how does ghci deduce type” at http://lpaste.net/849059070995333120
17:30:50 <HeladoDeBrownie> dgomez, line 8 is fine, line 9 is not
17:31:12 <HeladoDeBrownie> dgomez, i'm actually confused why you wrote what you did on line 9
17:31:14 <kazagistar> dgomez: a variable usually refers to a value. It HAS a type, but it does not refer to one (except type variables)
17:31:18 <dgomez> kazagistar: sorry I meant to place an OR
17:33:07 <HeladoDeBrownie> adas, so, you defined that function in ghci and say it gives the wrong types for something?
17:33:17 <HeladoDeBrownie> adas, or did you define it in a source file and load it into ghci?
17:34:54 <adas> HeladoDeBrownie: source file.. and that code in lpaste typechecks. it was not typechecking earlier if i removed the fromIntegral
17:35:13 <HeladoDeBrownie> dgomez, why don't we start from the beginning? so, you want to define a Functor instance involving Either. do you know the type of fmap in that instance?
17:35:57 <HeladoDeBrownie> adas, ah, well it is wrong without the fromIntegral :) so, you sorted it out then?
17:36:01 <adas> HeladoDeBrownie: I used holes "_" to understand that ghci wanted 'n' to be Double. So I changed the type signature and added fromIntegral
17:36:09 <adas> HeladoDeBrownie: yes. Thank you : )
17:36:09 <dgomez>  HeladoDeBrownie: I was not sure how to create an instance of the reader monad ((->) e). From what I understood it is supposed to go through a list of elements such as (h:hs) meaning that h would be mapped out a a type e in the form of h's
17:36:22 <dgomez> HeladoDeBrownie: I feel like I am just spewing bull though...
17:36:39 <HeladoDeBrownie> dgomez, that's incorrect
17:36:59 <HeladoDeBrownie> dgomez, it seems like you're confused on several levels so let's go through it step by step, starting with the question i asked
17:37:26 <HeladoDeBrownie> dgomez, it's okay if the answer is no, if it is then we'll go over that too
17:37:30 <dgomez> HeladoDeBrownie: ok, i imagined so.  Let me go back to starting an instance of Functor using Either...
17:39:34 <HeladoDeBrownie> adas, oh, so you were looking for a more general rule for figuring out the types of things, right?
17:39:35 <dgomez> HeladoDeBrownie: ok an instance of Functor involving Either.
17:39:38 <dgomez> :t fmap
17:39:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:40:35 <dgomez> Would we substitute the function f with the instance of Either? or is that not correctly stated?
17:41:07 <HeladoDeBrownie> adas, well, in particular, when you have f :: A -> B and some x, then in the expression f x, x is constrained to be of type A, and that whole expression is constrained to be of type B
17:41:32 <HeladoDeBrownie> adas, once you have that rule, that enables you to deduce types a lot of the time by looking at the types of the functions you're applying
17:41:39 <hiptobecubic> Hey all. I'm looking at the wikibooks chapter on GADTs and they suggest implementing the eval function with their extended Expr type (http://en.wikibooks.org/wiki/Haskell/GADT#Extending_the_language).  I have done so but it seems really... shitty. Is there a nicer way to have done this? http://lpaste.net/117492
17:41:47 <HeladoDeBrownie> dgomez, right, f becomes a more specific type
17:42:54 <mmmm> hiptobecubic: You don't seem to have used a GADT
17:43:18 <hiptobecubic> mmmm, indeed not. They say it's instruct to try to do it without one first.
17:43:21 <HeladoDeBrownie> dgomez, so, let's look at the definition of the Functor class
17:43:22 <hiptobecubic> instructive*
17:43:43 <hiptobecubic> mmmm, "they" being the wikibook page. "Exercise: Despite our goal, it may still be instructional to implement the eval function; do this."
17:43:47 <HeladoDeBrownie> dgomez, pay attention just to the first two lines http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Base.html#Functor
17:44:05 <HeladoDeBrownie> dgomez, notice that f appears in what we call the "head" of the class definition and also in the type of fmap
17:44:23 <HeladoDeBrownie> dgomez, this means that whatever you write in the head of the instance is what gets substituted in for the f in the type of fmap
17:44:59 <mmmm> ok, yes the difficulty is then you have to "tag" the different types ie data Val = I Int | S String, you did this with Either
17:45:02 <HeladoDeBrownie> dgomez, let's start off by saying that your head for Either was almost correct. you wrote: instance Functor Either e where …
17:45:18 <HeladoDeBrownie> dgomez, your only problem was syntactical, it should be: instance Functor (Either e) where …
17:45:31 <HeladoDeBrownie> dgomez, starting from there, can you tell me how fmap specializes in this instance?
17:46:37 <hiptobecubic> mmmm, well. They did it with Either. It seems like either is a bad choice if you ever plan on having more than two types, but they are just making an example so sure, whatever. I'm asking more about properly unpacking the terms like i'm doing in the case expressions. Is that a reasonable way to do it? It seems really unsatisfying.
17:48:50 <hiptobecubic> You can write a function :: f -> (Either Int Bool) -> (Either Int Bool) -> Maybe (Either Int Bool) and use the applicative instance for Maybe i guess. But that just pushes all the special case handling down into the operator `f`
17:48:52 <HeladoDeBrownie> dgomez, and to be clear, all i'm asking you for right now is the type of fmap
17:49:14 <HeladoDeBrownie> dgomez, once you're sure what the type is, then we can write a witness for it :) (fancy way of saying a value of that type)
17:50:15 <mmmm> hiptobecubic: I can't think of any much nicer ways.. apart from writing it as a fold
17:50:29 <dgomez>  HeladoDeBrownie: mmm ok, I defined two types, h and f ? or in the case of the standard definition a and b?
17:50:30 <hiptobecubic> ah... hm
17:50:39 <HeladoDeBrownie> dgomez, nnno
17:50:45 <hiptobecubic> a fold you say. I can see how it kind of folds yeah...
17:50:57 <HeladoDeBrownie> dgomez, ignore what you wrote for now, we'll just start with what i said in channel here
17:51:17 <HeladoDeBrownie> dgomez, the problem is there are lots of little problems with what you wrote, so it seems easier to start from scratch
17:51:38 <dgomez>  HeladoDeBrownie: ok, that sounds all right
17:53:42 <dgomez>  HeladoDeBrownie: so a type of fmap refers to...
17:53:45 <HeladoDeBrownie> dgomez, so i said that we substitute f for whatever type is mentioned in the head, right?
17:53:45 <dgomez> :t fmap
17:53:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:54:00 <HeladoDeBrownie> dgomez, what type is in the head of the instance?
17:54:16 <dgomez> e
17:54:20 <HeladoDeBrownie> the whole type
17:54:25 <dgomez> (Either e)
17:54:27 <HeladoDeBrownie> right
17:54:38 <HeladoDeBrownie> f ~ Either e (~ is basically type equality)
17:54:57 <HeladoDeBrownie> so do that substitution in the type of fmap. what do you get? (make sure to take the the (Functor f) => part)
17:55:06 <HeladoDeBrownie> s/the the/out the/
17:56:31 <dgomez>  HeladoDeBrownie: Functor f => (a - > b) -> (Either e) a -> (Either e) b ???
17:57:15 <HeladoDeBrownie> that's it if you take out the Functor f => part, we don't need that since there's no f anymore
17:57:29 <HeladoDeBrownie> so yep, fmap :: (a -> b) -> (Either e) a -> (Either e) b is correct
17:57:45 <HeladoDeBrownie> note you can take out the parents around Either e because of how type application associates
17:57:54 <HeladoDeBrownie> so: fmap :: (a -> b) -> Either e a -> Either e b
17:58:13 <HeladoDeBrownie> okay! so now we know the type. let's try writing out a definition for it
17:58:18 <dgomez>  HeladoDeBrownie: all right, that makes sense so far
17:58:27 <HeladoDeBrownie> let's start by writing what goes on the left side of the =
17:58:49 <HeladoDeBrownie> so, we can imagine fmap as a function taking two parameters, one of type a -> b and another of type Either e a
17:59:42 <HeladoDeBrownie> actually what you wrote for the left side of = in your source file is okay
17:59:57 <HeladoDeBrownie> the only confusing thing really is you gave different names for the parameter in the same position in the two cases
18:00:10 <HeladoDeBrownie> let's call them both f
18:00:31 <HeladoDeBrownie> let's start with the Right case
18:00:35 <HeladoDeBrownie> fmap f (Right x) =
18:00:36 <dgomez> HeladoDeBrownie: hmm ok.
18:00:54 <HeladoDeBrownie> hmm, this part you also got right
18:01:00 <dgomez> HeladoDeBrownie: Right (f x) ??
18:01:04 <HeladoDeBrownie> er well not quite
18:01:09 <HeladoDeBrownie> you were close though
18:01:15 <HeladoDeBrownie> yes, that's it
18:01:22 <HeladoDeBrownie> your variable naming might have thrown you off
18:01:34 <HeladoDeBrownie> out of curiosity, can you tell me the type of x?
18:02:25 <HeladoDeBrownie> if we say fmap :: (a -> b) -> Either e a -> Either e b, what is the type of x (assuming we can still use the type variables we wrote there)?
18:03:03 <dgomez> HeladoDeBrownie: I'm not sure i know only that it would be a type of a?  Or an element from a?
18:03:35 <HeladoDeBrownie> dgomez, yep, x :: a
18:03:44 <HeladoDeBrownie> (the type of x is a)
18:03:58 <HeladoDeBrownie> okay then. let's do the Left case.
18:04:05 <HeladoDeBrownie> fmap f (Left x) =
18:04:11 <HeladoDeBrownie> before we do that, tell me the type of x *here*
18:04:17 <HeladoDeBrownie> in fact so as to avoid confusion, let's name it differently
18:04:20 <HeladoDeBrownie> fmap f (Left y) =
18:04:24 <HeladoDeBrownie> it's y. what is the type of y?
18:04:37 <dgomez> HeladoDeBrownie: ok y :: b in this case?
18:04:42 <HeladoDeBrownie> nope
18:05:20 <dgomez> HeladoDeBrownie: ok is it still y :: a for the same function f ?
18:05:31 <HeladoDeBrownie> as a reminder, this is the second parameter of fmap, and fmap's type is (a -> b) -> Either e a -> Either e b
18:05:45 <HeladoDeBrownie> what is the type of the entire second parameter?
18:05:59 <HeladoDeBrownie> the Right x or the Left y
18:07:01 <dgomez> HeladoDeBrownie: Left y bc we are talking about type Either e b
18:07:13 <HeladoDeBrownie> mm, we don't have an Either e b yet, in fact we're going to produce one
18:07:19 <HeladoDeBrownie> we did in the Right case already
18:07:47 <HeladoDeBrownie> let's look at the definition of Either
18:08:01 <HeladoDeBrownie> data Either a b = Left a | Right b
18:08:15 <HeladoDeBrownie> so the first parameter of Either is the type of Left, yeah?
18:08:24 <dgomez> HeladoDeBrownie: yes
18:08:27 <HeladoDeBrownie> er, the type of the thing given to Left
18:08:36 <dgomez> HeladoDeBrownie: a
18:08:41 <HeladoDeBrownie> nope
18:08:42 <HeladoDeBrownie> Either e a
18:08:46 <HeladoDeBrownie> what's the first parameter to Either?
18:09:00 <HeladoDeBrownie> argument*, sorry
18:09:17 <dgomez> HeladoDeBrownie Either first argument is type e?
18:09:20 <HeladoDeBrownie> right
18:09:33 <HeladoDeBrownie> so then when we match on Left y, what is y's type?
18:09:42 <HeladoDeBrownie> fmap f (Left y) = …
18:10:18 <HeladoDeBrownie> you might be overthinking
18:10:29 <dgomez> Either e a
18:10:40 <HeladoDeBrownie> Either e a is the type of Left y, i'm just asking for the type of y
18:10:58 <dgomez> a
18:11:15 <HeladoDeBrownie> no, remember, the argument to Left is of the type of the first argument to Either. e
18:11:19 <HeladoDeBrownie> y :: e
18:11:42 <HeladoDeBrownie> hmm, i hope i'm not saying things too confusingly
18:11:55 <HeladoDeBrownie> if you do need me to clarify something i say or ask, do let me know please
18:12:26 <dgomez>  HeladoDeBrownie: I'm just trying to refer to the source I wrote and you sent at the same time. and reading it all at once is confusing me
18:12:31 <HeladoDeBrownie> ah
18:12:37 <dgomez>  <HeladoDeBrownie: you're not confusing me
18:13:03 <dgomez>  HeladoDeBrownie: i just need to understand it better.
18:13:17 <HeladoDeBrownie> i'll try to restrict references in the current discussion to things already mentioned in channel. referring to your code might not be helpful because as i said it contains errors
18:13:17 <Welkin> dgomez: always look at the types and their definitions
18:13:30 <Welkin> data Either e a = Left e | Right a
18:13:47 <EvanR> > ([1,2,3]++repeat 4) !! 0
18:13:48 <lambdabot>  1
18:13:51 <EvanR> > ([1,2,3]++repeat 4) !! 6
18:13:52 <lambdabot>  4
18:13:54 <HeladoDeBrownie> dgomez, i'll mention outright if you already got something right
18:14:14 <HeladoDeBrownie> dgomez, okay, so we have: fmap f (Left y) =
18:14:17 <HeladoDeBrownie> and we know y :: e
18:14:26 <HeladoDeBrownie> dgomez, given that, can you write the right-hand side? don't look at your code
18:14:32 <HeladoDeBrownie> dgomez, tell me if you need a hint
18:14:43 <HeladoDeBrownie> i might nudge you if it seems you're having trouble
18:14:56 <Welkin> HeladoDeBrownie: isn't this a bit of a trick question?
18:15:01 <HeladoDeBrownie> Welkin, is it?
18:15:07 <Welkin> you don't map over Left
18:15:38 <HeladoDeBrownie> Welkin, well, you map over both, but the question is what you do in the Left case, which is exactly the problem at hand
18:15:49 <Welkin> okay
18:15:58 <dgomez>  HeladoDeBrownie: ok  Left (f y) but it wouldn't map in the case of Right?
18:16:16 <dgomez> Welkin: or what do you mean it wouldn't amp over both?
18:16:17 <HeladoDeBrownie> dgomez, not the same way, no
18:16:28 <Welkin> LEft is the error
18:16:34 <HeladoDeBrownie> dgomez, i said it would map over both, affirmative not negative. but what i meant by that isn't immediately relevant
18:16:36 <Welkin> Right contains the value if it succeeds
18:17:25 <dgomez>  HeladoDeBrownie: Welkin: understood
18:17:42 <HeladoDeBrownie> dgomez, so, we're looking to do something with a value of type e. what are our options? (are there more than one, or just one?)
18:18:05 <dgomez> so the right side in the case fmap f (Left y) = Left (f y)
18:18:16 <HeladoDeBrownie> dgomez, nope, that doesn't type check. f :: a -> b
18:18:20 <HeladoDeBrownie> dgomez, it can't possibly take an e
18:18:38 <HeladoDeBrownie> the other reason it doesn't type check is because it doesn't produce an e
18:19:00 <HeladoDeBrownie> because, remember, we want to produce something of type Either e b
18:19:32 <HeladoDeBrownie> how can we construct something of that type given what we have?
18:19:46 <HeladoDeBrownie> we don't have anything of type a, so using f is straight out.
18:20:20 <kazagistar> (I would say it is somewhat of a trick question, Right is much easier to start with)
18:20:27 <HeladoDeBrownie> kazagistar, we finished Right already
18:20:34 <kazagistar> oh, I missed it, sorry
18:20:47 <Welkin> dgomez: there is a hidden option -- you can write the function however you want, that means you can choose to not apply the function at all and just produce Left y
18:21:04 <HeladoDeBrownie> Welkin, well, you just gave the answer :P
18:21:55 <kazagistar> may I suggest trying to populate the types as an example?
18:21:59 <Welkin> if you think about it, there is no reason you would want to apply a function to the error value
18:22:00 <dgomez>  HeladoDeBrownie: ok that's great but I am not sure I understand the answer anyway
18:22:19 <HeladoDeBrownie> dgomez, so, let me dissect the definition of Either a bit
18:22:38 <HeladoDeBrownie> and actually let's label the types similarly to how we labeled them here
18:22:45 <HeladoDeBrownie> data Either e a = Left e | Right a
18:22:56 <HeladoDeBrownie> this creates a type as well as two constructors
18:23:22 <HeladoDeBrownie> the constructors are values. their types are: Left :: e -> Either e a, Right :: a -> Either e a
18:23:23 <dgomez>  HeladoDeBrownie: ok, I understand that part. what else is there?
18:23:42 <HeladoDeBrownie> the constructors of Either in particular are functions, in other words
18:23:49 <Javran> is there a QuickCheck generator that takes a random subset of a list?
18:24:39 <HeladoDeBrownie> now say you wanted to constructor Either Foo Bar, but you only had a value of type Foo
18:24:52 <HeladoDeBrownie> well it doesn't matter that you have no Bar, because you can just use Left on that value
18:24:59 <HeladoDeBrownie> specializing to Left :: Foo -> Either Foo Bar
18:25:19 <kazagistar> My function gave me a Left ErrorMessage or Right Response... I have a function { parseMsg :: Response -> Int }, and I want to apply it to the response: If I got the Right, I apply the parse inside and return a Right Int. If I got the Left, I just propagate the ErrorMessage, and just change the type from Either ErrorMessage Response to Either ErrorMessage Int
18:25:31 <HeladoDeBrownie> and that's exactly what you do in the definition of fmap. you had no a, so you couldn't get a b; all you could do was use the e you already had.
18:25:45 * hackagebot LambdaNet 0.1.0.0 - A configurable and extensible neural network library  http://hackage.haskell.org/package/LambdaNet-0.1.0.0 (jbarrow)
18:25:50 <HeladoDeBrownie> dgomez, does that make sense?
18:28:15 <dgomez>  HeladoDeBrownie: I think so. Using only Foo but you wouldn't be able to use the Right function bc there is no Bar.
18:28:20 <HeladoDeBrownie> dgomez, correct
18:28:30 <dgomez> Oh hence the error?
18:28:40 <HeladoDeBrownie> dgomez, which error are you referring to?
18:29:00 <dgomez> that Welkin referred to earlier in the discussion when not applying the function Left to the earlier example/
18:29:01 <dgomez> ?
18:29:15 <dgomez> bc we had no a?
18:29:42 <dgomez> I mightn't be remembering correctly but what you explained does make sense
18:29:47 <HeladoDeBrownie> not sure what you mean, but yeah, basically, since we had no a, we couldn't possibly get a b, since we can't apply f
18:30:21 <HeladoDeBrownie> so, to summarize what has been written of this instance:
18:30:46 <HeladoDeBrownie> instance Functor (Either e) where { fmap f (Right x) = Right (f x) ; fmap f (Left y) = Left y }
18:31:03 <HeladoDeBrownie> (i just wrote in one line for the sake of typing in irc, feel free to space out as normal)
18:31:13 <HeladoDeBrownie> now, this is a correct instance.
18:31:39 <HeladoDeBrownie> by the way, do you know how to test these instances you write?
18:32:40 <dgomez> HeladoDeBrownie: just running it through the ghc and not receiving errors is what I think
18:33:03 <HeladoDeBrownie> hmm, almost, except there's the additional problem that you're writing instances that already exist in the Prelude
18:33:15 <HeladoDeBrownie> so you'll likely get an error for that
18:33:41 <HeladoDeBrownie> one way around that is to use the language pragma NoImplicitPrelude and then define the relevant types yourself in addition to the instances
18:33:55 <HeladoDeBrownie> at the top of your source file, write: {-# LANGUAGE NoImplicitPrelude #-}
18:34:06 <HeladoDeBrownie> and make sure to include the definition of Either in that file
18:34:14 <dgomez> HeladoDeBrownie: ok, I have seen that used. would there be a better alternative?
18:34:47 <HeladoDeBrownie> hmm, using that seems okay to me for this sort of purpose
18:35:03 <HeladoDeBrownie> i haven't used it much myself though so i'm not terribly aware of any corner cases
18:35:48 <johnw> aristid: thanks!
18:35:54 <HeladoDeBrownie> here, let me try out what i proposed then i'll throw something up on lpaste
18:36:02 <johnw> aristid: updating those docs is becoming a priority
18:36:35 <dgomez> HeladoDeBrownie: mmm, sounds good. would it then be possible to proceed down th rest of the problems i failed at solving?
18:38:26 <HeladoDeBrownie> dgomez, i had a better idea, just import Prelude hiding (Either, ...) where ... is whatever other types you redefine
18:38:41 <HeladoDeBrownie> dgomez, yeah just a sec, it's important to test things out so lemme figure this out real quick
18:39:33 <lpaste> heladodebrownie pasted “instance redefinition example” at http://lpaste.net/117494
18:39:38 <HeladoDeBrownie> dgomez, check that out ^
18:39:54 <HeladoDeBrownie> that can be used as-is in ghci, feel free to play around with using fmap on various values
18:40:10 <HeladoDeBrownie> and i think it'd be a good idea to follow that same general pattern for the other ones you try
18:40:28 <HeladoDeBrownie> dgomez, once you've played with your fmap definition a bit, let me know and we'll move to another instance
18:41:10 <HeladoDeBrownie> i didn't bother deriving any instances besides Show, because Show's the only one you really need in order to play around with it in ghci
18:44:10 <dgomez> HeladoDeBrownie: sounds good to me. I'll get some more practice in but I am not sure that how I've been doing it has been the best approach
18:44:27 <dgomez> case in point: the exercise we just went through.
18:44:29 <HeladoDeBrownie> dgomez, has what i've told you been helpful so far? do you understand things better?
18:45:17 * Buttons840 looked upon lenses and despaired
18:45:23 <dgomez> HeladoDeBrownie: I do understand them better. bc while I have been seeing the definition of Either and fmap being used for a couple days now, I didn't understand the notion of the constructors in Either as functions
18:45:32 <dgomez> that clarification helped out A LOT
18:45:37 <HeladoDeBrownie> cool :)
18:46:17 <dgomez> HeladoDeBrownie: yeah, so thanks for your help
18:46:18 <HeladoDeBrownie> the haskell language also sort of conflates constructors and patterns and some other things, but hopefully that won't end up being much of an obstacle
18:46:25 <jp_rider> Has anyone ever seen: Prelude.chr: bad argument: 3077277
18:46:34 <HeladoDeBrownie> yep, no problem
18:46:36 <jp_rider> this is the code: http://lpaste.net/7019753290850107392
18:46:38 <johnw> jp_rider: sounds like you fed it a Unicode code point
18:47:04 <johnw> are you sure you're decoding a properly encoded string?
18:47:17 <HeladoDeBrownie> dgomez, do you want to continue? it's also okay to say no, take a break and come back later if you like.
18:47:24 <jp_rider> no im not sure it's properly encoded
18:47:29 <johnw> I'm guessing it's not
18:47:42 <jp_rider> but why wouldn't it return Left …?
18:47:54 <johnw> good question
18:47:58 <jp_rider> fyi from Data.ByteString.Base64
18:48:02 <johnw> i'd put in print statements, to find out exactly which line is throwing the exception
18:48:32 <jp_rider> so if you look at the lpaste
18:48:37 <jp_rider> line 2 write the file
18:48:44 <jp_rider> but 5 and 8 dont
18:51:04 <jp_rider> is there some way I can catch this and return a left instead?
18:52:22 <dgomez> HeladoDeBrownie: I will be back in a few hours, I want to go back over some of what we discussed. I feel I need to read a little more, I still feel sort of lost or it just takes me a bit longer to read through the syntax.
18:52:42 <HeladoDeBrownie> dgomez, okay. good luck!
18:53:11 <dgomez>  HeladoDeBrownie: ok thanks again.
18:53:16 <HeladoDeBrownie> no problem
18:55:20 <johnw> jp_rider: i'm guessing it dies evaluates tmp
18:55:24 <johnw> evaluting
18:55:48 <johnw> also, you can just "case decode plaintext of"
18:57:00 <jp_rider> right, that's what I had before
18:57:18 <jp_rider> i was trying to debug, but realized it wouldn't do anything since this is haskell
18:58:48 <johnw> where is this decode from?
18:59:56 <jp_rider> looks like Data.Serialize
19:00:49 * hackagebot LambdaNet 0.1.0.1 - A configurable and extensible neural network library  http://hackage.haskell.org/package/LambdaNet-0.1.0.1 (jbarrow)
19:00:50 <johnw> hmm
19:01:07 <johnw> I don't know what to say at this point; I haven't seen the Prelude.chr error before
19:01:44 <jp_rider> hmm ok
19:01:55 <jp_rider> i can file a bug report i guess
19:02:07 <jp_rider> do you know how i can catch this in the meantime?
19:02:32 <johnw> use "catch"
19:03:04 <jp_rider> from Prelude or Control.Exception.Base?
19:03:15 <johnw> those two should be the same thing
19:03:27 <jp_rider> o
19:03:50 <jp_rider> I'm getting `No instance for (Exception a0) arising from a use of `catch'`
19:04:06 <jp_rider> is there a particular instance it uses?
19:04:20 <johnw> you have to specify that you're willing to catch any exception
19:04:48 <johnw> x `catch` \(e :: SomeException) -> Left ...
19:04:51 <jp_rider> something like this right? `catch (error "bla") (\msg -> putStrLn $ "caught " ++ show msg)`
19:07:50 <jp_rider> k i think i need ScopedTypeVariables, but this should work
19:07:55 <jp_rider> thanks for the help!
19:11:30 <johnw> yeah, for the syntax I wrote you would
19:11:39 <johnw> to void it, you'd say "show (msg :: SomeException)"
19:11:44 <johnw> s/void/avoid
19:12:07 <johnw> note that in general, catching all exceptions like this is inadvisable
19:12:34 <johnw> it will prevent users of your code from being able to pass it as an argument to "timeout" for example, since you'll unexpectedly catch the timeout signal
19:12:50 <jp_rider> ok
19:13:05 <jp_rider> i was planning to just wrap the decode function with catch if that makes sense
19:13:05 <johnw> it's better to catch the exception you expect to occur, and as few others as possible
19:18:20 <yedi> how do i install the newest version of pandoc without using haskell/cabal? apt-get has an older version thats incompatible with rmarkdown
19:22:39 <benzrf> yedi: that is a little like asking "how do i get the newest version of linux without using C/make"
19:22:46 <benzrf> yedi: what are you even asking for?
19:22:52 <benzrf> oh prebuilt binaries?
19:23:01 <yedi> yea i know, im just ridiculously desperate
19:23:07 <yedi> not even doing anything haskell related
19:23:15 <benzrf> uhhh
19:23:21 <yedi> in other news i hate technology and idk why i put up with it
19:23:39 <yedi> anyways, apologies for intruding =/
19:26:05 <agibiansky> Has anyone run into issues using spaces in cabal config files?
19:26:29 <hiptobecubic> I'm trying to implement a safeTail using GADTs, but it seems like it's not possible. You need two different return types, one when an empty list is produced and when a non-empty list is produced. Am I missing something?
19:28:08 <johnw> a safeTail based on a non-empty list?
19:28:15 <hiptobecubic> Here's what I have so far, which is great except that it doesn't type-check or work :( http://lpaste.net/117496
19:29:06 <johnw> how would the tail of a non-empty list be guaranteed to itself be non-empty?
19:29:17 <johnw> you need some notion of "at least 2 elements" in order to return "at least 1 element"
19:30:44 <hiptobecubic> johnw, right
19:30:48 <hiptobecubic> But then it goes on and on
19:31:00 <johnw> what goes on and on?
19:31:11 <hiptobecubic> How do you know when to return the 1-element list? Now you need to know when you have two elements or more than two elements
19:31:43 <johnw> so, if you had a length-indexed list
19:32:02 <johnw> then you could have: tail :: List (n + 1) a -> List n a
19:32:14 <johnw> and this would be total
19:32:48 <hiptobecubic> that looks pretty odd
19:32:53 <hiptobecubic> n+k pattern in a type?
19:32:57 <johnw> data List :: Nat -> * -> * where Nil :: Nat 0 a; Cons :: a -> List n a -> List (n + 1) a
19:33:10 <johnw> it's not a pattern match
19:33:14 <johnw> it's a type level function
19:35:16 <johnw> you'll need DataKinds and TypeOperators enabled, and import GHC.TypeLits
19:35:24 <hiptobecubic> hm
19:35:58 <hiptobecubic> Ok so in the wikibook on the GADT page when they say "Can you implement safeTail" they are assuming you will know a lot more than just GADTs.
19:36:10 <johnw> oh, I didn't realize that was the restriction
19:36:14 <hiptobecubic> Which seems kind of silly since you *just* learned gadts
19:36:20 <johnw> one sec
19:36:24 <hiptobecubic> yeah i'm here sorry: http://en.wikibooks.org/wiki/Haskell/GADT#Extending_the_language
19:36:31 <hiptobecubic> at the bottom
19:42:22 <johnw> well, I can do it, but the signature required is:
19:42:24 <johnw> safeTail :: List a More -> (forall b. List a b -> c) -> c
19:42:56 <johnw> otherwise, I need to take two function argument: one for Nil, and one for Cons
19:43:11 <johnw> i.e., safeTail is a case analysis of the remainder of the list
19:46:39 <hiptobecubic> hmmm
19:47:45 <hiptobecubic> so your safeTail needs two args? And what is c there?
19:47:57 <johnw> anything the user wants it to be
19:48:17 <johnw> i'm just using CPS-style to allow for polymorphism where I want it
19:49:30 <hiptobecubic> and the continuation there is somehow going to do what safeTail was supposed to do, it seems
19:49:50 <johnw> yeah, it tells the user "you need to give me a function that works for either case"
19:49:55 <hiptobecubic> except that safeTail will invoke it so you *know* it will be applied to a (List a More) ?
19:50:05 <johnw> no, it'll be More or None
19:50:23 <hiptobecubic> Where would safeTail get the None?
19:50:33 <johnw> to distinguish, we'd need to use: safeTail :: List a More -> (List a None -> c) -> (List a More -> c) -> c
19:52:01 <glguy> hiptobecubic: If you did safeTail of a singleton list the tail would be a "none"
19:52:50 <hiptobecubic> glguy, yes but the continuation *receives* a (forall b. List a b), even though it looks like the only value we'd have available to apply it to is a List a More
19:53:14 <glguy> No, it's forall b. (List a b -> c)
19:53:19 <glguy> not (forall b. List a b) -> c
19:53:24 <johnw> also note, my List is: data List a b where Nil :: List a Zero; Cons :: a -> List a b -> List a More
19:54:23 <glguy> hiptobecubic: which means that the continuation is offering to work for any b, not just None or More, but all "b"
19:54:42 <hiptobecubic> hm
19:55:36 <johnw> and such a function could use case analysis to determine the type of b
19:55:39 <johnw> because of the GADT
19:55:59 <hiptobecubic> johnw, so your List is the same as the SafeList from wikibooks, but with Zero and More instead of Empty and NonEmpty then?
19:56:25 <johnw> yeah
19:56:36 <johnw> sorry, I just wrote it without looking too closely
19:56:48 <hiptobecubic> No thanks for doing this at all
19:57:18 <hiptobecubic> I spent about a half hour or so banging around with that definition of List until i decided that something had to change because of the problem I mentioned in the beginning
19:57:43 <hiptobecubic> about the return type. Although I hadn't introduced RankNTypes
19:57:46 <hiptobecubic> I'll try again
19:57:58 <latermuse> Network.URI's parseURI function only works on strings: (parseURI :: String -> Maybe URI), is there an alternative that works with UTF-8 Text?
19:59:03 <latermuse> I want to build URI with CJK characters
19:59:57 <Welkin> exit
20:00:01 <Welkin> \quit
20:00:07 <Welkin> \quit
20:00:14 <HeladoDeBrownie> /quit
20:00:18 <HeladoDeBrownie> ^ that one
20:00:25 <Welkin> yes
20:00:30 <trap_exit> by apl, I'm really referiing to j or k or q
20:00:31 <trap_exit> parsec so awesome; anyone have apl parser in haskell ?
20:00:34 <Welkin> my client is not behaving
20:05:05 <trap_exit> parsec so awesome; anyone have apl parser in haskell ?
20:14:30 <danem> Hi all, i have a design question that I hope you could help me out with. I've tried to explain my design as best I could here: http://lpaste.net/7377951647781093376 The paste is a bit long, but i'd really appreciate it if you took a look :-)
20:15:06 <danem> The problem I've run into with this design is I can't find a nice way to "extend" my core game state
20:15:33 <danem> this is needed (i think) to implement more complicated mechanics
20:15:52 * hackagebot kan-extensions 4.2 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-4.2 (EricMertens)
20:15:54 * hackagebot pointed 4.2 - Pointed and copointed data  http://hackage.haskell.org/package/pointed-4.2 (EricMertens)
20:16:11 <danem> I've considered adding an "applicationState" field to the GameStatePrivate type, but that seems like an ugly hack
20:17:14 <danem> Really what I'd like to do i provide a nice interface to some core functionality thats built on top of StateT while allowing the user to provide their own additional state as well
20:19:49 <danem> I've run into similar problems whenever I want to use StateT in a generic way, hopefully someone can provide some insight on how they design around this
20:33:40 <eyebloom> Is there a type function version of id in haskell?
20:33:53 <hiptobecubic> johnw, I'm confused about this continuation you are using in your implementation of safeTail.
20:34:38 <hiptobecubic> johnw, you have safeTail :: (forall b. SafeList a b -> c) -> SafeList a NonEmpty -> c, right?
20:34:50 <Buttons840> if you were implementing a poker game in haskell, with an intelligent (and fair) AI, how would you prevent the AI from seeing the full game state, and thus it's opponents cards?
20:35:19 <hiptobecubic> Buttons840, seeing the other cards only matters if you use that information
20:36:24 <Buttons840> or the AI is a collection of functions which is only given the game state is should fairly have access to
20:36:34 <Buttons840> it*
20:37:00 <hiptobecubic> My point is that if you don't program the AI to cheat, it won't.
20:37:44 <dfeuer> hiptobecubic, I think Buttons840's question is a very good one. No need to shoot it down.
20:37:49 <Adeon> it will be more difficult to accidentally cheat if the AI is implemented as a function that cannot access information it would need
20:37:53 <eyebloom> I mean in the standard libraries?
20:38:04 <dfeuer> The AI might be provided by someone else.
20:38:11 <dfeuer> Or might not even be an AI!
20:38:30 <danem> Buttons840: I'm dealing with a similar question. Here's my progress at it: http://lpaste.net/7377951647781093376
20:38:32 <dfeuer> You can offer the same interface to the user interface for a human player.
20:38:52 <Buttons840> were I doing this with OOP I would have a "game supervisor" or sort which passes information to each "player" that the player should righfully have access to
20:39:19 <danem> Im essentially transforming the private game state into a "public game state" before it is given to the AI
20:39:31 <Adeon> in haskell you can just make a function that has other functions as parameters that it can use to query information it needs, and those functions won't tell information it shouldn't be able to use
20:39:35 <Buttons840> i guess I can do the same with functional programming -- i'd rather do this then just say: be careful, you might "accidentially" cheat
20:39:37 <danem> not sure if this is a bad approach or not though :-)
20:39:38 <Adeon> there are several ways to do this
20:40:45 <hiptobecubic> I would think that your AI is going to be a function of the collection of whatever things have been visible up that that point in the game
20:42:04 <Buttons840> filter visible fullGameState ? ;)
20:42:24 <hiptobecubic> Buttons840, well how are you preventing human players from cheating?
20:43:23 <Buttons840> hiptobecubic: probably the same way I'm preventing the AI from cheating, only show the player the information they should righfully be able to see
20:45:00 <hiptobecubic> So there are N + 1 sets of information, but three from the perspective of any given player. Private game state (unseen cards), public game state that everyone sees, and the private state of the player
20:45:41 <hiptobecubic> I would think it's enough to have a users' play be a function the latter two
20:45:57 <hiptobecubic> and then they never get to touch the private state
20:46:07 <Buttons840> i agree
20:46:54 <ReinH> This doesn't prevent all forms of cheating, but it does prevent some important ones
20:46:54 <Buttons840> I hadn't thought of it in quite those terms, but I like the idea of those 3 categories of information
20:47:15 <hiptobecubic> well you also have to decide if it's ok to count cards :)
20:48:04 <Buttons840> yes
20:48:09 <ReinH> You can provide some type-level support for this with a type like `PlayerView' that contains the information a player (human or AI) should have access to
20:48:14 <Buttons840> counting cards is fine
20:48:51 <ReinH> But you have to also consider that not all moves should be legal. In other words, if players use a function PlayerView -> GameState to update the game, they might be able to cheat an another way: my making illegal moves.
20:49:17 <ReinH> This might be a good use case for a free monad that provides a restricted interface for move making
20:49:40 <hiptobecubic> Oh, yes. But I would certainly expect the function to return some action and not a game state
20:49:44 <hiptobecubic> mostly for that reason
20:49:45 <Buttons840> welp, back to typeclassopedia then :\
20:49:59 <ReinH> ofc you still should validate the actions
20:50:07 <Buttons840> ReinH: i agree
20:50:25 <hiptobecubic> userPlay _ _ = CollectPot
20:50:45 <ReinH> hiptobecubic: CollectPot is not a player action
20:50:58 <ReinH> That's a possible result of an action as determined by game logic
20:51:05 <EvanR> does anyone know or ever heard of functoids?
20:51:06 <Buttons840> i guess a related question is "what is a player"?  can a human player (which requires a UI) and an AI (which is just a function) have the same type?
20:51:29 <ReinH> Buttons840: A player is a function from the state they can see to an action they perform
20:51:44 <ReinH> Thus human and AI have the same denotation
20:51:58 <Buttons840> what do you mean by denotation?
20:52:04 <ReinH> they  mean the same thing
20:52:18 <ReinH> human and AI "player" both mean PlayerState -> GameAction
20:52:32 <ReinH> or probably PlayerState -> IO GameAction
20:52:44 <ReinH> since you need, e.g., input
20:52:46 <benzrf> Buttons840: the denotation of X is what X "denotes"
20:52:52 <benzrf> Buttons840: what it is a "representation" of
20:53:22 <ReinH> Buttons840: I'm using it in this sense https://www.youtube.com/watch?v=zzCrZEil9iI
20:53:56 <benzrf> ReinH: o: is that the same presentation he gave at λjam
20:54:14 <ReinH> benzrf: pretty close
20:54:18 <Buttons840> seems a shame to force a pure AI function to return an IO GameAction ?
20:54:33 <benzrf> Buttons840: who knows
20:54:39 <benzrf> maybe you want randomness or something :)O
20:54:40 <Buttons840> but giving it the freedom is necissary, and might be helpful
20:55:25 <Buttons840> randomness might help with bluffing ;)
20:55:38 <ReinH> Buttons840: indeed, optimal bluffing requires randomness
20:55:56 <ReinH> in fact almost all optimal play requires a source of randomness
20:56:39 <EvanR> denotation is the meaning explicitly spelled out by something, as opposed to connotation which is a more implicit meaning (of possible the same thing)
20:57:04 <EvanR> in denotational semantics it seems like the "something" is usually programming language syntax
20:57:08 <ReinH> EvanR: denotation is being used as a technical term here
20:57:20 <ReinH> in the sense of "denotational semantics"
20:57:44 <EvanR> in which case, were you saying a human being has some denotation?
20:57:52 <EvanR> or is that some data type
20:57:55 <ReinH> No.
20:58:45 <Buttons840> i guess I haven't heard "denotation" very often, but have heard things like "X denotes Y" quite often
20:59:15 <EvanR> [[Foo]] = Bar, means Foo denotes Bar, Bar is the denotation of Foo
20:59:33 <dark_star> I want to model a two-dimensional array of fixed size (not known at compile time) whose values aren't numbers or unboxable or anything of the sort. which vector-ish type do I want?
20:59:52 <ReinH> dark_star: perhaps Data.Array
21:00:09 <ReinH> It's a likely choice without knowing specifically what you want to do with it
21:00:28 <dark_star> i'm going to be doing random-ish access and updates
21:00:50 <ReinH> Data.Array seems reasonable
21:01:02 <ReinH> Although Data.Map might be a good choice as well
21:01:07 <EvanR> perhaps IntMap (IntMap a) ;)
21:01:08 <johnw> why that instead of Data.Vector?
21:01:16 <johnw> I thought Data.Array was the older one
21:01:33 <dark_star> johnw: you can index an array by a tuple of ints, you can't index a vector that way
21:01:36 <Welkin> Data.Vector is just a wrapper around Data.Array I thought
21:01:41 <EvanR> Array beyond a certain size will not have very efficient updates, since its immutable
21:01:52 <EvanR> and vector is 1D
21:02:12 <dark_star> also yeah, maybe Data.Map (Int, Int) MyType might be the right thing to do? I don't know
21:02:25 <EvanR> thats a good default choice
21:02:29 <dark_star> the array in question is going to be around 250x250 or so
21:02:37 <ReinH> johnw: so a vector of vectors? It's a bit unwieldy...
21:02:48 <johnw> no, just a plain vector
21:02:54 <johnw> then do the math to access (x,y)
21:03:01 <johnw> x * rowHeight + y
21:03:06 <ReinH> johnw: "whose values aren't numbers or unboxable"
21:03:22 <johnw> not sure how that relates?
21:03:29 <ReinH> Oh. It doesn't.
21:03:35 <ReinH> Heh.
21:03:46 <ReinH> Somehow my scumbag brain read "values" as "keys"
21:03:58 <EvanR> thats CoMap ;)
21:04:23 <ReinH> johnw: Also a bit unwieldy. You have to keep the width (or height) around
21:04:33 <dark_star> alright, thanks for the advice, I'm going to start out with a Data.Map
21:04:58 <ReinH> Data.Map is pretty good for relatively sparse arrays
21:05:33 <dark_star> hm
21:05:37 <dark_star> this one isn't going to be sparse
21:05:49 <hiptobecubic> johnw, sorry to poke you again, but can you explain what you meant by: "to distinguish, we'd need to use: safeTail :: List a More -> (List a None -> c) -> (List a More -> c) -> c"
21:05:51 <ReinH> Maybe start with Data.Array and go from there
21:06:07 <EvanR> a 250x250 immutable array intended for updates...
21:06:37 <johnw> hiptobecubic: I was wrong; because it's a GADT, you only need the polymorphic version
21:06:40 <dfeuer> I'm trying to learn something about web programming. Would MFlow be a good place to start?
21:06:52 <dark_star> yeah I guess I'll play around with stuff
21:07:17 <dark_star> later all
21:07:44 <hiptobecubic> johnw, well if we consider that closure, I still don't understand how it can have a useful return type if it needs to work on lists of length one or more.
21:07:50 <ReinH> dfeuer: MFlow seems weird
21:07:53 <Zemyla> Man, ap really works well for Parsec.
21:07:58 <johnw> hiptobecubic: I don't quite understand
21:08:09 <dfeuer> ReinH, oh? What's weird about it and what's unweird?
21:08:12 <hiptobecubic> johnw, it's probably poorly asked because I also don't quite understand. Let me try again :)
21:08:13 <ReinH> dfeuer: Specifically it seems to be designed to make web programming seem as little like web programming as possible, which seems counter to your goals.
21:08:20 <dfeuer> Hmm.
21:08:24 <dfeuer> Perhaps.
21:08:29 <dfeuer> Perhaps so.
21:08:34 <Zemyla> Have one parse that returns a function, one that returns a value, and mash them together.
21:08:38 <hiptobecubic> johnw, safeTail :: (forall b. SafeList a b -> c) -> SafeList a NonEmpty -> c, right?
21:08:48 <ReinH> dfeuer: The first paragraph of the description is "Flow is a Web Framework that turns Web programing back into just ordinary programming by automating all the extra complexities." ;)
21:08:58 <johnw> something like that, yeah
21:08:58 <ReinH> Those complexities are... sort of what you need to learn...
21:09:03 <dfeuer> Hmm.
21:09:05 <EvanR> Zemyla: <*> ?
21:09:07 <dfeuer> Perhaps you're right.
21:09:14 <ReinH> dfeuer: Maybe start with something simple like Scotty that doesn't get in the way
21:09:16 <meoblast001> hi. i apologise for bringing ruby speak in here, but is there something like "bundler exec" for cabal? i want to build something using the GHC command through my cabal sandbox
21:09:19 <dfeuer> but those complexities seem very unpleasant. :P
21:09:23 <ReinH> dfeuer: The web is a messy place, best to get a clear look at it ;)
21:09:25 <Zemyla> @pl \f g -> do { a <- f; b <- g; return (f. g) }
21:09:26 <lambdabot> (line 1, column 12):
21:09:26 <lambdabot> unexpected '{'
21:09:26 <lambdabot> expecting variable, "(", operator or end of input
21:09:33 <dfeuer> ReinH, so you say start with Scotty?
21:09:37 <EvanR> meoblast001: cabal build maybe
21:09:43 <ReinH> dfeuer: then you can make better decisions about which messy parts you want someone else to handle for you ;)
21:09:49 <hiptobecubic> johnw, so the continuation there produces a "c" somehow, which really has to be of type SomeList x y for "safeTail" to have any kind of reasonable meaning, right?
21:09:51 <ReinH> dfeuer: I think so. It's very simple.
21:09:55 <dfeuer> Thanks!
21:10:08 <meoblast001> EvanR: well, i'm trying to build a file unmaintained by the project for testing
21:10:11 <Zemyla> @pl \f g -> f >>= (\a -> g >>= (\b -> return (a, b)))
21:10:11 <lambdabot> liftM2 (,)
21:10:12 <johnw> it doesn't produce a 'c'; the caller will fix c
21:10:14 <johnw> try using it
21:10:17 <ReinH> dfeuer: Sure! Let me know if you have any HTTP, HTML, CS, or JS questions.
21:10:25 <dfeuer> Thank you.
21:10:37 <ReinH> np
21:10:44 <dfeuer> ReinH, CS = CSS, or = computer science?
21:10:46 <hiptobecubic> johnw, I am, but I don't know hot to implement it in a way that doesn't fail to typecheck
21:10:48 <ReinH> CSS heh
21:10:51 <ReinH> dfeuer: but that too I guess
21:10:55 <dfeuer> If the latter, well, I do have a question about computer science :-P
21:10:57 <johnw> that function should type check as it is
21:10:59 <Zemyla> EvanR: <*> is just infix ap on monads, right?
21:11:07 <ReinH> dfeuer: Not saying I have any answers :p
21:11:14 <hiptobecubic> johnw, mostly because I don't see how it does anything to allieviate the "which return type do I have" problem
21:11:24 <ReinH> Zemyla: infix ap-equivalent on Applicative
21:11:36 <EvanR> Zemyla: <*> is the applicative version of what youre talking about, and is more generic (assuming all monads are applicative)
21:11:37 <ReinH> :t (<*>)
21:11:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:11:51 <EvanR> Zemyla: like using fmap instead of liftM
21:12:28 <dfeuer> ReinH, can you either figure out a way to zip Seq in O(n) time total with better than O((log(min{i,n-i}))^2) immediate access (before anything's been forced, that is), or figure out why it's impossible?
21:13:11 <EvanR> @pl \f g -> do { a <- f; b <- g; return (a b) }
21:13:11 <lambdabot> (line 1, column 12):
21:13:11 <lambdabot> unexpected '{'
21:13:11 <lambdabot> expecting variable, "(", operator or end of input
21:13:39 <dfeuer> @undo \f g -> do { a <- f; b <- g; return (a b) }
21:13:39 <lambdabot> \ f g -> f >>= \ a -> g >>= \ b -> return (a b)
21:13:41 <hiptobecubic> johnw, oh... wait maybe i see it now... hard to say. I'll poke my head back up in a few minutes
21:13:49 <dfeuer> @pl \ f g -> f >>= \ a -> g >>= \ b -> return (a b)
21:13:49 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
21:14:05 <dfeuer> I think there's actually a way to compose lambdabot commands, but I don't know how.
21:14:14 <dfeuer> EvanR, that is utterly disgusting code there.
21:14:17 <ReinH> dfeuer: heh, probably not
21:14:24 <ReinH> dfeuer: have you shown it to edwardk yet?
21:14:27 <johnw> hiptobecubic: https://gist.github.com/983e3daa816589146a43
21:14:35 <EvanR> dfeuer: its quite obviously really
21:15:10 <dfeuer> ReinH, I haven't been able to get edwardk's attention on this one.
21:15:28 <benzrf> :t \ f g -> f >>= \ a -> g >>= \ b -> return (a b)
21:15:29 <dfeuer> I think he's been busy.
21:15:29 <lambdabot> Monad m => m (a -> b) -> m a -> m b
21:15:33 <benzrf> :t p
21:15:33 <lambdabot> Expr
21:15:34 <benzrf> :t ap
21:15:35 <lambdabot> Monad m => m (a -> b) -> m a -> m b
21:15:52 <EvanR> @pl \f g -> f >>= \a -> g >>= \b -> return (a . b)
21:15:52 <lambdabot> liftM2 (.)
21:15:54 <ReinH> dfeuer: :(
21:15:56 <EvanR> @pl \f g -> f >>= \a -> g >>= \b -> return (a b)
21:15:56 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
21:15:58 <EvanR> heh
21:16:01 <benzrf> EvanR:
21:16:07 <benzrf> @pl \f g -> f >>= \a -> g >>= \b -> return (a $ b)
21:16:07 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
21:16:10 <benzrf> mfw
21:16:14 <edwardk> what am i ignoring?
21:16:27 <dfeuer> edwardk, I don't know if you're actively ignoring it, or just not noticing.
21:16:33 <ReinH> dfeuer: he has been summoned
21:16:37 <edwardk> what am i not noticing? =)
21:16:40 <dfeuer> I'm wondering if  it's possible to zip Seq any faster.
21:16:45 <edwardk> re lambdabot commands i think the command is @.
21:17:00 <edwardk> oh, good luck, the balance isn't exact, so it'd be difficult
21:17:13 <edwardk> but you surpriseed me with the 2-3 tree thing
21:17:13 <Zemyla> EvanR: What really helps, though, is that I cam write custom functions to output the desired values right away.
21:17:14 <edwardk> so maybe
21:17:15 <dfeuer> To get O(n) total, but *better than* O((log (min{n,n-i}))^2) immediate access.
21:17:17 <matematikaadit> dfeuer: @@
21:17:32 <ReinH> @. pl djinn (a -> b -> c) -> (a -> b) -> (a -> c)
21:17:33 <lambdabot> f = ap
21:17:35 <dfeuer> matematikaadit, is that a composition operator?
21:17:45 <matematikaadit> dfeuer: yes.
21:17:56 <ReinH> So is @.
21:18:20 <edwardk> well, lets see you can get O(log n) to cut the sequences to match in length, then the problem is that the trees have some wiggle room
21:18:23 <ReinH> I don't think @@ is. I think @@ is for addressing someone.
21:18:25 <ReinH> @@ pl djinn (a -> b -> c) -> (a -> b) -> (a -> c)
21:18:25 <lambdabot>  pl djinn (a -> b -> c) -> (a -> b) -> (a -> c)
21:18:26 <dfeuer> edwardk, I think not possible, but the fact that you can get each piece going to a spot in that time makes it annoyingly close enough to be driving me crazy wondering if I've missed something.
21:18:35 <matematikaadit> @@ @pl @undo \f g -> do { a <- f; b <- g; return (a b) }
21:18:35 <lambdabot>  (. ((. (return .)) . (>>=))) . (>>=)
21:18:39 <ReinH> @@ matematikaadit @pl (a -> a)
21:18:39 <lambdabot>  matematikaadit (line 1, column 6):
21:18:39 <lambdabot> unexpected '>'
21:18:39 <lambdabot> expecting operator
21:18:50 <ReinH> @@ matematikaadit @djinn (a -> a)
21:18:50 <lambdabot>  matematikaadit f a = a
21:18:57 <EvanR> Zemyla: yeah fmap is awesome, pure/<*> are awesome. still trying to get good intuition of >>= ;)
21:19:06 <ReinH> matematikaadit: Huh.
21:19:06 <edwardk> dfeuer: i look forward to being able to exploit the fruits of your labors ;)
21:19:10 <dfeuer> Heh.
21:19:12 <dfeuer> Thans.
21:19:14 <dfeuer> Thanks.
21:19:17 <Zemyla> For instance, instead of having to say do { symbol '+'; return (+) } I can basically say symbolVal '+' (+).
21:19:33 <eyebloom> Why would it be that if I have TypeSynonymInstances enabled and I instantiate a typeclass using a type synonym with kind (* -> *) I get a complaint that the type synonym expects 1 type parameter. But if I instantiate the same typeclass using a data constructor or newtype of kind (* -> *) I get no complaint?
21:19:44 <dfeuer> edwardk, a cute trick is using the new Seq <*> to implement the power set-using-filterM trick.
21:19:45 <ReinH> Zemyla: (+) <$ symbol '+'
21:19:51 <EvanR> beat me to it
21:20:36 <EvanR> Zemyla: <$ is like fmap aka <$> but it ignores the input to the function
21:21:05 <Zemyla> ReinH: Yes, but since I have to write my own token functions anyway because I'm tokenizing manually, this takes very little extra time.
21:21:19 <ReinH> Zemyla: ?
21:21:33 <EvanR> tokenization is a thing of the past
21:21:37 <ReinH> Not sure what this has to do with time
21:22:02 <dfeuer> edwardk, there's also a big question about what to do with arrays. I made a mistake of implementing a not-quite-general-enough fromArray, and then there's also a nasty tradeoff between performance and leak potential.
21:22:13 <Zemyla> I have to write my own token functions anyway.
21:22:21 <ReinH> Zemyla: So?
21:22:36 <ReinH> You asked for a definition of symbolVal and I gave you one
21:22:36 <dfeuer> What I really want is RTS-supported array slicing, but I have no idea what's involved in that, and people seem to think it a large undertaking.
21:23:00 <ReinH> Not sure what it has to do with tokenization
21:23:06 * dfeuer takes ReinH's token and trades it in for a big stuffed turtle.
21:23:22 <EvanR> symbol '+' >> return (+)  is also  (+) <$ symbol '+', both are shorter than do { symbol '+'; return (+) } ;)
21:23:25 <ReinH> dfeuer: I don't need to tokenize now since I use parsers *shrug*
21:23:30 <Zemyla> And instead of saying "if c == x then Just c else Nothing", I can give it an extra parameter v and go "if c == x then Just v else nothing".
21:24:11 <ReinH> Zemyla: Ah, you didn't ask for a definition of symbolVal. Never mind then.
21:24:17 <Zemyla> Also, I can do anyMap [('+', (+)), ('-', (-))].
21:24:44 <EvanR> > "FOO" <$ Just "foo"
21:24:45 <lambdabot>  Just "FOO"
21:24:51 <EvanR> > "FOO" <$ Nothing
21:24:52 <lambdabot>  Nothing
21:24:59 <Zemyla> :t <$>
21:25:00 <lambdabot> parse error on input ‘<$>’
21:25:08 <Zemyla> :t (<$>)
21:25:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:25:22 <Zemyla> :t (<$)
21:25:23 <lambdabot> Functor f => a -> f b -> f a
21:25:55 <EvanR> (and currently in idris <$> : Applicative f => f (a -> b) -> f a -> b which is weird)
21:25:58 <ReinH> Zemyla: anyMap = choice . map (curry symbolVal) ?
21:26:55 <dfeuer> Does anyone know if there is a (preferably portable) way to detect overflow for Int multiplication?
21:27:11 <EvanR> you cant even do that in C
21:27:45 <ibid> what has C's deficiency have to do with haskell?
21:27:47 <dfeuer> I see addIntC# and subIntC# in GHC.Prim, but for multiplication only the rather less useful mulIntMayOflo#.
21:27:54 <EvanR> unsafeCheckOverflowFlag :: IO Bool ?
21:27:59 <Zemyla> Sure you can.
21:28:21 <dfeuer> Does hardware not report multiplication overflow?
21:28:30 <EvanR> it does
21:28:48 <kadoban> Hardware does, it doesn't tend to be visible in languages higher-level than assembly though.
21:28:53 <kadoban> At least not portably.
21:28:57 <edwardk> re array slicing, you probably just want to use Data.Vector for that kinda stuff
21:29:07 <dfeuer> edwardk, wrong kind of behavior altogether.
21:29:21 <Zemyla> if (INTMAX / a > b) then print "a * b will overflow!"
21:29:28 <ReinH> EvanR: Er, it's easy to check for 32 bit multiplication overflow?
21:29:45 <EvanR> it is?
21:30:32 <dfeuer> edwardk, what I *want* is something that looks a lot like a Vector, except that the garbage collector will collect each slice as a separate thing. This way I can send different pieces of the array to different computations without any of them keeping the entirety live.
21:30:43 <ReinH> The easiest way is to check the result by dividing
21:30:49 <edwardk> ok, so magic =)
21:31:07 <ReinH> It's a bit more complicated for signed multiplication
21:31:15 <dfeuer> edwardk, well, it wouldn't be entirely magical; abused, it would make memory use explode.
21:31:26 <edwardk> maybe possible with something like an RRB tree
21:31:41 <dfeuer> ReinH, what about unsigned?
21:31:42 <EvanR> dfeuer: so the vector inhabits different chunks of memory, so might as well not be a monolithic vector, but some trie
21:31:45 <EvanR> which exists
21:31:48 <dfeuer> What is an RRB tree?
21:32:25 <edwardk> http://infoscience.epfl.ch/record/169879/files/RMTrees.pdf
21:32:31 <dfeuer> EvanR, the specific use I'm thinking of is a function to convert an array to a sequence.
21:32:33 <ReinH> dfeuer: Hacker's delight to the rescue again http://www.informit.com/articles/article.aspx?p=1959565&seqNum=13
21:33:22 <dfeuer> If I split the sequence, force most of it (and throw that away), then keep another (unforced) piece, I don't want to keep the whole array live.
21:33:25 <Zemyla> dfeuer: To a first approximation, I would just use an IntMap.
21:33:59 <dfeuer> There are all sorts of things to use in circumstances other than the one I am actually thinking about.
21:34:07 <EvanR> dfeuer: this might be why the clojure guy decided not to have arrays in the first place, and its always in chunks
21:34:18 <dfeuer> Could be.
21:34:24 <dfeuer> Thanks for the link, edwardk.
21:34:28 <edwardk> dfeuer: array itself is pretty much not likely to change, other better structures can be made though
21:34:41 <dfeuer> edwardk, no, I wasn't suggesting a change to array itself.
21:34:46 <meoblast001> with parsers if i do (try newline), is it normal for me to get "expected newline" at that character if it doesn't exist?
21:35:59 <dfeuer> Currently, there are three options:
21:36:33 <dfeuer> 1. The current fromArray, which gives a Seq "view" of an Array (very fast and incremental, but potentially leaky),
21:37:07 <dfeuer> 2. fromArrayMonolithic, which copies all the elements out of the Array into a Seq (less fast, not incremental, but not leaky)
21:37:44 <dfeuer> 3. manually copying pieces of the array to send to different subtrees, which is non-leaky but absurdly and ridiculously inefficient.
21:38:04 <sumdued> Anyone use EclipseFP and feel like walking a noob through what's probably a very minor issue that i can't fix in over 4 hours now? =/
21:38:06 <dfeuer> The copy-on-GC slice thing would make #3 look very much more sane.
21:38:25 <dfeuer> sumdued, someone must, but I've never met them.
21:38:35 <sumdued> *sigh*
21:38:50 <EvanR> dfeuer: 4. avoid however the data ended up in an array ;)
21:39:14 <dfeuer> sumdued, I tend to be rather backwards when it comes to editor technology, but the people who are not seem to really really like Emacs Haskell mode.
21:39:55 <dfeuer> EvanR, yeah, that's ... a thing.
21:40:07 <kadoban> I've never liked eclipse, even back when I was writing Java and C++, and still liked the idea of IDEs...
21:40:23 <sumdued> I'm running into similar issues with Eclipse and with GHCi&Notepad++,
21:40:25 <EvanR> alternatively leave it in the array, despite this being a leak. basically, live with it
21:40:35 <sumdued> I must be missing something really basic.
21:40:44 <dfeuer> evanjs, well, that's what I currently do, which was option #1.
21:40:55 * hackagebot contravariant 1.2.0.1 - Contravariant functors  http://hackage.haskell.org/package/contravariant-1.2.0.1 (EricMertens)
21:41:27 <EvanR> dfeuer: one way to have it be an array is load all that data mmapped, im just guessing its a huge file or something
21:41:48 <EvanR> then at least its not copied
21:41:52 <dfeuer> EvanR, Data.Sequence.fromArray. No specific application in mind :-P
21:42:12 <sumdued> dfeuer, is there an obvious reason why entering line by line in GHCi would work just fine, but the same code in a .hs would run into endless parse errors and never loading a module?
21:42:14 <dfeuer> But that's a good one!
21:42:26 <dfeuer> sumdued, multiple reasons, yes.
21:42:41 <sumdued> May i please have one? =l
21:42:43 <hiptobecubic> johnw, yeah no :(    I think i understand why the continuation fixes the problem from safeTail's perspective, but then it seems like you just shift the problem up one level. Now you have to write this continuation somehow where the type (forall b. SafeList a b -> c) doesn't make any sense
21:42:43 <dfeuer> GHCi is not quite normal Haskell.
21:42:59 <sumdued> ._.
21:43:02 <evanjs> Whats up now?
21:43:03 <dfeuer> sumdued, no. But if you stick your file on lpaste.net I'll have a look.
21:43:35 <evanjs> oh I see you mixed me up with EvanR
21:43:43 <dfeuer> Holey mother of cheese, it's getting late.
21:43:49 <dfeuer> Yes, I did, evanjs. Sorry.
21:43:53 <evanjs> GRRRRRR
21:44:07 <evanjs> I blow my nose in your general direction sir!
21:44:28 <evanjs> ok I'm going back to my tomato time
21:44:31 <evanjs> sausage
21:44:34 <hiptobecubic> johnw, that function will take an arbitrary SafeList, and produce something of an arbitrary type. That only makes sense if c gets fixed by the caller, but you're defining it outside of the caller because it's passed in as an argument, right? Am I way off here?
21:44:47 <lpaste> sumdued pasted “ghci” at http://lpaste.net/117503
21:45:02 <sumdued> 0o
21:45:21 <dfeuer> sumdued, start by moving the Module Main where up above the imports, and making the Module into a module, because module needs to be lower case.
21:45:22 <sumdued> This is cool as hell.
21:45:27 <dfeuer> NExt
21:45:47 <dfeuer> remove every single one of those "let" things, because you don't need to say let at the top level.
21:46:23 <dfeuer> Next next: while you *can* indent everything in the module, that's just painful. So let those top-level definitions hang out in column 0.
21:46:30 <sumdued> THANK YOU!
21:47:02 <dfeuer> sumdued, you're doing some rather strange things in that code.
21:47:10 <sumdued> (the indents were because the first hour i kept getting errors of the missing indent or punctuation variety)
21:47:12 <dfeuer> But that's another story.
21:47:13 <hiptobecubic> johnw, looking at your gist now. I don't see why it works yet, but thanks. I'll keep playing with it.
21:47:25 <johnw> enjoy :)
21:47:45 <sumdued> I am, i'm just trying to become familiar with strings, ints, indeces, etc.
21:47:50 <dfeuer> Yeah.
21:47:50 <sumdued> Thank you so much!
21:48:21 <dfeuer> sumdued, the !! operator is vaguelly anti-Haskellian. It might be better to avoid it when learning.
21:48:41 <sumdued> I didn't know. O.o
21:48:45 <Welkin> I have never used !!
21:48:49 <Welkin> it is not safe anyway
21:48:52 <sumdued> I saw it in the first tutorial i ever saw on heskell
21:48:54 <Welkin> :t (!!)
21:48:55 <lambdabot> [a] -> Int -> a
21:49:01 <dfeuer> It's also not-so-vaguely inefficient once things get kind of long.
21:49:15 <_um> Happy new years eve eve, #haskell!
21:49:26 <sumdued> Copy that.
21:49:26 <dfeuer> > [1..100000000] !! 50000000
21:49:29 <lambdabot>  50000001
21:49:35 <sumdued> Same to you, _um.
21:49:44 <Welkin> > [] !! 5
21:49:46 <lambdabot>  *Exception: Prelude.(!!): index too large
21:49:52 <dfeuer> > id 50000000
21:49:53 <lambdabot>  50000000
21:49:56 <Welkin> head and tail are also unsafe
21:50:13 <dfeuer> Well, that should have been faster, but lambdabot has lag ;P
21:50:24 <sumdued> Thaaaaat's also a lot of what i'm seeing in this tutorial.
21:50:32 <EvanR> !! head tail last are partial functions
21:50:34 <Welkin> what tutorial?
21:50:37 <sumdued> Care to direct me to a tutorial of better practices? xD
21:50:47 <Welkin> you must be reading a terrible tutorial
21:50:53 <dfeuer> Maybe.
21:50:57 <sumdued> https://www.youtube.com/watch?v=NBKnY7Z_w3I&list=PLAYqRAte9oRIChcPR_DD4uc8mCR6d3RiJ&index=1
21:51:08 <sumdued> vaguely based on Learn You a Haskell
21:51:10 <dfeuer> @where learnhaskel
21:51:10 <lambdabot> I know nothing about learnhaskel.
21:51:12 <dfeuer> @where learnhaskell
21:51:12 <lambdabot> I know nothing about learnhaskell.
21:51:16 <dfeuer> @where learn-haskell
21:51:16 <lambdabot> I know nothing about learn-haskell.
21:51:18 <dfeuer> Hmm.
21:51:26 <Welkin> Learn You A Haskell is pretty good
21:51:32 <dfeuer> @where lyah
21:51:32 <lambdabot> http://www.learnyouahaskell.com/
21:51:39 <Welkin> @where bitemyapp
21:51:39 <lambdabot> I know nothing about bitemyapp.
21:51:41 <Welkin> hm
21:51:54 <Welkin> he has a collection of tutorials
21:51:54 <dfeuer> That is odd, Welkin.
21:52:11 <Welkin> https://github.com/bitemyapp/learnhaskell
21:52:12 <matematikaadit> @where+ learnhaskell https://github.com/bitemyapp/learnhaskell
21:52:12 <lambdabot> Done.
21:52:29 <matematikaadit> @where learnhaskell
21:52:29 <lambdabot> https://github.com/bitemyapp/learnhaskell
21:53:17 <sumdued> Appreciated.
21:53:20 <Welkin> sumdued: https://github.com/bitemyapp/learnhaskell#yorgey-course---do-this-first-this-is-the-primary-way-i-recommend-being-introduced-to-haskell
21:53:23 <dfeuer> sumdued, pattern matching is da bomb.
21:53:24 <Welkin> start there
21:53:30 <dfeuer> Folds are nice too.
21:53:56 <sumdued> I'm mostly stuck to videos due to some weird medical issues with continuous reading, though . =/
21:54:09 <Welkin> sumdued: use a screen reader
21:54:26 <Welkin> I have some video lectures for you from one of the creators of Haskell
21:54:27 <sumdued> Maybe this is a good enough occasion to learn to live with one.
21:54:37 <sumdued> Are they basic?
21:54:54 <sumdued> Most of what i find is above my head, due to noone ever explaining basic syntax.
21:54:55 <Welkin> https://www.youtube.com/playlist?list=PLtRG9GLtNcHBv4cuh2w1cz5VsgY6adoc3
21:55:07 <sumdued> I still have no idea what =>, ->, etc. mean.
21:55:14 <Welkin> it is a lower-level undergraduate course on programming
21:55:43 <Welkin> Philip Wadler will explain all of those in his lectures
21:55:59 <dfeuer> ReinH, Hacker's Delight does *not* come to the rescue.
21:56:11 <sumdued> Dope!!!
21:56:24 <dfeuer> Not well, anyway.
21:56:41 <sumdued> I'm real glad i risked embarrasment to pick some brains here.
21:57:02 <sumdued> So far i'm very impressed with how pleasant a community you lot are. Compliments all around.
21:57:08 <Welkin> risked what embarassment?
21:57:20 <Welkin> if you don't know something, the only logical thing to do is ask
21:58:04 <sumdued> Agreed, though in many communities the only recourse to asking is usually hazing, so i was preparing for the worst. xD
21:58:30 <Welkin> if you have specific questions, there are many people here who will chat with you for however long until you understand
21:58:48 <sumdued> =>
21:58:53 <Welkin> we love answering questions
21:59:13 <sumdued> Thanks! I'll go start on those lectures while i still have some energy left in me tonight.
21:59:15 <dfeuer> Welkin, I did not know there was an intro Haskell lecture series by Wadler online. That's astonishing.
21:59:15 * sumdued waves
21:59:21 <platz> would this be a good usage of !! in generateReplacements? http://lpaste.net/117504
21:59:42 <dfeuer> Probably not.
22:00:01 <Welkin> dfeuer: I found it when searching for haskell videos as supplemental material
22:00:10 <Welkin> there sure isn't much on youtube, but I found those
22:00:26 <Welkin> they are great, but only for an introduction
22:00:34 <dfeuer> *nod*
22:00:57 <dfeuer> platz, I'm very tired. What's that code supposed to do?
22:01:49 <hiptobecubic> johnw, oh interesting. So your version is not safe because it sees the wrong type, it's safe because the type is ambiguous?
22:02:43 <johnw> hmm?
22:02:45 <johnw> i don't follow
22:02:48 <platz> the example at the bottom shows that you give it a function, and it will call it on each elt of the array and substitute in the values
22:02:55 <dfeuer> platz, no, that is *not* a good usage of !!.
22:03:17 <hiptobecubic> johnw, http://lpaste.net/117508
22:03:45 <dfeuer> platz, I can actually only think of one situation where !! is actually what you want, and it's fairly unusual.
22:04:17 <hiptobecubic> johnw, oh... nevermind. It was ambiguous because of how I wrote it.
22:04:32 <platz> dfeuer: ah, thinking now I might be able to re-write using the list monad
22:05:38 <dfeuer> platz, I dunno. Maybe. Or maybe you shouldn't be using lists there. I'm too tired to say. But that code looks inefficient in several different ways suggesting it has the wrong structure somehow.
22:06:02 <platz> dfeuer: I know substitueAtIndex is bad, that could be improved
22:06:11 <hiptobecubic> johnw, it does seem like your way makes it impossible to get the list tail out. I guess that's the CPS way
22:06:17 <dfeuer> platz, if you're thinking "list monad", you should probably try writing it with list comprehensions.
22:06:49 <dfeuer> GOOD NIGHT PEOPLE.
22:07:22 <platz> dfeuer: night
22:07:35 <johnw> hiptobecubic: just return the tail
22:08:07 <johnw> ah, I see what you mean
22:08:08 <hiptobecubic> you can't though, because the type is ambiguous
22:08:14 <hiptobecubic> that's the whole problem to begin with
22:08:25 <johnw> yes, "just returning the tail" runs into the very problem that forced us to go the CPS route
22:08:37 <hiptobecubic> johnw, ok good. I thought I was retarded.
22:09:21 <hiptobecubic> so we'd like to write safeTail (Cons a as) = as, but can't for the same reason
22:09:34 <johnw> yep
22:09:56 <hiptobecubic> And I don't see how there's any way around this without tracking the list depth
22:10:02 <johnw> there are much easier ways to define non-empty lists
22:10:21 <hiptobecubic> Well this was more about understanding how GADTs work
22:10:32 <johnw> fair enough
22:10:38 <johnw> the "tail" exercise in this case is just tricky
22:10:56 <johnw> I find safe encodings of expression languages to be an easier intro into GADTs
22:11:08 <hiptobecubic> it seems pretty unsolvable without deus-ex-ghc-extensions
22:11:26 <hiptobecubic> johnw, the wikibooks started with that, which was pretty approachable, yes.
22:11:27 <johnw> so, one way of looking at GADTs is this:
22:11:33 <johnw> matching on a constructor asserts a type equality
22:12:05 <johnw> it thus builds a new kind of relationship between types and data
22:12:31 <johnw> knowing which constructor you have conveys something more specific about the type, which a normal ADT does not do
22:12:51 <hiptobecubic> on the interpreted language note, i asked this earlier and didn't get much feed back. Is there a nice way to have done this non-gadt version? http://lpaste.net/117492 it seems like a pretty poor way to write these, but i also didn't come up with anything any shorter or more clear
22:13:18 <johnw> what is wrong with that?
22:13:22 <EvanR> .oO(dependent view?)
22:14:49 <hiptobecubic> johnw, i'm not sure that anything is wrong with it. It works, at least. It just seemed like a very beginner-looking result
22:15:09 <johnw> I mean, the result value of Maybe (Either Int String) is a bit odd
22:15:14 <johnw> but otherwise, it's what I would have written
22:15:17 <hiptobecubic> which isn't inherently bad, but often it seems like there's a better way than manually pattern matching all of the contstructors off
22:16:09 <hiptobecubic> yeah it's pretty contrived i guess. It just gives you an out for having operations on operands of different types fail
22:16:46 <johnw> well
22:17:16 <hiptobecubic> when you say "knowing which constructor you have" you mean at compile vs runtime, yes?
22:17:16 <johnw> you could create some helper functions
22:17:23 <johnw> right
22:17:41 <johnw> at compile time, you know about the type based on the pattern match
22:17:53 <johnw> and run time, you know about the value
22:18:24 <johnw> like, if I have a Nil value, then in the Nil case I know that b ~ None
22:18:36 <Zemyla> Am I allowed to gush about how easy to use Parsec was?
22:18:39 <johnw> even though this information means nothing at runtime
22:18:53 <johnw> Zemyla: Parsec-style parsers are great fun
22:19:14 <EvanR> Zemyla: did you parse something like a + b * c yet? ;)
22:19:26 <EvanR> (with correct precedence)
22:20:51 <Zemyla> Even better. I made a parser that parses dice roll expressions.
22:20:52 <hiptobecubic> I always felt like lisp was the way it was so that no one would have to write a parser back when everything was impossible
22:20:57 * hackagebot system-filepath 0.4.13.1 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.13.1 (MichaelSnoyman)
22:20:59 * hackagebot yesod-bin 1.4.3.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.2 (MichaelSnoyman)
22:21:45 <Zemyla> Like, how "roll 4 6-sided dice and take the three highest" is expressed as "4d6h3"?
22:22:28 <hiptobecubic> The answer is always "2d6"
22:22:56 <Zemyla> It can parse those, it can parse things like "2d8 * 2d{-1, 1}", it has a bunch of modifiers it can use.
22:23:09 <EvanR> cool
22:23:39 <Zemyla> I haven't written the code to actually roll those dice yet.
22:24:01 <EvanR> dem bones
22:24:38 <EvanR> "roll 1 seven sided die"
22:24:43 <EvanR> "ERROR NOT PLATONIC"
22:26:02 <_um> "roll 3 three sided die"
22:26:11 <Zemyla> You can roll a 1d6-sided die.
22:26:27 <Welkin> why is it preceeded by a 1?
22:26:27 <EvanR> 1d6d6
22:26:29 <Zemyla> It rolls a 1d6 to tell how many sides the die has.
22:26:33 <EvanR> 1d1d6
22:27:06 <Welkin> what is the formula for #d#?
22:27:07 <EvanR> fix ("1d"++) ++ "6"
22:27:21 <Welkin> I know the second number is the number of faes
22:27:23 <Welkin> faces*
22:27:28 <Welkin> what is the first?
22:27:30 <EvanR> count of dice d sides of dice
22:27:37 <Welkin> okay
22:27:39 <sivteck> @roll 1d6
22:27:40 <lambdabot> sivteck: 2
22:27:42 <Welkin> I need to play DnD
22:27:47 <EvanR> you really dont
22:27:55 <Welkin> I want to
22:27:57 <EvanR> lol
22:29:10 <Welkin> I just heard an amusing story last night on Snap Judgement
22:29:14 <Welkin> it was an old episode
22:29:52 <Welkin> the host told a story about how he was a nerd growing up, but he was not allowed to play DnD because his pastor said it was a satanic ritual
22:30:12 <_um> I've never really taken the time to read a longish piece of code. I understand, however, that this is important. Could anyone recommend a particularly beautiful or illuminating piece of code to cut my teeth on? Haskell would be preferable, but I'd gladly read something in another rational language if I could grok it.
22:30:19 <Welkin> so his friend developed a biblical version of DnD called "Bible Land" where they journeyed on biblical adventures
22:30:51 <Welkin> and as soon as he had taken two women as his whores (as it says it is okay in the bible), his pastor showed up in the room
22:30:54 <Welkin> haha
22:31:51 <Welkin> _um: build a web app or a game
22:32:07 <_um> Welkin: ?
22:32:10 <Welkin> Richard Bird's Sudoku solver is beautiful
22:33:35 <Welkin> _um: http://pastebin.com/PAhtm6dd
22:33:36 <EvanR> heh
22:33:46 <Welkin> the haskell wiki is being slow
22:33:54 <Welkin> but the code is posted at that link
22:34:21 <EvanR> when my friends werent allowed to play my dnd game (for the same reason) i made it post apocalyptic, very biblical. and they were allowed to play
22:34:55 <Welkin> _um: here http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
22:35:36 <Welkin> EvanR: the bible is violent and filled with rape
22:35:48 <Welkin> so I don't get it
22:36:01 <EvanR> its not for children
22:37:08 <Welkin> the way the story is told on Snap Judgement just makes it great
22:37:31 <Welkin> also, he referred to himself as a "blerd" or "black nerd"
22:38:33 <_um> thanks, Welkin!
22:38:58 <Welkin> it was episode #525 Presto!
22:39:08 <glguy> The bible and DND are a bit off topic for #Haskell
22:39:27 <EvanR> but dice rolling
22:39:48 <EvanR> and god made the integers
22:47:31 <trap_exit> what is a good way to _implement_ in pure haskell, decnetly fast linear lagebra library?
22:47:39 <trap_exit> i'm reading "matrix computations" and want to implement the algos in ahskell
22:47:47 <trap_exit> but would prefer to represent hte matrices with something besides a list of list of doubles
22:48:43 <EvanR> check out the existing linear algebra packages
22:49:20 <EvanR> they pull some fancy tricks to get the dimensions to make sense
22:50:06 <trap_exit> EvanR: what do you recommend ?
22:50:38 <trap_exit> https://ocharles.org.uk/blog/posts/2013-12-02-24-days-of-hackage-linear.html
22:50:40 <trap_exit> EvanR: check out https://ocharles.org.uk/blog/posts/2013-12-02-24-days-of-hackage-linear.html
22:50:58 * hackagebot hsebaysdk 0.3.0.0 - Haskell eBay SDK  http://hackage.haskell.org/package/hsebaysdk-0.3.0.0 (ChristopherReichert)
22:51:09 <paomian> cool
22:51:35 <_um> A happy haskelly new year to all!
22:51:37 <EvanR> https://www.haskell.org/haskellwiki/Applications_and_libraries/Mathematics#Linear_algebra
22:52:20 <trap_exit> or ... just ue http://hackage.haskell.org/package/linear
22:52:21 <paomian> in chinese,today is the last day of one year
22:52:37 <trap_exit> don't yoppu trust this Edward A. Kmett guy?
22:52:43 <trap_exit> i hear he writes good haskell
22:52:58 <EvanR> hell if i know
22:53:06 <EvanR> hmatrix seems like the one youd pick if you were serious
22:53:09 <trap_exit> paomian: watch out, some people would label such talk as 'off topic / chatter" and recommend #haskell-blah [but do not worry; I am not such a person]
22:53:14 <EvanR> but its not "pure haskell"
22:53:42 <trap_exit> EvanR: hmatrix looks like wrappers around BLAS / LPACK
22:54:39 <EvanR> this package bed-and-breakfast seems very cozy
22:54:47 <EvanR> its pure haskell
22:58:19 <matematikaadit> @hackage bed-and-breakfast
22:58:19 <lambdabot> http://hackage.haskell.org/package/bed-and-breakfast
22:59:12 <matematikaadit> strange name for a package
22:59:33 <trap_exit> oh, it's a rela package
22:59:34 <EvanR> it kind of makes sense
22:59:36 <trap_exit> I thought it was some stupid joke
23:00:14 <EvanR> for linear algebra youd expect some industrial strength suite of stress tested bit grinding code
23:00:34 <EvanR> this package seems to "just give me some matrices"
23:00:45 <EvanR> so a home away from home ;)
23:01:17 <trap_exit> data instance Matrix Double     = DoubleMatrix !Int !Int (Array Int (UArray Int Double))
23:01:21 <trap_exit> how is this an 'unboxed array' ?
23:01:33 <quchen2> I'm trying to include an external library with Cabal that does not have a .pc file, so Cabal complains that "the pkg-config ... could not be found". Is there an alternative way to specify that library?
23:01:45 <quchen2> (The lib is installed, just the .pc is missing.)
23:02:35 <trap_exit> https://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-Unboxed.html explains it
23:05:03 <EvanR> UArray Int Double
23:28:59 <trap_exit> is there a synonym of "Container", but is shorter, and is not the word "Group" ?
23:29:03 <trap_exit> I'm having trouble naming a datatype
23:29:03 <EvanR> :t (>=>)
23:29:04 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:29:23 <kadoban> trap_exit: Box
23:29:38 <trap_exit> Box is not a good thing
23:29:41 <trap_exit> I'm naming Svg Elements
23:29:49 <trap_exit> like SvgLine, SvgRect ... but then SvgGroup already deals with <g>
23:29:49 <EvanR> group
23:29:52 <trap_exit> SvgBox would be too similar to "<rect>"
23:29:57 <kadoban> Bag ? :)
23:29:59 <trap_exit> SvgGroup = <g> tag already
23:30:17 <EvanR> MyGroup ;)
23:30:35 <trap_exit> I think I'll call it SvgElemThatShallNotBeNamed
23:30:50 <Welkin> http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643
23:30:56 <Welkin> his book is finally available
23:31:02 <Welkin> it looks good, too
23:33:38 <trap_exit> you nkow what
23:33:42 <trap_exit> Ill call it SvgNode
23:33:58 <benzrf> SvgMmee
23:34:03 <benzrf> *SvgMeme
23:46:32 <benzrf> night
23:51:23 <xpika> what is a haskell data type with O(1) head and O(1) append ?
23:52:50 <Welkin> Sequence
23:52:56 <HeladoDeBrownie> Maybe :o)
23:52:58 <Welkin> in Data.Sequence
23:53:18 <Welkin> or a finger tree
23:53:23 <ibid> HeladoDeBrownie: Maybe has no append
23:53:28 <Welkin> Sequence is actually just a finger tree
23:53:49 <HeladoDeBrownie> ibid, hmm, you're right, i guess "append" usually means it doesn't delete the existing elements.
23:54:09 <ibid> :)
23:54:46 <xpika> how about a data structure with o(1) concatenate and O(1) head and O(1) append ?
23:55:16 <Welkin> http://hackage.haskell.org/package/containers-0.5.6.2/docs/Data-Sequence.html
23:57:41 <EvanR> > 4 <$ Nothing
23:57:43 <lambdabot>  Nothing
23:58:59 <EvanR> o(1) concatenate is (,)
23:59:14 <EvanR> and i saw a Bag data structre in ghc do something like this
23:59:57 <EvanR> like a lazy nested of sequences
