00:05:27 <Geekingfrog> In ghci, :t Functor output this strange line: (GHC.Base.<$) :: a -> f b -> f a what's that? I though there were only fmap
00:05:54 <Haskellfant> :t fmap . const
00:05:54 <lambdabot> Functor f => b -> f a -> f b
00:06:01 <Haskellfant> ah damnit
00:06:02 <jle`> what version do you have Geekingfrog ?
00:06:05 <Haskellfant> :t fmap . flip const
00:06:06 <lambdabot> Functor f => a -> f b -> f b
00:06:12 <Haskellfant> no I'm still stupid
00:06:17 <jle`> :t Functor doesn't give me anything
00:06:17 <dibblego> Geekingfrog: I think you mean :i Functor ó yes, there is an additional method (<$) on Functor
00:06:17 <lambdabot> Not in scope: data constructor ‚ÄòFunctor‚Äô
00:06:17 <lambdabot> Not in scope: ‚Äòdoesn't‚Äô
00:06:17 <lambdabot> Not in scope: ‚Äògive‚Äô
00:06:23 <jle`> :i Functor probably is what you are looking for, though
00:06:23 <Haskellfant> the first one was actually correct
00:06:26 * Haskellfant shuts up
00:07:30 <jle`> > 5 <$ [1,2,3]
00:07:32 <lambdabot>  [5,5,5]
00:07:37 <jle`> > 6 <$ Just "hello"
00:07:39 <lambdabot>  Just 6
00:08:04 <merijn> Geekingfrog: fmap is the only function in the Functor class, yes
00:08:14 <merijn> Geekingfrog: It's not the only function you can define on any functor
00:08:44 <jle`> hm. from my :i output it appears that (<$) is a part of the Functor typeclass now
00:08:50 <jle`> when did this happen
00:09:06 <merijn> Probably part of dfeuer optimisation hacking
00:09:21 * hackagebot data-filepath 2.0.0.0 - A type safe file path data structure  http://hackage.haskell.org/package/data-filepath-2.0.0.0 (domdere)
00:09:21 * hackagebot objective 0.6.1 - Extensible objects  http://hackage.haskell.org/package/objective-0.6.1 (FumiakiKinoshita)
00:09:23 <jle`> if it's there, it is so that types can offer customized implementations of (<$) for performance reasons
00:09:26 <merijn> There's a bunch of generic methods being moved into classes to allow for more optimal implementations
00:09:28 <jle`> Geekingfrog
00:09:36 <jle`> hm, any other examples?
00:09:42 <jle`> i just remember mconcat from long ago
00:09:55 <jle`> oh, join is moving to Monad, isn't it
00:10:07 <Haskellfant> I thought they decided against it
00:11:23 <jle`> would it be so bad if there was a Num instance for ()
00:12:06 <Welkin> I thought that bottom inhabits all types
00:12:13 <merijn> Welkin: It does
00:12:14 <Welkin> does that mean it has an instance for all typeclasses as well?
00:12:22 <haasn> bottom isn't a type
00:12:22 <dibblego> () is not ‚ä•
00:12:23 <haasn> it's a value
00:12:31 <haasn> only types can be instances of typeclasses
00:12:37 <Welkin> what about () ?
00:12:41 <Welkin> in type signatures
00:12:47 <haasn> () is a type
00:12:49 <dibblego> it is a type and a value
00:12:50 <merijn> Welkin: () is a type and a value
00:12:50 <haasn> data () = ()
00:13:34 <Geekingfrog> ok, thanks for the answers
00:14:03 <tdammers> I'd say there's two ()'s, one is a type, the other is a value, but they're not the same thing
00:14:18 <Welkin> how is () not bottom?
00:14:19 <jle`> data Unit = MkUnit
00:14:22 <haasn> () is top, not bottom :)
00:14:28 <merijn> tdammers: I didn't mean to imply they were the same
00:14:32 <dibblego> Welkin: () is unit and it is inhabited. Bottom is not inhabited.
00:14:40 <merijn> dibblego: Wut
00:14:49 <sgronblo> isnt () just one more data type which implies something that is of type () could also be bottom?
00:14:55 <merijn> dibblego: bottom is not a type and therefore can't be inhabited or unibhatied
00:15:00 <dibblego> er, sorry
00:15:03 <dibblego> data Bottom
00:15:07 <merijn> sgronblo: bottom is a value of type ()
00:15:16 <merijn> See
00:15:18 <merijn> :t undefined :: ()
00:15:19 <lambdabot> ()
00:15:20 <Ferdirand> so, question: are there conditions under which one can automatically derive an instance for () ?
00:15:22 <sgronblo> isnt bottom a value in all types?
00:15:26 <merijn> sgronblo: Yes
00:15:31 <haasn> Welkin: Try visualizing these functions: top :: a -> (),  bot :: Void -> a
00:15:35 <jle`> Ferdirand: sometimes () doesn't even make sense as an instance
00:15:39 <Ferdirand> something like the class only containing covariant type variables ?
00:15:48 <jle`> () can't be a Monad
00:15:52 <haasn> Welkin: Then try writing :: () -> a  or :: a -> Void
00:16:03 <ReinH> dibblego: we usually call that data Void
00:16:04 <dibblego> () is to 1 as Bottom/Void is to 0
00:16:05 <jle`> kind error
00:16:09 <dibblego> ReinH: yes
00:16:56 <Welkin> where can I read more about this?
00:16:56 <jle`> Welkin: what do you think bottom is?
00:17:00 <Welkin> any good books?
00:17:10 <Welkin> jle`: I thought Unit was bottom
00:17:13 <jle`> ah
00:17:31 <merijn> Welkin: bottom is a value, and it's part of every type
00:17:36 <merijn> Welkin: Actually, yes!
00:17:38 <merijn> @where tapl
00:17:38 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
00:17:52 <sivteck> 100$ :(
00:17:56 <merijn> Welkin: TaPL explains the basics of types and how to implement type checking/inference
00:18:02 <jle`> bottom can refer to a nonterminating computation
00:18:18 <jle`> like sum [1..] is a member of Int that is bottom
00:18:33 <jle`> (let x = x in x) is a bottom :: a, a bottom in any type
00:18:35 <merijn> Welkin: It even has example implementations of all the type checkers in ocaml (but only uses really basic ocamle, so if you have any Haskell experience it should be fairly trivial to translate the ocaml code to haskell)
00:18:38 <jle`> > let x = x in x :: ()
00:18:41 <lambdabot>  mueval-core: Time limit exceeded
00:18:48 <jle`> > let x = x in x :: Maybe Double
00:18:52 <lambdabot>  mueval-core: Time limit exceeded
00:19:15 * hackagebot Wordlint 0.1.0.2 - Plaintext prose redundancy linter.  http://hackage.haskell.org/package/Wordlint-0.1.0.2 (bgbgbg)
00:19:27 <jle`> in haskell semantics we treat 'undefined'/'error' as being semantically the same as nonterminating computations
00:19:38 <jle`> > undefined :: ()
00:19:39 <lambdabot>  *Exception: Prelude.undefined
00:19:42 <jle`> > undefined :: Maybe Double
00:19:43 <lambdabot>  *Exception: Prelude.undefined
00:19:52 <jle`> > fix id :: (Int, Bool)
00:19:56 <lambdabot>  mueval-core: Time limit exceeded
00:20:27 <ReinH> (except that you can catch error in IO)
00:20:40 <Welkin> okay
00:20:44 <Welkin> so then what is Unit?
00:20:50 <jle`> unit is just a normal data type
00:20:54 <dibblego> data () = () -- Welkin, it is this
00:20:56 <jle`> data Unit = MkUnit
00:21:03 <jle`> data IAmUnit = Hello
00:21:06 <jle`> etc.
00:21:11 <jle`> a data type with one constructor
00:21:20 <ReinH> a type with a single (non-bottom) value
00:21:25 <augur> does anyone know of a good interface for querying data that has a forest-y DAG shape to it? or for representing it in a nice queryable way?
00:21:36 <Welkin> so undefined is bottom for all types
00:21:43 <sgronblo> yeah data () = () is exactly the same as data Boolean = True | False, both of which automagically have bottom as one possible value?
00:21:45 <merijn> :t undefined
00:21:46 <lambdabot> a
00:22:09 <merijn> undefined has the type "forall a. a", i.e. all possible types
00:22:12 <jle`> undefined :: forall a. a
00:22:13 <ReinH> sgronblo: how many inhabitants do () and Bool have?
00:22:31 <jle`> let x = x in x :: forall a. a
00:23:06 <jle`> :t fix not
00:23:07 <lambdabot> Bool
00:23:17 <jle`> `fix not` is an inhabitant of Bool
00:23:19 <sgronblo> ReinH: Yeah different amount of members but I just tried to add to the noise saying that there doesn't seem to be anything special about ()/Unit
00:23:20 <jle`> > fix not
00:23:24 <lambdabot>  mueval-core: Time limit exceeded
00:23:33 <ReinH> sgronblo: it isn't special at all
00:24:18 <ReinH> (Well, not in terms of its definition as a Haskell data type, at least)
00:31:16 <Welkin> are there any good essays online where I could read more about bottom?, besides the book merijn linked?
00:32:09 <Welkin> I'll likely pick up TAPL at some point
00:33:05 <moop> you can listen to songs like "I like big bottoms and I cannot lie" by sir mix-alot
00:33:07 <merijn> Welkin: It should be very readable (or at least the majority, you may wanna gloss over the proofs if you get stuck) if you know basic haskell
00:33:37 <merijn> Welkin: There's a lot of stuff, the basics of lambda calculus and type theory would be good
00:33:48 <merijn> TaPL is a good start, lemme check if my old course notes are still online
00:33:52 <Welkin> moop: I think you got the lyrics wrong
00:34:08 <merijn> Welkin: http://www.cs.vu.nl/~femke/courses/lv/notes/notes.pdf
00:34:23 <merijn> Welkin: That's an intro to propositional logic and lambda calculus
00:34:27 <gfixler> Are combinators a difficult concept?
00:34:29 <ab9rf> wee, now i get to find out everything i broke by upgrading haskell platform
00:34:49 <ab9rf> gfixler: some people find them so, i suppose it varies
00:34:51 <gfixler> I've seen probably 50 uses of the word 'combinator' this year, and still no definitions
00:34:55 <merijn> gfixler: Combinators are simple, it's just an ill-defined term (except in a very specific term)
00:35:27 <merijn> gfixler: There's combinator calculus, but more generally "combinator" just means "anything that combines things", you're probably over thinking it :)
00:35:37 <gfixler> merijn: I was thinking I might be
00:35:37 <ab9rf> an ill-defined term that blows nobody any good
00:35:51 <Welkin> merijn: this looks good, thanks
00:36:12 <merijn> Welkin: Another, vaguely related book is Software Foundations, that covers depend types and proving properties about programs
00:36:14 <gfixler> (+) <- original combinator?
00:36:15 <merijn> @where sf
00:36:15 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sj√∂berg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
00:36:15 <lambdabot> assistant."
00:37:16 <Welkin> I still haven't read past chapter 1 in Lawvere's "Conceptual Mathematics"
00:37:19 <merijn> That book is free, so that's always ncie :)
00:37:40 <merijn> Welkin: Software Foundations is probably a lot more accessible than most math books :p
00:37:43 <Welkin> I suppose learning more about type systems and lambda calculus would be better to do first in terms of becoming better with haskell
00:37:51 <Welkin> rather than category theory
00:37:57 <merijn> Welkin: It's a very "programmer" oriented sort of math
00:38:14 <merijn> Welkin: Definitely, category theory is *very* overrated in relation to haskell
00:38:26 <merijn> Lambda calculus, algebra and type theory are MUCH more applicable
00:38:35 <ab9rf> i'm not wholly certain that you need that much category theory to write haskell
00:39:00 <thebnq> you shouldn't need any
00:39:34 <merijn> ab9rf: You don't need it at all
00:39:35 <gfixler> CT is just making me appreciate Haskell more than I already did
00:40:01 <ab9rf> merijn: i wasn't willing to assert it, since i'm only a mediocre haskell programmer, and it's possible that i';d be better if i had a clue about category theory
00:40:03 <merijn> I'm just stating that not only don't you need it, it's also a lot less helpful than most people seem to believe
00:40:26 <ab9rf> really all i know is that it's something to do with categories
00:40:36 <Dulnes> > 0/0
00:40:38 <lambdabot>  NaN
00:40:43 <ab9rf> now i want bread
00:40:55 <Welkin> well, I've been writing haskell for several months now and finally feel quite comfortable with it
00:41:01 <Welkin> so I am ready to go deeper
00:41:09 <Dulnes> Mmm proccesed fungus placed in a loaf like shape
00:41:22 <Welkin> doing projects with yesod and parsec were great fun
00:41:46 <merijn> Welkin: Other neat haskell topics: GADTs (the wikibook chapter is good), type families (read the "Fun with Type Functions" paper) and DataKinds (not sure about a good intro on there)
00:41:53 <Dulnes> What do you do for a living
00:42:30 <merijn> Both GADTs and type families are fairly straightforward and you can do neat things, especially when you combine them :P
00:43:09 <merijn> Welkin: Some of my favourite exampls: https://gist.github.com/merijn/6130082 https://gist.github.com/merijn/dc00bc7cebd6df012c5e and https://gist.github.com/merijn/39dc86e345e87276c523
00:45:33 <Welkin> that looks alien to me at this point, which makes it exciting
00:45:57 <gfixler> merijn: what's ': ?
00:46:18 <merijn> gfixler: DataKinds disambiguation
00:46:42 <merijn> gfixler: DataKinds lifts *values* to types and types to kinds, but some things are ambiguous
00:46:56 <merijn> Prefixing with ' indicates you mean the lifted version
00:47:05 <merijn> :k (':)
00:47:06 <lambdabot> parse error on input ‚Äò:‚Äô
00:47:11 <merijn> aww, really?
00:47:14 <merijn> :k (:)
00:47:15 <lambdabot> parse error on input ‚Äò:‚Äô
00:47:48 <merijn> So normally ':' has TYPE "a -> [a] -> [a]", but ': has KIND "a -> [a] -> [a]"
00:47:55 <merijn> i.e., it's constructing a type level list
00:48:15 <gfixler> whoa
00:48:16 <gfixler> a list of types?
00:48:53 <StoneCypher> alexandrescu <3
00:49:03 <merijn> @define data HList :: [*] -> * where { Nil :: HList '[]; Cons :: a -> HList l -> HList (a ': l) }
00:49:03 <lambdabot>  Parse failed: Parse error: ]
00:49:06 <merijn> Aww
00:49:14 <merijn> lambdabot doesn't have the right extensions
00:49:30 <merijn> gfixler: Try it in ghci, it should work for any GHC >7.6
00:49:36 <gfixler> merijn: I think I'm *sorta* seeing what the type family Restrict example is doing
00:49:47 <gfixler> it feels like regular list recursion, but through lists of types
00:49:58 <merijn> For example, try ":t Cons 'c' (Cons 3 (Cons True Nil))"
00:50:04 <merijn> gfixler: It is
00:50:22 <merijn> gfixler: And you know that ~ is type equality, right?
00:50:29 <gfixler> merijn: I didn't
00:50:45 <merijn> Ok, ~ tries to unify two types and produces a type error when it can't
00:50:46 <gfixler> you're using it between two strings
00:50:56 <merijn> Ah, no, two *symbols*
00:51:00 <merijn> :t "foo"
00:51:01 <lambdabot> [Char]
00:51:03 <merijn> :K "foo"
00:51:08 <merijn> :k "foo"
00:51:09 <lambdabot> GHC.TypeLits.Symbol
00:51:12 <gfixler> whoa
00:51:23 <gfixler> going deeper again
00:51:24 <merijn> gfixler: DataKinds gives us *type* level Strings (with kind Symbol)
00:51:54 <gfixler> are you being sneaky using it on two separate symbols?
00:52:02 <merijn> So it's trying to unify the  "Error!" *type* (of kind Symbol) with the type "Tried to apply a restricted type!" (of kind Symbol)
00:52:10 <gfixler> to generate a type mismatch error?
00:52:14 <merijn> gfixler: Correct :)
00:52:23 <gfixler> so sneaky
00:52:34 <gfixler> so it's like documentation that generates the error you want
00:52:37 <merijn> Right
00:52:55 <merijn> You could also use (Int ~ Bool) for the same effect, but that'd be really unhelpful :)
00:53:11 <gfixler> is the error not available to raise on its own?
00:53:24 <gfixler> raiseTypeMismatchError or somesuch?
00:53:25 <merijn> gfixler: There's no realy way to raise errors, no.
00:53:39 <gfixler> okay, then not as sneaky - you did what must be done
00:53:58 <merijn> Also, so if you know that () is the trivial, empty constraint (i.e. it's always true), can you see how it works? :)
00:54:10 <merijn> :t id :: () => a -> a
00:54:15 <lambdabot> a -> a
00:54:24 <gfixler> ah, so '[] is the empty list of types?
00:54:28 <gfixler> or a type-level empty list
00:54:45 <merijn> gfixler: It's a type-level, empty list of types, yes
00:54:50 <gfixler> I thought () was Void, and didn't know it worked that way
00:54:52 <merijn> :k []
00:54:52 <lambdabot> * -> *
00:54:57 <merijn> hmm
00:54:59 <merijn> Wrong one :p
00:55:05 <merijn> :k [Int, Bool]
00:55:05 <lambdabot> [*]
00:55:19 <gfixler> list of types
00:55:24 <gfixler> or kinds
00:55:26 <merijn> The *type* "[Int, Bool]" has *kind* "[*]"
00:55:31 <gfixler> sheesh
00:55:53 <merijn> Just like [Int] can contain any value of type Int, "[*]" can contain any *type* of kind *
00:56:00 <gfixler> Prim is Primitive?
00:56:16 <merijn> GHC.Prim is "GHC primitive voodoo"
00:56:21 <gfixler> hehe
00:56:24 <merijn> I believe you can also import if from GHC.Ext
00:56:29 <ab9rf> beware of dragons
00:56:30 <merijn> (GHC extensions)
00:56:41 <gfixler> the type family line is interesting and new
00:56:52 <gfixler> we're making a type family called Restrict here?
00:56:56 <merijn> Right
00:57:10 <gfixler> with inputs a and as
00:57:12 <merijn> A *closed* type family in this case (i.e., it's not possible to add new cases)
00:57:30 <gfixler> what signifies closed?
00:57:34 <merijn> The advantage of closed families is that, unlike open ones, they're cases are tried in order
00:57:50 <merijn> gfixler: the "where"
00:58:00 <gfixler> I should probably read up on type families
00:58:08 <gfixler> I'm not quite sure what they're used for
00:58:11 <gfixler> outside of this case
00:58:18 <merijn> Otherwise you would just write "type family Foo a as :: *; type instance Foo Int [Bool] = Char"
00:58:27 <merijn> gfixler: Read the "Fun with Type Functions" paper
01:00:02 <merijn> gfixler: The ConstraintKinds extension, as used in my example, lets you implement custom Constraint instead of only being able to use typeclasses, hence you can do fun things like "all types except Int and ()", but you can do more complex things, like one of the other pastes I linked has a list type and a constraint for "list shorter than length N"
01:00:03 <gfixler> Microsoft?
01:00:17 <merijn> gfixler: SPJ works at MS Research, yes
01:00:24 <gfixler> It's making me download Fun with Type Functions: Genuine Advantage
01:00:36 <gfixler> let me get my serial # off the box
01:00:54 <merijn> http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
01:01:01 <gfixler> already there
01:01:28 <gfixler> 35 pages - this will take me a little while
01:02:43 <merijn> gfixler: It's not a very hard to read paper, so you should be fine with the observations you figured out so far from my pastes
01:04:36 <gfixler> merijn: okay if I have more questions later?
01:04:51 <merijn> Well, depends how much later :p
01:04:59 <gfixler> merijn: possibly not today
01:05:11 <merijn> It's 1am, so I'm about to fall asleep, but if I'm around you can bug me sure
01:05:24 <merijn> Although I'm pretty sure others here can easily help too
01:05:25 <ab9rf> no sleeping!  sleep is for the weak!
01:05:54 <merijn> ab9rf: I've been skipping sleep to play games all thanksgiving weekend and I need to work :p
01:06:04 <ab9rf> bah
01:06:08 <gfixler> I'm not sleeping until I've read all of ocharles' papers
01:06:36 <ab9rf> merijn: i'm finally not hopelessly sick for the first time in a month and a half
01:06:50 <ab9rf> stupid recurring rhinoviruses
01:07:46 <gfixler> ab9rf: you just need a stop condition
01:11:19 <ChristianS> does the '<-' in monadic code and pattern guards have a name? how is it commonly called?
01:12:04 <merijn> ChristianS: It doesn't really have a name, it's syntactic sugar for >>=
01:13:01 <merijn> ChristianS: I tend to recommend reading how do notation desugars and avoiding it and writing unsugared code and only using do notation once you're comfortable doing that
01:13:04 <merijn> See: https://en.wikibooks.org/wiki/Haskell/do_Notation
01:13:54 <ChristianS> merijn: and >>= is called "bind"?
01:14:18 * hackagebot lucid 2.3 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.3 (ChrisDone)
01:15:07 <merijn> Yes
01:16:13 <sgronblo> i guess a lot of people informally talk about <- as extracting or assigning
01:16:34 <ion> or ‚Äúdrawing‚Äù x from m
01:16:51 <ChristianS> sgronblo: yeah i also thought about "extract"
01:17:12 <ion> ‚Äúextract‚Äù is comonadic nomenclature.
01:17:13 <thebnq> i don't think i see much about it in the pattern guard context
01:17:17 <merijn> ChristianS: Yea, but as the desugar thing shows it's not quite true
01:17:28 <merijn> Since
01:17:31 <merijn> :t (>>=)
01:17:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:17:58 <merijn> The type of >>= clearly illustrates how what you "get out" using <- can never *really* escape, as the end result will always be "m b" again
01:18:31 <Peaker> you don't get the value "out", you get the computation of that value "in"
01:19:09 <merijn> Peaker: Right, but that's not clear without using >>= explicitly :)
01:19:22 <merijn> Which is why advocate using >>= over do notation for beginners :)
01:19:43 <ChristianS> yes
01:19:51 <Peaker> yeah, until they want to write code others will use too :-)
01:20:12 <merijn> Peaker: I don't recommend using it for *actual* programming
01:20:41 <Peaker> merijn, btw, what's the state of your patch?
01:20:44 <merijn> I just recommend beginners use it until they're comfortable writing code that way and understanding what they're writing. THEN you start using do notation, because it's more readable and noisy
01:20:52 <Peaker> merijn, did you change the "catch" primop, etc?
01:20:53 <merijn> Peaker: the exception one?
01:20:57 <Peaker> merijn, yeah
01:21:17 <merijn> That was is half finished, once it became clear I wasn't making 7.10 I didn't really rush it
01:21:34 <merijn> I can get back to it this week or so
01:21:49 <Peaker> cool
01:22:13 <Peaker> I wonder if "mask" should be deprecated in favor of a new name "interruptibleMask" too, to make it clear you're not actually masking
01:22:33 <Peaker> I think the whole "interruptible" business is really a hack that indicates that passing around "restore" to where it matters is too difficult :(
01:23:08 <ReinH> Wadler talked about <- as "extracting"
01:23:25 <merijn> Peaker: Yeah, I'm not sure whether it'll be possible to retrofit a truly sensible async system into haskell, but I haven't had much time to think about it
01:23:36 <merijn> On account of no one being willing to pay me to think about it :p
01:24:02 <Peaker> heh
01:24:38 <merijn> Peaker: Same reason I don't get to spend much time working on my "sane, concurrent systems language" :p
01:24:45 <Peaker> ideally the type would tell you things.  IO t a where t can be an instance of Blocking, NonBlocking, Masked, etc?
01:24:50 <Peaker> (of course this is not possible :-) )
01:25:17 <ReinH> merijn: I get paid to work on some distsys stuff so I'm pretty happy :)
01:25:19 <Peaker> Maybe   type IO a = RealIO Unknown a ; instance AllTheThings Unknown
01:25:41 <Peaker> And then you can get static typing on this stuff incrementally ("gradual typing")
01:25:47 <merijn> Peaker: I've been thinking about ways to have multiple parallel type systems to encode properties like these
01:26:03 <Peaker> merijn, oh, right, you told me about that. There's another use case indeed :)
01:26:44 <merijn> Peaker: But I haven't really been able to invest enough energy for a prototype. I have a hard enough time doing any haskell hacking after work, hence the lack of exceptions patch so far :)
01:26:47 <jle`> Foldable.foldr :: Foldable t => t a -> ((a -> b -> b) -> b -> b)  -- rearranged
01:26:55 <jle`> Foldable.foldr :: Foldable t => t a -> ChurchEncodedList a
01:27:00 <jle`> never realized that :O
01:27:07 <Peaker> merijn, yeah, I barely have time for Lamdu recently :(  But slowly catching up with it
01:27:50 <jle`> Foldable.foldr converts any (t a) into a church encoded list
01:27:53 <Peaker> jle`, list foldr too, of course.  And "maybe" is church-encoded "Maybe" (rearranged). And "if'" is church-encoded boolean
01:28:27 <Peaker> jle`, basically a "pattern-matching" function (or a "fold" or "catamorphism") yields the church-encoding of types
01:28:30 <jle`> yeah, so one way you can imagine Foldable is just "any type that can be converted into a church encoded list"
01:28:42 <Peaker> jle`, Or simply: Foldable = ToList'able
01:28:49 <Peaker> (not necessarily Church-encoded)
01:29:03 <jle`> well, yeah :) that's how i always thought about it too, a  -> [a]
01:29:05 <augur> Peaker: no no no
01:29:16 <augur> Peaker: pattern-matching != fold/catamorphism
01:29:16 <jle`> but seeing this reflected in the type of Foldable.foldr is kinda neat
01:29:18 * hackagebot call 0.1.1.2 - The call game engine  http://hackage.haskell.org/package/call-0.1.1.2 (FumiakiKinoshita)
01:29:28 <Peaker> Another way to think of Foldable is Traversable_  (supports traversals with only the effect, not building up a new value)
01:29:34 <augur> Peaker: fold/cata = church encoding, yes, but just PM = scott encoding
01:29:35 <Peaker> augur, sorry, recursive-pattern-matching
01:30:00 <augur> ok, then yes, structurally recursive pattern-matched functions
01:30:02 <thebnq> is there maybe a derive for to make a church encode
01:31:21 <Peaker> thebnq, don't think so. For non-recursive types, I think making a church encoding encourages positional rather than named pattern matches, which is much uglier
01:31:40 <Peaker> case foo of Nothing -> .. ; Just x -> ..   is nicer than:  maybe .. (\x -> ..)
01:31:49 <Peaker> (especially for less common types)
01:33:01 <thebnq> true, sometimes its convenient though, style issues :s
01:33:14 <solatis> does anyone here actually use literate haskell?
01:33:29 <solatis> i like the idea, but i find the syntax somewhat... not nice
01:33:32 <thebnq> sometimes pattern matching is annoying with monadic code though
01:33:46 <thebnq> recently started to use foo >>= \case
01:34:24 <jle`> Peaker: btw, flip if' is now in base as of 7.8 :)
01:34:42 <merijn> jle`: You mean "Bool-elimination" ;)
01:35:13 <merijn> It's also not quite "flip if'"
01:35:15 <dmj`> solatis: agreed, I'd just use markdown then convert to .lhs via pandoc if that's possible
01:36:39 <jle`> merijn: it's not?
01:36:51 <solatis> yeah i don't like having to treat my code blocks as 'special' -- as in, bird style
01:37:01 <merijn> jle`: Bool is the last parameter
01:37:13 <jle`> ah
01:37:29 <solatis> hmmm maybe if my editor had good support for lhs it would be different tho
01:38:55 <dmj`> bird style is tough yes, \begin{code} \end{code} not too satisfying either, but maybe better
01:38:56 <jle`> @pl \if' b t f -> if' f t b
01:38:56 <lambdabot> flip . (flip .) . flip
01:39:18 <jle`> doesn't quite have the same ring
01:40:09 <solatis> jle`: flip flip flip has a pretty nice ring if you ask me
01:40:26 <solatis> or rather, flip dot flip dot dot flip
01:40:41 <ion> @ @djinn @type flip flip flilp
01:40:45 <ion> @@ @djinn @type flip flip flilp
01:40:46 <lambdabot>  Cannot parse command
01:40:46 <lambdabot>  Djinn> Cannot parse command
01:41:19 <malllle> @. @djinn @type flip flip flip
01:41:19 <lambdabot> Plugin `compose' failed with: Unknown command: "@djinn"
01:41:31 <malllle> ;/
01:41:40 <solatis> what's @djinn supposed to do?
01:41:56 <Hafydd> Constructs a term with a given type.
01:42:16 <jle`> @. djinn type flip flip flip
01:42:17 <lambdabot> f a b = a b (\ c d e -> c e d)
01:42:52 <ion> @unpl flip flip flilp
01:42:52 <lambdabot> (\ c f -> c f flilp)
01:42:58 <ion> @unpl flip flip flip
01:42:58 <lambdabot> (\ c f -> c f (\ g h i -> g i h))
01:43:24 <jle`> good job djinn
01:43:28 <ab9rf> heh
01:45:16 <augur> getting church encodings is extremely easy
01:45:31 <augur> thebnq, peddie^
01:45:32 <augur> ..
01:45:39 <augur> oh, no more peaker
01:45:43 <augur> sorry peddie, ignore that :)
01:46:15 <augur> thebnq: getting church encodings from a non-church-encoded type is as easy as deriving a fold function for it (if such a deriving exists; i dont know :x)
01:46:33 <solatis> if aeson is non-standards-compliant, in a good way, should i complain about it?
01:46:42 <augur> thebnq: tho, the best way to do this is to just use F-algebras and get it for free
01:48:40 <dmj`> solatis: seems a few have: https://github.com/bos/aeson/issues/100
01:49:19 <solatis> dmj`: basicly, json supports ints up to 2^53, while aeson uses an (unbounded) int64
01:49:57 <StoneCypher> solatis: does json explicitly bound or guarantee a minimum range
01:50:10 <solatis> StoneCypher: there are two competing standards
01:50:14 <solatis> ECMA json and RFC json
01:50:15 <StoneCypher> ew, really?
01:50:24 <StoneCypher> bugs under my skin already
01:50:25 <solatis> they say different things about, for example, character encoding
01:50:32 <StoneCypher> g'lawd
01:50:36 <solatis> yeah
01:50:41 <ion> nice
01:50:47 <solatis> everyone just does the sane thing and ignore the RFC
01:50:54 <StoneCypher> i would pick the one that seems likely to win, then i would complain on *any* difference between aeson and that spec
01:50:58 <solatis> since all javascript engines / browser engines use ECMA
01:50:59 <StoneCypher> inclusive or exclusive
01:51:18 <solatis> aaanyway, the JSON standard doesn't explicitly give a bounds to an int, but ECMAScript does
01:51:22 <solatis> (which is 2^53)
01:51:34 <StoneCypher> then yeah, i'd complain with an explanatory footnote
01:51:41 <solatis> yeah this is bikeshed
01:51:53 <StoneCypher> encoders need fine correctness
01:51:54 <solatis> but it means that aeson can emit json that's unparsable by a browser, for example
01:52:06 <solatis> ok, then i'll file a bug
01:52:07 <StoneCypher> i think this is a valid complaint.
01:54:13 <solatis> well json is a crappy standard imho
01:54:25 <solatis> i mean, why the f... doesn't it say anything about encoding types
01:54:33 <solatis> or about the bounds of a number
01:54:42 <StoneCypher> because it inherits those from the base language
01:54:45 <StoneCypher> and also because crockford
01:55:01 <solatis> which means JSON is incompatible between different languages
01:55:02 <solatis> great
01:55:15 <solatis> that's exactly what i *dont* want for a serialization format
01:55:24 <solatis>  /rant
01:55:44 <StoneCypher> no
01:55:50 <StoneCypher> the base language is ecmascript 262
01:55:57 <Freundlich> Or what the start symbol of the grammar is...
01:56:11 <solatis> i don't think so, StoneCypher
01:56:20 <solatis> json isn't defined with a "base language"
01:56:21 <StoneCypher> i could be wrong but that's what i've always believed
01:56:33 <solatis> it's an abstract format that doesn't target any specific language
01:57:04 <solatis> but javascript numbers are all IEEE floats, so that means 2^53 is the limit
01:57:24 <StoneCypher> k
02:00:31 <tattsun> hi, now i have a rsa public key string (for example "-----BEGIN PUBLIC KEY-----\nabcde...."), how can i generate RSAPubKey(in HsOpenSSL) from this string?
02:04:07 <solatis> tattsun: my suggestion: do a github code search to see how anyone else uses the library
02:06:11 <dmj`> tattsun: you don't need to
02:06:40 <dmj`> OpenSSL.Session (contextSetPrivateKeyFile :: SSLContext -> FilePath -> IO ())
02:06:57 <dmj`> after you open the session you can say where on disk the key is located
02:09:20 * hackagebot alarmclock 0.2.0.4 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.2.0.4 (dcturner)
02:11:01 <tattsun> dmj`: thank you very much! i'll check them on github.
02:14:42 <solatis> has anyone ever tried to stress-test the kind of number haskell is able to handle?
02:14:58 <solatis> for science, i'm considering calculating graham's number with haskell
02:15:03 <solatis> but i'm not sure how far i can push
02:16:16 <solatis> basicly, graham's number, in theory, requires more information to store than is available in the universe
02:16:36 <solatis> so i'm wondering how haskell will be able to cope with this
02:17:48 <SwashBuckla> import Memory.Universe
02:17:52 <solatis> then again, if i want to play around with this, might as well use GMP directly
02:18:18 <Kaidelong> is it possible that OI is just Identity?
02:19:20 * hackagebot atlassian-connect-descriptor 0.1.0.1 - Code that helps you create a valid Atlassian Connect Descriptor.  http://hackage.haskell.org/package/atlassian-connect-descriptor-0.1.0.1 (RobertMassaioli)
02:19:40 <Kaidelong> as in, IO essentially behaves like a magical Identity
02:19:56 <Kaidelong> if you try to reverse it, you have to get rid of the magic to keep it pure
02:20:11 <Kaidelong> Identity is its own comonad so you just end up with identity
02:28:17 <kalifornication> Hello people!
02:28:55 <StoneCypher> sup
02:29:50 <kalifornication> not much, how about your self?
02:35:45 <StoneCypher> kalifornication: not a ton
02:36:01 <StoneCypher> kalifornication: chat usually goes in #haskell-blah instead though, so that this channel can stay on topic
02:37:53 <solatis> a question out of pure interest
02:38:18 <hc> lol, #haskell-blah? nice name for a channel ;)
02:38:30 <solatis> i see a lot of libraries, such as Aeson, manually put an {-# INLINE #-} macro around functions
02:38:46 <solatis> in my days as a C++ coder, i was always told 'dont try to outsmart the compiler'
02:39:05 <solatis> isn't ghc able to inline the functions itself when the situation is optimal?
02:39:17 <solatis> why do all these libraries insist on manually telling the compiler to inline?
02:40:04 <dkbrk> ghc very agressively inlines anyway. Inlining is one of the primary performance improving mechanisms.
02:40:36 <solatis> yeah that's what i mean
02:41:02 <solatis> there is a tradeoff between having a function being too big so it introduces cache misses
02:41:16 <solatis> only the compiler has this knowledge at time of compilation
02:41:25 <solatis> why do all these libraries think they know better than the compiler?
02:42:24 <solatis> aren't all these manual declarations completely redundant? (as in, the compiler will most likely ignore it anyway when it's not optimal)
02:42:47 <dkbrk> There's a bit here on the wiki: https://www.haskell.org/haskellwiki/Performance/GHC#Inlining
02:44:21 * hackagebot ruler 0.4.0.1 - Ruler tool for UHC  http://hackage.haskell.org/package/ruler-0.4.0.1 (AtzeDijkstra)
02:46:32 <solatis> dkbrk: GHC's documentation is more comprehensive
02:47:11 <solatis> i think the advice of not exporting functions you don't use is far more insightful than using the INLINE pragma :)
02:47:18 <solatis> as in, that actually made sense
02:47:44 <solatis> ok
02:47:56 <solatis> apparently INLINE makes GHC *guarantee* it's inlined
02:48:41 <solatis> i would prefer INLINABLE over INLINE, tho
02:49:08 <jle`> solatis: i believe the general advice is to not inline, and only inline after extensive profiling
02:49:19 <jle`> not to explicitly inline pragma, i mean
02:49:52 <solatis> jle`: but how does a library know how its code is going to be used in practice?
02:50:05 <solatis> as in, wouldn't INLINABLE be better for a library?
02:50:05 <hyPiRion> well, isn't about everything in haskell inlinable? Afaik the compiler does heavy inlining
02:50:17 <dkbrk> solatis: also check out this http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/
02:50:19 <jle`> you don't...but you can try to make guesses :)
02:50:49 <hyPiRion> Not that I'm very knowledgeable about the internals, but that was what I thought was the case
02:51:01 <solatis> hyPiRion: yes that was my original point :)
02:51:22 <solatis> my C++ history has taught me to never try to outsmart a compiler, unless you're writing raw ASM
02:51:46 <solatis> but maybe gcc/llvm are a little more clever in optimisation than ghc, i'm not sure
02:52:09 <hyPiRion> solatis: I was recently burned by too heavy optimisation on the jvm actually, so I can share the pain :)
02:52:14 <solatis> but i personally think it's unwise to make a decision about inlining at the library level, and rather have the decision made when the actual function call is made
02:52:16 <dkbrk> That's a very loose rule of thumb, though. Realistically, you will find plenty of times when gcc "optimisation" makes things slower or doesn't inline when it should.
02:52:28 <hyPiRion> (As in, I optimised too heavily, ran twice as slow as less optimised code)
02:52:38 <solatis> dkbrk: that's why people always say "be careful with -O3"
02:52:50 <solatis> it unfolds a lot of loops, etc, but makes the code size bigger
02:52:50 <hyPiRion> "run -Ofast instead"
02:53:00 <solatis> thus introducing more cache misses
02:53:03 <solatis> etc
02:53:39 <dkbrk> The point is, if you care about performance enough, eventually you'll get to the point where you try to control the behaviour of the compiler.
02:54:32 <solatis> agreed, but i'm not sure if the INLINE pragma is the best way to go -- if the function is simple enough, the compiler will inline anyway, and if it doesn't want to inline it, it most likely has very valid reasons not to
02:54:59 <ChristianS> i always use -O2, seems to work well enough
02:55:09 <solatis> ChristianS: i'm talking about gcc eh, not ghc
02:55:24 <solatis> i believe -O3 is nowadays discouraged anyway
02:55:40 <ChristianS> solatis: ah, missed that
02:55:54 <solatis> -O3 is basically -O2 with -funroll-loops
02:56:19 <solatis> that means if you have, say, for (i ... <= 10), it will just repeat that code block 10 times
02:56:25 <solatis> instead of using a loop
02:56:45 <solatis> this will prevent certain instructions of being executed, and results in less instructions being executed in total
02:56:47 <solatis> *but*
02:56:52 <solatis> the code will be significantly bigger
02:57:04 <solatis> and thus you will introduce a lot more cache misses
02:57:08 <solatis> thus, in the end, being slower
02:58:08 <solatis> (if you have a big code block in your loop block of, say, 512 bytes, and duplicate that code 10 times, then *bam* there goes 5kb of your 1MB L1 cache)
02:59:26 <hyPiRion> Wasn't there an experiment using EA to generically find optimal compilation flags for a haskell program?
02:59:38 <hyPiRion> Perhaps that could be extended to function hints
02:59:56 <solatis> oh wait
02:59:57 <hyPiRion> genetically*
02:59:59 <solatis> 1MB of L1 cache
03:00:02 <solatis> hah
03:00:05 <solatis> i was being optimistic
03:00:20 <solatis> apparently 16kb is more realistic
03:00:22 <solatis> so there you go
03:00:58 <solatis> hyPiRion: there are no 'optimal compilation flags' -- to repeat a cliche, it's specific for your program/architecture, and you just need to profile
03:01:37 <solatis> https://upload.wikimedia.org/wikipedia/commons/9/95/Hwloc.png
03:01:44 <solatis> those are the cache sizes of an AMD bulldozer processor
03:01:58 <solatis> 16kb of L1 cache
03:02:07 <solatis> so you want your functions to be /as small as possible/
03:02:18 <solatis> inlining defeats that
03:02:42 <hyPiRion> solatis: right, optimal flags for your architecture
03:03:39 <solatis> not only that, optimal flags for your application
03:03:56 <solatis> if you have a 'hot spot' that 99% of the code is active in, then inlining might be suitable there
03:03:57 <hyPiRion> yes, of course
03:04:14 <solatis> ehr, 99% of the execution time is spent
03:04:30 <hyPiRion> http://donsbot.wordpress.com/2009/03/09/evolving-faster-haskell-programs/ was the thing I referred to
03:04:39 <solatis> i'll check it out
03:04:40 <hyPiRion> (If anyone's interested
03:06:33 <solatis> hyPiRion: funny, they talk about a 10x - 100x improvement with Data.Binary when they added the INLINE pragma there, but don't share numbers
03:08:14 <Guest96439> Hi, I am having trouble writing a function to split a list according to a list of integers, like [Int] -> [a] -> [[a]]. I think it is possible with take and drop, but i can't wrap my mind around it
03:08:36 <Guest96439> sorry for the noob question, hoogle and google didn't get me there
03:08:49 <dmj`> > splitOn "," "1,2,3"
03:08:51 <lambdabot>  ["1","2","3"]
03:09:15 <dmj`> what is your split criteria?
03:09:25 <ion> > splitAt 4 [0..10]
03:09:26 <lambdabot>  ([0,1,2,3],[4,5,6,7,8,9,10])
03:09:42 <dmj`> ^
03:09:49 <ion> > case splitAt 4 [0..10] of (xs,ys) -> splitAt 4 ys
03:09:50 <lambdabot>  ([4,5,6,7],[8,9,10])
03:10:12 <hyPiRion> solatis: I just remember skimming over it while doing a course on automatic code generation. Found the idea of using genetic algorithms to search the space interesting
03:10:25 <solatis> http://research.microsoft.com/en-us/um/people/simonpj/papers/inlining/index.htm
03:10:29 <solatis> that one is interesting
03:10:35 <hyPiRion> Granted, as always is the trouble with this, you optimise your benchmarks, not necessarily the general case
03:10:36 <Guest96439> ion, that is exactly what i needed, thank you
03:10:37 <solatis> more interesting than EA's blog post in any case
03:10:49 <solatis> it's a paper about how GHC decides to inline or not
03:11:03 <solatis> apparently it's not even called an optimization, it's called a simplification :)
03:11:50 <Guest96439> wait, no it's not
03:11:57 <sivteck> > span (<=4) [1..10]
03:11:58 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
03:12:10 <sivteck> ah
03:12:13 <sivteck> [[a]]
03:13:19 <hyPiRion> Guest96439: so "foo [4, 3, 2] [1..]" should return [[1,2,3,4],[5,6,7],[8,9]] ?
03:13:53 <Guest96439> hyPiRion, yes, sorry i couldn't explain clearly
03:16:07 <dmj`> Guest96439: foo [4, 3, 2] [1..] == [[1,2,3,4],[5,6,7],[8,9]] ? what exactly are you trying to do
03:16:29 <dmj`> ooooooo
03:16:30 <dmj`> got it
03:17:10 <dpn`> hyPiRion, if you have an inner loop in a prod app then you have a good benchmark to optimise ;D
03:18:24 <dmj`> > splitPlaces [4,3,2] [1..]
03:18:26 <lambdabot>  [[1,2,3,4],[5,6,7],[8,9]]
03:18:31 <dmj`> it's magic, magic, magic
03:18:47 <Guest96439> is that in prelude?
03:18:54 <dmj`> no, import Data.List.Split
03:18:57 <hyPiRion> oh, there's one implemented already
03:18:58 <dmj`> the split package
03:19:08 <dmj`> part of haskell-platform if you're into that
03:19:11 <hyPiRion> Well, it's possible to do https://www.refheap.com/3c05abd82f77b6752c67fd0eb too
03:19:23 <dmj`> @src splitPlaces
03:19:23 <lambdabot> Source not found. My mind is going. I can feel it.
03:19:26 <Guest96439> ah, cool. Thanks a bunch! that's awesome
03:20:24 <dmj`> http://hackage.haskell.org/package/split-0.1.1/docs/src/Data-List-Split-Internals.html#splitPlaces <-- source
03:20:47 <moop> my god
03:20:56 <moop> Data.List.Split is magical
03:20:59 <moop> i'm in love
03:24:50 <solatis> oh god now i'm into a bikeshed with the aeson authors whether aeson should conform to javascript json or not
03:28:01 <tdammers> solatis: what exactly are the pain points?
03:30:19 <solatis> tdammers: standards compliant versus compatibility
03:30:30 <solatis> tdammers: json doesn't say anything about upper/lower limits of ints
03:30:35 <solatis> of numbers, specifically
03:31:06 <tdammers> ah
03:31:18 <solatis> yet 99% of the JSON parsers out there are either based on IEEE floats (2^53) or int64 (2^64)
03:31:27 <solatis> in both cases, aeson is incompatible
03:31:32 <solatis> https://github.com/bos/aeson/issues/230
03:31:39 <tdammers> hmm
03:31:54 <solatis> "if aeson has an upper bound for numbers, you can't use it to talk to a standard-compliant system that has a higher (or no) bound."
03:31:55 <tdammers> the way I see it, aeson should use the best possible precision internally
03:32:01 <solatis> pretty much sums up the opinion of the library writer
03:32:23 <tdammers> so Double for floats, and Integer for ints
03:32:35 <solatis> well json just has 'number'
03:32:36 <tdammers> or even maintain a string representation internally
03:32:40 <solatis> which essentially is [0-9]+
03:32:51 <tdammers> json has int literals and float literals
03:33:01 <solatis> oh yes you are right about that
03:33:09 <solatis> it has numbers and ints
03:33:49 <solatis> anyway, i ran into this issue while talking to my database
03:34:03 <solatis> they overflowed the int, because it uses the v8 javascript engine
03:34:20 <tdammers> haha yeah... uhm...
03:34:26 <solatis> aeson says "that's their fault"
03:34:40 <tdammers> actually, I've been pondering this same issue in my javascript interpreter
03:34:43 <solatis> so it's essentially a "not my fucking problem" response :)
03:34:55 <tdammers> currently using Double and Int for numbers, but I'm seriously considering using Integer instead
03:35:06 <tdammers> anyhoo, lunchtime, brb
03:35:18 <solatis> well a good friend of mine works for rethinkdb, a database engine based on json
03:35:37 <solatis> of course, they had HUGE debates internally what to do
03:35:54 <solatis> in the end, they chose compatibility over "standards compliance", because, frankly, the JSON standard is extremely lacking
03:36:21 <moop> json is the worst
03:36:32 <solatis> you're obviously forgetting about XML
03:36:39 <chpatrick> it seems pretty reasonable to comply to a standard that's also more flexible
03:36:50 <chpatrick> rather than limit yourself to floats just because of js
03:37:09 <solatis> chpatrick: yeah i can see that point of view perfectly
03:37:11 <solatis> this is a minefield
03:37:52 <chpatrick> solatis: I mean couldn't you make some kind of wrapper that makes sure it plays along?
03:37:55 <solatis> imho someone at Json, Inc. should step up and make a better standard
03:38:26 <chpatrick> I mean
03:38:28 <solatis> chpatrick: well, the wisest thing to do would be for database API's and other things to use the right bounded ints
03:38:35 <chpatrick> why can't you just use Floats and Doubles if you're worried about js compatibility?
03:38:58 <solatis> because if i use a serialization library, the last thing i want to worry about is compatibility
03:38:59 <chpatrick> for any code that you know talks to something like that
03:39:25 <chpatrick> but surely you want to be sending data the other end will understand right?
03:39:26 <solatis> a serialization format should be compatible, regardless of the execution environment
03:39:33 <solatis> right
03:39:36 <chpatrick> if you're sending it data it can't understand anyway then you're doing the wrong thing in any case
03:39:40 <chpatrick> JSON or not
03:39:44 <solatis> and at the moment, aeson can send data the other side is not able to understand
03:39:55 <solatis> +to
03:40:01 <solatis> ehr, -to
03:40:14 <chpatrick> yeah but then you're sending the wrong data
03:40:34 <solatis> aha, so i should be aware of all the clients that might consume my json?
03:40:36 <chpatrick> the only difference is that the server throws an  error instead of aeson
03:40:45 <solatis> or silently overflows
03:41:07 <chpatrick> well usually you know where you're sending the data to right?
03:41:16 <chpatrick> aeson shouldn't make any assumptions about that
03:41:25 <solatis> i'm not sure, if i build a REST server i don't know who
03:41:29 <solatis> who's consuming my data
03:41:36 <solatis> it can be a browser, it can be a c++ application
03:41:41 <chpatrick> ok, then use floats?
03:42:18 <solatis> isn't that an implementation detail the serialization should deal with, rather than the one using the library/
03:42:26 <chpatrick> not at all
03:42:42 <chpatrick> the type of data you're sending is just as important as what it is
03:43:01 <chpatrick> you wouldn't blame the serializer if it doesn't catch you sending complete bogus input
03:43:04 <chpatrick> because it's not its job
03:43:15 <chpatrick> in this case bogus input is some weird numeric type that your client doesn't understand
03:43:38 <chpatrick> it's not its job to throw an error if you send a string instead of a number either
03:44:01 <solatis> that is true
03:44:03 <solatis> *however*
03:44:12 <solatis> in the case of json, it's different
03:44:32 <solatis> there are 3 definitions of json: the json.org website, which basicly says [0-9]+
03:44:49 <solatis> ECMA JSON, which says: "derives from ECMAScript", thus, 2^53
03:44:57 <solatis> and RFC JSON, which is a complete clusterfuck
03:45:05 <chpatrick> the problem is that your proposed fix would limit aeson's functionality when it's not really doing anything wrong
03:45:17 <chpatrick> and if you're worried about this problem you can stick to floats
03:45:38 <chpatrick> which is perfectly possible already
03:45:50 <chpatrick> and it's what you should be doing anyway if your client can only understand floats, right?
03:46:20 <solatis> so you expect every programmer to be perfectly aware of the implementation details of every JSON parser out there?
03:46:44 <chpatrick> no, but if you want to be JS-compatible there's an easy solution
03:46:50 <solatis> this is precisely an area where weird bugs pop up, and where i want a serialization library to *help me* reduce bugs, rather than introduce bugs
03:47:11 <chpatrick> but again it's like saying it should catch you using a completely different type
03:47:16 <chpatrick> it doesn't know what your client wnats
03:47:24 <solatis> ok, but i hope then we can at least agree there should be a big red warning that aeson numbers aren't compatible with the majority of JSON parsers out there?
03:47:34 <chpatrick> why aren't they though?
03:47:44 <solatis> because everyone uses the ECMA standard
03:47:46 <chpatrick> only if you use non-floats
03:47:49 <solatis> which says "2^53"
03:48:00 <chpatrick> is there such a thing as an aeson number?
03:48:05 <chpatrick> it's just a bunch of typeclass instances right?
03:48:09 <bitonic> aeson uses Scientific
03:48:10 <solatis> well it uses Scientific
03:48:30 <bitonic> basically a rational number
03:49:27 <bitonic> it follows pretty closely what json.org says
03:49:41 <bitonic> that is, a number representable by the scientific notation
03:49:42 <solatis> yes, which is not what most json parsers out there use
03:50:08 <chpatrick> ok but if you make a Scientific from a float it'll still be representable with IEEE right?
03:50:17 <bitonic> yeah, there is a mismatch there.  it would probably be more convenient to use an IEEE float
03:50:40 <bitonic> chpatrick: yeah, scientific can represent any IEEE float, but not the reverse
03:50:41 <chpatrick> so it's still possible to be compatible with JS without much trouble
03:50:59 <bitonic> the trouble is generating JSON which most JSON parsers can't parse
03:51:03 <chpatrick> whereas if they made it use float it would break whoever has some weird high-significant value application
03:51:08 <bitonic> I don't think it's a big issue
03:51:33 <solatis> i don't think it's a big issue either, i just think it merits a discussion
03:51:39 <chpatrick> I mean now it works for JS with a little bit of care, and also for whoever wants some weird bigdecimal
03:51:48 <chpatrick> if you made it use floats internally it would only work for JS
03:52:11 <chpatrick> I think that would be a step down especially since it currently conforms to a standard, even if it's not a very good one
03:52:28 <solatis> you're forgetting about the fact that there are multiple competing standards
03:52:37 <solatis> currently aeson uses json.org standard
03:52:40 <chpatrick> yeah I appreciate that
03:52:45 <solatis> while everyone else uses ECMA json
03:52:49 <sivteck> @hackage json
03:52:49 <lambdabot> http://hackage.haskell.org/package/json
03:52:56 <solatis> anyway
03:52:58 <solatis> i have to go
03:53:00 <chpatrick> I don't think floats are the last word on numeric encoding though
03:53:07 <chpatrick> what if you want a really big integer
03:53:18 <solatis> no, i think IEEE floats are an abomination
03:53:23 <solatis> it's the worst thing ever
03:53:25 <chpatrick> well then
03:53:48 <solatis> but when writing a serialization/deserialization library, compatibility should be a concern
03:54:06 <chpatrick> I mean
03:54:12 <chpatrick> you could make FromJSONSafe
03:54:25 <chpatrick> which reuses everything from FromJSON but you don't make instances for non-float stuff
03:54:28 <solatis> i rather have a FromJSONUnsafe :)
03:54:42 <solatis> anyway
03:54:43 <chpatrick> then you don't have to worry
03:54:48 <chpatrick> and aeson gets to be generic
03:55:08 <pharpend> solatis: my problem with aeson is that things don't round-trip.
03:55:14 <solatis> i understand
03:55:33 <chpatrick> you could even give it a default instanc4e
03:55:34 <pharpend> you have no idea how annoying it is that things don't round trip
03:55:39 <chpatrick> so then it's just instance FromJSONSafe Float
03:56:22 <solatis> pharpend: i understand, but if "everything that aeson serializes, it can parse" still holds
03:56:29 <chpatrick> https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/type-class-extensions.html#class-default-signatures
03:56:29 <solatis> just not the other way around
03:56:34 <bitonic> pharpend: because you lose precision in the dates?
03:56:40 <pharpend> bitonic: yup
03:56:45 <solatis> anyway, i'll continue the bikeshed in the GH issue :)
03:57:22 <bitonic> pharpend: is it really that annoying?  I've used aeson+dates tons of times, I never noticed
03:57:33 <pharpend> bitonic: the workaround is to use (decode . encode), then the values round-trip
03:57:54 <pharpend> bitonic: I only noticed it when I started doing consistency checks
04:14:24 * hackagebot rest-core 0.33.1.2 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.33.1.2 (ErikHesselink)
04:54:26 * hackagebot expiring-cache-map 0.0.5.3 - General purpose simple caching.  http://hackage.haskell.org/package/expiring-cache-map-0.0.5.3 (elblake)
04:54:28 * hackagebot expiring-cache-map 0.0.5.0 - General purpose simple caching.  http://hackage.haskell.org/package/expiring-cache-map-0.0.5.0 (elblake)
04:59:26 * hackagebot debian 3.85 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.85 (DavidFox)
05:13:41 <ChristianS> any vim users here? i wonder which haskell mode for vim is recommended?
05:14:47 <xpika> how do i break partition at every occurance of pattern "oneandtwoandthree" => ["one","and","two","and","three"] ?
05:15:58 <xpika> ChristianS: im using this https://github.com/eagletmt/neco-ghc
05:16:15 <bergmark> xpika: you can use splitOn from the split package
05:16:25 <bitonic> xpika: so wait, what's the pattern?
05:16:51 <xpika> bergmark: "and"
05:16:52 <ChristianS> xpika: that looks nice, thanks
05:17:17 <bitonic> xpika: ohhh.  yeah the `split' package will help
05:17:44 <FreeFull> xpika: https://hackage.haskell.org/package/split
05:17:50 <bitonic> :t intersperse "and" . splitOn "and"
05:17:51 <lambdabot> [Char] -> [[Char]]
05:18:08 <bitonic> > intersperse "and" $ splitOn "and" "oneandtwoandthree"
05:18:09 <lambdabot>  ["one","and","two","and","three"]
05:18:37 <bitonic> ta-dah!
05:19:13 <magicman> > intersperse "and" $ splitOn "and" "oneandandtwoandthree"
05:19:15 <lambdabot>  ["one","and","","and","two","and","three"]
05:20:31 <xpika> > split (onSublist "and") "oneandtwoandthree"
05:20:32 <lambdabot>  ["one","and","two","and","three"]
05:31:22 <Aleksejs> is there some magical function that would divide words to syllables?
05:32:07 <chrisdone> is there a name for a queue which only has one element and pushing n items onto it only takes the last one? so pushing will either put or replace
05:32:10 <FreeFull> Aleksejs: You'd probably want some sort of "english" library or such
05:32:43 <tdammers> interesting how common it is for people to expect really hard problems to be casually solvable in Haskell
05:35:39 <chpatrick> Aleksejs: http://en.wikipedia.org/wiki/Moby_Project#Hyphenator
05:35:41 <Cale> Aleksejs: TeX does this
05:37:23 <chpatrick> I would stick that in a ternary search trie or something
05:37:32 <indiagreen> I think lambdabot should have some kind of automatic ‚Äúyes, Edward has a library for this‚Äù response
05:37:33 <indiagreen> https://github.com/ekmett/hyphenation
05:38:30 <tdammers> I think we have reached ekmett singularity by now
05:38:53 <tdammers> (defined as the point where there are more programming problems that ekmett has solved than problems that he hasn't)
05:39:05 <chpatrick> haha no way
05:39:15 <tdammers> it does sometimes appear that way though
05:39:40 <hyPiRion> just waiting for https://github.com/ekmett/p-not-equal-np
05:40:13 <Cale> The ekmett singularity is when his projects start solving problems at a faster rate than he can do it himself.
05:40:34 <chrisdone> ["su","per","cal","ifrag"
05:40:38 <chrisdone> -- well that's wrong
05:40:42 <chrisdone> heh
05:40:42 <chpatrick> ekmett/auto-ekmett
05:40:59 <chpatrick> ekmett/ekmett
05:42:31 <chrisdone> it should be su-per-ca-li-fra‚Ä¶
05:43:08 <chrisdone> assuming it's supposed to be syllables
05:43:08 <chpatrick> moby has su-per-cal-i-frag-i-lis-tic-ex-pi-al-i-do-cious
05:43:08 <nshepperd> i'd say it's the right way to hyphenate
05:43:09 <gregnwosu> when I use the reader monad, or just currying for dependency injection i end up with my dependencies littered all over my code as opposed to neatly in one place
05:43:14 <nkar> does 'concurrently' from async guarantee that two actions will be performed at the same time?
05:43:16 <gregnwosu> is this supposed to happen?
05:43:19 <nshepperd> but hypenation isn't necessarily syllables...
05:43:24 <chrisdone> chpatrick: that seems correct
05:43:33 <tdammers> nkar: I don't think that's possible
05:43:58 <chrisdone> nshepperd: see chpatrick's version, that's how many syllables are in supercalifragelisticexpialidocious
05:44:35 <nshepperd> well, the number of syllables in a word can also depend on regional dialect/pronunciation
05:44:48 <chrisdone> not in this case
05:45:41 <nshepperd> yeah I know
05:45:55 <nshepperd> I don't think hyphenation is really the right answer
05:46:27 <nshepperd> maybe wordnet can provide syllable counts for english words?
05:47:13 <nshepperd> or one of the many nltk doodads
05:47:38 <chrisdone> what's wrong with chpatrick's link?
05:48:41 <nshepperd> oh, I didn't see that
05:48:47 <ClaudiusMaximus> chrisdone: your queue sounds like (deprecated) SampleVar http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent-SampleVar.html
05:51:09 <ab9rf> there is a well-established algorithm for english hyphenation, but there are words it doesn't handle ("minute").  it's used in TeX, and Knuth talks about it some in the TeXBook
05:51:50 <ab9rf> it can be adapted for some nonenglish languages (there are hyphenation tables for French and German)
05:52:57 <nshepperd> indeed, but hyphenation is not syllablization
05:52:59 <ab9rf> nshepperd: ultimately what you're asking for is impossible, as there are several english words which are spelled the same but pronounced differently; the best known of these is minute.
05:53:14 <ab9rf> mi-nute vs. min-ute
05:53:15 <chrisdone> ClaudiusMaximus: neat, thanks
05:53:33 <nshepperd> Aleksejs: ^^
05:54:04 <nshepperd> with syllablization you're always going to be stuck with "good enough"
05:54:37 <nshepperd> and hyphenation too, I guess, since that also depends on the pronunciation
05:54:38 <ab9rf> nshepperd: if you're happy with good enough, use the hyphenation algorithm
05:54:50 <Aleksejs> hmm, then it'd be an interesting topic for machine learning
05:55:08 <ab9rf> it'll be off in some edge cases but it'll definitely cover the 80% and most of the long tail too
05:55:17 <nshepperd> http://stackoverflow.com/questions/405161/detecting-syllables-in-a-word
05:56:03 <nshepperd> ab9rf: I'm just saying, you should train the algorithm on syllable data, not hyphenation data
05:56:20 <ab9rf> nshepperd: they're the same, since hyphenation is supposed to follow syllables
05:57:33 <nshepperd> they're not the same
05:59:33 <nshepperd> you don't break in the middle of a syllable, but there are also multi-syllable clusters that you prefer to keep together, like the "ation" in "hyphenation"
06:00:01 <chrisdone> nod
06:13:24 <greymalkin> Is there a way to bring two types of Control.Monad.Error together without explicitly wrapping them both?
06:14:29 * hackagebot product-profunctors 0.5 - product-profunctors  http://hackage.haskell.org/package/product-profunctors-0.5 (tomjaguarpaw)
06:14:31 * hackagebot opaleye 0.2 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.2 (tomjaguarpaw)
06:54:31 * hackagebot api-tools 0.5.2 - DSL for generating API boilerplate and docs  http://hackage.haskell.org/package/api-tools-0.5.2 (AdamGundry)
06:54:37 <lpaste> wei2912 pasted ‚ÄúPrime Factorization‚Äù at http://lpaste.net/115437
06:54:41 <athan> Is there a way to have haddock include source code links, like hackage?
06:55:08 <wei2912> how do i fix my code in the link above?
06:55:14 <wei2912> i'll paste the stacktrace, wait a moment
06:55:46 <lpaste> wei2912 annotated ‚ÄúPrime Factorization‚Äù with ‚ÄúPrime Factorization (annotation)‚Äù at http://lpaste.net/115437#a115438
06:55:55 <wei2912> stacktrace is below
06:57:22 <athan> wei2912: I get this error all the time when doing this
06:57:27 <athan> you need an `intSqrt`
06:57:45 <athan> my def is `let intSqrt = floor . sqrt . fromIntegral`
06:58:01 <wei2912> athan: thanks
06:58:13 <athan> on line 19
06:58:15 <athan> no prob :)
06:59:31 * hackagebot varan 0.5.1 - Process mpileup output to identify significant differences  http://hackage.haskell.org/package/varan-0.5.1 (KetilMalde)
07:10:59 <athan> Is there a way to pass in options to `haddock` from cabal? I'd like a custom theme :3
07:20:22 <hvr> athan: yes
07:21:34 <athan> hvr: Just found the --css option, sorry :S
07:24:04 <hvr> :)
07:24:08 <hvr> np
07:25:49 <tasker> Has anyone got any experience using the hakaru package ?
07:27:55 <athan> hvr: bright pink, everywhere :P
07:28:53 <athan> tasker: O_O I might have to get back to you in a few months... too cool :D
07:29:19 <tasker> it looks awesome - however I don't know much measure theory, and there doesn't appear to be that much documentation.
07:29:32 * hackagebot network-service 0.1.0.0 - Provide a service at the data type level.  http://hackage.haskell.org/package/network-service-0.1.0.0 (angerman)
07:29:44 <tasker> however I would like to get away from using pymc if there were a haskell equivilant :)
07:30:42 <athan> I'm a know-nothing when it comes to statistics in general, this looks like something I could really get interested in! Sorry I can't help you tasker :/
07:30:53 <tasker> athan: No problem :)
07:33:41 <jeltsch> Hi, I thought that it is possible to convert between STRef RealWorld and IORef.
07:33:53 <jeltsch> However,  I cannot find library functions for doing this.
07:33:56 <jeltsch> Any hints?
07:36:36 <bitonic> jeltsch: it seems like you should be able to do that importing `GHC.IORef'
07:37:25 <jeltsch> bitonic: Thanks for the hint. I am a bit worried though, because this seems to be GHC-specific then.
07:37:26 <bitonic> you can also obviously do it manually...
07:37:40 <jeltsch> bitonic: Obviously? How do I do it?
07:37:40 <bitonic> ah, this kind of stuff is definitely going to be GHC-specific
07:38:09 <bitonic> jeltsch: by reading the STRef and writing a new IORef
07:38:37 <jeltsch> bitonic: This is not conversion. In this case, I have two different references, one STRef and one IORef.
07:38:57 <jeltsch> Changes to the cell referenced by the STRef would not affect the cell referenced by the IORef.
07:39:27 <bitonic> ah, you want to use the same pointer both as an IORef and STRef
07:39:37 <bitonic> may I ask why?
07:39:49 <k00mi> jeltsch: the whole RealWorld business is a GHC-specific implementation detail
07:39:52 <greymalkin> So, liftIO raises an IO function into the ErrorT monad... what lifts an (Either a) b function into the IO monad?
07:41:16 <bitonic> greymalkin: you mean what lifts an `Either a b' function into `ErrorT a IO b'?
07:41:25 <k00mi> :t liftIO
07:41:26 <lambdabot> MonadIO m => IO a -> m a
07:41:34 <k00mi> greymalkin: what type should your desired function have?
07:41:49 <jeltsch> bitonic: I have an interface for certain algorithms. These algorithms are allowed to work with references; so they work in the ST monad. The final execution happens in IO though, via stToIO. The algorithm interface should still use ST, so that algorithms can only do sane things.
07:42:21 <tdammers> greymalkin: you can't lift anything into IO
07:42:57 <greymalkin> The function has `a -> Either EscrowError b` and I want it to have `a -> EscrowMonad b` where `type EscrowMonad = ErrorT EscrowError IO`
07:43:05 <jeltsch> bitonic: I need to treat some of the STRefs as IORefs finally, because I want to use mkWeakIORef to attach finalizers.
07:43:48 <bitonic> :t ErrorT . return
07:43:49 <lambdabot> Monad m => Either e a -> ErrorT e m a
07:43:53 <bitonic> greymalkin: ^^^
07:45:37 <jeltsch> k00mi: Do Haskell implementations other than GHC support ST at all?
07:47:12 <athan> arg wtf? Cabal is throwing a "cabal: Command.optionToFieldDescr: feature not implemented" all of a sudden...
07:47:28 <bitonic> jeltsch: I think hugs does.  in any case, STRefs are not in the standard, iirc
07:48:09 <jeltsch> Well, from a pragmatic point of view I have to say that my code is GHC-specific anyhow.
07:48:28 <jeltsch> Type families ‚Ä¶
07:48:51 <bitonic> right.  still, unpacking the GHC.IORef module would be very icky.  remind me, why would `mkWeakIORef' be different than `mkWeak'?
07:49:31 <jeltsch> It would be nice to have an stRefToIORef in Data.STRef or Data.IORef.
07:49:45 <k00mi> there aren't really any alternatives to GHC, but using internal modules is still not a good idea
07:49:55 <k00mi> they might change or make assumptions that are not documented
07:50:26 <bitonic> oh, I see
07:50:35 <jeltsch> bitonic: The difference between mkWeakIORef and mkWeak has nothing to do with STRef. It is about the difference between references and primitive Haskell types. So for STRef, you would also need some sort of specialized mkWeak variant, a mkWeakSTRef.
07:50:47 <bitonic> so mkWeakIORef uses the internal MutVar as the key
07:51:09 <jeltsch> bitonic: Yes.
07:52:28 <bitonic> right.  I'm out of ideas, if you want to do that
07:53:00 <bitonic> jeltsch: similar discussion about `TVar': <http://thread.gmane.org/gmane.comp.lang.haskell.libraries/20935/focus=20940>
07:53:11 <Denommus> Hi
07:53:13 <bitonic> for the time being, importing `GHC.IORef' would be the only way
07:53:40 <jeltsch> bitonic: For now, I will use GHC.IORef. If in the future any problems arise with this, I have to think about a different solution.
07:54:01 <jeltsch> I think there are workarounds in my particular use case, but they might impose some (small) runtime overhead.
07:54:03 <Denommus> I was scratching some arrow diagrams to check how some Wires are being built in the application I'm writing
07:54:09 <bitonic> jeltsch: it might be worth asking on `libraries'.  maybe there's something we're missing
07:54:18 <Denommus> The symmetry is impressive
07:55:05 <dmwit> Denommus: To pass GHC options through cabal, use --ghc-options
07:55:13 <dmwit> (from yesterday or whenever that question was)
07:55:35 <jeltsch> bitonic: I will ask there.
07:57:24 <Denommus> dmwit: I ended up rewriting the wire by scratching it on a piece of paper
07:57:49 <Denommus> dmwit: it was really easy to take the scratch and transform in wire composition
07:58:13 <dmwit> I'm glad you reached your goal.
07:59:14 <slomo_> Denommus: are you talking about netwire? if your code is public that would be great, i'm still looking for more (and more complex) examples ;)
07:59:42 <Denommus> slomo_: still not public
08:00:26 <Denommus> slomo_: I was going to make a simple game on top of it with SDL2, but the bindings are interesting enough to become an engine
08:02:01 <slomo_> Denommus: ok :) i'll wait then
08:04:53 <Denommus> It would be nice if one could automatically generate the arrow diagrams for a Netwire program
08:05:01 <lpaste> rhollor pasted ‚ÄúFactors‚Äù at http://lpaste.net/115439
08:05:19 <rhollor> what's wrong with this?
08:09:22 <Cale> rhollor: Because there are very few (zero) numeric types which are both instances of Integral (so as to support mod), and Fractional (so as to support (/))
08:09:26 <athan> Is there a way to group terms for haddock documenting? I've got a ton of pretty self-explanatory functions with a similar purpose, but explicity declaring that purpose at the top would be nice
08:09:30 <Cale> rhollor: Perhaps you wanted to use div
08:09:40 <Cale> (which is integer rather than fractional division)
08:10:32 <rhollor> Cale: thanks, someone just messaged me saying telling me that
08:11:01 <Cale> athan: If I recall, you can group things in the export list and put comments in the export list itself
08:11:33 <athan> Cale: Export list? :S
08:12:16 <Cale> see here: https://www.haskell.org/haddock/doc/html/ch03s04.html
08:12:31 <athan> thanks :)
08:18:29 <athan> Is there a way to write inline code blocks without it hyperlinking? I'd just like the font :/
08:18:43 <torpet> i trying to understand the following example
08:18:44 <torpet> https://www.dropbox.com/s/lrghqngltc2k1l8/Screenshot%202014-12-01%2017.16.28.png?dl=0
08:18:56 <torpet> apparently this is solvable without actually touching the integral, by interpreting at as a normal distribution
08:18:59 <torpet> could someone explain that to me?
08:20:59 <allyjweir> Hey all, trying to parse EXIF data. Found HsExif on Hackage but struggling to find docs/examples. Could anyone provide any pointers?
08:21:17 <tdammers> allyjweir: it's pretty straightforward isn't it?
08:21:27 <Iceland_jack> allyjweir: Do you understand 'parseFileExif'?
08:21:31 <tdammers> it's a two-step thing
08:21:31 <allyjweir> tdammers: I am a very green Haskell user
08:21:38 <tdammers> ah, fair enoigh
08:21:48 <tdammers> so first you parse the EXIF data from the file into an Exif structure
08:21:55 <allyjweir> I am trying to test it out in ghci
08:21:59 <Iceland_jack>     do Right exif <- parseFileExif "somefile"
08:22:00 <Iceland_jack>        ...
08:22:07 <tdammers> and then you call whatever accessors you're interested on that exif value
08:22:18 <Iceland_jack> That's a quick way to get access to the exif data
08:22:48 <allyjweir> I thought it would be a case of "print parseFileExif $ "path/to/file"" in ghci since I had installed the package with cabal
08:23:06 <Iceland_jack> allyjweir: That won't work
08:23:33 <allyjweir> Iceland_jack: yeah I found that out quickly. Could you explain why that won't work?
08:23:35 <lpaste> tdammers pasted ‚Äúexif example snippet‚Äù at http://lpaste.net/115440
08:23:48 <Iceland_jack> allyjweir: 'parseFileExif "path/to/file"' has type:
08:23:48 <Iceland_jack>     parseFileExif "path/to/file" :: IO (Either string (Map ExifTag ExifValue))
08:23:49 <tdammers> allyjweir: ^ here's a snippet from my current project
08:24:03 <tdammers> real-world code example
08:24:31 <allyjweir> tdammers: love a real world example :)
08:24:32 <Iceland_jack> allyjweir: You can do:
08:24:32 <Iceland_jack>     ghci> do exif <- parseFileExif "path/to/file"; print exif
08:24:51 <allyjweir> Iceland_jack: okay I was missing out the do
08:24:58 <tdammers> allyjweir: well, check the lpaste then :D
08:24:59 <Iceland_jack> tdammers: The 'liftIO' may be complicated if allyjweir is new to Haskell
08:25:12 <tdammers> Iceland_jack: yeah, there's a bit of clutter around the actual exif part
08:25:29 <Iceland_jack> allyjweir: Do you know what 'Either String (Map ExifTag ExifValue)' means?
08:25:30 <tdammers> applicative style <$> and all that, too
08:25:33 <allyjweir> I am taking a course at University and struggling to get my head around it all.
08:26:03 <mitu> allyjweir: the do isn't necessary: parseFileExif "path/to/file" >>= print
08:26:14 <Iceland_jack> mitu: I was keeping it simple
08:26:31 <Iceland_jack> (>>=) also complicates things like pattern matching :)
08:26:41 <allyjweir> I am getting "Not in scope: 'parseFileExif'"
08:26:45 <allyjweir> what have i missed?
08:26:51 <Iceland_jack> allyjweir: Did you import the module?
08:26:54 <tdammers> allyjweir: a suitable import, most likely
08:27:02 <Iceland_jack>     ghci> import Graphics.HsExif
08:27:07 <tdammers> I didn't include those in the paste
08:27:16 <allyjweir> AAAAAh. It was loaded (the package) but not imported
08:27:18 <allyjweir> right
08:27:22 <allyjweir> that makes more sense.
08:28:12 <allyjweir> Thank you very much folks. In the right direction now. I will experiment away and come back if I get really stuck again. Appreciate the help!
08:28:26 <Iceland_jack> allyjweir: No problem, best of luck
08:31:47 <mitu> If the goal is haskell proficiency, you might as well not defer understanding monads
08:37:38 <Denommus> mitu: I'd recommend first to understand Functor, then applicative, only then monad
08:40:03 <newsham> you can learn how to do basic IO in haskell without understanding the monad abstraction
08:40:21 <newsham> in fact, its prob a good background to understanding monads since it provices a concrete example of the abstraction
08:42:53 <athan> ...would scotty 404 when looking for a param that doesn't exist?
08:43:04 <mitu> when I was doing IO without understanding Monad I confused monadic bind and let
08:46:29 <indigo945> I don't understand Monad but I don't have trouble with it either
08:46:56 <indigo945> >>= , as far as I want to understand it, just takes a value from the left, performs magic and feeds it to the function on the right
08:47:01 <indigo945> nothing too bad
08:47:04 <allyjweir> Stuck again, time to go back to the books. :(
08:47:31 <athan> So -XOverloadedStrings doesn't work for Data.Text.Internal.Lazy.Text? :(
08:47:42 <bergmark> athan: it does, why are you saying it doesn't?
08:47:45 <nkar> allyjweir: don't give up.  read some tutorials and do simple exercises, then try to write something more difficult based on what you already know
08:48:00 <athan> bergmark: "No instance for (Data.String.IsString LT.Text)" :S
08:48:18 <allyjweir> nkar: yeah I think I need to do this instead of fruitlessly fighting with something harder
08:48:25 <athan> where LT is Data.Text.Internal.Lazy
08:48:47 <nkar> allyjweir: definitely!  haskell hides a lot of plumbing, so it may look like magic, but there's no magic, really
08:49:06 <bergmark> athan: the instance is defined in Data.Text.Lazy so you need to import that
08:49:16 <athan> bergmark: Ahh, thank you
08:49:32 <allyjweir> nkar: It has been a difficult transition from Python and Java over to Haskell. Feels like a completely different way to do everything
08:49:42 <newsham> [06:40] < mitu> when I was doing IO without understanding Monad I confused monadic bind and let
08:49:51 <bergmark> athan: this is why orphan instances are bad, but also you should generally stay away from modules named Internal
08:49:51 <newsham> obviously you'll need to learn those things when learning IO
08:49:54 <allyjweir> Whereas other imperative/OO langs aren't too bad to pick up
08:50:12 <mitu> allyjweir: it absolutely is
08:50:21 <nkar> allyjweir: you could try reading a book on scheme, then move to haskell.  that's what I did.
08:50:32 <nkar> that wasn't intentional, though
08:51:12 <allyjweir> nkar: I have Real World Haskell and have been reading through it. It has helped a little but not tonnes. Just looking into the Yorgey course that #haskell-beginners recommends
08:51:31 <nkar> I also suggest the haskell wikibook
08:51:39 <athan> bergmark: Ahh that makes sense. Thank you. I'm still getting used to the module system, I find myself wanting cycles often :S
08:53:15 <allyjweir> nkar: Okay. Will take a look
08:53:39 <bergmark> athan: when developing it's often nice to just stick everything in the same module and split it up later
08:54:15 <bergmark> then after a while i usually find a separation that makes sense
08:54:18 <allyjweir> nkar: It would be great if there was a beginners approach to haskell that doesn't assume prior programming knowledge. Would be really interesting to see someone approach Haskell that has never programmed at all. See if the ideas make sense more etc.
08:54:34 <bergmark> allyjweir: some universities start with haskell
08:54:34 <bitonic> allyjweir: that exists in many universities
08:54:43 <bitonic> that offer Haskell in the first programming course
08:54:45 <mitu> bergmark: wow! which ones?
08:54:55 <allyjweir> wow. interesting
08:55:00 <bitonic> I went to imperial college and it was like that
08:55:05 <bergmark> gothenburg does it, i think uppsala too
08:55:21 <bergmark> i started with common lisp ;-(
08:55:45 <allyjweir> Edinburgh and Oklahoma are listed on Haskell.org as doing it
08:56:53 <bitonic> allyjweir: in those courses you usually barely talk about monads anyhow, it's not really a "real world haskell" kind of thing
08:57:07 <bitonic> and that's good for an introductory course, I think
08:58:12 <bitonic> or at least, most people like it
08:58:27 <newsham> there's a good tutorial for starting with haskell thats targetted towards new programmers, called "two dozen short lessons in haskell" or something like that
08:58:47 <newsham> i think it would make a decent first language
08:59:17 <newsham> though prob needs more introductary material aimed at that..  non programmers arent going to be able to read a bunch of academic papers to learn topics
09:03:10 <indigo945> i think FP is nice for beginners, but barely-typed languages like scheme may be easier to understand
09:05:04 <newsham> i thin type checking could be a great asset when learning programming
09:05:13 <newsham> BUT type errors are prob not..  at least in the current state :)
09:06:39 <indigo945> well, you still get type checking, during runtime ;)
09:06:50 <indigo945> which has the advantage that type errors happen exactly when things go wrong
09:07:01 <Saltine>  /privmsg lambdabot @type map
09:07:07 <indigo945> so the student gets a better idea on where things have gone wrong
09:10:31 <newsham> indigo: finding bugs early is an advantage not just for professional programmers, but also for noobs
09:11:15 <newsham> you can use "undefined" liberally if you want to incrementally implement and test
09:12:00 <indigo945> but then you have to explain undefined, what it does and why it's needed, when what you really want to explain are basic concepts like conditionals and recursion
09:12:27 <indigo945> also, type errors don't help with finding bugs
09:12:54 <indigo945> they just inform you that there are bugs, but ghc's type messages don't really help with /finding/ them, particularly when you are a beginner
09:13:15 <koala_man> haha true
09:13:27 <newsham> i dont think "undefined" is a difficult lesson
09:13:57 <newsham> in fact, it could be the very first thing you teach them
09:14:06 <newsham> "lets write a program!  your first!   main = undefined!  tada!"
09:15:11 <indigo945> newsham: i love that that can actually be compiled, i had to try it :)
09:15:53 <ReinH> Why would you want type errors to happen "when things go wrong" when they could happen *before they have a chance to go wrong*?
09:16:40 <indigo945> in teaching or in production? because in production you don't want it
09:17:01 <indigo945> but in teaching it's useful, it's easiest to learn by making mistakes
09:17:35 <newsham> https://twitter.com/newshtwit/status/539467149614403584
09:21:13 <NemesisD> undefined and error are excellent development tools. I use them every day
09:21:57 <fizbin> undefined is great for "yeah, I'll finish this in a moment, just let me type-check this chunk of code over here"
09:22:22 <Iceland_jack> absolutely
09:22:23 <athan> Can I have multiple lines in a let statement? I'm not sure how to write this correctly, could someone show me? http://lpaste.net/115447
09:22:51 <fizbin> In fact, I should probably assign a shortcut key to that given how often I end up developing with that pattern.
09:22:58 <athan> or do I not need the extra indenting starting from line 10?
09:23:13 <geekosaur> athan, you can, your error is you on line 10 put something only valid in do inside the let
09:23:15 <athan> (line 10 and on shouldn't be made into let statements)
09:23:30 <geekosaur> you need to *un*indent those lines
09:23:41 <athan> geekosaur: Ahh that's the ticket. Thank you :)
09:23:48 <geekosaur> to somewhere before the "let" on line 2
09:24:03 <Cale> Well, it has to line up with the l
09:24:21 <Cale> (the f in formContent does)
09:24:26 <geekosaur> m, right, sorrry
09:24:29 <athan> geekosaur: is "let ... in" equivalent to "let"?
09:24:29 <geekosaur> but not be more indented than it
09:24:44 <geekosaur> "do"'s "let" turns into let ,,, in
09:24:57 <geekosaur> @undo do let {a = b}; x
09:24:58 <lambdabot> let { a = b} in x
09:25:05 <Cale> athan: yeah,  do { let { <decls> } ; <stmts> }  desugars to  let { <decls> } in do { <stmts> }
09:25:16 <Iceland_jack> athan:
09:25:16 <Iceland_jack>     do let a = ...
09:25:17 <Iceland_jack>            b = ...
09:25:17 <Iceland_jack>        print (a + b)
09:26:09 <athan> Cale, geekosaur, Iceland_jack: You all are heroes :)
09:26:12 <athan> thank you!
09:26:30 <athan> (& heroines, if that applies :])
09:26:36 <Iceland_jack> athan: :)
09:26:43 <athan> ...decidable type inference for gender roles anyone?
09:27:30 <Cale> IRC affords us parametric polymorphism with respect to gender. If we ignore it, it won't exist.
09:27:52 * geekosaur is not convinced that gender roles are decidable
09:28:14 <athan> :D
09:28:14 <ReinH> indigo945: Yes, it's easiest to learn by making mistakes. And the first kind of mistake you should learn about is type errors.
09:28:47 <Cale> The beautiful thing about using only text to communicate are that many things which were previously objects of prejudice are largely not present.
09:29:06 <Cale> is that*
09:29:07 <bitonic> ReinH: I think what he's saying is that it's nice to have partial results, to be able to run something
09:29:15 <bitonic> which some people like.
09:29:22 <ReinH> I think I understand that. And I strongly disagree.
09:29:47 <bitonic> bah, it can be nice. different people develop in different ways
09:29:55 <ReinH> Types in Haskell are one of our best tools for designing and reasoning about programs. We shouldn't be hiding them.
09:29:58 <indigo945> may i ask why? why is it so important to worry about types when all you do is implement fizzbuzz?
09:29:59 <Cale> bitonic, ReinH: did we just lose a whole bunch of your messages?
09:30:03 <indigo945> im not arguing that
09:30:14 <indigo945> im arguing that novice programmers shouldn't be taught haskell
09:30:19 <ReinH> Cale: I can't ansewr that :p
09:30:27 <chpatrick> why not?
09:30:36 <bitonic> ReinH: I didn't mean that -- I'm saying that while you're figuring out the types it might be nice to be able to run something
09:30:46 <chpatrick> there's so much stuff that you don't have to worry about in haskell
09:30:50 <bitonic> which is basically what you're doing when you're stubbing things with `error "TODO"' or similar
09:30:55 <bitonic> or -fdefer-type-errors
09:31:07 <ReinH> Why would you want to try to run something that will cause a runtime type error?
09:31:10 <ReinH> What do you learn?
09:31:25 <indigo945> well, imagine you're a beginning programmer
09:31:36 <Cale> indigo945: In my experience, starting people out on Haskell tends to produce pretty good programmers who, when programming in imperative, weakly typed languages, are sensitive to maintainability issues which would otherwise take decades to develop a sensitivity for.
09:31:37 <bitonic> ReinH: for example, you might know that that code path won't be triggered by a certain input, and you want to test with the other inputs
09:31:50 <indigo945> you got a homework exercise, write your first ever program - read a number from stdin, add 1, print to stdout
09:32:02 <ReinH> You would know that as a beginning programmer, but you can't know that you need to write programs that typecheck?
09:32:09 <indigo945> you don't understand types, so when you try to add 1 to a string
09:32:19 <indigo945> you either get:
09:32:24 <ReinH> You don't understand types? You do if you are *tought them*.
09:32:28 <Cale> indigo945: There's also a glib counterargument to the one you're presenting, which is -fdefer-type-errors
09:32:35 <ReinH> As a beginner, you learn what you are taught.
09:32:41 <benzrf> Cale: hiyooo
09:32:47 <ReinH> In Haskell, we try to teach beginners about types as early as possible.
09:33:01 <indigo945> Cale: i guess most people would argue that THAT isn't something beginners should be taught as common practice :)
09:33:05 <Cale> :D
09:33:28 <Cale> And why not? If it's meant to be a good idea to run your program with type errors in it?
09:33:32 <bitonic> the thing is, when beginners are taught Haskell, you can definitely sense the frustration when they can't figure out the types.  that frustration should be addressed in one way or another
09:33:48 <ReinH> bitonic: Yes, and it should be addressed by tackling the problem.
09:33:51 <Cale> Interactive help is a good way to reduce that frustration
09:34:07 <benzrf> bitonic: "when beginners are taught to drive, you can definitely sense the frustration when they have to stop at EVERY stop sign."
09:34:22 <ReinH> I don't think many people would argue that GHC's error messages can't be improved.
09:34:22 <Cale> Pointing out that the error message contains a line number and character position, even if they don't understand what the rest of the message means yet is another good things
09:34:24 <Cale> thing*
09:34:34 <bitonic> benzrf: but thankfully breaking a type system is not as crucial as stopping at a stop sign :)
09:34:38 <indigo945> benzrf: but the difference between learning to drive and learning to program is that programs don't usually kill people
09:34:44 <benzrf> indigo945: oh really
09:34:47 <Cale> But yeah, there's probably a lot which could be done to improve GHC's error messages
09:34:52 <indigo945> i think if cars didn't either, it would be great to just let people ignore stop signs
09:35:01 <benzrf> fft
09:35:02 <indigo945> then they have an accident and learn "oh damn, i really shouldn't ignore stop signs"
09:35:03 <rhollor> iRobot
09:35:06 <rhollor> nuff said
09:35:11 <ReinH> But if beginners are learning then presumably something is teaching them. That something can teach them about types.
09:35:16 <bitonic> ReinH: oh, I'm all for teaching people types.  I'm just saying that stubbing out functions with errors can be useful, that's all
09:35:27 <Cale> indigo945: -fdefer-type-errors
09:35:36 <ReinH> bitonic: I don't disagree with you there. Before we had nice type holes I used to use undefined as a type hole.
09:35:40 <Cale> indigo945: They'll get warnings and then run the program and it won't work
09:35:57 <indigo945> Cale: fair enough, it's just that everybody else is arguing that static typing is an excellent thing to teach to novices
09:36:00 <Cale> indigo945: which is pretty much what you're arguing they should be able to do...
09:36:03 <ReinH> I don't see the pedagogic value in running a program that you can prove will not work.
09:36:11 <indigo945> better than not passing the flag, anyway
09:36:26 <bitonic> ReinH: people like the feedback loop, even if the feedback is "this is broken here"
09:36:26 <Cale> I guess it shows them that "hey, the compiler knows what it's talking about"
09:36:29 <ReinH> indigo945: Well, you're in a Haskell channel...
09:36:40 <Cale> "maybe I shouldn't ignore these type error things after all"
09:36:42 <ReinH> bitonic: The compile error provides that feedback...
09:36:42 <bitonic> ReinH: and they need to get used to the other feedback loop, with the type checker
09:37:14 <bitonic> ReinH: yeah, but I find that at the beginning that feedback loop is very unpleasant to people, for some reason
09:37:22 <ReinH> Fundamentally I believe that beginners should be taught that the type system is one of the most valuable things that the Haskell language provides
09:37:29 <Cale> Getting a type error in Haskell is *sooooo* much better than running your program and getting a segfault
09:37:34 <chpatrick> I think it's better to train people to write programs that are correct than ones that are "correct enough by cursory inspection"
09:37:40 <ReinH> And ignoring type errors is fundamentally opposed to that philosophy
09:37:49 <bitonic> nobody's arguing that, I hope
09:37:59 <indigo945> ReinH: I'm actually d'accord with you on this
09:38:00 <Cale> Or a null pointer exception
09:38:00 <chpatrick> if you get good at writing code that typechecks you'll get code that will fail less at runtime too
09:38:19 <chpatrick> in whatever language, even dynamic
09:38:19 <indigo945> I just think they shouldn't be taught Haskell, period, which means that we can now leave our differences behind us :)
09:38:23 <Cale> (though the comparison there is weaker)
09:38:29 <ReinH> indigo945: sounds good
09:38:38 <Cale> indigo945: I disagree based on my experience teaching Haskell to beginners
09:38:47 <ReinH> I would just point out that Dijkstra disagrees with you :)
09:39:22 <bitonic> indigo945: right, I think that's the main disagreement :).  I'm definitely very glad they thought me Haskell in my first lecture
09:39:47 <Cale> indigo945: Even if they go on not to actually use Haskell, and instead decide that they really need to be programming in C or something, it makes them much more defensive
09:41:05 <bitonic> indigo945: but opinion differ.  many good programmers dislike Haskell, although that's rarer than disliking... other languages
09:41:44 <indigo945> eh, i LIKE haskell, i just don't think it's a good introductory language
09:43:14 <bitonic> I wonder what the satisfaction rates are in those introductory courses
09:43:26 <bitonic> I think at Imperial many people like it
09:44:40 <simpson> I don't think that there's any good way to introduce programming with any first language.
09:45:58 <bitonic> so what, logic, discrete maths?
09:47:10 <chrisdone> it's hard to find a good introductory language that is also useful
09:47:22 <simpson> What I mean is that I don't think that we understand how people learn their first language. It's a lot like spoken language; there's linguistics, and then there's the individual spoken language.
09:47:37 <simpson> Similarly, there's CS, and then there's the individual programming languages.
09:47:42 <chrisdone> i don't think it's like spoken language
09:48:17 <chrisdone> spoken language is 99% memorization of words and phrases, 1% technical grammar
09:49:32 <josephle> and when you apply more than 1% of technical grammar, you realize how weird the phrases you memorized are :P
09:49:58 <chrisdone> learning programming is 80% technical, and the other 20% is looking up things you want
09:50:37 <simpson> But that's not what happens in the very beginning, when somebody is just learning.
09:50:51 <johnw> yeah, a lot of it is learning the libraries/APIs, not the language per se
09:50:56 <simpson> They work by looking at snippets that are pre-crafted, and learning how to alter those snippets.
09:51:07 <chrisdone> of course, the older you get, the more your natural language learning becomes like learning programming, because you try to learn "cheats" and "rules" to help figure out without having to do all the immersive memorization again like when you were a kid
09:52:19 <simpson> I dunno. Maybe I'm wrong. I'm not an expert.
09:56:07 <chrisdone> simpson: it's true that you have to learn libraries and functions and those make up the vocabulary of the language. i just meant that in terms of degree, vocab is less important than knowing the semantics/grammar, imo. in contrast, kids learn their first natural language by remembering a zillion special cases and grow up not knowing the foggiest about the technical terms for grammar or etymology
09:58:09 <simpson> chrisdone: Yes. I believe, based on experience with teaching, that this is how the world's armies of PHP and JS developers learned their hobby/trade.
09:58:22 <chrisdone> i partly think the reason people start off with examples of libraries is because people want interaction
09:58:48 <nshepperd> heh
09:58:52 <chrisdone> yeah, i know a few php programmers who don't learn what they're doing, they just copy/paste and fudge until it works
09:59:06 <bitonic> right, that was my point -- I think this need for interaction (in the sense of running something and getting some result, whatever it might be), is very real amongst people
09:59:22 <chrisdone> bitonic: me too. in a big way
09:59:44 <chrisdone> we're Bret Victor's views, of course
09:59:59 <bitonic> I think Haskell kinda reeducates people in thinking first more.  but you need to bait them into drinking the types kool aid :P
10:00:03 <chrisdone> but there's a reason people want a REPL
10:00:13 <nshepperd> probably this is a case where measured results should trump armchair philosophizing
10:00:32 <bitonic> I'm simply talking from a "making programming enjoyable to most" perspective
10:00:45 <bitonic> which I think is important
10:01:29 <chrisdone> yeah
10:01:39 <chrisdone> i've a friend who doesn't "get" the point of a REPL
10:01:49 <chrisdone> "why not just put some code in the editor and run it?"
10:02:01 <chrisdone> answer: because that's one level of indirection more than you need
10:02:26 <chrisdone> why use a terminal shell, when you could type your commands into an editor and run it?
10:03:03 <meretrix> Is it unreasonable for ghc to take about 15 minutes and 6GB of ram to compile a module with 10,000 lines of (automatically generated) code?
10:03:09 <bitonic> that's what *scratch* is for!  ehe
10:03:20 <johnw> chrisdone:  you should really do a comprehensive blog post on mastering the REPL with Haskell
10:03:22 <chrisdone> why should i be able to redefine a function in emacs to immediately see the result of my work? why not recompile emacs and restart the editor?
10:03:25 <bitonic> meretrix: let me guess: datatypes with lots of constructors
10:03:34 <josephle> chrisdone: I know you say it in jest, but there are people who take that question seriously and have shell functionality in their editors -_-
10:03:35 <meretrix> bitonic: Yes and lenses.
10:03:40 <chrisdone> johnw: you think? hm =)
10:03:43 <johnw>  I think a lot of people aren't using it right now because they just don't "get it"
10:03:49 <bitonic> meretrix: I'd say it is unreasonable but it happens.
10:04:02 <johnw>  most of the people I know who really value a REPL either come from Python or Lisp
10:04:04 <meretrix> Hmm ok.
10:04:07 <bitonic> I'd be quite confident that big data types are the culprits, not lenses
10:04:12 <chrisdone> johnw: yeah, indeed
10:04:33 <bitonic> I love a good repl, and good debugging tools
10:04:36 <meretrix> bitonic: Yeah some have up to 50 fields, so they're decent size.
10:04:54 <bitonic> meretrix: I was talking about lots of data constructors.  big fields shouldn't be a big problem
10:05:00 <bitonic> *big records
10:05:01 <chrisdone> relatedly i'm currently working on a better way for inspecting Haskell values in the REPL that doesn't require Data/Typeable instances, and should work on any type, from any module
10:05:26 <chrisdone> it'll only be in emacs, but agibianksy might want to add it to ihaskell
10:05:53 <bitonic> yeah, I'd like a "unityped" view of haskell data types sometimes.  that's the bad side of type-erasure, that you can't jump into a process and inspect data structures comfortably
10:06:03 <johnw>  what I really want for iHaskell is the ability for someone else to watch along as I enter things at the REPL there
10:06:03 <chrisdone> right
10:06:20 <chrisdone> johnw: yeah, that'd be neat
10:06:32 <chrisdone> a shared REPL but with only a restricted set of writers
10:06:33 <johnw>  it would be a fantastic pedagogical tool
10:06:43 <johnw>  and then you'd have an interactive history of what the two of you did together
10:06:52 <chrisdone> right
10:07:06 <johnw>  I think this is part of luite's vision also
10:07:07 <chrisdone> great for exploring
10:07:19 <bitonic> this is advanced stuff -- but a much more basic thing would be preserving environments across GHCi reloads...
10:07:34 <bitonic> that's the kind of stuff with types make more difficult, while it's super natural in an unityped world
10:07:54 <bitonic> (I'd still take the types anyday :P)
10:08:13 <chrisdone> bitonic: i'm not sure how much of that is static types fault or just ghci
10:08:47 <chrisdone> haskellers tend not to be from the smalltalk/lisp school of image-based persistence, it doesn't seem like many people care about it
10:08:52 <bitonic> chrisdone: well, maybe it's not that static types make it more difficult, but if you have static types you tend to organize your tools around a well-typed world
10:09:01 <bitonic> right
10:09:05 <bitonic> maybe it's mostly a cultural thing
10:09:29 <chrisdone> with my foreign-store hack you can retain values between reloads
10:09:30 <bitonic> it definitely can be done, but if for example you always erase types at runtime in these kind of tools you make that stuff exceedingly hard
10:10:06 <chrisdone> well the odd thing is ghci lets you redefine things actually
10:10:38 <chrisdone> data X = X
10:10:38 <chrisdone> let f = ‚Ä¶ X ‚Ä¶
10:10:38 <chrisdone> data X = Y
10:10:38 <chrisdone> let g = ‚Ä¶ X ‚Ä¶
10:10:46 <chrisdone> f and g will work on separate versions of X
10:10:49 <bitonic> why is that odd?
10:10:51 <josephle> if I had to choose between worst-case exponential space to store types at runtime and type erasure...I'd choose type erasure >_>
10:11:14 <chrisdone> bitonic: it's odd because established wisdom is that ghci must reload everything
10:11:30 <chrisdone> but this demonstrates you could reload a module without losing previous things
10:11:48 <bitonic> josephle: well, unityped languages (e.g. erlang, lisp...) do quite well with the type information at runtime.  but I'd like it just for GHCi anyway
10:12:37 <bitonic> chrisdone: well but I want to retain previous things and their bindings
10:12:57 <chrisdone> observe:
10:13:00 <bitonic> I want to be able to reuse them.  and if I reload a module that changes the memory representation of a bound thing, I'm screwed
10:13:10 <chrisdone> Œª> data X = X Char deriving Show
10:13:10 <chrisdone> Œª> let g (X c) = c
10:13:10 <chrisdone> Œª> :t f ()
10:13:10 <chrisdone> f () :: Ghci2.X
10:13:13 <chrisdone> Œª> f ()
10:13:17 <chrisdone> X 5
10:13:19 <chrisdone> Œª> :t g (X 'c')
10:13:23 <chrisdone> g (X 'c') :: Char
10:13:27 <chrisdone> ^ that's what lisp can do. but here's haskell doing it in a type-safe way
10:13:35 <josephle> bitonic: unityped languages don't have exponentially sized types due to type inference and polymorphism ;)
10:13:37 <chrisdone> oh sorry i missed some stuff
10:13:43 <chrisdone> i'll lpaste it
10:13:57 <lpaste> chrisdone pasted ‚ÄúRedefining data types, retaining old definitions‚Äù at http://lpaste.net/115450
10:13:59 <chrisdone> ^ see
10:14:31 <chrisdone> it sort of shuffled the X type to be 'Ghci2.X', but `f' still works!
10:14:39 * hackagebot snowflake 0.1.1.0 - A loose port of Twitter Snowflake to Haskell. Generates arbitrary precision, unique, time-sortable identifiers.  http://hackage.haskell.org/package/snowflake-0.1.1.0 (edofic)
10:15:21 <bitonic> josephle: I'm not saying you have to store the full types somewhere -- I'm saying you could tag the memory representation so that you can print out things nicely and know when it's safe to use some object in some context
10:16:34 <chrisdone> so the question is whether ghci can load a module and do the same thing like it did there?
10:16:39 <bitonic> chrisdone: yeah but it works on the old stuff.  what you're showing is just a matter of naming
10:16:50 <chrisdone> hm?
10:17:01 <bitonic> the old and new X are different types
10:17:05 <bitonic> they just happen to have the same name
10:17:11 <chrisdone> correct, as it should be
10:17:17 <bitonic> sure
10:17:22 <chrisdone> so what's the problem?
10:17:33 <bitonic> but I don't see how this shows that it's easy to implement preservation of environments across module reloads
10:18:05 <chrisdone> it's supposed to show that static typing is not the limit here but the particular implementation of loading
10:18:36 <bitonic> I want to be able to have `module X where; data Foo ...; f :: Foo -> Int', define `let x :: Foo = ... long thing ...' in GHCi, reload `X' changing the implementation of `f', and still use the previous `x'
10:19:04 <bitonic> chrisdone: I don't think it does show that though
10:19:28 * chrisdone shrugs
10:19:56 <bitonic> it shows that you should be able to use the things defined with respect to the version of the module you have loaded previously, yes
10:20:15 <bitonic> but that wouldn't be that useful
10:20:27 <bitonic> or at least that's not what I was talking about
10:20:54 <chrisdone> in emacs i can jump to `f' in your example and hit a key and it will redefine it in-place
10:21:48 <bitonic> chrisdone: redefine it in-place in the GHCi session?
10:22:06 <bitonic> like, it would take the definition of `f' and load it in GHCi?
10:22:11 <chrisdone> yeah
10:22:19 <bitonic> what's that key?
10:22:37 <chrisdone> C-M-x in *my* emacs =)
10:22:41 <bitonic> ahhh, OK :)
10:22:52 <bitonic> that's nice!  although it doesn't solve the general problem
10:23:11 <bitonic> your emacs has probably been the most advanced Haskell editor for the past 2 years or so :P
10:23:12 <chrisdone> i understand the general problem. the problem is that ghci does not handle this case
10:23:24 <chrisdone> my point is that static types shouldn't have much to do with it
10:23:37 <chrisdone> in fact, the harder problem is laziness, if anything
10:23:45 <chrisdone> or, purity
10:23:59 <chrisdone> dynamic lookup of symbols in dynamic languages makes for much easier updating
10:24:10 <chrisdone> if you have a web server running and you want to update its handler function, for example
10:24:26 <chrisdone> you can't do that in haskell safely without making an explicit IORef or Store
10:24:29 <bitonic> I think type erasure has to do with it
10:24:40 <bitonic> more than types themselves
10:24:40 * hackagebot gitlib-test 3.1.0.1 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-3.1.0.1 (JohnWiegley)
10:24:42 * hackagebot gitlib-libgit2 3.1.0.1 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-3.1.0.1 (JohnWiegley)
10:24:52 <chrisdone> what does type erasure have to do with it?
10:25:45 <bitonic> a safe dynamic language is forced to make sure that it is safe at runtime, and it does that by maintaining the types at runtime
10:26:13 <bitonic> this + dynamic lookup/late binding of symbols makes it easy to implement those features
10:26:33 <bitonic> because you can just swap in a function for another, and it might not work with old data, but it'll still be safe
10:26:42 <chrisdone> "safe"
10:26:49 <bitonic> safe as in memory safe
10:26:58 <chrisdone> like stopping the program safe
10:27:05 <bitonic> like not segfaulting safe
10:27:08 <chrisdone> for development purposes that seems useless to me
10:27:39 <chrisdone> i don't think you need to abandon type-safety in this case
10:27:49 <bitonic> well, the point is that if you're reloading something you either know that the old data is compatible or you can manually hack your way through handling the old data
10:27:54 <chrisdone> when you perform an update on a name, if it's the same type, everything can continue using it
10:28:24 <marchdown> Hi
10:28:39 <chrisdone> if you make an update with a new type, you should update the things that depend on it and load those in too
10:28:44 <bitonic> sure, but if you have erased all types at runtime and want to replace a module for a new version, it's hard to tell if that's OK
10:30:05 <chrisdone> bitonic: well there are two approaches
10:30:13 <chrisdone> either you want runtime errors like a dynamic language
10:30:20 <chrisdone> or you want compile time errors like a static language
10:30:26 <chrisdone> i want the latter
10:30:43 <bitonic> right, me too
10:30:43 <chrisdone> updating in-place in emacs is great, but i have no idea what broke until it runs and breaks 5 minutes later
10:31:00 <marchdown> I‚Äôm trying to write a function which takes a list of n numbers and returns a list of n-1 pairwise differences between adjacent numbers. I‚Äôm having difficulties with pattern matching. I‚Äôm trying to match a list of length ‚â•3 with f (x0:x1:xs), but then I‚Äôm stumped: f (penultimate:ultimate:[]) results in non-exhaustive pattern exception.
10:31:22 <bitonic> my point is that I find it super useful to be able to jump in a running process and kinda be able to understand what's going on, and that's damn near impossible without custom tooling in Haskell
10:31:25 <Peaker> is it possible to easily get "cabal install" to install a shell script to ~/.cabal/bin as well as the compiled package?
10:31:26 <marchdown> What should I do/refer to?
10:31:39 <Peaker> maybe I just ought to embed the shell script functionality in my executable...
10:31:58 <chrisdone> bitonic: i'd rather: (1) change a definition, (2) that triggers a type error on function 'calculateSalary', and so i go update 'calculateSalary', (3) now i update both the definition and 'calculateSalary' together at once and it succeeds, i now have perfectly type-safe code
10:32:00 <bitonic> and hot code loading is done that way in erlang/emacs/whatever.  I wouldn't use that stuff in production, but I still miss the debugging possibilities
10:32:35 <bitonic> chrisdone: I'd love that too.  but even being able to inspect and debug at the cost of possible runtime errors would be nice
10:32:35 <chrisdone> bitonic: sure. for what it's worth you can do this in a limited fashion in ghci
10:32:41 <bitonic> yeah
10:33:02 <bitonic> ironically in Agda I think it'd be much easier
10:33:13 <chrisdone> when i develop web apps i run them in ghci and reload them in ghci by either updating the function in-place or killing the thread and restarting it
10:33:15 <bitonic> because you're forced to carry around interface files with the definitions of all functions anyway
10:33:21 <bitonic> because you need them to type check
10:33:27 <bitonic> so the information is already there
10:33:57 <bitonic> chrisdone: so, is this "replace the function definition in GHCi" functionality available in recent `haskell-mode' :P?
10:34:01 <chrisdone> bitonic: you're aware that you can run a program in ghci in a thread and access its internal state, right?
10:34:39 <bitonic> yeah.  but to be fair I found it very awkward when I tried, and I haven't really used that facility seriously
10:34:43 <chrisdone> bitonic: no, it was just a five liner i wrote because someone in here asked for it. i'll probably implement a more sensible version later, after i've implemented a json interface to ghci-ng. the multi-line support in ghci is icky
10:34:59 <chrisdone> bitonic: i don't mean the debugging support, i just mean e.g.
10:35:16 <chrisdone> > state <- newMVar defaultState
10:35:17 <chrisdone> > tid <- forkIO (launchProcess state)
10:35:18 <lambdabot>  not an expression: ‚Äòstate <- newMVar defaultState‚Äô
10:35:19 <lambdabot>  not an expression: ‚Äòtid <- forkIO (launchProcess state)‚Äô
10:35:27 <chrisdone>  > readMVar state
10:35:28 <chrisdone>  > killThread tid
10:35:39 <chrisdone> while it's running you can look inside the state mvar
10:35:40 <bitonic> ah right, sure.  that's what I mean with "...without custom tooling"
10:36:03 <chrisdone> "without custom tooling"?
10:36:19 <bitonic> I always implement one version or another of that kind of thing, but I'd like to be able to do that without having to set up the instrumentation myself
10:37:08 <bitonic> also because when you have the generic facilities you can build nice tooling around it
10:37:23 <bitonic> e.g. in erlang you can say "when you enter this function, print the arguments it's receiving"
10:37:24 <bitonic> or stuff like that
10:38:59 <bitonic> I guess I just miss the interaction you get with an Erlang VM in general
10:39:38 <bitonic> I'm sure some lisps are even better, but I've never used them in anger
10:40:32 <Peaker> what's an easy way of spawning a process via the shell and capturing its stdout?
10:40:53 <Peaker> it seems System.Process can do this for non-shell processes, or it can give you a bunch of handles (not too bad, but not nice)
10:41:34 <ChristianS> Peaker: do you need shell expansion of arguments?
10:41:46 <Peaker> System.Process surely could be wrapped with a more composable interface
10:41:55 <Peaker> ChristianS: I'm creating a shell pipe-line
10:42:08 <Peaker> ChristianS: for ease of installation of a little utility, I'm trying to inline a wrapper shell script directly into my Haskell binary
10:42:24 <Peaker> I guess I could just implement the entire pipe-line in Haskell instead
10:42:33 <bitonic> Peaker: `io-streams' has a nice wrapper around `createProcess', if it helps
10:42:46 <bitonic> it might be easier to compose inputs/outputs with that interface
10:44:00 <bitonic> (that doesn't answer the shell issue though)
10:44:18 <koala_man> readProcess "/bin/sh" ["-c", "ls | cat | wc" ] ""
10:44:41 * hackagebot lucid 2.4 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.4 (ChrisDone)
10:44:49 <chrisdone> Peaker: a simple shell command? just use `shell' from System.Process?
10:45:28 <chrisdone> oh, you want a simple string back?
10:46:03 <Peaker> yeah
10:46:12 <chrisdone> yeah, i wish readProcess accepted a CreateProcess argument
10:46:24 <Peaker> the stuff System.Process can do conveniently seems so arbitrary
10:46:40 <chrisdone> indeed, i suppose it did evolved organically
10:46:43 <chrisdone> there's always shell-conduit =p
10:47:10 <deech> Is there some way to detect at the type level if a type family equation does not match?
10:47:11 <jfischoff> Peaker: I saw something on hackage that is like system, but captures output ‚Ä¶ I can‚Äôt remember what it is called, so not much help :(
10:47:29 <chrisdone> Œª> import Data.Conduit.Shell
10:47:29 <chrisdone> Œª> run ls
10:47:30 <chrisdone> dist  LICENSE  present.cabal  README.md  Setup.hs  src	TAGS
10:47:30 <chrisdone> Œª> run (ls $| grep "-i" "e")
10:47:33 <chrisdone> LICENSE present.cabal README.md Setup.hs
10:47:36 <chrisdone> :3
10:47:38 <jfischoff> deech: well it won‚Äôt compile, what are you trying to do?
10:47:55 <jfischoff> chrisdone: nice
10:48:19 <dcoutts> Peaker: we've cleaned it up quite a bit in the latest release
10:48:32 <chrisdone> Peaker: https://github.com/chrisdone/shell-conduit#piping
10:49:27 <chrisdone> Peaker: and http://hackage.haskell.org/package/shell-conduit-4.5/docs/Data-Conduit-Shell-Segments.html
10:49:52 <deech> jfischoff: Yes, but what I want to detect that an equation has not matched and try another equation.
10:49:54 <chrisdone> Œª> import Data.Conduit.Shell.Segments
10:49:54 <chrisdone> Œª> run (strings (ls $| grep "-i" "e"))
10:49:54 <chrisdone> ["LICENSE","present.cabal","README.md","Setup.hs"]
10:50:26 <chrisdone> deech: doesn't it work like that anyway? pattern matching in order?
10:50:36 <jfischoff> deech: I would think a final catch all in a closed type would let you do that
10:50:44 <jfischoff> like chrisdone said
10:51:29 <deech> chrisdone, jfischoff: The problem is that I'd like to keep the type family open.
10:51:42 <jfischoff> well
10:51:48 <chrisdone> hmm
10:51:54 <jfischoff> okay
10:52:01 <jfischoff> so there is the old way in HList
10:52:02 <deech> chrisdone, jfischoff: I suppose I'm being vague, sorry. I don't have a small example right now.
10:52:29 <jfischoff> you have a HEq thing
10:52:53 <jfischoff> that has a catch all for not equal and is open
10:52:53 <deech> jfischoff: Yeah, I was looking at that. Hoping there was something I was missing with type families.
10:52:56 <bitonic> chrisdone: I'm slightly surprised that you were able to generate that PATH module on hackage.  I wonder how much you can get to know of the hackage server with TH :P
10:53:11 <bitonic> or  how much damage you can do
10:53:33 <carter> the doc builds are in vms
10:53:38 <carter> so theres no security issues
10:53:42 <bitonic> ah, good :P
10:53:48 <jfischoff> deech: Is it not working?
10:53:55 <jfischoff> oh wait
10:54:17 <jfischoff> you want type families, I would just give up on them then if you can get it to work the HList way
10:54:41 * hackagebot kicad-data 0.1.0.0 - Parser and writer for KiCad files.  http://hackage.haskell.org/package/kicad-data-0.1.0.0 (kasbah)
10:56:31 <RyanGlScott> How can I figure out if a particular GHC extension implicitly enables others? (e.g., -XGADTs enables -XGADTSyntax)
10:57:07 <Fuuzetsu> proper way would be to use GHC API which gives definitive answer
10:57:22 <Fuuzetsu> example in Haddock source somewhere
10:58:11 <bergmark> RyanGlScott: you should be able to see this in the ghc docs
10:59:10 <RyanGlScott> I'm not familiar with the GHC API. Is there a particular module(s) that I should search through?
11:00:29 <deech> jfischoff, chrisdone: I've made a small example: https://gist.github.com/deech/9d4eb66acd18b74cab6a
11:03:06 <fresheyeball> howdy folks
11:03:46 <chrisdone> deech: right, that result makes sense
11:04:33 <chrisdone> deech: i think the resolver stops on line 9?
11:04:53 <dmwit> RyanGlScott: Do you need to figure it out programatically or just as a one-off?
11:05:21 <chrisdone> deech: CheckFoundF (F f) ‚Üí B is not an instance of F ‚Üí go with (CheckFound (F B)) ‚Üí No instance for Show (CheckFoundF B)
11:05:36 <Cale> fresheyeball: Hello! Feel free to ask any questions about Haskell you might have. :)
11:05:44 <RyanGlScott> dmwit: Just as a one-off, although I was hoping I could find a document that comprehensively lists all of these extension dependencies.
11:05:51 <RyanGlScott> dmwit: The closest thing I've found is this: http://git.haskell.org/ghc.git/blob/1d32a8503c2ebfab2bbdb696fe65dd0823d1ed27:/docs/users_guide/flags.xml
11:06:17 <chrisdone> deech: except type families don't say "No instance", if there's no instance it seems to return the term as a no-op. like when you get "Couldn't match expected type Int against SomeIntFunc a"
11:06:19 <deech> chrisdone: Why doesn't it fall through to line 12?
11:06:56 <dmwit> RyanGlScott: Right. The user manual lists a few.
11:07:12 <RyanGlScott> Actually, never mind. That corresponds to this (https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/flag-reference.html), which is much more readable.
11:07:17 <deech> chrisdone: I see. Are functional dependencies the way to go here?
11:08:02 <dmwit> RyanGlScott: For the others, I would guess there's a single file in the GHC source that gives all the implications, and I'd grep to figure out which one it was.
11:08:08 <dmwit> (But I don't have more pointed advice than that.)
11:09:15 <chrisdone> deech: not sure
11:09:22 <deech> chrisdone: Thanks!
11:09:43 <dmwit> RyanGlScott: Of course, the other thing you can do is ask here. Somebody may actually know off the top of their head.
11:11:13 <bitonic> deech: maybe GHC just chooses not to normalise type instances application when displaying error messages
11:11:23 <Thooms> I might repeat myself, but do you guys know about a some nice firms using Haskell ready to hire summer interns?
11:11:30 <Thooms> -a
11:13:21 <bitonic> deech: there is also this, which might be relevant <https://ghc.haskell.org/trac/ghc/ticket/8423#no1>
11:16:54 <Peaker> hey, soliciting opinions on a handy little tool I made today: https://github.com/ElastiLotem/resolve-trivial-conflicts
11:17:30 <Peaker> automating my git conflict resolution workflow, wonder if others use similar flows
11:18:44 <chrisdone> Peaker: fun =)
11:19:34 <Peaker> chrisdone: :)
11:20:42 <johnw> Peaker:  do you use Emacs?
11:22:19 <chrisdone> Peaker: you're aware of Emacs's merge conflict functionality, i presume
11:22:21 <ReinH> johnw: hi
11:22:27 <johnw> ReinH: heya
11:22:33 <ReinH> chrisdone: I'm not...
11:22:38 <johnw> Ediff!
11:22:45 <johnw> use 'E' in Magit on a conflicted file
11:23:16 <ReinH> huh, nice
11:27:00 <chrisdone> ReinH: http://lh4.ggpht.com/_egN-3IJO0Xg/S5H8gwTDaFI/AAAAAAAAE10/IeJwVvvN13k/s640/merge.png
11:27:17 * Fuuzetsu wishes magit was faster
11:27:24 <Fuuzetsu> I end up waiting for it too much
11:27:44 <bergmark> yeah it's pretty slow :-(
11:28:03 <Fuuzetsu> going to be porting magit to Yi in the future ;)
11:28:13 <Fuuzetsu> not that near future
11:28:26 <chrisdone> you could call it 'hag'
11:28:35 <Fuuzetsu> hagrid
11:28:38 <chrisdone> as a complement of 'git'
11:29:00 <RyanGlScott> Are these two statements equivalent?
11:29:02 <RyanGlScott> data ADT a where ADT :: a -> ADT Int
11:29:04 <Fuuzetsu> magit-but-without-elisp-so-it's-no-slow
11:29:11 <RyanGlScott> data ADT a = forall b. a ~ Int => ADT b
11:29:21 <johnw> Fuuzetsu:  there is work underway on development branch to make magit quite a bit faster
11:29:35 <johnw>  right now it repeats to many of the same commands when populating the status buffer
11:29:42 * hackagebot Sonnex 0.1.0.3 - Sonnex is an alternative to Soundex for french language  http://hackage.haskell.org/package/Sonnex-0.1.0.3 (zigazou)
11:30:05 <chrisdone> whenever i think of the 'git' name i think of https://www.youtube.com/watch?v=_EfW9znJYjw&t=1m35s
11:32:20 <chrisdone> johnw: also it updates too often when you're staging
11:32:35 <chrisdone> you can't tap 's' repeatedly without waiting, when there are a lot of files
11:32:47 <chrisdone> it should be like dired mode so you can press s s s s and then x =)
11:32:53 <johnw> chrisdone:  I know, I don't like that either
11:33:16 <johnw>  I still use command-line git for a lot of things, because magic is too overactive about re-updating its status buffer
11:33:17 <bergmark> why does it even take it that long to stage? git add is super fast by itself
11:33:37 <johnw> bergmark:  because it re-populates the entire status buffer after you stage anything
11:33:42 <Fuuzetsu> pressing ‚Äòe‚Äô just makes it wait forever in commit list ‚Äòl l‚Äô view
11:34:01 <bergmark> that's some expensive rendering :-(
11:35:52 <chrisdone> yeah
11:36:05 <chrisdone> it would be good if it hard some judicial smart caching
11:36:14 <RyanGlScott> More generally, are GADTs syntactic sugar for existential quantification and equality constraints?
11:37:20 <chrisdone> dunno =)
11:39:47 <chrisdone> RyanGlScott: it seems like a GADT lets your constructors have different types, whereas a regular constructor doesn't
11:40:05 <chrisdone> e.g. data X a where XInt :: X Int; XChar :: X Char
11:40:19 <RyanGlScott> chrisdone: Can you give a GADT example that you couldn't do using equality constraints?
11:40:20 <chrisdone> how do you express that with normal data types and existentials?
11:41:44 <Iceland_jack>     data X a = (a ~ Int) => XInt a | (a ~ Char) => XChar a
11:41:45 <Iceland_jack> is one way
11:42:03 <RyanGlScott> Right. Is there any effective difference between these two?
11:42:11 <chrisdone> right, you had to add a slot to the constructors, though
11:42:27 <chrisdone> interesting, though
11:42:31 <Iceland_jack> chrisdone: oh no you don't need the slot actually
11:42:34 <Iceland_jack> I misread the original code
11:42:44 <chrisdone> you don't? hm, indeed not
11:42:53 <Iceland_jack> @let data X a = (a ~ Int) => XInt | (a ~ Char) => XChar
11:42:56 <Iceland_jack> :t XInt
11:42:56 <lambdabot>  Defined.
11:42:57 <lambdabot> X Int
11:43:18 <RyanGlScott> I ask since I was wondering how Haskell represents GADTs internally, but I noticed that Template Haskell doesn't have a "GADT constructor" http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#t:Con
11:43:21 <chrisdone> good job
11:43:28 <RyanGlScott> It just seems to use ForallC.
11:43:31 <Iceland_jack> RyanGlScott: That's basically what GADTs turn into yes
11:43:31 <chrisdone> right
11:43:41 <Iceland_jack> GADTs are more a collection of several different features
11:44:13 <chrisdone> existential and type equality and rank-n types
11:44:22 <Iceland_jack> Yes and GADTSyntax
11:44:22 <RyanGlScott> That's another reason why I asked about extensions implying other extensions -- I was wondering if equality constraints was a specific thing enabled by both -XGADTs and -XTypeFamilies.
11:44:43 <RyanGlScott> Now that I've found the flag reference, it doesn't seem like that's the case.
11:44:59 <Iceland_jack> RyanGlScott: equality constraints don't require an extension as such
11:45:21 <Iceland_jack>     % ghci -ignore-dot-ghci
11:45:21 <Iceland_jack>     ...
11:45:21 <Iceland_jack>     ghci> :kind (~)
11:45:21 <Iceland_jack>     (~) :: k -> k -> Constraint
11:45:52 <chrisdone> GHC usually prompts to enable type families to use them
11:45:55 <Iceland_jack> But you need extensions to use them to define functions
11:47:29 <RyanGlScott> Iceland_jack: Huh, I didn't know you could do that.
11:47:40 <Iceland_jack> RyanGlScott: You can see which extensions an extension implies by diffing :set
11:47:45 <chrisdone> what's the relationship between existentials and rank-n types?
11:48:29 <Iceland_jack>     ghci> :set
11:48:29 <Iceland_jack>     <output>
11:48:29 <Iceland_jack>     ghci> :set -XTypeFamilies
11:48:29 <Iceland_jack>     <same output + KindSignatures + ExplicitNamespaces + TypeFamilies + MonoLocalBinds>
11:48:42 <Iceland_jack> (there should be a 'ghci> :set' in the penultimate line)
11:48:48 <chrisdone> MonoLocalBinds?
11:48:52 <chrisdone> curious
11:49:09 <Iceland_jack> Yes because generalizing let bindings becomes tricky with type families
11:49:50 <Iceland_jack> I'm not sure there is a deep relationship between existentials and rank-n types but I'd be interested to hear it
11:54:01 <chrisdone> having uhc's 'exists a.' existentials in ghc would be fun =)
11:54:37 <Iceland_jack> Yeah existentials are clunky in Haskell
11:56:06 <chrisdone> i suppose you can fake existentials with unsafeCoerce and rank-N types
11:56:43 <chrisdone> e.g.
11:56:46 <chrisdone> x1 :: exists a . a
11:56:46 <chrisdone> x1 = 3 :: Int
11:56:52 <chrisdone> x1 :: forall a. a
11:56:52 <chrisdone> x1 = unsafeCoerce (3 :: Int)
11:57:21 <chrisdone> ah, nah that's not a rank-n
11:57:42 <Iceland_jack> There is a similar idea that groups an existential together with a proof of its type
11:58:09 <Iceland_jack> http://semantic.org/stuff/Open-Witnesses.pdf and http://www.cse.chalmers.se/~emax/documents/axelsson2014efficient.pdf are relevant
11:58:57 <chrisdone> witnesses remind me of Proxy?
11:58:58 <Iceland_jack> Where you basically have:
11:58:58 <Iceland_jack>     LitB True ::: BoolType :: HiddenType
11:59:08 <Apocalisp> Is this a special case of anything?
11:59:09 <Apocalisp> @type let foo f (Just a) (Just b) = f a b; foo f Nothing x = x; foo f x Nothing = x in foo
11:59:12 <lambdabot> (t -> t -> Maybe t) -> Maybe t -> Maybe t -> Maybe t
12:00:28 <chrisdone> f <$> a <$> b?
12:00:45 <benzrf> chrisdone: f <$> a . b?
12:01:00 <benzrf> equal by ftor laws
12:01:42 <Iceland_jack> benzrf: How do you figure?
12:01:46 <Iceland_jack> :t \f a b -> f <$> a <$> b
12:01:48 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
12:01:49 <Iceland_jack> :t \f a b -> f <$> a . b
12:01:51 <lambdabot> (c -> b) -> (b1 -> c) -> (a -> b1) -> a -> b
12:02:12 <chrisdone> hmm, rather: join (f <$> a <*> b)
12:02:13 <benzrf> wait
12:02:27 <benzrf> crap, i was thinking of (<&>)
12:02:34 * benzrf thumps himself in the head
12:02:35 <gp5st> really stupid question http://www.happstack.com/docs/crashcourse/index.html#route-filters is the msum call not happening at runtime, but instead returning a function that simpleHTTP calls?
12:02:40 <ReinH> Um. Isn't it just liftA2 f?
12:02:50 <chrisdone> ReinH: no beause of the 'f a b'
12:03:00 <chrisdone> so i think join (liftA2 f)
12:03:02 <ReinH> ahh
12:03:19 <ReinH> yeah, join . liftA2 seems right?
12:03:20 <chrisdone> er, well
12:03:21 <Apocalisp> f Nothing x = x,  though
12:03:22 <Iceland_jack> chrisdone: Do you get the first or the second?
12:03:24 <chrisdone> yeah, with the .: stuff
12:03:28 <benzrf> join .: liftA2 f
12:03:30 <chrisdone> Iceland_jack: sorry?
12:03:36 <benzrf> join .:. liftA2 ( Õ°¬∞ Õú ñ Õ°¬∞)
12:03:41 <ReinH> :t let f = undefined :: a -> a -> Maybe a in liftA2 f
12:03:45 <lambdabot> Applicative f => f b -> f b -> f (Maybe b)
12:03:55 <ReinH> :t let f = undefined :: a -> a -> Maybe a in join (liftA2 f)
12:03:59 <lambdabot> Applicative f => f b -> f (Maybe b)
12:04:02 <chrisdone> :t let f = undefined :: a -> a -> Maybe a in join .: liftA2 f
12:04:05 <lambdabot>     Not in scope: ‚Äò.:‚Äô
12:04:05 <lambdabot>     Perhaps you meant one of these:
12:04:05 <lambdabot>       ‚Äò.‚Äô (imported from Data.Function),
12:04:08 <benzrf> i love monads
12:04:10 <chrisdone> =(
12:04:11 <benzrf> they're so bad
12:04:11 <Iceland_jack> chrisdone: where you pick the first non-Nothing value
12:04:11 <Iceland_jack>     foo f x       Nothing = x
12:04:11 <Iceland_jack>     foo f Nothing y       = y
12:04:11 <Iceland_jack>  
12:04:19 <Iceland_jack> feels more like MonadPlus
12:04:30 <ReinH> Hmm.
12:04:36 <chrisdone> oh, indeed
12:04:44 <EvanR> is there a proposal somewhere or analysis on the idea of "default instance" which means, all types that dont have an explicit instance still have some dummy implementation? or would it be impossible to satisfy a given class forall a
12:04:51 <chrisdone> monad plus was my first reaction but for some reason i discarded it
12:04:58 <Iceland_jack> > Nothing `mplus` Just 'a'
12:05:02 <lambdabot>  Just 'a'
12:05:18 <ReinH> EvanR: Well, parametricity means that this would only work in rather trivial ways
12:06:03 <ReinH> Typeclass instances are typically interesting *because* of their specialized behavior
12:06:06 <ReinH> otherwise you wouldn't need a typeclass
12:06:11 <chrisdone> @pl \f a b -> mplus a b >>= f
12:06:28 <ParahSailin> should the default keyword be able to specify default instances of IsString as well?
12:06:28 <lambdabot> flip (flip . ((>>=) .) . mplus)
12:06:31 <chrisdone> ew
12:06:36 <benzrf> ew
12:07:03 <Apocalisp> lovely
12:07:19 <Iceland_jack> But 'f' was supposed to be binary
12:07:28 <chrisdone> ohhh
12:07:32 <chrisdone> oh oh oh
12:07:37 <chrisdone> maybe These‚Ä¶
12:07:41 * chrisdone waves hands around magically
12:07:43 <EvanR> ReinH: for example, java supports this via default methods in the interface. haskell has this but it cant fully implement the whole class this way
12:07:51 <moop> > ( . Y . )
12:07:54 <lambdabot>  <hint>:1:9: parse error on input ‚Äò)‚Äô
12:07:57 <moop> :(
12:07:58 <ReinH> EvanR: can you give me an example of a typeclass that would make use of this?
12:08:03 <EvanR> ReinH: its easy to satisfy any inteface in javas type system, you just return null pointers...
12:08:30 <ReinH> EvanR: And in Haskell you can always return bottom, but this doesn't actually "satisfy" anything afai concerned ;)
12:08:39 <EvanR> i cant think of a good reason, i was looking for bad reasons
12:09:03 <ReinH> Well I can't think of a good reason, so perhaps you would share? :)
12:09:21 <HeladoDeBrownie> gp5st, simpleHTTP's type is given here, from which we can see it's a ServerPartT IO a for some a. Looking at the docs for that reveals it has a Monoid instance: http://happstack.com/docs/happstack-server-7.0.2/doc/html/happstack-server/Happstack-Server-Internal-Monads.html#t:ServerPartT
12:09:40 <HeladoDeBrownie> Woops, forgot the first link http://happstack.com/docs/happstack-server-7.0.2/doc/html/happstack-server/Happstack-Server-SimpleHTTP.html#g:1
12:09:45 <EvanR> i found something similar but this one seems to be actually possible https://ghc.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances
12:10:00 <EvanR> i think my thing is impossible in general
12:10:06 <EvanR> due to parametricity
12:10:07 <HeladoDeBrownie> gp5st, the computation does happen at runtime though
12:10:29 <Apocalisp> @pl \f x y -> join (liftM2 f x y) `mplus` x `mplus` y
12:10:31 <lambdabot> flip flip id . (liftM2 mplus .) . join . ((flip . ((mplus . join) .)) .) . liftM2
12:10:39 <Apocalisp> nice.
12:10:45 <chrisdone> ha
12:10:50 * Iceland_jack dies a little inside
12:11:09 <HeladoDeBrownie> gp5st, GHC performs precious little, if any, evaluation at compile time
12:11:09 <chrisdone> i was just writing:
12:11:09 <chrisdone> \f a b = liftA2 f a b <|> pure a <|> pure b
12:11:17 <chrisdone> er, with the join
12:11:32 <Iceland_jack> chrisdone: that's a nice solution, but I think it's an odd pattern
12:11:33 <Apocalisp> may as well use MonadPlus if there's join
12:11:34 <chrisdone> but that's dumb, the pures are bad
12:11:45 <chrisdone> hmmm
12:11:58 <Iceland_jack> Apocalisp: Where did you encounter the pattern?
12:12:00 <chrisdone> :t let foo f a b = join (liftA2 f a b) <|> a <|> b in foo -- normal
12:12:01 <lambdabot> (Monad f, Alternative f) => (a -> a -> f a) -> f a -> f a -> f a
12:12:36 <EvanR> ReinH: it could be used to make dynamic programming even harder, when an unexpected dynamic type arrives because of a bug or some other reason, you would not get a crash but the equivalent of php outputting empty strings
12:12:44 <Apocalisp> Iceland_jack: I've a type t that is "not quite" a monoid. Appending one t to another is partial
12:13:04 <chrisdone> Apocalisp: can These be used here?
12:13:13 <chrisdone> data These a b = This a | That b | These a b
12:13:16 <chrisdone> https://hackage.haskell.org/package/these-0.3/docs/Data-These.html
12:13:31 <Apocalisp> chrisdone: Possibly. I think Map is really more appropriate for my use case
12:13:49 <chrisdone> these :: (a -> c) -> (b -> c) -> (a -> b -> c) -> These a b -> c
12:13:55 <chrisdone> foo = these const const f
12:13:59 <EvanR> does Monoid specifically say its append operation is not partial? ;)
12:14:27 <Apocalisp> EvanR: I suppose I could just error instead of Maybe but that's a bit horrid
12:14:42 <ReinH> EvanR: um... why would... you want to do this?
12:14:44 <Iceland_jack> EvanR: It should be closed :) it's implied/understood
12:14:48 <sssilver> Hey guys, how can I write directly into the parallel port of the computer?
12:14:55 <sssilver> ...using Haskell
12:14:59 <EvanR> Iceland_jack: like div and mod in Integral?
12:15:14 <EvanR> seems a lot of details are not written down here in the class notes ;)
12:15:17 <ReinH> EvanR: Void is a perfectly cromulent instance of Monoid ;)
12:15:18 <Iceland_jack> heh
12:15:34 <ReinH> instance Monoid Void where mempty = undefined; mappend _ _ = undefined ;)
12:15:39 <Iceland_jack> ReinH: Yes, but it is trivially total
12:15:44 <sssilver> kinda like inb()/outb() equivalents in C
12:15:48 <ReinH> Iceland_jack: your face is trivially total.
12:15:54 <ReinH> Iceland_jack: sorry, I've been playing a lot of Call of Duty...
12:15:55 <Iceland_jack> ;)
12:16:13 <Iceland_jack> At least it's not partial
12:16:16 <gp5st> HeladoDeBrownie: I guess one of the things confusing me is in the def for dir (http://happstack.com/docs/happstack-server-7.0.2/doc/html/happstack-server/Happstack-Server-Routing.html#v:dir) where the (servermonad m, monadplus m) gets passed in
12:16:17 <ReinH> hahaha
12:16:27 <EvanR> sssilver: use the parallel port device file
12:16:31 <gp5st> sorry, I'm sure this is all obvious if I knew what I was doing :-\
12:17:09 <sssilver> EvanR: that'd be slower though
12:17:17 <EvanR> actually i dont even think that exists
12:17:56 <EvanR> sssilver: you need to use your operating systems low level interface, and so you might need to write some C code and then link to haskell with FFI
12:18:28 <EvanR> also note that "slow" doesnt mean much with something like parallel port
12:18:41 <EvanR> you are limited to the clock rate of the port
12:18:49 <sssilver> EvanR: so how do you make system calls in Haskell? Only through C bindings?
12:18:54 <EvanR> sssilver: yes
12:19:02 <EvanR> FFI, not necessarily C
12:19:11 <EvanR> in practice C
12:19:24 <carter> well, you could do it from raw haskell, but the primops for doing it arent there yet
12:19:34 <carter> basically call via C because the FFI call wont be the bottle neck
12:19:50 <sssilver> EvanR: but then how do you write high/performance applications in Haskell? You just write the whole thing in C/C++, then just invoke the function called my_high_performance_app()?
12:19:53 <shaykha> Quick question...is there a (n existing) data type which can hold a (more or less) infinite decimal expansion?
12:19:59 <sssilver> *high-performance
12:20:20 <carter> sssilver: if your bottleknecks are system calls, your'e not writing very interesting code :)
12:20:21 <EvanR> sssilver: you write the application in haskell and use a few carefully written primitive operations supported by the ffi
12:20:27 <carter> what EvanR  said
12:20:52 <carter> ok, what i said before isn't quite true
12:20:55 <carter> i'm just being annoying
12:21:01 <EvanR> that is, if the runtime doesnt already support whatever your high performance app is even doing
12:21:04 <koala_man> shaykha: Data.Ratio?
12:21:11 <ab9rf> carter: it just means all the interesting bits of your code are really in the kernel :)
12:21:52 <sssilver> 'interesting' is highly subjective
12:22:06 <sssilver> I don't even know whether to take personal insult at this or just let it go
12:22:08 <sssilver> probably just let it go
12:22:13 <EvanR> high performance over parallel ports is highly subjective ;)
12:22:46 <shaykha> koala_man: I'm asking so I can compute irrational numbers like pi or e...sorry, should have specified context
12:22:56 <sssilver> so what about working with things like graphics cards? pushing vertices down the pipeline, flipping video pages, etc, is that all done through FFI?
12:23:16 <EvanR> you use a graphics card via opengl
12:23:21 <ab9rf> sssilver: until someone adds GPU ineration to the primops, yes
12:23:37 <HeladoDeBrownie> gp5st, note the instance Monad m => ServerMonad (ServerPartT m), which is being used here
12:23:38 <ab9rf> the opengl APIs are part of the platform now
12:23:38 <EvanR> the bindings to opengl have already been written for you
12:23:59 <HeladoDeBrownie> gp5st, you don't need to apologize, you're not bothering anyone.
12:24:09 <HeladoDeBrownie> gp5st, if you do need clarification please ask
12:24:32 <HeladoDeBrownie> gp5st, are you familiar with typeclasses in general?
12:24:44 <koala_man> shaykha: in a lazy kind of fashion, and in the end evaluated to a certain precision?
12:24:44 <EvanR> besides opengl itself, the other stuff necessary to open a window and get input events has been written for you, see glfw-b
12:24:47 <ab9rf> i've recent;ly started playing the opengl bindings
12:24:57 <ab9rf> er playing with
12:27:00 <gp5st> HeladoDeBrownie: not really.  Beyond some project Euler solutions this is my first voyage into Haskell
12:28:06 <shaykha> koala_man: yes. I'm working my way through the Mega Project List (https://github.com/karan/Projects). I'm using the Gauss-Legendre algorithm to find pi to n decimal places, but double restricts it to around fifteen. Due to lazy evaluation, it should be possible to print an arbitrarily large expansion of pi, if I understand it correctly
12:28:46 <EvanR> > pi :: CReal
12:28:48 <lambdabot>  3.1415926535897932384626433832795028841972
12:28:52 <EvanR> > pi :: Double
12:28:54 <lambdabot>  3.141592653589793
12:29:02 <EvanR> > pi :: Float
12:29:03 <lambdabot>  3.1415927
12:29:10 <EvanR> pi :: Int
12:29:12 <EvanR> 3
12:29:16 <ab9rf> heh
12:29:34 <EvanR> * not real haskell
12:29:39 <mauke> pi :: Rational
12:29:42 <mauke> 22 % 7
12:29:49 <EvanR> classic
12:29:51 <shaykha> haha
12:29:59 <ReinH> really
12:30:25 <shaykha> I figured using the built in pi was cheating, wanted to do the calculation myself
12:30:39 <ReinH> > 355 / fromInteger 113
12:30:41 <lambdabot>  3.1415929203539825
12:31:09 <EvanR> > 911 / 113
12:31:11 <lambdabot>  8.061946902654867
12:31:16 <EvanR> > 911 / 311
12:31:18 <lambdabot>  2.9292604501607715
12:31:23 <HeladoDeBrownie> gp5st, basically, a typeclass defines some bindings, called methods, which can be used on types for which definitions are given for those methods, which are said to be instances of that typeclass. (These terms have nothing to do with the OOP terms of the same name.) So when you see the type (ServerMonad m, MonadPlus m) => String -> m a -> m a, it means you can choose any m so long as there are instances ServerMonad m and MonadPlus m i
12:31:28 <shaykha> take 20 $ show pi
12:31:33 <flux> ocaml still dosen't have pi defined in the standard library
12:31:48 <flux> so you quickly learn that let pi = 4.0 *. atan 1.0
12:32:06 <HeladoDeBrownie> gp5st, in this code, we're choosing m ~ ServerPartT m' for some m'
12:32:06 <ReinH> 355/113 is the best approximation until the numerator and denominators are both 5 digit numbers
12:32:29 <Hijiri> > 355 / 113 :: CReal
12:32:31 <lambdabot>  3.141592920353982300884955752212389380531
12:32:39 <HeladoDeBrownie> gp5st, and if you look at the docs I linked you'll see there is an instance for that http://happstack.com/docs/happstack-server-7.0.2/doc/html/happstack-server/Happstack-Server-Internal-Monads.html#t:ServerMonad
12:32:44 <EvanR> 355/113 isnt even as accurate as Double
12:32:49 <HeladoDeBrownie> for ServerMonad that is
12:32:58 <ReinH> I didn't say that it is
12:33:00 <HeladoDeBrownie> Hmm, I should've linked to the type's docs
12:33:12 <EvanR> ReinH: no apologize now!
12:33:14 <HeladoDeBrownie> gp5st, http://happstack.com/docs/happstack-server-7.0.2/doc/html/happstack-server/Happstack-Server-Internal-Monads.html#t:ServerPartT
12:33:21 <ReinH> EvanR: :p
12:33:28 <EvanR> thats such an illegitimate pi approximation
12:33:33 <benzrf> i wanna print out 100 copies of lockhart's lament & give one to every student at my school
12:33:33 <HeladoDeBrownie> gp5st, reading the instance list, you can see both a Monad instance and a ServerMonad instance there, meaning it satisfies both the constraints
12:33:36 <benzrf> y/n
12:33:43 <ReinH> EvanR: it's the best smallish approximation of pi
12:33:45 <benzrf> crap wrong channel
12:33:50 <HeladoDeBrownie> gp5st, (It's slightly more complex than that since the instances *also* have constraints, but they too are satisfied)
12:33:58 <HeladoDeBrownie> gp5st, make sense?
12:33:59 <ReinH> benzrf: lockhart's lament is pretty great
12:34:09 <benzrf> i have a /couple/ of quibbles w/ it
12:34:11 <benzrf> but
12:34:23 <benzrf> so much of it is so incredible perfectly explanatory
12:34:34 <ReinH> EvanR: the next improvement isn't until 52163/16604
12:35:44 <EvanR> > (1/0) / (1/0)
12:35:47 <lambdabot>  NaN
12:35:49 <gp5st> HeladoDeBrownie: conceptually that's begining to make sense.  Where I'm getting hung up is when dir "path-parth" $ ... is written, I don't understand how that ServerMonad is being passed in
12:35:55 <EvanR> > it == pi
12:35:58 <lambdabot>  Not in scope: ‚Äòit‚Äô
12:35:58 <lambdabot>  Perhaps you meant one of these:
12:35:58 <lambdabot>    ‚Äòid‚Äô (imported from Data.Function),
12:35:58 <lambdabot>    ‚ÄòC.id‚Äô (imported from Control.Category),
12:35:58 <lambdabot>    ‚Äòi‚Äô (imported from Debug.SimpleReflect)
12:36:20 <gp5st> HeladoDeBrownie: thank you very much for helping
12:36:34 <benzrf> > i + 1
12:36:35 <HeladoDeBrownie> gp5st, it's not being passed in, it's a constraint on what's being passed in
12:36:37 <lambdabot>  i + 1
12:36:42 <benzrf> > i^2
12:36:45 <lambdabot>  i * i
12:36:50 <benzrf> lambdabot: you're not WRONG...
12:37:03 <benzrf> @src (^)
12:37:05 <lambdabot> x ^ 0            =  1
12:37:06 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
12:37:06 <lambdabot>   where f _ 0 y = y
12:37:06 <lambdabot>         f x n y = g x n
12:37:06 <lambdabot>           where g x n | even n    = g (x*x) (n `quot` 2)
12:37:07 <lambdabot>                       | otherwise = f x (n-1) (x*y)
12:37:09 <benzrf> interesting
12:37:09 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
12:37:19 <EvanR> > e**(i*pi)
12:37:21 <lambdabot>  e**(i * pi)
12:37:28 <EvanR> > e**(i*pi) + 1 == 0
12:37:31 <lambdabot>  False
12:37:36 <benzrf> ba dum tsh
12:37:50 <benzrf> > e**((0 :+ 1)*pi)
12:37:51 <mauke> > (0 :+ 1) ^ 2
12:37:52 <lambdabot>  (-1.0) :+ 0.0
12:37:53 <lambdabot>  Couldn't match expected type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
12:37:53 <lambdabot>              with actual type ‚ÄòData.Complex.Complex a0‚Äô
12:38:05 <benzrf> aw
12:38:25 <EvanR> > e**((0 :+ 1)*pi) + 1 == 0
12:38:29 <lambdabot>  Couldn't match expected type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
12:38:29 <lambdabot>              with actual type ‚ÄòData.Complex.Complex a0‚Äô
12:38:36 * EvanR looks for the Expr
12:38:42 * EvanR ... expr
12:39:06 <EvanR> > exp ((0 :+ 1)*pi) + 1 == 0
12:39:09 <lambdabot>  False
12:39:27 <EvanR> cant catch a break
12:40:26 <HeladoDeBrownie> gp5st, if you're wondering how we decided that m ~ ServerPartT IO, it's because that's the type required by simpleHTTP
12:40:52 <HeladoDeBrownie> (~ is pronounced "unifies with", and you can think of it as basically type-level equality)
12:41:27 <EvanR> dont try to pronounce haskell
12:41:31 <Iceland_jack> Didn't gp5st say they were fairly new to Haskell? They may want to cover some basics before going into things like this
12:41:51 <HeladoDeBrownie> Iceland_jack, I was answering what it seemed to me was being asked
12:42:36 <HeladoDeBrownie> gp5st, if you are confused though feel free to ask for clarification or to take things slower
12:42:43 <Iceland_jack> Yes, maybe this is fine
12:42:49 <Iceland_jack> It can be hard to tell
12:43:16 <gp5st> HeladoDeBrownie: o.O I didn't see the => in the signature definition. I see, so that's defining a constraint and what's after that is the signature
12:43:19 <HeladoDeBrownie> Also to be fair the example types are kind of complex
12:43:25 <Iceland_jack> Yes
12:43:35 <HeladoDeBrownie> gp5st, the whole thing is the signature, but yes that's otherwise right
12:43:49 <Iceland_jack> gp5st: Do you know type classes?
12:44:03 <Iceland_jack> (welcome to #haskell btw)
12:44:03 <gp5st> Iceland_jack: yeah, it probably wasn't the best thing to start poking into
12:44:16 <gp5st> Iceland_jack: not before 10min ago :)
12:45:11 <Iceland_jack> I see :) type classes are fundamental to Haskell, it's worth getting it right (there is also #haskell-beginners)
12:45:17 <HeladoDeBrownie> gp5st, if you haven't read an introductory text, it might be a good idea
12:45:18 <HeladoDeBrownie> @where lyah
12:45:20 <lambdabot> http://www.learnyouahaskell.com/
12:45:29 <HeladoDeBrownie> LYAH isn't perfect but it's an okay introduction
12:45:49 <Iceland_jack> LYAH covers type classes well
12:45:54 * gp5st knows what he'll be diving into tonight
12:46:16 <Iceland_jack> Pedagogically I wish that InstanceSigs was turned on by default
12:46:18 <benzrf> cis194   !
12:46:23 <benzrf> Iceland_jack: what's intsancesigs
12:46:33 <Iceland_jack> An extension that allows you to write instance signatures
12:46:51 <Iceland_jack>     instance Functor Maybe where
12:46:51 <Iceland_jack>       fmap :: (a -> b) -> (Maybe a -> Maybe b)
12:46:51 <Iceland_jack>       fmap f = ...
12:47:18 <benzrf> Iceland_jack: oh neat
12:47:39 <HeladoDeBrownie> I've used that on occasion, it's one of those things that seems so pointless to enable but useful when it's on
12:47:47 <Iceland_jack> I always use them (except when the extension fails)
12:48:18 <EvanR> huh
12:48:28 <HeladoDeBrownie> On the other hand I do my best to avoid writing Functor instances at all when I can just derive most of them ;)
12:48:33 <Iceland_jack> When type classe instances get tricky, especially for multi-parameter classes, they are a god's send
12:48:42 <HeladoDeBrownie> But of course there are other typeclasses
12:49:44 <Iceland_jack> HeladoDeBrownie: It's common to rewrite existing type classes to learn, in that case it's a nice extension to have but I'd rather not tell newcomers to enable extensions for something like that
12:50:04 <Iceland_jack> The benefits are similar to top-level type signatures
12:50:42 <HeladoDeBrownie> Iceland_jack, sure, for learning purposes it's fine to rewrite things, but for other things DeriveFunctor is really handy
12:50:51 <Iceland_jack> Yes
12:50:52 <HeladoDeBrownie> Iceland_jack, or is that not what you meant?
12:51:06 <Iceland_jack> That's precisely what I meant :)
12:51:08 <HeladoDeBrownie> Okay
12:51:22 <HeladoDeBrownie> I was being semi-facetious anyway :P
12:51:36 <Iceland_jack> Because I'm a slow learner I sometimes define my Functors manually to get a nice feel for them
12:51:44 <Iceland_jack> and then derive them
12:52:24 <HeladoDeBrownie> Though there are times when I wish I could derive but I can't and instead have to manually do a mechanical definition, like when higher-ranked constructors are involved
13:02:43 <johnw> Iceland_jack: nice, I've wanted that extension before, thanks for mentioning it!
13:03:34 <Iceland_jack> You're welcome! :) I hope more people start using it
13:03:44 <johnw> I have a few files where the sigs are in comments
13:03:55 <Iceland_jack> Exactly, and I still need to do that sometimes
13:04:06 <Iceland_jack> Because of a bug in GHC
13:04:46 <HeladoDeBrownie> What bug?
13:04:52 <Iceland_jack> https://ghc.haskell.org/trac/ghc/ticket/9582
13:05:05 <Iceland_jack> I may have some projection/embedding methods:
13:05:06 <Iceland_jack>     from :: Expr a -> a
13:05:06 <Iceland_jack>     to   :: a      -> Expr a
13:05:06 <Iceland_jack> where Expr is some type family
13:05:21 <Iceland_jack> no sorry, Expr should be Repr
13:05:53 <HeladoDeBrownie> Heh, in my browser it says it was closed "7 horas ago"
13:05:59 <Iceland_jack> normally it should work beautifully as such:
13:05:59 <Iceland_jack>     type Repr (Expr [a]) = [a]
13:05:59 <Iceland_jack>     from :: [a]      -> Expr [a]
13:05:59 <Iceland_jack>     to   :: Expr [a] -> [a]
13:06:09 <Iceland_jack> Oh :) fantastic
13:06:11 <HeladoDeBrownie> The bug tracker has a bug :P
13:06:40 <Iceland_jack> It shows '7 hours ago' here, are you sure it's not localization?
13:06:54 <EvanR> even the bugs have bugs
13:07:00 <HeladoDeBrownie> My browser is set to Spanish, a correct localization would be "hace 7 horas"
13:07:09 <Iceland_jack> 'horas' means hours in Spanish and Portuguese
13:07:17 <HeladoDeBrownie> "7 horas ago" is just wrong, it's a mix of two languages
13:07:32 <EvanR> haha "just wrong"
13:07:32 <Iceland_jack> it's partially localized, that's a start! :-)
13:07:38 <kadoban> Haha
13:07:50 <Iceland_jack> But I'm glad it's been closed, slated for 7.10.1
13:07:58 <EvanR> Just Wrong, Just Nothing, Nothing
13:08:03 <HeladoDeBrownie> XD
13:08:04 <gilligan_> evening
13:08:17 <Iceland_jack> Before 7.10 it would have had to be:
13:08:17 <Iceland_jack>     from :: Repr (Expr [a]) -> Expr [a]
13:08:17 <Iceland_jack>     to   :: Expr [a]        -> Repr (Expr [a])
13:08:34 <Iceland_jack> Rather nasty
13:08:49 <obb> i'm looking for a good haskell ide. what do you guys recommend?
13:09:05 <EvanR> IRL people talk switching between languages all the time ;)
13:09:11 <kadoban> obb: vim
13:09:28 <EvanR> VisualHaskell++
13:09:47 <obb> :D
13:09:48 <mmachenry> obb: There's a well-known thing that Well Typed is making that's an on-line IDE. You can pay monthly for it or there's a free version. But I don't know anything else about it.
13:09:54 <gilligan_> watching some video of a haskell emacs programming session I see the operators "<x" and "x>" where the 'x' is not actually the letter x but some unicode symbol looking like a small x - can someone tell me what operator that actually is ? (not a big fan of these unicode replacement shannanigans ..)
13:10:07 <benzrf> √ó?
13:10:17 <Iceland_jack> gilligan_: (<*) and (*>)?
13:10:19 <Iceland_jack> :t (*>)
13:10:22 <gilligan_> no
13:10:22 <lambdabot> Applicative f => f a -> f b -> f b
13:10:27 <mmachenry> obb: https://www.haskell.org/haskellwiki/IDEs
13:10:27 <benzrf> gilligan_: their font may render * as √ó
13:10:37 <gilligan_> benzrf, nope
13:10:54 <obb> yes but what's the best? ^^
13:11:04 <obb> any pros/cons?
13:11:33 <EvanR> heres something, cons, fancy gifs http://carymrobbins.github.io/intellij-haskforce/
13:11:39 <EvanR> er, i meant to say pros ;)
13:12:50 <obb> autocompletion is indeed very helpful
13:13:12 <EvanR> when i first started programming i spent a good part of my youth using visual studio to write c++, i felt like i learned almost nothing until i started using linux to manually link object files
13:13:19 <EvanR> obb: of course, vim does this
13:13:29 <obb> how EvanR ?
13:13:50 <EvanR> the basic autocomplete, which is pretty good for being basic, is control N
13:14:01 <EvanR> but there are more sophisticated ones
13:14:12 <mauke> ^P
13:15:09 <athan> I think haskellmode does stuff like this (if i could get it working ]:)
13:15:53 <kadoban> obb: Like neocomplete and neco-ghc for instance (for fancier autocomplete in vim)
13:17:23 <obb> thx, keep it coming :)
13:17:57 <josephle> or youcompleteme as an alternative to neocomplete
13:18:15 <gilligan_> i'm using YCM with neco-ghc
13:18:18 <gilligan_> works just fine
13:19:10 <gilligan_> there are various good haskell related plugins for vim for things like hoogle lookup, importing modules etc
13:19:59 <jfischoff> http-conduit is very slowly decompress a large gzip body
13:20:17 <jfischoff> is there any pointers to making the response decompress faster?
13:20:32 <kadoban> obb: I like neosnippet a lot, I find myself missing it more than autocomplete when I have to go without. It makes boilerplate really easy to fill in
13:22:52 <Peaker> johnw, chrisdone: Yeah, I don't use it though. A lot of the "advanced" emacs stuff doesn't work well for me :( So I mostly use the basic stuff
13:24:22 <Peaker> Even haskell-mode's features don't really work for me, and I use emacs like a basic text editor for Haskell..
13:24:46 <Peaker> every time I try to set it up, some things work (usually very brittle) and other things break
13:25:40 <Peaker> I remember emacs diff/conflict stuff did a lot of cumbersome extra windows that confused my muscle memory :)
13:25:53 <Denommus> is there a generic typeclass for collections?
13:26:05 <Peaker> Denommus: many of them :)
13:26:23 <Peaker> Denommus: There's Functor, Foldable, Traversable, Applicative, Monad, ... which are applicable to collections
13:26:32 <EvanR> Collection ;)
13:26:45 <EvanR> Arbitrary ;)
13:27:41 <Denommus> Peaker: is the "partition" function present in any of them?
13:28:14 <EvanR> whats the type of partition function
13:28:23 <Denommus> :t partition
13:28:25 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
13:28:40 <gilligan_> benzrf, meh..guess it was *> after all - i just have no idea why it would be a good idea to sometimes render it as *> and other times as ◊>
13:28:45 <EvanR> :t T.partition
13:28:48 <lambdabot>     Not in scope: ‚ÄòT.partition‚Äô
13:28:48 <lambdabot>     Perhaps you meant one of these:
13:28:48 <lambdabot>       ‚ÄòS.partition‚Äô (imported from Data.Set),
13:29:01 <Peaker> Denommus: It's present for Foldables, if you just toList first
13:29:21 <gilligan_> benzrf, imho these unicode replacements are nonsense anyway.. but maybe that's just me
13:29:46 <Peaker> Denommus: I don't think there's a class for "partition" that returns two sub-collections
13:29:56 <Denommus> Peaker: will the compiler optimize that, though?
13:30:05 <EvanR> gilligan_ likes his text punchcard compatible
13:30:27 <Peaker> Denommus: I'm not sure -- you can inspect the compiler intermediate output
13:30:27 <Denommus> I'll create my own partition function, then :-/
13:30:33 <Peaker> Denommus: what collection are you talking about?
13:30:54 <gilligan_> EvanR, i like my text unambiguous :)
13:31:32 * EvanR gives gilligan_ a bunch of non-printable characters, and 1 I l and | in a bad font ;)
13:31:52 * gilligan_ runs and hides
13:32:45 <Denommus> Peaker: I just want a sorting function that works accross any collection
13:33:07 <EvanR> Denommus: is that operation more generically (a -> b) -> f a -> [(b, f a)]
13:33:15 <EvanR> rather than a binary partition
13:33:47 <Denommus> EvanR: it's (a -> Bool) -> f a -> (f a, f a)
13:35:48 <Peaker> Denommus: some collections are already sorted (Map, Set, etc). Others have no sensible "sorting" operation (unordered collections). Others yet are inefficient at sorting (lists). I don't think it should be "across any collection"
13:37:17 <EvanR> Vector has two such partition functions, one that preserves the ordering the other does not but is faster
13:37:33 <EvanR> dunno if that last message survived the netsplit
13:38:08 <Hijiri> at least lambdabot is still with us
13:39:18 <EvanR> Denommus: in any case, if you want your thing to be generic against that operation you can define your own class for people to satisfy
13:39:48 * hackagebot monad-logger 0.3.10.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.10.1 (MichaelSnoyman)
13:41:26 <EvanR> also in vector, theres span and break which has the same signature but different semantics
13:42:06 <sinelaw> when splitting package's types into a separate module, do you also move "basic operations" on those types?
13:42:21 <sinelaw> or do you only move the type declarations and instances?
13:42:33 <sinelaw> (file under "software engineering")
13:43:54 <EvanR> if the basic operations depend on other modules, it might get hard to avoid loops
13:44:05 <EvanR> otherwise its easy to put in the same module?
13:45:36 <sinelaw> in the same module as the types you mean?
13:46:14 <EvanR> yes
13:55:10 <Peaker> sinelaw: you often have to resort to a "Types" module that only exports types to avoid circular dependencies
13:56:34 <EvanR> even then if types are mutually recursive in structure you need to put them in the same module
13:56:42 * Fuuzetsu will smack the first person to mention boot files besides himself
13:56:51 <EvanR> PARADOX
13:56:58 <schell> has anyone here glued scotty (ScottyT) into extensible-effects?
13:57:36 <schell> or the other way around?
13:57:43 <Peaker> EvanR: or parameterize them
13:58:37 <sinelaw> Peaker, that's what I'm doing, but even there I need to push some functions
13:59:17 <Peaker> sinelaw: why?
13:59:33 <sinelaw> because more than one other module needs them
13:59:48 * hackagebot snaplet-persistent 0.4 - persistent snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-persistent-0.4 (MichaelXavier)
14:00:22 <Peaker> so put them in a different shared module?
14:00:40 <sinelaw> perhaps.
14:01:12 <sinelaw> some of them are also used to implement some instances.
14:03:55 <EvanR> Type.hs, Instances.hs ...
14:05:40 <monochrom> write *.hs-boot files to earn circular modules :)
14:09:49 * hackagebot hplayground 0.1.2.3 - monadic, reactive Formlets running in the Web browser  http://hackage.haskell.org/package/hplayground-0.1.2.3 (AlbertoCorona)
14:11:25 <Zemyla> Can you have a function, say something that's [a] -> [b], do something different if it's invoked with (Ord a) => [a] -> [b]?
14:11:34 <sinelaw> Zemyla, no
14:11:42 <sinelaw> but you can have type classes
14:13:06 * hexagoxel looks expectantly at Fuuzetsu
14:13:38 <Fuuzetsu> halloa
14:13:57 * Fuuzetsu smacks monochrom
14:14:05 <Fuuzetsu> bad
14:18:58 <Denommus> ok, I managed to write a partition generic function using Monoid, Applicative and Foldable
14:19:39 <Denommus> now... I need some way to make head and tail
14:28:48 <EvanR> Denommus: in the package that has Collection i think it asks all these questions
14:34:24 <suvash> hi people, just getting start with regexp is haskell. what's the best lib to find/replace string patterns (in Text data type preferably)?
14:36:24 <davidthomas> suvash: Unfortunately, that's a hard question
14:37:03 <davidthomas> to which I've figured out candidate answers at various times, but don't remember what I settled on
14:37:16 <davidthomas> it depends partly on your needs
14:38:05 <suvash> i did manage to use regex-compat and unpacking Text to String. It type checked fine but failed when provided a unicode string at runtime :\
14:38:15 <davidthomas> I'm using regex-tdfa in my current project
14:38:23 <davidthomas> and it is certainly getting my job done
14:38:41 <davidthomas> but I don't remember enough of how it compare s to the others
14:38:56 <Iceland_jack> suvash: Did the regex-compat library fail? Hopefully the Text -> String conversion didn't
14:39:35 <suvash> my use case is to replace part of a utf encoded string/text (s/pattern/something)
14:39:55 <ph88> g <- getStdGen >>= someFunction g x        is this the right syntax for putting the g from context into pure function someFunction  ?
14:40:23 <suvash> Iceland_jack: It died with `(Text.Regex.Posix.String died: (ReturnCode 17,"illegal byte sequence"))` but I can see that the Text can be written to a file alright.
14:40:28 <Hijiri> ph88: no
14:40:29 <GGuy> Any Emacs org mode users? Anyone reconfigured org-babel haskell to compile using ghc rather then the interpreter?
14:40:40 <Hijiri> It would parse as g <- (getStdGen >>= someFunction g x)
14:40:59 <Hijiri> because <- is a syntax thing that comes at a lower precedence than other operators
14:41:09 <ph88> Hijiri: so i must use (g <- getStdGen) >>=    ?
14:41:23 <Hijiri> something like fmap (flip someFunction x) getStdGen would work though
14:41:41 <ph88> eh
14:41:42 <Hijiri> ph88: no, you can't use g <- getStdGen as an expression like that
14:41:50 <Hijiri> it has to be a line in a do block
14:42:14 <ph88> are you sure ? thats different as somebody else told me
14:42:16 <Hijiri> if you don't like prefix fmap there is always flip someFunction x <$> getStdGen
14:42:30 <ph88> where is     do   in that ?
14:42:39 <Hijiri> you can't use <- outside of do
14:42:47 <ph88> oh
14:42:51 <Hijiri> do would presumably be somewhere above that line
14:42:59 <mmmm> Does anyone know if there's a tool to rewrite your imports to explicitly qualify them? (a bit like --ddump-minimal-imports
14:43:07 <ph88> what do i need    flip    for ?
14:43:48 <malllle> :t flip
14:43:49 <lambdabot> (a -> b -> c) -> b -> a -> c
14:44:12 <Hijiri> another thing is that the right side of >>= is expected to be a function :: a -> m b (for some m, a, and b)
14:44:37 <Hijiri> if someFunction is pure, it wouldn't return a monadic value
14:44:44 <Hijiri> (I forgot a Monad constraint on m)
14:45:17 <Hijiri> flip flips the arguments
14:45:57 <Hijiri> so someFunction is :: a -> b -> c, with g :: b and x :: c
14:46:30 <Hijiri> :t fmap
14:46:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:46:49 <suvash> Iceland_jack: seems like my issue is pretty much similar to this. http://stackoverflow.com/questions/5047626/matching-specific-unicode-char-in-haskell-regexp
14:46:53 <Hijiri> b has to be what you want, and a has to be the thing in the functor
14:46:53 <suvash> any ideas ?
14:47:27 <Hijiri> but fmap someFunction :: a -> (b -> c), which doesn't seem to be what you want because you already have x for b
14:47:46 <Hijiri> actually I just realized I might not know what you meant by getting g from context into a pure function
14:48:04 <ph88> g is from a generator so its not pure
14:48:05 <EvanR> suvash: "invalid byte sequence" when handling Text or String doesnt make much sense, must be the library borking. Though Text does make a note that "woe be to anyone who attempts to treat unicode characters in the surrogate range as real characters"
14:48:29 <Hijiri> You can't automatically get Monad m => m a -> a
14:48:29 <EvanR> "despite the fact that Char allows it fine"
14:48:36 <ph88> but i need the g in my pure function and the result would be not-pure i guess ...
14:48:55 <EvanR> :t fromJust
14:48:56 <lambdabot> Maybe a -> a
14:49:05 <Hijiri> You have to either stay impure, or the type you want to make pure has to have a function that lets you do it
14:49:12 <suvash> EvanR: yeah, i'll try some other libs and see :(
14:49:38 <ph88> i was thinking to wrap my pure function in Monad context ??
14:50:06 <Hijiri> what fmap does is apply a function to a value with a Functor context
14:50:13 <Hijiri> and all Monads are supposed to be Functors too
14:50:17 <EvanR> > fromJust Nothing
14:50:18 <lambdabot>  *Exception: Maybe.fromJust: Nothing
14:50:37 <Hijiri> so that would let you stay within the impure value
14:50:59 <ph88> so the value has the context and i need fmap to apply the function to that value ?
14:51:31 <ph88> what about the --  the value has the functor context    and i apply the value to the function ? (the other way around)
14:51:43 * EvanR tries to get out of an impure value
14:51:43 * EvanR enters a pure value instead
14:52:07 <Hijiri> what do you mean by apply the value to the function?
14:52:15 <ChristianS> is it always a bug if i get "Stack space overflow... Use `+RTS -Ksize -RTS' to increase it" ? or is it sometimes just necessary to increase the stack size?
14:52:36 <EvanR> its always been a bug for me
14:52:40 <ph88> maybe i can call a pure function with a value with functor context as argument
14:52:51 <EvanR> as far as excessive usage of memory is a bug
14:53:40 <ChristianS> EvanR: is there a recipe to find out what's wrong?
14:53:51 <Hijiri> assume f is a functor:
14:53:52 <Hijiri> you can't automatically get from f a -> a
14:53:52 <Hijiri> it has to be provided or written aside from the Functor instance
14:54:11 <Hijiri> Being able to input a value with a Functor context to a pure function would be equivalent, because you could apply id to it
14:54:46 <ph88> ok so i use    fmap (someFunction x) getStdGen   ?
14:54:56 <EvanR> ChristianS: i dont really know of one. setting up profiling is good anyway. but you can also put Debug.Trace.trace around to attempt to narrow down what in the code is causing it, if you have no idea
14:55:04 <Hijiri> You need a function that takes something with a functor context and returns something with a functor context
14:55:11 <EvanR> ChristianS: are you doing a lot of processing of large String values?
14:55:46 <ph88> :(
14:55:48 <ChristianS> EvanR: lots of Texts, actually. but this issue still came up quite unexpectedly
14:55:56 <ph88> i wanted my function to stay pure
14:56:12 <indigo945_> System.Random > fmap (random) getStdGen
14:56:14 <EvanR> all functions in haskell are pure!
14:56:44 <EvanR> ChristianS: try to run the parts of your program separately on various size inputs
14:56:54 <EvanR> well, large size inputs
14:56:58 <ph88> i dont understand why fmap would work with flip only, and not without flip
14:57:06 <Hijiri> fmap will transform a function to that for you
14:57:06 <Hijiri> :t (+1)
14:57:06 <Hijiri> :t fmap (+1)
14:57:07 <lambdabot> Num a => a -> a
14:57:07 <lambdabot> (Num b, Functor f) => f b -> f b
14:57:12 <indigo945_> flip just reversed the order of arguments
14:57:17 <indigo945_> :t fmap
14:57:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:57:20 <indigo945_> :t flip fmap
14:57:21 <lambdabot> Functor f => f a -> (a -> b) -> f b
14:57:31 <EvanR> :t flip (<&>)
14:57:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:57:57 <ph88> ok guys thanks i wil have to think about this
14:58:07 <ph88> because there are many options  i see
14:58:28 <indigo945_> well, you wanted a random value, right?
14:58:39 <indigo945_> System.Random> fmap (random::Bool) getStdGen
14:58:41 <Hijiri> sorry, lost connection
14:58:42 <indigo945_> lambdabot pls
14:58:43 <Hijiri> :t (+(1 :: Int))
14:58:43 <lambdabot> Int -> Int
14:58:49 <Hijiri> :t fmap (+(1 :: Int))
14:58:49 <lambdabot> Functor f => f Int -> f Int
14:59:03 <Hijiri> fmap "raises" a function to work in a Functor
14:59:09 <suvash> davidthomas: is there some examples on usage of tdfa ?
14:59:12 <ph88> ok can we use fmap without flip ?
14:59:16 <indigo945_> of course
14:59:27 <dibblego> ph88: all haskell functions accept exactly one argument, including fmap
14:59:28 <Hijiri> flip just puts the arguments in the right order
14:59:38 <Hijiri> in the case of using someFunction
15:00:02 <EvanR> hehe, flip reverses the arguments, and all functions have one argument. double think!
15:00:20 <ph88> yes pretty confusing
15:00:38 <EvanR> would be good if that were discouraged
15:00:48 <ph88> Hijiri: as i said when you might have not been here with your connection,  i will take this information and think about it some more. Maybe i will understand it tomorrow
15:00:49 <dibblego> ph88: we might talk about "a function that accepts two arguments" as an approximation, but up until that approximation causes confusion, in which case, we stop doing it ó and so no, flip does not reverse the order of arguments.
15:01:26 <dibblego> flip :: (a -> (b -> c)) -> (b -> (a -> c))
15:01:50 <Hijiri> well it's much easier to understand than saying that flip takes a function that returns a function, and takes the first argument of the returned function and returns a new function that takes the argument that would have been taken by the function that flip was applied to
15:01:59 <Hijiri> or you can just use type signatures
15:02:03 <EvanR> easier is to say
15:02:04 <EvanR> @src flip
15:02:05 <lambdabot> flip f x y = f y x
15:02:15 <dibblego> http://tonymorris.github.io/blog/posts/haskell-functions-take-one-argument/
15:02:29 <EvanR> all functions take one argument. and flip takes three!
15:02:37 <ph88> i'm leaving
15:02:55 <ph88> thanks for help, bye all !
15:03:10 <dibblego> ph88: ok, let us know if are stuck again
15:03:22 <ph88> i will come back for sure, but first ill think about it
15:03:24 <ph88> bye bye
15:03:27 <dibblego> ok bye
15:07:41 <benzrf> whats the simplest way to get `readPNG :: Filename -> IO [[Color]]'
15:09:15 <mauke> step 1 is probably png2pnm
15:09:30 <EvanR> theres http://hackage.haskell.org/package/repa-devil-0.3.2.2/docs/Data-Array-Repa-IO-DevIL.html
15:13:47 <benzrf> > iterate (take 3) [1, 2, 3, 4, 5]
15:13:49 <lambdabot>  [[1,2,3,4,5],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]...
15:13:53 <benzrf> > iterate (take 2) [1, 2, 3, 4, 5]
15:13:54 <lambdabot>  [[1,2,3,4,5],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,...
15:13:57 <benzrf> hmm
15:14:03 <benzrf> ah
15:14:30 <benzrf> > map (take 2) (iterate (drop 2) [1, 2, 3, 4, 5, 6, 7])
15:14:32 <lambdabot>  [[1,2],[3,4],[5,6],[7],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
15:14:36 <benzrf> neat!
15:14:48 <Aruro> > let curried= 1 + sin
15:14:49 <lambdabot>  not an expression: ‚Äòlet curried= 1 + sin‚Äô
15:15:10 <Aruro> how to write 1+sin as a curried function?
15:15:31 <exio4> (1 +) . sin?
15:15:36 <Aruro> > let b = (1+)
15:15:36 <monochrom> no currying is involved.
15:15:37 <lambdabot>  not an expression: ‚Äòlet b = (1+)‚Äô
15:15:39 <Iceland_jack> That's not currying though
15:15:48 <exio4> point-free I guess
15:15:54 <EvanR> > 1 + sin
15:15:56 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
15:15:56 <lambdabot>    arising from a use of ‚ÄòM324386214826779251329892.show_M3243862148267792513...
15:15:56 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
15:15:56 <lambdabot>  Note: there are several potential instances:
15:15:56 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:16:04 <Aruro> no 1+sin does not work
15:16:09 <Aruro> i checked in ghci
15:16:11 <EvanR> no Num instance for functions ;)
15:16:17 <Iceland_jack> Aruro: How do you want that to work?
15:16:37 <Iceland_jack> Should it be '1 + sin x' for a given x?
15:16:39 <benzrf> hmm...
15:16:39 <Aruro> i want it to work same way as let b=(1+)
15:16:52 <Aruro> yes jack
15:16:53 <mauke> define "same"
15:16:53 <Aruro> correct
15:16:54 <monochrom> exio4 has already solved it.
15:17:34 <benzrf> @let instance Num b => Num (a -> b) where f + g = getSum . (Sum . f) <> (Sum . g)
15:17:34 <lambdabot>  Parse failed: Ambiguous infix expression
15:17:36 <Aruro> yep
15:17:41 <Aruro> ty exio4
15:17:49 <benzrf> @let instance Num b => Num (a -> b) where f + g = \n -> f n + g n
15:17:50 <lambdabot>  .L.hs:159:10: Warning:
15:17:50 <lambdabot>      No explicit implementation for
15:17:50 <lambdabot>        ‚Äò*‚Äô, ‚Äòabs‚Äô, ‚Äòsignum‚Äô, ‚ÄòfromInteger‚Äô, and (either ‚Äònegate‚Äô or ‚Äò-‚Äô)
15:17:50 <lambdabot>      In the instance declaration for ‚ÄòNum (a -> b)‚Äô
15:17:50 <lambdabot>  
15:17:51 <Iceland_jack> Aruro: You can do what exio4 did, but in normal code I would simply recommend:
15:17:51 <Iceland_jack>     ghci> let foo x = 1 + sin x
15:17:55 <benzrf> hmm
15:17:58 <benzrf> oh. im stupid
15:18:04 <mauke> benzrf: needs more applicative
15:18:14 <benzrf> mauke: hence 'im stupid' :)
15:18:20 <Aruro> nono im not insterested in normal code im interested in currying
15:18:30 <monochrom> it is still not currying.
15:18:36 <Aruro> what?
15:18:37 <mauke> this has nothing to do with currying
15:18:53 <benzrf> @let instance Num b => Num (a -> b) where (+) = liftA2 (+); (*) = liftA2 (*); abs = fmap abs; signum = fmap signum; fromInteger = pure; negate = fmap negate
15:18:54 <lambdabot>  .L.hs:164:23:
15:18:54 <lambdabot>      Could not deduce (b ~ Integer)
15:18:54 <lambdabot>      from the context (Num b)
15:18:54 <lambdabot>        bound by the instance declaration at .L.hs:159:10-32
15:18:54 <lambdabot>        ‚Äòb‚Äô is a rigid type variable bound by
15:18:57 <Iceland_jack> Aruro: What you're talking about is called 'point free'
15:18:59 <benzrf> oh
15:19:01 <Iceland_jack> benzrf: Can you try that in PM?
15:19:02 <Aruro> what has? learn haskell made me believe it is currying :)
15:19:06 <mauke> currying is about representing a function of 2 or more arguments as a series of 1-arg functions
15:19:14 <Aruro> aaa
15:19:15 <Aruro> ok
15:19:18 <benzrf> now we have:
15:19:19 <Aruro> sorry for confusion
15:19:22 <benzrf> :t sin
15:19:23 <lambdabot> Floating a => a -> a
15:19:26 <benzrf> > (1 + sin) 5
15:19:28 <lambdabot>  4.1075725336861546e-2
15:19:29 <benzrf> :)
15:19:31 <Iceland_jack> Aruro: If you want to curry '(a, b) -> c' you get 'a -> b -> c' back as the curried version
15:19:42 <benzrf> > (3 + 4) 5
15:19:43 <lambdabot>  7
15:19:49 <mauke> the type a -> b -> c parses as (a -> (b -> c))
15:19:55 <Iceland_jack> Yes
15:19:57 <Aruro> but curying is not dependent on point free?
15:20:07 <benzrf> Aruro: those are different things
15:20:11 <monochrom> no. you're mixing everything up.
15:20:14 <Aruro> k
15:20:21 <Iceland_jack> Aruro: Point-free style has to do with how the function itself is defined
15:20:25 <Aruro> im glad i mixed up and you solved it :)
15:20:35 <Aruro> hm
15:20:43 <Aruro> am i correct that i can not actually use currying?
15:20:55 <Aruro> like usefull freepoint
15:20:56 <monochrom> you can use currying in another situation
15:21:07 <Aruro> simple example?
15:21:27 <monochrom> when you write "map f xs" you are using currying.
15:21:33 <Aruro> > (1+sin) 6
15:21:34 <Iceland_jack> Aruro:
15:21:35 <Iceland_jack>     curried addition:   plus 1 4    => 5
15:21:35 <Iceland_jack>     uncurried addition: plus (1, 4) => 5
15:21:35 <lambdabot>  0.7205845018010741
15:21:58 <EvanR> function Num instead, check. now we are maximum mix-up ;)
15:22:05 <Iceland_jack> Where 'plus 1 4' is the same as '(plus 1) 4'
15:22:09 <Aruro> love maximum mixup :D
15:22:18 <EvanR> miximum maxup
15:22:28 <Aruro> yes that i remember from book
15:22:36 <Aruro> any usefull trick how to use that?
15:22:44 <Aruro> useful*
15:23:09 <Aruro> so in situation (1+sin) 6  (1+sin) is acutally point free?
15:23:40 <Hijiri> yes
15:23:45 <mauke> yes, but so is 1 + sin 6
15:23:49 <Aruro> hm
15:24:02 <Aruro> but why our code did not accept 1+sin as function?
15:24:12 <Aruro> > let b=1+sin
15:24:13 <lambdabot>  not an expression: ‚Äòlet b=1+sin‚Äô
15:24:16 <Iceland_jack> Aruro: I suggest you ignore '1 + sin'
15:24:19 <Hijiri> there isn't a Num instance for functions in the libraries
15:24:24 <Hijiri> and it would be confusing to use
15:24:58 <Aruro> :t exp
15:24:59 <lambdabot> Floating a => a -> a
15:25:33 <Iceland_jack> Aruro: Example of a partial application (max 5) of a curried function (max):
15:25:33 <Iceland_jack> > map (max 5) [1,4,6,10]
15:25:34 <lambdabot>  [5,5,6,10]
15:25:42 <EvanR> > maximum "mix"
15:25:43 <lambdabot>  'x'
15:26:23 <Iceland_jack> If you couldn't partially apply it we'd have to write:
15:26:23 <Iceland_jack> > map (\x -> max 5 x) [1,4,6,10]
15:26:25 <lambdabot>  [5,5,6,10]
15:26:42 <Aruro> but its not point free?
15:26:43 <Iceland_jack> It's not a drastic change but it's nice and gets nicer the more arguments you have
15:26:48 <Aruro> maximum mix indeed
15:27:06 <Aruro> let b=max 5
15:27:06 <Iceland_jack> (\x -> max 5 x) is not point-free since it mentions its argument (the "point" 'x')
15:27:11 <Iceland_jack> @let b = max 5
15:27:12 <lambdabot>  Defined.
15:27:24 <Aruro> > b2
15:27:25 <lambdabot>  Not in scope: ‚Äòb2‚Äô
15:27:25 <lambdabot>  Perhaps you meant one of these:
15:27:25 <lambdabot>    ‚Äòb‚Äô (line 166), ‚Äòb‚Äô (imported from Debug.SimpleReflect),
15:27:25 <lambdabot>    ‚Äò_2‚Äô (imported from Control.Lens)
15:27:27 <Aruro> > b 2
15:27:29 <lambdabot>  Ambiguous occurrence ‚Äòb‚Äô
15:27:29 <lambdabot>  It could refer to either ‚ÄòL.b‚Äô, defined at L.hs:166:1
15:27:29 <lambdabot>                        or ‚ÄòDebug.SimpleReflect.Vars.b‚Äô,
15:27:31 <lambdabot>                           imported from ‚ÄòDebug.SimpleReflect‚Äô at L.hs:118:1-26
15:27:33 <Iceland_jack> > b 2
15:27:33 <lambdabot>                           (and originally defined in ‚Äòsimple-reflect-0.3.2:De...
15:27:35 <lambdabot>  Ambiguous occurrence ‚Äòb‚Äô
15:27:37 <lambdabot>  It could refer to either ‚ÄòL.b‚Äô, defined at L.hs:166:1
15:27:39 <lambdabot>                        or ‚ÄòDebug.SimpleReflect.Vars.b‚Äô,
15:27:41 <lambdabot>                           imported from ‚ÄòDebug.SimpleReflect‚Äô at L.hs:118:1-26
15:27:43 <lambdabot>                           (and originally defined in ‚Äòsimple-reflect-0.3.2:De...
15:28:24 <Iceland_jack> Aruro: There is something already defined as 'b' :) you'll have to pick a new name and remember to add a space between: 'b 2'
15:28:32 <Iceland_jack> @let mymax = max 5
15:28:33 <lambdabot>  Defined.
15:28:38 <Aruro> yes
15:28:40 <Iceland_jack> > mymax 2
15:28:41 <lambdabot>  5
15:28:44 <Iceland_jack> > mymax 10
15:28:46 <lambdabot>  10
15:28:56 <mauke> for more ugliness you could write this in common lisp as: (MAPCAR #'(LAMBDA (X) (MAX 5 X)) '(1 4 6 10))
15:29:21 <Iceland_jack> You don't have to write it in uppercase ;) but for maximum ugliness you can
15:29:32 <Aruro> > map (max 5) [1,4,6,10]
15:29:34 <lambdabot>  [5,5,6,10]
15:29:37 <Aruro> original of yours
15:29:42 <Aruro> there is no point free here?
15:29:43 <mauke> Iceland_jack: just saving the reader some work
15:29:48 <Iceland_jack> :)
15:29:50 <Aruro> max 5 is point free no?
15:29:57 <EvanR> > let pointFree = filter (\x -> not (elem x [4, 5, 6, 8, 9, 10])) in pointFree [2..12]
15:29:58 <lambdabot>  [2,3,7,11,12]
15:30:08 <Axman6> I see points...
15:30:09 <Iceland_jack> Aruro: yes 'max 5' is point free
15:30:12 <exio4> EvanR, that isn't point-free
15:30:20 <Denommus> isn't there a way to get the first element of a Foldable?
15:30:22 <EvanR> :(
15:30:29 <Aruro> so currying is sister to point free?
15:30:34 <Axman6> :t foldMap
15:30:35 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
15:30:40 <Axman6> :t First
15:30:41 <lambdabot> Maybe a -> First a
15:30:43 <exio4> EvanR, filter (not . flip elem [..]) would be point-free
15:30:50 <Iceland_jack> :t head . F.toList
15:30:51 <lambdabot> Foldable t => t c -> c
15:30:57 <EvanR> oh i thought you were talking about dice
15:30:58 <Axman6> :t First. Just
15:30:59 <lambdabot> a -> First a
15:31:01 <monochrom> "max 5" has one fewer point than "\x -> max 5 x"
15:31:24 <Iceland_jack> Aruro: There are several concepts that are related/similar and often get mixed up: currying, uncurrying, partial application and point free/pointful
15:31:25 <Axman6> > foldMap (First . Just) [1,2,3,4,5]
15:31:27 <lambdabot>  First {getFirst = Just 1}
15:31:34 <Denommus> Iceland_jack: will that be optimized, or will it literally convert that?
15:31:43 <syk0mantis> hello
15:31:50 <Aruro> but where did the currying happend? forgive my mixedupness
15:31:55 <Aruro> in map (max 5) [1,4,6,10]
15:32:09 <syk0mantis> does anyone have experience with haskell audio/gui libraries?
15:32:13 <EvanR> :t curry
15:32:14 <lambdabot> ((a, b) -> c) -> a -> b -> c
15:32:35 <monochrom> currying happens when you don't write, for example, "map (max 5, [1,4,6,10])"
15:32:39 <syk0mantis> im trying to make a simple synth in haskell. I will present the user with a piano gui, and upon a click/keypress, a sound file will play. I've been looking at ALUT for audio,, and have no idea for the GUI.
15:32:49 <EvanR> ((a,b) -> c) -> (a -> (b -> c))
15:32:51 <Hijiri> Denommus: If the Foldable instance for the thing you are folding is lazy, it will not walk the entire container
15:33:24 <Axman6> syk0mantis: have a look at https://www.haskell.org/haskellwiki/Synthesizer
15:33:27 <Iceland_jack> Aruro: Currying can be tricky, technically it's not a property of a function but rather a process that changes a function
15:33:38 <EvanR> skarn: theres a port audio binding, and SDL mixer. but really synthesizing sound in haskell i have not heard of yet
15:33:47 <Hijiri> there is haskore
15:33:50 <Aruro> so currying is related to presenting arguments as one or just sequence?
15:33:58 <geekosaur> mrrr? it's been discussed recently on -cafe
15:34:00 <EvanR> haskore generates sound files?
15:34:01 <Axman6> right, the synthesizer stuff is built on haskore
15:34:07 <dibblego> currying is related to the function with the type ((a, b) -> c) -> a -> b -> c
15:34:17 <Hijiri> I think haskore can generate files
15:34:47 <EvanR> like, driving the real audio callback as in windows DAW
15:34:53 <Aruro> is writing max 3 4 vs max (3,4) reflects the existence of currying?
15:35:03 <EvanR> that seems tricky with the gc
15:35:07 <Iceland_jack> Aruro: Yes basically
15:35:11 <dibblego> you would have to uncurry the max function, so that you could write ma (3,4)
15:35:48 <geekosaur> https://www.haskell.org/pipermail/haskell-cafe/2014-November/117113.html re music synthesis
15:35:52 <Aruro> wait a minute one concept at a time :) i have no idea what uncurrying means
15:36:12 <monochrom> uncurrying is the opposite of currying
15:36:13 <dibblego> uncurrying is related to the function with the type (a -> b -> c) -> ((a, b) -> c)
15:36:17 <Iceland_jack> Aruro:
15:36:17 <Iceland_jack>     maxCurried a b      = max ab
15:36:17 <Iceland_jack>     maxUncurried (a, b) = max a b
15:36:23 <Iceland_jack> *max a b
15:36:32 <EvanR> yeah i figured youd need a separate system or process to do the actual sound, like this CSound backend
15:36:35 <dibblego> @type uncurry max
15:36:36 <lambdabot> Ord c => (c, c) -> c
15:36:46 <Aruro> k
15:37:04 <EvanR> "making music with haskell" is different from real time synthesis though
15:37:05 <Aruro> let me think, is there a neat algorithm that uses currying?
15:37:09 <Iceland_jack> Aruro: so 'maxCurried' is a curried function, 'maxUncurried' is not since it takes all its arguments as a single tuple
15:37:16 <Aruro> yes
15:37:18 <Aruro> clear
15:37:20 <Aruro> now
15:37:30 <Iceland_jack> Aruro: Currying doesn't change the functionality at all, so that question doesn't really make sense
15:37:53 <Aruro> so currying alows me to write stuff like max 5 . sin 7 ?
15:37:59 <Aruro> without getting hit?
15:38:02 <Iceland_jack> Yes, currying and partial application
15:38:18 <Aruro> partial application is not point free?
15:38:28 <Iceland_jack> Aruro: those things aren't really related
15:38:31 <dibblego> Aruro: examine the types of these two functions: curry, uncurry ó observe 1. there is only one function with each of those types 2. those functions are a together, a bijection
15:38:36 <EvanR> function uncurried(x,y){ return foo; }, function curried(x){ return function(y){ return foo; }}
15:39:21 <Aruro> ty guys returning a function example helpt
15:39:26 <Aruro> s*
15:39:46 <Iceland_jack> Aruro: Just to check, is the following function curried?
15:39:47 <Iceland_jack>     plus (x, y) = x + y
15:39:54 <Aruro> no
15:39:55 <Aruro> :)
15:39:59 <Iceland_jack> Right :)
15:40:08 <Iceland_jack> it's easier to partially apply curried functions
15:40:33 <EvanR> and in javascript, its harder to fully apply curried functions ;)
15:40:40 <Aruro> so if i write sin its partical application and if i write let b = sin its point free?
15:40:58 <Iceland_jack> Yes, but in a bit of a boring way :)
15:41:12 <EvanR> just sin isnt applied at all
15:41:20 <Iceland_jack> Normally partial application gives you a function with fewer arguments
15:41:32 <Aruro> yes max 5
15:41:33 <Iceland_jack> but you can think of a 0-partial application
15:41:38 <Iceland_jack> Yes
15:42:13 <EvanR> along with 0-argument functions, 0-partial applications works out quite nicely!
15:42:31 <EvanR> throw in one argument tuples too
15:42:37 <Iceland_jack> ;)
15:43:01 <Aruro> @let b'=(1+).sin
15:43:02 <lambdabot>  Defined.
15:43:08 <Aruro> > b' 1
15:43:09 <lambdabot>  1.8414709848078965
15:43:20 <Aruro> mm i like it
15:43:37 <EvanR> > let (.) = flip ($) in 3.14.sin
15:43:39 <lambdabot>  1.5926529164868282e-3
15:43:44 <EvanR> lol
15:43:56 <Aruro> so function composition alows to propagate free point inside of expression
15:44:19 <pharpend> Aruro: practically, no, EvanR is just abusing Haskell's syntax
15:44:51 <bananagram> :t sin
15:44:52 <lambdabot> Floating a => a -> a
15:44:53 <Aruro> above in definition of b' is it possible to write without . ?
15:45:01 <Aruro> :i b'
15:45:08 <Aruro> > :i b'
15:45:09 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
15:45:19 <pharpend> Aruro: lambdabot doesn't do :i
15:45:32 <pharpend> Aruro: to answer your question
15:45:55 <pharpend> @let c' x = (sin x) + 1
15:45:56 <lambdabot>  Defined.
15:46:03 <EvanR> Aruro: you saw several ways. use a normal function definition, use a lambda, use Num functions (for the + to work on sin directly)
15:46:16 <Aruro> i did see thank you :)
15:46:16 <pharpend> @check (\x -> (c' x) == (b' x))
15:46:18 <lambdabot>  +++ OK, passed 100 tests.
15:46:21 <Aruro> it is productive
15:46:29 <pharpend> Aruro: @check is one of your best friends in Haskell
15:46:36 <Aruro> pharpend i want point free definition
15:46:48 <Aruro> hm is it in ghci?
15:46:49 <pharpend> then (+1) . sin
15:46:59 <Aruro> yes is there way without . ?
15:47:06 <pharpend> Aruro: yes, import Test.Quickcheck, use the quickCheck function
15:47:16 <Iceland_jack> Aruro:
15:47:16 <Iceland_jack>     ghci> let c' x = sin x + 1
15:47:24 <Aruro> no that i know
15:47:28 <pharpend> Aruro: technically yes, but I would probably get banned if I told a beginner
15:47:29 <Aruro> not interested
15:47:36 <Aruro> tell me
15:47:38 <Aruro> :)
15:47:41 <Iceland_jack> Sigh, 'liftM2 (+) sin (const 1)'
15:47:43 <Hijiri> @check (\x /= 10000 :: Int)
15:47:44 <lambdabot>  <unknown>.hs: 1: 5:Parse error: /=
15:47:49 <Hijiri> @check (\x -> /= 10000 :: Int)
15:47:49 <lambdabot>  <unknown>.hs: 1: 8:Parse error: /=
15:47:53 <Aruro> const 1 i think i know
15:47:56 <Aruro> > const 1
15:47:58 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
15:47:58 <lambdabot>    arising from a use of ‚ÄòM859757494068017926230825.show_M8597574940680179262...
15:47:58 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
15:47:58 <lambdabot>  Note: there are several potential instances:
15:47:58 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:48:00 <Aruro> uu
15:48:01 <Hijiri> @check (\x -> (/= (10000 :: Int)))
15:48:03 <lambdabot>  +++ OK, passed 100 tests.
15:48:06 <EvanR> how many ways are there to defined 1 + sin x
15:48:13 <EvanR> the world may never know
15:48:18 <Aruro> nono
15:48:21 <Aruro> not just 1 + sin
15:48:23 <Hijiri> or I could have omitted the lambda
15:48:30 <Aruro> but (1+sin)
15:48:46 <Aruro> curryied point free, mixed up
15:48:53 <EvanR> 1+sin ok, (1+sin) error not a function
15:49:01 <Aruro> 1+sin is not ok
15:49:04 <Aruro> will not work
15:49:06 <Aruro> will it?
15:49:15 <EvanR> if it did i was be annoyed
15:49:19 <EvanR> would be
15:49:25 <Aruro> @let bb'=1+sin
15:49:26 <lambdabot>  Defined.
15:49:30 <Hijiri> it only works if there is a Num instance that could be applied to sin
15:49:30 <Aruro> hm
15:49:32 * EvanR annoyed
15:49:36 <pharpend> Œª: import Test.QuickCheck
15:49:37 <Hijiri> and there is because benzrf defined one
15:49:38 <pharpend> Œª: let b' = (+1) . sin
15:49:40 <Aruro> some other funciton?
15:49:40 <pharpend> Œª: let c' x = sin x + 1
15:49:41 <Iceland_jack> Aruro: Please don't use '1 + sin'
15:49:42 <pharpend> Œª: quickCheck (\x -> (b' x) == (c' x))
15:49:44 <pharpend> +++ OK, passed 100 tests.
15:49:46 <pharpend> there you go
15:49:48 <pharpend> Aruro: see above
15:50:17 <Aruro> yes people gave this solution above it uses function composition
15:50:21 <Iceland_jack> When newcomers come and ask about something this basic we should not define a Num instance for functions
15:50:28 <Aruro> :)
15:50:39 <pharpend> Iceland_jack: correct, we should introduce him to lens
15:50:48 <Aruro> who knows non sin function which takes Num?
15:50:54 <Aruro> i know lens lol :D
15:50:58 <pharpend> :t fmap . fmap . traverse . mapM . fmap traverse
15:50:59 <lambdabot> (Traversable t1, Traversable t, Applicative f2, Functor f1, Functor f) => (a -> a1 -> f2 b) -> f (f1 (t [a])) -> f (f1 (t1 a1 -> t [f2 (t1 b)]))
15:51:12 <Iceland_jack> pharpend: I'd laugh if that weren't true
15:51:15 <Aruro> at least i heard but im not ready to talk about it :)
15:51:22 <pharpend> Aruro: if you knew lens, that type signature would be intuitively clear to you
15:51:34 <Aruro> i heard but not know
15:51:37 <EvanR> lol
15:51:59 <Aruro> so no other function to substitute damn sin?
15:52:02 <Aruro> in 1+sin?
15:52:11 <Aruro> mod?
15:52:15 <Aruro> :t mod
15:52:16 <lambdabot> Integral a => a -> a -> a
15:52:18 <EvanR> when you dont have a function that is so simple, you write it yourself and be done with it
15:52:36 <EvanR> you can easily refactor into magic lambda dust later
15:52:53 <Aruro> > mod 1 2
15:52:55 <lambdabot>  1
15:53:11 <Aruro> @let bbb' = 1+ mod 1
15:53:11 <pharpend> augur: while we are at it, you should learn this about binary operators
15:53:12 <lambdabot>  Defined.
15:53:19 <pharpend> god dammit
15:53:23 <pharpend> Aruro: : while we are at it, you should learn this about binary operators
15:53:30 <Aruro> > bbb' 1
15:53:32 <lambdabot>  No instance for (GHC.Show.Show a0)
15:53:32 <lambdabot>    arising from a use of ‚ÄòM841302213151623714930962.show_M8413022131516237149...
15:53:32 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
15:53:32 <lambdabot>  Note: there are several potential instances:
15:53:32 <lambdabot>    instance [safe] GHC.Show.Show
15:53:41 <Iceland_jack> Aruro: You can PM lambdabot
15:53:54 <Aruro> i should sorry
15:53:58 <augur> pharpend: x3
15:54:14 <pharpend> @check (\x y -> (mod x y) == (x `mod` y))
15:54:15 <lambdabot>  *** Failed! Exception: 'divide by zero' (after 1 test):
15:54:15 <lambdabot>  0 0
15:54:18 <pharpend> oops
15:54:32 <EvanR> it makes a good point
15:54:33 <pharpend> forgot that `mod` is a partial function
15:54:36 <Aruro> wait hoogle can help me i can put Num->Num function
15:54:47 <pharpend> friggin old ghc
15:54:52 <Aruro> or i cant? to find function wich will work
15:55:41 <EvanR> + * - / ^
15:55:45 <EvanR> negate
15:55:54 <EvanR> :t signum
15:55:55 <lambdabot> Num a => a -> a
15:58:55 <Aruro> yes just was pming lambda bot about it
15:59:17 <Aruro> @let c'=1+(*) 2
15:59:18 <lambdabot>  .L.hs:154:1:
15:59:18 <lambdabot>      Multiple declarations of ‚Äòc'‚Äô
15:59:18 <lambdabot>      Declared at: .L.hs:153:1
15:59:18 <lambdabot>                   .L.hs:154:1
15:59:26 <Aruro> @let c''=1+(*) 2
15:59:28 <EvanR> /msg lambdabot can i has NumNum function
15:59:32 <lambdabot>  Defined.
15:59:43 <Aruro> > c'' 2
15:59:45 <lambdabot>  No instance for (GHC.Show.Show a0)
15:59:45 <lambdabot>    arising from a use of ‚ÄòM50972089835667698931131.show_M50972089835667698931...
15:59:45 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
15:59:45 <lambdabot>  Note: there are several potential instances:
15:59:45 <lambdabot>    instance [safe] GHC.Show.Show
15:59:59 <Aruro> does not work somehow im close to giving up on it :)
16:00:21 <Aruro> no functions want to mixup without (.)
16:00:31 <EvanR> @let (*) = (.)
16:00:32 <lambdabot>  .L.hs:153:10:
16:00:32 <lambdabot>      Ambiguous occurrence ‚Äò*‚Äô
16:00:32 <lambdabot>      It could refer to either ‚ÄòL.*‚Äô, defined at .L.hs:155:1
16:00:32 <lambdabot>                            or ‚ÄòPrelude.*‚Äô,
16:00:32 <lambdabot>                               imported from ‚ÄòPrelude‚Äô at .L.hs:40:8
16:00:44 <mauke> @undefine
16:00:44 <lambdabot> Undefined.
16:00:44 <EvanR> you can use any symbol you want
16:01:06 <Aruro> its not about symbol
16:01:21 <EvanR> you can use a different combinator
16:01:25 <Aruro> conceptually point free does not work for more than one function, expression
16:01:39 <Aruro> but combination is nice too
16:01:47 <Aruro> no problem here, just wondering
16:01:58 <EvanR> (1+) `Data.Aviary.Birds.bluebird` sin
16:02:36 <Aruro> so point free has always to have one function on top?
16:02:43 <EvanR> any expression has a top
16:02:44 <Aruro> correct conclusion?
16:02:53 <Aruro> well 1+ sin does not work
16:02:55 <Aruro> we saw that
16:02:58 <Gurkenglas> :t c''
16:02:59 <lambdabot>     Not in scope: ‚Äòc''‚Äô
16:02:59 <lambdabot>     Perhaps you meant ‚Äòf''‚Äô (imported from Debug.SimpleReflect)
16:03:01 <EvanR> its ill-typed
16:03:06 <Gurkenglas> :t 1+(*) 2
16:03:07 <lambdabot> (Num (a -> a), Num a) => a -> a
16:03:08 <Aruro> or 1+(*) even
16:03:22 <Aruro> looks about right no?
16:03:24 <Aruro> with types?
16:03:44 <EvanR> it looks messed up to me but im ignoring instance Num (a -> b)
16:04:36 <Aruro> so point free basically does not allow you to write naively like this  : sin + cos being sin x + cos x
16:04:56 <EvanR> nope
16:04:57 <mauke> sin + cos means (+) sin cos means ((+) sin) cos
16:04:59 <Aruro> thus propagating x everywhere on one level
16:05:03 <EvanR> it lets you write like this
16:05:09 <EvanR> @pl (\x -> 1 + sin x)
16:05:09 <lambdabot> (1 +) . sin
16:05:24 <benzrf> > 1 + sin $ 0
16:05:25 <lambdabot>  No instance for (GHC.Show.Show a0)
16:05:25 <lambdabot>    arising from a use of ‚ÄòM548389705128540456331248.show_M5483897051285404563...
16:05:25 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
16:05:25 <lambdabot>  Note: there are several potential instances:
16:05:25 <lambdabot>    instance [safe] GHC.Show.Show
16:05:34 <benzrf> oh did somebody clear it
16:05:39 <EvanR> yes thank god
16:05:45 <Iceland_jack> benzrf: Can we not use that instance?
16:05:48 <benzrf> ok
16:06:20 <EvanR> next explain printf!
16:06:22 <Gurkenglas> Shouldn't it be (const 1 + sin) at least?
16:06:56 <mauke> 1 can be const 1
16:06:56 <EvanR> 1 gets converted to a function automatically by the Num instance
16:07:09 <benzrf> :t 1
16:07:10 <lambdabot> Num a => a
16:07:23 <benzrf> looks well-typed to me!
16:07:26 <Gurkenglas> I see
16:09:54 <modasode> /join ##javascript
16:20:55 <Zemyla> @pl \m x -> (x - m) ^ 2
16:20:55 <lambdabot> flip flip 2 . ((^) .) . subtract
16:21:17 <Zemyla> @type ((^) .)
16:21:18 <lambdabot> (Num b, Integral b1) => (a -> b) -> a -> b1 -> b
16:24:22 <Aruro> ok
16:25:02 <Aruro> @let crazyd = foldr (+) 0 . take 2 . repeat
16:25:03 <lambdabot>  Defined.
16:25:19 <Aruro> > crazyd 2
16:25:20 <lambdabot>  4
16:25:55 <Aruro> > crazyd 5
16:25:57 <lambdabot>  10
16:25:58 <dmwit> ?quickcheck \x -> crazyd x = 2 * x
16:25:58 <lambdabot> Unknown command, try @list
16:26:05 <dmwit> ?check \x -> crazyd x = 2 * x
16:26:05 <lambdabot>  <unknown>.hs: 1: 16:Parse error: =
16:26:09 <dmwit> ?check \x -> crazyd x == 2 * x
16:26:10 <lambdabot>  +++ OK, passed 100 tests.
16:26:20 <pecanpy> so, lines <$> readFile path, returns the lines of a file. why can't i compose them pointfree as: f = lines <$> readFile
16:26:26 <Aruro> not @check?
16:26:35 <dmwit> Aruro: @check works too
16:27:05 <Aruro> so i have a problem making (:) to be point free
16:27:07 <dmwit> pecanpy: Because "path" is not the last argument to (<$>); "readFile path" is.
16:27:38 <dmwit> pecanpy: It might be more obvious if you write it as "(<$>) lines (readFile path)".
16:27:41 <exio4> @check \x y -> (((^ 2) .) . (-)) x y) == (x-y)^2
16:27:42 <lambdabot>  <unknown>.hs: 1: 30:Parse error: )
16:27:43 <glguy> pecanpy: composed that would be:   (lines <$>) . readFile     or      fmap lines . readFile   -- neither of which is necessarily clearer when made point free
16:27:58 <HeladoDeBrownie> fmap (fmap lines) readFile
16:28:00 <HeladoDeBrownie> :P
16:28:08 <HeladoDeBrownie> </facetious>
16:28:44 <dmwit> Aruro: Can you say a little bit more? "(:)" is already point-free.
16:28:52 <pecanpy> ah. that makes sense. appreciate the help
16:29:26 <Gurkenglas> (fmap . fmap) lines readFile
16:29:48 <dmwit> fmap fmap fmap lines readFile
16:29:53 <dmwit> yes, this is going well
16:30:07 <pecanpy> it's fmaps all the way down
16:30:07 <dmwit> at this rate a 2-year-old will be able to read it -37 years in the future
16:30:30 <Aruro> exio
16:30:33 <Aruro> interesting
16:31:01 <exio4> Aruro, uh?
16:31:26 <Aruro> @let exio5= (((^ 2) .) . (-))
16:31:28 <lambdabot>  Defined.
16:31:35 <Aruro> > exio5 1 1
16:31:36 <lambdabot>  0
16:31:48 <Aruro> mmm lol
16:31:48 <exio4> @check \x y ->  ((((^ 2) .) . (-)) x y) == ( (x-y) ^ 2 ))
16:31:49 <lambdabot>  <unknown>.hs: 1: 50:Parse error: )
16:31:58 <exio4> damn :P
16:31:58 <Aruro> @let exio5= (((^ 2) .) . (+))
16:31:59 <lambdabot>  .L.hs:154:1:
16:31:59 <lambdabot>      Multiple declarations of ‚Äòexio5‚Äô
16:31:59 <lambdabot>      Declared at: .L.hs:153:1
16:31:59 <lambdabot>                   .L.hs:154:1
16:32:04 <Aruro> @let exio6= (((^ 2) .) . (+))
16:32:06 <lambdabot>  Defined.
16:32:13 <Aruro> > exio6 5 5
16:32:15 <lambdabot>  100
16:32:16 <exio4> Aruro, it is (x-y)^2
16:32:17 <Gurkenglas> You got that term from @pl in a pm, admit it.
16:32:24 <Aruro> i made it +
16:32:38 <dmwit> ?check \x y -> (((^ 2) .) . (-)) x y == (x-y)^2
16:32:39 <lambdabot>  +++ OK, passed 100 tests.
16:32:49 <exio4> Gurkenglas, I didn't, I saw the point-free version of it a bit ago and it didn't look nice
16:33:36 <dmwit> Gurkenglas: ((f .) .) is a common form for point-free fans. I could easily have produced the point-free form without ?pl, and I suspect many others could, too.
16:34:42 <Gurkenglas> dmwit, what I was trying to tease at was that these newbies didn't have the required status to produce such sophisticated constructs
16:36:03 <exio4> Gurkenglas, I am a newbie though :P
16:36:10 <Hijiri> what is fromInteger for UTCTime? seconds?
16:36:33 <dmwit> Gurkenglas: oh =)
16:36:40 <Aruro> i like where this is going
16:36:51 <Aruro> can you make point free 2*x ?
16:36:54 <Aruro> using plus?
16:37:12 <StoneCypher> Hijiri: either that or milliseconds.  easy enough to test: google unix time, and then divide that thing's result by the google result.  if it's around 1 it's seconds.  if it's around 1000 it's milliseconds.
16:37:15 <Gurkenglas> > sum . replicate 2
16:37:16 <lambdabot>  <Integer -> Integer>
16:37:17 <exio4> join (+)
16:37:18 <StoneCypher> or there's docs
16:37:22 <Gurkenglas> > sum . replicate 2 $ 20
16:37:23 <lambdabot>  40
16:37:28 <exio4> > join (+) 2
16:37:30 <lambdabot>  4
16:37:33 <exio4> > join (+) 20
16:37:34 <dmwit> Hijiri: There is no fromInteger for UTCTime.
16:37:35 <lambdabot>  40
16:37:59 <mmmm> Is there a way I can invoke the cpp preprocessor to remove all CPP fragments from my project?
16:38:15 <mgsloan> Hijiri: However, for the Diff time types, fromInteger is in seconds
16:38:16 <dmwit> {-# LANGUAGE CPP #-}, I guess
16:38:24 <Gurkenglas> @src sum
16:38:25 <lambdabot> sum = foldl (+) 0
16:38:28 <Gurkenglas> if you really want the (+)
16:39:13 <Aruro> my question is following
16:39:36 <mmmm> I mean, process the files and spit out the source without any #if
16:39:43 <Aruro> can you apply (+) to two aruguments getting only one argument in, function has to be one argument
16:39:45 <Hijiri> oh, for some reason I thought UTCTime was Num
16:39:51 <Aruro> not using foldr
16:40:00 <Hijiri> DiffTime is what I was looking for, thanks
16:40:07 <Gurkenglas> Arura, give us the type signature you want.
16:40:09 <dmwit> Aruro: see exio4's answer above, "join (+)"
16:40:10 <Iceland_jack> Aruro: Do you want: \x -> x + x?
16:40:14 <Iceland_jack> That would be join (+)
16:40:28 <Gurkenglas> *o
16:41:50 <dmwit> mmmm: I'm not sure. You can of course invoke cpp yourself; whether you can ask GHC what arguments *it* would use (or what output *it* would get) is another question.
16:42:05 <dmwit> mmmm: There's probably a -v level that does the former or a -ddump-* flag that does the latter.
16:43:06 <Aruro> yes i wanted \x->x+x
16:43:15 <Aruro> but join is not in prelude
16:43:21 <Aruro> you need control monad for it
16:43:25 <Iceland_jack> Yes
16:43:31 <Aruro> and who is monad here i did not get :)
16:43:49 <Aruro> > join (+) 1
16:43:50 <lambdabot>  2
16:43:55 <Aruro> > join (+) 1 2
16:43:56 <geekosaur> (e ->)
16:43:57 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
16:43:57 <lambdabot>    arising from the ambiguity check for ‚Äòe_112‚Äô
16:43:57 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
16:43:57 <lambdabot>    bound by the inferred type for ‚Äòe_112‚Äô:
16:43:57 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
16:44:10 <Gurkenglas> :t join
16:44:10 <lambdabot> Monad m => m (m a) -> m a
16:44:20 <Iceland_jack> 'join' has the following type:
16:44:20 <Iceland_jack> :t join :: (a -> a -> b) -> (a -> b)
16:44:20 <dmwit> mmmm: -ddump-parsed is kind of it
16:44:21 <lambdabot> (a -> a -> b) -> a -> b
16:44:43 <Hijiri> looks like we need the Num instance again
16:44:48 <Iceland_jack> You don't want to use this though, just write '\x -> x + x'
16:44:52 <dmwit> No, this is different from the Num instance.
16:45:05 <dmwit> It is, after all, a Monad instance. =)
16:45:06 <Gurkenglas> (((->) r) is an instance of Monad)
16:45:29 <Aruro> > join (*) 2
16:45:30 <Hijiri> I mean for join (+) 1 2
16:45:31 <lambdabot>  4
16:45:47 <dmwit> ah
16:45:50 <Aruro> i do not get how does it work
16:46:00 <Gurkenglas> @src join
16:46:00 <lambdabot> join x = x >>= id
16:46:00 <Aruro> is (+) a monad?
16:46:17 <Iceland_jack> Aruro: It works for any function 'a -> a -> b'
16:46:19 <Hijiri> (e ->) is the monad, so have m = (e ->)
16:46:21 <Iceland_jack>     join f x = f x x
16:46:27 <Hijiri> (+) :: Num a => a -> a -> a
16:46:32 <Hijiri> so set e = to a
16:46:36 <Hijiri> and then you have m a
16:46:43 <Hijiri> (a -> a)
16:46:46 <Hijiri> (a ->) a
16:47:04 <Hijiri> (type sections are not real syntax as far as I know)
16:47:17 <Aruro> hm interesting
16:47:31 <HeladoDeBrownie> Is there some way to make a cabal sandbox portable, in that you could move it to another directory and it'd still be useable?
16:47:58 <kadoban> HeladoDeBrownie: I think it already is...
16:48:01 <HeladoDeBrownie> I ask because this has come up when I've either reorganized my files or tried developing from another system
16:48:22 <Iceland_jack> HeladoDeBrownie: Something like 'add-source'? http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
16:48:41 <Iceland_jack> Or you can check out the '--sandbox' flag
16:48:53 <HeladoDeBrownie> That doesn't seem to be what I'm talking about
16:49:07 <HeladoDeBrownie> Let me come up with an example
16:50:00 <HeladoDeBrownie> mkdir foo ; cd foo ; cabal sandbox init ; cd .. ; mv foo bar ; cd bar ; cabal repl
16:50:09 <HeladoDeBrownie> That will show the problem
16:51:07 <Iceland_jack> HeladoDeBrownie: You can't move sandboxes directly but you can share a single sandbox using --sandbox
16:51:35 <hexagoxel_> HeladoDeBrownie: see https://github.com/haskell/cabal/issues/1490
16:52:19 <Aruro> > join (join (\x y z f->x+y+z+f) 2) 2
16:52:20 <lambdabot>  8
16:52:48 <HeladoDeBrownie> hexagoxel_, yeah, that's it. Any idea if anyone has attempted to fix that yet?
16:53:35 <HeladoDeBrownie> I guess not, judging from that thread
16:54:25 <Aruro> very useful, but how do i write \x->x:[] point free?
16:54:35 <Iceland_jack> (:[])
16:54:35 <Iceland_jack> Monkey operator
16:54:36 <exio4> (:[])
16:54:49 <Aruro> lol
16:54:54 <HeladoDeBrownie> Also, return, if there's no risk of ambiguity
16:55:00 <HeladoDeBrownie> Equally, pure
16:56:02 <Iceland_jack> Yes it would be nice to have Data.List.singleton :: a -> [a]
16:56:16 <Aruro> > join (:[]) 2
16:56:17 <lambdabot>  Couldn't match type ‚Äòa0 -> a‚Äô with ‚Äò[a0]‚Äô
16:56:17 <lambdabot>  Expected type: a0 -> a0 -> a
16:56:17 <lambdabot>    Actual type: a0 -> [a0]
16:56:25 <Aruro> ups
16:56:35 <Aruro> not enough something
16:56:43 <Iceland_jack> Aruro: join doesn't make sense for (: [])
16:56:44 <HeladoDeBrownie> Needs to have two layers of function to join it
16:57:52 <Aruro> > ((:[]).(:[]) 2) 2
16:57:54 <lambdabot>  Couldn't match expected type ‚Äòa0 -> b‚Äô with actual type ‚Äò[a1]‚Äô
16:58:20 <HeladoDeBrownie> ((:[]).(:[]) 2) is a list, you can't apply it
16:58:27 <HeladoDeBrownie> > (:[]).(:[]) 2
16:58:28 <lambdabot>  Couldn't match expected type ‚Äòa -> b‚Äô with actual type ‚Äò[a0]‚Äô
16:58:31 <HeladoDeBrownie> Woops
16:58:34 <HeladoDeBrownie> Never mind :P
16:58:37 <Aruro> mm
16:58:38 <HeladoDeBrownie> I was misparsing the parens
16:58:47 <HeladoDeBrownie> Similar problem though
16:58:48 <Aruro> i want to apply monkey twice
16:58:55 <exio4> that is [[x]]
16:59:03 <HeladoDeBrownie> > ((:[]).(:[]))2
16:59:05 <lambdabot>  [[2]]
16:59:21 <Aruro> true
16:59:32 <Iceland_jack> > (\x -> [[x]]) 2
16:59:33 <lambdabot>  [[2]]
16:59:45 <HeladoDeBrownie> By this point you're probably better off writing it pointfully though
16:59:53 <Aruro> i want point free 2 -> [2,2]
17:00:09 <exio4> replicate?
17:00:12 <Iceland_jack> Aruro: join replicate, or \x -> replicate x x
17:00:12 <Iceland_jack> > join replicate 2
17:00:14 <lambdabot>  [2,2]
17:00:14 <HeladoDeBrownie> @pl \x -> [x, x]
17:00:15 <lambdabot> ap (:) return
17:00:22 <Aruro> monkey operator did not save me :(
17:00:33 <HeladoDeBrownie> :t (:) <*> pure
17:00:34 <lambdabot> a -> [a]
17:00:43 <HeladoDeBrownie> > (:) <*> pure $ 2
17:00:44 <lambdabot>  [2,2]
17:00:50 <Aruro> wooa
17:01:01 <Aruro> i did not intend to dig deeper
17:01:04 <HeladoDeBrownie> ap = (<*>) ; return = pure -- for functions
17:01:06 <Aruro> just have a simle wishes
17:01:10 <Aruro> simple*
17:01:17 <exio4> HeladoDeBrownie, for functors*?
17:01:40 <Aruro> no way to make point free (:) to give me  [2,2] ?
17:01:40 <HeladoDeBrownie> exio4, what I wrote was correct, if hedged
17:01:46 <exio4> oh, nevermind
17:01:57 <exio4> no idea why I thought of functors
17:02:18 <Iceland_jack> Aruro: That's been answered
17:02:39 <Cale> Aruro: [2,2] is 2 : (2 : [])
17:02:55 <Aruro> so how do i get it point free?
17:02:59 <HeladoDeBrownie> (In general ap should equal (<*>) and return should equal pure, but for improper (unlawful) instances this might not be true)
17:03:20 <pharpend> HeladoDeBrownie: see the spec for base-4.8, it's now a rule
17:03:23 <Cale> So you need a point free way to duplicate an argument. The typical answer is to use the Monad or Applicative instance for (->) e
17:03:31 <Aruro> yes
17:03:33 <Aruro> exactly
17:04:00 <Aruro> i mean guys already point out join
17:04:00 <Cale> and that's what the solutions above did
17:04:05 <Aruro> pointed*
17:04:09 <dibblego> \x -> f x x -- can be written: join f
17:05:19 <Gurkenglas> Do you want 3 to map to [3,3] or to [3,3,3]?
17:05:30 <Aruro> man without fold and repeat its hard
17:05:46 <HeladoDeBrownie> > map (join replicate) [1, 2, 3, 4, 5]
17:05:47 <Aruro> both im interested in
17:05:47 <lambdabot>  [[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5]]
17:06:26 <Gurkenglas> join replicate is one, replicate 2 is the other
17:06:43 <Gurkenglas> Oh right you wanted something with (:)
17:06:54 <Aruro> yes
17:06:54 <Gurkenglas> Lets see what lambdabot says
17:06:58 <Aruro> that
17:07:04 <Gurkenglas> @pl \x -> [x,x]
17:07:04 <lambdabot> ap (:) return
17:07:15 <Aruro> helado you got 3 times 3 but how to get x x x ?
17:07:25 <HeladoDeBrownie> Aruro, what?
17:07:27 <Gurkenglas> @pl \x -> [x,x,x]
17:07:29 <Aruro> triple argument
17:07:32 <lambdabot> ap (:) (ap (:) return)
17:07:58 <Gurkenglas> :t ap
17:07:59 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:08:01 <Aruro> what is pl command? :) kinda cheatsheet?
17:08:07 <HeladoDeBrownie> pl = pointless
17:08:13 <Aruro> uu
17:08:21 <HeladoDeBrownie> It takes away the point of an expression
17:08:22 <HeladoDeBrownie> :P
17:08:25 <Aruro> so people specially devoted command to it :)
17:08:27 <Aruro> cool
17:08:59 <Gurkenglas> There's an algorithm that makes any term into its pointless version, thus making the profession of producing pointless code pointless
17:09:10 <dibblego> @type join . join
17:09:11 <lambdabot> Monad m => m (m (m a)) -> m a
17:09:17 <dibblego> "three" arguments
17:09:49 <dibblego> > (join . join) (\a b c -> a + b + c) 8
17:09:51 <lambdabot>  24
17:09:51 <Gurkenglas> (Except that there's sometimes multiple ways and they're differently readable or say different kinds of things about your code)
17:10:16 <Cale> @pl \a b c d r -> a b r a c a d a b r a
17:10:19 <lambdabot> join (flip . ((flip . ((flip . (flip .)) .)) .) . flip flip id . ((flip . ((flip . (ap .)) .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . join (flip . ((flip . ((flip . (flip .) . flip) .)) .) . join (flip . ((flip . (flip .) . flip) .) . join (flip . (flip .)))))
17:10:19 <lambdabot> optimization suspended, use @pl-resume to continue.
17:10:26 <Iceland_jack> @pl-resume
17:10:28 <lambdabot> flip =<< ((flip . ((flip . (flip .)) .)) .) . flip flip id . ((flip . ((flip . (ap .)) .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . (flip =<< ((flip . ((flip . (flip .) . flip) .)) .) . (flip =<< ((flip . (flip .) . flip) .) . (flip =<< (flip .))))
17:10:36 <Aruro> ohhh
17:10:45 <HeladoDeBrownie> If I saw that in someone's actual code, *I'd* flip
17:10:45 <Aruro> good end to our sufferings with point free :)
17:10:57 <Aruro> there is flip in code :D
17:11:30 <HeladoDeBrownie> Nah, I have no problem with flip, it's not the prettiest in many circumstances but I use it occasionally
17:11:45 <exio4> "mixed" point-free looks kinda neat though, something like (\f ‚Üí map f . repeat) or so
17:12:14 <Aruro> yes
17:13:08 * hexagoxel_ would like a tool that transforms to a sensible level of point-free-ness
17:13:12 <Aruro> @pl \x -> [x,x]
17:13:12 <lambdabot> ap (:) return
17:13:51 <hexagoxel_> (for some completely objective definition of "sensible" :D)
17:14:10 <Gurkenglas> hexagoxel_, minimum code length?
17:14:23 <HeladoDeBrownie> Surely you mean maximum
17:14:28 <Aruro> @let exio7= (((^ 2) .) . (+))
17:14:30 <lambdabot>  Defined.
17:14:42 <Aruro> this looks llike  Polish notation no?
17:15:00 <hexagoxel_> shortest can be quite unintuitive
17:15:18 <HeladoDeBrownie> Oh, I misunderstood
17:15:34 <tempay> are lenses worth learning? do you guys use them often in your projects? if so, at what point should a person learn them (beginner, intermediate, etc)
17:15:41 <Gurkenglas> No worries, your comment is sufficiently amusing
17:15:42 <HeladoDeBrownie> Optimize for shortness
17:15:45 <dibblego> Yes. Yes. Now.
17:15:52 <dibblego> Yes. Yes. Now. -- tempay
17:16:23 <tempay> okie doke, that is decisive
17:18:39 <Aruro> im amused @pl knows everything
17:18:48 <Gurkenglas> hexagoxel_, name a longer piece of code that is preferable to a pointfuller one
17:18:48 <Aruro> @pl \x-> 1+ sin x
17:18:49 <lambdabot> (1 +) . sin
17:19:06 <hexagoxel_> e.g. `join f` is shorter, but `\x -> f x x` is easier to grasp
17:19:16 <Gurkenglas> That's the wrong way around
17:19:20 <Aruro> @pl \x-> 1+ sin x+x*x
17:19:20 <lambdabot> ap ((+) . (1 +) . sin) (join (*))
17:19:29 <Iceland_jack> Gurkenglas: reverse >>= (==)
17:19:57 * hackagebot presburger 1.2 - A decision procedure for quantifier-free linear arithmetic.  http://hackage.haskell.org/package/presburger-1.2 (IavorDiatchki)
17:20:13 <Aruro> @pl \x y->x
17:20:13 <lambdabot> const
17:20:48 <Aruro> @pl \x->[x,x]
17:20:49 <lambdabot> ap (:) return
17:21:07 <Aruro> @pl \x->[x,x,x]
17:21:07 <lambdabot> ap (:) (ap (:) return)
17:21:38 <Aruro> @pl \x y z->x
17:21:38 <lambdabot> const . const
17:22:11 <Aruro> mm but const has 2 arguments?
17:22:31 <dibblego> All Haskell Functions Accept One Argument, Always.
17:22:38 <Welkin> :t const . const
17:22:39 <lambdabot> a -> b -> b1 -> a
17:22:41 <Gurkenglas> Any functions that takes two arguments can be seen as a function that takes an argument and returns a function that returns an argument
17:22:52 <Gurkenglas> *Any function
17:22:55 <Gurkenglas> *takes
17:23:04 <Gurkenglas> damn it scratch that phrase i gotta sleep
17:23:05 <Aruro> ok currying right?
17:23:14 <Gurkenglas> It's called partial application.
17:23:23 <exio4> (\x y -> ...) is the same as (\x ‚Üí \y -> ...)
17:23:36 <Aruro> useful
17:23:40 <Gurkenglas> Although I like to think of the "full application" case of being the unusual one.
17:23:46 <Welkin> this is why the type signatures are written :: a -> b -> b
17:24:01 <mgsloan> currying is going from "(a, b, c) -> d" to "a -> b -> c -> d"
17:24:07 <Welkin> rather than separating out the "arguments" from the "result"
17:24:17 <Gurkenglas> a -> b -> b desugars to a -> (b -> b)
17:27:23 <Aruro> is there a tutorial on how @pl is written?
17:27:31 <Gurkenglas> (const . const) takes an argument and puts it through the right const, yielding the thunk (const a), and puts that through the left const, yielding the thunk (const (const a)). The second argument to be applied annihilates the left const and returns (const a). The third argument is disregarded by the remaining const and a remains as the returned value.
17:28:29 <Aruro> nice
17:28:33 <Aruro> ty
17:29:06 <Gurkenglas> @unpl (join . join) (\a b c -> a + b + c)
17:29:06 <lambdabot> (\ f -> (\ e -> (\ a b c -> (a + b) + c) e e) f f)
17:29:41 <Gurkenglas> Huh that doesn't sound descrambled.
17:30:05 <Aruro> nope
17:30:12 <exio4> Aruro, @pl uses https://hackage.haskell.org/package/pointfree
17:30:24 <Aruro> ty
17:31:51 <Gurkenglas> Oh, completely forgot about this one. Aruro, prepare to be amazed.
17:31:53 <shachaf> @pl is an optimizing compiler. Just doing what @pl does is very easy and you can find instructions for most of it at e.g. https://en.wikipedia.org/wiki/Combinatory_logic
17:31:58 <Gurkenglas> @djinn Bool -> a -> b -> Either a b
17:31:58 <lambdabot> f a b c =
17:31:58 <lambdabot>     case a of
17:31:58 <lambdabot>     False -> Left b
17:31:58 <lambdabot>     True -> Right c
17:31:59 <shachaf> The optimizations are the tricky part.
17:32:27 <Aruro> mmmmm that is nice :)
17:32:39 <Gurkenglas> Takes a type signature and returns a function. Doesn't work on recursive types or we'd all be out of a job.
17:32:55 <Aruro> still :)
17:33:01 <Aruro> impressive
17:33:06 <Welkin> @djinn [a] -> [[a],[a]]
17:33:06 <lambdabot> Cannot parse command
17:33:16 <Welkin> @djinn [a] -> ([a],[a])
17:33:16 <lambdabot> Error: Undefined type []
17:33:17 <Gurkenglas> Lists are a recursive type.
17:33:21 <Welkin> haha
17:33:21 <exio4> @djinn a -> (a,a)
17:33:22 <lambdabot> f a = (a, a)
17:33:29 <shachaf> Lists are also a very boring type from Djinn's perspective.
17:33:33 <Welkin> @djinn a -> b -> c
17:33:34 <lambdabot> -- f cannot be realized.
17:33:40 <Welkin> @djinn a -> a -> b
17:33:40 <lambdabot> -- f cannot be realized.
17:33:48 <shachaf> Please expriment with lambdabot in /msg unless you're demonstrating something to the channel.
17:33:50 <Welkin> @djinn a -> a -> Maybe a
17:33:50 <lambdabot> f _ a = Just a
17:33:59 <Aruro> ok today was good day :) @pl and @djin discovered :)
17:34:15 <Gurkenglas> Buuuut I wanna see them play with it
17:34:23 <Aruro> yes :) we do
17:34:47 <Aruro> @djinn Bool -> Int
17:34:47 <lambdabot> Error: Undefined type Int
17:34:57 <Aruro> @djinn Bool -> [a]
17:34:57 <lambdabot> Error: Undefined type []
17:35:06 <Aruro> @djinn Bool -> a
17:35:06 <lambdabot> -- f cannot be realized.
17:35:08 <shachaf> lambdabot conversation drowns out every other conversation.
17:35:21 <shachaf> If you really want to do a lot of it, try #haskell-overflow or something.
17:35:22 <Aruro> true
17:35:59 <hiptobecubic> you can always /query lambdabot directly
17:36:27 <Aruro> Gurkenglas your first example is still most impressive in complexity
17:36:34 <hiptobecubic> No telling how many private conversations she's having behind your back though.
17:36:51 <Gurkenglas> Aruro, your type signatures don't have a canonical example
17:37:03 <Gurkenglas> Sure there is!
17:37:04 <Gurkenglas> @activity
17:37:04 <lambdabot> 0*total
17:37:08 <Gurkenglas> @activity 100
17:37:08 <lambdabot> 1*total 1*#haskell
17:37:20 <Gurkenglas> @info activity
17:37:20 <lambdabot> activity
17:37:25 <Gurkenglas> @help activity
17:37:25 <lambdabot> activity seconds. Find out where/how much the bot is being used
17:38:22 <Gurkenglas> :t (.)
17:38:23 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:38:27 <Gurkenglas> @djinn (b -> c) -> (a -> b) -> a -> c
17:38:27 <lambdabot> f a b c = a (b c)
17:38:30 <exio4> is there anything that lambdabot doesn't know how to do?
17:38:42 <shachaf> Please take it to /msg or #haskell-overflow.
17:38:50 <Gurkenglas> I was demonstrating :I
17:38:54 <Aruro> @djinn Bool->Maybe a
17:38:55 <lambdabot> f _ = Nothing
17:39:01 <systemfault> exio4: Cooking :(
17:39:02 <Aruro> nice :D
17:39:08 <dibblego> Please can we not use #haskell for demonstrating lambdabot?
17:39:28 <pavonia> @tell dibblego Okay
17:39:28 <lambdabot> Consider it noted.
17:39:49 <dibblego> thank you
17:39:51 <Aruro> he also tell jokes on info command
17:39:55 <Aruro> or similar
17:39:58 <Aruro> or she
17:41:45 <Denommus> exio4: desugar ArrowSyntax
17:42:50 <Aruro> @djinn Bool->Maybe a->Bool
17:42:50 <lambdabot> f a b =
17:42:50 <lambdabot>     case a of
17:42:50 <lambdabot>     False -> False
17:42:50 <lambdabot>     True -> case b of
17:42:50 <lambdabot>             Nothing -> False
17:42:52 <lambdabot>             Just _ -> True
17:43:07 <Aruro> she assumed False always leads to false
17:43:11 <Aruro> assumes
17:47:25 <pavonia> Is there a library for really easy filtering of HTML/XML code? I'm looking for something like a regex but more high-level, e.g. find the first table that follows a certain h3 tag with a certain substring and list all table cells of the 3rd row
17:48:05 <pavonia> In the past I used tagsoup but the code gets really verbose the more complex the requests become
17:48:08 <hpc> sounds like you almost want a CSS engine
17:48:22 <hpc> except, with more selectors
17:48:43 <jabesed> I'm getting more and more confused about this... is   g . (\x -> x >>= f)  equivalent to   (\x -> x >>= (g.f))  ?
17:49:06 <jabesed> I thought it was, but trying to prove it, it doesn't seem the case
17:49:09 <pavonia> hpc: Hhm, I don't know much about CSS selectors
17:49:30 <jabesed> I can prove it for  map g, rather than g
17:49:39 <shachaf> jabesed: They don't even have the same type.
17:50:01 <jabesed> shachaf: hmm let me check, I was using standard category theory notation and just translated it, possibly badly
17:50:09 <Iceland_jack> :t ?g . (\x -> x >>= ?f)
17:50:10 <lambdabot> (?g::m b -> c, ?f::a -> m b, Monad m) => m a -> c
17:50:12 <Iceland_jack> :t (\x -> x >>= (?g . ?f))
17:50:13 <lambdabot> (?g::b1 -> m b, ?f::a -> b1, Monad m) => m a -> m b
17:51:08 <jabesed> in category theory notation what I want is     (g . f)* = g . f*
17:51:13 <hpc> pavonia: for instance, an element inside a hovered <a> tag and before a div with an attribute foo that contains bar
17:51:17 <jabesed> with f : A -> TB   and g : TB -> TC
17:51:45 <jabesed> and f*: TA -> TB
17:51:55 <hpc> a:hover div ~ *[foo*="bar"]
17:52:04 <hpc> http://www.w3.org/TR/css3-selectors/#selectors
17:52:21 <hpc> it's a painful syntax to learn completely, but the good parts are intuitive and powerful
17:53:03 <hpc> er, make that after a div
17:53:07 <hpc> before a div isn't possible
17:54:18 <pavonia> Is there a Haskell library that provides that?
17:54:24 <hpc> don't think so
17:55:24 <shachaf> jabesed: Ah, with that restriction on g's type.
17:55:30 <hpc> you might just need to parse it in and do it yourself, unfortunately
17:55:52 <hpc> but a CSS lib is the most likely thing to exist that would help you
17:56:30 <hpc> depending on what kind of matches you need to make, ofc
17:57:46 <jabesed> shachaf: yeap
17:57:56 <jabesed> sorry should have said that
17:57:58 <shachaf> jabesed: It's not true in general.
17:58:26 <jabesed> shachaf: right... so only for map g, right?  or in other words Tg
17:58:54 <jabesed> i.e.   (T g. f)* = T g . f*
17:59:48 <pavonia> hpc: Okay, thanks so far. I'll look a bit around on hackage
18:00:19 <jabesed> but  n . f* = (n . f)* = T f     right?
18:00:26 <jabesed> or written in haskell
18:00:52 <jabesed> return (\x -> x >> f) = map f
18:01:22 <jabesed> (\x -> x>>= return . f) = map f
18:01:24 <jabesed> right?
18:02:31 <jabesed> the latter
18:03:22 <shachaf> jabesed: You're saying several things here.
18:05:00 * shachaf is confused as to what the question is now.
18:05:15 <jabesed> shachaf: (n . f)* = T f    or in haskell (\x -> x>>= return . f) = map f
18:05:18 <shachaf> It's true that (x >>= return . f) = fmap f x
18:05:30 <shachaf> Yes.
18:05:32 <jabesed> ok
18:05:51 <shachaf> But you're asking whether fmap g . join . fmap f = join . fmap (fmap g . f) ?
18:06:30 <jabesed> shachaf: maybe I should just state where I was trying to get at
18:07:19 <jabesed> schell: I have a monad  defined in the standard (m, join, return)   fashion
18:07:31 <jabesed> instead of return and >>=
18:07:39 <jabesed> and now I defined >>=
18:07:48 <schell> jabesed: i think you meant to comment to shachaf ;)
18:07:57 <jabesed> ops sorry schell!
18:08:14 <xenocons> whats the order of eval for functions inlined with ``, e.g. `mod`, 21 * (-12) `mod` 26 => 8
18:08:22 <schell> all good - i name collide with shachaf a couple times a year
18:08:31 <shachaf> xenocons: You can define it, just like any other operators.
18:08:46 <shachaf> The default is infixl 9, just like any other operator.
18:08:48 <jabesed> shachaf: and of course the standard way obtain >>= would have been to use  join and map
18:09:05 <xenocons> so (21 * (-12)) % 26
18:09:21 <jabesed> shachaf: but I was wondering if I could take a shortcut, since I already guessed >>=
18:10:08 <jabesed> shachaf: and instead of doing  x>>=f = join (map f x)  , prove that >>= satisfies certain properties, and therefore must be the right one
18:10:10 <xenocons> cool
18:10:43 <shachaf> xenocons: * and `mod` are both defined to be infixl 7
18:10:59 <shachaf> You can find this out with :i in ghci, like I just did.
18:11:50 <jabesed> shachaf: so I was guessing maybe it would suffice to should that my >>=  satisfies   (join = \x >>= id  )   and (x>>= return . f) = fmap f x
18:11:51 <xenocons> ah excellent, that is perfect
18:12:06 <Iceland_jack> shachaf: ‚ÄúThese fixities can be yours for just $5.99..‚Äù :-)
18:12:08 <shachaf> jabesed: Well, (>>=) isn't unique for a particular monad, of course.
18:12:34 <shachaf> jabesed: Ah, but if your properties involve return and join then it could work.
18:12:41 <jabesed> shachaf: isn't  >>=  join (map f x)
18:13:00 <jabesed> shachaf: that didn't come out right  isn't  (>>=) =  join (map f x)
18:13:38 <jabesed> well x >>= f , you get the idea.... isn't it just that? I was pretty sure it was unique
18:14:00 <shachaf> Yes, it's unique for a particular join.
18:14:04 <jabesed> note that I actually have a monad defined, not just a functor... I have join and return
18:14:05 <jabesed> yes
18:14:24 <dfranke> It's *so* nice that GeneralizedNewtypeDeriving has been purged of evil in GHC 7.8. Saves so much boilerplate.
18:14:47 <jabesed> so I know that once >>= is defined those two properties hold... question is, is >>= the unique function satisfying those two properties?
18:14:55 <shachaf> dfranke: whoa, that happened?
18:14:57 <jabesed> I had the gut feeling that maaaaybe it is
18:14:59 <shachaf> I thought that was planned for later.
18:15:06 <ReinH> dfranke: Oh really? Huh.
18:15:16 <ReinH> I just used it anyway and tried to avoid the bad cases...
18:15:43 <ReinH> jabesed: join and fmap uniquely define (>>=), yes
18:15:59 <shachaf> ReinH: That is not the question.
18:16:05 <ReinH> shachaf: Woops.
18:16:14 <dfranke> ReinH: yup! See http://ezyang.tumblr.com/post/61969276833/hiw-generalizednewtypederiving-is-now-type-safe and https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/roles.html
18:16:25 <ReinH> dfranke: \o/
18:16:41 <shachaf> But it still uses an evil implementation.
18:16:54 <shachaf> Rather than just generate code the way some old Haskell compiler used to do it.
18:17:22 <jabesed> so now I was trying to show that if an operator  >>>=   satisfies    (join = \x >>>= id  )   and (x>>>= return . f) = fmap f x        then   x >>>= f =  join (map f x) or in other words, it must be >>=
18:17:24 <johnw> odd that there's no date on that first post
18:18:00 <jabesed> but of course this may not be true, maybe I'm missing some fundamental properties
18:18:11 <jabesed> I certainly am having trouble proving it
18:18:11 <shachaf> In an alternate universe: GeneralizedNewtypeDeriving is reasonable and GADTs/TypeFamilies are the evil extensions.
18:18:24 <jabesed> at some point I thought I was getting there, but nope :/
18:18:28 <shachaf> GADTs/TypeFamilies are incompatible with all sorts of things.
18:19:41 <Iceland_jack> Well newtypes give rise to a whole new notion of equality
18:20:20 <shachaf> So you have a Monad M, and function foo :: (a -> M b) -> M a -> M b such that foo (return . f) = fmap f and foo id = join, and you want to know whether foo = (=<<)
18:20:51 <shachaf> johnw: There is a date.
18:21:00 <shachaf> Wait, why am I talking to johnw?
18:21:29 <shachaf> I keep forgetting.
18:21:41 <jabesed> shachaf: yeap
18:22:41 <jabesed> shachaf: and there's some simple extra requirements that could be added to make it so
18:23:00 <jabesed> shachaf: the questions I was asking initially were related with my attempts to prove this
18:29:40 <nshepperd> (f=<<x) = join (fmap f x) = join (foo (return . f) x) = (foo id . foo return . fmap f) x = (foo id . fmap f) x = foo f x
18:29:41 <shachaf> I don't think those are sufficient.
18:30:00 * hackagebot quickpull 0.4.0.0 - Generate Main module with QuickCheck tests  http://hackage.haskell.org/package/quickpull-0.4.0.0 (OmariNorman)
18:30:15 <nshepperd> ^^ that uses (foo return = id) and (foo (f . g) = foo f . fmap g)
18:30:19 <jabesed> I'm starting to serioulsy doubt it myself
18:30:31 <shachaf> Hmm.
18:35:14 <jabesed> nshepperd: yeap I tried that path...
18:36:06 <jabesed> writting it in category theory notation and moving to haskell is making my head spin
18:36:19 <jabesed> I think I'm going to sleep on it
18:37:03 <jabesed> it's quite possible it's not enough, but it feels like maybe with another simple property or two it should work
18:37:05 <shachaf> What is your actual monad?
18:37:41 <jabesed> shachaf: that would take a long while to describe actually, and it's not even a monad but a comonad, I'm just proving the dual
18:37:47 <jabesed> shachaf: it's like some kind of trees
18:37:57 <shachaf> Do you have code for it?
18:38:05 <jabesed> shachaf: nope, it's denotational semantics
18:38:23 <jabesed> shachaf: therefore me using cat theroy notation
18:39:39 <shachaf> SMILING CATEGORY WITH HEART-SHAPED OBJECTS
18:39:45 <jabesed> :)
18:42:31 <lisbeth> List of all the vanilla functions in haskell?
18:42:34 <lisbeth> and their usage?
18:43:30 <jabesed> this was me trying to find an elegant way around of calculating f# (coextension of f) as T f . d     as it involves working with T f : TT A -> TB and calculating
18:43:35 <ReinH> lisbeth: what is a "vanilla function"?
18:43:39 <jabesed> and composing this
18:43:56 <lisbeth> In many english speaking countries vanilla is slang for unaltered/noncustom
18:44:06 <jabesed> so T A are trees, and TTA trees of trees
18:44:18 <lisbeth> so, everything that comes by default in a up to date package of ghc
18:44:23 <Welkin> rather, it means "plain"
18:44:28 <lisbeth> yeah
18:44:30 <ReinH> Ok. What is an "unaltered" or "noncustom" function? Are you referring to the definitions imported from the Prelude? Or base as a whole?
18:44:36 <Welkin> "vanilla" is often synonymous with "plain"
18:44:40 <lisbeth> as in
18:44:43 <lisbeth> lets say I open up ghci
18:44:54 <lisbeth> I want to know every function that is available to me without declaring a new function
18:45:10 <lisbeth> a cheat sheet, so to speak
18:45:10 <ReinH> lisbeth: http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html
18:45:14 <jabesed> lisbeth:  :browse
18:45:15 <lisbeth> thanks
18:45:23 <jabesed> lisbeth: type :browse in ghci
18:45:49 <Iceland_jack> :bro to save three characters
18:45:52 <lisbeth> heh ghci is busy calculaint a really really long output to a function right now
18:45:52 <lisbeth> but I will do it later
18:46:08 <jabesed> lisbeth: you can open two :P
18:46:35 * shachaf wonders whether the Comonad class is vanilla.
18:53:05 <jabesed> shachaf: more vanilla than the Monad class which is chocolate with fries
18:53:35 <ReinH> I'm thinking strawberry
18:53:43 <jabesed> is the fun-ap-mon proposal going to be applied soon?
18:53:52 <jabesed> monad class is horrible :/
18:54:05 <Hijiri> It'll be applied GHC 7.10
18:54:09 <jabesed> yay
18:54:28 <ReinH> Yay indeed.
18:54:57 <shachaf> jabesed: I was going for a vanilla extract pun but I didn't have the heart to continue.
18:55:07 <ReinH> I GET IT NOW
18:55:11 <jabesed> shachaf: ah :)
18:55:18 <ReinH> shachaf: You mean vanilla comultiplication? ;)
18:55:25 <shachaf> No.
18:55:29 <ReinH> Oh no that's vanilla counit
18:55:34 <jabesed> yeap
18:55:44 <jabesed>  cm a -> a
18:55:49 <ReinH> I can never remember the Haskell Comonad names
18:55:53 <sgronblo> :bro command for true brogrammers
18:56:06 <jabesed> just call them monad names with co behind
18:56:08 <ReinH> jabesed: We like to use w because it's a dual m ;)
18:56:09 <jabesed> easier
18:56:19 <ReinH> jabesed: I understand the CT terms.
18:56:28 <ReinH> I forget which ones were chosen for the Haskell typeclass
18:56:35 <jabesed> ReinH: ah I was going to ask that, couldn't remember
18:56:58 <ReinH> Comonad w => w a -> a
18:58:03 <shachaf> The Haskell names are easier to remember because they are English words rather than Greek letters.
18:59:50 <e11> hey guys which IDE would you recommend for Haskell on Linux? Or is it all vim and command line?
19:00:06 <dmj`> e11: emacs
19:01:04 <jabesed> shachaf: ok got it, I really was missing (g . f)* = g* . f*
19:01:35 <jabesed> shachaf: I thought maybe I could derive that one somehow, but I just saw an axiomatic for (-)* and it includes that one
19:01:45 <jabesed> which then makes the proof trivial
19:01:57 <HeladoDeBrownie> e11, emacs or vim, both are common afaict
19:02:17 <e11> oh ok, there is no big sexy IDE a la Pycharm or whatever. gotcha
19:02:36 <jabesed> shachaf: where f* is (>>=f)
19:02:37 <HeladoDeBrownie> e11, there are Haskell IDEs
19:02:38 <ReinH> e11: They supposedly exist. I'm not sure if many people use them.
19:02:41 <Hijiri> emacs is big
19:02:42 <HeladoDeBrownie> ^
19:02:49 <Hijiri> maybe sexy too
19:02:53 <dmj`> e11: sexy is relative
19:02:57 <ReinH> Well, certainly big
19:03:27 <shachaf> jabesed: What are the types of f and g here?
19:03:37 <e11> ok, I hear ya, I'll stick with vim for my haskell adventures I guess
19:03:48 <Welkin> e11: "big" is not good for a text editor
19:03:56 <Welkin> an IDE is too bloated as well
19:03:58 <ReinH> e11: Vim has some nice Haskell plugins.
19:04:05 <Welkin> if you *need* an IDE to program, then the language is fucked
19:04:22 <benzrf> Welkin: to be fair
19:04:30 <benzrf> intellegent completion could be incredible
19:05:00 <benzrf> the type system is more than powerful enough
19:05:01 <Welkin> benzrf: it is when you cannot do anything without it
19:05:13 <e11> im not against that philosophy (minimalism?) but I have worked on a project where IDEs saved huge amounts of time. I'm down with minimalist stuff tho
19:05:15 <Welkin> benzrf: have you developed anything for iOS using swift/obj-c?
19:05:17 <Welkin> what a nightmare
19:05:20 <benzrf> i'vent
19:05:26 <Welkin> autocomplete is your only hope
19:05:27 <benzrf> but i used to do java
19:05:29 <benzrf> cripes
19:05:47 <HeladoDeBrownie> I think there's a lot of potential for languages that are habitually used with IDEs rather than text editors. Graph- or tree-based editors, for example
19:05:52 <Hijiri> the course I'm taking uses java and requires vim
19:05:59 <jabesed> shachaf: f : A -> TB   and g: TB -> TTC
19:06:22 <ReinH> e11: IDEs increase in utility as languages become more and more tedious for humans to write. Haskell is relatively good here.
19:06:23 <jabesed> shachaf: so g . f : A -> TTC
19:06:33 <sgronblo> e11: there is some new thing for intellij called hask-force which i would try out if i had the time, for small things i just use vim.
19:06:36 <jabesed> shachaf: (g . f) : T A -> TTC
19:06:58 <jabesed> shachaf: missing a * there ^
19:07:10 <e11> good point, ReinH. Agree. Haskell seems to occupy a relatively sweet spot of newness and purity as languages go. thanks sgronblo
19:07:26 <Welkin> newness?
19:07:35 <Koganei> hey guys, is there a book that you'd recommend to start learning Haskell? I'm from the OO side (Javascript, PHP, C#) and want to learn how to speak Haskell
19:07:44 <Hijiri> Koganei: https://github.com/bitemyapp/learnhaskell
19:07:45 <sgronblo> i dont agree with the "you must use vim/emacs to be a true programmer" any more. yes, my vim level is pretty high.
19:07:46 <Welkin> "speak" haskell?
19:07:50 <ReinH> @google Thinking Functionally with Haskell Richard Bird
19:07:52 <lambdabot> http://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/thinking-functionally-haskell
19:07:52 <lambdabot> Title: Thinking Functionally with Haskell | Programming languages and applied logic ...
19:08:01 <e11> sorry just running my mouth, I'm just learning it now -- dont really know much haskell at all yet!
19:08:05 <ReinH> Koganei: This is by far the best book on Haskell right now imo
19:08:06 <HeladoDeBrownie> vim and emacs are both terrible. However, I've yet to find anything better
19:08:13 <jabesed> shachaf: nevermind wait
19:08:14 <Koganei> Welkin: figure of speech :)
19:08:14 <Welkin> e11: haskell started in 1988 I believe
19:08:25 <Welkin> perhaps earlier
19:08:28 <e11> shit, thats ancient
19:08:30 <Koganei> ReinH: Hijiri: nice, that's actualy the book I started yesterday
19:08:34 <Koganei> thanks!
19:09:03 <Hijiri> there's also the #haskell-beginners channel for random help if you haven't already been there
19:09:04 <jabesed> shachaf: sorry I really need bed, it should have been (g* . f )* = g* . f*
19:09:10 <ReinH> e11: If you're using vim, these plugins might be useful http://haskelllive.com/environment.html
19:09:11 <e11> "Thinking functionaly with haskell" is the best book, ReinH? thanks Hijiri
19:09:17 <Koganei> Hijiri: I am not, awesome
19:09:20 <jabesed> shachaf: and now that actually makes sense
19:09:29 <e11> thanks ReinH, I'm going to grab them now!
19:09:30 <jabesed> I'm off to bed, waaaay to tired
19:09:35 <jabesed> ciau
19:09:47 <ReinH> e11: yeah it's an incredibly good Haskell book
19:10:09 <Welkin> there are many good resources on the haskell wiki as well
19:10:15 <Hijiri> Maybe I should buy the book
19:10:19 <Hijiri> I don't have enough programming books
19:10:25 <Welkin> this too: http://dev.stephendiehl.com/hask/
19:10:38 <sgronblo> for dynamic languages i will keep using vim, but for static languages its really worth using something like intellij. IDE hating is being brainwashed.
19:11:01 <Hijiri> emacs is already an IDE
19:11:11 <Hijiri> (with plugins)
19:11:15 <sgronblo> yeah i guess emacs is closer to an ide than vim
19:11:35 <HeladoDeBrownie> Vim has autocomplete of some sort. I never got the hang of using autocomplete in any editor though so I don't know what its deal is
19:11:37 <sgronblo> but who wants to use emacs? :)
19:11:43 <dmj`> me
19:11:53 <dmj`> emacsOS
19:12:00 <Welkin> I've grown fond of emacs
19:12:03 <Welkin> it feels natural
19:12:16 <HeladoDeBrownie> just like the incursion of Cthulhu into our realm
19:12:19 <Welkin> but it still gets frustrating when I want to do something with my config file
19:12:28 <e11> you guys rock! why did I just figure out IRC just now?
19:12:32 <sgronblo> HeladoDeBrownie: yeah it does, but it requires you to mess with plugin customization and possibly add some scripting of your own.
19:12:42 <Welkin> even so, the keybindings are great
19:13:16 <orion> If you implement a cryptographic hash function in Haskell, can QuickCheck really only check test vectors and nothing else?
19:13:35 <orion> It can't do any arbitrary tests.
19:13:35 <HeladoDeBrownie> sgronblo, fair enough. I've touched vimscript, I'd prefer never to touch it again
19:13:56 <sgronblo> for me its much easier to install ideavim in intellij and get 80% of vim's keybindings instead of trying to get to 80% of intellijs functionality by configuring a bunch of plugins
19:14:08 <sgronblo> yeah vimscript is lame too
19:14:20 <benzrf> vimscript is Da Worst
19:14:25 <Iceland_jack> orion: Not sure what you're asking, you aren't limited to testing it with test vectors
19:14:42 <sgronblo> orion: I think quickcheck will verify any property that you are clever enough to define.
19:15:13 <sgronblo> not sure about what your definition of "arbitrary test" is.
19:15:15 <Iceland_jack> It's quite common to have a (slow; preexisting) reference implementation that you check against
19:17:48 <ReinH> QuickCheck uses a typeclass called "Arbitrary"...
19:18:16 <ReinH> So it definitely does arbitrary tests for some value of arbitrary.
19:18:44 <e11> thanks for the tips yall, have a good night everybody!!
19:23:18 <bananagram> good morning
19:23:36 <Hijiri> nyanpasu
19:29:02 <codygman> I'm guessing I need to specialize the m a at the end? http://lpaste.net/115471
19:30:11 <codygman> No wait, withMySQLconn doesn't know how to operate in MonadIO
19:31:36 <codygman> and needs all of (MonadBaseControl IO m, MonadIO m, MonadLogger m)?
19:32:46 <codygman> hmm just NEEDS (MonadBaseControl IO m, MonadIO m) with the MonadLogger optional. Is that because it is inferred?
19:33:23 <johnw> if you haev MonadBaseControl IO, you don't ever need MonadIO, since you now have liftBase.  Not sure about the lib constraints though, they could be overly strict
19:38:13 <orion> hmm
19:38:47 <orion> How do you write unit tests for "Internal" modules which aren't exposed in the project's cabal file?
19:39:00 <johnw> include them in the modules for the unit tests
19:39:12 <johnw> i.e., for the test executable have: other-modules: Foo.Internal
19:39:30 <c_wraith> orion: expose the modules in the project's cabal file.  Users of the library will thank you.
19:40:32 <orion> c_wraith: Why should internal modules be exposed to users?
19:41:06 <Iceland_jack> orion: http://www.reddit.com/r/haskell/comments/2nkiiq/testing_internals_without_exposing_them/ you can read this thread
19:41:17 <c_wraith> orion: because in 99% of cases, your expected use cases are incomplete, and by hiding your .Internal modules, you're preventing people from using your library because you guessed wrong.
19:43:15 <codygman> I solved the above problem (http://lpaste.net/115471) that I didn't fully understand and now I have a problem I really don't understand: http://lpaste.net/
19:43:34 <codygman> http://lpaste.net/115472 ^^^
19:44:27 <johnw> codygman: #1 you don't need liftIO in main, it's already in IO
19:44:42 <johnw> #2 do you mean to rcall runDb in IO?
19:45:04 <johnw> it seems to be expecting a database monadic context
19:46:35 <codygman> johnw: For the moment I just want a working way to get settings from my database. Which would mean I need to relax the MonadPersist m I'm guessing?
19:46:46 <codygman> SqlPersistM*
19:47:27 <johnw> i'm not sure
19:47:44 <codygman> I guess I really don't understand the types and what they are doing here.
19:48:02 <codygman> I probably just need to re-read through persistents types/monads.
19:48:29 <codygman> mayb
19:48:30 <codygman> e
20:00:00 <Na> Is there a library that'll easily let me construct arbitrary length words?
20:00:46 <Welkin> what do you mean by words?
20:00:56 <Welkin> valid english words?
20:01:00 <Na> Bits
20:01:04 <Welkin> oh
20:01:13 <Na> I have some bits. I want to perform bitwise operations on them as a whole
20:01:19 <Welkin> a word is two bytes (16 bits)
20:01:26 <Taneb> @hackage largeword
20:01:26 <lambdabot> http://hackage.haskell.org/package/largeword
20:01:34 <Taneb> @hackage OddWord
20:01:34 <lambdabot> http://hackage.haskell.org/package/OddWord
20:01:59 <shachaf> A word in Microsoftese and Intelese is 16 bits, anyway.
20:02:13 <Welkin> er
20:02:21 <Na> OddWord solves my problem
20:02:25 <Na> Thanks
20:02:26 <Welkin> yes
20:02:31 <simpson> 12634986723 ^. bitAt 42 -- doesn't lens do this?
20:02:33 <Welkin> word length is different on each platfomr
20:02:39 <simpson> > 12634986723 ^. bitAt 42 -- derp
20:02:41 <lambdabot>  False
20:03:18 <Na> I mean, I don't actually care about "words". I just have some bits that I want to do things to, but the Word libraries seem to be what I need to do those things
20:03:45 <simpson> The Word8, Word16, etc. types really only provide the wraparound and Bounded instances.
20:03:59 <simpson> > 1000 :: Word8
20:04:00 <lambdabot>  232
20:07:31 <merijn> Na: Data.Bits ?
20:29:52 <pavonia> @hoogle (a -> Bool) -> (a -> Bool) -> (a -> Bool)
20:29:53 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
20:29:53 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
20:29:53 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
20:30:25 <benzrf> pavonia: liftA2 (||)
20:30:28 <pavonia> Are there infix operators for liftA2 (&&) and liftA2 (||) smewhere?
20:30:33 <pavonia> Yeah :)
20:30:33 <benzrf> probs not
20:30:37 <benzrf> there's <>
20:30:45 <benzrf> if you store your bools as anys or alls
20:31:06 <pavonia> What does that mean?
20:31:14 <pavonia> :t (<>)
20:31:15 <lambdabot> Monoid m => m -> m -> m
20:31:23 <merijn> It's just mappend
20:31:41 <benzrf> > let long = Any . (>10) . length; short = Any . (<5) . length; longOrShort = long <> short; in longOrShort "hello"
20:31:43 <lambdabot>  Any {getAny = False}
20:31:49 <dmj`> pavonia: it means different things depending on the instance
20:32:06 <benzrf> pavonia: functions resulting in monoid elements form a monoid
20:32:12 <benzrf> pavonia: under pointwise mappend
20:32:27 <pavonia> Hhm, I see
20:32:34 <benzrf> pavonia: the Any and All monoids are the ones where mconcat is any and all respectively
20:32:39 <benzrf> er, wait
20:32:42 <dmj`> > Product 2 <> Product 2
20:32:43 <lambdabot>  Product {getProduct = 4}
20:32:46 <benzrf> make that and and or
20:32:47 <dmj`> > Sum 2 <> Sum 2
20:32:48 <lambdabot>  Sum {getSum = 4}
20:32:58 <benzrf> > Any True <> Any False
20:32:59 <lambdabot>  Any {getAny = True}
20:33:03 <dmj`> > "a" <> "b"
20:33:04 <lambdabot>  "ab"
20:33:05 <merijn> This works even better with
20:33:07 <merijn> :t foldMap
20:33:08 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
20:33:18 <merijn> :t foldMap Any
20:33:19 <lambdabot> Foldable t => t Bool -> Any
20:33:31 <benzrf> :t ala Any foldMap
20:33:32 <lambdabot> Foldable t => t Bool -> Unwrapped Any
20:33:33 <merijn> :t foldMap (Any . even)
20:33:34 <lambdabot> (Foldable t, Integral a) => t a -> Any
20:33:58 <benzrf> pavonia: of course it's probably impractical to keep all of your bools in monoid wrappers all th time
20:34:00 <merijn> I don't like ala, I find it confusing to read
20:34:29 <dmj`> :t F.foldr mappend mempty
20:34:30 <lambdabot> (Monoid b, Foldable t) => t b -> b
20:34:34 <benzrf> pavonia: but on the off chance that you have a buttload of liftA2 op where op is always the same, you could keep them in Any or All for that section of the program & use mappend on the functions
20:35:12 <merijn> dmj`: That's just foldMap :p
20:35:17 <dmj`> merijn: yes
20:35:26 <pavonia> benzrf: I only have up to four of them
20:35:35 <benzrf> pavonia: you could just define local aliases!
20:35:38 <merijn> Well, not quite, I guess that's 'foldMap id"
20:35:41 <benzrf> this is why we need idiom brackkets
20:35:44 <benzrf> >.<
20:35:46 <johnw> it's mconcat
20:35:55 <benzrf> [| short || long |] bls
20:36:15 <dmj`> :t foldMap (:[])
20:36:16 <lambdabot> Foldable t => t a -> [a]
20:36:18 <dmj`> :t F.toList
20:36:19 <lambdabot> Foldable t => t a -> [a]
20:36:38 <dmj`> :t foldr (mappend . (:[]) mempty
20:36:38 <pavonia> benzrf: What do you mean by local?
20:36:38 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
20:36:51 <merijn> pavonia: where/let
20:37:08 <pavonia> Ah, no, I need them top-level
20:39:00 <benzrf> or that
20:39:06 <benzrf> i actually meant module-local, so
21:30:07 * hackagebot warp 3.0.4 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.4 (MichaelSnoyman)
21:31:10 <ReinH> merijn: also known as "fold" ;)
21:31:14 <jle`> it's it's actually fold
21:31:20 <jle`> oh, beat me too it
21:31:22 <ReinH> :p
21:31:34 * jle` shakes fist
21:31:56 <bitemyapp> johnw: does `github` support the activity API? Doesn't seem like it does.
21:32:07 <bitemyapp> I want this: https://developer.github.com/v3/activity/events/
21:35:05 <Bones> Why is the lambda symbol associated with Haskell/functional languages?
21:35:19 <Welkin> lambda calculus
21:35:29 <bitemyapp> Bones: lambda calculus
21:35:49 <shachaf> It's associated with lots of things.
21:36:16 <narendraj9> Bones: https://medium.com/@ayanonagon/the-y-combinator-no-not-that-one-7268d8d9c46
21:42:48 <sgronblo> http://math.stackexchange.com/questions/64468/why-is-lambda-calculus-named-after-that-specific-greek-letter-why-not-rho-calc
21:45:26 <ab9rf> heh
21:45:50 <Dulnes> What am i doing here
21:46:55 <ab9rf> increasing entropy
21:48:07 <Dulnes> Soneone make a language based off of entropy
21:49:11 <jle`> insert cheap perl joke here
21:49:34 <peddie> Dulnes: http://homepages.cwi.nl/~tromp/cl/cl.html
21:50:05 <Dulnes> Leaves earth
21:50:08 * hackagebot wai-conduit 3.0.0.1 - conduit wrappers for WAI  http://hackage.haskell.org/package/wai-conduit-3.0.0.1 (MichaelSnoyman)
21:50:10 * hackagebot wai-extra 3.0.2.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.2.2 (MichaelSnoyman)
21:54:27 <dmj`> > for [1,2,3] Just
21:54:29 <lambdabot>  Not in scope: ‚Äòfor‚Äô
21:54:29 <lambdabot>  Perhaps you meant one of these:
21:54:29 <lambdabot>    ‚ÄòT.for‚Äô (imported from Data.Traversable),
21:54:29 <lambdabot>    ‚Äòor‚Äô (imported from Data.List),
21:54:29 <lambdabot>    ‚ÄòF.or‚Äô (imported from Data.Foldable)
21:54:37 <dmj`> > T.for [1,2,3] Just
21:54:39 <lambdabot>  Just [1,2,3]
22:28:10 <freakhill> hello, I have a small question about the "shelly" module (haskell beginner)
22:28:51 <freakhill> On Windows http://pastebin.com/krGSLWcx can't find the dir command
22:29:10 <freakhill> someone knows why? (I am making a comparative sheet of languages for my team at work)
22:29:34 <shachaf> Is dir a command in Windows?
22:29:41 <Haskellfant> yep
22:29:47 <MP2E> yes, it's the DOS equivalent of ls
22:29:49 <Haskellfant> it's even a command on linux
22:30:05 <shachaf> I meant is it a binary that you can run. But I see you're using cmd.exe /c
22:30:12 <shachaf> Does cmd.exe /c dir work otherwise?
22:30:17 <freakhill> not a binary
22:30:20 <freakhill> yes it works
22:30:21 <MP2E> ah
22:30:35 <shachaf> And that doesn't work?
22:30:42 <shachaf> What is it actually running?
22:30:56 <shachaf> If there's a Window equivalent of strace, I'd suggest trying that. :-)
22:32:07 <freakhill> i could read strace but i have no ideas about windows internals t_t, i'll look in that direction.
22:34:13 <shachaf> I think there's a Windows equivalent but I don't remember the details.
22:34:50 <freakhill> i'm looking into the options of the new visual studio 2013 community edition
22:39:33 <chrizz_> hello, I'm having trouble understanding the implementation of liftBaseOp... liftBaseOp f = \g -> control $ \runInBase -> f $ runInBase . g
22:39:44 <chrizz_> in particular I don't understand how "runInBase . g" is well-typed
22:40:11 <chrizz_> it looks to me like... let's see...
22:40:14 <shachaf> What are the types that you know?
22:40:29 <chrizz_> g :: MonadBaseControl b m => a -> m c
22:40:59 <chrizz_> runInBase :: MonadBaseControl b m => (forall a. m a -> b (StM m a)) -> b (StM m a)
22:41:24 <shachaf> I think you'd better add some quantifiers here.
22:41:28 <chrizz_> err, some of that is wrong, that a shouldn't escape
22:41:38 <shachaf> Also you'd better know the type of control or you're in trouble.
22:41:42 <shachaf> And of liftBaseOp.
22:42:07 <chrizz_> right, I got those types from the docs ^
22:42:47 <shachaf> Well, you didn't link to those and you didn't say what they are. :-)
22:43:07 <chrizz_> whoops, here you go http://hackage.haskell.org/package/monad-control-0.3.3.0/docs/Control-Monad-Trans-Control.html
22:43:26 <shachaf> OK.
22:44:54 <shachaf> control :: forall a m b. MonadBaseControl b m => ((forall x. m x -> b (StM m x)) -> b (StM m a)) -> m a
22:44:57 <shachaf> Is that right?
22:45:10 <chrizz_> yeah
22:46:59 <shachaf> And liftBaseOp :: forall m a b c d. MonadBaseControl b m => ((a -> b (StM m c)) -> b (StM m d)) -> (a -> m c) -> m d
22:46:59 <chrizz_> yes
22:47:19 <shachaf> And the puzzle is: Use control to implement liftBaseOp.
22:47:38 <chrizz_> Maybe here's a simpler question: the example in the docs for liftBaseOp is "liftBaseOp alloca :: MonadBaseControl IO m => (Ptr a -> m c) -> m c". Since alloca :: (Ptr a -> IO a) -> IO a, I don't see how it can be passed as an argument to liftBaseOp
22:48:14 <chrizz_> oops, alloca is a little more general than that
22:48:20 <chrizz_> but still - it doesn't look like the same "shape"
22:48:32 <chrizz_> as "a -> b (StM m c) -> b (StM m d)"
22:48:43 <chrizz_> ...with the correct parens
22:49:23 <chrizz_> does that make sense?
22:49:40 <shachaf> alloca :: (Ptr q -> IO w) -> IO w, with some constraints
22:49:52 <chrizz_> yes
22:50:10 * hackagebot react-haskell 1.1.0.0 - Haskell React bindings  http://hackage.haskell.org/package/react-haskell-1.1.0.0 (joelb)
22:50:13 <shachaf> liftBaseOp's argument is :: (a -> b (StM m c)) -> b (StM m d)
22:50:20 <chrizz_> yeah
22:50:37 <shachaf> So a = Ptr q and IO w = b (StM m c) = b (StM m d)
22:50:58 <shachaf> So presumably b = IO and StM m c = StM m d = w?
22:51:11 <chrizz_> That's what it looks like, but...
22:51:17 <shachaf> Hmm, StM is a data family thing.
22:51:30 <chrizz_> Yeah
22:52:32 <chrizz_> Oops, excuse me, I realize my confusion now
22:53:14 <chrizz_> I was thinking in terms of `bracket` (not alloca), where you can close over the acquire/release functions, and I thought, if you have control over the return values, then how do you satisfy the output shape StM?
22:53:31 <chrizz_> however I forgot that the type of bracket makes that just not a problem =)
22:53:50 <chrizz_> anyways, back to not understanding the liftBaseOp body
22:54:34 <xpilot> hi, I have a question about serialization: I'm using the cereal package, and I'd like to serialize a Data.Matrix
22:55:00 <shachaf> Oh, I misread part of it. It's polymorphic in the result type so of course it works fine.
22:55:19 <chrizz_> shachaf: what function?
22:55:28 <shachaf> alloca
22:55:35 <chrizz_> right
22:55:37 <shachaf> w = StM m c is no problem.
22:55:50 <xpilot> however, Data.Matrix isn't an instance of GHC.Generics.Generic, which cereal needs in order to define an instance of Serialize
22:55:50 <chrizz_> same with bracket closed over the acquire/release function, I had the same exact confusion
22:56:26 <chrizz_> but! I'm now back to trying to understand the function composition "runInBase . g" in the liftBaseOp definition
22:58:01 <dmj`> xpilot: Matrix contains a Vector, Vector contains an Array, you should be able to do it, if you specify a serialize instance for both Vector and Matrix since cereal already exports Array
22:58:53 <dmj`> xpilot: you can use generics (import GHC.Generics (Generic))
22:59:39 <xpilot> dmj': well I tried "deriving instance Generic (Matrix Int)"
23:00:05 <xpilot> but "The data constructors of `Matrix' are not all in scope"
23:00:25 <dmj`> xpilot: how are you import Matrix? Can you show code
23:00:28 <dmj`> on lpaste.net
23:00:36 <dmj`> importing
23:01:28 <chrizz_> shachaf: do you see how runInBase can compose with g?
23:01:29 <xpilot> import Data.Matrix hiding ((!)), import qualified Data.Matrix as Matrix
23:02:17 <xpilot> http://lpaste.net/115478
23:03:35 <xpilot> from the source code of Data.Matrix it looks like the constructor simply isn't exported
23:04:14 <xpilot> http://hackage.haskell.org/package/matrix-0.3.4.0/docs/src/Data-Matrix.html#Matrix
23:07:30 <dmj`> xpilot: that's not cool
23:08:04 <dmj`> xpilot: can you call show on it and pack it into a bytestring, save it to disk, then read from disk, unpack and read ?
23:08:19 <dmj`> a little hacky
23:09:00 <xpilot> matrix doesn't implement Read :(
23:10:32 <xpilot> all I really use matrix for game board... maybe there is a better alternative
23:11:42 <dmj`> another matrix library maybe? Or fork it and add your own serialize, make a pull
23:21:10 <nshepperd> what's wrong with using toList/fromList to serialize it
23:22:56 <dmj`> nshepperd: that would work... as long as you don't need the constructor
23:24:11 <chrizz_> shachaf: i think i got it, thanks though!
23:25:02 <shachaf> chrizz_: Oh, I didn't see your message above.
23:25:09 <shachaf> I'm glad you figured it out. :-) Those types look like a mess.
23:25:14 <chrizz_> no problem
23:25:40 <nshepperd> instance Serialize a => Serialize (Matrix a) where { put mat = put (ncols mat) >> put (nrows mat) >> put (toList mat); get = ... }
23:27:34 <dmj`> nshepperd: he doesn't have access to rowOffset or colOffset
23:28:23 <nshepperd> why do you need that
23:28:35 <dmj`> I guess you don't if you use the matrix function
23:28:41 <dmj`> matrix :: Int -- ^ Rows
23:28:41 <dmj`>        -> Int -- ^ Columns
23:28:41 <dmj`>        -> ((Int,Int) -> a) -- ^ Generator function
23:28:41 <dmj`>        -> Matrix a
23:29:32 <nshepperd> Data.Matrix.fromList
23:30:11 <dmj`> yea, that'd do it
23:33:02 <xpilot> I went with   put = Serialize.put . toLists   get = fmap fromLists Serialize.get
23:34:24 <zebral> @help
23:34:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:35:06 <zebral> @pl (\x w -> all (==True) (map (f x) w))
23:35:06 <lambdabot> (all (True ==) .) . map . f
23:36:41 <Iceland_jack> zebral: use 'and'
23:36:44 <shachaf> (==True) = id
23:36:47 <shachaf> all id = and
23:37:36 <shachaf> and . map g = all g
23:37:40 <Iceland_jack> In fact you can probably write 'all (f x) w'
23:38:03 <shachaf> So without any @pling, your expression becomes (\x w -> all (f x) w)
23:38:32 <ThreeOfEight> shachaf: are you sure?
23:38:37 <shachaf> No.
23:38:42 <ThreeOfEight> all g [] == True
23:38:51 <ThreeOfEight> er
23:38:58 <shachaf> @src all
23:38:58 <lambdabot> all p = and . map p
23:39:05 <shachaf> Which part should I not be sure about?
23:39:10 <ThreeOfEight> oh, never mind
23:39:17 <ThreeOfEight> I think I am stupid.
23:39:25 <shachaf> You can @pl that to (\x -> all (f x)) and further to (all . f)
23:39:28 <ThreeOfEight> I wanted to suggest using and first
23:39:40 <ThreeOfEight> and then thought that and and all behaved differently on the empty list
23:39:44 <ThreeOfEight> but, of course, they do not.
23:40:00 <ThreeOfEight> Alas, it is too early.
23:40:24 <shachaf> I think (all . f) is as simple as zebral could hope for that expression.
23:41:15 <PragCypher> is there a way to negate the result of the compare function to get the revese ordering?
23:41:19 <PragCypher> *reverse
23:41:24 <ThreeOfEight> PragCypher: flip
23:41:24 <shachaf> flip compare?
23:41:36 <shachaf> Perhaps this is one of the few valid uses of flip.
23:41:41 <shachaf> But even here I'm suspicious.
23:42:14 <Iceland_jack> PragCypher: there is always Down
23:42:29 <PragCypher> hmm
23:42:43 * PragCypher checking out both definitions
23:42:45 <shachaf> There's also the function compare EQ
23:43:01 <shachaf> > map (compare EQ) [LT,EQ,GT]
23:43:02 <lambdabot>  [GT,EQ,LT]
23:45:24 <ThreeOfEight> One thing I've been wondering about for some time now:
23:45:37 <PragCypher> i think compare . flip is most eligant
23:45:41 <PragCypher> thanks guys!
23:45:45 <ThreeOfEight> from what I've read, newtype wrappers like Down, Sum, etc. should be without any cost
23:45:53 <ThreeOfEight> because they do not appear at runtime
23:46:06 <ThreeOfEight> but what if I have an entire list and have to tag and untag it?
23:46:13 <Iceland_jack> ThreeOfEight: Then you use 'coerce'
23:46:30 <nkar> shachaf: I don't see enough context, but when does one want to compare EQ and LT?
23:46:32 <Iceland_jack> Further information here https://ghc.haskell.org/trac/ghc/wiki/Roles
23:46:47 <nkar> is it just there to provide other usecases?
23:46:49 <shachaf> nkar: (compare EQ) is a function that flips an Ordering around.
23:47:08 <PragCypher> *compare flip
23:47:21 <nkar> ah, I see
23:47:39 <shachaf> PragCypher: ?
23:48:04 <ThreeOfEight> interesting
23:48:12 <shachaf> Oh.
23:48:13 <shachaf> Never mind.
23:48:39 <ThreeOfEight> are there automatic rewrite rules that convert something like "map Sum" into "coerce"?
23:49:05 <Iceland_jack> You'll have to do that manually I'm afraid
23:49:28 <ThreeOfEight> wouldn't it be a good idea to add rewrite rules for that?
23:53:22 <haasn> Would it be a good idea to rewrite any function to ‚Äúcoerce‚Äù where it type checks?
23:53:41 <haasn> s/any/every/
23:54:00 <jle`> yeah probably
23:54:19 <butyoudonot> how "map Sum" and "coerce" even relates to each other?
23:54:44 <haasn> jle`: Oh, they simply can't work in general
23:54:46 <haasn> that*
23:54:55 <haasn> f :: [Int] -> [Sum Int]; f _ = []
23:55:00 <haasn> coerce type checks as well
23:55:04 <jle`> in fact i advocate rewriting everything to unsafeCoerce
23:55:10 <Iceland_jack> (for completeness of my previous answer)
23:55:13 <Iceland_jack> > sortBy (comparing Down) "abcd"
23:55:14 <lambdabot>  "dcba"
23:55:52 <jle`> rewriting everything to unsafeCoerce turns all of your algorithms into O(1)
23:55:55 <jle`> like magic
23:56:04 <jle`> see you later turing
23:56:08 <butyoudonot> wow so optimization very productive
23:56:20 <ThreeOfEight> butyoudonot: seeing as Sum doesn't exist at run time, "map Sum" will not do anything at run time
23:56:31 <ThreeOfEight> which is why I was wondering whether it gets eliminated
23:56:37 <haasn> butyoudonot: ‚Äúmap Sum‚Äù doesn't affect the representation of the list
23:56:43 <haasn> Sort of
23:56:55 <haasn> (It can still cause evaluation, though; which coerce would not)
23:57:06 <haasn> So there *is* a difference. A practical one when using lazy I/O, too
23:57:24 <jle`> wait, really?  map Sum causes evaluation in places where coerce does not?
23:57:58 <ThreeOfEight> I don't think so either
23:58:16 <haasn> Oh, it's been too long since I've had to think about lazy evaluation. You're right, map is lazy
23:58:20 <haasn> So there's no difference at all
23:58:36 <nshepperd> I think map Sum is equivalent to map coerce
23:58:44 <haasn> map Sum = map coerce = coerce
23:58:49 <nshepperd> the only difference is a smidgen of overhead
23:59:25 <nshepperd> since the 'map' part still traverses the list
