00:00:00 <Skola> Yeah I've seen that, but most of those projects are not-so-open source
00:00:12 <lpaste> solatis pasted “Can this be done more elegantly?” at http://lpaste.net/117145
00:00:22 <solatis> jle`: ^^
00:00:27 <solatis> that's what i have now
00:00:45 <solatis> but i feel it can be done more elegantly, since i just want Left a to propagate
00:01:01 <solatis> a case statement feels wrong here
00:01:14 <jle`> fmap
00:01:14 <platz> solatis: you mean something like tidal?
00:01:18 <solatis> i just only want to handle the case when it is a Right
00:01:22 <CrepeSuzette> ok it's working, thanks everyone++
00:01:27 <platz> ahh, Skola.
00:02:13 <solatis> jle`: hmz, let me see
00:02:27 <jle`> fmap (\selfId -> T.Quorum selfId peers) (lookupSelfOffset self peers)
00:03:35 <solatis> what.. how does that.. i don't..
00:03:38 <solatis> that's awesome
00:03:45 <platz> Skola: http://hackage.haskell.org/package/tidal
00:04:33 <solatis> how come fmap is able to deduce that i only care about Right ? because of type matching?
00:04:58 <HeladoDeBrownie> @type fmap
00:04:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:05:05 <HeladoDeBrownie> f ~ Either e
00:05:19 <HeladoDeBrownie> (a -> b) -> Either e a -> Either e b
00:05:20 <Skola> platz, that looks interesting.
00:05:33 <HeladoDeBrownie> The type e must be left alone, and we know nothing about e, so its value cannot change
00:05:58 <HeladoDeBrownie> (Strictly speaking it could be bottom but let's assume fmap is nice, which it is :P)
00:06:07 <solatis> ohhhh!
00:06:20 <solatis> so it deduces f to Either e
00:06:37 <HeladoDeBrownie> Yep
00:06:42 <solatis> is that also why generally Left contains the error, and Right is what we "care" about ?
00:06:49 <solatis> since otherwise, this would not work?
00:06:50 <HeladoDeBrownie> Yeah
00:06:56 <Skola> platz, do you know off the top of your head what it uses for the actual playback? If not I will dive into the code
00:06:56 <solatis> right
00:07:06 <solatis> suddenly this makes a lot more sense
00:07:27 <solatis> jle`: HeladoDeBrownie: thanks for your help!
00:07:33 <HeladoDeBrownie> no problem
00:07:34 <solatis> my code is now elegant
00:07:38 <HeladoDeBrownie> \o/
00:07:53 <solatis> and i don't even have to import Either or Maybe anymore :)
00:07:54 <platz> Skola: no, i haven't used it. but there is probably a google group or something, also there's a documentation site
00:08:04 <Skola> Cheers platz
00:08:12 <jle`> solatis: it's also actually just literally the implementation of fmap for Either
00:08:15 <jle`> @src fmap Either
00:08:15 <lambdabot> Source not found. I am sorry.
00:08:18 <jle`> @src Either fmap
00:08:18 <lambdabot> fmap _ (Left x) = Left x
00:08:18 <lambdabot> fmap f (Right y) = Right (f y)
00:08:32 <jle`> call it type inference, or call it just literally the function definition :)
00:08:40 <solatis> right
00:08:51 <jle`> that's like saying why does `fst` know you want the first element of the tuple
00:08:54 <jle`> @src fst
00:08:54 <lambdabot> fst (x,_) = x
00:08:57 <jle`> because that's the definition of fst :P
00:08:59 <solatis> i know that from my c++ days, template specialization
00:09:06 <solatis> which is similar to this
00:09:20 <solatis> (which is used by, say, a lot of serialization libraries)
00:09:29 <solatis> anyway, awesome
00:09:39 <solatis> i learned something again today
00:09:55 <jle`> :)
00:14:20 * hackagebot appc 0.0.4 - app container types and tools  http://hackage.haskell.org/package/appc-0.0.4 (wereHamster)
00:19:38 <zq> today i learned to not underestimate the utility of the vector package
00:24:04 <Myrl> In XMonad, why is it that they make records without capitalizing the first letter?
00:24:04 <Skola> tidal doesn't do any of the playback, that's done with Dirt, a software sampler
00:24:51 <Skola> which is pure C
00:25:15 <shachaf> Myrl: Given that most people here don't use xmonad, your question will be tricky to get an answer for.
00:25:25 <shachaf> You could ask in #xmonad or give people here more context.
00:25:52 <glguy> Record update syntax?
00:25:57 <Myrl> shachaf: :P
00:27:49 <Myrl> glguy: Whats that?
00:32:37 <glguy> https://www.haskell.org/onlinereport/exps.html#record-update
00:35:03 <shachaf> Myrl: Maybe I wasn't clear. But it would really make people's lives much easier if you linked to some piece of code that does the thing you're wondering about, rather than force them to guess.
00:35:30 <Myrl> shachaf: Sure. Wait.
00:38:27 <Myrl> http://ix.io/8ya
00:38:50 <Myrl> Please don't kill me if I'm misunderstanding something, I just recently learned Haskell.
00:40:18 <shachaf> Misunderstanding things is OK -- and with enough context nice people like glguy (and even grouches like me) can help you.
00:40:41 <shachaf> Anyway, yes, it's the thing glguy said, record update syntax.
00:40:43 <shachaf> @google record update syntax haskell
00:40:44 <lambdabot> http://stackoverflow.com/questions/14955627/shorthand-way-for-modifying-only-one-field-in-a-record-copy-a-record-changing
00:40:44 <lambdabot> Title: haskell - Shorthand way for "modifying" only one field in a record (copy a re...
00:41:07 <Myrl> shachaf: Thanks.
00:41:17 <shachaf> It's one of the few things that's stickier than function application -- i.e. "f x { y = z }" means "f (x { y = z })"
00:42:06 <Myrl> I see.
00:42:27 <shachaf> (glguy is the one to thank.)
00:42:47 <Myrl> glguy: Thanks.
00:43:26 <glguy> ^_^
00:43:57 <bitemyapp> @karma+ glguy
00:43:57 <lambdabot> glguy's karma raised to 32.
00:44:10 <Myrl> @karma+ glguy
00:44:10 <lambdabot> glguy's karma raised to 33.
00:44:35 <Skola> @karma+ shachaf
00:44:35 <lambdabot> shachaf's karma raised to 79.
00:44:46 <Myrl> @karma+ shachaf
00:44:47 <lambdabot> shachaf's karma raised to 80.
00:45:41 <Myrl> brb
00:49:17 <solatis> :t fmap
00:49:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:50:08 <Myrl> Back.
01:05:19 <wei2912> how do i check if some instance of Floating is an integer?
01:05:24 <wei2912> like "90.0"
01:06:38 <wei2912> s/"//
01:07:23 <pavonia> > (== 0.0) . snd . properFraction $ 90.0
01:07:25 <lambdabot>  True
01:07:31 <pavonia> > (== 0.0) . snd . properFraction $ 90.00000001
01:07:32 <lambdabot>  False
01:18:55 <wei2912> ehh'
01:19:01 <wei2912> i think i'm in float hell
01:19:12 <wei2912> λ :t f
01:19:13 <wei2912> f :: Fractional a => a -> a
01:19:35 <wei2912> the type of the value i want to test for whether it's an integer is of instance Fractional
01:29:30 <Cale> wei2912: Rational is an instance of Fractional
01:29:49 <Cale> wei2912: So you could compute it exactly and look at the denominator to determine whether it's actually an integer.
01:39:11 <wei2912> Cale: http://lpaste.net/117146 -- here's the code i'm having a problem with
01:39:11 <wei2912> i'm confused about the types
01:39:11 <wei2912> and typeclasses
01:39:23 * hackagebot ghcjs-dom 0.1.1.2 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.1.1.2 (HamishMackenzie)
01:40:04 <quchen2> wei2912: This picture from the Report m ight be helpful. https://www.haskell.org/onlinereport/haskell2010/haskell2x.png
01:40:23 <wei2912> thanks quchen2
01:42:15 <wei2912> let n = (fromIntegral x) / (2 * fromIntegral m) - m
01:42:23 <wei2912> the compiler complains:
01:42:24 <wei2912> No instance for (Fractional Int) arising from a use of ‘/’
01:49:31 <Skola> let n = (fromIntegral x) / (2 * fromIntegral m) - fromIntegral m
01:49:36 <Skola> wei2912
01:50:32 <wei2912> Skola: thanks
01:50:44 <wei2912> turns out that the piece of code doesn't give the right answer :(
01:53:12 <Skola> "if isInt n -- how do i implement this?"
01:54:49 <Skola> n's type is fixed (if you use / for division, it won't be an Int)
01:57:29 <Skola> wei2912, for your problem of calculating triplets you should check out list comprehensions
01:58:53 <Skola> your intSqrt is very inefficient, look up a proper integer sqrt algorithm and it will be orders of magnitude faster. Wikipedia has a decent article on it
01:59:24 * hackagebot glib 0.13.0.7 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.13.0.7 (HamishMackenzie)
02:00:50 <wei2912> Skola: yeh, i know about list comprehensions
02:01:01 <wei2912> Skola: i used to do notation in an attempt to reduce repetition
02:01:04 <wei2912> s/to/the/
02:03:42 <wei2912> Skola: also, thanks for the tip on intSqrt
02:04:24 * hackagebot cairo 0.13.0.6 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.13.0.6 (HamishMackenzie)
02:04:26 * hackagebot JuicyPixels 3.2.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.2.1 (VincentBerthoux)
02:06:21 <mmmm> What's the flag to disable document generation?
02:16:01 <Skola> mmmm: --disable-documentation
02:24:25 * hackagebot bank-holidays-england 0.1.0.2 - Calculation of bank holidays in England and Wales  http://hackage.haskell.org/package/bank-holidays-england-0.1.0.2 (dcturner)
02:43:46 <mmmm> Skola: I think that flag might have been deprecated, I had to set Documentation: False in my cabal file
02:45:15 <Skola> Oh sorry, thanks for the info
02:55:04 <quchen2> When Cabal complains that the "pkg-config package X could not be found", what's the name of the package it expects? I've got a package installed (couchbase), but I can't make Cabal find it. I've tried all combinations of couchbase{,2}{,-dev} already.
02:55:24 <quchen2> Oh, and the {lib,} versions too.
03:00:03 <tremon> I can't tell you the packagename (differs per distro), but pkg-config expects to find a file $pkg.pc in its search path
03:00:58 <pyon> Are there lenses for manipulating IntMaps and HashMaps?
03:02:35 <quchen2> tremon: Hmm. I'm confused because the package seems to be installed, at least that's what Synaptic tells me.
03:03:56 <supki> pyon: what exactly do you want to do with them?
03:04:15 <supki> pyon: C.L.At provides indexing and updating for maps
03:04:27 * hackagebot gio 0.13.0.4 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.13.0.4 (HamishMackenzie)
03:04:29 * hackagebot indices 1.6.0 - Static indices  http://hackage.haskell.org/package/indices-1.6.0 (MikeLedger)
03:04:31 * hackagebot pango 0.13.0.5 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.13.0.5 (HamishMackenzie)
03:04:33 * hackagebot gtk3 0.13.4 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.13.4 (HamishMackenzie)
03:05:13 <supki> pyon: also non/anon from C.L.Iso are sometimes useful when working with maps
03:07:24 <supki> pyon: actually, take a look at haddocks for Data.Map.Lens
03:07:39 <pyon> supki: Ah, thanks!
03:07:47 <pyon> supki: Yes, At does the trick.
03:07:54 * pyon is very new to the lens library.
03:08:18 <supki> it talks about Data.Map.Map but the it applies equally well to IntMap and HashMap
03:08:27 <supki> -the
03:09:34 <tremon> quchen2: maybe the package doesn't ship a .pc file. Which distro are the packages from?
03:09:53 <pyon> Why is Control.Lens.At.Index a free-floating family, and not an associated family of Control.Lens.At.Ixed?
03:11:43 <quchen2> tremon: Xubuntu 14.04 here
03:11:58 <quchen2> tremon: The package properties don't mention anything about a .pc file :-(
03:12:32 <SwashBuckla> a free floating-family
03:12:37 <quchen2> Package contents: http://lpaste.net/117147
03:16:14 <tremon> quchen2: right, no .pc file. I can't compare with my install as debian doesn't have couchbase it seems. You may need to ask the package maintainers
03:16:31 <rhaps0dy> Hello! Anyone around?
03:16:42 <aloiscochard> oh, no ORF in 7.10.1 :-(
03:16:58 <quchen2> tremon: Alright, thanks for your help
03:17:08 <rhaps0dy> I wrote newtype Cell [Int], and then I have a Cell and want to get the head of the list inside
03:17:16 <rhaps0dy> can I do this without having to first pattern match the Cell ?
03:17:31 <rhaps0dy> newtype Cell = Cell [Int] *
03:18:40 <mmmm> You have to pattern patch of write an accessor function
03:19:08 <mmmm> a common way is to write newtype Cell = Cell { unCell :: [Int] }
03:19:27 * hackagebot gtk 0.13.4 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.4 (HamishMackenzie)
03:19:35 <rhaps0dy> mmmm: ah, thank you
03:19:52 <rhaps0dy> so one really needs record syntax for that
03:20:21 <mmmm> You don't need to, you can also write it manually :: unCell (Cell x) = x
03:21:36 <rhaps0dy> well
03:21:46 <rhaps0dy> record is shorter and clearer
03:22:01 <rhaps0dy> but you're correct.
03:22:55 <mmmm> sure, I would recommend the record way as well
03:24:27 * hackagebot hs-pkg-config 0.2.1.0 - Create pkg-config configuration files  http://hackage.haskell.org/package/hs-pkg-config-0.2.1.0 (PeterTrsko)
03:34:28 * hackagebot gtksourceview3 0.13.1.2 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview3-0.13.1.2 (HamishMackenzie)
03:37:09 <ocharles_> Are any /r/haskell mods here?
03:39:28 * hackagebot egison 3.5.1 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.5.1 (SatoshiEgi)
03:39:30 * hackagebot gtksourceview2 0.13.1.2 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.13.1.2 (HamishMackenzie)
03:49:29 * hackagebot gtk3-mac-integration 0.3.0.2 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk3-mac-integration-0.3.0.2 (HamishMackenzie)
03:54:29 * hackagebot gtk-mac-integration 0.3.0.2 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk-mac-integration-0.3.0.2 (HamishMackenzie)
03:54:31 * hackagebot webkitgtk3 0.13.1.1 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.13.1.1 (HamishMackenzie)
03:59:29 * hackagebot webkit 0.13.1.1 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.13.1.1 (HamishMackenzie)
04:04:16 <hop__> hello, is there an immutable stack implementation in haskell (with amortized O(1) complexity)?
04:04:29 * hackagebot webkitgtk3-javascriptcore 0.13.0.3 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.13.0.3 (HamishMackenzie)
04:04:31 * hackagebot webkit-javascriptcore 0.13.0.3 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkit-javascriptcore-0.13.0.3 (HamishMackenzie)
04:07:22 <hop__> I mean in the standard library
04:07:24 <bergmark> hop__: can you newtype a list for that?
04:07:40 <hop__> I want push/pop amortized complexity
04:07:49 <hop__> So, it needs two lists
04:08:02 <hop__> SO, I am wondering if this is already done :-)
04:09:29 * hackagebot gconf 0.13.0.1 - Binding to the GNOME configuration database system.  http://hackage.haskell.org/package/gconf-0.13.0.1 (HamishMackenzie)
04:09:31 * hackagebot svgcairo 0.13.0.1 - Binding to the libsvg-cairo library.  http://hackage.haskell.org/package/svgcairo-0.13.0.1 (HamishMackenzie)
04:10:03 <indiagreen> hop__: but lists have O(1) complexity for push and pop
04:10:18 <indiagreen> what am I misunderstanding
04:10:28 <mmmm> do you mean a queue?
04:11:18 <hop__> mmmm: Yes sorry for the confusion
04:11:49 <exio4> hop__, stack == list, but maybe you mean Data.Dequeue ?
04:12:19 <hop__> exio4: queue sorry again
04:12:51 <exio4> so yeah, Data.Dequeue
04:13:37 <hop__> exio4: thanks!
04:14:30 * hackagebot vtegtk3 0.13.0.1 - Binding to the VTE library.  http://hackage.haskell.org/package/vtegtk3-0.13.0.1 (HamishMackenzie)
04:14:51 <slomo> what's the difference between conduit and pipes? why would one choose one over the other? :)
04:19:30 * hackagebot vte 0.13.0.1 - Binding to the VTE library.  http://hackage.haskell.org/package/vte-0.13.0.1 (HamishMackenzie)
04:20:46 <SwashBuckla> I would love dependent types in Database creation. Right now, with MSSQL, I am struggling with creating a constraint on allowing at least one of two columns to be null, but not both (null) and not both (not null). I am not sure it's possible
04:24:30 * hackagebot hlint 1.9.14 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.14 (NeilMitchell)
04:25:44 <bitonic> slomo: I'd say you should choose depending on what you need to do.  if you want to do web stuff, for example, you should use conduit.  if you just want to learn about those streaming constructs, I'd learn pipes
04:27:41 <slomo> bitonic: why would conduit be better for web stuff, and pipes for learning (and what else?)? from a high level both look the same to me, just that there are different libraries available on top of both
04:29:51 <bitonic> slomo: it's better because of the ecosystem it has.  for a fair comparison, you can hear it from the horse's mouth: <https://www.youtube.com/watch?v=Qn2Oc4vWoGg&t=1m22s>
04:30:43 <bitonic> but all in all, they're pretty similar now.  pipes simplicity and documentation is unmatched, imho
04:30:51 <bitonic> so for learning I really enjoyed pipes
04:32:17 <slomo> bitonic: alright, thanks :) will watch that later. for my specific case i could use both, and both would be similarily simple to use
04:32:51 <bitonic> slomo: the first couple of minutes are enough to sort of answer your question, btw :P
04:38:30 <Myrl> @src (<+>)
04:38:30 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
04:38:37 <Myrl> lol
04:43:28 <SwashBuckla> wow
04:43:33 <SwashBuckla> lambdabot has sass
04:44:06 <Iceland_jack> SwashBuckla: On Christmas :) tsk
04:48:30 <basichash> WHY IS THIS CHANNEL SO LARGE?!?
04:48:52 <apo> Because otherwise it couldn't hold all these people
04:48:58 <MP2E> :D
04:49:31 * hackagebot js-jquery 1.11.2 - Obtain minified jQuery code  http://hackage.haskell.org/package/js-jquery-1.11.2 (NeilMitchell)
04:49:52 <basichash> its even bigger than #python
04:50:09 <exio4> all the cool people needed a large channel for them
04:52:21 <frase> hi all, how can I convert Int# -> Int ?
04:52:47 <Iceland_jack> frase: I#
04:53:32 <Iceland_jack> ghci> import GHC.Prim
04:53:32 <Iceland_jack> ghci> :t I#
04:53:32 <Iceland_jack> I# :: Int# -> Int
04:53:32 <Iceland_jack> ghci> I# 42#
04:53:35 <Iceland_jack> 42
04:54:01 <frase> hmm, my GHC.Prim does not seem to have I#
04:54:15 <Iceland_jack> GHC.Types*
04:54:30 <Iceland_jack> You also need to enable MagicHash
04:54:33 <frase> yes, thanks
04:54:34 <Iceland_jack>     ghci> :set -XMagicHash
04:54:42 <frase> already there... thanks Iceland_jack
04:55:05 <Iceland_jack> I enable so many things by default that my examples are often incomplete
04:55:36 <Iceland_jack> frase: One way to figure it out is by running ':info Int'
04:55:54 <Iceland_jack> On a fresh GHCi it should give you: data Int = GHC.Types.I# GHC.Prim.Int#
04:56:00 <frase> oh heck, yeah I never noticed that before
04:56:05 <frase> astonishing
04:56:29 <frase> anyhow, yay, now I can do log of big Integer efficiently :)
04:57:27 <Iceland_jack> If you're interested in more, check out the “Unboxed Values as First Class Citizens” paper
04:57:31 <Iceland_jack> http://research.microsoft.com/en-us/um/people/simonpj/Papers/papers.html
04:57:49 <frase> thanks Iceland_jack; really appreciate the pointers
04:58:01 <Iceland_jack> :-) np
04:58:22 <frase> I don't normally come into #haskell but #haskell.au and #bfpg are a bit quiet at 11pm/midnight on christmas eve :)
04:58:30 <Iceland_jack> A PDF version is avaiable here: http://citeseer.uark.edu:8080/citeseerx/viewdoc/summary?doi=10.1.1.50.231
05:04:32 * hackagebot ghcid 0.3.4 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.3.4 (NeilMitchell)
05:12:58 <basichash> does stripe use haskell?
05:37:57 <dredozubov> basichash: afaik it's not
05:39:07 <basichash> dredozubov: i heard it was
05:41:55 <dredozubov> basichash: https://stripe.com/jobs/positions/engineer/#consumer i don't see anything haskell-related :\ but i may be wrong, it's possible they simply doesn't mention it in great detail
05:43:26 <basichash> dredozubov: would it be difficult to do? or would there be any good rason to use haskell over something more conventional?
05:44:13 <dredozubov> not sure i understand your question
05:44:28 <dredozubov> > would it be difficult to do? -- to do what exactly?
05:44:30 <lambdabot>  <hint>:1:26: parse error on input ‘do’
05:44:33 * hackagebot data-interval 1.2.0 - Interval arithmetic for both open and closed intervals  http://hackage.haskell.org/package/data-interval-1.2.0 (MasahiroSakai)
05:46:57 <basichash> dredozubov: to use haskell in your stack
05:49:44 <dredozubov> it depends
05:50:06 <dredozubov> i use it
05:50:39 <dredozubov> if you're facing strong deadlines and not proficient with haskell, you may face a pain train
05:50:56 <dredozubov> if you're proficient - it's entirely different experience
05:51:10 <dredozubov> and of course it's task-related
05:51:19 <dredozubov> so, yeah - it depends
05:53:47 <mjboa> .quit
06:02:44 <basichash> dredozubov: i haven't really done functional programming before, so for me it's really quite a  strange experience
06:03:17 <basichash> dredozubov: but i've heard a lot of people talking about how its very effective (can't remember exactly why though)
06:06:47 <dredozubov> basichash: i've come from imperative/dynamic languages camp, so i can say it's like a cultural shift, but it's very pleasant and rewarding
06:07:35 <dredozubov> and i believe that learning haskell will make you better engineer generally
06:07:47 <dredozubov> a better engineer*
06:08:41 <basichash> dredozubov: yeah i've heard that
06:09:00 <basichash> dredozubov: would you say functional programming is more powerful than OO?
06:09:17 <srhb> basichash: Strictly speaking, that's a fact. But that's probably not what you meant. :-)
06:09:36 <dredozubov> yes, but i'd say it another way: haskell is better at handling complexity
06:11:42 <dredozubov> i was doing OO for years and have say it's all a big scam
06:12:14 <dredozubov> have to say*
06:12:34 <dredozubov> i'm dysgraphic today, sorry :\
06:12:50 <Skola> but.. Patterns
06:13:27 <rhaps0dy> dredozubov: ikr
06:14:22 <rhaps0dy> I still harbor some doubts about Haskell's ease of I/O
06:14:33 <rhaps0dy> but I'm fairly sure these will go away with a bit of practice
06:14:44 <srhb> rhaps0dy: They have for me at least. :)
06:16:07 <dredozubov> rhaps0dy: lazy IO is seriously messing with my brain, but i guess i'll get over it
06:16:33 <rhaps0dy> ^
06:17:20 <rhaps0dy> srhb, they probably will. Still, I have not tried anything more complicated than basic stdin/out i/o
06:17:29 <srhb> rhaps0dy: Right. :)
06:18:54 <dredozubov> And btw, now i mentally typecheck all the code i review(whatever the language is). Method returns false or some object.. <BEEP> it's wrong.
06:19:10 <athan> Hey folks... might anyone else have experienced this error? http://lpaste.net/117150 It's from compiling ghc-mod in a sandbox
06:19:34 * hackagebot base 4.7.0.2 - Basic libraries  http://hackage.haskell.org/package/base-4.7.0.2 (HerbertValerioRiedel)
06:19:46 <dredozubov> no clue, athan
06:20:07 <BoR0> I've written a commercial relatively simple web app that talks to a DB, does some JSON conversion, uses hamlet template files, etc. it seems to be working fine. how do I know if my code is fine and how can I improve its elegance (without showing any code that is)? are there any general rules to follow?
06:20:35 <BoR0> (it uses Yesod, HDBC)
06:20:46 <dredozubov> BoR0: there are whole books written to answer this question
06:20:55 <slomo> BoR0: hlint, and reading similar code that is publically available to learn
06:21:14 <BoR0> slomo, I already used hlint until it's out of suggestions
06:21:15 <athan> dredozubov: It looks like MonadBaseControl has an associated newtype...?
06:21:26 <wei2912> BoR0: test suites?
06:21:34 <dredozubov> hlint is a THE tool to use no matter what kind of app you write :)
06:21:34 <athan> called `StM`?
06:22:26 <athan> BoR0: That comes with more exposure, I think. There's no real definitive answer, other than keep your code under 80 columns wide :P
06:22:39 <BoR0> :)
06:22:50 <rhaps0dy> dredozubov, I think that is counterproducent
06:23:00 <dredozubov> athan: can't say, i haven't encounter this error before :|
06:23:00 <rhaps0dy> dynamic languages are meant to return different types
06:23:27 <rhaps0dy> adapting yourself somewhat to the language you're using tends to produce clearer code
06:23:28 <athan> dredozubov: yeah something fishy is going on: http://hackage.haskell.org/package/monad-control-1.0.0.1/docs/Control-Monad-Trans-Control.html
06:23:36 <athan> it's just an assoicated type :s
06:23:54 <athan> maybe there was an api change in monad-control that wasn't reflected in the bounds on ghc-mod
06:24:02 <BoR0> rhaps0dy, haskell shows that that's more error prone, and not that of a good idea as most have thought a couple of ages ago
06:24:29 <dredozubov> rhaps0dy: generally yes, but if your method is a predicate, it should return a boolean, no matter what "conditional evaluation" strategy your language use
06:24:34 <BoR0> that's why some libraries and tools for e.g. python are released, so that you can keep using the language but improve correctness
06:24:41 <dredozubov> it'll be easier to refactor
06:25:04 <rhaps0dy> dredozubov: oh, of course
06:25:22 <rhaps0dy> I do not advocate returning a lot of different things
06:25:39 <rhaps0dy> but sometimes returning either a list or a hashmap is fine
06:26:56 <rhaps0dy> BoR0: it is more error prone. However it is also less verbose and more direct, which, if you control the possible outputs, is better
06:27:24 <rhaps0dy> I would do it in Haskell by defining a new type that is any one of the ones I want to return, but some languages do not allow you to place this restriction.| Oh well.
06:27:31 <dredozubov> rhaps0dy: To use result of such method, next method in logic "chain" must use some kind of case statement/pattern matching on the input. I don't sure if it's such a convenient api strategy.
06:27:46 <dredozubov> Maybe we need some examples?
06:29:26 <rhaps0dy> In a webapp I'm developing in Python, functions return {}, [] or None
06:29:35 * hackagebot gimlh 0.1.1.0 - Haskell parser for GIML  http://hackage.haskell.org/package/gimlh-0.1.1.0 (gazay)
06:29:53 <srhb> rhaps0dy: :(
06:29:54 <rhaps0dy> and that result is converted to json, with None being {}
06:29:55 <dredozubov> rhaps0dy: and it all evaluates to false in conditional operator
06:29:58 <Peaker> rhaps0dy: the equivalent Haskell is returning the common part of the interface
06:30:07 <rhaps0dy> dredozubov: that's no good :(
06:30:10 <Peaker> (as a record)
06:30:11 <rhaps0dy> lisp does that better
06:30:14 <dredozubov> you must be using it with this semantic in mind
06:30:22 <rhaps0dy> yeah, that's a problem
06:30:29 <dredozubov> it's bad API-design in general IMO
06:30:40 <rhaps0dy> as I said, I would do it with a new type in haskell
06:30:43 <rhaps0dy> dredozubov, how so?
06:30:53 <rhaps0dy> it's very convenient, and {} [] is what can be converted to JSON
06:30:59 <rhaps0dy> and if it doesn't return anything, it's just a {} too
06:31:50 <dredozubov> so maybe you should mentally evaluate output type as "JSON a", not a "List or Dict or something else"?
06:32:05 <dredozubov> if it's "JSON a", it may be correct
06:32:07 <rhaps0dy> yes.
06:32:11 <rhaps0dy> That's what I said
06:32:23 <dredozubov> ok, that's cool
06:32:29 <rhaps0dy> and JSON would be definied as either a dict, a list, or a None
06:32:53 <rhaps0dy> >I would do it in Haskell by defining a new type that is any one of the ones I want to return, but some
06:32:59 <dredozubov> it's good to have something more explicit and restrictive for this kinda things though
06:33:01 <rhaps0dy> languages do not allow that.
06:33:08 <rhaps0dy> yeah
06:33:19 <rhaps0dy> one other issue I'm worried about is the density of haskell
06:33:22 <Chathurga> It translate None to {}?
06:33:27 <rhaps0dy> each line contains a lot of information
06:33:33 <athan> I think haskell is going places
06:33:34 <rhaps0dy> that might prove to be a good thing though.
06:33:38 <rhaps0dy> Chathurga: yes.
06:33:39 <dredozubov> i'm not sure if None is a valid JSON value :)
06:33:40 <athan> It's nowhere near deprecation
06:33:40 <Chathurga> Am I mad or is that mad
06:33:49 <rhaps0dy> this way you can skip return {}
06:33:55 <Chathurga> Is null part of the JSON standard?
06:34:01 <rhaps0dy> athan, nobody said that
06:34:09 <rhaps0dy> Chathurga: yes, but not in a top level expression afaik
06:34:13 <athan> oh, derp, jumped the gun
06:34:14 <rhaps0dy> I'm not sure if yo ucan return just "nul"
06:34:21 * athan is too defensive :c
06:34:23 <rhaps0dy> but you can definitely return {"something": null}
06:34:28 <dredozubov> Chathurga: nope, only Object and Array can be serialized
06:34:30 <rhaps0dy> athan: lol
06:34:39 <Chathurga> Ah yes yes, sorry, I thought it was doing it in the general case
06:34:54 <rhaps0dy> I think it's a very sensible API.
06:34:58 <rhaps0dy> Time might prove me wrong though :P
06:35:21 <brainacid> good morning
06:35:27 <rhaps0dy> good morning.
06:35:32 <brainacid> went to bed at 3am studying haskell
06:35:38 <brainacid> i like it a lot
06:35:38 <dredozubov> > but you can definitely return {"something": null} -- <BEEP>
06:35:39 <lambdabot>  <hint>:1:32: parse error on input ‘"’
06:35:47 <brainacid> hi rhaps0dy
06:35:55 <rhaps0dy> next time you should goto sleep and study it in the morning, but I sometimes find it hard to do too
06:35:58 <rhaps0dy> lol
06:35:59 <Narfinger> hey, i seem to have some major problems understanding io in haskell: assume i have some "function" which has return type IO String, now I want to do a bunch of functions on this to transform it and one of these calls this, do I need to have the IO type now everywhere?
06:36:10 <dfeuer> Good moaning!
06:36:22 <dfeuer> Or good mourning?
06:36:26 <brainacid> hi dfeuer
06:36:27 <Peaker> Narfinger: if you functions operate on a pure string, then no, their signature will be something like: String -> Foo, Foo -> Bar
06:36:40 <Peaker> Narfinger: if you functions operate on the action that generates a string then they may look like (IO String -> ..)
06:36:41 <brainacid> man i havent been able to stop learning about programming
06:36:50 <brainacid> started with assembly and C
06:36:55 <dredozubov> Narfinger: you can't escape IO monad, so either you should use IO everywhere(it's bad) or you should write pure(w/o IO) functions, then lift them in IO
06:37:11 <dfeuer> brainacid, you started with assembly? o.O
06:37:13 <brainacid> once I understood the machine somehow or other I ended up learning Haskell
06:37:27 <brainacid> dfeuer, I began with a desire for reverse engineering
06:37:33 <dredozubov> dfeuer: i believe that's called a low start
06:37:33 <Narfinger> wait, let me make this clear i have foo which has type IO String and i have bar, bar now wants to call the string and do some transformation on it
06:37:34 <dfeuer> Jeepers.
06:37:41 <brainacid> yeah and I got tht
06:37:58 <Narfinger> should i now pull out the call to foo as close to the main as i can and have the rest be functions?
06:38:04 <dfeuer> Narfinger, you don't call a string. What do you mean?
06:38:13 <brainacid> now I run xmonad and cant stop thinking of functions and types ;)
06:38:22 <Narfinger> sorry call foo i mean, to get the string
06:38:23 <benzrf> woot
06:38:25 <dredozubov> Narfinger: you can use 'bar :: String -> String' and lift it with applicative either monad liftM
06:38:37 * brainacid gets coffee
06:38:56 <dredozubov> s/either/or/
06:38:57 <zwer_n> marfi what is the type of bar
06:39:08 <zwer_n> Narfinger*
06:39:32 <Nimatek> Does anyone know why GLFW.swapBuffers would segfault?
06:39:56 <Narfinger> i am basically just writing bar and at the moment i had it as another String
06:40:08 <Narfinger> mhhh but i think i feel now where the problem is
06:41:34 <Narfinger> i should basically try to write my transformations as String->String and call the IO String stuff only when i need it
06:41:52 <rhaps0dy> Nimatek: a bug maybe?
06:42:13 <rhaps0dy> Nimatek: in the library
06:44:10 <dredozubov> Narfinger: yes, you're right
06:44:18 <rhaps0dy> well, bye guys
06:44:19 <rhaps0dy> later
06:44:19 <Peaker> Nimatek: try gdb to see where it crashes? compile with -debug
06:44:30 <kl> Are thrown exceptions a side-effect?
06:44:35 * hackagebot wai-hmac-auth 1.0.0 - hmac authentication tools for WAI apps  http://hackage.haskell.org/package/wai-hmac-auth-1.0.0 (raptros)
06:44:40 <Narfinger> mhhh thanks, i think i need to think about how to do that all
06:46:07 <McManiaC> can someone give me a quick example use for mfix? i use fix regularely (typically "fix $ \loop -> do ...; loop"), but have no clue what mfix would be useful/used for
06:46:09 <brainacid> by rhaps0dy
06:47:15 <dredozubov> Narfinger: http://lpaste.net/117156 see this
06:47:28 <dredozubov> i hope it will make sense for you :)
06:47:41 <kl> Quick opinion? Are exceptions considered a side-effect?
06:48:09 <Taneb> kl, I... don't think so?
06:48:14 <Taneb> They are ugly, though
06:49:21 <Narfinger> dredozubov: sorry, i don't quite understand your example
06:49:36 * hackagebot indices 1.6.1 - Static indices  http://hackage.haskell.org/package/indices-1.6.1 (MikeLedger)
06:49:36 <dredozubov> Narfinger: ok, let's break it up
06:49:44 <Narfinger> ih wait
06:50:00 <Narfinger> you just use normal functions on an IO UTCTime type?
06:50:26 <dredozubov> yes, you can lift normal functions into monad(IO in this case) using fmap or liftM
06:50:38 <Narfinger> oh the fmap does the lifting? ah ok
06:50:38 <dredozubov> @t show
06:50:38 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
06:50:59 <dredozubov> :t show
06:50:59 <dredozubov> show :: Show a => a -> String
06:51:00 <lambdabot> Show a => a -> String
06:51:09 <dredozubov> ah, okay
06:51:34 <dredozubov> so yeah, you have something that is pure and it's type signature is "a -> String"
06:51:55 <dredozubov> you can use it on "IO a" if you lift it into monad
06:52:06 <Narfinger> ah ok
06:52:12 <dredozubov> :t fmap show
06:52:13 <lambdabot> (Show a, Functor f) => f a -> f String
06:52:49 <brainacid> hey im still not getting this
06:52:49 <brainacid> http://lpaste.net/117137
06:53:11 <dredozubov> Narfinger: so you don't have to plague all your logic with IO and should expose it to IO to a bare minimum
06:53:20 <brainacid> could anyone just ask me to see if my thinking is correct, i dont want the answer directly
06:53:23 <Narfinger> ok thanks, i think i understand at least this part
06:54:11 <lpaste> brainacid revised “lastButOne”: “learningLists” at http://lpaste.net/117137
06:54:18 <Narfinger> but i still need to think a bit on my own how to solve my problem :)
06:54:46 <dredozubov> Narfinger: give it some time
06:54:58 <dredozubov> it'll become simple :)
06:56:39 <dredozubov> brainacid: the most simple way to do it is: lastButOne = reverse . tail . reverse
06:57:25 <dredozubov> i believe it can be rewritten as: lastButOne xs = reverse (tail (reverse xs))
06:57:41 <Peaker> Narfinger: http://lpaste.net/117159 A function lifter table
06:58:30 <Russel-Athletic> thanks, i will look at it
06:58:34 <Peaker> Narfinger: you can take various kinds of functions and apply them on "actions" or "monadic values" in various ways, via the various functions in the table
06:58:53 <Peaker> Narfinger: so you use these lifters to apply your pure functions on the IO stuff you have at hand
06:58:55 <Russel-Athletic> btw. irc kicked me and my client switched to this nick
06:59:43 <Russel-Athletic> but thanks for all the help!
07:01:12 <brainacid> dredozubov, thanks le me see
07:14:37 * hackagebot hydrogen-prelude 0.10 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.10 (JulianFleischer)
07:16:18 <exio4> > let x = I# (error "2") in 42
07:16:19 <lambdabot>  Not in scope: data constructor ‘I#’
07:16:20 <lambdabot>  Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
07:21:36 <lpaste> brainacid revised “lastButOne”: “No title” at http://lpaste.net/117137
07:21:48 <brainacid> man why am i not understanding
07:21:54 <brainacid> "(
07:22:37 <exio4> "let x = I# (error "2") in 42" typechecked and ran over here, but "let x = I# undefined in 42" didn't, where is the difference and why is the first even working?
07:23:42 <dredozubov> brainacid: why do you need a clause with 'length xs < 3'?
07:26:05 <dredozubov> @let lastButOne xs = (reverse (tail (reverse xs)))
07:26:07 <lambdabot>  Defined.
07:26:21 <dredozubov> @run lastButOne [1..10]
07:26:23 <lambdabot>  [1,2,3,4,5,6,7,8,9]
07:26:27 <dredozubov> seems legit
07:27:06 <joe9> Is there a way to get the TimeZone for a different timezone and not my local timezone?
07:27:13 <brainacid> dredozubov, if the list is less than 3 elem then retunr the list
07:27:24 <brainacid> dredozubov, why is this incorrect? head (tail (reverse lst))
07:27:38 <wei2912> dredozubov: there's `init` for that
07:27:43 <wei2912> > init [1..10]
07:27:45 <lambdabot>  [1,2,3,4,5,6,7,8,9]
07:27:47 <joe9> localTimeToUTC :: TimeZone -> LocalTime -> UTCTime -- I want to use this function and know the LocalTime. But, I do not know the TimeZone for EST.
07:27:54 <exio4> he is trying to implement it, I think
07:28:02 <wei2912> i seee
07:28:08 <dredozubov> wei2912: thanks, i know, brainacid is learning it
07:28:09 <brainacid> dredozubov, wei2912 I would like to return [1,2,3] -> [2]
07:28:16 <joe9> wei2912: also check out Safe.
07:28:25 <dredozubov> brainacid: let's reuse our lastButOne then?
07:28:29 <brainacid> [1,2,3,4] -> [3]
07:28:35 <kadoban> brainacid: Look at the types of each of your clauses in isolation. They're not the same, hence the error.
07:28:40 <wei2912> joe9: what's the context?
07:28:40 <brainacid> the first you gave me works
07:28:54 <brainacid> lstBt1 = head . tail . reverse
07:29:05 <joe9> wei2912: was meant for brainacid, sorry. seeing all the usage of head and tail.
07:29:08 <dredozubov> brainacid: you're doing head (tail (reverse xs)) in your last paste
07:29:12 <dredozubov> it's clearly wrong
07:29:23 <kadoban> brainacid: IOW, what's the type of 'f xs = xs'  ?   What's the type of 'f xs = head (tail (reverse xs))' ?
07:29:24 <dredozubov> you're returning one element instead of list of elements
07:29:38 * hackagebot regular 0.3.4.4 - Generic programming library for regular datatypes.  http://hackage.haskell.org/package/regular-0.3.4.4 (JosePedroMagalhaes)
07:30:26 <brainacid> kadoban, the type signature of function f with argument xs f :: [a] -> [a] ??
07:30:55 <kadoban> brainacid: Correct, the first one is that type. And the second?
07:31:18 <zwer_n_f> brainacid do you want  [1,2,3] -> [2]  or  [1,2,3] -> 2?
07:32:09 <brainacid> zwer_n_f, good question, the exercise ... umm... i see
07:32:17 <brainacid> head :: [a] -> a
07:32:27 <brainacid> tail "" [a] -> [a]
07:32:56 <brainacid> :t last
07:32:57 <lambdabot> [a] -> a
07:33:43 <brainacid> im just learning how to manipulate list following RealWord Haskell Oreilly and damn...such a simple thing blows me away...all because my types are wrong correct?
07:34:34 <kadoban> brainacid: Well, your types are inconsistent, which doesn't really work in haskell. So you just have to pick one...do you want it to result in an [a] or an a ? Then make both clauses match that.
07:34:45 <dredozubov> your types are wrong because your code is wrong logically
07:34:58 <dredozubov> so it doesn't typecheck
07:35:16 <brainacid> im reading your reponses and I nod but I must not get it yet :(
07:35:21 <brainacid> the types are different
07:35:30 <brainacid> so it wont work
07:35:31 <kadoban> brainacid: By the way, you'll usually get better error messages if you specify explicitly what you want the type to be, to begin with. Then it can say "this part *right here* doesn't make sense" instead of that rather cryptic error it's giving you.
07:35:53 <dredozubov> you have two clauses in your last paste: one is [a] -> [a] and the other is [a] -> a
07:35:58 <brainacid> i see kadoban so type signature
07:36:04 <kadoban> brainacid: Yep.
07:36:05 <dredozubov> they should be identical for your function to work
07:36:15 <brainacid> im sorry im a bit messy
07:36:22 <brainacid> im just starting to program
07:36:24 <dredozubov> don't sweat it
07:36:32 <brainacid> there is still a lot for me to learn
07:36:44 <dredozubov> try it with explicit type signature
07:44:38 * hackagebot hydrogen-parsing 0.10 - Hydrogen Parsing Utilities  http://hackage.haskell.org/package/hydrogen-parsing-0.10 (JulianFleischer)
07:45:34 <ezrios> I have a record type with quite a few fields that instances Show
07:45:45 <brainacid> nope :(
07:45:47 <ezrios> however its textual representation is quite different from the fields it contains
07:45:50 <asthasr> Quick question -- for those of you who are so lame as to be thinking about haskell on christmas eve like me :p
07:45:59 <ezrios> how can I take a look at the fields inside the record in GHCi?
07:46:14 <indiagreen_> asthasr: also for those who don't even celebrate Christmas
07:46:23 <indiagreen_> ask away
07:46:32 <asthasr> I'm doing some problems on hackerrank and used this list comprehension to generate a list of pairs -- [(x, y) | x <- ps, y <- ps, (pid x) < (pid y)]
07:46:41 <asthasr> now, however, I'm trying to convert from using lists to using vectors, for speed
07:47:02 <asthasr> what is the most idiomatic way of writing this without using list comprehensions
07:47:09 <indiagreen> have you tried changing your algorithm first
07:47:25 <dredozubov> ezrios: you can access fields with a getter function, these have the same name as the field
07:47:27 <indiagreen> i.e. if you don't need some particular ordering of list pairs
07:47:46 <indiagreen> you can speed it up quite a bit by sorting the list
07:47:51 <dredozubov> let's suppose you have 'data A { foo :: String, bar :: String }'
07:47:59 <asthasr> This isn't about ordering, it's more about generating unique lists -- so, (1, 2) occurs once, (2, 1) never occurs, (1, 1) never occurs, built from the same list [1, 2, 3, 4, 5]
07:48:15 <brainacid> still dont understand why lastButOne = head . tail . reverse  evaluates and i guess i dont understand conditionals
07:48:17 <dredozubov> i mean 'data A  = A { foo :: String, bar :: String }'
07:48:41 <dredozubov> @let a = A { foo = "first", bar = "last" }
07:48:41 <lambdabot>  .L.hs:176:5: Not in scope: data constructor ‘A’
07:48:42 <lambdabot>  
07:48:42 <lambdabot>  .L.hs:176:7: ‘foo’ is not a (visible) constructor field name
07:48:43 <brainacid> i just want the function to check if the list is less than 3 if it is then return the entire list
07:49:02 <dredozubov> ok, whatever
07:49:10 <dredozubov> let a = A { foo = "first", bar = "last" }
07:49:12 <asthasr> brainacid: That type of point free syntax is basically creating a 'partial application' of the functions -- then you can use that partial application as a function in itself
07:49:24 <dredozubov> you can access for and bar with 'foo a' and 'bar a'
07:49:36 <dredozubov> you can use let binding to address them
07:49:37 <zwer> brainacid and if the length is 3 or more?
07:49:38 * hackagebot blaze-markup 0.6.2.0 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.6.2.0 (JasperVanDerJeugt)
07:49:39 <dredozubov> have fun
07:49:44 <brainacid> asthasr, so that is beyond my scope lol
07:50:02 <brainacid> zwer, then return the elem before last
07:50:22 <brainacid> like lastButOne [1,2] -> [1,2]
07:50:24 <asthasr> indiagreen: also, I am trying to use Vector because my understanding is that in production code Vector is almost always preferred to lists :)
07:50:37 <brainacid> like lastButOne [1,2,3] -> 2
07:50:42 <brainacid> like lastButOne [1,2,3, 4] -> 3
07:51:01 <zwer> brainacid again, types don't match. you have to decide if you want to return [a] or a
07:51:02 <brainacid> sorry to bother yall with such simple stuff
07:51:20 <brainacid> i see
07:51:26 <zwer> you can have  [1,2,3] -> [2]   [1,2,3, 4] -> [3]  though
07:51:43 <brainacid> zwer, ! so in my conditional my branches must evaluate to the same type
07:51:51 <zwer> yes
07:51:54 <brainacid> i see
07:51:55 <dredozubov> asthasr: if you have to use indexes then yes
07:52:10 <brainacid> so using head is not the right function
07:52:22 <brainacid> since it returns a not [a]
07:52:37 <dredozubov> brainacid: it's not what you're trying to accomplish anyway
07:52:39 <brainacid> or I have to rewrite my conditional
07:52:45 <dredozubov> yes
07:52:51 <zwer> [head xs] will type match
07:53:09 <indiagreen> asthasr: the trouble is that in this case you'll be forced to resort to explicit loops to get at least the same performance out of vector
07:53:25 <indiagreen> you're going over lists sequentially
07:53:25 <brainacid> zwer, huh
07:53:31 <indiagreen> it should fuse nicely
07:53:40 <brainacid> zwer, interesting
07:53:46 <zwer> > [head [1,2,3]]
07:53:47 <lambdabot>  [1]
07:53:48 <brainacid> i cant wait to understand this stuff
07:54:50 <brainacid> *Main> lastButOne [1,2,3,4]
07:54:50 <brainacid> [3]
07:54:50 <brainacid> *Main> lastButOne' [1,2,3,4]
07:54:50 <brainacid> 3
07:55:06 <brainacid> partial application lastButOne'
07:55:14 <brainacid> thanks for all the help
07:55:37 <brainacid> so by putting the evaluation of a function inside a list will return a list
07:55:49 <brainacid> head xs = a
07:56:06 <brainacid> [head xs] = [a]
07:57:01 <ToTheInternet> I have 5 modules, all in the same directory. When i want to compile my main module in Eclipse, it can't find the other modules. What could be the problem here? Is this a common problem in eclipse?
07:58:54 <asthasr> indiagreen: Makes sense.
07:59:34 <endiruna> why are the binaries created by haskell big?  a simple program that gets a line and prints one is about 1.2M and if i run strip on it is about 800K. the same program written in c is about 8K. why is it?
08:00:02 <exio4> endiruna, the runtime and libraries are in the binary
08:00:23 <JonReed> Hi guys! I have a programmer's block when I try to work with the state monad. Can anybody give me the simplest example of function that uses a state. E.g. "sPutStr :: String -> State String ()", which just concatenates the state string with the supplied string and returns nothing?
08:01:19 <JonReed> I try "sPutStr str = \x -> ( (), s ++ str )" but that does not work for some reason
08:01:24 <brainacid> endiruna, Haskell is not about machine performance
08:01:38 <brainacid> endiruna, Im coming from Assembly
08:03:44 <ChristianS> endiruna: ghc compiles a lot of library into a haskell binary, even if they aren't strictly needed
08:03:54 <zwer> sPutStr x = do state <- get; put (state ++ x); return ()
08:04:47 <zwer> > let sPutStr x = do state <- get; put (state ++ x); return () in execState (sPutStr "hello" >> sPutStr " there") ""
08:04:48 <lambdabot>  "hello there"
08:05:55 <JonReed> Oh. The "State" was renamed
08:06:11 <dredozubov> JonReed: eh?
08:06:13 <JonReed> In learn you a haskell there is "State" with the capital letter
08:06:20 <JonReed> E.g. pop = State $ \(x:xs) -> (x,xs)
08:06:26 <zwer> state in my code is just a variable name
08:06:26 <JonReed> But one needs to do "state"
08:06:28 <JonReed> Now It works
08:06:33 <JonReed> Thx
08:06:43 <dredozubov> wait wha---
08:06:44 <zwer> you could name it anything else
08:07:10 <JonReed> http://learnyouahaskell.com/for-a-few-monads-more  There is an example of a state
08:07:48 <zwer> > let sPutStr x = do cow <- get; put (cow ++ x); return () in execState (sPutStr "hello" >> sPutStr " there") ""
08:07:49 <lambdabot>  "hello there"
08:10:18 <athan> Isn't this what `liftM` is for? `foo <- lift fooM; let bar = someFunc foo` ==> `bar <- liftM someFunc fooM`?
08:11:09 <Peaker> athan: "liftM" and "lift" are not that similar
08:11:12 <Peaker> @type lift
08:11:13 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
08:11:14 <Peaker> @type liftM
08:11:15 <athan> ahh shoot
08:11:15 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
08:11:28 <athan> oh woah
08:11:29 <JonReed> let sPutStr str = state $ \s -> (5, s ++ str); execState (sPutStr " world") "hello"
08:11:31 <exio4> liftM is just fmap but with monads
08:11:33 <Peaker> lift is for translating a monad action from the inner monad to the outer monad
08:11:37 <Peaker> liftM=fmap
08:11:43 <athan> okay, my mistake
08:11:43 <Peaker> (well, after the AMP proposal)
08:11:46 <JonReed> > let sPutStr str = state $ \s -> (5, s ++ str); execState (sPutStr " world") "hello"
08:11:47 <lambdabot>  <hint>:1:84:
08:11:47 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:12:16 <Peaker> athan: but: `foo <- lift fooM; let bar = someFunc foo` --> `bar <- someFunc <$> lift fooM`
08:12:42 <athan> Peaker: Oh woah! okay, that makes sense!
08:12:42 <Peaker> > let sPutStr str = state $ \s -> (5, s ++ str)in execState (sPutStr " world") "hello"
08:12:44 <lambdabot>  "hello world"
08:12:55 <athan> hmm
08:13:02 <Peaker> JonReed: ^^
08:13:10 <athan> so liftM is fmap for nested monads?
08:13:15 <athan> like liftA?
08:13:18 <Peaker> athan: no no, liftM is just fmap
08:13:21 <athan> :t liftM2
08:13:22 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:13:28 <athan> ahh shoot
08:13:29 <Peaker> athan: it was separate from fmap because of the fact Monad doesn't subclass Functor
08:13:37 <athan> ahhh
08:13:41 <athan> that makes sense
08:13:42 <zwer> liftM is just like fmap except with a Monad constraint. in a perfect world we would only have fmap
08:13:43 <Peaker> athan: but now that Monad subclasses Applicative and Functor, liftM will literally be equal fmap
08:13:45 <athan> shame for the similar name
08:14:15 <Peaker> athan: fmap :: Functor m => ...  liftM :: Monad m => ...   (before the recent Applicative->Monad change)
08:14:36 <Peaker> @type liftA
08:14:37 <exio4> liftM is still useful for implement fmap using the monad instance
08:14:37 <lambdabot> Applicative f => (a -> b) -> f a -> f b
08:14:43 <Peaker> liftA is silly!
08:14:47 <Peaker> I don't know why it exists
08:15:19 <athan> @type liftA2
08:15:20 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
08:15:38 <Peaker> exio4: it should be named "monadFMap" or such. people actually use "liftM" and those that use it need to only have a Functor constraint
08:15:53 <Peaker> athan: liftA2 f x y = f <$> x <*> y
08:16:10 <Peaker> and (<*>) = liftA2 ($)
08:16:11 <nkar> edwardk: any particular reason why there's no 'singleton' in data.list.nonempty?
08:19:41 <athan> Peaker: Your solution `bar <- someFunc <$> lift fooM` would only work if AMP was in effect too, huh :s
08:20:59 <Peaker> athan: yep
08:21:05 <Peaker> athan: OR it's a concrete monad type
08:21:12 <Peaker> athan: which is also an instance of Functor
08:21:17 <Peaker> athan: OR I have all the constraints in scope
08:21:23 <exio4> most non-evil monad instances have applicative instances right now, though
08:21:35 <athan> Peaker: Perfect, thank you :)
08:21:45 <athan> ghc 7.10 is scheduled for February, right?
08:21:50 <lf94_-_-> Are there any libraries in haskell specifically tailored to manipulating bits, and is easy to use in ghci?
08:22:01 <lf94_-_-> Data.Bits does every but has some annoying usage
08:22:04 <lf94_-_-> everything
08:22:11 <lf94_-_-> Such as bitwise AND
08:22:27 <lf94_-_-> To do bitwise AND you need to type .&. all the time.
08:28:39 <joe9> need some ideas on how to compose these functions: f :: IO (Maybe FilePath) , getModificationTime :: FilePath -> IO UTCTime, I want the resulting function with :: IO (Maybe UTCTime)
08:31:59 <recursion-ninja> Hey guys, I wroe an algorithm I thought was very lazy, but it appears not to be. I suspect that all nodes are being generated instead of exiting early when a correct solution is found. here's the code, do you guys see a problem with it? Is there a way I could increase the laziness?
08:32:20 <recursion-ninja> http://lpaste.net/117165
08:32:22 <exio4> :t (\a f -> a >>= fmap f)
08:32:23 <lambdabot> (Functor m, Monad m) => m (m a) -> (a -> b) -> m b
08:35:48 <joe9> exio4: I do not know if it works with different m's: http://codepad.org/J3uzgWXD
08:37:04 <joe9> (Functor t, Monad m) => m (t a) -> (a -> m b) -> m (t b)
08:37:11 <joe9> is what I want, I think
08:37:12 <recursion-ninja> :t \a f -> a >=> fmap f
08:37:13 <lambdabot> (Functor m, Monad m) => (a -> m (m a1)) -> (a1 -> c) -> a -> m c
08:37:29 <exio4> joe9, sorry, I wasn't trying to solve your code, but something else over here
08:37:45 <joe9> exio4: oh, ok. sorry for the bother.
08:37:52 <recursion-ninja> :t sequence
08:37:53 <lambdabot> Monad m => [m a] -> m [a]
08:37:57 <recursion-ninja> :t sequenceA
08:37:58 <lambdabot>     Not in scope: ‘sequenceA’
08:37:58 <lambdabot>     Perhaps you meant one of these:
08:37:58 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
08:38:02 <recursion-ninja> :t T.sequenceA
08:38:03 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
08:38:07 <exio4> nah, I made it look like so
08:38:15 <exio4> should be using a query with lambdabot
08:39:45 <exio4> just checking, is a function like that, even possible?
08:42:39 <joe9> recursion-ninja: thanks.
08:46:29 <recursion-ninja> joe9: Did I help?
08:49:06 <joe9> recursion-ninja: yes. :t sequence . fmap getModificationTime =<< (f :: IO (Maybe FilePath))
08:49:16 <joe9> :t sequence . fmap getModificationTime =<< (f :: IO (Maybe FilePath))
08:49:17 <lambdabot> Not in scope: ‘getModificationTime’
08:54:41 <exceltior> hi guys...
08:55:02 <Darwin226> Hey guys, can someone tell me why I'm getting a parse error here? https://gist.github.com/dfc33a97b4f9578f7e09 parse error on input '->' on line 11
08:59:00 <athan> Darwin226: I think you need to wrap the pattern match in brackets
08:59:09 <athan> (AST.Assignment s e) -> ...
08:59:30 <athan> I could totally be mistaken, though
08:59:38 <chpatrick1> Darwin226: you need to move it to the right of the = after the let
09:01:08 <Darwin226> chpatrick1: That worked! Thanks!
09:27:01 <jdiez> I'm pretty sure this case statement can be rewritten as a monadic chain. https://github.com/jdiez17/HaskellHawk/blob/master/Bot/Database.hs#L25-L29
09:27:12 <jdiez> but I'm not sure how to go about it. any help?
09:27:38 <SrPx> Does anyone know why I'm getting this error? http://lpaste.net/117167
09:28:17 <jdiez> SrPx: you're importing Vec as Vec
09:28:23 <jdiez> which is the same as `import qualified Vec`
09:28:37 <SrPx> jdiez: okay my bad, thanks
09:28:51 <SrPx> I thought qualified required the "as"
09:28:53 <jdiez> SrPx: and function application has higher precedence than multiplication
09:29:12 <SrPx> okay I removed the parenthesis...
09:29:17 <SrPx> but what about the type error?
09:29:23 <jdiez> I see no type error
09:29:29 <jdiez> oh
09:29:31 <jdiez> there we go
09:29:36 <jdiez> hmm, let's see...
09:30:26 <SrPx> it is on the "foo" function. It works without the "runST" part
09:30:41 <jdiez> :t runST
09:30:42 <lambdabot> (forall s. ST s a) -> a
09:30:44 <SrPx> but changing the type signature as to remove the last "m" from "→ m a", and adding runST, makes it not work
09:31:06 <SrPx> okay, so the point is that runST is only for ST and my "m" is generic?
09:31:17 <jdiez> so I'm guessing PrimState m is a ST <something> m
09:32:27 <cwraith> jdiez: you could refactor that with MaybeT
09:32:40 <SrPx> jdiez: hm I think so?
09:33:17 <c_wraith> jdiez: oh, maybe not.  It's like m Either -> m Maybe
09:33:50 <jdiez> c_wraith: yeah, exactly
09:34:02 <jdiez> two eithers into a maybe
09:34:37 <c_wraith> jdiez: ok.  you could do it with hushT from errors and EitherT from either
09:35:00 <tsani> Any advice or guides on using Conduit in a multithreaded application?
09:35:11 <jdiez> c_wraith: sounds a lot more verbose and contrived than it's worth, no?
09:35:17 <jdiez> s/verbose/terse/
09:35:46 <SrPx> nobody? :(
09:36:09 <c_wraith> jdiez: it would work, but it might be a bit.. dependency-heavy.
09:38:01 <SrPx> "Expected type: Matrix v (PrimState (ST s1)) a" - "Actual type: Matrix v (PrimState (ST s)) a" that is not informative at all
09:38:17 <rhaps0dy> lol
09:38:19 <rhaps0dy> thanks ghc
09:38:55 <k00mi> jdiez: how about: return $ case eitherComp of Right (Right a) -> Just a; _ -> Nothing
09:38:56 <glguy> It tells you that the s1 and s didn't mtch
09:39:47 <glguy> so... figure out what you're doing that caused them to not match or paste the big of code that isn't working and ask for help
09:40:01 <jdiez> SrPx: try explicitly declaring the type variables with forall
09:40:10 <SrPx> I have no idea what to do, sorry...
09:40:40 <jdiez> SrPx: that's okay, don't worry
09:40:47 <c_wraith> SrPx: my guess is that you want ScopedTypeVariables
09:40:57 <c_wraith> SrPx: that's usually what that error message means
09:41:03 <SrPx> jdiez: same
09:41:03 <jdiez> SrPx: first you need to add the {-# LANGUAGE RankNTypes #-} pragma to the top of your code
09:41:39 <jdiez> and then add "forall m." to the beginning of your type signature
09:41:49 <jdiez> or whatever type variable is giving you trouble
09:41:51 <SrPx> {-# LANGUAGE RankNTypes, ScopedTypeVariables, ExistentialQuantification #-} ? Same error
09:42:06 <jdiez> SrPx: you need to add the forall to the type signature though
09:42:11 <SrPx> foo :: forall v s a . Matrix v (PrimState (ST s)) a -> (Int, Int) -> a
09:46:25 <SrPx> I really can't get it... for me it is just saying: "can't match the type FOO BAR with your signature FOO BAR". But it is the same!!
09:46:48 <c_wraith> SrPx: s and s1 are not the same
09:47:20 <SrPx> they are not the same, sure, but reading http://lpaste.net/117170 it says: "where s1 is the type expected and s is your type". It doesn't say anything for me? It is just a variable
09:48:15 <c_wraith> SrPx: it's not *just* a variable.  It's a type variable defined in another context, such that it's required to be the *same* type variable in each context.  It's like saying a -> a is the same type as a -> b, because a and b are just type variables
09:48:59 <arjanb> sometimes it helps to replace $ by parentheses when dealing with existentials
09:49:27 <c_wraith> Pattern matching sometimes has surprising results when dealing with polymorphic types, too
09:52:45 <SrPx> well, without runST, this works: foo :: (GMV.MVector v a) => Matrix v (PrimState (ST s)) a -> (Int, Int) -> ST s a; foo mat (x, y) = get (Vec x y 0) mat; .... so, runST has the type
09:52:46 <SrPx> :t runST
09:52:47 <lambdabot> (forall s. ST s a) -> a
09:53:08 <SrPx> well, the return type of "foo" is exactly ST s a... so...
09:53:46 <SrPx> I don't understand why adding "runST" to the beginning of the function, and changing the signature to `foo :: (GMV.MVector v a) => Matrix v (PrimState (ST s)) a -> (Int, Int) -> a` shouldn't work
09:54:03 <SrPx> sorry that is as far as I get, I guess I will ask on SO
09:57:04 <SrPx> what does: "Could not deduce (a ~ ST s a)" mean? What is the "~" there?
09:57:24 <c_wraith> SrPx: ~ is type equality
09:57:36 <SrPx> thanks!
09:59:04 <Mark-dls> Hello John
09:59:31 <SrPx> It is like I need to somehow get the "s" from inside the "forall" on runST on my type signature?
09:59:32 <John3784> Hello Mark
09:59:49 <c_wraith> SrPx: yes, exactly.  the polymorphism must be preserved
10:00:09 <c_wraith> SrPx: runST's type is the way it is to guarantee that the "s" type cannot leak
10:00:19 <NightRa> What's the function for doing >>= k times?
10:00:29 <Procian> NightRa: replicateM ?
10:00:34 <SrPx> so I can't type my function at all
10:00:58 <det> Is there much utility in the fine grained dependencies of fundeps, ie, instead of writing "class Mult a b c | a b -> c where" you might write "class Mult a b -> c where", IOW, would you lose much power by forcing all dependent types of a type class to depend on all parameters ?
10:01:14 <NightRa> (a -> m a) -> Int -> m a
10:01:53 <NightRa> err, a -> (a -> m a) -> Int -> m a
10:02:26 <Procian> NightRa: Oh. Yeah, it's useful.
10:02:39 <c_wraith> SrPx: well, if you're trying to subvert runST to make it unsafe, then... yes.  that's the point.
10:02:54 <Procian> NightRa: But I don't think it's in the standard library.
10:04:15 <SrPx> I'm what? Well it is just that the library I am using needs a function from (Int,Int) → Color to draw a image. I have stored colors in a mutable matrix for speed. Now I get to build a function that receives that mutable matrix, and returns the `(Int,Int) → Color` function I need. I thought I just needed runST?
10:04:23 <John3784> Mark-dls Can you send me the http link ? of the game ?
10:04:43 <c_wraith> SrPx: if you intend to have the result be outside ST, all mutation needs to be contained within that function.
10:05:01 <c_wraith> SrPx: if you're passing around a mutable vector, you're violating that requirement
10:05:09 <Mark-dls> John3784 go here http://yoliece463.itch.io/nexus-ball
10:05:54 <SrPx> so I'm not supposed to pass a mutable vector around?
10:05:57 <NightRa> Procian: I guess fold(replicate k f) will do (Kleisli monoid)
10:06:19 <c_wraith> SrPx: you can pass it around if you keep working inside ST
10:06:35 <c_wraith> SrPx: that's the whole point of ST.  It isolates the use of mutability, so that no use of mutability escapes it
10:06:56 <John3784> Mark-dls I bought it for 5 Dollar
10:07:28 <SrPx> I'm not sure I get it... I have a "set :: (PrimMonad m, GMV.MVector v a) => Vec Int -> a -> Matrix v (PrimState m) a -> m ()" function that mutates the matrix. I will call it several times. When I'm done, I just need to build a (x,y) → Color function to send to the API. I won't mutate anything anymore.
10:07:50 <Procian> NightRa: Yeah, I'd like to see it somehow as Kleisli conversion to Church numeral: that conversion being something that takes a natural number n and a function f, and gives you f composed with itself n times.
10:08:08 <John3784> Mark-dls it is very nice the game
10:08:21 <SrPx> I thought "runST" kinda recovered a solid matrix from a mutable matrix
10:08:24 <SrPx> wait
10:08:31 <c_wraith> SrPx: then freeze the vector to get it out of ST (and lost its mutability).
10:08:34 <c_wraith> *lose
10:09:16 <Mark-dls> John3784 , i know
10:10:25 <Mark-dls> John3784 I already know him
10:10:44 <c_wraith> SrPx: you can use unsafeFreeze to make it O(1) (no copying of the backing data), so long as you are sure the vector won't be mutated again
10:11:19 <Mark-dls> you work tomorrow John3784 ?
10:11:37 <John3784> Yes mark
10:12:23 <SrPx> c_wraith: so I need to build another version of my "Matrix" datatype that isn't mutable?
10:12:42 <c_wraith> SrPx: not if all you want to do is provide that function.
10:13:52 <SrPx> but my "get" function that reads the values uses the mutable matrix... get :: (PrimMonad m, GMV.MVector v a) => Vec Int -> Matrix v (PrimState m) a -> m a
10:13:54 <SrPx> I need another get then?
10:14:28 <c_wraith> SrPx: yes, you'd want a version that works on a generic Vector, rather than a generic MVector
10:15:35 <SrPx> hmm...
10:17:46 <SrPx> a generic "get" function that works for both mutable and immutable vectors? That sounds impossible, since the mutable/immutable read have different types, no?
10:17:47 <Procian> Nightra: Something like this: iterM n f = foldr (>=>) return (replicate n f)
10:17:55 <Procian> Generalising: iterF n f = foldr (.) id (replicate n f)
10:18:16 <c_wraith> SrPx: indeed.  with an immutable vector, get is a pure function because it never needs to worry about the result changing
10:18:34 <SrPx> hmmm...
10:19:22 <NightRa> Procian: with the derived monoid from the category, right?
10:20:02 <SrPx> ah... got it to work. wow! (:
10:20:13 <SrPx> thanks guyss
10:20:35 <c_wraith> SrPx: just be sure to not mutate the Vector after you call unsafeFreeze on it!  doing so will lead to crazy bugs! :)
10:20:58 <SrPx> c_wraith: actually runST worked, so I didn't need unsafeFreeze !
10:21:26 <SrPx> this is the definition that worked: http://lpaste.net/117171
10:21:49 <SrPx> I needed the parenthesis between forall s. and →
10:22:08 <SrPx> seems like this makes GHC somehow finally understand that both s are the same
10:22:09 <Procian> NightRa: Not sure what you mean. You don't need any monoids with that definition. It should literally just be n Kleisli compositions as opposed to n function compositions.
10:22:56 <NightRa> It can be generalized further than Kleisli
10:23:10 <NightRa> To Category a a
10:23:50 <NightRa> Such beauty :)
10:24:44 * hackagebot pregame 0.1.4.1 - Prelude counterpart  http://hackage.haskell.org/package/pregame-0.1.4.1 (jxv)
10:28:17 <osa1> can cabal print test program outputs without delayed printing and without removing colors?
10:31:14 <Procian> NightRa: Oh I see. Yeah, you're just doing x+x...+x n times for any monoid, whether function composition or Kleisli composition or addition.
10:31:17 <SrPx> How do I specialize this function: `foo :: (GMV.MVector v a) => (forall s. Matrix v (PrimState (ST s)) a) -> (Int, Int) -> a` to return only Color (instead of any `a`)? If I modify the `a`s to `Color`s I get a type error because of that "a" before the =>
10:31:54 <NightRa> Procian: We rediscovered multiplication!
10:31:56 <NightRa> Yay!!!!
10:33:48 <Procian> NightRa: It's a hall of mirrors all the way down.
10:34:43 <mathu> so, i'm reading through http://wall.org/~lewis/2013/10/15/asm-monad.html and I've got a question. i'm looking at the definitions for ldai, clc, adci, cmpi towards the beginning of the article and i just want to make sure i understand what's happening (relating to >> vs >>= for monads)
10:35:04 <Procian> SrPx: Do you get a type-error, or just a complaint that Haskell 98 doesn't like that sort of type constraint?
10:35:23 <SrPx> A complaint, but enabling FlexibleInstances doesn't help...
10:35:43 <SrPx> ah and it is an error, not a warning
10:36:33 <mathu> `ldai x = byte 0xa9 >> byte x` so, what's happening here in the context of the article is that the monadic return value is being ignored, but 0xa9 and x are concatenated and the location will be advanced twice?
10:36:37 <SrPx> oh I was supposed to add FlexibleContexts not instances. my bad
10:36:40 <mathu> sorry, typing that all out took a while
10:38:03 <bergmark> mathu: byte 0xa9 >> byte x = byto 0xa9 >>= \_ -> byte x
10:38:44 <Procian> SrPx: Yeah, you're looking for extensions, and presumably, you're already using multi-param type classes.
10:38:52 <Procian> Does the "v" have to be polymorphic?
10:39:40 <SrPx> Procian: I don't know
10:40:32 <Procian> If not, then you don't need a type-constraint at all. But I'm not sure what you're working with.
10:41:22 <mathu> bergmark: ahhh, okay, i see. thank you!
10:45:30 <eyebloom> If you create a function of type x -> x can the type of x be instantiated as (y,z) where y and z are other type variables?
10:45:54 <gambogi> So a friend of mine and I think we found a bug in GHC's type inference
10:46:02 <rhaps0dy> eyebloom: I think so, why not?
10:46:08 <Procian> eyebloom: Sure.
10:46:16 <gambogi> consider: https://gist.githubusercontent.com/TravisWhitaker/e090e2d34f7c763f702c/raw/17192d0c123d14c65e805f36e08801ac3f371579/gistfile1.txt
10:46:47 <eyebloom> I thought so too, but I’m getting a type error where it seems I can’t.
10:47:04 <eyebloom> http://lpaste.net/117130
10:48:41 <eyebloom> I realize this is probably a different kind of error but ghc is reporting it as a basic error in unification?
10:48:57 <c_wraith> gambogi: that's the monomorphism restriction.
10:51:14 <pnielsen> "probably the most annoying and controversial feature of Haskell's type system" do most people not add type signatures?
10:52:42 <eyebloom> pnielsen: It depends usually I’ll try to write the function and see if it type checks and then try to write the type signature.
10:52:52 <eyebloom> I realize this is often backwards.
10:52:54 <Procian> eyebloom: I don't know much about type families, but it looks like a sensible error.
10:53:46 <pnielsen> oh yeah, I do that too sometimes, but monomorphism restriction certainly hasn't held me back at any point. Forgot it even existed
10:53:55 <dfeuer> Does GHC have any primitive support for slicing vectors/arrays in PrimMonad or what have you? Hypothetically, wen the GC comes around, it would only evacuate the portion that was visible.
10:54:23 <eyebloom> Procian: why specifically?
10:54:24 <Procian> Heart3 Toy3 has type Heart a (Int,Int,Int), right?
10:54:36 <pnielsen> just surprising to see it described as the most annoying aspect. Anyway, it's the Haskell wiki so YMMV :)
10:54:49 <eyebloom> Yes
10:55:20 <Procian> Actually, is it Heart Toy (Int,Int,Int)?
10:55:28 <eyebloom> Yes
10:55:45 <rhaps0dy> wow, i usually write the type signature of functions first
10:55:47 <tasker> I keep getting the errors "     No instance for (MonadBase IO Maybe)" and "    No instance for (MonadBaseControl IO Maybe)". Is there some module I can use to import these instances ?
10:55:48 <gambogi> c_wraith: oh, yup, that's it
10:55:55 <rhaps0dy> else i woudlnt' be able to write the function
10:55:59 <Procian> But then, Heart2 Toy2 has type Heart Toy (Int,Int)
10:56:14 <eyebloom> I see.
10:56:22 <Procian> And you want to say that both can be generalised as Heart Toy a.
10:57:22 <eyebloom> Is there a way that I can pattern match the type based on the size of that tuple? Am I way off here?
10:58:14 <crobbins> eyebloom: you'd have to use a algebraic data type
10:59:11 <crobbins> something like, data Tuple a = TwoTuple (a, a) | ThreeTuple (a, a, a) | FourTuple (a, a, a, a)
10:59:31 <eyebloom> I see.
10:59:36 <crobbins> eyebloom: alternatively, you could use Data.Dynamic
10:59:45 <crobbins> because really, you are wanting to pattern match on different types
11:00:11 <eyebloom> Yes the issue is that I need something like
11:00:40 <eyebloom> data Tuple a = Tuple1 a | Tuple2 a b | Tuple3 a b c
11:00:54 <eyebloom> But I’m only passing in
11:00:56 <eyebloom> a
11:01:02 <eyebloom> as a type variable
11:01:45 <eyebloom> Or if I did data Tuple a b c = Tuple1 a | Tuple2 a b | Tuple3 a b c
11:01:53 <eyebloom> I have the inverse problem
11:02:55 <tasker> Could anyone point me to some examples of what MonadBaseControl IO Maybe instances should look like ?
11:03:19 <crobbins> eyebloom: it seems that a tuple is not the right data type for your problem
11:06:30 <eyebloom> Is there an alternative? Aside from Dynamic.
11:10:38 <michaelt> tasker: there can't be such an instance, since the only possibility for 'a' in MonadBase a Maybe is Maybe, the only possibility for MonadBaseControl a Maybe is Maybe as well ... this is a bit of a nightmare...
11:11:13 <tasker> Hm, okay. I guess this is a more fundamental misunderstanding on my part, then :)
11:11:15 <JonReed> I want to concatenate <Show a> <ByteString> <ByteString>. What would a readable and efficient way to do it.Right now I do <concat a s1 s2 = s1 `append` s1 `append` (pack $ show a)>
11:11:34 <JonReed> But that seems too verbose
11:12:37 <osa1> anyone here is using hpc tool?
11:13:06 <brainacid> :t map
11:13:07 <lambdabot> (a -> b) -> [a] -> [b]
11:13:14 <brainacid> How do I read that
11:13:20 <osa1> it's always failing with "hpc: can not find Main in ["./.hpc"]", any ideas about this?
11:14:40 <brainacid> (a -> b) -> [a] -> [b] ???
11:14:59 <barrucadu> brainacid: It's a function of two arguments, the first of which is type "a -> b", and the second is "[a]", it produces a "[b]"
11:15:03 <JonReed> brainacid: A function from list a to list b?
11:15:22 <michaelt> tasker: there is a 'functional dependency' of the first parameter on the second, so MonadBase m mtrans means, "m is the (unique) 'base monad' for mtrans" , MonadBaseControl has this constraint, but demands the possibility of a further operation
11:15:23 <JonReed> brainacid: map from list a to list b
11:15:36 <brainacid> so map (++ "\n) xs
11:15:41 <c_wraith> brainacid: as an alternative to barrucadu's (also correct) answer, you can read it as "a function from a function of type (a -> b) to a function of type ([a] -> [b])"
11:15:54 <brainacid> thanks barrucadu JonReed
11:16:08 <brainacid> :t map (++ "\n") xs
11:16:09 <lambdabot>     Not in scope: ‘xs’
11:16:09 <lambdabot>     Perhaps you meant one of these:
11:16:09 <lambdabot>       ‘x’ (imported from Debug.SimpleReflect),
11:16:20 <brainacid> :t map (++ "\n") ['a','b']
11:16:21 <lambdabot>     Couldn't match expected type ‘[Char]’ with actual type ‘Char’
11:16:21 <lambdabot>     In the expression: 'a'
11:16:21 <lambdabot>     In the second argument of ‘map’, namely ‘['a', 'b']’
11:16:51 <brainacid> :t map (++ "\n") ["....."]
11:16:51 <lambdabot> [[Char]]
11:19:53 <glguy> eyebloom: http://lpaste.net/117130
11:20:11 <glguy> There are some issues, you need to disamibuate the singleton case from a catch-all
11:20:21 <glguy> you need to use type classes for matching on those data families
11:20:35 <glguy> You can index your toy type with a tuple to match it to hearts and limbs
11:22:32 <rhaps0dy> eyebloom: out of curiosity, what are you writing?
11:22:35 <rhaps0dy> those are some curious names
11:22:48 <eyebloom> How would I index the toy type to a tuple?
11:23:12 <Phillemann> I'd like to run a program and read/analyze it's stderr (and possible stdout) "stream", while feeding stdin from the terminal (just like ./foo 2>haskellfunction). Is there a higher level wrapper in Haskell available for this?
11:24:31 <rhaps0dy> eyebloom: I'd answer if I knew, sorry
11:24:45 <eyebloom> rhapsOdy: I’m trying to write a DSL to describe doubly linked graphs. But those names are arbitrary, just Heart for unapplied data constructor and limbs for it’s functions. This lpaste is just a toy example to try and get to the heart of my type problem.
11:25:14 <rhaps0dy> Interesting
11:25:17 <rhaps0dy> thanks :)
11:25:20 <eyebloom> Sorry limbs for it’s arguments.
11:29:57 <eyebloom> Basically if a Heart is only applied to arguments of the same type as Toy. I can do it without type families.
11:30:46 <brainacid> c_wraith: I see that one nicer thanks!!
11:30:57 <dredozubov> haha, great cabal hell visualization http://www.well-typed.com/blog/aux/images/cabal-hell/cabal-hell-solutions.png
11:31:21 <romanandreg> lens question: is there a way to access a nested property via lenses and perform more than one update on this nested property, and get back the container with the property modified?
11:32:25 <romanandreg> imagine: record ^. subMap . at “property” . _Just & subProp1 .~ True & subProp2 .~ False
11:32:34 <romanandreg> but instead of getting the property back
11:32:39 <romanandreg> I get the record modified?
11:33:32 <orbital> confused by relational-record. In the examples they generate schema by doing things like $(defineTable "account"), but where is it getting the information from? The database?
11:34:28 <supki> romanandreg: I usually do something like this: record & subMap.at "property"._Just %~ set subProp1 True . supProp2 False
11:34:50 <romanandreg> uhmm
11:34:54 <romanandreg> let me try that
11:35:01 <brainacid> also folks in type signatures, does the parentheses () mean tuples? or just precedence as an expression
11:35:27 <jle`> it is both, just like in normal value expressions :)
11:35:43 <Saizan> brainacid: if you have commas in the middle it's tuples, otherwise not
11:36:03 <supki> romanandreg: basically it uses the fact that over/(%~) takes an arbitrarily complicated function as an argument
11:36:06 <brainacid> Saizan: ahh yes
11:36:07 <jle`> > ( True,  (3+2)*4 )
11:36:09 <lambdabot>  (True,20)
11:36:30 <brainacid> (True, 1+1)
11:36:40 <brainacid> > (True, 1+1)
11:36:42 <lambdabot>  (True,2)
11:36:52 <brainacid> :t (True, 1)
11:36:53 <lambdabot> Num t => (Bool, t)
11:37:00 <romanandreg> supki: worked like a charm… need to do set subProp2
11:37:02 <romanandreg> as well
11:37:09 <romanandreg> besides that, it worked pretty well
11:37:09 <brainacid> -> means function (evaluate)
11:37:16 <brainacid> thanks Saizan
11:37:21 <romanandreg> supki: thank you very much
11:37:26 <jle`> it's actually a little interesting that haskell has the same syntax at the type level as as the value level, for a lot of things
11:37:32 <jle`> :t (True, map)
11:37:33 <lambdabot> (Bool, (a -> b) -> [a] -> [b])
11:37:50 <romanandreg> supki: I didn’t know I could compose setters with .
11:37:52 <romanandreg> that’s amazing
11:38:27 <jle`> that's the beauty of it :D :D :D
11:50:24 <rhaps0dy> Freenode, why always so many joins and leaves?
11:53:01 <Saizan> brainacid: cheers :)
11:56:03 <brainacid> I also would like to understand my understanding here
11:56:41 <brainacid> I have let a = [1,2], let b = [1,2]
11:56:46 <brainacid> I want
11:57:18 <brainacid> f :: [1,2] -> [1,2] -> [2,4]
11:57:38 <brainacid> so i want to add to [Int] lists
11:58:03 <brainacid> i use  ? map (+ a) b ?
11:58:41 <shiona> brainacid: to combine two lists elementwise use zipWith
11:58:53 <shiona> > zipWith (+) [1,2] [1,2]
11:58:54 <lambdabot>  [2,4]
11:58:55 <michaelt> zipWith (+) ?
11:59:17 <brainacid> elementWise
11:59:23 <brainacid> shiona:
11:59:47 <pavonia> map only works on a single list
11:59:58 <michaelt> > map (uncurry (+)) (zip [1,2] [1,2])
11:59:59 <lambdabot>  [2,4]
12:00:57 <SrPx> Does anyone have an example in how to use drawPixels from OpenGL library?
12:02:54 <brainacid> very sweet michaelt
12:03:00 <brainacid> :t uncurry
12:03:01 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:05:16 <brainacid> wow
12:06:19 <brainacid> a function that takes a function type (a->b->c) as first argv, func :: (a->b) as second argv returning c
12:06:22 <brainacid> correct?
12:06:53 <brainacid> i meant snd argv (a,b) tuple
12:08:19 <kadoban> brainacid: Yes. It changes a function from a -> b -> c  to one from (a, b) -> c
12:14:48 * hackagebot uuid 1.3.8 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.3.8 (AntoineLatter)
12:15:13 <brainacid> can I do [1,2] -> ["1", "2"]
12:15:16 <brainacid> ??
12:15:33 <michaelt> > map show [1,2]
12:15:35 <lambdabot>  ["1","2"]
12:16:40 <NightRa> I posted a blog post about that crazy journy we just had on IRC:
12:16:46 <NightRa> https://medium.com/@NightRa/general-abstract-nonsense-in-its-best-65989aee622c
12:19:43 <brainacid> michaelt: very nice
12:19:58 <brainacid> michaelt: just found something different my self but thats nice
12:32:48 <Phillemann> Is there a way to write a generic "try :: IO a -> IO (Maybe a)" which catches an exception and returns a Nothing? I'm a bit confused about Control.Exception right now.
12:34:29 <Peaker> Phillemann: of course, you can use Control.Exception.try and map (Either SomeException a -> Maybe a)
12:34:49 * hackagebot quickcheck-instances 0.3.10 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.3.10 (AntoineLatter)
12:36:49 <Phillemann> I'm not sure about the mapping part. try has "Exception e => " in its signature, so simply "result <- try a; case result of ..." confuses ghc.
12:44:49 * hackagebot xmlhtml 0.2.3.4 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.3.4 (DougBeardsley)
12:49:15 <Phillemann> http://lpaste.net/117178 - ok, this is what I got now.
12:50:21 <trehans> hi everyone, is this a good place to ask a question about cabal?
12:51:56 <vanila> a good place but maybe not the best time, worth trying in future if no one can help just now
12:52:13 <trehans> okay, thanks
12:55:39 <aphorisme> Hey. I'm trying to understand some concepts in Haskell more deeply but somehow I might be to deep into OO-thinking... so for example: In which sense is a typeclass more then an interface like e.g. in Java?
12:57:20 <exio4> aphorisme, they aren't, but the closest you'll get in the OO land to a typeclass is an interface, but they are different
12:57:46 <aphorisme> hm, in which sense are they different?
12:58:02 <exio4> theyt aren't the same thing*
12:59:53 <exio4> aphorisme, implementing a functor instance like haskell's using interfaces is impossible, and they are also not part of the type, but just an "implicit record with functions and constants"
12:59:53 <exio4> aphorisme, also, something like bounded
13:01:05 <exio4> there is also a page in the wiki that talks about this, let me try to get it
13:01:35 <aphorisme> That would be great.
13:02:18 <brainacid> im trying to append two lists side by side
13:02:31 <brainacid> i have fPut :: [[Char]] -> IO ()
13:03:20 <brainacid> fPut = putStr . concat . map (++ "\n")
13:03:27 <brainacid> i tried
13:04:14 <brainacid> colForm = zipWith (++) but unintended -> [2,3] [4,5] -> [24,35]
13:05:17 <brainacid> I want ["2", "\t", 4, "\t", 3 ..
13:07:12 <nolrai66> > let f (x:xs) (y:ys) = x : y : f xs ys in f [2..] [4..]
13:07:13 <lambdabot>  [2,4,3,5,4,6,5,7,6,8,7,9,8,10,9,11,10,12,11,13,12,14,13,15,14,16,15,17,16,18...
13:07:33 <vanila> > let f (x:xs) ys = x : f ys xs in f [2..] [4..]
13:07:35 <lambdabot>  [2,4,3,5,4,6,5,7,6,8,7,9,8,10,9,11,10,12,11,13,12,14,13,15,14,16,15,17,16,18...
13:08:07 <nolrai66> hmm.
13:08:08 <Cale> > intercalate "\n" . map (intercalate "\t" . map show) . transpose $ [[1,2,3],[4,5,6]]
13:08:09 <lambdabot>  "1\t4\n2\t5\n3\t6"
13:08:19 <Cale> > intercalate "\n" . map (intercalate "\t" . map show) . transpose $ [[1,2,3],[4,5]]
13:08:20 <lambdabot>  "1\t4\n2\t5\n3"
13:08:55 <Cale> Depending on how you want to deal with the case where one of the lists is shorter, this approach might work well. You could also use zipWith
13:09:08 <exio4> aphorisme, https://www.haskell.org/haskellwiki/OOP_vs_type_classes
13:09:18 <aphorisme> thanks!
13:09:47 <Cale> aphorisme: One of the biggest differences is exemplified in the type of read:
13:09:49 <Cale> :t read
13:09:50 <lambdabot> Read a => String -> a
13:09:55 <nolrai66> So can one not use opperators in Hamlet?
13:10:05 <brainacid> Cale: dont have intercalate in the Prelude
13:10:13 <Cale> brainacid: It's in Data.List
13:10:20 <brainacid> import Data.List?
13:10:22 <Cale> yep
13:10:31 <brainacid> just that line?
13:10:34 <Cale> yes
13:10:37 <brainacid> cool
13:10:51 <brainacid> Cale
13:11:10 <brainacid> I want "1\t2\t3..
13:11:14 <Cale> oh
13:11:20 <Cale> in that case, get rid of the transpose
13:11:28 <vanila> I think you can use intersperse
13:11:31 <vanila> :t intersperse
13:11:32 <lambdabot> a -> [a] -> [a]
13:11:50 <Cale> intercalate is intersperse followed by a concat
13:12:01 <vanila> oh okay
13:12:01 <Cale> @src intercalate
13:12:02 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
13:12:08 <vanila> I was going to say intersperse '\t' . map show
13:12:15 <exio4> aphorisme, you may find http://www.haskellforall.com/2012/05/scrap-your-type-classes.html useful, it doesn't talk about interfaces though! :P
13:12:37 <brainacid> ok i got lost
13:12:44 <brainacid> one sec
13:13:04 <aphorisme> thanks again.
13:13:07 <aphorisme> Plenty to read.  ; )
13:13:45 <Cale> aphorisme: Sorry, got distracted there, I was going to say, look at how read is polymorphic in its result type.
13:14:19 <aphorisme> yeh ... right. Seems at first not possible. But with some creepy generic trick maybe.
13:14:26 <aphorisme> But I see   : )
13:14:53 <nolrai66> But with type classes it's trivial.
13:15:14 <Cale> It's possible because the typechecker is going to figure out what that type is at compile time, so we'll know which instance of the Read type class is in use.
13:15:15 <aphorisme> yeh, and much more elegant.
13:15:30 <Cale> Also, there are things like:
13:15:34 <Cale> :t (<)
13:15:35 <lambdabot> Ord a => a -> a -> Bool
13:16:02 <Cale> This is quite a bit different from the case where Ord is something like an interface, and you have "Ord -> Ord -> Bool"
13:16:11 <aphorisme> I mean, I see the elegance (and I like it), but it's on my side that my thinking does not seem to be free enough of OO.
13:16:14 <aphorisme> ye!
13:16:15 <Cale> Because this enforces that both arguments have the same type.
13:16:47 <brainacid> Cale: I dont get
13:17:28 <Cale> aphorisme: Another cool thing is that simply by using type class polymorphic things, you can make new type class polymorphic things.
13:17:38 <Cale> The Ord class doesn't mention sort anywhere, but we have:
13:17:40 <Cale> :t sort
13:17:41 <lambdabot> Ord a => [a] -> [a]
13:17:55 <aphorisme> I see.
13:18:25 <aphorisme> So somehow I have to get the OO out of my head.  ; )
13:18:26 <Cale> (this is really what sets type class polymorphism apart from ad-hoc polymorphism)
13:18:48 <Cale> Well, you don't entirely have to. But type classes don't have much to do with OO.
13:19:14 <aphorisme> but somehow it feels that I'm using them in this way and hence losing potential.
13:19:14 <Cale> If you want to do OO in Haskell, the way to do it is just using data types containing various functions and things corresponding to the methods of the type of object you're defining.
13:19:51 <Cale> and then instead of using subclasses to define many implementations of that type, you just define functions which set the methods appropriately in various ways.
13:20:29 <aphorisme> ye
13:20:29 <Cale> This I think actually does a better job of modelling OOP in the style of Smalltalk than most typed "OO languages" do.
13:20:50 <aphorisme> I've never used it.
13:21:07 <SharpGAF> aphorisme: It helps to break down what you actually mean by OOP… there's usually a substitute for every individual aspect of it from a conceptual perspective
13:21:16 <SharpGAF> Often a better substitute.
13:21:46 <Cale> Yeah, there are a lot of things which people use the term to mean, and people have different ideas about what the central essence of it is.
13:23:02 <zq> > ord '³'
13:23:03 <Cale> For me, the essence of OOP is that you're defining values in terms of how they respond to certain "methods" or "messages".
13:23:04 <lambdabot>  179
13:24:04 <lpaste> brainacid revised “lastButOne”: “No title” at http://lpaste.net/117137
13:24:14 <aphorisme> For example: at the moment I'm trying to get some structure in a low-level OpenGL Lib I'm writing to learn. There we have a bunch of "objects" (like a shader, a program, a vbo, a vba) which somehow have the same flow of being: create --> bind --> use. So my idea was to generalize this behaviour in a typeclass and having various algebraic types around representing the openGL "objects" ...
13:24:21 <Cale> It's sort of placing the focus on the existentials in everything: There *exists* some type which satisfies such and such interface and which is the type of my value.
13:25:38 <Cale> Whereas traditional functional programming places a very heavy emphasis on universal quantifiers: For all types a and b, the function map will take a function (a -> b) and a list of values of type a and produce a list of values of type b.
13:26:21 <Cale> aphorisme: That's possibly reasonable
13:26:43 <Cale> aphorisme: You could also try just using a plain record type of the functions that you want to use for those things.
13:26:51 <brainacid> Cale: if && when you have a sec check my lpaste
13:26:53 <aphorisme> but it feels like just writing an interface and classes which inherit it, i.e. it feels like I'm missing something.
13:26:58 <brainacid> or anyone for that matter
13:27:00 <Cale> brainacid: Oh, I'll have a look
13:27:12 <SharpGAF> aphorisme: Under that system, can you enforce that Create happens before Bind happens before Use?
13:27:29 <brainacid> i dont understand how to do the intercalate
13:27:33 <aphorisme> create has to happen before everything else. Is there a way to represent this?
13:27:47 <brainacid> thanks much Cale
13:28:02 <Cale> brainacid: You're importing Data.List, so intercalate will already be in scope, you don't need to define it yourself.
13:29:02 <SharpGAF> aphorisme: Not sure what the best way is, I'm mostly a Rust person, so I'm mostly ignorant of how to do this stuff in Haskell
13:29:22 <aphorisme> hehe, okok  ; )
13:29:37 <Cale> aphorisme: Well, what sort of types are we looking at? You might have create produce something which bind accepts as an argument.
13:29:52 <Cale> (in fact, what it produces might itself be the function you use to bind)
13:30:26 <Cale> I don't really know OpenGL all that well though
13:30:29 <aphorisme> Cale: I've to think about this.
13:30:58 <aphorisme> btw. how would you generalize if "create" needs different parameter for different objects?
13:31:31 <Cale> If you were using a type class, then you might use an associated type
13:31:51 <Cale> But probably if the type of create is different for different things, I would strongly consider not abstracting over it.
13:32:07 <Cale> i.e. just have different createFoo functions for different sorts of things
13:32:25 <aphorisme> Hm, I see.
13:32:34 <Cale> This is because it's hard to write code which actually uses such a thing in a polymorphic way
13:32:42 <Cale> So abstracting over it is questionable
13:33:16 <Cale> But yeah, you *could* do something like:
13:33:27 <Cale> class Create a where
13:33:48 <Cale>   type Info a
13:33:59 <Cale>   create :: Info a -> IO a
13:34:27 <Cale> and then in each of the instances, you'd be allowed to define which type  Info a  was for your specific a
13:34:50 <aphorisme> oh, that's new to me.
13:35:04 <Cale> Yeah, that's a language extension
13:35:37 <aphorisme> But I might go for not generalizing...
13:35:40 <aphorisme> which one?
13:35:41 <Cale> yeah
13:36:26 <Cale> The way to decide is just to look at code which uses these functions and see whether you could perhaps share code between various types.
13:37:02 <aphorisme> yeh...
13:37:11 <aphorisme> I'll try.
13:37:14 <aphorisme> : )
13:37:33 <Cale> If you can't because the code is just too different, then there's not much use in the abstraction. People get hung up all the time wanting to name things the same when they're really different, but I'd recommend just getting over that. :)
13:38:18 <aphorisme> hehe, I'm definitely one of those people.  ; )
13:38:32 <SrPx> How do I freeze an Unboxed Mutable Vector? There is no freeze function on its lib?
13:38:42 <aphorisme> thank you very much.
13:39:51 * hackagebot cql-io 0.13.0 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.13.0 (ToralfWittner)
13:39:56 <chrisdone> SrPx: i just did the same thing
13:40:00 <chrisdone> import qualified Data.Vector.Generic as V (freeze)
13:40:04 <chrisdone> V.freeze
13:48:40 <stepkut> anyone got a linode referral code they want me to apply?
13:49:37 <JagaJaga> Hi! Can you tell me how does `liftM2 (+) sin cos` works?
13:49:48 <brainacid> need a good editor
13:49:50 <Cale> JagaJaga: sure
13:49:56 <brainacid> my search and replace suck
13:50:01 <brainacid> something light on resources
13:50:11 <nkar> can ghc warn about redundant language pragmas?
13:50:19 <chrisdone> not that i know of
13:50:22 <chrisdone> but hlint does
13:50:31 <JagaJaga> I can't get why `sin` and `cos` are the `m a1`, `m a2` types..
13:50:37 <Cale> JagaJaga: So first of all, for any monad M, we have liftM2 :: (a -> b -> c) -> M a -> M b -> M c
13:50:52 <Cale> In this case, we're using M t = e -> t
13:51:04 <lpaste> chrisdone pasted “hlint unused LANGUAGE example” at http://lpaste.net/117181
13:51:18 <Cale> So that the type of liftM2 specialises to  (a -> b -> c) -> (e -> a) -> (e -> b) -> (e -> c)
13:51:31 <chrisdone> oh, i got the name wrong maybe
13:51:52 <Cale> It's probably not obvious that this is actually a monad
13:52:28 <michaelt> SrPx: the vector modules always come in pairs, Data.Vector.X and Data.Vector.X.Mutable  the thaw and freeze functions are always in the Data.Vector.X module, not in  Data.Vector.X.Mutable
13:52:46 <JagaJaga> Cale: oh! So can you tell me why it is a monad?
13:52:52 <Cale> The idea behind this monad is that "running" a function e -> a means applying it to the value of type e to which the whole computation has been applied
13:53:02 <JagaJaga> Cale: oh! Thanks.
13:53:08 <Cale> Look at this example: (we'll implement return and bind in a moment)
13:53:24 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
13:53:26 <lambdabot>  ("hello","olleh","HELLO")
13:54:05 <JagaJaga> what monad is here?
13:54:19 <Cale> M t = String -> t
13:54:31 <JagaJaga> So every function is a monad?
13:54:34 <Cale> Or, to write it another way, (->) String
13:54:52 * hackagebot shell-monad 0.0.1 - shell monad  http://hackage.haskell.org/package/shell-monad-0.0.1 (JoeyHess)
13:54:59 <SrPx> ah alright, thanks michaelt and chrisdone
13:55:01 <Cale> The function type constructor, partially applied to its first argument, is a monad.
13:55:10 <JagaJaga> Cale: yeah, got it.
13:55:16 <JagaJaga> Cale: thanks.
13:55:18 <Cale> (->) String is a monad, (->) Integer is a different monad, and so on
13:55:32 <Cale> (Monads are things which exist in the type system, they're not values)
13:56:04 <Cale> For another example of my terminology nitpicking there, IO is a monad, but getLine is not.
13:56:24 <Cale> and Maybe is a monad, but Just 5 is not.
13:56:32 <JagaJaga> But I have a second question. `Monad is a monoid in a category of endofuntors`. I know why they are and understand it. But why do we define them in haskell like return and bind, but not return and join (like eta and mu in a definition)?
13:56:55 <JagaJaga> Cale: yeah, I got the idea about functions, thanks a lot.
13:57:16 <Cale> Oh, if you're familiar with the category theory, the functor in question is the covariant hom functor.
13:58:09 <Cale> The reason to prefer bind for defining monads is mainly because it's usually the most important operation for the kinds of applications we have in mind while doing functional programming.
13:58:26 <JagaJaga> Cale: yeah, thought the same..
13:58:53 <recursion-ninja> Hey guys, I wroe an algorithm I thought was very lazy, but it appears not to be. I suspect that all nodes are being generated instead of exiting early when a correct solution is found. here's the code, do you guys see a problem with it? Is there a way I could increase the laziness?
13:58:58 <recursion-ninja> http://lpaste.net/117165#line13
14:00:02 <Cale> JagaJaga: On the category theory side of things, the sort of definition we give for Monad is sometimes referred to as a "Kleisli triple"
14:00:22 <c_wraith> recursion-ninja: it's very difficult for IO to be lazy.
14:00:43 <c_wraith> recursion-ninja: why is that in IO anyway?  I don't see anything actually doing IO
14:00:51 <recursion-ninja> c_wraith: shuffleM
14:01:11 <JagaJaga> Oh, going to read about kleisli category this night :)
14:01:17 <JagaJaga> And the third today's question is: can we calculate smthing in a compilation time?
14:01:30 <Cale> JagaJaga: Using Template Haskell, yes
14:01:54 <recursion-ninja> c_wraith: Are you suggesting that since I `shuffleM` at eacch recursive step, it might be preventing some laziness & optemiztions?
14:02:00 <JagaJaga> Cale: thx for you help this evening :)
14:02:04 <c_wraith> recursion-ninja: I'm flat-out saying it. :P
14:02:53 <recursion-ninja> c_wraith: Any pro tips to mitigate that?
14:03:16 <Cale> recursion-ninja: Yes, the order in which IO actions are executed is determined by the order in which the binds say they ought to, and the order in which they're *evaluated* basically doesn't matter, because the resulting action will be the same, and you can't observe much about the result.
14:03:24 <c_wraith> recursion-ninja: the principled way, or a bad hack?
14:03:52 <recursion-ninja> c_wraith: tell me both!?
14:04:44 <Cale> You could use the shuffle' function from System.Random.Shuffle, grabbing an initial StdGen using newStdGen in IO, and passing it along to the pure function which does your computation.
14:04:49 <recursion-ninja> Cale: So it will prefrom ALL the IO actions even though, lazily speeking, many should be ignored?
14:04:58 <c_wraith> recursion-ninja: you can use unsafeInterleaveIO as the worst possible hack.. (before the recursive call in selectCyclicArrangent')
14:05:17 <c_wraith> recursion-ninja: or you can get out of IO entirely, and just pass the Gen object around as needed, as Cale suggests.
14:05:29 <c_wraith> recursion-ninja: unsafeInterleaveIO is a bad hack. :)
14:05:52 <Peaker> that would still serialize the data dependencies, unless you split the gen before each shuffle to pass the split gen onwards -- so you don't depend on the entire shuffle
14:05:53 <recursion-ninja> c_wraith, Cale: I'm going to opt for passing around Gen
14:05:57 <Cale> recursion-ninja: IO actions execute in the order described, and generally to completion unless you throw an exception or something gets into an infinite loop.
14:06:28 <Cale> Consider something like:
14:06:43 <recursion-ninja> c_wraith, Cale: I think unsafeInterleaveIO would be opening me up to more headaches then I need...
14:06:44 <Cale> foo = do x <- getLine; print "Hello!"; return x
14:07:00 <Cale> It would be bad for this action to skip the printing just because x was already determined.
14:07:09 <c_wraith> recursion-ninja: you are correct about that. :)
14:07:09 <Cale> yes, probably
14:07:21 <recursion-ninja> Cale: That example makes sense!
14:07:25 <zzing> When we have something like newtype State s a = State { runState :: s -> (s, a) }    is runState an actual function or some how just apart of State? I also see this pattern with Snap, containing an unSnap.  I am trying to understand exactly what these are doing.
14:07:42 <kaiyin> https://gist.github.com/kindlychung/bf4003104dbc28ac548b   In the type declaration, `on` seems to take 7 parameters, but in the actual definition, it takes two. It's quite confusing here.
14:08:02 <c_wraith> zzing: it's an accessor function.  It's just a single-field record
14:08:46 <recursion-ninja> c_wraith, Cale: I'll rewrite this by grabbing a Gen at the selectCyclicArrangement(top level) and make selectCyclicArrangement' (prime) a pure function.
14:09:19 <recursion-ninja> c_wraith, Cale: That should bring lazyness back into the mix right?
14:09:45 <c_wraith> recursion-ninja: well, it will allow it.  Still depends on the algorithm details, though it looks right.
14:09:47 <zzing> I see some functions in snap that are the type    a :: Snap ()  that are meant to be a handler, they have the ability to getParam or writeBS, etc. I don't see any parameters being taken by this function, are these using that accessor in some way?
14:10:28 <arjanb> kaiyin: it is function that takes two functions a returns a new function
14:10:47 <c_wraith> zzing: well, they go the other way around - they use the constructor, passing it a function that the accessor would return.
14:10:47 <recursion-ninja> c_wraith: Well then that's where I'll start & then re-profile!
14:11:13 <recursion-ninja> c_wraith, Cale: Thanks for your help, it all seems so obvious now!
14:11:25 <zzing> c_wraith, is there any more clear example of how this 'magic' is done?
14:11:31 <kaiyin> arjanb, ok, I see now. Thanks!
14:11:53 <c_wraith> zzing: look at the State example, and consider get :: State s s
14:12:45 <zzing> c_wraith, is it on https://www.haskell.org/haskellwiki/State_Monad?
14:12:56 <arjanb> kaiyin: just formatting it a little different makes it more understandable:  on :: (b->b->c) -> (a->b) -> (a->a->c)
14:13:11 <c_wraith> zzing: probably.  (that page is loading slow for me)
14:13:29 <c_wraith> zzing: but it's better to try writing it all from scratch.
14:13:50 <zzing> c_wraith, I would generally agree, but know not where to start.
14:15:20 <nitrix> Hi, I'm learning sum elimination, and I'm actually really curious. How would one implement/rewrite the `maybe` function?
14:15:40 <nitrix> I have a clue that it'd use lambdas, but I'm still curious.
14:16:27 <c_wraith> zzing: start with this:  http://lpaste.net/117183
14:16:36 <nitrix> :t maybe
14:16:37 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:16:51 <c_wraith> zzing: Just follow the types - there aren't many ways to implement those.
14:16:57 <nolrai66> > bounds (listArray (1,2) undefined)
14:16:59 <lambdabot>  *Exception: Prelude.undefined
14:17:14 <nolrai66> > bounds (listArray (1,2) [4,5])
14:17:15 <lambdabot>  (1,2)
14:17:31 <zzing> c_wraith, so the syntax with the record is just sugar for what you have there?
14:17:47 <c_wraith> zzing: well, it's sugar for the runState function
14:21:47 <zzing> c_wraith, so what I start with is to replace all State s a with the right side. On that I see get wraps up a function  s -> (s,s). Is that the correct interpretation?
14:22:11 <c_wraith> zzing: yep.
14:24:13 <brainacid> c_wraith: How is the function where e && f [[Char]] [e1, e2] -> [f1, f2] -> [e1, "\t", f1 etc...
14:25:08 <brainacid> sorry for being cryptic
14:25:17 <c_wraith> yeah, I'm not quite sure what you're asking
14:25:20 <brainacid> im trying to make one list
14:25:38 <c_wraith> Oh, did you want concatMap, maybe?
14:26:39 <brainacid> that contains ["1","2"] ["a","b"] -> ["1","\t", "a", "2", "\t", "b"]
14:26:50 <brainacid> let me check concatMap
14:26:54 <brainacid> :t concatMap
14:26:55 <lambdabot> (a -> [b]) -> [a] -> [b]
14:27:21 <nolrai66> Gah, so I don't seem to be able to implement Ix for word4 with out causing infinite loops.
14:27:31 <nolrai66> Anyidea what I am doing wrong?
14:27:53 <c_wraith> brainacid: oh.  Hmm. looks like you want maybe a combination of zipWith and concat?
14:28:30 <c_wraith> > concat $ zipWith (\x y -> [x, "\t", y]) ["1", "2"] ["a", "b"]
14:28:32 <lambdabot>  ["1","\t","a","2","\t","b"]
14:28:47 <c_wraith> brainacid: that what you're looking for?
14:29:53 * hackagebot Spock 0.7.5.2 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.5.2 (AlexanderThiemann)
14:30:08 <zzing> c_wraith, say we have https://www.haskell.org/haskellwiki/State_Monad#Complete_and_Concrete_Example_1   with (_, score) <- get    Which should return State (GameState -> (GameState, GameState))  and <- would strip the State container, and then we have GameState -> (GameState, GameState)  but it seems that I have missed something here because it seems to want the (GameState, GameState) part.
14:30:27 <brainacid> c_wraith: im very new so this is all they way I study... not sure let me tes
14:30:28 <brainacid> t
14:30:34 <brainacid> c_wraith: thanks
14:30:58 <c_wraith> zzing: I think that example is complicating things by use of a compound state.
14:31:29 <zzing> potentially.
14:31:45 <chrisdone> yay, in-place quicksort http://lpaste.net/117184
14:32:50 <luite> chrisdone: i don't believe you :p
14:33:48 <chrisdone> luite: check it out =p
14:34:45 <chrisdone> the foldM is a bit lazy, creating an intermediate list, when i could use a manual "go" loop. but ja
14:34:49 <luite> chrisdone: no i mean that in-place usually means overhead independent of input size. with quick sort you typically need a non-constant-size stack
14:35:39 <c_wraith> that uses O(n) extra space because the input and output are immutable structures.  the O(log n) stack space isn't big in comparison. :P
14:35:40 <chrisdone> i read about that
14:36:01 <chrisdone> c_wraith: the input and output aren't immutable
14:36:12 <chrisdone> that's just the example use
14:36:28 <c_wraith> oh.  I saw the use of freeze and ignored the rest
14:36:31 <chrisdone> luite: the second call to qsort is in tail-call position which i read is the proper way to make it use constant stack
14:36:43 <chrisdone> luite: well, not constant stack. but decent
14:36:59 <c_wraith> chrisdone: it could still use O(n) stack space, worst-case.
14:37:08 <chrisdone> nod
14:37:44 <chrisdone> Sedgewick says:
14:37:49 <chrisdone> To make sure at most O(log n) space is used, recurse first into the smaller side of the partition, then use a tail call to recurse into the other.
14:38:03 <chrisdone> so perhaps i could do a check on the size to decide which tail call to make
14:38:08 <c_wraith> chrisdone: that'll work, but it requires you to know which size is larger
14:38:13 <brainacid> c_wraith: so do i define a func: myCon = concat $ zipWith ...
14:38:16 <luite> chrisdone: the biggest of the two partitions needs to be in the tail position
14:38:31 <chrisdone> luite: that's what i just said right? =p
14:38:53 <chrisdone> c_wraith: the pivot tells you that?
14:39:13 <luite> oh okay, sorry, i hadn't read that line yet, was replying to "the second call to qsort..." line
14:39:15 <c_wraith> chrisdone: the final index of the pivot does, yes
14:39:16 <chrisdone> pivot decides how to split the array. so you just take the delta from begin and end to decide how big each one is
14:39:41 <zzing> c_wraith, is all of this state and snap stuff essentially returning a function to be run later?
14:40:21 <chrisdone> i'm using this as a learning exercise to learn quickcheck, which i've never learned how it works in-place, which seems to be the only legit way to do it
14:40:23 <c_wraith> zzing: a State value or a Snap value is a (usually big and complex) function, yes.
14:40:26 <gilligan_> If I do say "cabal get alex" is there a sensible pragmatic way to now beforehand the name of the directory cabal is going to create ? "alex-3.1.3" : packageName-[version] -- but how can i know the version number ?
14:40:37 <chrisdone> it's surprisingly nice in haskell, isn't it?
14:40:39 <zzing> c_wraith, does that have performance implications?
14:40:57 <c_wraith> zzing: not usually.
14:41:05 <chrisdone> i thought the code would be horrid due to being so imperative, but it's not much different to the pseudo code
14:41:15 <chrisdone> it even works in either ST or IO, which rocks
14:42:16 <zzing> c_wraith, do you think that this is a good approach for a 'handler' in general, or would a more explicit passing in of data?
14:44:54 * hackagebot hspec-expectations 0.6.1.1 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.6.1.1 (SimonHengel)
14:46:14 <Beardful> I made a thing w/ OpenGL, where a square grows, but it doesn't automatically re-render itself - it does so when i change the window. Why so ?http://sprunge.us/PehC
14:47:37 <chrisdone> er, i meant as a learning exercise to learn quicksort
14:49:42 <chrisdone> c_wraith: luite: http://lpaste.net/117184#line29 =3
14:50:19 <chrisdone> onto merge sort!
14:51:34 <corbis> hi
14:51:47 <pavonia> Beardful: When should it rerender?
14:52:26 <Beardful> pavonia: I supposed it would rerender always.
14:52:55 <ticktock> Beardful: I think you want to add 'postRedisplay Nothing' after flush
14:53:39 <Beardful> ticktock: You're awesome! And also correct.
14:54:14 <pavonia> I guess it's better to add a timeout that rerenders at a given interval
14:54:54 * hackagebot list-t 0.3.2 - ListT done right  http://hackage.haskell.org/package/list-t-0.3.2 (NikitaVolkov)
14:54:56 * hackagebot list-t 0.4.1 - ListT done right  http://hackage.haskell.org/package/list-t-0.4.1 (NikitaVolkov)
14:55:04 <Peaker> so many ListT-done-right packages
14:55:28 <benzrf> pipes is the 1 tru list t
15:10:48 <nolrai66> So anyone here no how to use one hunk of hamlet inside of another?
15:11:54 <chrisdone> i don't think it's possible
15:12:39 <chrisdone> you have to write some haskell code with some quasi quotes or something. it's unawesome
15:13:14 <rhaps0dy> of hamlet?
15:13:18 <zzing> +1 for the use of unawesome
15:13:25 <nolrai66> grr.
15:15:08 <chrisdone> http://online-social-networking.com/images/snakeoil.jpg “might i offer you a bottle of Lucid?”
15:15:42 <chrisdone> cures all ailments!
15:16:03 <chrisdone> bitemyapp: i made some wee progress on my question-answer thing, not sure whether i already showed you
15:16:34 <dfeuer> I think I'm almost done with fromArrayMonolithic. I wonder if Milan will want it....
15:17:18 <bitemyapp> chrisdone: link please?
15:17:23 <chrisdone> bitemyapp: http://lpaste.net/116955 this just parses, doesn't actually run any code yet. but the key part is that it describes what it wants in plain english and then validates inputs
15:18:27 <nolrai66> Hmm, looks like I am supposed to use widgets.
15:18:58 <erisco> is Ubuntu usually behind on GHC versions?
15:19:05 <nolrai66> Wait no.
15:20:12 <chrisdone> bitemyapp: it's probably an arrow https://github.com/chrisdone/exercise/blob/master/src/Exercise/Types.hs#L20 but not sure whether i care to prove it http://www.reactiongifs.com/r/nsr.gif
15:20:15 <kadoban> erisco: Only tragically out of date. I just install GHC and cabal manually and go from there.
15:20:16 <dfeuer> Can I use StateT with ST somehow to avoid boxing Ints?
15:20:34 <dfeuer> Or do I need to go dig deep and unbox them by hand? (barf)
15:20:43 <zzing> Merry Christmas from London erisco.
15:20:48 <chrisdone> bitemyapp: probably will end up with applicative, although i'm just sticking with whatever type fits my mental model and whatever classes fit is fine
15:20:58 <dfeuer> (I have an Int STRef, and it's getting boxed)
15:21:25 <erisco> zzing, Merry Christmas from Chatham
15:22:02 <erisco> kadoban, manually? do you mean from source?
15:22:39 <chrisdone> bitemyapp: anyhoo, next step is to validators for functions with quickcheck and stuff
15:22:45 <chrisdone> er, to add
15:23:18 <kadoban> erisco: Yeah. I use.... https://gist.github.com/ion1/2815423 these instructions, they work well. After that, I just use sandboxes for everything.
15:24:13 <dfeuer> Anyone? Why is my STRef getting boxed?
15:24:16 <chrisdone> bitemyapp: i'll probably end up with an interesting english composition library, if this modest start continues to grow https://github.com/chrisdone/exercise/blob/master/src/Exercise/English.hs
15:24:16 <chrisdone> bitemyapp: i'm thinking i can test-drive some questions on irc here
15:25:21 <erisco> kadoban, does that get you ghci?
15:25:35 <kadoban> erisco: Yep, ghc, ghci, cabal, all the good stuff.
15:27:31 <chrisdone> like:
15:27:31 <chrisdone> <learner> @question if
15:27:32 <chrisdone> <exercisebot> Given a variable, x, write an expression that evaluates to "even" if x is even, or "odd" if x is odd.
15:27:32 <chrisdone> <learner> if even x then "even" else "odd"
15:27:34 <chrisdone> <exercisebot> Correct!
15:27:54 <chrisdone> but the nature of the condition and the branches'll be randomized
15:29:07 <chrisdone> i might claim that nick
15:35:32 <clark-ken2> Hello
15:35:39 <chrisdone> ahoy hoy
15:36:01 <clark-ken2> Are you bot??
15:36:28 <clark-ken2> Hey, are you bot??
15:36:35 <clark-ken2> Somebody?7?
15:36:55 <clark-ken2> I have some questions about haskell???
15:37:03 <erisco> kadoban, okay thanks
15:37:16 <exio4> just ask clark-ken2, you'll be more lucky that way
15:37:43 <yac> clark-ken2: yes, this is a dog
15:38:04 <exio4> yac, I thought it was phone
15:38:28 <clark-ken2> Can be haskell used as a scripting language for a C compiled program?? I am learning haskell and I think that is a good choice f
15:38:44 <yac> exio4: there is no phone
15:39:03 <solatis> how do you solve the problem that you sometimes want to test functions inside a module in a separate test-suite (for example using hspec), but do not want to have those functions exported as a module?
15:39:22 <yac> solatis: there is an issue about that in hspec-example github repo
15:39:35 <solatis> yac: great to know, i'll take a look!
15:40:33 <solatis> yac: where do i have to look? at first glance the hspec-example github repo has no issues ?
15:40:36 <yac> solatis: https://github.com/hspec/hspec-example/issues/5
15:40:45 <solatis> oh
15:40:47 <solatis> closed..
15:40:49 <solatis> sorry
15:41:11 <solatis> right
15:41:27 <solatis> i'm already using CPP, so that makes it a no-brainer
15:41:29 <benzrf> clark-ken2: that seems a little silly
15:41:29 <solatis> thanks!
15:41:45 <benzrf> clark-ken2: but as far as i know haskell is not particularly embeddable
15:41:49 <chrisdone> i'm not a bot!
15:42:04 <yac> chrisdone: yeah, keep telling yourself that
15:42:08 * chrisdone absent-mindedly wipes dust from his pale, dead mechanical eyes
15:42:54 <clark-ken2> Okay. I am just starting in programming.
15:44:02 <SharpGAF> I think you *can* call Haskell from C, if you really want to, but I don't know the details, making this a singularly unhelpful comment.
15:44:31 <yac> clark-ken2: you might want to consider other career choice before going into programming
15:46:39 <chrisdone> i made #haskell-exercises where exercisebot is going to sit
15:46:44 <solatis> yac: i think i'll go for a different aproach, having a main Module.hs that re-exports nested modules, and using a cabal flag -test to either put those nested modules in exported-modules or other-modules
15:46:59 <chrisdone> heh, reminds me of a lojban channel that you could join, and it would kick you from the channel if you wrote invalid lojban
15:47:08 <chrisdone> hard-mode
15:47:30 <sinelaw> chrisdone, the bot already works?
15:47:31 <solatis> same idea, different layer of abstraction ;)
15:47:44 <chrisdone> sinelaw: not yet, just setting up the bouncer
15:47:47 <sinelaw> k
15:48:21 <dfeuer> Ffffff
15:52:46 <dfeuer> Is there a way to make an unboxed STRef? Or is there an unboxed-Int version of StateT somewhere?
15:52:56 <dfeuer> GHC keeps boxing my Int for some reason.
15:53:11 <chrisdone> hmm an unboxed STRef. does that make sense?
15:53:16 <dfeuer> I don't know.
15:53:50 <dfeuer> chrisdone, I'm pretty sure a version of StateT with an unboxed Int for a state makes sense.
15:53:50 <chrisdone> STRef's are polymorphic. polymorphic variables usually can only be strict, but not unboxed because the value needs to be represented as a pointer in memory
15:54:20 <chrisdone> hmm
15:54:28 <chrisdone> perhaps a custom StateT type?
15:54:32 <dfeuer> I guess.
15:54:34 <dfeuer> *barf*
15:54:50 <chrisdone> you want StateT Int# ?
15:54:56 * hackagebot network-transport-tests 0.2.2.0 - Unit tests for Network.Transport implementations  http://hackage.haskell.org/package/network-transport-tests-0.2.2.0 (TimWatson)
15:55:10 <dfeuer> Yes, I think I do.
15:55:38 <dfeuer> I'm not sure why GHC can't unbox things right with StateT Int, but maybe there's too much complicated stuff going on.
15:56:39 <brainacid> anyone interested in seeing my very first Haskell prog?
15:57:15 <sinelaw> brainacid, go ahead
15:57:25 <sinelaw> (lpaste)
15:57:54 <sinelaw> Does anyone have a good reference for type inference of non-nominal recursive types?
15:58:11 <sinelaw> In a purely functional way of course
15:58:15 <sinelaw> (no destructive pointers)
16:00:37 <catery> so is there some trick to understanding code for like Applicative (EitherIO e) like this f <*> x = EitherIO $ liftA2 (<*>) (runEitherIO f) (runEitherIO x) , which took forever just to realize that the  (<*>) in the liftA2 has type (<*>) :: Either e (a->b) -> (Either e a -> Either e b)
16:00:58 <dfeuer> chrisdone, what I really want is to pass an Int# through my ST computation, but if that means wrapping it in a custom StateTInt#, well... I guess I can try.
16:02:32 <brainacid> sinelaw
16:02:48 <sinelaw> yes?
16:03:07 <chrisdone> dfeuer: is just using an Int not performant enough?
16:03:13 <dfeuer> No, this is not going to work, is it?
16:03:53 <dfeuer> chrisdone, I'm not sure. It's annoying to see the core take the thing out, put it back in, take it out, put it back in, and all for nothing :-/
16:04:04 <dfeuer> It may be better to ignore it though.
16:04:57 <sinelaw> *too
16:05:35 <clark-ken2> Stupid yac.
16:06:45 <zzing> What is the main difference between Control and Data in the hierarchy of modules?
16:06:47 <clark-ken2> Consider another career is not a choice. I like programming, and you are just a stupid who thinks that is a smart people.
16:07:25 <brainacid> sinelaw: mdf0.blogspot.com/p/haskell.html
16:07:32 <sinelaw> zzing, given Data.Functor and Control.Applicative, I'm not sure!
16:08:02 <clark-ken2> Yac is a stupid
16:08:30 <lpaste> brainacid pasted “ExerciseCalc” at http://lpaste.net/117190
16:08:50 <brainacid> sinelaw: or the lpaste
16:09:12 <sinelaw> lpaste is much better. is there anything specific you want to know about your code?
16:09:36 <dfeuer> zzing, someone, a long time ago, got confused and thought there was a difference.
16:09:47 <ReinH> zzing: Pretty much just the names.
16:09:54 <zzing> wonderful :P
16:09:57 <dfeuer> So now our modules are randomly placed in Control or Data.
16:11:34 <brainacid> sinelaw: well not sure honestly
16:11:47 <brainacid> just began with haskell and just was practicing
16:12:03 <zzing> very good know know. merci.
16:12:05 <brainacid> if you want to give me any suggestions
16:12:23 <sinelaw> brainacid, run hlint
16:14:57 * hackagebot distributed-process-extras 0.2.0 - Cloud Haskell Extras  http://hackage.haskell.org/package/distributed-process-extras-0.2.0 (TimWatson)
16:15:42 <michaelt> brainacid: sinelaw hlint isn't saying much on the lpaste
16:15:59 <sinelaw> for one, it's saying "use zipWith"
16:16:14 <sinelaw> there isn't much to say about the code, not sure what the intention is
16:16:52 <dfeuer> chrisdone, since I'm currently violating the generational hypothesis, the garbage collector is my nemesis. The less it touches anything before I'm done, the better. However, I don't think I could actually write the unboxed StateT; I'd need to do something much much nastier and not worth it.
16:18:02 <cerberusiscute> hey guys. this is cerberusiscute. i just posted my final fibonacci sequencer (if you will) on hpaste
16:18:49 <cerberusiscute> http://lpaste.net/117191
16:18:50 <michaelt> hlint's idea of an 'error' is a little strange. Why not, e.g. "51:19: Departure from good taste: Use zipWith"
16:19:06 <sinelaw> yeah, not sure why that's an error
16:19:09 <dfeuer> michaelt++
16:19:57 <sbrg> "62:13: That's *so* last year. Use zipWith."
16:19:57 * hackagebot distributed-process-async 0.2.1 - Cloud Haskell Async API  http://hackage.haskell.org/package/distributed-process-async-0.2.1 (TimWatson)
16:20:27 <dfeuer> cerberusiscute, what happens if you calculate fib 10000 !! 4 ?
16:20:42 <cerberusiscute> uhhhhh. not sure!
16:20:49 <dfeuer> Try it.
16:20:56 <cerberusiscute> dfeuer: i'd rather not. lol
16:21:11 <dfeuer> OK, how about fib 200!!4 ?
16:21:49 <cerberusiscute> uhhhhh. okay?
16:21:56 <dfeuer> What's it do?
16:22:09 <cerberusiscute> one sec and ill find out
16:23:05 <cerberusiscute> dfeuer: it hangs... epically, if i do say so
16:23:15 <dfeuer> Kill it.
16:23:28 <cerberusiscute> I did
16:23:32 <dfeuer> Yeah.
16:23:35 <cerberusiscute> So how do I fix this?
16:23:38 <recursion-ninja> The `split` function can create 2 unique generators from one input generator. What's a good way to use `split` to get N generators from one generator?
16:23:59 <Peaker> recursion-ninja: use recursion like a ninja
16:24:05 <sbrg> Peaker: heh
16:24:26 <recursion-ninja> superSplit :: RandomGen gen => gen -> Int -> [gen]
16:24:27 <sinelaw> :O
16:24:38 <recursion-ninja> infiniteSplit :: RandomGen gen => gen -> [gen]
16:24:48 <dfeuer> cerberusiscute, you should either pick fib or fib' to focus on first. Don't mix them up.
16:24:49 <recursion-ninja> something like that
16:24:58 * hackagebot distributed-process-client-server 0.1.2 - The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-client-server-0.1.2 (TimWatson)
16:25:00 * hackagebot distributed-process-supervisor 0.1.2 - Supervisors for The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-supervisor-0.1.2 (TimWatson)
16:25:04 <recursion-ninja> my recursive technique was a little ugly
16:25:08 <cerberusiscute> dfeuer: okay... what am i focusing on?
16:25:27 <dfeuer> cerberusiscute, pick one of them first!
16:25:29 <Peaker> recursion-ninja: runState $ replicate n (state split >> get)
16:25:31 <cerberusiscute> dfeuer: i am a n00b with haskell, just to let you know
16:25:39 <dfeuer> Yes, that is okay.
16:25:39 <Peaker> recursion-ninja: replicateM that is
16:25:50 <dfeuer> cerberusiscute, let's start with fib then.
16:25:55 <cerberusiscute> dfeuer: okay
16:26:03 <dfeuer> fib' does not currently exist.
16:26:06 <sinelaw> g364
16:26:18 <cerberusiscute> uhhh.... okay. sounds good
16:26:27 <dfeuer> Er ...
16:26:28 <recursion-ninja> :t runState $ replicateM n (state split >> get)
16:26:29 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘Expr’
16:26:29 <lambdabot>     In the first argument of ‘replicateM’, namely ‘n’
16:26:29 <lambdabot>     In the second argument of ‘($)’, namely
16:26:35 <dfeuer> Sorry, cerberusiscute, I think I led you astray.
16:26:41 <dfeuer> fib is going to be hard to start with.
16:26:41 <recursion-ninja> :t runState $ replicateM 5 (state split >> get)
16:26:42 <lambdabot>     Couldn't match type ‘[a] -> [[a]]’ with ‘(a0, Splitter a)’
16:26:42 <lambdabot>     Expected type: Splitter a -> (a0, Splitter a)
16:26:42 <lambdabot>       Actual type: Splitter a -> [a] -> [[a]]
16:26:58 <brainacid> sinelaw: hlint, researching ...
16:27:29 <brainacid> Prelude Not In Scope
16:27:33 <dfeuer> cerberusiscute, start by figuring out how to define an infinite list of all the fibonacci numbers.
16:27:36 <brainacid> is it in an import?
16:27:44 <dfeuer> That's the easy path.
16:27:47 <cerberusiscute> hmmmm okay
16:27:49 <dfeuer> There are faster paths.
16:27:53 <dfeuer> But that's the easy path.
16:28:05 <cerberusiscute> hmmm
16:28:16 <dfeuer> Hint:  fibonacci = 0:1:?
16:28:36 <cerberusiscute> 1
16:28:38 <cerberusiscute> then 2
16:28:41 <cerberusiscute> then 3
16:28:43 <cerberusiscute>  then 5
16:29:05 <cerberusiscute> if you are starting at 0=0 and 1=1 that is
16:29:09 * dfeuer is probably not doing a good job right now. Paging Cale!
16:29:19 <cerberusiscute> haha okay
16:29:25 <dfeuer> But yes.
16:29:34 * cerberusiscute is not really understanding because i am useless with haskell
16:29:41 <dfeuer> cerberusiscute, suppose you already have fibonacci.
16:29:45 <dfeuer> You know the whole value.
16:29:45 <cerberusiscute> okay
16:29:48 <cerberusiscute> okay
16:29:59 <dfeuer> No, I'm being silly.
16:30:00 <dfeuer> Sorry.
16:30:04 <dfeuer> Let me find an explanation.
16:30:13 <recursion-ninja> :t get
16:30:13 <lambdabot> MonadState s m => m s
16:30:16 <cerberusiscute> dfeuer: take you time
16:30:26 <cerberusiscute> your**
16:30:45 <dfeuer> cerberusiscute, here: https://www.haskell.org/haskellwiki/The_Fibonacci_sequence
16:30:46 <cerberusiscute> dfeuer: actually, how long will you be on for?
16:30:50 <dfeuer> I don't know.
16:31:07 <cerberusiscute> i must go for now. i'm sorry to trouble you and then leave so quickly
16:31:14 <dfeuer> Arright.
16:31:38 <cerberusiscute> dfeuer: i'm really, really sorry
16:31:42 <dfeuer> Don't worry about it.
16:31:50 <cerberusiscute> see ya around (hopefully)
16:31:53 <dfeuer> Sure.
16:32:43 <recursion-ninja> Is there a way to make `runState $ replicateM 5 (state split >> get)` an infinite list instead?
16:33:06 <dfeuer> Eww... I just realized that testing my fancy new function properly will have to involve things like weak pointers and manually triggering garbage collection.
16:33:09 <dfeuer> YUCK.
16:34:03 <matematikaadit> > let fiboSeqStartFromNth n = drop n $ fix (scanl (+) 1 . (0:)) in fiboSeqStartFromNth 5
16:34:05 <lambdabot>  [8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,...
16:34:31 <dfeuer> matematikaadit, that's ... yucky. And you're not even using the matrix trick.
16:35:36 <recursion-ninja> dfeuer: a `fix` is almost always yucky
16:36:14 <dfeuer> recursion-ninja, is the Maybe (IO()) passed to mkWeak a finalizer?
16:39:16 <matematikaadit> well, I prefer this faster in the west version http://lpaste.net/116935 (from that haskellwiki page)
16:39:54 <matematikaadit> @letpaste 116935
16:39:57 <lambdabot>  Defined.
16:40:24 <matematikaadit> > fib maxBound
16:40:29 <lambdabot>  mueval-core: Time limit exceeded
16:40:29 <lambdabot>  mueval: ExitFailure 1
16:41:06 <matematikaadit> > fib 10000
16:41:08 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
16:41:31 <int-e> > length $ show $ fib 10000
16:41:32 <lambdabot>  2090
16:41:33 <eriksensei> what sort of notation is (-) in "the endofunctor 1+(-) on the category of sets"? i'd like to understand precisely what it means, where it comes from and what it's called. (and a merry xmas to everyone!)
16:42:34 <triliyn> eriksensei: I believe the (-) is to be treated as a placeholder for the function's argument
16:42:44 <triliyn> So it's the endofunctor that maps x to 1+x
16:42:47 <lpaste> brainacid revised “ExerciseCalc”: “No title” at http://lpaste.net/117190
16:42:54 <triliyn> *functor's argument
16:44:04 <brainacid> any sugar for this bInfo		:: EInfo -> EInfo -> EInfo
16:44:05 <triliyn> ...though I'm not sure what + is supposed to mean, in the category of sets
16:44:12 <eriksensei> triliyn: ah, so it's a bit like Scala's _ then. Good to know, thanks!
16:44:15 <eriksensei> coproduct
16:44:25 <eriksensei> ie disjoint union
16:44:38 <triliyn> eriksensei: yeah, probably. Also similar to Clojure's %
16:44:39 <brainacid> bInfo a b =  concat $ zipWith (\x y -> ["\n",x,"\t",y]) a b
16:44:41 <triliyn> ahh, makes sense
16:46:56 <triliyn> brainacid: not really sugar, but it might be slightly easier to write bInfo = zipWith (\x y -> "\n" ++ x ++ "\t" ++ y)
16:47:49 <int-e> triliyn: but that's not the same.
16:48:34 <int-e> > let bInfo a b =  concat $ zipWith (\x y -> ["\n",x,"\t",y]) a b in bInfo ["a","b","c"] ["x","y","z"]
16:48:35 <triliyn> oh, hmm
16:48:35 <lambdabot>  ["\n","a","\t","x","\n","b","\t","y","\n","c","\t","z"]
16:48:40 <triliyn> I see
16:48:48 <int-e> but is that intended?
16:51:09 <nkar> joeyh: when does one need to generate shell code?  do you have a usecase in mind?  why not just use shell-conduit or some such?
17:00:25 <joe9> haskell programming structure: sometime ago, my programs used to have one big IO subroutine and lots of small pure functions. Recently, I practised Typeclassopedia, since then, I have lots of little IO or monadic functions instead of one big IO subroutine. Is this a good practice?
17:01:01 <solrize> better to have a small outermost IO action calling lots of pure functions
17:02:17 <tac_> A lot of programs can't be structured so cleanly into IO-calls-pure. You often have to dig a bit to figure out how much persistent state your program needs
17:02:31 <tac_> but IO calls pure is the ideal
17:04:28 <brainacid> triliyn: ok cool thanks a lot!!!!
17:05:24 <triliyn> brainacid: see int-e's correction; mine isn't quite the same as what you wrote
17:05:44 <triliyn> But if it's what you wanted, then great!
17:17:38 <brainacid> triliyn: both ways same output different Type
17:17:59 <brainacid> one with t [[Char]] and other [Char]
17:18:08 <brainacid> lol
17:18:13 <brainacid> love Haskell
17:47:01 <dfeuer> I'm trying to use weak references to see what's getting collected, but I'm doing something wrong. Can someone help?
17:47:21 <johnw> "wrong" in what sense?
17:47:51 <dfeuer> johnw, wait a sec...
17:48:35 <dfeuer> johnw, there's just no way it's been collected but I'm seeing it collected.
17:48:51 <johnw> um
17:49:09 <dfeuer> Shall I lpaste?
17:49:12 <johnw> sure
17:49:41 <lpaste> dfeuer pasted “Weak weakness” at http://lpaste.net/4148526301528981504
17:50:11 <dfeuer> There may be some extra imports.
17:50:33 <johnw> and what is the behavior that you see, and what do you expect?
17:50:58 <dfeuer> What I'm trying to do is figure out whether the array I'm sticking into fooArray has been collected on line 20.
17:51:08 <dfeuer> I'm expecting to see True (meaning not collected)
17:51:17 <dfeuer> and I'm seeing False, which I'm interpreting as collected.
17:51:17 <johnw> why would it not be collected?
17:51:27 <dfeuer> Because fromArray is lazy.
17:51:38 <dfeuer> Well, fairly lazy.
17:52:02 <dfeuer> fromArray should be in whnf once it gets the first few and the last few elements of the array.
17:52:11 <lpaste> brainacid revised “ExerciseCalc”: “v1.2” at http://lpaste.net/117190
17:52:15 <dfeuer> If even those.
17:52:45 <johnw> but you cleared out fooArray
17:52:49 <sbrg> Is there a way for me to ask lambdabot to only pass, say, unsigned integers to @check?
17:53:24 <dfeuer> johnw, right, but the array itself should still be live.
17:53:32 <johnw> but why?
17:53:42 <dfeuer> Because sq should have thunks pointing to it.
17:54:02 <johnw> I wonder if it works that way
17:54:09 <johnw> or if the accesses are strict?
17:54:14 <johnw> have you checked the Core?
17:54:28 <dfeuer> Wait, one more idea....
17:54:46 <johnchang> I have a list of lists: [[“name1”,acctno1,bal1],[“name2”,acctno2,bal2],…] I want to consolidate (sum) all the balances with the same name and account number to get an abbreviated list. I can see that sorting the list (sortBy compare list) would make this easier, but I’m stuck. What’s a short program that will do this?
17:54:46 <dfeuer> johnw, I think I know the problem!
17:55:28 <dfeuer> Could it be that the Array is dead but the Array# is alive?
17:56:20 <johnw> that sounds about right, actually
17:56:36 <ski> @check \n -> sqrt n >= 0
17:56:38 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 1077 shrinks):
17:56:38 <lambdabot>  -5.0e-324
17:56:40 <ski> @check \n -> (n >= 0) ==> (sqrt n >= 0)
17:56:42 <lambdabot>  +++ OK, passed 100 tests.
17:56:54 <ski> sbrg ^
17:56:56 <dfeuer> Foo. Is there a way to make a weak reference to the actual Array#?
17:59:44 <dfeuer> johnchang, yeah, the Core confirms it. It strips off the Array wrapper. Silly me!
18:03:44 <johnchang> The Core? I think recursively using a mess of heads and tails, along with a list constructor : might do it.
18:04:31 <johnchang> Somehow I feel like it’s not very pretty to do it that way though.
18:05:11 <johnchang> The list elements are all the same, 3 elements, a string, and two numbers.
18:05:23 <chip_buster> johnchang could you use a lookup table and just modify the table?
18:05:31 <chip_buster> so if the name / acct# are not in the table, insert into table
18:05:36 <chip_buster> otherwise, modify existing entry
18:05:40 <johnchang> The list is very long. There is no insertion.
18:05:51 <exio4> what? how do you modify a list?
18:06:00 <exio4> ;P
18:06:35 <johnw> johnchang: I'd do it with a fold over a Map String (Int,Int) something like that
18:06:42 <johnw> then render the map back out to the list, if you need it in that form
18:07:06 <johnchang> Sounds good, but that’s over my head. Can you be more explicit?
18:07:54 <solatis> @fmap
18:07:54 <lambdabot> Maybe you meant: slap faq
18:08:01 <solatis> :t fmap
18:08:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:08:18 <dfeuer> johnw, it looks like no, there's no way to make a weak pointer to an unboxed type. So my whole grand plan to test fromArrayMonolithic just went down the toilet. Is there an easy way to ask the RTS for my current memory residency? I might be able to do something with that.
18:08:56 <johnw> map (\(k,(x,y)) -> (k,x,y)) $ toList $ foldl' (\acc (name,acct,bal) -> case lookup name acc of Just (acct',bal') -> insert name (acct,bal + bal'); Nothing -> insert name (acct,bal)) mempty <list of data>)
18:09:49 <johnw> you can probably remove the two inserts and use "adjust" or "update" instead
18:10:04 <johnw> (lens has an even better way to do it, but I don't want to complicate things)
18:10:20 <johnchang> Well, the list is fixed, and won’t be updated, so I don’t need to create a lookup table. I’m thinking that if the list is sorted, you can just look at adjacent elements and add them if they have the same name and acct number.
18:11:09 <johnchang> johnw, that’s an impressive expression, but I don’t understand it… I guess I can try it though!
18:12:07 <johnw> I'm folding over the input list, aggregating the results into a Map (which is a good structure for this kind of update-based task), and then rendering the map back out into the same form as the original list
18:25:22 <exio4> is there any function like this?
18:25:25 <exio4> (>:<) :: (a -> c -> x) -> (b -> d -> y) -> (a,b) -> (c,d) -> (x,y)
18:25:27 <exio4> f >:< g = \(a,b) (c,d) -> (f a c, g b d)
18:25:48 <exio4> (this is the one I defined, and wonder if something like this already exists in some library)
18:28:40 <ski> @type Data.Map.insertWith
18:28:41 <lambdabot> Ord k => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
18:28:54 <ski> @type Data.Map.fromListWith
18:28:55 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
18:29:26 <ski> johnchang,johnw : perhaps use one of those ^ ?
18:33:43 <ski> johnchang : do you only want to consolidate entries having *both* the same name *and* account number ?
18:33:59 <johnchang> yes
18:35:00 <johnchang> ski : yes. Both name and account number need to be the same to add the balances.
18:35:18 <solatis> is it possible to suspress a warning for a single line of code only ? specifically, 'default initialization' warnings on a Maybe i'm getting is incredibly annoying
18:35:26 <solatis> or is it a sign of bad design if i do this ?
18:35:48 <ski> johnchang : is it possible to have two entries with same account number but different names ? same name but different account number ?
18:35:50 <solatis> or, can i provide a default value myself ?
18:36:10 <byorgey> solatis: what is a default initialization warning? for a record?
18:36:11 <christmasdotcode> solatis: can you give an example?
18:36:33 <solatis> one moment
18:36:34 <johnchang> ski: the account numbers are not unique. In fact there are only a few account numbers.
18:36:38 <byorgey> solatis: it is definitely bad design to create a record value without initializing some of the fields
18:38:07 <lpaste> solatis pasted “No title” at http://lpaste.net/117197
18:38:14 <solatis> ^^
18:38:21 <johnchang> ski: a name can have more than one account number. In fact it can be associated with all the account numbers.
18:39:02 <solatis> i suppose i have to manually create a 'constructor' function myself to get rid of the warnings ?
18:39:21 <christmasdotcode> solatis: constructPeer id addr = Peer id addr Nothing
18:39:31 <christmasdotcode> or Peer id addr Nothing yourself.
18:39:45 <solatis> yeah i know, but I want to reduce the 'Nothing' boilerplate
18:39:56 <christmasdotcode> You can always make the data constructor opaque and not import it ...but I don't like when libraries do that.
18:40:07 <christmasdotcode> solatis: It's not boilerplate, strictly speaking.
18:40:07 <solatis> s/import/export/ ?
18:40:16 <christmasdotcode> Yes, my bad.
18:40:29 <solatis> well this is an internal data structure anyway
18:40:38 <christmasdotcode> If you want to, I think Maybe has Nothing as a data.default instance
18:40:45 <christmasdotcode> so you could always: Peer id addr def
18:40:46 <solatis> but i have like a bazillion test cases that create this structure with .. Nothing
18:40:58 <ski> @type \f g -> curry ((uncurry f *** uncurry g) . ((fst *** fst) &&& (snd *** snd)))
18:40:59 <lambdabot> (a -> b -> c) -> (a1 -> b1 -> c') -> (a, a1) -> (b, b1) -> (c, c')
18:41:09 <christmasdotcode> I think you best solution is constructPeer
18:41:11 <christmasdotcode> Or
18:41:12 <solatis> i think i will follow the suggestion at https://www.haskell.org/haskellwiki/Default_values_in_records
18:41:37 <johnchang> johnw: I’m not sure which libraries to import to support the functions foldl’, toList, insert, and mempty. At least, ghc complains that they’re “Not in scope”.
18:42:00 <solatis> that even allows one to override the defaults
18:42:01 <exio4> ski: that one is clever!
18:42:14 <ReinH> johnchang: You can find them with hoogle. Some might be from Data.Foldable and Data.Monoid
18:42:33 <ski> johnchang : so you definitely need both name and account number to disambiguate, correct ?
18:42:51 <johnw> Data.List, Data.Map, Data.Monoid
18:43:03 <ski> (in relational database terminology : they both together form a key)
18:43:11 <johnchang> ski: correct
18:43:23 <ski> exio4 : i'd call the `(fst *** fst) &&& (snd *** snd)' part `mix'
18:43:41 <dfeuer> Ooooof. I did something stuuuuuupid.
18:45:35 <johnchang> johnw: ambiguous occurences for map, foldl’, lookup, insert. They’re all in both Data.Map and Data.List.
18:45:55 <johnw> hide lookup/insert from Data.List
18:46:03 <johnw> hide map from Data.Map
18:47:19 <ski> johnchang : something like `map (\((name,acctNo),bal) -> (name,acctNo,bal)) . toList . fromListWith (+) . map (\(name,acctNo,bal) -> ((name,acctNo),bal))', i think
18:47:56 <johnchang> johnw: foldl’? Sorry to have to be handheld like this, but this really is new to me.
18:48:08 <johnw> Data.List.foldl'
18:48:12 <johnw> the strict version of foldl
18:48:17 <ski> johnchang : that is using `(name,acctNo)' pairs as keys in the finite map, combining values (`bal'ances) with the same key using `(+)'
18:48:45 <johnchang> ski: I’ll try… That one looks like something I could write, except for fromListWith.
18:49:31 <ski> johnchang : this assumes that you'll feed in a list of triples, and that you want to get out a list of triples
18:49:44 <johnchang> ski: yes, that’s what I want.
18:50:08 <ski> if you want to feed in a list of lists, each having three elements, you need to adapt the latter `map' call
18:50:26 <johnchang> ski : these are not tuples, they’re a list of lists.
18:51:01 <johnchang> oops. can’t be. sorry
18:51:40 <ski> (but i suggest using either a triple, or a new data type (possibly using record syntax), to represent your entries, rather than using lists with three elements, having distinct roles)
18:52:20 <johnchang> Yes, I was hoping to avoid having to learn about records just to perform this seemingly simple task.
18:52:47 <michaelt> bah, this 'reflection without remorse' scheme is seeming like kind of a dog ...
18:52:49 <ski> .. e.g., if you have lists, each containing three strings, then you can't use `(+)' (directly) to add the balances. you need to convert that part to a number first
18:53:11 <ski> and then you can't have it in a *list* together with a name (assuming it's a string)
18:53:33 <ski> the elements of a list must all have the same type. the components of a tuple can have distinct types
18:53:46 <johnchang> understood. that’s why I said oops, can’t be.
18:54:12 <ski> a triple would be fine here, i think. record syntax can be nicer when you have more fields
18:54:33 <johnchang> I agree.
18:54:52 <mseeks> is there a good point-free way to write f, where f x = (x, x)?
18:55:02 <zq> f = (,)
18:55:08 <zq> wait no
18:55:08 <ski> no
18:55:13 <zq> there's a biapp
18:55:17 <ski>   f = join (,)
18:55:46 <mseeks> oh awesome
18:55:47 <mseeks> thanks!
18:55:50 <ski> @pointless f x = (x,x)
18:55:50 <lambdabot> f = join (,)
18:56:28 <ski> you'll need the `instance Monad (rho ->)' for that
18:56:41 <ski> i think it's in `Control.Monad.Reader'
18:57:03 <exio4> i
18:57:12 <exio4> I think it is loaded by Prelude *
18:57:13 <ski> .. some people think using this can be confusing, though
18:57:31 <ski> exio4 : perhaps it has changed
18:57:45 <exio4> instance Monad ((->) r) -- Defined in `GHC.Base'
18:57:50 <AlecTaylor> hi
18:58:33 <AlecTaylor> Giving a function too many arguments, how do I push the arguments to the next line? - E.g.: putStrLn("foo"++
18:58:35 <AlecTaylor> "bar")
18:58:44 <ski> in GHC 7.4.2 at least, you need to import what i said
18:59:08 <ski> AlecTaylor : indent the second line
18:59:24 <ski> AlecTaylor : .. or are you asking about an interactor, like GHCi ?
19:00:09 <johnchang> ski: ghc complains “Could not find module ‘Data.Map.Strict’ (which is what I imported, based on what hoogle said). What do I do?
19:01:39 <LordBrain> hoogle local, or hoogle  on the web?
19:02:08 <johnchang> https://www.haskell.org/hoogle/?hoogle=fromListWith
19:02:21 <SharpGAF> For someone who just wants to get dive into Haskell over the next four days or so, (a) can I expect to cover much, and (b) what would be a good resource for doing so?
19:02:34 <SharpGAF> s/get//
19:02:39 <LordBrain> it says IntMap.Strict
19:03:20 <johnchang> LordBrain: That doesn’t work either.
19:03:28 <LordBrain> SharpGAF, well, the answer varies depending on background of course
19:03:46 <SharpGAF> LordBrain: I've been doing a lot of Rust over the past year, done some SML, Lisp, C, Prolog, etc.
19:03:50 <SharpGAF> Just haven't done Haskell specifically.
19:03:51 <michaelt> johnchang: something is wrong, these modules come with ghc as 'boot libraries'
19:04:03 <LordBrain> shouldn't have too much trouble covering a lot of ground
19:04:20 <SharpGAF> What would be a good resource?  Learn You a Haskell?
19:04:24 <michaelt> johnchang: does ghc-pkg list show 'containers' somewhere?
19:04:56 <LordBrain> sure, whatever any tutorial is a starting place.
19:05:31 <SharpGAF> Cool, thanks!
19:05:34 <LordBrain> as a good resource, i think once you get going, you can focus on your area of interest more, i think with your background that will work out okay
19:06:19 <johnchang> I’m running ghc 7.4.1. I guess I should update?
19:06:31 <LordBrain> you're on wheezy i bet
19:06:56 <michaelt> johnchang: oh god yes what os are you using
19:07:10 <LordBrain> debian wheezy shipped with 7.4.1
19:07:57 <erisco> I seem to have run into this same problem trying to install cabal http://web.archiveorange.com/archive/v/2Kx35SzBxgS1h2IFHHmy
19:09:46 <michaelt> erisco: how much would break if you unregistered the old network and installed a new one (and then also network-uri)
19:10:20 <LordBrain> johnchang, if you want to stay on debian wheezy until jesse is released, my personal favorite thing is to rebuild these ubuntu  packages here which install into /opt: https://launchpad.net/~hvr/+archive/ubuntu/ghc
19:11:21 <michaelt> johnchang: it's very easy to install ghc by hand locally with the bindists on the ghc page https://www.haskell.org/ghc/download_ghc_7_8_4#x86linux or maybe LordBrain knows better
19:11:56 <LordBrain> just download the package source, and run DEB_BUILD_OPTIONS='parallel=8' dpkg-buildpackage, replace 8 wiht the number of cores on your machine.
19:12:13 <michaelt> erisco that is, does 'ghc-pkg unregister network' tell you 'no way, you'll break everything'
19:12:18 <zq> there's a 784 now?
19:12:34 <zq> ohwow
19:12:59 <erisco> michaelt, HTTP-4000 would break evidently
19:13:02 <zq> here's hoping -fllvm works with 3.5
19:13:30 <michaelt> hm, that might be okay you would have to unregister it too, then reinstall it, network and network-uri
19:13:37 <erisco> michaelt, I have unregistered HTTP-4000 and network
19:13:42 <LordBrain> you cant use the binary because they are built against the libc in ubuntu... but they recompile without issue..
19:14:31 <michaelt> erisco: but you're still ending with network-uri disaster?
19:15:24 <erisco> michaelt, well I don't know how to use ghc-pkg so I don't know how to reinstall the packages at the moment
19:15:40 <AlecTaylor> Am I doing too much type-casting and having too many parentheses? - http://ideone.com/UlX4MP
19:16:03 <michaelt> erisco: oh, after doing ghc-pkg unregister bad-version-of-whatever you just cabal install, perhaps with constraints
19:17:25 <LordBrain> the packages that i suggested let you have multiple ghc versions installed at once, which is handy
19:17:38 <srhb> AlecTaylor: If anything I'd complain more about using !!
19:18:04 <srhb> AlecTaylor: But in a test program like this it's hard to criticize anything.
19:18:05 <AlecTaylor> Whoops, now there's more error output: http://ideone.com/UlX4MP
19:18:34 <AlecTaylor> srhb: I'd rather start off writing Haskell properly than falling into code-smells
19:18:44 <erisco> michaelt, but I do not have cabal, that is what I am trying to install in the first place
19:18:52 <srhb> AlecTaylor: otoh you may be fine with crashing the program on its arguments being wrong. After all, you probably want to stop there anyway if the arguments ARE wrong.
19:18:54 <michaelt> oh oh oh
19:19:30 <srhb> AlecTaylor: But yeah, ))))) looks too lispy in my opinion. :)
19:20:02 <AlecTaylor> Yeah
19:20:06 <michaelt> erisco: doesn't the git repo for cabal-install have versions of these for bootstrap.sh to use?
19:20:08 <AlecTaylor> would be good to throw in some error handling also
19:20:19 <srhb> AlecTaylor: One thing you could do to alleviate that is to introduce a let block giving names (and types) to each of those read' arguments.
19:21:03 <erisco> michaelt, bootstrap.sh failed
19:21:05 <AlecTaylor> srhb: But I still need to covert the types for the concatenation, write?
19:21:08 <AlecTaylor> *right?
19:21:12 <erisco> with the error, the same one I linked to
19:21:51 <gazay> Hello! Is there any other way to publish somewhere own library with docs except way described here https://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
19:22:14 <srhb> AlecTaylor: let arg1ButSensibleName = arg !! 0; arg2 = arg !! 1; arg3ButConverted = (read $ arg !! 2) :: Int ...
19:22:24 <gazay> I mean some simple way like in ruby - gem build some.gemspec and gem push ready_gem
19:22:25 <ski> SharpGAF : you could try the "Gentle Tutorial", since you've already done some FP and LP
19:22:40 <SharpGAF> ski: Hm, what's that?
19:23:30 <AlecTaylor> srhb, http://ideone.com/UlX4MP
19:23:56 <srhb> AlecTaylor: Something like that. Of course, you'll still crash horribly if there aren't enough args.
19:24:02 <srhb> Or they cannot be read to the right types.
19:24:07 <SharpGAF> ski: https://www.haskell.org/tutorial/ ?
19:24:09 <AlecTaylor> Yeah
19:24:42 <AlecTaylor> srhb: For now though, how do I get this code to work?
19:24:53 <srhb> AlecTaylor: Also in a do block you can introduce let bindings like let name = foo <newline> name2 = bar <newline> ...
19:24:53 * AlecTaylor would then like to throw in clean error handling
19:24:56 <srhb> With proper indentation
19:25:02 <michaelt> erisco, hm ... did you download the hackage tarball for the version of cabal-install that corresponds by number with the version of Cabal shown by "ghc-pkg list Cabal"
19:25:25 <AlecTaylor> srhb: Recheck that ideone code
19:25:27 <AlecTaylor> I did that!
19:25:38 <AlecTaylor> I think
19:25:54 <srhb> AlecTaylor: http://lpaste.net/6071228017139515392
19:25:55 <AlecTaylor> Or were you saying to only use one `let`?
19:26:03 <srhb> AlecTaylor: Yes, only one let
19:26:03 <erisco> michaelt, it lists 1.18 and 1.20
19:26:30 <michaelt> hm, but one of them is local, the other global
19:27:13 <michaelt> were you trying to get a newer cabal or just any cabal, erisco
19:27:15 <srhb> AlecTaylor: http://lpaste.net/6903392460613877760 -- killed some parantheses
19:27:25 <ski> SharpGAF : yes
19:27:28 <solatis> anyone here has any experience working with raw sockets & haskell?
19:27:31 <solatis> https://hackage.haskell.org/package/network-2.6.0.2/docs/Network-Socket.html#t:SockAddr
19:27:34 <AlecTaylor> So something like this srhb - http://ideone.com/UlX4MP
19:27:49 <solatis> i'm curious to what i am supposed to provide for SockAddrInet6 FlowInfo and ScopeID ..
19:27:51 <erisco> michaelt, hm, I don't know when cabal would have been installed before, all I had installed was the ghc package from the Ubuntu repos
19:28:01 <erisco> michaelt, I am trying to install ghc 7.8.3 now instead
19:28:07 <srhb> AlecTaylor: Something like my last paste.
19:28:32 <SharpGAF> ski: Thanks, this seems like what I was looking for :)
19:28:34 <erisco> I will just nuke ~/.ghc and reinstall ghc
19:28:45 <michaelt> erisco: oh. but the capital C Cabal library will come with your ghc ; it is the executable cabal-install we are worried about.
19:29:41 <AlecTaylor> Getting close: http://ideone.com/UlX4MP
19:29:47 <ski> SharpGAF : note that it's a little old, so it doesn't cover recent library stuff, nor recent language extensions. but it should hopefully get you up to the basics
19:29:58 <AlecTaylor> Can't see what's wrong with that last one srhb
19:30:00 <SharpGAF> Yeah, from the date I figured it wouldn't cover GHC extensions
19:30:10 <srhb> AlecTaylor: Nothing.
19:30:19 <SharpGAF> But I figure I should familiarize myself with the core language before wading into the deep end.
19:31:20 <srhb> AlecTaylor: I'd probably align the two shows after putStrLn, so it looks nice...
19:31:30 <srhb> AlecTaylor: But other than that (and no error handling) everything is fine
19:31:51 <AlecTaylor> How do I error handle in Haskell?
19:32:05 <srhb> AlecTaylor: Depends. Have you read a Haskell book?
19:32:13 <AlecTaylor> I'm going through the Scheme tutorial ATM
19:33:07 <srhb> AlecTaylor: You should probably read one of the introductory tests first. What you might do is check whether there are enough arguments, check whether they can be parsed as Int, and then conditionally deal with the situation. The Maybe monad might be useful for this.
19:33:11 <erisco> michaelt, I removed ~/.ghc and now ghc-pkg list Cabal only lists one version, 1.18
19:33:11 * AlecTaylor is up to the end of the first lesson - https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/First_Steps
19:33:21 <erisco> so I will get that version and try again
19:33:23 <srhb> AlecTaylor: I suggest reading LYAH or something similar to start with.
19:33:37 <srhb> AlecTaylor: And then a document on error handling with Maybe or Either. :)
19:34:05 <AlecTaylor> kk
19:37:13 <brainacid> where am i misunderstanding
19:37:19 <brainacid> cCol	:: EInfo -> EInfo -> EInfo -> [String]
19:37:19 <brainacid> cCol m ms mx   	= concat $ zipWith (\x y z -> "\n" ++ x ++ "\t" ++ y ++ "\t" ++ z) m ms mx
19:37:38 <brainacid> EInfo :: [[Char]]
19:38:22 <pavonia> zipWith only works on two lists
19:38:26 <pavonia> :t zipWith
19:38:27 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
19:38:34 <pavonia> :t zipWith3
19:38:35 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
19:39:11 <michaelt> erisco, right thats the one that came with the compiler.  it is probably as well to try to install the cabal-install the corresponds to its version number
19:40:25 <michaelt> erisco: so see if the bootstrap.sh that comes with the tarball you can download from the hackage cabal-install page for it
19:40:27 <erisco> michaelt, I could not find the exact version number but I grabbed the latest 1.18
19:40:59 <michaelt> i think that should work
19:41:21 <ski> brainacid : `cCol m ms mx = unlines (intercalate "\t" (transpose [m,ms,mx]))' ?
19:41:46 <michaelt> erisco: you just don't want it to try to install a different Cabal library.
19:42:16 <ski> brainacid : sorry, replace `intercalate "\t"' by `map (intercalate "\t")'
19:42:19 <michaelt> erisco: in fact it isnt too grave to have two versions, but one should start with one...
19:42:35 <Zemyla> Question about GADTs.
19:42:50 <erisco> michaelt, same error darn
19:43:08 <Zemyla> Is it possible to have Read work correctly for SetM here? http://okmij.org/ftp/Haskell/set-monad.html
19:43:27 <brainacid> ski: sweetness let me check thanks a lot
19:43:33 <michaelt> erisco: grrr
19:47:42 <ski> brainacid : as pavonia said, `zipWith3' also works. i just provided an alternative
19:50:09 <ski> Zemyla : `instance Ord a => Read (SetM a)' may work
19:51:04 <sccrstud92> anyone found a good way to automatically add a cabal sandbox bin folder to the path? perhaps only when the current directory is the sandbox pr subdirectory
19:51:45 <erisco> evidently using 7.8 on Ubuntu is nontrivial
19:52:20 <brainacid> thanks pavonia ski
19:52:27 <brainacid> this is my first definition script
19:55:04 <ski> > transpose [["0","1","2","3"],["@","a","b","c"],["zero","one","two","three"]]
19:55:05 <lambdabot>  [["0","@","zero"],["1","a","one"],["2","b","two"],["3","c","three"]]
19:55:17 <ski> shows what `transpose' does
19:55:23 <brainacid> thanks ski
19:56:03 <ski> > unlines ["This","is","a","dream"]
19:56:04 <lambdabot>  "This\nis\na\ndream\n"
19:56:47 <ski> > intercalate "\t" ["title","year","author"]
19:56:48 <lambdabot>  "title\tyear\tauthor"
19:57:16 <ski> brainacid : note that `unlines' adds `\n's to the end of each line, not to the start
19:57:43 <ski> `map f' does `f' to each element of a list
19:58:14 <matematikaadit> :t concatMap ('\n' ++)
19:58:15 <lambdabot>     Couldn't match expected type ‘[b]’ with actual type ‘Char’
19:58:15 <lambdabot>     In the first argument of ‘(++)’, namely ‘'\n'’
19:58:15 <lambdabot>     In the first argument of ‘concatMap’, namely ‘('\n' ++)’
19:58:24 <ski> > map f [0,1,2]                     :: [Expr]
19:58:25 <lambdabot>  [f 0,f 1,f 2]
19:58:27 <matematikaadit> :t concatMap ('\n':)
19:58:28 <lambdabot> [[Char]] -> [Char]
19:58:46 <ski> > map even [0,1,2]
19:58:47 <lambdabot>  [True,False,True]
19:59:07 <matematikaadit> > concatMap ('\n':) ["Hello", "World"]
19:59:08 <lambdabot>  "\nHello\nWorld"
19:59:17 <ski> > let square x = x*x in map square [0,1,2]
19:59:19 <lambdabot>  [0,1,4]
19:59:31 <ski> > map (\x -> x*x) [0,1,2]
19:59:32 <lambdabot>  [0,1,4]
19:59:53 <ski> > [x*x | x <- [0,1,2]]
19:59:54 <lambdabot>  [0,1,4]
20:00:44 <lpaste> brainacid revised “ExerciseCalc”: “FINAL” at http://lpaste.net/117190
20:02:12 <matematikaadit> brainacid: if you wanna add '\n' to the start of each line, you could use `concatMap ('\n':)` instead of `unlines`
20:04:04 <brainacid> Thank You Very Much pavonia ski michaelt triliyn sinelaw c_wraith Cale kadoban shiona Saizan barrucadu JonReed matematikaadit
20:05:50 <lpaste> brainacid revised “ExerciseCalc”: “FINAL w/ SHOUTS” at http://lpaste.net/117190
20:07:02 <erisco> michaelt, oddly 1.20.0.3 specifically worked
20:07:33 <michaelt> erisco: oh, did it install a second version  of Cabal lib?
20:09:04 <erisco> michaelt, yes
20:10:01 <michaelt> erisco: ah ok. I occasionally get some weirdness from that, I think; though dcoutts says it shouldnt be a problem
20:10:23 <michaelt> erisco, great
20:29:08 <brainacid> Good Nite!
20:43:05 <SharpGAF> Is Haskell's list sugar ([1,2,3]) hardcoded to work with linked lists, or can it be used for other types?
20:43:38 <SharpGAF> e.g. can you use list comprehension with an array?
20:44:55 <BrianHV> SharpGAF: never tried them myself, but look into OverloadedLists and MonadComprehensions. they *might* do what you want.
20:45:14 <SharpGAF> I will, thanks.
20:47:14 <shachaf> SharpGAF: [1,2,3] isn't a list comprehension, but the GHC extension OverloadedList will turn it into something like (fromList l :: IsList a => a), where l is the real list [1,2,3]
20:47:16 <ski> SharpGAF : for parallel haskell, there's syntax for parallel arrays
20:47:33 <shachaf> It's not really optimal for the kinds of lists you might want but it works for some cases.
20:48:12 <SharpGAF> Yeah, I'm reading about it, sounds like the list notation extension is separate from comprehension
20:48:35 <SharpGAF> ski: Hm, is a parallel array considered a separate type?
20:48:59 <shachaf> Yes, there's also overloading for the comprehension notation, which BrianHV mentioned.
20:50:23 <ski> SharpGAF : yes, see <https://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell>
20:50:51 <SharpGAF> Cool, thanks.
20:54:05 <SharpGAF> Whoa, generalized list comprehensions look nice.
20:57:42 <Lokathor> concat :: [[a]] -> [a], which removes one level of nesting, but is there a way to convert an arbitrarily nested list into a non-nested list without knowing about the depth of the nesting ahead of time?
20:59:18 <pavonia> Not for the standard list type
20:59:46 <shachaf> Lokathor: There's no such thing as an arbitrary nested list, really.
21:00:12 <shachaf> But Free [] is a pretty close approximation, and there is something :: Free [] a -> [a]
21:00:35 <shachaf> It's called retract, right.
21:01:17 <SharpGAF> Can Haskell enforce associativity in the type system?
21:01:51 <shachaf> That depends on what you mean.
21:02:32 <SharpGAF> Can it enforce for some function f that (f a (f b c)) = (f (f a b) c)?
21:03:04 <SharpGAF> It mentions that parallel arrays take an undirected fold function that requires "an associative function" as an argument
21:03:04 <shachaf> No, not easily.
21:03:17 <SharpGAF> I assume that that construction can only be correct if f is actually associative
21:03:20 <benzrf> SharpGAF: you can do that with dependent typing
21:03:22 <shachaf> Sounds right.
21:03:28 <benzrf> you cannot do that in haskell
21:03:33 <SharpGAF> Okay, cool
21:03:33 <benzrf> as far as i am aware
21:03:56 <SharpGAF> Sorry, I'm new, just not sure what the limits of the type system are with all the GHC extensions.
21:04:11 <benzrf> idris has a hierarchy of algebraic classes like Monoid and Group and in parallel it has VerifiedMonoid and VerifiedGroup, etc
21:04:17 <SharpGAF> Ah, neat.
21:04:22 <benzrf> where the Verified versions are subclasses whose methods are proofs
21:04:35 <benzrf> so a VerifiedMonoid instance really is a monoid, guaranteed
21:04:47 <benzrf> unless youre fucking with the type system using unsafeCoerce or believe_me
21:05:51 <benzrf> SharpGAF: even with all the extesions you cannot do pi types
21:06:03 <benzrf> you can have values at the type level yes
21:06:10 <SharpGAF> Pi types?
21:06:23 <benzrf> but in haskell, at the current moment, there is no way to have values cross to the type level from below
21:06:28 <benzrf> SharpGAF: uh,
21:06:46 <benzrf> replicate : a -> (x : Nat) -> Vec x a
21:07:06 <benzrf> dependent product
21:07:14 <benzrf> it corresponds to forall the same way -> corresponds to implies
21:07:44 <benzrf> you can bind the hypothetical value that gets passed in and then use it to the right of the arrow
21:08:15 <benzrf> so the return type of replicate is Vec x a, where x is the actual Nat you pass in
21:08:18 <dfeuer> Durrr
21:08:28 <SharpGAF> I don't think I know enough Haskell yet to understand, but let me try :)
21:08:34 <benzrf> oh
21:08:37 <benzrf> SharpGAF: ok, basically
21:08:38 <ski> that's not Haskell
21:08:42 <SharpGAF> I know
21:08:43 * dfeuer does not know enough.
21:08:46 <benzrf> the really big important thing that dependent typing does is
21:08:51 <benzrf> merge the type and value level
21:08:56 <benzrf> there are no kinds anymore
21:08:59 <benzrf> types are just values of type Type
21:09:16 <benzrf> so that means you're allowed to do things like define a type constructor that takes a nat as an argument
21:09:17 <SharpGAF> So something can have type 2?
21:09:23 <benzrf> SharpGAF: no, 2 is not a type
21:09:29 <benzrf> if f : t, then t : Type
21:09:32 <benzrf> at least, in Idris
21:09:44 <benzrf> anyway
21:09:52 <benzrf> type constructors like Maybe are basically functions from types to types
21:09:57 <SharpGAF> But if a type constructor can take a Nat as an argument, and 2 :: Nat, doesn't that make 2 a type?
21:10:10 <benzrf> good question
21:10:18 <benzrf> it's because it's no longer forced to take types as arguments!
21:10:24 <SharpGAF> Ah, okay ;)
21:10:29 <benzrf> since types and values are now the same thing, type constructors can be parametrized by values
21:10:32 <benzrf> so
21:10:37 <benzrf> Vec : Nat -> Type -> Type
21:10:49 <benzrf> Vec 3 String <- type of lists of strings of length 3
21:10:57 <benzrf> well, vectors
21:10:57 <SharpGAF> That's neat.
21:11:01 <benzrf> indeed
21:11:13 <benzrf> you can actually do somethign a lot like this in haskell with enough extensions already
21:11:19 <benzrf> now, here's the thing you CAN'T do:
21:11:26 <zq> pi types
21:11:35 <benzrf> unitVec : (x : Nat) -> Vec x ()
21:11:38 <benzrf> er
21:11:41 <benzrf> unitVec : (x : Nat) -> Vec x Unit
21:11:50 <benzrf> i think it's called Unit instead of () in idris
21:11:59 <benzrf> because otherwise you confuse () the value with () the type
21:12:07 <benzrf> anyway, check out that type
21:12:11 <benzrf> what's happening here is
21:12:14 <benzrf> this means
21:12:20 <benzrf> unitVec 3 : Vec 3 Unit
21:12:23 <benzrf> unitVec 4 : Vec 4 Unit
21:12:27 <Gurkenglas> But x is a value, how can you do a function from a value
21:12:35 <benzrf> the output type is parameterized not just by the input type
21:12:39 <benzrf> but by the input *VALUE*
21:12:45 <SharpGAF> Oh, huh
21:12:55 <benzrf> that's the key thing you cannot do in haskell
21:12:56 <benzrf> like, at all
21:12:59 <ski> Gurkenglas : the input type of `unitVec' is `Nat', a type
21:13:04 <SharpGAF> So the function body is constrained by the value, then, in some sense...
21:13:13 <benzrf> SharpGAF: yep
21:13:28 <Gurkenglas> ski, but he said the input type is (x : Nat), which is something like 2
21:13:35 <benzrf> Gurkenglas: no, the input type is Nat
21:13:37 <Gurkenglas> meaning that would be a function of type 2 -> Vec 2 Unit
21:13:44 <benzrf> Gurkenglas: the input value is being bound to x
21:13:48 <benzrf> Gurkenglas: that reads as
21:14:06 <benzrf> "this is a function from nat to vec <something> Unit, where <something> is whatever nat gets passed in"
21:14:07 <chrisdone> luite: my quicksort's faster than this merge sort =p http://hackage.haskell.org/package/vector-algorithms-0.6.0.3/docs/Data-Vector-Algorithms-Merge.html
21:14:17 <Gurkenglas> So what you meant is (Nat x) => Vec x ()
21:14:21 <SharpGAF> Okay so fundamentally the return type cannot depend on the input value in Haskell, and if the return type can depend on the input value then that's a dependent type?
21:14:22 <benzrf> Gurkenglas: nu
21:14:28 <SharpGAF> Is that more or less right?
21:14:31 <benzrf> SharpGAF: er
21:14:37 <benzrf> oh wait
21:14:44 <benzrf> SharpGAF: pretty close
21:14:46 <benzrf> SharpGAF: to be precise
21:14:59 <benzrf> SharpGAF: a "dependent type" is just one that's parameterized by a value
21:15:03 <benzrf> it "depends" on the value
21:15:09 * hackagebot shell-monad 0.0.2 - shell monad  http://hackage.haskell.org/package/shell-monad-0.0.2 (JoeyHess)
21:15:21 <benzrf> a pi type or dependent product is a function type where the output type depends on the input value
21:15:27 <SharpGAF> Gotcha
21:15:28 <benzrf> otherwise yes that's correct :)
21:15:34 <SharpGAF> Awesome, thanks a lot!
21:15:37 <benzrf> np
21:15:48 <benzrf> it makes inference MUCH more difficult
21:15:55 <benzrf> in idris you /need/ type sigs
21:16:01 <Gurkenglas> benzrf, like (read :: (Read a) => String -> a) ?
21:16:06 <benzrf> Gurkenglas: no,
21:16:12 <benzrf> Gurkenglas: ok, step back for a second
21:16:13 <chrisdone> luite: (for the 1 million list of ints i'm testing with, anyway. 79ms vs 95ms)
21:16:16 <benzrf> Gurkenglas: consider this function:
21:16:30 <benzrf> unitVec Z = []
21:16:35 <chrisdone> dolio: how come your vector-algorithms package doesn't have a quicksort implementation? is merge sort better in the general case?
21:16:40 <benzrf> unitVec (S n) = ():unitVec n
21:16:50 <benzrf> Gurkenglas: what's the type of this function in haskell?
21:16:59 <dolio> Introsort is quicksort.
21:17:06 <Gurkenglas> Nat -> [()]
21:17:06 <chrisdone> dolio: ah, i see introsort is a quicksort
21:17:29 <benzrf> SharpGAF: anyway, to represent a proof of associativity in a language like haskell or idris, you need a forall
21:17:33 <benzrf> SharpGAF: and those correspond to pi types
21:17:39 <benzrf> Gurkenglas: ok
21:17:45 <benzrf> Gurkenglas: let's say instead of []
21:17:57 <benzrf> Gurkenglas: we use a type where the type length is parameterized by the length
21:17:59 <benzrf> Gurkenglas: like so:
21:18:06 <benzrf> @let data Nat = Z | S Nat
21:18:08 <lambdabot>  Defined.
21:18:32 <benzrf> @let data Vec n a where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a
21:18:34 <lambdabot>  Defined.
21:18:39 <benzrf> ^uses DataKinds, don't worry
21:18:42 <benzrf> Gurkenglas: following?
21:18:46 <ski> Gurkenglas : personally, i prefer writing it like `unitVec : (x :) Nat -> Vec x Unit', which emphasizes more that `Nat' is the input type, and `x' is the name we're giving to the input of that type, *in* the type signature of the function
21:19:52 <Gurkenglas> benzrf, how can Cons go from a and Vec n a to Vec (S n) a when S goes from Nat to Nat, not from Type to Type? Or is lambdabot here already equating types and values?
21:19:59 <SharpGAF> benzrf: Is there an easy general way of determining whether a particular type can be represented in Haskell?  Is "do you need a forall to accurately define the type" the necessary and sufficient criterion?
21:20:02 <benzrf> SharpGAF: to be precise, a proof of associativity would look like a function that takes 3 values in the monoid and then gives back a proof that the outputs are equal for the two possible associations, for those particular values
21:20:20 <benzrf> SharpGAF: but the type of the equality proof depends on the particular values involved
21:20:23 <benzrf> pi type!
21:20:23 <benzrf> SharpGAF: oh uh
21:20:35 <benzrf> SharpGAF: forall is the same thing as dependent product
21:20:38 <benzrf> SharpGAF: so either one works
21:20:43 <SharpGAF> Okay, cool.
21:20:44 <ski> Gurkenglas : `Vec :: Nat -> * -> *' in benzrf's example
21:20:46 <benzrf> SharpGAF: the main criterion is whether the output type depends on the input value
21:20:54 <benzrf> SharpGAF: even then there are some ways you can make that work
21:20:56 <Gurkenglas> ski, oh, of course. Makes sense.
21:21:03 <Gurkenglas> ben, carry on
21:21:09 <benzrf> Gurkenglas: 12:17 < benzrf> ^uses DataKinds, don't worry
21:21:10 <benzrf> :p
21:21:11 <ski> Gurkenglas : this is using the `DataKinds' extension, iirc
21:21:45 <benzrf> SharpGAF: it's possible to write a function that's polymorphic over the input type and then make different input values have different types
21:21:54 <SharpGAF> Yeah, I have heard about DataKinds in the context of avoiding bounds checks in Rust (in some hypothetical future)
21:21:57 <ski> (i would say `data Vec :: Nat -> * -> * where ...' to emphasize this)
21:21:58 <Gurkenglas> (And once again, theory is sacrificed for power)
21:22:07 <benzrf> SharpGAF: but it's pretty limited
21:22:11 <benzrf> SharpGAF: right, ok
21:22:16 <benzrf> alright Gurkenglas soz
21:22:19 <benzrf> Gurkenglas: now,
21:22:21 <benzrf> consider this:
21:22:33 <benzrf> (i'm not sure if the following function typechecks, but)
21:22:44 <benzrf> unitVec Z = Nil
21:22:53 <benzrf> unitVec (S n) = Cons () (unitVec n)
21:22:58 <benzrf> Gurkenglas: what type does this have?
21:23:33 <zq> Nat -> List Unit
21:23:37 <zq> shit sorry
21:23:38 <benzrf> zq: shoosh
21:24:21 <Gurkenglas> This feels like I need that exists/forall syntax for this
21:24:26 <benzrf> =D
21:24:31 <benzrf> Gurkenglas: give it a stab
21:24:36 <benzrf> use made-up syntax if you want
21:28:24 <Gurkenglas> Nat -> exists x: Vec x (), though this doesn't seem to allow the typechecker to grasp what I mean
21:28:39 <ski> good try
21:28:51 <benzrf> Gurkenglas: you need to link the x to the Nat somehow
21:28:52 <Gurkenglas> Like, how would it infer from that a nat exists such that the value is of that type
21:29:06 <benzrf> Gurkenglas: you need to indicate that the x you mean is the first argument to the function
21:29:10 <Gurkenglas> that the x is the one I want in whatever function I plug the result of unitVec into
21:29:24 <benzrf> (x : Nat) -> Vec x ()
21:29:42 <Gurkenglas> That seems to indicate that x is the left side of the ->
21:29:48 <benzrf> it is!
21:29:51 <benzrf> ^when you write unitVec 3, this binds x to 3
21:29:52 <ski> sometimes written as `forall x : Nat. Vec x ()'
21:30:04 <benzrf> ^in coq
21:30:10 <benzrf> the version i put is idris notation
21:30:42 <Gurkenglas> <benzrf> it is! <- !?
21:30:59 <ski> (i think Coq uses `,' instead of `.'. i was talking about notation in (some) papers. imagine `forall' being a real up-side down `A')
21:31:06 <benzrf> ski: i kno it does
21:31:11 <benzrf> ski: it was unimportant >:[
21:31:15 <Gurkenglas> (My model is wrong or this story is false, if you know what I'm referencing)
21:31:20 <benzrf> right
21:31:23 <benzrf> your model is wrong, m8
21:31:27 <benzrf> Gurkenglas: ok, here's the thing
21:31:33 <benzrf> Gurkenglas: x will differ, depending on the input argument, right?
21:31:43 <Gurkenglas> Yes
21:31:59 <benzrf> and it will differ SPECIFICALLY depending on the input argument
21:32:11 <Gurkenglas> Whatever specifically means :P
21:32:18 <benzrf> doesnt matter, that was an irrelevant statemtn
21:32:19 <benzrf> t
21:32:24 <benzrf> Gurkenglas: so what you can say is
21:32:43 <benzrf> "given that the input argument was x, the return type of this function is Vec x ()'
21:32:46 <benzrf> "
21:32:52 <Gurkenglas> I guess the question is, what are the members of the type 2
21:33:03 <benzrf> 2 has no members, sheesh
21:33:11 <benzrf> 2 : Nat
21:33:17 <Gurkenglas> Dangit, I expected to say exactly one member
21:33:20 <Gurkenglas> *you
21:33:31 <benzrf> x : t implies t : Type
21:33:36 <Gurkenglas> Do you mean it has 0 members, or the question for members doesn't apply?
21:33:37 <solatis> ok, bikeshed time: =<< or >>= ?
21:33:40 <benzrf> Gurkenglas: the latter
21:33:48 <benzrf> solatis: contextual ( ͡° ͜ʖ ͡°)
21:33:54 <solatis> :)
21:33:55 <Gurkenglas> Then how can you have 2 -> Vec 2 ()?
21:33:59 <benzrf> Gurkenglas: you don't!
21:34:06 <benzrf> it's Nat -> Vec x ()
21:34:10 <benzrf> except that x must be bound
21:34:11 <solatis> forkIO =<< foo, or foo >>= forkIO ?
21:34:12 <Gurkenglas> <benzrf> it is!
21:34:22 <benzrf> Gurkenglas: that's not x -> Vec x ()
21:34:26 <zachstone> Hey everyone, I'm getting an error in an instance declaration - "'Show' is applied to too many type arguments" - would anybody be able to explain what this means without context?
21:34:32 <solatis> i feel the former is more idiomatic / functional
21:34:38 <benzrf> that's Nat (and bind whichever specific Nat it is to x) -> Vec x ()
21:34:43 <solatis> but have no arguments for it, really
21:34:45 <ski> solatis : how large is `foo' ?
21:35:01 <HeladoDeBrownie> zachstone, you may have written a context like Show Foo Bar when Show Foo is what it should look like
21:35:01 <benzrf> zachstone: it means you forgot parenthesis around the thing after Show
21:35:09 <HeladoDeBrownie> Ah, that's more likely :P
21:35:18 <solatis> well, for example this is actual code i just wrote: forkIO . callback . fst =<< accept sock
21:35:28 <benzrf> zachstone: Show Set a <- this is like f s a
21:35:34 <benzrf> zachstone: Show (Set a) <- this is like f (s a)
21:35:40 <benzrf> zachstone: Show only takes 1 argument
21:35:41 <Gurkenglas> Wait, is the misunderstanding here that x is not related to (x : Nat) as not is to (not :: Bool -> Bool)?
21:36:05 <Gurkenglas> (*benzrf)
21:36:12 <benzrf> Gurkenglas: the x : Nat indicates that the input type is Nat
21:36:16 <benzrf> and that, FURTHERMORE
21:36:21 <solatis> it seems like =<< is more idiomatic, since function composition also works in that order ?
21:36:23 <zachstone> Thanks for the replies, I have Show (Complex a b) = ...
21:36:24 <benzrf> once the function is applied, bind x to whatever Nat you applied it to
21:36:31 <benzrf> zachstone: you want where
21:36:33 <benzrf> zachstone: not =
21:36:49 <solatis> (as in, you read from right-to-left, as opposed to left-to-right)
21:36:52 <Gurkenglas> Well that's just random new syntax that solves this exactly class of problems. >:[
21:36:57 <Gurkenglas> -ly
21:37:22 <benzrf> Gurkenglas: Well, duh
21:37:38 <zachstone> benzrf: Oh, sorry, I meant "show (Complex a b) = ...", it's the second line
21:37:42 <ski> Gurkenglas : `(x : Nat) -> Vec x ()' (or, as i prefer it, `(x : ) Nat -> Vec x ()' means : the type of functions that map inputs of type `Nat' (let's call it `x') to outputs of type `Vec x ()' (for the specific value `x' of type `Nat' that was passed as input)
21:37:43 <benzrf> zachstone: ah
21:37:58 <zachstone> But the error is in the first line?
21:38:20 <benzrf> zachstone: it's complaining about Show the typeclass
21:38:22 <benzrf> not show the functoin
21:38:25 <benzrf> zachstone: you wrote something like
21:38:32 <benzrf> instance Show Foo a where
21:38:32 <Gurkenglas> `(x : ) Nat -> Vec x ()' <- yea that looks in hindsight like it woulda been less confusing
21:38:33 <benzrf> you want
21:38:35 <benzrf> instance Show (Foo a) where
21:39:29 <ski> zachstone : please define `showsPrec' instead ? .. or use a custom function (or custom class), if you want some kind of pretty-printing that's not parsable as Haskell syntax
21:39:31 <Gurkenglas> So unitVec . Cons has type (x : ) Nat -> Vec (Cons x) (), right?
21:39:47 <benzrf> Gurkenglas: that's not well-typed
21:40:04 <Gurkenglas> Then what's the type of unitVec . Cons?
21:40:05 <benzrf> it is if you s/Cons/S/g
21:40:06 <benzrf> ;)
21:40:10 <ski> Gurkenglas : no
21:40:14 <Gurkenglas> "s/Cons/S/g"?
21:40:23 <benzrf> 12:38 < Gurkenglas> So unitVec . Cons has type (x : ) Nat -> Vec (Cons x) (), right?
21:40:27 <benzrf> 12:38 < Gurkenglas> So unitVec . S has type (x : ) Nat -> Vec (S x) (), right?
21:40:30 <zachstone> benzrf: That seemed to fix that problem, thanks.. Now I'm getting another error, heh.
21:40:30 <ski> substitute `S' for `Cons'
21:40:31 <benzrf> former is ill-typed
21:40:32 <benzrf> latter works
21:40:35 <benzrf> zachstone: oh boy
21:41:06 <Gurkenglas> But what is S there?
21:41:32 <ski> a data constructor for `Nat'
21:41:34 <benzrf> the nat constructor
21:41:43 <Gurkenglas> ...right <.<
21:41:45 <ski>   S : Nat -> Nat
21:41:47 <Gurkenglas> my fail there soz
21:41:47 <benzrf> =D
21:43:42 <benzrf> ooh
21:43:46 <benzrf> if we church encode our nats
21:43:48 <benzrf> we can have
21:43:59 <benzrf> unitVec n = n (Cons ()) Nil
21:44:19 <kirill_> k
21:44:43 <ski> zachstone : e.g. `showsPrec p (Complex re im) = showParen (p > 10) $ showString "Complex " . showsPrec 11 re . showChar ' ' . showsPrec 11 im'
21:46:07 <Gurkenglas> twice :: Nat -> Nat; twice (S n) = S (S (twice n)); twice Z = Z. (unitVec . twice) has type ((x : ) Nat -> Vec (twice x) ())?
21:46:25 <ski> yes
21:46:51 <Gurkenglas> Ah well, the type system was already turing-complete anyway.
21:47:16 <zachstone> ski: Woah. Well, I don't think I'm doing anything too crazy, making an instance of Show worked for another type that I made earlier, so I feel like it should work.
21:47:26 <ski> dependently typed programming languages often have termination checkers
21:48:16 <hodapp> what if... the Terminator was actually a termination checker for the Matrix?
21:48:37 <benzrf>       WHAT.
21:48:43 <benzrf> not even a termination checker
21:48:45 <hodapp> Neo: "What are you saying? Are you saying that I could do unbounded recursion?"
21:48:47 <benzrf> a termination /efnforcer/
21:48:53 <ski> zachstone : generally, i think a `Show' instance for a type should generate a a valid Haskell syntax representation of an expression that when evaluated will yield an equal value
21:48:54 <hodapp> Morpheus: "I'm saying that when the time comes, you won't need to."
21:48:57 <benzrf> the designers had no sense of styl
21:49:00 <spearman> hey, new to lenses, is this proper syntax or is there a better way to compose this: over _1 (over _1 (+1)) ((2,3), 9)
21:49:03 <zachstone> instance Show (Complex a) where show (Complex a b) = show a ++ " + " ++ show b ++ "i"
21:49:03 <benzrf> instead of checking for termination
21:49:07 <benzrf> they just built in an OOM killer
21:49:09 <benzrf> 8D
21:49:29 <zachstone> ski: but that code is getting an error
21:49:32 <benzrf> spearman: that would be mmissing the whole point of lenses!
21:49:39 <benzrf> spearman: the cool part of them is precisely that they can be composed
21:49:45 <ski> zachstone : iow, if you want some kind of pretty-printing, i think you're better off with defining a separate function (not touching `Show' for this) .. perhaps with some (new ?) pretty-printing type class, if you like
21:49:46 <benzrf> spearman: over (_1._1) (+1)
21:50:10 <benzrf> spearman: that's standard (.) from the prelude
21:50:15 <spearman> benzrf: thanks :)
21:50:24 <zachstone> ski: Ah, okay. So even if it's valid Haskell, it's probably a bad practice?
21:50:31 <spearman> benzrf: the type signatures are still a bit daunting
21:50:47 <hodapp> huh, I wonder how Haskell printf works. I need to do something similar for my printf-wrapper for Ivory
21:50:55 <benzrf> spearman: yup/
21:51:02 <benzrf> spearman: fyi they compose "backwards"
21:51:05 <benzrf> spearman: like,
21:51:21 <benzrf> > view (_1._2) ((1, 2), 3)
21:51:23 <lambdabot>  2
21:51:25 <ski> zachstone : defining `show' like you did means that it won't get shown properly, if part of a larger expression, involving operators. this is why i suggested using `showsPrec'
21:51:30 <brainacid> Hey
21:52:19 <zachstone> ski: Yeah, that makes sense. I was really just using it for a small program, just to be able to look at the results.
21:53:16 <ski> zachstone : e.g., let's say that you print a value of type `Ratio (Complex Int)'. then you will get something like `2 + 3i % 4 + 5i', rather than `(2 + 3i) % (4 + 5i)'
21:53:35 <spearman> benzrf: hmm, so it should be read left-right (i'm used to reading compositions right-left)
21:54:24 <benzrf> spearman: yeah, "backwards"
21:54:42 <benzrf> spearman: it's backwards for the same reason this is backwards:
21:54:52 <benzrf> > (first . second) (+1) ((1, 2), 3)
21:54:52 <zachstone> ski: but if I didn't make an instance of Show at all, then it wouldn't look anywhere near that.
21:54:53 <ski> zachstone : for debugging (including testing stuff in the interactor), i think it would be ok to make `Show' pretty-print .. though it wouldn't be that hard either, to use a separate function `pretty' or `display' (or whatever you want to call it)
21:54:54 <lambdabot>  ((1,3),3)
21:55:12 <ski> zachstone : why not ?
21:56:32 <zachstone> ski: Well I don't know, I don't think it would make the assumtion to print some random type as 'a + bi'
21:57:34 <ski> instead of typing `...' in the interactor, you could type `pp $ ...', where `pp' is your pretty-printing function for complex numbers
21:58:57 <benzrf> i g2g
21:58:57 <benzrf> night
22:00:03 <brainacid> night benzrf
22:00:04 <ski> zachstone : my main points here are (a) if you manually make an instance of `Show', then define `showsPrec' instead of `shows' (or `show') (something similar goes for manually making an instance of `Read')
22:01:52 <ski> zachstone : and (b) please consider not making `Show' (and `Read') generate (or parse) anything else but valid Haskell representations of the relevant input value (parsed result)
22:02:01 <zachstone> ski: I wasn't aware you could define arbitrary functions inside of Show
22:02:19 <ski> you can define arbitrary functions inside `where' and `let'
22:02:49 <ski> otherwise you can only define the methods which belong to the type class in question, in instances
22:02:59 <zachstone> ski: so basically I should instead define a function 'pp' to take a Complex and return a nice looking string, then call putStr on that.
22:03:38 <ski> yes. or you could make `pretty' make the string, and make `pp' call that and `putStr'
22:04:01 <zachstone> ski: Right.
22:04:05 <ski> if you want to, you could make `pretty' a method of a new type class
22:04:58 <zachstone> ski: Well, thanks for the help. I think I have enough to chew on for now, haha.
22:05:26 <ski> (in that case, it should probably also get as input the precedence level (like for `showsPrec' and `readsPrec'), and perhaps also other stuff, like the maximum desired line length of the pretty-printed output)
22:06:44 <ski> (`pp' being short for "pretty print")
22:06:57 <zachstone> ski: Yeah, I figured :P
22:07:24 <ski> @google pretty printing Hughes
22:07:25 <lambdabot> http://belle.sourceforge.net/doc/hughes95design.pdf
22:07:25 <lambdabot> Title: The Design of a Pretty-printing Library John Hughes Chalmers Tekniska HБogsk...
22:07:34 <ski> that paper might be interesting to read
22:08:37 <zachstone> ski: ooh, I'll check it out. Although that's a bit overkill since I just want to output my complex number to the screen. >_>
22:10:43 <ski> i know. just figured it could perhaps pique your fancy
22:11:37 <yonoid> hi, I'm new to Haskell
22:11:54 <yonoid> On ch3 of Real World Haskell
22:12:06 <dfeuer> ski, does this look sane? https://github.com/haskell/containers/pull/115/files
22:12:11 <dfeuer> Hi, yonoid.
22:12:50 <yonoid> I don't want to be annoying, so I'm wondering: Anyone mind if I ask an XMonad related question?
22:13:02 <solrize> you can ask but #xmonad might be better place
22:13:10 <yonoid> yeah, it's dead right now
22:13:29 <dfeuer> yonoid, you can ask; whether anyone knows the answer is another matter.
22:13:50 <yonoid> I'm new to functional programming, and it would help me if I could print debug messages to a file
22:14:04 <dfeuer> Mmmmm
22:14:07 <yonoid> I know how to set-up key bindings as shown here http://www.nepherte.be/step-by-step-configuration-of-xmonad/
22:14:43 <dfeuer> yonoid, I know very little about such things, but you might be looking for something like this: http://hackage.haskell.org/package/base-4.7.0.2/docs/Debug-Trace.html
22:15:07 <yonoid> I'd like to bind a key to print hello to a file
22:15:32 <dfeuer> yonoid, printing things to files is straightforward.
22:15:32 <LordBrain> yonoid, it doesnt go to a file, but there is Debug.Trace
22:15:48 <dfeuer> But it all depends on context.
22:16:15 <dfeuer> But if you're in a context where you can handle key presses, it's likely you can do regular IO.
22:16:24 <LordBrain> if you want to temporarily insert a  printing side effect in the middle of pure code, people use trace for that.
22:16:33 <ticktock> yonoid: To write to file you use 'writeFile :: FilePath -> String -> IO ()'
22:16:35 <dfeuer> (i.e., you may not need trace)
22:16:37 <ski> hmm .. perhaps `Show' should have subclasses `ShowIntegral' (with method `showsFromIntegralPrec') and `ShowReal' (with method `showsRealToFracPrec') ..
22:19:11 <yonoid> Okay, from what I understand the signature I'm using is (KeyMask, KeySym), X ())
22:19:14 <zachstone> ski: btw, I follow maybe half of what you say. I've been doing Haskell for a total of like 4 days so far. Many concepts are pretty fuzzy still.
22:19:15 <ski> default implementation being `showsFromIntegralPrec p n = showParen (p > 10) $ showString "fromIntegral " . showsPrec 11 n'
22:19:28 <yonoid> Where X is mentioned here http://xmonad.org/xmonad-docs/xmonad/XMonad-Core.html#t:X
22:19:39 <ski> zachstone : oh, atm i was just pondering a wild idea
22:19:49 <ticktock> yonoid: I think there's a function called 'io' of  type 'IO a -> X a'
22:19:51 <ski> zachstone : if anything i said above was unclear, just ask
22:20:29 <yonoid> Ticktock, what you're saying sounds like I'm looking for
22:20:41 <yonoid> Let me see here... THanks for not booting me folks
22:20:46 <dfeuer> yonoid, yeah, that X looks real powerful.
22:20:57 <LordBrain> X is in MonadIO, you can use liftIO $ writefile "mylog.txt" "ERROR: something went wrong"
22:21:00 <dfeuer> You can probably do anything in that X.
22:21:05 <ticktock> yonoid: Yeah, its in XMonad.Core
22:21:13 <dfeuer> Yes, what LordBrain said.
22:21:26 <yonoid> Sounds good, thanks
22:21:30 <ski> @hoogle appendFile
22:21:31 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
22:21:31 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
22:21:31 <lambdabot> Data.ByteString appendFile :: FilePath -> ByteString -> IO ()
22:21:41 <dfeuer> Yes, even that better.
22:21:59 <zachstone> ski: I'm still trying to ignore my previous notions of what a class or subclass is, from OO languages.
22:22:06 <LordBrain> yeah, for a log, definitely... use appendFile, writeFile will just overwrite everything there
22:25:00 <dfeuer> yonoid:  <LordBrain> yeah, for a log, definitely... use appendFile, writeFile will just overwrite everything there
22:26:52 <ski> zachstone : ok
22:28:06 <ski> zachstone : type classes are more similar to fully abstract superclasses / interfaces in OO, though there are still differences
22:29:28 <ski> zachstone : if a Java class implements an interface, then values (iow objects) constructed ("instantiatied") by that class carries around the method implementations of the interface. not so with type classes
22:29:35 <LordBrain> i think they're implemented via an implicit dictionary parameter, right?
22:29:55 <zachstone> ski: Yeah. My first experience with that type of thing was with Rust's traits, which I thought were pretty awesome.
22:30:14 <LordBrain> maybe the tutorials should teach them as explicit adts and then introduce htem as a sort of sugar
22:31:16 <ski> zachstone : if you have a function with signature `foo :: Eq a => [a] -> ..a..', then there will only be one dictionary/vtable of methods passed to `foo' (in the dict-passing implementation of type classes). the `a's in the list doesn't contain any references to implementations of methods of the type class `Eq'
22:33:26 <ski> zachstone : also, you specify that a type is an instance of a type class separately from the definition of the class (though it's recommended that you place the instance in either the package defining the type, or the package defining the type class. otherwise you run the risk of multiple separate libraries both providing an instance, and then you can't use them together)
22:34:06 <ski> zachstone : also (with extensions), type classes can relate multiple types, and not just specify a property of a single type
22:34:49 <ski> zachstone : also, type classes can be defined which take type functions (generic types) as arguments, rather than regular "concrete" types
22:34:50 <LordBrain> i think one important thing to get about type classes, is you really do not want multiple instances of the same class for a given type, not even in different modules, it will make a mess... if you need a different instance, that is what newtype is for.
22:35:05 <ski> yes
22:35:41 <ski> there should be at most one instance for a type (or sequence of types), for any given type class, in a single program
22:36:30 <ski> this is so that the implementation will be able to unambiguously determine which instance to use (there can only be one), and also so that you can rely of different pieces of code using the same instance for some particular type
22:36:38 <ski> (`Set' relies on the latter thing)
22:37:58 <ski> (by "sequence of types", i mean for type classes that takes multiple arguments (being types). e.g. `MonadReader' in the `mtl')
22:38:01 <LordBrain> in practice this has some ramifications, you probably want to make instances for your own types... but not someone elses unless you are actually modifying their code...
22:39:05 <ski> if you're defining a new type class, then it's ok to make instances for some common existing types (but you might perhaps want to put some such instances in a separate module)
22:39:18 <LordBrain> i mean you can do it... but say you do it in a library, and hten they add an instance in their library, and now well you see where i'm going.
22:40:12 * hackagebot hspec-test-sandbox 0.1.0 - Hspec convenience functions for use with test-sandbox  http://hackage.haskell.org/package/hspec-test-sandbox-0.1.0 (junjihashimoto)
22:40:16 <ski> zachstone : i don't recall whether you can separately specify trait constraints on tyvars in Rust
22:40:56 <zachstone> ski: It's alright, I probably know Haskell better than Rust at this point.. heh.
22:41:41 <SharpGAF> ski: You can
22:41:51 <ski> (istr you couldn't express `exists a. SomeClass a *> [a]' in Rust, though)
22:42:15 <SharpGAF> Yeah, it doesn't have HKTs yet
22:42:26 <ski> "HKT" ?
22:42:32 <SharpGAF> Higher kinded types
22:43:05 <ski> doesn't it at least have a few built-in such constructions, like various pointer versions, and also arrays ?
22:43:32 <SharpGAF> Those aren't actually typeclasses.
22:44:00 <ski> the main point in the example above is that we only have a single dict for `SomeClass', rather than one for each `a' (whether in a linked-list, or array, or some other generic data structure)
22:45:30 <SharpGAF> That sounds kinda like type erasure?  Am I conflating concepts?
22:46:26 <ski> (of course those things i mentioned in the next-to-last statement wouldn't be type classes. the point there was that those would be primitive examples of generics / type functions, even if it wouldn't be possible to define your own)
22:46:42 <SharpGAF> Oh, no, you can define generics
22:46:56 * ski was thinking you could
22:47:37 <ski> i suppose you could think of it in terms of type erasure
22:48:18 <SharpGAF> GHC also has a mechanism for unboxed types, though, right?  How does that play with typeclasses?
22:48:56 <SharpGAF> Is it like C#, where specialized implementations are created only for unboxed types?
22:49:15 <SharpGAF> Er, s/typeclasses/generics/
22:49:47 <LordBrain> i suspect its easy for a haskell newbie to go a bit overkill with type classes, we have first order functions, so really anything that can be written func:: Show a -> a -> b for example can be functionally accomplished by actually having something like data ShowT a = ShowT { Sshow :: a -> String }  and then func:: ShowT a -> a -> b which might be better because it gives you the flexibility to change out the dictionary without worrying
22:49:48 <LordBrain> about making a whole new type and or conflicting instance or what not.
22:50:56 <ski> the important part here would be erasing the type of each `a' value (as always happens in Haskell)  .. but also erasing the infor for `a' associated with the `exists a. ' part
22:50:57 <LordBrain> correction, the first one above should have been func:: Show a => a -> b, i used -> instead of =>
22:51:53 <ski> unboxed types in GHC have a different kind, so you can't make them into instances of the same type classes that (only) accept boxed types
22:52:05 <SharpGAF> Ah, interesting.
22:52:30 <ski> also, a type variable can't have the unboxed kind, iirc
22:52:56 <ski> anyway, you can't have an operation being polymorphic in unboxed stuff
22:53:06 <SharpGAF> Gotcha, so it doesn't come up then.
22:54:36 <ski> one alternative to allow that could be to say that `forall (a :: #). ..a..', rather than erasing the info for `a' (as in the case `a :: *' and `a :: # -> *', &c.), realize that by passing around storage requirements (such as size) of values of type `a'
22:55:50 <ski> another variant could be to require `forall (a :: #). Unboxed a => ..a..', so that an instance for `Unboxed a' would instead carry that info. leaving `forall' alone to always allow type erasure
22:56:36 <SharpGAF> What does # mean?
22:56:41 <LordBrain> you can think of type classes as a means of hiding parameters that you really want to always be the same anyway, and so are not interesting.  That's not like an abstract parent type in OO at all, if it's mainly the polymorphism you are interested in, then a record type with methods as fields is a closer approximation to the OO concept.
22:56:45 <ski> it's the kind of unboxed types
22:56:48 <SharpGAF> Ah, okay.
22:56:50 <ski> @kind Int
22:56:51 <lambdabot> *
22:57:09 <ski> @kind GHC.Base.Int#
22:57:10 <lambdabot> #
22:57:31 <ski> @kind GHC.Base.Array#
22:57:32 <lambdabot> * -> #
22:57:49 <SharpGAF> Rust has similar restrictions for unsized types (unboxed types with size not known at compile time)
22:58:37 <yonoid> Sweet, I got it now! liftIO with appendFile is what I needed
22:58:40 <yonoid> ((modMask x, xK_u), liftIO (appendFile "/tmp/myxmonad.log" "Hello"))
22:58:56 <ski> yonoid : great :)
22:59:01 <yonoid> Thanks guys, this binding will be very helpful!
22:59:38 * ski disappears
23:00:04 <LordBrain> type classes were originally invented for overloading our arithmetic operators
23:01:15 <LordBrain> then came the Monad class..;
23:03:54 <LordBrain> which lets us overload to some extent the meaning of the order of instructions, 'after' in this after that, informally speaking... but we never added the ability the overload adjacency which i think ruby has
23:05:11 <LordBrain> adjacency pretty much always means function application or something very close to it
23:06:47 <LordBrain> i guess we have templatehaskell so you can use quasiquotes to achieve that kind of overloading... but i templatehaskell isn't a firstclass citizen really of haskell in my eyes.
23:07:09 <SharpGAF> Ruby can overload adjacency?
23:07:20 <LordBrain> i'm not a ruby coder, but i have heard it can
23:07:41 <LordBrain> you define some special function and it changes what adjacency means in a limited scope
23:08:12 <SharpGAF> I've written a lot of Ruby and I have no idea what mechanism is being referenced there…
23:08:23 <LordBrain> ok, i'll do some googling to dig it up for ya
23:08:39 <SharpGAF> yield, maybe?
23:09:03 <LordBrain> no, it was multiple syllables
23:09:31 <matematikaadit> something like: `method_name arg, arg` in ruby?
23:10:13 <matematikaadit> monkey patching?
23:10:55 <SharpGAF> Monkey patching is just being able to append new methods to classes arbitrarily (you can also add arbitrary methods to eigenclasses and I think can construct an infinite tower of them)
23:11:37 <LordBrain> i think it started with an m
23:11:42 <SharpGAF> method_missing?
23:11:46 <LordBrain> but not monkey patching
23:12:08 <LordBrain> i tried googling but i'm getting blocked by lots of graph theory libraries
23:12:11 <SharpGAF> Haha.
23:12:30 <LordBrain> i think it was mono_something_something = blah blah
23:12:42 <LordBrain> we're stretching my memory
23:12:59 <LordBrain> i never actually messed around with it, i just read a blog and thought, oh that's cool
23:13:11 <SharpGAF> I'm seriously drawing a blank
23:14:15 <SharpGAF> It has call/cc…
23:14:19 <SharpGAF> Technically.
23:16:02 <LordBrain> it is possible that i misunderstood what i read, that ruby actually doesn't do it, but i thought that is what the guy was saying, and i thought yeah that is cool.
23:16:37 <LordBrain> i have done exactly 0 ruby coding
23:16:40 <SharpGAF> Ruby definitely lets you do some really weird stuff, like do arbitrary computation on method dispatch or iterate through all GC roots.  I just don't think it lets you do that.
23:18:48 <LordBrain> in googling i find some about define_method, it might have been some trick making use of this
23:20:09 <LordBrain> which come to think of it, haskell has some tricks too, its possible to make a polyvariadic function that acts as a list which is sort of like rebinding adjacency
23:20:54 <SharpGAF> I don't think define_method can control evaluation order in Ruby
23:20:57 <LordBrain> i thought there was an actual special language construct for rebinding adjacency tho, and i kinda like that idea.
23:21:26 <SharpGAF> Ruby does have a splat operator that converts [1,2,3] to 1,2,3
23:21:50 <LordBrain> i don't even know enough ruby to know the difference
23:22:25 <SharpGAF> Methods with arity 3 can accept the latter but not the former… but in Ruby it's pretty blury.  The default closure type (proc) also automatically casts between them
23:22:56 <LordBrain> i see
23:23:33 <SharpGAF> It's kind of amazing how complex Ruby is as a language
23:23:35 <SharpGAF> For better or worse :P
23:24:19 <zachstone> When did this turn into a Ruby channel? :P
23:27:18 <LordBrain> oh well, i think it would be cool to be able to do that without meta programming, like exchange have spaces take the place of a convenient operator like <*> for example, and an explicit symbol like $ for application except with higher precedence than $... just within a local scope.
23:28:39 <LordBrain> i might like adjacency to mean multiplication at times too
23:28:57 <codygman-> Is there any reason it would be a bad idea to set executable-profiling and library-profiling to True in ~/.cabal/config?
23:29:08 <LordBrain> no
23:29:12 <LordBrain> i recommend it
23:29:29 <codygman-> Cool, just needed a sanity check. Thanks LordBrain
23:29:38 <LordBrain> definitely the library-profiling... the only thing is, you will have to rebuild everything
23:29:42 <SharpGAF> LordBrain: This sounds vaguely like it might be a feature in a concatenative language somewhere
23:30:14 * hackagebot stackage 0.3.0.1 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.3.0.1 (MichaelSnoyman)
23:30:51 <LordBrain> codygman, that is a major caveat i should have mentioned... it will break all the libraries you have already installed
23:31:28 <LordBrain> until you re-compile them with profiling
23:32:45 <LordBrain> i think cabal has a command to make world or something
23:32:51 <LordBrain> its been so long since i had to do it
23:33:46 <LordBrain> cabal install --reinstall world
23:34:02 <altern> Why am I getting error "Couldn't match expected type `BSL.ByteString' with actual type `[Char]'" when I am trying to decode JSON with command ` decode $ "{\"children\":[{\"children\":[],\"value\":{\"version:
23:34:02 <altern> "1\"}}],\"value\":{\"version\":\"x\"}}"`
23:34:36 <ReinH> LordBrain: oh that's a useful command
23:34:54 <ReinH> altern: what is the type of decode?
23:35:07 <altern> ReinH, RoseTree
23:35:15 <ReinH> that doesn't make sense
23:35:38 <LordBrain> altern, you have a regular haskell string, but your function to decode the json takes a bytestring, or the other way around... try using pack perhaps.
23:35:41 <altern> ReinH, instance (Show a, JSON.FromJSON a) => JSON.FromJSON (RoseTree a) where
23:36:16 <ReinH> What is the type of decode?
23:36:23 <altern> LordBrain, I tried pack, but it doesn't work for some reason
23:36:27 <altern> ReinH, instance (Show a, JSON.FromJSON a) => JSON.FromJSON (RoseTree a) where
23:36:34 <ReinH> That can't possibly be the type of decode
23:38:13 <LordBrain> altern, what package are you using to parse the json etc?
23:38:42 <altern> LordBrain, I use import qualified Data.Aeson as JSON
23:39:47 <lpaste> altern pasted “FromJSON” at http://lpaste.net/1648830265532874752
23:39:53 <codygman-> LordBrain: Thanks for the followup warning. In my case I was actually rebuilding everything anyway ;)
23:40:05 <ReinH> if decode expects a ByteString and you are using a string literal, you can use the OverloadedStrings extension
23:40:23 <LordBrain> decode :: FromJSON a => ByteString -> Maybe a
23:40:49 <LordBrain> found here: https://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html#v:decode
23:41:38 <zq> hm
23:41:48 <LordBrain> yeah, but he said he tried pack and it didn't work :/
23:41:58 <ReinH> LordBrain: I'm not convinced.
23:42:23 <LordBrain> me neither :)
23:42:34 <ReinH> Maybe "it didn't work" means that they got a different error. "It didn't work" is not a good problem description.
23:43:06 <LordBrain> maybe he put the pack in on the wrong side of the dollar sign?
23:43:07 <altern> LordBrain, it turns out I used different pack
23:43:20 <altern> BS.pack instead of BSL.pack
23:43:25 <LordBrain> ah
23:43:31 <altern> I am now getting another error
23:44:06 <LordBrain> want to share it?
23:45:06 <lpaste> altern pasted “FromJSON error” at http://lpaste.net/117206
23:45:57 <lpaste> altern pasted “FromJSON” at http://lpaste.net/117207
23:48:28 <LordBrain> altern, try putting a type signature on that function
23:48:55 <LordBrain> the one whose body begins with decode
23:49:12 <LordBrain> its the return type that ghc is having issues with
23:49:26 <altern> LordBrain, could you give an example?
23:50:18 <altern> LordBrain, smth like "decode :: BSL.ByteString -> RoseTree a " ?
23:50:40 <LordBrain> well...
23:50:54 <LordBrain> you are doing this in ghci?
23:50:58 <altern> yep
23:51:11 <LordBrain> ok, at the end of hte line put :: and the return type you expect
23:51:43 <altern> oh, I see. thx
23:52:02 <LordBrain> so... ghci> (decode $ BSL.pack "...") :: Maybe X
23:52:08 <LordBrain> but instead of X, the appropriate type
23:53:11 <zq> alright
23:53:14 <zq> this took too long
23:53:17 <zq> > let z=chr.fromIntegral.round in map (z.me) [0..4] ++ map (z.ch) [0..8] ++ map (z.ha) [0..7]
23:53:18 <lambdabot>  "merrychristmas#haskell"
23:53:22 <zq> gg
23:53:38 <Taneb> :)
23:53:46 <altern> LordBrain, it works!
23:55:05 <altern> LordBrain, I am doing (JSON.decode $ BSL.pack"{\"children\":[{\"children\":[],\"value\":{\"version\":\"1\"}}],\"value\":{\"version\":\"x\"}}") :: Maybe (RoseTree Version)
23:56:16 <LordBrain> yeah, in a program you type, you can make it prettier of course, and ghc might be able to infer the return type for you
23:56:40 <LordBrain> when there is more context, but type signatures don't hurt anyway.
