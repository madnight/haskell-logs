00:00:38 <ski> alternatively expressed, the stack is used for remembering what to do next, after forcing a thunk
00:00:52 <srhb> Right.
00:01:01 <shachaf> I think thinking about graph reduction is good enough for figuring most things out, though.
00:01:02 <nshepperd> well, the question was about why one of the implementations required increasing ghc's stack limit
00:01:10 <srhb> Indeed.
00:03:33 <nshepperd> anyway, I think it's definitely not about the dlist because you can implement sequence_hughes with an ordinary accumulating list (that builds the result in reverse order), and the reverse the list at the end
00:03:41 <nshepperd> and I don't think that would blow the stack
00:04:09 <shachaf> Well, sure.
00:06:07 <zRecursive> Surprising! a working function in ghc-7.6.x cannot work now after upgrading to ghc-7.8.x? his = do {pid <- runCommand $ "tail " ++ ssqHitNum; waitForProcess pid >>= exitWith}, And `ghc -ignore-dot-ghci -e "import XXX" -e "his"` will exit without any output.
00:07:59 <zRecursive> :t print
00:08:00 <lambdabot> Show a => a -> IO ()
00:08:56 <zRecursive> Weird, even `ghc -ignore-dot-ghci -e "print 9"` outputs nothing too
00:09:23 <srhb> zRecursive: Works here.
00:10:32 <zRecursive> srhb: oh, it works in xterm not in emacs eshell
00:10:52 <srhb> zRecursive: Works in Emacs shell, too, here.
00:11:27 <zRecursive> really! what happens to this freebsd-9.3 box ?
00:11:34 <srhb> I don't know. :-)
00:18:11 <hunter_> is anyone here familiar with "helm"
00:18:23 <hunter_> is there any way to run sdl commands through it? if not how am i meant to do audio?
00:19:36 <hunter_> also
00:19:49 <hunter_> how come its possible to do looping io
00:20:10 <hunter_> like how come IO() actions that occur along the way are processed
00:20:19 * hackagebot debian-build 0.4.0.0 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.4.0.0 (KeiHibino)
00:20:19 <hunter_> instead of just the final IO ()
00:23:22 <ReinH> They are sequenced into a final IO () action using >> and >>=, like usual
00:25:19 * hackagebot case-insensitive 1.2.0.2 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.2.0.2 (BasVanDijk)
00:25:21 * hackagebot case-insensitive 1.2.0.3 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.2.0.3 (BasVanDijk)
00:28:49 <dspies> How can I make this topo-sort program run in constant stack space?
00:28:51 <lpaste> dspies revised “topo-sort”: “topo-sort” at http://lpaste.net/116744
00:31:00 <ReinH> dspies: Well, the most obvious issue is that you're using the lazy state monad.
00:32:43 <dspies> I don't think that matters.  I'm not trying to reduce the space usage, I just want to move it from the stack to the heap
00:33:34 <dspies> Yeah, changing it to strict doesn't work
00:36:22 <lpaste> dspies revised “topo-sort”: “topo-sort” at http://lpaste.net/116744
00:36:46 <ReinH> I didn't say that changing to strict state monad was the only issue
00:36:59 <ReinH> You're still building up IntMap.insert thunks, for instance, right?
00:39:22 <dspies> Yes, but those are on heap, aren't they?
00:39:47 <dspies> no wait, I'm not
00:39:58 <dspies> because I immediately then call IntMap.member
00:44:34 <ski> srhb : "BEcause tail recursion is almost (always?) never a thing in Haskell" -- it is a thing in Haskell, but there's less emphasis to it, due to the often available alternative of making an operation incremental (using non-strictness), rather than tail-recursive (and bulky)
00:44:47 <ski> srhb,dmwit,shachaf : `sequence (m:ms) = (:) <$> m <*> sequence ms', "That LOOKS tail recursive modulo cons though" -- tail-recursion-modulo-cons(tructor) is not tail-recursion. it's a separate thing (and extension, if you will).
00:45:05 <ski> (perhaps see chapter 3 (from page 11) of "Making Mercury programs tail recursive" by Peter Ross,David Overton,Zoltan Somogyi in 1999-09 at <https://www.mercurylang.org/information/papers.html#tail_lopstr_lncs>)
00:45:17 <ski> (it's called "Last-Call Optimization" (tail-calls) and "Last-Call Optimization Modulo CONStructor" (tail-call-modulo-cons) in the logic programming setting, which independently discovered the same two ideas)
00:45:24 <ski> dmwit,shachaf : perhaps we should call operations like `sequence_hughes' "effectively tail-recursive", making a pun on "effects" :)
00:45:47 <ski> shachaf,srhb : "Talking about \"TCO\" doesn't even make that much sense when talking about Haskell." -- i don't agree. i agree that it's less important (due to available alternatives), and that it doesn't mean quite the same thing as in an by-value language (because of the difference between by-value and by-need&by-name)
00:45:58 <ski> shachaf : "Graph reduction is good enough of a mental model for most issues relating to laziness that you'll come across.", yes. possibly augmented with a notion of the current focus in the graph
00:46:03 <ski> srhb : have you seen monochrom's "Lazy Evaluation of Haskell" at <http://www.vex.net/~trebla/haskell/lazy.xhtml> yet ?
00:46:20 <ski> srhb : "Right, where's the stack space consumption here?" -- it comes from `sequence' not being "effectively tail-recursive" here :
00:46:23 <srhb> ski: Website down.
00:46:41 <ski> when *executing* (not evaluating) `do x <- m; xs <- sequence ms; return (x : xs)' / `m >>= \x -> sequence ms >>= \xs -> return (x : xs)' / `liftA2 (:) m (sequence ms)' / `(:) <$> m <*> sequence ms', you need to "return the cons cell" *after* `sequence ms' has executed (`sequence ms' occurs to the left of `>>=')
00:46:44 <ReinH> That's a shame.
00:47:31 <shachaf> ski: I don't mean that talking about tail recursion doesn't make sense in Haskell, but that talking about "tail recursion optimization" doesn't make sense. It's not really an optimization in the normal way Haskell code would be compiled, it's just the natural way to do things.
00:47:37 <ski> srhb : <www.mercurylang.org> or <www.vex.net> ?
00:47:56 <ReinH> ski: monochrom's
00:48:07 <ski> this (cont. from above) is only a problem for "strict monads" like `IO', where execution of `ma >>= amb' corresponds to evaluating `ma', then executing it, yielding an `a', then evaluating `amb a', then executing it (and the whole `ma >>= amb' then yields the same answer as the execution of `amb a' did)
00:48:18 <ski> nshepperd : "I think, one way to look at it is \"how do you reduce the expression\"" -- it's not only about reduction/evaluation, in this case. it's also about execution of actions in the particular monad (or applicative functor)
00:48:23 * ski is possibly violently agreeing with nshepperd
00:48:32 <ski> srhb : "While regular sequence will not grow stack for the lazy variants (due exactly to laziness of cons, I guess?)" -- mainly due to the "laziness" of those monads. but also due to `(:)' being non-strict, yes
00:48:36 <ski> dspies : see above
00:48:41 <ski> srhb : "Which uses stack because... ?","The chain of  >>= ?" .. because the recursive call occurs to the left of `>>=', for a "strict" monad
00:49:02 <ski> nshepperd,shachaf : it's about the (functional) difference list in the sense that it is used to be able to both be tail-recursive and store the elements in order. it's as you noted also not about the diff-list, because the diff-list (or something equivalent to it) isn't *sufficient* (you need actual "effective tail-recursion", as well)
00:49:07 <ski> hunter_ : see my rough explanation above for how `ma >>= amb' gets executed in `IO'
00:51:46 <ski> shachaf : ok. i agree that "tail recursion optimization" is partly missing the point. you want it to be a guarantee (under certain circumstances), not something that may or may not happen, depending on optimization levels
00:51:50 <ski> in Scheme it's mandated by the language standard, called "proper tail recursion" (which is arguably slightly a misnomer, because it applies to all tail calls, not just tail recursion)
00:53:52 <ski> ("proper tail recursion" amounts to the operational semantics of the language supporting an unbounded number of active tail calls in bounded space. this may be implemented via TCO, or in some other way (e.g. heap allocating stack frames / activation records, and letting the GC collect them))
00:54:23 * shachaf wonders whether such a long sequence of messages all at once is suitable for IRC.
00:54:40 <shachaf> I guess it's good for logs etc. but it's a bit hard to follow.
00:55:17 <ski> srhb : hm, it seems to be up now (for me). otherwise you can try <https://web.archive.org/web/20141218085154/http://www.vex.net/~trebla/haskell/lazy.xhtml>
00:55:18 <shachaf> ski: I think "tail call optimization" still makes more sense to talk about in a strict language like Scheme than in a non-strict language like Haskell.
00:55:29 <shachaf> (Though admittedly it probably makes less sense in Scheme than in C.)
00:56:06 <shachaf> I can't really think of a reasonable non-strict evaluation model that doesn't do "TCO".
00:57:43 <ski> shachaf : do you mean the optimization, or the language property ?
00:57:55 <shachaf> The optimization.
01:00:10 <ski> (btw, would it have been better if i had split up the response barrage in smaller charges, separated by perhaps five minutes of intermission ?)
01:00:49 <shachaf> Possibly.
01:00:55 <shachaf> But on the other hand that's kind of silly.
01:01:19 <shachaf> I like the word "action" for value :: M A where M is a monad (or similar), but I wish it didn't conflict with e.g. "group action".
01:01:39 <shachaf> Maybe a clever person can figure out how to make it a special case of the usual sense of "action".
01:02:05 <shachaf> (Which as far as I can tell typically means a particular sort of functor.)
01:02:18 <ski> shachaf : anyway .. you may have a point about that "I think ..."
01:03:09 <shachaf> ski: I like the notion of "graph reduction with a focus" -- I don't think I've seen that mentioned explicitly anywhere.
01:03:38 <shachaf> Maybe you want something more than a focus -- something like a focus with a path to represent the stack? I don't know.
01:03:49 <ski> shachaf : btw, apropos Hoare triples and weakest precondition in imperative programming, `wp(skip,Post) = Post' and `wp((S0 ; S1),Post) = wp(S0,wp(S1,Post))' specifies that `wp' is a monoid action :) .. just an interesting observation i made a few days ago
01:04:47 <shachaf> Maybe I missed a discussion about Hoare triples earlier. :-)
01:04:57 <shachaf> But that seems reasonable.
01:05:09 <ski> (for by-standers : and obviously there's an analogy between commands ("statements") `S0',`S1' in imperative programming, and actions in monadic (and to some extent, "applicative functor"iadic) programming)
01:06:07 <shachaf> Can you figure out a way to write out a step-by-step reduction of an expression in a non-strict language that doesn't do "TCO"?
01:06:58 <ski> shachaf : well, yes, also a spine down to the focus. (for some reason i was apparently thinking only of trees, and so i didn't distinguish between them)
01:07:17 <jstolarek> I'm looking for a better way of writing this code:
01:07:18 <jstolarek> (\inj -> case or inj of { True -> Just inj; False -> Nothing})
01:07:23 <jstolarek> feels a bit ugly
01:07:31 <shachaf> if?
01:07:52 <jstolarek> same thing
01:07:56 <shachaf> That's slightly odd code anyway. What do you do with inj (a list of Bool?) afterward?
01:08:00 <Ferdirand> something with guard maybe ?
01:08:05 <Ferdirand> in the Maybe monad
01:08:38 <shachaf> ski: If you write e.g. "f x = g (h x) (i x)", the next step of reduction would be g. How do you not "eliminate that tail call"?
01:08:42 <jstolarek> I'm thinking about a combinator that takes a value and a predicate. If the predicate is true foir that value return it in a Just, otherowse return Nothing
01:08:52 <ski> `do guard (or inj); return inj' / `guard (or inj) >> return inj'
01:09:00 <shachaf> I've seen that function discussed before.
01:09:06 <jstolarek> ski" briliant
01:09:12 <ski> aye, me too
01:09:55 <shachaf> Monad comprehensions can do it:
01:10:05 <shachaf> [inj | or inj] :: Maybe [Bool]
01:10:38 <jstolarek> so, I'm down from 5 lines of code to 1 line of code and 5 lines of comment :-D
01:10:54 <shachaf> (Or you can listToMaybe if you don't want MonadComprehensions.)
01:11:03 <ski> shachaf : hmm .. let's say `f x = let y = h x; z = i x in g y z', and say we don't remove the `let <bindings> in' part before the body is a value ?
01:11:33 <shachaf> In fact I've used [x | y] pretty regularly, and Maybe is a natural monad for it.
01:11:43 <shachaf> ski: Sure, that's better.
01:11:54 <shachaf> ski: (Or make up your own expression, there was nothing special about that one.)
01:12:48 <jstolarek> du, hoogle just went down for me
01:13:02 <Zol_> How come force forces evaluation if it ignores the values in a list? Does it just expand a list into a full list of thunks? Like.. *Thunk* -> [*Thunk*, *Thunk*, *Thunk*, ...] ?
01:13:03 <jstolarek> what's the signature of listToMaybe?
01:13:08 <barrucadu> :t listToMaybe
01:13:08 <jstolarek> > :t listToMaybe
01:13:09 <lambdabot> [a] -> Maybe a
01:13:10 <lambdabot>  <hint>:1:1: parse error on input ‘:’
01:13:22 <shachaf> [a] -> Maybe a
01:13:30 <ski> shachaf : so, even if `y' and `z' have been reduced to values (say `g' is strict), and we have substituted for them. but we still don't remove the `let' frame with bindings for them until after `g <value for `y'> <value for `z'>' has been reduced (to WHNF, say)
01:13:31 <shachaf> Oh, lambdabot answered.
01:13:38 <ski> shachaf : would that work ?
01:13:41 <jstolarek> nope, listToMaybe doesn't doo it for me
01:13:49 <jstolarek> I'm not sure about MonadComprehensions
01:13:51 <shachaf> jstolarek: listToMaybe [inj | or inj], I mean
01:13:59 <jstolarek> oh
01:14:00 <shachaf> If you don't want the extension.
01:14:06 <shachaf> It's not that great.
01:14:27 <ski> Zol_ : are you using some operation named `force' ?
01:15:23 <shachaf> NFData is evil. :-(
01:15:25 <jstolarek> shachaf: but that will return just a single True
01:15:36 <jstolarek> whereas I want to return whole list
01:15:36 <shachaf> jstolarek: Why?
01:15:49 <ski> @hoogle force
01:15:49 <lambdabot> Control.DeepSeq force :: NFData a => a -> a
01:15:49 <lambdabot> package force-layout
01:15:49 <lambdabot> Graphics.UI.GLUT.DeviceControl forceJoystickCallback :: IO ()
01:15:50 <ski> oh
01:16:00 <shachaf> jstolarek: [x | b] :: Maybe A is "Just x" when b is True and "Nothing" when b is False
01:16:00 <jstolarek> [inj | or inj] will contain only True's, right?
01:16:10 <shachaf> No, this isn't a list comprehension.
01:16:17 <Zol_> ski: http://lpaste.net/116757 -- from ch24 in Real World Haskell
01:16:46 <Zol_> ski: I thought force was a common function...
01:17:08 <ski> jstolarek : yes. a list of at most one list (of only `True's) -- or a `Maybe' of such a list, with `MonadComprehensions'
01:17:35 <shachaf> Er, I misread jstolarek's question, I guess.
01:17:55 <ski> Zol_ : i seldom use any `DeepSeq' operation
01:18:01 <jstolarek> anyway, guard (or inj) >> return inj does it for me
01:18:21 <ski> Zol_ : yes, it will force the spine of the list for you (in a separate thread)
01:18:29 <shachaf> [inj | or inj] means the same thing, with MonadComprehensions.
01:18:34 * ski would use `()' rather than `1', there
01:18:47 <Zol_> ski: Spine?
01:19:05 <jstolarek> shachaf: that's not obvious at first glance
01:19:13 <ski> Zol_ : the `_ : _ : _ : .... : _ : _ : []' structure of the list, ignoring all the elements `_'
01:19:18 <shachaf> I wish people were more used to this idiom so that it would be obvious.
01:19:19 <jstolarek> and since this goes into GHC I'm putting readability over compactness
01:19:31 <Zol_> ski: So it will thunkify the thunk?
01:19:39 <shachaf> List comprehensions with no generators are very useful.
01:19:41 <Zol_> ski: I mean, expand it into thunks.
01:19:43 <shachaf> But fair enough.
01:19:49 <ski> Zol_ : iow, the list constructors of the main list ("top level". not including any lists that might be inside the elements of the main list)
01:20:21 <ski> Zol_ : it will go from possibly only a thunk of a list, to a list of thunks
01:20:30 <shachaf> (To me the guard-return version is a bit harder to read but I guess for others it's the opposite.)
01:20:38 <Zol_> ski: Ok, thanks! :) That is what I wanted to confirm.
01:20:47 <shachaf> ski: Well, maybe a thunk of a list of thunks. :-)
01:20:59 <ski> shachaf : possibly :)
01:21:20 <ski> Zol_ : .. of course, it could be that some part of the spine of the input list was already forced before
01:21:26 <shachaf> It's not fair to call x "possibly a thunk" and not call "force x" the same thing.
01:22:26 <Zol_> ski: When I use pseq or par, will the left arguments always be run on their own threads?
01:23:35 <ski> shachaf : roughly what i meant : before evaluating/reducing `force x', both `x' and `force x' would be "possibly a thunk" (the latter also definitely one). after, both would be a concrete list spine, referring to (possible) thunks
01:24:00 <shachaf> OK.
01:24:09 <ski> Zol_ : oh, sorry, i actually misread. it uses `pseq', not `par', so no new thread/spark
01:24:12 <shachaf> Why wouldn't it force the elements of the list too?
01:24:31 <ski> it depends on how `x' is defined
01:24:59 <shachaf> You mean the NFData of the type of list element?
01:25:03 <shachaf> NFData instance
01:25:18 <Zol_> ski: Aha, thanks! That makes me less confused now. :-)
01:25:36 <ski> shachaf : i'm talking about the `force' that Zol_ linked to at <http://lpaste.net/116757>. no `NFData' there
01:25:42 <shachaf> Oh.
01:25:48 <shachaf> I missed that.
01:26:14 <Zol_> shachaf: Sorry, I just realized you were talking about the same thing as us, would have linked your nick otherwise. :)
01:26:26 <ski> Zol_ : `par' makes a new spark. `pseq' reduces the left/first argument before reducing the right/second one (`seq' doesn't guarantee that, though)
01:27:17 <ski> (afaiu, we don't even have a guarantee that in  a `seq` b  , `a' will be forced before this whole expression returns)
01:28:13 <shachaf> What do you mean, before this whole expression returns?
01:28:45 <Zol_> ski: seq and pseq evaluates to WHNF, while par maybe evaluates the first/left list to WHNF in parallel?
01:29:06 <ski> (.. as long as the implementation can determine (through strictness analysis) that this expression will be needed, but `a' perhaps only needed later, i think it is allowed to set up things so that `a' is only reduced later (before it is needed), if it feels like)
01:29:29 <ski> Zol_ : yes
01:29:35 <shachaf> ski: Well, sure.
01:30:08 <shachaf> I often prefer to think of seq as a sort of "compiler directive" rather than a function.
01:30:09 <ski> this is to counter the common belief that in  a `seq` b  , `a' at least has to be reduced to WHNF before the `seq' call returns
01:30:47 <Zol_> ski: From Hoogle: Seq: "Evaluates its first argument to head normal form, and then returns its second argument as the result."
01:30:50 <shachaf> Certainly in (a `seq` _|_) a doesn't have to be reduced at all.
01:30:55 * ski had some denotational equality chain derivation of such a case, but can't recall it atm
01:31:49 <ski> Zol_ : the official specification is that `seq _|_ y' is `_|_', and that `seq x y' is `y' in case `x' is not `_|_'
01:32:33 <ski> Zol_ : .. so, i believe that description you quoted is (slightly) off
01:33:08 <ski> Zol_ : `pseq', otoh, i believe is required to behave as you say, while also reducing the left operand before the right one
01:34:01 <ski> Zol_ : denotational semantics is concerned only with "what" an expression evaluates to, not how. the "before" and "after" stuff refers to the "how", so it is operational semantics, and isn't covered by the explanation in terms of `_|_'
01:35:11 <ski> (see monochrom's "Lazy Evaluation of Haskell" at <http://www.vex.net/~trebla/haskell/lazy.xhtml> for a little more about the difference between operational and denotational semantics)
01:39:46 <Armel`> Hi! Is it possible to use a type (like "Int") as a function parameter? Thanks! :)
01:40:10 <shachaf> Not in Haskell.
01:40:31 <shachaf> But you can pass a value-level proxy for the type, using Data.Proxy: data Proxy a = Proxy
01:41:00 <shachaf> Then you have e.g. typeRep :: Typeable a => proxy a -> TypeRep, which you can use as "typeRep (Proxy :: Proxy Int)"
01:41:39 <shachaf> Passing types to functions is a concept that exists in Core (an intermediate language that GHC compiles Haskell into) but not in Haskell.
01:42:28 <shachaf> On the Haskell level you can think of "forall a." as passing the type "a" as an argument to the function, but it's not accessible without something like Proxy.
01:44:40 <Armel`> Thank you shachaf, it's a bit complex for what I'm doing so I'll find an other way. ;)
01:45:05 <shachaf> I guess a third answer to your question is that you can pass a TypeRep, but that's not very satisfying.
01:45:12 <shachaf> It depends on what you're doing.
01:47:52 <jle`> Armel`: what exactly are you trying to do...?
01:48:00 <Zol_> ski: Just to confirm again; seq, pseq and par only evaluates to WHNF in case of evaluation, I would need to use the force function I mentioned if I would like to get closer to NF, in any of the three functions?
01:48:30 <shachaf> Certainly none of these functions don't do anything more than WHNF.
01:48:48 <shachaf> par doesn't even do that, really.
01:49:16 <shachaf> I think using a function like force isn't a good solution in many cases (though it is in some).
01:49:51 <jle`> is there a common non-newtype version of Identity?
01:50:22 <petrus> Hi! How can I get ghci to display possible completions instead of iterating them one by one in full?
01:51:12 <shachaf> ghci does display possible completions rather than iterate through them, for me.
01:51:25 <petrus> In my environment (linux), this behavior has changed, I believe.
01:51:40 <shachaf> When?
01:52:06 <jle`> yeah i totes use linux and it displays all of them
01:52:10 <petrus> shachaf, that was for me in the past but not any more
01:52:20 <Zol_> shachaf: Ok, you mean that par only suggests that its left argument should be run in parallel, but it's up to the runtime to decide finally what will happen?
01:52:25 <petrus> I am not sure when it happened
01:52:29 <shachaf> I mean, what changed?
01:52:40 <petrus> the completion
01:52:41 <shachaf> Ah.
01:52:43 <petrus> ethod\
01:52:46 <shachaf> Yes, I know that.
01:53:10 <shachaf> Zol_: I think it's slightly too complicated to explain the details in IRC. There's plenty of documentation on it to read. :-)
01:53:46 <Zol_> shachaf: Ok, but in essence, it's what the docs say? "Indicates that it may be beneficial to evaluate the first argument in parallel with the second. Returns the value of the second argument."
01:54:10 <shachaf> Hmm, I think there's documentation that says more than that...
01:54:54 <Zol_> shachaf: I think I will settle there, since it looks like my exam is not going to request deeper knowledge than what I've understood so far. Thanks a lot for the help!
01:54:58 <shachaf> E.g. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/lang-parallel.html , maybe.
01:55:05 <Zol_> Oh, ok, will take a look
01:55:32 <shachaf> The idea of sparks is important.
01:55:46 <hunter_> do you think a strongly typed non-pure language would be more widely used?
01:55:51 <hunter_> maybe thats why haskell is niche
01:56:15 <hunter_> what would be the price of a non-pure haskell
01:56:17 <Zol_> hunter_: Look at Scala, OCaml, SML, F#.
01:56:29 <hunter_> i see
01:56:31 <hunter_> whats the downside
01:56:38 <hunter_> to being non-pure
01:56:38 <Zol_> hunter_: Less purity.
01:56:43 <hunter_> why is that bad though
01:56:52 <Zol_> hunter_: Well, why is purity good?
01:56:57 <hunter_> i dont know
01:56:59 <hunter_> why is it?
01:57:18 <Iceland_jack> hunter_: You can search for "advantages of purity funtional programming" and find some explanations
01:57:32 <Zol_> -buffer 377
01:58:22 <hunter_> ah for the sake of organization and simplicity, then?
01:58:46 <Zol_> hunter_: One reason is because the compiler can catch a lot of bugs for you.
01:58:48 <hunter_> in some ways although its much more organized i feel like purity brings a much bigger learning price
01:59:01 <hunter_> Zol_: i think thats got more to do with the type system
01:59:05 <hunter_> Zol_: than the purity
01:59:24 <Zol_> hunter_: It's a two-way street.
01:59:36 <hunter_> Zol_: how so?
01:59:52 <mmmm> I have a map which I suspect is slowly leaking memory by not releasing used objects.. how can I deal with this?
02:00:15 <Zol_> hunter_: http://en.wikipedia.org/wiki/Pure_function
02:01:05 <hunter_> Zol_: i know what a pure function is
02:01:27 <petrus> any ideas for the ghci completion?
02:01:37 <hunter_> Zol_: wikipedia doesnt give any insight into how purity can make things more compiler checkable
02:02:11 <Zol_> hunter_: If you remove state, or shove it out of the way, you will have easier time to reason about your program, and when you write pure functions, the compiler will be able to catch bugs earlier on.
02:02:29 <ski> Zol_ : yes, or something like it. but i also concur with what shachaf said
02:03:07 <shachaf> Which thing shachaf said?
02:03:30 <hunter_> Zol_: i think reasoning about the program is true, but if you think about what haskells compiler is doing as towards catching bugs it only relies on the strong types. You could still have impurity with strong types and you would get the same type checking/bug-catching.
02:04:16 <jesyspa> hunter_: Purity means there are significantly fewer functions of each type, making "foo is of type A -> B" a stronger guarantee.
02:04:27 <ski> hunter_ : "purity" implies that you have more reasoning laws, and so you can more easily reason about and refactor your code, which hopefully results in less complex code and less bugs
02:04:52 <jesyspa> (For some sense of "significantly fewer".)
02:05:03 <ski> shachaf : in reply to WHNF,`force',`par',&c.
02:05:40 <shachaf> Ah, both things.
02:06:05 <ski> hunter_ : making programs (or programming language features / constructs) easier to reason about is good both for computers (language implementations like compilers) and for humans
02:06:48 <hunter_> does anyone else feel its very difficult to approach and learn new librarys in haskell?
02:06:53 <Iceland_jack> hunter_: yup
02:06:57 <shachaf> i,i language implementations like compilers, fruit flies like bananas
02:07:12 <hunter_> does anyone have a theory on why things are that way?
02:07:20 <hunter_> maybe also what we can do to amend that?
02:07:39 <ski> hunter_ : i saw some blog past that argued that the heavy reliance of (re)assignment in imperative programming means that it's easier to screw up the order of things, since you don't name the individual versions of the thing you're working with. you only name the box that contains them, one at a time
02:08:09 <hunter_> ski: are you an academic
02:08:11 <Iceland_jack> hunter_: Bespoke operators, over-generalisation and moving logic to the type level
02:08:16 * ski is as a student
02:08:17 <Iceland_jack> Those are the main ones
02:08:21 <ski> s/as a/a/
02:08:28 <hunter_> Iceland_jack: solutions?
02:08:34 <Iceland_jack> KISS :)
02:08:46 <hunter_> kiss who
02:08:52 <Iceland_jack> Keep It Simple Stupid
02:08:57 <ski> shachaf :)
02:09:10 <ski> DRY
02:09:11 <hunter_> are those solutions or theories about why its difficult ?
02:09:18 <jkarni1> hunter_: I imagine partly it's just because not as many people are using and contributing to Haskell libraries as to, say, python libraries
02:09:26 <ski> (Don't Repeat Yourself)
02:09:35 <Iceland_jack> hunter_: You may want to look at Elm(-lang), they focus on keeping the library interfaces simple and easy to understand
02:10:06 <hunter_> jkarni1: so you think its got more to do with the librarys not being well written than something in the nature of haskell?
02:10:18 <jkarni1> hunter_: no no no
02:10:20 <hunter_> Iceland_jack: isnt elm for javascript?
02:10:38 <frawgie_> hunter_: i suppose Haskell libraries tend to be more abstract than in many other languages, both in documentation and implementation
02:10:41 <Iceland_jack> hunter_: Sure, but it has ML/Haskell like syntax
02:10:44 <jkarni1> hunter_: if you like at something like python's "request", it has 329 contributors
02:11:15 <HrafnA> Haskell encourages people to be smarter than strictly necessary
02:11:16 <jkarni1> hunter_: so many people had questions about how something works along the way, and were probably willing to document their questions
02:11:22 <hunter_> Iceland_jack: im into writing cli stuff
02:11:23 <Iceland_jack> hunter_: It's more an issue of the community, people that like creating abstractions and turning the type system up to 11 with the latest extensions flock to Haskell
02:11:33 <Iceland_jack> my 2c
02:11:48 <hunter_> jkarni1: oh i see
02:12:09 <Iceland_jack> People don't "kill their darlings" as much as they should in my opinion
02:12:17 <hunter_> Iceland_jack: agreed thats the situation i experience
02:12:26 <hunter_> its very abstract and i feel that the problem is
02:12:34 <hunter_> i either dont have the right background knowledge
02:12:45 <hunter_> or its just difficult for everyone
02:13:07 <bartavelle> I recently realized (thanks reddit ..) that for many people, using GADTs is already "turning the type system up to 11" :(
02:13:14 <jesyspa> hunter_: By the way, I'm not sure how you could take, say, C#, and make it even stronger typed.
02:13:24 <jkarni1> hunter_: even Ulysses is approachable nowadays, after so many people banged their heads against it and wrote commentaries
02:13:29 <hunter_> bartavelle: well of course it is if youve never had a type system before
02:13:46 <hunter_> jesyspa: i imagined a way, ill write a short explanation
02:14:02 <Iceland_jack> hunter_: Every library lives in its own world and essentially defines an embedded DSL with its own operators, this is nice if you focus on that library as its own special language but when you combine 3 or 4 libraries each with (>~>), (!*!), (***!), (<*<), (<*>), (>=>), (|||) I experience mental fatigue
02:14:04 <bartavelle> hunter_, yeah, but the comments were like "I'll never use this is production code, because it's so complicated", whereas I believe it actually makes your APIs more resilient ...
02:14:24 <hunter_> jkarni1: what is ulysses
02:15:20 * hackagebot test-framework 0.8.1.0 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.8.1.0 (HerbertValerioRiedel)
02:16:09 <jkarni1> hunter_: A book by James Joyce that's famous for being both good and extremely difficult
02:16:24 <Welkin> I think you mean Finnegan's Wake
02:16:49 <jesyspa> bartavelle: To be honest, GADTs looked really foreign to me until I tried them, at which point it was "Oh, that's all it is?".  Maybe their reputation as hard will drop?  (I suspect lambda functions have/had the same thing.)
02:17:03 <jkarni1> I didn't, but that would also have been a valid comparison
02:17:12 <Iceland_jack> jesyspa: There are also initial kinks that are being worked out with GADTs
02:17:28 <bartavelle> jesyspa, I didn't really knew what they were until I needed them, so I did not realized they had a "reputation"
02:17:37 <jesyspa> Iceland_jack: Ah, cool, could you give an example?
02:18:18 <Iceland_jack> jesyspa: GHC can't detect exhaustiveness for GADTs, there are currently limitations about lifting them to the kind level that do not apply to regular types
02:18:22 <hunter_> jesyspa: http://pastebin.com/MmbUjkqk
02:18:34 <Iceland_jack> In a language like Idris, working with 'GADTs' is a lot less awkward
02:18:49 <hunter_> jesyspa: thats how i would imagine an impure strongly typed language
02:19:10 <jesyspa> Iceland_jack: Ah, maybe I've not touched Haskell GADTs for too long, then.
02:19:16 <jesyspa> Thanks.
02:19:30 <Iceland_jack> Haskell GADTs are very nice, they have come a long way certainly
02:19:45 <jesyspa> hunter_: Hmm, what strong typing does this add?
02:19:55 <jle`> haskell already handles imperative algorithms though
02:20:00 <hunter_> jesyspa: how is it not strongly typed?
02:20:13 <hunter_> jle`: ?
02:20:31 <jle`> you can specify imperative algorithsm just fine with haskell
02:20:32 <jesyspa> hunter_: It's strongly typed, but I'm not sure why it would be *more* strongly typed than existing languages.  It looks about as strong as C#.
02:20:37 <jle`> and gain all of the benefits of type checking
02:20:59 <jesyspa> IO effects as values is cool, but that's all the difference I see.
02:21:15 <hunter_> jesyspa: this was more meant as a take haskell make it impure
02:21:18 <hunter_> jesyspa: demo
02:21:27 <hunter_> jesyspa: rather than take c and make it strongly typed
02:21:38 <hunter_> jesyspa: so just imagine the type system of haskell exists
02:22:30 <hunter_> i suppose i forgot about polymorphic types
02:22:41 <hunter_> but basically i dont see a conflict
02:22:48 <hunter_> between impurity and haskells type system
02:23:38 <tsdh> What's the right term for the individual "lines" of a function definition, i.e., the individual <funName> <pattern> = <body> parts?
02:23:44 <jesyspa> hunter_: Let me phrase the question differently: would you say Haskell is stronger typed than, say, C#?
02:23:47 <Iceland_jack> tsdh: equation
02:23:53 <tsdh> Iceland_jack: Thanks.
02:24:31 <hunter_> jesyspa: im not actually familiar with C# so i mean assuing C# ~ C then yes i guess although im also uncertain about the exact definition of strongly typed
02:24:58 <jesyspa> hunter_: Err, Java, then?
02:25:19 <jesyspa> (It doesn't really matter; C is just ridiculously poorly typed, so not really fair to compare to.)
02:25:24 <ffwacom> https://twitter.com/SwiftOnSecurity/status/545429167341199362
02:25:28 <hunter_> jesyspa: im not masterful enough in java to say for certain that you cant do the things you can do in haskell in java with some work, thanks to templating and generics
02:26:16 <petrus> How can I modify the behavior of completion in ghci, so it shows the possible completions?
02:26:25 <hunter_> jesyspa: i mean if java is in fact as strongly typed as haskell with some work haskell has the benefit of making it much simpler
02:27:10 <jesyspa> hunter_: My point is, I suspect that this "imperative extension" you propose will lose a significant part of the safety of Haskell; so significant that just using an existing imperative language is just as good.
02:27:43 <jle`> you get some neat type safety benefits out of type classes
02:27:45 <hunter_> jesyspa: it will sacrifice the ability to contemplate the program easily
02:27:54 <hunter_> jesyspa: which is huge
02:27:59 <jle`> that you can't get from templates and generics and stuff like that
02:28:13 <jle`> for example, foo :: a -> Bool
02:28:19 <jesyspa> jle`: True, you'll have to wait a little longer for C++ to get those.
02:28:31 <jle`> from parametricity, you know that this can only be one of two things
02:28:35 <hunter_> jesyspa: isnt c++ getting monads
02:28:35 <jle`> foo _ = True
02:28:37 <jle`> foo _ = False
02:28:39 <jesyspa> Although, I think C# has something to that extent.
02:28:41 <jle`> (if we discount bottom)
02:29:23 <hunter_> yea type classes are really great
02:29:25 <jle`> it cannot branch on the `a`
02:29:26 <jesyspa> hunter_: Monads are a library feature, you can write them already.
02:29:32 <jle`> now, let's say we want to branch on the type of a
02:29:34 <jle`> then we can say
02:29:39 <jle`> foo :: Typeable a => a -> Bool
02:29:40 <bartavelle> jesyspa, depends on what you mean by that
02:29:58 <jle`> that means, foo is now "allowed" to branch on and only on the type of `a`
02:30:07 <jle`> let's say we wanted to allow foo to branch on the string representaiton of `a`
02:30:08 <bartavelle> jesyspa, hunter_ : right now you can write monad-like interface for many datatypes, but you can't write monad-independant code (such as mapM)
02:30:11 <jle`> foo :: Show a => a -> Bool
02:30:13 <hunter_> jle`: what do you mean branch
02:30:19 <jle`> the value can depend on the type of `a`
02:30:26 <Iceland_jack> hunter_: "if input has type Bool, the True, else False..."
02:30:40 <jle`> in foo :: a -> Bool, the result can't depend on anything involving a
02:30:52 <hunter_> oh because we know nothing about a
02:30:56 <jle`> if foo :: Typeable a => a -> Bool, the result is now "allowed" to depend on the type of a
02:30:57 <Iceland_jack> Exactly
02:31:01 <jesyspa> jle`: If you've allowed IO anywhere, as hunter_ proposes, you've already got far more implementations than that.  Though you're right, the type systems do allow more circumvention.
02:31:15 <jle`> if foo :: Show a => a -> Bool a, the result is now "allowed" to depend on the string representaiton of a
02:31:21 <jesyspa> the type systems of what I've mentioned*
02:31:22 <jle`> jesyspa: this is true even for implicit side-effects though
02:31:33 <jle`> except you can say a bit less
02:31:54 <hunter_> i think its true that this is a result of purity
02:31:55 <jle`> if foo :: Num a => a -> Bool, you are saying that the result is now allowed to depend on (sume) numerical properties of a
02:31:58 <jle`> *some
02:32:14 <hunter_> this is an interesting way to look at functions
02:32:17 <Iceland_jack> hunter_:
02:32:17 <Iceland_jack>     foo :: Typeable a => a -> Bool
02:32:17 <Iceland_jack>     foo x = case cast x :: Maybe Int of
02:32:17 <Iceland_jack>       Just _  -> True
02:32:20 <Iceland_jack>       Nothing -> False
02:32:25 <jle`> with implicit side-effects, foo :: a -> Bool still isn't allowed to depend on anything about `a`
02:32:39 <jle`> having purity doesn't change this
02:33:02 <hunter_> i guess youre right
02:33:12 <hunter_> as long as a has no guarenteed properties
02:33:15 <hunter_> than you cant use it really
02:33:20 <hunter_> in the result
02:33:41 <jle`> if foo :: Show a => a -> Bool, then foo is allowed to use the string representation of `a` in its result
02:33:57 <jle`> if foo :: Num a => a -> Bool, then foo is allowed to use some numerical properties of `a` in its result
02:34:21 <jle`> and no other properties of `a`
02:34:50 <jle`> with purity added in, you have stronger guaruntees...foo is *only* allowed to use string representation of `a`s for the result, *only* allowed to use some certain numerical properties...
02:34:54 <Iceland_jack> jle`: Which doesn't really give you any extra capabilities though
02:35:33 <hunter_> it gives you a better program overall
02:35:44 <hunter_> easier to reason about, at least
02:36:01 <jle`> Iceland_jack: it might help you narrow down a source of bugs
02:36:15 <jle`> if you limit what you are allowed to know or use from the inputs
02:36:17 <Iceland_jack> jle`: I meant the type 'Num a => a -> Bool' in particular
02:36:23 <jle`> heh. oh yeah
02:36:35 <jle`> maybe that's not the best example
02:36:42 <Iceland_jack> maybe needlessly pedantic :)
02:37:11 <Iceland_jack>     foo :: Show a => a -> Bool
02:37:11 <Iceland_jack>     foo x = show x == "15"
02:37:11 <Iceland_jack>           
02:37:12 <jle`> :)
02:37:32 <jesyspa> hunter_: By the way, "imperative but with Haskell's type system" also gives you the problem of values vs references.
02:38:06 <jesyspa> Which may be less than fun.
02:38:11 <hunter_> i actually think you still couldnt use a to get the Bool knowing only that a was Num
02:38:27 <jle`> why not?
02:38:29 <hunter_> since Num doesnt provide any functions to resolve the type
02:38:29 <jle`> @src even
02:38:29 <lambdabot> even n = n `rem` 2 == 0
02:38:32 <tdammers> "imperative but with Haskell's type system" sounds pretty much like Haskell :D
02:38:48 <jle`> :t even
02:38:49 <lambdabot> Integral a => a -> Bool
02:38:57 <hunter_> Integral ^
02:39:07 <Iceland_jack> There is no way to return a non-a type from 'Num a => a'
02:39:15 <hunter_> yea
02:39:16 <jle`> heh
02:39:29 <hunter_> in some way you need to be able to resolve a to a boolean
02:39:35 <jesyspa> tdammers: Not if you want mutable-by-default and implicit-performUnsafeIO
02:39:36 <hunter_> which means a eventually has to become concrete
02:39:44 <jesyspa> :)
02:39:48 <Iceland_jack>     foo :: Num a => a -> Bool
02:39:48 <Iceland_jack>     foo x = ??? negate (x * x) + fromInteger 5 ???
02:40:19 <hunter_> jesyspa: im just going to forget the whole thing
02:40:45 <tdammers> jesyspa: those aren't really necessary properties of imperative programming
02:40:51 <jle`> jesyspa: haskell can specify imperative algorithms just as well as any other imperative language
02:41:10 <jesyspa> tdammers, jle`: No, but I was reacting specifically to hunter_'s suggested changes.
02:41:19 <jle`> ah
02:41:22 <hunter_> tdammers: state is a really nice benefit of most imperative languages
02:41:24 <jesyspa> I like Haskell the way it is. :)
02:41:30 <hunter_> tdammers: and you have to deal with reference for state
02:41:34 <hunter_> i think
02:41:48 <tdammers> hunter_: arguably, and yes, state is commonly associated with imperative programming
02:42:01 <jle`> haskell can work with state too tho
02:42:08 <tdammers> hunter_: but this doesn't mean mutable state has to be implicit
02:42:10 <Armel`> Hi again! :) Is there a way to make ghci use a proxy when doing some HTTP I/Os?
02:42:10 <jle`> > foldr (+) 0 [1..10]
02:42:12 <lambdabot>  55
02:42:18 <tdammers> and indeed, haskell can model stateful computations just fine
02:42:36 <bartavelle> Armel`, that depends on the library you are using in GHCI
02:42:38 <jle`> haskell has no problems specifying imperative algorithms involving state mutation
02:42:59 <Armel`> bartavelle: wreq
02:43:24 <hunter_> jle`: are you referring to something outside of do and the state monad?
02:43:37 <jle`> yes, i'm referring to normal types...
02:43:38 <tdammers> hunter_: do notation is just syntax sugar
02:43:42 <jle`> an algorithm is an algorithm
02:43:44 <hunter_> tdammers: i know
02:43:54 <tdammers> hunter_: and actually, so is the state monad
02:43:55 <Armel`> There is a way to specify a proxy using wreq but does wrea can use the "system proxy" directly?
02:44:03 <tdammers> in a way
02:44:04 <hunter_> jle`: can you give an example of state / imperative in that sense
02:44:07 <bartavelle> Armel`, there is a "proxy" lens with sample usage here : http://hackage.haskell.org/package/wreq-0.3.0.1/docs/Network-Wreq.html#g:14
02:44:14 <hunter_> tdammers: in what way?
02:44:30 <jle`> here is a very imperative algorithm to find the sum of all integers between 1 and 100:
02:44:34 <jle`> 1) start with a state of 0
02:44:40 <jle`> 2) for each number, add that number to your state
02:44:42 <tdammers> hunter_: there's no magic there, you could implement exactly what State does on an ad-hoc basis without using the Monad abstraction
02:44:46 <jle`> 3) return the final value of that state
02:44:53 <jle`> here is an implementation in haskell of that imperative algorithm:
02:45:00 <jle`> > foldl' (+) 0 [1..100]
02:45:00 <bartavelle> Armel`, I don't think this works, because it's annoying to do well ("system proxy" depends on the system)
02:45:01 <lambdabot>  5050
02:45:22 <bartavelle> but cabal seems to read my http_proxy environment variable
02:45:36 <hunter_> jle`: ok, but im talking about the imperative style of programming
02:45:57 <jle`> do you mean programming with imperative algorithms?
02:45:57 <Iceland_jack> hunter_: You _can_ model that in Haskell, but it's rarely good style
02:46:07 <hunter_> im not saying its impossible in haskell
02:46:14 <jle`> because haskell can specify imperative algorithms just fine...
02:46:26 <hunter_> im not saying you cant write imperative algorithms
02:46:38 <hunter_> im saying you cant write in an imperative style
02:46:47 <bartavelle> Armel`, the HTTP library seems to do this
02:47:07 <hunter_> you write in the functional style
02:47:07 <Iceland_jack> hunter_:
02:47:07 <Iceland_jack> > runST (do ref <- newSTRef 0; F.for_ [1..100] (\i -> modifySTRef ref (+ i)); readSTRef ref)
02:47:08 <lambdabot>  5050
02:47:14 <bartavelle> although I don't think it's as nice to use as wreq
02:47:26 <tdammers> > runState (forM [1..100] $ \x -> modify (+ x)) 0
02:47:27 <lambdabot>  ([(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
02:47:29 <jle`> > flip execState 0 $ traverse (\x -> modify (+x)) [1..100]
02:47:31 <lambdabot>  5050
02:47:35 <tdammers> hehe
02:47:37 <tdammers> almost
02:47:37 <Armel`> bartavelle: I thought wreq was just wrapping the HTTP library.
02:47:44 <jle`> i'm using traverse so then nobody is allowed to call it "the state monad" :P
02:47:54 <bartavelle> Armel`, wreq depends on http-client
02:47:54 <tdammers> jle`: yeah, that'd work
02:48:03 <Iceland_jack> hunter_: A formatted version, this uses a mutable variable
02:48:03 <Iceland_jack>     do ref <- newSTRef 0
02:48:03 <Iceland_jack>        F.for_ [1..100] $ \i -> do
02:48:03 <Iceland_jack>          modifySTRef ref (+ i)
02:48:06 <Iceland_jack>        readSTRef ref
02:48:24 <bartavelle> anyway, brb
02:48:46 <Iceland_jack> But it's not pretty.
02:48:48 <hunter_> Iceland_jack: yea i do know this stuff
02:49:10 <Iceland_jack> It sounded like this was what you were asking, my bad.
02:49:14 <jle`> but
02:49:20 <jle`> no true imperative scottsman is like that
02:49:20 <hunter_> no that does fit what i was asking
02:49:21 <hunter_> just
02:49:24 <hunter_> imperative style
02:49:30 <hunter_> you guys know what i mean by imperative style
02:49:32 <tdammers> I would argue that it's not very pretty in an "imperative language" either; Haskell just happens to map conceptual ugliness to ugly syntax more accurately
02:49:47 <tdammers> hunter_: you mean "something that looks like imperative syntax"
02:49:47 <jle`> what is imperative style? thinking in imperative algorithms?
02:49:54 <hunter_> tdammers: conceptaully it seems straightforward to me
02:50:14 <hunter_> c style
02:50:18 <hunter_> jle`:
02:50:22 <tdammers> hunter_: conceptually, you want to use destructive iteration and mutable state
02:50:30 <jle`> so your definition of imperative style is C
02:50:34 <hunter_> tdammers: what is destructive iteration
02:50:40 <hunter_> jle`: its a programming style
02:50:41 <jle`> by definition, no other language other than C is imperative style
02:50:44 <tdammers> i.e., a mutable variable to collect your result, and a mutable variable to implement the loop
02:50:57 <hunter_> jle`: i dont know how to formulate the difference between c-esque languages and functional programming
02:51:14 <tdammers> int x = 0; for (int i = 0; i < 100; ++i) { x++; } return x;
02:51:15 <jstolarek> http://lpaste.net/116763
02:51:23 <tdammers> both x and i are mutable in this example
02:51:24 <jle`> to me, "imperative style" means writing imperative algorithms in order to get what you want
02:51:32 <tdammers> and mutating variables is a destructive operation
02:51:34 <jstolarek> how do I derive instances of Data and Typeable for my definition of BranchList?
02:51:36 <jle`> and "thinking imperatively"
02:51:42 <jstolarek> if I say:
02:51:43 <jstolarek> deriving instance (Data.Data a, Data.Data br) => Data.Data (BranchList a br)
02:51:57 <jstolarek> GHC complains that br should have kind AxiomBranched, not *
02:52:00 <hunter_> tdammers: really? i didnt realize it was destructive
02:52:13 <hunter_> tdammers: i thought variables were mutable on a very low level
02:52:16 <tdammers> hunter_: of course it is. The previous value of the variable is gone forever
02:52:28 <hunter_> tdammers: that is true
02:52:29 <jstolarek> if I put kind signature on br in deriving clause then I get error from the deriving mechanism
02:52:34 <hunter_> tdammers: its overwritten
02:52:34 <tdammers> hunter_: it is literally removed from the memory cell that used to store it
02:52:51 <tdammers> hunter_: if that's not destructive at the lowest possible memory, then I don't know what is
02:52:53 <hunter_> tdammers: is it actually destroyed and then rewritten, or just overwritten in one step
02:53:08 <hunter_> tdammers: the value is destroyed for sure
02:53:24 <tdammers> hunter_: implementation detail. A C variable update probably ends up overwriting a CPU register and/or a RAM location
02:53:28 <tdammers> in-place
02:53:59 <tdammers> the overwriting is destructive, it's pretty common to call it that
02:54:35 <jle`> my C implementation actually pokes a physical hole in that place in memory and waits for the user to put in a new RAM card before writing the new value
02:55:08 <hunter_> thats really efficient
02:55:21 <jle`> all of the asymptotics are the same
02:55:25 <tdammers> jle`: if you work in Big Data, consider a sledgehammer instead - just destroy the entire server and write the new value to another server
02:55:44 <jle`> O(n) algorithsm on writes stay O(n), so what's the big deal
02:55:44 <hunter_> asymptotics?
02:56:16 <tdammers> destroy server -> order new server -> wait for new server to be installed -> write value
02:56:21 <jle`> even better, O(1) algorithsm stay O(1).  basically just as performant
02:56:24 <hunter_> jle`: anyways, lets say imperative programming is capturing imperative algorithms, a good imperative style would be making it easy to do so
02:56:35 <tdammers> time to update variable: 3 weeks. Still O(1) though.
02:56:48 <hunter_> jle`: in that sense its unclear if haskell has a good style, but its style is certainly unnatural for most of the world
02:57:24 <tdammers> hunter_: two concerns here, one, which paradigm do you use to approach a problem, and two, is the language you are using suitable to support your way of approaching the problem
02:57:50 <hunter_> well
02:57:55 <hunter_> im going to sleep
02:57:58 <hunter_> instead
02:58:01 <tdammers> haskell doesn't mandate any paradigm, but it is more suited to a functional problem solving approach than, say, an object-oriented one
02:58:19 <hunter_> im going to hang out here more
02:58:25 <tdammers> by all means do
02:58:48 <hunter_> thanks
02:58:49 <hunter_> bye
03:11:03 <Io-Robot> hello
03:13:30 <moop> hello input output robot
03:15:31 <Io-Robot> . Who has created this game ? Robert Kooima http://yoliece463.itch.io/nexus-ball
03:20:01 <ski> @tell hunter_ "http://pastebin.com/MmbUjkqk","thats how i would imagine an impure strongly typed language","i suppose i forgot about polymorphic types","but basically i dont see a conflict","between impurity and haskells type system"
03:20:01 <lambdabot> Consider it noted.
03:20:13 <ski> @tell hunter_ there is indeed a conflict between polymorphism and assignment. if you don't add some restrictions, you can break the type safety by combining those two
03:20:13 <lambdabot> Consider it noted.
03:20:16 <ski> jesyspa ^
03:20:22 <ski> tsdh : "What's the right term for the individual \"lines\" of a function definition, i.e., the individual <funName> <pattern> = <body> parts?" -- (defining) equation or (defining) clause
03:20:25 <Io-Robot> o I'm an Ai
03:20:36 <ski> jle` : "foo :: Typeable a => a -> Bool","that means, foo is now \"allowed\" to branch on and only on the type of `a`" -- as soon as it knows the type, it can use all the known operations of that type to possibly also depend on the value. Iceland_jack's example can be extended to show this
03:20:56 <ski> @tell hunter_ "state is a really nice benefit of most imperative languages" -- it (state side-effects) sure increases the expressivity, yes. it also increases the "unreasonability" (iow decreases the ability to reason (including refactor) effectively about the language)
03:20:57 <lambdabot> Consider it noted.
03:21:29 <ski> @tell hunter_ removing the "side" in "side-effects", as Haskell does, helps with this (it insulates the rest of the program from the effects), but doesn't solve it completely (since you can still program monadically with state, which is still hard to reason about)
03:21:29 <lambdabot> Consider it noted.
03:21:53 <jle`> i gotta find better examples
03:22:45 <ski> Io-Robot : dunno
03:23:30 * ski performs I/O on the robot, unsafely
03:30:02 <Zol_> Is there any reason for writing a non-generic function, if the algorithm is the same for both? I mean, String -> Bool vs a -> Bool for example.
03:30:56 <shachaf> Generally the most general type is best.
03:31:00 <shachaf> (If there is one.)
03:31:16 <Iceland_jack> Zol_: Yes, for example why you use (.) rather than fmap
03:31:23 <shachaf> It makes it easier to write the program, easier to figure out what it does, and so on.
03:31:26 <Iceland_jack> For clarity
03:32:45 <Iceland_jack> In lens there is also a function 'traverseOf' that is simply defined as 'traverseOf = id'
03:36:47 <tsdh> ski: Yes, thanks.
03:40:41 <ski> tsdh : the part being defined (to the left of `=') is known as "definiendum" (pl. "definienda") or "head" or "left-hand-side". the thing (to the right of `=') it is defined in terms of is known as "definiens" (pl. "definientia") or "body" or "right-hand-side"
03:41:12 * ski is a little uncomfortable with the "LHS" and "RHS" terms
03:41:57 <sinelaw> ski, why?
03:42:01 <tsdh> ski: I'm comfortable with LHS/RHS coming from a graph transformation background.
03:42:20 <sinelaw> it's not an actual definition of the intention but they are universally accepted
03:43:06 <sinelaw> Actually it offends my RTL culture. I protest!
03:43:20 <sinelaw> typical western colonialism
03:43:39 <ski> sinelaw : well, (a) because those are also used in other contexts (say an equation we want to solve, or a general law, where one could just as easily flip the sides); and also (b) because it assumes left-to-right reading&writing, and i'm anxious about depending arbitrarily on such symmetry-breaking things
03:44:59 <sinelaw> ski, ok, but we need better terms (preferably not in latin)
03:45:45 <sinelaw> "the thing being defined" and "the value being assigned"
03:46:15 <ski> (which is also the reason why i'm not comforable with the terms (regarding functions) "compose to the left/right" and "left/right cancellable" .. i think "postcompose"&"precompose" and "post-cancellable"&"pre-cancellable" are better in that regard)
03:46:24 <ski> sinelaw : yes, that would be nice
03:47:08 <shachaf> ski: I never remember which one is precompose and which one is postcompose.
03:47:09 <ski> in the meantime, i usually either try to use the latin terms, or the "head"/"body" dichtomy
03:47:36 <ski> shachaf : "pre" is composing on the input side of a function. "post" is composing on the output side
03:48:27 <shachaf> ski: That doesn't answer the question "when you precompose f with g, which way are you composing?". :-)
03:49:02 <ski> sinelaw : it's not so much the colonial aspect (in itself) which offends me, but having to arbitrarily break symmetry
03:50:12 <ski> shachaf : `f' is the main thing you're operating on, and you modify it by the auxilary thing `g'. so it must be `f . g', and the "precompose `f'" function is `\g -> f . g'
03:50:32 <shachaf> OK.
03:52:07 <sinelaw> ski, I was kidding about the colonialism. It makes sense for English-speaking people to use terms that make sense for them.
03:52:32 <ski> (similarly, when you add `3' to `5', `5' is the main thing you are modifying, and `3' is the thing you're using to modify it (it controls the operations, if you will). so `3' is the addend, and `5' is the augend. in general, if you add an absolute and a relative thing, getting an absolute, the relative thing is the addend (the thing you add), and the absolute input is the augend (the thing you add to))
03:53:13 <sinelaw> ski, what about  "foldr" and "foldl"?
03:53:26 <sinelaw> ski, they too assume a LTR writing system
03:53:28 <ski> (e.g. the absolute thing can be a point (in some geometric space, an affine space), and the relative thing can be a vector (in a corresponding vector space))
03:54:32 <ski> sinelaw : yes. if you define `data SnocList a = Nil | Snoc (SnocList a) a', then `foldrSnocList' would be the tail-recursive one, and `foldlSnocList' the catamorphism
03:55:11 <sinelaw> ski, so do want to rename foldr?
03:55:18 <sinelaw> do you want*
03:56:14 <ski> i'm not sure, but i suppose it's not as much of an issue there, since there's already another arbitrary choice involved (the associativity of the list data srtucture)
03:58:56 <ski> (anyway. when you multiply `4' (or `orange', or `kick') with `3', then you're modifying the former main object, the multiplicand, while you're operating this modification by the latter, the multiplier. if you have a group `G', and a normal subgroup `N', and a corresponding quotient/factor group `F', then in `G = N * F' (semi-direct product) you can think of `F' as the multiplier and `N' as the multiplicand)
04:01:00 <ski> (because of this potential asymmetry in the basic operations of addition and multiplication, which is lost when we abstract to say naturals,integers,rationals,reals (where we get commutativity), there's correspondingly two versions of subtraction, and two versions of division)
04:01:58 <ski> (and this is why i prefer the term "factor group" to "quotient group", since the role it plays is not that of quotient (which would be the normal subgroup), but that of factor/multiplier)
04:20:21 * hackagebot keter 1.3.7.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.7.1 (MichaelSnoyman)
04:21:39 <phischu> how do I switch off --make in GHC?
04:33:05 <favetelinguis> is the size paramater in quickcheck the same as a seed in a random generator?
04:33:32 <opqdonut> no
04:33:54 <opqdonut> it's the size of the inputs, so for example for lists larger sizes generate longer lists
04:34:55 <favetelinguis> ok so it is the same value every time i call arbitrary for a list generator
04:35:02 <favetelinguis> hardcoded by quickcehck?
04:35:21 * hackagebot etcd 1.0.3 - Client for etcd, a highly-available key value store  http://hackage.haskell.org/package/etcd-1.0.3 (wereHamster)
04:36:27 <opqdonut> favetelinguis: you can inject the size somehow
04:36:42 <opqdonut> have a look at the "instance Arbitrary a => Arbitrary [a]" in https://hackage.haskell.org/package/QuickCheck-2.1.0.1/docs/src/Test-QuickCheck-Arbitrary.html#Arbitrary
04:37:11 <opqdonut> yeah, you can use resize :: Int -> Gen a -> Gen a to change the size
04:37:21 <opqdonut> I guess the default is indeed hardcoded somewhere
04:37:23 <dmwit> favetelinguis: Again, no. The tester starts with small sizes and asks for larger and larger ones as more tests pass.
04:37:39 <opqdonut> favetelinguis: also note that the quickcheck Args struct has a maxSize field
04:38:22 <favetelinguis> thanks i get it now, smart solution :)
04:38:57 <trap_exit> we need somethign like mesosphere
04:38:59 <trap_exit> but haskel based
04:39:02 <trap_exit> and it's not cloud ahskell
04:39:03 <ski> @type Test.QuickCheck.sized  -- favetelinguis, you can set it locally, using this
04:39:04 <lambdabot> (Int -> Gen a) -> Gen a
04:39:28 <ski> er, the other way around, depend on it
04:39:38 <ski> though i also think you can set it locally
04:39:52 <favetelinguis> thats what im using right now with frequency for my recursive datatypes, was not just sure how it worked
04:40:17 <ski> @type Test.QuickCheck.resize  -- yeah, right
04:40:18 <lambdabot> Int -> Gen a -> Gen a
04:40:56 <ski> i think that works more or less like `local', iow it's in effect for the action argument of `resize', but then reverts back to the old value
04:43:51 <nkar> phischu: -fno-code (i.e., "only typecheck") maybe?
04:45:23 <aloiscochard> trap_exit: why do we need that?
04:45:35 <trap_exit> to write one haskell prog
04:45:41 <trap_exit> to control a datacenter
04:45:50 <trap_exit> programming one machine at a time is such a drag
04:46:11 <tdammers> isn't that what things like Puppet and Chef are for?
04:46:47 <trap_exit> no, you'd still have little haskell progs running around
04:46:54 <trap_exit> have you programmed in haste?
04:46:57 <trap_exit> it's client + server side as a single prog
04:47:02 <trap_exit> I wnat to program a datacenter like that
04:54:50 <tdammers> I'm not a fan of pretending that there is no network between the client and the server
04:56:45 <bartavelle> I'd think it's more like thinking about threads, all the code is written in the same language, even share the same source files, and (in Haskell at least) you use specific communication mechanisms (MVar, STM, etc.)
04:57:08 <bartavelle> instead of having 2 programs, writing the client side, server side, both data marshalling, RPC, etc.
04:57:33 <aloiscochard> tdammers: +1
04:57:34 <bartavelle> a bit like cloud haskell I'd expect, but trap_exit said it's not cloud haskell, so I don't really know what he means
04:57:57 <trap_exit> I want to be able to do smoething like
04:58:02 <trap_exit> main :: DataCEnter ()
04:58:04 <trap_exit> main = do
04:58:05 <aloiscochard> I have a hard time to believe in system that try to abstract away the communication, like actors
04:58:06 <trap_exit>   x1 <- get computer
04:58:09 <trap_exit>   x2 <- get computer
04:58:15 <trap_exit>   y <- do_computation _on _x1
04:58:25 <trap_exit> so it's not pretending that the network isn't there
04:58:30 <aloiscochard> right
04:58:35 <trap_exit> but it's allowin gme to fire up machines and do computations on them within a single haskell prog
04:58:41 <aloiscochard> now, I understand what you want trap_exit
04:58:50 <trap_exit> aloiscochard: do you also want it now?
04:58:52 <trap_exit> say yes
04:58:53 <bartavelle> it's more like an orchestration system
04:58:56 <aloiscochard> haha
04:59:13 <trap_exit> orchetration and computation should be one language, one codeabse
04:59:26 <bartavelle> that's very debatable, DSLs and stuff
04:59:38 <jonaszzz> hellooooooo
04:59:43 <bartavelle> I'd say that orchestration and configuration management should be one codebase ;)
04:59:45 <trap_exit> bartavelle: you are hereby excommunicated from the cult of haskell-as-a-datacenter
05:00:04 <bartavelle> I thought your cult was datacenter-as-haskell
05:00:05 <jonaszzz> how can i make a state in my main :: IO () ?
05:00:07 <trap_exit> everything should be a monad
05:00:15 <trap_exit> righ tirhg,t data-center-as-a-haskell-prog
05:00:31 <trap_exit> jonaszzz: what are you trying to acheive?
05:00:40 <trap_exit> i am haskell expert
05:01:25 <dbushenko> hi all!
05:01:25 <dmwit> jonaszzz: newIORef, or their concurrency-friendly cousins newMVar/newTVar.
05:01:25 <jonaszzz> let me make a code sample one second
05:01:33 <dbushenko> how to create an anonymous function without parameters?
05:01:35 <dmwit> jonaszzz: Or half a dozen other ways. Depends what you need.
05:01:46 <dmwit> dbushenko: A function always has a parameter.
05:02:08 <dmwit> dbushenko: Some people will tell you a function always has exactly one parameter, even.
05:02:15 <dbushenko> :-)
05:02:35 <jonaszzz> look at this: http://lpaste.net/116766
05:03:09 <dbushenko> ok then
05:03:13 <dbushenko> consider this code http://lpaste.net/116767
05:03:16 <jonaszzz> when i put something it returns StateT, so i can't do that in my main?
05:03:38 <srhb> jonaszzz: You'll need runStateT or evalStateT or the last one which I don't remember
05:03:42 <dbushenko> in "createPool (newConn conf) delConn 1 60 5" what is the construction (newConn conf) ?
05:03:42 <dmwit> exec
05:03:46 <srhb> dmwit: Thanks.
05:03:47 <trap_exit> jonaszzz: are you coding in ghcjs, haste, or fay ?
05:03:58 <dbushenko> is it the result (a connection) or a curried function?
05:04:03 <jonaszzz> no, with gtk :p
05:04:08 <trap_exit> oh
05:04:09 <dmwit> dbushenko: It's the application of the function "newConn" to the value "conf".
05:04:33 <jonaszzz> gtk2hs i'm making a GUI
05:04:46 <jonaszzz> but i need to change the state in my event handler
05:04:57 <srhb> jonaszzz: Assuming you have a foo :: StateT s IO a, runStateT foo :: IO (a,s)
05:04:58 <dmwit> jonaszzz: If you use StateT with gtk2hs without understanding it, you're gonna have a bad time.
05:05:04 <jonaszzz> so i'm using a state which i can pass around? that seems logic right, but i'm stuck on how to create it in my main :: IO ()
05:05:22 * hackagebot semigroups 0.16.0.1 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.16.0.1 (EdwardKmett)
05:05:28 <srhb> jonaszzz: Don't put it in your main directly (unless you're going to use IORefs instead or something)
05:05:31 <dmwit> jonaszzz: http://stackoverflow.com/q/12002814/791604
05:05:45 <dmwit> "How to deal with application state in Gtk2Hs"
05:06:11 <dmwit> dbushenko: Per your last question, I'm not sure. It might be both!
05:06:29 <dbushenko> dmwit, yep, this is what I'm trying to figure out....
05:06:44 <dmwit> dbushenko: Depends on what "connect" is, and possibly on what "createPool" is.
05:07:13 <dmwit> dbushenko: :t connect -- ?
05:07:19 <dbushenko> moment...
05:07:58 <dbushenko> connect :: ConnectInfo -> IO Connection
05:08:25 <dmwit> Then (newConn conf) is not a curried function.
05:08:36 <dbushenko> thanks!
05:09:19 <dmwit> But it's also not a connection.
05:09:28 <dmwit> So it turns out the direct answer to your question is "neither".
05:09:56 <tdammers> direct, but not super helpful :D
05:10:37 <dmwit> I blame the question, not the answer. =)
05:10:49 <tdammers> easy way out ;d
05:11:10 <tdammers> important distinction though: Connection and IO Connection are not the same thing
05:11:27 <dbushenko> dmwit, I'm trying to apply resource-pool to mysql-simple connection
05:11:58 <dbushenko> so the first argument of createPool is
05:12:00 <dbushenko> IO a	
05:12:00 <dbushenko> Action that creates a new resource.
05:12:10 <dbushenko> this is what I can't understand
05:12:26 <dbushenko> does it use one single connection or creates it each time it needs it?
05:13:29 <tdammers> newConn conf :: IO Connection -- right?
05:13:37 <tdammers> so that type tells you two things:
05:13:41 <tdammers> one, it's an IO action
05:13:41 <dmwit> I would expect something with a name like "createPool" to wait until the resource is needed, then connect; possibly many times concurrently.
05:13:53 <tdammers> two, it wraps around a Connection ("returns" a Connection)
05:15:17 <tdammers> what exactly the semantics of "create a connection" are, and what the Connection type entails, is impossible to tell from the type alone
05:17:12 <jonaszzz> i  don't understand, can anyone edit this code? http://lpaste.net/116766
05:17:24 <dmwit> I think one can say even more in this case.
05:17:56 <dmwit> The fact that createPool takes an IO a instead of just an a means it intends to regenerate the a several times (or potentially intends never to generate the a in the first place, or similar).
05:17:59 <dbushenko> tdammers, ok, let us think logically. if newConn conf produces an IO with a connection, then, after closing this connection, pool can't reuse it
05:18:14 <dbushenko> an also it can't create a new one with action (newConn conf)
05:18:20 <dbushenko> since it is not a function
05:18:26 <dmwit> jonaszzz: We're not going to write code for you...
05:18:27 <dbushenko> doesn't it?
05:18:41 <dbushenko> it looks logically for me
05:18:50 <dmwit> dbushenko: That is not correct. It can indeed create a new connection by executing the (newConn conf) action again.
05:19:06 <dbushenko> dmwit,
05:19:08 <dbushenko> nice!
05:19:14 <dbushenko> but how is it possible?
05:19:37 <jonaszzz> okay, but just tell me how i can create a new state in my main :: IO ()
05:19:39 <dmwit> dbushenko: Well, (>>) takes two actions and runs them both.
05:20:11 <dmwit> dbushenko: So it's easy to write a compound action that executes a simple action many times.
05:20:30 <dmwit> jonaszzz: "newIORef, or their concurrency-friendly cousins newMVar/newTVar."
05:21:01 <dbushenko> dmwit, that blows my mind..
05:21:14 <dmwit> dbushenko: Yes, first-class IO actions are pretty cool.
05:21:23 <dbushenko> may be you could point me to some documentation?
05:21:23 <dmwit> I miss them often in other languages.
05:22:01 <dmwit> dbushenko: Well, any monad tutorial, I suppose. Or sigfpe's "IO for people who just don't care" is nice if you don't feel ready for the monad abstraction yet and want to stay specific.
05:22:12 <dbushenko> thanks!
05:23:01 <jonaszzz> is that Data.IORef ?
05:23:34 <dmwit> jonaszzz: Yep! Sorry, I should have pointed you to some documentation.
05:23:50 <dmwit> If you haven't used Hoogle before, you definitely should give it a look.
05:24:00 <dmwit> https://www.haskell.org/hoogle/?q=newIORef
05:24:21 <dmwit> You can also search for values by type.
05:25:12 <dmwit> If you click the "newIORef" result it will tell you more about that function.
05:33:05 <jonaszzz> thanksssssss got i working :p
05:34:01 <jonazzzz> just a question why not STRef instead of IORef?
05:34:35 <dmwit> Try it and see. =)
05:35:22 <dmwit> ST is carefully designed to make it impossible to pull the mutable bits out.
05:35:26 <dmwit> STRef's are mutable.
05:35:53 <dmwit> So... it's impossible to pull an STRef out of the ST monad and into IO.
05:36:33 <jonazzzz> ok thanks
05:40:33 <dramforever> dmwit: stToIO
05:40:36 <dramforever> :t stToIO
05:40:37 <lambdabot> ST RealWorld a -> IO a
05:41:37 * dmwit nods agreeably
05:42:06 <dmwit> Any coder worth his salt can do the impossible.
05:42:12 <dmwit> But you still talk about it as if it's impossible. ;-)
05:42:20 <trap_exit> @remember dmwit "Any coder worth his salt can do the impossible."
05:42:20 <lambdabot> I will remember.
05:42:35 <trap_exit> dmwit: write me a linear time SAT solver
05:42:47 <trap_exit> dmwrite: write me a _constant time_ halting problem solver :-)
05:42:55 <chris2> works for 2-SAT :P
05:43:03 <dmwit> data SATResult = Yes | Maybe | No
05:43:05 <dmwit> const Maybe
05:43:07 <dmwit> ;-)
05:43:27 <trap_exit> dmwit: you should not be a programmer
05:43:29 <trap_exit> you should be a lawyer
05:45:44 <ab9rf> pay is better, but it takes a toll on your soul
05:45:57 <srhb> Only paid in the afterlife, it's fine.
05:46:52 <ab9rf> there are no grotesque hairy hand stories in a computer science degree, either
05:50:22 * hackagebot Deadpan-DDP 0.6.0.0 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.6.0.0 (LyndonMaydwell)
05:50:48 <remdezx> Hi! Why ghci works so slow for some functions like `run` from accelerate-cuda? When I use it in executable it works 3 times faster than in interpreter... Even specialising it in accelerate-cuda package does not work, What am I missing?
05:51:25 <dramforever> remdezx: ghci is slow. period.
05:51:34 <ab9rf> ^
05:52:11 <dramforever> same for all "interpreters vs. compilers" comparsions
05:53:05 <remdezx> dramforever: but shouldn't it just load compiled function and just call it?
05:54:02 <dramforever> remdezx: maybe because ghci cannot optimize?
05:54:11 <dramforever> did you use ghc -O?
05:54:46 <ocharles_> remdezx: GHCI can only load compiled modules, it can't load a compiled function
05:54:54 <ocharles_> so maybe you're importing the module that you want to work with as interpreted
05:54:55 <remdezx> dramforever: of course! I'm compiling with ghc -O2 and loading it later into ghci
05:55:09 <ocharles_>  The module will have a * in the prompt (by default) if it's interpreted
05:55:18 <Darwin226> Hey guys, this is probably stupidly simple but I'm lost. If I have a char 'n', how can I "escape" it into '\n'?
05:55:52 <ocharles_> Darwin226: do you mean always prefix it with a \ character?
05:55:57 <ocharles_> E.g i -> \i ?
05:56:00 <dramforever> Darwin226: maybe you want a character table
05:56:10 <remdezx> It shows that is compiled :show modules says that is compiled
05:56:28 <ocharles_> If not, you need to decide what escaping means - if it's a common escaping scheme then maybe someone has already written what you need in a library
05:56:30 <opqdonut> Darwin226: do you want the string of two characters "\n" or the line return character '\n'
05:56:33 <opqdonut> ?
05:56:34 <dramforever> remdezx: I'm not sure then
05:56:39 <Darwin226> Basically, I'm parsing a string and I want to convert "\n" into the actual newline character
05:56:50 <benzrf> Darwin226: parse backslashes
05:56:54 <ocharles_> oh, that's not quite escaping then
05:57:03 <ab9rf> it's actually 'unescaping'
05:57:08 <Darwin226> ocharles_: Yeah, my terminology is probably off :D
05:57:12 <ocharles_> or just parsing, yea :)
05:57:20 <benzrf> Darwin226: have your normal string-contents-parser match on anything /besides/ a backslash instead of anything
05:57:30 <benzrf> Darwin226: then have a special case that reads a parser and then the escaped char
05:57:53 <ab9rf> i'm sure that's trivial in attoparsec but i'm not awake enough
05:58:09 <dramforever> let blah [] = []; blah ('\\':'n':cs) = '\n':blah cs; blah (c:cs) = c:blah cs in blah "\\n"
05:58:19 <dramforever> > let blah [] = []; blah ('\\':'n':cs) = '\n':blah cs; blah (c:cs) = c:blah cs in blah "\\n"
05:58:20 <lambdabot>  "\n"
05:58:22 <Darwin226> benzrf: But if the string actually contains the two characters '\' and 'n'. How do I merge them into a newline char?
05:58:25 <dramforever> great
05:58:44 <dramforever> Darwin226: do you understand what I wrote?
05:59:15 <joe9> http://www.stephendiehl.com/what/#prelude talks about masking some Prelude functions. Just want to check if it is a good idea to add some more to them.
05:59:28 <Darwin226> dramforever: Sure, but that requires a special case for every char that can be backslashed
05:59:31 <srhb> Darwin226: "\\n" needs to be converted to "\n"
05:59:50 <ocharles_> You could possibly hack around parsing by (ab)using `read`
06:00:08 <Darwin226> ocharles_: Right! That should work!
06:00:10 <srhb> or if you just want to replace every single n with newline, "n" -> "\n"
06:00:21 * srhb is probably misunderstanding the question
06:00:41 <Darwin226> srhb: "\\n" needs to be converted to 'n'
06:00:47 <Darwin226> srhb: "\\n" needs to be converted to 'n'
06:00:47 <remdezx> so I first compile this module with 'ghc -dynamic -c -O2' and later load it and run.in ghci but it is still slow. I tried specializing everything I use and recompiling it but is still slow....
06:00:52 <Darwin226> '\n' sorry
06:00:58 <srhb> Right. :)
06:01:18 <ocharles_> > let hack s = read ("\"" ++ s ++ "\"") :: String in hack "Hello \\n"
06:01:19 <lambdabot>  "Hello \n"
06:01:25 <ocharles_> Can't say I particularly recommend that
06:01:29 <ab9rf> heh
06:01:30 <remdezx> there is also similiar question on stackoverflow: http://stackoverflow.com/questions/27541609/difference-in-performance-of-compiled-accelerate-code-ran-from-ghci-and-shell
06:01:36 <dramforever> can't recommend that
06:01:44 <dramforever> > let hack s = read ("\"" ++ s ++ "\"") :: String in hack "Hello\" \\n"
06:01:45 <lambdabot>  "*Exception: Prelude.read: no parse
06:01:55 <ocharles_> of course, it has plenty of problems
06:01:58 <srhb> Darwin226: Data.List.Utils has replace. :)
06:02:02 <ocharles_> but it does answer the original question :)
06:02:13 <srhb> Think there's one in a better library though...
06:02:29 <dramforever> ocharles_: but that fails for some cases
06:02:46 <Darwin226> Now I'm considering just parsing the few cases I need myself
06:03:04 <dramforever> Darwin226: are they all backslash - one char?
06:03:06 <ab9rf> don't oversolve the problem
06:03:07 <Darwin226> \", \n, \r and \t should probably be enough
06:03:12 <dramforever> okay then
06:03:32 <Darwin226> Any more common ones you guys can think of?
06:03:34 <dramforever> then my blah above is probably okay,
06:03:38 <benzrf> Darwin226: yes, you need to special case them
06:03:45 <benzrf> Darwin226: in what world do you not need to special case them
06:03:52 <ab9rf> it's all special cases anyhoo
06:03:57 <dramforever> escapes are special
06:04:09 <benzrf> Darwin226: oh are you asking for a stdlib function to take an escaped char/string and then tell you what it is?
06:04:17 <ski> Darwin226 : `\v',`\f',`\0'
06:04:23 <erisco> @tell chrisdone it did not infer because partially applied type families are not allowed but the compiler is not transparent about this, see #9433
06:04:24 <lambdabot> Consider it noted.
06:04:29 <ski> > '\0'
06:04:31 <lambdabot>  '\NUL'
06:04:34 <dramforever> Darwin226: add \0
06:04:44 <benzrf> Darwin226: like unescape "NUL" = '\0'
06:04:46 <dramforever> \v \f are not that useful
06:04:58 <dramforever> benzrf: no
06:05:00 <Darwin226> What are v and f?
06:05:04 <ab9rf> but i like formfeeds!
06:05:11 * ski regularly inserts literal `\f's (form feeds) into source files
06:05:11 <trap_exit> oh shit
06:05:14 <trap_exit> amazon prime now
06:05:22 <trap_exit> if I lived in nyc, id'b e able to program all day and not leave my apartment
06:05:27 <ab9rf> admittedly vertical tab is pretty rare
06:05:28 <ski> `\v' is vertical tab
06:05:39 <dramforever> pretty rare
06:05:47 <Darwin226> Ok, thanks for suggestions guys
06:06:00 <ab9rf> i'm not aware of any modern device that uses vertical tab for anything meaningful
06:06:09 <ski> > chr `map` ([0 .. 31] ++ [127])
06:06:10 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
06:06:21 <ski> Darwin226 : so `\a' as well
06:06:32 <dramforever> ha ha ha
06:06:34 <ab9rf> a long time ago i used a terminal that advanced the paper to the "next section" on a vertical tab
06:07:05 <dramforever> reminds me of how I made noise in my schools computer
06:07:09 <dramforever> room
06:07:20 <ski> dramforever : disk drive music ?
06:07:25 <Darwin226> Oh, and definitely '\7'
06:07:29 <ab9rf> i remember the guy who got his account suspended over abusing fortran carriage control on the high speed printer
06:07:32 <dramforever> ski: outputting \a 's
06:07:39 <ski> ok
06:07:45 <dramforever> that one goes to the speaker
06:08:02 <ab9rf> first, print a thousand lines of hyphens with suppressed carriage control
06:08:07 <Darwin226> Thanks again
06:08:12 <dramforever> "regular" sounds go into the headset, and nobody else could hear them
06:08:13 <ab9rf> then a thousand blank lines with formfeed carraige control
06:08:19 <ski> dramforever : unless you've redirected it to a visual bell
06:08:53 <erisco> is it possible to constrain types to be non-equal?  foo :: (a !~ b) -> a -> b (a, b)  ?
06:09:01 <benzrf> erisco: yes iirc
06:09:07 <benzrf> erisco: you can use a type family or something
06:09:08 <erisco> missing a -> in there
06:09:13 <benzrf> erisco: why do you want to do it
06:09:16 <ab9rf> the ops center people will hate you forever for making them extract a thousand pages of paper accordioned into the printer's carriage feed assembly
06:09:18 <erisco> benzrf, I cannot use a type family :(
06:09:25 <benzrf> erisco: whats the use case
06:09:48 <erisco> I need something I can partially apply, and type constructors are the only thing I know of that you can partially apply
06:09:55 <erisco> so I am trying to use a GADT for this
06:11:33 <ski> dmwit : i prefer to think of it as `STRef s a's *referring* to mutable storage (the same way an `Int' can refer to an element in a list or array or `IntMap')
06:12:59 <erisco> I will post a more complete example in a minute
06:13:11 <benzrf> erisco: no but why u need to constrain
06:13:21 <benzrf> erisco: are you tryna ensure well-behavedness at the type level
06:13:34 <erisco> yes
06:13:35 <benzrf> in haskell thats not really super practical a lot o the time
06:13:41 <benzrf> whta exactly are you trying to enforce
06:13:45 <erisco> tough bananas I guess
06:13:53 <erisco> well I will post an example in a minute
06:17:23 <erisco> this is as far as I have gotten on the idea http://lpaste.net/116772   benzrf
06:17:57 <erisco> I cannot seem to make the GADT idea work at all yet even if I could constrain x !~ y
06:18:15 <erisco> I guess a GADT is not promotable?
06:21:00 <erisco> okay so now I have this which does appear to work  http://lpaste.net/116773   but unfortunately 'ToBool' is closed
06:21:56 <erisco> and it seems data families must be injective
06:22:15 <ski> yes
06:22:16 <hodapp> That sounds like a Bender joke out of Futurama
06:24:17 <erisco> maybe I can get type classes to interact with this somehow
06:24:53 <deech> Do empty data declarations have any runtime cost?
06:25:28 <erisco> and for reference, this has stemmed from https://ghc.haskell.org/trac/ghc/ticket/9898
06:25:38 <erisco> deech, not that I am aware of
06:30:38 <athan> Is there a MonadReader class without the functional dependency?
06:32:28 <benzrf> athan: why would you want that
06:32:51 <athan> benzrf: Generic IsString readers :/
06:33:13 <erisco> okay new question
06:33:16 <erisco> how do I make this compile http://lpaste.net/116774
06:33:21 <ski> perhaps `athan' want to be able to refer to different pieces of environment in the same monad
06:33:30 <benzrf> athan: huh
06:34:20 * athan gets a stapler
06:34:33 <trap_exit> GREATNESS
06:34:36 <trap_exit> haskell
06:35:00 * ski gets a staple remover
06:36:21 <erisco> what I need is something like type classes at the type level if I cannot have partial application
06:37:29 <benzrf> erisco: so this is why you want the constraint
06:37:30 <benzrf> i see
06:37:31 <erisco> I need to somehow say that 'Equivalence x x' is true and 'Equivalence x y where x !~ y' is false... and I seem lightyears from being able to do so
06:39:06 <erisco> or some way to recreate ToBool that is open
06:39:06 <benzrf> erisco: how about
06:39:23 <benzrf> erisco: er, i know i've seen this...
06:40:45 <benzrf> ugh, nvm
06:41:02 <benzrf> erisco: why not have the argument to Filter just be a constraint instead of a contructor
06:41:18 <erisco> I am not sure of what you mean
06:41:53 <erisco> an example is  undefined :: Filter (Equivalence Int) (Char, (Int, ())) :: (Int, ())
06:41:53 <benzrf> 1 sec
06:42:32 <benzrf> erisco: http://lpaste.net/116774
06:42:42 <osa1> any ideas why we dont have folds defined for mutable vectors in vector package?
06:42:43 <benzrf> er, you'll need ConstraintKinds
06:43:00 <osa1> do I have to use unsafeFreeze or something like that?
06:43:46 <erisco> benzrf, that is a compile error, I made up the syntax for adding a context to the type family
06:43:59 <benzrf> oh
06:44:02 <benzrf> ahhhh i see
06:44:21 <erisco> but I am glad it was so compelling :)
06:44:31 <benzrf> erisco: have you considered leibniz equaliuty
06:44:43 <benzrf> it works pretty well
06:44:46 <benzrf> afaik
06:44:50 <erisco> I know nothing of, could you explain?
06:45:01 <benzrf> wait idk if it would be appropriate hmm
06:45:17 <erisco> somewhere along the line I have to have a common interface for true things and false things
06:45:37 <erisco> that is what 'ToBool' is serving as, but it is closed which makes it not that useful
06:45:40 <benzrf> @let newtype Equal p q = Equal {deEqual :: forall a. p a -> q a}
06:45:42 <lambdabot>  Defined.
06:45:53 <benzrf> erisco: curry-howardized version of the notion of
06:46:21 <benzrf> oh wait hold on
06:46:30 <benzrf> shit that's wrong
06:46:31 <benzrf> @undef
06:46:31 <lambdabot> Undefined.
06:46:45 <erisco> okay, but whatever type I construct to represent some fact, I need to eventually test if the fact holds or not
06:46:47 <benzrf> @let newtype Equal a b = Equal {deEqual :: forall p. p a -> p b}
06:46:48 <lambdabot>  Defined.
06:46:52 <benzrf> erisco: sorry, i confused myself
06:46:53 <erisco> for example, Filter has to know this
06:46:56 <benzrf> erisco: curry-howardized version of the notion of
06:47:22 <benzrf> P = Q ↔ ∀A.P A → Q A
06:47:36 <benzrf> @let eqRefl = Equal id
06:47:37 <lambdabot>  Defined.
06:47:38 <benzrf> :t eqRefl
06:47:39 <lambdabot> Equal a a
06:48:03 <osa1> help. why no folds for mutable vectors in vector lib?
06:48:24 <erisco> benzrf, what does this representation grant me?
06:48:35 <benzrf> erisco: uhh
06:48:42 <benzrf> shit
06:48:43 <benzrf> bbl
06:49:07 <joe9> Is it possible to export everything from a module but for those that are hidden: http://codepad.org/aZv38BoZ
06:49:47 <joe9> other than having to explicitly list all that are exported.
06:49:50 <Peaker> Is there a Haskell lib capable of outputing a "diff -u" style output?
06:49:55 <OliverJAsh> Yesterday in an interview test I was asked to write a function that adds 1 to a number represented as a list of digits, e.g. [1,2,7] -> [1,2,8]. I came up with a solution in JavaScript using for loops: https://gist.github.com/OliverJAsh/bff2ab7afa0fa5ad7250. I'm learning Haskell and I'm trying to think how you could write this function functionally in
06:49:56 <OliverJAsh> Haskell. Has anyone got any tips?
06:50:27 <chpatrick> OliverJAsh: foldr the carry?
06:50:41 <chpatrick> OliverJAsh: mapAccumR really
06:51:00 <kadoban> OliverJAsh: I would think you'd want the list of digits to be backwards in haskell, due to how haskell lists work.
06:51:17 <chpatrick> kadoban: not necessarily
06:51:27 <RchrdB> Reverse the list, work from the least significant digit up, reverse it again. :)
06:51:45 <kadoban> Well, it'd make addition and subtraction easier... what would be harder?
06:54:03 <OliverJAsh> Okay, that's enough help for now I think. Will see what I can do. Thanks
06:56:20 <chpatrick> OliverJAsh: done, 6 lines, no reversing :)
06:56:23 <trap_exit> 1 + 2
06:56:32 <juri_> btw, the more i learn it, the more i love haskell.
06:56:34 <juri_> ;)
06:56:48 <ab9rf> juri_: you'll come around eventually
06:57:23 <srhb> juri_: You may want to stop now and keep the rest of the programming languages enjoyable. :-)
06:57:38 <ab9rf> you don't really know something until you hate it
06:57:43 <juri_> I've got three books to read, but.. the stuff i've managed to learn and apply has been awesome.
07:00:22 * hackagebot extended-reals 0.2.0.0 - Extension of real numbers with positive/negative infinities  http://hackage.haskell.org/package/extended-reals-0.2.0.0 (MasahiroSakai)
07:03:07 <joe9> is it possible to do something like this: module Masked.Prelude (module Prelude hiding (head, map, read)) where
07:03:48 <joe9> i know I cannot use hiding there, but, just want to check if there are any tricks to get a similar effect.
07:05:53 <kadoban> joe9: You know you can do 'import Prulude hiding (blah, blah, blah)', right? You mean you want it as a named module instead?
07:06:40 <kadoban> Oh, I see what you mean. Nevermind. Yeah I dunno.
07:10:07 <erisco> noes I just realized that my :.: is partially applied
07:10:11 <erisco> was wondering what was going wrong
07:17:07 <athan> Why can't I make Identity a MonadReader? :(
07:17:07 <joe9> kadoban: fyi, this works http://codepad.org/JitsDugV
07:17:29 <athan> is this because there isn't a relationship between the reader index `r` and the monad?
07:17:57 <athan> by relationship, I mean some kind of binding between the variables. All other monad readers are parameterized by the reader index `r`, while identity doesn't have any parameters
07:19:51 <chpatrick> athan: I think it's because there's no particular r a given Identity is associated with
07:20:14 <chpatrick> athan: and r has to be implied by m
07:20:19 <chpatrick> athan: what are you trying to do anyway?
07:20:21 <athan> chpatrick: That makes sense
07:20:32 <athan> I wonder if encoding it in a GADT would work lol
07:20:42 <chpatrick> what do you mean?
07:21:03 <athan> chpatrick: Trying to handle a trivial basic case monad reader :P
07:21:24 <ski> athan : `instance MonadReader () Identity' ?
07:21:24 <athan> chpatrick: This helps a ton, thank  you :)
07:21:42 <athan> close! It's actually IsString a => instance MonadReader a Identity :)
07:21:56 <athan> er.. syntax...
07:22:12 * athan wishes there was a lens for spacetime
07:22:36 <edwardk> a gravitational lens?
07:22:48 * ski doesn't understand what athan is attempting to do
07:23:32 <edwardk> athan: that instance doesn't make sense
07:23:38 <athan> ski: I've got a library thats founded on MonadReader, and some different monads for different "deployment" schemes
07:23:54 <athan> if I have Identity as a "deployment", then it would just be trivial (or something)
07:24:07 <athan> idk, I should probably just expect the users to grok monads :/
07:25:07 <athan> edwardk: I think I'm just gonna make a newtype. Thanks :)
07:25:22 * hackagebot resolve-trivial-conflicts 0.2 - Remove trivial conflict markers in a git repository  http://hackage.haskell.org/package/resolve-trivial-conflicts-0.2 (EyalLotem)
07:25:23 <ski> athan : why do you want to use `Identity' here ?
07:25:56 <edwardk> athan: just pointing out two things. 1.) Identity doesn't have anywhere to tuck the environment, so you can't implement 'local'.  2.) the instance doesn't make sense because of the fundep. instance IsString a => MonadReader a Identity -- fails because 'a' has to be determined entirely by 'Identity'
07:26:36 <edwardk> so that instance is dead on arrival on two counts
07:28:50 <athan> edwardk: Learned something new today :) Thank you!!
07:29:11 <athan> ski: Just for convention to note something as a "un-effectful" monad :/
07:29:19 <athan> or... somethign...
07:30:22 <lf94> Hey, is it possible to create a library in haskell to use in C code?
07:30:47 <ski> athan : `MonadReder a Identity' is going to be effectful .. except perhaps if `a' has only a single value
07:31:12 <ski> (the same holds for `MonadReader a (...)', for any `...')
07:31:18 <geekosaur> lf94: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-ghc.html#ffi-library
07:31:22 <athan> hmm
07:31:43 <ski> why did you want to use an environment monad ?
07:31:53 <ski> where did `IsString a => ' come from ?
07:32:02 <geekosaur> see also https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-ghc.html#hs-exit
07:32:16 <athan> ski: It's for url writing, but for any OverloadedString (hopefully)
07:33:01 <athan> ski: The `r` is the host of the url :)
07:33:15 <athan> I'm having each environment include the host differently
07:33:17 <ski> oh
07:33:21 <ski> s/oh/ok/
07:33:47 <athan> where the identity would then (shot in the dark) "not" add the host
07:33:59 <ski> why not use `(r ->)' or `Reader r' or `ReaderT r m', where `IsString r' ?
07:34:01 <lf94> geekosaur: how do I call my haskell code?
07:34:19 <lf94> geekosaur: it is only showing me the boilerplate for what is needed to make the library
07:34:24 * athan is in la-la land
07:34:28 <athan> sorry ski :(
07:34:39 <ski> .. or `(IsString r,?host :: r) => ' for that matter ..
07:35:25 <ski> athan : or, if you prefer a custom monad, make one (parameterized over `r', or by fixing the stringy type)
07:35:27 <athan> ski: `?host`?
07:35:58 <athan> :s I think I'm fixing the stringy type right now, idk
07:36:12 <ski> athan : "Implicit parameters", see <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#implicit-parameters>
07:36:40 <danilo2> Hello! :) What is the fastest method to get from a Map list of values from list of keys? Just fmapping them or is there anything else? :)
07:36:53 <geekosaur> lf94, you have a "foreign export" declaration for each function you want to be callable, which uses appropriate FFI types for parameters / return value; then you just call it, making sure the haskell runtime has been initialized by call time (hs_init0
07:36:59 <geekosaur> *(hs_init)
07:37:41 <athan> ski: I'm still very vanilla in this neck of the woods, but I might come back to you begging for advice :)
07:37:57 <geekosaur> the FFI glue created by the `foreign export` handles getting the parameters and return value converted
07:38:07 <lf94> geekosaur: right but how do I compile my haskell code to a library
07:38:14 <lf94> geekosaur: just regular `ghc myprogram` ?
07:38:22 <geekosaur> ghc -c
07:38:45 <geekosaur> without -c it will look for a Haskell main function (just as `gcc foo.c` will look for a C main() and the link will fail if it's not there)
07:39:39 <erisco> I feel like I have been lied to... I don't have any partially applied type families that I can see yet it still does not work :(
07:41:22 <athan> erisco:
07:41:29 <athan> I'm sorry :(
07:41:45 <athan> (can I see your code?)
07:43:55 <erisco> yeah I will post it up in a minute, just summarizing the errors
07:44:21 <athan> edwardk: MonadReader's can't really become CoMonads, can they?
07:47:46 <erisco> here we go http://lpaste.net/116781
07:48:03 <erisco> I don't know at the moment where the error is at all... there seems to be at least three different problems
07:49:00 <erisco> I carefully got rid of all the partially applied type families yet I am betrayed! noes!
07:51:56 <brycelane> edwardk, are they any 'hello world' examples for your gl package?
07:52:10 <athan> erisco: This is awesome haha
07:53:26 <athan> erisco: ...AllowAmbigousTypes? Doubt it will help, but it might be worth a shot
07:53:56 <athan> erisco: Don't give up! This is too cool!
07:54:22 <EvanR> whats the maximum size of a tuple?
07:55:46 <animeshsaxena> Tuples can be of arbitrary length*, but Show, as well as Eq, Ord, Read, Bounded, etc are only instantiated up to 15-tuple
07:56:30 <exio4> up to 63, a least in ghc?
07:56:39 <indiagreen> 62, GHCi says
07:56:54 <exio4> > (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
07:56:55 <lambdabot>  A 166-tuple is too large for GHC
07:56:55 <lambdabot>    (max size is 62)
07:56:55 <lambdabot>    Workaround: use nested tuples or define a data type
07:57:04 <exio4> yup
07:57:12 <EvanR> heh
07:57:12 <fuzzyhorns> such a big tuple frightens me lol
07:57:50 <animeshsaxena> :(
07:59:06 <nyuszika7h> if length 62 is supported, why isn't Show etc. defined up to 62, I wonder
07:59:16 <nyuszika7h> that said I can't see a use case for a 62-tuple anyway
07:59:30 <nyuszika7h> even a 15-tuple is overkill in 99% of cases
08:00:51 <erisco> athan, AllowAmbiguousTypes changes the error to cannot match ApplyFilter (ToBool ((Not :.: Equal Int) :$: Int)) (Int, ()) with ()
08:01:12 * athan is sick of trying to make type coercion a configuration system
08:01:21 <erisco> this kind of thing was happening when I was using partially applied type families, where it would appear as though the compiler was not evaluating the type family
08:01:52 <erisco> if I run  :t undefined :: ApplyFilter (ToBool ((Not :.: Equal Int) :$: Int)) (Int, ())   it comes back with () as expected
08:02:18 <athan> erisco: I wish I could help you dude, this looks awesome but a bit dicey
08:02:23 <athan> :(
08:02:41 <erisco> *shrug* I'll open another GHC ticket and see what the wizards say
08:08:37 <Fuuzetsu> [shana@lenalee:~/programming/eris]$ nix-shell -p php
08:08:42 <Fuuzetsu> forgive my father for I have sinned
08:10:26 <Qfwfq> :'(
08:10:30 <erisco> athan, it is :.: giving it trouble it seems
08:11:06 <Fuuzetsu> me* and this went into wrong buffer ;P
08:11:12 <erisco> if I change :+: to use (Equal x) rather than (Not :.: Equal x) it can type check, but obviously the behaviour is wrong
08:11:47 <erisco> it does not seem to like the rule  (g :.: f) :$: x = g (f x)  i.e. it does not want to match on it
08:11:52 <osa1> how do I catch this exception http://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-C-Error.html#v:throwErrno ?
08:11:56 <erisco> if I add a second rule  f :$: x = f x  it likes to match on that instead
08:12:20 <maukem> :t catchIOError
08:12:21 <lambdabot>     Not in scope: ‘catchIOError’
08:12:21 <lambdabot>     Perhaps you meant ‘catchError’ (imported from Control.Monad.Error)
08:12:28 <maukem> @hoogle catchIOError
08:12:30 <lambdabot> No results found
08:12:32 <maukem> :-(
08:12:39 <erisco> maybe there is a bug with pattern matching then
08:12:50 <maukem> osa1: http://hackage.haskell.org/package/base-4.7.0.1/docs/System-IO-Error.html#v:catchIOError
08:13:22 <geekosaur> catch (\(e :: IOError) -> ...) isn't it? (with ScopedTypeVars)
08:13:44 <osa1> maukem: how do I test if the catched exception is errno exception?
08:13:57 <maukem> osa1: what do you mean, "errno exception"?
08:14:37 <osa1> maukem: that function catches all IOExceptions, right? I don't care about all exceptions, I only care about the ones thrown by throwErrno
08:15:02 <maukem> osa1: no such thing
08:15:12 <maukem> throwErrno doesn't throw a separate kind of exception
08:15:17 <osa1> uhhhh http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Foreign-C-Error.html#errnoToIOError
08:15:35 <geekosaur> yes, that uses the errno to pick an appropriate instance of IOError
08:16:35 <osa1> why is it not throwing it's own type of exception?
08:17:06 <geekosaur> because the only IOError that *isn't* ultimately traceable to an errno in most cases is userError?
08:17:25 <geekosaur> go look at System.IO.Error
08:19:37 <maukem> osa1: it maps errno values to IOErrors
08:19:54 <maukem> but given an IOError, you can't tell where it came from
08:20:53 <osa1> yeah that's the problem
08:21:02 <osa1> that's why I asked "why it's not throwing it's own exceptions"
08:21:25 <geekosaur> ... I am having toruble understanding why you think errno is magical
08:21:46 <pdpi> Ahoy. having some Repa issues. My code works fine inside ghci, but, when compiled, blows up with Oops!  Entered absent arg $dShape2{v a4S5} (and some more stuff I can paste if it helps)
08:22:06 <geekosaur> or should be
08:22:18 <lpaste> chrisdone pasted “Typed Template Haskell” at http://lpaste.net/116785
08:22:35 <chrisdone> anyone taken this idea to fruition?
08:22:58 <geekosaur> "so, I/O errors are generated from errno-s returned by kernel or library routines, except in this one case where I want to cons up an errno from thin air and treat it as a different kind of exception"
08:23:13 <agocorona> template haskell makes me feel my fingers dirty
08:23:20 <geekosaur> this almost sounds like exception abuse to me
08:23:29 <osa1> geekosaur: let's say I have an IO function which calls some functions that can throw errno thing
08:23:41 <osa1> geekosaur: I wrapped this function with catch and catched and IO exception
08:23:50 <osa1> geekosaur: how do I know if it's coming from errno?
08:23:57 <geekosaur> ?????
08:24:04 <osa1> ????????
08:24:06 <geekosaur> because it's an IO error
08:24:26 <osa1> geekosaur: that functions also calls a dozen of other IO functions which does file IO, displaying stuff to screen, etc.
08:24:54 <geekosaur> ans you have decided to treat all exceptions as I/O errors?
08:25:13 <maukem> osa1: why would it?
08:25:23 <geekosaur> you are saying you want an I/O error that is not an I/O error but has a fake errno assigned to it
08:25:42 <geekosaur> ...and therefore the I/O error stuff should be designed around non-I/O-errors that have fake errno-s
08:26:14 <geekosaur> instead of designed around I/O errors that have errno data describing the I/O error from the OS / system libhrary perspective
08:47:10 <osa1> can anyone help me with this http://lpaste.net/116789
08:49:03 <geekosaur> why are you doing bind and connect on the same socket?
08:50:09 <osa1> geekosaur: it doesn't matter -- I'm getting same error either way
08:53:18 <osa1> any ideas?
08:55:38 <glguy> osa1: You need to "accept" connections coming in on listening sockets
08:57:33 <glguy> Oh, you're using "listen" in a different way that network library does
09:00:42 <waxjar> what is meant by a "closed form solution"?
09:01:45 <osa1> glguy: I'll try using accept but I think this should work too
09:01:54 <glguy> This can't work
09:02:10 <glguy> to receive connections you need to bind an address (you are) then listen, then accept
09:02:47 <fresheyeball> morning folks
09:03:25 <fresheyeball> so I have a question
09:03:31 <fresheyeball> about MonadPlus
09:03:33 <lpaste> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/116789#a116797
09:04:02 <glguy> osa1: I'm not saying that's perfect yet, but it fixes some of the issues. I added comments to explain the changes
09:04:11 <fresheyeball> if I want to see an instance of MonadPlus
09:04:17 <fresheyeball> how can I look that up?
09:04:29 <fresheyeball> if I hoogle for (MonadPlus)
09:04:37 <fresheyeball> I get the definition of the class
09:04:50 <fresheyeball> and not the ability to look up any specific definitions
09:05:02 <glguy> fresheyeball: You can see which instances come with the library http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad.html#t:MonadPlus
09:05:12 <glguy> and in GHCi you can see which instances are currently available with :info
09:05:34 <fresheyeball> right
09:05:44 <fresheyeball> but what if its not in the MonadPlus package?
09:06:00 <fresheyeball> Can I look up the MonadPlus implementation for Either?
09:06:45 <glguy> If Either had one it would also be in base alongside the MonadPlus class
09:10:30 <fresheyeball> ok, so same question but different
09:10:39 <fresheyeball> Functor is in the prelude
09:10:52 <fresheyeball> and definitions of fmap are not usually along side the class
09:11:09 <fresheyeball> how could I lookup the definition of Functor for Either?
09:11:56 <indiagreen> fresheyeball: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-Either.html#Either
09:11:57 <glguy> Find "Either" in the documentation: http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#t:Either
09:12:00 <glguy> and then click "source"
09:12:16 <fresheyeball> ok, so I want to know how to find it
09:12:17 <indiagreen> the definitions of instances are usually either where the thing is defined, or where the class is defined
09:12:18 <fresheyeball> not where it is
09:12:27 <fresheyeball> I want better skills looking things up
09:12:28 <glguy> That's the process: goto the documentation for the type
09:12:30 <glguy> click source
09:12:38 <indiagreen> so you only have to check source for the type, or source for the class
09:13:19 <glguy> Unless there is a special reason the instances for things should be in the module that defines the class or in the module that defines the type
09:13:35 <fresheyeball> ok, so in other words
09:13:45 <fresheyeball> there is not a special hoogle-fu to solve this
09:13:57 <osa1> glguy: http://lpaste.net/116798
09:13:58 <fresheyeball> I need to lookup the module where the data type is defined
09:14:00 <glguy> There might be, I don't use hoogle
09:14:05 <fresheyeball> and then see if its a member of that type class
09:15:21 <joeyh> so I'm taking over a library on hackage that was using version numbers like 2007.10.27. I want to convert it to use the PVP. I wonder how to do that.
09:15:38 <joeyh> I suppose I can use 2014.0.0 for a new version and just treat 2014 as the major version going forward..
09:15:42 <glguy> joeyh: The PVP doesn't say anything about how big the numbers are
09:15:45 <glguy> just how to increment them
09:16:05 <joeyh> a bit confusing though. Perhaps 10000 would be a less ambiguous major
09:16:13 <nitrix> When using a monad transformer, like the MaybeT type, do you always have to wrap all the T type functions?
09:16:45 <nitrix> e.g. readLine would become maybeReadLine x = MaybeT IO (readLine x)   ?
09:18:30 <dfeuer> Why's the Haskell Wiki so slow right now?
09:18:57 <osa1> glguy: any ideas about this version?
09:20:09 <glguy> osa1: you forgot to copy the "listen" action
09:21:27 <osa1> glguy: now it works. thanks.
09:21:28 <athan> Hey guys, I'm getting a parse error here: http://lpaste.net/116799#line37 - where did I screw up? (besides the hideous architecture)
09:21:29 <glguy> and it's likely the message won't be received because main finishes right after sending it, so it's unlikely that the listener will run again
09:22:09 <fresheyeball> hey athan
09:22:16 <glguy> You don't need to use async if you're not interested in recovering the result. Normal forkIO will work
09:22:24 <athan> fresheyeball: Yo!!! What's new man?
09:22:50 <fresheyeball> last two work days before vacation
09:23:00 <fresheyeball> mostly just reading about haskell
09:23:09 <fresheyeball> and CT more broadly
09:23:09 <athan> that sounds so nice, where are you headed?
09:23:16 <fresheyeball> I'm not going anywhere
09:23:20 <athan> fresheyeball: Awodey's book is awesome
09:24:03 <athan> oh, well... That's still rad haha. How long is it?
09:24:35 <johnw> glguy: the result, or any exceptions
09:24:47 <geekosaur> athan: given the bare let on line 32, I assume you are missing a do at the end of line 31
09:24:50 <glguy> tell him :-p
09:24:51 <dfeuer> Can someone tell me how to generate an arbitrary function with QuickCheck? I see Test.QuickCheck.Function, but it's pretty vague.
09:25:08 <fresheyeball> 2 weeks
09:25:16 <athan> geekosaur: !! Thank you :)
09:25:45 <athan> fresheyeball: We should find time to hang out
09:25:52 <fresheyeball> sounds like fun to me
09:25:59 <athan> :)
09:26:06 <fresheyeball> I've been learning about the CT functors and such
09:26:25 <fresheyeball> math functors and haskell functors have an odd relationship
09:26:26 <jonazzzz> can somebody tell me how IORef works? is it like a map? or can i only store one thing in it?
09:26:45 <johnw> jonazzzz: one thing
09:27:04 <johnw> it's like a traditional imperative variable: think of it like a memory slot that you can read from and write to
09:27:36 <johnw> of course, it's not quite the same because I don't believe it's address has to be stationary or anything
09:27:46 <jonazzzz> hmm ok thanks :)
09:27:52 <athan> fresheyeball: I wish I knew more. I think I know where you're going with this, though, it's pretty weird
09:28:06 <jonazzzz> and any idea how i can make a timer, i need like a timer that every second updates my gui ^^
09:28:11 <athan> pure nesting is like a functor... or something :P
09:28:19 <johnw> jonazzzz: use another thread that loops around a threadDelay
09:28:38 <johnw> forkIO $ forever $ threadDelay 1000000 >> updateGui
09:28:57 <fresheyeball> well a functor is a function from one category to another
09:29:11 <fresheyeball> haskell functors demand that the functors domain and codomain be the same
09:29:25 <johnw> fresheyeball: Haskell functors are endofunctors on the Hask category
09:29:29 <exio4> endofunctors
09:29:34 <johnw> they are a specialization of "CT functors"
09:29:36 <fresheyeball> yes
09:29:57 <fresheyeball> but I could see the potential for other functors in haskell
09:30:00 <athan> o_O
09:30:14 <johnw> fresheyeball: check out https://dorchard.wordpress.com/2011/10/18/subcategories-in-haskell-exofunctors/
09:30:25 <fresheyeball> even then
09:30:29 <fresheyeball> its sub cat to cat
09:30:39 <fresheyeball> functors can be cat to cat
09:30:55 <fresheyeball> f : A -> B where A and B are Categories
09:31:02 <jonazzzz> @johnw thanks
09:31:02 <lambdabot> Not enough privileges
09:31:12 <athan> fresheyeball: If you want an adventure, edwardk's hask lib and mikeizbiki's subhask look pretty... nuclear :)
09:31:14 <glguy> jonazzzz: @ is for bot commands
09:31:16 <johnw> jonazzzz: on IRC, "johnw: thanks" is traditional
09:31:24 <jonazzzz> johnw: thanks
09:31:27 <jonazzzz> ^^
09:31:28 <johnw> :)
09:31:30 <fresheyeball> Adventure!!!
09:31:56 * athan goes on a candy binge
09:32:37 <fresheyeball> holy craps
09:32:47 <fresheyeball> ok subhask is a decent into madness
09:32:58 <fresheyeball> I'll let you know if I survive
09:33:06 <osa1> why lazy bytestring.length returning Int64 while strict returning Word64 ?
09:33:36 <fresheyeball> athan, hit me up when you want to hang out
09:33:42 <johnw> osa1: interesting
09:33:56 <athan> fresheyeball: Will do :)
09:34:30 <lf94> Compiling Haskell for N64 is it possible?
09:35:57 <zomg> for.. Nintendo 64?
09:36:09 <jonazzzz> hehe
09:37:01 <lf94> zomg: yeah B)
09:37:16 <lf94> zomg: apparently with some tinkering you can make the LLVM backend generate mips code?
09:40:17 <jonazzzz> anyone here uses haskell on its work?
09:41:56 <zomg> lf94: interesting, what are you planning on doing with it? I have no idea how to do it, but I'm curious =)
09:42:21 <kadoban> Are there fixed-width integer types in haskell? Specifically I need... unsigned 32 bit
09:42:48 <HeladoDeBrownie> kadoban, Word32
09:42:56 <HeladoDeBrownie> Data.Word.Word32
09:42:57 <kadoban> Ah, thanks.
09:43:23 <vlopez> has anyone written a function to get all the free variables in the TH representation of a type?
09:45:11 <lf94> zomg: just write some routines in Haskell and hook them into some N64 games
09:45:18 <lf94> zomg: just as a proof of concept
09:45:33 <lf94> I know nothing of LLVM though
09:45:37 <lf94> maybe it's time to learn
09:47:11 <zomg> I see, sounds interesting
09:47:41 <lf94> eh, i don't think it isn't /that/ interesting, more like it'll be cool to see people hacking with haskell :)
09:47:53 <lf94> it's just haskell compiling to mips
09:47:58 <lf94> which was already possible before
09:48:04 <lf94> apparently latest ghc cant do it
09:54:49 <juri_> can i get a math sanity check?
09:54:58 <johnw> yes, math is sane
09:55:27 <geekosaur> usually >.>
09:56:00 <juri_> if: C=(distance_between_shafts*2)+(cog_radius+thickness*pi/2) then: cog_radius=(C*pi*2)-(distance_between_shafts*4*pi)-(thickness*pi^2) ?
09:58:49 <nitrix> it's lf, not if. I think you need a better font :)
09:59:30 <CindyLinz> XD
09:59:53 <koala_man> juri_: is that (cog_radius+thickness*pi/2) or (cog_radius+thickness)*pi/2  ?
10:00:18 <juri_> koala_man: the latter.
10:00:23 * hackagebot unagi-streams 0.1.1.0 - Unagi Chan IO-Streams  http://hackage.haskell.org/package/unagi-streams-0.1.1.0 (LukeHoersten)
10:00:46 <dfeuer> juri_ the pi^2 looks real fishy.
10:00:59 <dfeuer> Please try again.
10:01:01 <nitrix> 1l|L oO08 yvvwu rnm hn zs5S ...
10:02:15 <koala_man> juri_: I'm getting radius = 2C/pi - distance * 4/pi - thickness
10:02:58 <koala_man> ie your answer divided by pi^2
10:03:49 <juri_> ok.. back to the drawing board then...
10:03:50 <ReinH> dfeuer: pong
10:04:02 <ReinH> johnw: o/
10:04:12 <koala_man> juri_: http://sprunge.us/ghSC
10:04:39 <nitrix> Why would someone use a `MaybeT IO b` instead of `IO (Maybe b)` ?
10:04:56 <juri_> oh. duh.
10:04:57 <dfeuer> ReinH, I'm still attacking this finger tree thing, and I'm looking for help structuring code and/or my thinking about said code. I'm having trouble holding enough in my head at once, and trouble drawing sufficienly meaningful/general diagrams, and so on.
10:05:02 <juri_> thanks. :)
10:05:09 <ReinH> dfeuer: Alright :)
10:05:29 <dfeuer> ReinH, if you have the time to work on it with me in a somewhat focused way, I would be most extremely appreciative.
10:05:34 <jle`> nitrix: the Monad instance is more interesting
10:05:39 <jle`> er well, more useful in some cases
10:05:46 <ReinH> @unmtl MaybeT IO b
10:05:46 <lambdabot> IO (Maybe b)
10:06:06 <jle`> why would someone use the Sum monoid instance instead of the Product monoid instance
10:06:07 <ReinH> nitrix: They are equivalent, but MaybeT makes it easier to "exit" from a computation
10:06:23 <athan_> what does it mean for something to be "armortized"? Is it similar to memoized?
10:06:31 <dfeuer> athan_, no.
10:06:43 <dfeuer> But memoization is likely to be involved in amortization.
10:07:20 <geekosaur> it's like in finances; it means that the cost is spread out over more than just the point where it would be incurred
10:07:48 <nitrix> jle`: I see. So, hirerchically, Monad is more versatile and so, wrapping my computation into a `MaybeT IO b` is more convenient than `IO (Maybe b)` ?
10:07:50 <ReinH> nitrix: The haskell wiki has a nice example of MaybeT https://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial
10:07:50 <geekosaur> so instead of taking a big space or time hit in one place, you take a bunch of small hits in many places
10:07:58 <jle`> nitrix: i depends on what you want to do
10:08:03 <ReinH> nitrix: that shows exactly how it differs from the same computation in IO (Maybe b)
10:08:10 <dfeuer> athan, if you give "real-time bounds" for some set of operations, then each time you run each operation, it will fall within the bounds.
10:08:16 <athan> geekosaur: That wasn't directed toward me, was it?
10:08:20 <geekosaur> yes
10:08:32 <athan> ahhh okay
10:08:41 <dfeuer> If you give "amortized bounds" for a set of operations, then if you start at some base point and run any sequence of those operations, the total time will fall within those bounds.
10:08:53 <jle`> without MaybeT, (>>=) :: IO (Maybe a) :: (Maybe a -> IO b) -> IO b
10:09:01 <nitrix> jle`: What scares me about it, is it says it can chain computation, and either they are all successful, or it fails.
10:09:02 <athan> dfeuer: Holy... wow.
10:09:10 <jle`> with MaybeT, (>>=) :: IO (Maybe a) -> (a -> IO (Maybe b)) -> IO (Maybe b)
10:09:16 <ReinH> nitrix: Why does that scare you?
10:09:18 <nitrix> jle`: What I'd like instead, is, either one of them is successful, or else it fails.
10:09:31 <dfeuer> Persistence interacts with amortization in a somewhat funky way, and lazy evaluation makes it (relatively) easy to get right.
10:09:38 <ReinH> nitrix: Do you want to return the first successful thing?
10:09:40 <dfeuer> Well, that's a bad way to describe it.
10:09:41 <jle`> see, in the MaybeT version, you get to use an (a ->  ...) instead of a (Maybe a -> ...)
10:09:42 <nitrix> Yes
10:09:44 <nitrix> ReinH: ^
10:09:52 <ReinH> nitrix: Then you can use a flipped EitherT, which exists somewhere...
10:09:58 <dfeuer> athan, read Okasaki's book "Purely Functional Data Structures".
10:10:08 <ReinH> nitrix: http://hackage.haskell.org/package/errors-1.4.7/docs/Data-EitherR.html
10:10:21 <ReinH> nitrix: "More advanced users can use EitherR and EitherRT to program in an entirely symmetric "success monad" where exceptional results are the norm and successful results terminate the computation. "
10:10:54 <athan> dfeuer: I will make a delicious smoothie out of my brain with it :) Thank you!!
10:11:05 <ReinH> @where okasaki
10:11:06 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
10:11:08 <nitrix> ReinH: You can tell me if it makes sense, but I'm using my file system project to learn haskell, and IOs can come from multiple providers (it's distributed), and the first block successfully retrieved is fine. It doesn't make sense to try other nodes unless I repeatedly encounter failures.
10:11:10 <ReinH> athan: You can get started with his thesis :)
10:11:26 <ReinH> nitrix: Ah. Then is this concurrent?
10:11:27 <athan> ReinH: Thanks :)
10:12:37 <jle`> can't you use the MonadPlus instance of MaybeT to get try-all-of-these-until-the-first-success behavior?
10:12:58 <jle`> action1 <|> action2 <|> action3 :: IO (Maybe a)
10:13:05 <jle`> where action1 :: IO (Maybe a)
10:13:18 <jle`> it'll execute the actions until it encouters a Just
10:13:22 <jle`> and then return that as the result
10:14:00 <dfeuer> athan, but I think his book is a little gentler.
10:14:03 <jle`> asum [action1, action2, action3, action4 ...]
10:14:04 <dfeuer> With exercises.
10:14:11 <alphonse23_> does anyone here know Template Haskell?
10:14:23 <jergason> dear friends, i'm trying to create a few related types that all either add or remove a field from each other, but it seems like i have an awful lot of duplication. can someone point me to a better way to create a bunch of related data types like this? https://gist.github.com/jergason/56fa2d30504c811d3505
10:14:31 <alphonse23_> what does reify do exactly?
10:16:13 <johnw> ReinH: hello there!
10:16:21 <chpatrick> alphonse23_: looks like it looks up a Name and tells you what it is
10:16:27 <JuanDaugherty> anybody know of a haskell LabVIEW integration pkg/project? google, hackage, hayoo/hoogle turned up nussing
10:16:38 <alphonse23_> looks like, have you used it
10:16:41 <alphonse23_> it's confusing
10:16:58 <chpatrick> what's wrong?
10:18:15 <alphonse23_> I guess I'd like to know exactly what it does
10:18:19 <alphonse23_> Just curious
10:18:31 <alphonse23_> it's really not that important though
10:20:13 <nitrix> ReinH: That looks like what I want, except it's an extra dependency :P
10:21:39 <hodapp> somehow, when I must wrap a value around "fromInteger . toInteger"
10:21:43 <hodapp> I have to think that something is wrong
10:22:39 <hodapp> I have to use toInteger on a Word8 to make it an Integer, and then I have to use fromInteger to turn it to a Uint8 (a type in Ivory)
10:22:44 <hodapp> even though they're both unsigned 8-bit types
10:22:57 <johnw> well
10:23:01 <johnw> in that case, you could be evil
10:23:23 <johnw> write a function: word8ToUInt8 = ...
10:23:37 <johnw> and I'm not sure if the memory representations are identical, but you may be able to just unsafeCoerce in there
10:23:59 <dfeuer> johnw, ReinH, the concept is this: I start with a Hinze-Paterson 2-3 finger tree. I "massage it" (fairly simply) to make all the digits ones or twos, except the ones on top, which are twos or threes. At this point it's a "rigid" 2-3 finger tree which structurally represent a specific 2-3 tree.
10:24:07 <chpatrick> hodapp: Data.Coerce?
10:24:10 <johnw> dfeuer: I really know nothing about fingertrees
10:24:16 <dfeuer> OK.
10:24:37 * geekosaur would be suspicious about what it's representing, yeh. in particular, I believe all the standard types that fit are stored in machine words (so a Word8 is stored in a 32- or 64-bit memory location)
10:24:39 <hodapp> chpatrick: I don't know if the underlying representations are the same.
10:24:43 <dfeuer> So I have this rigid finger tree and I make three "copies" (not really copying, but whatever)
10:24:49 <geekosaur> whereas Uint8 might actually *be* an 8-bit value
10:25:21 <johnw> edwardk though is Edward Fingertreehands
10:25:22 <hodapp> it can already handle pretty much any literal as a Uint8, it seems
10:25:23 * hackagebot io-streams-http 0.1.0.1 - http-client for io-streams  http://hackage.haskell.org/package/io-streams-http-0.1.0.1 (DavidJohnson)
10:25:24 <dfeuer> The one in the middle, I repeatedly "squash" both top digits down into the next level.
10:25:43 <dfeuer> The one on the left, I repeatedly remove the left digit and squash down the right one.
10:25:51 <hodapp> and Uint8 is Bounded & Num
10:25:53 <dfeuer> The one on the right, I repeatedly remove the right digit and squash down the left.
10:26:16 <dfeuer> All this continues until the tree in the middle is down to two Deep constructors.
10:26:40 <hodapp> so fromInteger . toInteger works in the meantime but just still seems like it should be totally unnecessary o_O
10:26:53 <chpatrick> hodapp: Data.Coerce.coerce shouldn't let you do it unless they're the same
10:27:00 <chpatrick> hodapp: it's compiler magic
10:27:05 <dfeuer> Once that happens, I can finish squashing the one in the middle into a FingerTree (Node(Node a))
10:27:18 <johnw> hodapp: and you better hope that a GMP integer isn't really be allocated just for that conversation in the Core
10:28:07 <znst> How do I open yi after I `cabal install yi`
10:28:12 <hodapp> johnw: it doesn't matter much if it is; this is a representation for the sake of generated code
10:28:20 <johnw> ahhh, ok
10:28:22 <johnw> right, Ivory
10:28:25 <hodapp> yup :)
10:28:25 <dfeuer> I can squash the right and left sides of the left and right trees down once more to get on Node(Node a)) each.
10:28:33 <hodapp> as long as Ivory gets a Uint8, things are peachy.
10:28:47 <dfeuer> Then I can *insert* those nodes into their corresponding middles/bottoms.
10:29:00 <dfeuer> Then append the three resulting FingerTree(Node(Node a))
10:29:12 <chpatrick> hodapp: looks like they're Integers internally in ivory
10:29:13 <dfeuer> But this is all @$%!$% complicated for me.
10:29:15 <chpatrick> hodapp: so you're out of luck
10:30:03 <hodapp> chpatrick: I don't know about 'out of luck' so much as 'dealing with something clumsy'
10:30:30 <chpatrick> hodapp: can't you just fromIntegral? Uint8 is a NUm
10:30:31 <dfeuer> If I make special types to represent intermediate phases, that gets rid of partial functions and could potentially clarify thinking, but it leads to an absurd profusion of types.
10:31:08 <erisco> simon, are you the suave gentleman responding to my tickets?
10:31:15 <chpatrick> hodapp: it's the same thing in the end though
10:31:23 <hodapp> chpatrick: huh, that may work
10:31:52 <chpatrick> hodapp: every fromIntegral is fromInteger . toInteger, they just have RULEs for the primitive types :)
10:31:54 <chpatrick> isn't haskell great
10:32:14 <hodapp> huh
10:32:20 <erisco> athan, also here is the solution to the problem with :.: https://ghc.haskell.org/trac/ghc/ticket/9902
10:32:35 <erisco> evidently kind inference is more simplistic than I presumed it was
10:32:45 <dfeuer> erisco, unlikely. Simon Peyton Jones doesn't seem to come here, and Simon Marlow comes but very rarely speaks.
10:32:59 <erisco> ah well
10:33:08 <erisco> just wanted to give an extra thanks is all
10:33:21 <athan> Oh wow! Thanks erisco!
10:33:41 <erisco> athan, so, yeah, now you can have type sets
10:33:55 <erisco> unfortunately it relies on closed ToBool and :$:
10:34:17 <erisco> until the day partially applied type families becomes reality
10:38:36 <athan> erisco: Hold on, let me get all the poo out of my pants. That's friggin amazing.
10:40:23 * hackagebot io-streams-http 0.1.0.2 - http-client for io-streams  http://hackage.haskell.org/package/io-streams-http-0.1.0.2 (DavidJohnson)
10:40:39 <dzhus> My main function ends with a call to blocking function wrapped in bracket. How do I handle SIGTERM sent to my program?
10:43:45 <dzhus> Here's what I've tried: http://dpaste.com/3J6VKSE, but this program simply terminates at once
10:43:48 <athan> Anyone here use hpc-coveralls?
10:44:28 <johnw>  what is the flag to pass to GHC to tell it that a certain module is to be considered the main module?
10:44:40 <johnw> ah, -main-is
10:44:44 <johnw> it doesn't like -main-is=
10:45:20 <geekosaur> zshus, just do the installHandler and then your bracket foo
10:46:07 <geekosaur> bracket should catch the exception raised by the signal handler and do whatever cleanup is needed
10:47:21 <johnw> no
10:47:23 <johnw> sorry
10:48:38 <HeladoDeBrownie> dzhus, in addition to that, the reason that exits immediately is that (by default?) all threads exit when the main thread does.
10:49:17 <znst> How do I open yi after a `cabal install yi` ?
10:49:27 <znst> sorry if it was answered before, i lost my connection
10:49:31 <Peaker> `yi` ?
10:49:49 * geekosaur guesses that cabal installed into ~/.cabal/bin or windows equivalent and it's not in $PATH
10:49:59 <HeladoDeBrownie> That was my guess too
10:50:06 <geekosaur> (resp. %PATH%)
10:50:14 <crobbins> znst: ~/.cabal/bin/yi
10:50:24 <crobbins> if ~/.cabal/bin is not on your PATH
10:50:28 <znst> found it, thanks, i'm new to the software
10:51:05 <crobbins> znst: you should add ~/.cabal/bin to your PATH in your .bashrc, .zshrc, whatever
10:52:29 <dzhus> geekosaur: This was my original thinking, but where to throw the ExitSuccess exception? Here's what I tried: http://dpaste.com/3859GJY. Now sending SIGTERM to the process simply yields ExitSuccess on stdout while the program keeps running
10:53:59 <geekosaur> myThreadId, presumably
10:54:42 <geekosaur> or just use throw instead of throwTo
10:55:28 <geekosaur> well, throwIO probably
10:56:44 <dzhus> geekosaur: thanks, it works with (throwTo (myThreadId result) ExitSuccess)
10:56:50 <dzhus> not with throw/throwTo though
11:00:23 * hackagebot urlpath 0.1 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-0.1 (athanclark)
11:06:12 <dfeuer> This is definitely the longest pattern I have ever written.
11:06:57 <freeman42> anyone knows if it is possible to load/save in Lamdu editor? http://vimeo.com/97713439 / https://github.com/Peaker/lamdu
11:07:07 <dfeuer> It matches 24 variables :-/
11:09:34 <ReinH> dfeuer: o_O
11:09:39 <ReinH> seems bad
11:10:13 <MindIsAVortex> Hello, does anyone know of some more detailed documentation as to how Happy parser generator deals with Left recursive grammar rules, and why this doesn't lead to immediate stack overflow, as with parser combinators? I have already read the standard documentation from haskell.org and I'm sure that what I've written up now suffices for the answer I'm supposed to provide. (University exercise). I am just curious as to how Happy actually manag
11:10:23 * hackagebot moan 0.2.0.0 - Language-agnostic analyzer for positional morphosyntactic tags  http://hackage.haskell.org/package/moan-0.2.0.0 (vjeranc)
11:10:48 <mauke> maybe it works like yacc
11:11:30 <johnw> MindIsAVortex: I don't think LALR has the left recursive overflow problem
11:11:55 <johnw> "A formal grammar that contains left recursion cannot be parsed by a LL(k)-parser or other naive recursive descent parser unless it is converted to a weakly equivalent right-recursive form. In contrast, left recursion is preferred for LALR parsers because it results in lower stack usage than right recursion."
11:11:57 <johnw> (Wikipedia)
11:11:57 <erisco> MindIsAVortex, iirc Happy can generate a LALR parser which is bottom up and those inherently do not have problems with left recursion
11:11:58 <dfeuer> ReinH, yeah.... not sure how to do better though.
11:12:27 <erisco> MindIsAVortex, however, the assertion that top down parsers and particularly parser combinators cannot handle left recursion is false
11:12:33 <WilliamDhalgren> hi!
11:12:36 <dfeuer> ReinH, my current plan is to see if I can pound it out in this horrifying form and make it work. If so, maybe someone else will have an idea for cleaning it up.
11:12:57 <johnw> parsec has the "chainl" combinator for dealing with left recursion
11:13:26 <ReinH> dfeuer: :)
11:13:47 <athan> freeman42: Welp, I know what I'm switching to. Thanks :)
11:14:11 <WilliamDhalgren> I'm having some problem with cabal sandbox repl under windows. while a cabal build creates my exes just fine, cabal repl complains that ghc.exe can't find some dll. (using pcre.dll). Is there some path I need to add somewhere or? irritating that it works for compile but not for interactive...
11:15:31 <erisco> MindIsAVortex, often parser combinators mimic a recursive descent parser and those can not handle left recursion
11:15:53 <MindIsAVortex> erisco: interesting. We havent discussed LALR parsers in class yet, we're half way through this course so I guess it's still coming up but I'll read into it.
11:16:30 <johnw> LALR is fun to work through on paper
11:16:40 <erisco> just bottom up parsing in general is what you would want to look for, LALR is a parsing algorithm for a subset of context free grammars
11:16:54 <johnw> I loved the exercise of walking through (using a fictional stack machine) both how LL(1) and LALR(1) would approach parsing the same expression
11:17:58 <freeman42> athan, but does it blend? I mean, but can Lamdu save?
11:18:19 <athan> freeman42: Haha. Hopefully, this looks really cool
11:18:37 <freeman42> athan, I could not figure it out how, please tell me if you give it a try
11:19:10 <bennofs> Lamdu cannot even run code yet, so I don't think it's useful yet
11:19:14 <MindIsAVortex> johnw: that does seem like something I'll be looking at soon. Probably after Christmas tho :D
11:19:23 <johnw> my favorite text on parsing is sadly no longer in print: Compiler Design in C, by Holub
11:19:37 <johnw> so clear, such good exercises
11:19:42 <athan> ahh shoot
11:20:18 <johnw> oh, wow
11:20:26 <johnw> he himself makes the PDF available!  https://holub.com/software/compiler.design.in.c.docs.pdf
11:20:48 <johnw> oh, it's a companion to the book, never mind
11:21:01 <ReinH> :( so close
11:21:08 <johnw> here's the real book: http://www.holub.com/software/compilerDesignInC.pdf
11:21:11 <johnw> so again, yay :)
11:21:37 <johnw> i implemented that whole text in Perl, which was great fun back in the day
11:22:36 <MindIsAVortex> johnw: oh man, thanks for those links!
11:22:54 <johnw> yeah, the Holub book is really what made LALR clear for me
11:22:56 <bitonic> johnw: I love how those resources on compilers usually dedicate most of the space to parsing :P
11:22:59 <johnw> and understanding how yacc does what it does
11:23:02 <bitonic> oh, you were talking about parsing
11:23:06 <ReinH> johnw: How does it compare to the dragon book?
11:23:13 <johnw> the dragon book covers backend too
11:23:19 <johnw> so it's coverage of the front-end is more dense
11:23:19 <bitonic> but it's one of those problems which is kind of solved now, or at least kind of uninteresting
11:23:24 <ReinH> Ah
11:23:34 <ReinH> johnw: Oh yay you found the book itself!
11:23:34 <johnw> the Holub book will truly show you exactly how yacc does what it does
11:23:40 <johnw> at the end, you'll be able to write yacc
11:23:43 <ReinH> Although $30 for a used copy wouldn't have been the end of the world
11:23:51 <ReinH> johnw: that's pretty awesome :)
11:23:57 <WilliamDhalgren> no ideas re ghci linking woes w win? damn...
11:24:42 <erisco> bitonic, the problems just shift to more complicated grammars
11:24:48 <ReinH> johnw: do you ever use Maybe String where Just str indicates a failure message?
11:24:59 <bitonic> I think somebody pulled looked at the papers for the first POPL, and like 75% of them were about parsing.  in the last one, none, or maybe one
11:25:00 <johnw> ReinH: I think I may have done it once
11:25:11 <ReinH> I just found a use for it
11:25:14 <bitonic> erisco: yeah but it's not really the focus anymore
11:25:21 <erisco> of what?
11:25:41 <bitonic> of PL research
11:26:02 <bitonic> some people (e.g. the Agda people) still push the boundaries, but it's mostly a solved problem, it feels good :P
11:26:16 <hunt_> is it better to learn haskell on my own or by having someone teach it to me
11:26:19 <erisco> maybe for conventional programming languages
11:27:01 <erisco> it is not too much to suggest that a computer could be instructed with natural language, and then you have plenty of parsing problems
11:27:11 <ReinH> johnw: Well, I've been looking for a project for my holiday vacation. Maybe this is it :)
11:27:22 <johnw> ReinH: what is the project?
11:27:26 <bitonic> erisco: I think most people gave up on that
11:27:36 <bitonic> or don't feel the need for it
11:27:37 <erisco> they're the quitters
11:27:40 <bitonic> I certainly don't
11:27:45 <josephle> erisco: that's no longer the field of PL research :P
11:27:46 <trap_exit> with the exception of being acquired for 19B, when does erlang > haskell ?
11:27:50 <josephle> the NLP people got that covered
11:28:06 <erisco> I don't know anything about PL research
11:28:13 <erisco> I am just saying, parsing is not over
11:28:28 <josephle> trap_exit: erlang's built-in failure propagation and handling is really, really nice
11:28:29 <bitonic> well, in PL research, it pretty much is
11:28:59 <erisco> that is like saying PL research is uninteresting because we already have JavaScript
11:28:59 <trap_exit> parsing ended with regex + cfg + ll + lr + parsec + packrat
11:29:16 <trap_exit> erisco: bitconic is right; you're wrong
11:29:31 <trap_exit> there's nothing to be done in the theory of parsing
11:29:35 <bitonic> erisco: I'm saying that based on the number of papers published regarding parsing recently
11:30:14 <erisco> alright, interest has died, I have no idea :) I'll take it from you
11:30:37 <trap_exit> there is nothing to be done in the theory of parsing progrmaming lanuages
11:30:43 <bitonic> I was saying that because maybe in 30 years there's going to be no debate on types either.  that'd be great :P
11:30:51 <bitonic> although a bit boring
11:32:33 <rom1504> erisco: nlp is a very active field of research but indeed not much to do with parsing programming languages
11:32:42 <bitonic> but most likely not
11:33:03 <DSALNASS> AyyyyYyYyyyYyYyyYy
11:33:07 <josephle> bitonic: looking at the current state of PL research, I think there will always be debate on types :)
11:33:08 <erisco> rom1504, well, draw the box around programming languages wherever you please
11:33:21 <erisco> then you can be right, and I will draw the box differently and I will be right
11:33:23 <bitonic> josephle: yeah, I think so too :)
11:33:29 <erisco> that is all I am saying
11:33:32 <rom1504> yeah ok
11:34:02 <DSALNASS> Beginner question: If I have a module called Chips, I will have a Chips.hs and a Chips directory in the same location, and in the Chips directory will have all my submodules?
11:34:14 <rom1504> the methods are differents erisco that's all
11:34:20 <DSALNASS> Or will the Chips.hs be in the Chips directory
11:34:22 <erisco> sure
11:34:32 <rom1504> nlp is mostly approximate algorithms
11:34:41 <monochrom> DSALNASS: you will have a Chips.hs, that's all.
11:35:14 <DSALNASS> I don't need a Chips folder for submodules? they can go in the same directory as Chips.hs ?
11:35:29 <monochrom> I have two points to make then.
11:36:19 <monochrom> first point: I would not consider "Chips.Hello" a submodule of "Chips". this is because, for example, a user still has to import them separately.
11:36:24 <ReinH> johnw: Ooh, weechat.el and TeX input mode is really nice!
11:36:44 <ReinH> johnw: I'm actually using this rather than TeX mode: http://www.emacswiki.org/emacs/TeXInputMethod
11:36:56 <monochrom> second point: "Chips.Hello", if you want it, is in "Chips/Hello.hs", which is what you thought.
11:37:16 <johnw> ReinH:   I'm listening to your Haskell castrate now
11:37:20 <johnw> Haskell cast right now
11:37:23 * Clint squints
11:37:36 <johnw> voice dictation is not 100% :)
11:37:41 <ReinH> johnw: awkward typo is awkward
11:37:47 <trap_exit> in attoparsec, is ther a wway to disable "auto backtracking" ?
11:37:49 <geekosaur> oh, I figued that was autoincorrect >.>
11:38:00 <trap_exit> sometimes, I want to say "dude, just fucking commit; if you consume input, and can not finish, then just fail"
11:38:04 <carter> johnw: youre coding on Unichs?
11:38:08 <DSALNASS> ok thanks
11:38:15 <ReinH> johnw: Wait. You are irc-ing via dictation?
11:38:20 <johnw> ReinH: yes
11:38:23 <ReinH> That is next level.
11:38:42 <znst> psychic city
11:38:45 <johnw>  I found the typing on IRC was just getting to be too much typing for my fingers during the day, in addition to coding
11:40:22 <trap_exit> johnw: say: Peter Piper picked a peck of pickled peppers. A peck of pickled peppers Peter Piper picked. If Peter Piper picked a peck of pickled peppers, Where's the peck of pickled peppers Peter Piper picked?
11:40:29 <ReinH> johnw: Clever.
11:40:31 <johnw> huh?
11:42:10 <trap_exit> http://www.serpentine.com/blog/2011/06/03/attoparsec-0-9-a-major-release/
11:42:12 <trap_exit> gah
11:42:19 <trap_exit> is there no way to disable auto backtracking in attoparsec?
11:42:24 <monochrom> I recommend dictation for coding and keyboard for irc :)
11:43:11 <carter> trap_exit: theres probably a commit combinator
11:43:24 <ReinH> johnw: Oh wow, I can even input compound characters like α̂
11:43:59 <trap_exit> https://www.haskell.org/pipermail/haskell-cafe/2011-March/089821.html <- seems to be in other library
11:44:02 <trap_exit> but not in attoapsrsec
11:45:03 <carter> trap_exit:  commit p =   p <|> error "bam"
11:45:20 <trap_exit> omg
11:45:21 <trap_exit> that is brilliant
11:45:23 <trap_exit> carter++
11:45:36 <carter> haha
11:45:41 <carter> trap_exit: really, thats what you wanted?
11:45:44 <carter> glad I could help :)
11:45:46 <trap_exit> yeah
11:45:50 <trap_exit> I just wanted parsec's behavior
11:45:52 <trap_exit> in attoparsec
11:46:04 <trap_exit> I couldn't figure out how to make attoparsec NOT backtrack
11:46:16 <carter> trap_exit: actually
11:46:19 <carter> you can do one better
11:46:20 <trap_exit> WAIT
11:46:21 <trap_exit> that is not right
11:46:27 <trap_exit> if p does not consume input
11:46:29 <trap_exit> it hits error "blah"
11:46:36 <carter> newtype Parser i a = Parser {
11:46:36 <carter>       runParser :: forall r.
11:46:36 <carter>                    State i -> Pos -> More
11:46:37 <carter>                 -> Failure i (State i)   r
11:46:38 <carter>                 -> Success i (State i) a r
11:46:39 <trap_exit> parsec's behavior is "if you consume input, you commit"
11:46:39 <carter>                 -> IResult i r
11:46:41 <carter>     }
11:47:39 <trap_exit> Parsec{ a <|> b } <-- means, if "a" consumes inputs, we commit to "a", I don't see how to make this work with your "commit" above in attoparsec
11:47:40 <carter> trap_exit: you can want a noop parser that then builds the IResult Fail constructor?
11:48:04 <carter> trap_exit: what do you want instead
11:48:41 <trap_exit> Parsec{ a <|> b } <-- if "a' consumes input, we commit to "a", and fail if "a" fails; AttoParsec { a <|> b } <-- if "a" consumes input, we try a, and if "a' fails, we try "b"
11:48:50 <trap_exit> I want attoparsec to behave like parsec
11:49:00 <trap_exit> attoparsec autobacktracks, parsec does not
11:49:16 <ReinH> trap_exit: I mean, the docs say " Attoparsec parsers always backtrack on failure"...
11:49:32 <trap_exit> yeah, I want to firugre out a way to mimic parsec behavior
11:50:06 <ReinH> Well, maybe you can't?
11:50:08 <indiagreen> fizbin was working on something similar recently: http://ircbrowse.net/browse/haskell?id=19661112&timestamp=1418647253#t1418647253
11:50:24 <indiagreen> ne also had “better error messages” as an explicit goal
11:50:48 <fizbin> Hey, yeah, I did.
11:51:08 <fizbin> And I think I did it too. I need to update my paste with my current version.
11:51:33 <fizbin> trap_exit: Give me... ten minutes to clean it of proprietary stuff.
11:51:53 <fizbin> Maybe a bit longer to add a better example.
11:52:21 <trap_exit> I love it when someone else solves my problem
11:52:40 <trap_exit> fizbin: after you clean up the code, write a nice blog post, along with a youtube tutorial
11:52:50 <trap_exit> might as well as do it right since youi're doing it
11:52:58 <indiagreen> also put it on Hackage and Stackage
11:53:28 <trap_exit> make it solve 3SAT in linear time too while you're at
11:53:31 <hunt_> guys why isnt Num an extension of Monoid
11:54:38 <indiagreen> hunt_: there are several monoids for e.g. integers
11:54:42 <indiagreen> which one should be the default?
11:55:00 <hunt_> shouldnt the monoid typeclass be a superclass to the num typeclass
11:55:08 <hunt_> not a specific monoid instance
11:55:15 <indiagreen> okay, assume it is
11:55:23 <indiagreen> and Integer is now an instance of Num
11:55:38 <indiagreen> which implies that Integer also should become an instance of Monoid
11:55:44 <indiagreen> question: which instance should it be?
11:56:09 <hunt_> indiagreen: could it not be its own instance
11:56:13 <hunt_> i dont understand the question
11:56:24 <mauke> hunt_: what would that "own instance" look like?
11:56:38 <hunt_> mappend is however + is defined for integers
11:56:40 <hunt_> mempty is 0
11:56:46 <mauke> why not * and 1?
11:57:17 <hunt_> doesnt append imply (+)
11:57:21 <mauke> there's probably also a monoid based on max or gcd
11:57:26 <mauke> hunt_: how could it?
11:57:32 <hunt_> i mean not literally in the code
11:57:34 <mauke> most monoids aren't numbers
11:57:38 <hunt_> just isnt that what mappend is taken to mean
11:57:49 <hunt_> some form of direct concatenation
11:57:54 <mauke> + isn't concatenation
11:58:01 <mauke> + is addition
11:58:04 <hunt_> numerically it seems like the analogue
11:58:06 <cdk_> hunt_: mappend is an associative binary operation with an identity element, that's all
11:58:11 <kadoban> hunt_: Monoid just means it has an associated binary operation, and an identity value. The names in Monoid are a bit poorly chosen...but even so, neither + or * on integers are appending
11:58:16 <ReinH> hunt_: There are multiple choices of Monoid for instances of Num so we prefer to not make an arbitrary choice.
11:58:19 <kadoban> associative*
11:58:19 <hunt_> i see
11:58:26 <ReinH> Sum and Product exist to make the choice explicit
11:58:38 <mauke> + is commutative and invertible
11:58:47 <monochrom> there are many possible monoids using integers. which one should be the default? my answer: the one with the binary operation (\x y -> 0)
11:59:06 <shachaf> monochrom: That's not a monoid.
11:59:21 <monochrom> shoot
11:59:35 <hunt_> ReinH: any examples of how Sum is used?
11:59:36 <shachaf> This is why monoids are better than semigroups.
11:59:41 <monochrom> this is too hard. I'll go shopping.
11:59:53 <indiagreen> > Sum 1 <> Sum 2
11:59:55 <lambdabot>  Sum {getSum = 3}
12:00:06 <mauke> > 1 <> 2 :: Sum Integer
12:00:07 <lambdabot>  Sum {getSum = 3}
12:00:14 <hunt_> i mean like in actual code
12:00:15 <Hijiri> Sum is used in Data.Foldable to implement sum using foldMap
12:00:15 <mauke> > 1 <> 2 :: Product Integer
12:00:16 <cdk_> monochrom: do you mean (\x y -> mempty)?
12:00:17 <lambdabot>  Product {getProduct = 2}
12:00:18 <hunt_> like i see its function
12:00:29 <hunt_> but it seems more useful as a typeclass
12:00:34 <hunt_> i dont see why you would want it as a type
12:00:36 <indiagreen> there's an instance of Num for Sum/Product? cool, didn't know this
12:00:41 <Hijiri> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-Foldable.html#sum
12:00:43 <mauke> me neither :-)
12:00:53 <mauke> but it seemed like the obvious thing to do
12:01:11 <mauke> hunt_: huh? how would it work as a typeclass?
12:01:14 <cdk_> hunt_: A common pattern in Haskell is to use newtype to wrap an existing type but provide different instances
12:01:22 <marchelzo_> cdk_, that's not a monoid either, is it?
12:01:36 <cdk_> marchelzo_: It's the trivial monoid (i think)
12:01:40 <Hijiri> itn's not
12:01:43 <mauke> marchelzo_: it's probably a monoid on ()
12:01:43 <hunt_> mauke: i dont know it just seems like it should be used to generalize about something, how is it useful as a type?
12:01:45 <Hijiri> x <> mempty == mempty
12:01:48 <Hijiri> which is wrong
12:01:53 <marchelzo_> mauke, right
12:01:57 <cdk_> Hijiri: ah, right
12:01:58 <shachaf> (x y -> mempty) could be a monoid, if your type has only one inhabitant.
12:02:01 <mauke> hunt_: because types have instances
12:02:02 <Hijiri> or that
12:02:31 <mauke> hunt_: and so it can define its mappend to be +
12:02:35 <marchelzo_> (\x y -> if x == mempty then y else (if y == mempty then x else mempty))
12:02:39 <hunt_> mauke: i mean would you write a function that takes Sum Int? is that in order to fulfill a function that takes Monoid m
12:02:54 <cdk_> marchelzo_: not a monoid either :( that requires Eq
12:03:06 <mauke> cdk_: Eq is fine
12:03:21 <hunt_> is that right?
12:03:26 <marchelzo_> for Num
12:03:34 <monochrom> I love the monoid on ().
12:03:35 <hunt_> Sum would be used to take something Num and use it in a function that takes Monoid m
12:03:59 <hunt_> also does anyone here understand all the craziness that goes on with arrows
12:04:28 <hunt_> and like what it means to define something on an arrow level that is not an arrow
12:04:34 <ReinH> shachaf: Sorry, what prevents monochrom's binary op from forming a monoid?
12:04:42 <mauke> marchelzo_: looks like that fails associativity
12:04:49 <mauke> ReinH: neutral elements (lack of)
12:04:51 <monochrom> I broke "mempty <> x = x"
12:04:52 <shachaf> The monoid laws.
12:04:59 <shachaf> Yes.
12:05:01 <ReinH> shachaf: ... really?
12:05:09 <shachaf> Yes, the one monochrom said, for instance.
12:05:17 <ReinH> Ah. Makes sense.
12:05:19 <ReinH> Thanks monochrom
12:05:24 <ReinH> shachaf: Don't be rude.
12:05:33 <phaazon> hey, how should I add debug symbols in the compiled executable?
12:05:37 <mauke> ReinH: don't be rude
12:05:44 <ReinH> mauke: How am I being rude?
12:05:47 <phaazon> I’d like to use gDebugger
12:05:48 <Hijiri> let's all be rude
12:05:52 <mauke> <ReinH> shachaf: ... really?
12:05:57 <phaazon> and it fails without debug symbols
12:05:58 <mauke> that added nothing
12:06:04 <hunt_> would it make sense for haskell to allow you to partially define things within typeclasses
12:06:05 <marchelzo_> mauke, you're right :(
12:06:07 <hunt_> like for the mappend example
12:06:19 <ReinH> mauke: Neither did "The monoid laws", which is condescending and rude.
12:06:26 <hunt_> it seems logical to define mappend mempty x = x within the monoid typeclass
12:06:29 <mauke> ReinH: disagree
12:06:35 <mauke> and you got two other answers before that
12:06:55 <phaazon> hm, -debug I guess
12:07:09 <shachaf> If your objection is that I was typing a newline between the two parts of my answer, well, I'll try to conserve vertical space in the future.
12:07:32 <ReinH> shachaf: This is is a common pattern with you. You say a condescending thing first and then maybe follow up with a real answer.
12:07:39 <ab9rf> oi
12:07:47 <hunt_> chill pill
12:07:48 <phaazon> hey, peace and luv guys <3
12:07:51 <ReinH> Things would be improved by just skipping the first part
12:08:22 <mauke> you're the only one who heard it as condescending
12:08:24 <ReinH> Obviously the monoid laws would be what prevents something from being a monoid. Obviously.
12:08:33 <indiagreen> mauke: count me in
12:08:34 <DSALNASS> lol how odd, some dude followed me on twitter so I looked at his pictures and there was a screencap of I assume this #haskell channel
12:08:37 * ab9rf would like to suggest that private messages exist for a reason
12:08:38 <shachaf> I'll have a think on whether that was condescending. It certainly wasn't meant that way.
12:08:50 <mauke> indiagreen: ok!
12:08:53 <shachaf> ReinH: No, the first thing that prevents it from being a monoid is that it didn't have an identity.
12:09:08 <ReinH> shachaf: Indeed, and it would have been better if you had just said that.
12:09:19 <ReinH> Rather than implying that I don't know that monoids have monoid laws.
12:09:25 <shachaf> When you try to figure out what an identity should be, you run into the monoid laws.
12:09:34 <shachaf> I'm not implying anything like that.
12:09:38 <hunt_> guys
12:09:42 <hunt_> how can we use haskell
12:09:46 <hunt_> to dismantle north korea
12:09:51 <delphinas> lol
12:09:54 * ReinH shrugs
12:10:03 <ReinH> It's not worth arguing over. I just wish it wasn't such a common pattern.
12:10:26 <ab9rf> if you want to dismantle north korea, send over a squadron of three year olds with allen wrenches from IKEA
12:10:39 <hunt_> but they hacked sony
12:10:47 <hunt_> are we sure our 3 year olds are up to the challenge?
12:10:55 <EvanR> #haskell-blah
12:11:00 <bennofs> hunt_, ab9rf: that's what #haskell-blah is for
12:11:04 <sivteck> #haskell-war!
12:11:05 <ab9rf> bennofs: bah
12:11:10 <shachaf> There are many things about this channel that it would nice if they weren't common patters.
12:12:10 <hunt_> shachaf: such as?
12:24:33 <chrisdone> odd that i've never used quickcheck for something real
12:24:39 <chrisdone> it's really super easy and nice
12:27:48 <dfeuer> ARGH. Back to off-by-one errors. WHY.
12:30:56 <johnw> chrisdone: I know, right?
12:35:27 <platz> qc seems nice for exploratory testing but somewhat concerned about reproducibility
12:36:11 <platz> would be strange to get failing builds randomly on a ci server
12:38:33 <bartavelle> as it (usually) clearly displays what went wrong, you get a reproducible failing test case
12:39:08 <bartavelle> you just have to make sure you don't miss it on the CI server ;)
12:39:12 <tdammers> hmm, I need a double >>=, somehow
12:39:34 <tdammers> Maybe a >>= a -> Maybe b -- this one is straightforward
12:39:54 <tdammers> but I have: Maybe (Maybe a) ? a -> Maybe b
12:40:05 <tdammers> so what's ? in that scenario?
12:40:19 <mauke> join x >>= y
12:40:21 <tdammers> @hoogle Maybe (Maybe a) -> (a -> Maybe b) -> Maybe b
12:40:23 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
12:40:23 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
12:40:23 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
12:40:23 <bartavelle> you want to join it first or work on the "inner" Maybe ?
12:40:27 <ajcoppa> :t join
12:40:28 <lambdabot> Monad m => m (m a) -> m a
12:40:43 <tdammers> yeah, that looks promising
12:40:44 <monochrom> @djinn Maybe (Maybe a) -> (a -> Maybe b) -> Maybe b
12:40:45 <lambdabot> f a b =
12:40:45 <lambdabot>     case a of
12:40:45 <lambdabot>     Nothing -> Nothing
12:40:45 <lambdabot>     Just c -> case c of
12:40:45 <lambdabot>               Nothing -> Nothing
12:40:47 <lambdabot>               Just d -> b d
12:40:58 <ajcoppa> :t (>>=) . join
12:40:59 <lambdabot> Monad m => m (m a) -> (a -> m b) -> m b
12:41:02 <tdammers> hehe, yeah, what djinn says, but in one line
12:41:13 <monochrom> djinn's is the same as join a >>= b
12:41:19 <tdammers> alrightie
12:41:52 <tdammers> always wondered what that function is for, hehe
12:42:27 <monochrom> join is less obvious in programming, more obvious in mathematics.
12:42:35 <monochrom> and >>=, the opposite.
12:42:49 <bartavelle> tdammers, I use it often with the STM monad, for functions that are like `foo :: STM (IO a)`
12:42:52 <tdammers> heh, shows how I'm a programmer and not a mathematician
12:43:14 <monochrom> I sit on the fence and is a bit of both
12:43:30 <tdammers> I just lean against the fence from the programming side
12:43:36 <monochrom> but you know how both sides stone to death those who sit on the fence.
12:43:40 <tdammers> occasionally peeking through a hole in it
12:43:58 <tdammers> (sure as hell not picking up any rocks, rest assured)
12:44:16 <tdammers> (and if I were, I'd throw them at the people on the far end of my side)
12:44:35 <tdammers> (the "herp derp getting things done" squad)
12:44:40 <tdammers> (but enough with the bashing)
12:46:00 <tsani> Why does "let 1 = 2 in 1" print out 1 in GHCi ?
12:46:15 <bartavelle> tdammers, you can also use join to obfuscate concat
12:46:25 <shachaf> tsani: It means something like this: case 2 of { ~1 -> 1 }
12:46:48 <shachaf> Numbers behave a bit lit constructors for pattern-matching.
12:47:08 <shachaf> It's like let Nothing = Just ... in Nothing
12:47:32 <tdammers> bartavelle: golf much?
12:47:33 <shachaf> Pattern matching, but with no variables.
12:48:06 <tsani> I see how they behave like constructors, but I don't see why it doesn't print 2.
12:48:38 <tsani> Oh, is it because it's constructing a "new 1" ?
12:48:54 <tsani> Likewise for Nothing in the case of "let Nothing = Just 5 in Nothing" ?
12:49:19 <shachaf> Maybe it's easier to see with a more usual use of let: let Just x = ... in ...
12:49:26 <shachaf> The goal of that is to bind x, not define Just.
12:49:38 <tsani> Sure
12:49:41 <shachaf> (And it binds x lazily, so if you don't use x, the first "..." isn't even checked.)
12:50:12 <tsani> But "let 2 + 2 = 5 in 2 + 2" works, because we're locally redefining (+)
12:50:34 <monochrom> (+) is a variable name. 1 is not a variable name. Just is not a variable name either.
12:50:41 <tsani> Aha
12:50:56 <monochrom> variable names get redefined. other names get matched.
12:51:19 <tdammers> hmm, popular beginner gotcha
12:51:32 <monochrom> > case 2 of { ~(+) -> (+) }
12:51:34 <lambdabot>  2
12:52:18 <shachaf> let 2 + 2 = 5 in 2 + 2 can't straightforwardly be translated to a case.
12:52:28 <tdammers> > let y = "foo" in case "bar" of { y -> "Yes: " ++ y; _ -> "nope" }
12:52:30 <lambdabot>  "Yes: bar"
12:53:02 <monochrom> > case (\ 2 2 -> 5) of { ~(+) -> 2 + 2 }
12:53:04 <lambdabot>  5
12:53:41 <monochrom> > (\ (+) -> 2 + 2) (\ 2 2 -> 5)
12:53:42 <lambdabot>  5
12:53:56 <erisco> hard to find certain doc pages... turns out lists and tuples are already promoted to kinds by DataKinds
12:54:04 <erisco> that will simplify some stuff for me
12:54:51 <chrisdone> is there a json api for hackage?
12:55:03 <chrisdone> like "get all versions of a package"
12:55:30 <monochrom> also try: (\ ~1 -> 1) 2
12:56:39 <tsani> What does the tilde do?
12:57:20 <chrisdone> it's a lazy pattern
12:59:30 <chrisdone> ~p means p will always succeed in a pattern match and any strictness there would've been is deferred until any bindings involved in p are used
13:01:56 <chrisdone> i'd link you to the haskell 98 report but still can't reach haskell.org
13:02:21 <marchelzo_> > (\ ~(Just x) -> x) Nothing
13:02:23 <lambdabot>  *Exception: <interactive>:3:2-17: Irrefutable pattern failed for pattern (Da...
13:03:37 <marchelzo_> After reading https://www.haskell.org/haskellwiki/Lazy_pattern_match, it is my understanding that (\ ~(Just x) -> x) would be more efficient than (\(Just x) -> x). Is that true?
13:04:21 <monochrom> false. the opposite.
13:04:46 <marchelzo_> oh. why?
13:05:33 <chrisdone> (\~(Just x) -> x) is like you wrote (\y -> let x = (case y of Just x -> y; _ -> error "irrefutable pattern") in x)
13:05:48 <johnw> isn't \~(Just x) -> x exactly the same thing as "fromJust"?
13:05:54 <monochrom> the optimizer may generate equivalent code
13:05:59 <chrisdone> (not exactly, there're some subtle differences, but i can't get the report)
13:06:36 <chrisdone> (er, Just x -> x, ofc)
13:07:18 <monochrom> (\ ~(Just x) -> x) is an uninteresting example. (\ ~(Just x) -> Just x) is more interesting.
13:07:34 <marchelzo_> ah
13:07:50 <monochrom> (\ ~(Just x) -> Just x) is the same as (\y -> Just (fromJust x))
13:08:14 <monochrom> this is different from (\ (Just x) -> Just x)
13:08:15 <marchelzo_> so it still won't work on Nothing?
13:08:38 <monochrom> it is better to say to which degree you want it to "work"
13:08:47 <marchelzo_> It should error
13:08:50 <marchelzo_> > (\ ~(Just x) -> Just x) Nothing
13:08:52 <lambdabot>  Just *Exception: <interactive>:3:2-22: Irrefutable pattern failed for patter...
13:09:09 <monochrom> > case (\ ~(Just x) -> Just x) Nothing of { Just _ -> "hello" }
13:09:11 <lambdabot>  "hello"
13:09:32 <monochrom> it is better to say to how deep the error lives
13:09:38 <marchelzo_> that is pure magic
13:10:03 <chrisdone> it's only as magic as normal Haskell not evaluating its arguments
13:10:20 <chrisdone> > maybe 123 (const 123) (Just undefined)
13:10:22 <lambdabot>  123
13:10:25 <monochrom> strictness, "works", and error are not booleans. instead, whole spectrums. in fact, not just linear spectrums, non-linear (branching) trees
13:10:37 <monochrom> but perhaps s/spectrums/spectra/
13:10:44 <chrisdone> spectræ
13:10:59 <marchelzo_> case force ((\ ~(Just x) -> Just x) Nothing) of { Just _ -> "hello" }
13:11:15 <indiagreen> chrisdone: okay, apparently there's an API but it's really incomplete (e.g. http://hackage.haskell.org/package/lucid/preferred works, http://hackage.haskell.org/package/lucid/preferred.json doesn't)
13:11:16 <marchelzo_> > case force ((\ ~(Just x) -> Just x) Nothing) of { Just _ -> "hello" }
13:11:17 <lambdabot>  Not in scope: ‘force’
13:11:42 <monochrom> error "xxx" is different from Just (error "xxx")
13:12:14 <chrisdone> indiagreen: perhaps it's one of those where they base it on accept HTTP headers
13:12:15 <erisco> I am confused by DataKinds. Why can I not get something like this to work? http://lpaste.net/116820
13:12:50 <chrisdone> indiagreen: seems not
13:12:54 <marchelzo_> monochrom, are you saying that (\ ~(Just x) -> Just x) Nothing is Just (error "xxx")?
13:13:00 <monochrom> yes
13:13:11 <marchelzo_> Okay I can see why the case pattern match works.
13:13:14 <indiagreen> chrisdone: they don't even list JSON support for this one at http://hackage.haskell.org/api, so I guess not
13:13:26 <marchelzo_> I didn't know that the error was in the Maybe, though?
13:13:28 <chrisdone> i thought i was clever by making M-. open the hackage docs from emacs if it comes from a separate package
13:13:48 <monochrom> <monochrom> (\ ~(Just x) -> Just x) is the same as (\y -> Just (fromJust x))
13:13:48 <chrisdone> but because hackage had that zombie period where it generated no docs half of the versions are 404's
13:13:59 <erisco> okay I derped so hard in a number of ways, including not having DataKinds on :P
13:14:07 <erisco> never mind
13:14:08 <monochrom> err, that one has a typo
13:14:09 <marchelzo_> monochrom, ahh, I didn't realize the implications of that
13:14:16 <marchelzo_> yeah
13:14:17 <monochrom> (\y -> Just (fromJust y))
13:14:43 <monochrom> fromJust y gives you error "xxx", but it's still nested inside an outer Just.
13:15:33 <monochrom> this is why you are not looking at a boolean, you are looking at a whole hierarchy ⊥, Just ⊥, Just (Just ⊥), ...
13:16:39 <chrisdone> Haskell: and you thought null pointers were tricky!
13:17:29 <marchelzo_> oh I should have realized when I tried it. It said "Just Exception..." instead of just "Exception..."
13:17:37 <marchelzo_> That's pretty cool.
13:18:11 <chrisdone> ⊥ and null are pretty similar in practical terms, although one can at least print a null
13:18:23 <fizbin> @tell trap_exit Sorry, got distracted, but the parsing stuff is at http://lpaste.net/116821
13:18:23 <lambdabot> Consider it noted.
13:19:14 <fizbin> chrisdone: Though I think Scala actually distinguishes the types of bottom and null.
13:19:18 <chrisdone> i feel a bit awkward when i hear "no null pointers in haskell!" and in my head add "… we have something far worse"
13:19:52 <monochrom> I disagree that it is worse. I think it is better.
13:19:54 <erisco> why does promotion fail? http://lpaste.net/116822
13:19:57 <erisco> this is for real now, less derping
13:20:01 <chrisdone> fizbin: what does scala use bottom for?
13:20:23 * hackagebot HTTP 4000.2.19 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.19 (GaneshSittampalam)
13:20:28 <erisco> chrisdone, which one? bottom? unsafePerformIO? unsafeCast? undefined? error?
13:20:43 <erisco> exhausted patterns?
13:20:55 <fizbin> chrisdone: Scala has a type called Nothing. A method may only declare itself as returning Nothing if it always throws an exception.
13:21:27 <monochrom> in a null-laden language, when you give me f :: X->Y, and when I use it, I am obliged to use it like "g (if f x == null then f x else something_else)"
13:21:36 <chrisdone> erisco: well, they're all caused by laziness. i accept the trade-off, but i don't try to downplay the landmine aspect of it
13:21:58 <monochrom> in Haskell, I just use it as "g (f x)". oh, f x may be bottom? that's your problem, not mine, I can't even do anything about it.
13:22:00 <fizbin> Well, I guess technically in Scala you could return a theoretical value of type Nothing that you got from another method.
13:22:29 <erisco> monochrom, meh, maybe you can say the same to null
13:22:30 <chrisdone> harper's arguments against laziness are pretty compelling in this particular aspect. in ML, when you have a value, you *have a value*. only functions can yield ⊥. in haskell, almost everything can
13:22:33 <monochrom> this does not even need a total language.
13:22:34 <erisco> "don't give me a null or it is your problem"
13:23:25 <fizbin> But the point is, there are no values of type Nothing, "return null" in a Nothing-valued Scala function won't compile. Nothing sits at the total bottom of the type hierarchy and you can assign any variable to something that is declared to return Nothing.
13:24:02 <Peaker> chrisdone: well, when Harper is confronted with cases that benefit greatly from laziness, he says "no problem, opt in to laziness there". So here too - if you want a *value*, just opt out of laziness there
13:24:24 <fizbin> It's common scala idiom to declare a function ??? of type Nothing that just throws UnimplementedException and then use ??? the way haskellers sometimes use "undefined" all over the place while working out some code.
13:24:27 <monochrom> ok, let me try a different angle. null helped people procratinate getting algebraic data types.
13:24:53 <monochrom> with null, when people wanted an option type, they used null for "Nothing".
13:25:00 <chrisdone> Peaker: the arguments on both sides work. haskell's laziness benefits only work because laziness is pervasive, but so are the problems
13:25:21 <monochrom> if null didn't existed, people who wanted an option type would discover algebraic data type.
13:25:46 <Peaker> chrisdone: some of the benefits are there even when it isn't pervasive (e.g: map (+ expensive) xs)
13:25:54 <tasker> I need to test that some stuff compiles on windows 64 - anyone know where I can get a windows 7 64 bit vm ?
13:26:22 <Peaker> Trying out leksah for the first time in ages. It's "Updating Metadata" for a looong time
13:26:23 <fizbin> monochrom: Probably. They might first discover (Bool, value-with-default)
13:26:36 <monochrom> haha
13:29:08 <athan> hey guys, pop quiz: If I'm getting this type inferred as an error from using `lift ask` :: (MonadReader LT.Text (ReaderT T.Text m)), do I need _another_ lift, or one less lift?
13:29:53 <chrisdone> MonadReader is a class…
13:30:42 <athan> chrisdone: your ldots scare me
13:32:29 <dfeuer> Woohoo! Tremendous progress!
13:33:54 <HeladoDeBrownie> ldots…?
13:34:35 <JagaJaga> Hi! Have script like `foo -i | grep Bar | cut -f2 -d ":" | cut -f2 -d " "`. How to write that using haskell? Parsec?
13:34:49 <HeladoDeBrownie> JagaJaga, what's it do?
13:35:31 <JagaJaga> HeladoDeBrownie: getting line from programm's output :)
13:35:47 <HeladoDeBrownie> JagaJaga, more specific? Seems more involved than that
13:36:11 <marchelzo_> JagaJaga, I'm assuming you want to replace "grep Bar | cut ... " with a haskell program? You could do it. I doubt parsec would be terribly helpful.
13:36:48 <chrisdone> > filter (isInfixOf "Bar") (lines "Bar bob\nBar black\n sheep")
13:36:50 <lambdabot>  ["Bar bob","Bar black"]
13:37:12 <JagaJaga> marchelzo_: yes, that's what I want. so what's the best way to do it?
13:37:16 <JagaJaga> chrisdone: oh!
13:37:40 <chrisdone> > map (take 4 . (++":") . drop 2) (filter (isInfixOf "Bar") (lines "Bar bob\nBar black\n sheep"))
13:37:41 <lambdabot>  ["r bo","r bl"]
13:38:24 <pyon> @pl (\f -> f x) . foo . bar
13:38:24 <lambdabot> flip foo x . bar
13:38:31 <chrisdone> use the Data.Text version of these functions
13:38:31 <JagaJaga> chrisdone: this methods are obvious, thought there were some special libs..
13:38:45 <chrisdone> obvious but your question was vague ;)
13:38:51 <hodapp> hmmm, this dependent typing for array indices in Ivory is getting me down
13:38:53 <chrisdone> "How to write that using haskell?"
13:39:04 <JagaJaga> chrisdone: yeah, my fault :)
13:39:12 <exio4> @type \foo bar x -> ($ x) . foo . bar
13:39:13 <lambdabot> (b -> a1 -> c) -> (a -> b) -> a1 -> a -> c
13:39:20 <exio4> @type \foo bar x -> flip foo x bar
13:39:21 <hodapp> I get why it had to be there, but it's still a pain...
13:39:21 <lambdabot> (a -> b -> c) -> a -> b -> c
13:39:25 <exio4> @type \foo bar x -> flip foo x . bar
13:39:25 <chrisdone> with shell-conduit you can use those shell commands :3
13:39:26 <lambdabot> (b -> b1 -> c) -> (a -> b) -> b1 -> a -> c
13:39:35 <marchelzo_> JagaJaga, Text.Regex.Posix might help
13:39:51 <chrisdone> grep "Bar" $| cut "-f2" "-d" ":" $| cut "-f2" "-d" " "
13:40:05 <chrisdone> https://github.com/chrisdone/shell-conduit
13:40:14 <thungsten> @pl \a -> (max a .) . min
13:40:14 <lambdabot> (. min) . (.) . max
13:40:22 <chrisdone> depends on your use-case
13:40:40 <takemikazuchi545> can anyone help me understand the mutual recursion of an equality type class?
13:41:08 <takemikazuchi545> I'm going through learn you a haskell and I'm having trouble understanding how the recursion terminates
13:41:12 <erisco> I am beginning to understand that :.: does not infer how I want it to
13:41:13 <takemikazuchi545> This is the code: http://lpaste.net/116824
13:41:21 <shachaf> Do you mean the definitions of (==) and (/=)?
13:41:38 <takemikazuchi545> @shachaf yes
13:41:38 <lambdabot> Unknown command, try @list
13:42:02 <HeladoDeBrownie> takemikazuchi545, they don't end up being mutually recursive. Your instance replaces one.
13:42:08 <shachaf> You define how (==) and (/=) behave for your type.
13:42:14 <HeladoDeBrownie> (Or both.)
13:42:28 <takemikazuchi545> Oh is the instance overriding them?
13:42:29 <shachaf> If you don't define them, there's a default for each one in terms. You can choose to define either one or both.
13:42:35 <HeladoDeBrownie> takemikazuchi545, basically.
13:42:49 <chrisdone> if you forget to implement one, it doesn't terminate =)
13:42:53 <shachaf> "overriding" sounds like something atypical, but this is what instances are for.
13:43:03 <takemikazuchi545> The explanation in learnyouahaskell was, "Because == was defined in terms of /= and vice versa in the class declaration, we only had to overwrite one of them in the instance declaration."
13:43:09 <shachaf> chrisdone: Fortunately we have this great MINIMAL pragma now, so GHC warns you.
13:43:17 <chrisdone> MINIMAL++
13:43:18 <shachaf> Oh, well, that's LYAH.
13:43:32 <chrisdone> Haddock also takes advantage of that, right?
13:43:42 <chrisdone> with the Minimal section i recall seeing
13:43:50 <shiona> I switched architecture of my system, should I just delete my old ~/.cabal (and possibly something else) and reinstall everything I need or do something else?
13:43:59 <HeladoDeBrownie> I thought I saw manually worded entries in Manual sections
13:44:06 <shiona> (from i686 to x86_64)
13:44:19 <takemikazuchi545> I think that makes sense then.
13:44:24 <HeladoDeBrownie> s/Manual/Minimal/
13:44:54 <chrisdone> HeladoDeBrownie: http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#t:Eq
13:44:54 <erisco> here is my kind problem http://lpaste.net/116825
13:45:05 <erisco> prized Internet points to the solver
13:45:07 <chrisdone> this one has a fully supported "Minimal complete definition" section
13:45:34 <chrisdone> i've seen some classes with default methods which don't display this section, but i think those lack the MINIMAL pragma
13:45:38 <takemikazuchi545> So since I don't implement ./= the instance will derive ./= from its typeclass? And the .== in the function body of ./= will be the .== I defined in the instance?
13:46:03 <chrisdone> e.g. Bifunctor: https://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html
13:46:03 <HeladoDeBrownie> chrisdone, oh, the "Minimal complete definition" subheading with just the symbols?
13:46:22 <chrisdone> and the latest version does have it: https://hackage.haskell.org/package/bifunctors-4.2/docs/Data-Bifunctor.html
13:46:32 <chrisdone> HeladoDeBrownie: right =)
13:47:19 * chrisdone can never remember optparse-applicative's API 
13:48:16 <fizbin> I think the number of different haskell parsing APIs out there is a sign of something bad.
13:48:56 <erisco> two DDG results for my compile error. one is from #haskell-blah in 2005 said by lambdabot
13:48:58 <erisco> the other is a 404
13:49:00 <chrisdone> fizbin: how many are you thinking of?
13:49:05 <erisco> er
13:49:09 <erisco> from #haskell
13:49:40 <chrisdone> only parsec, attoparsec and frisby spring to mind
13:49:54 <fizbin> chrisdone: Oh, parsec, attoparsec, uuparsing-lib, happy, frisby...
13:50:39 <fizbin> Even the java world doesn't have that many.
13:50:43 <chrisdone> uuparsing-lib??
13:50:57 <chrisdone> i don't know that lib, but the others are simply different
13:51:02 <fizbin> https://hackage.haskell.org/package/uu-parsinglib
13:51:16 <fizbin> Sorry, put the dash in the wrong spot
13:51:20 <ab9rf> fizbin: it's a sign of the fact that haskell is especially amenable for writing parsers
13:51:49 <fizbin> No, I think haskell is especially amenable to writing parser libraries.
13:51:50 <ab9rf> and that people who fiddle about with haskell are the sort of people who write parsing libraries for fun
13:52:08 <erisco> "Kind signature on data type declaration has non-* return kind" why is this a restriction
13:52:36 <chrisdone> happy is a parser generator, parsec is a DSL that abstracts over both the token and the monad with optional backtracking, attoparsec is a DSL that focuses on performance and specializes on the token which backtracks all the time
13:52:45 <chrisdone> and frisby is a packrat PEG parser which is totally different to the previous three
13:53:02 <fizbin> But in particular, to writing parser libraries that aren't quite right.
13:53:20 <erisco> fizbin, I know you
13:53:21 <Peaker> Leksah code browsing/completion/docs seem to work! None of the other features seem to work though. Running package -> no-op. Trying to get type/info of anything -> Parse errors
13:53:28 <ab9rf> fizbin: feel free to write one that is quite right :)
13:53:56 <fizbin> So someone else comes along, and writes their own from scratch because writing your own from scratch is easier than tweaking someone else's code.
13:53:57 <chrisdone> if java has less than three parser libraries i'd wonder what's so hard about writing parser libraries in java
13:54:14 <ab9rf> i'm sure there's more than three java parser libraries, too :)
13:54:30 <Peaker> Maybe none of the Haskell IDE's/etc were ever tried on a medium/large project? Or one with both a Library and an Executable section?
13:54:48 <chrisdone> i run all my large projects through ghci
13:54:49 <erisco> writing parser combinators in languages without infix operators is painful... overloaded operators is slightly less painful
13:55:14 <pavonia> erisco: Can't you explicitly specify the result kind of (:.:)?
13:55:19 <chrisdone> but i have patience to invest time to get something working
13:55:25 <fizbin> Yeah, but in common use you'll find AntLR, a jLex or whatever that lex port is, and... that's it, really.
13:55:27 <erisco> pavonia, I wish! but I get the compile error "Kind signature on data type declaration has non-* return kind"
13:55:49 <pavonia> Ah
13:56:19 <Peaker> chrisdone: but the canonical "load project", "check type of some subexpression" workflow doesn't seem to work out of the box in either the Haskell-emacs packages or leksah, with the Lamdu cabal project
13:57:04 <erisco> * is basically Dynamic for types it seems
13:57:13 <chrisdone> working out of the box for a particular project is slightly different
13:58:44 * chrisdone clones lamdu
13:59:10 <Peaker> chrisdone: We're working in the wip_integration branch, not in master
14:00:56 <Peaker> I wonder if the fact our cabal package is called "lamdu" and the executable is called "lamdu" is causing trouble. Just saw a warning about ambiguity there from leksah
14:03:04 <erisco> I am being hamstrung... cannot have partially applied type families, cannot have non-* return kinds for data
14:03:18 <chrisdone> Peaker: yeah, one red flag is having so many modules in an Executable section
14:03:38 <HeladoDeBrownie> erisco, I imagine that's because data specifically defines inhabited types, only * can be inhabited
14:03:47 <chrisdone> executables should just have a Main and import the library, really, but oh well
14:04:01 <Peaker> chrisdone: well, we tried splitting it across some sensible abstraction boundary
14:04:10 <HeladoDeBrownie> erisco, you complained about the partial application thing, right? :P
14:04:11 <erisco> HeladoDeBrownie, well my data type has no constructors anyways, it is already uninhabited
14:04:13 <Peaker> The lib is for reusable generic stuff
14:04:16 <erisco> yes, always
14:04:18 <HeladoDeBrownie> erisco, it's inhabited by _|_ unfortunately
14:04:26 <Peaker> And the exe is for stuff specifically for this app
14:04:29 <erisco> get out of here bottom
14:04:48 <erisco> the only reason I am using data is because you can partially apply type constructors
14:04:56 <erisco> if there was any other way
14:07:23 <chrisdone> Peaker: so: exposed-modules / other-modules
14:07:38 <chrisdone> i'm cabal installing… hopefully the opengl stuff will build :3
14:08:58 <delphinas> anyone uses haskell with sublime?
14:09:01 <delphinas> sublime text
14:09:01 <chrisdone> i should've built with --ghc-options=-O2
14:09:05 <chrisdone> er, -O0
14:10:40 <chrisdone> Building lamdu-0.1...
14:10:40 <chrisdone> Preprocessing library lamdu-0.1...
14:10:40 <chrisdone> cabal: can't find source for Data/Map/Utils in bottlelib, submodules/AlgoW,
14:10:40 <chrisdone> dist/build/autogen
14:10:46 <chrisdone> Peaker: is that expected?
14:11:36 <Peaker> chrisdone: need submodule update
14:12:03 <chrisdone> okay, building now
14:12:09 <Peaker> We currently refer to submodule sources directly in lamdu's cabal, which is a hack to avoid a multiple package build
14:12:28 <Peaker> (but the submodule has its own cabal, as a smaller project for easier development of that sub-component)
14:12:53 <chrisdone> nod
14:15:25 * hackagebot eventstore 0.1.0.1 - EventStore Haskell TCP Client  http://hackage.haskell.org/package/eventstore-0.1.0.1 (YorickLaupa)
14:16:01 <chrisdone> mmk, loaded in
14:16:22 <chrisdone> so everything in bottlelib/ jumps and has type info
14:16:30 <chrisdone> let's try the other ones
14:17:09 <chrisdone> ok, submodules/AlgoW also works fine
14:18:49 <chrisdone> Peaker: so that's ok so far
14:18:59 <Peaker> chrisdone: hmm. Nothing I tried in either one of those with the chrisdone-haskell-emacs repo worked, weird!  Maybe different emacs versions?
14:19:47 <chrisdone> well, i seem to remember you saying loading the library target and then opening an executable file doesn't work
14:20:00 <Peaker> I tried opening library files too
14:20:06 <Peaker> I couldn't get any type info to ever work
14:20:12 <Peaker> I tried various files
14:20:23 <Peaker> I tried reloading the session, changing session targets.. nada
14:21:07 <chrisdone> i tried that in my regular emacs. i'll try that repo version
14:21:44 <chrisdone> loaded everything, collecting type info for 63 modules(s) ..
14:21:48 <chrisdone> done
14:22:00 <chrisdone> works…
14:22:10 <chrisdone> chris@retina:~$ emacs --version
14:22:11 <chrisdone> GNU Emacs 24.3.1
14:22:51 <chrisdone> also emacs git version which i built yesterday
14:23:09 <chrisdone> $ ~/Repos/emacs/src/emacs --version
14:23:09 <chrisdone> GNU Emacs 25.0.50.1
14:23:12 <Peaker> same emacs version
14:23:26 <chrisdone> you want me to record my screen of the steps i do?
14:23:38 <Peaker> yeah, that would be great!
14:23:48 <Peaker> thanks!
14:23:57 <Peaker> does it record the key presses?
14:24:57 <chrisdone> i made a lil app to do that, i'll run it
14:24:57 <Zemyla> :t (,1)
14:24:58 <lambdabot> Num t1 => t -> (t, t1)
14:25:30 <greymalkin> all of a sudden, every sandbox I make can't install things because "profiling libraries" -- what is the way to fix this?
14:26:39 <mmachenry> greymalkin: I'm actually trying to do this myself right now. I think I need to --reinstall
14:27:01 <mmachenry> But cabal doesn't recognize my —reinstall argument and I spelled it right and it tells me to use —reinstall
14:27:43 <Hijiri> you almost never need --reinstall
14:27:52 <Hijiri> delete the packages directory in ~/.ghc
14:27:56 <Hijiri> and it will reinstall everything
14:28:10 <greymalkin> I've gotten cabal (install) to note my 'reinstall', but eventually I get down to a level where a package which is part of the one I'm compiling says something like:
14:28:22 <greymalkin> Perhaps you haven't installed the profiling libraries for package ‘data-default-class-0.0.1’?
14:28:28 <Hijiri> you also want to make sure you don't have global packages installed e.g. from haskell platform or ghc libraries from your distro
14:29:10 <mmachenry> greymalkin: Yeah I'm getting that too. I just did and "rm -rf .cabal-sandbox" and cabal sandbox init and I'm trying again
14:29:21 <mmachenry> I'll let you know if that works.
14:29:41 <greymalkin> mmachenry: So, in other words, we can't use xmonad from our distro while also making haskell applications with cabal sandboxes?
14:29:54 <Hijiri> have you tried deleting ~/.ghc/<architecture name>?
14:30:22 <Hijiri> @mmachenry
14:30:22 <lambdabot> Unknown command, try @list
14:30:24 <erisco> HeladoDeBrownie, I quite possibly have worked around the problem in a simple way... oO
14:30:25 * hackagebot google-drive 0.3.1 - Google Drive API access  http://hackage.haskell.org/package/google-drive-0.3.1 (PatrickBrisbin)
14:30:27 <glguy> greymalkin: Hopefully your distribution also packages profiling versions of libraries
14:30:33 <erisco> the amazing thing is I have no idea precisely what I have done!
14:30:50 <hodapp> erisco: hey, me too!
14:31:08 <erisco> I just typed in some things and told GHC to figure it out and it did
14:31:09 <mmachenry> glguy: No I'm using cabal for everything. My OS doesn't matter in that respect I think.
14:31:13 <hodapp> erisco: I just figured out how to use the arrays in Ivory that have their size fixed at compile-time
14:31:28 <erisco> nice! though I don't know what Ivory is
14:31:43 <johnw> c2hsc has preliminary support for turning C headers into Ivory declarations, btw
14:31:46 <glguy> mmachenry: I just misunderstood the problem by not reading far enough up the backlog
14:31:47 <hodapp> http://ivorylang.org/ivory-introduction.html and it's from Galois
14:31:53 <johnw> it supports fixed-size array declarations
14:32:03 <hodapp> johnw: c2hsc? Never heard of it...
14:32:09 <johnw> http://hackage.haskell.org/package/c2hsc
14:32:24 <hodapp> johnw: what's your connection to all this?
14:32:29 <johnw> I wrote it
14:32:35 <hodapp> johnw: You use Ivory too?
14:32:40 <johnw> oh, that connection
14:32:43 <johnw> no, I know people at Galois
14:33:06 <hodapp> Am I the only one in #haskell who either is working at Galois right at this instant, or knows people who are?
14:33:08 <johnw> and the project for which Ivory was created is also being worked on by my company
14:33:20 <johnw> lispy works at galois
14:33:21 <hodapp> s/is/isn't.
14:33:25 <johnw> ah
14:33:28 <hodapp> quit proving my point!
14:33:33 <hodapp> glguy does too, afaik.
14:33:52 <hodapp> he harassed Lee Pike for me the other day
14:35:39 <hodapp> I don't know what hsc files are, but I will be looking at this because if it can interface to Ivory it may help me
14:35:55 <glguy> hsc files are input to the hsc2hs program
14:35:58 <hodapp> as I am having to convert some code over to Ivory, and running into a lot of annoyance when I need to interface Ivory with some API I don't control
14:36:06 <glguy> which knows how to compute struct offsets and stuff
14:36:18 <johnw> hodapp: so, my Ivory support is work-in-progress, but I'm eager to complete it
14:36:31 <johnw> so I'm happy (after the holidays) to work with you and any examples you come up with that fail to convert properly
14:36:52 <johnw> my company is willing to fund the work, so finding time to do it isn't a problem
14:36:58 <hodapp> johnw: ooh, awesome
14:37:17 <hodapp> I'd like to help a bit with Ivory documentation... but I am having a hard time understanding things that lack documentation.
14:37:28 <hodapp> but I'll take a look at c2hsc tomorrow
14:38:17 <glguy> hsc2hs*
14:38:37 <glguy> There's also c2hs or something , but it's different
14:39:01 <johnw> yeah, way different
14:39:04 <acowley> johnw: Oh wow, you get to work on Ivory?
14:39:11 <johnw> no, not on Ivory directly
14:39:23 <johnw> but if I can find small side projects that benefit Ivory, it's looked well upon
14:40:09 <chrisdone> Peaker: do you have google hangouts?
14:40:27 <hodapp> glguy: I literally meant c2hsc here as it's what johnw told me of
14:40:50 <dfeuer> Yeeeee haw.
14:41:06 <glguy> Ah, neat. TIL
14:44:16 <acowley> I'd not heard of c2hsc yet, either. Has anyone tried it against a large-ish API?
14:44:26 <johnw> i use it against libgit2
14:44:38 <johnw> maybe 30 files, a few thousands lines of headers
14:45:42 <chrisdone> Peaker: i made a quick video, recordmydesktop is compressing it
14:46:04 <acowley> That's really good to hear. You haven't had any trouble from language-c?
14:46:09 <chrisdone> will take a couple minutes
14:46:45 <johnw> acowley: no, just total failure concerning macro-related stuff
14:47:47 <erisco> data Set where Set :: [a] -> Set;  if Set is promoted, I cannot seem to unambiguously refer to the data constructor
14:47:53 <erisco> is this a flaw or is there special syntax?
14:48:04 <acowley> johnw: We had a problem with c2hs due to language-c because it couldn't parse some pragma when Yosemite came out. I hacked a fix, but it took ages to get it upstream due to various not-good reasons.
14:48:20 <Aruro> it has been pointed out that this definitionof maximum is very slow : maxi (x:rest) = if x > maxi rest then x else maxi rest
14:48:26 <Aruro> why?
14:48:27 <johnw> ah, I haven't done much with it post-Yosemite
14:49:07 <chrisdone> aruro: it looks O(n2)
14:49:16 <chrisdone> damn, compose key fail
14:49:20 <Aruro> why?
14:49:21 <erisco> I can rename to  data Set' where Set :: [a] -> Set';  and it is happy, but I am not totally happy
14:49:22 <chrisdone> O(n²)
14:49:31 <Aruro> why does it look like that?
14:49:55 <Aruro> because of double recursion?
14:50:01 <chrisdone> Aruro: because you are doing n operations × n-k operations
14:50:03 <chrisdone> yeah
14:50:46 <Aruro> actually maxi [1..256]
14:50:58 <Aruro> got hanged on my machine
14:50:59 <chrisdone> which means as the size of the list scales, the number of operations scales with it in a quadratic manner
14:51:18 <Aruro> so roughly 256 ^ 2
14:51:45 <Aruro> approx 9*10^4
14:51:55 <Aruro> operations
14:52:09 <chrisdone> roughly yeah. under that, but growth is about scale rather than specific discrete numbers
14:52:16 <indiagreen> hm
14:52:26 <indiagreen> but maxi [1..256] definitely shouldn't hang then
14:52:48 <indiagreen> actually it looks like 2^n
14:52:48 <Aruro> so question why?
14:53:12 <Aruro> 90000 operations does not look much or it does?
14:53:28 <indiagreen> okay, so
14:53:30 <indiagreen> Aruro
14:53:33 <Aruro> yes
14:53:37 <exio4> > 2 ^ 256
14:53:39 <lambdabot>  115792089237316195423570985008687907853269984665640564039457584007913129639936
14:53:44 <indiagreen> maxi [1..n] takes twice as much time as maxi [1..n-1]
14:53:45 <indiagreen> right?
14:53:50 <indiagreen> well, or [2..n]
14:54:05 <Aruro> oook seems so
14:54:12 <dfeuer> johnw, ReinH, carter: I DID IT.
14:54:14 <indiagreen> so it's (twice as much time) × (number of elements)
14:54:16 <indiagreen> so, 2^n
14:54:24 <Aruro> ok sounds logical
14:54:38 <marchelzo_> indiagreen, why is his definition 2^n ?
14:54:53 <Aruro> takes twice as much time because recursion is used twice?
14:54:57 <Aruro> in if expr?
14:55:06 <kadoban> It's T(n) = 2T(n-1) + O(1)
14:55:31 <Aruro> whatever it is
14:55:34 <Aruro> maxi 50 hangs
14:55:36 <Aruro> too
14:55:44 <Aruro> so it looks more like power law
14:55:48 <Aruro> indeed
14:56:03 <kadoban> T(n) = T(n-1) + O(1) is O(n^2), so yeah it basically has to be much much worse than that at least, hehe.
14:56:19 <chrisdone> s'what i said =p
14:56:52 <Aruro> no it is not n^2
14:57:03 <Aruro> it is 2^n
14:57:08 <Aruro> much worse
14:57:18 <Aruro> n^2 is nothing on such small lists
14:57:24 <chrisdone> oh, you're correct
14:58:09 <chrisdone> it is worse than O(n²). i was reading it as n-1 steps for n steps. but each of those steps recurses
14:58:20 <Aruro> yes
14:58:21 <kadoban> Yeah
14:58:21 <johnw> O(no)
14:58:25 <chrisdone> you may have invented a new incredibly slow algorithm
14:58:27 <Aruro> :D
14:58:28 <chrisdone> congratulations!
14:58:30 <Aruro> not me
14:58:34 <Aruro> friend asked
14:58:37 <Aruro> why it is so slow
14:58:45 <chrisdone> =)
14:59:03 <Aruro> well i dont know how he wrote it , but looks there are no many options :)
14:59:09 <Aruro> not*
14:59:36 <kadoban> To improve it you mean? There's many options :)
14:59:47 <Aruro> untill we are talking maxi 50 is still there :D
14:59:49 <Aruro> no
14:59:51 <acowley> Hahaha, I love the "Not for me, it's for a friend...." proviso on an algorithmic complexity question
15:00:22 <Aruro> i mean to write it recursively
15:00:25 <chrisdone> Aruro: do you want a spoiler?
15:00:37 <fizbin1> > let maxi (x:rest) = let y = maxi rest in if x > y then x else y; maxi [x] = x in maxi [1..500]
15:00:38 <chrisdone> because there is one incoming whether you want one or not. someone in here has itchy fingers
15:00:39 <lambdabot>  *Exception: <interactive>:3:5-77: Non-exhaustive patterns in function maxi
15:00:45 <Aruro> acrowley :D  he asked me why haskell is so slow :) here is your answer
15:00:53 <fizbin1> Oops. Wrong order.
15:01:18 <fizbin1> > let maxi [x] = x; maxi (x:rest) = let y = maxi rest in if x > y then x else y in maxi [1..500]
15:01:19 <Aruro> give me spoiler :)
15:01:19 <kadoban> Aruro: Oh, of course you can fix it while it still being recursive. It's trivial to make it O(n^2) at least, and not much harder to make it O(n)
15:01:19 <lambdabot>  500
15:01:28 <chrisdone> > foldl' max 0 [1..10000]
15:01:29 <lambdabot>  10000
15:01:46 <Aruro> aha :) no fold is how maximum seems defined inside
15:01:53 <Aruro> whole point was to deviate from that
15:02:06 <chrisdone> just for the sake of re-implementing foldl?
15:02:35 <Aruro> fizbin1 let me think
15:02:42 <marchelzo_> if you were to compile it using GHC, the way that Aruro originally had it, it would surely be optimized to use the let, right?
15:02:53 <Aruro> maxi (x:rest) = if x > maxi rest then x else maxi rest
15:02:56 <Aruro> original
15:03:09 <Aruro> i skipped empty case
15:03:14 <indiagreen> marchelzo_: no, GHC doesn't do CSE
15:03:19 <kadoban> marchelzo_: I don't think so
15:03:25 <fizbin1> Mine is equivalent to using "foldl" instead of "foldl' " in what chrisdone said
15:03:34 <Aruro> ah ok
15:03:37 <Aruro> ty
15:03:38 <fizbin1> Well, maybe.
15:03:58 <fizbin1> Actually, I guess mine might be equivalent to foldr
15:04:01 <Aruro> you are using let blocks to remember
15:04:15 <Aruro> assume it is not alowed
15:04:17 <fizbin1> And more importantly, to recurse only once.
15:04:32 <marchelzo_> Oh, is there a reason it doesn't? It seems odd since Haskell has referential transparency
15:04:50 <fizbin1> Aruro: Is it allowed to build on the function "max" ?
15:05:06 <indiagreen> marchelzo_: sometimes you don't want to float things out
15:05:13 <indiagreen> like, say, you're using [1..1000000]
15:05:16 <indiagreen> in 2 places
15:05:26 <Aruro> max ? what is does
15:05:31 <fizbin> @src max
15:05:31 <lambdabot> max x y = if x <= y then y else x
15:05:39 <indiagreen> you don't want this big list to remain in memory because it's easier to recompute it every time
15:05:52 <indiagreen> but if it gets “let-optimised”, it will remain in memory
15:05:53 <Aruro> ok you can use max
15:06:00 <Aruro> i guess that will still be rather neat
15:06:00 <indiagreen> hooray, you've got a space leak
15:06:05 <chrisdone> Peaker: upload video… =p
15:06:42 <marchelzo_> indiagreen, interesting. I suppose it's easy enough to apply CSE manually where applicable.
15:07:04 <fizbin> > let maxi [x] = x; maxi (x:xs) = max x (maxi xs) in maxi [1..10000]
15:07:06 <lambdabot>  10000
15:07:19 <fizbin> Aruro: ^^
15:07:23 <Aruro> cool! :)
15:07:30 <Aruro> at least it works :)
15:07:36 <chrisdone> fizbin: hey… did you graduate SICP? =p
15:07:46 <Aruro> wait
15:07:56 <Aruro> looks great but now i think
15:08:07 <fizbin> But by bouncing through "max", I'm doing what you didn't like before about "remembering with let" by using max's two references to "x" and "y".
15:08:26 <Aruro> yes!
15:08:48 <chrisdone> i think your maxi will also run out of stack on big lists
15:09:03 <chrisdone> unless ghc implements tail recursion modulo cons, which i don't think it does
15:09:25 <Aruro> fizbin your remembering is more neat
15:09:28 <fizbin> chrisdone: Maybe. It's equivalent as written to foldr, and I don't know the rules about stream fusion.
15:09:45 <Aruro> cuase its hidden inside max second parameter indeed
15:10:01 <Aruro> so this crazy definition : maxi (x:rest) = if x > maxi rest then x else maxi rest
15:10:14 <Aruro> seems to be the only one? under our conditions?
15:10:15 <chrisdone> main = print (maxi [1..100000000])
15:10:18 <chrisdone> Stack space overflow: current size 8388608 bytes.
15:10:18 <chrisdone> Use `+RTS -Ksize -RTS' to increase it.
15:10:24 <shlevy> Any book recs for a brand new programmer to indoctrinate them in the ways of FP?
15:10:26 <Aruro> not using fold and remembering
15:10:46 <marchelzo_> let maxi [a] = a ; maxi [a,b] = if a > b then a else b ; maxi (x:xs) = maxi [x,maxi xs]
15:10:53 <Aruro> and no remembering through second argument (good thing btw)
15:10:57 <platz> shlevy: brand new to programming or just fp?
15:11:04 <shlevy> platz: brand new to programming
15:11:06 <chrisdone> using foldl' doesn't stack overflow for obvious reasons
15:11:12 <shlevy> platz: But picking it up very quickly
15:11:23 <Aruro> marchelzo
15:11:24 <fizbin> > let maxi' x [] = x; maxi' x' (x:xs) = if (x' > x) then maxi' x' xs else maxi' x xs; maxi (x:xs) = maxi' x xs in maxi [1...100000]
15:11:26 <lambdabot>  Could not deduce (Control.Lens.Plated.Plated c0)
15:11:26 <lambdabot>    arising from the ambiguity check for ‘e_11100000’
15:11:26 <lambdabot>  from the context (Control.Lens.Plated.Plated c,
15:11:41 <Aruro> is it fast your definition?
15:11:41 <fizbin> > let maxi' x [] = x; maxi' x' (x:xs) = if (x' > x) then maxi' x' xs else maxi' x xs; maxi (x:xs) = maxi' x xs in maxi [1...10000]
15:11:42 <lambdabot>  Could not deduce (Control.Lens.Plated.Plated c0)
15:11:43 <lambdabot>    arising from the ambiguity check for ‘e_1110000’
15:11:43 <lambdabot>  from the context (Control.Lens.Plated.Plated c,
15:11:52 <fizbin> WTF? Plated?
15:11:53 <marchelzo_> Aruro, it works for 256
15:11:58 <chrisdone> lol
15:12:00 <Aruro> how fast?
15:12:03 <Aruro> let me try
15:12:11 <Aruro> fizbin second argument?
15:12:11 <marchelzo_> let maxi [a] = a ; maxi [a,b] = if a > b then a else b ; maxi (x:xs) = maxi [x,maxi xs] in maxi [1..256]
15:12:16 <marchelzo_> > let maxi [a] = a ; maxi [a,b] = if a > b then a else b ; maxi (x:xs) = maxi [x,maxi xs] in maxi [1..256]
15:12:17 <lambdabot>  256
15:12:19 <chrisdone> people's horror at being taken by surprise by lens types makes me laugh
15:12:22 <Aruro> ok
15:12:35 <Aruro> so its not 2^n
15:12:38 <Aruro> definitely
15:12:50 <Aruro> what it is?
15:13:00 <fizbin> chrisdone: Oh, I used "..." accidentally.
15:13:04 <fizbin> let maxi' x [] = x; maxi' x' (x:xs) = if (x' > x) then maxi' x' xs else maxi' x xs; maxi (x:xs) = maxi' x xs in maxi [1..10000]
15:13:12 <fizbin> > let maxi' x [] = x; maxi' x' (x:xs) = if (x' > x) then maxi' x' xs else maxi' x xs; maxi (x:xs) = maxi' x xs in maxi [1..10000]
15:13:13 <lambdabot>  10000
15:13:29 <fizbin> Aruro: That ^^ is probably the fastest.
15:13:43 <Aruro> ok guys ty so much let me write it down and think :D
15:13:43 <eriksensei> shlevy: I quite like PureScript by Example https://leanpub.com/purescript
15:13:45 <fizbin> I think it fits your restrictions, though I find your restrictions kind of odd.
15:13:54 <shlevy> eriksensei: thanks, checking it out
15:13:56 <Aruro> nono they are good :)
15:14:03 <Aruro> im glad you made it :)
15:14:06 <chrisdone> you should read sicp!
15:14:22 <chrisdone> implementing recursive functions so that they are iterative is covered in it
15:14:30 <fizbin> Aruro: That last one I wrote is equivalent to chrisdone's foldl' version.
15:14:44 <eriksensei> if you're going to read sicp, might as well watch some of the video series as well
15:14:51 <fizbin> Or... Maybe. It should be, under a decent optimizer.
15:14:55 <chrisdone> mandatory!
15:14:56 <lpaste> kadoban pasted “crappy recursive maximum” at http://lpaste.net/116829
15:15:00 <platz> shlevy: hard to say, theres the book 'Introduction to Functional Programming using Haskell' by richard bird, but personally for FP in general a course like https://www.coursera.org/course/proglang provides a lot more structure
15:15:07 <kadoban> Aruro: ^ That's my version
15:15:10 <chrisdone> eriksensei: jery sussman in a fez is not to be missed
15:15:31 <fizbin> Maybe I need to use some bang patterns to make it actually equivalent to foldl'...
15:15:38 <eriksensei> chrisdone: that /is/ one of the high points
15:15:47 <shlevy> platz: Yeah but courses are less convenient as a Christmas gift :) Thanks!
15:15:58 <Aruro> ty kadoban!
15:16:03 <chrisdone> @tell Peaker here's me loading lamdu in emacs. it's a talkie! https://www.youtube.com/watch?v=HFZMlgNizuw&feature=youtu.be
15:16:03 <lambdabot> Consider it noted.
15:16:35 <shlevy> Ooooh! LYAH has a print edition
15:17:00 <fizbin> sicp was sort of interesting, but I didn't find scheme stuff that mind-expanding until you got into call/cc and unwind/protect stuff.
15:17:03 <eriksensei> shlevy: yeah, i have it, but it's black and white on the inside though
15:17:15 <shlevy> Aww really? That's a shame
15:17:22 <eriksensei> yeah :S
15:17:41 <Aruro> kadoban and fizbin u used additional 2 argument functions :)
15:17:58 <kadoban> Aruro: You didn't say we couldn't XD
15:17:58 <carter> dfeuer: you solved it?
15:18:26 <Aruro> marchelzo_  got it without :)
15:18:27 <dfeuer> carter, yes! I still have some mistakes in special cases for short sequences (of which there are *way* too many)
15:18:30 <dfeuer> But yes!
15:18:32 <Aruro> let me paste back
15:18:37 <carter> dfeuer: congrats
15:18:44 <carter> you've worked hard and the goal is in sight!
15:18:45 <tasker> what is the current best way to get ghc/etc on ubuntu ?
15:18:52 <carter> tasker: use the hvr ppas
15:18:54 <eriksensei> chrisdone: my goodness, does your keyboard have curly wires?
15:19:04 <tasker> carter: link ?
15:19:09 <shlevy> tasker: nix
15:19:09 <carter> @google hvr ppa
15:19:10 <lambdabot> https://launchpad.net/~hvr/+archive/ubuntu/ghc
15:19:10 * shlevy ducks
15:19:18 <carter> @google multi ghc travis
15:19:18 <lambdabot> https://github.com/hvr/multi-ghc-travis
15:19:52 <dfeuer> carter, could you take a look at it and tell me 1. What you think of the main event (start at apty and follow it to runApState) and 2. How I can handle those short xs in a saner fashion?
15:20:04 <carter> dfeuer: sure
15:20:08 <chrisdone> eriksensei: it's a das keyboard. cherry mx blues :3
15:20:25 <fizbin> Aruro: Okay, fine. Let me see if I can do it with no defined functions...
15:20:33 <Aruro> ty! :)
15:20:40 <Aruro> i would be glad to see something new
15:20:50 <dfeuer> carter, https://github.com/treeowl/containers/commit/6438aa22800889306c2687104a7582e6d6930cf9
15:21:27 <carter> dfeuer: i'll look at it in like 10 minutes
15:21:29 <eriksensei> chrisdone: mesmerizing… i can almost hear the miami vice title music in the background
15:21:32 <carter> need to go outside and rrand
15:21:35 <dfeuer> Cool, carter.
15:21:40 <carter> dfeuer: but seriously, great
15:21:45 <carter> you're now ... an expert!
15:21:55 <dfeuer> Ehhhh.... an apprentice!
15:22:10 <lpaste> Aruro pasted “variableLESS maximum by Marchelzo_” at http://lpaste.net/116830
15:23:15 <kadoban> marchelzo_: Hah, cute.
15:24:00 <marchelzo_> :)
15:24:12 <Aruro> so what i learned that expression max something can not be exactly same twice in recursion :)
15:24:27 <Aruro> cuase that seems to give nasty 2^n
15:24:29 <Aruro> order
15:24:33 <chrisdone> eriksensei: that's a part of american culture i'm not well versed in =p
15:24:53 <Aruro> there can not be exactly same recursive calls in recursion coupled through if
15:25:18 <chrisdone> Aruro: now implement it with fix
15:25:21 <chrisdone> :t fix
15:25:22 <lambdabot> (a -> a) -> a
15:25:24 <Aruro> :D
15:25:27 <chrisdone> :p
15:25:27 <eriksensei> chrisdone: no shame in that ;)
15:26:11 <Aruro> i still think marchelzo_ 's variant teaches a lot vs good but crazy naive case :)
15:26:35 <Aruro> it also looks like double recursion
15:26:54 <Aruro> maxi is used twice on the right side
15:27:10 <chrisdone> huh, let's try this colalborate thing http://haskellstub.com/146052903/
15:27:49 <Aruro> wow looks nice :)
15:28:04 <tasker> carter: on that ppa, I get some error about the publickey not being avaliable. Any idea why ?
15:28:07 <gnusosa> Hi, I don't have a clue about what hierarchy order should a types library be put in Hackage? either Data.Text or another place where types only live in?
15:28:47 <carter> @google hvr ppa github
15:28:48 <lambdabot> https://github.com/hvr/multi-ghc-travis
15:28:55 <carter> tasker: that github repo has some directions
15:28:59 <carter> or debian.haskell.org
15:29:17 <carter> http://deb.haskell.org/
15:29:32 <carter> tasker: woops https://launchpad.net/~hvr/+archive/ubuntu/ghc
15:29:37 <carter> theres direcions ther
15:30:25 * hackagebot concraft-hr 0.1.0.0 - Part-of-speech tagger for Croatian  http://hackage.haskell.org/package/concraft-hr-0.1.0.0 (vjeranc)
15:31:06 <tasker> carter: Hm, so I followed those directions. When I do the sudo apt-get update, I get the error about the ppa's public key not being avaliable
15:31:18 <dfeuer> carter, ah, I have some incorrect size annotations I need to fix.
15:31:26 <carter> tasker: which direcitons?
15:31:34 <dfeuer> This does not surprise me at all.
15:31:42 <dfeuer> But that's a relatively minor issue.
15:31:44 <tasker> on https://launchpad.net/~hvr/+archive/ubuntu/ghc
15:32:04 <dfeuer> Very tedious, but minor.
15:32:06 <erisco> does a type family applied to no arguments count as partially applied?
15:32:08 <Aruro> marchelzo_ what is the order of your algorithm?
15:32:17 <Aruro> im trying to guess but failing :D
15:32:58 <erisco> also, is there a place I can run Haskell code online? I need to test something on 7.8.4 to get my answer
15:33:23 <Aruro> here http://haskellstub.com
15:33:25 <marchelzo_> Aruro, it seems to have the same complexity as the default maximum but with worse runtime
15:33:30 * tasker seems to be this issue: https://github.com/hvr/multi-ghc-travis/issues/5
15:33:34 <tasker> or simiar
15:33:36 <marchelzo_> and that may just be because I'm using it in ghci
15:33:37 <indiagreen> erisco: since GHC 7.8.4 isn't even out yet
15:33:45 <indiagreen> s/since/
15:33:50 <Aruro> default you mean prelude one?
15:33:56 <marchelzo_> Aruro, yes
15:33:57 <Aruro> or the 2^n one?
15:34:02 <marchelzo_> Prelude
15:34:03 <erisco> not officially, but you can still build head
15:34:13 <Aruro> im trying to see that it is no 2^n
15:34:15 <Aruro> but cant
15:34:25 <Aruro> u used maxi twice too on the right side
15:34:29 <erisco> the relevant patch is only in 7.8.4 and I need to know if it will break my code or not
15:34:40 <erisco> else I am just going to run into a brick wall when it released
15:34:59 <Aruro> so if list is one element bigger than how much longer it takes?
15:35:15 <marchelzo_> Aruro, but the first maxi uses a different definition than the second (unless length xs == 2)
15:35:56 <marchelzo_> **maxi** [x, maxi xs], the one with **s is O(1)
15:36:11 <Aruro> mm why?
15:36:16 <Aruro> this im trying to see
15:36:19 <marchelzo_> because of the second pattern match
15:36:28 <Aruro> maxi [a,b] ?
15:36:31 <marchelzo_> yes
15:36:57 <marchelzo_> it's just max but takes its arguments in a list rather than curried
15:37:11 <Aruro> but it will get  reduced to it only after some unfolding?
15:37:17 <gnusosa> Oh no worries. I've found the module layout.
15:37:38 <Aruro> aa
15:37:41 <erisco> Aruro, thanks but it does not appear to be running 7.8.4
15:37:44 <Aruro> u mean there is max hidden inside? :D
15:37:56 <Aruro> sorry erisco did not know that
15:40:13 <Aruro> ok after small thinking
15:40:42 <Aruro> does defining max inside of maxi itself any different from calling extrenal function?
15:40:44 <Aruro> max
15:40:57 <Aruro> in terms of evaluation
15:44:11 <Aruro> so maxi [x,maxi xs] unfolds till the end of list and solves last two elements
15:44:17 <Aruro> lets say it is order n
15:44:21 <Aruro> list length
15:44:38 <Aruro> then we have list of the length n-1
15:44:59 <Aruro> which also should take n-1 to unfold and solve last 2 elements
15:46:03 <Aruro> n+(n-1)+(n-2)+.....+1
15:46:11 <Aruro> ok now i see why its order N :)
15:49:01 <Aruro> actually it is order n(n-1)
15:49:05 <Aruro> or N^2
15:56:47 <mmmm> I wish fixing space leaks didn't feel so good
15:59:44 <dfeuer> mmmm, you're weird.
16:00:26 <dfeuer> But I just solved a problem I've been chewing on for the last *month*, so I feel about as high as a kite right now.
16:01:32 <dfeuer> carter?
16:05:43 <dfeuer> How do you make criterion more aggressive, exactly?
16:06:07 <dfeuer> I mean quickcheck.
16:06:08 <dfeuer> damn.
16:07:26 <carter> ???
16:10:14 <dfeuer> carter, I'm running the containers test suite, and I want it to get real aggressive about testing Data.Sequence.
16:10:23 <dfeuer> (with all tests but my own disabled)
16:10:35 <dfeuer> I don't have a clue.
16:10:48 <dfeuer> Anyway, carter, I *think* I fixed the size annotation issue.
16:12:04 <dfeuer> carter, I just pushed an update that should fix the failures. The remaining big problem is that the cases from 2 to 9 are an unholy mess.
16:37:35 <carter> dfeuer: why does this make me think of fourier transform kinda things?
16:37:46 <carter> i guess its a generalized all pairs convolution
16:38:15 <carter> @google algorithms for outer product
16:38:15 <lambdabot> http://en.wikipedia.org/wiki/Outer_product
16:38:16 <lambdabot> Title: Outer product - Wikipedia, the free encyclopedia
16:38:36 <carter> dfeuer: that might be helpful ?
16:39:07 <dfeuer> Hi carter.
16:39:19 <dfeuer> I have no idea what that means :)
16:39:39 <carter> look at the pictures
16:39:43 <carter> you have two sequences
16:39:49 <carter> youre building ALL pairs
16:39:53 <carter> that line up with eachother
16:40:01 <carter> then laying them down in a fixed ordered
16:40:05 <dfeuer> Yes.
16:40:22 <carter> so this is kinda a dense outer product
16:40:37 <dfeuer> I don't know what a "convolution" is.
16:40:49 <carter> its not a convolution
16:40:56 <carter> (that would rquire beign able to add things)
16:41:25 <dfeuer> But the idea is to use as much as possible of the structure of the two sequences, instead of throwing it away.
16:41:28 <carter> http://en.wikipedia.org/wiki/Outer_product#Definition_.28vectors_and_tensors.29
16:41:44 <dfeuer> Yes, carter.
16:42:07 <dfeuer> I was thinking of it as a Cartesian product, but to a linear algebraist, I could see how it would look like an outer product :)
16:43:10 <dfeuer> Clearly, there are 4 cases: 1, 2-3, 4-9, and everything else.
16:43:23 <dfeuer> The nastiest mess is 4-9.
16:43:45 <carter> the 4-9 bit is to make it more efficient?
16:43:48 <dfeuer> No.
16:43:55 <carter> coudln't you do the splitting trick here too?
16:44:10 <carter> and then interleave the answers?
16:44:12 <dfeuer> The general approach only works for sufficiently deep finger trees.
16:44:26 <carter> ok
16:44:30 <dfeuer> The splitting trick is less efficient.
16:44:42 <carter> because you have to do that merge right?
16:45:01 <carter> so you're doing someting that has less mergin
16:45:07 <gcganley> is there a function that has the same properties as chunksOf but chunks to the right so that the shorter array is on the left
16:45:16 <carter> dfeuer: Q: does the order of the pairs in the result matter?
16:45:22 <dfeuer> Because splitting is O(log n), so tearing things down to singletons is O(n) (okay) but forcing enough thunks to reach a single singleton is O((log n)^2)
16:45:38 <carter> because you could just do the splitting  then concat them back together
16:45:58 <carter> instead of preservering the "row" oriented oridering
16:45:59 <dfeuer> Yes, the order matters. It is expected to be the same as what Data.List gives.
16:46:07 <carter> ew
16:46:09 <carter> thats why its hard
16:46:15 <dfeuer> I don't understand your proposal yet, but it's not acceptable :-)
16:46:30 <carter> have you timed the not order preservering approaches that still give you all the pairs?
16:46:32 <carter> fineee
16:46:36 <dfeuer> carter, have you read through runApState? Isn't it beautiful under the covers?
16:46:41 <mmmm> how can I stop ghc retaining stuff in memory after it is used?
16:47:08 <dfeuer> carter, I have not tried any non-order-preserving approaches in any fashion, because that's a different problem.
16:47:20 <carter> https://github.com/treeowl/containers/tree/ap  this branch?
16:47:21 <dfeuer> A potentially interesting and useful one, yes, but a different one.
16:47:26 <dfeuer> Yes, carter.
16:47:51 <dfeuer> The first *half* of the patch (approximately) is for cases from 2 through 9.
16:49:15 <dfeuer> carter, note that there's a fair bit of flexibility in most of those 4-9 cases--a pretty solution might give slightly different trees.
16:51:15 <carter> i must confess i dont understand this code very welll at all :)
16:51:25 <dfeuer> HMMMMMM
16:51:39 <dfeuer> There are three trees.
16:51:42 <carter> ok
16:51:44 <carter> why 3?
16:51:51 <dfeuer> I'm going to explain.
16:51:55 <carter> OK :)
16:52:10 <dfeuer> There's some redundancy in that, I'm sure, but I'm also sure it's not worth removing :P
16:52:50 <dfeuer> So the first thing that happens is that the tree's spine gets stretched out on the rack (this is called "rigidify")
16:53:07 <dfeuer> Once it gets out of rigidify, it directly represents the structure of a 2-3 tree.
16:53:15 <hodapp> I'm a little confuzzled... I just saw a paper that explained FC (https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/FC) but I don't see it anywhere in the ASCII diagram in https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
16:53:23 <dfeuer> [without the extra flexibility Hinze and Paterson add]
16:54:08 <carter> ok
16:54:25 <dfeuer> Then the main operation of note is "squash". This takes a 2-3 digit and squashes it into the 1-2 digit below it.
16:55:04 <dfeuer> So looking at these three trees, we take a digit off the left side of the leftmost one, and one off the right side of the rightmost one.
16:55:21 <dfeuer> We use those to build a level of finger tree.
16:55:33 <dfeuer> Then we squash down the remaining four digits.
16:55:45 <dfeuer> (the right one of the left side, both in the middle, and the left one on the right side)
16:56:19 <dfeuer> Eventually (and this is where the lower bound on tree depth comes in) we get a tree with exactly two Deep constructors.
16:57:37 <dfeuer> At this point, we take two final digits, turn the middle tree into a 2-3 tree, crush the leftmost and rightmost trees once more, map all the fs over the 2-3 tree,
16:57:57 <greymalkin> Anyone know how to make cabal use a native library other than the main one installed?
16:58:11 <dfeuer> and then do a little nasty (maybe avoidable?) impedence matching so we can glom the bottoms of the trees onto the new middle.
16:58:13 <carter> greymalkin: change the name of the librayr?
16:58:19 <carter> i honestly dont know
16:58:28 <carter> maybe something with linker flags?
16:58:34 <carter> other folks migh tknow though
16:59:21 <dfeuer> carter, if you can figure out a way to make this work at the level of just *one* Deep constructor, and somehow avoid the impedence matching, that would be fantastic.
17:00:34 <dfeuer> carter, does my explanation help any?
17:00:37 <greymalkin> something like "--extra-lib-dirs" but prepending instead of appending.
17:00:40 <carter> why does it have a mismatch?
17:01:02 <carter> greymalkin: you can probably do that via custom setup.hs
17:01:04 <carter> ask ttuegel  :)
17:01:14 <carter> if anyone knows, it'd likely be him :)
17:01:35 <dfeuer> carter, I can't claim to understand it completely. Something about the height of the 2-3 trees compared to the finger trees maybe? This is the way I could get the types to work out.
17:02:04 <dfeuer> Actually, carter, it's possible that there's a deeper reason.
17:02:37 <dfeuer> It might be that sufficiently deep trees *need* the extra |xs| length to stretch properly.
17:05:42 <ttuegel> carter: greymalkin: the only way i know of to do that is a custom setup.hs
17:06:10 <ttuegel> but that's not my subsystem, so don't consider that the final word of authority
17:06:34 <carter> otoh, its not that hard to do with a custom one
17:06:56 <ttuegel> greymalkin: oooh, actually, GHC may have an option for that. you could pass it with --ghc-option=
17:08:34 <greymalkin> ttuegel: Good idea, I'll give that a shot.
17:12:06 <acowley> TIL: I'm glad finger trees are handled by a library
17:12:53 <greymalkin> Actually... my solution was staring me in the face; I had installed the library that needed patching just to develop this... so I take it out and use --extra-lib-dirs
17:14:13 <dfeuer> acowley, you want to help me clean up the code?
17:15:15 <acowley> dfeuer: I've never written finger tree code, and it doesn't look super easy to just jump in to
17:16:12 <dfeuer> That's probably true for most people, acowley. I don't know about ski though.
17:16:35 <dfeuer> BBL; dinner time!
17:19:09 * hexagoxel_ wonders what universal greeting time says about meals
17:27:19 <zRecursive> `ghc -ignore-dot-ghci -e "print 9" -e "import Foo"` will print 9 normally. However, `ghc -ignore-dot-ghci -e "import Money" -e "print 9"` will quit without any output. The same code worked in ghc-7.6.x but not in ghc-7.8.x, why ?
17:27:43 <zRecursive> s/Foo/Money
17:34:04 <Zemyla> @pl \(a,x) (b,y) -> compare (x,a) (y,b)
17:34:05 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (flip (,)) . (((.) . (.) . compare) .) . flip (,))
17:34:33 <joelteon> okay, that much gymnastics is just pointless
17:34:34 <Zemyla> @pl \(a,x) -> (x,a)
17:34:35 <lambdabot> uncurry (flip (,))
17:35:31 <Zemyla> :t comparing $ uncurry $ flip (,)
17:35:32 <lambdabot> (Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
17:39:56 <ReinH> :t swap
17:39:56 <lambdabot> (a, b) -> (b, a)
17:40:10 <ReinH> Apparently pointfree doesn't know about swap
17:40:47 <ReinH> :t comparing swap
17:40:48 <lambdabot> (Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
17:49:38 <alexchandel1> hey haskell people!
17:49:53 <Gurkenglas> @pl \(x,y,z) -> x
17:49:53 <lambdabot> (line 1, column 7):
17:49:53 <lambdabot> unexpected "z"
17:49:53 <lambdabot> ambiguous use of a non associative operator
17:50:01 <Gurkenglas> Aha! It failed!
17:50:27 <alexchandel1> i have a question for type perfectionists
17:50:30 <alexchandel1> What is the correct name for the optional type and its variants?
17:50:37 <alexchandel1>  OCaml, Scala, Standard ML, Swift, and Rust all use Option/Some/None
17:50:44 <alexchandel1> Java and C++ use Optional
17:50:47 <alexchandel1> Haskell uses Maybe/Just/Nothing
17:50:51 <Gurkenglas> Maybe
17:50:52 <alexchandel1> But there is a proposal in Rust to rename it to Maybe/Yes/No
17:51:07 <alexchandel1> which names are *correct*?
17:51:07 <Gurkenglas> :t (Just 5, Nothing)
17:51:08 <lambdabot> Num a => (Maybe a, Maybe a1)
17:51:43 <alexchandel1> Gurkenglas: i know that's what Haskell does, but if we could do it all over again, what should it be?
17:52:44 <Gurkenglas> Assuming that nothing else can be changed, and everyone is changed to remember to have always used that name?
17:53:06 <alexchandel1> yes
17:53:11 <alexchandel1> what is the true name?
17:54:01 <kadoban> alexchandel1: You ask that like "true name" actually has a meaning. I'm not sure what that meaning would be...
17:54:21 <alexchandel1> kadoban: it means what is the *best* name
17:54:40 <alexchandel1> lol this is not a serious conversation
17:54:51 <kadoban> Hehe, okay.
17:54:52 <Gurkenglas> Off the top of my head, we could try to optimize for ease for new people to grok it, aesthetics, brevity, etc. Doesn't sound like there's one true name
17:55:54 <exio4> why don't we call None/Nothing "null", and leave the Just/Some implicit?
17:56:03 <alexchandel1> BTW you don't have to worry about people transitioning from C++/MUMPS/whatever evil unintuitive languages
17:56:36 <alexchandel1> exio4: it still has to be a Sum Type, with two data constructors
17:56:47 <Gurkenglas> exio4, because then you'd have to pattern-match for null in any function
17:57:26 <exio4> I think I should have added an emoticon at the end
17:57:43 <zRecursive> `ghc -ignore-dot-ghci -e "import Data.List" -e "print 9"` still prints nothing. So it doesnot due to my module. Why does "import Data.List" defeat "print 9" in ghc-7.8.x command line ?
17:58:11 <alexchandel1> exio4: CANIHAS?/YAY:)/SAD
17:58:33 <athan> 'E'
17:58:40 <athan> <-
17:58:54 <alexchandel1> Gurkenglas: some people from Rust are saying it should be Maybe/Yes/No, with the analogy that the optional type is a question
17:59:18 <Gurkenglas> Just makes it clear that something is to follow
17:59:18 <exio4> no, it was basically suggesting making everything nullable, and get back what most(all?) mainstream languages have
17:59:36 <exio4> a bad joke, I know!
17:59:41 <alexchandel1> exio4: ahhh nooooooooooooooooooooo! null pointers!
17:59:54 <Gurkenglas> Well, everything is bottomable already anyway.
18:00:10 <exio4> you can't pattern match on bottom though
18:00:10 <alexchandel1> Gurkenglas: yes, we don't have dependent types… :'(
18:00:38 <zRecursive> Would you mind running `ghc -ignore-dot-ghci -e "import Data.List" -e "print 9"` to see result ?
18:00:49 <athan> exio4: you could add like a "death" concept, where pattern matching on None/Nothing is just an error lol
18:00:57 <Gurkenglas> Explain dependent types or if you're lazy recommend a tutorial.
18:01:15 <athan> Gurkenglas: Types depend on values
18:01:27 <athan> learn idris/agda/crytol
18:01:39 <athan> (cryptol did it for me) :P
18:01:40 <alexchandel1> dependently typed programs can be proven to halt at compile time
18:01:49 <alexchandel1> and thus, there is no bottom type, or failure
18:01:54 <athan> alexchandel1++
18:02:37 <exio4> that sounds like a definition of "total" functional programming, didn't know that dependant types implied total functional programming..
18:02:38 <alexchandel1> lol unless you explicitly call failure I suppose
18:02:39 <Gurkenglas> Soo it's undecidable whether a program can be translated into that
18:02:46 <Gurkenglas> *from a different language
18:03:46 <exio4> alexchandel1, I would "to be productive", because codata can be used for "non-halting but productive" programs?
18:03:47 <alexchandel1> Gurkenglas: most programs probably can, but not via any algorithm that also doesn't run them
18:04:04 <exio4> would say*
18:04:22 <alexchandel1> Gurkenglas: the type systems of most languages just aren't powerful enough
18:05:19 <alexchandel1> exio4: sure, explicitly failing is just defining multiple endpoints to your program
18:05:42 <alexchandel1> i don't really like the question analogy though, for Maybe/Yes/No
18:05:50 <alexchandel1> that just feels like it's pandering to noobs
18:06:04 <Gurkenglas> What would you optimize for, then?
18:06:05 <alexchandel1> which never yields a good programming language
18:06:07 <alexchandel1> just look at Java
18:06:43 <alexchandel1> i'm trying to think of what describes it conceptually
18:06:59 <alexchandel1> i think the optional type should be closer to Shape/Circle/Rectangle analogy
18:08:31 <Gurkenglas> Isn't that also pandering to noobs? If you're oldbie enough, you can visualiize it however you choose independently of its naming
18:09:52 <alexchandel1> i'm thinking, there is a type Circle and a type Rectangle. One possible sum of those two types is the Shape
18:09:55 <Hijiri> Idris has bottom
18:10:20 <alexchandel1> But Yes and No aren't really sensical types on their own
18:10:35 <alexchandel1> they could just as easily apply to Either/Yes/No
18:10:50 <alexchandel1> Hijiri: how is it used?
18:11:05 <Hijiri> it can be a result of recursing infinitely
18:11:25 <alexchandel1> that makes sense. but it's not a member of every type is it?
18:11:47 <Hijiri> I'm pretty sure you can do let x = x in x
18:11:56 <Hijiri> or whatever Idris has that is similar to let bindings
18:12:09 <alexchandel1> interesting. can the compiler detect infinite recursion?
18:12:20 <Hijiri> I don't know, probably some forms of it
18:12:39 <Hijiri> but if you could detect it always that would be solving the halting problem, I think
18:13:16 <Hijiri> I know Agda has no bottom because it requires total functions and only allows certain kinds of recursion
18:13:31 <exio4> you can have non-total functions in idris, but you can give the compiler hints that it'll halt
18:13:54 <alexchandel1> Gurkenglas: but consider the type Nothing, and the type Some(T), and a possible sum type Maybe
18:14:38 <alexchandel1> Hijiri: so idris doesn't solve the halting problem… coq?
18:16:45 <Hijiri> isn't the halting problem supposed to be unsolvable in general?
18:16:52 <Gurkenglas> alexchandel1, you mean (), T and Maybe T?
18:17:11 <Hijiri> haltingness is just detectable in some languages because they aren't turing-complete (or lambda calculus complete)
18:18:00 <Gurkenglas> Yep. Whatever this language can do, you can't make a C or Haskell compiler in it.
18:18:16 <alexchandel1> Gurkenglass: exactly, except we need data constructors for () and T
18:18:21 <Gurkenglas> (Wait, no. You can do the C one)
18:18:24 <exio4> you could make a C/Haskell compiler, I would guess
18:18:45 <Gurkenglas> exio4, Haskells type system is lambda-calculus-complete
18:18:48 <alexchandel1> Hijiri: exactly
18:19:04 <exio4> I didn't know Haskell2010 had a type system that powerful
18:19:09 <alexchandel1> Hijiri: in languages that aren't  technically turing complete
18:19:32 <nshepperd> 'generally unsolvable' but there are certainly many decidable programs
18:19:46 <Gurkenglas> Well that's the same in any other language.
18:19:57 <alexchandel1> exio4: most programming languages are lambda complete
18:20:02 <alexchandel1> exio4: *turing complete
18:20:10 <exio4> data Halts = Yes | Maybe | No; halts :: Expr -> Halts
18:20:14 <exio4> alexchandel1, I said type system
18:20:39 <nshepperd> (let x = x in x) provably runs forever, for example
18:20:50 <alexchandel1> Gurkenglas: actually, you can have a compiler for a turing-complete language in a non-turing complete one
18:21:21 <Gurkenglas> alexchandel1, yes, but not one where you can reduce the halting problem to whether a program compiles.
18:22:08 <exio4> what is "lambda calculus complete", by the way?
18:22:28 <Hijiri> can compute anything the lambda calculus can
18:22:31 <c_wraith> I think Church-Turing implies it's the same as Turing-complete
18:22:33 <alexchandel1> Gurkenglas: ?
18:22:35 <Hijiri> same as with turing complete
18:22:52 <exio4> ah, turing machine complete, λ calculus complete, I see
18:22:58 <alexchandel1> isn't that the definition of compiling?
18:23:22 <alexchandel1> Gurkenglas: the proof I saw *did* rely on finite-sized source code files
18:23:27 <Gurkenglas> alexchandel1, you can give me any program with an input and I'll give you a haskell program that compiles iff your program halts
18:24:00 <alexchandel1> well doh, you can't solve the halting problem for turing complete languages
18:24:36 <Gurkenglas> How is that related? Can you rephrase?
18:25:54 <alexchandel1> hah i'm not sure
18:26:02 <exio4> > let collatz = takeWhile (/= 1)  . iterate (\n -> if even x then x `div` 2 else 3*x+1) in collatz 20
18:26:02 <dfeuer> c_wraith, I don't think Church had anything to do with that particular theorem. The Church-Turing thesis is an entirely different sort of thing.
18:26:03 <lambdabot>  [20,3 * x + 1,3 * x + 1,3 * x + 1,3 * x + 1,3 * x + 1,3 * x + 1,3 * x + 1,3 ...
18:26:14 <exio4> > let collatz = takeWhile (/= 1)  . iterate (\nx-> if even x then x `div` 2 else 3*x+1) in collatz 20
18:26:16 <lambdabot>  [20,3 * x + 1,3 * x + 1,3 * x + 1,3 * x + 1,3 * x + 1,3 * x + 1,3 * x + 1,3 ...
18:26:35 <exio4> > let collatz = takeWhile (/= 1)  . iterate (\x-> if even x then x `div` 2 else 3*x+1) in collatz 20 -- now?!
18:26:36 <lambdabot>  [20,10,5,16,8,4,2]
18:26:40 <c_wraith> dfeuer: yes, but that's the one I was referring to. That Turing machines and lambda calculus are equivalent.
18:26:53 <Gurkenglas> Let's try again. There is a program that transforms any c program with an input which halts into a haskell program that compiles, and any c program with an input that doesn't halt into a haskell program that doesn't compile.
18:27:13 <Gurkenglas> (For those latter ones, the compiler won't halt.)
18:27:32 <dfeuer> c_wraith, the Church-Turing Thesis is the philosophical concept that their (identical) computational power is actually the best that can be attained.
18:27:53 <exio4> > let collatz = (== 2) . last . takeWhile (/= 1)  . iterate (\x-> if even x then x `div` 2 else 3*x+1) in collatz 2000
18:27:54 <lambdabot>  True
18:27:57 <dfeuer> No one actually knows if the Church-Turing thesis holds.
18:31:16 <alexchandel1> ahhh snap ok. I'm referring to an Agda program that takes finite-length C source code as an input, and produces a finite executable as an output.
18:31:17 <darkroom> Okay so I have a question if any of you have worked with Yampa is there a standard method of getting input for functional reactive programing??
18:31:36 <darkroom> Because everything i make seems like a shitty hack
18:33:17 <Hermit> lol
18:33:53 <alexchandel1> Gurkenglas: so i guess they're different scenarios
18:39:40 <benzrf> darkroom: i hant used yampa
18:40:08 <benzrf> darkroom: i know that in reactive-banana you can construct an Event t a from an IO-based event dispatcher thingy
18:48:10 <darkroom> benzrf: hum this documentation is very good but the examples are so high level man
18:48:50 <darkroom> benzrf: i want to stay away from reactive-banana as the space and time leaks are really bad
18:48:54 <benzrf> they are?
18:48:56 <benzrf> damn
18:49:14 <darkroom> oh man dude they crush performance let me get you this source
18:49:46 <darkroom> http://haskell.cs.yale.edu/wp-content/uploads/2011/01/leak.pdf
18:49:55 <darkroom> warning that paper is complicated
18:50:02 <darkroom> but arrowized frp is the solution
18:51:24 <benzrf> i misparsed "cs.yale" as Cale
18:51:50 <darkroom> xD
18:54:02 <darkroom> I wish the new haskell verison would come out with a "correct" "haskell aproved" way of making GUIs
18:54:35 <benzrf> that's not part of haskell...
18:54:41 <benzrf> that's an issue of libraries
18:55:11 <kadoban> I should really look into the actual existing GUIs again, see if I can find one I actually can use...
18:57:20 <darkroom> none of the libraries work well together
18:58:03 <dfeuer> darkroom, the Haskell Report is not for that, but you're welcome to put together your own attempt at an integrated GUI thingum for Haskell.
18:58:36 <darkroom> just curious whats the haskell report for? language semanics?
18:59:22 <zRecursive> Can you guys try `ghc -e "import Data.List" -e "print 9"`, thanks ?
19:00:00 <chrisdotcode> darkroom: helm is nice
19:00:10 <darkroom> zRecursive: i got 9
19:00:28 * hackagebot rhythm-game-tutorial 0.0 - Haskell rhythm game tutorial  http://hackage.haskell.org/package/rhythm-game-tutorial-0.0 (FumiakiKinoshita)
19:00:36 <zRecursive> darkroom: Is yours ghc-7.8.x?
19:01:16 <zRecursive> darkroom: I got 9 on ghc-7.6.x but not on ghc-7.8.x ?
19:02:06 <darkroom> i am running 7.6.3
19:02:09 <darkroom> sorry bud
19:02:22 <pavonia> zRecursive: What do you get instead?
19:02:38 <darkroom> chrisdotcode: helm does look nice i will look into it
19:02:40 <zRecursive> pavonia: no any output just quit
19:02:53 <chrisdotcode> darkroom: it's based on elm. last time I checked ,it's still WIP, but it's promising.
19:03:35 <pavonia> zRecursive: Is that import relevant?
19:03:59 <zRecursive> pavonia: `ghc -e "print 9"` => 9, `ghc -e "import Data.List"-e "print 9" => Nothing
19:04:34 * zRecursive i have a bit regret to upgrade to ghc-7.8.x now
19:04:42 <darkroom> chrisdotcode: helm has exactly what yampa is missing thanks man!!!!
19:04:52 * chrisdotcode nods.
19:05:14 <darkroom> zRecursive: seems like ghc is quite unpopular on alot of blogs i read
19:05:27 * hackagebot rhythm-game-tutorial 0.1 - Haskell rhythm game tutorial  http://hackage.haskell.org/package/rhythm-game-tutorial-0.1 (FumiakiKinoshita)
19:06:02 <zRecursive> darkroom: Do you mean haskell is not unpopular ?
19:06:17 <zRecursive> darkroom: Do you mean haskell is unpopular ?
19:06:25 <darkroom> zRecursive: sorry mistyped i mean new ghc
19:06:35 <darkroom> 7.8
19:06:39 <zRecursive> i agree
19:07:25 <pavonia> zRecursive: What happens if you use two -e's with different prints?
19:08:56 <animeshsaxena> Prelude Data.List> :t (fmap (*) (Just 2))
19:08:57 <animeshsaxena> (fmap (*) (Just 2)) :: Num a => Maybe (a -> a)
19:09:02 <darkroom> chrisdotcode: aw man I dont think i will be able to transform the signal type into yampas types
19:09:16 <darkroom> chrisdotcode: helms signal types
19:09:22 <chrisdotcode> darkroom: Why are you using both?
19:09:32 <zRecursive> pavonia: `ghc -e "print 7" -e "print 9"` => 7 \n9
19:09:42 <animeshsaxena> as per the definition if i pass a Maybe it should return a function ...but if i try this i get an error
19:09:43 <zRecursive> pavonia: normal
19:09:44 <animeshsaxena> Prelude Data.List> :t ((fmap (*) (Just 2)) (Just 3))
19:09:49 <darkroom> helm is pretty limited in regards to switching
19:10:25 <pavonia> zRecursive: That's weird
19:10:48 <pavonia> Might be worth a bug report
19:10:48 <darkroom> chrisdotcode: making any complicated game state requires extensive switches
19:11:04 <zRecursive> pavonia: It dues to ghc-7.8.x because it works very well in ghc-7.6.x
19:11:47 <chrisdotcode> darkroom: I'm not too experienced in Helm; but I do know it's initially awesome. I'd recommend taking a look at Elm examples on Elm's site for inspiration about state switching.
19:12:19 <darkroom> chrisdotcode: will do
19:13:11 <hodapp> Hmm, I don't see evancz around here any longer
19:14:26 <chrisdotcode> He might be on #elmlang, or whatever it's called
19:14:39 <chrisdotcode> Either that, or he switched to some dynlang and is ashamed
19:14:59 <hodapp> o_O
19:16:21 <chrisdotcode> darkroom: elm's site has a great pong example, from 0 to 100.
19:16:57 <darkroom> chrisdotcode: on it right now actually :)
19:18:55 <Modius> Anyone know a data structure you'd use to represent something like a "set of cards with possible duplicates" where you can remove/draw one; but have the ability to do a weighted random draw again on the remainder?
19:19:03 <fresheyeball> hello
19:19:19 <fresheyeball> I am dieing over here
19:19:28 <fresheyeball> I have a cabal project that will build and run
19:19:35 <fresheyeball> but wont work in ghci
19:19:45 <Modius> It's almost something you'd do with index lookup on an array then cut out the found item and repeat with new random against array; but that ain't that functional.
19:20:00 <fresheyeball> in ghci it says Could not find module ‘Network.Wai.Application.Static’
19:20:12 <fresheyeball> but cabal build works fine
19:20:15 <fresheyeball> any ideas?
19:20:16 <simon> Modius, sounds like a Data.Map to me?
19:20:37 <Modius> simon:  I don't get how data.map can do this as you can't do a random lookup into it
19:21:08 <Modius> simon:  I mean, a random lookup considering its elements numerically equal.  Or weighted so, if each value is a count of the key
19:21:25 <Modius> simon:  E.g. Map<Card, int> <-- how to get random out of that?
19:21:35 <simon> Modius, you have a point-.
19:22:23 <fresheyeball> anyone
19:22:26 <fresheyeball> I am blocked
19:22:29 <fresheyeball> ?
19:23:36 <pavonia> fresheyeball: Did you start ghci in the base directory of your project?
19:23:53 <fresheyeball> yes
19:24:52 <pavonia> You need to start from the src directory, I guess
19:25:16 <pavonia> or use !cd src
19:25:22 <j201> Modius: it sounds like a multiset/bag
19:25:27 <pavonia> Err, :cd src
19:25:29 <lpvb> is hackage source link broken? I click on the source link under bind and I'm still at the top of the source file
19:25:32 <lpvb> http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#v:-62--62--61-
19:26:47 <simon> Modius, if I've got a [(Card,Weight)] like [(c1,5),(c2,2),(c3,7)], I could draw a random number in the interval [0;5+2+7-1] and then use a BST as a lookup mechanism that is divided across this interval, e.g. draw a random number and at every node in the BST, go left or right depending on which sub-interval it resides within. this leaves the problem of recalculating the interval when removing elements from the interval.
19:27:09 <pavonia> lpvb: Where is that link from? There's a minus missing at the end
19:27:21 <lpvb> pavonia: hoogle
19:27:31 <pavonia> Ah no, it's just my IRC client :/
19:27:45 <pavonia> With the minus it works for me
19:28:22 <Modius> simon:  Yeah, that's the hard part
19:28:29 <Modius> simon:  I mean, recalculating the intervals
19:29:08 <simon> Modius, this is if you want O(lg n) lookups. if you don't, it'd be pretty simple to just use a list. also, it could probably be a [(Card,Weight,Count)] so that one can re-adjust Weight and Count and the presence of a card. you'd get linear lookups, but re-doing the interval when removing cards is straight-forward.
19:29:46 <Modius> simon:  Alternative with the o(lg n) search/tree version is you have to recalculate absolute totals for at least half the tree
19:30:10 <Modius> simon:  However, seems that tree with nodes that had the totals for everything under it, if such a thing could exist, at each non-leaf node, could assist in this.
19:30:40 <simon> Modius, I don't know if BSTs that cover intervals rather than individual elements is commonly solved.
19:30:57 <simon> Modius, I'd probably go with the list implementation to begin with and improve later.
19:31:22 <Modius> simon: Question is if such a thing already exists or could be built out of an existing thing, e.g. a bst type tree that would let you store a total in each non-leaf.
19:31:23 <simon> Modius, https://en.wikipedia.org/wiki/Interval_tree
19:32:00 <simon> err, I'm not sure the use-case in that article is entirely relevant.
19:37:30 <fresheyeball> I'm sorry, I really can't figure this out
19:37:39 <fresheyeball> all the other cabal installed packages work in ghci
19:37:50 <fresheyeball> but ghci can't find Network.Wai.Application.Static
19:38:12 <fresheyeball> it finds Network.Wai.Handler.Warp fine though
19:38:24 <fresheyeball> and they are both installed via .cabal file
19:38:31 <pavonia> Is that Static module a simple Haskell file?
19:38:31 <fresheyeball> cabal build and cabal run work
19:38:58 <fresheyeball> @pavonia I don't know what you mean
19:38:58 <lambdabot> Unknown command, try @list
19:40:04 <simon> Modius, I'm not sure the BST of intervals needs to be rebalanced. perhaps if items are also added to it, but if they're only removed, it will only become O(n) in a very unlikely worst case.
19:40:27 <pavonia> fresheyeball: I thought it might be a .hpc file or so, but apparently it isn't
19:41:24 <fresheyeball> oh
19:41:27 <fresheyeball> never heard of a .hpc
19:41:54 <simon> Modius, I guess even for adding things to the tree, one could add items where it rebalances the tree the most. it'd require some annotation of the tree to know that.
19:46:14 <lpaste> glguy pasted “updatable random indexable structure” at http://lpaste.net/116838
19:46:50 <glguy> fingertrees are a fun way to implement such a thing ^
19:47:29 <Modius> Thanks glguy, simon, I'll look at this updatable/random/indexable too
19:48:13 <chrisdotcode> How many concurrent TCP/Socket/IO connections can the GHC runtime handle at once?
19:48:15 <Modius> glguy:  Did you just write this?
19:48:35 <johnw> chrisdotcode: I would imagine it's limited by the system, more than the GHC runtime
19:48:45 <glguy> yeah i just made the paste
19:49:13 <glguy> trying to rush a bit to finish it before discussion moved on :)
19:49:32 <Modius> glguy: Have to AFK a bit or I'd try it out to make sure it works (at least that it compiles to where I could fix it with my lesser skills)
19:49:33 <chrisdotcode> johnw: So there are no hard bounds on that? Can GHC's behind-the-scenes managing of IO/HTTP match, Node, for example?
19:49:46 <Modius> glguy:  You gotta be semi-famous to have cranked this out that fast :P
19:49:54 <johnw> I would want to say "yes", but I haven't measured it
19:50:47 <chrisdotcode> Sweet. That's good to hear.
19:50:53 <glguy> ha i wish ^_^
19:50:56 <chrisdotcode> I'm trying to serve a whole lot of concurrent static files at once.
20:00:03 <Hijiri> I don't think networking is directly part of the GHC runtime, I think it's provided by the c dependencies in the network package
20:00:06 <Hijiri> I'm not sure though
20:03:25 <dfeuer> carter, would your suggested "out of order" version of <*> even be able to obey Applicative and Applicative/Monad laws?
20:04:23 <chrisdotcode> Hijiri: I think that's correct. I was ranting on twitter a day ago about how's there's no networking facilities in base =/
20:05:25 <chrisdotcode> How can Our Glorious Leader Haskell not even have default networking support?
20:06:46 <daishi> You mean it's not just input <- allTheNetworks?
20:07:21 <dfeuer> chrisdotcode, why would we want networking facilities in base?
20:08:59 <chrisdotcode> dfeuer: You don't consider networking an integral part of a programming language?
20:11:05 <fosterite> chrisdotcode: most of the chips in the world do not have networking (although this may not be true anymore)
20:11:22 <glguy> I'd prefer that the language was able express the concepts needed for networking than to have to have it baked in
20:11:57 <glguy> adding things to base is a good way to keep them from getting updated too quickly
20:12:23 <chrisdotcode> I'm all for 100% purity; but what sort of practical language that wants adoption doesn't allow you to fiddle with HTTP?
20:12:46 <glguy> It just shouldn't be in base, but thatdoesn't mean that library support isn't a good thing
20:12:46 <fosterite> chrisdotcode: C
20:13:09 <chrisdotcode> Pfft.
20:13:30 <dfeuer> chrisdotcode, no I don't consider networking an integral part of a programming language, unless maybe it's a language for programming routers.
20:13:46 <dfeuer> File access is another thing that's not part of a programming language.
20:13:58 <dfeuer> I/O in general.
20:16:29 <carter> dfeuer: i dont like that applicative personally
20:16:30 <carter> i like the ziplists more
20:16:32 <chrisdotcode> I mean, I'm thrilled that Haskell's well-designed enough that networking *can* be a library.
20:17:09 <chrisdotcode> But I don't see how not having the immediate ability to work with sockets is productive to adopters.
20:17:44 <Clint> ...
20:17:51 <dfeuer> carter, ziplist-like things seem to really get to the basics of what an Applicative is, and that's nice, but Seq generally tries to pretend its like a list only better.
20:17:59 <dfeuer> (sometimes better)
20:18:11 <MP2E> Why would you *want* to clout up the language standard and base if you can get equivalent functionality in a library?
20:18:25 <carter> what are the applicative laws anyways?
20:19:05 <dfeuer> carter, there's various things and I have trouble remembering.   pure f <*> x = pure (f x) is a big one.
20:19:21 <fosterite> chrisdotcode: You just need to include Network.Socket. Every language has an equivalent requirement
20:19:25 <chrisdotcode> Clint, MP2E: What are the qualifications for something that SHOULD go in base, then?
20:19:35 <dfeuer> There's a composition law, and a weird reverse-application law,
20:19:35 <carter> i think that equation is wrong
20:19:40 <dfeuer> and I don't remember what else.
20:19:44 <carter> @where typeclassopedia
20:19:44 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
20:20:21 <greymalkin> Okay, I feel dumb -- lazy Bytestring -> bytestring how?
20:20:39 <carter> pure f <*> pure x = pure (f x)
20:20:52 <greymalkin> toStrict... nevermind
20:21:02 <fosterite> :t (<$>)
20:21:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:21:03 <carter> dfeuer: pure f <*> pure x = pure (f x) definitely holds
20:21:07 <dfeuer> Oh yeah, that .
20:21:32 <fosterite> f <$> pure x = pure $ f x -- IIRC
20:21:49 <Clint> chrisdotcode: i don't really care which ghc library package things are shipped in, so i don't know
20:21:56 <carter> dfeuer: pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
20:22:00 <carter> thats the one that breaks
20:22:02 <carter> maybe?
20:22:07 <dfeuer> I dunno.
20:22:08 <carter> dfeuer: or does it?
20:22:13 <carter> theres lots of valid orders
20:22:20 <dfeuer> carter, you haven't told me which order you want.
20:22:39 <dfeuer> But then there's also a Monad instance. Maybe there shouldn't be one.
20:22:45 <carter> yeah
20:22:48 <carter> probably!
20:22:55 <dfeuer> But ... I don't think Data.Sequence is suddenly going to change.
20:23:01 <carter> 7.12!
20:23:05 <carter> major version bumps
20:23:06 <carter> and friends
20:23:13 <dfeuer> Of course, if you decide to generalize edwardk's ropes, you can do what you like.
20:23:22 <carter> if it was ziplist, i bet <*>  would be used more
20:23:33 * dfeuer does not understand these ropes, and the documentation seems just a bit spare.
20:23:38 <chrisdotcode> Can't wait for OverloadedRecordFields.
20:23:40 <carter> dfeuer: linkee?
20:23:54 <carter> chrisdotcode: thats ... not gonna happen till theres a new actor on dr who
20:23:55 <carter> or a year
20:23:56 <dfeuer> @google ekmett rope hackage
20:23:57 <lambdabot> https://hackage.haskell.org/package/rope
20:24:01 <dfeuer> There you go.
20:24:10 <carter> kk
20:24:21 <chrisdotcode> carter: say it ain't so.
20:24:28 <chrisdotcode> carter: it was already in 7.10 HEAD!
20:24:41 <dfeuer> carter, 7.12 is not likely to make the fairly conservative maintainers of containers decide to change the semantics of Seq instances.
20:24:51 <dfeuer> At least not dramatically.
20:25:10 <carter> chrisdotcode: no
20:25:15 <carter> chrisdotcode: it was on a BRANCH
20:25:16 <carter> not head
20:25:25 <carter> unless i'm way out of date
20:25:34 <dfeuer> The big semantic change I'd have liked to see go into containers relates to splitAt, which is too lazy in a very stupid way.
20:26:20 <dfeuer> (it has laziness that has a fairly meaningful efficiency cost but no apparent utility)
20:26:25 <chrisdotcode> carter: I believe you are; that branch was merged, iirc.
20:26:32 <carter> chrisdotcode: nope
20:26:34 <carter> what makes you think that
20:26:40 <carter> i'm pretty sure it hasnt been merged
20:26:52 <carter> and that in fac austin remarked on a reddit thred about this yesterday
20:26:56 <dfeuer> carter, https://github.com/haskell/containers/issues/90
20:26:58 <chrisdotcode> carter: You're right.
20:27:02 <chrisdotcode> Why must you crush me so?
20:27:11 <carter> chrisdotcode: because i am doom and lamda
20:27:17 <carter> *lambda
20:27:56 <dfeuer> carter, any ideas for cleaning up the <*> 4-9 code? Or should I just reconsider it tomorrow?
20:28:08 <carter> sleep is a great problem solving tool
20:28:12 <carter> my sleep has been shit lately
20:28:21 <chrisdotcode> carter: I guess I'm stuck with foo and foo' for at least another year.
20:28:38 <dfeuer> Other good problem solving tools: going hiking, and going out for pizza.
20:28:43 <carter> chrisdotcode: 0th world problems  "i dont have magic syntax"
20:28:49 <carter> :)
20:29:01 <carter> chrisdotcode: i'm told lens has some tempalte haskell that does this automatigclcakly
20:29:35 <dfeuer> I had some of my best ideas on this <*> thing when away from my computer, and without even any paper. But I don't think there are any really new great ideas there; just cleaning.
20:29:53 <carter> dfeuer: i've been a bit out of it this week
20:29:55 <chrisdotcode> By the time I learn enough TH to do that, ORF will be here
20:29:56 <dfeuer> Ah.
20:29:57 <carter> so i'm low on ideas
20:30:00 <carter> chrisdotcode: no
20:30:03 <carter> lens COMES with it
20:30:11 <carter> ask edwardk  or glguy
20:30:16 <dfeuer> carter, maybe you'll be into it tomorrow, after you've slept!
20:30:26 <carter> dfeuer: nah, i neeedddd to ship my shit
20:31:11 <dfeuer> ??
20:31:18 <dfeuer> Ship what shit where?
20:31:24 <chrisdotcode> But lens is huge! I don't need all that bloat in my tiny, precious codebases.
20:31:36 <athan> chrisdotcode: ORF?
20:31:37 <johnw> you could use lens-family then
20:31:46 <chrisdotcode> OverloadedRecordFields
20:31:50 <athan> :O!
20:31:51 <chrisdotcode> My favorite extension.
20:32:00 <chrisdotcode> I dream about using it.
20:32:17 <athan> I need to change my pants
20:32:23 <glguy> Does what?
20:32:50 <chrisdotcode> Allows you to use foo { bar :: F} and qux { bar :: F} in the same program.
20:32:59 <chrisdotcode> Without needing to use bar and bar' to disambiguate.
20:34:49 <glguy> Ah. There's "makeFields" which basically solves thus if you don't mind some lenses
20:35:32 * chrisdotcode minds lenses.
20:35:47 <carter> glguy: yeah, that was what i was thinging
20:35:49 <chrisdotcode> At least lenses that aren't fclabels and require you to basically download the entire platform a second time.
20:36:04 <glguy> Yeah, that's a common misunderstanding
20:36:40 <animeshsaxena> why i get an error on this simple function
20:36:43 <animeshsaxena> elementAt' :: (Integral a) => [a] -> a -> a
20:36:43 <animeshsaxena> elementAt' [] a = 1
20:36:44 <animeshsaxena> elementAt' [a] b = [a] !! b
20:37:09 <chrisdotcode> #lensesforbase
20:37:15 <chrisdotcode> Just kidding.
20:37:50 <animeshsaxena> its a very basic question...just looking for a simple explanation...
20:37:57 <tgeeky> chrisdotcode: eventually, we'll be there.
20:37:59 <chrisdotcode> animeshsaxena: What's your error?
20:38:09 <chrisdotcode> tgeeky: I wouldn't mind something lens-like in base.
20:38:14 <glguy> :t (!!)
20:38:15 <lambdabot> [a] -> Int -> a
20:38:20 <animeshsaxena>     Could not deduce (a ~ Int)
20:38:20 <animeshsaxena>     from the context (Integral a)
20:38:21 <animeshsaxena>       bound by the type signature for
20:38:22 <animeshsaxena>                  elementAt' :: Integral a => [a] -> a -> a
20:38:53 <chrisdotcode> But these guys were giving me stuff for asking why networking isn't in base, so lens will be there in a long, long time ;)
20:39:10 <carter> chrisdotcode: probably because the API needs to get fixed
20:39:18 <carter> the networking libs WORK, but dont WORK AMAZINGLY
20:39:36 <chrisdotcode> carter: it was more "because who needs networking defaultly, anyway?"
20:39:38 <glguy> Getting into base would not help make then better
20:39:41 <chrisdotcode> "just download it"
20:39:47 <glguy> Just make updates slower
20:39:48 <carter> chrisdotcode: no
20:39:59 <carter> its that the more its integerated in, the less you can change it
20:40:03 <animeshsaxena> somehow still i get this erro although the patterns match
20:40:05 <animeshsaxena> Non-exhaustive patterns in function elementAt'
20:40:06 <chrisdotcode> Try this type signature elementAt' :: (Integral a) => [a] -> Int -> a, animeshsaxena
20:40:15 <animeshsaxena> elementAt' [] a = 1
20:40:16 <animeshsaxena> elementAt' [a] b = [a] !! b
20:40:37 <chrisdotcode> :t (!!)
20:40:37 <lambdabot> [a] -> Int -> a
20:40:44 <glguy> [a] only matches a single element list
20:40:46 <chrisdotcode> animeshsaxena: b is *required* to be an integer
20:43:04 <animeshsaxena> single element list??
20:43:15 <animeshsaxena> i thought [a] stood for a list of elements
20:43:35 <glguy> [a,b] matches a two element list, and so on
20:43:41 <chrisdotcode> animeshsaxena: It does, *only* in type signatures.
20:43:44 <chrisdotcode> Not in pattern matches.
20:44:09 <chrisdotcode> In a type sig, [a] means "list of a", in a pattern match, [a] means "the list containing the singleton a"
20:44:18 <chrisdotcode> *the singleton list containing a"
20:44:21 <chrisdotcode> Whatever, semantics.
20:44:24 <johnw> just as the value [1] is a list with one member
20:44:27 <animeshsaxena> ohh....k
21:02:15 <johnw> hmm.. looks like recent haskell-mode completely borked my setup :(
21:06:35 <athan> So a catamorphisms and anamorphisms are generic for any functor? The wikipage on F-Algebras looks like a comonad :s
21:08:12 <athan> ahhh wait, durrrrrrrrrr
21:08:48 <recursion-ninja> Is it bad if I use the Either monad as: Right () or Left goodValue, so I can `sequence [Right (), Right,() Left 5, Left 6]`. This is the behavior I want, but it seems like I might be going about this backwards
21:09:31 <johnw> use Maybe
21:09:31 <Axman6> so you just want Left 5 to be the result?
21:09:35 <c_wraith> recursion-ninja: that seems to be the same as Maybe
21:09:37 <recursion-ninja>  > sequence [Right (),Left "Good Value",Left "Second Good value I will Ignore"]
21:09:42 <recursion-ninja> > sequence [Right (),Left "Good Value",Left "Second Good value I will Ignore"]
21:09:44 <lambdabot>  Left "Good Value"
21:09:53 <athan> hmm
21:09:57 <Axman6> seems like you might want ot use Alternative with Maybe
21:09:59 <recursion-ninja> > sequence [Nothing, Just "Good Value", Just "Second Good value I will Ignore"]
21:10:01 <lambdabot>  Nothing
21:10:05 <athan> why not just index?
21:10:10 <recursion-ninja> not quite the same as Maybe
21:10:26 <recursion-ninja> c_wraith: not quite the same as Maybe
21:10:27 <athan> that seems intentional to me, but the nomenclature is off
21:10:30 <Axman6> > foldr (<|>) Nothing [Nothing, Just "GoodValue", Just "I hope I'm ignored", Nothing]
21:10:31 <lambdabot>  Just "GoodValue"
21:10:36 <athan> recursion-ninja: make your own datatype I say
21:10:46 <athan> nice!
21:11:07 <recursion-ninja> :t (<|>)
21:11:08 <lambdabot> Alternative f => f a -> f a -> f a
21:11:17 <recursion-ninja> :t foldr (<|>)
21:11:17 <lambdabot> Alternative f => f a -> [f a] -> f a
21:11:23 <athan> recursion-ninja: higher-kinded monoid
21:11:35 <athan> used in parsers a lot
21:11:50 <recursion-ninja> athan: hmm never used Alternative before!
21:11:53 <athan> subclass of Applicative
21:12:00 <recursion-ninja> that seems like what I'm looking for
21:12:01 <athan> recursion-ninja: It's good stuff :)
21:13:02 <recursion-ninja> will foldr (<|>) behave will on an infinite list?
21:13:12 <c_wraith> yep
21:13:32 <Welkin> <|> is left-biased
21:13:32 <c_wraith> though only if the inner Monoid instance allows it
21:13:47 <recursion-ninja> > foldr (<|>) $ Just 5 : (repeat Nothing)
21:13:48 <lambdabot>  <[[Maybe Integer]] -> [Maybe Integer]>
21:14:11 <athan> O_o
21:14:38 <Axman6> > foldr (<|>) Nothing $ Just 5 : (repeat Nothing)
21:14:39 <lambdabot>  Just 5
21:14:39 <athan> recursion-ninja: See? It works!
21:14:53 <athan> er wait haha (sorry)
21:15:01 <athan> wow, I really want that show instance
21:15:33 <recursion-ninja> athan: Sweet, exactly what I was looking for
21:16:00 <athan> :)
21:18:08 <carter> TallerGhostWalt: engineering is hardddd
21:21:03 <ReinH> carter: let's go shoping
21:21:10 <ReinH> s/shoping/shopping
21:21:26 <carter> ReinH: i'm really sad that i'm adding a function with the following type to my type class
21:21:41 <carter>     basicUnsafeAddressAsInt :: (address ~ LayoutAddress form)=>
21:21:41 <carter>         form ->  address -> Int
21:21:43 <carter> so sad
21:21:54 <ReinH> hahaha
21:22:08 <carter> the default impl is: error "you did shit wrong, now look where you are"
21:22:19 <carter> actually, i'll probably put a nicer message in
21:22:21 <carter> but the point stands
21:22:45 <carter> only the most basic instances will ever do anything
21:22:51 <carter> i just dont think its worth making it its own class
21:35:28 * hackagebot http-client-streams 0.1.0.0 - http-client for io-streams supporting openssl  http://hackage.haskell.org/package/http-client-streams-0.1.0.0 (DavidJohnson)
21:57:42 <zRecursive> @wn pointless
21:57:43 <lambdabot> *** "pointless" wn "WordNet (r) 3.0 (2006)"
21:57:43 <lambdabot> pointless
21:57:43 <lambdabot>     adj 1: not having a point especially a sharp point; "my pencils
21:57:43 <lambdabot>            are all pointless" [syn: {pointless}, {unpointed}] [ant:
21:57:43 <lambdabot>            {pointed}]
21:57:45 <lambdabot> [5 @more lines]
21:58:08 <zRecursive> @more
21:58:08 <lambdabot>     2: serving no useful purpose; having no excuse for being;
21:58:08 <lambdabot>        "otiose lines in a play"; "advice is wasted words"; "a
21:58:08 <lambdabot>        pointless remark"; "a life essentially purposeless";
21:58:08 <lambdabot>        "senseless violence" [syn: {otiose}, {pointless},
21:58:08 <lambdabot>        {purposeless}, {senseless}, {superfluous}, {wasted}]
21:59:25 <fresheyeball> another question if anyone is out there
21:59:41 <fresheyeball> how can I issue a GET request from haskell?
22:03:09 <fosterite> fresheyeball: there is an HTTP package
22:03:17 <fosterite> @google hackage HTTP
22:03:18 <lambdabot> http://hackage.haskell.org/package/HTTP-4000.2.8
22:03:18 <lambdabot> Title: HTTP: A library for client-side HTTP | Hackage
22:03:34 <fresheyeball> oh duh
22:03:42 <fresheyeball> for some reason I didn't think to look there
22:03:50 <fresheyeball> I was googling around for wai and warp
22:04:00 <johnw> wreq is probably a better way to do it than HTTP
22:04:10 <johnw> HTTP is lower-level
22:04:13 <fresheyeball> wreq?
22:04:17 <johnw> http://hackage.haskell.org/package/wreq
22:05:20 <fresheyeball> I am using wai and warp
22:05:25 <fresheyeball> does it make sense to use wreq?
22:05:28 * hackagebot http-client-streams 0.1.0.1 - http-client for io-streams supporting openssl  http://hackage.haskell.org/package/http-client-streams-0.1.0.1 (DavidJohnson)
22:05:33 <johnw> in that case, http-client
22:05:48 <recursion-ninja> Do you guys know of a nice way I can cons an element to the head of a list like so: (Monad m0, Monad m1) => a -> m0 (m1 [a]) ->  m0 (m1 [a])
22:06:23 <johnw> foo a = liftM (liftM (a:))
22:06:30 <glguy> Which version of LLVM does GHC support for codegen?
22:06:55 <recursion-ninja> johnw: I was hope for a pointfree way...
22:07:11 <recursion-ninja> :p liftM (liftM (a:))
22:07:28 <recursion-ninja> @pf \a -> liftM (liftM (a:))
22:07:28 <lambdabot> Maybe you meant: pl bf
22:07:42 <fosterite> :t liftM . liftM . (:)
22:07:43 <recursion-ninja> what;s the lambdabot pointfree converter?
22:07:43 <lambdabot> (Monad m1, Monad m) => a -> m (m1 [a]) -> m (m1 [a])
22:08:22 <dv-> it just told you
22:08:29 <fosterite> @pl liftM (liftM (a:))
22:08:30 <lambdabot> fmap (fmap (a :))
22:08:31 <glguy> If you have to ask lambdabot how to write something like that it's a clue that you shouldn't put it in your file ^_^
22:09:26 <chrisdotcode> Can we do anything about google giving old hackage packages first?
22:09:45 <johnw> I think that would require haskell.org generating whatever that XML file is called
22:09:55 <chrisdotcode> Too many times I've gotten an older version of a lib from a google search, and it's almost bit me a lot of times.
22:09:58 <chrisdotcode> johnw: Sitemap?
22:10:01 <johnw> yeah
22:10:05 <johnw> exactly
22:10:22 <chrisdotcode> johnw: Where can I volunteer?
22:10:27 <johnw> #haskell-infrastructure
22:10:29 <fosterite> if you google `haskell geometric algebra' you get a link to algebra-0.6.0
22:10:40 <fosterite> current version is 4.something
22:10:46 <chrisdotcode> yeah, it's annoying.
22:12:38 <sivteck> (DDG links to the latest page mostly)
22:16:07 <chrisdotcode> What's the deal with unclickable documentation on hackage?
22:16:11 <chrisdotcode> Like http://hackage.haskell.org/package/HTTP-4000.2.19
22:16:27 <chrisdotcode> But the 2.18 has it clickable.
22:16:35 <chrisdotcode> Did sombody forget a flag or something?
22:16:44 <chrisdotcode> --haddock-hyperlink-source ?
22:17:09 <glguy> That package was updated today
22:17:23 <glguy> docs still have to be generated for it
22:17:55 <chrisdotcode> Ah, so it's on a cron, as opposed to a fag.
22:17:57 <chrisdotcode> *flag
22:18:16 <chrisdotcode> Is there any benefit to that at all, glguy?
22:18:26 <glguy> to what?
22:18:44 <chrisdotcode> Generating docs on a cron - as opposed to when they're uploaded?
22:18:59 <glguy> Yeah, its so that it gets done
22:19:09 <glguy> stuff's getting built all the time, there's a queue
22:19:40 <chrisdotcode> I'm assuming it would take up too much CPU/RAM if they were all done as uploaded and/or block until a single one is finished.
22:19:45 <Axman6> is that true? it used to be the case that the job was run every few hours
22:19:55 <glguy> The maintainer can upload docs manually if they want them up quickly
22:20:21 <chrisdotcode> It would be better to decrease the amount of concurrent connections if it meant generation documentation immediately, IMO.
22:20:26 <chrisdotcode> *concurrent uploads
22:20:46 <glguy> Just click back a minor version
22:21:31 <chrisdotcode> The risk of course being, using deprecated/deleted code.
22:21:51 <glguy> If you're super risk adverse you can look in your local doc install
22:22:25 <fosterite> you can still browse the source of 2.19
22:22:28 <chrisdotcode> Which I've done, but takes forever and a half.
22:31:31 <Welkin> I wonder if there is a way to do this without pattern matching using a recursive function
22:31:56 <Welkin> > split (startsWith [Just {..}]) [Just 4, Nothing, Nothing, Just 2, Nothing]
22:31:58 <lambdabot>  Illegal `..' in record construction
22:31:58 <lambdabot>  Use RecordWildCards to permit this
22:32:24 <jle`> what is "this"
22:32:26 <jle`> ?
22:32:33 <Welkin> I want to split a list based on a constructor
22:32:44 <Welkin> I'm actually working with the Pandoc type
22:32:49 <Welkin> so this list is [Block]
22:33:12 <Welkin> I want to split it on Heading
22:33:14 <jle`> ah yeah. when i worked with pandoc i couldn't really avoid writing isBlock etc..  but i think this is a problem that prisms solve
22:33:44 <Welkin> any idea how I could do this?
22:35:28 <Welkin> [Heading, Paragraph, Paragraph, Heading, Paragraph, Paragraph, Heading, Paragraph, Paragraph] should become [[Heading, Paragraph, Paragraph], [Heading, Paragraph, Paragraph... etc]]
22:38:59 <Axman6> sadly haskell doesn't have first class records, but Lam,bdaCase (or whatever it's called) would allow you to write )\case Just _ -> True; _ -> False)
22:39:46 <fosterite> idris has isJust in the prelude, but haskell doesn't appear to
22:39:50 <Axman6> uh, first class patterns
22:39:56 <glguy> :t Data.Maybe.isJust
22:39:57 <lambdabot> Maybe a -> Bool
22:39:58 <Axman6> isJust is in Data.Maybe
22:40:52 <glguy> When you're pattern matching you can use empty record patterns even with non-records, so you can match Heading with:   Heading{}
22:41:01 <glguy> so you don't have to know what fields it has
22:41:06 <jle`> if your type has prisms, then you can use the prism stuff
22:41:16 <jle`> to get free isJust, isHeading, isParagraph, etc.
22:41:58 <glguy> is _Just :: Maybe a -> Bool
22:43:29 <Welkin> > fmap (splitAt 1) $ split (dropInitBlank . keepDelimsL . whenElt $ isJust) [Just 4, Nothing, Nothing, Just 0, Nothing]
22:43:30 <lambdabot>  [([Just 4],[Nothing,Nothing]),([Just 0],[Nothing])]
22:43:33 <Welkin> this does what I want
22:43:45 <Welkin> I suppose I'll need to write an isHeading function
22:46:46 <jle`> :t maybe False (const True)
22:46:47 <lambdabot> Maybe a -> Bool
23:04:56 <fProgrammer_> quick question: How do I recursively find all files in a given directory, like os.walk in python.. getDirectoryContent has depth = 1
23:06:39 <Fuuzetsu> no such function in base
23:07:06 <Fuuzetsu> I'm sure all of us here wrote it at least 5 times each though
23:07:19 <apo> I didn't
23:07:32 <apo> but then again I only took a haskell course at uni and never did much with it :p
23:09:53 <Fuuzetsu> you're still here so not all hope is lost yet
23:10:28 * hackagebot cndict 0.4.6 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.4.6 (DavidHimmelstrup)
23:15:28 * hackagebot crypto-pubkey 0.2.6 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.2.6 (VincentHanquez)
23:31:01 <jle`> apo: i think it might be in a chapter of RWH
23:31:03 <jle`> or LYAH
23:31:30 <jle`> er, fProgrammer_
