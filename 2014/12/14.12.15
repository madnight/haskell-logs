00:00:27 <lykos_> I tried using T.pack "Escape", but it gave "No instance for (glib-0.13.0.6:System.Glib.UTFString.GlibString
00:00:27 <lykos_>                        string0)
00:00:28 <lykos_>       arising from a use of ëtextBufferTextí
00:00:28 <lykos_> "
00:00:44 <lykos_> I tried using stringToGlib earlier, but it gave another error
00:01:34 <indiagreen> what error?
00:01:47 <indiagreen> also, it seems that you
00:01:52 <indiagreen> ouch
00:02:04 <indiagreen> ...that you're cutting the error messages
00:02:24 <indiagreen> would be more helpful if you didn't
00:02:41 <lykos_> sure thing, sorry about that.
00:02:58 <lykos_> This is the error stringToGlib gives:
00:03:03 <lykos_> No instance for (GlibString string0)
00:03:03 <lykos_>       arising from a use of ëtextBufferTextí
00:03:03 <lykos_>     The type variable ëstring0í is ambiguous
00:03:03 <lykos_>     Note: there are several potential instances:
00:03:03 <lykos_>       instance GlibString text-1.2.0.3:Data.Text.Internal.Text
00:03:04 <lykos_>         -- Defined in ëSystem.Glib.UTFStringí
00:03:06 <lykos_>       instance GlibString [Char] -- Defined in ëSystem.Glib.UTFStringí
00:03:30 <lykos_> for a different line though, 89:31
00:06:06 <indiagreen> this one seems to arise 'cause ¬´get¬ª and ¬´clipboardSetText¬ª are both too smart and can deal with various types of strings
00:06:22 <indiagreen> and so it's unclear which type to actually use
00:07:05 <lykos_> makes sense. Is there some way to set a default glib string for the scope of the program?
00:07:12 <lykos_> I'm super rusty, thanks for the help :)
00:07:15 <indiagreen> you can replace ¬´txt¬ª with ¬´(txt :: String)¬ª on line 91
00:08:55 <indiagreen> I think there's no way to set the default type, because of the limitedness of Haskell's ‚Äúdefault‚Äù declaration (it only works for Prelude numeric classes)
00:09:37 <lykos_> It compiled and is running now! It's refreshing to see this old code.
00:09:45 <lykos_> Do you think this is the best way to do it, currently?
00:10:08 <lykos_> using stringToGlib and forcing the String datatype for txt?
00:10:54 * hackagebot http-client 0.4.6.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.6.1 (MichaelSnoyman)
00:10:54 * hackagebot boolsimplifier 0.1.8 - Simplification tools for simple propositional formulas.  http://hackage.haskell.org/package/boolsimplifier-0.1.8 (GershomBazerman)
00:10:55 <indiagreen> if you had lots of string constants like "Escape", using OverloadedStrings would've made sense
00:12:10 <lykos_> how would I do that?
00:12:16 <indiagreen> hm, except that then all the declarations in the beginning ("newKeypairButton", etc.) would suddenly become ambiguous
00:12:53 <lykos_> hmm
00:13:56 <indiagreen> the weird thing, actually, is that keyName returns a Text instead of any string, which doesn't align with builderGetObject and other functions
00:14:18 <indiagreen> if it was like builderGetObject, you wouldn't need stringToGlib
00:15:12 <indiagreen> in your place I'd be satisfied with the current situation
00:15:56 <indiagreen> it's a bit inelegant, sure, but I don't see a way to make it better
00:16:08 <TyrfingMjolnir> How can I make an array/dictionary of pointers to repeating substrings in a string?
00:16:10 <lykos_> I have another program that has a lot more strings I'd have to convert to Glib, so I'll try overloading the strings and see if it works, but otherwise thanks a lot :)
00:16:21 <lykos_> Man, it's been awhile since I've looked at Haskell.. I miss it.
00:16:27 <TyrfingMjolnir> Let's say I would like to know ptr + length for all repeating substrings in string longer than n chars
00:17:12 <indiagreen> lykos_: to enable OverloadedStrings, just put ‚Äú{-# LANGUAGE OverloadedStrings #-}‚Äù on top of the file
00:18:56 <indiagreen> however, if it results in lots of ambiguity and all your strings are keyName comparisons, it might be better to make your own version of keyName which returns String
00:19:42 <indiagreen> (by importing the actual keyName qualified and saying something like ‚ÄúkeyName = glibToString . Keys.keyName‚Äù)
00:20:32 <lykos_> makes sense. Overloaded strings did add way too much ambiguity, so I'll stick with stringToGlib, and make a utlity keyName function for it if needed
00:20:38 <lykos_> works well though... thanks again
00:20:46 <lykos_> It's so nice working on Haskell code again!
00:41:16 <stillwater> Hello I've been going through 'Fold' from the FPComplete Tutorial
00:41:24 <stillwater> and it makes zero sense to me
00:41:34 <stillwater> https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell/4-higher-order-programming-and-type-inference
00:41:47 <stillwater> Is there a better resource to study abt fold ?
00:42:57 <calvinx> what does the ‚Äú()‚Äù denote in ‚ÄúhttpBasicAuth :: Handler ()‚Äù (reference http://stackoverflow.com/questions/12128474/basic-http-auth-in-yesod/12200382#12200382) ?
00:44:24 <opqdonut> calvinx: it's the unit type
00:44:40 <opqdonut> calvinx: basically in this situation it means "doesn't return anything"
00:44:57 <opqdonut> :t putStrLn -- another example
00:44:58 <lambdabot> String -> IO ()
00:45:35 <calvinx> ok
00:47:36 <calvinx> I see. So I see the main examples with code snippets that do return Html, of the form ‚ÄúgetStuff :: Handler Html‚Äù.
00:48:19 <calvinx> And if I want to return Json, I should say ‚ÄúgetStuff :: Handler Value‚Äù yes?
00:49:25 <calvinx> Or as a continued question, what‚Äôs the difference between ‚ÄúHandler ()‚Äù and ‚ÄúHandler Value‚Äù ?  (reference http://pbrisbin.com/posts/writing_json_apis_with_yesod/)
00:50:00 <opqdonut> a "Handler Value" is an action in the Handler monad that produces a Value
00:50:03 <calvinx> ‚ÄúHandler Html‚Äù is clear enough. But when ‚Äú()‚Äù and when ‚ÄúValue‚Äù ?
00:50:15 <opqdonut> a "Handler ()" is an action in the Handler monad that doesn't produce anything, or rather just has side-effects
00:50:49 <opqdonut> I'm not familiar with yesod unfortunately so I can only help you with the general stuff
00:51:20 <opqdonut> but it looks like the GET handler returns a Value, because some data needs to be sent back to the client
00:51:35 <calvinx> that‚Äôs kind of strange. my understanding with REST is that it should always return something, even if just a json containing a message stating error. Why would I ever need ‚ÄúHandler ()‚Äù?
00:51:58 <opqdonut> whereas the POST handler just produces the 201 status and no data / value
00:52:21 <Welkin> calvinx: to return a response code
00:52:29 <calvinx> ok. that‚Äôs a fair conclusion. thanks!
00:52:48 <calvinx> () if only returning response code and no other json data/value, Value if returning json data.
00:53:09 <Welkin> and Html when it is Html
00:55:15 <slop> Hi, I'm trying to run my ncurses game with ghci. I am unable to get it to load everything in the top level of the module. The prompt says "Prelude Main" where it would normally say "*Main". Does anyone have any ideas on how to load everything from my module?
00:55:51 * hackagebot pregame 0.1.3.0 - Prelude counterpart  http://hackage.haskell.org/package/pregame-0.1.3.0 (jxv)
00:56:26 <Welkin> use :l Main.hs
00:56:39 <Welkin> as long as Main imports everything it needs, it should run fine
00:56:51 <tdammers> not deeply familiar with Yesod myself either, but my guess is that its Handler monad works such that you can use it to get stuff from the request and do all sorts of stateful things; and then at some point, you're expected to call some function that takes a Response and returns Handler ()
00:56:59 <shachaf> slop: It sounds like some of your code is already compiled and ghci is using that.
00:57:12 <tdammers> but again, I don't know if that's what Yesod does
00:57:15 <shachaf> slop: Try deleting the compiled code (Main.hi, Main.o) and seeing if that fixes it.
00:57:22 <tdammers> (not without looking it up anyway)
00:57:56 <Welkin> yes, Handler is a synonym
00:57:58 <Welkin> type Handler = HandlerT App (ResourceT IO)
00:58:23 <slop> Thanks shachaf!
00:58:28 <slop> It worked!
00:58:42 <shachaf> slop: This is enough of a gotcha that a bug report about it might not be a bad idea.
00:59:00 <shachaf> E.g. to have ghci print "reusing compiled output ...".
00:59:02 <shachaf> Or something.
01:03:22 <lpaste> stillwater pasted ‚Äúhaskell tut‚Äù at http://lpaste.net/116508
01:03:43 <favetelinguis> haste can find haste-boot on windows, it is not in the bin folder?
01:03:56 <favetelinguis> *can not
01:10:12 <calvinx> I have ‚Äúhttp-client‚Äù installed, but some how, when I try to run my app, I am getting ‚ÄúCould not find module ‚ÄòNetwork.HTTP.Client‚Äô, It is a member of the hidden package ‚Äòhttp-client-0.4.2.2‚Äô.
01:10:23 <calvinx> I have to manually modify my project
01:10:31 <calvinx> ‚Äôs .cabal file?
01:10:51 * hackagebot lifted-base 0.2.3.3 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.3.3 (BasVanDijk)
01:12:42 <calvinx> yup. looks like it.
01:14:43 <steffen> How do I sort a Vector from Data.Vector (sortWith would be even MUCH better)
01:16:24 <quchen__> steffen: Have you seen vector-algorithms?
01:16:29 <quchen__> @hackage vector-algorithms
01:16:29 <lambdabot> http://hackage.haskell.org/package/vector-algorithms
01:18:32 <elfeck> hello, I'm using Haskell Mode. Can someone tell me if there is a convinient way to load all source files into the repl? I hate editing one file, switch to my example file, switching back
01:21:08 <steffen> quchen__: yes I'm looking at it, but I'm not sure whether I can apply this to an immutable vector
01:21:25 <slop> shachaf: bug report submitted, thanks again for the help.
01:21:50 <shachaf> slop: whoa
01:23:38 <favetelinguis> elfeck: what do you mean by all?
01:24:15 <favetelinguis> c-c l loads you project with you includes?
01:25:03 <elfeck> I was using C-C C-l to load buffer into repl
01:25:06 <mhall> hey, could someone recommend me a good vector math library? (like the glm c++ library for opengl math)
01:25:23 <elfeck> but if I'm editing a file which is not a "test-file" I need to switch around all the time
01:25:33 <elfeck> I would like to just load _everything_ into the repl
01:26:05 <mhall> i'm looking at vect-floating right now if that's any good?
01:26:17 <quchen2> steffen: Are you familiar with mutable vectors? You'd use this library by making your vector mutable, sorting it, and then freezing it again.
01:26:59 <quchen2> steffen: PrimMonad is IO/ST combined under one class, if that helps.
01:27:41 <favetelinguis> mhall: https://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
01:28:59 <steffen> quchen2: So I can not sort a Vector in pure code? (non-monadic code)
01:29:52 <mhall> favetelinguis: well i'm looking for something with 3d-math functions like dots/crosses, etc
01:30:22 <jle`> mhall: linear has some things like that
01:30:54 <jle`> steffen: you can sort a vector
01:31:10 <jle`> steffen: it's just that an in-place sort requires vector mutation
01:32:23 <t4nk328> @pl foo x = sum x `div` length x
01:32:23 <lambdabot> foo = liftM2 div sum length
01:32:49 <jle`> steffen: you can describe an algorithm involving vector mutation with different types
01:33:07 <jle`> that is, there are types that act as sort of AST's that can describe algorithms using vector mutations
01:33:14 <jle`> this doesn't really have anything to do with monads
01:33:33 <jle`> you can write a function Vector -> TypeDescribingAMutableAlgorithmToProduce Vector
01:34:12 <jle`> take a vector and return a value of a type that contains algorithms to produce a sorted vector using mutation
01:34:28 <jle`> the vector-algorithms library basically allows you to parameterize over that type
01:34:36 <jle`> Vector -> t Vector
01:34:52 <jle`> so that *any* type that can be used to describe a mutable algorithm producing a vector can work
01:35:44 <steffen> jle`: Thakns for your elaboration, I'm looking into it
01:36:08 <jle`> so, it's not a "monad" that you're looking for
01:36:37 <jle`> it's just any type that has the ability to "describe" an algorithm involving mutation
01:36:57 <jle`> because remember, hasell is pure, so Vector -> AlgorithmInvolvingMutationProducing Vector is a pure function from a Vector to an Algorithm
01:37:06 <jle`> that's kind of how we roll
01:37:51 <steffen> jle`: makes sense, now I only have to figure out how to use it. I guessed there would be something like runMutation but I could not yet find something like that :)
01:37:52 <jle`> there are two types that can describe the algorithms that vector-algorithms offers
01:38:00 <jle`> one is IO, the other is ST
01:38:24 <jle`> you can probably imagine more, but those are the ones they are probably imagining you using
01:40:24 <favetelinguis> Im playing around with a differentiate function that need to be able to differentiate my Expr type but im to bad at math to figure out how to get it working, would be glad for some help http://lpaste.net/116510, trying to get these rules working https://en.wikipedia.org/wiki/Derivative#Rules_for_combined_functions
01:41:08 <jle`> actaully i'm looking at the function again, it actually doesn't take a vector, it takes a "pointer"/reference to a vector in memory.  so it's really a function PointerToVector -> Algorithm (), where the algorithm will mutate the vector found at that pointer/reference
01:41:24 <jle`> again, it's parameterized over the algorht-describing type
01:43:26 <thebnq> is it possibly safe to unregister a package installed via the haskellplatform
01:45:08 <steffen> jle` I kind of got it, but I can't find out how to use it. The PrimState is confusing me
01:45:50 <jle`> yeah, i could try explaining it to you, but i think this is something that is just best done using an example
01:45:53 * hackagebot rncryptor 0.0.2.1 - Haskell implementation of the RNCryptor file format  http://hackage.haskell.org/package/rncryptor-0.0.2.1 (AlfredoDiNapoli)
01:45:55 * hackagebot hspec-server 0.1.0.0 - Test Framework for Server's status  http://hackage.haskell.org/package/hspec-server-0.1.0.0 (junjihashimoto)
01:45:57 * hackagebot handa-gdata 0.7.0.2 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.7.0.2 (RyanNewton)
01:46:10 <jle`> *shown
01:46:27 <steffen> jle`: Let's say we have a Data.Vector.Vector of Intergers, how would we go ahead and sort it
01:46:36 <jle`> it's sort of actually a type system hack, but it's not very well documented in how to work with it
01:46:48 <jle`> steffen: you'll need to convert it into a mutable vector
01:47:02 <jle`> that is, into a pointer to a vector with mutation api
01:47:19 <quchen2> steffen: Monads and purity are orthogonal to each other.
01:48:04 <quchen2> You can easily write a wrapper that has the type "mySort :: Vector -> Vector", which internally uses the functions provided by vector-algorithms.
01:49:29 <jle`> if you wanted a pure Vector -> Vector, then you can go about it by using ST as yor type that encodes the algorithm
01:49:40 <jle`> so ST is your PrimMonad
01:50:08 <steffen> quchen2: ok
01:50:11 <jle`> you would use thaw :: Vector a -> ST (MVector (PrimState ST) a)
01:50:42 <jle`> and then you would use sort :: (MVector v e, Ord e) => v (PrimState ST) e -> ST ()
01:50:50 <jle`> hm
01:50:58 <jle`> sort :: MVector (PrimState ST) e -> ST ()
01:52:10 <trap_exit> yo yo yo ; what's a good tutorial on how to implement parsec in haskell ?
01:52:13 <quchen2> sortVector v = do { v' <- thaw v; sort v'; unsafeFreeze v' }
01:52:18 <quchen2> Something along those lines
01:52:28 <jle`> and then you'd use freeze :: MVector (PrimState ST) a -> ST (Vector a)
01:52:31 <trap_exit> yo yo yo ; what's a good tutorial on how to implement parsec in haskell ? // pls answer in rap form
01:52:49 <shachaf> Why would you do that?
01:53:11 <jle`> unsafeFreeze'd probably work here too and better
01:53:23 <steffen> jle`: Thank you so much, let me try to get this working, Ill tell you later how it went :)
01:53:36 <jle`> from that all, using the do block that quchen2 offered to put this all together, you'd get an ST (Vector a)
01:53:37 <thebnq> trap_exit: its already in haskell? yo?
01:53:53 <shachaf> What I mean is, why would you use unsafeFreeze when there's a safe wrapper for doing exactly that operation?
01:53:56 <shachaf> (modify)
01:54:22 <jle`> :O
01:54:47 <jle`> this changes everything
01:55:26 <jle`> i guess doing it the manual way would help with an understanding of ST and what `copy` actaully does/its intent
01:55:44 <jle`> but yeah, modify sort :: Ord e => Vector e -> Vector e
01:55:50 <jle`> which is just what you wanted steffen
01:55:54 <jle`> ty shachaf
01:57:11 <jle`> to continue on with the previous chain of thought, binding and composing all of those functions will get you an ST (Vector a), a type encoding instructions for producing a Vector a.  Then you can run those instructions purely by using runST.  and then you basically get what `modify` does
01:59:11 <steffen> jle`: Thank you very much for your help :)
01:59:14 <trap_exit> yeah
01:59:18 <trap_exit> but I want to learn how to impelment aprsec
01:59:20 <trap_exit> not just use parsec
01:59:21 <trap_exit> duh
01:59:33 <jle`> i liked that chalmers series
02:01:50 <jle`> http://www.cse.chalmers.se/edu/year/2013/course/TDA452/FPLectures/Vid/
02:04:21 <jle`> steffen: np :)  this was stuff i wish i had someone to help me figure out when i was firs tworking with
02:07:26 <steffen> jle`: Its very kind of you, I'll use the cheap method with modify for now because I have to get done with this, but later I'll think though the one with the state monad
02:07:57 <jle`> it's actaully the ST type, a bit different from the State type. just so you know what to google :)
02:17:59 <Athas> Hey, does anyone know how GHC sets the locale (and importantly, the encoding/decoding options derived from it)?  I'm getting unexpected results on OpenBSD.
02:22:01 <Flonk> How do people even come up with this - https://www.haskell.org/pipermail/haskell-cafe/2008-February/039007.html
02:26:11 <thebnq> haha hes great
02:28:21 <trap_exit> typed sql statements <-- is this not possible ?
02:30:09 <jle`> it's a whole other order
02:30:54 * hackagebot hasql-backend 0.2.2 - API for backends of "hasql"  http://hackage.haskell.org/package/hasql-backend-0.2.2 (NikitaVolkov)
02:39:10 <elfeck> can someone help me out with a function that gives (subsetsOfLengthN n xs)?
02:39:40 <shachaf> Help you out?
02:40:35 <elfeck> I tried filter ((== n) . length) (superset xs) but its too slow since it calculates 2^|xs| subsets
02:40:59 <elfeck> and I can't come up with a function that does it directly
02:41:36 <shachaf> Ugh, no, that's awful.
02:41:43 <shachaf> I guess you mean subsequences rather than subsets?
02:42:14 <elfeck> no subsets of lengh n ... e.g subsetsN 2 [1,2,3] = [[1,2], [1,3], [2,3]]
02:42:40 <shachaf> What's subsetsN 2 [1,1,1]?
02:42:58 <elfeck> undefined
02:43:05 <elfeck> set should not have duplicates
02:43:22 <shachaf> What brings this particular problem about?
02:43:39 <thebnq> do they have to be ordered? is that not 3 choose 2
02:43:54 <elfeck> I want to find minimal generators for an algebraic group structure
02:44:10 <elfeck> no order does not matter
02:44:25 <Ferdirand> is three a choose in the standard lib ?
02:44:38 <shachaf> Well, it's a simple enough recursive function to write directly.
02:44:38 <Ferdirand> doesn't look too hard to define though
02:45:03 <shachaf> At least for sequences, which as far as I can tell is equivalent to what you're asking for here.
02:45:32 <shachaf> foo :: Int -> [a] -> [[a]]
02:45:58 <shachaf> foo 0 _ = [[]]; foo n [] = []
02:45:59 <shachaf> Right?
02:46:02 <mauke> > let fn 0 _ = [[]]; fn _ [] = []; fn n (x : xs) = map (x :) (fn (n - 1) xs) ++ fn n xs in fn 2 [1,2,3]
02:46:04 <lambdabot>  [[1,2],[1,3],[2,3]]
02:46:19 <shachaf> And yes, the thing mauke said for the third line.
02:46:37 <shachaf> I was hoping to have you figure out that part yourself, but that works. :-)
02:46:58 <mauke> ah, sorry. I didn't mean to interrupt you
02:47:01 <elfeck> aha, but that works only for [1..n] and not for a set
02:47:04 <jle`> you can probably do a pre-nub to get the kind of "no-duplicates"ish behavior you are specifing
02:47:17 <shachaf> No problem, it was the same solution anyway.
02:47:19 <jle`> also i don't see why subsetsN 2 [1,1,1] can't just be []
02:47:33 <shachaf> What's a set?
02:47:45 <mauke> > let fn 0 _ = [[]]; fn _ [] = []; fn n (x : xs) = map (x :) (fn (n - 1) xs) ++ fn n xs in fn 2 "a set"
02:47:46 <lambdabot>  ["a ","as","ae","at"," s"," e"," t","se","st","et"]
02:48:25 <elfeck> okay I'm impressed ... I tried to come up with a solution for like 1.5h s now ...
02:49:06 <elfeck> I can't think in terms of recursion and composition ...
02:49:17 <shachaf> Well, it's still a good exercise to figure out how you would have written it.
02:49:19 <jle`> yes you can
02:49:21 <jle`> :)
02:49:23 <jle`> i believe in you
02:49:50 <elfeck> I know, but I couldn't do it shachaf
02:50:03 <elfeck> I tried for quite a bit
02:50:07 <shachaf> Well, now that you have a few hints, you can go back and see what you missed.
02:50:27 <shachaf> Then you can learn for next time.
02:51:17 <Flonk> I like to write a couple of recursive steps on a piece of paper until I figure out how I can put it into code
02:51:20 <elfeck> I will try
02:51:23 <shachaf> Given that mauke and I came up with the same solution down to the variable names, there's surely some value to experience with this sort of thing.
02:51:47 <mauke> fn /= foo
02:51:51 <mauke> only n was the same :-)
02:52:06 <shachaf> x was the same too in my ghci window
02:52:25 <elfeck> thanks a lot anyway
02:52:58 <Ferdirand> 9
02:53:01 <Ferdirand> voops
02:54:00 <elfeck> fn 0 _ = [[]]
02:54:01 <elfeck> fn _ [] = []
02:54:01 <elfeck> how is this both a valid pattern for Int -> [a] -> [[a]]
02:54:14 <elfeck> [[]] and [] are both of type [[a]]?
02:54:44 <thebnq> one is an empty list of lists
02:54:53 <thebnq> both*
02:55:36 <shiona> elfeck: [] is an empty list, [[]] is a list containing one empty list
02:56:04 <shiona> [[],[]] would be a list containing two empty lists, also of type [[a]]
02:56:11 <thebnq> yea that, i rushed my correction
02:56:23 <elfeck> aha
02:56:27 <elfeck> I see
02:58:19 <mauke> [] :: [b] and b = [a] in this case
02:58:21 <mauke> more or less
03:33:59 <SoupE> http://www.haskell.org down?
03:34:19 <SoupE> 503
03:35:19 <peddie> https://status.haskell.org/
03:38:30 <SoupE> okay thx for the link
03:39:53 <SoupE> down but operational hm
03:40:57 * hackagebot stm-containers 0.2.7 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.2.7 (NikitaVolkov)
03:47:35 <fizbin> @src ap
03:47:35 <lambdabot> ap = liftM2 id
03:47:43 <fizbin> @src liftM2
03:47:43 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:48:58 <bitonic> I've finally read through Pipes.Core, and stuff makes sense now.  where do I look for examples of large applications taking full advantage of pipes?
03:49:08 <bitonic> Tekmo uses it for bioinformatics if I'm not mistaken
03:49:58 <bitonic> but I'd like to read some programs that really show how all the functionality is useful, because while I get how it works I don't really get how you use it effectively
03:56:46 <guest123232> @pl (f >=> g) x = f x >>= g
03:56:46 <lambdabot> (line 1, column 14):
03:56:46 <lambdabot> unexpected " "
03:56:46 <lambdabot> expecting operator
04:00:45 <barrucadu> Given a ThreadId, is there a way to check if that thread is blocked?
04:00:58 * hackagebot slave-thread 0.1.5 - A principal solution to ghost threads and silent exceptions  http://hackage.haskell.org/package/slave-thread-0.1.5 (NikitaVolkov)
04:01:42 <{AS}> Hi, does "exists" as a function working on collections (Map, List, Set, etc.) exist in Haskell? I can't find it on Hoogle or similar?
04:03:12 <exio4> {AS}, do you mean something like Traversable/Foldable?
04:03:23 <{AS}> Yeah, I mean an existing one :)
04:03:33 <{AS}> I guess it is foldable
04:03:52 <amaru> it's called a bunch of different things: elem for lists, member for sets. (If i understood the question correctly)
04:04:52 <{AS}> I guess what I am looking for is, exists :: (Foldable f) => f a -> Bool
04:05:21 <{AS}> err sorry
04:05:27 <exio4> oh, I read your question wrong, sorry
04:05:36 <{AS}> (Foldable f) => f a -> (a -> Bool) -> Bool
04:05:56 <amaru> find :: Foldable t => (a -> Bool) -> t a -> Maybe a
04:06:11 <{AS}> amaru, ah thanks
04:06:28 <{AS}> is there also an forall equivalent?
04:06:46 <exio4> any/all functions in Foldable too
04:06:46 <barrucadu> See `any` and `all` in Data.Foldable
04:06:50 <amaru> Oh, yeah that's in there as well. "any" and "all"
04:06:56 <{AS}> Ah, thank you very much :)
04:07:32 <{AS}> they just didn't have the name I expected them to
04:08:12 <{AS}> Maybe, because of forall and exists being type-level keywords
04:09:12 <t4nk918> why hashtables (new ones) must be in some wrapper (IO, ST etc) ?
04:09:55 <hpc> "This package provides a couple of different implementations of mutable hash tables ..."
04:09:58 <hpc> they're mutable
04:10:55 <t4nk918> OK.. ST makes them wrapped / mutable.. But why IO ?
04:10:58 <quchen2> The standard package for hash{map,set} is unordered-containers. That sounds more like what you want.
04:11:00 <tdammers> IORef
04:11:01 <quchen2> @hackage unordered-containers
04:11:01 <lambdabot> http://hackage.haskell.org/package/unordered-containers
04:11:41 <{AS}> t4nk918:  I guess it is just a matter of convenience/choice (if you rather use IO instead of ST)
04:12:11 <tdammers> well, breaking out ST isn't always the right choice when all you need is mutability
04:12:13 <Guest4781> @pl let (<<>>) g  = (.) (flip (>>=) g)
04:12:13 <lambdabot> (line 1, column 5):
04:12:13 <lambdabot> unexpected "("
04:12:13 <lambdabot> expecting "()", natural, identifier or "in"
04:12:22 <Guest4781> @pl (<<>>) g  = (.) (flip (>>=) g)
04:12:22 <lambdabot> (line 1, column 12):
04:12:22 <lambdabot> unexpected " "
04:12:22 <lambdabot> expecting operator
04:12:34 <hpc> t4nk918: ST is "IO without IO", so it's IO because it allows mutation
04:12:41 <hpc> and ST because it happens to as well
04:15:58 * hackagebot git-embed 0.1.0 - Use TH to embed Git repo information.  http://hackage.haskell.org/package/git-embed-0.1.0 (borsboom)
04:17:40 <izohask> Aaaahaaa.. they are mutable, so I can do "H.insert hash 1 1" and then again "H.insert hash 2 2" and now I have both elements in the hash...
04:18:05 <izohask> so this is something "weird" ant that's why it has to be inside IO
04:21:04 <dav1d> I want to debug a function, basically pritning out content of variables defined in `where`, how would I do that?
04:21:29 <srhb> dav1d: Look at Debug.Trace.trace
04:22:20 <dav1d> oh
04:22:21 <dav1d> that's neart
04:22:23 <dav1d> *neat
04:22:24 <dav1d> thanks
04:23:21 <Guest4781> @pl (<<>>)  g = (.) $ flip (>>=) g
04:23:21 <lambdabot> (line 1, column 12):
04:23:21 <lambdabot> unexpected " "
04:23:21 <lambdabot> expecting operator
04:23:24 <belst> 1
04:23:59 <Guest4781> @pl (<<>>) g = (.) $ flip (>>=) g
04:23:59 <lambdabot> (line 1, column 11):
04:23:59 <lambdabot> unexpected " "
04:23:59 <lambdabot> expecting operator
04:24:25 <Guest4781> @pl (<<>>) g =(.) $ flip (>>=) g
04:24:25 <lambdabot> (line 1, column 11):
04:24:25 <lambdabot> unexpected "("
04:24:25 <lambdabot> expecting operator
04:24:42 <Guest4781> @pl (<<>>) g = ((.) $ flip (>>=) g)
04:24:42 <lambdabot> (line 1, column 11):
04:24:42 <lambdabot> unexpected " "
04:24:42 <lambdabot> expecting operator
04:25:10 <Guest4781> @pl (<<>>) g = (.) (flip (>>=) g)
04:25:10 <lambdabot> (line 1, column 11):
04:25:10 <lambdabot> unexpected " "
04:25:10 <lambdabot> expecting operator
04:25:24 <Guest4781> why isn't it working :(
04:26:11 <belst> isn't flip (>>=) just (=<<)
04:26:15 <batchm> yes
04:27:30 <Guest4781> indeed
04:27:41 <Guest4781> @pl (<<>>) g = (.) ((=<<) g)
04:27:41 <lambdabot> (line 1, column 11):
04:27:41 <lambdabot> unexpected " "
04:27:41 <lambdabot> expecting operator
04:28:40 <detrumi> @pl (.) ((=<<) g)
04:28:40 <lambdabot> ((g =<<) .)
04:29:41 <belst> (<<>>) = (.) . (=<<)
04:30:19 <sinelaw> . o O 8)
04:31:10 <fizbin> :t (>>=)
04:31:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:31:32 <fizbin> :t \x y -> join (ap x y)
04:31:33 <lambdabot> Monad m => m (a1 -> m a) -> m a1 -> m a
04:31:51 <fizbin> :t \x y -> join (ap y x)
04:31:51 <lambdabot> Monad m => m a1 -> m (a1 -> m a) -> m a
04:32:19 <fizbin> :t (join .) . fmap
04:32:20 <lambdabot> (Functor m, Monad m) => (a1 -> m a) -> m a1 -> m a
04:32:52 <fizbin> :t (join .) . (flip fmap)
04:32:53 <lambdabot> (Functor m, Monad m) => m a1 -> (a1 -> m a) -> m a
04:33:02 <belst> @pl \g -> (.) ((=<<) g)
04:33:02 <lambdabot> (.) . (=<<)
04:33:32 <srhb> Any particular reason the channel is being spammed with this?
04:34:00 <fizbin> Sorry. Was trying to work out the easiest way to define a Monad instance when I already have applicative.
04:34:11 <fizbin> Looks like I first need to figure out join.
04:34:21 <detrumi> You can also chat with lambdabot in private
04:35:02 <indiagreen> fizbin: um... sorry to spoil it, but you can't define a Monad instance if you only have Applicative
04:35:20 <fizbin> Well, you can if you have Applicative and also join.
04:35:58 <indiagreen> ah, then I guess I misunderstood ‚Äúfigure out join‚Äù
04:37:36 <codygman-> Is there a lazy bytestring version of isInfixOf?
04:37:40 <fizbin> Well, looking at this, my definition for <*> is so complex that it might be worth reworking it into a definition for (>>=), which I think is possible, and then using the Monad definition to define (<*>)
04:38:54 <agocorona> codygman-: I think so. don¬¥t try to do it yourself char by char because that is extremely slow
04:40:06 <codygman-> agocorona: I guess I'll just convert to strict bytestring and use its isInfixOf function
04:40:28 <codygman-> either that or convert to lazy text at beginning
04:40:29 <batchm> agocorona why extremely slow? i can't see how elseit could be done but going through a string char by char
04:40:53 <tdammers> batchm: you can step through a bytestring char by char without turning it into a linked list first
04:41:08 <agocorona> use breakOn
04:41:08 <batchm> sure
04:41:11 <tdammers> but, more pressing concern, bytestrings and texts/strings do not represent the same thing
04:41:12 <mgzk> fizbin: Mind if I ask what you're working on?
04:41:29 <batchm> tdammers, wouldn't list be optimized away to a loop, though?
04:41:49 <tdammers> there'd still be some overhead though
04:42:04 <tdammers> but what's more important, bytestrings ain't character data
04:42:18 <tdammers> bytestrings are bags of bytes. Not characters.
04:42:23 <codygman-> tdammers: Yeah, that's why I'm going to use Text... it's more appropriate here.
04:42:38 <tdammers> if you're going to use Text anyway, I'd convert as soon as you receive the data
04:42:45 <tdammers> and then use Text for everything internally
04:42:54 <fizbin> mgzk: I'm trying to get slightly better error messages out of AttoParsec. To do that, I'm defining a type that represents a parser with "critical sections" that can't be backtracked out of. (though an entire critical section can be backtracked over)
04:43:02 <agocorona> I mean for long strings. Well what is slow is "break"
04:44:34 <fizbin> mgzk: I'm trying to express the idea "if parse expression A succeeds, then parse expression B must succeed right after. Otherwise, the whole thing fails no matter how many other things you have in <|> afterwards.
04:46:25 <fizbin> I should write up a tiny example.
04:48:07 <indiagreen> fizbin: do you mean something like ‚Äúdon'tBacktrack‚Äù which you could use in places like ‚Äú(a >> don'tBacktrack >> b) <|> x <|> y <|> ...‚Äù?
04:49:24 <mgzk> fizbin: There isn't a way to combine A and B together in that library already? I've never used it. But I'd think there'd be a combinator that would make A by itself invalid, no?
04:50:08 <fizbin> mgzk: Not that way. Attoparsec has no concept of "stuff that can't be backtracked out of".
04:51:05 <fizbin> All Attoparsec constructs can be backtracked out of. As a consequence, attoparsec's error handling isn't so much "minimal" as "actively hostile".
04:52:39 <mgzk> fizbin: So it'll give you something like "expected one of A C or D".. when you really want "had A but there was no B"?
04:55:17 <fizbin> mgzk: Even worse; it'll say "finished parsing, consumed nothing". If you force it to read all the input by attaching "<* endOfInput" to your parser definition, it'll just say (Left "endOfInput")
04:57:06 <mgzk> fizbin: Oh, that's painful! Sounds like you're doing something valuable.
05:01:08 <favetelinguis> trying to differentiate my own expression type for fun be realized im to dumb for this :) Could need some help on how to do this http://lpaste.net/116518
05:30:57 <{AS}> Hi again, is there any function :: Monoid b => Maybe b -> b?
05:31:16 <tdammers> {AS}: have you tried Hoogle?
05:31:24 <tdammers> @hoogle Monoid b => Maybe b -> b
05:31:25 <{AS}> tdammers: yeah
05:31:25 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
05:31:25 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
05:31:25 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
05:31:28 <mauke> :t fromDefault mempty
05:31:29 <lambdabot>     Not in scope: ‚ÄòfromDefault‚Äô
05:31:29 <lambdabot>     Perhaps you meant ‚ÄòT.fmapDefault‚Äô (imported from Data.Traversable)
05:31:36 <mauke> :t fromMaybe mempty
05:31:37 <lambdabot> Monoid a => Maybe a -> a
05:32:06 <{AS}> Ah, thanks
05:32:21 <{AS}> I was using: maybe mempty id
05:32:30 <{AS}> thought there was something neater
05:32:38 <tdammers> :t mayve
05:32:39 <lambdabot>     Not in scope: ‚Äòmayve‚Äô
05:32:39 <lambdabot>     Perhaps you meant ‚Äòmaybe‚Äô (imported from Data.Maybe)
05:32:41 <tdammers> :t maybe
05:32:42 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:32:44 <tdammers> :t fromMaybe
05:32:45 <lambdabot> a -> Maybe a -> a
05:32:57 <tdammers> so yeah, what mauke said
05:33:08 <batchm> those are some arbitrary names.. fromJust, fromMaybe, maybe
05:33:36 <{AS}> as far as I understand the eliminator for a data type D is often called d in Haskell
05:33:42 <{AS}> the others I do not know why
05:34:08 <{AS}> > list
05:34:09 <lambdabot>  Not in scope: ‚Äòlist‚Äô
05:34:09 <lambdabot>  Perhaps you meant one of these:
05:34:09 <lambdabot>    ‚Äòlast‚Äô (imported from Data.List),
05:34:13 <{AS}> :t list
05:34:14 <lambdabot>     Not in scope: ‚Äòlist‚Äô
05:34:14 <lambdabot>     Perhaps you meant one of these:
05:34:14 <lambdabot>       ‚Äòlast‚Äô (imported from Data.List),
05:34:20 <dramforever> :t foldr
05:34:20 <lambdabot> (a -> b -> b) -> b -> [a] -> b
05:34:28 <mauke> too recursive
05:34:30 <nshepperd> the eliminator for lists is foldr
05:34:37 <{AS}> Ah
05:34:42 <{AS}> yeah of course
05:34:48 <{AS}> I just thought there was an alias
05:35:00 <mauke> list :: b -> (a -> [a] -> b) -> [a] -> b
05:35:33 <dramforever> IMO they (so called-ly) "church encode" the data
05:35:41 <dramforever> :t maybe Nothing Just
05:35:41 <lambdabot> Maybe a -> Maybe a
05:35:58 <nshepperd> yeah, foldr and maybe give you the church encoding
05:36:01 <dramforever> :t foldr (:) []
05:36:02 <lambdabot> [a] -> [a]
05:36:16 <dramforever> :t either Left Right
05:36:17 <lambdabot> Either a b -> Either a b
05:36:23 <nshepperd> although properly I supposed the order of arguments should be reversed for that
05:36:31 <dramforever> huh?
05:36:55 <{AS}> :t either Right Left
05:36:55 <lambdabot> Either a a1 -> Either a1 a
05:36:58 <quchen2> I think the Church encoding of lists is something different: the standard number representation introduced in elementary (untyped) lambda calculus texts.
05:37:02 <nshepperd> churchMaybe :: Maybe a -> (b -> (a -> b) -> b)
05:37:06 <{AS}> I think the order is correct
05:37:21 <dramforever> hmm...
05:37:37 <dramforever> yep, that's what I mean by "so called-ly"
05:38:55 <nshepperd> well, foldr does give the right result when you feed it the list constructors
05:39:15 <dramforever> maybe, either also works like that
05:39:30 <dramforever> they replaces constructors with functions you gave them
05:41:25 <batchm> :t fix
05:41:26 <lambdabot> (a -> a) -> a
05:41:41 <dramforever> :t fix fix
05:41:42 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> a
05:41:42 <lambdabot>     Expected type: (a -> a) -> a -> a
05:41:42 <lambdabot>       Actual type: (a -> a) -> a
05:42:00 <danilo2> Hello! Is it possible to create some type class dependencies in Haskell? I mean - I want to automatically generate an instance when some instance "chains" are available - here is small example: http://lpaste.net/116519
05:44:08 <dramforever> danilo2: you could have done "instance XClass Foo => IntClass Foo where...", but that makes type checking undecidable
05:44:18 <danilo2> I mean - we've got type classes A and B. We know that if something implements A it implements B because it is straightorward. Isi t possible to automatically implement B when implementation of A is available?
05:44:54 <danilo2> dramforever: I dont think this solves the problem - look 2 lines up - I descrbed it another way
05:45:06 <dramforever> danilo2: instance XClass a => IntClass a where ...
05:45:24 <dramforever> then a will be an instance of XClass in the "where"
05:45:30 <dramforever> but that won't work
05:45:54 <ThreeOfEight> http://lpaste.net/116520
05:45:56 <nshepperd> well, that does work
05:46:01 <ThreeOfEight> This works, but the "overlapping instances" thing is a bit problematic
05:46:06 <nshepperd> afaik
05:46:10 <dramforever> that's a undecidable instance, iirc
05:46:12 <danilo2> dramforever: Of course, but as far as I'm not wrong, to make it working I still have to manually write instance (instance XClass ...) for this specific a there
05:46:14 <dramforever> an*
05:46:14 <nshepperd> but if you do that you can't have any other IntClass instances
05:46:35 <nshepperd> because it's not exactly 'generating' instances according to 'availability'
05:46:39 <ThreeOfEight> the problem is that this "forces" you to use the automatically-inferred instance whenever possible
05:46:56 <danilo2> dramforever, ThreeOfEight: ahh this way! of course
05:47:14 <danilo2> dramforever, ThreeOfEight: I know, the errors could be ugly here
05:47:27 <ThreeOfEight> Whether or not something like this makes sense for your application depends on what exactly you are trying to do
05:47:43 <ThreeOfEight> but I would generally advise to do it another way.
05:47:47 <dramforever> xClassGetX :: XClass i => i -> Int
05:48:33 <dramforever> and instance IntClass blah where getInt = xClassGetInt
05:48:48 <dramforever> s/xClassGetX/xClassGetInt/
05:49:43 <dramforever> this way you still have to write them, but a bit cleaner
05:49:48 <danilo2> dramforever: Yeah it works of course. I dont knwo why I just didnt saw it. It's very straightforward here, heh :)
05:50:08 <dramforever> that's very common in haskell stuffs
05:50:26 <dramforever> it's called something like "default implementation"
05:50:42 <dramforever> like instance Functor BlahMonad where fmap = liftM
05:51:05 <dramforever> (I hope) you get the idea
05:51:14 <danilo2> ThreeOfEight: I understand. I will be carefull with this :)
06:05:12 <lpaste> fizbin pasted ‚ÄúWrangling real errors out of attoparsec‚Äù at http://lpaste.net/116521
06:06:39 <fizbin> mgzk: ^^ That's what I'm doing.
06:07:52 <fizbin> "tinyPrser" and "tinyAtto" parse the same thing, but give different results on bad input.
06:14:38 <wolf_mozart> what kind of coding is haskell especially made for actually.
06:14:52 <wolf_mozart> math intensive applications?
06:15:20 <rom1504> no
06:15:56 <wz1000> wolf_mozart: Haskell is made for everything. Especially the cool things
06:16:31 <exio4> I would say only cool things though
06:16:39 <wolf_mozart> hmm. do I need an enviroment thing to run it, like I need python to run python scripts?
06:16:56 <rom1504> yeah you can't run it with your hand
06:17:14 <wz1000> wolf_mozart: Haskell programs can be compiled if thats what you mean.
06:17:16 <exio4> after you compile it, we could say you don't need anything
06:17:24 <wz1000> rom1504: I disagree
06:17:38 <wz1000> rom1504: I frequently run Haskell programs by hand.
06:17:48 <indiagreen> wolf_mozart: if you compile an executable, you don't need any Haskell compiler installed, but you can also distribute scripts and run them with runhaskell
06:17:48 <nshepperd> well, it's mostly just lambda calculus so I reckon you could run haskell with pen and paper
06:18:05 <rom1504> wz1000: yeah but do you *run* the program by hand ? :p
06:18:20 <rom1504> oh right didn't read
06:18:21 <rom1504> well ok
06:18:39 <wei2912> rom1504: no, he runs the program on his hand
06:18:54 <wei2912> small programs are cute enough to be placed on your hand
06:18:56 <wei2912> and they don't bite
06:18:57 <exio4> I'd bet it is easier to run HS programs by hand than, lets say, C, because you don't need to keep track of lots of state
06:19:37 <rom1504> :D
06:20:19 <pantsman> once you start using IO, it's hard to run haskell programs by hand
06:20:43 <exio4> isn't everything hard when using IO?
06:21:02 <benzrf> exio4: sort offf
06:21:11 <benzrf> exio4: tbh you kind of do
06:21:14 <benzrf> have to keep track of
06:21:15 <benzrf> lots of state
06:21:20 <pantsman> exio4: strict IO is a bit easier
06:21:21 <benzrf> exio4: closures maintain state of a sort
06:21:27 <nshepperd> when you have a space leak and build pages and pages of thunks :0
06:21:36 <benzrf> well, i suppose you can view them as partially-filled-in lambdas
06:21:37 <exio4> benzrf, closures without mutability are still easier than with it
06:21:48 <exio4> and you can "inline" it
06:21:49 <nshepperd> but brain is the best strictness analyzer :)
06:22:28 <exio4> nshepperd, we need to give GHC a brain then!
06:24:31 <nshepperd> the first usage for human mind uploads!
06:25:13 <nshepperd> optimizing our wrongly written folds
06:25:53 <exio4> and then someone adds recursive datatypes to djinn...
06:26:01 <rofer> Can anyone help me with: http://lpaste.net/2265643644331491328 ? I'm getting that it can't match bytestring-0.10.4.1:Data.ByteString.Lazy.Internal.ByteString with LBS.ByteString
06:26:13 <dfeuer> Any data structure masters around?
06:26:29 <rofer> but I'm a little confused as to why they don't match because as far as I can tell they're the same type
06:28:56 <nshepperd> rofer: you may have two versions of package bytestring installed
06:29:57 <brainacid> hey guys i wanted to know if Haskell supports inline assembly?
06:30:03 <brainacid> for x86-64
06:30:06 <brainacid> thanks
06:30:13 <rofer> nshepperd: Ah, you got that from the version name in the type?
06:30:44 <nshepperd> yeah that's the typical reason for an error like that
06:31:22 <rofer> nshepperd: Is there an easy way to recompile all of my dependencies to get them to use the same version?
06:32:28 <nshepperd> my typical solution is to nuke ~/.ghc and cabal install everything again
06:33:05 <nshepperd> or, using a sandbox, remake the sandbox
06:33:24 <rofer> Think I should probably start using a sandbox. Thanks!
06:33:24 <otulp> brainacid: I have never heard of inline asm in Haskell. You can inline it in C and call to that via the foreign function interface, though.
06:33:41 <brainacid> yes otulp indeed thx
06:33:51 <nshepperd> the key thing is I think to cabal install everything at once, so that the dependency solver will find a common version that satisfies every package
06:33:54 <myst|work> why would you need inline asm in Haskell?
06:34:02 <myst|work> with all that lazyness around
06:34:13 <brainacid> High levek languages are clumsy and inefficient
06:34:17 <brainacid> *level
06:34:31 <brainacid> my point the lazy programmer sucks
06:34:32 <otulp> Them's fighin' words :)
06:34:36 <brainacid> :)
06:34:38 <brainacid> j/k
06:34:41 <brainacid> relax
06:34:52 <brainacid> i purposely came in to pick on yall
06:34:57 <tdammers> brainacid: low level languages are even clumsier, and inefficient on a different axis :D
06:34:59 <brainacid> l0l
06:35:07 <brainacid> tdammers, :D
06:35:08 <exio4> you could always get an ASM interpreter
06:35:13 <nshepperd> the only languages I know of clumsier than x86 assembly are fictional
06:35:29 <brainacid> I am a very small bit ... i know nothing of developing useful software
06:35:33 <tdammers> nshepperd: boy do I wish that were true... have you tried PHP?
06:35:55 <brainacid> im just beginning my jounery as a programmer
06:35:56 <exio4> I would say PHP is fictional!
06:36:05 <nshepperd> haha I have tried php
06:36:16 <exio4> I tried and failed
06:36:17 <nshepperd> but thar's another tale
06:36:25 <nshepperd> as they say on the high seas
06:37:37 <myst|work> oh wow
06:37:42 <myst|work> we got trolled
06:39:51 <tdammers> my experience is that PHP requires gargantuan quantities of trust
06:39:57 <tdammers> faith, even
06:40:01 <tdammers> blind faith, even
06:43:28 <ClaudiusMaximus> @tell brainacid http://hackage.haskell.org/package/harpy for x86, maybe you could patch it for x86-64
06:43:29 <lambdabot> Consider it noted.
06:47:18 <rofer> Is it normal for a Haskell project to involve a ton of dependencies?
06:47:28 <tdammers> rofer: define "a ton"
06:47:49 <tdammers> but yes, it's pretty normal to have many compile-time dependencies
06:48:02 <batchm> 2000 pounds
06:48:04 <rofer> I have 19 things in my .cabal file and my project barely does anything yet (and those dependencies of course pull in a bunch of other stuff)
06:48:07 <tdammers> runtime dependencies should be very modest though
06:48:31 <JonReed> Isn't a dependency actually a good thing, meaning that you re-use code, instead of reinventing the wheel?
06:48:33 <tdammers> 19 sounds normal
06:48:36 <rofer> Obviously pretty subjective, but I'm not used to using so many different libraries in my projects
06:48:49 <tdammers> besides, it's not like the number of dependencies is going to grow linearly as your project scales up
06:49:15 <tdammers> also, keep in mind that Haskell libraries are often much smaller in scope than, say, C libraries
06:49:22 <rofer> I just feels like it's growing faster than my features sometimes
06:49:43 <rofer> Trying to write a game and right now I'm only approaching the point where you can log in
06:49:44 <tdammers> nah... the dependencies just grow faster in the early stages
06:50:20 <tdammers> but once you have done the groundwork, you're going to be moving mostly in the upper abstraction layers, and you rarely need to introduce new dependencies there
06:50:54 <rofer> Yeah, just not used to it I guess. When I would write something in C++ I'd just have a few big dependencies.
06:51:05 <tdammers> look at it this way - you're only writing about 5% of the actual program, the rest is dependencies. The early stages of the project involve putting the 95% in place that you don't write yourself, then you start writing the 5%
06:51:43 <tdammers> also, it's a bit like boost - except that it's often easier to just depend on "boost-all" than managing dependencies individually
06:55:07 <rofer> Yeah, I see that it's not a bad thing, just feels weird
06:56:56 <tdammers> matter of habits
06:57:30 <tdammers> large monolithic dependencies are theoretically inferior, but unless you have excellent package management, they are often a more pragmatic approach
07:06:25 <zipper> I'm having a problem coming up with a fibonnachi pattern like: x:y:next where next is x+y and then pass y:next to the function somehow.
07:14:21 <Saizan> > let fib = 0:1:zipWith (+) fib (tail fib) in fib
07:14:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:15:16 <codygman-> What would the Haskell equivalent of this Python code be? code: http://pastebin.com/59Dd3c7N
07:15:39 <JonReed> How would I construct a Data.IntMap from a list of data objects, which contain keys inside them. E.g. "data Person { _key :: Int, _name :: String }".  AFAIK, key value pair looks like this (k, v). But my list is [p], where p is Person. And the key is contained inside p. Am I wrong that "(k, p)" wil duplicate data unnessesarily?
07:16:47 <n4x> codygman-: what would izip_longest do?
07:17:23 <codygman-> n4x: Basically it is like zip that provides a default. Instead of truncating list items it pairs them with None.
07:17:55 <Saizan> JonReed: it doesn't seem something you should worry about
07:18:27 <quchen2> JonReed: `Map.fromList . map (\person -> (_key person, _value person))` will do what you want. It won't copy keys/values, all the "unnecessary" work it does is to allocate a tuple for each Person.
07:18:52 <pharpend> morning/evening/whatever-time-it-is-in-your-country, everyone!
07:19:15 * ski . o O ( `_key &&& _person' )
07:19:33 <ski> (hum .. s/_person/_value/)
07:19:44 <n4x> > let xs = Nothing:xs in zip (Just "Rep Nam":xs) ["email@email.email", "other@email.email"] -- some naive solution, but something like this?
07:19:45 <lambdabot>  [(Just "Rep Nam","email@email.email"),(Nothing,"other@email.email")]
07:19:52 <albeit> What typeclass do I need to derive to be able to use "data Foo = Bar | Baz" as Ints (as keys for an IntMap)?
07:19:55 <jdiez> hi guys, I'm trying to use mueval (rolling my own ghetto lamdabot-esque thing.) it doesn't seem to work out of the box.
07:20:03 <jdiez> mueval-core: GHC returned a result but said: [GhcError {errMsg = "Top level:\n    Module \8216Control.Monad.Error\8217 is deprecated:\n      Use Control.Monad.Except instead"}]
07:20:16 <jdiez> I've tried removing that from Mueval/Context.hs but the error persists; any help?
07:20:42 <quchen2> albeit: You should make your type Ord and then use ordinary Map.
07:20:58 <zipper> Saizan: Ok I don't know how to convert that into something that can run. Here is what I have from your definition: https://gist.github.com/urbanslug/5d64ae304197c95410e6
07:20:58 <JonReed> But the key will be stored twice (key, Person { key, field, field field } )?
07:20:59 <quchen2> IntMap is for things with Int as key. Your type isn't Int.
07:21:00 <c_wraith> jdiez: the problem is that mueval uses hint, and hint can't handle code comiling with warnings
07:21:07 <albeit> quchen2: Okay, thanks
07:21:11 <quchen2> If you're looking for a hashmap, then have a look at the unordered-containers package.
07:21:11 <c_wraith> jdiez: you need to disable warnings
07:21:21 <jdiez> c_wraith: alright, how do I do that?
07:21:26 <batchm> what quchen said.. you need YourType -> Int function
07:21:26 <ski> n4x : `xs = repeat Nothing'
07:21:47 <batchm> or alternatively just use Data.Map.Map
07:21:53 <quchen2> JonReed: The key will not be copied. There will be two pointers to each key on your RAM though: one from inside a Person, and one from inside the tuple you're constructing.
07:21:55 <c_wraith> jdiez: Not sure if you can from mueval.  does it take compiler options at the command line?
07:22:26 <n4x> ski: oh, didn't remember repeat's type signature :P
07:22:33 <zipper> Saizan: Oh my bad
07:22:35 <ski> @type repeat
07:22:36 <lambdabot> a -> [a]
07:22:38 <zipper> Saizan: Done
07:22:39 <jdiez> c_wraith: doesn't look like it unfortunately
07:22:47 <n4x> @type cycle -- I was confusing it with this one ski
07:22:48 <lambdabot> [a] -> [a]
07:24:27 <jdiez> c_wraith: but I'm willing to modify mueval; how should I go about it?
07:26:06 * hackagebot tamper 0.3.5.3 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.3.5.3 (TobiasDammers)
07:27:08 <JonReed> quchen2: That's what I'm talking about. I thought that maybe there is some custom function for Data.Map/Data.IntMap to extract a key. Like fromList (Person -> k) [p, p, p]. Of course,  one additional Word for an extra pointer is not a big deal. But it seems a bit redundant.
07:27:35 <quchen2> JonReed: I wouldn't be surprised if GHC optimized that step away.
07:28:27 <c_wraith> jdiez: wherever it calls Mueval.Interpreter.interpreter, make sure the Options object has an Extension for -w (disable all warnings)
07:28:42 <jdiez> c_wraith: got it, thanks
07:29:14 <c_wraith> jdiez: err, whoops.  Not quite right.
07:29:22 <c_wraith> jdiez: it doesn't go in the Options object
07:29:36 <mmachenry> If I have a 16-processor Linux machine where all processors are quad core, and I write a server that does forkIO to server client connections, what will be the upper bound of processor usage? The whole machine? One processor? One core?
07:30:08 <jdiez> c_wraith: I'm just setting -w unconditionally for now just to see if I can work around it, I'll properly fix it after that
07:30:27 <bjobjo> mmachenry: check out amdahls law in general and "parallell and concurrent programming in haskell" in particular
07:30:28 <jdiez> c_wraith: indeed, setting -w doesn't get rid of the error
07:30:39 <bjobjo> mmachenry: it has a lot of useful info on the subject
07:31:06 <c_wraith> jdiez: it needs to be set inside mueval's call to the GHC machinery.  Not sure how to do that.
07:31:07 * hackagebot time-locale-compat 0.1.0.0 - Compatibility of TimeLocale between old-locale and time-1.5  http://hackage.haskell.org/package/time-locale-compat-0.1.0.0 (KeiHibino)
07:31:08 <bjobjo> mmachenry: you can find it here: http://chimera.labs.oreilly.com/books/1230000000929/index.html
07:31:12 <tdammers> mmachenry: my guess would be that you'll max out on I/O bandwidth before you manage to drive all cores to 100%
07:31:22 <tdammers> mmachenry: generally speaking, that is
07:31:31 <c_wraith> jdiez: looks like you might just need to alter Mueval.Intepreter.interpreter to set -w as an option for hint
07:31:33 <jdiez> c_wraith: unsafeSetGhcOptions seems like it would do the trick, but doesn't
07:35:19 <jdiez> agh
07:35:22 <jdiez> mueval is pretty broken
07:35:53 <mmachenry> bjobjo: I am reading it now
07:45:47 <izohask> I have getNew = do ht <-H.new return HT
07:45:53 <izohask> ( import qualified Data.HashTable.IO as H )
07:46:18 <izohask> can I get new, empty hashtable somehow "immediately",
07:46:27 <izohask> without having to define "getNew"
07:46:54 <izohask> something like "let m = return H.new :: IO (H.BasicHashTable String Int)"
07:47:00 <izohask> (this does  not work)
07:49:05 <Skye> problem porting
07:50:39 <ski> izohask> :t H.new
07:51:03 <izohask>  :: Data.HashTable.Class.HashTable h => IO (H.IOHashTable h k v)
07:51:32 <ski> then `getNew = do ht <-H.new return HT' is illtyped
07:51:49 <izohask> getNew :: IO (H.BasicHashTable String Int)
07:51:55 <izohask> getNew = do ht <- H.new return ht
07:52:11 <izohask> "getNew" works fine
07:52:12 <ski> oh, i suppose you mean `getNew = do ht <- H.new; return ht'
07:52:21 <izohask> correct, sorry for misstyping
07:52:37 * ski thought izohask was passing arguments to `H.new' 
07:52:54 <izohask> getNew works... But I do not know how to get same result without defining "creator function"
07:53:02 <ski> by one of the monad laws, `getNew = do ht <- H.new; return ht' is equivalent to `getNew = H.new'
07:53:28 <ski> iow, instead of using `getNew', you could use `H.new' immediately
07:53:35 <ski> .. what were you trying to do ?
07:54:29 <izohask> I'm in GHCI and I would like to have new hashtable
07:54:33 <izohask> one option now is:
07:54:39 <izohask> let m = getNew
07:54:40 <izohask> this works
07:54:44 <izohask> but
07:54:49 <izohask> let m = H.new
07:54:56 <Benzi-Junior> hey what is the best way to turn a list of strings to a string containing a comma seperated list of the strings (so [a,b,c] goes to (a++","++b++","++c)
07:54:58 <ski> note that there is no constant of type `H.IOHashTable h k v' exported. since hashtables refer to mutable storage, you need to explicitly allocate new such storage each time you want a new (initially empty) hashtable
07:54:58 <izohask> gives me No instance for (Data.HashTable.Class.HashTable h0) arising from a use of `H.new'
07:55:35 <izohask> can I alocate this without defining "creator function" ("getNew" in my case) ?
07:55:37 <ski> izohask : if you're in GHCi, you can type `myHashtable <- H.getNew' to get a new one
07:55:43 <nshepperd> jdiez: gwern (who wrote mueval) is on freenode and "might" respond to /msg, or an email. Maybe he knows something about the warning situation
07:56:01 <ski> er, `H.new', i mean
07:56:07 <ski> saying `m = getNew' is as useless as saying `getNew = H.new'
07:56:56 <ski> > intercalate "," ["a","bc","def"]  -- Benzi-Junior ?
07:56:56 <kuribas> > concat $ intersperse "," ["a", "b", "c"]
07:56:57 <lambdabot>  "a,bc,def"
07:56:57 <lambdabot>  can't find file: L.hs
07:57:11 <ski> @src intercalate
07:57:11 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
07:57:40 <izohask> hm.. but getNew has type (HashTable String Int)
07:58:00 <izohask> how I can "force" this datatype without definining "getNew" function ?
07:58:12 <n4x> it doesn't, it has type IO (HashTable String Int)
07:59:12 <izohask> Sorry, n4x, you're right
07:59:36 <izohask> so "getNew >>= H.toList" works  fine in GHCI
07:59:50 <ski> izohask : you can type `myHashtable <- H.new' in GHCi .. that gets you a `myHashtable' that's not an `IO'-action
08:00:11 <n4x> do you mean, how can you give it an explicit type signature?
08:00:19 <izohask> right, n4x
08:00:41 <izohask> (ski, it does not work, m <- H.new gives exception)
08:00:50 <izohask> No instance for (Data.HashTable.Class.HashTable h0) arising from a use of `H.new'
08:01:22 <srhb> Well it needs more arguments for starters.
08:01:31 <ski> izohask : oh, that's a type class error, not an exception
08:01:39 <ski> izohask : so specify some concrete type you want
08:01:55 <srhb> Wait, which hashtable is this? The one from base?
08:02:31 <ski> izohask : something like `myHashtable <- H.new :: IO (H.IOHashTable A B C)', where you should replace `A',`B',`C' by the actual types you want there
08:02:32 <n4x> @type let f = ([] :: [Int]) in f
08:02:33 <lambdabot> [Int]
08:02:36 <izohask> Data.HashTable.IO.BasicHashTable
08:03:07 <srhb> Ah.
08:04:17 <izohask> my <- H.new::(H.BasicHashTable String Int)
08:04:21 <izohask> this does not work
08:04:27 * ski isn't sure of the roles of `h',`k',`v` in `IOHashTable h k v', so can't suggest example types atm
08:04:43 <ski> izohask : add `IO' right after the `::'
08:04:44 <c_wraith> izohask: I'm betting BasicHashTable isn't a monad.
08:04:50 <srhb> k is key type, v is value type. h is weird.
08:04:55 <izohask> yeeeeeees!
08:05:04 <izohask> that's it, thank you... That's what I was looking for
08:05:11 <izohask> my <- H.new::IO (H.BasicHashTable String Int)
08:05:15 <izohask> thank you all!
08:05:39 <ski> `my :: H.BasicHashTable String Int <- H.new' would work with `PatternSignatures' (or `ScopedTypeVariables', possibly ?)
08:05:42 <sruz25> is it possible to make "modify" data structure/make new instance from old one without having to "copy" everything?
08:06:01 <ski> izohask : also, please leave your `::' some room to breath : `my <- H.new :: IO (H.BasicHashTable String Int)
08:06:08 * hackagebot mime-mail 0.4.6.2 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.6.2 (MichaelSnoyman)
08:06:10 * hackagebot mime-mail-ses 0.3.2.1 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.3.2.1 (MichaelSnoyman)
08:06:32 <srhb> sruz25: A lot of data structures will permit sharing of the individual stuff, depending on your program. Otherwise there are varieties of approaches to mutability such as IORefs etc.
08:06:35 <flux> sruz25, well, depends. if your data is structued in a tree-like fashion, you may be able to make a modified copy of the spine and then share most of it.
08:06:58 <ski> operators usually feel crowded if they're not given enough space to breath in
08:07:22 <znst> What is the :: operator called?
08:07:29 <srhb> is of type!
08:07:37 <sruz25> I don't really mean mutability, I mean if I can say "I want something like this one, only with different left subtree" for example
08:07:42 <srhb> (Well, that's my name for it)
08:07:54 <srhb> sruz25: That will happen automagically in most instances
08:08:02 <ski> in expressions, it's used to ascribe a type to an expression. it might there be called a "type ascription operator"
08:08:33 <izohask> ski: OK I will , thnx
08:08:33 <sruz25> Is there some example anywhere?
08:08:35 <ski> in declarations, it's used to specify a type signature for some datum. there it might perhaps be called a "type signature operator"
08:08:39 <sruz25> I'm not sure about the syntax
08:09:11 <srhb> sruz25: let a = [1,2,3]; b = tail a in (a,b) should not allocate [2,3] twice, afair
08:09:49 <JonReed> Datastructures which preserve previous versions of themselves are called "persistent". https://en.wikipedia.org/wiki/Persistent_data_structure
08:09:51 <ski> sruz25 : if you're working with trees, then only the new nodes you make will be allocated. the old subtrees will just have their reference copied, they won't be structure-copied themselves
08:10:25 <izohask> I'm still trying to understand why HashTable needs this IO or ST "wrapper"
08:10:29 <znst> srhb: ski: cool, lots of info about a ::
08:10:34 <srhb> sruz25: It's simply so easy to exploit this property with immutability that it's almost never discussed, I guess. :-)
08:10:40 <izohask> If I'mo on right way, this is due to mutability
08:10:46 <JonReed> AFAIR, most haskell datastructures are persistent. Data.Map won't copy itself completely, it will just have different versions stored.
08:11:08 <sruz25> But I still do have to copy the reference manually, right?
08:11:20 <izohask> otherwise I would have to copy complete hashmap to add new element
08:11:33 <ski> znst : btw, in a type signature, you can declare the type of more than one datum at a time. e.g. `take,drop :: Int -> [a] -> [a]' works
08:12:11 <srhb> sruz25: Nope.
08:12:16 <ski> izohask : `IO' and `ST s' can be used to manage mutable data structures
08:12:32 <sruz25> so there is something like "makeModified original changedElement"?
08:12:43 <srhb> sruz25: No, it just happens. See the example I gave with lists.
08:12:44 <ski> sruz25 : you copy it by just twice (or more times) mentioning the variable which refers to the data structure, e.g.
08:12:48 <batchm> when you add a new element to a Map only a couple of nodes are allocated on your way. everything else is shared
08:13:03 <znst> ski: interesting
08:13:26 <ski> sruz25 : in srhb's example, `tail a' will just extract a sub-structure of `a', so that will create an "alias" to a part of `a'
08:14:00 <ski> sruz25 : "so there is something like \"makeModified original changedElement\"?" -- if you define it, yes
08:14:43 <srhb> izohask: It has to do with the hash conflict resolution, I believe
08:14:56 <ski> sruz25 : for record syntax, there's `oldRecord {field = newFieldValue}' which makes a copy of `oldRecords' with all fields the same, except that `field' will hold `newFieldValue' (and yes, you can update more than one field at once, with this syntax)
08:15:23 <sruz25> oh, that's exactly what I was looking for
08:15:25 <srhb> izohask: It's not about mutability per se, since you can obviously have a pure Data.Map etc.
08:15:30 <izohask> ski: So, if Im adding 1000 elements to hashmap inside one IO function, it will be much much faster then calling some IO function 1000 times, am I correct ?
08:15:57 <izohask> I mean, because "computing context" will enable adding new elements without making copy each time ?
08:16:00 <srhb> That distinction probably makes no sense.
08:16:09 * hackagebot wai-app-static 3.0.0.4 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-3.0.0.4 (MichaelSnoyman)
08:16:14 <sruz25> thanks for help
08:16:15 <ski> sruz25 : however, it's clunkier to use when you have nested records :/ .. there are some "functional reference" libraries that are designed to ameliorate this problem
08:16:50 <ski> @where lenses
08:16:50 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-
08:16:50 <lambdabot> structure-access-and-mutation>
08:18:20 <sruz25> ski: It's just for parsing arguments from getArgs and it's not that complicated
08:18:39 <rofer> Anyone know what's usually done with acid-state when you want to do something like having multiple tables?
08:18:41 <ski> izohask : ".., it will be much much faster then ..., am I correct ?" -- i dunno why that would necessarily be the case. presumably you call your adding function `1000' inside your `IO' function, no ?
08:18:43 <srhb> izohask: let f [x] = if x < 10^9 then [x+1] else [x] in f 1 will probably faster than an equivalent IORef version, if that's what you're asking.
08:19:02 <srhb> will probably be slower*
08:19:35 <srhb> rofer: Add it to your top data type, or have multiple acid stores.
08:19:39 <srhb> rofer: Either way works.
08:20:33 <rofer> srhb: Are there any tradeoffs between the two or are they basically equivalent?
08:20:38 <izohask> srhb: inside func::IO HashTable, I can doo H.insert ht "key1" 1;H.insert ht "key2" 2
08:21:17 <srhb> rofer: You don't have to do migrations for the latter solutions, but on the other hand you have logically decoupled your types, which is not nice IMO.
08:21:18 <izohask> srhb: as there is "mutability", I believe I have "computing context" enabling me not to make copies of "ht", so I can just simple add new keys&values in hashtable
08:21:36 <srhb> izohask: That's right, it's a mutable type.
08:21:50 <srhb> izohask: Equivalent to storing an Int in an IORef and manipulating that.
08:22:07 <izohask> srhb: if I use some non-IO function, I would have , in order to add, copy complete hashtable to a new result
08:22:18 <srhb> izohask: Generally no, but maybe for the case of hashtable.
08:22:31 <srhb> izohask: Immutability allows sharing for a lot of data structures.
08:23:10 <srhb> I don't see how a "pure hashtable" works anyway, perhaps some expert does, but in this case the point is moot since these hashtables cannot ever be pure.
08:23:35 <srhb> (Perhaps by simply disallowing collissions, but then you basically have a Map, no?)
08:24:00 <izohask> What is the main reason to put hashtables in IO instead of having "normal" hashtables ? Why H.new wants IO HashTable instead of HashTable ?
08:24:01 * ski would say it's a type (having values) that reference mutable storage
08:24:19 <srhb> izohask: Like I said, I don't know how a "normal" hashtable works
08:24:33 <srhb> I can talk about Maps or trees though.
08:25:31 <srhb> izohask: What I'm claiming (which may be wrong) is that hashtables are by definition impure, mutable. Therefore the discussion is moot.
08:25:52 <Ferdirand> probably the same reason why we put arrays in IO ?
08:26:08 <rofer> srhb: If I do things the former way won't I have to change all of my query functions every time I add in a new "table"?
08:26:24 <izohask> Ferdirand: and what is the reason ...?
08:26:27 <nshepperd> haskell does has immutable arrays
08:26:28 <srhb> rofer: Not if you design your queries carefully. They don't ever have to touch the other records in your "top datatype"
08:26:35 <batchm> you can't generally disallow collissions in a hashtable. you need to have a perfect hash function for that
08:26:41 <ski> (`Array' doesn't require `IO' to manage)
08:26:44 <nshepperd> but modifying them directly is inefficient
08:26:53 <izohask> why ?
08:26:55 <ski> (`IOArray' does, unsurprisingly)
08:26:58 <nshepperd> you have to copy the whole thing each time
08:27:14 <izohask> nshepperd: super,  that's what sounds reasonable for me :)
08:27:41 <batchm> hash tables are rather simple.. you have a hashing function that takes a key and produces number, and then you use that number (module current hash length) to fetch the value from an array
08:27:50 <izohask> it this the same reason for all data structures , that have IO versions,generally =
08:27:50 <batchm> modulo*
08:27:53 <izohask> it this the same reason for all data structures , that have IO versions,generally ?
08:27:58 <srhb> izohask: I think the reason given there was wrong.
08:28:01 <StoneToad> izohask: if you want ato avoid IO, hashmaps are pretty good
08:28:02 <izohask> or is there also some other reason , that I'm not aware of ?
08:28:03 <srhb> For the record.
08:28:20 <izohask> (I do not want to avoid, I would like to understand)
08:28:23 <batchm> that being said I don't know how immutable/persistant hash table would work either
08:28:36 <rofer> srhb: Know of any examples that show something like that? I was thinking my top datatype would be a tuple which I thought would require me to change all of my query functions every time I added something new to it.
08:28:49 <rofer> Which definitely seems like poor design, I'm just not seeing the right way to do it.
08:28:52 <ski> perhaps you could envision doing bulky updates on hashtables ?
08:28:53 <tdammers> batchm: as with any data structure, you'd make shallow copies to emulate mutation
08:29:03 <srhb> rofer: Just do something like this: data MyApp = MyApp { firstTable :: ...; secondTable :: ... }
08:29:10 <rofer> And all of the existing acid-state examples all have just one "table"
08:29:14 <tdammers> batchm: the difference is that some data structures lend themselves better to this kind of cumulative updating than others
08:29:16 <rofer> srhb: Aha! Thanks.
08:29:17 <srhb> rofer: Now your queries work on an argument in which they extract their particular table
08:29:29 <srhb> so foo x = doStuff (firstTable x)
08:29:30 <srhb> etc.
08:30:06 <rofer> Yup, I think I see that now. Thank you :)
08:30:09 <srhb> (I don't recall exactly how queries look, but I hope you catch my drift. Otherwise just ask)
08:30:59 <izohask> why do there exist "monadic" HashTables (IO, ST s and all other strange things :) ), if "non-wrapped" structures are just fine ?
08:31:09 * hackagebot respond 0.2.0.0 - process and route HTTP requests and generate responses on top of WAI  http://hackage.haskell.org/package/respond-0.2.0.0 (raptros)
08:31:17 <srhb> izohask: If we remove HashTables from that question, it's usually because of efficiency.
08:31:28 <izohask> so, it is faster ?
08:31:31 <izohask> srhb: so, it is faster ?
08:31:40 <srhb> izohask: In many if not all cases.
08:31:50 <srhb> It's also much more cumbersome and less easy to reason about.
08:31:55 <kuribas> But hashtables are mutable by default, right?
08:31:58 <srhb> Indeed
08:32:10 <srhb> The answer is hashtables is "because what even is a pure hashtable"
08:32:11 <izohask> srhb: due to having "computing context" allowing not to be forced to create copies constantly ?
08:32:27 <rofer> srhb: The one problem I see is taht this means all of my other tables need to know about the compound type which means they all need to know about each other
08:32:28 <srhb> izohask: Sort of kind of. It really depends.
08:32:36 <izohask> (ok sorry for choosing hashtable as examples, it seems it is bad example here )
08:32:38 <kuribas> So the ST monad allows you to use mutable hashtables in a pure function.
08:32:59 <srhb> izohask: For instance, if I had a pure Map of values, a, and I created a new Map b by adding one element to a
08:33:03 <rofer> Oh, actually if i can do mutually recursive imports I think I'm good
08:33:05 <srhb> I'm not really doing any copying
08:33:15 <srhb> izohask: Even without introducing mutability
08:33:42 <srhb> Where mutability really shines is when you need to do in-place stuff.
08:33:49 <kuribas> Would it even make sense to have a hashtable with copying instead of mutation?
08:33:52 <srhb> It's not a huge advantage if you're just adding values to a structure
08:34:00 <srhb> kuribas: Not as far as I can see.
08:34:11 <nshepperd> sure it would make sense
08:34:15 <srhb> But I'm witholding judgment till a smarter person comes along :P
08:34:24 <ski> kuribas : perhaps, with bulky updates
08:34:33 <nshepperd> if you spend a lot of time reading and very little time writing
08:34:40 <srhb> True.
08:34:41 <nshepperd> just like immutable arrays
08:35:09 <srhb> But yeah, then ST really shines. Set up the hashmap or array, and then pretend everything's pure.
08:35:12 <kuribas> nshepperd: good point.
08:36:13 <kuribas> srhb: not just pretend, it will be pure.
08:36:18 <srhb> Yeah. :)
08:36:54 * ski pretends to pretend it's pure
08:37:07 <srhb> Thanks! ;)
08:37:12 <nshepperd> also, I use immutable arrays occasionally to memoize a function
08:37:24 <nshepperd> with the contents lazily computed
08:37:33 <ski> aye, that's handy
08:37:40 <kuribas> ski: isn't that pretentious?
08:37:47 <nshepperd> you could do the same thing with an immutable hashtable, presumably
08:37:51 <srhb> It's pretendious, at least.
08:38:27 <ski> kuribas : possibly
08:39:27 <kuribas> :)
08:39:42 <izohask> Argh... Now I see that hashtables is muttable by default
08:39:51 <JonReed> Why binary trees over hashtables: http://stackoverflow.com/a/18908851/2290598
08:40:16 <izohask> But now I really do not understand why there is that complicated "IO" or "ST s" (monadic) approach
08:40:52 <izohask>  "to have purity"... So to make them seems pure, I guess...
08:41:23 <kuribas> izohask: Because you cannot use IO in a pure function.
08:42:06 * ski remarks that all Haskell functions are pure
08:42:27 <SrPx> Hello, does anyone know a function to generate a bitcoin public address from a private key in Haskell?
08:42:55 <nshepperd> naked mutability is like a naked singularity, it heralds death and destruction
08:43:29 <izohask> kuribas: can you give me quick example, what can be done with IO hashtable, and cannot with "normal hashtable" ?
08:43:31 <kuribas> mutation has a viral effect :)
08:43:37 <indiagreen> SrPx: http://hackage.haskell.org/package/haskoin-crypto-0.0.1.1/docs/Network-Haskoin-Crypto.html
08:43:51 <indiagreen> derivePubKey might be what you want
08:43:59 <ski> `ST' allows delimiting mutation
08:44:13 <kuribas> izohask: not sure what you mean by that.  Since hashtables are mutable by default, an IO hashtable is "normal".
08:44:27 <kuribas> izohask: Because of it's mutability.
08:45:18 <kuribas> izohask: The ST monad is just a clever trick to use mutable structures inside a pure function.
08:46:10 <ifesdjeen> does anyone know whether Control.Monad.STM.atomically will cause it's actions to repeat?
08:46:15 <SrPx> indiagreen: thank you!
08:46:32 <ifesdjeen> e.g. when the one of the values didn't succeed to be written before it got swapped by the other operation
08:46:33 <SrPx> seriously thank you. wow
08:46:56 <indiagreen> SrPx: for future occasions: I just searched for ‚Äúbitcoin‚Äù on Hackage
08:46:57 <ifesdjeen> essentially, the question is whether it's safe to embed side effects into `atomically` performed operations
08:47:13 <SrPx> okay just a quick Haskell question, can I create a Graph class that uses mutable arrays internally, but that is, itself, pure?
08:47:19 <srhb> ifesdjeen: Yes
08:47:35 <srhb> ifesdjeen: If some other transaction modified anything, it will discard and retry
08:47:41 <SrPx> indiagreen: fair enough, I didn't expect it to be so easy considering the amount of time I just spent looking for the same in other languages (:
08:47:43 <ifesdjeen> srhb: ok, perfect
08:47:47 <ifesdjeen> srhb: thanks!
08:47:50 <kuribas> izohask: Or is your question why Monads are necessary for mutable structures?
08:47:51 <srhb> (So don't make the transactions too large if you expect others are touching the datas)
08:48:03 <srhb> Deadlocking on a neverending atomically block is bad :-)
08:48:21 <ifesdjeen> yup, that was my assumption, coming from Clojure background
08:48:24 <ifesdjeen> goodz
08:48:25 <izohask> kuribas: yes
08:48:26 <srhb> :-)
08:48:28 <ifesdjeen> thank you !
08:48:30 <srhb> Sure
08:48:48 <srhb> ifesdjeen: They totally stole it from us, by the way!
08:48:50 * srhb hides
08:49:02 <ski> ifesdjeen : what do you mean by "side effects" here ?
08:49:28 <kuribas> izohask: It's not an easy answer.  I'd recommend to read a good introductory haskell book.
08:49:59 <izohask> kuribas: OK thank you.. Will try once again :)
08:51:00 <srhb> izohask: Perhaps it would make sense to start by playing around with an IORef Int
08:51:02 <kuribas> izohask: Learn yourself a haskell is quite popular (http://learnyouahaskell.com/).  I read "Real World Haskell", which is a bit outdated now, but I can recommend it.
08:51:04 <ifesdjeen> srhb: I don't make distinctions between "us" and "them" :)
08:51:23 <srhb> ifesdjeen: Then you'll forfeit using the word heretic. I'm not ready for that. ;-)
08:51:24 <kuribas> srhb: I think he doesn't really understand the need for monads in haskell well.
08:51:49 <ski> kuribas : you either need uniqueness or something like a monad to not lose equational reasoning while getting update-in-place
08:51:57 <srhb> kuribas: Right, hence why I wanted to start by saying something about ordering in modifying an IORef'ed Int vs. let a = 2; b = a+2; c = ... :-)
08:51:58 <ski> hm
08:52:02 <ski> izohask : ^
08:52:13 <nshepperd> does STM even allow side effects inside an STM block
08:52:18 <kuribas> srhb: yeah
08:52:22 <srhb> STM effects.
08:52:35 <ski> nshepperd : it allows .. what srhb said
08:52:39 <nshepperd> I assume you can't just run random IO actions
08:52:42 <ifesdjeen> yeah
08:52:43 <ski> right
08:52:46 <ifesdjeen> technically
08:52:48 <srhb> You can run any old STM stuff.
08:52:49 <ifesdjeen> you shouldn't tho
08:52:52 <ifesdjeen> hence my question
08:52:54 <ifesdjeen> :)
08:53:19 <ski> ifesdjeen : shouldn't what ?
08:53:25 <srhb> There's nothing wrong with it.
08:53:38 <srhb> The type system prevents you from doing any IO action, so you're safe.
08:53:48 <ifesdjeen> ah ok
08:54:05 <srhb> Unless you unsafePerformIO, and then you're game over anyway.
08:54:07 <kuribas> izohask: http://book.realworldhaskell.org/
08:54:41 <ifesdjeen> ski: nm, i misread a statement from srhb, sorry
08:54:46 <ski> mhm
08:55:04 <nshepperd> right that's what I thought
08:55:27 <nshepperd> the whole point is that inside an atomically block you can safely write to TChans etc
08:57:19 <haskell235> @pl \(a, b) -> (b, a)
08:57:20 <lambdabot> uncurry (flip (,))
08:57:37 <albeit> @pl \x -> f x (g x)
08:57:37 <lambdabot> ap f g
08:59:03 <Skye> Porting?
08:59:23 <ziggystar> I'm trying to use Shelly and I get "couldn't match 'Text'  with 'Data.Text.Internal.Text' when trying `LT.lines <$> readfile ...`, where LT is Data.Text.Lazy as suggested for Shelly. I have no idea what to do.
09:00:48 <artemshitov> ziggystar: Seems like you are trying to apply lazy text function to strict text
09:01:18 <srhb> They really should rename that module...
09:01:26 <ziggystar> Ok, I changed the import to Data.Text (removing lazy). Now it works.
09:01:47 <ziggystar> Why do they suggest using Text.Lazy if their functions don't work with it then?
09:01:50 <srhb> It would be so much more obvious if it said Data.Text.Strict.Internal.Text, like it does with Data.Text.Lazy.Internal.Text ...
09:02:08 <srhb> ziggystar: Is readFile a shelly function?
09:02:21 <ziggystar> Yes. It's readfile (not readFile).
09:02:27 <albeit> @pl \x m -> flip (f x) m <$> g x
09:02:28 <lambdabot> ap (flip . ((<$>) .) . flip . f) g
09:02:28 <srhb> Oh.
09:02:56 <srhb> Well yes, that's silly then.
09:03:21 <artemshitov> ziggystar: They say on Github that Shelly < 1.0 used lazy text, while Shelly > 1.0 uses strict text
09:03:38 <srhb> Ah.
09:03:39 <ziggystar> Hmm, maybe they changed it. I'm now on the hackage packe and there it's saying Data.Text (no Lazy).
09:04:05 <ziggystar> Yeah. This explains it. Was surfing around too many example webpages then.
09:04:12 <srhb> And Data.Text.Text is Data.Text.Internal.Text which is really Data.Text.(Strict, damn it!).Internal.Text ._.
09:04:14 <ski> srhb : it would be nice if GHC wouldn't report long identifiers that refer to modules which aern't in scope
09:04:14 <srhb> Such a mess.
09:04:29 <srhb> ski: That doesn't solve this particular problem though
09:04:45 <srhb> Every new user who uses Text runs into this at some point, and it's so non-obvious.
09:05:20 <ski> (iow, if you're not importing an `Internal' module, then error messages shouldn't refer to it)
09:05:57 <srhb> In reality we just need to parameterize these types somehow, I guess.
09:06:08 <srhb> Needs more ML functors.
09:06:24 <ski> tthat would be nice as well :)
09:06:34 <ReinH> ziggystar: Yeah, I'm not sure why he made the switch but I can ask him.
09:06:48 <Html-01> Someone is here a programmer of unity 3d ? √π
09:07:37 <ziggystar> Nah, I'm new to this and I understand that sometimes you want to change things.
09:07:57 <srhb> ReinH: I think the idea was to start using pipes for everything large, judging by the haddock.
09:11:23 <ReinH> srhb: Ah. I was just going to ask him at work today ;)
09:11:34 <srhb> ReinH: Please do, if it's not too much of a bother :-)
09:11:46 <srhb> Now I'll be wondering anyway. :P
09:11:54 <ReinH> srhb: :)
09:15:10 <ziggystar> Is there any Regex package working on Text? Wiki says all packages support String and ByteString. But they don't mention Text.
09:16:55 <srhb> ziggystar: text-regex-icu afair, but most people just use a parser combinator for everything.
09:17:06 <srhb> text-icu even
09:17:17 <ziggystar> Hmmm. Maybe that's indeed more comfortable.
09:17:42 <srhb> I think it always is if you can get away with it. :)
09:17:56 <ReinH> Yay, new haskell cast with Conal is up :D
09:18:01 <srhb> ReinH: Yay!
09:18:01 <ziggystar> Would have never thought about it, though. Thanks.
09:19:05 <sivteck> http://www.haskellcast.com/episode/009-conal-elliott-on-frp-and-denotational-design/ !!!
09:21:11 * hackagebot lmdb 0.2.2 - Lightning MDB bindings  http://hackage.haskell.org/package/lmdb-0.2.2 (dmbarbour)
09:27:45 <gregnwosu> why doesnt curry support arbitrary length tuples?
09:28:09 <crobbins> gregnwosu: because each tuple is it's own type
09:28:18 <crobbins> it wouldn't be typesafe otherwise
09:28:35 <crobbins> tuples are not like lists, they are not a collection
09:28:40 <crobbins> they are just a group of types
09:28:48 <crobbins> you can't iterate over a tuple
09:31:40 <dfeuer> carter, I've made essentially no progress since yesterday. I went on an 8.8 mile walk, though. I did, however, think of a way to separate out one subproblem, though, by trying to solve the special case of fs<*>xs when |fs|=2. I predict this will still be quite hard enough, but if it works, the rest should probably be fairly straightforward.
09:31:57 <carter> induction
09:32:01 <carter> woot
09:32:31 <carter> doesnt that become efficient concat?
09:32:33 <dfeuer> carter, there are really two problems, both tricksy: 1. There is funny math. 2. There are very weird types.
09:33:00 <petrus> 2qa3ws;'
09:33:13 <dfeuer> carter, that does not.
09:33:26 <dfeuer> I mean, you could do it with just concat, but my aim is to do it differently.
09:36:04 <carter> how is concat not optimal?
09:42:55 <ReinH> You *could* support curry for tuples of arbitrary size with a typeclass. There just isn't much advantage: you will always know the size, so you can always just pick the appropriate curry function.
09:44:08 <dfeuer> carter, concat probably is optimal for that case, but I'm trying to figure out how to do it the other way, which should then generalize to what I actually want.
09:45:15 <dfeuer> Well, <>, not concat, but whatever.
09:46:04 <rofer> Can you use type annotation in GHC? I'm trying to get a random Word8 generator
09:46:40 <clrnd> rofer, a :: Int
09:46:43 <quchen> :t randomIO :: IO Word8
09:46:43 <lambdabot> IO Word8
09:47:05 <clrnd> > randomIO :: Int
09:47:06 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
09:47:07 <lambdabot>              with actual type ‚ÄòGHC.Types.IO a0‚Äô
09:47:09 <rofer> clrnd: Hmmm, must be that I'm doing something else wrong
09:47:22 <clrnd> > randomIO :: IO Int
09:47:23 <lambdabot>  <IO Int>
09:48:29 <rofer> The latest thing I've tried is: let (wordGen :: RandomGen g => (Word8, g)) = random stdGen
09:48:41 <rofer> Which causes a complaint about scoped type variables
09:49:13 <Myrl> Hi guys.
09:49:20 <shiona> hello
09:49:38 <clrnd> > let w = random stdGen in w :: RandomGen g => (Word8, g)
09:49:39 <lambdabot>  Not in scope: ‚ÄòstdGen‚Äô
09:50:14 <quchen> :t let randomInt :: IO Int; randomInt = randomIO in randomInt
09:50:15 <lambdabot> IO Int
09:50:18 <clrnd> > let w = randomIO in w :: IO Int
09:50:19 <lambdabot>  <IO Int>
09:50:52 <Myrl> `((==) $ show 11) $` reverse $ show 11` Can I remove the parentheses even further?
09:51:18 <crobbins> Myrl: pipe it into hlint, it'll tell you
09:51:25 <quchen> That's nt valid Haskell, Myrl.
09:51:52 <Myrl> quchen: I tested it and it is.
09:51:56 <rofer> clrnd: Thanks 'let w = random stdGen in w :: (Word8, StdGen)' is what I wanted
09:52:00 <dfeuer> Myrl, that's utterly disgusting anyway. WHY?
09:52:12 <clrnd> rofer, no problem :)
09:52:13 <quchen> show 11 == reverse (show 11) -- That is valid Haskell, or at least not terribly invalid.
09:52:14 <Myrl> dfeuer: I dunno.
09:52:22 <quchen> Myrl: Your backticks are illegal.
09:52:31 <quchen> Maybe your client added them for some reason.
09:52:34 <gcganley> chrisdone: is there a reason you have shm hard linked to haskell-src-exts == 1.15.* . Just wondering because 1.16.0 came out and now shm and ghc-mod conflict
09:53:01 <Myrl> quchen: I added them to signify code.
09:53:20 <Myrl> quchen: What should I use instead to signify code?
09:53:22 <crobbins> Myrl: but you had a tick in the middle of the expression, so it was confusing
09:53:33 <dfeuer> Very confusing.
09:53:46 <quchen> Myrl: Backticks are fine to signify code, but when you put a third one in the middle it makes things confusing.
09:53:55 <quchen> The snippet above says "$`" in the middle.
09:54:05 <Myrl> quchen: Oh, the $` there was a typo.
09:54:13 <Myrl> Sorry.
09:54:14 <gcganley> @tell chrisdone is there a reason you have shm linked to haskell-src-exts version 1.15.* . Just curious because now ghc-mod and shm use different versions of haskell-src-exts
09:54:14 <lambdabot> Consider it noted.
09:54:32 <quchen> But dfeuer's criticism is probably very relevant ;-)
09:55:02 <jmct> dreams: you around?
09:56:29 <dfeuer> quchen, I'll admit that I used @pl to figure out how to handle coercions in Data.Functor.Identity.
09:56:38 <quchen> You monster.
09:57:02 <quchen> Now let me look up what could possibly be complicated in Identity
09:57:05 <dfeuer> It's a lot easier to get the types to check using things similar to edwardk's .# and #.
09:57:19 <ReinH> dfeuer: Where and what are .# and #.?
09:57:23 <dfeuer> But then expressing things using those requires some pointlessness.
09:58:08 <dfeuer> ReinH, I can't claim to understand them in their original context, but in the narrower forms I used, #. is like composition but ignores the value of its left argument, using only its type for coercion, while .# does the same to its right argument.
09:58:16 <quchen> dfeuer: I don't see any coercions there. Are you talking about new stuff you fused (pun pun) into HEAD?
09:58:43 <dfeuer> quchen, yeah, it's new stuff. hvr started it, and I did some more.
09:58:51 <nitrix-work> Hi
09:58:58 <nitrix-work> Is there cleaner ways to write: maybe (return ()) Prelude.putStrLn blockId
09:59:08 <quchen> dfeuer: You started working a lot on GHC, is there a particular reason for this?
09:59:23 <quchen> Doing a thesis on fusion or something?
09:59:25 <dfeuer> quchen, I have to learn programming somehow, right?
09:59:27 <dfeuer> No.
09:59:36 <michi7x7> @pl \x -> show x == reverse (show x)
09:59:36 <lambdabot> liftM2 (==) show (reverse . show)
09:59:50 <quchen> ‡≤†_‡≤†
10:00:10 <ski> @check \x -> show x == reverse (show x)
10:00:12 <lambdabot>  *** Failed! Falsifiable (after 1 test):
10:00:12 <lambdabot>  ()
10:00:25 <dfeuer> quchen, I've lately been working on Data.Sequence, and if you want to help, that would be much appreciated!
10:00:36 <quchen> ?check \xs -> xs == reverse xs -- ski
10:00:37 <lambdabot>  <hint>:1:59:
10:00:38 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
10:00:41 <quchen> ?check \xs -> xs == reverse xs
10:00:42 <lambdabot>  +++ OK, passed 100 tests.
10:01:15 <dfeuer> quchen, why would that pass?
10:01:25 <quchen> dfeuer: xs defaults to [()]
10:01:30 <dfeuer> Ooooooo.
10:01:31 <quchen> xs' type, that is
10:01:44 <quchen> dfeuer: I haven't had much time for Haskell due to moving, getting a new job etc. What are you doing with Data.Sequence?
10:01:45 <dfeuer> Yuck.
10:01:50 <nitrix-work> Is there a function that returns an `IO ()` but does no side effects?
10:01:55 <quchen> :t return ()
10:01:56 <lambdabot> Monad m => m ()
10:01:58 <hiptobecubic> I'd have expected a failure to resolve due to ambiguous types
10:02:02 <nitrix-work> Other than manually writing return () ?
10:02:08 <quchen> hiptobecubic: I think Lambdabot has extended defaults.
10:02:20 <michi7x7> quchen: liftM2 ... List Monad?
10:02:29 <quchen> No, Reader.
10:02:47 <quchen> liftA2 u f g x = u (f x) (g x)
10:02:53 <ski> nitrix-work : no function does side effects in Haskell
10:02:53 <dfeuer> quchen, well, I've done a new implementation of zipWith, which is nicely lazy in performance, and then Milan Straka and I used the same approach to reimplement mapWithIndex and make a new function fromFunction.
10:03:03 <michi7x7> ah, that makes sense
10:03:12 <nitrix-work> ski: It's fine, I wrote a simple noop = return ()
10:03:23 <ski> nitrix-work : i would call it `done' :)
10:03:39 <quchen> I would call it "return ()".
10:04:03 * quchen is a naming genius O:-)
10:04:08 * ski notes that it isn't possible to use spaces or brackets in identifiers in Haskell ;)
10:04:17 <nitrix-work> I like `done`. It's a good name for an edge condition.
10:04:22 <dfeuer> quchen, the old zip was monolithic, so zipWith f xs ys `index` (min (length xs) (length ys) - 1) would've been O(min {|xs|,|ys|}).  Now it'd be O(1).
10:04:49 <ski> nitrix-work : i hope you're also aware of `when' and `unless'
10:04:54 <michi7x7> return must be the worst name in the haskell standard... good thing that we can use pure in the future
10:04:56 <dfeuer> The constant factors are also much improved for monolithic use.
10:05:02 <quchen> dfeuer: Interesting. I haven't used Data.Sequence much to be honest.
10:05:16 <quchen> michi7x7: return is the worst name in the C standard, because it has nothing to do with monads there
10:05:43 <dfeuer> I've been working on doing the same thing for <*>. I can get the asymptotics right using the same approach, but the constant factors suck. So now I'm trying to work out an entirely different approach. If that approach is *possible*, it will perform extremely well.
10:05:55 <dfeuer> Whether it's possible is another question.
10:05:57 <quchen> dfeuer: I mostly abuse Data.Sequence to get a cheap queue and don't use much of the API otherwise. I might want to change that.
10:06:31 <dfeuer> Yes, quchen, it makes for a crappy queue, somewhere around twice as slow as a (persistently amortized) Banker's queue.
10:06:36 <quchen> dfeuer: Another one that gave me trouble a couple of weeks ago was "why isn't there traverseSet in Data.Set"
10:07:04 <dfeuer> quchen, I'm not sure what that might mean.
10:07:29 <quchen> dfeuer: Well you can't make a Set traversable because of the type system (requiring Ord in the traversable instance which you can't do).
10:07:44 <quchen> But you can easily define "traverseSet f = fromList . traverse f . toList"
10:08:00 <dfeuer> Ah.
10:08:02 <quchen> Which should do what you'd expect, shouldn't it?
10:08:08 <quchen> Same thing for sequence
10:08:28 <quchen> I've had numerous cases in which I wanted to assemble some actions in a Set for efficiency
10:08:33 <quchen> And then I couldn't traverse those
10:08:41 <dfeuer> quchen, I don't understand traversals too well, but I don't see any reason for a special traverseSet to be meaningfully faster than the implementation you just gave.
10:08:48 <dfeuer> A sequence is already Traversable.
10:09:09 <quchen> Right, because Sequence is fully polymorphic in its contents.
10:09:13 <michi7x7> quchen: well... C was first, and you really "return" smth in C. In Haskell you only inject
10:09:42 <quchen> There is no name for "return" that isn't wrong in some context.
10:09:59 <quchen> Pure is wrong, return is wrong, inject is wrong. Luckily, if everything is wrong, nothing is wrong.
10:10:24 <michi7x7> I like pure, because nobody else uses it
10:10:26 <dfeuer> quchen, the only advantage to a specialized traverseSet would be if knowing the size of the resulting set somehow made it faster to construct it, but I don't think that's the case (unlike for sequences).
10:10:26 <quchen> Œ∑ would be nice maybe.
10:10:33 <ski> quchen : s/polymorphic/parametric/
10:10:48 <dfeuer> quchen, that's very hard to type. Also not too easy to read.
10:10:49 <quchen> ski: Oh. Okay. Why?
10:11:18 <ski> quchen : a polymorphic type would be somthing like e.g. `Const :: forall k. * -> k -> *'
10:11:45 <quchen> Ah, I see.
10:11:52 <dfeuer> quchen, why is polymorphism now only at the kind level?
10:11:55 <ski> @kind Seq.Seq
10:11:56 <lambdabot> * -> *
10:12:05 <ski> see, it's kind isn't universal
10:12:18 <quchen> monokinded, but values of type Seq a are polymorphic.
10:12:25 <quchen> Correcter?
10:12:28 <ski> (iow, `Seq' is a monomorphic type)
10:12:45 <ski> a value of type `Seq Integer' is not polymorphic
10:13:09 <ski> a value of type `forall a. Seq ([a] -> [a])' would be polymorphic
10:13:40 <ski> `Seq' itself is parametric, aka is a type function
10:13:52 <dfeuer> Hmm.
10:14:18 <dfeuer> Sorry, ski, I guess I need to get more learning in the typish realm :-/
10:14:48 <quchen> I'm going to learn something about bouldering now, by going bouldering. See you later!
10:15:09 <quchen> On my bike ride I'll reflect upon ski's comments. :-)
10:15:21 <ski> dfeuer : i just think it's easier to understand things if we don't confuse terminology
10:15:46 <dfeuer> ski, oh, you're surely right. I just keep running into things I don't even understand as well as I thought I did.
10:15:53 <ski> the above `Const' would be polymorphic in exactly the same way that `length' (of type `forall a. [a] -> Int') is polymorphic
10:16:11 <lpvb> Does ocaml/F# feel very limiting without hkt?
10:16:28 <ski> the only difference is that `Const' lives on the type level, but `length' on the value level
10:16:39 <ski> "hkt" ?
10:16:49 <jdiez> hi guys, quick question, I'm designing the types for a irc parser; I can either declare each sequence type individually and then create a `Sequence` type or use only one type: https://gist.github.com/jdiez17/99b99d378128d9e53e18
10:17:02 <jdiez> however when I use only one type I can't enforce the constructor in the type signature
10:17:04 <dfeuer> ski, higher-kinded types?
10:17:08 <dfeuer> Just a guess.
10:17:15 <jdiez> i.e I can't say "respondToPrivmsg :: Message -> Bla"
10:17:37 <jdiez> but I don't like having to "tag" each possible message in a joint data type like sequence in a.hs in that gist
10:17:39 <jdiez> any ideas?
10:17:45 <lpvb> higher kinded types
10:18:11 <ski> SML also doesn't have higher-order types
10:18:47 <ski> lpvb : to some extent you can "work around" it by ML module functors (not present in F# though, alas !)
10:19:41 <ski> (ML module functors are great, i wish Haskell had them. it's just that when used to emulate higher-order types, they're somewhat limiting)
10:20:51 <lpvb> So how do you get by without functors/monads in those language? Emulate them?
10:21:22 <lpvb> or just rework the code to forgo them
10:21:44 <johnw> ski: I like them sometimes, when it saves adding a constraint absolutely everywhere, but otherwise they don't seem to win too much over typeclasses
10:22:04 <ski> jdiez : fyi, `deriving (Show)' can be simplified to `deriving Show'
10:22:12 <ski> jdiez : you could possibly use a GADT ..
10:22:13 <dfeuer> lpvb, some people even decided to write a version of Haskell without the typeclass system, getting many of its features back by implementing something like ML's functor system on top. It was a bit ... odd.
10:22:15 <jdiez> ski: ah, thanks.
10:22:18 <jdiez> skarn: GADT?
10:22:34 <ski> Generalized Algebraic Data Type
10:22:44 <jdiez> ski: I don't know what that is; how would it help?
10:22:49 <clrnd> ocharles, thank you for the "24 days of" series :D
10:22:59 <johnw> ocharles++
10:23:00 <ocharles> clrnd: you're welcome!
10:23:04 <ocharles> glad you're enjoying it :)
10:23:10 <johnw> yes, thank you so much ollie!  for doing it, and for being consistent
10:23:18 <johnw> that latter is a rare commodity
10:23:22 <jdiez> ski: basically, I have two parsers, with types `Parser Message` and `Parser Ping` respectively; I want to combine them into a Parser Sequence
10:23:46 <clrnd> ocharles, hey, how you introduced type families and multiparamtypeclasses, step by step and showing WHY you needed them, made me get them finally
10:23:54 <johnw> jdiez: do you have a Sequence constructor that can take a Message and a Ping and join them?
10:24:03 <ocharles> oh, i'm glad you liked that! I was worried that my examples were a bit bland
10:24:08 <johnw> if so, you can just use the applicative
10:24:14 <jdiez> johnw: I have "data Sequence = M Message | P Ping"
10:24:15 <ocharles> but sometimes keeping the examples simple means we can focus on the details
10:24:22 <johnw> ah, then:
10:24:39 <johnw> (M <$> parseMessage) <|> (P <$> parsePing)
10:24:46 <johnw> tries to parse first a message, then a ping
10:24:47 <ski>   data Sequence t
10:24:48 <jdiez> hmm
10:24:52 <ski>     where
10:25:14 <ski>     Message :: {sender :: String,...} -> Sequence MessageT
10:25:38 <jdiez> johnw: ah, that finally made it click. I was getting all sorts of weird errors without the brackets. thanks.
10:25:38 <ski>     Ping    :: {response :: String}   -> Sequence PingT
10:25:44 <ski> jdiez : like that
10:25:59 <AleksejsHome> cabal: There is no package named 'cabal-install'; but when I try cabal update, I get "Skipping download: Local and remote files match."
10:26:13 <johnw> i've always found using GADTs with parsers to be rather tricky
10:26:14 <ski> jdiez : you'll need to add `{-# LANGUAGE GADTs #-}' to the first line of your module to enable the `GADTs' language extension
10:26:14 <jdiez> ski: okay, sounds overkill... I think I'll stick with the Sequence constructor, but thanks a lot for your time anyway :)
10:26:56 <ski> jdiez : this way, you'd have `respondToPrivmsg :: Sequence MessageT -> Bla', and it would be a type error to try to pass it a ping response
10:27:39 <jdiez> ski: yeah, sounds very powerful but I think I'll stick to algebraic data types for now
10:27:58 <jdiez> until I get around learning GADTs
10:28:01 * izohask
10:28:56 <AleksejsHome> anyone?
10:29:37 <johnw> AleksejsHome: You haven't told us what command it is you're executing to get that error
10:30:34 <ski> lpvb : instead of defining `data Foo (ref :: * -> *) = ..ref..; blah :: Foo ref -> ..ref..' you define a module interface specifying (at least) `Ref :: * -> *', and then you make a module function (an (ML) functor) that when applies to a module of the earlier interface will build `data Foo = ..Ref..; blah :: Foo -> ..Ref..'
10:30:52 <ski> lpvb : some patterns of usages can't (at least easily) be captured by this, though
10:31:18 <AleksejsHome> johnw: cabal install cabal-install
10:32:07 <johnw> AleksejsHome:  interesting‚Ä¶ What operating system are you on?
10:32:39 <sivteck> also what is cabal --version
10:33:36 <AleksejsHome> johnw: ubuntu. It's a DO droplet. On my local ubuntu everything works
10:34:59 <AleksejsHome> 1.20.0.3
10:35:35 <sivteck> that is the latest cabal-install
10:40:55 <sivteck> AleksejsHome, the error "Skipping download: Local and remote files match." is because you have recently updated cabal package database. try installing some other package
10:54:13 <fizbin> @pl \f x y = y x
10:54:13 <lambdabot> (line 1, column 8):
10:54:13 <lambdabot> unexpected "="
10:54:13 <lambdabot> expecting pattern or "->"
10:56:15 * hackagebot respond 1.0.0 - process and route HTTP requests and generate responses on top of WAI  http://hackage.haskell.org/package/respond-1.0.0 (raptros)
10:56:28 <ski> @pl \f x y -> y x
10:56:28 <lambdabot> const (flip id)
10:56:33 <ski> @pl f x y = y x
10:56:33 <lambdabot> f = flip id
10:56:39 <ski> fizbin ?
10:59:18 <ski> @let data ABT = AT | BT deriving Show
10:59:19 <lambdabot>  Defined.
10:59:21 <ski> @let data AB :: ABT -> * where {A :: AB AT; B :: AB BT}; deriving instance Show (AB ab)
10:59:22 <lambdabot>  Defined.
10:59:47 <ski> > case A of A -> (); B -> ()
10:59:48 <ski> @type \ab -> case ab of A -> (); B -> ()
10:59:48 <lambdabot>  Couldn't match type ‚Äò'L.AT‚Äô with ‚Äò'L.BT‚Äô
10:59:49 <lambdabot>  Inaccessible code in
10:59:49 <lambdabot>    a pattern with constructor L.B :: L.AB 'L.BT, in a case alternative
10:59:49 <lambdabot>     Couldn't match expected type ‚Äòt‚Äô with actual type ‚Äò()‚Äô
10:59:49 <lambdabot>       ‚Äòt‚Äô is untouchable
10:59:50 <lambdabot>         inside the constraints (t1 ~ 'AT)
11:00:21 <ski> is there a nice way around this ?
11:02:22 <zipper> I have issues seeing how "let fib = 0:1: zipWith (+) fib tail (fibs) in fib" moves to the third element onward of the list.
11:02:42 <zipper> > let fib = 0:1: zipWith (+) fib tail (fibs) in fib
11:02:43 <lambdabot>  Not in scope: ‚Äòfibs‚Äô
11:02:43 <lambdabot>  Perhaps you meant ‚Äòfib‚Äô (line 1)
11:02:44 <johnw> zipper: the parens are wrong in what you typed
11:02:44 <jfischoff> ski: would added a type sig help?
11:02:52 <jfischoff> s/added/adding
11:03:07 <zipper> > let fib = 0:1: zipWith (+) fib (tail fib) in fib
11:03:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:03:09 <johnw> let fibs = 1:1:zipWith (+) fibs (tail fibs)
11:03:16 <zipper> Yes
11:03:29 <ski> jfischoff : that would require me to pass the scrutinee as an argument to the relevant definition
11:03:37 <fizbin> ski: Yeah, was looking for "flip id". Found it in private lambdabot chat
11:03:43 <zipper> johnw: So as I was saying I don't see how it's moving to the third element in the list and so forth.
11:03:49 <zipper> Saizan: ^
11:03:57 <johnw> @src zipWith
11:03:57 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
11:03:57 <lambdabot> zipWith _ _      _      = []
11:04:18 <zipper> johnw: I get how zipWith works
11:04:19 <johnw> due to laziness, it's computing each "f a b" in turn, as you are printing the values
11:04:21 <ski> jfischoff : iow, i have something like `x = case y of ...', and i'd like to avoid having to make `y' an argument of `x'
11:04:34 <zipper> johnw: I don't see how the recursion is moving to the third element
11:04:52 <zipper> third element onwards
11:04:54 <johnw> the third element is the result of the first level of evaluation of the zipWith
11:05:35 <ski>      let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib
11:05:45 <zipper> johnw: Okay but then what about the fourth?
11:05:57 <johnw> the second level of evaluation
11:05:57 <ski>   =  let fib = 0 : fib_0; fib_0 = 1 : zipWith (+) fib (tail fib) in fib
11:06:02 <johnw> maybe I'm not understanding the question; listen to ski
11:06:15 * hackagebot containers 0.5.6.0 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.6.0 (JohanTibell)
11:06:30 <zipper> johnw: I see the third element is a result of zipWith (+) fibs (tail fibs) where fibs is (x:y_)
11:06:34 <ski>   =  let fib = 0 : fib_0; fib_0 = 1 : zipWith (+) fib (tail fib) in 0 : fib_0
11:06:47 <zipper> but I can't see the fouth element being generated.
11:06:53 <ski>   =  let fib = 0 : fib_0; fib_0 = 1 : fib_1; fib_1 = 1 : zipWith (+) fib (tail fib) in 0 : fib_0
11:07:15 <ReinH> srhb: So the switch to strict text is just for better interop generally since strict is the default
11:07:19 <ski>   =  let fib = 0 : fib_0; fib_0 = 1 : fib_1; fib_1 = 1 : zipWith (+) (0 : fib_0) (tail fib) in 0 : fib_0
11:07:26 <srhb> ReinH: Oh, okay.
11:07:28 <zipper> ski: Could we go to PM?
11:07:31 <srhb> ReinH: Thanks. :)
11:07:34 <ReinH> srhb: :)
11:07:42 <ski> zipper : move to #haskell-overflow ?
11:07:48 <zipper> ski: Okay
11:08:00 <ReinH> srhb: adding pipes is unrelated, and motivated by use cases involving large stdout streams
11:08:05 <ReinH> (as you might expect)
11:08:23 <srhb> I thought those would overlap with lazy text as well, but ah well.
11:09:45 <ReinH> srhb: well, I suppose they are related, but adding pipes didn't directly motivate the switch to strict text.
11:09:51 <srhb> Indeed.
11:10:40 <johnw> what is the "switch to strict text"?
11:12:38 <ReinH> johnw: in Shelly 1.0
11:13:32 <johnw> ahh
11:14:55 <johnw> ReinH: did you work on shelly 1.0?
11:17:35 <ReinH> johnw: No but I Greg is my coworker.
11:17:40 <ReinH> s/I //
11:17:56 <johnw> oh, I didn't know he went to AlephCloud?
11:18:04 <ReinH> Just recently, yeah.
11:18:06 <johnw> say hi from me!  I saw him not long ago here in Chicago
11:18:10 <ReinH> Cool
11:21:19 <ReinH> johnw: New haskellcast with Conal btw.
11:21:29 <johnw> ah, nice!
11:21:52 <ReinH> Thought you might be interested
11:22:28 <johnw> of course
11:22:35 <johnw> not in iTunes yet
11:23:04 <rofer> Is there a better way I could write this? 'let initRandState :: (Word8, StdGen); initRandState = random gen'
11:23:33 <rofer> I want to write 'let initRandState :: (Word8, StdGen) = random gen', but apparently that's not correct
11:24:40 <monochrom> the first way is already the best way
11:25:02 <rofer> Okay, just thought there might be a nicer way. Thanks.
11:25:28 <geekosaur> definitions of "nicer" vary
11:25:40 <artemshitov> rofer: `let initRandState = random gen :: (Word8, StdGen)` ?
11:25:43 <rofer> Yeah, I figured as much.
11:25:56 <jle`> yeah i usually do artemshitov's way
11:26:06 <jle`> well
11:26:10 <jle`> it depends on the context
11:26:50 <rofer> artemshitov: Ah! That's what I was looking for.
11:30:19 <hsk4> Did anyone here come to Haskell from imperative programming, find it impossible to do anything in Haskell at first (e.g., because of difficulties with understanding how to use monads), and eventually arrive at a point where you can comfortably do virtually any programming project in Haskell?
11:30:43 <Ulrar> I'
11:30:57 <Ulrar> m still figuring out monads, but may be some day :D
11:31:29 <johnw> hsk4: I did exactly that
11:31:35 <ReinH> hsk4: Pretty much.
11:31:37 <hsk4> Same here, I don't have a clue. It seems so convoluted...
11:31:42 <monochrom> I came from imperative programming. but I did not find anything impossible at first.
11:31:47 <johnw> hsk4: it sure does, in the beginning
11:32:14 <ReinH> It helps if you treat it like a foreign language rather than a new dialect of a language you already know.
11:32:16 <jmcarthur> i came from imperative programming, but clicked with haskell pretty quickly. this is not the same story as everybody else though, obviously.
11:32:21 <monochrom> I learned IO before I learned monads.
11:32:21 <jle`> i did more or less that but i don't think there was a point whre i thought everything was impossible
11:32:21 <ReinH> Expect things to not make sense at first and keep working at it
11:32:38 <jle`> i guess i'm an optimistic person
11:32:48 <hsk4> I've thought about giving up so often... for some reason I'm still trying
11:32:50 <rofer> hackagebot: I think I'm getting there. Still hanging out here asking lots of questions, but I'm writing a networked game and thus far things are going well
11:33:06 <rofer> Woops, that was supposed to be to hsk4
11:33:20 <monochrom> read my http://www.vex.net/~trebla/haskell/IO.xhtml
11:34:17 <hsk4> monochrom: thanks bookmarked
11:34:56 <hsk4> lol these plain HTML pages have a certain allure to them
11:34:59 <johnw> hsk4: I found it easier to pick a library, and pick a task, and just to focus on the subset of Haskell I needed to get that task done; success in a small areas inspires efforts to grow
11:35:14 <hsk4> johnw: good idea
11:35:40 <ReinH> Also it's important to have successes, however small
11:35:48 <ReinH> Morale is a real factor in learning.
11:36:26 <hsk4> But now that you guys know Haskell, do you guys clearly see the benefits of Haskell?
11:36:26 <johnw> ReinH: in life in fact :)
11:36:32 <johnw> hsk4: absolutely
11:36:47 <hsk4> ok, i hope i'll get there
11:36:52 <johnw> you will, without a doubt
11:37:15 <ReinH> johnw: indeed
11:37:18 <rofer> hsk4: I can't claim I know Haskell, but this project is really fun because I get to write it in Haskell
11:37:26 <rofer> Even though I've yet to get it to do anything particularly interesting
11:37:55 <rofer> Also, when I was first starting out I did a bunch of these: https://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
11:38:57 <rofer> These short so you can quickly get a sense of accomplishment and there are solutions so you can see better ways to do things too
11:39:06 <hsk4> nice, bookmarked
11:40:17 <josephle> as an amusing aside, when I groked monads, I used monads everywhere. Then I started the process of learning how to not use monads
11:40:24 <rofer> heh
11:40:46 <rofer> I'm somewhere in between being able to use monads and writing my own monad tutorial
11:41:19 <monochrom> wrtie a monoid tutorial first
11:42:25 <hsk4> lol
11:42:49 <hsk4> so far I've enjoyed these monad tutorials: http://mvanier.livejournal.com
11:43:25 <johnw> monads are the ultimate hipster subject: you can react with disdain to nearly everything written or said about them
11:44:54 <hsk4> why?
11:44:57 <johnw> I can imagine a zen master riddling a student with: "the true monad is that of which no one has ever spoken; now explain it"
11:45:44 <monochrom> that is too Platonist.
11:45:57 <monochrom> I'm a formalist. the true monad is a bunch of axioms.
11:46:36 <johnw> true
11:46:38 <c_wraith> honestly, monads aren't really important.  They're a handy pattern, but understanding monads is as important to knowing Haskell as understanding the factory pattern is to knowing java.
11:46:46 <monochrom> but I'm in agreement with the Zenist view that there is nothing to explain.
11:46:49 <johnw> in that case, explaining what they *are* is trivial, but why they are important is harder to convey
11:48:00 <hsk4> Do you think there are a lot of programmers who will be left behind, unable to break into Haskell?
11:48:07 <johnw> I don't think so at all
11:48:15 <hsk4> ok
11:48:21 <johnw> i think the status quo has created a great deal of mential inertia
11:48:28 <johnw> but the next generation will not be nearly as burdened
11:48:39 <monochrom> on its importance, I'm an individualist. each person decides for himself/herself whether it's important.
11:48:43 <johnw> Haskell is simpler in many ways
11:49:07 <c_wraith> It's amazing how much the lack of inheritence simplifies haskell.
11:49:08 <monochrom> for example my favourite hair stylist would not find monad important; but he would not find Haskell important either.
11:49:20 <johnw>  monochrom: point
11:49:24 <monochrom> but both him and I agree that my haircut is important to me!
11:49:56 <c_wraith> To be contrary, I don't find my haircut very important to me.  Though I might need to care more since my girlfriend said my last haircut wasn't acceptable.
11:50:30 <johnw> c_wraith: it's also amazing how I never think of wanting inheritance now, ever
11:50:37 <monochrom> oh, my haircut is important in the sense that it's important to keep it short so I don't have to do anything :)
11:50:59 <c_wraith> monochrom: that's my only criterion, but apparently my girlfriend has more criteria. :P
11:51:20 <ReinH>  monochrom Funny, I keep it long so I don't have to do anything.
11:51:36 <Ulrar> ReinH: A lot harder to dry
11:51:38 <sinelaw> subtyping is of the devil. my opinion changed that much to the worse after finding out how complicated it is to describe precisely
11:51:41 <ReinH> Ulrar: there is that.
11:51:50 <johnw> ah, how monads allow our conversations to diverge to just about anywhere...
11:52:03 <monochrom> ah, there are other requirements such as cleaniness I haven't said. but I digress.
11:52:18 <ReinH> The closest thing to subtyping that I semi-regularly want is extensible records.
11:52:47 <sinelaw> ReinH, even that's far out. row-type polymorphism is enough for me
11:53:09 <ReinH> Yeah...
11:55:22 <monochrom> inheritance can be good. Haskell type classes have some kind of inheritance, in fact multiple inheritance too. you have the full power of DAG. I conclude that something went wrong with the OOP's execution of inheritance, rather than inheritance per se.
11:56:29 <clrnd> anyone feel like explaining why the hype for extensible effects and just what the hell are they?
11:56:38 <monochrom> perhaps it's because OOP uses inheritance for the wrong purpose. or for the right purpose but some detail goes wrong.
11:56:43 <johnw> clrnd:  there a lot of good papers written on that subject
11:57:09 <clrnd> I'm reading the most known "An Alternative to Monad trans."
11:57:10 <johnw> http://okmij.org/ftp/Haskell/extensible/
11:57:16 <clrnd> but I err, don't see it
11:57:17 <monochrom> I haven't seen any hype on it lately. a year ago sure.
11:57:26 <johnw>  lots of material there
11:57:29 <sinelaw> monochrom, I don't see type classes as a form of inheritance. It's more like interfaces
11:57:39 <johnw> Idris still hypes it in a lot of its tutorials and presentations
11:57:46 <sinelaw> Interface "inheritance" is not the same as class inheritance
11:57:59 <johnw> right, class inheritance is more "is a", which is a fairly rigid relationship
11:58:07 <Crazypyro> When I try to install cabal from bootstrap.sh script that comes with it, it just gets Killed after compiling 76 of 76 in Distribution.Simple on "Linking Setup ..." then I get "Error during cabal-install bootstrap compiling the Setup script failed"
11:58:49 <clrnd> are they too based on a category theory construct?
11:58:54 <johnw> Crazypyro:  are you running out of memory?
11:58:59 <sinelaw> interfaces extending each other is just building a larger API contract, not mixing up implementations
11:59:08 <sinelaw>  /s/just//
11:59:20 <fragamus> monochrom: you said "OOP's"
11:59:30 <monochrom> yes, I said it.
11:59:41 <johnw> clrnd: from that webpage I linked: "[extensible effects] solves the long-standing problem of combining effects without imposing restrictions on their interactions (such as static ordering)"
12:00:11 <clrnd> johnw, yeah I can understand that far, I can see how transformers are inherently stacked
12:00:16 <fragamus> monochrom: I think it is somehow fittingly applied to OOP
12:00:38 <monochrom> oh, but I don't like to play letter games like that.
12:00:48 <johnw> so, with extensible effects you can obtain a sort of "effects algebra" which can express some pretty cool things, like what Idris does for statically typing protocols
12:01:08 <sinelaw> does anyone know of a functional language with iso-recursive typing?
12:01:19 <johnw> whereas monad transformers are pretty much you get what you get
12:01:25 <Saizan> sinelaw: haskell?
12:01:33 <SvenskFisk> Is there a quick way to do haskell profiling without compiling? Some equivalent to 'python -m cProfile program.py'? All sources I've found have three steps or more, compile with a couple flags, run with another couple flags, then look at the output in the .prof file. Any alternatives that don't require as much work?
12:01:40 <sinelaw> Saizan, sorry, I meant the other. Equi-recursive
12:01:40 <monochrom> I disdain things like "ASSUME makes an ASS of U and ME"
12:01:55 <Saizan> sinelaw: ocaml has a flag for it, i think
12:02:06 <sinelaw> Saizan, -frectypes
12:02:07 <johnw> SvenskFisk:  no, everything must be built with profiling enabled, and modules you're interested in need to have cost center annotations either added automatically, or by using specific annotations
12:02:09 <sinelaw> or so
12:02:09 <sinelaw> yeah
12:02:27 <sinelaw> Saizan, is it actually used though?
12:02:38 <sinelaw> seems like that opens up a can of worms
12:04:22 <johnw>  I'm just realizing right now that I've never seen worms sold in cans
12:04:29 <Crazypyro> johnw, guess so, I had to kill off some stuff and it got further, guess I just can't compile it on a small DO server
12:04:40 <johnw> Crazypyro: nope, the OOM killer is on the job
12:04:58 <johnw> Crazypyro:  someone else was in here yesterday with the exact same problem trying to do it on a small DO server
12:05:23 <Crazypyro> Haha, seems silly that it can't tbh
12:06:00 <johnw> you're welcome to analyze GHC and find out how to reduce its memory footprint for us :)
12:07:31 <Saizan> sinelaw: dunno, probably not
12:07:41 <Crazypyro> Its not like everyone even had 512MB of memory a decade ago
12:07:50 <Benzi-Junior> hey I how do I filter over a list [(a,b,c)]
12:07:51 <ReinH> monochrom: Assumptions make an ASS out of U and MPTIONS?
12:08:43 <ReinH> Benzi-Junior: with a predicate function of type (a,b,c) -> Bool
12:09:19 <sinelaw> ReinH, don't forget ASSURANCES
12:09:38 <sinelaw> or for the algebraicly inclined, ASSURING
12:09:42 <Benzi-Junior> nvm found out what I was doing wrong
12:10:03 <ReinH> sinelaw: heh
12:10:52 <monochrom> I remember the days MLton was promoted as "whole-program analyses and optimizations are awesome. it only takes 64MB of memory on most examples." bear in mind that at that time most PCs had just 16MB memory. (fortunately, servers at schools accomodated MLton's footprint pretty comfortably.)
12:11:50 <sinelaw> incidentally, why is mlton trying to compile everything (all the base libs) every time I run it? is that normal?
12:12:16 <monochrom> I don't know whether it's related to whole-program optimizations.
12:12:49 <sinelaw> it's extremely slow because of that
12:13:06 <monochrom> but really, if you're going to do whole-program optimizations, the difference in costs between "parse again" and "don't parse again" diminishes.
12:13:30 <lpaste> ski pasted ‚Äú`fibs' reduction trace‚Äù at http://lpaste.net/116547
12:13:39 <ski> zipper ^
12:13:57 <Crazypyro> Is a gig enough for cabal? x)
12:14:26 <sinelaw> monochrom, when it needs to open 1039 files and parse them, rather than read stuff from one library, it's not worth it
12:23:08 <ReinH> Crazypyro: depends on what cabal is doing.
12:25:57 <Crazypyro> ReinH, cabal install cabal-install takes over 800mb
12:26:24 <ReinH> Crazypyro: I am not disagreeing with you
12:26:40 <Crazypyro> ReinH, Well that's what I was referring to cabal doing. :)
12:27:00 <sinelaw> Crazypyro, it isn't known to be thrifty
12:27:20 <Crazypyro> Still, 850mb? :S
12:42:30 <nguyeng> are there any quick and easy ways to word wrap 'Text' (ie add '\n' in the appropriate places) before print/writing to a file?
12:44:56 <ReinH> nguyeng: what would be the "appropriate places"?
12:45:13 <ski> rofer : i think you *can* say `initRandState :: (Word8, StdGen) = random gen' with `PatternSignatures' (unfortunately deprecated) or `ScopedTypeVariables'
12:45:18 <ReinH> nguyeng: (The answer is probably "no".)
12:45:23 <ski> monochrom,sinelaw : *nod*, "interface inheritance" and "implementation inheritance" (and "prototype inheritance") are all different
12:45:26 <ski> sinelaw : as noted, `ocaml -rectypes' has Equi-recursive types. without `-rectypes' an equi-cycle must go through at least one object type  sinelaw : MLton does whole-program analysis because it wants to do aggressive improvement (compare with Stalin in the Scheme world). iiuc many people develop with SML/NJ and release with MLton
12:45:48 <nguyeng> ReinH: forcing line length < Int
12:45:52 <ReinH> nguyeng: Pretty printing libraries are designed in part to handle this sort of thing.
12:46:08 <sinelaw> ski, oh thanks
12:46:14 <ReinH> nguyeng: There are easy ways if you don't care about word boundaries.
12:46:37 <ReinH> If you do, you could process your text with a pretty printing library
12:46:48 <sinelaw> ski, didn't know about 'must go through an object'. what exactly is the rule? that the nested type variable must be somethwere inside an object type constructor?
12:47:22 <sinelaw> ski, e.g. t = ((Bla (Blo (Ble (Object { ((t <-- here it is! )))))...)
12:47:28 <ChristianS> nguyeng: quick googing found http://moreindirection.blogspot.de/2010/08/blog-post.html and http://rosettacode.org/wiki/Word_wrap#Haskell
12:47:46 <nguyeng> ReinH: Yeah. I'm looking at Text.PrettyPrint but its not wrapping for me. I'll keep trying.
12:47:57 <ChristianS> nguyeng: those are for String but should be easy to adapt for Text. don't know if there is a library for it somewhere.
12:48:13 <sinelaw> ski, is that what you mean?
12:48:42 <nguyeng> ChristianS: Thanks. It looks like Text.PrettyPrint might do what I want but its being difficult =(
12:48:53 <ski> sinelaw : the cyclic path must go through a type "node" being an object type
12:48:58 <ski> (unless you use `-rectypes')
12:49:43 <sinelaw> ski, interesting - i was just reaching the same conclusion about when it makes sense to allow implicit recursion
12:50:47 <sinelaw> ski, which brings me to another question: how does one "iterate over the constructors" in a haskell data type?
12:51:29 <ski> sinelaw : i think they implemented this so as to support binary methods <http://caml.inria.fr/pub/docs/manual-ocaml/objectexamples.html#sec39> and methods returning an object of the current class (typically some kind of cloning method <http://caml.inria.fr/pub/docs/manual-ocaml/objectexamples.html#sec37>, also see <http://caml.inria.fr/pub/docs/manual-ocaml/objectexamples.html#sec36>)
12:51:53 <sinelaw> I'm assuming Generics would be the answer, e.g. given a structure made up of various nested data constructors with that type variable buried inside, is there an easy way to check if a certain constructor is in the path? or get a list of constructors?
12:52:01 <ski> sinelaw : interestingly, these two cases are cases where subclassing *doesn't* imply subtyping (in O'Caml)
12:52:16 <rofer> ski: Just putting the type signature at the end works just as well for me, thanks though
12:52:37 <ski> rofer : *nod*, just informing you of the availability of what you asked about
12:54:41 <ski> sinelaw : i think there's a TH way to do it. also there's generic classes <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/generic-classes.html> and more recent generic programming support <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/generic-programming.html>
12:55:18 <sinelaw> ski, from the "functional objects" example looks like they use something like a newtype on the object
12:55:28 <sinelaw> the type of the object is not a recursive a'
12:55:32 <sinelaw> it's "object a'"
12:55:44 <sinelaw> and inside the methods, the reference is to a', not to object a'
12:55:49 <sinelaw> method types, I mean
12:56:03 <sinelaw> so it's a form of iso-recursiveness
12:57:51 <ReinH> nguyeng: You might start with something like  fsep . map text . words
12:59:19 <ski> sinelaw : that is related to row-types. a class type in O'Caml locally binds a type variable (usually named "'self" if mentioned explicitly) that refers to the current implementation type. when you instantiate a class (construct an object by invoking the class/constructor) this type variable is fixed to the current (completed) object type that you're building
13:00:50 <ski> sinelaw : (classes are only involved in implementation inheritance. when you have an object, its type is an object type, which no longer has any reference to a class. you can pass any object supporting the right methods of the right type to an operation, regardless of which class you used to make the object. iow, they don't need to have a common base class)
13:01:25 <ski> sinelaw : "so it's a form of iso-recursiveness" -- no
13:01:37 <sinelaw> ski, ok row types are what I'm interested in anyway. but it still could have said something like: myobj :: a = { method :: a -> ... }. instead it says: myobj :: Object a = { method :: a -> .. }
14:08:18 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org (migrating) | http://downloads.haskell.org'
14:08:18 --- topic: set by geekosaur on [Tue Nov 18 16:03:41 2014]
14:08:18 <benzrf> not on expressions
14:08:29 <quchen> Chathurga: Yes. Well, Haskell code doesn't have much order, or at least the order in which definitions appear doesn't matter.
14:08:35 <ski> Zemyla : they behave the same, observationally
14:08:35 <Zemyla> ski: Disregarding strictness.
14:08:51 <Chathurga> yeah that part makes sense, I guess it's the dependancy that's confusing me
14:09:52 <Zemyla> Can you strictly evaluate a partial function application?
14:10:14 <quchen> Chathurga: Maybe you also noticed the XYdefault functions in libraries like Traversable, like for example "fmapDefault". Those serve the same purpose: if you manage to define a valid Traversable instance, you get the Functor one without much effort.
14:10:44 <ski> ChristianS : no, functors are older than monads (e.g. functors were used before monads in Category Theory). perhaps the `Monad' class in Haskell is older than the `Functor' class. i'm not sure about that
14:11:12 <ski> quchen : ok. i can't recall hearing that, but fair enough
14:11:26 <shachaf> There are only two functions that use the "default" naming scheme as far as I know.
14:11:32 <quchen> ski: What else would you use them for?
14:11:49 <ski> Zemyla : no ! even taking strictness and (non-)termination into account, they are (observationally) the same !
14:11:51 <quchen> shachaf: 2 is close enough to "many" in physics ;-)
14:12:08 <shachaf> They're both in Data.Traversable.
14:12:26 <ski> Zemyla : "Can you strictly evaluate a partial function application?" -- yes, if the function was defined to do any useful work inbetween taking its arguments
14:12:34 <shachaf> liftM and liftA and so on are the same thing, though.
14:12:53 <Itkovian_> Is there something that allows me to (Maybe a, Maybe b) -> Maybe (a,b)
14:13:26 <albeit> I need to convert an integral value to type T, where "data T = Foo | Bar | Baz"... a function (:: Integral a => a -> T). Is it any slower deriving Bounded and Enum on T and filter the bounds till I find a match, compared to an explicit pattern matching function?
14:14:07 <k00mi> :t liftA2 (,) -- Itkovian_
14:14:07 <lambdabot> Applicative f => f a -> f b -> f (a, b)
14:14:11 <quchen> :t uncurry (liftA2 (,)) -- Itkovian_
14:14:12 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
14:14:21 <Itkovian_> thx
14:14:35 <Itkovian_> I knew I had seen something like that somewhere sometime
14:14:39 <Itkovian_> rock on
14:15:20 <guest_____> hi
14:17:13 <Tuplanolla> I built a parser that produces a syntax tree, but it contains metadata (like indentation) as well, so it is quite cumbersome to wrangle. Is there a convenient way to structure it so that I can traverse it without having to worry about the metadata or vice versa?
14:19:06 <Tuplanolla> Any hand waving to point me to the right direction would be appreciated.
14:19:21 <guest_____> how are you
14:19:45 <ski> Zemyla : also see "Partial Evaluation" (*not* to be confused with "Partial Application") <https://en.wikipedia.org/wiki/Partial_evaluation> (also see <http://www.itu.dk/people/sestoft/pebook/>,<http://readscheme.org/partial-eval/events/pepm1999.html>,<http://library.readscheme.org/page10.html>)
14:20:51 <ski> quchen : sorry, use what for ?
14:21:01 <Zol_> Is there a simpler way than http://lpaste.net/116557 to find out the type for quirky functions like those in https://raw.githubusercontent.com/Zolomon/xmr/master/public/images/courses/edan40/exams/20061016/3.png ?
14:22:12 <quchen> ski: "<ski> quchen : ok. i can't recall hearing that, but fair enough" -- I thought you were referring to "xDefault is good for defining instances"
14:22:42 <ski> Zemyla : a partial evaluator takes a program, and some of its inputs (termed "early"), and simplifies the program wrt those inputs as much as it can, yielding a new program that will accept the remaining (late) input, behave the same as the initial program, partially evaluated on the early inputs, but hopefully be more efficient (because it doesn't has to inspect/check the early inputs)
14:23:07 <hsk5> monochrom: why is there no link to the exception tutorial http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml from your http://www.vex.net/~trebla/haskell/index.xhtml ?
14:23:16 <hsk5> Are there any other hidden gems?!
14:23:45 <ski> Zemyla : if you know about `printf', then that's a common example, partially evaluating calls to it on its format string (which is usually specified explicitly in calls) -- such partially evaluated calls to `printf' won't have to traverse the format string at run-time, it's been done once and for all
14:23:47 <monochrom> ah, I haven't added it yet, that's all
14:24:53 <ski> quchen : sorry, i was apparently unclear. that was in response to the instance of superclass depending on the instance of the subclass things
14:25:08 <monochrom> Zol_: I wonder if you're just looking for ":type (.) (.)". but if you prefer to figure it out yourself, see my http://lpaste.net/99842 for a related example
14:26:10 <ski> Zemyla : .. while partial *application* just means that you presupply some of the inputs to a program/function/procedure/method/predicate/&c. .. without necessarily that doing any useful work before all the arguments/inputs are supplied
14:27:21 <Zol_> monochrom: I'm studying for my exam on Thursday, and some questions will be to determine the type, and the best way so far for myself have been to convert code into a final form in lambda-notation, and then figure out the types trying to infer it on my own. But this is very time consuming and tedious, I thought there ought to be a better way.
14:28:33 <monochrom> yes. my way is better.
14:28:54 <quchen> Corollary. Every 10th statement monochrom makes should be framed.
14:28:55 <monochrom> unless you consider basic algebra skills to be worse, not better.
14:29:00 <Zol_> :t (.)
14:29:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:29:32 <Zol_> monochrom: Ah, you put parentheses around (a -> c)
14:30:00 <monochrom> and sometimes, around ((a -> b) -> (a -> c))
14:30:09 <Tuplanolla> You can also figure out the types of compositions by aligning them visually, but only if you have compositions.
14:31:59 <Zol_> monochrom: Sorry, I'm getting stuck at line 25, how do you reach that conclusion?
14:32:49 <monochrom> for your example, you don't need to go that far. your example is simply cc c1, and you can stop by line 22.
14:32:54 <fizbin> Is there an easy way, as part of a cabal-based build process, to take a separate external (non-haskell) text file and convert its contents into a giant Text constant that's compiled into your program?
14:33:31 <monochrom> but I'm looking at "(cc c1) c2". I treat "(cc c1)" as one atomic thing now. and it has type (Œ± -> b->c) -> (Œ± -> (a -> b) -> (a -> c))
14:33:37 <Zol_> monochrom: I'm trying to learn your "algorithm" of doing it so I can do more advanced stuff in the future, but I guess I just missed something trivial.
14:34:54 <monochrom> I have a function of type X->Y. I pass it a parameter of type Z. this requires X=Z.
14:35:48 <monochrom> I have a function of type (Œ± -> b->c) -> (Œ± -> (a -> b) -> (a -> c)). I pass it a parameter of type (y -> z) -> (x -> y) -> (x -> z). this requires Œ± -> (b->c) = (y -> z) -> (x -> y) -> (x -> z)
14:36:15 <monochrom> X is (Œ± -> b->c), Z is (y -> z) -> (x -> y) -> (x -> z)
14:38:21 <Zol_> monochrom: Aha, thanks!
14:44:16 <Zemyla> Even though a Monad can't require, say, Ord a, there's nothing stopping me from defining (Ord a, Ord b) => f a -> (a -> f b) -> f b as a function called, say, `>>?`, right?
14:44:42 <Zemyla> I just don't get the syntactic sugar of do blocks that way.
14:45:35 <shachaf> You can even call your function (>>=) and then get do blocks with RebindableSyntax.
14:46:06 <shachaf> But at any rate there are no rules that say that you can't define a function whose type is suspiciously similar but not identical to (>>=)'s.
14:46:38 <Chathurga> Why do fail and return have to be in scope for RebindableSyntax?
14:47:02 <shachaf> Do they?
14:47:26 <shachaf> fail I understand, but not return.
14:47:40 <shachaf> Maybe for MonadComprehensions, if you use that.
14:48:03 <Chathurga> Yeah I tried it yesterday, return certainly has to. I was just putting together a "clean" Prelude for practice, wanted to just use pure
14:48:27 <Chathurga> Had to do return = pure
14:48:52 <Chathurga> Maybe I'm wrong, wait
14:51:23 * hackagebot Cabal 1.18.1.5 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.18.1.5 (JohanTibell)
14:51:56 <Chathurga> Yup return has to be in scope
14:55:20 <Tuplanolla> One way to solve my problem would be to use some kinds of views to operate on the underlying data structure.
14:57:21 <stephenmac7> I'm using haskell-mode in emacs but it doesn't seem to see my sandbox. Any way to fix this?
14:58:10 <hsk5> monochrom: great i/O tutorial, thanks
15:00:08 <monochrom> hsk5: you're welcome
15:00:30 <stephenmac7> Nevermind, seem to have fixed it
15:01:24 * hackagebot cabal-install 1.18.0.6 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.18.0.6 (JohanTibell)
15:04:56 <albeit> Is there a function to do ":: (a -> b) -> m2 m1 a -> m2 m1 b"?
15:05:24 <shachaf> forall m2 m1 a b?
15:05:45 <geekosaur> fmap . fmap ?
15:06:10 <albeit> Oh wait, slight typo, ":: (a -> b) -> m2 (m1 a) -> m2 (m1 b)". Does that change anything?
15:06:13 <albeit> :t fmap . fmap
15:06:14 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
15:06:14 <Axman6> albeit: m1 m2 a or m1 (m2 a)?
15:06:17 <Axman6> right
15:07:07 <shachaf> OK, but what are m2 and m1?
15:07:13 <geekosaur> liftM in place of fmap if you want to be pedantically true to Monad (may the AMP arrive soon)
15:07:24 <shachaf> May people stop using that acronym soon.
15:07:28 <albeit> shachaf: They are both monads
15:07:37 <shachaf> OK. In that case, liftM . liftM
15:07:42 <albeit> Great, thanks guys
15:09:38 <SvenskFisk> Is there a way to do takeWhile, but also the next element? For example, I have a list of numbers and I want to take from that list until the length of the digits is less than 1000, but also the number that has a digit lenth of 1000. My code right now : (print . takeWhile ((<1000) . digitLength)) nums, how would I modify this to include the 1000-digit number too?
15:10:08 <quchen> (<=)?
15:10:33 <shachaf> That certainly doesn't do the same thing.
15:10:55 <shachaf> I don't know a nice way of doing that with the standard library. :-(
15:16:24 * hackagebot shake-language-c 0.6.2 - Utilities for cross-compiling with Shake  http://hackage.haskell.org/package/shake-language-c-0.6.2 (StefanKersten)
15:16:26 * hackagebot Cabal 1.20.0.3 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.20.0.3 (JohanTibell)
15:21:24 * hackagebot cabal-install 1.20.0.4 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.20.0.4 (JohanTibell)
15:22:31 <athan> AWWWW YEEEEAAAAA
15:27:55 <luite> > foldr (\x xs -> x : bool [] xs (x<3)) [] [1..]
15:27:56 <lambdabot>  [1,2,3]
15:31:47 <Zol_> monochrom: How would you name (:[]) ? I'm just curious since [] is in the second parameter, I could infer this type in my sleep.
15:32:11 <Axman6> it's the angry monkey operator
15:32:24 <Zol_> monochrom: Would you rewrite it as cons = (:), empty = [], (:[]) = \x -> cons x empty?
15:32:47 <Zol_> Axman6: Haha, my lecturer calls it the Haskell Monster.
15:34:48 <gnusosa> Hi, I'm having a bad time writing a general deconstructor equation for a Maybe type. Can you recommend any good blog posts or article?
15:35:55 <gnusosa> Basically, I want to write a function to deconstruct a Maybe a and Maybe b with only one function.
15:36:14 <Axman6> :t maybe
15:36:14 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:41:53 <gnusosa> or any package in hackage to look at.
15:42:10 <chrisdone> bitemyapp: (moving from #haskell-infra) related to education i started work on my exercise library. i'm making a trivial formlet lib which accepts different kinds of code as input (exps, decls, modules), is presentable as text, and has validators which will take the code provided, compile and test it with quickcheck. i'm still at the type phase, modelling what i want to be able to write. but i'm pretty sure the formlet + quickcheck will
15:42:10 <chrisdone> be a nice combination
15:42:10 <chrisdone> bitemyapp: maybe i write: numF and it generates: "Please write a number." then i can write a number and it consumes and validates it as syntactically correct, then i have:
15:42:10 <chrisdone> bitemyapp: validate "between one and ten" (\x -> x >= 1 && x <= 10) numF which generates "Please write a number between one and ten." and you write 7 and it says OK. etc. then you build up with functions, validateFunction "reverses a list" (\f xs -> reverse xs == f xs) funF "Please write a function that reverses a list"
15:42:59 <chrisdone> bitemyapp: once *that's* all work, i'll make the *formlets themselves* instances of Arbitrary, or at least a class that's similar. so i'll need a DSL which can nicely compose validators so that the output is sensible and the validation is sensible
15:43:48 <chrisdone> although it doesn't have to be too sophisticated. i just want a certain level of variation in the questions
15:45:16 <bitemyapp> chrisdone: oh good.
15:45:17 <chrisdone> i'll literally start from something as simple as writing numbers and then work my way up into functions and lambdas and so on up up up. with each topic having a list of fine-grained dependencies like we discussed earlier, i probably have the book determine what's more difficult based on how many dependencies it has
15:45:22 <bitemyapp> chrisdone: you're going to make my coauthor very happy.
15:45:42 <chrisdone> who's your coauthor?
15:45:45 <bitemyapp> chrisdone: when you mentioned the idea she got really starry-eyed and excited and wanted me to do something similar I had mentioned as an extra for the book.
15:45:52 <chrisdone> lol
15:45:58 <chrisdone> excellent
15:46:13 <bitemyapp> chrisdone: linguist non-programmer I taught Haskell. Twitter acct in privchat if you want.
15:47:06 <chrisdone> gotcha
15:47:30 <chrisdone> relatedly, ew =p http://www.reddit.com/r/programming/comments/2pbqud/programming_and_programming_languages/cmvnph4
15:48:06 <bitemyapp> chrisdone: between that and Pyret I sighed and closed the tab.
15:48:26 <bitemyapp> chrisdone: I'd love to see that justification floated for the broken C and C++ books.
15:48:27 <chrisdone> my living room door is full of post-it note ideas. so i'm just at that stage at the moment, although i do have a module filled with undefined's
15:48:47 <bitemyapp> chrisdone: I understand. Thanks for keeping me posted.
15:49:08 <chrisdone> bitemyapp: np =)
15:54:41 <ski> @tell zipper see "`fibs' reduction trace" at <http://lpaste.net/116547>
15:54:41 <lambdabot> Consider it noted.
15:56:06 <chrisdone> ski: can we pay someone to make this automated?
15:59:46 <ski> chrisdone : is that `numF' related to / inspired by conal's <https://www.haskell.org/haskellwiki/Tangible_Value>s ?
15:59:55 <Guest9843> Ayyyyy
16:00:13 <Guest9843> Could I have some feedback on why a simple script I wrote isnt working
16:00:14 <ski> chrisdone : not the informal justifications, i fear
16:00:33 <Guest9843> It has to be something with my declarations because when I do it by hand it works fine
16:00:34 <Guest9843> length' :: [a] -> [a]
16:00:34 <Guest9843> length' a = sum' [1|_<-a]
16:00:34 <Guest9843> sum' :: (Num a) => [a] -> a
16:00:34 <Guest9843> sum' [] = 0
16:00:34 <Guest9843> sum' (a:b) = a + sum' b
16:00:49 <Guest9843> I think the issue is in the first line
16:01:56 <Axman6> the type for length there is clearly wrong
16:02:31 <Axman6> :t length
16:02:32 <lambdabot> [a] -> Int
16:02:47 <chrisdone> ski: i can't access haskell.org on my isp, but numF is just a name for "num formlet". it's inspired by formlets
16:04:24 <ski> @tell SvenskFisk "Is there a way to do takeWhile, but also the next element?", perhaps try something like `case span ((1000 >) . digitLength) nums of (prefix,next:_) -> prefix ++ [next]; _ -> ...' ?
16:04:25 <lambdabot> Consider it noted.
16:04:31 <Axman6> Guest9843: what does the type length' :: [a] -> [a] say
16:04:56 <chrisdone> the more modern formlet examples are digestive-functors and optparse-applicative
16:05:15 <ski> Guest9843 : btw, `(Num a) =>' can be written simply as `Num a =>'
16:05:20 <chrisdone> i think what makes a formlet differ to a basic parsec kind of parser is combining consumption with description
16:05:26 <Guest9843> Thanks guys can't beleive I missed that
16:06:04 <ski> chrisdone : not <hackage.haskell.org> either ?
16:06:08 <Guest9843> Are there any good resources to read up on these things with "=>" I really am struggling with their use
16:06:15 <chrisdone> hackage works, thankfully
16:06:26 * hackagebot music-dynamics-literal 1.8.1 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.8.1 (HansHoglund)
16:06:28 * hackagebot music-pitch-literal 1.8.1 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.8.1 (HansHoglund)
16:06:30 * hackagebot abcnotation 1.8.1 - Haskell representation and parser for ABC notation.  http://hackage.haskell.org/package/abcnotation-1.8.1 (HansHoglund)
16:06:32 * hackagebot musicxml2 1.8.1 - A representation of the MusicXML format.  http://hackage.haskell.org/package/musicxml2-1.8.1 (HansHoglund)
16:06:34 * hackagebot lilypond 1.8.1 - Bindings to Lilypond  http://hackage.haskell.org/package/lilypond-1.8.1 (HansHoglund)
16:06:37 <chrisdone> i'm unable to access the ip itself. traceroute gives up
16:06:42 <ski> chrisdone : .. i suppose <https://web.archive.org/web/20140715182804/http://www.haskell.org/haskellwiki/Tangible_Value> could possibly work
16:07:14 <ski> (iirc <www.haskell.org> and <hackage.haskell.org> resolve to different machines)
16:07:27 <Guest9843> Does => just restrict a certain type
16:07:42 <chrisdone> i can access that
16:07:46 <Axman6> Guest9843: the things before => are type class constraints; they say that the types used must be instances of a specific class. For example, Num a => ... means that the a's that appear in the type must be instances of the Nuym class, which means they have (+) and (*) and negate, and fromIntegral defined for the type a
16:08:03 <Axman6> @src Num
16:08:04 <lambdabot> class  (Eq a, Show a) => Num a  where
16:08:04 <lambdabot>     (+), (-), (*)       :: a -> a -> a
16:08:04 <lambdabot>     negate, abs, signum :: a -> a
16:08:04 <lambdabot>     fromInteger         :: Integer -> a
16:08:10 <Axman6> @instances Num
16:08:11 <lambdabot> Double, Float, Int, Integer, Product a, Sum a
16:08:31 <acowley> Anyone here familiar with the diagrams code base?
16:08:41 <Guest9843> if I define a function like Integral a => a -> b -> b    A would be restricted to Integral, but b and the output could be anything else as long as they matched?
16:08:50 <chrisdone> ski: yeah, tangible values are the same ball park as formlets. put both the value and the representation for that value together and you can make composable UIs
16:08:55 <Axman6> Guest9843: yep
16:09:01 <chrisdone> there's some work in the 70s calling them editor combinators
16:09:07 <Guest9843> Oh sweet
16:09:11 <ski> Guest9843 : the things to the left of `=>' specify which (classes of) types the operation is overloaded on
16:09:19 <geekosaur> note that the *caller* gets to decide what b is
16:09:28 <geekosaur> not you
16:09:29 <chrisdone> although in my case it's not for a "live" UI, just for a one-shot consumer
16:09:31 <Axman6> Guest9843: have you followed any haskell tutorials?
16:09:33 <HrafnA> acowley: What are you wanting to do with diagrams?
16:09:35 <Guest9843> Whats the difference between All and not restricting?
16:09:52 <Guest9843> Like in the previous one I typed how would All b being added to it change it?
16:10:02 <Guest9843> Or would that just be more readable
16:10:02 <ski> Guest9843 : your summing function is overloaded on all types that are an instance of the `Num' (for "numeric") type class, including such types that haven't been defined yet !
16:10:07 <benzrf> Guest9843: something of type Foo a can be used in place of something of type Foo Int, or Foo String, or anything you like
16:10:13 <Axman6> Guest9843: what is All b?
16:10:26 <benzrf> Guest9843: something of type Num a => Foo a can be used in place of any Foo Thing where Thing has a Num instance
16:10:33 <fryguybob> acowley: There may be people in #diagrams to answer questions too
16:10:38 <acowley> HrafnA: I wanted to add something to diagrams-builder, but I don't understand what's happening with diagrams-core. Version 1.2.0.4 was relatively recently uploaded to hackage, but master is quite different.
16:10:57 <acowley> HrafnA: Though the particular changes to master that are tripping me up are several months old.
16:11:11 <acowley> fryguybob: Oh, thanks
16:11:22 <Guest9843> Axman6: I thought All b was a restriction like Integral b
16:11:30 <ski> @where SEC
16:11:30 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
16:11:36 * hackagebot music-score 1.8.1 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.8.1 (HansHoglund)
16:11:37 <ski> chrisdone : thinking of that ^ ?
16:11:38 * hackagebot music-pitch 1.8.1 - Musical pitch representation.  http://hackage.haskell.org/package/music-pitch-1.8.1 (HansHoglund)
16:11:40 * hackagebot music-dynamics 1.8.1 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.8.1 (HansHoglund)
16:11:42 * hackagebot music-articulation 1.8.1 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.8.1 (HansHoglund)
16:11:43 <ski> chrisdone : or some paper ?
16:11:44 * hackagebot music-parts 1.8.1 - Musical instruments, parts and playing techniques.  http://hackage.haskell.org/package/music-parts-1.8.1 (HansHoglund)
16:11:48 <Axman6> Guest9843: i've never seen an All type class
16:12:00 * ski presumes the latter
16:12:02 <chrisdone> ski: http://www.ics.uci.edu/~taylor/ics228/SynGen.pdf
16:12:05 <ski> ty
16:12:08 <chrisdone> and http://www.cas.mcmaster.ca/~kahl/Publications/TR/2000-01/Kahl-Braun-Scheffczyk-2000a.pdf
16:12:37 <Guest9843> Axman6: Oh okay sorry my mistake
16:13:13 <Guest9843> Really dumb question but Haskell has applications outside of math right?
16:13:35 <Guest9843> I started yesterday and it seems crazy awesome for math/set type stuff
16:13:45 <Welkin> computer science is just math
16:13:51 <benzrf> Guest9843: if you want something crazy awesome for math use coq or something
16:13:53 <Welkin> so all programming is math
16:13:55 <kadoban> Sure, it's a general programming language. It's not even particularly well suited to math applications, as far as I know.
16:13:57 <benzrf> Guest9843: haskell is PRACTICAL, friend
16:14:16 <Guest9843> A neckbeard came to me and told me to learn haskell so here I am
16:14:20 <Zorg> Welkin that's like saying CS is programming =p..
16:14:27 <geekosaur> haskell has applications anywhere that you care enough about correctness to use it
16:14:30 <Welkin> I built a web app, wrote a language, an irc bot, and some games in haskell
16:14:45 <Guest9843> Welkin: That's pretty cool :o
16:14:59 <Welkin> you can do anything with haskell
16:15:23 <Welkin> it's just a high-level way of writing machine code
16:15:40 <Guest9843> I noticed it's fast as hell
16:16:03 <kadoban> It's quite speedy as far as high level languages go, yeah. Especially with tuning.
16:16:39 <benzrf> how many libraries already exist for bridging the gap between pipes and conduit
16:16:46 * hackagebot music-preludes 1.8.1 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.8.1 (HansHoglund)
16:16:48 * hackagebot music-graphics 1.8.1 - Diagrams-based visualization of musical data structures.  http://hackage.haskell.org/package/music-graphics-1.8.1 (HansHoglund)
16:16:50 * hackagebot music-sibelius 1.8.1 - Interaction with Sibelius.  http://hackage.haskell.org/package/music-sibelius-1.8.1 (HansHoglund)
16:16:52 * hackagebot music-suite 1.8.1 - A set of libraries for composition, analysis and manipulation of music.  http://hackage.haskell.org/package/music-suite-1.8.1 (HansHoglund)
16:17:32 <Welkin> I thought pipes and conduit served the same purpose
16:17:39 <chrisdone> ski: i think these are different implementations of the same rough idea, and i think it's a good one‚Ä¶ i think generally a parser is just a consumer, a printer is just a printer. but an editor is both a parser and a printer‚Ä¶ making them composable is a good idea.
16:17:39 <chrisdone> ski: in my case i want to generate text questions and quickcheck-based verification of the answers, i'll probably test it out on irc when i have something vaguely working. it can be a fun little quizz game :3
16:18:31 <HrafnA> In my experience, writing games in Haskell is something of a black art.  Particularly simulation games, where you need a single giant mutable world stored in memory.
16:18:52 <Welkin> HrafnA: what do you mean?
16:19:09 <Welkin> it is straight forward using state
16:19:15 <Welkin> you can also do it with FRP
16:19:18 <ski> chrisdone : i recall reading that they has some problems in Fudgets with not being able to decouple presentation from internal wiring easily, though ..
16:19:22 <Welkin> that is more complex though
16:19:30 <ski> s/has/had/
16:20:51 <Welkin> I like haasn's pong example
16:21:00 <chrisdone> ski: in the web world formlets are generally a success
16:21:28 <ski> chrisdone : i've imagined so, but not looked that much into it
16:21:45 <HrafnA> I'm talking more SimCity than Pong.
16:22:06 <jnape> hi all! does anyone know of a termination-case-preserving analog built-in to unfoldr?
16:22:27 <HrafnA> Welkin: Choosing how to manage/represent that state has mental overhead in Haskell, that doesn't exist in other languages.
16:22:31 <jnape> eg: unfoldr (\i -> if i > 10 then Nothing else Just (i, i+1)) 0  -- > [0,1,2,3,4,5,6,7,8,9,10,11]
16:22:49 <ski> jnape : what do you mean by "termination-case-preserving" ?
16:23:14 <Welkin> jnape: you mean like Control.Monad.guard?
16:23:16 <jnape> where the input that produces the Nothing is the final value in the resulting list
16:23:17 <Welkin> :t guard
16:23:17 <lambdabot> MonadPlus m => Bool -> m ()
16:23:35 <ski> > (`unfoldr` 0) $ \i -> do guard (10 >= i); return (i,i + 1)
16:23:37 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
16:23:38 <jnape> excellent, I'll check it out, thanks Welkin!
16:23:42 <kadoban> HrafnA: You certainly have to spend time choosing how you represent and manage state in other languages.
16:23:46 <jnape> perfect, thanks!
16:24:04 <ski> you could also use `guard (...) >> ...' instead of `do guard (...); ...', if you prefer
16:24:08 <HrafnA> FRP is good for Pong or Space Invaders, not so good for SimCity or OpenTTD. Feel free to prove me wrong on that.
16:24:15 <ski> (and `Just' or `pure' instead of `return')
16:24:59 <stephenmac7> Anyone know how to restore consumed input in parsec?
16:25:05 <jnape> ski: of course, thx ;)
16:25:07 <Welkin> stephenmac7: use try
16:25:07 <ski> @type until
16:25:08 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
16:25:20 <HrafnA> I'd love to see some proof of concept for a multiplayer simulation game in idiomatic Haskell, but it doesn't seem to be an area that has much been explored.
16:25:38 <HrafnA> In my limited reading in the area, anyway.
16:25:39 <Welkin> stephenmac7: you mean backtracking?
16:25:43 <stephenmac7> Welkin: Very cool. Thanks. That's exactly what I wanted
16:25:45 <Welkin> if so, then use try
16:25:50 <ski>   foldr : scanr :: foldl : scanl :: until : ?
16:25:57 <benzrf> HrafnA: hm
16:26:20 <benzrf> HrafnA: i feel like FRP can still be useful in cases like that
16:26:36 <benzrf> if only as a means of more declaratively handling mutable values
16:26:54 * ski . o O ( Fudgets )
16:27:18 <codygman-> Anyone have ideas on shortening these examples? They seem quite long compared to python/php: http://langref.org/haskell+python+php/networking/http/find-language-on-site
16:27:27 <chrisdone> ski: i forgot that fudgets was a thing that existed =) it's pretty neat
16:28:21 <Welkin> codygman-: those do blocks with one line are unnecessary
16:28:25 <ski> chrisdone : btw .. will you make it possible for the user of the page to enter stuff involving `numF' into some appropriate form(let) thing, that generating a new one which they can then test ?
16:28:32 <ski> @where Fudgets
16:28:32 <lambdabot> GUI using X, by Thomas Hallgren and Magnus Carlsson, at <http://www.altocumulus.org/Fudgets/>,<http://www.carlssonia.org/ogi/ProdArrows/>. Also see `Alfa'
16:28:34 <Welkin> as are the if-else statements
16:28:39 <Welkin> you can just pattern match
16:29:01 <HrafnA> benzrf: I've periodically checked the various Haskell FRP libraries' documentation and the syntax and boilerplate they require seems very opaque to me.  Elm seems to do things better in that regard.
16:29:04 <codygman-> Welkin: Thanks
16:29:11 <chrisdone> ski: example?
16:29:14 <ski> chrisdone : Fudgets is pretty cool. too bad it hasn't seen development in years
16:29:30 <benzrf> HrafnA: yeah the boilerplate is a lil impenetrable without a tutorial
16:29:50 <benzrf> i wish there were a practical-for-production way to have a monad instance for behavior
16:30:12 <benzrf> dynamic event switching is ok
16:31:10 <ski> (Fudgets is one of the earliest GUI systems for Haskell, if not the earliest. they used it to write an example WWW Browser (in 1994) that fetched inlined images in parallel (happening automatically, due to how Fudget was structured), unlike e.g. in Mosaic at the time, which fetched one image at a time)
16:32:18 <chrisdone> ski: quite an impressive achievement
16:32:27 <ski> chrisdone : well, you talked about allowing a user to type Haskell expressions into a form, and having it processed in various ways, including getting executed
16:32:29 <Cale> Yeah, I kind of miss Fudgets-style development on UIs
16:32:46 <chrisdone> not only a browser, but one built on a novel, principled UI framework
16:33:04 <dfeuer> Cale, care to help a poor, lost soul?
16:33:15 <dfeuer> Or ski or anyone else, for that matter?
16:33:17 <ski> chrisdone : and you talked about using `numF' to write such form things .. so the natural meta-question would be if it would be allowed for the user to also inpute expressions/programs using `numF', which they can then try out interactively :)
16:33:39 <Cale> There used to be a lot more of that sort of thing going on, but the bindings to existing libraries eventually leveraged so much work that they quickly became much more usable in practical settings.
16:34:04 <Cale> dfeuer: It helps to know up-front what I'm being asked to help with ;)
16:34:16 <Cale> dfeuer: But sure :)
16:34:17 <chrisdone> ski: ah, sure. a repl running in the same context with the same bindings isn't a stretch
16:34:25 <ski> chrisdone : .. and, if it doesn't happen automatically, also allow the user to write an expression for a form that allows a user to write an expression for a form to test interactively, to test interactively :) (and so on)
16:34:25 <shachaf> Asking people to commit to helping you before they know what they're helping you with isn't nice.
16:34:44 <dfeuer> Cale, nested type stuff.
16:34:52 <shachaf> If they can't help you, then in the best case (for them) they'll just feel bad that they said they'd help you and weren't able to.
16:35:50 <shachaf> (In a worse case you'll keep bugging them until they regret ever offering to help anyone. This is half the reason for "don't ask to ask".)
16:35:54 <chrisdone> ski: well, i wasn't planning on giving the user access to formlets in order to manipulate the service, it's more for defining questions, like this: http://chrisdone.com/example.png
16:36:02 <ski> dfeuer : "nested type" in which sense ? irregular data types like `data Nested a = Node a (Nested [a])' ?
16:36:11 <shachaf> Just say what your problem is, and if people think they can help you, they'll do it.
16:36:35 <dfeuer> ski, yes, irrregular types with polymorphic recursion.
16:36:52 <ski> dfeuer : ok. elaborate ?
16:38:11 <chrisdone> ski: my plan is that the system asks the user questions infinitely until they hit "I know this". every question should be slightly different to the last with a random seed
16:38:30 <dfeuer> ski, I'm working (still) on reimplementing <*> for Data.Sequence. It seems the most natural way to do it is to do a weird sort of "map" over the left argument, replacing each leaf with that leaf mapped over the right argument.
16:38:50 <dfeuer> And then "stretching" the two ends up/out to bring it to the right depth.
16:39:45 <ski> codygman- : in `(map toLower body)' there, you can drop the brackets
16:40:00 <benzrf> dfeuer: think in terms of liftA2 (,)
16:40:17 <benzrf> dfeuer: think about what that should do, and then which implementation of (<*>) will do that
16:40:29 <dfeuer> ski, so I can actually make this work very easily and nicely if the right-hand argument has two or three elements.
16:40:50 <dfeuer> But I can't figure out the proper types to handle the recursive case.
16:40:56 <dfeuer> If it's possible, of course.
16:41:46 <dfeuer> The basic concept is that I want to build up, as I descend, a function for converting Seq a to a 2-3 tree of successively increasing depth.
16:41:56 <benzrf> crap i misunderstood
16:41:58 <benzrf> soz dfeuer
16:42:16 <dfeuer> And a function for mapping a function of type a->b over a 2-3 tree of that depth.
16:42:32 <dfeuer> (note that 2-3 trees of different depth have different types)
16:42:40 <dfeuer> benzrf, no problem.
16:43:31 <chrisdone> ski: initially i can hard-code e.g. What is the value of if 0 == 2 then "OK!" else "Nope!"
16:43:31 <chrisdone> ski: but i can make the two branches generated from an instance of Arbitrary, and then also the conditional part. now if we consider the second question which involes handling some variable, generating the condition would require combining the conditional *code* with a conditional *validator*. so if the code generated is "if even x then ‚Ä¶ else ‚Ä¶" then i should be generating a quickcheck property of the form (\x -> even x ==> ‚Ä¶ .||. not
16:43:32 <chrisdone> (even x) ==> ‚Ä¶) or something like that. i'm still learning quickcheck
16:43:51 <ski> codygman- : also, `liftM (\body -> "haskell" `isInfixOf` map toLower body) (getResponseBody =<< simpleHTTP (getRequest "http://langref.org"))' is `liftM (("haskell" `isInfixOf`) . map toLower) (getResponseBody =<< simpleHTTP (getRequest "http://langref.org"))' is `(("haskell" `isInfixOf`) . map toLower <$>) . getResponseBody =<< simpleHTTP (getRequest "http://langref.org"))'
16:43:59 <dfeuer> The reason I need to build up a function for converting the sequence, instead of building up a 2-3 tree representing that sequence, is that the latter doesn't give the right performance characteristics (I need to access leaves in logarithmic time, without a potential linear time ignition)
16:45:16 <dfeuer> The reason I need to build up a mapping function, instead of doing the mapping, is that the latter is (often) much more expensive, tearing down the same sequence into singletons over and over by repeated splitting, instead of just doing it three times.
16:45:27 <chrisdone> ski: but i also want to couple english descriptions with properties. anyhoo. if you're interested i'll let you know when i have something tangible
16:45:46 <dfeuer> Cale, ski, I don't know if I'm even making sense to you right now.
16:46:05 <codygman-> ski: Thanks
16:46:32 <ski> dfeuer : something like `Seq (a -> b) -> (a -> Seq b)' ?
16:46:55 <Cale> dfeuer: Yeah, I don't really know if there's anything useful I can say here.
16:46:58 <dfeuer> ski, er ... not exactly.
16:47:04 <stephenmac7> How would I raise a parse error in parsec?
16:47:05 <dfeuer> I don't think.
16:47:21 <ski> (that was re your "It seems the most natural way to do it is to do a weird sort of \"map\" over the left argument, replacing each leaf with that leaf mapped over the right argument.")
16:47:37 <ski> (i didn't get your "And then \"stretching\" the two ends up/out to bring it to the right depth." at all)
16:48:23 <Axman6> @hoogle f (a -> b) -> (a -> f b)
16:48:25 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
16:48:25 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
16:48:25 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
16:48:53 <dfeuer> ski, Cale, this is what the simple 2-element/3-element case looks like, with the 2-element and 3-element sequences represented as tuples: https://github.com/haskell/containers/issues/73#issuecomment-66897917
16:49:34 <ski> dfeuer : which operation do you refer to by "tearing down the same sequence into singletons over and over by repeated splitting" ?
16:50:02 <dfeuer> Sorry, ski, I should give more context.
16:50:28 <dfeuer> Well, actually... ski, did you grok that code yet?
16:50:34 <ski> Axman6 : it's a variant formulation of `strength', i dunno whether there's any common canonical name for it
16:50:51 <benzrf> :t \f a -> f <&> a
16:50:51 <ski> Axman6 : .. well, apart from `flip', i.e. ;)
16:50:52 <lambdabot> Functor f => f a -> (a -> b) -> f b
16:50:55 <benzrf> hm
16:51:01 <benzrf> :t \f a -> fmap ($a) f
16:51:02 <lambdabot> Functor f => f (a -> b) -> a -> f b
16:51:07 <ski> benzrf : yes
16:51:21 <ski> it used to be that `flip' was defined in that way in lambdabot
16:51:29 <benzrf> oh?
16:51:32 <benzrf> oh heh
16:52:05 <ski> it let you say e.g. stuff like :  [sin,cos,tan] `flip` pi/3
16:52:08 <athan> How would a parser form a higher-kinded Alternative type? Is it parameterized over the returning type from a successful parse?
16:52:12 <stephenmac7> How would I go about expecting an failure in parsec?
16:53:49 <dfeuer> ski, if you ignore the types, the idea is (somewhat) simple. To calculate fs<*>xs, start by replacing each leaf (Elem f) in fs with the result of mapping f over a 2-3 tree representing xs. Then remove the left-most and right-most 2-3 tree from the result and use them to form digits leading down to what remains of that fingertree.
16:54:54 <ski> > [sin,cos,tan] `sequence` (pi/3)  -- happens to do the same thing, for different reasons
16:54:55 <lambdabot>  [0.8660254037844386,0.5000000000000001,1.7320508075688767]
16:55:14 <dfeuer> How do you turn a sequence into a 2-3 tree? Well, one option is to start by pairing up elements, and then pairing pairs, and so on, but that doesn't offer the sort of incremental performance I desire, I don't think.
16:55:39 <dfeuer> The alternative is to split the sequence into two or three pieces, and split each piece, etc.
16:55:58 <dfeuer> This, I think, will have the performance characteristics I want.
16:56:29 <dfeuer> But that splitting process is expensive.
16:56:43 <ski> dfeuer : "replacing each leaf ... with ..[a new tree].." sounds like `(>>=)', to me ..
16:57:26 <rofer> Is there an existing function with the type a -> () or do I just have to do const ()?
16:57:41 <ski> dfeuer : ok, bottom-up vs. top-down merging/joining
16:57:58 <ski> (cf. top-down vs. bottom-up merge-sort)
16:58:15 <benzrf> ski: more like join
16:58:19 <ski> rofer : not to my knowledge
16:58:27 <rofer> All right, thanks.
16:58:53 <ski> rofer : there's also of course the alternative `\_ -> ()'
16:59:01 <dfeuer> Right, ski. I think I have most of the idea settled, except two things: 1. How to make it work with the nested types, and 2. the arithmetic of figuring out how many elements to place in each digit on the way down. This arithmetic will have to be done in a rather careful fashion to maintain the right sorts of asymptotic bounds.
16:59:36 <dfeuer> I'd be very happy to leave (2) until later, and focus on (1), so I can get a compilable "skeleton" of what I'm trying to do.
17:00:34 <dfeuer> I believe I've gotten the types for the digit-filling-in pretty much settled (aside from some bookkeeping Int arguments), but I'm still rather lost when it comes to getting the right types for the main event.
17:01:26 <ski> dfeuer : `type Seq a = FingerTree (Elem a)' or what ?
17:01:48 <dfeuer> The difference is that the functions I pass down for the digit trail carry the mapping function with them; for the main event, I need to be able to pluck the mapping function out of a sequence, and it will have its original type because it's never been touched.
17:02:04 <dfeuer> ski, newtype Seq a = Seq (FingerTree (Elem a))
17:02:09 * ski isn't that familiar with finger-trees and "digits"
17:02:13 <dfeuer> Ah.
17:02:13 <ski> ok
17:02:23 <athan> Is there an unambiguous way to use a kind signature? I'm using -XDataKinds :(
17:02:23 <dfeuer> Don't worry about the digits, then.
17:02:41 <dfeuer> Because that's the easy part from the type perspective.
17:02:48 <HrafnA> ski: http://staff.city.ac.uk/~ross/papers/FingerTree.pdf
17:02:53 <ski> athan : how do you mean ? do you mean you want `KindSignatures' ?
17:03:13 <athan> ski: Actually nevermind
17:03:14 <athan> sorry
17:03:37 <Cale> dfeuer: Wouldn't it be hilarious to discover that the cost of the arithmetic resulted in exactly the same cost as the current method of computing it :D
17:03:49 <dfeuer> Cale, impossible :-)
17:04:33 <dfeuer> Really, Cale, even in about the worst imaginable scenario, it still will be better in a broad class of situations.
17:04:43 <ski> HrafnA : ty
17:04:48 <dfeuer> But I hope that's not the case, of course.
17:05:45 <ski> dfeuer : definitions of `Node',`Elem',`FingerTree' ?
17:06:29 <ski>   data Node a = Node2 Int a a
17:06:30 <ski>               | Node3 Int a a a
17:06:31 <ski> ?
17:07:20 <dfeuer> ski, you may want to look at https://github.com/haskell/containers/blob/master/Data/Sequence.hs   That whole splitMap thing actually comes out of trying to solve this problem a different way, using some Cartesian product splitting code by Joachim Breitner, but the constant factors were lousy.
17:07:39 <dfeuer> Yes, ski, that's about right.
17:07:56 <dfeuer> newtype Elem a = Elem a
17:08:48 <dfeuer> FingerTree a = Empty | Single a | Deep {-# UNPACK #-} !Int !(Digit a) (FingerTree (Node a)) !(Digit a)
17:09:08 <ski>   data FingerTree a = Empty
17:09:11 <ski>                     | Single a
17:09:13 <ski>                     | Deep Int (? a) (FingerTree (Node a)) (? a)
17:09:15 <ski> i think
17:09:25 <ski> ok
17:09:39 <dfeuer> ski, it's Digit a, and Digit a = One a | Two a a | Three a a a | Four a a a a
17:09:43 <ski> i see
17:10:18 * ski tried to infer the type declarations from looking at `mapMulNode',`mapMulFT'
17:11:48 <athan> Is there a way to have `not` at the type level, to say that two types are _not_ the same?
17:12:20 <HeladoDeBrownie> athan, Not a = a -> Void
17:12:43 <HeladoDeBrownie> Not sure how useful that will be in whatever application you intended, but that's one way to encode not
17:13:19 <athan> HeladoDeBrownie: I'm moreso looking for a constraint, thank you though
17:13:57 <athan> like `a ~/~ b` or something
17:14:10 <ski> HeladoDeBrownie : i suppose perhaps `a ~ b => Void' for inequality -- i dunno whether that can actually be used practically, though
17:14:11 <HeladoDeBrownie> Hmm, out of curiosity, what do you need that for?
17:14:37 <shachaf> ski: Inequality doesn't work very well with GHC at all. :-(
17:14:38 <HeladoDeBrownie> ski, yeah, I'm thinking Haskell might not be smart enough for some of the ways you might want to use it
17:15:30 <athan> HeladoDeBrownie: ahmmm... umm. I've got two data types as instances of a typeclass that are being fed into a GADT that's got two sum types - one that holds one instance, and another that holds _both_ instances - I'm trying to make them truly _both_
17:15:31 <nshepperd> I don't think there's any such thing as a "these types aren't the same" constraint
17:15:32 * HeladoDeBrownie imagines someone going "Haskell's not smart enough? That's it, I'm done, this was a good run"
17:15:53 <shachaf> ski: E.g. I've sent https://www.haskell.org/pipermail/glasgow-haskell-users/2013-March/023896.html to a mailing list before
17:16:03 <athan> ._.
17:16:07 * athan is ashamed
17:16:51 <shachaf> ski: And https://www.mail-archive.com/haskell-cafe@haskell.org/msg104555.html and a few other posts on related topics.
17:16:51 <ilken> Topic in #haskell is Topic in #haskell is ski: And https://www.mail-archive.com/haskell-cafe@haskell.org/msg104555.html and a few other posts on related topics.
17:16:52 <ilken> Topic in #haskell is ski: And https://www.mail-archive.com/haskell-cafe@haskell.org/msg104555.html and a few other posts on related topics.
17:17:15 <HeladoDeBrownie> What a weird bot response
17:17:43 <shachaf> Whose bot is that?
17:17:59 <HeladoDeBrownie> No idea. ilken, are you human?
17:18:11 <stephenmac7> What does unboxed mean?
17:18:52 <nshepperd> even if there was you could get around it by wrapping one in a newtype
17:19:04 <shachaf> I'm still interested in answers to some questions related to these.
17:19:50 <nshepperd> so I'm not sure that type inequality would enforce anything semantically useful
17:20:49 <ski> HeladoDeBrownie,shachaf : i suppose an alternative idea would be to use `a ~ b :- Absurd' or `a ~ b :=> Absurd', where `Absurd' would be a class with no instance. see <https://hackage.haskell.org/package/constraints>) ..
17:20:54 <HeladoDeBrownie> I'm legitimately curious if type inequality is actually necessary to encode anything
17:21:19 <HeladoDeBrownie> ski, "with no instance" is a sticking point I imagine
17:21:28 <HeladoDeBrownie> (Because you can't prove it)
17:21:29 <shachaf> I didn't see HeladoDeBrownie's original question, I was just talking about type inequality in general.
17:21:36 <HeladoDeBrownie> It wasn't my question
17:21:49 <HeladoDeBrownie> It was athan
17:21:54 <shachaf> OK, well, whosever question.
17:22:01 <athan> :)
17:22:11 <HeladoDeBrownie> "Is there a way to have `not` at the type level, to say that two types are _not_ the same?"
17:22:16 <shachaf> You *can* implement (Is A B -> Void) with GADTs or TypeFamilies, but not with plain RankNTypes.
17:22:27 <ski> shachaf : interesting. perhaps it's releated to OWA, i dunno
17:22:35 <athan> ski: OWA?
17:22:49 <Hermit> I remember having seen inequality in some code. I'm still sifting through bookmarks and stuff, but I believe I've seen it done before
17:23:06 <shachaf> ski: OWA?
17:23:10 <athan> Hermit: Thank you :)
17:23:25 <ski> Open-World Assumption
17:23:26 <shachaf> cmccann implemented something like reallyUnsafeCoerce :: Unequal a b => a -> b once
17:23:51 <shachaf> But of course that only worked when you had concrete types.
17:23:55 <shachaf> Ah.
17:24:06 <shachaf> ski: Inequality like this is incompatible with HoTT, I imagine.
17:24:38 <athan> :i Void
17:24:42 <athan> mer
17:24:45 <ski> shachaf : hm, interesting. elaborate/reference/link ?
17:24:55 <athan> hahaha
17:25:12 <ski> lambdabot : doesn't interpret `:i'
17:25:39 <athan> What is HoTT, for a layman?
17:25:49 <HeladoDeBrownie> athan, Void is a type that is uninhabited (except by bottom, which we like to ignore)
17:26:36 <shachaf> ski: Nothing much other than the things I linked to and various discussions in IRC.
17:26:40 <shapr> athan: http://homotopytypetheory.org/book/
17:26:40 <athan> Ahh wait
17:26:49 <athan> We can't have boolean inequality huh
17:26:50 <ski> athan : (Dependent) Type Theory, adding that there can now possibly be more than one proof of two things being equal
17:27:02 <athan> because something something Heyting Algebra...?
17:27:19 <ski> (what about Heyting Algebra ?)
17:27:42 <shachaf> ski: GHC's implementation is kind of silly, though.
17:27:45 <sclv> well alternately it is a precise correspondence between dependent type theory and topology
17:27:52 <athan> ski: if inequality is `not $ equality ...`, would !(!(a)) ~ a?
17:28:15 <HeladoDeBrownie> I don't think we can retrieve A from (A -> Void) -> Void
17:28:22 <shachaf> ski: The only reason you can implement (Is A B -> Void) is that the warning for incomplete matches is suppressed when a particular pattern match would cause a unification error.
17:28:44 <josephle> ski: Dependent types presents the problem that there can be multiple proofs of equality
17:28:56 <josephle> ski: HoTT is about unifying those proofs (univalence axiom)
17:28:58 --- mode: ChanServ set +o glguy
17:28:58 --- mode: ChanServ set +q *!*@unaffiliated/ilk
17:29:07 <athan> ski: So there was only one route  to the proof in normal Coq, right?
17:29:19 --- mode: glguy set -o glguy
17:29:26 <sclv> well there are many routes to proof
17:29:39 <sclv> without univalence you can't show they're all the same necessarily (unless you add an axiom they are)
17:29:43 <sclv> but you also can't show they're different
17:29:47 <athan> oh wow
17:29:47 <sclv> its a mystery
17:29:51 <athan> josephle: Thank you
17:30:05 <athan> wow
17:30:10 <josephle> don't worry, it's just proofs of identity all the way up (the type hierarchy)
17:30:11 <athan> that's incredible, thank you sclv
17:30:17 <athan> (and ski :])
17:30:20 <sclv> there's a neat analogy to intuitionistic logic
17:30:22 <shachaf> ski: This is also related to the problem with (old) GeneralizedNewtypeDeriving -- as far as I know it's not problamtic without GADTs/TypeFamilies
17:30:39 <HeladoDeBrownie> I love how this all started as a question about whether we can do "not" constraints
17:30:58 <sclv> without double negation elimination, you can't show that forall a. a or not a. but you can't show that its not the case either.
17:31:02 <HeladoDeBrownie> The answer is surprisingly complex
17:31:14 <sclv> but you can also introduce axioms that contradict it, and _then_ you can show its not the case
17:31:15 <shachaf> ski: (Because the way it worked was essentially by providing an equality between two different types, which isn't actually incompatible with Haskell2010+RankNTypes.)
17:31:34 <Denommus> ok, I tried Happstack but I didn't really liked it
17:31:37 <athan> that is awesome
17:31:41 <Denommus> it seems very old-fashioned
17:31:49 <Denommus> am I wrong to assume that?
17:31:57 <ski> athan : .. constructively, i often (not always) makes sense to take apartness as a primitive concept, and define equality as the negation of that
17:32:13 <sclv> Denommus: well its the oldest of the bunch. but if you use it cleanly it can be very minimal
17:32:19 <sclv> and feel a lot like a simpler snap
17:32:19 <athan> Denommus: I'm a fan of scotty
17:32:23 <shachaf> ski: You can simulate "positive" GADTs pretty easily with just RankNTypes, but they're much less useful without this feature.
17:32:24 <ski> josephle : well, not unifying *all* those proofs ..
17:32:38 <Denommus> athan: I'm giving scotty a look. It's similar to Sinatra, right?
17:32:48 <ski> (that would be UIP, which is inconsisted with HoTT, iirc)
17:32:48 <athan> yep, and it's wicked fast
17:32:53 <shachaf> ski: (I mean GADTs that give you "positive" equality evidence but not "negative" inequality evidence.)
17:33:10 <Denommus> athan: I'm thinking of having a Haste or GHCJS front-end application, and instead of passing JSON around, I just pass serialized Haskell structures
17:33:15 <athan> Denommus: Also, Lucid is pretty sweet if you use monad transformers :)
17:33:18 <Denommus> athan: deriving Show and Read
17:33:22 <athan> nice!
17:33:28 <athan> I want to try that haha
17:33:48 <athan> but yeah, it's as easy as including Aeson and throwing it on a url response route
17:33:50 <josephle> ski: true. the UA just claims that an isomorphism is sufficient for equality
17:33:56 <sclv> Denommus: yeah some folks have done that. it works out pretty well
17:34:38 <shachaf> ski: This channel is too busy for talking about this, but if you have anything to say on the topic I'd be interested.
17:34:59 <calvinx> how do I add the ViewPatterns language extension in my yesod app (per upgrade to yesod 1.4) ?
17:35:06 <Denommus> sclv: athan: quite in fact, I'm thinking of a front-end library for GHCJS or Haste based on FRP. Even the state machine (like the one in ui-router or ng-router) would be based on Behaviors
17:35:28 <athan> o.o
17:35:38 * athan doesn't know frp :E
17:36:02 <ski> athan,sclv,josephle : note that HoTT isn't simply "all equality proofs of `a = b' are equal" (that would be the `UIP' "Uniqueness of Identity Proofs" axiom, which HoTT does *not* assume). it's more subtle than that. in specific circumstances, we positively *want* more than one proof of `a = b' (e.g. when `a' and `b' are types)
17:36:09 <ski> shachaf : (re "(old) GeneralizedNewtypeDeriving") ok
17:37:15 <calvinx> o, in the cabal file. got it.
17:37:44 <sclv> right hott is the opposite of UIP.
17:37:59 <Denommus> athan: FRP became easier to grasp when I understood it's about defining the entirety of the values' dynamic behavior on their declaration
17:38:23 <sclv> univalence lets you explicitly construct an equality between types that is not equal to another equality between those types
17:38:25 <ski> sclv : "but you can also introduce axioms that contradict it, and _then_ you can show its not the case" -- yeah, like Churchs thesis, or Brouwer's intuitionistic continuity axioms
17:38:26 <Denommus> athan: so instead of having callbacks mutating your values, you have something like fold for events
17:39:23 <ski> shachaf : ".., but they're much less useful without this feature." -- "this feature" being ?
17:39:30 <josephle> ski: well, the UIP is "localized" to the IsSet property for a given type
17:39:56 <Denommus> well, I'm leaving
17:39:59 <dfeuer> ski, did you have any insights into my problem?
17:40:37 <sclv> i.e. if you say that isomorphism suffice for equalities (yes i know this is a simplification) then the type Bool equals Bool by sending True to True and False to False, but also by the twist map that sends True to False and False to True. Since we can transport across equalities, we could take a formula, send it to itself one way, then back the other, and if
17:40:38 <sclv> we pretended both equalities (resp paths) were the same, then we would generate a contradiction
17:41:02 <shachaf> ski: Type inequality, e.g. the ability to write (Is A B -> Void).
17:41:25 <sclv> but we still can't write disequality at the type level in a way that the compiler can reason with, right?
17:41:26 <ski> dfeuer : hmm .. getting caught in some crossfire
17:41:30 <dfeuer> *nod*
17:41:44 <ski> josephle : ok, i suppose that's a reasonable way to think of it
17:41:46 <ski> (ty)
17:42:44 <ski> shachaf : GADTs are much less useful without type inequality ?
17:43:00 <sclv> i thought they really just wrapped up type equality constraints
17:43:05 <sclv> we don't even have those with just RankN
17:43:23 <sclv> i think you can do limited disequality constraints with closed type families
17:43:54 <shachaf> ski: Yes.
17:44:03 <ski> shachaf : example of what you mean ?
17:44:38 <Hermit> athan: the approach I've seen at some point was pretty elegant, maybe it's just me not remembering correctly but this one, even though it may not be very orthodox, works just fine. https://gist.github.com/anonymous/9465b346028ce9230725
17:45:01 <shachaf> ski: I think most examples of GADTs take advantage of it. Let me see if I can find one.
17:45:34 <athan> Hermit++
17:45:43 <athan> Hermit: That's brilliant :) Thank you!!
17:45:44 <shachaf> ski: It comes up pretty quickly if you try to simulate GADTs with RankNTypes using Leibniz equality.
17:46:52 <shachaf> I can't think of an obvious example so I'll make a contrived one.
17:47:07 <Hermit> athan: thanks. Now you are bound by honor to let me know of a better way to do it if you were to find it ;)
17:47:24 <shachaf> Let's say we have "data T :: * -> * where { I :: Int -> T Int; C :: Char -> T Char }"
17:48:19 <athan> Hermit: You have my word :)
17:48:57 <benzrf> is there any kind of layer over alsa-seq that makes it not terrible
17:49:04 <shachaf> We want to write f :: T Int -> Int; f (I x) = x
17:49:12 <shachaf> But how do we handle the C case?
17:49:56 <shachaf> The way GHC implements it is that it just suppresses the warning, since matching on C would be a unification error anyway.
17:50:20 <shachaf> But let's say we wanted to implement this with Leibniz equality, i.e. newtype Is a b = Is (forall p. p a -> p b)
17:51:00 <shachaf> We would write f :: T Int -> Int; f (I _ x) = x; f (C r y) = ...
17:51:36 <shachaf> Er, with data T a = I (Is a Int) Int | C (Is a Char) Char
17:51:43 <sclv> Hermit: closed type families for the win :-)
17:51:50 <shachaf> If you had bar :: Is Int Char -> Void, it would be easy to implement the C case for f.
17:52:12 <shachaf> But since you don't, you can't really write it without undefined or something like that.
17:52:21 <Hermit> sclv: you said it! :D
17:52:32 <ski> shachaf : ok, i see
17:53:54 <sclv> but if you do it with ~ then it works
17:54:04 <sclv> because if you "open" the C you have the evidence already
17:54:15 <athan> sclv: "closed"?
17:54:26 <sclv> its  new feature
17:54:26 <shachaf> Yes, data T a = (a ~ Int) => I Int | (a ~ Char) => I Char is the same type as the GADT
17:54:38 <shachaf> GHC has special support for ~, implemented in the slightly dubious way I mentioned.
17:54:43 <Hermit> underneath the *THICK* layer of pedantry, lies a very nice language. This I believe, but sometimes it's just a pain in the ass when I'm trying to accomplish something non-trivial, due to all I have to sift through to get the compiler to accept my code.
17:55:00 <sclv> shachaf: i don't know what's dubious about what you mentioned?
17:55:01 <athan> :O
17:55:24 <Hermit> which in other languages is pretty strightforward, but not as deppendable or trustworthy
17:55:38 <shachaf> My opinion varies on how dubious it is. :-)
17:55:43 <sclv> it used to be that you couldn't really do things like that trick, because Foo a b was considered to match with anything Foo a a would
17:55:53 <sclv> closed families let you try the more restrictive one then fall thru
17:56:08 <shachaf> At any rate it's stronger than Leibniz equality.
17:56:17 <shachaf> This doesn't have to do with closed families.
17:56:40 <sclv> shachaf: i'm crosstalking with Hermits thing simultaneously :-)
17:56:42 <sclv> sorry
17:56:45 <shachaf> AH.
17:56:47 <shachaf> s/H/h/
18:00:32 <Cale> Hermit: Which language are you talking about? Haskell?
18:00:46 <Hermit> yes
18:01:02 <Cale> Hermit: Your comment sounds a little funny to me, because Haskell is probably the least pedantic language I can actually stand using for anything nontrivial :)
18:01:24 <geekosaur> indeed. if you think haskell is pedantic, try agda sometime
18:01:25 <Hermit> I guess that says more about your background than the language
18:01:29 <Cale> yes
18:02:17 <Hermit> I still got to make something useful out of Arrows (don't get me wrong, just need to learn them) and some other abstractions
18:02:20 <Cale> I've been programming in Haskell for a long time now, and lately I've been interested in dependently typed languages in which you can build libraries with very precise types.
18:02:57 <Hermit> dependent types are the next level, but I'm worried about productivity
18:03:35 <Cale> Well, in any case it's interesting to give the programmer more control/expressiveness when it comes to how well things are statically checked.
18:04:10 <Cale> You could still use one of these type systems in a very lax way which left most of the checking to runtime.
18:04:27 <Hermit> which is not something positive
18:04:31 <Cale> But they afford you the ability to be extremely picky about how things are used.
18:04:39 <Cale> Well, it's a spectrum
18:07:04 <Hermit> at some point, I'd like to grab a lisp and try rolling my own type system, see how simple I can make it without throwing away reliability and flexibility
18:07:10 <Cale> There probably isn't a single right answer to how much information about program behaviour should be encoded in the type system. Different sorts of applications will make it more or less profitable.
18:07:21 <Hermit> right
18:08:13 <Hermit> I'm still waiting for structural record typing in haskell
18:08:54 <Cale> Well, there are already libraries you can use to basically get it. The error messages would definitely be better if it were built in though.
18:09:21 <Cale> Personally I think subtyping of all sorts is kind of overrated.
18:09:49 <Cale> But it'd probably be nice to have in certain cases.
18:10:00 <Cale> As long as it doesn't hurt inference at all.
18:10:14 <Hermit> it wouldn't
18:10:50 <Cale> Are you familiar with the way Ermine does it?
18:10:54 <Cale> It's pretty cool
18:11:08 <Hermit> say that a function can be applied to any record with a field named x of type Y
18:11:12 <Hermit> no
18:11:27 <Cale> There have been a lot of systems for row polymorphism proposed, and many of them do a good job of inferring types.
18:13:41 <Cale> Ermine has (type level) row variables and row constraints
18:13:58 <Cale> Let me see if I can dig up an example
18:14:04 <rs0> how is it that 'liftM2 id' typechecks?
18:14:29 <Cale> :t liftM2
18:14:30 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:14:39 <Cale> If r = (a1 -> a2)
18:14:43 <Cale> er
18:14:44 <Cale> no
18:14:52 <Cale> if a1 = (a2 -> r) rather
18:15:08 <rs0> oh
18:15:11 <Cale> a1 -> a2 -> r means a1 -> (a2 -> r)
18:15:45 <Hijiri> :t id `asAppliedTo` (liftM2 $)
18:15:46 <lambdabot> Monad m => ((a1 -> a2 -> r) -> m a1 -> m a2 -> m r) -> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:15:50 <Cale> right, there's this talk about it https://www.youtube.com/watch?v=QCvXlOCBe5A
18:16:59 <Cale> Hermit: You can express things like that one row has a subset of the fields of two others.
18:17:28 <arianvp__> Bam
18:17:33 <Hermit> Cale: nice, let me watch the vid
18:17:35 <arianvp__> after 5 hours of hacking my code works
18:17:38 <arianvp__> now its 3 am
18:17:48 <arianvp__> Types make a lot more sense when I'm tired for some reason
18:17:49 <Hijiri> @let aaa f x = let _ = f x in x
18:17:51 <lambdabot>  Defined.
18:17:59 <Hijiri> :t aaa liftM2 id
18:18:00 <lambdabot>     No instance for (Monad m0) arising from a use of ‚ÄòliftM2‚Äô
18:18:00 <lambdabot>     The type variable ‚Äòm0‚Äô is ambiguous
18:18:00 <lambdabot>     Note: there are several potential instances:
18:18:17 <Cale> Oh, right, the primitive that it uses looks like a <- (b,c) which means that the row a can be partitioned into rows b and c
18:18:27 <Cale> (exactly)
18:18:35 <Hijiri> :t aaa (liftM2 :: (a -> a2 -> r) -> Maybe a -> Maybe a2 -> Maybe r) id
18:18:36 <lambdabot> (a2 -> r) -> a2 -> r
18:19:02 <Cale> and that can be combined with existentials and foralls in various ways to express a lot of operations on rows
18:21:19 <Hermit> looks promising. I'll enqueue checking it out.
18:21:52 <Hermit> right now I'm learning about the low level details of sockets and reading some RFCs
18:22:07 <Hermit> trying to get a custom DNS server up
18:23:17 <Hermit> anyway Cale, I'll get back to you when I have actually checked ermine out and I have some insight regarding it
18:24:24 <dfeuer> Holy moley! carter, Cale, I think I got the types right!
18:25:19 <carter> ohhhhh?
18:25:22 <dfeuer> My function tentatively takes 9 arguments, but hey!
18:25:39 <dfeuer> Exciting times, carter!
18:26:09 <Hermit> if your function takes 9 arguments, maybe you missed one or two  :P
18:26:31 <dfeuer> Hermit, it's entirely possible, but I think any missing arguments will have type Int.
18:26:43 <Hermit> dfeuer: see if you can pack all that into a struct
18:26:48 <Hermit> record*
18:26:58 <dfeuer> Hermit, how will that help me?
18:27:03 <Hermit> then you can touch only the fields you need to pass around all that stuff
18:27:13 <dfeuer> Oh... Good point.
18:27:35 <dfeuer> Hermit, I've never really used records much. I don't even exactly know the syntax for updating them.
18:27:55 <Hermit> learn it then, it's the way to go
18:27:56 <dfeuer> But that will probably make it easier to read than it is now.
18:28:12 <Cale> dfeuer: cool re: types
18:28:34 <Hermit> dfeuter.s/probably//
18:28:43 <dfeuer> Cale, the type looks like ap2tFT :: Int -> (Seq a -> d) -> (Seq a -> d) -> Seq a -> Seq a -> Seq a -> (Seq (a->b)) -> (Seq a -> c) -> ((a -> b) -> c -> d) -> FingerTree d
18:28:48 <Cale> hahaha
18:28:51 <Cale> nice
18:29:33 <dfeuer> The c and d are much less polymorphic than they appear, but that extra flexibility is needed for the recursion.
18:29:39 <Hermit> dfeuer: see that? how can you tell you are not feeding the third argument to the second? in a record each one goes named
18:29:45 <Cale> It's especially obnoxious that you have many arguments with the same type, so that you can silently screw up the order without getting any kind of error from the type checker
18:29:53 <dfeuer> Hermit, you already convinced me.
18:30:12 <Hermit> good
18:30:17 <Hermit> :)
18:30:48 <dfeuer> Cale, the real trick was figuring out that I needed those two "extra" type variables c and d.
18:34:25 <ski> Cale : where can i find more info on Ermine ? i suppose it has some variant of extensible records ?
18:34:33 <ski> @remember arianvp__ after 5 hours of hacking my code works || now its 3 am || Types make a lot more sense when I'm tired for some reason
18:34:33 <lambdabot> I will never forget.
18:34:38 <ski> dfeuer : s/(Seq (a->b))/Seq (a->b)/
18:34:45 <ski> Hermit,dfeuer,Cale : O'Caml has named parameters <http://caml.inria.fr/pub/docs/manual-ocaml/lablexamples.html>
18:35:59 <Hermit> too bad I don't use ocaml
18:36:11 <dfeuer> ski, one extra pair of parentheses is the least of my worries :-P
18:36:18 <ski> if `{x = 0 | rec}' is syntax for extending the record `rec' with field `x' associated with value `0', then a section `{x = 0 | }' of this ought to be allowed. then one could say `f . {x = 0 | }' to do partial application on named arguments simulated via passing a record
18:37:02 <Hermit> looks like a nice thing to have
18:37:24 <Hermit> I'll have to look into it
18:37:58 <Hermit> but still, I'd prefer not to deviate from lazy eval for the time being
18:40:04 <ski> dfeuer : anyway, i looked at <https://github.com/haskell/containers/issues/73#issuecomment-66897917>, and i still don't quite understand the
18:40:09 <ski>   "I want to build up, as I descend, a function for converting Seq a to a 2-3 tree of successively increasing depth."
18:40:15 <ski>   "And a function for mapping a function of type a->b over a 2-3 tree of that depth."
18:40:19 <ski>   ".. I need to build up a function for converting the sequence, instead of building up a 2-3 tree representing that sequence .."
18:41:13 <dfeuer> ski, well ....
18:41:15 <ski> dfeuer : part (i may have gotten a rough idea, but i'm not sure i correctly got your idea), and i don't see how it would connect to what you wrote there
18:41:21 <dfeuer> It's that bottom-up vs. top-down thing.
18:41:40 <dfeuer> ski, part what?
18:42:11 <ski> dfeuer : that was a continuation of the previous sentence (including the quotes)
18:42:45 <ski> the "build up a function" sounds like you perhaps want to do some amount of partial-evaluation-by-hand or "pre-compilation" or something like that
18:42:57 <ski> (but i'm not sure if this is the correct interpretation)
18:43:08 <dfeuer> ski, ok, so the point is that with nested types you can't just boom pull a function out of nowhere (often)
18:43:19 <dfeuer> You have to build it up piece by piece.
18:44:06 <ski> Hermit : the MLs (SML,OCaml,Alice ML) are worth looking into for the (powerful) module system, if nothing else (F# is also an ML, but doesn't support the module system :/ )
18:44:15 <dfeuer> So the two ways to go from Sequence a  to  a 2-3 tree at the right depth are bottom up: start by making a sequence of little 2-3 trees, then *at the next recursive level* make a sequence of bigger ones, etc.,
18:44:42 <Hermit> ski: which would be your pick?
18:44:43 <ski> dfeuer : hm .. sometimes you can build an infinite structure of functions, and apply as many as are needed in the polyrec
18:44:44 <dfeuer> or you can build up a function through the recursion which will perform the sequence to 2-3 tree conversion for 2-3 trees at that level.
18:45:34 <dfeuer> ski, that sounds like a potentially useful way to refactor the code.
18:46:14 <ski> Hermit : SML and OCaml are the two main ones. Alice ML is experimental, and has interesting ideas. F# if you need to be on Mono and want something half-decent (it also has two or three small extensions are a bit interesting)
18:46:16 <dfeuer> ski, I guess that would mean adding a new data type parallel to the FingerTree type, but more listy?
18:48:13 <ski> dfeuer : would it be possible to express the core idea you're trying to convey here, using a simpler irregular tree type ? perhaps `data PerfectlyBalancedBinaryTree a = Here a | Double (PerfectlyBalancedBinaryTree (a,a))' ?
18:48:20 <Hermit> ski: what ideas do you find interesting from AliceML?
18:48:25 <dfeuer> In any case, ski, I actually want *some* of that nasty slew of functions because I think dealing with the digit dribbles will be a constant factor faster if I build special-purpose functions just for the left-most and right-most functions...
18:49:15 <dfeuer> ski, yeah, I could. But since I think I already got over the hump, so to speak, I don't think there'd be any point.
18:50:48 <dfeuer> I think your idea of making an infinite "list" of functions is a nice one; I may use that to refactor.
18:55:02 <dfeuer> Hermit, how should I name record fields when I'm only using the record for one function?
18:55:31 <lifter> Is it possible to share pattern synonyms across modules?
18:57:21 <ski> Hermit : (perhaps not that clearly divides into : ) in general, futures,higher-order modules,constraints. in particular, packages / first-class modules,pickling/marshalling (including closures),first-class and higher-order components,distribution and proxies and remote execution
18:57:37 <ski> <http://www.ps.uni-saarland.de/alice/>
18:59:57 <benzrf> is there any kind of alsa-seq wrapper
19:00:01 <ski> dfeuer : well, for `PerfectlyBalancedBinaryTree', you could have `data PBBTFuns a b = PBBTF (a -> b) (PBBTFuns (a,a) (b,b))' and `apply :: PBBTFuns a b -> (PerfectlyBalancedBinaryTree a -> PerfectlyBalancedBinaryTree b)'
19:00:26 <ski> (`PBBTFuns' is naturally an arrow, iirc)
19:00:59 <ski> dfeuer : "only using the record for one function" ?
19:01:21 <dfeuer> ski, not sure what you mean about PBBT...
19:01:42 <dfeuer> Oh. now I do.
19:02:12 <ski> dfeuer : `PBBTFuns a b' is the type of streams of values (one each) of types `a -> b',`(a,a) -> (b,b)',`((a,a),(a,a)) -> ((b,b),(b,b))',&c.
19:02:35 <dfeuer> But wait, what is this "apply"?
19:02:38 <ski> in this case, only one function would be extracted by `apply'
19:02:39 <dfeuer> Is that a record field?
19:04:27 <dfeuer> ski, what is "apply"? Is that a record selector, or a function? I don't see how its type makes sense exactly.
19:05:02 <ski>   apply (PBBTF f _ ) (Here   a  ) = Here   (      f  a  )
19:05:08 <ski>   apply (PBBTF _ fs) (Double aat) = Double (apply fs aat)
19:05:44 <ski> it's comparable to `(!!)', plus a function application
19:05:59 <dfeuer> Hmmm.
19:06:06 <ski> (and `apply' is also polyrecursive)
19:06:33 <dfeuer> I'm not sure what this wins me, exactly.
19:06:48 * ski neither
19:06:57 <dfeuer> It's an interesting idea though.
19:07:13 <dfeuer> It might be someone else can apply it later, or it might make more sense in another context.
19:07:16 <ski> however, i still don't understand your strategy idea here
19:07:36 <dfeuer> ski, shall we talk in #nested-headaches?
19:07:51 <dfeuer> Too much distraction here.
19:08:16 <ski> (which was why i asked if you could distill the idea ("build up, as I descend, a function") down to an example in terms of some simpler irregular data type, perhaps `PerfectlyBalancedBinaryTree')
19:08:31 <dfeuer> Oh.
19:09:07 <ski> (if you'd prefer some other simple irregular type, that's be fine as well. `PerfectlyBalancedBinaryTree' is just an example)
19:09:40 <dfeuer> ski,  http://lpaste.net/679492091406974976 is what I have so far. Most of the "meat" of it is completely bogus.
19:09:59 <dfeuer> note map23, which is a sort of "apply",
19:10:24 <dfeuer> and build23, which is one of your PBBT funs, I think.
19:11:34 <dfeuer> ski, map23 doesn't actually run until the base case; until then, it's just used to build a new map23.
19:11:51 <dfeuer> The same goes for build23.
19:12:53 <ski> dfeuer : btw, do you know what i meant by "partial-evaluation-by-hand or \"pre-compilation\"" ?
19:13:12 <dfeuer> ski, not much of a clue, no.
19:13:34 <dfeuer> I mean, I think I know what partial evaluation generally means.
19:13:41 <dfeuer> Substituting things in and such.
19:13:48 <dfeuer> But how's that relate, exactly?
19:14:29 <ski> dfeuer : ok. one example would be a regex builder, which given a description of a regex traverses and analyzes it and builds an efficient function that doesn't refer to the regex description any more when it's passed its input
19:14:42 <dfeuer> Sure.
19:15:29 <ski> dfeuer : another example would be a parsing combinator library which propagates and uses static information about the parser, which is collected, analyzed and used to improve efficiency, before any parsing actually starts
19:15:40 <dfeuer> ski, and I guess my xs23=build23 xs  is something like that, yes.
19:15:56 <dfeuer> That's the concept, anyways.
19:16:28 <ski> dfeuer : there are also external tools that does partial evaluation .. the above two cases would otoh happen when the computed function is first forced (usually when it's applied)
19:16:34 * hackagebot hydrogen-version 1.2 - Hydrogen Version Type  http://hackage.haskell.org/package/hydrogen-version-1.2 (JulianFleischer)
19:16:36 * hackagebot hydrogen-prelude 0.8 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.8 (JulianFleischer)
19:17:09 <ski> (dfeuer : btw, i hope you know the difference between partial evaluation and partial application. people sometimes confuse these)
19:17:17 <dfeuer> Yes, ski. that's my aim. I only want to tear up xs into a 2-3 tree *once*.
19:17:30 <dfeuer> I want to reuse that 2-3 tree for each element of fs.
19:17:44 <dfeuer> Except for the two at the end, which are treated specially.
19:17:56 <ski> hm, now that sounds a bit more similar to loop (e.g. fold) fusion ..
19:17:57 <dfeuer> er .. I guess in this function, that's all of fs.
19:17:58 <dfeuer> Sorry.
19:18:31 <dfeuer> ski, it's a sort of fusion, yes, but not fold fusion.
19:19:21 * ski nods
19:19:44 <ski> i don't see `xs23' being (or containing ?) a (computed) function in the paste ?
19:19:52 <dfeuer> The splitting is relatively expensive; only want to do it thrice.
19:20:05 <ski> thrice ?
19:20:39 <dfeuer> ski, it gets torn apart one way through the left digits, one way through the right digits, and one way for everything else.
19:21:04 <dfeuer> These are very different tearings.
19:21:34 * hackagebot hydrogen-util 0.8 - Hydrogen Tools  http://hackage.haskell.org/package/hydrogen-util-0.8 (JulianFleischer)
19:22:26 <dfeuer> ski, the challenge of figuring out where those tear points are supposed to be remains before me. I have a vague general sense of what it will look like, but absolutely no details.
19:25:33 <dan_> does this look ok? addLastTwo xs = last xs + last (init xs)
19:25:33 <dan_>  
19:25:47 <Guest61972> Im not sure if there is a cleaner way of going about it
19:26:52 <ski> dfeuer : "and one way for everything else" -- one way, and not some indeterminate number decided by recursion ?
19:27:27 <ski> Guest61972 : doesn't work with lists having less than two elements
19:27:46 <ski> .. if you're fine with that, then i suppose it works
19:28:16 <dfeuer> ski, I create a series of functions of initially-unknown length to tear it in different ways, but I only use *one* of them.
19:28:38 <ski>   addLastTwo = sum . take 2 . reverse  -- would be another way to do it, probably a bit wasteful (unless fusion magic, and perhaps more improvement, happens)
19:28:48 <dfeuer> Ew yuck.
19:29:04 <ski> you could define a `takeLast', though
19:29:15 <dfeuer> ski, yeah, it's been done.
19:29:34 <ski> (which ?)
19:30:42 <dfeuer> ski, taking from the end, I think?
19:31:31 <ski> ok
19:31:41 <Guest61972> Is there a quick way to reuse the values from a function? Like in a fibonachi sequence, if I find the value of fibanachi number 500 I want to reuse that whenever the function needs it
19:31:46 <ski> (i'm sure it has come up here multiple times in the past)
19:32:00 <dfeuer> ski, sorry, I'm mixing it up with Breitner's dropTail, I think.
19:32:19 <ski> Guest61972 : which function ?
19:32:25 <dfeuer> I think taking from the end of a list is actually inherently nasty.
19:32:36 <ski> probably ..
19:33:00 <dfeuer> Guest61972, you don't want to save them all for Fibonacci. There might be a lot of them.
19:33:44 <ski> Guest61972 : if you want to save all (assuming non-negative inputs), then you could define `fibonaccis = map fibonacci [0 .. ]' ..
19:33:52 <dfeuer> Guest61972, the next version of Data.Sequence will offer a nice fromFunction :: Int -> (Int -> a) -> Seq a   but it still doesn't sound like that's what you really want.
19:35:21 <ski> dfeuer : i suggest naming it `tabulate' or `tabulateSeq' or something along that line. cf. `tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e' (implementation left as a exercise for the reader)
19:35:52 <ski> (it's called `tabulate' in the MLs)
19:36:10 <dfeuer> ski, sequences have nothing to do with Ix. Also, you'll have to file an issue against containers if you want to change the name, and convince the maintainers.
19:36:24 <dfeuer> The discussion that went into the name was fairly short, and no one thought of "tabulate".
19:37:13 <ski> dfeuer : in the ML version i'm thinking of, it was just a simple `0'-based index array, so i think something like :  val tabulate : int * (int -> 'a) -> 'a vector
19:37:19 <dfeuer> Oh, I see what you mean about arrays now. Sorry, ski. But yeah, it may or may not be too late to change the name.
19:38:00 <dfeuer> It would be nice to be similar to someone else, but I didn't like the idea of "fromGenerator".
19:38:09 <ski> dfeuer : the `Ix' was just to adapt to Haskell `Array'
19:38:14 <dfeuer> Right, I got that.
19:38:21 <dfeuer> Finally.
19:39:28 <ski> > tabulate (0,9) $ \i -> i^2 + 1
19:39:30 <lambdabot>  array (0,9) [(0,1),(1,2),(2,5),(3,10),(4,17),(5,26),(6,37),(7,50),(8,65),(9,...
19:41:10 <gcganley> hey does anyone have a guide for learning how to write cabal files? I've never used GNU make or anything like that so im as fresh as can be
19:42:24 <dfeuer> ski, I got the drift. Carter's the one who came up with the interface for Data.Sequence, calling it, initially, fromVectorLike. I suggested fromIntFunction, and Milan Straka changed that to fromFunction.
19:42:43 <dfeuer> [I had started with fromArray, and he suggested generalizing]
19:43:37 <dfeuer> Now we have both. And I'd like a third, a monolithic fromArray using that crazy unlifted unary tuple trick.
19:43:49 <dfeuer> But <*> is a higher priority for me.
19:44:06 <ski> is that Carter Schonwald (`carter' here) ?
19:47:31 <bitemyapp> ski: carter is Mr. Schonwald yes.
19:47:45 <bitemyapp> gcganley: howistart.org/posts/haskell/1
19:52:07 <carter> hehehe
19:52:49 <carter> ski: does the vector package on hackage have tabulate/
19:53:24 <carter> ski: talk over here
19:53:25 <carter> not at me
19:54:32 <ski> ok
19:54:51 <dfeuer> carter, Data.Vector calls it "generate"
19:54:53 <carter> ok
19:54:57 <dfeuer> Which I think is pretty awful.
19:55:01 <carter> dfeuer: true
19:55:20 <ski> (to repeat, i just checked it up and : )
19:55:30 <ski> SML defines `tabulate' in <http://sml.sourceforge.net/Basis/list.html>,<http://sml.sourceforge.net/Basis/vector.html>,<http://sml.sourceforge.net/Basis/array.html>, at least
19:55:33 <ski> (O'Caml happens to call it `init' <http://caml.inria.fr/pub/docs/manual-ocaml/libref/Array.html> .. i don't think that's as suggestive as `tabulate', though)
19:55:36 <nshepperd> 'reify'!
19:55:45 <dfeuer> memoize!
19:55:48 <ski> nshepperd : too overloaded :)
19:55:53 <carter> sml is prettier than okcaml
19:55:58 <nshepperd> hee
19:56:01 <dfeuer> We could totally make a different name for each package.
19:56:12 <dfeuer> We're already well on our way.
19:56:18 <ski> "memoize" at least is somewhat in the right direction
19:56:35 <carter> dfeuer: woottt
19:57:22 <dfeuer> carter, now that I managed to get that type right, it's time to do the heavy arithmetic and figure out how to use it right.
19:57:47 <carter> sweet
19:57:49 <carter> dfeuer: +++
19:57:56 <dfeuer> yeah, right.
19:58:31 <dfeuer> Oh, how do I pattern match using record field names?
19:58:40 <dfeuer> Thanks for the patience and cheerleading, carter.
19:59:05 <dfeuer> Oh, I see it.
19:59:07 <carter> dfeuer: i'm just lazy and trusting
19:59:11 <ski> dfeuer : `foo MyRec {x = anXpattern,y = anYPattern} = ..variables bound by the patterns'
19:59:58 <dfeuer> ski, wait, what?
20:00:16 <ski> dfeuer : also there's `foo MyRec {x = theX,..} = ..theX..' (ignoring the rest of the fields by `..') and `foo MyRec {x,y} = ..x..y..' (sugar for `foo MyRec {x = x,y = y} = ..x..y..')
20:01:10 <dfeuer> ski, this syntax is much too complicated. No wonder I've never used it.
20:01:35 <ski> dfeuer : tha basic form is the same as how records are constructed (which makes sense, if you think about it)
20:01:47 <ski> the two extra variants are shortcuts
20:01:55 <dfeuer> Some of it feels backwards.
20:02:01 <ski> (enabled by language extensions, i forget the names)
20:02:18 <dfeuer> ski, containers is portable. No can language extensions.
20:02:18 <ski> dfeuer : how is it more backwards than `fst (x,y) = x' ?
20:02:37 <dfeuer> ?
20:02:40 <ski> the basic record pattern-matchng syntax doesn't require extensions
20:02:54 <dfeuer> ski, but I need to name all the fields?
20:03:36 <dfeuer> That seems to defeat much of the point.
20:03:51 <ski> in `fst (x,y) = x' you have to interpret the pattern `(x,y)' "backwards", providing a value of pair type, matching it on the pattern, and extracting bindings for `x' and `y' (as opposed to computing a pair from values for `x' and `y', as would happen in an expression `(x,y)')
20:04:07 <dfeuer> Don't worry about it.
20:04:31 <dfeuer> I just hate learning new crap, and syntax is mostly crap.
20:05:23 <ski> a pattern `MyRec {x = ...,y = ...}' is backwards in exactly the same way ..
20:05:38 <dfeuer> Hmm.
20:05:41 <dfeuer> Maybe?
20:06:19 <ski> dfeuer : for many fields, where you only need a few, then either `..' (but you can't use extensions), or use selectors explicitly instead of matching
20:07:40 <dfeuer> ski, are you sure that's an extension?
20:07:47 <dfeuer> It seems to be on by default.
20:07:55 <dfeuer> Not with dots.
20:08:03 <dfeuer> But with just matching on some of the fields.
20:08:16 <ski> `..' in a record pattern needs `RecordWildCards'
20:08:35 <ski> saying `x' instead of `x = ...' needs `NamedFieldPuns'
20:09:30 <dfeuer> Oh, okay, I see what it does now. You can still match a partial record; .. does a bit of magic filling in the ones left out with their names.
20:10:23 <dfeuer> I mean, that would be nice to have, but oh wel.
20:12:26 <ski> <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#record-puns> (and the following section)
20:12:33 <dfeuer> Yeah, I found it.
20:12:35 <dfeuer> Thanks.
20:12:52 <dfeuer> It's the least of my troubles right now. Mostly, I need to figure out the arithmetic.
20:12:59 * ski nods
20:13:24 <dfeuer> This is not your grandpappy's arithmetic.
20:13:37 <ski> recurrence relations ?
20:13:58 <dfeuer> I'll have to write stuff out. Not sure exactly what I'll be needing.
20:14:04 <dfeuer> There's wiggle room.
20:14:08 <dfeuer> I hate wiggle room.
20:14:32 <dfeuer> It means I can't just solve stuff; I have to make decisions and then see if they work.
20:14:51 * dfeuer goes to do that.
20:16:51 <ski> aye, it's like choice-points in logic programming -- generally you want to avoid them, if reasonable (but when needed, they're good)
20:17:58 <ski> sometimes you end up doing a little bit of local breadth-first-search to hopefully quickly prune away all except possibly one alternative to continue exporing ..
20:19:13 <dfeuer> Yuck.
20:22:10 <ski> (.. but if you try to do that too much at a time, you get swamped in a too large state to keep track of at the same time)
20:24:32 <Joe_____________> hai
20:25:05 <Joe_____________> I am thinking of getting a book on haskell and functional programming for christmas
20:25:22 <Joe_____________> I have done a decade of programming already though, including some functional programming
20:25:33 <Joe_____________> so I'm looking for any recommendations which aren't "intro to haskell" type books
20:26:09 <dfeuer> ski, I'll have to be very, very disciplined here to keep it efficient.
20:26:38 * hackagebot debian-build 0.2.2.0 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.2.2.0 (KeiHibino)
20:26:51 <Joe_____________> I'm looking for any suggestions on good books for an experienced programmer
20:27:24 <dfeuer> Joe_____________, why don't you shorten your nick so you don't annoy everyone?
20:27:46 <Joe_____________> all the short versions were taken
20:28:01 <dfeuer> OK, so add a letter, or a number, or something with another symbol, or whatever.
20:28:05 <Joe_____________> I didn't think it was annoying either, I have seen plenty with longer nick names
20:28:12 <Joe_____________> especially on twitch IRC
20:28:13 <dfeuer> It is annoying.
20:28:22 <Joe_____________> ok, you are the first to have raised it
20:29:05 <dfeuer> Anyway, Joe_____________, you could read lots of books about type systems, like stuff by Pierce.
20:29:18 <dfeuer> Over my head.
20:29:33 <dfeuer> Joe_____________, have you read Okasaki's book yet?
20:29:46 <Joe_____________> nope
20:29:51 <dfeuer> Read it then.
20:30:00 <dfeuer> "Purely Functional Data Structures"
20:30:13 <dfeuer> It's actually written mostly in SML, but that's okay.
20:30:32 <dfeuer> It's SML with custom lazy extensions, actually.
20:30:40 <Joe_____________> I will take a look, thanks
20:30:49 <dfeuer> Yeah. Real cool.
20:30:51 <dfeuer> Thanks.
20:31:18 <dfeuer> Also articles by Okasaki, and Hinze, and Paterson, and Wadler, and Hughes.
20:31:38 * hackagebot cndict 0.4.1 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.4.1 (DavidHimmelstrup)
20:31:48 <dfeuer> There are lots of god things to read.
20:31:50 <dfeuer> good
20:32:47 <ski> Joe_0129 : i second the PFDS recommendation
20:32:56 <Guest63026> if I say something like "take 5 [x|bla bla bla]" will my set builder notation stop at 5 values??
20:33:15 <dfeuer> Guest63026, yeah ...
20:33:24 <ski> Joe_0129 : also, SICP (which happens to use Scheme), while old, is a good book
20:33:42 <Joe_0129> sicp?
20:33:51 <dfeuer> Structure and Interpretation of Computer Programs.
20:33:52 <Guest63026> like take 5 [x|x<-[1..100000000]]    wont need to go to such a large number because it only cares about the first 5 vals
20:34:03 <ski> Guest63026 : yeah, except it's a "list builder", aka a list comprehension (cf. set/ZF comprehension, for `{x | ..x..}' in set theory)
20:34:12 <ski> Guest63026 : right
20:34:17 <ski> @where SICP
20:34:17 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
20:34:23 <ski> the first two links
20:34:54 <Guest63026> ski: how would I define special constraints like I want it to stop finding values once they exceed a certain threshold
20:34:58 <ski> Guest63026 : also, i think CTM is a good book, though it's about multiple paradigms (including logic programming, and constraint programming)
20:35:02 <ski> er
20:35:05 <ski> Joe_0129 ^
20:35:09 <ski> @where CTM
20:35:09 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
20:35:33 <Guest63026> Like I want this to use the list builder notation, untill a value greater than 100 has been added
20:35:43 <Guest63026> immediately I want it to stop and return the list
20:35:45 <ski> (it happens to use the language Oz, <http://www.mozart-oz.org/>
20:35:46 <ski> )
20:36:33 <fryguybob> Joe_0129: Pearls of Functional Algorithm Design -- Richard Bird  is very good.
20:37:05 <Joe_0129> I have been toying with some logic programming over the last year, so that is a good suggestion for me ski
20:37:35 <ski> Alice ML is a language that is based on the same run-time as Mozart (the Oz implementation), but is a statically typed (impure) functional language (Oz is dynamically typed, and is (deterministic) logic programming at its code), but which has incorporated some of the multiple-paradigm ideas from Oz into it
20:37:54 <ski> <http://www.ps.uni-saarland.de/alice/>
20:38:19 <Guest63026> [x^5|x<-[1.100],x<300] <- How can I write a statement like this, that when x>300 the list stops trying to build itself
20:38:22 <dfeuer> Joe_0129, Edward Kmett has a list of books he likes in a review at http://www.quora.com/Reviews-of-Learn-You-a-Haskell-2011-book?share=1
20:38:22 <wyager> Anyone know why using "mapM foo xs" instead of "sequence (map foo xs)" would cause a massive slowdown?
20:38:22 <wyager> I would think they were equivalent
20:38:22 <dfeuer> Guest63026, you mean something like takeWhile (<=100) [blah blah blah]    ?
20:38:24 <dfeuer> wyager, GHC version?
20:38:34 <wyager> 7.8.3
20:38:45 <Guest63026> dfeuer: Yeah exactly like that, is the syntax takeWhile?
20:38:50 <wyager> I may have upgraded recently, let me check again
20:39:02 <dfeuer> Guest63026, it's not syntax; it's just a function.
20:39:22 <ski> (Alice ML is a member of the ML language family. other languages include SML (Standard ML),O'Caml (Objective Caml), and F# (more or less a .NET-variant of O'Caml, minus the very nice and powerfule module system, minus the interesting object system, and plus some cruft of interoperating with .NET)
20:39:24 <dfeuer> wyager, I can't remember if that's one where fusion rules changed in 7.9.
20:39:26 <Guest63026> Alright cool, that seems to be the function I was looking for
20:39:55 <Joe_0129> ok, that's a nice list of books for me to go lookup, thanks!
20:40:00 <ski> Joe_0129 : if you're interested in Logic Programming, then you should also check out Constraint (Logic) Programming
20:40:26 <Guest63026> dfeuer: Thanks, im reading through the documentation now and this is exactly what I was looking for
20:40:46 <dfeuer> No problem, Guest63026.
20:41:11 <dfeuer> ski, I will probably hunt you down for a  more focused reading list at some point, but I'm too focused on other things right now.
20:41:32 <wyager> dfeuer: I think an update of GHC I applied earlier today may have fixed it
20:42:16 <dfeuer> wyager, huh. OK.
20:42:33 <wyager> It doesn't seem to make such a drastic change anymore
20:45:20 <ski> Guest63026 : if you enable the extension `TransformListComp', then you can also say `[x | x <- [0 ..],then takeWhile by x < 10]' (as an alternative to `takeWhile (< 10) [x | x <- [0 ..]]')
20:46:39 * hackagebot debian-build 0.3.0.0 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.3.0.0 (KeiHibino)
20:46:41 <dfeuer> ski, I think that's probably not what a new user needs.
20:48:35 <ski> dfeuer : i don't know .. it's a relatively new extension, and relatively unknown (afaicd). possibly newbies would find it quite reasonable if they encounter it
20:49:47 <idnar> I'm calling a C function by FFI, it expects me to pass it a pointer to an array into which it will write a string; presumably there's some way to do this with ByteStrings that doesn't involve allocating an array, copying it, then throwing away the original array, but I can't quite figure it out
20:50:40 <ski> @where book-acronyms
20:50:40 <lambdabot> mbishop's "List of popular programming book acronyms" at <http://web.archive.org/web/20080918051833/http://mbishop.esoteriq.org/stuff/books.txt>
20:50:56 <ski> Joe_0129 : you could also perhaps have a look at that list ^
20:51:29 <ski> for learning more about type systems, TAPL as dfeuer hinted at
20:51:33 <ski> @where TAPL
20:51:33 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
20:51:37 <dfeuer> ski, it looks weird.
20:52:10 <ski> dfeuer : compiled by a lisper :)
20:52:28 <dfeuer> ski, I'm talking about that list comprehension extension.
20:52:32 <ski> oh, that
20:52:47 <ski> it's meant to be a bit "SQL-like" (but more general)
20:53:12 <wyager> idnar: https://hackage.haskell.org/package/bytestring-0.9.2.1/docs/Data-ByteString-Unsafe.html
20:53:30 <dfeuer> ski, I'm just starting to learn SQL. Do you know a good resource/tutorial?
20:53:33 <idnar> hmm, Data.ByteString.Internal.unsafeCreate looks like what I want, but it's not exposed via Data.ByteString.Unsafe, I assume there's a reason for that
20:54:34 <wyager> idnar: It could just be an oversight. Sometimes libraries don't see all the use cases for exporting something
20:54:59 <dfeuer> Or they don't want to tie themselves down to supporting it in the future.
20:55:06 <dfeuer> Which is a more serious concern.
20:55:33 <dfeuer> Why do people change their nicks from sensible ones like amar to unsensible ones like Guest41299?
20:56:39 * hackagebot time-locale-compat 0.1.0.1 - Compatibility of TimeLocale between old-locale and time-1.5  http://hackage.haskell.org/package/time-locale-compat-0.1.0.1 (KeiHibino)
20:56:56 <dibblego> dfeuer: the freenode server does it because amar is a reserved nickname by someone else
20:56:56 <dibblego> (if you don't identify within a time)
20:57:05 <dfeuer> Oh......
20:57:09 <dfeuer> OK.
20:57:48 <wyager> I have to say, it's annoying how, despite the Haskell community's general interest in type safety, so many libraries use Int to represent indices or sizes, when Word would be much more appropriate
20:58:43 <dfeuer> wyager, it's a hard habit to break, because people generally *expect* such things to be Int.
20:58:54 <wyager> Yeah, that's unfortunately true
20:58:59 <wyager> Also, Word isn't in prelude
20:59:13 <wyager> It really should be fixed, though. It's not a technically difficult fix
20:59:13 <dfeuer> It will be in 7.10 :-)
20:59:17 <ski> dfeuer : hm. i've learned from "Database Systems" by Hector Garcia-Molina,Jeffrey D. Ullman,Jennifer Widom (2008,2013),from a short book called "SQL-introduktion",from an uni course, and from looking at a few books by Christopher J. Date (e.g. "Database in Depth: Relational Theory for Practitioners". i haven't looked at his "An Introduction to Database Systems". also see <https://en.wikipedia.org/wiki/The_Third_Manifesto>)
20:59:19 <wyager> Cool
20:59:28 <dfeuer> wyager, fixing *all the codes* is a very hard fix.
20:59:45 <dfeuer> ski, which did you like?
20:59:58 <wyager> Yeah, but a gradual fix wouldn't be so bad
20:59:58 <wyager> It would, at worst, require an ugly fromIntegral every once in a while
21:00:18 <wyager> Most code will just work out of the box with a dumb search and replace Int |-> Word
21:00:41 <ski> (also i've looked at Date's "The Database Relational Model: A Retrospective Review and Analysis", but that's more of a theoretical and historical (short) volume)
21:00:48 <dfeuer> wyager, you probably don't even understand how ugly fromIntegral really is.
21:00:57 <wyager> dfeuer: I do not
21:01:10 <wyager> Isn't it just a basic cast?
21:01:16 <wyager> (for going across integral types)
21:01:26 <ski> dfeuer : well, of those i've mentioned that i've looked at, i liked them all (which is why i mentioned them)
21:01:28 <wyager> Most architectures have standard instructions for that
21:01:31 <dfeuer> wyager, it is an unholy terror that works very nicely casting between certain specific types.
21:01:38 <zq> is there a way to unsafeWrite a byte of ByteString?
21:01:47 <dfeuer> Thanks, ski.
21:01:50 <wyager> dfeuer: I will take a look at it
21:02:21 <dfeuer> wyager, what makes it unholy is that the Haskell Report does not have multiparameter type classes.
21:03:20 <wyager> dfeuer: I can't read the haskell wiki article on that. Is the haskell website down for y'all too?
21:03:51 <wyager> Let me leave my VPN. brb
21:04:25 <dfeuer> fromIntegral :: (Integral a, Num b) => a -> b
21:04:27 <dfeuer> fromIntegral = fromInteger . toInteger
21:04:32 <ski> dfeuer : however. you should be aware that (a) SQL is an imperfect realization of the relational model of database systems (not to mention that the concrete syntax of SQL is ugly as hell), having several flaws and gotchas; and (b) implementations of SQL are typically worse, not even implementing parts of the standard, or implementing it suboptimally, and providing ad-hoc non-declarative substitutes that are more performant, but which leaves more work
21:04:44 <dfeuer> Oh, wyager is gone.
21:04:51 <dfeuer> fromIntegral :: (Integral a, Num b) => a -> b
21:04:53 <dfeuer> fromIntegral = fromInteger . toInteger
21:04:53 <ski> (oops, cut off near ".., and providing ad-hoc non-declarative substitutes that are more performant, but which leaves more work for the database designer&programmer, and which scales less well and are less modular")
21:05:33 <dfeuer> ski, I'm just trying to learn enough to be dangerous; maybe help me find a job or something?
21:05:43 * dfeuer has no job.
21:05:48 <wyager> dfeuer: Is it specialized for e.g. Word -> Int?
21:05:58 <wyager> Because that's seriously just 1 assembly instruction
21:06:05 <wyager> Not even, really
21:06:12 <dfeuer> wyager, yeah, GHC has RULES to rewrite it in a few special cases.
21:06:17 <wyager> Blech
21:06:21 <dfeuer> It becomes free.
21:06:33 <dfeuer> But if you are not in special cases, ha ha on you.
21:06:40 <wyager> Isn't there some mechanism to write special instances of a function without rules? Like type families, but for functions?
21:06:59 <dfeuer> wyager, yeah, they're called multiparameter type classes :-)
21:07:11 <wyager> Oh, OK, I still can't load that article for some reason
21:07:38 <dfeuer> class Funky a b where funkify::a->b    instance Funky Int Word where .....
21:07:48 <dfeuer> wyager, yes, because haskell.org is DOWN.
21:07:51 <wyager> oh, ok
21:07:53 <wyager> missed that
21:07:54 <ski> wyager : also see <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#specialize-pragma>
21:08:39 <dfeuer> wyager, oh, it seems to be working now.
21:08:41 <dfeuer> A bit slow.
21:08:58 <dfeuer> ski, that doesn't actually help here, I don't think  :)
21:09:25 <dfeuer> Well,
21:09:37 <dfeuer> maybe it would work with SpecConstr or whatever it's called.
21:09:48 <dfeuer> Or something. Yuck.
21:09:59 <ski> Joe_0129 : for more AI:y stuff, you might like Ivan Bratko's "Prolog: Programming for Artificial Intelligence". and Richard A. O'Keefe's "The Craft of Prolog" is a more advanced book on practical programming that has lots of useful advice
21:10:19 <dfeuer> ski, what's prolog actually used for these days?
21:10:25 <Joe_0129> I am interested in using Prolog for non-AI stuff
21:10:30 <Joe_0129> I was working on a web framework using it
21:10:43 <ski> dfeuer : perhaps not for the `Word -> Int' case, i'm not sure
21:10:51 <Joe_0129> (although it didn't really go anywhere, but it had some neat ideas)
21:12:59 <ski> dfeuer : there is someone in ##prolog who is paid to make a kind of interactive applications, embedded in SecondLife, for a university, and uses Prolog for it
21:12:59 <dfeuer> ski, why is a FingerTree strict in its Digits?
21:13:28 <dfeuer> ski, that's pretty vague.
21:14:01 <ski> dfeuer : .. not having studied finger trees, i suppose that they basically wanted a shortcut from inlining `Digit' into that `Deep' constructor, in all possible ways
21:14:46 <dfeuer> ski, no comprende.
21:15:00 <ski> dfeuer : there's someone else who uses it (Prolog) to control dependencies for services that can be up and down
21:15:21 <dfeuer> Hmm
21:16:16 <ski> dfeuer : say `data Digit a = One a | Two a a' and `data Silly a = Deep !(Digit a) (Digit a)' -- inlining, we get `data Silly a = Deep11 a a | Deep12 a a a | Deep21 a a a | Deep22 a a a a' -- at least, that's afaiui
21:16:54 <glguy_> If anyone is interested in GHC.Generics and/or lens package I've got what I think is a cool trie implementation. A Trie type can be automatically derived for any type implementing Generic and comprised of fields that have Tries http://www.galois.com/~emertens/tries/Data-Trie.html
21:18:02 <dfeuer> ski, does it really do that? That would seem pretty bad for allocation.
21:18:16 <ski> dfeuer : without the strictness annotation, we could have `_|_' in those `Digit a' fields -- and also with the `UNPACK' pragma, i think it will actually represent it by storing the `a's directly in the constructor(s), instead of having them behind an indirection
21:18:43 <dfeuer> ski, the UNPACK only applies to the !Int field; it can't ever do anything for polymorphic stuff.
21:19:05 <ski> ok. i stand corrected
21:19:23 <dfeuer> UNPACK is actually per-field, also.
21:19:58 <ski> (though i don't think `Digit a' would apply there. i think it's a single type variable which can't be affected by `UNPACK' (or a type variable applied to some type arguments))
21:20:07 <dfeuer> {-#UNPACK#-}!Int {-#UNPACK#-}!Char !Int !Char  will make two unpacked fields and two packed ones.
21:20:23 <ski> ok
21:20:38 <dfeuer> But anyway, I dunno.
21:20:45 <dfeuer> It seems a little strange.
21:22:14 <ski> (also, istr, Windows NT used Prolog. not sure if Windows still uses it)
21:22:35 <Joe_0129> Windows NT used Prolog?
21:22:37 <Joe_0129> where and for what?
21:23:26 <gamegoblin> If there a function in the standard library that tells me the index of the maximum value of a list?
21:24:08 <dfeuer> WTF?
21:24:35 <ski> Joe_0129 : "networking installation and configuration" apparently. it seems <http://www.drdobbs.com/cpp/extending-c-with-prolog/184409294> mentions it
21:25:41 <t4nk287> Hi,  I was sondering if someone could take a look at this code and suggest why it is not working in Haskell WinGHCi ver 7.6.3: http://pastebin.com/PhippNAu
21:27:11 <wyager> gamegoblin: You could use mi xs = elemIndex (maximum xs) xs
21:27:32 <wyager> Or something like that
21:27:34 <gamegoblin> wyager: problem with that is it‚Äôs 2*N instead of just N
21:27:45 <wyager> Let me write a fold that does this
21:29:52 <gamegoblin> t4nk287: if you input a = False b = True to that function the first condition will get triggered since b = True
21:30:22 <wyager> gamegoblin: mi = fst . foldl (\(i,v) (i',v') -> if v' > v then (i',v') else (i,v)) (-1,0) . zip [0..]
21:30:31 <gamegoblin> t4nk287: What are you trying to get this function to do?
21:30:39 <wyager> You will want to change the (-1, 0) probably
21:30:58 <wyager> This assumes everything in the list is at least 1
21:31:12 <gamegoblin> wyager: ended up going with """ snd (maximumBy (comparing fst) (zip xs [0..])) """
21:31:12 <t4nk287> I see.  Just tryinto to do simple boolean logic.  T&&T = T, T&&F=F, etc.
21:31:18 <t4nk287> but with the Or
21:31:22 <t4nk287> does not work
21:31:38 <t4nk287> The and ver works as it should but not the Or version.
21:31:46 <t4nk287> does not...
21:31:57 <gamegoblin> t4nk287: your logic is wrong, your function will always return true
21:32:07 <wyager> gamegoblin: That looks nice
21:32:24 <t4nk287> I see, ok, I will look at it again, and use your suggestion.  Thanks for the help.
21:32:40 <gamegoblin> t4nk287: if I give it False False, the second condition will trigger
21:32:47 <wyager> You could also do "fst . maximumBy (comparing snd) . zip [0..]"
21:33:04 <gamegoblin> t4nk287: since you are saying "if A is true, or B is False"
21:33:14 <gamegoblin> t4nk287: and B is False, so the statement becomes True
21:33:31 <t4nk287> ahh, I see
21:33:45 <ski> (hm, also found <http://www.faqs.org/faqs/prolog/resource-guide/part1/section-18.html>,<http://stackoverflow.com/questions/10772530/how-prolog-is-used-and-implement-the-real-world-application>,<http://stackoverflow.com/questions/130097/real-world-prolog-usage>,
21:33:49 <ski> <http://www.pathwayslms.com/swipltuts/html/systemsusingprolog.png>,<http://www.accountingsoftware411.com/SoftwareDirectory/softwareview.aspx?sid=Prol71C618s> on the topic. dunno where to find more info)
21:34:27 <t4nk287> thanks for the help.
21:34:38 <hunter> why are simple programs compiled to large sizes in haskell? whats all the overhead coming from
21:34:55 <wyager> hunter: The runtime is very complicated
21:34:58 <wyager> it's like a mini OS
21:34:58 <hunter> my hunch has always been that because the nature of hasell is so unnatural for the computer yea
21:35:05 <hunter> yea its kind of like a vm isnt it
21:35:11 <MP2E> hunter: C++ and C programs are usually dynamically linked to the C library on your system, Haskell's runtime is not as ubiquitous so it is normally statically linked in
21:35:25 <wyager> It has to manage threading and memory allocation and all sorts of stuff. Also the static linking takes a lot of space
21:35:31 <lifter> How can I export pattern synonyms from a module?
21:35:33 <hunter> MP2E what about what wyager is saying?
21:35:38 <MP2E> If you compared C and C++ programs with the libc/libc++ linked in, it would probably be about as big(though I think Haskell programs would still be slightly larger)
21:35:50 <MP2E> the runtime is more complex too, yes.
21:36:56 * ski petar p√• en SvenskFisk
21:37:39 <hunter> k
21:37:41 <hunter> thanks guys
21:38:02 <ski> (just fyi, not everyone in here is a guy)
21:38:26 <wyager> "guys" is a valid genderless plural personal in english, is it not?
21:38:36 <ski> sometimes
21:39:45 <wyager> Apparently the etymology of the word "guy" to mean "bloke" or "fellow" is actually Guy Fawkes
21:39:46 <ski> i've heard/read some gals saying they've felt exluded by it (even if only by thoughtlessness, or the commonness of that idiom)
21:40:07 <ski> wyager : interesting
21:41:22 <shachaf> The etymology isn't really relevant, though.
21:42:02 <peddie> MP2E, wyager: on my machine, libHSrts_thr.a is 584K, so I don't think you can blame the runtime for everything . . .
21:42:44 <MP2E> peddie: interesting to note :P
21:42:49 <MP2E> perhaps GHC just generates bigger ASM as well?
21:42:57 <wyager> peddie: Interesting. I haven't actually looked why, but "main = putStrLn "hello"" is 1.4 megs
21:43:10 <wyager> (On OS X 10.whatever it is now)
21:43:45 <zq> why is haskell so slow
21:43:51 <zq> i banged everything already
21:44:02 <wyager> zq: More context please
21:44:05 <zq> core is unreadable
21:44:15 <zq> +RTS -p tells me nuthin
21:44:32 <wyager> Did you -auto-all when you compiled?
21:44:42 <wyager> That will make +RTS -prof much more useful
21:45:16 <zq> wyager: -prof -fprof-auto -rtsopts
21:45:26 <wyager> zq: add -auto-all
21:45:28 <zq> alright, auto-all
21:45:42 <wyager> Also, compile with -O2
21:45:48 <peddie> wyager: actually on a 64-bit machine, that library is 852K
21:45:53 <wyager> I don't think you're using any optimizations
21:46:41 <wyager> (note that -prof and -auto-all will make your code slower, but they will help you find where you code is slow, so you can fix that then turn off profiling options)
21:48:57 <zq> yeah no still unhelpful
21:49:04 <zq> alright
21:49:06 <zq> i'll paste
21:49:50 <zq> https://gist.github.com/bryant/394b0e01d4b1d125e819
21:50:05 <zq> oh yeah, i even hand-imperatized it
21:55:49 <deech> How do I use a type variable created by a type function inside my function? eg. f :: (TyFun a b) => a -> ()
21:57:39 <wyager> zq: is the shuffled list supposed to get bigger every time?
21:59:30 <jle`> deech: try (c ~ TyFun a b) ?
22:00:00 <wyager> zq: nevermind
22:00:04 <wyager> let me keep looking at this
22:00:11 <wyager> it's definitely a memory leak that's causing problems
22:00:53 <zq> wyager: why do you say that?
22:00:59 <zq> wyager: %alloc?
22:01:04 <wyager> zq: Because it takes a ton of RAM :)
22:01:12 <deech> jle`: The problem is I just want the `b` and pass it on to something else like 'proxy :: Proxy b' inside my function.
22:01:24 <dmj`> jle`: io-http-streams is on its way
22:01:31 <dmj`> er io-streams-http
22:01:45 <dmj`> jle`: https://github.com/Gabriel439/Haskell-Pipes-HTTP-Library/issues/7
22:01:51 <zq> wyager: oh  ithought that was the default for haskell :p
22:01:52 <jle`> :D
22:01:59 <wyager> zq: haha, not that badly
22:02:08 <wyager> Admittedly, it is a challenge sometimes with laziness
22:03:25 <wyager> fixed it
22:03:27 <wyager> let me upload
22:03:51 <zq> just comment on the gist
22:03:59 <wyager> https://gist.github.com/wyager/f2cc3af57e7d21322062
22:04:18 <wyager> Now, I do feel like what you did *should* have worked
22:04:52 <wyager> I'm not sure why "drop n . iterate foo" built up so much waste
22:06:46 <zq> wyager: that fixed the leak, but didn't really change the speed
22:07:13 <wyager> zq: How long does it take to run for you? 4.85 seconds for me
22:08:00 <wyager> Also, remember -O2 and turn profiling stuff, including -auto-all, off
22:08:44 <zq> wyager: 15 sec
22:08:59 <zq> wyager: yours is 15 flat, mine was 15.5-ish
22:09:05 <wyager> huh
22:09:17 <wyager> What machine are you on?
22:09:34 <zq> wyager: model name      : Intel(R) Core(TM) i7-3770 CPU @ 3.40GHz
22:09:42 <zq> and yes, i have -O3 on
22:09:52 <wyager> Oh, stick with -O2
22:09:56 <wyager> See if that helps
22:10:03 <wyager> O3 can have negative consequences sometimes, I think
22:10:19 <wyager> Also, yeah, your version is 12.6 seconds on mine, but only 4.85 for my version
22:10:22 <wyager> So something's up
22:10:28 <deech> jle`: The answer was to use ScopedTypeVariables.
22:10:34 <glguy_> GHC doesn't go past -O2
22:10:46 <zq> glguy_: i like being optimistic
22:11:01 <jle`> deech: oh, you mean in the where/let clauses, or type signatures inside parts of your function
22:11:07 <jle`> i thought you meant in the type signature, heh.
22:11:11 <jle`> congrats :D
22:11:15 <wyager> zq: What is your entire compilation command?
22:11:42 <zq> wyager: ghc -O2 -auto-all -prof -fprof-auto -rtsopts -fforce-recomp -main-is SaltedShuffle
22:12:18 <wyager> do this: ghc -O2 -fforce-recomp -main-is SaltedShuffle
22:12:22 <wyager> No other stuff
22:12:28 <zq> so no profiling?
22:12:30 <wyager> No
22:12:31 <zq> alright
22:12:36 <wyager> Profiling can slow down some things *a lot*
22:13:00 <zq> wow jesus
22:13:05 <zq>         Command being timed: "./saltedshuffle"
22:13:06 <zq>         User time (seconds): 4.02
22:13:13 <wyager> yay
22:13:30 <wyager> fast enough?
22:13:33 <zq> so the moral here is to come up for air every now and then
22:13:37 <zq> wyager: it's faster than cpp, somehow
22:13:38 <MP2E> yep exactly
22:13:41 <wyager> Nice
22:13:57 <wyager> Haskell makes some super fast code sometimes
22:14:21 <wyager> I wrote fibonacci in Haskell and C, and the Haskell-generated assembly was 1 instruction shorter and about 2% faster :)
22:14:45 <wyager> (mod 2^64 fibonacci)
22:14:52 <zq> i'd love to have a look at the asm dump
22:15:02 <wyager> What platform are you on?
22:15:53 <zq> linux
22:16:10 <gamegoblin> > 1:[1]
22:16:11 <lambdabot>  [1,1]
22:16:12 <zq> x86-linux-gnu-blahblahblah
22:16:15 <gamegoblin> > [1]:[[1]]
22:16:16 <lambdabot>  [[1],[1]]
22:16:17 <wyager> zq: Use objdump
22:16:20 <gamegoblin> > 1:[1]:[[1]]
22:16:21 <lambdabot>  No instance for (GHC.Show.Show t0)
22:16:21 <lambdabot>    arising from a use of ‚ÄòM60911974489811308110909.show_M60911974489811308110...
22:16:21 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
22:16:28 <zq> wyager: i meant your fib's asm
22:16:28 <wyager> objdump -d <executabel name>, IIRC
22:16:32 <wyager> Oh ok
22:16:32 <wyager> sure
22:16:35 <wyager> let me do it real quick
22:16:46 <zq> also, ghc-core is supposedly more convenient for asm dumps too
22:16:58 * hackagebot cndict 0.4.2 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.4.2 (DavidHimmelstrup)
22:16:58 * hackagebot relational-query 0.1.0.1 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.1.0.1 (KeiHibino)
22:17:27 <Axman6> > (1:[1]):[[1]]
22:17:28 <lambdabot>  [[1,1],[1]]
22:21:49 <glguy_> Hmm, haddock doesn't show the difference between newtype instances and data instances
22:22:27 <jle`> > ($[]) . ($1) <$> (:) (:) []
22:22:28 <lambdabot>  [[1]]
22:27:11 <zq> it's not fast enough
22:27:14 <zq> it must go faster
22:27:32 <zq> i just fixed a cpp bug and haskell's back to 1.5x-ish slower
22:27:59 <wyager> zq: You can probably speed it up by not converting between bytestring and other stuff every time
22:28:03 <wyager> that's what you're doing now, right?
22:34:33 <carter> zq: wyager  profiling makes the code slower
22:34:54 <carter> dont build with profling for getting runtime measurements
22:35:08 <wyager> Yep, that was the issue :)
22:35:47 <zq> carter: obviously does, but i didn't think it'd be THAT slow
22:35:57 <carter> haha
22:36:05 <zq> carter: it went from 15.87 to 4.02
22:36:12 <wyager> zq: The problem is that -auto-all inserts stuff even in very tight loops
22:36:17 <carter> ive had ~100x time slow downs
22:36:30 <carter> when doing a profiling build
22:36:32 <wyager> Now, as for this fib thing, for some reason GHC isn't optimizing very well this time around. It keeps using memory when it shouldn't
22:36:34 <zq> wyager: -auto-all didn't really change the runtime of the profiled version, though
22:39:33 <wyager> This is so strange. GHC is using 64(%rsp) as a temp variable instead of a register
22:40:00 <wyager> It's just swapping two registers
22:41:48 <wyager> +0x11	movq                %rsi, 64(%rsp)
22:41:48 <wyager> +0x16	movq                %rdi, %rsi
22:41:49 <wyager> +0x19	movq                64(%rsp), %rdi
22:42:12 * ski grins
22:42:21 <wyager> Am I misreading this? I can't see how that makes sense
22:42:49 <DSALNASS> Am I able to import multiple hs functions into ghsi at once?
22:42:54 <centrinia> So it is swapping.
22:42:58 <DSALNASS> Whenever I import one it forgets the old functions
22:43:10 <Axman6> DSALNASS: do you mean multiple modules?
22:43:13 * ski isn't really much familar with X86 asm syntax, but isn't that an indirect+offset addressing mode on `%rsp' ?
22:43:31 <centrinia> xorq %rsi, %rdi; xorq %rdi, %rsi; xorq %rsi, %rdi; :D
22:43:43 <DSALNASS> Axman6: I just started working with haskell so im not sure
22:44:00 <wyager> ski, I think it's just %rsp[64]
22:44:02 <wyager> which is some stack variable
22:44:05 <DSALNASS> I just have *.hs files with functions defined in them and I would like to use multiple at a time
22:44:10 <wyager> but it should definitely no tbe using memory at all
22:44:10 <ski> wyager : aye, what i dais :)
22:44:25 <centrinia> It should be using the xor swap. :)
22:44:29 <ski> (s/dais/said/)
22:44:40 <wyager> OK, I wasn't sure if that's what you meant
22:44:53 <wyager> But yeah, xor swap or at least another register
22:45:28 <ski> how easy would it be for a static analyzer to determine that the XOR trick indeed swaps ?
22:45:34 <wyager> this is using the L1 cache, which makes it like 3-4x slower than the GCC-generated code
22:45:56 <wyager> ski: Usually stuff like that is hard-coded. This seems more like llvm-land than ghc-land stuff
22:46:29 <wyager> Maybe Clang/LLVM is doing something stupid
22:46:33 <shachaf> There are all sorts of opportunities for optimizations to GHC's generated x86 code.
22:46:49 <shachaf> Is this via llvm or the native code generator?
22:47:03 <wyager> I'm not sure. Just plain old ghc, which I thought used llvm at some point
22:47:17 <centrinia> xchgq %rsi, %rdi :D
22:47:27 <tommd> wyager: LLVM isn't used unless -fllvm is supplied at compile time.
22:47:32 <wyager> I'll try that
22:47:45 <tommd> wyager: I suggest you try 'ghc -O2 -fllvm'
22:48:56 <wyager> I did, and it didn't make any difference. I tried with -fforce-recomp, and it totally broke LLVM haha
22:49:07 <wyager> "Alias must point to a definition" errors out the whazoo
22:49:16 <shachaf> Then it sounds like LLVM wasn't working for you at any point.
22:49:24 <shachaf> What's the Cmm that gets turned into this code?
22:49:40 <wyager> How do I get the Cmm?
22:49:45 <shachaf> -ddump-cmm
22:50:13 <shachaf> Usually I read Cmm unless I'm specifically concerned about machine-level details, because it has a lot more information relevant to the Haskell code.
22:50:24 <shachaf> (But of course in this case you are concerned about machine-level details. But still.)
22:54:03 <Kaidelong> GHC still actually uses C--?
22:54:27 <Kaidelong> I thought that GHC no longer had that as an actual step in the transformation and just compiled the Core directly
22:55:07 <wyager> Generated code looks good: https://gist.github.com/wyager/838946a34b72bede63f9
22:55:24 <wyager> I can't see any reason it wouldn't completely register-ify this
22:57:04 <Guest67454> are there any other exciting things happening in programming languages?
22:57:16 <Guest67454> i feel like ive exhausted the excitement of haskell
22:57:25 <wyager> Guest67454: Play with dependent types
22:57:53 <Guest67454> arent dependantly typed languages kind of slow or incomplete as of yet?
22:58:05 <Kaidelong> yes, but they're making progress
22:58:07 <wyager> Guest67454: Anything more cutting edge than Haskell is going to be that way
22:58:23 <Guest67454> well what the hell
22:58:25 <Guest67454> sounds intersting
22:58:27 <wyager> You can also play with ownership/lifetimes in Rust
22:58:34 <Kaidelong> you could check out Shen, F*, and LiquidHaskell to see arbitrary propositions used as types
22:58:39 <Guest67454> never heard of those two features
22:58:46 <Guest67454> these are great suggestions
22:58:55 <zq> ehhh no liquidhaskell doesn't do "arbitrary"
22:59:11 <Kaidelong> functional logics are always interesting, you could look at Curry, Mercury, Mozart/Oz
22:59:13 <Guest67454> how many of you guys are involved in academia
22:59:15 <zq> more like numerical contracts
22:59:47 <Kaidelong> you could look at Microsoft Research's AsmL
22:59:59 <Kaidelong> which has the distinction of using word documents as source files
23:00:12 <wyager> hahaha
23:00:17 <Guest67454> what dependantly typed language would you guys reccomend?
23:00:28 <Guest67454> for trying out
23:00:29 <Kaidelong> ACL2
23:00:38 <Kaidelong> oh for quickly trying something out?
23:00:39 <Kaidelong> umm
23:00:46 <Kaidelong> probably Idris, if you can get it to build
23:01:09 <Guest67454> is ACL2 more for long term projects?
23:01:19 <glguy_> Agda is easy to build from hackage and has a /similar/ syntax to Haskell
23:01:31 <Kaidelong> ACL2 is incredibly hard to learn, you're not just going to pick it up
23:01:33 <Guest67454> im not sayingquickly,just looking for something to get into
23:01:42 <Guest67454> that will be fun
23:02:32 <Kaidelong> well here's a language I've always been curious about but never really got to look at much
23:02:32 <Kaidelong> http://research.microsoft.com/en-us/projects/asml/
23:03:14 <Guest67454> why does asml use word
23:03:18 <Guest67454> thats so unique
23:03:22 <Kaidelong> it's essentially a way to express state machines that may have a non-finite amount of states
23:03:33 <Guest67454> yea i was just reading that actually
23:03:34 <Kaidelong> it's meant as a specification language
23:03:44 <Kaidelong> so literate programming fits it
23:03:57 <Guest67454> i suppose since i dont have word xml is my only option?
23:04:02 <Kaidelong> because microsoft loves dogfooding, I guess they used their own in-house system for document setting
23:04:16 <Guest67454> or actually i probably cant try it at all on linux
23:04:27 <wyager> I feel like that's a condition for working at microsoft research
23:04:52 <Kaidelong> yeah you'd need visual studio as well
23:04:55 <wyager> "OK, you can do cool stuff, but you have to throw our products a bone every once in a while, no matter how shitty they are"
23:04:55 <Kaidelong> so that's not an option
23:05:09 <Kaidelong> Microsoft word is actually pretty good now
23:05:24 <wyager> It's still exponentially worse than TeX
23:05:28 <Kaidelong> eeeeh
23:05:29 <wyager> Even the typesetting engine is clearly worse
23:05:38 <wyager> Like, just from looking at the generated text
23:05:47 <Kaidelong> I don't know, Word comes with a ton of styles out of the box and has a much lower learning curve
23:05:53 <wyager> I don't understand how an expensive product gets away with making inferior-looking output to a free product
23:05:58 <Kaidelong> it also walks you through doing things like your table of contents and references
23:06:10 <Kaidelong> Latex makes inferior looking output by default IMO
23:06:16 <wyager> What? No way
23:06:19 <faveteli_> Is genetic programming only about changing parameters of the function or does it actually change the code building the function?
23:06:20 <Taneb> Word is like Easy Mode on Guitar Hero, LaTeX is like Expert Mode
23:06:21 <Kaidelong> since I never learned how to apply themes to latex, it still does, for me
23:06:23 <wyager> It has correct kerning and ligature and all that stuff
23:06:36 <wyager> Word does not
23:06:50 <Kaidelong> people don't notice that so much as your flashy theme and colors, I've found
23:06:51 <Guest67454> faveteli_: ive heard of programs that change the code
23:07:00 <Taneb> faveteli_, I don't really know what I'm talking about, but I think it's only the parameters, but sometimes the code is one of the parameters
23:07:01 <Guest67454> faveteli_: i think theyre rarer but im not knowledgeable about it
23:07:36 <Guest67454> would you guys consider yourselves stereotypical programmers
23:07:37 <faveteli_> ok trying to find a book about the subject but most are about genetic algorithms that seems to only change the parameters
23:07:51 <Kaidelong> the thing with latex is that typesetting only goes so far, you need graphic design too. Latex makes this possible, but not easy
23:08:05 <jle`> faveteli_: what would you call the difference between the two?
23:08:23 <jle`> isn't changing he code building the function just the same as changing the parameters to the function that builds the function?
23:08:25 <wyager> Guest67454: Which stereotype?
23:08:49 <Guest67454> wyager: nerdy, socially awkward, indoorsy, etc.
23:09:05 <Guest67454> the stereotype really bugs me
23:09:23 <Taneb> Guest67454, I fit the stereotype to some extent but I know that a lot of programmers really do not
23:09:31 <wyager> I mean, it (just like most stereotypes) has a pretty solid real-world foundation
23:09:50 <Guest67454> it bugs me so much that it makes me want to not program because i really dont want to live like that
23:09:55 <wyager> But honestly, most programmers I know don't fit that
23:10:02 <wyager> maybe I just don't notice the ones that do
23:10:10 <ouchthats> pl (\x -> f . g . h x)
23:10:11 <MP2E> Don't fit the stereotype then, no one is forcing you :P
23:10:30 <Guest67454> i worry that programming itself forces you into that box
23:10:34 <wyager> Nah
23:10:35 <faveteli_> jle`: well yes makes sense :) I was more thinking about how one could evolve lisp macros but higher order functions would fit my description also. Thanks, not fully used to FP yet
23:10:36 <Guest67454> like somehow it molds you into that person
23:10:38 <MP2E> I doubt it
23:10:48 <MP2E> I fit that stereotype perfectly and I can promise you I was this way long before I programmed
23:10:52 <MP2E> heh
23:11:00 <Guest67454> maybe i am that way
23:11:09 <Guest67454> but i just dont want to broadcast it
23:11:17 <Guest67454> because it gives you lower social status
23:11:27 <wyager> I mean, the fact that most programmers like computers leads a lot of them to be pasty and overweight, but I think the "socially akward" thing comes from the fact that socially akward -> likes computers, not likes computers -> socially akward
23:11:37 <wyager> s/most/some
23:11:50 <MP2E> oh i know what you mean Guest67454
23:11:55 <Kaidelong> I can confirm that when I'm programming a lot my physical and mental health starts to tank
23:11:58 <MP2E> yeah, I typically don't bring up programming at parties and stuff
23:12:02 <MP2E> unless someone else brings it up in a good way
23:12:06 <MP2E> heh
23:12:14 <ouchthats> @pl (\x -> f . g . h x)
23:12:14 <lambdabot> ((f . g) .) . h
23:12:14 <Guest67454> why is it so stigmatized
23:12:15 <MP2E> Kaidelong: sorry to hear that :(
23:12:26 <Guest67454> i think it may be that way for me too
23:12:35 <Guest67454> it definitely burns me out even though i love doing it
23:12:44 <wyager> Guest67454: It's mentally intensive
23:12:56 <Kaidelong> it's probably managable if you limit the amount of time spent on it but this is hard
23:13:19 <Guest67454> itd probably be way less intensive if more people programmed
23:13:26 <Guest67454> but also way less valuable and special
23:13:39 <Guest67454> thats another thing im worried about, becoming a "grunt" programmer
23:14:20 <wyager> Just avoid that by establishing yourself as talented and setting your own terms
23:14:21 <Guest67454> like just writing tedious code, and not getting to make meaningful descisions
23:14:32 <MP2E> well, you're in #haskell, I don't think you have to worry about that too much :P I think the grunts are the people who just learn the language that 'makes the most money' and jump right in
23:14:39 <wyager> ^exactly
23:14:56 <Guest67454> it could turn out im not talented, i havent gotten the chance to really find out
23:15:10 <Guest67454> ive written programs ofc but you know what i mean by that
23:15:20 <wyager> I think most of CS talent is a function of effort
23:15:24 <wyager> so it's up to you, really
23:15:30 <Guest67454> if thats true than i should be ok
23:15:34 <Guest67454> because i really like cs
23:15:38 <Guest67454> and do it
23:15:54 <Guest67454> although some things i find dont grab me...
23:16:16 <Guest67454> like the academic stuff, im not really excited by researchusually perhaps because i dont understand it, and that concerns me
23:16:27 <Guest67454> sorry about off topic
23:16:37 <Kaidelong> #haskell-blah
23:17:42 <Guest67454> thanks
23:19:06 <wyager> So yeah, anyone have any idea why GHC is doing a register swap by using a stack variable as a temp value?
23:29:39 <Guest67454> is there any dependantly typed language in which i could write a functioning program? does the description "proof-assistant" mean that thats not an option?
23:30:56 <Welkin> idris
23:31:00 <Welkin> agda
23:31:02 <Welkin> coq
23:31:11 <Welkin> there are more than that
23:31:15 <Welkin> I just don't know about them yet
23:31:17 <Guest67454> agda is described as a proof assistant
23:31:27 <Welkin> idris is a general purpose language
23:31:37 <Guest67454> ah ok ill investigate it
23:31:41 <Guest67454> thanks
23:36:42 <macalimlim> hello :) what testing framework would someone recommend? testing both pure and impure code...
23:37:06 <Guest67454> "cabal package list is 36 days old"
23:37:09 <Guest67454> but its upto date?
23:37:12 <Guest67454> that doesnt seem right
23:37:16 <pyon> I just read this article on polytypic programming: http://zenzike.com/posts/2010-12-10-from-polymorphic-to-polytypic . Is it just me, or the relationship between the Rep and Generic type classes is similar to the relationship between Elements and Visitors in the Visitor pattern?
23:37:18 <Guest67454> is haskell dying?
23:38:00 <macalimlim> hello :) what testing framework would someone recommend? testing both pure and impure code...
23:39:50 <macalimlim> hello :) what testing framework would someone recommend? testing both pure and impure code is required...
23:40:15 <kvanb> use QuickCheck
23:40:27 <kvanb> sorry, HSpec
23:41:43 <macalimlim> thnaks kvanb
23:41:44 <macalimlim> :)
23:42:09 <Kaidelong> Guest67454: pretty sure all that means is that you need to run "cabal update"
23:42:31 <kvanb> to get an idea what that looks like
23:42:50 <kvanb> I do some silly testing here: https://github.com/kvanberendonck/codec-rot13/blob/master/test/Spec.hs
23:43:14 <kvanb> you can ofcourse go much more complex than that! the library is very powerful
23:43:25 <Guest67454> Kaidelong: i did but it downloads nothing and says its equal to whats on hackage
23:43:52 <macalimlim> thanks again :)
23:44:00 <macalimlim> that was very helpful
23:49:44 <bernalex> hmm I have an 'instance Foo a Bar => Foo (a, b) Bar where ...', but now I need to change it so that b is also an instance of Foo. how did I do that again? something with multiparam stuff
23:50:23 <jle`> does (Foo a Bar, Foo b Bar) => Foo (a, b) Bar work?
23:50:50 <bernalex> I have an 'instance Foo a b => Foo Fu Bar where f a = blah', and I want to make tuple an instance of Foo, so that f (a, b) = (blah a, blah b)
23:50:55 <bernalex> jle`: hmm
23:53:27 <bernalex> jle`: maybe? :-P
23:53:42 <jle`> d-:
23:54:07 <bernalex> jle`: I'm not sure if that's wrong, or I'm using lens wrong
23:54:27 <bernalex> it was originall Foo a Bar => Foo (a, b) Bar where f = _1 . f
23:54:56 <bernalex> now I have (Foo a Bar, Foo b Bar) => Foo (a, b) Bar where f = both f
23:55:14 <bernalex> and it spectacularly doesn't typecheck because "both is applied to too many arguments"
23:55:45 <bernalex> does it maybe matter that Bar is actually Maybe Bar?
23:56:02 <bernalex> hm. shouldn't.
23:56:33 <bernalex> oh wait
23:56:45 <bernalex> Foo (a, b) Bar is just wrong I think
23:57:18 <bernalex> or maybe it isn't. gah idk.
23:58:27 <Flonk> Does anyone know of an explanation of what it means for a functor to be cofree?
23:59:59 <dibblego> Flonk: it's not exactly an accurate statement, so maybe you can clarify with some context. However, cofree is: data Cofree f a = Cofree a (f (Cofree f a)), which gives you a Comonad (all comonads are functors) as long as there is a Functor for (f).
