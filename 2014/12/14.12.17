00:00:05 <Myrl> Meh.
00:00:22 <Myrl> ...
00:00:30 <Myrl> Perhaps xmonad borked.
00:02:06 * hackagebot persistent 2.1.1.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.1.2 (MichaelSnoyman)
00:07:06 * hackagebot persistent-postgresql 2.1.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.2 (MichaelSnoyman)
00:07:08 * hackagebot persistent-sqlite 2.1.1.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.1.1.1 (MichaelSnoyman)
00:10:16 * hackagebot persistent-postgresql 2.1.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.2 (MichaelSnoyman)
00:10:16 * hackagebot persistent-sqlite 2.1.1.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.1.1.1 (MichaelSnoyman)
00:11:48 <Guest6> hi
00:12:27 <jle`> hi Guest6 !
00:12:47 <Guest6> I am new here so just checking out
00:13:40 <srhb> Guest6: It's a bit quit right now, but it's usually a very active and friendly channel. :)
00:13:43 <srhb> quiet*
00:14:18 <Guest6> ok, yeha I was noticing the same why so quite here
00:14:26 <srhb> Just the hour I think.
00:14:43 <Guest6> ok
00:15:10 * hackagebot hsay 1.1.0 - (ab)Use Google Translate as a speech synthesiser  http://hackage.haskell.org/package/hsay-1.1.0 (alexander)
00:16:20 <Guest6> I want to read some good paper to get started with FP what you guys recommend ?
00:17:22 <srhb> Hmm, maybe the John Hughes one.
00:17:36 <Guest6> why FP matters?
00:17:48 <srhb> Yeah.
00:18:00 <Guest6> great, thats on my list
00:18:18 <Myrl> Lol'd.
00:18:41 <Myrl> I think I borked everything Haskell related.
00:18:44 <Myrl> :|
00:19:08 <srhb> Myrl: Sounds fun!
00:19:18 <Guest6> borked everything Haskell related ?
00:19:26 <Myrl> Who knows what I did.
00:19:52 <Guest6> no idea
00:20:10 * hackagebot keter 1.3.7 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.7 (MichaelSnoyman)
00:22:58 <Myrl> Well...
00:23:03 <Myrl> I'll try to resolve this problem, BRB.
00:27:16 * Myrl tries a method which rarely fails... reinstalling.
00:27:22 * Myrl laughs at his own joke since he's a sad person.
00:29:37 <ReinH> Myrl: did you try turning it off and back on again?
00:30:02 <Myrl> ReinH: Hahahahaha.
00:32:12 <Myrl> So, should I use Cabal instead?
00:32:36 <Myrl> srhb: Should I use cabal instead?
00:33:12 <srhb> Myrl: I usually do.
00:33:36 <srhb> You'll need to get the X11 dev headers afair. But it should tell you as much.
00:33:57 <Myrl> srhb: Also, how do I make a sandbox on cabal?
00:34:12 <srhb> Myrl: mkdir foo && cd foo && cabal sandbox init
00:34:29 <Myrl> srhb: Ah.
00:35:10 * hackagebot streaming-commons 0.1.8 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.8 (MichaelSnoyman)
00:37:07 <srhb> Myrl: So the way to go is probably cabal unpack xmonad; cd xmonad*; cabal sandbox init, cabal sandbox install
00:39:02 <Myrl> srhb: I see.
00:39:13 <srhb> er, not sandbox install
00:39:16 <srhb> just cabal install
00:39:23 <Myrl> Ah, okay.
00:39:49 <apitheia> Is there a way to compose two functions where the first function takes 2 values, such as (a -> b -> c) -> (c -> d) -> a -> b -> d
00:43:02 <c_wraith> apitheia: yes.  But there's not an operator for it in base
00:43:39 <alpounet> :t \f g -> (f .) . g
00:43:40 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
00:43:51 <c_wraith> :t (.:)
00:43:52 <lambdabot>     Not in scope: ‘.:’
00:43:52 <lambdabot>     Perhaps you meant one of these:
00:43:52 <lambdabot>       ‘.’ (imported from Data.Function),
00:43:57 <c_wraith> sometimes it's named that
00:44:47 <apitheia> that gives me a parse error, do I just need to define it myself?
00:45:21 <c_wraith> yeah, it's just a common name for it.
00:46:28 <matematikaadit> @let f (.:) g = \x y -> f (g x y)
00:46:29 <lambdabot>  .L.hs:174:21:
00:46:29 <lambdabot>      Ambiguous occurrence ‘f’
00:46:29 <lambdabot>      It could refer to either ‘L.f’, defined at .L.hs:174:1
00:46:49 <matematikaadit> @let m (.:) n = \x y -> m (n x y)
00:46:50 <lambdabot>  .L.hs:174:21:
00:46:50 <lambdabot>      Ambiguous occurrence ‘m’
00:46:50 <lambdabot>      It could refer to either ‘L.m’, defined at .L.hs:174:1
00:47:10 <Welkin> I keep getting the same error: http://hackage.haskell.org/package/containers-0.5.6.1/docs/Data-Map-Lazy.html#v:map
00:47:19 <Welkin> why is there no documentation for this?
00:49:41 <Welkin> whoever updated containers in the last two days broke hoogle
00:49:50 <Welkin> since they did not upload hackage docs
00:50:02 <Welkin> so now all the links from hoogle don't work
00:50:19 <Welkin> at least the ones pointing to containers
00:50:43 <srhb> I thought Hackage was responsible for building docs.
00:55:17 <apitheia> ok this is weird, if I define .: as (.).(.) I can use .: and it works perfectly, but if I use (.).(.) in place I get errors
00:55:42 <c_wraith> apitheia: precedence problem?
00:56:07 <c_wraith> apitheia: f (.) . (.) g parses as (f (.)) . ((.) g)
00:56:30 <apitheia> c_wraith: it looks like infix problem actually, f ((.).(.)) g doesn't work but ((.).(.)) f g does
00:56:41 <c_wraith> yeah, same thing
01:01:40 <matematikaadit> @let (.:) = (.) . (.)
01:01:41 <lambdabot>  Defined.
01:02:11 <jle`> :t concat .: map
01:02:12 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
01:02:15 <jle`> neat
01:02:27 <jle`> i still haven't been able to bring myself to use it
01:02:35 <jle`> :t \f -> concat . map f     -- is just fine for me
01:02:36 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
01:03:39 <kressara> Hmmm...
01:03:51 <srhb> kressara: hmmm?
01:07:16 <kressara> Don't mind me, this is just my alternate name when I'm on Linux terminal.
01:07:29 <kressara> You'll forget about everything once I'm gone.
01:08:29 <Fuuzetsu> :t the
01:08:30 <lambdabot> Not in scope: ‘the’
01:08:47 <Fuuzetsu> Anyone know how GHC.Exts.the is meant to be useful?
01:09:05 <Fuuzetsu> “the ensures that all the elements of the list are identical and then returns that unique element”, the :: Eq a => [a] -> a
01:10:04 <tdammers> what happens when they're not identical?
01:10:06 <tdammers> bottom?
01:10:18 <bitonic> that's some solid naming
01:10:25 <Fuuzetsu> tdammers: no idea!
01:10:40 <bitonic> yeah, throws an `error'
01:10:41 <Fuuzetsu> if we know they are identical and some exist, ‘head’ does the same thing…
01:10:44 <tdammers> considering the type, I don't see how else it could "ensure" that
01:10:47 <Aruro> if i run this program -> main = interact count ; count s = show (length s) ++"\n"     ____ on itself
01:10:50 <srhb> Yep, error!
01:10:57 <Aruro> than it shows wrong file size
01:11:02 <srhb> *** Exception: GHC.Exts.the: non-identical elements
01:11:10 <tdammers> ah, hmm
01:11:11 <Aruro> file size is smaller
01:11:56 <tdammers> so exception-based flow control ;)
01:12:00 <srhb> Beautiful.
01:12:11 * Fuuzetsu gets ill
01:12:14 <bitonic> well, it's flow control only if you `catch' that :)
01:12:23 <tdammers> avoiding Boolean Blindness through Exception Blindness
01:12:56 <Fuuzetsu> I wonder what was wrong with ‘Maybe’
01:13:17 <Aruro> real size of this program on vista is 1526344, but program itself shows its size to be just 1526327 bytes
01:13:25 <srhb> Haddock needs some kind of anecdote markup
01:13:25 <Aruro> what is the reason?
01:13:31 <bitonic> Fuuzetsu: btw, some tests use that function -- e.g. `testsuite/tests/deSugar/should_run/mc06.hs'
01:13:39 <srhb> Aruro: Paste the whole program please.
01:13:52 <Aruro> main = interact count ; count s = show (length s) ++"\n"
01:13:54 <srhb> But surely it's a binary vs. character thing
01:14:01 <toby1851> Aruro: i bet it involves unicode
01:14:09 <sriprasanna> I have been trying to learn haskell and I am looking for resources to: learn haskell using TDD and tutorial for haskell-vim-now development environment. Any help is appreciated.
01:14:16 <srhb> Aruro: How does that program known the name of the file?
01:14:21 <Aruro> i run it on itself
01:14:30 <Aruro> wc.exe < wc.exe
01:14:36 <srhb> Ah
01:15:00 <srhb> Well yeah, encoding.
01:15:00 <Aruro> does .exe have unicode?
01:15:10 <srhb> Well you're reading it in as a String
01:15:32 <tdammers> doesn't matter if it "has" unicode
01:15:32 <c_wraith> Aruro: Char isn't a byte
01:15:35 <srhb> So some of binary stuff corresponds to single characters
01:15:41 <srhb> Instead of one character
01:15:48 <srhb> per byte.
01:16:00 <tdammers> String is characters, by definition, so that's what you're counting if you read the file as a String
01:16:09 <Aruro> yes but program gives the result which is LESS not bigger
01:16:16 <tdammers> yes
01:16:35 <c_wraith> Aruro: do you know about unicode encodings?
01:16:40 <Aruro> no :)
01:16:43 <Aruro> have no idea :)
01:16:45 <c_wraith> Aruro: they represent a single character as multiple bytes
01:16:46 <tdammers> one character (which is what you're counting) can be between 1 and 4 bytes in utf-8 (which is how you're treating your binary input)
01:16:54 <c_wraith> Aruro: when the file is read, it's decoded.
01:17:08 <c_wraith> Aruro: That means that sometimes multiple bytes are treated as a single character.
01:17:08 <Aruro> i see , so it does count unicode?
01:17:17 <c_wraith> Aruro: String is unicode
01:17:20 <Aruro> ok
01:17:25 <speak> sriprasanna: Maybe someone can correct me, but "learn haskell using TDD" sounds strange to me. Maybe you should first learn Haskell, and then learn to do TDD with it?
01:17:28 <Aruro> thank you!
01:17:47 <srhb> TDD is probably just "learn QuickCheck" after learning Haskell
01:17:53 <tdammers> speak: I guess you can learn both in tandem
01:18:05 <tdammers> srhb: TDD is more than just "write tests for everything"
01:18:13 <srhb> Impossibru!
01:18:17 <tdammers> srhb: TDD is "red-green-refactor"
01:18:26 <speak> tdammers: I wouldn't recommend learning anything in tandem with Haskell, unless you're super familiar with functional languages already :P It's a handful as it is
01:18:26 <sivteck> "write more tests"
01:18:31 <sriprasanna> speak: I am really comfortable with TDD concepts and I am more productive when I learn a language along with TDD
01:18:33 <tdammers> speak: yes
01:19:04 <tdammers> sriprasanna: then you're not leaning Haskell along with TDD, you're *using* TDD to learn Haskell
01:19:15 <sriprasanna> tdammers: true
01:19:41 <tdammers> sriprasanna: if you're comfortable with TDD, I suggest you learn the basics of Haskell, and then jump into a little project that you do TDD-style
01:20:21 <tdammers> sriprasanna: if you want to keep the amount of tooling and libraries low, consider using shelltestrunner or something like that for your tests
01:20:45 <sriprasanna> tdammers: when I learn a language I usually go through the basics and put them in practise by solving Project Euler problems with TDD. It really brings me up to the speed in few weeks in a language.
01:20:57 <tdammers> sriprasanna: sure, that's a decent enough approach
01:21:06 <sriprasanna> tdammers: thanks will try shelltestrunner
01:21:36 <tdammers> sriprasanna: it's a language-agnostic tool, really, great for low-ceremony end-to-end testing
01:22:13 <tdammers> sriprasanna: eventually you'll want to look into QuickCheck and maybe HUnit or something like that, but those require a fair bit of Haskell fundamentals, so they're not the first thing you should tackle when learning haskell
01:22:41 <sriprasanna> tdammers: Thanks. Never new about shelltestrunner. Looking into it now.
01:23:13 <sriprasanna> tdammers: what is your dev environment like for Haskell?
01:23:15 <Aruro> so maybe someone should update haskell wiki
01:23:31 <Aruro> the section on interact not being the real wc :) cause of unicode
01:23:55 <tdammers> sriprasanna: Debian, XMonad, urxvt, vim, cabal, iceweasel, chromium, apache, postgresql
01:24:06 <tdammers> sriprasanna: plus a bunch of CLI utilities
01:24:11 <c_wraith> Aruro: wc is often unicode-aware
01:24:12 <tdammers> sriprasanna: oh, and git
01:24:33 <Myrl> Never fails.
01:24:53 <sriprasanna> tdammers: and plugins for vim? I am looking at haskell-vim-now. It looks nice but if there is any better option I am ok to switch but prefer using Vim over other text editors.
01:25:13 <tdammers> sriprasanna: no plugins
01:25:19 <sriprasanna> tdammers: sweet!
01:25:31 <tdammers> sriprasanna: I could use one to manage imports, but the need isn't pressing enough yet
01:25:57 <tdammers> hasktags, btw, and command-line hoogle - I do use those
01:26:08 <tdammers> and I make heavy use of :! in vim
01:26:26 <tdammers> git "integration", for example, is doing stuff like :!git add %
01:26:35 <tdammers> no plugin needed :D
01:27:19 <tdammers> another thing I do is I write a makefile wrapper for cabal install - just a simple 3-line makefile so that :make in vim trigger cabal install
01:27:35 <tdammers> dirty hack, but very convenient
01:29:20 <sriprasanna> tdammers: that is a pretty good approach.. I will give it a shot as well.. never thought about it before
01:32:43 <Aruro> how close is ocaml to haskell? im looking at syntax and it looks virtually same, with haskell one being much cleaner
01:33:06 <c_wraith> Aruro: in practice, almost completely different
01:33:14 <Aruro> really? why?
01:33:28 <c_wraith> purity, mostly.  Typeclasses are another big thing
01:33:32 <bitonic> well.  I'd say that in the programming language landscape they are more alike than different
01:33:35 <bitonic> and lazyness
01:33:42 <tdammers> purity, strictness, typeclasses, yes
01:33:48 <bitonic> and the module system
01:33:54 <bitonic> records
01:33:55 <Aruro> there is no purity in ocaml?
01:34:12 <tdammers> more like, there is no impurity in haskell ;D
01:34:13 <jle`> laziness was one of the things that bit me most
01:34:14 <c_wraith> In practice, it means the way you use the languages is pretty different.  A few idioms translate, but not most
01:34:32 <jle`> i didn't realize how much i took laziness for granted
01:34:44 <jle`> so many of my haskell idioms went kapoot
01:35:03 <srhb> Yep, it's painful to lose.
01:35:21 <Kaidelong> OCaml and Haskell are really close
01:35:24 <jle`> the way typeclasses work in haskell and how haskellers use them for is a bit different too i think
01:35:51 <Kaidelong> OCaml has an incredibly cool type system that is in some ways more advanced than Haskell's (a bit like implicit typeclasses)
01:35:59 <jle`> i've found i've used typeclasses less for overloading as i have as tools to state guaruntees in type signatures
01:36:10 <Kaidelong> it would be enlightening to spend some time with it
01:36:19 <jle`> ocaml definitely has a lot of things right
01:36:37 <jle`> but i think they are different enough in key places that the idioms and practical writing/development are pretty different
01:36:40 <Kaidelong> OCaml development practice is quite different though
01:36:42 <Zol_> In http://lpaste.net/116676, is the result from line2 m1 the same as line2 m2, and line m2? I feel like it should be the same logically, but I'm afraid that the parentheses might introduce something I'm not aware of yet. Doing (line2 m1) == (line2 m2) gives me False. :/
01:36:46 <Kaidelong> like
01:37:03 <Kaidelong> OCaml developers intentionally avoid putting type signatures on things because they think that is better practice
01:37:20 <Zol_> I'm trying to write a line2 that would give the same result for m1 and m2, as line m2 would.
01:37:32 <Kaidelong> it avoids accidentally restriction polymorphism or locking in a particular implementation and preventing refactoring
01:37:48 <Aruro> i got the feeling they perceive Ocaml as being more safe
01:38:33 <Kaidelong> Haskell seems to have ended up with the opposite approach being the norm because monomorphic functions are more performant and produce better error messages (and explicit type signatures prevent type errors from propagating)
01:38:52 <c_wraith> Also because types are documentation
01:39:20 <edwardk> monomorphic functions are no more performant, the representation doesn't change if you go from a -> a  to Int -> Int
01:39:20 <c_wraith> and machine-checked documentation, at that!
01:39:36 <edwardk> they can be a bit more performant if you are dealing with a concrete instance
01:39:47 <Kaidelong> edwardk: wait what. I thought haskell does runtime dispatch for a -> a but not for Int -> Int
01:39:49 <edwardk> but that's about it
01:39:53 <edwardk> um, no
01:40:01 <edwardk> a -> a and Int -> Int generate the exact same code
01:40:13 <c_wraith> edwardk: well, yes.  Num a => a -> a and Int -> Int are not the same for performance
01:40:15 <edwardk> if you have Foo a => a -> a    vs. Int -> Int where there happens to be an instance of Foo Int it can make a different
01:40:22 <c_wraith> that's the case he means, I think
01:40:28 <Kaidelong> that was the case I meant
01:40:28 <edwardk> but for 'a -> a' nothing changes
01:40:44 <Welkin> does anyone use binary trees? Or do you just use a rose tree or finger tree?
01:41:40 <Welkin> data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a) -- this seems clumsy
01:42:07 <edwardk> anyways, in general i write the polymorphic version of things because i can reason about it, and i find that with enough work i tend to get better optimizations available to me by sticking to my guns and writing the 'most general' version of a thing because it works in more sitatuations including later on when i write a compiler for whatever domain i care
01:42:07 <edwardk> about
01:42:15 <mmmm> Finally learned what a "NamedFieldPun" was by accidently trying to use one
01:42:22 <edwardk> and can safely thread it through the entire thing by using the highly parametric nature of the tools i built
01:42:24 <bitonic> I think what Kaidelong is saying is that when you have parametrised modules in OCaml you can reliably generate de-modularised functions when you instantiate the modules
01:42:24 <Kaidelong> rose trees might be more idiomatic for haskell, I think that's the cofree comonad over lists?
01:43:31 <edwardk> Welkin: you can use whatever tree structure you need to express your problem. if you have no shape invariants, then a rose tree is fine, if you do then perhaps a binary tree is better, or a 2-3 tree or a finger tree or a braun tree, or an AVL tree, or a binary tree of bounded balance or...
01:43:56 <bitonic> while with Haskell type classes it's harder to do
01:44:21 <edwardk> bitonic: sure, but then you can also do things like polymorphic recursion here, so its a trade off
01:44:25 <edwardk> i like fingertrees =P
01:44:29 <Aruro> ok that went much further than i thought :)
01:44:34 <bitonic> edwardk: it's obviously a tradeoff
01:44:47 <Kaidelong> the main thing I miss working outside of haskell is higher kinded polymorphism
01:44:54 <Kaidelong> lazy evaluation is easy to mock
01:44:59 <edwardk> i write things in the haskell manner because its the only language in which i can really write down most of the thoughts i like to think
01:45:11 * hackagebot yesod-bin 1.4.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.2 (MichaelSnoyman)
01:45:17 <Aruro> lets rephrase it, is there language which is closer to haskell than ocaml?
01:45:19 <Kaidelong> I've never encountered a problem where I needed polymorphic recursion, but I know that some of them exist
01:45:32 <bitonic> and to be fair, we could go much further with Haskell type-classes anyway -- what the OCaml compiler does is to save the parametrised code for modules, which is pretty much the same machinery that you get with INLINABLE
01:45:39 <Kaidelong> Aruro: Clean may be worth a look, it's abandoned now, which is a shame
01:45:43 <Welkin> Aruro: idris
01:46:09 <shachaf> Did you see conal's fancy parallel scans talk?
01:46:13 <Kaidelong> Disciple and Idris are other good bets, Disciple for Haskell's manifest effects being explored as the central focus, Idris for dependent types
01:46:28 <shachaf> http://conal.net/talks/understanding-parallel-scan.pdf
01:47:02 <Kaidelong> mercury has syntax similar to prolog but semantics more like clean
01:47:15 <Kaidelong> it's very similar to Haskell
01:47:19 <Kaidelong> in a lot of ways
01:48:10 <Kaidelong> I guess the best answer is the languages in the Haskell programming language family (Curry, Timber, Idris, Frege, Disciple, Elm, O'Haskell, Helium)
01:48:51 <Kaidelong> many of them are so similar to Haskell that a lot of code is valid for both
01:50:11 * hackagebot cndict 0.4.3 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.4.3 (DavidHimmelstrup)
01:50:12 <Kaidelong> Clean would be in this family as well
01:50:35 <edwardk> the thing that keeps me away from disciple is it conflates pretty much all use of the idea of a monad with the concept of IO-like effects
01:50:43 <edwardk> same problem Clean has
01:51:14 <edwardk> i have a few problems i'd love to be able to express as a monad in Clean, you can make a nice quantum probability monad that is safe there in theory, if they didn't write off the whole concept of a monad
01:51:17 <Kaidelong> linear types are cool for so much more than just effects, as far as Clean goes
01:51:25 <edwardk> sure
01:51:38 <edwardk> but they are mostly orthogonal to 'monads as a code organization principle'
01:51:46 <edwardk> they just happen to both be usable for effects
01:51:52 <purelazy> is there a version of Haskell which can show a function? e.g. show (\x -> x + x) = "\x -> x + x)"
01:52:13 <edwardk> so they throw out the monads because they don't use them for the original flagship monad purpose
01:52:22 <edwardk> very very few of the lines of code i write in do notation live in IO
01:52:26 <tdammers> purelazy: how would that work?
01:53:08 <purelazy> tdammers: like any other program that prints out a data structure I guess
01:53:21 <Kaidelong> tdammers: lisp has something like this, they just keep the ASTs around at runtime I think?
01:53:44 <tdammers> Kaidelong: yes, but then, a lisp function is an entirely different beast than a Haskell function
01:53:46 <Aruro> purelazy you want code inspection
01:54:01 <Aruro> as far as i was asking here a month ago it is not possible
01:54:15 <tdammers> lisp pretty much takes a list, tacks on some stuff to implement scope, and wraps it into a value - all that at runtime
01:54:17 <Kaidelong> yes being able to do that in a reasonable fashion eliminates a lot of other possibilities
01:54:30 <tdammers> it's relatively easy to decompose that into AST
01:54:31 <Kaidelong> for optimizing and transforming code
01:54:37 <Kaidelong> it's something of a tradeoff
01:54:50 <Aruro> functions can not see their definition , nor definitions of other functions
01:54:51 <tdammers> but I don't think you can trivially reverse the Haskell compilation process for a function
01:55:01 <Kaidelong> F#'s approach was to print the function pointer
01:55:03 <Kaidelong> not very useful
01:55:09 <edwardk> purelazy: the problem is you wind up with things being built up out of simpler parts
01:55:11 <Kaidelong> I think Scheme does something like that too
01:55:16 <tdammers> I think the best you could get would be that you use TH or something to inspect the function's type signature and print that
01:55:49 <tdammers> so you'd print something like "Int -> String"
01:55:53 <edwardk> purelazy: const a b = a; const = \a b -> a            const 12   becomes \b -> 12
01:56:04 <edwardk> some of the 'functions' may be infinitely large when expanded to show
01:56:21 <bezirg> i have two SomeException values  . Can I write a an Eq instance for them? I was looking at the data a :~: b of Data.Typeable, but I don't understand how to use it. Has anybody tried sth similar?
01:56:27 <purelazy> Yeah - these are not infitite
01:56:38 <edwardk> these happen not to be
01:56:54 <Aruro> purelazy it is not possible at the moment
01:56:59 <purelazy> and show [1..] works anyway
01:57:01 <Aruro> its good idea but not realized yet
01:57:30 <Aruro> not realized cause there are other good people who think its bad idea :)
01:57:37 <Kaidelong> not sure it's a good idea
01:57:47 <purelazy> I'm sure a good old fashion LISP would likely be able to do it
01:57:49 <Kaidelong> part of why functions can be optomized is because they are black boxes
01:57:54 <fizbin> @src join
01:57:54 <lambdabot> join x = x >>= id
01:57:59 <Kaidelong> I think Common Lisp can sort of do it to this day!
01:58:01 <Zol_> If I have a structure like: (((Node 1 :+: Node 2) :+: Node 3) :+: Node 4), how can I turn that into (Node 1 :+: (Node 2 :+: (Node 3 :+: Node 4))) instead?
01:58:06 <Kaidelong> but you need to explicitly transform a function into a list first
01:58:13 <tdammers> another thing that you could do would be to write a quasi-quoter that accepts plain Haskell source code, and runs it through the normal compilation process, but also generates some code to print a string representation
01:58:17 <edwardk> purelazy: the point is more that you need to either a.) reduce in which case you don't terminate for things like the Y combinator or b.) not reduce in which case you leak memory for ever because someone someday might print your function
01:58:37 <tdammers> you'd have to write your functions in the quasi-quoter though, and I'm not sure how you'd glue the string representation into a Show instance
01:58:40 <edwardk> purelazy: and as a side-effect now the two definitions i gave above for 'const' cease to be equal because you can distinguish between them by showing
01:58:54 <Myrl> Hmmm... how to use haddock?
01:59:01 <shachaf> Extensionality is pretty important.
01:59:08 <edwardk> Myrl: i usually just use 'cabal haddock'
01:59:08 <shachaf> Well, at least it's pretty nice.
01:59:27 <Aruro> on conceptual level it is higher cause program can access more information about itself
01:59:39 <Aruro> simple logic, its difficult but its higher
01:59:41 <edwardk> scheme made the mistake of giving you the ability to distinguish lambdas by identity. as a result it pretty much lost access to almost all interesting optimizations
01:59:57 <Myrl> Erm, why must you supply a file to haddock?
02:00:00 <Kaidelong> does Racket do the same thing?
02:00:03 <Myrl> Hmmm...
02:00:17 <edwardk> because you have to do control flow analysis to make sure it doesn't find its way into any place that might check
02:00:24 <edwardk> Kaidelong: yes
02:01:39 <Aruro> you say the downsides
02:01:43 <purelazy> So am I to take "No" as the answer to the question "is there a version of Haskell which can show a function? e.g. show (\x -> x + x) = "\x -> x + x)""
02:01:45 <Aruro> can you find the benefits?
02:01:58 <Aruro> edwardk
02:01:58 <bitonic> shachaf: eta is pretty important too
02:02:18 <Aruro> yes. NO
02:02:38 <Myrl> Guys, so I just finished "Learn You A Haskell For Great Good" what next should I read on?
02:02:39 <Aruro> functions are black boxes and inspection is being fraud upon because you can USE it
02:02:46 <tdammers> purelazy: indeed. And personally, I think it'd be wrong for functions to implement Show for similar reasons as it would be wrong for them to provide Eq.
02:03:32 <shachaf> bitonic: Eh.
02:03:43 <Aruro> there is nothing wrong with anything
02:03:48 <Aruro> its just more faulty
02:03:54 <Aruro> that is all
02:03:58 <mietek> Should all Cabal packages which reference extra-libraries (native OS libraries) use pkg-config on Linux?
02:04:40 <bitonic> Aruro: having that `Show' instance would break some widely shared assumptions on when two functions are "equal" -- a consequence of two things being equal is that you can substitute one for the other and always get the same result
02:05:03 <Aruro> im sure in current haskell you can write plenty of abusive code too, if you want to
02:05:37 <Aruro> good point bitonic
02:05:42 <Kaidelong> tdammers: why Eq? Pointer equality is pretty well defined
02:06:00 <Aruro> i just wanted to point out the rejection is not the right answer, right answer it IS difficult at the moment
02:06:08 <Kaidelong> and useful, too
02:07:03 <Aruro> i asked edwardk can we think about Benefits of code inspection?
02:07:11 <Aruro> we look at one side of the problem only
02:07:27 <mauke> what are the benefits of code inspection?
02:07:34 <Aruro> you see nobody knows :)
02:07:55 <edwardk> Aruro: you can go print arbitrary functions in javascript today
02:07:56 <Kaidelong> I can think of one
02:08:08 <Kaidelong> you might want to debug a system while it is still running
02:08:14 <Kaidelong> IE a web server or a space probe
02:08:17 <Aruro> so we have one :)
02:08:19 <edwardk> Aruro: you don't get a heck of a lot of benefit to it, because you can't use that information, tons of data about lexical scope are just gone
02:08:23 <Kaidelong> hanging onto ASTs will help here
02:08:32 <mauke> Kaidelong: how?
02:08:44 <edwardk> and again optimization is just dead
02:08:52 <tdammers> Kaidelong: because equality on functions would most reasonably have to mean that they are equivalent, i.e., for all valid inputs they'd both produce exactly the same output
02:09:00 <Kaidelong> you can inspect the code running there, change it, and assign it to the same location other things were calling
02:09:09 <Aruro> optimization why is it important here?
02:09:26 <Aruro> assume ideal machine, just logics
02:09:28 <edwardk> Aruro: ghc does a ton of stuff to make the code you run run in reasonable time.
02:09:29 <mauke> Kaidelong: changing/assigning code is orthogonal to inspection
02:09:32 <nshepperd> purelazy: if your function is sufficiently polymorphic you can pass it a 'symbol' value, of a type whose operations just record what operation was applied
02:09:47 <nshepperd> eg. how lambdabot does
02:09:49 <tdammers> pointer equality isn't good enough
02:09:49 <edwardk> you can go give up 3 orders of magnitude if you want, then leak memory for all time to bring arbitrary functions
02:09:53 <nshepperd> > f (x + y)
02:09:54 <lambdabot>  No instance for (GHC.Show.Show a0)
02:09:54 <edwardk> but i think its a pretty crappy deal
02:09:54 <lambdabot>    arising from a use of ‘M20708666303131558144819.show_M20708666303131558144...
02:09:54 <lambdabot>  The type variable ‘a0’ is ambiguous
02:10:01 <edwardk> er to print arbitrary functions
02:10:06 <mauke> > f (x + y) :: Expr
02:10:07 <lambdabot>  f (x + y)
02:10:14 <edwardk> and along the way you lose all the benefits of parametricity in terms of being able to reason about your code
02:10:19 <nshepperd> er, right
02:10:24 <edwardk> i write haskell precisely _because_ of those benefits
02:11:07 <nshepperd> anyway, that's kind of limited, it only works if your function is polymorphic in the right way
02:11:33 <Kaidelong> mauke: then you run into the problem of having to work blind when you remote into the system and try to fix the problem
02:11:36 <edwardk> there are lots of homiconic languages where what you want is much closer to a viable thing, but name capture makes a right mess of it.
02:11:42 <Aruro> so you claim its easy to reason about lazily evaluated code?
02:11:49 <Kaidelong> the paradigm of everything can be inspected, everything is mutable and dynamic, has its place
02:12:09 <Kaidelong> just not in Haskell
02:12:41 <bitonic> well, I think more inspection as a debugging facility wouldn't be a bad thing
02:12:45 <edwardk> aruro: i personally manage to get by doing that just fine, yes. primarily by exploiting parametricity and the things that make it easy to rule out whole classes of errors in the code I do have to reason about
02:13:13 <purelazy> nshepperd: It's just if the data structure is mainly functions, there isn't the luxury of being able to see it - as one would for Ints, String, everything else.
02:13:32 <bitonic> but that kind of run-time inspection it's just not worth the disadvantages
02:13:36 <tangentstorm> that's just a design decision in haskell though. it doesn't have to be that way.
02:13:42 <nshepperd> debugging seems like an acceptable use case for code inspection
02:13:45 <edwardk> throwing all of that out is a big step. there are plenty of languages that get by with the big ball o mud model, and somehow make it work. e.g. Erlang is much better for it in many ways, it supports their loose notion of hot code swapping much better than any static type system really could.
02:13:46 <tangentstorm> in ghc i mean.
02:15:55 <Kaidelong> I kept wanting to mention Erlang, but couldn't bring myself to do it because I don't know enough about how it worked
02:15:59 <purelazy> I can accept that such a feature doesn't (some say cannot) exist
02:16:02 <edwardk> tangentstorm: the claim was that it'd be nice to be able to print every function. the issue is that this destroys canonicity of many constructions, destroys your ability to reason about the number of inhabitants of a type, gives up parametricity and free theorems for all intents and purposes, gives non-trivial semantics to easy things, and in exchange you
02:16:02 <edwardk> can some times try to make out what a function was by looking at the residue, so long as it isn't too complicated and only have to leak all your memory for all time to do it
02:16:07 <Kaidelong> some of the JPL's use of LISP was motivated by similar concerned
02:16:09 <nshepperd> presumably it would be available only when compiled in a debugging mode, so that parametricity and so on would still provide advantage in reasoning
02:16:19 <Aruro> this feature CAN exist
02:16:22 <Aruro> you did not get them
02:16:22 <Kaidelong> concerns*
02:16:42 <Aruro> they just say they can not deal with it properly
02:16:54 <edwardk> there is a usecase there, but you have to be pretty darn committed to it in order to make it your primary concern.
02:17:01 <Aruro> im not sure there is any mathematical reason for it being "wrong"
02:17:31 <Kaidelong> edwardk: you can't deny that the use case Ericsson came up with is compelling though?
02:18:02 <tangentstorm> hrm. i haven't thought all that through, to be honest. i use a language that offers the feature, but it doesn't have a strong static typing system like haskell.
02:18:10 <edwardk> aruro: um, sure there is. the lambda calculus doesn't halt. we can't always simplify the expression we show, and i can't tell you if i can
02:18:11 <Kaidelong> although I'd definitely agree that almost always you don't need dynamic systems like Erlang
02:18:28 <Kaidelong> and the disadvantages would outweigh the benefits
02:19:03 <Aruro> how the halt problem is different from infinite loop?
02:19:13 <Kaidelong> well Microsoft Research had been looking at optimizers that run at run time and adapt the program to work better as it collects information about how it is actually used
02:19:16 <Aruro> in a practical sense
02:19:32 <Kaidelong> I guess that's another potential application for the dynamic approach
02:19:40 <Aruro> ok so we have 2
02:19:49 <Aruro> which are basically 1 and half
02:20:14 <edwardk> Kaidelong: and they pretty much just don't do the thing you are asking for. you "can" serialize lambdas between nodes, it just 90% of the time doesn't work. almost all of the benefit of erlang comes from hot-code-swap on the other primitives, not functions, and the functions update by reference to the module, higher order code that works across channels
02:20:14 <edwardk> there is actually quite difficult to get right
02:20:48 <edwardk> remember
02:21:05 <edwardk> in erlang you have processes and ports, and they can accidentally get closed over in your nice little lambda
02:21:10 <edwardk> and they won't send
02:22:11 <edwardk> Kaidelong: nothing to that approach needs the ability to print an arbitrary function for a user
02:22:34 <Kaidelong> true, but that ability does follow from retaining all that information in runtime
02:22:52 <Kaidelong> how useful the printout would be, though...
02:23:06 <bitonic> Kaidelong: not really.  when you hot-swap a module in you're not inspecting the previous definitions
02:23:32 <fizbin> Huh. It turns out that not only *can* you define everything in Applicative and Monad from definitions for pure, fmap, and join, it actually isn't that ugly at all to do it that way.
02:23:35 <edwardk> not really, we can and to my knowledge universally do things like tracing jits without trying to retain anything approximating a textual presentation of the code
02:24:04 <Kaidelong> you could definitely print *something* describing the retained representation
02:24:11 <edwardk> fizbin: yep. mathematicians use that approach rather than the return/bind approach, because after all the monad is already a 'functor' so the fmap machinery is already defined.
02:24:43 <mauke> m >>= f = join (fmap f m) and you're done
02:24:49 <tangentstorm> i don't understand why being able to print a value destroys your ability to reason about it.
02:25:06 <bitonic> Kaidelong: what you do when you hot-swap a gen_server or something of that kind, which is the most useful use case, is provide a function to update the state for the new functions, and the new module code.  but you don't need to inspect the syntax of the previous functions
02:25:07 <edwardk> Kaidelong: this carries the assumption that all things can be showable. why can i show an IORef? its just an address in memory _that is constantly changing_
02:25:09 <fizbin> Right. I knew about join/return as an alternative to return/(>>=) ; I was just quite surprised at how nice (<*>) works out as well:
02:25:10 <Zol_> I have a recursive data type, data Music = Note Int | Music :+: Music | Music :=: Music, and I'm trying to combine a [Music] into Music, by combining sequential elements by :+:. So I have a helper function helper ( l :+: r) = helper l :+: helper r, helper m = m. How can I make (Note 1 :+: Note 2 :+: Note 3) :+: Note 4 become (Note 1 :+: (Note 2 :+: (Note 3 :+: Note 4))) ? Do I need to apply strict evaluation
02:25:12 <Zol_> or use DeepSeq or something?
02:25:28 <fizbin> I now have it as:  b <*> c = join' $ (<$> c) <$> b
02:25:29 <edwardk> Kaidelong: not because it is a reference, but because its heap allocated and we keep moving the heap around
02:25:59 <Kaidelong> edwardk: so you are saying that show would not be a pure function on IORefs?
02:26:28 <edwardk> i'm saying that you have to change the fundamental contract of an IORef to incorporate some extra piece of distinguishing information per reference to make it sensible
02:26:29 <mauke> Zol_: I don't see what this has to do with strictness
02:26:36 <nshepperd> tangentstorm: more like being able to print values destroys your ability to reason about things that take operate on values
02:26:50 <Kaidelong> that extra piece of information would be a UUID, I guess
02:26:57 <Kaidelong> OOP languages do something like this
02:27:13 <edwardk> sure, now you've blown out the memory and time footprint of your program a great deal
02:27:17 <Zol_> mauke: I feel lost, I am not sure how I can approach this problem, I'm flailing in the air and my next attempts were to look at strict evaluation etc.
02:27:30 <mauke> Zol_: what difference does evaluation make?
02:27:39 <edwardk> java does it because, well, they seem to believe that everything in math conveniently comes with a hashcode ;)
02:27:57 <Kaidelong> having a convenient hash code does let you do a lot of nifty things
02:28:02 <Kaidelong> like put everything from math in a hashtable
02:28:08 <Zol_> mauke: Doesn't that depend on other functions?
02:28:16 <mauke> ???
02:28:22 <edwardk> sure it does. it also requires you to occasionally do impossible things to subscribe to a contract that doesn't belong in 'object'
02:28:32 <edwardk> it gives you thoughts you can't think
02:28:34 <edwardk> it isn't free.
02:28:58 <Kaidelong> Yes, I understand that. I don't think you can clearly say the one way of thinking is better than the other
02:29:00 <Kaidelong> it is a tradeoff
02:29:43 <tdammers> the tradeoff is to allow the impossible to make the possible a bit more convenient
02:29:51 <tdammers> s/convenient/"convenient"/
02:29:52 <nshepperd> you know a lot less about a function `foo :: (Show) a => a -> Foo` than `bar :: a -> Foo`
02:30:00 <Zol_> mauke: So, I'm studying for my exam, and one of the problems is to create a function which returns the same result as another, and the difference between my version and the original is the evaluation, or the placement of parentheses, which makes me wonder whether they can be considered equal or not.
02:30:05 <Myrl> Hmmm...
02:30:16 <edwardk> i find that java has a ton of escape valves that it has to give you to compensate for a fairly mediocre type system. they use reflection everywhere because it is the escape valve they have, they use toString and hashCode on all their objects because they don't have a typeclass equivalent to dispatch that machinery in a more sane way and enable the power of
02:30:17 <edwardk> saying it isn't present for a thing.
02:30:31 <mauke> Zol_: your function does nothing
02:30:38 <nshepperd> adding universal printability, in principle destroys your ability to define and use the latter
02:31:00 <mauke> Zol_: evaluation is not placement of parentheses
02:31:07 <tdammers> just like you can express "perform numeric addition on a hamburger and a suspension bridge" in a dynamic language, even though it makes absolutely no sense
02:31:13 <edwardk> its a great lowest common denominator, but you could just as soon swap out the use of polymorphic variables in haskell with ones that carried around (Typeable a, Showable a, Hashable a)  constraints for everything you ever programmed with
02:31:33 <edwardk> along the way you'd give up a ton of power to gain a thing you can already gain back locally whenever you wanted it.
02:32:00 <edwardk> so i don't think it is a clear 'trade-off'. unless the trade off here is between having to type the constraint and having it always foisted upon you
02:32:00 <nshepperd>  ikoooooooooooooo
02:32:15 * nshepperd meow
02:32:19 <Myrl> Hmmm...
02:32:24 <Myrl> This is making me lost. :<
02:32:26 <edwardk> in something like erlang where you get more powers for that tax, like the hot code swapping machinery, its more clearly a trade-off.
02:32:30 <edwardk> but here its just a loss.
02:32:36 <Kaidelong> edwardk: Haskell's inability to put things like functions in a set is a pretty big loss IMO
02:32:55 <Zol_> mauke: http://lpaste.net/116680
02:33:19 <edwardk> you want to put functions in a set? compute a StableName for the function, put it in with its own stable name as a key.
02:33:22 <edwardk> done
02:33:37 <edwardk> now you have all the power of java at your finger tips
02:33:45 <Kaidelong> how would you compute the StableName?
02:33:51 <edwardk> makeStableName
02:33:56 <srhb> Myrl: What is? (And what's with the useless "Hmms" in public :P)
02:34:01 <edwardk> use unsafePerformIO if you must, or live in IO everywhere
02:34:04 <tdammers> actually, putting things in a set for which equality is an ill-defined or impossible concept doesn't make a lot of sense IMO
02:34:06 <Kaidelong> I mean short of doing things dependent on GHC
02:34:22 <Zol_> mauke: I would like line2 m1 == line2 m2 == line m2.
02:34:26 <Kaidelong> I guess unsafePerformIO is now technically standard Haskell
02:34:39 <tdammers> so demanding that you explicitly state what "equality" is supposed to mean in this context is a *good* thing
02:34:40 <mauke> Zol_: why?
02:34:42 <Welkin> are we role-playing medieval peasants?
02:34:55 <edwardk> um, stableNames are pretty darn portable at this point. they've been around since 1999.
02:34:57 <Welkin> Kaidelong is the stable boy
02:34:57 <Myrl> srhb: It's pretty much to notify that I have to say something and that everyone should run away because I ask pointless questions. :P
02:35:07 <Welkin> who owns the horses?
02:35:13 <edwardk> and besides you should be doing everything in IO everywhere, right? =)
02:35:14 <srhb> Myrl: It's just filler, and the channel is pretty full as is. What's your problem? :)
02:35:22 <edwardk> because its more flexible that way
02:35:26 * edwardk stops trolling
02:35:27 <Myrl> srhb: Well, it's not really related that much to Haskell.
02:35:32 <Kaidelong> edwardk: this is actually an approach that a lot of languages have used for a long time
02:35:34 <srhb> Okay.
02:35:36 <Kaidelong> it turns out to work pretty well
02:35:41 <Zol_> mauke: Because it's part of the problem I'm trying to solve. https://raw.githubusercontent.com/Zolomon/xmr/master/public/images/courses/edan40/exams/20061016/4.png, "b)", and my solution so far is line2.
02:35:51 <Kaidelong> there are some tradeoffs, though
02:36:11 <Zol_> mauke: But you can see the difference in results, and I'm not sure whether it would count as the same or not. :/
02:36:12 <edwardk> it works great right up until you want laziness you can reason about, or don't want to spend years chasing after how to get STM into your compiler before giving up
02:36:15 <mauke> Zol_: heh, "och"
02:36:41 <Myrl> srhb: But I'll ask something related instead. On xmonad config, it says '  xmonad defaultConfig {' does that mean that defaultConfig is a value constructor which will be passed to xmonad?
02:36:54 <Zol_> mauke: My lecturer is a Pole living in Sweden, I think he has too many languages running around at the same time. :)
02:36:54 <srhb> Myrl: No, it's just a value.
02:37:04 <srhb> Myrl: You can modify the individual records with the { } syntax
02:37:19 <Kaidelong> on the other hand your type inference algorithm doesn't give up when you try to implement an in-place shuffle algorithm
02:37:26 <Myrl> Oh yes, now I remember that it's called records. Thanks.
02:38:19 <edwardk> Just write the in-place shuffle in IO or ST s, aka "" as they say in other languages. ;)
02:38:25 <Zol_> mauke: So logically, I would say that my definition is kind of the same - it's a tree structure except that mine will become left balanced while the original version will become right balanced.
02:38:31 <mauke> Zol_: I don't understand what line2 is supposed to do. it's underspecified
02:38:33 <Kaidelong> edwardk: that's what I'm talking about
02:38:41 <Kaidelong> implementing this, in Haskell, with ST, is a bit of a pain
02:38:42 <Kaidelong> http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
02:38:51 <Kaidelong> IO makes it a lot easier, admittedly
02:39:05 <Zol_> mauke: It should produce the same result as line = foldr (:+:) (Rest 0) :: [Music] -> Music.
02:39:10 <mauke> Zol_: your function seems to be identical to line
02:39:17 <Kaidelong> I mean it's not impossibly hard
02:39:24 <Kaidelong> I've had to do it myself
02:39:24 <mauke> Zol_: and no, it shouldn't
02:39:51 <Kaidelong> but it definitely could hang begginers up and Haskell's type inference cannot handle the ST version
02:40:05 <mauke> Zol_: in fact, line m1 can't be the same as line2 m1
02:40:38 <Kaidelong> runST is rank-2
02:40:47 <mauke> Zol_: line2 _ = line m2  -- technically solves the exercise
02:41:05 <srhb> Zol_, mauke: Seems to me it should fold the values which are not already folded with :+:
02:41:09 <srhb> onto the one that is
02:41:49 <srhb> But yeah, it's not specified.
02:42:16 <Zol_> Ok, thanks, I guess it's intentionally underspecified to give multiple solutions a shot then.
02:42:20 <srhb> So for m1 it's basically foldr1 (:+:) (head m1) (tail m1)
02:42:32 <srhb> (I think.)
02:43:04 <srhb> But obviously, "dur" isn't a thing either, so it's all quite broken.
02:43:06 <mauke> I'm going with line2 _ = line m2 because that's the least effort
02:43:07 <srhb> Fire the teacher. :)
02:43:17 <edwardk> @lpaste
02:43:17 <lambdabot> Haskell pastebin: http://lpaste.net/
02:43:28 <Zol_> srhb: He could be in this channel for all I know. :D
02:43:43 <lpaste> edwardk pasted “fisher-yates” at http://lpaste.net/116681
02:43:55 <edwardk> ^- that doesn't appear all that different than the classic algorithm
02:43:59 <srhb> Well, then he'll probably be shamed into writing better questions. :-)
02:44:12 <mauke> lineToList2 _ = lineToList (line m2)  -- there, I've just done all of it
02:44:21 <mauke> 5.c), that is
02:44:24 <srhb> I mean, line m2 isn't even valid until you define dur = Dur
02:44:54 * srhb is off again
02:44:54 <edwardk> except it has the benefit that you can reseed and reproduce a shuffle if you want
02:45:08 <Zol_> mauke, srhb: Thanks for the help! I will jump on to the next set of problems. Much appreciated.
02:45:40 <bitonic> edwardk: what's `G.swap'?
02:45:53 <edwardk> import Data.Vector.Generic as G
02:46:04 <searock> :q
02:46:04 <bitonic> right
02:46:19 <searock> obs sorry
02:46:28 <Kaidelong> oh what is this "fill"?
02:46:35 <Kaidelong> I admit to not having seen that before
02:46:39 <Kaidelong> oh
02:46:42 <Kaidelong> I see
02:46:43 <edwardk> Kaidelong: its defined 2 lines down =)
02:47:04 <Kaidelong> I bet this is brilliant, I'll see how long it takes me to understand what you were doing
02:47:14 <Kaidelong> (admittedly, I was kind of hoping you would respond like this)
02:47:27 <Kaidelong> what is the type of randomIs, by the way?
02:48:09 <edwardk> Kaidelong: i confess i grabbed it out of a folder worth of snippets folks had sent me / asked about before
02:48:15 <edwardk> its probably broken =P
02:49:35 <Kaidelong> alright
02:49:43 <Kaidelong> the version I wrote was like ~40 lines long or so
02:49:47 <Kaidelong> =(
02:50:46 <Kaidelong> to be fair I don't know if this does what I was actually doing at that point (unboxed vectors where the shuffle had to play nice with Data.Random)
02:51:08 <edwardk> https://www.haskell.org/pipermail/haskell-cafe/2011-April/091308.html looks similar
02:52:28 <edwardk> http://www.reddit.com/r/programming/comments/cw6ct/why_haskell_isnt_popular_in_the_industry_9_reasons/c0vqw2m might give a nicer way to think about the problem
02:53:09 <edwardk> there dons gives the shuffle operator in terms of randomIs
02:53:12 <Kaidelong> I guess making it work with RVar imposes the additional problem that there is no such thing as an STT
02:53:18 <Kaidelong> (you can make one, but it is unsafe)
02:53:58 <edwardk> STT can, of course, be defined, but you need a custom heap for it or something like apfelmus' trick for building the Vault.
02:55:11 * hackagebot resourcet 1.1.3.3 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.3.3 (MichaelSnoyman)
02:55:51 <Kaidelong> there was an STT package somewhere on hackage, but because RVars are by design, a source of nondeterminism
02:56:07 <Kaidelong> I think that it'd fall afoul of the restriction that the inner monad must be deterministic
02:56:34 <Kaidelong> STT [] was their example of something not to do
02:57:28 <edwardk> you can build a real transformer that works with non-determinism, it just needs to manage its own vault/heap of current assignments and leaks memory like a sieve
02:58:43 <Aruro> edwardk, how did situation with haskell embedding changed since 2010?
02:59:23 <Aruro> i refer to 9 reasons post
02:59:29 <Aruro> you mentioned above
02:59:29 <edwardk> Aruro: in terms of in other applications? hint has gotten better, simon marlow spent some time on haskell re-linking, but i don't know the details.
03:00:00 <Aruro> yes
03:00:00 <Welkin> https://en.wikipedia.org/wiki/Hope_%28programming_language%29
03:00:03 <Welkin> wow
03:00:23 <Welkin> it makes me want to try out Hope
03:00:30 <Kaidelong> Hope and Joy are both cool
03:00:38 <Kaidelong> I haven't used them much
03:00:46 <Kaidelong> but yeah, try them
03:00:50 <edwardk> aruro: let me re-read it.
03:02:27 <Aruro> you answered already the last reason mentioned by blog author himself
03:02:38 <Aruro> about embedding haskell in c++ code
03:02:54 <Aruro> why do you want to try Hope?
03:03:08 <Aruro> the factorial definition from wiki is exactly same
03:03:14 <Aruro> as in haskell i see no point
03:03:34 <Welkin> Aruro: for fun
03:03:35 <Aruro> "named after agricultural reformer" - seriously?? :)
03:03:40 <Welkin> it is a predecessor to haskell
03:04:19 <edwardk> Aruro: #1 nobody has heard of it is changing fast. #2 is circular reasoning, #3 is true, #4 is something i'm actively campaigning against, #5 is slowly slipping away, more folks are in the vanguard on this stuff now, so its easier to say we're just following the herd, #6 seems precisely backwards, i can both hire enough awesome haskell programmers that i can
03:04:19 <edwardk> build whatever i want and simultaneously there are enough jobs for those committed to the language to find something, tackling #7 is pretty much how i spend all my time, #8 is a thing that reading okasaki's book teaches you how to fix. its unpredictable in that its sometimes way better, and often just as bad as you'd have to do elsewhere, #9 isn't how i sell
03:04:19 <edwardk> haskell. i talk to folks about speed benefits.
03:05:03 <edwardk> e.g. jfischoff is over at IMVU, they don't give a lick about correctness but they do care about speed, and replacing a web service with another one that supports 500x as many users on the same hardware and which is easier to understand and maintain? win.
03:05:11 * hackagebot stm 2.4.4 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.4.4 (HerbertValerioRiedel)
03:05:42 <Kaidelong> edwardk: what about these reasons: http://www.quora.com/Why-are-people-so-down-on-Haskell/answer/Barend-Venter?srid=zE1P&share=1
03:05:46 <edwardk> we do kinda suck at the 'put a little bit of haskell in anotherwise c++ application' space
03:05:59 <tnks> where are these enumerated things?
03:06:11 <purelazy> > (if False then head else head) [1,2]
03:06:12 <lambdabot>  1
03:06:24 <purelazy> > (if False then head else head tail) [1,2]
03:06:25 <lambdabot>  Couldn't match expected type ‘[[a] -> a]’
03:06:25 <lambdabot>              with actual type ‘[a0] -> [a0]’
03:06:26 <Aruro> http://www.reddit.com/r/programming/comments/cw6ct/why_haskell_isnt_popular_in_the_industry_9_reasons/c0vqw2m
03:06:35 <Aruro> tnks, read it
03:06:37 <purelazy> why is that?
03:06:47 <Aruro> he was answer that
03:06:50 <purelazy> i.e. the second one wrong
03:06:52 <Aruro> answering*
03:07:03 <Aruro> its difficult is  so stupid argument :)
03:07:14 <Aruro> like no we want  language which monkey can use
03:07:29 <Aruro> completely unscientific arguing
03:07:33 <edwardk> Kaidelong: documentation is bad. yep. working on it. batteries not included: no gui, yep. working on that too. =) no good ide. with ghc-mod and the like that is a bit less pressing. we've had folks build a bunch of things like visual studio plugins, but nobody cares to get involved and maintain these things. we also have the fpcomplete gui online for editing
03:07:34 <edwardk> haskell, and its actually not bad.
03:08:00 <Aruro> there is gui? gtk?
03:08:13 <edwardk> windows support is, if anything, even worse than since the post was written.
03:08:20 <barrucadu> purelazy: Because "head" takes a list, and you're giving it a function
03:08:32 <barrucadu> > (if False then head else head . tail) [1,2]
03:08:33 <edwardk> Aruro: hsqml is pretty easily installable and is more or less where i'm hanging my hopes right now.
03:08:33 <lambdabot>  2
03:08:42 <barrucadu> "." is the function composition operator
03:09:05 <edwardk> aruro: we have gtkhs and wxhaskell bindings, and used to have some qthaskell bindings, but the latter is defunct
03:09:27 <edwardk> i was able to fix up the wxmac brew installer for osx 64-bit so wxhaskell can be installed out of the box by a lot of folks now
03:09:55 <edwardk> so that may be a viable option if you don't have some bleeding edge concerns like me, its useless to me for another 12 months until we get a new release that supports modern opengl profiles.
03:10:00 <Aruro> cool
03:10:04 <tnks> on that note, I'm not sure it's desktop apps that's holding people back.
03:10:14 <Aruro> im sitting on vista and some packages just refuse to compile :)
03:10:25 <tnks> I think it's some kind of "killer app" on the distributed systems side.
03:10:28 <purelazy> barrucadu Thanks
03:10:35 <purelazy> > (if False then head else head . tail) [1,2]
03:10:37 <lambdabot>  2
03:10:39 <edwardk> but for the most part a lot of folks have moved to the web for their UI story, e.g. threepenny-gui and the like
03:10:41 <purelazy> :)
03:10:52 <Aruro> yes i wanted to mentioned web
03:11:24 <edwardk> i only now care about UI stuff in haskell because now i want to put together a nice little user interface on an opengl scene editor for signed distance fields
03:11:30 <edwardk> and that means i have to do it desktop side
03:11:41 <edwardk> because webgl isn't up to the task of displaying this stuff
03:13:53 <edwardk> anyways i think things like the fpcomplete platform at least offer some of a sop to the XY problem of the quora link above. they do have a curated set of compatible packages, they do have easy deployment for web applications and the like, they do have an IDE story, etc.
03:14:16 <edwardk> but the big question is 'are the things he's asking for there actually the things that would drive adoption?'
03:14:19 <edwardk> and that i don't know
03:14:49 <edwardk> i can't say i've seen people beating down the doors of fpcomplete to use their gui
03:15:05 <Kaidelong> I spent some time with fpcomplete
03:15:18 <Kaidelong> then concluded that it was barely any better than what I was already doing in vim
03:15:21 <Kaidelong> and stopped caring
03:15:29 <Aruro> i heard they are not doing that well
03:15:36 <Aruro> maybe wrong
03:15:39 <Kaidelong> on the other hand I'd never want to write C# without Visual Studio
03:15:51 <chpatrick> edwardk: is there an "ekmett name" for holey monoids? :) https://hackage.haskell.org/package/HoleyMonoid-0.1/docs/Data-HoleyMonoid.html
03:16:00 <edwardk> aruro: afaict they are doing fine since they switched to focusing on finance.
03:16:17 <Kaidelong> given that Haskell is very similar to things like C# and Java in that it's focused on programming on the large it might benefit from some of the same IDE tools though
03:16:21 <Aruro> ah that is a fine choice :)
03:16:26 <edwardk> chpatrick: we had them in a dev branch of lens as Formats
03:16:32 <edwardk> chpatrick: they eventually were pulled though
03:16:38 <edwardk> they caused conflicts with a more useful feature
03:16:40 <zipper> uuuiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii my head will crack. Too much haskell.
03:16:48 <chpatrick> cheers :)
03:16:48 <Aruro> i guest in finances it is easier to argue about importance of error free and stuff like that
03:17:08 <edwardk> Aruro: also you have people with big fat wallets who want nice support contracts
03:17:21 <Aruro> yeah :)
03:17:25 <zipper> edwardk: Hey human.
03:17:29 <Aruro> they also tend to like math and stuff
03:17:51 <edwardk> rather than trying to sell editors to a rather spoiled open source community that is broke, expects everything to work perfectly, and wants everything for free ;)
03:18:05 <Aruro> heh :D
03:18:16 <Aruro> no i see no problem with that
03:18:28 <Aruro> if they can sell im only happy for them
03:19:31 <Aruro> oh forgot to ask you, which okasaki book you mentioned?
03:19:53 <Aruro> something about predicting performance
03:20:04 <Aruro> edwardk
03:20:07 <osa1> is there a way to set Cabal-project level defaults? (e.g. default int but should apply all the project)
03:20:09 <edwardk> http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
03:20:10 <Welkin> https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
03:20:21 <edwardk> Purely Functional Data Structures -- the book form is the one i'd recommend over the thesis
03:20:29 <Welkin> oh
03:20:31 <edwardk> but the thesis is a way to get your feet wet if you can't afford the book
03:20:34 <Welkin> I started reading the paper
03:20:41 <Welkin> is the book much better?
03:20:53 <Aruro> o man 96 :) was long time ago
03:21:12 <Kaidelong> yeah developing a new IDE as a commercial project is going to be incredibly challenging, no doubt about that
03:21:31 <Kaidelong> people are not going to pay for it is it's not already better than emacs
03:21:36 <Kaidelong> and that will take time
03:21:51 <Kaidelong> and you are not going to be making much money in that time
03:22:00 <edwardk> anyways he pretty much stated the space of the problems around purely functional data structures and how it affects your ability to do analysis, because immutability means the old data structures are still there, so you can't earn credit for doing things cheaply... and then in the same breath (ok, book) he wrote down almost everything there was to say about
03:22:01 <edwardk> how to solve the problem
03:22:36 <edwardk> Aruro: i've been able to trot things out of that book repeatedly and improve known asymptotics on some fairly important algorithms.
03:23:15 <edwardk> so 17 years old or not, i wish i'd read it earlier, and i don't begrudge any of the time i've spent reading and re-reading it
03:23:23 <edwardk> i may even eventually return shapr's copy to him
03:23:24 <Welkin> Kaidelong: hipsters love GitHub's Atom editor
03:23:29 <edwardk> and buy another
03:23:29 <Aruro> ok interesting will take a look at it
03:23:30 <Welkin> for some reason
03:24:13 <Welkin> people also seem to like sublimetext, but I don't see how it;s any different/better than emacs
03:24:32 <Kaidelong> those both sound like text editors rather than full VS or Eclipse style IDEs
03:24:36 <Welkin> except it costs about $100
03:24:40 <edwardk> anyways, he basically shows you how to use laziness to set up a computation/thunk like a layaway account and pay it off through debits, if two uses pay off the same thunk then things are just faster than expected, but it doesn't screw up your amortization scheme
03:25:36 <edwardk> http://cstheory.stackexchange.com/a/1550 summarizes the stuff that is new since Okasaki's book pretty thoroughly
03:26:35 * Welkin adds to growing list of haskell bookmarks
03:28:27 <edwardk> Welkin: heh accept the fact that the set will grow without bound ;)
03:32:03 <Aruro> actually is multitasking on one core affects purity?
03:32:22 <Aruro> is it possible to have pure one core multitasking os?
03:32:53 <Aruro> which does not have IO and only does some calculations :)
03:33:42 <flux> it's not possible for the program to proceed, because each step would modify the program counter register ;-)
03:34:03 <flux> (though it's not quite the point)
03:35:12 * hackagebot cndict 0.4.4 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.4.4 (DavidHimmelstrup)
03:36:36 <Aruro> hm
03:37:17 <geekosaur> I'm not so sure I'd go there since it's perfectly valid to make use of mutability "under the hood" as long as it's not observable within Haskell (and indeed the Haskell runtime does so)
03:38:09 <geekosaur> also, you can fudge the definition of "purity": if the system you're considering is an isolated computer in its entirety then the only "impure" data source is the user >.>
03:39:35 <Aruro> yes,
03:40:01 <Aruro> but i was thinking if multitasking itself can be the source of impurity
03:40:12 * hackagebot deepseq 1.4.0.0 - Deep evaluation of data structures  http://hackage.haskell.org/package/deepseq-1.4.0.0 (HerbertValerioRiedel)
03:40:14 <geekosaur> (Haskell's purity is at a process level, so does not include things like other processes or data on disk, etc. which is why some things are in IO that might be thought of as "pure" at another level, such as environment which is injected by process creation and thereafter can "only" be changed by the program itself [note that FFI does complicate this])
03:41:14 <geekosaur> actually at a program level, which excludes things like FFI to external functions that may change state visible to the Haskell program
03:42:16 <geekosaur> multitasking is impure in Haskell's model, but a model which enforces purity at a higher level could encompass it
03:43:03 <geekosaur> the main problem with this is that most people can't reason well at that level
03:43:33 <Aruro> which level you mean now?
03:43:33 <Kaidelong> well haskell does provide some great pure paralellism
03:43:46 <Aruro> yes for that i mentioned one core
03:44:40 <Kaidelong> I'm not sure pure *distributed* code is really possible even in theory because you have the real problem of physical networks losing and reordering information
03:45:02 <Kaidelong> although I guess you could say TCP is good enough to consider stuff pure if you trust the other machines
03:45:31 <Aruro> we were assuming just one machine multitasking
03:45:47 <Kaidelong> ah
03:45:57 <Kaidelong> I guess that's as good a cue as any to get some sleep
03:45:59 <Kaidelong> goodnight
03:46:04 <Phillemann> I'm a bit confused about stackage's new configuration model. What am I supposed to write as remote-repo in ~/.cabal/config?
03:46:20 <Aruro> goodnight
03:46:26 <hvr> Phillemann: just hackage
03:46:46 <geekosaur> so if we assume just one machine multitasking, if you set the focus at the level of that machine then things like disk I/O become "pure"
03:47:14 <geekosaur> your disks are just fancy state monads, in effect
03:48:43 <geekosaur> however, arranging for this to actually make sense is (a) difficult for most people to encompass (b) not especially useful, since when it comes right down to it we use computers to solve problems on demand and the question *itself* isn't pure >.>
03:50:14 <Aruro> interesting
03:50:36 <geekosaur> there is in principle no particular reason that OS scheduling couldn't be a pure function of Haskell-style state and time, aside from that a program that does no I/O isn't doing anything that people find useful
03:50:45 <Zol_> :help
03:51:00 <geekosaur> (unless you consider warming the room to be useful...)
03:51:27 <Aruro> well i can setup this computer to calculate large numbers
03:52:01 <Aruro> or you consider initial process of entering programm as being impure?
03:52:26 <geekosaur> I consider seeing the result of the program to be impure, more to the point
03:52:35 <Aruro> mm how?
03:52:43 <Aruro> it just outputs something
03:52:46 <Aruro> no input is needed
03:52:53 <geekosaur> "outputs" is by definition impure
03:52:53 <Aruro> but there is inside some multitasking going on
03:53:06 <Aruro> hm
03:53:40 <Aruro> why output is considered impure ? it looks predictable no?
03:54:03 <Zol_> Ok, I am stumped on this one, how would you write g x y = [y z | z <- [1..x]] in point-free style without using lambda-expressions or enumerations?
03:54:04 <geekosaur> if something is observable from outside the program *or* injectable from outside the program, it is not pure. pure is a black box
03:54:51 <Aruro> ok so you wanna say that if i can see state of the memory that makes my system impure?
03:55:01 <zipper> geekosaur: Well a blackbox whose internal workings you should know if need be. Basically encapsulation on steroids.
03:55:12 * hackagebot cndict 0.4.5 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.4.5 (DavidHimmelstrup)
03:55:14 * hackagebot monad-control 1.0.0.1 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-1.0.0.1 (BasVanDijk)
03:55:22 <geekosaur> zipper, yes, exactly
03:55:24 <timrich> Hi, I am a beginner with a question about implicit typing. if after 'import Prelude hiding ((||))' I put this in a script 'False || b = b' why is b typed to be Bool?
03:55:37 <Zol_> :pl [y z | z <- [1..x]]
03:55:49 <geekosaur> actually more of a reverse black box, you can see what's in it but not what's *outside* of it
03:55:59 <zipper> Aruro: Output is impure if it's not what the function returns. as in if it's not the result.
03:56:22 <zipper> The funtion is impure not the output
03:56:47 <zipper> samrat: OMFG I know a supermarket by that name.
03:58:10 <ric> pl \x y -> x y
03:58:26 <geekosaur> I don't think @pl handles list comprehensions
03:58:47 <Zol_> @pl [y z | z <- [1..x]]
03:58:47 <lambdabot> [y z | z <- [1..x]]
03:59:01 <geekosaur> you haven't told it which points to remove, in any case
03:59:08 <Zol_> How would I do that?
03:59:27 <ric> @pl \x y -> x y
03:59:27 <lambdabot> id
03:59:28 <barrucadu> timrich: It's not, this is what I get from ghci: http://lpaste.net/8093889856704348160
03:59:30 <geekosaur> you need to use a lambda or a function definition to do that (this does not mean you need to write one to use the result; just to identify the points to remove)
03:59:39 <chpatrick> @pl \x y -> map y $ takeWhile (/=x) (iterate succ 1)
03:59:40 <lambdabot> flip map . flip takeWhile (iterate succ 1) . (/=)
03:59:48 <ric> @unpl id
03:59:48 <lambdabot> (\ a -> a)
04:00:03 <geekosaur> because there's no syntactic way to identify that "x" is a point to be removed and "takeWhile" is not, in the above example
04:00:03 <Zol_> @pl \x y -> [y z | z <- [1..x]]
04:00:03 <lambdabot> flip flip [] . ((:) .) . flip ((<-) . (| z) . ($ z)) . enumFromTo 1
04:00:12 * hackagebot hakyll 4.6.2.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.2.0 (JasperVanDerJeugt)
04:00:33 <ric> @pl \p l -> or (map p l)
04:00:33 <lambdabot> any
04:00:36 <geekosaur> oh, it does handle list comps these dats
04:00:45 <chpatrick> flip ((<-) . (| z) . ($ z))
04:00:46 <ric> @unpl any
04:00:46 <chpatrick> wat
04:00:46 <lambdabot> any
04:00:49 <geekosaur> but it's still enumerating, just not using the syntactic sugar
04:01:19 <Zol_> geekosaur: Yeah, any idea how to avoid that?
04:01:21 <geekosaur> ...no, it did not handle that at all correctly, I see
04:01:50 <geekosaur> Zol_, I think you missed my point completely
04:02:01 <ric> @pl \r -> 3*r*r
04:02:01 <lambdabot> (*) =<< (3 *)
04:02:02 <geekosaur> the @pl command requires to be told what points to be removed, using lambda syntax
04:02:13 <geekosaur> you are not writing the @pl command in your code
04:02:32 <ric> @pl \x y -> (x-y)*(x+y)
04:02:32 <lambdabot> ap (ap . ((*) .) . (-)) (+)
04:02:41 <chpatrick> @pl \x y -> map y [1..x]
04:02:42 <lambdabot> flip map . enumFromTo 1
04:02:47 <geekosaur> and by definition, since @pl has removed the points, the lambda syntax you used to tell @pl what to do is *not in* the result
04:02:53 <chpatrick> I don't think it's going to get any better than that
04:04:03 <chpatrick> points-free with multiple arguments is usually pretty nasty though
04:04:07 <geekosaur> or were you referring to the enumFrom, which is what the [1..] turns into? there's no real way around that unless you want it to generate a specialized definition of the Enum typeclass at the same time... doable but ugly
04:04:26 <Zol_> geekosaur: Yeah, that was what I was referring to.
04:05:12 * hackagebot distributed-process-extras 0.1.0 - Cloud Haskell Extras  http://hackage.haskell.org/package/distributed-process-extras-0.1.0 (TimWatson)
04:05:14 <geekosaur> this sounds like homework then, since there's no point in actually doing that aside from making you think about how enumerations work
04:05:47 <geekosaur> and asking IRC to think about how they work and regurgitate an answer is missing the point...
04:06:50 <Zol_> geekosaur: It is kind of, I'm studying for my exam. I've looked around in LYAH, read about syntactic sugar for lists and I got stuck on that problem.
04:07:27 <Zol_> geekosaur: I appreciate the help, and I feel it is encouraging and not useless.
04:08:19 <geekosaur> I would be surprised if LYAH really intended anything other than replacing the syntactic sugar with the underlying Enum functions
04:12:36 <timrich> barrucadu: thanks for the pastebin. My script included a second pattern match 'True || _ = True' and this must have triggered the inferred type to be Bool -> Bool -> Bool
04:15:12 * hackagebot uhc-light 1.1.8.1 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.8.1 (AtzeDijkstra)
04:18:38 <torpet> Hi, I have 2 List of tuples [(a,b)] and [(a,c)]
04:18:47 <torpet> How can i produce something like [(a,b,c)]
04:19:34 <Peaker> an intersection?
04:19:41 <torpet> yeah
04:19:59 <chpatrick> torpet: do an inner join with a Map?
04:20:12 * hackagebot distributed-process-async 0.1.0 - Cloud Haskell Async API  http://hackage.haskell.org/package/distributed-process-async-0.1.0 (TimWatson)
04:20:34 <Aruro> it is not intersection
04:20:38 <Aruro> it is union
04:20:45 <Peaker> Map.intersectionWith (,)
04:20:49 <Iceland_jack> > M.unionWith (++) (M.fromList [(a, [b])]) (M.fromList [(a, [c])])
04:20:50 <lambdabot>  fromList [(a,[b,c])]
04:20:52 <Peaker> Aruro: no, because b,c both exist
04:21:06 <Iceland_jack> > M.intersectionWith (++) (M.fromList [(a, [b])]) (M.fromList [(a, [c])])
04:21:07 <lambdabot>  fromList [(a,[b,c])]
04:21:38 <Peaker> > M.intersectionWith (,) (M.fromList [(a, b)]) (M.fromList [(a, c)])
04:21:39 <lambdabot>  fromList [(a,(b,c))]
04:21:46 <Peaker> ^^ this is what he wanted
04:22:01 <Peaker> up to product lifting
04:22:08 <Iceland_jack> It's what they asked for yes
04:22:11 <chpatrick> @t map (\(a, ( b, c )) -> ( a, b, c ) $ M.assocs $ M.intersectionWith (,) (M.fromList xs) (M.fromList ys)
04:22:11 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
04:22:28 <chpatrick> oops
04:23:08 <indiagreen> chpatrick: “:t” or “@type”
04:23:21 <chpatrick> :t map (\(a, ( b, c )) -> ( a, b, c )) $ M.assocs $ M.intersectionWith (,) (M.fromList xs) (M.fromList ys)
04:23:21 <lambdabot>     Not in scope: ‘xs’
04:23:22 <lambdabot>     Perhaps you meant one of these:
04:23:22 <lambdabot>       ‘x’ (imported from Debug.SimpleReflect),
04:23:31 <chpatrick> :t \xs ys -> map (\(a, ( b, c )) -> ( a, b, c )) $ M.assocs $ M.intersectionWith (,) (M.fromList xs) (M.fromList ys)
04:23:32 <lambdabot> Ord t => [(t, t1)] -> [(t, t2)] -> [(t, t1, t2)]
04:23:38 <Zol_> geekosaur: flip map $ flip take (iterate (+1) 1) :D
04:24:29 <Zol_> Oh, yeah, should be (iterate (+1) 0) to be correct.
04:25:12 * hackagebot deepseq-generics 0.1.1.2 - GHC.Generics-based Control.DeepSeq.rnf implementation  http://hackage.haskell.org/package/deepseq-generics-0.1.1.2 (HerbertValerioRiedel)
04:47:45 <torpet> i have written a sort function
04:47:45 <torpet> http://lpaste.net/1233303668682391552
04:47:53 <torpet> If I make a to Ord a it works
04:48:10 <torpet> Even though as Ord, I don't want the function to treat it as such because I don't need it
04:48:35 <mauke> so don't
04:49:00 <wei2912> torpet: yes you do need it
04:49:00 <mauke> sortVPB :: (Ord b, Ord c) => (a, b, c) -> (a, b, c) -> Ordering
04:49:17 <wei2912> torpet: you're wait, you were talking about a
04:49:19 <wei2912> well, don't specify it
04:49:20 <mauke> sortVPB (a1, b1, c1) (a2, b2, c2) = compare b1 b2 <> compare c1 c2
04:49:25 <wei2912> s/you're//
04:49:53 <mauke> or even compare (b1, c1) (b2, c2)
04:50:04 <torpet> but i want to sort  (a,b,c) tuples
04:50:06 <torpet> *triples
04:50:16 <mauke> WHAT DO YOU MEAN, "BUT"
04:50:20 <mauke> THAT IS THAT THE CODE DOES
04:50:35 <mauke> er
04:50:38 <mauke> *THAT IS WHAT
04:50:40 <torpet> yeah sure, but with a being of Type Ord
04:50:47 <mauke> NO
04:50:51 <mauke> DID YOU LOOK AT THE TYPE
04:50:58 <srhb> mauke: Chillax.
04:50:58 <wei2912> calm down mauke
04:51:02 <mauke> NO
04:51:03 <purelazy> torpet you could comment your code :)
04:51:04 <mauke> DENIED
04:51:06 <srhb> @ops
04:51:06 <lambdabot> Maybe you meant: pl oeis docs
04:51:13 <wei2912> lambdabot++
04:51:18 <srhb> woo
04:51:23 --- mode: ChanServ set +o mauke
04:51:29 <mauke> YOU RANG?
04:51:40 <srhb> Fine. You're not contributing to a nice atmosphere here right now.
04:51:47 <torpet> nevermind mauke
04:51:48 --- mode: mauke set -o mauke
04:51:50 <srhb> And someone should take that rank from you if you can't see how that's a problem.
04:52:07 <mauke> torpet: anyway, gotta run. see my first line of code
04:52:15 <mauke> that's the type I'm talking about
04:52:38 <torpet> sorry i am an idiot, overlooked it
04:52:40 <torpet> makes sense now
04:53:01 <purelazy> torpet are u sorted?
04:53:05 <torpet> :D
04:53:15 <purelazy> hehe
04:53:18 <torpet> I am sortVPBed
04:53:19 <torpet> yeah
04:53:22 <wei2912> torpet: err...
04:53:34 <wei2912> torpet: could you test out the code you write next time? :P
04:53:49 <purelazy> torpet; what is it for?
04:54:00 <torpet> Oh I knew it didn't work, should have mentioned that lol.
04:54:12 <torpet> I am just sorting results.
04:54:37 <purelazy> OK
04:54:51 <purelazy> no need to be so specific ;)
04:55:09 <torpet> results of a game
04:55:16 <torpet> really boring
04:55:17 <purelazy> cool
04:55:29 <purelazy> what kinda game
04:55:37 <purelazy> text, 2D, 3D?
04:55:51 <tdammers> that was... uhm... unusually fierce for #h...
04:55:52 <purelazy> other?
04:55:54 <torpet> haha nothing of that, haskell
04:56:03 <torpet> wtf, i am absednt minded
04:56:12 <torpet> wanted to say "nothing like that, soccer"
04:56:29 <torpet> i am just learning haskell and wanted to write an app to sort simple tuples and triples
04:56:55 <purelazy> I am learning too
04:57:47 <tdammers> torpet: sort can already do that for tuples of Ord types
04:58:11 <tdammers> > sort [(20, 1), (4, 3), (4, 1), (9, 10)]
04:58:12 <lambdabot>  [(4,1),(4,3),(9,10),(20,1)]
04:58:19 <torpet> well the thing is i want the 3rd value to sorted the other way around
04:58:27 <torpet> 5<8 should be GT
04:58:33 <purelazy> yeah the thing is that
04:58:33 <tdammers> ah right
04:58:36 <tdammers> :t sortBy
04:58:37 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
04:58:59 <tdammers> ^ this is the generalized version of sort where you can provide your own comparison function
04:59:37 <purelazy> I imagine that is the Ordering bit
05:00:06 <tdammers> > let c (a, b) (c, d) = compare a b <> compare d c in sortBy c [(1, 2), (1, 3), (2, 1), (0, 4)]
05:00:07 <lambdabot>  [(1,2),(1,3),(0,4),(2,1)]
05:00:23 <tdammers> > let c (a, b) (d, c) = compare a b <> compare d c in sortBy c [(1, 2), (1, 3), (2, 1), (0, 4)]
05:00:24 <lambdabot>  [(1,2),(1,3),(0,4),(2,1)]
05:00:40 <tdammers> wait I messed sth up there
05:00:43 <tdammers> haha
05:02:16 <homesitter> Hi
05:02:16 <homesitter> are demos for ersatz still of interest ?
05:02:16 <homesitter> ?
05:02:48 <torpet> tdammers: what does <> do?
05:03:03 <tdammers> <> is the monoid operator
05:03:07 <purelazy> :t (<>)
05:03:08 <lambdabot> Monoid m => m -> m -> m
05:03:13 <Iceland_jack> > EQ <> LT
05:03:15 <lambdabot>  LT
05:03:16 <tdammers> a generalized version of things like +, ++, ...
05:03:33 <Zol_> :t (:(.))
05:03:34 <lambdabot>     Couldn't match expected type ‘[a]’
05:03:34 <lambdabot>                 with actual type ‘(b0 -> c0) -> (a0 -> b0) -> a0 -> c0’
05:03:34 <lambdabot>     Probable cause: ‘(.)’ is applied to too few arguments
05:03:45 <purelazy> hehe
05:03:49 <purelazy> niceone Zol_
05:04:11 <tdammers> for Ordering, EQ <> b == b, a <> b == a
05:04:18 <wei2912> what does the monoid operator do?
05:04:21 <Zol_> purelazy: Looks like a trick question on the old exam I'm currently looking at :p
05:04:27 <wei2912> `mappend`?
05:04:30 <tdammers> wei2912: whatever the monoid specified :P
05:04:36 <Iceland_jack> torpet: The definition is:
05:04:36 <Iceland_jack>     instance Monoid Ordering where
05:04:36 <Iceland_jack>       mappend :: Ordering -> Ordering -> Ordering
05:04:36 <Iceland_jack>       mappend LT _ = LT
05:04:37 <tdammers> :t mappend
05:04:38 <lambdabot> Monoid a => a -> a -> a
05:04:39 <Iceland_jack>       mappend EQ y = y
05:04:41 <tdammers> :t (<>)
05:04:42 <lambdabot> Monoid m => m -> m -> m
05:04:43 <Iceland_jack>       mappend GT _ = GT
05:04:47 <Iceland_jack> Where '(<>) = mappend'
05:04:59 <Zol_> purelazy: What made you think it was nice btw? :)
05:05:15 <purelazy> It's Homer
05:05:18 <tdammers> intuitively, mappend/<> on Ordering combines orderings in descending precedence
05:05:33 <tdammers> pretty much exactly like multiple ORDER BY clauses in SQL
05:05:59 <Zol_> What.. how should I tilt my head for that? :p
05:06:13 <Zol_> ooh :D
05:06:16 <purelazy> to the left I guess
05:06:32 <Zol_> He is whistling! :D
05:06:41 <purelazy> Yeah
05:07:14 <purelazy> an clean shaven
05:13:51 <clrnd> > mconcat [LT, EQ, GT]
05:13:52 <lambdabot>  LT
05:14:27 <Iceland_jack> > mconcat [EQ, EQ, EQ, EQ, GT, undefined]
05:14:29 <lambdabot>  GT
05:16:21 <tdammers> > mconcat $ repeat EQ ++ LT -- >:->
05:16:22 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Ordering]’
05:16:22 <lambdabot>              with actual type ‘GHC.Types.Ordering’
05:16:32 <tdammers> > mconcat $ repeat EQ ++ [LT] -- >:->
05:16:36 <lambdabot>  mueval-core: Time limit exceeded
05:19:39 <clrnd> I was hoping it'd terminate, meh
05:20:15 <clrnd> > mconcat $ [GT] ++ repeat EQ
05:20:16 <lambdabot>  GT
05:20:18 <clrnd> :D
05:20:43 <ski>   forall x,xs. repeat x ++ xs = repeat x
05:21:40 <tdammers> no, it doesn't terminate, obviously
05:22:05 <tdammers> the LT value can never be reached because the preceding list is empty
05:22:09 <tdammers> s/empty/infinite/
05:23:03 <clrnd> I meant the [GT] ++ repeat, I read it wrong
05:23:08 <ski> hm .. i wonder if a GC could be smart enough to realize that it's unreachable ?
05:30:53 <Deadsylian> i have to do more operation in a single return statement at the B\=[Void] case https://paste.kde.org/pfrp0thwo
05:31:12 <danilo2> Hello! Would somenbody be so nice and tell me why I can write in ghci "let x = []; print ((1::Int):x)" but I cannot "x <- return []; print ((1::Int):x)" ? I get error about GHC.Prim.Any - what is it ?
05:34:43 <srhb> danilo2: the first x defaults to [t], the second one to [GHC.Prim.Any]
05:36:00 <danilo2> srhb: I know, but why they cannot default to the same and what exactly is Ghc.Prim.Any? Why it cannot just default like in let case?
05:36:37 <snizzo> is there a way to pass parameters to map function calls?
05:36:39 <srhb> I suspect it's merely a ghci implementation thing.
05:36:45 <srhb> snizzo: What do you mean?
05:36:57 <tdammers> I think it has to do with how ghci sneaks execution into the repl
05:37:17 <benzrf> ok so im looking at https://github.com/HeinrichApfelmus/reactive-banana/blob/master/reactive-banana-wx/src/Wave.hs and it appears that it does timed events by using WX's Timer thingy
05:37:24 <tdammers> basically, when you write x <- something, ghci has to somehow "execute" it, but it doesn't know what you're about to do with that x yet
05:37:25 <srhb> danilo2: If you wrapped it all in a do block, the correct type would be inferred. Or even if you desugared it.
05:37:29 <benzrf> is there a way to get such an event generator without needing to pull in the entire wx library ;-;
05:37:30 <nkar> do cpp macros affect libraries that an executable depend on?
05:37:43 <snizzo> srhb: (map 5 myFunc) [1,2,3] where myfunc takes 4 arguments
05:38:17 <srhb> snizzo: Not directly no.
05:38:50 <snizzo> srhb: I'm using map but maybe I'm using the wrong function. Is there any function that could fit?
05:39:19 <srhb> If what you mean is to generically apply an n-ary function to arguments in a list, no.
05:39:20 <danilo2> srhb: I have seen this behaviour also. I still cannot wrap it at once here and just looking for information why this strange Ghc.Prim.Any defaulting occurs. Is there any reason why after the do block we cannot get the same result as from let?
05:39:27 <lostman_> why does Data.ByteString.length return Int64 while Data.ByteString.length returns an Int?
05:39:36 <srhb> danilo2: Look at what tdammers said.
05:40:00 <srhb> lostman_: You wrote Data.ByteString.length twice
05:40:10 <danilo2> srhbm tdammers: ah, ok! so is there any way to "convert
05:40:12 <lostman_> oh right, the first one is Lazy
05:40:24 <srhb> danilo2: You may specify its type.
05:40:41 <danilo2>  any datatype with Ghc.Prim.Any inside to just polymorphic type?
05:40:45 <srhb> Actually no, that wouldn't even work.
05:41:17 <srhb> danilo2: You'd have to reimplement ghci.
05:41:22 <lostman_> I'm going through the usual spaghetti of mixing lazy and strict bytestrings and if it wasn't enough pain to constantly convert between the two now I need to throw Int and Int64 into the mix
05:41:32 <tdammers> x <- (something :: IO Int) -- should work though
05:41:46 <srhb> tdammers: Huh, why?
05:41:49 <danilo2> srhb: ouch :(
05:42:40 <tdammers> srhb: 'cause it restricts the "something" action to IO Int, which means that x can only be Int itself
05:43:20 <srhb> tdammers: Oh yeah
05:45:25 <wei2912> @pl \ x xs -> f x : xs
05:45:25 <lambdabot> (:) . f
05:45:31 <wei2912> O_O
05:45:55 <ski> srhb : it would be nice if the type of `x' in the second example would be (the monomorphic type) `[_t]', where `_t' would be a logic/meta variable that got resolved/constraint/instantiated to a concrete type (say `T') as soon as `x' as used (and then `x' is known to have the monomorphic type `[T]' everywhere in that scope) -- the O'Caml implementation does this
05:46:35 <srhb> ski: Indeed.
05:46:37 <ski> (SML/NJ instead does something similar to GHCi, except it generates a new fresh skolem type (named `?.X1' and so on, iirc), instead of using a single fixed type like `Ghc.Prim.Any')
05:46:54 <srhb> Yes, it's an unnecessary restriction.
05:49:16 <danilo2> ski: exatly - that is something i'm looking for right now
05:51:50 <Pieter_> Can anyone confirm that the project homepage for gtk2hs is down ? http://projects.haskell.org/gtk2hs/
05:52:12 <Pieter_> It points to the welcome page of a wordpress site :(
05:52:41 <danilo2> Pieter_: confirmed
05:52:56 <Pieter_> Oke, thanks !
05:53:00 <wei2912> Pieter_: dfeojm
05:53:16 <Pieter_> Frustrating though.
05:53:17 <sipa> gah, i should not have a highlight on my first name
06:00:13 * hackagebot generics-sop 0.1.0.4 - Generic Programming using True Sums of Products  http://hackage.haskell.org/package/generics-sop-0.1.0.4 (AndresLoeh)
06:04:18 <danilo2> Hello! :) Is there in Haskell something like listBuilder that would allow to append elements on the end of list in O(1) + time to flatten the list? I'm asking about something like TextBuilder or ByteString builder but general for lists.
06:04:34 <Iceland_jack> danilo2: DList
06:05:12 <Flonk> While skimming through the Haskell source, I noticed a lot of #-signs in the lower level code (random snippet: `case noDuplicate# s of s' -> (# s', () #)`) - what do they mean?
06:05:34 <danilo2> Iceland_jack: Thank you!
06:05:50 <Iceland_jack> Flonk: Take a look at https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/primitives.html
06:06:03 <Iceland_jack> That specific example is an "unboxed tuple"
06:06:42 <Flonk> Iceland_jack: I'll read through that, thanks :)
06:09:24 <danilo2> Iceland_jack: btw, does DList.toList work in O(n) time? I'm asking because it uses (++) under the hood whe nappending the list chunks
06:09:56 <chpatrick> danilo2: it's O(n) to turn it into a list and traverse it
06:10:16 <chpatrick> danilo2: but appending is just a function composition
06:10:38 <danilo2> chpatrick: interesting. Because at first look it just uses (++) to concat each chunk, so it should be slower, but maybe there is something that i dont see yet
06:11:25 <danilo2> chpatrick: I know it is function composition, so its o(1), but look, then we've got function that uses (++) to glue both lists
06:11:28 <chpatrick> danilo2: DList is basically \x -> someStuff ++ x
06:11:55 <chpatrick> danilo2: specifying the x is O(1), then when you turn it into a list all the ++s happen which is O(n) in total
06:12:03 <danilo2> chpatrick: exactly, so if we append many things and use "toList" we get s1 ++ s2 ++ s3 ++ s4 ++ ...
06:12:11 <chpatrick> danilo2: but that's O(n) :)
06:12:40 <chpatrick> danilo2: it has to go over each sub-list element once to find the end of the list, then it just slaps the next list on
06:12:49 <chpatrick> danilo2: but each sub-list element is only traversed once
06:12:58 <danilo2> chpatrick: because of some optimizations? You know in general this is not O(n) because EACH (++) has to traverse the list from the beginning
06:13:06 <chpatrick> danilo2: this _would_ be slow ((s1 ++ s2) ++ s3) ++ s4
06:13:11 <chpatrick> danilo2: that's not true
06:13:25 <chpatrick> danilo2: because it's bracketed like this s1 ++ (s2 ++ (s3 ++ s4)))
06:13:33 <danilo2> chpatrick: ah!
06:13:35 <miroorim> please,...how can I get double value from POSIXTime?
06:13:41 <danilo2> chpatrick: ok, now it makes perfect sense
06:13:45 <danilo2> chpatrick: thank you! :)))
06:13:56 <chpatrick> danilo2: DList just ensures that that's how it's bracketed, no matter how you use it
06:14:14 <danilo2> chpatrick: great, thank you a lot! :)
06:14:18 <chpatrick> danilo2: it also works for any functor :) see Codensity
06:14:37 <chpatrick>  /smartarse mode off
06:14:49 <danilo2> chpatrick: oh, I've never heard about Codensity
06:15:10 <chpatrick> danilo2: the same problem arises with Free Monads because you have to traverse a big tree every time if you bracket it wrong
06:15:19 <chpatrick> danilo2: or with any structure for that matter
06:15:28 <supki> miroorim: realToFrac
06:15:34 <chpatrick> danilo2: codensity generalizes the DList idea to any kind of structure
06:15:48 <danilo2> chpatrick: right, it makes perfect sense witf free monads also. And thank you for explaining the Codensity!
06:16:27 <Grisha> hi, have data Expr = Const | Plus Expr Expr | Mult Expr Expr | Minus Expr Expr | Frac Expr Expr: what is the canonical way to automatically add brackets when implementing as a Show instance?
06:16:43 <Flonk> Iceland_jack: That cleared up a lot, thanks
06:16:49 <Grisha> would it be to break down into a two-layer Expr type
06:16:52 <Grisha> ?
06:16:56 <miroorim> supki: many thanks!
06:18:19 <chpatrick> Grisha: showsPrec / showParen?
06:18:36 <danilo2> And I've got yet another small question - is there in Haskell any standard class like class IsList a b | a -> b where toList :: a -> [b]; fromList [b] -> a ?
06:18:46 <Grisha> chpatrick, must look it up, never heard of it - thanks a lot!
06:19:04 <chpatrick> Grisha: it's part of Show
06:19:15 <Grisha> oh, nice
06:19:18 <Grisha> chpatrick, thanks a lot
06:19:27 <Iceland_jack> danilo2: There is "IsList" from Data.List
06:19:35 <Iceland_jack> that is used with the OverloadedLists extension
06:19:37 <Grisha> chpatrick, I totally am a newbie with H
06:19:51 <chpatrick> Grisha, no worries :)
06:19:56 <Iceland_jack> No sorry, from GHC.Exts
06:20:29 <danilo2> Iceland_jack: Oh, I have to be blind. thank you! :)
06:20:41 <Iceland_jack>     GHC.Exts.fromList :: [Item l] -> l
06:20:41 <Iceland_jack>     GHC.Exts.toList   :: l        -> [Item l]
06:21:19 <Iceland_jack> so for things like 'Map k v', 'Item (Map k v) = (k, v)
06:21:24 <sgillis> I have a question about Yesod and Persist. I have a function that will should be run with runDB to get the result. I know the type should be
06:21:27 <sgillis> validateAmount :: YesodPersistBackend site ~ SqlBackend => [Amount] -> Entity Wallet -> YesodDB site [ValidatedAmount]
06:21:35 <Iceland_jack> So:
06:21:35 <Iceland_jack>     fromList :: [(k,v)] -> Map k v
06:21:35 <Iceland_jack>     toList   :: Map k v -> [(k, v)]
06:21:38 <sgillis> But what is the ~ SqlBackend for?
06:22:38 <clrnd> xmonad question: I have a floating window-f "child" of window-2, and I'm in Full layout seeing window-1; if I hover window-f, window-2 comes above window-1
06:23:14 <clrnd> ofc, I don't want my windows to dance like that only because I hovered a floating window
06:23:35 <Grisha> chpatrick, one more thing if I may: what is the canonical way for implementing several builders over your data type? I would like to export my Exprs either as say Matlab or LaTeX code without having to write too much boilerplate code
06:24:17 <Grisha> chpatrick, should be easily extendable for more formats
06:25:01 <bergmark> sgillis: what happens if you remove it?
06:27:09 <chpatrick> Grisha: what do you mean by builders?
06:27:10 <znst> what is deployment of a haskell web application like?
06:27:52 <Grisha> chpatrick, like Data.Text.Lazy.Builder
06:28:09 <Grisha> chpatrick, or blaze-builder
06:30:10 <tdammers> znst: depends how you implement it... in my case, I run a script that triggers a build, copies the required files over to the server, and calls a suitable script there to restart the application
06:30:13 * hackagebot distributed-process-extras 0.1.1 - Cloud Haskell Extras  http://hackage.haskell.org/package/distributed-process-extras-0.1.1 (TimWatson)
06:30:19 <chpatrick> Grisha: this might not be the best way but you could consider Control.Lens.Plated
06:30:48 <tdammers> znst: generally speaking though, it works pretty much like everything else (except PHP)
06:31:03 <sgillis> bergmark: I get a type error
06:31:06 <sgillis>     Expected type: transformers-0.3.0.0:Control.Monad.Trans.Reader.ReaderT
06:31:06 <sgillis>                      SqlBackend (HandlerT site IO) (Maybe (Entity WalletBalance))
06:31:09 <sgillis>       Actual type: Entity Currency
06:31:12 <sgillis>                    -> YesodDB site0 (Maybe (Entity WalletBalance)
06:31:15 <znst> tdammers: are there any server provisioning gotchas?
06:31:27 <tdammers> haha, yeah, there always are :D
06:31:27 <Grisha> chpatrick, thanks a lot, I will look into it - I often have no idea whatsoever how different things are called ;)
06:31:40 <znst>  tdammers: lol, thanks the input
06:31:43 <sgillis> I just don't know the `~` symbol in types, what does it do?
06:31:55 <tdammers> znst: running a built-in server behind a reverse proxy is a pretty good setup IMO
06:32:32 <tdammers> znst: throw in a little watchdog cron job to automatically restart the app when it dies, and you have something reasonably robust
06:32:32 <bergmark> sgillis: ah, ~ is type equality
06:33:09 <Iceland_jack> :kind (~)
06:33:23 <znst> tdammers: built-in server like nginx? or is there a generic stack specific to the haskell community's software?
06:33:25 <Iceland_jack> ..
06:33:25 <Iceland_jack> @kind (~)
06:33:26 <lambdabot> k -> k -> Constraint
06:34:18 <tdammers> znst: no, built into the Haskell binary... Warp, most likely
06:34:56 <znst> tdammers: excellent.
06:35:17 <znst> tdammers: do you use a specific haskell framework?
06:35:19 <tdammers> the stack is usually something like Warp -> Wai -> (Scotty|Yesod|...)
06:35:53 <sgillis> bergmark, Iceland_jack So it is saying that site has the same type as SqlBackend? I thought that a site was something else than a SqlBackend?
06:35:55 <tdammers> I'm not really a huge fan of heavy frameworks, I prefer grabbing libraries for each part and writing the bit of glue between them myself
06:36:31 <tdammers> but if frameworks are your thing, Yesod is probably as good as it gets
06:36:48 <bergmark> sgillis: no it's saying that YesodPersistBackend site is the same as SqlBackend
06:37:00 <sgillis> Ah, okay
06:37:09 <bergmark> and YesodPersistBackend is a type family?
06:37:56 <sgillis> bergmark: I don't know what a type family is
06:38:00 <athan> Is there an easy way to promote GADTs?
06:38:03 <znst> tdammers: very helpful. what are you most excited about concerning web development in haskell? if you don't mind me asking
06:38:17 <Denommus> hi
06:38:27 <athan> znst: Haskell is really nice for compilers
06:38:40 <athan> that level of reasoning applied to web applications is what interests me :)
06:38:54 <Denommus> I still didn't find the web framework that fits my expectations :-/
06:39:01 <athan> And also that scotty (which runs on warp) throws down 6k responses/sec on my 1GB RAM core 2 duo laptop :)
06:39:13 <sgillis> bergmark: It's defined here http://haddocks.fpcomplete.com/fp/7.8/20140916-162/yesod-persistent/Yesod-Persist-Core.html
06:39:18 <athan> Denommus: I'm trying to make a bunch of generics for stuff :/
06:39:23 <znst> athan: dang :0
06:39:35 <athan> that will work with blaze-html lucid et. al
06:39:38 <Denommus> athan: any Haskell framework is way faster than popular web frameworks for interpreted languages :-)
06:39:52 <athan> It's gold :)
06:39:58 <chrisdone> sgillis: type families let you write simple functions on types. an associated type is a type function associated with your instance
06:40:05 <athan> I really want to start making web applications in idris xD
06:40:13 * hackagebot distributed-process-async 0.2.0 - Cloud Haskell Async API  http://hackage.haskell.org/package/distributed-process-async-0.2.0 (TimWatson)
06:40:15 <Denommus> athan: well, the thing I disliked about scotty was that it didn't type-checked my URL params
06:40:15 <chrisdone> sgillis: "type YesodPersistBackend site" means when you define your instance, you can write "type YesodPersistBackend App = <your backend type>"
06:40:23 <Denommus> athan: unlike, say, yesod
06:40:28 <athan> Denommus: I agree
06:40:46 <athan> sometimes you don't want that rigour
06:40:58 <Denommus> athan: but I also disliked yesod because of that binary that basically requires Stackage
06:41:15 <athan> Denommus: I like parts of yesod
06:41:26 <Denommus> I prefer to just work with a cabal sandbox instead of Stackage
06:41:26 <athan> like persistent is awesome
06:41:44 <athan> but I'm not much a fan of hamlet :s (the rest of shakespeare is good though)
06:41:55 <athan> Denommus: Same, I haven't tried stackage yet
06:42:02 <Denommus> yes, there are lots of good things in yesod. But I really thing scotty's and happstack's library approach is more interesting than shipping a binary
06:42:27 <chrisdone> Denommus: what does a binary have to do with yesod?
06:42:34 <athan> Denommus: Well, oyu still get a binary with scotty
06:42:41 <athan> and most other cabal packages :P
06:42:50 <sgillis> chrisdone: Thanks, I think I get the basics. I'll read up on type families to get more familiar
06:42:52 <Denommus> athan: Stackage either doesn't have enough packages (when you use the exclusive repos), or it's just as broken as Hackage (when you use the inclusive repos). So it doesn't have a lot of benefits over Hackage
06:43:03 <athan> chrisdone: Better get your boxing gloves
06:43:25 <Denommus> chrisdone: I'm talking about the yesod binary they use in the guide, but I am aware you can make your way without it
06:43:38 <chrisdone> it's trivial to use yesod: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/basics-of-yesod/yesod-1#hello-piggies-
06:43:48 <Denommus> athan: no, what I mean is that yesod has a "yesod init" command. That is a binary
06:43:58 <athan> Denommus: Ahh, I see
06:44:07 <athan> you can still develop without `yesod devel`
06:44:23 <athan> just make your own sandbox and `cabal install` with the package generated with `yesod init`
06:44:28 <Denommus> this package: https://hackage.haskell.org/package/yesod-bin
06:44:33 <chrisdone> if you don't want type-safe routes or any of the other stuff, you might as well use something dumb like scotty or warp. but nobody should use either for anything long-term
06:44:33 <Denommus> yeah, maybe I should try yesod without it
06:44:45 <tdammers> let's see, what do I like about haskell web dev...
06:44:51 <athan> `yesod devel` simply does `cabal install`, but runs it with a different... thing...
06:44:53 <tdammers> the language itself, obviously
06:45:08 <tdammers> tons of zero-cost and near-zero-cost abstractions
06:45:14 <Denommus> chrisdone: I have tried scotty, but doesn't it use strings for URL params?
06:45:26 <tdammers> which means I can keep my code extremely DRY, type-safe, maintainable, etc., without sacrificing performance
06:45:34 <tdammers> then, correctness guarantees
06:45:42 <chrisdone> Denommus: yes, it does (which is the problem)
06:45:53 <tdammers> I can set things up such that stuff like SQL injection, XSS, etc., become no-brainers
06:46:00 * athan hides
06:46:16 <pantsman> is there a haskell web stack that doesn't involve rails-style code gen, or stringly typed request params?
06:46:21 <tdammers> simply because my types won't let me pretend that a String and a ByteString and Html are interchangeable
06:46:27 <athan> lol
06:46:30 <chrisdone> pantsman: yesod, snap, happstack
06:46:32 <tdammers> pantsman: sure
06:46:37 <athan> (scotty :P)
06:46:49 <athan> oh
06:46:51 <tdammers> none of the frameworks use stringly-typed request params, really
06:46:58 <athan> I thought that said strangely
06:47:05 <Denommus> chrisdone: yeah. Something like scotty with yesod's URL params would be the ideal to me
06:47:06 <Denommus> chrisdone: I also have tried happstack, but it looks too old-fashioned
06:47:08 <chrisdone> in fact you can use yesod's urls independently
06:47:08 <Denommus> athan: scotty uses stringly-typed request params
06:47:18 <tdammers> Denommus: no
06:47:20 <athan> derped
06:47:36 <Denommus> tdammers: no what?
06:47:42 <tdammers> Denommus: it can, but it also provides a typeclass to tell it how to parse request params to typed values
06:47:46 <pantsman> chrisdone: I thought Yesod used TH to do basic stuff like routing.
06:47:53 <Denommus> tdammers: really?
06:47:56 <tdammers> Denommus: yes
06:48:14 <Denommus> then I'll have to check it again
06:48:25 <athan> Guyz how do I promote GADTs? :(
06:48:35 <tdammers> http://hackage.haskell.org/package/scotty-0.9.0/docs/Web-Scotty.html#g:4
06:48:36 <pantsman> does anyone think happstack is particularly active? It seemed attractive, but I don't hear much about it.
06:48:51 <chrisdone> pantsman: it does. you don't have to, but TH exists to avoid boilerplate
06:48:59 <tdammers> Denommus: particularly, the `param` function
06:49:00 <chrisdone> here is yesod without the template-haskell http://www.yesodweb.com/blog/2012/10/yesod-pure
06:49:45 <Denommus> tdammers: ah
06:49:52 <tdammers> oh, one more thing I love about Haskell web dev is how most libraries are built for reuse and modularity
06:50:09 <tdammers> so I can take some of Yesod without having to use all of it
06:50:12 <tdammers> for example
06:50:18 <Denommus> tdammers: but params are still taken with strings, right?
06:50:33 <Denommus> tdammers: doesn't yesod uses a smarter system using actual variables?
06:50:33 <pantsman> chrisdone: I know why it's used, I just hope that abstractions could be a better way to avoid boilerplate
06:50:38 <tdammers> Denommus: ultimately, yes - it's HTTP, so *everything* is a bytestring initially
06:50:45 <Denommus> tdammers: no, I mean
06:50:46 <pantsman> using TH for *routing* seems like giving up
06:51:00 <Denommus> tdammers: the parameter to take a param *is* a Text, and can be wrong
06:51:06 <tdammers> pantsman: TH for routing is so that you can type-check individual routes
06:51:12 <chrisdone> pantsman: i used to think that TH was cheating, too
06:51:17 <tdammers> Denommus: you mean the parameter name?
06:51:23 <Denommus> tdammers: so I can have a route "/:foo" and try to call param "bar", and it will be a runtime error
06:51:24 <tdammers> Denommus: yeah, that part isn't typed
06:51:35 <Denommus> tdammers: that's what I disliked about scotty, actually
06:51:45 <chrisdone> but TH is just there to generate types and instances
06:51:50 <tdammers> well, frankly, the web isn't typed, so you can't really do a lot about that part
06:52:01 <chrisdone> the abstraction underneath is fine
06:52:05 <Denommus> tdammers: a CPU also isn't typed, and look where we got
06:52:10 <tdammers> at best, you can make it such that all the URLs your application exposes are type-safe
06:52:12 <chrisdone> are lenses a poor abstraction because you need $(makeLenses ..)?
06:52:12 <pantsman> chrisdone: that blog post looks very informative, thakn
06:52:15 <pantsman> *thanks
06:52:19 <tdammers> in that whatever you emit matches something you can consume
06:52:50 <Denommus> tdammers: of course! But the point is that I can emit something incorrect in scotty, because it allows me to use parameters I have not defined
06:52:57 <tdammers> ah, yes
06:53:07 <tdammers> matter of balancing priorities methinks
06:53:24 <Denommus> maybe I should just try yesod without yesod-bin
06:53:35 <Denommus> or stop having prejudice against happstack
06:53:36 <tdammers> Yesod comes with some rather heavy machinery to make it happen, and you do pay a price
06:54:10 <Denommus> tdammers: you're talking about all the DSLs?
06:54:14 <dfeuer> @tell edwardk I think I can work around the Node (Node a) thing, but it's ugly and messy. I'd really prefer to find a way to make it clean.
06:54:14 <lambdabot> Consider it noted.
06:54:39 <tdammers> Denommus: yes. DSL's, TH, longer compile times, steeper learning curve, reduced greppability..
06:54:53 <chrisdone> the upcoming new haskell home page uses yesod and lucid for templates
06:55:11 <tdammers> also, hasktags doesn't understand TH, so I can't use tag files to step into TH-generated code
06:55:12 <Denommus> tdammers: what about Happstack? Does it provide what I'm looking for?
06:55:13 * hackagebot xml-conduit 1.2.3.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.3.1 (MichaelSnoyman)
06:55:17 <tdammers> Denommus: it might
06:55:39 <Denommus> hm
06:56:27 <Fuuzetsu> dfeuer: I missed convo earlier, are you making better fingertree implementation?
06:56:45 <Fuuzetsu> (than fingertree package)
06:57:11 <dfeuer> Fuuzetsu, no, I'm working on a replacement for the <*> implementation in Data.Sequence.
06:57:23 <Fuuzetsu> ah
06:57:42 <Fuuzetsu> hacking up the individual functions as usual then
06:57:47 <dfeuer> I want one with the right sort of performance for lazy use.
06:57:54 <dfeuer> This one's turning out to be quite a project.
06:58:15 <dfeuer> Yes, Fuuzetsu, it's a lot easier than trying to make something from scratch.
06:58:17 <Fuuzetsu> just think of the saved cycles!
06:58:34 <dfeuer> Fuuzetsu, asymptotic, these ones.
06:59:02 <Denommus> changing subjects completely
06:59:11 <dfeuer> SUBJECTS: BOW!
06:59:12 <Fuuzetsu> if there's anything I learned from Okasaki, it's that you can make anything sound O(1) with right kind of reasoning ;P
06:59:17 <chrisdone> @yow
06:59:17 <lambdabot> I'm a fuschia bowling ball somewhere in Brittany
06:59:57 <dfeuer> Fuuzetsu, ha ha.
07:00:03 <Denommus> in hsqml, can I get a signal from a QML object to connect it to a slot in Haskell, WITHOUT exporting the Haskell code for QML?
07:00:13 * hackagebot yackage 0.7.0.6 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.7.0.6 (MichaelSnoyman)
07:00:59 <Fuuzetsu> I kind of like stackage's package pages better than hackage's
07:02:52 <tomasWiedermann> som tu spravne na programvanie 3?
07:02:55 <pepol> tomasWiedermann: hi
07:03:06 <ViRPo> :D
07:03:22 <potato_> @pl \p l -> or (map p l)
07:03:22 <lambdabot> any
07:03:59 <dfeuer> Fuuzetsu, I don't even know what Stackage is :-p
07:04:10 <potato_> @pl \x y -> (x+y)*(x-y)*x/y
07:04:10 <lambdabot> join . ((/) .) . (flip =<< ((*) .) . ap (ap . ((*) .) . (+)) (-))
07:04:24 <clrnd> of course
07:04:41 <Fuuzetsu> dfeuer: apparently it's like Hackage but only with sets of packages that build and play nicely together
07:04:45 <Fuuzetsu> stable hackage or something
07:04:54 <dfeuer> Huh.
07:05:00 <dfeuer> Interesting.
07:05:15 <dfeuer> I've been avoiding really learning about package management, because it's too complicated.
07:05:25 <dfeuer> And there's too much to try to remember.
07:05:38 * Fuuzetsu uses nix so doesn't meddle into this stackage/hackage business directly anymore
07:06:00 <purelazy> \o/ nix
07:08:00 <eacameron> what's the best way to cross compile 32/64 arch on Windows? I'm running 64-bit but want to build both 32 and 64-bit exes
07:08:16 <eacameron> just install 32 and 64-bit versions of GHC?
07:09:11 <dfeuer> eacameron, doing anything weird with GHC on Windows seems to be heavy guru territory. You might want to ask on a mailing list.
07:09:23 <purelazy> then that wouldn't be cross-compile would it?
07:09:35 <eacameron> purelazy: true...
07:10:00 <tdammers> it's 2014. the accepted canonical way of doing multi-arch compilation is to just run multiple VMs
07:10:01 <texasmynsted> woot! New haskell cast.  :-)
07:10:02 <eacameron> purelazy: my fear would be that 32-bit GHC still builds 64-bit bins on my host
07:10:02 <tdammers> :P
07:10:03 <purelazy> so you've solved it
07:10:28 <tdammers> (all kidding aside, that's what I do - I just build on a 32-bit VM)
07:10:42 <eacameron> tdammers: does build with 32-bit GHC on a 64-bit host work?
07:10:43 <dfeuer> tdammers, yes, if you just run a Linux VM under Windows, your Haskell development will be much easier. You will, however, have some issues integrating with anything Windowsy.
07:10:51 <iorum> hi
07:11:02 <purelazy> hi
07:11:03 <dfeuer> iorum, how's your purewhiskey?
07:11:08 <tdammers> dfeuer: then you'd just run Windows in a 32-bit VM, right?
07:11:25 <dfeuer> tdammers, why would you do that?
07:11:33 <iorum> good good
07:11:37 <tdammers> dfeuer: to create 32-bit Windows builds?
07:11:46 <tdammers> dfeuer: assuming that's what you need...
07:11:55 <dfeuer> I don't know. That falls into the category of doing something weird with GHC and Windows.
07:11:57 <tdammers> dfeuer: in my case, I can afford to just ignore Windows entirely
07:12:17 <eacameron> tdammers: not all of us are so fortunate
07:12:23 <dfeuer> tdammers, that's been my strategy too. Unfortunately, I accidentally broke Windows builds for everybody that way once.
07:12:31 <tdammers> dfeuer: but other than that, no, it's not weird at all - you run 32-bit GHC on a 32-bit OS in a 32-bit machine
07:12:38 <tdammers> dfeuer: the machine just happens to be a virtual one
07:12:56 <tdammers> eacameron: I pay a hefty price for this privilege
07:13:02 <tdammers> eacameron: I do PHP development for a living
07:13:15 <eacameron> tdammers: [shudder] I'll stick with Windows
07:13:32 <dfeuer> tdammers, I tend to lump doing anything with GHC on Windows beyond "download the Haskell Platform and compile sources" to be "weird".
07:13:52 <eacameron> dfeuer: Thankful for minghc build now
07:14:17 <tdammers> dfeuer: yeah, but then, that's exactly what you'd be doing
07:15:13 * hackagebot distributed-process-client-server 0.1.1 - The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-client-server-0.1.1 (TimWatson)
07:15:24 <lpaste> ionum pasted “How to ...” at http://lpaste.net/116692
07:16:23 <srhb> ionum: How to... what? :P
07:17:24 <ionum> I have some xml that i want to parse. it is used to render a graph. i want to change same values in haskell and want to represent the tree structure nicely, but i do not want to basickally build a stupid wrapper for data like Point and Path
07:17:31 <quxbam> i've made progress with my emacs haskell FFI
07:18:04 <quxbam> it is now possible to call funs with a lot of different types directly from emacs
07:18:11 <ionum> i want to say: Point, Path, Location... is also of type Element
07:18:30 <quxbam> the input is parsed and the output is encoded in elisp
07:19:00 <ionum> and Model = [Element]
07:19:12 <dfeuer> tdammers, tbh, I haven't even installed GHC on a Windows machine in years. I do all my hacking and almost everything else on Fedora.
07:19:56 <tdammers> dfeuer: debian here, same story otherwise
07:20:12 <srhb> ionum: why not invert it so you have data Element =
07:20:15 <srhb> { _eType, ...
07:20:41 <tdammers> I do have a few 32-bit servers left though, so the VM-based cross-compilation setup is still pretty useful to me
07:20:44 <quxbam> is anybody interested? i would be happy to receive tips
07:21:00 <tdammers> VM's are also a great way to test against a virgin OS install
07:21:09 <dfeuer> quxbam, what is this, a Haskell-to-elisp compiler?
07:21:09 <srhb> quxbam: It sounds like the sort of thing that might be awesome when integrating the haskell modes and whatnot with Emacs
07:21:48 <ionum> srhb: can you explain what you mean?
07:21:56 <quxbam> hmm, it's more like an automatic wrapper
07:22:22 <quxbam> a little haskell process will provide functions which are exported in self written modules
07:22:35 <srhb> ionum: So you have one data type that encompasses elements, and then you have an ElementType datatype that specifies its kind and properties etc.
07:22:45 <quxbam> and the elisp side does wrap every function which is provided by the haskell process into elisp functions
07:23:12 <dfeuer> ski, I think I've accomplished (most of) the mission, but for reasons I don't entirely understand the types are forcing things to be a little deeper than I want, which will make me write a lot of special cases for short things.
07:23:43 <ski> mhm
07:23:44 <ionum> srhb: can you give me a little example, please I am still learning ^^
07:24:28 <dfeuer> ski, it's also possible this actually isn't working entirely  :-/
07:24:31 <dfeuer> HMM
07:24:57 <quxbam> if you would like to see an example of my wrapper: https://github.com/knupfer/haskell-emacs
07:25:04 <dfeuer> Yes, ski, I'm having off-by-one or off-by two problems with my types :-(
07:25:16 <ski> chrisdone : btw, `(=<<)' is in the literature often referred to as "extend" or "monadic extension operation"
07:25:17 <dfeuer> Maybe what I am trying to do is impossible.
07:25:26 <srhb> ionum: Um, I don't know how to be more explicit... data Element = Element { _name :: EName, _properties :: EProp }; data EType = Pos Double Double | StartEnd EName EName; ...
07:25:45 <ionum> ah ok
07:25:46 <srhb> er, data EProp
07:25:49 <srhb> not EType
07:26:00 <srhb> (although now I have Angels Crying going in my mind...)
07:28:11 <lpaste> ionum pasted “ToParse” at http://lpaste.net/116693
07:28:47 <Eduard_Munteanu> @hoogle extend
07:28:48 <lambdabot> System.Posix.Terminal.ByteString ExtendedFunctions :: TerminalMode
07:28:49 <lambdabot> System.Posix.Terminal ExtendedFunctions :: TerminalMode
07:28:49 <lambdabot> Text.Regex.Posix.Wrap compExtended :: CompOption
07:29:18 <indiagreen> Eduard_Munteanu: did you mean extend in Control.Comonad?
07:29:21 <Eduard_Munteanu> For some reason I remember that being the name for (<<=), not (=<<).
07:29:23 <Eduard_Munteanu> Yes.
07:29:29 <indiagreen> http://hackage.haskell.org/package/comonad-4.2.2/docs/Control-Comonad.html#v:extend
07:29:36 <srhb> <<= ?
07:29:51 <srhb> What even is that.
07:29:55 <athan> Is there any way to declare kinds?
07:30:00 <athan> (without DataKinds)
07:30:01 <Eduard_Munteanu> (<<=) :: Comonad w => (w a -> b) -> w a -> w b
07:30:25 <Eduard_Munteanu> athan, declare in what way? KindSignatures?
07:30:28 <athan> srhb: It's application
07:30:31 <athan> function application
07:30:35 <athan> (for comonads :])
07:30:39 <srhb> Yeah, I see it. :)
07:30:51 <athan> Eduard_Munteanu: I'm trying to do DataKinds manually
07:31:05 <mmachenry> Is there no way to get a source distribution of Haskell Platform 2014 that doesn't require an existing GHC 7.4?
07:31:05 <athan> I've got a GADT I'd like to promote, but can't cause it's a GADT :P
07:31:15 <ionum> srhb: if i do it like you suggested, then it will be possible, that someone creates a Point with a Property, that should not belong to a Point
07:31:19 <ionum> am i wrong?
07:31:20 <athan> All I need to do is reference the GADT from a kind
07:31:32 <dfeuer> srhb, the initial mention was of =<<, not <<=.
07:31:41 <srhb> ionum: In a way where your example wouldn't fail?
07:31:47 <srhb> dfeuer: Ah.
07:31:48 <Eduard_Munteanu> athan, ah, then no. But you might be able to get some effect using PolyKinds and using a kind variable
07:32:01 <athan> hmm, alrighty. Thank you!
07:32:09 <athan> How is PolyKinds supposed to be used?
07:32:11 <texasmynsted> so very off topic, but does anybody here play Go on mac and have a favorite go client?  http://senseis.xmp.net/?GoClient
07:32:23 <srhb> texasmynsted: That's too off topic.
07:32:29 <texasmynsted> sigh ok
07:32:35 <tdammers> texasmynsted: try #haskell-blah?
07:32:39 <srhb> texasmynsted: There's #haskell-blah
07:32:40 <texasmynsted> oh, sure
07:32:41 <srhb> Eh.
07:32:48 <texasmynsted> sorry
07:32:57 <srhb> No problem, can't know before you accidentally fail. :-)
07:33:12 <Denommus> meh, nobody here really uses hsQML, right? :-/
07:33:20 <tdammers> srhb: what kind of unityped attitude is that?
07:33:25 <Eduard_Munteanu> athan, so instead of having a separate kind, use * and make your kind signatures polymorphic to get some more kind safety.
07:33:31 <srhb> tdammers: True. We need to fix that.
07:33:41 <tdammers> :D
07:34:02 <srhb> Either Response OffTopicRant.
07:34:14 <srhb> Wait, that should be the other way around.
07:34:27 <athan> Eduard_Munteanu: Oh woah, it's like RankN at the kind level
07:34:30 <athan> (but inferred)
07:35:56 <ionum_> so nobody can tell me, how make good data types for sth like this http://lpaste.net/116693
07:36:03 <tdammers> srhb: depends on the channel
07:36:05 <ski> Eduard_Munteanu : yes, just like there is "monadic extension", there can be "comonadic extension"
07:36:17 <srhb> tdammers: Point.
07:36:37 * ski suggested the name `preserve' for `(<<=)'
07:36:56 <ski> (and `scaffold :: Comonad w => w a -> w (w a)')
07:37:33 <srhb> Shouldn't that be split or unjoin?
07:37:48 <ski> @type System.Random.split
07:37:49 <lambdabot> RandomGen g => g -> (g, g)
07:37:56 <srhb> Meh, get rid of that! :-)
07:38:01 <exio4> just add co-
07:38:08 <srhb> Then it would be cojoin
07:38:10 <exio4> coreturn, cojoin, cobind, whatever!
07:38:14 <Eduard_Munteanu> athan, e.g. suppose you want to represent categories. Instead of talking about a concrete kind for objects and arrows (e.g. Ob c -> Ob c -> Arr c), you could instead have polymorphic kinds like 'ob -> ob -> arr', even if they do end up being combinations of * and (->).
07:38:15 <srhb> Ah, yes :P
07:38:21 <clrnd> counsafeperformIO
07:38:22 <Eduard_Munteanu> If that makes sense to you.
07:38:37 <srhb> clrnd: Would that unsafely do an IO action?
07:38:41 <ski> also, e.g. for `\a -> (s,s -> a)' or `Stream', it doesn't really "split" in any meaningful sense of the word
07:38:45 <srhb> unsafely UNdo*
07:39:02 <clrnd> exactly, but only maybe
07:39:07 <athan> Eduard_Munteanu: Perfect sense
07:39:16 <ski> clrnd : `unsafePeekComputation :: a -> Computation a'
07:39:19 <athan> On a side note - Agda web framework: https://github.com/larrytheliquid/Lemmachine
07:39:43 <ski> (`Computation a' would, among other things, allow you to inspect whether a thunk has been forced yet, or not)
07:40:22 <ski> clrnd : .. also, there's `OI' (even a paper about it) -- but it's unsafe
07:41:05 <clrnd> ski, jajaja omg i have to google that
07:41:16 <mmachenry> I am trying to give my company's sysadmin advice on building Haskell Platform-2014 from source. It seems that it requires ghc-7.8.3, which in turn requires GHC itself. We're on Oracle Linux which has no binary distribution. Is there a way to avoid a laborious process?
07:41:22 <ski> Eduard_Munteanu : itym s/polymorphic kinds/parameterized kinds/ or something like that ..
07:41:39 <ski> clrnd : search for paper by Kieburtz (iirc)
07:42:00 <clrnd> athan, that's remarkable, though I don't understand one bit of the source code
07:42:25 <EvanR> mmachenry: its linux? theres a binary distribution of ghc
07:42:29 <Eduard_Munteanu> ski, poly as in PolyKinds
07:42:39 <ski> (for the above `Computation', it's an idea i got from reading an article about using comonads in programming language semantics to reason about the stages of knowledge about the value of an expression)
07:42:41 <clrnd> ski, lol it's a comonad for real!
07:43:00 <ski> Eduard_Munteanu : i think that extension is probably a misnomer
07:43:08 <mmachenry> EvanR: It's Oracle Linux. There are binary distributions for many Linux systems. For Oracle Linux the only one is a lagged-behind 2012 Haskell Platform.
07:43:09 <Eduard_Munteanu> My point was it helps afford some more kind-safety even if you don't use kinds other than those made of * and (->).
07:43:14 <Eduard_Munteanu> Yeah, it sort of is.
07:43:29 <EvanR> mmachenry: you might be thinking of package management
07:43:47 <mmachenry> EvanR: Perhaps.
07:44:01 <dfeuer> ski, you got a minute to help me?
07:44:05 <EvanR> binary distribution means down a program, run it. like .exe files
07:44:26 <EvanR> mmachenry: theres no ghc for slackware for example but you can still have linux on slackware
07:44:40 <dfeuer> EvanR, Slackware still exists?
07:44:58 <EvanR> 14.1 seems to be the latest
07:45:03 <mmachenry> EvanR: I thought the distribution would matter due to slightly different glibc versions, etc. No?
07:45:04 <EvanR> blasted straight past 13.37
07:45:52 <EvanR> mmachenry: im not familiar with ghc's policy on libcs, but its possible to statically link a libc for a given family of kernels
07:46:00 <Eduard_Munteanu> mmachenry, glibc ABI doesn't change all that often, and one can compile static binaries or distribute glibc along.
07:46:13 <EvanR> just download a ghc and try it
07:46:27 <mmachenry> EvanR: I will, thanks.
07:47:02 <athan> clrnd: The Agda / Haskell FFI looks pretty sensible! That web server is out of date, though, but I might try something myself :)
07:49:23 <clrnd> athan, aha hadn't seen that aprt, it uses a Haskell framework, now it makes sense
07:49:27 <clrnd> it was just too compact
07:50:43 <athan> clrnd: Yeah, it's using hack which looks pretty dead. Might as well use warp :)
07:51:11 <athan> I really like the idea of using graphs for security policies, I bet dependent types would help us make graphs more easily (so it feels)
07:53:13 <Fuuzetsu> plenty of space for graph modules in Agda stdlib
07:53:27 * tdammers is still baffled at how easy it is to write an application that supports cgi, scgi, and built-in warp, without recompiling...
07:54:00 <tdammers> so now I use plain CGI for development (faster dev cycles, no need to restart anything), warp for production
07:54:25 <athan> tdammers: I've never used CGI ._.
07:55:03 <athan> is it like a particular application interface or something?
07:55:16 <tdammers> yeah
07:55:21 <tdammers> the simplest one of them all
07:55:28 <athan> o.o
07:55:50 <tdammers> the "protocol" is that the web server sets a bunch of environment variables, and then feeds the HTTP request to the CGI app on stdin
07:55:58 <flux> the thing with CGI is that your application starts and stops for each request, so if you want to persist state, it needs to happen via a cookie, filesystem or a database
07:56:03 <tdammers> and the CGI app outputs the response on stdout and then exits
07:56:04 <athan> oh for real? Wow
07:56:05 <dfeuer> Hmmm... found one problem.
07:56:07 <flux> ..or a background process
07:56:15 <tdammers> so yeah
07:56:21 <tdammers> new process for every request
07:56:24 <tdammers> not very efficient
07:56:34 <tdammers> but good enough for my current dev purposes
07:56:40 <athan> but, you don't have to build it on warp, right?
07:56:50 <tdammers> warp gets compiled in anyway
07:56:53 <athan> you can just pump the raw requests into stdin?
07:56:55 <athan> oh lol
07:57:08 <tdammers> oh, that's what you mean... no, you don't need warp for cgi
07:57:15 <chrisdone> i run warp inside ghc =p
07:57:17 <tdammers> there's a CGI backend for Wai
07:57:23 <chrisdone> er, inside ghci
07:57:38 <tdammers> chrisdone: you could probably run warp inside ghc, too, if you write suitable TH code
07:57:43 <chrisdone> i hit f12 to reload the project and restart the server
07:57:44 * tdammers shudders
07:57:52 <chrisdone> takes about a second
07:57:59 <athan> chrisdone: That's so awesome
07:58:05 <athan> can you debug live requests?
07:58:26 <chrisdone> you could run the debugger, yeah. set a breakpoint or w/e. i don't do that much
07:58:30 <tdammers> anyway, in my case, I just rebuild and reload in the browser
07:59:55 <clrnd> the PHP way I like it
08:00:15 <Fuuzetsu> too much web talk in here
08:00:30 <znst> i don't think so :/
08:02:09 <clrnd> I'm offended because, since I was away last week, the IRC bot of our office server is now some coffescript thingy (Hubot)
08:02:39 <clrnd> instead of the almighty lambdabot
08:02:58 <Fuuzetsu> this is why /kick and friends exist
08:05:13 * hackagebot stackage 0.2.0.0 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.2.0.0 (MichaelSnoyman)
08:06:32 <cschneid> I'm having a hard time getting Hasql to actually run a request - can somebody take a look and point me in the right direction?  https://gist.github.com/cschneid/cbaab379eeeb1787d992 -- As far as I can tell, I should have a `Mapping` instance for Text (and int and similar), but its not finding it.
08:07:39 <ski> dfeuer : hm, i have to leave :/
08:07:47 <cschneid> it seems to work if I use `unit` instead of `single`, skipping the whole parsing of results.
08:10:13 * hackagebot yesod 1.4.1.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.4.1.2 (MichaelSnoyman)
08:10:15 * hackagebot yesod-core 1.4.6.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.6.2 (MichaelSnoyman)
08:13:23 <qbit> whoa - big channel
08:13:37 <Iceland_jack> Welcome qbit
08:13:44 <qbit> Thanks Iceland_jack
08:14:05 <qbit> I have a cabal / stackage question .. in the "setup" instructions it says: "Please place this file next to your .cabal file as cabal.config"
08:14:12 <qbit> what does that mean? :P
08:14:18 <qbit> if .cabal is in ~/
08:14:24 <qbit> does cabal.config go in ~/ as well?
08:15:44 <chrisdone> qbit: you can now have a cabal.config file in your project directory
08:16:18 <chrisdone> qbit: so you just download the file cabal.config and save it in your project dir alongside yourproject.cabal
08:16:28 <qbit> chrisdone: ah - i see
08:16:49 <qbit> is there a way to use stackage as the base for cabal as a whole?
08:18:14 <chrisdone> qbit: you could change your remote-repo to the line it says in the cabal.config file
08:18:41 <chrisdone> e.g. remote-repo: stackage-nightly-2014-12-17:http://www.stackage.org/snapshot/nightly-2014-12-17
08:18:54 <qbit> ok
08:18:58 <qbit> thanks chrisdone
08:22:09 <chrisdone> tdammers: athan: this is pretty much how i dev all my sites from emacs https://www.youtube.com/watch?v=M9__fJCfAEY
08:23:57 <athan> chrisdone: the glory is blinding
08:24:40 <bananagram> bitmap-0.0.1 has bitmapToBytestring, but bitmap-0.0.2 doesn't
08:24:51 <bananagram> and there doesn't seem to be any way to do that now
08:26:26 <bananagram> gloss doesn't seem to have any way to read Bitmaps
08:26:44 <bananagram> ugh
08:27:26 <chrisdone> athan: lol
08:29:01 <weasel__> Hi, I have a quick question about ekmett's algebra package, specifically Numeric.Coalgebra.Geometric
08:29:59 <weasel__> The basis blades don't appear to be carrying scales, and I don't see a way to go from a Comultivector to its component basis blades
08:30:13 * hackagebot cublas 0.2.1.0 - FFI bindings to the CUDA CUBLAS and CUSPARSE libraries  http://hackage.haskell.org/package/cublas-0.2.1.0 (bmsherman)
08:30:56 <weasel__> Am I missing something obvious?
08:33:08 <bananagram> is it just me or does bitmap suck? it seems to be useless unless the software you're using uses it directly
08:33:56 <bananagram> I want to manipulate some bitmaps and give them to Gloss to use, but it doesn't support bitmap, only Codec.BMP which is very weak
08:34:28 <bananagram> gloss haa the option to load from a bytestring but bitmap dorsn;t have the option to export it to one
08:36:42 <Javran> saying that xs :: [a], ys :: [a], " (if null xs then id else delete (head xs)) ys " and " ys \\ (maybeToList . listToMaybe) xs " does the same thing, which one you would prefer?
08:39:13 <ski> Javran : i suppose the latter, or a `case'
08:39:25 <mmmm> I would probably do a case
08:40:13 * hackagebot lambdaBase 0.0.1.0 -   http://hackage.haskell.org/package/lambdaBase-0.0.1.0 (faleidel)
08:40:31 <Javran> ski: mmmm: oh I haven't considered that, does look better, thanks!
08:41:59 <ski> Javran : oh, i didn't read too closely. `(maybeToList . listToMaybe) xs' could be just `take 1 xs'
08:42:54 <ski> (still, if you also want to do something with the tail of `xs', i would probably use `case' anyway .. and perhaps even if not)
08:43:08 <Javran> ski: I see
08:44:29 * ski . o O ( `(case xs of [] -> id; x:xs -> delete x) ys' )
08:45:12 <dfeuer> Javran, FYI, maybeToList and especially listToMaybe have always struck me as rather sloppy. There are some things in Data.Monoid and Data.Foldable to help with that, and Data.List will have "uncons" in 4.8, which is also nice (and easy to write yourself)
08:45:58 <dfeuer> ski, frustration abounds. I realized some of what I'm doing wrong, and will have to rewrite a lot of stuff again, hoping that something will work. BLEH.
08:46:12 <ski> `listToMaybe' is sometimes known as `safeHead'
08:46:23 <ski> dfeuer :/
08:47:10 <dfeuer> ski, so it is; so it is. There's no safeTail to go with it though.
08:47:23 <Javran> uncons?
08:47:30 <Javran> :t uncons
08:47:31 <lambdabot> Cons s s a a => s -> Maybe (a, s)
08:47:46 <Javran> ah I see
08:47:48 <dfeuer> Javran, uncons is mostly useful for passing to unfoldr and such.
08:47:54 <Iceland_jack> Also for patterns
08:48:05 <dfeuer> This uncons is  uncons :: [a] -> Maybe (a, [a])
08:48:14 <Iceland_jack>     pattern Nil       <- (uncons -> Nothing)
08:48:14 <Iceland_jack>     pattern Cons x xs <- (uncons -> Just (x:xs))
08:48:29 <RchrdB> dfeuer: unfoldr uncons == id?
08:48:37 <dfeuer> Iceland_jack, yeah, I don't know all that fancy syntax stuff.
08:48:59 <dfeuer> RchrdB, you'd be using it *with* unfoldr, not passing it directly in.
08:48:59 <Iceland_jack> dfeuer: It's not that relevant, it's even wrong :)
08:49:07 <Javran> hmm, didn't know uncons before, looks convenient
08:49:08 <Iceland_jack>     pattern Cons x xs <- (uncons -> Just (x, xs))
08:50:01 <dfeuer> Why would you bother with that, Iceland_jack?
08:50:17 <Iceland_jack> dfeuer: If 'uncons' is a method of a type class
08:50:22 <dfeuer> Hmm.
08:50:24 <dfeuer> Colud be.
08:50:25 <Iceland_jack> You can define 'uncons' for [a], Text, ... etc.
08:50:38 <Javran> just recall that whenever I import Data.Foldable, I have to hide lots of things from Prelude :(
08:50:41 <bennofs> Can you define polymorphic pattern synonyms?
08:50:42 <Iceland_jack> and then you can pattern match with Nil and Cons on anything that implements 'uncons'
08:50:44 <Iceland_jack> Sure
08:50:54 <dfeuer> Javran, that's because you're not using GHC HEAD.
08:51:03 <dfeuer> Iceland_jack, oh, nice.
08:51:04 <bennofs> oh, that's nice :=)
08:51:20 <Iceland_jack>     pattern Empty = []
08:51:21 <Iceland_jack> where
08:51:21 <Iceland_jack>     Empty :: [a]
08:51:44 <Javran> dfeuer: GHC HEAD?
08:52:04 <dfeuer> Javran, if you use git to download the latest GHC sources and compile them yourself.
08:52:39 <dfeuer> All the things in the Prelude that used to conflict with the ones in Data.Foldable now *are* the ones in Data.Foldable.
08:52:47 <dfeuer> The same goes for Data.Traversable.
08:53:16 <dfeuer> Also, some stuff from Data.Monoid seems to have gotten into the Prelude; not sure exactly what.
08:53:28 <ski> dfeuer : with the `Data.{Foldable,Traversable}' signatures, or with the more restricted `Prelude' ones ?
08:53:39 <dfeuer> ski, with their general signatures.
08:53:47 * ski thinks it ought to be possible to rexport an operation with a more restricted signature
08:54:05 <ski> s/rexport/reexport/
08:54:20 <dfeuer> ski, that would bring back the conflicts, unless of course the import mechanism could recognize that and choose the most general... messy.
08:54:32 <Javran> oh that's sweet
08:54:35 <dfeuer> Especially if there *isn't* a most general.
08:55:00 <ski> dfeuer : you just have to disambiguate then, as usual
08:55:13 * hackagebot codex 0.2.1.0 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.2.1.0 (aloiscochard)
08:55:34 <dfeuer> There are still a few performance regressions resulting from that, last I checked. I've just moved on for now from screwing around with Data.List to screwing around with containers.
08:55:36 <ski> (it also ought to be possible to make a method signature more general in a subclass, imho)
08:55:53 <dfeuer> Oh, that's an interesting thought.
08:56:17 <dfeuer> Unfortunately, you often really want the opposite, which is a no-can-do.
08:56:37 <ski> (or, if anything like jmeacham's superclassing proposals gets implements : also being able to make a method signature more restricted in a superclass)
08:57:46 <dfeuer> ski, I really want to see one of those or similar get done. The DefaultSignatures thing is frickin' upside down.
08:58:11 <chrisdone> frickin
08:58:14 <chrisdone> i prefer 'functoring'
08:58:51 <dfeuer> chrisdone, how about "fucking"?
08:58:52 <edwardk> defaultsignatures is very very backwards, yes
08:59:40 <ski> oh, and on this subject ..
09:00:04 <ski> .. why isn't it possible to place type signatures in instances ?
09:00:11 <hodapp> motherfunctor.
09:00:12 * hodapp runs away
09:00:32 <weasel__> Can anyone help with the algebra library? I'm trying to use the geometric algebra it provides but I can't tell if I'm using it correctly
09:01:07 <athan> Is there an identity constraint?
09:01:08 <dfeuer> ski, I think it's a general fear of duplication or something. But yes, it would be nice if you could duplicate those signatures for documentation and to help you write the bloody things. Then again, you can always just put them in comments.
09:01:18 <ski> if i'm making an `instance Functor Foo where ...' (just an example), then i want to be able to say in there `fmap :: (a -> b) -> (Foo a -> Foo b); fmap f ... = ...'
09:01:21 <dfeuer> athan, is there a what?
09:01:45 * ski always ends up having to write the signature in a comment, and then it's not compiler-checked :(
09:02:01 <athan> dfeuer: Say I have a type family that takes in two parameters - a constraint and a type. How could I make an instance with this supposed "identity" constraint?
09:02:14 <dfeuer> ski, so you want the compiler to check that the *signature* you give for documentation purposes is actually the right one? I think that's a reasonable request.
09:02:27 <Qfwfq> ski: {-# LANGUAGE InstanceSigs #-} IIRC
09:02:50 <athan> ^ InstanceSigs doesn't really even add anything :c
09:02:59 <Fuuzetsu> instancesigs ftw
09:03:05 * Iceland_jack is a fan of Instancesigs
09:03:08 <dfeuer> athan, can you   type instance Foo (~) blah ?  I don't know.
09:03:11 <ski> Qfwfq : oh, looks like exactly what i wanted :)
09:03:17 <ski> this must be relatively new
09:03:20 <ski> ty
09:03:24 <Qfwfq> <3
09:03:31 <Iceland_jack> Sadly it's a bit broken but it is fixed in 7.10
09:03:44 <athan> dfeuer: Or like a reflexive unary equality..?
09:04:00 <dfeuer> athan, I'm not a type wizard like you. No idea what you're talking about.
09:04:10 <athan> :C
09:04:24 <ski> athan : is the kind of it `Constraint -> * -> *' ?
09:04:27 <athan> dfeuer: I prefer bridge troll
09:04:32 <MP2E> haha
09:04:32 <athan> ski: Yes!
09:04:37 <athan> .. I think
09:05:01 <ski> athan : maybe you want something like `type instance Foo () (...) = ...' ?
09:05:13 * hackagebot lambdaLit 0.1.0.0 - ...  http://hackage.haskell.org/package/lambdaLit-0.1.0.0 (faleidel)
09:05:24 <athan> ski: Maybe!! Do all types inhabit `() => a`?
09:05:51 <dfeuer> Oh, interesting.
09:06:05 <ski> athan : all concrete (monomorphic ?) types should be instances of that type scheme, yes
09:06:22 <ski> athan : edwardk's <https://hackage.haskell.org/package/constraints> uses `()' in this sense, e.g.
09:06:25 <athan> ski: Awesome :) Thank you!!
09:06:31 <athan> oh woah
09:06:36 * athan grabs shovel
09:08:12 <athan> oh wait I saw this on the comonad reader! Way over my head, but hopefully I'll.. be less.. plebian. Thanks edwardk :)
09:09:55 * ski has mixed feelings about the use of the `(..,.., ... ,..)' notation for compound constraints
09:10:12 <ski> (and also about the use of that notation for tuple types)
09:10:25 <Iceland_jack> ski: Why do you have mixed feelings about that?
09:11:07 <ski> because it makes it harder to (possibly in an extension) talk about tuples of types, as opposed to types of tuples
09:11:29 <ski> (or as opposed to conjunctions of constraints)
09:11:43 <Iceland_jack> Yes that's already a slight problem, expressing the empty constraint for example
09:12:24 <Iceland_jack>     ()  :: *
09:12:25 <Iceland_jack>     '() :: ()
09:12:25 <Iceland_jack>     ()  :: Constraint
09:13:45 <haasn> My most major issue with (..,..) constraints is that going back and forth between types with 1 constraint and types with 2 or more constraints is a huge hassle
09:13:54 <haasn> Foo a  <->  (Foo a, Bar a)
09:14:13 <haasn> Would be less of a hassle to just add “, Bar a”
09:14:23 <FreeFull> Rust uses + to combine constraints
09:14:40 <Iceland_jack> FreeFull: That just opens a whole new can of worms :)
09:15:10 <weasel__> But A + B for Either A B would be so pretty
09:15:17 <Iceland_jack> You can do that already
09:15:20 <Iceland_jack>     type a + b = Either a b
09:15:21 <FreeFull> The syntax in Haskell is pretty well established, I don't think adding an alternative will become popular
09:16:52 <weasel__> Ah, didn't realize that
09:18:55 <Qfwfq> Then you have to worry about overloading with TypeLits etc. though
09:19:27 <Iceland_jack> Yes, there are also plans to lift the usual (+) to the type level so..
09:19:35 <Iceland_jack> '+
09:24:27 <athan> Fuuzetsu, Iceland_jack: What do you practically get out of InstanceSigs?
09:24:39 <athan> I can't seem to bring any additional information / context into instances
09:25:04 <Java-programmer> h
09:25:05 <Java-programmer> hi
09:25:09 <Iceland_jack> athan: My main use for it is documentation, exactly the same as top-level type signatures
09:25:38 <athan> Iceland_jack: crud
09:25:42 <Iceland_jack> But they also help for personal understanding and pedagogically, make the method types explicit
09:27:04 <athan> I'm trying to make a function that accepts either IsString (a constraint), or my custom data type with only IsString fields (this is overloaded with typeclass instances of the function `foo :: ( Foo a, IsString b ) => a -> b`, to "render" the data type)
09:27:17 <athan> I just can't force `a ~ b` in the signature :(
09:29:30 <clrnd> hi Java-programmer
09:30:13 <Java-programmer> Someone can buy this game ? http://bluesweatshirt.itch.io/fantastic-witch-collective pà
09:30:14 * hackagebot hopenssl 1.7 - FFI bindings to OpenSSL's EVP digest interface  http://hackage.haskell.org/package/hopenssl-1.7 (PeterSimons)
09:30:23 <Java-programmer> I have no home , I am poor è
09:30:46 <Java-programmer> is only $9.99 USD
09:30:58 <Fuuzetsu> athan: I only use them during dev, when I want to make sure I'm writing the right instance; combine with ScopedTypeVariables and holes for max benefit
09:31:43 <Fuuzetsu> athan: I don't think the signatures can give you any ‘new’ info
09:32:37 <athan> Java-programmer: I was homeless for 6 months and just got a job, if you give me til friday, I can get you some BTC
09:33:01 <Fuuzetsu> BTC? Can you eat those?
09:33:12 <athan> Fuuzetsu: Thanks hahaha.
09:33:22 <glguy> You can warm your hands by the computer that produced them, at least
09:33:25 <athan> Fuuzetsu: You can if you go drug-dealer status
09:33:30 <Fuuzetsu> hehe
09:33:44 <athan> "naw man, these are the REAL currency right here!"
09:35:19 <EvanR> Fuuzetsu: https://bitdazzle.com/food
09:36:09 <Fuuzetsu> damn those cookies look good
09:36:39 <EvanR> java-programmer ought to get a job faster than anyone save php-programmer
09:38:07 <EvanR> https://gooroo.io/GoorooTHINK/Article/16225/Programming-languages--salaries-and-demand-October-2014/17081#.VJG-yXW9-kA
09:38:18 <Java-programmer> I'm hungry, I do not eat anything from one month
09:38:34 <moop> eating is overrated
09:38:37 <tnks> Java-programmer: is there a particular reason you're on #haskell to solve this problem.
09:38:53 <Fuuzetsu> why are Clojure users getting more than Haskell users
09:39:01 <Fuuzetsu> I guess they get paid for the suffering
09:39:04 <tnks> or is this an inside joke I'm just getting.
09:39:20 <EvanR> yeah the harder it is to use, the more money you make, generally
09:39:35 <moop> that's why php devs are so rich
09:39:36 <Fuuzetsu> surely PHP should be in 6 figures
09:39:58 <tnks> Fuuzetsu: I don't think it's fair to look at salary by technology.
09:39:58 <EvanR> php is easy to use, but using it to make working software doesnt factory into salaries
09:40:04 <tnks> the spread is too big.
09:40:22 <moop> COBOL people are making all the bucks
09:40:25 <Denommus> I think Clojure has a bigger demand because of the JVM factor
09:40:26 <EvanR> "PHP, I know this"
09:40:29 <tnks> and looking at the top percentile is misleading.
09:40:35 <Denommus> COBOL is for the lack of offer
09:41:48 <moop> why c# so popular tho
09:42:24 <josephle> now that .net is open source, c# can only get more popular!
09:42:24 <Fuuzetsu> it's not Java which is nice
09:42:43 <EvanR> understatement
09:43:23 <weasel__> c# is like java except slightly better so you feel good about it. LINQ is also very popular
09:43:54 <Denommus> C# is way better than Java. If not for anything, because of actual pass-by-reference and proper generics
09:44:41 <Fuuzetsu> proper generics? What did it improve? Still no higher-kinded…
09:46:57 <ibid> both languages retrofitted generics, they weren't designed into the original languages
09:47:06 <c_wraith> actual pass-by-reference?  I thought getting rid of pass-by-reference was one of the things java got right.
09:47:32 <c_wraith> pass-by-reference is a terrifying sea of hidden sources of mutability
09:53:50 <edwardk> athan: i took some time in response to that to add a raft of docs to constraints =)
09:53:51 <ibid> c_wraith: c# implements out parameters as pass-by-reference. that's a horrible idea imo
09:53:56 <edwardk> one sec, it'll be on hackage
09:54:06 <athan> :O!!!!!
09:54:16 <lpaste> NickT__ pasted “Type error?” at http://lpaste.net/116704
09:54:19 <jfischoff> Does anyone know anything about async IO, like AIO on linux and completion ports on Windows?
09:54:30 <NickT__> Can someone explain why that's a type error?
09:54:37 <athan> edwardk: Direct me to your feet, and I will kiss them
09:54:38 <jfischoff> I’m curious is if there is an advantage to using them with GHC
09:54:46 <edwardk> https://github.com/ekmett/constraints/commit/4cf82d771def75f34e42d10ad73a071ad1e68442 summarizes the new changes until i can get the docs up on hackage
09:55:14 * hackagebot constraints 0.4.1 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.4.1 (EdwardKmett)
09:55:15 <athan> edwardk: Heck yeah hahaha, thank you.
09:55:19 <glguy> NickT__: (*) :: Num a => a -> a -> a,   the left and right arguments have to be the same. Double and Int aren't the same
09:55:20 <Fuuzetsu> NickT__: because you're trying to multiple Double ‘x’ by Ints (generated with 1 .. n)
09:55:48 <NickT__> glguy Fuuzetsu: shit I should have thought of that.
09:55:49 <NickT__> Thanks!
09:56:05 <Fuuzetsu> GHC tells you that, just got to read it ;P
09:56:13 <NickT__> Fuuzetsu: It didn't strike me.
09:56:16 <NickT__> Thanks a ton
09:56:19 <Fuuzetsu> np
10:13:25 <barrucadu> edwardk: "This means that for instance, even though there are two ways to derive Ord a :- Eq a", shouldn't that be "Ord a :- Eq [a]", judging from the following explanation?
10:13:38 <edwardk> probably
10:13:41 <edwardk> fixing
10:13:43 <barrucadu> Oh, I see someone else noticed this a few minutes ago
10:15:14 * hackagebot data-kiln 0.1.0.0 - Sculpt mutable recursive data with reference equality; bake it using a data kiln into an immutable lazy structure  http://hackage.haskell.org/package/data-kiln-0.1.0.0 (kwf)
10:16:12 <johnw> edwardk:  good to have you back :-)
10:16:45 <edwardk> johnw: well, had 2 weeks of pretty much doing nothing but talking all day
10:16:48 <edwardk> its exhausting ;)
10:16:53 <edwardk> now i just need to code ;)
10:17:02 <johnw> edwardk: wait, isn't that what you do most days anyway?  :-)
10:17:25 <johnw> oh yeah, forgot about the coding in between
10:17:57 <chrisdone> same thing we do every night, pinky. try to take over the world!
10:18:15 <jfischoff> I did some profiling with thread scope. My program pauses for 50 milliseconds to gc. Why would it take so long to gc, and how can I fix that?
10:18:52 <johnw> try -I0
10:19:06 <johnw> that will disable the idle GC that happens from time to time nothing else is going on
10:19:13 <johnw> although that may have nothing to do with your problem
10:19:24 <jfischoff> it is worth trying
10:19:34 <jfischoff> but it wasn’t idle
10:19:58 <jfischoff> this is during a http profiling session, so it is doing work throughout
10:20:13 <johnw> you could also force GC at low work points, so that there is less work to do in a regular GC
10:20:36 <jfischoff> so this is expected behavior?
10:21:10 <johnw> It all depends, really
10:21:35 <johnw> Were you expecting there to be a minimum length of time that the GC is allowed to run?
10:21:41 <jfischoff> no
10:22:02 <ski> ibid : surely `out' should be "copy-on-out", except possibly when it can be optimized to "by-reference" ?
10:23:25 <DistroX> Hello?
10:23:26 <ski> (e.g. when the actual out parameter wasn't initialized before the call, or when there's no non-local exit (like exceptions) involved)
10:23:33 <johnw> DistroX: hi
10:23:53 * ski stares at DistroX
10:24:00 <DistroX> >_>
10:24:02 <DistroX> <_<
10:24:23 <DistroX> I'm just trying to learn how to program and my ventures have brought me here.
10:24:29 <ski> ok. welcome
10:24:33 <Iceland_jack> DistroX: Great!
10:24:45 <ibid> ski: exactly
10:25:06 <ski> ibid : so .. i take that to mean it isn't "copy-on-out" in C#, then ?
10:25:13 <ibid> ski: yes :)
10:25:14 * hackagebot xml-extractors 0.2.0.0 - Simple wrapper over xml (Text.XML.Light) to extract data from parsed xml  http://hackage.haskell.org/package/xml-extractors-0.2.0.0 (holmisen)
10:25:40 <ibid> ski: it's pass-by-reference with static checking to enforce assignment before use and return
10:25:48 <ski> (or perhaps it's called "copy-out" or "copy-out-on-exit" or something like that, i can't recall exactly)
10:26:04 <DistroX> So far, I've learned the basic syntax of javascript and jquery and I know html and css. I'm just looking for other programmers to work with on things they need help with and maybe a mentor or something if they have free time.
10:26:07 <ibid> ski: pass-by-result is what i've seen used
10:26:19 <ski> ibid : .. but you can get partial updates, with exceptions, yes ?
10:26:37 <ibid> ski: presumably. i don't remember the details too clearly
10:26:42 <Iceland_jack> DistroX: I would be happy to answer questions
10:26:51 <ski> (i'm not talking up updating things via references in the returned value. i'm talking about components directly inside it)
10:27:08 <ski> (s/ up / of /)
10:27:18 <DistroX> Iceland_jack: Thank you if there is any more information I can give to help be more part of the/a community please let me know.
10:27:30 <Iceland_jack> DistroX: Quick note, you can ask lambdabot to evaluate Haskell expressions by prefixing them with "> "
10:27:34 <Iceland_jack> > 5 + 2 * 4
10:27:35 <lambdabot>  13
10:27:47 <Iceland_jack> > "hello" ++ " " ++ "world"
10:27:48 <lambdabot>  "hello world"
10:28:35 <objclassifier> > asdj
10:28:36 <lambdabot>  Not in scope: ‘asdj’
10:29:17 <ski> > let primes = sieve [2 ..]; sieve (p:ns) = p : sieve [n | n <- ns , n `mod` p /= 0] in primes
10:29:19 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:29:19 <DistroX> > "how" ++ " " ++ "are" ++ " " ++ "you?"
10:29:20 <lambdabot>  "how are you?"
10:30:19 <Iceland_jack> DistroX: You can also get the type of an expression with '@ty'.
10:30:19 <Iceland_jack> @ty not (not True)
10:30:20 <lambdabot> Bool
10:30:36 <DistroX> @ty "hello"
10:30:37 <lambdabot> [Char]
10:30:42 <Iceland_jack> Have you installed GHC?
10:30:43 <DistroX> char?
10:30:47 <DistroX> No
10:30:53 <clrnd> :t "lalal"
10:30:54 <lambdabot> [Char]
10:30:54 <Iceland_jack> DistroX: [Char] means a "list of characters"
10:31:07 <DistroX> Ok
10:31:17 <Iceland_jack> "hello" is the same as ['h', 'e', 'l', 'l', 'o']
10:31:20 <Iceland_jack> @ty 'h'
10:31:21 <lambdabot> Char
10:32:00 <objclassifier> :t [[1, 2, 3], [2, 3], []]
10:32:01 <lambdabot> Num t => [[t]]
10:33:27 <DistroX> Is ["","",""] an array?
10:33:29 <ski> > let rot13 = map $ \c -> fromMaybe c (lookup c (zip (alpha0 ++ alpha1) (alpha1 ++ alpha0))); alpha0 = ['a' .. 'm'] ++ ['A' .. 'M']; alpha1 = ['n' .. 'z'] ++ ['N' .. 'Z'] in rot13 "QvfgebK, gung'f v'z svar"
10:33:31 <lambdabot>  "DistroX, that's i'm fine"
10:33:42 <ski> DistroX : it's a list of (empty) strings
10:33:43 <Iceland_jack> DistroX: It's a list of strings
10:34:04 <DistroX> I don't know anything about haskell, obviously.
10:34:08 <Iceland_jack> That's fine
10:34:23 <Iceland_jack> You can start by looking at Learn You a Haskell
10:34:25 <Iceland_jack> @where lyah
10:34:25 <lambdabot> http://www.learnyouahaskell.com/
10:34:31 <Iceland_jack> It's available free online
10:34:54 <ski> @where tryhaskell
10:34:54 <lambdabot> http://tryhaskell.org/
10:34:59 <ski> DistroX : you can try that ^ first
10:35:20 <ski> you don't need to install anything (well, you need a capable browser) to use that
10:35:43 <DistroX> I'm using the latest version of firefox.
10:35:47 <ski> should work
10:35:50 <DistroX> I believe
10:35:53 <DistroX> Ok
10:36:29 <DistroX> Let me just ask, what were the benefits of learning haskell for you?
10:36:34 <ski> (but LYAH is a good learning resource)
10:36:55 <ski> DistroX : changing the way i think about programs
10:37:35 <ajcoppa> DistroX: welcome! if you're interested in learning haskell, there's a channel called #haskell-beginners that has a fantastic guide with recommended learning resources to get you started
10:37:35 <ski> .. by showing alternative ways to approach programming
10:37:43 <Ferdirand> the main benefit is that then you can use Haskell !
10:39:52 <DistroX> Thank you for your support ski, ajcoppa, Ferdirand.
10:39:57 <ajyasgar> come join us in haskell-beginners yes
10:40:43 <ski> DistroX : as Ferdirand says, Haskell is a reasonably nice language to program in (all languages have some less-than-desirable things. Haskell happens to have quite few of them, imho, especially when compared to other commonly and semi-commonly used languages)
10:40:50 <ski> DistroX : are you also new to IRC ?
10:41:28 <ajyasgar> the major benefit of learning haskell for me is that programming can and should be more like doing math, and haskell does a good job of getting there, which is a Very Good Thing
10:44:50 <Denommus> c_wraith: it's "bad", but without tuples or return multiple values, reference passing is useful
10:46:22 <ski> DistroX : anyway, if you're going to be hanging around on IRC (and why not ? #haskell can be a good, nice, and helpful place to learn. i haven't been to #haskell-beginners much, but i have no reason to believe it would be worse) you might want to be using a proper IRC client
10:46:38 <DistroX> ski: I'm not new to irc, but I had a cringe to get on irc and try one more time to find a group of programmers willing to work with me, so I just jumped on freenode instead of using a client.
10:46:45 <DistroX> I usually use weechat.
10:46:50 <ski> ok, fine
10:47:15 <Iceland_jack> #haskell-beginners can be more dogmatic in their teaching style, but both channels are fine
10:47:17 <DistroX> I guess I shouldn't go into so much detail.
10:47:36 <ajyasgar> it's nice to have a personality
10:47:41 <ski> (because IRC newbies usually need to be told a bit more about how IRC works, for them to be able to use it effectively (e.g. not leaving too early))
10:47:42 <c_wraith> Denommus: well..  Only in the sense that when you remove all the convenient ways of doing something (tuples or multiple returns) you're stuck with only bad approaches, like one-off classes and out parameters.
10:48:05 <c_wraith> Denommus: and I'm not sure which of those bad approaches is worse
10:49:06 <ski> c_wraith : .. i don't think `out' parameters are inherently bad, though
10:50:14 * hackagebot lambdaLit 0.1.0.1 - ...  http://hackage.haskell.org/package/lambdaLit-0.1.0.1 (faleidel)
10:51:17 <c_wraith> ski: You don't think an irregular additional return mechanism is an inherently bad thing?
10:52:19 <ski> c_wraith : consider Mercury. there `:- mode append(in,in,out) is det.' specifies that you can call `append([0,1,2],[3,4],List)' (getting `List = [0,1,2,3,4]' as answer)
10:52:45 <DistroX> ski: Will you tell me what you would have told me if I would have said I was new to irc.
10:53:00 <ski> caumeslasal : and `:- mode append(in,out,in) is semidet.' specifies that you can call `append([0,1,2],Suffix,[0,1,2,3,4])' (getting `Suffix = [3,4]' as answer)
10:53:03 <ski> er
10:53:05 <ski> c_wraith ^
10:54:39 <weasel__> c_wraith: out parameters would help a lot if you were say writing a DSL for very low-memory environments.
10:55:05 <weasel__> c_wraith: I believe you could push it all the way to static knowledge of your stack sizes pretty easily
10:55:06 <ski> c_wraith : `append(Front,Back,List)' describes the *relation* that the concatenation of `Front' and `Back' is equal to `List'
10:55:52 <c_wraith> weasel__: out parameters as operational behavior are sometimes useful because they let you specify memory use more exactly in cases when it matters.  But as a language feature, I only see them as in the way of comprehending what code does.
10:55:56 <ski> c_wraith : this relation can be used in different *modes*, to solve for parameters, given values for others, for different patterns of assigning "in" and "out" roles to the parameters
10:56:32 <ski> c_wraith : .. and it's the same source code which can be run "forwards, backwards, and sideways", each mode isn't implemented separately
10:56:36 <weasel__> ski: so it's append (f,b : List) ->(l : List ** l = f++b)?
10:56:49 <c_wraith> ski: ah, that's more interesting.  That's defining a relation where any number of unknowns can be solved for if the rest of the bits are known.
10:57:10 <weasel__> ski: with idris types
10:57:32 <ski> weasel__ : well, i don't think Idris can run things backwards ?
10:59:35 <ski> c_wraith : aye, though sometimes the implementation places restrictions on the "any number of unknowns" part. so you can specify exactly which modes are supported (and this is statically checked by the compiler, not allowing to use any mode not specified (or implied by specified) modes)
11:00:14 * hackagebot constraints 0.4.1.1 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.4.1.1 (EdwardKmett)
11:00:17 <weasel__> ski: no, I wrote it before I saw that message. I was attempting to capture the behavior that it gives you a list which is equal to the two arguments concated.
11:01:30 <ski> DistroX : well, stuff like "don't ask a question and then leave too soon (where leaving within half an hour is probably too soon)" and "don't ask to ask" and "don't ask whether anyone knows anything about X (or variants of this)"
11:02:18 <DistroX> ski: Thanks, I was curious.
11:02:55 <ski> DistroX : oh, and "don't assume that anyone in a channel is actually paying attention to IRC atm. some people stay logged in to IRC all the time. sometimes people answer questions that have been asked hours (or days) earlier"
11:03:13 <ski> weasel__ : ok
11:04:50 <DistroX> ski: I understand.
11:04:53 <Aruro> what is last symbol in each line after  lines command? i can not make parsec to handle it properly
11:05:19 <Aruro> it seems to perceive '\n' at the end of string like '\\'
11:05:37 <ReinH> Aruro: That can't be so.
11:06:01 <Aruro> in parsec i have last parser to be char '\\'
11:06:27 <Aruro> then each line in interact command i end with \n
11:06:28 <ski> DistroX : .. usually with more rationale about what they mean, and why IRC custom is like this
11:06:35 <Aruro> and it seems to work
11:06:53 <Aruro> i can not make parsec to work only with Enter
11:07:17 <ReinH> > lines "foo\nbar\n"
11:07:18 <lambdabot>  ["foo","bar"]
11:07:36 <Aruro> so there is nothing at the end?
11:07:50 <Aruro> i should provide him stopper myself?
11:07:50 <ReinH> Correct.
11:07:50 <Denommus> c_wraith: Java is completely bad, C# is still terrible, but it's a lot... "less bad" than Java
11:08:05 <ski> DistroX : anyway, i suggest you keep joining #haskell in addition to #haskell-beginners, even if you're mostly (at least initially) going to keep attention to the latter
11:08:05 <Denommus> c_wraith: I wouldn't migrate from Haskell to it, of course
11:08:09 <Aruro> ok ty
11:08:14 <c_wraith> Denommus: I guess I can accept that
11:08:27 <Aruro> is there anybody in haskell beginners?
11:08:36 <Aruro> never heard of this irc :)
11:08:41 <vanila> is there something better than C# you could use instead?
11:09:17 <ski> Aruro : it would appear so
11:09:28 <Denommus> c_wraith: the only three other languages that makes some things I wanted Haskell to do similar are Common Lisp, because of macros, Rust, because of the memory model and borrowing rules, and OCaml, because of the module system
11:09:35 <Denommus> vanila: F#?
11:09:48 <vanila> ive heard good about F#
11:09:50 <vanila> have not used it
11:10:00 <ski> F# unfortunately doesn't have the ML module system
11:10:11 <Denommus> vanila: it's a worsened OCaml. It doesn't have the same module system
11:10:12 <vanila> are there any small compilers written in haskell or ocaml I could read and learn from? something < 1000 lines
11:10:27 <ski> if you have to be on .NET, F# could be a nice option
11:10:31 <johnw> vanila: there's ermine
11:10:45 <johnw> vanila: when you say compiler, do you want code generation?
11:10:57 <vanila> i've read ermine a bit, it does STG interpreter with lots of unsafePerformIO :/
11:10:59 <Denommus> it would be nice if one started a compiler for OCaml targetting .NET
11:11:31 <c_wraith> I'm not sure how well that'd work.  the OCaml module system doesn't play nicely with .NET's object model, iirc
11:12:51 <Denommus> c_wraith: well, Scala's objects are somewhat similar to OCaml modules, and it works on top of the JVM
11:24:16 <zmbmartin> Is there a way to get what values/keys are missing or wrong when using decode with aeson?
11:30:13 <DSALNASS> I'm currently reading learnyouahaskell.com/modules is the purpose of this section for me to memorize all these functions that he demonstrates in the chapter?
11:30:14 * hackagebot moan 0.1.0.0 - Language-agnostic analyzer for positional morphosyntactic tags  http://hackage.haskell.org/package/moan-0.1.0.0 (vjeranc)
11:30:31 <DSALNASS> Just seems like a ton of them to go through
11:31:31 <vanila> don't memorize them
11:31:38 <vanila> you can look back at the page if you need to
11:37:00 <johnw> DSALNASS: learning how to search for the functions you want by type is the best way to access the functionality that's in the standard libraries
11:38:58 <FourLeav> Should I learn bash before trying to learn haskell on a mac?
11:39:19 <johnw> FourLeav: you mean the bash scripting language?  Or just how to use your shell?
11:39:26 <FourLeav> Both
11:39:32 <vanila> dont learn bash
11:39:35 <johnw> I think you can get by without learning the scripting language just fine
11:40:26 <Dashkal> hrm, reminded that it's probably time to learn zsh
11:40:39 <athan> DSALNASS: They're just practical. You'll find uses for them :)
11:40:43 <FourLeav> Say I learn languages pretty quickly, would it be worth a week of work to get to know bash scripting better though?
11:40:50 <johnw> I gave up on learning Zsh.  Mainly because bash is everywhere,  and I got tired of all the tiny little differences
11:40:52 <vanila> no
11:40:57 <FourLeav> o
11:41:00 <johnw> FourLeav: learn how to write system scripts in Haskell I say
11:41:02 <hiptobecubic> FourLeav, i vote yes.
11:41:25 <FourLeav> System scripts can be run in haskell?
11:41:29 <Dashkal> I learned bash, but only with the motivation that the more languages I learn, the more I can think of problems.  Bash was an excercise in ways to not develop a language...
11:41:32 <athan> FourLeav: Haskell first, practicality later :P
11:41:35 <johnw>  although I do end up writing plenty of little bash scripts here and there
11:41:38 <johnw> FourLeav: sure they can
11:41:51 <hiptobecubic> learning to use your shell and learning bash aren't different
11:42:08 <johnw> hiptobecubic:  but there are a lot of aspects to bash that you never need to learn from the shell, like doing regular expression matching
11:42:18 <hiptobecubic> FourLeav, learning the basics of bash will pay for itself very very quickly. Don't worry about the complicated cases because you almost certainly shouldn't be using bash then anyway
11:42:22 <johnw> if [[ $foo =~ hello ]]; then ...
11:42:38 <FourLeav> ty
11:43:09 <FourLeav> I know php and python right now, should I jump get decent at any other languagues before haskell?
11:43:22 <vanila> you can start with haskell
11:43:35 <Iceland_jack> FourLeav: You'll be fine
11:43:40 <hiptobecubic> FourLeav, forget php and fill that part in with haskell
11:44:23 <johnw> FourLeav:  I would think that starting with Haskell before any of the others is a good way to go
11:44:34 <FourLeav> I get an odd feeling yall like haskell
11:44:40 <johnw> imagine that
11:44:43 <Iceland_jack> Perish the thought
11:44:53 <FourLeav> inconcievable!
11:44:54 <johnw> funny,  they even named an IRC channel after us
11:46:18 <FourLeav> Does haskell have any unique cryptoanalytic uses at a high level of programming?
11:46:32 <hiptobecubic> I'm not sure that question makes any sense.
11:48:06 <FourLeav> hm
11:48:19 <vanila> FourLeav, cryptol does
11:48:38 <Iceland_jack> FourLeav: I'm actually working on an embedded DSL in Haskell for cryptographic algorithms, similar to Cryptol
11:48:49 <clrnd> FourLeav, haskell is quite different to other languages. between PHP, Python and Ruby there are not many differences besides syntax
11:48:53 <ReinH> Iceland_jack: nice :)
11:49:55 <ReinH> I tend to write shell scripts in bash and then migrate them to Haskell once they reach a certain level of coplexity.
11:52:43 <FourLeav> I ask about haskell because I’m looking for a computer language I can devote a lot of time to mastering, which will have great value as a general-use programming language.
11:53:19 <Sev3x> Learn Malbolge and be 3l33t brah
11:53:26 <FourLeav> orly?
11:53:33 <Sev3x> mmhm
11:53:42 <markus3> hi, irc!
11:53:49 <Sev3x> My name isnt IRC
11:53:55 <dv-_> FourLeav: to do what with?
11:53:59 <weasel__> FourLeav: Haskell is in the top two for hardest (as in the most material) to master general purpose language, so it's a good choice.
11:54:22 <markus3> so, here I am with another question about optparse-applicative -- is there a way to have an option with a default value?
11:54:52 <markus3> sorry Sev3x, didn't mean you specifically, though hi to you too :)
11:55:05 <Sev3x> Hahha, just being funny. Hello to you as well
11:55:12 <ReinH> weasel__: What's the other one?
11:55:14 <tolt> I wish there was a way to display the filesystem graphs for a package..
11:55:18 <tolt> Does that exists at all?
11:55:30 <ReinH> tolt: "filesystem graphs"?
11:56:13 <tolt> ReinH: I mean when I look at a package I want to be able to see it's dependencies as a tree
11:56:31 <markus3> tolt, I've missed that too
11:57:01 <markus3> theres the revdeps web front somewhere. don't remember if it had the subdependencies too
11:57:17 <FourLeav> dv-_, Well, in the longterm, I want to develop a program that excels at analyzing physics problems and their many daunting variables.
11:57:27 <ReinH> tolt: A quick search found https://hackage.haskell.org/package/graphmod and https://hackage.haskell.org/package/cabal-graphdeps but I've never used them
11:57:52 <tolt> Huh I wasn't finding those
11:57:57 <tolt> I guess I was searching too specifically
11:58:21 <markus3> tolt, ReinH, graphmod I tried maybe a few years ago -- it worked but generated *huge* images
11:58:35 <tolt> Yeah. graphmod looks awesome.
11:58:36 <dv-_> FourLeav: for high performance, you'd probably be better off learning C++
11:58:37 <markus3> i.e some packages have huge transitivie closures
11:58:55 <ReinH> markus3: true enough
12:00:56 <markus3> ReinH, the big picture is not graphmod's fault, but of the package you queried, and an image is probably not the best output
12:01:10 <FourLeav> dv-_, I thought about writing my own language for the same purpose, but that seems at tad ambitious at the moment. I don’t necesarily need high performance, just a language with few a lot of freedom and functionality
12:01:15 <tolt> ReinH: graphmod visualizes module dependencies not package dependencies but it's still really cool.
12:01:24 <markus3> ReinH, I think a list (maybe indented list), and using grep would be a good choice
12:01:26 <ReinH> I'm not sure why Haskell is a bad choice for high performance.
12:01:45 <ReinH> And it's definitely a better choice for reasoning about mathematical problems than C++
12:01:45 <weasel__> ReinH: C++, although I don't think the complexity there is necessary.
12:02:08 <ReinH> weasel__: Sure, you could just use C ;)
12:02:43 <athan> Why does hlint want me to use mapM_ instead of mapM? And moreso that it's an _error_?
12:02:52 <FourLeav> Does the term “function-chain” ring a bell with anyone?
12:03:18 <athan> FourLeav: where did you see it?
12:03:26 <weasel__> ReinH: C can be beautiful but if you make one bad call when designing your data structures it's a mess.
12:03:47 <weasel__> FourLeav: signal processing context?
12:04:23 <purelazy> function composition context
12:05:10 <ajyasgar> a.b.c.d.e.f.g chain?
12:05:16 <FourLeav> So it is a real term in the computer-science field? Anyways, it’s just something I picked up in a discussion on another chan.
12:05:54 <purelazy> I rarely hear of the term "function chain"
12:06:04 <geekosaur> athan, I'd have to see what it is complaining about, but usually it means hlint thinks you are throwing away the result. note that hlint doesn't actually understand code but relies on heuristics, so it can be confused about what's going on
12:06:08 <purelazy> Or never even
12:06:15 <ski> athan : not sure why it has some of the suggestions as "errors". if you're not using the computed list of results, then `mapM_' is probably more efficient than `mapM'
12:06:15 <Iceland_jack> Method chaining is often used
12:06:54 <ReinH> It is also obviously better than void $ mapM ...
12:07:02 <ReinH> or _ <- mapM ...
12:07:05 <purelazy> composition is the mathematical term, generally speaking
12:07:36 <athan> ski, geekosaur: Thank you :)
12:07:53 <FourLeav> It was used in the context to describe a set of derivative-antiderivatives, which formed a logical chain, linked in parallel with a static set of variables.
12:08:27 <purelazy> probably composition, but I have no idea
12:08:28 <FourLeav> But from what I hear, that isn’t an application or term common in programming?
12:08:28 <athan> FourLeav: That's not a technical term :) just a description
12:09:16 <FourLeav> oki
12:09:20 <vamega> Hi, is there a safe version of (!!) ?
12:09:41 <vamega> I've looked at hoogle, but not really found anything that seemed like it would work
12:10:15 <chpatrick> vamega: what do you need it for?
12:10:15 * hackagebot groundhog 0.7.0.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.7.0.1 (BorisLykah)
12:10:17 * hackagebot groundhog-sqlite 0.7.0.1 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.7.0.1 (BorisLykah)
12:10:19 * hackagebot groundhog-postgresql 0.7.0.1 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.7.0.1 (BorisLykah)
12:10:20 <ClaudiusMaximus> > listToMaybe (drop 5 "abcdef")  -- or the 'safe' package on hackage (it has 'atMay')
12:10:21 * hackagebot groundhog-mysql 0.7.0.1 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.7.0.1 (BorisLykah)
12:10:21 <lambdabot>  Just 'f'
12:10:28 <ClaudiusMaximus> > listToMaybe (drop 7 "abcdef")  -- or the 'safe' package on hackage (it has 'atMay')
12:10:29 <lambdabot>  Nothing
12:10:43 <ReinH> vamega: There isn't one, which probably has to do with how bad lists are as a random access data structure.
12:10:50 <purelazy> vamega: I don't think List are inherently safe
12:10:57 <ski> FourLeav : .. i suppose you've already seen <http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/> ?
12:10:58 <ReinH> vamega: Perhaps you want an IntMap instead
12:11:22 <purelazy> vamega: They are inherently unsafe
12:11:24 <ReinH> ski: That is a blog post of epic proportions
12:11:32 <vamega> I have an alphabet defined as a string.
12:11:33 <FourLeav> ski, no i haven’t but looks like a good read
12:11:42 <ReinH> purelazy: Why are lists inherently unsafe?
12:11:42 <vamega> And I was using the index of that as part of a hash functionl
12:12:07 <chpatrick> vamega: if you put it in a Vector you'll get O(1) lookup and a safe version
12:12:12 <Iceland_jack> purelazy: What does that even mean
12:12:20 <ski> @type (listToMaybe .) . take
12:12:21 <lambdabot> Int -> [a] -> Maybe a
12:12:31 <ski> vamega ^ ?
12:12:32 <purelazy> If safe means cannot crash, then head []
12:12:34 <ReinH> ski: not bad
12:12:47 <Iceland_jack> purelazy: That's not a property of lists..
12:12:50 <ReinH> purelazy: That has nothing to do with lists
12:12:52 <chpatrick> purelazy: it's not the list that's partial, it's head
12:12:54 <vamega> I think a Map of Char -> Int would work well for me.
12:13:10 <chpatrick> vamega: but that's the other way around no?
12:13:16 <ReinH> I can write an "unsafe" function for literally any type.
12:13:29 <ReinH> That will behave exactly like head []
12:13:51 <ReinH> Some functions are partial.
12:13:57 <purelazy> Oh OK, I guess I was think about "head"
12:14:00 <vamega> chpatrick -> When you say O(1) lookup, you mean lookup by index right?
12:14:23 <chpatrick> vamega: yeah
12:14:35 <chpatrick> vamega: !! is indexing though
12:14:52 <chpatrick> vamega: do you mean findIndex?
12:14:56 <ReinH> vamega: how do you populate your alphabet's list of characters?
12:15:10 <vamega> I defined a string.
12:15:15 * hackagebot amazonka-core 0.1.0 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.1.0 (BrendanHay)
12:15:17 * hackagebot amazonka 0.1.0 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.1.0 (BrendanHay)
12:15:19 * hackagebot amazonka-autoscaling 0.1.0 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.1.0 (BrendanHay)
12:15:21 * hackagebot amazonka-cloudformation 0.1.0 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.1.0 (BrendanHay)
12:15:23 * hackagebot amazonka-cloudfront 0.1.0 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.1.0 (BrendanHay)
12:15:23 <vamega> alphabet = "abcdefghijklm"
12:15:53 <vamega> Give me a second.
12:16:11 <vamega> I need to think about what I actually need for what I'm doing.
12:16:18 <chpatrick> vamega: are you looking for a char given an int or the other way around?
12:16:33 <ReinH> vamega: That is usually a good idea
12:17:27 <ReinH> You'd probably do pretty well to use ski's solution and memoize it, though. Although I think ski meant drop rather than take.
12:19:40 <nitrix> Hi, is writeIORef strict?
12:20:00 <nitrix> Or does that have the same problem as modifyIORef and creates a space leak?
12:20:25 * hackagebot amazonka-cloudsearch 0.1.0 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.1.0 (BrendanHay)
12:20:27 * hackagebot amazonka-cloudsearch-domains 0.1.0 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.1.0 (BrendanHay)
12:20:29 * hackagebot amazonka-cloudtrail 0.1.0 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.1.0 (BrendanHay)
12:20:31 * hackagebot amazonka-cloudwatch 0.1.0 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.1.0 (BrendanHay)
12:20:33 * hackagebot amazonka-cloudwatch-logs 0.1.0 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.1.0 (BrendanHay)
12:22:21 <ski> ReinH : oops, yes i did :)
12:23:02 <ski> nitrix : i don't think it's strict ?
12:25:34 * hackagebot amazonka-codedeploy 0.1.0 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.1.0 (BrendanHay)
12:25:36 * hackagebot amazonka-cognito-identity 0.1.0 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.1.0 (BrendanHay)
12:25:38 * hackagebot amazonka-elasticache 0.1.0 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.1.0 (BrendanHay)
12:25:40 * hackagebot amazonka-elasticbeanstalk 0.1.0 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.1.0 (BrendanHay)
12:25:42 * hackagebot amazonka-elastictranscoder 0.1.0 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.1.0 (BrendanHay)
12:30:09 <ReinH> Haha such amazonka update wow
12:30:44 * hackagebot amazonka-elb 0.1.0 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.1.0 (BrendanHay)
12:30:46 * hackagebot amazonka-emr 0.1.0 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.1.0 (BrendanHay)
12:30:48 * hackagebot amazonka-iam 0.1.0 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.1.0 (BrendanHay)
12:30:50 * hackagebot amazonka-importexport 0.1.0 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.1.0 (BrendanHay)
12:30:52 <johnw> and it keeps coming...
12:30:52 * hackagebot amazonka-kinesis 0.1.0 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.1.0 (BrendanHay)
12:31:08 <johnw> ERC filter engaged
12:31:18 <joeyh> this must be why spj said to avoid success
12:31:27 <MP2E> haha
12:32:02 <ReinH> I told Brendan that his amazonka updates were flooding #haskell... I wasn't really joking...
12:32:45 <ReinH> They're also flooding the hackage documentation generation queue
12:32:46 <nitrix> Is it common to see an IO definition in a where clause and things chained with >>= even inside the io monad?
12:32:47 <ReinH> Good times
12:33:02 <ReinH> nitrix: Do you mean inside a do block?
12:33:10 <nitrix> sorry, do block yes
12:33:11 <ReinH> nitrix: It's a bit unusual but I've done it myself a few times
12:33:21 <ReinH> I would generally try to avoid it
12:33:30 <nitrix> where   tailResources = readIORef $ tailBlock hyperspace
12:33:51 <ReinH> The >>= inside do notation, I mean.
12:34:03 <bennofs> nitrix: I sometimes do that if I don't like to invent yet another variable name (>>= inside do)
12:34:07 <ReinH> Giving meaningful names to thing with a where block or let statement seems fine
12:34:27 <ReinH> On the other hand, avoiding naming something by using >>= sometimes seems fine too
12:34:30 <ReinH> per bennofs
12:34:50 <nitrix> Well thats my question. It already has a perfectly fine name from the where clause, I don't want an extra binding with <-
12:35:03 <ReinH> Haskell is one of the few languages where you can gain readability with less descriptive or even no variable names...
12:35:11 <Modius> "Thinking Functionally in Haskell" by Richard Bird <-- where does this book land in the grand scheme of things compared with LYAH, RWH, Or Hutton/Programming In Haskell?
12:35:15 <ReinH> nitrix: seems fine
12:35:22 <ReinH> Modius: Far far better than any of them
12:35:38 <ReinH> Focused on the principles of functional programming and Haskell rather than library usage, etc
12:35:54 * hackagebot amazonka-kms 0.1.0 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.1.0 (BrendanHay)
12:35:56 * hackagebot amazonka-lambda 0.1.0 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.1.0 (BrendanHay)
12:35:58 * hackagebot amazonka-opsworks 0.1.0 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.1.0 (BrendanHay)
12:36:00 * hackagebot amazonka-rds 0.1.0 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.1.0 (BrendanHay)
12:36:02 <ReinH> Closest to Hutton or Bird's own previous "Introduction to FP using Haskell"
12:36:02 * hackagebot amazonka-redshift 0.1.0 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.1.0 (BrendanHay)
12:36:10 <nitrix> LYAH was all about library usage. It gets tiring after a while with all the examples.
12:36:26 <Modius> ReinH:  Is it up-to-date of anachronisms/assuming all the latest conventions?
12:36:29 <nitrix> I'd rather learn the building blocks and come to the conclusion of how to assemble them myself.
12:36:33 <ReinH> Modius: It came out last month.
12:36:55 <ReinH> It doesn't make much use of modern GHC features, but it isn't anachronistic at all
12:36:57 <Modius> ReinH:  Fair enough thanks - was just wondering if it was some sort of reprint of his prior book or new.
12:37:07 <ReinH> Modius: It's a rewrite of Intro to FP using Haskell
12:37:13 <ReinH> Which is the best FP book I've ever read
12:37:15 <ReinH> So.
12:37:36 <ReinH> Books like that age much better than books like RWH anyway
12:37:45 <Modius> Fair enough, ReinH - I was on the brink of ordering, you nudged it over the line thanks.
12:38:25 <ReinH> Libraries might be out of date in 6 months. Algebra and logic haven't become out of date in over a hundred years.
12:38:32 <ReinH> Modius: seems good.
12:38:58 <ReinH> I'd say most Haskell programmers would get a lot out of that book, even experienced ones.
12:39:05 <ReinH> Also the exercises are wonderful and include answers.
12:39:46 <Modius> ReinH: I'm all over the place.  Lot of paid time in F# now, I do my C# functional, doing Meijer's class to fill in little gaps in my haskell.  I was hoping for a bit of mid-level catering in the book.
12:41:04 * hackagebot amazonka-route53 0.1.0 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.1.0 (BrendanHay)
12:41:06 * hackagebot amazonka-route53-domains 0.1.0 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.1.0 (BrendanHay)
12:41:08 * hackagebot amazonka-s3 0.1.0 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.1.0 (BrendanHay)
12:41:10 * hackagebot amazonka-sdb 0.1.0 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.1.0 (BrendanHay)
12:41:12 * hackagebot amazonka-ses 0.1.0 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.1.0 (BrendanHay)
12:42:07 <ReinH> Modius: Sounds good then.
12:42:26 <erikd> anyone have links that show the size of the haskell community and its growth rate? for $management
12:43:00 <adamse> erikd: some stats on #haskell: http://ircbrowse.net/haskell
12:44:39 <erikd> thanks adamse
12:44:54 <ski> erikd : also not everyone involved with Haskell in on here (or in sibling channels)
12:45:19 <erikd> there was thing recently when showed how other communities were talking about haskell. anyone remember that?
12:45:40 <pakino> saaalve!!!
12:45:42 <erikd> i wasn't specifically talking about irc. i interested in a much broader sense.
12:45:52 <pakino> !list
12:45:52 <monochrom> pakino: http://okmij.org/ftp
12:46:14 * hackagebot amazonka-sns 0.1.0 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.1.0 (BrendanHay)
12:46:16 * hackagebot amazonka-sqs 0.1.0 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.1.0 (BrendanHay)
12:46:18 * hackagebot amazonka-storagegateway 0.1.0 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.1.0 (BrendanHay)
12:46:20 * hackagebot amazonka-sts 0.1.0 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.1.0 (BrendanHay)
12:46:22 * hackagebot amazonka-support 0.1.0 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.1.0 (BrendanHay)
12:46:25 <ski> erikd : perhaps <https://www.haskell.org/haskellwiki/Haskell_Communities_and_Activities_Report> would also be useful
12:46:51 <ski> pakino : salve soror/frater
12:48:24 <erikd> and http://langpop.com/
12:51:24 * hackagebot amazonka-swf 0.1.0 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.1.0 (BrendanHay)
12:51:26 * hackagebot propellor 1.2.1 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-1.2.1 (JoeyHess)
12:52:10 <ski> nitrix : in `do', sometimes the pattern `result <- foo x =<< bar y' (or `result <- foo x . baz z =<< bar y' or `result <- (foo x <=< quux i) =<< bar y' or some other variant) is nice and readable
12:52:52 <amf> how do i add the code that would be produced when you add Read to deriving for newtype? i assumed instance Read Somenewtype would be enough (Somenewtype has only one Int32 field)
12:53:32 <ski> amf : write it by hand ?
12:53:40 <ski> amf : how is `Somenewtype' defined ?
12:53:50 <Iceland_jack> amf: -ddump-deriv?
12:54:00 <amf> its actually: newtype MaxBytes = MaxBytes Int32 deriving (Show, Eq, Num, Serializable, Deserializable)
12:54:12 <nitrix> Can you pattern match a list with x:xs idiom where x is a tuple?
12:54:25 <nitrix> As in, (p1,p2):xs ?
12:54:26 <Iceland_jack> ghci> :set -ddump-deriv
12:54:26 <Iceland_jack> ghci> import Data.Int
12:54:26 <Iceland_jack> ghci> newtype MaxBytes = MaxBytes Int32 deriving Read
12:54:28 <johnw> sure
12:54:32 <johnw> nitrix: ^
12:54:47 <Iceland_jack> amf: that should print the derived definition
12:54:51 <nitrix> johnw: I get a parse error
12:55:05 <johnw> share
12:55:34 <Iceland_jack> > let ((p1, p2):xs) = [(1, 10),(2,20)] in [p1, p2]    -- nitrix
12:55:35 <lambdabot>  [1,10]
12:55:57 <amf> Iceland_jack: very cool! ill use that until i can get the library updated. thanks!!
12:56:04 <nitrix> Ah there we go. Needed the parentheses.
12:56:11 <ski>   instance Read MaxBytes
12:56:16 <ski>     where
12:56:50 <ski>     readsPrec p = readParen (p > 10) $ \s0 -> [(MaxBytes n,s) | ("MaxBytes",s1) <- lex s0,(n,s) <- readsPrec 11 s1]
12:56:58 <ski> amf : something like that, iirc
12:57:42 <ski> > let (p1,p2):xs = [(1,10),(2,20)] in [p1, p2]  -- even without the brackets
12:57:44 <lambdabot>  [1,10]
12:57:47 <erikd> ski: this is the one i was thinking about https://github.com/Dobiasd/programming-language-subreddits-and-their-choice-of-words/blob/master/README.md
12:57:49 <ski> nitrix ^
12:58:02 <Iceland_jack> Yes. But you need parentheses in function definitions ski, I assumed that that was the issue
12:58:04 <amf> ski: neat. saved the snippet away for later
12:58:38 <ski> Iceland_jack : could be
12:59:04 <Iceland_jack> nitrix: This will not work:
12:59:04 <Iceland_jack>     foobar (p1,p2):xs = ...
12:59:04 <Iceland_jack> even though:
12:59:04 <Iceland_jack>     let (p1, p2):xs = ...
12:59:07 <Iceland_jack> will
12:59:13 <Iceland_jack> Well nitrix said: <nitrix> Ah there we go. Needed the parentheses.
12:59:48 <Iceland_jack> List pattern matching is such a common source of confusion, it would be nice if Haskell had Rust's syntax
13:00:02 <ski> amf : it can be useful to have a basic understanding of how `showsPrec',`readsPrec' work, and how their accompanying helper operations like `showChar',`showString',`showParen',`readParen',`lex' are used
13:00:27 <ski> Iceland_jack : which is ?
13:00:44 <Iceland_jack>     foobar [(p1,p2), xs...] = ...
13:00:44 <Iceland_jack> Something like that
13:00:50 <ski> ok
13:01:08 <Iceland_jack> The whole (:) business trips people up
13:01:10 <ski> Prolog and Erlang has `[(p1,p2) | Xs]'
13:01:24 <ski> (with possibly more than one element to the left of `|')
13:01:39 <ski> (well, it might be `||' in Erlang. but it's basically the same thing)
13:01:48 <Iceland_jack> Yes I'd say that's also preferable since at least you keep the list syntax
13:01:55 <ski> `:' is just an infix operator
13:01:58 <schell> is there a way to get around creating a cycle in a type synonym, without using a newtype wrapper?
13:02:08 <schell> for instance my type is type Varying a b = a -> (b, Varying a b)
13:02:15 <Iceland_jack> I've seen so many people use [x,y] to match the first two elements of a list of length 2+
13:02:17 <ski> just like you write `f (a + b)' you write `g (x : xs)'
13:02:35 <ski> that applies both in expressions and in patterns
13:02:43 <rgrinberg1> are there any good examples of using listt done right without io?
13:02:57 <Iceland_jack> Are you directing that to me ski?
13:03:08 <ski> Iceland_jack : if you want to
13:03:11 <Iceland_jack> :)
13:03:28 <chpatrick> schell: it doesn't really make sense with a type synonym since it's just substituted
13:03:37 <chpatrick> schell: if it was recursive you'd get an infinite type
13:03:55 <schell> chpatrick: indeed that seems like the problem
13:04:08 * ski usually tries to emphasize that the basic shape of a non-empty list is `x : xs' (not `(x : xs)')
13:04:16 <chpatrick> schell: you need to give it a name so that you can refer to it
13:04:19 <chpatrick> schell: with newtype :)
13:04:41 <chpatrick> schell: you could also use Fix
13:04:51 <schell> chpatrick: yes, thanks :) … ah! fix!
13:04:58 <schell> i need to properly learn fix
13:05:10 <schell> it’s simple but still mind bending
13:05:15 * hackagebot distributed-process-supervisor 0.1.1 - Supervisors for The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-supervisor-0.1.1 (TimWatson)
13:05:16 <ski> note that `Fix' is distinct from (but related to) `fix'
13:05:22 <chpatrick> it doesn't really help you for types
13:05:27 <ski> > fix error
13:05:28 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
13:05:32 <schell> are there any good articles on the two?
13:05:35 <clrnd> lol!
13:05:36 <Eduard_Munteanu> LOL, that language comparison is interesting.
13:05:42 <schell> *recommended articles?
13:05:44 <ski> > fix show  -- is another one
13:05:46 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
13:06:23 <ski> schell : hm, i'm not sure
13:06:36 <ski> also i'm not sure if you're asking about how to use it, or how to implement it
13:06:39 <clrnd> > fix (+)
13:06:40 <lambdabot>  Occurs check: cannot construct the infinite type: a ~ a -> a
13:06:40 <lambdabot>  Expected type: a -> a
13:06:40 <lambdabot>    Actual type: a -> a -> a
13:06:45 <clrnd> > fix (+1)
13:06:49 <lambdabot>  mueval-core: Time limit exceeded
13:06:49 <ski> > fix (0 *)
13:06:50 <schell> ski: mostly how to use it
13:06:53 <lambdabot>  mueval-core: Time limit exceeded
13:07:03 <chpatrick> :t ContT fix
13:07:04 <lambdabot> ContT r m (m r)
13:07:18 <begriffs> I've got a parsing question. I want to take a string like 'Foo: "abc"; Bar: "123"; Baz: "xyz"' and assign the values (abc, 123, xyz) into a data structure. However Foo, Bar, Baz may occur in any order, or not at all. Does Parsec have a way to describe this situation?
13:07:24 <schell> conceptually i know it calls a function on that function recursed but that’s about when my brain stops
13:07:49 <chpatrick> schell: it gives a function a name it can use to recurse
13:07:57 <schell> ah
13:08:53 <chpatrick> so instead of foo = "oh baby "  ++ foo you can do fix $ \foo -> "oh baby "  ++ foo
13:09:07 <iLike> begriffs, you mean like choice?
13:09:10 <ski> schell : my "repaste of PoorManDebug" in 2009-09-30 (originally from some years before, i can't recall exactly) at <http://lpaste.net/10060> has one example of how to use the idea creatively to automagically insert extra book-keeping inbetween recursive calls
13:09:14 <chpatrick> > fix $ \foo -> "oh baby "  ++ foo
13:09:16 <lambdabot>  "oh baby oh baby oh baby oh baby oh baby oh baby oh baby oh baby oh baby oh ...
13:09:58 <ski> > (`fix` 5) $ \fact n -> if n == 0 then 1 else n * fact (n - 1)
13:10:00 <lambdabot>  120
13:10:11 <begriffs> iLike: or maybe I shouldn't use parsec at all and just split on "; " then on ": " and pull it into a Map with fromList.
13:10:15 * hackagebot distributed-process-task 0.1.0 - Task Framework for The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-task-0.1.0 (TimWatson)
13:10:15 <schell> ski, chpatrick: thanks :)
13:10:17 * hackagebot distributed-process-execution 0.1.0 - Execution Framework for The Cloud Haskell Application Platform  http://hackage.haskell.org/package/distributed-process-execution-0.1.0 (TimWatson)
13:10:24 <ski> > fix $ \fibs -> 0 : 1 : zipWith fibs (tail fibs)
13:10:25 <lambdabot>  Couldn't match expected type ‘[a]’ with actual type ‘[b0] -> [c0]’
13:10:26 <lambdabot>  Relevant bindings include fibs :: [a] (bound at <interactive>:1:8)Couldn't m...
13:10:26 <lambdabot>  Relevant bindings include fibs :: [a] (bound at <interactive>:1:8)
13:10:29 <ski> er
13:10:32 <ski> > fix $ \fibs -> 0 : 1 : zipWith (+) fibs (tail fibs)
13:10:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:10:40 <iLike> begriffs, well that depends on how intricate the data could be(come)
13:11:12 <chpatrick> btw, I thought this wasn't supposed to typecheck: fix f = f (fix f)
13:11:13 <chpatrick> what gives?
13:11:16 <iLike> Using parser combinators isn't too hard though, and a good exercise
13:11:21 <begriffs> It's an error message from Postgres and I want to pull out the hint, code etc. So I don't think it will change much. But I thought maybe I should learn The Right Way to do it with parsec.
13:11:44 <iLike> begriffs, http://book.realworldhaskell.org/read/using-parsec.html
13:12:19 <begriffs> Cool, time to go read, thanks.
13:14:54 <HeladoDeBrownie> chpatrick, why wouldn't it type check?
13:15:46 <HeladoDeBrownie> chpatrick, let's take a look: So, f is applied to the output of fix, right? So f's input type must equal fix's output type. Let's call those both a. (a -> ?) -> a
13:15:52 <HeladoDeBrownie> chpatrick, what else needs to be true?
13:16:47 <HeladoDeBrownie> chpatrick, if I skipped too many steps for you I can go back
13:18:25 <chpatrick> HeladoDeBrownie: why do they do fix f = let x = f x in x?
13:19:15 <HeladoDeBrownie> chpatrick, I'm not sure what "why" you're looking for. That's a way you can write that.
13:19:54 <chpatrick> HeladoDeBrownie: because that's what's in Control.Monad.Fix
13:19:55 <chpatrick> HeladoDeBrownie: anyway I was thinking of the Y combinator, not fix
13:20:08 <HeladoDeBrownie> I don't think Y is expressible in Haskell, if I recall
13:20:42 <vanila> y is based on self applciation which you can't do in haskell because of the occurs check
13:20:49 <vanila> you can work around it by wrapping and unwrapping a newtype
13:21:00 <iLike> What's the 'arrow' I keep reading/hearing about?
13:21:17 <iLike> Is it a widely-used library or a language construct or something?
13:21:47 <HeladoDeBrownie> iLike, it's fairly well known but little used outside of functions. Control.Arrow is where you want to look I guess.
13:21:54 <erisco> so I remember trying to do some so-called meta programming and having a difficult time with overridden instances
13:22:26 <HeladoDeBrownie> iLike, Arrow is an abstraction that turns out not to be all that useful, at least as-is.
13:22:33 <HeladoDeBrownie> But sometimes it's useful!
13:22:37 <erisco> you can sort of construct a list of types using tuples, but matching on the type (a,b) is painful because 'a' might be (c,d)
13:22:55 <erisco> i.e. if you want to walk through the list of types that becomes obtuse and annoying
13:23:12 <erisco> anyone know what I mean?
13:23:49 <nitrix> maybe (firstAvailableResource xs) (return . Just) block
13:24:07 <nitrix> Is it possible to write this more cleanely without a case :/ ?
13:24:29 <HeladoDeBrownie> That looks okay to me, given that I know what firstAvailableResources and block are
13:24:30 <iLike> what's the type of firstAvailableResource?
13:24:48 <nitrix> firstAvailableResource :: [Resource] -> IO (Maybe Block)
13:25:34 <purelazy> > 1
13:25:35 <lambdabot>  1
13:25:57 <ski> > fix $ \rationals -> 1 % 1 : [(if b then recip else id) (1 + r) | r <- rationals,b <- [True,False]]  -- schell, here's another example of using `fix' to breadth-first traverse the <https://en.wikipedia.org/wiki/Stern%E2%80%93Brocot_tree> of all positive rationals
13:25:58 <lambdabot>  [1 % 1,1 % 2,2 % 1,2 % 3,3 % 2,1 % 3,3 % 1,3 % 5,5 % 3,2 % 5,5 % 2,3 % 4,4 %...
13:26:53 <ski> chpatrick : fwiw, i would state that as `fix f = x  where x = f x' .. i think it's more readable in that order
13:27:06 <ski> chpatrick : and they do it for efficiency
13:27:26 <nitrix> It's just that I end up with a whole bunch of nested case of, where each case is also an IO, so it's kind of annoying me.
13:27:39 <nitrix> I figured I could reduce a couple lines using `maybe`.
13:27:46 <ski> chpatrick : so that `fix ("hi" ++)' will create a single cycling list, rather than allocating new list cells as you traverse farther
13:27:48 <schell> ski: i see - that one’s neat
13:27:56 <vanila> nitrix, mybe you need MaybeT of IO
13:28:35 <erisco> has anyone flattened nested tuples? can maybe such be done with closed families? I remember trying this and failing
13:28:40 <ski> schell : note especially how i "contraintuitively" *start* by selecting recursively in the list comprehension, rather than first selecting which branch to traverse (left or right)
13:28:51 <nitrix> vanila: There's only one function. mapMaybeT. That one?
13:29:09 <vanila> erisco, I'mnot sure how you'd know when you got to the bottom of a nested tuple
13:29:22 <vanila> e.g. ((a,b),c) it is possible that a might be a pair too
13:29:52 <erisco> I don't know, I would hope that type inference would figure it out
13:29:54 <iLike> nitrix, perhaps use the Functor instances?
13:29:57 <ski> schell : doing that happens to yield the breadth-first traversal of the tree (in this case, the two children of a node `r' are `recip (1 + r)' and `1 + r') -- however, this neat trick doesn't work if your tree is finite :/ (it'll hang after enumerating all the elements)
13:30:07 <erisco> actually I realize now that will never work
13:30:16 <vanila> erisco, if you were ok writing down the shape of the tuple you could write a flattener using GADTs
13:30:25 <erisco> you'd have to have rules that talk about n-tuples
13:30:26 <vanila> I could sketch it out if you're interested
13:30:39 <ski> nitrix : perhaps you want `MaybeT IO' ?
13:30:49 <nitrix> MaybeT IO Block
13:30:54 <ski> oh, vanila already said :)
13:30:58 <erisco> I think maybe I settled for normalizing to a right associative nested tuple
13:31:12 <vanila> right nested tuples are a nice normal form
13:31:15 <nitrix> And holy crap, I think Functors, Monads and transformers and finally getting togheter.
13:31:22 <nitrix> I have an eureka moment.
13:31:23 <vanila> it's similar to just using Vector N
13:31:40 <nitrix> *are *together
13:31:51 <ReinH> nitrix: sweet
13:31:54 <ski> nitrix : `MaybeT m' is an instance of `Monad' (and more. provided that `Monad m') -- so you can also use all the usual (generic) monadic stuff on `MaybeT IO'
13:32:31 <erisco> vanila, I also remember there being ambiguity problems with the types... you'd probably not want to use (,) but rather some other type name
13:32:50 <erisco> otherwise is  (a,(b,c))  the type list  [a,b,c]  or the type list [a,(b,c)] ?
13:33:08 <erisco> or [(a,(b,c))] for that matter
13:33:37 <vanila> yeah it can be quite tricky
13:33:41 <erisco> something like   TCon a (TCon b c)  helps remove that problem
13:33:51 <erisco> as long as you play nice and don't use TCon for other things
13:33:59 <ski> > case (# (# () ,() #) , (# () , () #) #) of _ -> ()
13:34:00 <lambdabot>  ()
13:34:33 <erisco> or TCons rather
13:34:51 * ski would prefer `TCon a (TCon b (TCon c TNil))'
13:35:10 <erisco> oh, of course, my bad
13:35:15 * hackagebot distributed-process 0.5.3 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.5.3 (TimWatson)
13:35:25 <ski> nitrix : .. perhaps you could paste your code ?
13:35:46 <athan> woo! Distributed is getting some love :D
13:35:47 <boothead> can anyone explain to me the t in lens's forOf? I want to run the action, but I can't figure out how to discard the result
13:37:34 <erisco> there is an extension for infix type constructors yes? maybe  a :*: b :*: Nil  ?
13:37:48 <Iceland_jack> Yes, TypeOperators
13:39:08 <Aruro> how do i access clipboard? on vista?
13:39:53 <Axman6> Aruro: In haskell?
13:40:03 <Aruro> yes
13:40:19 <Aruro> is there an easy way?
13:40:35 <nitrix> https://github.com/nitrix/udfs/blob/c244325ec12b5007a7252840b45e6ae968391e23/src/Main.hs#L57
13:40:37 <pavonia> @hackage Clipboard
13:40:37 <lambdabot> http://hackage.haskell.org/package/Clipboard
13:40:42 <Aruro> now that im thinking about it why clipboard is not some sort of standard file in OS
13:40:45 <indiagreen> Aruro: http://hackage.haskell.org/package/Hclip
13:41:09 <nitrix> It's extremely minimal, I have firstAvailableResource, but it already seems like the design is wrong. That's a lot of `IO (Maybe X)`.
13:41:38 <ReinH> Aruro: ask the OS developers
13:41:41 <geekosaur> Aruro: X11 clipboards at least are not files
13:42:03 <Aruro> it would be nice to treat them as a file
13:42:08 <Aruro> i would like that :)
13:42:17 <geekosaur> I don;t know how it works on Windows, but an X11 selection is an advertisement, not a chunk of data. you must negotiate a common data format with the selection holder to get data
13:42:22 <geekosaur> it's good to want :p
13:42:29 <zq> hi guys
13:42:39 <zq> LANGUAGE rebindablesyntax ain't workin
13:42:48 <Aruro> ok ty guys! clipboard i think did not compile on vista
13:42:55 <Aruro> but hclip installed with no problems
13:43:01 <zq> > let (>>) = (+) in do { 1; 0; 0; 1; 2; }
13:43:02 <lambdabot>  Could not deduce (GHC.Num.Num (m a3))
13:43:02 <lambdabot>    arising from the ambiguity check for ‘e_110012’
13:43:02 <lambdabot>  from the context (GHC.Num.Num (m a6),
13:43:56 <Axman6> zq: did you use rebindablesyntax or RebindableSyntax?
13:45:15 * hackagebot cloud-haskell 0.2.0.0 - The Cloud Haskell Application Platform  http://hackage.haskell.org/package/cloud-haskell-0.2.0.0 (TimWatson)
13:45:17 * hackagebot formatting 6.0.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-6.0.0 (ChrisDone)
13:45:25 <geekosaur> it may go beyond that; IIRC there are some specific requirements for do-desugaring
13:46:27 <geekosaur> you are in some sense playing with the guts of ghc, and sometimes it enforces rules you don't expect and that are not quite clearly enunciated in the manual
13:47:28 <zq> Axman6: the camel version
13:49:07 <sinelaw> chrisdone, did you see my silly github issue for ircbrowse? couldn't figure out how to fix it myself in 5 minutes
13:50:06 <zq> never mind, made it work
13:52:52 <ski> nitrix : `providerLocalGet blockId = either (const Nothing) Just =<< tryIOError (B.readFile "data/" ++ blockId)'
13:53:29 <boothead> any pipes people around? What's the way to go from Producer a IO a to Producer a IO (). I've tried void, but I must be missing something?
13:53:31 <ski> (and similarly for `providerLocalSet')
13:54:06 <lambdafan> I'm having what appears to be a cabal-specfic problem when I try to use puppet to do a cabal install
13:54:09 <lambdafan> is this the right channel?
13:54:11 <Axman6> boothead: I don't know the answer, but I feel that you might get better answers if you say what you're actually trying to do
13:55:03 <lambdafan> or should I go find a puppet channel?
13:55:39 <boothead> Axman6, I'm confused by this code: https://github.com/boothead/BellRinger/blob/component/src/Main.hs#L45 I don't understand where the edom1 is coming from in the error or why I can't get rid of it
13:57:02 <dbushenko> hi all!
13:57:20 <dbushenko> can anyone help me with this small piece of code?
13:57:20 <dbushenko> http://lpaste.net/116719
13:57:29 <dbushenko> it works but looks like those two lines can be a one-liner
13:57:32 <nitrix> ski: thank you ;-;
13:57:46 <Axman6> lambdafan: #hackage might be a better place to ask
13:57:49 <dbushenko> how to get rid of the explicit returning the value 'res'?
13:57:59 <Iceland_jack> dbushenko: You can do:
13:57:59 <Iceland_jack>     Just c -> join $ liftIO $ callAuthenticatedFunction conn c f
13:58:08 <erisco> it would be nice if types were not unityped
13:58:14 <dbushenko> Iceland_jack, let me try...
13:58:15 <erisco> dynamic type programming woo
13:58:43 <Axman6> dbushenko: for reference:
13:58:44 <boothead> Axman6, as far as I can tell the comments line shoudl be roughly the same as the run function, but lens is confusing me by sticking the t of Over p f s t a b into the return of the monad (in this case Producer)
13:58:46 <Axman6> :t join
13:58:47 <lambdabot> Monad m => m (m a) -> m a
13:58:53 <DSALNASS> At 13:30 today I asked a question and walked away so I wasn't able to thank those of who responded but I appreciate your responses
13:59:02 <DSALNASS> 12:30*ish
13:59:28 <dbushenko> Axman6, ah, its clear now.... thanks!
13:59:44 <HeladoDeBrownie> erisco, what are you referring to?
14:00:05 <erisco> the type of types of course
14:00:05 <dbushenko> Iceland_jack, Axman6, thanks! it works!
14:00:15 <Axman6> boothead: sorry I'm not sure I can help, but hopefully someone else can
14:00:55 <hodapp> hrmph. Ivory is making it really difficult to interact with any kind of external API that defines its own C types
14:00:57 <ski> boothead : you could also try #haskell-lens, i suppose
14:01:09 <boothead> thanks Axman6 - no worries :-)
14:01:13 <iLike> What library is well-written and understandable enough for a novice (novice being implemented monads, some small school projects and the like but nothing serious) so that I can get a feel for haskell?
14:02:21 <ski>   firstAvailableResource :: [Resource] -> MaybeT IO Block
14:02:30 <ski>   firstAvailableResource [                       ] = mzero
14:02:40 <ski>   firstAvailableResource ((providerId,blockId):xs) =
14:02:44 <erisco> vanila, Iceland_jack this is what I came up with
14:02:51 <boothead> ski, thanks, I'll give that a try!
14:02:59 <erisco> oops, linkie http://lpaste.net/116720
14:03:34 <erisco> also HeladoDeBrownie look at that link to see what I mean... particularly why Norm is needed
14:03:38 <ski>             do provider <- lift (M.lookup providerId providers)
14:03:39 <vanila> that just computes a type
14:03:52 <ski>                block <- getBlock provider blockId
14:03:54 <erisco> vanila, yes of course
14:03:56 <vanila> will it be able to implement the function too?
14:03:59 <ski>                return block
14:04:24 <DSALNASS> Are there graphics libraries for haskell?
14:04:27 <ski>     `mplus` do firstAvailableResource xs
14:04:30 <erisco> vanila, once that is needed then it is a world of hurt with overloaded instances isn't it
14:04:42 <erisco> oh how I wish instances could be closed like type families
14:04:47 <ski> nitrix : something like that could work, i think, provided you change `getBlock' and `setBlock' to also use `MaybeT IO'
14:04:51 <arianvp__> So my birthday is around the corner.  What would be some good haskell books to ask for?  (non-beginner)
14:04:53 <HeladoDeBrownie> erisco, ah, because you're working with anything of kind *, which is a rather large class?
14:04:58 <johnw> does anyone here use Liquid Haskell?
14:05:03 <vanila> erisco, maybe you culd do it in a simpler way with GADTs
14:05:14 <ski> nitrix : obviously you can remove the `block <-' and `return block' there, if you wish, that was just for illustration
14:05:46 <erisco> HeladoDeBrownie, well, with value lists you have  data List a = Cons a (List a) | Nil   and particularly you have   Cons :: a -> List a -> List a
14:06:20 <erisco> HeladoDeBrownie, you don't get that at the type level, from what I can tell, so there is nothing to distinguish between 'a' and 'List a'
14:06:24 <erisco> they are both type *
14:06:45 <HeladoDeBrownie> You can use DataKinds to get more control, probably?
14:07:02 <erisco> maybe, I have not used that before
14:07:20 <erisco> vanila, I consider that fairly simple as is
14:07:32 <vanila> ok
14:09:21 <ski> nitrix : now, i suppose one could then say `firstAvailableResource = msum :. map $ \(providerId,blockId) -> do provider <- lift (M.lookup providerId providers); getBlock provider blockId'
14:10:42 <ski> sorry, s/:./.:/
14:10:47 <ski> @let infixr .:; (.:) :: (c0 -> c1) -> (a -> b -> c0) -> (a -> b -> c1); (.:) = (.) . (.) {- (f .: g) x y = f (g x y) -}
14:10:48 <lambdabot>  Defined.
14:11:39 <ski> @type msum .: map
14:11:40 <lambdabot> MonadPlus m => (a1 -> m a) -> [a1] -> m a
14:11:54 <ski> @hoogle MonadPlus m => (a -> m b) -> [a] -> m b
14:11:54 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
14:11:54 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
14:11:54 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
14:12:49 <ski> hmpf
14:13:28 <erisco> vanila, for at least part of my problem the types can be phantom types
14:13:42 <erisco> down the road I will need to do stupider stuff :(
14:14:44 <texasmynsted> What am I not seeing?  (I am new to haskell)
14:14:57 <ski> (also, should be `infixr 9 .:')
14:15:24 <ski> texasmynsted : apropos what ?
14:15:29 <texasmynsted> heheh
14:15:55 <erisco> well at least I can make :*: infixr and then I won't usually run into normalization issues
14:16:04 <texasmynsted> Ok I am getting a typing error, and it is showing me a hole in my logic
14:16:26 <vanila> erisco, I could show you how to do it with GADTs if you like
14:16:34 <erisco> please
14:17:12 <texasmynsted> I have a HashMap like "m :: Data.HashMap.Strict.HashMap Char Char"
14:18:03 <vanila> http://lpaste.net/116721
14:18:07 <texasmynsted> I want to be able to perform lookups like this
14:18:35 <vanila> if you wanted you could remve a from It constructor and write a function t -> Tuples t l -> l, rather than what i have done
14:19:24 <texasmynsted> darn, I will just paste this
14:20:25 <texasmynsted> This is an exercise to help me learn haskell, so I guess it is doing its job
14:20:26 <texasmynsted> heh
14:20:31 <texasmynsted> http://lpaste.net/1622364191723618304
14:22:20 <texasmynsted> nm
14:22:24 * texasmynsted hides
14:22:42 <erisco> vanila, hm, that is interesting and might help for something else that needs values
14:23:21 <erisco> though, I might be able to swing this a bit differently
14:24:20 <erisco> I get to this Expr type which is my primary use right now http://lpaste.net/116722
14:24:46 <erisco> it will be more like   data Expr a = Foo String | Blah String   but 'a' will not be used in any constructor
14:25:05 <erisco> so I guess if the type list is a GADT it doesn't make much difference
14:26:52 <erisco> vanila, I think the two concepts connect together at  Cons :: x -> List xs -> List (x, xs)  because this needs to be  Cons :: x -> List xs -> List (x :*: xs)
14:27:02 <toblerone> Hi all, whats the easiest way you know of to copy and paste code into GHCI? Google didn't turn up much useful / recent information so I am hoping something has been made to make this easier
14:27:05 <erisco> otherwise the ambiguity problem again
14:28:16 <heatsink> toblerone: You can paste a multiline statement in :{ :} braces
14:28:30 <Axman6> toblerone: if you use :{<enter> then paste the code, then <enter>:}<enter> it may work
14:28:41 <heatsink> toblerone: But the more common approach is to paste the code in a file that you import in GHCi
14:28:50 <erisco> actually maybe not... I am not exactly sure what changed but I cannot think of how you would ambiguously construct List
14:29:06 <toblerone> Yeah, thats not really satisfactory because I still have to prepend everything with 'let'
14:29:24 <vanila> erisco, I don't see the problem exactly - I should say that you are supposed to write down a 'Tuples' element to use this
14:29:37 <vanila> it would be possible to build them automatically with typeclasses sometimes, but I don't really recommend it
14:29:47 <Axman6> toblerone: then use a file
14:29:57 <jfischoff> Why would having a thousand threads blocked on reading an empty queue, slow down an entire application?
14:30:03 <toblerone> Axman6: Yes, there is always that option.
14:30:26 <Axman6> ghci isn't designed to be a general purpose code construction interface, it's primarilly there to interract with code you've already written
14:30:28 <toblerone> buuuut, it would be very convenient if I didn't have too : )
14:30:40 <quchen> jfischoff: STM issues?
14:31:00 <erisco> I think it becomes unambiguous because the only way you can construct a List is with Nil and Cons, so you know for example that List ((a, b), (c, ()))  is the type list [(a, b),c]
14:31:00 <jfischoff> they never wake up
14:31:09 <jfischoff> the queue is always empty
14:31:28 <jfischoff> so I don’t see what the issue would be
14:31:44 <Axman6> what sort of queue?
14:31:48 <erisco> in (a,b) the type 'a' is always the element type and 'b' is always () or (c,d) and the same logic applies again
14:31:50 <jfischoff> TQueue
14:32:00 <quchen> jfischoff: Hmm. Maybe do some Debug.trace to see whether the transaction is *really* not restarted again and again?
14:32:09 <jfischoff> I know it is not
14:33:22 <quchen> Is the behaviour reproducible in an isolated environment? Is the code pasteable?
14:33:45 <jfischoff> no it is not code pasteable, it is something we discovered at work
14:34:19 <erisco> vanila, I find that really interesting... I have not used GADTs for much before
14:34:27 <jfischoff> My current understanding of the GHC runtime would lead me to believe this would not have such a large performance impact
14:35:33 <quchen> In case the threads are just waiting I'm out of ideas as well :-/
14:35:46 <vanila> im glad it was interesting!
14:35:54 <vanila> GADTs are very powerful but not often used to their potential
14:37:17 <quchen> jfischoff: Now I'm wondering how GHC checks whether a transaction needs to be rerun, actually.
14:38:07 <quchen> Somehow the change in a variable must be propagated back to all transactions using it after all.
14:38:28 <jmcarthur> jfischoff: doesn't GHC's implementation of STM suffer from the thundering herd problem when there is a lot of contention?
14:38:35 <jfischoff> yes it wakes up all threads that depend on a TVar is my understanding
14:39:02 <jfischoff> jmcarthur: sure but that doesn’t affect sleeping threads, right?
14:39:12 <quchen> The naive implementation would be busy waiting for changes in dependent vars, which might explain some load when you have many waiting threads. But the GHC devs probably have some nifty better implementation.
14:39:13 <jmcarthur> jfischoff: maybe i misunderstood the problem you described. is it that you aren't ever changing the queue?
14:39:25 <jfischoff> yes I am never changing it
14:39:28 <jmcarthur> huh
14:39:34 <jfischoff> yeah
14:39:36 * jmcarthur looks at TQueue, as he has never used it
14:39:47 <erisco> vanila, my mind has been in either type land or value land, and GADTs seem to sit somewhere in the middle so I find it perplexing
14:40:11 <jfischoff> quchen: I can find the description, but I believe they are not just spinning
14:40:17 <jmcarthur> jfischoff: what operation are the threads blocked on?
14:40:22 <jmcarthur> readTQueue?
14:40:25 <vanila> erisco, yeah :) they let you do a very small amount of communication between levels in a way - it's a precursor to dependent type pattern matcher
14:40:45 <jfischoff> jmcarthur: yes
14:40:48 <vanila> when you match on a GADT constructor it will affect the type of that branch
14:41:04 <jfischoff> jmcarthur: some form of reading that is
14:41:11 <jfischoff> let me look at the code ...
14:41:18 <erisco> vanila, right, hm
14:42:52 <jfischoff> jmcarthur: Yes and actually it is a TBMQueue, which is still very similar
14:43:27 <lambdafan> Axman6: thanks :)
14:43:27 <jmcarthur> ah, i'll look at that instead. TQueue is really simple, at least
14:43:36 <chrisdone> @vixen how much wood would a woodchuck chuck if a wouldchuck could chuck wood?
14:43:36 <lambdabot> Always remember that others may hate you but those who hate you don't win unless you hate them. And then you destroy yourself.
14:43:43 <jfischoff> TBMQueue is not that different
14:44:03 <ski> (there is no `vixen' command)
14:44:09 <jmcarthur> looks pretty different to me
14:44:10 <jfischoff> In thread scope, I did not see the threads wake up
14:44:21 <chrisdone> ski: demonstrably there is =p
14:44:25 <jmcarthur> ah it uses TQueue under the hood
14:44:26 <jfischoff> Well it is not just two lists
14:44:50 <chrisdone> but it's an alias for something less offensive now
14:45:03 <jfischoff> I wonder if there is scheduler has to visit sleeping threads in some list or something
14:45:09 <chrisdone> i think it should contain insightful computer science quotes
14:45:27 <chrisdone> but fed through a markov chain so that it makes up new wisdom
14:45:32 <jfischoff> so even if they are not using cpu directly that can still slow everything down
14:46:37 <jmcarthur> jfischoff: i don't think that is the case
14:46:43 * jfischoff nods
14:46:48 <jfischoff> I hope not
14:46:54 <quchen> jfischoff: GHC makes debugging this hard because it detects my infinite waiting for a transaction in my silly small example haha
14:46:57 <jmcarthur> jfischoff: do you have some main thread doing work while all these others are waiting?
14:47:05 <jfischoff> yes
14:47:14 <jfischoff> many other threads are doing work
14:47:24 <jmcarthur> have you ruled out the gc?
14:47:39 <erisco> why do I have to tell ghci :set -GADTs so that it will stop complaining of GADTs being an unrecognized pragma?
14:47:49 <quchen> :set -XGADTs
14:48:03 <erisco> I mean :set-XGADTs
14:48:15 <jfischoff> jmcarthur: It could still be gc related, but removing the threads fix the performance
14:48:16 <erisco> with a space. I cannot type
14:48:18 <jfischoff> fixed
14:48:40 <geekosaur> not sure what you're asking. {-# LANGUAGE GADTs #-} should be valid
14:49:04 <geekosaur> ir were you just saying {-# GADTs #-} which ould trigger unrecognized pragma (the pragma being LANGUAGE)
14:49:06 <jfischoff> jmcarthur: reduced response times by half across the board on our server
14:49:09 <jmcarthur> jfischoff: depending on how many there are, maybe their mere existence is impacting the gc?
14:49:16 <jfischoff> yes
14:49:26 <jfischoff> right, it checks to see they are alive
14:49:40 <ski> chrisdone : lambdabot is just nice enough to second-guess what you really meant :)
14:50:15 * hackagebot xlsior 0.1.0.0 - Streaming Excel file generation and parsing  http://hackage.haskell.org/package/xlsior-0.1.0.0 (rcallahan)
14:50:17 * ski can't really recall `vixen' being offensive, though
14:50:30 <ski> (but that may perhaps be because i'm not easily offended)
14:50:47 <jmcarthur> jfischoff: should be easy to test. see if significantly more time is spent on gc with those threads than without.
14:50:52 <blackdog> ski: it had some pretty ripe stuff in there :) i grabbed all the quotes from a visual basic bot i found online ages ago
14:50:53 <monochrom> ski: http://www.vex.net/~trebla/vixen.txt :)
14:51:00 <blackdog> didn't really vet it
14:51:14 <jmcarthur> this is a shot in the dark though
14:51:43 <jfischoff> jmcarthur: I was seeing a lot of time spent in the gc, and odd gc behavior so it is possible.
14:52:05 <jfischoff> I can’t test it that easily, but I might try an artifical test
14:52:12 <jfischoff> I like the theory though ;)
14:56:35 <ParahSailin> why is cabal update its own command? other package managers like npm, gem etc search the remote database whenever you try to install anything
14:57:14 <johnw> ParahSailin: it's a bit like "apt-get update", "yum makecache", etc.
14:57:34 <johnw> you update the local cache of the remote package database
14:59:20 <ParahSailin> i guess cabal has a harder dependency graph than pip or npm, so you need the entire remote database cached?
14:59:47 <johnw> does pip solve against past versions, or only the "current version"?
15:00:01 <johnw> cabal searches for a solution within a pretty rich graph
15:00:06 <ParahSailin> yeah i have no idea, it breaks a lot in my experience
15:01:07 <ski> blackdog : ok
15:01:52 <S11001001> Where did the Linux logo on https://www.haskell.org/platform/ come from?
15:05:55 <danclien> S11001001: http://commons.wikimedia.org/wiki/File:Tux.svg ?
15:06:06 <serutsubi> I'm a haskell noobie. How do I "test" a library ghci? I installed it from hackage in a cabal sandbox.
15:06:56 <marchelzo_> You just import the module
15:07:54 <quchen> monochrom: whatdidijustread
15:08:12 <serutsubi> I tried but it couldn't find it. I did "import Text.ICalendar", but I got an error
15:08:16 <quchen> #haskell seems to have come a long way.
15:08:46 <jmcarthur> is there any way to encapsulate a constraint? for example, with constraint kinds I can define a synonym, but nothing like a newtype whose representation i can choose not to export.
15:08:56 <jmcarthur> at least as far as i know
15:09:10 <danclien> serutsubi: Try `cabal repl` instead.
15:09:23 <shachaf> jmcarthur: What sort of behavior do you have in mind?
15:09:41 <serutsubi> danclien: Excellent, thank you!
15:09:49 <shachaf> You could define class (Foo a, Bar a) => Vaz a and instance (Foo a, Bar a) => Vaz a, with some extensions.
15:09:51 <danclien> serutsubi: You're welcome. :)
15:10:15 * hackagebot google-drive 0.3.0 - Google Drive API access  http://hackage.haskell.org/package/google-drive-0.3.0 (PatrickBrisbin)
15:11:15 <ski> jmcarthur : imho, it ought to be possible to export synonyms abstractly
15:11:21 <jmcarthur> shachaf: in this particular case, i want to use something like  type MyConstaint s = Reifies s SomeData  but hide the fact that Reifies or SomeData are involved at all in the interface i expose. my library would just use reify internally.
15:11:47 <quchen> serutsubi: GHCi probably doesn't know about your sandbox. Try "cabal repl" in your directory, instead of simply "ghci". If I recall correctly, that should recognize your sandbox.
15:12:07 <quchen> Oh, I'm a bit late to the party.
15:14:16 <Zol_> @pl \x y -> (5 + x) / y
15:14:16 <lambdabot> (/) . (5 +)
15:14:19 <quchen> serutsubi: I'm not sure what "cabal repl" does exactly, but conceptually it runs GHCi with an environment variable set that is based on all the environments it can find. So conceptually it's similar to "cabal exec ghci". You can check the cabal'd environment using "cabal exec env", which should show you an entry GHC_PACKAGE_PATH, which lists all the package paths in scope.
15:14:36 <jmcarthur> ski: that feature would have its ups and downs, but i think would be mostly a win.
15:15:33 <jmcarthur> ski: not a huge win, though, to be honest
15:16:36 <ski> jmcarthur : "7.3.5  Restricted type synonyms" at <https://www.haskell.org/hugs/pages/hugsman/exts.html#sect7.3.5> in Hugs is related
15:16:55 <shachaf> Yes, I was thinking of the Hugs thing.
15:17:16 <shachaf> It's slightly suspicious, the way that works.
15:17:20 <ski> also, in the MLs, one can export synonyms abstractly
15:17:40 <ski> perhaps there would be some interactions with instances, though ..
15:17:54 <jmcarthur> you probably wouldn't be able to safely use such abstractions as GADT parameters or with type classes
15:18:04 <jmcarthur> or type families, or other interesting features
15:18:47 <shachaf> Presumably related to the thing with GADTs and TypeFamilies that I was talking about the other day.
15:18:58 * ski nods
15:19:22 * ski isn't sure type inequality is a win
15:19:52 <shachaf> I'm not entirely sure either, but certainly it makes GADTs much more useful.
15:20:05 <shachaf> I think most use cases of GADTs use it.
15:20:39 <shachaf> jmcarthur: Your API would export an equivalent of reify and reflect specialized to your constraint?
15:20:50 <jmcarthur> shachaf: something like that, yes
15:21:38 <jmcarthur> i can think of safe things to do, but they leave some ugliness
15:22:12 <jmcarthur> such as allowing the constraint to be transparent, but just not exporting SomeData
15:22:43 <jmcarthur> (or at least for my use case that would be safe)
15:22:46 <serutsubi> I'm trying to parse a ics file on my disk, but I don't know how I do it. After importing i tried to run "parseICalendarFile Home.ics", got loads of errors. This is the lib I'm talking about
15:23:34 <jmcarthur> but i hate it when a type visible in type errors and documentation but not actually available for use
15:23:41 <jmcarthur> *when a type is visible
15:24:07 <shachaf> Well, using a class like I mentioned should work reasonably enough, shouldn't it?
15:24:13 * athan is guilty of such crimes
15:24:15 <serutsubi> I also tried: 'parseICalendarFile $ dfBS2IText "home.ics"'
15:24:19 <shachaf> Other than needing UndecidableInstances and all that.
15:24:44 <athan> jmcarthur: Why don't you inspect it with `cabal repl`? What type/lib is it?
15:24:59 <jmcarthur> shachaf: yeah, it would work. ideally i would hide that the reflection library is used at all
15:25:07 <shachaf> Doesn't this hide it?
15:25:18 <shachaf> Well, unless people want to write their own instances of your class, or :i it in ghci.
15:25:40 <jmcarthur> yeah, it's still visible in the interface, even though it's useless for users
15:26:05 <sinelaw> jmcarthur, yo
15:26:05 <shachaf> In the interface?
15:26:24 <jmcarthur> shachaf: in ghci, in the documentation, etc.
15:26:30 <jmcarthur> sinelaw: yo
15:26:31 <shachaf> Ah, I guess.
15:26:53 <shachaf> The main advantage would be that it wouldn't show up in type errors.
15:26:54 <jmcarthur> i admit this is a nit
15:26:57 <jmcarthur> yeah
15:27:43 <jmcarthur> athan: i suspect you missed some context. this is a library i'm writing at the moment. i'm just trying to figure out a way to avoid the problem i'm complaining about, because some libraries have it
15:28:39 <athan> jmcarthur: Having an `Internal` module is usually where I go
15:28:43 <athan> is it from phantoms?
15:28:55 <lpaste> schell pasted “delayWith” at http://lpaste.net/116726
15:29:15 <schell> does anyone have a nifty way of optimising this function? ^
15:29:21 <jmcarthur> athan: that wouldn't help. i would have some internal type class that an external type class requires, and then the internal one appears in the public interface even though it is useless
15:29:37 <schell> it’s taking up the biggest chunk of my running time, eventually my program gets really choppy
15:29:51 <athan> jmcarthur: I've been venturing into GADT's to maintain constraints, but in a hidden way. Maybe that might help...?
15:30:02 <athan> You're probably going to run into scary ideas though :[
15:30:06 <serutsubi> I meant to link this in my previous message: https://hackage.haskell.org/package/iCalendar-0.4.0.2/docs/Text-ICalendar-Parser.html
15:31:22 <jmcarthur> athan: this is all about type classes. if you are able to construct a GADT that allows me to define a constraint in terms of another without exposing the dependence on that constraint, i will be both surprised and pleased. emphasis on "surprised" though
15:32:03 <athan> `data Foo where Foo :: Show a => a` encodes the Show constraint on the value constructor
15:32:14 <athan> even after pattern matching, you don't need to explicitly declare the context
15:32:27 <athan> (in fact, you can't because the `Foo` type constructor :: *)
15:32:31 <jmcarthur> shachaf: another downside to your suggestion is that it allows users to pointlessly use reify wherever my constaint is present. again, not awful, but just yet more garbage and confusion
15:32:57 <jmcarthur> athan: sure, but i don't see how that helps. that does not create a new constraint of my own
15:32:57 <shachaf> jmcarthur: I guess so.
15:33:17 <athan> jmcarthur: Yeah, it's just an idea. Have you looked into ConstraintKinds?
15:33:22 <shachaf> jmcarthur: reflection's implementation is 5 lines. Just unsafeCoerce it yourself. :-)
15:33:33 <jmcarthur> athan: i mentioned ConstraintKinds in my original question
15:33:37 <erisco> vanila, I have some reading to do, but I was wondering if you could give some insight as to why GHC believes there is an ambiguous type http://lpaste.net/116727
15:33:40 <athan> ;x
15:33:56 <shachaf> (And 3 of those lines are the API, so maybe I should say the implementation is 2 lines.)
15:33:57 <jmcarthur> shachaf: yeah, i also considered that. just wanted to shift the burden of supporting that awful hack to somebody else ;)
15:35:21 <shachaf> jmcarthur: OK, how about this: Write your own class which is compatible with Reifies, and then unsafeCoerce reify to use your constraint instead of Reifies.
15:35:36 <jmcarthur> ha
15:36:32 <monochrom> binary-compatible type classes...
15:36:37 <jmcarthur> shachaf: i think until i think of something better, i will just do a variation on your suggestion. i'll make your suggestion an internal, unexposed type class, and make the exposed one require that one. that at least removes junk from the API, even though it still makes documentation ugly
15:36:56 <shachaf> Two layers of type classes?
15:36:58 <weasels_acme> monochrom: Doesn't Storable do that
15:37:03 <jmcarthur> yup :'(
15:37:07 <monochrom> no
15:37:32 <shachaf> *And* you get to turn on UndecidableInstances and a whole bunch of extensions!
15:37:36 <shachaf> It's your lucky day.
15:37:38 <jmcarthur> ain't it great
15:39:11 <erisco> vanila, sorry, I am taking off now, but I will be on tomorrow no doubt
15:39:32 <chrisdone> erisco: i think your type function cannot be applied because it doesn't have all its arguments yet resolved. your 't'
15:40:17 * hackagebot hasql 0.4.1 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.4.1 (NikitaVolkov)
15:40:18 <chrisdone> the type can't be said to be fully resolved at this stage
15:40:36 <erisco> chrisdone, hm, that is not really clear to me but I will put more thought in to it tomorrow
15:40:37 <erisco> thanks
15:40:43 <dfeuer> @tell edwardk Don't even bother looking at that lpaste. There are severe errors in my thinking there, and I'm now re-thinking.
15:40:43 <lambdabot> Consider it noted.
15:41:45 <serutsubi> /quit/quit
15:49:19 <statusfailed> What's the difference between a deeply and shallowly embedded DSL?
15:51:22 <johnw> a shallow embedding is like a library with an API
15:51:54 <johnw> a deep embedding is where the DSL is converted into an abstraction within the host language
15:52:00 <johnw> let me see if I can't find you more precise descriptions
15:52:11 <johnw> http://alessandrovermeulen.me/2013/07/13/the-difference-between-shallow-and-deep-embedding/
15:52:35 <johnw> "Conceptually, a shallow embedding captures the semantics of the data of the domain in a data type and provides a fixed interpretation of the data, whereas a deep embedding goes beyond this and captures the semantics of the operations on the domain enabling variable interpretations."
15:52:37 <ski> one uses data constructors for the many producing operations, the other uses some (usually complex) "semantic" representation type
15:52:47 <ski> .. but i can never recall which is which :/
15:53:02 <dfeuer> johnw, what's the difference between a deeply embedded DSL and just a language?
15:53:21 <johnw> a DSL is more of a "language within a language"
15:53:26 <dfeuer> Er ... I eman ....
15:53:26 <statusfailed> dfeuer: I guess the "embedded" bit means "you can use it in a Haskelly way inside Haskell"? :)
15:53:27 <dfeuer> Bah.
15:53:36 <johnw> err, EDSL
15:53:36 <ski> (probably because the course in which i first heard about them accidentally taught them the other way around than they're normally used (they've since fixed the course notes))
15:53:38 <dfeuer> I'm trying to focus on something else.
15:53:45 <statusfailed> ski: ouch!
15:53:59 <joelteon> Conceptually, embeddings are represented by metaphors.
15:54:04 <statusfailed> johnw, ski : sounds like "GADT -> Deeply embedded", is that fair?
15:54:09 <dfeuer> johnw, that definition you gave is extremely vague.
15:54:14 <johnw> so, shallow = captures data semantics, deep = captures operational semantics
15:54:19 <dfeuer> What do the words even mean?
15:54:27 <johnw> see the article
15:54:33 <statusfailed> dfeuer: that depends on what the meaning of "is" is.
15:54:35 <dfeuer> OOOK.
15:54:47 <dfeuer> statusfailed++
15:55:24 <statusfailed> dfeuer: sorry :p
15:55:28 <monochrom> "semantics of operations" does not mean operational semantics
15:56:02 <johnw> usually when I think "deep embedding in Haskell", I think of using the free monad to apply multiple interpretations to a Haskelly representation; while when I think of "shallow embedding", I think of a family of data types and functions that let me express what I want to do more directly
15:56:21 <ski> monochrom : yes, i was pondering remarking on that
15:56:35 <statusfailed> johnw: OK, that makes sense to me
15:57:15 <mmmm> Any ideas why Data.Text.IO.putStrLn might not be putting the newline character everytime?
15:57:45 <dfeuer> johnw, I still don't understand free monads. Do you have a link to a good explanation?
15:57:59 <chrisdone> mmmm: what does it put the other times?
15:58:12 <dfeuer> After this, though, I'm going to turn away from chat to try to do this sequence thing.
15:58:29 <johnw> dfeuer: so, you know how lists of numbers let you represent multiple values that you might fold over later, whereas the number 4 has lost the original set of values it may have come from?
15:58:30 <mmmm> Some lines are concatenated together, most are seperated by a newline
15:58:32 <lpaste> vamega pasted “Too many lifts” at http://lpaste.net/116729
15:58:33 <statusfailed> mmmm: Are you putting strings you read from stdin by any chance?
15:58:47 <dfeuer> johnw, I guess?
15:59:11 <vamega> Hi, I was wondering if there was a clearer way to write the function that is shown in the above paste.
15:59:15 <statusfailed> mmmm: maybe a test snippet would help?
15:59:39 <mmmm> in fact, more are concatenated together than not
15:59:51 <vamega> I feel like the multiple uses of Lift make it less apparent what the code is trying to do.
16:00:00 <chrisdone> mmmm: how many threads are running?
16:00:16 <dfeuer> johnw, go on?
16:00:17 <johnw> dfeuer: a free monad gives you a nested structure representing multiple contexts that you might interpret later, whereas a regular monadic action has lots the original set of actions that were composed together to create it
16:00:27 <mmmm> ahh, yes this is in a concurrent setting
16:00:36 * chrisdone beams
16:00:41 <ski> vamega : replace `y' by fromIntegral y', and remove the `liftA' call ?
16:00:42 * chrisdone rings the concurrency bell
16:00:48 <mmmm> I don't know exactly how many threads but yes there are threads
16:01:21 <dfeuer> johnw, hrm. I'm going to have to read up on them (again) later.
16:01:21 <ski> johnw : s/lots/lost/
16:01:29 <mmmm> there are also lots of sad new lines at the end of the input which have lost their lines :(
16:01:30 <chrisdone> mmmm: writing to a handle isn't atomic at the granularity of a putStrLn
16:01:32 <johnw> dfeuer: if a list is [a], you have a functor f, the free monad is very much like having [f] a, if such a syntax even made sense, and respecting the fact that [f] is really a tree and not confined to being just a list
16:02:04 <johnw> because it is, after all, the free monoid in the category of endofunctors
16:02:14 <chrisdone> mmmm: i'd suggest using a mutex on that handle before writing to it
16:02:16 <dfeuer> Uhhhhh, not helpful that.
16:02:32 <johnw> hmm
16:02:36 <johnw> this works better with pictures
16:02:41 <dfeuer> It might.
16:02:51 <dfeuer> So does this other thing I'm working on :P
16:02:52 <johnw> you know how when you write 1 + 2 + 3, you can see three numbers, even though the result will be one number?
16:02:56 <dfeuer> Yes.
16:03:12 <johnw> so, when you write foo >>= bar >>= baz, the result is one action, even though you can see three actions
16:03:16 <chrisdone> mmmm: e.g. withMVar_ handleVar (\handle -> hPutStrLn handle "Hello!")
16:03:18 <dfeuer> Yes.
16:03:23 <vamega> ski: Yeah, that's a definite improvement
16:03:28 <johnw> the free monoid would be [1,2,3] for the first example
16:03:35 <dfeuer> johnw, does the free monad make >>= into a constructor?
16:03:41 <mmmm> ok thanks chris!
16:03:41 <dfeuer> Or someat?
16:03:52 <johnw> the free monoid would be like a list of the contexts produced by foo, bar and baz, but not yet bound together
16:03:52 <Eduard_Munteanu> dfeuer, altrenatively, you can think of a free monad as letting you unroll the application of >>= step by step.
16:03:57 <johnw> dfeuer: it does!
16:03:58 <chrisdone> mmmm: btw if you're using this for logging, there're libraries that handle this for you
16:04:05 <johnw> s/monoid/monad
16:04:27 <johnw> [1,2,3] defers the reduction implied by '+'
16:04:33 <dfeuer> Ahhh.
16:04:35 <johnw> the free monad defers the reduction implied by >>=
16:04:56 <mmmm>  any in particular chrisdone?
16:04:59 <johnw> allowing you to supplying multiple, alternate interpretations of >>= later
16:06:02 <johnw> said another way: the free monad turns do-notation into a syntax-based AST builder for Haskell DSL designers :)
16:06:20 <chrisdone> mmmm: monad-logger
16:06:20 <johnw> (deeply embedded EDSLs, specifically)
16:06:35 <hiptobecubic> what makes a DSL deep?
16:06:40 <johnw> mmmm: logging, if you just need dead-simple logging for an application, rather than a library
16:06:44 <piskrist> http://www.dakotaenginebuilders.com/wp-content/uploads/2009/10/lance-haskell.jpg lol
16:06:55 <johnw> hiptobecubic: you are capturing the operational semantics of the DSL, allowing for multiple intepretations of meaning
16:06:59 <Eduard_Munteanu> E.g. the free monad for a monad with exception-like stuff lets you unroll exceptions and see where it busted out.
16:07:00 <dfeuer> johnw, when might you want to supply such? Also, could you also do something like that using newtypes to select different interpretations? Especially with Coercible?
16:07:24 <johnw> dfeuer: well, the idea is that you want to construct a value-based representation of the program written in your DSL
16:07:29 <dfeuer> Right.
16:07:30 <dfeuer> OK.
16:07:38 <dfeuer> I think I vaguely get some of that gist.
16:07:40 <dfeuer> Thanks!
16:07:45 <johnw> so you have some AST type, and you use the free monad to build up instances of your AST
16:08:15 <dfeuer> Just as though you were building up some other thing, which it might or might not eventually be interpreted as.
16:08:21 <dfeuer> Sounds very very general.
16:08:28 <johnw> yep
16:08:32 <johnw> it's as general as it gets, pretty much
16:08:37 <johnw> which makes it hard to explain :)
16:08:49 <HrafnA> What does AST stand for?
16:08:58 <josephle> abstract syntax tree
16:09:00 <dfeuer> Which also makes it hard to come up with applications immediately. Probably one of those things that needs some practice.
16:09:26 <benzrf> HrafnA: the idea is that most programming languages' syntax represents some kind of tree
16:09:33 <vanila> well I think the good thing about free monad based AST is that you can decorate the nodes with extra things
16:09:38 <vanila> isnt it?
16:09:39 <johnw> just as the free monoid lets you encode "sentences" for any set of terms, the free monad lets you encode "expressions" for any language
16:09:50 <benzrf> HrafnA: so when you parse a language, you want the output to be the tree that the syntax fundamentally represents
16:09:58 <vanila> but you can achieve this with just an extra 'info' cell
16:10:43 <josephle> HrafnA: you can do more complex analysis (e.g. type checking) when you represent your program as a tree
16:10:48 <chrisdone> formlets would make a good denotional example
16:11:02 <HrafnA> I see
16:11:11 <chrisdone> because the same expression tends to be used both for generating a form and for consuming input and validating
16:11:19 <Eduard_Munteanu> vanila, not really, the functor affects the structure of the computation... e.g. a tree would result in representing multiple possible computations at each step
16:11:25 <chrisdone> in practice libraries do it in one monad, but you could have one AST and two separate interpreter functions
16:11:58 <vanila> Eduard_Munteanu, The functor here would be AST :: * -> * though I thought?
16:12:00 <josephle> HrafnA: compilation is basically changing your plaintext source code into various data structures for analysis and optimization, then finally spitting out some target language
16:12:03 <dfeuer> chrisdone, wait, how does generating the form tie in to consuming the input and validating it?
16:12:15 <vanila> which is define like  data AST a = ... | App a | .. for exmaple
16:12:28 <vanila> and I think just  data AST info = .. | App info AST | .. works well enough
16:12:33 <marchelzo_> Is there a version of Data.List.intersect that requires both lists to contain at least n copies of an element in order to return n copies of it in the result?
16:12:46 <marchelzo_> > intersect [1,1,1,1,1] [1]
16:12:47 <lambdabot>  [1,1,1,1,1]
16:12:54 <marchelzo_> would just be [1]
16:13:10 <dfeuer> Unfortunately, GHC's native code generator does not use an AST, so asm-level optimizations are done *in the pretty-printer*.
16:13:26 <S11001001> danclien: thanks
16:13:30 <johnw> dfeuer: usually when I find myself thinking, "I want multiple meanings for >>=" (such as: execution, tracing, instrumentation),  is the moment I think of free monads
16:13:37 <Eduard_Munteanu> vanila, oh, well, that's more complex then
16:14:05 <Eduard_Munteanu> vanila, I was merely thinking of the inherent application in monadic binds
16:14:17 <dfeuer> Thanks, johnw. I'm going to go off now and continue my data structure adventures.
16:14:22 <johnw> enjoy!
16:14:26 <johnw> finger trees await
16:14:26 <chrisdone> dfeuer: consider validate (/= "Chris") (textInput (Just "Dave")) :: Formlet String. this expression can be used to produce <input type="text" value="Dave" id="UUID_123"> and also when you run the form this same expression will know to lookup UUID_123 in the form's input table and then the validator function will look at the value and either throw an error or suceed
16:14:56 <dfeuer> chrisdone, I do not know what a formlet is.
16:14:58 <Eduard_Munteanu> And we're probably talking about FreeT, not just Free.
16:15:22 <chrisdone> dfeuer: do you know how web forms work?
16:15:49 <dfeuer> chrisdone, what little I once knew I've forgotten. Horrible CGI weirdness.
16:15:56 <chrisdone> optparse-applicative is also essentially a formlet
16:16:11 <hiptobecubic> a formlet is like a piglet
16:16:17 <hiptobecubic> but with forms
16:16:36 <hiptobecubic> next!
16:16:43 <chrisdone> switch (long "verbose" <> short 'v')  -- this can be used to either consume input from program arguments, [String]
16:16:49 <chrisdone> or it can be used to produce --help documentation
16:16:52 <Eduard_Munteanu> Mushy when cooked? :P
16:17:13 <chrisdone> both the description and the parsing are combined, but can be run separately
16:17:46 <dfeuer> Oh, before I go away go away, does anyone know of articles that go into much depth about finger trees? I've read Hinze and Paterson, but what I'm doing now gets a bit deeper into things.
16:18:23 <dfeuer> [with their trees, but doing weirdness to them]
16:19:02 <dfeuer> BOOM
16:38:55 <vjeranc> does anyone know how could I upload haddock docs to hackage without having local links to source code of some dependencies (ex. Data.Text links to my local docs copy instead of online one)?
16:40:12 <johnw> vjeranc:  are you saying that what's on hackage has links to local paths from your machine?
16:40:47 <vjeranc> johnw: yep, some are /usr/local/haskell/blabla, but there are even some pointing directly to my /home/vjeran/... when I get them online
16:40:54 <glguy> This is how I upload documentation to hackage: https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
16:41:15 <dfeuer> johnw, glguy, do you know of any must-read literature on finger trees? I'm specifically looking at ways to transform them radically, in zipper-like fashions.
16:41:24 <glguy> I didn't make it specific to the lens package, though, so you can use it, too
16:41:31 <dfeuer> [and such]
16:41:31 <johnw> dfeuer: I don't know
16:42:19 <vjeranc> glguy: thanks, i'll try it
16:42:39 <dfeuer> All righty then. I'll keep trying to invent it myself.
16:43:17 <dfeuer> johnw, the person I'd really like to talk to is Louis Wasserman. Maybe I'll email him.
16:48:19 <vjeranc> glguy: still the same thing, probably the sandbox with its own docs is what's confusing the docs build
16:49:29 <glguy> vjeranc: could be, I don't use sandboxes for library dev
16:50:09 <vjeranc> glguy: thanks anyway!
16:50:17 * hackagebot tighttp 0.0.0.7 - Tiny and Incrementally-Growing HTTP library  http://hackage.haskell.org/package/tighttp-0.0.0.7 (YoshikuniJujo)
16:59:17 <dredozub-> http://lpaste.net/2024497225119301632 could someone please explain to me what this error means in general?
16:59:51 <Axman6> is Route or Location a type synonym?
17:00:06 <Axman6> is, defined as type Location a = ... a ...?
17:00:20 <dredozub-> Axman6: Location is a type synonym family
17:01:08 <dredozub-> it's defined like 'type family Location a where'
17:04:13 <dredozubov> Axman6: can you explain it with simple type synonym?
17:05:06 <dredozubov> i understand it is an issue with the part of instance declaration after '=>'
17:05:17 * hackagebot tighttp 0.0.0.8 - Tiny and Incrementally-Growing HTTP library  http://hackage.haskell.org/package/tighttp-0.0.0.8 (YoshikuniJujo)
17:05:44 <dredozubov> this stuff should be type constructors and it's really not, if i understand correctly
17:06:24 <Axman6> dredozubov: no, I'm not sure what the problem is =)
17:10:47 <Eduard_Munteanu> dredozubov, you can't really make instances for type synonym families, just like you can't for plain type synonyms.
17:12:12 <dredozubov> Eduard_Munteanu: hm, hypotetically can it be refactor using something like 'data family' to make it work?
17:12:46 <Eduard_Munteanu> dredozubov, that should work, if suitable
17:14:40 <Eduard_Munteanu> dredozubov, you might want to try LiberalTypeSynonyms and TypeSynonymInstances as a quick workaround, but I'm unsure
17:16:01 <dredozubov> Eduard_Munteanu: thanks, i'll give it a look, i'm not really sure how to make it work with data family quickly
17:16:03 <Eduard_Munteanu> Just be aware they behave like type synonyms so there's no way to distinguish the synonym from its reduction.
17:16:24 <Eduard_Munteanu> So same issue as with String vs [Char] instances.
17:16:29 <dredozubov> yeah, i get that
17:17:44 <dredozubov> basically i have something like a 7-10 newtype declarations wrapping multiple types
17:18:01 <dredozubov> and i want to generalize them for some function annotations
17:18:17 <Eduard_Munteanu> dredozubov, or perhaps    instance (..., b ~ Location a) => ... a b | a -> b  if you can change the typeclass
17:18:30 <dredozubov> hmm
17:18:36 <Eduard_Munteanu> Err, the fundep is on the class declaration.
17:19:42 <dredozubov> i believe you can't do that on instance declaration
17:20:00 <dredozubov> anyway, i get the fundep syntax, but the part with ~ is completely cryptic to me
17:22:19 <dredozubov> Eduard_Munteanu: can you explain this ~ bit? I don't really know how to google it.
17:23:15 <dredozubov> i think i've found it here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-families.html
17:23:47 <dredozubov> but it's kind of between the lines
17:26:33 <Hijiri> is ~ type equality?
17:27:04 <Hijiri> as in a ~ Fam b is a constraint saying that Fam b is a
17:27:08 <heatsink> yes
17:28:37 <dredozubov> The paper says:
17:28:39 <dredozubov> > Equality constraints, whose general form is t1 ~ t2, can appear anywhere that Haskell admits class constraints.
17:28:41 <lambdabot>  <hint>:1:21: parse error on input ‘,’
17:28:53 <dredozubov> oh, lambdabot
17:33:57 <erisco> I have boiled down my type inference problem http://lpaste.net/116735
17:35:38 <glguy> erisco: What'd you expect that to do?
17:35:47 <erisco> I expected it to type check
17:35:49 <glguy> example :: (First t ~ Second t) => proxy t -> First t -> Second t -- You'd have to do something like this to get it to go
17:36:20 <erisco> why? I must not be understanding something
17:37:59 <erisco> if I just add (First t ~ Second t) to the context it type checks
17:38:02 <erisco> but why is that necessary?
17:38:13 <glguy> because   id :: a -> a
17:38:22 <glguy> example x = x , same deal
17:38:47 <erisco> yes, that is fine, but why do I have to explicitly annotate First t ~ Second t ?
17:38:47 <glguy> so   First t and  Second t must unify with that same 'a'
17:38:56 <glguy> So that only type checks when they're equal
17:39:21 <glguy> since type-checking your example function requires that assumption you have to add it to your context
17:39:39 <erisco> WHY! :)
17:40:17 <glguy> same reason you can't write this: whoops :: a -> b   ;   whoops x = x
17:42:10 <erisco> the definition of 'example' should infer First t ~ Second t, I do not understand why it cannot
17:42:27 <glguy> You put an explicit type signature on it
17:42:30 <erisco> we have  x :: First t  and  x :: Second t, so  First t ~ Second t
17:42:43 <dredozubov> glguy: for a ~ b a must be equal to b or they _can_ be equal to one another?
17:43:00 <glguy> it did infer that they needed to be equal and then it looked at your type signature and you hadn't written that, so type error
17:43:13 <glguy> dredozubov: must
17:43:30 <RageD> Does anyone have any preferred IDEs for working with Haskell?
17:43:34 <erisco> glguy, oh I see
17:43:54 <RageD> to this point i've been vim only, but just curious
17:44:05 * hodapp uses Emacs
17:44:25 <Hijiri> I use emacs too
17:44:34 <erisco> for some reason it was in my head that the type sig was adding constraints to the inference rather than annotating the exact type
17:44:45 <dredozubov> i've switched to emacs from vim for haskell development
17:45:04 <RageD> that's what i feared
17:45:07 * glguy continues to be rock solid on the vim for haskell
17:45:09 <dredozubov> haskell-mode is nice, but i hate feeling handicapped while editing code
17:45:10 <RageD> vim + emacs... so many key bindings for one brain
17:45:11 <RageD> may have to just dump vim :)
17:45:18 <erisco> thanks glguy
17:45:33 <dredozubov> RageD: it's muscle memory anyways
17:45:58 <dredozubov> just like piano and guitar, you don't have to dump something to play other
17:46:05 <RageD> fair point
17:46:23 <RageD> emacs it is!
17:46:40 <lifter> I understand it is a common practice to put an app's data type definitions into a single module. What might one name such a module? Something like "MyApp.Data"?
17:47:03 <dredozubov> RageD: prepare to feel handicapped too
17:47:21 <dredozubov> i really hate emacs default configuration, it's useless for editing text
17:47:32 <dredozubov> vim is so much better by default :)
17:47:50 <RageD> dredozubov: I know :( i've used it a few times and left it lol
17:48:18 <lifter> This has worked very well for me: https://github.com/begriffs/haskell-vim-now
17:48:24 <dredozubov> RageD: you can set up something similar to haskell-mode in vim
17:48:29 <dredozubov> but it's painful
17:48:49 <dredozubov> you have to install vimproc/neobundle/build some stuff
17:49:41 <dredozubov> and of course i really hate to maintain my idempotent vim configuration scripts to install working vim from scratch
17:50:21 <RageD> lol maybe i'll take my lumps just finally learning emacs well (enough)
17:50:50 <dredozubov> i'm struggling withou dd/f/ciw and other
17:50:56 <dredozubov> without*
17:51:09 <acowley> Surely Hinze's papers are must-read for finger trees
17:51:29 <acowley> So hackage documentation building is still broken? http://hackage.haskell.org/package/hmatrix-0.16.1.1/docs/Numeric-LinearAlgebra.html
17:51:36 <RageD> ooh damn.. dd is like my best friend.. that and shift+V then dd :) lol
17:52:33 <dredozubov> RageD: you just have to reconfigure it to suit your needs
17:52:59 <dredozubov> RageD: it has many nice thing by default, such as C-x C-o and others
17:55:17 * hackagebot lambdaLit 0.1.1.0 - ...  http://hackage.haskell.org/package/lambdaLit-0.1.1.0 (faleidel)
17:55:31 <RageD> dredozubov: here goes nothing :)
17:55:52 <dredozubov> RageD: and goes, and goes, and goes...
17:57:24 <RageD> xD
17:59:49 <geekosaur> acowley, probably best asked in #haskell-infrastructure
18:00:19 <Welkin> hm, has anyone written a Functor instance for ((->) e)?
18:00:21 <waxjar> anyone know of a better haskell syntax file for sublime text (3)?
18:00:43 <Welkin> I'm going through the typeclassopedia exercises am having trouble with this one
18:00:59 <exio4> :t fmap
18:01:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:01:17 <Welkin> first, let's start with the data declaration
18:01:35 <Welkin> I have data Reader e a = Reader { runReader :: e -> a }
18:02:06 <exio4> :t fmap :: (a -> b) -> ((->) e) a -> ((->) e) b
18:02:07 <lambdabot> (a -> b) -> (e -> a) -> e -> b
18:02:12 <Welkin> data ((->) e) a = e -> a
18:02:25 <Welkin> they are equivalent, right?
18:02:41 <Welkin> er
18:02:46 <Welkin> data (->) e a = e -> a
18:02:53 <exio4> Welkin, yes, (->) a b == a -> b
18:03:09 <Welkin> well, I meant my implementation of it above
18:03:12 <Welkin> using Reader
18:03:46 <exio4> yes, they are
18:03:53 <Welkin> okay
18:04:06 <Welkin>  fmap g x = Reader $ \r -> g (runReader x r)
18:04:09 <Welkin> that is what I have
18:04:19 <Welkin> but I am confused about how to even test it
18:04:57 <Welkin> what is the environment e?
18:05:45 <dredozubov> Welkin: it's polymorphic, so whatever
18:05:51 <exio4> @let data Reader e a = Reader { runReader :: e -> a }
18:05:52 <lambdabot>  Defined.
18:06:12 <exio4> @let instance Functor (Reader e) where fmap g x = Reader $ \r -> g (runReader x r)
18:06:12 <lambdabot>  .L.hs:165:19:
18:06:12 <lambdabot>      Ambiguous occurrence ‘Reader’
18:06:12 <lambdabot>      It could refer to either ‘L.Reader’, defined at .L.hs:163:1
18:06:25 <exio4> @let instance Functor (L.Reader e) where fmap g x = L.Reader $ \r -> g (L.runReader x r)
18:06:26 <lambdabot>  Defined.
18:07:18 <exio4> > L.runReader (map (++ "world") (Reader ("hello"++)) " "
18:07:19 <lambdabot>  <hint>:1:55:
18:07:19 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:07:29 <exio4> > L.runReader (map (++ "world") (Reader ("hello"++))) " "
18:07:31 <lambdabot>  Couldn't match expected type ‘L.Reader [GHC.Types.Char] a’
18:07:31 <lambdabot>              with actual type ‘[[GHC.Types.Char]]’Couldn't match expected typ...
18:07:31 <lambdabot>              with actual type ‘L.Reader [GHC.Types.Char] [GHC.Types.Char]’
18:08:27 <pavonia> exio4: fmap, no?
18:08:40 <exio4> oh..
18:08:48 <exio4> > L.runReader (fmap (++ "world") (L.Reader ("hello"++))) " "
18:08:50 <lambdabot>  "hello world"
18:08:55 <exio4> thanks pavonia :P
18:10:14 <exio4> > (++ "world") . ("hello" ++) $ " "
18:10:15 <lambdabot>  "hello world"
18:10:27 <Welkin> okay
18:10:31 <Welkin> so how is this useful?
18:10:37 <Welkin> Reader just stores a function
18:11:36 <Welkin> > L.runReader (Reader show) 4
18:11:38 <lambdabot>  "4"
18:11:59 <Welkin> > L.runReader (Reader (filter even)) [1..10]
18:12:01 <lambdabot>  [2,4,6,8,10]
18:12:43 <jmcarthur> > L.runReader (Reader show >>= \str -> Reader (+1) >>= \n -> return (str ++ " " ++ show n)) 7
18:12:45 <lambdabot>  No instance for (GHC.Show.Show a0)
18:12:45 <lambdabot>    arising from a use of ‘GHC.Show.show’
18:12:45 <lambdabot>  The type variable ‘a0’ is ambiguous
18:12:58 <jmcarthur> > L.runReader (Reader show >>= \str -> Reader (+1) >>= \n -> return (str ++ " " ++ show n)) (7 :: Int)
18:12:59 <lambdabot>  No instance for (GHC.Base.Monad (L.Reader GHC.Types.Int))
18:12:59 <lambdabot>    arising from a use of ‘GHC.Base.>>=’
18:15:04 <jmcarthur> @let instance Monad (L.Reader e) where return = const; Reader f >>= g = Reader (\e -> L.runReader (g (f e)))
18:15:05 <lambdabot>  .L.hs:169:18:
18:15:05 <lambdabot>      Couldn't match type ‘b0 -> a’ with ‘L.Reader e a’
18:15:05 <lambdabot>      Expected type: a -> L.Reader e a
18:15:20 <Welkin> > L.runReader (Reader (`elem` [0,2,4..10])) 4
18:15:21 <jmcarthur> @let instance Monad (L.Reader e) where return = const; Reader f >>= g = Reader (\e -> L.runReader (g (f e)) e)
18:15:21 <lambdabot>  <hint>:1:35: parse error on input ‘..’
18:15:21 <lambdabot>  .L.hs:169:18:
18:15:22 <lambdabot>      Couldn't match type ‘b0 -> a’ with ‘L.Reader e a’
18:15:22 <lambdabot>      Expected type: a -> L.Reader e a
18:15:35 <Welkin> > L.runReader (Reader (`elem` [0,2,4,6,8,10])) 3
18:15:37 <lambdabot>  False
18:15:39 <Welkin> > L.runReader (Reader (`elem` [0,2,4,6,8,10])) 4
18:15:41 <lambdabot>  True
18:15:49 <jmcarthur> i give up. was trying to demonstrate the point and got lost in lambdabot oddities
18:16:00 <Welkin> heh
18:16:20 <Welkin> I'm just working with the functor right now
18:16:25 <jmcarthur> @let instance Monad (L.Reader e) where return = const; L.Reader f >>= g = L.Reader (\e -> L.runReader (g (f e)) e)
18:16:26 <lambdabot>  .L.hs:169:18:
18:16:26 <lambdabot>      Couldn't match type ‘b0 -> a’ with ‘L.Reader e a’
18:16:26 <lambdabot>      Expected type: a -> L.Reader e a
18:16:28 <jmcarthur> meh
18:16:42 <jmcarthur> well, fmap for Reader is exactly the same as (.)
18:16:50 <Welkin> okay
18:18:22 <Welkin> fmap g x = Reader $ g . runReader x
18:18:38 <Welkin> fmap g x = Reader $ \r -> g (runReader x r)
18:18:59 <Welkin> :t \r -> g (L.runReader x r)
18:18:59 <lambdabot>     Couldn't match expected type ‘L.Reader e a0’
18:19:00 <lambdabot>                 with actual type ‘Expr’
18:19:00 <lambdabot>     Relevant bindings include r :: e (bound at <interactive>:1:2)
18:19:32 <Welkin> :t \r -> g (k x r)
18:19:33 <lambdabot>     Couldn't match expected type ‘Expr -> t1 -> t0’
18:19:33 <lambdabot>                 with actual type ‘Expr’
18:19:33 <lambdabot>     Relevant bindings include r :: t1 (bound at <interactive>:1:2)
18:19:49 <Welkin> :t \x r -> g (k x r)
18:19:50 <lambdabot>     Couldn't match expected type ‘t1 -> t2 -> t0’
18:19:50 <lambdabot>                 with actual type ‘Expr’
18:19:50 <lambdabot>     Relevant bindings include
18:20:11 <Welkin> anyway
18:20:17 * hackagebot cabal-rpm 0.9.2 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.9.2 (JensPetersen)
18:20:49 <Welkin> does g . runReader x r === \r -> g (runReader x r)
18:21:00 <Welkin> it makes sense
18:21:22 <Welkin> :t L.runReader
18:21:23 <lambdabot> L.Reader e a -> e -> a
18:21:28 <Welkin> :t L.runReader a
18:21:29 <lambdabot>     Couldn't match expected type ‘L.Reader e a’ with actual type ‘Expr’
18:21:29 <lambdabot>     In the first argument of ‘L.runReader’, namely ‘a’
18:21:29 <lambdabot>     In the expression: L.runReader a
18:21:33 <Welkin> :t L.runReader 1
18:21:34 <lambdabot> Num (L.Reader e a) => e -> a
18:21:49 <Axman6> :t flip L.runReader 1
18:21:49 <lambdabot> Num b => L.Reader b c -> c
18:22:29 <johnw> makes sense in what sense?
18:22:57 <Welkin> johnw: that fmap for Reader is just composition (.)
18:23:27 <Welkin> Axman6: now that is more interesting
18:23:46 <johnw> fmap for ((->) r) is composition
18:24:00 <Welkin> yes
18:24:10 <johnw> Reader involves type wrapping and unwrapping
18:24:14 <Welkin> oh
18:24:38 <johnw> which is really the only difference between them
18:24:53 <Welkin> @let data (->) e a = e -> a
18:24:53 <lambdabot>  Parse failed: Illegal data/newtype declaration
18:24:58 <johnw> heh
18:25:05 <Welkin> I used Reader instead
18:25:11 <Welkin> for the name
18:27:11 <erisco> vanila, new challenge is a type set
18:28:18 <exio4> runReader is ($)
18:28:28 <exio4> > flip ($) 1
18:28:30 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
18:28:30 <lambdabot>    arising from a use of ‘M25480563159120855520721.show_M25480563159120855520...
18:28:30 <lambdabot>  The type variable ‘c0’ is ambiguous
18:28:33 <vanila> erisco, that's one I don't know how to do !
18:28:34 <exio4> :t flip ($) 1
18:28:35 <lambdabot> Num b => (b -> c) -> c
18:28:46 <vanila> but I think that Oleg et al. did this in their ext eff work maybe?
18:28:54 <vanila> it's a language feature I think we kinda need built in though
18:30:02 <erisco> I will give it a shot
18:30:07 <erisco> might look something like nub
18:41:04 <athan> How are superclass constraints different from normal ones? One thing I've noticed is that you can't really have un-used variables: `class (Foo a, Bar a b) => Baz b where` doesn't work :[
18:42:04 <erisco> vanila, it worked :o
18:42:15 <vanila> nice!
18:42:27 <jmcarthur> athan: for what purpose would you want that?
18:42:35 <jmcarthur> oh i see
18:42:46 <athan> functional dependency work-arounds
18:42:49 <erisco> @src nub
18:42:49 <lambdabot> nub = nubBy (==)
18:42:54 <erisco> @src nubBy
18:42:54 <lambdabot> nubBy eq []     = []
18:42:54 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:42:55 <athan> functional dependencies only use monomorphic types :/
18:43:14 <erisco> I will write out those functions and use that
18:43:19 <jmcarthur> that isn't true, or at least my interpretation of that sentence isn't true
18:43:34 <erisco> I just wrote Nub as the eq filter part
18:43:48 <athan> jmcarthur: Wait, actually these are two different issues ><
18:43:58 * athan is loosing his marbles D:
18:44:06 <erisco> vanila, allow me to reciprocate http://lpaste.net/116737
18:44:20 <erisco> also it would be nice to not require UndecidableInstances but alas
18:44:33 <erisco> so if you use a type family in a type family it is inherently undecidable?
18:46:53 <vanila> good night!
18:50:33 <athan> jmcarthur: Wait, so if I have a class `class Foo a b | a -> b`, can I make a `instance Bar b => Foo Mon b where...`?
18:51:16 <johnw> that would be exactly what you could *not* do
18:51:30 <athan> johnw: Thank you :)
18:51:48 <erisco> :t nub
18:51:48 <lambdabot> Eq a => [a] -> [a]
18:53:03 <erisco> partially applied type functions... is that a thing? :)
18:53:21 <johnw> absolutely
18:53:26 <johnw> Either Int
18:57:22 <heatsink> they only work with type inference when they're injective
19:00:04 <Welkin> what is a type :: * -> * that cannot be made an instance of Functor?
19:00:11 <johnw> TVar
19:00:22 <Welkin> I'm not familiar with it
19:00:26 <Welkin> why can it not?
19:00:27 <johnw> IORef
19:00:32 <Welkin> oh
19:00:33 <johnw> try to write fmap :)
19:00:48 <Welkin> :t show
19:00:49 <lambdabot> Show a => a -> String
19:00:50 <Welkin> er
19:00:53 <Welkin> :t print
19:00:54 <lambdabot> Show a => a -> IO ()
19:01:04 <Welkin> hm
19:01:11 <Welkin> IO is already a functor
19:01:18 <Welkin> :k IORef
19:01:19 <lambdabot> Not in scope: type constructor or class ‘IORef’
19:01:41 <Welkin> :k TVar
19:01:42 <lambdabot> Not in scope: type constructor or class ‘TVar’
19:01:49 <johnw> :k Data.IORef.IORef
19:01:50 <lambdabot> * -> *
19:01:59 <Welkin> @src IORef
19:01:59 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
19:02:22 <Welkin> @src TVar
19:02:22 <lambdabot> Source not found. Just try something else.
19:02:32 <johnw> @src Control.Concurrent.STM.TVar
19:02:32 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:03:39 <Welkin> why is it that they cannot be made Functors?
19:03:50 <johnw> try!
19:03:55 <johnw> it's more more meaningful
19:03:58 <johnw> much more
19:05:21 <Welkin> I don't know where to begin
19:05:24 <Welkin> what is STRef
19:05:28 <Welkin> and RealWorld
19:05:30 <johnw> instance Functor IORef where
19:05:37 <johnw> fmap f someioref = ...
19:05:59 <Welkin> I don't understand the structure of IORef
19:06:06 <johnw> it's a black box
19:06:12 <johnw> you read it with readIORef
19:06:16 <johnw> and write to it with writeIORef
19:06:42 <johnw> I think there's a modifyIORef too
19:06:49 <johnw> :t modifyIORef
19:06:50 <lambdabot>     Not in scope: ‘modifyIORef’
19:06:50 <lambdabot>     Perhaps you meant one of these:
19:06:50 <lambdabot>       ‘modifySTRef’ (imported from Data.STRef),
19:06:52 <johnw> :t Data.IORef.modifyIORef
19:06:53 <lambdabot> GHC.IORef.IORef a -> (a -> a) -> IO ()
19:06:57 <erisco> is there a tool in ghci for evaulating type families?
19:07:22 <erisco> it seems problematic when you are using DataKinds... can't really use my  undefined :: 'do type stuff'  trick
19:07:44 <athan> I wish -XOverloadedStrings included a Monoid instance :(
19:08:08 <johnw> athan: ?
19:08:27 <Welkin> how can I write fmap if it is a black box?
19:08:34 <athan> johnw: OverloadedStrings only gives you `IsString a => a` (instead of String)
19:08:35 <Welkin> I need some way to access the value inside
19:08:40 <johnw> Welkin: Now you're getting it... :)
19:08:51 <Welkin> unless I writeIORef . readIORef
19:09:40 <athan> If I had a Monoid instance included, "foo" <> "bar" <> "baz" could even get compiled to "foobarbaz" statically, soundly (pretty sure)
19:09:45 <athan> there's milzions of benefits
19:09:51 <Welkin> er
19:09:56 <simon> what's the point in type unification algorithms allowing the unification of e.g. 'a' with '[a]'? (e.g. 'let x = [] in if False then head x else x') - is this a side effect of a corner case, or are infinite types ever useful in practice?
19:09:59 <Welkin> unless I newIORef . readIORef
19:10:01 <johnw> such a thing is never statically merged
19:10:33 <johnw> simon: [] has infinitely many types
19:10:47 <johnw> i think it's inferring [[a]]
19:11:01 <athan> johnw: Either way, it gives you the ability to work with these polymorphic values instead of just look at them :S
19:11:19 <johnw> athan: but it's indepnedent of Monoid
19:11:26 <athan> what is?
19:11:28 <johnw> "foo" <> "bar" :: Text, :: String, :: ByteString
19:11:33 <johnw> with OverloadedStrings, they all work
19:11:40 <johnw> without it, it can only have type :: String
19:11:54 <athan> right, but if you had overloadedStringsAndMonoid, it would still work
19:12:00 <athan> er, sorry
19:12:03 <johnw> i don't know what you're asking for
19:12:10 <athan> with overloadedstrings, you need a monomorphic type
19:12:29 <athan> with the monoid context, too, you could work with the polymorphic type
19:12:31 <jmcarthur> Welkin: right. newIORef, readIORef, writeIORef, etc. are the ways you access the value stored in the IORef
19:12:35 <athan> and make general text-processing libs
19:13:30 <jmcarthur> Welkin: you cannot write fmap for IORefs, since that would require IO. you could, however, write something like this:   fmapIORef :: (a -> b) -> IORef a -> IO (IORef b)
19:13:40 <simon> johnw, it gives me '() -> [t]' when I package this into a function. isn't "infinitely many types" just another way of saying that it is polymorphic in one variable?
19:13:45 <jmcarthur> Welkin: but it is not a vary meaningful operation, in my opinion
19:13:49 <jmcarthur> *very
19:15:05 <simon> johnw, ah, sorry... when I used the word 'infinite types' I was actually thinking about some expansion [[[...a....]]], but I think both ML and Haskell catch this as a circularity, right?
19:15:05 <Welkin> okay
19:15:16 <Welkin> I am just going through the typeclassopedia exercises
19:15:19 <Welkin> which is why I asked
19:15:39 <Welkin> > Just . Just
19:15:40 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
19:15:41 <lambdabot>    arising from a use of ‘M138124001194032100021432.show_M1381240011940321000...
19:15:41 <lambdabot>  The type variable ‘a0’ is ambiguous
19:15:52 <Welkin> :t Just . Just
19:15:53 <lambdabot> a -> Maybe (Maybe a)
19:16:12 <Welkin> Just is a data constructor, but if its type is a Functor, is Just also a Functor?
19:16:15 <athan> > :t fix fix
19:16:16 <lambdabot>  <hint>:1:1: parse error on input ‘:’
19:16:22 <athan> :t fix fix
19:16:23 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> a
19:16:29 <lambdabot>     Expected type: (a -> a) -> a -> a
19:16:29 <lambdabot>       Actual type: (a -> a) -> a
19:16:37 <athan> :t fix . fix
19:16:38 <lambdabot> ((c -> c) -> c -> c) -> c
19:16:56 <Welkin> the specific temrinology gets confusing
19:16:58 <jmcarthur> Welkin: a type is not a Functor. a type *constructor* is. and the relevant type constructor here is Maybe, not Just.
19:17:10 <Welkin> okay
19:17:24 <jmcarthur> Welkin: that is, Just is a value/data constructor, and Maybe is a type constructor
19:17:26 <Welkin> well the typeclassopedia asks if a Functor composed with a Functor is still a Functor
19:17:32 <jmcarthur> aha
19:17:44 <Welkin> which is confusing to me
19:17:53 <jmcarthur> they mean something like this:   newtype IOMaybe a = IOMaybe (IO (Maybe a))
19:17:59 <Welkin> how can you compose a type constructor
19:18:01 <jmcarthur> is IOMaybe a Functor?
19:18:08 <Welkin> yes
19:18:10 <jmcarthur> IO and Maybe both are
19:18:30 <jmcarthur> alright, how about this more general thing?:
19:18:42 <jmcarthur> newtype Compose f g a = Compose (f (g a))
19:19:04 <jmcarthur> is this possible?    instance (Functor f, Functor g) => Functor (Compose f g) where ...
19:19:38 <Welkin> wait, in your IOMaybe example, how is Maybe on the right side of the equation?
19:19:47 <jmcarthur> Welkin: because that
19:19:54 <Welkin> it is not a data constructor
19:19:55 <jmcarthur> Welkin: because that's how i designed the newtype. it's mine
19:20:06 <Welkin> I thought newtype was equivalent to a data declaration with one field
19:20:11 <jmcarthur> yeah
19:20:14 <jmcarthur> basically
19:20:21 <jmcarthur> and the one field has type  IO (Maybe a)
19:20:29 <Welkin> ah
19:20:30 <Welkin> okay
19:20:44 <athan> How do people _make_ GHC extensions?
19:20:51 <athan> I'm guessing it's easy? Plug & play?
19:21:03 <jmcarthur> athan: do you want an answer beyond "by modifying GHC"?
19:21:36 <athan> jmcarthur: Yes plez 'u'
19:21:36 <jmcarthur> athan: i don't think it's quite *that* modular
19:21:36 <Welkin> jmcarthur: about Compose, it looks possible
19:21:42 <jmcarthur> Welkin: well, that's basically what i think they are probably asking
19:21:58 <jmcarthur> Welkin: if f and g are functors then Compose f g is the composition of those functors
19:22:18 <athan> :t runCompose
19:22:19 <lambdabot> Not in scope: ‘runCompose’
19:22:58 <jmcarthur> Welkin: similarly, we can construct pairs and sums of functors:   data Pair f g a = Pair (f a) (g a)    data Sum f g a = FLeft (f a) | FRight (g a)
19:22:58 <athan> `type Compose f g = forall x. g (f x)`?
19:23:15 <jmcarthur> athan: i gave it earlier, but yeah, roughly that
19:23:23 <athan> oh woah
19:23:38 <athan> jmcarthur: Sorry, I'll stay quiet :)
19:27:49 <erisco> mkay, not sure why this does not type check http://lpaste.net/116740
19:28:04 <erisco> I have tried adding explicit annotation for :.: as well but no dice
19:28:36 <erisco> I don't know why it cannot figure out the type  (:.:) Not (Equal Int) Int
19:29:06 <erisco> well, the kind rather
19:29:53 <erisco> uh, no the type
19:30:04 <erisco> it should get to the type False
19:31:49 <johnw> athan: newtype Compose f g a = Compose { getCompose :: f (g a) }
19:34:08 <athan> crap, TemplateHaskell can't handle constraint expressions, can it?
19:34:56 <athan> ...nevermind ._.
19:35:09 <dspies> Can I add +RTS options from within a .hs file?
19:36:36 <johnw> no
19:36:44 <johnw> that's a runtime option, not a compile-time option
19:36:50 <johnw> you can bake them into your executables within the .cabal file, though
19:36:52 <erisco> is this a bug?
19:37:13 <johnw> for example: ghc-options: -with-rtsopts "-K1000M"
19:38:55 <mjo> dspies: depends, what do you want to do? If you want to e.g. mimit +RTS -N, you can use getNumProcessors and setNumCapabilities
19:39:06 <dspies> When a program uses too much stack space (and I'm not allowed to add the -K option either at compile-time or run time, I only have access to the Main.hs file), is there a general approach to make it use heap space instead?
19:39:07 <mjo> e.g. mimiC
19:39:19 <johnw> dspies: no
19:39:45 <erisco> if I type > 'x' :: See ((Not :.: Equal Int) Int)    into ghci it returns 'x' which is correct
19:39:45 <johnw> dspies: Haskell does not use stack the same way that many other languages use stack
19:40:01 <erisco> why does it type check in ghci
19:40:27 <johnw> dspies: if you are using too much stack space, it's because you have too many partial deconstruction pending at one time, which almost always represents a problem in your code
19:40:44 <dspies> johnw: partial deconstruction?
19:40:57 <johnw> so, say I have a data structure value named 'x'
19:40:57 <johnw> and I do:
19:41:09 <johnw> case x of Foo y z -> fun y
19:42:00 <johnw> wait, let me find a better example
19:42:07 <erisco> am I doing this? I am blaming the compiler? fine
19:42:13 <dspies> johnw: ok
19:43:17 <erisco> can you not use guest/guest on the trac anymore?
19:43:18 <johnw> let's say we're doing a foldl
19:43:22 <dspies> johnw: ok
19:43:30 <johnw> we start with foldl (+) 0 [1..]
19:43:46 <johnw> then we have foldl (+) (0+1) [2..]
19:43:54 <erisco> > (!!6) $ scanl (*) 1 [1..]
19:43:54 <johnw> then foldl (+) (0+1+2) [3..]
19:43:56 <lambdabot>  720
19:44:02 <johnw> this ever-growing expression needs to live somewhere
19:44:09 <johnw> it gets put into a temporary memory region called the stack
19:44:21 <johnw> if it gets too big before being evaluated, the stack is exhausted
19:44:38 <dspies> johnw: Right, I've seen this example.  But if the list already lives in memory, then it's just a constant factor.  Making the sum strict is not crucial
19:45:00 <johnw> it's not the list blowing the stack, but the 0+1+2...
19:45:29 <erisco> of course I am getting about 100bits/s on my 20Mbit connection right now
19:45:35 <dspies> johnw: right, but that big thunk is not going to be significantly larger than the list itself
19:45:40 <johnw> we're building up an intermediary value without collapsing it through evaluation
19:45:45 <nshepperd> I thought haskell only used the heap anyway
19:45:52 <johnw> it's a bit larger , since the list won't exist in memory at all
19:46:07 <johnw> GHC will have optimized it down to a for loop
19:46:19 <thoughtpolice> nshepperd: stacks are allocated on the GC'd heap, actually, and they're GC'd just like normal objects.
19:46:26 <johnw> there we go
19:46:35 <johnw> they simple have fixed size
19:46:37 <johnw> simply
19:46:38 <dspies> johnw: Of course, if the list is lazily constructed and quickly consumed, then you're right.  But if it's already constructed, that's different
19:46:52 <johnw> but in the foldl case, it's not constructed atall
19:46:52 <johnw> yet we still blow stack
19:47:05 <johnw> the expression we're building up just keeps getting bigger
19:47:38 <johnw> and in general, this is the problem: your code is building up something that is left unevaluated in certain places for too long, until stack is blown
19:48:15 <johnw> so the answer is generally to either (a) make the algorithm *more* lazy, so that it doesn't build up so much at once, or (b) add strictness annotations to force earlier evaluations
19:48:23 <nshepperd> that's what i thought. so do we really run out of stack? or just run out of memory?
19:48:24 <dfeuer> Ping ReinH
19:49:23 <johnw> nshepperd: you run out of the stack region allocated for your function evaluation
19:51:03 <nshepperd> so there's like a fixed limit to the length of a chain of dependent evaluations?
19:51:13 <johnw>  you can think of any Haskell expression is a recipe.  If that recipe has simply too many instructions in it, it overwhelms the chef.   So we either have to provide a shorter recipe, or we have to break it up into multiple recipes so that the scope is not so daunting
19:52:09 <dspies> johnw: Then why do later versions of ghc do away with that limit?
19:52:34 <dspies> johnw: In 7.6.3 it's 8M, whereas in 7.8.3 it's 80% physical memory
19:53:03 <dspies> johnw: If consuming too much stack space is always a sign you're doing the wrong thing, shouldn't they have left it?
19:53:06 <johnw> thoughtpolice would know better, but I think mainly it's because 8 MB was an arbitrary limit
19:53:38 <johnw>  it does help for finding out when you have a problem in your code, however, instead of having to rely on detecting whether your system has started swapping or not
19:54:08 <dspies> johnw: I'm specifically talking about using too much stack space, not using too much memory
19:54:15 <johnw> me too
19:54:18 <johnw> i like the 8M stack limit
19:54:35 <johnw> I've only once legimitately needed 16M
19:54:52 <johnw> otherwise, I usually need around 1-2M tops
19:55:05 <HeladoDeBrownie> johnw, I'm curious what that was for
19:55:10 <johnw> the 16M?
19:55:17 <HeladoDeBrownie> Yeah
19:55:43 <johnw>  one sec, let me read over the code and refresh my mind as to why couldn't work around
19:56:19 <dspies> johnw: Okay, I'll be more specific about my case where I think I have a legitimate need for stack space
19:56:35 <johnw> it was a filesystem traversal utility, and I was unable to find a way to reduce it to constant space
19:56:51 <johnw> I remember discovering the root cause of the problem, but the memory has left me now
19:56:52 <dspies> johnw: I want to do a topological sort of a directed acyclic graph.  In the worst case, it seems I need to put all the vertices on the stack
19:56:54 <russmuss> Does anyone know a place where I can get a free number to receieve a text?
19:57:18 <johnw> russmuss: that is an inappropriate question here
19:58:00 <johnw> dspies: I'm still not entirely clear about whether you're talking about stack space or heap space
19:58:10 <dspies> johnw: stack space
19:58:18 <johnw> pulling in all the verses of the graph should be a heap issue, why is it the stack issue?
19:59:16 <dspies> johnw: one sec, I'll post some code
20:07:48 <thoughtpolice> dspies: consuming too much stack space is not 'the wrong' thing; you can very legitimately use more than 8MB in stack. where the limit goes is ultimately arbitrary; but for example, very simple programs that do things like 'replicateM oneHundredThousand someIOAction >>= \xs -> ...', or an equivalent with mapM, will overflow. there is an argument this makes it harder to spot 'wrong' programs that use ridiculous stack space, but I'm not sure ho
20:07:59 <thoughtpolice> i probably got cut off there
20:08:12 <thoughtpolice> dspies: anyway, if you want to look at the motivation, see GHC ticket #8189
20:11:47 <erisco> okay, before I post a bug to ghc I will ask again with an even further reduced reproduction
20:11:49 <erisco> here it is http://lpaste.net/116742
20:12:01 <benzrf> thoughtpolice: hmm, what
20:12:10 <benzrf> thoughtpolice: won't that fold it so that you never need to allocate the whole list
20:12:16 <benzrf> @src replicateM
20:12:17 <lambdabot> replicateM n x = sequence (replicate n x)
20:12:23 <benzrf> @src sequence
20:12:23 <lambdabot> sequence []     = return []
20:12:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:12:23 <lambdabot> --OR
20:12:23 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
20:12:33 <benzrf> hmm..
20:12:56 <erisco> 100 Internet points to anyone who can tell me why type check fails
20:13:00 <benzrf> thoughtpolice: it doesnt perform the reduction within the do block so it closes over the list?
20:13:10 <erisco> I have them all here in cash
20:13:51 * dfeuer is getting a bit impatient.
20:14:01 * johnw hands dfeuer a finger sapling
20:14:06 * dfeuer should try to get more patient.
20:14:11 <dfeuer> johnw, awww, thanks.
20:14:22 <treats> would you guys get upset if i plug a puzzle real quick?
20:14:30 <treats> everyone is stuck.
20:14:35 <glguy> As long as it's a Haskell puzzle, go for it
20:14:36 <johnw> is it a Haskell puzzle?
20:14:45 <carter> dfeuer: narrate your problems here
20:14:46 <dfeuer> Or a functional programming puzzle, ;i guess.
20:14:53 <treats> it's not haskell. i just saw this was a popular channel.
20:14:53 <carter> i'll interject randomly
20:14:56 <carter> and other people will too
20:15:29 <johnw> treats: we don't want any old random puzzle
20:15:29 <dfeuer> Very unfocused that way. I'm starting with a "rigid" 2-3 finger tree.
20:15:54 <dfeuer> That is, a Hinze-Paterson tree restricted to having 2 and 3 digits at the top and 1 and 2 digits elsewhere.
20:16:13 <treats> it's new. they've been posting clues daily since Monday.
20:16:25 <dfeuer> Also, another finger tree representing a sequence of functions.
20:16:32 <johnw> it sounds like this is not in any way Haskell-related, treats
20:16:59 <treats> you're right. it's just a puzzle that no one in this channel can figure out. i'll fuck off now.
20:17:16 <dfeuer> The main tree of interest for this, however, has, like any such finger tree, two sides.
20:17:27 <treats> no one in the puzzle channel, that is.
20:17:39 <Welkin> treats: you can ask in #haskell-blah
20:17:55 <treats> welkin: cool, thanks. i'll check it out.
20:18:16 <dfeuer> Start off by copying this main tree, making three copies.
20:18:32 <dfeuer> It can actually start with just two copies, but three is easier to think about.
20:18:58 <dfeuer> So we have six "tree sides" to begin with.
20:19:29 <thoughtpolice> benzrf: I have no idea what you mean. think about what mapM does based on its type signature: (a -> m b) -> [a] -> m [b]. you have 'a -> m b' and many 'a'. a regular map can turn those into 'm b', but *not* 'm [b]'. the only way to get the [b] is to sequence the m b's together to construct the list.
20:19:29 <carter> huh
20:19:45 <dfeuer> Now start building a new finger tree. At each step, take the left digit of the leftmost left side and the right digit of the rightmost right side.
20:19:56 <thoughtpolice> er, I said 'mapM', but the same can be said of replicateM - they both use 'sequence' underneath
20:20:00 <carter> dfeuer: this is for <*>
20:20:01 <carter> ?
20:20:10 <dfeuer> All the rest of the digits get "crushed down", turning the digits below them into 2-3 digits.
20:20:12 <dfeuer> Yes, carter.
20:20:59 <dfeuer> So finally you get to a finger tree with two Deep pieces and then either an Empty or a Single.
20:21:20 <dfeuer> At that point, things get juggled around at the bottom.
20:22:04 <carter> haveyou written the case for the botton bit?
20:22:12 <carter> cause hopefully thats the easy part
20:22:18 <dfeuer> The effect of this juggling is that one entire copy of the tree ends up in the leftmost right side.
20:22:26 <dfeuer> And one entire copy in the rightmost left side.
20:22:54 <dfeuer> Or... I may be mixing up copies, or not having enough.
20:23:09 <dfeuer> carter, I think that's actually the hard part.
20:23:12 <dfeuer> Lots of cases there.
20:23:40 <carter> any way you could write code to generate that code?
20:23:51 <dfeuer> There probably is, but I don't know how.
20:23:52 <carter> or at least enumerate teh cases?
20:23:57 <carter> strings and ++
20:24:02 <dfeuer> ?
20:24:10 <dfeuer> Hmm.
20:24:15 <hunter_> how do you get proper vim haskell syntax highlighting
20:24:22 <hunter_> whats the generally accepted way
20:24:43 <glguy> :set filetype=haskell
20:24:51 <hunter_> yes glguy
20:24:53 <dfeuer> glguy, it's pretty unreliable.
20:24:57 <hunter_> when i say proper i mean good
20:25:02 <hunter_> the default is not very good
20:25:05 <dfeuer> No, it's crap.
20:25:11 <dfeuer> I've been putting up with it.
20:25:22 <dfeuer> But it can't keep track very well.
20:25:23 <Welkin> try emacs
20:25:27 <hunter_> Welkin: no
20:25:30 <Welkin> haskell-mode is pretty good
20:25:36 <hunter_> im a vimmer
20:25:47 <Welkin> so you follow a religious dogma
20:26:11 <hunter_> no
20:26:14 <hunter_> i like vim
20:26:14 <Welkin> it's justa tool
20:26:16 <Welkin> not a way of life
20:26:20 <glguy> No, he used an editor. Don't turn this into an editor battle please
20:26:27 <hunter_> i know welkin
20:26:27 <hunter_> i like it more
20:26:53 <Welkin> okay, well if you want good syntax highlighting, haskell-mode on emacs is good
20:27:00 <hunter_> anyone else who uses vim, how do you fix the syntax highlighting
20:27:21 <dfeuer> hunter_, let me know if you find out, please.
20:27:29 <glguy> It's probably more productive to say what it is you're trying to change about it
20:27:51 <hunter_> dfeuer: just so you know there are existing fixes but i dont know which ones are good
20:27:52 <dfeuer> glguy, it loses track of what's what. So it will highlight comments as code and code as comments sometimes.
20:28:12 <hunter_> glguy: it does almost no highlighting
20:28:15 <Welkin> I believe there are vim bindings for emacs as well
20:28:17 <dfeuer> That's *my* biggest gripe with it.
20:28:18 <Welkin> so that is an option
20:28:21 <glguy> Yeah, large multiple line comments confuse vim
20:28:41 <glguy> I find ^L helps :(
20:28:53 <tnks> I use Evil with Emacs, and I love it.
20:29:07 <dfeuer> Emacs has approximately the most confusing user interface in history, even compared to vim :-(
20:29:13 <tnks> best of all words so far as I can tell.
20:29:29 <tnks> (well, no types in elisp, but I'll take that over vimscript)
20:29:44 <glguy> But what kind of stuff do you want to add highlighting for?
20:29:52 <glguy> Maybe we can figure it out
20:30:20 <hunter_> glguy: im not really sure whats possible, but the majority of a functions body is all the same color
20:30:44 <glguy> That makes sense. Why would functions be different?
20:30:45 <hunter_> glguy: id like to have the definition be a different color than the body
20:33:26 <dspies> johnw: okay, sorry i took so long
20:33:31 <dspies> johnw: here it is
20:33:34 <lpaste> dspies pasted “topo-sort” at http://lpaste.net/116744
20:33:49 <gcganley> whats the name of a function that takes a list and splits it into a list of list of the same length
20:34:04 <gcganley> kind of like chunking
20:34:12 <glguy> On the bright side it doesn't arbitrarily highlight a handful of the prelude functions
20:34:30 <glguy> chunksOf
20:34:50 <glguy> Data.List.Split
20:34:53 <dfeuer> Yes, arbitrarily highlighting prelude functions is obnoxious. They are not special.
20:34:53 <heatsink> I think it's in the split package
20:34:58 <hunter_> glguy theres definitely something more it should be doing
20:35:03 <hunter_> glguy because its not making it very easy to read
20:35:07 <hunter_> glguy but im not sure what
20:35:25 <dspies> johnw: Consider what happens when the graph is just a chain: lb -> (lb+1) -> (lb+2)..-> ub
20:35:28 <dfeuer> Syntax highlighting is an art.
20:35:41 <dspies> johnw: Then the entire graph has to be put on the stack, doesn't it?
20:35:49 <gcganley> it should have type (Integer -> [a] -> [[a]])
20:35:51 <dspies> johnw: Is there a way to avoid that?
20:36:08 <gcganley> im trying to find it on hoogle
20:36:43 <johnw> dspies:   But why would you need to be put on the stack?
20:36:49 <johnw> s/you/it
20:36:57 <heatsink> gcganley: http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html#v:chunksOf
20:37:14 <johnw> Are you thinking of the runtime stack in the sense of a programming language like C?
20:37:54 <dspies> johnw: because sortDescend 1 calls sortDescend 2 which calls sortDescend 3 etc. so you end up building up the thunk (1 : (2 : (3 : (4 : (5 : ... (n-1 : sortDescend n)))))...)
20:38:07 <johnw> ah, I didn't know about sortDescend
20:38:18 <glguy> Hunter_: is this what yours looks like? http://www.galois.com/~emertens/solarized.png
20:38:18 <johnw> would it build up such a thunk?
20:38:24 <johnw> I would think it would build: 1 : <thunk>
20:38:30 <gcganley> heatsink, glguy: thank you
20:39:17 <dspies> johnw: Now I'm not sure.  I should have just used my actual example
20:39:27 <dspies> johnw: But this one's so much smaller
20:39:59 <dspies> johnw: Yeah, I guess because (:) is a constructor, it's not a problem
20:40:24 <dspies> johnw: That wasn't meant to be an emoticon, it's ( : )
20:42:15 <johnw> :)
20:42:50 <dspies> johnw: Ok here's my actual program. It's a solution to https://open.kattis.com/problems/digicomp2
20:43:20 <lpaste> dspies pasted “Actual program” at http://lpaste.net/116745
20:43:41 <johnw> where is your code that is currently blowing stack?
20:44:11 <dspies> johnw: It's either countFor or makeCount
20:44:18 <dspies> (inside makeCounts)
20:44:45 <johnw> every time people have stack issues, almost always tuples are involved :)
20:46:54 <dspies> johnw: Not really.  I don't think the tuples have anything to do with it
20:47:10 <johnw> just remarking on something that may not matter
20:48:17 <johnw> dspies: perhaps try this:
20:49:14 <johnw> no, never mind
20:50:02 <johnw> dspies: can I have your data set?
20:50:05 <johnw> i'd like to analyze this myself
20:50:16 <erisco> ugh, stupid Internets
20:50:34 <erisco> did anyone have a solution to http://lpaste.net/116742 ?
20:50:46 <erisco> I seemingly have found yet another bug too
20:50:48 <dspies> johnw: Look at http://challenge.csc.kth.se/2013/
20:51:05 <dspies> johnw "Packaged problems"
20:51:12 <johnw> great
20:51:34 <johnw> which set?
20:51:50 <dspies> digicomp2
20:52:13 <dspies> I think the first one that fails is number 22 or 23
20:52:18 <erisco> here is the other type checking problem http://lpaste.net/116746
20:52:23 <johnw> hmm?
20:52:35 <johnw> i don't have a digicomp2 in what I downloaded
20:52:44 <dspies> johnw: oh oops
20:52:50 <dspies> johnw: wrong competition
20:52:57 <johnw> can you link me to the file I should be using?
20:53:49 <dspies> johnw: Sure
20:53:56 <dspies> johnw: I just need to upload it somewhere
20:57:09 <dspies> johnw: here it is: http://www.filedropper.com/22bigladderordered
20:57:29 <johnw> excellent
20:57:44 <russypoo> what is this
20:57:50 <johnw> i see a bunch of L's and R's
20:58:49 <dspies> johnw: yes, but eventually (if you're using GHC 7.6.3) it runs out of stack space
20:58:49 <johnw> it even runs within 1M of stack...
20:59:03 <johnw> it finishes in 10k of stack
20:59:28 <dspies> johnw: something strange is going on then
20:59:32 <dspies> johnw: Try this one
21:01:34 <dspies> john: ... (I should probably gzip these files before uploading them)
21:01:48 <dspies> johnw: http://www.filedropper.com/21biglinesshuffled
21:02:13 <johnw> also works within 1k of stack
21:02:17 <johnw> (using 7.8.3)
21:02:31 <johnw> I'm running: ./foo -K1k < ./21_big_lines_shuffled.in
21:02:37 <johnw> and see a bunch of LRRRLLLRRR type output
21:02:43 <dspies> johnw: Oh yeah, I know 7.8.3 does a much better job of optimizing.  You have to run it on 7.6.3
21:02:51 <johnw> i can't run 7.6.3, sadly
21:02:59 <johnw> will -O0 reproduce this perhaps?
21:03:04 <dspies> johnw: maybe?
21:03:07 <joe9> from here http://www.stephendiehl.com/what/#prelude, I gather that it is not a good idea to use some functions of Prelude, etc. Is there an automatic way to hide away those functions so I do not have to add it to each file?
21:03:18 <johnw> no, that works too
21:03:38 <johnw> so, I guess I cannot help, sorry
21:06:17 <dspies> johnw: In any case, can you see why the program might be using stack space?
21:09:05 <trap_exit> any good haskell deep learning tutorials
21:09:42 <dspies> johnw: I'm running it on 7.8.3 and it certainly runs out of memory
21:09:50 <hunter_> whats the preferred way to install an executable with cabal?
21:09:59 <dspies> johnw: Are you sure you're using +RTS -Kn properly?
21:10:08 <tnks> hunter_: I make a sandbox.
21:10:14 <tnks> and install into that sandbox.
21:10:30 <tnks> then symlink into where it's installed.
21:10:37 <tnks> from somwhere on my path.
21:10:46 <johnw> dspies: if I had to guess, I'd say it's because of the recursive nature of makeCounts, since the entire array must be built in order for elems to have any answer, but that's just a guess
21:10:56 <johnw> dspies: oh, whoops
21:11:16 <johnw> yay, it failed!
21:11:20 <johnw> cool, examining
21:12:06 <hunter_> guys
21:12:15 <hunter_> should i install hasktags via cabal or via pacman
21:12:21 <tnks> hunter_: cabal.
21:12:32 <hunter_> tnks: im worried about inducing cabal hell
21:12:36 <tnks> hunter_: but use a sandbox.
21:12:57 <hunter_> tnks: how do i install in a sandbox but then install the final executable to the proper bin?
21:13:04 <tnks> cabal sandbox init; cabal install <package>
21:13:13 <tnks> in some fresh directory.
21:13:18 <hunter_> tnks: wont the executable install into the sandbox?
21:13:33 <tnks> yeah, but it will be in a deterministic spot.
21:13:40 <hunter_> tnks: so i just move it?
21:13:47 <tnks> I prefer symlinks.
21:13:52 <hunter_> good idea
21:14:04 <tnks> so I have a directory on my path called ~/src/cabal/bin
21:14:28 <tnks> and I have ~/src/cabal/bin/hoogle pointing to ~/src/cabal/packages/hoogle/.cabal-sandbox/bin/hoogle
21:14:40 <erisco> trap_exit, my one line deep learning example is 'uncurry id'
21:14:56 <tnks> along with a whole bunch of other symlinks to other binaries.
21:14:59 <trap_exit> :t uncurry
21:14:59 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:15:12 <johnw> dspies: it seems you are running into the replicateM problem that thoughtpolice mentioned before
21:15:13 <trap_exit> :t (uncurry id)
21:15:14 <lambdabot> (b -> c, b) -> c
21:15:18 <johnw> it's the call to readVert that fails with -K8M
21:15:41 <johnw> rather, replicateM m readVert
21:15:44 <hunter_> do you guys use codex?
21:16:02 <dspies> johnw: Sorry, what's the replicateM problem?
21:16:22 <johnw> 22:05 <thoughtpolice> dspies: anyway, if you want to look at the motivation, see GHC ticket #8189
21:17:49 <erisco> > (+1) `id` (+2) `id` (+3) $ 0 -- this is your hint trap_exit
21:17:51 <lambdabot>  No instance for (GHC.Show.Show a0)
21:17:51 <lambdabot>    arising from a use of ‘M104432045688143068123355.show_M1044320456881430681...
21:17:51 <lambdabot>  The type variable ‘a0’ is ambiguous
21:18:04 <erisco> > (+1) `id` (+2) `id` (+3) $ (0 :: Int) -- this is your hint trap_exit
21:18:05 <lambdabot>  No instance for (GHC.Num.Num
21:18:05 <lambdabot>                     ((GHC.Types.Int -> GHC.Types.Int)
21:18:05 <lambdabot>                      -> GHC.Types.Int -> GHC.Types.Int))
21:18:09 <erisco> mkay wut
21:18:37 <erisco> I am probably remembering something else
21:18:45 <erisco> > (+1) `id` 0
21:18:45 <hunter_> erisco: id takes one argument no?
21:18:46 <lambdabot>  1
21:18:51 <erisco> that is what I meant
21:18:54 <hunter_> how are you using id like tha
21:18:55 <hunter_> t
21:19:06 <erisco> see! deep learning example :)
21:19:16 <trap_exit> wtf does any of this have to do with deep learnin g?
21:19:44 <jle`> hunter_: write it out in prefix, add the right parentheses, and then simply evaluate like normal :)  evaluate through substitution.  id x = x.  whenever you see "id x", replace with "x"
21:19:55 <erisco> well, I consider learning type unification important because it helps you understand more complicated types
21:20:25 <dspies> johnw: Wait, I'm sure this isn't the first time I've used replicateM to read in a large list of values.  Why haven't I have any problems before?
21:20:38 <heatsink> What is deep learning?
21:21:08 <erisco> and that in turn helps you design programs more simply because common patterns become more obvious
21:21:15 <dspies> johnw: Also, how did you know that was the problem?  All the profiling stuff I've done has pointed to makeCount and countFor as the culprits
21:21:29 <johnw> i used putStrLn to put print statements between every line in main
21:21:41 <hunter_> jle`: ok
21:21:41 <johnw> it never gets to "let vpar"
21:21:52 <hunter_> jle`: i just didnt know `` = postfix i thought `` = infix
21:22:23 <jle`> it does
21:22:27 <jle`> x `f` y = f x y
21:23:24 <jle`> so re-write it out in the "normal" prefix form :)
21:23:46 <erisco> > ($) `id` ($) `id` ($) `id` 0
21:23:47 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
21:23:47 <lambdabot>    arising from a use of ‘M358886078964891059923475.show_M3588860789648910599...
21:23:47 <lambdabot>  The type variable ‘b0’ is ambiguous
21:23:52 <erisco> what do I keep doing :(
21:24:15 <jle`> what are you expecting that to do?
21:24:16 <erisco> > ($) `id` ($) `id` ($) `id` id 0
21:24:18 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
21:24:18 <lambdabot>    arising from a use of ‘M318462318410711053823499.show_M3184623184107110538...
21:24:18 <lambdabot>  The type variable ‘b0’ is ambiguous
21:24:46 <jle`> also mind your precedences/fixities
21:24:57 <erisco> thanks
21:25:03 <erisco> > ($) `id` ($) `id` ($) `id` id $ 0
21:25:05 <lambdabot>  0
21:25:24 <erisco> there we go! that is the fun I was after... just need stuff of type (a -> a) -> a -> a
21:26:43 <erisco> well, (a -> b) -> a -> b will do :D
21:28:26 <erisco> > (. (+1)) `id` (. (+2)) (+3) $ 0  -- this one does some work at least
21:28:27 <lambdabot>  6
21:29:41 <erisco> also, define foldr using foldl and vice versa for another good challenge
21:32:21 <Welkin> > foldr ((:) . f) [] [1..10] :: Expr
21:32:23 <lambdabot>  Couldn't match type ‘[b0]’ with ‘Debug.SimpleReflect.Expr.Expr’
21:32:23 <lambdabot>  Expected type: b0
21:32:23 <lambdabot>                 -> Debug.SimpleReflect.Expr.Expr -> Debug.SimpleReflect.Expr....
21:32:41 <Welkin> > foldr (f) [] [1..10] :: Expr
21:32:43 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
21:32:43 <lambdabot>              with actual type ‘[t0]’
21:32:56 <Welkin> > foldr (f) [] [1..10] :: [Expr]
21:32:57 <matematikaadit> > foldr (f) [] [1..10] :: [Expr]
21:32:57 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr
21:32:58 <lambdabot>                     [Debug.SimpleReflect.Expr.Expr])
21:32:58 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
21:32:58 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr
21:32:58 <lambdabot>                     [Debug.SimpleReflect.Expr.Expr])
21:32:59 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
21:33:04 <Welkin> damn it
21:33:08 <Welkin> how do you use this thing again
21:33:16 <matematikaadit> > foldr ((:) . f) [] [1..10] :: [Expr]
21:33:16 <Welkin> > foldr (f) [] [1..10]
21:33:17 <lambdabot>  [f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10]
21:33:18 <lambdabot>  No instance for (GHC.Show.Show t0)
21:33:18 <lambdabot>    arising from a use of ‘M875572841471413479023766.show_M8755728414714134790...
21:33:18 <lambdabot>  The type variable ‘t0’ is ambiguous
21:33:22 <Welkin> hm
21:33:36 <matematikaadit> > foldr ((:) . f) [] [1..10] :: [Expr]
21:33:38 <lambdabot>  [f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10]
21:33:45 <Welkin> > foldr (f) g [1..10]
21:33:46 <lambdabot>  No instance for (GHC.Show.Show a0)
21:33:46 <lambdabot>    arising from a use of ‘M769493206641054911423790.show_M7694932066410549114...
21:33:46 <lambdabot>  The type variable ‘a0’ is ambiguous
21:33:57 <Welkin> > foldr f g [1..3]
21:33:59 <lambdabot>  No instance for (GHC.Show.Show a0)
21:33:59 <lambdabot>    arising from a use of ‘M694088475598909766923814.show_M6940884755989097669...
21:33:59 <lambdabot>  The type variable ‘a0’ is ambiguous
21:34:05 <Welkin> > foldr f g [1..3] :: Expr
21:34:06 <lambdabot>  f 1 (f 2 (f 3 g))
21:34:09 <Welkin> there we go
21:34:25 <Welkin> > foldr (++) g [1..3] :: Expr
21:34:26 <lambdabot>  Couldn't match type ‘[a0]’ with ‘Debug.SimpleReflect.Expr.Expr’
21:34:26 <lambdabot>  Expected type: [a0]
21:34:26 <lambdabot>                 -> Debug.SimpleReflect.Expr.Expr -> Debug.SimpleReflect.Expr....
21:35:18 * hackagebot colors 0.3 - A type for colors  http://hackage.haskell.org/package/colors-0.3 (FumiakiKinoshita)
21:35:44 <Welkin> > foldr (++) [] [1..10]
21:35:45 <lambdabot>  can't find file: L.hs
21:35:56 <Welkin> > foldr (:) [] [1..10]
21:35:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:36:24 <Welkin> > foldr (++) "" "lambdabot"
21:36:25 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
21:36:25 <lambdabot>  Expected type: [[GHC.Types.Char]]
21:36:25 <lambdabot>    Actual type: [GHC.Types.Char]
21:37:09 <Welkin> > foldr (++) "" $ fmap show "lambdabot"
21:37:10 <lambdabot>  "'l''a''m''b''d''a''b''o''t'"
21:37:22 <Welkin> > foldr (++) [] $ fmap show "lambdabot"
21:37:23 <lambdabot>  "'l''a''m''b''d''a''b''o''t'"
21:37:33 <Welkin> > foldr (:) [] $ fmap show "lambdabot"
21:37:34 <lambdabot>  ["'l'","'a'","'m'","'b'","'d'","'a'","'b'","'o'","'t'"]
21:38:25 <erisco> Welkin, hm, if are you trying to get to foldl you'll need to do something different
21:38:31 <Welkin> no
21:38:41 <Welkin> I am looking at the difference between : and + as folding functions
21:38:47 <Welkin> and (++)
21:38:54 <erisco> ah
21:39:00 <erisco> well either way, this is helpful
21:39:17 <erisco> > foldr (:) [] [m,n,o]
21:39:18 <lambdabot>  [m,n,o]
21:39:31 <erisco> > foldl (flip (:)) [] [m,n,o]
21:39:32 <lambdabot>  [o,n,m]
21:39:49 <erisco> I don't know why or how, but lambdabot is simply amazing
21:39:57 <hunter_> does codex work with sandbox cabal files
21:40:05 <Welkin> I say this because the Monad instance for lists is implemented as foldr (++)
21:40:18 * hackagebot stackage 0.2.1.0 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.2.1.0 (MichaelSnoyman)
21:40:19 <Welkin> er, >>= is
21:40:43 <hunter_> i think codex isnt working with sandboxes
21:41:20 <Welkin> > foldr (:) [] [m,o,n]
21:41:21 <lambdabot>  [m,o,n]
21:41:23 <Welkin> > foldr (++) [] [m,o,n]
21:41:25 <lambdabot>  Couldn't match expected type ‘[a]’
21:41:25 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
21:41:25 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
21:41:36 <Welkin> > foldr (++) [] [[m],[o],[n]]
21:41:38 <lambdabot>  [m,o,n]
21:41:57 <hunter_> how do i upload my sandboxed package to hackage?
21:42:57 <Welkin> I see, because for m >>= k, k :: a -> m b
21:44:46 <hunter_> is there a cabal command for adding a liscence?
21:44:58 <jle`> touch LICENSE
21:45:00 <jle`> that's mine heh.
21:45:14 <jle`> warning: ianal
21:45:27 <Welkin> it's the default license
21:45:30 <Welkin> the empty one
21:47:48 <hunter_> for the license field
21:47:53 <hunter_> how would i specify mit license
21:47:54 <toblerone> Hi all I have a question about concurrency and STM, this snippet should (i think) print 1 every 100 milliseconds 4 times
21:47:55 <toblerone> http://lpaste.net/116747
21:47:58 <hunter_> like what would the exact text be
21:48:15 <toblerone> I find it only prints a single time though, is this due to laziness?
21:48:49 <jle`> hunter_: the license field is for the filename of the license
21:49:04 <jle`> and then you would just copy/paste whatever license you want at that location in your project
21:49:37 <hunter_> jle`: cabal seems to have generated a field called license-file
21:49:41 <hunter_> jle`: which points to the file
21:49:47 <hunter_> jle`: are you sure thats what license is?
21:50:45 <johnw> toblerone: instrument it with some prints
21:51:07 <toblerone> johnw: sorry, I'm not sure what you mean
21:51:13 <johnw> putStrLn "got here", etc.
21:51:17 <toblerone> ah
21:51:18 <toblerone> ok
21:51:19 <johnw> see why it stops
21:54:37 <toblerone> johnw: eep. stupid mistake was the cause
21:54:39 <toblerone> : )
21:55:18 * hackagebot steambrowser 0.1.0.0 - List and launch steam games from the cli  http://hackage.haskell.org/package/steambrowser-0.1.0.0 (hunteriam)
21:55:18 <toblerone> thanks
21:56:36 <hunter_> mah package
21:59:24 <sgronblo> today i was thinking, there seems to be four levels of proofs that you can do for programs ordered by strength as follows: type check, unit test, quick check type property checking, formal proofs like proof by induction for example. agree? disagree?
22:00:57 <Axman6> I'd argue that type checking is more powerful than unit testing; unit testing says that for this specific case I get the result I expect, but type checking says that for all things of the types I specify I will get a result of the type I desire. that ignores non-termination/exceptions though
22:02:12 <jle`> well, depending on your language :) some languages have types that can give termination guaruntees
22:02:42 <kuntal> I agree with @jle
22:03:47 <johnw> sgronblo: formal proofs and type checking are the same thing
22:03:56 <johnw> it depends on the language you are using
22:04:28 <Welkin> the function definition is the proof for the type declaration
22:04:37 <johnw> exactly
22:04:50 <johnw> the question is how rich the type can be to express the theorem
22:14:53 <sgronblo> I also heard this definition is the proof of the type declaration somewhere, but it sounds kind of backwards. It seems more natural to think of the type declaration as a property of the definition.
22:15:21 <johnw> it is exactly that
22:15:45 <johnw> the type formally expresses a property of the definition, and the definition is a witness to fulfillment of the property expressed by the type
22:16:13 <johnw> the function (+1) is a transformation of Int to Int, and a proof that such a transformation is possible
22:16:32 <johnw> it's called the Curry-Howard Isomorphism
22:17:48 <hunter_> do you update cabal install in a sandbox?
22:18:01 <hunter_> seems like you shouldnt but...
22:18:02 <hunter_> im not sure
22:20:41 <sgronblo> johnw: It sounds like a very weak proof, since there are infinite amounts of definitions that also prove that a transformation (I guess this is an intuitive term here) Int -> Int is possible. Maybe that is the main takeaway though.
22:20:53 <johnw> yep, exactly
22:21:06 <johnw> your intuition is dead on, it's an incredibly weak statement
22:21:29 <johnw> not because there are so many possible proofs, but because they say so little
22:21:32 <sgronblo> When you get into dependent types you further restrict the amount of definitions that satisfy the type declaration I guess.
22:21:39 <johnw> yep
22:22:00 <sgronblo> Interesting.
22:22:13 <johnw> and then your theorem can include values
22:22:31 <johnw> like, forall n : nat, even n -> even (n + n)
22:22:41 <hunter_> guestimate when a major dependantly typed language will exist and be in use
22:22:52 <hunter_> hopefully the word major is clear
22:22:54 <johnw> um, 1983
22:23:01 <hunter_> ok
22:23:03 <hunter_> by major
22:23:07 <hunter_> i meant big
22:23:11 <hunter_> a la c or java
22:23:12 <johnw> yeah, Coq is pretty huge
22:23:13 <Welkin> what does big mean?
22:23:17 <sgronblo> I guess he meant when will dependent types go mainstream
22:23:17 <hunter_> popylar
22:23:20 <hunter_> yes
22:23:24 <Welkin> how popular?
22:23:28 <hunter_> c/java level
22:23:29 <johnw> and popular with whom
22:23:33 <sgronblo> You gotta wait until Haskell goes mainstream first...
22:23:35 <hunter_> doesnt matter with whom
22:23:41 <johnw> yeah, it matters
22:23:42 <hunter_> it matters about scale
22:23:43 <Welkin> it does
22:23:47 <johnw> Coq is very popular in academia and mathematics
22:23:50 <hunter_> sheer numbers
22:23:53 <hunter_> number of people
22:23:57 <Welkin> being popular has nothing to do with being useful
22:23:57 <hunter_> i dont care which people
22:24:07 <johnw> hunter_: be specific about your metric
22:24:10 <hunter_> there are far more people outside of academia than in it
22:24:16 <hunter_> so sheer numbers should cover that
22:24:23 <Welkin> who cares about numbers?
22:24:25 <hunter_> i do
22:24:28 <hunter_> that was my question
22:24:30 <hunter_> ok
22:24:34 <Welkin> everyone and their dog knows some javascript
22:24:41 <Welkin> that doesn't mean it is the best language
22:24:44 <hunter_> lets just say mainstream in software development
22:24:56 <hunter_> i asked when will it be popular
22:24:58 <hunter_> not how popular is it now
22:25:03 <johnw> let's say then, 1,000,000 professionally engaged engineers using it
22:25:12 <hunter_> yes thats goood
22:25:22 <johnw> my guess: 50 years
22:25:30 <hunter_> why is the earth so slow to progress
22:25:45 <johnw> because it doesn't need a dependent typed language to do what it wants to do right now
22:25:46 <Welkin> things are popular because they are popular, not because they are the best
22:26:05 <hunter_> Welkin: thats not true i think johnw is more correct about popularity
22:26:10 <johnw> it may never be mainstream
22:26:12 <hunter_> Welkin: its about what is needed
22:26:15 <sgronblo> I've never used Coq but I was wondering if it involves proving properties by a similar method that was used in the recent Erik Meijer FP course. As in you use rewrite rules to massage expression a to b if you were supposed to prove that a = b?
22:26:22 <Welkin> hunter_: needed by who?
22:26:22 <johnw> but it may become a very powerful tool for a sub-segment of the population
22:26:34 <johnw> sgronblo: that's one part of it
22:26:59 <johnw> you use rewrite rules and induction
22:27:00 <hunter_> Welkin: by the masses
22:27:14 <Welkin> hunter_: your statements are so vague as to be meaningless
22:27:25 <sgronblo> johnw: How big a part is that type of proving for Coq? And what other "features" are used?
22:27:28 <hunter_> i dont understand how you could not know what masses mean
22:27:29 <hunter_> scroll up
22:27:44 <johnw> sgronblo: I didn't fully understand the question
22:28:06 <Welkin> hunter_: there is not one tool for every job
22:28:28 <johnw> I'd be very happy if Haskell had one million active professional users
22:28:31 <sgronblo> I've never been terribly interested in this type of proof in my math classes before, but if it was computer-assisted it seems like it could become more puzzle game like and maybe quite interesting.
22:28:38 <johnw> but then, maybe I wouldn't be, because of what it would do to Haskell, who knows
22:28:47 <johnw> sgronblo: oh *absolutely*
22:28:53 <johnw> Coq gamifies math proofs like you wouldn't believe
22:29:01 <johnw> you _will_ lose sleep because it becomes so much fun
22:29:13 <Ralith> can confirm
22:29:17 <johnw> sgronblo: start here: http://www.cis.upenn.edu/~bcpierce/sf/current/index.html
22:29:18 <hunter_> johnw: i would be very happy if a haskell fork had 1,000,000 users
22:29:27 <johnw> and don't say I didn't warn you: your interest in lesser things will suffer
22:29:29 <hunter_> theres always going to be a "haskell" thats ahead of the times and not in use
22:29:41 <Welkin> I knew a CS PhD student who doesn't program, but he loves coq
22:29:47 <johnw> hunter_: fair point!
22:29:56 <sgronblo> johnw: I meant, does the induction + rewrite rules type of proving constitute for example 50% of the type of "proof work" you would do when using Coq or is it just a small part of the whole cake?
22:29:59 <johnw> I'm using Coq full-time at work right now
22:30:15 <Ralith> oh man
22:30:18 <johnw> sgronblo: it's about 70% of the proof work, the rest being "management of the context"
22:31:11 <hunter_> what do you make with coq johnw
22:31:24 <sgronblo> oh man, why did they choose the name coq...
22:31:29 <hunter_> i know lol
22:31:38 <hunter_> i just pronounce it "coke"
22:31:41 <sgronblo> you dont even need to work hard to make everything sound dirty when talking about
22:31:43 <johnw> hunter_: at the moment, I'm writing a "high assurance" linear scan register allocator for a compiler
22:31:44 <hunter_> with a shorter k
22:31:56 <Eduard_Munteanu> sgronblo, it's most of it, if you take 'induction ~ pattern matching' and 'rewrite rules ~ theorems + reflection', that's pretty much what dependent types are about.
22:32:01 <Ralith> asking people "have you ever used coke" isn't much better tbh
22:32:02 <sgronblo> hunter_: have you seen that korean class on youtube?
22:32:04 <johnw> Coq makes type theory conferences awesome fun
22:32:09 <johnw> (due to the puns)
22:32:11 <hunter_> johnw: putting aside my complete lack of understanding of what you just said, is it fast?
22:32:18 <johnw> hunter_: fast in what sense?
22:32:23 <johnw> coq, the compiler, is dog slow
22:32:30 <hunter_> johnw: the runtie
22:32:33 <hunter_> runtime
22:32:39 <johnw> ah, I extract the code to Haskell and use GHC's optimizer
22:32:43 <johnw> but I don't have performance metrics yet
22:32:55 <hunter_> johnw: are you working academically or production?
22:33:09 <johnw> this is side project within a DARPA-funded research project
22:33:18 <johnw> so, neither
22:33:19 <hunter_> DARPA
22:33:23 <hunter_> are you making nukes
22:33:23 <Eduard_Munteanu> sgronblo, OTOH, if you prefer dealing with the expressions directly, you may like Agda.
22:33:30 <johnw> no, trying to make safer computers
22:33:41 <hunter_> computers for nukes
22:33:57 <johnw> hunter_: sure, why not
22:33:57 <hunter_> anyways
22:34:29 <johnw> if a nuke has to have a guidance computer on it, I'd rather it was one that couldn't be hacked
22:34:35 <sgronblo> I dont know which type I prefer, I just did the exercises for Erik's course which didnt even require you to come up with the proofs. Just to verify if a sequence of rewrite rule applications was valid or not.
22:34:49 <sgronblo> And thats when I started getting puzzle game vibes from it.
22:34:54 <johnw> sgronblo: Coq has a very nice interactive environment for working on proofs
22:35:09 <johnw> you see results immediately and get good feedback (especially if you use the Emacs mode called Proof General)
22:35:18 * hackagebot objective 0.6.3.2 - Extensible objects  http://hackage.haskell.org/package/objective-0.6.3.2 (FumiakiKinoshita)
22:35:21 <johnw> and it makes you appreciate Haskell in new ways
22:35:28 <sgronblo> Sort of like a grownups version of DragonBox
22:35:34 <johnw> as edwardk often says, Haskell's "power-to-weight" ratio is awesome
22:35:54 <sgronblo> johnw: Ah I was wondering about that, does Coq show you some listing of all the available rewrite rules?
22:36:06 <johnw> Coq may have tremendous power due to its dependent typing and interactive proving features, but there are major costs too
22:36:14 <johnw> sgronblo: yes, you can search them by type, by name, etc.
22:36:35 <johnw> I can search for "even (_ + _)"
22:36:45 <Eduard_Munteanu> sgronblo, mind they're more commonly called tactics
22:37:07 <hunter_> so is writing in coq akin to writing mathematical proofs?
22:37:14 <johnw> it can be
22:37:16 <Eduard_Munteanu> Not very.
22:37:20 <johnw> depends on what you're doing really
22:37:25 <johnw> if you're just programming, no
22:37:34 <Eduard_Munteanu> Ordinary math proofs are way less pedantic/formal.
22:37:43 <johnw> oh, he means pen and paper mathematical proofs
22:37:59 <johnw> Coq is actually the only kind of math proof I've ever really done
22:38:29 <sgronblo> Arent proofs by induction also "mathematical proofs"?
22:38:40 <Eduard_Munteanu> Actually my comment applies to Agda more accurately.
22:38:49 <johnw> You can have proofs by induction that have nothing to do with math
22:39:00 <Eduard_Munteanu> Coq's tactics might save quite a bit more effort.
22:39:04 <sgronblo> Also btw, I guess Coq handles applying the rewrite rule for you?
22:39:05 <johnw>  and induction principle is really just a way of iterating over a recursive data structure
22:39:21 <johnw> sgronblo: you have to tell it which rule to use, and it applies it
22:39:30 <sgronblo> Well it would be a bit crap if you had to manually write the resulting new expression I guess
22:39:42 <sgronblo> how do you target your rewrite rule?
22:39:45 <johnw> ah, I see
22:39:52 <johnw>  there is always a current "goal"
22:39:55 <hunter_> johnw: wanna paste some coqyoure working on? ;)
22:39:57 <johnw>  the rewrite rule applies to that goal
22:39:59 <hunter_> ;) = pls
22:40:03 <johnw> hunter_: https://github.com/jwiegley/linearscan
22:40:16 <johnw> hunter_: for example, Lib.v
22:40:35 <Eduard_Munteanu> Is that a challenge like "show your coq to the world"? :P
22:40:43 * Eduard_Munteanu stops the Coq jokes
22:40:45 <johnw> Eduard_Munteanu:  see, the jokes just never end
22:40:59 <johnw>  we had so much fun at OPLSS coming up with possible beginner book titles
22:41:29 <sgronblo> I mean if you had two similar expressions you need to be able to say like (a op b) + (c op d) "Coq, apply op to the second parentheses"?
22:41:54 <johnw> sgronblo:  there is a library for Coq which makes it very easy to isolate which thing you want to apply it to
22:42:06 <johnw> for example: rewrite 2[op]rule
22:42:06 <sgronblo> johnw: not built-in by default?
22:42:12 <johnw> no, it's not the default
22:42:24 <sgronblo> by default it would be impossible or just verbose?
22:42:35 <johnw> the default just lets you specify the "index" out of the set of possible targets
22:42:43 <sgronblo> ok
22:42:52 <sgronblo> next question...
22:43:12 <sgronblo> is it possible to automate this graph search by using a* or something?
22:43:44 <sgronblo> as in the resulting expression of applying this rewrite rule would be one step closer to the goal
22:43:49 <sgronblo> so we should try to do that first
22:43:52 <johnw> there are graph searching tools, Adam Chlipala has a book which focuses very much on automating proof search
22:43:53 <Eduard_Munteanu> sgronblo, proof search?
22:43:57 <sgronblo> yeah
22:44:11 <sgronblo> I thought I can't be the first to have that idea
22:44:18 <johnw> repeat match goal with | [ | (_ op _) ] => rewrite foo end
22:44:21 <Eduard_Munteanu> sgronblo, tactics can do that.
22:44:27 <recursion-ninja> A* will only be applicable if you have an ``admissible'' function to weigh the fitness of each node
22:44:43 <johnw> yeah, A* needs a hueristic
22:44:51 <johnw> otherwise it degenerates to djikstra
22:45:05 <recursion-ninja> johnw: correct
22:45:15 <sgronblo> yeah my first idea was something like comparing the number of operators and terms or something to get the distance
22:45:37 <johnw> sgronblo: the Isabelle proof assistant can use SAT solvers to do proof search against a database of known proofs
22:46:16 <sgronblo> I feel like some very wide world of math and proofs is opening up before me
22:46:30 <johnw> I'm also quite interested in checking out how Liquid Haskell can be used to achieve verification in Haskell;  it uses a SAT solver also
22:46:53 <johnw>  its main restriction is that all of its predicates must be decidable
22:48:36 <sgronblo> what was this management of context you mentioned?
22:49:03 <johnw> renaming of hypothesis, introducing new hypotheses, assigning names to subexpression of the goal, etc.
22:49:22 <johnw> bookkeeping
22:50:15 <nshepperd> hmmm, one way to invent heuristics is to remove a constraint from the problem and solve the "easier" problem exactly
22:50:52 <nshepperd> on the case of proof search, that could be adding an axiom schema
22:51:01 <nshepperd> dunno if that would be at all useful though
22:55:59 <johnw> good night all
22:58:14 <sgronblo> good night
23:00:25 <dspies> Can someone explain why sequence from : http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Control-Monad.html#sequence uses stack space while sequence_hughes from https://www.haskell.org/pipermail/haskell-cafe/2013-August/109998.html uses heap space?
23:01:53 <jle`> dspies: what is stack space?
23:02:41 <dspies> jle`: function arguments to be processed
23:06:10 <dspies> jle`: sorry that's not a very good explanation.  I don't think I understand it very well myself yet.  Take a look at http://research.microsoft.com/pubs/67083/spineless-tagless-gmachine.ps.gz for the real difference between free variables and function arguments
23:08:56 <dspies> Okay, I think I understand it now. It's the same way stackoverflows happen in an imperative language
23:09:10 <dspies> in sequence_hughes, h is an accumulating parameter
23:09:23 <dspies> which makes the function "tail-recursive"
23:14:43 <srhb> dspies: Is that the last link?
23:14:52 <srhb> BEcause tail recursion is almost (always?) never a thing in Haskell
23:15:34 <dmwit> sequence_hughes is not tail recursive, it is "tail recursive".
23:15:34 <srhb> Or rather, tail recursion modulo cons is what we care about.
23:15:36 <dspies> srhb: Okay, in that case I still don't understand it
23:16:06 <dmwit> It looks tail recursive in do notation, and acts tail recursive when you run it.
23:16:18 <dmwit> Because thank laziness and heap cycles.
23:20:08 <nshepperd> i think it's apt to describe the normal 'sequence' as "not tail recursive" though
23:20:24 <srhb> dspies: I can't quite see it either though.
23:23:01 <nshepperd> 'sequence (m:ms) = (:) <$> m <*> sequence ms' being the normal definition
23:23:50 <srhb> That LOOKS tail recursive modulo cons though
23:24:03 <srhb> Isn't it?
23:24:44 <nshepperd> if I understand 'stack' right, the thing that is blowing the stack is that it has to remember to go back and apply the (:) stuff after executing 'sequence ms'
23:24:49 <dmwit> srhb: What does "modulo cons" mean?
23:25:09 <nshepperd> it's not a plain cons though, it's a lifted cons
23:25:44 <shachaf> i,i it's tail-recursive, just not in the tail
23:26:05 <srhb> nshepperd: True, the <*> is fine though
23:27:53 <srhb> dmwit: Afair it's when we can make similar optimizations like tco, but we can do it even if the recursion happens in a cons
23:28:20 <srhb> ie x : recurse
23:28:43 <shachaf> Talking about "TCO" doesn't even make that much sense when talking about Haskell.
23:28:49 <srhb> Indeed.
23:29:37 <shachaf> So I'm not sure what you're getting at.
23:31:18 <srhb> I was just mentioning that exactly because tail calls aren't the thing to strive for, but guarded recursion (which is really tail recursion modulo cons, afair)
23:31:27 <srhb> In foldr because of laziness etc.
23:32:22 <shachaf> I don't know what "tail recursion modulo cons" means either. :-)
23:34:02 <nshepperd> I think, one way to look at it is "how do you reduce the expression"
23:34:03 <srhb> I think it's merely similar to guarded recursion. Or rather, you get the same result
23:34:27 <srhb> But the issue at hand here is how to recognize stack space vs. heap space in those cases outlined above, I believe.
23:34:31 <nshepperd> say m = putStr "."
23:34:48 <shachaf> What nshepperd said is a good approach, certainly.
23:35:02 <shachaf> Graph reduction is good enough of a mental model for most issues relating to laziness that you'll come across.
23:35:17 <nshepperd> (:) <$> putStr "." <*> sequence ms
23:36:20 <srhb> Right, where's the stack space consumption here?
23:37:40 <nshepperd> putStr "." >>= (\r -> sequence ms >>= (\rs -> r : rs))
23:37:55 <hunter_> how slow is ghc development
23:38:00 <srhb> hunter_: Not.
23:38:00 <hunter_> are there many people working on it?
23:38:04 <nshepperd> can't reduce that any further since IO is a free monad
23:38:28 <srhb> nshepperd: I see, and how does that change with a DList implementation instead of lists?
23:38:29 <hunter_> srhb: last time somebody pitched contributing to me they made it sound like there was just a few people developing it
23:38:50 <srhb> hunter_: There are fewer than those few people would like, but that does not mean development is slow at all.
23:40:33 <nshepperd> importantly, I guess, you don't reduce that any further. the runtime starts executing the action, printing a dot, and then moves on to (sequence ms >>= (\rs -> () : rs))
23:40:35 <srhb> nshepperd: According to the thread, it's an issue for Control.Monad.ST, Control.Monad.State.Strict, etc.
23:41:13 <srhb> While regular sequence will not grow stack for the lazy variants (due exactly to laziness of cons, I guess?)
23:42:19 <nshepperd> oh, those inner lambdas should have a 'return'
23:42:23 <srhb> Yeah.
23:42:35 <nshepperd> anyway that's the story for IO...
23:42:44 <shachaf> I wasn't around for the original question.
23:43:04 <srhb> shachaf: dspies at xx:58
23:43:46 <srhb> This is the post in question: https://www.haskell.org/pipermail/haskell-cafe/2013-August/109998.html
23:43:51 <hunter_> whats the divide function for ints?
23:43:57 <hunter_> i forget what its called
23:44:10 <srhb> `div`
23:44:25 <hunter_> is there another one too? i feel like there were 2 that were slightly different
23:44:37 <srhb> `quot` for no sign
23:45:25 <dspies> Ok, so I replaced replicateM with a more stack-friendly version and I'm still getting stackoverflow
23:45:29 <lpaste> dspies pasted “Still getting stackoverflow” at http://lpaste.net/116753
23:46:34 <dspies> I still think it's in makeCounts
23:47:21 <dspies> In particular if each vertex has the next vertex as a child then you end up with all the vertices on stack
23:47:30 <dspies> but I don't see any workaround
23:47:40 <dspies> nor do I see why that should be a problem
23:47:56 <hunter_> fromIntegral vs fromEnum
23:47:59 <hunter_> which is faster?
23:48:09 <hunter_> for Ints
23:48:12 <dspies> (I suppose I could use the state monad to accumulate the sum, but that doesn't seem like it should be necessary)
23:48:14 <nshepperd> srhb: so sequence_hughes (m:ms) = go id (m:ms) >>= some stuff
23:48:24 <srhb> Yeah
23:48:43 <nshepperd> so the runtime evaluates 'go id (m:ms)'
23:48:59 <nshepperd> go id (m:ms) = m >>= (\x -> go (id . (x:)) ms)
23:49:41 <nshepperd> m = putStr "." so it prints a dot and passes the result () to the continuation...
23:49:57 <nshepperd> -> go (id . (():)) ms
23:50:25 <srhb> Mkay, so it's actually about the continuation.
23:50:38 <srhb> Not so much the dlist
23:51:14 <shachaf> ?
23:51:14 <hunter_> fastestway to convert int -> double?
23:52:02 <nshepperd> I think what it's about is that the runtime doesn't need to "remember" anything
23:52:03 <dspies> actually I don't think the state monad thing would work, because it still has to fold over the rest of the list for each vertex
23:52:21 <srhb> nshepperd: Okay. I think I sort of get it.
23:53:08 <shachaf> You might want to spend some time reducing DLists by hand to see what happens.
23:53:32 <srhb> Yeah.
23:54:01 <shachaf> I think it's "about the dlist" as much as it's about anything.
23:54:09 <nshepperd> with sequence_hughes we only need to keep track of one thing, the currently evaluating expression, which goes "go id ms" ... "go (id . (():)) ms" ... "go (id . (():) . (():)) ms"
23:54:33 <nshepperd> the parameter (which is a dlist) gets bigger, but that's ok, because such things are stored on the heap
23:54:41 <srhb> *nods*
23:57:09 <nshepperd> whereas in the normal 'sequence' case you build up this ((sequence ms >>= (\rs -> return (():rs))) >>= ... thing
23:57:17 <hunter_> guys how functional is FRP.Helm
23:57:21 <hunter_> it seems very limited
23:58:14 <srhb> nshepperd: Which uses stack because... ?
23:58:23 <srhb> The chain of  >>= ?
23:58:57 <srhb> More parameters go to stack, bigger parameters go to heap?
23:59:44 <shachaf> I think you need a better mental model of how GHC evaluates code before talking about "stack" and "heap" (which are really pretty implementation-specific anyway).
23:59:51 <nshepperd> i'm not sure :p
23:59:53 <shachaf> The stack is used for forcing thunks.
