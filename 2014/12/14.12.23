00:00:09 <bob123> It works but is there another way to do it?
00:00:58 <maukem> > (\x -> splitAt (length x `div` 2) x) "hello"
00:00:59 <lambdabot>  ("he","llo")
00:04:20 <glguy> Mauke, yours is missing the grouchy failure mode...
00:08:26 * hackagebot conduit-combinators 0.3.0.5 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.3.0.5 (MichaelSnoyman)
00:08:26 * hackagebot cndict 0.4.7 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.4.7 (DavidHimmelstrup)
00:33:21 * hackagebot appc 0.0.3 - app container types and tools  http://hackage.haskell.org/package/appc-0.0.3 (wereHamster)
01:09:29 <odi> hi is there a way to get the documentation and the source code of an loaded function in ghci without lambdabot and hoogle like e.g. clojure => (doc print)
01:12:06 <mmmm> odi: :t
01:12:51 <mmmm> or.. :info
01:12:54 <odi> with :t you get the type of the function but i like to have the documentation
01:13:30 <Myrl> odi: You can't.
01:13:31 <Myrl> odi: Or at least, that's what I heard from others when I asked.
01:13:42 <Myrl> odi: You need to use hoogle and such.
01:13:42 <odi> sometime i like to view the implementation details about a function
01:15:48 <odi> i like to have this information offline, i know you can use hoogle offline too but you have to manage the package-db yourself
01:15:57 <odi> and if one package is in a wrong version ...
01:18:17 <odi> my workflow is to create a cabal-project, add some dependencies in the cabal-file and build the project. in my ~/.cabal/packages/hackage.haskell.org are all downloaded packages and i can browse the source-code there but it would be nice to have this information in ghci itself
01:18:52 <odi> the information for the documentation of a function and the implementation
01:19:44 <hvr> odi: you'd need something like `:def hdoc    \q -> return $ ":! haskell-docs " ++ q
01:21:18 <hvr> odi: fwiw, I hope (= wishful thinking) we can get some integrated haddock support into GHCi for 7.12
01:28:23 * hackagebot cndict 0.4.8 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.4.8 (DavidHimmelstrup)
01:28:25 <odi> hvr: that would be really cool because of doing all that stuff from within ghci!
01:44:00 <t4nk612> I have a question about catching exceptions!
01:44:21 <t4nk612> when using `catch` for example, I read that I can pattern-match on the exception type
01:44:40 <t4nk612> What I do not understand is what happens if the pattern-match fails.
01:44:53 <t4nk612> It says that the exception will propagate, but
01:45:04 <t4nk612> from what I know, if a pattern-match fails, that in itself a new error
01:45:12 <t4nk612> wouldn't it mask the original error?
01:45:46 <t4nk612> I'm referring to pattern-matching in the handler function
01:47:24 <t4nk612> Is it because catch is some type of a special function?
01:47:42 <alem0lars> I'd like to go away from systemd (and go back to openrc). However removing the systemd use and upgrading didn't work for me. I get the this error when calculating dependencies: https://gist.github.com/alem0lars/0801878f5bf9997c966d Any ideas?
01:48:53 <alem0lars> I don't understand why since there isn't the systemd flag so systemd and gentoo-systemd-integration shouldn't be pulled in
01:49:14 <alem0lars> I've also tried to manually unmerge those packages but they will still pulled in by the upgrade
01:49:17 <Saizan> alem0lars: wrong channel
01:49:23 <alem0lars> ops
01:49:26 <alem0lars> XD
01:49:35 <alem0lars> such fail XD
01:49:39 <alem0lars> sorry
01:53:12 <t4nk209> It's me again with the `catch` question
01:54:31 <Saizan> t4nk209: it's because of typeclasses
01:55:23 <Saizan> t4nk209: catch is doing the "match on the type" for you, so it can recover when it doesn't match, you are only matching on the constructor of the type
02:09:28 <t4nk209> Thanks Saizan for your answer, yet I'm not sure I understand
02:09:51 <t4nk209> Yes I understand I am matching on the constructor of the type
02:10:03 <t4nk209> What do you mean catch is doing the "match on the type" for you?
02:10:48 <t4nk209> Perhaps you mean that the type of the handler function is checked in compile time to be of the right type?
02:11:29 <t4nk209> how does it recover?
02:17:53 <maukem> t4nk209: it's not really pattern matching
02:18:07 <maukem> catch will automatically select the right type
02:18:29 <maukem> but if your type has multiple constructors (and you only handle some of them), you get a normal pattern matching error
02:19:40 <Saizan> t4nk209: see the fromException method of the Exception typeclass
02:22:45 <tdammers> guys, has anyone made libsass bindings for haskell yet?
02:26:08 <dspies> I have a program that doesn't use very much space to run and it's memory profile according -hc is what I would expect (in other words, it doesn't look like there's a space-leak), but it runs slower than I would like and according to -sstderr uses most of its time garbage-collecting.  How can I speed up the garbage-collector?
02:26:45 <lpaste> dspies pasted ‚ÄúSlow garbage-collecting‚Äù at http://lpaste.net/117083
02:27:23 <dspies> It's a solution to this problem: https://open.kattis.com/problems/tourist
02:27:32 <dspies> The input data is here: http://heim.ifi.uio.no/~db/nm-i-programmering/nm2004/testdata/h.in
02:48:26 * hackagebot hastache 0.6.1 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.6.1 (DaniilFrumin)
02:54:12 <t4nk209> Saizan: I actually already looked at it
02:54:33 <t4nk209> I'm still kinda confused. So fromException works for any instance of Exception
02:55:04 <t4nk209> So my handler will work on my type of exception, and therefore pattern match is only on constructors of my type
02:55:45 <t4nk209> but if another type of Exception altogether is thrown, my handler doesn't get called at all? Is that some kind of logic that happens because of the throw?
02:56:02 <t4nk209> Is that black magic a part of regular haskell library code?
02:58:58 <maukem> I think it simply uses cast behind the scenes
02:59:01 <maukem> :t cast
02:59:02 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
02:59:16 <maukem> and the target type comes from the argument of the handler function
03:01:49 <Cale> t4nk209: Did you link your code somewhere?
03:02:24 <Cale> maukem is correct, it uses Typeable and cast
03:03:04 <Cale> There's some magic involved, but it's not as much magic as you might expect.
03:03:22 <Saizan> t4nk209: yeah, if some other type of exception is thrown your handle doesn't get called
03:03:43 <Saizan> t4nk209: because fromException for your type will return Nothing on that exception
03:05:07 <Cale> If your handler's type is such that it specifies a certain type of exception, it'll only get exceptions of that type. You can use the type SomeException to catch all exceptions. It's also possible to define new types along with instances of Exception in such a way as to catch any set of exceptions.
03:08:03 <lpaste> Cale pasted ‚ÄúCatch either of two exception types‚Äù at http://lpaste.net/117084
03:08:21 <Gabriel11101> Hi, there! I'm new to the IRC and I would like to know how things are going on here
03:08:56 <lpaste> Cale pasted ‚Äúan example of refining an existing exception type into a bunch of more specific types‚Äù at http://lpaste.net/117085
03:09:07 <Cale> Gabriel11101: hello!
03:09:41 <Cale> Gabriel11101: Questions and discussion about Haskell are always welcome here :)
03:10:10 <Hafydd> :---)
03:10:38 <Gabriel11101> THank you!
03:18:28 * hackagebot persistent 2.1.1.3 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.1.3 (MichaelSnoyman)
03:20:06 <statusfailed> Is the "Void" type supposed to be "a type with no inhabitants"?
03:21:10 <statusfailed> if defined as "data Void = Void !Void", can't you construct one with "fix Void"?
03:21:24 <statusfailed> Is the type supposed to enforce that the only inhabitant you can construct is _| ?
03:21:27 <statusfailed> _|_ *
03:21:47 <Fuuzetsu> ‚ä•
03:21:52 <statusfailed> ^ that :)
03:23:28 * hackagebot persistent-sqlite 2.1.1.2 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.1.1.2 (MichaelSnoyman)
03:28:33 <Taneb> statusfailed, Void is a strict function, so fix Void is ‚ä•
03:29:20 <statusfailed> Taneb: would non-strictness change it?
03:29:45 <Taneb> Yeah, then it'd be Void (Void (Void (Void...
03:30:11 <statusfailed> but isn't that also bottom, becauses it never terminates?
03:30:20 <Taneb> That is, the value Void (Void (Void (Void
03:30:24 <Taneb> Which is like an infinite list
03:30:28 <Taneb> A very boring infinite list
03:30:29 <statusfailed> right
03:30:30 <statusfailed> :)
03:30:46 <statusfailed> so "bottom" is not "nontermination"?
03:30:55 <Taneb> Soooort of
03:31:20 <Taneb> "bottom" is "will never give you anything useful at all"
03:31:57 <Taneb> Whereas an infinite list will terminate if you only ask for it to WHNF
03:32:03 <Taneb> Which'd be ():_
03:32:23 <statusfailed> Taneb: Couldn't you do that with the "void list" though?
03:32:25 <Taneb> For a non-strict Void you'd get Void _
03:32:29 <Taneb> Then Void (Void _)
03:32:36 <Taneb> For a strict void, you can't do that
03:32:52 <Taneb> Because you need to have the inside reduced to WHNF to reduce the outside to WHNF
03:33:00 <statusfailed> oh wait; so we're saying lazy Void is not bottom
03:33:00 <bernalex> > take 2 $ repeat () -- this can't happen without laziness.
03:33:02 <lambdabot>  [(),()]
03:33:04 <statusfailed> which was my question? haha
03:33:15 <statusfailed> ok i think I get it
03:33:58 <Taneb> I hope I explained it well enough!
03:35:24 <statusfailed> Taneb: yeah, thanks :)
03:35:28 <Taneb> :)
03:37:10 <Taneb> statusfailed, data Void = Void !Void is pretty much equivalent to newtype Void = Void Void
03:37:22 <mArs3llus> helloooo
03:37:26 <Taneb> Another definition of Void is just "data Void"
03:37:29 <statusfailed> Taneb: are newtypes strict ?
03:37:33 <Taneb> Hi, mArs3llus
03:37:36 <statusfailed> Taneb: yeah I saw that one, but requires a GHC extension right?
03:37:38 <mArs3llus> hey
03:37:56 <Taneb> statusfailed, yes, newtypes pretty much get compiled out
03:38:42 <statusfailed> ah ok
03:43:29 * hackagebot stackage 0.2.1.4 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.2.1.4 (MichaelSnoyman)
03:53:07 <jdiez> hi guys, is there any way to tell the compiler a type variable from the top-level signature is the same as a type variable with the same name in a sub expression?
03:53:28 <McManiaC> jdiez: use explicit forall
03:53:32 <dramforever> -XScopedTypeVariables, iirc
03:53:44 <McManiaC> oh and that
03:53:54 <Taneb> jdiez, yeah, the ScopedTypeVariables GHC extension
03:54:05 <dramforever> (I assume you know what that means)
03:54:05 <jdiez> McManiaC, dramforever, Taneb: thanks, that worked
03:54:09 <Taneb> :)
03:54:33 <dramforever> you're welcome
03:54:45 <jdiez> used to to write this: https://gist.github.com/jdiez17/f52d2ab6be2bd5fbae2d
03:54:56 <jdiez> which doesn't feel very haskellish (what's the equivalent of pythonic for haskell?)
03:54:58 <jdiez> any tips?
03:56:10 <mmmm> looks fine
03:56:29 <Taneb> jdiez, you can use fmap rather than do notation
03:56:34 <mmmm> If you find yourself doing either (const Nothing).. a lot then there's lots of helper functions in Control.Error
03:56:45 <Taneb> "either (const Nothing) Just <$> redisComp"
03:57:04 <bernalex> jdiez: "The Right Thing". ;-)
03:57:07 <jdiez> Taneb: hmm, not sure how that works
03:57:18 <dramforever> @hoogle Either a b -> Maybe b
03:57:20 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
03:57:20 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
03:57:20 <jdiez> Taneb: I'd understand `redisComp >>= either (const Nothing) Just
03:57:20 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
03:57:43 <endiruna> are the guards if else?
03:57:53 <Taneb> jdiez, it's a Monad law, I believe, fmap f xs  ==  xs >>= return . f
03:57:59 <mmmm> jdiez: That wouldn't type check
03:58:06 <endiruna> for example if i do      f x | x<10 "hello"
03:58:19 <endiruna> * f x | x<10 ="hello"
03:58:21 <jdiez> mmmm: how so?
03:58:36 <endiruna> *    | x<110 ="hell"
03:58:45 <jdiez> mmmm: ah, forgot a return
03:58:50 <dramforever> jdiez: What do you mean by "I'd understand"
03:59:09 <jdiez> dramforever: I meant "I can see <this thing> working, but not <thing Taneb suggested>"
03:59:32 <jdiez> mmmm: this would work, though, right? redisComp >>= return . either (const Nothing) Just
03:59:37 <mmmm> yes
03:59:44 <jdiez> yep, silly mistake
03:59:45 <mmmm> the other way is more idiomatic though I find
03:59:48 <dramforever> :t flip fmap
03:59:49 <lambdabot> Functor f => f a -> (a -> b) -> f b
03:59:56 <dramforever> @hoogle Functor f => f a -> (a -> b) -> f b
03:59:57 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
03:59:57 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
03:59:57 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
04:00:12 <jdiez> yeah, I see
04:00:15 <dramforever> ouch
04:00:23 <dramforever> no better functions
04:00:42 <dramforever> sometimes you have to read from right to left
04:01:02 <Taneb> lens exports (<&>)
04:01:04 <Taneb> :t (<&>)
04:01:05 <lambdabot> Functor f => f a -> (a -> b) -> f b
04:01:11 <mmmm> I use =<< as much as >>= tbh
04:01:21 <dramforever> I can't recommend lens
04:01:35 <Taneb> Well yeah, it's horribly overkill for that one operator
04:02:33 <Taneb> :t returning
04:02:34 <lambdabot> Not in scope: ‚Äòreturning‚Äô
04:02:44 <Taneb> @let import qualified Data.Functor.Bind
04:02:45 <lambdabot>  <no location info>:
04:02:45 <lambdabot>      The package (comonad-4.0.1) is required to be trusted but it isn't!
04:02:45 <lambdabot>  
04:02:49 <Taneb> :(
04:02:58 <Taneb> Data.Functor.Bind.returning :: Functor f => f a -> (a -> b) -> f b
04:03:01 <Taneb> In semigroupoids
04:03:29 <dramforever> hey
04:03:42 <dramforever> jdiez: why don't you *just* understand it
04:03:51 <jdiez> ?
04:03:58 <t4nk209> Thanks Saizan and Gabriel! I understood it now!
04:04:02 <dramforever> just accept it
04:04:09 <dramforever> can you accept it?
04:04:16 <jdiez> can't tell if you're trolling
04:04:21 <dramforever> no
04:04:28 <jdiez> k
04:05:08 <dramforever> how about this: <$>, <*>, =<< are all like function application
04:05:23 <t4nk209> Guys I have a lil question, in my code I wrote this:
04:05:33 <dramforever> use the one with the correct type
04:05:47 <t4nk209> 10 * 10 ^ (6:: Int)
04:06:15 <t4nk209> Just because this: 10 * 10 ^ 6 would not work, because it can't deduce what instance of Integral the 6 is
04:06:26 <dramforever> t4nk209: look at this
04:06:29 <dramforever> :t (^)
04:06:29 <lambdabot> (Num a, Integral b) => a -> b -> a
04:06:47 <t4nk209> Is there an elegant way to avoid having to be so type specific on things which seem trivial?
04:06:50 <dramforever> the two types argument aren't necessarily the same
04:06:58 <t4nk209> I looked at it already dramforever
04:07:02 <dramforever> oh
04:07:24 <dramforever> sorry I misread that
04:07:24 <t4nk209> Yes but, it didn't force me to specify an instance for the Num so why force me to specify an instance for the Integer?
04:07:38 <t4nk209> for the Integral*
04:07:50 <mmmm> I thought it usually defaulted to int and warned you?
04:07:58 <t4nk209> Oh I understand why
04:08:09 <t4nk209> the result was the same Num so that was defaulted
04:08:10 <dramforever> Can you give more code
04:08:17 <t4nk209> but it didn't default the Integral b
04:08:22 <t4nk209> Yes
04:08:29 * hackagebot machines-io 0.2.0.0 - IO utilities for the machines library  http://hackage.haskell.org/package/machines-io-0.2.0.0 (aloiscochard)
04:08:32 <t4nk209>         Just _  -> liftIO $ threadDelay $ 10*10^(6 :: Int)
04:09:23 <dramforever> I forgot which extension, but one allowed this: (I hope the following works)
04:09:26 <dramforever> > 10e6 :: Int
04:09:28 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
04:09:28 <lambdabot>    arising from the literal ‚Äò10e6‚Äô
04:09:32 <dramforever> ouch
04:10:04 <t4nk209> What do you think dramforever?
04:10:30 <lericson> > fromFractional 10e6 :: Int
04:10:32 <lambdabot>  Not in scope: ‚ÄòfromFractional‚Äô
04:10:32 <lambdabot>  Perhaps you meant ‚ÄòfromRational‚Äô (imported from Prelude)
04:10:38 <mmmm> I'm not sure why, I have used exactly the same code without having to specify :/
04:10:40 <dramforever> I think that extension was to solve this
04:10:51 <t4nk209> realy mmmm? That's weird
04:10:54 <Peaker> can I pass ghci-ng ":set +c" as a command-line flag?
04:11:40 <dramforever> t4nk209: me too
04:11:46 <dramforever> no need to use (6::Int)
04:11:54 <t4nk209> I'm using freenode to look at this irc chat but it's really annoying with all the messages of people joining and leaving
04:12:14 <t4nk209> dramforever I can show you the err message
04:12:39 <dramforever> t4nk209: using -Wall gave a warning, though
04:12:40 <lericson> t4nk209: you can ignore them, i'm pretty sure
04:13:03 <Myrl> t4nk209: Erm, that all depends on your client.
04:13:10 <t4nk209> http://lpaste.net/117086
04:13:29 * hackagebot machines-directory 0.2.0.0 - Directory (system) utilities for the machines library  http://hackage.haskell.org/package/machines-directory-0.2.0.0 (aloiscochard)
04:13:35 <Athas> Are there GHC flags I can pass to cabal to make GHC use less memory?
04:13:44 <t4nk209> I'm using freenode which is a client in the browser. Is there any client you would recommend instead?
04:14:07 <dramforever> t4nk209: does "main = threadDelay $ 10^6" work?
04:14:13 <t4nk209> dramforever I am using -Wall, but It's an error not a warning
04:14:19 <Myrl> t4nk209: Well, almost everything unless you have no other choice.
04:14:42 <t4nk209> I'll try
04:15:30 <t4nk209> well in ghci it works, but not when I compile my project :/
04:16:05 <t4nk209> What is a recommended irc client, a lot of people here use?
04:16:12 <dramforever> Hmmm... "Just _  -> liftIO ..."?
04:16:16 <dramforever> "->" ??!!
04:16:38 <t4nk209> Yes it's a case
04:16:43 <t4nk209> part of a case expression
04:16:45 <dramforever> oh
04:17:04 <t4nk209> Anwyays dram it's not a major problem
04:17:13 <t4nk209> Perhaps it is the -Wall
04:17:28 <dramforever> can you tell us the flags you gave ghc?
04:17:28 <t4nk209> Thanks for trying to help :)
04:17:32 <t4nk209> Yes
04:17:54 <t4nk209> -Wall, -Werror
04:18:01 <dramforever> see
04:18:11 <dramforever> *I see
04:18:20 <dramforever> -Werror makes warnings errors
04:18:27 <dramforever> no wonder you are getting errors
04:18:53 <t4nk209> But usually
04:19:07 <t4nk209> when it does it, it also prints a message that because -Werrors is active I'm getting the warning as errors
04:19:24 <t4nk209> and that happens after all regular compilation errors are fixed. But this comes up before I fixed other ocmpilation errro
04:20:01 <dramforever> sorry, I don't know what to do now
04:20:35 <t4nk209> It's ok
04:20:36 <dramforever> How about this: I think you can make do with 10 * 1000 * 1000
04:20:38 <t4nk209> not a big deal
04:20:47 <t4nk209> lol actually you're right dram
04:20:53 <t4nk209> I think I'll go with that
04:22:00 <t4nk209> By the way dramforever which irc client are you using?
04:22:13 <t4nk209> I'm looking for a simple CLI irc client
04:22:55 <bennofs> weechat is a good CLI irc client. not sure how simple it is though (usage is easy, idk if it's "small" implementation-wise)
04:23:30 * hackagebot machines-process 0.2.0.0 - Process (system) utilities for the machines library  http://hackage.haskell.org/package/machines-process-0.2.0.0 (aloiscochard)
04:23:37 <t4nk209> I'll try it thanks
04:24:12 <k_bx> Hey everyone! I‚Äôm trying to add a MonadReader instance for ExceptT from transformers-compat since I‚Äôm stuck to older mtl, but have a fundep error I can‚Äôt figure out. Could someone please take a look? http://lpaste.net/117087
04:27:10 <k_bx> (repost): Hey everyone! I‚Äôm trying to add a MonadReader instance for ExceptT from transformers-compat since I‚Äôm stuck to older mtl, but have a fundep error I can‚Äôt figure out. Could someone please take a look? http://lpaste.net/117087
04:31:40 <jdiez> @pl \m -> asks source >>= respond m
04:31:40 <lambdabot> (asks source >>=) . respond
04:31:45 <jdiez> meh
04:31:45 <supki> k_bx: have you tried UndecidableInstances?
04:31:47 <jdiez> clearer this way
04:32:54 <k_bx> supki: that seemed to help :/
04:33:02 <k_bx> supki: thanks
04:48:31 * hackagebot git-sanity 0.1.0.0 - A sanity checker for your git history.  http://hackage.haskell.org/package/git-sanity-0.1.0.0 (aloiscochard)
04:52:33 <Guest28642> Hi guys! Quick question: I'm just starting to try to use the IO monad (never used it before), and obviously can't loop... I'm trying to make a function that will return n integers, after reading them from stdin. so, I tried "getInts :: Int -> [IO Int]", but this doesn't work. It complains about an expected type IO (IO Int). Thoughts?
04:53:08 <mmmm> Guest28642: You can loop.. just not in the way you're used to
04:53:24 <mmmm> Have you looked at the functions from Control.Monad?
04:57:18 <statusfailed> Guest28642: did you write "getInts" ?
04:57:44 <statusfailed> Guest28642: and can you show a snippet with some more context?
04:57:44 <zwer> Guest12342 you probably want getInts :: Int -> IO [Int]
04:57:50 <statusfailed> ^
04:59:56 <maukem> :t flip replicateM readLn
04:59:57 <lambdabot> Read a => Int -> IO [a]
05:01:55 <mmmm> maukem: That's not very useful is it..
05:02:16 <maukem> why not?
05:02:36 <statusfailed> maukem: I think because the asker is new to the IO monad, and it's perhaps a bit opaque :)
05:03:09 <maukem> "Have you looked at the functions from Control.Monad?" isn't much better
05:03:13 <statusfailed> maukem: agreed
05:03:43 <mmmm> Well I disagree
05:04:28 <lericson> :t replicateM
05:04:29 <lambdabot> Monad m => Int -> m a -> m [a]
05:04:48 <statusfailed> hongminhee: in summary: there are quite a few ways to write this (maukem's is quite nice, but don't worry if you don't follow it); if you show us what you're having trouble with we can be of more help
05:05:26 <maukem> mistab?
05:05:41 <statusfailed> mistab? ?
05:06:02 <maukem> yeah, you're addressing hongminhee instead of Guest28642
05:06:11 <vanila> why is this guy being so argumentative?
05:06:14 <statusfailed> maukem: nick change ^
05:06:15 <vanila> too many cooks in here
05:06:24 <maukem> statusfailed: no
05:06:26 <statusfailed> oh
05:06:27 <statusfailed> haha
05:06:31 <statusfailed> whoops :)
05:06:50 <statusfailed> too many guests
05:08:05 <Guest28642> statusfailed: sorry, I got called away from the computer for a sec
05:08:29 <Guest28642> http://pastebin.com/3iRFPbTz
05:08:32 * hackagebot zip-conduit 0.2.2.2 - Working with zip archives via conduits.  http://hackage.haskell.org/package/zip-conduit-0.2.2.2 (TimCherganov)
05:08:34 <Guest28642> here is my function
05:08:41 <Guest28642> trying to read a single number, then read *that* number of integers
05:09:05 <vanila> Guest28642, you will need to use  sequence (readInts z)
05:09:14 <maukem> Guest28642: yeah, your type is wrong
05:09:25 <maukem> readInts doesn't actually read ints as written
05:09:41 <maukem> it returns a list of n actions, all of which are readLn
05:10:01 <maukem> so basically it's replicate n readLn
05:10:20 <maukem> > replicate 5 "hello"
05:10:21 <lambdabot>  ["hello","hello","hello","hello","hello"]
05:10:45 <statusfailed> Guest28642: Are you trying to write it without any higher-order functions?
05:11:45 <maukem> the basic structure is ok, but the type should be Int -> IO [Int]
05:11:50 <maukem> and then you have to change the code a bit
05:13:03 <hop_> newbie here: I have the feeling I am something ugly when I tried to lift my pure function into the IO monad: https://gist.github.com/anonymous/ea97d18e8038627a6a35. Is the (return .hopla) proper way to do this kind of things?
05:13:45 <vanila> hop_, why not use let instead of <- then?
05:13:51 <mmmm> hop_: You can use let instead.. ie let all = hopla re file
05:13:53 <vanila> let all = hopla re file
05:14:11 <hop_> vanila: ah :-) I am feeling stupid. Thanks!
05:14:39 <Chathurga> fmap (hopla re) (D.readFile "r10stdlib.pre.pssl") might be nice too, depending on your style
05:15:24 <hop_> Chathurga: thanks!
05:15:33 <Guest28642> statusfailed: no
05:16:47 <Guest28642> I guess I don't understand -- in readInts, I'm doing readLn, then appending a call to readInts again. Why would that lead to a "list of actions?"
05:16:57 <Guest28642> shouldn't each separate iteration of readLn work?
05:17:00 <maukem> you're not "doing" readLn
05:17:08 <maukem> you're just using it as a value
05:17:12 <Guest28642> ah
05:17:22 <Chathurga> hop_: You could also use the operator version of fmap: hopla re <$> D.readFile "r10stdlib.pre.pssl"
05:17:23 <Guest28642> imperative thinking
05:17:39 <maukem> > let readHello 0 = []; readHello n = "hello" : readHello (n - 1) in readHello 3
05:17:41 <lambdabot>  ["hello","hello","hello"]
05:17:45 <maukem> same function :-)
05:17:47 <Chathurga> hop_: Your code and that are the same, usually when you do (return .) it can be replaced by fmap
05:17:53 <maukem> it's simply building a list
05:19:00 <Guest28642> maukem: Ok, I see that, but it's literally returning a string literal "hello." Shouldn't each call to readLn be equivalent to "readHello n = [the unique value for this call of the function] : readHello (n - 1)"?
05:19:26 <maukem> readLn isn't a function
05:19:33 <maukem> (and you can't call it)
05:21:01 <maukem> Guest28642: btw, what other programming languages do you know?
05:23:06 <zwer> Guest28642 you seem to know how to use do notation, so why don't you try using it in readHello?
05:23:09 <Guest28642> maukem: Is there a good explanation of this that I can read?
05:23:24 <Guest28642> ergh, stupid web client didn't scroll down
05:23:25 <endiruna> is it true that one can get same efficiency(or close enough) with recursion as with non recursive algorithms?
05:24:24 <asthasr> maukem: Ruby, Python, Java, Clojure, JavaScript/CoffeeScript, and some Scala. :)
05:24:39 <endiruna> i was wondering because it seems that with haskell it is rather easy to implement a recursion
05:24:39 <Fare> regarding the discussion a few hours ago, I know remember why I had to do this monadic transformation the hard way:
05:24:40 <vanila> endiruna, yeah its true
05:24:47 <Chathurga> endiruna: Tail call recursion can be unrolled to a loop essentailly
05:24:58 <Fare> because I wanted to leverage the haskell type-system, rather than reimplement it
05:25:08 <bartavelle> how can I associate constructors of a sum type (basically an enum) to a type ?
05:25:19 <Fare> Chathurga: not in the general case, it cannot
05:25:21 <bartavelle> I want to deserialize stuff :/
05:25:31 <bartavelle> stuff that is not in a sum type !
05:25:39 <maukem> asthasr: IO has similarities to JS's ajax stuff
05:25:48 <Fare> or you need a central loop for ALL the code, or a little more decentralized, a trampoline
05:26:09 <bartavelle> or perhaps I should just build yet another sum type and be done with it :/
05:26:34 <maukem> asthasr: you can't call readLn in Haskell and you can't implement sleep() in JS
05:26:45 <maukem> instead: callbacks
05:26:57 <endiruna> vanila Chathurga : is there a theorem that says that?
05:27:05 <Fare> bartavelle: not sure what you mean ó or are you trying to go meta and generate typed code from an untyped description?
05:27:13 <Fare> you could do that with dependent types
05:27:26 <Fare> types computed from data
05:27:55 <vanila> endiruna, the idea is that you can write a loop using recursion which has the same execution behavior (same memory usage, same number of steps)
05:27:59 <bartavelle> Fare : yes that is what I need, except I need it in haskell
05:28:01 <Chathurga> Yeah I worded it badly, I meant more performs like a loop, as in keeps a single stack frame
05:28:18 <maukem> asthasr: https://www.haskell.org/haskellwiki/Introduction_to_IO
05:28:23 <bartavelle> but I'll just reencode my data types, it will not be as elegant, but at least it will be resilient
05:28:24 <asthasr> maukem: That makes sense, but I was envisioning the "callbacks" to readLn as distinct; so that it would be [readLn1, readLn2, readLn3, ...] instead of just [readLn, ...]
05:28:33 <bartavelle> well, not too complicated
05:28:35 <maukem> asthasr: there are no callbacks in that code
05:29:09 <maukem> asthasr: readLn is a constant
05:29:25 <maukem> it's ... well, not entirely unlike XMLHttpRequest
05:29:30 <maukem> of which there's only one
05:30:43 <danilo2> Hello! In haskell (lenses) we've got (&) a f = f a. Is there any standard library providing operator like (&&) a b = f a b ? If not, just out of curious - && is a good name for such operator ? :)
05:30:44 <asthasr> maukem: Ah, right. So, the <- in the do notation is "pulling" a value from it
05:31:11 <maukem> asthasr: right. but I'd actually recommend skipping do notation for now and just using >>= directly
05:31:25 <maukem> when I was starting, it made things clearer
05:31:29 <jonazzzzz> can anyone hlep met UI? i want a popup with 2 textfields and a button.. i only found this example <popup>\
05:31:29 <jonazzzzz> \            <menuitem action=\"EDA\" />\
05:31:37 <asthasr> danilo2: As a naive non-expert, if I see && I assume it's a boolean operator... it's so unusual that overloading it seems painful to me
05:31:41 <tdammers> :t (&&)
05:31:42 <lambdabot> Bool -> Bool -> Bool
05:31:46 <jonazzzzz> is it <input action ="test"> or something?
05:31:48 <tdammers> so, uh, probably not a good name
05:32:29 <asthasr> maukem: Makes sense, like avoiding it in clojure/lisp
05:32:30 <Chathurga> &&& is taken too, &&&& is free as far as I know
05:32:39 <aorecphgsntheu> :t &&&
05:32:40 <lambdabot> parse error on input ‚Äò&&&‚Äô
05:32:47 <aorecphgsntheu> :t (&&&)
05:32:47 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
05:32:49 <asthasr> :t (&&&)
05:32:50 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
05:32:56 <Chathurga> The 3 stripping nuns operator
05:33:10 <Chathurga> :t (*2) &&& (+1)
05:33:11 <lambdabot> Num c' => c' -> (c', c')
05:33:21 <maukem> Arrow (~>) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
05:33:25 <maukem> now with more infix
05:33:53 <batchm> asthasr well.. do in clojure/lisp has nothing to do with do in haskell
05:34:11 <danilo2> asthasr, tdammers: heh, because of Haskell many operators I just was not thinking about this meaning of && :D Right :)
05:34:18 <batchm> and you will want to use do once you learn what it desugars to
05:34:41 <maukem> do is overrated :-)
05:34:59 <asthasr> batchm: Understood.
05:35:10 <Chathurga> Yeah not a fan either, in most cases
05:35:38 <tdammers> do notation is admitting defeat :D
05:35:41 <batchm> I sometimes like liftA* and >>= over do, but mx >>= \x -> ..  is just ugly
05:35:45 <Chathurga> I much prefer applicative syntax and bind
05:36:08 <Chathurga> if you can see a variable it means the terrorists have won
05:36:10 <tdammers> (f . g . g) <$> foo <*> bar <*> baz -- \o/
05:36:27 <batchm> >> and <* make for a neat code too sometimes
05:36:53 <maukem> *> <*
05:37:28 <jonazzzzz> gtk2hs: i want a popup with 2 textfields and a button.. i only found this example <popup>\ <menuitem action=\"EDA\" />\, how to specify input/buttons?
05:38:04 <aorecphgsntheu> :t (<*)
05:38:04 <lambdabot> Applicative f => f a -> f b -> f a
05:38:45 <Chathurga> @pl \a b c f d -> a <$> f b <*> c <*> d
05:38:45 <lambdabot> (. ((((<*>) .) .) . flip . ((<*>) .) . flip id)) . (.) . (.) . (.) . (<$>)
05:38:56 <Chathurga> Cool I'll use that
05:39:13 <maukem> @unpl (. ((((<*>) .) .) . flip . ((<*>) .) . flip id)) . (.) . (.) . (.) . (<$>)
05:39:13 <lambdabot> (\ w as n q t -> w <$> (((q as) <*> n) <*> t))
05:39:25 <maukem> nice
05:39:29 <Chathurga> Wow that's actually rreally cool
05:40:33 <asthasr> Personally I like to make haskell look as lispy as possible and write things like (+ 3 7) all the time!
05:40:53 <indiagreen> ((+) 3 7), you mean
05:41:09 <asthasr> indiagreen: ...trolling fail.
05:41:21 <indiagreen> why, it's even *more* parentheses
05:41:28 <asthasr> :(
05:41:38 <hodapp> huh, I think I kind of sort of made sense of GADTs
05:41:56 <hodapp> after my brief foray into "hey, I should put a typeclass constraint on a data declaration!"
05:42:57 <maukem> > (+ 3) 7
05:42:58 <lambdabot>  10
05:43:32 <clrnd> > (<*>) ((<$>) (+) (Just 5)) (Just 6)
05:43:32 <jonazzzzz> nobody can help me??
05:43:33 <lambdabot>  Just 11
05:44:14 <clrnd> jonazzzzz, what does the gtk docs say?
05:44:24 <jonazzzzz> nothing i can't find it
05:44:43 <Xeironis> > ((. Just) . (<*>) . ((+) <$>) . Just) 5 6
05:44:44 <lambdabot>  Just 11
05:45:05 * hodapp now has "what does the docs say" stuck in his head
05:45:13 <batchm> asthasr here are three ways of doing what you wanted.. from most elegant to (probably) easiest to understand for a beginner. http://ideone.com/LqEoSN
05:47:38 <asthasr> batchm maukem: Thanks guys. Time for work, so I'll save these links to read after I write Ruby and Java for 8-9 hours. :D
05:47:40 <asthasr> :'D
05:49:11 <batchm> welcome. and I am going too, have to study
05:49:11 <dfeuer> @tell int-e Unless I got something mixed up, it looks like the liftA2 thing makes no difference in the benchmarks even for 2 and 3 element xs sequences, and it does a bit worse on the immediate-indexing test. So I guess it's just a bad idea.
05:49:11 <lambdabot> Consider it noted.
05:52:48 * ichbineintroll_m ist ein troll
05:56:28 <dfeuer> @tell SrPx There's a lot of back-and-forth between library development and compiler development. The library writers try to write libraries so GHC will compile them well; when that doesn't work out well enough, they demand optimizations from GHC. Most are data structure neutral; exceptions tend to be really basic types in the base "package", like [], Bool, Maybe, String, and Array#.
05:56:29 <lambdabot> Consider it noted.
05:57:27 <jonazzzzz> noobs
05:59:37 <Chathurga> !!!
06:00:18 <jonazzzzz> > i'm a better bot
06:00:19 <lambdabot>  Not in scope: ‚Äòi'm‚ÄôNot in scope: ‚Äòbetter‚ÄôNot in scope: ‚Äòbot‚Äô
06:00:20 <lambdabot>  Perhaps you meant one of these:
06:00:20 <lambdabot>    ‚Äònot‚Äô (imported from Data.Bool),
06:12:46 <ij> Any difference between glfw{,-b}?
06:13:40 <gspr> ij: The GLFW docs say: "Note that this binding comes with an older GLFW C version 2.7.9 due to incompatible API changes in GLFW since 3.0 (for example, the removal of texture functions). If you want to use newer GLFW C versions, install Haskell package GLFW-b instead."
06:13:43 <besenwesen> one binds the old version
06:29:28 <SrPx> What is wrong with this code? http://lpaste.net/117090
06:30:01 <maukem> MVec is not defined
06:30:14 <SrPx> import qualified Data.Vector.Unboxed.Mutable as MVec *
06:30:49 <maukem> looks like you're trying to return an ST variable from an ST action
06:31:20 <maukem> which is pretty much *the* thing runST's type protects against
06:31:28 <SrPx> I get it, let me think
06:31:48 <maukem> :t runST (newSTRef ())
06:31:49 <lambdabot>     Couldn't match type ‚Äòa‚Äô with ‚ÄòSTRef s ()‚Äô
06:31:49 <lambdabot>       because type variable ‚Äòs‚Äô would escape its scope
06:31:49 <lambdabot>     This (rigid, skolem) type variable is bound by
06:32:56 <gspr> SrPx: Look at freeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)
06:34:30 <SrPx> gspr: maukem sure it works now, thank you (=
06:34:51 <SuperHotFire> elementAt :: [a] -> Int -> a
06:34:56 <SuperHotFire> is this a valid statement?
06:35:13 <gspr> SuperHotFire: It's a valid type signature...
06:35:38 <SuperHotFire> gspr, ty
06:35:39 <maukem> @hoogle [a] -> Int -> a
06:35:41 <lambdabot> Prelude (!!) :: [a] -> Int -> a
06:35:41 <lambdabot> Data.List (!!) :: [a] -> Int -> a
06:35:41 <lambdabot> Prelude drop :: Int -> [a] -> [a]
06:36:18 <gspr> SuperHotFire: But, as maukem points out, you're probably looking for (!!) from Prelude.
06:36:45 <gspr> Moreover, if you find yourself using (!!) or elementAt a lot, you probably shouldn't be using lists, since indexing is O(length of list)
06:37:10 <gspr> (while Vectors are indexed in constant time)
06:37:59 <maukem> more like O(i)
06:38:17 <maukem> (!! 42) is constant time, no matter the list
06:38:33 <gspr> Oops, sorry, of course :)
06:38:45 <zwer> O(N) worst case
06:38:57 <maukem> > [0 ..] !! 5
06:38:58 <lambdabot>  5
06:40:35 <zwer> > [0 ..] !! maxBound
06:40:38 <lambdabot>  mueval-core: Time limit exceeded
06:42:04 <Denommus> pyon: was I banned from ##programming or something?
06:42:18 <SrPx> I am kinda confused with a point. Notice my mvec_empty function now: http://lpaste.net/117090 - when I learned about monads, someone wrote that as long as your function has a "pure" type, you know for sure it isn't doing things like reading files or sending tcp messages under the hood. But the value "mvec_empty" has a pure type and it is doing some mutable operations under the hood...
06:42:20 <Denommus> whops, wrong channel
06:42:24 <SrPx> mvec_empty value*
06:42:53 <SuperHotFire> Why doesn't this work?
06:42:57 <SuperHotFire> elementAt :: [a] -> Integer -> a
06:42:57 <SuperHotFire> elementAt a b (x:xs)
06:42:57 <SuperHotFire> 		| a == x = 0
06:42:57 <SuperHotFire> 		| otherwise = x + b
06:43:16 <SuperHotFire> It's from 99problems, question 3
06:44:22 <SrPx> SuperHotFire: there is something wrong, why the type of elementAt tells it only has 2 arguments, if it actually has 3?
06:45:01 <SuperHotFire> Erm, does it have three?
06:45:15 <Cale> SuperHotFire: a, b, and (x:xs)
06:45:31 <SrPx> a, b and (x:xs), right? I'm not the best expert though
06:45:36 <SuperHotFire> I asked someone before, but the answer regarding (x:xs) being an element was unclear.
06:46:07 <SrPx> a is an argument, b is an argument and (x:xs) is an argument that gets destructured and assigned to two different variables for convenience when the function is called
06:46:46 <SuperHotFire> Ok, I see now. What kind of argument is (x:xs)?
06:46:57 <SuperHotFire> Can I type in [a] or what?
06:47:10 <endiruna> hello, i wrote this little function http://lpaste.net/117094  that should take a list of 1 and 0 and should try to find the connected components(subsequent 1s) and calculate on each of them a certain function that depends on the length. i get In the expression: x == [] and I do not understand what might be the problem. i am very new to haskell so perhaps i am doing something really really stupid
06:47:59 <endiruna> what i wanted to say is that i get a compilation error
06:48:12 <Xeironis> endiruna: x is not a list, you cannot check if it is equal to []
06:48:34 <SrPx> SuperHotFire: it looks like it is [a] indeed, elementAt :: [a] ‚Üí Integer ‚Üí [a] ‚Üí a would make more sense, but
06:48:34 <endiruna> that should be xs right!
06:48:40 <endiruna> thanks Xeironis !
06:48:42 <Xeironis> no problem
06:48:48 <SuperHotFire> but?
06:49:12 <SrPx> SuperHotFire: the argument "a" doesn't look like a list since you are comparing it to "x" which isn't a list (but the first element of a list)
06:49:17 <Cale> SuperHotFire: Well, hang on. The original type you had for elementAt was probably the right one. What is the function supposed to do?
06:49:43 <SrPx> I'm not sure how your function works though, if you explain with words I can guess better what is wrong !
06:49:55 <SrPx> SuperHotFire: oh listen to Cale (:
06:50:00 <Cale> If it's meant to take a list and a number, and give the element of the list at the given position, then the original type seems appropriate
06:50:05 <SuperHotFire> (["take", "in", "list"] 3) >> "list"
06:50:36 <Xeironis> indexing conventionally starts at 0
06:51:14 <Cale> SuperHotFire: You probably want elementAt (x:xs) n = ...
06:51:17 <zwer> SuperHotFire those are two arguments, not three
06:51:28 <Cale> (possibly with some guards as well)
06:51:40 <simon> shouldn't ghc -static Foo generate an executable that doesn't link to shared libraries?
06:52:25 <simon> is there a way to inline specific libraries and not necessarily everything Haskell?
06:52:56 <simon> (I guess this is more of an ELF question than a Haskell question...)
06:53:14 <SuperHotFire> Cale, what do you mean? Trying to write the code with no guards? :S
06:54:19 <Cale> simon: -static is the default, it just means to avoid shared Haskell libraries if possible
06:54:47 <simon> Cale, ah. I'm actually trying to avoid libffi6 which seems to be an external library.
06:55:52 <simon> I should probably just try to make libffi6 work on this damn box. but then it occurred to me that "partially static executables" was something I'd never heard of.
06:59:45 <SuperHotFire> elementAt :: [a] -> Integer -> a
06:59:45 <SuperHotFire> elementAt (x:xs) a
06:59:45 <SuperHotFire> 		| a == x = 0
06:59:45 <SuperHotFire> 		| otherwise = x + a
07:00:03 <SuperHotFire> Why doesn't it work now then? :S
07:00:04 <Cale> SuperHotFire: a is an Integer, such as 6
07:00:16 <Cale> x is any type of value, perhaps it's a string or a function
07:00:19 <SuperHotFire> Yeah I know, which is bound to box x
07:00:38 <SuperHotFire> I assigned it to be = 0
07:00:45 <Cale> no you did not
07:00:52 <wei2912> what?
07:01:18 <wei2912> you can't compare any value with a just like that
07:01:23 <Cale> You have no control over the value of x in the implementation of this function. It is an arbitrary value.
07:01:30 <wei2912> ^^
07:01:44 <Cale> (it is the first element of the list that elementAt is applied to)
07:02:30 <wei2912> the reuse of a as a variable is confusing, so let's tweak the function
07:02:37 <wei2912> elementAt :: [a] -> Integer -> a
07:02:40 <wei2912> elementAt (x:xs) y
07:02:45 <wei2912>     | x == y = 0
07:02:49 <wei2912>     | otherwise = x + y
07:02:53 <Cale> I'd have used n, but okay :)
07:03:08 <wei2912> now, note the functions you're using in that function
07:03:12 <endiruna> i changed my function and now I get non exhaustive pattern. so to recap i have a list of 1s and 0 and i would like to create a new list where each element is a function on each connected component(ie a subset of contiguous 1s)
07:03:12 <Cale> But the x == y is nonsense
07:03:19 <Cale> Because x might be a String
07:03:23 <wei2912> SuperHotFire: what functions are you using in that function?
07:03:28 <wei2912> SuperHotFire: no pun intended
07:03:36 <Cale> and besides, why are you checking to see if the first element of the list matches the integer?
07:03:40 <endiruna> i have an otherwise in the function so i am surprized that such an error would come out
07:03:47 <wei2912> Cale: no idea tbh
07:03:57 <Cale> That was a question for SuperHotFire
07:04:00 <SuperHotFire> You're looking at it. :P
07:04:09 <wei2912> Cale: i completely don't know what he's doing ;P
07:04:19 <SuperHotFire> Because if I could match the boxes with numbers.
07:04:24 <SuperHotFire> Like, a == x
07:04:30 <Cale> boxes?
07:04:37 <SuperHotFire> I would just change y to change a
07:04:45 <Cale> change?
07:04:49 <SuperHotFire> listnumbers.
07:04:52 <wei2912> you sound very confused
07:05:08 <Cale> SuperHotFire: Do you want me to give you this one?
07:05:12 <SuperHotFire> Sure..
07:05:18 <wei2912> @src (!!)
07:05:18 <lambdabot> xs     !! n | n < 0 = undefined
07:05:18 <lambdabot> []     !! _         = undefined
07:05:18 <lambdabot> (x:_)  !! 0         = x
07:05:18 <lambdabot> (_:xs) !! n         = xs !! (n-1)
07:05:30 <Cale> wei2912: thanks, but no thanks, I want to explain this
07:05:36 <wei2912> Cale: sure
07:06:08 <Cale> Okay, so first of all, let's break the problem into two cases: the case where we're trying to get the 0th (or first) element of the list
07:06:19 <Cale> and the case where we want some further element
07:06:57 <Cale> So, elementAt (x:xs) 0 = x, because x is the 0th element of the list (x:xs)
07:07:06 <Cale> right?
07:07:13 <SuperHotFire> yes.
07:07:33 <Cale> and then so we need to deal with  elementAt (x:xs) n
07:08:09 <Cale> How can we make the problem smaller? Well, the nth element of (x:xs) is the (n-1)'th element of xs
07:08:23 <Cale> So elementAt (x:xs) n = elementAt xs (n-1)
07:09:27 <SrPx> > No instance for (NFData (Tree Int)) arising from a use of ‚Äòdeepseq‚Äô
07:09:28 <lambdabot>  <hint>:1:4: parse error on input ‚Äòinstance‚Äô
07:09:33 <SrPx> How do I make my structure deepseq'able?
07:10:12 <Cale> SrPx: By writing an instance of NFData for it.
07:10:39 <SrPx> sure, but how? I couldn't find anything explaining
07:10:59 <mmmm> look in deepseq-generics if you just want generic instances
07:12:30 <SuperHotFire> Cale, could you explain why you used .... = elementAt xs (n-1)? Just the elementAt part
07:12:54 <Enzoray> Because I find it rather confusing.
07:13:05 <Cale> SuperHotFire: Well, the element at position n in (x:xs) is equal to the element at position (n-1) in xs, right?
07:13:28 <Cale> But (n-1) is (assuming n was positive to begin with) a smaller number than n
07:13:37 * hackagebot elm-package 0.2.2 - Package manager for Elm libraries  http://hackage.haskell.org/package/elm-package-0.2.2 (MaxNew)
07:13:52 <Cale> So, we're getting closer to the case where we're looking for the 0th element in a hopefully nonempty list
07:15:03 <Cale> SrPx: instance NFData a => NFData (Tree a) where rnf Tip = (); rnf (Branch x l r) = rnf x `seq` rnf l `seq` rnf r
07:15:21 <Cale> SrPx: Something like that, you can adapt it for the particular tree type you're using
07:15:31 <zwer> Cale shouldn't that be `deepseq` ?
07:15:48 <zwer> if x is a list `seq` won't fully evaluate it
07:15:59 <endiruna> found the error! ghc is pretty smart!!! really surprising
07:16:02 <Cale> none of those things are lists
07:16:11 <Cale> they're in fact empty tuples
07:16:19 <SrPx> http://lpaste.net/117102 I tried this but it didn't work... I didn't knew it was just a chain of `seq`s, let me try
07:16:27 <Enzoray> Cale, I think I see what you mean now with the whole n - xs thing.
07:16:38 <zwer> Cale ok.. still seems less error prone to just put `deepseq` everywhere
07:16:45 <Cale> Enzoray: n - xs? what?
07:16:52 <Cale> Enzoray: xs is a list
07:16:52 <Enzoray> xs - n I mean
07:16:53 <zwer> as a general rule
07:16:57 <Cale> Enzoray: n is a number
07:17:02 <Cale> You can't subtract the
07:17:03 <Cale> m
07:17:11 <Cale> zwer: hm?
07:17:28 <zwer> Cale when writing NFData instance
07:17:29 <Cale> zwer: rnf is the method that you define in order to define the NFData class
07:17:38 <zwer> yes
07:17:41 <Cale> deepseq isn't a method directly, it's separate
07:17:48 <Enzoray> I mean (n-1)! Sorry, I was reading what you read and the words got absorbed by my mind. :P
07:17:59 <zwer> Cale I realize that
07:18:06 <Enzoray> typed*
07:18:21 <Cale> I guess you can still use deepseq on the right if you prefer
07:18:23 <SrPx> It worked Cale, thanks
07:18:37 * hackagebot clanki 1.0.6 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.0.6 (marcusbuffett)
07:19:13 <Enzoray> So, you're saying x:xs is still merged, even though they are splitted.
07:19:26 <freeman42> anyone know where there is a quickcheck example of how generators are used? (repasted from #..beginners)
07:19:59 <Enzoray> Because, for ME. if I was at position n in xs, then -1 I would go out of bounds, not to x.
07:20:09 <Enzoray> n being = 0 in xs.
07:20:29 <zwer> Cale my point is that using `deepseq` everywhere in rnf definition is less error prone than trying to figure out if seq will suffice for every element
07:20:35 <Enzoray> So, I should approach this problem as they are still, in a way merged. :P
07:20:44 <Cale> zwer: I'm not applying seq to any of the elements there
07:20:55 <Cale> zwer: I'm applying it to the rnfs of various things
07:21:46 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/deepseq-1.3.0.2/src/Control-DeepSeq.html#NFData -- this is how instances of NFData typically look
07:22:31 <zwer> Cale let me give an example
07:22:51 <zwer> do you see any issue in here? http://lpaste.net/117104
07:23:15 <Cale> yes, that's wrong. It's also nothing like my example.
07:23:30 <Cale> (did you read my example)
07:24:14 <zwer> I am not saying your example was wrong. just that it is easier to get it right if you use `deepseq` everywhere. ie: rnf (Foo x y) = x `deepseq` y `deepseq` ()
07:24:31 <zwer> is there any argument for not doing that?
07:25:41 <Cale> It's entirely equivalent to what I wrote
07:26:03 <Cale> deepseq x y = rnf x `seq` y
07:26:32 <Cale> So you can also just apply rnf to everything and seq the results
07:28:06 <zwer> ok I did not read that right, you actually put rnf in front of everything
07:28:07 <Enzoray> elementAt :: [a] -> Integer -> a
07:28:07 <Enzoray> elementAt (x:xs) n
07:28:07 <Enzoray> 		| n == x = 0
07:28:07 <Enzoray> 		| otherwise = elementAt (n-1) xs
07:28:29 <Cale> Enzoray: stop comparing n with x
07:28:33 <Cale> they're not even the same type
07:28:48 <Cale> n is an Integer, it's the position at which we want to extract an element
07:28:52 <Enzoray> Then the guards seems pretty worthless to me.
07:28:58 <Cale> x is an element of the list, and is of any type at all
07:29:00 <zwer> still, I think deepseq is more readable/less error prone :)
07:30:03 <Cale> zwer: I dunno, I sort of thought that direct recursion would be easier to understand than mutual recursion
07:30:19 <Cale> Enzoray: Actually, if you swap the 0 and x there, it will work
07:30:28 <Cale> You want to check if n is 0
07:30:37 <Cale> and if so, then the result is x, the 0th element of the list
07:31:06 <Enzoray> Hmm, a new way of thinking.
07:31:10 <Cale> Not check whether n is x, and if so, the result is 0, that doesn't make sense because you're not even looking for produce a number.
07:31:17 <Cale> s/for/to/
07:31:26 <klewis> is haskell good choice for writing GUI programs?
07:31:34 <Enzoray> No, not really.
07:31:36 <Enzoray> Go to Java.
07:31:37 <Enzoray> :P
07:31:39 <Cale> klewis: It's no worse than anything else
07:32:24 <klewis> even if target platform is windows?
07:33:25 <Cale> klewis: Well, I don't really know much about Windows, since I almost never use it, but Gtk2Hs and WxHaskell both work on Windows.
07:33:37 * hackagebot PTQ 0.0.7 - An implementation of Montague's PTQ.  http://hackage.haskell.org/package/PTQ-0.0.7 (MasahiroSakai)
07:33:48 <freeman42> found a generators example http://www.stuartgunter.org/intro-to-quickcheck/
07:34:20 <Enzoray> So, now I have checked that n == 0 = x; giving me x = 0, n = 0. Now I just have to put it into action
07:34:28 <Enzoray> Any clues, Cale?
07:34:48 <Skola> What's the current state of affairs for real-time audio programming in Haskell? Anything cross-platform still being maintained?
07:34:59 <Cale> Enzoray: no, n == 0 is a test, it's a Bool value, i.e. either it's True, or it's False
07:35:21 <Cale> Enzoray: When that condition turns out to be True, the corresponding right hand side of the = is taken
07:35:51 <Cale> Enzoray: i.e. in this case, when n == 0, the function gives the result x.
07:36:30 <klewis> cale is it recommended to just use those bindings directly? i was checking out reactive banana
07:36:31 <Enzoray> Hmm, I see.
07:36:39 <nshepperd> it should really be written   | n == 0      = x
07:36:58 <nshepperd> so that the guard condition is clearly separate from the result
07:37:03 <Enzoray> nsheppard, it is.
07:37:17 <Enzoray> almost. :P
07:37:25 <Enzoray> are you telling me to tab it away?
07:38:02 <batchm> i am having a lot of fun parsing things with parsec.. actually i never had this much fun parsing in other languages
07:38:02 <Cale> klewis: I know some people have set things up using reactive-banana. I haven't really ever used reactive-banana myself, but I don't know. How complicated is your GUI?
07:38:04 <nshepperd> I find it helpful to put lots of whitespace in there so that n == 0 = x doesn't look like one expression
07:38:06 <zipper> Is there a way to see in the repl step by step how my function is being run?
07:38:52 <Enzoray> Well, what now then? How am I going to solve this?
07:38:52 <nshepperd> because what it really means is "when n == 0, then elementAt (x:xs) n = x"
07:39:21 <Cale> Enzoray: if you made the change I recommended, it should work
07:39:39 <Enzoray> elementAt :: [a] -> Integer -> a
07:39:40 <Enzoray> elementAt (x:xs) n
07:39:40 <Enzoray> 		| n == 0 =	x
07:39:40 <Enzoray> 		| otherwise = (elementAt (n-1) xs
07:39:51 <Cale> You have an unclosed paren
07:39:58 <klewis> Cale half a dozeb of forms, buttons, menu and a table (if possible with ability to sort data per column)
07:39:59 <Enzoray> unclosed?
07:40:05 <Enzoray> how do i close it?
07:40:05 <Cale> ( without )
07:40:10 <Enzoray> oh...
07:40:52 <Enzoray> "Can't match expected type [a] with actual type Integer"
07:40:57 <Enzoray> Doesn't work.
07:41:11 <srhb> Enzoray: You mixed up the arguments.
07:41:22 <srhb> elementAt (n-1) is a type error.
07:41:40 <Cale> Oh, yes, that too
07:41:42 <Enzoray> How come?
07:41:42 <batchm> you mixed up arguments because elementAt index reads better!
07:41:50 <srhb> Enzoray: Because your first argument is the list, not the counter.
07:42:13 <Enzoray> Does it matter? :S
07:42:16 <srhb> Enzoray: Uh, yes.
07:42:18 <srhb> :P
07:42:19 <Cale> klewis: Hmm, well, maybe something to look into is this reactive-banana-wx package
07:42:33 <Enzoray> Well, thanks a lot for clearing it up for me.
07:42:40 <Cale> klewis: But it appears like you ought to know what you're doing with wxHaskell beforehand.
07:42:41 <Enzoray> I'm trying to learn, sorry for being such a drag. :D
07:42:57 <srhb> Enzoray: You can't just randomly toss in arguments in some weird order, you have to stick with one order. Your type signature and your first line of the definition both agree that the list is first, then the counter. :)
07:43:41 <Enzoray> So, if I typ asasd :: Integer -> String (i know)
07:43:43 <batchm> Enzoray do you know any other programming language? I can't think of a single one where swapping arguments arbitrarily won't break things
07:43:50 <srhb> Enzoray: Also if you added the closing paranthesis, it is in fact unnecessary. elementAt (n-1) xs is fine
07:43:57 <Enzoray> asasd integer string = ...
07:43:58 <Enzoray> Right?
07:44:02 <srhb> Enzoray: Yes.
07:44:15 <Enzoray> C#, a bit. Also some Java.
07:44:16 <Cale> no
07:44:19 <srhb> Enzoray: For some function Integer -> String -> ?
07:44:25 <SrPx> I asked yesterday what is a good purely functional structure to use instead of mutable vectors... some suggested "Seq", but my benchmarks showed it is ~500x slower than mvecs... is there anything better? http://lpaste.net/117105
07:44:37 <Cale> Yeah, if it's Integer -> String -> Something
07:44:50 <Cale> then you can apply asasd to an Integer and then a String
07:45:02 <Enzoray> Yeah, ofc. I was just trying to focus on the form here. Not the rightness of the expression
07:45:09 <Cale> But if it were just  Integer -> String, then that means it takes just one argument
07:45:15 <SrPx> Considering log2(65536) = 16, I didn't expect much more than a 16x slowdown. Not 500x...
07:45:15 <Cale> and produces a String result
07:45:19 <Enzoray> I know. :P
07:45:23 <Cale> okay :)
07:45:39 <Enzoray> Thanks for clearing that up. :)
07:45:43 <srhb> Sure thing.
07:46:10 <Cale> SrPx: Well, yeah, the constant factors on Seq are pretty hefty
07:46:15 <srhb> Enzoray: By the way, I don't think either C# or Java does it differently. Well, aside from syntax, but f(x,y,z) is generally not the same as f(z,y,x) etc.
07:46:32 <batchm> not sure if this will help.. but i can't resist... all functions in haskell take just one argument
07:46:50 <indiagreen_> shhhhhh
07:46:58 <Enzoray> srhb, fyi. I'm 18 years old, programmed some C# in school, did a course in that. So I'm pretty much a n00b.
07:47:06 <srhb> Enzoray: That's fine. :)
07:47:23 <sinelaw> Enzoray, perfect time to learn Haskell! Wish I did at that age.
07:47:24 <Enzoray> That's why my knowledge is regarding programing is.. fairly limited.
07:47:28 <hamid> Enzoray, I'm noob, too. Noobs rock :D
07:47:44 <SrPx> Cale: sad, is there anything better? I tried implementing it as fast as I can with this: http://lpaste.net/117107 but the results were at most 2x better than seq
07:47:45 <Cale> Enzoray: What have you been reading?
07:47:48 <SrPx> :(
07:47:53 <sinelaw> That may actually be an advantage. less time for wrong misconceptions to sink in.
07:48:08 <Cale> SrPx: Have you considered using IntMap?
07:48:09 <srhb> sinelaw: Wrong misconceptions? :-)
07:48:17 <Enzoray> IT & Communication at high school, now in university-- Computer Science.
07:48:20 <SrPx> no, brb
07:48:20 <GaveUp> sometimes I think it'd be easier to pick up functional languages without a background in other languages
07:48:28 <sinelaw> srhb, yeah, like unknown unknown :P
07:48:35 <sinelaw> *unknown unknowns
07:49:15 <Cale> SrPx: Usually Map or IntMap is the right thing for random access, but neither of those has the contiguousness that an array does
07:49:55 <Enzoray> GaveUp, I've heard that as well. Not much to do about it now is it? :P
07:50:35 <SrPx> is there some kind of syntax sugar that allows us to work with mutable values with less bureaucracy? I struggle anytime I try to use mutable vectors
07:50:50 <srhb> I found FP much easier to reason about than imperative stuff, despite having a background solely in Java (and PHP, forgive me...)
07:50:53 <Cale> Well, you've only had one course in C#, it shouldn't be as bad for you as someone who had been programming for 20 years in imperative languages or something :)
07:51:12 <Enzoray> But it was a 1¬Ω year ago I programmed in c#, so.. that's why I'm pretty.. excluded from programming atm.
07:51:20 <Enzoray> Cale, I guess so.
07:51:23 <tdammers> srhb: you are forgiven
07:52:00 <tdammers> but, anyway, FP scales better in terms of developer brain resources
07:52:28 <batchm> in some ways I think haskell is more intuitive to a total beginner. I tried to teach someone how to loop in python in a couple of minutes and he could not understand it.  then I tried to show him a little haskell, and 10 minutes later he figured by himself that xs = 0 : 1 : xs   will lead to infinite repetition of 0 and 1. true story
07:52:48 <batchm> +an
07:52:58 <Enzoray> How does the program approach this line of code? Can someone pseudo it up for me? :P
07:53:08 <tdammers> reasoning about a 1-line Haskell program can be harder than reasoning about a 1-line Python script, but reasoning about a 10,000-line Haskell program is *much* easier than a 10,000-line Python program
07:53:11 <Enzoray> batchm, I've also tried Python. It's quite funny
07:53:24 <Enzoray> | otherwise = elementAt xs (n-1)
07:53:28 <tdammers> python is wacky
07:53:29 <sinelaw> I has a funny smell
07:53:34 <sinelaw> *It
07:53:35 <sinelaw> not me.
07:53:38 * hackagebot mudbath 0.0.2 - Continuous deployment server for use with GitHub  http://hackage.haskell.org/package/mudbath-0.0.2 (wereHamster)
07:53:41 <tdammers> but I can deal with wacky
07:53:45 <srhb> Enzoray: Is that the line you are asking about?
07:53:47 <Enzoray> I don't rely on the "otherwise:" in haskell. What does it do actually? :P
07:53:48 <Enzoray> Yes.
07:53:51 <tdammers> what I hate about it is how badly it scales to large-ish codebases
07:53:53 <EvanR> what if reasoning about 10000 lines was as difficult as reasoning about 1 line.. times 10000 ;)
07:54:00 <Cale> otherwise is just a constant defined to be True
07:54:03 <Cale> > otherwise
07:54:04 <srhb> Enzoray: It's what we call a recursive call, a call within the function to itself.
07:54:05 <lambdabot>  True
07:54:08 <tdammers> (just like Perl, PHP, Ruby, and the rest of the dynamic bunch, BTW)
07:54:09 <lrocksmashtime> silly question. but how do i install a package in a module i'm building and have be saved as a dependency in cabal? Do i manually add the depedency into the cabal file or is there some neat cabal command to install and put it in for me
07:54:14 <Enzoray> In my language "Otherwise:" gives me a.. funny translation. Making this illogical
07:54:15 <Cale> It's just so that it reads nicely in guards
07:54:33 <Chathurga> Enzoray: This of it like "else"
07:54:36 <Chathurga> *Think
07:54:39 <Enzoray> Or I'm not aware of enought synonyms making it somewhat impossible for me to comprehend.
07:54:40 <Cale> You're saying that if n == 0 then the result is something, and otherwise, the result is something else
07:54:51 <srhb> Enzoray: Ah. Well, it's just always True. What matters is like it's the final clause of the guards, so it will only be evaluated if the preceding guards were False
07:54:55 <tdammers> lrocksmashtime: you add it to the cabal file manually, and then if it's not on hackage, you can install it manually using cabal install /path/to/your/dependency
07:55:06 <lrocksmashtime> tdammers: thanks!
07:55:10 <Enzoray> For me it is like. If above = false, then it jumps to otherwise, which is true
07:55:13 <Enzoray> Is that right?
07:55:29 <Cale> Enzoray: "else" is an Engligh synonym for otherwise (but "else" is reserved in the Haskell syntax)
07:55:48 <Enzoray> Being, if n /= 0. do elementAt xs (n-1)
07:55:54 <srhb> Enzoray: Personally I tend to define that program as elementAt 0 (x:_) = x; elementAt n (_:xs) = elementAt (n-1) xs -- but they are identical
07:55:59 <Enzoray> Hm, English isn't my main language. :P
07:56:05 <Cale> The way that guards work is that each one is evaluated in turn, and the first guard to evaluate to True is the one which wins
07:56:12 <Enzoray> Or native, call it whatever you like. :P
07:56:15 <Cale> and its corresponding right hand side is taken as the result
07:56:41 <Cale> Enzoray: I was suggesting that maybe you could look up "else"
07:56:45 <Enzoray> Ok, so only one result can be retrieved from guards.
07:56:53 <Enzoray> Being the same as "switch" in c#
07:56:57 <Enzoray> hmm?
07:56:58 <srhb> Enzoray: Only one expression is ever the result of a function.
07:57:03 <SrPx> How can I normalize something before benchmarking it? I don't want the speed of building the base list to count on my benchmarking of updating that list...
07:57:15 <Cale> Enzoray: The English words "else" and "otherwise" have similar meanings
07:58:10 <Enzoray> Yeah, but in my language, otherwise == else = True
07:58:46 <Cale> Enzoray: okay
07:59:35 <Enzoray> Almost, I guess. I might just have a lack of vocabulary regarding the word.
07:59:43 <Cale> So yeah, otherwise is just defined to be True because that makes the guard succeed. It's meant to be used in the last of a bunch of guards as a sort of catch-all.
07:59:59 <Enzoray> Hmm, ok.
08:00:21 <SrPx> if I do "deepseq foo (defaultMain my_benchamrks)" can I be sure "foo" will be 100% reduced and not count when criterion does the benchmarks?
08:00:24 <batchm> > otherwise
08:00:25 <lambdabot>  True
08:00:39 <srhb> Enzoray: You can just write True instead and your program will work identically. Because they are identical. But it's not idiomatic. :)
08:00:44 <Cale> SrPx: Yeah, so long as foo isn't typeclass polymorphic, that should work
08:00:46 <Enzoray> Hmm. ok
08:01:13 <Enzoray> Idiomatic, I have to look that up. :D
08:01:16 <SrPx> didn't work :(
08:01:32 <Enzoray> Now for the code, could you explain what the code does? Excluding otherwise =
08:01:34 <Enzoray> 		| otherwise = elementAt xs (n-1)
08:01:35 <srhb> Enzoray: "Typical" -- we tend to use otherwise instead of True as the last guard because it reads better.
08:01:47 <erisco> why is the singletons package called singletons?
08:01:49 <srhb> Enzoray: Try running it by hand. Say, elementAt 2 [1,2,3]
08:01:52 <batchm> Enzoray do you understand recursion?
08:02:21 <Cale> Enzoray: So, you know how every list in Haskell is either the empty list [] or it is a nonempty list formed by taking some element x and adding it to the beginning of another list xs?
08:02:21 <Enzoray> batchm, erm. I've read about it, I don't really understand it by meaning I have to work with it.
08:02:25 <Cale> i.e. (x:xs)
08:02:27 <srhb> Enzoray: Now, the first clause is untrue, so we move to the otherwise clause. It then looks like this: elementAt (2-1) [2,3]
08:02:28 <Enzoray> Yeah, Ik now.
08:02:32 <SrPx> deepseq (seq_test size) $ defaultMain [ bgroup "tree" [ bench "seq" $ nf seq_test size ] ] -- still takes a lot of time to compute the benchmark regardless of supposedly be already reduced when it hits the benchmark expression
08:02:38 <erisco> Enzoray, hi
08:02:42 <srhb> Enzoray: Then you do the same thing again.
08:02:47 <Cale> Enzoray: Okay, so if you ask me to find the 0th element of (x:xs), I can just hand you x
08:02:48 <Enzoray> erisco, hi :)
08:02:51 <batchm> Enzoray if you don't understand recursion keep reading this sentence from the beginning
08:03:03 <Enzoray> batchm, lol. :P
08:03:17 <Enzoray> I know, it's calling the own function in the funcion
08:03:29 <Enzoray> It makes my brain.. disfuncion. :D
08:03:37 <Cale> Enzoray: But if you ask me to find some later element, say the nth element of (x:xs), then this is the same as searching for the (n-1)th element of xs
08:03:39 * hackagebot markup 0.0.4 - Abstraction for markup languages  http://hackage.haskell.org/package/markup-0.0.4 (athanclark)
08:03:54 <Cale> So that's what we make it do
08:04:01 <batchm> Enzoray you will get used to it
08:04:23 <batchm> we all found it confusing at some point
08:04:23 <Enzoray> Yeah, I'm currently solving 99problems. I think there are some recursion exercises in there.
08:04:24 <Cale> For example
08:04:52 <Cale> elementAt 2 ('a' : ('b' : ('c' : [])))
08:05:06 <Cale> -> elementAt 1 ('b' : ('c' : []))
08:05:16 <Cale> -> elementAt 0 ('c' : [])
08:05:20 <Cale> -> 'c'
08:05:43 <Cale> (sorry, swapped the order of arguments :P)
08:06:02 <Cale> The name of the function suggests that the arguments are in this order instead
08:06:10 <batchm> yes it does
08:06:30 <Enzoray> Okay, basically all I see is that you've done a list with a set of chars.
08:06:34 <srhb> If only English didn't have different prefixes for 1st, 2nd, 3rd, 4th, we could call it nd :-)
08:06:36 <Enzoray> Merging them one by one.
08:06:52 <Cale> Enzoray: This is the sequence of reductions that it makes using the definition of the function
08:07:22 <Cale> Enzoray: It will check to see whether 2 == 0, and when that fails, it will apply elementAt to (2-1) and the remainder of the list
08:07:29 <Enzoray> Okay. So, not what I saw.. :P
08:07:35 <srhb> Enzoray: The first two times the otherwise clause matches, so the head of the list is discarded and the counter is decremented.
08:08:24 <srhb> The third time, the n == 0 clause matches, so x is the result.
08:09:24 <Enzoray> x:xs, giving x the first position in the list. But 'c' was the last.
08:09:29 <batchm> recursive algorithms often have a base case, that breaks the recursion. in this case the base case is n being 0
08:09:35 <Enzoray> You said you wrote it in the wrong order, yes?
08:09:35 <Cale> srhb: Well, when you're zero indexing things the convention is to use 1th, 2th, 3th
08:09:57 <srhb> Enzoray: The intuition here is that finding the nth element of x:xs is the same as finding the (n-1)th element of xs
08:10:23 <marcusbuffett> Hey guys, I have a function that takes a Card and returns an IO Bool, and I want to filter a list of cards by that function, This is what I have : http://lpaste.net/117110, but of course it doesn't work because it expects a Bool, not an IO Bool, how should I fix it to take a IO Bool?
08:10:41 <srhb> marcusbuffett: fmap!
08:10:42 <Enzoray> Or, can it be that the parentescs makes them execute the order, making 'c' the first one in the list?
08:10:44 <Cale> marcusbuffett: use filterM
08:10:55 <srhb> Enzoray: No, nothing like that.
08:10:57 <Cale> :t filterM
08:10:57 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
08:11:30 <srhb> Enzoray: Let's try again. elementAt 3 [1,2,3]. The n==0 clause is false, so the result is elementAt (3-1) [2,3]
08:11:40 <batchm> Enzoray (x:xs) in the argument position destructures a list. x is the first elmeent, xs are the remaining elements
08:11:44 <srhb> Enzoray: Note that we're doing the recursive call on xs, not on x:xs
08:11:50 <srhb> So we've "lost" the first element of the list already
08:12:10 <srhb> Erp, it should be 2, not 3
08:12:22 <batchm> so we are dropping the first element on every recursive call
08:12:39 <srhb> So, what is the result of elementAt (2-1) [2,3]? Well, again, the n==0 clause is false, so the result is the otherwise clause. elementAt (1-1) [3]
08:12:42 <batchm> and we keep doing that until n is 0
08:12:50 <Enzoray> Oh..
08:12:54 <srhb> Now, n == 0, so the first clause matches. The result is x, which is 3
08:12:57 <Enzoray> So it repeats until n == 0.
08:13:04 <Enzoray> ........ :|
08:13:08 <Enzoray> I think I get it now.
08:13:12 <srhb> Goodie. :)
08:13:14 <erisco>  \f (x:xs) -> let x : xs = x : xs in x : xs
08:13:19 <begriffs> Is there a service to build haskell binaries for multiple platforms?
08:13:37 <Cale> marcusbuffett: Did that work out for you? :)
08:13:39 * hackagebot mudbath 0.0.3 - Continuous deployment server for use with GitHub  http://hackage.haskell.org/package/mudbath-0.0.3 (wereHamster)
08:13:57 <erisco> I wonder what happens there
08:14:21 <Enzoray> if elementAt 2 [1,2,3].. Would give us first [2,3] n = 1, [3], n = 0.
08:14:24 <Enzoray> Or am I wrong?
08:14:48 <Cale> erisco: It's a constant function of two arguments, one of which must be a list, which produces the list _|_ : _|_ as its result.
08:14:53 <marcusbuffett> Cale: Yeah that was exactly what I was looking for, thank you!
08:15:17 <Cale> erisco: Oh, not quite, in the case that the second argument to the function is [], the result is _|_
08:15:18 <srhb> Enzoray: Yes, the first recursive call looks like elementAt (2-1) [2,3]
08:15:28 <srhb> Enzoray: And the second one: elementAt (1-1) [3]
08:15:34 <Enzoray> Yeah.
08:15:52 <erisco> Cale, for some reason I thought \f started a lambda
08:15:59 <Cale> No, it's just \
08:16:03 <batchm> Enzoray that is correct. and when n is 0 we break recursion and just return 3
08:16:07 <erisco> you know I know this
08:16:16 <Cale> okay :)
08:16:18 <Enzoray> Thanks a lot. :)
08:16:50 <Cale> erisco: But in any case, the definition made in the let shadows the parameter bound by the lambda
08:17:11 <Cale> erisco: and it's a cyclic definition
08:17:32 <Cale> > let x:xs = x:xs in x:xs
08:17:36 <lambdabot>  mueval-core: Time limit exceeded
08:17:53 <erisco> I guess we have to do \(x:xs) = let y : ys = x : xs in y : ys
08:18:06 <Cale> If you don't want an infinite loop, yes
08:18:40 <srhb> Enzoray: It might be helpful to rewrite the function with no guards and just pattern matching, and also a version using if then else
08:18:49 <srhb> Enzoray: To really solidify your intuition. :)
08:19:52 <erisco> @let myElemAt n = head . take n
08:19:54 <lambdabot>  Defined.
08:20:03 <erisco> maybe that is too boring
08:20:04 <srhb> erisco: drop?
08:20:04 <Cale> uhhh
08:20:12 <erisco> meh, drop, take
08:20:16 <erisco> depends on how I am feeling
08:20:21 <batchm> Enzoray try to write length function using recursion for practice.   mylength :: [a] -> Int
08:20:35 <Cale> > myElemAt 0 [1,2,3]
08:20:36 <lambdabot>  *Exception: Prelude.head: empty list
08:21:23 <erisco> okay wait, I got this
08:21:44 <clrnd> let's try scotty
08:21:53 <clrnd> okay be back in 5hs when cabal install finishes
08:22:03 <srhb> clrnd: You need more cpu. :-)
08:22:10 <clrnd> I know :(
08:22:22 <erisco> @let myElemAt2 n xs = head . take (length xs - n) . reverse $ xs
08:22:23 <lambdabot>  Defined.
08:22:28 <srhb> It's basicallt the only reason I'm packing a suitcase of a Thinkpad.
08:22:32 <erisco> > myElemAt2 0 [1,2,3]
08:22:34 <lambdabot>  3
08:22:39 <erisco> bug fixed clearly
08:22:55 <ij> I made a litle gl program that renders a square. What should I use to make a global variable for storing the rotation of the cube? I will want to mutate it.
08:23:22 <clrnd> ij, why not try an immutable approach?
08:23:41 <EvanR> or use a mutable local variable
08:24:01 <carter> clrnd: does your ~/.cabal/config file have a $ncpus line somewhere?
08:24:06 <Enzoray> Well, yeah. I might try that later, now I've got to focus on advancing through the 99 problems.
08:24:20 <clrnd> carter my pc is slow, it's using all the cores
08:24:30 <clrnd> I forgot to disable profiling iin the sandbox though
08:24:33 <clrnd> 'ouch
08:24:47 <ij> clrnd, the rendering function is a callback and it's not my main loop.
08:25:44 <batchm> what is the signature of the rendering function?
08:25:47 <clrnd> ij why not paste the code?
08:26:34 <ij> http://sprunge.us/DNbR
08:27:08 <erisco> Cale, any idea why the singletons package is called singletons?
08:27:40 <Enzoray> --problem4
08:27:40 <Enzoray> myLength :: [a] -> Int
08:27:40 <Enzoray> myLength a = length a
08:27:48 <Enzoray> Is this too.. clean?
08:27:52 <erisco> that is good problem solving son
08:27:52 <srhb> Enzoray: Cheating.
08:27:56 <srhb> Enzoray: You're reusing length. :P
08:27:59 <clrnd> Enzoray, master of problems bro
08:27:59 <batchm> Enzoray it is cheating
08:28:09 <clrnd> dont listen to them you know dog
08:28:13 <srhb> Enzoray: (ie. it's fine but it's taught you nothing)
08:28:15 <batchm> Enzoray myLength = length would work too (and would also be cheating :) )
08:28:33 <Enzoray> Well, I do get to "cheat" on my exam.. So does it matter? :P
08:28:43 <erisco> srhb, in the industry we call this code reuse
08:28:51 <erisco> in school we call it cheating
08:28:58 <Enzoray> Why would you write same thing twice?
08:29:01 <srhb> Enzoray: If I asked you to define length in an exam, I would be expecting you to actually not use the predefined length. :-)
08:29:07 <clrnd> Enzoray, well do you want to learn or finish?
08:29:11 <srhb> Enzoray: It's about showing understanding of how it works, obviously.
08:29:29 <hop_> Hello, what is the standard way in haskell to write a fallback (catch the rest of the cases) pattern?
08:29:30 <Enzoray> Both, mostly finish. I want to graduate as soon as possible.
08:29:34 <erisco> @let myLength2 = genericLength :: [a] -> Int
08:29:35 <lambdabot>  Defined.
08:29:41 <quchen2> I'm writing an FFI bining to a C lib that contains constant values. What's the appropriately marshalled type for them? In other words, what Foreign type corresponds to "const int"?
08:29:42 <srhb> hop_: in guards or in patterns?
08:29:49 <erisco> is that still cheating?
08:29:58 <batchm> I don't think teacher will give you points for reusing length
08:29:59 <srhb> erisco: It would be on my exams. :-)
08:30:08 <tdammers> case foo of { bar -> something; _ -> fallback }
08:30:31 <hop_> srhb: in guards sorry
08:30:46 <srhb> hop_: We generally use otherwise for that. | otherwise -> ...
08:30:53 <erisco> :t F.foldr
08:30:54 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:30:58 <Enzoray> Hey, it did solve the problem.. :D
08:30:59 <hop_> srbh. ok. Thanks!
08:32:00 <jtanguy> quchen2: you might want to take a look at the Pattern Synonyms extension https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html
08:32:06 <Enzoray> I guess you don't like my reverse-function either..
08:32:06 <Enzoray> myReverse :: [a] -> [a]
08:32:07 <Enzoray> myReverse a = reverse a
08:32:11 <srhb> Enzoray: No. :P
08:32:18 <ParahSailin> i might have expected the scoping rules for wheres and pattern guards to allow this: case () of {_ | Just j <- Just 1 -> derp where derp = j}
08:32:27 <Enzoray> Is there another way to reverse it?
08:32:34 <srhb> Enzoray: Yes. :)
08:32:40 <Enzoray> Hit me.
08:32:40 <quchen2> jtanguy: I don't think that will help my case.
08:32:43 <erisco> @let myLength3 = F.fold . fmap (Sum . const 1)
08:32:44 <lambdabot>  Defined.
08:32:48 <srhb> Enzoray: All these functions are not language primitives, you can actually write them yourself.
08:32:51 <erisco> srhb, how about that one
08:32:57 <erisco> :t myLength3
08:32:58 <lambdabot> (Foldable t, Num b, Functor t) => t a -> Sum b
08:33:00 <srhb> erisco: Acceptable.
08:33:19 <srhb> erisco: Though not full points.
08:33:29 <srhb> erisco: Thunk buildup. :)
08:33:52 <Enzoray> On the exam we get this sheet, filled with predefined functions.
08:33:53 <cinimod`> hello carter?
08:34:02 <Enzoray> I'm basically just using the functions that we are given.
08:34:03 <Enzoray> :P
08:34:12 <erisco> @let myLength4 = getSum . F.foldl' . fmap (Sum . const 1)
08:34:13 <srhb> Enzoray: You don't need any function to write length.
08:34:13 <lambdabot>  .L.hs:161:22:
08:34:13 <lambdabot>      Couldn't match type ‚Äòb -> t0 a0 -> b‚Äô with ‚ÄòSum c‚Äô
08:34:13 <lambdabot>      Expected type: (b -> a0 -> b) -> Sum c
08:34:26 <carter> cinimod`: yo
08:34:30 <carter> cinimod`: 1) what ghc version
08:34:31 <erisco> @let myLength4 = getSum . F.foldl' (mappend) mempty . fmap (Sum . const 1)
08:34:31 <tdammers> Enzoray: hint: reversing an empty list is trivial. reversing a one-element list is trivial. finishing the reversal when you have already reversed the list from the second element to the end isn't very hard either
08:34:32 <lambdabot>  Defined.
08:34:38 <erisco> :t myLength4
08:34:39 <lambdabot> (Foldable t, Num c, Functor t) => t a -> c
08:34:43 <carter> 2) cabal 1.19 isn't a released version,
08:34:47 <jtanguy> quchen2: why not ? what purpose does your c constants have?
08:34:48 <srhb> Enzoray: And I would expect you to be able to define it (on even the earliest exam in FP) by yourself. :)
08:34:49 <carter> cabal 1.20 is
08:34:52 <erisco> srhb, do I pass yet?
08:34:54 <srhb> Enzoray: I assume your exam does as well.
08:34:54 <carter> as are 1.18 and soon 1.22
08:35:01 <Enzoray> tdammers, so.. is this a recursive function you're talking about..? :P
08:35:09 <tdammers> Enzoray: yes
08:35:14 <Enzoray> srhb, I don't think so. :P
08:35:17 <carter> cinimod`: what ghc version were you testing? and what is the OS X version you were on?
08:35:20 <srhb> Enzoray: OK. :)
08:35:27 <tdammers> Enzoray: in the end, pretty much all list traversals boil down to recursion in Haskell
08:35:27 <Enzoray> Want a question from the exam?
08:35:29 <srhb> Enzoray: Doesn't sound like compsci.
08:35:34 <srhb> Enzoray: Sure.
08:35:36 <quchen2> jtanguy: It's a constant struct of some complicated thing.
08:35:46 <carter> cinimod`: and whats the output of ghc --info
08:35:47 <Enzoray> srhb.. the catch is that they are written BY HAND.
08:35:48 <quchen2> It's full of connection information and settings.
08:35:54 <srhb> Enzoray: Sure. :)
08:35:57 <carter> cinimod`: put these on a lpaste or github gist plz :)
08:36:00 <srhb> Enzoray: As in any good exam. :-)
08:36:06 <quchen2> I'm not sure whether I should just marshal it as if it wasn't "const".
08:36:30 <Enzoray> findIndex :: Eq a => a -> [a] -> Int
08:36:31 <Enzoray> that given an x and a list xs, finds out at what position x occurs in the list. We start counting positions at 0. If there are multiple positions, the function findIndex always returns the first position x is at.
08:36:40 <Enzoray> That is question 1.
08:36:46 <srhb> Enzoray: Yep. Definitely a recursion question.
08:36:56 <erisco> @let myLength5 = F.foldl' (+) 0
08:36:57 <lambdabot>  Defined.
08:37:00 <matematikaadit> :t findIndex
08:37:01 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
08:37:09 <erisco> :t myLength5
08:37:10 <lambdabot> (Foldable t, Num a) => t a -> a
08:37:12 <matematikaadit> from Data.List
08:37:28 <Enzoray> Looks quite advanced...
08:37:39 <cinimod`> carter: ~/Dropbox/Private/yarr/yarr $ ghc --version
08:37:40 <cinimod`> The Glorious Glasgow Haskell Compilation System, version 7.8.3
08:37:56 <SrPx> I'm kinda disappointed that I couldn't get better than 100x slower than arrays with pure structures. This will basically make me want to ignore pure structures completely, use mutable arrays everywhere and that kinda defeats the whole beauty of Haskell. How do you guys deal with that?
08:38:11 <batchm> > let length = sum . map (const 1) in length [1,2,3]
08:38:13 <lambdabot>  3
08:38:18 <srhb> Enzoray: Hint: findIndex y (x:xs) = if y == x then 0 else 1 + findIndex
08:38:20 <carter> SrPx: i suggests to me that your code wasn't paralle
08:38:22 <erisco> @let myLength6 = foldMap Sum
08:38:23 <lambdabot>  Defined.
08:38:25 <srhb> Well, that's not really a hint, it's a solution.
08:38:26 <cinimod`> carter: OSX 10.9.5
08:38:32 <srhb> ._.
08:38:37 <erisco> @let myLength7 = getSum . foldMap Sum
08:38:39 <lambdabot>  Defined.
08:38:41 <SrPx> carter: hmm.?
08:38:43 <erisco> :t myLength7
08:38:44 <lambdabot> (Foldable t, Num c) => t c -> c
08:38:52 <lrocksmashtime> i'm trying to build my newly created executable with cabal install -j and i keep getting a dist/dist-sanbox‚Ä¶/[name of executable]: does not exist. Anyone know what the deal is?
08:38:57 <erisco> probably thunks in foldMap
08:38:59 <matematikaadit> um... uh... TIL that GHC is "Glorious" Glasgow Haskell Compilation System
08:38:59 <srhb> Enzoray: Anyway, that's the style of the solutions you are expected to deliver. Not just importing the function from some library and non-solving them.
08:39:01 <carter> SrPx: synthetic benchmarks are boring :)
08:39:11 <carter> SrPx: i write really imperative codes
08:39:24 <erisco> nonetheless, Foldable module does not define a length function I think it ought to
08:39:25 <Enzoray> srhb, why are we giving a sheet which provides us with the predefined functions then?
08:39:29 <srhb> (There are in fact issues with my approach, but I would probably not expect you to know that in the very first course)
08:39:36 <srhb> Enzoray: Is findIndex there?
08:39:36 <carter> cinimod`: did you try updating your cabal?
08:39:40 <Enzoray> No.
08:39:45 <cinimod`> carter: I see I have ("Haskell CPP command","/usr/bin/gcc")
08:39:47 <srhb> Enzoray: There you have it.
08:39:56 <carter> cinimod`: ... thats actually clang
08:39:59 <cinimod`> carter: did you want the whole info
08:40:02 <Enzoray> Yeah, but.. yeah.. hmm.. :D
08:40:04 <carter> cinimod`: lpaste.net
08:40:05 <srhb> Enzoray: Anyway, why would you be trying to NOT learn from this course? :)
08:40:07 <carter> paste all the things
08:40:11 <cinimod`> carter: I know that now
08:40:13 <srhb> Enzoray: That's basically what you're doing with myLength = length
08:40:17 <SrPx> carter: synthetic benchmarks? Also, if you write really imperative codes what is the advantage of using Haskell at all?
08:40:23 <srhb> Enzoray: It's the very quick path to flunking.
08:40:26 <carter> SrPx: good generics
08:40:33 <cinimod`> carter: I could just change it but I will post the whole output
08:40:42 <SrPx> carter: I get it, it is a great imperative language too... so you just dismiss all the Functional stuff?
08:40:43 <carter> cinimod`: dont change it, you'll be doing it wrong
08:40:46 <carter> SrPx: no
08:40:51 <carter> SrPx: stop over simplifying
08:40:52 <Enzoray> srhb, I'm slightly behind. I just want to catch up and then.. "learn"
08:41:12 <srhb> Enzoray: You're going to be doing the opposite. Skipping the basics until it's all way too difficult to understand, imo.
08:41:17 <srhb> Enzoray: Always get the basics first.
08:41:21 <carter> SrPx: frankly, i interpret a lot of your efforts as "solutions in search of problems"
08:41:22 <carter> :)
08:41:40 <carter> and i mean that in the kindest way possible
08:41:47 <carter> cinimod`: you REALLY should update your cabal install
08:41:49 <Enzoray> srhb, the courses arn't that big. Next up is Java.
08:41:52 <carter> 1.19 was a dev version
08:41:54 <Enzoray> Or, atm. It's Java.
08:41:57 <cinimod`> carter: https://gist.github.com/idontgetoutmuch/2eb65f07c59ea378793b
08:41:59 <erisco> > (myLength7 (Just 5), myLength7 Nothing)
08:41:59 <carter> cinimod`: cabal update ; cabal install cabal-install
08:42:00 <lambdabot>  (5,0)
08:42:08 <srhb> Enzoray: Okay then. I'll butt out. I just disagree with your approach. :)
08:42:19 <erisco> yeah that is a boo boo
08:42:50 <erisco> @let myLength8 = getSum . foldMap (const (Sum 1))
08:42:50 <carter> cinimod`: if you install a real GCC,
08:42:51 <lambdabot>  Defined.
08:42:53 <carter> cinimod`: you could have
08:42:54 <carter>  ("Haskell CPP command","gcc-4.9"),
08:42:55 <carter>  ("Haskell CPP flags","-E -undef -traditional "),
08:42:59 <erisco> > (myLength8 (Just 5), myLength8 Nothing)
08:43:00 <carter> or something
08:43:00 <lambdabot>  (1,0)
08:43:07 <srhb> erisco: You can talk to lambdabot privately
08:43:26 <carter> cinimod`: honestly, most active haskell projects now just try to use CPP in a way that works with both clang and gcc
08:43:40 * hackagebot clanki 1.0.7 - Command-line spaced-repetition software  http://hackage.haskell.org/package/clanki-1.0.7 (marcusbuffett)
08:43:42 <SrPx_> carter: (lost connection) > carter: I don't understand what you mean but it is just that everytime I try Haskell I get ridiculously less performant code than my JavaScript counterparts and I'm trying to find a way around that because I enjoy Haskell better
08:43:51 <SrPx_> but what did you try to say?
08:44:03 <carter> SrPx_: ummm youre not asking about native code haskel?
08:44:04 <erisco> you know the predefined foldable instances are not that interesting =\
08:44:14 <SrPx_> carter: huh?
08:44:14 <carter> SrPx_: may i suggest an alternative behavior for you?
08:44:20 <SrPx_> of course, go on
08:44:25 <Enzoray> Great, question 6 is impossible to solve.
08:44:48 <carter> SrPx_: when you're stumped about peformance, share a SMALL example haskell and js programs both, and ask for help / ideas making the hs one more performant
08:44:53 <zwer> SrPx are you compiling, and with what flags?
08:44:58 <carter> SrPx: saying  "X is slow" isn't actionable
08:45:02 <srhb> Enzoray: That seems unlikely.
08:45:07 <carter> saying "heres a program, i'm not happy with its perf"
08:45:12 <carter> "could you please help me"
08:45:13 <carter> IS
08:45:22 <Enzoray> srhb, want to see it? I mean.. wt.. What is this?
08:45:29 <srhb> Enzoray: Sure.
08:45:32 <carter> SrPx_: one makes you seem like youre trying to get attenion, the other is asking for help because youre stumped
08:45:49 <Enzoray> *) Find out whether a list is a palindrome. A palindrome can be read forward or backward; e.g. (x a m a x).
08:45:51 <Enzoray> Example in Haskell:
08:45:53 <Enzoray> *Main> isPalindrome [1,2,3]
08:45:54 <Enzoray> False
08:45:55 <Enzoray> *Main> isPalindrome "madamimadam"
08:45:56 <Enzoray> True
08:45:57 <Enzoray> *Main> isPalindrome [1,2,4,8,16,8,4,2,1]
08:45:58 <Enzoray> True
08:45:59 <srhb> Enzoray: Use your definition of reverse, and then equality
08:46:05 <SrPx_> carter: I'm not sure, you are talking about the program I just posted!?
08:46:13 <carter> idkd, i dont see a program
08:46:32 <Enzoray> srhb, you seem to have a solution to everything.. don't you? -- :P
08:46:46 <SrPx_> carter: http://lpaste.net/117105 that is what I posted, I thought it was pretty small and isolated?
08:46:52 <srhb> Enzoray: Well, if you know what a palindrome is and you've defined myReverse (and you have equality on lists) the solution is trivial. :-)
08:46:54 <carter> SrPx_: idk, iddint see it
08:47:00 <SrPx_> ah okay...
08:47:00 <Enzoray> So.. if reverse list == normal list = True?
08:47:16 <srhb> Enzoray: Well, that's even more effort than you need.
08:47:17 <batchm> what made you think this is impossible to solve?
08:47:27 <srhb> Enzoray: if foo then True else False -- is always the same as foo
08:47:33 <carter> SrPx_: also ... have you considered mutable vectors in the ST monad?
08:47:49 <SrPx_> I even made it so all you need to do is run it and it shows you the benchmark... not sure how I could make it easier for people trying to help, please let me know if you know...
08:47:50 <carter> SrPx_: sequence and list aren't good for random axes
08:47:54 <endiruna> what is the difference between the Data.List module functions and the ones that are already present in ghc. in a simple source code i have included nothing and I can use filter but if i understand it correctly there is a function in Data.List named filter
08:48:08 <carter> SrPx_: 'but your problem is you don tunderstand algorithm complexity
08:48:13 <srhb> endiruna: I think you mean Prelude, not GHC?
08:48:18 <geekosaur> endiruna: the most commonly used Data.List functions are implicitly imported via the Prelude
08:48:24 <benzrf> endiruna: by "already present in ghc" i think you mean "already in the Prelude"
08:48:30 <carter> SrPx_: pick the data structures that give the right complexity
08:48:33 <batchm> endiruna they are the same functions
08:48:44 <carter> SrPx_: in this case, if you want to treat it as pure, use MVectors in the ST monad
08:48:55 <srhb> endiruna: The module Prelude which is the one that gets loaded automatically, imports Data.List and then exports filter from there.
08:48:57 <carter> if you care about random access
08:49:42 <carter> cinimod`: i actually have my OS X ghc setup to use clang for c code, and gcc for CPP
08:49:51 <carter> cinimod`: idk if my suggestions are helping :)
08:50:03 <SrPx_> carter: huh? Are you offended by anything I said? It is not true that I don't understand algorithm complexity. I don't know what it means to "use MVectors in the ST Monad" to "treat it as pure" but I will study this possibility, thank you.
08:50:28 <endiruna> thanks! i see.  for me included in ghc means the ones i do not have to load manually. did not know that prelude was a module which is automatically included. that explains why ghci has Prelude written
08:50:44 <endiruna> :D
08:50:48 <srhb> endiruna: Indeed. You can look up the source of Prelude to see where the functions come from. :)
08:50:55 <carter> random access on lists will be linear time, random access on sequence will be log time, random access on arrays/vectors will be constant time
08:51:04 <Enzoray> isPalindrome :: [a] -> Bool
08:51:04 <Enzoray> isPalindrome a 	
08:51:04 <Enzoray> 		| a == (reverse a) = True
08:51:04 <Enzoray> 		| otherwise = False
08:51:22 <Enzoray> Didn't work, do I have to reverse them one by one or what?.. :S
08:51:50 <srhb> Enzoray: That should work.
08:52:02 <srhb> Enzoray: Though it's a lot more effort than you need to do.
08:52:36 <Enzoray> It told me to add Eq A
08:52:40 <Enzoray> Now it's compiling.
08:52:40 <srhb> Oh yeah
08:52:43 <srhb> Sorry
08:52:45 <Enzoray> What does Eq a do?
08:52:49 <Enzoray> I never understod that.
08:52:50 <srhb> It implements ==
08:53:16 <srhb> If the elements of the list do not have equality defined, then neither can lists consisting of those elements.
08:53:18 <SrPx_> carter: yes so? I've been talking about that all the time and how I was looking for a purely functional structure that had log(N) write and low constant factor since that is, I guess, the best you can do without mutability.
08:53:40 <Enzoray> srhb, demonstate please. In a example
08:53:42 <carter> SrPx_: use intmap
08:53:43 <srhb> Enzoray: The equivalent definition is this: isPalindrome xs = reverse xs == xs
08:53:47 <SrPx_> carter: the problem is that the constant factor of, say, Seq is too high so you get a 500x slowdown instead of a ~16x slowdown for a 65536 sized structure
08:53:49 <carter> or unordred containers intmpa
08:53:59 <srhb> Enzoray: Well, you just can't use == if the types you try to use it on don't have it defined.
08:54:01 <carter> SrPx_:  have you looked at intmpa?
08:54:11 <carter> SrPx_: or the one in unordered containers
08:54:26 <SrPx_> yes it is actually on the benchmark I just provided... it preformed 100x worse than mutable vectors
08:54:37 <carter> well yeah
08:54:43 <srhb> Enzoray: data MyList a = Nil | Cons a (MyList a) -- if I don't derive or define an instance of Eq, I cannot compare values of type MyList a
08:54:47 <carter> SrPx_: whats wrong with mutable arrays?
08:54:53 <carter> theres no deep existential problem here
08:54:56 <carter> just use them
08:55:09 <Enzoray> srhb, btw. I have not really learned what you just typed.. data RandomThings
08:55:18 <srhb> Enzoray: Indeed. Read LYAH. :)
08:55:24 <Enzoray> Yeah.
08:55:26 <SrPx_> nothing wrong, as I said, I personally don't know how I can "treat them as pure values using the ST monad" and am going to study your suggestion
08:55:45 <Enzoray> I have done that. I should check up that part more.
08:55:57 <srhb> Then you certainly have learned about defining data types.
08:56:07 <carter> SrPx_: you'll like the ST monad
08:56:10 <Enzoray> yeah, I really need to practice on that I guess.
08:56:37 <srhb> Enzoray: Chapter 8. :)
08:56:39 <cinimod`> carter: ok I give up - where does ghc get --info from?
08:56:44 <Enzoray> Thanks.
08:56:48 <carter> cinimod`: oh, the settings file
08:56:58 <Enzoray> Wait a minute, problem 8 is about data etc. Should I skip it for now? :S
08:57:10 <carter> cinimod`: its located at /usr/local/lib/ghc-7.8.3/settings usually
08:57:14 <SrPx_> my code is using it for the mutable vector benchmark, I'm just not sure I understand very well how it can be used in practice. Do you mean that, for example, if I am working with ndarrays and I have a "draw_circle" function, I first get a normal vector, convert it to a mutable vector, update the right pixels imperatively and freeze it back?
08:57:19 <srhb> Enzoray: You should read the book, then do the exercises later, if you ask me.
08:57:30 <Enzoray> srhb, I'm running a bit short on time.
08:57:31 <srhb> Enzoray: As far as I can tell you're not equipped to solve the problems yet. No offense intended. :)
08:57:34 <Enzoray> Exam is soon. :P
08:57:47 <carter> SrPx_: if you want help with game engineering ask on #haskell-game
08:57:48 <Enzoray> srhb, haha. I guess so. :P
08:58:07 <carter> SrPx_: if you want help with browser dev, abuse luite's patience on #ghcjs :)
08:58:21 <Enzoray> The exam is in less than two weeks, 1 w d 5
08:58:39 <srhb> Enzoray: You can read the relevant chapters in LYAH and solve the questions before that.
08:58:41 <carter> SrPx_: i'm not sure what your goal is, so i cant give you end to end soltions
08:58:46 <srhb> Enzoray: Read chapter 8, come back and do questions 7 and 8
08:58:47 <Enzoray> Hmm, I guess so.
08:58:56 <carter> cinimod`: unless your  using ghcforosx, in which case it'd be in the .App folder
08:58:59 <srhb> Enzoray: It's definitely doable. :)
08:59:10 <srhb> Enzoray: You just have to cram hard. :-)
08:59:16 <Enzoray> I havn't told you the catch, there are two exams. :P
08:59:35 <srhb> Enzoray: You're in #haskell, so the advice will be to prioritize the Haskell exam and screw the other one. :-)
08:59:49 <srhb> Go to #foo for the opposite advice.
09:00:02 <Enzoray> Haha, I can't really. The other one is a math exam. :P
09:00:09 <Enzoray> I've head it's quite simple, but still.
09:00:19 <SrPx_> carter: I'm just trying to learn what structures I should use and when. For example, I'd implement a game using IntMap to represent images/the screen. I'm afraid that would be slow. That is the core of the issue. I know how to use Haskell and how to write code, I just don't know what is the right structures to use for each situation, when it is okay to use pure structures and when you have to appeal to mutable, unboxed, etc.
09:00:30 <SrPx_> I'm slowly progressing, though, those benchmarks help a lot in getting a bigger picture
09:00:37 <srhb> Enzoray: Well, I'm not your student counsellor. :) I can tell you how to get ready for the Haskell exam, the rest is up to you.
09:00:43 <carter> SrPx_: how about you first write the game
09:00:44 <carter> then fix it
09:00:56 <carter> haskell is good for refactoring
09:01:19 <Enzoray> Well, my thanks to you. :P
09:01:41 <srhb> Enzoray: Sorry, I don't mean to sound cold, but I don't know what else I can do but give you what I feel is the best advice with regards to Haskell. :)
09:01:49 <srhb> Enzoray: I wish you the best of luck of course!
09:02:21 <Enzoray> srhb, I know. I just hope I manage to pass them both in some magical way. :S
09:02:28 <srhb> I hope you do. :)
09:02:42 <srhb> (Less time agonizing over it, more time doing the LYAH and exercises!) :-)
09:02:53 <SrPx_> is it, though? Even in C++ you can replace every use of a particular data structure across your entire codebase by rewriting a single #define. In Haskell I'm aware most of the time you find yourself having to change a structure for another you have to update the code everywhere it is used...
09:03:15 <srhb> SrPx_: Right, but in Haskell you catch more unintended changes of behaviours in the types.
09:03:17 <carter> SrPx_: i'm just hearing excused :)
09:03:17 <Enzoray> I guess so. Thanks for the help. :)
09:03:22 <carter> write the game
09:03:24 <carter> then fix it
09:03:38 <carter> SrPx_: is the goal game writing or micro optimizatin?
09:04:15 <SrPx_> micro optimization is actually the complete opposite of choosing the right data-structures for your program...
09:04:36 <carter> exactly
09:04:39 <carter> thats what youre doing though
09:04:41 <carter> :)
09:04:51 <carter> first just write something
09:05:05 <carter> if the game is fast, but boring, does it matter?
09:07:27 <SrPx_> well, fair enough
09:07:40 <SrPx_> I'll accept that as a challenge
09:07:56 <mewab> I have a question about generating tags file for Haskell!
09:08:08 <mewab> Out of all the options: GHC, hasktags, nothasktags, fasttags
09:08:20 <mewab> so many options yet, I'm not sure which one is the most reliable
09:08:28 <SrPx_> I'm going to code whatever stupid game I can think of using what is most convenient for coding performance and will not care a single bit about performance
09:08:30 <mewab> I'd like to generate tags for a project, not for a single file like lushtags
09:08:49 <carter> SrPx_: if you have a cool game, but its a teeny bit slow/has pauses, thats a fun and concrete challenge to learn how to optimize
09:08:52 <SrPx_> lets see how easy it will be to save the probably innefficient outcome
09:09:03 <carter> SrPx_: i suspect that perf problems will also be slightly different from what you expect
09:09:05 <carter> yes!
09:09:14 <carter> SrPx_: also its easier to optimize an overall program than a micro benchmark
09:09:17 <carter> and harder too
09:10:10 <SrPx_> Just before I begin, can you guys suggest a library to render a array (or something) to the screen, a library to get keyboard inputs and a way to create an intervaled thread? (the main loop)
09:10:32 <EvanR> glfw-b
09:10:45 <carter> yeah, thats probably a good call
09:10:46 <cinimod`> carter: , ("Haskell CPP flags", "-E -undef -traditional -Wno-invalid-pp-token -Wno-unicode -Wno-trigraphs")
09:10:50 <carter> cinimod`: yup
09:10:52 <cinimod`> bother
09:10:57 <carter> cinimod`: thats clang
09:11:03 <cinimod`> most active haskell projects now just try to use
09:11:03 <cinimod`> 	 CPP in a way that works with both clang and gcc
09:11:03 <carter> cinimod`: do you have mac brew installed?
09:11:14 <carter> :)
09:11:20 <cinimod`> I inherited this package
09:11:26 <carter> hehe
09:11:28 <cinimod`> I didn't think so
09:11:33 <carter> ok
09:11:45 <carter> cinimod`: how many actie users does Yarr have?
09:11:48 <cinimod`> brew says no
09:11:53 <carter> brew says no what
09:11:54 <cinimod`> Probably 1
09:11:57 <cinimod`> Me
09:11:58 <carter> ok
09:12:09 <cinimod`> But it is faster than repa
09:12:20 <carter> oh?
09:12:23 <carter> how much faster?
09:12:25 <carter> wonder why
09:12:28 <carter> for what workload?
09:12:30 <cinimod`> Also repa is not particularly well maintained
09:12:56 <carter> cinimod`: hehe
09:13:05 <carter> cinimod`: and sadly i'm not doing anything for fusion :)
09:13:15 <carter> cinimod`: i've been pushing runnable array instances a wee bit
09:13:21 <zipper> Sitting looking at my code and wishing I could be updating global values and such things sometimes lol I'm like the dog that's begging for chocolate. Will post problematic code in a few.
09:13:27 <carter> i may be missing XMas release date
09:13:36 <carter> zipper: StateT monad
09:13:41 * hackagebot rdf4h 1.3.0 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.3.0 (RobStewart)
09:13:43 <lispy> zipper: That's a really good analogy
09:13:43 <carter> or unsafePeformIO on gloabl iorref
09:13:50 <lispy> zipper: I might have to steal that :)
09:13:57 <carter> lispy: OMG youre online
09:13:59 <carter> how're you doing?
09:14:09 <lispy> I'm okay. You?
09:14:15 <cinimod`> carter: 18 seconds for repa and 0.5 for yarr
09:14:16 <zipper> lispy: Please do. I stole it from a tweet about life and why we sometimes don't get things we want so bad.
09:14:37 * mmmm is rebuilding a sandbox which has lens in
09:14:45 <cinimod`> carter just to check I have made 2 changes to my settings file
09:14:54 <zipper> carter: I'm not familiar with it yet so I won't use it. I can do this without state. Also monad transformers are killing me right now.
09:14:57 <mewab> Can anyone help me with knowing what is a good haskell tags generation solution?
09:15:06 <mewab> Out of all the options: GHC, hasktags, nothasktags, fasttags
09:15:28 <carter> cinimod`: ummmmmmm
09:15:32 <carter> cinimod`: ...... what changes
09:15:57 <carter> cinimod`: if you dont have REAL GCC installed, those changes will break shit
09:16:17 <lispy> mewab: I haven't used many of those, but if GHC can generate the tags then it probably does the best job because it groks the most?
09:16:38 <EvanR> so types should not be considered sets, i heard
09:16:38 <lispy> mewab: You might look at ghc-mod instead of tags.
09:16:49 <mewab> I also thought like you lispy, however GHC does not specialise in creating tags
09:17:03 <mewab> And if GHC did such a good job, why those other solutions have to exist in the first place?
09:17:09 <EvanR> newtype U = In ((U -> Bool) -> Bool)
09:17:15 <mewab> ghc-mod can create tags?
09:17:27 <lispy> mewab: probably not, I mean use ghc-mod instead of tags.
09:18:04 <lispy> "The ghc-mod command and ghc-modi command are backend commands to enrich Haskell programming on editors including Emacs, Vim, and Sublime. "
09:18:26 <mewab> Oh, you mean try using ghc-mod as a way to hop from a function to it's definition?
09:18:31 <mewab> I'll have to look at that option
09:18:33 <lispy> yeah
09:18:48 <lispy> http://www.mew.org/~kazu/proj/ghc-mod/en/
09:18:54 <cinimod`> carter: i have gcc-4.9.1 installed
09:18:57 <carter> ok
09:18:59 <carter> cinimod`: sweet
09:19:08 <cinimod`> Now I get further
09:19:29 <carter> cinimod`: you probably want to make sure the C compiler line is still real clang though
09:19:30 <cinimod`> Weirdly I now get type errors
09:19:40 <lispy> ?remember zipper Sitting looking at my code and wishing I could be updating global values and such things sometimes lol I'm like the dog that's begging for chocolate. Will post problematic code in a few.
09:19:40 <lambdabot> I will never forget.
09:19:40 <carter> oh?
09:19:49 <lispy> ?quote zipper
09:19:50 <lambdabot> zipper says: Sitting looking at my code and wishing I could be updating global values and such things sometimes lol I'm like the dog that's begging for chocolate. Will post problematic code in a few.
09:20:01 <mewab> I already have installed ghc-mod but from what I know I can only use it to check the types of stuff
09:20:09 <zipper> lispy: :)
09:20:26 <cinimod`> carter: I have clang as my gcc
09:20:30 <carter> yes
09:20:31 <carter> good
09:20:35 <cinimod`> Anyhow that is not the problem
09:20:45 <carter> cinimod`: yarr bitrotting is?
09:20:46 <cinimod`> But this code has not been touched for 2 years
09:20:48 <carter> :)
09:21:29 <cinimod`> I think it is worth rescuing
09:21:44 <lispy> mewab: If you do the hoogle dance correctly you might be able to use the ghc-mod hoogle support to go to functions
09:22:02 <lispy> mewab: I'm speculating here. I don't use ghc-mod.
09:22:15 <lispy> (I've been meaning to try it though, it looks splendid)
09:22:34 <dfeuer> Is anyone going to try to rescue Hugs?
09:22:39 <dfeuer> Or NHC98?
09:23:00 <mewab> lispy I want to hop to function definitions in my own project as well
09:23:09 <mewab> not just to see them but to modify them if neccessary as well
09:23:23 <cinimod`> dfeuer: do you have your tongue in your cheek?
09:23:29 <zipper> Ok how can I get a value out of IO without print? Like a function with signature f :: IO <record value> -> <record value>
09:23:42 * hackagebot intern 0.9.1.4 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.9.1.4 (EdwardKmett)
09:23:46 <dfeuer> cinimod`, no, I just don't know the history behind why those projects were abandoned.
09:24:08 <amanforindia> hey... i've been reading learn you a haskell for learning functional programming... now i want to learn more about implementing imperative data structures/algorithms in the functional way... any recommendations?
09:24:21 <josephle> okazaki's purely functional data structures
09:24:34 <kadoban> That ^
09:24:37 <carter> SrPx_: i'm very excited now :)
09:24:58 <dfeuer> *Okasaki
09:25:12 <amanforindia> ahh thanks!
09:25:18 <dfeuer> What are you excited about, carter?
09:25:18 <lispy> mewab: I'm kind of surprised that's not part of ghc-mod. I wonder if it would be hard to add.
09:25:19 <amanforindia> i'll get into it right away!
09:28:13 <cinimod`> dfeuer: I think after Mark Jones decided he didn't want to maintain hugs anymore and ghci was invented then there wasn't much incentive to use it and there was no-one really committed to maintaining it
09:28:16 <zipper> With `data ArmyCounts = ArmyCounts { attackers :: Int, defenders :: Int }` How can I write f :: IO ArmyCount -> ArmyCount
09:28:16 <zipper> :src print
09:28:42 <lispy> mewab: I know it's not ideal, but `grep -wR foo` is surprisingly efficient
09:28:55 <cinimod`> dfeuer: I think about 2000 - I recall Malcolm demoing ghci
09:28:56 <lispy> (if you need a stopgap thing)
09:29:21 <chrisdone> a digraph of "social" activity jan 2013-today in #haskell http://chrisdone.com/haskell-digraph-2013.png
09:29:27 <chrisdone> i.e. who talked to who the most
09:29:31 <mutantmell> Is there a list of the features added for ghc 7.10?
09:29:33 <indiagreen> zipper: you can't
09:29:53 <cinimod`> carter: for extra amusement, I agree with ghc's type errors for code that once compiled
09:30:00 <carter> cinimod`: yay
09:30:01 <zipper> indiagreen: Then I'm dead
09:30:03 * cinimod` scratches head
09:30:06 <carter> cinimod`: see why IRC was easier?
09:30:22 <dfeuer> cinimod`, and what about NHC98?
09:30:35 <cinimod`> carter: I am very grateful to you
09:30:36 <hop_> For a Data.Array, is there any other way to test if it is empty other than fst a <= snd a???
09:30:57 <cinimod`> dfeuer: dunno - I never used it
09:30:58 <indiagreen> I wonder whether suggesting using unsafePerformIO is acceptable when the other alternative is death
09:31:15 <dfeuer> hop_, yes, that's the wrong way altogether.
09:31:21 <geekosaur> all programs start out in IO, so there is always a way
09:31:25 <mmachenry> I must be blind. If ds :: [Int] why is x::[Int] ? http://lpaste.net/117112
09:31:28 <dfeuer> hop_, there's some kind of rangeSize thing or somehing.
09:31:40 <geekosaur> the question is usually whether you're willing to let go of incorrect assumptions
09:31:45 <dfeuer> hop_, you get the array bounds and ask for their range size.
09:31:46 <zipper> indiagreen: Do you have time? I can show you my code.
09:31:49 <jdiez> I'm writing my first "real" haskell project, an IRC bot (of course!). I'm worried because most of its code lives in my Bot monad, which is a ReaderT with an underlying IO monad. therefore I'm not sure how to test my code
09:31:50 <hop_> dfeuer: i am looking at the doc, not able to find anything :-(
09:31:51 <jdiez> example: https://github.com/jdiez17/HaskellHawk/blob/master/Net.hs#L33
09:31:55 <geekosaur> or will let them drag you down into the depths
09:31:56 <cinimod`> did I# change its type recently?
09:32:16 <jdiez> see, stuff eventually calls `write`, and I'm not sure how to test that.
09:32:22 <indiagreen> zipper: yep, or paste it on lpaste since I'm not the only one with free time on my hands
09:32:26 <dfeuer> hop_, look at the Data.Ix doc.
09:32:27 <jdiez> maybe monkey patching write? something else? I don't know
09:32:34 <dfeuer> :t getBounds
09:32:35 <lambdabot> Not in scope: ‚ÄògetBounds‚Äô
09:33:03 <lispy> jdiez: One thing you can do is supply a different "IO" monad for testing.
09:33:08 <hop_> dfeuer: Ah yes! Thanks!
09:33:26 <lispy> jdiez: Are you familiar with mock objects for testing?
09:33:34 <jdiez> lispy: yep, I'm familiar with that
09:33:40 <jdiez> lispy: but I'm not sure how I'd mock IO
09:34:29 <lispy> jdiez: There is a library for this but I'm failing to remember the name
09:34:42 <HeladoDeBrownie> chrisdone did it, think it's called pure-io
09:34:59 <HeladoDeBrownie> @hackage pure-io
09:34:59 <lambdabot> http://hackage.haskell.org/package/pure-io
09:35:11 <HeladoDeBrownie> Hmm, maybe not quite what you had in mind
09:35:18 <jdiez> looks like that only mocks stdin and stdout
09:35:30 <EvanR> what happens when you do forkIO in pure-io ;)
09:35:39 <jdiez> in my case I'm writing to a Handle created by Network.connectTo
09:35:57 <lispy> jdiez: There are several ways to approach this. One way would be to use a free monad so that your testing "IO" would be an interpreter that can mock real IO
09:36:01 <mmmm> jdiez: .. one option is to use a free monad but that's quite heavyweight
09:36:07 <HeladoDeBrownie> I don't think it implements that operation. I think its purpose was to provide basics for a website REPL
09:36:09 <hop_> dfeuer: is rangeSize $ bounds array more correct?
09:36:25 <lispy> jdiez: another approach is to use module imports. When building for testing you get the stubs. Otherwise you get the real IO
09:36:25 <HeladoDeBrownie> Heh, I wouldn't have thought of free monads as heavyweight
09:36:46 <mmmm> jdiez: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
09:36:53 <hop_> dfeuer: (rangeSize $ bounds array) > 0, I mean
09:36:59 <dfeuer> hop_, yes, I believe that is *the* correct way. Checking if the bottom is smaller than the top can give wrong answers; don't remember why.
09:37:03 <jdiez> lispy: modifying the code to make it more suitable for testing sounds wrong to me, just like mock objects sound wrong to me
09:37:14 <hop_> dfeuer: thanks!
09:37:15 <dfeuer> hop_, oh, there might be a special thing to
09:37:18 <dfeuer> check for empty
09:37:20 <dfeuer> not sure.
09:37:36 <jdiez> mmmm: I've seen that post, and it looks like the right direction
09:37:38 <dfeuer> hop_, in base 4.8, you will be able to just use Data.Foldable.null
09:37:45 <zipper> indiagreen: Is that too much code? You only have to read from line 66 http://lpaste.net/117114
09:37:51 <hop_> dfeuer: or any pattern like for lists?
09:37:53 <lispy> jdiez: Well if you don't want to go that route then I think you're stuck with functional tests.
09:38:10 <dfeuer> hop_, not without some sort of weird extension.
09:38:13 <zipper> indiagreen: It's from exercise 4 here http://www.seas.upenn.edu/~cis194/hw/08-monads.pdf
09:38:35 <lispy> jdiez: eg., testing the whole thing from the outside. Like running a program on specific inputs and checking the outputs. Instead of testing sub parts of the program.
09:38:38 <zipper> indiagreen: brb
09:38:40 <hop_> dfeuer: Maybe I should use the list version of PCRE instead of array actually. Maybe more idiomatic
09:38:50 <cinimod`> https://hackage.haskell.org/package/MonadPrompt
09:38:56 <lispy> jdiez: The last option is probably using HUnit or the monadic portions of quickcheck
09:39:03 <quchen> Hmm, the 7.10 user's guide still isn't up to date (full of TODOs). Is there a version with the 7.10 changes available somewhere?
09:39:09 <dfeuer> hop_, PCRE?
09:39:09 <cinimod`> jdiez: I believe the above is what you want
09:39:09 <jdiez> lispy: yeah, sounds like I'll have to stick to testing small parts of it and hope the IO stuff works
09:39:28 <jdiez> cinimod`: taking a look
09:39:36 <cinimod`> Never tried it myself
09:39:47 <jdiez> unless I'm misunderstanding what it does, it isn't
09:40:00 <mewab> Anyone can help me figure out why syntastic with hdevtools to show errors does not work for a cabal project?
09:40:01 <lispy> jdiez: For most Haskell programs you can separate the IO from the computation to the point that the IO stuff is just a call to read/write that passes on whatever it got.
09:40:10 <lispy> jdiez: and that may well be enough for you
09:40:20 <hop_> dfeuer: Text.Regex.PCRE match overload with lists (I think there is one)
09:40:26 <jdiez> lispy: take a look at this: https://github.com/jdiez17/HaskellHawk/blob/master/IRC/Commands.hs#L10
09:40:33 <jdiez> lispy: I'd like to write a quickCheck prop like
09:40:51 <jdiez> privmsg (arbitrary) (arbitrary) == write "PRIVMSG " (bla bla)
09:40:55 <jdiez> symbolically, perhaps
09:41:28 <cinimod`> jdiez: I thought you wanted to test your app even though it is in a monad
09:42:40 <jdiez> ideally, what I'd want to do, is symbolically test the actions in the Bot monad
09:42:41 * HeladoDeBrownie hears their "monad" word overuse alarm ding softly.
09:43:18 <carter> i like applicatives
09:43:43 * hackagebot bank-holidays-england 0.1.0.0 - Algorithm for calculating bank holidays in England and Wales  http://hackage.haskell.org/package/bank-holidays-england-0.1.0.0 (dcturner)
09:44:11 <mewab> For exception handling the IO monad, should I use Control.Exception's mechanism or use IO's MonadError instance?
09:44:31 <mewab> It looks like the Control.Exception mechanism is more rich, but it's less uniform if I don't use the ErrorMonad instance
09:48:23 <dredozubov> how to make cabal give warnings for the whole project during 'cabal build'? it builds only changed files by default
09:48:27 <quchen> mewab: IO's ErrorMonad instance calls Control.Exception.{catch,ioError}
09:49:25 <mewab> quchen: but from what I understand, with ErrorMonad you specify an Exception instance
09:49:40 <mewab> and then you have to create exception's of that instance. And catch them
09:49:47 <dredozubov> maybe i should use ghc-mod without cabal :\
09:50:11 <mewab> but with Control.Exception's mechanism you can try to catch a certain type of Exception and have it propagate if it's not the type you were trying to catch
09:50:32 <mewab> Is it the same with ErrorMonad? Or there's no propgation in the same manner?
09:51:22 <quchen> dredozubov: cabal clean?
09:52:10 <dredozubov> quchen: i've decided that something like 'ghc-mod check -g -Wall src/Main.hs' will work even better
09:52:18 <quchen> mewab: Control.Exception is fine. You need MonadError only if you want your functions to be polymorphic over some throwing monad.
09:52:28 <dredozubov> it won't compile it after all
09:53:19 <lispy> jdiez: sorry, got distracted (at work)
09:53:28 <jdiez> don't worry, it's not that important :)
09:53:29 <mewab> quchen: what if I want exception mechanism in the same vein but not in IO? Isn't that a reason to use some MonadError instance as well?
09:54:03 <lispy> jdiez: I think what you're describing with the symbolic testing would require a free monad to do well (or a very similar trick, I think edwardk has some lighter weight alternatives)
09:54:57 <jdiez> @pl respond m r = asks config >>= \cfg -> uncurry privmsg $ respond' cfg m r
09:54:57 <lambdabot> respond = (((asks config >>=) . (uncurry privmsg .)) .) . flip . flip respond'
09:55:02 <jdiez> heh
09:55:02 <lispy> jdiez: The core of the problem is that IO is the "misc" bucket and you're appealing to IO. So to make this work you need to either swap it out or give things finer granularity.
09:55:14 <quchen> mewab: In that case I guess you'd have to newtype IO and write a new MonadError instance
09:55:25 <jdiez> lispy: yeah, I'm refactoring the code to split the IO and pure functions
09:55:39 <cinimod`> carter: (<=#) used to be (<=#) :: Int# -> Int# -> Bool
09:55:46 <carter> oh yeah
09:55:48 <mewab> quchen: is newtyping IO an option if I want a pure monad?
09:55:48 <carter> :)
09:55:57 <cinimod`> carter: now it is (<=#) :: Int# -> Int# -> Int#
09:56:03 <jdiez> lispy: https://github.com/jdiez17/HaskellHawk/blob/master/IRC/Commands.hs#L13-L27 vs https://gist.github.com/jdiez17/fbda3c09cf1bdd9ad3b0
09:56:11 <carter> cinimod`: yup
09:56:12 <cinimod`> Why oh why
09:56:13 <carter> it is known
09:56:18 <carter> cinimod`: branchless ANDS and ORS
09:56:20 <jdiez> lispy: is that an improvement? I think so
09:56:25 <quchen> mewab: You can also write your own type that instantiates MonadError of course
09:56:44 <lispy> jdiez: Yeah, I think that will make testing easier.
09:56:47 <cinimod`> carter: I don't know what a branchless and is
09:56:58 <lispy> jdiez: You might  want a custom type instead of (String, String)
09:56:59 <carter> cinimod`: cpus have jumps and branches and ifs
09:57:00 <carter> right?
09:57:15 <carter> and-ing two Ints bitwise doesn't rquire a cpu branch
09:57:22 <jdiez> lispy: don't really use this more than once, but yeah
09:57:53 <lispy> Ah yeah, in that case maybe it's a waste
09:58:12 <mewab> quchen: so can I use the MonadError instance of IO and it will be the same as using the Control.Exception's mechanism? Just to make sure I understood you correctly, if so that makes me happy!
09:58:13 <jdiez> @pl respond m r = asks config >>= \cfg -> uncurry privmsg $ respond' m r cfg
09:58:13 <lambdabot> respond = (((asks config >>=) . (uncurry privmsg .)) .) . respond'
09:58:43 * hackagebot bank-holidays-england 0.1.0.1 - Calculation of bank holidays in England and Wales, including special cases 1995-2014.  http://hackage.haskell.org/package/bank-holidays-england-0.1.0.1 (dcturner)
09:58:50 <cinimod`> carter: I can see why you might want to and two words
09:58:50 <carter> cinimod`: heres how i patched arithmoi a while back
09:58:51 <carter> https://bitbucket.org/dafis/arithmoi/pull-request/1/somewhat-untested-cpp-and-api-hooks-for/commits
09:58:56 <cinimod`> Ah cool
09:58:58 <cinimod`> thanks
09:59:06 <carter> cinimod`: basically isTrue#
09:59:11 <brolin_empey> How do I solve the ‚Äúunknown symbol `__imp___fmode'‚Äù problem with gtk2hs on Windows NT?
09:59:16 <carter> you may wanna use a teeny bit of CPP to allow the old style
09:59:33 <mewab> Can I pass an accessor of a certain type as a parameter for a function then use it?
09:59:35 <carter> cinimod`: my patch there was strucutred to thatlib
09:59:54 <mewab> object { someAccessor = someNum }
10:00:07 <mewab> someAccessor :: Object -> Int
10:00:12 <mewab> and someNum is Int
10:00:19 <mewab> I tried doing that but it does not work
10:00:21 <carter> cinimod`: but it should give you some hints
10:00:27 <mewab> i.e. I can't pass someAccessor to the function
10:01:59 <quchen> mewab: http://lpaste.net/117116 Something like this should be possible.
10:02:05 <quchen> That's an Int-throwing IO.
10:02:30 <idnar> is there a better way to write "handle (\e -> foo >> throw (e :: SomeException)) bar"? "handle foo bar" has the wrong type
10:03:56 <mewab> thanks quchen but if I want to throw all sorts of exception types
10:04:06 <mewab> I have to do repeat the process each time
10:04:29 <mewab> but if I'm using Control.Exception's mechanism with the SomeException conversion, I can right away throw whatever instance of Exception that I want
10:07:44 <EvanR> ‚äë
10:09:44 <quchen> mewab: You can also write an instance that throws a SomeException.
10:09:53 <quchen> You can also write your own SomeException.
10:10:08 <quchen> Or throw a sum type of all the possible exceptions you have.
10:11:00 <mewab> quchen: You're right! Haven't though of that! Is that an acceptable practice?
10:11:45 <EvanR> ones = (‚ä• ‚äë 1:‚ä• ‚äë 1:1:‚ä• ‚äë ...) ?
10:11:50 <mewab> quchen: a sum type is even a better idea
10:12:22 <mewab> quchen: don't know how I haven't thought about it. So the most sensible thing to do would be a MonadError with my sum type?
10:12:35 <Luke> I'm trying to pack two 8-bit chars into a Word16. Here's what I have so far though it doesn't work: http://lpaste.net/5778993799460028416
10:12:38 <Luke> anyone know how to do this?
10:12:39 <quchen> It's probably the easiest solution.
10:12:50 <mewab> quchen: if I'm plannign to catch the exception in IO does it even matter if I use MonadError? Or is it acceptable to just use Control.Exception?
10:13:07 <EvanR> Luke: well theres (a `shiftL` 8) .|. b
10:13:22 <quchen> Luke: There are no 8-bit chars in there.
10:13:23 <EvanR> with fromIntegral thrown in
10:13:31 <quchen> Char is not 8-bit, it's abstract.
10:13:48 <Luke> fair - how can I get it's 8-bit representation then?
10:14:00 <Luke> EvanR: I think shift uses the sign to say which direction to shift
10:14:09 <EvanR> > ord '‚äë'
10:14:11 <lambdabot>  8849
10:14:11 <quchen> ‚òÉ does not have an 8-bit representation.
10:14:13 <mauke> > '\123456'
10:14:14 <lambdabot>  '\123456'
10:14:25 <Luke> i want it's 8-bit ASCII representation
10:14:32 <Luke> that's unicode
10:14:41 <mauke> ASCII is 7 bits, not 8
10:14:44 <flebron> Hi. How should I interpret this heap profile from -hy? What is the "[]" label? http://fedelebron.com/static/4.ps
10:14:48 <mauke> and Char is unicode
10:14:50 <EvanR> Luke: no theres left and right shift, with right shift having two versions to tell whether to sign extend
10:14:51 <Luke> mauke: fits into 8
10:15:34 <Luke> EvanR: as far as I can tell from the docs, "shift" is equivalent to "shiftL" or "shiftR" based on the sign of the shift bits
10:15:51 <EvanR> spooky
10:15:58 <quchen> flebron: I think the GHC manual talks about these things somewhere. Let me see whether I can find it.
10:16:20 <EvanR> Luke: just saying, you want a left shift for this, after reformulating the problem correctly
10:16:40 <Luke> right: and "shift" by a positive bit offset is a left shift
10:16:48 <Luke> so I was already using a left shift
10:17:03 <quchen> If you want a left shift, why not use shiftL
10:17:14 <quchen> Very little room for confusion then
10:17:23 <carter> Luke: .... theres no ascii rep of unicode snowman
10:17:26 <Luke> this is getting offtopic
10:17:49 <Luke> anyway ord gets me closer but now I think I need an unsafe coerce - is there a better way to go from int to word16?
10:17:54 <quchen> Wat.
10:17:58 <flebron> lol
10:18:03 <quchen> No, unsafeCoerce will not save you here.
10:18:21 <Luke> so how can I go from the resulting int to word16?
10:18:25 <flebron> UnsafeCoerce won't save you ever, it will always damn you.
10:18:33 <EvanR> Luke: fromIntegral
10:18:37 <Luke> thanks
10:18:39 <quchen> :t fromIntegral -- Int to Word16, silently truncating
10:18:41 <lambdabot> (Num b, Integral a) => a -> b
10:19:04 <EvanR> if youre sure you have a char whose ord is less than 128 then fromIntegral can be used without thinking any more about it
10:19:07 <Luke> quchen: yeah EvanR already said said that
10:19:19 <Luke> EvanR: great thanks a lot
10:19:55 <EvanR> a type dedicated to this kind of "ASCII Char" would be cool
10:20:08 <quchen> Char7?
10:20:12 <EvanR> hehe
10:20:27 <quchen> flebron: Hmm can't find it anymore :-| RWH has a section about this, but you probably already checked that
10:20:30 <EvanR> AsciiText = Vector Char7
10:20:43 <quchen> EvanR: mumble mumble databytestringchar7
10:21:04 <EvanR> with some static guarantee that the bytes arent between 128 and 255
10:21:18 <EvanR> so you can use checksums?!!!
10:21:42 <quchen> With some static guarantee that there is one globally known bit that's unused. That bit changes nondeterministically.
10:22:14 <EvanR> sounds legit
10:22:40 <EvanR> i was just thinking, though, that the guarantee is the elements are ascii characters
10:24:00 <EvanR> i know theres a Prop based ascii hackage
10:25:48 <erisco> @let id2 = unsafeCoerce . unsafeCoerce :: a -> a
10:25:48 <lambdabot>  .L.hs:169:7: Not in scope: ‚ÄòunsafeCoerce‚Äô
10:25:48 <lambdabot>  
10:25:48 <lambdabot>  .L.hs:169:22: Not in scope: ‚ÄòunsafeCoerce‚Äô
10:26:03 <erisco> I see lambdabot has standards too high for that
10:26:17 <dfeuer> quchen, don't you just need fromEnum for Char7 to do a mask?
10:26:37 <EvanR> you could unsafeCoerce some integer into a system call that self destructs the hdd ;)
10:27:20 <quchen> dfeuer: Maybe. Maybe not. Maybe I should not finish this quote. ;-)
10:27:59 <quchen> Anything involving Char-withanumber is probably not worth thinking about much.
10:28:18 <EvanR> Ascii characters come up an awful lot, still
10:29:43 <erisco> :t (undefined :: b -> c) . (undefined :: a -> b) :: a -> a
10:29:44 <lambdabot> a -> a
10:29:56 <erisco> hmm I find that strange
10:29:59 <dfeuer> ASCII is much more compact and much faster to work with than Unicode.
10:31:27 <EvanR> erisco: doesnt that just mean c = a, by your request
10:31:31 <flebron> quchen: Ah, RWH has a sentence "The most interesting things to notice here are large parts of the heap devoted to values of list type (the [] band)"
10:31:57 <erisco> EvanR, which 'a'?
10:31:58 <quchen> flebron: Homework: find that section in the user's guide
10:32:15 <erisco> also, the part I find weird is what will happen in the middle
10:32:22 <EvanR> erisco: the implicit forall a
10:32:25 <quchen> [] really doesn't say much in a postscript file without context.
10:32:46 <erisco> EvanR, there are two a's in the example, it is not all one scope
10:33:38 <EvanR> :t (undefined :: a) :: b
10:33:38 <lambdabot> b
10:33:51 <EvanR> they unified
10:33:57 <quchen> dfeuer: ASCII is not more compact than Unicode (say UTF-8) if you use one byte for an ASCII char (which is what's usually done).
10:34:15 <quchen> And I don't know about the "much faster" either.
10:34:18 <EvanR> :t (undefined :: Int) :: b
10:34:19 <lambdabot>     Couldn't match expected type ‚Äòb1‚Äô with actual type ‚ÄòInt‚Äô
10:34:19 <lambdabot>       ‚Äòb1‚Äô is a rigid type variable bound by
10:34:19 <lambdabot>            an expression type signature: b1 at <interactive>:1:1
10:35:25 <geekosaur> :t (undefined :: _a) :: b
10:35:26 <lambdabot> b
10:35:32 <geekosaur> awww
10:35:40 <dfeuer> quchen, if I give you a 1-billion-character ASCII file and ask for the 500 millionth character, you will be able to tell me real quick. If I give you a 1-billion-codepoint UTF-8 file and ask for the 500 millionth codepoint, you will take some time.
10:35:45 <quchen> geekosaur: Hoping for 7.10 magic?
10:35:59 <erisco> EvanR, that is fine but I still don't know which 'a' you are referring to
10:36:00 <EvanR> im thankful the nth character in a sequence isnt often needed
10:36:03 <geekosaur> thought typed holes were already there
10:36:16 <dfeuer> quchen, compactness is more in processing. You probably don't actually want to work, internally, in UTF-8.
10:36:19 <erisco> also, I still don't know how it decides what 'b' should be
10:36:24 <mauke> dfeuer: what are codepoints good for?
10:36:41 <flebron> Say I have a file with n space-separated 32-bit ints. What's the fastest way to read those into a Data.Array.Unboxed.UArray?
10:36:42 <EvanR> erisco: nevermind. the inside variables dont matter i guess
10:36:43 <dfeuer> mauke, I guess that's a fair question.
10:36:58 <flebron> (I'm currently going through words . getLines, but that seems to be using a lot of memory.)
10:37:16 <flebron> err, sorry, words <$> getContents I meant.
10:37:24 <dfeuer> flebron, good question! But how do you separate 32-bit Ints with spaces?
10:37:25 <EvanR> dfeuer: if you are mostly folding, utf8 is fine
10:37:35 <flebron> dfeuer: "1 2 3 4 5"
10:37:51 <EvanR> and its fast to encode and decode into utf8 if its the external format ;)
10:37:56 <dfeuer> flebron, those are not 32-bit Ints.
10:38:11 <flebron> I didn't say Ints though, I said ints.
10:38:17 <dfeuer> EvanR, I suppose that's a point.
10:38:20 <flebron> ;)
10:38:37 <dfeuer> flebron, since an "int" is not a thing in Haskell, I assumed you must mean an "Int".
10:38:47 <dfeuer> You also said 32-bit.
10:38:50 <flebron> Well it's a thing in C.
10:38:50 <dfeuer> So an Int32
10:38:56 <dfeuer> Those are not C ints either.
10:39:06 <dfeuer> They are strings.
10:39:13 <dfeuer> ANYWAY.
10:39:20 <flebron> If pedantry is required, I have a list of bytes, such that if I were to interpret it as a list of space-separated strings od digits, each string of digits could be converted to the a 32-bit C int.
10:39:35 <EvanR> &&x*[]**[]
10:39:42 <dfeuer> flebron, how are you stuffing them into the UArray?
10:39:43 <flebron> That's too pedantic, so one says "I have n space-separated ints".
10:39:50 <flebron> Using fromList.
10:39:58 <mauke> flebron: should be "decimal digits"
10:39:59 <flebron> And the aforementioned words <$> getContents.
10:40:05 <flebron> Even better, mauke.
10:40:20 <flebron> Although I'd think "digits" is already decimal.
10:40:21 <mauke> and apparently not fixed width
10:40:27 <flebron> (As opposed to bits, trits, ...)
10:40:34 <mauke> I would've expected 8 hex digits
10:40:42 <flebron> You are a strange, strange person, then.
10:40:42 <EvanR> digits are characters
10:40:49 <mauke> because you specifically said "32-bit"
10:40:52 <EvanR> in fact, ascii chars!
10:40:58 <flebron> Yes, to mean they fit in 32 bits.
10:41:21 <flebron> To be pedantic, such that if the aforementioned conversion procedure was undertaken, they would be faithfully represented by a 32-bit int.
10:41:38 <flebron> To be even more pedantic, these are all nonnegative.
10:41:57 <dfeuer> flebron, do you mean listArray?  I don't see a fromList.
10:42:11 <flebron> This pedantry, however, has so far given me no clue as to how to improve the performance of my reading of these oh-so-important characters into an UArray of Int :)
10:42:17 <flebron> Yeah, sorry, listArray.
10:42:35 <flebron> I think fromList must be from Data.Traversable or Foldable or something.
10:42:53 <kadoban> flebron: What are you using, Strings and read :: Int or whatever?
10:42:56 <dfeuer> flebron, there's a fromList in Data.Sequence.
10:43:10 <dfeuer> And there's a fromList in GHC.Exts (in the IsList class)
10:43:17 <flebron> kadoban: getContents returns a String, so yes :)
10:43:21 <EvanR> use ByteString IO, first of all. or equivalent Iteratee
10:43:26 <flebron> Would you expect Data.Text or ByteString to improve things?
10:43:29 <flebron> Alright.
10:43:52 <dfeuer> words is kind of silly.
10:43:56 <quchen> ByteStrings don't have lines though.
10:44:06 <quchen> Or words.
10:44:23 <dfeuer> You want, one way or another, to combine the number parsing with the number separating.
10:44:24 <kadoban> flebron: Yeah, both would speed it up. From ByteString.Char8 there's uhm, readInt and lines/words
10:44:28 <dfeuer> I believe.
10:44:43 <dfeuer> readInt sounds promising.
10:45:22 <flebron> I'll give it a shot then :)
10:45:36 <kadoban> I think there's a way in Text as well, but I can't find it at the moment. Even doing that way, unpacking to String and using read is probably faster than using String directly, I think, but I'm not so sure.
10:46:04 <dfeuer> Well, you don't *have* to use getContents.
10:46:30 <EvanR> dont use getContents for real stuff!
10:46:31 <dfeuer> flebron, you also could probably do better even with String if you avoid the words.
10:47:36 <dfeuer> I think you could probably write a nice fold over the getContents that produces Ints as it goes.
10:48:32 <kadoban> That sounds harder than the other ways though, at least to me.
10:48:45 * hackagebot haddock-api 2.15.0.1 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-api-2.15.0.1 (MateuszKowalczyk)
10:48:47 * hackagebot haddock 2.15.0.1 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.15.0.1 (MateuszKowalczyk)
10:48:48 <jonaazzzzz> why cant' i do this
10:48:48 <jonaazzzzz> data Something = Module.Number | MagicNumber { amount :: Int }
10:49:01 <jonaazzzzz> it says qualified name in binding position
10:49:34 <flebron> Module.Number isn't a valid constructor name, I'd think.
10:49:44 <kadoban> jonaazzzzz: Because there's a qualified name in binding position :) You want a Something to be able to be created from an Int or a Module.Number? You have to give it a constructor for the first one. Like...
10:49:47 <flebron> ("Module." is qualifying "Number").
10:49:58 <kadoban> jonaazzzzz: data Something = Blah Module.Number | ...
10:50:26 <jonaazzzzz> hmm but i want to do that Something is either a Number or a MagicNumber
10:50:30 <jonaazzzzz> how i do that than?
10:50:31 <dfeuer> getInts :: String -> [Int];  getInts str = build $ \c n -> foldr (\c !r a -> if isSpace c then a else r (digitToInt c+10*a)) n str 0
10:50:38 <dfeuer> Something like that, I think, flebron.
10:50:49 <clrnd> jonaazzzzz, data Something a = Number a | MagicNumber a
10:51:03 <dfeuer> er..
10:51:05 <dfeuer> that was wrong
10:51:20 <jonaazzzzz> hmm let me try to copy the definiton of the Number
10:51:43 <dfeuer> getInts :: String -> [Int];  getInts str = build $ \c n -> foldr (\ch !r a -> if isSpace c then a `c` r 0 else r (digitToInt ch+10*a)) n str 0
10:51:49 <dfeuer> There; more like that, I think.
10:51:56 <dfeuer> Except isSpace ch
10:51:59 <dfeuer> Dammit.
10:52:20 <jonaazzzzz> no it's not working clrnd
10:52:34 <jonaazzzzz> how can i reuse the definition from my other module?
10:52:35 <athan_> Hey guys, -XDeriveGeneric isn't working - it's just telling me that `Generic` is not in scope, from `data Foo = Foo deriving Generic`
10:52:45 <cinimod`> carter: woohoo i can now compile under 7.8.3
10:53:02 <cinimod`> All I need to do now is make sure it still compiles under 7.6
10:53:17 <kadoban> jonaazzzzz: It doesn't really have anything to do with modules. You already have a Number type or constructor, you have to give Something a constructor to wrap it in.
10:53:22 <mauke> athan_: you need to import it
10:53:55 <Denommus> any idea when GHCJS's cabal and cabal-install will be merged into trunk?
10:53:59 <jonaazzzzz> so i can't do this? data Something = Number Int Int | MagicNumber Int? they have different params
10:54:15 <clrnd> jonaazzzzz, doesn't matter the number of params
10:54:30 <kadoban> jonaazzzzz: You could if Number didn't already mean something.
10:54:36 <athan_> mauke: Oh shoot, thanks :)
10:54:52 <jonaazzzzz> hmmm.. so i can't reuse that data type frm my module? :p that strange
10:54:53 <mmmm> athan_: import GHC.Generics
10:55:06 <kadoban> jonaazzzzz: Could you do...  data Something = Int | Char   ?
10:55:14 <kadoban> jonaazzzzz: Sure you can, but you have to wrap it.
10:55:39 <EvanR> data Something = SomeInt Int | SomeChar Char
10:56:01 <Denommus> man, I still wish I knew how to use QML signals from Haskell, instead of the other way around
10:56:17 <Denommus> QML would be great as a GUI-only DSL
10:56:31 <jonaazzzzz> but in my other module i already have SomeInt Int, than that doesn't work because when i use SomeInt it says ambigous between the one defined in my own module and the one imported from the other module
10:56:35 <jonaazzzzz> EvanR
10:56:56 <EvanR> jonaazzzzz: you can call it something else or import qualified
10:57:01 <EvanR> A.SomeInt, B.SomeInt
10:57:01 <kadoban> jonaazzzzz: Sure, you have to give it a unique name, otherwise it wouldn't make much sense.
10:57:36 <jonaazzzzz> but i just want to reuse it? :( let me create a lpaste
10:58:24 <kadoban> jonaazzzzz: One name can't mean two different things at once. If  SomeInt blah is both a Something and a SomethingElse, how is haskell supposed to figure out what to do?
10:58:33 <jonaazzzzz> like this: http://lpaste.net/4496185105068326912 how i fix it
10:58:42 <EvanR> kadoban: with type-directed name disambiguation ;)
10:58:49 <jonaazzzzz> in module B i want to use Something, which can be one of both types
10:59:01 <kadoban> EvanR: :P
10:59:44 <EvanR> jonaazzzzz: whats the problem here?
11:00:14 <jonaazzzzz> when i do that, and i use Test in module b, than t it says ambigous between the one defined in my own module and the one imported from the other module
11:00:32 <EvanR> you really shouldnt name all your types Something, and certainly not in the same file
11:00:42 <kadoban> jonaazzzzz: Well, unless I'm missing something, the first doesn't even work. But assuming you're looking at the second...you just can't. You have to make it ... SomeTest Test | ... or give it a unique name, whichever you mean to do.
11:01:13 <EvanR> you can do it
11:01:17 <jonaazzzzz> sorry first is data Test = Test { amount :: Int}
11:01:34 <jonaazzzzz> Hmm ok, i think i get it thanks let me try
11:01:35 <EvanR> you have A.Test (a type) and B.Test (a function, constructor)
11:01:44 <EvanR> to use them in module C you need to import qualified
11:02:12 <meretrix> When I'm using "cabal repl" interactively, how can I import a module from a "hidden" package without setting up a .cabal file?
11:02:14 <EvanR> (B.Test isnt a function in this case, nevermind)
11:02:54 <kadoban> meretrix: Isn't the whole point of 'cabal repl' to use a .cabal file and such?
11:03:04 <toblerone> hi all, I've been playing around with the sockets API and I'm trying to support multiple persistent connections that a server can read from and write to. My current implementation doesn't work for some reason I can't quite figure out. Here it is: http://lpaste.net/117073
11:03:24 <toblerone> Perhaps I don't understand sockets
11:03:39 <meretrix> kadoban: Yes I suppose, but sometimes I just want to check something without redoing the cabal file.
11:04:23 <kadoban> Fair enough I guess. If there's a way, which is quite possible, I don't know it...
11:04:28 <EvanR> can someone help me understand what the denotation of this datatype is newtype U = In ((U -> Bool) -> Bool)
11:06:07 <quchen> EvanR: Cont Bool U
11:07:17 <mauke> toblerone: "atomically retry"? what is that supposed to do?
11:07:56 <EvanR> quchen: ok, Cont, but whats U?
11:08:14 <quchen> Oh U is the type itself
11:08:23 <toblerone> mauke: Well its my understanding that the retry will "retry" reading 'n' on line 27 if it hadn't changed
11:08:23 <quchen> Well then that's nothing I've seen
11:08:28 <EvanR> U = Cont Bool U
11:08:31 <EvanR> heh
11:08:58 <mauke> toblerone: nope. 'retry' will restart the current STM action
11:09:13 <mauke> toblerone: so basically 'atomically retry' is a weird way to write an infinite loop
11:09:23 <mauke> or maybe GHC detects this and kills your thread
11:09:48 <toblerone> ah, so if I did a read and retry inside stm
11:10:01 <toblerone> and then did atomically on that, it would work as expected
11:10:09 <toblerone> I suspected that might be my problem
11:11:57 <toblerone> mauke: Okay, so if that is my problem, what do you think the best way to "block until change"? Switch to a TChan instead of a TVar?
11:13:19 <EvanR> MVar?
11:13:36 <EvanR> or TMvar
11:13:52 <toblerone> EvanR: Is that to me?
11:14:16 <EvanR> yeah if you take an mvar, you block until someone writes to it
11:14:27 <EvanR> repeat
11:14:28 <toblerone> ah cool
11:14:42 <toblerone> and tmvar is an stm mvar
11:14:46 <toblerone> ill give that a shot
11:14:47 <EvanR> i think so
11:14:47 <toblerone> thanks
11:16:30 <mp> getArgs >>= return . head >>= putStrLn -- is there prettier way to write it?
11:17:07 <Denommus> damn, can't build ghc-mod
11:17:14 <mauke> getArgs >>= putStrLn . head
11:17:24 <mauke> putStrLn . head =<< getArgs
11:18:45 <Denommus> putStrLn . head <$> getArgs
11:18:52 <Denommus> if you import Control.Applicative
11:18:52 <mp> mauke: cool thanks; and maybe so that "get", "head", "put" appear in this order?
11:18:53 <mauke> fail
11:19:00 <Denommus> :t putStrLn . head <$> getArgs
11:19:01 <lambdabot> Not in scope: ‚ÄògetArgs‚Äô
11:19:04 <Denommus> no, wait, I'm wrong
11:19:18 <danilo2> Hello! Is there in haskell a tool to see the Haskell Core tree? I know that there is ghc-core but it doesnt show the whole tree I think. for example, with just simple code: data A = A deriving Show; main = print A; the ghc-core does not show any code related to the type of A and I would love to inspect it and see how it is kept. Is is somehow possible?
11:19:40 <mauke> getArgs >>= (head >>> putStrln)? not sure if you need the parens
11:20:06 <mp> cool, thanks :)
11:22:21 <EvanR> mp: your program will instacrash if no args are given ;)
11:23:00 <ocramz> ahoy there
11:23:21 <mp> is (\x -> return x) "free" in terms of performance? it does not really box it, right? ghc will optimize return away?
11:23:38 <EvanR> > sum . map succ . head . group $ ""
11:23:40 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
11:23:40 <lambdabot>    arising from a use of ‚ÄòData.List.sum‚Äô
11:23:43 <mauke> mp: what?
11:24:02 <EvanR> > sum . map succ . head . group $ []
11:24:03 <lambdabot>  *Exception: Prelude.head: empty list
11:24:17 <ocramz> :t group
11:24:18 <lambdabot> Eq a => [a] -> [[a]]
11:24:48 <carter> cinimod`: :)
11:25:05 <ocramz> :i group
11:25:15 <EvanR> mp: its hard to talk about performance of different kinds of equivalent syntax, since ghc optimizes so much
11:25:56 <EvanR> mp: why would you write (\x -> return x) ?
11:26:47 <zipper> EvanR: Because you want to create a Monad?
11:26:48 <clrnd> using ghc 7.11 I can't install scotty
11:26:53 <clrnd> says something about vault
11:27:01 <clrnd> what's 7.11 `base` version?
11:27:01 <EvanR> zipper: its the same as saying return by itself
11:27:28 <mauke> zipper: creating monads is done with 'instance Monad X where ...'
11:28:41 <Denommus> anyone else having problems installing ghc-mod?
11:28:45 <EvanR> Monad x = (Monad*) new Monad();
11:29:09 <jonazzzz> i got a function that returns a new object, how can i make an array of 25 of those objects any idea?
11:29:16 <pnielsen> EvanR: welcome to Haskell, where one of the bigger downsides is the compiler uses some kind of quantum field theory to optimize 95% of your code and it's hard to identify the remaining 5%
11:29:24 <EvanR> jonazzzz: replicateM
11:30:14 <EvanR> pnielsen: in any language its hard to identify performance issues until you use profilers
11:30:42 <jonazzzz> thanks, will it work if my function returns an IO Something
11:30:48 <jonazzzz> so i get a list of Something
11:30:53 <EvanR> :t replicateM
11:30:54 <lambdabot> Monad m => Int -> m a -> m [a]
11:31:08 <jonazzzz> alright :p
11:31:21 <pnielsen> yeah but in Haskell it's hard to anticipate what machine language your code will be translated into, whereas in languages like C my code is just slow
11:31:27 <pnielsen> :P
11:31:42 <EvanR> i dont pretend to know what the c compiler even will do
11:32:08 <EvanR> bigger issues to worry about in C ;)
11:32:45 <pnielsen> the ntpd guys can attest to that
11:33:47 * hackagebot MonadCatchIO-transformers 0.3.1.3 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.3.1.3 (AriePeterson)
11:34:00 <Denommus> holy cow, why can't I install ghc-mod? -.-
11:34:09 <Denommus> I'm getting a "Wrong category of family instance; declaration was for a type synonym"
11:35:17 <clrnd> Denommus, that sounds fun!
11:37:11 <bennofs> Denommus: i think there is a bug about that on ghc-mod bugtracker, no?
11:37:40 <Denommus> bennofs: I don't know
11:38:40 <bennofs> Denommus: https://github.com/kazu-yamamoto/ghc-mod/issues/422
11:39:26 <aristid> when did ghc get pattern synonyms?
11:39:31 <bennofs> Denommus: https://github.com/phaazon/ghc-mod/commit/625bd720d7438d877c9cb7420225dcc30ab187b9 seems to be the fix
11:39:36 <bennofs> aristid: 7.8 I guess?
11:39:44 <aristid> hmm looks like a cool feature
11:39:56 <bennofs> either 7.8 or 7.10
11:40:49 <bennofs> ah, must be 7.8, i already used it and wondered why it didn't work in GHCi :)
11:41:01 <jonazzzz> hey guys can i pattern match like this? i have a IORef Something, and Something Int Int, can i do (IORef (Something x y)) for example?
11:41:13 <jonazzzz> or do i need to readIORef first
11:41:42 <mauke> you need readIORef
11:41:50 <mauke> IORef is an opaque type
11:44:57 <jonazzzz> ok thanks man
11:45:20 <endiruna> i have another stupid question if i do:   main = do x <- readLn          i get an error but if i put some operations afterwards like   if x == 4 then putStrLn "hello" else putStrLn "ciao"       then it would work
11:45:38 <mauke> (by "opaque" I mean you don't know what its constructor(s) are)
11:45:41 <aristid> what does this code snippet mean? "type role HyperLogLog nominal"
11:45:47 <c_wraith> endiruna: a do block can't end with a bind (the <- line)
11:46:22 <jonazzzz> yeah i saw it in class xd you need to have a expression at the last line because it uses the bind function from monadzzz
11:46:29 <c_wraith> endiruna: that's part of how do blocks are desugared.  <- lines desugar to use of the >>= operation, which needs two parameters
11:46:55 <jonazzzz> first thing i can answer haha :p
11:46:55 <c_wraith> endiruna: the rest of the do block is one of the parameters.  (more or less)
11:46:58 <geekosaur> aristid: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/roles.html#idp25254608
11:47:04 <mauke> do { v <- X; ... } turns into X >>= \v -> do { ... }
11:47:07 <mmachenry> Is this a bug in the Database.Enumerator library? http://lpaste.net/117033
11:47:58 <mmachenry> I can't seem to find any way to close cursors unless I'm doing a select. Commands seem to not have them because they have no interators (according to the types) and withCursor is the only way to ensure they are closed.
11:48:23 <mmachenry> I think that execDML is supposed to open and close a cursor but it never closes it. Perhaps I'm using this incorrectly though.
11:48:39 <Denommus> bennofs: thanks, I think it will install now
11:49:16 <aristid> geekosaur: oh that's interesting but a bit confusing
11:52:09 <endiruna> i have a rather stupid question: what is a bind?
11:52:12 <geekosaur> it's confusing but somewhat important; as noted on that page, you can do things like break Set completely
11:52:22 <endiruna> so it has to call some function that is not a IO?
11:53:07 <mauke> "bind" is the name given to the >>= operator
11:53:11 <mauke> :t (>>=)
11:53:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:53:20 <mauke> or just looking at IO
11:53:26 <mauke> IO a -> (a -> IO b) -> IO b
11:53:50 <mauke> it takes an IO action and a function, and combines them into a bigger action
11:56:34 <aristid> geekosaur: are roles used only for generalized newtype deriving?
11:57:14 <geekosaur> that's the most common case, I think
11:57:34 <geekosaur> it also prevents explicit "abuses", but those are fairly rare
11:57:48 <geekosaur> it's GND that can silently create brokenness
11:58:10 <aristid> what would an explicit abuse look like?
12:01:11 <wyager> Hi all. I am getting an error I'm not sure how to deal with. When using the -XOverloadedLists extension, I would think "[1..100] :: Vector Int" would be a valid expression, but GHC is complaining "No instance for (Enum (GHC.Exts.Item (Vector Int))) arising from the arithmetic sequence ‚Äò1 .. 100‚Äô".
12:01:12 <geekosaur> mm, they describe but don't show one in that web page: you can explicitly create a newtype over Set or Map (not using deriving since that would actually "do the right thing" here) with a different Ord instance
12:01:48 <geekosaur> which would let you do things like hide values in the Set or Map that can't be accessed except via the newtype, since they can only be reached using the newtype's special Ord instance
12:02:18 <pikkabird> :quit
12:02:23 <pikkabird> ?
12:02:52 <geekosaur> "/quit" perhaps? (were you looking to exit IRC?)
12:02:53 <mauke> pikkabird: /quit
12:03:00 <mauke> if you want to exit irssi
12:03:25 * bsmt wonders if there is an IRC extension for vim
12:03:33 <mauke> there used to be, yes
12:03:39 <bsmt> ha, of course
12:03:44 <geekosaur> probably, and it's probably about as broken as the emacs one(s)
12:03:51 <aristid> geekosaur: but how would the role system prevent you from doing this abuse?
12:03:59 <mauke> more broken because no one uses it
12:04:48 <geekosaur> if I understand correctly, by declaring the type as nominal, your newtype would actually produce a different Set
12:05:09 <clrnd> yo scotty is pretty fast, gud
12:05:30 <geekosaur> or if it can't do that then it just declares the newtype invalid because it would violate the role annotation, which is protecting Set's invariant
12:06:12 <agibiansky> Does anyone have any experience packaging Haskell/GHC things? I am trying to figure out how to do so, but failing. My first attempt at making a relative-path-based cabal directory failed because `cabal` wants an absolute `prefix`, even though I hear new cabal supports relocatable packages...
12:09:18 <aristid> geekosaur: but then you won't be able to get the set out of the newtype at all?
12:09:57 <geekosaur> I think you can still unwrap it? what you can't do is use the newtype to replace the Ord instance
12:10:33 <geekosaur> I may be confused abotu what's going on, actually
12:12:23 <geekosaur> I worked this through at one point but have not remembered it beyond what I need to know to write code... not really a type theory wonk
12:14:19 <aristid> haha no worries
12:15:03 <aristid> i don't think i or most people here are likely to use that feature
12:16:20 <ianliu> How can I find the list index of the first element satisfying a condition (such as positiveness)?
12:17:23 <lericson> ianliu: firstIndex x:xs x = 0 \n firstIndex x:xs v = 1 + (firstIndex xs v)
12:17:24 <lericson> i suppose
12:17:44 <lericson> i'm sure there's a more succinct way to put it ;)
12:19:04 <mauke> @hoogle [a] -> (a -> Bool) -> Int
12:19:06 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
12:19:06 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
12:19:06 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
12:19:19 <lericson> ah.
12:19:27 <mauke> lericson: missing parens
12:21:10 <lericson> around the cons operator?
12:21:39 <greymalkin> If I want to run two monads which are wrappers around IO... how?
12:21:55 <mauke> lericson: yes
12:22:00 <lericson> greymalkin: what is a wrapper around IO?
12:22:26 <mauke> lericson: and you can't reuse variables in patterns
12:27:35 <lericson> what, i thought this was prolog
12:27:39 <lericson> ;)
12:28:10 <mauke> No.
12:28:49 <nitnelave> Hey everyone! I'm trying to have a shared module, like a .so but from Haskell to Haskell, any idea how to do that?
12:29:23 <eazar001> nitnelave: i think you have to go to your cabal.config and make sure "library-shared : True"
12:29:26 <eazar001> something like that
12:29:30 <Peaker> nitnelave: GHC can compile .so's now - or do you mean one you want to load with dlopen/etc?
12:29:30 <mauke> nitnelave: why does it have to be shared?
12:29:39 <quchen> nitnelave: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-shared-libs.html
12:30:00 <nitnelave> Basically, I want to test many students' code
12:30:21 <nitnelave> So I asked them to write the module respecting a certain interface
12:30:21 <eazar001> some people want .so files ... it's not an uncommon thing
12:30:50 <mauke> nitnelave: how do shared libraries help with this?
12:30:53 <nitnelave> the tests use the module, but I don't want to re-compile each test for each student
12:31:21 <mauke> why not?
12:31:22 <nitnelave> so I want to compile their module into a .so, and compile (only once) the tests
12:31:42 <nitnelave> then I can just load the different .so to test the students' code
12:31:55 <nitnelave> mauke: too much resources, too many students
12:32:17 <mauke> runhaskell?
12:32:46 <eazar001> yea, you don't have to compile
12:32:55 <nitnelave> that was one solution, but I wanted to see if I could do with compiled code
12:33:05 <quchen> Even if you compile you won't have to recompile the unchanged modules
12:33:31 <nitnelave> some tests are cpu intensive, it would be better compiled
12:33:34 <quchen> Ooooor ‚Ä¶ Homework A: Set up a Github/Travis account. B: send me the build log including sample output.
12:33:59 <nitnelave> quchen: not gonna work....
12:34:07 <eazar001> but i think it's a good thing to learn something as basic as that nitnelave
12:34:11 <eazar001> i say go for it
12:34:20 <eazar001> quchen 's link will help you with that =]
12:34:30 <nitnelave> well, I had a look at it
12:34:34 <quchen> In any case you'll have to compile your students' sources
12:34:39 <ReinH> "cabal-install-1.20.0.4 depends on Cabal-1.20.0.3 which failed to install." hahahaha
12:34:54 <quchen> And whether your other lib is static or dynamic shouldn't matter much
12:35:11 <nitnelave> but apart from exporting a C interface and then loading it dynamically with custom ghc code...
12:35:18 * quchen runs cabal update
12:35:37 <quchen> Uh oh, new Cabal indeed
12:35:59 <jonazzzz> :t RightButton
12:36:00 <lambdabot> Not in scope: data constructor ‚ÄòRightButton‚Äô
12:36:08 <jonazzzz> damnit anybody knows?
12:36:28 <nitnelave> I mean, I compiled a .so from a module, but then I can't use it to compile the main program
12:36:43 <nitnelave> "cannot find module Whatever"
12:37:47 <nitnelave> Do I have to go through a package?
12:38:11 <eazar001> i think your module needs to be in a certain path nitnelave
12:38:24 <eazar001> module(s)
12:38:30 <jonazzzz> anybody knows how to print out the type of a variable in the program? not :t, but i need to print it like putStr ... ?
12:38:33 <nitnelave> well, I put it in . and added -L. to the compilation command
12:38:38 <eazar001> hmmm
12:38:52 <nitnelave> but it told me (with -v) it was only looking for
12:39:01 <nitnelave> Whatever.hs and Whatever.lhs
12:40:16 <mauke> jonazzzz: what for?
12:40:28 <jonazzzz> because i don't know what type RightButton is
12:40:44 <jonazzzz> onButtonPress bu (\x -> if (Ev.eventButton x) == RightButton
12:40:48 <mauke> jonazzzz: why not use :t?
12:41:00 <jonazzzz> because it can't find it :(
12:41:13 <mauke> jonazzzz: does the code compile?
12:41:33 <jonazzzz> oh god :D
12:41:36 <quchen> > return (3+4) `asTypeOf` _what_is_that_type
12:41:38 <lambdabot>  Found hole ‚Äò_what_is_that_type‚Äô with type: m a
12:41:38 <lambdabot>  Where: ‚Äòm‚Äô is a rigid type variable bound by
12:41:38 <lambdabot>             the inferred type of it :: m a at Top level
12:41:40 <quchen> Hole magic!
12:41:51 <jonazzzz> it's ok, i forgot to load the lib xd
12:41:52 <quchen> Modulo typeclasses
12:41:56 <jonazzzz> haha quchen thanks i will remember that
12:42:22 <mauke> print (typeOf RightButton)
12:42:27 <mauke> spoilers: it's RightButton
12:42:41 <quchen>  :t is the identity on types.
12:42:44 <mauke> ah, no. MouseButton
12:43:36 <jonazzzz> yep it is a mousebutton ^^
12:44:26 <nitnelave> ok, now when trying to get the .o for the test, I have a "Failed to load interface for `Whatever'"
12:44:48 <nitnelave> How do you write a simple interface?
12:45:04 <geekosaur> ypu don't. what it means is that next to the .o there should be a .hi file
12:45:32 <nitnelave> how do I get the .hi file?
12:45:57 <geekosaur> (it would be interesting if that could be generated as part of the .o but I don't think there's a portable way to do so, barring extreme abuse of the symbol table)
12:46:16 <greymalkin> I'm so ready to scream.
12:46:33 <geekosaur> nitnelave, wherever you got the .o file
12:46:50 <nitnelave> I'm trying to get the .o file
12:46:51 <Denommus> which routing library to use with Happstack?
12:46:54 <geekosaur> it is not something you create, it is created alongside the .o by ghc and it must go together with it
12:46:55 <greymalkin> I need to transform either the ResourceT (coming from LevelDB) to Curses, or vis-versa, but I can't even get the 'resourcet' package to be acknowledged by `cable repl`
12:47:02 <nitnelave> ghc -c Test.hs
12:47:28 <nitnelave> with Test depending on module Core
12:47:30 <gspr> How can I set the include path (-i..) with GHC-mod?
12:47:41 <gspr> (or, rather, it's emacs mode)
12:47:44 <gspr> *its
12:49:57 <nitnelave> ok, I'm getting there
12:50:24 <nitnelave> So, from Core.hs, I made Core.hi and libHSCore-1.0-7.6.3.so
12:50:46 <nitnelave> from Test.hs (with Core.hi), I made Test.o
12:51:30 <nitnelave> but now I have some linker errors when trying to make Test from Test.o and libHSCore-1.0-7.6.3.so
12:51:59 <nitnelave> because I'm using other modules
12:52:06 <SrPx_> Does anyone know why this is happening? http://lpaste.net/117121
12:52:09 <geekosaur> yes, where is Test.hi?
12:52:26 <nitnelave> For example,
12:52:29 <nitnelave> (.text+0x5f45): undefined reference to `unixzm2zi6zi0zi1_SystemziPosixziIOziCommon_stdInput_closure'
12:52:48 <nitnelave> Well, I also have Test.hi in the same folder
12:52:52 <geekosaur> SrPx, you imported the type, but not its data constructors. try exporting Vec(..)
12:52:57 <gspr> SrPx_: You're not exporting the constructor
12:53:06 <SrPx_> How do I export it?
12:53:13 <geekosaur> well, now you are describing a different problem from the "Failed to load interface"
12:53:19 <SrPx_> And what is the "Vec" I'm exporting?
12:53:23 <ReinH> greymalkin: is resourcet in your cabal dependencies list?
12:53:24 <gspr> SrPx_: The type :)
12:53:30 <SrPx_> interesting
12:53:30 <nitnelave> Yes, I got past that because I found the Core.hi file
12:53:30 <geekosaur> [23 20:51] <geekosaur> SrPx_, you imported the type, but not its data constructors. try exporting V
12:53:33 <mauke> <geekosaur> SrPx, you imported the type, but not its data constructors. try exporting Vec(..)
12:53:34 <geekosaur> er
12:53:39 <nitnelave> It was generated along the .so
12:54:05 <geekosaur> and that missing reference is because you have decided to link explicitly and you only included HsCore
12:54:14 <geekosaur> you need libHsUnix as well
12:54:17 <joe9> "connect: timeout (Connection timed out)"  -- I am seeing these messages when using Network.HTTP.simpleHTTP even though I am checking on the Result and capturing the error. Just want to  check if anyone recommends any mechanism to capture such errors and re-submit/get the url.
12:54:19 <SrPx_> ah my bad his comment wasn't highlighted
12:54:28 <geekosaur> I missed the _
12:54:31 <geekosaur> the first time
12:54:45 <gspr> SrPx_: Having explicit exports, as you do, is good practice, but take note that you don't *have* to. It's perfectly reasonable to just put "module Foo where" without an export list to have everything exported when you're just playing around
12:54:45 <nitnelave> hmmm, where would I find this?
12:54:58 <SrPx_> ah cool (=
12:55:36 <geekosaur> nitnelave, if you are doing all of this manually for some reason then you'll have to consult ghc-pkg to find where the unix-2.6.0.1 package stores its library
12:55:38 <SrPx_> thanks
12:55:52 <geekosaur> if you're using ghc, then you want -packahe unix-2.6.0.1
12:55:56 <geekosaur> er
12:56:05 <geekosaur> -package unix-2.6.0.1
12:56:06 <nitnelave> ok, thanks
12:56:54 <joe9> I am making around a 1000 http requests to a single server. Am I still better off using Network.HTTP.simpleHTTP or is there something better out there?
12:57:08 <geekosaur> (I can mostly decode those symbols by eye; "unix-2.6.0.1" is what the "unixzm2zi6zi0zi1_" means)
12:57:10 <joe9> at 1 second intervals.
12:57:23 <bestdew55> http://hdxsx.com/malena-morgan-mia-malkova-girls-rule/
12:57:29 --- mode: ChanServ set +o geekosaur
12:57:40 --- mode: geekosaur set -o geekosaur
12:59:23 <nitnelave> one step closer
12:59:31 <nitnelave> I got an executable
12:59:55 <nitnelave> when I run it, I have to say LD_PRELOAD=/path/to/libHSCore.so
12:59:59 <nitnelave> which is expected
13:00:37 <nitnelave> but then, I get a weird segfault when trying to call methods from test
13:00:48 <nitnelave> frome Core, sorry
13:04:22 <nitnelave> geekosaur: any idea?
13:04:35 <geekosaur> no, sorry
13:05:02 <Denommus> managed to use web-routes-boomerang :-D
13:09:56 <Denommus> what does :- mean in a type signature?
13:10:16 <EvanR> looks like an operator
13:10:20 <EvanR> :t (:+)
13:10:21 <lambdabot> a -> a -> Complex a
13:10:34 <EvanR> :t (:~:)
13:10:35 <lambdabot> Not in scope: data constructor ‚Äò:~:‚Äô
13:10:35 <Denommus> EvanR: yes, it's a type operator
13:10:44 <Denommus> EvanR: but what does it mean?
13:10:48 <EvanR> so you need to find the definition
13:10:50 <Denommus> :i (:-)
13:11:28 <Denommus> EvanR: :t (:-) gives me a -> b -> a :- b, which doesn't tell me anything
13:11:48 <EvanR> yes just as :+ is the constructor for complex numbers
13:12:01 <EvanR> look up the type (:-)
13:12:50 <EvanR> http://hackage.haskell.org/package/boomerang-1.0.1/docs/Text-Boomerang-HStack.html#t::-45-
13:13:03 <glguy> Denommus: It means that someone declared a type (:-) with a constructor (:-)
13:13:05 <glguy> that's all it means
13:13:06 <EvanR> heterogenous stack
13:13:19 <EvanR> in this case its also the name of the type
13:13:46 <Denommus> ah
13:14:32 <gcganley> is there a way to browse threw git history backwards. so eariest date to newest date. i want to look at some libraries such as lens and see what desicions they made along the way
13:14:56 <Peaker> gcganley: git log, then press <end> and navigate up? :)
13:15:54 <quchen> Maybe the manpage has a section about reversing the output named "--reverse".
13:16:17 <indiagreen> gcganley: I just use QGit, it's not terminal-based but still convenient
13:16:43 <gcganley> indiagreen: what platforms does it run on?
13:16:55 <gcganley> s/platforms/platform(s)
13:17:24 <gcganley> i was more looking for the code they changed
13:17:56 <indiagreen> Linux, Windows, don't know about OS X
13:18:03 <indiagreen> there's a lot of Git viewers
13:18:10 <indiagreen> one is even bundled with Git itself
13:18:14 <indiagreen> ‚Äúgitk‚Äù, I think
13:22:47 <Denommus> ok, can web-routes-boomerang handle multiple representations for the same route?
13:29:58 <athan_> Do people often wrap applications in a reader monad, just to give environment variables / settings?
13:32:33 <greymalkin> ReinH: Yes. I was able to get to it using `cabal exec ghci` rather than `cabal repl`
13:33:09 <greymalkin> But I still don't know how to transform UI.NCurses to live under MonadResource
13:33:11 <EvanR> athan_: well env vars are available in IO
13:33:31 <athan_> EvanR: I'm just talking about general configuration for users
13:33:31 <Peaker> athan_: I usually do
13:33:38 <athan_> right on :)
13:33:45 * athan_ is still getting used to it
13:33:59 <EvanR> you can also put IORefs or MVars in the reader
13:34:01 <Peaker> I also use a custom Writer (transformers' Writer leaks memory!) for stuff that propagates the other way around
13:34:28 <EvanR> leaks?
13:34:28 <sinelaw> Peaker, did you submit a patch / proprosal on how to fix it?
13:34:36 <sinelaw> *proposal
13:35:20 <gcganley> sinelaw: s/proprosal/proposal
13:36:01 <gcganley> i cat remember which but there is a channel that shouts at you if you use the *fixedword as the only word
13:36:08 <gcganley> s/cat/cant
13:36:15 <sinelaw> *can't
13:36:26 <gcganley> sinelaw: :'()
13:36:34 <gcganley> sometimes i hat smartparens
13:36:39 <gcganley> s/hat/hate
13:36:42 <gcganley> man im tired....
13:36:45 <Peaker> sinelaw: I didn't, others did
13:36:49 <Peaker> sinelaw: there was a big discussion about it
13:37:05 <Peaker> EvanR: Yeah, Writer is like doing a foldr where you should use a foldl or vice-versa
13:37:13 <Peaker> EvanR: well, at least WriterT is
13:37:14 <sinelaw> gcganley, no worries I'll imagine that's a monkey or something
13:37:50 <Peaker> EvanR: because:  WriterT's implementation of (>>=) necessarily has to remember the left-side monoid result for the whole duration of the right-hand-action, so it can eventually mappend the two
13:38:02 <Fuco> gcganley: heh, I have planned to write ERC support to somehow disable the pairing :D (e.g. after : or - etc). Never got to it as I don't use ERC
13:38:12 <Peaker> so basically every (>>=) in WriterT leaks the accumulated monoid of the left-arg of >>=
13:38:22 <Peaker> which is nuts!
13:38:43 <EvanR> i remember thinking through writer at some point and wondering about this, but i was assured laziness came to the rescue again somehow
13:38:48 <Peaker> instead, you can use a (Monoid w => StateT w) with tell = modify . mappend
13:38:53 <gcganley> Fuco: did you write SP?
13:39:09 <Peaker> EvanR: With Writer, it might. With WriterT (of strict monads like IO, at least) it cannot
13:39:11 <gcganley> or just user
13:39:20 <Fuco> gcganley: I wrote it
13:39:27 <gcganley> Fuco: no shut
13:39:29 <glguy> MonadLib's WriterT's implementation has a strict accumulated value
13:39:31 <gcganley> s/shut/shit
13:39:52 <gcganley> Fuco: what do you use for IRC if you dont use ERC
13:39:54 <Peaker> so WriterT-via-StateT is better, but to implement "listen", "censor", etc, you have to revert back to the Writer approach (remember the left-hand monoid and run the right-hand one with mempty) but then you take this memory only where you must, instead of every bind
13:40:00 <dfeuer> Does anyone know of a test suite I could use to make sure my implementations of foldl' and foldr' have the right strictness properties?
13:40:04 <Peaker> glguy: that doesn't solve the issue I described above
13:40:30 <Fuco> gcganley: irssi :D  and damn my internet has delay
13:40:33 <EvanR> yurg low level stuff like this sucks
13:40:40 <EvanR> especially for stdlib-like contraptions
13:40:43 <gcganley> dfeuer: arent there stictness profilers out there?
13:40:49 <Peaker> glguy: it still leaks every >>=
13:40:59 <dfeuer> gcganley, no idea. I basically need QuickCheck properties for strictness.
13:41:43 <Peaker> glguy: I was shocked to discover this with a stack overflow when using strict-WriterT, and debugging it thoroughly -- and it's inherent in the tuple-return approach
13:41:52 <dfeuer> gcganley, and then there's the fun question of whether foldl' f z xs should or shouldn't be strict in z.
13:42:22 <Peaker> dfeuer: probably shouldn't, because it can only harm, never help
13:43:00 <gcganley> Fuco: why not use an emacs irc client. dont like ERC much? or do you not use emacs anymore
13:43:45 <dfeuer> Peaker, okay, so about them QuickCheck properties ....
13:43:45 <Fuco> gcganley: well, mostly because I like irssi. I've tried erc and circe and both didn't work as I wanted. I use emacs for mostly everything else though
13:44:02 <EvanR> Peaker: what about RWS/T
13:44:09 <jonazzzz> anyone knows how i can get the size of a IO [Int] list?
13:44:30 <dfeuer> They couldn't be normal properties even, I guess. They'd need that exception stuff. I don't even understand the basic stuff.
13:44:55 <Peaker> EvanR: broken too :(
13:45:12 <EvanR> jonazzzz: well thats not a list, its an IO command
13:45:18 <EvanR> or do you mean [IO [Int]]
13:45:31 <glguy> jonazzzz: IO [Int] isn't a list, it's like asking "How many files are in the ls command"
13:45:32 <gcganley> Fuco: :/ i've migrated all my clients to emacs. i even run everything in term or shell
13:45:37 <glguy> What're you trying to do?
13:45:43 <jonazzzz> hmm one moment
13:46:10 <gcganley> :t lift
13:46:11 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
13:46:15 <EvanR> it has a size of 1. ONE IO [Int], ha ha ha
13:46:31 <Peaker> EvanR: look at impl of >>= in http://hackage.haskell.org/package/transformers-0.4.2.0/docs/src/Control-Monad-Trans-RWS-Strict.html#RWST
13:46:48 <gcganley> EvanR: *crickets*
13:46:54 <Peaker> reference to 'w' must be kept alive throughout "runRWST (k a) r s'" :-(
13:47:19 <EvanR> lazy version of the transformer works?
13:47:32 <Peaker> fixing this bug requires breaking transformers' API -- because Haskell libraries tend to expose implementation details like the data constructors of all the transformers! Bad idea!
13:47:45 <jonazzzz> nvm got it :D
13:47:46 <gcganley> Fuco: do you use term or other terminal emulators in emacs or do you use a dedicated one like urxt
13:47:53 <Peaker> EvanR: Nope, all WriterT's in hackage that I know of are broken for strict monads being transformed
13:48:11 <EvanR> how many transformer libs has it been now >:
13:48:40 <Peaker> well: MonadLib, transformers :)  You could count mtl though it's just a wrapper
13:48:51 <gcganley> I'll wait for one to rule them all before i get into transformers. I understand their motives and theory but i REALLY havent been able to grok them
13:49:05 <EvanR> ive avoided them
13:49:13 <Peaker> gcganley: wait for one what?
13:49:24 <glguy> Peaker: MonadLib doesn't expose the constructor
13:49:32 <gcganley> Peaker: supreme monad transformer package
13:49:41 <Peaker> glguy: ah, that's good, it can probably fix the bug then without breaking the API, yay!
13:49:43 <glguy> But I see what you mean about using it on stricts monads
13:49:51 <zipper> How can I write this elegantly in a let. `if value >= 3 then value = 3 else value`
13:50:09 <Peaker> zipper: min 3 value  ?
13:50:23 <glguy> It'd be a shame to break it for lazy contexts where it's what you want
13:50:27 <gcganley> :t min
13:50:28 <lambdabot> Ord a => a -> a -> a
13:50:28 <zipper> Peaker: What? I don't know that one.
13:50:29 <zipper> :t min
13:50:29 <lambdabot> Ord a => a -> a -> a
13:50:30 <glguy> when you can get the other behavior using state already
13:50:32 <gcganley> min 3 4
13:50:41 <Peaker> glguy: you mean - optimize for CSE?
13:50:42 <gcganley> :> min 3 4
13:50:46 <gcganley> > min 34
13:50:48 <lambdabot>  <Integer -> Integer>
13:50:59 <Peaker> glguy: or just allow less data-dependencies?
13:51:01 <gcganley> i forget how to eval in lambdabot... im sad
13:51:10 <sinelaw> > min 3 4
13:51:12 <lambdabot>  3
13:51:15 <sinelaw> gcganley, you were doing it right
13:51:25 <zipper> > min 3 4
13:51:26 <sinelaw> lambdabot was telling you that "min 34" is a function
13:51:27 <lambdabot>  3
13:51:53 <Peaker> glguy: you can get it via StateT but it isn't trivial (You need to implement tell, censor, etc via internal runStateT with mempty and then mappend)
13:52:09 <Peaker> glguy: and I think the extra-lazy WriterT behavior is quite rarely useful
13:52:19 <zipper> Peaker: I don't think that that's what I want. Though I don't really get why I'd need min.
13:52:31 <zipper> I want to stop a value from going beyong 3
13:52:35 <zipper> *beyond
13:52:44 <Peaker> zipper: if value >= 3 then 3 else value   is the same as   min value 3
13:53:00 <EvanR> so you can fix this by changing the internal form of the rwst to basically have two states, one is a monoid
13:53:06 <Peaker> zipper: that's why you take the minimum between value and 3
13:53:18 <Peaker> EvanR: yeah
13:53:35 <zipper> Peaker: You don't say. WOW
13:53:37 <zipper> > min 2 3
13:53:38 <Peaker> EvanR: and a bit of trickery in listen/tell that yields the Writer behavior again
13:53:39 <lambdabot>  2
13:53:51 <zipper> Peaker: Wow yeah that works
13:53:55 <gcganley> :k WriterT
13:53:56 <lambdabot> * -> (* -> *) -> * -> *
13:53:57 <EvanR> and at this point seems like theres something non-theoretically-pleasing about transformers, since you could have concocted something yourself
13:53:59 <Peaker> @src min
13:53:59 <lambdabot> min x y = if x <= y then x else y
13:54:06 <Peaker> zipper: look how 'min' is implemented
13:54:30 <Peaker> EvanR: you can implement all of hackage yourself though? :)
13:54:51 <zipper> Peaker: I wonder how I didn't know about it. Crazy handy.
13:55:13 <Peaker> zipper: if you want to cap a value between low and high, you can use:  max low . min high
13:55:20 <EvanR> maybe instead of four "universal" transformers there should be a DSL for forming monads in a more explicit way, with more control
13:55:41 <Peaker> EvanR: I think that'd make sense if there was a cartesian explosion
13:55:59 <gcganley> zipper: there are a ton of helper functions in the prelude that will help you in youre writing of haskell
13:56:05 <Peaker> EvanR: just need to fix WriterT to the correct way, and anyone who wants the "extra-lazy" Writer with the current behavior can just use tuples directly or implement their own (I doubt anyone would need it?)
13:56:22 <EvanR> i guess thats the most pragmatic
13:56:37 <sinelaw> zipper, also, one way you can find out about these functions is by using hoogle either on the web or with lambdabot
13:57:05 <Peaker> EvanR: I spent hours debugging the WriterT leak/stack-overflow in my project, to find that the mailing list was buzzing with this exact bug at around the same time!
13:57:05 <Luke> Hey guys i'm getting type binding errors w/ this; http://lpaste.net/5802760318820024320
13:57:10 <sinelaw> if x > 3 then x else 3 -- this has type like Int -> Int -> Int
13:57:12 <sinelaw> so
13:57:16 <Luke> having `b` in the instance is breaking things
13:57:19 <sinelaw> @hoogle Int -> Int -> Int
13:57:21 <lambdabot> Test.QuickCheck.State computeSize :: State -> Int -> Int -> Int
13:57:21 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
13:57:21 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
13:57:23 <zipper> sinelaw: I couldn't have found this with hoogle because so many functions can take an int and return an int
13:57:49 <sinelaw> zipper, yeah that's not very useful - on the website you can click on "base"on the left menu
13:58:05 <EvanR> Peaker: just checking, in the case of a lazy transformee, this behavior isnt bad ?
13:58:08 <zipper> :t max 3 4
13:58:09 <lambdabot> (Ord a, Num a) => a
13:58:14 <zipper> > max 3 4
13:58:14 <EvanR> or its just as bad but in slower motion
13:58:15 <lambdabot>  4
13:58:23 <athan_> Say I'm using the reader monad in an expression. If I dive in another layer of a different monad, how would I use `ask`?
13:58:41 <athan_> where this other monad is part of the result, not in some monad transformer
13:59:00 <Luke> EvanR: can you take a look at my paste when you get a sec?
13:59:07 <Peaker> EvanR: I think it may actually be desirable. Consider: Writer itself (WriterT Identity). The evaluation order of >>= isn't really left-to-right, but you lazily pick whatever you need. If you only need something from the right side you can do that, without computing left side. With StateT you must compute left side
13:59:50 <Peaker> EvanR: the problem with the fix is that it creates a false data dependency between left computation and right computation.
14:00:10 <tolt> When using a double I occasionaly see it printed as "7.17e-2" instead of 0.0717 is there any way to fix that?
14:00:13 <EvanR> athan_: you can, youd need to pass the context into the subcomputation, or run a new ReaderT over that subcomputation
14:00:17 <EvanR> you cant*
14:01:02 <EvanR> Luke: b is not defined in that class
14:01:04 <athan_> EvanR: Crud, that's what I need, though! Thanks :)
14:01:14 <Peaker> athan_: Monads don't compose, so if you have:  Monad1 (Monad2 (Monad3 a))  then you don't automatically get (>>=) for the composition Monad1.Monad2.Monad3
14:01:21 <Luke> EvanR: can it wait until the instance defines it?
14:01:43 <Luke> EvanR: clearly not since the instance complains of rigid binding
14:01:49 <athan_> Peaker: Where (>>= :: Monad1 a -> (a -> Monad b) ...), right?
14:01:52 <EvanR> Luke: no. you have to specify what b means in that class. for example, with another  parameter
14:02:00 <athan_> s/Monad /Monad1 /
14:02:11 <Peaker> athan_: You only have: (>>=) :: Monad1 a -> (a -> Monad1 b) -> Monad1 b
14:02:17 <Luke> EvanR: could I just describe b as a class?
14:02:18 <athan_> Ahh, perfect
14:02:31 <athan_> Peaker: Thank you :)
14:02:38 <Peaker> athan_: you don't automatically get: (>>=) :: Monad1 (Monad2 (Monad3 a))) -> (a -> Monad1 (Monad2 (Monad3 b))) -> Monad1 (Monad2 (Monad3 b)))
14:03:01 <athan_> ahh wow, okay
14:03:05 <athan_> that makes a lot of sense
14:03:08 <Peaker> athan_: but you do automatically get:  something like (<*>) :: Monad1 (Monad2 (Monad3 (a->b))) -> Monad1 (Monad2 (Monad3 a)) -> Monad1 (Monad2 (Monad3 b))
14:03:25 <athan_> wait, wat
14:03:28 <athan_> how? Peaker?
14:03:31 <simon> Just (Just (Just 5)) >>= \x -> ...here, x is Just (Just 5)...
14:03:39 <Peaker> athan_: that's why Monad transformers are needed, but Applicative transformers aren't. because Monads don't compose and applicatives do
14:03:42 <EvanR> Luke: it looks like youre trying to define a class of things that "have an id of some sort", i know of a few ways to do this, but theres probably a simpler way to accomplish what you want.
14:04:01 * athan_ needs to rethink his life again
14:04:04 <Peaker> athan_: Applicative can be defined via  (pure, liftA2)  (simpler for our purposes than (pure, <*>)
14:04:05 <Peaker> )
14:04:14 <Peaker> @type pure . pure . pure
14:04:15 <lambdabot> (Applicative f2, Applicative f1, Applicative f) => a -> f (f1 (f2 a))
14:04:22 <Peaker> @type liftA2 . liftA2 . liftA2
14:04:23 <Luke> EvanR: exactly. All I know is that it's an (Ord, Num) =>
14:04:23 <lambdabot> (Applicative f2, Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 (f2 a)) -> f (f1 (f2 b)) -> f (f1 (f2 c))
14:05:04 <Peaker> athan_: so via simple composition like that: we can treat: (Monad1 . Monad2 . Monad3) as if it was an Applicative directly
14:05:17 <Peaker> athan_: if you're worried about liftA2 vs (<*>):
14:05:21 <Peaker> @type liftA2 ($)
14:05:22 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
14:05:23 <EvanR> Luke: starting with what it seems youre eventually going to do with the ids, which is print them, youre going to need Show not Num
14:05:23 <athan_> simon, Peaker : Thank you, hopefully I'll catch on soon :)
14:05:34 <simon> athan_, no probs. :)
14:05:48 <Luke> EvanR: no i use them for addition etc
14:06:05 <EvanR> Luke: ok, then Show in addition to Num and Ord
14:06:12 <Luke> yeah
14:06:20 <Peaker> athan_: http://hackage.haskell.org/package/TypeCompose-0.9.10/docs/src/Control-Compose.html#%3A.  implements an actual type-compose operator :.   and it has an instance (Applicative f, Applicative g) => Applicative (f :. g)
14:06:40 <Peaker> athan_: type (f :. g) a ~= f (g a)
14:06:46 <EvanR> Luke: next, since you want the IO routine f to be polymorphic too, transfer the relevant constraints to the signature of f too
14:06:50 <Peaker> so Monad1 (Monad2 (Monad3 a)) ~= (Monad1 :. Monad2 :. Monad3) a
14:07:02 <Luke> EvanR: right - just missed that
14:07:17 <EvanR> Luke: and make f take the sequence id instead of the sequence id-able thing
14:07:22 <Luke> EvanR: really a is parameterized by b
14:07:32 <EvanR> yes ill get to that
14:07:40 <Peaker> athan_: so, the fact you can do this Applicative derivation of type-compositions is nice, but for Monads you can't, because Monads suck and don't compose :P  so that's why we need Monad transformers -- writing ad-hoc composition for each and every monad we have
14:07:42 <EvanR> but im going over the simpler way for now
14:07:57 <Peaker> (since a general composition is not possible)
14:09:16 <EvanR> Luke: now when you use f somewhere in your project, you can use it even on heterogenous collections as long as you can produce some Show Num from them
14:09:41 <EvanR> this is one way to break out of the oop thinking
14:11:30 <EvanR> now sometimes you really do want to implement some interface for *two* types, where they are somehow related through the interface. like vectors over some field, and the elements of the field itself
14:12:33 <Luke> hmm ok let me try that
14:13:05 <Luke> EvanR: here's why I'm doing this: this is an io-streams transformer so it needs to preserve the outer type
14:13:20 <EvanR> in this case you can use associated type families or something similar. but stuff like this would better be suited, i think, to libraries and not a way to structure an applications guts
14:14:57 <Luke> EvanR: http://lpaste.net/7047475526629326848 here's more context from the code
14:15:02 <EvanR> ignoring IO for a second, seems like a stream transformer shouldnt worry about the output type?
14:15:17 <EvanR> i mean it would be like a -> b, not a -> (a,b)
14:15:23 <greymalkin> Is there a way to transform a monad which is in a hidden module? Only the monad type is exported
14:17:12 <EvanR> Luke: whats this, a filter that uses IO ?
14:18:17 <Luke> EvanR: just inspects the stream
14:19:07 <EvanR> well, its returning a newly constructed stream for some reason
14:20:20 <Luke> EvanR: it should
14:20:32 <Luke> that's the way stream transforms work in io-streams
14:21:02 <EvanR> have you looked at Iteratees?
14:21:15 <Luke> yes
14:21:40 <Peaker> greymalkin: of course, a transformer doesn't care about impl. details of the underlying monad
14:22:16 <EvanR> io-streams looks really operational
14:22:23 <Luke> what do you mean operational?
14:22:44 <EvanR> i mean, the code is reading like java
14:22:57 <Luke> you mean imperative?
14:22:58 <EvanR> what does your function do?
14:23:11 <Luke> checks the stream sequence ids
14:23:13 <greymalkin> Is there a really good tutorial on getting two IO-based monads to play well together (esp. UI.NCurses.Curses using ResourceT)?
14:23:16 <EvanR> what does check mean?
14:23:28 <Luke> do some math to see if it's valid
14:23:37 <Luke> i.e. monotonically incrementing
14:23:39 <EvanR> if its valid, it passes through, and if not?
14:23:47 <Luke> if not it runs the fault handler
14:23:56 <EvanR> which is like an exception?
14:24:01 <Luke> could be
14:24:03 <Luke> yeah
14:25:46 <Peaker> I wonder if I'm the first to invent this nice way to define record field lenses manually:  someField f Record{..} = f _someField <&> \_someField -> Record{..}
14:26:30 <Peaker> RecordWildCards are useful!
14:28:46 <EvanR> Luke: whats the unit of work in this stream, bytes? messages?
14:28:48 <EvanR> lines?
14:29:03 <Luke> messages
14:29:13 <Luke> well from this point of view it's just things with sequence ids
14:30:33 <sinelaw> Peaker, can you show why that's a lens? I'm not all too familiar with them yet
14:30:52 <Peaker> (<&>) = flip fmap
14:30:58 <Luke> EvanR: Ah I got it. I needed the MultiParamTypeClasses extension to get the relationship
14:31:06 <bernalex> :t (<&>)
14:31:07 <lambdabot> Functor f => f a -> (a -> b) -> f b
14:31:27 <EvanR> Luke: for what you think you need them for, i would go with type families
14:31:31 <Peaker> so: someField f Record{..}   to be a lens, needs to apply 'f' to 1 thing inside Record{..}, and then re-wrap the result with Record, that's it
14:31:58 <Peaker> sinelaw: if you remember how traversals work, then lenses are just traversals that are known to be of exactly 1 thing. This is expressed in the types by them requiring just Functor and not Applicative
14:32:04 <Luke> EvanR: implying you don't think I need multi param type classes?
14:32:05 <EvanR> Luke: or i would write the code for InputStream Message and not worry about it
14:32:11 <EvanR> no i really dont
14:32:54 <Peaker> f _someField <&> \_someField -> Record{..}   <--  f is applied to exactly 1 thing in there (_someField), and the result is fmap'd to be rewrapped via lambda doing name-shadowing and then {..} building a new record with the shadowed field
14:33:18 <Peaker> <&> lets me avoid parenthesis around the lambda, which fmap or <$> would require
14:33:22 <sinelaw> Peaker, _someField (including the underscore) is the name of that field?
14:33:27 <Peaker> sinelaw: yeah
14:33:30 <Luke> EvanR: what do you think i should be doing?
14:33:38 <Peaker> sinelaw: the convention is to name your field with _ prefix and the lens without the prefix
14:33:47 <sinelaw> ah
14:33:47 <EvanR> if you have several message types in mind right now, go with a sum type, otherwise just dont worry about type class polymorphism
14:34:10 <Luke> EvanR: I will release this as a library
14:34:22 <Luke> any (Ord, Num) can be used as a seq id
14:35:46 <EvanR> seems like a weird level to do this generically
14:35:58 <EvanR> or attempt to
14:36:17 <Luke> EvanR: I was considering that
14:36:49 <Luke> EvanR: pushing it down a level and using pure functions is also an option which it sounds like you're leaning towards
14:37:39 <EvanR> as an example of how it can seem weird, first consider a "generic" function which requires a type class. f :: Num a => a -> IO (), and the body of the function happens to use the negate method
14:37:57 <EvanR> obviously this thing needs to be able to negate the argument and do some IO
14:37:58 <pxqr> is it possible to show what exactly the :kind! command do step by step?
14:38:09 <pxqr> i mean rules fired
14:38:47 <EvanR> so next remember that type classes are like sugar for passing in the method implementations too, f :: a -> (a -> a) -> IO (), where the second argument is the negate operation on a
14:39:14 <Luke> hmm
14:39:24 <EvanR> the f can still work, and so it applies the function to the first argument. but its better if whoever is using f does it for you
14:40:01 <EvanR> and i messed up because the result of negate is still some unknown type
14:40:34 <EvanR> rewind, imagine i used Show instead of Num. f :: a -> (a -> String) -> IO ()
14:40:41 <gspr> How can I set the include path (-i..) with GHC-mod's emacs integration? At present it fails at all imports that are part of the project I'm currently working on.
14:41:05 <EvanR> now instead of passing in the to-string operation, you just pass in the string instead, f :: String -> IO ()
14:41:19 <EvanR> now f is more flexible, and can be used in more places
14:41:32 <EvanR> including a collection which gets its Stringification in different ways
14:41:34 <Luke> gspr:    (setq  ghc-ghc-options '("-isrc"))
14:42:05 <Luke> EvanR: yeah i hear you. I'm definitely thinking this is too complex
14:42:13 <Luke> EvanR: and you're saying it's more restrictive as well
14:43:06 <EvanR> currently, what are the various types you are using which satisfy Ord and Num ?
14:43:09 <Luke> that makes sense. let me mess w/ moving the abstraction level this check takes place
14:43:18 <EvanR> Int?
14:43:19 <Luke> EvanR: Int, Word32, Word16, etc
14:43:20 <Luke> yeah
14:43:45 <EvanR> so in this case, maybe just agree that the check works with Integers, and the clients of the code need to provide an Integer view of the message
14:44:15 <jonazzzz> can anyone help me with threading, referring to this article: https://www.haskell.org/haskellwiki/Gtk2Hs/Tutorials/ThreadedGUIs how would i just stop the forkIO instance, instead of the whole program?
14:45:06 <Luke> EvanR: yeah thats a good idea. Much simpler
14:45:08 <Luke> thanks a lot
14:45:18 <Luke> thanks for bearing with me to get that to compile
14:46:22 <gspr> Luke: Thanks!
14:46:23 <Luke> jonazzzz: forkIO returns a ThreadID which you can use killThread on
14:46:27 <Luke> gspr: np
14:47:09 <Luke> jonazzzz: http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent.html
14:47:11 <jonazzzz> luke ok thanks i'll check it out
14:47:14 <Luke> jonazzzz: np
14:48:03 <EvanR> note that killThread uses async exceptions, which requires (???) to be sure youre ok
14:48:30 <greymalkin> I need a tutorial on monad transforming, but not with pure monads (Maybe, etc); http://pastebin.com/0FWWwHSU
14:49:22 <EvanR> whats wrong with your runCurses
14:49:30 <gspr> How can I do fixed-width parsing with Attoparsec? Let's say, for example, that I want to parse into an Integer the following: "16 Word8s, starting with 0 or more ASCII spaces, followed by at least 1 ASCII decimal digit, *so that the total is 16 bytes precisely*". How do I deal with consuming precisely 16 bytes?
14:49:44 <greymalkin> it's the runResourceT inside the runCurses.
14:49:54 <gspr> (This is probably a lame question... I know well how to do it without the fixed width requirement)
14:50:03 <EvanR> gspr: you can parse one byte at a time
14:50:08 <greymalkin> I want to change so that I can intersperse screen and database queries.
14:50:09 <EvanR> or two
14:50:16 <gspr> EvanR: But then I can't reuse the Decimal parser, right?
14:50:22 <gspr> *decimal
14:50:34 <gspr> (the one that comes with attoparsec)
14:50:36 <EvanR> its youre expecting a decimal string next, dont get a byte
14:50:38 <EvanR> if*
14:50:43 <greymalkin> If I do all my real IO in nested runResourceT blocks, then I get extreme performance drops.
14:51:07 <greymalkin> (like, from 0.11 ms to 4 seconds)
14:51:20 <EvanR> what is runResourceT?
14:51:21 <gspr> EvanR: Hmm... I'm being slow... could you elaborate?
14:51:40 <greymalkin> MonadBaseControl IO m => ResourceT m a -> m a
14:52:04 <EvanR> gspr: to start, replicateM 16 word8
14:52:11 <EvanR> or whatever the one byte parser is called
14:52:38 <EvanR> ok reading your format description backwards now
14:52:46 <gspr> :)
14:52:50 <EvanR> start with skip spaces
14:52:58 <EvanR> get one digit
14:53:02 <EvanR> then get 16 word8s
14:53:08 <gspr> EvanR: Yep, but then I might be reading past 16 Word8s, no?
14:53:13 <EvanR> er wait
14:53:17 <gspr> suppose the input is 17 spaces
14:53:19 <gspr> then I should fail
14:53:29 <gspr> (or 16 spaces, for that matter, per my specification)
14:53:34 <EvanR> skipspaces, but use the one that tells you what you got, and you can count the spaces
14:53:35 <Luke> EvanR: I just remembered why I was trying to do all this at this abstraction level: I have a fan-in situation so handling the sequence ids at the channel level vs. the pure code underneath prevents me from having to keep track of some kind of (chan -> seq) mapping.
14:54:02 <gspr> EvanR: Oh, I haven't seen that one
14:54:20 <EvanR> gspr: takeWhile space, or something
14:55:03 <gspr> EvanR: Right. But that'll give be a Parser ByteString... so I'll have to run that inside my outer Parser, then?
14:55:13 <endiruna> is there some plugin that you would suggest for vim? i saw that there are several in the wiki.
14:55:23 <gspr> *give me
14:55:59 <akowalz> hello
14:56:02 <EvanR> gspr: no.. using a Parser ByteString with a <- gives you a ByteString
14:56:18 <EvanR> (if followed by another Parser of some sort)
14:57:01 <gspr> oh, of course, I'll just stay in the parser monad
14:57:02 <gspr> d'oh
14:57:03 <gspr> thanks :)
14:57:10 <EvanR> Luke: if you wanted like one agent to have one sequence to check one stream... then whats the issue with that
14:57:33 <Luke> that's what this is
14:57:40 <EvanR> so why do you need a mapping
14:57:56 <Luke> that's the alternative to scrapping this whole stream -level approach
14:58:12 <Luke> and just passing on responsibility of seq id checking to the consumer of this stream
14:58:31 <Luke> that's a separate issue from just hard coding the num type to Word32 or Int
14:59:40 <EvanR> youre saying you have several message channels in one stream multiplexed?
15:00:27 <Luke> yes
15:00:33 <nitnelave> anybody ever had issues with a haskell binary segfaulting when calling functions from a .so?
15:00:39 <EvanR> oh well move the demultiplexer earlier ;)
15:00:59 <Luke> that'd require the mapping i talked about to keep the streams sorted
15:01:17 <Luke> anyway it's not a problem, just reminded myself why I was doing this in the first place
15:01:47 <EvanR> well to me theres not much point in decomposing something into stream processors unless theres going to be real simple processors at each step
15:02:03 <EvanR> and enough to make each one simple enough to understand
15:02:03 <geekosaur> nitnelave, I might ask, how exactly are you calling these functions?
15:02:46 <nitnelave> oh, hi again!
15:03:07 <EvanR> demultiplex sounds like a first step, sending messages to their own dedicated continuation that doesnt have to muck with channel ids
15:03:13 <nitnelave> Well, I have those two module, Test and Core (with Test calling functions from Core)
15:03:27 <nitnelave> and if I compile them together they work fine
15:03:40 <Luke> EvanR: that's what this solution is
15:03:42 <nitnelave> so normal function calls
15:03:53 <nitnelave> but I want to make Core into a .so
15:03:55 <EvanR> are you reimplementing tcp?
15:03:59 <Luke> EvanR: haha no
15:04:16 <darkroom> hey so i have been seeing this written in alot of online texts but why is the Num class so bad?
15:05:02 <EvanR> refudiated, the Num class is perfect!
15:05:12 <darkroom> why?
15:05:23 <nitnelave> the program runs fine, until I have to call a function from the .so
15:05:28 <nitnelave> then it crashes
15:06:02 <SrPx> How do I understand Data.Vector.Unboxed.Mutable ? There is no constructor, I don't know how i create a new value, read, write... nothing I try works. I have no problems with the immutable version...
15:06:15 <EvanR> Num seems to be an informal basic interface to computer arithmetic, without division. good enough
15:06:19 <nitnelave> geekosaur: does that help?
15:07:01 <Peaker> ANN annotations add a lot to my build time
15:07:14 <Peaker> any way to tell hlint to avoid warning about certain things in certain modules without ANN?
15:08:23 <EvanR> darkroom: in Num and several other standard classes, you cant assert that really any laws are followed because of floats
15:08:36 <pnielsen> Thyme is the fastest time library, right (particular with regards to repeated calls to getCurrentTime)?
15:08:39 <glguy> You could put your ANN's in #ifdef HLINT like the rest of the stuff hlint can't deal with, at a minimum
15:09:10 <darkroom_> sorry laptop died
15:09:24 <SrPx> for example, I want to create a type, "Matrix", which wraps around it. I can't even write its signature. "data Matrix a s = Matrix { size :: (Int,Int), buffer :: s (MVector (PrimState s) a) }" ? I have no idea really. Why is it so obscure...
15:09:28 <geekosaur> not really; not enough information, certainly not enough to try to reproduce it locally, so nothing I can do
15:12:34 <gspr> EvanR: I'm being really slow now. Suppose i have a   takeWhile isSpace :: Parser ByteString. What if it contains more than the allowed number of spaces? If I fail my parser at this point, are these rewound?
15:13:06 <EvanR> gspr: in attoparsec, not automatically. you have to use try to rewind
15:13:28 <EvanR> so you can use try, takeWhile space, check the length, if greater then fail.
15:13:40 <EvanR> if greater than 14 or whatever
15:13:48 <gspr> the try documentation says: "This combinator is provided for compatibility with Parsec. attoparsec parsers always backtrack on failure. "
15:13:58 <EvanR> oh then i have it backwards
15:14:06 <gspr> Thanks anyway, that's perfect :)
15:14:21 <EvanR> you want it to fail completely in this case right
15:14:31 <gspr> yep
15:14:51 <EvanR> ok then the issue of backtracking doesnt matter ;)
15:15:07 <gspr> Oh, sorry, well, I'm writing a small sub-parser at the moment. I want
15:15:09 <gspr> oops
15:15:15 <gspr> I want *it* to fail, but not the parser that it's a part of
15:15:19 <gspr> so it needs to backtrack
15:15:47 <EvanR> so then <|>
15:16:15 <gspr> right, that makes sense
15:16:23 <nshepperd> SrPx: you probably want 'data Matrix v a = Matrix { size :: (Int,Int), buffer :: v a }'
15:16:59 <SrPx> that makes a lot of sense... let me think about it
15:18:04 <SrPx> nshepperd: but then how I'm supposed to access the functions of the type "v"? It will vary
15:18:08 <nshepperd> er, that should be 'data Matrix v s a' I guess for the state token
15:18:36 <nshepperd> SrPx: Data.Generic.Vector.Mutable has all the functions you need
15:19:31 <nshepperd> your newMatrix function would be something like :: (PrimMonad m, MVector v a) => (Int,Int) -> m (Matrix v (PrimMonad m) a)
15:20:04 <nshepperd> :: (PrimMonad m, MVector v a) => (Int,Int) -> m (Matrix v (PrimState m) a)
15:20:07 <nshepperd> rather
15:21:42 <SrPx> what the...
15:23:08 <jonazzzz> hi, what is the default value for a ThreadId ? because i want to keep a reference to it in my type, is it null or nil or what is this in haskell?
15:23:35 <HeladoDeBrownie> jonazzzz, what do you mean by "default"?
15:23:45 <glguy> Nope. You can store a "Maybe ThreadId", however.
15:23:48 <HeladoDeBrownie> jonazzzz, Haskell has no universal null analogous with that of Java and similar languages.
15:24:04 <jonazzzz> oh ok a maybe seems alright than ^^ thanks
15:24:10 <jonazzzz> then*
15:24:23 <EvanR> remember to initialize your record fields ;)
15:24:52 <EvanR> b (Foo {a = 3}) *crasshhh*
15:25:22 <EvanR> they are by default undefined!
15:28:03 <nshepperd> SrPx: oh right, I think it's weird and horrible that they use the same name for the class MVector and the type constructor Unboxed.Mutable.MVector
15:28:26 <nshepperd> but I'm referring to the class in the type signature above
15:28:49 <nshepperd> the PrimMonad stuff is just making it work for either ST or IO
15:29:30 <nshepperd> you could do newMatrix :: (MVector v a) => (Int,Int) -> ST s (Matrix v s a)
15:29:59 <nshepperd> if you don't really care about IO
15:32:27 <SrPx> I can't get it
15:34:03 <nshepperd> oh :(
15:34:12 * nshepperd gotta flee
15:34:21 <SrPx> okaay
15:34:23 <SrPx> thank you!
15:40:20 <endiruna> i have trouble understanding how it works here fibs = 1:1 [a+b | (a,b) <- zip fibs (tail fibs)]. perhaps someone
15:40:29 <endiruna> could explain what happens
15:41:03 <EvanR> > let fibs = 1:1 [a+b | (a,b) <- zip fibs (tail fibs)] in fibs
15:41:04 <lambdabot>  No instance for (GHC.Show.Show t0)
15:41:04 <lambdabot>    arising from a use of ‚ÄòM472327938930487217724829.show_M4723279389304872177...
15:41:04 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
15:41:38 <endiruna> i saw it on this talk https://www.youtube.com/watch?v=apBWkBDVlow
15:42:01 <EvanR> well, zip fibs (tail fibs) is pairing each element of fibs with the one before it
15:42:16 <EvanR> does that part make sense
15:42:48 <endiruna> somehow i do not understand how the lazy evaluations works here
15:43:13 <EvanR> > let fibs = 1:1: [a+b | (a,b) <- zip fibs (tail fibs)] in fibs
15:43:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:43:17 <EvanR> repaired ;)
15:43:49 <EvanR> endiruna: in your mind, try to evaluate fibs !! 0, then fibs !! 1.
15:44:05 <EvanR> if that goes ok, try fibs !! 2
15:44:09 <greymalkin> Can I transform a monad that doesn't have a `..T` form?
15:44:22 <Axman6> ..T?
15:44:25 <endiruna> what is the difference between the two lines you wrote?
15:44:37 <EvanR> endiruna: a second colon by the 1:1
15:44:50 <endiruna> :D right
15:45:00 <greymalkin> There is a monad called 'Curses a', but no CursesT for transforming.
15:45:00 <endiruna> sorry for copying it wrong
15:45:12 <Axman6> it might be a little clearer without the list comprehension
15:45:27 <Axman6> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
15:45:41 <Axman6> fibs = 1 : 1 : zipWith (+) (1:1:...) (tail (1:1:...))
15:45:54 <Axman6> fibs = 1 : 1 : zipWith (+) (1:1:...) (1:...)
15:46:19 <Axman6> fibs = 1 : 1 : 2: zipWith (+) (1:2:...) (2:...)
15:46:36 <Axman6> fibs = 1 : 1 : 2: 3: zipWith (+) (2:3:...) (3:...)
15:46:54 <Axman6> fibs = 1 : 1 : 2: 3: 5: zipWith (+) (3:5:...) (5:...)
15:46:57 <Peaker> fibs' = map fst $ iterate (\(cur,next)->(next,cur+next)) (0,1)
15:47:18 <Peaker> @pl fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
15:47:18 <lambdabot> fibs = fix ((1 :) . (1 :) . ap (zipWith (+)) tail)
15:47:30 <endiruna> what does 'in fibs' do in the iteration?
15:47:43 <endiruna> *in the comprehension
15:47:56 <EvanR> thats part of the let expression
15:48:02 <Axman6> and so on. does that help at all endiruna? the ... in each expression shows what's going to be computed yet, but we don't know the value yet because fibs hasn't been evaluated that far yet
15:48:04 <EvanR> > let x = 3 inx
15:48:05 <lambdabot>  not an expression: ‚Äòlet x = 3 inx‚Äô
15:48:09 <EvanR> > let x = 3 in x
15:48:10 <lambdabot>  3
15:48:17 <jonazzzz> how do i convert an Int to a String?
15:48:22 <Axman6> > let x = 4 in x -- x (or 4) is just the value rteturned by the let expression
15:48:23 <lambdabot>  4
15:48:24 <EvanR> show
15:48:27 <Axman6> jonazzzz: show
15:48:33 <jonazzzz> ofc! i was doing read haha
15:48:35 <Axman6> returned*
15:48:54 <Axman6> jonazzzz: ghci is a valuable tool when trying to figure out what's wrong ;)
15:48:59 <Axman6> :t read
15:49:00 <lambdabot> Read a => String -> a
15:49:05 <Axman6> :t show
15:49:06 <lambdabot> Show a => a -> String
15:49:29 <EvanR> :t show . read
15:49:30 <lambdabot> String -> String
15:49:38 <EvanR> :t read . show
15:49:39 <lambdabot> (Show a, Read c) => a -> c
15:49:41 <nitnelave> > let 3 = 4 in let x = 3 in x
15:49:42 <lambdabot>  3
15:50:09 <nitnelave> > let 3 = 4 in let x = 3 in x == 4
15:50:11 <lambdabot>  False
15:50:15 <Axman6> > let !3 = 4 in let x = 3 in x
15:50:17 <lambdabot>  *Exception: <interactive>:3:5-10: Non-exhaustive patterns in pattern binding
15:50:56 <Axman6> let 3 = 4 is a pattern match btw, not a redefinition of 3
15:53:04 <EvanR> or very small values of 4
15:54:25 <danilo2> Hello! I was looking into GHC code and found following sentence "NOTE: we make the n_loc field strict to eliminate some potential (and real!) space leaks, due to the fact that we don't look at the SrcLoc in a Name all that often." Why non-strict variables can introduce space leaks?
15:54:28 <akowalz> hi all, I'm trying to use Parsec but ghc can't seem to find it.  I ran "cabal install parsec" and it worked.  Any ideas what's going wrong? This is my first time using Cabal
15:54:53 <akowalz> error is "Could not find module `Text.ParserCombinators.Parsec`"
15:55:56 <Cale> danilo2: Because code for computing something can be larger in terms of space than the final result.
15:56:03 <pavonia> akowalz: What does "ghc-pkg list parsec" tell you?
15:57:05 <Cale> danilo2: Especially when the result is something like a pair of Integer values.
15:57:06 <akowalz> pavonia: /Users/Alex/.ghc/x86_64-darwin-7.8.3/package.conf.d    parsec-3.1.7, and package.conf.d
15:57:34 <danilo2> Cale: Ok, that makes perfect sense, thank you! :)
15:57:49 <nitnelave> anyone knows why I would get a segfault when calling code from a .so made from haskell?
15:57:51 <Axman6> and how are you trying to import the module?
15:58:05 <nitnelave> So haskell -> .so ->  haskell
15:58:28 <endiruna> how does haskell know that it is an infinite list in the fibonaci comprehension. or it keeps it like tat till someone asks it? to me the  via the 'iterate' seems a more natural way. the way that the list comprehension looks like is some sort of fixed point
15:58:31 <EvanR> Cale: why especially? because the value is so small?
15:59:33 <akowalz> anyone have any ideas why GHCI can't find a library I installed with cabal?
15:59:35 <Hermit> endiruna: haskell can't know it's infinite. period. It just generates it on demand, element by element, again, on demand
15:59:50 <Axman6> akowalz: how are you trying to import the module?
16:00:09 <EvanR> endiruna: iterate forms some sort of fixed point too
16:00:09 <yac> is there some job scheduler software in haskell?
16:00:10 <Axman6> akowalz: you haven't said if you're using ghci, or trying to compile a file
16:00:11 <akowalz> `import Text.ParsecCombinators.Parsec` tried both in ghci and by loading a file
16:00:27 <akowalz> Axman6: using ghci
16:00:29 <pavonia> akowalz: Have you restarted ghci after installing the package?
16:00:34 <akowalz> yes
16:00:37 <Axman6> akowalz: it's ParserCombinators not ParsecCombinators
16:00:51 <Axman6> @hoogle Parsec
16:00:52 <lambdabot> Text.Parsec.Prim type Parsec s u = ParsecT s u Identity
16:00:53 <lambdabot> Text.Parsec module Text.Parsec
16:00:53 <lambdabot> Text.ParserCombinators.Parsec module Text.ParserCombinators.Parsec
16:00:56 <geekosaur> in fact, these days it should just be Text.Parsec
16:01:13 <akowalz> Axman6: lemme double check i'm getting the spelling right. almost sure I am
16:01:14 <geekosaur> the other is for parsec2, although parsec3 retains those modules for backward compatibility
16:01:36 <akowalz> "import Text.ParserCombinators.Parsec  <no location info>:     Could not find module ‚ÄòText.ParserCombinators.Parsec‚Äô"
16:01:42 <Axman6> yeah you probably want just Text.Parsec in that case
16:01:59 <akowalz> Axman6: that fails too :( same way
16:02:13 <Axman6> anyway, it's home time for me, have a good christmas all
16:02:22 <akowalz> well thanks for your brief help
16:03:35 <EvanR> Œªo Œªo Œªo
16:03:52 <akowalz> it's also saying "maybe you haven't installed the dyn libraries for package 'parsec-3.1.7'"
16:03:58 <akowalz> but I don't really know that means...
16:03:59 * hackagebot lock-file 0.5.0.0 - Provide exclusive access to a resource using lock file.  http://hackage.haskell.org/package/lock-file-0.5.0.0 (PeterTrsko)
16:03:59 <lesmon> TroŒªŒª.
16:04:39 <benzrf> Œªo and behŒªod
16:04:41 <benzrf> er
16:04:44 <benzrf> Œªo and behoŒªd
16:08:06 <jonazzzz> ¬∞Œª = a sad man hehe
16:08:23 <pavonia> akowalz: Do you run ghci with the -dynamic flag?
16:08:27 <zq> :t unsafeIOtoST
16:08:28 <lambdabot> Not in scope: ‚ÄòunsafeIOtoST‚Äô
16:08:31 <akowalz> pavonia: I did not
16:08:33 <zq> :t unsafeIOToST
16:08:34 <lambdabot> Not in scope: ‚ÄòunsafeIOToST‚Äô
16:08:38 <zq> @hoogle unsafeIOToST
16:08:40 <lambdabot> Control.Monad.ST unsafeIOToST :: IO a -> ST s a
16:08:40 <lambdabot> Control.Monad.ST.Lazy unsafeIOToST :: IO a -> ST s a
16:08:40 <lambdabot> GHC.Conc.Sync unsafeIOToSTM :: IO a -> STM a
16:08:43 <zq> it's not there
16:08:52 <Peaker> are there any indexed monad transformers implemented? How do the types work out?
16:08:59 * hackagebot distributed-process-registry 0.1.0 - Cloud Haskell Extended Process Registry  http://hackage.haskell.org/package/distributed-process-registry-0.1.0 (TimWatson)
16:09:02 <zq> http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad-ST.html#v:unsafeIOToST not there
16:09:20 <akowalz> pavonia: that didn't work though..
16:10:03 <pavonia> akowalz: Well yeah, that seems to be the problem, it's trying to use the dynamic library which doesn't seems to be insatalled
16:10:15 <pavonia> But I have no idea why it does that
16:10:37 <akowalz> pavonia: hm. Ok.  Weird.  just to confirm, I supposed to install with "cabal install parsec" right?
16:10:53 <pavonia> The static one, yes
16:12:32 <pavonia> Maybe there's a config flag set somewhere to use -dynamic by default
16:13:55 <zq> nvm, found it in GHC.IO
16:14:05 <zq> thanks for the help
16:14:19 <akowalz> pavonia: so, do you think if I compiled my parser program and ran it, it would work? But the library for parsec I have just won't work with ghci?
16:15:06 <pavonia> I don't know how GHC handles static and dynamic linking
16:15:56 <pavonia> akowalz: You could try "cabal install parsec --enable-shared --reinstall" for installing the dynamic library
16:16:25 <akowalz> pavonia: ok, thanks. I'll try giving all this a shot
16:17:41 <akowalz> pavonia: it's working when I compile the program! so you were right.  thanks.
16:30:21 <danilo2> Hello! If I'm writing a new compiler, should I use FastString (as GHC does) or npowadays should I stay with Text when naming variables and make some hashing things to make the comparison O(1) ?
16:33:30 <lpaste> solatis pasted ‚ÄúNo title‚Äù at http://lpaste.net/2396448496828809216
16:34:46 <endiruna> i am trying to solve euler problem no. 3: given a number x1 find the largest prime dividing it.  any idea on how to optimize it? code: http://lpaste.net/117125
16:36:51 <geekosaur> euler problems aren't generally a good idea for this; they're not about programming, they're about whether you can think like a mathematician
16:37:08 <geekosaur> and your best bet for optimization is that, not knowing how to write Haskell
16:38:06 <geekosaur> in particular: the single biggest optimization here does not involve Haskell at all, but a particular property of prime numbers
16:41:58 <neuroserpens> Do bans get reset in this channel lol
16:42:27 <geekosaur> if you have a problem with a ban, you want to ask in #haskell-ops
16:42:42 <chrisdotcode> How do you even get banned here? Talk about Python?
16:42:43 <neuroserpens> geekosaur: I was banned, but now here I am hahahaha
16:43:41 <neuroserpens> chrisdotcode: There was a time when I didn't know haskell and I was bored, I found a story of a guy who tried trolling this channel and people were so nice to him that he ended up learning haskell. I tried to do the same thing but I succedded in the trolling and got banned lmao
16:43:54 <geekosaur> some bans get reset by the op who set them, depending on what led to the ban
16:44:20 <chrisdotcode> The LORD giveth, and the LORD taketh away.
16:44:30 <neuroserpens> chrisdotcode: I guess so.
16:45:00 <HeladoDeBrownie> chrisdotcode, I never realizede there were two denizens who shared the first seven characters of their nicks. That must be some sort of record
16:45:03 <HeladoDeBrownie> realized*
16:45:03 <neuroserpens> chrisdotcode: And I ended up learning haskell too... This channel contaminates everyone who comes in.
16:45:26 <chrisdotcode> HeladoDeBrownie: Yes it's caused slight problems before. I'm chrisdone's understudy.
16:45:41 <chrisdotcode> neuroserpens: toyLanguage = (/= Haskell)
16:45:45 <HeladoDeBrownie> Haha, I bet
16:46:04 <chrisdotcode> oh, I almost forgot my festive theme
16:46:12 <HeladoDeBrownie> XD
16:49:17 <SrPx> yea guys
16:49:47 <SrPx> after 3 hours I managed to create THIS: http://lpaste.net/117126
16:49:55 <SrPx> FEAR THE MASTER OF THE TYPES, LORD OF THE MONADS!!!
16:50:05 <SrPx> I am completely pro no am I not?
16:50:23 <SrPx> guys?
16:50:23 <akowalz> can anyone recommend a parsec tutorial? The ones I've found have been really dense...
16:51:26 <neuroserpens> SrPx: No one wants to indulge you. Deal with it. :D
16:53:27 <SrPx> I guess they don't appreciate the pure mastery of the monadic control in its livest shape.
16:54:02 <neuroserpens> SrPx: You have shown no evidence of that fact.
16:54:19 <SrPx> I clearly exhibited it on the lpaste link.
16:54:45 <SrPx> I bet not even carter could produce such a masterpiece of functional engineering in so few time
16:55:16 <neuroserpens> SrPx: That is hardly enough evidence of being the pure mastery of the monadic control in its livest shape.
16:55:20 <carter> SrPx: thats baby shit :)
16:55:49 <carter> wanna talk about how runlength encodings + SOA array formats are needed to efficiently build sparse CSR matrices?
16:55:52 <carter> i've some code I can show you
16:56:09 <SrPx> neuroserpens: you missed the part I said I only took 3 hours to write that. Only 3 hours! That is an impressive 1 hour/LOC. Okay, nevermind.
16:56:15 <SrPx> I know, you are all just jealous.
16:56:20 <neuroserpens> lmao xD
16:56:25 <neuroserpens> I'm with carter
16:56:27 <neuroserpens> carter: is da man
16:56:32 <t4nk940> Hi, I'm new with haskell, can I ask a question?
16:56:34 <carter> neuroserpens: i alsopatch things
16:56:39 <HeladoDeBrownie> t4nk940, sure, go ahead
16:56:59 <carter> neuroserpens: do you or anyone else off hand know that trick that lets me use quasi quoters for getting a TH AST?
16:57:05 <t4nk940> Thanks. I learned that I can use this  sum [n | n <- [1,2..5]]
16:57:12 <t4nk940> to sum the integers from 1 to 5
16:57:48 <t4nk940> But can I make someting like this :  sum [n | n <- [1,2..], n<5]
16:58:13 <HeladoDeBrownie> t4nk940, no, because the language isn't smart enough to know that the numbers are always increasing after a certain point and so will all be greater than or equal to 5
16:58:19 <ski> use `takeWhile'
16:58:49 <t4nk940> I see, how do I use takeWhile?
16:58:55 <HeladoDeBrownie> t4nk940, it may surprise you to learn that in everyday Haskell code list comprehensions aren't used all that often, favoring functions like map and filter and, as ski mentioned, takeWhile
16:58:59 <HeladoDeBrownie> @type takeWhile
16:59:00 <lambdabot> (a -> Bool) -> [a] -> [a]
16:59:01 * hackagebot aws-kinesis 0.1.2 - Bindings for Amazon Kinesis  http://hackage.haskell.org/package/aws-kinesis-0.1.2 (larsk)
16:59:12 <neuroserpens> carter: Do you mean this? http://stackoverflow.com/questions/10567164/how-do-i-use-quasi-quotations-to-get-an-ast-in-nemerle
16:59:23 <ski> > sum (takeWhile (< 5) [n | n <- [1 ..]])
16:59:23 <HeladoDeBrownie> takeWhile will keep grabbing a's until it finds one that gives a False result from the function passed. It stops there.
16:59:25 <lambdabot>  10
16:59:27 <carter> neuroserpens: ... wrong language
16:59:38 <HeladoDeBrownie> Or else it hits the end of the list, and it stops there.
16:59:49 <HeladoDeBrownie> Or else it never stops!
17:00:00 <HeladoDeBrownie> (Of course this isn't a problem due to non-strict evaluation)
17:00:09 <neuroserpens> carter: I know
17:00:11 <neuroserpens> ‚ñë‚ñë‚ñë‚ñë‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ
17:00:11 <solatis> hmmm, is it a bad practice to just ignore all 'shadows binding' warnings? I compile with -Wall and -Werror, but that warning keeps coming up, resulting in me having to choose weird variable names
17:00:13 <neuroserpens> ‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñë‚ñë‚ñÄ‚ñÄ‚ñÑ
17:00:15 <neuroserpens> ‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñí‚ñí‚ñí‚ñë‚ñë‚ñà
17:00:17 <neuroserpens> ‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñÑ‚ñà‚ñà‚ñÄ‚ñÑ‚ñÑ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñÑ‚ñÑ‚ñÑ‚ñë‚ñë‚ñë‚ñà
17:00:19 <neuroserpens> ‚ñë‚ñÄ‚ñí‚ñÑ‚ñÑ‚ñÑ‚ñí‚ñë‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚ñÑ‚ñà‚ñë‚ñë‚ñë‚ñà‚ñà‚ñÑ‚ñÑ‚ñà‚ñë‚ñë‚ñë‚ñà
17:00:21 <neuroserpens> ‚ñà‚ñí‚ñà‚ñí‚ñÑ‚ñë‚ñÄ‚ñÑ‚ñÑ‚ñÑ‚ñÄ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñí‚ñí‚ñí‚ñí‚ñí‚ñà
17:00:23 <neuroserpens> ‚ñà‚ñí‚ñà‚ñë‚ñà‚ñÄ‚ñÑ‚ñÑ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñÄ‚ñë‚ñë‚ñë‚ñë‚ñÄ‚ñÑ‚ñë‚ñë‚ñÑ‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚ñí‚ñà
17:00:24 <HeladoDeBrownie> solatis, I generally try to avoid shadowing
17:00:25 <neuroserpens> ‚ñë‚ñà‚ñÄ‚ñÑ‚ñë‚ñà‚ñÑ‚ñë‚ñà‚ñÄ‚ñÑ‚ñÑ‚ñë‚ñÄ‚ñë‚ñÄ‚ñÄ‚ñë‚ñÑ‚ñÑ‚ñÄ‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà
17:00:26 <HeladoDeBrownie> neuroserpens, >:|
17:00:27 <neuroserpens> ‚ñë‚ñë‚ñà‚ñë‚ñë‚ñÄ‚ñÑ‚ñÄ‚ñà‚ñÑ‚ñÑ‚ñë‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÄ‚ñÄ‚ñà‚ñÄ‚ñà‚ñà‚ñë‚ñà
17:00:28 --- mode: ChanServ set +q *!*@177.96.216.246.dynamic.adsl.gvt.net.br
17:00:39 <HeladoDeBrownie> solatis, but I acknowledge it's sometimes useful, so it really depends on your style
17:01:20 <ski> iirc
17:01:24 <ski> > sum [n | n <- [1 ..],then takeWhile by n < 5]
17:01:26 <lambdabot>  Unexpected transform statement in a list comprehension
17:01:26 <lambdabot>  Use TransformListCompNot in scope: ‚Äòby‚Äô
17:01:26 <lambdabot>  Perhaps you meant one of these:
17:01:30 <solatis> well i have lot of nested functions, since i always try to limit the scope as much as possible
17:01:30 <ski> would also work
17:01:39 <solatis> that very often results in shadowing
17:01:56 <HeladoDeBrownie> solatis, mind if I take a look? Easier to point out stylistic elements with concrete examples
17:02:23 <carter> neuroserpens: ..... ?
17:02:25 <solatis> one moment
17:02:37 <HeladoDeBrownie> neuroserpens appears to have been automatically muted
17:02:42 --- mode: ChanServ set -q *!*@177.96.216.246.dynamic.adsl.gvt.net.br
17:02:43 <lpaste> solatis pasted ‚Äúshadowing (avoided)‚Äù at http://lpaste.net/117127
17:02:44 <HeladoDeBrownie> (Thank goodness :P)
17:02:48 <pnielsen> is there a way to SPECIALIZE for a type only when that type (e.g. ByteString) is already included from something else's cabal conf? (i.e. specialize something for ByteString without forcing people to install ByteString if they don't use it)
17:02:53 <HeladoDeBrownie> Oh, not anymore.
17:02:54 <solatis> HeladoDeBrownie: ^^
17:02:55 <neuroserpens> Is that true?
17:03:06 <t4nk940> Sorry I did not answer, I was trying to write it with take while
17:03:17 <t4nk940> I have this now :   sum [n | n <- (takeWhile (<5) [1,2..])]
17:03:21 <ski> neuroserpens : key got stuck on your keyboard ?
17:03:22 <t4nk940> Thanks
17:03:27 <solatis> look at the function lookupSelfOffset, for example, which uses a nested comparison function
17:03:30 <neuroserpens> ski: What? Why?
17:03:47 <solatis> i cannot reuse the 'a' variable anymore, so i had to choose 'address'
17:03:51 <neuroserpens> carter: You got rickrolled.
17:04:00 <carter> neuroserpens: bugger off
17:04:01 * hackagebot snap-core 0.9.6.4 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.6.4 (GregoryCollins)
17:04:02 <ski> neuroserpens : you kept repeating the character "‚ñë" into the channel
17:04:18 <neuroserpens> ski: Alright.
17:04:19 <HeladoDeBrownie> solatis, at a glance I can't tell what's being shadowed
17:04:26 <neuroserpens> HeladoDeBrownie: Habla espa√±ol?
17:04:32 <solatis> ok let me rewrite with shadowing collissions
17:04:34 <HeladoDeBrownie> neuroserpens, sip
17:04:56 <ski> t4nk940 : that's also fine
17:05:04 <neuroserpens> HeladoDeBrownie: Your name shows
17:05:14 <HeladoDeBrownie> neuroserpens, aj√°, lo s√© :)
17:05:15 <ski> t4nk940 : you don't need the brackets around the call to `takeWhile' there, though
17:05:19 <t4nk940> How could you do it easier
17:05:21 <t4nk940> ?
17:05:38 <lpaste> solatis pasted ‚Äúshadowing‚Äù at http://lpaste.net/117128
17:06:04 <solatis> HeladoDeBrownie: lines 18, 30 and 35
17:06:18 <carter> many thanks to int-e
17:06:19 <carter>  $([|Just 123|] >>= stringE . show)
17:06:20 <HeladoDeBrownie> solatis, okay, I see. I've done that sort of thing before and on reflection don't see anything wrong with it. Others may have different opinions, or not.
17:06:21 <carter> bam
17:06:28 <neuroserpens> HeladoDeBrownie: Vamos jugar un dota pinche pendejo ksm jajajajjajajaja
17:06:36 <HeladoDeBrownie> neuroserpens, ...
17:06:54 <ij> neuroserpens, trolls are bad. boooo go away
17:06:59 <solatis> HeladoDeBrownie: ok, guess i'll just add an ignore flag to my ghc
17:07:04 <neuroserpens> ij: :C
17:07:19 <solatis> don't feed the trolls...
17:07:32 * neuroserpens goes read more LYAH because of ij
17:09:39 <solatis> maybe i should just get rid of -Werror and let the warnings be there
17:09:44 <solatis> since it can be useful
17:10:09 <solatis> how many people compile with -Wall -Werror ?
17:10:14 * christmasdotcode raises hand.
17:10:20 <christmasdotcode> -Wall is good practice.
17:10:21 * HeladoDeBrownie compiles with whatever cabal does by default :P
17:10:34 <solatis> HeladoDeBrownie: s/cabal/ghc/
17:10:44 <solatis> yeah -Wall is fine, -Werror can be a PITA
17:10:59 <geekosaur> -Werror isn't necessarily a good idea, since it complicates compatibility with other ghc versions
17:11:02 <HeladoDeBrownie> solatis, well, I didn't have specific knowledge of cabal not doing anything by default beyond what GHC does by default.
17:11:20 <solatis> geekosaur: good point
17:11:21 <geekosaur> and some of the warnings in various ghc versions don't really warrant errors, notably defaulting
17:11:52 <solatis> yeah from my c++ background -Wall -Werror was almost a must
17:12:25 <solatis> if only i could -Werror a specific subset of warnings
17:12:28 <Zorg> for C I'd start with clang's -Weveyrthing not -Wall =P
17:12:28 <geekosaur> most of the things C++ -Wall -Werrors catches, ghc catches anyway as type errors :)
17:12:51 <solatis> geekosaur: well, default initialization... :)
17:13:03 <solatis> but in C++ it can be a little more disastrous, that's my point
17:13:16 <solatis> (leaking data)
17:16:03 <t4nk940> How is this wrong : filter (`mod` 2 == 0) [1,2..10]
17:16:35 <vanila> t4nk940, it's almost right
17:16:47 <vanila> the section needs to be on its own (`mod` 2)
17:16:55 <vanila> so ((== 0) . (`mod` 2))
17:17:22 <vanila> or you can write (\x -> x `mod` 2 == 0) of course
17:19:05 <t4nk940> vanila: So, I should write filter (`mod` 2) [1,2..10]?
17:19:20 <carter> i guess SrPx  hasn't looked at my crazy layout apis
17:19:24 <vanila> filter ((== 0) . (`mod` 2)) [1,2..10]
17:19:38 <carter> SrPx: here is an older build of my layout machiner bit.ly/prealphadocs
17:20:14 <t4nk940> vanila: thanks
17:21:45 <t4nk940> vanila: Can I make sometinh like this? : filter ((== 0) . (`mod` 3) || (== 0) . (`mod` 2)) [1,2..10]
17:22:18 <vanila> that wont work without a little change
17:22:22 <vanila> || takes twoo booleans, not functions
17:22:28 <vanila> so you need to lift it up to handle functions
17:22:33 <vanila> liftA2 (||) doe sthis
17:22:45 <vanila> so filter (liftA2 ((== 0) . (`mod` 3)) ((== 0) . (`mod` 2))) [1,2..10]
17:22:49 <t4nk940> filter ((==0). (`mod` 2)) (filter ((== 0) . (`mod` 3)) [1,2..10])
17:23:09 <vanila> of course you could fuse them together and just do filter ((== 0) . (`mod` 6)) but that's probably not the point
17:23:26 <vanila> oh wait that's actually wrong, that owuld apply to &&
17:23:38 <t4nk940> Yes
17:23:47 <vanila> in this case, it's just ((== 0) . (`mod` 2))
17:23:49 <t4nk940> you are right
17:23:55 <vanila> but anyway...
17:24:15 <vanila> oh I typed that wrong
17:24:20 <vanila> filter (liftA2 (||) ((== 0) . (`mod` 3)) ((== 0) . (`mod` 2))) [1,2..10]
17:24:23 <vanila> is what I meant
17:24:35 <vanila> it would be nicer if you do
17:24:40 <t4nk940> liftA2 is another function?
17:24:49 <vanila> divides d n = n `mod` d == 0
17:24:51 <vanila> yes
17:25:10 <vanila> xthne you could write filter (liftA2 (||) (divisible 2) (divisible 3))
17:25:44 <vanila> what it does in this particular case is turns (||) :: Bool -> Bool -> Bool  into liftA2 (||) :: (Intger -> Bool) -> (Integer -> Bool) -> (Integer -> Bool)
17:25:51 <t4nk940> that's more easy to read
17:25:56 <vanila> that lets you do "or" of these functions
17:26:27 <solrize> http://lpaste.net/117129  how come "quickcheck prop_msort" gets a messy type error if i try to compile it, but it works fine and has type IO () in ghci?
17:26:29 <t4nk940> thank you
17:29:02 * hackagebot snap-server 0.9.4.6 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.4.6 (GregoryCollins)
17:29:40 <solrize> and when i run verboseCheck prop_msort in ghci, all it tests is lists of () of various sizes
17:29:52 <zq> hello
17:30:13 <zq> how unsafe would it be to use a Storable inside ST?
17:30:54 <Adeon> how would you use Storable inside ST
17:31:11 <c_wraith> only way to use Storable inside ST is via unsafeIOToST
17:31:17 <Adeon> I think the operations that utilize the Storableness of thing X will ask for IO
17:31:19 <Adeon> yeah
17:31:27 <zq> yeah o
17:31:34 <zq> so, why is it even unsafe?
17:31:34 <solrize> i guess there's no arbitrary instance for Ord a => [a]
17:31:35 <c_wraith> Which can be perfectly fine.  You just need to assure yourself it's actually safe.
17:32:01 <c_wraith> that is...  You don't leak the Ptr, or other things that would mess up ST's guarantees
17:32:08 <zq> maybe i should rephrase. what are the criteria for a safe unsafeperformio on a storage?
17:32:22 <yac> how come this code can accept multiple connections in parallel? https://github.com/yaccz/code-samples-haskell-connection-counter/blob/master/main.hs
17:32:23 <c_wraith> zq: unsafeSTToIO is very different from unsafePerformIO
17:32:35 <zq> c_wraith: unsafeIOToST, you mean?
17:32:39 <yac> is it some magic in accept?
17:32:42 <c_wraith> zq: err, yes
17:33:07 <c_wraith> zq: for unsafeIOToST, the only guarantee needed is that you cooperate with runST's rank-2 safety trick.
17:33:12 <zq> c_wraith: i actually meant to say unsfeIOToST in my rephrase. but now that you've brought it up, what are the differences?
17:33:24 <zq> c_wraith: so no leakage, as you said
17:33:43 <c_wraith> zq: yep.  unsafePerformIO has the full referential transparency requirement
17:33:57 <c_wraith> zq: which is significantly stronger of a requirement
17:34:22 <zq> c_wraith: i'm running into segfaults on -O3 despite not leaking
17:34:34 <Adeon> yac: as far as I can tell, it doesn't...it does that anyway?
17:34:55 <c_wraith> zq: well, are you sure that what your doing doesn't segfault in IO rather than ST?
17:36:32 <c_wraith> *you're.  (the typo was starting to hurt)
17:36:53 <zq> c_wraith: how could i tell?
17:37:13 <c_wraith> zq: run whatever sequence of actions in IO, instead of ST.  does that segfault too?
17:39:32 <zq> yus
17:39:34 <zq> ugh
17:40:44 <zq> alright, i'll be digging through core and asm
17:40:45 <c_wraith> zq: right.  second requirement - your IO code needs to not segfault. :P
17:40:50 <ReinH> Oh. Unsafe io segfaults. My fav.
17:41:05 <arnoblalam> Hi all
17:41:07 <c_wraith> ReinH: actually, that should be a safe IO segfault... just via the FFI
17:41:14 <c_wraith> sorta-safe IO
17:41:27 <ReinH> FFI is unsafe :p
17:41:38 <arnoblalam> question for you‚Ä¶ I have written a Haskell library for the Iron.IO message queueing service
17:42:07 <ReinH> arnoblalam: yay!
17:42:20 <arnoblalam> a bunch of my code looks like ```pushMessages client queueName ‚ÄúmyMessage1‚Äù```
17:42:44 <arnoblalam> or ```getMessages client queueName```
17:42:47 <arnoblalam> etc.
17:43:18 <arnoblalam> is there a way to provide an implementation of these functions so that the user does not have to provide the client every time
17:44:03 <pavonia> arnoblalam: That's a common use case for the Reader monad
17:44:20 <arnoblalam> Reader monad‚Ä¶ don‚Äôt know what that is
17:44:23 <arnoblalam> will look it up
17:44:26 <ReinH> Implicit configuration?
17:45:24 <dibblego> arnoblalam: the reader monad starts with this data type: newtype ClientReader a = ClientReader (TheTypeOfClient -> a)
17:45:28 <arnoblalam> well the client just looks like this ‚Äò‚Äô‚ÄôClient {token :: Text, server :: Text, projectID :: Text, ...}
17:46:10 <pavonia> arnoblalam: https://www.haskell.org/haskellwiki/All_About_Monads#The_Reader_monad
17:46:28 <ReinH> I would leave them and let users use a reader monad if they want.
17:46:38 <arnoblalam> my other functions just take the config data from the client and make the URL and such for the endpoint
17:46:50 <arnoblalam> thanks for the heads up!
18:21:10 <tsani> Is the best practice to use a cabal sandbox for each new project you're working on?
18:22:05 <ReinH> tsani: it's a pretty good practice
18:22:05 <gregnwosu> tsani: yes i think so
18:23:01 <gregnwosu> im getting the following error, "cabal: can't find source for HUnit in ., dist/build/autogen"
18:23:18 <gregnwosu> but ive added hunit to build dependencies in cabal
18:23:52 <solatis> when i have a function [a] -> a -> b, what is the proper way to specify a precondition that a must be in [a] ? by just adding a haddock comment?
18:23:55 <gregnwosu> and ive run cabal install --only-dependencies
18:24:29 <solatis> (and have my program fail when that condition is not met, similar like 'head' and 'tail')
18:25:00 <tsani> Installing twitter-conduit to this sandbox has grown the sandbox to over 250Mb heh
18:25:22 <tsani> Anyway, anyone have any experience with twitter-conduit or advice on working with Twitter in Haskell ?
18:25:50 <gregnwosu> solatis: i dont think you can specify that at the type level
18:26:23 <tsani> solatis: short of using fancy things like GADTs, I don't think it's really possible.
18:26:45 <HeladoDeBrownie> solatis, make it very clear in the documentation it fails otherwise (presumably with error?)
18:29:25 <solatis> yeah, gotcha
18:29:40 <solatis> in doxygen et al you have @pre and @post, but there is no such thing with haddock eh
18:30:30 <vanila> solatis, it isn't expressible in the type system so a comment would be good - another approach could be pass a list index instead of the element maybe?a
18:31:19 <solatis> vanila: that's interesting, but less user-friendly i'm afraid
18:31:24 <solatis> (in my case)
18:31:27 <gregnwosu> solatis: haskell has assertions, but they dont seem idiomatic to me
18:31:52 <vanila> ok just worried about if you accidentally violate the invariant
18:32:02 <solatis> nah at the moment it'll fail on a `fromJust` somewhere, i just need to make sure i generate a better error message i think
18:32:34 <solatis> (in which case the less-idiomatic assertion will probably be a good option)
18:33:13 <eyebloom> Hi, I‚Äôm trying to write a program that is to some extent polymorphic over functions with varying arity. So far I‚Äôve attempted to use type families to implement the functionality I‚Äôm imagining, but my solution is not good. I‚Äôm wondering if anyone can help me elucidate the errors in my thinking. Some toy code and compiler response is here: http://lpaste.net/117130
18:33:15 <hodapp> Dang, I might be to the point where monad transformers are a thing I need... but I probably won't know until I understand monad transformers.
18:33:31 <HeladoDeBrownie> vanila, passing an index only adds indirection, it can still fail if there aren't that many elements
18:34:26 <solatis> HeladoDeBrownie: it does make it more explicit, but i agree with you
18:34:51 <vanila> i feel like its a step closer, since you cannot get an 'a' except from the list
18:34:58 <HeladoDeBrownie> > fromJust Nothing
18:34:59 <lambdabot>  *Exception: Maybe.fromJust: Nothing
18:35:11 <vanila> well worth mentioning that there is still a precondition to satisfy though!
18:35:15 <HeladoDeBrownie> solatis, that's not a very good error message, try using maybe instead but use (error "Good error message") as one argument
18:35:26 <HeladoDeBrownie> @type maybe
18:35:27 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:35:40 <HeladoDeBrownie> > maybe (error "Good error message") id Nothing
18:35:41 <lambdabot>  *Exception: Good error message
18:35:42 <solatis> HeladoDeBrownie: yeah i believe there are Maybe helper-functions that allow you to do that
18:35:51 <HeladoDeBrownie> solatis, I mentioned one, notice the lower case :)
18:36:11 <solatis> ah!
18:36:18 <solatis> i missed that
18:36:21 <solatis> thank you :)
18:36:30 <solatis> that seems like a pretty idiomatic way
18:36:44 <HeladoDeBrownie> Yep, the idea is if you absolutely must bottom out you at least be nice about it
18:36:45 <solatis> (and lazy/just-in-time error generating)
18:37:07 <cschneid> Can somebody help me figure out the last bit of this Hasql issue I'm having - type system trickery is over my head: https://gist.github.com/cschneid/4174addefb254a517f35 -- last comment is current issue
18:37:16 <ninedotnine> i'm trying to convert some code that used a list of Ints like [0..] to use a list of Sum Int instead, and found that [0..] won't work now because Sum a isn't an instance of Enum. what should i do here?
18:37:18 <cschneid> (it's actually simple type system stuff, but still over my head)
18:37:30 <benzrf> HeladoDeBrownie: fromMaybe
18:37:33 <benzrf> :t fromMaybe
18:37:34 <lambdabot> a -> Maybe a -> a
18:37:43 <benzrf> > fromMaybe (error "lol no") (Just 4)
18:37:44 <lambdabot>  4
18:37:45 <benzrf> > fromMaybe (error "lol no") Nothing
18:37:46 <lambdabot>  *Exception: lol no
18:37:56 <cschneid> ninedotnine: `map Sum [0..]` ?
18:38:06 <HeladoDeBrownie> benzrf, neat, but I only used id for demonstration, presumably solatis's use case is more general
18:38:22 <benzrf> oh
18:38:58 <HeladoDeBrownie> Then again maybe foo bar = bar . fromMaybe foo -- I think?
18:39:05 <HeladoDeBrownie> Wait no
18:39:10 <ninedotnine> hmm, thanks cschneid, that will work
18:39:10 <HeladoDeBrownie> Er, yes, that seems to type check
18:39:24 <HeladoDeBrownie> @type \foo bar -> maybe foo bar
18:39:25 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:39:31 <HeladoDeBrownie> @type \foo bar -> bar . fromMaybe foo
18:39:31 <ninedotnine> not quite as pretty as i wanted, though, haha
18:39:32 <lambdabot> b -> (b -> c) -> Maybe b -> c
18:41:13 <HeladoDeBrownie> Hmm, those examples are wrong, but I'm too tired to figure it out right now :P
18:43:42 <solatis> in that case i'll just use benzrf's solution ;0
18:44:03 <benzrf> :t maybe
18:44:04 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:44:08 <HeladoDeBrownie> solatis, I didn't mean that what I told you earlier was wrong, more like the equality I worked out was wrong and I'm not sure why
18:44:14 <benzrf> HeladoDeBrownie: that what u were lookin for?
18:44:45 <solatis> ah ok
18:44:59 <HeladoDeBrownie> benzrf, not quite, I was trying to find some way to relate fromMaybe and maybe
18:45:05 <HeladoDeBrownie> s/way/equality/
18:45:13 <benzrf> oh
18:45:29 <benzrf> fromMaybe x y = maybe x id y
18:45:39 <HeladoDeBrownie> ‚Ä¶ Right, of course XD
18:45:49 <HeladoDeBrownie> That even went through my head earlier
18:46:34 <HeladoDeBrownie> Incidentally I just figured out what I mistyped above
18:46:37 <HeladoDeBrownie> Mystery solved!
18:46:52 <benzrf> @check \x y -> fromMaybe x y == maybe x id y
18:46:54 <lambdabot>  +++ OK, passed 100 tests.
18:46:58 <benzrf> (y)
18:47:37 <augur> fromMaybe should have a better name
18:47:43 <augur> because you can chain it nicely
18:48:25 <augur> call it orElse, then:   x `orElse` y `orElse` z
18:48:50 <augur> where x and y can be maybe'd
18:53:00 <christmasdotcode> > 1 + 1 -- test
18:53:01 <lambdabot>  2
18:53:23 <cschneid> Can somebody help me figure out the last bit of this Hasql issue I'm having - type system trickery is over my head: https://gist.github.com/cschneid/4174addefb254a517f35 -- last comment is current issue
18:53:44 <cschneid> it's a thing w/ a type variable escaping its scope, but I'm not sure what annotation its looking for
19:02:55 <tsani> is there a comprehensive list of all the command line options and configuration file options for cabal ?
19:08:11 <simon> tsani, cabal -h is not comprehensive enough?
19:09:06 * hackagebot relational-query 0.2.1.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.2.1.0 (KeiHibino)
19:14:10 <tsani> simon: it doesn't give help about what to put in a projectname.cabal file
19:15:14 <brainacid> hello all
19:15:20 <brainacid> man i get so frustrated
19:15:44 <brainacid> ii just started but i want to know it well already
19:15:55 <brainacid> lol
19:19:47 <ninedotnine> i know what you mean, haskell is so weird like that
19:20:17 <Welkin> it's the same with any tool
19:20:22 <Welkin> it takes time to learn how to use it
19:22:08 <solatis> geez, i just discovered how incredibly hard testing for exception throwing is in haskell
19:25:01 <vanila> exception throwing is so horible :(
19:25:07 <vanila> what is wrong with Either monad!
19:25:32 <vanila> its' realll weird that they added this feature, I think it just makes things harder
19:29:48 <HeladoDeBrownie> vanila, it's a natural thing to have exist since Either exists and Monad exists. Doesn't mean you need to use it. Some people find it handy though.
19:30:29 <HeladoDeBrownie> vanila, in fact in many cases the non-transformer version of something isn't terribly useful but the transformer is handy, like, in my opinion, ReaderT and StateT. There is also EitherT which is nice
19:30:55 <HeladoDeBrownie> (Although Either is useful in its own right for many situations, regardless of its Monad instance)
19:31:07 <ddellacosta> sorry if I'm not asking this using the right terminology, but how do you see the type signature for a generally defined function belonging to a specific instance of a typeclass?  In particular, I have bind (>>=) defined for a monad instance, but when I do :t (>>=) in ghci with that loaded, it just shows me the general type sig for (>>=).
19:32:32 <HeladoDeBrownie> ddellacosta, I don't know what the general way is if any, but you can use asAppliedTo
19:32:39 <HeladoDeBrownie> @type (>>=) `asAppliedTo` Nothing
19:32:39 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
19:32:50 <HeladoDeBrownie> @type asAppliedTo
19:32:51 <lambdabot> (a -> b) -> a -> a -> b
19:33:08 <ddellacosta> HeladoDeBrownie: thanks--what module is asAppliedTo in?
19:33:08 <HeladoDeBrownie> asAppliedTo = const -- but with a less general type
19:33:14 <HeladoDeBrownie> Umm, I forget, lemme check
19:33:16 <ddellacosta> Control.Monad maybe?
19:33:27 <ddellacosta> no, hmm
19:33:38 <HeladoDeBrownie> Hmm, it might not be in any module
19:33:59 <ddellacosta> huh, that sounds perfect though
19:34:12 <HeladoDeBrownie> You can always just throw it in one of your source files just for checking things out
19:34:22 <HeladoDeBrownie> I'm sure there must be a more general way but unfortunately I don't know it
19:34:59 <ddellacosta> HeladoDeBrownie: no, that's helpful.  Really it's not critical that I have this, I just want it for more easily seeing the types of instances I'm working with
19:35:09 <ddellacosta> will grab the source though, thanks!
19:35:13 <HeladoDeBrownie> \o/
19:36:14 <ddellacosta> hmm, can I get the source here I wonder?
19:36:18 <ddellacosta> @source asAppliedTo
19:36:18 <lambdabot> Unknown command, try @list
19:36:24 <ddellacosta> okay then
19:38:35 <ddellacosta> jeez, there's nothing to it is there
19:38:41 <HeladoDeBrownie> Like I mentioned, it's asAppliedTo = const
19:38:45 <HeladoDeBrownie> The type signature is important though
19:38:56 <ddellacosta> HeladoDeBrownie: sorry, I didn't get your explanation at the time
19:39:00 <HeladoDeBrownie> No worries
19:39:00 <ddellacosta> now I see!
19:39:11 <HeladoDeBrownie> @src asAppliedTo
19:39:11 <lambdabot> Source not found. My brain just exploded
19:39:13 <HeladoDeBrownie> Hrm
19:39:35 <ddellacosta> what I found was just asAppliedTo f _ = f
19:39:38 <ddellacosta> with the type sig you gave me above
19:39:53 <HeladoDeBrownie> Yeah, that's equivalent
19:40:01 <HeladoDeBrownie> const = \f _ -> f
19:40:09 <ddellacosta> right
19:40:16 <ddellacosta> wonder why they didn't use const actually
19:40:17 <ddellacosta> but whatever
19:40:24 <HeladoDeBrownie> Maybe they thought it was clearer
19:40:29 <ddellacosta> that's a good point
19:40:39 <ddellacosta> more explicitly about what it's doing
19:40:43 <ddellacosta> *explicit
20:09:15 <brainacid> been on xmonad for 2 days now
20:09:27 <brainacid> it rocks
20:09:36 <brainacid> building xmobar now
20:11:29 <ddellacosta> okay, feeling like I'm missing something obvious here.  I need X.  I've got a Monad X.  I need to "evaluate monadically," and return the X.  Obviously {do x <- m; return x} gives me a monad back, but I just want the x...can someone point out the blindingly obvious thing I must be missing here?
20:12:02 <shachaf> There are a bunch of things to address.
20:12:27 <geekosaur> ddellacosta, in the general case you can't. for certain specific monads there is a "run function" that can do it
20:12:32 <shachaf> If M is an instance of Monad, M is called a monad. A value :: M A isn't a monad (some people call it an "action").
20:12:41 <geekosaur> but if you are talking about IO, then you need to learn to work within the monad
20:12:49 <ddellacosta> shachaf: sorry for the mistakes in notation, thanks
20:12:49 <shachaf> But in general, most of the time, a value :: M A doesn't contain a value :: A.
20:13:01 <shachaf> Or it might contain several, or something more complicated.
20:13:05 <ddellacosta> geekosaur: yes, I'm am working in IO in fact.  I guess I have to revisit that.
20:13:12 <Cale> An IO String contains a String in the same sense as /bin/ls contains a list of files
20:13:24 <shachaf> I agree with Cale.
20:13:36 <Cale> (In fact, I'm paraphrasing shachaf there :)
20:14:22 <Fare> a monad is the formalization of some computational effect
20:14:23 <Cale> But yeah, the idea is that given any IO action x, you can write v <- x inside of a do-block, which means "run the action x, calling its result v"
20:14:25 <geekosaur> considering that your program entry point is *always* in IO, it is always possible to design things so you can stay in IO
20:14:27 <ddellacosta> thanks, this is all helpful.  I'm slowly approaching monad satori, but I still have a number of misconceptions and notions I have to adjust
20:14:40 <Cale> and if x :: IO String, say, then v :: String
20:14:48 <cwraith> Fare: not really.  a monad is something that fits a certain composition pattern.  some computations do, but so do other things
20:14:51 * Fare is trying to guess what the delimited control monad looks like without looking at the papers (yet)
20:14:55 <Cale> and the do-block as a whole will have type IO t for some possibly different type t
20:15:04 <shachaf> But x doesn't "contain" v, at least not in general.
20:15:06 <Cale> (whatever type of result the last action in it has)
20:15:06 <geekosaur> (although sometimes it's annoying if you've got a fairly deep set of pure functions and suddenly need to do IO)
20:15:14 <Fare> cwraith: you're looking at the inside of the monad, I'm looking at the outside
20:15:27 <shachaf> From an "internal" perspective you could say that running x returned v, but from an "external" perspective something different could be going on.
20:15:30 <pnielsen> Realizing that there's a 95% chance the answer is no: is there a way to SPECIALIZE for a type only when that type (e.g. ByteString) is already being included e.g. in something else's cabal conf during a build? (i.e. specialize something for ByteString without forcing people to install ByteString if they don't use it)
20:15:37 <Fare> no one will want to look inside until you show them why they're useful outside
20:15:47 <shachaf> E.g. if x is a list of values, v is all of the values at once.
20:16:51 <ddellacosta> Cale, shachaf, geekosaur, thanks
20:17:22 <ddellacosta> I'll stay out of what Fare and cwraith are discussing for the moment. ;-)
20:17:38 <shachaf> Hmm, the thing I said about "internal" and "external" perspectives makes some sort of sense, right?
20:17:52 <shachaf> Is there a better way to talk about it, or somewhere I can read about someone else talking about it?
20:18:15 <Fare> shachaf: I suppose
20:18:53 <Fare> I like to explain monads in terms of their being a way to formalize precisely the meaning of various side-effects
20:19:16 <Fare> so M a means "a computation that returns an a with possible side-effects"
20:19:27 <Fare> the list monad is non-determinism
20:19:51 <Fare> the double negation monad is first-class continuations
20:20:03 <shachaf> I guess Fare was talking about the same sort of thing I was at the same time.
20:20:03 <Fare> the state monad is a global variable
20:20:31 <Fare> the option monad is the possibility of utter failure
20:21:29 <Fare> I suppose depending on how you compose state and continuations, you get global variable vs dynamic variable.
20:21:45 <Fare> so they obviously don't commute
20:23:18 <Fare> similarly, you can have many-world non-determinism each with its own global state, or quantum like non-determinism where all the variants partake in modifying the same universe state
20:24:16 <Fare> or first class continuations where the entire world can fail, or one where individual computation threads can fail.
20:27:55 <godel> Lambda calculus question: are the formulas : (\x:A.x) and (\y:B.y)  equal? (\x:A.x) and (\y:A.y) definitely are, but I don't know if the type changes anything
20:28:11 <vanila> godel, they have differnet type, so they aren't the same
20:28:52 <godel> I thought so, one has type A->A and the other B->B, so they can't be the same, except A==B, right?
20:28:52 <vanila> you cannot replace one with the other in certain situations without causing a type error
20:29:04 <vanila> and for things to be equal you should be able to substitute them
20:29:05 <vanila> yeah
20:29:27 <godel> vanila: what is the formal thing to do to decide if two expressions are the same?
20:29:48 <godel> after reducing them the most you can
20:30:19 <vanila> well in a strongly normalizing typed lambda calculus you can test if two terms are equal by beta reducing them fully and then testing for alpha equality
20:30:32 <vanila> in untyped lambda calculus you can define equality as a relation, but it's not computable
20:30:53 <godel> vanila: but to betareduce I need a context, what would be the context here?
20:30:56 <vanila> you would say that m = n if there is a sequence of beta reductions m --> r and n --> r
20:31:01 <godel> the type of everything?
20:31:09 <vanila> you could start with the empty context if it is a closed lambda term
20:31:26 <vanila> but that's a good point: In typed lambda calculus systems it usually is the case that equality is defined in terms of a context
20:31:59 <godel> yea but I'm not doing exactly haskell, so (\x:A.x) with the empty context is not valid
20:32:04 <godel> because A has no type
20:32:34 <godel> it is unbound, you usually have something like "A : Universe_k" in the context
20:33:00 <godel> so it gets tricky
20:49:27 <eyebloom> Is there any way to have polymorphic arity in Haskell?
20:49:56 <shachaf> Maybe, sometimes.
20:50:01 <shachaf> It depends on the situation.
20:51:10 <eyebloom> I‚Äôm trying to express the situation I‚Äôm thinking of.
20:52:04 <eyebloom> Here‚Äôs an example of the type of code I‚Äôd like to write: http://lpaste.net/117130
20:52:28 <eyebloom> It has major problems, I understand.
20:53:44 <eyebloom> But the basic idea is that the function explode swap and reform is polymorphic across many different types, expressed by Heart3 Heart2 etc.
20:54:17 <eyebloom> But those functions take differing numbers of type variables.
21:00:38 <lf94_B]> Hey, why does showHex only allow non-negative integers? http://hackage.haskell.org/package/base-4.7.0.1/docs/Numeric.html#v:showHex
21:01:33 <Ralith> to factor out showSigned, presumably
21:02:15 <kadoban> lf94_B]: Well, presumably it has something to do with the showSigned above
21:02:30 <wz1000> Is there any (performance) difference between 'f x = let e = <expensive computation not depending on x> in ...' vs 'f = let e = <expensive computation not depending on x> in \x -> ...'
21:02:58 <shachaf> Yes, there can be.
21:03:46 <wz1000> In the first case, will e be evaluated everytime the function is called?
21:04:31 <wz1000> That is, assuming the function definition forces e.
21:04:59 <shachaf> Well, this isn't specified by the Report, of course.
21:05:06 <shachaf> It can depend on some other things.
21:05:48 <wz1000> I'm talking with respect to GHC here.
21:06:14 <wz1000> Will it pull out e from the function definition?
21:17:20 <Cale> wz1000: It may.
21:20:37 <wz1000> Also, is there any way to take configuration files at compile time and process them into pure haskell values?
21:21:21 <Cale> You could use Template Haskell for that
21:21:41 <wz1000> Can template haskell do IO?
21:22:22 <pavonia> Yes
21:22:35 <brainacid> I have such a long road ahead of me
21:23:03 <brainacid> does it happen to many? ... the initial awe of it all
21:23:52 <mseeks> hey guys, I'm trying to write a markov chain text generating function like generate :: Predictor -> [String] -> Int -> IO [String]
21:24:03 <pnielsen> wz1000: I usually use file-embed, e.g. myConf :: parseConf $(fileEmbed "path/to/file.conf")
21:24:04 <mseeks> right now I have something that's sort of ugly using do notation and explicit recursion
21:24:31 <pnielsen> (but obviously not on anything containing credentials!)
21:24:41 <mseeks> i'm trying to think of something cleaner using `sequence` or something, but it's tricky because each time you generate a new word you have to update the previous sequence you're generating on
21:24:51 <pnielsen> myConf = *
21:24:57 <wz1000> pnielsen: Oh, that sounds like what I was looking for
21:25:09 <wz1000> pnielsen: Thanks
21:25:21 <pnielsen> happy to help
21:25:27 <wz1000> I don't currently have the time to learn TH
21:25:42 <pavonia> brainacid: It's a never-ending road, I guess
21:26:59 <brainacid> pavonia: Hi. I just began. Im really interested in learning to think writting Haskell.
21:27:43 <brainacid> pavonia: Im stuck right now trying to understand recursive list functions... the very first steps. ;)
21:28:07 <pnielsen> brainacid: yes, happens to everyone. Don't let it deter you--enjoy the journey of discovery :)
21:28:27 <pavonia> brainacid: Are you working through a tutorial/book?
21:28:51 <brainacid> pnielsen: Hey thanks. im just taking a break before trying again to make the function
21:29:43 <brainacid> pavonia: Several books really, I find that some authors same some things one way and I seek other perspectives to see which I understand most
21:30:06 <brainacid> pavonia: And Im hungry for code. I want to write something useful
21:30:10 <nshepperd> mseeks: unfoldM?
21:30:15 <nshepperd> :t unfoldM
21:30:16 <lambdabot>     Not in scope: ‚ÄòunfoldM‚Äô
21:30:17 <lambdabot>     Perhaps you meant one of these:
21:30:17 <lambdabot>       ‚ÄòBS.unfoldr‚Äô (imported from Data.ByteString),
21:30:27 <brainacid> maybe make my python and perl scripts haskell definitions
21:30:41 <nshepperd> hmm
21:31:03 <brainacid> *same => say
21:31:26 <pnielsen> brainacid: that's a good exercise. This is also good: https://www.reddit.com/r/dailyprogrammer/wiki/challenges
21:32:55 <brainacid> pnielsen: those sound nice
21:34:48 <sshekh> I have done some functional programming in Oz. Now I want to learn Haskell (mainly for a project). What will be the best resource for it ?
21:35:38 <pavonia> @where lyah
21:35:38 <lambdabot> http://www.learnyouahaskell.com/
21:35:45 <pavonia> @where tryhaskell
21:35:45 <lambdabot> http://tryhaskell.org/
21:36:01 <Cale> also http://www.seas.upenn.edu/~cis194/lectures.html looks really good
21:36:12 <pnielsen> sshekh: https://twitter.com/bitemyapp/status/547611943775637506
21:36:23 <pnielsen> Cale: :)
21:36:27 <hodapp> is there some other term for the "explicit structuring" that RWH mentions as an alternative to layout?
21:36:38 <sshekh> thank you all
21:36:43 <sshekh> :)
21:37:39 <mseeks> nshepperd: interesting, the thing is that each expression depends on the result value of the previous expression
21:38:35 <nshepperd> mseeks: check out http://hackage.haskell.org/package/monad-loops, there's probably something applicable in there
21:39:19 <mseeks> thanks, didn't know about those
21:40:53 <nshepperd> oh, unfoldrM does it
21:41:46 <mseeks> thanks!
21:51:44 <SrPx> How do I freeze a generic mutable vector?
21:57:14 <brainacid> Occurs check: cannot construct the infinite type: a0 = [a0]
21:57:14 <brainacid>     Expected type: [[a0]]
21:57:14 <brainacid>       Actual type: [a0]
21:57:22 <brainacid> im so lost
21:57:23 <brainacid> lol
21:57:45 <brainacid> if (length xs) >= 3 || null xs then xs else head xs
21:58:31 <pavonia> What's the type of xs?
21:58:49 <pnielsen> xs is a list but (head xs) is just one element
21:59:30 <c_wraith> pnielsen: so...  you see the problem, right?
21:59:55 <c_wraith> pnielsen: what's the type of the result of that expression?  Is it a list or a single element?
22:00:12 <pnielsen> do you mean brainacid?
22:00:15 <pnielsen> :)
22:00:25 <c_wraith> err, yes.
22:00:43 <c_wraith> I blame my client's choice to make your nicks the same color.
22:01:07 <pnielsen> hey, at least you're not colorblind
22:01:23 * pnielsen sobs silently thinking of the fighter pilot and/or navy captain he could have been
22:02:54 <brainacid> pnielsen: lastButOne :: [a] -> [a]
22:03:19 <brainacid> return elem before last
22:03:25 <pnielsen> brainacid: feel free to paste everything into http://lpaste.net/ and link it
22:03:40 <brainacid> pnielsen: ok
22:04:15 * hackagebot test-sandbox 0.0.1.11 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.11 (junjihashimoto)
22:06:24 <brainacid> http://lpaste.net/117137
22:06:33 <brainacid> pnielsen:
22:08:09 <pnielsen> brainacid: is the goal to return the second-last element of the list?
22:12:13 <brainacid> pnielsen: yeah but i cant seem to understand :
22:12:36 <brainacid> pnielsen: I have pencil and paper trying to figure it out lol but im blocked
22:14:26 <Welkin> by (:) you mean Cons?
22:14:33 <Welkin> :t (:)
22:14:34 <lambdabot> a -> [a] -> [a]
22:14:47 <Welkin> (:) is just the infix version of Cons
22:14:55 <Welkin> Cons is just a constructor for the list
22:15:44 <brainacid> Welkin: thanks but that was typo
22:15:54 <Welkin> brainacid: also, you want to use pattern matching, not if-else
22:16:06 <brainacid> Welkin: I am just not getting the error from my function definiton
22:16:16 <Welkin> lastButOne [] = []
22:16:20 <Welkin> that is the terminating condition
22:16:24 <greymalkin> What does the bar mean in this? class MonadBase b m => MonadBaseControl b m | m -> b
22:16:25 <brainacid> Welkin: oh well I havent gotten that far yeat
22:17:01 <pnielsen> brainacid: operating on the back of lists is clunky since they're singly-linked lists in Haskell, but try using 'reverse', 'drop', and 'head' together
22:17:33 <solatis> ok
22:17:56 <solatis> should i just give up on testing whether exceptions are thrown?
22:18:13 <Welkin> head will throw exceptions on an empty list
22:18:28 <Welkin> it is unsafe and not recommended
22:18:29 <solatis> i know, and fromJust when you provide it with Nothing
22:18:44 <pnielsen> solatis: what's the context for your question?
22:19:04 <solatis> mwah, i have some place 'deep' inside my code that has some pre-conditions
22:19:34 <solatis> i expect a certain element to be inside a list
22:19:45 <solatis> at runtime, the error is properly thrown
22:19:49 <solatis> but hspec isn't able to catch it
22:20:11 <greymalkin> I'm trying to do `instance MonadBase Curses where`... but it's telling me that MonadBase has 'kind' (* -> *)
22:20:12 <pnielsen> lpaste.net?
22:20:35 <solatis> one moment
22:20:54 <Welkin> greymalkin: that means you must provide a constructor, like Maybe :: (* -> *)
22:21:19 <Welkin> Maybe is a constuctor, Maybe Int is a concrete type (*)
22:21:55 <greymalkin> I don't have access to the Curses constructor -- it's in a hidden module.
22:26:11 <lpaste> solatis pasted ‚ÄúNo title‚Äù at http://lpaste.net/117138
22:26:21 <solatis> pnielsen: ^^
22:26:23 <zzing> In an api design sense, if I had a function such as "addEventHandler" that attached an event handler h to element e; and each type of event handler was a distinct type such as a mouse event or a keyboard event; what would be the best approach to take?
22:26:57 <solatis> look at lines 85 and line 98, and line 56 and line 73 for their corresponding test cases
22:27:17 <solatis> the tested failure is generated at line 34, but since the error is generated, this code 'works'
22:27:38 <solatis> so my question is: why doesn't hspec catch the error with the code presented at line 56?
22:28:14 <solatis> for what it's worth: doing evaluate (fromJust Nothing) `shouldThrow` anyError *does* work
22:28:31 <solatis> so i highly suspect the error being thrown 'too late'
22:28:36 <Welkin> zzing: data EventType = MouseEvent | KeyboardEvent
22:29:12 <pnielsen> solatis: not sure what Quorum is, but when in doubt, deepseq
22:29:13 <zzing> Welkin, now the handler types for each event type would have different signatures.
22:29:33 <Welkin> zzing: no, that is a single type
22:29:36 <Welkin> EventType
22:29:44 <solatis> pnielsen: ok, i'll try deepseq.force
22:29:46 <zzing> Welkin, I mean the functions being passed in to handle them
22:29:49 <Welkin> or just, Event
22:30:07 <solatis> pnielsen: Quorum is defined at the top
22:30:25 <solatis> oh ehr
22:30:28 <solatis> i omitted the Types.hs
22:30:29 <Welkin> zzing: what do you mean? example?
22:30:36 <jle`> greymalkin: it's the type constructor in this case, not the data constructor
22:30:36 <solatis> it's just a data Quorum = Quorum { ... }
22:30:50 <jle`> greymalkin: the idea is that MonadBases must be paramerized types
22:30:53 <zzing> So for example,  a mouse handler might be MouseEventDataStructure -> IO ()   and a keyboard handler might be KeyboardEventDataStructure -> IO ()
22:31:08 <jle`> greymalkin: like Maybe or IO or (Either e)
22:31:22 <Welkin> zzing: what is the problem with that?
22:31:30 <jle`> as opposed to things like Int, Double, Bool, String, (), [Int], etc.
22:31:53 <Welkin> addEventHandler :: (a -> IO) -> Event -> EventHandler
22:31:58 <greymalkin> okay, I'm in over my head.
22:32:24 <zzing> Are you saying (a -> IO) is the handler?
22:32:24 <jle`> greymalkin: do you see the differene between Int, and Maybe?
22:32:25 <Welkin> greymalkin: a type constructor is a function that takes an argument to construct a complete type
22:32:30 <Welkin> zzing: yes
22:32:35 <jle`> greymalkin: do you know what Maybe is, btw?
22:32:37 <greymalkin> Right.
22:32:43 <greymalkin> Yes.
22:32:44 <jle`> can you have anything of type Maybe?
22:32:52 <zzing> Welkin, but doesn't a have to be a little bit more defined than that?
22:33:04 <Welkin> zzing: no.
22:33:06 <greymalkin> No, needs to be Maybe a
22:33:07 <Welkin> it is fine to generalize
22:33:09 <jle`> mhm
22:33:11 <isBEKaml> Hi, I have some issues with eclipseFP. is this the right channel to talk about this?
22:33:17 <jle`> you can have things of type Int
22:33:21 <jle`> or Maybe Bool
22:33:23 <jle`> but not of type Maybe
22:33:34 <jle`> the "kind" error you are receiving is that MonadBase has to be things like Maybe, IO, etc.
22:33:38 <zzing> Welkin, I would think I would have to at least have a typeclass on it
22:33:43 <jle`> it can't be things like Maybe Bool, Int, etc.
22:34:07 <Welkin> zzing: you can restrict it however you want, but you don't need to
22:34:10 <greymalkin> Right. Curses is defined (in a hidden module) as newtype Curses a = Curses { unCurses :: IO a }
22:34:18 <Welkin> :t foldr
22:34:19 <lambdabot> (a -> b -> b) -> b -> [a] -> b
22:34:22 <zzing> Welkin, I was not aware of that
22:34:22 <greymalkin> I only have access to the type.
22:34:22 <jle`> so it looks like Curses can be a MonadBase
22:34:56 <jle`> the type constructor
22:34:57 <Welkin> zzing: there is an implicit forall a
22:35:01 <greymalkin> It's only a Monad, MonadFix, MonadIO, and Functor.
22:35:03 <jle`> newtype **Curses** a = ...
22:35:05 <zzing> Welkin, for sure
22:35:20 <jle`> that constructor, that i highlighted with asterisks
22:35:26 <greymalkin> I'm trying to make it a MonadBase so that I can shove it together with a MonadResource or ResourceT
22:35:28 <jle`> not the data constructor
22:35:46 <jle`> hm
22:36:00 <jle`> but it looks lie here tha Curses is something like Maybe, IO
22:36:03 <zzing> Welkin, does that mean that I only would have to narrow it down in the event handler?
22:36:09 <jle`> because it takes a single type argument
22:36:11 <jle`> hm
22:36:28 <jle`> oh
22:36:32 <jle`> MonadBase needs two things like that
22:36:40 <jle`> what does your instance declaration look like?
22:37:05 <greymalkin> (at the moment:) instance MonadBase IO m => Curses m where liftBase = liftIO
22:37:11 <greymalkin> Which doesn't work.
22:37:19 <jle`> oh
22:37:20 <Welkin> zzing: yes
22:37:36 <jle`> the second argument of MonadBase has to also be a (* -> *) thing, or a Maybe/IO/Curses-like thing
22:37:46 <jle`> a type constructor taking one argument
22:37:47 <zzing> Welkin, thank you for your input. May your beard grow long and grey with wisdom.
22:38:01 <jle`> but you see, Curses takes a type parameter of kind *...something like Int, or Bool, etc.
22:38:30 <jle`> so first, you use `m` as if it were something like Maybe/IO...something that takes one type parameter
22:38:46 <jle`> but then you use `m` later as if it were something like Bool/Int...something that doesn't
22:39:11 <jle`> the problem isn't that it's a technicality and ghc is being picky...the problem is that what you are trying to do really doesn't make sense :)
22:39:49 <jle`> also, your MonadBase has to be something that is like Maybe/IO
22:39:54 <jle`> but here you, are saying it is `Curses m`
22:39:55 <greymalkin> I know; I'm thrashing around in the dark right now because I've spent all day trying to get these two to play together.
22:40:01 <jle`> which is something fully realized already
22:40:13 <jle`> you can only have `Curses` be MonadBase
22:40:16 <jle`> not `Curses m`
22:40:21 <jle`> have you tried looking at the example instances?
22:41:38 <greymalkin> I'm honestly not sure which example instances you're refering to.
22:41:57 <Welkin> :k Curses
22:41:58 <lambdabot> Not in scope: type constructor or class ‚ÄòCurses‚Äô
22:42:21 <Welkin> :k MonadBase
22:42:22 <lambdabot>     Not in scope: type constructor or class ‚ÄòMonadBase‚Äô
22:42:31 <greymalkin> Curses :: * -> *
22:43:19 <jle`> look at the type of `liftBase`
22:43:40 <greymalkin> MonadBase :: (*->*) -> (* -> *) -> Constraint
22:43:55 <greymalkin> b a -> m a
22:44:04 <jle`> liftBase :: MonadBase m b => b a -> m a
22:44:09 <jle`> so this is saying
22:44:21 <jle`> if you have a MonadBase m b, then you have a way to turn a `b a` into an `m a`
22:44:25 <greymalkin> take something in my second monad and put it into the first
22:44:38 <jle`> i like to think of it more like a transformation
22:44:43 <jle`> into a different domain
22:44:54 <jle`> now, you're saying you want liftBase = liftIO
22:44:56 <jle`> :t liftIO
22:44:56 <greymalkin> okay
22:44:57 <lambdabot> MonadIO m => IO a -> m a
22:45:13 <jle`> so liftIO lets you take an IO a and turn it into a `m a`
22:45:15 <greymalkin> (that was just my most recent attempt)
22:45:19 <jle`> oh
22:45:29 <jle`> well let's see what liftBase would have to be if it was liftIO
22:45:31 <greymalkin> Ah, which means it would need to be MonadBase b IO to use taht.
22:45:40 <jle`> liftIO says, "give me any IO a, and i'll turn it into an `m a`"
22:45:58 <jle`> liftBase says "for a MonadBase m b, give me any b a, and i'll turn it into a b a"
22:46:25 <jle`> so, if we specialize liftBase = liftIO
22:46:58 <jle`> um
22:47:01 <jle`> i mixed up some letters there
22:47:20 <jle`> liftBase is something you define for a MonadBase b m, which says, "give me any b a, and I'll turn it into an m a"
22:47:27 <greymalkin> no problem b a into m a
22:47:28 <jle`> so liftIO would be something for MonadBase IO m
22:47:29 <solirc> solatis: I haven't looked at your code in detail, but I think it's likely that you need deepseq
22:47:42 <jle`> if m is a MonadIO
22:48:04 <greymalkin> (which it is)
22:48:22 <solatis> solirc: i'm trying, but it still fails... :/
22:48:25 <solirc> solatis: try (evaluate . force) instead of evaluate
22:48:31 <jle`> `instance MonadBase IO m where liftBase = liftIO` would work for any MonadIO m
22:48:40 <solatis> (evaluate . force) (initialize [] (SockAddrInet 1234 0)) `shouldThrow` anyError
22:48:42 <jle`> so in your case you could write instance MonadBase IO Curses where liftBase = liftIO
22:48:42 <solatis> that is what i have now
22:48:49 <solatis> (evaluate . force) (initialize [] (SockAddrInet 1234 0)) `shouldThrow` anyErrorCall
22:48:52 <solatis> sorry wrong paste
22:49:05 <solatis> still doesn't throw the error
22:49:05 <jle`> if you have MonadBase IO Curses, that means that liftBase will turn any Curses a into an IO a
22:49:09 <solatis> ehr, catch
22:49:16 <jle`> um
22:49:22 <jle`> backwards
22:49:26 <jle`> it'll turn any IO a into a Curses a
22:49:28 <solatis> fuck it, i'll just rewrite my code that this exception never occurs
22:50:26 <zq> does newstref make a copy
22:50:28 <solirc> solatis: that is better anyway
22:50:37 <solatis> i hate that haskell has so many ways to report errors, i don't know what is best
22:50:43 <solatis> Either, Maybe or just error ()
22:51:03 <solatis> i know when to use Either or Maybe, i don't know when error () is better tho
22:51:33 <solirc> solatis: using exceptions in pure code is not a good idea in most cases
22:51:55 <solatis> so the Maybe is not pure ? (looking at fromJust .. )
22:52:03 <pnielsen> I only use use error when I know something is incomplete and expect there to never be a failure (famous last words), not for regular control flow
22:52:14 <solatis> ok
22:52:22 <nshepperd> pure mode exceptions is really only for errors that it would be nonsense to catch
22:52:25 <Welkin> that's what Maybe and Either are for
22:52:30 <solatis> so when someone incorrectly uses your API, use Either with a nice error message ?
22:52:34 <solirc> solatis: Did you write an NFData instance for that Quorum?
22:52:43 <solatis> solirc: yep
22:52:49 <solatis> (otherwise it wouldn't compile)
22:53:00 <pnielsen> solatis: Yes, or Maybe if an error condition without a description is still intuitive for your user
22:53:06 <solatis> but i'm getting tired about this, and starting to think that relying on error () is a bad idea in the first place
22:53:13 <pnielsen> e.g. lookup doesn't need to give you Left "Not found"
22:53:24 <solatis> ok
22:53:51 <solatis> and where can i find more information about how to properly structure your code with Either, without resulting to epic nested pattern match hell?
22:54:08 <Welkin> solatis: write functions that do one thing
22:54:09 <solatis> (e.g. are there any functions that help with this?)
22:54:17 <nshepperd> I've never seen error () used, normally it's error "empty list" or whatever message
22:54:24 <solatis> ok wait, i'll just paste my code :)
22:54:39 <pnielsen> solatis: http://stackoverflow.com/a/13879189/620239
22:54:46 <lpaste> solatis pasted ‚ÄúNo title‚Äù at http://lpaste.net/117140
22:55:03 <solatis> line 33 is the error
22:55:41 <Welkin> solatis: only use fromJust if you *know* that it is a Just
22:55:43 <pnielsen> (or, in other words, Applicative is your friend. The answer below adds further)
22:55:57 <Welkin> otherwise, use a case statement and match on Just a and Nothing
22:56:10 <Welkin> or, use fromMaybe
22:56:35 <solatis> Welkin: gotcha
22:57:17 <pnielsen> I've *known* that things were Justs for years and I'm still paying for it
22:57:29 <solatis> :)
22:57:43 <Welkin> I have yet to use fromJust in any program
22:57:46 <solatis> so 'fromJust' should be treated like an assertion
22:57:53 <Welkin> I usually go with case experssions
22:57:59 <Welkin> expressions*
22:58:05 <solatis> but that adds a lot of boilerplate!
22:58:11 <Welkin> it makes it clear
22:58:17 <solatis> you end up with 3 nested case expressions
22:58:19 <Welkin> fromMaybe is just as good for Maybe
22:58:25 <Welkin> ?
22:58:27 <Welkin> why 3?
22:58:36 <solatis> well, just to name a random number
22:58:46 <solatis> you end up with many nested case expressions
22:58:54 <jle`> you only need a case statement when you eventually emerge, at the single point
22:59:03 <jle`> if you stay in Maybe, you can live with the functor, applicative, and monad instances
22:59:14 <jle`> you really should never have to nest case statements using Maybe
22:59:21 <jle`> only one per situation :)
22:59:27 <solatis> and would require me actually rewriting the function at http://lpaste.net/117140#line19
22:59:55 <solatis> which, at the moment, is quite readable to me
23:00:13 <jle`> i don't see any nested case statements here
23:00:21 <jle`> oh, you use fromJust
23:00:57 <liyang> Don't make baby SPJ cry. ;_;
23:01:13 <pnielsen> hah
23:01:17 <Welkin> if you want to use fromJust, use fromMaybe instead
23:01:26 <jle`> if you have a sensible default, you can just use fromMaybe
23:01:34 <jle`> or `maybe`
23:01:43 <solatis> i don't have a sensible default, since the error results in API misusage
23:01:51 <solatis> ehr, *is a result of
23:02:02 <solatis> so the error should be propagated
23:02:12 <liyang> ProTip: @maybe def id@ is 1 character shorter than @fromMaybe def@, and it's already in Prelude, so you don't need to import Data.Maybe.
23:02:16 <jle`> would you want to return Maybe T.Quorum?
23:02:44 <solatis> i think i would want to return Either T.Quorum, with a nice error message
23:03:21 <pnielsen> solatis: that's when I do it. If it doesn't make sense for some argument API function's "n" argument to be negative it's fine to error out
23:03:31 <solatis> it would be a PITA to have a Nothing returned without knowing what the cause is
23:03:33 <pnielsen> s/argument API/API/
23:04:21 <jle`> if you want Either, then you can do maybe (Left (your error value)) Right
23:04:40 <jle`> :t maybe (Left "hey") Right
23:04:41 <lambdabot> Maybe b -> Either [Char] b
23:05:08 <solatis> ok, wait, i'm going to refactor this a bit to use Either
23:05:25 <solatis> usually Left is where the error message is, not ?
23:05:30 <pnielsen> yes
23:05:37 <solatis> got it
23:05:44 <jle`> yeah, it is that way for the purposes of the Functor/Applicative/Monad instance use cases :)
23:06:09 <jle`> but yeah, you really should only have to be maybe/fromMaybe/either-ing once in your entire "thing"
23:06:14 <jle`> or one case statement
23:06:37 <solatis> yes that is my problem, so i will need a little bit of guidance on how to aproach this problem
23:06:52 <jle`> nested case statements can usually be taken care of by the functor, applicatve, and monad instances
23:07:05 <solatis> i want to avoid the Go-like boilerplate-error-handling mechanism
23:07:06 <jle`> so show us a case where you have a nested case statement and we might be able to tell you how to use it
23:07:12 <solatis> which is what I feel Either and Maybe are... :/
23:07:48 <jle`> haskell is designed so that either and maybe become invisible
23:07:50 <jle`> that's the beauty of it
23:08:00 <jle`> it's there, but you never have to explicitly really deal with their existance at all
23:08:10 <jle`> you just use your normal functions, and everything
23:08:12 <Welkin> > (+3) <$> Just 4 <*> Just 3 <*> Nothing
23:08:13 <lambdabot>  Could not deduce (GHC.Num.Num (a1 -> a0 -> b))
23:08:13 <lambdabot>    arising from the ambiguity check for ‚Äòe_1343‚Äô
23:08:13 <lambdabot>  from the context (GHC.Num.Num (a2 -> a -> b), GHC.Num.Num a2)
23:08:14 <greymalkin> jle`: Thank you for your patience. Sorry I still haven't figured it out... but the `:k` command is one I did not know.
23:08:20 <jle`> no problem :)
23:08:22 <greymalkin> So I learned something new and valuable.
23:08:24 <solatis> i don't think i fully grasp that at the moment, so guess i'll just start using it and force myself to figure it out :)
23:08:28 <Welkin> > (+) <$> Just (+4) <*> Just 3 <*> Nothing
23:08:30 <lambdabot>  No instance for (GHC.Show.Show b0)
23:08:30 <lambdabot>    arising from a use of ‚ÄòM744525712510449049331619.show_M7445257125104490493...
23:08:30 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
23:08:36 <Welkin> > (+) <$> Just (+4) <*> Just (+3) <*> Nothing
23:08:38 <lambdabot>  No instance for (GHC.Show.Show b0)
23:08:38 <lambdabot>    arising from a use of ‚ÄòM655912060543831886831631.show_M6559120605438318868...
23:08:38 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
23:08:50 <Welkin> > (+4) <$> Just (+4) <*> Just (+3) <*> Nothing
23:08:51 <lambdabot>  No instance for (GHC.Show.Show b0)
23:08:51 <lambdabot>    arising from a use of ‚ÄòM224747231637627205331643.show_M2247472316376272053...
23:08:51 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
23:09:00 <solatis> well so much for intuitiveness... :)
23:09:28 <jle`> i'm not totally sure what Welkin is trying to do >_>
23:09:34 <Welkin> (+3) <$> Just 5
23:09:42 <Welkin> > (+3) <$> Just 5
23:09:43 <lambdabot>  Just 8
23:09:54 <pnielsen> > pure (+) <*> Just 1 <*> Just 2
23:09:56 <lambdabot>  Just 3
23:10:06 <pnielsen> > pure (+) <*> Just 8 <*> Nothing
23:10:08 <lambdabot>  Nothing
23:10:12 <jle`> solatis: anyways, i wrote a blog post about this subject of having maybe and either and stuff like that "disappear" and become free abstractions w/out boilerplate.  http://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad if you wanted :)
23:10:14 <Welkin> > (+) <$> Just 5 <*> Just 4
23:10:16 <lambdabot>  Just 9
23:10:19 <Welkin> yes
23:10:35 <solatis> yeah i think it's time for me to start to understand Applicative
23:10:41 <solatis> i've been trying to avoid it so far :)
23:11:11 <Welkin> <*> is just fmap, but the function is inside a functor
23:11:20 <Welkin> <$> is exactly fmap
23:11:30 <jle`> i have grown to not be too fond of the <$>/<*> idioms in the small arity cases...
23:11:41 <jle`> solatis: fmap lets you turn an (a -> b) into a (Maybe a -> Maybe b)
23:11:53 <jle`> solatis: liftA2 lets you turn a (a -> b -> c) into a (Maybe a -> Maybe b -> Maybe c)
23:12:05 <jle`> liftA3 lets you turn a (a -> b -> c -> d) into a (Maybe a -> Maybe b -> Maybe c -> Maybe d)
23:12:10 <jle`> and that's really all there is too it :)
23:12:20 <jle`> > liftA2 (+) (Just 4) Nothing
23:12:21 <lambdabot>  Nothing
23:12:24 <jle`> > liftA2 (+) (Just 4) (Just 10)
23:12:26 <lambdabot>  Just 14
23:12:34 <jle`> it's like fmap with multiple arguments
23:12:41 <solatis> hmz
23:12:54 <jle`> so the "idea" is, with Functor and Applicative
23:12:58 <jle`> you write all your functions as (a -> b)
23:13:01 <jle`> or (a -> b -> c)
23:13:10 <jle`> and you "ignore" the Maybe aspect
23:13:22 <jle`> you don't have to worry that a or b are Maybe
23:13:29 <jle`> you just pretend like they exist
23:13:45 <solatis> yeah, except when you write function signatures ;)
23:13:45 <jle`> this is the "free abstraction" part.  you work with a and b etc. like they are just normal values
23:13:53 <jle`> no, you leave them a, b, too :)
23:13:58 <jle`> you write functions a -> b -> c, etc.
23:14:02 <jle`> that are actually like that
23:14:11 <jle`> don't worry about Maybe, Either at all
23:14:21 <jle`> then, at the end, you use fmap, liftA2, etc. to make them work on Maybe a, etc.
23:14:24 <solatis> woa
23:14:29 <solatis> that sounds like, evil
23:14:41 <jle`> sometimes you have functions that are (a -> Maybe b)
23:14:44 <solatis> my c++ background does not approve of this blasphmey
23:14:48 <jle`> and you might want to really apply `a` to a Maybe a
23:14:51 <jle`> but...you don't have to worry about it
23:14:58 <jle`> you can just treat `a` like it is just a normal `a`
23:14:58 <solatis> yeah i understand
23:15:06 <solatis> just let the compiler deal with type inference
23:15:10 <jle`> and then...at the end... use `bind` all at the end, to turn it into (Maybe a -> Maybe b)
23:15:20 <jle`> write it as if it were `a`, use it as if it were `Maybe a`.
23:15:27 <solatis> ok i'm going to read your blog post
23:15:40 <jle`> it's not quite type inference...it's more like, using higher order functions
23:15:49 <solatis> yeah i understand
23:15:52 <jle`> notice that fmap, liftA2, bind, etc., are all higher order functions
23:16:01 <solatis> i was pretty big on template metaprogramming in my c++ days, which is similar
23:16:05 <jle`> that turn functions that are easy to write, into functions that would otherwise be annoying to write
23:16:19 <jle`> (but the latter ar ethe functions you need)
23:16:39 <solatis> ok, let me try out this evil heresy
23:16:42 <solatis> and see if i like it
23:16:53 <jle`> come to the dark side :)
23:19:00 <solatis> *googling rigid type variable errors*
23:20:19 <pnielsen> solatis: you can usually remove your type signature and ask (:t) ghci for its inferred type signature without it being too confusing
23:20:44 <solatis> i need to start using ghci, too
23:20:52 <solatis> instead of doing everything with nix/ghc
23:21:07 <pnielsen> or enable -fwarn-missing-signatures when compiling
23:22:22 <Heather> Hi, what means: the 'stdcall' calling convention is unsupported on this platform
23:22:29 <Heather> I want foreign import stdcall unsafe "SHGetFolderPathW"
23:22:35 <greymalkin> Oh. My.
23:22:40 * greymalkin dances
23:23:00 <Heather> I mean, I'm on windows, why does it unsupported
23:23:06 <solatis> ah wait, i have emacs
23:23:14 <solatis> C-c C-t displays the type
23:23:15 <greymalkin> So, the instance MonadBase IO Curses needed '-XMultiParamTypeClasses' ...
23:23:18 <jle`> congrats greymalkin :D
23:23:21 <solatis> s/type/signature/
23:23:26 <greymalkin> and then it stopped showing me errors.
23:23:50 <greymalkin> ANd then I very carefully added lines to a new function with ResourceT Curses () as the type
23:23:55 <greymalkin> and it didn't stop working.
23:25:32 <Gurkenglas> Running http://lpaste.net/117141 on fpcomplete.com doesn't seem to do anything; substituting hpmor.com for haskell.org prints a http page.
23:25:47 <Gurkenglas> Wat do?
23:26:30 <glguy> Use the browser module if you need to automatically handle redirects and such
23:26:58 <Gurkenglas> (oh, "substituting a for b" turns "b" into "a", right? If so, turn around what I wrote.)
23:27:07 <Gurkenglas> k
23:29:00 <Gurkenglas> http://lpaste.net/117142 says src/HPMOR.hs@8:26-8:36 Not in scope: getRequest
23:29:01 <Gurkenglas> src/HPMOR.hs@9:24-9:39 Not in scope: getResponseBody
23:29:12 <lpaste> solatis pasted ‚Äúhow to refactor ?‚Äù at http://lpaste.net/117143
23:29:21 <solatis> jle`: ^^
23:29:25 <solatis> can you please take a look at that
23:29:31 <solatis> i think i'm aproaching the problem in a wrong way
23:29:44 <solatis> but, line 22, the 'lookupSelfOffset' can return a Maybe
23:30:06 <solatis> i want the *whole* function to return a Left "error message" if Nothing, or otherwise return Right T.Quorum { ... }
23:30:43 <jle`> btw, you need a type for your Left
23:30:50 <jle`> Either ErrorType T.Quorum
23:30:56 <solatis> oh yeah of course
23:31:01 <solatis> this doesn't compile anyway
23:32:09 <solatis> the idiomatic way would be to use a case expression, i think ?
23:32:32 <solatis> or Data.Maybe.maybe ...
23:33:20 <solatis> or maybe I need to have lookupSelfOffset already return an Either, instead of a Maybe
23:33:22 <solatis> *sigh* :)
23:37:43 <ReinH> solatis: http://hackage.haskell.org/package/errors-1.4.7/docs/Control-Error-Util.html#v:note
23:37:51 <ReinH> Might be useful
23:39:51 <solatis> ReinH: awesome!
23:43:10 <CrepeSuzette> hello, I'm a total beginner with haskell and the program I want to run needs base>= 4.7 <=4.8, however i have base 4.6. Is there an easy way to upgrade it?
23:44:33 <pavonia> Updating GHC is the only way, AFAIK
23:44:36 <solatis> CrepeSuzette: did you install ghc/haskell using your distro's package manager, and if so, which one ?
23:46:15 <CrepeSuzette> I installed from a tarball at slackbuilds (Slackware has no official package for Haskell)
23:46:41 <CrepeSuzette> isn't it possible to upgrade base using cabal?
23:46:47 <sivteck> nope
23:47:01 <solatis> nop
23:47:11 <pavonia> CrepeSuzette: What package are you trying to install?
23:47:22 <solatis> this might be the wrong moment (or maybe the right), but maybe it's an idea to use the nix package manager on top of slackware?
23:47:56 <CrepeSuzette> it's just a CLI flashcard program made by a guy, it's still in development
23:47:59 <CrepeSuzette> Clanki
23:48:02 <CrepeSuzette> is the name
23:48:33 <gfixler> (another newb here) would sandboxes help?
23:49:09 <CrepeSuzette> https://github.com/marcusbuffet/Clanki
23:49:16 <gfixler> or is base not just another module?
23:49:43 <pavonia> CrepeSuzette: I'd download the source code, change the base version dependency and try to compile that
23:50:33 <CrepeSuzette> yes. otherwise I'd need to get the latest ghc package, right?
23:51:37 <pavonia> ghc-7.8.3
23:53:08 <sivteck> 7.8.4 is out now
23:54:20 <CrepeSuzette> okay apparently downgrading the requirements worked. Now I need to know how to run his program :)
23:54:37 <CrepeSuzette> (I just ran cabal install  in his package without error)
23:55:22 <Skola> What's the current state of affairs for real-time audio programming in Haskell? Anything cross-platform still being maintained?
23:56:12 <bitemyapp> Skola: Piponi is working on this, sorta, I think.
23:56:58 <Skola> Piponi sounds promising, "sorta" less so
23:57:25 <bitemyapp> He's doing more than audio programming
23:57:29 <bitemyapp> he's making a GUI IIRC
23:57:52 <Skola> I've resorted to using Julia for audio programming lately, and it's pretty hot, but it's not Haskell
23:58:21 <bitemyapp> Skola: take a look at what Piponi is up to, see if you can reuse it.
23:58:37 <bitemyapp> Skola: Haskell is one of the languages being used for live music performance via the coding thing
23:58:43 <bitemyapp> so it's surely not impossible.
23:59:20 * hackagebot wl-pprint-text 1.1.0.3 - A Wadler/Leijen Pretty Printer for Text values  http://hackage.haskell.org/package/wl-pprint-text-1.1.0.3 (IvanMiljenovic)
23:59:40 <Skola> I just need an f :: (Integer -> Word32) -> IO () kinda thingie
