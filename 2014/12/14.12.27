00:00:50 <dhrosa> zq: do you know of a concise way to make aeson populated the "unAPI" field with whatever the "result" of the API call is? (the stuff that's not the ok or error)
00:01:01 <dhrosa> and not have a bunch of boiler plate for every kind of response?
00:01:55 <dhrosa> oo I've got it now, thanks
00:02:10 <zq> you'd need a way to distinguish the different classes of json responses, then
00:03:48 <sebastianrkg> Hey guys, could anyone explain what <$> and <*> do? I saw them in the Aeson package but as they're symbols there is no way to google them, and I'm not sure how to describe their type signature for Hoogle
00:04:16 <zq> @hoogle (<$>)
00:04:16 <sebastianrkg> and when I do :t (<%>) in GHCi I get nothing
00:04:18 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
00:04:18 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
00:04:18 <zq> @hoogle (<*>)
00:04:18 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
00:04:29 <zwer_s> <$> is just infix fmap
00:04:34 <zq> sebastianrkg: Control.Applicative
00:04:58 <sebastianrkg> @hoogle fmap
00:04:58 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
00:04:58 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
00:04:58 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
00:05:15 <sebastianrkg> @hoogle map
00:05:15 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
00:05:15 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
00:05:15 <lambdabot> Data.ByteString.Char8 map :: (Char -> Char) -> ByteString -> ByteString
00:05:37 <sebastianrkg> okay, thanks guys, I'm gonna look into that
00:08:50 * hackagebot shell-monad 0.3.1 - shell monad  http://hackage.haskell.org/package/shell-monad-0.3.1 (JoeyHess)
00:08:50 * hackagebot mtl-prelude 1.0.2 - Reexports of most definitions from "mtl" and "transformers"  http://hackage.haskell.org/package/mtl-prelude-1.0.2 (NikitaVolkov)
00:14:07 <dhrosa> how might I have an association between types and strings?
00:14:17 <dhrosa> I'm sure there's a way to do this with a typeclass
00:14:24 <godel> dhrosa: what?
00:14:50 <godel> ah
00:15:15 <indiagreen> dhrosa: do you want something like “typeName” which would give you the name of the type of a value? well, or something other than the name
00:15:17 <dhrosa> a way to take a type, like Int, and return a string like "integer". This doesn't have to be complete, just for some types I specialize
00:15:26 <dhrosa> specify*
00:15:46 <dhrosa> something other than the name
00:17:37 <indiagreen> you just write “class Named a where name :: a -> String” and then «instance Named Int where name _ = "integer"». That's the simplest way, but it requires you to pass undefined values to “name” and it's not very nice
00:18:24 <sebastianrkg> if it's just types you specify, just a function that checks for type and gives the appropriate corresponding String should be enough
00:19:25 <dhrosa> indiagreen: yeah I tried doing a typeclass thing like that, and found it weird because I wouldn't actually have an object of the proper type at the time
00:19:36 <dhrosa> so I'd have to do weird shit like name (undefined :: Int)
00:19:45 <indiagreen> in this case you could use Proxy
00:19:53 <indiagreen> http://stackoverflow.com/questions/22116363/what-is-the-purpose-of-data-proxy
00:20:14 <indiagreen> it's in base since GHC 7.8
00:21:01 <zwer_s> dhrosa pretty much, yes.. one library does something like this: of = undefined;  name (of:: Int), but that is just improvement in cosmetics
00:21:44 <kranius> hello, are there any "reference implementation" of Pi decimals extraction or approximations
00:21:57 <indiagreen> with Proxy you'll have to do slightly more weird shit – like “name (Proxy::Proxy Int)” – but there won't be any undefineds
00:24:53 <rohan> Hey!
00:25:26 <codygman> Can you compile ghc for arm?
00:25:26 <codygman> For instance, if I wanted ghc 7.8.4 on my nexus 7
00:26:07 <codygman> rohan: Hi
00:26:14 <rohan> @codygman : Actually there exists a port of ghc that works on my rpi
00:26:14 <lambdabot> Unknown command, try @list
00:26:36 <rohan> so at least theoretically it should be possible ....
00:27:08 <rohan> @list
00:27:08 <lambdabot> What module?  Try @listmodules for some ideas.
00:27:16 <rohan> @listmodules
00:27:16 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
00:27:56 <Welkin> @spell
00:27:56 <lambdabot> No word to spell.
00:28:01 <Welkin> @spell lambdabot
00:28:01 <lambdabot> Plugin `spell' failed with: aspell: readProcessWithExitCode: runInteractiveProcess: exec: does not exist (No such file or directory)
00:35:19 <dhrosa> how do I specify the type of a do-notation binding?
00:35:43 <dhrosa> nvm I figured it out, rubber ducky programming :p
00:41:07 <dedgrant> dhrosa: It's all about the (>>=), i.e. look at the return type.
00:41:35 <dedgrant> @type (>>=)
00:41:36 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:42:44 <dhrosa> i know what type I want, I had a polymorphic thing and I was trying to force the compiler to make it monomorphic
00:44:14 <dhrosa> I've hit a haskell milestone, lack of ScopedTypeVariables finally bit me in the ass. Is there any motivation for this extension to not be default in future versions?
00:50:29 <dedgrant> dhrosa: I think you are in pretty good company, insofar as requiring notation for quantification would avoid confusion in the first place. It's just a big change to the current defaults.
00:51:21 <dedgrant> (I'm talking of GHC, not Haskell, and I wonder what implications this has for the language in general.)
00:53:55 <dhrosa> it produces a decently confusing error message for something relatively innocuous-looking
01:03:00 <solatis> @hoogle Either a b -> b
01:03:01 <lambdabot> Data.Either rights :: [Either a b] -> [b]
01:03:01 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
01:03:01 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
01:03:35 <solatis> well guess i'll roll out my own then
01:04:18 <dhrosa> solatis: you know for a fact your Either will be a Right?
01:04:27 <solatis> this is for a test case
01:04:37 <solatis> fromRight (foo) `shouldBe` bar
01:04:39 <solatis> that kind of thing
01:05:32 <solatis> (i am aware that it is not a good thing to do in production, which i am not)
01:05:34 <dhrosa> are you sure you don't want foo `shouldBe` Right bar ?
01:06:04 <dhrosa> your code will crash with a pattern match failure instead of an actual assertion
01:09:28 <solatis> well it's actually foo (bar (fromRight (baz)) `shouldBe` wombat
01:10:01 <solatis> i am aware that my code will crash with a pattern match failure otherwise, similar like fromJust
01:12:26 <dhrosa> what I'm trying to say is that you're not saving any space to use fromRight, and in the off-chance it isn't a Right, you'll get a nicer error
01:13:19 <solatis> dhrosa: hmm how would you refactor the foo(bar(fromRight baz)) example to not-deal with fromRight ?
01:13:24 <solatis> (i'm genuinely curious)
01:14:18 <dhrosa> foo . bar <$> baz `shouldBe` (Right wombat)
01:14:34 <solatis> ah, applicative again
01:14:42 <solatis> dammit i really have to start learning about that
01:15:13 <dhrosa> yes, it's quite useful. I probably use applicative stuff more than monadic stuff
01:15:27 <dhrosa> applicative is stronger than functor, but weaker than monad
01:15:32 <dhrosa> hell
01:15:36 <dhrosa> you don't even need applicative here
01:15:47 <solatis> enlighten me :)
01:15:51 <dhrosa> just fmap (foo . bar) baz `shouldBe` (Right wombat)
01:16:03 <dhrosa> <$> is simply an infix version of fmap
01:16:19 <solatis> wait, let me paste some code
01:17:03 <solatis> https://github.com/solatis/dissent/blob/master/test/Dissent/NetworkSpec.hs#L52
01:17:06 <solatis> that's an example
01:17:49 <dhrosa> there you could instead do "quorum <- Q.initialize blah blah blah"
01:18:17 <dhrosa> hmm, actually let me think about that, I think that has the same patttern match proble
01:18:48 <dhrosa> oh and you're probably not in the Either monad, derp
01:18:57 <solatis> nop
01:21:29 <solatis> i really think this approach is a pragmatic one
01:22:46 <solatis> but i agree this might not be the most elegant approach
01:44:21 <dhrosa> any tips for debugging Aeson parsing? I get "Expected a [a] but got an Object instead", which gives me no information on where in the json stream this parse error might be happening
01:44:42 <solatis> +RTS -xc ?
01:45:24 <solatis> but yeah i feel your pain, most json libraries suffer from this problem (it's very often a performance versus usability tradeoff)
01:45:44 <dhrosa> it's  probably attoparsec's fault
01:50:36 <dhrosa> aghhh, problem solved... aeson and ghc were being too smart with my type signatures
01:57:03 <crocket> Is haskell used at valve?
02:12:09 <EvanR> :t (**)
02:12:10 <lambdabot> Floating a => a -> a -> a
03:04:34 <wz1000> Can we say that there is one function of type 'Void -> Void'?
03:07:29 <Taneb> wz1000, yes
03:07:36 <Taneb> :t id :: Void -> Void
03:07:37 <lambdabot> Void -> Void
03:07:51 <Taneb> We can also say there's zero. It's the whole 0^0 thing.
03:10:00 <mlen> Taneb: but 0^0 == 1 :)
03:10:16 <bennofs> > 0^0
03:10:18 <lambdabot>  1
03:12:59 <joaopizani> the only way to define this function should be undefined, right?
03:13:24 <bennofs> joaopizani: id
03:13:31 <bennofs> joaopizani: or absurd
03:13:37 <bennofs> :t absurd :: Void -> Void
03:13:38 <lambdabot> Not in scope: ‘absurd’
03:13:41 <bennofs> :|
03:14:24 <bennofs> :t \(x :: Void) -> case x of :: Void   -- or nullary case
03:14:25 <lambdabot> Void -> Void
03:14:31 <joaopizani> In a sense, the "Void" type is NOT REALLY empty, since undefined belongs to Void
03:15:20 <joaopizani> but that's just a Haskell thing, ∀ t . ⊥ ∈ t
03:16:14 <joaopizani> So if this condition above didn't hold, we could not provide a definition for a function of type t → Void
03:16:25 <joaopizani> as in Agda, the "definition" has no right-hand side
03:17:08 <Freundlich> If the above was false then the denotational set of Void -> Void would be empty.
03:17:46 <Freundlich> But on the other hand if the set is not empty doesn't imply you can implement all of the set's members.
03:20:19 <Freundlich> Take Bool -> Bool -> Bool, for example. The denotation is a finite set of functions but if you don't provide certain parallel operations (like parallel or) you can't implement all of the set's functions.
03:20:43 <joaopizani> what do you mean by "parallel or"
03:20:45 <joaopizani> ?
03:21:51 <Freundlich> por a b = true if a true or b true... (one of them can be bottom, though).
03:25:18 <ilpianista> hi there, new user here. Which install method do you suggest? I read cabal-install usage is discouraged, is this true? I'm familiar in packaging stuff - if that helps
03:26:07 <ilpianista> I'm using arch, and I'm even an archlinux packager... I talked with my collogues and they told me arch packages (and packaging haskell in general) is a mess...
03:28:35 <Freundlich> ilpianista: It's certainly possible that package constraints can't be satisfied if you want to install multiple packages.
03:29:05 <Freundlich> cabal offers sandboxes which basically are separate installations.
03:29:16 <ilpianista> I see
03:31:10 <CrepeSuzette> I'm doing a tutorial on Haskell and using the ghci interpreter, when I type  ex01 = 3 + 2  as stated in the example, I get <interactive>:2:6: parse error on input `='
03:31:41 <CrepeSuzette> do I need to do something before?
03:31:53 <ilpianista> CrepeSuzette: prepend "let"
03:32:02 <bennofs> CrepeSuzette: ghci is a bit weird. You need to prepend let
03:32:06 <CrepeSuzette> thanks
03:32:16 <mauke> the tutorial probably expects you to be using a file
03:32:17 * ilpianista feels happy, I'm new to haskell too
03:33:13 <CrepeSuzette> :)
03:46:48 <magthe> ilpianista: I'd be most interested in hearing what about Arch packages "is a mess"
03:56:43 <ilpianista> magthe: hi! you maintain the haskell repo correct?
03:57:02 <magthe> ilpianista: yupp... hence the interest :)
03:57:02 <ilpianista> magthe: well, I tried to install hoogle. That package is on AUR
03:57:30 <ilpianista> hoogle has a lot of versioned-dependencies, many out of dated
03:57:41 <magthe> ilpianista: I personally don't touch AUR for Haskell packages
03:57:52 <ilpianista> magthe: I can guess the reason
03:58:08 <magthe> it was a long time since ArchHaskell (I) orphaned all the AUR packages
03:58:23 <magthe> I think a few of them have been picked up by others... but far from all
03:58:30 <ilpianista> magthe: I'd like to cleanup AUR and even the official haskell packages
03:59:07 <ilpianista> e.g. haskell-gtk and its dependenceis are going to be moved on AUR tomorrow
04:02:47 <kaiyin> http://en.wikibooks.org/wiki/File:Functor.png Isn't F(g) also equal to F(idB) here?
04:03:30 <Cale> kaiyin: It doesn't look like it
04:03:47 <Cale> Looks like it's a different arrow F(B) -> F(B)
04:04:24 <Cale> This diagram is a little awkward with all the crossing lines...
04:04:26 <kaiyin> Cale, well, F(A) = F(B)
04:04:34 <Black-Heaven> Hi all, which library do you use to do IMAP/SMTP + SSL? I have tried HaskellNet, but I have encountered some issues. Thanks by advance.
04:04:35 <Cale> kaiyin: yes
04:05:17 <Cale> kaiyin: For example in Haskell, we have a functor [] which when applied to a type, gives the type of lists of elements of that type
04:05:40 <magthe> ilpianista: I'm not an official Arch packages... I only deal with [haskell-core], the ArchHaskell repo
04:05:54 <ilpianista> magthe: yup I know
04:06:01 <Cale> and the corresponding action on arrows is to send a function f :: a -> b to the function map f :: [a] -> [b]
04:06:37 <magthe> last I heard the official packages were limited to ghc+cabal-install
04:06:49 <Cale> kaiyin: Note that even though map (*2) :: [Integer] -> [Integer], it is certainly not the identity function.
04:06:59 <magthe> (well, maybe a few more that are needed to build ghc too)
04:07:30 <ilpianista> magthe: plus xmonad and xmobar
04:07:37 <Cale> kaiyin: It's hard to give really good examples which look like this diagram in Haskell though, because the functors you can implement in Haskell tend to be injective on objects (i.e. don't send more than one object to the same one)
04:08:22 <magthe> ilpianista: ah, are those in [community] too... so pretty much it's limited to ghc and a few tools, no libs?
04:08:33 <Cale> kaiyin: But the same principle applies regardless: even if multiple objects are sent to the same object, it's not necessarily the case that the arrows between them are all sent to the identity.
04:08:49 <ilpianista> magthe: that was the idea.
04:09:01 <magthe> ilpianista: it's a very appealing idea :)
04:09:25 <ilpianista> magthe: however there are libs yet, which are going to be moved to AUR (aka dropped...)
04:10:15 <ilpianista> magthe: btw, pacman-key -r 4209170B does not work. is still that one your key?
04:11:29 <magthe> ilpianista: yupp, it is
04:12:04 <magthe> ilpianista: what's the complaint from pacman-key?
04:12:08 <ilpianista> ==> ERROR: Remote key not fetched correctly from keyserver.
04:12:30 <ilpianista> keyserver hkp://pool.sks-keyservers.net
04:13:38 <kaiyin> Cale, ok, what is an object in category theory?
04:14:11 <kaiyin> If A and B are sets, then I understand you mean.
04:14:44 <Cale> Well, a set (or class) of objects is part of the data which makes up a category. The objects themselves can be whatever you like them to be.
04:15:50 <Cale> (From category theory's point of view, they're just labels which tell you which arrows can be composed, and the arrows themselves similarly are arbitrary things which the composition operation acts on.)
04:16:47 <Dongyanc1i> Hello, I'm trying to setup a develop env in eclipse with eclipseFP, but every time eclipse starts, I got message like http://lpaste.net/117330. How can I get rid of this?
04:17:12 <kaiyin> Cale, what categories are there in haskell besides hask?
04:18:03 <Cale> For instance, we can make a category with a single object (it doesn't matter what that object is), and many arrows from that object to itself, say, we'll take the arrows from that object to itself to be the natural numbers. Since there's only one object in this category, any pair of arrows will be composable. We could define the composite of n and m to be n + m.
04:18:21 <Cale> With a similar approach, we can turn any monoid into a one-object category.
04:18:46 <Cale> (note that in my example there, 0 becomes the identity arrow)
04:20:03 <moop> is hspec used a lot in haskell?
04:20:05 <Cale> (if you're unfamiliar with what monoids are, I'd be happy to define them)
04:21:46 <Cale> moop: I hadn't actually heard of it, but it looks like perhaps a nice way to use QuickCheck
04:22:35 <Cale> kaiyin: For more examples of categories, let's have a look at what are called preorders
04:23:19 <Cale> A preorder is a set S together with a relation <= on S such that 1) For every a, b, c in S, whenever a <= b and b <= c, then a <= c, and 2) For every a in S, we have a <= a.
04:23:38 <Cale> Pretty much anything you normally think of as an ordering will satisfy these two conditions.
04:24:14 <Cale> We can turn any preorder into a category whose objects are the elements of S, and where there is exactly one arrow a -> b in the category whenever a <= b, and no other arrows.
04:25:19 <Cale> Property (1) in the definition of a preorder ensures that any two arrows a -> b and b -> c will have a suitable composite a -> c (and since there's at most one arrow between any pair of objects in this example, there's no confusion about which one it is)
04:25:47 <Cale> Property (2) ensures that there will be an arrow a -> a for each object a, which is important because we're required to have an identity arrow there.
04:26:40 <Cale> Associativity of composition will also hold for free, just because again there's at most one arrow between any pair of objects in these preorder categories.
04:26:51 <Cale> (also the identity laws)
04:27:22 <Cale> kaiyin: Does that example make sense? So we could make a category whose objects are the real numbers, and where there's an arrow x -> y whenever x <= y.
04:28:54 <Cale> We can also take just about any logical system of reasoning or string rewriting system you can think of, and make a category whose objects are the statements of that logic, and where there's an arrow P -> Q whenever it's possible to logically deduce Q when starting from P.
04:29:36 <Cale> It's also often possible to make a richer sort of category from most logics where the arrows instead of just being there or not, are the actual derivations or proofs.
04:30:01 <Cale> (but you have to be careful about how composition and identities work)
04:31:13 <Cale> oh, he pinged out :/
04:31:31 <Cale> kaiyin: back?
04:33:00 <lpaste> Cale pasted “text kaiyin might've missed because of disconnect” at http://lpaste.net/117331
04:33:01 <lpaste> Cale pasted “text kaiyin might've missed because of disconnect” at http://lpaste.net/117332
04:33:12 <Cale> oops, hm
04:33:32 <Cale> heh, might want to view that in raw
04:34:29 <kaiyin> Cale, I am back, sorry, I was reading something else.
04:34:54 <kaiyin> Now I need to read what you have pasted first, :-)
04:35:12 <Cale> er, the stuff I pasted is stuff I said in the channel
04:35:29 <Cale> but I don't know how complete your log will be since you seemed to be having connection troubles
04:40:39 <kaiyin> Well, the passages seem coherent, I think they are mostly there.
04:41:12 <kaiyin> Cale, what do you mean "where there's an arrow P -> Q whenever it's possible to logically deduce Q when starting from P."
04:41:32 <kaiyin> I am asking this because P and Q can be anything.
04:41:45 <Cale> P and Q in this case being logical statements
04:41:56 <kaiyin> oh.
04:45:13 <kaiyin> So Maybe is a functor, and "a functor is essentially a transformation between categories, so given categories C and D"
04:45:31 <Cale> Maybe is a functor Hask -> Hask
04:45:32 <kaiyin> Hence Maybe is a transformation between two categories.
04:46:01 <kaiyin> ok.
04:46:05 <Cale> So, yeah, it takes objects of Hask (which are types like Integer) to objects of Hask (which are types like Maybe Integer)
04:46:50 <Cale> and it takes arrows of Hask (which are functions like  chr :: Int -> Char) to arrows of Hask (fmap chr :: Maybe Int -> Maybe Char)
04:48:37 <kaiyin> So from a category theory point of view, a functor is F: C -> D, then Maybe is something like fmap: C -> D?
04:48:50 <kaiyin> I mean fmap: Hask -> Hask
04:51:25 <kaiyin> I am confused here because a functor is some kind of transformation, but Maybe is a type, I don't know how to reconcile these two.
04:51:47 <Cale> Maybe isn't a type
04:51:56 <Cale> Maybe is a type constructor
04:52:01 <Cale> It sends types to other types
04:52:12 <Cale> e.g. it sends Integer to Maybe Integer
04:52:26 <Cale> and String to Maybe String, and so on
04:52:36 <kaiyin> ok, Int -> Just Int or Int -> Nothing, for example
04:52:41 <Cale> er
04:52:42 <bernalex> no
04:52:45 <kaiyin> Is Just a type then?
04:52:47 <bernalex> Just and Nothing are values
04:52:50 <Cale> We're not talking about a value level function
04:52:57 <Cale> We're talking about something in the type level
04:52:58 <bernalex> Just 5 is a value. Nothing is a value. Maybe Int is a type.
04:53:10 <bernalex> Nothing is a value of type Maybe a.
04:53:20 <Cale> But essentially Maybe is a function at the type level.
04:53:44 <kaiyin> And a type is a category, right?
04:53:55 * hackagebot eventstore 0.1.2.0 - EventStore Haskell TCP Client  http://hackage.haskell.org/package/eventstore-0.1.2.0 (YorickLaupa)
04:54:10 <Cale> There's a category whose objects are Haskell types, and whose arrows are the Haskell-definable functions between those types.
04:54:41 <bernalex> most things are categories tbh. it's a very abstract thing.
04:55:29 <magthe> ilpianista: `pacman -r 4209170B` works for me... just tried it
04:56:16 <kaiyin> For example, Maybe :: a -> Maybe a
04:56:25 <Cale> no
04:56:29 <Cale> Maybe is not a value
04:56:34 <bernalex> Maybe :: * -> *
04:56:46 <magthe> ilpianista: not sure which keyserver it's using though
04:56:50 <bernalex> where * is is a value.
04:57:02 <Cale> It never occurs to the left of :: unless you're writing a kind signature (kinds being to types what types are to values)
04:57:07 <Cale> * is not a value
04:57:22 <Cale> * is the kind of types which themselves have values
04:57:22 <kaiyin> :t Maybe 5
04:57:23 <lambdabot> Not in scope: data constructor ‘Maybe’
04:57:33 <kaiyin> :t Just 5
04:57:34 <lambdabot> Num a => Maybe a
04:57:41 <bernalex> Cale: that is more precise, yes. sorry.
04:58:11 <kaiyin> :t Maybe Int
04:58:12 <lambdabot> Not in scope: data constructor ‘Maybe’
04:58:13 <lambdabot>     Not in scope: data constructor ‘Int’
04:58:13 <lambdabot>     Perhaps you meant one of these:
04:58:18 <Cale> :k Int
04:58:19 <lambdabot> *
04:58:21 <Cale> :k Maybe
04:58:22 <lambdabot> * -> *
04:58:27 <Cale> :k Maybe Int
04:58:28 <lambdabot> *
04:58:34 <Rufflewind> so ghc will wipe out your source code if you try to compile one that doesn't have an extension and forget to specify "-o" :\
04:58:35 <bernalex> :k Maybe (Maybe (Maybe Int))
04:58:36 <lambdabot> *
04:58:44 <Cale> :k StateT
04:58:45 <lambdabot> * -> (* -> *) -> * -> *
04:58:48 <Cale> :k StateT Int
04:58:49 <lambdabot> (* -> *) -> * -> *
04:58:51 <Cale> :k StateT Int Maybe
04:58:52 <lambdabot> * -> *
04:58:55 <Cale> :k StateT Int Maybe String
04:58:56 <lambdabot> *
04:58:58 <bernalex> :k (->)
04:58:59 <lambdabot> * -> * -> *
04:59:33 <bernalex> :k Int -> Int
04:59:34 <lambdabot> *
04:59:57 <Cale> Rufflewind: That's interesting, and probably ought to be fixed. Why was your code in a file without an extension anyway?
05:00:43 <Cale> Rufflewind: There was once a bug in GHC a very long time ago where if you had a certain sort of type error in your code, some chain of events would occur that caused it to delete your source code.
05:00:45 <Rufflewind> Cale: it's meant to be "script-like", so usually I'd just run it directly with runhaskell
05:00:56 <Rufflewind> Cale: I've heard about that :P
05:00:57 <Cale> ah
05:01:10 <bernalex> sounds like a very worthwhile bug report.
05:01:36 <kaiyin> Ok, more confused than before, let's get back to the foundation: Maybe is a type constructor, it sends type to another type.
05:01:42 <Cale> yes
05:02:00 <Cale> So Integer is a type, and when we apply Maybe to it, we get Maybe Integer, which is another type
05:02:00 <kaiyin> How do you send type to type, exactly, in haskell?
05:02:15 <kaiyin> > Maybe 5
05:02:17 <lambdabot>  Not in scope: data constructor ‘Maybe’
05:02:21 <Cale> 5 is not a type
05:02:27 <kaiyin> > Maybe Int
05:02:28 <lambdabot>  Not in scope: data constructor ‘Maybe’Not in scope: data constructor ‘Int’
05:02:28 <lambdabot>  Perhaps you meant one of these:
05:02:28 <lambdabot>    ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
05:02:34 <bernalex> Rufflewind: what do you use to compile it? IIRC off-hand, "ghc filewithnoext" won't really do anything
05:02:41 <Cale> Also, the bot is expecting a value expression, not a type expression
05:02:49 <Cale> > Just 5 :: Maybe Int
05:02:50 <Rufflewind> bernalex: ghc -x hs
05:02:51 <lambdabot>  Just 5
05:02:56 <bernalex> Rufflewind: ah
05:03:22 <bernalex> Rufflewind: haha oh I see
05:03:29 <kaiyin> ok, type expression and value expression seem to be in parallel universes.
05:03:33 <Cale> yes
05:03:46 <Cale> Types only exist at compile time
05:03:46 <kaiyin> > Just 5 :: Maybe Double
05:03:47 <lambdabot>  Just 5.0
05:03:49 <bernalex> Rufflewind: we should do this a bit differently, yes. please file a bug report.
05:04:01 <Cale> They are erased by compilation and the resulting machine code has no corresponding notion
05:04:13 <Cale> Values have a representation at runtime.
05:04:59 <Cale> Types are used to check that values are well behaved, and also, via typeclasses, in some cases used to decide which values to use based on type context.
05:05:21 <Cale> (e.g. which parser will be used when you write   read "5"  depends on which type the result is used as)
05:05:27 <Cale> > read "5" :: Integer
05:05:28 <lambdabot>  5
05:05:29 <kaiyin> cool.
05:05:31 <Cale> > read "5" :: Double
05:05:33 <lambdabot>  5.0
05:05:38 <Cale> > read "5" :: [String]
05:05:39 <lambdabot>  *Exception: Prelude.read: no parse
05:05:58 <kaiyin> > read "5" [Char]
05:05:59 <lambdabot>  Not in scope: data constructor ‘Char’
05:05:59 <lambdabot>  Perhaps you meant ‘Chr’ (imported from Text.PrettyPrint.HughesPJ)
05:06:07 <kaiyin> > read "5" [Chr]
05:06:08 <lambdabot>  No instance for (GHC.Show.Show a0)
05:06:08 <lambdabot>    arising from a use of ‘M33964644377980828085422.show_M33964644377980828085...
05:06:08 <lambdabot>  The type variable ‘a0’ is ambiguous
05:06:16 <Cale> > read "5" :: [Char]
05:06:17 <kaiyin> > read "5" String
05:06:18 <lambdabot>  "*Exception: Prelude.read: no parse
05:06:18 <lambdabot>  can't find file: L.hs
05:06:30 <Cale> The :: there is important
05:06:37 <kaiyin> > read "5" :: String
05:06:38 <lambdabot>  "*Exception: Prelude.read: no parse
05:06:53 <Cale> > read "\"5\"" :: String
05:06:54 <lambdabot>  "5"
05:07:11 <Cale> > read "[1,2,3]" :: [Integer]
05:07:13 <lambdabot>  [1,2,3]
05:07:17 <Cale> > read "[1,2,3]" :: [Double]
05:07:18 <lambdabot>  [1.0,2.0,3.0]
05:07:35 <kaiyin> cool
05:08:47 <kaiyin> Back to topic, a functor is a transformation between categories, F:C->D, and Maybe is a functor, what if the F part for Maybe?
05:08:57 <Cale> Maybe itself
05:09:10 <Cale> Well, the action on objects is Maybe
05:09:15 <Cale> and the action on arrows is fmap
05:09:19 <Cale> :t fmap
05:09:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:09:30 <structuralist> is there some standard module containing type-level list operations like (++)?
05:09:35 <Cale> :t fmap :: (a -> b) -> (Maybe a -> Maybe b)
05:09:36 <lambdabot> (a -> b) -> Maybe a -> Maybe b
05:10:40 <kaiyin> ok.
05:11:38 <kaiyin> It needs to map any object in Hask, say O_h, to F(O_h), which is, Maybe O_h
05:11:45 <Cale> structuralist: Not standard, but hackage gives me: http://hackage.haskell.org/package/type-list
05:11:55 <Cale> structuralist: I don't see (++) there though...
05:12:24 <bernalex> str I don't immediately see the use case for type-level append in haskell -- enlighten me?
05:12:27 <bernalex> structuralist: ^
05:12:53 <Cale> I can imagine some use cases with HList-like things
05:13:37 <bernalex> I guess
05:14:05 <kaiyin> > fmap id Just 5
05:14:06 <lambdabot>  Just 5
05:14:24 <kaiyin> > fmap id
05:14:25 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
05:14:26 <lambdabot>    arising from a use of ‘M27528060806782015185640.show_M27528060806782015185...
05:14:26 <lambdabot>  The type variable ‘b0’ is ambiguous
05:14:30 <Cale> hehe, that's probably using a different fmap than you were expecting there
05:14:37 <Cale> > fmap id (Just 5)
05:14:38 <lambdabot>  Just 5
05:14:42 <Cale> > fmap (*2) (Just 5)
05:14:44 <lambdabot>  Just 10
05:14:50 <kaiyin> :t fmap id
05:14:51 <lambdabot> Functor f => f b -> f b
05:15:58 <structuralist> bernalex: I'm sort of writing an AST where terms have lists of types
05:16:20 <bernalex> structuralist: yeah I just realised that an AST or similar would probably benefit from it.
05:16:26 <structuralist> bernalex: more precisely I'm implementing a one-sided sequent calculus
05:16:52 <structuralist> "ASTs" = derivations
05:27:02 <cinimod`> @seen carter
05:27:02 <lambdabot> CAr7eR
05:35:29 <dutchie> how do you pronounce applicative's <*> operator?
05:37:20 <ddellacosta> dutchie: I've heard 'ap' used for that before
05:37:48 <mitu> star-in-the-diamond
05:39:12 <mitu> http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Applicative.html#v:-60--42--62-
05:39:19 <Cale> yeah "ap", since for monads, it's the same as Control.Monad.ap
05:39:29 <Cale> short for "apply"
05:39:39 <dutchie> makes sense
05:40:18 <fizbin> Seeing this makes me want to try to work out something similar for lens: https://glyphic.s3.amazonaws.com/ozone/mark/periodic/Periodic%20Table%20of%20the%20Operators%20A4%20300dpi.jpg
05:41:10 <_d0t> ohai. Does anyone know how much space a hackage mirror would occupy? Thx.
05:41:25 <vanila> Hello
05:42:11 <vanila> Can anyone give me more info on using stackage? The instructions are very breif and I don't know whether I should be doing other things like sandbox or how to test if its working and so on
06:03:58 * hackagebot DigitalOcean 0.1.1.0 - A client library for the DigitalOcean API  http://hackage.haskell.org/package/DigitalOcean-0.1.1.0 (lclarkmichalek)
06:06:28 <renxx__> Is there a book for haskell data structures?
06:06:45 <notdan> There is http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
06:06:46 <dramforever> maybe Purely Functional Data Structures
06:06:55 <notdan> while not for haskell per se, but quite useful anyway
06:17:24 <vanila> anyone know a bit about stackage?
06:32:19 <dfeuer> The GHC docs on UNPACK are pretty UNCLEAR. If I have data Foo = Foo {-# UNPACK #-} !(Bar a) Baz  and data Bar a = Bar a a, will Bar get unpacked into Foo or not?
06:41:34 <kaiyin> From haskell road to logic: Constructor identifiers are used to name types. They have to start with an
06:41:34 <kaiyin> upper-case letter. Examples are True, False
06:41:43 <kaiyin> So True is a type?
06:42:05 <_d0t> kaiyin: its a constructor
06:42:13 <_d0t> kaiyin: data Bool = False | True
06:42:54 <kaiyin> _d0t, and data Maybe a = Just a | Nothing ?
06:43:22 <kaiyin> Cale mentioned that Just is a value, so is Nothing.
06:43:43 <kaiyin> Doesn't that imply False and True are values?
06:43:59 * hackagebot extended-reals 0.2.1.0 - Extension of real numbers with positive/negative infinities  http://hackage.haskell.org/package/extended-reals-0.2.1.0 (MasahiroSakai)
06:44:19 <vanila> yes, they are values
06:45:58 <kaiyin> and they are also types, vanila ?
06:46:07 <vanila> no, True is the type
06:46:08 <vanila> sorry
06:46:11 <vanila> Bool is the type
06:46:37 <kaiyin> the books says True is also a type.
06:47:08 <vanila> that's wrong
06:47:24 <vanila> maybe the book is talking about something slightly diffrent than  data Bool = False | True
06:47:59 <vanila> http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf I found the PDF, what page is it?
06:48:38 <vanila> oh just the quote you posted? I think that is just a slight mistake in wording when they wrote the book
06:48:56 <vanila> True, False, Just, Nothing are constructors for values
06:48:59 * hackagebot shell-monad 0.4.0 - shell monad  http://hackage.haskell.org/package/shell-monad-0.4.0 (JoeyHess)
06:49:19 <vanila> Bool and Maybe are constructors for types
06:49:41 <kaiyin> Page 12
07:09:00 * hackagebot hpc-coveralls 0.7.0 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.7.0 (killy971)
07:13:53 <Darwin226> Hey guys, are there classes like Foldable available for non-generic types? For example a map that doesn't affect some inner value of a structure, but the structure itself? Like (Tree -> Tree) -> Tree -> Tree
07:17:54 <makalu> can I do a parallel map over the columns/rows of a matrix with a function that operates on vectors?
07:21:44 <renxx__> where can I get definitons for haskell defined data types
07:24:44 <adamse_> renxx__: depends on which datatypes?
07:24:51 <renxx__> for example tuple
07:29:00 <bennofs> Is it possible to generate 'foreign export' statements with TH in GHC?
07:34:17 <adamse_> renxx__: I believe the tuple type is something built in, not defined in haskell. for ghc https://github.com/ghc/ghc/blob/b5930f8b8030350eff306bf56ba7607098ada61e/libraries/base/GHC/Base.lhs contains some clues (see the "Note [Depend on GHC.Tuple]")
07:34:59 <renxx__> thank you
07:35:17 <adamse_> renxx__: but here is the GHC.Tuple module: https://github.com/ghc/ghc/blob/b5930f8b8030350eff306bf56ba7607098ada61e/libraries/ghc-prim/GHC/Tuple.hs
07:35:37 <adamse_> and it seems I was wrong
07:36:21 <vanila> you can think of the tuple like this:  data Pair a b = Pair a b
07:36:26 <vanila> with edfferent syntax
07:39:16 <f-a> https://github.com/Dobiasd/articles/blob/master/programming_language_learning_curves.md probably someone already spammed it in here. If that's not the case, here it is
07:39:57 <dfeuer> > (,,,) 1 2 3 4
07:39:58 <lambdabot>  (1,2,3,4)
07:40:24 <dfeuer> :k (,,,) Int Bool
07:40:25 <lambdabot> * -> * -> *
07:40:33 <renxx__> why is the defintion of tuple in GHC.Tuple.hs "data (,) a b = (,) a b" is it because of currying
07:41:14 <adamse_> renxx__: (,) is like any other constructor here
07:41:53 <adamse_> with data Pair a b = Pair a b, Pair is the same as (,), only without the special syntax
07:42:11 <dfeuer> The only special thing about tuples is the (a,b,c) syntax.
07:42:14 <jiang42> https://raw.githubusercontent.com/Dobiasd/articles/master/programming_language_learning_curves/haskell.png # https://github.com/Dobiasd/articles/blob/master/programming_language_learning_curves.md
07:42:35 <dfeuer> (a,b,c) is a friendly shorthand for (,,) a b c
07:42:46 <vanila> the PHP one is daft, lots of people are extremely productive with PHP
07:43:22 <dfeuer> vanila, see http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/
07:45:54 <siddhu> is there a function that goes from [a] -> [[a]], in particular, [1..99] to [[1,2,3],[4,5,6],...,[97,98,99]] ?
07:46:30 <f-a> siddhu: it seems to you want to map a function to something
07:46:40 <vanila> its called chunks
07:46:49 <f-a> seeing that 4,5,6 is nothing more thant 1,2,3 * 2...
07:47:09 <vanila> https://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html#t:Splitter
07:47:26 <siddhu> splitEvery 3 ['a'..'z'] does the trick
07:47:33 <siddhu> Thanks vanilla and f-a
08:06:09 <kaiyin> About monad laws, the wiki book says: given a monod M: C->C, join . M(join) = join . join
08:06:15 <kaiyin> how so?
08:06:45 <kaiyin> join is M M a -> Ma
08:07:07 <kaiyin> M join should be M M M a -> M M a, right?
08:07:35 <barrucadu> :t liftM join
08:07:36 <lambdabot> (Monad m1, Monad m) => m (m1 (m1 a)) -> m (m1 a)
08:08:18 <vanila> thats right kaiyin
08:08:21 <kaiyin> then join . M join should be M M M a -> M a
08:08:39 <vanila> note where you write M in category theory it would be fmap in haskell
08:08:53 <kaiyin> yeah.
08:09:12 <kaiyin> But join . join is M M a -> a, isn't it?
08:09:23 <vanila> almost, it's M M M a -> M a
08:09:26 <vanila> :t join . join
08:09:26 <lambdabot> Monad m => m (m (m a)) -> m a
08:10:22 <kaiyin> ok, I see, it must return M a
08:10:52 <kaiyin> :t join . return
08:10:53 <lambdabot> Monad m => m a -> m a
08:11:10 <robstewartuk> I have a straight forward question (I think). I'm looking for a containers API that provides `insert :: v -> IntMap v`. I don't want to have to provide an Int argument. I want this `insert` construct to do nothing is the value `v` exists, else increment the IntMap index and enter `v` eith this index.
08:11:40 <robstewartuk> I could wrap something about IntMap, I am looking for an existing efficient implementation
08:11:41 <robstewartuk> .
08:11:49 <robstewartuk> Does anyone know of one?
08:12:36 <phaazon> robstewartuk, lens? :)
08:15:00 <kaiyin> given a monad M:C->C and a morphism f:A->B, how can you compose unit with f?
08:15:06 <kaiyin> :t return
08:15:07 <lambdabot> Monad m => a -> m a
08:15:33 <vanila> you could do return . f or M f . return
08:15:51 <vanila> and these are equal
08:16:07 <kaiyin> :t return . (+3)
08:16:07 <lambdabot> (Num b, Monad m) => b -> m b
08:16:35 <vanila> are you drawing the diagrams along with these?
08:17:12 <kaiyin> what kind of diagrams, vanila ?
08:17:29 <vanila> http://pdp7.org/blog/wp-content/uploads/2011/01/Screen-shot-2011-01-24-at-16.11.06-.png
08:17:50 <vanila> like this, it can help a lot getting a clear picture of how the compositions relate
08:18:11 <vanila> (eta there is return, and mu is join)
08:20:24 <kaiyin> vanila, and what is T^2?
08:20:39 <vanila> that's T . T
08:20:44 <kaiyin> oh, and what is T?
08:20:47 <vanila> so instead of writing M M a they write M^2
08:20:51 <vanila> but this monad is called T
08:20:55 <vanila> rather than M
08:20:58 <kaiyin> ok
08:21:21 <kaiyin> so T eta is T join and eta T is join T
08:21:45 <amaniacprogramme> hello, trying to wrap my head around the state monad with some simple examples, but getting type errors: No instance for (MonadState Int m0) arising from a use of `state'. http://lpaste.net/117342
08:22:47 <vanila> try import Control.Monad.State.Lazy instaed?
08:23:02 <kaiyin> :t join Maybe Maybe
08:23:03 <lambdabot> Not in scope: data constructor ‘Maybe’
08:23:03 <lambdabot> Not in scope: data constructor ‘Maybe’
08:23:13 <kaiyin> :t join Just 5 Just 4
08:23:14 <lambdabot>     Couldn't match type ‘a0 -> (a1 -> Maybe a1) -> a2 -> t’
08:23:14 <lambdabot>                   with ‘Maybe a0’
08:23:14 <lambdabot>     Expected type: a0 -> a0 -> (a1 -> Maybe a1) -> a2 -> t
08:23:19 <vanila> :t join . Just . Just
08:23:20 <lambdabot> a -> Maybe a
08:23:20 <amaniacprogramme> @vanilla: doesn't work
08:23:20 <lambdabot> Unknown command, try @list
08:24:17 <kaiyin> :t join . Just
08:24:18 <lambdabot> Maybe a -> Maybe a
08:24:26 <kaiyin> :t join . Maybe
08:24:27 <lambdabot> Not in scope: data constructor ‘Maybe’
08:25:37 <kaiyin> Maybe is a monad, but why can't I use :t join . Maybe as suggested by the diagram, vanila ?
08:26:12 <vanila> kaiyin, well remember that in category theory when T or M has two meanings, it's fmap when used at the value level and it's the monad type constructor when used in a type
08:27:22 <kaiyin> ok
08:27:29 <kaiyin> :t join . fmap
08:27:30 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a)
08:27:30 <lambdabot>     Expected type: (a -> b) -> f a -> f a -> b
08:27:30 <lambdabot>       Actual type: (a -> b) -> f a -> f b
08:28:07 <vanila> :t fmap . join
08:28:08 <lambdabot> Functor f => (a -> a -> a1) -> f a -> f a1
08:28:48 <vanila> the other one is read differently: eta T a is eta_{T a}, so it's just return (on T a)
08:29:43 <vanila> this isn't really important though, that diagram was just an example - it uses normal mathematical notation rather than haskell notation, but you can make these diagrams with haskell notation
08:30:49 <kaiyin> ok, I will stick with writing equations for now. thanks.
08:31:34 <kaiyin> :t fmap (f . return)
08:31:36 <lambdabot> (FromExpr b, Show (m a), Functor f, Monad m) => f a -> f b
08:32:06 <kaiyin> :t return . f
08:32:07 <lambdabot> (FromExpr b, Show a, Monad m) => a -> m b
08:32:24 <kaiyin> :t (fmap f) . return
08:32:25 <lambdabot> (FromExpr b, Show a, Functor f, Monad f) => a -> f b
08:32:49 <athan> Hey guys, if I have some json file that I want to read with aeson, I'd probably try `(thing :: Maybe SomeThing) <- decodeFile "something.json"`. Is there a JSON data type that is just a javascript object, with text names? I'm trying to do statistics over an arbitrarilly nested javascript object.
08:33:00 <kaiyin> :t fmap f . return
08:33:01 <lambdabot> (FromExpr b, Show a, Functor f, Monad f) => a -> f b
08:34:54 <kaiyin> Suppose f: a->b, then fmap f is M a -> M b right?
08:35:16 <athan> yep :)
08:35:30 <athan> also written as `f <$>`
08:35:51 <athan> :t (+) <$>
08:35:52 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
08:36:07 <athan> :t (<$>) (+)
08:36:08 <lambdabot> (Num a, Functor f) => f a -> f (a -> a)
08:36:10 <athan> lol
08:36:36 <athan> :t (<$>) (+1)
08:36:37 <lambdabot> (Num b, Functor f) => f b -> f b
08:36:51 <athan> :t (+1)
08:36:52 <lambdabot> Num a => a -> a
08:37:11 <Confusion> athan: that would be a JSON 'object'
08:37:42 <kaiyin> :t fmap (\x -> show x)
08:37:43 <lambdabot> (Show a, Functor f) => f a -> f String
08:37:47 <athan> Confusion: It feels like it would be heterogeneous or something, sorry, I'll check it out
08:38:26 <kaiyin> :t (<$>) (\x -> show x)
08:38:27 <lambdabot> (Show a, Functor f) => f a -> f String
08:38:38 <kaiyin> :t (\x -> show x) <$>
08:38:39 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
08:38:50 <kaiyin> :t ((\x -> show x) <$>)
08:38:51 <lambdabot> (Show a, Functor f) => f a -> f String
08:40:14 <znn> i read somewhere that effects aren't composable, but i don't know if this makes sense at all
08:40:49 <znn> i think the paper/person was talking about exteff
08:41:42 <asthasr> Hi guys! I was thinking about my question the other day during which time people told me that I shouldn't be using the do notation,--so I decided to convert one of my problem solutions from do notation to "plain" notation
08:41:55 <asthasr> However, I'm missing something in the translation of one of the elements. I will make a pastebin.
08:43:23 <asthasr> http://hastebin.com/koritilifu.hs
08:43:51 <asthasr> the call to unfairness is raising an error because of the use of a monadic int, IO Int -- what is the idiomatic way to make this work?
08:43:56 <asthasr> do I need to 'lift' the function somehow?
08:44:01 <prophile> people told you not to use do notation?
08:44:22 <asthasr> prophile: Yes. I don't have logs, but the gist was "it hides some of what's happening"
08:44:27 <prophile> @undo do { count <- readLn :: IO Int; print count }
08:44:27 <lambdabot> (readLn :: IO Int) >>= \ count -> print count
08:44:28 <asthasr> which, this proves, I suppose :)
08:45:44 <asthasr> @undo do { x <- readLn :: IO Int; y <- readLn :: IO Int; print (x + y) }
08:45:44 <lambdabot> (readLn :: IO Int) >>= \ x -> (readLn :: IO Int) >>= \ y -> print (x + y)
08:46:12 <prophile> minor points: putStrLn . show ==> print
08:46:38 <prophile> and rather than using foo <- return bar in do notation, it's better to use let foo = bar
08:48:40 <asthasr> Hmm, I am surprised that the form using (>>=) allows me to access the input variable in an anonymous function from a later element... or am I reading it wrong? does the anon function greedily consume the rest of the line, so that \x -> (readLn :: IO Int) >>= ... is its actual definition?
08:49:49 <geekosaur> lambda bindings extend as far as they can, yes
08:51:04 <asthasr> prophile: Why is it better?
08:51:09 <asthasr> gehmehgeh: Thanks!
08:51:13 <asthasr> gehmehgeh: not you.
08:51:17 <asthasr> geekosaur: you.
08:51:38 <prophile> asthasr: clearer and [potentially, depending on the situation] faster
08:55:04 <asthasr> prophile: *nod*
08:55:59 <asthasr> prophile: Thanks :)
08:56:28 <prophile> asthasr: no worries!
09:01:14 <kaiyin> :t join Just 5
09:01:15 <lambdabot>     Couldn't match type ‘a0 -> a’ with ‘Maybe a0’
09:01:15 <lambdabot>     Expected type: a0 -> a0 -> a
09:01:15 <lambdabot>       Actual type: a0 -> Maybe a0
09:01:24 <kaiyin> :t join $ Just 5
09:01:25 <lambdabot> Num (Maybe a) => Maybe a
09:02:57 <lajto> What are the steps to build a graph database from scratch in Haskell? Any recommendations?
09:03:10 <kaiyin> Why is it Num (Maybe a) => Maybe a ?
09:03:21 <HeladoDeBrownie> kaiyin, 5 is a polymorphic value (Num a) => a
09:03:22 <vanila> Just 5 has type  m a for some number a
09:03:29 <vanila> but it expects m (m a)
09:03:40 <vanila> so it figures that a is Maybe something
09:04:22 <kaiyin> > join Just 5
09:04:23 <lambdabot>  Couldn't match type ‘a0 -> a’ with ‘Data.Maybe.Maybe a0’
09:04:23 <lambdabot>  Expected type: a0 -> a0 -> a
09:04:23 <lambdabot>    Actual type: a0 -> Data.Maybe.Maybe a0
09:04:40 <kaiyin> > join $ Just Just 5
09:04:41 <lambdabot>  Couldn't match expected type ‘a1 -> m (m a)’
09:04:41 <lambdabot>              with actual type ‘Data.Maybe.Maybe (a0 -> Data.Maybe.Maybe a0)’
09:05:02 <HeladoDeBrownie> you shot beyond one mistake and into another :)
09:05:07 <HeladoDeBrownie> > join (Just 5)
09:05:08 <lambdabot>  No instance for (GHC.Show.Show a0)
09:05:08 <lambdabot>    arising from a use of ‘M79865447802104718309020.show_M79865447802104718309...
09:05:08 <lambdabot>  The type variable ‘a0’ is ambiguous
09:05:21 <HeladoDeBrownie> > join (Just (Just 5))
09:05:22 <Iceland_jack> > join (Just (Just 5))
09:05:22 <lambdabot>  Just 5
09:05:23 <lambdabot>  Just 5
09:05:36 <kaiyin> > join $ Just $ Just 5
09:05:38 <lambdabot>  Just 5
09:07:19 <prophile> > instance (Num a) => Num (Maybe a) where { (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = pure . fromInteger }
09:07:20 <lambdabot>  <hint>:1:1: parse error on input ‘instance’
09:07:46 <prophile> ah well
09:08:47 <HeladoDeBrownie> you can probably @let that
09:08:57 <prophile> @let instance (Num a) => Num (Maybe a) where { (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = pure . fromInteger }
09:08:59 <lambdabot>  Defined.
09:09:02 <prophile> intriguing
09:09:12 <prophile> > join (Just 5)
09:09:14 <lambdabot>  Just 5
09:09:15 <bananagram> > join $ Just $ Nothing
09:09:16 <lambdabot>  Nothing
09:09:17 <HeladoDeBrownie> > 5 + 5 :: Maybe Integer
09:09:18 <lambdabot>  Just 10
09:10:05 <_2_chop1234> hi
09:18:34 <flexfit> I'm reading through the LYAH guide, and I'm a little confused about list comparison. As long as the heads of the lists match, it will return true? so [1,2] < [0,9000] returns true
09:19:44 <flexfit> I would think that every element would have to match in order for it to be true. So [1,2] < [0,9000] would only return true if 1 < 0 && 2 < 90000
09:23:37 <kadoban> flexfit: It's lexicographic comparison. It works kinda like sorting in a dictionary, etc. Your choice would probably also be valid, but would be difficult in the case of infinite strings, for instance.
09:24:05 <kadoban> s/infinite strings/infinite lists/
09:25:00 <indiagreen> flexfit: «[a,b] < [x, y]» is the same as «a < x || (a == x && b < y)»
09:26:33 <flexfit> I just want to make sure I understand this. So when you compare lists, they only compare the first element of the lists?
09:26:42 <indiagreen> nope
09:26:48 <indiagreen> you compare 1st elements
09:26:55 <indiagreen> if they are equal, you compare 2nd elements
09:27:11 <kadoban> flexfit: No. It compares until elements at matching locations aren't equal. If one ends first, that gives a result too.
09:27:37 <flexfit> So it compares the first elements that are not equal? unless you're checking for equality?
09:27:44 <kadoban> > "blah1" < "blah2"
09:27:45 <lambdabot>  True
09:28:12 <tommd> Is anyone in here familiar with SBV internals?
09:28:20 <Procian> flexfit: It's lexicographic, literally the dictionary order. Imagine compiling the dictionary of all lists. The lists starting with zero come before the lists starting with 100. The lists starting with zero and then one come before the lists starting with zero and then 100.
09:28:23 <kadoban> flexfit: Yeah, I suppose that's a valid way of thinking about it.
09:34:48 <merijn> flexfit: Think of it as "dictionary ordering", i.e. "aaa" comes before "aba" which comes before "abc"
09:39:38 <CrepeSuzette> hey. I have a 3-lines program to display the arg 1 from the command-line but it complains about getArgs not in the scope
09:39:55 <CrepeSuzette> I guess I need to include something? (complete noob here)
09:40:00 <CrepeSuzette> main = do
09:40:13 <CrepeSuzette>  ( arg1 : arg2 : _ ) <- getArgs
09:40:13 <brainacid> Hello
09:40:21 <CrepeSuzette> print arg1
09:40:26 <Clint> @hoogle getArgs
09:40:28 <lambdabot> System.Environment getArgs :: IO [String]
09:40:28 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
09:40:28 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
09:41:01 <slack1256> @where ezyang
09:41:01 <lambdabot> I know nothing about ezyang.
09:41:18 <athan> CrepeSuzette: Just do an `import System.Environment` after your module statement
09:41:32 <athan> (like how Clint pointed out!)
09:41:33 <CrepeSuzette> I don't have a module statement..
09:41:37 <athan> erm
09:41:39 <athan> you should
09:41:43 <CrepeSuzette> I just declared main = do on the first line
09:42:08 <athan> just make it a habbit i guess - `module Main where` at the very top
09:42:10 <CrepeSuzette> so I name my file for instance Args.hs, then I write module Args where
09:42:10 <kadoban> Well, you should have a module statement, but even without you can still do imports.
09:42:12 <CrepeSuzette> import ....
09:42:16 <CrepeSuzette> like that?
09:42:25 <athan> (because it's the entry point to the program)
09:42:30 <athan> yep!
09:42:36 <CrepeSuzette> okay, thanks
09:42:38 <athan> `import System.Environment`
09:42:42 <athan> no prob :)
09:43:06 <athan> kadoban: Ahh, thank you :)
09:47:42 <makalu> what is the difference between (.) and (>->) in Accelerate?
09:59:52 <Frivillig> One friend told me today choosing Haskell because of syntatic errors is like choosing solid diamond for roads because of wear and tear. To some extent I had to agree. It's the best but far from practical or economic.
10:00:25 <sinelaw> wat
10:00:31 <HeladoDeBrownie> was someone saying haskell was good because of its syntactic errors?
10:01:10 <Frivillig> Yes, because Haskell traps them early in compillation
10:01:22 <HeladoDeBrownie> i think you're confusing syntax errors with type errors, maybe?
10:01:26 <sinelaw> Frivillig, perhaps you mean type errors?
10:01:57 <sinelaw> why is haskell not practical?
10:01:57 <Frivillig> "Syntax errors" includes type errors in this context.
10:02:11 <sinelaw> Frivillig, syntax errors hardly ever means type errors
10:02:11 <HeladoDeBrownie> i also have to point out that some people would take 'the best but far from practical or economic' as a contradiction
10:02:16 <Confusion> What is the proper way to perform a series of IO actions (say reading responses from a server) and be able to stop as soon as some condition has been met? mapM effectively isn't lazy and performs all the IO actions. I understand why, but don't see any nice solution
10:02:20 <vanila> there's a difference between syntax and syntactic
10:02:27 <HeladoDeBrownie> and also that throwing up a strawman argument the moment you enter a channel comes across as trollish
10:02:34 <vanila> type errors are syntactic, because they come from syntactic analysis
10:02:47 <vanila> as opposed to e.g. dynamic type errors you only get when running a program
10:03:03 <sinelaw> Confusion, you aware of the packages pipes and conduit?
10:03:09 <vanila> it would be clearer to have said static but it's not exactly wrong
10:03:10 <brainacid> hello sinelaw
10:03:10 <Frivillig> HeladoDeBrownie, well "best" here is used to point to the poorest part of a program: errors. Then Haskell is the best.
10:03:22 <Confusion> sinelaw, I am now :)
10:03:40 <sinelaw> Confusion, ok, they might give you what you need
10:04:02 <sinelaw> Confusion, https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview
10:04:09 <sinelaw> brainacid, hi!
10:04:29 <Hijiri> maybe if solid diamond was cheap and easy to use
10:04:38 <HeladoDeBrownie> Frivillig, did you have a question, or did you just feel like expressing your opinion about that?
10:04:43 <sinelaw> Frivillig, a strong type system is also useful for understanding what the program does
10:04:45 <Confusion> sinelaw, Thanks
10:04:57 <Hijiri> it's DeBeers fault that diamond is expensive, just how the imperative cabal keeps us haskellers down
10:05:39 <Frivillig> HeladoDeBrownie, isn't it obvious I was searching for other opinions for if it is really worth it making it with Haskell?
10:05:49 <vanila> maybe someone who is just getting interested in haskell doesn't know the terms as precisely as you all do
10:05:58 <HeladoDeBrownie> Frivillig, to put it plainly, no. you could easily have just been looking to get a rise out of people
10:06:01 <vanila> and this is the channel for discussing haskell
10:06:23 <sinelaw> Frivillig, well, it's totally worth it even if you don't end up using it too much
10:06:24 <Frivillig> HeladoDeBrownie, would that be bad?
10:06:50 <Hijiri> well if you get a rise out of people to the detriment of other discussion that would be bad
10:07:12 <HeladoDeBrownie> Frivillig, anyway, now that we know that you're actually interested in haskell, why not have a look at some introductory texts to see for yourself? we usually suggest LYAH among others
10:07:16 <HeladoDeBrownie> @where lyah
10:07:16 <lambdabot> http://www.learnyouahaskell.com/
10:07:17 <sinelaw> Frivillig, when learning Haskell was the first time I felt "this is worth knowing regardless!", never had that experience with other programming languages (except perhaps the first)
10:07:33 <Hijiri> https://github.com/bitemyapp/learnhaskell imo
10:07:57 <Frivillig> sinelaw, really? I need four to five times more time doing it in Haskell instead of C# or C++
10:08:07 <Hijiri> to do what?
10:08:25 <Frivillig> To make some clever thing that takes thousand lines
10:08:37 <Hijiri> could you be more specific
10:09:13 <Frivillig> It could be filter calculation to find the right components.
10:09:32 <Hijiri> I don't know what that means
10:09:39 <vanila> just ignore him then
10:10:03 <tremon> Frivillig: needing more time doing to do something does not in itself diminish its value
10:10:07 <HeladoDeBrownie> Frivillig, if you do have any specific questions about haskell, feel free to ask in here
10:10:20 <HeladoDeBrownie> Frivillig, for now i suggest reading some introductions
10:10:24 <Hijiri> I think in general it takes less time for me to do something in haskell
10:10:29 <Hijiri> especially when you factor in debugging time
10:10:48 <Frivillig> tremon, that must of course be my point of view too or else I would already have my conclusion, but it is hard to support development in Haskell.
10:11:41 <vanila> Frivillig, I give you the benefit of the doubt and now this?
10:11:46 <Hijiri> why is it hard to support development in Haskell?
10:12:17 <Frivillig> Because as I said, it takes four to five times longer to write compared to C# or C++
10:12:44 <HeladoDeBrownie> Frivillig, many will say the opposite
10:12:53 <Procian> It takes me four of five times as long to write a 1000 line Haskell program than a 1000 line Java program.
10:12:54 <Procian> Agreed.
10:13:01 <kadoban> Frivillig: That is definitely not the case in my experience.
10:13:14 <Frivillig> HeladoDeBrownie, then what I'm seeking must obviously be: how!?
10:13:19 <HeladoDeBrownie> Frivillig, i think it's a matter of experience with the languages in question, which is one reason it's hard to answer the questions you've asked so far.
10:13:49 <HeladoDeBrownie> Frivillig, which is essentially why i directed you to lyah: if you want to know how, what better way than to experience it yourself?
10:14:05 <HeladoDeBrownie> (i.e., by learning and getting comfortable with the language)
10:14:54 <kadoban> Frivillig: Where did you get the 4-5 times thing?
10:15:46 <Frivillig> HeladoDeBrownie, that could be an explanation, but I feel the answer is no. I do have experience from getting better in the two other languages and even if I assume the same curve of cleverness I fail to see how Haskell programming can ever be as fast as those.
10:15:54 <exio4> Frivillig,  what do you measure? lines of code? if you do, most will agree, Haskell tends to be "terse" compared to most languages you probably know, in terms of "getting things done", most will disagree..
10:16:04 <exio4> Frivillig, fast, performance-wise?
10:16:05 <kadoban> Frivillig: If it's personal experience based on someone just starting to learn the language, that'd be...excepted and almost meaningless. It's basically guaranteed that a lanugage you're learning is slower to use than one you know well.
10:16:17 <kadoban> s/excepted/expected/
10:17:24 <HeladoDeBrownie> i actually do think it's harder to write 1000 lines of haskell than 1000 lines of c#. after all, there's a lot more functionality in 1000 lines of haskell
10:17:54 <exio4> it is a thing that in Haskell you can keep "learning new concepts", and become even more "productive" over time, using "better" abstractions. and what not
10:17:59 <Frivillig> kadoban, that doesn't answer my question. I already said I have experience from getting better in a few languges and know the path. The only way to show me wrong is to point out that Haskell has a steeper curve so the final result will get better.
10:18:17 <vanila> You don't have to be very clever to program in haskell
10:18:42 <exio4> it is a simple language with some evil-named things like burritos and what not!
10:19:17 <Frivillig> I prefer nomads over burritos
10:19:33 <Hijiri> do you know any other functional languages?
10:19:34 <sinelaw> nomads eat burritos, don't you know
10:19:50 <Hijiri> If haskell it your first FPL, you also have the learning curve of functional programming
10:20:00 <kadoban> Frivillig: Your experience, making assumptions based on my own, is probably mostly a bunch of imperative languages that aren't all that different from each other. The learning curve for something as different as Haskell /is/ steeper, in that case.
10:20:00 <Frivillig> Hijiri, I know Ecmascript pretty well
10:20:07 <exio4> it isn't a functional language
10:20:09 <Hijiri> ecmascript isn't really that functional
10:20:12 <HeladoDeBrownie> es is not quite the kind of functional we had in mind
10:20:19 <Hijiri> there is a lot of support for imperative-style programming
10:20:23 <HeladoDeBrownie> to be fair, though, "functional" is almost meaningless
10:20:30 <Frivillig> Well, it really is functional program if you like it to be
10:20:30 <HeladoDeBrownie> Hijiri, the same can be said of haskell
10:20:32 <exio4> we're talking about things like some ML, Scheme, and something "like that"
10:20:43 <Hijiri> HeladoDeBrownie: I guess
10:20:44 <sinelaw> I for one never program in dysfunctional languages
10:21:02 <HeladoDeBrownie> i would include ml, haskell, agda, and idris among the sorts of languages we're talking about
10:21:04 <Procian> A fuctional language has first class functions, where are dinner parties for posh people.
10:21:06 <HeladoDeBrownie> but not lisp
10:21:06 <exio4> dysfunctional languages are the worst! specially the ones with multiple inheritance!
10:21:27 <sinelaw> yeah, that's a legal nightmare
10:21:33 <bernalex> HeladoDeBrownie: lisp is a language family which permits the kind of programming we are talking about. the ml family more keenly encourages.
10:21:34 <sinelaw> not to mention taxes
10:21:39 <HeladoDeBrownie> but then again you could make all sorts of arguments for what to include as functional and not. either way, those languages i mentioned are all, in my opinion, "similar enough" to have significant overlap in learning
10:21:42 <exio4> HeladoDeBrownie, I was specific about scheme
10:21:54 <bernalex> *encourages it.
10:22:02 <kadoban> Procian: I've found that it usually requires more than that. For example, python has first-class functions, but writing in functional style in python is pretty crap.
10:22:22 <CrepeSuzette> then you wouldn't include OCaml, because it has OOP?
10:22:25 <HeladoDeBrownie> i don't mean to say that other people are wrong, they probably also have good reasons to mention the languages they do
10:22:27 <bernalex> you can write functional C++ or Java. it's just not that fun.
10:22:30 <Frivillig> Functional programming is basically programming without side effects. No more no less.
10:22:35 <Hijiri> ML is including OCaml, I think
10:22:42 <sinelaw> Frivillig, that's not really possible
10:22:43 <HeladoDeBrownie> Frivillig, not really
10:22:49 <bernalex> sinelaw: sure it is.
10:22:53 <Frivillig> sinelaw, then we use nomads
10:22:54 <Hijiri> also last I heard the OO in OCaml wasn't all that popular
10:22:54 <sinelaw> what would a program without side effects do?
10:22:57 <vanila> @ops
10:22:57 <lambdabot> Maybe you meant: pl oeis docs
10:23:00 <vanila> @where ops
10:23:00 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
10:23:05 <sinelaw> compute itself?
10:23:05 <HeladoDeBrownie> vanila?
10:23:08 <Hijiri> although maybe I heard wrong
10:23:09 <bernalex> sinelaw: construct programs that when evaluated in RTS have effects.
10:23:10 <kadoban> Frivillig: Not really. That's more like "purely functional" which is pure + functional
10:23:13 <bernalex> sinelaw: that's what haskell does, anyway.
10:23:22 <vanila> can someone do something about this trolling
10:23:39 <sinelaw> bernalex, that's true also about C
10:23:40 <sinelaw> http://conal.net/blog/posts/the-c-language-is-purely-functional
10:23:45 <Frivillig> kadoban, like red red is the true red?
10:23:55 <HeladoDeBrownie> i think this is actually in that sweet spot where it could easily be simple confusion or trolling
10:24:12 <kadoban> Frivillig: I don't understand your (presumably rhetorical) question.
10:25:01 <Frivillig> kadoban, your objection basically say my interpretation of functional is too strong.
10:25:14 <HeladoDeBrownie> Frivillig, it depends what you mean by "side effects"
10:25:52 <Frivillig> Do we really benefit from lapsing to a war of definitions?
10:25:56 <sinelaw> Frivillig, what was your question again?
10:25:58 <tremon> Frivillig: I'd say too limited, rather. having well-defined and encapsulated side effects is a requirement, not a definition
10:26:05 <HeladoDeBrownie> Frivillig, it's not a war, it's clarifying what you're talking about.
10:26:06 <Frivillig> sinelaw, scroll
10:26:14 <sinelaw> Frivillig, i didn't get it the first time
10:26:44 <bernalex> sinelaw: and conal is right. :-]
10:26:46 <vgrbr> hi I'm working on upenn CIS 194 course (http://www.seas.upenn.edu/~cis194/lectures.html) anybody learning haskell this way?
10:26:55 <kadoban> Frivillig: You gave a definition of functional programming which I disagree with, so...I'm not sure how to avoid disagreeing on it. *shrug*
10:27:12 <vanila> hi vgrbr
10:27:24 <kadoban> Frivillig: If the definition doesn't matter, then you're free to go on with whatever point you're working on without addressing the disagreement.
10:27:30 <vgrbr> hi vanila
10:27:31 <Nik05> vgrbr i did those exercises last year
10:28:06 <Frivillig> HeladoDeBrownie, well, I need a minute to figure out what _I_ mean by "side effects", but I doubt it is different from what's commonly accepted.
10:28:30 <Hijiri> vgrbr: it's the "official" first tutorial in #haskell-beginners guide
10:28:47 <vgrbr> Nik05 could you send me your solutions, i'm looking for solutions to compare with my own
10:28:54 <Hijiri> so there are lots of people there who have taken and are taking it there
10:29:03 <Hijiri> for some value of lots
10:29:12 <Nik05> vgrbr i can try to find them, or you can ask questions about your solutions here ;)
10:29:36 <HeladoDeBrownie> Frivillig, i think what would be most productive right now, if your goal is to find out how some people can think haskell is nicer to code in, would be to think of specific features of haskell and ask things like "how does this help and/or hinder haskell?"
10:30:26 <vgrbr> Hijiri, didnt knew about it being the beginners choice =) made a good choice then
10:31:12 <vgrbr> Nik05, well, i have some very specific doubts, but it was mainly to see alternatives implementations
10:31:42 <Nik05> vgrbr ah i asked questions about those exercises here before
10:32:04 <sinelaw> Question: when parsing high-level haskell, does pattern matching on a data/newtype lead to an iso-recursive "unroll" expression? and does constructing lead to an iso-recursive "roll" expression?
10:32:25 <tasker> does anyone know if it is possible to convert Friday StorageImage to ByteString ?
10:32:26 <monochrom> every conversation that begins with "I heard" or "my friends said" should stop right there.
10:32:27 <kadoban> Frivillig: If your question is just along the lines of "Will working with haskell get more efficient as I learn it", then absolutely yes. I'm far from a haskell expert, and it's already far faster to code in than C++, to achieve the same resulting program.
10:32:35 <Frivillig> HeladoDeBrownie, I do agree that would be a good idea, but it doesn't really address my problem, namely at least four times more work time when programming in Haskell and the main reason for more time consumption is because I always feel the need for extra time to understand what I have done in Haskell. It may because I am still a noob to the syntax and feel insecure or maybe my brain is not
10:32:35 <Frivillig> constructed for it.
10:33:49 <HeladoDeBrownie> Frivillig, if that's not okay with you, and you don't want to put in the work of learning haskell, then feel free not to use it. if you do want to put in the work, start with the reading i or someone else suggested earlier.
10:33:52 <sinelaw> Frivillig, when writing code in perl I am also thousands of time less productive, because I have hardly any experience using it (close to zero)
10:34:10 * hackagebot duplo 1.6.0 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.6.0 (kenhkan)
10:35:17 <Frivillig> HeladoDeBrownie, that's hardly an answer to produce more Haskell programmers. Couldn't you say something more encouraging, like you felt the same way after a year of programming Haskell?
10:35:28 <vanila> monochrom, he has been trolling with inflammatory rhetorical claims designed to ilicit responses for ages, its stopping other discussions from happening
10:35:46 <vanila> sinelaw, its' not needed to insert roll/unroll - its not normally done that way
10:36:04 <sinelaw> vanila, I'm trying to figure how it IS done. any pointers?
10:36:34 <vanila> sinelaw, you can just represent patterns as they appear built out of constructors
10:37:01 <HeladoDeBrownie> Frivillig, my goal is not to produce more haskell programmers. and i can't say that, because after i learned about haskell i never felt it wasn't worth learning. my goal is, if your wish is to use haskell, to help you with that. but so far i can't really tell if that's your goal, so i'm making some guesses based on the information you've provided me.
10:37:36 <Procian> Why is it that #haskell chatters always emphasise the word "so"?
10:37:37 <mattp_> whats the recommended haskell learning resource these days?
10:37:45 <Hijiri> https://github.com/bitemyapp/learnhaskell
10:37:45 <Procian> It's so pretentious.
10:39:00 <mattp_> Hijiri: thx
10:39:14 <vanila> Procian, You are being rude
10:39:44 <Procian> vanila: so rude?
10:39:46 <mattp_> Procian: what is?
10:39:48 <HeladoDeBrownie> Frivillig, i'll tell you one thing though, all of us here put in effort to learn haskell (and even programming in general). i doubt that if you can comprehend other programming tools you will be unable to comprehend this one with some work
10:39:49 <vanila> What was the other haskell compilers book than SPJ lester? I forgot the link
10:40:24 <vanila> it has a chapter by Wadler on compiling pattern matching
10:40:29 <Frivillig> HeladoDeBrownie, you're damn right it's not my goal to make Haskell work for me. My goal is to find and use the most effective programming language and too degree I felt the need to start using Haskell because I saw there was potential.
10:40:42 <sinelaw> vanila, I'm specifically trying to understand how iso-recursive types are implemented
10:40:45 <sinelaw> in the type inference
10:40:59 <zomg> Frivillig: haskell takes a while to learn if you're not familiar with the style, certainly made my head hurt at first
10:41:11 <vanila> sinelaw, there is nothing extra about implementing them, just start your context out with all the constructors having their types
10:41:15 <zomg> coming from imperative non fp langs, even with familiarity of fp concepts in those langs
10:41:24 <HeladoDeBrownie> Frivillig, if your hope was that someone would make a profound statement about haskell that would convince you it's worth it, i'm afraid you'll be disappointed. you will need to see for yourself whether it's worth it for you and that requires the effort of learning it.
10:41:29 <vanila> sinelaw, e.g.   Nothing :: forall a. Maybe a ; Just :: forall a. a -> Maybe a |-  <do typechecking here>
10:41:39 <vanila> since consrtructors are just normal values, you can typecheck the just the same
10:41:50 <sinelaw> vanila, that's not a recursive type
10:41:50 <vanila> (and nothing changes when they are recursive)
10:41:55 <sinelaw> ah.
10:42:03 <HeladoDeBrownie> Frivillig, if you've already decided you don't want to learn it better, then it sounds like you have your answer.
10:42:57 <sinelaw> vanila, ok
10:42:58 <Frivillig> zomg, for how long did it hurt? I have done three projects where Haskell was used 30% in the code and now I feel it would be a better idea if everything was done in C++ and that's not a good feeling after so much effort learning Haskell.
10:44:06 <zomg> Frivillig: quite a while. I did mostly random things at first, spending some weeks and then doing something else and coming back again later
10:44:10 <sinelaw> Frivillig, it can hurt for a long time, but in my case I ended up seeing the light, even if I wouldn't be use it all that much I fell like I've learnt a lot and it was totally worth the effort.
10:44:18 <sinelaw> *using
10:44:26 <zomg> Frivillig: but it eventually started making more sense =)
10:45:00 <zomg> now using other langs, I tend to miss features I'd have if I was using Haskell
10:45:04 <sinelaw> Frivillig, it helps if at first you do only self-contained projects that can be in idomatic haskell and don't need to interact with other languages
10:45:25 <Frivillig> I would really like to know what "long time" means. I have done Haskell for 15 months after 3 week course and it still hurts really bad.
10:46:02 <sinelaw> Frivillig, it depends on how much effort you put into learning more and how much code you end up writing
10:46:24 <Frivillig> I have been writing about 200 lines Haskell each day for 15 months
10:46:35 <Frivillig> That's 200 lines of production code
10:46:35 <ReinH> vanila: ping
10:46:48 <vanila> hey!
10:47:18 <Nadrieril> Frivillig: imho, it also depends on what kind of programs you do
10:47:20 <Hijiri> it might help to get feedback on your code
10:47:20 <HeladoDeBrownie> Frivillig, also i'm sorry if i misread your intentions earlier, i really couldn't tell what you came in here to do
10:47:37 <Frivillig> Nadrieril, mostly math stuff related to electronics
10:47:49 <ReinH> vanila: Trifecta is so nice for parsing PLs :) https://gist.github.com/reinh/201f01f7c6c309312441
10:48:04 <HeladoDeBrownie> Frivillig, right now it sounds like you're frustrated and i understand that, it can be a struggle to learn new tools, especially ones so different from the ones you already know as haskell is
10:48:06 <sinelaw> Frivillig, what kind of math stuff?
10:48:07 <Nadrieril> I find Haskell perfect for "functional" tasks, like parsing but less fine for event- or UI-related tasks, for example
10:48:22 <int-e> Frivillig: also are you getting any kind of feedback on that code? do you get the feeling that the code you write today is more elegant than what you did 12 months ago?
10:48:34 <Nadrieril> Although it does that quite well too
10:48:37 <Frivillig> sinelaw, mostly filter stuff
10:48:58 <vanila> ReinH, Applicative parsing looks awesome! I have yet to use this
10:49:00 <ReinH> I don't think I wrote any good Haskell code for the first 3 years, fwiw
10:49:15 <ReinH> vanila: I love how closely it matches the EBNF
10:49:19 <Procian> Nadrieril: There are some types of program, such as UI-intensive stuff, where I feel like I'm defiling Haskell by coding it.
10:49:20 <sinelaw> Frivillig, are you using any libraries for that?
10:50:14 <HeladoDeBrownie> Procian, it helps once you get over the idea that you're not supposed to do heavy mutation in haskell :) for what it's worth there are nicer abstractions for many things like that but it's not necessarily bad to do that "UI-intensive stuff" in haskell
10:50:33 <Nadrieril> Procian: I understand you ^^
10:50:35 <HeladoDeBrownie> (nicer abstractions that may or may not have been written yet)
10:50:42 <sinelaw> Frivillig, such as dsp? http://hackage.haskell.org/package/dsp
10:50:43 <Frivillig> int-e, yes, first I felt it was much, much more elegant than C++ and then I found new ways of doint it simpler every month. That's not where the frustration is, but the feel I need to use so much time to be sure I have done what I want to. The work I am doing there is no practical way to check for errors other than static tests.
10:51:03 <ReinH> vanila: Oh the boolean parser is actually nicer than what I wrote. Fixed.
10:51:32 <Procian> HeladoDeBrownie: "Not written yet", exactly. If they ever figure out how to do it correctly, my bet is that it'll be done in Haskell.
10:52:02 <vanila> i like this ^^
10:52:15 <Frivillig> sinelaw, only basic libs.
10:52:58 <sinelaw> Frivillig, I learnt a lot by using various libraries - they taught me a lot about how I can write my own code
10:53:08 <sinelaw> the kinds of abstraction I could make, etc.
10:53:20 <monochrom> ReinH: I have some trouble with "dottedList = parens $ dottedList ...". ok, until I see later "where dottedList = ...". this is evil!
10:53:28 <Frivillig> There are no libs to support development of filters in Haskell, not even close.
10:53:31 <ReinH> monochrom: why evil?
10:53:35 <sinelaw> Frivillig, did you see dsp?
10:53:39 <vanila> ReinH, Would it be difficult to use Cons Datum Datum rather than List [Datum]? I remember the tutorial uses lists but some schemers had an issue with it
10:53:43 <sinelaw> Frivillig, linked above
10:53:45 <monochrom> too many dottedLists, too closely.
10:53:52 <Frivillig> sinelaw, sure, not what I need.
10:54:01 <ReinH> monochrom: Ah, just the name then?
10:54:01 <sinelaw> Frivillig, what do you need?
10:54:25 <monochrom> the shadowing that happens so close to the thing shadowed
10:54:26 <Frivillig> sinelaw, I need to calculate component values from a static set.
10:54:42 <sinelaw> pca?
10:54:51 <Frivillig> ?
10:55:02 <sinelaw> principal component analysis?
10:55:15 <Frivillig> No, filter construction
10:56:24 <ReinH> vanila: Well, the R6RS grammar calls it "<list>" and I'm trying to hew closely to it http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-7.html#node_sec_4.3.2
10:56:36 <ReinH> monochrom: there's... there's no shadowing?
10:56:47 <ReinH> monochrom: Oh.
10:56:49 <ReinH> OH GOD
10:56:54 <ReinH> monochrom: I didn't even realize
10:56:58 <ReinH> what have I done
10:57:03 <monochrom> :)
10:57:14 <ReinH> monochrom: mkDottedList?
10:57:26 <vanila> oh okay
10:57:56 <vanila> by the way, R7RS has been ratified now! I don't know if you want to go with R6RS but it's a lot shorter so that's a nice thing about it
10:58:06 <int-e> Frivillig: It may be your domain. array-based computation and loops really isn't Haskell's strength, and finding good abstractions for them can be hard. That said, there's Data.Vector and friends; there are various people doing audio processing in Haskell ... so it doesn't seem impossible.
10:58:53 <ReinH> vanila: ooh :)
11:00:49 <sinelaw> Frivillig, I agree with int-e, but one thing that may be helpful is to use newtypes to wrap up your numerical values in a way that prevents you from doing computations that don't make sense unit-wise
11:01:12 <Frivillig> int-e, that's not really the problem that the language doesn't support what I do directly. My problem is to feel ensured I wrote the code as I wanted. This is very important for me because there is no way to check my code for logical errors other than by static tests. This means I really need to understand my code.
11:01:50 <yac> http://hackage.haskell.org/package/netstring-enumerator why is this deprecated? By what?
11:02:16 <sinelaw> Frivillig, why do you feel the code is harder to understand than in C# (or whatever you were comparing it to)?
11:03:17 <brainacid> man i started with asm and C but Haskell is so amazing...i love to think in it...just wish I had more time to learn
11:03:40 <Kristien> that's because your brain is full of acid
11:03:51 <Frivillig> sinelaw, that's a damn good question. What I know for sure is that I feel the need to use four times as much for bug checks to get to the same degree of assurance.
11:04:15 <sinelaw> Frivillig, do you feel unit checking would be helpful?
11:04:25 <Nadrieril> brainacid: +1
11:04:28 <sinelaw> not sure if in your problems that's even an issue
11:04:36 <brainacid> Nadrieril, ;)
11:04:51 <hiptobecubic> with hmatrix you can do as well as C, but there isn't really anything as good as, say, Eigen in C++
11:05:03 <hiptobecubic> i saw "as well as" because it basically *is* just C anyway
11:06:01 <hiptobecubic> It's strange to me that there isn't an expression rewriting library for linear algebra in haskell
11:06:05 <hiptobecubic> As far as I've seen, anyway
11:06:22 <hiptobecubic> To make the best use of BLAS calls, for example
11:06:47 <Frivillig> sinelaw, no, not really. At least I can't see how
11:07:04 <CrepeSuzette> I don't understand, I did import Text.Printf and   main = do  printf "%d\n" (2::Int) and runghc  says "No instance for (PrintfType t0) arising from a use of `printf'. If I just write 2 instead of (2::Int) I got another error.
11:08:19 <Zemyla> Question. If one of my constructors for Set a is Set a = ... | forall b. MultiSet [b] a (b -> a -> a) | ...
11:08:22 <CrepeSuzette> (and it works in ghci)
11:08:48 <Zemyla> (Which would be constructed with a function Set a -> Set [a])
11:09:14 <sinelaw> Frivillig, what's the difference in how you do the filter stuff in haskell compared to C#
11:09:31 <indiagreen> CrepeSuzette: what's your version of GHC? it works for me with 7.8.3
11:09:50 <CrepeSuzette> 7.6.2
11:09:56 <Zemyla> Then I can have a function on MultiSet produce values with type a from the list of bs and the cons function stored inside, right?
11:09:57 <monochrom> CrepeSuzette: I just tried 7.8.3, no error.
11:10:00 <sinelaw> s/in/between/
11:10:25 <monochrom> also 7.6.3 no error
11:11:20 <CrepeSuzette> oh. I commented out the first line "module Args" and it works.. module may not have main?
11:11:31 <indiagreen> ah
11:11:43 <indiagreen> interesting catch
11:11:45 <monochrom> replace "Args" by "Main"
11:11:53 <CrepeSuzette> ah ok. thanks
11:12:08 <indiagreen> it must be because in non-Main modules “main” doesn't even have to be IO something?
11:12:12 <CrepeSuzette> ok it works
11:12:14 <brainacid> hey all
11:12:44 <monochrom> indiagreen, it's because runghc (and when ghc produces an exe) look for Main.main, not just any main.
11:13:14 <monochrom> plus a rule: if you don't say "module XXX", it implicitly defaults to "module Main(main)"
11:14:11 <monochrom> read the Haskell 2010 Report from cover to cover for more details!
11:14:17 <CrepeSuzette> and now I'm trying printf "%d\n" (length getArgs)  but still error (with import System.Environment on line 2)
11:14:43 <CrepeSuzette> Couldn't match expected type '[a0]' with actual type `IO [String]'
11:14:45 <monochrom> do { a <- getArgs; printf "%d\n" (length a) }
11:15:15 <kadoban> CrepeSuzette: getArgs isn't of type [a]. It's not a list.
11:15:16 <monochrom> for more details, read my www.vex.net/~trebla/haskell/IO.xhtml
11:15:18 <sinelaw> from cover to shiny beautiful cover
11:17:59 <brainacid> im working on some things and wanted to lpaste
11:18:40 <kadoban> brainacid: You have our blessing on your lpaste endeavours :)
11:24:00 <lpaste> brainacid revised “learningData :: data Client”: “learningData :: data Client” at http://lpaste.net/117345
11:31:35 <iElectric> so I have a function with signature: [String -> IO (Response ByteString)]
11:31:44 <iElectric> Response is a type from Wreq module
11:31:54 <iElectric> how do I print it in ghci?
11:32:21 <iElectric>     No instance for (Show (String -> IO (Response ByteString)))
11:32:24 <iElectric>       arising from a use of ‘print’
11:33:08 <k00mi> iElectric: what do you want to see?
11:33:32 <Procian> If you could print functions, you could equate them, and Turing would get cross.
11:33:33 <k00mi> in general you can't inspect and thus print functions in any meaningful way
11:34:14 * hackagebot MuCheck 0.1.2.0 - Automated Mutation Testing  http://hackage.haskell.org/package/MuCheck-0.1.2.0 (RahulGopinath)
11:34:33 <prophile> k00mi: I'm always a little unconvinced about the lack of a Show instance for functions
11:34:45 <prophile> as a debugging tool its not being there is painful
11:35:33 <Procian> prophile: I have a function f:a->b. How does it print?
11:35:40 <prophile> "f"
11:35:50 <prophile> or "<module>.f"
11:36:05 <k00mi> Procian: you could only equate them syntactically, which is clearly possible
11:36:10 <Procian> That's just on of its many names.
11:36:27 <iElectric> so I have http://paste.ofcode.org/sg5Su5yhPNru7eejHj3Q8b
11:36:30 <prophile> it's the name you gave for it
11:36:32 <iElectric> so I can't print out the result?
11:36:41 <prophile> as I said, my concern is with it as a debugging tool
11:37:00 <Procian> prophile: It also has the name "g" when passed as the argument to some other function.
11:37:42 <prophile> so what? it's still pointing at some block of code internally, no reason it can't be pointing at a name associated with that block of code internally
11:37:56 <k00mi> prophile: have a look at the simple-reflect package
11:38:17 <prophile> simple-reflect is very cool
11:38:46 <k00mi> iElectric: do you want to view the fetched pages?
11:38:46 <prophile> I'm more thinking of this as a general point in haskell though, it would be nice if show (const "bees") would give you "const \"bees\""
11:39:00 <Procian> It's pointing at some block of code is an implementation detail.
11:39:14 * hackagebot postgresql-simple 0.4.9.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.9.0 (LeonSmith)
11:39:17 <iElectric> k00mi: yes
11:39:19 <k00mi> Procian: and implementation details are important and helpful for actual programming
11:39:36 <prophile> ^ what k00mi said, particularly when debugging
11:39:53 <prophile> I'm not suggesting implementing Eq for functions, but Show would be very useful
11:40:29 <k00mi> iElectric: if you use 'mapM' instead of 'map' you get: IO [Response ByteString]
11:41:44 <Procian> The problem is that the "debugging-phase" isn't something that's clearly specified in the semantics of programming languages.
11:41:47 <exio4> > let f x y = (x::Int) == (y+x) in f
11:41:48 <lambdabot>  <Int -> Int -> Bool>
11:42:15 <Procian> So no, I don't want to be pointed at some particular implementation of functions on the machine I happen to be using. That fails the abstraction.
11:42:41 <iElectric> k00mi: thanks
11:42:45 <iElectric> that makes sense.
11:43:00 <Zol_> I'm working on some heavy state dependent logic in my simple MUD game, is there a prettier/easier way to handle the direction of the user than validation IO and then calling local functions (like a state machine)?
11:45:12 <indiagreen> Procian: in this case I want “debugging phase” to be clearly specified as “having binary compiled with --debugging-phase” flag, and in this “debugging phase” I want to have available some function which would give me syntax representation of functions/values, what module they come from, are they fully evaluated or not, string representation (with underscores instead of unevaluated parts), etc.
11:45:52 <exio4> use ghci
11:46:06 <Procian> indiagreen: So long as it's something that coders don't then come to rely on when they're not debugging, I'm probably happy.
11:46:40 <gfixler> Zol_: what are you validating? key presses?
11:49:00 <Zol_> gfixler: Input. I'm doing very simple parsing at the moment: https://github.com/Zolomon/PokemonArena/blob/master/src/Server.hs#L78-137
11:50:42 <Zol_> gfixler: For this instance I've implemented a simple finite state machine which traverses to a new state depending on user input.
12:11:22 <joeyh> is IncoherentInstances an extension to avoid, or ok in small amounts?
12:12:55 <njbartlett> Is anybody successfully using Haste? Bashing my head on a brick wall (aka Cabal) trying to get the damn thing installed..
12:13:14 <mauke> joeyh: it sounds evil
12:13:44 <joeyh> yeah, it kind of makes me want to split off a module with only the instance where I want to use it
12:19:17 * hackagebot MuCheck 0.1.2.1 - Automated Mutation Testing  http://hackage.haskell.org/package/MuCheck-0.1.2.1 (RahulGopinath)
12:23:03 <Stalkr_> Hello. I am just being a curious CS student; would there be anything interesting to learn from Haskell if I learn/already know some F#? I hear good stuff about Haskell, so I am curious
12:23:03 <Taneb> Stalkr_, I don't really know much of F# but there is laziness* and typeclasses which are interesting
12:23:19 <notdan> The answer is yes. I think Haskell has a more advanced type system (in virtue of not being tied to .NET), typeclasses and slightly different semantics
12:24:15 <Stalkr_> Taneb: Why laziness*? Do they both have it but differently?
12:24:18 * hackagebot blas-hs 0.1.1.0 - Low-level Haskell bindings to Blas.  http://hackage.haskell.org/package/blas-hs-0.1.1.0 (Rufflewind)
12:24:48 <Taneb> Stalkr_, because really Haskell is defined to have non-strict semantics, and laziness is one way you can do that
12:24:55 <Taneb> I don't know if F# has laziness?
12:25:07 <Taneb> But it lets you have infinite data structures
12:25:16 <Stalkr_> I don't know F#, I mention it because we'll learn it next semester
12:25:20 <Taneb> > [1..]
12:25:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:25:34 <Stalkr_> Ahh yes I heard about laziness in that regard
12:26:51 <notdan> Well, F# is still a very nice language, and having a certain background in functional programming will certainly help with Haskell
12:27:23 <Stalkr_> The most interesting project that I know and use [that use Haskell] is pandoc. What is Haskell's use? Does it solve anything better than say F#?
12:28:38 <Stalkr_> notdan: Definitely believe that. The most 'functional' experience I have is JavaScript and I am sure I abuse that language
12:33:31 <srhb> Stalkr_: They're both general purpose programming languages, so they don't solve anything "better" than F#
12:33:33 <notdan> Stalkr_: well there are tonns of stuff. From web frameworks to compilers. Haskell is a general-purpose language
12:33:40 <srhb> It's a more pleasant experience in Haskell, however.
12:34:02 <srhb> ... though this is #haskell, the F#'ers might disagree.
12:36:13 <Zemyla> :t map (:[])
12:36:14 <lambdabot> [a] -> [[a]]
12:38:34 <ij> (:[]) = return
12:38:57 <sinelaw> I'm officially frustrated by how field accessors are globally scoped
12:39:36 <Nadrieril> sinelaw: +1
12:39:48 <fizbin> Many, many people are.
12:40:00 <Nadrieril> import qualified...
12:40:07 <joeyh> huh, I did the splitting out, turned off a bunch of other extensions, and now seem not to need IncoherentInstances
12:40:10 <bimboum> hello all, I would like to map an enum like Data Bli = Bla
12:40:14 <bimboum> sorry
12:40:43 <Hijiri> map an enum?
12:40:52 <sinelaw> snippet for GHC source: DataDecl { tcdLName = tc, tcdTyVars = tyvars, ....
12:40:59 <sinelaw> "tcdLName", bah
12:41:00 <bimboum> hello all, I would like to map an enum like Data Bli = Bla | Blou | Blu to list elements where first one will be associated to Bla, the next one to Blou but automatically
12:41:07 <sinelaw> *from
12:41:35 <platz> F# is very nice, lack of higher kinded types and polymorphic dispatch on return types makes some haskell idioms hard to express in F#, but there are alternative F# techniques to get things done with slightly less aggressive code re-use
12:41:36 <Hijiri> if you give it a Bounded instance, you can do [minBound..maxBound], or if you know what part you want, [firstThing..lastThing]
12:41:46 <bimboum> So, I can change the enum later on and the list will be updated properly
12:41:51 <Hijiri> @define data Bli = Bla | Blou | Blu
12:41:53 <lambdabot>  Defined.
12:41:53 <Hijiri> yeah
12:42:00 <Hijiri> @define data Bli = Bla | Blou | Blu deriving (Enum, Bounded)
12:42:00 <lambdabot>  .L.hs:175:1:
12:42:00 <lambdabot>      Multiple declarations of ‘Bli’
12:42:00 <lambdabot>      Declared at: .L.hs:171:1
12:42:03 <bimboum> a bit like named initialized in c99
12:42:05 <notdan> enumFrom Bli
12:42:11 <geekosaur> bimboum, derive Enum and use something like zip [Bli..] yourlist ?
12:42:13 <Hijiri> @define data Blo = Bla | Blou | Blu deriving (Enum, Bounded)
12:42:14 <lambdabot>  .L.hs:175:12:
12:42:14 <lambdabot>      Multiple declarations of ‘Bla’
12:42:14 <lambdabot>      Declared at: .L.hs:171:12
12:42:17 <Hijiri> aa
12:42:29 <bimboum> initialized -> initializers
12:42:37 <fizbin> Unfortunately, @undefine is rather extreme.
12:42:41 <geekosaur> um, need a space in that because it looks like a qualified function
12:42:45 <geekosaur> [Bli ..]
12:42:52 <Hijiri> @define data A = A | B | C deriving (Enum, Bounded)
12:42:53 <fizbin> @undefine
12:42:54 <lambdabot>  Defined.
12:42:54 <lambdabot> Undefined.
12:42:54 <geekosaur> qualified operator rather
12:42:56 <Hijiri> @define data A = A | B | C deriving (Enum, Bounded)
12:42:58 <lambdabot>  Defined.
12:42:59 <indiagreen> bimboum: can you give an example of what you want
12:43:00 <indiagreen> also, ma-aybe consider naming them A, B and C instead
12:43:08 <Hijiri> [minBound..maxBound] :: [A]
12:43:13 <Hijiri> > [minBound..maxBound] :: [A]
12:43:14 <lambdabot>  No instance for (GHC.Show.Show L.A)
12:43:14 <lambdabot>    arising from a use of ‘M410562936965263470412196.show_M4105629369652634704...
12:43:18 <notdan> heh
12:43:22 <Hijiri> agh
12:43:23 <fizbin> @define data Bli = Bla | Blou | Blu deriving (Enum, Bounded)
12:43:24 <lambdabot>  Defined.
12:43:29 <Hijiri> you forgot Show too
12:44:06 <bimboum> indiagreen. Saying in C, enum {bli,bla,blu}; Then static int foo { [bli] = 2, [bla] = 3};
12:44:44 <bimboum> indiagreen:  static int foo[] = { [bli] = 2, [bla] = 3}; sorry
12:44:51 <Hijiri> > [minBound..maxBound] :: [Bla]
12:44:52 <lambdabot>  Expected kind ‘*’, but ‘L.Bla’ has kind ‘L.Bli’
12:45:00 <Hijiri> > [minBound..maxBound] :: [Bli]
12:45:01 <notdan> @define data A = A | B | C | D deriving (Enum, Bounded, Show)
12:45:02 <lambdabot>  [Bla,Blou,Blu]
12:45:03 <lambdabot>  Defined.
12:45:09 <notdan> > [A..C]
12:45:10 <lambdabot>  A section must be enclosed in parentheses thus: (A.. C)Not in scope: ‘A..’
12:45:11 <lambdabot>  Perhaps you meant ‘C..’ (imported from Control.Category)
12:45:13 <notdan> > [A..D]
12:45:14 <Hijiri> (I redefined Bli in query)
12:45:14 <lambdabot>  A section must be enclosed in parentheses thus: (A.. D)Not in scope: ‘A..’
12:45:14 <lambdabot>  Perhaps you meant ‘C..’ (imported from Control.Category)
12:45:17 <geekosaur> spaces
12:45:41 <geekosaur> "A..D" looks like a qualified operator applied to a single parameter
12:45:41 <notdan> argh, ok, sorry, I give up spamming the channel
12:46:00 <geekosaur> > [A .. D]
12:46:01 <lambdabot>  [A,B,C,D]
12:48:45 <Pamelloes> If I have a list a [1..] and a list b [10..], how do I get the difference between them? e.g. [1..9]
12:49:00 <hiptobecubic> So i have a little app that lets you translate text using an online service. The interface is text based, as in you type in commands and it either modifies the state of the app (set source or target language, display help, etc) or calls out to do the translation based on that state. I'm wondering what an appropriate structure is for such an application
12:49:03 <bimboum> indiagreen: I think the question is too vague. I am basically looking for good practices to map an enumeration to values
12:49:39 <geekosaur> Pamelloes, in that specific case you can't since both lists are effectively infinite and it would have to traverse one of them completely
12:49:52 <geekosaur> > [1..10] \\ [3..6]
12:49:53 <lambdabot>  [1,2,7,8,9,10]
12:50:00 <hiptobecubic> What's implemented already is a simple function to turn user input into an ADT representing the few commands we support and a monad transformer stack that can talk to the translation service while handling auth
12:50:13 <geekosaur> hm, that might be the opposite of what you want actually...
12:50:54 <Pamelloes> geekosaur: In my case, I have two infinite lists a and b that are identical only a has a bunch of elements at the start that b doesn't. Is there an easy way to get those elements?
12:51:00 <fizbin> @ty (\\)
12:51:01 <lambdabot> Eq a => [a] -> [a] -> [a]
12:51:09 <Peaker> Pamelloes: are they monotonically increasing?
12:51:17 <geekosaur> did you see my example above?
12:51:19 <hiptobecubic> Pamelloes, the problem is that the lists aren't *necessarily* sorted according to the types
12:51:34 <hiptobecubic> so you don't know if the end of the second list has an element in the beginning of the first list
12:51:42 <Pamelloes> Peaker: The contents of the list are effectively random.
12:51:59 <hiptobecubic> so you can't show any of the result until you've at least seen the entire list of "elements that should not be in the result"
12:52:16 <indiagreen> bimboum: I still don't quite understand. One interpretation I can think of is that you want something like fromEnum (e.g. “fromEnum A == 0, fromEnum B == 1”), except that you want to specify what values you want to get instead of 0, 1, etc. Am I far off?
12:52:27 <Peaker> Pamelloes: then how do you know when the "random elements at the start of a" end and the common sequence starts? It's infinite, after all
12:52:35 <Pamelloes> Hm.....
12:52:58 <Peaker> Pamelloes: you could discover, a million years from now, that they no longer equal, and you could explain it by having all elements so far be the "random elements" in the beginning of a
12:52:58 <Pamelloes> I didn't think of that. I guess I'll need to redesign some of my program :/
12:53:30 <indiagreen> bimboum: but then I don't understand what “So, I can change the enum later on and the list will be updated properly” means
12:53:51 <kaiyin>  :t foldr (liftA2 (:)) (pure []) [(+1), (+2)]
12:53:51 <kadoban> Pamelloes: Are there any limits on the number of arbitrary non-equal elemnts or anything? Otherwise, it's probably not possible
12:53:52 <gcganley> what is the current top of the hill GUI framework. I've never designed a desktop GUI but i have some experience with html and css. threepenny-gui looks good but im just curious if there is anything else out there that i should know about before commiting to one framework
12:54:00 <kaiyin> :t foldr (liftA2 (:)) (pure []) [(+1), (+2)]
12:54:01 <lambdabot> Num a => a -> [a]
12:54:17 <kaiyin> Why is it so?
12:54:56 <kadoban> kaiyin: Why not?
12:55:42 <kaiyin> kadoban, how can : be applied to pure [] and a function?
12:55:51 <indiagreen> bimboum: okay, I've read about designated initialisers in C90, I'll rewrite the examples in Haskell now
12:55:56 <Pamelloes> kadoban: There aren't any actual limits, so I guess it isn't possible.
12:55:59 <kaiyin> :t (:) (pure []) (+1)
12:56:00 <lambdabot>     Couldn't match expected type ‘[f [t]]’ with actual type ‘a0 -> a0’
12:56:00 <lambdabot>     In the second argument of ‘(:)’, namely ‘(+ 1)’
12:56:00 <lambdabot>     In the expression: (:) (pure []) (+ 1)
12:56:05 <bimboum> indiagreen: I think what I want seems to be a data array containing all the data per enum value iniatilized once using index/value pairs such that if I add more to the enum I have only one place to update and I can look up the array to get the data from the enum. Or maybe it is more idiomatic to use one function with guards
12:56:19 <kaiyin> :t liftA2 (:) (pure []) (+1)
12:56:19 <lambdabot> Num [[t]] => [[t]] -> [[t]]
12:56:47 <kaiyin> How is this exactly done?
12:56:47 <bimboum> indiagree: this function returning a record with everything I need (would be the same record I imagine than the one in the data.array)
13:01:28 <brainacid> does x:xs mean ... head and tail?
13:01:41 <brainacid> :t x:xs
13:01:42 <lambdabot>     Not in scope: ‘xs’
13:01:42 <lambdabot>     Perhaps you meant one of these:
13:01:42 <lambdabot>       ‘x’ (imported from Debug.SimpleReflect),
13:01:52 <Zekka> brainacid: (:) is one of the constructors for list
13:01:59 <brainacid> correct
13:02:01 <Zekka> So x:xs either conses or unconses x to xs
13:02:36 <brainacid> Zekka, so how dows that work in pattern matching im so consued
13:03:13 <Zekka> brainacid: [1, 2, 3] = 1:(2:(3:[])). (x:xs) = [1, 2, 3] -- x = 1, xs = [2, 3]
13:03:25 <Zekka> @let (x:xs) = [1, 2, 3]
13:03:26 <lambdabot>  Defined.
13:03:29 <Zekka> > (x, xs)
13:03:30 <lambdabot>  Ambiguous occurrence ‘x’
13:03:31 <lambdabot>  It could refer to either ‘L.x’, defined at L.hs:163:2
13:03:31 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.x’,
13:03:36 <Zekka> > (L.x, xs)
13:03:38 <lambdabot>  (1,[2,3])
13:03:49 <Zekka> @let (y:z:xs) = [1, 2, 3]
13:03:49 <brainacid> is that a tuple
13:03:49 <lambdabot>  .L.hs:164:11:
13:03:49 <lambdabot>      Multiple declarations of ‘xs’
13:03:49 <lambdabot>      Declared at: .L.hs:163:6
13:03:58 <Zekka> brainacid: I just used a tuple so I could print both
13:04:06 <brainacid> yes
13:04:08 <Zekka> L.x is 1 and xs is [2, 3] as you can see
13:04:14 <brainacid> so
13:04:16 <Zekka> The tuple doesn't really have any significance here
13:04:43 <brainacid> Zekka, i am trying to make a list of tuples
13:04:46 <brainacid> as in
13:05:10 <brainacid> [(Male, x), (Female, y)]
13:05:17 <srhb> > let x:xs = [(1,2), (3,4)] in x
13:05:19 <lambdabot>  (1,2)
13:05:34 <Zekka> brainacid: Something like this? (using Male and Female data constructors instead of strings)
13:05:46 <Zekka> > zipWith (,) ["male", "female"] ["x", "y"]
13:05:47 <lambdabot>  [("male","x"),("female","y")]
13:05:50 <brainacid> where Male and Female are defined: data Gender = Male | Female | Unknonw
13:05:59 <Zekka> (oh, and values x and y instead of strings)
13:06:03 <srhb> \msg lambdabot > let (a,b):xs = [(1,2), (3,4)] in b
13:06:05 <srhb> Woops
13:06:12 <brainacid> well I have a list of clients
13:06:17 <brainacid> here is my paste
13:06:32 <brainacid> http://lpaste.net/117345
13:07:38 <brainacid> im trying to make a function the looks at that list and counts all the males and females
13:07:49 <indiagreen> bimboum: okay, then you can use a list of [(Bli, Data)] which represents your mapping explicitly, and then use “lookup” to get Data from Bli. If you want it to be faster, use Map Bli Data. If you don't mind counting where is the -37th element of your mapping which you want to update- every time you want to update it, you can use a simple list of [Data] and then index it with (!! fromEnum bli). A better solution would be to use a Data.Array.Array
13:07:49 <brainacid> returning that list of tuples
13:07:51 <indiagreen> constructed from an explicit list of pairs with “array” – then you get both speed and self-documented code. If you don't want undefineds to occur, you can construct an array filled with default Data values and then use “//” to update it using a list of mapping pairs. Finally, if you don't have pairs, a function (or “case” statement) is the best choice because then GHC checks for you whether you've covered all possible Blis.
13:07:55 <srhb> :t filter
13:07:56 <lambdabot> (a -> Bool) -> [a] -> [a]
13:08:17 <Zekka> indiagreen: Was that for brainacid? I'm still reading
13:08:36 <indiagreen> nope, bimboum
13:08:54 <HeladoDeBrownie> in theory, do any inconsistencies arise if you allow in a hypothetical language: f (let datatype T = Foo | Bar in Foo), i.e., a locally defined datatype whose values escape its scope
13:09:03 <bimboum> indiagreen: Thanks!
13:09:36 <HeladoDeBrownie> if this is too off-topic i can leave it
13:09:56 <bimboum> indiagreen: I am going to play a bit with the options :-)
13:09:59 <indiagreen> bimboum: “if you don't have pairs” should've been “if you don't have that many pairs”
13:10:32 <srhb> brainacid: If you can write a function isMale p that is True only if p is an Individual and Male, then filter isMale clients does what you want.
13:12:07 <Zekka> srhb: I think he atually wants to zip each client with its classification
13:12:13 <Zekka> But he can do something similar
13:12:17 <srhb> Oh.
13:12:23 <brainacid> well guys im just reading this book
13:12:33 <Zekka> something like zipWith (,) <*> classify
13:12:36 <brainacid> and in so far we are discussing patter match
13:13:02 <brainacid> he hasnt used any of thos functions yet
13:13:15 <Zekka> (,) is the constructor for tuples of width two
13:13:20 <Zekka> and <*> is just a golfy shorcut
13:13:23 <Zekka> shortcut*
13:13:30 <brainacid> so far i have used case x of ... -> ...
13:13:54 <Zekka> Er, that would be map classify, come to think of it
13:14:11 <brainacid> func x = x
13:14:19 <brainacid> func y = x - 1
13:14:20 * hackagebot shell-monad 0.5.0 - shell monad  http://hackage.haskell.org/package/shell-monad-0.5.0 (JoeyHess)
13:14:22 <Zekka> \xs -> zipWith (,) (map classify xs) xs or \xs -> zipWith (,) xs (map classify xs), depending on your personal preference, would do the same
13:14:29 <brainacid> function defined with patterns
13:14:55 <brainacid> although i do appreciate the assistance
13:15:01 <brainacid> im still trying to understand
13:15:09 <brainacid> newbie programmer
13:15:14 <Zekka> brainacid: You have two subtasks here
13:15:22 <Zekka> You want to replace each element with its male-or-female classification
13:15:40 <Zekka> So, for a function classify that classifies the element (which you have to write yourself), you want to classify every element of your list
13:15:44 <Zekka> :t map
13:15:45 <lambdabot> (a -> b) -> [a] -> [b]
13:15:55 <Zekka> map turns a function on as into a function on [a]s
13:16:11 <Zekka> Then you want to match the classification with the original element for each element
13:16:16 <Zekka> :t zipWith
13:16:16 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
13:16:23 <exio4> zipWith (,) is zip
13:16:27 <exio4> :t zip
13:16:28 <lambdabot> [a] -> [b] -> [(a, b)]
13:16:35 <Zekka> exio4: Silly me! You're right.
13:16:47 <Zekka> zip takes two lists and joins corresponding elements
13:16:57 <Zekka> zipWith is zip taking a custom joining function
13:17:13 <Zekka> ('join' may be a poor word to use as there's another function called 'join' with a different type)
13:17:54 <bimboum> Coming from partially ocaml, it is sometimes a bit verbose to write pattern matching by "specializing" the function (not sure of the term) for each pattern. Is "case ... of" really considered bad practice, in particular for a enum?
13:18:29 <Zekka> bimboum: I don't think it's considered bad practicec most of the time, but often a type has properties that mean other functions like fmap express intent more clearly
13:18:44 <Peaker> bimboum: it's not considered bad practice, but the appeal of foo (Bar ..) = .. foo (Baz ..) = ..   is that it is syntactically like equational reasoning
13:19:03 <Peaker> bimboum: the syntax of definition and use become identical, which is nice
13:19:36 <bimboum> Peaker, Zekka: OK. I see the reasoning.
13:19:53 <pantsman-> I use case...of all the time, when I want to match only one parameter without repeating the rest
13:19:56 <Zekka> If I had to guess you would probably run into more oppositition to caseof vs i.e. fmap or foldr than to caseof vs lists of rules i.e. Peaker
13:20:31 <Peaker> I also use case-of to avoid repetition of any more than the function name
13:20:41 <Zekka> (even though foldr is totally isomorphic to pattern matching, unlike fmap)
13:21:10 <Peaker> Zekka: foldr is isomorphic to pattern matching? You mean to pattern-matching+recursion?
13:21:29 <Zekka> Peaker: Yeah! Whoops.
13:21:38 <Zekka> I'm full of errors today, apparently.
13:24:05 <exio4> foldr is isomorphic to lists!
13:24:11 <exio4> (does that even make sense? ^)
13:24:17 <bernalex> no
13:24:47 <Zekka> exio4: foldr is one thing and lists are a group of things
13:24:58 <Zekka> so I'm not sure I'd put it that way
13:25:11 <brainacid> thanks Zekka
13:25:15 <brainacid> still working on it
13:25:27 <Zekka> Partially-applied cases of foldr are isomorphic to lists
13:25:30 <Zekka> :t foldr
13:25:31 <lambdabot> (a -> b -> b) -> b -> [a] -> b
13:25:54 <Zekka> For any (a -> b -> b) -> b -> b you can get an [a] and for any [a] you can get an (a -> b -> b) -> b -> b
13:26:09 <Zekka> (I always trot that one out)
13:48:55 <ReinH> Yay initial and final encodings
13:49:33 <benzrf> Zekka: yes but neither is a bijection is it
13:50:02 <Zekka> benzrf: Aren't the pair of them a bijection?
13:50:09 <benzrf> hmm wait
13:50:20 <ReinH> Yes, they are isomorphic
13:50:32 <Zekka> Pass : and [] to the fold, and apply (the right argument of) foldr with the list
13:50:50 <benzrf> Zekka: yeah but the type of foldr is not unique to foldr
13:51:24 <Zekka> benzrf: Are you arguing that there are (a -> b -> b) -> b -> bs that cannot be represented as [a]s?
13:51:37 <Zekka> Because I'd argue that you can, just by passing (:) and [] to them.
13:51:46 <benzrf> no, i'm saying i don't know if that's a bijection
13:51:54 <benzrf> im not convinced it's injective
13:52:04 <ReinH> benzrf: this is a classic church encoding
13:52:09 <godel> you mean the composition gives the identity benzrf?
13:52:10 <Zekka> So anything having that type can be represented as a list, and hence as a partial-application of foldr (because you can apply foldr to it)
13:52:28 <benzrf> Zekka but is it injective
13:52:31 <ReinH> benzrf: yes.
13:52:36 <benzrf> oh
13:52:36 <Zekka> Injective in which way? Injective to folds or to lists? Maybe I'm misunderstanding
13:52:52 <benzrf> to lists
13:52:52 <ReinH> benzrf: http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html
13:52:55 <exio4> it is the lambda-calculus way of a sum type!
13:53:27 <exio4> or something like Y^X * Y^W == Y^(X+W) ? :P
13:53:31 <ReinH> benzrf: this is an example of a "Boehm-Berarducci isomorphism" as described in that link
13:53:45 <dreams> guys, is referential transparency "tied" or only possible without side-effects?
13:53:51 <ReinH> (it isn't actually a church encoding because it is typed)
13:53:54 <Zekka> benzrf: So you're trying to argue that you can't get every different list by working with some kind of (a -> b -> b) -> b -> b?
13:54:05 <godel> exio4: that reminds me of type derivatives :P
13:54:14 <Zekka> Or wait
13:54:23 <Zekka> I think I have injective and surjective backwards
13:54:45 <Zekka> You're arguing that you can't get every (a -> b -> b) -> b -> b by operating on a list?
13:56:23 <ReinH> foldr (:) [] xs = xs witnesses the isomorphism
13:56:54 <ReinH> as in, foldr (:) [] = (id :: [a] -> [a])
13:57:05 <ReinH> which you can easily show by equational reasoning
13:57:32 <benzrf> ReinH: no, the type
13:57:38 <ReinH> benzrf: ?
13:57:50 <benzrf> @let allegedIso f = f (:) []
13:57:52 <lambdabot>  Defined.
13:58:17 <benzrf> @let allegedIso :: (forall b. (a -> b -> b) -> b -> b) -> [a]
13:58:18 <lambdabot>  Defined.
13:58:29 <ReinH> What does it mean for a type to be an isomorphism?
13:58:30 <benzrf> ReinH: i'm not convinced that ^ is injective
13:58:35 <ReinH> Types are not arrows.
13:58:44 <benzrf> ReinH: allegedIso most certainly is
13:59:14 <ReinH> An arrow in what category?
13:59:18 <benzrf> Hask
13:59:26 <ReinH> Types are not arrows in Hask
13:59:36 <benzrf> ReinH: try reading better
13:59:38 <benzrf> 04:56 < benzrf> @let allegedIso f = f (:) []
13:59:38 <benzrf> 04:56 < lambdabot>  Defined.
13:59:40 <ReinH> Try explaining better.
14:00:24 <ReinH> Is someone claiming that all inhabitants of (a -> b -> b) -> b -> b are isomorphic to [a]?
14:00:36 <Zekka> Yeah, I did!
14:00:37 <bernalex> that makes zero sense
14:00:46 <ReinH> @djinn (a -> b -> b) -> b -> b
14:00:46 <lambdabot> f _ a = a
14:01:01 <ReinH> That's pretty obviously false
14:01:10 <Zekka> (\_ a -> a) (:) []
14:01:11 <benzrf> ReinH: no, look at the type
14:01:20 <Zekka> Oh, wait,' hold up a sec
14:01:34 <benzrf> ReinH: a is existential not universal
14:01:43 <benzrf> b is universal
14:01:45 <Zekka> benzrf: I think his still inhabits the correct type
14:01:51 <Zekka> > (\_ a -> a) (:) []
14:01:53 <lambdabot>  []
14:01:56 <notdan> I thought Zekka said that the type (a -> b -> b) -> b -> b is isomorphic to a type [a]
14:02:18 <benzrf> notdan: yeah, that seems to be assuming that a is existential
14:02:23 <Zekka> > (\z -> \x y -> foldr x y z) []
14:02:24 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
14:02:25 <lambdabot>    arising from a use of ‘M378137584926368476314030.show_M3781375849263684763...
14:02:25 <lambdabot>  The type variable ‘b0’ is ambiguous
14:02:25 <benzrf> that is to say, i think Zekka meant that
14:02:31 <benzrf> allegedIso :: (forall b. (a -> b -> b) -> b -> b) -> [a]
14:02:34 <benzrf> allegedIso f = f (:) []
14:02:37 <benzrf> is an isomorphism.
14:02:40 <Zekka> > ((\z -> \x y -> foldr x y z) []) 0 1
14:02:41 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> b -> b))
14:02:42 <lambdabot>    arising from the ambiguity check for ‘e_101’
14:02:42 <lambdabot>  from the context (GHC.Num.Num (a -> b -> b), GHC.Num.Num b)
14:02:51 <ReinH> That doesn't make sense
14:02:52 <Zekka> oh, phooey, I am making all the dumb mistakes
14:02:57 <Zekka> > ((\z -> \x y -> foldr x y z) []) (+) 1
14:02:58 <lambdabot>  1
14:02:58 <bernalex> I'm with ReinH here
14:03:05 <ReinH> (forall b. (a -> b -> b) -> b -> b) -> [a] is not the type of the final encoding of a list
14:03:06 <benzrf> ReinH: how nowt
14:03:07 <benzrf> *not
14:03:09 <ReinH> the final encoding of a list is
14:03:17 <benzrf> and what is that
14:03:26 <Zekka> ReinH: Doesn't this demonstrate that it holds true at least for Djinn's suggestion?
14:03:26 <ReinH> :t \f z -> foldr f z []
14:03:27 <lambdabot> (a -> b -> b) -> b -> b
14:03:38 <benzrf> wait
14:03:45 <benzrf> that's just [] though
14:03:53 <ReinH> I don't know what (forall b. (a -> b -> b) -> b -> b) -> [a] is
14:03:54 <Zekka> (being super informal about it -- you can expand teh equations yourself if you want to do and prove it holds in general for djinn's case)
14:04:11 <notdan> ReinH: it's a type of the alledged isomorphism between two types
14:04:11 <Zekka> ReinH: The type of the half of the bijection that turns partially-applied folds into lists
14:04:24 <kaiyin> @ data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
14:04:26 <ReinH> Ah.
14:04:32 <Zekka> The other half is [a] -> (forall b. (a -> b -> b) -> b -> b)
14:04:35 <benzrf> finally
14:04:37 <exio4> isn't "\f z -> foldr f z []" just z?
14:04:39 <kaiyin> :t Tree
14:04:40 <lambdabot>     Not in scope: data constructor ‘Tree’
14:04:40 <lambdabot>     Perhaps you meant ‘True’ (imported from Data.Bool)
14:04:57 <Zekka> exio4: Yeah, if you expand it
14:05:01 <kaiyin> How do I find out mempty of a monoid?
14:05:03 <benzrf> @let data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
14:05:04 <lambdabot>  .L.hs:168:23:
14:05:04 <lambdabot>      Ambiguous occurrence ‘Tree’
14:05:04 <lambdabot>      It could refer to either ‘L.Tree’, defined at .L.hs:167:1
14:05:11 <Zekka> kaiyin: By specializing mempty to the monoidal type?
14:05:18 <Zekka> > mempty :: And
14:05:20 <lambdabot>  Not in scope: type constructor or class ‘And’
14:05:20 <lambdabot>  Perhaps you meant ‘Any’ (imported from Data.Monoid)
14:05:22 <Zekka> > mempty :: Any
14:05:24 <lambdabot>  Any {getAny = False}
14:05:36 <kaiyin> > mempty :: Tree
14:05:37 <lambdabot>  Expecting one more argument to ‘Data.Tree.Tree’
14:05:37 <lambdabot>  Expected a type, but ‘Data.Tree.Tree’ has kind ‘* -> *’
14:05:48 <ReinH> kaiyin: What do you mean "find out"?
14:06:12 <Zekka> It looks like they don't mean "find out what mempty was declared as" but "find a value of mempty that makes sense"
14:06:14 <kaiyin> ReinH, just like Zekka did.
14:06:19 <Zekka> which depends on how your type is a monoid
14:06:55 <Zekka> Figure out a notion of monoidalness that makes sense for your tree type and then you'll know
14:06:58 <ReinH> You can evaluate mempty of that type or look up the definition
14:07:28 <kaiyin> But why didn't this work?
14:07:29 <kaiyin> :t Tree
14:07:30 <lambdabot>     Not in scope: data constructor ‘Tree’
14:07:30 <lambdabot>     Perhaps you meant ‘True’ (imported from Data.Bool)
14:07:45 <ReinH> If you're trying to write your own instance of Monoid, you just need to find the inhabitant of that type that satisfies the laws
14:07:48 <Zekka> kaiyin: Because "Tree" isn't a value, but a type constructor
14:08:11 <Zekka> "Empty" and "Node" are values
14:08:28 <kaiyin> > mempty :: Node 1 Empty Empty
14:08:29 <lambdabot>  Not in scope: type constructor or class ‘Empty’Not in scope: type constructo...
14:08:41 <Zekka> kaiyin: "Node 1 Empty Empty" is not a type
14:08:45 <Zekka> So mempty can't be of that type
14:08:52 <kaiyin> > mempty :: Node
14:08:52 <brainacid> man i am so stuck
14:08:53 <lambdabot>  Data constructor ‘Data.Tree.Node’ comes from an un-promotable type ‘Data.Tre...
14:08:57 <Zekka> This is probably what you mean (it still won't work)
14:09:06 <Zekka> kaiyin: Node is also not a type. It's a data constructor
14:09:09 <Zekka> > mempty :: Tree a
14:09:11 <lambdabot>  No instance for (Data.Monoid.Monoid (Data.Tree.Tree a1))
14:09:11 <lambdabot>    arising from a use of ‘Data.Monoid.mempty’
14:09:29 <Zekka> kaiyin: What that says is "you haven't told me how Tree is a monoid"
14:09:44 <kaiyin> ok.
14:09:51 <Zekka> So it can't tell you what mempty is until then
14:10:24 <ReinH> The tree defined by Data.Tree is not a monoid.
14:10:45 <ReinH> (And can't be one)
14:10:46 <kaiyin> ok, what does mempty mean here: http://lpaste.net/117351 ?
14:10:48 <benzrf> ReinH: it isnt?
14:10:56 <benzrf> ReinH: what about monoid a => monoid tree a
14:11:12 <ReinH> benzrf: That definition doesn't include an empty node: http://hackage.haskell.org/package/containers-0.5.6.2/docs/Data-Tree.html
14:11:28 <benzrf> huh?
14:11:33 <Zekka> kaiyin: Let's check out the type of foldMap
14:11:34 <benzrf> empty node?
14:11:39 <Zekka> :t foldMap
14:11:40 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
14:11:46 <benzrf> ReinH: Node mempty []?
14:12:06 <Zekka> kaiyin: Where f turns the things inside the tree into members of a Monoid type, mempty is the empty for that monoid type
14:12:13 <ReinH> benzrf: How would you define mappend?
14:12:32 <benzrf> ReinH: mappend (Node x xs) (Node y ys) = Node (x <> y) (xs <> ys)
14:12:36 <Zekka> So if foldMap takes (:[]), then mempty will be []
14:12:53 <Zekka> because [] is mempty for []
14:13:01 <ReinH> benzrf: That's an unusual tree monoid, but a legal one I suppose
14:13:06 <benzrf> :)
14:13:19 <Zekka> benzrf: Spicy!
14:16:57 <kaiyin> cool
14:19:41 <kaiyin> > mempty :: Int 1
14:19:42 <lambdabot>  ‘GHC.Types.Int’ is applied to too many type arguments
14:19:44 <kaiyin> > mempty :: Int
14:19:45 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
14:19:45 <lambdabot>    arising from a use of ‘Data.Monoid.mempty’
14:19:51 <kaiyin> > mempty :: Integer
14:19:52 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Integer.Type.Integer)
14:19:52 <lambdabot>    arising from a use of ‘Data.Monoid.mempty’
14:20:21 <vanila> > mempty :: Sum Integer
14:20:22 <lambdabot>  Sum {getSum = 0}
14:20:24 <vanila> > mempty :: Product Integer
14:20:25 <lambdabot>  Product {getProduct = 1}
14:20:25 <Zekka> kaiyin: Ints are a monoid in more than one way
14:20:49 <Zekka> So some types called Sum and Product exist as examples of ways that numeric types can be monoids
14:21:06 <kaiyin> ok
14:21:10 <kaiyin> :t (+)
14:21:11 <lambdabot> Num a => a -> a -> a
14:21:28 <kaiyin> :t (+) Int Int
14:21:29 <lambdabot>     Not in scope: data constructor ‘Int’
14:21:29 <lambdabot>     Perhaps you meant one of these:
14:21:29 <lambdabot>       ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
14:21:38 <kaiyin> :t ((+) Int Int)
14:21:39 <lambdabot>     Not in scope: data constructor ‘Int’
14:21:39 <lambdabot>     Perhaps you meant one of these:
14:21:39 <lambdabot>       ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
14:21:48 <exio4> Int is a type, not a value
14:21:50 <Zekka> kaiyin: Int isn't a value, but a type
14:21:59 <Zekka> So you can't apply (+), which is a function on values, to it
14:22:05 <kaiyin> ok
14:22:08 <kaiyin> :t 5 + 5
14:22:09 <lambdabot> Num a => a
14:22:13 <Zekka> You can apply type constructors to it, mind
14:22:28 <Zekka> > Just 1 :: Maybe Int
14:22:29 <lambdabot>  Just 1
14:22:43 <Zekka> Maybe is intuitively a function from types to types
14:22:46 <Zekka> :k Maybe
14:22:47 <lambdabot> * -> *
14:22:52 <kaiyin> > mempty :: Sum Int
14:22:53 <lambdabot>  Sum {getSum = 0}
14:23:01 <kaiyin> > mempty :: Product Int
14:23:02 <lambdabot>  Product {getProduct = 1}
14:24:00 <kaiyin> @let testTree = Node 5
14:24:00 <kaiyin>             (Node 3
14:24:00 <kaiyin>                 (Node 1 Empty Empty)
14:24:00 <kaiyin>                 (Node 6 Empty Empty)
14:24:00 <kaiyin>             )
14:24:01 <kaiyin>             (Node 9
14:24:01 <lambdabot>  Defined.
14:24:03 <kaiyin>                 (Node 8 Empty Empty)
14:24:05 <kaiyin>                 (Node 10 Empty Empty)
14:24:07 <kaiyin>             )
14:24:20 <benzrf> kaiyin: please
14:24:33 <kaiyin> Sorry.
14:24:44 <Zekka> :t testTree
14:24:45 <lambdabot> Num a => Forest a -> Tree a
14:25:01 <kaiyin> Is there a better way to load things?
14:25:23 <benzrf> kaiyin: @letlpaste
14:25:30 <kaiyin> Oh, cool.
14:25:35 <benzrf> kaiyin: make a lpaste then @letlpaste <number>
14:25:38 <Zekka> Do you know about lpaste? It's in the channel topic
14:25:53 <kaiyin> @letlpaste http://lpaste.net/117352
14:25:53 <lambdabot>  Invalid paste ID.
14:26:02 <kaiyin> @letlpaste 117352
14:26:03 <lambdabot>  .L.hs:167:1:
14:26:03 <lambdabot>      Multiple declarations of ‘testTree’
14:26:03 <lambdabot>      Declared at: .L.hs:166:1
14:26:13 <kaiyin> Cool.
14:26:45 <kaiyin> Zekka, where does Forest come from?
14:27:03 <Zekka> :t Node
14:27:04 <lambdabot> a -> Forest a -> Tree a
14:27:38 <brainacid> matching patterns in custom data
14:27:43 <Zekka> kaiyin: I don't know what a Forest is but apparently you needed one to finish your testTree (because it only read the very first line)
14:28:06 <brainacid> data Client = Individual Person Bool
14:28:17 <brainacid> data Person = Person String String Gender
14:28:30 <brainacid> data Gender = Male | Female | Unknown
14:28:37 <dreams> Can someone point out a paper that discuss Haskell's type system?
14:29:06 <kaiyin> > empty :: Bool
14:29:06 <brainacid> let x = (Individual (Person "Me" "Last" Male) True)
14:29:07 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
14:29:08 <lambdabot>              with actual type ‘f0 a0’
14:29:23 <kaiyin> > empty :: True
14:29:23 * hackagebot MuCheck 0.1.2.2 - Automated Mutation Testing  http://hackage.haskell.org/package/MuCheck-0.1.2.2 (RahulGopinath)
14:29:24 <lambdabot>  Expected a type, but ‘GHC.Types.True’ has kind ‘GHC.Types.Bool’
14:29:25 * hackagebot hob 0.0.1.0 - A source code editor aiming for the convenience of use  http://hackage.haskell.org/package/hob-0.0.1.0 (rakatan)
14:29:42 <kaiyin> > mempty :: Bool
14:29:43 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Bool)
14:29:43 <lambdabot>    arising from a use of ‘Data.Monoid.mempty’
14:30:36 <kaiyin> @letlpaste 117352
14:30:37 <lambdabot>  .L.hs:168:28:
14:30:37 <lambdabot>      Not in scope: data constructor ‘Empty’
14:30:37 <lambdabot>      Perhaps you meant one of these:
14:31:48 <kaiyin> @letlpaste 117352
14:31:49 <lambdabot>  .L.hs:166:12:
14:31:49 <lambdabot>      Ambiguous occurrence ‘Node’
14:31:49 <lambdabot>      It could refer to either ‘L.Node’, defined at .L.hs:169:15
14:32:06 <brainacid> :t x :: [Client]
14:32:07 <lambdabot>     Ambiguous occurrence ‘x’
14:32:07 <lambdabot>     It could refer to either ‘L.x’,
14:32:07 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:163:2
14:32:14 <mauke> @undefine
14:32:14 <lambdabot> Undefined.
14:32:48 <brainacid> if I store a List of Client data how can I match pattern ??
14:33:22 <mauke> like any list
14:33:26 <mauke> what's the problem?
14:33:44 <brainacid> well mauke im really not sure if i am understanding my issue
14:35:32 <exio4> brainacid, what do you want to do?
14:35:44 <exio4> maybe all you need a map or filter
14:36:16 <lpaste> brainacid revised “learningData :: data Client”: “confused” at http://lpaste.net/117345
14:36:25 <brainacid> exio4, im doing an exercise for a book
14:36:32 <brainacid> we havent coverd map or filter
14:36:37 <brainacid> im a hobby programmer
14:36:37 <exio4> oh
14:36:46 <brainacid> im trying to match patterns
14:36:48 <Zekka> brainacid: They're not too hard to reimplement if you want to do
14:36:54 <brainacid> learning and failing
14:37:04 <brainacid> been hacking at it for hourse
14:37:17 <brainacid> took some breaks but i cant seem to see clearly
14:37:23 <brainacid> say
14:37:25 <mauke> brainacid: the two patterns for a list look like [] and x : xs
14:37:32 <mauke> where [] represents an empty list
14:37:48 <mauke> and x : xs is a non-empty list, with x being the first element (head) of the list and xs the rest
14:37:54 <brainacid> if you look at my paste quickly you see im using some data constructors
14:38:14 <brainacid> im just not getting if my list is correctly made
14:38:34 <brainacid> and not sure how to look into that list and say there are 5 clients that are male and 5 female
14:39:18 <Zekka> brainacid: How about you start with the problem of saying whether just one client is male or female?
14:39:26 <brainacid> yes
14:39:29 <brainacid> thats where im stuck at
14:39:49 <Zekka> OK, so let's disregard the list
14:39:51 <brainacid> let i = [(Individual (Person "Me" "Rod" Male) True)]
14:40:11 <brainacid> the Bool is for Receive Ads Ye or No
14:40:15 <Zekka> Write the function classify :: Client -> Gender
14:40:37 <Zekka> I'll give you one to start with
14:40:46 <brainacid> classify i would return a Bool?
14:40:53 <Zekka> classify (Individual (Person _ _ g) _) = g
14:41:02 <brainacid> see thats where im stuck
14:41:07 <mauke> brainacid: no, it would be a type error
14:41:09 <mauke> i is a list
14:41:13 <Kaidelong> is there a neat package out there with an emacs binary for windows that comes with a bunch of haskell extensions?
14:41:15 <brainacid> mauke, yes
14:41:17 <Zekka> brainacid: It returns a Gender -- you can compose it with something that turns the gender into a Bool
14:41:37 <brainacid> but I need the sum of male and female clients
14:41:42 <Zekka> You can follow writing classify with definitions like this: isMale = (== Male) . classify, isFemale = (== Female) . classify
14:41:47 <Zekka> brainacid: That's a separate problem!
14:41:51 <Zekka> Let's stick to just this first problem
14:42:01 <brainacid> so if male then (male, 1) else (female, 1)
14:42:14 <mauke> brainacid: no
14:42:18 <Zekka> brainacid: Why not just reurn the gender? What does the ,1 do?
14:42:29 <brainacid> counting the total males and females
14:42:41 <mauke> Zekka: it's the weird data structure they're using
14:42:42 <Zekka> But we don't know anything about a total or anything
14:43:00 <Zekka> Oh, I guess if he wants it to exactly match the format of clientGd he can
14:43:09 <brainacid> indeed we dont know a total
14:43:18 <Zekka> But why are we thinking about the list right now? Why can't we just classsify exactly one client first?
14:43:33 <Zekka> Then we can do that to every client in the list
14:43:38 <brainacid> sorry Zekka yes we can focus on that
14:43:58 <Zekka> OK, can you write classify :: Client -> (Gender, Integer)?
14:44:18 <brainacid> Zekka, yes
14:44:19 <Zekka> As a reminder, I start with: classify (Individual (Person _ _ g) _) = (g, 1)
14:44:27 <Zekka> OK, write that!
14:44:35 <brainacid> done
14:44:57 <Zekka> OK, so when we're done, clientGd is that done to every client in the list
14:45:05 <Zekka> For starter, what is clientGd if the list is empty?
14:45:07 <Zekka> starters*
14:45:44 <Zekka> clientGd [] = ???
14:46:01 <brainacid> clientGd [] = error "An empty List!"
14:46:07 <mauke> terrible
14:46:11 <Zekka> brainacid: Are you sure that's right?
14:46:12 <brainacid> :(
14:46:43 <mauke> your result data structure makes this harder than necessary
14:46:44 <Zekka> I think you can define a reasonable return value that isn't nontermination for an empty list
14:46:53 <mauke> I wouldn't use a list
14:47:09 <mauke> I'd use a record, because the number of possible genders is known
14:47:30 <Zekka> I'd use a Map from Gender! But that might be too complicated
14:47:40 <brainacid> its not my structure its the books
14:47:44 <kaiyin> I finally got a glimpse of what of monad is, I need to open a bottle of champagne! :-D
14:47:47 <brainacid> im just using to learn Haskell
14:48:02 <Zekka> kaiyin: Cool! Define it for us.
14:48:06 <mauke> brainacid: "Define a data type to hold the results of this function" doesn't say what to use
14:48:09 <Zekka> (or don't, if you're afraid...)
14:48:25 <mmmm> anyone here played with indexed free monads?
14:48:34 <mauke> Zekka: we already have a fixed Gender type. why bother with maps?
14:49:06 <kaiyin> No, I am not afraid, my dear friend. It's just taking something out of some context, apply some function to it, and then put it back to the same context!
14:49:19 <Zekka> mauke: Because it gives an automatic assocation between Gender values and 'field' analgoues in the output
14:49:29 <Zekka> kaiyin: Pretty close! I'll get to bickering in ab it
14:49:54 <Zekka> mauke: There's no explicit association between the field that counts the number of males and the Male data constructor if you use a record
14:50:10 <brainacid> mauke, *Main> let lCs = (Individual (Person "Me" "Sane" Male) True) *Main> clientGd lCs -> (Male,1)
14:50:15 <Zekka> The problem with Maps is that there's no innate guarantee that the Male data constructor is associated with anything, but you cacn address that in you interface
14:50:32 <Zekka> mauke: When you're dealing with such a small problem then there's not much difference though
14:51:19 <Zekka> kaiyin: OK: so for starters, what *is* a monad? Is it a process? A kind of value? A kind of type?
14:51:31 <mauke> Zekka: what's the difference between M.fromList [(Male, 0)] and M.fromList []?
14:51:46 <mauke> that is, with maps you can have missing keys
14:52:02 <Zekka> mauke: Maps can have missing keys, but your interface for working with them doesn't have to!
14:52:03 <kaiyin> Zekka, is it a kind of functor?
14:52:14 <mauke> kaiyin: what's a functor? :-) same question
14:52:20 <Zekka> kaiyin: Yes. What's Functor? (and what is *a* Functor?)
14:52:28 <kaiyin> A functor, I read, is a transformation from one cat to another.
14:52:37 <Zekka> kaiyin: Cat?
14:52:41 <Zekka> Oh, category
14:52:44 <kaiyin> yeah
14:52:47 <mauke> cat -> dog
14:52:51 <kaiyin> :D
14:53:08 <kaiyin> You can say they are categories, too.
14:53:19 <Zekka> kaiyin: A capital-F Functor is a functor from Hask to Hask afaik (I'm not a mathematician!)
14:53:36 <quchen> lower-case f.
14:54:57 <quchen> A Functor in Haskell is a typeclass. It can be seen as a mathematical functor when you're thinking about it in a larger context, but as far as the Haskell standard is concerned that's irrelevant.
14:54:58 <brainacid> sorry
14:55:02 <brainacid> i give up
14:55:04 <brainacid> thanks all
14:55:08 <Zekka> quchen: That's probably a more correct way to put it
14:55:12 <Zekka> brainacid: That's unfortunate! See you around, I guess
14:55:44 <brainacid> well ive been at it since 6 am Zekka i know very well how unfortunate it is... :(
14:56:11 <Zekka> kaiyin: Can you tell us concretely what a capital-F Functor is in Haskell?
14:56:17 <brainacid> and i wont even be graded, no teacher and no boss... just for my dumb curiosity
14:56:31 <brainacid> such a long road ahead of me
14:56:33 <Zekka> Maybe by summarizing what operations a Functor must provide?
14:56:35 <brainacid> bah
14:56:52 <Zekka> well, maybe I'm giving away too much of the answer!
14:56:53 <kaiyin> brainacid, your curiosity values more than anyone's grade, IMHO.
14:57:46 <kaiyin> Yes, fmap :: (a->b) -> (f a -> f b)
14:58:02 <HeladoDeBrownie> subject to the laws fmap id = id and fmap g . fmap f = fmap (g . f)
14:58:05 <Zekka> kaiyin: OK. Can you explain why that's useful?
14:58:22 <Zekka> (Helado's given you the laws, feel free to talk about them if you want)
14:58:55 <HeladoDeBrownie> woops, sorry if i stepped on toes
14:59:23 <Zekka> HeladoDeBrownie: I'm not annoyed! I think when I first learned about functor/applicative/monad I had a pretty strong intuition for the laws but wouldn't have been able to recite them off the top of my head
14:59:38 <kaiyin> It's useful because it put normal functions into context. I am not sure about terminology, but that's what my intuition tells me.
15:00:13 <kaiyin> HeladoDeBrownie, that's ok. If I want to cheat, I can look it up on wikipedia anyways. :-)
15:00:19 <Zekka> kaiyin: The terminology is that it lifts functions from normal values to values in f
15:00:34 <kaiyin> Cool.
15:00:43 <Zekka> So for [], fmap lifts functions from as to bs into functions from as in lists to bs in lists
15:00:49 <quchen> HeladoDeBrownie: The second law is a consequence of the first law (up to bottom) :-) https://github.com/quchen/articles/blob/master/second_functor_law.md
15:01:23 <HeladoDeBrownie> yeah, i just didn't read far back enough in the context to see this was a lesson. sorry
15:01:29 <Zekka> kaiyin: So if a Monad is a kind of Functor, what's a Monad got that a Functor doesn't got? (you mentioned a pretty close high-level intuition)
15:01:46 <Kristien> kaiyin: It's useful because you can now implement algorithms that work on any functor, and are not tied to e.g. lists or maybes.
15:02:06 <kaiyin> cool.
15:02:17 <Zekka> There's actually at least two good answers to that qestion
15:02:20 <kaiyin> A monad also has a bind function, >>=
15:02:33 <Zekka> kaiyin: OK, what's bind do?
15:02:40 <texasmynsted> I think that if something can form a Monad it can also form a Functor
15:02:44 <Zekka> :t (>>=)
15:02:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:02:57 <kaiyin> yes, I was about to do that.
15:03:05 <quchen> texasmynsted: Yes, all valid Monad instances can also be made valid Functor instances.
15:03:17 <Zekka> texasmynsted: I think so too! fmap f x = x >>= (return . f)
15:03:49 <texasmynsted> Right, I just prefer the "can form a" vs "is a" nomenclature
15:04:29 <quchen> If a Monad "is not" a Functor then it's a bad code smell in existing libraries.
15:04:54 <Nadrieril> kaiyin: with an imperative intuition, f >>= g executes f, and then executes g with the return value of f as a parameter
15:05:10 <Nadrieril> Sorry, wrong hl; Zekka
15:05:16 <Zekka> Nadrieril: I already know!
15:05:23 <quchen> That imperative intuition isn't applicable to Haskell, at least not in the general case.
15:05:28 <Zekka> I'm trying to help kaiyin, who said they thought they'd figured out what monads were
15:05:32 <quchen> Works arguably well for some monads, very bad for others.
15:05:39 <Zekka> that is, by making them rigorously define it
15:05:55 <Nadrieril> Works for some monads at least
15:05:57 <Zekka> I don't really like that intuition because it applies to Hask too
15:06:14 <kaiyin> :t >>=
15:06:15 <lambdabot> parse error on input ‘>>=’
15:06:20 <quchen> :t (>>=)
15:06:20 <Zekka> :t (>>=)
15:06:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:06:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:06:48 <EvanR> if you did Functor, continue to Applicative instead of Monad
15:06:50 <kaiyin> yeah. take m a and a function a -> m b, return mb
15:07:07 <Zekka> kaiyin: Yeah. Look at this by the way
15:07:10 <Zekka> :t ($)
15:07:10 <lambdabot> (a -> b) -> a -> b
15:07:12 <Zekka> :t fmap
15:07:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:07:15 <Nadrieril> I would be intersted in having a more general intuitive explanation of monads, if someone has that
15:07:17 <Zekka> :t (=<<)
15:07:18 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:07:24 <EvanR> :t (<*>)
15:07:25 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:07:46 <kaiyin> =<< is just a flipped version of >>=
15:08:02 <Zekka> Nadrieril: I kind of like "monoidin the category of endofunctors" but it may be too hard to explain
15:08:05 <mmmm> Are there any good resources explaining :~: from Data.Type.Equality?
15:08:17 <Zekka> kaiyin: Yeah. How does it look relative to fmap?
15:08:38 <Zekka> Think of fmap as Monad m => (a -> b) -> m a -> m b if that helps
15:08:43 <Nadrieril> Zekka: I agree, but I'm not sure about the "intuitive" part
15:08:57 <EvanR> Nadrieril: there isnt one. but there is https://www.haskell.org/haskellwiki/Monads_as_containers and https://www.haskell.org/haskellwiki/Monads_as_computation
15:09:09 <Zekka> Nadrieril: I don't think there's a way to talk about it other than by introducing Functor
15:09:22 <Zekka> I don't think you need to introduce Applicative but you need to introduce Functor and *should* introduce Monoid
15:09:28 <quchen> Every phenomenon has a simple and compelling explanation. That explanation is wrong.
15:09:43 <bimboum> I guess this question is going to be terribly vague. I am mostly looking for an code snippet. In a functional language with mutable (saying like in ocaml), I can pass a (recursive here) function as closure that mutates its environment. Is there any way to do this? Can I pass a state monad and hope to do something similar?
15:10:06 <Zekka> bimboum: You can do it in ST in a literla sense, State in a figurative one, if I understand you
15:10:13 <Zekka> Er, wait a sec
15:10:14 <Nadrieril> I know about monads, I was just interested in a simple explanation because I couldn't see one. Tks anyway
15:10:17 <Zekka> No, I'm not sure you can
15:10:28 <vanila> bimboum, you could do that in scheme with SET!
15:10:34 <EvanR> bimboum: if you use IO, you can close over IORefs or MVars
15:10:39 <Zekka> If you're in ST the whole time I think you can, if you're in IO you can use IORef
15:10:52 <Zekka> But you can't generate a function that does that in one case of ST and then pass it into another one
15:11:07 <Zekka> And in general I don't think you *should* do that
15:11:14 <bimboum> Zekka, EvanR: I want to use a list as a stack and mutate it while I (tail) recurse an array basically
15:11:17 <kaiyin> fmap and >>= return the same type, Zekka
15:11:21 <quchen> Nadrieril: There is no explanation that's both simple and right.
15:11:33 <EvanR> bimboum: well, a list as a stack works great *without* mutating it
15:11:40 <Zekka> kaiyin: Yes, they both lift some kind of operation into (m a -> m a)
15:11:44 <quchen> Nadrieril: Except for the tautological one, "a Monad is a type that is an instance of Monad and the functions satisfy the laws".
15:11:48 <Nadrieril>  "monoidin the category of endofunctors" will have to do then ^^
15:12:04 <Zekka> bimboum: Tried the State monad?
15:12:16 <bimboum> EvanR: well, not really. I want a function (i.e. a callback more or less) but its prototype does not contain the list. I want it captured
15:12:23 <Zekka> That will probably work so long as you manipulate the list in non-evil ways
15:12:36 <Zekka> (things that don't necessitate recreating the whole structure)
15:12:57 <bimboum> saying Int -> (Int -> Int) -> Int
15:13:08 <EvanR> bimboum: a function by itself cant have any state, sorry. you need to pass it in or make it an IO action instead and use mutable variables
15:13:38 <exio4> bimboum: I think you want a local function that does the recursion
15:13:45 <Zekka> kaiyin: Short version: (=<<) is fmap for (a -> m b) instead of (a -> b)
15:14:00 <cyberace> hi
15:14:17 <Zekka> return is self-explanatory (but still really important!)
15:14:45 <bimboum> EvanR: I can make it partly generic so? Like a -> Int -> Int?
15:15:02 <EvanR> bimboum: a -> Int -> Int wont work
15:15:05 <bimboum> a needs to be a type class I imagine?
15:15:14 <bimboum> State a -> Int -> Int?
15:15:20 <EvanR> or provide an operation that works on a
15:15:31 <exio4> uhh, what are you trying to do?
15:15:45 <Zekka> bimboum: I don't think I quite understand what you're trying to do
15:16:07 <Zekka> You're trying to perform a series of list operations by recursing over an array, right?
15:16:37 <EvanR> probably a fold over the array with the list as the accumulator
15:16:41 <quchen> I don't think >>= is like fmap at all. It respects different laws, it has a different type, it doesn't lift things. `ap` and `return` are a lot more like fmap: while fmap lifts unary functions to a Functor, `ap` lifts arbitr-ary functions to a Monad, and `return` lifts nullary ones.
15:17:36 <mauke> fmap :: (a -> b) -> f a -> f b
15:17:49 <mauke> (=<<) :: (a -> f b) -> f a -> f b
15:18:02 <quchen> I see the lexical resemblance in the type signature, yes.
15:18:08 <bimboum> Zekka: It is more about writing one function that processes a ByteString calling another function and does *anything* on this function. But I guess it is impossible to hide it in haskell as I would do in another functional mutable language. I need to do it differently I imagine
15:18:09 <Zekka> quchen: ($) : Hask :: (=<<) : Kleisli
15:18:28 <mauke> (=<<) = join .: fmap
15:18:54 <Zekka> fmap is a good illustrative example for 'operating on things in a context' (if you don't like calling (=<<) a lift)
15:19:06 <Zekka> although I don't understand why you wouldn't call (=<<) a lift
15:19:31 <quchen> What does it lift to where?
15:19:43 <Zekka> quchen: It lifts (a -> m b)s to (m a -> m b)s
15:20:33 <Zekka> Are you operating under a formal definition of a lift that doesn't match my intuitive description of one?
15:20:39 <bimboum> Zekka: I would need to rewrite my code since this one is for work (I am playing with haskell to change a bit from day to day C++ / python mining). Sorry for being a bit vague. I would do a gisthub otherwise.
15:20:45 <quchen> That looks like a mapping to me, not a lift. "fold :: (...) => t m -> m" doesn't lift Foldables to Monoids.
15:21:27 <Zekka> quchen: It's turning one kind of operation mapping as to bs into another kind of operation mapping as to bs
15:21:30 * HeladoDeBrownie wonders what the formal meanings of "lift" and "map" are as used here
15:21:38 <mauke> map is a lift
15:21:45 <fizbin> bimboum: I have often found the act of cleaning stuff up and rewriting it so that I can post about work stuff here is sufficient to solve my problem.
15:21:55 <Zekka> I'd argue that a function from one kind of a -> b to another kind of a -> b for arbitrary a and b is a lift
15:22:02 <kaiyin> Zekka, you have already mentioned the relation between fmap and >>=, that is fmap f x = x >>= (return . f)
15:22:05 <fizbin> That is, writing up the simple example often solves it.
15:22:13 <zwer> liftM == fmap with monadic constraint.. so i wouldn't say there's aclear distinction between lifting and mapping
15:24:41 <Zekka> quchen: Reiterating -- wouldn't you agree that for Functor f, Monad m, $ : Hask :: fmap : f :: (=<<) : Kleisli m
15:24:44 <Zekka> ?
15:25:45 <Zekka> (let me know if there's a more correct way to name the category for a given functor)
15:26:27 <Zekka> ($) : Hask*
15:26:33 <notdan> fmap : f Hask
15:26:57 <Zekka> notdan: Sure, sounds pretty good
15:27:15 <quchen> I don't understand the syntax there, but it looks right. $ is pointful function application, bind is pointful monadic function application, for some value of function application.
15:27:26 <Zekka> quchen: It's a series of analogies
15:27:46 <Zekka> ($) is to Hask as fmap is to f of Hask as (=<<) is to Kleisli of m.
15:28:00 <Zekka> well, of analogous statements*
15:28:38 <EvanR> a convert sequence of analogies?
15:28:45 <EvanR> convergent*
15:28:55 <Zekka> What do you mean by "convergent"?
15:29:02 <EvanR> has a limit
15:29:24 <toblerone> I'm having some troubles with cabal and cabal sandbox, and i'm not sure how to go about diagnosing them. I've installed aeson-0.8.0.2 into a cabal sandbox, but when i try to start the repl via cabal repl it complains aeson is missing. I've tried reinstalling aeson, but that doesn't work. If remove aeson from my cabal file, and load the repl, it tel
15:29:24 <toblerone> ls me that aeson-0.8.0.2 is hidden
15:30:06 <Zekka> toblerone: Someone else might have a less destructive solution, but have you tried deleting the sandbox and recreating it?
15:30:45 <toblerone> Zekka: No I haven't, I'd prefer not too if I can help it though : )
15:31:12 <Zekka> I don't think I've run into that one if I've offered more advice -- do that, I suppose, if nothing else works (hopefully someone else will speak up)
15:32:07 <quchen> Zekka: Hmm, I guess you can see it as a lift that way then.
15:32:50 <Zekka> quchen: FWIW, I think (=<<) is easier to talk about than (>>=) and really wish people would start with (=<<)
15:32:58 <Zekka> Actually I really wish people would start with fmap and join
15:33:13 <quchen> Zekka: <=< is probably even better.
15:33:37 <Zekka> quchen: I thought composition was scary when I started learning Haskell! But sure, maybe
15:33:42 <Zekka> :t (.)
15:33:43 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:33:45 <Zekka> :t (<=<)
15:33:46 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
15:34:55 <fizbin> :t (<<<)
15:34:56 <joeyh> how do I make haddock show a comment after a GADT constructor? "-- ^" doesn't work
15:34:56 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
15:35:12 <hiptobecubic> Zekka, why is =<< easier than >>= ?
15:35:19 <fizbin> :t (<<<) `asTypeOf` (.)
15:35:19 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:35:38 <fizbin> So start with (<<<) and (<=<) ?
15:35:41 <Zekka> hiptobecubic: Because you can break it into (m a -> m b) and (a -> m b) -- the (a -> m b) isn't in the middle
15:36:00 <hiptobecubic> :t (=<<)
15:36:01 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:36:17 <Zekka> It looks more like an operation on operations than an operation on a data structure
15:36:28 <toblerone> Zekka: running cabal configure seemed to fix it
15:36:32 <toblerone> thanks for the help
15:36:36 <Zekka> toblerone: Cool! Don't ask me why.
15:38:55 <TallerGhostWalt> anyone had luck signing auth tokens for google services using one of the jwt packages?  I'll do it by hand if I must but a package would be nice
15:45:17 <joeyh> hmm, nothing in the haddock docs about GADTs. -- | also doesn't work within the constructors of a GADT
15:59:28 * hackagebot MuCheck 0.1.3.0 - Automated Mutation Testing  http://hackage.haskell.org/package/MuCheck-0.1.3.0 (RahulGopinath)
16:00:42 <EvanR> :t (<$)
16:00:43 <lambdabot> Functor f => a -> f b -> f a
16:00:46 <EvanR> :t ($>)
16:00:46 <lambdabot>     Not in scope: ‘$>’
16:00:47 <lambdabot>     Perhaps you meant one of these:
16:00:47 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
16:02:15 <bennofs> :t >$
16:02:16 <lambdabot> parse error on input ‘>$’
16:09:22 <TallerGhostWalt> I don't understand why all 3 jwt libraries on hackage have hard coded JwtClaims
16:10:21 <TallerGhostWalt> I have used JWT for two sites and they wanted custom claims (in addition to the standard) both times. Usually stuff is the way it is for a reason, just can't figure it out.
16:19:11 <pkinsky> Has anyone been able to get GHC running on an Intel Edison?
16:20:27 <dfeuer> What is an Intel Edison?
16:22:13 <pkinsky> The Edison is Intel's answer to the Rasberry Pi. It's a system on a chip with built in wifi, bluetooth, all slightly smaller than a credit card
16:22:23 <pkinsky> It uses an intel atom cpu
16:22:58 <pkinsky> So it's x86 unlike the RasPi which is ARM
16:23:15 <dfeuer> If there's an Intel Edison, is there an AMD Carver?
16:23:24 <dfeuer> Oh.
16:23:38 <dfeuer> HMM
16:24:13 <pkinsky> I tried building from ghc 7.8.3's Generic i386 Linux build
16:24:25 <dfeuer> What happened?
16:25:06 <pkinsky> It's failing with:  ./configure
16:25:06 <pkinsky> checking for path to top of build tree... ./configure: ./configure.lineno: line 2174: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd-bindist: not found
16:25:06 <pkinsky> configure: error: cannot determine current directory
16:25:35 <dfeuer> You should probably ask in #ghc, or on the ghc-devs list.
16:25:41 <pkinsky> will do, thanks
16:26:08 <bimboum> Not sure there is still people from the closure with mutable state stuff :-)
16:26:54 <bimboum> I wrote a simplistic example about how I would do it in haskell way. I think this is very close to State monad but I do not know how I would use it in this example
16:26:59 <bimboum> This is here:
16:26:59 <bimboum> https://gist.github.com/anonymous/62fbc187beacb304ff6f
16:27:33 <bimboum> Basically, the "callback" is responsible to fwd the state
16:27:34 <dunno> http://www.trafficswarm.com/url.pl?method=preview&urlid=2304862
16:28:39 <Zekka> bimboum: Thefunction taken by withState is very close to being a String -> State a String
16:28:42 <bimboum> The bigger code I am working on is using this but I have the feeling this is not haskell idiomatic i.e. this is a bit awkward
16:29:26 <Zekka> @src State
16:29:26 <lambdabot> Source not found. Wrong!  You cheating scum!
16:29:27 <EvanR> it takes practice to get things to be idiomatic, and a lot of reconsideration
16:29:43 <dfeuer> Wait... pkinsky, I'm not thinking straight. You can't build it on there unless you already have a Haskell compiler there. If not, you will need to attempt to use a dist binary. Or someat.
16:29:43 <EvanR> haskell is not like c++, or scheme at all
16:30:35 <bimboum> EvanR: what would be the more idiomatic way to write this simple function?
16:30:38 <bimboum> :-)
16:30:47 <dfeuer> Can't build GHC without GHC.
16:30:58 <dfeuer> EvanR, Haskell is at all like Scheme.
16:31:34 <pkinsky> dfeur: should I try to cross-compile GHC? https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
16:31:46 <EvanR> dfeuer: no way
16:31:50 <bimboum> (I know this function is a bit completely stupid...)
16:32:02 <EvanR> bimboum: i didnt get the whole explanation of what you were trying to do
16:32:11 <dfeuer> pkinsky, I don't know. *If* you're able to use a distributed binary, that will be *much* easier.
16:32:37 <dfeuer> pkinsky, have you tried searching for binaries for that device (or something similar to it)?
16:32:38 <Zekka> EvanR: It looks like he's reimplmenting evalState
16:32:46 <bimboum> EvanR: I want a generic function (as withState) that calls another function that (may) require a state to work on
16:32:49 <Zekka> and the State monad, of course
16:33:03 <bimboum> I try to stuff a state Monad here :-)
16:33:18 <Zekka> bimboum: withState is basically evalState
16:33:19 <pkinsky> dfeur: should I look for binaries associated with the linux distro?
16:33:27 <EvanR> bimboum: really? well if thats really what youre trying to do, then you might want to check out State, which is s -> (a, s)
16:33:34 <Zekka> The type of your function argument is basically String -> State a String
16:33:34 <pkinsky> dfeur: or is it binaries associated with the CPU?
16:33:45 <dfeuer> EvanR, Scheme is mostly functional, with a generally pro-functional programming culture, so I think a decent amount of code ends up having a similar flavor.
16:33:50 <EvanR> bimboum: but if you have an actual problem to solve, then there might be a better way
16:34:24 <dfeuer> pkinsky, I'm not sure why you're spelling my name funny, but yeah, the linux distro would be a good place to start. If you can't find those, try the architecture.
16:34:58 <pkinsky> dfeuer: sorry about that, thanks for helping me out
16:35:11 <dfeuer> NP.
16:36:10 <bimboum> EvanR: I really want genericity. In Ocaml, I would have a closure (with type String  -> String) that mutate its env. In Haskell, I think this seems to be the proper way. I am going to try to put a state monad to see if I can make the code more expressive and a bit more readable
16:36:28 <Zekka> bimboum: Your solution is the same as the state monad
16:36:33 <EvanR> dfeuer: var arg, mutable variables, typelessness, macro shenanigans, fumbly currying...
16:36:33 <Zekka> It's identical up to argument order
16:36:44 <EvanR> impure
16:36:47 <n4x> pkinsky: you may want to use tab for autocompleting nicks, try something like "df[tab]"
16:37:36 <bimboum> Zekka: OK. But if I do not use any do {...} sugar, is there anything to gain from using state monad?
16:37:41 <EvanR> bimboum: ok, so if you are trying to write a subroutine that takes a String and gives a String while using some state, you can do String -> State s String for some s
16:37:54 <Zekka> bimboum: You don't have to manually propagate the state each time you operate on a thing
16:38:01 <EvanR> or equivalently, String -> (String, s)
16:38:04 <dfeuer> EvanR, Haskell has every bit as much in the way of macro shenanigans, I believe. And Scheme's macro systems are about as nice as macro systems get. Var args are relatively rare, mutable variables generally discouraged. Yes, there are problems, but it's not as bad as you're making it out.
16:38:08 <Zekka> Youcan write code that's polymorphic over using state, not using state, or using state and a monad transformer
16:38:11 <EvanR> er String -> s -> (String, s)
16:38:23 <dfeuer> bimboum, yeah, it makes it much easier to think about.
16:38:54 <Zekka> You can't accidentally screw up a type so that it can't be substituted into code where it hsould have been possible to substitute it
16:39:05 <dfeuer> Also, bimboum, you get to use all sorts of functions made for monads and applicative functors.
16:39:31 <dfeuer> Like if you're using Data.Sequence, you can pass your State thingum to replicateA and make cool things happen.
16:39:57 <dfeuer> Or if you're using lists, I think there's a replicateM or something.
16:40:30 <dfeuer> Mm... no.
16:40:32 <dfeuer> Something else.
16:41:16 <bimboum> ok. I am going to try to use state monad so. Let's see how I can make it fit. Thanks for your comments!
16:41:37 <dfeuer> O;h yeah, it is Control.Monad.replicateM that I'm thinking of.
16:41:49 <vanila> Can anyone tell me how to set up stackage?
16:41:49 <Zekka> bimboum: Replace every String -> a -> (String, a) or similar type with State a String
16:41:50 <EvanR> it might not fit, since you didnt ask about your specific problem, just about State
16:41:53 <Zekka> That's a good first step
16:41:58 <dfeuer> bimboum, it's not for everything, by any means; it's just sometimes a good fit.
16:42:57 <bimboum> EvanR: I just wanted to know how this function can be rewritten with state monad :-). Zekka, dfeuer: thanks!
16:43:07 <Zekka> bimboum: You don't need to rewrite withState with the state monad
16:43:11 <Zekka> It already exists, it's called evalState
16:44:32 * hackagebot ghcjs-dom 0.1.1.3 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.1.1.3 (HamishMackenzie)
16:44:43 <EvanR> does it make sense to define a Num instance for an applicative over Nums in a generic way
16:44:55 <Zekka> EvanR: I wouldn't do that!
16:45:02 <EvanR> a + b = (+) <$> a <*> b
16:45:12 <Zekka> You can use all the Num operations exactly like that with explicit lifting
16:45:29 <EvanR> its certainly going to make expressions a lot larger
16:45:30 <Zekka> And if you were to do that you would just set the expectation that every typeclass's methods be automatically lifted
16:45:36 <johnw> (+) = liftA2 (+)?
16:45:42 <Zekka> which you can't possibly manage
16:45:47 <n4x> we just need applicative syntax, then!
16:45:55 <johnw> [| a + b |] :)
16:45:58 <bimboum> Zekka: OK. I have to see how this is going to fit in my bigger code. I'll look at evalState
16:45:59 <dfeuer> No, not a good idea. Even trying would require UndecidableInstances, I think, but that's the least of its troubles.
16:47:51 <EvanR> what about copying a bunch of (+) = liftA2 (+) etc just for select Applicatives
16:48:02 <Zekka> EvanR: If you must do that, rename it
16:48:04 <EvanR> i wasnt really asking about doing it for literally all Applicatives
16:48:16 <n4x> dfeuer: only FlexibleInstances
16:48:18 <Zekka> No, that's still evil
16:48:23 <EvanR> why?
16:48:28 <n4x> at least with 7.6.3
16:48:29 <Zekka> it will globally affect your project
16:48:54 <EvanR> its evil to define a Num instance for a type T using Ts applicative instance?
16:49:06 <dfeuer> FlexibleInstances is a lot less evil than where this is really heading, which is the OverlappingInstances/IncoherentInstances realm of horribleness.
16:49:09 <Zekka> EvanR: Why is all kinds of could-otherwise-be-pure numeric code so closely intermixed with Applicative?
16:49:18 <Zekka> You should be looking for ways to factor it out to not be
16:49:30 <EvanR> heh
16:49:34 <Zekka> I know it can be factored out because otherwise definitions like the ones you're describing, that don't use teh context at all, wouldn't be tempting
16:49:50 <EvanR> they would use the context
16:49:55 <EvanR> thats why im using applicative
16:49:58 <Zekka> EvanR: No they won't
16:50:00 <EvanR> eh?
16:50:09 <Zekka> liftA2 says 'turn this operation that doesn't use the context into one that nominally uses the context'
16:50:17 <Zekka> It's a pure operation, just lifted to operate on contextual values
16:50:32 <Zekka> You are still dealing with pure operations
16:50:37 <EvanR> well if i were to define the Num instance manually... id basically rewrite the applicative instance
16:50:48 <EvanR> and put + and * in there
16:50:50 <Zekka> EvanR: You're missing the point -- the Num instance is not necessary
16:51:07 <Hijiri> the AMD one would be lawnmower or something
16:51:25 <Zekka> You should write your numeric code in such a way it operates on bare values -- then lift those higher-level operations to work on applicatives
16:51:40 <EvanR> numeric code?
16:51:54 <Zekka> EvanR: Yeah, the code that needs the numeric operations
16:52:10 <EvanR> im trying to add numeric signal functions
16:52:20 <johnw> EvanR: when I look at a + operator, I'd rather not have to think about whether it conflates the concepts of numerics and applicatives
16:53:09 <EvanR> like sin + 2 for instance
16:54:04 <Zekka> EvanR: You are still not convincing me what you're doing is nonevil!
16:54:23 <Zekka> My first thought reading code like that is "a function is not a number"
16:54:28 <EvanR> im not trying to, im wondering how its feasible to factor out "numeric code"
16:54:56 <vanila> What would you recommend to set up a haskell blog? (for free)
16:54:56 <Zekka> EvanR: liftA (+2) sin
16:55:15 <Zekka> That doesn't look terribly verbose to me, although it's more verbose
16:55:26 <agibiansky> vanila: Depends on what you want of course, but i like DigitalOcean for hosting and Hakyll for static site generation. takes some time to set up though
16:55:32 <EvanR> more like liftA (+) (pure 2) sine
16:55:37 <Zekka> You seemed to indicate that doing this with your actual code would lead to big honking stacks of lifts and other horrors
16:55:43 <vanila> Hakyll and things might be a bit much work for me :(
16:55:45 <Zekka> EvanR: Not only is that not necessary, but it's ill-typed
16:55:58 <EvanR> sine :: T -> R
16:56:07 <EvanR> well, B R
16:56:09 <Zekka> :t liftA
16:56:10 <lambdabot> Applicative f => (a -> b) -> f a -> f b
16:56:18 <Zekka> You can't lift a function over two arguments with liftA
16:56:24 <EvanR> oops
16:56:25 <Zekka> :t liftA2
16:56:26 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:56:41 <EvanR> liftA2 (pure 2) sine
16:56:48 <EvanR>     ^(+)
16:57:12 <Zekka> EvanR: If you're doing things that are that simple then I don't see why the Applicative instance is so appealign to begin with
16:57:52 <Zekka> What you're asking is kind of like "I like square brackets, can't I overload array access to do what call syntax does instead?" in Ruby
16:58:24 <Zekka> it's relatively insignificant and doesn't strictly make your code wrong, but makes it break most of what anyone else who uses the language expects
16:59:13 <EvanR> im lost
16:59:30 <Zekka> EvanR: Most of the time doing what you want to do probably will not make your code buggy or incorrect
16:59:36 <Zekka> But it'll make it confusing and has limited advantages
17:00:17 <Zekka> And it'll encourage you to specialize to Applicatives a lot of code that could have been written to operate on bare values
17:00:45 <Zekka> Which will make your code much less versatile in the long run, because if you need to switch Applicatives or if you need to operate on values that aren't signals for a change, you won't be able to
17:01:05 <EvanR> if i have a time function of Bool, and a time function which oscillates between Just and const Nothing, seems natural to want to apply one to the other, so thats applicative. factoring that part out seems weird
17:01:34 <EvanR> if i have a time function of Complex Double, and Complex Double, i makes sense to multiply them, and you can do that with applicative
17:01:54 <Zekka> EvanR: It makes sense to multiply their eventual values -- it doesn't necessarily make sense to multiply functions!
17:02:12 <EvanR> you multiply functions like this in math though
17:02:19 <Zekka> But not in Haskell!
17:02:20 <EvanR> just like multiplying equations
17:02:43 <dhrosa> you don't multiply functions, you multiply their results :p, unless you mean a different definition of multiplication
17:02:46 <Zekka> "I don't like parentheses: can I replace them with square brackets instead?"
17:02:47 <EvanR> the only other reason i have would be to reduce code
17:03:07 <Zekka> "I think the = operator is kind of stupid, can I replace it with := instead?"
17:03:40 <EvanR> another reason why haskell is not scheme, no one seems to like syntax tricks ;)
17:04:15 <Zekka> And like I said, doing it this way, while it won't break your code, will probably encourage you to write worse code in the long run
17:04:18 <EvanR> you also cant apply non-function types to things, yet i am
17:04:43 <Saizan> > (sin + 2) 0
17:04:44 <lambdabot>  No instance for (GHC.Show.Show a0)
17:04:44 <lambdabot>    arising from a use of ‘M510922561209757641517976.show_M5109225612097576415...
17:04:44 <lambdabot>  The type variable ‘a0’ is ambiguous
17:04:54 <Saizan> :t (sin + 2) 0
17:04:55 <lambdabot> (Num (a -> a), Floating a) => a
17:04:58 <Zekka> your otherwise Num a => a -> a -> a you might miswrite as Num a => Signal a -> Signal a -> Signal a because nothing stopped you from doing that
17:05:06 <dfeuer> EvanR, Haskell has a *lot* of syntax. It's just rather carefully considered. Reading the basics of, say, Python or Ruby syntax is enough to make a typical Haskell programmer balk.
17:05:21 <EvanR> Zekka: ok but this is purely syntactic for writing specific signals, expanding using lots of liftA2 or <*> seems like a hair shirt
17:05:26 <Zekka> EvanR: "I did other evil things!" is not a valid argument for "I want to do evil things!"
17:05:40 <Zekka> EvanR: It's a global change which by definition will affect your entire program
17:05:51 <Zekka> And my point earlier, which you missed, is that you won't need to use *lots* of liftA2
17:05:53 <EvanR> conceptually it makes sense to add two signals
17:06:01 <Saizan> EvanR: anyhow, a Num (a -> b) instance wouldn't be unheard of
17:06:09 <EvanR> its not a -> b
17:06:09 * ReinH shrugs
17:06:21 <EvanR> its Num a => B a
17:06:35 <Zekka> You need to use one lift for all the things that are in your Applicative
17:06:43 <Zekka> You can write the rest of the code as operations on bare values
17:06:56 <Zekka> If you think you can't do this then you're probably wrong
17:07:10 <EvanR> example expression F = G*(b - a)/(b-a)^2
17:07:25 <Zekka> I agree to some extent that conceptually it makes sense to add two signals -- we have a construct for extending concept-over-bare-values to concept-over-contextual values, and it's called Applicative
17:07:27 <EvanR> i dont remember the exact formula for that but numeric expressions usually involve a handful of operations
17:07:31 <ReinH> The Num instance for Num b => Num (a -> b) is somewhat useful.
17:07:54 <dfeuer> Also somewhat confusing when you mess up.
17:07:58 <Zekka> EvanR: liftA2 (\b' a' -> G * (b' - a')/(b' - a')^2)) b a
17:08:10 <Zekka> ReinH: A lot of evil things are useful!
17:08:18 <EvanR> that doesnt work
17:08:21 <ReinH> I don't see why it's evil
17:08:47 <EvanR> hmm, it does work
17:08:51 <dfeuer> ReinH, I think it's mostly evil because it will lead to horribly confusing error messages in case of type errors.
17:09:05 <ReinH> dfeuer: Num instances already lead to horribly confusing error messages
17:09:12 <Romefeller> Hi everyone
17:09:13 <EvanR> so youre saying put large formulas into a regular function and liftAN the input signals into it
17:09:14 <vanila> hi
17:09:17 <dfeuer> ReinH, this will be even worse.
17:09:19 <ReinH> dfeuer: This is literally from today http://stackoverflow.com/questions/27671594/no-instance-for-num-int-int-arising-from-the-literal-5
17:09:22 <Zekka> ReinH: a) it affects everything // b) it's a duplicate feature // c) it's confusing when you get it wrong // d) it's a syntax trick
17:09:46 <ReinH> It is not a syntax trick
17:09:47 <Zekka> Oh, and e) it encourages you to write code that intermixes effectful parts and non-effectful parts
17:09:49 <ReinH> It has nothing to do with syntax
17:09:55 <ReinH> It has nothing to do with effects
17:09:59 <ReinH> It is not a duplicate feature
17:10:13 <dfeuer> ReinH, yes, that is confusing. But with the instance you're talking about, the type error can get almost arbitrarily far from the actual mistake!
17:10:23 <EvanR> Zekka: since this is frp-like, thats a given, regarding mixing things up
17:10:34 <vanila> well don't put it in the prelude then :)
17:10:38 <vanila> but its fine to use if you find it useful
17:10:51 <Zekka> EvanR: "Operations that don't deal with context on contextual values" is a given
17:10:52 <flebron> Hey. Say I have f x = g where foo = {expensive computation}  g y = ... y ... foo ..., if I pass f {something} to some function, is it likely the internal foo will be computed only once?
17:10:53 <ReinH> dfeuer: I agree that the type errors are worse. I still found it useful for implementing some mathy things, like phi accrual
17:11:15 <Zekka> That those operations can't be factored out is assuredly not a given -- and as I demonstrated, you only ever have to use one lift
17:11:21 <flebron> Is there any difference, in terms of the caching likelihood, if I write it as f x = let foo = ...  g = ... in g?
17:11:36 <EvanR> Zekka: you only ever have to use one lift to do what?
17:11:38 <dfeuer> ReinH, I have no idea what phi accrual might be. Would it be terrible to use a newtype to isolate it?
17:11:42 <ReinH> dfeuer: The equations in the paper translate beautifully using the Num instance for functions (http://ddg.jaist.ac.jp/pub/HDY+04.pdf)
17:11:53 <Saizan> flebron: yes, i'd expect it to be cached
17:11:54 <Zekka> EvanR: To apply your operation, expressed over bare values, to a group of contextual values
17:11:57 <ReinH> dfeuer: Not really. You can isolate it to a module.
17:12:13 <vanila> flebron, yeah,you would have to put it at the top level for it to not be recomputed
17:12:24 <Zekka> For what it's worth, I think using a newtype is substantially less evil
17:12:28 <vanila> so not using where
17:12:33 <Saizan> vanila: nope
17:12:35 <vanila> if thats not possible pass foo in too
17:12:41 <Zekka> Then you can't inadvertently lift over more arguments than you expect, and you can keep it from escaping your specific place of use
17:12:41 <flebron> vanila: What does "top level" mean here? (foo might depend on x)
17:12:44 <dfeuer> ReinH, huh? What I'm saying is that if you use a newtype, you don't end up with a global instance for those functions.
17:12:53 <EvanR> Zekka: a newtype for my B type, when it doesnt have a Num in first place?
17:13:06 <flebron> (Say foo is a very big listArray call, creating some matrix.)
17:13:08 <dfeuer> And yes, what Zekka said too.
17:13:28 <Saizan> vanila, flebron: foo is fixed once you fix the x, and ghc is usually good enough to spot that if you give foo a name like that
17:13:29 <vanila> oh yeah i made a mistake
17:13:44 <ReinH> dfeuer: I can scope it to a single module with a few definitions. It doesn't pollute everything.
17:13:45 <Zekka> EvanR: If your B type is the Applicative, then, does it escape to parts of your program other than the ones where you've already decided there's no helping your need for numeric shorthand?
17:13:50 <ReinH> The newtype would just get in the way
17:13:58 <flebron> Ah, OK :) Thanks!
17:14:09 <Zekka> ReinH: How do you scope it to a single module other than by using a newtype?
17:14:14 <dfeuer> ReinH, I don't understand how it can avoid polluting everything. Could you explain that part?
17:14:35 * hackagebot folds-common 0.1.0.0 - A playground of common folds for folds  http://hackage.haskell.org/package/folds-common-0.1.0.0 (jozefg)
17:14:36 <flebron> (I don't suppose anyone here is doing the functional-programming challenge at HackerRank, right? Not asking anything about it, just curious :))
17:14:37 * hackagebot hasql-backend 0.3.0 - API for backends of "hasql"  http://hackage.haskell.org/package/hasql-backend-0.3.0 (NikitaVolkov)
17:14:43 <Zekka> flebron: I don't know anything about it
17:14:48 <ReinH> dfeuer: The Num instance only exists where it is imported or defined?
17:14:49 <dfeuer> Never heard of it.
17:15:03 <vanila> flebron, what is the challenge?
17:15:05 <dfeuer> ReinH, anything importing that module with a few functions.
17:15:12 <Zekka> ReinH: Are you sure about that? I thought instance declarations were by-design global
17:15:14 <flebron> It's a bunch of little problems using only functional programming. https://www.hackerrank.com/contests/lambda-calculi-9/
17:15:25 <Zekka> if they're ever exist, they always do
17:15:31 <ReinH> dfeuer: instance imports are transitive?
17:15:37 <EvanR> Zekka: so instead of a*r + b*(1-r) ... liftA3 (\a b r -> a*r + b*(1-r)) a b r
17:15:46 <Zekka> EvanR: Yes
17:15:48 <vanila> interesting
17:15:55 <ReinH> dfeuer: That doesn't make sense?
17:15:56 <Zekka> But probably assigning a name to the part in the lambda if it's meaningful elsewhere
17:15:58 <dfeuer> ReinH, yes, to the best of my knowledge.
17:16:16 <ReinH> dfeuer: So if I import an instance into module A but don't export it then if I import A in B, B has the instance?
17:16:22 <dfeuer> Instance definitions leak all over everything.
17:16:37 <dfeuer> You can't export/not export them. What do you mean?
17:16:43 <ReinH> True enough
17:16:44 <Zekka> AFAIK dfeuer is correct and that it's bitten me on the rear before
17:16:54 <ReinH> That's rather annoying then
17:17:25 <EvanR> Zekka: ok that makes sense
17:17:37 <dfeuer> ReinH, it's a problem for sure; it's a problem several people have tried to solve, and have even written papers about, but so far none of the solutions are remotely satisfactory.
17:17:42 <Zekka> EvanR: FYI I don't really expect you to listen to me and I'm also not a real expert
17:17:49 <ReinH> dfeuer: Interesting.
17:17:55 <ReinH> Somehow I haven't encountered that yet.
17:19:21 <Zemyla> Okay, I had a weird thought.
17:19:35 * hackagebot hasql 0.6.0 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.6.0 (NikitaVolkov)
17:19:36 <dfeuer> ReinH, there was one paper that suggested replacing Haskell's class system entirely with something like ML functors in order to address this problem. Then there was a somewhat more subtle attempt that made much less overblown claims but still admitted in the end that it had not entirely succeeded.
17:19:37 * hackagebot hasql-postgres 0.10.0 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.10.0 (NikitaVolkov)
17:19:51 <ReinH> dfeuer: welp
17:19:59 <dfeuer> I don't even know what that means.
17:20:09 <Zemyla> Aside from the whole "Ord restriction" thing, sets form a monad.
17:20:27 <ReinH> dfeuer: what "welp" means?
17:20:31 <dfeuer> Right.
17:20:43 <ReinH> dfeuer: http://www.urbandictionary.com/define.php?term=Welp
17:20:51 <ReinH> Sort of "well then"
17:20:54 <dfeuer> Ah.
17:21:04 <Zemyla> However, sets have a perfectly good comonadic "duplicate" operation, which is simply the power set.
17:21:24 <Romefeller> all of you work with haskell in production??
17:21:30 <EvanR> Zemyla: what is extract?
17:21:33 <Zemyla> dfeuer: "Welp" is "well then" but with more resignation.
17:21:34 <dfeuer> Romefeller, no, not all of us.
17:21:34 <Romefeller> Im new to haskell and im loving it
17:21:34 <jle`> wabaout extract
17:21:39 <Zekka> Romefeller: Very, very little
17:21:48 <Zekka> I don't know if there's any left in our system right now
17:21:59 <Romefeller> Zekka why?
17:22:09 <Zemyla> EvanR: That's what I was wondering about.
17:22:15 <Zekka> Romefeller: Because we're in Java and Clojure and Scala are more tempting
17:22:30 <Romefeller> Im so amazed with haskell power
17:22:45 <dfeuer> Zekka, also more unreadable, which must be good for job security or something.
17:22:48 <Zekka> IIRC we aren't using much (any?) scala right now, we used a ton of Clojure but found it hard to maintain
17:23:16 <Zekka> It ate up one of our projects -- we'd originally planned to use a Clojure DSL but ended up implementing way too much in it
17:23:19 <Zekka> and found it to be horrific to debug
17:23:22 <jle`> Zemyla: what do you mean by a perfectly good comonadic duplicate?
17:23:49 <Zemyla> powerset :: Set a -> Set (Set a).
17:23:50 <jle`> isn't duplicate for comonads only really defined in terms of extract?
17:24:05 <Zekka> I think everyone's pretty turned off to things that don't play well with Java stack traces and Eclipse
17:24:13 <Romefeller> Zekka im a former Java dev. Now i just teach it.
17:24:20 <quchen> jle`: duplicate is cojoin, extract is coreturn, extend is cobind
17:24:23 <jle`> as in, how do you know it follows the laws for `duplicate` if you don't have extract?
17:24:28 <Zekka> The shop is pretty conservative as it is, I'm the most active programmer and spearheading a port from Visual Basic 6 of our main product
17:24:31 <EvanR> Romefeller: can you unteach it?
17:24:36 <Zemyla> jle`: extract f is fmap f . extract.
17:24:44 <Zemyla> Actually, I have it.
17:24:52 <jle`> ah, okay :)
17:25:00 <Romefeller> EvanR why unteach??
17:25:14 <EvanR> java needs some creative destruction
17:25:14 <Zekka> I don't hate Java probably as much as I should -- it's deeply flawed and frustrating in a lot of ways but it's not so bad as to be unworkable
17:25:15 <Zemyla> extract s is the largest element in s.
17:25:31 <jle`> if you don't have `extract`, then your "duplicate" is just something that "typechecks"...it's not really duplicate
17:25:34 <Zekka> and it's (generally) not bad in ways that make it hard to write large programs in it (compare C, C++)
17:25:36 <jle`> just like fmap f xs = []
17:25:43 <bitemyapp> I have a cantankerous library
17:25:44 <jle`> Zekka: what about for empty sets?
17:25:45 <Romefeller> EvanR lol. After this month with haskell im starting to unlike it
17:25:47 <EvanR> Zemyla: so this is only for sets of sized things
17:25:56 <bitemyapp> that returns IO (m a) and the only thing I know about the m is it implements MonadError
17:26:03 <jle`> er sorry, Zemyla
17:26:05 <bitemyapp> how do I foldM a function that returns this?
17:26:09 <jle`> ^^ what about for empty sets?
17:26:48 <Zekka> I think I'll be back later
17:26:57 <Zemyla> Well, hold on. For non-empty sets, getting the largest set in the powerset is just the set itself.
17:27:00 <EvanR> :t liftA
17:27:01 <lambdabot> Applicative f => (a -> b) -> f a -> f b
17:27:10 <Saizan> bitemyapp: if it's polymorphic you can choose the m
17:28:04 <Romefeller> anyone here work with haskell?
17:28:12 <Zemyla> And then if you do extend extract, it pulls the largest element from each of the nonempty sets, and for every element in s there is a subset of s where it is the largest element.
17:28:38 <Zemyla> Romefeller: No, no one here ever works with Haskell in the #haskell ch
17:28:43 <Zemyla> *channel.
17:28:52 <jle`> :P
17:29:02 <jle`> so, what is extract (fromList []) ?
17:29:13 <jle`> that's an interesting correspondence though :)
17:29:23 <Romefeller> Zemyla that's so sad. Time to startups lol
17:29:29 <Zemyla> We're here because we enjoy eating Haskell curry.
17:29:32 <bitemyapp> Saizan: how? I tried a function alias with a more monomorphic type but it didn't work.
17:29:35 * hackagebot SWMMoutGetMB 0.1.0.0 - A parser for SWMM 5 binary .OUT files  http://hackage.haskell.org/package/SWMMoutGetMB-0.1.0.0 (siddhanathan)
17:29:37 <bitemyapp> where rf = readfile :: ConfigParser -> FilePath -> IO (Either CPError ConfigParser)
17:29:39 <EvanR> restrict this to Non-empty sets of sized items ;)
17:29:47 <jle`> Romefeller: i work with haskell :D
17:30:21 <Romefeller> jle` nice. What country?
17:30:29 <Zemyla> EvanR: They don't have to be sized, just ordered.
17:30:36 <EvanR> ok
17:31:20 <EvanR> well the a in Comonad a is expecting any items, rather than ordered items
17:31:25 <Romefeller> .
17:31:57 <dhrosa> i'm dealing with a JSON API that returns timestamps in a format like this: 1234567890.123456, what's the most appropriate Haskell type for this? e.g. is there a reccomended Decimal library?
17:32:03 <jle`> Romefeller: in the states, but i really only use it for research, does that count :P
17:32:04 <EvanR> the ordering operation in the definition would have to come from somewhere, maybe a new class just for Sets ;)
17:32:06 <dhrosa> or a built-in timestamp type that works like that
17:32:14 <jle`> i know plenty of people here do work with haskell though :)
17:32:26 <bitemyapp> Zemyla: looks like it has a forceEither that might be what I wanted.
17:32:54 <bergmark> dhrosa: scientific if you want arbitrary precision, otherwise use Float/Double
17:32:57 <EvanR> dhrosa: UTCTime
17:33:12 <EvanR> which uses Data.Fixed Pico to store the number
17:33:35 <bitemyapp> oh god, that is not what I wanted
17:33:38 <bitemyapp> that looks like a partial function. gag.
17:33:42 <EvanR> (if aeson fixed the utctime problem)
17:34:27 <pnielsen> Romefeller: <- for a living
17:34:28 <Zemyla> Also, the other problem with my proposed extract function is that extract . fmap f = f . extract only when f is a monotonic function.
17:35:32 <pnielsen> Romefeller: don't worry, you won't have any issues finding a haskell job :)
17:36:13 <Romefeller> pnielsen Im from Brazil dude. People here still trapped in OOP lol. I want to startup with haskell
17:36:40 <quchen> The Haskell job market in Europe isn't exactly large either.
17:36:49 <bergmark> Romefeller: i'm working with haskell at Silk(.co) in amsterdam
17:36:52 <Zemyla> Also, is Mario a monad and Wario a comonad?
17:36:57 <pnielsen> the Haskell job market isn't large anywhere, but there aren't a lot of Haskell programmers either
17:37:18 <slack1256> Any southamerican haskeller around?
17:37:22 <Romefeller> pnielsen that's good. It is an opportunity
17:37:26 <Romefeller> slack1256 me
17:37:44 <pnielsen> I always found this argument that you have to learn Java or <insert other mainstream language here> to get a job preposterous
17:37:46 <sipa> Zemyla: so Mario is a cowario, which is probably italian for coward?
17:38:23 <slack1256> Brazil is the biggest country of SA and probably has the most haskellers around, any conference anywhere on it?
17:38:26 <pnielsen> and in my experience it's silly to worry about job prospects. The companies that do use Haskell use it for way cooler stuff, and when they need to hire, you go to the top of the list just for knowing Haskell
17:38:48 <Romefeller> slack1256 few haskellers here. In my city i never saw one.
17:39:03 <pnielsen> in fact, nearly every crazy-good job Software Engineer-ish offer I've gotten has been for Haskell or some other FP (but usually Haskell)
17:39:23 <Saizan> bitemyapp: do you have a link to the actual type?
17:39:51 <bitemyapp> Saizan: https://hackage.haskell.org/package/ConfigFile-1.1.3/docs/Data-ConfigFile.html#v:readfile
17:39:58 <bitemyapp> Saizan: mapM/traverse work pretty easily, foldM is being a PITA.
17:40:27 <bitemyapp> Wanted to return `EitherT CPError IO ConfigParser` from the enclosing function.
17:40:37 <bitemyapp> liftIO $ foldM readfile emptyCP configFiles
17:40:39 <Romefeller> pnielsen i was a Java dev. Now im teaching OOP and Design Patterns. Im on haskell this month only. Im loving it. Im so sick of OOP
17:40:47 <slack1256> Romefeller: I will send a mail to cafe to see how many south americans are on it and see if we can do a reunion of some sort
17:40:47 <bitemyapp> Expected type: ConfigParser -> FilePath -> IO ConfigParser         Actual type: ConfigParser -> FilePath -> IO (m0 ConfigParser)
17:41:26 <Romefeller> slack1256 good idea!
17:41:27 <pnielsen> Romefeller: Alan Kay is sick of today's "OOP." That should be a clue to most people...
17:41:38 <Zemyla> Actually, Wario is at least Applicative, because if he eats a function f, and them eats a value a, he has (f a) in his stomach.
17:41:44 <Saizan> bitemyapp: foldM (\ x y -> EitherT (readfile x y)) emptyCP configFiles
17:42:26 <bitemyapp> Expected type: IO ConfigParser       Actual type: EitherT CPError IO ConfigParser
17:42:37 <Saizan> bitemyapp: remove the liftIO?
17:42:40 <bitemyapp> oh, sorry.
17:42:51 <bitemyapp> ah bloody hell.
17:42:54 <Romefeller> pnielsen Yeah. Im very very sick
17:42:55 <bitemyapp> Saizan: brill. Thank you very much.
17:43:01 <Saizan> cheers
17:43:35 <dhrosa> EvanR: what about the intermediate format? I'll have to parse ot the JSON value as some type, and UTCTime needs some processing
17:43:56 <EvanR> dhrosa: in aeson, it converts it for you
17:43:56 <dhrosa> EvanR: I'll still need to parse the JSON value as some sort of numeric type before I put it into UTCTime, as UTCTime requires me extracting the day # out of it
17:44:12 <EvanR> UTCTime should have a FromJSON instance
17:44:22 <dhrosa> oh, let's try this
17:44:24 <EvanR> (though i think it was malfunctioning at some point last i checked)
17:44:44 <dhrosa> do you know that it reads in decimal timestamps like that?
17:45:05 <bitemyapp> Saizan: that has worked out very nicely. Thank you.
17:45:06 <EvanR> if it doesnt, then you should be able to define a newtype
17:46:09 <bitemyapp> @pl (\x y -> EitherT (readfile x y))
17:46:09 <lambdabot> (EitherT .) . readfile
17:50:23 <EvanR> > parseTime defaultTimeLocale "%s%Q" "1234567890.423" :: Maybe UTCTime
17:50:24 <lambdabot>  Not in scope: type constructor or class ‘UTCTime’Not in scope: ‘parseTime’No...
17:50:52 <ionum> hi
17:51:05 <ionum> can anyone help me with hspec?
17:53:02 <EvanR> dhrosa: that code will convert the string to the utctime, would be nice if that could be fit into aeson. by defining the FromJSON instance for a newtype JSONUTC = JSONUTC UTCTime using the above code, and asking for a Maybe JSONUTC...
17:53:25 <EvanR> i have a feeling the current instance for UTCTime uses a weird ass format
17:53:41 <pavonia> ionum: What is your question?
17:54:05 <dhrosa> ugh, the timestamp is a strong in the JSON, I have to add in a step to convert it to a proper number
17:54:30 <EvanR> dhrosa: i wrote code above to convert it from a String to a Maybe UTCTime
17:54:34 <EvanR> no numbers
17:55:17 <dhrosa> oh there it is
17:55:20 <dhrosa> missed it
17:55:28 <EvanR> dhrosa: also its only a String if you ask for a String, or a Value. by asking for specific types it will try to convert for you
17:56:48 <dhrosa> I didn't ask for a String, I asked for a Fixed, but in the json text itself, it has timestamp: "123.456", instead of timestamp: 123.456
17:56:57 <dhrosa> but I'll try your snippet in a second
17:58:19 <EvanR> if you asked for a number, and it cant convert to the right type, you should get a parse error, not a string
17:58:55 <dhrosa> sorry, I wasn't clear. there was a parse error that there was an unexpecting String
17:59:10 <EvanR> yeah so it doesnt know how to convert a string to a number i guess
17:59:37 <EvanR> Maybe Pico might work
17:59:46 <EvanR> and youd get Nothing, which is wrong so nevermind
18:10:26 <dhrosa> EvanR: works beautifully, thanks!
18:20:34 <bimboum> OK. So, control.monad.state is basically giving  you a way to build a complex function that once evaluated gives the final state. And since everything is usually lazy, the function creation and its evaluation happens mostly at the same time. Kind of mind boggling. And at the end, it just looks like imperative using this do sugar. hmmm :-)
18:21:01 <trap_exit> is there anyway to do 'interactive scientific computing', i.e. Julia / R / MatLab, ... but in Haskell ?
18:22:01 <EvanR> :t runState
18:22:02 <lambdabot> State s a -> s -> (a, s)
18:22:22 <bimboum> Reading https://www.haskell.org/haskellwiki/State_Monad and trying to unwarp everything with pen and paper just make everything kind of magic. It just works but the intrinsics reason why it works sounds like magic to me
18:22:38 <bimboum> (section 3)
18:22:43 <EvanR> runState (modify (+1) >> modify (+1)) 0
18:22:50 <EvanR> > runState (modify (+1) >> modify (+1)) 0
18:22:52 <lambdabot>  ((),2)
18:23:08 <pavonia> trap_exit: Load a math library into GHCi?
18:24:40 <benzrf> > execState (modify (+1) >> modify (+1)) 0
18:24:42 <lambdabot>  2
18:24:55 <bimboum> I see how it works and more or less why but I am failing to see how anybody can end up making this mapping between imperative programming and function composition. Is there any good material (more theoretical I imagine) trying to expose all this in a more formal way?
18:25:17 <bimboum> I would like to understand why it just works
18:25:17 <EvanR> bimboum: State isnt magic, and you can write a State program without using monads at all. just by sequentially using s -> (a,s) functions, with sequences of let (x, s''') = f s'' a b in etc
18:25:17 <benzrf> bimboum: in the case of the State monad, the real point is kleisli composition
18:25:51 <benzrf> bimboum: a kleisli State arrow looks like `a -> s -> (b, s)'
18:26:09 <benzrf> bimboum: it's a function from a pair to a pair
18:26:35 <benzrf> bimboum: if you were to represent your state Kleisli arrows uncurried, you could compose them directly
18:28:53 <dhrosa> bimboum: the State monad is just a nice abstraction around composition together functions of the type a -> (a, s)
18:29:03 <dhrosa> damnit didn;t notice EvanR's response again
18:29:57 <eyebloom> Can a type class be instantiated for a type constructor?
18:30:15 <EvanR> yeah, instance Functor Maybe where
18:30:51 <dhrosa> bimboum: LYAH has a section on monads, and they go over how to implement all the common ones, like State
18:31:02 <dhrosa> it's not compiler magic
18:31:04 <eyebloom> I’m speaking of type synonym.
18:31:09 <bimboum> EvanR: this part is the most obvious but this is really the way everything fits (do syntactic sugar, monadic bind) that eludes me. Or rather, it sounds more like maths i.e. you build abstract structure on top of others and the final one becomes very complex when  you try to go back top to bottom.
18:31:38 <eyebloom> as in: type MyFunction a = a -> a
18:31:41 <geekosaur> I think you need an extension for that (TypeSynonymInstances)
18:32:04 <geekosaur> as a warning that insnantiating for a type synonym does not create an instance distinct from the original
18:32:34 <benzrf> eyebloom: perhaps you want Endo
18:32:44 <geekosaur> I was just thinking that
18:33:30 <benzrf> i wonder if showing the Endo monoid and requesting a generalization would be a good way to introduce people to categories
18:33:52 <EvanR> bimboum: whats nice is if you start with simple stuff (even if it seems TOO simple) and work your way up in simple steps, and you end up with something really nice, dont worry about how it works underneath, thats the abstraction pattern
18:34:00 <eyebloom> Basically I’m trying to use typeclasses to automatically differentiate between functions with different arity.
18:34:27 <dhrosa> it's kind of like proof by induction, you prove a really simple case, show that one step can lead from a previous step, and you prove something much more complex
18:34:39 * hackagebot hasql-postgres-options 0.1.3 - An "optparse-applicative" parser for "hasql-postgres"  http://hackage.haskell.org/package/hasql-postgres-options-0.1.3 (NikitaVolkov)
18:34:52 <hiptobecubic> When would you want ErrorT not to be the outermost monad in a transformer stack? Assuming you're using it, of course
18:35:13 <EvanR> bimboum: but really, i havent found a lot of use for basic State monad
18:35:18 <LordBrain> eyebloom, as in functions of a given arity are all instancess of type class ArityN ?
18:35:50 <dhrosa> that reminds me, can anyone tell me how the order of monad transformer layers affects things?
18:36:10 <hiptobecubic> I have an `ErrorT String (StateT AppState IO) a`, which seems right, but when you unwrap it you run the error monad first and end up with StateT AppState IO a, which seems odd
18:36:20 <hiptobecubic> err no, that's wrong
18:36:30 <eyebloom> No the typeclass would provide generalized functions for functions of arity n.
18:36:30 <hiptobecubic> StateT AppState IO (Either String a)
18:36:57 <Hijiri> you might want a stateful computation that fails entirely if part of it fails
18:37:23 <hiptobecubic> Hijiri, isn't that what I have here?
18:37:33 <hiptobecubic> Oh.. no.
18:37:35 <hiptobecubic> I seee
18:37:38 <Hijiri> you have a stateful computation where individual parts can fail
18:37:40 <hiptobecubic> Damnit.
18:37:41 <Hijiri> and you can examine that
18:37:43 <hiptobecubic> Right
18:37:44 <Hijiri> and keep your state
18:37:55 <Hijiri> in the other case you lose your state if it fails
18:37:58 <bimboum> EvanR, dhrosa: I am starting to see how haskell now departs from all other language (include ML and the rest). This is just functions and the language challenge becomes how to make things usable and with a decent syntax just with that. I need to sleep now. Thanks for your comment!
18:37:59 <hiptobecubic> Dammit, rather. :)
18:38:46 <hiptobecubic> Hijiri, so monad transformer stacks are inverted then.
18:39:01 <Hijiri> yeah, sort of
18:39:57 <eyebloom> member:identifier:lordbrain: Here’s a super simple example: http://lpaste.net/117360
18:40:46 <eyebloom> Though I’m sure this would not compile
18:41:43 <eyebloom> I could write another type constructor MyFunction2 a :: a -> a -> a ->  a
18:42:19 <eyebloom> Sorry that should be an equals sign instead of ::
18:42:29 <hiptobecubic> So if I want failure to abort the rest of the state computation i need to flip my transformers
18:42:38 <hiptobecubic> (Monads in disguise)
18:42:45 <EvanR> lol
18:42:46 <LordBrain> hmm hlint on lpaste is nice sometimes but also kind of annoying
18:43:19 <EvanR> State, Parser, Random, Error, Cont, these could be transformer names
18:43:55 <EvanR> IOT would be like unicron
18:44:11 <geekosaur> there've been times when I really wanted to turn it off; heuristic checking can become confused and several times I've seen it suggest things that won't work (usually because it doesn't recognize some higher order stuff)
18:46:24 <hiptobecubic> lately hlint has been helping me express my ill-typed programs very concisely
18:46:36 <eyebloom> I guess I’m always wanting a level of polymorphism from Haskell that it doesn’t want to provide….
18:50:01 <pavonia> eyebloom: What exactly is your question?
18:53:44 <vanila> Anyone know how to get stackage set up?
18:54:43 <pavonia> Isn't that just a huge cabal package?
18:54:53 <vanila> i dont really know
18:55:07 <vanila> http://www.stackage.org/lts/cabal.config
18:55:09 <vanila> i have this file
18:55:37 <eyebloom> Is it possible to instantiate a typeclass over a type constructor of kind * -> *
18:55:37 <vanila> im not sure where to save that, how this relates to sandbox etc..
18:55:44 <vanila> is there a guide I can read
18:55:50 <eyebloom> or does it need to be of kind *
18:56:12 <vanila> eyebloom, monad does this
18:56:16 <n4x> Functor/Applicative/Monad are all higher-kinded
18:56:27 <n4x> I think you've the answer
18:56:50 <eyebloom> Thanks I’ll take a look at the source for those.
18:57:11 <pavonia> vanila: "Please place this file next to your .cabal file as cabal.config." Have you done this?
18:57:29 <c_wraith> eyebloom: the problem in your case is that you can't instantiate a typeclass with a type alias.
18:57:47 <vanila> I just made a new folder for this stuff so I guess not - where do I get a .cabal file?
18:58:00 <Zemyla> What's the difference betweem a Monoid and a MonadPlus?
18:58:00 <c_wraith> vanila: you can use cabal init
18:58:08 <vanila> alright
18:58:15 <Zemyla> Is a MonadPlus just a Monoid that's also a Monad?
18:58:25 <c_wraith> Zemyla: the kind.  Monoid requires something of kind *, MonadPlus (and Alternative) require something of kind * -> *
18:58:45 <c_wraith> Zemyla: ie, [a] is a Monoid, [] is a MonadPlus
18:58:54 <vanila> should I do cabal init before or after I get this stackage file?
19:00:22 <Zemyla> So MonadPlus m => Monoid (m a)?
19:00:56 <c_wraith> Zemyla: well, the kinds line up, but there isn't a definition like that.
19:01:10 <eyebloom> c_wraith: Thanks, I think you can do that with the TypeSynonymInstances extension.
19:01:10 <c_wraith> Zemyla: because it'd overlap with all kinds of things
19:01:56 <c_wraith> eyebloom: you can, but it often just ends up papering over more severe issues that you'll uncover quickly
19:02:52 <eyebloom> c_wraith: Understood, my end goal is to create a cleaner interface for a module.
19:03:05 <Zemyla> So if you are defining something that satisfies the monadplus laws, you just define Monoid (m a) yourself?
19:03:24 <c_wraith> Zemyla: or you never define the Monoid instance at all.
19:03:45 <c_wraith> Zemyla: depending on the meaning of the type?
19:03:53 <eyebloom> In it’s current state the user of the module would need to wrap parameters depending on the arity of a functino being passed as a parameter.
19:04:24 <eyebloom> I’d like to use typeclasses to determine the appropriate action based on the arity.
19:04:40 <dfeuer> I don't understand the TypeSynonymInstances concept.
19:05:03 <c_wraith> eyebloom: that's difficult to do, because function arity is either always 1, or hard to figure out. :)
19:05:48 <n4x> @type undefined
19:05:49 <lambdabot> a
19:05:55 <dfeuer> c_wraith, depending on what you mean by arity, I guess?
19:06:06 <vanila> "At that point you definitely need to stop using Stackage and start using a sandbox." do sandboxes subsume stackage?
19:06:08 <eyebloom> c_wraith: Does that mean it’s actually impossible because of type erasure>
19:06:09 <n4x> @type (undefined :: [a] -> Maybe b -> IO a -> b
19:06:10 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
19:06:12 <n4x> @type (undefined :: [a] -> Maybe b -> IO a -> b)
19:06:13 <lambdabot> [a] -> Maybe b -> IO a -> b
19:06:16 <c_wraith> dfeuer: I mean, how many arguments does printf take? :)
19:06:30 <c_wraith> eyebloom: it's because of polymorphism, not erasure
19:06:35 <dfeuer> c_wraith, oh gosh, that horrifying thing.
19:06:49 <c_wraith> dfeuer: the answer is either "1" or "I have no idea"
19:07:00 <dfeuer> c_wraith, I actually don't remember how that works.
19:07:13 <dfeuer> c_wraith, also, there's the possibility of "not a function"
19:07:15 <c_wraith> :t printf
19:07:16 <lambdabot> PrintfType r => String -> r
19:07:20 <c_wraith> dfeuer: true
19:07:42 <EvanR> > printf "%d" 4
19:07:44 <lambdabot>  No instance for (GHC.Show.Show a0)
19:07:44 <lambdabot>    arising from a use of ‘M257751521770202004920203.show_M2577515217702020049...
19:07:44 <lambdabot>  The type variable ‘a0’ is ambiguous
19:08:02 <dfeuer> > printf "%d" (4::Int)
19:08:03 <lambdabot>  No instance for (GHC.Show.Show a0)
19:08:03 <lambdabot>    arising from a use of ‘M716489346181490534520228.show_M7164893461814905345...
19:08:03 <lambdabot>  The type variable ‘a0’ is ambiguous
19:08:05 <c_wraith> EvanR: it's too polymorphic.  tell it you want a string
19:08:05 <dfeuer> Nope.
19:08:12 <EvanR> > printf "%d" 4 :: String
19:08:13 <lambdabot>  "4"
19:08:37 <vanila> lost :(
19:08:59 <EvanR> dont try to understand printf, youll hurt yourself
19:10:16 <dfeuer> c_wraith, I imagine printf with a lot of arguments could slow down type inference, right?
19:10:25 <eyebloom> c_wraith: So it sounds like we can’t differentiate between instances based only on the overall structure of the function.
19:10:48 <dfeuer> Oh wait...
19:11:00 <c_wraith> dfeuer: possibly, though things like "id id id id id id id id id" require exponential space in the number of "id"s already...
19:11:08 <c_wraith> dfeuer: (to typecheck, that is)
19:11:19 <dfeuer> c_wraith, printf isn't *really* proving your point, is it? Once you've decided on its type, its arity becomes much clearer, doesn't it?
19:11:50 <dfeuer> > id id id id id id id id id id id id 3
19:11:52 <lambdabot>  3
19:11:58 <dfeuer> > id id id id id id id id id id id id id id id id 3
19:11:59 <lambdabot>  3
19:12:04 <dfeuer> > id id id id id id id id id id id id id id id id id id id id id id 3
19:12:08 <lambdabot>  mueval-core: Time limit exceeded
19:12:10 <dfeuer> OK.
19:12:15 <vanila> :t f x = x id id id id id id id id id id id 3 in f
19:12:16 <lambdabot> parse error on input ‘=’
19:12:18 <n4x> things like "id" can be of "n-th" arity too
19:12:19 <vanila> :t let f x = x id id id id id id id id id id id 3 in f
19:12:20 <lambdabot> Num a11 => ((a -> a) -> (a1 -> a1) -> (a2 -> a2) -> (a3 -> a3) -> (a4 -> a4) -> (a5 -> a5) -> (a6 -> a6) -> (a7 -> a7) -> (a8 -> a8) -> (a9 -> a9) -> (a10 -> a10) -> a11 -> t) -> t
19:12:27 <c_wraith> dfeuer: my point was more that the arity can only be figured out when you have a concrete type.  When it's got a polymorphic return value, you just aren't sure yet.
19:12:28 <n4x> @type id :: (a -> b -> c) -> a -> b -> c
19:12:29 <lambdabot> (a -> b -> c) -> a -> b -> c
19:12:38 <dfeuer> Yaw.
19:12:43 <n4x> and c can be (d -> e) ...
19:14:23 <Zemyla> c_wraith: Then how does Text.Printf work?
19:14:33 <dfeuer> Do people actually *use* printf, or is it more for demonstrating that you can do crazy things even within a proper type system?
19:14:40 <c_wraith> dfeuer: mostly the latter.
19:14:56 <int-e> :t let f x = (x `asTypeOf` id) id id id id in f
19:14:57 <lambdabot> (((((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> a -> a
19:15:45 <c_wraith> Zemyla: I don't really know, in all honesty.  I don't think I'll ever know unless I try to implement it myself.
19:15:46 <EvanR> > (1 :+ 2) > 0
19:15:48 <lambdabot>  No instance for (GHC.Num.Num a0) arising from the literal ‘1’
19:15:48 <lambdabot>  The type variable ‘a0’ is ambiguous
19:15:48 <lambdabot>  Note: there are several potential instances:
19:16:07 <Zemyla> :t printf
19:16:07 <lambdabot> PrintfType r => String -> r
19:16:45 <Zemyla> :t printf "%f %s" 3.14 "pi"
19:16:45 <EvanR> > (1.0 :+ 2.0) > 0
19:16:46 <lambdabot> PrintfType t => t
19:16:46 <lambdabot>  No instance for (GHC.Real.Fractional a0)
19:16:47 <lambdabot>    arising from the literal ‘1.0’
19:16:47 <lambdabot>  The type variable ‘a0’ is ambiguous
19:17:13 <Zemyla> > printf "%f %s" 3.14 "pi"
19:17:15 <lambdabot>  No instance for (GHC.Show.Show a0)
19:17:15 <lambdabot>    arising from a use of ‘M873056781084148452520499.show_M8730567810841484525...
19:17:15 <lambdabot>  The type variable ‘a0’ is ambiguous
19:17:43 <n4x> > printf "%f %s" pi "pi" :: String
19:17:44 <lambdabot>  "3.141592653589793 pi"
19:17:51 <n4x> Zemyla: ^^
19:20:11 <Javran> http://lpaste.net/117361 I want to use the case guard, but ghc complains about syntax error, any idea?
19:24:54 <pavonia> Javran: Try this one http://lpaste.net/117362
19:26:33 <Javran> pavonia: thanks, that works. maybe https://www.haskell.org/haskellwiki/Case should be updated.
19:27:53 <Zemyla> Ohhh, I think I have a beginning of an idea on how printf works.
19:29:13 <eyebloom> c_wraith: Looking through the source for class Monad I’m pretty sure there are no instances over something of kind * -> *, it’s pretty clear that only inhabited types can have instances.
19:29:46 <eyebloom> Which basically answers my question.
19:29:57 <pavonia> > case 3 of { x | x > 5 -> "foo" | x > 0 -> "bar" }
19:29:58 <lambdabot>  "bar"
19:30:01 <c_wraith> eyebloom: fascinating conclusion.  How do you reach it?  (it's wrong, by the way)
19:30:28 <Zemyla> If you type printf "%f %s" pi "pi" :: String, then it takes (printf "%f %s") first and evaluates it, getting some kind of PrintfType.
19:30:38 <pavonia> Javran: That seems to work, so I guess you indentation was only wrong
19:30:41 <eyebloom> I’d love it if it was.
19:30:50 <eyebloom> But I can’t find an example.
19:31:25 <c_wraith> eyebloom: every instance of Monad is over something with the kind * -> *.  Every single one.
19:31:26 <Zemyla> It's being called with the value pi, so it tries to figure out what PrintfType it is, and there are three possibilities.
19:32:21 <Zemyla> It could be IO a, String. or (PrintfArg a, PrintfType r) => a -> r, and only the last can be called with an argument.
19:33:17 <Zemyla> With this knowledge, I can create my own variadic functions.
19:33:18 <c_wraith> eyebloom: You can see that just from "class Monad m where return :: a -> m a"
19:33:29 <c_wraith> eyebloom: the class is over the type m, not the type a
19:33:35 <EvanR> destroy the knowledge at all costs
19:34:07 <c_wraith> eyebloom: (->) has the kind (* -> * -> *), so its two arguments must have kind *, so a :: *, and m a :: *
19:34:26 <c_wraith> eyebloom: the combination of those is enough to infer that m :: * -> *
19:34:37 <Zemyla> Never. I will create a variadic tuple constructor and there's nothing you can do to stop me :D
19:35:05 <EvanR> insolence
19:35:37 <khyperia> Hey all, I'm digging my way through http://www.stephendiehl.com/posts/monads.html and I'm wondering if there's other similar readings that people know of.
19:36:04 <dfeuer> Zemyla, no, you are wrong.
19:36:05 <eyebloom> I see. I’m just trying to understand so I can write better code. Why if I say “instance Ford Zaphod where …  Zaphod has kind * -> * the compiler will report that Zaphod is missing an application.
19:36:44 <c_wraith> eyebloom: unless the class is kind-polymorphic, the kind of the type variable must match the kind of the class.
19:37:13 <eyebloom> I see. So how would a declare a kind polymorphic class?
19:37:19 <dfeuer> Zemyla, GHC never guesses at types (except in error messages). It needs to figure them out properly. There is no process of elimination possible.
19:37:36 <c_wraith> eyebloom: you would need a class definition that allowed it.  Then you'd need GHC's PolyKinds extension.
19:37:58 <dfeuer> eyebloom, you'd also probably have to leave your sanity at the door.
19:38:13 <c_wraith> eyebloom: oftentimes, the kind of a class is fixed by the definitions in the class
19:38:24 <Zemyla> dfeuer: Well, GHC can figure it out somehow.
19:38:46 <dfeuer> c_wraith, what sort of class definition would allow such a thing? I'm sure one whose only members are associated types will do, and I guess you can probably do something with MPTC, but ... I dunno, that's confusing.
19:38:55 <eyebloom> dfeuer: I understand what you mean. But unfortunately the alternative, which is basically wrapping everytihng in a GADT, is also quite messy.
19:39:09 <dfeuer> Zemyla, you're starting in the wrong place. The string isn't inspected until runtime.
19:39:14 <c_wraith> dfeuer: nah.  Typeable and Category are both Polykinded
19:39:37 <dfeuer> o.O
19:40:24 <Zemyla> dfeuer: So in your words, how does printf work?
19:41:38 <dfeuer> Zemyla, I don't know the details, It has type PrintfType r => String -> r, so we should be able to work some things out.
19:42:24 <dfeuer> If we say   printf s :: String, then it knows we want printf s to have type String, so printf :: String -> String
19:42:46 <dfeuer> So we've chosen the String instance of the PrintfType class.
19:43:32 <dfeuer> If instead wi had   printf s (3::Int)::String, then it infers  printf :: String -> Int -> String, meaning we've chosen the PrintfType instance  Int -> String
19:44:34 <dfeuer> There are probably a bunch of instances that start out  instance PrintfType foo => PrintfType (T -> foo)
19:44:45 <dfeuer> Zemyla, ^^
19:45:32 <Zemyla> dfeuer: It's actually (PrintfArg a, PrintfType foo) => PrintfType (a -> foo).
19:45:34 <dfeuer> These instances will deconstruct their piece of the format string and do something with it.
19:45:48 <dfeuer> Zemyla, okay, whatever. I was close.
19:45:50 <mjrosenb> looks like haskell support for flac is limited :-(
19:46:08 <gfixler> for game loops, are there useful/interesting alternatives to passing the world around as a map?
19:46:31 <dfeuer> Zemyla, I guess it uses FlexibleInstances to save some work, or semething?
19:46:39 <dfeuer> Oh wait, no.
19:46:42 <dfeuer> Sorry.
19:46:45 <Zekka> gfixler: You could embrace IO and use IORefs and stuff for everything
19:46:49 <dfeuer> Whoa...
19:46:57 <Zekka> I'm assuming that State is too close to just "passing the world around as a map" for you
19:47:13 <gfixler> Zekka: for very simple games, you can use whatever structure(s)
19:47:14 <dfeuer> Zekka, IORefs are not free.
19:47:31 <gfixler> Zekka: but for a world that dynamically grows and changes, all I can imagine is a big, ugly map
19:47:47 <gfixler> I don't know IORefs yet - I'll have to look them upnext
19:47:57 <Zekka> dfeuer: I don't think it's a good idea!
19:48:04 <dfeuer> gfixler, they're not free, and they're likely not what you want.
19:48:06 <Zekka> But he asked for an alternative.
19:48:10 <gfixler> dfeuer: noted
19:48:12 <dfeuer> They can be kind of slow, actually.
19:48:32 <gfixler> well, not so much an alternative as alternatives that are known and in-use
19:48:42 <Zekka> Personally I'd just use State and Lens-style zooming along with occasional Reader instead of State
19:48:43 <gfixler> if no one can think of anything, I'll have to go with a big, ugly map
19:48:58 <eyebloom> Is there any special meaning to a data constructor that ends with #?
19:48:58 <Zekka> The data structure would probably basically amount to a record type
19:49:13 <gfixler> Zekka: okay - this is sort of where I was heading
19:49:16 <dfeuer> gfixler, what sort of big, ugly map are you talking about?
19:49:31 <gfixler> dfeuer: lots of NPCs with stats, world map stuff, etc
19:49:39 <gfixler> i.e. 'a big game'
19:49:57 <EvanR> you can represent your game entities and properties using a bunch of indexes into an EAV data set
19:50:01 <dfeuer> Separate this state into sensible pieces.
19:50:02 <gfixler> not that I'm making one, but I'm starting into game programming in haskell, and want to head the right directions
19:50:09 <Zekka> It's going to be uglyi n the sense that you'll be looking at a hodgepodge collectio nof apparently unrelated things no matter what -- even if you segregate it into pieces
19:50:09 <dfeuer> EvanR, what is EAV?
19:50:13 <Zekka> But that's not a Haskell problem
19:50:19 <EvanR> entity attribute value
19:50:21 <c_wraith> dfeuer: the Category class, for instance is "class Category c where id :: c a a ; (.) :: c b d -> c a b -> c a d".  there's nothing in that definition that requires the arguments to c be of any particular kind..  Just that c have the kind (k -> k -> *)
19:50:25 <Zekka> Games involve a lot of unrelated things and you'll inevitably be enumerating them in some sense
19:50:37 <Zemyla> The kind of stuff you'd dump into a global variable in any other language/
19:50:52 <dfeuer> c_wraith, I see....
19:50:57 <gfixler> Zekka: true
19:51:05 <EvanR> you can then make views and updates on this data set
19:51:16 <dfeuer> c_wraith, and what does this let you do, exactly?
19:51:43 <gfixler> when I said map, I presumed a key that held a list of NPCs, one for the player, one for items, etc
19:52:00 <gfixler> so yes, there would be structure, and lists of things
19:52:11 <c_wraith> dfeuer: It means just means the class isn't unnecessarily restrictive. It can be used for anything it makes sense for.
19:52:30 <gfixler> I suppose a map is kind of correct - worlds are big piles of things we give names to
19:53:49 <dfeuer> c_wraith, right, so ... an example?
19:54:33 <dfeuer> gfixler, you may want to look at HList stuff, although I can't claim to understand it.
19:54:46 <c_wraith> dfeuer: so you can have an instance for (->), where k = *.  Or an instance for...  I dunno.  I don't have anything else in mind.  I just know it doesn't need to be that restrictive. :)
19:54:51 <Zekka> I think it'd be more sensible to keep multiple collections
19:55:10 <dhrosa> hmm, I have a Maybe String, and I have a function String -> Slack User, where Slack is a monad transformer stack. I'm trying to get a Slack (Maybe User) out of this. my attempts have gotten me a Maybe (Slack User), which is not quite what I need
19:55:23 <Zekka> I think the world will be generally divisible into multiple groups of things, and you can just define a type which handles the special case where things are mutually interchangeable
19:55:29 <dhrosa> is there a way in general to swap monad layers, or can someone help me arrange my functions to get a Slack (Maybe User)?
19:55:35 <Zekka> dhrosa: There's no general way to do that
19:55:46 <dfeuer> c_wraith, does making such things less restrictive lead to worse error messages, or is there some other reason classes aren't automatically kind-polymorphic when possible?
19:55:49 <Zekka> But I think Maybe is Traversable
19:55:54 <Zekka> :t sequence
19:55:55 <lambdabot> Monad m => [m a] -> m [a]
19:55:58 <gfixler> Zekka: one nice thing with maps is that they let me change my mind without changing all my functions
19:55:58 <EvanR> or one big collection, but many different indices into the attributes and values, or from the attributes to the entities
19:56:00 <Zekka> :t T.sequence
19:56:01 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
19:56:08 <Zekka> > T.sequence (Just [1, 2, 3])
19:56:09 <lambdabot>  [Just 1,Just 2,Just 3]
19:56:19 <Zekka> > T.sequence ([Just 1, Just 2,  Just 3])
19:56:20 <lambdabot>  Just [1,2,3]
19:56:25 <Zekka> > T.sequence ([Just 1, Just 2, Nothing])
19:56:26 <lambdabot>  Nothing
19:56:34 <Zekka> dhrosa: Does that look close to what you want?
19:57:24 <dhrosa> hmm, I see, so as long as the outer-thing I have is a Traversable, which MAybe is this should work
19:57:27 <Zemyla> @quote
19:57:27 <lambdabot> jvoorhis says: @remember dmhouse <dmhouse> ?quote dmhouse
19:57:28 <dhrosa> let's try this
19:57:29 <EvanR> Map (E,A) V1, Map (E,A) V2, Map A E, Map E A
19:58:02 <EvanR> V1 might be String, V2 Int
19:58:16 <dedgrant> Hi, anyone know if there is a patch for http://code.haskell.org/tar/ for GCH 7.10.1?
19:58:19 <dedgrant> GHC rather
19:58:27 <gfixler> EvanR: I like the idea of various views
19:58:28 <dfeuer> carter, your mission is to find a way to improve the asymptotic bounds for immediate indexing with Data.Sequence.zipWith from polylogarithmic to logarithmic, or prove it impossible.
19:58:33 <c_wraith> dfeuer: nah, error messages should be mostly the same.  I think that it's just a case where it's not obvious how to infer polymorphic kinds fro a theoretical perspective.
19:58:40 <Zemyla> @quote oleg
19:58:40 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
19:58:41 <c_wraith> *from
19:59:42 <carter> dfeuer: that veers into phd thesis territory
19:59:52 <carter> shaving logs
20:00:16 <dfeuer> c_wraith, but isn't that what it does for Category? There aren't any kind annotations or anything.
20:00:30 <dfeuer> carter, shaving ... logs...
20:00:32 <dfeuer> OK.
20:01:08 <carter> dfeuer: some CS theory folks only analyze alg complexiity up to polylog factors
20:01:20 <dfeuer> Huh.
20:01:31 <carter> dfeuer: though I do agree that 2* log (n) IS better than log(n)^2
20:01:34 <dhrosa> Zekka: works perfectly, thanks! my first use of Traversable
20:01:46 <Zekka> dhrosa: You'll find it has another very good use!
20:02:09 <Zekka> Oftentimes you'll generate lists or other collections of monadic actions which you'll need to perform in order
20:02:22 <c_wraith> dfeuer: Oh, I suppose it does infer polykinds whenever the extension is enabled.  I guess it is inferrable
20:02:23 <Zekka> forM and mapM generalize to all Traversables for cases where it's hard to do that
20:02:24 <dfeuer> carter, yeah, but I don't know how, if at all, it can be done when zipping finger trees. That's why I need *your* help.
20:02:31 <dhrosa> yeah, I've used sequence and mapM before,but never on something that wasn't a list
20:03:07 <Zemyla> 'Basically any time you say 'X can't be done in Haskell', you can be 80% sure that within a week, Oleg will respond saying "Actually, you can do it, using these 17 different type classes, here's how: ..."'
20:03:43 <n4x> you're missing the 19 extensions
20:04:05 <dfeuer> Zemyla, I think it's kind of interesting that he started making a name for himself with Scheme macrology and continuation hacks before becoming a major Haskell guru, if I have the story right.
20:04:38 <Zekka> dfeuer: Kmett was a Perl guru before getting into Haskell, right?
20:04:53 <dfeuer> Perl? Yuck.
20:05:00 <Zemyla> I imagine if he had found C++, he would be writing template definitions that would make the faces of the Boost team melt off.
20:05:02 <carter> dfeuer: zipping finger trees
20:05:14 <carter> dfeuer: have you considered doing unsafe perform ios?
20:05:36 <dfeuer> carter, if I saw any way for that to help me?
20:05:37 <carter> or ST REfs/?
20:05:48 <carter> i'm suggesting it as the next "hammer" or "trick"
20:06:34 <dfeuer> carter, yes, those sound like nice tricks. I don't see how they relate to getting a better  zip xs ys `index` k
20:06:47 <carter> its tricky to do idk yet
20:07:24 <dfeuer> carter, make sure you're looking at the current zipping code and not some old shit that shipped with 7.8.
20:08:00 <dfeuer> (In case you've forgotten how it all works already)
20:08:01 <carter> track the head
20:08:03 <carter> gotcha
20:08:07 <carter> dfeuer: i'm on fam trip right now
20:08:11 <dfeuer> Ohhhhh.
20:09:10 <dfeuer> carter, fam = your parent(s)? child(ren)? partner(s)? sibling(s)?
20:09:22 <dfeuer> Zemyla++
20:10:04 <dfeuer> @remember Zemyla I imagine if [Edward Kmett] had found C++, he would be writing template definitions that would make the faces of the Boost team melt off.
20:10:04 <lambdabot> I will remember.
20:10:07 <carter> dfeuer: sibs and parents and stuff
20:10:24 <carter> dfeuer: Zemyla  ... i'm pretty sure edwardk know C++ pretty well
20:10:41 <dfeuer> carter, fun times! Enjoy yourself.
20:11:13 <EvanR> my program is running quite a bit slower if i print out lists ~125 Complex Doubles during a spin loop, than if i print out the lists length on each loop (goes into the tens of thousands)
20:11:25 <EvanR> not surprising i guess
20:11:32 <erisco> is it possible to write TH TLDs without an extra indentation?
20:11:56 <erisco> the parser seems angry if I try to leave it out
20:12:02 <Zemyla> :t \x -> x >>= (\y -> if y == 0 then Left "error" else return y)
20:12:03 <lambdabot> (Num b, Eq b) => Either [Char] b -> Either [Char] b
20:14:39 <dfeuer> carter, what is thomie's actual name? I forget.
20:14:54 <carter> dfeuer: idk
20:14:55 <carter> ask him
20:15:14 <zq> what the fuck
20:15:17 <dfeuer> thomie, what is your name?
20:15:27 <carter> ...
20:15:30 <dfeuer> zq, the goddamn fuck.
20:15:40 <zq> because i installed a new ghc, i gotta recompile vecror and friends all over again on my poor little laptop
20:15:53 <carter> zq: same ghc version
20:15:55 <carter> or new ghc version?
20:16:01 <zq> doesn't matter
20:16:04 <carter> nope
20:16:06 <carter> does :)
20:16:08 <zq> nope
20:16:12 <zq> doesn't ):
20:16:13 <carter> lol
20:16:14 <carter> bai
20:16:20 <zq> full paths are hardcoded
20:16:23 <zq> sandbox
20:16:24 <zq> useless
20:16:25 <carter> ahhh
20:16:26 <zq> thanks cabal
20:16:45 <zq> cabal needs to stop bitching about not being a package manager and actually be a package manager
20:16:55 <zq> fuck that
20:16:58 <zq> i'll just write one
20:17:03 <zq> who's with me
20:17:04 <carter> zq: patches welcome
20:17:18 <dhrosa> but if they claim they're not a package manager, then they can get as close to being a package manager without having the liability of actually promising to be one :p
20:17:36 <carter> zq: you should ask bernalex  why they're not the same
20:18:06 <nkar> zq: you may want to look at nix
20:18:26 <zq> dhrosa: that's my prob
20:18:42 <zq> dhrosa: s/my/the/
20:19:11 <zq> carter: why which aren't the same?
20:19:23 <zq> carter: i'm not sure what you mean by "they"
20:19:30 <carter> zq: talk with bernalex
20:19:35 <khyperia> oh, heya carter, somehow I got roped in here again. Trying to understand the whole Hask category thing right now.
20:19:52 <carter> khyperia: hehe, hows undergrad starting off/
20:19:55 <carter> ?
20:20:52 <khyperia> I passed my first semester, so that's good. No fun stuff, all "this is a set. This is the subset operator. It does things." and I'm like "yeah yeah I know, Monoids and all that jazz" "nope we're not learning about that sorry"
20:21:22 <zq> bernalex: he said i should talk with you. hi.
20:21:43 <carter> khyperia: that means you got an A
20:21:49 <carter> unless you were partying
20:21:50 <benzrf> khyperia: i am not looking forward to that :|
20:21:52 <carter> those are you choices
20:21:55 <khyperia> Heh, yep, carter.
20:21:59 <benzrf> khyperia: whats your major
20:22:00 <khyperia> The A bit, that is.
20:22:06 <khyperia> benzrf, computer science
20:22:08 <carter> khyperia: why not both? :)
20:22:20 <benzrf> hh
20:22:35 <khyperia> heh, carter
20:23:23 <khyperia> But I did snag an internship at the Big Evil Corporation this summer, so that's cool. No haskell there though :(
20:23:41 <dawik> google?
20:23:45 <khyperia> microsoft
20:23:57 <zq> microsoft is big?
20:24:03 * khyperia shrugs
20:33:04 <Zemyla> :t either show show
20:33:05 <lambdabot> (Show b, Show a) => Either a b -> String
20:35:50 <erisco> how can I eval type functions that have non-* kind?
20:36:33 <erisco> I can ask for the type of a value, or the kind of a type, and I can evaluate a value-level expression
20:36:49 <erisco> using :t, :kind, or normal input respectively
20:37:27 <erisco> for * kinds I can use  :t undefined :: expr
20:38:35 <idnar> how do I convert from a Char to a Word8?
20:38:44 <n4x> erisco: you mean something like Proxy?
20:38:52 <Zekka> idnar: Not all chars can be represented in one Word8
20:38:53 <erisco> n4x, I don't know, what is Proxy?
20:38:59 <n4x> > Proxy :: Proxy Maybe
20:39:01 <lambdabot>  Proxy
20:39:04 <Zekka> It also depends on encoding
20:39:05 <n4x> :t Proxy :: Proxy Maybe
20:39:06 <lambdabot> Proxy Maybe
20:39:48 <idnar> Zekka: okay right, my question was a bit broad; specifically, I have an 8-bit char constant, but I don't want to write it as an integer
20:40:01 <n4x> erisco: a datatype where its type parameter is anything
20:40:04 <Zekka> idnar: Can't you use single-quotes?
20:40:09 <n4x> :t Proxy Monad
20:40:10 <lambdabot> Not in scope: data constructor ‘Monad’
20:40:13 <idnar> Zekka: 'a' has type Char
20:40:14 <n4x> :t Proxy :: Proxy Monad
20:40:15 <lambdabot> Proxy Monad
20:40:24 <erisco> n4x, I am not sure how this will help
20:40:25 <Zekka> Oh, you mean an 8-bit Word8 constant?
20:40:39 <idnar> I guess I can write fromIntegral (ord 'a') :: Word8 or some such, but that's pretty awkward
20:41:01 <Zekka> I guess you can define an alias for that -- I don't know if there's a builtin naughty function for this though
20:41:42 <erisco> hm, so if I ask  :t Proxy :: Proxy expr  then it will evaluate the expression for me
20:41:46 <erisco> suppose that makes some sense
20:41:46 <n4x> erisco: I thought you were doing some kind of type level computation, and needed a "value" that could store the "higher-kinded" result
20:42:00 <erisco> I am doing that
20:42:18 <erisco> hm, I get down to  (Int :== Int) :|| FalseSym0  which isn't right
20:42:57 <idnar> Zekka: I suppose what I really want is an OverloadedChars extension (like OverloadedStrings), but that doesn't seem to exist
20:43:12 <erisco> must be something missing on the definition of :==
20:43:22 <Zemyla> :t either id show
20:43:23 <lambdabot> Show b => Either String b -> String
20:43:30 <Zemyla> :t either id read
20:43:30 <lambdabot> Read c => Either c String -> c
20:43:50 <Zemyla> :type cast
20:44:44 * hackagebot stm-conduit 2.5.3 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.5.3 (ClarkGaebel)
20:44:52 <nkar> idnar: there's c2w in Data.ByteString.Internal; not sure whether it suites your needs
20:45:19 <idnar> nkar: hmm, that would probably work, but I guess it's not worth importing from .Internal for something like this
20:51:53 <spearman> hi all, first time messing with template haskell. if i do something weird like [| 1 + $([| \x -> 1 |]) |] i get a function of type (Num (t -> a), Num a) => t -> a, but are there any types that satisfy the constraints? i tried calling it with an Int but got an error
20:52:31 <spearman> did i basically generate a function with a type error?
20:53:40 <dmj`> spearman: you're producing 1 + const 1
20:53:51 <dmj`> :t 1 + const 1
20:53:51 <lambdabot> (Num (b -> a), Num a) => b -> a
20:54:31 <dmj`> b's type is a function, so a concrete value will be a type error
20:58:29 <spearman> hmm, so how could (1 + const 1) be evaluated? or not?
21:02:57 <dmj`> :t \x -> (1 + const 1) x
21:02:58 <lambdabot> (Num (b -> a), Num a) => b -> a
21:06:12 <nickels> :t _
21:06:13 <lambdabot>     Found hole ‘_’ with type: t
21:06:13 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
21:06:13 <lambdabot>                the inferred type of it :: t at Top level
21:07:49 <tac_> :t _ _
21:07:50 <lambdabot>     Found hole ‘_’ with type: t0 -> t
21:07:50 <lambdabot>     Where: ‘t0’ is an ambiguous type variable
21:07:50 <lambdabot>            ‘t’ is a rigid type variable bound by
21:09:45 * hackagebot codecov-haskell 0.2.0 - Codecov.io support for Haskell.  http://hackage.haskell.org/package/codecov-haskell-0.2.0 (killy971)
21:09:58 <pavonia> Is only one hole reported or is that only in lambdabot?
21:10:17 <indiagreen> only in lambdabot
21:10:32 <indiagreen> GHCi 7.8.3 reports both holes
21:14:08 <Buttons840> I am using the SDL2 library and I need to do some C style binary "or'ing" of some flags -- what opperator does binary or in haskell?
21:15:01 <Buttons840> :t (.|.)
21:15:02 <lambdabot> Bits a => a -> a -> a
21:15:29 <tinix> what hole?
21:16:28 <matematikaadit> > 1 .|. 2
21:16:29 <lambdabot>  3
21:18:48 <Buttons840> yeah, I found it -- i guess it's called "bitwise or"; once I knew the magic words google found it for me
21:20:23 <pavonia> > True .|. True
21:20:24 <lambdabot>  True
21:20:52 <tinix> False .|. True
21:22:18 <Zemyla> :t Bits
21:22:19 <lambdabot> Not in scope: data constructor ‘Bits’
21:24:08 <pavonia> tinix: You need to put an "> " at the beginning to evaluate expressions in lambdabot
21:25:17 <tinix> > False .|. True
21:25:19 <lambdabot>  True
21:25:32 <tinix> ')
21:27:07 <tinix> > (\ f x y −> f x y) (+) 3 4
21:27:08 <lambdabot>  <hint>:1:10: parse error on input ‘−>’
21:27:10 <Welkin> > False .&. True
21:27:12 <lambdabot>  False
21:27:19 <tinix> :t (\ f x y −> f x y) (+) 3 4
21:27:20 <lambdabot> parse error on input ‘−>’
21:27:36 <Welkin> there is no space after the lambda
21:27:42 <tinix> :t (\f xy)
21:27:43 <lambdabot> parse error on input ‘)’
21:28:00 <tinix> > \f xy
21:28:01 <lambdabot>  <hint>:1:6:
21:28:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:28:06 <indiagreen> tinix: you used a dash instead of a hyphen
21:28:10 <Welkin> > \x -> (+1) x $ 4
21:28:11 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
21:28:12 <lambdabot>    arising from a use of ‘M444637388590451758823011.show_M4446373885904517588...
21:28:12 <lambdabot>  The type variable ‘t0’ is ambiguous
21:28:15 <indiagreen> “->”, not “−>”
21:28:17 <Welkin> > \x -> (+1) x $ 4 :: Int
21:28:18 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable s0)
21:28:18 <lambdabot>    arising from a use of ‘M528833424137164251623027.show_M5288334241371642516...
21:28:18 <lambdabot>  The type variable ‘s0’ is ambiguous
21:28:46 <Welkin> :t \x -> (+1) x
21:28:47 <lambdabot> Num a => a -> a
21:28:53 <indiagreen> my apologies, you used a minus, not a dash
21:28:56 <indiagreen> still wrong
21:29:03 <bananagram> according to http://hackage.haskell.org/package/JuicyPixels-3.2/docs/Codec-Picture.html#t:PixelRGB8 PixelRGB8 has a constructor PixelRGB8 !Pixel8 !Pixel8 !Pixel8
21:29:11 <bananagram> what do the bangs mean?
21:29:26 <indiagreen> bananagram: unboxed values
21:29:32 <Welkin> strict evaluation
21:29:41 <bananagram> ok
21:29:45 <MP2E> unboxed values is #, ! is strict evaluation to WHNF
21:29:46 <indiagreen> hm, wait, or strict evaluation
21:29:53 <indiagreen> right, messed them up
21:29:54 <indiagreen> sorry
21:30:36 <tinix> What is template haskell?
21:31:15 <tac_> It's a haskell program that generates code during compilation
21:31:19 <Welkin> it allows you to embed languages inside haskell
21:31:20 <tac_> It's a macro system for Haskell
21:31:27 <Welkin> like html, css, etc.
21:31:36 <dmj`> compile time code gen
21:31:52 <tac_> It is good for code which requires a lot of boilerplate, but which the type system isn't powerful enough to encode
21:32:02 <tinix> It generates code in another language?
21:32:08 <Hijiri> it generates haskell code
21:32:09 <tinix> from haskell code?
21:32:28 <tinix> <Hijiri> got it
21:33:07 <tinix> filter :: Ord k => (a -> Bool) -> Map k a -> Map k a
21:33:32 <tac_> It's a superset of Haskell
21:33:32 <Zemyla> Wait, how is ((->) r) even a type?
21:33:38 <tac_> That compiles to Haskell
21:33:41 <tinix> How do you parse through a list using TextParser
21:34:01 <dmj`> Zemyla: (->) is an infix type constructor
21:34:03 <Welkin> (->) is just a constructor, like (:)
21:34:27 <Zemyla> Ohh, and now I see how it's a functor.
21:35:00 <Zemyla> fmap :: (a -> b) -> (r -> a) -> (r -> b) is just (.).
21:36:27 <pavonia> ((->) r) is a type constructor
21:37:01 <Zemyla> So ((->) r) is forall a. r -> a.
21:37:01 <tac_> ((->) r) means "functions from r into _"
21:37:15 <tac_> ((->) r) Int means (r -> Int)
21:37:19 <tac_> for instance
21:37:27 <Zemyla> Is there a similar type that is forall a. a -> r?
21:37:40 <Zemyla> Can you get flip (->)?
21:37:40 <dmj`> :t const
21:37:41 <lambdabot> a -> b -> a
21:37:54 <Pamelloes> If I define a function in a where clause, can I give this function its own where clause?
21:37:58 <tac_> Zemyla: yes. But the flip of (->) isn't a functor
21:38:03 <tac_> It's a Contra (contravariant functor)
21:38:27 <pavonia> Pamelloes: Yes
21:38:39 <tac_> You give it an (a -> b) and it gives you back a (b -> r) -> (a -> r)
21:40:20 <tinix> <tac_> Could you elaborate? How is type a being mapped to type b?
21:40:31 <tinix> bc a. a -> r?
21:40:56 <tinix> meaning a -> r is an expression in type a?
21:41:56 <tac_> forall a. a -> r is a lie. It's a useless empty type.
21:42:02 <pavonia> a -> r is a type and its values map values of type a to values of type r
21:42:03 <tac_> But the flip of (->) a is interesting
21:42:47 <tac_> The functor (->) a is the so-called "Hom" functor in category theory
21:43:01 <tac_> and the flip of (->) a is the contravariant hom functor
21:44:58 <tinix> <tac> so how is that functor denoted?
21:45:38 <tac_> In Haskell?
21:45:44 <tac_> I'm not sure the 'standard' way
21:45:57 <Zekka> It's usually called Reader, isn't it?
21:46:12 <tac_> It might be
21:46:23 <tac_> @sec Reader
21:46:23 <lambdabot> Source not found. My mind is going. I can feel it.
21:46:25 <tac_> @src Reader
21:46:25 <lambdabot> Source not found.
21:46:27 <tac_> bah
21:46:37 <tinix> <tac> in Haskell
21:46:48 <Zekka> newtype Reader r a = Reader { runReader :: r -> a }
21:46:50 <Zemyla> :t (# 3, "Hello" #)
21:46:51 <lambdabot> Num a => (# a, [Char] #)
21:47:04 <Zemyla> :t (#,#)
21:47:05 <lambdabot> a -> b -> (# a, b #)
21:47:23 <tac_> Reader is the same as the covariant Hom, if I'm not mixing things up
21:47:26 <Zemyla> It looks like a face.
21:47:29 <Zekka> tac_: I think so
21:47:46 <Zekka> I don't know if the contravariant hom has a name
21:47:57 <matematikaadit> (#,#) a confused face
21:48:02 <tac_> Reader is a bit older than Contra in Haskell, I believe
21:48:32 <Zemyla> > (# 3, "Hello" #) = (3, "Hello")
21:48:33 <lambdabot>  <hint>:1:18: parse error on input ‘=’
21:48:39 <Zemyla> > (# 3, "Hello" #) == (3, "Hello")
21:48:41 <lambdabot>  Couldn't match expected type ‘(t0, [GHC.Types.Char])’
21:48:41 <lambdabot>              with actual type ‘(# a0, [GHC.Types.Char] #)’
21:48:58 <tinix> <Zekka> why would your do notation be type a -> r
21:49:10 <tinix> <Zekka> why wouldn't *
21:49:12 <Zekka> tinix: do-notation? What does this have to do with that?
21:49:51 <tinix> <Zekka> if you are running every element a through type r?
21:50:00 <Zekka> Just to be clear, it's a functor, applicative, and monad both with and without the newtype
21:50:04 <Zekka> tinix: "running through"?
21:50:17 <Zekka> r -> a doesn't "run" an a through an r -- it gives you a unique a for every r
21:50:27 <Zemyla> :t uncurry (#,#)
21:50:28 <lambdabot>     Kind incompatibility when matching types:
21:50:28 <lambdabot>       c :: *
21:50:28 <lambdabot>       (# a, b #) :: #
21:50:36 <Zemyla> :t uncurry
21:50:37 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:50:49 <Zekka> Zemyla: Fun!
21:51:04 <tac_> Cont is the contravariant hom applied twice
21:51:08 <tinix> <Zekka> let me make it very simple for you: r -> a vs a-> r ?
21:51:15 <Zemyla> > (# 3, "Hello" #)
21:51:16 <lambdabot>  Kind incompatibility when matching types:
21:51:16 <lambdabot>    a0 :: *
21:51:16 <lambdabot>    (# a1, [GHC.Types.Char] #) :: #
21:51:36 <Zekka> tinix: Using the argument order I provided earlier, the first one is Reader and the second one, if it has a name, I don't know it
21:51:40 <Zekka> tac_: Good catch!
21:51:41 <tinix> <Zekka>
21:51:53 <n4x> :t (# 1#, 3## #)
21:51:54 <lambdabot> (# GHC.Prim.Int#, GHC.Prim.Word# #)
21:51:55 <tinix> <Zekka> ok I get what you're saying
21:52:50 <tac_> The category theory crap makes you good at Haskell trivia after a few years
21:53:24 <Zemyla> So what can be done with a (# a, b #)?
21:53:55 <tac_> You can probably box it or project out the components
21:54:04 <Zekka> @let (# x, y #) = (# 1, 2 #)
21:54:04 <lambdabot>  .L.hs:170:8: parse error on input ‘)’
21:54:12 <tac_> There's not much you can do with a tuple of any kind except project
21:54:47 <Zekka> tac_: Looks like the `contravariant` package calls contravariant hom Op
21:55:44 <tac_> looks like it
21:57:03 <tac_> I'm guessing Op is less useful in Haskell than contravariant functors are in mathematics
21:57:25 <tac_> Since functions don't have decidable equatliy or a lot of tractible properties
21:57:42 <Zekka> I'm looking at some of the typeclasses defined in th contravariant package
21:58:12 <Zekka> currently parsing Decidable, I have a feeling it'll be murder getting an intuition
21:58:22 <Zekka> actually, I should be starting with Divisible
22:00:30 <ReinH> Op is the contravariant hom functor? Do you mean that Op b = Hom(-,b)?
22:00:35 <tac_> wtf is "Day convolution mapping"?
22:00:53 <Zekka> I don't know what most of the objects being referred to are talking about: I'm just looking a the types
22:01:08 <ReinH> tac_: http://ncatlab.org/nlab/show/Day+convolution
22:01:12 <Zekka> ReinH: I don't know if I mean that. Ask tac_!
22:04:07 <tac_> I'm not entirely sure a link to the nLab is ever an answer in the traditional sense of the word
22:04:20 <tac_> >__>
22:04:38 <ReinH> tac_: haha fair enough
22:04:42 <tac_> ;P
22:04:45 <ReinH> tac_: This paper uses day convolution iirc http://www.fceia.unr.edu.ar/~mauro/pubs/Notions_of_Computation_as_Monoids.pdf
22:05:12 <Zekka> tac_: We can talk about divisible just in terms of haskell types, I think
22:05:20 <Zekka> and maybe then the relationship to Applicative will be more obvious
22:05:36 <tac_> ah yes, when we run into trouble, we just throw another layer of monoids into things and the problem goes away
22:05:49 <tac_> or more accurately, the problem is replaced by an entry in nLab :P
22:05:57 <Zekka> Looks to me first of all like divide is a special kind of contramap
22:06:07 <Zekka> :t contramap
22:06:08 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
22:06:08 <ReinH> Zekka: divisible?
22:06:10 <Zekka> :t divide
22:06:11 <lambdabot> Not in scope: ‘divide’
22:06:20 <Zekka> ReinH: One of the typeclasses introduced by contravariant
22:06:25 <Zekka> should have capitalized it: Divisible
22:06:39 <Zekka> @import Data.Functor.Contravariant.Divisible
22:06:40 <lambdabot> Unknown command, try @list
22:06:44 <Zekka> hm
22:06:59 <Zekka> divide :: Contravariant f => (a -> (b, c)) -> f b -> f c -> f a
22:07:10 <ReinH> Zekka: where d  you find it?
22:07:14 <ReinH> s/d /do
22:07:17 <Zekka> ReinH: https://hackage.haskell.org/package/contravariant-1.2/docs/Data-Functor-Contravariant-Divisible.html
22:07:45 <ReinH> Oh. It's been removed.
22:08:02 <Zekka> What?
22:08:19 <Zekka> It's right there where I linked it, and as near as I can tell that's the most recent version of the library
22:09:22 <ReinH> Oh. I guess I got that backwards.
22:10:03 <Zekka> Let's see -- those types for Op r look like this
22:10:14 <Zekka> contramap :: (a -> b) -> (b -> r) -> (a -> r)
22:10:49 <Zekka> divide :: (a -> (b, c)) -> (b -> r) -> (c -> r) -> (a -> r)
22:10:52 <ReinH> which is flip (.) as you would expect
22:11:21 <Zekka> So divide probably splits the a, performs both actions, and monoidally joins the r
22:11:33 <Zekka> conque, for any a, gets an r
22:11:43 <Zekka> So those pretty neatly correspond to the monoid operations behind an arrow!
22:12:26 <ReinH> monoidally joins the results, yes
22:12:44 <bananagram> if I have a function that takes Data.ByteString.Internal.ByteString, how can I give it Data.ByteString.Lazy.ByteString?
22:13:01 <Zekka> I guess my read of Divisible is that it says the contextual part of f acts like a monoid -- if you have a joining operation for the value part, you can monoidally join the context
22:13:42 <Zekka> you can also monoidally grab some context out of thin air
22:14:24 <ReinH> bananagram: Data.ByteString.Lazy.fromStrict
22:15:01 <solatis> ok guys, i've got an interesting question again
22:15:04 <Zekka> That's kind of like how Applicative monoidally combines context in operations like (<*>) and (*>) and creates it out of thin air for pure
22:15:17 <solatis> i need to pad my lazy bytestring to 16 bytes
22:15:24 <solatis> what would be the best aproach to do so ?
22:15:26 <Zekka> But I don't think I have the precise mathwords to express the relationship (I guess that's what the "denser jargon" blurb provides)
22:15:53 <solatis> (this is for feeding data to an AES encryption function, which requires data to be padded)
22:16:15 <tac_> Typicall abstract nonsense. So in the case of the Predicate instance, if you have a predicate on A and a predicate on B, and a mapping C -> (A, B), then it gives you a predicate on C such that under the map, the predicate holds for both components
22:16:43 <Zekka> tac_: Predicate is just Op Bool, right?
22:17:02 <Zekka> using the All monoid for Bool?
22:17:04 <tac_> I feel like I might as well go read the paper on how to use cohomology for carrying in the addition algorithm
22:17:16 <tac_> Yeah, Predicate a = a -> Bool
22:17:23 <tac_> It's a decidable predicate
22:17:31 <bananagram> ReinH: more like, how can I convert a Data.ByteString.Lazy.Bytestring to a Data.ByteString.Internal.ByteString?
22:17:40 <LordBrain> solarus, are you trying to pad it without evaluating the thunk?
22:17:47 <bananagram> that seems to make a lazy one
22:17:51 <tac_> Not to be confused with contravariant's "Decidable" class
22:17:51 <ReinH> Oh, then toStrict
22:18:02 <LordBrain> solatis, i meant, sorry solarus
22:18:05 <Zekka> tac_: What does "decidable predicate" mean?
22:18:23 <solatis> LordBrain: yeah preferably, the bytestring can contain large files
22:18:29 <solatis> so i cannot just calculate the length
22:18:33 <Zekka> What would a not-decidable predicate be?
22:18:34 <tac_> It means you can case-match and find a proof or disproof
22:19:06 <tac_> A predicate in Idris, for instance, Nat -> Type, would not be inherently decidable
22:19:10 <bananagram> ReinH: thank you, that works
22:19:15 <solatis> http://hackage.haskell.org/package/crypto-api-0.13.2/docs/Crypto-Padding.html looks interesting
22:19:37 <solatis> but it works with strict bytestrings... :/
22:19:38 <Zekka> tac_: What, because you can't case-match over Nat? I don't think I understand what you mean
22:19:46 <tac_> Nat -> Bool is a function that takes a natural and tells you if the thing is true for it
22:19:52 <Zekka> actually, youcancase-match over Nat
22:20:06 <tac_> Nat -> Type is something that takes a natural and you can type-check if you already have a proof... but the computer doesn't a priori know how to construct one
22:20:20 <tac_> You can case-match over Nat... and Bool.... but not over Type
22:20:22 <tac_> (In Idris)
22:20:30 <tac_> (well, in most builds of Idris ;)
22:20:36 <Zekka> OK, I think I follow, but I'm not sure
22:20:54 <ReinH> solatis: er, strict bytestring are the usual kind?
22:20:57 <tac_> In Haskell, you can't really even express it properly
22:21:10 <solatis> ReinH: as opposed to lazy, i mean?
22:21:13 <Zekka> I've only worked with Idris once or twice, I don't know it at all
22:21:17 <tac_> In Idris, Type is kind of like *
22:21:18 <solatis> or what do you mean ?
22:21:30 <tac_> So Nat : Type and Bool : Type
22:22:01 <ReinH> solatis: I mean that Data.ByteString is strict, most APIs use strict bytestrings
22:22:03 <tac_> but Type cannot be pattern-matched against. (The same is true of functions in Haskell).
22:22:23 <tac_> So if f : Nat -> Bool, you can do "case f 100 of True -> ...; False -> ..."
22:22:26 <solatis> ReinH: i know, but, for example, HsOpenSSL provides LBS functions, which is convenient
22:22:32 <Zekka> OK, so an example of a decidable predicate in Haskell would be an Int -> Bool, but not an Int -> (Int -> Bool)?
22:22:39 <solatis> however, you still have to manually pad data, which is important with AES
22:22:41 <Zekka> Because I don't think I would even call the second one a predicate
22:22:48 <tac_> but if P : Nat -> Type, you can't do anything with P 100 except pass it as an opaque object. You can't inspect it.
22:23:04 <tac_> yeah, sorta.
22:23:12 <ReinH> solatis: I would recommend http://hackage.haskell.org/package/cipher-aes but it also uses strict bytestrings
22:23:41 <solatis> i don't want to use cipher-aes since it is a complete reimplementation of AES
22:23:47 <tac_> Some people when they learn logic learn that true values are boolean-valued. But in Idris, they are actually Type-valued, not Bool-valued
22:24:17 <ReinH> solatis: ah
22:24:17 <tac_> Bool is a discrete type. It has exactly two points. You can look at them and see which point you're holding in your hand.
22:24:18 <Zekka> tac_: I don't follow. What are false values?
22:24:27 <Zemyla> Is it a requirement that, if something is both a monad and a comonad, that join . duplicate = id?
22:24:36 <ReinH> solatis: fair enough, but it's the one whose quality I can vouch for ;)
22:24:48 * hackagebot json-autotype 0.2.5.3 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.3 (MichalGajda)
22:24:50 <tac_> On the other hand, Int -> Bool is not discrete, since you can inspect as much of a function Int->Bool as you want and still not know exactly which you have
22:24:52 <Zekka> Is this an extension of "a successful typecheck is a proof of truth!"? Because it sounds like one, but it's an implication that I don't understand the base concept well enough to have an intuition for
22:25:06 <tac_> False values are just functions into Void
22:25:09 <tac_> err
22:25:19 <tac_> disproofs, I guess you would say. Not P really means P -> Void
22:25:57 <ReinH> tac_: P -> Void or Void -> P ?
22:26:07 <tac_> P -> Void
22:26:10 <tac_> means "not P"
22:26:14 <Zekka> So a predicate for ints in this encoding has the type Int -> Type, and if I have an arbitrary Int how do I use this to check truth or falsity?
22:26:51 <tac_> Write a type signature, give it a name, and write the program/proof
22:28:04 <tac_> So say you have Even : Nat -> Type; Even n = (k : Nat ** 2 * k = n)
22:28:13 <tac_> The predicate on Nat telling you when a number is even
22:28:34 <tac_> (A number n is even if there is a number k which, when you double it, gives you n)
22:28:35 <Zekka> tac_: OK, I'm following
22:28:53 <tac_> Then you can prove 4 is even
22:28:53 <Zekka> (not good at the notation but I think I understand it here)
22:29:05 <tac_> p : Even 4; p = (2, refl)
22:29:16 <tac_> 2 is your k, and refl proves that 2 * 2 = 4
22:29:41 <Zekka> OK, what happens if I feed it 3?
22:29:42 <tac_> But, a priori, you haven't said how you can take an *arbitrary* natural and *decide* if it's even or odd
22:30:20 <tac_> The problem is feeding it doesn't do much. It's like asking what happens if you buy the tools to build a shed. You have to build the shed yourself!
22:30:28 <tac_> All you know is that Even 3 : Type
22:30:43 <tac_> You know that Even 3 is a type. You don't know if it's provable or not
22:30:54 <Zekka> So, being clear, could I have introspected on Even 4?
22:31:01 <tac_> Nope
22:31:11 <tac_> You know that Even 4 : Type. But you can't pattern-match on Type
22:31:53 <Zekka> OK. That doesn't tell me how I do anything useful with it but to some extent it tells me that this is a predicate for a meaningful sense of predicate but also can't be inspected
22:32:04 <Zekka> which was your point, so thanks for humoring the digression!
22:32:12 <tac_> All you have done when you define Even is you've shown what is sufficient to prove Even n
22:32:36 <tac_> The next step is usually to write code to automatically construct proofs for you
22:32:39 <Zekka> So you could theoretically run potential proofs by it and it would throw up if those proofs were insufficient?
22:33:00 <tac_> Even is entirely decidable, of course. But you have to write a Deciable instance. (Idris's decidable is different than this one from Contravariant)
22:33:36 <Zekka> So it generates a type which is more of a rule to check "does some particular proof satisfy this definition?" than "is it true?"
22:33:45 <tac_> yeah
22:34:01 <tac_> It's funny
22:34:04 <Zekka> OK! That sounds pretty cool I guess
22:34:23 <tac_> Some types you don't care about "running" in the first place. You just care you can construct objects of that type at all.
22:34:51 <tac_> The fact you can construct an object of type Even 4 but not of Even 3 is a limiting factor in the language. It limits what kinds of bad programs you can write
22:35:46 <Zekka> How suitable is Idris for serious use, by the way?
22:35:58 <Zekka> Is anyone other than mathematicians using it for anything?
22:35:58 <tac_> It's good for serious fun at the moment
22:36:09 <Zekka> (uh, ignoring that if you use Idris you are probably a mathematician by proxy)
22:36:17 <tac_> It's not really mathematicians using it. Programmers who like fancy types
22:36:48 <tac_> The language's main crowd is no worse than the usual haskellers
22:36:51 <Zekka> Are we using the same sense of "mathematicians"? Everyone I know says Haskell programmers are all mathematicians whether they really study math or not, because type systems are scary
22:36:56 <tac_> Maybe better, because they know there's a stigma ;)
22:37:43 <tac_> I don't think the Idris people care about category theory at all, for the most part
22:38:19 <tac_> Mr. Brady at least seems fairly ambivalent about it.
22:38:44 <Zekka> Most of the reason I ask about whether it's suitable for use is because I've been looking for a new systems language to play around with
22:39:28 <Zemyla> Hmm, if a monoid is commutative, then is its associated comonoid mmutative?
22:39:44 <tac_> lol, Zemyla, yes, yes it is
22:40:28 <Zekka> I'm a little tired of Rust for the moment and spend too much time working in Haskell anyway
22:40:47 * solatis is tired of Rust propaganda at the moment
22:40:55 <tac_> I would take Idris to be a language where you can do fancy type stuff and actually run your code (to contrast with Coq, Agda)
22:41:56 <tac_> Also, it's a language where you can avoid monad transformers
22:42:00 <tac_> (thank god)
22:42:03 <Zekka> tac_: That's one of the first things I noticed!
22:42:52 <tac_> I think there's also a bit of work on different ways of doing 'protocol-y' stuff
22:42:56 <Zekka> Monad transformers are pretty hacky even though they're a nice alternative to every other language's "do nothing at all" take
22:43:10 <tac_> You write your program and then guarantee you didn't read from closed files or network connections
22:43:25 <Zekka> I hear someone wrote a pretty neat vaguely Idris-like extensible effects implementation for Haskell, bt no one's using it: let me find it
22:43:44 <Zekka> https://hackage.haskell.org/package/extensible-effects <- here it is. The authors will not surprise you
22:43:45 <MP2E> that's because of the impact on runtime performance
22:44:10 <numberten> is it possible to make a template haskell function that returns Q Exp take a function, and then call it from another file with $() ?
22:44:13 <tac_> I'm not 100% satisfied with the ad-hoc feel of the effects library, but it's good that people can experiment with different systems in Idris
22:44:25 <Pamelloes> Anyone know a good way to process a ByteString on a bit-by-bit basis?
22:44:27 <MP2E> http://www.reddit.com/r/haskell/comments/2novmn/til_about_extensibleeffects_an_alternate_universe/cmfqene
22:44:47 <tac_> A lot of the Idris development at the moment goes into the runtime
22:44:56 <numberten> like: foo n = runQ [| repeat n |]
22:45:01 <tac_> It's not yet sure how to compile dependent types efficiently
22:45:04 <numberten> and then in another file call $(foo 10)
22:45:14 <Zekka> I heard it generally compiled to pretty sane native code: did I hear wrong?
22:45:18 <tac_> In Haskell, you simply erase all the typing information, but with dependent types, sometimes type information is data and sometimes data is type information
22:46:56 <n4x> the thing in research now is dependant types, so, in like 40 years, we'll see a mainstream language with dependant types!
22:48:14 <tac_> Re: this post on the extensible effects
22:48:54 <tac_> This may be the pragmatist in me speaking but, IMO, if you are using Cont, you probably wrote an unmaintainable program.
22:49:20 <Zekka> Why so?
22:49:34 <tac_> Continuation monads are useful for certain kinds of algorithms, but I feel like they are not well-suited for 'general use' in programming
22:49:53 <tac_> Most of what I need transformers for, anyway, is nested stateful effects
22:49:54 <Zekka> I don't really have an example right offhand but I feel like you can probably implement useful structure in terms of them
22:50:07 <tac_> I don't know the proper term, but the effects are in some sense "linear"
22:50:14 <tac_> you do them and you shouldn't need to undo them, generally speaking
22:50:47 <tac_> If you need time traveling computations, then Cont is great, but those effect should be completely isolated from the rest of your program
22:51:29 <Zekka> Who's talking about time-travel? Am I not understanding the notion of what Cont does?
22:52:04 <neuroserpens> HAHAHAHAHAHAHAHAHAHA
22:52:06 <tac_> Using Cont in a program is a minor act of time travel
22:52:15 * neuroserpens shoots haskell one liners everywhere while laughing histerically
22:52:30 <Zekka> tac_: A pretty minor one, isn't it?
22:52:39 <tac_> Cont by itself isn't so bad. It's almost useless. You can escape your current context to throw a value to the caller.
22:52:42 <tac_> But ContT is weird
22:52:46 <Zekka> Can't you get relatively comprehensible stuff out of it like coroutines?
22:52:56 <tac_> ContT with a stateful monad inside, you can store the continuation and jump to it repeatedly
22:53:05 <tac_> yeah
22:53:05 <Zekka> Yeah, my gut about ContT is bad news
22:54:31 <tac_> This is my own unpopular bias
22:54:42 <tac_> But I feel monads are too general for most use cases
22:55:13 <Zekka> Well, what are some examples of usecases where you feel monads are inappropriate but still used?
22:55:14 <MP2E> generally you can get by fine with just an Applicative, or do you mean something else?
22:55:31 <tac_> Applicative is much better behaved
22:55:31 <Zekka> My first response would have been MP2E's, but I'm not sure exactly what you mean
22:55:47 <MP2E> Ah, I agree
22:55:51 <tac_> Mostly ContT and ListT are weird
22:56:01 <Zekka> tac_: Isn't ListT unlawful?
22:56:04 <tac_> and even the standard Control.Monad combinators are nonsense
22:56:11 <tac_> ListT can be made lawfully I think
22:56:14 <Zekka> IIRC Gabriel Gonzales' pipes includes a more lawful version
22:57:11 <Zekka> My general position is that you should use Monad only if you really have to, and I'm not sure how this differs from your position
22:57:18 <Zekka> ad I think it's ap retty common position
22:57:46 <Zekka> When possible/sane I usually write the most general type possible, and that applies for code that could be written with monad combinators but also with applicative ones
22:57:51 <tac_> The more you think about it, the more you want to just reach for Python when you have a problem ;)
22:58:23 <Zekka> I think monads + monad transformers require a lot of cconfiguration and thought that makes them pretty unpleasant for small apps!
22:58:56 <Zekka> I'm hoping Idris-style effects turn out more pleasant (they have a pretty API)
22:59:32 <tac_> The annoying truth about software is that you have to use the appropriate level of precision in everything you do
22:59:43 <Zemyla> Why is fst only defined for (a, b)?
22:59:55 <tac_> If you play loosey-goosey with types, you get Perl or Ruby :X
23:00:07 <Zekka> Zemyla: Making it polymorphic requires a lot of trouble!
23:00:11 <tac_> If you are too strict, you don't leave enough room to make changes
23:01:14 <tac_> Zemyla: because fst can only have one type
23:01:28 <tac_> It can't be both (a, b) -> a and (a, b, c) -> a
23:01:32 <Zekka> I guess my personal demands are a) code should be able to require arbitrary effects b) code should be polymorphic over all the effects it doesn't need c) code should compose with other code whose effects requirements aren't contradictory to its own d) a pony
23:02:15 <Zekka> I don't really care about this "precision" problem as much as I care about whether you can guarantee those things and demonstrate you guarantee them
23:02:28 <Zekka> (last thing is important! It probably requires a type system to do)
23:03:54 <tac_> But anyway, yeah, hang out in #idris
23:03:58 <tac_> (not that I talk there much)
23:04:00 <tac_> but it's cool
23:04:02 <tac_> I gotta run
23:04:06 <Zekka> See you
23:04:13 <tac_> later
23:04:50 * hackagebot ConcurrentUtils 0.2.0.0 - Concurrent utilities  http://hackage.haskell.org/package/ConcurrentUtils-0.2.0.0 (JamesCandy)
23:05:55 <Pamelloes> Can I write a base 2 literal in Haskell?
23:08:14 <HeladoDeBrownie> not straightforwardly
23:08:49 <LordBrain> you can write hex literal easily
23:08:52 <int-e> right, only decimal, octal and hexadecimal are supported directly https://www.haskell.org/onlinereport/lexemes.html#sect2.5
23:09:15 <LordBrain> are we under attack?
23:09:35 <HeladoDeBrownie> what, is there a netsplit?
23:09:41 * HeladoDeBrownie recently started ignoring join/part/quit
23:09:43 <LordBrain> its an attack
23:10:07 <LordBrain> i've never seen that here, but i've seen it in other irc forums
23:10:18 <HeladoDeBrownie> can you describe what's happening?
23:10:33 <MP2E> many random accounts are joining and parting very quickly
23:10:35 <godel> I have an option enabled in weechat that doesnt show join/part/quit, I recommend it
23:10:37 <HeladoDeBrownie> ah
23:10:38 <LordBrain> yes, somebody is purposely flooding
23:10:42 <godel> But it must be a netsplit
23:10:51 <HeladoDeBrownie> so this channel in particular is being attacked
23:10:54 <int-e> godel: no, it's always the same nicks
23:10:58 <hamid> hmm :/
23:11:07 <HeladoDeBrownie> is that right?
23:11:10 <Zekka> !ops
23:11:12 <Pamelloes> Seems like it
23:11:12 <godel> int-e: and why are them doing it?
23:11:13 <HeladoDeBrownie> @where ops
23:11:13 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
23:11:20 <LordBrain> HeladoDeBrownie, Yes. I believe this to be the case.
23:11:21 <int-e> for irssi, /ignore #haskell JOINS PARTS  helps (you may add QUITS)
23:11:29 <MP2E> thank you int-e
23:11:43 <MP2E> ah much better
23:12:01 --- mode: ChanServ set +o Cale
23:12:15 --- mode: Cale set +b *!~knrdo@111.78.209.215
23:12:21 <HeladoDeBrownie> \o/
23:12:23 <Zekka> Thanks, Cale
23:12:25 <marienz> if any ops around, may I suggest a brief +r or +j (with sensible values)?
23:12:36 <bueqcov> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:36 <mqdmq> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:36 <tojhh> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:36 <mwxudzf> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:36 <adaaqz> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:36 <qfycj> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:36 <bpxwr> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:36 <cympgmp> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:36 <cympgmp> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <cympgmp> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <stgjb> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <vqsjvg> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <witscl> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <witscl> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <witscl> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <vqsjvg> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <vqsjvg> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <bhxvt> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <bhxvt> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <bhxvt> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <kjmdih> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <kjmdih> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <kjmdih> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:37 <marienz> banning individual IPs is unlikely to help much
23:12:38 <bbtthvv> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <bbtthvv> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <bbtthvv> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <bbtthvv> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <zqmmuoq> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <tsfjmi> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <tsfjmi> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <tsfjmi> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <iowyi> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <iowyi> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <iowyi> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <yjibdjc> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <yjibdjc> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <yjibdjc> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <bqochfh> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <bqochfh> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <bqochfh> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:38 <iuswx> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <iuswx> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <iuswx> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <bdrumyh> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <bdrumyh> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <bdrumyh> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <iowyi> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <iowyi> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <cbfpko> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <cbfpko> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <cbfpko> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <irdza> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <irdza> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <irdza> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <exuqr> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <exuqr> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <exuqr> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <biucnv> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <biucnv> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <biucnv> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <mkbmn> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <mkbmn> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:39 <mkbmn> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <kgreiz> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <kgreiz> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <bbgmhk> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <bbgmhk> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <bbgmhk> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <loufcg> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <loufcg> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <loufcg> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <tfjhkp> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <tfjhkp> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <tfjhkp> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <ztqkw> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <ztqkw> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:41 <ztqkw> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:42 <MP2E> oh great
23:12:43 <HeladoDeBrownie> gah.
23:12:45 <nvsdk> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:46 <nvsdk> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:46 <nvsdk> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:47 <smyqqi> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:47 <smyqqi> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:47 <smyqqi> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:48 <kqoyw> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:48 <kqoyw> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:48 <kqoyw> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:48 <kqoyw> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:48 <kqoyw> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:51 <icxob> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:51 <icxob> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:51 <icxob> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:12:58 <Cale> they're getting k-lined
23:13:06 <becbjmk> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:13:06 <becbjmk> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:13:06 <becbjmk> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:13:07 <fxarep> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:13:07 <fxarep> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:13:07 <fxarep> cale Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gR0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0n-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ`'.`.''Jh0N-T`(!)`gRouP'.`.'eAsTeRn`(!)`ruLeZ`'.`.''Jh0N-T`(!)`Gr0uP`'.`.''EaStErN`(!)`RuLeZ
23:13:11 <godel> what is this?
23:13:12 <haasn> At least the response was pleasantly quick. Imagine if they all kept going.
23:13:17 <LordBrain> they have a dynamic ip tho
23:13:26 <LordBrain> is it possible to kline that?
23:13:45 <LordBrain> set the channel to registered only
23:13:45 <marienz> LordBrain: certainly
23:13:59 <aynrk> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <aynrk> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <djdkbiu> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <djdkbiu> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <djdkbiu> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <djdkbiu> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <aynrk> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <zzjcon> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <aynrk> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <zzjcon> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <yimgpv> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <yimgpv> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <qvfnnu> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:00 <qvfnnu> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <phzkw> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <phzkw> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <phzkw> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <phzkw> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <phzkw> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <xlzgeba> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <xlzgeba> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <plegcgg> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <plegcgg> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <plegcgg> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <plegcgg> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:01 <plegcgg> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:02 <fnqqzk> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:02 <ydfhds> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:02 <fnqqzk> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:02 <ydfhds> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:03 <Hijiri> wah
23:14:05 <fxozkn> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:05 <fxozkn> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:11 <qjqeqe> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:11 <qjqeqe> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:11 <qjqeqe> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:11 <qjqeqe> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:11 <qjqeqe> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:12 <dbxadrl> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:12 <dbxadrl> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:12 <dbxadrl> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:12 <dbxadrl> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:13 <dbxadrl> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:13 <xqaobq> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:13 <xqaobq> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:13 <xqaobq> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:14 <Cale> Eventually they ought to run out of hosts
23:14:25 <quantum-mechanic> wtf is happening
23:14:27 <hamid> :/
23:14:28 <HeladoDeBrownie> Cale, do you think +r in the meantime might help?
23:14:33 <Cale> What is +r?
23:14:35 <hamid> it's done?
23:14:37 <HeladoDeBrownie> registered only
23:14:39 <ndwybgg> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:39 <ndwybgg> cale ..`> SoReTes(`)VoS(`)Lee SoReTe(`)SuCio De MiErDa(`)ViviS para Arne(`)y Te oLViDaSTe De ToMaR(`)La SoDa KauSTiKa(`)MiErDas(`)LeE DeSDe La FoSa(`)Lee SoReTe(`)MiErDas(`)VoS La FoSa(`)ArNe HiJo De eL TRaVa(`)MoRiRaS(`)PoR CoJeRTe Al TRaVa(`)Al PeRRo Cam Y(`)ArNe(`)En La FoSa(`)PuTReFaCTa(`)De La CoNCH
23:14:44 <hamid> nope :/
23:14:53 <marienz> Cale: agreed (speaking as freenode staff). If you're willing to ride this out for a few minutes, that'd be appreciated. If you choose to redirect unregistered users elsewhere, please ping me so I can stick idoru in there.
23:14:53 --- mode: Cale set +r
23:14:57 <godel> It's all spanish
23:14:57 <hamid> kill this one too :/
23:15:00 <LordBrain>  /mode +r #haskell
23:15:03 <LordBrain> yes
23:15:05 <LordBrain> thanks
23:16:04 <Zemyla> Anyways, I think I figured out how to have fst work on nearly-arbitrary tuples.
23:16:26 <godel> Zemyla: how is that?
23:17:03 <Zemyla> You use TypeFamilies, and have fst be an operation on the Fstable typeclass.
23:17:37 <godel> but you have to do "instance Fstable ..." for every tuple
23:17:42 <Zemyla> Give Fstable a type family Fsttype, and fst is a -> Fsttype a.
23:17:47 <HeladoDeBrownie> Zemyla, the lens package includes something even more generic than that for that matter. look at _1, _2, etc if interested
23:18:14 <Cale> lol, now I'm getting NOTICE spam
23:18:17 <Zemyla> godel: You do it in Prelude, just like you define Show, Read, Eq, etc. for every type.
23:18:53 <Cale> I assume that idoru will pick up on that as well?
23:19:10 <Zemyla> As a pointless but hilarious bonus, you can even have [a] be Fstable, Sndable, and so on.
23:19:13 <Cale> (at least, I'm getting a limited amount of it from each of the machines)
23:19:32 <godel> Zemyla: but you have to define an instance for every tuple
23:19:38 <godel> so it is the same problem...
23:19:43 <marienz> Cale: if you /msg me a bunch of hostmasks I can probably check and kline them
23:19:46 <ddellacosta> folks, here is what I would like to do: generate a tone based on a sine wave, using the most fundamental method--that is, I don't want to use osc messages to SuperCollider (for example) but want to go as low-level as Haskell will allow me to.  Does anyone have a suggestion on where to start with that?
23:19:48 <godel> I don't see how does that solve anyting
23:20:05 <Cale> They seem to be gone already
23:20:41 <Zemyla> godel: You only have to do it for up to, say. 15-tuples.
23:20:57 <godel> marienz: what is kline?
23:21:25 <Pamelloes> What causes a parse error on "=" inside do?
23:21:44 <Zemyla> Show is only defined for 15-tuples, and it's not difficult to define for larger ones if needed.
23:21:47 <godel> Pamelloes: let
23:21:59 <godel> Pamelloes: "let a = something"
23:22:15 <HeladoDeBrownie> Pamelloes, usually best to show the erroneous code, if applicable
23:22:18 <Pamelloes> godel: I have a let statement yet it's still erroring.
23:22:38 <godel> Pamelloes: paste it in some web of your choice and share the link
23:23:00 <Pamelloes> http://lpaste.net/117369
23:23:17 <Pamelloes> Error is on the fourth line.
23:23:39 <Zemyla> And you can also even define fst, snd, etc. for your own types, if needed.
23:23:47 <HeladoDeBrownie> Pamelloes, your lambda should have -> not =
23:23:58 <marienz> godel: network ban
23:24:11 <Pamelloes> Ooooh! I was looking at the wrong =. Thanks HeladoDeBrownie :)
23:24:20 <marienz> Cale: a bunch of them chose to spam me instead, so I booted them off the network. Let me know if you still get spam, please.
23:24:33 <int-e> Pamelloes: note that the error message also gives the column, that's often helpful
23:24:34 <HeladoDeBrownie> Pamelloes, the error you got probably told you what character number, if you configure your editor to tell you what character you're at on a line it becomes nice and easy :)
23:25:03 <godel> marienz: are you some freenode authority? cool
23:25:13 <marienz> godel: network staff
23:25:29 <Pamelloes> Can you put a where clause on a lamda?
23:25:32 <HeladoDeBrownie> Pamelloes, no
23:25:39 <LordBrain> marienz, they are spamming me
23:25:39 <Pamelloes> Damn. Alright.
23:25:50 <HeladoDeBrownie> Pamelloes, you can do let outside or inside the lambda though
23:25:51 <LordBrain> i had to ignore basically all private messages
23:25:55 <marienz> LordBrain: PM me their hostmasks and I'll see what I can do about it
23:26:04 <Zemyla> Hell, what is even the limit on commas?
23:26:19 <Zemyla> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
23:26:19 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34)
23:26:48 <HeladoDeBrownie> Zemyla, https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1210006.1.4
23:26:51 <LordBrain> it could be a whole bot network for all i know marienz , the masks are not consistent, they keep changing.
23:26:59 <HeladoDeBrownie> Zemyla, potentially arbitrary, but at least 15 must be supported
23:27:00 <Pamelloes> HeladoDeBrownie: The lamda is for foldr, so let probably won't be that useful. I'll just make a separate function.
23:27:10 <int-e> Zemyla: "A 81-tuple is too large for GHC (max size is 62)" ...
23:27:24 <HeladoDeBrownie> Pamelloes, that works too. it can even be in a where of whatever declaration includes the lambda, if applicable
23:27:25 <marienz> LordBrain: you'll probably find they're using far more nicks than they're using IPs
23:27:30 <SharpGAF> Why 62?
23:27:35 <LordBrain> well that is true...
23:27:55 <HeladoDeBrownie> SharpGAF, the Report specifies implementations may put arbitrary limits as long as they're 15 or over
23:28:02 <SharpGAF> Ah, okay.
23:28:10 <Zemyla> :type uncurry
23:28:19 <Zemyla> :t uncurry
23:28:20 <lambdabot> (a -> b -> c) -> (a, b) -> c
23:28:56 <Zemyla> :t curry
23:28:57 <HeladoDeBrownie> in other words if you're writing haskell code with 16+-tuples, in addition to being hard to manage/read, it's also not portable :)
23:28:57 <lambdabot> ((a, b) -> c) -> a -> b -> c
23:29:09 <SharpGAF> I hope I never am :)
23:29:12 <int-e> SharpGAF: seems arbitrary though it's close to 64, which is a nice round number.
23:29:14 <HeladoDeBrownie> and frankly you should probably be defining separate data types by the time you reach 15-tuples
23:29:27 <SharpGAF> Just was curious about whether there was some implementation restriction.
23:29:47 <CindyLinz> Pamelloes: You can do it (cheat it) with LambdaCase extension like this: \case a -> go where go = ....
23:30:03 <HeladoDeBrownie> then again we write non-portable haskell code all the time, what with the language extensions we make liberal use of
23:30:11 <CindyLinz> With only 1 additional keyword 'case'
23:30:23 <Zemyla> Yeah, probably. But yeah, there should be also curry and uncurry extensions for the various types.
23:38:19 <Cale> haha, I think they decided to ddos me instead of just annoy me on IRC
23:38:21 <Cale> My connection went down for a bit
23:39:52 * hackagebot crypto-numbers 0.2.4 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.2.4 (VincentHanquez)
23:40:21 <LordBrain> well i think they tried to ddos me too, but for whatever reason they weren't successful
23:40:38 <Pamelloes> Can I not put a type restriction on a type declaration?
23:40:44 <LordBrain> or maybe they just wanted to flood annoy me
23:41:59 <LordBrain> Pamelloes, a type declaration can certainly restrict what would otherwise be inferred to be a more polymorphic type, if that is what you mean
23:42:23 <HeladoDeBrownie> Pamelloes, can you clarify? do you mean like a data declaration? how do you want to restrict it?
23:42:50 <Pamelloes> I want to make a statement "type (Show a) => MyType a = (...)", though my syntax is clearly wrong.
23:43:03 <HeladoDeBrownie> oh, okay
23:43:24 <HeladoDeBrownie> i don't think type lets you do that but i could be mistaken. if it does it'd be more like type MyType a = (Show a) => ...
23:43:27 <LordBrain> oh in a synonym
23:44:08 <HeladoDeBrownie> Pamelloes, keep in mind, that just declares a type synonym, basically. so whenever MyType Whatever is encountered it gets expanded to the right-hand side
23:44:42 <HeladoDeBrownie> sorry if you knew that already, i just thought it might help to clarify judging on what you wrote
23:45:04 <Pamelloes> Hm. I knew that but I never really took it that literally.
23:45:32 <Pamelloes> I guess it makes no sense if it is a literal substitution. I guess I'll just put the restriction elsewhere.
23:45:46 <HeladoDeBrownie> sounds reasonable
23:49:42 <Pamelloes> How can I print a type that has an ambiguous parameter?
23:50:07 <Pamelloes> I tried putting a restriction on the parameter but then it won't compile.
23:51:11 <HeladoDeBrownie> are you trying to derive a Show instance?
23:52:29 <LordBrain> Pamelloes, could you paste some code maybe?
23:53:12 <Pamelloes> hmmm. The code involved is kinda large. Let me try to find a snippet that can work.
23:56:43 <LordBrain> Pamelloes, if you use data instead of type, you could just put deriving Show at the end of the line... and then you'll have instances for all the a that are in show
23:56:45 <lpaste> Zemyla pasted “Type families: * -> *” at http://lpaste.net/117370
23:57:20 <Pamelloes> I've already put deriving Show at the end of my data definition.
23:57:31 <Pamelloes> I think the issue stems from a misuse of the Free Monad.
23:58:36 <Zemyla> The type Curryable line on the instance gives an error: Number of parameters must match family declaration; expected 1.
