00:01:58 <makalu> can emacs support multi-way-if? I get a parse error
00:06:49 <merijn> makalu: Most likely whichever syntax checker you use wasn't enabled to parse MultiwayIf
00:08:55 <makalu> I use haskell-mode and I now found this https://github.com/haskell/haskell-mode/issues/247
00:09:08 <makalu> I don't know if there's any other Haskell mode?
00:10:07 <makalu> wow there's so much code in haskell-mode
00:11:27 * hackagebot base-compat 0.5.0 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.5.0 (SimonHengel)
00:15:32 <jle`> i wonder what's with all the lens hype as of late
00:16:20 <bitemyapp> jle`: some people are excited, some people are threatened and angry.
00:17:05 <Total_1mmersion> Is there a function (a -> Bool) -> [a] -> (Maybe a, [a]) which finds an element in a list and returns Maybe an element which matches, and the list without that element?
00:18:41 <edwardk> jle`: it ebbs and flows. bos releasing a library using it when he'd previously been a bit of a lens holdout was another watershed moment, like when SPJ came out and gave a talk on them.
00:19:00 <edwardk> now all i have to do is somehow win over tibbe ;)
00:20:20 <bitemyapp> edwardk: could be snuck in via the back door by adding a backend to EKG :)
00:21:24 <jle`> oh yeah it was the web library
00:21:32 <jle`> i remember now, that makes sense
00:21:37 <jle`> everything clicks.
00:22:21 <bitemyapp> jle`: everything clicks for you now? what about lens :P
00:23:10 <jle`> that's a diifferent story :)
00:25:22 <shachaf> Total_1mmersion: No, but you can probably write it using span if you really need it.
00:25:36 <shachaf> Of course, maybe lists are the wrong data structure if you're doing a lot of that. Who knows.
00:27:54 <jle`> mapAccum might help too
00:28:44 <evancz> Has anyone run into TlsNotSupported errors recently with http-client library?
00:29:20 <evancz> The description ( http://hackage.haskell.org/package/http-client-0.2.0.1/docs/Network-HTTP-Client.html ) is pretty minimal, and I'm not sure if this is a dependency thing, something I did, etc.
00:29:38 <evancz> any similar issues?
00:30:07 <evancz> I am trying to communicate with api.github.com, so maybe they changed their requirements
00:30:09 <evancz> ?
00:37:28 <NinjaPenguin> I've just started learning Haskell and I was wondering if it's possible to "overload" a function to have more arguments than the previous definition? Or will Haskell not be able to deduce which function should be called?
00:37:53 <NinjaPenguin> Such as, fst :: (a, b, c) -> a
00:38:35 <m09> functions in haskell actually take only one argument
00:38:36 <d1323> NinjaPenguin not possible
00:38:52 <pavonia> You can do that defining a type class with fst as a type class function
00:39:26 <NinjaPenguin> m09: Right, I meant bigger size tuples. Like I showed above. :p
00:39:29 <d1323> > view _1 (1,2)
00:39:31 <lambdabot>  1
00:39:33 <d1323> > view _1 (1,2,3)
00:39:34 <lambdabot>  1
00:39:37 <d1323> > view _1 (1,2,3,4,5,6)
00:39:38 <lambdabot>  1
00:40:02 <pavonia> > const 1 (1,2,3,4)
00:40:04 <lambdabot>  1
00:40:15 <kadoban> XD
00:41:17 <d1323> > over _1 (+10) (1,2,3)
00:41:19 <lambdabot>  (11,2,3)
00:41:30 * hackagebot regular 0.3.4.3 - Generic programming library for regular datatypes.  http://hackage.haskell.org/package/regular-0.3.4.3 (JosePedroMagalhaes)
00:41:34 <NinjaPenguin> Ah, didn't know about those. That's probably better than having an additional function just for it. :p
00:41:43 <d1323> so there are ways to do this generically, just not the way you wanted. as someone said, all the functions in lambda take one argument
00:42:10 <d1323> all the functions in haskell, even
00:42:23 <NinjaPenguin> d1323: Yeah, thanks.
00:46:19 <d1323> > over  (_Just ._1._1) (+10)  (Just ((1,2), 2, 3))
00:46:21 <lambdabot>  Just ((11,2),2,3)
00:47:36 <d1323> library is called lens. you can think of it as getters and setters on steroids. _1 is a lens. you can combine them with `.'
00:48:53 <edwardk> NinjaPenguin: there are techniques for making overloaded functions that can take arbitrary number of arguments, they use trickery to pull it off
00:49:04 <edwardk> @let import Numeric.AD
00:49:05 <lambdabot>  .L.hs:112:1:
00:49:05 <lambdabot>      Failed to load interface for ‘Numeric.AD’
00:49:05 <lambdabot>      Perhaps you meant
00:49:05 <lambdabot>        Numeric.Sum (from math-functions-0.1.5.2)
00:49:05 <lambdabot>        Numeric (needs flag -package haskell2010-1.1.2.0)
00:49:06 <_flatline_> Is anyone here familiar with HDBC/SQL in general? I've created a new column. What's the easiest way to iterate through the rows and insert a new entry for each row
00:49:08 <edwardk> shucks
00:49:17 <d1323> :t printf
00:49:17 <lambdabot> PrintfType r => String -> r
00:49:23 <edwardk> anyways, i have one in there, but printf does it as well
01:05:02 <augur> ski: it cant throw an error for out of scope vars at compile time since there is no compile time, it has to throw an error at the point of use
01:05:17 <augur> ski: which feels to me more like a presupposition failure. anyway, its not that important
01:14:43 <jnj> Can someone help me with making a type with a 'forall' type variable an instance of Show? I do not know how to specify to GHC that 'a' itself must be an instance of Show. http://lpaste.net/103305
01:15:58 <edwardk> data Action =
01:15:58 <edwardk>           forall a. (Moveable a, Show a) => Move a Position
01:16:21 <edwardk> personally i think this is an 'antipattern'
01:16:25 <edwardk> there are better ways to do this
01:16:34 <jnj> Is there any way I can "delay" that requirement so that it is only used when I want to use show?
01:16:38 <edwardk> what is in Moveable? What instances are there? what powers does it give you?
01:16:59 <edwardk> what does the class contain?
01:17:22 <edwardk> lets turn this around a bit and extract the essence of the problem
01:17:34 <jnj> This is a very simple class: http://lpaste.net/103306
01:17:50 <edwardk> great
01:17:53 <edwardk> now, lets take this apart
01:18:03 <edwardk> why use an existentia?
01:18:23 <jnj> It was because of a cyclic module dependency, let me try and reconstruct my original idea
01:19:21 <edwardk> Well, Movable lets you take a Position and get [b], but you have nothing you can do with b!
01:19:56 <edwardk> so you can't do anythng with that list other than take its length
01:21:17 <osa1> is there a parameter for cabal to print log file while building? (like in previous version of cabal)
01:21:38 <edwardk> osa1: like -v2 ?
01:21:42 <edwardk> osa1: or something else?
01:22:19 <osa1> edwardk: -v2 is a lot more verbose. I'm trying to get "compiling ..." lines and full error messages
01:22:36 <osa1> current cabal only prints last 10 lines and I have to read generated log file
01:22:49 <osa1> I didn't like this new behavior
01:23:39 <edwardk> oh dear. haven't tried it since that became the norm
01:24:26 <bergmark> that is pretty annoying :-h
01:29:21 <jnj> edwardk, sorry for the late reply. This was my original idea: I am making a card game where players take turn doing an "Action". One of those is playing a card for example, which in turn triggers "Action"s defined in the Card. See http://lpaste.net/103306
01:30:19 <pavonia> Wrong paste?
01:30:26 <jnj> yes
01:30:31 <jnj> http://lpaste.net/103307
01:30:32 <jnj> sorry
01:32:02 <jnj> So that is why I made the "moveable" type class http://lpaste.net/103306 and then came up with http://lpaste.net/103305
01:43:59 <hexagoxel> jnj: my first idea: use XConstraintKinds, add a constraint parameter like "data Action c = forall a. (Moveable a, c a) => Move a Position"
01:44:31 <hexagoxel> i have not tried if that actually works though :)
01:45:32 <pranz> hexagoxel: it works
01:47:32 <pranz> jnj: if you quantify over a, then you can't use a anywhere outside that type signature
01:48:52 <pranz> jnj: you could do "data Action = forall a. Show a => Move a Position", if you only want a to be Show
01:50:47 <merijn> hexagoxel: It works, but be aware that any file using Action will have to enable ConstraintKinds
01:50:56 <jnj> hexagoxel, pranz: i will look into trying that, thank you.
01:51:36 <merijn> Be warned, the "forall a. Show a => Move a Position" is an antipattern and would be better as just "Move String Position"
01:51:42 <merijn> @where existential-antipattern
01:51:42 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
01:51:44 <Saizan> or, avoid classes and existentials, you can use hs-boot files to get around cyclic imports
01:52:04 <merijn> Or just split your datatypes and instances off into a single .Types module
01:52:13 <merijn> (Man, I wish GHC had recursive imports)
01:53:07 <Saizan> or just move some declarations into a common module
02:01:39 * hackagebot plugins-multistage 0.5 - Dynamic linking for embedded DSLs with staged compilation  http://hackage.haskell.org/package/plugins-multistage-0.5 (AndersPersson)
02:22:09 <ski> ReinH : you probably already got this, but a functor doesn't require a value function of type `a >---> F a' (for every object (here a type) `a' in the category) (where this function would have been `return')
02:22:21 <ski> ReinH : it requires a type function of kind `* -> *' (or replacing the `*' and `*' with the desired source/domain and target/codomain categoryies of the type function), this type function is the (object-mapping part of the) functor itself : `F : * >---> *' (Or `F : K0 >---> K1', if `K0' and `K1' are the domain and codomain categories)
02:22:26 <ski> augur : hm, i see
02:23:30 <DarkLinkXXXX> Can I get ghc to compile something with contents from another sandbox as a dependency?
02:27:48 <jtcwang> Hey guys, I'm trying to generate an infinite Conduit Source of StdGen (random number seed). Can anyone point me to the right direction here? http://lpaste.net/103309
02:27:54 <d3lxa> anyone skilled in heap profile who can tell me if it's fine or not http://i.imgur.com/Ja5Et8d.png ? any article welcomed, thx, I have performance problem with my problem (matrix operations), searching the source
02:33:34 <nclarke> jtcwang: One thing is that newStdGen lives in the IO monad, so you would need to add a 'MonadIO' constraint to m to use that
02:33:40 <nclarke> The other thing would be to pass in the initial source
02:34:14 <nclarke> I.e. make sourceStdGen of type StdGen -> Source m StdGen
02:35:34 <jtcwang> but then I'll still need to do newStdGen somewhere else
02:35:44 <jtcwang> see my question here: http://stackoverflow.com/questions/23321983/conduit-combining-multiple-sources-producers-into-one
02:36:26 <jtcwang> I'm trying to zip two sources together: sourceFile (ByteString) and sourceStdGen (StdGen)
02:36:43 * hackagebot clash-lib 0.3.0.3 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.3.0.3 (ChristiaanBaaij)
02:37:36 <nclarke> Well, you'll need to do newStdGen somewhere inside the IO monad, certainly
02:38:23 <nclarke> If you want to do it inside the source, you can, but you need to constrain 'm' to 'MonadIO', and use 'liftIO' to get the first StdGen
02:38:25 <nclarke> :t liftIO
02:38:26 <lambdabot> MonadIO m => IO a -> m a
02:38:27 <jtcwang> nclarke, that's for sure, But the line I'm trying to figure out is this:     Prelude.mapM_ yield (stdGenList g)
02:38:39 <jtcwang> nclarke, ok i'll give that a try
02:39:10 <nclarke> jtcwang: Sure, I hadn't tried running your code, that was just the first thing I spotted!
02:39:47 <jtcwang> nclarke, I'm not familiar with monad operations (lifting, transformers etc), so I always get stuck with them
02:41:44 * hackagebot clash-ghc 0.3.0.3 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.3.0.3 (ChristiaanBaaij)
02:50:54 <merijn> Parsec doesn't have a builtin way of parsing numeric literals (both floating point and integer), I guess?
02:51:51 <DanielDiaz> merijn: it doesn't, as far as I know
02:52:10 <ion> merijn: http://hackage.haskell.org/package/parsers-0.11/docs/Text-Parser-Token.html
02:54:41 <merijn> ion: That doesn't really help as I don't actually want a value, I want the String representation of said numeric literal
02:54:48 <merijn> I guess I'll just write it myself
02:56:20 <merijn> Actually, I can probably just get away with parsing "many char" or something
03:01:24 <jtcwang> Can anyone tell my why I'm getting parse error for this snippet? http://lpaste.net/103309
03:02:44 <Polarina> jtcwang, why is there a colon in line 2?
03:03:11 <jtcwang> Polarina, that's list concatenate
03:03:21 * Polarina is blind.
03:03:33 <jtcwang> actually, the first function doesn't have anything to do with the error
03:03:41 <jtcwang> :D
03:03:44 <tarmil> i think the body of your do needs to be indented further than the "l" of "loop"
03:04:19 <jtcwang> nope :/
03:04:44 <jtcwang> (I think the 'where' is bound to the = sign)
03:05:20 <Polarina> jtcwang, indent lines 8, 9 and 10 one further.
03:05:24 <pavonia> Your "g <-" needs to be indented further that "loop"
03:05:27 <pavonia> *than
03:05:57 <jtcwang> rawr you got it
03:06:00 <tarmil> the declaration of "loop" on line 7, not its use on line 6
03:06:28 <eikke__> hvr: I'm inclined to favor the "Apply to oldest version branch that should contain the patch, then forward-merge every version N branch to version (N + 1) branch" (maybe not immediately, but at least before every release)
03:06:30 <jtcwang> thx guys
03:06:46 <eikke__> hvr: less room for human errors (forgetting a branch etc)
03:12:29 <quchen> Is there a reason Data.Set does not provide Set-specific versions of sequence/traverse?
03:16:34 <hpc> :t sequence
03:16:35 <lambdabot> Monad m => [m a] -> m [a]
03:16:47 * hackagebot marmalade-upload 0.7 - Upload packages to Marmalade  http://hackage.haskell.org/package/marmalade-upload-0.7 (lunaryorn)
03:17:14 <hpc> i don
03:18:13 <hpc> i don't think there's a good way to build a value of type [a] for the result set
03:18:50 <hpc> wait, im derp
03:19:06 <hpc> you mean sequence :: Set (m a) -> m (Set a)
03:19:28 <hpc> probably has to do with deciding how to order the (m a) actions?
03:20:00 <hpc> or something like how to handle
03:20:21 <hpc> S.fromList [return 5, putStrLn "different" >> return 5]
03:20:32 <hpc> input set has 2 elements, output set has one
03:20:33 <quchen> hpc: Well, the order of traversal is given by the Ord instance as usual
03:20:41 <quchen> Here's a naive implementation: http://lpaste.net/103312
03:20:48 <quchen> It's the same as Set.map, really
03:21:59 <hpc> yeah
03:22:21 <hpc> that's the only issue i can see it possibly being, just from a few minutes of looking at it
03:23:36 <quchen> As long as the types check the order is given by the Ord instance of 'a'.
03:23:37 <fizruk> quchen: I guess the laws of Traversable do not hold
03:24:46 <fizruk> quchen: e.g. you can lose some of the structure halfway by treating two intermediate values as a single value
03:25:16 <fizruk> [naturality] t . traverse f = traverse (t . f)
03:25:28 <quchen> Hmmm.
03:25:29 <fizruk> i think even this fails
03:25:30 <quchen> Good point.
03:26:05 <pranz> :t traverse
03:26:06 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:27:49 <quchen> pranz: traverse = generalized mapM
03:32:34 <fizruk> i’d say it’s function application generalized over containers and effects :)
03:49:36 <merijn> Is there a way to have TH just dump out a String for GHC to parse instead of a value in the Q monad?
03:50:46 <quchen> I'm not sure that's how TH works. Isn't it a special step during compilation?
03:51:24 <quchen> In particular, doesn't TH happen well after the parsing stage (of which there is only one, the regular one)?
03:52:24 <pavonia> Have you tried -ddump-splices?
03:54:34 <merijn> -ddump-splices outputs whatever TH generates
03:55:08 <merijn> I'm saying I want to generate a String rather than a Q expression, because, well, I can't construct a Q expression for this code
03:55:20 <merijn> (since TH doesn't support pattern synonyms)
04:00:26 <k00mi> you could use CPP as a workaround
04:00:32 <merijn> k00mi: How?
04:00:50 <merijn> CPP doesn't have loops
04:00:54 <merijn> Or parsing, for that matter
04:01:25 <k00mi> right, I don't know what you actually want to do
04:01:38 <merijn> I need to generate several PatternSynonyms from a QuasiQuoter
04:01:56 <merijn> But since TH in 7.8 doesn't support PatternSynonyms, I'm stuck
04:02:33 <merijn> Barring any way to just output a String of said pattern synonyms plus some way to make GHC accept a String as TH output
04:04:38 <k00mi> maybe you can do something like this? http://hackage.haskell.org/package/vector-space-0.8.6/docs/src/Data-AffineSpace.html#.-%5E
04:05:24 <seye> hi - newb question: is it the case (as it seems to be), that in the type signature (a -> b -> c), c can be anything including another function (say Int -> Int) making the expression 'mean' a function taking at least two arguments?
04:05:41 <merijn> k00mi: No, because that still has no way to loop, so I'd have to write everything out by hand
04:05:53 <merijn> k00mi: At which point I may as well throw away the quasiquoter
04:05:57 <pranz> seye: yes
04:06:02 <merijn> seye: Yes
04:06:20 <jbetzend> Hello Haskell people! I'm learning about Haskell testing at the moment and I wondered if there was some way (possibly involving TemplateHaskell) of automatically finding everything that starts with "prop_" in all files in my project and automatically test it?
04:06:21 <seye> cool, thanks - it seemed so, but never read it anyweher
04:07:32 <pranz> seye: (->) is a type constructor, in the same way that c can be (Int,Int), it can be Int -> Int
04:07:33 <fizruk> jbetzend: have you seen doctest? I guess it’s pretty much what you want: https://hackage.haskell.org/package/doctest
04:08:02 <quchen_> jbetzend: QuickCheck already provides that functionality via the 'All' module, http://hackage.haskell.org/package/QuickCheck-2.7.3/docs/Test-QuickCheck-All.html
04:08:39 <jtcwang> jbetzend, let me find u a snippet of mine
04:10:14 <jtcwang> jbetzend, this should work http://lpaste.net/103313
04:11:02 <jbetzend> quchen_, it says that it tests all properties in the *current* module. If possible, I'd want to have one place in my test suite that crawls the rest of the project and finds all props.
04:11:34 <jbetzend> quchen_, although I suppose exporting the one thing from each module and then bundling those in the test suite wouldn't be too bad either
04:11:50 <jbetzend> fizruk, I'll check it out thanks for the link :)
04:12:00 <jbetzend> jtcwang, hang on, I'll take a look
04:12:04 <quchen_> jbetzend: I recommend separating the testing parts from the actual program anyway, so the library does not depend on the testsuites
04:12:12 <jtcwang> jbetzend, if you import every test module you have, it could work
04:12:17 <jtcwang> jbetzend, i think
04:12:55 <seye> pranz: got it - thanks!
04:14:17 <jbetzend> What's the generally accepted way to go here? Code all properties into the testSuite or have them in the modules themselves? Do I want them seperate or together?
04:15:30 <jbetzend> jtcwang, yeah, I've seen a snippet like that before. I have one question: If a test fails, do I get to know which one and where or do I just get a "Some tests failed"?
04:19:51 <seye> Also, in Learn you... it says that 'fmap (*) Just 3' results in Just ((*) 3), which if fine. It then says that this is can be written as Just (* 3). Shouldn't that be Just (3 *)?
04:20:18 <Maior> :t Just (3 *)
04:20:19 <lambdabot> Num a => Maybe (a -> a)
04:20:24 <Maior> :t Just (* 3)
04:20:25 <lambdabot> Num a => Maybe (a -> a)
04:20:44 <quchen_> seye: Well in the special case of (*) it doesn't matter, but in general it should be Just (3*), right.
04:21:09 <seye> yeah - i realise comutativity makes this more of a nitpick, but if it where (++), say
04:21:42 <Maior> :t fmap
04:21:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:21:52 <seye> :t Just ("!" ++)
04:21:53 <lambdabot> Maybe ([Char] -> [Char])
04:21:59 <seye> :t Just (++ "!")
04:22:00 <lambdabot> Maybe ([Char] -> [Char])
04:23:26 <Maior> > fmap (*) Just 3
04:23:27 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
04:23:27 <lambdabot>    arising from a use of ‘M307827757601703482323741.show_M3078277576017034823...
04:23:27 <lambdabot>  The type variable ‘a0’ is ambiguous
04:23:27 <lambdabot>  Note: there are several potential instances:
04:23:27 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
04:23:28 <pranz> > (fmap (++) (Just "Yo")) <*> Just "!"
04:23:30 <lambdabot>  Just "Yo!"
04:23:36 <pranz> seye: ^
04:24:15 <quchen_> (++) <$> Just "Hello" <*> Just "world" -- applicative notation :-)
04:24:28 <davd> when are generalized cata- and paramorphisms useful? e.g. gpara :: (Unfoldable t, Comonad w) => (forall b. Base t (w b) -> w (Base t b)) -> (Base t (EnvT t w a) -> a) -> t -> a
04:25:53 <davd> oh, there's a section in the wiki about it!
04:26:29 <jbetzend> davd, mind sharing the link? :)
04:26:53 <davd> http://www.haskell.org/haskellwiki/Catamorphisms#Generalized_Catamorphisms
04:27:19 <davd> jbetzend: implementations can be found in the recursion-schemes package
04:27:26 <jbetzend> davd, thanks :)
04:28:01 <seye> cool :-)
04:30:27 <ocharles> dreixel: did you mean to take ownership of https://ghc.haskell.org/trac/ghc/ticket/9043#comment:3 ?
04:42:56 <dreixel> ocharles: yes, it just means I'm responsible for it. I think owners are generally people who can push
04:43:05 <ocharles> dreixel: ah, ok
04:43:26 <dreixel> ocharles: it doesn't mean I'll write your patch :-P
04:43:41 <ocharles> oddly enough, this is one of the few times where i don't want someone else to do the work ;)
04:43:59 <dreixel> it also doesn't mean I'll remove your authorship from your patch!
04:44:25 <ocharles> :)
04:44:29 <jophish> Yo yo yo
04:45:32 <zipper> I'm having trouble with getting info out of values of type Options (type Options = M.Map String String) described in http://hackage.haskell.org/package/getopt-simple-0.1.0.2/docs/System-Console-GetOpt-Simple.html
04:48:09 <identity> > let m = M.fromList [("option", "value")] in M.lookup "option" m
04:48:10 <lambdabot>  Just "value"
04:48:15 <identity> @ zipper
04:48:45 <identity> There's also (!)
04:48:50 <identity> :t (M.!)
04:48:51 <lambdabot> Ord k => M.Map k a -> k -> a
04:48:58 <identity> but it's partial
04:48:59 <zipper> identity: Wnere are you getting this?
04:49:09 <identity> zipper: M.Map is just Data.Map
04:49:20 <nclarke> http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map.html
04:49:24 <identity> Data.Map.Map, that is
04:49:31 <identity> Most likely Data.Map.Strict, I'd guess
04:49:38 <identity> no, it isn't
04:49:39 <identity> it's lazy
04:50:11 <identity> either way, same API(for the most part)
04:50:22 <zipper> identity: Well I tried `M.fromList opts` but the types didn't add up
04:50:35 <identity> zipper: where opts :: Options?
04:50:40 <zipper> Yes
04:50:59 <nclarke> opts is already a Map. `fromList' converts a list of pairs to a map
04:51:02 <identity> M.fromList constructs a map from a list of key value pairs, in this case, a [(String, String)]
04:51:09 <nclarke> :t M.fromList
04:51:10 <lambdabot> Ord k => [(k, a)] -> M.Map k a
04:51:12 <identity> so you already have a Map -- you just want to access it
04:51:51 <zipper> Before that I had tried `M.map opts`
04:52:11 <identity> zipper: But I would personally suggest using the cmdargs library. It has a nicer API, IMO, and can pretty much automatically construct your 'config data type'
04:52:13 <nclarke> Ah, that maps a function over the map :-)
04:52:17 <zipper> :t M.map
04:52:18 <lambdabot> (a -> b) -> M.Map k a -> M.Map k b
04:52:48 <nclarke> I would alternatively recommend optparse-applicative
04:53:17 <zipper> I think I have invested too much time in GetOpt simple already.
04:53:29 <identity> That is understandable
04:54:24 <arj> can I somehow create a record data type that can be pattern matched but not constructed outside my module?
04:54:56 <arj> I tried exporting Ctor() but this disallows pattern matching and Ctor(Ctor) allows construction (for data Ctor = Ctor { ... })
04:55:49 <identity> Couldn't ViewPatterns do something like that?
04:55:50 <identity> just a thought
05:00:41 <d3lxa> ok guys, don't ever use bed-and-breakfast for matrices… hmatrix is soooo much faster… I hope I would know it earlier
05:00:54 <zipper> :t Data.Maybe.fromJust
05:00:55 <lambdabot> Maybe a -> a
05:01:20 <merijn> zipper: ಠ_ಠ
05:01:45 <merijn> arj: Well, depends on how portable you want to be
05:02:03 <merijn> arj: PatternSynonyms might be useful to you, but they're GHC 7.8 and up only
05:03:26 <arj> merijn: I only have 7.6.3 available at the moment.
05:03:44 <arj> ok thanks anyway
05:04:01 <merijn> If I write my own implementation of readsPrec can I just ignore the precedence argument?
05:04:39 <merijn> I never quite understand how it's supposed to work
05:04:46 <zipper> merijn: What's up?
05:04:57 <mikeplus64> @pl \a -> f a `g` a
05:04:57 <lambdabot> g =<< f
05:05:35 <zipper> identity: First I had an issue differenciating Data.Map and Data.Maybe
05:05:55 <zipper> identity: but that's out of the way.
05:06:16 <merijn> zipper: I was disapproving of your fromJust
05:06:29 <zipper> merijn: What would you rather I use?
05:06:37 <identity> pattern matching
05:06:41 <zipper> :t M.fromList
05:06:42 <lambdabot> Ord k => [(k, a)] -> M.Map k a
05:06:46 <merijn> zipper: pattern matching, case, fromMaybe, maybe...
05:07:01 <merijn> :t fromMaybe
05:07:02 <lambdabot> a -> Maybe a -> a
05:07:06 <merijn> :t maybe
05:07:07 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:07:19 <merijn> fmap/>>=
05:07:26 <identity> You're basically ignoring the benefits of Maybe by using fromJust -- in your scenario, you might as well just use (M.!)
05:07:51 <identity> zipper: Perhaps it would be better if you posted some code so that we could give you more detailed tips or some such
05:07:58 <zipper> Well in this case all I want to do it get a value from a Just.
05:08:02 <quchen_> It's not only ignoring the benefits of Maybe, it's ignoring the benefits of the type system guarding you.
05:08:20 <zipper> identity: lol I'm ashamed of the code and it's all over the place right now but I will share.
05:09:56 <merijn> zipper: Well, what if you don't have a Just, but a Nothing?
05:15:04 <ocharles> Does anyone know any uniplate-type library that works when I want to change the types? I want to traverse a tree created by GHC.Generics, completely some K1 nodes
05:15:54 <bitemyapp> ocharles: good thing jonsterling isn't awake :)
05:16:16 <yitz> @quote jonsterling
05:16:17 <lambdabot> No quotes match. I feel much better now.
05:16:46 <ocharles> bitemyapp: why is that?
05:17:01 * hackagebot cereal-conduit 0.7.2.2 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.7.2.2 (MichaelSnoyman)
05:17:01 <ocharles> i also accidentally a word in that last question it seems :)
05:17:03 <bitemyapp> ocharles: ML functors enthusiast :)
05:17:06 <ocharles> completely *omitting* some nodes
05:17:09 <ocharles> bitemyapp: ah :)
05:17:19 <makalu> ocharles: where do you work if I may ask?
05:17:26 <ocharles> makalu: company?
05:17:29 <makalu> yes
05:17:33 <ocharles> makalu: a startup called "Fynder" (http://fynder.io)
05:18:32 <ocharles> Ok, I might want biplate it seems
05:18:52 <makalu> cool
05:19:25 <zipper> identity: At the moment I am looking for the best way to parse the arguments and send them to relevant functions https://gist.github.com/urbanslug/648f37ed66013c031a35
05:19:33 <zipper> identity: Sorry I went offline.
05:20:02 <makalu> but I came here for another reason :). If I want to use applicative syntax to apply a function but it's monadic what should I do? I tried join and it works. Is that the usual way?
05:20:05 <Feuerbach> ocharles: does biplate support type changing transforms? I don't see that
05:20:16 <ocharles> Feuerbach: http://hackage.haskell.org/package/uniplate-1.2.0.3/docs/Data-Generics-Biplate.html
05:20:25 <ocharles> it looks like it has separate from and to types, so I think so
05:20:29 <ocharles> also, hi!
05:20:33 <Feuerbach> hi :-)
05:20:42 <Feuerbach> I'm afraid that's different
05:20:58 <ocharles> oh
05:21:11 <alpounet> ocharles: oh, you're not doing musicbrainz anymore?
05:21:18 <ocharles> oh yes, all of these functions are to -> Maybe to
05:21:22 <Feuerbach> one type is the whole structure type, the other is the type of substructures
05:21:27 <ocharles> alpounet: right, I left MusicBrainz at the start of the year
05:21:46 <alpounet> ocharles: still using haskell though I suppose :)
05:21:49 <identity> zipper: Well, you should start by making the arguments to your program Required/Optional as is appropriate, that is if they aren't all optional
05:22:13 <ocharles> alpounet: writing a lot more haskell, it's why I left :) I wasn't happy writing anything else, but I came to realise forcing haskell on MB was a terrible idea that was extremely poisonous to the project
05:22:30 <identity> In the rest of your program, it would probably simply make sense to pass the relevant flags to the relevant functions as maybes
05:22:37 <ocharles> so i realised i wasn't really compatible with the project and the only sensible move was to leave
05:22:45 <ocharles> Feuerbach: ah yes, indeed. hmm
05:22:54 <bitemyapp> ocharles: is fynder your company?
05:22:55 <Feuerbach> ocharles: ironically, GHC.Generics itself is the only library that comes to mind that supports type-changing transforms
05:23:00 <identity> so, let's pretend you have an argument called "file" which is optional, as it will either use the provided file or some default file..
05:23:16 <ocharles> Feuerbach: oh yes, maybe I can do a generic traversal to get a new generic structure
05:23:38 <ocharles> bitemyapp: I'm not an owner or anything, just a contractor right now. hoping to move to be full time + equity sometime soon
05:23:39 <alpounet> ocharles: ok, that sounds like a reasonable decision indeed. still in the UK?
05:23:42 <identity> In that case, you could either do something like: main = do { args <- parseArgsSomehow; config <- loadConfigFile (M.lookup args "file"); .. } or use fromMaybe/maybe
05:23:43 <zipper> identity: They aren't all optional.
05:23:44 <ocharles> alpounet: yep, London
05:23:46 <Feuerbach> ocharles: although I wouldn't be surprised if lens can do it, too (is there anything it can't do?)
05:23:57 <identity> zipper: Well, you have them all set to "Optional"
05:24:01 <bitemyapp> ocharles: did they already use Haskell before-hand?
05:24:03 <alpounet> Feuerbach: lens has 'Plated' for this
05:24:04 <ocharles> Feuerbach: not sure, all I know in lens is plated
05:24:18 <zipper> identity: Not sure how to make e.g password optional pegged on name.
05:24:37 <alpounet> ocharles: well, good luck on your new adventure, sir :)
05:24:41 <yitz> Feuerbach: yes - be idiomatic haskell ;)
05:24:43 <ocharles> bitemyapp: I joined them from the start - Haskell was the initial technology choice. i think them getting me from the start helped them stick to that choice too :)
05:24:50 <ocharles> alpounet: thanks!
05:25:10 <identity> zipper: You could pass them both to your function that deals with that, and if either one is Nothing, you'd fail with an error(or something in that direction)
05:25:25 <zipper> identity: I could do that.
05:25:37 <zipper> but I need to parse the arguments first
05:25:50 <zipper> That is what I was thinking of doing.
05:25:58 <yitz> ocharles: can you build the types to begin with to support the operations? e.g., a type parameter
05:26:11 <ocharles> yitz: that's another thing I'm thinking of
05:26:27 <bitemyapp> ocharles: cool, thanks for sharing. I work at a startup so hearing about others that use Haskell is always interesting.
05:26:33 <yitz> ocharles: you'd still need to traverse and rebuild it of course, so that doesn't always help...
05:26:46 <ocharles> basically, we have a  data CommandF n = Command Arg1 Arg2 (Result -> n)  type free functor, and we want a  data Command = Command (CommandF ())  type that can be shown
05:27:07 <ocharles> I was wondering if I could generalise that (Result -> n) to be (p Result n) and maybe there is a showable profunctor I can use instead
05:27:28 <identity> zipper: I'm not very familiar at all with the getopt-simple library, but it looks like you've already got that down
05:29:01 <alpounet> bitemyapp: haskell startup too?
05:29:03 <yitz> ocharles: could be just p n would be good enough
05:29:17 <bitemyapp> alpounet: not quite. I've only introduced Clojure and Datomic at my company, no Haskell yet.
05:29:24 <alpounet> ok
05:29:25 <Feuerbach> ocharles: did you mean Free CommandF () instead of CommandF ()?
05:30:18 <ocharles> Feuerbach: no
05:30:39 <ocharles> (Though we do use Free CommandF, but that's for other things)
05:30:45 <Feuerbach> well, showing CommandF () seems easy - just print arg1 and arg2
05:30:52 <Feuerbach> so I don't quite see the problem
05:30:55 <ocharles> exactly, but I want to do that with generics
05:31:03 <ocharles> CommandF has about 50 constructors
05:31:08 <Feuerbach> oh
05:31:11 <ocharles> and it's completely mechanic how to show  it
05:31:18 <ocharles> I can do it with overlapping instances
05:31:26 <ocharles> so I just filter out K1 (a -> b) entirely
05:31:33 <ocharles> I just wondered if I could do it with tree rewriting first
05:32:56 <Feuerbach> what's the problem with overlapping i-ces? ;)
05:33:05 <ocharles> None, but I like finding new approaches :)
05:33:16 <ocharles> I will probably go with that
05:33:31 <identity> zipper: But be careful about getting lost in details like configuration parsing when beginning your project :P I mean, you'd rather have a functioning program and fix stuff like that later
05:34:38 <yitz> ocharles: is it a gadt? gadt + type parameter actually can solve a lot of problems for types with many constructors
05:34:56 <yitz> ocharles: sometimes datakinds helps with that too.
05:35:04 <ocharles> well you can't have gadts and data kinds
05:35:08 <ocharles> but no, it's not a gadt
05:35:09 <yitz> ?
05:35:18 <ocharles> data kinds can't promote gadts
05:35:27 <yitz> no as the type parameter
05:35:36 <ocharles> oh, right
05:36:40 <ocharles> Time for some foods
05:37:03 * hackagebot network-bitcoin 1.5.2 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.5.2 (ClarkGaebel)
05:54:17 <vanila> what would be required in compiling haskell to x86?
05:54:45 <c_wraith> vanila: a haskell compiler
05:54:57 <c_wraith> vanila: GHC seems to be popular
05:55:35 <c_wraith> vanila: which is a slightly tongue-in-cheek way of saying that the most popular haskell implementation *is* a compiler.
05:56:00 <vanila> oh yeah, GHC is great! I'm talking about implementing one from scratch (in haskell though)!
05:56:16 <c_wraith> GHC is mostly in haskell, actually.
05:56:22 <c_wraith> Except for the runtime system
05:56:27 <c_wraith> and the primop definitions
05:56:28 <vanila> So far I've been thinking that after parsing and typechecking you can translate the source into a graph. I think you woud need a small runtime that does garbage collection and graph reduction, is that all the runtime would need to handle?
05:56:52 <c_wraith> If you're willing to leave out concurrency, yes
05:57:05 <edwardk> ocharles: the two types in biplate don't let you change the type, they let you search for and manipulate parts of a different type
05:57:06 <c_wraith> GHC's RTS is more complicated only because it also handles concurrency
05:57:14 <vanila> okay, so lets stay simple
05:57:24 <bartavelle> well, the runtime should be able to do a bit more than GC and graph reduction, you at least need some way to print "hello world" :)
05:57:51 <c_wraith> What was the name of the book about how GHC used to work?
05:57:52 <edwardk> ocharles: if we add tinplate1 to lens you'll get the ability to do generic programming where you can manipulate the leave level `a`'s separately or the self-recursive cases
05:58:07 <c_wraith> The one where it built on the spineless tagless g-machine stuff?
05:58:14 <edwardk> but this is one thing lens doesn't contain.
05:59:44 <merijn> vanila: Actually I have a decent reference for you
05:59:57 <merijn> vanila: First things first, are you familiar with Core?
06:00:23 <vanila> I think that GHCs Core is sort of a simplified, more annotated version of the normal language it handles - is that right?
06:00:33 <c_wraith> vanila: http://research.microsoft.com/en-us/um/people/simonpj/Papers/slpj-book-1987/index.htm  This is *huge*, but it's all about an early implementation of GHC
06:00:39 <merijn> vanila: Core is a simplified lazy functional language, yes
06:00:45 <vanila> thanks c_wraith
06:00:47 <merijn> vanila: This paper is rather good: https://research.microsoft.com/apps/pubs/default.aspx?id=67083
06:01:19 <merijn> vanila: It described the STG language (a lazy functional language) and how one would implement it on a standard computer (like x86)
06:01:46 <merijn> vanila: GHC compiles haskell to Core and then in turn compiles Core to STG (there's Cmm somewhere in there, but that's not very exciting)
06:02:06 * hackagebot distributive 0.4.3.2 - Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.4.3.2 (EdwardKmett)
06:02:28 <merijn> vanila: See also Types and Programming Languages (on how to implement type systems and the likes for languages like haskell)
06:02:31 <merijn> @where tapl
06:02:31 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:03:18 <klrr_> @where sicp
06:03:19 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
06:05:23 <klrr_> is SICP good introduction to CS topics?
06:05:49 <c_wraith> yes
06:06:52 <klrr_> okey :)
06:11:05 <archblob> can the optimization flag be changed when working in --interactive ?
06:15:38 <geekosaur> archblob, ghci / the bytecode backend doesn't have an optimizer
06:16:00 <archblob> geekosaur, oh, ok thank you
06:17:10 <quchen_> You can compile modules with optimizations, and GHCi will load the compiled version if unchanged though.
06:17:29 <ocharles> edwardk: oh, interesting
06:18:16 <edwardk> archblob: you can probably do it with -fobject-code turned on
06:19:23 <geekosaur> there are some tradeoffs there though, ghci can't introspect compiled modules fully for example --- it only knows what the .hi file says, it doesn't have the full source
06:20:08 <archblob> quchen_, yes but i should have been clearer, I'm only interested in loading the file directly
06:20:50 <archblob> edwardk, i was not really interested in doing it, just if it can be done, but it's a nice little pice of info, thanks :)
06:21:40 <vanila> > let x = x in x
06:21:44 <lambdabot>  mueval-core: Time limit exceeded
06:21:49 <vanila> why doesn't this give a black hole error?
06:22:08 * hackagebot ZipperAG 0.6 - An implementationg of Attribute Grammars using Functional Zippers  http://hackage.haskell.org/package/ZipperAG-0.6 (prmartins)
06:22:19 <vanila> in this paper it says it detects infinite loops like that
06:23:58 <quchen_> vanila: "this paper" is not very specific.
06:24:01 <geekosaur> it used to do that. turned out to be bad for concurrency; the blackhole mechanism prevents concurrent threads from evaluating the same thunk, and sometimes (often) that's cheaper than having to serialize them
06:24:11 <quchen_> vanila: GHC will report this as a <<loop>>.
06:24:36 <geekosaur> so, some blackholing still takes place, but as ghci runs with the threaded backend a lot of blackholing is disabled
06:24:53 <vanila> ohh okay
06:24:55 <vanila> thanks
06:25:15 <hk3380> is there a concrete, agreed upon distinction between referntial function and pure function? (got d/c)
06:33:04 <osa1> oh, Debug.Trace.trace prints to stdout...
06:33:23 <osa1> sorry, stderr
06:49:36 <pjdelport> hk3380: "pure" is often short-hand for "referentially transparent"
06:50:10 <pjdelport> the latter is more strictly defined, while "pure" is looser, and also gets used for related things
06:58:41 <hk3380> pjdelport: are you definitely sure? i'm writing a report and i want to make it clear whether there's a distinction, but couldn't a find a paper that really cared about the difference
06:58:54 <merijn> ugh, why is the stuff I want always one GHC release away? >.>
06:59:14 <hk3380> wiki says that referential transparent functions could have some impure functions if their impact is insignificant, which is fair to say, but no source provided
07:00:01 <merijn> hk3380: I think by "their impact is insignificant" it means "the behaviour of the impure function does not observably alter the results of the pure one"
07:00:49 <c_wraith> in other words, "ST is ok"
07:00:50 <merijn> hk3380: i.e. imagine an impure hashtable for memoising results. Using this impure function to cache previous results does not observably alter the result of a function (other than being faster/slower)
07:03:37 <hk3380> merijn: well, yeah, that's my interpretation too, and it seems logical. i just can't find a reliable source that i can cite when i say this
07:03:57 <hk3380> worst case scenario i just put it out there like it is with no reference, as i really think this definition makes the most sense
07:04:14 <vanila> Is the source code for this STG paper available?
07:04:23 <pjdelport> hk3380: You probably won't find a specific source; they're terms used by convention.
07:04:28 <drupzky> Hi, is there a nicer way to "lift" a [a] to a [Maybe a] so that all as in the list become (Just a)s, than doing map?
07:04:43 <pjdelport> hk3380: Usually people will give precise definitions for a particular context, whenever it actually matters.
07:04:57 <vanila> > Just <$> [1,2,3]
07:04:59 <lambdabot>  [Just 1,Just 2,Just 3]
07:05:07 <drupzky> thanks!
07:05:24 <quchen_> That is literally map.
07:05:30 <pjdelport> hk3380: So instead of citing, you can probably just give a quick definition of how exactly you define them for the purposes of what you're writing.
07:05:30 <vanila> it's fmap
07:05:37 <quchen_> Which is map here.
07:06:19 <drupzky> okay, but vanily got what I wanted, it just looks nicer than map (\x -> Just x) xs
07:06:28 <drupzky> vanila* sry
07:06:33 <vanila> map Just xs  also works, by the way
07:06:42 <drupzky> ahh nice
07:06:48 <pjdelport> or Just `map` xs
07:06:49 <vanila> even though Just is a constructor, you can treat it like a function too
07:07:21 <vanila> the nice thing about <$> is it works for some other things than just lists, and it has <*>
07:07:36 <vanila> e.g.
07:07:45 <vanila> > (+) <$> [1,2,3] <*> [40,50]
07:07:47 <lambdabot>  [41,51,42,52,43,53]
07:08:28 <Philonous> Well, <$> (that is, fmap) works for any Functor, while (<*>) is only defined for Applicatives
07:08:33 <saml> > zipWith(+) [1,2,3] [40,50]
07:08:34 <lambdabot>  [41,52]
07:08:38 <saml> hehehehe
07:10:58 <merijn> > map Just [1..10]
07:10:59 <lambdabot>  [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
07:11:19 <c_wraith> > Nothing <$ [1..10]
07:11:21 <lambdabot>  [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Not...
07:11:45 <oleo> > map Unjust [1..10]
07:11:46 <lambdabot>  Not in scope: data constructor ‘Unjust’
07:11:52 <oleo> waaahhahahahaha
07:12:53 <merijn> If I'm making a new preprocessor for haskell files, should I come up with a new file extension for it or is there a cleaner way to make sure something is preprocessed before GHC uses it
07:13:31 <joneshf-laptop> :hoogle (Monoid b) => (a -> b) -> (a -> b) -> a -> b
07:13:44 <joneshf-laptop> erm
07:13:48 <joneshf-laptop> @hoogle (Monoid b) => (a -> b) -> (a -> b) -> a -> b
07:13:49 <lambdabot> Data.Generics.Aliases extQ :: (Typeable a, Typeable b) => (a -> q) -> (b -> q) -> a -> q
07:13:49 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
07:13:49 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
07:17:11 <hunt> why would installing something with cabal try and reinstall the versions of things i already have?
07:17:17 <hunt> how do i get aroun this error?
07:18:27 <merijn> hunt: Because it has conflicting dependencies
07:19:27 <merijn> hunt: For example, package X depends on A and B, A also depends on B, you already have A installed using an older version of B than X can work with. Now trying to install X breaks because it can't use the installed version of A (it's version of B is not compatible with X)
07:19:59 <hunt> ah so is using force-reinsatlls ok? why cant cabal manage having multiple versions of a lib?
07:20:12 <hunt> i guess having multiple versions would actually be shitty...
07:20:25 <dcoutts> hunt: it's a long standing limitation of ghc, but one that's not lifted quite so easily
07:20:54 <merijn> hunt: Forcing reinstalls is likely to break things
07:21:00 <merijn> hunt: There's two sane approaches
07:21:05 <merijn> hunt: 1) install inside a sandbox
07:21:22 <merijn> 2) manually "ghc-pkg unregister" all conflicting dependencies and install newer versions
07:21:32 <hunt> this is not fun
07:21:36 <merijn> dcoutts: How do I ensure my preprocessor runs after CPP?
07:21:49 <merijn> dcoutts: When using hookedPreProcessors, that is
07:21:50 <hunt> is there a solution for this in other package manager?
07:21:51 <hunt> s
07:22:04 <merijn> hunt: sandboxing is pretty easy with recent cabal
07:22:23 <dcoutts> merijn: I'm not sure you can, cpp is special because of the direct support in ghc
07:22:36 <merijn> dcoutts: argh, you made me sad :(
07:22:46 <hunt> merijn well shit, ive already started the force reinstalls so im just running with it
07:22:47 <dcoutts> merijn: iirc, you can make cabal run cpp as a separate pre-processor if you name the file .hs.cpp or something
07:22:58 <merijn> That means I have to deal with CPP in my preprocessor :\
07:23:04 <dcoutts> merijn: but then cabal doesn't support chaining multiple preprocessors
07:23:36 <vanila> does ghc target c?
07:23:56 <dcoutts> vanila: no, except in a special mode for porting to new platforms.
07:23:57 <merijn> vanila: No, it used to, but the C backend is deprecated and only around for porting to new architectures
07:24:16 <merijn> vanila: By default GHC generates native code directly, there's also an LLVM backend
07:25:39 <merijn> ffs, having to deal with CPP makes my life so much harder :\
07:26:47 <dcoutts> merijn: so what is it that has to run post-cpp?
07:27:43 <merijn> dcoutts: Basically, I'm writing a quick preprocessor to generate code for FFI enums (I was planning to make it a quasi quoter, but TH doesn't support PatternSynonyms and won't get support for that until 7.10)
07:28:19 <dcoutts> merijn: and what forces that to run post cpp?
07:28:20 <merijn> dcoutts: Some of my enums have stuff conditionally defined, so if I want to handle the code generation properly I have to properly parse and support CPP to figure out which enum values exist
07:28:42 <merijn> dcoutts: If it ran *after* CPP my parser wouldn't even see the values that have been ifdef'ed away
07:29:02 <merijn> So I could just generate my code without needing to implement CPP logic
07:29:10 <dcoutts> merijn: oh, so it has to run before cpp, then that's ok
07:29:20 <merijn> No, CPP has to run before it
07:29:35 <merijn> i.e. I don't want the preprocessor to see stuff that's ifdef'ed away
07:29:53 <mornfall> merijn: you contradict yourself
07:29:57 <merijn> mornfall: No I don't
07:30:21 <merijn> mornfall: Where is the contradiction?
07:30:54 <mornfall> merijn: well, you either deal with CPP and run before it, or you don't deal with it and run after it
07:31:08 <mornfall> merijn: I don't see how you can deal with it when it's gone?
07:31:15 <merijn> mornfall: I don't want to deal with it
07:31:20 <merijn> Hence why I want to run after CPP
07:31:42 <mornfall> 16:27 ( merijn ) dcoutts: If it ran *after* CPP my parser wouldn't even see the values that have been ifdef'ed away
07:32:00 <mornfall> what does that mean then? :-)
07:32:13 <mornfall> is it just a statement of a non-problem?
07:32:16 * hackagebot fixed-vector-hetero 0.1.0.0 - Generic heterogeneous vectors  http://hackage.haskell.org/package/fixed-vector-hetero-0.1.0.0 (AlexeyKhudyakov)
07:32:34 <dcoutts> merijn: so would it really matter if you generate some code that subsequently gets ignored because it's inside a #if conditional?
07:32:51 <dcoutts> merijn: or the point is you might fail in the generation because something is missing
07:33:20 <merijn> mornfall: http://lpaste.net/103314
07:33:31 <merijn> mornfall: I was clarifying that that'd simplify my life
07:33:32 <mornfall> dcoutts: depending on what cpp you use, the code may change in ways other than just removing well-defined sections
07:33:49 <dcoutts> merijn: note that c2hs and hsc2hs both do cpp directly
07:34:19 <merijn> dcoutts: The code generated depends directly on which CPP branches are active
07:34:20 <mornfall> consider bar
07:34:23 <mornfall> #ifdef BLAH
07:34:24 <mornfall> = 3
07:34:25 <mornfall> #else
07:34:35 <mornfall> or something evil like that
07:35:00 <merijn> dcoutts: Consider my example depending on whether BLAH is defined "toEnum 2" should return something different
07:35:14 <mornfall> (I guess that doesn't actually change the meaning of the code for merijn but something else could)
07:35:43 <merijn> So I can't just generate code with the CPP left in, I need to resolve the which values are active while preprocessing to generate code properly :\
07:36:09 <dcoutts> merijn: mm yeah fair enough
07:36:10 <merijn> Alternatively, I need to generate code for the cartesian product of all #if conditions encountered during parsing
07:37:26 <merijn> Is there a way to obtain all the "-I" include flags, etc. from cabal, then I could just call CPP from my preprocessor before doing my own preprocessing
07:37:42 <merijn> dcoutts: FWIW, the CPP handling in c2hs is grotesquely broken
07:37:58 <dcoutts> merijn: it's not strictly cpp it's true, it's just similar syntax
07:38:14 <merijn> dcoutts: I used c2hs in an attempt to do what I want before and any non-trivial CPP I included completely broke c2hs
07:39:18 <dcoutts> merijn: if you mean, from within the Setup.hs, then yes, see the def of the builtin c2hs, hsc2hs, hscpp pre-processors in Cabal
07:39:44 <merijn> Oh, I think I found it already "cppOptions" in BuildInfo
07:40:00 <merijn> ok, then I will just CPP the file myself before preprocessing, that should work, I think
07:40:01 <dcoutts> merijn: it's much more complicated than that
07:40:12 <dcoutts> merijn: see the existing pre-processors for the cpp stuff
07:40:14 <merijn> dcoutts: Why are you trying to make me sad? :(
07:40:21 <dcoutts> build systems are complicated!
07:40:29 <dcoutts> cpp flags from multiple sources
07:44:25 <merijn> dcoutts: It doesn't seem to have much more than just that when I look at http://www.haskell.org/ghc/docs/7.8.2/html/libraries/Cabal/src/Distribution-Simple-PreProcess.html#ppCpp ?
07:46:40 <dcoutts> merijn: you're looking at getCppOptions right?
07:47:10 <dcoutts> merijn: and tbh, I don't think that covers them all (those two pre-processors are rarely used). Look at hsc2hs
07:47:27 <dcoutts> stuff from the current package, stuff from dependencies
07:48:58 <dcoutts> merijn: you're probably ok with the first 3 parts of getCppOptions
07:51:38 <fizruk> how is non-GADT declaration called?
07:51:56 <vanila> just data type declaration
07:52:37 <fizruk> hm… i’d like to distinguish, may I call it “simple” ?
07:53:17 <vanila> yes or regular
07:54:47 <fizruk> thanks!
07:57:19 * hackagebot protobuf 0.2.0 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.2.0 (NathanHowell)
07:58:17 <Javran> @pl \(xs,y:ys) -> (y:xs,ys)
07:58:18 <lambdabot> uncurry ((`ap` tail) . (. head) . ((,) .) . flip (:))
08:05:32 <vanila> ((:) <$> head . snd <*> fst) &&& (tail . snd)
08:09:16 <haskell-newbie> vanila: can you read it in english?
08:10:10 <haskell-newbie> vanila: i mean ((:) <$> head . snd <*> fst) &&& (tail . snd)
08:11:09 <vanila> it just does the same as \(xs,y:ys) -> (y:xs,ys),   y:xs is head . snd ":" fst
08:11:44 <haskell-newbie> vanila: yeah, but how does it reads in english?
08:13:46 <Fernandos> hi
08:14:21 <Fernandos> Are some of you working on extending the WikiBooks Haskell documentation?
08:15:18 <Fernandos> It's really awesome! Only fpcomplete.com was better than wikibooks, learnyousomehaskell etc. looks nice, but doesn't help to learn the relevant stuff fast enough
08:18:58 <Fernandos> What Haskell IDE should I use? Should I really use Emacs, I mean is it really worth it?
08:19:16 <Maior> Fernandos: I just use vim. I keep meaning to use IDEA. ymmv
08:19:24 <Javran> @pl op f x = (x, fx)
08:19:24 <lambdabot> op = const (flip (,) fx)
08:19:56 <Fernandos> Maior: I compiled Lekshah, but also compiled emacs and have not setup my Vim for haskell yet..
08:20:32 <Maior> Fernandos: I use nothing more than vim2hs with vanilla config
08:20:35 <Maior> fwiw
08:21:25 <Fernandos> Maior: I tried SublimeHaskell which autocompiles while I type, which is quite nice
08:22:17 <Fernandos> but yeah, I wanted to know if there is something the Pro's would recommend, for whatever reason :)
08:23:03 <Ankhers> Fernandos: You should use whatever editor you are comfortable using.
08:23:50 <Maior> Fernandos: I'm with Ankhers
08:24:42 <nh2> Fernandos: I recommend SublimeHaskell if you like it! (ok I'm one of the guys maintaining it :P)
08:24:52 <Ankhers> I also advise against using an editor just because someone else does.
08:25:24 <nclarke> I quite like SublimeHaskell, but I was also quite happy just using vim and cabal
08:26:48 <Ankhers> Fernandos: I agree with nh2. If you like it, keep using it. If you find there are any deficiencies with it... you know where to come and who to yell at :P
08:27:22 * hackagebot protobuf 0.2.0.1 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.2.0.1 (NathanHowell)
08:28:51 <Fernandos> Ankhers: I'm not really bound to any editor :) I use nano, vim, sublime, kate, intelli idea, netbeans, eclipse or whatever I find that works.. But I write python, scala, haskell, c, c++, php, javascript, css etc.
08:29:20 <Fernandos> and for java I use intelli idea, because java sucks
08:30:01 <hk3380> when people refer to functional languages as 'stateles' they don't mean literally stateless, do they?
08:30:22 <hk3380> i mean you do have a program state of local variables within a function - the arguments
08:30:23 <nclarke> Yep. Functional languages have no citizenship of an UN registered state
08:30:34 <nclarke> It's a travesty
08:30:40 <nclarke> They have no rights whatsoever
08:30:45 <alpounet> hk3380: yeah except that in general you don't keep changing these "variables"'s value
08:30:53 <alpounet> you just produce new values, based on the previous ones
08:31:02 <nh2> hk3380: no, just that the state is passed around and always a "local" (and in Haskell immutable) thing
08:31:21 <hk3380> alpounet: so they're not really variables because they don't vary. should i not refer to them as variables then?
08:31:33 <alpounet> hk3380: we tend to just call them values
08:32:20 <alpounet> if you have "let x = Just 5 in ...", well, you can be damn sure x will be that a bit further down in the 'in ...' block
08:32:23 <hk3380> nh2: well what's in this passed around state?
08:32:32 <alpounet> hk3380: it's whatever you want to pass
08:32:58 <hk3380> alpounet: so you don't refer it as a sort of new state? you just call it a state? or is not a state at all? :/
08:33:50 <alpounet> hk3380: if you take the example of the "state monad" for example, which is a traditional way of representing computations that maintain a "state" on the side, well if you take a look at the type, you'll see it's just an abstraction around functions of the form: s -> (a, s)
08:33:54 <taktoa> I have a Map String String and a long String, and I want to replace all substrings that are keys with their respective values. Anyone know of a good idiomatic way to do this?
08:34:14 <alpounet> here, 's' is the type of your "state", "a" is the type of the value returned by your function, and the 's' on the right is the new state
08:34:34 <alpounet> so you're not updating stuffs in-place, you're literally producing a new value for you "state"
08:35:14 <Kron_> taktao: what about overlapping keys?
08:35:17 <hk3380> alpounet: i see. so how is it better to refer to this - as being one constant state, or no state at all? (or it doesn't matter?)
08:35:27 <Kron_> it's not immediately clear what the correct way to resolve that is
08:35:35 <Kron_> if you have a key "foo" and a key "oof" and the string is "foof" then what?
08:35:59 <taktoa> I suppose they could be delimited or something
08:36:07 <alpounet> hk3380: it's really not so important. the key idea is that "int x = 4; /* some code ... */ x = 5;" won't happen
08:36:10 <taktoa> like, all keys are of the form "$foo$"
08:36:21 <hk3380> alpounet: i see. cheers man <3
08:36:22 <Kron> hmm, okay
08:36:58 <Kron> so the string itself would be like "$foo$ something soemthing $oof$"?
08:37:59 <taktoa> yes
08:38:05 <alpounet> hk3380: we have some solutions for dropping down to some "more imperative" style of writing programs, locally, where the algorithms just perform better when you actually modify things etc. But aside from these bits of your programs, you really operate in a pure way. a function "Int -> Text -> Html" is guaranteed to not access anything except "constants" and its 2 arguments
08:38:27 <alpounet> (and other functions obviously)
08:38:36 <taktoa> and there would be a Map like: Map.fromList [("$foo$", "bar"), ("$oof$", "baz")]
08:39:03 <taktoa> and the desired product would be "bar something soemthing baz"
08:39:49 <hk3380> alpounet: what's a bit confusing about this state deal is that variables are defined as 'storage locations' rather than 'mutable values' so according to that definition, i feel like saying functional languages have no state is a bit iffy, as they do have variables/storage locations for their values
08:40:27 <Kron> taktao, alright that's a lot more doable
08:41:09 <alpounet> hk3380: well, we basically don't care about the "location" aspect. an identifier in haskell is a name for a value, period. not a time-changing value (like a non-const variable is in C++ for example), just a value.
08:41:11 <Kron> I'm trying to look up the name of the library for what I'm thinking about
08:41:17 <Javran> @pl op f g x y = f (g x) y
08:41:18 <lambdabot> op = (.)
08:42:07 <Kron> I suspect the best way to do it would be with regexs
08:42:12 <Kron> https://hackage.haskell.org/package/regex-compat-0.92/docs/Text-Regex.html
08:42:24 <hk3380> alpounet: yeah, this does make sense
08:42:40 <alpounet> hk3380: but don't make too big a deal out of this. if you want to know how it feels like to write decently-sized projects in Haskell, then give it a shot, and you'll actually develop a good instinct on how it feels like, what's different etc. Just by structuring your program, reading about how people do it, etc. You really only should trust yourself for that, we can read a lot of crap on the internet and also the experience is di
08:42:40 <alpounet> fferent depending on who you ask
08:42:55 <Kron> or wait hold up we're not just trying to find the keys we're trying to string replace them
08:43:07 <Kron> hmm, we could actually kind of do that manually
08:43:08 <Fuco> is there a simple synchronous way to read output of a program as a string? e.g. I'd run "finger" from haskell and I want to receive the input as a string.
08:43:28 <Fuco> I'm mostly asking for some nifty library that covers the nonsense :P
08:43:50 <joelteon> Fuco: process
08:43:52 <alpounet> Fuco: System.Process module
08:43:59 <Maior> Fuco: System.Process's readProcess
08:44:10 <Fuco> thanks :)
08:44:14 <Maior> https://www.haskell.org/ghc/docs/6.12.2/html/libraries/process-1.0.1.2/System-Process.html#v%3AreadProcess etc.
08:44:34 <Maior> though that example code doesn't match the prototype
08:45:08 <Kron> taktoa: I'd write my own recursive function where pattern matches on the string as a list (x:xs)
08:45:15 <Maior> Fuco: http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html, there
08:45:25 <taktoa> okay
08:45:43 <Maior> though the example _still_ doesn't match the prototype... brb going to try to add doctest support!
08:45:56 <Kron> if function ('$':xs) then we just span (/= '$')
08:45:59 <Maior> ...my bad, [] is ""
08:46:01 <taktoa> I mean, I had a solution that was using Data.String.Utils.replace from MissingH
08:46:03 <Kron> to get the first substring that reaches until the next $
08:46:07 <Kron> and then the rest of the list after
08:46:14 <taktoa> but I thought there might be a more idiomatic way to do it
08:46:19 <Kron> we then do a lookup on the span result ++ the other value of the tuple
08:46:23 <taktoa> using parsec or similar
08:46:29 <Kron> I agree, I suspect there may be a more idiomatic way to do it via a parser library
08:46:36 <Kron> but there seem to be a lot of regex/parser libraries
08:47:25 * hackagebot network-msg 0.3 - Recvmsg and sendmsg bindings.  http://hackage.haskell.org/package/network-msg-0.3 (sickmind)
08:47:28 <Kron> maybe a fold over a replace from Data.Text?
08:47:45 <alpounet> Kron: we tend to write our own parsers by using the parser generator libraries in general. (we = the community)
08:47:50 <Kron> but that strikes me as greatly inefficient
08:47:53 <Kron> hmm okay
08:48:14 <alpounet> also, I recommend Text over String whenever you feel comfortable enough in Haskell to switch from Prelude list functions to Data.Text's
08:48:16 <Kron> I guess I don't know the right way to solve this
08:48:26 <Kron> i know a few ways but they all strike me as kind of ugly
08:48:51 <alpounet> Kron: on the other hand, the use case of replacing $foo$ by the corresponding value in the map is a bit overkill for a parser-based solution I guess yeah :p
08:49:22 <Kron> if the map is really large and we're dealing with a long string it may be worth it
08:49:53 <Kron> we need some sort of recursive compositional control structure that parses through the list replacing things it finds
08:50:03 <Kron> a naive fold with a single substring replacement function isn't going to cut it
08:50:08 <Kron> hmm
08:50:14 <Kron> or maaybe it might...
08:50:31 <Kron> it sounds space inefficient but lazily evaluated list constructing folds should chain properly
08:50:44 <Kron> without necessarily tracing the whole original list several times
08:51:29 <taktoa> could have a Parser that munches all input until a $, then takes until the next $, puts that value through the map, and returns
08:51:41 <taktoa> then just do many on that parser?
08:52:02 <ocharles> dreixel: in generic-deriving, why does GEq' (K1 c) require GEq c? Why not just Eq c?
08:53:03 <Kron> I've never used a parser library in haskell before, so I really don't know :(
08:53:24 <taktoa> I'll try it
08:54:11 <Kron> good luck!
08:55:06 <albeit> Is it bad style to use a state monad of State Foo (), and just fill members of Foo instead of having it wrap something other than ()?
08:55:24 <taktoa> wait couldn't I just split on $
08:56:29 <hunt> so im trying to install wai-middleware-static
08:56:39 <hunt> and i get the error that ResponseFile was not found
08:56:54 <hunt> ive tracked this down to indicate that Network.Wai.Internal was not included
08:57:02 <hunt> but i dont understand wai it wasnt (pun)
08:57:17 <hunt> i feel like there must just be something wrong with my cabal installation
08:57:31 <hunt> because i had to force-reinstalls in order to install this stuff in the first place
08:57:37 <identity> albeit: I'm not sure I understand your question. You mean have a function that returns nothing because you just want to 'fill Foo'?
08:57:42 <fizruk> albeit: you mean do { field1 .= val1; field2 .= val2; … } or what?
08:57:42 <hunt> although any suggestions would be appreciated
08:58:13 <identity> In cases where you don't care about the return value, there's .. execState? I always confuse them
08:58:14 <albeit> Yes. It modifies the state structure, but doesn't "return" anything.
08:58:18 <identity> :t execState
08:58:19 <lambdabot> State s a -> s -> s
08:58:21 <hunt> it does import Network.Wai
08:58:22 <identity> no
08:58:26 <identity> :t evalState
08:58:27 <lambdabot> State s a -> s -> a
08:58:31 <identity> oh, yes, execState
08:58:31 <hunt> but for some reason that doesnt include Wai.Internal
08:58:33 <identity> durr.
08:58:53 <albeit> Yes, so it's okay to just ignore the "a"?
08:58:57 <fizruk> albeit: execState is ok
08:59:06 <identity> albeit: Sure. I mean, if you use execState you can return whatever you want.
08:59:17 <identity> including the state..
08:59:22 <identity> or just "3".
08:59:58 <identity> But consider whether you really need State in that case -- it could be just as easy to use a fold, depending on what you're doing.
09:00:35 <albeit> Okay, thanks
09:00:43 <alpounet> Kron: just give a first shot, and improve on it when it works.
09:01:12 <Kron> I shall someday! At the moment I'm elisping
09:02:43 <Javran> @pl f i = (i:) . t
09:02:43 <lambdabot> f = (. t) . (:)
09:04:50 <allsystemsarego> hi all, how can I suppress the "*** Exception: ExitSuccess" output of exitSuccess (from System.Exit)?
09:06:06 <joelteon> allsystemsarego: where are you getting that output?
09:06:25 <allsystemsarego> joelteon, in the console
09:06:45 <joelteon> ghci?
09:06:54 <allsystemsarego> joelteon, yes
09:07:00 <joelteon> that's what ghci's default exception handler looks like; you wouldn't want exitSuccess to *actually* terminate ghci
09:07:07 <joelteon> well, you might want that. but it doesn't
09:07:19 <joelteon> if you run the program normally, exitSuccess will terminate it.
09:07:21 <allsystemsarego> oh, ok, that makes sense
09:07:31 <allsystemsarego> thanks joelteon
09:07:31 <Fernandos> Javran: what does  f i = (i:) . t  mean?  A function with param i is defined as .. ?
09:08:26 <vanila> Fernandos, f i x = i : t x
09:08:28 <vanila> easier to read
09:08:31 <vanila> same function
09:08:49 <ion> > ((1:) . map (*10)) [5..9]
09:08:51 <lambdabot>  [1,50,60,70,80,90]
09:09:19 <Fernandos> vanila: Does the colon stand for division?
09:09:27 <vanila> no, it's cons for making lists
09:09:35 <vanila> [1,2,3] is the same as 1 : [2,3]
09:09:40 <Javran> Fernandos: I define it as "t `prependA` i = \x -> i : t x"
09:09:55 <ion> > 1 : map (*10) [5..9]
09:09:56 <lambdabot>  [1,50,60,70,80,90]
09:15:52 <vermeille> @pl f i x = i : t x
09:15:52 <lambdabot> f = (. t) . (:)
09:22:11 <robstewartuk> Is there a way to use pragmas to selectively choose the module imports that is sensitive to command line args to GHC? E.g. ifdef #something import Foo.Bar else import Foo.Baz , where #something is given as an argument to GHC ?
09:25:24 <deadfoxygrandpa> hey everyone, using http-client and working with the github api, but the past couple days we've seen a lot of TlsNotSupported exceptions
09:25:25 <vermeille> what would be the use case?
09:25:50 <deadfoxygrandpa> has anyone else seen this? could it be related to people changing stuff because of heartbleed?
09:26:35 <Jei> might very well be
09:28:00 <identity> deadfoxygrandpa: I ran into a lot of problems very shortly after heartbleed with tls
09:28:19 <angerman> how do I validate a record against a certain set of functions? Say I can build a set of function fn :: Record -> Maybe String, where fn checks for condition and return Just "error message" or Nothing if everything is fine. How would I run N of those fn against a record R, without having to resort to if ... then ... else trees?
09:28:22 <identity> it basically completely broke on my system for a while.
09:28:35 <deadfoxygrandpa> identity: have you resolved those issues?
09:28:41 <angerman> Or maybe I should not use Maybe but some other type? Any input would be greatly appreciated.
09:29:48 <Javran> > take 2 (tails [1,2,3,4,undefined])
09:29:50 <lambdabot>  [[1,2,3,4,*Exception: Prelude.undefined
09:30:08 <Javran> is there a lazier `tails`?
09:31:38 <Javran> sorry, I was wrong..
09:31:39 <glguy> tails is as lazy as it gets
09:31:52 <identity> deadfoxygrandpa: I ran into the problem originally while using git -- I ended up removing libcurl on my system(which used gnutls) and installing the openssl version, and then git worked fine
09:31:54 <glguy> > map (take 1) (tails [1,2,3,4,undefined])
09:31:56 <lambdabot>  [[1],[2],[3],[4],[*Exception: Prelude.undefined
09:32:01 <identity> (or I recompiled git against libcurl-openssl, I don't recall)
09:32:31 <identity> angerman: So you want to collect all the Just's?
09:32:42 <identity> Or you want to run it until you reach a Just?
09:32:50 <angerman> identity: I guess getting the first error will be sufficient.
09:32:57 <Javran> glguy: I just realise 'undefined' is in the result and that's why I got such output.
09:33:05 <angerman> there's likely not going to be enough space for all errors anyway :)
09:33:18 <deadfoxygrandpa> identity: thanks for the info, i'll look into it
09:33:23 <identity> angerman: then there's MonadPlus, I guess
09:34:10 <identity> > foldl1' mplus [Nothing, Just 3, Nothing, Just 4]
09:34:12 <lambdabot>  Just 3
09:34:45 <angerman> hmm... haskell is really all about monads :)
09:34:57 <identity> angerman: You could also use lefts/rights and switch to Either
09:35:14 <identity> but that may be redundant
09:35:32 <quchen_> No, Haskell is not even remotely all about monads.
09:35:35 <angerman> yep I guess so.
09:35:57 <angerman> quchen_: I know, but when ever I have something to solve, it's always going to involve monads :)
09:36:41 <dwat3r> hi guys, i'm trying to use the "next" function from Network.Pcap module,and I don't know why it isnt working.
09:36:51 <angerman> so, i'll build a list of [Record -> Just String], map that over my record, and run fold it with mplus. sounds fine.
09:37:12 <jle`> angerman: maybe, it is that monads provide a convenient solution for a wide range of problems :)
09:37:24 <angerman> jle`: that's probably it :)
09:37:45 <jle`> but
09:37:49 <jle`> mplus doesn't have to do with monads
09:37:49 * angerman is still not sure he really wanted to go down that vty-ui road
09:37:55 <jle`> it' relaly just (<|>)
09:37:56 <identity> angerman: that sounds like a fair solution yes
09:38:12 <jle`> which is really just a monoid over Maybe a
09:38:18 <jle`> just not the default monoid
09:38:44 <jle`> > foldMap First [Nothing, Just 3, Nothing, Just 4]
09:38:45 <lambdabot>  First {getFirst = Just 3}
09:38:55 <angerman> sometimes I feel ashamed to have studied math, but never touched any of this.
09:39:10 <jle`> > getFirst . foldMap First $ [Nothing, Just 3, Nothing, Just 4]
09:39:12 <lambdabot>  Just 3
09:39:26 <daimonos> Is it just me or is programming frustrating?
09:39:49 <identity> jle`: oh yeah, I forgot about First. I have never used it, but I remember someone mentioning it before when someone asked a similar question
09:39:52 <deadfoxygrandpa> angerman: not everyone that studies math studies category theory. one of my good friends just got his phd in set theory and he'd never heard of monoids or monads or basically anything
09:40:13 <angerman> daimonos: it's Just You.
09:40:31 <jle`> yeah i guess first is only useful over <|>/mplus because you can use it with monoid functions
09:40:52 <angerman> deadfoxygrandpa: alright :) Time to do a Phd in Category theory then I guess :) After all I did mostly geometry
09:40:58 <jle`> although i'm not sure how you can get so far in math without learning about groups?
09:41:16 <jle`> monoids are just groups without an inverse
09:41:27 <Javran> "class (Monoid w, Monad m) => MonadWriter w m | m -> w where" can someone explain the part "| m -> w" ? I haven't seen it before..
09:41:45 <jle`> thars onea dem fundeps
09:42:06 <glguy> Javran: http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/type-class-extensions.html#functional-dependencies
09:42:08 <quchen_> Javran: See this SE answer, http://stackoverflow.com/questions/20040224/functional-dependencies-in-haskell/20040343#20040343
09:42:13 <nclarke> It says that w can be determined by m
09:42:15 <deadfoxygrandpa> jle`: yeah he knew groups. when i explained monoids to him he said "oh, that's a group without an inverse"
09:42:31 <Javran> thanks
09:42:39 <angerman> daimonos: But really, it's just frustrating in the beginning, and haskell seems to be quite frustrating at first :)
09:43:48 <angerman> jle`: apparently you can get pretty far :)
09:44:09 <jle`> though to be fair i have never studied monoids before haskell...groups definitely though.  maybe they just aren't as useful in "normal" maths
09:44:35 <drupzky> I'm having big trouble understanding mplus, can someone please elaborate on foldl1' mplus [Nothing, Nothing, Just 1, Nothing], because the docu of mplus says only "an associative operation," which is not illuminating for me (maybe some1 fix that?!)
09:45:03 <jle`> drupzky: mplus is a binary associative operation, with the identity mzero
09:45:06 <jle`> if that...helps at all >_>
09:45:16 <angerman> :t mplus
09:45:17 <lambdabot> MonadPlus m => m a -> m a -> m a
09:45:18 <drupzky> xDDD no it does not
09:45:20 <jle`> it should evoke in you faint memories of the definition of monoid
09:45:20 <deadfoxygrandpa> jle`: well, i have another maths grad student friend who specializes in category theory and it's interestng talking about haskell with him, because he knows all the category theory behind it but has a hard time imagining how it'd be applicable to programming
09:45:24 <jle`> do you know what a monoid is?
09:45:41 <drupzky> kind of
09:46:08 <jle`> the integers form a monoid under (+) with the identity zero
09:46:10 <jle`> > (1 + 2) + 3
09:46:12 <lambdabot>  6
09:46:13 <jle`> > 1 + (2 + 3)
09:46:15 <lambdabot>  6
09:46:16 <jle`> > 3 + 0
09:46:17 <lambdabot>  3
09:46:36 <jle`> the booleans form a monoid under (&&) with the identity True
09:46:40 <deadfoxygrandpa> drupzky: monadplus is basically just a monad and monoid at the same time
09:46:40 <daimonos> angerman: :)
09:46:46 <jle`> > (True && False) && True
09:46:47 <lambdabot>  False
09:46:58 <jle`> > True && (False && True)
09:47:00 <lambdabot>  False
09:47:10 <jle`> > False && True
09:47:11 <lambdabot>  False
09:47:22 <drupzky> ahh okay
09:47:24 <jle`> basically a monoid a is something with a "combining" operator, a -> a -> a
09:47:25 <drupzky> now I got it
09:47:29 <jle`> where there is an identity element..and it is associative
09:47:55 <jle`> so mplus (the operator) and mzero (the identity) make a monoid over...the mondplus data thing
09:48:00 <jle`> (not sure what word to use for it)
09:48:03 <drupzky> okay
09:48:11 <drupzky> got it! thanks big time :)
09:48:44 <jle`> deadfoxygrandpa: that's very interesting
09:48:52 <Javran> another question, I find "instance Monoid a => Applicative ((,) a)" but in Writer monad it's "Monoid m => (a,m)", somehow inconsistent, any reason for this design?
09:49:00 <identity> Understanding monoids, groups, rings and a bunch of other stuff related to category theory is only hard because people think it is. It's just about patterns, really. It's just about observing that patterns form all over in math and being able to do the same stuff to different things because they both fit the pattern
09:49:32 <identity> (that's my view of it, anyhow. I know very little about category theory)
09:49:54 <jle`> Javran: how do you mean?
09:49:59 <deadfoxygrandpa> identity: my category theory friend insists he could explain most of those concepts to 10 year olds because they're so simple, but i'm not really sure if he's correct
09:50:24 <dwcook> identity, you don't even need to bring up CT to talk about monoids, groups, or rings
09:50:31 <jle`> don't underestimate 10 year olds
09:50:32 <yitz> monoids groups and rings are not category theory.
09:50:56 <deadfoxygrandpa> jle`: is it alright if i underestimate my friend?
09:51:03 <yitz> they are loosely related to category theory. but so is everything else in mathematics.
09:51:06 <jle`> deadfoxygrandpa: haha. that's probably more fair
09:51:11 <identity> (this is why I mentioned I know very little about category theory)
09:51:27 <nclarke> Monoids come up more in CT than in other areas of maths, to be fair
09:51:38 <Javran> jle`: I meant the place for monoid is inconsistent, in applicative it's in `fst` position but in monad it's in `snd` position
09:51:40 <FreeFull> Javran: (a,m) is the same as (,) a m
09:51:45 <nclarke> Groups and rings have a bit more interesting structure, so they come up much more elsewhere
09:51:48 <yitz> nclarke: yeah i suppose.
09:52:06 <jle`> Javran: well, Writer is wrapped in a newtype isn't it?
09:52:21 <FreeFull> It would have to be (m,a) if it wasn't wrapped
09:52:38 <jle`> i think writer's monoid being second is probably evokative of the State monad
09:52:50 <jle`> where the 'result' is the first and the 'metadata' is the second
09:52:55 <yitz> identity: from this list: monoids, groups, rings, category theory - the most important to learn about for haskell programming is monoids. (they're easy, too.)
09:53:00 <jle`> but i do not know the history of this and it would be very embarassing if writer came before state
09:53:09 <exicer> I'm trying to install skein in a fresh sandbox on Osx 10.9.2 (necessary for snap). I get the error "skein-1.0.9 failed while unpacking the package. The exception was:
09:53:12 <Javran> I see
09:53:13 <exicer> user error (data is not in tar format)"
09:53:29 <exicer> Any ideas what I can do to fix this ?
09:53:45 <jle`> the applicative instance of (a,b) is sort of a straightforward extension of the functor instance
09:53:47 <yitz> exicer: try again. probably a network problem.
09:53:59 <jle`> er, of (a,)
09:54:10 <exicer> yitz: Hmm, it is pretty persistent
09:54:16 <exicer> I've tried for half an hour or so
09:54:26 <yitz> exicer: oh. try cabal update again.
09:54:44 <yitz> exicer: i meant. sorry.
09:55:03 <exicer> yitz: Same error after update
09:55:16 <yitz> exicer: what cabal update does is download a tar file from the hackage server.
09:55:46 <exicer> Hm, okay. But I can install other packages with no issue ?
09:55:49 <exicer> Or is it per package
09:55:49 <Javran> so, here raises another questions: given "data F a b", how to parameterize  "F" on "a" part, say if I want to "instance Functor f (F ??? b)" ?
09:56:20 <yitz> exicer: do you think the problem is with the package index tar file, or with the skein package tar file?
09:56:34 <exicer> yitz: I would guess the package tar file.. but I really don't know
09:56:38 <jle`> Javran: you need a newtype wrapper
09:57:04 <exicer> yitz: Is there some way to clear out cabal's list of files, and start again ?
09:57:09 <yitz> exicer: you can download the package tar gz file directly from the package page on hackage if you want.
09:57:15 <jle`> unless maybe we can do instance Functor (`F` b)
09:57:19 <jle`> hm.
09:57:36 <jle`> (but we don't, we use newtype wrappers :) )
09:58:03 <angerman> :t (<|>)
09:58:04 <exicer> yitz: Where would I then put it ?
09:58:04 <lambdabot> Alternative f => f a -> f a -> f a
09:58:12 <yitz> exicer: sure. just delete your .cabal folder. then run cabal update again
09:58:13 <Javran> jle`: newtype wrapper should work under most situations I think?
09:58:37 <jle`> it should, but the unwrapping may lead to noise if not handled properly
09:58:42 <Javran> just rearrange type arguments
09:58:59 <jle`> newtype F2 b a = F a b
09:59:13 <jle`> er
09:59:17 <jle`> F2 (F a b)
09:59:30 <yitz> exicer: unzip it, then go into that folder and type cabal install. or if you are using sandbox, go back to your sandbox and add that folder using cabal sandbox add-source.
09:59:32 <Javran> Don't know if there is a syntax for "type hole"..maybe
10:00:21 <angerman> I think I prefer f0 r <|> f1 r <|> f2 r over fold1 mplus ($r) [f0,f1,f2]
10:01:10 <yitz> angerman: you must mean for Maybe
10:01:21 <angerman> yes.
10:01:40 <yitz> angerman: yeah i have been moving to that style too
10:01:42 <angerman> f0 :: Record -> Maybe String
10:01:52 <angerman> it's just more readable.
10:02:33 <jle`> foldMap (First . ($r)) [f0, f1, f2, f3]
10:02:41 <jle`> heh. probably worse
10:02:54 <yitz> angerman: i agree. i like <|> for Maybe.
10:02:55 <angerman> jle`: I think I'm just parsing that | (or) beter.
10:03:17 <jle`> yeah, that's clear
10:03:23 <yitz> jle`: but it's cool though
10:03:24 <jle`> and with only three functions why not
10:03:44 <jle`> hm.
10:04:10 * yitz winces, ready for the lens people to come crashing in
10:04:29 <jle`> [f0,f1,f2] <*> pure r
10:05:12 <yitz> @type \f r -> [f] <*> pure r
10:05:13 <lambdabot> (a -> b) -> a -> [b]
10:05:40 <jle`> i like that over map ($r)
10:05:41 <yitz> jle`: ok but you're missing the Maybe now
10:06:38 <yitz> @type (<*>)
10:06:39 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:07:11 <yitz> oh i see so
10:07:21 <yitz> @type \f r -> [f] <*> [r]
10:07:22 <lambdabot> (a -> b) -> a -> [b]
10:07:26 <yitz> aha
10:07:58 <jle`> yeah, that's just one component
10:08:01 <jle`> of the solution
10:08:07 <jle`> i find map ($r) to be kind of ugly :|
10:08:57 <yitz> foldr1 (<|>) (fs <*> pure r)
10:09:22 <ReinH> yitz: <|> is a monoid so you don't need foldr1
10:09:41 <yitz> i wish the *other* monoid instance were the default for Maybe. it's so much more useful.
10:09:54 <yitz> ReinH: unfortunately it's not the default instance for Maybe.
10:10:05 <dreixel> ocharles: consistency, more than anything else...
10:10:08 <ReinH> yitz: the default instance for maybe should be the one from Semigroup.Option
10:10:08 <yitz> ReinH: you need to wrap it in First.
10:10:13 <dreixel> ocharles: it's a debatable choice, though.
10:10:21 <angerman> That records do not use their field fn on destructuring, but consider it ambiguous, if there's another function with the same name is kinda unfortunate.
10:10:24 <ReinH> since that's how you turn a semigroup into a monoid for free
10:10:31 <angerman> On the other hand though that kinda forces you to clean up your code base.
10:10:55 <exicer> yitz: Looks like that has worked, thanks!
10:11:04 <ReinH> First is pretty easy to use
10:11:06 <yitz> exicer: cool!
10:11:06 <ReinH> > ala First foldMap [Nothing, Just 1]
10:11:07 <lambdabot>  Just 1
10:11:24 <yitz> @type ala
10:11:25 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
10:11:30 <yitz> huh
10:11:40 <ReinH> it just wraps and unwraps the newtype
10:11:41 <albeit> If I have a datatype Foo, with instance foo, how can I make bar, which equals foo but with one field changed?
10:12:31 <yitz> albeit: if Foo is a record: foo { field = baz }
10:12:33 <carlosgaldino> is this the best place aggregating the haskell's successful cases? http://www.haskell.org/haskellwiki/Haskell_in_practice
10:12:34 * hackagebot xml-html-conduit-lens 0.3.0.0 - Optics for xml-conduit and html-conduit  http://hackage.haskell.org/package/xml-html-conduit-lens-0.3.0.0 (MatveyAksenov)
10:12:40 <albeit> yitz: A great, thanks
10:13:34 <jle`> if only the record modifier syntax was first-class somehow
10:13:43 <jle`> . o O ( if only... )
10:13:48 <yitz> ahh lenses for xml-conduit. i've been waiting for that. i wonder how that interacts with xml cursors.
10:14:04 <edwardk> jle`: give us time
10:14:24 <jle`> oh it was supposed to be a subtle and ignorable lens joke
10:14:24 <edwardk> jle`: one of the possible extensions to the ORF allows that later on
10:14:47 <jle`> wait, really?
10:15:06 <edwardk> well, there is a subtle and not-quite ignorable issue with using lenses as a field accessor replacement that needs eventual addressing
10:15:21 <jle`> i was just saying that as a set-up for someone to come along and say "lens!"
10:15:26 <yitz> edwardk: which was the original motivation for lenses
10:15:44 <alpounet> yitz: i've been using that package recently, it's pretty nice :)
10:16:01 <yitz> alpounet: nice, thanks. i'll have a look.
10:16:05 <jle`> i have a hard time rationalizing why something like accessors/modifiers should even be a part of syntax
10:16:46 <mietek> It doesn't seem like it's possible to run  cabal update  with a custom  --config-file  or am I doing something wrong?
10:16:47 <yitz> jle`: well OO does it. why shouldn't we?
10:17:21 <alpounet> yitz: I used to write crappy functions with tagsoup before. the only thing I'm bugged by is that the package mentions conduit but concretely it's not important and I especially don't care what streaming api is used. but it's really handy to use, I crawl some sites and get data out in 15-20 lines
10:17:37 <jle`> sounds fair
10:17:38 <yitz> alpounet: yeah that should be split out
10:17:55 <mietek> Never mind.  I am.
10:18:36 <nh2> why is there no strict equivalent to Control.Monad.State.Strict.modify? That feels kinda useless
10:18:43 <yitz> mietek: i do remember having trouble with that with earlier versions of cabal. if that is still a bug, please report it on github.
10:19:15 <yitz> nh2: like modify'
10:19:33 <nh2> yitz: yes, that doesn't seem to exist
10:19:34 <mietek> yitz: no, it's just a bug with my use of bash
10:19:48 <albeit> :pl (\a -> a {bar=baz})
10:19:53 <yitz> mietek: ok.
10:19:58 <albeit> @pl (\a -> a {bar=baz})
10:19:58 <lambdabot> (line 1, column 10):
10:19:58 <lambdabot> unexpected "{"
10:19:58 <lambdabot> expecting variable, "(", operator or ")"
10:20:16 <jle`> (they aren't first class)
10:20:28 <nh2> yitz: or does it?
10:20:37 <edwardk> jle`: http://www.haskell.org/definition/from12to13.html#records
10:21:24 <nh2> currently I'm doing {x <- get; put $! x + 1}, having modify' sounds useful and consistent to me
10:21:36 <edwardk> jle`: they were actually quite useful for modifying one field of several without boilerplate that keeps changing
10:22:50 <yitz> nh2: agreed. no i don't see it in transformers.
10:23:20 <edwardk> nh2: transformers wags the tail of mtl, so if you get ross to add it to transformers you can see it through mtl
10:23:59 <edvo> Does anyone know an easy way to do some kind of type case with DataKinds? For example, if I have data Tagged (t :: Tag) = Tagged Int with data Tag = A | B and DataKinds and I want something equivalent to val :: Tagged t; val = Tagged $ case t of {A -> 0; B -> 1}. Is that possible?
10:25:22 <nh2> edwardk: do you see something obvious against such a proposal or should I do it?
10:26:59 <edwardk> edvo: use tagged and reflection, then use Reifies s Tag => Tagged s Int -- then you can use 'reflect' to lower the 's' from the type level to the term level
10:27:32 <edwardk> and you can make instance Reifies A Tag where reflect _ = A; instance Reifies B Tag where reflect _ = B
10:28:07 <edwardk> then you can reify A $ ... to work with a type that will reflect down to A in here.
10:28:23 <edwardk> nh2: its plausible anyways
10:29:36 <yitz> nh2: go for it
10:31:35 <edvo> edwardk: thank you! the next problem is, i have valA :: Tagged A and valB :: TaggedB and I want val' :: Tagged t; val' = case t of A -> valA; B -> valB. With your suggestion, this would be case reflect t of , but that does not type-check
10:32:10 <edwardk> you can't have that
10:32:14 <edwardk> types get erased
10:32:24 <edwardk> you _can_ have vl
10:32:35 <edvo> what is vl?
10:32:37 <edwardk> val' :: Reifies s Tag => Tagged s
10:32:49 <edwardk> a premature hitting of enter ;)
10:32:55 <edvo> ok^^
10:33:05 <edvo> and how would val' look like?
10:33:43 <edwardk> you'd need to use ScopedTypeVariables and lots of black magic
10:33:52 <edwardk> are you determined to go down this path?
10:34:04 <edwardk> val' :: forall s. Reifies s Tag => Tagged s -- using your Tagged
10:34:14 <benzrf> hello haskellers
10:34:29 <edwardk> val' = case reflect (Proxy : Proxy t) of A -> valA; B -> valB
10:34:46 <benzrf> is there a non-ugly way to lift an operator over 2 args?
10:35:01 <benzrf> liftA2 foo bar baz is ok, just 1 extra liftA2
10:35:10 <benzrf> but liftA2 (+) something something else is ugly
10:35:49 <edvo> edwardk: ok, but that does not type-check, because valA and valB don't even have the same type
10:36:37 <edvo> by lowering t to the term level, the compiler lost the information, that t ~ A
10:36:43 <edvo> or t ~ B
10:37:11 <yitz> benzrf: why?
10:37:15 <ReinH> benzrf: nope, unless you could idiom brackets with template haskell
10:37:43 <yitz> benzrf: you can write (+) <$> something <*> something
10:37:53 <ReinH> *count
10:37:57 <jle`> there's that <**> stuff
10:38:05 <Iceland_jack>     [i| bar + baz |]
10:38:30 <ReinH> s/template haskell/quasi quoting
10:38:42 <jle`> > Just 1 <**> pure (+) <*> Just 5
10:38:43 <lambdabot>  Just 6
10:38:54 <ReinH> eww
10:39:03 <jle`> but i would probably do the (+) <$> x <*> y
10:39:55 <jle`> it brings me back to my schemey days
10:40:03 <ReinH> if you're talking about numeric operators then you can make Num b => a -> b an instance of Num
10:40:05 <jle`> lispy
10:40:12 <ReinH> which is both wonderfully clever and maybe not a great idea for every use case
10:40:19 <sm> hledger-web depends on language-javascript, which requires happy 1.19+ to install, so I've added "build-tools: happy >= 1.19" to library and executables in hledger-web.cabal. But it's having no effect. Any tips ?
10:41:03 <yitz> sm: no build-depends?
10:41:08 <yitz> *not
10:41:20 <ReinH> then you can say e.g. `average = sum / length' instead of `average = (/) <$> sum <*> length'
10:41:57 <sm> I don't think I should be build-depending on tools like happy ? It's not a library
10:42:31 <edwardk> edvo: yeah that is a whole other problem
10:42:43 <sm> I guess build-tools: is enforced only when installing the top-level package, not it's dependencies. I need to get that added directly to the language-javascript package.
10:42:56 <jle`> on that level you might as well do instance (Applicative f, Num b) => Num (f b)
10:42:56 <edwardk> edvo: ok, scrap that approach. it is a mess ;)
10:42:59 <jle`> (does that work)
10:43:18 <jle`> a + b = (+) <$> a <*> b
10:43:39 <benzrf> jle`: seems hacky to me
10:43:51 <yitz> sm: interesting. there should be a way to do that using cabal. like constraints. maybe propose something.
10:43:51 <jle`> fromInteger = pure . fromInteger
10:44:05 <bitemyapp> I can judge how hacky things are by how contorted my face is.
10:44:07 <jle`> abs = fmap abs, (*) = liftA2 (*)
10:44:30 <jle`> well we are talking about a Num instance for Num b => a -> b   >_>
10:44:41 <jle`> might as well go all the way
10:44:46 <ReinH> it's pretty nice if you do a lot of that sort of thing
10:44:49 <bitemyapp> mmmmm magma
10:45:00 <yitz> bitemyapp: I can judge how hacky things are by how contorted my coworkers are.
10:45:43 <jle`> actually doesn't an applicative instance cover all the non-standard num instances out there
10:46:11 <ReinH> jle`: http://hackage.haskell.org/package/applicative-numbers
10:46:18 <edvo> edwardk: actually this is solvable with a helper type class and FlexibleContexts like so: class Helper (x :: Tag) where { helper :: Proxy x -> Tagged t }, data Proxy (t :: Tag) = Proxy, instance Helper A where helper _ = valA, instance Helper B with helper _ = valB and finally val' :: forall t. Helper t => Tagged t; val' = helper (Proxy :: Proxy t)
10:46:22 <edvo> but this is very ugly
10:46:41 <ReinH> jle`: you still need some boilerplate
10:46:42 <edvo> for each such values, you have to create another type class
10:46:54 <edvo> and you have a useless constraint, which is always fulfilled
10:46:54 <sm> yitz: build-depending on happy 1.19 as you suggest does seem to work, however. Though maybe only through luck that cabal chose to install happy before language-javascript.
10:47:09 <edwardk> edvo: yep. hence wy i was trying to steer you towards finding another approach ;)
10:47:38 <edwardk> my experience with data kinds is they are rarely worth the pain
10:47:42 <yitz> sm: wow. that seems very wrong. i really thing you should bring this up with the cabal team.
10:48:17 <sm> yitz: ok, I'll go and mention it on #hackage at least
10:48:34 <yitz> edwardk: what do you think would need to be added to make them more useful?
10:48:43 <yitz> sm: you just did
10:49:25 <SaBer> is there really no function like "rotate i xs = (drop i xs) ++ (take i xs)" in the standard libraries?
10:49:33 <sm> oh, but installation failed when it got to the top-level package, with cabal: InstallPlan: internal error: configured package depends on a non-library package
10:50:11 <monochrom> rotate is not in standard prelude. that's right.
10:50:20 <monochrom> or standard libs
10:50:40 <SaBer> I find it a very commonly used operation...
10:51:07 <monochrom> I agree it's pretty common for the first few weeks of learning haskell
10:51:20 <jle`> it doesn't really sound like something i would use lists for
10:51:40 <jle`> maybe another data type might be more suitable
10:52:37 <silasm> https://en.wikipedia.org/wiki/Circular_buffer
10:52:39 * hackagebot country-codes 0.1 - ISO 3166 country codes and i18n names.  http://hackage.haskell.org/package/country-codes-0.1 (JeanPhilippeMoresmau)
10:53:07 <SaBer> yeah a ringbuffer would be smarter, sometimes you just don't really need the performance
10:53:21 <silasm> ^ on that note, how would one implement a circular buffer in haskell? I thought about STArrays, but I feel like you could do it more elegantly than that.
10:53:21 <merijn> dcoutts: Can I import modules from one of my build-depends in Setup.hs?
10:53:38 <monochrom> I would use an array as well
10:54:15 <SaBer> rotateOnFirst :: (a -> Bool) -> [a] -> [a] -- something I use a lot in another language...
10:54:20 <yitz> you can use Data.Sequence
10:54:33 <mietek> Any idea why even with --disable-shared, cabal is still looking for "dyn" libraries?
10:54:34 <jle`> you probably use it in other languages on arrays
10:54:51 <mietek> This happens e.g. when compiling happstack-server-7.3.5
10:55:03 <jle`> but haskell lists have different use cases than arrays
10:55:05 <yitz> SaBer: if the buffer is immutable you can use tie the knot
10:55:14 <merijn> mietek: Does happstack use TH? I vaguely remember TH needing dynamic libs
10:55:14 <monochrom> mietek: which cabal-install version and ghc version?
10:55:25 <merijn> (in GHC 7.8, that is)
10:55:26 <mietek> monochrom: 1.20.0.0, 7.8.2
10:55:29 <silasm> jle`: well in other languages in which you have arrays it's probably better to just maintain start and end pointers rather than actually shifting data anyways.
10:55:31 <mietek> merijn: interesting, thanks
10:55:47 <monochrom> then it's what merijn says. it is true of 7.8
10:56:11 <mietek> That's vaguely annoying
10:56:12 <monochrom> don't disable shared. ghci and TH need it
10:56:46 <mietek> monochrom: what about deployment?
10:56:57 <mietek> Does TH need it only at compile time?
10:57:03 <merijn> mietek: Yes
10:57:04 <monochrom> yes
10:57:06 <mietek> OK
10:57:17 <mietek> Thanks, that's very helpful
10:57:33 <merijn> mietek: You can build static binaries just fine, but if you disable shared libraries globally then TH stuff and ghci break
10:57:42 <monochrom> you can also go back to 7.6, then there is no shared lib requirement :)
10:58:04 <edwardk> yitz: not sure, but my experence with them is when i bring them into a project everything gets 20x more verbose and the code becomes a lot harder to explain
10:58:36 <merijn> mietek: I'd say the best workflow is to just leave shared enabled for everything (afaik GHC builds both shared *and* static libs when you do) and then just specify you want a static binary whenever you're compiling whatever you plan to deploy
10:58:54 <yitz> edwardk: they're fine for trivial uses. but i guess then they're just there to be cute.
10:58:58 <mietek> merijn: I'm also trying to trim the number of libraries GHC keeps
10:59:17 <mietek> Trimming *.dyn_hi and *HS*.so appears no longer viable in 7.8
10:59:56 <monochrom> if you want to trim, trim the static libs and go fully dynamic :)
11:00:02 <mietek> hm
11:00:05 <monochrom> "if you can't beat them, join them" :)
11:00:39 <mietek> It's nice being to able to deploy just a single binary
11:00:39 <monochrom> you can also go back to 7.6, if you want pure static libs
11:00:51 <mietek> Acknowledged
11:00:58 <mietek> I'd like to support both
11:01:01 <yitz> monochrom: dynamic is a real pain when trying to deploy to customers. especially on linux.
11:01:28 <mietek> yitz: I'm hoping to improve the deployment situation a little
11:02:28 <mietek> merijn: are you saying if I build libraries with "shared: False", they won't be available in ghci?
11:03:02 <brettweavnet> doing my first JSON encoding / decoding for a CLI which accesses a rest API.  Any recommendations on the best approach?  Aeson vs Text.JSON?
11:03:30 <merijn> mietek: I'm not entirely sure of all the details, I recommend checking the 7.8 release notes for details
11:03:31 <monochrom> actually I haven't tested it. that is, I haven't tested that cabal-install 1.20 really honours "shared: False"
11:03:51 <mietek> monochrom: it does, until it runs into TH
11:03:52 <monochrom> I think I now recall that it is honoured
11:04:56 <monochrom> at cabal-install 1.18 release time (yes, it began at 1.18 already), there was a message thread mentioning "now we have to tell people to not shared:False"
11:05:43 <eyebloom> Let's say I have a [Char] that I'd like to read from as a [Word8] without incurring an runtime penalty. How can I do that?
11:05:55 <mietek> At the same time, libgmp.a is still required, even though there's a perfectly nice libgmp.so.3
11:06:14 <merijn> eyebloom: ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ
11:06:30 <merijn> eyebloom: The answer is fortunately really easy: you can't
11:06:58 <Kaidelong> I need a runRVarT but with a flipped around type
11:07:04 <eyebloom> Really. I can't create a coercion somehow?
11:07:10 <monochrom> Char doesn't even have the same internal representation as Word8. there will be runtime penalty.
11:07:24 <merijn> eyebloom: Oh, you can create a coercion just fine, it's just very likely to segfault your program
11:07:50 <Kaidelong> basically a "(Lift n m, RandomSource m s) => (s -> m a) -> RVarT n a
11:07:53 <monochrom> I am not even sure it is called "penalty".
11:08:01 <Kaidelong> I have no idea how I can do this
11:08:36 <merijn> eyebloom: Why would you expect Char to be coercible to Word8?
11:09:12 <eyebloom> I'm translating a library from C where they consistently cast between the two.
11:09:27 <monochrom> between which two?
11:09:37 <mietek> eyebloom: have you considered ByteStrings?
11:09:39 <monochrom> C's char is not Haskell's Char
11:09:53 <merijn> eyebloom: C "char" is a byte (well, that's not true according to the standard, but ok), Haskell's Char is a unicode codepoint
11:10:36 <merijn> Hell, you shouldn't even assume you can coerce char to "word8" (i.e. uint8_t) in C
11:10:39 <merijn> That's still a bug
11:11:00 <eyebloom> unsigned char to signed char
11:11:16 <eyebloom> allocated as arrays
11:11:30 <d1323> actually it is  true, C standard defines a byte as a storage required to store one char.
11:11:49 <merijn> d1323: Yes, but the C standard doesn't define a byte to be 8 bits
11:11:52 <monochrom> I am doubtful of the point of "translate a library from C" to begin with. provide the same exported interface, sure. but why mimic the internal?
11:12:15 <eyebloom> Because I want to rewrite it.
11:12:16 <merijn> d1323: So for all *practical* purposes, assuming someone means "8 bit value" when they say "byte", C's char is not a byte
11:12:32 <monochrom> sure. rewrite it the Haskell way. not the C way.
11:12:52 <merijn> eyebloom: Why do you have a [Char] if you wanted [Word8] in the first place?
11:12:56 <n-dolio> I bet C isn't using linked lists.
11:13:05 <d1323> merijn, it is a C byte though, which has CHAR_BIT bits :).
11:13:05 <monochrom> (did you even read my "provide the same exported interface, sure"?)
11:13:18 <yitz> n-dolio: i bet c isn't using thunks
11:13:27 <eyebloom> I think I was confused about Haskell's internal representations.
11:13:30 <merijn> d1323: (FWIW, my old office had a machine where char was 32bit :)
11:13:36 <jle`> [Word8] isn't the same as an array of bytes either
11:13:42 <jle`> there is an array of bytes data type
11:13:44 <jle`> in haskell
11:13:59 <jle`> (but it's not [Word8])
11:14:19 <jle`> if you pick your encoding, you can turn a String into a ByteString, which you can turn into a [Word8].
11:14:29 <yitz> jle`: hint: it has an unpack function which *does* give you a [Word8]
11:14:33 <merijn> jle`: I'm guessing that he has a ByteString to begin with
11:14:46 <srhb> Mmm, unpack. So much badness in such an innocent word.
11:14:50 <merijn> But considering he hasn't said what exactly he's trying to do
11:14:51 <eyebloom> Of course the reason I want to rewrite it is to rewrite with higher order functions. But the first step is getting a working version in Haskell syntax.
11:15:07 <merijn> srhb: unpack is fine, Char8.unpack is the evil twin
11:15:20 <yitz> srhb: |:<
11:15:50 <srhb> What on earth does the different unpack do? I've only ever seen Char8.unpack used
11:16:03 <merijn> srhb: "unpack :: ByteString -> [Word8]"
11:16:06 <srhb> Ah.
11:16:11 <eyebloom> So what is the best representation for a signed byte?
11:16:16 <merijn> eyebloom: Int8
11:17:03 <merijn> srhb: Similarly the normal pack is "pack :: [Word8] -> ByteString"
11:17:16 <srhb> merijn: Yeah. Those are completely acceptable, for sure.
11:17:33 <yitz> > fromIntegral (200 :: Word8) :: Int8
11:17:34 <jle`> Char is a unicode codepoint, so it might not be the size of a byte
11:17:34 <lambdabot>  -56
11:17:50 <jle`> > ord (maxBound :: Char)
11:17:51 <eyebloom> If I'm comparing a haskell string (representing a tag in a binary file) to a list of bytes read from a file what is the simples way to do that?
11:17:51 <lambdabot>  1114111
11:18:13 <daimonos> Hi
11:18:17 <jle`> why can't you read the file as a string?
11:18:19 <monochrom> don't even use string for that tag
11:18:21 <jle`> hi daimonos
11:18:37 <monochrom> use an array or list of bytes
11:18:42 <jle`> oh yeah, if the tag is in a binary file, then don't use a string :|
11:18:58 <monochrom> hell. don't use string. end of story.
11:19:30 <monochrom> C's return : Haskell's return :: C's string : Haskell's string
11:19:30 <eyebloom> Because the library I'm translating sometimes looks as bytes as characters and other times as values.
11:19:32 <merijn> jle`: s/might not/definitely is not
11:19:41 <eyebloom> As you often find in C.
11:19:56 <monochrom> on the Haskell side stick with bytes
11:20:13 <yitz> eyebloom: what does the library do?
11:20:23 <eyebloom> Renders truetype fonts
11:20:50 <nesqi> How would I lift the List constructor [] so i can bind it with >>= ? What is the name of the function a -> [a], I trired "liftM [] x" but it did not work out.
11:20:50 <jle`> ad-hoc coercion is discouraged because haskell is a language where you can get maximum benefit from correctness in types at compile-time
11:21:08 <yitz> eyebloom: so these string/value things are field labels in the ttf file or something?
11:21:11 <jle`> nesqi: [] is a type constructor
11:21:13 <jle`> not a data constructor
11:21:18 <nesqi> Right
11:21:18 <jle`> you can't do [] 1
11:21:24 <eyebloom> yitz: Yes
11:21:24 <fizbin> What's the standard Haskell idiom for [Char] -> [Word8] via UTF8, and then also [Word8] -> [Maybe Char] ?
11:21:25 <jle`> but
11:21:28 <jle`> > (:[]) 1
11:21:30 <lambdabot>  [1]
11:21:32 <jle`> > return 1 :: [Int]
11:21:34 <lambdabot>  [1]
11:21:38 <jle`> > pure 1 :: [Int]
11:21:39 <lambdabot>  [1]
11:21:40 <jle`> etc.
11:21:47 <daimonos> I'm having some issues with Data.ByteString.Lazy.readFile in https://gist.github.com/urbanslug/11379782
11:21:50 <sm> public service announcement: anyone using build-tools: happy or alex should conditionalise that for GHC 7.8, like https://github.com/simonmichael/language-javascript/commit/29f6ddcfa430cd0b542f46326c1d5b27af951019
11:21:51 <merijn> nesqi: What are you trying to do? "pure :: Applicative f => a -> f a" and "return :: Monad m => a -> m a" both work
11:21:55 <eyebloom> But the file is treated as one big array of bytes.
11:22:07 <jle`> robot monkey operator is fun to use for its own sake though :)
11:22:11 <yitz> eyebloom: and you want those labels to be readable (as ascii) by a human reading your program, but really be bytes?
11:22:25 <monochrom> fizbin: there are some encoders and decoders in these packages: utf8-string, encode. there are others. pick one.
11:22:29 <nesqi> os (:[]) is the trivial function a -> [a] ?
11:22:30 <yitz> eyebloom: that is the one legitimate use case for Data.ByteString.Char8.
11:22:55 <eyebloom> yitz: Ok I'll look into that.
11:22:57 <monochrom> no no, why even go through Char?
11:23:07 <yitz> monochrom: that's not Char
11:23:14 <jle`> nesqi: have you ever used (:) before?
11:23:18 <nesqi> no
11:23:32 <nesqi> Oohh... haha.. yes i have =)
11:23:36 <monochrom> then just use Data.ByteString
11:23:37 <jle`> [1,2,3] is syntactical sugar for 1:(2:(3:[]))
11:23:37 <nesqi> now i get it
11:23:43 <yitz> monochrom: eyebloom wants string literals in the source code that really represent bytes, not characaters. that's exactly what D.BS.C8 is.
11:23:53 <jle`> > \x -> x:[]
11:23:55 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
11:23:55 <lambdabot>    arising from a use of ‘M702177665266543087729119.show_M7021776652665430877...
11:23:55 <lambdabot>  The type variable ‘a0’ is ambiguous
11:23:55 <lambdabot>  Note: there are several potential instances:
11:23:55 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
11:24:07 <nesqi> jle`: right, thanks
11:24:10 <monochrom> don't even use string literals. that's my opinion.
11:24:11 <jle`> mk
11:24:18 <ziman> that's quite a number there
11:24:50 <eyebloom> I could just translate these ascii tags in lists of bytes or bytestrings.
11:25:00 <yitz> monochrom: how do you make the code readable? write the labels in comments? that's fragile. make them text and codec them at runtime? that's ugly.
11:26:37 <yitz> monochrom: i guess you could write TH code that converts Text to ByteString at compile time. but that's more or less what D.BS.C8 is.
11:28:02 <NemesisD> hey folks. this is kind of a more math/algorithm question but here it goes. i'm trying to write a function to find a weighted median. it looks like http://lpaste.net/103319
11:28:13 <eyebloom> Thanks for your help, hopefully I'll have something working by the end of the week that I'll add to hackage.
11:28:17 <monochrom> I just write like [0x54, 0x49, 0x46, 0x46] and be done with it
11:28:59 <NemesisD> this is as naive of an implementation as it goes, it uses the weight of each element and just generates that many instances of the element in the list, then takes the regualr mean. the problem is that for relatively large weights this becomes really expensive (i.e. my quickcheck tests take forever). can anyone think of a better way?
11:30:07 <jle`> you can sum the weights up, and pull items until the combined weight of what you have taken is half of the total weight
11:30:43 <NemesisD> jle`: what ordering would i have to apply to the input list beforehand?
11:31:05 <jle`> oh you'd have to sort on the element
11:31:06 <mietek> merijn, monochrom: have you seen "libgmp.a(mp_set_fns.o): relocation R_X86_64_32 against `__gmp_default_allocate' can not be used when making a shared object; recompile with -fPIC" when bootstrapping cabal-install?
11:31:19 <mietek> I'm pretty sure using --disable-shared makes this go away
11:31:45 <mietek> I thought this was because I only had a 64-bit libgmp.a, so I added a 32-bit one to LIBRARY_PATH, but nope
11:32:15 <mietek> (This is apparently a long, long-standing bug in libgmp)
11:32:18 <jle`> this way oyu do no indexing, which is what lists are bad at
11:32:24 <monochrom> "relocation R_X86_64_32" means trying to code built without -fPIC in shared libs. this is forbidden. *.a's are built without -fPIC
11:32:43 <jle`> well, one of the things lists are bad at :)
11:33:20 <mietek> monochrom: so... why is this attempted during a bootstrap of cabal-install?
11:33:39 <mietek> dcoutts_: ping?
11:33:57 <monochrom> what OS is this on?
11:34:10 <mietek> Ubuntu 10.04 LTS
11:34:16 <benzrf> 10.04?
11:34:19 <benzrf> that's hella old o-O
11:34:24 <mietek> Hence the L
11:34:38 <Forgetaboutit> Hey guys, I have a bit of an conceptual question.  I am planning to build a web application backed by acid-state.  What's the Haskell-y way to implement m:n relations between records?
11:35:23 <monochrom> I have not run into ghc using libgmp.a
11:35:31 <mietek> Really?
11:35:45 <vanila> isn't that how it handles Integer?
11:36:02 <mietek> monochrom: it is required to bootstrap cabal-install 1.20.0.0
11:36:26 <monochrom> I don't think I can reproduce it
11:37:00 <merijn> Forgetaboutit: If you want a relational database I would recommend not using acid-state, it is not a relational database
11:37:23 <jle`> in other words, forget about it!
11:37:39 <mietek> monochrom: without libgmp.a, building Cabal-1.20.0.0 fails with
11:37:44 * hackagebot mangopay 1.5 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.5 (JeanPhilippeMoresmau)
11:37:45 <mietek> /usr/bin/ld: cannot find -lgmp
11:37:46 * hackagebot yesod-mangopay 1.5 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.5 (JeanPhilippeMoresmau)
11:38:13 <mietek> monochrom: that's the first step in the bootstrapping of cabal-install-1.20.0.0
11:38:35 <monochrom> this may be so full of XY problems
11:38:46 <Forgetaboutit> merijn: I want to store an object graph;  I would like to avoid RDBMS because storing sum types gets really hairy ...
11:39:03 <mietek> But that's fine, as I can make libgmp.a available!  But then, the next step is building cabal-install, and *that* fails with the -fPIC error
11:39:10 <monochrom> you're on ubuntu 10.04 which was still with gmp 3. but ghc 7.8 has moved on to gmp 10. unless you use the one built for centos
11:39:22 <mietek> But that's fine, as I can make it go away with --disable-shared!  But then, you and merijn said ghci may be hosed...
11:39:33 <mietek> monochrom: I am indeed using the one built for centos
11:39:45 <Forgetaboutit> jle`: no :(
11:40:00 <monochrom> well ok you're on a platform I don't understand or even condone.
11:40:35 <cschneid> How do I go about rewriting this so the fmap isn't so intrusive? If json were :: String, it'd just be `json ^.. lenslenslens` - but the fmap makes it uglier. https://gist.github.com/cschneid/0b93cc699edb076b84b0
11:40:52 <mietek> Well, is the platform the cause of cabal-install attempting to build a shared library using a static library?
11:40:56 <bennofs> mietek: GHC links dynamically to libgmp by default I think, so you should have libgmp.so, not .a
11:41:19 <mietek> bennofs: that's another issue, and yes, I do have libgmp.so
11:41:32 <yitz> Forgetaboutit: can you represent your m:n relationship using haskell types? won't acid state then serialize that for you?
11:42:11 <monochrom> I don't know about cause. but I know about empirical correlations. ubuntu 13.10, non-centos ghc does not reproduce the problem.
11:42:20 <merijn> Quick check: The report haskell source files are UTF8, right?
11:42:35 <merijn> s/report/report mandates/
11:43:13 <benzrf> hmm, lenses are basically instances of functor arent they
11:43:36 <zerokarmaleft> wtf...Data.Bifunctor.Clown and Data.Bifunctor.Joker? color me intrigued
11:43:43 <haasn> benzrf: No, not at all
11:43:51 <yitz> merijn: does it really mandate an encoding? i thought it just says unicode.
11:43:53 <haasn> Lenses are values, values are not instances of type classes
11:44:03 <Forgetaboutit> yitz: I thought about having a type RelationAB which stores one of A and one of B.  Storing some collection of RelationAB would allow to get either an A or a B out of it.  I was just wondering if there are some Haskell-y patterns for this case ...
11:44:29 <monochrom> bootstrap.sh has finished successfully
11:44:48 <merijn> yitz: Ah, bollocks, you're right
11:44:52 <cschneid> `json <&> (^.. key "books" . values . key "title")` -- that's as close as I can get to make this code a bit closer to the pure version. (json :: IO String). Is there a way to get rid of the fmap entirely here? I figure not, since I'm working in IO
11:44:55 <bennofs> haasn: well, but at least setters are like fmap but given a name
11:45:01 <mietek> monochrom: well, thanks for checking.  On second thought, bootstrapping cabal-install with --disable-shared ought not to break anything, as I'll get rid of the intermediate libraries anyway.
11:45:02 <cschneid> I suppose it'd be cleaner if this were part of a do block
11:45:13 <monochrom> now I have to delete what it has installed
11:45:14 <triliyn> cschneid: there's probably an fmapped lens
11:45:31 <bennofs> haasn: so you could see them as "instances" of Functor that you explictly pass around. :)
11:45:34 <haasn> bennofs: Not all setters
11:45:35 <cschneid> triliyn: right - I gisted earlier. I'm playing with aeson in ghci - read a file in via `readFile`, so obviously IO.
11:45:44 <haasn> bennofs: You might as well pass around “fmap”
11:45:48 <haasn> But yeah
11:46:00 <cschneid> triliyn: just a bit sad that it entirely changes the syntax from just  `json ^? key "fjdkl"` to trickery with fmap
11:46:31 <haasn> :t fmapOf
11:46:32 <lambdabot>     Not in scope: ‘fmapOf’
11:46:32 <lambdabot>     Perhaps you meant one of these:
11:46:32 <lambdabot>       ‘imapOf’ (imported from Control.Lens),
11:46:35 <haasn> Aw :(
11:46:39 <merijn> yitz: Does GHC at least mandate utf8? (I have a preprocessor and need to know which encoding to use for files, I'm guessing just "utf8 only" is the most sensible)
11:46:44 <haasn> :t mapOf
11:46:45 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
11:46:57 <bennofs> :t mapped
11:46:57 <lambdabot> (Settable f1, Functor f) => (a -> f1 b) -> f a -> f1 (f b)
11:47:00 <yitz> merijn: i think you're correct
11:47:23 <supki> :t (^!! acts.ix "books" . folded . ix "title")
11:47:24 <lambdabot> (Ixed m1, Ixed a, Foldable f, Monad m, Index m1 ~ [Char], Index a ~ [Char], IxValue a ~ f m1) => m a -> m [IxValue m1]
11:47:38 <yitz> merijn: well, the IO system uses the current locale actually. ghc uses that to read your module files, doesn't it?
11:47:38 <NemesisD> is ScopedTypeVariables the extension where type variables in a function's type declaration refer to the same variables in a where clause?
11:47:45 * hackagebot hsoptions 1.0.0.0 - Haskell library that supports command-line flag processing  http://hackage.haskell.org/package/hsoptions-1.0.0.0 (josercruz01)
11:47:45 <bennofs> NemesisD: yes
11:47:57 <n-dolio> But only if explicitly quantified.
11:48:38 <yitz> merijn: and if so, that's actually kind of ugly. your program might have different meanings depending on where you are located.
11:49:01 <n-dolio> Also, a lens is not an instance of Functor.
11:49:05 <benzrf> haasn, bennofs: that's what i meant
11:49:13 <benzrf> i forgot you can use lenses as getters
11:49:19 <benzrf> it's been a while since i used em >.>
11:50:33 <n-dolio> It is more like an instance of a class that doesn't exist, which would be Traversable except with the Applicative constraint replaced by Functor.
11:51:02 <n-dolio> Except that doesn't cover everything, either.
11:51:07 <merijn> yitz: The mailing list implies that GHC mandates UTF8, but silently ignores non-utf8 in comments
11:53:15 <edwardk> triliyn: there is 'mapped' and 'over'
11:58:38 <yitz> merijn: yeah just tested it. my string literal was interpreted as utf-8 both at compile time and run time independently of my current locale.
11:58:51 <haasn> :t (^!!) -- I wonder if this could help cschneid
11:58:52 <lambdabot> Monad m => s -> Acting m [a] s a -> m [a]
11:59:34 <cschneid> haasn: used how?
11:59:50 <cschneid> I'm fairly rough on the lens types
12:00:07 <yitz> merijn: didn't try comments. but you'd have to define what "silently ignores" means. drops bytes one at a time that would create invalid utf-8, until it starts getting utf-8 again?
12:00:10 <haasn> I don't actually know. Let me figure it out
12:00:17 <merijn> btw, it seems odd that Parsec has no combinators for parsing Text...
12:00:25 <yitz> merijn: that could do weird things like ending comments in the wrong place
12:00:38 <pranz> haasn: what is Acting a synonym for?
12:01:21 <merijn> yitz: I think it just means that after a comment starts it just scans and ignores bytes until it finds the UTF8 representation of a comment end (for block comments) or newline (for line comments)
12:01:51 <haasn> > runIdentity $ return "Hello world"^!!acts.folded.from enum -- cschneid
12:01:53 <lambdabot>  [72,101,108,108,111,32,119,111,114,108,100]
12:02:05 <haasn> Use “acts” to get inside the result of a monadic action
12:02:11 <yitz> merijn: even if, say, that newline is in the middle of a valid utf-8 sequence that is not a newline? i doubt it.
12:02:17 <haasn> Run the resulting monadic fold with (^!!)
12:02:25 <cschneid> haasn: sweet
12:02:31 <haasn> pranz: LensLike with Effect m r -- or something
12:02:35 <cschneid> λ json ^!! acts . key "books" . values . key "title"
12:02:38 <cschneid> :t acts
12:02:39 <lambdabot> (Effective m r f, Conjoined p) => p a (f a) -> p (m a) (f (m a))
12:02:39 <yitz> oh wait
12:02:47 <cschneid> yep. that makes sense.... :)
12:02:54 <haasn> cschneid: does it work? :)
12:02:55 <yitz> newline can't occur at all except as a newline. ok.
12:03:03 <cschneid> haasn: it did, yes. The type sig never would have let me figure that out :)
12:03:15 <haasn> Great!
12:03:24 <haasn> acts :: IndexPreservingAction m (m a) a
12:03:26 <merijn> yitz: Dunno
12:03:53 <haasn> Which is something like a Getter (m a) a -- except that we're inside the m monad
12:04:01 <yitz> merijn: every byte of a multi-byte utf-8 character has its high-order bit set.
12:04:04 <haasn> and, well, it's indexpreserving.
12:04:32 <cschneid> haasn: I need to spend a few good evenings with a bottle of wine and the lens type classes.
12:04:44 <haasn> I do it with a cup of tea
12:04:46 <yitz> merijn: so '\n', '-', and '}' always represent themselves when they occur as bytes in valid utf-8.
12:05:36 <cschneid> I wish somebody would just pay me to write haskell so I could do it on a company's dime
12:05:48 <cschneid> (says the guy taking a long lunch to hang out in #haskell)
12:05:50 <haasn> I wish somebody would just pay me to provide lens support in #haskell
12:05:55 <yitz> cschneid: if that doesn't work, try whisky.
12:06:29 <cschneid> :t ^!!
12:06:30 <lambdabot> parse error on input ‘^!!’
12:06:34 <cschneid> :t (^!!)
12:06:35 <lambdabot> Monad m => s -> Acting m [a] s a -> m [a]
12:06:40 <mietek> Any idea why binaries in both GHC 7.6.3 and 7.8.2 are distributed without having done a strip --strip-unneeded on them?
12:06:46 <cschneid> :t (^..)
12:06:47 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
12:07:00 <benzrf> what the hell is Acting
12:07:35 <cschneid> so ^!! works on a different monad? Trying to change my working json code to use `^..` instead, I get a "Couldn't match type `Identity` with `IO`" error
12:08:03 <cschneid> in this case, it and `acts` pulls it into IO?
12:08:18 <haasn> I'm not sure how to interpret that question. (^..) is for pure folds
12:08:24 <haasn> (^!!) is for monadic folds
12:08:37 <haasn> that is, we live inside ‘m’ and the final result is m [a]
12:08:51 <haasn> In a way, (^..) is like (^!!) but inside Identity
12:08:58 <haasn> it's like map vs mapM
12:09:00 <haasn> Not sure what you're asking
12:09:05 <cschneid> haasn: exactly, yeah
12:09:52 <pranz> there should be a lensopedia
12:10:08 <cschneid> pranz: please write that for me. :)
12:12:39 <pranz> cschneid: if only I could ;)
12:12:48 * hackagebot type-unary 0.2.15 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.2.15 (ConalElliott)
12:12:50 * hackagebot language-javascript 0.5.13 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.13 (AlanZimmerman)
12:16:03 <Guest52392> man, are the classes in purescripts prelude better for purescript, or just better?
12:16:20 <Guest52392> they seem to have rethought haskells standard classes
12:19:24 <jle`> Guest52392: well they have the advantage of building on 20 or so years of haskell growing pains
12:19:55 <Guest52392> i was wondering if thats all it is, or if its somehow better for the javascript environment
12:28:04 <mietek> monochrom: how about just bootstrapping cabal-install-1.20.0.0 with ghc-7.6.3?
12:28:12 <monochrom> that works
12:28:21 <mietek> monochrom: this fails for me with "Setup: /usr/bin/ar: permission denied"
12:28:37 <mietek> Ah, this is without Cabal-1.20.0.0 installed
12:29:08 <mietek> The bootstrapping fails at the moment of linking Setup for Cabal-1.20.0.0
12:31:44 <SrPx> Hello, is there a standard function to remove nodes in a tree? Say, data Tree = Node Int | Branch Tree Tree ? Or at least a simple, compact and fast way to express this?
12:32:09 <haasn> remove?
12:32:16 <SrPx> haasn: I want a copy of the tree without duplicates
12:32:44 <haasn> fromList . nub . toList?
12:32:51 <SrPx> so (T (T (N 1) (N 2)) (T (N 1) (N 3)) becomes (T (T (N 1) (N 2)) (N 3)) using shorts
12:32:58 <SrPx> haasn: let me see!
12:33:37 <haasn> Your requirements are not clear to me. Maybe you want a Set instead, if you want to avoid duplicates?
12:33:48 <haasn> Or some sort of ordered tree
12:37:03 <TallerGhostWalt> If I fork a process and change the working directory, does it change it for the main thread too?
12:39:06 <SrPx> It is just what I said, I have a datatype such as "data T = B T T | N Int" and I want an algorithm to eliminate identical nodes across the tree. So (B (B (N 1) (N 2)) (B (N 1) (N 3))) becomes (B (B (N 1) (N 2)) (N 3)). I can't use another datatype as this the actual form of the data, it is used in other algorithms. Just for this case (cleaning identical non-deterministic computations) it would be nice to remove those duplicates.
12:40:28 <edvo> edwardk: I actually found a solution with GADTs, which only requires one GADT and type class per tag type. There is still the always fulfilled constraint. If you want to have a look, I created a gist: https://gist.github.com/anonymous/4048a367420d140fc9e3
12:42:14 <stelleg> SrPx: I think haasn's solution is good then, assuming you don't need to retain structure in some predefined way as you remove nodes
12:42:43 <haasn> SrPx: I guess I'd hand-roll one at this point; traverse over the tree while keeping a set of all seen elements or something
12:42:52 <SrPx> nah I don't, Im trying to find what those fromList nub and toList are ^^
12:43:06 <haasn> That is, if you want to avoid losing structure
12:43:08 <FireFly> @ty (^!!)
12:43:09 <lambdabot> Monad m => s -> Acting m [a] s a -> m [a]
12:43:18 <FireFly> Hm
12:43:21 <haasn> If you don't care about structure, I would write my own “toSet” and “fromSet”
12:43:21 <merijn> TallerGhostWalt: You first mention fork a process and then refer to threads, this does not compute
12:43:32 <FireFly> @info Acting
12:43:32 <lambdabot> Acting
12:43:40 <FireFly> Why, thanks!
12:43:47 <haasn> like foldrMyTree Set.insert Set.empty and then foldrSet MyTree.insert MyTree.empty
12:43:52 <merijn> FireFly: There is no @info, it's autocorrecting to @echo
12:43:58 <FireFly> Oh
12:44:04 <zipper> I asked a question a short while before my network went down. I didn't get an answer. I'll ask again.
12:44:07 <zipper> I'm having some issues with Data.ByteString.Lazy.readFile in https://gist.github.com/urbanslug/11379782
12:44:21 <merijn> zipper: That's not a question, that's a statement :)
12:44:22 <FireFly> merijn: wait, that has an edit distance of 3, I thought it only did up to 2
12:44:47 <haasn> merijn: @undo
12:44:50 <FireFly> ah
12:44:55 <haasn> @help echo
12:44:55 <lambdabot> echo <msg>. echo irc protocol string
12:44:56 <merijn> ah
12:45:11 <merijn> @undo Acting
12:45:12 <lambdabot> Acting
12:45:15 <merijn> There you go :)
12:45:15 <FireFly> @help info
12:45:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:45:21 <edwardk> edvo: http://hackage.haskell.org/package/ad-4.2.0.1/docs/src/Numeric-AD-Internal-Or.html#Or uses a very similar approach
12:45:23 <haasn> @info do { x <- foo; bar x }
12:45:23 <lambdabot> foo >>= \ x -> bar x
12:45:32 <FireFly> Aw, if only it did the fuzzy matching on @help as well..
12:45:40 <haasn> That would actually be useful
12:46:04 <pranz> @list
12:46:05 <lambdabot> What module?  Try @listmodules for some ideas.
12:46:12 <pranz> @help list
12:46:12 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
12:46:25 <zipper> merijn: I asked the question
12:46:35 <benzrf> @info sdfsdf
12:46:35 <lambdabot> sdfsdf
12:46:38 <benzrf> @info do
12:46:38 <lambdabot> <unknown>.hs: 1: 3:Parse error: Last statement in a do-block must be an expression
12:46:40 <benzrf> ??
12:46:50 <benzrf> @info do 3
12:46:50 <lambdabot> 3
12:46:57 <benzrf> wtf does @info do
12:47:08 <FireFly> Gets corrected into @undo
12:47:11 <merijn> zipper: I don't see a question, I see a statement ("I'm having some issues with..." and some code)
12:47:16 <FireFly> (see above)
12:47:20 <iamnot> I know that this is probably not the right place to ask, but can someone tell me how to convert Ints to Doubles in Haskell? Just cant find it..
12:47:20 <benzrf> aha
12:47:31 <merijn> zipper: I'm not psychic, if you don't ask a question what kind of answer do you expect?
12:47:41 <merijn> iamnot: fromIntegral
12:47:45 <mmachenry> iamnot: fromIntegral
12:47:50 <benzrf> @echo sdf
12:47:50 <lambdabot> echo; msg:IrcMessage {ircMsgServer = "freenode", ircMsgLBName = "lambdabot", ircMsgPrefix = "benzrf!~benzrf@198.23.200.81", ircMsgCommand = "PRIVMSG", ircMsgParams = ["#haskell",":@echo sdf"]} target:#haskell rest:"sdf"
12:47:53 <benzrf> o=
12:47:59 <haasn> iamnot: Why would this not be the right place to ask?
12:48:03 <merijn> @quote who.do.you.call
12:48:04 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
12:48:07 <iamnot> wow thanks for the fast reply :)
12:48:09 <bennofs> @ty fromIntegral
12:48:09 <lambdabot> (Num b, Integral a) => a -> b
12:48:52 <felixn> how do I lift a function into a monad?  (a -> b) -> (m a -> m b)  trying to >>= (intercalate "\n") but obviously intercalate doesn't return a monad..
12:49:01 <merijn> felixn: fmap
12:49:05 <felixn> :O
12:49:07 <merijn> and/or liftM
12:49:11 <merijn> :t fmap
12:49:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:49:14 <pranz> every monad is a functor
12:49:17 <ion> @hoogle (a -> b) -> (m a -> m b)
12:49:17 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
12:49:17 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:49:17 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
12:49:19 <zipper> I'm having some issues with Data.ByteString.Lazy.readFile in https://gist.github.com/urbanslug/11379782
12:49:22 <zipper> merijn: ^
12:49:28 <merijn> zipper: Yes, I saw that
12:49:40 <merijn> zipper: How are we supposd to know what "some issues" means?
12:49:40 <ion> felixn: The type constructor “m” is a monad, a value of type “m a” is not.
12:49:41 <FireFly> That is still not a question. What kind of issues?
12:49:47 <merijn> zipper: There's no description, no error, nothing
12:50:14 <merijn> :t liftM
12:50:15 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
12:50:31 <merijn> felixn: But really, using fmap instead of liftM is almost always preferred
12:50:47 <FireFly> Why does liftM even exist?
12:50:49 <yitz> @type (<$>)
12:50:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:50:54 <pranz> @src liftM
12:50:54 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:50:58 <FireFly> Did Monad not initially require Functor?
12:51:01 <pranz> ...why
12:51:01 <merijn> FireFly: Because Functor is not a superclass of Monad
12:51:10 <merijn> FireFly: Monad *still* doesn't require Functor
12:51:11 <Cale> It is now!
12:51:13 <FireFly> Oh
12:51:13 <yitz> FireFly: liftM has existed for longer than Functor
12:51:14 <geekosaur> it still doesn't, that will be fixed next ghc release
12:51:15 <merijn> FireFly: That won't happen until 7.10
12:51:15 <FireFly> Right
12:51:30 <vanila> in theory monads are functors
12:51:32 <FireFly> I thought that it requried Functor but will require Applicative, or something
12:51:38 <Cale> right, in 7.10 :)
12:51:39 <FireFly> I haven't used Haskell enough :P
12:51:53 <Cale> FireFly: Applicative in turn requires Functor
12:51:54 <pranz> @src Monad
12:51:54 <lambdabot> class  Monad m  where
12:51:54 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
12:51:54 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
12:51:54 <lambdabot>     return      :: a -> m a
12:51:54 <lambdabot>     fail        :: String -> m a
12:51:54 <FireFly> Right, I thought it was Functor pre-7.10 and would get tightened, so to speak
12:51:59 <merijn> FireFly: It will require Applicative in 7.10, which automatically requires Functor as Functor is a superclass of Applicative
12:52:04 <FireFly> Right.
12:52:15 <yorick> can someone provide some hints to why http://sprunge.us/chRi?hs is running out of memory (my trie has 50k elements, and my c is 3)
12:52:17 <merijn> FireFly: Right now it has neither, hence everyone's frustration :)
12:52:18 <n-dolio> We still probably can't get rid of liftM, though.
12:52:25 <Cale> FireFly: But yeah, Haskell 98 for some stupid reason left out the superclass constraint
12:52:26 <n-dolio> Because it would just break tons of stuff.
12:52:28 <FireFly> That explains liftM then
12:52:32 <geekosaur> liftM = fmap -- done
12:52:36 <Cale> liftM is good though, even if we require the instance
12:52:45 <Cale> because it gives you an easy way to write that instance
12:52:46 <FireFly> For consistency?
12:52:48 <FireFly> Oh
12:52:50 <FireFly> Right
12:52:56 <shachaf> Like liftA
12:52:58 <FireFly> fmapDefault, Monad edition
12:53:10 <Cale> yes
12:53:14 <shachaf> But I wonder whether defaultFmapInTermsOfMonad should be a different function and liftM=fmap for efficiency.
12:53:20 <shachaf> Probably not because that would break things.
12:53:37 <Cale> I also would like to see us go back to having map = fmap
12:54:18 <bennofs> Cale: at least we get Foldable/Traversable into Prelude with GHC 7.10, I heard!
12:54:36 <n-dolio> shachaf: I bet there are quite a few 'fmap = liftM' definitions out there already.
12:54:38 <Cale> I like Traversable, but Foldable has always felt weird to me
12:55:41 <gamegoblin> do any of you folks know at about what size Data.Map has faster lookups than a list of [(key, value)] ?
12:56:03 <merijn> gamegoblin: Presumably almost any size
12:56:14 <Cale> gamegoblin: Maybe around 10?
12:56:22 <Cale> That's just a guess
12:56:24 <felixn> merijn: ion: thanks!  I'm ballin with <$> now
12:56:32 <gamegoblin> Hmm I’ll just do some tests
12:56:53 <shachaf> n-dolio: Right.
12:57:13 <Cale> I wouldn't be surprised if it were half that
12:57:18 <mmachenry> gamegoblin: Whenever the index of the element you're looking for is after log n of the size of the list you're likely to find it fast in a map.
12:57:26 <Cale> But I also wouldn't be too surprised (though a bit disappointed) if it were double
12:57:30 <merijn> ok, someone help me out with naming: Name for a preprocessor that generates FFI wrappers for C enums?
12:58:16 <benmachine> mmachenry: the constant factors are going to dominate at small sizes
12:58:23 <gamegoblin> mmachenry: I’m a bit suspicious of saying that exactly. I know all about O(lg n) access times but there is a constant factor involves
12:58:26 <felixn> ion: what is "m a" called?
12:58:41 <mmachenry> gamegoblin: It's kind of hard to answer the question, really. Do you understand the difference between the two data structures? It's probably important to. There's not really a specific size at which one or the other is faster. For example it you're always trying to access the first few elements of a list (say you're making a stack) lists will be better regardless of the data size.
12:59:29 <gamegoblin> mmachenry: yes, I very well understand them. I was just curious if anyone had measured the constant factor between them.
12:59:30 <oio> how can i make a type signature that requires the input to be two types at the same time?
12:59:45 <gamegoblin> oio: example of what you mean?
12:59:54 <mmachenry> benmachine: Sure constant factors matter, but you really should know what you're using the data structure for. Or, perhaps. if you're only looking for that point at which the constant factors are drowned out, I guess that's a different question.
12:59:58 <felixn> oio: Either a b?
12:59:59 <ion> merijn: A value of type “m a” where m is an instance of Monad can be called e.g. a monadic value.
13:00:03 <ion> Whoops
13:00:07 <ion> felixn: ↑
13:00:12 <felixn> ^_^
13:00:19 <felixn> †_†
13:00:35 <ion> _e_i_n
13:00:55 <shachaf> A good name is "action".
13:01:04 <oio> gameglobin: xxx:: (Int a, Integer a) => a -> Intensity
13:01:07 <shachaf> "monadic value" is a confusing name.
13:01:17 <merijn> shachaf: For a second there I thought you were answering my question and was very confused
13:01:20 <oio> felixn: maybe
13:01:21 <benmachine> shachaf: Conor McBride doesn't like the name "action" on account of how that's already a maths word
13:01:22 <gamegoblin> mmachenry: It’s just arbitrary key:value lookup. No particular ordering or frequency in lookups. So for large enough N, Data.Map will obviously perform better, but I suspect for small N, a list will perform better.
13:01:32 <FireFly> oio: but Integer is a type class and Int is a datatype--the two are different
13:01:38 <benmachine> shachaf: I do not necessarily endorse this view, but I think it's worth thinking about
13:01:41 <felixn> oio: it will allow either type into your function :D  then you can pattern match on Left/Right
13:01:41 <merijn> oio: That has several syntax errors, "Int a" is not something sensical
13:01:49 <jfischoff> shachaf: I sent kmc an email, inviting him to BayHac
13:01:51 <benmachine> shachaf: not only a maths word but the sort of maths that might actually come up
13:02:10 <n-dolio> shachaf: Action is also confusing. :)
13:02:24 <jfischoff> Wasserman too but he is going to be in Germany
13:02:24 <shachaf> benmachine: That's true, I suppose.
13:02:36 <benmachine> someone invented the term "mobit" for a value of type m a but I'm not sure it ever caught on
13:02:41 <gamegoblin> FireFly: Integer is a type, no?
13:02:42 <shachaf> did people just write six messages addressed to me
13:02:43 <shachaf> what is this
13:02:49 <n-dolio> See the big thread on reddit about monads being about sequencing.
13:02:49 <oio> i think i made a thought  mistake
13:02:58 <FireFly> shachaf: you're mr. popular today
13:03:00 <shachaf> n-dolio: That sounds like the sort of thread I'd rather not see.
13:03:04 <merijn> gamegoblin: I think FireFly confused Integer with the Integral typeclass
13:03:04 <n-dolio> :)
13:03:07 <oio> THANkS anyway
13:03:30 <FireFly> Oh. Oops, my bad
13:03:30 <benmachine> (there's an implicit Monad m => in what I just said)
13:04:11 <jfischoff> What other ex-Haskellers should I try to bring back into the fold?
13:04:16 <jfischoff> in the bay area that is
13:05:09 <benzrf> jfischoff: why into the fold, why not into the scan
13:05:11 <benzrf> :-D
13:05:23 <gamegoblin> benzrf: I was about to say “you should scan around to find some people”
13:05:27 <jfischoff> BayHac is looking to be a little crazy. Not sure what is going to happen if 150 people actually show up on saturday
13:05:37 <benzrf> gamegoblin: nice
13:06:04 <matheus23> I cannot "cabal install haddock", because it "cannot satisfy -package-id directory-*blah*"... How can I make cabal not pass the -package-id parameter?
13:06:59 <NemesisD> jle`: i wonder if you could take a look at my algorithm for weighted mean based on your recommendation and help me figure out what's wrong with it
13:07:47 <dmbarbour> Hello! I'm looking for some quick information about System.Plugins. I'm wondering how it interacts with garbage collection. I.e. if we load a value, but let it fall out of scope naturally, will the object code be unloaded?
13:08:21 <c_wraith> dmbarbour: before GHC 7.8, object code was never unloaded
13:08:49 <shachaf> jfischoff: I'd better start figuring out what to my lens thing soon.
13:08:52 <c_wraith> dmbarbour: I know that 7.8 will unload object code, but I'm unsure of exactly when
13:08:56 <dmbarbour> @c_wraith: never unloaded? System.Plugins does have an `unload` function.
13:08:56 <lambdabot> Unknown command, try @list
13:09:09 <shachaf> jfischoff: Since I'm apparently at the end of the day does that mean I can go over time if people are interested?
13:10:34 <dmbarbour> c_wraith: thanks for this information. I wonder if I'll need to use System.Mem.Weak to force `unload`, in this case.
13:10:59 <jfischoff> shachaf: No. There was scheduling mixup. We no longer have the classroom after 1
13:11:15 <jfischoff> oh wait
13:11:22 <jfischoff> forgot when you were going
13:11:25 <jfischoff> maybe
13:11:29 <jfischoff> I'll check
13:11:31 <c_wraith> dmbarbour: that function is about what's in scope, not what is in memory
13:12:03 <dmbarbour> c_wraith: So even `unload` won't help?
13:12:19 <c_wraith> dmbarbour: not before GHC 7.8
13:12:32 <dmbarbour> c_wraith: thanks. :(
13:12:55 * hackagebot find-conduit 0.4.1 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.4.1 (JohnWiegley)
13:15:05 <bennofs> c_wraith: even Linker.unload from GHC doesn't work?
13:16:41 <bennofs> c_wraith: I'm using the following code: http://lpaste.net/103321 does that not remove the module from memoryß
13:18:40 <c_wraith> bennofs: have you tried loading and unloading something in a loop? I'm pretty sure that before GHC 7.8, there's exactly no way to free memory allocated for object code.
13:19:29 <bennofs> c_wraith: maybe I should try that ... GHC is so hard to profile (if you still want TH to work)
13:19:52 <c_wraith> you don't need to profile for that.  top would suffice
13:20:21 <bennofs> i know. But it would be nicer to get a heap profile, to see if it's not something else :)
13:22:20 <jle`> NemesisD: feel free to post it, but I'm in class right now :)
13:22:56 * hackagebot data-lens-light 0.1 - Simple lenses, minimum dependencies  http://hackage.haskell.org/package/data-lens-light-0.1 (RomanCheplyaka)
13:24:06 <edwardk> 'minimal set of dependencies' and 'data-lens, data-lens-fd and data-lens-template exported through a single module in a single package' seem rather amusingly at odds
13:24:47 <Feuerbach> edwardk: just count 'em ;)
13:25:44 <Feuerbach> (and I'm referring to the number of transitive deps, of course)
13:26:24 <edwardk> Feuerbach: *shrugs* it is obvious our tastes differ.
13:28:41 <oio> how can i make O2 and CO2 to have the same properties as an integer in
13:28:41 <oio>       data BloodGas = O2 | CO2                                          [15:27]
13:28:41 <oio>  
13:29:04 <jle`> what integer properties are you talking about
13:29:20 <vanila> you could write type BloodGas = Integer than use  o2 = 0  and  co2 = 3  (or whatever)
13:29:39 <vanila> you can't pattern match on them, but you can use ==
13:29:43 <edwardk> Feuerbach: did you keep the partial lenses?
13:30:01 <merijn> vanila: You could, but it'd make baby Jesus cry
13:30:24 <oio> like a type synonimun
13:30:27 <Feuerbach> edwardk: no
13:30:35 <jle`> it might also cause the death of a few kittens
13:30:38 <Feuerbach> it's really tiny
13:31:29 <NemesisD_> oio: you could have newtype BloodGas = Bloodgas Int; then don't export the constructor, just type type, then o2 = BloodGas 0, etc
13:31:51 <edwardk> Feuerbach: fair nuff. kudos on killing the partial lenses at least ;)
13:32:06 <Feuerbach> haha
13:32:26 <zipper> I'm having an error relating with Data.ByteString.Lazy.readFile in https://gist.github.com/urbanslug/11379782 Both file and error are there.
13:32:34 <ion> You could just have made the partial lenses Traversals. ;-)
13:33:21 <felixn> https://gist.github.com/munro/11383147 <-- anyone know how to force a monadic value to be evaluated?  I can't seem to get any BangPatterns syntax to work for me
13:33:59 <edwardk> given that t doesn't do type changing assignment i can literally write none of the code i write today with lens with it, so it makes me sad that there is yet another ceiling-lowering lens-family -like library out there, but meh.
13:33:59 <ion> @type (<$>)
13:34:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:34:21 <ion> It seems you are trying to use an “f b” where a “b” is expected.
13:34:33 <shachaf> Is there any lens library other than lens thta supports type-changing assignment?
13:34:40 <ion> You shouldn’t need “_ <-” here.
13:34:43 <shachaf> Every representation of lenses can do it.
13:34:44 <edwardk> fclabels
13:34:51 <shachaf> Though you have to give up on the Category instance.
13:35:06 <felixn> ion: -Wall was yelling at me :/  so I just threw them everywhere.. but you may be right!
13:35:24 <ion> var <- createFunction …; setProp blah var
13:35:49 <felixn> ion: is that the only way?  this is actually all generated code, I can do that... but I'm also lazy
13:35:57 <zipper> Which is the right bytestring?
13:35:58 <felixn> I guess haskell is lazier
13:36:25 <ion> do { a <- foo; bar a } = (foo >>= \a -> bar a) = (foo >>= bar)
13:36:49 <ion> = (bar =<< foo)
13:37:01 <felixn> ion: woah, ok, thanks a lot!
13:38:25 <zipper> Am I dead? Can people see what I am posting?
13:38:33 <zipper> I give up. Good night
13:42:36 <Feuerbach> edwardk: this is nothing ambitious, just for myself to get stuff done. Luckily there's enough space on hackage for everyone
13:43:17 <edwardk> Feuerbach: sure. you'll even get some free support in ghc 7.10 with the ORF
13:43:59 <edwardk> Feuerbach: that proposal was put together to rather deliberately work better with fclabels and data-lens style lenses
13:45:20 <edwardk> just remember every time you run into a case where you have to take a chunk of code that you write in this lib and rewrite it out to use another approach that its the ceiling you put on yourself you are bumping into, not one fundamental to the notion of a lens ;)
13:46:14 <edwardk> Feuerbach: and if that ever gets too frustrating, we'll be waiting over on #haskell-lens to help you take the plunge ;)
13:48:18 <Cale> ORF?
13:48:29 <Feuerbach> OverloadedRecordFields
13:49:46 <joelteon> orf orf orf
13:50:32 <Cale> I'm not sure I believe in overloaded record fields
13:51:28 <Feuerbach> edwardk: can you link to a couple of examples of practical (not abstract CT) code where you use polymorphic updates?
13:51:43 <merijn> Feuerbach: Updating a tuple?
13:52:11 <merijn> > (1,2) & _1 .~ 'c' -- let's see if I remember the syntax
13:52:12 <lambdabot>  ('c',2)
13:52:39 <haasn> > "hello" ^.. folded.from enum
13:52:40 <lambdabot>  [104,101,108,108,111]
13:52:46 <Feuerbach> "link" as in "link to a github project that uses it for something practical", not "write a one-liner"
13:52:59 * hackagebot snap-extras 0.9 - A collection of useful helpers and utilities for Snap web applications.  http://hackage.haskell.org/package/snap-extras-0.9 (OzgunAtaman)
13:53:12 <Feuerbach> in my day-to-day Haskell programming I don't remember ever wanting polymorphic updates
13:53:58 <ciaranm> i cannot approve of this bias against impracticality. check your privilege, C scum!
13:54:07 <zipper> merijn: bro https://gist.github.com/urbanslug/11379782
13:54:29 <haasn> > "48656c6c6f20776f726c64"^..chunking 2 folded.hex.to chr -- is this sufficiently real world?
13:54:30 <lambdabot>  "Hello world"
13:54:43 <haasn> Oh, wait
13:54:48 <haasn> Those are not polymorphic *updates*
13:54:52 <haasn> Never mind
13:55:24 <merijn> zipper: You're using two broken modules (both versions of Char8) *and* mixing Lazy and strict ByteString
13:55:58 <merijn> zipper: You need to figure out which ByteString the libraries you use want and use that one
13:56:38 <haasn> Feuerbach: I feel as if “over setmapped” would be a reasonable example of where polymorphic updates can be useful
13:57:01 <zipper> merijn: Two broken modules?
13:57:11 <merijn> Char8 is evil
13:57:19 <zipper> merijn: What should I use?
13:57:30 <merijn> That depends on what you're trying to do
13:57:47 <shachaf> haasn: That's no lens.
13:57:58 <merijn> Presumably you want to encode Text to ByteString using Text.Encoding
13:58:02 <zipper> merijn: send text files via form data and some strings
13:58:24 <zipper> merijn: Like a pastebin
13:58:35 <Feuerbach> haasn: can you explain like I don't know 'lens'? (because I don't.) Note that I'm asking about lenses, not folds/traversals/prisms/etc.
13:59:09 <n-dolio> That's your problem.
13:59:47 <edwardk> Feuerbach: we have an entire compiler built in this style. virtually every use of a lens combinator we use is a typechanging update
13:59:53 <zipper> n-dolio: me?
13:59:57 <n-dolio> No.
14:01:52 <merijn> zipper: Right, so use Text and Text.Encoding to get the right type of ByteString
14:02:48 <edwardk> Feuerbach: https://github.com/ekmett/ermine/blob/master/src/Ermine/Syntax/Kind.hs sets up a bunch of prisms (co-lenses) we use everywhere in the compiler for our kind system. we have similar tools for types and terms. https://github.com/ekmett/ermine/blob/master/src/Ermine/Syntax/Core.hs for our core language.
14:03:22 <vijaykiran> I'm trying to use cabal sandbox - is it normal that it is compiling lots of stuff again while installing them into .cabal.sandbox ?
14:03:43 <merijn> vijaykiran: Well, yes, it's compiling every single recursive dependency
14:03:44 <Feuerbach> vijaykiran: yes
14:03:49 <maxiepoo> lambdabot: @hoogle (<>)
14:03:49 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
14:03:49 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
14:03:49 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
14:03:57 <maxiepoo> ^why no Data.Monoid?
14:04:06 <zipper> merijn: I can convert from text to bytestring with Text.Encoding?
14:04:25 <merijn> zipper: Yes
14:04:25 <zipper> merijn: Will read up on Text. I am not familiar with it
14:04:44 <zipper> I have read about it on the first few chapters of the Yesod book
14:06:40 <Taneb> maxiepoo, possibly old data
14:06:42 <edwardk> Feuerbach: almost all of our type changing examples do boil down to traversals/prisms though, as other than the field accessor that we compose with them we care very little about lenses per se.
14:07:27 <edwardk> e.g. traversing all of the free variables in an expression
14:07:33 <edwardk> or a type or a kind
14:10:40 <edwardk> Feuerbach: but take the traversal case. where you wnt to be able to change the type of say, the type variables or kind variables in a syntax tree. this lets us substitute in unification meta variables in a type safe manner without making up a new syntax tree.
14:12:49 <Ralpy> Hello
14:13:20 <Feuerbach> edwardk: type-changing traversals certainly occur often. type-changing lenses — maybe not so much. My point is that somehow adding polymorphic updates to data-lens-light probably wouldn't have much value
14:14:22 <edwardk> Feuerbach: without the type-changing lenses you can't compose them with type changing traversals/prisms, etc.
14:14:28 <luite> edwardk: or use ghc's approach ;)
14:15:26 <edwardk> if you cripple the domain of discussion enough you can't find uses for anything. if all you have is the unit type, what is the point of higher order functions? ;)
14:15:41 <Feuerbach> edwardk: that's assuming you have composable traversals/prisms etc. which data-lens-light doesn't provide by design.
14:16:18 <n-dolio> That's why people barely use data-lens style lenses.
14:16:24 <edwardk> > (1,2) & _2 %~ length
14:16:26 <lambdabot>  Could not deduce (GHC.Num.Num [a0]) arising from the literal ‘2’
14:16:26 <lambdabot>  from the context (GHC.Num.Num t)
14:16:26 <lambdabot>    bound by the inferred type of
14:16:26 <lambdabot>             it :: GHC.Num.Num t => (t, GHC.Types.Int)
14:16:26 <lambdabot>    at Top level
14:16:31 <edwardk> > (1,"hello") & _2 %~ length
14:16:33 <lambdabot>  (1,5)
14:16:36 <Feuerbach> yeah, I do feel uncomfortable about crippling the domain of discussion on lenses to... just lenses
14:17:11 <shachaf> Are "just lenses" lenses that follow the laws?
14:17:17 <edwardk> Feuerbach: lens is about a whole realm of things, lenses are one point in the design space. getters, setters, folds, traversals, etc.
14:17:39 <edwardk> lenses themselves aren't a particularly interesting corner of that space
14:17:51 <Feuerbach> not to you :)
14:18:03 <Feuerbach> I find them quite useful
14:18:10 <edwardk> Feuerbach: as evidenced by the number of users of data-lens not to many people ;)
14:18:19 <Feuerbach> totally fine with that
14:18:32 <Feuerbach> anyway, I'm off to bed. Have a good day everyone :)
14:18:38 * edwardk shrugs and leaves
14:18:39 <merijn> ok, someone help me out with naming: Name for a preprocessor that generates FFI wrappers for C enums?
14:18:42 <luite> :)
14:19:13 <Tordek> is there a convention on the order of parameters? e.g., should an "insert" function on a collection take the collection or the element as first parameter?
14:19:30 <merijn> Tordek: The convention is: Whichever is more comfortable to compose
14:19:39 <shachaf> :t M.insert
14:19:40 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
14:19:51 <shachaf> This is the convention. Element first.
14:19:57 <merijn> Tordek: For example, "insert on a collection" tends to take element first so you can partially apply to an element
14:20:00 * srhb is prevented by German lessons from suggesting FFICk
14:20:02 <vijaykiran> n00b question - I'm looking for an easy to use http-client library
14:20:21 <vijaykiran> I found wreq - is that a good start ?
14:20:21 <shachaf> The question is whether (insert x) is more or less useful than (insertInto collection)
14:20:24 <Cale> Tordek: Well, there are two (occasionally competing) strategies for determining argument order. One is that arguments should be in order of increasing expected rate of change, so the "most constant" arguments should be first.
14:20:43 <augur> dolio: beep
14:20:53 <c_wraith> vijaykiran: wreq is a good library, but the interface takes a little more to learn than something like http-client
14:21:00 <Cale> And secondly, if you can have the last argument be the same as the result type, that's often also very convenient, because functions A -> A compose nicely.
14:21:03 <augur> i responded to your comment on reddit. also you should come to #idris!
14:22:36 <vijaykiran> c_wraith: yes, I see that it uses lens and such - I'm actually interested in just using Get/Post and deal with the txt response bodies
14:22:55 <Tordek> awesome, thanks merijn, shachaf, Cale
14:22:57 <Cale> The reason for the first rule of thumb is for one that you want partial applications to be useful, and secondly, it's sometimes the case that you can get better performance by doing some of the computation after getting the first argument
14:24:01 <Cale> (e.g. if the partial application f x is then applied to a list of things, perhaps some of the work is done when computing the function f x and doesn't have to be done for each element of the list)
14:48:05 * hackagebot hblas 0.2.0.0 - Human friendly BLAS and Lapack bindings for Haskell.  http://hackage.haskell.org/package/hblas-0.2.0.0 (CarterSchonwald)
14:54:16 <dmwit> Is there a canonical name/location for choose :: [a] -> [(a, [a])]?
14:54:35 <shachaf> Not that I know of.
14:54:45 <dmwit> ok, thanks
14:58:08 <corgifex> select? draw?
14:58:31 <shachaf> I've heard it called "pick".
14:58:38 <shachaf> But I've heard of many names for it.
14:59:43 <shachaf> @let choose [] = []; choose (x:xs) = (x,xs) : over (mapped._2) (x:) (choose xs)
14:59:44 <monochrom> what does it do? the type leaves a lot of room
14:59:44 <lambdabot>  .L.hs:146:55:
14:59:44 <lambdabot>      Ambiguous occurrence ‘choose’
14:59:44 <lambdabot>      It could refer to either ‘L.choose’, defined at .L.hs:145:1
14:59:44 <lambdabot>                            or ‘Lambdabot.Plugin.Haskell.Eval.Trusted.choose’,
14:59:44 <lambdabot>                               imported from ‘Lambdabot.Plugin.Haskell.Eval.Tr...
14:59:50 <shachaf> @let pick [] = []; choose (x:xs) = (x,xs) : over (mapped._2) (x:) (choose xs)
14:59:50 <lambdabot>  .L.hs:145:55:
14:59:50 <lambdabot>      Ambiguous occurrence ‘choose’
14:59:50 <lambdabot>      It could refer to either ‘L.choose’, defined at .L.hs:145:1
14:59:52 <lambdabot>                            or ‘Lambdabot.Plugin.Haskell.Eval.Trusted.choose’,
14:59:52 <shachaf> Er.
14:59:54 <lambdabot>                               imported from ‘Lambdabot.Plugin.Haskell.Eval.Tr...
14:59:56 <shachaf> Sigh.
15:00:01 <corgifex> @undefine
15:00:01 <lambdabot> Undefined.
15:00:02 <monochrom> time to @undefine :)
15:00:08 <shachaf> @let pick [] = []; pick (x:xs) = (x,xs) : over (mapped._2) (x:) (pick xs)
15:00:10 <lambdabot>  Defined.
15:00:15 <vanila> http://www.swi-prolog.org/pldoc/man?predicate=select/3
15:00:26 <monochrom> someone should secretly @undefine every 30 seconds
15:00:34 <corgifex> > pick [0..]
15:00:35 <lambdabot>  [(0,[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
15:02:11 <nclarke> :t over
15:02:12 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
15:02:24 <monochrom> then I suggest all_possible_ways_of_separating_an_item_from_a_list
15:02:38 <corgifex> :t let select [] = []; select (x : xs) = (x, xs) : fmap fmap fmap (x :) (select xs) in ()
15:02:38 <danclien> For monads, should you use >>= only when adding in additional monadic values and <*> if you're applying a function (transforming? mapping?) a monadic value?
15:02:39 <lambdabot> ()
15:02:53 <shachaf> corgifex: That also works.
15:03:00 <monochrom> or, in caml_case, allPossibleWaysOfSeparatingAnItemFromAList
15:03:25 <shachaf> superUncons
15:03:34 <identity> Anyone familiar with a library that translates Data.Graph graphs to .dot -- or simply renders them?
15:03:36 <corgifex> extracts
15:03:42 <corgifex> exiles
15:04:14 * corgifex cuts it out
15:04:40 <monochrom> danclien: use whichever is convenient for the particular occasion
15:05:33 <danclien> monochrom: Thanks!
15:06:22 <merijn> monochrom: Would this be: ocaml_case? :D
15:06:49 <monochrom> ocaml_case equals caml_case
15:13:01 <peddie> does anyone know how to index into the statically sized vectors from Linear.V?
15:15:31 <stolaruk> What is the difference between Control.Exception and Control.Exception.Base?
15:22:40 <merijn> stolaruk: Control.Exception seems to simply re-export Control.Exception.Base
15:23:04 <stolaruk> merijn: Oh ok, thanks. Did you peek at the source?
15:23:10 <merijn> stolaruk: Yeah
15:23:17 <stolaruk> merijn: Ok I'll start doing that more, thanks
15:23:49 <__sebastian____> stolaruk: C.E.Base also exports "Calls for GHC runtime"
15:23:52 <merijn> stolaruk: Mostly, I'm guessing Control.Exception.Base can have GHC specific things in it whereas Control.Exception is expected to be more portable? That's just a blind guess, though
15:23:57 <FireFly> @ty pick
15:23:58 <lambdabot> [a] -> [(a, [a])]
15:24:04 <FireFly> huh
15:24:11 <companion_cube> > pick [1,2,3]
15:24:13 <lambdabot>  can't find file: L.hs
15:24:27 <companion_cube> ah, it's a lens thing
15:24:46 <FireFly> That's what I was thinking, but the type doesn't look very lnsy
15:24:50 <FireFly> lensy, even
15:26:34 <FireFly> Oh duh, it was defined in lambdabot just a while ago
15:26:36 * FireFly is bilnd
15:26:58 <Algebr> Why is IO a new type? What type is it shadowing?
15:27:24 <geekosaur> an unboxed tuple
15:27:30 <geekosaur> with a virtual first element
15:27:35 <geekosaur> aren't you glad you asked? :p
15:27:53 <monochrom> it is not necessarily a newtype
15:28:15 <Algebr> Does boxing/unboxing in Haskell mean raw C objects vs Haskell objects?
15:28:25 <merijn> Algebr: There are no C objects
15:28:43 * monochrom walks away from this
15:28:45 <merijn> Algebr: Haskell (okay, pedants, GHC...) doesn't compile to C
15:28:47 <Algebr> I thought that what GHC.Prim was, basically.
15:28:59 <geekosaur> Algebr: an unboxed type doesn't have a constructor. what the value is can vary but is often a machine word
15:29:01 <Kaidelong> so is list t ~= Mu (Either () :. (t,)) ?
15:29:08 <Kaidelong> [t] I mean
15:31:06 <Kaidelong> well I guess you can't do sections with types
15:31:15 <monochrom> I don't know :., but likely yes
15:31:45 <merijn> I think :. is Compose
15:31:47 <Kaidelong> so [t] ~= Mu (Either () :. (,) t)
15:32:35 <monochrom> then yes
15:32:43 <dmwit> identity: perhaps
15:32:46 <dmwit> ?hackage graphviz
15:32:46 <lambdabot> http://hackage.haskell.org/package/graphviz
15:32:47 <dmwit> ?
15:32:57 <Kaidelong> does any PL community actually approach list this way?
15:33:04 <Kaidelong> or is that a purely academic exercise?
15:33:21 <pavonia> PL?
15:33:23 <Algebr> What does Word mean in the context of machine word
15:33:27 <Kaidelong> programming language
15:33:37 <pavonia> tempus does
15:33:54 <monochrom> they do and don't depending on what is important for each occasion
15:34:02 <FireFly> Hm
15:34:10 <FireFly> Mu was some sort of type-level recursion thing?
15:34:11 <dmwit> Algebr: The number of bits that your architecture natively munges.
15:34:17 <vanila> Kaidelong, it's useful to be able to decompose all data types into Mu, +, *, 1, 0 to do reasoning that works for every data type
15:34:22 <Kaidelong> Mu is fix for types
15:34:25 <monochrom> yes, Mu is type-level recursion
15:34:28 <FireFly> Ah
15:35:37 <dmwit> Algebr: (Either 32 or 64 bits in almost all cases these days.)
15:35:53 * Algebr needs to take computer arch class
15:38:35 <Algebr> So is it fair to say that Haskell really doesn't have a null since Nothing is actually a value.
15:38:57 <FireFly> Nothing isn't really "like" null
15:38:59 <merijn> Algebr: primitive here just means "there is no haskell code, this is built into the compiler" (for some value of "built into"), for example, to add two numbers we need to at some point make the CPU do something, so in GHC there is a "add two numbers corresponds to this sequence of assembly instructions"
15:39:14 <monochrom> it is oversimplifying and misleading
15:39:43 <monochrom> are you a philosophy major?
15:39:46 <FireFly> Well, I guess it's a bit like null.
15:40:21 <Algebr> monochrom: my degree is in philosophy, heh
15:40:24 <c_wraith> there is a very important difference between Nothing and null.  Nothing only shows up if the type explicitly allows it, and it's not a valid value for any other type.
15:41:33 <Algebr> c_wraith: right, which is why I was saying that Haskell doesn't really have a null, which in other languages is the representation of the abscence of a value.
15:41:39 <Algebr> or was thinking.
15:44:00 <FireFly> ghci doens't mind   type Stream a = Mu ((,) a)   , but I can't actually use that type, can I?  Because to me it seems trying to use it would result in an infinite type of nested pairs
15:44:20 <mietek> monochrom: figured it out
15:44:29 <c_wraith> FireFly: You can create values of that type.  They'll be infinite, but that's possible
15:44:44 <FireFly> Hm
15:44:49 <merijn> FireFly: Infinite types are fine if wrapped into a newtype
15:44:51 <mietek> monochrom: to bootstrap cabal-install-1.20,
15:44:52 <mietek> -  \${GHC} --make Setup -o Setup ||
15:44:52 <mietek> +  \${GHC} -L"/where/my/libgmp.so/is" --make Setup -o Setup ||
15:44:53 <c_wraith> FireFly: just like every other stream type.
15:45:05 <merijn> (newtype or data)
15:45:09 <vanila> FireFly, lazyness makes it ok!
15:45:18 <c_wraith> merijn: Mu is usually a newtype.. I assumed it was
15:45:25 <monochrom> your libgmp.so is not in a "standard" location?!
15:45:31 <merijn> c_wraith: It is (or at least, I'm assuming that)
15:45:57 <vanila> it's not an infinite type since Mu : (b -> b) -> b
15:45:58 <merijn> I just wanted to clarify that there's no deep magic, everyone can define their own infinite types
15:46:05 <mietek> monochrom: there's libgmp.so.3 in /usr/lib
15:46:14 <vanila> I think ever type is finite though
15:46:23 <benbangert> is there a good tutorial on using HUnit + QuickCheck for testing monadic operations? been reading the quickcheck bit in RWH, which seems like a great first step
15:46:28 <mietek> monochrom: this is a long-standing bug with bootstrapping; https://ghc.haskell.org/trac/ghc/ticket/5093
15:46:43 <Kaidelong> perhaps it's better to say "recursive type" than "infinite type" so as not to evoke the occurence check type error in people's minds
15:46:44 <mietek> Fixed in https://ghc.haskell.org/trac/ghc/ticket/957 ?
15:46:53 <FireFly> Oh, right
15:47:22 <merijn> FireFly, Kaidelong: Not directly related, but very similar is Free, might be interesting to read: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
15:47:22 <monochrom> but you are not building ghc.
15:47:40 <FireFly> Thanks for the link
15:47:54 <mietek> Right.  I mean it's the reason.
15:48:07 <c_wraith> :t In
15:48:08 <lambdabot> f (Mu f) -> Mu f
15:48:46 <c_wraith> :t let f x = In (x, f (x + 1)) in f
15:48:47 <lambdabot> Num t => t -> Mu ((,) t)
15:48:53 <c_wraith> FireFly: ^^
15:50:02 <monochrom> I would rather believe that you did not run "sudo ldconfig" enough number of times
15:50:27 <mietek> ldconfig is not available on my platform
15:50:52 <FireFly> In is the data constructor of Mu here?
15:50:56 <c_wraith> yes
15:51:10 <FireFly> Hm, any good reason why it isn't also called Mu?
15:51:17 <shachaf> Instead of Mu that type should be called Fix. :-(
15:51:28 <c_wraith> only that the inverse is called out
15:51:28 * monochrom walks away from this madness
15:51:52 <FireFly> Naming the data constructor after the type seems to be the norm when it comes to newtypes
15:53:38 <Algebr> Why do I need to do deriving for a newtype? it seems redundant.
15:53:54 <Algebr> or rather, it should be a redundancy.
15:53:57 <copumpkin> because you don't necessarily want something to be able to see through it
15:54:13 <monochrom> FireFly, in this case people want the pair of inverses nicely called "in" and "out". except that they also need a capital letter for "in".
15:54:14 <copumpkin> or for it to have all the same instances
15:54:51 <pavonia> Often the only reason to wrap a type into a newtype is to get different instances
15:55:27 <acowley> Algebr: Think about Monoid instances for Ints: Sum and Product
15:55:33 <Algebr> But like isn't newtype just another level of indirection? if that's the case, why do people say its faster than just going through the data way?
15:56:07 <c_wraith> newtypes often have no runtime cost.
15:56:08 <pjdelport> newtype only exists at compile time, not runtime
15:56:11 <acowley> Because it's not an indirection
15:56:30 <FireFly> @ty Out
15:56:31 <lambdabot> Not in scope: data constructor ‘Out’
15:56:37 <c_wraith> :t out
15:56:38 <lambdabot> Mu f -> f (Mu f)
15:56:42 <FireFly> Oh
15:56:53 <FireFly> I see
15:57:27 <c_wraith> :t let x = In ("hello!", x) in x
15:57:28 <lambdabot> Mu ((,) [Char])
15:58:42 <c_wraith> very boring.  But it's fully defined.  If you were to look at it with vacuum, it'd show you that it's a circular data structure in memory
15:59:46 <shachaf> @let newtype Moo f = Moo { runMoo :: forall r. (f r -> r) -> r }
15:59:46 <lambdabot>  Parse failed: TypeOperators is not enabled
15:59:52 <shachaf> :'(
15:59:57 <peddie> edwardk: can you tell me how to index into a vector from Linear.V?
16:00:07 <edwardk> peddie: good question =)
16:00:33 <peddie> edwardk: I started trying to do something with Ixed and it complained about missing instances for E (the basis element)
16:00:50 <edwardk> E isn't actually a Num, etc.
16:00:58 <edwardk> it just provides you access to the element you are at
16:01:18 <peddie> I noticed it's not actually a Num
16:01:29 <edwardk> so it depends on what you want to do
16:01:31 <peddie> if I could figure out what E was and then add a Num instance would it work?
16:01:51 <edwardk> adding a Num instance for it is ... tricky
16:01:54 <peddie> edwardk: I'm just trying to extract a value
16:02:10 <peddie> with "^? ix n" at the moment
16:02:42 <edwardk> yeah ix is expecting an E (V n) not an Int right now. we should probably add something that can index into it with an Int unsafely though
16:02:58 <edwardk> the problem is that i can't in general give you a lens from an Int
16:03:05 <edwardk> because the Int may be out of bounds
16:03:08 <monochrom> http://www.vex.net/~trebla/tmp/nu.txt
16:03:12 <peddie> I am OK giving it an E (V n) if I can figure out how to form one correctly
16:03:24 <acowley> I use Fin a lot
16:03:29 <acowley> We should have a good one
16:03:35 <edwardk> acowley: i'd be open to adding a Fin n to linear
16:03:37 <slikts> if haskell is so good, where is all the killer software written in Haskell?
16:03:40 <acowley> brb
16:03:50 <edwardk> and moving to that rather than E (V n), E V3, etc.
16:04:03 <edwardk> E (V n) is effectively Fin n
16:04:08 <edwardk> but its a lot less convenient
16:04:18 * peddie sighs, starts googling
16:04:20 <peddie> heh
16:04:36 <NemesisD> jle`: /quit
16:04:39 <edwardk> peddie: we're going to need to change the API for you to be happy here and its a latent point we've been considering
16:04:50 <peddie> edwardk: yikes
16:04:51 <edwardk> so you're just caught right at the cusp of progress on it ;)
16:04:58 <peddie> edwardk: anything I can help with?
16:05:21 <edwardk> peddie: its mostly that we need to figure out the right path forward
16:05:28 <peddie> ok
16:05:33 <edwardk> the E trick is clever, but its inconvenient for ix/at
16:05:41 <peddie> I guess I'll just unwrap it everywhere I use it and stay tuned
16:06:54 <peddie> having to use a static index like E (V 3) makes perfect sense; I just couldn't figure out how to actually do it
16:07:07 <peddie> edwardk: thanks for the speedy reply
16:08:05 <edwardk> peddie: well, you _can_ get the index # from an E (V n)
16:08:21 <edwardk> and you can construct a way to get them back out by index through some trickery as well
16:08:26 <edwardk> but its not nearly convenient enough
16:08:28 <peddie> by using dim ?
16:09:01 <edwardk> dim gives you the total # of elements
16:09:09 <peddie> oh oops
16:09:45 <peddie> it sounds like I don't understand how this works well enough to try doing it the tricky way :)
16:10:02 <srhb> slikts: pandoc is pretty killer. xmonad, too. And if we're talking more general, lens, snap are some of my favourites.
16:10:10 <edwardk> so you can get a feel for how awkward it is right now, you can in theory make an E (V n)   with pure 0 & partsOf traverse .~ [1..]   -- that gives you a vector where element 0 is 0, 1 is 1, etc. out to n-1
16:10:39 <peddie> ahhh I see
16:10:53 <srhb> slikts: Not that being a great language is necessarily tied to having killer software. Or even vice versa.
16:10:55 <edwardk> then given x :: E (V n) you can use v^.el x  -- to find the number
16:11:04 <peddie> yep
16:11:37 <edwardk> and we can make a V n (E (V n))  -- by using pure () & itraverse %~ const
16:12:28 <peddie> hmm
16:12:35 <edwardk> but that doesn't give a nice random access, because we never exposed toVector
16:12:41 <edwardk> so V is just a hot mess right now
16:12:44 <slikts> srhb: it just seems like a valid question that if the FP approach is superior, its superiority should express itself in good stuff getting done in FP languages even without mainstream adoption
16:12:56 <srhb> slikts: Given time, I'm sure it will. :)
16:13:09 <slikts> srhb: ironic to say that in #haskell
16:13:15 <savanni> Working on just such a thing.
16:13:20 <srhb> slikts: Is it?
16:13:26 <peddie> edwardk: ok, I'll probably just go back to using Data.Vector for now
16:13:30 <slikts> srhb: given that it's decades old
16:13:42 <edwardk> peddie: one option might be to write the function from an Int -> Lens' (V n a) a  -- that taks the Int mod n
16:13:48 <edwardk> that woul work except for n = 0
16:13:50 <srhb> slikts: Well, it has been a research language for a very long time. It still is, but most research languages juts die.
16:13:56 <srhb> slikts: Haskell is very special in that regard.
16:13:59 <edwardk> where i can feel justified giving an error ;)
16:14:07 <peddie> hehe
16:14:28 <Luke_> is there any way to thread a monad through mapAccumWithKey from Data.IntMap?
16:14:32 <edwardk> with that mindset we could have ix and at work with Int rather than E (V n)
16:14:51 <edwardk> but if we're going to do that we should really do that everywhere
16:14:52 <Kaidelong> "Haskell" as we know it now isn't really decades old
16:15:14 <peddie> edwardk: with that way, you're losing some of the point of having a statically sized vector
16:15:25 <peddie> but I guess you can still fold / map/ whatever without any funny business
16:15:27 <edwardk> peddie: let me take some time to hash out the right solution with acowley
16:15:49 <edwardk> yeah we could have a Fin n, but that requires ugly things for users to work with it
16:15:53 <slikts> Kaidelong: how old is it then?
16:15:54 <shachaf> Luke_: You can use traverseWithKey with your own State.
16:16:03 <peddie> edwardk: sounds good to me :) thanks for explaining
16:16:05 <Kaidelong> hard to say
16:16:10 <Luke_> shachaf: sorry I should have been more clear: Data.IntMap.Strict
16:16:12 <edwardk> unless we define it to use arithmetic mod n if they do math
16:16:24 <Luke_> shachaf: as far as I understand, the traverse instance is lazy
16:16:35 <edwardk> otherwise the pain of manipulating the indices will exceed the utility of the safety
16:16:37 <srhb> slikts: For instance, monadic IO didn't appear until about 10 years after its conception.
16:16:40 <shachaf> Luke_: traverseWithKey is a function.
16:16:44 <peddie> I don't really like the mod n approach too much
16:16:48 <shachaf> Luke_: Data.IntMap.Strict.traverseWithKey
16:17:05 <edwardk> i don't either, but losing Num entirely is really bad
16:17:15 <Kaidelong> nor was compilation to native code the general way people went about doing haskell
16:17:15 <peddie> I'd almost rather have Int -> Maybe (Lens' (V n a) a) like with fromVector
16:17:25 <Luke_> shachaf: "Be aware that the Functor, Traversable and Data instances are the same as for the Data.IntMap.Lazy module, so if they are used on strict maps, the resulting maps will be lazy."
16:17:28 <Kaidelong> Hugs and Gofer were JITed I think
16:17:43 <srhb> slikts: But perhaps it's mostly just a self-fulfilling prophesy. If a lot of people think "it's not used much so it must be bad" rather than trying it out, adoption and hence library building won't go as fast as it could. :)
16:17:51 <srhb> prophecy? yes.
16:17:54 <edwardk> well, we _could_ offer something like that, but it is a oneshot for V n and doesn't give you a tool for indexing the other types
16:17:57 <peddie> but I guess, yeah, that prevents Num from working nicely
16:17:59 <Kaidelong> also the FFI is pretty recent
16:18:02 <edwardk> i can concede the need for ordinal indexing
16:18:11 <Luke_> shachaf: thunks will be built instead of evaluating the traverse
16:18:18 <edwardk> right now the best you can do is v^.traversed.index n
16:18:21 <edwardk> which is slow
16:18:28 <shachaf> Luke_: I'm not saying to use the Traversable instance.
16:18:31 <edwardk> right now the best you can do is v^?!traversed.index n
16:18:34 <peddie> hm
16:18:47 <edwardk> or v^.singular (traversed.index n)
16:18:51 <Luke_> shachaf: it looks like it uses Applicative - does that use Functor?
16:18:56 <slikts> srhb: how stable would you say it is? if someone makes an investment in haskell now, would the rug get pulled out from under them in the future?
16:19:12 <srhb> slikts: I very much doubt that. The adoption rates of Haskell are pointing towards the opposite
16:19:15 <shachaf> Luke_: ?
16:19:16 <edwardk> slikts: Haskell has remained remarkably stable for a very long time
16:19:17 <srhb> slikts: Or rather the adoption acceleration
16:19:54 <shachaf> Luke_: The Applicative instance that you use has nothing to do with the Functor instance for Data.IntMap itself.
16:19:54 <edwardk> slikts: the bulk of our language standard was set down in 1998, and very little changed in 2010 during the last standards update
16:20:08 <Luke_> shachaf: ok
16:20:11 <Luke_> but I need monad
16:20:11 <srhb> slikts: People are slowly becoming more open to FP, we see this by the adoption of FP concepts in more mainstream languages. :)
16:20:18 <edwardk> slikts: the improvements in the language standard itself are evolutionary, not revolutionary.
16:20:21 <srhb> Eventually, they'll just be absorbed, bwahaha!
16:20:21 <shachaf> Luke_: It looks like maybe Data.IntMap.Strict.traverseWithKey is the same as .Lazy.traverseWithKey, though.
16:20:29 <srhb> :-)
16:20:32 <shachaf> Luke_: You should try it out and see if it does what you need.
16:20:39 <edwardk> the extensions provided by the compiler may come and go, but the core language itself was _designed_ for such experimentation
16:20:39 <Kaidelong> well yes
16:20:45 <edwardk> t was the original purpose of the language
16:20:46 <slikts> srhb: do chicks dig haskell more than php?
16:20:50 <Luke_> shachaf: yeah I think it's lazy and I need Monad not Applicative
16:20:55 <Kaidelong> rather than haskell taking the world the trends seem to be that all other languages are converging on becoming like haskell
16:21:03 <Kaidelong> C# is a pretty good example
16:21:11 <srhb> slikts: I suppose that depends on the woman you ask. I know of no statistics, nor do I see any relevance.
16:21:23 <FreeFull> I really like Rust
16:21:34 <shachaf> Luke_: Really?
16:21:45 <shachaf> Luke_: Well, you can use WrappedApplicative or something if you really insist on something that really insists on Monad.
16:21:49 <slikts> srhb: what, you don't go around polling females for their relative preferences towards haskell vs. php?
16:21:52 <Luke_> shachaf: also I need a reverse instance
16:22:02 <srhb> slikts: Sorry, no. :)
16:22:06 <Kaidelong> slikts: the best "success story" I can think of offhand is actually probably Parsec
16:22:12 <Luke_> shachaf: I'm using mapAccumWithKey because there's also a mapAccumRWithKey
16:22:16 <srhb> Oh yeah, Parsec is a great example.
16:22:23 <Kaidelong> but since it's a library and not a whole application its success has been in the form of it being copied by other people
16:22:35 <Kaidelong> every language now has to have a parser combinator library
16:22:52 <srhb> Generally you have to jump a few more hoops to do it in other languages though.
16:23:11 <shachaf> Luke_: You can implement them all with traverseWithKey.
16:23:11 <edwardk> slikts: we do try to avoid creating a hostile environment for either gender around here though, so just be mindful of that in what you say
16:23:24 <Luke_> shachaf: also Applicative is defined as an instance of Functor
16:23:32 <Kaidelong> I guess it's a little obscure but it's a lot easier to use a parsec than yacc and bison
16:23:38 <Kaidelong> in a sense it was truly revolutionary
16:23:45 <Kaidelong> so a "killer app" in that sense
16:23:49 <shachaf> Luke_: See e.g. http://hackage.haskell.org/package/lens-4.1.2/docs/Control-Lens-Traversal.html#v:mapAccumLOf
16:24:05 <shachaf> Luke_: I'm not sure what you're getting at.
16:24:23 <Luke_> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Applicative
16:24:26 <slikts> edwardk: I'm known to be exceptionally inclusive
16:24:37 <Luke_> shachaf: basically it looks like this is lazy
16:24:55 <srhb> slikts: I think edward meant that sentences such as that, especially using "chicks" may easily be perceived as sexist.
16:24:56 <shachaf> Luke_: Huh? What is?
16:25:07 <Luke_> shachaf: traverseWithKey
16:25:31 <slikts> srhb: yeah, I meant that I'm an equal opportunity sexist
16:25:36 <shachaf> That's possible. But what does that have to do with Applicative's superclass?
16:26:14 <edwardk> slikts: that bodes not well for a long tenure on this channel
16:26:18 <Luke_> shachaf: if functor is lazy i think applicative is as well
16:26:36 <shachaf> Luke_: What does "functor is lazy" mean?
16:27:01 <Luke_> shachaf: the functor instance is lazy...
16:27:05 <shachaf> <Luke_> shachaf: "Be aware that the Functor, Traversable and Data instances are the same as for the Data.IntMap.Lazy module, so if they are used on strict maps, the resulting maps will be lazy."
16:27:18 <shachaf> That sentence is talking about the Functor instance for IntMap
16:27:32 <shachaf> We're talking about the Functor instance for whatever your monad is.
16:27:44 <Luke_> ah
16:27:55 <Luke_> monad is WriterT btw
16:28:14 <srhb> That's a monad transformer. :o
16:28:31 <FreeFull> A monad transformer takes a monad and gives you a different monad
16:28:57 <FreeFull> I think technically monad transformers are higher level monads
16:30:18 <Luke_> shachaf: so you think traverseWithKey will work with a Writer?
16:30:30 <shachaf> I think you should try it and figure out whether it works for you.
16:30:48 <shachaf> Or read the source code and figure out whether it works for you.
16:30:49 <Luke_> ok thanks
16:31:15 <Hermit> Anyone has thorough experience with gtk2hs? I'm wondering how can I "lock" an entry box so that clicking on it won't put a cursor in it, but select/give-focus-to the whole thing, if it's even possible
16:31:32 <slikts> edwardk: that was intended as a joke, but whatever
16:33:38 <srhb> Hermit: entryEditable?
16:34:00 <Hermit> srhb: unfortunately, it just makes the text immutable, but the cursor is still there
16:34:07 <Hermit> can move, select, etc
16:34:12 <srhb> Hermit: Ah, okay. Then I think you should just transform the Entry to something else
16:34:37 <Hermit> you mean like a newtype and remaking a few instances?
16:35:03 <srhb> Hermit: No, I mean literally removing the Entry from your layout and placing a box with the text there instead
16:35:15 <Hermit> I see, I'll check it out
16:35:39 <shachaf> slikts: Being intended as a joke doesn't have much to do with creating a hostile environment. So please keep in mind the effects of what you say as well as the intent. :-)
16:36:00 <slikts> shachaf: cmon, we're all brogrammers here
16:36:12 <Kaidelong> uh oh
16:36:22 <geekosaur> uh
16:36:47 <srhb> I think we've found a live troll! :o
16:36:52 <Kaidelong> (you'd be poking at a hornet's nest in any programmer's community, should have seen the whining that happened in ycombinator over bropages)
16:37:34 <slikts> srhb: old school represent
16:37:54 <Kaidelong> anyway offtopic
16:38:01 <Kaidelong> should be taken to -blah
16:41:51 <Luke_> shachaf: I'm still not sure how to get traverseWithKey to visit in the other direction
16:42:51 <Luke_> shachaf: any more guidance for me there?
16:50:03 <evancz> Has anyone run into a TlsNotSupported error recently?
16:50:22 <evancz> http-client got updated yesterday, and I suspect that's the issue
16:50:24 <shachaf> Luke_: Did you see the lens link I sent? Maybe that'd clarify it.
16:51:21 <evancz> the dependencies seem to be exactly the same though...
16:53:15 <Luke_> shachaf: yeah I looked at it but i wasn't sure what was going on =)
16:53:33 <Luke_> shachaf: were you suggesting I use lenses or just use that as an example of how to write the reverse traverse myself?
16:53:50 <shachaf> Just an example.
16:54:02 <shachaf> Luke_: I think you can just use Backwards on your Applicative thing.
16:54:06 <shachaf> Looks like that's all it does.
16:54:55 <edwardk> slikts: you're rapidly becoming indistinguishable from a troll. please lay off the good old boy i was joking routine.
16:55:28 <slikts> edwardk: u mad?
16:55:41 --- mode: ChanServ set +o edwardk
16:55:46 <Luke_> shachaf: reading...
16:55:48 --- mode: edwardk set +b *!~reinis@wikipedia/reinis
16:55:49 --- kick: slikts was kicked by edwardk (Your behavior is not conducive to the desired environment.)
16:55:51 <edwardk> no
16:57:31 <Luke_> shachaf: that's awesome - let me give it a try! thanks a lot!
16:57:53 --- mode: edwardk set -o edwardk
16:58:09 <btcNeverSleeps> first Haskell question ever: if I have "somesort :: Ord a => [a] -> [a]", is "Ord a" some kind of property attached to what the function returns? And then I can write, say, another function only accepting ordered lists as input? (and have the type checker refuse non-ordered lists?)
16:58:36 <shachaf> btcNeverSleeps: "Ord a" is a constraint on a meaning that you can compare values of type a.
16:58:36 <monochrom> no, it is a property attached to "a"
16:58:37 <roboguy_> btcNeverSleeps: Ord is a type class and it restricts both the argument and the result type
16:58:52 <btcNeverSleeps> oh gotcha
16:58:56 <shachaf> btcNeverSleeps: It's not saying that the list is sorted, just that the elements can be compared. You need that in order to sort the list.
16:59:25 <monochrom> well, to the author of somesort, it is a property, an assumption the author can make. to the user, it is a prerequisite
17:01:49 <btcNeverSleeps> roboguy_: does it restricts both the argument and the result type because, in that case, the result type is of the same type as the input? I mean: can you have a type class applying only to the argument?
17:02:10 <roboguy_> btcNeverSleeps: yes, just use a different type variable
17:02:15 <btcNeverSleeps> gotcha
17:02:25 <roboguy_> @t show
17:02:25 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
17:02:28 <roboguy_> :t show
17:02:30 <lambdabot> Show a => a -> String
17:02:36 <[swift]> @seen sof
17:02:36 <lambdabot> $of
17:02:46 <[swift]> hmm, not quite what i was hoping for...
17:02:49 <btcNeverSleeps> :)
17:03:19 <geekosaur> there is no @seen (it edit corrected to @leet)
17:03:20 <[swift]> has anyone heard from sigbjorn finne lately?
17:03:48 <[swift]> geekosaur: ah, was wondering what exactly it was doing there
17:04:30 <Kaidelong> edwardk: I would have promoted myself before issuing the first warning, personally
17:04:42 <Kaidelong> just to drive home that it's a warning
17:05:10 <shachaf> Kaidelong: The channel for discussing these sorts of issues is #haskell-ops.
17:05:27 <edwardk> Kaidelong: i had a few words with him via PM first
17:05:37 <Kaidelong> edwardk: gotcha
17:05:51 <edwardk> Kaidelong: and it was after me and shachaf both commented, and other traffic earlier
17:06:03 <[swift]> sof seems to have dropped off the face of the earth and i need to get an updated version of greencard on hackage for my package to build with ghc 7.8
17:06:05 <edwardk> but #haskell-ops if you want to keep drilling
17:06:09 <btcNeverSleeps> I'm familiar with HoF, lazyness and FP but never did any Haskell. How "real" is the problem that some people complain about Haskell where what would be syntax error in other languages are type errors in Haskell? Is this really a problem for a beginner wanting to learn Haskell?
17:06:34 <Hodapp> ain't no drama like Haskell drama
17:06:43 <[swift]> is there any procedure to do a non-maintainer upload these days? hackage 2 seems to have made this harder than it used to be
17:07:03 <Hodapp> btcNeverSleeps: If an error's an error, what difference doe sit make if it's a syntax error or a type error?
17:07:59 <dwcook> btcNeverSleeps, I've never heard that particular complaint before, I'd be interested in hearing what the exact complaint was
17:08:02 <monochrom> yikes, greencard, that's really old, yeah
17:08:09 <Hodapp> btcNeverSleeps: But, my opinion: Type errors are far more comprehensible than syntax errors.
17:08:38 <[swift]> monochrom: i'd like to move off it but it's a huge job =\
17:08:49 <Hodapp> Though, my main comparison is C++ where common syntax errors can spawn 10 times as many lines of errors as there are lines of code.
17:09:05 <Luke_> does Control.Applicative.Backwards have a negative performance impact when traversing with it?
17:10:05 <geekosaur> [swift]: you need to request it, suggest email to haskell-cafe@haskell.org
17:10:26 <Kaidelong> btcNeverSleeps: you could actually argue that if something should be a type error but is in fact a parse error, the parser is too complicated. It shouldn't have to know about types. I can see some specific examples where this might matter more like accidentally passing functions instead of values, but this is a problem with all ML-syntax languages so if you know those you'll be fine
17:10:34 <[swift]> geekosaur: ok, i'll give that a shot
17:11:07 <monochrom> btcNeverSleeps: I have only heard that beginners get more type errors than elsewhere, but not that those would be syntax errors elsewhere
17:11:28 <Rarrikins> btcNeverSleeps: Do you mean runtime errors?
17:11:58 <Kaidelong> btcNeverSleeps: type errors have the advantage that you can, with time, almost always figure out what's wrong (except for some combinator libraries that do fancy things with types)
17:12:10 <Kaidelong> that's actually good if you're a beginning programmer
17:12:23 <Hodapp> Kaidelong: I think that's good for *any* programmer.
17:12:25 <Kaidelong> it's similar to how java used to be a mainstay of pedagogy because of its checked exceptions
17:12:43 <btcNeverSleeps> Rarrikins: I haven't tried yet (I installed gchi+cabal+structured-haskell-mode in my Emacs but haven't code yet). I take it they're compile time errors, not runtime erros, that people were complaining about.  Basically type errors made by beginners that then they couldn't "troubleshoot" easily.
17:12:49 <Kaidelong> the compiler would keep shouting at you until you dealt with potential corner cases and common mistakes
17:13:11 <edwardk> Luke_: not appreciably, though it might matter applicative by applicative
17:13:23 <Kaidelong> (the term people like is "bondage and discipline")
17:13:51 <Luke_> edwardk: fair enough. basically I was wondering if its some known thing that it's O(n) vs. O(n^2) or something
17:14:18 <btcNeverSleeps> Kaidelong: Java's checked exceptions are glorified goto's : )
17:14:18 <Luke_> edwardk: I've not even closed to wrapped my head around what i'm trying to do here =)
17:14:22 <edwardk> Luke_: nah it should basically have the same asymptotic behavior
17:14:30 <Luke_> ty
17:14:35 <Luke_> good enough
17:14:46 <edwardk> unless (<*>) is really really expensive biased one way or the other
17:15:03 <Luke_> yeah I knew what you meant
17:15:08 <Kaidelong> btcNeverSleeps: this is true of exceptions in general, I'm talking about the bad old java where code would not compile unless it handled or re-threw all incoming exceptions, explicitly
17:15:21 <roboguy_> btcNeverSleeps: some of the type errors are confusing at first, but they become really useful
17:15:39 <Kaidelong> they don't do that anymore, but it was considered good for students to be nagged to handle exceptions by threatening them with their code not compiling
17:15:40 <roboguy_> in fact, type errors are one of ghc's biggest strengths in my opinion
17:15:57 <Kaidelong> in industry the result was that people just wrote "throws Exception" and defeated the whole mechanism
17:16:24 <roboguy_> actually, type errors are so useful that they recently added a way to intentionally induce a type error to help you figure out how to write pieces of code!
17:17:18 <Kaidelong> (I think type holes are legit for encapsulation purposes and should just be allowed period)
17:17:38 <Kaidelong> ST _ t  or even an alias that explicitly hides the first parameter
17:17:42 <c_wraith> Kaidelong: or wrapped everything in some form of RuntimeException
17:19:44 <Luke_> http://hackage.haskell.org/package/lens-4.1.2/docs/Control-Lens-Traversal.html#v:mapAccumLOf the Backwards instance is on the accum but traverses backwards over the datastructure?
17:21:15 <btcNeverSleeps> what about Haskell when implementing cryptographic algorithms? Especially the ones not too common, like those found in papers but not necessarily implemented yet? (say stuff like "socialist millionaire" or "2-way anonymous veto network")  Is Haskell "good" to write code doing multiplication and modulo on big numbers? Are "Integer"s fast? (I read about cryptol, but I need to implement stuff really not commonly found)
17:22:03 <Cale> btcNeverSleeps: Integer is reasonably fast. The default implementation in GHC uses GMP for large values and machine integers for small ones.
17:24:20 <Cale> As a beginner, you might bump into performance issues regarding strictness if you're not careful, but these are the sorts of things which you can only really learn by doing.
17:24:20 <btcNeverSleeps> Cale: thanks, just Googled GMP.  Right now I'm using Clojure's BigInt (which I think is mostly a wrapper around Java's BigInteger) but I'm bit pissed of at Clojure's lack of types.
17:25:45 <Cale> (a lot of cryptographic algorithms are of the sort where you'll want to make sure to have a little bit of strictness at the right place, or else you'll waste a lot of space and allocation time on unevaluated expressions)
17:26:06 <btcNeverSleeps> Cale: oh gotcha
17:26:18 <btcNeverSleeps> Cale: I'm used to lazyness in Clojure
17:27:15 <btcNeverSleeps> btw I saw that there was another Haskell-like language which was strict by default and non-strict only if you explicitely asked for it.  Does the "inverse" exists: I mean, Haskell is lazy by default, can you "force" it to be strict?
17:27:29 <Cale> yes, you can force it to be strict
17:27:52 <joelteon> there are strictness annotations, but there isn't a compiler flag for it or anything.
17:28:32 <Hermit> btcNeverSleeps: there's seq (function to create eval dependency), NFData (class to evaluate collections) and BangPatterns (language extension)
17:28:52 <Cale> Yeah, it's just annotations you put in your code. Probably the easiest ones to understand are bang patterns. Roughly, matching against the pattern !x will force the evaluation of x (up to determining the top-level data constructor)
17:29:29 <Cale> (In the case of Integer, that's equivalent to fully evaluating)
17:29:55 <joneshf-laptop> let's go back to btcNeverSleeps ' first question, is there a way to encode that the result is sorted aside from a typeclass or newtype?
17:29:57 <Hermit> (in the case of list, is like evaluating the first cons)
17:30:09 <joneshf-laptop> not that i'm against either approach
17:30:13 <joneshf-laptop> just curious
17:30:29 <Hermit> phantom types?
17:30:38 <Cale> joneshf-laptop: That a list is sorted?
17:30:45 <joneshf-laptop> Cale, yes
17:30:58 <Cale> joneshf-laptop: Theoretically, maybe, but in practice, not really.
17:31:53 <Cale> That's something you can pull off in a dependently typed language, but while GHC has a lot of features leaning in that direction, and its type system is quite fancy, complicated things like that in the type system aren't terribly practical.
17:32:10 <Cale> (especially ones which depend so heavily on the values involved)
17:32:24 <joneshf-laptop> ah well
17:39:28 <roboguy_> joneshf-laptop: you can ensure that a red-black tree is valid but I'm not sure that I'd want to try something too much more complicated than that
17:42:58 <Cale> Yeah, there are some impressive things which can be accomplished using nested recursive data types even in Haskell 98. I don't entirely understand what the exact level of power that gives you is.
17:44:13 <btcNeverSleeps> I installed the latest cabal, structured-haskell-mode for Emacs and GHC.  But GHC is the "stock" one that comes with Debian: version 7.4.1.  Is 7.4.1 too old or should it be ok to begin?
17:44:15 <roboguy_> I would imagine that making sure a list is sorted would be pretty difficult
17:44:25 <roboguy_> (in types, I mean)
17:44:49 <monochrom> 7.4 is good enough to begin
17:45:45 <Cale> roboguy_: In a dependently typed setting, it's not hard at all, but yeah, in Haskell, it's close-to-impossible.
17:46:20 <nh2> how's atomicModifyIORef implemented? Some lock/memory barrier?
17:46:38 <Cale> You'll at the very leasy need to implement the type of elements of your list in the type system as well as the comparison operation.
17:48:23 <Cale> nh2: hmm, apparently it's implemented as:  atomicModifyIORef (IORef (STRef r#)) f = IO $ \s -> atomicModifyMutVar# r# f s
17:48:40 <Cale> Let's see how atomicModifyMutVar# is implemented... might be primitive
17:50:45 <Cale> I wonder how many times a day on average I go to press Ctrl-G in Chrome to search for something and hit Ctrl-H instead, opening my history in a new tab. The one thing I really miss from Firefox is / to search.
17:50:49 <c_wraith> nh2: IIRC, it's atomic CAS
17:52:43 <nisstyre> Cale: what about Chrome do you like more?
17:53:03 <Cale> It's a bit faster
17:53:06 <nisstyre> if Firefox uses too much resources there is always something like vimb
17:53:12 <nisstyre> if you're a vim fanatic
17:53:46 <nh2> Cale, c_wraith: my main concern in the business is: modifyIORef' doesn't guarantee atomicity, so I'd expect it to be somewhat faster - in fact just a plain memory write. But it's much slower than writing a for loop over the strict state monad - I wonder why and if that's to be expected
17:54:27 <btcNeverSleeps> Cale: I've got Ctrl-H set to del-backward-char in Emacs and in my terminal... So everytime I make a typo in Chrome I type Ctrl-H trying to delete backward and invariably it opens the history (both under Chrome and under Firefox/Iceweasel). Can't count the number of times it happens to me either.
17:55:22 <c_wraith> nh2: I would expect all forms of mutable cell to be much slower than functional state calculations.
17:55:43 <meretrix>  Is there any way to write an error-like function without any crazy TH that automatically prints the module name, function name, and line number from which it was called?
17:55:53 <c_wraith> nh2: GHC produces code optimized for state-passing, rather than mutating
17:56:12 <nh2> meretrix: I wish, but I don't think its possible
17:56:55 <meretrix> That's too bad. Probably the only feature I miss from java.
17:57:05 <meretrix> Now I have to write very descriptive error messages.
17:58:47 <StoneToad> meretrix: what about undefined?  IIRC it tells you the source file and line number
17:58:53 <nh2> c_wraith: eh, I've got quite disappointed with either of them in the last days since I've started looking into how to write really fast loops; but using IO to modify unboxed vectors and STUarrays seems to optimize quite well
17:59:18 <nh2> StoneToad: what? It prints `Prelude: undefined`, pretty much the worst error ever
17:59:21 <StoneToad> hmm
17:59:27 <nh2> I wish it did that
17:59:29 <StoneToad> I remember doing something thatp rinted out the line number
17:59:44 <meretrix> I think there are profiling options that enable line numbers.
17:59:52 <meretrix> But I can't use those on production code.
18:00:38 <intrados> meretrix: There are a few sort of hacky options outlined on http://augustss.blogspot.com/
18:00:55 <meretrix> Thanks, I'll check them out.
18:01:32 <StoneToad> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/assertions.html
18:01:38 <StoneToad> ah that's what I was thinking of
18:02:04 <StoneToad> also check http://www.haskell.org/haskellwiki/Debugging#Source-located_errors the LocH sounds interesting (though I've never used it)
18:03:49 <Cale> nh2: You can see its implementation in rts/PrimOps.cmm in the GHC source code
18:04:00 <Cale> stg_atomicModifyMutVarzh ( gcptr mv, gcptr f )
18:04:25 <roboguy_> Cale: I usually use cmd-f and enter to search in chrome
18:04:34 <Cale> (h) = ccall cas(mv + SIZEOF_StgHeader + OFFSET_StgMutVar_var, x, y);
18:04:40 <meretrix> Yeah assertions are useless with any optimization turned on.
18:05:58 <Cale> well, that's the key thing for the threaded RTS implementation...
18:05:59 <nh2> StoneToad: better don't use assertions, they get removed when you compile with optimizations on
18:06:09 <StoneToad> which is a feature?
18:06:22 <nh2> unfortunately; sadly enough there are no assertions that stay
18:06:30 <nh2> because assertions actually give you good location errors
18:06:33 <nh2> iirc
18:06:37 <Cale> I really don't know the RTS well enough to read this code
18:06:38 <StoneToad> they're wonderful for checking for programmer stupidity I find
18:06:53 <StoneToad> (where programmer == me)
18:07:25 <Cale> roboguy_: ah, good to know that Enter works
18:07:46 <Cale> (though I often use Ctrl-G because I want to repeat a search I just did on another page)
18:07:57 <StoneToad> but yes, I can see how having some asserts that didn't get optimized out would be nice, that LocH library from dons looks pretty sweet though
18:08:13 <StoneToad> wonder if it still works
18:08:19 <StoneToad> 2007 is last update :(
18:08:43 <nh2> yes looks ancient. I think good location errors should really be a ghc feature
18:09:08 <StoneToad> oh nm, it's using assert to get the location data it seems
18:09:32 <StoneToad> so suffers from the optimization taking it out
18:10:10 <StoneToad> indeed, it would help with a lot of errors
18:17:59 <Kaidelong> on approaching cross platform development; would one way be to set up my system so that both my C compilers and GCC target the LLVM?
18:18:20 <Kaidelong> then take the dump for the LLVM compiler to windows and compile it there?
18:31:55 * btcNeverSleeps goes to sleep and thanks everyone for the help
18:33:31 * BMeph_ calls btcNeverSleeps on the misleading name...alas, too late, too late!
18:42:08 <benzrf> hey
18:42:24 <benzrf> im trying to figure out Moment in reactive-banana, but i am confuse
18:42:43 <benzrf> it's a time-varying value that is only /valid/ at the given t parameter?
18:48:02 <Cale> benzrf: Well, yeah, I think the t parameter is meant to be thought of as the time at which it was observed, but iiuc, you just always leave that polymorphic, you never plug in a specific t.
18:49:40 <benzrf> hmm
18:49:47 <benzrf> http://apfelmus.nfshost.com/blog/2012/09/03-frp-dynamic-event-switching-0-7.html
18:49:47 <Cale> compile :: (forall t. Frameworks t => Moment t ()) -> IO EventNetwork
18:49:50 <Cale> It's like ST
18:49:51 <benzrf> ^reading that...
18:50:01 <benzrf> >Being able to tag values with clock times is nice and well, but the real magic only starts to happen when you quantify over the time parameter. Namely, an expression
18:50:04 <benzrf> y :: forall t. Moment t A
18:50:06 <benzrf> denotes a value of type A for each time t. Most importantly, this value can be different for different times t. In other words, this quantified version is extremely similar to a Behavior!
18:50:10 <benzrf> this confuses me
18:50:22 <Cale> Do you understand runST?
18:50:26 <Cale> :t runST
18:50:26 <lambdabot> (forall s. ST s a) -> a
18:50:28 <benzrf> no >.>
18:50:39 <benzrf> what i dont understand is
18:50:43 <benzrf> if you can do that
18:50:49 <benzrf> what's the point of having Behavior?
18:51:02 <benzrf> i do not understand the difference >.<
18:52:06 <Kaidelong> don't think about the t
18:52:08 <Kaidelong> it's not real
18:52:19 <Kaidelong> it leaks out because haskell types don't do encapsulation properly
18:52:33 <Kaidelong> (well in this case you need it for the constraint)
18:52:43 <benzrf> ok but that's not what confuses me here
18:52:47 <benzrf> >_>
18:52:52 <Cale> Kaidelong: What?
18:53:04 <Cale> No, it exists solely to prevent things from leaking out
18:54:15 <Cale> In particular, if you use some operation which creates a Moment t a, you can't smuggle that Moment t a value out of the current call to compile and use it in the construction of some other EventNetwork
18:54:51 <Kaidelong> Cale: but it's not particularly useful to the caller to know that this is achieved by a rank 2 type
18:55:05 <benzrf> :|
18:55:10 <Kaidelong> that's "implementation detail"
18:55:28 <Cale> I suppose. It is important to the programmer to know that they won't be able to do this
18:55:53 <Cale> Perhaps the expression of it in the type system could be prettier
18:56:02 <benzrf> anyway.
18:56:02 <Kaidelong> I think "ST _ a" is a good compromise
18:56:10 <benzrf> -_-
18:56:31 <benzrf> mainly i do not understand how Moment t a differs from Behavior t a
18:56:40 <Cale> benzrf: Anyway, think of values of type Behaviour t a as being time-varying values, while values of type Moment t a are sampled
18:56:45 <benzrf> b-but
18:56:48 <benzrf> Being able to tag values with clock times is nice and well, but the real magic only starts to happen when you quantify over the time parameter. Namely, an expression
18:56:51 <benzrf> y :: forall t. Moment t A
18:56:53 <Cale> There's no clock time
18:56:54 <benzrf> denotes a value of type A for each time t. Most importantly, this value can be different for different times t. In other words, this quantified version is extremely similar to a Behavior!
18:57:02 <Cale> That's a weird interpretation of the t parameter
18:57:05 <benzrf> that's a quote from the article
18:57:09 <benzrf> written by the creator
18:57:13 <Cale> Yeah, well, don't listen to it :P
18:57:16 <benzrf> ...
18:57:20 <benzrf> q_q
18:57:31 <Cale> Just follow the type signatures :P
18:57:49 <benzrf> http://apfelmus.nfshost.com/blog/2012/09/03-frp-dynamic-event-switching-0-7.html
18:57:54 <Cale> valueB :: Behavior t a -> Moment t a
18:58:02 <Cale> this operation makes Moment similar to Behavior
18:58:11 <Cale> But note that there's no operation in the other direction
18:58:23 <benzrf> >_<
18:58:41 <benzrf> i just want to understand what the article means u_u
18:58:48 <benzrf> can a moment vary or can it not?
18:58:55 <benzrf> and if it can, why have behavior?
18:59:14 <Cale> Well, there is  Moment t a -> Moment (Behavior t a)
18:59:36 <roboguy_> it isn't possible to use Void somehow to avoid the rank2type is there?
19:00:25 <benzrf> :L
19:01:46 <Cale> benzrf: Moment t is just a reader monad and doesn't have the same caching machinery in it that Behaviour t a does
19:02:24 <Cale> It's just a monad which is being used to construct the EventNetwork, and pretty much all you need to know about it is that it's a monad
19:02:35 <benzrf> >.>
19:02:40 <Cale> and that you're going to pass a computation of that type to compile
19:02:45 <benzrf> ;-;
19:02:52 <Cale> apart from that, you don't really use it to represent anything changing over time
19:03:05 <Cale> You use Behavior and Event values
19:03:46 <Cale> I don't really know banana all that well, but I believe the Moment computation might just run once
19:04:38 <Cale> i.e. its job is to construct a graph of the computation to be done -- what needs updating when something changes, etc.
19:04:40 <benzrf> :T
19:05:05 <mizu_no_oto> Is there any way in Yi to enter greek or math symbols, at the moment?
19:05:26 <mizu_no_oto> Something like vim's digraphs, for example
19:05:49 <Cale> Actually, yeah, it probably runs once, but then certain Moment computations will be run when doing switching, in order to recompute the EventNetwork.
19:06:17 <Cale> (I've worked extensively on implementing an FRP system, but not this one)
19:07:54 <benzrf> :I
19:08:20 <Cale> i.e. when you use switchB for example, to create a behaviour which switches between some other behaviours each time that an event occurs, the Event that you give to switchB has type Event t (AnyMoment Behavior a)
19:08:38 <benzrf> i just do not understand how moment works
19:08:39 <benzrf> :|
19:08:45 <Cale> What do you need to understand?
19:08:58 <Cale> http://hackage.haskell.org/package/reactive-banana-0.8.0.0/docs/Reactive-Banana-Switch.html -- the operations are in here
19:10:12 <Cale> You should think of a value of type Moment t a as being pretty much the same thing as a value of type a, but the type system is going to control what things you're allowed to do with it.
19:10:37 <Cale> i.e. it's just a static value, it doesn't change over time
19:12:03 <Cale> (however, looking at the implementation, it is secretly parameterised over an EventNetwork, which if I had to guess, is probably the EventNetwork which it is being used to build, in some recursively loopy way)
19:12:24 <Cale> But you can't see that from the exposed interface anyway
19:12:51 <Cale> So, just think of values of type Moment t a as being wrapped up values of type a, and you probably won't go too wrong.
19:13:34 <benzrf> then what's this shit about varying in time when the parameter is forall'd
19:13:36 <benzrf> ;-;
19:14:33 <Cale> Well, each call to compile will correspond to an instantiation of the t variable
19:14:52 <Cale> So, it's not really time, it's occurrences of building an EventNetwork
19:15:02 <benzrf> ... :I
19:15:08 <Cale> But hopefully you don't do that more than once at any given time
19:15:50 <Cale> So when you see this, for instance: anyMoment :: (forall t. Moment t (f t a)) -> AnyMoment f a
19:16:00 <Cale> and then the various operations depending on AnyMoment values
19:16:24 <Cale> It's just to help keep separate the results of operations in this Moment monad which come from different runs of the EventNetwork compiler
19:16:41 <benzrf> ok...
19:16:48 <benzrf> switchB :: Behavior t a -> Event t (forall s. Moment s (Behavior s a)) -> Behavior t a
19:16:55 <benzrf> what's the point of the Moment wrapper there?
19:16:58 <benzrf> same thing?
19:17:15 <Cale> because (just guessing), there are perhaps unique identifiers associated to the graph nodes involved in each run which get restarted from 0 each time and shouldn't be confused with nodes in different graphs
19:17:51 <Cale> Yeah, when it switches to a new behaviour, it'll have to recompile the graph associated with that behaviour
19:18:20 <Cale> btw, that type is slightly out of date
19:18:26 <Cale> switchB :: forall t a. Behavior t a -> Event t (AnyMoment Behavior a) -> Behavior t a
19:18:42 <Cale> AnyMoment is its own type now, with an operation  anyMoment :: (forall t. Moment t (f t a)) -> AnyMoment f a
19:19:06 <Cale> Probably just because impredicative polymorphism in GHC is often not very well supported.
19:19:47 <Cale> (not many libraries use it, and it's apparently hard to maintain alongside all the other features of GHC)
19:19:53 <benzrf> sorry i knew some of the words in that last message
19:19:58 <Cale> That's okay
19:20:19 <Cale> Impredicative polymorphism refers to giving a type with an explicit forall as the parameter to a type constructor
19:20:39 <Cale> Like  Maybe (forall a. [a] -> [a])
19:22:03 <dolio> That's what it refers to in GHC, anyway.
19:22:11 <Cale> yeah
19:22:47 <Cale> Well, that's almost what it means in general
19:28:26 <_flatline_> Does haskell have a function to properly escape characters in a string?
19:28:33 <Cale> benzrf: anyway, since Moment provides an operation Behaviour t a -> Moment t a, the results of Moment computations might be different when those computations get run at different times, because the values of the behaviours are changing. But a major point of FRP is not recomputing things when nothing that affects them has changed, which involves maintaining caches. Moment doesn't have any of that caching machinery.
19:28:46 <_flatline_> The context is that I'm trying to query a sql database with this string and the string has an apostrophe in it
19:29:18 <benzrf> ok
19:29:30 <Cale> _flatline_: If you're generating SQL strings from user input, you're doing it wrong. Use a compiled query with a parameter.
19:29:39 <Cale> _flatline_: which database library are you using?
19:29:44 <benzrf> in general i should treat Moment t a as being like Identity a?
19:29:52 <Cale> benzrf: pretty much, yes
19:29:55 <benzrf> kk
19:30:50 <_flatline_> Cale: HDBC, and i'm not generating them from user input
19:31:12 <_flatline_> I'm trying to create and fill a column in a database that already has data in it
19:33:08 <_flatline_> Cale: is there a better database library? I also don't know where to look for compiled queries with hdbc
19:33:41 <Cale> Put a ? in your query where that string goes, and then use, e.g. quickQuery conn "... ? ..." [SqlString theString]
19:33:44 <minancorax> !help
19:33:47 <benzrf> Cale: thank u very much :D
19:35:27 <Cale> You can also use prepare and execute separately, which will perform much much better if you're going to do this for many different strings
19:36:14 <[swift]> _flatline_: re: a better database library, i doubt it's worth changing over now, but for future projects you could consider the *-simple set of libraries (sqlite-simple, postgres-simple, etc)
19:37:35 <_flatline_> [swift]: Thanks, I'll keep that in mind
19:37:41 <_flatline_> Cale: Thank you, I'll look into that
19:38:28 <Cale> prepare :: conn -> String -> IO Statement
19:38:44 <Cale> execute :: Statement -> [SqlValue] -> IO Integer
19:39:24 <Cale> (Well, really the conn in prepare needs to be an instance of IConnection, but I copied it from the documentation :)
19:39:58 <Cale> executeMany :: Statement -> [[SqlValue]] -> IO () -- there's also this
19:40:09 <Cale> which is very useful if you're populating a table
19:40:12 <_flatline_> I'm almost afraid to ask this, but why does this result in better performance?
19:40:22 <Cale> It depends on the database
19:41:08 <Cale> Well, prepare sends the query (with ?'s in it) to the database, and the DB is able to compile some code to execute that query ahead of time, once it has the parameter values
19:42:24 <Cale> and so it doesn't have to go through the process of compiling the query for each row you're inserting, for instance
19:42:35 <_flatline_> Ah, k
19:43:12 <Cale> Similarly, if you give it the whole list of parameter lists that you want to execute the query on, it might be able to do something clever with that ahead of time.
19:43:38 <Cale> To perhaps arrange that it does linear work rather than O(n log n) work or something.
19:43:56 <Cale> well, that's a bit unlikely overall
19:43:59 <_flatline_> So if I'm populating a column, I'd want to prepare each statement, put the results into a list, and then run through the list and execute each one?
19:44:32 <Cale> (But maybe it can do something O(n log n) to the list of parameter lists which is faster than doing the same on whole rows of the DB)
19:45:09 <Cale> Prepare one statement with parameters for, say, the ID column and the data to fill
19:45:40 <Cale> then use executeMany with a list of [id, data] lists
19:46:17 <Cale> Make sense?
19:46:25 <_flatline_> ohhhh, i see
19:46:38 <_flatline_> yeah that makes sense
19:46:39 <_flatline_> thank you
19:50:20 <Cale> That said, I have found myself wishing for a Haskell library which generates valid SQL code from syntax trees (and then maybe some fancier combinators built on top of that)
19:50:47 <Cale> Though really SQL just sucks and we ought to make something better :)
19:51:05 <Cale> (and pretty much all the noSQL things suck even more)
19:51:19 <Cale> I want *stronger* types in my database, not weaker ones!
19:51:46 <Cale> There's acid-state which is pretty cool
19:57:46 <[swift]> Cale: acid-state *is* pretty cool. if you're writing code that matches the traditional strengths of SQL, though, i'm not sure how much you gain, because you need to manually implement things like indexes
19:58:57 <Cale> Yeah, the thing is that not a whole lot matches the traditional strengths of SQL, because most applications eventually need a sum type.
19:59:07 <Cale> and SQL doesn't give you any reasonable way to work with those
19:59:43 <Cale> There's no easy way to say "this column is populated with either a foreign key in table A or a foreign key in table B, and we know which"
20:00:44 <Cale> and that's just the beginning. Try representing a tree structure in a table without accidentally allowing representations of arbitrary graphs.
20:01:11 <[swift]> Cale: yup, definitely true. it seems like a shorter path to build nice indexing and query libraries to go with acid-state than to try to retrofit the benefits of Haskell's type system onto SQL
20:02:45 <assia_t> I'm stuck in a really basic problem... Anyone active?
20:02:51 <Luke> shachaf: got converted to a StateT WriterT stack for IntMap.traverseWithKey but I still can't figure out how to use Control.Applicative.Backwards with it
20:02:57 <Vimmer> I'm active by i dont' know haskell!
20:02:57 <assia_t> Is there a reversed takeWhile?
20:03:16 <assia_t> I didn't want to do explicit recursion
20:03:35 <Luke> assia_t: you mean dropWhile or reversed list?
20:03:42 <assia_t> mm.../
20:03:48 <assia_t> hadn't though of dropWhile
20:03:56 <assia_t> I'm trying to extract file extensions
20:03:58 <assia_t> so
20:04:14 <Luke> assia_t: check out System.FilePath
20:04:16 <assia_t> from the last element up, rather than going from the head
20:04:22 <assia_t> yeah...
20:04:49 <assia_t> but if I needed a reversed takeWhile, would I need to use explicit recursion?
20:05:06 <Luke> assia_t: http://hackage.haskell.org/package/filepath-1.3.0.2/docs/System-FilePath-Posix.html
20:05:17 <croyd> assia_t: you can reverse the input before giving it to takeWhile
20:06:03 <assia_t> croyd: yeah
20:06:08 <croyd> e.g. extension = reverse . takeWhile (/= '.') . reverse
20:06:12 <Luke> assia_t: no you don't need to do explicit recursion - just use 'takeExtension'
20:06:22 <assia_t> croyd: but then it goes through the entire list
20:06:28 <assia_t> Luke: I got that.. Thanks
20:06:51 <assia_t> Luke: now I'm just trying to understand the things around this...
20:07:22 <Luke> assia_t: are you trying to get the filename or the extension?
20:07:48 <assia_t> Luke: the extension... The problem has been solved
20:08:19 <assia_t> but I think it's funny that a fold wouldn't do it..
20:08:42 <Luke> fold condenses down to one accumulated value
20:08:49 <assia_t> Luke: yes
20:08:49 <Luke> its like reduce
20:08:53 <assia_t> I know
20:09:36 <assia_t> wouldn't foldWhile be a good idea?
20:09:41 <assia_t> or something like that?
20:10:23 <Luke> here's the dropWhile source: http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-List.html#dropWhile
20:10:54 <assia_t> foldlWhile :: (a -> Bool) -> (b -> a -> b) -> b -> a -> b
20:11:01 <assia_t> ops
20:11:07 <croyd> assia_t: I'm not sure what your object to going through the entire list is. AFAIK there isn't any other way to get to the last elements
20:11:07 <assia_t> foldlWhile :: (a -> Bool) -> (b -> a -> b) -> b -> [a] -> b
20:11:17 <croyd> s/object/objection/
20:11:23 <assia_t> croyd: you can start from the last element
20:11:36 <croyd> assia_t: how so?
20:11:59 <assia_t> croyd: oh
20:12:05 <assia_t> croyd: you're right...
20:12:20 <assia_t> croyd: but the problem is working on the entire list...
20:12:26 <assia_t> croyd: yeah.. idk
20:12:31 <Luke> fold really isn't the right approach because you have an extra accumulator you're not using
20:13:03 <Luke> you could make it work but it's not a perfect fit
20:14:00 <croyd> > reverse . takeWhile (/= '.') . reverse $ [error "eek", undefined, '.', 'h', 's']
20:14:01 <lambdabot>  "hs"
20:14:40 <Luke> haha
20:14:41 <Luke> nice example
20:15:08 <croyd> file I'm working on right now
20:16:18 <assia_t> yeah...
20:16:28 <assia_t> dropWhile is the approach..
20:16:47 <assia_t> but takeExtension is probably more efficient
20:16:56 <assia_t> so yeah... thanks :)
20:17:27 <Luke> np
20:18:12 <c_wraith> if you want a right takeWhile, the most efficient implementation is a foldr
20:21:09 <c_wraith> :t let takeWhileR p = foldr (\c r -> if p c && not (null r) then c : r else []) [] in takeWhileR
20:21:10 <lambdabot> (a -> Bool) -> [a] -> [a]
20:21:21 <c_wraith> You're not going to find a solution more efficient than that.
20:21:45 <c_wraith> assia_t: ^
20:22:28 <assia_t> croyd: won't that return an empty list when the predicate fails?
20:22:33 <assia_t> ops
20:22:38 <assia_t> c_wraith: ^
20:22:55 <c_wraith> oh, right, I'm used to the other direction. I messed up the logic.
20:23:49 * hackagebot hspec-meta 1.9.4 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.9.4 (SimonHengel)
20:23:52 * hackagebot hspec 1.9.4 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.9.4 (SimonHengel)
20:24:22 <c_wraith> Gah, yes I did.  I don't think there's a clever trick for that one along those lines.
20:24:50 <assia_t> yeah... it'll depend on the efficiency of the predicate
20:24:54 <assia_t> you could do:
20:24:58 <c_wraith> If there isn't, though, it means there's nothing fundamentally better than the double reverse method.
20:28:50 * hackagebot loop 0.1.0 - Fast loops (for when GHC can't optimize forM_)  http://hackage.haskell.org/package/loop-0.1.0 (NiklasHambuechen)
20:30:19 <assia_t> yeah.. idk
20:30:29 <_flatline_> Cale: With HDBC, should I be able to do something like run conn "ALTER TABLE databasename ADD ? VARCHAR(255)" [SqlString colName]
20:31:40 <Cale> I should hope so
20:31:58 <[swift]> _flatline_: i don't know about this specific case but some databases do not support database names, table names, or column names as prepared statement parameters. i'm thinking in particular about sqlite here.
20:32:16 <Cale> Yeah, that should be a table name, rather than a database name
20:32:39 <Cale> [swift]: Oh, that's disappointing
20:32:59 <geekosaur> I think that's actually pretty common
20:33:12 <geekosaur> DDL is often rather weakly supported
20:33:37 <_flatline_> shit
20:33:46 <_flatline_> i meant tablename, but
20:33:52 <_flatline_> i'm using sqlite >_<
20:34:45 <assia_t> c_wraith: https://gist.github.com/11390082
20:35:07 <Cale> _flatline_: Are you certain you need to be dynamically adding new columns to your table?
20:35:13 <_flatline_> No, I don't
20:35:15 <_flatline_> I was just curious
20:36:00 <Cale> Usually that would be pretty bad as far as normalisation is concerned.
20:36:06 <Luke> anyone able to help me use use Control.Applicative.Backwards with IntMap.traverseWithKey?
20:36:22 <Luke> i just can't figure out how to wrap my current functor w/ Backwards
20:37:29 <Cale> Luke: which functor?
20:37:53 <Luke> StateT WriterT stack
20:37:55 <Cale> Well, what is the line of code without Backwards?
20:38:27 <Luke> runStateT (IntMap.traverseWithKey matchLevel ms) (Just t)
20:39:18 <Cale> runStateT (forwards (IntMap.traverseWithKey (\k v -> Backwards (matchLevel ms k v)) (Just t))
20:39:24 <Luke> thanks
20:39:40 <Cale> That "forwards" name is a little silly
20:39:45 <Luke> yeah
20:39:46 <Cale> It should be runBackwards
20:39:50 <Luke> i didn't know what to use that for
20:39:51 <Luke> haha
20:40:22 <Cale> oh, oops
20:40:26 <Cale> I accidentally a paren
20:40:35 <Cale> The (Just t) should be outside
20:41:06 <Luke> ah
20:44:27 <Luke> Cale: i have no idea how that works but thanks! it at least compiles!
20:44:44 <Cale> er, I would've explained it...
20:45:08 <_flatline_> Is it possible to use ANY precompiled statements with SQLite?
20:58:47 <owlglass> I want to wrap list in a newtype so I can write my own monoid instance, but I'd also like it to be a functor. I can write a monoid instance for newtype T = T [Int], but I can't derive or write my own functor instance since it doesn't take a type parameter. what's the usual way around this?
21:00:03 <Total_1mmersion> Has anyone written a toy compiler with SSA/type checking/code generation before? I'm in the process of writing one myself and after finishing SSA generation and starting type checking, I'm realizing that my data structure for the SSA is difficult to work with. The SSA statements are parameterized by some extra information which I figured could be used for adding type and register information. Now I would like to make a pass thr
21:01:23 <jle`> owlglass: T [Int] can't be a functor
21:01:28 <jle`> er, T = T [Int]
21:01:55 <jle`> the kind mismatch aside, how would you fmap something like `show` onto it?
21:02:25 <jle`> and regarding kind mistatch, look at the type signature of fmap
21:02:26 <jle`> :t fmap
21:02:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:02:33 <jle`> T can't be a functor
21:02:45 <jle`> because you apply f to a, it makes no sense to have T a
21:03:10 <jle`> the best you can probably do to be able to 'map functions' over your T would be to make it an instance of MonoTraversable
21:03:39 <jle`> which is something that you can only map functions of a certian type a, (a -> a) over
21:03:56 <jle`> https://hackage.haskell.org/package/mono-traversable-0.4.0.4/docs/Data-MonoTraversable.html
21:04:10 <fread2282> @src foldr1
21:04:10 <lambdabot> foldr1 _ [x]    = x
21:04:10 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
21:04:10 <lambdabot> foldr1 _ []     = undefined
21:05:03 <fread2282> @src foldl1
21:05:03 <lambdabot> foldl1 f (x:xs) = foldl f x xs
21:05:03 <lambdabot> foldl1 _ []     = undefined
21:05:35 <fread2282> @src foldl1'
21:05:35 <lambdabot> Source not found. Take a stress pill and think things over.
21:07:53 <owlglass> jle` thanks, that makes a lot of sense
21:08:36 <jle`> oh i'm not sure if it was clear, but you can't map show onto your ints because it'll turn it into a list of strings, but T can only hold a list of Ints
21:15:08 <owlglass> yep, makes sense. my thinking was that I wanted an mappend different from [], but didn't want to have to unwrap and wrap just to fmap over it. monofunctor looks like what I want.
21:15:45 <owlglass> thanks for your help
21:31:31 <stolaruk> Is an arbitrary "Text" binding typically "xs" or "x"?
21:35:41 <bms1> stolaruk: I think it's "t"
21:36:02 <stolaruk> bms1: Yeah that would make more sense wouldn't it :)
21:36:17 <bms1> http://hackage.haskell.org/package/text-0.11.2.0/docs/src/Data-Text.html
21:37:09 <stolaruk> Ah yes
21:51:07 <SrPx> Is there a shortcut for (case a of {(Foo _) -> True; (Bar _) -> False}) ?
21:53:05 <srh_> case a of {(Foo _) -> True; _ -> False})
21:53:26 <srh_> define an isFoo function and use it
21:53:37 <SrPx> okay, ty
21:54:05 <johnw> if you use lens, you can say: has _Foo
21:54:11 <SrPx> oO
21:54:19 <johnw> presuming you makePrisms ''YourType
21:54:38 <SrPx> does lens use template haskell?
21:54:40 <srh_> or like, maybe you actually want to use the Maybe monad with do notation.  do { Foo _ <- blah; ... }   (unless my memory is screwing with me)
21:54:44 <johnw> for this, yeah
21:54:51 <johnw> but the core of lens doesn't
21:54:57 <SrPx> I see, interesting
21:55:25 <supki> SrPx: you can write a Prism yourself if you don't like TH, see  prism  (and  prism')
21:55:33 <supki> it's even not that painful
21:57:44 <SrPx> so, what if I have a type constructor in a variable (I will send it to a function) and want to test if an element has that type constructor?
21:58:18 <SrPx> I guess v = Foo; case a of {(v x) -> True; _ -> False} won't work
21:58:19 <startling> SrPx: that's not something you can do.
21:58:21 <shachaf> You don't even need a Prism for has.
21:58:27 <SrPx> ):
21:58:34 <startling> SrPx, but you can use traversals for that!
21:58:55 <startling> (and prisms too)
21:59:41 <SrPx> Is there another way to avoid duplicating a 15 lines long function which the only difference between the them is the type constructor used in one of the lines?
22:01:08 <SrPx> as in, one function is (fun (A x) = ...; fun (B x) = ...; fun (C x) = ...;) and other function is (fun (K x) = ...; fun (B x) = ...; fun (C x) = ...;) the only difference being that one uses A and other uses K in that line?
22:01:23 <mmachenry> SrPx:  Yeah you can make two wrappers and given them different types.
22:01:35 <SrPx> pardon?
22:01:45 <mmachenry> Can you paste bin the two funcs?
22:02:24 <mmachenry> Oh I think you need to pass in a function that get's x from your datatype.
22:04:19 <SrPx> mmachenry: http://lpaste.net/103330 the algorithm to apply a function to a value is exactly the same algorithm to expand a recursion point... notice my solution to this is using a boolean variable, "fix", to determine what is the actual use case... then I have a guard on lines 8-12 so I only have to duplicate those lines
22:04:39 <SrPx> that is kinda unelegant and unreadable, though
22:04:54 <SrPx> lpaste breaks my indentation ):
22:05:35 <cin> tabs break your indentation
22:05:54 <cin> don't use tabs if you want life to be easy
22:05:57 <SrPx> it is the only way I know on VIM ...
22:06:22 <mmachenry> SrPx: http://lpaste.net/103332
22:06:26 <SrPx> spaces are lame, you can't untab by pressing backspace on them... too many keypresses
22:06:44 <mmachenry> In my example it's not really worth it because x+1 is a small expression but you get the idea
22:06:58 <kadoban> SrPx: sure you can if your editor isn't bad
22:07:39 <SrPx> kadoban: vim isn't good enough for you.?
22:07:56 <kadoban> SrPx: vim untabs with backspace, with tabs as spaces...
22:07:58 <SrPx> mmachenry: hmm I think so, let me think
22:07:59 <SrPx> thanks
22:08:51 <kadoban> SrPx: I think emacs does too, but I neven use that... You probably have to set up vim correctly to do it, but it's just to usual tab settings do it, I didn't do anything special.
22:09:20 <mmachenry> SrPx: I'm sorry I cannot allow you to think.
22:10:10 <SrPx> mmachenry: then I will never know
22:10:28 <SrPx> kadoban: I never had any problem with tabs other than people complaining, though ...
22:10:43 <SrPx> one day I'll find a way to use spaces on vim
22:10:47 <SrPx> one day...
22:11:58 <kadoban> SrPx: The only problem is that different tools decide they're different amounts of space, so it ends up looking like crap somewhere, but fine elsewhere, etc.
22:12:50 <kadoban> But I don't really have a problem with either, just use spaces myself usually *shrug*
22:19:54 <ReinH> It's easy to use spaces. :help expandtab and :help softtabstop
22:22:11 <_flatline_> So I have a list of IO strings and I need to do stuff with all of them
22:22:46 <_flatline_> But whenever I try to bind them to a list using sequence, I get a SqlError (I'm using HDBC)
22:23:13 <dmj`> _flatline_: what db are you using
22:23:19 <_flatline_> There are no runtime exceptions before this particular point and I have no idea why this is happening
22:23:20 <_flatline_> sqlite
22:24:24 <dmj`> _flatline_: explain what you mean by "bind" them to a list
22:24:54 <dmj`> can you show code?
22:26:05 <int-index> Why isn't (Monoid e => Either e a) a MonadPlus?
22:26:28 <int-index> It could be like maybe, but the Lefts would be combined with mappend (and mzero is Left mempty)
22:27:00 <int-index> Does such a definition break any MonadPlus law?
22:27:07 <_flatline_> dmj` http://pastebin.com/dKnLMY51
22:27:25 <_flatline_> I know this is hideous, but I need to figure it out before I refactor
22:29:34 <_flatline_> ending has type String -> IO String
22:31:47 <dmj`> _flatline_: have you considered using more modern db bindings?
22:31:58 <_flatline_> What do you mean?
22:32:45 <dmj`> _flatline_: if you use groundhog you get an ORM, does auto-migrations and has a DSL for writing type safe sql queries / updates
22:32:59 <joelteon> i'd just like to express my gratitude that strings and bytestrings in haskell are different
22:36:24 <_flatline_> it's probably too late for me to switch to something else at this poitn
22:41:14 <bergmark> _flatline_: can you trace the fromSql call that fails?
22:42:01 <bergmark> perhaps there's a null?
22:42:45 <bergmark> you're also using head which is unsafe, why not map head words => mapMaybe headMay words?
22:44:05 * hackagebot warp 2.1.5.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.5.1 (MichaelSnoyman)
22:47:47 <orion> inet_ntoa has type HostAddress -> IO String. How do I write a pure function which converts a HostAddress to a String?
22:50:01 <supki> @tell int-index it breaks  v >> mzero = mzero  :  Left "foo" >> Left mempty = Left "foo"
22:50:01 <lambdabot> Consider it noted.
22:55:29 <zipper> Can I get a lazy readfile for text?
22:55:45 <johnw> Data.Text.Lazy.readFile
22:57:14 <zipper> johnw: Thanks :)
22:57:51 <zipper> johnw: You were messing with me
22:58:04 <johnw> that isn't what you wanted?
22:59:12 <zipper> It's in Data.Text.Lazy.IO.readfile
22:59:17 <johnw> ah
22:59:37 <zipper> When I looked for it in Text.Lazy and couldn't find it I thought you were messing with me.
22:59:42 <zipper> :t Data.Text.Lazy.IO.readfile
22:59:43 <lambdabot> Not in scope: ‘Data.Text.Lazy.IO.readfile’
22:59:56 <benbangert> zipper: my doc search tool usually resolves little things like that for me
23:00:12 <benbangert> assuming its in the 'prelude' so that it appears in my search...
23:00:18 <zipper> How come Lambdabot can't find it
23:00:27 <benbangert> hoogle should've found it
23:00:28 <zipper> http://hackage.haskell.org/package/text-0.7.1.0/docs/Data-Text-Lazy-IO.html
23:00:51 <zipper> I can see it exists at http://hackage.haskell.org/package/text-0.7.1.0/docs/Data-Text-Lazy-IO.html but lambdabot can't find it
23:05:50 <bergmark> zipper: that's an old version of text, is it in 1.1?
23:06:56 <zipper> bergmark: The one with readFile?
23:07:35 <zipper> bergmark: Are you saying that Data.Text.Lazy.IO is deprecated?
23:13:08 <bergmark> zipper: no it seems not, but it wouldve explained why lambdabot couldn't find it :)
23:13:23 <zipper> bergmark: I see
23:13:42 <zipper> Best way to convert string to lazy bytestring?
23:14:08 <bergmark> pack
23:14:22 <jtcwang> pack?
23:14:23 <johnw> encodeUtf8 . pack
23:14:44 <bergmark> oops misread that :-)
23:15:00 <zipper> bergmark: pack doesn't take string
23:15:12 <zipper> johnw: Which pack is that?
23:15:17 <bergmark> http://www.haskell.org/hoogle/?hoogle=pack
23:15:30 <bergmark> there's the utf8-string package for this also
23:15:39 <zipper> I was thinking of overloading strings then using lazy text to lazy bytestring
23:19:53 <maxx--> hello. what haskell platform do you recommend I should install on linux? there are several: precise, quantal, saucy and trusty
23:20:05 <johnw> Data.Text.LAzy.pack
23:21:13 <Ralith> 											
23:23:20 <maxx--> also, should I get them from haskell website or with apt-get?
23:29:33 <NinjaPenguin> maxx--: Those sound like Ubuntu's versions.
23:29:59 <NinjaPenguin> maxx--: You should most of the time prefer apt-get because it gets you the one that's "designed" for your operating system.
23:33:38 <arj> maxx--: just run "sudo apt-get install haskell-platform"
23:39:13 * hackagebot hblas 0.3.0.0 - Human friendly BLAS and Lapack bindings for Haskell.  http://hackage.haskell.org/package/hblas-0.3.0.0 (CarterSchonwald)
23:39:47 <carter> :)
23:40:06 <carter> i'm hoping to write an offcial ANN: numerical haskell email this week :)
23:42:42 <pqmodn> @unmtl ErrorT e (Writer w) a
23:42:42 <lambdabot> (Writer w) (Either e a)
23:42:46 <pqmodn> @unmtl (Writer w) (Either e a)
23:42:47 <lambdabot> (Writer w) (Either e a)
23:42:49 <pqmodn> @unmtl Writer w (Either e a)
23:42:49 <lambdabot> ((Either e a), w)
23:42:52 <pqmodn> :-\
23:43:10 <pqmodn> am i doing it wrong?
23:43:30 <pqmodn> or do the parens just confuse unmtl?
23:44:53 <fizruk> does anyone have good literate haskell highlighting in vim?
23:45:32 <carter> fizruk: i think its call latex? :)
23:46:46 <fizruk> carter: no, latex does not highlight haskell code, on the contrary it marks all underscores in it as invalid
23:46:54 <carter> :*(
23:47:10 <fizruk> i guess the one on the wiki page should work, but I thought I already have that…
23:47:21 <carter> in the text editor I use, it handles begine / end code blocks as haskell quite nicely
23:49:38 <fizruk> oh i had markdown literate haskell syntax file in vim2hs…
23:51:00 <startling> carter: nice!
23:51:41 <carter> startling: the v0.3 is basically the same as 0.2, but with a cleaner organization so the haddocks don't spam you
23:51:53 <carter> fuck, forgot a change log :)
23:52:01 <startling> carter, I didn't know haddock was *that* bad
23:52:23 <carter> startling: look at the http://hackage.haskell.org/package/hblas-0.2.0.0/docs/Numerical-HBLAS-BLAS.html
23:52:36 <carter> vs once the docs for the same module in v0.3
23:52:42 <carter> startling: are you on a mac or linux?
23:52:48 <startling> os x, yes
23:52:56 <carter> cabal update ; cabal install hblas
23:53:01 <carter> then look at the haddocks for 0.3
23:53:04 <carter> for the same module
23:53:06 <carter> its much simpler
23:53:10 <carter> and nicer
23:53:30 <startling> carter: the usual way you solve that problem, I think, is those comments that start with -- |
23:53:34 <carter> yes
23:53:40 <startling> :)
23:53:45 <carter> startling: no
23:53:51 <carter> first look at the 0.3 haddocks
23:53:55 <carter> i wrote LOTS of comments in the source
23:54:01 <startling> ah
23:54:04 <carter> just not haddock style ones
23:54:18 <carter> but the api looks less spammy in the 0.3 version
23:54:19 <carter> look
23:54:24 <carter> cabal install it
23:54:25 <carter> :)
23:54:49 <carter> startling: better yet, its built ! http://hackage.haskell.org/package/hblas-0.3.0.0/docs/Numerical-HBLAS-BLAS.html
23:55:29 <startling> neat!
23:55:43 <carter> see why i was saying v0.3 has better haddocks?
23:56:38 <carter> vs the 0.2?
23:57:02 <carter> still not very good docs mind you
23:57:06 <carter> but def better
23:59:20 <carter> (am i making sense)
23:59:23 <carter> its 3am over here
