00:08:09 * hackagebot antigate 2.0.1 - Interface for antigate.com captcha recognition API  http://hackage.haskell.org/package/antigate-2.0.1 (MikhailKuddah)
00:08:09 * hackagebot soap 0.2.2.2 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.2.2 (AlexanderBondarenko)
00:29:30 <pavonia> @hoogle Ord c => c -> c -> c -> Bool
00:29:31 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
00:29:31 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Color3 :: a -> a -> a -> Color3 a
00:29:31 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
00:30:27 <pavonia> Is there no predefined function for "\lo hi x -> x >= lo && x <= hi"?
00:33:06 <srhb> pavonia: If Hoogle says no, then not in base.
00:33:46 <supki> :t inRange
00:33:47 <lambdabot> Ix a => (a, a) -> a -> Bool
00:34:08 <pavonia> Huh, what is Ix?
00:34:12 <srhb> Oh dear
00:34:20 <supki> Data.Array thing
00:34:21 <shachaf> A class for things that you can use as array indices.
00:35:21 <pavonia> Ah, I heard of this before long, long time ago
00:35:49 <srhb> I guess it's fine if you're using Integer or something.
00:37:12 <pavonia> > inRange ('a', 'f') 'c'
00:37:13 <lambdabot>  True
00:42:25 <tdammers> it'll bite you when you use floats
00:42:47 <tdammers> (or rather, it *could*)
00:53:19 <srhb> Floats have an Ix instance? :|
00:56:56 <johnchen902> @
00:56:59 <johnchen902> @?
00:57:07 <johnchen902> @help
00:57:08 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:57:16 <johnchen902> @list
00:57:17 <lambdabot> What module?  Try @listmodules for some ideas.
00:57:28 <johnchen902> @help list
00:57:28 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
00:57:57 <haasn> What does “cons” actually stand for? Where does the term originate from?
00:59:03 <johnchen902> @pl step1 n k s 	| k == 0 = forward n k s 	| k == n - 1 = backward n k s 	| k + k < n = "LEFT\n" ++ step1 n (k - 1) s 	| otherwise = "RIGHT\n" ++ step1 n (k + 1) s
00:59:03 <lambdabot> (line 1, column 27):
00:59:03 <lambdabot> unexpected " "
00:59:03 <lambdabot> expecting operator
01:00:17 <tdammers> haasn: lisp
01:00:31 <tdammers> haasn: IIRC it's short for "construct"
01:00:33 <haasn> tdammers: I figured it out, wiktionary says “construct”
01:00:36 <haasn> yes
01:00:59 <tdammers> as in "construct a car/cdr pair"
01:01:29 <tdammers> come to think of it, dynamic languages haven't really improved an awful lot since the 1950s
01:01:59 <johnchen902> \n k s -> case() of _	| k == 0 -> forward n k s 	| k == n - 1 -> backward n k s 	| k + k < n -> "LEFT\n" ++ step1 n (k - 1) s 	| otherwise = "RIGHT\n" ++ step1 n (k + 1) s
01:02:23 <johnchen902> @pl \n k s -> case() of _ | k == 0 -> forward n k s | k == n - 1 -> backward n k s | k + k < n -> "LEFT\n" ++ step1 n (k - 1) s | otherwise -> "RIGHT\n" ++ step1 n (k + 1) s
01:02:24 <lambdabot> (line 1, column 17):
01:02:24 <lambdabot> unexpected ' '
01:02:24 <lambdabot> expecting variable, "(", operator or end of input
01:02:30 <lfairy> tdammers: I think JITs have gotten better
01:02:56 <tdammers> lfairy: implementations are obviously faster, sure
01:03:01 <lfairy> that's just implementation though
01:03:05 <lfairy> yeah
01:03:06 <tdammers> but the languages themselves, dunni
01:03:09 * hackagebot snap-cors 1.2.3 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.2.3 (OliverCharles)
01:03:09 <tdammers> *dunno
01:03:40 <tdammers> if you compare, for example, how Scheme handles runtime type checks, and how other languages do it, I can't help but think that Scheme does it better
01:04:03 <tdammers> == vs. === and all that nonsense
01:07:24 <mjrosenb> tdammers: python added list comprehensions! and neuered lambdas!
01:07:53 <tdammers> neuered lambdas?
01:07:55 <tdammers> what's that?
01:08:36 <tdammers> (oh, and list comprehensions - basically just some sugar over map and filter)
01:09:23 <Maior> python has had list comprehensions for some time...
01:09:31 <mjrosenb> tdammers: yes, it is sugar, but it is nice sugar
01:09:45 <mjrosenb> Maior: "quite some time", yes, but much more recent than 1950.
01:09:50 <Maior> mjrosenb: oh ok
01:10:11 <mjrosenb> tdammers: they neutered lambdas, you can only have a single expression inside of one, etc.
01:10:26 <mjrosenb> tdammers: and concat.
01:11:32 <tdammers> oh, "neutered", as in "crippled"
01:11:40 <tdammers> that's not exactly a feature now, is it
01:11:42 <tdammers> more like a wart
01:11:59 <tdammers> and uh, how do list comprehensions concatenate?
01:12:12 <fragamus> inp
01:12:13 <fragamus> knp
01:12:14 <Yuu_chan> tdammers: Python type check is arguably fine, IMO
01:12:31 <tdammers> Yuu_chan: mostly, yes, except for the mutability thing
01:12:55 <tdammers> Yuu_chan: i.e., you can change the semantics of a function by passing a different type of argument
01:12:59 <fragamus> ignore previous input    that was meant for a game on plato
01:13:42 <tdammers> Yuu_chan: PHP and JavaScript are arguably worse, I give you that
01:14:13 <Yuu_chan> tdammers: don't tell me these sweary words ._.
01:15:36 <Yuu_chan> A friend of mine, who strangely moved into web programming from C++, truly HATES weak typing and implicit casts
01:16:21 <tdammers> they're not wrong per se, they just optimize for a particular development style and project phase
01:16:50 <tdammers> dynamic types are great for quick prototyping, and as long as the entire project fits into the programmer's head at once, all is fine
01:16:59 <Yuu_chan> tdammers: sorry, but I didn't understand your example with different type of argument and what it has to do with mutability
01:17:05 <tdammers> ah
01:17:15 <lfairy> tdammers: try [x for xs in xss for x in xs]
01:17:30 <Yuu_chan> You pass differently typed arguments in Scheme all the time, don't you?
01:18:04 <Yuu_chan> lfairy: that's still not composable enough
01:20:04 <lfairy> there's the funny xs += [1,2,3] modifies in-place for lists, but creates a new value for tuples
01:20:44 <Yuu_chan> lfairy: it's clearly said in the documentation that tuples are immutable
01:21:00 <palo_> Question: I have a IORef Task and want to access the task in a where or let block
01:21:31 <lfairy> Yuu_chan: yes, but we would expect x += y to desugar to x = x + y
01:21:36 <Yuu_chan> (and given the language dynamic nature, that's one of few differences between them)
01:21:51 <lfairy> the fact that it doesn't is the funny bit
01:22:42 <Yuu_chan> lfairy: if I get it right, it still desugars this way in case of tuples
01:22:43 <shachaf> whoa, whoa, whoa. Python does that? That's unexpected.
01:22:53 <tdammers> Yuu_chan: the problem is that if a function takes an argument and does stuff with it, such as in-place modification, it depends on the type of the argument whether this modification is in-place (amounting to a side effect) or acts upon a local copy (which would keep the function pure on the outside)
01:22:54 <Yuu_chan> Or not, I get it wrong
01:23:13 * Yuu_chan begins to torture IDLE
01:24:17 <pjdelport> The entire point of having the inplace assignment operators in Python is to allow mutable objects to implement them efficiently... otherwise there wouldn't be a reason to have them, over "x = x + y".
01:24:30 <lfairy> shachaf: yes
01:24:41 <pjdelport> Python doesn't embrace syntax like that for no reason.
01:26:10 <Yuu_chan> tdammers: what's the difference in argument passing semantics between Scheme and Python?
01:26:34 <tdammers> python has mutable and immutable types
01:26:38 <lfairy> pjdelport: in most languages augmented assignment *is* mere sugar though. When it isn't in Python, it's surprising, efficient or not.
01:26:38 <pjdelport> Python's is a lot more complicated :)
01:27:08 <tdammers> scheme makes a distinction between binding and destructive updates at the syntax level
01:27:17 <pjdelport> Yuu_chan: Python has varargs, keyword argument, and defaulting
01:27:34 <Yuu_chan> Ah, do you mean the difference between define and set?
01:27:45 <tdammers> define, let, yeah
01:28:00 <Yuu_chan> Now I get what you mean, thanks
01:28:00 <tdammers> makes it much easier to keep things pure
01:28:13 <palo_> got it , t <- return $ readIORef tasks
01:28:18 <tdammers> and there's a reason for the ! convention for impure / destructive procedures
01:29:01 <lfairy> palo_: should the return be there? I thought readIORef was in IO already
01:29:07 <tdammers> I think the failure to acknowledge that mutable state is a dangerous thing that deserves safeguards is actually Python's biggest flaws
01:29:11 <tdammers> *flaw
01:29:18 <tdammers> the whole "consenting adults" thing
01:29:35 <Yuu_chan> ...and an even more stronger convention is IO, right? :)
01:29:58 <lfairy> that's a good point -- once I ran into a bug when I used an iterator multiple times
01:30:21 <lfairy> the first use emptied it, so subsequent uses failed silently
01:30:44 <palo_> lfairy: true, i'm a bit confused i mixed stuff , ... its like this now do ; t <- readIORef tasks ; newT <- return $ doSomethingPure t ; writeIORef tasks newT ; return newT ;
01:31:33 <lfairy> palo_: that looks ok, except the pure part can be simplified to: let newT = doSomethingPure t
01:32:25 <palo_> I somehow have a problem wit let. inline in do blocks i always get a parse error at the in part
01:33:02 <lfairy> palo_: post your code on lpaste and link it here
01:33:51 <tdammers> Yuu_chan: well, IO is more than a convention, but its main benefit comes from the fact that Haskell is designed with static type checking in mind; the benefit of something like IO is much much smaller in a dynamically-typed environment
01:35:35 <palo_> lfairy: http://pastebin.com/kSep6uEn
01:35:42 <palo_> lfairy: these are both versions
01:36:05 <Yuu_chan> @hoogle modifyIORef
01:36:06 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
01:36:06 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
01:36:29 <Yuu_chan> Use that, palo_!
01:36:50 <palo_> Yuu_chan: I do also need the result
01:36:59 <palo_> Yuu_chan: but thx
01:37:20 <lfairy> palo_: in a do block, you don't need the "in" afterward
01:38:13 <palo_> lfairy: ah and also no indention.
01:38:32 <palo_> thx lfairy and Yuu_chan  (/me like that community :D)
01:39:26 <exicer> Has anyone got much experience with using haskell from within python?
01:39:42 <tdammers> exicer: not really. What's your use case?
01:39:50 <lfairy> exicer: I don't think anyone's tried it
01:40:05 <Yuu_chan> palo_ do {<...>; let a = b in do {<...>}} is equivalent to do {<...>; let a = b; <...>}
01:40:27 <Yuu_chan> So I guess your first sample needed a nested do-block
01:41:28 <palo_> Yuu_chan: btw i like the modifyIORef version now better, it also makes it obvious that i'm changing the IORef state.
01:41:58 <Yuu_chan> That's the point!
01:42:12 <tdammers> I think those who combine the two languages would typically take a per-process approach
01:42:28 <tdammers> i.e., implement one part in python, one part in haskell, and string them together at the process level
01:42:53 <tdammers> most likely, you'll have a python host application that runs the haskell program as a subprocess
01:42:59 <Yuu_chan> appendTasks <...> = do {modifyIORef tasks (flip addTasks tasksToAppend); readIORef tasks}
01:43:39 <pjdelport> exicer: There is https://github.com/sakana/HaPy
01:44:18 <lfairy> Haskell supports JSON serialization via aeson, so that's a good route
01:44:41 <exicer> tdammers: Basically, my supervisor's project is written in python. It is essentially a GUI with some extra capability. I'm currently writing new stuff to go into this GUI, but I would much prefer to do it in haskell.
01:45:28 <exicer> I think calling python should be pretty straightforward, but I wouldn't know how to even start distributing the code
01:45:42 <exicer> Most people using the software are not overly technical
01:46:23 <lfairy> GHC links statically by default, so just bundle the binary
01:47:03 <pjdelport> There's http://hackage.haskell.org/package/MissingPy too, in the other direction.
01:47:34 * Yuu_chan requests the MissingNo package
01:47:46 <exicer> Hmm, interesting
01:48:13 <bennofs> Is there a framework for running "bigger" benchmarks that don't need to be repeated very often? (It seems that criterion is designed for running "micro" benchmarks that need to repeated very often)
01:52:56 <augur> AHHHH
01:52:58 <augur> i finally understand how the SKI calculus works!
01:53:00 <augur> :OOOOOO
01:53:22 <companion_cube> :D
01:53:30 <augur> :)
01:53:49 <augur> like, i understood the formal junk, but i never really understood the _why_ of the SKI calculus
01:53:52 <augur> and now i do!
01:54:14 <Yuu_chan> augur: now you can write in Unlambda!
01:54:17 <augur> its so simple and elegant once you look at it from a categorical perspective!
01:54:21 <augur> Yuu_chan: haha, no. :)
01:54:37 <Yuu_chan> categorical?.. Tell me moar!
01:54:47 <augur> the thing about SKI is that if you throw types on it, and squint, its _just_ just the LC
01:54:57 <tdammers> if you can write in unlambda, does that mean you can also unwrite in lambda?
01:55:00 <augur> i dont mean kinda, i mean, its just the LC in categorical terms
01:55:10 <augur> Yuu_chan: so SKI with types is
01:55:14 <augur> I : A -> A
01:55:19 <augur> K : A -> B -> A
01:55:31 <augur> S : (A -> B -> C) -> (A -> B) -> A -> C
01:55:38 <prophile> SKI is just a special case of Applicative
01:55:42 <augur> well, forall those if you want, actually. it works better
01:56:07 <augur> Yuu_chan: so now, let's consider renaming these a wee bit
01:56:12 <augur> I : a -> a
01:56:18 <augur> K : g -> a -> g
01:56:31 <augur> S : (g -> a -> b) -> (g -> a) -> (g -> b)
01:57:20 <augur> now, let's put on our category theory glasses and remember that a term   Γ ⊢ M : A   in CT terms is an arrow   M : Γ -> A
01:57:34 <augur> and now lets consider how we get variables in categorical logic:
01:57:44 <augur> well, we use de bruijn indices on the context
01:58:04 <augur> we have 0 : A -> A   which just picks the one var in the context
01:58:18 <Yuu_chan> tdammers: if augur is self-adjoint, he can lambda in unwrite
01:58:22 <augur> or maybe we call it here : A -> A to be nicer
01:58:44 <augur> there : Γ × A -> Γ
01:58:56 <augur> which pops the top item off the context
01:59:07 <Yuu_chan> augur: my category theory glasses are still too blurry :( But I'll try to understand.
01:59:10 <merijn> ok, so I realise that making haskell total would disallow implementing something like fix, but what (if anything) would break if we dropped partial pattern matches, undefined and error and the only bottom allowed was infinite recursion?
01:59:29 <merijn> Would anything break? Would we just have a slightly less expressive haskell?
01:59:39 <augur> for convenience actually lets pretend its not I : A -> A but instead H : A -> B -> B
01:59:46 <augur> which is obviously a generalization
01:59:55 <augur> top : Γ × A -> A
02:00:13 <augur> er, here, not top
02:00:15 <augur> doh.
02:00:19 <augur> so we can pick out anything in the context by composing 'here' and 'there'
02:00:25 <quchen> merijn: And everything that throws would get a Maybe type?
02:00:50 <quchen> Asynchronous exceptions are out
02:01:03 <augur> for instance if our context is A × B × C and we want to get out the B element, we pop the C and take the top element
02:01:25 <augur> A × B × C ---there---> A × B ---here---> B
02:01:26 <Yuu_chan> augur: why is H a generalization?
02:01:32 <merijn> quchen: Right
02:01:32 <lfairy> ooh ooh ohh so K is the pop thing?
02:01:42 <augur> Yuu_chan: well, its obviously just id, but with an extra arg it ignores
02:01:44 <augur> its kinda KI
02:01:48 <augur> actually it is KI
02:01:49 <augur> :p
02:02:00 <Yuu_chan> To me it looks like flip K
02:02:06 <augur> Yuu_chan: its that too! :)
02:02:16 <augur> so   here∘there : A × B × C -> B
02:02:16 <Yuu_chan> Hmm
02:02:26 <augur> which is just the deBruijn term for that var
02:02:38 <augur> ok good, so we got vars with K and H (== KI)
02:02:41 <merijn> quchen: I'm thinking of playing around with my own language, and haskell's partial functions annoyed me a lot, so I wonder if I could eliminate that annoyance. I just don't wanna go all the way and implement a completely total language
02:02:45 <augur> ok now what?
02:02:52 <augur> well, lets consider how application works in categorical logic
02:02:54 <augur> hmmmm
02:03:10 <merijn> quchen: Well, maybe I do, but I'm guessing a total language may be trickier to implement than a "less-partial" one :p
02:03:51 <augur> F : Γ ⊢ A -> B   and   X : Γ ⊢ A   yields App(F,X) : Γ ⊢ B
02:04:05 <shachaf> merijn: "disallow things like fix" isn't the complete story.
02:04:23 <Yuu_chan> augur: so it's like redefining abstraction and application in terms of combinators, and how you can express "anything" with them?
02:04:23 <augur> but what is App categorically, well, its actually App(F,X) = ev ∘ <F,X>
02:04:26 <merijn> shachaf: Right, hence why I'm asking what else would break :)
02:04:35 <shachaf> merijn: A total language can allow things like fix, just like Haskell can allow IO.
02:04:42 <merijn> shachaf: I know that too
02:04:46 <augur> but hey wait a second, if we translate the logic symbols to arrows...
02:05:06 <augur> F : G -> A -> B   and   X : G -> A   yields   App(F,X) : G -> B
02:05:07 <bennofs> merijn: why would it disallow fix?
02:05:08 <augur> App = S!
02:05:19 <augur> Yuu_chan: not even!
02:05:26 <merijn> bennofs: Because fix by definition lets you write non-total functions?
02:05:42 <augur> Yuu_chan: it turns out that its more or less exactly the categorical interpretation of the LC _on the nose_
02:05:51 <merijn> bennofs: "fix id" <- there you go, non-total function
02:05:52 <lfairy> augur: woah
02:05:56 <bennofs> merijn: but I thought you wanted to allow infinite recursion?
02:06:40 <augur> we dont need our "currying" or "lambda abstraction" combinator here because everything is already just arrows all the way down, no pairs, so its all already lambda abstracted, really
02:06:41 <merijn> bennofs: I said "implementing a total language would disallow fix", hence why I was asking if there was a sensible way of specifying a language whose only bottom is infinite recursion
02:06:54 <shachaf> Yes, he didn't want to ban fix.
02:07:05 <merijn> I'm not sure that idea makes any sense, though
02:07:16 <augur> Yuu_chan, companion_cube, lfairy: does that make sense?
02:07:26 <lfairy> surprisingly, it does
02:07:30 <augur> :D
02:07:44 <augur> i like to imagine that H is really the better combinator to have, in place of I
02:07:49 <augur> tho we know I is redundant anyway
02:07:56 <augur> but if you're gonna have it, better to swap it for H
02:07:57 <merijn> Although, if someone tells me that making a language total is only epsilon more difficult from making a non-total language, I'd be game for just stuffing fix in the sin-bin like a partial monad
02:08:36 <shachaf> Making a language really total and also useful has all sorts of complications.
02:08:58 <augur> this is SUCH a weight off my shoulders. now i know the One True Translation technique to get from the LC to SKI
02:09:17 <Yuu_chan> augur: I bit more than I can chew
02:09:20 <augur> namely, just do the proof for the lambda term and it _is_ the lambda term, almost :D
02:09:21 <shachaf> (I would also call the Haskell way of doing IO "all sorts of complications", of course.)
02:09:28 <augur> minus all the indexation
02:09:49 <augur> thats really what it amounts to -- the lambda term minus the names
02:10:33 <augur> this is also really fun because i get to write a little thing about this and complain about how "variable free" semantic theories of natural language kind of really arent :x
02:10:52 <merijn> shachaf: Right, that's what I figured. Actually, I think even error/undefined won't be such a problem to allow in my case, if I just replace them with more useful behavior than haskell's "crash" :)
02:11:12 <shachaf> What's a more useful behavior?
02:11:26 <augur> i should also write that thing on categorical semantics too. that'd be helpful im sure
02:11:27 <merijn> shachaf: Dropping into a debugger and letting you unwind your code
02:12:05 <shachaf> A good Haskell debugger is probably an even more complicated problem. :-)
02:12:08 <lfairy> augur: sounds like it'd make a good blog post
02:12:15 <shachaf> The idea of undefined/error/etc. is to improve on the failure mode of going into an infinite loop.
02:12:16 <merijn> shachaf: I'm not planning to do this in haskell
02:12:44 <shachaf> Well. For any non-strict language, I think.
02:12:51 <augur> lfairy: meh. i like to have fancy symbols and code coloring
02:13:01 <augur> latex + pdf's is the only way!
02:13:05 <merijn> shachaf: hmm, that's true
02:13:16 <shachaf> If you're OK with error/undefined, are you just talking about disallowing partial matches?
02:13:20 <merijn> I didn't really think about the laziness aspect too much
02:13:25 <shachaf> Partial matches are already disallowed.
02:13:32 <shachaf> ghc -Wall -Werror
02:14:24 <merijn> shachaf: I know how to do that in haskell :) I was just curious about more theoretical implications. But you raised a more critical point, laziness makes a debugger tricky
02:14:36 <merijn> Which means I need to reevaluate the desire for laziness
02:14:44 <lfairy> augur: as the great Mexican once said, why not both? mathjax+pygments is great
02:14:52 <augur> horrible
02:15:04 <Yuu_chan> merijn: do you dislike existing embodiments of total FP?
02:15:08 <augur> cant even say it in spanish
02:15:09 <lfairy> to each their own...
02:15:12 <augur> whats pygments
02:15:22 <augur> oh its some python thing
02:15:26 <merijn> Yuu_chan: No, but they're utterly unsuitable for what I want to do :)
02:15:26 <augur> my blog is php :(
02:15:35 <augur> well, my server
02:15:47 <augur> i dont know if i can get python installed
02:15:58 <mgdm> you could embed Github gists
02:16:03 <merijn> Well, my Idris can be coerced into it, but it's not really designed for low-level work
02:16:06 <mgdm> I've done that from time to time on a PHP blog
02:16:08 <augur> someone should really make a latex->html thing
02:16:09 <lfairy> you use php for your blog? oh dear
02:16:17 <augur> mgdm: yeah but i need fancy stuff not just a gist
02:16:23 <prophile> augur: pandoc :D
02:16:23 <Yuu_chan> augur: thanks for a comprehensive explanation, but that's really too hard to me at this point :'( I'll save that and someday will try to grok again.
02:16:25 <augur> lfairy: well i use wordpress
02:16:25 <merijn> Essentially what I want is a statically typed lisp machine :p
02:16:27 <quchen> augur: Pandoc?
02:16:39 <mgdm> augur: ah, more than syntax colouring etc?
02:16:46 <augur> quchen: does pandoc give me good latex-y stuff? i think not!
02:16:52 <augur> aint no inference rules in pandoc!
02:16:57 <augur> edsko: !
02:17:09 <quchen> augur: Latex doesn't give you *good* latex-y stuff either ;-)
02:17:10 <augur> edsko: i groked the SKI calculus using category theory :D
02:17:19 <augur> quchen: shut up yes it does :|
02:17:22 <shachaf> merijn: In a total language, laziness doesn't affect semantics!
02:17:33 <Yuu_chan> merijn: is lisp low-level enough?
02:17:45 <augur> so, heres another question
02:17:54 <merijn> Yuu_chan: Considering people have in fact implemented and worked on lisp machines, yes.
02:18:14 <augur> does anyone know how much pattern matching contributes to the power of the LC?
02:18:32 <augur> by pattern matching i dont mean on constructors, per se
02:18:51 <edsko> augur: was that meant for me?
02:18:57 <augur> edsko: yes :p
02:19:03 <tdammers> merijn: by that logic, BASIC is also a low-level language, because they sold machines with a ROM BASIC interpreter
02:19:04 <merijn> augur: Pattern matching can be translated in several different ways to UTLC, so it contributes pretty much no power, afaict
02:19:24 <augur> edsko: you're all CS-y and you maintain the Catsters info thing, so im letting you know! for no real reason!
02:19:26 <merijn> tdammers: Designing basic to work as a low level language is considerably easier than Agda
02:19:28 <Yuu_chan> merijn: is UT for un-typed?
02:19:33 <merijn> Yuu_chan: yeah
02:19:36 <augur> merijn: what i mean is in the evaluator, wherein you have to have schematic variables for beta
02:19:37 <edsko> augur: aha, I was wondering :)
02:20:21 <augur> merijn: that is to say, you have to inspect your term and notice that it has the shape App (Lam b) a
02:20:34 <edsko> augur: using category theory to understand SKI.. sounds like you like pain :p
02:20:35 <augur> as opposed to some other shape, and only then can you reduce
02:20:37 <Yuu_chan> augur: seems your appearance distracted him from me :)
02:20:45 <augur> edsko: actually it turns out to be remarkably simple
02:20:55 <Yuu_chan> Now I mix nicknames too...
02:21:03 <augur> edsko: i mean, provided you either use the STSKI calculus
02:21:28 <merijn> tdammers: Really any language with automatic memory management is a bit tricky unless you can find a nice way to expose manual memory management primitives in the language
02:21:39 <augur> edsko: the untyped version is crazy but you can recover the gist of it from the ST version
02:21:47 * Yuu_chan likes the „Catster“ term
02:22:04 <augur> Yuu_chan: https://www.scss.tcd.ie/Edsko.de.Vries/ct/catsters/linear.php
02:22:13 <augur> oh right, thats moved
02:22:21 <augur> i need to fix that bookmark
02:22:27 <augur> https://www.scss.tcd.ie/~devriese/ct/catsters/linear.php
02:22:42 <augur> edsko: why'd your site move? :\
02:23:08 <Yuu_chan> yaaaay
02:23:36 <edsko> augur: probably the better link is http://simonwillerton.staff.shef.ac.uk/TheCatsters/
02:23:51 <merijn> btw, any STG experts around? I'm not sure I understand the difference between updateable and non-updateable closures?
02:23:58 <edsko> don't know why my site moved, I no longer work in Trinity
02:24:12 <Yuu_chan> Big thanks for the link!!
02:24:18 <augur> edsko: ah, ok. well i'll use that site then
02:25:14 <edsko> augur: those videos rock.
02:25:31 <augur> edsko: yeah, oh god they're so good
02:25:39 <augur> ive watched them so many times
02:26:02 <edsko> I once had a plan of starting my own series, explaining CS related category theory topics
02:26:16 <edsko> it was an ambitiuous plan and like most ambitious plans, it got nowhere :(
02:26:25 <augur> edsko: why nowhere?
02:26:40 <edsko> drowned out by other ambitious plans :)
02:27:21 <shachaf> edsko: Hmm, ~devriese is a confusing username.
02:27:50 <shachaf> There's a Dominique Devriese on the Haskell mailing lists.
02:27:52 <edsko> surname + first letter first name was the convention. write a letter of complaint to Trinity :)
02:28:08 <edsko> shachaf: yeah, I know. I alwasy think "hey, he has my username" :p
02:28:53 <augur> edsko: well lets keep you on focus!
02:28:57 <augur> edsko: lets get writing!
02:29:03 <edsko> haha :)
02:29:57 <augur> edsko: actually, ive been trying to get cale to write a haskell techniques thing too, since there are a bunch of interesting things to say there as well. maybe we could smoosh it together into one big book about FP stuff!
02:30:05 <augur> a hodge podge of functional programming!
02:30:29 <edsko> actually, I've thought about a book about category theory targeted at haskell programmers before
02:30:45 <edsko> kinda like ATAPL, written by different authors
02:30:48 <edsko> still thing that would be awesome
02:30:53 <edsko> *think
02:31:14 <augur> then lets do it!
02:31:49 <edsko> ah, no time. definitely now that I'm in the real world :)
02:31:55 <augur> horrible
02:32:05 <augur> what do you do now, edsko?
02:32:36 <edsko> augur: I work as a haskell consultant for well-typed http://www.well-typed.com/
02:32:52 <augur> well surely they'd like you to write a CT-for-Haskellers book
02:33:00 <augur> i mean they're Well Typed, for goodness sake
02:33:30 <MP2E> I would love to see a Category Theory book targetted at Haskellers
02:33:42 * MP2E throws all the moneys
02:33:43 <augur> see, edsko? we've already got our first customer
02:33:48 <edsko> I'm sure "we'd" like that but "we" like to keep busy :) "we" are happy if we even manage to write a paper or two :0
02:33:57 <edsko> haha, oh, you don't have ot convince me, I think lots of people would like it
02:34:01 * Yuu_chan seconds
02:34:12 <augur> two, count them, two customers!
02:34:26 <augur> man we should kickstart this
02:34:30 <Yuu_chan> Supply our demand!
02:34:32 <MP2E> haha
02:34:32 <edsko> well perhaps I planted a seed and somebody else will nurture it :)
02:34:33 <merijn> MP2E: A colleague of mine wrote a 12 page "intro to category theory for functional programmers" recently, he's having some CT people here read it over before putting into the wide world, so you may have a useful intro soon :p
02:35:10 <MP2E> Excellent :) I have some basics down from reading quite a few papers on it, but it isn't intuitive yet
02:35:16 <Yuu_chan> Seriously, a profound Russian haskeller successfully kickstarted a e-book about quantum FP recently
02:35:27 <MP2E> isn't intuitive to me*
02:35:46 <Yuu_chan> And I think that's a more... specific topic.
02:35:54 <augur> edsko: once i have some slightly more free time, we should talk about this, see what we would want from such a book, and who to scout for contributions
02:36:12 <augur> writing is easy once you know what to write about, i feel
02:36:15 <edsko> I can think of a person or two I'd like to invite :)
02:36:38 <augur> edwardk obviously
02:36:50 <Yuu_chan> I can also remember the crowdsourced HoTT book
02:37:02 <augur> yeah but the HoTT book was written by people with jobs
02:37:14 <augur> jobs paying them to write that book
02:37:15 <augur> :p
02:37:44 <Yuu_chan> Well, crowdfunding is an option :)
02:38:12 <augur> probably couldnt get much tho, alas
02:38:42 <Yuu_chan> You could at least give it a try
02:39:27 <augur> well i'll probably just write some things that could be pasted together into chapters anyway, you know? not for a CT book specifically, but in a logic-and-CT-and-haskell book
02:39:42 <tdammers> I'd buy "CT for Haskellers" :D
02:39:56 <tdammers> well, if it's reasonably priced
02:39:57 <augur> i actually really should write something about why CCCs arent the right category for the LC, too
02:40:18 <augur> how they sort of cheat in naughty ways
02:41:01 <Yuu_chan> THREE customers!
02:41:15 <Axman6> me too
02:41:17 <palo_> what is good style for testing? Create a new Module for Testing another module ?
02:41:54 <structuralist> maybe interviews would be comparably valuable while being significantly less commitment to do, at least for giving a sense of what's out there beyond the basics
02:42:16 <structuralist> sigfpe's quora feed is a treasure trove
02:43:14 <structuralist> but yeah I'd definitely buy a book
02:44:07 <augur> goodness
02:44:20 <augur> edsko: we better start writing an outline of chapters :x
02:44:22 <Yuu_chan> Unfortunately I can't get most of the good CS literature without terrible overpricing :(
02:44:30 <Yuu_chan> (in paper, of course)
02:44:43 <edsko> lol :)
02:45:20 <Yuu_chan> Thanks Church the TaPL was published locally
02:45:43 <augur> edsko: obviously Intro to CT should be the first chapter or two, but what else? we probably want some categorical logic and also some monads
02:46:15 <augur> categorical logic might need a logic/TT section
02:46:45 <edsko> well, for example it would be fantastic if we could get Ralf Hinze to contribute a chapter on his adjoint folds
02:47:13 <Yuu_chan> augur: can you include illustrative implementations?
02:47:51 <augur> Yuu_chan: its probably a bit tricky to also do CT _in_ haskell at the same time
02:48:03 <Axman6> speaking of illustrative things... is there a cannonical example of something which is a semigroup without being a monoid?
02:48:09 <augur> i think it would run the risk of confusing people doubly
02:48:19 <Yuu_chan> Hm.
02:48:40 <prophile> non-empty lists
02:48:49 <augur> one, because there's a lexical issue -- do we mean arrow as in the CT concept abstract, or arrow as in the type class???
02:49:08 <shachaf> Non-empty lists are as canonical as it gets, being free.
02:49:13 <augur> and two, because haskell's category modules aren't strictly speaking true categories
02:49:14 <Axman6> hmm, I guess that works
02:49:17 <shachaf> Another example is Max/Min for types like Integer.
02:49:26 <augur> or really, arent all the categories
02:49:27 <edsko> I take your point but on the othre hand I've been thinking about doing some category theory programming in Haskell using polykinds. that would be fun, too :)
02:49:38 <prophile> Max/Min for types without bounds might make for a nicer example
02:49:39 <Axman6> shachaf: ah thanks, that is a nicer example
02:50:05 <augur> edsko: well im sure it could be done in a later section, but not in parallel
02:50:18 <augur> edsko: like, later on you say, ok now lets use these ideas _inside_ haskell
02:51:21 <augur> but when you're trying to teach the CT stuff i think maybe not? so people dont mix the two? i dont know. i just think, if you're doing, say, a CT semantics chapter, writing it _in haskell_ is risky
02:51:35 <augur> but then, we do write LC stuff in haskell all the time, so who knows
02:51:57 <Yuu_chan> augur: sounds reasonable
02:52:14 <augur> ok i really need to sleep
02:52:49 <Yuu_chan> Good night :)
02:53:03 <augur> edsko: we should definitely talk a bit more tho about who to try to coerce into this :p
02:53:26 <edsko> like I said, I won't have much time. but go ahead :)
02:53:47 <augur> edsko: well you dont have to write anything!
02:53:56 <augur> just, you know, name people a bunch :P
02:53:57 <shachaf> Axman6: Well, non-empty lists are the best.
02:53:58 <augur> anyway, night
02:54:03 <edsko> night
02:59:58 <Yuu_chan> Axman6: + on Nats? (well, that's equivalent to composition of length and ++ on non-empty lists)
03:01:35 <Axman6> eh? aren't Nats monoids with (+) and 0?
03:03:00 <prophile> that depends whether your definition of the natural numbers includes 0
03:03:10 <Yuu_chan> Some math schools don't include zero in natural numbers
03:03:18 <Axman6> hmm, ok
03:03:36 * Axman6 is used to the Ada use of Natural and Positive as different types
03:03:41 <Yuu_chan> Well, yeah. Mine doesn't, though I think it's less logical
03:04:45 <augur> btw before i go to sleep, let me just pass this on to everyone interested in machine learning: http://www.reddit.com/r/MachineLearning/comments/23pndk/dexter_machine_what_is_it/
03:04:46 <Yuu_chan> Anyway, PL's Nats typically include 0, so I'd better get used to that
03:05:02 <ethelward> )/quit
03:27:23 <haasn> 0∈ℕ or bust
03:32:48 <BlankVerse> how do i repeat a monadic action k times?
03:33:23 <Maior> :t repeat
03:33:24 <lambdabot> a -> [a]
03:33:26 <Maior> oh
03:33:56 <Maior> BlankVerse: ^ + sublist / similar?
03:34:38 <BlankVerse> Maior: I could not find anything for monads, was expecting a repeatM , rolled my own ..
03:34:42 <prophile> :t replicateM
03:34:43 <lambdabot> Monad m => Int -> m a -> m [a]
03:34:46 <prophile> ^
03:34:48 <Maior> oops sorry
03:41:04 <BlankVerse> prophile: thanks
03:43:28 * hackagebot http-kit 0.1.0 - A low-level HTTP library  http://hackage.haskell.org/package/http-kit-0.1.0 (SimonHengel)
03:47:26 <haasn> BlankVerse: replicateM_
03:48:29 * hackagebot curves 1.1.0.1 - Library for drawing curve based images.  http://hackage.haskell.org/package/curves-1.1.0.1 (UlfNorell)
03:57:18 <Ainieco> shachaf: hello
03:58:27 <Ainieco> shachaf: how do you feel sitting here for almost 9 years?
04:13:17 <skypers> hi
04:13:24 <skypers> someone knows laar’s nick?
04:13:41 <quchen_> Who is "laar"?
04:13:56 <asQuirr> hey guys, does anyone use Haskell Mode for vim? Because I'm trying to figure out how to run the commands prefixed with an underscore, and can't figure it out for the life of me (e.g. _ct to create tags)
04:16:29 <pjdelport> asQuirr: do you have maplocalleader set?
04:17:03 <asQuirr> I just use the default \
04:17:39 <pjdelport> asQuirr: Does that work, instead of _ ?
04:18:01 <asQuirr> nope
04:19:53 <asQuirr> I'll set the local leader to underscore and see what happens
04:20:12 <pjdelport> Does :map <buffer> say anything?
04:20:20 <pjdelport> (while you're in a Haskell buffer)
04:20:42 <asQuirr> pjdelport: no mapping found
04:21:07 <pjdelport> asQuirr: Are you sure the plugin is getting loaded, then?
04:21:21 <asQuirr> yeah, haddock querying works
04:21:28 <pjdelport> It should be showing *some* mappings.
04:21:34 <pjdelport> If it's defining any.
04:23:31 <skypers> 13:12 < quchen_> Who is "laar"?
04:23:37 <skypers> the maintainer of OpenGLRawgen
04:23:42 <skypers> https://github.com/Laar
04:23:48 <asQuirr> pjdelport: well _? produces :call Haddock()
04:23:48 <skypers> and GLFW-b, seems to be
04:24:12 <pjdelport> asQuirr: oh, it looks like the plugin actually defines global mappings, not buffer ones
04:24:14 <pjdelport> oy vey
04:25:20 <skypers> yay!
04:25:28 <skypers> just compiled OpenGL 4.4 for Haskell
04:25:44 <skypers> I had to blacklist a few modules because the tool of laar’s not perfect yet
04:25:47 <skypers> but still: woah.
04:25:55 <skypers> 477 written modules
04:26:00 <pjdelport> Ugh, it looks like it defines mappings in the compiler plugin
04:26:13 <pjdelport> asQuirr: Did you run :compiler ghc ?
04:26:25 <asQuirr> ...no
04:26:28 <asQuirr> I have now though
04:26:42 <asQuirr> :D it works
04:26:53 <pjdelport> asQuirr: It's pretty terrible style for a plugin to define mappings in there, but oh well
04:27:11 <pjdelport> Someone probably needs to fix that
04:27:23 <asQuirr> mmm... the setting compiler thing is pretty hidden...
04:28:03 <pjdelport> asQuirr: broken, would be a better word :)
04:28:48 <pjdelport> a compiler plugin is supposed to set :make-related options, not define mappings or anything else
04:31:43 <asQuirr> pjdelport: thakns for your help :)
04:31:49 <asQuirr> *thanks
04:33:34 * hackagebot network-msg 0.1 - Recvmsg and sendmsg bindings.  http://hackage.haskell.org/package/network-msg-0.1 (sickmind)
04:36:33 <asQuirr> now it can't find modules that are quite clearly there >.> I give up...
04:53:49 <orion> Hi. I have a... unique situation. I have a library, libsodium, installed somewhere in my home directory. As part of that installation, a file exists "blah/blah/lib/pkgconfig/libsodium.pc" which contains the pkg-config information for the library. I set PKG_CONFIG_PATH to that directory and ran "/usr/local/bin/cabal configure" in my project directory.
04:54:08 <orion> My project lists libsodium in PkgConfig-Depends.
04:54:22 <orion> And it works! Cabal had no trouble finding and linking to the library.
04:54:58 <orion> But if I use ~/.cabal/bin/cabal, the configure fails: * Missing C library: sodium
04:55:35 <orion> The system-wide cabal version is 1.16.0.2. The one in my home directory is 1.20.0.0
04:55:58 <orion> Does anyone know what could be going wrong here?
04:56:45 <orion> I tried using verbosity 3 and found this:
04:56:47 <orion> ("/usr/local/bin/pkg-config",["--modversion","libsodium"])
04:56:47 <orion> Dependency libsodium -any: using version 0.4.5
04:57:08 <orion> So, that says to me that cabal is definitely finding the pkgconfig information.
04:57:46 <orion> I don't know what else I can do to debug this.
05:08:41 <fizruk> is there a library with/for cascade menus, I’d like to see how they are usually represented
05:09:36 <fizruk> (specifically I wonder if it makes sense to have Alternative Menu or Monoid Menu)
05:59:18 <vermeille> is IR a category? I can't see what would be the composition function under that category
05:59:26 <vermeille> Just (.) ?
06:05:40 <fizruk> vermeille: what’s IR?
06:08:46 * hackagebot yesod-test 1.2.1.3 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.1.3 (MichaelSnoyman)
06:08:48 * hackagebot streaming-commons 0.1.2 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.2 (MichaelSnoyman)
06:19:49 <arboris> is there a library function with less precision than getCPUTime?
06:22:15 <Kron> arboris: less precision in what way?
06:22:51 <Kron> do you just mean giving a less highly resolved number, or more elaborate date/time output?
06:26:07 <arboris> getCPUTime returns an Integer in picoseconds, I would be fine with nano or microseconds, also I would prefer one that does return an Int
06:26:47 <tdammers> arboris: can always reduce precision
06:26:59 <tdammers> just integer-divide by a million and convert to Int?
06:27:13 <tdammers> or are we talking performance critical code here?
06:27:17 <arboris> tdammers: sure but that costs a lot of performance if you stick that in your inner loop
06:27:44 <tdammers> hmm, gettimeofday springs to mind
06:30:04 <Kron> I've never thought about profiling various time calls
06:30:17 <Kron> arboris, how about just running an external process via the IO monad?
06:30:45 <Kron> I think "date" can print the exact UTC seconds or something
06:32:06 <suOya_> /quit//quit
06:32:23 <MagneticDuck> btw what's the best way of just getting the output from a process again?
06:32:44 <merijn> MagneticDuck: Read from it's stdout?
06:32:56 <suOya_> /quit/quit
06:33:27 <Kron> I think "system"?
06:33:41 <Kron> hmmm no that only returns an exitcode
06:34:23 <MagneticDuck> merijn: yeah
06:34:29 <Kron> http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html
06:34:33 <arboris> Kron: i was thinking about how I would implement a game loop in haskell, which needs fast and semi-accurate deltaT to update (maybe even double)
06:34:49 <MagneticDuck> I sometimes use "system "process &> /tmp/readsystem; output <- readFile "
06:34:52 <MagneticDuck> tmp/system" x|
06:35:04 <arboris> so running in another process would not really work
06:35:04 <Kron> I guess createProcess and derivatives to run a separate process and then use the handles?
06:35:40 <Kron> arboris: getCPUTime has a value of "IO Integer"
06:35:57 <Kron> this is a bit of an annoying naming scheme, but Int is a machine integer and Integer is a bignum
06:36:04 <Kron> you can't even run out of space on an Integer
06:36:09 <Kron> which probably just makes it even slower
06:36:17 <arboris> Kron: sure but it uses 4 system calls
06:36:30 <arboris> and i don't care if it wraps around every 40 days
06:36:39 <Kron> anyway
06:36:43 <Kron> I think you want Clock then
06:36:44 <Kron> http://www.haskell.org/ghc/docs/7.4.2/html/libraries/time-1.4/Data-Time-Clock.html
06:37:11 <Kron> I think Difftime?
06:37:23 <Kron> I don't know how fast this is but I vaguely remember using it myself ages ago
06:37:35 <Kron> to be honest there are a lot of time related libraries in haskell
06:40:59 <pjdelport> arboris: For something on the scale of a game loop, scaling the Integer to an Int should be negligible
06:41:03 <merijn> arboris: btw, if you know of a C function that does what you want it'd be trivial to call that and use it's result
06:42:23 <arboris> merijin: yes, i will probably do that
06:43:01 <merijn> arboris: Probably you want something like clock_gettime?
06:43:14 <merijn> oh, bah
06:43:20 <merijn> Those return a struct
06:46:34 <arboris> apple has something like mach_absolute_time, which probably just boils down to reading a special cpu register
06:47:22 <merijn> arboris: If you have something that's good enough for you and returns an int, then that will be trivial to wrap. clock_gettime isn't very hard to wrap, but dealing with structs is a bit annoying
06:51:44 <merijn> names
06:52:49 <arboris> merijn, i think for now i will just wrap the standard c library
06:53:00 <arboris> for linux
06:53:26 <arboris> although time.h seems to be universal
07:01:29 <exicer> I wanted to play around with wreq, but on installing with cabal I get the error:     Not in scope: peekChar'
07:01:39 <exicer> Anyone else experienced this ?
07:01:56 <quchen> Did you sandbox it?
07:02:48 <exicer> yup
07:16:17 <tero-> uh, MissingH 1.2.1.0 conflicts with http-client-tls 2.5.0.0 on network-package
07:16:39 <fragamus> good morning haskellers
07:17:07 <Dtgr> good evening
07:17:18 <fragamus> my question is about pipes
07:17:48 <fragamus> I have been transforming my lazy list code to pipes and its great BUT
07:18:13 <fragamus> sometimes I need to work with the whole list as in a fold
07:18:23 <fragamus> and it seems to break the pipes model
07:20:08 <merijn> fragamus: In what way?
07:20:30 <fragamus> well I find myself wanting to detect the end of the input stream
07:20:41 <fragamus> which I understand is a wrong thing to want
07:22:22 <merijn> fragamus: Why do you need to know the end of the input stream?
07:22:45 <fragamus> because I'm doing a fold
07:24:10 <merijn> fragamus: Don't the fold functions in Pipes.Prelude already do what you need?
07:24:37 <fragamus> lemme see....
07:48:57 * hackagebot esqueleto 1.4 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.4 (FelipeLessa)
07:57:44 <bennofs> Does anyone know a good tutorial for lazy st?
07:57:49 <bennofs> :t runST
07:57:50 <lambdabot> (forall s. ST s a) -> a
07:58:06 <bennofs> > runST (forever (return ()) >> return 4)
07:58:11 <lambdabot>  mueval: ExitFailure 1
07:58:23 <int-e> does "use strict ST instead" count?
07:58:39 <bennofs> heh :P
07:58:49 <bennofs> is lazy st bad?
07:59:46 <int-e> As far as I understand, it contains an implicit unsafeDupablePerformST on overy bind.
08:00:40 <int-e> I.e. in a >> b, the 'b' part may be executed more than once.
08:01:26 <FreeFull> Sounds inefficient
08:01:49 <int-e> FreeFull: It happens very rarely. The problem is a failure of correctness.
08:02:15 <FreeFull> Strict IO and strict ST seem to be the way to go
08:02:25 <FreeFull> And then something like pipes or conduit
08:02:35 <FreeFull> Although I'm not aware of anything like those for ST
08:03:07 <int-e> runST $ do s <- newSTRef 0; a <- readSTRef s; writeSTRef s 1; return a -- can return 1 sometimes? awful.
08:03:36 <FreeFull> That is awful
08:03:59 * hackagebot thumbnail-plus 1.0.3 - Generate thumbnails easily and safely.  http://hackage.haskell.org/package/thumbnail-plus-1.0.3 (FelipeLessa)
08:05:51 <threestrikes> is it ok to use modules from the haskell98 library or is it bad practice?
08:07:01 <Axman6> which modules?
08:07:11 <threestrikes> System.Directory
08:07:25 <threestrikes> getDirectoryContents
08:09:00 * hackagebot wreq 0.1.0.1 - An easy-to-use HTTP client library.  http://hackage.haskell.org/package/wreq-0.1.0.1 (BryanOSullivan)
08:12:45 <whoisburbansky> Hello?
08:12:59 <whoisburbansky> Umm, is anybody here?
08:13:00 <threestrikes> Hi
08:13:07 <randomclown> nope all ghosts here
08:13:14 <threestrikes> lol
08:13:15 <BeardedCoder> yip
08:13:28 <Maior> :t repeatM_
08:13:29 <lambdabot>     Not in scope: ‘repeatM_’
08:13:30 <lambdabot>     Perhaps you meant one of these:
08:13:30 <lambdabot>       ‘repeat’ (imported from Data.List),
08:14:05 <whoisburbansky> And I thought social awkwardness only applied to real life
08:14:07 <threestrikes> :t getDirectoryContents
08:14:07 <lambdabot> Not in scope: ‘getDirectoryContents’
08:14:41 <whoisburbansky> I was wondering why functions are represented as (->) r
08:14:47 <whoisburbansky> What does that even mean?
08:15:01 <Axman6> ((->) r) is like (r ->)
08:15:08 <whoisburbansky> So what's the r?
08:15:14 <Axman6> it's a partially applied type, awaiting a result type
08:15:19 <Axman6> it's the input
08:15:21 <Axman6> type
08:15:34 <whoisburbansky> Right.
08:15:38 <Axman6> (r ->) a == r -> a
08:15:57 <Axman6> well, ((->) r) a == r -> a
08:16:13 <d3lxa> I'm compiling with cabal and I can't get the debugging symbol: "No modules are loaded with debugging support." I've added 'GHC-Options: -debug' under the Executable section of my cabal
08:16:21 <whoisburbansky> So if I had a (>3), the r would be Int?
08:16:45 <Axman6> um, I'm not sure how those questions are related
08:16:51 <Axman6> :t (>3)
08:16:52 <lambdabot> (Ord a, Num a) => a -> Bool
08:17:01 <Axman6> I might be misunderstanding what you don't understand
08:17:16 <Maior> whoisburbansky: where does your question come from
08:17:25 <whoisburbansky> I was looking at the instance implementation for functions as Applicatives
08:17:30 <whoisburbansky> It goes like
08:17:38 <whoisburbansky> instance Applicative ((->) r) where ...
08:17:57 <whoisburbansky> So I thought, why ((->) r) ? How does that represent a function?
08:18:08 <Axman6> right, so that's the Reader instance. it's an applicative instance for all functions of type r -> a, for any a
08:18:30 <Axman6> you understanad instance Applicative Maybe where right?
08:18:33 <whoisburbansky> Yep
08:18:40 <Axman6> how Maybe is something of kind *-> 8
08:18:42 <Axman6> *
08:19:06 <Axman6> ((->) r) is also of kind * -> *, it needs another type to form a ... full? type
08:19:20 <whoisburbansky> Right, one that takes no more type parameters.
08:19:23 <whoisburbansky> Ah, okay.
08:19:33 <Axman6> it's just partially applying (->) to one value
08:19:34 <whoisburbansky> So, the idea of a function is (->)
08:19:46 <whoisburbansky> But r is to make it a type that needs only one more type.
08:19:50 <Axman6> yeah
08:20:00 <Axman6> so you then get things like ...
08:20:22 <Axman6> > (+3) <$> (*4) $ 7
08:20:23 <lambdabot>  31
08:20:48 <Axman6> or
08:20:51 <Sculptor> and
08:20:52 <Sculptor> hi
08:21:16 <Axman6> (,) <$> show <*> (\n -> n*n) $ 7
08:21:19 <Axman6> > (,) <$> show <*> (\n -> n*n) $ 7
08:21:21 <lambdabot>  ("7",49)
08:21:44 <Axman6> it gives the value of type r to all of the functions in the chain basically
08:22:09 <whoisburbansky> Right. I get it. Yay. :D
08:22:23 <whoisburbansky> Thanks a ton!
08:24:01 * hackagebot htsn 0.0.9 - Parse XML files from The Sports Network feed.  http://hackage.haskell.org/package/htsn-0.0.9 (MichaelOrlitzky)
08:24:53 <Axman6> no worries =)
08:25:33 <whoisburbansky> Axman6++
08:25:42 <Axman6> @karma Axman6
08:25:42 <lambdabot> You have a karma of 6
08:25:43 <remib> Hi!
08:25:52 <Axman6> hmm, that's lower than I thought :(
08:26:00 <BeardedCoder> https://gist.github.com/ccarter/11199103. Can someone help me with trying to convert an exception in Network.Http to an either. I minified the first problem in that gist.
08:26:54 <Axman6> BeardedCoder: have you seen try?
08:26:58 <Axman6> @hoogle try
08:26:58 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
08:26:58 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
08:26:58 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
08:27:49 <Zuleyken> Why doesn't the mtl package contain a MaybeT?
08:28:04 <bennofs> Zuleyken: because MaybeT is already in transformers
08:28:11 <bennofs> Zuleyken: import Control.Monad.Trans.Maybe
08:28:46 <bennofs> Zuleyken: and there are no MaybeT-specific functions that would need a typeclass (there is no MonadMaybe), because you can just use return/mzero
08:28:53 <BeardedCoder> Axman6: Ya, I went down that path. I can go down it again if that's the correct way. I was trying to understand the Failure typeclass. I can have it automatically work with a Maybe but not an Either
08:29:21 <threestrikes> is it ok to use modules from the haskell98 library or is it bad practice? Specifically System.Directory getDirectoryContents
08:29:56 <bennofs> threestrikes: System.Directory lives in the package directory
08:30:02 <l0cust> @karma l0cust
08:30:02 <lambdabot> You have a karma of 0
08:30:06 <l0cust> dammit
08:30:12 <bennofs> threestrikes: you shouldn't use haskell98 for new projects
08:30:15 <bennofs> l0cust++
08:30:24 <l0cust> @karma l0cust
08:30:24 <lambdabot> You have a karma of 1
08:30:29 <l0cust> ah, that's nice
08:30:41 <l0cust> now I just have to create a fake nick, and give my self karmas
08:30:55 <pseudolio> @karma C/C
08:30:56 <lambdabot> C/C has a karma of 766
08:31:01 <pseudolio> Read it and weep.
08:31:09 <bennofs> @karma bennofs
08:31:09 <lambdabot> You have a karma of 1
08:31:12 <bennofs> bennofs++
08:31:14 <bennofs> @karma bennofs
08:31:14 <lambdabot> You have a karma of 1
08:31:16 <bennofs> :|
08:31:54 <BeardedCoder> Axman6: Actually disregard, I was looking at the wrong "parseUrl" documentation. The one I'm using is using MonadThrow not Failure. I'll research that.
08:32:55 <Axman6> righto
08:33:26 <Axman6> @karma C
08:33:26 <lambdabot> C has a karma of 2
08:33:29 <Axman6> @karma C++
08:33:29 <lambdabot> C++ has a karma of 1
08:33:37 <Axman6> hmm, that used to be very negative
08:33:50 <pseudolio> It gets reset every so often.
08:34:09 <pseudolio> Also, there are special cases for C.
08:34:42 <pseudolio> C--
08:34:44 <pseudolio> @karma C
08:34:44 <lambdabot> C has a karma of 2
08:34:53 <StoneCypher> c++
08:34:55 <pseudolio> You have to go out of your way to change C.
08:34:59 <StoneCypher> c++++
08:35:19 <threestrikes> will it be safe to delete the haskell98 library?  I'm not sure how it got there in the first place
08:36:09 <bennofs> threestrikes: I think you cannot delete it, as it comes with ghc
08:36:39 <bennofs> threestrikes: just igore it
08:36:45 <bennofs> s/igore/ignore
08:38:44 <threestrikes> I'm trying to import System.Directory but I'm getting "Could not find module 'System.Directory' it's a member of the hidden package 'directory-1.2.0.1'
08:38:52 <threestrikes> path issue?
08:39:39 <geekosaur> if it's hidden, either you hid it explicitly with ghc-pkg or you're using cabal to build and didn't list it as a required module in the cabal file
08:39:56 <Zuleyken> bennofs: Thanks, it just seemed ugly to me to have both mtl and transformers in build-depends when mtl could just reexport MaybeT. But I didn't think of the type classes...
08:42:24 <whoisburbansky>  > (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> </2> $ 5
08:42:27 <whoisburbansky> > (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> </2> $ 5
08:42:28 <lambdabot>  <hint>:1:43: parse error on input ‘</’
08:43:02 <whoisburbansky> > (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
08:43:03 <lambdabot>  [8.0,10.0,2.5]
08:43:27 <whoisburbansky> > (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2)  5
08:43:28 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
08:43:28 <lambdabot>    arising from a use of ‘M865994612136417340723135.show_M8659946121364173407...
08:43:28 <lambdabot>  The type variable ‘t0’ is ambiguous
08:43:28 <lambdabot>  Note: there are several potential instances:
08:43:28 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
08:43:35 <whoisburbansky> > (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) 5
08:43:36 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
08:43:36 <lambdabot>    arising from a use of ‘M444182328849940749523154.show_M4441823288499407495...
08:43:36 <lambdabot>  The type variable ‘t0’ is ambiguous
08:43:36 <lambdabot>  Note: there are several potential instances:
08:43:38 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
08:44:10 <shapr> overwhelmed by error messages, the depressed IRC client leaves the channel
08:44:20 <threestrikes> That fixed it, I'm using cabal and didn't list it as a required module.  Thank you!
08:45:45 <thrustfault> this is possibly a really dumb question
08:45:55 <thrustfault> can someone tell me what the point of 'repeat' is?
08:46:03 <tac_> > repeat 1
08:46:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:46:14 <thrustfault> why would you need/want an infinite list though?
08:46:15 <tac_> to create an infinite list of all the same thing
08:46:22 <geekosaur> it creates an infinite list. one way you might use it is to zip it against something else
08:46:51 <tac_> thrustfault: You sometimes want a list filled with all the same element right?
08:46:57 <angerman> Code critique please: https://github.com/angerman/vty-ui-demos/blob/master/statefulcrud.hs
08:47:00 <tac_> like a list of all 0's... it's like the most common thing you can do in a language like C
08:47:04 <tac_> > take 10 $ repeat 0
08:47:05 <lambdabot>  [0,0,0,0,0,0,0,0,0,0]
08:47:08 <eyebloom> I'm working on trying to convert an existing C library for reading Truetype fonts into a Haskell library. I'm starting by just trying to mimic the behavior of the C library by converting loops and searching for side effects. The library reads a font file into an array of bytes and then accesses the array randomly, indexing the array by bytes and typecasting the byte aligned values to unsigned, signed, 8 - 32 bit integer values. Is there an
08:47:08 <eyebloom> existing haskell library that can do this easily. byteArray indexes according to the value type, the Get Monad is not random access...
08:47:11 <thrustfault> ah
08:47:12 <tac_> now you have a finite list of 0's :D
08:47:21 <thrustfault> that is awesome
08:47:22 <tac_> or maybe
08:47:29 <tac_> you have a list of strings
08:47:34 <tac_> and you want to append something to the end of all of them
08:47:45 <tac_> well then you'd probably just use map...
08:47:53 <tac_> but you could do something like this, too:
08:48:16 <tac_> > zipWith (++) ["hello", "world"] (repeat "!")
08:48:17 <lambdabot>  ["hello!","world!"]
08:48:52 <tac_> The fact repeat "!" is an infinite list means that zipWith (++) will work on it no matter how long the other list is
08:49:21 <thrustfault> ok, that's really cool!
08:55:31 <skypers> ahah
08:55:32 <stolaruk> I've noticed I can do "isDoesNotExistError e" or "isDoesNotExistErrorType (ioeGetErrorType e)"... is there any reason to prefer one over the other?
08:55:43 <skypers> I’m using more and more function I thought I’ll never use
08:55:45 <skypers> like uncurry <3
08:56:12 <skypers> map, bifunctors and uncurry; powerful tools!
08:59:42 <remib> I'm trying to understand IO, and on some of the haskell wiki page, it is written that once you got an IO, you can't get rid of it. So I tried to do it and came up with that code http://lpaste.net/2284883092067844096 . It gives me a stack overflow, can somebody tell me why ?
09:00:00 <shachaf> @google isDoesNotExistError
09:00:00 <lambdabot> http://hackage.haskell.org/package/base-4.3.0.0/docs/System-IO-Error.html
09:00:00 <lambdabot> Title: System.IO.Error
09:00:11 <shachaf> stolaruk: Click on Source.
09:00:21 <skypers> remib: woh
09:00:32 <skypers> remib: I’m not sure IO is in Eq
09:01:12 <skypers> how does this thing even compile?
09:01:26 <remib> yeah, I also added "instance Eq (Io a)"
09:01:31 <S11001001> um
09:01:35 <skypers> you can’t do that
09:01:35 <remib> (sorry, I had forgotten it)
09:01:42 <skypers> what do you want to achieve?
09:01:47 <shachaf> ==S11001001
09:01:49 <stolaruk> shachaf: Are you suggesting I look at the source of a particular function?
09:02:05 <shachaf> stolaruk: Yes, isDoesNotExistError
09:02:12 <stolaruk> ok
09:02:14 <S11001001> -fdefer-type-errors is my copilot
09:02:29 <skypers> remib: some monads can be in Eq
09:02:30 <skypers> like Maybe
09:02:31 <Maior> remib: I, wow
09:02:34 <skypers> > Just 3 == Just 1
09:02:35 <lambdabot>  False
09:02:38 <shachaf> (The definition is a what you wrote.)
09:02:40 <skypers> but it’s not the case for IO
09:02:49 <skypers> you can’t compare impure effects
09:02:52 <skypers> it doesn’t even have a sense
09:02:57 <remib> What I wanted to do was perform som IO action but without having an IO instance as return type
09:03:09 <S11001001> remib: don't do that
09:03:13 <skypers> you can do that.
09:03:16 <skypers> but don’t.
09:03:20 <shachaf> Oh, I see. You wrote "instance Eq (IO a)" without any instance body.
09:03:21 <remib> Wait.
09:03:25 <skypers> :t unsafePerfomIO
09:03:26 <lambdabot> Not in scope: ‘unsafePerfomIO’
09:03:31 <skypers> :t unsafePerformIO
09:03:32 <lambdabot> Not in scope: ‘unsafePerformIO’
09:03:36 <skypers> yeah, don’t.
09:03:40 <skypers> :D
09:03:43 <shachaf> :-(
09:03:44 <shachaf> Stop it.
09:03:52 <skypers> remib: don’t try to make it your way
09:03:54 <stolaruk> shachaf: I see, thank you
09:03:59 <skypers> learn how to design a good program in Haskell
09:04:00 <S11001001> btw hope to see some of you at ny haskell tonight :)
09:04:03 <Maior> remib: why did you want to do that?
09:04:05 <skypers> forget about what you think
09:04:34 <remib> Yeah, I explain: I didn't actually want to compare the results of the two prints.
09:04:55 <eyebloom> When and where is NY Haskell
09:05:24 <skypers> remib: if you run something in IO, you can’t escape it in pure code
09:05:26 <S11001001> eyebloom: http://www.meetup.com/NY-Haskell/events/177110862/
09:05:32 <skypers> it’s because of the definition of a Monad
09:05:34 <remib> What I wanted was to find a way to do an IO action without having to return an IO. I wanted to do that to better understand how they work
09:05:42 <dwcook> remib, print 3 is actually the representation of an IO action, not the result of one. Comparing those is about as futile as comparing functions.
09:05:47 <skypers> remib: you can’t
09:05:52 <S11001001> remib: They work by not working at all when you try to do that.
09:05:58 <shachaf> remib: You can't. That's not how I/O works in Haskell.
09:06:06 <Maior> remib: I don't think "doing an IO action without having to return an IO" is a good way to "better understand how they work" - I think the opposite in fact
09:06:11 <skypers> that’s not how monads work.
09:06:20 <skypers> it’s not a matter of IO
09:06:21 <eyebloom> Wish I could make it
09:06:22 <dwcook> Forget Monads, that's not how IO works
09:06:26 <shachaf> remib: You don't "do" I/O so much as make an IO value which describes the I/O you want to do. Then someone else runs it.
09:06:36 <mmachenry> remib: The only way is http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO-Unsafe.html#v:unsafePerformIO
09:06:45 <skypers> bad advise, mmachenry
09:06:50 <dwcook> unsafePerformIO shouldn't even be mentioned in this conversation
09:06:51 <mmachenry> Its not recommended though.
09:06:54 <skypers> that function should not exist…
09:06:59 <shachaf> Would you all stop it?
09:07:10 <remib> wow, a lot of comments, I'm sorry if I'm not playing by the rules
09:07:12 <mmachenry> skypers:  I know it's bad to use it, and I said that, but that doesn't mean it's not possible.
09:07:30 <skypers> mmachenry: I never found a descent use of it
09:07:38 <shachaf> You're being actively unhelpful when someone is trying to understand IO and you say "unsafePerformIO".
09:08:05 <skypers> btw, what does “undestand IO“ mean if we don’t talk about monads?
09:08:06 <mmachenry> skypers: He's looking to learn and just because you haven't found a good use of it doesn't mean I'm not going to answer and honest question correctly.
09:08:17 <skypers> mmachenry: sure
09:08:21 <skypers> but this is not a great answer
09:08:26 <skypers> it won’t help him to understand IO
09:08:33 <skypers> and it’ll only confuse him
09:08:52 <remib> So when you say "you can't perform something impure (ie IO) in a pure code", you mean "anyway you will try to escape the IO, you will fail". Is that right ?
09:09:01 <skypers> yes
09:09:02 <dwcook> skypers, Monad is not fundamental to dealing with IO actions.
09:09:03 <skypers> it won’t compile
09:09:08 <mmachenry> remib: There's definitely reasons to not use it. The high-level intuitive reasoning is that if you call something in the IO monad, the function you're in does IO… so it should have that type. This is why the IO monad is different from most monads in that you cannot escape it.
09:09:09 <skypers> dwcook: I know
09:09:10 <shachaf> "escape the IO" isn't a phrase that really makes sense.
09:09:14 <skypers> it’s fundamental to _understand_ it
09:09:27 <tdammers> no it's not
09:09:29 <shachaf> Wow, never mind.
09:09:38 <tdammers> IO is just another type
09:09:51 <tdammers> it happens to be a monad, but that's relatively unimportant
09:09:57 <skypers> tdammers: oh really?
09:10:00 <skypers> it’s not important?
09:10:02 <remib> shachaf, it's because I don't really understand the "rule"
09:10:04 <tdammers> no
09:10:06 <klrr_> how do you write a functor instance for "((->) e)"? i presume "fmap g f = \r -> g (f r)" is wrong?
09:10:15 <mmachenry> remib: Unsafe IO is the only way. I'm sure it's there for a reason. Probably for print debugging honestly. That's probably the only use I can think of.
09:10:17 <skypers> the rule he’s looking for
09:10:18 <tdammers> you have atomic IO values provided by the language
09:10:19 <skypers> is called…
09:10:21 <skypers> (>>=)
09:10:27 <skypers> nothing else
09:10:27 <ReinH> klrr_: what would the type be?
09:10:30 <Maior> mmachenry: trace etc. exist
09:10:33 <ReinH> :t fmap
09:10:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:10:37 <tdammers> and you have a bunch of functions to modify and combine them
09:10:51 <klrr_> hmm
09:10:53 <angerman> Ok, I ran my code through HLint as well, it should be a little cleaner now. Anyone willing to give me some feedback on the code? https://github.com/angerman/vty-ui-demos/blob/master/statefulcrud.hs
09:10:58 <skypers> he wants understand why he can’t escape IO, and it’s because of the way we use IO in monadic code
09:11:00 <ReinH> klrr_: what is f?
09:11:07 <skypers> but I let gurus explaining
09:11:08 <tdammers> now, those functions happen to make our type a monad, so it makes sense to have it implement the Monad typeclass
09:11:09 <klrr_> "((->) e) b"?
09:11:11 <mmachenry> Maior: Yeah and they probably use unsafeIO, right?
09:11:23 <tdammers> but that's not why you can't "escape" IO
09:11:29 <ReinH> klrr_: ok, now put the arrow infix
09:11:38 <klrr_> (e -> b)
09:11:45 <ReinH> klrr_: ok, now replace all the f's
09:11:45 <Maior> @src trace
09:11:45 <lambdabot> trace string expr = unsafePerformIO $ do
09:11:45 <lambdabot>     hPutStrLn stderr string
09:11:45 <lambdabot>     return expr
09:11:46 <skypers> tdammers: if you have a function that runs in Maybe, you can’t escape Maybe.
09:12:01 <Maior> mmachenry: heh ok
09:12:02 <tdammers> skypers: yes you can.
09:12:02 <klrr_> fmap :: (e -> a) -> (a -> b) -> (e -> b)
09:12:03 <klrr_> ?
09:12:06 <mmachenry> skypers: You can
09:12:10 <ReinH> :t fmap
09:12:10 <tdammers> fromMaybe, for example, does just that
09:12:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:12:12 <remib> So, with classical IO, nothing impure is actually done by the code during the execution, but only at the end. And unsafe IO's actually do stuff during execution ?
09:12:14 <ReinH> klrr_: try again :)
09:12:18 <klrr_> okey
09:12:19 <skypers> tdammers: it’s monad relative
09:12:24 <skypers> it’s defined by the type itself
09:12:26 <tdammers> yeah well
09:12:28 <tdammers> the thing is
09:12:31 <dwcook> Maybe a is different from IO a in that Maybe a could actually literally contain an a. IO a will never in any sense contain an a.
09:12:31 <skypers> of course you can of Maybe a -> a
09:12:36 <skypers> have*
09:12:36 <Axman6> klrr_: huh, that looks kind of familliar doesn't it?
09:12:37 <klrr_> fmap :: (a -> b) -> (e -> a) -> (e -> b)
09:12:44 <quchen> No, you can't have Maybe a -> a.
09:12:44 <tdammers> you can't "escape" IO because there is no function that turns an IO value into a plain value
09:12:47 <remib> And the IO that you return at the end of the main describes all you the IO's you will have to perform ?
09:12:48 <ReinH> klrr_: ok, now let's change some letters a bit
09:12:55 <klrr_> okey
09:13:02 <quchen> You can have Maybe a -> a -> a.
09:13:04 <skypers> tdammers: ok, I got your point
09:13:11 <remib> tdammers: That's exactly what I was trying to do with my code.
09:13:20 <ReinH> klrr_: fmap :: (b -> c) -> (a -> b) -> a -> c
09:13:23 <Axman6> tdammers: I'm pretty sure there is... :P
09:13:29 <skypers> quchen: you better say b -> (a -> b) -> Maybe a -> b
09:13:30 <skypers> ;)
09:13:34 <ReinH> klrr_: which is equivalent to yours, just with some letters moved arond
09:13:40 <tdammers> Axman6: yes, but its behavior isn't what you think it is
09:13:41 <klrr_> okey
09:13:48 <ReinH> klrr_: do you know another function that looks like that?
09:13:48 <Axman6> it so is though
09:13:56 <klrr_> hmm
09:13:56 <tdammers> or rather, evaluation doesn't work such that it would be safe to escape IO
09:14:00 <klrr_> (.)?
09:14:02 <tdammers> hence, 'unsafe-'
09:14:03 <quicksilver> tdammers: Axman6 was thinking of (const "hello")
09:14:04 <quchen> skypers: Why would that be
09:14:04 <klrr_> :t (.)
09:14:05 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:14:12 <skypers> quchen: it was a reference dammit!
09:14:13 <klrr_> =O
09:14:13 <skypers> :t maybe
09:14:14 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:14:18 <quicksilver> tdammers: an excellent function of type IO String -> String
09:14:27 <klrr_> ReinH: so functor instance for reader monad is (.)?
09:14:30 <ReinH> klrr_: yep
09:14:32 <klrr_> =O
09:14:36 <quchen> :t fromMaybe -- skypers
09:14:37 <lambdabot> a -> Maybe a -> a
09:14:37 <klrr_> ReinH: thanks for awesome explaination
09:14:42 <ReinH> klrr_: :)
09:14:42 <tdammers> quicksilver: that doesn't turn the IO value into a plain value though... not in a useful way
09:14:53 <skypers> :t fromJust
09:14:55 <lambdabot> Maybe a -> a
09:15:32 <Axman6> @let purifyString :: IO String -> String; purifyString _ = "No! Bad! Bad Haskeller!"
09:15:34 <lambdabot>  Defined.
09:15:48 <Axman6> > puriftString getLine
09:15:49 <lambdabot>  Not in scope: ‘puriftString’
09:15:49 <lambdabot>  Perhaps you meant ‘purifyString’ (line 150)
09:15:54 <Axman6> > purifyString getLine
09:15:57 <lambdabot>  "No! Bad! Bad Haskeller!"
09:15:59 <skypers> > purifyString undefined
09:16:01 <lambdabot>  "No! Bad! Bad Haskeller!"
09:16:05 <quchen> safePerformIO :-)
09:16:09 <Axman6> see, it's always correct
09:16:19 <ReinH> klrr_: it can also be uniquely derived from the type
09:16:22 <ReinH> @djinn (b -> c) -> (a -> b) -> a -> c
09:16:22 <lambdabot> f a b c = a (b c)
09:17:25 <ReinH> how do I compose @pl and @djinn?
09:17:33 <skypers> @let purifyString':: IO String -> String; purifyString' !x = "Try this out now."
09:17:34 <lambdabot>  .L.hs:148:1:
09:17:34 <lambdabot>      The type signature for ‘purifyString'’
09:17:34 <lambdabot>        lacks an accompanying binding
09:17:41 <dwcook> @. pl djinn (b -> c) -> (a -> b) -> a -> c
09:17:41 <lambdabot> f = (.)
09:17:43 <skypers> arf, we don’t have bang patterns?
09:17:44 <quchen> @@ @pl @djinn (b -> c) -> (a -> b) -> a -> c
09:17:44 <lambdabot>  f = (.)
09:17:47 <Maior> ok djinn is so cool
09:17:49 <ReinH> thanks
09:18:10 <ReinH> klrr_: so if you ask djinn for a proof you'll get (.) :)
09:18:26 <skypers> @let purifyString':: IO String -> String; purifyString' x = seq x "Try this out now."
09:18:28 <lambdabot>  Defined.
09:18:38 <skypers> > purifyString' getLine
09:18:40 <lambdabot>  "Try this out now."
09:18:50 <skypers> huh what?
09:18:54 <Axman6> seq does evaluation, not execution
09:19:08 * hackagebot api-tools 0.3 - DSL for generating API boilerplate and docs  http://hackage.haskell.org/package/api-tools-0.3 (AdamGundry)
09:19:40 <Axman6> remember, IO is basically a set of instructions that are run by the RTS, you can't run them within haskell itself*
09:19:41 <skypers> arf, with !x it’d raise an exception
09:19:48 <Axman6> nope
09:19:55 <skypers> yep
09:20:16 <Axman6> > let foo !x = "hello" in foo getLine
09:20:18 <lambdabot>  "hello"
09:20:27 <Axman6> but
09:20:32 <alpounet> seq juste forces smth to whnf
09:20:37 <Axman6> > let foo !x = "hello" in foo (error "oh noes")
09:20:38 <lambdabot>  "*Exception: oh noes
09:20:48 <ReinH> !x *is* seq x
09:20:52 <skypers> > let foo !x = "hi" in foo undefined
09:20:55 <lambdabot>  "*Exception: Prelude.undefined
09:21:00 <skypers> > let foo !x = "hi" in foo getLine
09:21:01 <lambdabot>  "hi"
09:21:03 <skypers> interesting
09:21:15 <quchen> ReinH: It *is* not, but it is ;-)
09:21:22 <dwcook> You can't perform the actual IO they represent, but if you had some way to decompose IO values then you could still interpret them purely, like you might with a Free monad
09:21:24 <Axman6> evaluating getLine just produced an IO String value. it doesn't execute that IO String value
09:21:31 <ReinH> quchen: uh
09:21:34 <ReinH> quchen: ok :)
09:21:42 <skypers> Axman6: so how to force it?
09:21:53 <bennofs> Why does Foldable not define length?
09:21:55 <quchen> ReinH: I mean there's a direct translation, but "seq x" is a function and "!x" is a pattern etc.
09:21:55 <skypers> with safePerformIO?
09:21:56 <Axman6> unsafePerformIO
09:22:01 <alpounet> skypers: you have to *run* it, it's an IO action
09:22:02 <ReinH> quchen: ok, it's equivalent to :)
09:22:03 <alpounet> run it from IO
09:22:08 <Axman6> there's no such thing as safePerformIO
09:22:09 <bennofs> it could easily be defined as getSum . foldMap (const $ Sum 1)
09:22:18 <Axman6> because IO is inherently unsafe
09:22:34 * Axman6 -> sleep
09:22:38 <skypers> hm, so
09:22:43 <skypers> I’m gonna try something else
09:23:05 <alpounet> skypers: what is it that you're actually trying to achieve? we may help more if we know what you want to do
09:23:09 <skypers> > let p !x = x >>= return in p undefined
09:23:10 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
09:23:10 <lambdabot>    arising from a use of ‘M748676916548318975723874.show_M7486769165483189757...
09:23:10 <lambdabot>  The type variables ‘m0’, ‘b0’ are ambiguous
09:23:10 <lambdabot>  Note: there are several potential instances:
09:23:10 <lambdabot>    instance [safe] GHC.Show.Show a =>
09:23:33 <skypers> let p !x = x >>= return in p getLine
09:23:46 <skypers> something like that maybe?
09:23:53 <skypers> alpounet: nothing, juste curious
09:23:58 <skypers> just*
09:24:01 <remib> tdammers: Your say that IO is just another type, with the additional property that there is no function to get something else from it. That's also what I read on the wiki. The idea I get is that once you perform an IO, the function is tainted and there is no way to "untaint" it, the function itself will also have to return an IO. And that's exactly the part I don't understand. Why (as in: What stops us from)
09:24:02 <remib> can't we just not care about the result and return something else. And that's what I tried to do in my code. And the fact that it gives an error seems to comply with what has been said, but I don't see how/why haskell itself does forbid any case like that. (I'm not sure I make sense)
09:24:33 <ReinH> remib: the obvious answer is that there is no function IO a -> a
09:24:49 <ReinH> and you can't pattern match on the constructor
09:24:53 <ReinH> because it is not exported
09:25:08 <alpounet> skypers: you probably want: getLine >>= \str -> str `seq` ..., although it actually just evaluates whether the string is the empty list or _:_
09:25:22 <skypers> alpounet: yeah
09:25:26 <remib> ReinH: So it's not impossible, but forbidden ?
09:25:33 <ReinH> remib: it's forbidden because it's impossible :)
09:25:42 <skypers> I just mistakened the fact that !x if x ~ IO a, it won’t execute it
09:25:56 <ReinH> remib: but another type constructor that did the same thing would behave similarly
09:26:12 <dwcook> remib, the reason you can't get a String out of an IO String is because there isn't actually a String in IO String. At best you'd need an interpreter to get one. That interpreter is Haskell's IO system.
09:26:20 <FOOD_> so... a top level function with a polymorphic type, like a -> b -> a, can be used many times in the same function on different combinations of a and b. but if you pass that top level function into the other function as a parameter, it can only be used for one combination of a and b, or not at all?
09:26:25 <alpounet> skypers: exactly yeah
09:26:30 <quchen> `IO a -> a` is not forbidden the same way going as fast as light is.
09:26:30 <FOOD_> NoMonomorphismRestriction isnt helping
09:26:35 <ReinH> @quote ls
09:26:35 <lambdabot> sipa says: can we write a TutorialMonad t ? which is used to build and combine monad tutorials?
09:26:35 <quchen> (For massive particles, at least.)
09:26:40 <ReinH> :(
09:26:41 <dwcook> remib, you could write a pure interpreter for IO if you could decompose IO values but it wouldn't do actual IO.
09:26:49 <alpounet> @quote /bin/ls
09:26:49 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:27:13 <ReinH> should have been more specific
09:27:22 <skypers> alpounet: btw, I discovered the useful use of uncurry
09:27:26 <skypers> it’s ooooossom
09:27:33 <alpounet> ReinH: lambdabot doesn't have a PATH I guess :]
09:27:39 <ReinH> :)
09:27:42 <skypers> uncurry + first / second from bifunctors + map = <3
09:29:12 <remib> ok, it's clearer now
09:29:21 <remib> Thanks all for the help!
09:30:09 <skypers> oh btw remib
09:30:14 <skypers> do you know the fap function?
09:30:18 <skypers> it’s funny when composed
09:30:27 <skypers> :t fap . fap . fap . fap . fap
09:30:28 <lambdabot> (Functor f4, Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 (f4 a)))) -> f (f1 (f2 (f3 (f4 b))))
09:30:35 <skypers> ok, it was a stupid joke.
09:30:40 <quchen> @undef
09:30:40 <lambdabot> Undefined.
09:30:44 <skypers> oh no
09:30:46 <skypers> :(
09:30:52 <remib> what's the point ?
09:31:08 <skypers> it’s an alias to fmap, remib
09:31:11 <skypers> it should be in Prelude.
09:31:13 <bennofs> the point is function composition
09:31:19 <skypers> ahah bennofs
09:31:21 <skypers> nice one
09:36:13 <lyxia> FOOD_: If you have f :: (a -> a) -> a -> a, you should expect it to accept a function of type (Int -> Int) for example, and then your assumption that "the argument is polymorphic" breaks.
09:36:39 <lyxia> Basically because the type of f is implicitly f :: forall a. ((a -> a) -> a -> a)
09:37:01 <lyxia> and not f :: (forall a. (a -> a)) -> a -> a whatever that would mean
09:37:22 <dwcook> FOOD_, to do what you're describing, you'd want an explicit forall inside your function argument, which requires an extension
09:38:52 <dwcook> f :: (forall a. a -> a) -> (Int, String)
09:38:52 <dwcook> f g = (g 10, g "Hello")
09:38:59 <dwcook> Must have RankNTypes enabled
09:39:12 <dwcook> (or Rank2Types?)
09:39:43 <quchen> dwcook: They're synonyms
09:42:16 <angerman> so, I'm looking for something like >>= but with m a -> (a -> m' b) -> m' b
09:42:39 <dwcook> angerman, what for?
09:42:41 <thoughtpolice> quchen: RankNTypes and Rank2Types were not synonyms at one point. they are now, in 7.8, however
09:42:58 <thoughtpolice> (because having a special case for Rank2 in retrospect is kinda dumb, everyone just uses RankNTypes anyway)
09:43:16 <geekosaur> that implicitly extracts something from m and is therefore not possible as a general monad operation
09:43:21 <angerman> dwcook: I'm having a Maybe X and wand to apply a X -> IO ()
09:43:48 <klrr_> the Effects library from idris, does there exist something like that for haskell, if so, is it to be preffered over monad transofmers or is there any drawbacks?
09:43:59 <dwcook> angerman, what do you want to do if the Maybe X contains Nothing?
09:44:14 <angerman> dwcook empty action.
09:44:16 <itsmonktastic> :t maybe
09:44:17 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:44:35 <dwcook> angerman, where are you going to get a b from then?
09:44:42 <dwcook> Wait no
09:44:55 <dwcook> Forget that question
09:45:52 <klrr_> oh find a package
09:45:52 <dwcook> angerman, I'd agree that some sort of pattern match on your Maybe is the way to go
09:45:55 <klrr_> found*
09:45:59 <itsmonktastic> angerman: generally if you want to 'get out of' a maybe then you need to provide a default. So you can use "maybe" to do that
09:46:56 <angerman> ok. Can I do it like this: Maybe X -> Maybe (IO ()) ?
09:47:08 <angerman> lifting should do, no?
09:47:11 <dwcook> angerman, sure, that's as straightforward as fmap
09:47:49 <itsmonktastic> angerman: that's the start, and then use "maybe" or explicit pattern matching and provide the no op IO action as a default.
09:48:19 <dwcook> In this case your no-op is probably some variation of fail or otherwise throwing an exception unless you can come up with a b though
09:48:39 <itsmonktastic> dwcook: why?
09:48:48 <dwcook> Oh right, you said you want to do X -> IO ()
09:48:50 <itsmonktastic> could just return () if you actually want a no op
09:48:56 <dwcook> Yep return ()
09:49:06 <dwcook> Before they were asking about a more general type
09:49:10 <itsmonktastic> ahh okay
09:49:29 <dwcook> Since we know () :: (), we're good to go
09:54:18 <itsmonktastic> dwcook: is there a typeclass for "has a zero/default value" ?
09:54:56 <quchen> itsmonktastic: Default, yes.
09:54:58 <CindyLinz> itsmonktastic: this one.. # http://hackage.haskell.org/package/data-default-class-0.0.1/docs/Data-Default-Class.html
09:55:03 <quchen> I think it's in Data.Default.
09:55:05 <itsmonktastic> makes sense!
09:55:37 <CindyLinz> itsmonktastic: And some instances # http://hackage.haskell.org/package/data-default-0.5.3/docs/Data-Default.html
09:55:46 <quchen> itsmonktastic: data-default is the package
09:55:49 <dwcook> itsmonktastic, how about Monoid/Alternative/MonadPlus?
09:56:12 <dwcook> "Default value" only makes sense in relation to some operation
09:57:45 <quchen> dwcook: Or in relation to some type. Default basically gives you a monoid without mappend for when you want to generate some (arbitrary) value that has a certain type.
09:57:48 <itsmonktastic> well, I guess an identity is a lot more awesome than a random value that happens to be the right type
09:58:34 <itsmonktastic> yeah, maybe "Arbitrary" is a better name ;)
09:58:35 <Maior> ah that's cute
09:59:13 <dwcook> quchen, so basically you're saying the use case is providing a proof that ∃x:T for some type T?
10:00:19 <quchen> dwcook: Not sure whether that's a "use case", but yes.
10:00:31 <dwcook> quchen, that would have been my next question: When is this actually useful?
10:00:49 <syao> hello, I have a question, better explained in image http://www.gliffy.com/go/publish/image/5656201/L.png
10:01:00 <quchen> dwcook: I think I remember a paper that used "undefined" to generate values of arbitrary type; using Default would be much less hacky there.
10:01:50 <syao> data structure, immutability question
10:02:10 <quchen> dwcook: "Functional Pearl: Implicit Configurations" by Oleg and Shan
10:02:24 <Maior> for some f :: Default b => Maybe a -> b
10:02:24 <Maior> ?
10:02:26 <quchen> (They write ⊥ for 'undefined' in their paper)
10:02:48 <quchen> Maior: f _ = def :: Default b => Maybe a -> b
10:03:09 <itsmonktastic> almost sounds like Default as a dependency injection mechanism
10:05:04 <Maior> quchen: ah thanks
10:20:07 <deweyvm> is there a way to turn on warnings for built in partial functions like head?
10:23:06 <Maior> deweyvm: no idea but would love to know!
10:28:18 <fragamus_> fold in Pipes.prelude:
10:28:22 <wereHamster> https://ghc.haskell.org/trac/ghc/wiki/ReportABug -> To submit an anonymous bug: use login "guest", password "guest" -
10:28:27 <wereHamster> > login does not work
10:28:29 <lambdabot>  Not in scope: ‘login’Not in scope: ‘does’Not in scope: ‘work’
10:28:29 <fragamus_> fold :: Monad m => (x -> a -> x) -> x -> (x -> b) -> Producer a m () -> m b
10:28:45 <fragamus_> what is that (x->b) for
10:28:57 <wereHamster> I have a 'ghc: internal error: evacuate: strange closure type -1061486592', so if you want me to report that as a bug, please provide means to do so
10:33:32 <dwcook> fragamus_, the source names it "done" http://hackage.haskell.org/package/pipes-4.1.1/docs/src/Pipes-Prelude.html#fold
10:37:35 <albeit> Shot in the dark, but does anyone here edit with Vim, and function definitions are minimized when you open a Haskell file, and how to disable that?
10:37:48 <randomclown> albeit: what plugins are you using?
10:38:25 <albeit> randomclown: vim2hs
10:38:37 <Maior> albeit: http://stackoverflow.com/q/8316139/928098
10:39:02 <Maior> albeit: http://vim.wikia.com/wiki/All_folds_open_when_opening_a_file
10:39:08 <albeit> Ah beautiful, I couldn't figure out what the term was for what was happening
10:39:19 <Maior> :)
10:39:30 <Maior> and thanks for provoking me into finally doing that
10:40:43 <pavonia> wereHamster: Is that a reproducable bug?
10:43:17 <Maior> albeit: I have failed to make this work properly
11:04:33 <akegalj> hey. how can i install new base with cabal. i have base 4.6.0.1 but i want 4.7.0.0, cabal says "rejecting: base-4.7.0.0 (only already installed instances can be used"
11:04:50 <dwcook> akegalj, base version is tied to GHC version
11:04:55 <akegalj> oh
11:04:59 <akegalj> dwcook: thnx
11:07:35 <joelteon> i wonder if it would be possible to install a new base with cabal :)
11:07:39 <joelteon> that would be an easy way to upgrade
11:08:10 <bennofs> joelteon: base is wired in in ghc, so it isn't
11:09:18 <dwcook> It's reasonably straightforward to install multiple GHC versions side by side by using a configure prefix, I've found
11:09:30 <dwcook> And then setting your PATH appropriately
11:10:11 <monochrom> that's what I do all the time too
11:10:37 <monochrom> also great for "how to uninstall?" "answer: erase that directory"
11:11:39 <joelteon> answer: the daily double
11:18:00 <jle`> is there a common idiom for inRange -- (&&) <$> (> min) <*> (> max)
11:18:09 <jle`> `elem` [min..max] ?
11:18:23 <jle`> but that has much more comparisons
11:21:13 <pavonia> :t inRange
11:21:14 <lambdabot> Ix a => (a, a) -> a -> Bool
11:21:36 <jle`> oh
11:21:47 <klrr_> gonna play with wreq :)
11:21:48 <pavonia> I learned about that earlier today having the same question :p
11:22:15 <oleo> what does the above mean ?
11:22:41 <oleo> a pair gets reduced to a truth value ?
11:23:02 <pavonia> > inRange ('a', 'z') 'f'
11:23:04 <lambdabot>  True
11:23:13 <pavonia> > inRange ('a', 'z') 'A'
11:23:14 <lambdabot>  False
11:23:36 <pavonia> oleo: It checks if an element is in the given range
11:24:01 <oleo> ok
11:26:09 <heaumer_> Azel: #haskell hum. what a surprise.
11:44:11 <jfischoff> does the new fetchAddIntArray# primop having a ton of overhead like it used to?
11:47:13 <jfischoff> are there any benchmarks for the new primops?
11:47:42 <jfischoff> carter?
11:49:27 * hackagebot find-conduit 0.0.1 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.0.1 (JohnWiegley)
11:50:58 <carter> jfischoff: how much overhead is a lot?
11:51:22 <carter> it should be pretty fast
11:51:26 <carter> if you find its not, thats a bug
11:52:12 <jfischoff> are they inlined
11:52:29 <jfischoff> is there still the double function call overhead?
11:52:37 <afleck> is there a way to unimport a module in ghci?
11:52:50 <carter> dont remember
11:53:03 <carter> that was part of what ryan newton did
11:53:09 <carter> i think it may still ahve a jump
11:53:20 <carter> but thats at worst gonna 2x the time
11:53:39 <carter> heck, CAS in the RTS is  full funcall
11:53:56 <carter> but thats gonna be < 5ns overhead
11:53:57 <carter> afaik
11:54:27 * hackagebot app-settings 0.2.0.0 - A library to manage application settings (INI file-like)  http://hackage.haskell.org/package/app-settings-0.2.0.0 (EmmanuelTouzery)
11:55:52 <carter> jfischoff: had i known that ghc 7.8 wouldn't shipt till march, i'd have gotten around to adding the properly inlined versions.... but late fall "its shipping on 2 weeks, no point in adding it now"
11:56:13 <flebron> Hi. What's an idiomatic way to pick k indices, uniformly (and distinct) from the set [0 .. n - 1]?
11:56:36 <carter> flebron: use a good random number generator?
11:56:45 <carter> :)
11:57:34 <Zuleyken> Is it possible to print the type of something during runtime?
11:57:50 <carter> :info Typeable
11:58:04 <carter> > :info Typeable
11:58:05 <lambdabot>  <hint>:1:1: parse error on input ‘:’
11:58:16 <mmachenry> flebron: :t getRandomR
11:58:21 <mmachenry> :t getRandomR
11:58:22 <lambdabot> Not in scope: ‘getRandomR’
11:58:25 <Peaker> :t typeOf
11:58:26 <lambdabot> Typeable a => a -> TypeRep
11:58:26 <mmachenry> Aw :(
11:58:32 <Peaker> Zuleyken: ^^
11:58:42 <flebron> mmachenry: I know how to get a random number in a range, but those wouldn't necessarily be distinct.
11:58:45 <carter> and TypeRep is showable
11:58:50 <carter> flebron: then filter them
11:58:51 <carter> :)
11:58:58 <flebron> For example, if k = n, I should get [0 .. n - 1].
11:59:23 <mmachenry> flebron: Oh I see. You want to shuffle a list of the values from [0 .. n-1]
11:59:25 <flebron> If there's a way to have a random permutation, then I can just take k from that, but I don't know that there is.
11:59:34 <flebron> I want only k of them.
11:59:53 <mmachenry> flebron: Can you just shuffle the list [1..n-1] ?
12:00:03 <Zuleyken> carter: Thanks!
12:00:14 <flebron> I don't know.
12:01:29 <jfischoff> carter: what is involved to make the inlined versions?
12:01:40 <carter> jfischoff: not that hard
12:01:47 <carter> it just needs to work on all the backends
12:01:48 <Zuleyken> Peaker: Thank you, too
12:01:50 <carter> and add the right primops
12:01:59 <carter> jfischoff: do you have a use case that needs that extra 2-5ns?
12:02:11 <jfischoff> no I'm curious
12:02:14 <carter> well
12:02:22 <carter> it'd be kinda lke my prefetch patch
12:02:43 <carter> and teaching NGC + LLVM + C backends to understand it
12:02:50 <mmachenry> flebron: Seems like that would work.
12:03:03 <jfischoff> can you link to the prefetch path?
12:03:07 <jfischoff> patch
12:04:03 <carter> https://ghc.haskell.org/trac/ghc/ticket/8256  https://ghc.haskell.org/trac/ghc/changeset/fd74014079f14bd3ab50e328e52c44ef97d40e05/ghc
12:04:16 <carter> trac is slow today
12:04:51 <carter> https://ghc.haskell.org/trac/ghc/changeset/fd74014079f14bd3ab50e328e52c44ef97d40e05/ghc
12:05:17 <flebron> mmachenry: If I knew how to randomly permute a list, sure :p
12:05:29 <carter> flebron: try permuting an array
12:05:31 <carter> not a list
12:05:45 <mmachenry> flebron: http://hackage.haskell.org/package/random-shuffle
12:06:32 <flebron> Cool, thanks :)
12:06:49 <carter> spacekitteh has an array permutation lib
12:06:58 <carter> http://hackage.haskell.org/package/permutation
12:10:15 <merijn> If we're talking finite lists another simple shuffle/permutation is this: generate list of random double, zip with permutable lists, ordBy double, :)
12:10:59 <merijn> It's a very robust shuffle method, assuming your list aren't too big that sorting becomes costly
12:12:17 <kaeluka> where should I begin reading if I’m interested in how to/whether it’s possible to implement linear types/unique references in haskell?
12:12:40 <napping> Maybe look at Clean?
12:13:36 <kaeluka> i’m aware of clean; however i really like haskell and would like to have some fun implementing interesting stuff.
12:13:50 <kaeluka> https://www.fpcomplete.com/user/mutjida/typed-tagless-final-linear-lambda-calculus this is what i found after some googling
12:14:25 <napping>  Do you mean implementing a language with linear types in Haskell, a library in Haskell, or changing a Haskell compiler?
12:14:43 <kaeluka> one of the former two
12:14:58 <merijn> kaeluka: Oh, then sure
12:14:58 <napping> as a library it will be very painful but maybe possible
12:15:16 <merijn> kaeluka: I would go the "implement a simple language" route
12:15:19 <napping> I don't see any way to use ordinary variables
12:15:34 <napping> so you'd have to do some kind of crazy type level computation stuff to track environments yourself
12:15:48 <Rodya_> how can i modify a list of sublists such that i can pass it into zip? e.g. zip $ foo $ lists
12:16:50 <jle`> Rodya_: um. can you give an example?
12:17:00 <jle`> :t zip
12:17:01 <lambdabot> [a] -> [b] -> [(a, b)]
12:17:12 <jle`> zip takes two lists...so if your second thing is a list of lists, you can use concat to turn that into one list
12:17:14 <jle`> :t concat
12:17:15 <lambdabot> [[a]] -> [a]
12:17:19 <jle`> but i'm not totally sure what you want
12:17:31 <kaeluka> napping: well, unique refs are not ordinary refs; but you can make a unique ref an ordinary ref whenever you like
12:17:35 <jle`> but
12:17:44 <jle`> you can already use zip with a list of lists
12:17:55 <jle`> > zip [1,2,3] [[1,2,3],[5,6,7],[7,8,9]]
12:17:56 <lambdabot>  [(1,[1,2,3]),(2,[5,6,7]),(3,[7,8,9])]
12:19:02 <Welkin> > zip [1,2,3] $ flatten [[1,2,3],[5,6,7],[7,8,9]]
12:19:03 <lambdabot>  Couldn't match expected type ‘Data.Tree.Tree b’
12:19:04 <lambdabot>              with actual type ‘[[t0]]’
12:20:26 <jle`> Welkin: you are probably looking for concat
12:20:49 <intrados> Is there a way to control which directory emacs runs ghc-mod from?
12:23:06 <orion> Hi. I have a... unique situation. I have a library, libsodium, installed somewhere in my home directory. As part of that installation, a file exists "blah/blah/lib/pkgconfig/libsodium.pc" which contains the pkg-config information for the library. I set PKG_CONFIG_PATH to that directory and ran "/usr/local/bin/cabal configure" in my project directory.
12:23:18 <orion> My project lists libsodium in PkgConfig-Depends. And it works! Cabal had no trouble finding and linking to the library.
12:23:25 <orion> But if I use ~/.cabal/bin/cabal, the configure fails: * Missing C library: sodium
12:23:25 <orion> The system-wide cabal version is 1.16.0.2. The one in my home directory is 1.20.0.0
12:23:34 <orion> I tried using verbosity 3 and found this:
12:23:34 <orion> ("/usr/local/bin/pkg-config",["--modversion","libsodium"])
12:23:41 <orion> Dependency libsodium -any: using version 0.4.5
12:23:41 <orion> So, that says to me that cabal is definitely finding the pkgconfig information.
12:23:48 <orion> Does anyone know what could be going wrong here?
12:24:11 <crundar> I want to read something about MonadChoice. But it's google-proof. Cite?
12:24:31 * hackagebot x509-system 1.4.3 - Handle per-operating-system X.509 accessors and storage  http://hackage.haskell.org/package/x509-system-1.4.3 (VincentHanquez)
12:25:16 <geekosaur> orion: "Missing C library" means something is not using pkg-config to find it but looking directly. A missing pkg-config library has a different error.
12:25:35 <napping> kaeluka: tracking whether you still have a pointer to the unique reference would be tricky
12:25:48 <napping> maybe you could do something like only handing out and invalidating proxies, I suppose
12:26:17 <kaeluka> i thought about passing a *function in*, rather than getting the reference out
12:27:02 <napping> well, the tricky bit is keeping the "unique" thing unique, because Haskell doesn't constrain how you use variables in the right way
12:27:20 <kaeluka> for this, I’d need to _somehow_ encapsulate a `Maybe a`; passing in a function has the side effect of setting the encapsulated value to `Nothing`
12:29:28 <kaeluka> this sounds like such a fun/horrible project ;)
12:31:50 <dwcook> crundar, what MonadChoice are you talking about?
12:34:07 <exicer> Anyone know off-hand how to create a manager in http-client that makes a tls connection with client certs?
12:34:28 <Clint> can it do that yet?
12:34:38 <exicer> Not sure, but it seems likt it should be able to
12:34:55 <exicer> Think I saw that an older version had the ability to do it, but it wasn't in the manager at that point
12:35:04 <KatZilla> Hi there !) Is there any way to transform ToJSON response of PERSISTENT ?
12:35:32 <KatZilla> I would like to return data in another format, then persistent does by default
12:36:10 <BeardedCoder> KatZilla: I assume you mean your using the deriving feature for the JSON. You could write your own that puts it in whatever format you want
12:36:54 <monochrom> I always hand-write my own FromJSON instance :)
12:39:53 <KatZilla> BeardedCoder: monochrom: http://lpaste.net/103124
12:41:11 <heatsink> I have code that frequently computes (let x' = join x y in ...) for various data types.  Very frequently x' = x.
12:42:13 <jle`> :t join
12:42:14 <lambdabot> Monad m => m (m a) -> m a
12:42:14 <heatsink> For performance, I've written the code to avoid constructing a copy of x in this case
12:42:25 <heatsink> It's lattice join
12:42:30 <jle`> ah mk
12:43:06 <Rodya_> i can't figure out where i'm going wrong in this: http://lpaste.net/103125
12:43:19 <heatsink> The code has a bunch of checks to decide whether to return a new value or the original value, and that makes the code messy
12:43:26 <heatsink> Is there a cleaner way to do this?
12:44:08 <merijn> :t foldl (\ acc x -> acc ++ (head x))
12:44:09 <lambdabot> [a] -> [[[a]]] -> [a]
12:44:37 <merijn> Rodya_: [[[a]]] doesn't match the [[a]] returned by group
12:46:01 <BeardedCoder> Whoever was asking about the persistence json thing. (lost my buffer). https://gist.github.com/ccarter/11229674
12:46:05 <exicer> I seem to remember there were some cool gifs illustrating how thunks etc work, can anyone point me to them ?
12:46:09 <Rodya_> merijn: i'm not too sure what that means - i'm returning a triply nested element when i'm working with a doubly nested element?
12:48:35 <fizbin> :t group
12:48:36 <lambdabot> Eq a => [a] -> [[a]]
12:49:06 <merijn> Rodya_: No, it *wants* a triple nested element and you're only giving it a doubly nested one
12:49:11 <fizbin> Rodya_: What is the type of (head x) ?
12:49:27 <fizbin> Rodya_: Then, what is the type of (++) ?
12:49:34 * hackagebot perceptron 0.1.0.1 - The perceptron learning algorithm.  http://hackage.haskell.org/package/perceptron-0.1.0.1 (StefanHoldermans)
12:49:45 <fizbin> Then, can you really pass (head x) as an argument to (++)?
12:50:31 <tapuu> I'm getting 'parse error on input `=`' because of this 'typeRep# = '
12:51:12 <pavonia> tapuu: Set -XMagicHash
12:51:52 <tapuu> pavonia: that fixed it, thanks!
12:52:26 <jakex> @pl (\xs -> (head xs, length xs))
12:52:27 <lambdabot> liftM2 (,) head length
12:52:27 <fizbin> merijn: I suspect that you're confusing Rodya_ because you're taking the first argument to the foldl as correct and saying "the last argument has the wrong type", whereas I think the way forward is "that function you passed to foldl makes (foldl thatFunction) not have the type you intended".
12:54:15 <Rodya_> fizbin: ++ :: [a]
12:54:57 <Rodya_> fizbin: i'm not sure about the type of (head x), but my reasoning: if (group xs) :: [[a]], then (head x) :: a
12:55:05 <fizbin> Rodya_: Specifically, (++) :: [a] -> [a] -> [a]
12:55:09 <merijn> :t foldl
12:55:10 <lambdabot> (b -> a -> b) -> b -> [a] -> b
12:55:56 <fizbin> Now if (head x) has type "a", and "acc" has type "[a]", you can't do acc ++ (head x)
12:56:46 <Rodya_> fizbin: so if i changed (head x) to [head x], that would give it the type it is expecting?
12:57:09 <fizbin> So when you do (acc ++ (head x)), the compiler says "ah, (head x) must have type [a] just like acc does, so x must have type [[a]], so then... (and here you get to what merijn was saying)
12:57:17 <fizbin> Rodya_: Try and see.
12:59:07 <fizbin> For future reference, one way to nail down typing issues like this that I've found productive is to take stuff that isn't compiling and use where clauses to split out each little piece, with its own type declaration, so that I can see what's going on.
12:59:22 <fizbin> So in this example, I'd do:
13:00:05 <fizbin> compress xs = foldl compressor [] grouped
13:00:27 <fizbin>    where compressor :: [a] -> [a] -> [a]
13:01:01 <fizbin>       compressor acc x = acc ++ (head x)
13:01:02 <fizbin>       grouped :: [[a]]
13:01:11 <fizbin>     grouped = group xs
13:01:22 <fizbin> Reformat that obviously, but you get the idea.
13:01:24 <Rodya_> so basically make it a little more verbose to see where my expectations /= reality
13:01:30 <fizbin> Yeah.
13:02:05 <fizbin> And specifically, assign types to tinier pieces until you narrow down what isn't working.
13:02:47 <jakex> is this a safe use of head?
13:02:55 <jakex> > map (\xs -> (head xs, length xs)) . group . sort . words $ "foo bar foo baz baz baz"
13:02:56 <lambdabot>  [("bar",1),("baz",3),("foo",2)]
13:03:05 <fizbin> > group []
13:03:06 <lambdabot>  []
13:03:12 <c_wraith> yes
13:03:29 <c_wraith> all elements of group are guaranteed to be non-empty
13:03:37 <fizbin> jakex: I believe so. I don't believe group will ever put an empty list as one of the elements of what it returns.
13:04:02 <c_wraith> If there was ever a case for adding a NonEmpty type to base, it would be to make group better
13:04:18 <jakex> thought so, thanks
13:04:36 * hackagebot perceptron 0.1.0.2 - The perceptron learning algorithm.  http://hackage.haskell.org/package/perceptron-0.1.0.2 (StefanHoldermans)
13:04:38 * hackagebot x509-system 1.4.4 - Handle per-operating-system X.509 accessors and storage  http://hackage.haskell.org/package/x509-system-1.4.4 (VincentHanquez)
13:04:44 <ReinH> c_wraith: and then we could add semigroup?
13:05:06 <ReinH> and fix the monoid instance of Maybe?
13:05:09 <ReinH> pleeeease
13:05:17 <c_wraith> I wasn't being that aggressive
13:05:23 <ReinH> c_wraith: oh well
13:06:51 <orion> < geekosaur> orion: "Missing C library" means something is not using pkg-config to find it but looking directly. A  missing pkg-config library has a different error.
13:07:13 <orion> geekosaur: Could you rephrase that? I didn't catch it.
13:07:36 <geekosaur> you were talking about how you had the pkg-config stuff and it was working
13:07:44 <geekosaur> if cabal had been *using* it, it would have found the library
13:07:45 <fizbin> ReinH: What's wrong with Maybe's monoid instance?
13:07:54 <geekosaur> "Missing C library" means it did not use pkg-config
13:08:00 <orion> Weird.
13:08:37 <orion> Is that even in spite of the fact that "cabal configure -v3" printed out: Dependency libsodium -any: using version 0.4.5 ?
13:08:44 <c_wraith> fizbin: it's not consistent with the view of Maybe as "the result of a computation that might fail"
13:08:47 <geekosaur> so you will need to either find out what is not using pkg-config and make it use pkg-config, or use --extra-lib-dirs and --extra-include-dirs to tell it how to find the C library (and headers if needed) directly
13:09:02 <fizbin> c_wraith: How so?
13:09:07 <geekosaur> orion: that's a cabal library not a C library
13:09:12 <tapuu> How are you supposed to define instances of typeable for things in the latest version of base?
13:09:45 <c_wraith> tapuu: derive them
13:09:54 <orion> geekosaur: libsodium is a library written in C that I specified in the cabal file.
13:10:06 <orion> oh wait
13:10:14 <Rodya_> thanks a lot for the help
13:10:19 <c_wraith> > Just "foo" <> Just "bar"
13:10:20 <lambdabot>  Just "foobar"
13:10:25 <Rodya_> i'm gonna keep playing with it and see if it'll grok
13:10:30 * orion is confused
13:10:32 <geekosaur> "Dependency libsodium -any" refers to a cabal library which is presumably a wrapper for the C library
13:10:36 <c_wraith> fizbin: that's not the result of either part.
13:10:59 <tapuu> c_wraith: Is there no way to give a custom instance?
13:11:01 <geekosaur> because C libraries can't have "-any", that's a (null) Cabal version constraint
13:11:05 <fizbin> c_wraith: So?
13:11:05 <c_wraith> tapuu: nope.
13:11:18 <fizbin> I admit I don't see the issue.
13:11:28 <c_wraith> fizbin: so it isn't "select a success result"
13:11:30 <orion> oh
13:11:42 <orion> So, in other words cabal is looking for a haskell library, not a C library.
13:11:56 <geekosaur> hm, it might be a pkg-config version constraint, don't know for certain about that. but the cabal file is *also* looking for a C library, without using pkg-config, for some reason
13:12:51 <geekosaur> orion: what part of "Missing C library" says Cabal library to you?
13:12:52 <orion> pkgconfig-depends:   libsodium <-- if I remove that line, cabal successfully configures.
13:13:07 <geekosaur> or means "not a C library" to you?
13:13:13 <c_wraith> tapuu: it *does* mean there are types that can't have Typeable instances at all, now.  I consider that to be a bug in the implementation, but the concept is definitely good. The whole idea is preventing cast from making programs crash because of bad Typeable instances
13:13:19 <orion> geekosaur: Your statement "refers to a cabal library"
13:13:47 <geekosaur> [23 20:11] <geekosaur> hm, it might be a pkg-config version constraint, don't know for certain about that. but the cabal file is *also* looking for a C library, without using pkg-config, for some reason
13:14:16 <orion> That doesn't make sense to me, because if I remove the pkgconfig-depends line, it configures properly.
13:14:23 <geekosaur> also I don't know enough about what you're trying to do to sensibly decipher all of it
13:14:50 <orion> What's puzzling is that the system installed version of cabal, 1.16, works fine WITH the pkgconfig-depends line.
13:15:35 <geekosaur> er. that would be a bad sign, if different cabal library versions are not handling pkg-config stuff the same way
13:15:55 <geekosaur> or you're mixing Cabal library versions and it's confusing itself; I think I saw some mention of that recently
13:19:01 <orion> ghc-pkg reports that I have a system-wide Cabal library (1.16) installed, and a home-directory version (1.20) installed.
13:19:16 <bennofs> orion: what does cabal --version say?
13:19:52 <orion> cabal-install version 1.20.0.0
13:19:52 <orion> using version 1.20.0.0 of the Cabal library
13:20:04 <orion> That's the version that *doesn't* work.
13:20:50 <orion> The version that does correctly find libsodium with NO changes to the cabal file is 1.16.0.2 / 1.16.0, and it's the system-wide installed version of cabal.
13:29:39 * hackagebot signed-multiset 0.4 - Multisets with negative membership.  http://hackage.haskell.org/package/signed-multiset-0.4 (StefanHoldermans)
13:29:40 <geekosaur> 1.20 was just released, maybe it's buggy
13:29:59 <geekosaur> like I got the release notification in my inbox first thing this morning
13:32:01 <orion> If I put "cabal-version: >=1.20" in a cabal file and try to run it with 1.16, what should happen?
13:32:42 <orion> Should it give a warning and continue, or an error and stop?
13:35:11 <orion> 1.16 is able to configure the project successfully. HOWEVER, if I change "cabal-version" from ">=1.10" to ">=1.20", cabal-1.16 fails:
13:35:13 <orion> setup-Cabal-1.20.0.0-ghc-7.6.3: Missing dependency on a foreign library:
13:35:13 <orion> * Missing C library: sodium
13:37:11 <orion> I guess I'll just write off 1.20 as buggy for now.
13:38:33 <c_wraith> If you're going to do that, at least submit a bug report
13:39:26 <identity> orion: did you try removing the 'system wide' cabal? I assume that is something that came from your distro's package manager or some such?
13:39:40 * hackagebot perceptron 0.1.0.3 - The perceptron learning algorithm.  http://hackage.haskell.org/package/perceptron-0.1.0.3 (StefanHoldermans)
13:39:41 <identity> I'd go ahead and remove everything, fetch the platform and build it yourself
13:42:47 <KatZilla> :t json
13:42:48 <lambdabot> Not in scope: ‘json’
13:42:54 <KatZilla> :m + Web.Scotty
13:42:57 <KatZilla> :t json
13:42:58 <lambdabot> Not in scope: ‘json’
13:43:07 <KatZilla> :t Web.Scotty.json
13:43:07 <lambdabot> Not in scope: ‘Web.Scotty.json’
13:44:19 <fizbin> Are there any articles or books people know about that talk about the general process of taking an algorithm defined on a datastructure that gets mutated as part of the algorithm to working on an immutable datastructure?
13:44:54 <startling> fizbin: it's not really something that you do
13:44:56 <orion> identity: You're right, I used FreeBSD's ports to install haskell-platform.
13:45:10 <orion> I'll try building it from scratch -- that's a good idea.
13:45:48 <fizbin> I have this algorithm that is dirt simple in python and trying to replace most of the process in haskell is being nasty, because the python algorithm relies on being able to mutate things.
13:46:11 <geekosaur> interesting, it wouldn't install for me (kept trying to reinstall over hs-GLUT)
13:46:24 <zoomshorts> very basic question
13:46:26 <Eduard_Munteanu> Are there any nice markup languages that support math, preferably favoring readability of the markup / easy input, that would be worth looking at? I'm looking for an alternative to LaTeX.
13:46:51 <zoomshorts> inserting multiple entries from lists, can I use wildcards like 0-4
13:46:53 <zoomshorts> ?
13:47:04 <Eduard_Munteanu> An alternative that makes it easy to reason about the math on a computer rather than on paper and then transcribing it.
13:47:16 <Eduard_Munteanu> Er, I thought I was in -blah.
13:47:47 <Eduard_Munteanu> > [0..4] -- zoomshorts
13:47:48 <lambdabot>  [0,1,2,3,4]
13:48:00 <Eduard_Munteanu> zoomshorts: like that?
13:48:09 <zoomshorts> Eduard_Munteanu: thank you
13:48:13 <zoomshorts> Eduard_Munteanu: that should work
13:48:29 <zoomshorts> Eduard_Munteanu: learning hakell without a uni is hard XD
13:49:30 <taktoa> have you tried LYAH or Real World Haskell?
13:49:32 <Eduard_Munteanu> zoomshorts: nah, I did it while I was a student, but they didn't teach it to me. :)
13:50:10 <c_wraith> zoomshorts: Absolutely none of what I've learned about haskell came from formal instruction!
13:51:35 <south> Hi everyone!
13:51:43 <south> Does anyone happen to have any idea what's going on here?: http://lpaste.net/103129
13:52:06 <south> I'm so confused, the types match up just fine
13:56:09 <c_wraith> south: what line is line 90?
13:56:30 <napping> south: your type signature says DijkstraState e v but you're doing something inside that requries e to be Int
13:56:37 <south>     g     <- use underlyingGraph
13:57:19 <tapuu> I had to edit mflow to get it to compile under latest GHC, is mflow supposed to support 7.8.2?
13:58:06 <geekosaur> a lot of stuff has not yet been updated for 7.8, I think
13:58:21 <south> napping: holy shit
13:58:31 <south> I can't believe that was the issue, that's so confusing!
13:58:36 <south> but thank you so much!
13:58:37 <rntz> are closed type families in some version of ghc at this point, and if so, which version(s)?
13:58:52 <c_wraith> rntz: 7.8.*
13:59:16 <c_wraith> rntz: but don't use 7.8.1, it has some bad bugs that 7.8.2 fixed
13:59:28 <rntz> ah, that far off? I'm still on 7.6.3
13:59:39 <south> take care all
13:59:42 * hackagebot bifunctors 4.1.1.1 - Bifunctors  http://hackage.haskell.org/package/bifunctors-4.1.1.1 (EdwardKmett)
13:59:43 <c_wraith> 7.8.2 is out
13:59:53 <c_wraith> has been for at least a week
14:00:07 <intrados> What does `cabal repl target` actually do? `cabal repl` and `cabal test` both work but `cabal repl test` complains about hidden packages.
14:00:20 <napping> south: for a "could not deduce" error, don't even bother looking at the "possible fix", just look real close at the desired instance
14:00:22 <rntz> yeah, but I'm not going to go through the hassle of maintaining my own haskell install instead of using my package manager just for this one feature. oh well.
14:00:30 <rntz> thanks!
14:14:53 <ion> Seen in a commit message: “The OOM was cabal's way of telling us it couldn't resolve dependencies.”
14:19:00 <monochrom> hehe
14:19:35 <deni> hi there...what's the preffered way to install haskell on debian? (i've been told by a few ppl not to install haskell-platform because it installs *a lot* of fluff)
14:19:41 <deni> (they may be wrong) :)
14:19:56 <prophile> personally, I'd advise installing the haskell platform
14:20:12 <deni> prophile: it does get like 800mb or so of stuff
14:20:31 <prophile> 800 millibits is tiny!
14:20:40 <c_wraith> I just install the linux binary build
14:20:45 <c_wraith> Much easier than the platform
14:20:54 <deni> prophile: :P
14:21:05 <deni> c_wraith: haskell-cabal-install  ?
14:21:19 <ion> deni: Dunno about preferred, but i do this. https://gist.github.com/ion1/2815423
14:21:27 <c_wraith> deni: I build it with the bootstrap script in its repo
14:21:44 <c_wraith> deni: I don't touch debian packages.  Their rate of screwing stuff up is very high.
14:21:48 <tapuu> I also prefer installing the latest binary build from https://www.haskell.org/ghc/dist
14:22:57 <deni> c_wraith: tapuu what ion suggests seems reasonable to me.....doesn't pollute the system that much. and i can just rm -rf it when not needed
14:23:00 <deni> ion: tnx
14:24:00 <deni> tnx for your help guys....i don't have mistrust in deb packages it's just that i wan't to have my workstation as lean as possible....meaning when i upgrade that i don't have to upgrade a gazillion packages
14:24:15 <deni> that's why i don't like the haskel-platform approach
14:25:01 <tapuu> ion: your gist installs 7.8.1, you should probably change it to 7.8.2 before somebody uses it
14:26:03 <ion> tapuu: Updated
14:26:13 <tapuu> ion: :)
14:30:40 <Athas> Has anyone here ever used a Python syntax quasiquoter?  I found a language-python package, but it does not seem to come with quasiquoting facilities.
14:33:55 <afleck> is there a function that will add two numbers inside a monad? like f (Just 3) (Just 4) would give (Just 7)
14:34:09 <afleck> but for any monad, not just the Maybe monad
14:34:21 <Lethalman> :t liftM2
14:34:22 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:34:32 <Lethalman> :t liftM2 (+)
14:34:32 <lambdabot> (Num r, Monad m) => m r -> m r -> m r
14:34:36 <vermeille> afleck: like (+) <$> (Just 3) <*> (Just 4) ?
14:35:27 <acomar_> hey, trying to use cpphs to get rid of some FFI boilerplate, but I can't seem to find any examples on its usage. Anyone know where I should look?
14:35:49 <afleck> lethalman: looks pretty cool, is the definition of liftM2 simliar to what vermeille said?
14:36:12 <vermeille> afleck: liftM2 deals with monads, I deal with Applicative
14:36:20 <croyd> @src liftM2
14:36:20 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:36:34 <geekosaur> sort of. vermeille showed you applicative syntax; liftM2 predates it by something like a decade
14:36:39 <vermeille> (which is theoritically a superclass of Monad)
14:36:50 <geekosaur> but they do the same thing via different interfaces
14:37:48 <afleck> does x1 <- m1 take whatever is inside m1 and bind it to x1?
14:38:02 <_d0t> hi. Say I have two different type classes. Is it possible to write an instance of one type class for all of the instances of the other one?
14:38:33 <shachaf> There is nothing "inside" m1.
14:38:37 <shachaf> _d0t: Usually not usefully.
14:38:51 <_d0t> shachaf: actually it might be very useful
14:39:00 <_d0t> I'm talking about Storable and Binary
14:39:26 <shachaf> _d0t: Usually you can't do it in a useful way.
14:39:34 <_d0t> shachaf: what do you mean?
14:39:41 <jle`> instance (Binary a) => Storable a where ...
14:39:45 <shachaf> I mean that the cases where you can do it probably don't help you do what you want.
14:40:17 <Peaker> _d0t: you can write it -- the problem is that instance selection completely ignores the class constraints on instances - which are required to make this kind of thing work reasonably
14:40:18 <shachaf> You can say instance Foo a => Bar a where ... (I think with GHC extension required)
14:40:27 <shachaf> But that instance will overlap with every other instance of Bar.
14:40:38 <afleck> shachaf: I'm confused
14:40:41 <Peaker> overlap-with-everything *could* be fine, if instance selection was smarter
14:41:04 <_d0t> So, generally it's not worth that. Thanks.
14:41:18 <jle`> you wouldn't be able to meaningfully define your own 'special instance' of Bar, like instance Bar Int
14:41:27 <jle`> except with overlapping and undecidable instances, i think
14:41:51 <afleck> shachaf: Isn't monad a typeclass?
14:42:15 <shachaf> Monad is a type class.
14:43:03 <afleck> does, for example, x <- (Just 3) bind 3 to x?
14:43:20 <pranz> if you're in the maybe monad, yes
14:43:22 <shachaf> It's meaningless on its own.
14:43:32 <jle`> x <- Just 3 is sort of meaningless in a vacuum
14:43:33 <pranz> but then you can only use it in that block
14:43:46 <bitemyapp> afleck: it's syntax for (Just 3) >>= (\x -> ....rest of the program...)
14:43:58 <shachaf> You can talk about do { x <- Just 3; ... }
14:44:03 <dmj`> "-fglasgow-exts is deprecated: Use individual extensions instead", what is "individual extensions" ?
14:44:07 <bitemyapp> afleck: the problem is, <- isn't necessarily going to be >>= *for* Maybe because of the way the syntax works.
14:44:17 <bitemyapp> dmj`: language pragmas.
14:44:19 <shachaf> But since you're talking about monads in general, Maybe is probably not a useful example.
14:44:30 <shachaf> Try [] and (Int ->)
14:44:40 <dmj`> bitemyapp: I understand what a language pragma is, you didn't read the question
14:45:02 <jle`> dmj`: i think glasgow-exts is just a grab bag of various extensions
14:45:03 <pranz> dmj`: you don't need any compiler flags
14:45:06 <bennofs> dmj`: are you asking what language pragmas are enabled by -fglasgow-exts?
14:45:13 <jle`> they recommend you just enable them individually
14:45:29 <jle`> -XOverloadedStrings, etc.
14:45:44 <geekosaur> dmj`, can't tell what extensions are required just from that, would need to examine the source to see which ones it's using
14:45:48 <afleck> shachaf: I'm new to the whole Monad thing, as you can tell, so I was fooling around with an identity Monad
14:46:31 <afleck> I managed to define adding within monads by two nested binds and lambdas, but I was wondering if there was another way
14:46:32 <jle`> for the identity monad, the semantics of bind are that function that is being bound is given the value inside Identity
14:46:46 <shachaf> No other way.
14:46:47 <dmj`> the package I'm using is old, from 2008, and has {-# OPTIONS -fglasgow-exts #-} at the top, cabal issues a warning saying it's deprecated. What was fglasgow-exts comprised of?
14:46:49 <shachaf> That's how liftM2 works.
14:46:51 <shachaf> @src liftM2
14:46:51 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:46:55 <shachaf> @@ @undo @src liftM2
14:46:55 <lambdabot>  liftM2 f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2);
14:47:16 <savanni> dmj`: you could completely remove that and the compiler will give you suggestions as to what extensions you need.
14:47:21 <thoughtpolice> dmj`: it turned on literally everything, which is terrible.
14:47:33 <afleck> shachaf : yep, thats exactly what it looks like
14:47:34 <thoughtpolice> just take it out, and the compiler will tell you what to add for the most part, as savanni said
14:47:35 <artyomkazak> dmj`: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/ghc-language-features.html
14:47:36 <afleck> i see now
14:47:39 <jle`> if your Monad is an instance of Applicative then you can use the various Applicative combinators
14:47:47 <jle`> for example, to add Just 3 and Just 5
14:47:49 <thoughtpolice> savanni: hi btw (it's aseipp :)
14:47:52 <jle`> you can fmap (+) onto Just 3
14:47:54 <jle`> to get Just (+3)
14:47:59 <savanni> Oh, hi, thoughtpolice
14:48:02 <artyomkazak> dmj`: (at the end)
14:48:05 <jle`> and then use <*>
14:48:07 <jle`> :t (<*>)
14:48:08 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:48:21 <pranz> or use the shorthand, liftA2
14:48:23 <jle`> which takes a Just (+3) and a Just 5 and returns Just (3+5)
14:48:28 <pranz> :t liftA2 (+)
14:48:29 <lambdabot> (Applicative f, Num c) => f c -> f c -> f c
14:48:41 <jle`> i mixed up all sorts of operators thjere
14:48:56 <acomar_> anyone know how to declare a macro with cpp/cpphs? the usual c preprocessor syntax doesn't quite translate...
14:48:56 <savanni> thoughtpolice: hey, do you know if there's any interest in getting the Austin Haskell community running again?
14:49:11 <jle`> > (+) <$> Just 3 <*> Just 5
14:49:12 <lambdabot>  Just 8
14:49:15 <geekosaur> acomar_, it should modulo differences between haskell and c syntax
14:49:34 <jle`> :t fmap (+) (Just 3)
14:49:35 <lambdabot> Num a => Maybe (a -> a)
14:49:39 <jle`> :t Just 5
14:49:40 <lambdabot> Num a => Maybe a
14:49:46 <acomar_> geekosaur: I guess, that's what I can't figure out, I'll post a paste
14:49:47 <jle`> :t (<*>)
14:49:47 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:49:52 <shachaf> afleck: I was objecting to the idea that there's a value "inside" m1, because there usually isn't.
14:50:19 <shachaf> afleck: Identity and Maybe are pretty special cases, and if you just look at them you might get bad intuition like that.
14:50:37 <afleck> shachaf: I don't know any other monads yet, realy
14:50:57 <jle`> "insideness" is a part of the semantics for Identity and Maybe, but it is not a part of the semantics or meaning of monads in general
14:51:11 <deni> afleck: there's really a great chapter on applicative (with just the example you mentioned here) in lyhfg book
14:51:12 <shachaf> Then you should probably delay "learning about Monad" until you do. :-)
14:51:14 <pranz> btw, what is an example of a datatype that is applicative but not a monad?
14:51:19 <jle`> just like another typeclass, Eq
14:51:28 <jle`> numberness is a property of various Eq instances, like Int and Integer
14:51:40 <acomar_> geekosaur: http://lpaste.net/103131 this obviously doesn't work, but I have no clue what to try and I can't find any examples on google
14:51:40 <jle`> but a lot of Eq instances do not have a concept of "numberness"
14:51:45 <shachaf> You actually do know some other types that have Monad instances, though.
14:51:48 <jle`> pranz: zip lists are the canonical example i think
14:51:54 <shachaf> Lists and functions are two examples.
14:52:07 <acomar_> geekosaur: ack, typo in that one, I'll edit in a sec
14:52:26 <acomar_> fixed
14:52:28 <thoughtpolice> savanni: yes! bitemyapp was complaining to me about this actually, and i'm in talks with someone now at Rackspace
14:52:36 <afleck> deni: In lyhfg the only Monad he ever talks about is Maybe
14:52:40 <jle`> > [1,2,3] >>= (\x -> [x,-x])
14:52:41 <lambdabot>  [1,-1,2,-2,3,-3]
14:52:44 <thoughtpolice> savanni: i've just been a bit swamped. i'll go ahead and follow up with Francesco and Sukant now that you mention it
14:52:46 <jle`> i'm pretty sure he talks about many monads
14:52:49 <jle`> (i read the book)
14:53:01 <jle`> State, Writer, Reader ((->)), List
14:53:05 <jle`> at least
14:53:08 <deni> afleck: i'm not talking about monads i'm talking about the applicative chapter
14:53:27 <deni> the examples that ppl pasted here are covered in more detail in that chapter.
14:53:44 <deni> afleck: just read it so it's fresh :)
14:53:49 <afleck> deni: yes, but all of his examples are in terms of Maybe
14:53:53 <pranz> jle`: but [] does have a monad instance
14:54:03 <jle`> pranz: yeah, so we have a newtype wrapper
14:54:15 <pranz> jle`: I mean types that can not be monads, but are applicative
14:54:16 <jle`> over the zip-list applicative instance
14:54:29 <jle`> oh
14:54:59 <deni> afleck: sure enough. but that shouldn't stop you from groking applicative.. and figuring out how to apply a regular function to the value inside a monad
14:55:17 <jle`> (+) <$> (ZipList [1,2,3]) <*> (ZipList [6,7,8])
14:55:21 <afleck> deni: but according to shachaf, the idea of insideness is one I should avoid
14:55:22 <jle`> > (+) <$> (ZipList [1,2,3]) <*> (ZipList [6,7,8])
14:55:23 <lambdabot>  ZipList {getZipList = [7,9,11]}
14:55:58 <deni> afleck: the functions know how to deal with Nothing....or atleast you make sure they do
14:56:13 <shachaf> pranz: Const r for r /= ()
14:56:14 <deni> afleck: trust me...reading that chapter should clear a lot of this stuff up
14:56:19 <deni> afleck: just my 2c
14:56:22 <deni> i'm no expert
14:57:57 <geekosaur> oh huh the freebsd hs-GLUT thing got fixed overnight. good portsnap :)
14:58:17 <pranz> shachaf: ah, didn't think of phantom types
14:59:56 <pranz> shachaf: wait, can you even do a pure for Const r?
15:00:40 <deni> ion: what do the 2 settings ibrary-profiling and documentation in cabal/config do?
15:00:41 <shachaf> pranz: For Monoid r.
15:00:54 <shachaf> pranz: It's like Writer without the value.
15:01:44 <ion> deni: One builds variants of libraries with profiling turned on for when you want to profile your code that uses those libraries. Building libraries will take twice the time. The other builds local haddock documentation.
15:02:31 <deni> ion: tnx
15:18:40 <joneshf-laptop> bear with me on this one
15:19:06 <joneshf-laptop> so it seems one of the problems with full dependent types is that you can't really have non-terminating programs, right?
15:19:23 <joneshf-laptop> could we use soemthing similar to type erasure at the dependent level
15:19:38 <joneshf-laptop> and say, check that the dependent part of the type holds in one phase of compilation
15:19:44 <joneshf-laptop> erase the dependent bits
15:19:55 <joneshf-laptop> and continue on with the normal compilation phases after that?
15:20:24 <joneshf-laptop> or does that not get us anything?
15:22:16 <dwcook> Where does dependent typing imply guaranteed termination?
15:22:33 <merijn> joneshf-laptop: You are thinking of total languages
15:22:53 <joneshf-laptop> oh?
15:23:04 <merijn> joneshf-laptop: Agda is *both* dependently typed *and* total, but the two don't necessarily have anything to do with eachother
15:23:05 <pjdelport> joneshf-laptop probably meant to say type checking is not guaranteed to terminate?
15:23:19 <merijn> pjdelport: It is
15:23:33 <pjdelport> (depending on what "full" dependent typing means)
15:23:45 <merijn> pjdelport: I'm not aware of any "big" dependently typed language that has undecidable type checking
15:27:00 <thoughtpolice> Cayenne (one of the many of Lennarts' children) at least, was dependently typed and just let the user have a timeout on how long typechecking takes, and gave up once that timeout was reached. but it's not exactly big, more like old :)
15:28:41 <merijn> My point was that since several big ones do have type checking that's guaranteed to terminate, clearly that is possible too :)
15:29:00 <thoughtpolice> heh, Cayenne even had a Lazy ML backend, https://github.com/csgordon/cayenne/blob/master/ToLML.hs
15:29:22 <ReinH> c_wraith: my issue with the Monoid instance for Maybe is that the constraint *should* be Semigroup a => Monoid a, because that's exactly how you turn a semigroup into a monoid.
15:29:35 <ReinH> er Semigroup a => Monoid (Maybe a)
15:30:08 <ReinH> and Option (Maybe a) is cumbersome
15:32:38 <JagaJaga> how to make my grammar avoid such things? to parse smth like `a(x - 3) + b(x - 8)` not like `a((x - 3) + (b (x - 8)))`? Made in my happy file `%left '+' '-'` but no result...
15:52:58 <lasericus> I am having a difficult time determining why a polymorphic data type I’ve declared:
15:53:00 <lasericus> data Stream a = Cons a (Stream a)
15:53:33 <lasericus> blows up when I try to instantiate it with: let x = Cons 1 (repeat 1)
15:53:51 <jle`> lasericus: define blows up
15:54:01 <jle`> for one...i'm not sure that typechecks
15:54:09 <lasericus> The expected type is ‘Stream’ and the actual type is [a0]
15:54:16 <jle`> :t repeat 1
15:54:17 <lambdabot> Num a => [a]
15:54:26 <jle`> do you know about algebraic data types?
15:54:32 <jle`> what Cons a (Stream a) means?
15:54:44 <jle`> it means that Cons is a constructor that takes an a and a Stream a and returns a Stream a
15:54:50 <jle`> Cons :: a -> Stream a -> Stream a
15:54:57 <lasericus> Well, I thought I did but this line of questioning leads me to believe that I do not.
15:55:08 <jle`> so the first item you pass into cons is 1
15:55:15 <jle`> let's say, Int
15:55:19 <jle`> the second item has to be Stream a
15:55:19 <lasericus> sure, I’m with you
15:55:22 <jle`> Stream Int
15:55:29 <jle`> but observe carfully
15:55:34 <jle`> :t repeat (1 :: Int)
15:55:35 <lambdabot> [Int]
15:55:40 <jle`> repeat 1 is not Stream a
15:55:44 <jle`> repeat 1 is [Int]
15:55:52 <jle`> Stream Int /= [Int]
15:56:45 <jle`> it's like, say, trying to do something like 5 + [4]
15:56:56 <jle`> or [9] && True
15:57:07 <lasericus> What’s perplexing to me is that the Stream data type (as provided by Data.Stream)
15:57:41 <lasericus> follows a similar (the same) pattern and is used in a similar fashion
15:58:07 <jle`> oh, ther eis a Data.Stream.repeat :: a -> Stream a
15:58:16 <jle`> if you are getting that terror, then you are probably using repeat from Prelude
15:59:04 <lasericus> Oh, of course. I see now. As an example, the implementation of dropWhile (from Data.Stream) is doing a Cons x xs
15:59:12 <lasericus> but xs is of type Stream, not [a]
15:59:30 <lasericus> silly error, my mistake. Thanks for the help
15:59:37 <jle`> np
16:03:50 <lasericus> out of curiosity, what could a constructor for the Stream data type look like that would accept only infinite lists of a?
16:04:52 <lasericus> I suppose something like data Stream = Cons a (List a) would not enforce that the list was not empty
16:04:59 <lasericus> rather, infinite
16:05:06 <Algebr> Something like [Int, Int] doesn't make sense, correct?
16:05:32 <apples> data Stream a = Cons a (Stream a) is enforcing that it has an infinite stream
16:06:05 <lasericus> @apples true - but I’d like to be able to create a stream from an infinite list: the result of Data.List.repeat 5 (for instance)
16:06:05 <lambdabot> Unknown command, try @list
16:06:15 <geekosaur> Algebr: correct
16:06:56 <Kaye18>  Here some videos. I hope you like them! http://bitly.com/1gAh6Jy
16:06:57 <apples> lasericus, f (x:xs) = Cons x (f xs) -- it's partial though
16:07:03 <geekosaur> multidimensional arrays exist but are not the same as lists and don't get any fancy built-in syntax
16:07:24 <lasericus> apples: interesting, thanks
16:08:05 <MagneticDuck> [record| Foo { a = 1 } |] -- <-- waht is this? From a lens-related context, perhaps it's some TH haskell?
16:08:11 <MagneticDuck> s/TH haskell/TH
16:08:27 <geekosaur> it looks like a quasiquoter, which is related to TH, yes
16:08:46 <MagneticDuck> quasiquoter... mmm
16:11:00 * MagneticDuck remembers about QQs
16:11:06 <MagneticDuck> yes, yes
16:11:48 <MagneticDuck> it's interesting how there are always things that are impossible to do concisely inside of any language, and require TH haskell
16:12:17 <MagneticDuck> ...but that should imply that, to be able to do absolutely everything "concisely", not even TH is enough!
16:12:22 <MagneticDuck> we need a meta TH
16:12:32 <MagneticDuck> and an infinite sequence of higher-order template codes
16:12:37 <MagneticDuck> :D
16:12:42 <silasm> can't you generate TH from TH?
16:12:43 <zzzzzzzziiii> wow...-O2 brings down the execution time from more than 2m to less than 3s
16:12:45 <MagneticDuck> s/TH haskell/TH ._.
16:13:03 <MagneticDuck> silasm: I don't think so, but that would be interesting.
16:13:04 <silasm> I seem to remember the Yesod book saying you could.
16:13:06 <geekosaur> somewhere there is probably a proof about it. in fact, hm, wasn't I reading about one recently?
16:13:18 <MagneticDuck> (programs that can generate themselves at runtime)
16:13:31 <MagneticDuck> I wonder if a language like that could do absolutely everything concisely...
16:13:36 <MagneticDuck> well, I guess so
16:13:44 <MagneticDuck> you can abstract as many levels as you want
16:14:25 <geekosaur> some relative of http://en.wikipedia.org/wiki/Tarski%27s_indefinability_theorem ?
16:14:59 <MagneticDuck> of course, in practice, the complication that multiple levels of meta-templates + added compilation time + eventually larger code base would outrule the practical benifits...
16:15:04 <MagneticDuck> geekosaur: yeah
16:15:35 <silasm> geekosaur: https://en.wikipedia.org/wiki/Goedel's_incompleteness_theorem ?
16:15:48 <MagneticDuck> tarski came after godel
16:15:53 <MagneticDuck> but they're related yeah
16:15:57 <silasm> although I guess that's not about conciseness.
16:16:06 <geekosaur> silasm, certainly in that arena although I think I'd point back to Cantor diagonalization as the foundation
16:16:16 <MagneticDuck> they don't use the term "completely concise"
16:16:26 <MagneticDuck> but it's a similiar question
16:16:47 <MagneticDuck> that's what I like about math, everybody eventually says the same thing if they don't watch out =P
16:17:30 <MagneticDuck> cantor diagonalization is nifty, I always like to scare my friends with it... but godel's theorm is a few levels above that =P
16:17:40 <MagneticDuck> why am I ending all of my lines with a =P
16:17:44 <vermeille> There are waaay too much packages of various quality in Hackage :(
16:17:49 <geekosaur> hey, sometimes saying the same thing is the intent
16:18:08 <geekosaur> (proving an isomorphism between two apparently different things)
16:18:14 <MagneticDuck> geekosaur: https://www.youtube.com/watch?v=RNC-aj76zI4
16:18:17 <MagneticDuck> :D
16:18:25 <MagneticDuck> I would sing along, but I don't have sound atm
16:18:42 <MagneticDuck> vermeille: a lot of them are abandoned :<
16:18:48 <MagneticDuck> hackage is a bit of graveyard
16:19:08 <geekosaur> it happens
16:19:17 <MagneticDuck> luckily there are quite a few living specimens about there too
16:19:36 <vermeille> MagneticDuck: is there a simple way to know which packages are reliable?
16:19:54 <MagneticDuck> check the last version release date =P
16:19:55 <geekosaur> someone writes a package to solve a problem they have, and having solved it they move on. the next person who cares shows up years later and is frustrated by an out of date solution.
16:20:45 <geekosaur> you think hackage is bad, try cpan sometime
16:21:08 <vermeille> Haskell lacks a lot of "standard" libraries for various purposes. Drawing, sound, parsing, etc
16:21:12 <geekosaur> (or ctan which last I looked had a lot of tex2 cruft still in it)
16:21:20 <vermeille> Like C++ :)
16:21:48 <vermeille> I try to stay away from LaTeX as much as possible. Thankfully pandoc exists
16:21:50 <MagneticDuck> vermeille: parsing?
16:21:52 <bennofs> vermeille: stackage includes a lot of the better maintained packages
16:22:23 <vermeille> MagneticDuck: I mean, not parser combinators, but already defined parsers for various formats
16:22:44 <MagneticDuck> vermeille: ahk, I thought you were about to ignore the all mighty parsec
16:22:51 <MagneticDuck> one of haksell's great achievements =P
16:22:55 <MagneticDuck> haskell*
16:23:22 <mister_integer> parsec is my favorite library in any language
16:23:29 <vermeille> I wouldn't dare :D I even rewrote a parsec-like C++ metaprogrammed parser combinator article :D
16:23:37 <mister_integer> like, a JSON parser is probably a 15 liner
16:23:46 <bennofs> 15 liner? :O
16:23:53 <MagneticDuck> hmm... thinking about programs that are their own templates are cool
16:24:38 <MagneticDuck> essentially, the compiler could recurse on the source, evalulating the code and putting the results back in using determined rules...
16:24:47 <vermeille> bennofs: is Stackage just a git repo?
16:24:47 <MagneticDuck> oh wait, that's a celular automata
16:25:05 <MagneticDuck> celular automata: the future of programming :D
16:25:33 <bennofs> vermeille: it's a "list"/collection of packages
16:25:58 <MagneticDuck> speaking of that
16:26:13 <MagneticDuck> any good celular automata stuff out there in haskell?
16:26:39 <vermeille> bennofs: Oh right! this http://daniel-diaz.github.io/stackagelist/ ?
16:28:02 <MagneticDuck> by stuff, I mean stuff being done
16:28:08 <afleck> typeclassopedia seems a lot better for learning about Functors and Up than LYAH
16:28:22 <afleck> its way harder, but more instructive
16:28:31 <vermeille> afleck: Typeclassopedia is more formal
16:28:45 <levi> Typeclassopedia is awesome.
16:28:51 <vermeille> you have to first have the intuition through LYAH imho
16:29:01 <MagneticDuck> yes
16:29:46 <afleck> I'm just slogging through it
16:29:55 <MagneticDuck> LYAH?
16:30:08 <afleck> MagneticDuck: Learn you a haskell
16:30:09 <vermeille> MagneticDuck: Learn You A Haskell (for a great good)
16:30:09 <silasm> @where lyah
16:30:10 <lambdabot> http://www.learnyouahaskell.com/
16:30:19 <MagneticDuck> yes I know xD
16:30:25 <MagneticDuck> I was asking afleck if he was using it
16:30:33 <MagneticDuck> lyah is great good
16:31:50 <afleck> Oh. I used it to kind of get acquainted with Haskell syntax since I was already acclimated to functional programming from Common Lisp, but the later chapters on the category theory stuff seemed slow to me so someone here pointed me to typeclassopedia
16:32:47 <afleck> typeclassopedia is hard, but reading it is really instructive. You have to kind of let everything sit for a while and read each section multiple times
16:33:22 <shachaf> There's no "category theory stuff" in Learn You A Haskell.
16:35:50 <MagneticDuck> cya tomorrow
16:38:06 <vermeille> Greaaaaaaat, no 2D graphics library in Stackage.
16:38:32 <afleck> shachaf: I guess I didn't necessarily mean formal category theory, but rather the concepts from category theory as implemented in Haskell.
16:38:33 <monochrom> there is not enough supply
16:38:44 <afleck> shachaf: Functors exist in category theory, no?
16:39:13 <monochrom> to increase supply, the best way is to use the law of demand: increase price, pay up
16:40:37 <afleck> shachaf: What would you call Functors, Applicatives, Monoids, Monads, etc. as a group?
16:40:40 <btubbs> Trying to install postgresql-libpq on OSX and getting this error with libiconv.  A couple hours of googling and upgrading possibly-relevant packages hasn't fixed it.  ideas?  http://lpaste.net/103133
16:42:02 <geekosaur> you're mixing something built against system libraries against something built with macports/homebrew/fink. iconv problems are kinda the original bane of os x...
16:44:49 <btubbs> that sounds similar to the things i saw online, mostly involving macports (though i'm using homebrew)
16:45:54 <btubbs> i saw this advice on installing a newer libiconv, but not sure how to get GHC to use it: https://github.com/sparklemotion/nokogiri/wiki/Install-libiconv-on-OS-X-with-Homebrew
16:47:07 <geekosaur> homebrew has the same problem these days, yes. they learned the hard way, as macports did some 10 years before them, but since they're oh so much better they ignored it
16:56:41 <speckle> Sorry if this a stupid newbie question, but is there an easy way to know when an instance of something is generated (like the "new" keyword in Java)?  Or is that generally hidden from the programmer, and only apparent when profiling?
16:56:46 <btubbs> a search for libiconv.2.dylib makes me wonder if homebrew's really the problem, or if maybe it's Postgres bringing its own libiconv that's causing my issue http://lpaste.net/103134
17:00:41 <geekosaur> as I said but apparently not clearly enough for you, don't mix sources. if you use homebrew, install postgres from homebrew, don't install some other one. mixing stuff like that always ends in tears
17:00:48 <triliyn> speckle: in theory, it could be more difficult than this, but in practice a new thingy is generated if and only if you call a constructor
17:01:26 <triliyn> id a = a -- no constructor calls, so no new allocations-or-whatever
17:01:42 <speckle> Ah, type constructors/data constructors?  Alright, thanks!
17:02:13 <triliyn> specializedId (SomeWrapper a) = SomeWrapper a -- probably a new SomeWrapper is allocated, but a is not reallocated
17:05:14 <btubbs> thanks for your help geekosaur
17:22:40 <Algebr> When we put extend/put constraints on a typeclass, do we get the methods defined for the super typeclass?
17:24:05 <sellout> Algebr: It more means that in order to make an instance for the new typeclass, you first need to have an instance of the constraining class for that type.
17:25:13 <bucketh3ad> I am trying to run 'cabal update' on an AWS instance running Ubuntu 14.04 LTS, but it keeps timing out. I tried using the mirror but no luck. I can ping both sources just fine. What could be going wrong?
17:25:57 <Algebr> sellout: Ah, so you'd still end up having to define implementations for the super typeclass.
17:26:17 <sellout> Algebr: Exactly.
17:26:54 <Algebr> I stepped away from haskell for a few days and like magically things are starting to really come together.
17:35:39 <iron_houzi> Any slackware users know how to get cabal working on Slackware 14.1?
17:46:51 <johnchen902> @?
17:46:56 <johnchen902> @help
17:46:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:47:03 <johnchen902> @list
17:47:03 <lambdabot> What module?  Try @listmodules for some ideas.
17:47:12 <johnchen902> @listmodules
17:47:12 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
17:47:38 <johnchen902> @pl (\a b c d -> d - c - b - a)
17:47:39 <lambdabot> flip (flip . ((flip . ((-) .)) .) . flip (flip . ((-) .) . subtract))
17:48:18 <afleck> iroun_houzi: what's your problem?
17:48:38 <johnchen902> (\a b c -> (-b+sqrt(b*b-4*a*c)) / (2 * a) )
17:48:51 <johnchen902> @pl (\a b c -> (-b+sqrt(b*b-4*a*c)) / (2 * a) )
17:48:52 <lambdabot> ap (flip . ((flip . (((/) . negate) .)) .) . liftM2 (.) (+) . ((sqrt .) .) . flip ((.) . (-) . join (*)) . (*) . (4 *)) (2 *)
17:49:05 <geekosaur> some things just shouldn't be @pl-ed
17:49:33 <afleck> yes, good grief
17:50:25 <johnchen902> @pointful ap (flip . ((flip . (((/) . negate) .)) .) . liftM2 (.) (+) . ((sqrt .) .) . flip ((.) . (-) . join (*)) . (*) . (4 *)) (2 *)
17:50:26 <lambdabot> (\ g -> return ((\ ai b c f -> (negate ((\ j d -> return (\ p -> j ((\ bv by -> sqrt ((((*) >>= \ bi -> bi) bv) - ((4 * ai) * by))) d p)) d) ((+) c) c f)) / b) g ((\ z -> 2 * z) g)) g)
17:50:40 <johnchen902> @pointful (\ g -> return ((\ ai b c f -> (negate ((\ j d -> return (\ p -> j ((\ bv by -> sqrt ((((*) >>= \ bi -> bi) bv) - ((4 * ai) * by))) d p)) d) ((+) c) c f)) / b) g ((\ z -> 2 * z) g)) g)
17:50:40 <lambdabot> (\ g -> return (\ c f -> (negate (return (\ p -> c + (sqrt ((((*) >>= \ bi -> bi) c) - ((4 * g) * p)))) c f)) / (2 * g)) g)
17:51:17 <johnchen902> @pl (\ g -> return (\ c f -> (negate (return (\ p -> c + (sqrt ((((*) >>= \ bi -> bi) c) - ((4 * g) * p)))) c f)) / (2 * g)) g)
17:51:18 <lambdabot> ap (flip . ((flip . (((/) . negate) .)) .) . join . (return .) . liftM2 (.) (+) . ((sqrt .) .) . flip ((.) . (-) . join (*)) . (*) . (4 *)) (2 *)
17:56:00 <ReinH> johnchen902: stahp
17:57:20 <ozataman> Hi all -  Not having followed the recent work on exception handling - is the exceptions package meant to replace monad-control as well?
17:57:26 <napping> johnchen902: @pl works fine if you /msg lambdabot
17:59:33 <zcd> is there a good way to dissect the monads used in parsec
18:14:30 <Algebr> How is it that haskell is able to deal with such a level of abstraction with what is actually quite simple syntax?
18:14:57 <kfish> Algebr, algebra
18:15:11 <hpc> hehe
18:15:12 * hackagebot retry 0.4 - Retry combinators for monadic actions that may fail  http://hackage.haskell.org/package/retry-0.4 (OzgunAtaman)
18:21:59 <kfish> Algebra (from Arabic al-jebr meaning "reunion of broken parts"[1]) is how Haskellers think of software development
18:22:32 <Algebr> kfish: Are there some good papers/blogposts/articles about this?
18:26:14 <kfish> Algebr, there's a concise way of thinking, with types; I'm not sure what to recommend
18:26:35 <kfish> perhaps the typeclassopedia?
18:28:30 <ski> Algebr : the book "Algebra of Programming" by Richard Bird,Oege de Moor in 1996-09 might be interesting, if you're looking for algebraic ways to think about programming
18:44:08 <ReinH> ski: oh cool, "3 used from $733.23"
18:45:05 <ReinH> ski: also 1st ed. of intro to FP, $2432 new :D
18:59:47 <monochrom> I have Algebra of Programming hard cover :)
19:00:17 * hackagebot extensible-effects 1.6.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.6.0 (BenFoppa)
19:01:06 <anon123> @pl \f -> f 1 2 3
19:01:07 <lambdabot> flip (flip ($ 1) 2) 3
19:01:27 <Platz> ReinH: thanks for your environment page about neco-ghc.  Can't believe I didn't know about that plugin
19:02:10 <Platz> Was leaning emacs but now I'm back in the other direction
19:02:36 * StoneCypher wants to /nick ctorfunfun
19:09:36 <ReinH> Platz: it's pretty nice :)
19:17:25 <Tordek> is there some guideline as to when I should define a typeclass? e.g., I was playing with a paper on binomial queues; is it proper to define a Queue typeclass, and make implementations of the typeclass for different... well... implementations?
19:18:52 <kazu> Hello, everyone
19:19:10 <matttodd> I have a function that returns a double and I want to compare this to a float. How should I go about this?
19:20:04 <ski> Tordek : it might be, at least if you want to have operations polymorphic over queue implementations, and you have at least two queue implementations -- another feature that partially overlaps here is that of "module functors" (as in SML and OCaml. Haskell sadly doesn't have this)
19:22:49 <schlegel> matttodd: I would convert the float to a double then compare them
19:23:00 <ski> Tordek : if you don't have any queue operation which takes more than one queue as input, then it might work to instead explicitly pass around a record of queue operations (either coupled with the queue state (or partially applied to it) (OO), or not coupled with it (ADT))
19:23:43 <schlegel> matttodd: Either way it's a sticky subject as floating point errors can cause some funky results
19:24:33 <schlegel> matttodd: As (double) 1.1 != (float) 1.1
19:24:35 <Tordek> ski: I'm not quite sure how that works?
19:24:58 <napping> ski: or make the queue type a parameter of the record
19:25:31 <napping> Tordek: like data QueueOps q a = QueueOps {push :: a -> q -> q, pop :: q -> (a,q), pushEnd :: q -> a -> q ....}
19:25:32 <ski> napping : well, i was vague about that part :)
19:26:23 <Tordek> napping: and my queue "q" is some opaque type from the point of view of the user?
19:26:36 <matttodd> schlegel: thanks, I'll see what I can do
19:27:10 <ski> Tordek : e.g. `data Queue a = forall q. Q {queueState :: q,enqueue :: a -> q -> q,dequeue :: q -> Maybe (a,q)}' (coupled) or `data Queue a = Q {enqueue :: a -> Queue,dequeue :: Maybe (a,Queue)' (partially applied) or `data Queue a = forall q. Q {empty :: q,enqueue :: a -> q -> q,dequeue :: q -> Maybe (a,q)' (not coupled)
19:28:33 <ski> sorry, the middle one should use `Queue a', not `Queue', recursively
19:28:36 <Tordek> I kinda see, I kinda have no idea how forall works
19:28:51 <napping> Tordek: well, from the point of view of a method using a typeclass, like foo :: (Queue q) => ...., q is just an opaque type too
19:29:18 <ski> Tordek : those are existential variants (though it might make sense to replace the middle one (partially applied) by `data Queue a = forall q. Q (QImpl a q); data QImpl a q = QI {enqueue :: a -> QImpl a q,dequeue :: Maybe (a,QImpl a q)}' -- this would ensure that the same `q' representation type is used for the lifetime of the queue)
19:29:20 <napping> It's about packing up the operations, not really about whether the queue type is opaque
19:29:44 <napping> well, at least the way I wrote, not necessarily with all of ski's options
19:29:46 <ski> Tordek : also, one can skip the existential, if one doesn't need it
19:29:58 <ski> (which is what napping suggested)
19:30:02 <napping> if you happen to have e.g. a QueueOps ([a],[a]) a, the type isn't opaque to you
19:30:33 <napping> But of course any code that's polymorphic over multiple queue implementations can't do anything specific to the queue implementation
19:30:36 <matttodd> would the best way to convert a double to a float be unsafeCoerce? It doesn't seem ideal
19:31:01 <ski> Tordek : in some cases, you might want to keep the representation type non-abstract (so no existential), while in other cases, you might want to dynamically decide the representation type (so you probably one an existential)
19:31:48 <napping> matttodd: I'm a bit surprised that doesn't segfault
19:32:31 <napping> unsafeCoerce# (1.0 :: Float) :: Double has given me either 6.92561029841583e-310 or 5.263544247e-315
19:32:55 <napping> That's probably not even a "way", let alone the best way :)
19:33:15 <ski> Tordek : btw, one clarification re the "coupled" (OO) (including the "partially applied" version) vs. the "non-coupled" (ADT) version : with the former, you'd rewrap the new state with the operations, each time you applied an operation; while with the latter, you'd unpack the record once for all in some scope, and then manipulate a queue state explicitly with the extracted operations
19:33:17 <matttodd> napping: ah
19:33:31 <napping> matttodd: realToFrac is pretty good
19:33:32 <matttodd> napping: yes that seems bad.
19:33:43 <napping> I'd expect a Float and Double to actually be different sizes
19:33:54 <matttodd> napping: cool I'll check it out thanks
19:33:56 <lambdanoob> hi everyone
19:33:59 <lambdanoob>  doubleEveryOther :: [Int] -> [Int] doubleEveryOther (x:y:zs) = (x*2) : y : doubleEveryOther zs doubleEveryOther  [] = []
19:34:07 <Tordek> alright, I think I get how to do it... now for the million dollar question (?): Why should I prefer the record-passing method or the typeclass method?
19:34:10 <napping> maybe rounding up to multiples of the word size (on 64-bit OS) avoided a segfault
19:34:28 <lambdanoob> Non-exhaustive patterns in function doubleEveryOther
19:34:46 <ski> Tordek : on OO vs. ADT (Abstract Data Types, not Algebraic Data Types), you might be interested in "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf> -- TaPL also has some info on this distinction
19:34:52 <napping> matttodd: realToFrac is SPECIALIZE'd for common combinations, so it should be plenty fast
19:35:07 <Tordek> lambdanoob: which pattern matches "doubleEveryOther [5]"?
19:35:35 <ski> Tordek : also, if you haven't seen the original classic paper "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>, it's a good read
19:35:42 <Tordek> ski: I did read that paper (understanding it is a different matter altogether)
19:36:07 <ski> Tordek : "I kinda have no idea how forall works" -- in this case, the `forall' effects an "existential (data type)"
19:36:08 <andkore> A month or two ago there was a post on /r/haskell soliciting people's best tips. I can't seem to find it now. Anyone know what I'm talking about? It was a self post I think.
19:36:22 <Tordek> hmm, I think I read the latter, I don't remember if I read the former
19:36:38 <matttodd> napping: it works perfectly thanks!
19:36:38 <lambdanoob> my array would alays have even number of elements :)  how do i make it work?
19:36:55 <lambdanoob> thanks @Tordek
19:37:27 <ski> Tordek : given `data Queue a = forall q. Q {queueState :: q,enqueue :: a -> q -> q,dequeue :: q -> Maybe (a,q)}', we get
19:37:33 <ski>   Q :: forall q. q -> (a -> q -> q) -> (q -> Maybe (a,q)) -> Queue a
19:37:36 <ski> which of course is short for
19:37:40 <ski>   Q :: forall a q. q -> (a -> q -> q) -> (q -> Maybe (a,q)) -> Queue a
19:37:51 <ski> or, with Haskell98 syntax
19:37:54 <ski>   Q :: q -> (a -> q -> q) -> (q -> Maybe (a,q)) -> Queue a
19:38:24 <ski> Tordek : the important point to note is that the type variable `q' doesn't occur in the result type of the data constructor
19:38:50 <ski> Tordek : applying the constructor *forgets* the actual type `q' used with the arguments
19:39:56 <ski> Tordek : so, when you pattern-match, you (in general) don't know what type `q' was used, only that all the five uses of `q' in the types of the arguments in *this* `Queue a' value refer to the same type
19:40:44 <ski> Tordek : however, given another value of type `Queue a' (for the same `a'), it can possibly use a different hidden `q' type, and so you can't mix components between them
19:41:14 <ski> Tordek : this also means that if you have a list of type `[Queue a]', then possibly each element of the list uses a different `q' type
19:41:19 <ski> Tordek : does that make sense ?
19:41:56 <Tordek> lambdanoob: well, if you can't have an odd number of parameters, maybe you can make it explicit: "foo [x] = error"
19:43:14 <Tordek> ski: it's a bit over my head, but I think I kinda get it (maybe the queues example is less than ideal to think of "a list of different implementations of queues"
19:45:07 <ski> Tordek : yeah, the traditional example is a list of graphical widgets (a widget possibly being a checkbox button, a text field, a radio button, a selection list, a panel (possibly containing more widgets))
19:45:23 <lambdanoob> Tordek: doubleEveryOther  [x] = [x] worked.. thank you very much!
19:45:24 <ski> @where existential-antipattern
19:45:24 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
19:45:42 <ski> Tordek : ^ might also be interesting to check out, if you haven't seen it before
19:46:32 <Tordek> awesome, thanks
19:49:37 <Tordek> ski: I love how he starts with "This snippet is long", and it's 20 lines ;[
19:58:33 <fizbin> A demonstration of why mkStdGen on the current time is not really sufficient randomness:
19:58:36 <fizbin> > let randomB :: StdGen -> Bool; randomB = fst . random in map (randomB . mkStdGen) [1398308175..1398308195]
19:58:37 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
19:59:33 <jle`> yeah i have never been too happy with System.Random :/
19:59:45 * jle` cries at night
20:01:27 <fizbin> Even the standard advice of "discard the first few" seems not to work so well:
20:01:41 <fizbin> > let randomB :: StdGen -> Bool; randomB = fst . random; roll :: StdGen -> StdGen; roll s = iterate (snd . next) s !! 20; in map (randomB . roll . mkStdGen) [1398308175..1398308195]
20:01:43 <lambdabot>  [False,True,True,True,True,True,False,False,False,False,False,True,True,True...
20:02:11 <fizbin> That's still way too correlated, even after 20 generations.
20:07:38 <anon__> Hey, I am considering purchasing the "Introduction to Functional Programming using Haskell" by Richard Bird. One of the reviewer's in Amazon mentions that some of the programs in the book do not work (http://goo.gl/f3D1MG). Did any other experienced Haskellers find this to be true? Would you recommend this book to someone who already has Bird's book on functional pearls?
20:09:24 <c_wraith> anon__: haskell is an actively-developed language with little fear of breaking changes.  Sometimes older code needs small modifications to work in modern versions of GHC.
20:10:28 <c_wraith> I guess the language standard hasn't been updated since 2010, but GHC stopped waiting for the standard to update.
20:10:52 <c_wraith> (If it ever did wait...)
20:11:15 <schlegel> If it did I think we would have had a long 12 years
20:11:30 <anon__> How different is Haskell 98 from Haskell 2010? Is it like a completely different language?
20:11:53 <schlegel> anon__: http://www.haskell.org/haskellwiki/Haskell_2010#Changes_since_Haskell_.2798
20:12:24 <schlegel> Might be a little in depth and someone else could probably surely explain more succinctly
20:12:54 <c_wraith> anon__: also, GHC has breaking changes not included in the specs.  Particularly things like Eq and Show not being superclasses of Num
20:13:41 <Algebr> Thanks to everyone in this channel for being so helpful. I've finally written a practical program, sending sms messages via command line over Network.Curl.
20:14:16 <anon__> c_wraith and schlegel: Thank you very much. I think I will go ahead and get the book
20:16:33 <khumba> I'm using a TextView in a Gtk2Hs app.  When the view or model changes I update the other (if different).  I can't seem to avoid having 'bufferChanged' fire twice when updating the view, once to clear the old value (value at the time = "") and once to insert the new value.  I've tried both 'textBufferSetText' and "set [textBufferText := ...]".  Can I avoid having to ignore the first, extra signal manually?
20:17:03 <schlegel> anon__: Have you read any other Haskell books?
20:17:57 <anon__> I went through Learn Haskell Hard and Fast, partly through Haskell Road to Math, Logic and Programming and learn you a haskell for greater good
20:20:26 * hackagebot persistent-postgresql 1.3.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.3.1 (MichaelSnoyman)
20:20:28 * hackagebot conduit 1.1.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.1.1 (MichaelSnoyman)
20:20:30 * hackagebot conduit-extra 1.1.0.2 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.0.2 (MichaelSnoyman)
20:24:23 <schlegel> anon__: I can't specifically recommended or warn against the book, but I can say that comment you linked while it does work, isn't quite how floor is actually implemented in haskell
20:25:24 <schlegel> And I question if the author actually defined his implementation of floor to map a value of type Float to a value of type Integer, or if the commentor has a preconcieved notion of what the floor specification should be
20:26:53 <ski> @google Learn Haskell Hard and Fast
20:26:55 <lambdabot> http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
20:26:55 <lambdabot> Title: YBlog - Learn Haskell Fast and Hard
20:27:05 <schlegel> (though Haskell2010 does say it should be RealFrac a, Integral b => a -> b)
20:27:10 <anon__> ah ok, I just checked the type signature in GHCi, you seem to be correct. Is there a way to convert between different Num classes in haskell?
20:28:07 <ski> @type floor
20:28:08 <lambdabot> (RealFrac a, Integral b) => a -> b
20:28:13 <ski> @type ceiling
20:28:13 <lambdabot> (RealFrac a, Integral b) => a -> b
20:28:16 <ski> @type round
20:28:17 <lambdabot> (RealFrac a, Integral b) => a -> b
20:28:19 <ski> @type truncate
20:28:20 <lambdabot> (RealFrac a, Integral b) => a -> b
20:28:39 <ski> > (fromIntegral . floor) pi
20:28:40 <lambdabot>  3
20:28:51 <ski> > (fromIntegral . floor) (pi :: Double) :: Double
20:28:52 <lambdabot>  3.0
20:29:19 <schlegel> anon__: Here's everything you can do with Numbers as defined in Haskell2010 https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#dx13-135001
20:30:13 <anon__> schlegel: thank you very much.
20:33:29 <ski> @type fromIntegral
20:33:30 <lambdabot> (Num b, Integral a) => a -> b
20:33:31 <ski> @type realToFrac
20:33:32 <lambdabot> (Real a, Fractional b) => a -> b
20:33:44 <ski> > realToFrac (2 % 3 :: Rational) :: Double
20:33:45 <lambdabot>  0.6666666666666666
20:34:28 <ski> anon__ : those two functions (in addition to the four i mentioned above) can often be used to convert between numeric types
20:36:04 <anon__> ski: thanks for both the functions and showing me the @type ... interpreter
20:36:32 <schlegel> anon__: You can also use :t in GHCi
20:37:23 <schlegel> And as I found out 2 days ago, DuckDuckGo has a Hoogle bang: !h
20:38:08 * ski stares blankly
20:40:08 <schlegel> https://lmddgtfy.net/?q=%21h+trunctate
20:40:28 * hackagebot yesod-fay 0.5.1 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.5.1 (MichaelSnoyman)
21:05:50 <dmj`> does hackage have an api call for package versions? I want to write a program that parses my cabal file and tells me if I don't have the latest version of a package (if version is specified)
21:15:33 * hackagebot yesod-bin 1.2.9 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.9 (MichaelSnoyman)
21:15:35 * hackagebot yesod-core 1.2.15 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.15 (MichaelSnoyman)
21:15:37 * hackagebot schedevr 0.1.0.3 - Marge schedules and show EVR  http://hackage.haskell.org/package/schedevr-0.1.0.3 (YoshikuniJujo)
21:15:39 * hackagebot ffmpeg-light 0.5 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.5 (AnthonyCowley)
21:30:32 <SrPx> Is there a way to get a value out of a value in an expression (without pattern matching in a function)?
21:30:35 * hackagebot ffmpeg-light 0.6 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.6 (AnthonyCowley)
21:30:44 <SrPx> Ie, get "x" of (Foo x)
21:31:00 <silasm> lenses?
21:31:19 <Cale> Well, the lens will have to pattern match or something
21:31:27 <Cale> Basically, "no"
21:31:30 <Cale> at some level
21:31:38 <Cale> You can write a function which does that specifically
21:31:44 <edwardk> someone somewhere is wrestling with a pattern
21:32:11 <savanni> I think I'm wrestling with that pattern, myself.
21:33:07 <edwardk> well, one might argue that record field accessors for a data type with one constructor are different that pattern matching in the way the gc automatically forwards them to avoid wadler's space leaks, but that's being a bit pedantic
21:33:11 <ski> SrPx : how is the datatype of the constructor `Foo' declared ?
21:33:28 <SrPx> Wait, so... I have this: `redStep (App fun value) = red (subs value fun)` ... this returns "(Lam something)", but I only need something. What is the right way to fix this?
21:34:28 <savanni> SrPx: either don't return the Lam, or if you have to (lots of reasons why you would), pattern matching on the return value is probably your best option.
21:35:00 <SrPx> savanni: sure, but how do I pattern match against it? You mean creating a helper function like "extractBody (Lam body) = body" and using it?
21:35:09 <SrPx> isn't there an expression for that?
21:35:11 <Cale> SrPx: are you aware of case expressions?
21:35:11 <savanni> That's one option
21:35:16 <savanni> The other is a case expression
21:35:20 <SrPx> Cale: no, how?
21:35:28 <Cale> case redStep ... of Lam something -> ... something ...
21:37:21 <SrPx> ah okay thank you
21:38:11 <savanni> I've done something hideous and evil with an instance of Convertible, but I'm about to delete that instance.
21:40:36 * hackagebot ffmpeg-light 0.7 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.7 (AnthonyCowley)
21:45:36 * hackagebot schedevr 0.1.0.4 - Marge schedules and show EVR  http://hackage.haskell.org/package/schedevr-0.1.0.4 (YoshikuniJujo)
21:51:48 <felixn> https://gist.github.com/munro/11241890 <-- hey there, is it possible to make a recursive/self referencing type class?
21:52:06 <felixn> I could imagine that working, but it's not :/
21:53:11 <sellout> felixn: You need to specify that a also has an instance for LangCoercion
21:53:33 <sellout> instance LangCoercion a => LangCoercion (Maybe a) where
21:54:10 <sellout> IE “when a can be coerced, so can Maybe a”
21:54:48 <felixn> sellout: ahh you rock, it was trying to tell me that.. but I'm still new >_<
21:55:14 <felixn> I'm making a little dynamic language in haskell.  it's going very well!
21:57:26 <sgronblo> Youre bringing Satan into paradise
21:58:34 <felixn> ^_^ it's really amazing how well haskell is for developing a VM though!
22:01:31 <Cale> It's possible that when error messages suggest you make some change to your code, they should also show you how the code would look with that change
22:03:40 <c_wraith> Huh.  It occurs to me that it should be possible to write a Futamura projection library.  Probably a *ton* of work, though.
22:04:34 <ski> all projections ?
22:09:45 <c_wraith> ski: well, at least the first two.  The third might be possible.  Though possibly super-slow.
22:11:16 <startling> flebron: Haskell is excellent for parsing and for manipulating ASTs
22:11:29 <startling> er
22:11:31 <startling> felixn
22:11:37 <startling> it's really nice.
22:11:38 <bitemyapp> I find Haskell is nice for writing programs.
22:12:10 <startling> bitemyapp, I don't notice the difference so much doing many other things, though
22:12:10 <c_wraith> Yeah, I like haskell for writing programs.  It's not so useful for grating cheese.
22:12:26 <zomg> acme-cheesegrater
22:12:28 <startling> maybe "managing effects"
22:12:47 <bitemyapp> startling: I write software. I find it helps me do that.
22:13:05 <startling> ok. glad your experience is so straightforward !
22:15:40 * hackagebot wai-test 2.0.1.2 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-2.0.1.2 (MichaelSnoyman)
22:15:42 * hackagebot warp 2.1.5 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.5 (MichaelSnoyman)
22:15:44 * hackagebot warp-tls 2.0.5 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-2.0.5 (MichaelSnoyman)
22:17:23 <savanni> Question: if I call forkIO in my application, do I need to also have the -threaded RTS option?  It strikes me from some previous tests that I don't but that leaves me wondering what -threaded does.
22:18:28 <startling> savanni, I think -threaded allows green threads to be used
22:18:32 <startling> I may be mistaken.
22:18:33 <c_wraith> savanni: forkIO works without -threaded.  However, it won't run different threads in parallel without -threaded.  It will just switch between them
22:18:58 <c_wraith> startling: GHC uses green threads in both runtimes.  The threaded runtime just uses m:n multiplexing, instead of 1:n
22:19:15 <pharaun> how come -threaded isn't default
22:19:20 <startling> h
22:19:21 <startling> ah
22:19:25 <c_wraith> pharaun: it's slower for some tasks
22:19:33 <savanni> Ah, so -threaded would allow my multiple IO threads to get distributed to different cors?
22:19:42 <c_wraith> savanni: correct
22:20:14 <Sgeo> There's no function compile :: String -> IO () -> IO () that creates an executable located at the path described by the first argument that will, when run, execute the second argument, is there?
22:20:17 <savanni> *done*! :)
22:20:56 <c_wraith> savanni: you *also* will need to set the -N flag in the RTS to tell GHC to use multiple cores.
22:21:14 <pharaun> Sgeo: xmonad supports "dynreload" via recompiling itself and then exec'ing into that so you may want to look into how they did it
22:21:15 <c_wraith> savanni: that is, in the compiled program, use something like ./foo +RTS -N
22:21:22 <luite> savanni: you'll need -threaded in some cases, a blocking foreign call might block all forkIO threads in the nonthreaded rts
22:21:59 <luite> savanni: but forkIO by itself will work fine in both
22:22:10 <NemesisD> does bracketOnError re-raise exceptions like bracket does?
22:22:11 <c_wraith> savanni: though luite's comment is correct.  The threaded runtime avoids blocking native calls in more cases.
22:22:33 <startling> Sgeo: there's not a pre-existing one. I don't think writing one would be straightforward.
22:22:47 <Sgeo> Some CL implementations have something roughly equivalent
22:22:49 <startling> you could maybe do something like it with template haskell?
22:23:07 <c_wraith> savanni: sadly, a bad FFI binding can still block progress of an entire program in the threaded runtime, due to the garbage collector
22:23:16 <Sgeo> But I assume that all of those are reliant on the image nature the implementation
22:23:24 <startling> Sgeo, common lisp (if that's the CL you mean) has a number of properties that Haskell doesn't.
22:23:59 <startling> I think it's feasible with template haskell, though (which is Haskell's macro system)
22:24:44 <startling> (but that won't really have the type you asked for).
22:25:04 <savanni> c_wraith: I may have already seen symptoms of that, though I could be wrong and it seems unlikely in the Gtk2Hs FFI.
22:30:14 <haasn> Is it possible to auto-generate a Binary-style (de)serializer using something like a Data instance which can be auto-derived?
22:30:32 <startling> haasn: I think so. let me find it
22:30:42 <haasn> “To use this option, simply add a deriving Generic clause to your datatype and declare a Serialize instance for it without giving a definition for put and get. ”
22:30:44 <haasn> There we go :)
22:31:40 <startling> aha
22:31:56 <haasn> “Beginning with GHC 7.2, it is possible to use binary serialization without writing any instance boilerplate code.” (from binary, too)
22:36:06 <edwardk> haasn: yes, i've done it before
22:36:24 <edwardk> haasn: you can do it with 'Data' alone as well.
22:37:13 <edwardk> haasn: bytes also offers GHC.Generics support
22:37:17 <haasn> I wonder how much more efficient this would be than what a hand-rolled parser could achieve
22:37:28 <haasn> I mean, how much less
22:37:29 <edwardk> hand rolled parser wins
22:38:12 <edwardk> my experience is Data.Data versions of things are usually 30-100% slower, and GHC.Generics versions are usually 100-400% slower.
22:38:58 <haasn> What about TH code to auto-generate functions by simply inspecting the data type?
22:39:08 <edwardk> that can be done as well.
22:39:42 <c_wraith> I thought GHC.Generics was supposed to be faster than Data.Data for most uses.
22:39:46 <edwardk> geniplate takes that approach, if we want to consider these like uniplate's Data instances vs hand-rolled ones
22:40:05 <c_wraith> Or is it just easier to use?
22:40:14 <edwardk> c_wraith: its safer and more powerful, but I've never once seen it win a benchmark
22:40:30 <c_wraith> Huh.  I was completely mistaken.  Good to get that misconception corrected, then!
22:41:20 <edwardk> basically GHC.Generics always pays to completly flush out your entire structure and replace it with funky constructors of its own
22:41:26 <edwardk> so you're always paying to go through that layer
22:41:39 <edwardk> and that means lots of annoyingly indirect jumping
22:41:51 <c_wraith> ah, I see
22:42:08 <edwardk> Data.Data on the other hand can basically be done in place
22:42:14 <osa1> where can I find a working documentation page for bytestring? http://hackage.haskell.org/package/bytestring this doesn't show some modules
22:42:44 <edwardk> so it avoids thrashing the heap as badly, doesn't have to 'flush and refill' the structure with to/from, and so can make minor edits more efficiently, etc.
22:43:29 <pharaun> minor edits ?
22:43:54 <edwardk> pharaun: consider trying to use GHC generics to tweak part of a Map like structure
22:44:11 <pharaun> ah
22:44:30 <edwardk> with it, you ave to convert the entire Map to generic pairwise noise. K's and (:*:) 's and (:+:) 's, and M's, etc.
22:44:43 <edwardk> hen you edit one thing and reassemble
22:45:33 <edwardk> if it was more like a paramorphism so you could access entire unmodified parts of the structure, or a single level unwrapping/wrapping like a free monad approach then you _could_ do small edits
22:45:42 <edwardk> but it'd have a different AP
22:45:44 <edwardk> er API
22:46:06 <edwardk> and 'free monad' is a bad analogy anyways
22:46:07 <pharaun> alright that does make sense, i guess i was thinking of it as a pure one shot serialization and deserialization operation
22:46:15 <pharaun> to stow/load from disk (since that's what i usually do)
22:46:22 <edwardk> yeah
22:46:32 <edwardk> i use generics in unfortuntely complex ways
22:47:05 <edwardk> and the biggest bottleneck they have for me is that flush/fill to/from conversion
22:47:05 <pharaun> in that case makes more sense that you would want to be able to do small edits
22:47:35 <edwardk> well, even for 'big tasks' it is an expensive proposition.
22:47:57 <edwardk> GHC.Generics.Lens.tinplate is way slower than the Data.Data.Lens.tinplate
22:48:13 <edwardk> which is in turn way slower than the Data.Data.Lens.uniplate code
22:48:18 <pharaun> oof
22:48:38 <edwardk> though the former difference is the only one attributable to the flush/fill thing.
22:48:52 <edwardk> the difference is significant though. 3-4x
22:49:32 <akurilin> Quick question: is there a big community favorite among the various command-line parsers / helper libraries out there?
22:53:34 <edwardk> akurilin: they all have something wrong with them, for me? optparse-applicative does what i need it to do today, isn't too bad to use and makes legible code
22:54:25 <pharaun> i like optparse myself
22:54:27 <edwardk> akurilin: cmdargs requires more magic, getopt lets you get standards-like behavior. optparse-applicative is what i use for new work though.
22:55:23 <edwardk> (technically cmdargs doesnt require magic any more, but its non-magic API is rather ugly compared to optparse-applicative's)
22:56:26 <Enigmagic> i've been using optparse-applicative for a couple years now too
22:58:20 <ski> Sgeo : hm, SMLofNJ has `val SMLofNJ.exportFn : (string * ((string * string list) -> OS.Process.status)) -> unit' (and also `val SMLofNJ.exportML : string -> bool', while MLton has `val MLton.World.save: string -> MLton.World.status')
23:14:32 <napping> edwardk: what was that about GHC.Generics needing to convert an entire structure? It seems to me it just does one constructor at a time
23:20:47 * hackagebot x509-system 1.4.5 - Handle per-operating-system X.509 accessors and storage  http://hackage.haskell.org/package/x509-system-1.4.5 (VincentHanquez)
23:21:02 <akurilin> edwardk, pharaun, Enigmagic ok great, thanks for the overview, will check out optparse-applicative see what that's like
23:24:15 <c_wraith> napping: but the conversions still depend on the entire structure being converted.  Laziness only saves you latency, not total cost
23:25:14 <napping> c_wraith: I mean from/from1 leaves any recursive values of that type alone, wrapped under K1/Rec1
23:25:20 <napping> It doesn't walk a whole tree
23:26:02 <akurilin> I love when I look at applicative style code and have no idea what's happening. Haskell newbie problems.
23:26:12 <akurilin> Hope it gets better with the years :)
23:28:31 <c_wraith> akurilin: you just sort of ignore the <$> and <*> symbols, and treat it like function application
23:28:45 <c_wraith> akurilin: that just happens to be carrying a bit more along
23:30:37 <[swift]> does anyone have any experience with adding new extra-source-files in Setup.hs?
23:30:55 <[swift]> it's not clear to me which hook i'm supposed to do that from
23:31:07 <napping> c_wraith: show (from1 (Branch (Leaf 'X') (Branch (Leaf 'a') (Leaf 'b'))))
23:31:13 <napping> gives "R1 (Rec1 (Leaf 'X') :*: Rec1 (Branch (Leaf 'a') (Leaf 'b')))"
23:31:23 <c_wraith> Huh.
23:31:27 <napping> after defining appropriate Show instances
23:37:07 <akurilin> c_wraith: hm actually that way of thinking about it helped quite a bit last time I asked, let me write this down make sure I don't forget :)
23:42:20 <pharaun> i may just not be familiar enough with template haskell, but is there a neat way that i can definite a function in TH that when i import and use it in a different module it will generate *that* module's name at compile time?
23:42:37 <dmj`> what is faster for lookup / insertion and has smaller footprint, IntMap (containers) or HashMap (unordered-containers)?
23:42:47 <napping> pharaun: probably, where have you looked?
23:43:22 <pharaun> i was able to use - http://stackoverflow.com/a/5480638/326077 - which would generate it for the module its defined in but i'm not sure how i would make it be relocable, ie if i refer to it in module b it'll generate module b's name
23:43:25 <napping> pharaun: how about qLoc?
23:44:07 <S3thc0n> Hello #haskell people! I am fascinated by pure functional programming, but now I wonder: How does a program have to be structured to acommodate for usually useful shared mutable state. I'll give an example: I do some kind of lookup in a large key-value data structure, and while searching in one thread another one is working on adding new key-value pairs. Now I want the searching thread too
23:44:07 <S3thc0n> see the new value as they are added to improve the hit rate (a key is not necessarily existant). Of course this could be modeled as IO, but are there other ways? (Clojure's concurrency is a great example of solving this without being pure)
23:44:07 <napping> that should work fine
23:44:35 <pharaun> napping: qLocation ?
23:45:11 <napping> You'll have to call the template haskell code wherever you want it of course, the String value will be the module where it's defined
23:46:00 <Enigmagic> S3thc0n: exchanging values between threads isn't pure
23:46:35 <pharaun> napping: i guess i'm just not sure how i can "define" the template haskell in module a then call it in module B ?
23:46:50 <haasn> S3thc0n: threading sort of implies IO, doesn't it?
23:46:52 <pharaun> so that qLocation would get module b
23:47:39 <napping> like any TH thing - you define something like currentModule :: ExpQ in your library
23:47:47 <shachaf> S3thc0n: It depends, of course, on what the threads are doing. Maybe what you gave is a low-level description of something that is actually "pure" at a high level.
23:47:49 <napping> then run the splice like $currentModule where you want it
23:47:51 <pharaun> napping: OH
23:48:03 <pharaun> napping: this is my first time i've used TH :)
23:48:17 <pharaun> yeah that's basically what i wanted thanks i'll go figure out how to do that
23:48:46 <napping> Ok, I don't think there are any surprises
23:49:12 <napping> well, except that it doesn't work to try to use a thing in a splice in the same module that defines it
23:49:20 <pharaun> yeah aware of that one
23:51:01 <napping> S3thc0n: for structuring, that depends how complicated the "work" is
23:53:08 <pharaun> napping: ahh i got it, thanks
23:54:00 <napping> If you can easily compute in advance what lookups you'll need, you could probably encapulate all the concurrency in one function in IO that takes pure callbacks describing how to handle items
23:55:17 <napping> Otherwise, to make the purity of the computation manifest you'd probably need to give the work some type along the lines of (Monad m) => (Key -> m Result) -> (Key -> Item -> m Result)
