00:05:36 <haasn> S3thc0n: note: threading, in Haskell, refers to concurrency, the interleaving of side-effects; performing actions (in the real world) simultaneously
00:06:50 <napping> haasn: still, even if you're just trying to parallelize a pure computation but use a shared cache, you'll have some nondeterminism that probably can't be completely pure
00:07:17 <haasn> In Haskell, you can parallelize pure computations using a shared cache without invoking side effects, threads or concurrency
00:07:41 <napping> only if you know all the keys in advance, I think
00:08:03 <napping> what about something like a transposition table for a game tree search?
00:08:22 <haasn> Your shared cache could be a shared lazy data structure, parallelization could be parallel forcing using `par` (or other abstractions on top of this), and the shared cache would arise from GHC's own ability to rewrite thunks for sharing - which takes care of all issues like atomicity, etc.
00:09:08 <napping> hmm, maybe that works
00:10:18 <napping> and if it does you can use something like uglymemo
00:10:29 <haasn> memotrie etc. works too
00:10:49 <napping> It's precisely because those work that unsafePerformIO is legitimate
00:11:06 <haasn> Yeah, there are plenty of justifications for having unsafePerformIO for performance reasons
00:11:14 <haasn> (And code clarity reasons)
00:11:38 <napping> But before even worrying about performance you have your proof obligation that you are not ruining referentialy transparency
00:11:45 <haasn> Which might actually tell us a lot about Haskell's philosophy in the real world, but also certainly tells us a lot about how well Haskell can adapt to the real world
00:12:19 <napping> (as cprng-aes didn't bother to do)
00:12:36 <S3thc0n> Hmmm.
00:13:14 <napping> I suppose you'd use par to schedule the work then, which takes care of making evaluation happen (if needed) as a separate parallel task
00:13:59 <napping> The other example I had in mind was chasing imports while parsing source files, but that has to be in IO anyway
00:14:13 <napping> well, at least the file reading part
00:14:21 <haasn> There are more high level ways of achieving parallelism quickly and easily without using ‘par’ on carefully chosen values manually
00:15:02 <haasn> napping: Yes, unless you've already read in all files in which case a parList on the list of imports or whatever would be a low-overhead way of recursing in parallel
00:15:17 <S3thc0n> Sorry if I take quite a while to answer, I have to look some things up and reread. Not ignoring you.
00:15:21 <napping> Sure, but I was wondering if those ways actually operationally produce as much parallelism as you want
00:15:51 <napping> S3thc0n: Reading about the lazy caching way?
00:16:16 <[swift]> hmm
00:16:27 <[swift]> so apparently you can't upload a package to cabal that requires cabal 1.20?
00:16:32 <[swift]> sorry, to hackage
00:17:37 <[swift]> that's a bit aggravating since there's a breaking change between cabal 1.18 and cabal 1.20 that affects my Setup.hs script
00:18:06 <S3thc0n> napping: Yes, I think that is the way it seems I have to go. But would that not imply that laziness actually changes what is given as an argument?
00:18:14 <haasn> napping: S3thc0n: http://chimera.labs.oreilly.com/books/1230000000929/pt01.html <- is a useful resource to learn about all things parallelism
00:19:59 <napping> S3thc0n: that's not the only way to go. I'm just guessing the other way isn't so tricky to understand. If you're using a cache in a way where threads can see it's nondeterministic, then checking the cache isn't pure, so you'll have an impure toplevel (maybe try to isolate it from most of the computation), and there's nothing unique to concurrency about that
00:20:20 <napping> haasn: I meant reading a file, then reading its imports, then reading their imports and so on
00:20:39 <napping> Doing parallel IO before you even have the whole list of files
00:20:46 <pharaun> napping: thanks, got it, that was a bit confusing but i got the TH thing resolved :)
00:20:51 <pharaun> that was the kick i needed
00:21:23 <S3thc0n> napping: Exactly, that is what I meant. I just wanted to see if there's some kind of pure way to that I did not see (even if it sounds illogical, I didn't want to rely on that conclusion due to my limited knowledge).
00:21:51 <napping> S3thc0n: Yep, that's the trickier one. You can look up how pure memoization works
00:22:03 <arrnas> hey guys, i'm getting confused with monads, more specifically: what is a monad? a type class that's an instance of the monad class?
00:22:18 <napping> pharaun: great. I didn't realize you actually get pretty decent syntax - $foo almost looks like a shell variable access, doesn't it?
00:28:29 <haasn> napping: Yeah, that kind of thing should live in IO
00:30:55 * hackagebot voyeur 0.1.0.0 - Haskell bindings for libvoyeur  http://hackage.haskell.org/package/voyeur-0.1.0.0 (sethfowler)
00:36:35 <napping> S3thc0n: this might explain a little http://stackoverflow.com/questions/4980102/how-does-data-memocombinators-work
00:37:44 <pharaun> napping: yeah it does its just mainly confusing to start with and the module/naming and so on but once i got a few basic thing going it starts to coalesce my understanding of it
00:39:07 <startling> arrnas, a monad is a type that is an instance of Monad (the typeclass)
00:39:49 <startling> these types have kind * -> *, so you have things like "m Int" and "m String" for some Monad m. These are "monadic actions".
00:40:10 <startling> arrnas: does that help a bit?
00:40:53 <arrnas> startling: so if i have an assigment to write three monads of different types, what does that mean? write three typeclasses that are instances of the monad typeclass?
00:41:17 <startling> arrnas: I think that means that you have a teacher who plays loose with terminology. :(
00:41:42 <startling> arrnas: I would read it as "write three types and monad instances for them." but that's just a guess.
00:42:19 <startling> arrnas: I think you're confusing words, too -- I wouldn't say you can "write typeclasses that are instances of the monad typeclass"
00:46:14 <startling> arrnas: you might want to clarify your understanding, and then read http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
01:03:30 <arrnas> startling: yeah i'm pretty confused still, so i can make a type of vector thats (float,float,float), a typeclass is like an interface so if want my vector to be an instance of the monad typeclass i'd need to implement the return bind and fail functions. Does that make sense?
01:03:52 <startling> arrnas: yep, but your type isn't the right kind
01:04:18 <startling> arrnas, it needs to have a type parameter, i.e. be of kind * -> *
01:04:28 <arrnas> it should have one parameter right?
01:04:42 <startling> so maybe you want something like data V3 a = V3 a a a, but you might have trouble writing a Monad instance.
01:05:18 <startling> (namely because there isn't one. :) )
01:05:41 <bernalex> can you get :i (in GHCi) to print src in addition to typesig & infix rule?
01:05:57 <startling> oh, maybe I'm wrong.
01:06:31 <startling> yeah, there is a monad instance for V3, but it's kind of weird. you should probably start somewhere else.
01:07:17 <arrnas> so i should probably write three types that have Int, Maybe and IO inside them ?
01:07:50 <startling> arrnas: I'm not sure what you mean.
01:09:01 <startling> hm, it strikes me that a neater "join" for V3 would find the center of a triangle.
01:09:27 <startling> I wonder if that's doable. probably not.
01:10:59 * hackagebot tidal 0.3.8 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.3.8 (AlexMcLean)
01:11:06 <startling> arrnas, have you hand-written an instance for data Maybe a = Just a | Nothing?
01:13:01 <arrnas> i'm not sure either, i've asked my classmates and basically the assignment is to write instance Monad ... where, but types like maybe, io all have instances of monad so thats what's confusing me, do i need to write a new type and make it and instance of monad?
01:13:38 <Maior> you have an assignment and you're not sure what it is?
01:13:51 <Maior> I think step 1 might be to find the exact text
01:13:57 <shachaf> i,i an assignment your aunt gave you and you're not sure what it is
01:14:26 <startling> shachaf: is i,i an emoticon or a stutter?
01:14:45 <startling> arrnas: that's what I'd assume, but I can't speak for your teacher.
01:16:08 <startling> arrnas: is the "a new type" part what's confusing you?
01:16:25 <shachaf> startling: Neither.
01:16:39 <startling> a page number?
01:17:05 <startling> (the preface to the first section of the preface?)
01:17:16 <arrnas> the assignment is: write your three monads with different types, learn functional programming. When showcasing you'll need to assign your monads to some type ( i.e.: IO, List, etc..) explain the 3 parts of the monad, how they work together and if asked write code using the monads.
01:17:34 <arrnas> i'm translating it but is confusing even in the original language
01:19:17 <jle`> "learn functional programming"
01:19:27 <jle`> sounds like a tall order for a homework assignment :)
01:22:32 <zomg> maybe it's homework for the rest of his life
01:22:34 <zomg> :D
01:28:15 <bitemyapp> arrnas: and uh, you got tossed directly into monads?
01:28:25 <bitemyapp> what is this, the FP Hunger Games?
01:28:57 <GGMethos> haha
01:31:20 <arrnas> kinda, the module is programming language theory and lab work included ruby for the first assignment but that was easy, scalatron bot for the second one, monads for the third one, another assignment in haskell for the next one and something using prolog for the last one.
01:31:54 <arrnas> to be fair we were warned that this would take up all of our free time for this one
01:32:17 <bitemyapp> arrnas: don't get me wrong, monads aren't that big of a deal, it's just that you usually learn them after you already...uh...know Haskell.
01:32:35 <bitemyapp> arrnas: I want you to try something
01:33:09 <bitemyapp> arrnas: do you understand functors yet?
01:33:16 <arrnas> kinda
01:33:25 <bitemyapp> arrnas: kinda won't suffice, lets start with that.
01:33:25 <arrnas> map over something with a function
01:33:33 <bitemyapp> arrnas: okay but, lets break it down.
01:33:50 <bitemyapp> arrnas: functor is a typeclass. A typeclass can be thought of as an interface, implemented by a type, with laws.
01:34:03 <bitemyapp> > fmap (+1) [1..10]
01:34:04 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
01:34:11 <bitemyapp> arrnas: ^^ who's the Functor?
01:34:43 <arrnas> hmmm, [1..10] ?
01:34:53 <arrnas> or
01:34:56 <arrnas> list?
01:34:57 <bitemyapp> arrnas: well yeah, but I said a typeclass was implemented by a type.
01:34:58 <arrnas> i guess
01:35:01 <bitemyapp> arrnas: right, yes. List.
01:35:12 <bitemyapp> when you see a type that looks like: [a]
01:35:19 <bitemyapp> it's special list syntax for the List type constructor
01:35:25 <bitemyapp> which is just a way to say, "List of a"
01:35:30 <bitemyapp> okay, so list is the functor.
01:35:38 <bitemyapp> >fmap (+1) (Just 1)
01:35:44 <bitemyapp> > fmap (+1) (Just 1)
01:35:45 <lambdabot>  Just 2
01:35:53 <bitemyapp> arrnas: who's the functor? ^^
01:35:57 <arrnas> Just
01:36:07 <bitemyapp> arrnas: okay but that's not a type, that's a value constructor.
01:36:12 <arrnas> right
01:36:14 <arrnas> Maybe
01:36:16 <arrnas> is the functor
01:36:17 <bitemyapp> arrnas: who is Just a value constructor for? What's t---there we go.
01:36:24 <bitemyapp> very good!
01:36:33 <bitemyapp> > fmap (+1) Nothing
01:36:34 <lambdabot>  Nothing
01:36:44 <bitemyapp> okay, so we've got the basics of functors pinned down a bit.
01:36:45 <bitemyapp> :t fmap
01:36:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:36:53 <bitemyapp> lets note a limitation.
01:37:18 <bitemyapp> arrnas: in the function signature for fmap, the function provided goes from (a -> b) right?
01:37:26 <arrnas> yup
01:37:38 <bitemyapp> arrnas: so, what if I wanted to process a list and return more lists?
01:37:52 <bitemyapp> arrnas: or process a Maybe and return more Maybe wrapped values?
01:38:00 <bitemyapp> can I do that?
01:38:08 <arrnas> nope
01:38:15 <bitemyapp> well, lets see.
01:38:37 <bitemyapp> > fmap (\x -> [1000, x]) [1..10]
01:38:39 <lambdabot>  [[1000,1],[1000,2],[1000,3],[1000,4],[1000,5],[1000,6],[1000,7],[1000,8],[10...
01:38:51 <merijn> I have a clarification question about "Implementing lazy functional languages on stock hardware: the Spineless Tagless G-Machine", specifically it seems to me that the lambdaforms at the bottom of page 26 contain a typo, but I'm not sure?
01:38:58 <bitemyapp> arrnas: lambdabot says you're wrong. :)
01:39:04 <bitemyapp> arrnas: but that's okay! this is how we learn.
01:39:11 <bitemyapp> arrnas: do you know why this is allowed with fmap?
01:39:11 <jle`> > fmap (\x -> Just x) (Just 7)
01:39:12 <lambdabot>  Just (Just 7)
01:39:15 <bitemyapp> :t fmap
01:39:16 <jle`> oh dear
01:39:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:39:38 <bitemyapp> arrnas: can you point what part of the type signature allows me to return a list in the function I passed to fmap?
01:39:42 <bitemyapp> point out*
01:40:37 <arrnas> welp, b is what gets returned so f b means that whatever a -> b returns gets assigned to the functor right?
01:41:13 <bitemyapp> arrnas: well, actually, it means the "b" that (a -> b) returns gets rewrapped in the type f
01:41:21 <shachaf> merijn: What/where?
01:41:30 <Chousuke> hmh
01:41:33 <bitemyapp> arrnas: what strictly speaking *allows* this, is that we're allowed to have a different type b than type a, because they're different letters.
01:42:01 <bitemyapp> arrnas: but, my intent wasn't just to return lists when I mapped over, I wanted a single continuous list as a final result, I just wanted to inject more than one result at a time.
01:42:09 <bitemyapp> arrnas: but I can't do this with Functor.
01:42:15 <bitemyapp> > fmap (\x -> [1000, x]) [1..10]
01:42:17 <lambdabot>  [[1000,1],[1000,2],[1000,3],[1000,4],[1000,5],[1000,6],[1000,7],[1000,8],[10...
01:42:44 <bitemyapp> I can get nested List or Maybe back with functor, but the type is (f (f b)) not (f b) as I'd prefer.
01:42:50 <Chousuke> to see what happens, you can substitute b with [a]
01:42:54 <merijn> shachaf: The bottom of page 26 mentions the following closure "aList = {} \n Cons {thing,nil}", but as far as I can tell the proper syntax for that closure as described earlier would be "{} \n {} -> Cons {thing,nil}" (i.e. a closure with no free variables and no function arguments)
01:43:03 <bitemyapp> arrnas: do you know how to squish a list?
01:43:10 <bitemyapp> arrnas: namely, to turn [[a]] into [a]?
01:43:24 <Chousuke> so you get (a -> [a]) -> f a -> f [a])
01:43:27 <merijn> shachaf: I was unsure whether "{} \n Cons {thing,nil}" is a new notation/syntax of just a type where they accidentally forgot the "{} ->" since the argument list is empty
01:43:42 <arrnas> well an applicative functor should do that since its called flatmap in scala right?
01:43:45 <Chousuke> but since f is [] you get (a -> [a]) -> [a] -> [[a]]
01:43:57 <bitemyapp> :t fmap (\x -> [1000, x])
01:43:58 <lambdabot> (Num t, Functor f) => f t -> f [t]
01:44:17 <merijn> s/of just a type/or just a typo/
01:44:19 <merijn> Man, I can't type
01:44:22 <bitemyapp> arrnas: hum. lets take a look.
01:44:27 <bitemyapp> :t (<*>)
01:44:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:44:40 <bitemyapp> arrnas: not *quite*, but still close.
01:44:58 <bitemyapp> arrnas: f (a -> b) means I could have a *list* of functions, but I want a function to *return* a list of its own volition.
01:45:02 <shachaf> merijn: Hm, looks like a mistake to me.
01:45:16 <merijn> shachaf: ok, that's the answer I was hoping for :)
01:45:17 <Chousuke> arrnas: what is the type of the function that you need to go from a list of lists to a list? :P
01:45:21 <bitemyapp> arrnas: lets focus on what I asked though.
01:45:28 <bitemyapp> arrnas: how do you go from [[a]] to [a]?
01:46:12 <arrnas> ugh, you'd use Flatten?
01:46:20 <bitemyapp> well
01:46:20 <Chousuke> arrnas: then generalise that to the type of a function that works for any functor
01:46:22 <bitemyapp> :t concat
01:46:23 <lambdabot> [[a]] -> [a]
01:46:38 <bitemyapp> > concat $ fmap (\x -> [1000, x]) [1..10]
01:46:39 <lambdabot>  [1000,1,1000,2,1000,3,1000,4,1000,5,1000,6,1000,7,1000,8,1000,9,1000,10]
01:46:47 <bitemyapp> Chousuke: please let me do my thing.
01:47:07 <bitemyapp> arrnas: problem is, concat isn't generic. It's specific to lists, right?
01:47:18 <bitemyapp> arrnas: so we need something like... f (f a) -> f a
01:47:20 <arrnas> right
01:47:27 <bitemyapp> or maybe   m (m a) -> m a
01:47:33 <bitemyapp> so happens, that exists.
01:47:37 <bitemyapp> :t join
01:47:37 <lambdabot> Monad m => m (m a) -> m a
01:47:46 <bitemyapp> > join $ fmap (\x -> [1000, x]) [1..10]
01:47:47 <lambdabot>  [1000,1,1000,2,1000,3,1000,4,1000,5,1000,6,1000,7,1000,8,1000,9,1000,10]
01:48:24 <shachaf> merijn: I should probably finish reading this paper sometime.
01:48:28 <bitemyapp> arrnas: so we've got two bits of kit here. both generically applicable. fmap and join. join is explicitly part of the Monad typeclass.
01:48:46 <bitemyapp> arrnas: but, when you've seen monads in Haskell, you usually see >>=  (aka bind) right?
01:48:50 <bitemyapp> lets take a look.
01:48:54 <bitemyapp> :t (>>=)
01:48:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:49:14 <bitemyapp> notice that the function passed to >>= is *not* (a -> b) like functors, applicative or otherwise.
01:49:22 <bitemyapp> it's a -> m b
01:49:45 <bitemyapp> but, also unlikely our attempt at returning lists within lists with Functor, it doesn't return a nested m b, just m b.
01:49:49 <bitemyapp> unlike*
01:50:25 <merijn> shachaf: I already had two "I know kung-fu"-moments so far
01:50:26 <bitemyapp> arrnas: turns out, you can go from join and fmap to >>=
01:50:30 <bitemyapp> :t (join .) . fmap
01:50:31 <lambdabot> (Functor m, Monad m) => (a1 -> m a) -> m a1 -> m a
01:50:36 <bitemyapp> :t flip $ (join .) . fmap
01:50:37 <lambdabot> (Functor m, Monad m) => m a1 -> (a1 -> m a) -> m a
01:50:41 <bitemyapp> :t (>>=)
01:50:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:50:49 <merijn> shachaf: Although I got a bit confused at the end in chapter 9, so I'm going over the start again
01:50:50 <bitemyapp> arrnas: see the symmetry now?
01:51:12 <shachaf> merijn: I think reading enough GHC-generated code is an acceptable substitute for many situations.
01:51:14 <arrnas> yup
01:51:18 <bitemyapp> arrnas: so! For the List monad specifically, >>= is just (concat .) . map
01:51:47 <shachaf> merijn: By the way, some of the things that paper says are pretty outdated.
01:51:48 <bitemyapp> arrnas: we're mapping functions through the type, which is allowed to return nested results and then recollapsing them back down.
01:51:57 <bitemyapp> another function to know. return.
01:51:57 <shachaf> There are all sorts of follow-up papers that are also worth reading (and shorter).
01:52:00 <bitemyapp> :t return
01:52:01 <lambdabot> Monad m => a -> m a
01:52:11 <shachaf> @where cpr -- for instance
01:52:11 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
01:52:15 <bitemyapp> arrnas: return is how we generally "nest" or inject a type into the monad.
01:53:01 <yeeeeeeee> somebody who know haskell and c++?
01:53:18 <bitemyapp> > return 1 :: [Int]
01:53:19 <lambdabot>  [1]
01:53:19 <merijn> shachaf: In terms of how GHC generates code you mean?
01:53:24 <bitemyapp> > return 1 :: Maybe Int
01:53:25 <lambdabot>  can't find file: L.hs
01:53:30 <bitemyapp> wat.
01:53:30 <shachaf> Right.
01:53:33 <bitemyapp> > return 1 :: Maybe Int
01:53:34 <lambdabot>  Just 1
01:53:40 <bitemyapp> arrnas: see?
01:53:50 <merijn> shachaf: I'm more curious from a "how do I implement my own lazy functional language" perspective :)
01:53:51 <mniip> Race condition it looks like
01:53:53 <arrnas> yeah, but wait a sec.
01:53:59 <merijn> shachaf: Better understanding of GHC is a bonus
01:54:07 <arrnas> so a functor is used to iterate over something with a function
01:54:22 <bitemyapp> arrnas: I wouldn't use the term iterate.
01:54:23 <arrnas> an applicative functor is used to iterate over something with a function that has context
01:54:32 <arrnas> like Just (+1)
01:54:33 <bitemyapp> arrnas: it applies a provided function to the "values" inside the type.
01:54:40 <bitemyapp> arrnas: stop saying iterate.
01:54:41 <Chousuke> arrnas: it's best to really think of these things in terms of the operations
01:54:43 <bitemyapp> there's no iteration here.
01:54:54 <shachaf> merijn: Yes, relevant there too.
01:54:57 <bitemyapp> arrnas: I would avoid analogies in general and just think about the types and operations involved in the abstract.
01:55:09 <bug2000> yeeeeeeee, Only C++ here. I'm still trying to grasp this haskell.
01:55:15 <bitemyapp> I have an f a, I have an (a -> b) and I want to get to f b.
01:55:17 <bitemyapp> :t fmap
01:55:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:55:19 <Chousuke> arrnas: Lists are Functors because they provide fmap
01:55:22 <bitemyapp> is path to get what I want.
01:55:41 <Chousuke> arrnas: and what fmap does really depends entirely on the functor
01:55:55 <mniip> yeeeeeeee, I know both... but not the things that lie between them
01:55:56 <bitemyapp> arrnas: ditto Applicative, ditto Monad. It depends on the typeclass instance.
01:56:04 <Chousuke> it might iterate over whatever structure there is, but what about IO?
01:56:05 <Cale> A functor is a type constructor f together with a function fmap of type (a -> b) -> f a -> f b which given a function a -> b and a structure of type f a, produces a structure of type f b (presumably by applying the function to all the elements of type a throughout the structure)
01:56:14 <Chousuke> IO is a functor, but there's no iteration
01:56:19 <jle`> i like to say that there are no "semantics" or meaning attached to fmap, bind, etc.
01:56:29 <jle`> and that what semantics or meaning there are comes from the actual instance itself
01:56:33 <merijn> shachaf: I realise there's tons more (considering this was published in 1992), but I figure I might as well start somewhere and this seemed as good an entry as anything :)
01:56:34 <bitemyapp> jle`: eh. laws.
01:56:47 <shachaf> Sure.
01:56:48 <merijn> shachaf: But I'll remember the one you linked
01:56:48 <jle`> semantics, i mean, that are different from the laws
01:56:57 <jle`> if you say that fmap for lists 'iterate' over the item
01:56:59 <Chousuke> jle`: fmap, bind, etc. are themselves the "meaning" I think.
01:57:05 <arrnas> well the only part i don't understand is how the values for example in a list get fed to the function?
01:57:08 <jle`> well that's because that's the case for list
01:57:08 <shachaf> I like the CPR paper because it says "this thing that we said was an optimization back in 1992 is no longer an optimization on modern CPUs".
01:57:14 <jle`> not for fmap
01:57:44 <bitemyapp> arrnas: why not implement it yourself and find out?
01:57:50 <Chousuke> if you know something is a monad that tells you that it has join and return and that it's an applicative functor as well. (except not in Haskell-land. yet)
01:57:50 <jle`> arrnas: implementation detail :P
01:58:09 <bitemyapp> jle`: no fuck that. They should just write the typeclass instances themselves and see.
01:58:14 <Chousuke> so you can  meaningfully use bind and whatever even if you don't know what they actually do
01:58:22 <Chousuke> because you know their laws
01:58:27 <jle`> Chousuke: yeah, true; but it doesn't tell you anything about the semantics of what join and return are supposed to do for that specific instance
01:58:39 <jle`> those things come from the actual thing itself
01:58:45 <jle`> IO, Maybe, []
01:58:55 <Chousuke> hmm, right.
01:59:11 <Chousuke> the point is though, quite often that doesn't even matter :)
01:59:15 <merijn> shachaf: Curse those damn CPU designers ;)
01:59:28 <bitemyapp> arrnas: still with us?
01:59:37 <yeeeeeeee> somebody can give me a hand with c++? and haskell?
01:59:40 <jle`> well, it matters when you are using it.  but it's important to see that it has nothing to do with funtorness or monadness or w.e
01:59:42 <arrnas> bitemyapp: yeah
02:00:02 <bitemyapp> arrnas: so. I just provided a reason we might want a monad implementation. Lets see what it looks like.
02:00:04 <jle`> you can attach semantics to what fmap does for lists...but it only appllies to lists, and not to functors in general
02:00:12 <bug2000> yeeeeeeee, Ask mniip?
02:00:14 <Chousuke> yeah
02:00:21 <bitemyapp> > [1, 2, 3] >>= (\x -> [100, x])
02:00:23 <lambdabot>  [100,1,100,2,100,3]
02:00:39 <bitemyapp> > join $ fmap (\x -> [100, x]) [1, 2, 3]
02:00:40 <lambdabot>  [100,1,100,2,100,3]
02:00:44 <Chousuke> lists actually have two possible monads related to them, don't they? list and ziplist
02:00:50 <mniip> bug2000, they should have clarified that they want to rewrite haskell code in c++
02:00:51 <bitemyapp> Chousuke: ZipList is Applicative
02:00:55 <jle`> i'm not sure zip lists can be monad'd
02:00:58 <bug2000> mniip, Tell me about it >.>
02:01:09 <bug2000> mniip, I said I don't know haskell and he expected me to understand it.
02:01:23 <bitemyapp> > Just 1 >>= (\x -> Just (x + 3))
02:01:24 <jle`> that is you can't make a monad instance for lists where ap = the <*> for zip lists
02:01:25 <lambdabot>  Just 4
02:01:31 <jle`> @src ap
02:01:31 <lambdabot> ap = liftM2 id
02:01:34 <mniip> Well i hinted him at the solution
02:01:45 <bitemyapp> arrnas: now, did you look at the paste I shared?
02:01:48 <jle`> @src liftM2
02:01:48 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:01:49 <bug2000> mniip, And that wasn't enough!?@#!
02:02:11 <mniip> (yeeeeeeee) can you write the code for me please =)
02:02:13 <Chousuke> hm, somehow I thought ziplist had a monad instance too
02:02:15 <Chousuke> oh well
02:02:16 <bug2000> mniip, May I ask what is that code supposed to be doing?
02:02:28 <bitemyapp> arrnas: consider starting with Applicative here, then moving on to Monad: http://www.seas.upenn.edu/~cis194/lectures.html
02:02:59 <arrnas> sorry
02:03:06 <bitemyapp> arrnas: what for?
02:03:21 <mniip> bug2000, something mapping over permutations of a thing
02:03:40 <arrnas> had to answer the door
02:03:49 <Chousuke> arrnas: so tl;dr functors, applicatives and monads are useful, small and very generic abstractions that have so many uses that not all of them have yet been discovered. probably.
02:04:41 <arrnas> but that seems like a specific use case
02:04:44 <Chousuke> chances are you'll be writing haskell code someday and go "oh, this is an applicative" and then implement the type class and delete fifty lines of code.
02:05:24 <arrnas> a functor seems very useful since it's like a block that you send to a function to filter values from a list
02:05:27 <bitemyapp> arrnas: seriously consider going through the final 3 lessons of that course I linked.
02:05:38 <bitemyapp> arrnas: it will hammer Applicative and Monad home for you, and they're very quick.
02:05:41 <bitemyapp> do the exercises!
02:05:58 <bitemyapp> arrnas: also maybe take a look at: http://book.realworldhaskell.org/read/monads.html
02:06:06 * hackagebot mangopay 1.4 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.4 (JeanPhilippeMoresmau)
02:06:08 * hackagebot yesod-mangopay 1.4 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.4 (JeanPhilippeMoresmau)
02:06:35 <jle`> i like to think of functors as things you can lift functions too
02:06:50 <jle`> f is a functor if i can turn a (a -> b) into an (f a -> f b)
02:06:57 <jle`> *to
02:07:08 <jle`> i can turn any (a -> b) into a (Maybe a -> Maybe b)
02:07:09 <bitemyapp> jle`: yep!
02:07:11 <jle`> it's magic!
02:07:15 <bitemyapp> it's great :)
02:07:24 <arrnas> bitemyapp: http://www.haskell.org/tutorial/monads.html is this the first link?
02:07:33 <jle`> I have (+ 3)...which can be Int -> Int ... but now i can also turn it into a Maybe Int -> Maybe Int
02:07:40 <bitemyapp> arrnas: the course I want you to do is the other link
02:07:54 <bug2000> mniip, At least he said please.
02:07:58 <bitemyapp> arrnas: I was just linking RWH for an example.
02:11:30 <arrnas> bitemyapp: well thanks for all the explaining you did, i appreciate it alot.
02:12:10 <bitemyapp> arrnas: no problem, good luck with the homework.
02:36:51 <Melvar> How do I deal with an “Ambiguous module name” error?
02:38:06 <pavonia> In you own library or importing from packages?
02:39:37 <Melvar> Importing Control.Monad.State, which is found in both mtl and monads-tf.
02:40:01 <bergmark> -hide-package monads-tf
02:40:29 <Melvar> bergmark: Thanks.
02:40:40 <pavonia> There's also -XPackageImports which lets you specify the package name on import
02:40:47 <shachaf> You probably shouldn't have monads-tf in the first place.
02:40:48 <bergmark> for monads-tf in particular you can put this in your .cabal/confi
02:40:52 <bergmark> constraint: MonadCatchIO-transformers == 0.3.0.*
02:40:52 <bergmark> constraint: MonadCatchIO-mtl == 0.3.0.5
02:41:07 <bergmark> that's probably what's pulling it in
02:43:17 <bergmark> you can also `ghc-pkg hide monads-tf', don't think that will cause any issues
02:47:11 <Melvar> I’ve hidden it for now.
02:56:12 <jakex> is there an elegant way of doing this?  [1,2,3,4] -> [(1,2),(3,4)]   [1,2,3] -> [(1,2)]
02:59:33 <Maior> (just to play)
02:59:43 <Maior> @djinn [a] -> [(a,a)]
02:59:43 <lambdabot> Error: Undefined type []
02:59:50 <Maior> oh well
02:59:55 <jakex> what is that?
02:59:55 <opensourcegeek> hi guys - could anyone help on installing scion-browser please using cabal
03:00:09 <opensourcegeek> i get an error saying cannot resolve dependencies
03:00:15 <Maior> jakex: aiui it does magical type->definition where it can
03:00:15 <jakex> it attempts to generate code based on the type?
03:00:16 <asQuirreL> jakex: it tries to determine the function from the type signature
03:00:29 <jakex> does it sometimes work? :)
03:00:33 <Maior> jakex: yes
03:00:43 <jakex> cool
03:00:43 <Maior> @djin (a, b) -> a
03:00:44 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
03:00:46 <asQuirreL> jakex: it works more than you'd initially think
03:00:49 <Maior> @djinn (a, b) -> a
03:00:49 <lambdabot> f (a, _) = a
03:00:52 <Maior> etc. etc.
03:04:26 <eizo> jakex: http://lpaste.net/103148 i'm new to haskell so there is probably much shorter
03:05:22 <ocharles> eizo: zip xs (tail (repeat xs))
03:05:24 <ocharles> I think
03:05:36 <ocharles> let xs = [1..10] in zip xs (tail (repeat xs))
03:05:38 <ocharles> > let xs = [1..10] in zip xs (tail (repeat xs))
03:05:40 <lambdabot>  [(1,[1,2,3,4,5,6,7,8,9,10]),(2,[1,2,3,4,5,6,7,8,9,10]),(3,[1,2,3,4,5,6,7,8,9...
03:05:45 <ocharles> haha, no
03:05:45 <fizruk> ocharles: not exactly
03:05:46 <ocharles> :)
03:06:14 * hackagebot blaze-markup 0.6.1.0 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.6.1.0 (JasperVanDerJeugt)
03:06:15 <Maior> hm I wonder how to tell Djinn about []
03:06:29 <Maior> @help djinn-add
03:06:29 <lambdabot> djinn-add <expr>.
03:06:29 <lambdabot> Define a new function type or type synonym
03:06:31 <ocharles> oh wait, I misread what that function is doing
03:06:33 <jakex> eizo appreciated.
03:06:36 <shachaf> Don't, because it's pointless.
03:06:47 <shachaf> [] is not a useful type for djinn.
03:06:51 <Maior> shachaf: why not?
03:07:04 <Maior> I can't help but note it's aware of it and used in the examples at http://lambda-the-ultimate.org/node/1178
03:07:16 <shachaf> It's equivalent to Maybe.
03:07:29 <Maior> it's common syntax people seem likely to use
03:07:32 <shachaf> You can always return the empty list.
03:07:42 <Maior> ah
03:08:02 <shachaf> If you really want it you can add it.
03:08:33 <Maior> the example above manages to do something more useful than returning the empty list
03:08:35 <shachaf> But don't expect djinn to start generating recursive functions for you.
03:08:47 <shachaf> Yes. It can do all sorts of things.
03:09:00 <shachaf> But nothing useful that is list-specific.
03:09:14 <shachaf> It'll try to use all arguments.
03:09:21 <shachaf> @djinn a -> Maybe a -> Maybe a
03:09:22 <lambdabot> f a b =
03:09:22 <lambdabot>     case b of
03:09:22 <lambdabot>     Nothing -> Just a
03:09:22 <lambdabot>     Just c -> Just c
03:09:37 <shachaf> Even better!
03:10:12 <Maior> @hoogle a -> Maybe a -> Maybe a
03:10:13 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
03:10:13 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
03:10:13 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
03:10:21 <Maior> ah
03:10:22 <matheus23> @type (***)
03:10:23 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
03:11:36 <eizo> @hoogle (a -> [b]) -> [a] -> [b]
03:11:36 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
03:11:36 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
03:11:36 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
03:17:52 <asQuirreL> jakex: I believe you can do it with unfoldr, wait one on an actual solution
03:18:33 <jakex> I wanted to do it with zip and dropEveryN function, but there is no such function in standard lib as far as I can see
03:23:37 <asQuirreL> jakex: http://lpaste.net/103150
03:24:14 <asQuirreL> this is of course, not much of an improvement on the straight recursive definition
03:26:39 <jakex> yeah. I actually find it a bit harder to understand. probably because I never use unfoldr
03:27:57 <fizruk> > map snd . filter (odd . fst) . zip [1..] $ zip <*> tail $ [1..5]
03:27:58 <lambdabot>  [(1,2),(3,4)]
03:32:39 <asQuirreL> fizruk: that's a nice idea
03:32:56 <merijn> Rather unreadable, though
03:33:20 <merijn> I don't really see a reason why not to have a straight forward recursive definition?
03:33:37 <fizruk> > map (\[x, y] -> (x, y)) $ chunk 2 [1..5]
03:33:38 <lambdabot>  [(1,2),(3,4),*Exception: <interactive>:3:6-22: Non-exhaustive patterns in la...
03:33:52 <fizruk> I would go for simple recursion :)
03:35:24 <asQuirreL> > map (\[x, y] -> (x, y)) $ chunk 2 [1..4]
03:35:25 <lambdabot>  [(1,2),(3,4)]
03:35:29 <asQuirreL> mmm...
03:35:31 <asQuirreL> damn :
03:35:33 <asQuirreL> *:P
03:36:17 <jedai> > let toPairs (x:y:xs) = (x,y) : toPairs xs; toPairs _ = [] in toPairs [1..5]
03:36:18 <lambdabot>  [(1,2),(3,4)]
03:36:18 * hackagebot timeout 0.0.0 - Generalized sleep and timeout functions  http://hackage.haskell.org/package/timeout-0.0.0 (FedorGogolev)
03:36:53 <jedai> The recursive definition really seems like the way to go
03:37:02 <asQuirreL> it's the most comprehensible
03:37:18 <asQuirreL> I just chose unfoldr because that is what is being represented here
03:38:05 <merijn> Clarity > one liners
03:38:19 <asQuirreL> unfortunately the cruft of explicitly having to use Just and Nothing make it a little less elegant, I'm sure there's a way to do it without that though
03:38:24 <merijn> And if the clear one becomes too large, factor stuff out into where clauses
03:38:59 <jedai> sure and when you're used to unfoldr, your definition is pretty clear too. But I think here the direct recursion is the cleanest and clearest one
03:41:34 <fizruk> merijn: I guess noone’s arguing :p just messing with possible definitions
03:44:34 <jedai> > foldr (\~(xs,ys) x -> (ys, x:xs)) ([],[]) [1..5]
03:44:35 <lambdabot>  <hint>:1:20: parse error on input ‘->’
03:47:00 <jedai> let pairsUp = uncurry zip . foldr (\x ~(xs,ys) -> (ys, x:xs)) ([],[]) in pairsUp [1..5]
03:47:05 <fizruk> jedai: lambdabot thinks \~ is an operator
03:47:06 <jedai> > let pairsUp = uncurry zip . foldr (\x ~(xs,ys) -> (ys, x:xs)) ([],[]) in pairsUp [1..5]
03:47:07 <lambdabot>  [(2,1),(4,3)]
03:47:22 <jedai> Right... :)
03:47:49 <jedai> Just, not the right order around if the list is of impair length
03:48:10 <jedai> > let pairsUp = uncurry zip . foldr (\x ~(xs,ys) -> (ys, x:xs)) ([],[]) in pairsUp [1..8]
03:48:11 <lambdabot>  [(2,1),(4,3),(6,5),(8,7)]
03:48:49 <asQuirreL> > let pairsUp = uncurry zip . foldr (\x ~(xs,ys) -> (ys, x:xs)) ([],[]) in pairsUp [1..6]
03:48:51 <lambdabot>  [(2,1),(4,3),(6,5)]
03:49:09 <jedai> > let pairsUp = uncurry zip . swap . foldr (\x ~(xs,ys) -> (ys, x:xs)) ([],[]) in pairsUp [1..5]
03:49:10 <lambdabot>  [(1,2),(3,4)]
03:49:25 <jedai> > let pairsUp = uncurry zip . swap . foldr (\x ~(xs,ys) -> (ys, x:xs)) ([],[]) in pairsUp [1..4]
03:49:26 <lambdabot>  [(1,2),(3,4)]
03:49:34 <jedai> Hmmm... ???
03:49:56 <asQuirreL> jedai: it's probably always in the wrong order because even number of elements means an even number of swaps
03:50:04 <asQuirreL> eh.. i dunno...
03:50:21 <jedai> But odd shouldn't ? Should it
03:50:30 <BoR0> what's ~(ys, x:xs) ?
03:50:56 <fizruk> lazy pattern matching
03:50:56 <jedai> BoR0: it's like the pattern (xs, ys) but lazy
03:51:10 <BoR0> I see
03:51:56 <jedai> BoR0: that's needed here so that the foldr doesn't need to consume the whole list before producing the first elements of the result
03:52:43 <jedai> > take 10 . fst . foldr (\x ~(xs,ys) -> (ys, x:xs)) ([],[]) $ [1..]
03:52:45 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
03:52:52 <jedai> > take 10 . fst . foldr (\x (xs,ys) -> (ys, x:xs)) ([],[]) $ [1..]
03:52:57 <lambdabot>  mueval-core: Time limit exceeded
03:52:57 <lambdabot>  mueval: ExitFailure 1
03:53:19 <BoR0> got it
03:54:32 <fizruk> guys, perhaps you can give me some real world examples of Alternative? I mean hand-made ones, such as parsers (but not parsers)
03:54:34 <jedai> Ok, clearly I was thinking about this function all wrong because if the length of the list changed the order of the result... how could it work in the infinite case
03:55:51 <asQuirreL> jedai:  foldr (\x ~(xs,ys) -> (x:ys, xs)) ([],[]) <-- this works without needing the swap
03:55:55 <jedai> So we have a real implementation for jakex function, working a bit like he wanted "with zip and dropEveryN function"
03:56:25 <jedai> asQuirreL: Right, I was confused :)
03:56:57 <jedai> > let pairsUp = uncurry zip . foldr (\y ~(xs,ys) -> (y:ys, xs)) ([],[]) in pairsUp [1..7]
03:56:59 <lambdabot>  [(1,2),(3,4),(5,6)]
03:59:14 <asQuirreL> I would probably name the fold there as "uninterleave"
03:59:34 <asQuirreL> I would probably name the fold there as "uninterleave 2"
03:59:48 <asQuirreL> oops, I meant to just say *or maybe "uninterleave 2"
04:00:33 <jedai> asQuirreL: Right, that's the idea. You can use it in a merge sort (though it's more efficient to just explode the whole list in a list of singletons
04:04:09 <int-e> carter: btw I rebuilt lambdabot / mueval to use shared libraries, which should help @run to time out less frequently.
04:04:45 <alpounet> int-e: oh, are you the one running \b these days?
04:04:55 <int-e> alpounet: yes
04:05:07 <alpounet> ok, good to know
04:05:29 <int-e> And since it was brought up, I'm happy to revert the @faq social experiment if there's demand for it.
04:05:35 <int-e> @faq
04:05:35 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:07:17 <alpounet> int-e: that used to trigger the "Yes! Haskell can do that!" sentence right?
04:07:24 <int-e> yes.
04:07:46 <alpounet> and some people want it back?
04:07:58 <int-e> indeed
04:08:32 <alpounet> i don't really care, but that's definitely not lambdabot's most interesting feature
04:10:45 <Yaniel> @faq can haskell fix windows?
04:10:46 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:11:12 <Yaniel> well, it was fun while it was there
04:19:19 <pavonia> @where faq
04:19:19 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:20:48 <tdammers> yeah, it was mostly useful to belittle noobs
04:22:35 <srhb> I found it kind of educational, occasionally people do come in here asking the same question ("Can Haskell do X?") a zillion times. That is when it was appropriate, when six different people had tried to explain what general purpose programming language means.
04:23:10 <srhb> Not that I mind terribly. I just don't think people abused it to belittle noobs very much at all.
04:24:01 <tdammers> well, a more serious answer would have been "Haskell is a general-purpose programming language, but it doesn't perform miracles"
04:24:14 <Yaniel> yeah I've seen it used as a proper response to badly formed questions
04:24:16 <tdammers> which, for some reason, are things that aren't obvious to newcomers
04:24:19 <Maior> fwiw I've found similar things be very useful in other channels along similar lines to what srhb describes
04:24:26 <orion> Does lambdabot use an IRC library in Hackage?
04:24:30 <orion> If so, which one>?
04:25:27 <srhb> tdammers: I mostly meant after all those attempts had been made. There comes a point where pointing out that the questions are ridiculous in a humorous way is actually useful.
04:27:22 <tdammers> yeah, it is
04:27:29 <tdammers> it's still kind of belitteling though
04:27:35 <tdammers> but, arguably, rightfully so
04:28:00 <tdammers> I mean, if you keep asking questions that show you aren't listening at all, then you deserve being mocked and belittled
04:28:00 <m-r-r> Hello
04:28:56 <m-r-r> I have a function `f :: Sting -> String -> Bool`
04:29:30 <m-r-r> It takes two string, performs a comparison, and returns a boolean
04:30:21 <m-r-r> The function is case-sensitive, so i would like to combine it with another function: (map toLower).
04:30:54 <srhb> m-r-r: Can you write it in a pointful way?
04:31:10 <m-r-r> The problem is i can't write g = f . (map toLower) because f takes two arguments, and (.) only works with one argument
04:31:24 * hackagebot network-msg 0.2 - Recvmsg and sendmsg bindings.  http://hackage.haskell.org/package/network-msg-0.2 (sickmind)
04:31:39 <pavonia> :t on
04:31:40 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
04:32:54 <pavonia> > on (==) (map toLower) "FOObar "fooBAR"
04:32:55 <lambdabot>  <hint>:1:39:
04:32:55 <lambdabot>      lexical error in string/character literal at end of input
04:33:02 <pavonia> > on (==) (map toLower) "FOObar" "fooBAR"
04:33:04 <lambdabot>  True
04:33:38 <m-r-r> pavonia: that's just what i was looking for, thanks :-)
04:34:00 <pavonia> np
04:39:48 <zomg> Is iterate + takeWhile a generally good approach for doing something that requires collecting N results for an unknown number of iterations?
04:40:15 <srhb> zomg: Sounds fine :)
04:40:33 <zomg> Cool, was just wondering as I haven't used laziness in this style before
04:40:35 <fizruk> zomg: to collect N, I’d use take N
04:40:52 <srhb> I don't think he actually meant N
04:41:03 <zomg> yeah by N I just meant some number of results :)
04:41:11 <fizruk> ah, ok
04:41:15 <zomg> where said number is not known ahead thus takeWhile
04:56:15 <jdm12> quick cabal install question if anyone's got a moment to help out:
04:57:07 <jdm12> I want to install the Haskell Platform with profiling *and* offline documentation, which doesn't exist
04:57:29 <jdm12> so I've installed the profiling version,and wget-ed the docs
04:58:38 <jdm12> If I place the docs in the default cabal location, and enable docs + profiling for future library downloads, will cabal do what I want, ie build cleanly on the platform library docs I'ce downloaded?
05:11:29 * hackagebot creatur 5.3.2 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.3.2 (AmyDeBuitleir)
05:11:33 <byorgey> jdm12: I'd be surprised if anyone knew the answer to that.  I am even more surprised that you say offline documentation doesn't exist for the Haskell Platform.
05:11:48 <jdm12> it does exist, of course
05:11:49 <byorgey> jdm12: how are you installing it?
05:12:06 <jdm12> sudo apt-get install haskell-platform-prof
05:12:23 <merlin_> @hoogle ~
05:12:24 <lambdabot> keyword ~
05:12:24 <lambdabot> Test.HUnit.Base (~:) :: Testable t => String -> t -> Test
05:12:24 <lambdabot> Test.HUnit.Base (~=?) :: (Eq a, Show a) => a -> a -> Test
05:12:34 <byorgey> jdm12: apt-get install haskell-platform-doc ?
05:12:44 <jdm12> i can choose -prof, -doc or neither, but not both, afaik
05:12:50 <byorgey> wat
05:13:14 <byorgey> silly Debian.
05:13:26 <jdm12> you're suggesting plonking haskell-platform-doc on top of -prof?
05:13:32 <jdm12> would that work?
05:13:35 <byorgey> I have no idea
05:13:49 <jdm12> yeah, nor me
05:13:50 <jdm12> pfff
05:13:57 <byorgey> I was simply suggesting installing haskell-platform-doc.  I had no idea it would involve plonking.
05:14:13 <jdm12> plonking's always a danger in these waters
05:14:57 <pjdelport> jdm12: What do you mean by choosing either, but not both? They don't conflict
05:15:38 <jdm12> ok, so i can, in fact,install the -prof version, then install the -doc version on top?
05:15:49 <pjdelport> jdm12: What do you mean by "on top"?
05:16:04 <pjdelport> They're independent packages; you just install them side by side.
05:16:11 <jdm12> as in apt-get install blah-prof blah-doc
05:16:19 <jdm12> oh, ok
05:16:50 <jdm12> they have a lot of material in common, of course, so i was anticipating potential issues
05:17:35 <jdm12> but if that's not a problem, life is easy, i think.  Thanks.
05:20:12 <jdm12> ...except for the stuff about local vs global library installation...
05:20:44 <jdm12> Chaps, thanks for taking a few moments to help out with something fairly pedestrian.
05:24:01 <byorgey> jdm12: what about local vs global library installation?
05:24:36 <byorgey> jdm12: everything that comes with the haskell platform should go in the global package DB.  Anything you install yourself via 'cabal install' should (and will automatically) go in your local user package DB.
05:26:19 <jdm12> yes, just so
05:26:52 <jdm12> i'd like to have a unified offline docs index
05:27:40 <jdm12> and from memory and a bit of reading, this doesn't just happen
05:28:38 <jdm12> but i'm a bit sleep-deprived, and may be worrying about illusory stuff
05:31:32 * hackagebot cabal-cargs 0.5 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.5 (DanielTrstenjak)
05:46:34 * hackagebot twitter-types 0.2.20140424 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.2.20140424 (TakahiroHimura)
06:04:47 <oafa> hello
06:06:49 <srhb> oafa: o/
06:07:06 <oafa> in haskell one can define unsafeCoerce via a binding such as "let x = unsafePerformIO (newIORef Nothing)".  non-pure languages like ocaml work around this type-safety hole by imposing a "value restriction".  is it possible to somehow work around this (i.e. prevent such code) in haskell?
06:07:59 <srhb> The point of unsafePerformIO is exactly to escape the type system, sort of.
06:07:59 <oafa> (perhaps by changing the calling convention of unsafePerformIO to :: IO a -> (a -> b) -> b or something like that)
06:08:04 <srhb> Hmm
06:09:14 <StoneToad> you want to have a safe unsafePerformIO?
06:09:17 <StoneToad> 'safe'
06:09:30 <StoneToad> or you want to avoid people escaping the type system on you?
06:09:36 <oafa> an unsafePerformIO which doesn't let you write unsafeCoerce :)
06:09:40 <{AS}> Hi, is there a short way to uncurry to the right like this : (a -> b -> c -> d) -> (a, (b, c)) -> d ?
06:11:17 <jdm12> {AS}: uncurry . uncurry
06:11:50 <srhb> jdm12: Isn't that to the left?
06:11:58 <srhb> :t uncurry .  uncurry
06:11:58 <Axman6> @djinn (a -> b -> c -> d) -> (a, (b, c)) -> d
06:11:58 <lambdabot> f a (b, (c, d)) = a b c d
06:11:59 <lambdabot> (a -> b1 -> b -> c) -> ((a, b1), b) -> c
06:12:11 <Axman6> @. pl djinn (a -> b -> c -> d) -> (a, (b, c)) -> d
06:12:11 <lambdabot> f = (`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .)
06:12:12 <StoneToad> oafa:  hmm in conduit the code that was trying to do stuff like that got changed to use PrimMonad (from Data.Vector), that might have the sort of stuff you want?
06:12:16 <Axman6> ha
06:12:46 <jdm12> oops,sorry
06:13:00 <oafa> StoneToad: i'll check it out
06:13:04 <{AS}> Oh, I see (it is probably easier to do it manually then), thanks :)
06:13:52 <money> can I do .NET and Winapi programming with Haskell?
06:14:38 <jdm12> pjdelport: byorgey: so, the result is that if I don't worry excessively and proceed straightforwardly, the system does the Right Thing, pretty much.  (This hasn't always been my experience in  the past, particularly under Windows.)  Thanks again.
06:15:13 <srhb> money: I think the Winapi is decently exposed through various libraries. Not sure on .NET
06:17:30 <StoneToad> oafa: it occurs to me that actually that's probably not a solution for what you want, since it just abstracts your code over IO and ST monads
06:28:19 <klrr_> is there any _String -like functions when working with wreq like _List and _Int?
06:28:45 <Axman6> if they're in lens, then probably
06:28:56 <klrr_> _String is from lens?
06:29:02 <Axman6> yes...
06:29:12 <Axman6> have you read the tutorial?
06:29:16 <edwardk> _String comes coms from Data.Aeson.Lens
06:29:22 <edwardk> er comes from
06:29:23 <Axman6> oh, right
06:29:32 <edwardk> which is in lens
06:29:38 <klrr_> really?
06:29:50 <klrr_> or well, it can be there but not be documented
06:29:59 <klrr_> (i searched its haddock and no _String appear ;))
06:30:18 <klrr_> hmm, Data.Aeson.Lens dont export _String
06:30:18 <edwardk> http://hackage.haskell.org/package/lens-4.1.2/docs/Data-Aeson-Lens.html
06:30:28 <edwardk> look in AsPrimitive
06:30:59 <klrr_> hmm, i looked at latest docs, thanks!
06:31:20 <klrr_> or another package
06:31:24 <klrr_> now im confused, either way thanks! :)
06:31:48 <supki> edwardk: is there any point in having _Integral now?
06:32:13 <supki> or _Integer
06:32:40 <edwardk> yes. because you usually don't want it back as a Scientfic
06:32:55 <supki> _Integer is especially silly being the exact copy of _Integral with constrained type
06:33:30 <edwardk> yet it is often exactly what you need
06:34:01 <edwardk> lest you get a refusal for t to work due to an underspecified type
06:40:15 <albeit> Is it possible to have a function that takes either a pair (Int, Int) or an Int as the first argument? Or is the best way to do that have Maybe (Int, Int) and Maybe Int as arguments, and just make one of them Nothing?
06:40:31 <supki> edwardk: I don't see how it helps with t?
06:40:53 <supki> and Integral a => a thing defaults to Integer anyway
06:42:38 <edwardk> supki: defaulting only fires in very limited circumstances
06:43:37 <edwardk> with the existing aeson combinators it is possible to wind up in circumstances where the defaulting roles don't apply (even extended defaulting rules)
06:43:51 <edwardk> which forces you to use explict type annotations or something like _Integer
06:45:55 <geekosaur> albeit: Either (Int,Int) Int ?
06:46:37 <geekosaur> while it's often used that way, there's nothing that says Left *has* to indicate an error condition
06:47:19 <albeit> geekosaur: Would it still be considered acceptable style?
06:48:10 <geekosaur> needing to dothat at all is a bit of a smell, but it depends on what exactly you're trying to accomplish. (by which I don't mean the implementation but the intent / high level overview)
06:49:13 <albeit> I have a graph, and it needs to update either an edge or a vertice (with the rest of the arguments the same). An edge is keyed by (Int, Int), and a vertice by Int.
06:50:40 <fizruk> albeit: why not 2 functions: updateEdge and updateVertex?
06:54:32 <albeit> They share about half the code, so was hoping to do one function, but I guess I could refactor the repeated code into a new function and just make three functions.
06:57:56 <vermeille> Does applicative guarantees sequentiality ? does f <$> a <*> b guarantees that a would be "evaluated" before b in the same fashion as a >>= b?
06:58:11 <vermeille> I don't know how to word it properly but you got the idea
07:03:02 <byorgey> vermeille: it doesn't guarantee anything about evaluation.  It does guarantee that the "effects" of a will "happen before" the effects of b
07:03:50 <byorgey> however, there may be a different meaning of "happens before" particular to each Applicative instance
07:04:06 <vermeille> byorgey: so if a and b are parsers, it does guarantee that the parser a will "run" before the parser b, just to make sure
07:04:23 <byorgey> vermeille: yes, for a typical parser instance
07:05:55 <byorgey> (though it's quite possible---and a fun exercise---to make a parser instance that runs "backwards" =)
07:06:38 <vermeille> My brain can't handle that :D
07:07:48 <byorgey> of course not, that's why it's a good exercise =)
07:07:58 <byorgey> then after the exercise, your brain *can* handle it.
07:10:28 <vermeille> Okay, please define what you exactly mean by "backwards"
07:11:29 <byorgey> I mean that in   f <$> a <*> b   the parser 'b' will run first, consuming the first part of the input, and then parser 'a' will run, consuming what's left
07:11:57 <merijn> byorgey: Don't you mean what's right? ;p
07:12:02 <byorgey> hahaha
07:12:36 <merijn> Actually, right works in two ways :)
07:12:47 <merijn> positionally and as-in correctness :p
07:12:59 <byorgey> merijn: no, I mean what's left.  You're being LTR-normative ;-)
07:13:12 <byorgey> obviously vermeille is parsing Arabic.
07:13:21 <merijn> byorgey: Check your horizontal reading-privilege!
07:16:10 <erisco> I do not understand what looks like a simple type error http://lpaste.net/103153
07:16:38 <erisco> what variable is escaping scope?
07:18:50 <byorgey> erisco: compile requires an argument which can use *any* type t, but at the time when you call it the type t has already been chosen
07:19:00 <fizruk> erisco: compile expects (forall t. Frameworks t => Moment t ()), you have Moment t for *some* t
07:19:13 <byorgey> erisco: note in particular that foo is a list of  Moment t ()  which *all have to be the same* t
07:19:50 <erisco> what are my options?
07:19:56 <byorgey> i.e.  forall t. Frameworks t => [Moment t ()]   is not the same as   [forall t. Frameworks t => Moment t]
07:20:13 <erisco> okay thanks I'll try that
07:21:01 <byorgey> you might have to make a wrapper type for  forall t. Frameworks t => Moment t,  I'm not sure if what I wrote is actually valid
07:21:35 <fizruk> should be
07:22:06 <erisco> I annotated with a new compile error http://lpaste.net/103153
07:22:09 <fizruk> :t undefined :: [forall a. Show a => Maybe a]
07:22:10 <lambdabot>     Illegal polymorphic or qualified type: forall a. Show a => Maybe a
07:22:10 <lambdabot>     Perhaps you intended to use ImpredicativeTypes
07:22:10 <lambdabot>     In an expression type signature: [forall a. Show a => Maybe a]
07:22:46 <byorgey> erisco: did you have to turn on ImpredicativeTypes?
07:22:50 <erisco> yes
07:22:57 <byorgey> don't, I wouldn't trust it
07:23:02 <merijn> erisco: ImpredicativeTypes is broken and shouldn't be used
07:23:04 <erisco> but it did not compile without
07:23:08 <merijn> erisco: Also, you can't do this by design
07:23:30 <erisco> merijn, I do not really understand what the design is... can you help me understand?
07:23:30 <fizruk> erisco: it would help if you provided more details
07:23:32 <merijn> erisco: reactive-banana was designed this way to stop you from sneaking Moment's in and out
07:23:34 <erisco> I have been stuck on this forever now
07:23:46 <byorgey> erisco: I don't know what you're trying to do, but there is probably a better way.
07:23:57 <merijn> erisco: You can't pass moments as arguments to another Moment
07:24:10 <erisco> merijn, where am I doing that?
07:24:27 <merijn> erisco: You're using a Moment (foo) to generate a new Moment (via sequence)
07:24:46 <erisco> the sequence_ is for the IO monad
07:24:56 <merijn> hmm, lemme check
07:25:47 <erisco> I have multiple web pages. each page is constructed as the type  Moment t (Behavior t [Node])
07:25:55 <merijn> oh, wait
07:26:06 <merijn> reactive-banana changed quite a lot since I last looked
07:26:19 <erisco> and so since I have multiple I have the list  [Moment t (Behavior t [Node])]   all I want to do is compile the pages individually so that I can switch between them
07:26:40 <erisco> I know there is switching in reactive-banana but it seems to only be for events/behaviors in the same network
07:26:40 <merijn> erisco: You need the Reactive.Banana.Switch module to convert via "AnyMoment"
07:26:58 <merijn> erisco: Wait, you want to have multiple networks?
07:27:00 <erisco> I do not want all the pages to be compiled at once because that'd be too costly
07:27:12 <erisco> yes I do not see why not
07:27:18 <merijn> erisco: You can't exchange things between them
07:27:31 <erisco> exchange what things?
07:27:42 <zq> oh man
07:27:50 <zq> i think i'm stuck in the honeymoon phase with hs
07:28:12 <merijn> Anything, all communication between multiple networks would have to go via producing IO that triggers events in the other networks
07:28:20 <erisco> yes that is fine
07:29:53 <erisco> I just can't appease the types :(
07:30:28 <tdammers> I for one welcome our new type overlords
07:31:23 <erisco> I understand the original type problem as it was explained
07:31:29 <erisco> I do not understand the problem in my annotation
07:31:30 <erisco> http://lpaste.net/103153
07:32:10 <erisco> (yes, qux would be compiling all the
07:32:28 <erisco> 'pages' but this is just simplified)
07:33:48 <erisco> if impredicativetypes is not wise to use, how can I avoid it here?
07:36:48 <erisco> I am getting the feeling that I am SOL
07:37:17 <JordiGH> Do you guys find most Haskell easy to read? I find like I still have to do a lot of internal language lawyering to grok unfamiliar Haskell. It reminds me more of C++ than of Python.
07:37:36 <JordiGH> I wonder if I'm just stupid or if Haskell really is just harder to read.
07:38:53 <Yuu_chan> IMO, Haskell is easy, most Haskell code is not
07:39:32 <Yuu_chan> Whereas C++ is complicated by itself.
07:39:56 <JordiGH> Well, I find most C++ easy to read unless they're doing complicated template magic.
07:40:06 <mmachenry> JordiGH: I would say that in some cases, Haskell has more features that allow you to write concise and occasionally denser code. This amounts to a shorter program that is in total easier to read and debug, but an individual code snippet might be harder if you're coming from Python.
07:40:35 <Yuu_chan> A matter of habits, probably.
07:40:57 <JordiGH> mmachenry: You really think that if Haskell had happened 10 years before Python and everyone was familiar with it, most people would find it just as easy to read as Python?
07:41:19 <mmachenry> JordiGH: I didn't say that.
07:41:30 <Maior> JordiGH: to expand upon what mmachenry has said, I've found that sometimes people write that concise and denser code where they would be better writing more verbose and understandable code;
07:41:32 <JordiGH> Well, that's what I'm asking. Is Haskell easy to read on some absolute scale?
07:41:41 <mmachenry> JordiGH: Imagine this...
07:41:45 <Yuu_chan> Problems of reading _good_ Haskell code are from that it is densier and carries much more information.
07:42:16 <Maior> JordiGH: pass
07:42:20 <mmachenry> Take Python, add a lot of new functions that allow you to say what you want more concisely. Add function composition and auto currying allowing point free style.
07:42:23 <JordiGH> Yuu_chan: I find that argument bad. Bad Python is still usually easy to read. Bad Haskell isn't.
07:42:30 <Yuu_chan> Bad code can be overwhelmed with pointfree, non-obvious operator using and so on
07:42:35 <mmachenry> Now rewrite a larger Python program using these new features.
07:42:41 <mmachenry> Which is easier to read?
07:42:47 <zerokarmaleft> but bad python is usually impossible to reason about
07:42:52 <mmachenry> It's not conclusive, but I think that's the difference.
07:43:02 <zerokarmaleft> and even good python may be difficult to reason about
07:43:06 <Maior> JordiGH: on the scale of "large chunks of code" / "programs" etc. I find Haskell easier to read; even if I can't work out what a function does, I can often tell from the type signature etc.
07:43:15 <mmachenry> I need to pay attention to this meeting, bbl
07:43:21 <JordiGH> mmachenry: But that's also a matter of ethos... if the language encourages people to write bad code, well... It's difficult to write difficult to understand Python unless you try very hard.
07:43:55 <Maior> JordiGH: the strength of the type system, etc. etc., means that I'll gladly take the occasional cost of "how does this function work, um, thinking time" in return for knowing "this function does X and can't do anything else"
07:43:59 <JordiGH> Maior: I suppose type signatures are a very good aid, but since they're frequently optional, I hate it when I'm reading new code and not all functions have type annotations.
07:44:02 <mmachenry> I agree a lot with that, JordiGH, but I think Haskell's new features aren't bad. Whereas stuff like Autoload in Perl are.
07:44:08 <Maior> JordiGH: I absolutely disagree re Python btw
07:44:24 <erisco> I have a similar type error again http://lpaste.net/103157  just shooting in the dark now
07:44:31 <erisco> would be nice if I knew why this one was wrong too
07:44:36 <Maior> JordiGH: it's perhaps hard to write _individual lines_ of difficult to understand Python
07:44:49 <Maior> JordiGH: whereas it's incredibly easy to write lines of hard to understand Haskell (ime)
07:45:07 <Maior> JordiGH: if you step back and compare programs/services/etc., I find the opposite
07:45:08 <JordiGH> Okay, I'll keep on trying with Haskell, but if I can't understand my own code 6 months from now, I'll be disappointed.
07:45:30 <Yuu_chan> JordiGH: which argument?
07:45:49 <JordiGH> Yuu_chan: The argument that "anyone can write obscure code in any language."
07:46:05 <Yuu_chan> JordiGH: I didn't say that.
07:46:19 <JordiGH> Yuu_chan: It's about the language ethos. Some languages just scream out for writing obscure code. Try to write easy-to-read J, for example.
07:46:52 <JordiGH> And you can, if you want, also write beautiful brainfuck. All you have to do is comment just about every character. :-)
07:47:27 <Yuu_chan> JordiGH: with whom are you arguing?
07:47:55 <JordiGH> No one, ttyl.
07:50:58 <erisco> merijn, if it is impossible to have multiple frameworks how might I do this with one?
07:51:33 <Fernandos> hi
07:52:09 <Fernandos> I'd like to upgrade cabal for the local user only, how would I do that? cabal install --user cabal ?
07:52:41 <geekosaur> it already defaults to user
07:53:54 <Fernandos> geekosaur: ok, trying it out
07:54:07 <Fernandos> Cabal-1.20.0.0 failed during the configure step. The exception was:
07:54:13 <Fernandos> ExitFailure 127
07:54:26 <Fernandos> that's not of much help :/
07:54:45 <geekosaur> 127 is usually a missing program, the real error should be above that (but may need some -v options to see what's actually going on)
07:54:51 <vermeille> When writing an interpreter, do you use a Free monad for the AST or only for the side effects? I don't see how you would use the Free monad on an AST of an arithmetic expression. Despite being completely silly, you can't avoid arithmetic expressions. All exemple I saw were just sequence of simple instructions without real world tree structure
07:56:08 <lazythunk>  #haskell-game
07:56:22 <jmcarthur> :D
07:56:30 <lazythunk> damn fingers
07:56:50 * hackagebot http-kit 0.2.0 - A low-level HTTP library  http://hackage.haskell.org/package/http-kit-0.2.0 (SimonHengel)
07:57:50 <fizruk> vermeille: data Op a = Add a a | Mul a a | Sqrt a
07:58:11 <Fernandos> Ok this is the "error" http://bpaste.net/show/o0niGSExF5TkKNKDlo5p/
07:58:22 <Fernandos> no idea what's wrong..
07:58:25 <fizruk> vermeille: forgot “ | Lit Int”
07:58:50 <merijn> Fernandos: oh
07:58:58 <fizruk> vermeille: “Free Op Void” would be a closed term under those operations
07:59:07 <merijn> Fernandos: You're trying to update your "cabal" binary?
07:59:07 <vermeille> fizruk: okay no pb with that, that's the naive code I have for now
07:59:33 <fizruk> vermeille: >>= would be subexpression substitution
07:59:41 <merijn> Fernandos: You've been misled, the correct name for the "cabal" binary is the "cabal-install" package, so you'll want "cabal install cabal-install"
07:59:59 <Fernandos> merijn: aahh ok.. gonna try that
08:01:16 <Yuu_chan> „To install cabal, do cabal install cabal-install“
08:01:22 <vermeille> fizruk: what you mean by "subexpression substitution"?
08:01:26 <Yuu_chan> FY=YF(YF)
08:01:46 <vermeille> Lambda calculus?
08:02:16 <ziman> :D
08:02:28 <oleo> what about ?
08:02:59 <fizruk> vermeille: suppose you have t :: Free Op Var, then t >>= f would substitute each variable x :: Var with (f x)
08:03:00 <Yuu_chan> Recursive sentences always remind me of fixed point combinator
08:03:54 <fizruk> vermeille: in “Free Op a” a’s represent free variables in a term
08:04:02 <Fernandos> merijn: that failed with: cabal-install-1.20.0.0 depends on Cabal-1.20.0.0 which failed to install.
08:04:08 <Fernandos> cyclic dependency??
08:04:37 <vermeille> fizruk: okay I think I got it
08:05:04 <fizruk> vermeille: anyway, I don’t understand what you actually want
08:05:24 <geekosaur> Fernandos, that's not cyclic. cabal-install is a program, Cabal is a library
08:05:33 <erisco> okay for some reason it compiled when I broke out the steps... how did the type inference change? so confused
08:05:33 <erisco> http://lpaste.net/103158
08:05:34 <geekosaur> note that upgrading the Cabal library carries some risks
08:05:52 <erisco> also what is wrong with impredicative types?
08:06:37 <fizruk> vermeille: you want to combine “expressions” and “statements” in a single functor f so that “Free f a” would represent a program with both of them?
08:06:51 * hackagebot battleships 1.0.0 - A web-based implementation of battleships including an AI opponent.  http://hackage.haskell.org/package/battleships-1.0.0 (fatho)
08:07:55 <vermeille> fizruk: I read this article http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html which is very interesting *but* his language is purely linear, we can't even call that an AST, but an "ASL" (Abstract Syntax List :D). How do you use the nice things he his introducing with languages which have a tree structure
08:08:12 <geekosaur> erisco: what isn't wrong with them? they're difficult.
08:08:17 <Fernandos> geekosaur: I only try to upgrade to the current cabal library and binary, then want to ONLY use packages from cabal instead of using those from the haskell overlay.
08:08:25 <erisco> geekosaur, difficult in what way?
08:08:43 <fizruk> vermeille: in comments there are some words on Fork a a, which introduces branching
08:08:54 <Fernandos> geekosaur: I have gentoo, wish I had nixos, but switching over would take too much off atm. maybe another time
08:09:15 <erisco> also I am wondering if there is a type inference bug....
08:09:32 <geekosaur> erisco: http://www.haskell.org/haskellwiki/Impredicative_types and links therefrom
08:09:57 <geekosaur> if you're trying to do type inference around an impredicative type, stop now; it does not work, it can not work
08:10:13 <geekosaur> that's kinda what impredicative type means
08:10:25 <fizruk> vermeille: note however that in article “a” (in “Free f a”) refers to “future computations”
08:10:26 <erisco> that is okay but this result is bizarre
08:10:28 <erisco> take a look http://lpaste.net/103159
08:10:33 <matheus23> is there an operator like (.) of the type (a -> b -> c) -> (c -> d) -> (a -> b -> d) ?
08:10:35 <erisco> I'd like to know why one compiles and the other fails
08:10:56 <fizruk> vermeille: while in “Free Op a” a refers to free variables (subexpressions)
08:11:25 <fizruk> vermeille: these are two different uses of Free monad
08:12:12 <erisco> considering  \x -> actuate =<< compile x   is equivalent to  actuate <=< compile   it seems like a bug that one compiles and the other does not
08:12:40 <erisco> unless there is some incredibly obscure type inference rules getting in the way
08:12:46 <vermeille> I understand your use less than his. What would mean the do notation with your use?
08:13:35 <jmcarthur> vermeille: the second comment on that blog post asks exactly what you are asking. "How does the machinery work for non-linear languages, for example data Expr a = Value a | Plus a a?"   and there is a response
08:14:24 <dashster18> yes
08:14:27 <geekosaur> erisco: you porbably need to ask a ghc internals expert. that kinda sounds to me like the old problem with impredicative typing, aka the runST problem...
08:15:35 <ozgura> did anyone experience slow-downs with ghc-7.8.2 compiled programs in comparison to ghc-7.6.3?
08:15:39 <geekosaur> there is "hidden" polymorphism going on (indicated by the forall in the error) due to impredicativity, as I understand it. but I *don't* really understand it, I just know that it's a form of polymorphism that tends to break things people expect to work....
08:15:48 <ozgura> I don't mean the compilation times here
08:16:25 <fizruk> vermeille: do-notation would rarely be used, I guess: building AST would be just as you usually do with data AST = …
08:16:38 <jmcarthur> ozgura: so far it has produced overall faster binaries for me, but i haven't done much performance testing yet
08:17:04 <ozgura> jmcarthur: it is much slower for me if I am not doing something terribly wrong
08:17:12 <fizruk> jmcarthur: `Plus a a` would be a fork, not actually addition (not sure what vermeille asked about though)
08:17:27 <vermeille> jmcarthur: I read that comment. I don't understand it.
08:17:27 <ozgura> well, both the compiler and the generated executable
08:17:46 <intrados> matheus23: flip ((.).(.)) does that
08:17:49 <ozgura> unfortunately, this is a closed-source beast of a program where this happens
08:17:53 <vermeille> fizruk: that's exactly what bothers me with that post
08:18:25 <fizruk> vermeille: expressions or non-linear languages? :)
08:18:35 <vermeille> both!
08:18:46 <ozgura> did anything change about what -O1 and -O2 imply in 7.8?
08:19:01 <ozgura> i.e. what optimisations are turned on
08:19:42 <fizruk> vermeille: they are *different* things, Gabriel’s post is about “statements”, not “expressions” (correct me someone if I’m wrong)
08:21:49 <fizruk> vermeille: in that comment “Plus a a” would better be called “Fork a a” - it would correspond to a fork command (statement)
08:22:09 <vermeille> I won't understand that Monad today. Feeewww.
08:22:25 <vermeille> fizruk: yeah I see, and what about an actual Plus?
08:23:25 <fizruk> vermeille: that is a very different story :) I’m not an expert in building expression ASTs with free monads though
08:23:28 <albeit> I'm doing some like "(MyState _ _ _ foo) <- get" in a stateful function... is there a better way to get just the field foo? (Assume MyState has a field called fooField with record syntax)
08:24:17 <geekosaur> foo <- gets fooField -- ?
08:24:22 <vermeille> fizruk: Oh... That's maybe the reason I can't understand it :D Okay, I'll try to figure it out again thinking that I may be looking for something nonexistent
08:25:46 <erisco> ah ha I figured something out geekosaur :)
08:26:06 <erisco> I figured out the problem with the annotation here http://lpaste.net/103153
08:26:23 <albeit> geekosaur: Thanks
08:26:24 <solrize> z
08:26:31 <erisco> sorry, I did not figure that out, lol
08:26:33 <fizruk> vermeille: note that free monads are often used to implement *embedded* DSL in Haskell: that way you already have all sorts of expressions :)
08:26:55 * hackagebot direct-sqlite 2.3.13 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.13 (IreneKnapp)
08:27:19 <erisco> what I figured out was how to take an implicit forall and make it... explicit?
08:27:30 <erisco> data Page = Page (forall t. Frameworks t => Moment t (Behavior t [Node]))
08:27:35 <erisco> I have to wrap it in a data type
08:27:39 <erisco> then unpack it
08:27:42 <erisco> *shrug*
08:27:53 <fizruk> vermeille: what you get is a clean way to specify what you can or cannot do, possibility to traverse/modify AST and have multiple interpreters
08:28:21 <fizruk> vermeille: I might have missed some other bonuses free monads give you
08:28:39 <erisco> I guess the point is that by putting a value into Page it generalises 't', and therefore unpacking it then maintains the generalised 't'
08:28:41 <vermeille> Oooh... "embedded"... That may not be suitable at all for an interpreter which actually parses a source file and stuff
08:29:15 <erisco> which basically gives me the magical   Moment t () -> forall t. Moment t ()   conversion
08:29:27 <erisco> not sure if there is a smarter way but that works for me
08:30:22 <erisco> and I have no idea what is really going on with it :P
08:31:51 <fizruk> vermeille: depending on the kind of AST you want to get, free monads may or may not be of any use to you
08:33:20 <fizruk> vermeille: actually you could make it “source -> AST -> IR -> interpretation”
08:33:50 <fizruk> vermeille: where AST would be close-to-source AST and IR could be a free monad
08:34:17 <vermeille> fizruk: true! absolutely! thanks for the idea!
08:35:15 <fizruk> vermeille: haven’t written that way any interpreters, so can’t tell you any caveats of this approach
08:37:18 <carter> erisco: you can use newtype tooo
08:37:46 <erisco> carter, so I can... was getting an error with something similar before
08:38:00 <carter> erisco: sleep is a wonderful thing
08:38:21 <erisco> indeed but I don't get any until I get what I need working :P
08:38:24 <carter> fizruk: vermeille  theres also the finally tagless approach
08:41:11 <vermeille> carter: Hum?
08:41:13 <jmcarthur> carter: in fact, the finally tagless approach is pretty much dual to the free monad approach
08:41:38 <carter> jah
08:42:07 <jmcarthur> free monads are a syntax driven style. finally tagless is a semantics driven style.
08:42:24 <carter> jmcarthur: the vector package kinda does the final encoding right?
08:42:37 <carter> i like me some semantics
08:42:37 <jmcarthur> carter: not sure what you mean
08:42:44 <jmcarthur> carter: final encoding of what?
08:42:54 <carter> finally tagless
08:43:03 <vermeille> What means "finally tagless"?
08:43:07 <erisco> carter, do you know if I have to wrap and then unwrap to get the damned 't' variable to work?
08:43:11 <jmcarthur> carter: i mean what is the semantics of vector?
08:43:11 <erisco> seems strange
08:43:28 <carter> jmcarthur: ha :)
08:43:35 <jmcarthur> vermeille: https://www.cs.rutgers.edu/~ccshan/tagless/jfp.pdf‎
08:44:18 <jmcarthur> carter: i don't think it's so easy to say something is a final encoding if you can't even pin down the semantics
08:44:33 <carter> jmcarthur: well, *my* array api has really neat semantics
08:44:40 <jmcarthur> carter: you devise a final encoding based on the semantics
08:44:47 <carter> i'm really pleased with how its stabilizing
08:44:55 <jmcarthur> carter: in particular a denotational semantics
08:45:14 <carter> in my head or on paper or in coq or haskell or idris or agda?
08:45:25 <carter> ie "what things mean when you evaluate them"
08:45:48 <carter> right?
08:46:02 <jmcarthur> yes, denotational semantics is the "meaning"
08:46:23 <carter> jmcarthur: yeah, too much of the meaning in vector is tied into the fusion tubing
08:46:23 <jmcarthur> and a final encoding is when your representation coincides with your denotational semantics
08:48:05 <jmcarthur> the meaning of a vector is basically just    [| Vector a |] = (n:Nat) * ((m:Nat) -> a), m < n
08:48:34 <jmcarthur> a length and a function from nats to elements where the index must be less than the length
08:48:49 <jmcarthur> pardon the notation
08:49:46 <jmcarthur> so in order for vector to be a final encoding, it would have to be something like   data Vector a = Vector Int (Int -> a)   with some extra restrictions
08:50:09 <jmcarthur> you could make that type more precise, but it's arguable whether it would be worth it
08:52:26 <carter> jmcarthur: don't you mean moreso you could model vector as such
08:52:40 <carter> but it might internally be implemented different from that but have the same semantics?
08:53:03 <jmcarthur> carter: you're free to have a different implementation, but then it's not a final encoding
08:53:27 <carter> the denotation != implementation
08:54:02 <jmcarthur> right.  final encoding basically means denotation = representation
08:54:19 <jmcarthur> initial encoding means syntax = representation
08:58:42 <carter> huh
08:58:47 <carter> i dislike both then
08:58:48 <carter> :)
08:59:49 <jmcarthur> why? they both have their uses
09:00:36 <jmcarthur> initial encodings are great if you just don't want to think about how it works yet. final encodings are great if you are concerned with semantics (and can actually be quite efficient in practice)
09:00:57 <carter> im being silly
09:00:58 <jmcarthur> for example, the machinery vector actually uses can just be hidden in the closure of the final encoding
09:03:21 <jmcarthur> and the final encoding makes many properties of the type plainly obvious
09:12:00 * hackagebot integer-pure 1.0 - A pure-Haskell implementation of arbitrary-precision Integers.  http://hackage.haskell.org/package/integer-pure-1.0 (MalcolmWallace)
09:22:02 * hackagebot Octree 0.5.3 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.5.3 (MichalGajda)
09:22:03 <erisco> > (- 1) 5
09:22:04 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
09:22:05 <lambdabot>    arising from the ambiguity check for ‘e_115’
09:22:05 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
09:22:05 <lambdabot>    bound by the inferred type for ‘e_115’:
09:22:05 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
09:22:20 <erisco> > (+ (-1)) 5
09:22:21 <lambdabot>  4
09:22:28 <erisco> mkay is there another way to do that?
09:23:14 <geekosaur> > (subtract 1) 5
09:23:15 <lambdabot>  4
09:23:49 <geekosaur> kinda the official Haskell report hack for sections on (-) which are made difficult by the unary - hack
09:24:42 <erisco> thanks
09:27:02 * hackagebot voyeur 0.1.0.1 - Haskell bindings for libvoyeur  http://hackage.haskell.org/package/voyeur-0.1.0.1 (sethfowler)
09:30:00 <asQuirreL> @djinn Bool -> a -> Maybe a
09:30:00 <lambdabot> f a b =
09:30:00 <lambdabot>     case a of
09:30:00 <lambdabot>     False -> Nothing
09:30:00 <lambdabot>     True -> Just b
09:30:33 <asQuirreL> ^^ does such a function actually exist? it seems like it should...
09:30:55 <erisco> touble with MaybeT is you don't get to learn where the failure happens... debugging is a pita
09:32:41 <vermeille> @djinn (a -> b) -> c -> a -> Either c b
09:32:42 <lambdabot> f a _ b = Right (a b)
09:32:43 <erisco> @hoogle Bool -> a -> maybe a
09:32:44 <lambdabot> Did you mean: Bool -> a -> Maybe a
09:32:44 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
09:32:44 <lambdabot> Control.Exception assert :: Bool -> a -> a
09:33:00 <erisco> @hoogle Bool -> a -> Maybe a
09:33:01 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
09:33:01 <lambdabot> Control.Exception assert :: Bool -> a -> a
09:33:01 <lambdabot> Control.OldException assert :: Bool -> a -> a
09:33:03 <ReinH> :t flip maybe id
09:33:04 <lambdabot> a -> Maybe a -> a
09:33:11 <fizruk> :t \c x -> guard c >> return x
09:33:11 <ReinH> oh that's the wrong way
09:33:12 <lambdabot> MonadPlus m => Bool -> b -> m b
09:33:18 <asQuirreL> yeah, I was trying to avoid raising an error, but I've just gone for an assertion now
09:33:30 <erisco> ah yes, guard works
09:33:35 <erisco> :t guard
09:33:36 <lambdabot> MonadPlus m => Bool -> m ()
09:33:55 <vermeille> @djinn (a -> Bool) -> c -> a -> Either c a
09:33:55 <lambdabot> f a b c =
09:33:55 <lambdabot>     case a c of
09:33:55 <lambdabot>     False -> Left b
09:33:55 <lambdabot>     True -> Right c
09:33:56 <fizruk> there also should be guardA
09:34:34 <vermeille> I *WANT* that as a vim plugin
09:37:15 <ReinH> Valodim: want what?
09:37:26 <monochrom> wrong nick completion :)
09:37:31 <ReinH> argh
09:37:36 <ReinH> vermeille: want what?
09:37:41 <Valodim> :3
09:37:48 <monochrom> probably @djinn
09:37:57 <ReinH> Ah. Wouldn't be too hard.
09:38:11 <monochrom> djinn is actually available on hackage
09:38:13 <ReinH> :!djinn might be enough
09:39:36 <bennofs> Oh, so @djinn always gives a result, even if there is more than ne possible implementation?
09:40:14 <monochrom> when there are many solutions, it outputs the first one that comes to its mind
09:42:48 <vermeille> Yeah, djinn. Amazing.
09:43:47 <fizruk> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
09:43:47 <lambdabot> f a b =
09:43:47 <lambdabot>     case a of
09:43:47 <lambdabot>     Nothing -> Nothing
09:43:47 <lambdabot>     Just c -> b c
09:44:23 <fizruk> :t (\m f -> Nothing) :: Maybe a -> (a -> Maybe b) -> Maybe b
09:44:24 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
09:47:17 <srhb> is there a pandoc channel around?
09:52:47 <mmmm> I don't think there is srhb
09:52:54 <mmmm> best way it the mailing list or I can try and help
09:53:18 <srhb> mmmm: Ah, okay. Thank you. Is there a way to set options like extensions you want to enable from within the document?
09:55:12 <jakex> @src Ord
09:55:13 <lambdabot> class  (Eq a) => Ord a  where
09:55:13 <lambdabot>     compare      :: a -> a -> Ordering
09:55:13 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:55:13 <lambdabot>     max, min         :: a -> a -> a
09:55:42 <mmmm> Not as far as I am aware srhb, I am checking the source now
09:56:03 <srhb> mmmm: That's very kind of you. Don't worry about it if it's too much trouble. :)
09:57:16 <certainty> good evening everyone. Do arrays from Data.Array.IArray share structure? I mean does an update return an entirely new array that shares nothing with the old one or not?
09:57:38 <monochrom> I think it's a new array
09:58:08 <jakex> is it possible to autogenerate NFData?
10:00:35 <jle`> @djinn (s -> (a, s)) -> (a -> (s -> (b, s)) -> (s -> (b, s))
10:00:36 <lambdabot> Cannot parse command
10:00:53 <jle`> oops
10:01:05 <jle`> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
10:01:05 <lambdabot> f a b c =
10:01:05 <lambdabot>     case a c of
10:01:05 <lambdabot>     (d, e) -> b d e
10:01:52 <jle`> neat
10:03:01 <matheus23> fizruk: My 'widget' implementation mostly works (query Mouse clicks). I clean it up a little, upload it to github and send you a link :)
10:03:29 <matheus23> As a response to a so called 'Event' (Mouse / Keyboard) Widgets are allowed to change
10:04:47 <pavonia> Does anyone know what happened to preflex?
10:05:34 <__jim__> Does anyone know off hand if there is a transpose function for sequences like there are for lists? I didn't see anything on hoogle
10:05:45 <bennofs> pavonia: i think the host running it died
10:06:02 <fizruk> matheus23: can you link you repo again? I’d just “watch” it
10:06:28 <bennofs> __jim__: what do you mean by "Sequence" ?
10:06:35 <matheus23> fizruk: Yet, the Widget stuff is not uploaded. It will be in another repo (I think?). The one with the drawing is this one:https://github.com/matheus23/DeclarativeGraphics
10:06:42 <bennofs> __jim__: Data.Sequence.Seq?
10:06:45 <pavonia> bennofs: Hhm, that whouldn
10:06:46 <__jim__> bennofs: Data.Sequence
10:06:49 <__jim__> Yes
10:06:49 <pavonia> oops
10:07:07 <pavonia> bennofs: That shouldn't be a big problem
10:07:16 <bennofs> > traverse return [[1,2,3],[2,3,4],[4,5,6]]
10:07:18 <lambdabot>  No instance for (GHC.Show.Show (f0 [[t0]]))
10:07:18 <lambdabot>    arising from a use of ‘M231511492667873353815237.show_M2315114926678733538...
10:07:18 <lambdabot>  The type variables ‘f0’, ‘t0’ are ambiguous
10:07:18 <lambdabot>  Note: there are several potential instances:
10:07:18 <lambdabot>    instance [safe] GHC.Show.Show a =>
10:07:53 <fizruk> transpose == traverse (with ZipList/ZipSeq applicative) ?
10:08:21 <bennofs> @let import qualified Data.Sequence as S
10:08:22 <lambdabot>  Defined.
10:08:58 <fizruk> matheus23: oh ok. if there will be another repo, send a link :)
10:09:02 <certainty> monochrom: thanks
10:09:12 <bennofs> lambdabot > traverse id (S.fromList . map S.fromList $ [[1,2,3], [3,4,5], [5,6,7]]) :: S.Seq (S.Seq Int)
10:09:17 <bennofs> > traverse id (S.fromList . map S.fromList $ [[1,2,3], [3,4,5], [5,6,7]]) :: S.Seq (S.Seq Int)
10:09:19 <lambdabot>  Ambiguous occurrence ‘S.fromList’
10:09:19 <lambdabot>  It could refer to either ‘Data.Set.Base.fromList’,
10:09:19 <lambdabot>                           imported qualified from ‘Data.Set’ at L.hs:102:1-30
10:09:19 <lambdabot>                           (and originally defined in ‘containers-0.5.5.1:Data...
10:09:19 <lambdabot>                        or ‘Data.Sequence.fromList’,
10:09:37 <bennofs> @let import qualified Data.Sequence as Seq
10:09:39 <lambdabot>  Defined.
10:09:41 <fizruk> bennofs: Sequence has zippy Applicative instance?
10:09:47 <bennofs> > traverse id (Seq.fromList . map Seq.fromList $ [[1,2,3], [3,4,5], [5,6,7]]) :: S.Seq (S.Seq Int)
10:09:48 <lambdabot>  fromList [fromList [1,3,5],fromList [1,3,6],fromList [1,3,7],fromList [1,4,5...
10:10:03 <fizruk> nah, it’s like for lists
10:10:05 <bennofs> hmm, doesn't look right :p
10:10:15 <__jim__> I can play around with it
10:10:17 <__jim__> Thanks guys
10:11:07 <fizruk> oh, actually I meant sequenceA (which is traverse id)
10:11:59 <fizruk> > traverse ZipList [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
10:12:01 <lambdabot>  ZipList {getZipList = [[1,4,7],[2,5,8],[3,6,9]]}
10:13:24 <arrnas> i keep reading about monads from different sources but i haven't found a place where they would talk about writing your own instance of a monad. Is there even a point to it? there's a monad for lists, a monad for maybe etc.. i can't think of a type that would need a monad..
10:13:54 <iiian> arrnas: the low hanging fruit there has largely been picked
10:14:06 <__jim__> ahah, good call fizruk
10:14:43 <Maior> arrnas: http://learnyouahaskell.com/for-a-few-monads-more
10:14:58 <Maior> arrnas: iirc that sort of does
10:15:09 <Maior> granted, it's a monad that already exists, but still
10:15:16 <jmcarthur> arrnas: i write new monads all the time. i often happens that they are just different interpretations of existing monads, but it is still useful.
10:15:20 <jmcarthur> *it often
10:16:12 <jmcarthur> arrnas: also, that you can't think of a type that would "need" a monad is fine, because you never *need* one. it's just a useful way of looking at some combinations of types and operations on them
10:17:05 <c_wraith> arrnas: in particular, Monad is an abstraction that lets you re-use existing code.  You never need to re-use existing code.  It's just a good thing to do.
10:17:34 <Hodapp> You never need to re-use existing code, unless time has value to you.
10:17:34 <skypers> hm
10:17:49 <skypers> is there any difference between calling something a fold, and calling it a catamorphism?
10:18:02 <c_wraith> Hodapp: what, you don't rewrite the OS for every program you write?
10:18:10 <c_wraith> skypers: catamorphism is more specific
10:18:35 <c_wraith> skypers: for instance, with [], you can call both foldl and foldr a fold, but only foldr is a catamorphism
10:18:51 <skypers> c_wraith: why?
10:19:40 <c_wraith> skypers: build up an operation from the definition of a catamorphism.  You'll find that it's foldr, not foldl
10:19:54 <FreeFull> For reverse lists, foldl would be the catamorphism
10:19:57 <c_wraith> Hmm, where was that awesome article
10:20:21 <skypers> but hm
10:20:28 <a3gis> c_wraith: awesome article? where?
10:20:30 <skypers> I don’t really understand what a catamorphism is then
10:21:01 <c_wraith> a3gis: this is really hard to google for.  I remember an awesome article a few years back describing generic catamorphisms
10:21:02 <skypers> I read somewhere it’s a homomorphism
10:21:07 <skypers> but a -> b is not
10:21:14 <a3gis> c_wraith: oh ok :p I thought it was something linked earlier
10:21:15 <jmcarthur> skypers: basically it's when you replace the constructors with your own values of appropriate type
10:21:31 <skypers> jmcarthur: I’m looking for the mathematical sense
10:21:50 <jmcarthur> skypers: i good way to tell you have a catamorphism is that you can plug the constructors in and get the identity:   foldr (:) []
10:21:54 <jle`> arrnas: if you are ready for it, here is an article where they write their own monad for the purposes of purely constructing safe IO -- http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
10:21:57 <jmcarthur> *a good
10:22:33 <skypers> jmcarthur: but hm
10:22:41 <skypers> an isomorphism, for instance
10:22:42 <FreeFull> IO used to be done with lazy lists rather than monads
10:22:45 <skypers> we can define what it is
10:22:58 <skypers> what would be a catamorphism?
10:23:28 <jmcarthur> skypers: if your type is the fixpoint of a functor F, then a catamorphism takes an algebra (F a -> a) and produces an a
10:23:53 <c_wraith> skypers: Hmm.  I think http://stackoverflow.com/a/4435137/383200 might be what I was thinking of.
10:24:01 <skypers> thank you guys
10:24:08 <c_wraith> a3gis: ^ Amusingly, it was an answer on stack overflow
10:24:11 <jmcarthur> skypers: the functor in the case of [a] would be    data F a r = Cons a r | Nil
10:24:14 <FreeFull> I don't think there is any way to do catamorphisms in Haskell without recursive types
10:24:35 <a3gis> c_wraith: eheh, thanks! :)
10:24:36 <jmcarthur> skypers: so foldr in these terms would be   foldr :: (F a r -> r) -> [a] -> r
10:25:03 <jmcarthur> skypers: you can manipulate that type to look like the foldr type you are used to
10:25:04 <c_wraith> FreeFull: well, yes.  But you can get away with using Fix/Mu as your only recursive type
10:25:14 <FreeFull> True
10:25:46 <bennofs> FreeFull: isn't either a catamorphism ?
10:26:02 <FreeFull> :t either
10:26:03 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:26:31 <jmcarthur> FreeFull: you could also (basically by definition) define catamorphisms over types of the form     (forall r. (F r -> r) -> r)
10:26:35 <FreeFull> Yeah, it is
10:26:43 <FreeFull> > either Left Right (Left "Foo")
10:26:45 <lambdabot>  Left "Foo"
10:26:59 <skypers> c_wraith: so catamorphisms look like Foldable, right?
10:27:50 <jmcarthur> skypers: catamorphisms are a bit more general. Foldable basically just captures natural transformations targeting []
10:28:05 <c_wraith> skypers: I think Foldable is slightly less general.  and I guess jmcarthur agrees with me
10:28:27 <c_wraith> skypers: you can think of catamorphisms as a generalization of destructors for a data type.
10:28:45 <jmcarthur> skypers: consider the type:    data Tree a = Branch (Tree a) a (Tree a) | Empty
10:28:52 <FreeFull> Foldable is definitely less general
10:29:03 <jmcarthur> skypers: Foldable basically just lets you turn that into a list
10:29:15 <c_wraith> skypers: are you familiar with Church-encoding data types?
10:29:23 <jmcarthur> skypers: but its catamorphism would be more like    foldTree :: (r -> a -> r -> r) -> r -> Tree a -> r
10:29:26 <skypers> jmcarthur: huh?
10:29:31 <skypers> to list?
10:29:35 <skypers> no, to a monoid
10:29:43 <c_wraith> skypers: and lists are the free monoid
10:29:48 <jmcarthur> skypers: list is a free monoid
10:29:50 <skypers> hence the foldMap
10:29:52 <c_wraith> skypers: that is, exactly the equivalent
10:30:00 <skypers> what do you call a “free” monoid?
10:30:08 <skypers> every monoid is a list?
10:30:09 <jmcarthur> skypers: fold, foldMap, toList, foldr... all are equivalently powerful
10:30:46 <jle`> it's a free monoid in the way Free is the free monad
10:30:56 <c_wraith> skypers: you can convert any monoidal operation to a foldr over the list you get
10:31:04 <jle`> minimal definition of operations that guarantees to satisfy the laws
10:31:26 <jmcarthur> skypers: toList just associates all the mappends to the right. fold and foldMap will typically keep them associated the way the original structure would have them. however, since monoids are associative, this is equivalent
10:31:48 <c_wraith> skypers: look at the type jmcarthur gave for foldTree.  It doesn't require associativity in the function.  Therefore, it's not required to be monoidal.
10:32:36 <skypers> hm
10:32:53 <jmcarthur> skypers: to be more precise, it should always be the case that    foldr mappend mempty . toList = fold
10:32:53 <skypers> data Tree a = Branch (Tree a) a (Tree  a) | Empty
10:33:44 <jmcarthur> and...
10:33:51 <olalonde> I'm trying to define alphabet in ghci this way: alphabet = "abcdefghijklmnopqrstuvwxyz" but there is a parse error on input `='
10:33:56 <olalonde> I"m not allowed to do that?
10:33:57 <jmcarthur> @free F.toList
10:33:57 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
10:34:01 <skypers> I have some difficulties to understand your “free” stuff
10:34:05 <jmcarthur> i knew i'd get that wrong
10:34:16 <FreeFull> olalonde: ghci behaves like you're in a monad's do block
10:34:21 <skypers> I understand it as “the minimal structure that satisfies some law”
10:34:27 <FreeFull> So do     let alphabet = something
10:34:33 <ReinH> jle`: well no, it's a free monoid in the way free is a free monad: it's constructed by a functor that is left-adjoint to a forgetful functor.
10:34:35 <skypers> but I don’t understand “free list”
10:34:37 <olalonde> ah, I haven't reached monads yet.. just beginning :P
10:35:01 <jmcarthur> skypers: who said "free list"?
10:35:08 <c_wraith> skypers: put another way, you can always create an identity catamorphism.  You can't create an identity operation for all instances of Foldable using the Foldable interface. The only one that you can create an identity operation for is []
10:35:15 <FreeFull> olalonde: Follow "Learn you a Haskell" and you'll be fine
10:35:18 <skypers> jmcarthur: just above
10:35:35 <jmcarthur> skypers: free monoid?
10:35:46 <olalonde> FreeFull: yes I'm reading it right now.. actually I was trying to implement a casesar cipher : https://gist.github.com/11262866
10:36:06 <olalonde> just started 1 hour ago so I guess it's pretty ugly but I'd like to know why I'm getting an error
10:36:15 <FreeFull> You'll need the let
10:36:25 <FreeFull> Or just write your code into a file and load that in ghci
10:36:27 <jmcarthur> skypers: to elaborate one what c_wraith just said:   foldTree Branch Empty = id
10:36:31 <jmcarthur> *on
10:36:51 <FreeFull> olalonde: Yeah, if you just copy-paste what you have there into ghci, it won't work, but putting it into a file will
10:37:10 * hackagebot codex 0.0.1.0 - Code Explorer for Cabal  http://hackage.haskell.org/package/codex-0.0.1.0 (aloiscochard)
10:37:16 <c_wraith> jmcarthur: is a catamorphism always the church encoding of the type?
10:37:24 <skypers> jmcarthur: a free monoid would be a structure that satisfies the monoid laws, right?
10:37:27 <ReinH> olalonde: ghci is in a special context that is similar to an IO do block
10:37:28 <jmcarthur> c_wraith: i believe so, yes
10:37:37 <jmcarthur> skypers: yes
10:37:38 <skypers> hence, that can build any other monoids
10:37:41 <jmcarthur> well
10:37:43 <jmcarthur> no
10:37:46 <olalonde> FreeFull: ok cool. actually I tried that as well but getting a different errror :P still related to alphabet.. Couldn't match expected type `Char' with actual type `Int' In the return type of a call of `length'
10:37:48 <jmcarthur> it's just *a* monoid
10:37:59 <ReinH> skypers: a free monoid, being a monoid, satisfies the monoid laws.
10:38:02 <skypers> jmcarthur: so why you said *the* free monoid?
10:38:09 <jmcarthur> i didn't
10:38:15 <jmcarthur> i said *a* free monoid
10:38:21 <skypers> 19:28 < c_wraith> skypers: and lists are the free monoid
10:38:25 <skypers> it was c_wraith
10:38:27 <FreeFull> olalonde: That error is in the cipher function
10:38:33 <c_wraith> Yes, I did say that.
10:38:41 <c_wraith> I may have been slightly off.
10:38:46 <skypers> ok
10:38:47 <jmcarthur> there are other free monoids, but they are all isomorphic to lists
10:38:55 <skypers> like Maybe?
10:38:56 <jmcarthur> so that is why some say it is "the" free monoid
10:38:58 <c_wraith> It's not too useful distinguishing between different free monoids though, since they all can be interconverted
10:39:01 <ReinH> skypers: Maybe is not a free monoid.
10:39:03 <jmcarthur> Maybe is not a free monoid
10:39:09 <skypers> why?
10:39:27 <FreeFull> Lists and anything isomorphic to them are free monoids
10:39:32 <skypers> it has too much stuff to be “minimal”?
10:39:33 <olalonde> FreeFull: Couldn't match expected type `Char' with actual type `Int'.. this means that length alphabet returns an Int but a char was expected? doesn't `mod` expect an Int?
10:39:34 <shachaf> jmcarthur: It's not even the right kind. :-)
10:39:37 <c_wraith> Unlike different free monads, which are not always isomorphic to each other.
10:39:39 <shachaf> But Maybe Void is a free monoid.
10:39:57 <shachaf> c_wraith: ?
10:40:02 <skypers> wait why Maybe is not a free monoid?
10:40:07 <skypers> isn’t it minimal?
10:40:11 <FreeFull> olalonde: Mod expects the same type for both sides
10:40:15 <skypers> what’s extra?
10:40:17 <ReinH> skypers: "free" does not mean "minimal"
10:40:26 <olalonde> FreeFull: ahh ok.. so maybe the other side returns a char :O
10:40:28 <c_wraith> shachaf: Free [] and Free Maybe are both free monads, but they aren't isomorphic
10:40:30 <skypers> ReinH: to me it means “no redundance”
10:40:47 <ReinH> skypers: then you should throw that definition away and learn the correct one.
10:40:51 <FreeFull> olalonde: The bracketing is a bit confusing
10:40:57 <bennofs> is this type together with the monoid instance defined somewhere already? data EndoKleisli m a = EndoKleisli (a -> m a)
10:41:07 <olalonde> right
10:41:18 <jmcarthur> a free monoid can syntactically express exactly the things you can express with a monoid, and nothing else.
10:41:19 <c_wraith> bennofs: doesn't look familiar.
10:41:19 <shachaf> c_wraith: Oh, well, if you choose that interpretation, that's not unlike free monoids.
10:41:21 <bennofs> mempty would be EndoKleisli return, mappend would be >=>
10:41:26 <FreeFull> I think you're missing an extra set of brackets
10:41:29 <skypers> jmcarthur: yeah
10:41:34 <skypers> so it’s what I thought so
10:41:34 <martijnK> Hi all, beginner here; I’m (still) looking for the proper/best way to model and handle persistence of relational data (as well as querying it). Suppose I have a test system (test -> questions -> answer possibilitites and testsession > answers), then modelling it like a datatype and storing it seems like a hassle (have to make own ID’s and maintain my own many to many relations?) going “back” to writing my own sql and doing
10:41:35 <shachaf> c_wraith: [Int] and [Void] aren't isomorphic either.
10:41:35 <martijnK> toDataType (or something) feels wrong…. :<
10:41:37 <skypers> it’s like vector space
10:41:37 <olalonde> FreeFull: oh.. that was the problem actually, thanks :p
10:41:41 <c_wraith> shachaf: I see
10:41:53 <FreeFull> olalonde: Found it yourself? =P
10:42:02 <shachaf> c_wraith: But [()] and Nat are both free monoids on (), and isomorphic.
10:42:08 <olalonde> FreeFull: well, after you mentioned the bracketing was confusing hehe
10:42:17 <mm_freak> hi there
10:42:20 <skypers> I just don’t get why Maybe doesn’t fit that definition
10:42:59 <FreeFull> [a] is a monoid for all a
10:43:16 <mm_freak> is there a low-level (sample-level) cross-platform, cross-target audio library?  it should probably support ALSA and windows at the very least
10:43:18 <FreeFull> The monoid part doesn't care about the a
10:43:21 <ReinH> skypers: first, Maybe cannot be a monoid. `Maybe a' could be a monoid
10:43:34 <skypers> ReinH: yeah, it’s what I meant…
10:43:40 <ReinH> But `Maybe a' cannot be a monoid for all a.
10:43:49 <skypers> oh
10:43:52 <skypers> ok
10:44:06 <shachaf> Yes it could
10:44:07 <jmcarthur> ReinH: yes it can. but this isn't the reason it's not a free monoid
10:44:15 <skypers> but hm
10:44:17 <FreeFull> Maybe a is only a monoid if a is a Semiring
10:44:18 <ReinH> jmcarthur: it can't without introducing another equation
10:44:21 <skypers> (Monoid a) => Maybe a
10:44:23 <skypers> is this a free monoid?
10:44:24 <ReinH> FreeFull: semigroup
10:44:25 <jmcarthur> take First and Last as examples of monoids for Maybe a, no matter what a is
10:44:25 <jle`> Maybe a can be a monoid
10:44:29 <FreeFull> Semigroup, sorry
10:44:31 <jle`> First and last, yeah
10:44:45 <FreeFull> Definitely not semiring
10:44:59 <jle`> or even the Applicativey definition, where Nothing dominates
10:45:11 <ReinH> jmcarthur: you beat me to the part where I said "without introducing an equation other than those that follow from the monoid laws"
10:45:21 <ReinH> You *can* construct a monoid from any semiring.
10:45:27 <ReinH> By forgetting about one of the monoids.
10:45:31 <skypers> ReinH: (Monoid a) => Maybe a, this would be a free monoid right?
10:46:01 * mm_freak is working on an FRP OpenAL replacement, and he'd like to replace ALSA by something cross-target =)
10:46:05 <ReinH> the functor from semiring to monoid is forgetful, not free :)
10:46:28 <fizruk> skypers: frer monoid over a set S is such a structure that allows to “combine” elements of S first and decide how to “execute” mempty and mappend later
10:46:36 <fizruk> *free
10:46:59 <skypers> fizruk: as I always understood free stuff
10:47:27 <jmcarthur> skypers: here's a decent test for whether A is a free monoid. can you convert an A to a (forall a. Monoid a => a) and then convert it back to an A such that the final A is the same as the original A?
10:47:28 <skypers> I thought it was “something that satisfies laws with nothing extra required but the structure concerned by the laws”
10:47:28 <fizruk> skypers: so how do you combine Just 1 and Just 2 and then use Sum monoid for Ints?
10:47:53 <skypers> fizruk: yeah I got it
10:47:54 <skypers> but hm
10:48:03 <skypers> (Monoid a) => Maybe a is a free monoid
10:48:09 <skypers> because it doesn’t care about the a
10:48:16 <jle`> i wonder if with the new applicative/monad thing, Pure would be removed from Free
10:48:20 <fizruk> skypers: it does
10:48:24 <skypers> huh
10:48:26 <fizruk> skypers: it has to be Monoid
10:48:36 <skypers> so it’s not a free monoid?
10:48:43 <fizruk> skypers: so Maybe a could borrow it’s structure
10:48:48 <ReinH> skypers: (Monoid a) => Monoid (Maybe a) maps a monoid to a monoid.
10:49:14 <skypers> hm
10:49:15 <skypers> ok
10:49:27 <skypers> I still have tough issues to get what free is
10:49:27 <fizruk> skypers: you can see (Semigroup a) => Maybe a as a free structure that adds mempty
10:49:30 <skypers> for instance a free functor
10:49:38 <skypers> list is a free functor?
10:49:49 <skypers> because it doesn’t give a damn about what the list is?
10:49:51 <ReinH> skypers: Semigroup a => Monoid (Maybe a) constructs a free monoid over some semigroup a
10:50:03 <jmcarthur> skypers: similarly, you can tell whether M is a free monad by this test: can you write a function (f :: Monad m => M a -> m a) and a function (g :: (forall m. Monad m => m a) -> M a) such that g and f are inverses?
10:50:07 <fizruk> skypers: something like that
10:50:55 <jmcarthur> skypers: Monoid a => Maybe a is only a free monoid if you can show that it is isomorphic to   (forall a. Monoid a => a)
10:51:43 <skypers> ok
10:51:45 <skypers> got it jmcarthur
10:51:49 <shachaf> (forall a. Monoid a => a) ~~ () ?
10:52:17 <skypers> all that from catamorphisms :)
10:52:21 <skypers> now, anamorphisms!
10:52:22 <skypers> ahah
10:52:32 <skypers> sounds to be a generalization of unfolds
10:52:33 <shachaf> Maybe you mean (forall r. Monoid r => (a -> r) -> r) or something along those lines?
10:52:42 <jmcarthur> maybe i didn't think hard enough
10:52:50 <ReinH> skypers: what jmcarthur is talking about is the fact that a free object is formed via an adjunction, which means (iinm) that [a] is a free object over a iff there is a functor F : a -> [a] and a functor G : [a] -> a and F . G = id :: a -> a and G . F = id :: [a] -> [a]. This is where shachaf should correct me if I have misspoken. :)
10:53:12 <skypers> a iff?
10:53:16 <ReinH> if and only if
10:53:19 <skypers> ok
10:53:26 <skypers> english weirdness
10:53:26 <skypers> :)
10:53:30 <ReinH> math weirdness :)
10:53:32 <shachaf> ReinH: No thanks. I'm not a "let me say wrong things service".
10:53:40 * ReinH sighs
10:53:45 <jmcarthur> shachaf: it's not isomorphic to () because i can extract whatever mappends and memptys were used to construct it
10:53:49 <osa1_> "[ERROR] /home/omer/.cabal/share/hakyll-4.2.2.0/templates/atom.xml: openFile: does not exist" apparently my statically linked hakyll blog generator was depending on some other files :-) can anyone provide me that file?
10:53:53 <jmcarthur> shachaf: whereas () doesn't give me access to them
10:53:54 <ReinH> here we go again
10:54:00 <shachaf> jmcarthur: But you don't know what a is.
10:54:05 <jmcarthur> i don't need to
10:54:07 <jmcarthur> i get to choose
10:54:13 <shachaf> jmcarthur: Oh, you mean if you make an invalid Monoid instance?
10:54:14 <ReinH> shachaf: that was me letting you know that if you wanted to correct me it would be ok.
10:54:17 <skypers> ReinH: what you said
10:54:26 <skypers> about [a] -> a and a -> [a] and G . F = id
10:54:27 <jmcarthur> shachaf: it can be valid
10:54:33 <jmcarthur> shachaf: (should be)
10:54:33 <skypers> isn’t the def of in isomorphism?
10:54:40 <ReinH> shachaf: not that I demand it or anything
10:54:46 <shachaf> jmcarthur: If all Monoid instances are valid, then I think (forall a. Monoid a => a) ~~ ()
10:54:50 <jmcarthur> shachaf: if it's a valid monoid instance then i just can't tell which way the mappends were associated, which is fine
10:54:53 <shachaf> The only thing you can mappend is memptys.
10:54:56 <skypers> well no
10:55:02 <skypers> isomorphism preserve structure
10:55:04 <jmcarthur> shachaf: i can still get something like peano numerals out of it
10:55:05 <skypers> [a] -> a doesn’t
10:55:05 <skypers> ok
10:55:08 <shachaf> You don't have any other "a" values.
10:55:11 <shachaf> How?
10:55:13 <FreeFull> data Id x = Id { unId : x }  should be a free object
10:55:24 <jmcarthur> shachaf: mappend = (+); mempty = Z
10:55:31 <shachaf> I'm confused.
10:55:44 <skypers> so you can say that something free works forall objects?
10:55:45 <shachaf> newtype M = M (forall a. Monoid a => a)
10:55:50 <shachaf> How can you distinguish M values?
10:56:07 <jmcarthur> i can convert them to peano numerals and distinguish them
10:56:20 <jmcarthur> or any other free monoid
10:56:23 <shachaf> How?
10:56:24 <ReinH> skypers: G : [a] -> a is a forgetful functor because it forgets the extra structure
10:56:24 <FreeFull> How do you convert them?
10:56:27 <jmcarthur> i'll write the code
10:56:54 <ReinH> skypers: F : a - [a] is a free functor. All free functors are left-adjoint to a forgetful functor. The free functor "remembers" exactly what the forgetful functor forgets. No more, no less.
10:57:06 <ReinH> s/-/->
10:57:13 <jle`> heh
10:57:19 <jle`> i didn't know there was an implicit /g
10:57:23 <skypers> ReinH: forgetful, ok, what’s the heck is that again :D
10:57:33 <skypers> it’s something that drops down a category?
10:57:38 <skypers> s/something/a functor
10:57:42 <skypers> C a -> b
10:57:43 <skypers> ?
10:57:46 <ReinH> skypers: and I suppose for clarity I should say that [a[ is actually the tuple ([a],[],(++)) that defines the monoid structure
10:58:04 <ReinH> skypers: no, both are categories
10:58:14 <skypers> :(
10:58:21 <jmcarthur> shachaf: http://lpaste.net/103163
10:58:39 <Twey> Fuuzetsu: http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Typeable.html — what's going on with the kinds here?
10:59:02 <ReinH> skypers: let's talk about some set A instead of some type a.
10:59:18 <jmcarthur> shachaf: i guess i could also write the conversion the other way
10:59:20 <shachaf> jmcarthur: I don't quite follow. How do you distinguish two M values?
10:59:31 <skypers> ReinH: oooh
10:59:32 <skypers> ok
10:59:33 <skypers> got it
11:00:02 <skypers> [a] -> a is a forgetful functor because it drops the structure of list?
11:00:30 <ReinH> skypers: and [] and (++)
11:00:37 <skypers> ReinH: yes
11:00:41 <skypers> that’s what I implied
11:00:48 <ReinH> and what it forgets are precisely the things you need to add to A to get a monoid.
11:00:51 <skypers> any list-related stuff
11:01:03 <monochrom> jmcarthur: my question would be: is there x such that mToNat x = Succ Zero? is there a constructive proof?
11:01:08 <shachaf> Can you make an M value x such that mToNat x /= Zero?
11:01:12 <jmcarthur> shachaf: oh, i am a fool
11:01:18 <monochrom> \∩/
11:01:21 <olalonde> when does indentation matter in haskell?
11:01:26 <ReinH> skypers: what jmcarthur was showing you is that if you can't construct the left-adjoint and show that the identities hold, you don't have a forgetful functor
11:01:36 <jmcarthur> ignore that last fifteen minutes of me
11:01:38 <skypers> left-adjoint
11:01:39 <skypers> dammit
11:01:45 <skypers> I’m seriously bad in math…
11:01:58 <ReinH> skypers: the forgetful functor from the free monoid over A back to A
11:02:27 <monochrom> I am a forgetful functor. I keep forgetting whether it's left or right. :)
11:02:41 <ReinH> monochrom: I had to look it up :)
11:02:45 <shachaf> jmcarthur: I think (forall r. Monoid r => (a -> r) -> r) is what you were going for.
11:02:53 <jmcarthur> shachaf: i also think so
11:03:05 <skypers> I read the wiki page of adjunction in categories
11:03:09 <shachaf> (Since that type is a free monoid.)
11:03:11 <skypers> I understand nothing.
11:03:12 <skypers> :D
11:03:21 <skypers> it’s way too hard to me to get it now
11:03:41 <ReinH> monochrom: free -| forgetful, write it 100 times. ;)
11:04:15 <ReinH> skypers: the wikipedia page uses the Hom isomorphism definition. The natural transformation definition is easier imo.
11:04:22 <skypers> yeah
11:04:23 <monochrom> I will never forget to bring free -| forgetful to class again.
11:04:24 <skypers> nevermind
11:04:30 <skypers> I’ll try to understand that later
11:04:32 <skypers> way too hard right now
11:04:34 <skypers> thank you anyway
11:04:37 <monochrom> I will never forget to bring free -| forgetful to class again.
11:04:38 <monochrom> ...
11:05:47 <ReinH> monochrom: heh :)
11:14:37 <joseph07> Aww lens bashing on reddit
11:15:03 * monochrom does reddit bashing on irc
11:15:04 <ReinH> joseph07: eh
11:15:10 <monochrom> don't read reddit
11:15:40 <joseph07> monochrom: what should I read?
11:15:45 <ajf> OK, a wee problem. I’ve done getDirectoryContents to get a listing of files in a directory. However, I need the absolute paths of those files. Should I just do dirname ++ “/“ ++ name?
11:15:48 <tdammers> read /r/popping
11:15:51 <ReinH> The lens bashing is actually occuring here http://ro-che.info/articles/2014-04-24-lens-unidiomatic.html
11:15:52 <tdammers> best of reddit
11:15:53 <monochrom> if humanity pooled collective effort to avoid reddit, it will be less awful
11:15:54 <ajf> for each name in the list
11:16:00 <ReinH> Which isn't so much "bashing" as "a reasoned critique"
11:16:05 <monochrom> you should read nothing.
11:16:36 <monochrom> I read nothing
11:16:45 <thrakcattack> ajf: getDirectoryContents path >>= mapM canonicalizePath
11:16:58 <ajf> thrakcattack: canonicalizePath won’t work
11:17:04 <thrakcattack> why
11:17:06 <ajf> since these files aren’t in the same directory
11:17:11 <ajf> they’re in a different directory
11:17:34 <ajf> er, the dir I’m listing isn’t necessarily the dir I’m running the program from, is what I mean
11:17:48 <ReinH> Most criticisms of lens that I've seen fall into basically one camp: "I don't understand the types."
11:17:49 <thrakcattack> oh
11:17:59 <ReinH> Which is a fair, if not very actionable, criticism
11:18:30 <olalonde> I've defined "data MetricUnit = Meter | Liter | KiloGram" in MyData.hs and run ghci MyData.hs.. when I type :type Meter ,it says <interactive>:1:1: Not in scope: data constructor `Meter'
11:18:53 <ReinH> olalonde: what does your module clause look like?
11:19:47 <monochrom> ajf: "dirname </> name" is always right. </> comes from System.Filepath
11:20:15 <ajf> ooh
11:20:21 <ajf> is that a path addition operator? :)
11:20:24 <monochrom> yes
11:20:37 <monochrom> it does "/" for linux, "\" for windows
11:20:38 <ajf> Ah! Like Python’s os.path.join, then
11:20:40 <olalonde> oops, it was a typo nevermind! ReinH
11:20:51 <joseph07> ajf: something like fmap (path </>) <$> getDirectoryContents path
11:20:54 <ajf> monochrom: Funny that, considering / is valid on Windows and always has been. But consistency is preferred
11:21:14 <monochrom> that's also true
11:21:29 <geekosaur> needs an extra map in there, I believe
11:21:42 <ajf> Also, what does >>= do?
11:22:02 <matheus23> ajf: do you know the do notation?
11:22:03 <monochrom> it chains I/O actions
11:22:14 <ajf> monochrom: Ah
11:22:21 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml#bind
11:22:24 <ajf> paths <- getDirectoryContents directory >>= mapM (\path -> directory </> path)
11:22:30 <ajf> Any idea why that doesn’t work?
11:22:57 <thrakcattack> ajf: omit the "paths <-"
11:22:59 <matheus23> do sth <- getString; putStrLn sth is desugared into getString >>= (\sth -> putStrLn sth)
11:23:00 <ajf> hey, I should just do (directory </>) there, no need for a lambda
11:23:16 <ajf> thrakcattack: how do I assign it somewhere, then?
11:23:35 <thrakcattack> ajf: with >>=
11:23:39 <joseph07> ajf: (>>=) chains monadic actions, but (</>) is a nonmonadic function
11:23:39 <monochrom> ok, show a self-contained reproducible experiment
11:24:13 <ajf> Oh, right, silly me
11:24:20 <thrakcattack> ajf: nvm
11:25:53 <matheus23> Key events are not sent to my Gtk widget. Why? Do I need some extra focus code? MousePress events work
11:26:02 <matheus23> my widget is a DrawingArea
11:26:31 <ajf> Hmm, so
11:27:18 <ajf> this works: paths <- getDirectoryContents directory; let paths2 = map (directory </>) paths
11:27:24 <ajf> But how can I skip that extra variable?
11:27:57 <joseph07> ajf: if you're comfortable with functors you can do paths <- fmap (directory </>) <$> getDirectoryContents directory
11:28:09 <joseph07> ajf: the (<$>) is actually another fmap
11:28:20 <monochrom> paths2 <- map (directory </>) <$> getDirectoryContents directory
11:28:25 <FOOD_> anyone know the magic answer for well-supported sound output library/bindings for haskell
11:28:30 <ajf> I… see
11:28:34 <FOOD_> csound?
11:28:40 <ajf> I think I understand that
11:28:41 <thrakcattack> ajf: or use getDirectoryContents path >>= return $ map (directory </>)
11:29:08 <joseph07> ajf: One fmap to apply your function inside an IO action, another fmap to apply within a list
11:29:14 <monochrom> um, you need . there instead of $
11:29:37 <thrakcattack> monochrom: ah ok
11:30:12 <ajf> Where’s <$> from?
11:30:18 <monochrom> Control.Applicative
11:30:30 <monochrom> hmm, it may also be available elsewhere
11:30:37 <ajf> OK, now it compiles
11:30:45 <ajf> It works!
11:30:48 <ajf> Thank you all :)
11:30:53 <monochrom> Data.Functor is better
11:31:07 <ajf> I should really qualify these imports to make it clear why I need them
11:31:12 <ajf> would reduce namespace pollution too
11:31:21 <ajf> anyhow, I’m away for a while. Thanks a bunch
11:32:32 <joseph07> :t fmap . fmap
11:32:33 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
11:35:14 <vermeille> :t fmap fmap
11:35:15 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
11:35:32 <shergill> how is it that the dual of a functor is a functor?
11:35:32 <shergill> could someone elaborate?
11:36:51 <shergill> pointers to what is meant by dual in that context, in a manner understandable by a CT noob would be appreciated
11:41:02 <ReinH> monochrom: it's from Data.Functor unless you think you're going to want <*>, in which case it's from Control.Applicative. ;)
11:41:12 <ReinH> shergill: A functor is a mapping from a category to a category
11:41:16 <monochrom> yeah
11:41:19 <ReinH> shergill: The dual of something is that thing with its arrows reversed.
11:41:30 <ReinH> shergill: if you reverse the arrow, you get a mapping from a category to a category.
11:43:51 <shergill> ReinH: right ok that seems trivially true. i was thinking something where cofmap :: f a -> f b -> a -> b
11:44:58 <ReinH> shergill: there are "cofunctors", which are contravariant, not dual in the usual sense that a coX is the dual of X.
11:45:11 <ReinH> they are more properly called contravariant functors anyway
11:45:39 <shergill> ReinH: right, but that's where you have a -> b -> f b -> f a
11:45:44 <shergill> what i have is different still
11:47:52 <ReinH> (the "co" there probably traces back to some older algebraic thing. Algebraic topology? I'm not sure)
11:49:42 <monochrom> every time there is an involution A->A, people say "co" or "dual" or "inverse" or "opposite" without foresight of how many other important involutions there will be for A->A
11:50:10 <monochrom> therefore by the time you have 4 important involutions A->A, you will find that they are all named wrong.
11:50:14 <ReinH> heh
11:51:30 <shergill> so what would you call the thing where you'd have that unmap like operation? it seems odd that people wouldn't have considered it
11:53:36 <miguel_> I'm trying to use filter but I keep getting this weird error : http://pastebin.com/kgDsCQXB
11:54:02 <fizruk> :t filter
11:54:03 <lambdabot> (a -> Bool) -> [a] -> [a]
11:54:20 <fizruk> miguel_: filter returns a list, not list of lists
11:54:22 <monochrom> why is it not simply sieb p subjects = filter p subjects?
11:54:43 <miguel_> yeah, I kinda commented out the rest of the code
11:55:37 <miguel_> full code: http://pastebin.com/XPqXhVWG
11:55:56 <monochrom> replace ++ by :
11:56:09 <miguel_> wtf
11:56:22 <joseph07> :t (:)
11:56:23 <lambdabot> a -> [a] -> [a]
11:56:24 <miguel_> I tried it b4 with literal values and : didnt work
11:56:30 <miguel_> but ++ worked, thats why I used ++
11:56:38 <miguel_> :t (++)
11:56:39 <lambdabot> [a] -> [a] -> [a]
11:56:43 <miguel_> ahh
11:56:47 <monochrom> clearly, ++ breaks now
11:57:19 <miguel_> thx =)
11:57:39 <monochrom> therefore, you used wrong literal values previously
11:57:42 <mniip> So
11:57:50 <joseph07> :t partition
11:57:51 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
11:58:06 <monochrom> distrust everyone. in particular, distrust yourself.
11:58:27 <mniip> What this does is just group elements by which function did they match first?
11:59:11 <monochrom> > partition even [3,1,4,1,5,9]
11:59:12 <lambdabot>  ([4],[3,1,1,5,9])
11:59:46 <mm_freak> hi again
11:59:51 <monochrom> yeah, looks like it, mniip
11:59:54 * fizruk just read monochrom as “destruct everyone. in particular destruct yourself”
12:00:23 <monochrom> I also condone that :)
12:00:23 <mm_freak> edwardk: the Storable instances for V* in 'linear' are all x, then y, then z…  is this going to stay the way it is?
12:00:46 <miguel_> yeah, it filters the elements
12:01:54 <mm_freak> edwardk: background: i'm going to use e.g. 'Vector (V2 Float)' for interleaved stereo audio samples, and a change in this ordering would have dramatic effects =)
12:02:15 <mniip> "disgust everyone; in particular, disgust yourself"
12:02:27 <k_89> how do i compile and run a single .hs file ?
12:02:45 <mm_freak> k_89: since GHC 7.6:  ghc -O -o blah blah.hs
12:02:45 <k_89> i can compile it, i get the .hi, and .o files, but what should i do with them ?
12:02:53 <k_89> ok
12:03:07 <mm_freak> k_89: in earlier GHCs you need to add the --make flag
12:03:33 <monochrom> actually even "-o blah" can be omitted
12:03:46 <monochrom> the executable is called "blah" or "blah.exe". find it.
12:03:48 <mm_freak> k_89: you can also use the interpreter:  runhaskell blah.hs
12:04:04 <mm_freak> monochrom: i guess i'm still gcc-damaged =)
12:04:06 <k_89> i don't get an interpreter
12:04:11 <k_89> eh
12:04:18 <k_89> i don't get an executable
12:04:25 <monochrom> well, I wouldn't say gcc's convention is wrong either
12:04:29 <k_89> again, i get the .hi, and .o files
12:04:30 <mm_freak> k_89: what's your exact command line?
12:04:31 <stolaruk> Is there any way to catch "SomeException" and test to see what kind of specific exception is encapsulated by the "SomeException"?
12:04:39 <k_89> ghc -O ls.hs
12:04:51 <mm_freak> k_89: which GHC version?
12:04:57 <mm_freak> (ghc --version)
12:04:58 <k_89> 7.6.3
12:05:00 <monochrom> ls? call it something else, just for the sake of avoiding name clash
12:05:14 <joseph07> k_89: do you have a non-main module name?
12:05:19 <mm_freak> k_89: if you're on unix/linux, make sure to type "./ls", not just "ls"
12:05:24 <k_89> joseph07, yes
12:05:33 <k_89> changing it to main
12:05:44 <joseph07> k_89: *Main
12:05:54 <mm_freak> k_89: the main module has to be called Main, even if it doesn't reflect its file name
12:05:55 <monochrom> capital M
12:06:05 <k_89> mm_freak, yeah, i am just implementing linux file-system utils to get a hang of interacting with the env in haskell
12:06:15 * monochrom hates case-insensitive programmers
12:06:20 <k_89> joseph07, yes, naming it Main :P
12:06:43 * monochrom hates case-insensitive math students too, but that's for ##math
12:07:14 <k_89> yup that works
12:07:16 <k_89> thanks
12:07:22 <joseph07> monochrom: I'll try to be more sensitive
12:07:59 <mm_freak> k_89: at some point you'll probably use cabal and all this low-level details will go away =)
12:08:05 <mm_freak> these
12:08:27 <k_89> still, i kinda feel the need to just "go through" this stuff
12:09:03 <mm_freak> k_89: probably a good idea, although i think i haven't typed "ghc" for years
12:09:30 <mm_freak> oh, i have…  "ghc --version" says my shell history =)
12:09:41 <monochrom> that doesn't count :)
12:13:02 <WraithM> For sending email via SMTP, what package do people use? I see smtp-mail and SMTPClient. Has anybody used one of these or prefer one over the other?
12:13:47 <mm_freak> WraithM: there is also HaskellNet…  pick the library that, according to its version history and latest release, seems most maintained
12:15:10 <mm_freak> WraithM: also in many cases it may be best to use the system MTA
12:15:17 <mm_freak> i.e. use the 'sendmail' command
12:15:25 <WraithM> Right, true.
12:15:47 <WraithM> I guess I want the code to be fairly portable, hence not using sendmail.
12:15:59 <WraithM> Thanks!
12:16:19 <WraithM> I'm not familiar with HaskellNet though. Have you used it?
12:16:21 <mm_freak> mail handling is difficult to get portable, even in haskell =)
12:16:33 <mm_freak> yes, briefly, but it's a while ago
12:16:37 <WraithM> Very true :)
12:17:50 <mm_freak> i suggest using sendmail anyway…  there are sendmails for pretty much any operating system
12:18:48 <mm_freak> to make the decision easier, you could do whatever yesod does
12:19:01 <mm_freak> their authentication system is capable of sending mails
12:19:37 <mm_freak> it's not necessarily the best choice, but at least you can count on it being maintained for a long time =)
12:19:55 <orion> Do people usually use the haskell serialization modules as a way of defining a network protocol, or is that bad practice?
12:20:21 <orion> By "network protocol" I mean something which allows two haskell applications to talk to one another over, say, TCP.
12:20:26 <edwardk> mm_freak: i have no intention currently of changing the order or any idea how one could viably do so ;)
12:20:58 <Javran> is "type Bin a b = a -> a -> b" a valid instance of Profunctor?
12:21:04 <tippenein> What am I doing wrong here? rot13 just takes a string and does what you'd think with it.   ---  putStrLn $ foldl ((++) . rot13) '\n' =<< getArgs
12:21:26 <FreeFull> Javran: I think it would be
12:21:36 <FreeFull> Although you need to make it into newtype/data to make an instance
12:21:56 <threestrikes> ahhh this strict type stuff is killing me
12:22:03 <threestrikes> I can't wrap my head around it
12:22:07 <threestrikes> nothing works lol
12:22:09 <mm_freak> edwardk: could it be a bad idea to rely on this ordering?
12:22:36 <geekosaur> tippenin, at least two things wrong with that: (=<<) in this case produces an IO whatever that putStrLn does not accept, and the foldl does not produce an IO whatever
12:22:49 <Javran> FreeFull: yeah, I don't find a default impl in Data.Profunctor, but it's easy to make one
12:22:51 <edwardk> mm_freak: i think you're fine
12:23:05 <matheus23> fizbin: (are you fizruk?) It's finally up: https://github.com/matheus23/DeclarativeWidgets
12:23:06 <FreeFull> Javran: It's similar to a -> b
12:23:15 <edwardk> mm_freak: and knowing i have a user gives me a great reason to push back if someone wants to
12:23:22 <tippenein> n/m, I just need to make it String rather than Char
12:23:25 <fizbin> matheus23: We are separate people.
12:23:31 <matheus23> okay
12:23:34 <fizbin> Many people confuse us.
12:23:35 <mm_freak> tippenein: use concat/unlines
12:23:40 <matheus23> really? :D
12:24:05 <mm_freak> edwardk: ok, great…  thanks
12:24:27 <Javran> FreeFull: yes, they have made "(->)" a profunctor
12:24:35 <tippenein> although I'd like to preserve a space between the args
12:25:01 <mm_freak> oops
12:25:17 <mm_freak> edwardk: does V have a compact representation as well?
12:25:26 <mm_freak> memory representation that is
12:25:41 <edwardk> mm_freak: in memory its  bunch of unboxed values
12:25:52 <solrize> :k Product
12:25:53 <lambdabot> * -> *
12:25:57 <eizo> did anyone encounter this definition in the context of haskell? http://i.imgur.com/IHOzVPp.png
12:26:00 <solrize> > Product 3 <> Product 5
12:26:02 <lambdabot>  Product {getProduct = 15}
12:26:02 <edwardk> mm_freak: you could easily make a Storable instance for it
12:26:07 <edwardk> if it is somehow missing
12:26:10 <solrize> > Product "foo" <> Product "bar"
12:26:11 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
12:26:11 <lambdabot>    arising from a use of ‘Data.Monoid.<>’
12:26:13 <mm_freak> edwardk: it is Storable already
12:26:22 <solrize> why does Product not have a Num constraint?
12:26:51 <edwardk> solrize: why should it make you pass a dictionary for an instance you don't use?
12:26:54 <threestrikes> how does everyone else here traverse the strict type universe,  I"m sooo lost.
12:27:24 <mm_freak> threestrikes: we usually 'traverse' or 'fold'
12:27:26 <solrize> edwardk, well the idea of Product is to actually multiply stuff
12:27:28 <edwardk> solrize: its using it a a Monoid that needs its contents to be a Num.
12:27:32 <mm_freak> threestrikes: some people 'fix'
12:27:44 <Ankhers> threestrikes: What are you having issues with?
12:27:49 <threestrikes> lol
12:28:02 <tippenein> import Data.List (foldl)
12:28:08 <edwardk> solrize: until then nothing goes wrong without the constraint, but _with_ the constraint you can wind up in situations where you have to pick a concrete instance for a dictionary you never use, so type annotations have to be added for no reason
12:28:22 <Fuuzetsu> Twey: ?
12:28:33 <mm_freak> tippenein: btw, if you don't know whether to use foldl or foldl', in virtually every case you want foldl' =)
12:28:38 <tippenein> How would you keep the spaces between args while folding:  putStrLn $ foldl ((++) . rot13) "\n " args
12:28:56 <mm_freak> but in this particular case you probably want neither:  you want foldr
12:29:12 <ReinH> > unwords ["foo", "bar"]
12:29:14 <lambdabot>  "foo bar"
12:29:14 <tippenein> mm_freak: isn't that just for performance?
12:29:24 <solrize> edwardk, do you mean only the situation where you happen to never actually use mappend (which is sort of the point of a monoid)?
12:29:26 <miguel_> if I have a list of lists, is there a way to add an element to all sublists?
12:29:28 <tippenein> thanks ReinH
12:29:28 <mm_freak> tippenein: foldl' over foldl is for performance, both memory and time, yes
12:29:37 <Fuuzetsu> Twey: pester haasn about any kind display problems, he wrote that part (and we couldn't figure out good ways to show some stuff)
12:29:50 <mm_freak> tippenein: the semantics are slightly different, but irrelevant to pretty much every problem you would solve with a left-fold =)
12:29:59 <edwardk> solrize: consider  newtype Compose f g a = Compose (f (g a))    -- you could force it to be data (Functor f, Functor g) => Compose f g a = Compose (f (g a)) -- but now you can't compose things that are just Foldable, ven though they'd be otherwise fine
12:30:04 <threestrikes> trying to use different functions within libraries to see how they work but I'm afraid I don't understand enough to get anything to produce something that remotely looks like a test that I understand
12:30:06 <edwardk> solrize: these things happen a lot in practice
12:30:07 <tippenein> mm_freak: yah, I don't care about that here, but thanks. foldl' also requires an import which I'm not interested in
12:30:17 <ReinH> :t \a -> map (a :) -- miguel_
12:30:18 <edwardk> > sumOf both (1,2)
12:30:18 <lambdabot> a -> [[a]] -> [[a]]
12:30:19 <lambdabot>  3
12:30:20 <solrize> threestrikes, haskell doesn't really have strict or lazy types, it just has a strictness hack (seq) that the type system doesn't track
12:30:23 <edwardk> > sumOf _1 (1,2)
12:30:24 <lambdabot>  1
12:30:28 <edwardk> > sumOf _1 ("who cares",2)
12:30:30 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
12:30:30 <lambdabot>    arising from a use of ‘Control.Lens.Fold.sumOf’
12:30:30 <Twey> Fuuzetsu: I was confused by the weird placement of the selected kind in the instance list
12:30:33 <Ankhers> > map (++ "!") ["foo", "bar"]
12:30:35 <lambdabot>  ["foo!","bar!"]
12:30:40 <Twey> Fuuzetsu: Ah
12:30:43 <edwardk> oh, wait sumOf is strict now =)
12:30:47 <Ankhers> miguel_: ^^
12:30:50 <threestrikes> for example hasExtension
12:30:54 <mm_freak> solrize: in haskell 'seq' isn't actually a hack…  you can define it yourself
12:30:58 <ReinH> Ankhers: that's the pessimal way to add a single element
12:31:04 <edwardk> > ala Sum foldMapOf _1 ("who cares",2)
12:31:06 <lambdabot>  Couldn't match type ‘s0
12:31:06 <lambdabot>                       -> Control.Applicative.Const (s1 -> f0 t0) s0’
12:31:06 <lambdabot>                with ‘Data.Monoid.Sum b’Couldn't match type ‘s0 -> s1 -> f0 t0’
12:31:06 <lambdabot>                with ‘Data.Monoid.Sum (([GHC.Types.Char], t1) -> t)’
12:31:06 <lambdabot>  Expected type: (Control.Lens.Wrapped.Unwrapped
12:31:08 <edwardk> > alaf Sum foldMapOf _1 ("who cares",2)
12:31:09 <lambdabot>  Couldn't match type ‘s0 -> Control.Applicative.Const r0 s0’
12:31:10 <lambdabot>                with ‘Data.Monoid.Sum b’Couldn't match type ‘s0 -> r0’ with ‘D...
12:31:12 <ReinH> unless you actually care where you put it
12:31:12 <lambdabot>  Expected type: (([GHC.Types.Char],
12:31:13 <edwardk> > alaf Sum (foldMapOf _1) ("who cares",2)
12:31:14 <lambdabot>                   Control.Applicative.Const r0 [GHC.Types.Char])
12:31:15 <edwardk> bah
12:31:16 <lambdabot>                  -> s0 -> Control.Applicative.Const r0 s0)
12:31:18 <lambdabot>  Couldn't match type ‘([GHC.Types.Char],
12:31:20 <lambdabot>                        Control.Applicative.Const (Data.Monoid.Sum b) [GHC.Typ...
12:31:22 <lambdabot>                with ‘a0 -> Control.Applicative.Const (Data.Monoid.Sum b) b0’
12:31:23 <solrize> :t sumOf
12:31:24 <lambdabot>  Expected type: Control.Lens.Getter.Accessing
12:31:26 <lambdabot> Num a => Getting (Endo (Endo a)) s a -> s -> a
12:31:28 <lambdabot>                   (,) (Data.Monoid.Sum b) e [GHC.Types.Char]
12:31:41 <ReinH> such scroll
12:31:41 <triliyn> edwardk: shouldn't you be using _2?
12:31:41 <ReinH> wow
12:31:48 <edwardk> > alaf Sum (foldOf _1) ("who cares",2)
12:31:50 <lambdabot>  No instance for (Data.Profunctor.Unsafe.Profunctor (,))
12:31:50 <lambdabot>    arising from a use of ‘Control.Lens.Wrapped.alaf’No instance for (Control....
12:31:50 <lambdabot>                     ([GHC.Types.Char], Data.Monoid.Sum b)
12:31:50 <lambdabot>                     ([GHC.Types.Char], Data.Monoid.Sum b)
12:31:50 <lambdabot>                     (e -> Data.Monoid.Sum b1)
12:31:52 <miguel_> ReinH,Ankhers: thx
12:32:09 <solrize> mm_freak, how can you define seq yourself?  other than with bang parameters which are syntax sugar for seq
12:32:18 <mm_freak> > let mySeq x y = case x of _ -> y in mySeq undefined ()
12:32:20 <lambdabot>  ()
12:32:23 <mm_freak> huh?!
12:32:47 <mm_freak> weren't pattern matches strict?
12:33:06 <haasn> Twey: what's this about?
12:33:07 <srhb> Well you aren't actually matching, are you?
12:33:08 <edwardk> > ala Sum (foldMapOf _1) ("hello","world")
12:33:08 <triliyn> Pattern matches in core are strict, but matching against _ in haskell is not strict
12:33:09 <lambdabot>  "hello"
12:33:35 <srhb> > let mySeq x y = case x of z -> y in mySeq undefined ()
12:33:36 <lambdabot>  ()
12:33:36 <mm_freak> srhb: i am, with a universal pattern…  and i distinctly remember the remark, "pattern matches are strict in haskell"
12:33:38 <srhb> ... ok
12:33:40 <srhb> Yeah
12:33:42 <edwardk> anyways, i ws pointing out that because that lens there never goes to put any of the things together, it doesn't matter what we wrap in the Sum newtype and take right back out
12:33:42 <srhb> :P
12:33:54 <mm_freak> ok, seq is a hack =)
12:34:10 <fizruk> :t foldMapOf _1
12:34:11 <lambdabot> Field1 s s b b => (b -> r) -> s -> r
12:34:17 <geekosaur> _ doesn't specify a structure so it has nothing to be strict about; it matches everything and discards it
12:34:24 <edwardk> solrize: anyways, this stuff a.) actually happens and b.) data type contexts to do what you want aren't in the language any more!
12:34:32 <mm_freak> wait, i think i can still define seq
12:34:33 <solrize> edwardk, hmm, ok, thanks
12:34:48 <mm_freak> @let newtype Single a = Single { single :: a }
12:34:50 <lambdabot>  Defined.
12:34:51 <edwardk> solrize: and please trust me, but if you chase this to its logical conclusion you are much better off moving the instance constraints to their use sites than keping them on the data type
12:34:57 <ReinH> mm_freak: it is strict, but there isn't a constructor to check
12:34:58 <fizruk> :t ala
12:34:59 <solrize> mm_freak, you could do it with Control.Evaluate which is another hack ;)
12:34:59 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
12:35:08 <mm_freak> > let mySeq x y = case Single x of Single _ -> y in mySeq undefined ()
12:35:09 <lambdabot>  ()
12:35:11 <edwardk> solrize: otherwise you wind up with an explosion of one-off data structures
12:35:11 <mm_freak> hmm
12:35:14 <ReinH> mm_freak: f (a,b) = a matches the pair constructor
12:35:15 <fizruk> edwardk: would that work with ala from Data.Newtype?
12:35:16 <haasn> mm_freak: They're strict in the really much more general case in which you actually discriminate between constructors
12:35:21 <edwardk> that way lies madness, and scala.
12:35:27 <mm_freak> @let data Single' a = Single' { single' :: a }
12:35:28 <lambdabot>  Defined.
12:35:29 <edwardk> fizruk: yes
12:35:32 <mm_freak> uhm
12:35:34 <threestrikes> I'm trying to basically filter the contents of a folder to only display specific file extensions.  Is there a library that does this already?
12:35:37 <mm_freak> @undefine
12:35:37 <lambdabot> Undefined.
12:35:43 <mm_freak> @let data Single a = Single { single :: !a }
12:35:45 <lambdabot>  Defined.
12:35:47 <haasn> mm_freak: You can, however, define mySeq with strict data types
12:35:49 <mm_freak> > let mySeq x y = case Single x of Single _ -> y in mySeq undefined ()
12:35:50 * geekosaur considers @remember-ing that comment about madness...
12:35:51 <lambdabot>  *Exception: Prelude.undefined
12:35:51 <haasn> like that :)
12:35:53 <mm_freak> there we go
12:36:09 <mm_freak> seq is not a hack =P
12:36:10 <solrize> mm_freak, that's basically seq, the bang pattern is syntax sugar
12:36:14 <haasn> mm_freak: if pattern matches were strict in general, bang patterns would have no reason for being
12:36:23 <zq> @hoogle Semigroup
12:36:24 <lambdabot> package Semigroup
12:36:24 <lambdabot> package semigroupoid-extras
12:36:24 <lambdabot> package semigroupoids
12:36:26 <mm_freak> solrize: it's standard haskell to describe a strict field
12:36:37 <mm_freak> haasn: you're right, yeah
12:36:42 <solrize> mm_freak, it's an extension
12:36:45 <mm_freak> solrize: no
12:36:52 <mm_freak> it's not BangPatterns
12:36:54 <solrize> hmm
12:37:00 <mm_freak> it's regular strict fields
12:37:04 <geekosaur> solrize, ! in patterns is an extension, ! in ADT fields is not
12:37:47 <solrize> hmm, ok
12:38:10 <threestrikes> I can get the contents of the directory with getDirectoryContents and print it with the print command in a do block but after that I'm lost
12:38:41 <mm_freak> threestrikes: see System.FilePath
12:38:48 <mm_freak> and then simply apply 'filter'
12:39:11 <threestrikes> ok thanks
12:40:43 <mm_freak> edwardk: i suppose V is not itself "storable" in the same sense that Data.Vector.Storable.Vector and ByteString are, is it?
12:40:57 <mm_freak> i.e. it has a specific position in memory
12:41:17 <edwardk> mm_freak: fraid not. its unboxed data
12:41:22 <edwardk> er boxed
12:41:36 <edwardk> you can have V 3 (V 100 Int) after all
12:41:37 <Soft> Can I somehow make cabal sandboxes work like python's virtualenv
12:41:41 <Soft> What I mean is that often I would just like download few packages and try things without creating a cabal project and all that
12:41:45 <Soft> So what I would like to do is something like: cabal sandbox init; cabal install some-library; cabal repl; and get a ghci session with some-library available
12:41:58 <edwardk> an V 3 (IntMap Double)
12:42:14 <geekosaur> Soft: you want hsenv, I think
12:42:31 <monochrom> Soft: you may like my http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
12:42:39 <mm_freak> edwardk: makes sense, thanks
12:42:45 <mm_freak> seems like i have to write a library after all =/
12:42:49 <albeit> I'm reading a file line by line, and feeding each line to stateful computation. Right now I'm foldl' over each line, and the accumulator is a custom state data structure. Is there a better way to do this?
12:43:10 <edwardk> mm_freak: you need unboxed vectors/matrices?
12:43:15 <Twey> haasn: I got temporarily confused by the kind instantiation syntax in the instance list of http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Typeable.html#g:1
12:43:30 <edwardk> mm_freak: put in an issue on linear. we've been talking about possible APIs for such a beast for a while
12:43:31 <mm_freak> edwardk: storable…  i basically need a fixed-length storable Vector
12:43:39 <olalonde> can anyone tell me what's wrong with this? https://gist.github.com/11267028
12:44:06 <edwardk> yeah V isn't really engineered for that
12:44:11 <mm_freak> edwardk: not sure if it really belongs to 'linear'…  it's a generic data structure for things like vectors of shapes, vectors of audio frames, etc.
12:44:12 <haasn> Twey: Oh, it's sort of always been this way on Haddock. I think a while ago I just fixed some things which displayed even worse; like (Typeable -> *) -> * -> [] or whatever
12:44:21 <haasn> Oh, wait, Typeable being kind-polymorphic is new!
12:44:30 <haasn> That's what prompted the confusion, I guess?
12:44:51 <olalonde> oops, meant https://gist.github.com/11267057
12:45:03 <mm_freak> olalonde: your constructor is named 'Int'
12:45:03 <olalonde> can I not patter match if I use my own data type?
12:45:17 <haasn> Twey: The alternative is not displaying it all, and an in-between would be displaying it with some sort of alternative syntax. I'm not sure if the first option is worth the trouble since in Haddock it's not entirely clear what kind various names correspond to, especially in the absence of proper qualification in some cases. If you have any suggestions about better ways to show them, but keep them
12:45:19 <haasn> distinguished, I'd be happy to hear
12:45:22 <Twey> haasn: I think I'd just never run across kind-polymorphic instances in Haddock before, and it wasn't very self-explanatory (I figured it out by reading the source and the mention of kind polymorphism above)
12:45:22 <mm_freak> olalonde: which is probably not what you intended =)
12:45:32 <olalonde> mm_freak: I see
12:45:40 * geekosaur has no idea what that is supposed to mean
12:46:17 <mm_freak> olalonde: this is a tree of Ints:  data IntTree = Leaf Int | Branch [IntTree]
12:46:28 <mm_freak> with values at leaves
12:46:29 <Twey> haasn: Particularly, an instance could be polymorphic in multiple kind variables, and that would be *really* confusing
12:46:39 <Twey> Or a class, rather
12:46:42 <haasn> Twey: This was the behavior in GHC 7.6.x's display of poly-kinded types, fwiw
12:46:46 <Soft> geekosaur: hsenv looks like it's exactly what I was looking for, thanks
12:46:49 <haasn> But they changed it in GHC 7.8.x, it's now hidden
12:47:04 <mm_freak> olalonde: read as:  an IntTree either looks like "Leaf x" or "Branch trees", where x :: Int, and trees :: [IntTree]
12:47:07 <haasn> Twey: Yeah, there's no good way to get this out of the GHC API either. It's really quite terrible
12:47:49 <haasn> Twey: But I think we think we could correctly figure out which kind parameter corresponds to which type variable
12:47:52 <Twey> haasn: How about Typeable (Int ∷ *) ?
12:47:56 <olalonde> mm_freak: ok. so i need to name the value constructor right? can't just do Tree = Int [Tree]
12:48:11 <haasn> Twey: that seems like a decent compromise, actually; I'll look into implementing this
12:48:12 <mm_freak> olalonde: exactly…  otherwise it would be impossible to match on the cases
12:48:25 <olalonde> mm_freak: ok I will try something :P
12:48:27 <Twey> haasn: Brilliant; thanks!
12:48:38 <mm_freak> olalonde: if you ever heard the term "discriminated union", this is where the "discriminated" comes from =)
12:48:54 <olalonde> never heard.. started haskel about 2 hours ago :P
12:49:02 <geekosaur> olalonde, think of it this way: there's always one possible "constructor" more than you write. (It is what we call "bottom")
12:50:10 <mm_freak> olalonde: in that case, i'm pretty sure you defined your own Bool about one hour ago, and here is what it looks like:  data MyBool = MyFalse | MyTrue
12:50:17 <geekosaur> so the fact that you have only one case does not absolve you of providing a constructor for it, or that constructor having an actual meaning, because there's always that other possibility hiding in the shadows. (and yes, this does kinda complicate thinking about data in Haskell, but it's the price of non-strictness)
12:50:28 <mm_freak> a Bool either looks like "MyFalse" or "MyTrue"
12:50:41 <mm_freak> and your IntTree is basically just a slightly extended version of that =)
12:52:08 <olalonde> ok, trying to digest this :P
12:52:26 <ReinH> mm_freak: inductive data types are maybe slightly more than slightly extended. Moderately extended? =)
12:52:32 <mm_freak> olalonde: just try to represent a number of specific values of type IntTree and see if it fits the definition
12:53:27 <mm_freak> ReinH: because right now you're thinking, "how can anyone say that ADTs are just slight extensions of C's enum types?!", and i understand that…  but conceptually they are very similar =)
12:53:46 <ReinH> mm_freak: no, becuase I'm thinking that recursion is not a trivial extension
12:54:47 <olalonde> I'm not sure exactly how value constructors are defined.. seems data XXX =  ... defines at type but how would you define a value constructor on its own line.. is it possible?
12:55:09 <mm_freak> olalonde: yes, but pretend that "no"
12:55:20 <mm_freak> olalonde: if this is solely about source code lines, you can break the data definition
12:55:48 <mm_freak> as long as you indent the next line that is
12:57:15 <ReinH> olalonde: have you seen Learn You a Haskell?
12:57:17 <ReinH> @where lyah
12:57:17 <lambdabot> http://www.learnyouahaskell.com/
13:00:09 <solrize>     Warning: -XDatatypeContexts is deprecated: It was widely considered a misfeature, and has been removed from the Haskell language.
13:00:15 <solrize> ?
13:00:30 <benmachine> solrize: !
13:01:17 <solrize> does that have something to do with some inconsistency created by newtype?  i mean with data it can be done with a gadt
13:02:25 <benmachine> solrize: datatype contexts don't do anything useful, and never did
13:02:26 <mm_freak> solrize: that's a constructor context, not a type context
13:02:33 <edwardk> lens is the only library I've ever written that generates hate mail and invites to give talks in almost equal measure
13:02:44 <benmachine> edwardk: hate mail, huh
13:02:56 <FreeFull> edwardk: All the other libraries only generate invites?
13:02:57 <benmachine> solrize: they are not to be confused with contexts on the RHS of a = in a type definition, which are a whole other fish kettle
13:02:58 <olalonde> ReinH: yeah.. I'm reading that and http://shuklan.com/haskell/lec06.html#/
13:03:00 <quchen> Hate mail about lens!?
13:03:03 <edwardk> well, actually i suppose technically, most of my other ibraries vacuously hold that balance ;)
13:03:05 <mmachenry> edwardk: Why is it so polarizing?
13:03:25 <ReinH> if you aren't making people angry you aren't doing anything important
13:03:28 <olalonde> actually I figured to get my code to work... I know it's probably not very idiomatic : https://gist.github.com/11267620
13:03:28 <ReinH> the converse is not always true
13:03:33 <djahandarie> @remember edwardk lens is the only library I've ever written that generates hate mail and invites to give talks in almost equal measure
13:03:33 <lambdabot> Nice!
13:03:40 <solrize> edwardk, do they happen in the same message?  "i hate lens, can you come over and talk about it?"
13:03:56 <mm_freak> solrize: constructor contexts make pattern matching richer
13:04:08 <edwardk> solrize: not yet but there is always a first time
13:04:16 <haasn> Most of edwardk's other libraires do not have sufficient documentation to generate hate mail
13:04:27 <ReinH> olalonde: actually that looks pretty normal
13:04:31 <edwardk> patches welcome ;)
13:04:39 <mm_freak> data X :: (* -> *) -> * -> * where X :: (Monad m) => m a -> X m a
13:04:40 <solrize> haasn maybe the hate mail is from lack of documentation
13:04:45 <mm_freak> f (X c) = y
13:04:58 <ReinH> olalonde: you don't need braces around add
13:05:03 <haasn> solrize: hate mail is not a particularly effective way to generate documentation, one would think :P
13:05:06 <mm_freak> 'y' now knows that 'c' has a monad constraint on 'm', even when 'f' doesn't
13:05:08 <zerokarmaleft> haasn: Saunders MacLane *is* the documentation
13:05:26 <quchen> haasn: "This function *sucks*" instead of deprecation? :-D
13:05:37 <ReinH> olalonde: you've just invented a fold :)
13:05:45 <albeit> Is "read x :: Int" the fastest way to convert a string x = "123" to an integer?
13:05:51 <olalonde> ReinH: haha right :/
13:05:56 <ReinH> zerokarmaleft: it's Mac Lane :)
13:06:04 <mm_freak> albeit: fastest for the programmer, not the machine =)
13:06:05 <ReinH> olalonde: no, inventing things is good, even if they've been invented before.
13:06:05 <quchen> albeit: No, read is the fastest way to shoot yourself in the foot. readMaybe is a better option.
13:06:14 <edwardk> > "123"^?base 10
13:06:15 <lambdabot>  Just 123
13:06:28 <haasn> quchen: I'll just send edwardk my base-related hate mail now, too. “This function *succs*”
13:06:29 <ReinH> olalonde: if they've been invented before it means you aren't doing anything too silly ;)
13:06:32 <albeit> mm_freak: What is a faster method for the machine?
13:06:35 <mm_freak> albeit: ∀ x. the fastest way to do x is to use 'lens' =)
13:06:38 <olalonde> ReinH: yes.. I'm just trying to learn about types and pattern matching now
13:06:42 <edwardk> haasn: heh
13:06:43 <olalonde> haha
13:06:53 <quchen> haasn: You're not the first one to make that joke ;-)
13:06:53 <shachaf> edwardk: We should make a traversal for read that uses the past tense version of the word.
13:06:59 <mm_freak> albeit: the text package has readInteger i think
13:06:59 <haasn> Well aware :(
13:07:04 <shachaf> "12" ^? read
13:07:10 <olalonde> ReinH: is there any easy way I could make the [Tree] part optional?
13:07:19 <ReinH> olalonde: what do you mean by optional?
13:07:24 <edwardk> > "12"^._Show
13:07:24 <mm_freak> albeit: http://hackage.haskell.org/package/text-1.1.0.1/docs/Data-Text-Read.html
13:07:25 <lambdabot>  ()
13:07:29 <ReinH> you need *some* way to represent the children
13:07:30 <edwardk> > "12"^.from _Show
13:07:31 <lambdabot>  No instance for (Data.Profunctor.Choice
13:07:31 <lambdabot>                     (Control.Lens.Internal.Iso.Exchange
13:07:31 <lambdabot>                        [GHC.Types.Char] [GHC.Types.Char]))
13:07:31 <lambdabot>    arising from a use of ‘Control.Lens.Prism._Show’
13:07:39 <edwardk> > "12"^.re _Show
13:07:40 <lambdabot>  "\"12\""
13:07:56 <mm_freak> albeit: something ByteString-based would be even faster, but also wrong
13:07:58 <edwardk> > "12"^._Show :: Int
13:07:59 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
13:07:59 <lambdabot>    arising from a use of ‘Control.Lens.Prism._Show’
13:08:02 <haasn> shachaf: clearly, we need an invisible UNICODE PAST TENSE DISTINCTION MARK
13:08:07 <mm_freak> albeit: in a more subtle way than 'read'
13:08:08 <edwardk> > "12"^?_Show :: Maybe Int
13:08:09 <lambdabot>  Just 12
13:08:20 <albeit> mm_freak: Why wrong?
13:08:28 <mm_freak> albeit: because byte strings are not character strings
13:08:37 <edwardk> > _Show # 12
13:08:39 <lambdabot>  "12"
13:08:45 <olalonde> ReinH: oh.. just figured it.. well that's what I meant :P -> https://gist.github.com/11267802
13:09:03 <mm_freak> albeit: you would need to make sure you're using the correct encoding, and this can't be made sure via types
13:09:09 <albeit> mm_freak: But if know the input is pure ascii, would it be better?
13:09:11 <ReinH> olalonde: ah :)
13:09:22 <mm_freak> albeit: no (that's a lie, but pretend it's the truth)
13:09:37 <mm_freak> albeit: the speed difference is hardly measurable anyway =)
13:09:47 <mm_freak> so just use Text
13:10:03 <ReinH> olalonde: now if you generalize that to any `sum'-like and any `add'-like, you get a fold
13:10:25 <olalonde> ReinH: eheh, I might try that next :)
13:10:54 <mm_freak> olalonde: right now you're using (+)
13:11:01 <monochrom> "I know the input is pure ascii" has got us into much trouble. if you ever leak your program to the outside, people will use it on non-ascii.
13:11:04 <mm_freak> olalonde: what if you take the addition function as an argument?
13:11:11 * haasn wonders how much slower http://www.haskell.org/haskellwiki/Wc#Data.ByteString would be when translated to Text
13:11:35 <mm_freak> olalonde: try this:  combine f (Node x xt) = …
13:11:42 <mm_freak> it's really not much different from your code =)
13:12:02 <FreeFull> ByteString and Text have different purposes
13:12:09 <tdammers> monochrom: you can "know" by doing a pre-check that simply rejects any byte with the MSB set
13:12:17 <olalonde> mm_freak: ah right, I just realized that would be kind of easy :)
13:12:25 <FreeFull> ByteString is a replacement for [Word8]
13:12:33 <mm_freak> tdammers: you assume that all text has ASCII as the first 127 codepoints
13:12:41 <zerokarmaleft> ReinH: duly noted!
13:12:51 <mm_freak> olalonde: welcome to functional programming =)
13:12:52 <albeit> Is Data.Text better to use than String?
13:12:55 <albeit> In general
13:12:59 <olalonde> mm_freak: :)
13:13:00 <FreeFull> Yes
13:13:01 <mm_freak> albeit: not in general
13:13:02 <monochrom> pre-check is good. but I have never seen anyone pre-checking.
13:13:06 <mm_freak> albeit: but in many cases
13:13:09 <FreeFull> Well, depends on what you're doing
13:13:28 <FreeFull> If you're just making a quick little thing, you probably don't need to bother with Text
13:13:43 <mm_freak> FreeFull: why not?  this isn't about problem size, but problem structure =)
13:13:50 <albeit> mm_freak: Should I read the file in as Data.Text, or just convert a line of the file currently in String to Data.Text and then convert to Int?
13:13:53 * monochrom suddenly remembers the movie Minority Report. "Pre-bug. It works." :)
13:13:55 <mm_freak> and i find myself using Text even for very small things
13:14:02 <tdammers> well, you can only check which values you get anyway, not what they mean
13:14:06 <mm_freak> albeit: the former
13:14:40 <haasn> My philosophy is that rather than prechecking, you should design your program so that it handles every physically possible case, and your static constraints so that this never results in a loop or crash
13:14:43 <tdammers> but yeah, I basically agree that if it's text, you should use a text type, not a byte stream type
13:14:57 <haasn> Of course, you can add pre-checks on top of this, but at that point, they'd only guard against implementation error
13:15:53 <tdammers> your input is going to be raw unchecked bytes one way or another
13:15:54 <monochrom> I can't handle the physical case of power-off.
13:16:05 <tdammers> you *will* have to check and parse at some point
13:16:15 <mm_freak> tdammers: not necessarily…  operating systems have become smarter =)
13:16:26 <monochrom> but distrusting input is always a good idea
13:16:28 <mm_freak> tdammers: let the RTS or the OS decide what the application receives
13:16:37 <solrize> @remember * monochrom suddenly remembers the movie Minority Report. "Pre-bug. It works." :)
13:16:37 <lambdabot> It is forever etched in my memory.
13:16:38 <mm_freak> as long as it's local!
13:16:39 <haasn> monochrom: I guess that's what libraries like acid-state try to do? (among other things)
13:16:46 <monochrom> destructing input is even better (good riddance), but probably not profitable :)
13:17:10 <tdammers> mm_freak: that's not necessarily smart I would argue
13:17:18 <orion> How often is the OverloadedStrings extension used?
13:17:20 * tdammers strokes his massive unix beard
13:17:25 <mm_freak> tdammers: when reading a file, you should probably just read it in text mode
13:17:31 <haasn> But when I said physical, what I really meant is in terms of whatever external abstraction, data, or whatever is possible in the language of the environment. Eg. if a bit string can be passed to your API, it needs to handle it
13:17:33 <mm_freak> orion: i use it all the time
13:17:53 <tdammers> mm_freak: text mode is just raw bytes with line end conversion anyway
13:17:58 <danclien> How's Windows support for Haskell? Good enough for production use?
13:18:00 <haasn> If a file name can consist of arbitrary octets, your FilePath needs to support that
13:18:15 <mm_freak> tdammers: 'text' does more
13:18:30 <mm_freak> danclien: for many things, but not for everything
13:18:46 <danclien> mm_freak: Any specific cases I should look out for?
13:18:51 <mm_freak> danclien: the rule of thumb is:  when you have to bind to non-haskell libraries, you might have to go through some pain to get them to work
13:19:06 <tdammers> mm_freak: yes, but the OS doesn't
13:19:26 <tdammers> mm_freak: or are you talking about libc's fopen() text mode?
13:19:29 <danclien> mm_freak: Ah, gotcha. Sounds like the same issue with Ruby.
13:19:50 <mm_freak> tdammers: i think we agree that text should be handled as text and best not received as byte streams…  let's not stretch this further =)
13:19:51 <Maior> @hoogle (a -> b -> c) -> f a -> f b -> f c
13:19:52 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:19:52 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:19:52 <lambdabot> Data.IntMap.Strict intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
13:20:23 <tdammers> mm_freak: I agree on this much. It just doesn't go well with Unix' bag-of-bytes model of a file
13:20:25 <Maior> is liftM2 just a two-arg fmap?
13:20:33 <Maior> @src liftM2
13:20:33 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:20:49 <tdammers> mm_freak: so what it boils down to is that the OS gives you a pretty raw stream of bytes, and it's up to you to make sense of it
13:20:50 <Maior> @src liftA2
13:20:50 <lambdabot> liftA2 f a b = f <$> a <*> b
13:20:55 <mm_freak> tdammers: bottom line:  you also agree with me that unix sucks and plan9 made it worse (when many people think it made it better) =)
13:21:14 <olalonde> mm_freak: what would be the typeclass though? for the function that is passed
13:21:21 <tdammers> mm_freak: not really, no
13:21:25 <mm_freak> olalonde: what type class?
13:21:53 <tdammers> mm_freak: I think that Unix is pretty OK, and that having to deal with raw byte streams is the price we pay for its incredible flexibility and malleability
13:22:07 <Maior> @hoogle (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
13:22:07 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:22:07 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:22:07 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
13:22:21 <Maior> I should have expected that, sorry
13:22:22 <olalonde> mm_freak: I mean.. I need to pass a function to combine.. how do I define combine's type if I want it to be able to accept any function?
13:22:58 <mm_freak> olalonde: what's the type of 'combine'?  just the generic shape…  previously it had the shape A -> B (it took one argument, the tree, and produced a result, the Int)
13:23:17 <mm_freak> olalonde: what's the shape now?  (how many arguments does it take before it produces a result?)
13:23:37 <olalonde> I just kept the same function for now but added a "fn" argument
13:23:56 <olalonde> combine fn (Node i []) = i etc.
13:23:57 <mm_freak> olalonde: ok, but the type must have changed now, because it takes another argument
13:24:11 <mm_freak> what's the type of that new argument?
13:24:15 <olalonde> yes, that's the question :P would this work? combine :: Tree -> (a -> a -> a) -> Int
13:24:22 <mm_freak> olalonde: no =)
13:24:23 <olalonde> oh
13:24:34 <olalonde> i don't know if it's an Int right
13:24:48 <mm_freak> olalonde: don't you?  look at your type
13:24:54 <mm_freak> does it support anything other than Int?
13:25:02 <olalonde> oh wrong order also
13:25:05 <olalonde> haha damn it
13:25:14 <orion> mm_freak: I just found out about it. Am I correct in stating that with OverloadedStrings, I can avoid: pack "Hello, World!" :: ByteString -- and instead simply do: "Hello, World!" :: ByteString ?
13:25:28 <mm_freak> orion: yes
13:25:35 * orion just came
13:25:40 <orion> wow
13:25:44 <mm_freak> keep that to yourself =P
13:26:08 <olalonde> combine :: (a -> a -> a) -> Tree -> a   ... is that even syntaxically valid?
13:26:17 <orion> mm_freak: Now, is this functionality specifically because the ByteString data type is an instance of IsString ?
13:26:17 <mm_freak> olalonde: it is, but it's wrong =)
13:26:43 <mm_freak> olalonde: when you write a type signature like that, the /user/ of 'combine' chooses the type 'a'
13:27:00 <mm_freak> orion: correct
13:27:06 <olalonde> right, that's what I want.. replace the  addition by a user supplied function
13:27:15 <mm_freak> orion: similarly you can write "123 :: Integer", because Integer is a Num
13:27:29 <mm_freak> olalonde: yes, but functions are /values/, not /types/
13:27:45 <olalonde> ahh right! oops
13:27:50 <mm_freak> olalonde: the user of 'combine' gets the freedom to pass a custom function, a value, not choose a custom type (yet)
13:28:05 <olalonde> is there a type for functions?
13:28:14 <mm_freak> olalonde: sure, you've written it above =)
13:28:20 <FreeFull> Functions have (->) in their type
13:29:00 <FreeFull> So   foo :: (->) a b    or    foo :: a -> b
13:29:12 <FreeFull> For any a and b
13:29:25 <mm_freak> FreeFull: allow olalonde to figure things out =)
13:29:31 <FreeFull> Sorry
13:29:47 <olalonde> yes please :P
13:30:19 <mm_freak> olalonde: 'add' was a function, and you've written its type:  IntTree -> Int
13:30:40 <mm_freak> olalonde: now imagine a function of type X -> Y
13:30:46 <mm_freak> and it takes a function as its first argument
13:30:50 <mm_freak> what would X look like?
13:31:06 <orion> mm_freak: Seems easy to go from a String to a ByteString, but what about the other way around? What if I have a ByteString and want to go back to a String?
13:31:21 <mm_freak> orion: that's horribly complicated (i'm serious)
13:31:47 <mm_freak> orion: ByteString is a list of bytes, while String is a list of characters, so you have to deal with encodings, etc.
13:32:05 <mm_freak> orion: it would be much easier to go from Text to String (the function is called 'unpack')
13:32:10 <geekosaur> String to ByteString is not entirely easy either, at least if you care about data loss
13:32:17 <olalonde> mm_freak: all I can come with is (a -> a) or something like that :/
13:32:27 <mm_freak> olalonde: that's almost correct
13:32:31 <orion> mm_freak: This is a good point.
13:32:37 <mm_freak> olalonde: what if it takes a function like 'add'?
13:32:43 <mm_freak> what would X be in that case?
13:33:10 <olalonde> mm_freak: (a -> a -> a) no?
13:33:12 <orion> mm_freak: What encoding does unpack use? ASCII?
13:33:34 <mm_freak> olalonde: we haven't talked about polymorphic types at all yet, so don't use type variables =)
13:33:48 <mm_freak> olalonde: and i'm talking about your 'add' from earlier, not a function that adds numbers
13:33:52 <olalonde> (Int -> Int -> Int) ... (the only numeric type i know:P)
13:33:56 <tdammers> orion: Text.unpack just maps Unicode to Unicode
13:33:57 <olalonde> ahh right
13:33:58 <olalonde> haha
13:34:05 <olalonde> (Tree -> Int)
13:34:16 <mm_freak> olalonde: absolutely correct, so what would be the overall type?
13:34:21 <mm_freak> X -> Y = ?
13:34:32 <olalonde> (Tree -> Int) -> Y ?
13:34:35 <tdammers> orion: ByteString.Char8.unpack just says "yolo" and doesn't convert at all, it just widens 8-bit values to 32 bits
13:34:35 <mm_freak> yeah
13:34:51 <mm_freak> olalonde: now back to your 'combine'…  it takes two arguments:  X -> IntTree -> Int
13:34:54 <mm_freak> olalonde: X = ?
13:35:05 <mm_freak> remember:  it takes a function that adds two Ints =)
13:35:30 <mm_freak> orion: semantically Text is a list of Char, not a list of Word8
13:35:37 <mm_freak> orion: ByteString is a list of Word8
13:35:41 <olalonde> (Int -> Int -> Int) -> IntTree -> Int  ?
13:35:45 <orion> What IS a Char then?
13:35:48 <mm_freak> olalonde: there you go =)
13:35:53 <mm_freak> orion: a unicode codepoint
13:36:05 <orion> My life is a lie.
13:36:13 <c_wraith> All praise to unicode!  codepoints don't mean characters!
13:36:43 <mm_freak> orion: it isn't…  you've just figured out how serious haskell is about correctness =)
13:36:53 <earthy> All praise to unicode! Characters don't mean graphemes! :P
13:38:14 <mm_freak> c_wraith: that's actually fine with me…  i l̲o̲v̲e̲ unicode's combinatorial characters =)
13:38:17 <orion> hm
13:38:24 <olalonde> mm_freak: makes sense! thanks
13:38:39 <albeit> Is this a reasonable way to extract an Int out of Data.Text? fst . either error id . decimal $ pack "123"
13:38:40 <monochrom> damn you using unicode to circumvent my measure of disallowing underlines
13:39:03 <mm_freak> albeit: if crashing your program on parse errors is the behavior you want, yes
13:39:16 <orion> So for network protocols, definitely use Word8 instead of Char?
13:39:29 <mm_freak> orion: likely, yeah
13:39:48 <albeit> mm_freak: It's just doing simulations on data I provide, and I can guarantee the data is in a format, and if its not, its not big deal.
13:39:49 <mm_freak> orion: you usually use ByteString and convert the text parts to Text early
13:39:50 <c_wraith> orion: and if you're going to be sending text, specify the encoding!
13:40:04 <mm_freak> orion: as soon as you know what encoding is used, that is
13:40:12 <c_wraith> orion: preferably in the protocol.  Don't make it an option.  That never works out well.
13:40:40 <mm_freak> albeit: you can't guarantee that, but for a small helper tool that you don't distribute, it's probably sufficient
13:41:05 <orion> In a simple client/server model, I am guessing the go-to library for serializing and deserializing data structures is attoparsec?
13:41:08 <mm_freak> albeit: my own variant would be to use an IO exception
13:41:19 <mm_freak> orion: it's a reasonable choice
13:42:06 <mm_freak> orion: for deserializing…  for serializing i personally use builders
13:42:16 <mm_freak> orion: see Data.ByteString.Lazy.Builder
13:42:33 <mm_freak> oh and i'm not sure if "serialization" is the correct term here
13:42:54 <afleck> @src Control.Monad.Reader
13:42:54 <lambdabot> Source not found. You type like i drive.
13:43:05 <mm_freak> @src Reader
13:43:05 <lambdabot> Source not found. Are you typing with your feet?
13:43:08 <mm_freak> @src ReaderT
13:43:08 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:43:10 <quchen> Lambdabot @src database: https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
13:43:17 <mm_freak> @src Control.Monad.Trans.Reader.ReaderT
13:43:17 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:43:19 <mm_freak> wow
13:43:24 <mm_freak> lambdabot, you suck
13:45:43 <monochrom> people don't call themselves rocket scientists. worse, people call themselves engineers.
13:47:02 <afleck> could someone explain to me how ((->) e) and Reader e a are related?
13:47:22 <monochrom> Reader is a newtype of ((->) e)
13:47:54 <monochrom> "newtype Reader e a = Reader (e -> a)
13:48:41 <afleck> is ((->) e) a constructor for functions from e to another type?
13:49:01 <LowPotential> I was reading the article on Free Monads on Haskell For All (http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html), with the intention of modelling my AST using them. What I don't understand is what benefits using a Free monad gives me over a simple list, particularly if I'm doing pure transformerations and filtering (for which I could use 'map' and 'filter'). I'm not a theoretician (see? I can't even spell
13:49:01 <LowPotential> it. :-)
13:51:11 <mm_freak> afleck: a type constructor, yes
13:51:12 <olalonde> mm_freak: think I've got something that works https://gist.github.com/11268987
13:51:48 <mm_freak> olalonde: congratulations…  you've just mastered MapReduce =)
13:51:54 <olalonde> haha :)
13:52:43 <Javran> http://lpaste.net/103166 I just played around with Profunctor, what I did was to implement a toy instance of Num, does this look good?
13:52:46 <mm_freak> seriously…  what google is selling as a major breakthrough is pretty much what you just wrote, except distributed =)
13:53:33 <mm_freak> olalonde: next step:  rename IntTree to Tree and make it deserve its name =)
13:54:30 <olalonde> right haha... good suggestion .. sorry for the misleading name :P I will try later.. will read next chapter first
13:54:45 <mm_freak> olalonde: go ahead =)
13:54:52 <afleck> mm_freak: how do I construct a type of (e -> a) using ((->) e)? I'm trying to implement a Monad instance for ((->) e) and doing "return a = (e -> a)" doesn't appear to work
13:55:16 <mm_freak> afleck: (e -> a) is a type, not a value
13:55:23 <mm_freak> a value of that type looks like this:  \x -> y
13:55:39 <afleck> mm_freak ah, I see
13:55:53 <mm_freak> afleck: also keep in mind that there is already an instance for that type
13:56:02 <Javran> it'll be fine to define `join f x = f x x` and get ">>=" for free ...
13:56:19 <mm_freak> afleck: just define custom functions with the following types:
13:56:31 <mm_freak> afleck: readerReturn :: a -> (e -> a)
13:56:46 <mm_freak> afleck: readerBind :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
13:56:48 <olalonde> mm_freak: by the way, where can I see how the "standard library" functions are implemented? and what's the right term for standard library in haskell?
13:56:59 <mm_freak> afleck: those will correspond to the Monad instance
13:57:02 <afleck> mm_freak: I've got a Monad' class
13:57:10 <mm_freak> afleck: ah, then go ahead =)
13:57:27 <mm_freak> olalonde: base library
13:57:33 * hackagebot Workflow 0.8.0.9 - Workflow patterns over a monad for thread state logging & recovery  http://hackage.haskell.org/package/Workflow-0.8.0.9 (AlbertoCorona)
13:57:36 <mm_freak> olalonde: http://hackage.haskell.org/package/base
13:57:40 <afleck> mm_freak: so is a good return for Reader just id?
13:57:46 <olalonde> mm_freak: thanks again
13:57:49 <monochrom> afleck: you can write "e -> a" or "(->) e a"
13:57:56 <mm_freak> afleck: no, that's a type error =)
13:58:10 <mm_freak> afleck: return :: a -> M a
13:58:12 <albeit> How much slower would keying a Map.Map by (Int,Int) be then Int for lookups?
13:58:14 <mm_freak> where M = (->) e
13:58:22 <mm_freak> afleck: so:  return :: a -> (e -> a)
13:58:23 <albeit> *than
13:58:28 <mm_freak> afleck: does that help?
13:58:55 <mm_freak> albeit: the difference should be very small, especially when the first value distinguishes most of the time
13:58:56 <afleck> mm_freak: I perfectly understand all of that, but I'm unsure of the actual implementation
13:59:11 <mm_freak> afleck: a -> (e -> a) = a -> e -> a
13:59:22 <mm_freak> afleck: you're receiving an 'a' and an 'e' and need to return an 'a'
13:59:24 <mm_freak> what do you return?
13:59:39 <mm_freak> return x y = ?
13:59:56 <afleck> mm_freak: so return is allowed to have two arguments?
13:59:59 <afleck> return x y = x
14:00:25 <mm_freak> afleck: "f x = \y -> …" is the same as "f x y = …"
14:00:31 <mm_freak> and yes, that's correct
14:00:39 <mm_freak> do you recognize that function? =)
14:00:55 <afleck> ...no
14:01:03 <bennofs> @ty const
14:01:05 <lambdabot> a -> b -> a
14:01:06 <mm_freak> 'return x' is a function that ignores its argument
14:01:10 <mm_freak> and just returns 'x'
14:01:17 <mm_freak> if it doesn't depend on its argument, it is …?
14:01:36 <afleck> ah, a constant function
14:01:43 <mm_freak> afleck: correct =)
14:02:43 <albeit> mm_freak: If the pairs are [(i,j) | i<-[1..10], j<-[1..10]], versus keys for an IntMap [(i*100+j)  | i<-[1..10], j<-[1..10]], would the IntMap then be quite a bit faster?
14:03:08 <sipa> benchmark it :)
14:03:32 <albeit> Fair enough! I'll give it a go
14:06:03 <afleck> how does return x y = x put x into the ((->) e) monad?
14:06:15 <mm_freak> albeit: also make sure you don't suffer from premature optimization…  both Map and IntMap are very fast, fast enough for most purposes =)
14:06:25 <ReinH> albeit: it doesn't do any such thing. It just satisfies the types and the monad laws.
14:06:27 <joelteon> Anyone here have experience with hpc-coveralls?
14:06:59 <ReinH> argh
14:07:01 <mm_freak> afleck: a -> e -> a = a -> (e -> a) = a -> (->) e a = a -> ((->) e) a = a -> M a
14:07:01 <ReinH> afleck: ^
14:07:08 <mm_freak> afleck: where M = (->) e
14:07:10 <ReinH> My tab completion skills need an overhaul
14:08:16 <mm_freak> afleck: (->) is right-associative (a -> b -> c = a -> (b -> c)) and function application is left-associative, for types as well:  T a b = (T a) b
14:08:44 <afleck> mm_freak: Alright, I get it, it just seems weird
14:09:19 <mm_freak> afleck: well, haskell is pretty consistent in the "when it makes sense, it should work" sense =)
14:09:32 <mm_freak> except for one thing that bothers me a lot:  TupleSections
14:09:45 <mm_freak> and i don't understand why TupleSections didn't make it into haskell 2010
14:11:35 <afleck> welp, now on to figuring out bind...
14:11:43 <orion> hm
14:11:53 <orion> in ghci: let x = do string8 "Hello "; string8 "World"; -- Couldn't match expected type `m0 b0' with actual type `Builder'
14:12:09 <mm_freak> afleck: first expand its type like you did for 'return', then it's very easy to figure out
14:12:16 <orion> Am I looking at Builders incorrectly?
14:12:31 <monochrom> afleck: yes, the type is good hint here
14:12:35 * hackagebot find-conduit 0.1.0 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.1.0 (JohnWiegley)
14:12:52 <mm_freak> orion: you're pretending to have a monad, when in fact you have a monoid =)
14:12:58 <mm_freak> orion: use (<>) instead of (>>)
14:13:08 <orion> bah
14:13:10 <monochrom> although, it takes a mechanical mind that ignores intuition to correctly write out the type
14:13:39 <orion> No syntactic sugar for (<>) I suppose.
14:13:53 <mm_freak> orion: what would syntactic sugar for that one look like?
14:14:21 <orion> <> = >>
14:14:30 <orion> That's not a well-thoughtout opinion though
14:14:43 <mm_freak> orion: would you want syntactic sugar for (+) as well? ;)
14:14:50 <monochrom> Reader e a -> (a -> Reader e b) -> Reader e b
14:14:58 <mm_freak> but anyway, you can use list notation:  mconcat [x, y, z]
14:15:13 <monochrom> (e -> a) -> (a -> e -> b) -> (e -> b)
14:15:32 <mm_freak> monochrom: you're missing a pair of parentheses =)
14:15:45 <orion> mm_freak: (<>) isn't found on Hoohle.
14:15:47 <orion> Hoogle*
14:15:52 <monochrom> I think it helps to omit that pair
14:15:56 <orion> For Builders anyway
14:16:29 <monochrom> in the "expand, use for guidance" direction anyway
14:17:47 <afleck> okay, is the first step in expansion (e -> a) -> (a -> e -> b) -> e -> b?
14:17:53 <monochrom> yes
14:18:03 <mm_freak> orion: Data.Monoid
14:18:32 <mm_freak> orion: (<>) = mappend
14:19:02 <afleck> monochrom: it seems like just removing all of the parentheses would do
14:19:25 <monochrom> no, those parentheses are necessary
14:19:31 <mm_freak> afleck: how many arguments are you seeing there?
14:19:41 <afleck> after the first step, 4
14:19:43 <monochrom> (e -> a) -> (a -> e -> b) -> e -> b already uses the minimum number of parentheses
14:19:45 <mm_freak> afleck: wrong
14:19:48 <mm_freak> try again =)
14:19:51 <afleck> oh 3
14:19:53 <afleck> sorry
14:20:08 <tdammers> monochrom: type-level $, now I wish that were a thing
14:20:14 <mm_freak> afleck: ok, the result type is 'b', and there is a way to produce a 'b'…  do you see it?
14:21:02 <afleck> yeah, with a function of type e -> a -> b
14:21:13 <mm_freak> afleck: well, a -> e -> b
14:21:22 <mm_freak> afleck: and you're receiving such a function as your second argument
14:21:27 <mm_freak> (>>=) f g x = …
14:21:43 <monochrom> you have ingredients f::e->a, g::e->a->b, x::e. can you apply them?
14:21:49 <mm_freak> afleck: so the overall result has to be an application of 'g', because that's what produces the 'b'
14:21:58 <mm_freak> (>>=) f g x = g ? ?
14:22:04 <mm_freak> afleck: now figure out the second ?
14:22:06 <mm_freak> it's very easy
14:23:20 <afleck> :( I'm hung up on the fact that (>>=) is taking 3 arguments
14:23:33 <mm_freak> afleck: that's what your type says, isn't it?
14:24:24 <mm_freak> afleck: don't worry, that confusion is unique to reader monads =)
14:24:25 <ReinH> Well, another equivalent way to think of it is a function that takes two functions and produces a function that takes a value.
14:24:31 <ReinH> (f >>= g) = \x -> ...
14:24:56 <afleck> seems like .
14:24:57 <afleck> to me
14:25:22 <ReinH> it is *a* way to combine functions, but it is not composition
14:25:24 <mm_freak> afleck: in haskell there is no difference between "takes three arguments" and "takes two arguments and produces a function"
14:25:38 <mm_freak> afleck: they are the same concept
14:25:52 <monochrom> afleck: "(e -> a) -> (e -> a -> b) -> (e -> b)" suggests taking two parameters and codomain e->b.
14:26:24 <monochrom> afterall if you write it back as Reader e a -> (a -> Reader e b) -> Reader e b, it still looks 2 parameters.
14:26:46 <mm_freak> but 'Reader e b' is a function type itself
14:27:17 <monochrom> eventually you will lose a set-in-stone notion of "how many parameters"
14:27:47 <monochrom> id::a->a looks like 1 parameter
14:28:03 <mm_freak> not to confuse you further, but 'b' can itself be a function type, so you can make (>>=) take as many parameters as you want =)
14:28:27 <monochrom> until you discover that you can instantiate it to (b->b->b->b)->b->b->b->b and then suddenly it looks 4 parameters too
14:28:40 <monochrom> @quote monochrom 17-ary
14:28:40 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
14:28:58 <ReinH> lol
14:29:43 <fragamus_> @quote fragamus WTF
14:29:43 <lambdabot> No quotes for this person. stty: unknown mode: doofus
14:30:14 <fragamus_> knp
14:32:41 <ReinH> monochrom: there is no n-ary, only zuul
14:33:04 <albeit> I'm getting a stack overflow, but the only fold I ever use is foldl'. What's the best way to determine where the overflow is coming from?
14:33:07 <mm_freak> functions in a box, please
14:33:18 <mm_freak> albeit: pasting your code =)
14:33:21 <monochrom> to comfort you, I thought of "id::a->a" as 1-parameter for many years too.
14:33:35 <johnw> albeit: foldl' can still overflow, if you are using nested structures
14:33:44 <mm_freak> monochrom: let me guess, at some point you figured out that ($) is just id in disguise =)
14:33:53 <afleck> alright, I'm totally stumped
14:34:00 <monochrom> no, it's worse. at some point, someone here taught me it
14:34:20 <mm_freak> afleck: don't worry about all that, just remember that (>>=) wants three arguments for reader monads
14:34:28 <ReinH> no it doesn't :p
14:34:34 <afleck> it seems like if f is type (e -> a), and g is type (e -> a -> b), you could do g f x
14:34:37 <afleck> and get what you want
14:34:50 <mm_freak> afleck: g :: a -> e -> b
14:34:57 <afleck> agh
14:35:06 <albeit> http://lpaste.net/103171
14:35:23 <albeit> There's a lot more code... but Market is a data structure with four different Maps
14:35:39 <mm_freak> albeit: (,) is nonstrict
14:35:47 <johnw> yeah, that's the nested structure I was talking about :)
14:35:49 <mm_freak> so you're not forcing evaluation
14:36:01 <afleck> well, x :: e, so (f x) has type a, right?
14:36:04 <johnw> step (!as, !m); and where (!as', !m')
14:36:04 <albeit> Ah so its building up a ton of pairs?
14:36:11 <mm_freak> afleck: correct
14:36:12 <davean> mm_freak: uh, what 3 argumenets?
14:36:27 <johnw> it's building up pairs containing thunks
14:36:29 <mm_freak> davean: (>>=) :: (e -> a) -> (a -> e -> b) -> e -> b
14:36:54 <johnw> davean: as in: m >>= f $ e
14:37:05 <afleck> so g (f x) has type (e -> b), and g (f x) x has type b
14:37:12 <afleck> which seems like what you want
14:37:16 <davean> johnw: um, that isn't the >>= taking 3 arguements
14:37:23 <davean> mm_freak: that is definately not >>='s type
14:37:29 <johnw> (>>=) m f e
14:37:34 <ReinH> davean: for Reader
14:37:37 <mm_freak> afleck: not quite
14:37:41 <johnw> depends on how you look at it
14:37:52 <johnw> >>= either takes two arguments and returns a function, or takes three arguments, same diff
14:37:52 <mm_freak> davean: type Reader = (->)
14:37:53 <ReinH> I prefer to look at it as taking two arguments
14:38:03 <mm_freak> davean: where ask = id
14:38:38 <afleck> mm_freak: does g (f x) have type (e -> b)?
14:38:42 <ReinH> since that doesn't require me to consider a special exception for the Reader instance of (>>=)
14:38:46 <ReinH> they all work equivalently
14:38:59 <mm_freak> afleck: oh, sorry…  my bad =)
14:39:05 <mm_freak> afleck: and yes, it looks correct to me
14:39:13 <mm_freak> afleck: compile it =)
14:39:20 <mm_freak> if it's incorrect, you'll get a type error
14:39:35 <mm_freak> because there is only one (non-bottom) way to define (>>=) for readers
14:39:39 <afleck> thank god, it finally works
14:39:49 <albeit> Just so I understand, when I'm putting bangs on step (!as, !m), I'm forcing step to evaluate each item in the pair its provided. Why do I need to that in the where as well?
14:40:07 <mm_freak> albeit: you have to use 'seq' there
14:40:15 <mm_freak> albeit: x `seq` y `seq` (x, y)
14:40:22 <mm_freak> when returning the result from the folding function
14:40:26 <davean> mm_freak: I wouldnt consider it valid to drop parens like that
14:40:42 <mm_freak> davean: then you don't consider equality equality =)
14:40:49 <mm_freak> because a -> b -> c = a -> (b -> c)
14:40:49 <olalonde> is there a generic function to test whether an element is in a list? other than: length (filter (==ele) ls) > 0
14:41:00 <albeit> mm_freak: I have to? It worked with the bangs?
14:41:10 <srhb> olalonde: elem?
14:41:11 <srhb> :t elem
14:41:12 <lambdabot> Eq a => a -> [a] -> Bool
14:41:13 <albeit> But why do I need to force evaluation twice?
14:41:19 <mm_freak> albeit: it did, but you're still missing a bunch of evaluations =)
14:41:26 <mm_freak> albeit: nothing to worry about though
14:41:37 <davean> mm_freak: Equivilence and equality aren't the same thing
14:41:46 <srhb> olalonde: You could have found it by inferring its type and searching for it via hoogle @hoogle a -> [a] -> Bool
14:41:47 <mm_freak> olalonde: null
14:41:53 <mm_freak> oh
14:41:57 <afleck> @pl \f g x -> g (f x) x
14:41:57 <lambdabot> flip flip id . (ap .) . flip (.)
14:41:57 <mm_freak> no, elem =)
14:41:59 <mm_freak> sorry, misread
14:42:03 <olalonde> thanks
14:42:08 <mm_freak> davean: but in that case it's equality
14:42:15 <srhb> OK, I lied by not bringing in Eq. :P
14:42:18 <srhb> But it would work
14:42:19 <mm_freak> davean: so it's both =)
14:42:19 <olalonde> srhb: thanks for the tip
14:42:21 <albeit> mm_freak: Would you mind explaining the difference between (!x, !y) and x `seq` y `seq` (x,y)?
14:42:22 <srhb> @hoogle a -> [a] -> Bool
14:42:23 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
14:42:23 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
14:42:23 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
14:42:35 <mm_freak> albeit: the former forces the arguments, the latter the result
14:42:52 <ReinH> mm_freak: eh?
14:42:58 <ReinH> they are equivalent iinm
14:43:01 <srhb> olalonde: Finding functions based on the type that you can figure out they would have is very powerful :-)
14:43:02 <mm_freak> albeit: so the last or second last tuple will remain with unevaluated components
14:43:03 <ReinH> the former is sugar for the latter
14:43:17 <mm_freak> ReinH: (\(x, y) -> (f x, g y))
14:43:49 <mm_freak> ReinH: "\(!x, !y)" vs. "let !x' = f x; !y' = f y in (x, y)"
14:44:15 <supki> @@ @hoogle @type \ele ls -> length (filter (==ele) ls) > 0
14:44:16 <benmachine> > (\ (_, _) -> () ) undefined
14:44:17 <lambdabot>  Prelude elem :: Eq a => a -> [a] -> Bool
14:44:17 <lambdabot>  Data.List elem :: Eq a => a -> [a] -> Bool
14:44:17 <lambdabot>  Prelude notElem :: Eq a => a -> [a] -> Bool
14:44:17 <lambdabot>  *Exception: Prelude.undefined
14:44:24 <mm_freak> ReinH: the difference is in whether you force the argument or the result
14:45:06 <ReinH> let (!x,!y) = e in b <=> let { t = case e of (x,y) -> x in x `seq` y `seq` (x,y); x = fst t; y = snd t } in b
14:45:25 <olalonde> srhb: indeed :)
14:45:32 <monochrom> the difference between forcing an argument and forcing a result (a result that is an argument in recursion) is usually just an off-by-1 difference and not worth sweating over
14:45:54 <monochrom> but I still like forcing the result :)
14:46:10 <mm_freak> ReinH: you're out of context, i guess
14:46:14 <ReinH> mm_freak: I guess so
14:46:22 <mm_freak> ReinH: this is about the very last step of a strict left fold
14:46:28 <ReinH> Ah.
14:46:30 <mm_freak> well, the last recursive step
14:46:32 <olalonde> just wrote a password strength checker https://gist.github.com/11270610
14:46:58 <srhb> olalonde: Never use foldl
14:47:07 <mm_freak> > foldl' (\(!x, !y) z -> (x+z, x*z)) (0, 1) [undefined] `seq` ()
14:47:08 <lambdabot>  ()
14:47:14 <srhb> Its existence is a horrible mistake.
14:47:22 <monochrom> oh! I mean forcing the result that is passed down to recursion. e.g., f x = f $! (x+1)  (vs f !x = f (x+1))
14:47:22 <olalonde> ah didn't know
14:47:33 <mm_freak> > foldl' (\(x, y) z -> let !x' = x+z; !y' = y*z in (x', y')) (0, 1) [undefined] `seq` ()
14:47:35 <lambdabot>  *Exception: Prelude.undefined
14:47:39 <mm_freak> ReinH: there's the difference
14:47:53 <ReinH> olalonde: you have discovered `any' :)
14:48:19 <olalonde> oh yes... just saw the solution used any... the code is much cleaner haha
14:49:08 <olalonde> I understand any is a better choice here but why "never use foldl" ?
14:49:23 <mm_freak> olalonde: foldl is unnecessarily non-strict
14:49:34 <srhb> olalonde: It will not allow you to walk through a list lazily, but on the other hand not be strict enough to not break your program
14:49:41 <srhb> It's in that non-sweet spot of badness.
14:49:57 <mm_freak> olalonde: a foldl-based sum function will not return the sum, but the addition…  you will have "1 + 2 + 3" in memory rather than "6"
14:49:58 <olalonde> ah ok, is there a better alternative?
14:49:58 <monochrom> foldl is too non-strict for its purpose. and its purpose requires more strictness 99.9999% of the time
14:50:08 <mm_freak> olalonde: foldl'
14:50:09 <olalonde> ah I see
14:50:13 <olalonde> ok thanks
14:50:32 <jmcarthur> most uses of foldl are strict, but it doesn't provide the necessary seq to inform ghc of that fact
14:50:34 <srhb> olalonde: Really, foldl' should be the default. Everyone will get bitten by this. You just happened to write a program that won't crash. :-)
14:50:40 <monochrom> the non-strictness of Haskell 98 foldl was probably because not enough thought put into it in early days
14:50:46 <geekosaur> foldl is kinda a wart we inherited from a very conservative language specification, and is rarely appropriate.
14:50:50 <StoneToad> srhb: is there ever a case where you would want fold and not fold'?
14:50:57 <joelteon> foldl is useful for AppE
14:51:02 <mm_freak> monochrom: i read somewhere that strict left folds already existed before h98
14:51:08 <mm_freak> or haskell for that matter
14:51:08 <jmcarthur> joelteon: AppE?
14:51:12 <mm_freak> so the problem was known =)
14:51:12 <joelteon> yeah, template haskell
14:51:18 <joelteon> folding function application over an argument list
14:51:18 <geekosaur> StoneToad, there are cases. they're just not very common.
14:51:20 <olalonde> is that related to tail recursion? or is that a different thing
14:51:22 <mm_freak> my guess is that 'seq' was added too late
14:51:23 <joelteon> since function application is left-associative
14:51:25 <ReinH> olalonde: it isn't.
14:51:44 <jmcarthur> joelteon: but is foldl better than foldl' for that?
14:51:49 <geekosaur> tail recursion is kinda a non-thing because haskell calls work completely differently from those of strict languages
14:51:50 <joelteon> oh
14:51:50 <monochrom> hmm, I think you're right, joelteon
14:51:55 <zoomshorts> sombody wanna verify my nooby list is setup correctly?
14:51:57 <joelteon> I thought you guys were talking about left folds, not strict left folds
14:52:04 <joelteon> i retract my statements
14:52:07 <shachaf> There are some uses of foldl.
14:52:17 <zoomshorts> pls go ultranoob for 5sec
14:52:32 <srhb> zoomshorts: Pose your question :)
14:52:32 <zoomshorts> chellLayout = onWorkspaces ["I","II","III","IV","V"]
14:52:34 <StoneToad> geekosaur: can you think of any off the top of your head?
14:52:37 <monochrom> ok, I'll weaken my probability from 99.9999% to 99.99% :)
14:52:40 <zoomshorts>                 . gaps [(U,40) (R,40) (D,40) (L,40)] $ tiled ||| Mirror tiled ||| Full
14:52:43 <zoomshorts>                 $ onWorkspace "M" tiled
14:52:45 <srhb> Holy
14:52:45 <joelteon> oh lord
14:52:46 <StoneToad> I feel like knowing an example would help my 'groking' haskell
14:52:47 <srhb> Use lpaste
14:52:48 <jmcarthur> zoomshorts: please use lpast
14:52:50 <jmcarthur> e
14:52:57 <nh2> in ghc, is there a -Werror flag that I can enable for *specific* warnings?
14:53:01 <geekosaur> zoomshorts, as I commented over in #xmonad, that looks very wrong to me
14:53:01 <zoomshorts> sry 3lines
14:53:04 <shachaf> zoomshorts: Maybe ask in #xmonad. And use hpaste.org
14:53:08 <shachaf> > foldl (\_ y -> y) (error "empty list") [1,undefined,3]
14:53:09 <geekosaur> I don't know why you moved back here
14:53:09 <lambdabot>  3
14:53:10 <shachaf> > foldl' (\_ y -> y) (error "empty list") [1,undefined,3]
14:53:10 <monochrom> then again, I have never said "foldl is never useful" anyway, so I'm safe.
14:53:12 <lambdabot>  *Exception: Prelude.undefined
14:53:19 <mm_freak> olalonde: contrary to common belief, GHC does not do tail call optimization, because tail calls are optimized by the very nature of how haskell code is compiled =)
14:53:38 * monochrom is not a fan of rules of thumb
14:53:39 <nh2> I want -Werror, but ONLY for uninitialized record fields
14:53:41 <joelteon> or to be more clear, it *does* do tail call optimization; it does this by compiling a program
14:53:45 <olalonde> mm_freak: ah ok!
14:53:51 <mm_freak> olalonde: when you write "f(); g();" in C, then f returns and g is called…  in equivalent haskell code more likely 'f' will jump to 'g' directly =)
14:54:12 <jmcarthur> mm_freak: i would further argue that "tail call optimization" in generall, haskell or not, is not an optimization at all, but that non-tail calls are simply an additional feature which require stack space :)
14:54:16 <jmcarthur> *general
14:54:18 <StoneToad> shachaf: aaah, thanks, yes, I see how you would need the lazy one in that case
14:54:34 <mm_freak> jmcarthur: hehe yeah, you could say that =)
14:54:49 <monochrom> additional feature...
14:54:59 <olalonde> so basically the difference between foldl and foldl' is that foldl's "memory" grows linearly while foldl' memory stays constant?
14:55:09 <monochrom> "upsize your stack for $0.99 more!"
14:55:18 <mm_freak> jmcarthur: unfortunately that's not what the popular compiler handbooks teach and what most compiler writers think =)
14:55:27 <StoneToad> english apostrophes messing with prime notation ftl D:
14:55:34 <srhb> olalonde: Given a sufficiently strict folding operator, ish.
14:55:42 <jmcarthur> mm_freak: i have a tendency to be unafraid of disagreeing with the majority
14:55:57 <mm_freak> jmcarthur: just like myself
14:56:00 <olalonde> lol ok
14:56:20 <mm_freak> jmcarthur: i guess haskell bends you to that attitude
14:56:20 <olalonde> I'll just remember to use foldl' for now :)
14:56:24 <srhb> olalonde: But that's a matter of choosing the appropriate fold for the appropriate task
14:56:31 <mm_freak> olalonde: s/for now/forever/ =)
14:56:59 <mm_freak> olalonde: when you need foldl, you'll know it…  when you don't know, you don't need it =)
14:57:13 <monochrom> I don't think it is worth arguing the precise semantics of "what is optimization" and "how naive should code generation be when optimization is turned off"
14:57:24 <olalonde> ok :)
14:57:48 <monochrom> but there are philosophical channels if you need :)
14:57:49 <mm_freak> monochrom: i don't think that's what we do…  also because GHC-generated code is horrible when optimization is disabled =)
14:58:48 <jmcarthur> monochrom: there are many optimizations which are basically required for a practical/sane implementation. i prefer to think of such optimizations as fundamental instead of "just" optimization, regardless of whether they can be enabled or disabled, or whether they are the "naive" thing to do
14:59:06 <srhb> olalonde: If you want more insight, you could try implementing length with folds
14:59:08 <mm_freak> i usually disable optimization for development, but in some cases i had to reenable it, because the resulting code was annoyingly slow
15:00:22 <ReinH> jmcarthur: fsvo "practical/sane". It's a langauge game all the way down.
15:00:32 <mm_freak> monochrom: btw, by your notion a compiler could just produce an executable with a source code interpreter built into it =)
15:00:51 <jmcarthur> ReinH: they are easier to define in the context of what the language/compiler are designed for
15:00:53 <monochrom> no, I don't have any notion
15:01:30 <monochrom> perhaps I do.
15:02:00 <monochrom> yes, I accept that as one option.
15:02:12 <jmcarthur> mm_freak: I'm not sure I even see that as necessarily a "bad" compiler.
15:02:30 <ReinH> haha
15:02:40 <mm_freak> jmcarthur: i don't see that as a "compiler" to begin with, but it's not something you could capture formally
15:02:44 <srhb> Compilepreter.
15:02:46 <mm_freak> jmcarthur: or at least not something i do
15:03:02 <jmcarthur> mm_freak: e.g. maybe it's actually just preparation for JIT
15:03:13 <ReinH> So basically "the only way to make a stand-alone executable for an interpreted langauge"
15:03:29 <ReinH> Which people definitely actually do.
15:03:34 <mm_freak> but i think it's fair to say that the straightforward STG-to-native transformation can be said to be "naive code generation"
15:03:47 <jmcarthur> sure
15:04:11 <mm_freak> in other words, you can't compile common lisp =)
15:04:43 <afleck> is there any good use for ((->) e) besides the reader monad?
15:05:01 <jmcarthur> you mean you can't partially apply the interpreter to the program and specialize the result for the target machine? strong claim :)
15:05:07 <ReinH> afleck: it has a nice Functor instance.
15:05:13 <ReinH> And a nice Applicative.
15:05:14 <olalonde> mm_freak: srhb: does the same advice apply to foldr? should I use foldr' instead of foldr?
15:05:20 <srhb> olalonde: Nope
15:05:31 <srhb> olalonde: There is no sensible foldr'
15:05:45 <afleck> ReinH: the functor instance seems kind of trivial
15:05:57 <jmcarthur> olalonde: foldr is best when you want to consume the list lazily, in which case you definitely don't want foldr'
15:06:02 <srhb> olalonde: And foldr should be used when the right-hand argument of your function is nonstrict.
15:06:04 <ReinH> afleck: It is, but trivial does not imply useless
15:06:04 <bennofs> afleck: I use it all the time
15:06:09 <silasm> afleck: the applicative instance is fun, because it's the 2 basic combinators.
15:06:12 <ReinH> we use it all the time
15:06:12 <olalonde> ok
15:06:36 <banister> ReinH when's the next haskellcast coming out? :P
15:06:44 <jmcarthur> afleck: the Functor instance is just fmap = (.). we use function composition *everywhere* :)
15:06:47 <ReinH> banister: ugh, working on it. Scheduling--
15:06:48 <bennofs> :t fmap (+1) . (+)
15:06:49 <lambdabot> Num a => a -> a -> a
15:06:50 <mm_freak> afleck: you use ((->) e) all the time =)
15:06:55 <banister> ReinH sweet show btw
15:06:56 <mm_freak> afleck: you do use functions, don't you? =P
15:06:59 <ReinH> banister: thanks :D
15:07:10 <afleck> ReinH: why would you not just use . ?
15:07:18 <afleck> as opposed to fmap>
15:07:20 <afleck> ?
15:07:29 <ReinH> afleck: you wouldn't, you would just note that (.) *is* fmap
15:07:31 <banister> ReinH do you use haskell in your day job yet or still in RoR land?
15:07:37 <jmcarthur> afleck: fmap is more generic. or maybe you want a prefix notation instead of infix and just hate using parens to say (.)
15:07:41 <mm_freak> afleck: reader-fmap is what we often refer to as Caleskell =)
15:07:42 <ReinH> (instantiated at ((->) e))
15:07:47 <mm_freak> afleck: just use (.) =)
15:08:01 <ReinH> banister: I don't even write code any more :D
15:08:11 <banister> ReinH management ? :P
15:08:15 <ReinH> banister: scrum master
15:08:20 <banister> cool
15:08:22 <ReinH> not really
15:08:29 <mm_freak> i have yet to find a sensible use case for reader-fmap
15:08:35 <ReinH> but it's easy and it gives me free time to work with haskell
15:08:44 <afleck> ReinH: how is the Functor ((->) e) defined in base?
15:08:51 <ReinH> as (.), probably
15:09:09 <afleck> ReinH: then it seems like fmap is (.), not (.) is fmap
15:09:10 <bennofs> I like fmap f . g more than (f.) . g (because of parens)
15:09:17 <ReinH> afleck: right
15:09:29 <ReinH> for ((->) e), fmap is (.)
15:09:32 <afleck> ReinH: so then why have a functor instance at all?
15:09:34 <ReinH> and (.) is fmap
15:09:43 <afleck> if you can just use (.)?
15:09:53 <ski> @src (->) fmap
15:09:53 <lambdabot> fmap = (.)
15:10:01 <afleck> i guess I don't know how (.) is defined...
15:10:06 <ReinH> @src (.)
15:10:06 <lambdabot> (f . g) x = f (g x)
15:10:06 <lambdabot> NB: In lambdabot,  (.) = fmap
15:10:08 <bennofs> afleck: because there are other functions that use Functor
15:10:46 <afleck> bennofs: I don't understand what you mean
15:11:12 <monochrom> if the criterion for including a thing in the standard library is "everyone agrees that it is useful"...
15:11:13 <srhb> afleck: You might have "other things" that compose in a similar fashion with fmap
15:11:14 <bennofs> hmm, does anyone have some examples besides lens that need a Functor constraint?
15:11:20 <monochrom> then the standard library will be pretty empty.
15:11:39 <ReinH> afleck: because it's a valid functor and sometimes you want to abstract over the choice of functor
15:11:56 <mm_freak> afleck: the choice of wording depends on whether you talk about "definition" or "generalization"
15:12:04 <mm_freak> definition:  fmap is (.)
15:12:08 <bennofs> :t (<$)
15:12:09 <lambdabot> Functor f => a -> f b -> f a
15:12:10 <mm_freak> generalization:  (.) is fmap
15:12:26 <mm_freak> but that's a poor way to generalize (.) anyway =)
15:13:19 <afleck> I'm sure I'll ascend in understanding at some point :P
15:14:48 <bennofs> afleck: if you have other functions that have a Functor constraint, like Functor f => ...., then you can also use those functions with f = (->) e if you need to
15:15:24 <bennofs> afleck: if (->) e didn't have a Functor instance, then you couldn't do that
15:15:38 <ReinH> I mostly use the Functor instance as a part of the Applicative instance.
15:15:43 <mm_freak> > mapM (+) [10,20,30] 5
15:15:45 <lambdabot>  [15,25,35]
15:16:10 <mm_freak> > sequence [sin, cos, tan] (pi/6)
15:16:12 <lambdabot>  [0.49999999999999994,0.8660254037844387,0.5773502691896257]
15:16:30 <bennofs> mm_freak: that uses the applicative instance though
15:16:43 <afleck> bennofs: alright, that makes sense
15:16:44 <mm_freak> bennofs: sure…  there aren't many useful general Functor functions =)
15:16:49 <bennofs> mm_freak: do you know of an example that only uses Functor? I wasn't able to find one :P
15:16:53 <mm_freak> bennofs: also that wasn't in response to your remark =)
15:17:10 <bennofs> mm_freak: (other than lens)
15:17:15 <mm_freak> bennofs: well, if you want to apply a function for the sake of applying a function, but ignore the result…
15:17:25 <mm_freak> > void id
15:17:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
15:17:26 <lambdabot>    arising from a use of ‘M51989982744025026820909.show_M51989982744025026820...
15:17:26 <lambdabot>  The type variable ‘a0’ is ambiguous
15:17:26 <lambdabot>  Note: there are several potential instances:
15:17:26 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:17:30 <fizruk> is there a name for f :: (Applicative f, Applicative g) => g a -> Compose f g a ?
15:17:35 <mm_freak> what?!
15:17:35 <bennofs> > () <$ id
15:17:37 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
15:17:37 <lambdabot>    arising from a use of ‘M432919882533778835720921.show_M4329198825337788357...
15:17:37 <lambdabot>  The type variable ‘a0’ is ambiguous
15:17:37 <lambdabot>  Note: there are several potential instances:
15:17:37 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:17:39 <bennofs> :t () <$ id
15:17:40 <lambdabot> a -> ()
15:17:40 <mm_freak> oh
15:17:44 <mm_freak> > void id 3
15:17:45 <lambdabot>  ()
15:17:51 <mm_freak> we failed to apply it =P
15:18:00 <bincalc> a
15:19:51 <srhb> :t (<$)
15:19:52 <lambdabot> Functor f => a -> f b -> f a
15:19:56 <srhb> Oh.
15:20:44 <ajf> Couldn't match type `[()]' with `()'
15:20:44 <srhb> const for Functors. odd.
15:20:47 <ajf> What does this mean?
15:21:05 <srhb> ajf: Got a list of (), expected ()
15:21:24 <olalonde> hmm I tried to install 2 cabal packages (SG and clipper) but both failed with ExitFailure 1
15:21:39 <srhb> olalonde: Paste the verbose output if you need help with it
15:21:40 <ajf> srhb: https://gist.github.com/TazeTSchnitzel/6f9a55c99169251b3eb1
15:21:43 <ajf> problem is line 23
15:22:09 <mm_freak> srhb: why is that odd?
15:22:22 <srhb> mm_freak: I guess I just haven't needed it. :P
15:22:26 <srhb> Or known I did!
15:22:39 <mm_freak> srhb: () <$ getLine
15:22:58 <olalonde> srhb: https://gist.github.com/11271550
15:22:58 <bennofs> ajf: well, annotateDirection is of type ... -> IO [()]
15:22:59 <srhb> ajf: annotateDirectory returns [()]
15:23:04 <srhb> ajf: Well, that
15:23:08 <srhb> and annotateFile ()
15:23:13 <srhb> You probably want forM_
15:23:14 <bennofs> mm_freak: that's a bad example, because that's just void :P
15:23:22 <ajf> forM_ discards result?
15:23:27 <bennofs> ajf: yes
15:23:28 <srhb> ajf: Yes
15:23:31 <bennofs> @ty forM_
15:23:32 <ajf> Aha
15:23:32 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
15:23:35 <srhb> bennofs >:/
15:23:37 <ajf> thanks
15:23:41 <mm_freak> bennofs: 'void' is awkward to use, so i tend to use (<$) anyway
15:23:53 <olalonde> srhb: maybe it's a problem with the package?
15:24:10 <srhb> olalonde: It is.
15:24:36 <pavonia> ajf: You can avoid these kind of problems by giving type signatures to all top-level functions
15:24:43 <srhb> olalonde: Hasn't been updated for quite a while, probably breaks on modern GHC versions
15:25:15 <srhb> I'm a bit surprised by the Num => Show
15:25:18 <srhb> Was that a thing?
15:25:24 <sipa> :o
15:25:46 <bennofs> sipa: yes
15:25:48 <int-e> Num used to be  class Show a => Num a, yes.
15:25:49 <mm_freak> srhb: if you said it was, i'd believe it
15:25:54 <srhb> int-e: Yikes!~
15:26:04 <int-e> (check the haskell 98 report)
15:26:09 <srhb> That's perverse.
15:26:12 <mm_freak> we had many totally stupid class dependencies and still miss many useful ones =)
15:26:16 <ajf> pavonia: yep, my bad
15:26:16 <bennofs> srhb: it was removed because someone wanted instance Num b => Num (a -> b) I think
15:26:25 <int-e> srhb: passing dictionaries is very expensive ... or so people thought
15:26:50 <srhb> olalonde: If that is the only issue with the package, you could easily fix it!
15:26:54 <mm_freak> how could a number not be turned into text?
15:27:07 <mm_freak> funny enough that it had a Show constraint, but not a Read constraint =)
15:27:12 <olalonde> srhb: eheh, maybe later.. just trying to play with cabal :)
15:27:22 <srhb> olalonde: OK :)
15:27:35 <int-e> mm_freak: Right. Funny that Show and Read aren't the same class.
15:27:36 <srhb> olalonde: (for the record cabal unpack packagename is a thing)
15:27:46 <srhb> olalonde: And then you can fix the source, go into the tree and cabal install it
15:27:59 <olalonde> nice
15:28:44 <monochrom> mm_freak: every computable number could be turned into text, but it could also be too costly to carry enough data with each number for turning into text
15:29:55 <mm_freak> monochrom: read my statement in context =)
15:31:12 <monochrom> I think I know the context too
15:31:44 <mm_freak> monochrom: plainly: i was just joking ;)
15:32:26 <monochrom> ok! then hahahah
15:32:45 * hackagebot propellor 0.5.1 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.5.1 (JoeyHess)
15:32:48 <mm_freak> that's the way to go!
15:35:31 <olalonde> srhb: I'm trying to run the example here now: http://hackage.haskell.org/package/gloss-1.8.1.2/docs/Graphics-Gloss.html .. it draws a white window but then it gets stuck there (OS X spinning loader shows up when i mouse over the window)  .. I'm running it from ghci (ghci example.hs) and then I type "main"
15:35:51 <olalonde> maybe the package doesn't support OS X?
15:35:52 <srhb> olalonde: Don't run it from ghci, I think
15:36:12 <olalonde> ok I'll try that.. I haven't tried compiling anything yet :P
15:36:26 <srhb> olalonde: runhaskell filename will do
15:36:34 <srhb> Pretty sure gloss at least used to have issues with ghci
15:37:31 <olalonde> oh, compiling works, great
15:37:34 <monochrom> or, still use ghci, but start ghci with "ghci -fno-ghci-sandbox"
15:37:56 <monochrom> the short story is threading issue
15:38:29 <olalonde> ok
15:38:55 <olalonde> cool, this works as well
15:42:46 * hackagebot codex 0.0.1.1 - Code Explorer for Cabal  http://hackage.haskell.org/package/codex-0.0.1.1 (aloiscochard)
15:44:50 <ajf> SO
15:44:54 <ajf> I wondered why my script didn’t work
15:45:01 <ajf> >../../Source/gg2/Scripts/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././.
15:45:02 <ajf> /././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././
15:45:02 <ajf> /././././././././././././././././././././././././././././././././././././././././././.
15:45:04 <ajf> Well.
15:51:12 <afleck> if I want to implement Free f as a functor, how can I guarantee that f is a functor so GHC doesn't get mad at me?
15:51:18 <monochrom> is that morse code? :)
15:51:46 <monochrom> instance Functor f => Functor (Free f) where ...
15:52:20 <afleck> ahh ok. I was trying to add Functor f as a type constraint to fmap, but I quickly realized that that did not work
15:55:13 <ajf> OK
15:55:25 <ajf> I need help again. This is supposed to recurse through a directory tree: https://gist.github.com/TazeTSchnitzel/6f9a55c99169251b3eb1
15:55:29 <ajf> It seems to do nothing.
15:55:35 <ajf> What am I doing wrong?
15:56:42 <pavonia> Make sure to handle "." and ".." properly
15:57:31 <ajf> pavonia: I am handling them properly
15:57:37 <ajf> hence the ‘.’ pattern-match
15:57:54 <pavonia> *and* ".."
15:58:13 <monochrom> annotate ('.':_) = nop
15:58:13 <ajf> annotatePath ('.':_) = nop
15:58:22 <ajf> heh
15:59:27 <pavonia> Oh, sorry
15:59:51 <ajf> I’m wondering is isDirectoryOrFile is the problem
15:59:52 <ajf> hmm
16:00:06 <srhb> ajf: Must be
16:00:07 <pavonia> Err wait, you'Re prependig the path
16:00:11 <ajf> Nope
16:00:41 <monochrom> well, empirically, it still gets stuck with "xxx/./././././etc". so we haven't caught everything
16:00:56 <ajf> that’s not a problem
16:02:34 <pavonia> ajf: directory </> "." won't match on ('.':_)
16:02:42 <monochrom> yeah
16:02:48 <ajf> …what
16:03:15 <ajf> oh
16:03:17 <ajf> I see the problem
16:03:30 <Ainieco> hello
16:03:31 <ajf> OH
16:03:36 <ajf> pavonia: that’s not the problem
16:03:43 <ajf> >Andreas-MacBook-Air:Profiler ajf$ ./profiler ../../Source/gg2/Scripts
16:03:53 <ajf> It stops itself before it does anything
16:03:53 <ajf> ahahahahaha
16:04:02 <Ainieco> whas there maybeHead in stdlib or containers or i'm mistaken?
16:04:21 <srhb> Ainieco: Don't think there is
16:04:25 <apples> :t listToMaybe
16:04:25 <lambdabot> [a] -> Maybe a
16:04:25 <srhb> @hoogle [a] -> Maybe a
16:04:25 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
16:04:25 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
16:04:25 <lambdabot> Prelude head :: [a] -> a
16:04:40 <joelteon> Does cabal have a conditional for whether tests are enabled yet?
16:04:40 <Ainieco> > listToMaybe []
16:04:42 <lambdabot>  Nothing
16:04:42 <Ainieco> > listToMaybe [1]
16:04:42 <lambdabot>  Just 1
16:04:44 <Ainieco> cool, thanks!
16:04:44 <srhb> Guess I'm mistaken :-)
16:05:06 <srhb> What a silly name though
16:05:26 <Ainieco> yeah, name is awkward
16:05:41 <srhb> Though I don't see the need either -- you've just exchanged handing [] for handing Nothing
16:05:48 <fizruk> when it is a good idea to put {-# INLINE f #-} ?
16:05:51 <srhb> handling*
16:06:07 <pavonia> ajf: Well yes, it matches ('.':_) on the first call and goes to nop
16:06:13 <ajf> Right
16:06:15 <ajf> I’m fixing it
16:06:41 <srhb> fizruk: When you have a function that is sufficiently big fsvo big that GHC won't inline it, even though it should
16:07:21 <ReinH> ... *and* you actually want it to be inlined
16:07:44 <fizruk> how do I know that I want it inlined or not?
16:07:52 <srhb> ReinH: Hence "should" :-)
16:08:00 <ReinH> srhb: touche
16:08:01 <ajf> it works for one iteration
16:08:02 <ajf> great
16:08:17 <ajf> hmm
16:08:48 <geekosaur> fizruk, that's kinda the problem. you know it because your code is performing worse than it should, and inspecting the GHC Core indicates that something that "should be" inlined isn't
16:09:13 <geekosaur> but determining that is itself something of an expert level thing...
16:09:18 <srhb> Reminds me: shachaf fix ghc-core! :-)
16:09:23 <Ainieco> does inlining gives one significant performance gain?
16:09:28 <geekosaur> sometimes
16:09:44 <srhb> Oh wait, it works
16:09:47 <geekosaur> sometimes it's a significant performance loss because a chance to do list fusion is lost
16:09:49 <srhb> ... why did I think it was broken?
16:09:59 <geekosaur> which is why it's tricky to figure out when it's a win
16:10:10 <geekosaur> (or stream fusion, etc.)
16:10:36 <Ainieco> geekosaur: good to know, thanks
16:11:30 * srhb thinks she's starting to have dreams about Haskell and failing to distinguish them from reality ._.
16:11:39 <Ainieco> meh, that fgl library so unsafe... got "Irrefutable pattern" somewhere inside fgl and have no idea what's wrong
16:12:21 <speckle> at compile time or run time?
16:12:29 <Ainieco> runtime
16:12:31 <speckle> ouch!
16:12:46 <Ainieco> yeah
16:13:29 <Ainieco> alas there is no alternative to fgl nowadays
16:13:31 <ajf> OK, I fixed my program :)
16:13:31 <ajf> https://gist.github.com/TazeTSchnitzel/6f9a55c99169251b3eb1
16:13:57 <ajf> Wait…
16:13:59 <ajf> !! 0
16:14:03 <ajf> Shouldn’t I just use head? :D
16:14:14 <srhb> ajf: same difference.
16:14:26 <ajf> Yes
16:14:30 <ajf> head is nicer, though
16:14:31 <olalonde> I'm trying to implement reverse this way: rev [x:xs] = (rev xs) ++ [x]   but I'm getting this error: Occurs check: cannot construct the infinite type: a0 = [a0]
16:14:59 <srhb> olalonde: You don't mean [x:xs]
16:15:08 <fizruk> geekosaur: runApT_ f g = getConst ∘ runApT (Const ∘ f) (Const ∘ g ∘ fmap getConst)  — should I inline this?
16:15:08 <srhb> (probably)
16:15:29 <srhb> olalonde: That would be a one-element list containing a non-empty list as its single element
16:15:33 <olalonde> srhb: ohhh haha :P
16:15:39 <srhb> olalonde: :-)
16:15:47 <fizruk> geekosaur: minus getConst/Const this is effectively “runApT_ f g = runApT f g”
16:15:52 <geekosaur> fizruk, I have no idea. in particular a lot depends on where it is *used*
16:16:12 <olalonde> I need a rubber duck :)
16:16:22 <geekosaur> since inlining at the use site can change how ghc generates code at the use site, which may enable some optimizations and disable others
16:16:47 <srhb> olalonde: #haskell is a great rubber duck if you can endure the torture ;-)
16:16:48 <geekosaur> cf. the fusion thing I mentioned, where the use site loses the ability to do fusion under some circumstances if something is inlined
16:18:17 <geekosaur> fizruk, I think what I would recommend, if you're not up to reading the GHC Core to see what is going on (note that I can only do it meaningfully in somewhat restricted circumstances). is that *if* you are seeing performance issues, you can try adding INLINE or NOINLINE at places that seem relevant to the slowdown and comparing the resulting performance
16:18:27 <silasm> For some reason the "!!0" reminded me of this: one of my favorite dumb moments in haskell was when I laughed for a good five minutes at 3 AM because I named my array "arr", indexed it with 'map (arr!) [x,y,z]', and read the function like a pirate.
16:18:31 <srhb> I like that the docs specify that xs must be finite for reverse. :-)
16:18:41 <srhb> silasm: arrr!
16:19:08 <srhb> olalonde: You should try to implement it with an accumulating parameter instead (to avoid the [] construction overhead)
16:19:17 <srhb> olalonde: (also, you should probably never reverse a list!)
16:19:35 <fizruk> geekosaur: ok, I see, thanks :)
16:20:04 <olalonde> srhb: right :)
16:20:04 <olalonde> right
16:20:09 <olalonde> yes well I was doind an exercise which was to reverse the text in a file
16:20:34 <srhb> olalonde: Yes, I realize. It's fine, it's just an expensive operation, but obviously may be necessary for some use cases
16:20:41 <olalonde> srhb: I noticed the implementation in prelude uses an accumulator
16:20:49 <srhb> olalonde: Yes.
16:22:06 <olalonde> srhb: (x:a) is cheaper than a ++ [x] right?
16:22:40 <olalonde> seems like something the compiler should be able to optimize
16:22:50 <srhb> olalonde: yes-ish, the main problem with your code is the constant creation and destruction of the constructor
16:23:03 <olalonde> ah ok
16:23:57 <olalonde> oops that should have been [x] ++ a *
16:24:04 <afleck> okay, the Free Monad is tough
16:24:56 <srhb> olalonde: And as you see the null case must be chopped off and then you create a new for each ++
16:25:59 <afleck> do you need separate instances of >>= for (Var x) and (FreeNode x)?
16:26:07 <afleck> separate definitions, rather
16:33:24 <fizruk> afleck: what do you mean?
16:33:24 <Ainieco> why traceShow might not output anything when i'm "cabal run" my project?
16:33:29 <Ainieco> it compiles fine
16:35:19 <afleck> fizruk: Free is defined as  data Free f a = Var a | FreeNode (f (Free f a)), where f is a functor
16:35:42 <afleck> I'm trying to make it an instance of Monad
16:36:05 <triliyn> afleck: you need to handle all cases, yes
16:36:23 <fizruk> afleck: then yes, you need “Var x >>= g” case and “FreeNode f >>= g” case
16:37:57 <srhb> Ainieco: Because the value isn't ever being used?
16:38:41 <afleck> I have Var x >>= g = g x, but I'm stuck on the fact that the f in (FreeNode f) is (f (Free f a))
16:39:12 <Ainieco> srhb: well, it was but thanks to laziness it wasn't ever evaluated because fgl throwed exception
16:39:17 <jakex> I want to write a template haskell that automatically generates NFData instances. can someone suggest some reading? I never did metaprogramming in haskell (but have in other languages).
16:39:24 <srhb> Ainieco: Same difference. :)
16:39:28 <afleck> I was thinking of double fmap, but one fmap is on f, and the other fmap would be on Free
16:39:30 <monochrom> FreeNode :)
16:39:38 <afleck> and I don't know how to do that
16:40:26 <triliyn> afleck: I don't think you need to do anything special, it should just work
16:40:53 <monochrom> I figured out Free's join before I figured out its >>=
16:42:39 <afleck> triliyn: (fmap . fmap) g f doesn't work
16:45:13 <triliyn> hmmm, actually, you don't want a double fmap
16:45:29 <triliyn> g :: a -> Free f b, not a -> b
16:45:54 <triliyn> fmap (>>= g) f, I think?
16:46:10 <triliyn> or wait
16:46:22 <triliyn> That's not quite it either...
16:46:41 <afleck> does g :: f a -> Free f b ?
16:47:20 <triliyn> It should be a -> Free f b
16:47:22 <monochrom> no, a -> Free f b
16:47:34 <triliyn> (>>=) :: m a -> (a -> m b) -> m b
16:48:21 <afleck> huh, though in free isn't the 'a' in m a really an f?
16:49:25 <monochrom> triliyn: you're on the right track. you have produced f (Free f b). there is only one step left to get Free f b, and the step doesn't really do anything
16:50:05 <triliyn> oh, right
16:50:15 <triliyn> I thought I was wrong for different reasons but I wasn't!
16:50:46 <afleck> Seems like return might help me out, but I could be off
16:51:33 <Ainieco> is it possible to see where funtion is defined from ghci?
16:52:08 <geekosaur> :info will show what module it found it in, but that won't get you a definition directly
16:52:36 <afleck> The only way I can see it is really as an fmap...
16:52:45 <monochrom> free monad is exciting! :)
16:53:14 <afleck> I tried to do the type decomposition thing like I did with ((->) e) but it did not help
16:53:23 <monochrom> afleck: fmap and >>= are involved. there is one more ingredient involved, when you see it, you will feel anti-climatic. :)
16:54:10 <Ainieco> i just want to see definition of that typeclass function https://hackage.haskell.org/package/fgl-5.4.2.4/docs/Data-Graph-Inductive-Graph.html#v:match but i can't find it anywhere
16:54:34 <Ainieco> what more experienced haskellers do in such situation?
16:55:40 <geekosaur> um? did you notice on the right hand side of that definition, there's a link?
16:55:41 <monochrom> definition of typeclass function? what does that mean? typeclass functions have definitions?
16:55:44 <geekosaur> labeled "Source"
16:56:12 <geekosaur> oh, but the link doesn;t work quite right, sigh
16:57:01 <Ainieco> geekosaur: it's a typeclass, there is no definition in it
16:57:17 <monochrom> and that is exactly to be expected.
16:57:17 <afleck> Ainieco: you could download the GHC source
16:57:19 <geekosaur> ok, you can't see it directly because yes, it's a typeclass method. you need to find the instance definition for a particular type
16:57:20 <Ainieco> found it by searching all instances of Graph typeclass
16:57:41 <geekosaur> if there had been a default implementation then that would have been shown
16:57:47 <afleck> not GHC, but the package source
16:57:48 <afleck> rather
16:57:50 <geekosaur> (or should have been)
16:58:13 <monochrom> this one doesn't have a default. I have just read it.
16:59:21 <geekosaur> yes. (as implied by the minimum implementation thing in the haddock)
16:59:25 <monochrom> if you are looking for instance code, well, instance code belong to instances, not type classes. this is a tautology.
16:59:56 <monochrom> this means your :info command should be ":info <an actual type>"
17:01:06 <monochrom> well, ok, ":info Graph" tells you about instances too. but you still have to pay attention to instances, not methods.
17:01:07 <afleck> monochrom: When I try fmap (>>= g) f it says the expected type is Free f (Free f a)
17:01:13 <afleck> which does not sound nice
17:01:23 <afleck> maybe my definition of fmap is messed up...
17:01:32 <monochrom> no, f (Free f b)
17:01:58 <Ainieco> after diving in flg source figured that the only instance of Graph is Tree, and in Tree's definition of match splitFM from FiniteMap is used which is returns Nothing for Emtpy FiniteMap and Nothing is propagated to insEdge via Tree.map
17:02:08 <Ainieco> and in insEdge only Just case is handled
17:02:17 <Ainieco> meh, it's so horrible
17:02:19 <afleck> monochrom: can we backtrack to fmap for a second?
17:02:27 <monochrom> yes
17:02:44 <afleck> fmap g (Var a) = Var (g a) ?
17:02:57 * hackagebot find-conduit 0.2.0 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.2.0 (JohnWiegley)
17:02:58 <monochrom> yes
17:03:14 <Ainieco> can i monkey patch insEdge somehow?
17:03:29 <afleck> fmap g (FreeNode a) = FreeNode ((fmap . fmap) g a)?
17:03:29 <Ainieco> or do I need to modify orginal library code?
17:05:21 <afleck> that compiles, but maybe it's not right...
17:05:39 <Ainieco> oh, thats pointless i cant change type of insEdge because it's used in tons of other places of fgl
17:06:07 <Ainieco> and it's probably easier to rewrite fgl from scratch rather than fixing its brokeness
17:07:38 <Ainieco> nice example of truly dead, unmaintained library without any chance to recovery
17:07:48 <monochrom> afleck: it is right
17:07:57 * hackagebot find-conduit 0.2.1 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.2.1 (JohnWiegley)
17:08:06 <Ainieco> using it feels like programming in cpp
17:08:28 <Ainieco> never know what will break it
17:09:09 <afleck> huh.
17:09:58 <monochrom> You don't like to be right? :)
17:10:58 <afleck> well, my error message says the expected type for the second argument of fmap in the definition of bind is (Free f (Free f a))
17:11:21 <Ainieco> probably the only reasonble way to work with it is using thick wrapper :(
17:11:28 <Ainieco> anyway, thanks for support!
17:12:44 <olalonde> let f s = (length.head.words) s   VS  let f s = length $ head $ words s
17:13:00 <olalonde> is there an important difference I'm missing or is it just a matter of taste?
17:13:28 <monochrom> I don't think you should read that deeply into a type error message
17:15:07 <afleck> monochrom: haha alright. I'm kind of stuck though, the only way I can think of getting from f (Free f a) to Free f a is using fmap
17:15:55 <monochrom> fmap cannot possibly do that
17:15:57 <silasm> olalonde: they look equivalent to me. 'f = length . head . words' is also equivalent, and I think a lot of people prefer that.
17:17:31 <olalonde> silasm: ah ok thanks
17:17:33 <afleck> monochrom: what if you had a function g :: (Free f a) -> (Free f a) -> (Free f a)
17:17:54 <monochrom> the thing that you need is introduced at a place nobody thinks of looking. therefore, when they finally find it, they feel silly.
17:18:09 <afleck> monochrom: :(
17:18:41 <monochrom> it consists of one token only. look for one token. one name. don't even look for something you have to write anew.
17:19:55 <afleck> I can think of . and $
17:20:12 <monochrom> they all have wrong types
17:20:40 <dwcook> olalonde, repeated usage of (.) is often seen as prettier than repeated usage of ($), in places where the two are interchangeable
17:21:08 <afleck> monochrom: well, 'Var' sounds like it's along the right lines
17:21:23 <monochrom> Var still has the wrong type
17:21:42 <monochrom> but I agree about "along the right line"
17:21:47 <monochrom> FSVO "line"
17:21:55 <triliyn> afleck: what's the other constructor for Free?
17:21:58 <triliyn> What type does it have?
17:22:10 <monochrom> yeah, what's the other thing on the same line as "Var" XD
17:22:34 <monochrom> FSVO "line" literally XD
17:23:20 <afleck> The other constructor is FreeNode, which has the right type I'm guessing
17:23:40 <monochrom> you can in fact ask ghci ":type FreeNode" to find out
17:24:41 <afleck> yep, you're right. That's pretty neat.
17:24:46 <olalonde> dwcook: ok thanks for the info
17:24:57 <afleck> so, fmap (>>= g) (FreeNode x)?
17:25:04 <dwcook> FreeNode constructor? Somebody making an IRC network type? :P
17:25:14 <monochrom> no
17:25:25 <dwcook> (Just kidding, I read the context)
17:25:34 <monochrom> fmap (>>= g) x :: f (Free f b). then convert to Free f b
17:25:46 <afleck> oh ok, I see
17:27:15 <afleck> monochrom: I do feel stupid
17:27:28 <monochrom> that's what I felt too when I did this
17:28:00 * hackagebot authoring 0.3.3.1 - A library for writing papers  http://hackage.haskell.org/package/authoring-0.3.3.1 (TakayukiMuranushi)
17:28:27 <afleck> monochrom: I think it's because it's not really intuitive at all what type FreeNode as
17:30:45 <afleck> monochrom: I don't even have any idea what Free is for
17:31:18 <afleck> typeclassopedia just said, hey, here's free, make it an instance of Functor and Monad
17:33:14 <triliyn> afleck: it's kind of like a functor structure that can get arbitrarily deep
17:33:25 <triliyn> (the type itself, that is)
17:33:56 <triliyn> At each step you can either stop with a Var or add another layer of the functor with FreeNode
17:35:27 <triliyn> The monad operations correspond intuitively to "recursing all the way down to the Vars at the end and growing the structure from there"
17:35:33 <afleck> triliyn: sounds like a weirdo list
17:35:56 <triliyn> It is a bit like a list, actually!
17:36:26 <triliyn> It behaves almost like a list of all the binds you've ever done
17:37:04 <triliyn> (Almost, though. The exact behavior depends on what the functor is too)
17:37:13 <afleck> It makes sense now, really.
17:37:19 <triliyn> Free [] is a kind of tree
17:37:24 <afleck> What's a Functor that would benefit from Free?
17:37:59 <shachaf> Free [] is S-expressions
17:38:00 <triliyn> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html this gives a nice example
17:38:06 <Twey> I like the list analogy
17:38:06 <c_wraith> Free [] is rose trees
17:38:12 <shachaf> No, that's Cofree []
17:38:15 <ReinH> c_wraith: Cofree...
17:38:18 <ReinH> never mind
17:39:11 <afleck> Cofree? D:
17:39:38 <c_wraith> huh?  I could swear Free [] a is either a leaf containing a single a value, or a list of Free [] a values.
17:39:47 <c_wraith> Isn't that a rose tree?
17:41:08 <c_wraith> Oh, not quite.  Rose Trees have a value at each node, then a list of children.  Ok, not quite the same.
17:42:10 <c_wraith> And looking at the definition of Cofree...  Yeah, ok, a rose tree is exactly Cofree []
17:42:44 <fizbin> Does any instance of Functor ever override (<$) for efficiency as claimed in the class haddock?
17:43:00 <hpc> @src (<$)
17:43:00 <lambdabot> (<$) = (<$>) . const
17:43:14 <fizbin> I thought if anything would that the instance for ((->) r) would, but no.
17:43:33 <c_wraith> fizbin: I'd check out parsing libraries.
17:43:51 <fizbin> hpc: That's the default definition from the class definition.
17:43:51 <c_wraith> uu-parsinglib, maybe
17:44:04 <fizbin> Hrm. Okay, will look there.
17:44:12 <dn5> looking for the best way to spawn many threads, keep running until each one finishes, and have any runtime errors bubble up to the main thread. currently using myForkIOs here: https://github.com/dangirsh/Auto/blob/master/Main.hs
17:44:24 <dn5> but that doesn't bubble up runtime errors, and seems super hacky
17:45:09 <c_wraith> fizbin: http://hackage.haskell.org/package/uu-parsinglib-2.8.1.1/docs/src/Text-ParserCombinators-UU-Core.html#P
17:45:25 <fizbin> I am a bit surprised though that the ((->) r) instance doesn't. I mean, it seems a classic case where that efficiency argument is justified, since you don't even need to examine the second argument.
17:45:37 <dwcook> dn5, look into the async package
17:46:19 <c_wraith> fizbin: the thing is, there's basically no overhead for that instance anyway
17:46:34 <fizbin> c_wraith: Good find. There I guess it lets you ignore two of the three arguments to the T data structure, so I can see it.
17:46:43 <dn5> dwcook: just what i needed, thanks!
17:46:58 <johnw`> MonadFree's wrap can go from f (Free f a) -> Free f a
17:47:29 <c_wraith> johnw: isn't that just applying a constructor?
17:47:37 <c_wraith> err, johnw`
17:48:48 <johnw`> yeah, looks like it
17:50:14 <johnw`> it's too bad that if I have a type Foo a b, I can make Foo a Category, but I have no way of making Foo a a for any a an Alternative.  I want an instance that applies only to a sub-Category
17:50:42 <johnw`> I've even written it and it makes sense, but I can't get the compiler to swallow it
17:51:38 <jakex> any gtk2hs users? I am trying to make one cell in a column editable, but without success.
17:51:53 <jakex> what functions should I look up?
17:53:59 <fizbin> > let f = undefined :: Int -> Int in 5 <$ f $ 1
17:54:00 <lambdabot>  5
17:54:42 <fizbin> Huh. I guess it doesn't need the special "efficient" version to avoid evaluating that undefined there.
17:55:31 <c_wraith> laziness is sufficient
18:00:45 <ReinH> johnw`: can you make it a monoid?
18:01:26 <johnw`> ReinH: let me try that!
18:02:04 <johnw`> yay, thanks ReinH!
18:02:50 <johnw`> find-conduit's predicates are now a semigroup and a monoid :)
18:16:18 <ReinH> johnw`: it's a single object in the category so... ;)
18:16:23 <ReinH> johnw`: yay CT really
18:16:58 <Welkin> johnw shall henceforth be known as JohnSnow
18:17:00 <ReinH> or it's an endomorphism in the category, whatever
18:17:20 <Welkin> all he needs is the sno
18:17:30 <Welkin> perhaps he can retrieve it from snobol
18:17:32 <ReinH> snoc?
18:22:49 <johnw`> they make a decent MonadPlus too, but at no real benefit
18:27:40 <jakex> anyone knows how to use this? I am trying to make a row in TreeView editable, butI am completely stuck. http://hackage.haskell.org/package/gtk-0.12.3/docs/Graphics-UI-Gtk-ModelView-CellEditable.html#t:CellEditable
18:38:24 <albeit> If I have a bunch of functions that operate on FooState = State Foo monad, and then I need some outer functions that operate on a BarState = State Bar but need to call the FooState functions, am I looking for the monad transformer StateT?
18:38:50 <johnw`> can you transform from Bar to Foo and back again?
18:39:16 <albeit> so instead of BarState = State Bar, it would be BarState = StateT Bar FooState?
18:39:29 <albeit> No, I can't, they are pretty seperate. But Bar depends on stuff that happens in Foo.
18:39:34 <johnw`> that wraps a Bar state around a Foo state, that's one way to do it
18:40:13 <albeit> Basically Foo can happen all by itself, but Bar needs to run Foo functions and pull out a result from them (but the result is not part of Foo).
18:41:06 <johnw`> then what you've suggested will work; there may be more optimal ways to do it, but that will be straightforward
18:42:02 <albeit> Since I don't quite understand transformers yet, why not learn something else... what are the more optimal ways to do it?
18:42:18 <albeit> (Not detail, just general concepts)
18:42:26 <napping> it depends how the Foo and the Bar are related
18:42:36 <napping> if you just have both Foo and Bar as independent states
18:42:41 <johnw`> transformers are a great thing to learn
18:42:47 <napping> then the monad trasnformer way is pretty good
18:43:03 <johnw`> i actually really like transformers; but I understand I'm in a minority
18:43:16 <albeit> What do other not like them?
18:44:29 <johnw`> they are theoretically a bit messy, I think
18:44:44 <johnw`> lots of complicated for something which feels like it should be simpler
18:45:26 <johnw`> like, Applicatives compose very nicely, but Monads don't compose nicely at all, so we have transformers to build a kind of vertical composition which comes with a LOT of technical overhead
18:46:32 <ReinH> Well actually..
18:46:33 * ReinH ducks
18:46:34 <jakex> if I have data Foo = Bar | Baz, and do module MyModule ( Foo ) where, users can't use Bar and Baz, corect?
18:46:42 <jakex> +r
18:46:43 <johnw`> correct
18:47:15 <johnw`> you have hidden the data constructors and I think also any type class instances
18:47:33 <enthropy> no you can't hid instances
18:47:38 <johnw`> ah, ok
18:47:45 <johnw`> you can just choose not to import them
18:48:16 <jakex> so this must be a bug then? I am supposed to use CellRendererModeEditable, but they are only exporting CellRendererMode. https://hackage.haskell.org/package/gtk-0.12.4/docs/src/Graphics-UI-Gtk-ModelView-CellRenderer.html
18:48:19 <enthropy> right, you can't import something from a module without getting the instances that the module imported/defined
18:48:56 <enthropy> @type toEnum
18:48:57 <lambdabot> Enum a => Int -> a
18:49:09 <jakex> newer version exports CellRendererMode (..)
18:49:18 <enthropy> CellRendererModeEditable == toEnum 2 -- probably
18:49:41 <napping> albeit: I think it's usually cleaner to write code that just has constraints like MonadState, rather than expose a monad transformer stack directly
18:52:07 <dwcook> Would be silly if they expected you to use toEnum, not just because toEnum is unsafe
18:53:10 * hackagebot find-conduit 0.2.2 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.2.2 (JohnWiegley)
18:54:53 <albeit> Alright, I'll keep learning about transformers and check out MonadState
18:54:55 <albeit> Thanks guys
18:55:02 <jmcarthur> @hoogle Int -> [a] -> Maybe a
18:55:02 <lambdabot> Prelude (!!) :: [a] -> Int -> a
18:55:03 <lambdabot> Data.List (!!) :: [a] -> Int -> a
18:55:03 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
18:55:09 <jmcarthur> sadness
18:55:35 <jmcarthur> never quite realized we lacked that
18:56:03 <napping> albeit: transformer are really nice for defining a monad that has all the features you want
18:56:09 <dwcook> jmcarthur, you can find it in a package called something like safe, if I recall
18:56:41 <dwcook> jmcarthur, http://hackage.haskell.org/package/safe-0.3.4/docs/Safe.html#v:atMay
18:56:42 <jmcarthur> meh
18:56:58 <jakex> dwcook I think it is an oversight they corrected in newer version. anyway, toEnum worked!  thanks enthropy
18:57:00 <enthropy> > "jmcarthur" ^? ix 3
18:57:01 <lambdabot>  Just 'a'
18:57:09 <ion> Just a what?
18:57:22 <ReinH> > [] ^? ix 1
18:57:23 <lambdabot>  Nothing
18:57:26 <ReinH> oh darn
18:57:26 <jmcarthur> > lookup 3 $ zip [0..] "jmcarthur"
18:57:26 <dwcook> Lens to the rescue
18:57:27 <lambdabot>  Just 'a'
18:57:28 <ReinH> enthropy: :p
19:07:02 <structuralist> when optimizing, how do you figure out why something is being evaluated if you think it doesn't need to be?
19:19:03 <johnw`> i use trace
19:19:08 <johnw`> since that only prints if something is evaluated
19:19:26 <johnw`> then just keep backing out the trace
19:39:50 <augur_> http://www.reddit.com/r/haskell/comments/23x3f3/lenses_dont_compose_backwards/
19:42:49 <byorgey> augur_++
19:42:55 <byorgey> nice explanation.
19:43:05 <augur_> byorgey: thank you :)
19:43:28 <ReinH> augur_: oh that's you. Nice.
19:43:30 <ReinH> byorgey: hai
19:43:47 <augur_> byorgey: i think its important that we have good communication of ideas, and unfortunately, that is very much lacking in haskell :\
19:44:52 <byorgey> augur_: I agree good communication is very important, though I am more of a glass-half-full sort.
19:45:01 <byorgey> hi ReinH
19:45:08 <ReinH> augur_: we don't need to communicate *ideas*. Ideas are imprecise. Types are precise. /s
19:45:44 <byorgey> ReinH: the problem is that brains aren't precise.  No one actually thinks directly in types.
19:45:56 <ReinH> Maybe GHC 7.12 will introduce a patch.
19:46:07 <byorgey> for brains?
19:46:09 <ReinH> Yes.
19:46:54 <structuralist> does ghc ever just decide to make things to evaluate as an optimization than might backfire in some cases? I can't figure out what's going on in my code
19:47:05 <byorgey> . o O ( TypoDerm HQ )
19:48:51 <augur_> ReinH: :P
19:48:57 <augur_> byorgey: i think we think in types!
19:48:59 <dwcook> structuralist, posting it would be a good start to getting help. Your speculation is too vague to go off of
19:49:01 <augur_> byorgey: just not those :(
19:50:11 <structuralist> dwcook: trying to figure out how to make a self-contained example right now... but the question is an independent yes/no, isn't it?
19:51:34 <dwcook> structuralist, I can't figure out what your question means in a concrete way
19:52:10 <johnw`> structuralist: no, it doesn't do speculative evalution
19:52:25 <johnw`> that's been proposed, and even implemented before, but never made it into a GHC release
19:52:43 <structuralist> ok, thanks
19:58:19 * hackagebot find-conduit 0.2.3 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.2.3 (JohnWiegley)
19:58:49 <johnw`> yay, find-conduit finally has some docs (still waiting on Haddocks generation, though)
19:59:25 <johnw`> is there anyone with an interest in Windows support who'd be willing to follow the approach taken by stream-commons and adapt it for file-conduit?
19:59:43 <johnw`> I need to conditionalize the use of FileStatus, and the various functions that query it
20:00:12 * johnw` treats #haskell like a big extended Hackathon :)
20:06:39 <ReinH> johnw: it isn't?
20:07:47 <jle`> if it's not, i'm going to have to adjust my resume
20:08:56 <solrize> woah, galois just open sourced cryptol?
20:09:30 <solrize> Cryptol version 2 is now released as open source under a 3-clause BSD license. Our goal is that it becomes a widely adopted standard for expressing cryptographic algorithms.
20:12:58 <ReinH> solrize: where are you seeig this?
20:13:39 <solrize> ReinH, http://www.cryptol.net/
20:13:51 <solrize> https://news.ycombinator.com/item?id=7642434
20:13:57 <solrize> is where i found out about it
20:14:24 <mayski> Wow that is really nice, thanks
20:18:21 <ReinH> Pretty awesome.
20:18:35 <qin_> hi?
20:19:10 <qin_> what's this?
20:23:46 <mayski> what's what? :)
20:24:03 <mayski> oh whoops
20:29:09 <Algebr> How can I compile without ghc making .hi/.o files? I have used ghc --make Main.hs, and tried ghc Main.hs -o MyApp, but I still get these .hi and .o
20:29:30 <johnw> Algebr: you could compile from the /tmp directory
20:29:44 <johnw> here=$PWD ; cd /tmp ; ghc -i$here --make Main.hs
20:30:15 <Algebr> johnw: I don't understand why these files are even made, gcc doesn't make stuff like this
20:31:31 <ReinH> Algebr: Well, ghc isn't gcc.
20:32:08 <ReinH> Or set up cabal for your project and have it automatically compiled into ./dist/
20:32:09 <heatsink> gcc makes temporary files
20:32:21 <heatsink> it just puts them in temporary directories so you don't see them
20:32:35 <heatsink> You can use gcc --verbose to see where it puts them
20:32:52 <johnw> for the simple case of "gcc foo.c", I think gcc can use pipelines to avoid temporary files
20:35:03 <Algebr> ReinH: Ah, that's what I should be doing anyway, having cabal take care of this.
20:35:03 <Algebr> Is making ghc-pkg a real package manager basically a low-priority item?
20:35:20 <johnw> maybe even negative-priority
20:35:57 <Algebr> heatsink: Oh wow, I didn't know that.
20:36:06 <Algebr> johnw: Why negative?
20:36:29 <johnw> what would the value be?  a real package manager is a lot of work to get right, and keep right
20:37:04 <Algebr> because the current way of uninstalling packages, unregister, is a hack.
20:37:33 <johnw> use cabal-delete
20:37:42 <johnw> and I think 'cab' can do it a good job too
20:38:01 <Algebr> not familiar with either..
20:38:17 <johnw> https://github.com/iquiw/cabal-delete
20:38:22 <johnw> i've been using that for a long time
20:38:33 <johnw> recursive deletion of all install products, yum
20:38:47 <ReinH> cabal install cabal-install is dual to cabal delete cabal-delete?
20:39:04 <Algebr> wat, why isn't this part of cabal ?
20:39:10 <johnw> lol
20:39:26 <ReinH> oh hey Bird's Introduction to FP 1st ed. is available for free as a pdf!
20:39:28 <ReinH> cool
20:39:34 <heatsink> One lets you install packages, the other prevents you from deleting them.  A bit like initial vs final algebra?
20:39:34 <johnw> link!!
20:39:36 <ReinH> Now I can feel ok about recommending it to people
20:39:36 <Algebr> ReinH: Link!
20:39:40 <ReinH> http://www.nlda-tw.nl/janmartin/vakken/TFIT/Extra%20materiaal/Bird_Wadler.%20Introduction%20to%20Functional%20Programming.1ed.pdf
20:40:03 <ReinH> since they won't have to spend $60
20:40:27 <Algebr> Philip Wadler once randoming sent me a tweet.
20:40:31 <Algebr> randomly.
20:40:33 <ReinH> Algebr: hah
20:40:34 <ReinH> nice
20:40:47 <johnw> ask him to restate his tweet in the form of a monad comprehension
20:41:07 <ReinH> Oh also this http://www.e-booksdirectory.com/listing.php?category=533
21:17:00 <l4u-> for a string that will be modified upon IO, how should I deal with it?
21:19:05 <johnw> l4u-: can you rephrase that question?
21:21:12 <l4u-> i have to accept a string, and a list of inputs that are string operations (editing the n-th char)
21:21:37 <l4u-> each operation is accumulative
21:21:59 <dmj``> anyone ever get "TlsException (HandshakeFailed (Error_Misc "<<timeout>>"))" when using conduits? I get this often it seems :(
21:22:07 <dmj``> kills the process
21:23:04 <l4u-> my problem is I don't how how to read a line, and edit the previously modified string.  Do I have to use a State Monad?
21:24:13 <johnw> l4u-: usually you would do something like this: fmap f getLine >>= print
21:24:28 <johnw> that applies the function 'f' to the string read by getLine, and then passes the modified string to print
21:24:53 <l4u-> for example
21:25:01 <l4u-> abcd
21:25:03 <l4u-> 1 e
21:25:05 <l4u-> 2 f
21:25:20 <l4u-> the expected outputs will be ebcd   and efcd
21:28:29 <johnw> i see
21:28:31 <l4u-> but I have no idea on storing the first result of the modified string, and pass it to the second operation
21:28:33 <johnw> yes, you'll need State for this
21:28:42 <johnw> or rather, StateT
21:28:53 <johnw> well, you could do it with plain functions too
21:29:12 <l4u-> johnw creating a recursive impure function?
21:29:15 <johnw> State is just sugar for "passing things around"
21:29:20 <johnw> yeah
21:29:40 <johnw> read the first string, then recurse on all the remaining strings, mutating the input string
21:29:48 <dmj``> > flip execState "line of stuff" $ do { replicateM_ 4 $ modify (++"h") }  :: String
21:29:49 <lambdabot>  "line of stuffhhhh"
21:33:15 <l4u-> thanks johnw i got it working. I will learn StateT later :)
21:33:20 <johnw> nice!
21:33:51 <johnw> yeah, StateT is useful to know, but imposes a learning burden for such a simple problem
21:34:12 <l4u-> i see
21:34:17 <johnw> I think ReaderT is the transformer I use the most, by far
21:38:51 <chrisw_> Does anyone know how to do bash process substitution in Haskell, perhaps using System.Process or process-conduit? Example: diff <(cat file1.txt) <(cat file2.txt)
21:39:34 <johnw> do you want to invoke "diff" with the arguments bound to named pipes?
21:39:51 <chrisw_> I believe so
21:40:03 <johnw> you could do it just that way
21:40:12 <johnw> create two named pipes, fork threads to write to them, pass them as arguments
21:43:08 <chrisw_> But the named pipes must be stored somewhere on the drive, right? It would be cool if I didn't have to do that. I imagine bash's process substitution is creating named pipes in the system temp directory so it's merely hiding the grunt work though.
21:43:30 <johnw> yep
21:43:35 <chrisw_> ok thanks
21:43:40 <johnw> you need filepaths to pass as the arguments
21:43:58 <johnw> now, you could bind to file descriptors in the spawned process
21:44:03 <johnw> but that wouldn't work with "diff"
21:44:13 <johnw> the process would have to know how to read from the two different file descriptors
21:50:02 <zacts> johnw: were you the guy who was making a scheme interpreter with haskell as the host language a while back?
21:52:15 <johnw> I don't think so
21:55:10 <zacts> oh, sorry
21:55:54 <johnw> yay!
21:56:00 <johnw> (Oops, wrong channel)
21:56:13 <jle`> you might have been overjoyed at his apology
21:56:26 <johnw> lol
22:05:55 <jle`> is it considered hipster, cool, or edgy to always use (-> a) instead of Reader a
22:06:12 <jle`> and how much smarter than everyone else does it make you seem
22:06:53 <augur_> jle`: neither, since you mean (->) a not (-> a)
22:06:54 <augur_> :)
22:07:03 <jle`> oh yeah >.>
22:07:36 <johnw> lol
22:07:47 <augur_> also, alas, you'd want to say (a ->) but the parser or whatever balks at that
22:08:09 <johnw> I thought we were already Hipster just for using Haskell at all
22:08:29 <jle`> with a capital H
22:08:39 <johnw> that's the new way to spell it
22:08:56 <jle`> i am behind the times
22:09:02 <johnw> "How come the hipster burnt his tongue?"  "He ate his food before it was cool."
22:09:22 <jle`> >____>
22:10:37 <jle`> no but really do people actually use (->) a
22:10:39 <jle`> i wonder.
22:10:51 <johnw> i don't think I ever do
22:10:52 <jle`> . o O ( wonder )
22:11:00 <johnw> I like differentiated types as much as possible
22:11:10 <chrisw_> Is there a convenient way to execute a list of IO Bool until one returns False? I'm thinking along the lines of takeWhileM_, and I've looked through monad-loops, but I'm not sure if it has what I'm looking for.
22:11:17 <haasn> jle`: I use it for join and liftM2
22:11:39 <jle`> haasn: oh, i meant, as a replacement for Reader
22:11:56 <jle`> with do notation
22:12:01 <jle`> and (>>=)
22:12:48 <haasn> I don't recall ever doing it personally. Mind that ReaderT requires a newtype
22:12:58 <jle`> sometimes when i am in Reader (and not ReaderT) I just wonder...why am i even doing this?
22:13:19 <jle`> why am i doing anything.
22:13:22 <johnw> chrisw_: monad-loops has whileM
22:13:45 <johnw> haha
22:13:51 <johnw> jle`: transformer crisis!
22:14:01 <johnw> clearly you should be using IdentityT more
22:14:10 <jle`> i didn't even know there was an IdentityT
22:14:13 <jle`> but...why not.
22:14:38 <jle`> Identity is the free identity
22:14:41 <johnw> sure there is
22:15:02 <johnw> Control.Monad.Trans.Identity
22:15:04 <johnw> bask in the glory
22:15:08 <jle`> lol
22:15:26 <jle`> i'll be sure to throw in a few runIdentity's when i unwrap my polymorphic transformer stacks
22:15:37 <jle`> because why not
22:15:43 <johnw> "This is useful for functions parameterized by a monad transformer."
22:15:48 <chrisw_> johnw, I don't see how that works on a list of IO Bool. I don't want to execute the same action repeatedly, I want to execute each action in a list until one returns False.
22:16:20 <johnw> chrisw_: so you just want [IO Bool] -> IO ()?
22:16:31 <johnw> "conditionally sequence until False"?
22:16:50 <chrisw_> Yeah, or [IO Bool] -> IO [Bool] would be fine as well
22:16:53 <johnw> that's very easy to write as a recursive function
22:17:07 <jle`> @src sequence
22:17:07 <lambdabot> sequence []     = return []
22:17:07 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:17:07 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
22:17:19 <johnw> f [] = return (); f (x:xs) = do { a <- x; when a (f xs) }
22:17:27 <jle`> but we like to discourage explicit recursion don't we
22:17:40 <johnw> sometimes explicit recursion is pellucidly clear
22:18:06 <jle`> you can try anyM id
22:18:09 <jle`> :t anyM id
22:18:10 <lambdabot>     Not in scope: ‘anyM’
22:18:10 <lambdabot>     Perhaps you meant one of these:
22:18:10 <lambdabot>       ‘any’ (imported from Data.List),
22:18:22 <johnw> anyM would stop at the first true value
22:18:27 <jle`> oh
22:18:28 <johnw> he'd need allM
22:18:29 <jle`> allM?
22:18:30 <jakex> :t anyM
22:18:31 <lambdabot>     Not in scope: ‘anyM’
22:18:31 <lambdabot>     Perhaps you meant one of these:
22:18:31 <lambdabot>       ‘any’ (imported from Data.List),
22:18:43 <jle`> allM id :: [IO Bool] -> IO Bool
22:18:43 <johnw> allM is pretty much what I just wrote
22:18:44 <chrisw_> I think allM
22:18:46 <jle`> darn boolean blindness
22:18:51 <johnw> if I had returned IO Bool
22:19:14 <chrisw_> allM only works because of laziness, right?
22:19:23 <jle`> who indents 8 spaces!
22:19:30 <jle`> no, allM is basically what johnw wrote
22:19:46 <jle`> if haskell was a strict language, it would work the same way
22:19:51 <jle`> unless your list is infinite
22:19:57 <jle`> in which case oops
22:20:25 <chrisw_> ok cool, thanks everyone
22:21:00 <jle`> np
22:21:04 <jle`> is chris done ever on here?
22:21:17 <johnw> jle`: sometimes
22:21:21 <jle`> what does he go by?
22:21:24 <jle`> on the cybernets
22:21:31 <johnw> chrisdone
22:21:36 <jle`> ah.
22:21:49 <johnw> he's probably waking up in an hour or two
22:27:13 <jle`> why did i ever use Data.Foldable.mapM_ in non-polymorphic situations
22:27:19 <jle`> (where i know the monad is applicative)
22:27:26 <jle`> i could have always just use traverse_ instead
22:27:49 <haasn> It does have a shorter name
22:28:07 <jle`> it makes me do those weird import Prelude hiding games :/
22:28:11 <jle`> and i also have to hide it from Control.Monad too
22:28:19 <johnw> I only use traverse_ if I _only_ have an Applicative
22:28:36 <jle`> import Prelude hiding (mapM); import Control.Monad hiding (mapM)
22:28:51 <johnw> jle`: been there, done that, 1000x
22:29:03 <jle`> and you still do it?
22:29:04 <johnw> I should just write a macro to insert those hiding imports
22:29:06 <johnw> yep
22:29:18 <jle`> i always wanted to try that whole
22:29:21 <jle`> import Prelude () thing
22:29:25 <jle`> that i heard about
22:29:31 <johnw> {-# LANGUAGE NoImplicitPrelude #-}
22:29:34 <jle`> at the start of every file, and adding them in as i needed
22:29:37 <jle`> oh yeah, that too
22:29:50 <jle`> i might be surprised at how much i need is actually in prelude.
22:29:50 <johnw> put that in .cabal, and you won't need to mention Prelude ever
22:30:05 <johnw> you'll find yourself importing Data.Int, and Data.Org
22:30:06 <jle`> wait, don't i still have to import the functions from prelude manually?
22:30:07 <johnw> Data.Ord
22:30:08 <jle`> hm.
22:30:10 <jle`> ah
22:30:11 <johnw> until you say to yourself, "wow"
22:30:23 <jle`> why would i import from prelude if they are in Data.Ord, Data.Int etc.
22:30:23 <johnw> Data.Bool
22:30:28 <johnw> you'll discover modules you didn't know existed :)
22:30:40 <johnw> there's a LOT of them
22:30:53 <jle`> i need {-# LANGUAGE OverloadedStrings #-} to say to myself "wow"
22:31:00 <johnw> you'll trade two hiding imports for like 30 imports
22:31:08 <jle`> oh.
22:31:15 <jle`> wait is this supposed to be a good thing or a bad thing
22:31:17 <johnw> the base library is nicely granular
22:31:28 <jle`> because my import lists are already ridiculously long
22:31:33 <jle`> compared to other languages
22:31:37 <johnw> you could always craft your own prelude
22:31:50 <jle`> MissingJ
22:32:00 <johnw> i created general-prelude for just this reason
22:32:05 <johnw> after going down this exact same rabbit hole
22:32:10 <jle`> is that similar to classy-prelude
22:32:15 <johnw> no, it's much less ambitious
22:32:29 <johnw> it seeks to trade general for polymorphic, but doesn't introduce new classes to make normal things more polymorphic
22:32:36 <jle`> ah
22:32:36 <johnw> trade specific for*
22:32:48 <jle`> so basically just the Prelude that edwardk is pushing for
22:32:52 <johnw> classy-prelude makes functions like "length" and "map" super-polymorphic
22:33:01 <johnw> yeah, pretty much
22:33:26 <johnw> I'd love to see us move toward an abstract prelude, and GHC support for it with better type errors
22:33:48 <johnw> but really, all it would save is for me to have to write less imports
22:33:51 <johnw> which isn't really a big deal
22:34:02 <jle`> i am hesitant to depend on general-prelude cause of the whole bitrot issue
22:34:06 <johnw> I can make any module I want exactly as abstract as I want, with a bit of effort
22:34:26 <johnw> general-prelude is really small in scope, but feel free to hack it apart to your liking and fork it
22:34:38 <jle`> http://hackage.haskell.org/package/pointless-fun-1.1.0.1/docs/Data-Function-Pointless.html wut
22:34:49 <johnw> I use .: :)
22:34:50 <jle`> oh it's just a compilation of all those various idioms people have tried to introduce
22:35:44 <johnw> I should revisit general-prelude, getting it going again; I've learned a lot since then
22:36:57 <jle`> classy-prelude is snoyman's thing right?
22:37:01 <johnw> yes
22:37:31 <johnw> it can be very convenient; I used it a lot when I worked with him.  But I don't use it for any of my own projects.  A bit too heavyweight sometimes.
22:37:44 <jle`> monotraversables was an interesting idea
22:38:03 <johnw> yes, that can be quite handy
22:53:36 <jle`> it feels weird using Maybe a as an Either a ()
22:53:53 <jle`> Nothing for a success with no information, Just a as a failure with information
22:54:19 <johnw> in those cases, I'd use a custom type
22:54:30 <jle`> not even a type synonym?
22:54:36 <johnw> a newtype, usually
22:54:41 <jle`> hm.
22:54:47 <johnw> newtypes pay dividends
22:54:55 <jle`> newtype over Maybe ?
22:55:05 <johnw> or a new ADT
22:55:19 <johnw> data MyMaybe = Success | Failed a
22:55:32 <jle`> i was thinking that, yes.
22:55:35 <jle`> but this is a very one-off situation
22:55:39 <jle`> :/
22:55:46 <johnw> it's a good habit even still
22:56:02 <jle`> true.
22:56:24 <johnw> the other day I change from a core type to a newtype, and discovered that I was using a Moniod where no reasonable Monoid existing for my use of that core type
22:56:48 <johnw> meanwhile, my fingers seem to want to choose random grammatical forms for words
23:11:22 <hengchu> hello
23:11:40 <ski> hello yourself
23:13:55 <hengchu> @help
23:13:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:14:11 <hengchu> list
23:14:49 <ski> @list
23:14:49 <lambdabot> What module?  Try @listmodules for some ideas.
23:14:58 <hengchu> @list
23:14:58 <lambdabot> What module?  Try @listmodules for some ideas.
23:15:04 <hengchu> @listmodules
23:15:04 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
23:15:07 <ski> @list dict
23:15:07 <lambdabot> dict provides: dict-help all-dicts bouvier cide devils easton elements foldoc gazetteer hitchcock jargon thesaurus vera wn world02
23:15:21 <hengchu> thanks :)
23:16:37 <ski> re ?
23:17:07 <hengchu_> @listmodules
23:17:07 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
23:17:14 <hengchu_> @list irc
23:17:14 <lambdabot> irc has no visible commands
23:18:33 <pavonia> @unlambda \x y -> (x, y)
23:18:34 <lambdabot>   unlambda: Unknown operator '\\'
23:18:46 <ski> @pointless \x y -> (x, y)
23:18:46 <lambdabot> (,)
23:18:58 <ski> @list unlambda
23:18:59 <lambdabot> unlambda provides: unlambda
23:18:59 <pavonia> What is unlambda?
23:19:03 <ski> @help unlambda
23:19:03 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
23:19:25 <pavonia> @unlambda 1 + 2
23:19:25 <lambdabot>   unlambda: Unknown operator '1'
23:19:37 <johnw> http://www.madore.org/~david/programs/unlambda/
23:20:45 <pharaun> @botsnack
23:20:45 <lambdabot> :)
23:20:48 <pharaun> hmm
23:20:50 <ski> @where unlambda
23:20:50 <lambdabot> http://www.madore.org/~david/programs/unlambda/
23:20:55 <ski> ok
23:20:56 <pavonia> @unlambda `ix
23:20:56 <lambdabot>   unlambda: Unknown operator 'x'
23:21:03 <pavonia> @unlambda `i.x
23:21:03 <lambdabot>  Done.
23:21:11 <pavonia> :S
23:21:53 <mmachenry> Is Unlambda just combinatory logic renamed and recredited?
23:33:44 <pharaun> @uptime
23:33:44 <lambdabot> uptime: 36m 56s, longest uptime: 1m 10d 23h 44m 29s
23:33:50 <pharaun> oh only 36m?
23:37:33 <pavonia> @ticker fb twtr
23:37:34 <lambdabot> FB: 60.87 -0.49 (-0.80%) @ 4/24/2014 4:00pm
23:37:34 <lambdabot> TWTR: 44.82 -1.13 (-2.46%) @ 4/24/2014 4:00pm
23:40:28 <pharaun> oh didn't know it could do that
23:41:27 <pavonia> It should support @sell and @buy too :p
23:41:48 <Taneb> @ticker fogl
23:41:48 <lambdabot> FOGL: 0.00 @ N/A N/A
23:42:05 <Taneb> Oh no, I have stocks with them!
23:42:36 <Taneb> Also, doesn't seem to have FTSE
23:43:18 <pavonia> @ticker fogl.l
23:43:18 <lambdabot> FOGL.L: 24.50 +0.25 (+1.03%) @ 4/24/2014 11:35am
23:43:56 <arrnas> data List2 a = Nil | Cons a (List2 a) deriving(Show) when i try to use this i get Not in scope: data constructor `List2' and i don't understand why this happens..
23:44:34 <shachaf> Because List2 is a type.
23:44:43 <shachaf> (And you're trying to use it as a value.)
23:46:12 <arrnas> but with data Point = Point Float Float deriving (Show)  if i write Point 2 4 it works
23:46:34 <arrnas> not really getting the difference
23:48:16 <pavonia> You're using "Point 2 4" as value, not "Float"
23:48:27 <nisstyre> arrnas: List2 is a type constructor there
23:48:38 <arrnas> right
23:48:46 <arrnas> so how would i add something to the list?
23:48:52 <nisstyre> type constructor names can be the same as data constructor names
23:49:04 <nisstyre> that is often a point of confusion for new people
23:50:48 <arrnas> so the data constructor in this case would be Nil and Cons?
23:51:04 <nisstyre> correct, those are the constructors for List2
23:51:11 <jle`> Nil :: List2 a
23:51:15 <nisstyre> they both construct something of type List2 a
23:51:17 <jle`> Cons :: a -> List2 a -> List2 a
23:52:22 <arrnas> so Nil seems to work but if i try something like Cons 5 i get No instance for (Num t0) arising from the literal `5'...
23:52:54 <jle`> are you on ghci?
23:53:01 <jle`> oh wait.
23:53:06 <arrnas> yes
23:53:22 <arrnas> oh snap
23:53:25 <arrnas> let a = Cons 5
23:53:28 <jle`> yeah
23:53:37 <jle`> look at the type of cons i guess
23:53:45 <jle`> what are you trying to do?
23:54:03 <nisstyre> that seems like a strange error to get though
23:54:08 <arrnas> basically i want to define List2 and then write an instance Monad for it
23:54:10 <jle`> yeah, something feels off
23:54:22 <arrnas> oh it kinda works
23:54:23 <jle`> let x = Cons 5 should work
23:54:30 <arrnas> No instance for (Show (List2 Integer -> List2 Integer))
23:54:32 <jle`> x :: Num a => List2 a -> List2 a
23:54:34 <arrnas> thats the problem right now
23:54:37 <jle`> ah yeah.
23:54:39 <nisstyre> arrnas: that is because it can't show a function
23:54:42 <jle`> well you can't really show a function meaningfully
23:54:46 <jle`> unless you have my .ghci
23:54:53 <jle`> or are on lambdabot
23:55:06 <jle`> or otherwise define a less-than-meaningful show instance :)
23:55:48 <mgccl> Is there a data that wraps around a Ord type by give it a largest and smallest element? of course I can write one myself but maybe there is already a library...
23:55:57 <jle`> but you probably don't want to show it anyway
23:57:11 <mmachenry> mgccl:  Bounded
23:58:19 <jle`> Bounded is a typeclass
23:58:51 <mmachenry> jle`: What do you think he meant by "Is there a data"?
