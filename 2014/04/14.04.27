00:00:24 <Yoctogon> now it's the more reasonable seq version, but i added a seq to the monad bind definition too
00:00:51 <Yoctogon> actually, adding it to the bind operation is sufficient
00:01:42 <startling> why does hlint prefer const?
00:03:14 <Yoctogon> although, now i'm getting <<loop>> on replicate..
00:04:22 <gansteed> Ahh... my stupid English...
00:05:25 <Yoctogon> oops scratch that last message
00:05:54 <Yoctogon> huh.
00:05:58 <Yoctogon> interesting
00:06:06 <Yoctogon> it worked on int, but now not on list
00:06:13 <Yoctogon> (or Integer, that is)
00:06:33 <Yoctogon> i'm guessing that it's because of list's deeper structure
00:07:59 <jle`> try writing your own seqqy map
00:08:05 <jle`> and seeing if that helps
00:08:10 <Yoctogon> ok
00:08:27 * hackagebot Salsa 0.2.0.0 - A .NET Bridge for Haskell  http://hackage.haskell.org/package/Salsa-0.2.0.0 (TimMatthews)
00:08:27 * hackagebot Salsa 0.2.0.1 - A .NET Bridge for Haskell  http://hackage.haskell.org/package/Salsa-0.2.0.1 (TimMatthews)
00:13:18 <m09> Is there a way to show how a particular expression has its typeclass instance matched? I have a "Monoid b => a -> a -> b" function and I'd like to show it matches the "Monoid b => a -> b" instance of Monoid
00:13:30 <m09> in GHC
00:13:35 <m09> GHCi*
00:14:10 <EvanR> try :info
00:14:46 <EvanR> or :t after you assign the expression to a variable with let
00:15:33 <m09> but :t will only show the basic type
00:15:39 <m09> not how it matches the Monoid typeclass
00:15:53 <m09> in my example it will only show "Monoid b => a -> a -> b"
00:16:37 <EvanR> apply it to something
00:17:28 <enthropy> I don't think there is such a feature (would be called type level debugger?)
00:18:02 <jle`> m09: there is asTypeOf and asAppliedTo ?
00:18:19 <m09> I'll look into that
00:18:51 <fizruk> :t compare
00:18:52 <lambdabot> Ord a => a -> a -> Ordering
00:19:18 <EvanR> :t compare 2
00:19:18 <fizruk> :t compare `asTypeOf` mempty
00:19:19 <lambdabot> (Ord a, Num a) => a -> Ordering
00:19:19 <lambdabot> Ord a => a -> a -> Ordering
00:20:44 <m09> to be more specific, I have this example: https://gist.github.com/m09/11339507
00:20:50 <Yoctogon> jle`: yep, this works: http://lpaste.net/103257
00:20:55 <startling> m09, Monoid b => a -> a -> c -> b
00:21:18 <Yoctogon> yey, now i can do stuff
00:21:25 <m09> startling: what do you mean?
00:21:28 <jle`> Yoctogon: yay.  but i think the xs seq might not be necessary.
00:21:34 <Yoctogon> it is.
00:21:36 <jle`> oh
00:21:40 <startling> m09, (to your first question).
00:21:44 <jle`> well then i really have no intuition to this after all
00:21:45 <jle`> v.v
00:21:45 <startling> m09: to your paste:
00:21:59 <startling> m09, ok, so Integer -> Ordering is a Monoid. Is that clear?
00:22:01 <Yoctogon> jle`: because without it it would thunk after the first element
00:22:19 <Yoctogon> doesn't have to evaluate xs
00:22:19 <m09> startling: sure it is. My problem is that I'd like to show the derivation to people during a talk
00:22:26 <startling> oh, I see.
00:23:34 <m09> because it uses two Monoids instances, a -> b and Ordering
00:23:49 <m09> and I thought it might be a bit hard to grasp without GHCi showing its work
00:23:58 <m09> but I guess I'll do it by hand, thanks for the input :)
00:24:48 <AshyIsMe> hmm
00:25:01 * enthropy wonders about setting breakpoints on class methods
00:25:06 <AshyIsMe> I have a IO (Either Reply Integer), how do I get at the Integer with a case statement?
00:25:25 <enthropy> but for now I just get: cannot set breakpoint on mempty: module Data.Monoid is not interpreted
00:25:42 <jle`> AshyIsMe: what do you want to do wiht it?
00:26:19 <jle`> you can have a function (Either Reply Integer -> b)
00:26:22 <AshyIsMe> jle`: use it in a do block
00:26:22 <jle`> and fmap it into your IO object
00:26:24 <corgifex> AshyIsMe: x <- foo; case x of Right i -> ...
00:26:24 <jle`> to get IO b
00:26:55 <jle`> ah yes well that
00:27:46 <AshyIsMe> corgifex: yeah ive got that but the "Right i" line has the error:
00:28:27 <AshyIsMe> couldnt match expected type IO (Either Reply Integer) with actual type Either t0 t1
00:28:58 <jle`> we definitely need more code
00:29:01 <corgifex> what's the actual error message?
00:29:10 <AshyIsMe> yeah i'll put together a pastebin
00:29:23 <corgifex> (the actual error message will contain a filename, line number, error location, and not "couldnt")
00:29:27 <AshyIsMe> it's using the Redis library too
00:32:31 <jle`> lol
00:34:42 <AshyIsMe> https://gist.github.com/AshyIsMe/11339706#file-watchlist-hs-L56
00:35:18 <corgifex> x <- return ... can just be 'let'
00:35:38 <corgifex> and you're not even using it
00:35:47 <corgifex> ah, but the return is wrong
00:35:59 <corgifex> ... or is it?
00:36:14 <corgifex> what's the type of runRedis?
00:37:28 <AshyIsMe> sorry, slow internet here, im getting there
00:38:01 <AshyIsMe> http://hackage.haskell.org/package/hedis-0.4.1/docs/Database-Redis.html#v:runRedis
00:38:07 <AshyIsMe> that's runRedis
00:38:10 <jle`> can you post the error?
00:38:29 <AshyIsMe> commented it on the gist
00:38:34 <AshyIsMe> twice apparently, haha
00:38:36 <corgifex> ok, shouldn't that return then be liftIO?
00:40:00 <AshyIsMe> i actually did have this working before i tried to split out nextWatchlistID into it's own function, let me go back to that, and ask my real question, heh
00:40:12 <AshyIsMe> got myself with the old X Y question
00:40:13 <corgifex> just try liftIO
00:40:30 <AshyIsMe> case liftIO nexti of ... ?
00:40:45 <corgifex> wtf
00:40:47 <jle`> nexti <- liftIO $
00:41:05 <fizruk> :t liftIO
00:41:06 <lambdabot> MonadIO m => IO a -> m a
00:41:22 <jle`> remember that you are in the Redis monad
00:41:30 <jle`> so all lines have to be of type Redis a
00:41:38 <jle`> you have an IO a
00:41:42 <AshyIsMe> ah
00:41:44 <jle`> so liftIO :: IO a -> Redis a
00:41:53 <corgifex> x <- return foo is just let x = foo
00:41:56 <AshyIsMe> so could nextWatchlistID use the Redis monad instead of IO?
00:42:06 <corgifex> sure
00:42:21 <jle`> well
00:42:24 <jle`> you can remove the runRedis
00:42:36 <jle`> and just have it be a Redis (Either Reply Integer)
00:43:00 <jle`> that's probably what you really want to do
00:43:16 <jle`> you probably don't want to...jump into IO and run a separate redis execution pipeline, from within a redis command
00:43:27 * hackagebot mime-mail 0.4.5.2 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.5.2 (MichaelSnoyman)
00:43:43 <jle`> one of the whole "points" of monads/having Redis being a monad is taht you can have several different redis commands that you can 'sequence together' and "run" all at once
00:44:16 <AshyIsMe> ah, yeah that makes more sense
00:44:21 <jle`> so keep everything in Redis a, use monadic and functor combinators to compose and sequence your Redis a commands, and then wait as long as possible (that is, build up the biggest Redis command chink you can do) before using runRedis
00:46:25 <jle`> if you have ever used the State monad, it's a similar sort of interface
00:46:33 <jle`> er, usage philosophy
00:46:58 <AshyIsMe> ok this is the working code i had originally: https://gist.github.com/AshyIsMe/11339878#file-watchlist-hs-L64-L66
00:47:17 <AshyIsMe> what i wanted to do was pull those highlighted lines out into it's own function
00:47:26 <corgifex> yeah, that should be trivial
00:47:29 <jle`> you can just pull it out as-is
00:47:41 <AshyIsMe> so i dont have to repeat them when i make the setWatchlist function for the KeywordWatchlist type
00:48:03 <corgifex> foo wl = if watchlistID wl > 0 then return (Right (watchlistID wl) else incr "..."
00:48:11 <jle`> f wl = if watchListID wl > 0 then return ... else ...
00:48:14 <corgifex> nexti <- foo wl
00:48:15 <jle`> nexti <- f wl
00:48:19 <jle`> oh
00:48:20 <corgifex> no u
00:48:25 <jle`> >.>
00:48:35 <jle`> well this is awkward
00:49:11 <jle`> if you pull it out into its own function then you can use guards instead of if statments
00:49:31 <corgifex> foo (watchlistID -> wid) | wid > 0 = return (Right wid) | otherwise = incr "..."
00:50:41 <AshyIsMe> i think i just messed myself up by trying to type annotate nextWatchlistID
00:50:51 <AshyIsMe> when i could have just let ghc figure it out
00:50:57 <corgifex> this is something I really like about Haskell: refactoring/extracting stuff into functions is extremely mechanical
00:51:07 <startling> agreed.
00:51:48 <startling> I've been thinking about that a lot lately.
00:52:15 <startling> Adding a monad transformer to a piece of code is *trivial*. This is nowhere near as easy in e.g. clojure
00:52:27 <startling> your loop is stateful? oops, you need to recur with an extra argument
00:52:44 <corgifex> :t if ?watchListID ?wl > 0 then return (Right (?watchlistID ?wl)) else ?incr "..."
00:52:46 <lambdabot> (?wl::t, ?watchlistID::t -> b, ?watchListID::t -> a, ?incr::[Char] -> m (Either a1 b), Ord a, Num a, Monad m) => m (Either a1 b)
00:52:52 <corgifex> oops
00:53:11 <corgifex> :t if ?watchlistID ?wl > 0 then return (Right (?watchlistID ?wl)) else ?incr "..."
00:53:12 <lambdabot> (?wl::t, ?watchlistID::t -> a, ?incr::[Char] -> m (Either a1 a), Ord a, Num a, Monad m) => m (Either a1 a)
00:53:16 <jle`> a lot of this is due to the emphasis on equational reasoning and following the monad laws
00:53:29 * hackagebot sqlite-simple 0.4.6.1 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.6.1 (JanneHellsten)
00:53:31 * hackagebot http-client 0.3.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.2 (MichaelSnoyman)
00:53:33 * hackagebot http-conduit 2.1.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.2 (MichaelSnoyman)
00:53:45 <corgifex> :t if ?watchlistID ?wl > (0 :: Integer) then return (Right (?watchlistID ?wl)) else ?incr "..."
00:53:46 <lambdabot> (?wl::t, ?watchlistID::t -> Integer, ?incr::[Char] -> m (Either a Integer), Monad m) => m (Either a Integer)
00:54:15 <jle`> we are working on a language where the implementors actaully care about equational reasoning and the ability to reason about things mathematically and intuitively (fsvo)
00:54:44 <corgifex> .oO( floatuition )
00:55:56 <corgifex> http://codepad.viper-7.com/MclUwk http://www.biblegateway.com/passage/?search=Matthew+20%3A16&version=KJV
00:58:29 * hackagebot yesod-bin 1.2.9.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.9.1 (MichaelSnoyman)
01:00:17 <EvanR> need sleep
01:00:49 <Yoctogon> yeah, now that i understand how to use and apply `seq`, i don't even need the state monad for what i'm doing
01:01:01 <zipper> Good morning from Nairobi.
01:04:22 <jle`> Yoctogon: well now you have learned more and enriched yourself :)
01:04:24 <jle`> zipper: good morning
01:18:15 <redtricycle> How do I perform an function (IO) on every member of a list?
01:18:54 <klugez> redtricycle: mapM or mapM_
01:19:21 <klugez> First one gives a list of all the results, the second one just (), if you don't need the results.
01:19:41 <klugez> redtricycle: They are defined in Control.Monad
01:20:12 <redtricycle> will look into it, thanks
01:21:13 <jle`> conceptually, you can also use fmap
01:21:15 <jle`> er,
01:21:16 <jle`> map
01:21:25 <jle`> and then sequence
01:21:36 <erisco> what is the ideal library for boxed 2d arrays?
01:22:04 <no-n> I need a way to keep *.hi, *.o and executables out of my directory where I write everything (because I like to keep it very small for backups and such).
01:22:22 <jle`> if you have a list [a] and a function  (a -> IO b), you can map your function on your list to get [IO b], then you can use sequence, which executes every IO action in that list
01:24:03 <shachaf> Whoever I said things about the CPR paper to the other day, I was wrong. I meant the dynamic pointer tagging paper.
01:24:19 <AshyIsMe> hmm, well ive now got compiling code but it's still pretty repetitive
01:24:29 <enthropy> erisco: array works
01:24:54 <erisco> enthropy, are you suggesting I newtype it to add dimension information?
01:24:59 <erisco> or 'data' it I mean
01:25:08 <jle`> arrays already have dimension information
01:25:09 <AshyIsMe> there's about 2 lines of code different in each "case" of one particular function, but 15 lines or so repeated
01:25:11 <jle`> in Data.Array at least
01:25:22 <jle`> you can index on arbitrary data
01:25:22 <erisco> I must be looking at the wrong library
01:25:23 <enthropy>  Array (Int,Int) Double -- is a 2d array of doubles
01:25:25 <jle`> including tuples
01:25:42 <redtricycle> klugez: worked, thanks!
01:25:47 <redtricycle> jle`: will look into that too
01:25:51 <erisco> ah the tuple has an Ix instance, okay thanks
01:26:33 <jle`> redtricycle: in real code you would use mapM, but maybe map and sequence would be easier to understand
01:26:48 <corgifex> @src mapM
01:26:48 <lambdabot> mapM f as = sequence (map f as)
01:26:48 <jle`> but mapM f xs = sequence (map f xs)
01:26:57 <jle`> >_>
01:27:19 <corgifex> :t fmap fmap fmap sequence fmap
01:27:20 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
01:27:41 <jle`> :t mapM
01:27:41 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
01:28:06 <enthropy> erisco: or maybe repa is better. I don't think 'array' lets you slice up arrays in the same way
01:28:50 <erisco> enthropy, thankfully I have no need to update or slice the array. I simply desire to construct the entire array once and then have O(1) indexing time
01:29:57 <jle`> :t fmap (fmap sequence) fmap
01:29:57 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
01:30:12 <jle`> i don't know how to go the last step corgifex
01:31:18 <jle`> i went \f -> sequence . map f to (sequence .) . map to (sequence `fmap`) `fmap` fmap to fmap (sequence fmap) fmap
01:34:40 <jle`> : t fmap fmap fmap sequence `asAppliedTo` map
01:34:46 <jle`> :t fmap fmap fmap sequence `asAppliedTo` map
01:34:47 <lambdabot> Monad m => ((a1 -> m a) -> [a1] -> [m a]) -> (a1 -> m a) -> [a1] -> m [a]
01:34:55 <jle`> oh of course
01:44:39 <anthezium> anybody know the options that you can pass to the literate preprocessor?  i'm trying to get it to ignore bird tracks or pay attention to "\begin{spec}" in addition to "\begin{code}"
01:44:58 <anthezium> er, ghc literate preprocessor.  "unlit", i believe
01:54:37 <erisco> jle`, it seems problematic to learn the row and col bounds of Array (Int,Int) a
01:54:58 <augur_> NEW PROPOSAL
01:55:07 <augur_> <*> SHOULD BE PRONOUNCED "TIE FIGHTER"
01:55:45 <corgifex> jle`: mapM f xs = sequence (map f xs) ==> mapM = sequence .: map where f .: g = \x y -> f (g x y)
01:55:57 <corgifex> (.:) = (.) . (.) = (.) (.) (.)
01:55:58 <Iceland_jack> (|>*<|) looks more like a tie :) /s
01:56:02 <corgifex> and (.) = fmap
01:56:22 <corgifex> thus mapM = (.:) sequence map = (.) (.) (.) sequence map = fmap fmap fmap sequence map
01:56:27 <corgifex> also, map = fmap too
01:56:37 <augur_> Iceland_jack: <*> is obviously a TIE Advanced, like the one Vader flew
01:56:41 <erisco> "As you see in our applicative parser, we fmap the AST constructor onto the first sub-parser and tie fighter it with the next sub-parser"
01:56:41 <augur_> |*| is a normal TIE fighter
01:56:53 <augur_> erisco: exactly
01:56:55 <shachaf> fmap fmap fmap fmap fmap fmap = fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
01:57:11 <augur_> buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo
01:57:34 <Iceland_jack> semantic satiation satiation semantic saturation sa..
02:00:20 <jle`> is |*| stolen by syntax
02:00:23 <jle`> or can we actually use it
02:00:25 <SrPx> Is there any way to connect Haskell to unity3D? The framework is so good, but C# is...
02:00:50 <jle`> > let x |*| y = show x ++ show y in 8 |*| True
02:00:52 <lambdabot>  "8True"
02:00:54 <jle`> neat
02:01:47 <erisco> SrPx, hrm, suppose there were, is the framework conducive to pure, immutable, and lazy functional programming? I have not used Unity much but I would assume not
02:02:12 <klugez> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:%28|*|%29 - Naturally there's more than one |*| already...
02:02:58 <SrPx> erisco: I mean, if you could just use wrappers to work with unity3d from haskell, that would be great. You could just code your game logic entirely in Haskell and then just access unity3d stuff for what it is good
02:03:45 * hackagebot yesod-test 1.2.1.4 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.1.4 (MichaelSnoyman)
02:03:48 <erisco> SrPx, I suppose it depends on what systems from Unity you want to use. I am guessing the physics and graphics engines are appealing
02:04:28 <SrPx> erisco: also the fact you make a game once and it is compiled to pretty much any relevant platform...
02:04:36 <SrPx> it is a very solid platform, overall
02:05:09 <dword>  
02:05:21 <erisco> according to Don Stewart (as of 2010) there is no .NET backend for ghc http://stackoverflow.com/questions/3269062/haskell-for-the-net-platform
02:05:32 <erisco> and I am presuming that Unity is using C# + Mono
02:06:14 <erisco> or no .NET runtime for ghc, I suppose he said
02:06:52 <SrPx> ):
02:06:53 <AndyS2_> sounds like a lot of work to make entities accessible via haskell if the engine is c++ and c#(for a layman like me)
02:07:35 <erisco> however he does suggest F#. afaik it is a strict language, but that is not necessarily a bad thing for games programming
02:07:47 <AndyS2_> have you looked at ue4? at least you get full access to the c++ codebase there. no idea if that makes it easier to addon another language, but might be?
02:09:46 <AndyS2_> (they moved away from their own scripting language because of debugging issues, though, and added a graphical programming thingy called blueprints. those compile to c++, so debugging might work better) (again, I'm a total novice on this)
02:10:32 <SrPx> I have no idea about that?
02:10:35 <erisco> SrPx, actually I have a potential solution for you
02:10:52 <palo> question: I have some submodules Task.data Task.func Task.foo Task.bar. How do I create a nice module which exports all that is needed. So I can do something like import Task  and all is cool ?
02:10:53 <SrPx> I might google UE4 + haskell, but I'm looking the F# suggestion, seens nice
02:10:56 <SrPx> erisco: yes?
02:11:01 <SrPx> seems*
02:11:27 <erisco> SrPx, forget C#. Unity supports JavaScript and ghcjs is an upcoming backend for ghc that will compile to JavaScript
02:12:13 <SrPx> erisco: ah GHCJS doesn't produce fast enough code for games and... well, Unity3D doesn't actually use JavaScript but their own scripting language, UnityScript, which GHCJS's output doesn't work on ):
02:12:19 <SrPx> good try though
02:13:04 <erisco> really? I thought Unity did JavaScript
02:13:42 <shachaf> Those are invalid module names.
02:14:02 <shachaf> But a module can reëxport other modules. You probably want to do that.
02:14:32 <erisco> SrPx, hm, doing some reading suggests that the languages are syntatically similar
02:15:27 <erisco> SrPx, you might be able to do a simple translation from the ghcjs output (which is thankfully simplistic) to unityscript
02:16:32 <erisco> of course the perf implications are entirely unknown... ghcjs does a decent job for javascript wrt perf but it is tailored specifically to it
02:16:42 <erisco> no idea if unityscript will benefit in the same ways. could be awful
02:18:30 <SrPx> ah very unlikely, the ghcjs output is huge
02:18:39 <erisco> huge does not imply slow
02:19:31 <erisco> also remember that it includes the ghc runtime, and basic libraries
02:20:01 <SrPx> I mean, unlikely to translate manually to unityscript
02:20:06 <SrPx> ):
02:20:16 <erisco> no I would suggest writing a translator to do it
02:20:41 <SrPx> oh that would be hard I guess
02:20:41 <jtcwang> In conduit, how would I combine two or more Producers into one?
02:20:50 <SrPx> anyway, I didn't ever manage to get GHCJS working
02:20:57 <SrPx> I swear I have tried more than 5 times already lol
02:21:01 <SrPx> one day...
02:21:06 <erisco> SrPx, get the vagrant machine
02:21:16 <SrPx> tried that too
02:21:22 <SrPx> do you suggest a tutorial for osx?
02:21:36 <erisco> then it must have worked unless your virtualisation software is broken
02:21:59 <erisco> or are you saying you could not get the virtual machine running?
02:23:21 <erisco> if I cared about Unity I would give this a crack but alas, I do not, so it is all up to you SrPx :)
02:23:47 <startling> ghc-js worked fine for me on os x
02:24:09 <startling> 1) install ghc 7.8 2) install their cabal fork 3) cabal install in the ghcjs source directory
02:26:10 <SrPx> erisco: I don't remember, I am trying again :C
02:26:15 <SrPx> erisco: what you mean with giving this a crack?
02:26:23 <erisco> writing the translator
02:28:38 <erisco> lol it is rather infuriating that all these references say "JavaScript" or "JavaScript (UnityScript)" when they actually mean "UnityScript"
02:40:06 <SrPx> erisco: indeed it is
03:01:43 <drnet> Hi, Haskellers! I'm learning haskell and trying to make simple infinite prime number list. But have some issues.
03:01:53 <drnet> My code hangs on line 8 and I don't know why  http://lpaste.net/103261
03:04:39 <erisco> drnet, what element does it hang on?
03:05:05 <drnet> well, It does not hang when I hardcode q = 3
03:05:13 <drnet> everything >3 hangs
03:05:41 <erisco> so, the third element?
03:05:57 <drnet> yes
03:05:59 <d3lxa> in cabal info, is this possible to display all versions (especially the most recent ones)? please
03:06:06 <erisco> in that case evaluate your function by hand for the third element
03:07:05 <drnet> when I eveluate in ghci: take 3 primes, it outputs "[2,3" and hangs
03:07:29 <shachaf> drnet: Maybe you want s/ceiling/floor/?
03:07:43 <shachaf> (Not that that's a great way to implement integer square root either way.)
03:09:13 <drnet> shachaf: oh thats weird. replaced with floor and stopped hanging.
03:09:49 <lyxia> drnet: isqrt 5 == 3, the takewhile will try to test 5 which isn't computed yet
03:10:22 <drnet> Oh! I see now thanks a lot!
03:30:21 <no-n> I have a list of pairs but I need to lookup by the second value as well as the first
03:30:55 <no-n> what would be a better data structure for doing that?
03:32:53 <pavonia> no-n: Where lookup means getting the corresponding other element?
03:33:08 <no-n> pavonia: yup.
03:33:15 <pavonia> There Data.Bimap
03:33:20 <pavonia> 's
03:33:31 <pavonia> @hackage bimap
03:33:31 <lambdabot> http://hackage.haskell.org/package/bimap
03:34:29 <no-n> looks ok
03:35:16 <no-n> thanks :)
03:35:38 <d3lxa> I need to run a haskell program on stable, compiled on debian testing, the only problem is libffi6 is not in stable, what should I do? any hint please?
03:36:35 <Kinnison> backport libffi6 ?
03:37:22 <d3lxa> Kinnison: what do you mean?
03:38:16 <Kinnison> Get the source package for libffi6 from testing, and build it on stable
03:38:21 <Kinnison> Offer that alongside your haskell app
03:39:59 <d3lxa> Kinnison: ok, what I mean is that I could install libffi6 but then other dependencies like libc are going testing which is not acceptable for my server; is there a way to tell GHC/cabal to compile against libffi5 instead? or what would you do?
03:40:26 <Kinnison> Do you *need* ghc etc from testing in order to build your program?
03:40:35 <Kinnison> If not, perhaps debootstrap a stable chroot to do your builds in
03:43:55 <d3lxa> Kinnison: hehe :) that's what I've tried so far but I couldn't get my sandbox to compile :( so many dependencies and I have failure, I tought I could just get my dev sandbox packages list with version and install them in the debootstrap but that's not as smooth as expected, because GHC 7.4 != GHC 7.6
03:44:38 <d3lxa> it seems GHC 7.6 require libffi6 so I'm stuck with GHC 7.4, I think
03:45:35 <Kinnison> You could try rebuilding the 7.6 packages in your stable chroot to bind them to an earlier libffi but I can't be certain if that'll work
03:47:12 <d3lxa> I will try again in my stable debootstrap, I wish cabal was better at dependency managment, it's improving but it's still tough to get a well sandbox; that's why I keep my dev sandbox in my backups I don't want to be stuck again
03:51:08 <srhb> d3lxa: Pretty sure that's not cabal doing anything from or bad.
03:51:28 <buckmaster> any acid-state users out there who feel like answering newbie questions?
03:51:50 <srhb> buckmaster: If I can. Also just ask :-)
03:54:16 <buckmaster> srhb: cheers! I just feel rude popping in and asking :P. Just wondering, on a high level: if I use acid as storage for a web app, how would I handle persisting to disk? A host might only allow 512MB of RAM, but several gigs HDD storage. There's a line on the wiki about this, but it's a bit vague and I'm wondering if it's a problem people solve often. I'm currently using Mongo for web apps because it's relatively easy, but
03:54:54 <buckmaster> *instead of persisting, I should have said only holding a subset of data in RAM
03:55:36 <buckmaster> I'm guessing the answer is complex - even just a pointer in the right direction would be appreciated!
03:55:39 <srhb> buckmaster: I think the suggestion on that page is that you implement some manual cache-system via acid-state.
03:56:11 <srhb> buckmaster: So what you would do is ask for the data in acid-state and if it's not there, load it into acid-state. If you run out of memory, you need to decide what stuff to dump from acid-state back to disk.
03:56:22 <srhb> buckmaster: Well, not complex, but not transparent either.
03:57:28 <buckmaster> srhb: thanks. And then I assume that would preclude using the simple interface in Data.Acid.Remote? Or could I define some custom rules in my acid server that let me handle not found data?
03:57:59 <srhb> buckmaster: I haven't actually tried Data.Acid.Remote, but my guess is "yes."
03:58:36 <srhb> An easier solution is to just leave the "big data" on disk and leave the keys to find it in acid-state
03:58:49 <srhb> I'd probably do that if I ever ran out of memory, but I don't really store that much in acid-state.
03:59:17 <srhb> (As in, I don't leave binary blobs of user images in acid-state)
04:02:16 <buckmaster> srhb: for sure. I'm just trying to get my head around the idea. I'm not planning on having 512 MB of data any time soon :P. I just like to overthink things. Thanks for the brief intro. I'm not worried about binary/image data so much as actual structures (in particular, graphs) that I'd want to do atomic modifications on. At the moment, I just store each graph as a big text blob of JSON. Which sucks, but it was the easy so
04:02:41 <buckmaster> *s/atomic/small :P
04:02:43 <srhb> buckmaster: (I think you got cut off)
04:03:01 <buckmaster> srhb: last thing I wrote was 'see how I do'
04:03:16 <srhb> "easy so" here :P
04:03:33 <buckmaster> srhb: but it was the easy solution. downside is obviously, to save the thing you have to upload the whole graph blob each time. Anyway, I'm going to play around with acid-state a bit and see how I do
04:03:54 <skypers> edwardk: yesterday you told me a syntax like 2 -> Float
04:03:54 <buckmaster> didn't realise there was a message cap :P
04:04:07 <skypers> was only to demonstrate, or is it an Haskell extension?
04:04:39 <srhb> buckmaster: Thinking about it is fine, but you can make actual estimates about your data usage easily because the data type you end up storing in acid-state have fields that have predictable sizes
04:04:58 <srhb> buckmaster: Estimate size of data structure, divide memory available by that. Now you know how much you can store in acid-state.
04:06:10 <buckmaster> srhb: is estimating the size of a Haskell data structure fairly easy? I've never thought of that before. Obviously I can add up all the primitives...
04:06:23 <srhb> buckmaster: Yep, that's basically it
04:06:43 <srhb> buckmaster: Of course it's a rough estimate not considering overhead etc., but it's sufficient for almost all cases.
04:06:52 <jle`> skypers: TypeNats ?
04:06:59 <thoughtpolice> there is overhead to account for in terms of object headers for the GC, etc. but it's back-of-napkin-close-enough, for most things
04:07:20 <jle`> with type literals
04:07:24 <thoughtpolice> (GHC generally only has a small amount of overhead per object of about 1 word, IIRC)
04:07:46 <thoughtpolice> which is pretty good, I think the JVM has like 5 words of overhead when tibbe last checked.
04:08:11 <buckmaster> thoughtpolice: cheers, that's good to know
04:08:24 <jle`> skypers: https://ghc.haskell.org/trac/ghc/wiki/TypeNats/Basics
04:08:30 <jle`> if that's what you are looking for
04:09:02 * hackagebot codex 0.0.1.4 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.0.1.4 (aloiscochard)
04:11:20 <buckmaster> srhb: thanks for the chat... I'm going to digest that for a while and learn how to use acid state :P
04:11:32 <srhb> buckmaster: Luckily that's really easy :-)
04:12:15 <buckmaster> srhb: yeah I was actually very pleasantly surprised by the examples after stumbling my way through Persistent! Which is great, don't get me wrong, but wasn't easy to do outside Yesod. Could be just me :P
04:12:38 <srhb> buckmaster: I think it's fine outside Yesod, the docs are just not as good as they could be imo.
04:13:00 <srhb> Yesod'y things tend to have very Yesod'y docs, which is annoying :P
04:13:04 <buckmaster> srhb: sure thing. Also using Mongo didn't help, as it's slightly different from the SQL family of backends.
04:13:09 <srhb> Right.
04:13:22 <srhb> Well, we all know Mongo is bad and should not be used anyway, right? :-)
04:13:47 <buckmaster> srhb: I'm embarrassed to say that I'm devving on Windows and it was the first db I could get working locally :P
04:13:54 <buckmaster> which seems bizarre, but hey.
04:14:00 <srhb> buckmaster: Really? I thought postgresql would work just fine
04:14:05 <buckmaster> me too...
04:14:08 <srhb> Hm. Sad.
04:14:17 <srhb> I have to admit I CBA to find out how to do it on Windows :P
04:14:19 <buckmaster> probably just me being dumb.
04:15:07 <buckmaster> srhb: I just discovered Vagrant so I think I will be using the 'I'm on windows' excuse less and less. I dual-boot ubuntu but only for specific things :/
04:16:52 <d3lxa> Kinnison: part of my problem came from my locales, which was incorrect: "hGetContents: invalid argument"
04:17:16 <srhb> buckmaster: I personally find working on Linux much, much less cumbersome, but ymmv. :)
04:17:36 <srhb> buckmaster: Even just for "package manager, get me this program and these dev libraries."
04:17:37 <Kinnison> d3lxa: ouch
04:18:01 <d3lxa> Kinnison: this link helped me http://jaspervdj.be/hakyll/tutorials/faq.html#hgetcontents-invalid-argument-or-commitbuffer-invalid-argument
04:19:18 <bananushka> hey, i'm starting to learn haskell, and i'm trying to use haskellmode in vim, but i don't understand how to run the current file.
04:19:49 <buckmaster> srhb: yeah I definitely agree. I tend to use a lot of git-bash when I'm in windows land. Which sucks :P. And after using xmonad for several months, Windows is starting to feel very cramped. I guess I was just raides on it for too long :P
04:19:49 <bananushka> i've tried :make, which seems to work, but if i do something like :GHCi main it doesn't wait for input
04:20:05 <srhb> buckmaster: Come to the dark side, padawan. :-)
04:20:09 <srhb> Sounds like it's time.
04:20:57 <bananushka> what am i doing wrong?
04:21:20 <buckmaster> srhb: yeah, using some scipy libraries for thesis has me booting ubuntu more and more often :P. I also used it all summer at an internship. Definitely on the path to it. I just do a fair amount of game dev with an engine that's windows-only, so for now at least I'm not saying goodbye for good...
04:21:47 <srhb> buckmaster: Virtual machine and shared folders? :)
04:22:13 <buckmaster> srhb: I've never tried running Windows in a VM. Might give that a go...
04:22:23 <buckmaster> ...though we're working on linux support for this engine anyway :P
04:22:28 <srhb> buckmaster: I do that, no problem :)
04:22:34 <buckmaster> performance?
04:22:40 <srhb> buckmaster: Unproblematic.
04:22:43 <buckmaster> bananushka: I wish I could help but I
04:22:47 <buckmaster> ve never used haskellmode :(
04:22:50 <srhb> buckmaster: Hardware access to GPU might be more tricky if you really need it
04:23:27 <buckmaster> srhb: yeah that would be good for game engine stuff...
04:23:41 <srhb> buckmaster: In fact I have an entire workspace dedicated to a fullscreen Windows VM. When I hand over my laptop to other people I switch to that and they'll never know the difference
04:23:50 <bananushka> buckmaster: do you use vim with other plugins or a completely different editor?
04:23:59 <skypers> jle`: thank you
04:25:10 <buckmaster> bananushka: I use vim, but no plugin. I usually just load up my code in ghci in a separate terminal and hit :r when I need to
04:25:42 <buckmaster> bananushka: or cabal repl
04:26:20 <srhb> buckmaster: If the engine can run in software mode, it should be unproblematic for devving I guess.
04:26:26 <d3lxa> Kinnison: I made it! it's compiled, wouhou \o/ when I had rejection, I picked the package and tried random things :P (like removing the version constraint, etc)
04:26:35 <buckmaster> srhb: sneaky... sounds great actually. I haven't ubuntu-ed my laptop out of paranoia (have had problems with that in the past) but that sounds tempting just to be awesome
04:27:00 <srhb> buckmaster: I personally dislike Ubuntu, but finding that distro that's right for you takes a little while.
04:27:28 <bananushka> buckmaster: thanks!
04:27:47 <Kinnison> d3lxa: :-)
04:28:51 <buckmaster> srhb: any reason in particular? When I was starting it was the obvious choice as it was known for its user-friendliness. Now I'm a bit more experienced, but I don't know what else is out there. Actually, one friend has been managing his personal linux setup with Vagrant, since he's basically building from Arch or something else ridiculously minimal
04:29:01 <thoughtpolice> srhb: NixOS or bust.
04:29:04 * hackagebot cabal-bounds 0.4 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.4 (DanielTrstenjak)
04:29:12 <buckmaster> bananushka: hope that's adequate! Maybe try later to see if anyone can help you with haskellmode...
04:29:28 <srhb> thoughtpolice: One day... ;)
04:29:33 <srhb> thoughtpolice: Right now Arch is too convenient
04:33:09 <srhb> buckmaster: Well I really enjoy minimal. but it's personal preference
04:34:05 * hackagebot codex 0.0.1.5 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.0.1.5 (aloiscochard)
04:34:11 <benmachine> srhb: of all the adjectives I could describe my arch installation with, I don't know that "convenient" would make the first page
04:34:53 <srhb> benmachine: Really? I think it's so hassle-free compared to Ubuntu.
04:35:14 <benmachine> srhb: oh, maybe
04:35:18 <benmachine> I don't use anything else
04:35:38 <benmachine> so maybe my ire is best directed at computers-as-a-whole rather than arch specifically
04:36:22 <buckmaster> benmachine: http://www.xkcd.com/1349/
04:36:37 <buckmaster> relevant, though probably worn out by this point...
04:36:59 <benmachine> buckmaster: resonates with me, yes
04:37:19 <zxq9> benmachine: I think your last statement is most accurate (I use and support Kubuntu, Vine, RHEL/SL, Windows7, AIX, and Gentoo -- but personally use Gentoo in my own network)
04:37:23 <angerman> can I have a lambda expression destructuring a Record?
04:37:46 <srhb> angerman: Yes, just so.
04:38:19 <angerman> I tried \x{field=var}, but that did not work :(
04:39:11 <dv-> \(Record field1 field2...)
04:39:33 <buckmaster> angerman: or \x@(Record field) -> ...
04:39:48 <supki> angerman: x should be a constructor name
04:39:53 <buckmaster> angerman: sorry, \x@(Record var) -> ...
04:40:32 <skypers> in linear
04:40:43 <skypers> I don’t find the way to compute the norm of a vector
04:40:46 <skypers> is there any?
04:41:06 <angerman> ahh thanks!
04:41:36 <supki> skypers: norm from Metric class?
04:42:35 <skypers> hm, thank you
04:42:46 <benmachine> \ RecordConstructor{ field = var } -> should work
04:43:15 <skypers> is there a place where I can find cross then?
04:43:44 <skypers> cross :: Num a => V3 a -> V3 a -> V3 a
04:43:50 <skypers> hm
04:43:57 <skypers> it might be in Linear.V3 then
04:44:06 * hackagebot codex 0.0.1.6 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.0.1.6 (aloiscochard)
04:44:09 <skypers> yeah, it’s there :)
04:45:15 <buckmaster> benmachine: I'm no expert but that looks like object construction syntax rather than destructuring
04:47:08 <benmachine> buckmaster: so does \ (Just x) -> ...
04:47:26 <skypers> is there a way to get the x component of a V3 without lens?
04:47:58 <buckmaster> benmachine: ok true, and so does \(Record f1 f2), there's an overlap there
04:48:26 <srhb> skypers: case v of V3 x _ _ -> ... x
04:49:03 <srhb> skypers: but really, use the nice accessor _x
04:49:07 * hackagebot cabal-bounds 0.4.1 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.4.1 (DanielTrstenjak)
04:49:18 <skypers> srhb: yeah…
04:49:25 <skypers> I think it’s time to me to migrate to lens
04:49:34 <srhb> skypers: Lens makes you happy. Short and shiny code. :)
04:49:34 <skypers> even if I really don’t want to…
04:49:43 <skypers> srhb: yeah
04:49:47 <srhb> You don't have to use it everywhere, just where it's really convenient.
04:49:54 <skypers> I think you’re right, but it’s huge
04:50:01 <skypers> it makes your code dependent to a massive library
04:50:09 * srhb shrugs
04:50:26 <benmachine> skypers: the marginal cost probably isn't that large, because everyone has already installed it :D
04:50:28 <AshyIsMe> omg hackagebot, good bot!
04:50:42 <AshyIsMe> codex looks sweet
04:51:07 <srhb> skypers: Pretty sure linear depends on lens anyway.
04:51:33 <bgamari> srhb, it does not, thankfully
04:51:39 <jle`> wow, that is surprising
04:51:48 <srhb> bgamari: Really?
04:51:49 <AshyIsMe> aloiscochard: codex is yours?
04:51:50 <jle`> considering ek's philosophy on integration
04:52:01 <jle`> i say ek so he doesn't know that we are talking about him :)
04:52:31 <srhb> How can things appear in the hackage depends field but not be actual dependencies?
04:52:38 <aloiscochard> AshyIsMe: yes it is, I'm afraid a pushed a bugged version before but it's fixed now
04:52:42 <aloiscochard> AshyIsMe: have you gave it a try?
04:52:46 <bgamari> srhb, doh, s/not/now/
04:52:46 <bgamari> really unfortunate typo
04:52:49 <bgamari> srhb, Linear depends upon lens
04:52:53 <bgamari> you were right
04:52:55 <srhb> bgamari: Ah, good :P
04:53:04 <AshyIsMe> aloiscochard: im about to, can i just install it with cabal install?
04:53:07 <AshyIsMe> how do you globally install it?
04:53:10 <jle`> that is a significant typo
04:53:18 <srhb> AshyIsMe: Don't!
04:53:24 <srhb> AshyIsMe: just cabal install it, not globally.
04:53:32 <aloiscochard> AshyIsMe: just cabal install codex, be sure to cabal install hasktags as well
04:53:48 <AshyIsMe> yeah ive been using hasktags for my projects already
04:53:52 <aloiscochard> cool
04:53:52 <srhb> AshyIsMe: (the answer is --global but you should almost never do that)
04:53:55 <skypers> srhb: yes it does
04:53:56 <AshyIsMe> srhb: it's an executable though, not a code library?
04:53:57 <skypers> benmachine: yeah…
04:53:58 <skypers> well
04:54:04 <skypers> I think I’ll use it now
04:54:07 <aloiscochard> AshyIsMe: update hackage too to be sure you get the last
04:54:10 <skypers> I have a lot of ugly stuff in my code
04:54:10 <skypers> like
04:54:29 <skypers> let s = getTheState m in m { s = fmap foo s }
04:54:33 <skypers> or that kind of stuff
04:54:37 <aloiscochard> AshyIsMe: you should get 0.0.1.6
04:55:13 <AshyIsMe> aloiscochard: so do you globally install codex?
04:55:23 <AshyIsMe> otherwise i'd need to install it in each project's sandbox right?
04:55:26 <aloiscochard> AshyIsMe: yes you should, out of a sandbox
04:55:29 <aloiscochard> AshyIsMe: right
04:55:39 <Kaidelong> GHC can't cross compile. JHC doesn't have things like "multi-parameter type classes"
04:55:39 <aloiscochard> AshyIsMe: as you did for hasktags I suppose
04:55:41 <AshyIsMe> srhb: i think this is one of those rare cases :)
04:55:46 <srhb> AshyIsMe: OK :)
04:55:50 <Kaidelong> (which are kind of important)
04:56:00 <srhb> AshyIsMe: building it in a sandbox is a good idea though
04:56:09 <Kaidelong> I feel stuck because it seems the only way to get anything done reasonably well is to cross compile
04:56:27 <Kaidelong> unless I want it only working on linux
04:57:08 <Kaidelong> there aren't any good options, I could use GHC but then I can't use gtk
04:57:17 <Kaidelong> or other big libraries already written for me
04:57:29 <srhb> Kaidelong: You mean JHC?
04:57:31 <buckmaster> skypers: lens-family?
04:57:34 <AshyIsMe> aloiscochard: will vim read the codex.tags file automatically?
04:57:40 <Kaidelong> srhb: I meant GHC
04:57:41 <buckmaster> though I guess it doesn't give you the operators, which you're after...
04:58:03 <aloiscochard> AshyIsMe: no you should put 'set tags=tags;/,codex.tags;/' in your .vimrc
04:58:14 <aloiscochard> AshyIsMe: damn, something else I forgot for the README! ty ;-)
04:58:22 <skypers> buckmaster: ?
04:58:44 <buckmaster> skypers: lens without the massive dependencies... but I'm not sure how many conveniences it gives you
04:58:45 <Kaidelong> setting up a practical developer environment on windows using cygwin/mingw seems to end up being "there's always some wrench flying into the works, always"
04:58:50 <Kaidelong> whenever you try to build something
04:59:02 <srhb> Kaidelong: Yes, I too find Haskell on Windows mostly inoperable.
04:59:10 <Kaidelong> so I'd have to stick to haskell libraries that don't need cygwin/mingw
04:59:15 <skypers> yeah
05:00:18 <Kaidelong> alternatively I could try targeting windows with a cross compiler and have the advantage of things like proper package managers and no schizophrenic quirks like "there are spaces in the directory name, the world has ended!"
05:00:31 <Kaidelong> but then I can't use GHC because GHC can't cross compile
05:00:35 <Kaidelong> dillema
05:00:38 <buckmaster> Kaidelong: I manage to get by ;P. Though anything that depends on C bindings does tend to be a little difficult...
05:01:36 <AshyIsMe> aloiscochard: i was literally thinking about how to set this up last week
05:01:56 <aloiscochard> AshyIsMe: good to hear that could be useful for others :-)
05:02:09 <AshyIsMe> cabal install is taking a long time though i think srhb was right about the sandbox
05:02:19 <aloiscochard> AshyIsMe: I'm just starting with haskell, and that will boost my productivity
05:02:32 <aloiscochard> he's definitely right about never installing other stuff globally
05:02:45 <aloiscochard> should be fine for hasktags Cabal and your building tools
05:03:20 <aloiscochard> AshyIsMe: ideally it should be installed thru the distrib imho
05:03:42 * srhb is not a "he"
05:03:44 <srhb> But yeah.
05:03:56 <aloiscochard> oh I'm sorry for that srhb, apologize
05:04:00 <srhb> No worries. :)
05:04:44 <srhb> AshyIsMe: Depending on your version of cabal install you might want to throw a -j flag at it for parallel building
05:05:54 <AshyIsMe> cabal install version 1.18.0.2 apparently
05:06:59 <buckmaster> thoughtpolice: do you use nix to manage haskell packages? Or is it cabal install all the way down?
05:07:00 <srhb> Rawr, -j all the way.
05:07:08 <aloiscochard> AshyIsMe: this is the version of Cabal, not of codex
05:07:47 <AshyIsMe> hmm, codex requires cabal 1.19
05:07:52 <aloiscochard> yeah, weird
05:08:02 <thoughtpolice> buckmaster: i'm beginning to use nix for all of my packages in place of Cabal sandbox, yes
05:08:05 <aloiscochard> I use some API which where expose only on that version
05:08:27 <srhb> aloiscochard: So dev version?
05:08:31 <srhb> Oh, not cabal-install
05:08:35 <thoughtpolice> the reason for this is Nix can act as a sandbox for *literally everything* (python, ruby, haskell, C, etc), so it drastically reduces the amount of tools i need to deal with
05:08:42 <aloiscochard> srhb: yes the "cabal as library"
05:08:47 <srhb> righto.
05:09:06 <buckmaster> thoughtpolice: cheers, that's what I thought. Very tempted to try it out
05:09:16 <srhb> thoughtpolice: Is there an overview of nix packages somewhere? I'd like to see if I'd have to package everything to get a system to my liking.
05:09:22 <thoughtpolice> buckmaster: of course, the worst part of this is that I have to add Nix expressions for libraries. but this is mostly automated - for example, the other day I added Cryptol to nixpkgs
05:09:23 <aloiscochard> a shame I couldn't use hasktags as a lib though, that would have made the tool more portable
05:09:36 <thoughtpolice> buckmaster: and i needed 5 libraries that weren't there. it took about 10 seconds to do it all using 'cabal2nix', worked the first time
05:10:27 <thoughtpolice> srhb: my rule of thumb is - your packages will never always be there. what I mean by that is that, roughly speaking, all Nixpkgs users are contributors. there just isn't a large enough community for *everything*.
05:10:33 <thoughtpolice> srhb: but, as an approximation, go here - http://hydra.nixos.org/
05:10:41 <srhb> thoughtpolice: Thanks!
05:10:47 <buckmaster> thoughtpolice: great to hear! Though most of my 'cabal hell' problems have been alleviated with sandboxes, having one program for different languages does sound very attractive
05:10:49 <thoughtpolice> and you can search for the name of the package. note that Nix uses camelCase for lots of stuff
05:11:22 <thoughtpolice> srhb: so for example if you wanted the haskell package 'process-conduit' search for 'processConduit'
05:11:51 <srhb> thoughtpolice: Got it. :) I think I will give it a go later today. Sounds too good to pass on.
05:12:50 <thoughtpolice> srhb: of course it's a little extra work, but Nix is a very simple language, it only took me a day or two to really get to writing stuff. in 2 months i already maintain 30+ packages and have commit rights :P
05:13:02 <thoughtpolice> (GitHub seems to say I'm #30 with 110 commits already)
05:13:15 <srhb> thoughtpolice: I'm ok with the extra work, I'm really interested in the model. I want the entire OS of course :P
05:13:16 <thoughtpolice> and the costs all pay for themselves with the large benefits, IMO
05:13:33 <thoughtpolice> srhb: yes, NixOS is even better. and NixOps takes it to the multi-node level :)
05:13:38 <srhb> Nice
05:13:44 <thoughtpolice> (NixOps was actually how I learned the most myself)
05:13:46 <srhb> Grabbing the minimal installer on a USB stick is fine, yes?
05:13:55 <thoughtpolice> by deploying to my Hetzner machine
05:13:59 <aloiscochard> thoughtpolice: are you using NixOS for your dev machine?
05:14:10 <srhb> Oooh, I have a hetzner VPS. Maybe that would be useful too
05:14:15 <thoughtpolice> srhb: roughly, yes - https://nixos.org/wiki/Installing_NixOS_from_a_USB_stick
05:14:21 <AshyIsMe> aloiscochard: any reason why hasktags couldnt be used as a lib?
05:14:21 <srhb> thoughtpolice: Great, thanks
05:14:27 <thoughtpolice> srhb: alternatively if you just want to play, VirtualBox works good
05:14:44 <thoughtpolice> and NixOps can deploy virtualbox machines for you, so you can 'flip the switch' and go from VBox -> Hetzner for example by changing a few lines
05:14:45 <srhb> thoughtpolice: I have a free harddisk, might as well use the sunday for that :P
05:14:51 <srhb> Oh nice.
05:15:02 <thoughtpolice> since it separates the concept of 'logical' (what a machine is) vs 'physical' (how and where a machine is provisioned)
05:15:04 <Kaidelong> I actually wonder if a *package manager* of the style of nix is the right solution in the end
05:15:18 <thoughtpolice> aloiscochard: I am going to, yes. but i have a lot of stuff to account for - my servers were a nobrainer, however
05:15:21 <Kaidelong> what nix does almost seems to merit having it be a versioned file system of some sort
05:15:25 <aloiscochard> AshyIsMe: well, because it is not one at all https://github.com/MarcWeber/hasktags/blob/master/hasktags.cabal
05:15:25 <thoughtpolice> and I use my Hetzner EX40 for development
05:15:36 <aloiscochard> AshyIsMe: or maybe I could, but I don't know how?
05:15:49 <Kaidelong> nix built into the filesystem may be a better solution in the end
05:16:17 <buckmaster> night all, cheers for the discussion :)
05:16:22 <thoughtpolice> srhb: anyway, it 100% obsoletes tools like puppet, chef, ansible, and 'telescopes' the configuration management of your stack from packages all the way up to full networks.
05:16:35 <aloiscochard> thoughtpolice: I'm seriously seduced by NixOS on the paper, but haven't found motivation for switching from Arch
05:16:43 <thoughtpolice> (telescoping as in the same way an infinite, telescoping series collapses)
05:17:05 <thoughtpolice> well, there are some real downsides, for sure
05:17:06 <srhb> Exciting!
05:17:15 <Kaidelong> aloisochard: if it breaks, you can just roll back to a previous version
05:17:27 <Kaidelong> this was my main motivation for switching from arch
05:17:51 <aloiscochard> Kaidelong: the thing is that I find arch really awesome and well designed
05:18:00 <thoughtpolice> for one, the documentation is pretty bad. like one thing i still can't get over is how there are so many commands with minor differences sometimes. and stupid defaults
05:18:18 <aloiscochard> Kaidelong: aside from that rollback feature, is there any other motivation?
05:18:19 <thoughtpolice> if i search for a command with 'nix-env' for example, why should i explicitly have to say --description? i almost always want this to ensure i'm installing the right thing
05:18:31 <aloiscochard> Kaidelong: because since I use arch, I never had to reinstall my distrib
05:18:43 <thoughtpolice> the NixOS manual is quite complete, but doesn't address lots of common things. it's all got a solid basis
05:19:05 <aloiscochard> AshyIsMe: got the tool working btw? or still compiling the whole world ;-) ?
05:19:10 <thoughtpolice> but i would say it needs lots more polish in the long run. but there are more people, so it's happening more steadily now. and, of course, that's not enough to deter me given the upsides
05:19:19 <AshyIsMe> aloiscochard: hmm yeah looks like hasktags isn't set up to be used as a library, maybe email MarcWeber?  it might not be too hard to change it
05:19:22 <thoughtpolice> so let that speak as it may
05:19:35 <aloiscochard> AshyIsMe: ok, I'll get in touch with him
05:19:47 <Kaidelong> aloiscochard: configuration.nix'
05:19:56 <aloiscochard> looks like Nix is very good in term of having up to date packages
05:20:02 <AshyIsMe> hmm, i just updated cabal-install but the one in my path is still the old one
05:20:02 <Kaidelong> it's a bit like gentoo's various configuration files
05:20:32 <thoughtpolice> aloiscochard: the biggest advantage is that you have one way of describing everything on your system. you don't need to tweak your /etc endlessly for every single program, your configuration.nix describes everything
05:20:38 <Kaidelong> so if you have a system configuration you like you can just copy over your configuration.nix
05:20:50 <AshyIsMe> oh i installed it into the codex sandbox, whoops
05:20:58 <thoughtpolice> from services to installed packages. so you only need to know Nix, really, to understand how to build your system. the fact everything is configured with Nix also helps in other places, like reproducibility
05:21:15 <thoughtpolice> if i use the same configuration.nix, and the same version of nixpkgs (the package set), i will always get the same machine every time, for example
05:21:16 <aloiscochard> thoughtpolice: sounds good, I love this kind of approach
05:21:23 <Kaidelong> reproducibility is probably the big thing
05:21:38 <Kaidelong> that's nixos' killer feature
05:21:40 <aloiscochard> thoughtpolice: kind a like when I disccovered nginx after hours of painful apache configuration
05:21:44 <Kaidelong> things don't generally break mysteriously
05:21:47 <thoughtpolice> also, i can do other things: for example, let's say i modify configuration.nix, and want to test it
05:22:02 <aloiscochard> ok I'm sold, I was looking forward hearing feedback from folks using it
05:22:13 <thoughtpolice> you can use 'nixos-rebuild build-vm' and it'll automatically create a QEMU virtual machine with your configuration
05:22:46 <aloiscochard> docker is on my list as well... for this kind of stuff.
05:22:51 <thoughtpolice> but not switch your system. so then you can start it and play around immediately. the infrastructure also supports tests this way, so for example I have services i've written like chat servers and distributed databases
05:23:18 <thoughtpolice> and i can have tests that spin all the necessary machines up on a private software vlan, run all the configurations, make sure it works properly, etc. then it will tear down the VMs and mark them as complete
05:23:25 <aloiscochard> AshyIsMe: arf! let me know how it goes, I would be happy to hear if it work ok or not ... so then I can spam it on reddit ;-)
05:23:36 <Kaidelong> you could probably get pretty far just using nix on some other better maintained, better supported OS like SuSE or Ubuntu
05:24:00 <thoughtpolice> yes, using Nix on top of your current system is a decent way to get a feel for things
05:24:06 <AshyIsMe> aloiscochard: will do, as soon as everything finishes building
05:24:09 <thoughtpolice> i know some people who use Debian 7 + Nix userspace, for example
05:24:16 <aloiscochard> oh, I didn't even it's possible to use Nix like that
05:24:19 <aloiscochard> know*
05:24:31 <thoughtpolice> aloiscochard: yes, due to the way Nix works, binary nix packages work on any linux distribution, unmodified
05:24:53 <thoughtpolice> this all boils down to the fact Nix precisely captures all dependencies in a cryptographic hash (more or less)
05:24:56 <aloiscochard> that have the potential to make our life much easier :-)
05:25:49 <Kaidelong> oh, nix is an application of a one-way cipher?
05:25:59 <Kaidelong> that's quite a bizzare one
05:26:08 <Kaidelong> like most applications of one way ciphers I guess
05:26:50 <edvo> With DataKinds, what is the easiest way to make some sort of case over the type? Lets say I have data Tag = A | B and data Tagged (t :: Tag) = Tagged Int and I want val :: Tagged a such that val = Tagged 0 if a ~ A and Tagged 1 if a ~ B. Is there an easier way than using an auxiliary type class?
05:27:20 <thoughtpolice> Kaidelong: well, when you say a package X has dependencies and inputs A, B, and C, Nix basically calculates hash(A+B+C), and then uses that + the package name as a unique identifier. so 'foo' depends on 'bar' and 'baz', calculate hash(bar+baz) = ABCDEF1234, then the full ID is 'ABCDEF1234-foo'
05:27:45 <thoughtpolice> what this means is that you can have two versions of 1 package installed, and their dependencies can coexist, even if they would otherwise conflict
05:27:52 * srhb just got the iso and dd'ed it to an USB disk. Apparently should read manual first. :P
05:28:03 <thoughtpolice> because changing the dependencies implies a change in the hash
05:29:02 <aloiscochard> thoughtpolice: it's quite funny, I do something similar in my codex tool to know if I should update the tags file (I hash the dependency graph, and use it to check)
05:29:29 <thoughtpolice> in fact, this property is the exact same thing we want for Cabal
05:29:41 <aloiscochard> yeah, definitely
05:29:43 <skypers> hm
05:29:54 <skypers> (.~) sets something
05:30:05 <skypers> (%~) maps a function on a field
05:30:10 <skypers> (^.) gets something
05:30:16 <skypers> what is the gets equivalent?
05:30:20 <thoughtpolice> for example, i might have two libraries foo and bar depend on baz. but one of them requires 'baz' be installed with some extra option, say to enable some specific extra feature (or disable one). right now that can't work without overwriting baz, and breaking foo and bar, requiring reinstallation
05:30:36 <skypers> getting something an applying on function on it
05:30:46 <pranz> skypers: (^.to f)
05:30:56 <skypers> :t (to)
05:30:57 <lambdabot> (Contravariant f, Conjoined p, Functor f) => (s -> a) -> p a (f a) -> p s (f s)
05:30:58 <thoughtpolice> that is Cabal is not actually purely functional, in a way. which is basically one of its most annoying problems.
05:31:00 <skypers> holy shit
05:31:08 <thoughtpolice> so eventually a more Nix-like model will fix this
05:31:21 <aloiscochard> thoughtpolice: yeah, the compilation flag must be part of that hash then, right?
05:31:33 <skypers> > (1,3) & _2 ^. to (+1)
05:31:34 <lambdabot>  Couldn't match type ‘a0 -> f b0’ with ‘(t0, t1)’
05:31:34 <lambdabot>  Expected type: Control.Lens.Getter.Getting
05:31:34 <lambdabot>                   ((t0, t1) -> s -> f t)
05:31:34 <lambdabot>                   ((a0 -> f b0) -> s -> f t)
05:31:34 <lambdabot>                   ((t0, t1) -> s -> f t)
05:31:39 <bitemyapp> thoughtpolice: co-existing dependencies would eliminate a lot of (most?) breakage with Haskell packaging.
05:31:58 <skypers> > (1,3) & _2 ^. (to (+1))
05:31:59 <lambdabot>  Couldn't match type ‘a0 -> f b0’ with ‘(t0, t1)’
05:31:59 <lambdabot>  Expected type: Control.Lens.Getter.Getting
05:31:59 <lambdabot>                   ((t0, t1) -> s -> f t)
05:31:59 <lambdabot>                   ((a0 -> f b0) -> s -> f t)
05:31:59 <lambdabot>                   ((t0, t1) -> s -> f t)
05:32:02 <bitemyapp> thoughtpolice: I know people like to talk about flipping around the PVP, but the deeper point is that when I build a package with Maven it "just works" even if it's being sloppier.
05:32:06 <skypers> > (1,3) & _2 (^. (to (+1)))
05:32:06 <edvo> > (1,3) ^. _2. to (+1)
05:32:07 <lambdabot>  can't find file: L.hs
05:32:08 <lambdabot>  No instance for (GHC.Show.Show (f0 (t0, b0)))
05:32:08 <lambdabot>    arising from a use of ‘M60505228231591324714375.show_M60505228231591324714...
05:32:08 <lambdabot>  The type variables ‘t0’, ‘b0’, ‘f0’ are ambiguous
05:32:09 <lambdabot>  Note: there are several potential instances:
05:32:11 <lambdabot>    instance [safe] GHC.Show.Show a =>
05:32:18 <thoughtpolice> something like that, yes. there's been work done on this front in the past, but it stalled. hopefully we (Well-Typed) will be able to work more on it again pretty soon, actually
05:32:22 <skypers> oh
05:32:39 <bitemyapp> thoughtpolice: that'd be fantastic and eliminate one of the roadblocks for getting new people onboarded.
05:32:55 <skypers> > (1,3) ^. _2.(to (+1))
05:32:56 <thoughtpolice> bitemyapp: i don't want to get into PVP discussions other than saying people who break it annoy me, but yes, it would help in a substantial amount of common cases.
05:32:57 <lambdabot>  4
05:32:59 <skypers> ok
05:33:14 <thoughtpolice> just today i needed to reinstall unordered-containers to benchmark a GHC optimization i made, for example
05:33:16 <bitemyapp> thoughtpolice: I've nothing to say about it, just that I don't think changing it would fix the root problem.
05:33:32 <skypers> > (1,3) ^. to id
05:33:33 <lambdabot>  (1,3)
05:33:35 <thoughtpolice> but that would have broke 6 other packages, which is annoying
05:33:51 <skypers> > (1,3) ^. to ((*2) *** (const 0))
05:33:52 <lambdabot>  (2,0)
05:33:55 <skypers> ahah
05:34:17 <skypers> :t indexed
05:34:18 <lambdabot> Indexable i p => p a b -> i -> a -> b
05:34:24 <skypers> hm
05:34:35 <AshyIsMe> omg, i keep messing up the order of the arguments to ln
05:34:47 <skypers> :t traversed
05:34:48 <lambdabot> (Indexable Int p, Traversable f, Applicative f1) => p a (f1 b) -> f a -> f1 (f b)
05:35:01 <skypers> I’ll check that later :D
05:48:01 <srhb> Hmm, gummiboot instead of grub is slightly icky.
05:48:53 <Yaniel> still better than rEFInd
05:50:10 <srhb> Never heard of that. I just use grub on Arch.
05:50:35 <srhb> Nixos doesn't seem to support efi grub though.
05:51:04 <NinjaPenguin> What book would you guys recommend for someone who wants to learn Haskell?
05:51:15 <srhb> Lyah
05:51:15 <NinjaPenguin> I'm buying a few books for the first time of my life. :|
05:51:23 <srhb> @where lyah
05:51:23 <lambdabot> http://www.learnyouahaskell.com/
05:51:25 <AshyIsMe> srhb: so once ive done "cabal install" in the sandbox, how do i then install the binary globally?
05:51:43 <srhb> just copy it. :)
05:51:45 <AshyIsMe> NinjaPenguin: i bought a copy of lyah, it's good
05:52:49 <aloiscochard> AshyIsMe: in ~/.cabal/bin
05:52:52 <AshyIsMe> srhb: urgh really?
05:53:00 <NinjaPenguin> I am considering it. Any other good books you'd recommend? I like to check different sources and see which one suits me the best. :)
05:53:19 <aloiscochard> NinjaPenguin: I found RWH better than LYAH, but it's probably a matter of taste
05:53:33 <aloiscochard> NinjaPenguin: and then the concurrency one by marlow is fantastic imo
05:53:50 <AshyIsMe> that one is next on my list
05:53:56 <srhb> Ashyisme: nothing wrong with that. :)
05:54:13 <aloiscochard> srhb: well you have to always manually do that at every update
05:54:21 <srhb> I dislike rwh personally. But yeah the concurrency one is great.
05:56:44 <NinjaPenguin> aloiscochard: RWH looks really nice, I'll buy it. Thanks!
05:57:30 <aloiscochard> NinjaPenguin: I think you'll find stuff in it that you won't find in the other
05:57:37 <aloiscochard> NinjaPenguin: then think about checking the papers too!
06:01:41 <AshyIsMe> aloiscochard: did you add the vim setup to the readme?
06:01:52 <aloiscochard> NinjaPenguin: specially these three papers: http://pastie.org/9117144
06:02:20 <aloiscochard> AshyIsMe: it's done in my local repo but I haven't commited yet
06:03:42 <aloiscochard> AshyIsMe: pushed https://github.com/aloiscochard/codex#vim
06:04:07 <AshyIsMe> cheers :)
06:05:28 <AshyIsMe> aloiscochard: omg that's glorious
06:05:42 <aloiscochard> AshyIsMe: awesome, was looking forward hearing that :-)
06:06:06 <AshyIsMe> so that's better than even visual studio's jump to definition now
06:06:21 <AshyIsMe> because it includes source for the standard libraries, not just types
06:06:26 <aloiscochard> AshyIsMe: I'm working on an other tool, now that I finished that one
06:07:04 <aloiscochard> AshyIsMe: you might be interested in, it's basically detecting file change and then run cabal build/tests/benchmark and send notification if fail
06:07:29 <corgifex> like jenkins?
06:07:30 <aloiscochard> AshyIsMe: this just changed my life this codex thing really, I can learn library much more quickly :-)
06:07:45 <aloiscochard> corgifex: oh no no! just something for the dev machine, to do continous development
06:07:46 <AshyIsMe> aloiscochard: yeah you're a genious
06:08:03 <aloiscochard> AshyIsMe: that's really simple honestly :-) but ty
06:08:12 <AshyIsMe> even the standard libraries, 1 keystroke away from the source at all times
06:09:33 <AshyIsMe> aloiscochard: how good are you with vim?
06:09:41 <AshyIsMe> some smart autocommands would be good too
06:10:04 <AshyIsMe> run codex update whenever a *.cabal file is saved
06:10:27 <aloiscochard> AshyIsMe: well, that's what my next tool will do as well  mate ;-)
06:10:46 <aloiscochard> AshyIsMe: I'm a good vim user I belive, but to be clear I'm totally against using it as IDE
06:10:55 <aloiscochard> that's why *next tool* come in place
06:11:17 <aloiscochard> I can show you my script that will be easier to explain
06:11:44 <aloiscochard> AshyIsMe: I'm porting this scipt: http://pastie.org/9117159 to a proper command line tool
06:11:46 <AshyIsMe> the middle path is always the best i think, i dont mind integrating useful plugins into my vim workflow but i also don't want to go overboard
06:12:07 <aloiscochard> AshyIsMe: for it's ctrl-p and some buffer juggler, but that's all. no autocomplete
06:12:12 <aloiscochard> for me*
06:12:31 <AshyIsMe> fugitive is great too
06:12:38 <AshyIsMe> i highly recommend it if you havent tried it
06:12:47 <corgifex> :au BufWritePost *.hs !codex update
06:13:30 <AshyIsMe> corgifex: cheers!, though we'll want *.cabal i think
06:13:45 <AshyIsMe> this only needs to happen when new libraries are added to the project
06:15:25 <aloiscochard> AshyIsMe: yep I use fugitive, but just for the git grepping
06:16:32 <aloiscochard> AshyIsMe: also, do you know you can use ctrl-p to lookup for tags?
06:16:40 <aloiscochard> AshyIsMe: it's like a Hoogle in your vim
06:16:49 <aloiscochard> (poor's man hoogle)
06:16:56 <AshyIsMe> yeah but it's not muscle memory for me yet
06:17:05 <bitemyapp> I nominate aloiscochard for a cookie for being helpful.
06:17:19 <aloiscochard> haha bitemyapp
06:18:19 <pjdelport> If we're recommending Vim stuff, you should be using syntastic too
06:18:46 <pjdelport> Works nicely with hdevtools
06:18:55 <pjdelport> and hlint
06:19:25 <AshyIsMe> yeah i have those set up
06:19:37 <AshyIsMe> and ghcmod too
06:19:45 <aloiscochard> I found them too heavy for me, but I understand I might sound like an alien
06:19:55 <aloiscochard> anything that introduce latency I don't like
06:20:09 <AshyIsMe> i have <leader>ht bound to :GhcModType
06:20:19 <AshyIsMe> nice way to check the type of anything under the cursor
06:41:40 <darthdeus> guys is there a way to define a second instance of a typeclass on a type synonym, or do i need to wrap that type in a newtype and implement the instance for that?
06:42:20 <Saizan> darthdeus: the latter
06:43:12 <darthdeus> ok :( and to be specific, I want to define a new Arbitrary instance for Char for quickcheck, so that it only returns the characters I need ... is there a good way of doing that, other than using the newtype wrapper?
06:44:22 * hackagebot swish 0.9.0.14 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.14 (DouglasBurke)
06:46:03 <magicman> @type forAll
06:46:04 <lambdabot> (Testable prop, Show a) => Gen a -> (a -> prop) -> Property
06:46:18 <magicman> darthdeus: Use that function with your custon Gen Char?
06:46:34 <magicman> *custom
06:47:42 <magicman> If that alternative Char instance is only used to define an instance of Arbitrary for a bigger datatype, you can define the instance for the bigger datatype by not referring to (arbitrary :: Gen Char), but to (custom :: Gen Char).
06:49:26 <darthdeus> magicman: thanks, I'll look at that, I've basically been defining an Arbitrary instance for my own newtype which just wraps the Char
07:08:12 <lostInTypes> I have a function with signature fct:: [a] -> [[c]], i would like to apply it in a way to keep some tags on values, to obtain something like [(a,b)] -> [[(c,b)]], can i achieve this without having to modify the original function, and use some kind of composing or mapping to get to my goal?
07:10:05 <EvanR> .oO( a = (A,B), c = (C,B) )
07:10:16 <EvanR> but your function cant operate on pairs
07:10:32 <EvanR> it cant do anything with the a and c, if they are variables
07:13:16 <EvanR> if you change your function so it operates on Functor f => [f a] -> [[f c]] then it can accept these decorated types
07:13:44 <EvanR> any functor
07:14:03 <EvanR> fmap (+1) (1, 'a')
07:14:08 <EvanR> > fmap (+1) (1, 'a')
07:14:10 <lambdabot>  Could not deduce (GHC.Num.Num GHC.Types.Char)
07:14:10 <lambdabot>    arising from a use of ‘GHC.Num.+’
07:14:10 <lambdabot>  from the context (GHC.Num.Num t)
07:14:10 <lambdabot>    bound by the inferred type of
07:14:10 <lambdabot>             it :: GHC.Num.Num t => (t, GHC.Types.Char)
07:14:17 <EvanR> > fmap (+1) ('a', 1)
07:14:19 <lambdabot>  ('a',2)
07:14:25 * hackagebot hinotify 0.3.7 - Haskell binding to inotify  http://hackage.haskell.org/package/hinotify-0.3.7 (LennartKolmodin)
07:14:59 <eizo> lostInTypes: do you have a function a -> [c]?
07:16:43 <lostInTypes> @eizo, no the function does some grouping based on value of as and apply some function on a, so u may say i have a function a -> c, but not a -> [c]
07:16:43 <lambdabot> Unknown command, try @list
07:17:23 <EvanR> so its not any a, you at least know the class of a or its on some concrete A ?
07:17:26 <lostInTypes> @EvanR so if i change the function to have [f a], how does the need function become?
07:17:27 <lambdabot> Unknown command, try @list
07:18:58 <fizruk> lostInTypes: do not prepend @ to username, you’re confusing lambdabot :)
07:19:20 <EvanR> hashtag haskell ;)
07:19:26 * hackagebot fgl 5.5.0.0 - Martin Erwig's Functional Graph Library  http://hackage.haskell.org/package/fgl-5.5.0.0 (IvanMiljenovic)
07:24:23 <Phillemann> Is there any widely followed style guide regarding naming? For instance, I'm not sure if I should name the "getters" of newtypes "getFoo" or simply "foo".
07:24:26 * hackagebot data-r-tree 0.0.2.0 - R-Tree is a spatial data structure similar to Quadtrees or B-Trees.  http://hackage.haskell.org/package/data-r-tree-0.0.2.0 (SebastianPhilipp)
07:25:33 <skypers> woh
07:25:49 <skypers> lens are actually quite simple when you know the idea behind operators
07:25:54 <skypers> like = is for MonadState
07:26:02 <skypers> then .= maps const value
07:26:08 <skypers> then <>= mappends a monoid
07:26:12 <skypers> then %= maps a function
07:26:17 <skypers> this is great :)
07:26:19 <srhb> skypers: ;)
07:26:29 <skypers> what is for Reader ?
07:26:32 <skypers> and Writer?
07:26:38 <edwardk> %= if you are looking for an intuition stands for 'mod'-equals, its how you use it there.
07:27:08 <corgifex> Phillemann: for monadic stuff it's often runFoo
07:27:10 <srhb> view is for reader
07:27:11 <corgifex> or unFoo
07:27:13 <edwardk> 'view' automatically works in reader.
07:27:22 <edwardk> (or as a function since reader is)
07:27:28 <Phillemann> corgifex: Ah, right, I've seen this a couple of times.
07:27:45 <skypers> ok
07:27:47 <skypers> thank you :)
07:27:52 <skypers> I’m gonna try that
07:28:18 <skypers> so hm
07:28:29 <skypers> if I want to modify my State
07:28:36 <skypers> I can just do something with %=, right?
07:28:37 <edwardk> we may eventualy switch the %~ form over to working with arbitrary MonadReader instances, etc.
07:28:54 <edwardk> there was some push back within the group when that came up before
07:29:01 <edwardk> yeah
07:29:39 <skypers> hm
07:30:24 <srhb> > execState (_1 %= (+1)) (1,"ok")
07:30:26 <lambdabot>  (2,"ok")
07:30:36 <skypers> > flip runState (0,"foo") $ do { _1 %= (+1); _2 <>= ", bar"; return "yay" }
07:30:37 <lambdabot>  ("yay",(1,"foo, bar"))
07:30:42 <skypers> oh
07:30:43 <skypers> neat :D
07:30:58 <skypers> :t (++=)
07:30:59 <lambdabot>     Not in scope: ‘++=’
07:30:59 <lambdabot>     Perhaps you meant one of these:
07:30:59 <lambdabot>       ‘++’ (imported from Data.List),
07:31:09 <skypers> :t (@=)
07:31:10 <lambdabot>     Not in scope: ‘@=’
07:31:10 <lambdabot>     Perhaps you meant one of these:
07:31:10 <lambdabot>       ‘/=’ (imported from Data.Eq), ‘<=’ (imported from Data.Ord),
07:31:12 <srhb> mappend is just as nice for that
07:31:17 <skypers> nice, I defined that operator, so it’s free
07:31:22 <skypers> srhb: yeah
07:31:34 <skypers> just like you can do this:
07:31:44 <skypers> > "hi " <> "srhb"
07:31:46 <lambdabot>  "hi srhb"
07:31:49 <srhb> Yes.
07:31:59 <skypers> maybe (++) should not even exist after all
07:32:31 <srhb> Well, it's certainly less general.
07:32:39 <srhb> The same argument applies to map though
07:32:46 <srhb> They are easier to understand when you're new to all of it.
07:33:03 <skypers> that’s very true
07:33:09 <skypers> but the more you dig in
07:33:13 <skypers> the more you apply general stuff
07:33:22 <skypers> I tend to use fmap instead of map on lists sometimes :)
07:33:23 <srhb> > execState (_1 <>= 2) (Product 3,"ok")
07:33:25 <lambdabot>  (Product {getProduct = 6},"ok")
07:33:25 <skypers> it makes me smile
07:33:40 <srhb> Monoids are nice anyway. We likes them.
07:33:42 <corgifex> sometimes I write fmap fmap fmap sequence fmap
07:33:45 <corgifex> it makes me cackle
07:33:56 <skypers> srhb: yeah
07:34:05 <skypers> I love monoids
07:34:06 <hseg> I can't find it on Hoogle, but is there a function :: Monad m => (a -> b) -> (a -> m b) ? That would category-theoretically be the functor from Hask to Kleisli_M(Hask).
07:34:17 <hseg> skypers: They're the best.
07:34:27 <jmcarthur> :t (return .)
07:34:28 <lambdabot> Monad m => (a -> b) -> a -> m b
07:34:33 <jmcarthur> hseg: ^^
07:34:50 <no-n> @hoogle EitherT
07:34:51 <lambdabot> package EitherT
07:35:09 <hseg> jmcarthur: That's what I ended up with. However, it seems like nobody has mentioned this anywhere.
07:35:24 <corgifex> :t liftM return
07:35:25 <lambdabot> (Monad m1, Monad m) => m a1 -> m (m1 a1)
07:35:57 <hseg> (return.) should satisfy the functor laws, except that it then ends up being: return . id = return; return . f <=< return . g = return . f . g
07:36:00 <skypers> no-n: either
07:36:05 <skypers> the package is either
07:36:09 <no-n> skypers: i saw
07:36:23 <skypers> :t fmap return
07:36:23 <lambdabot> (Functor f, Monad m) => f a -> f (m a)
07:36:34 <corgifex> :t fmap pure
07:36:35 <lambdabot> (Applicative f1, Functor f) => f a -> f (f1 a)
07:36:38 <jmcarthur> hseg: what functor is it exactly? a function alone cannot be called a functor.
07:36:40 <skypers> ahah :D
07:37:00 <jmcarthur> oh you said it already
07:37:02 <jmcarthur> sorry
07:37:03 <zipper> Someone recommend something easy I can use for regex?
07:37:18 <srhb> zipper: Not really, the regex libraries are crazy and buggy.
07:37:26 <Algebr> Why are tuples considered an algebraic data type?
07:37:41 <zipper> srhb: or parsing command line arguments in haskell
07:38:03 <zipper> It's not like there's much info on the nets.
07:38:13 <EvanR> zipper: getopt?
07:38:23 <skypers> :t (<$%=)
07:38:24 <lambdabot>     Not in scope: ‘<$%=’
07:38:24 <lambdabot>     Perhaps you meant one of these:
07:38:24 <lambdabot>       ‘<#%=’ (imported from Control.Lens),
07:38:28 <jmcarthur> hseg: is it surprising to you that such a function isn't already defined in the standard libs? does it seem like it would be useful for something?
07:38:31 <skypers> :t (<#%=)
07:38:32 <lambdabot> MonadState s m => ALens s s a b -> (a -> b) -> m b
07:38:36 <wingrime> can I use tuple matching in lambda ?
07:38:44 <srhb> zipper: Or cmdtheline
07:38:46 <srhb> Very nice one
07:39:01 <hseg> jmcarthur: For equational reasoning I guess.
07:39:15 <srhb> > (\(x,_) -> x) (1,undefined) -- wingrime
07:39:16 <lambdabot>  1
07:39:19 <edwardk> :t (&~)
07:39:20 <lambdabot> s -> State s a -> s
07:39:37 <edwardk> > (1,"ok') &~ do _1 %= (+1)
07:39:38 <lambdabot>  <hint>:1:26:
07:39:38 <lambdabot>      lexical error in string/character literal at end of input
07:39:40 <hseg> jmcarthur: Also, in order to lift pure functions into the Kleisli category.
07:39:41 <srhb> wingrime: If you want fancier stuff you use a case or even a lambda case
07:39:57 <wingrime> srhb: I get error with  \(a,b,c) -> (a,b,99)
07:40:01 <jmcarthur> hseg: arr?
07:40:02 <edwardk> > (1,"ok") &~ do _1 += 1; _2 <>= "!"
07:40:04 <lambdabot>  (2,"ok!")
07:40:06 <srhb> wingrime: What error?
07:40:10 <skypers> hm
07:40:20 <skypers> edwardk: is there a combinator for that kind of stuff:
07:40:32 <edwardk> what kind?
07:40:35 <skypers> field %= (\c -> [] <$ c)
07:40:41 <srhb> > (\(a,b,c) -> (a,b,99)) (1,2,3) --wingrime
07:40:43 <lambdabot>  (1,2,99)
07:40:43 <skypers> field %= ([] <$)
07:40:47 <srhb> wingrime: Works fine.
07:40:52 <edwardk> nope
07:40:55 <skypers> field %= ((<$) []))
07:40:57 <skypers> I guess
07:41:07 <hseg> jmcarthur: Yeah. I guess that would be the correct function.
07:41:10 <edwardk> you can use a setter to go under the functor though
07:41:10 <skypers> ok, I’ll stick to that anyway
07:41:15 <wingrime> srhb: condf a f = if a then f a else a; condmap True (\(a,b,c) -> (a,b,99)) (1,2,3)
07:41:16 <edwardk> field.mapped .= []
07:41:18 <jmcarthur> hseg: an Arrow is basically some sort of monoidal category and functors from Hask to it
07:41:24 <skypers> huh :D
07:41:30 <wingrime> srhb: err
07:41:31 <skypers> what is mapped?
07:41:34 <wingrime> srhb: condf a f = if a then f a else a; condf True (\(a,b,c) -> (a,b,99)) (1,2,3)
07:41:43 <skypers> :t mapped
07:41:44 <lambdabot> (Settable f1, Functor f) => (a -> f1 b) -> f a -> f1 (f b)
07:41:50 <srhb> wingrime: Your lambda does not operate on a Bool
07:41:51 <skypers> it’s overwhelming
07:41:57 <edwardk> > [1..10] & mapped +~ 1
07:41:58 <foofoobar> Hello. So I'm currently developing a lot with go and javascript. Now a friend of mine gifted me a book: "Learn You a Haskell for Great Good!". Can someone give me some arguments why I should try haskell in comparison to e.g. golang?
07:41:58 <hseg> jmcarthur: Yeah, I never got what an Arrow is, precisely.
07:41:58 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
07:42:04 <srhb> wingrime: It has type Num a => (a,a,a) -> (a,a,a)
07:42:17 <srhb> Erm, wait what
07:42:24 <srhb> condf doesn't take three arguments either
07:42:24 <jmcarthur> hseg: largely a hack to get arrow notation, sadly.
07:42:26 <edwardk> you can read "Settable f" as f ~ Identity without losing much information
07:42:27 <hseg> foofoobar: FP over imperative programming in general, or Haskell specifically?
07:42:28 <srhb> It only takes two
07:42:41 <pranz> foofoobar: Haskell
07:42:41 <srhb> wingrime: Barring those two type errors, everything is fine!
07:42:53 <pranz> foofoobar: *will make you think about programming in a new way
07:43:07 <skypers> edwardk: so mapped takes a function and maps it in lens?
07:43:09 <skypers> Lens*
07:43:15 <wingrime> srhb: error messages are hardly readable
07:43:20 <EvanR> go has some craze about it, but its nothing new
07:43:29 <edwardk> skypers: mapped is a 'Setter' that targets all the members of a functor.
07:43:48 <srhb> wingrime: Well, it takes a bit of practice. It's telling you that condf does not take three arguments, only two.
07:43:49 <skypers> edwardk: so it has nothing to do with list?
07:43:52 <edwardk> A Setter is weaker than a Lens. you can't 'get' with it.
07:43:55 <hseg> jmcarthur: Yeah. Considering (***) and (+++) are just bimap and Arrows are all Profunctors, it seems like an overfused hack
07:43:56 <edwardk> it works for any functor.
07:43:58 <skypers> why haven’t you called it fmapped?
07:44:05 <alpounet> skypers: well 'f' could be a list there
07:44:08 <edwardk> because that name sucks ;)
07:44:12 <skypers> ahah :D
07:44:14 <skypers> ok
07:44:14 <zipper> EvanR: I can't find info on how to use GetOpt
07:44:17 <skypers> let me try then
07:44:18 <skypers> hm
07:44:19 <srhb> wingrime: It also helps if you explicitly annotate condf with the type you want it to have
07:44:23 <wingrime> srhb: got it, thanks
07:44:35 <srhb> wingrime: Because the compiler won't try to figure out some other weird type that could maybe possibly work and obscure your message even further
07:44:48 <skypers> > Just 3 & mapped %~ (*3)
07:44:50 <lambdabot>  Just 9
07:44:52 <skypers> hm
07:44:53 <pranz> foofoobar: it is very expressive, modular and safe, which works well for many types of problems
07:45:04 <pranz> foofoobar: but it depends on what you want out of a language
07:45:04 <foofoobar> hseg, pranz: I always thought haskell or in general FP is a good catch for algorythmic things like math calculations or simulations etc. I'm currently developing only for the web. Is using haskell for things like this still a good idea ?
07:45:05 <hseg> skypers: If it weren't for the Prelude's demand of monomorphism, we would have had map = fmap, and then fmapped makes no sense as a name.
07:45:08 <wingrime> srhb: ghci , can't annotate
07:45:10 <EvanR> zipper: theres a hackage package doc if you google haskell getopt
07:45:14 <srhb> wingrime: You can.
07:45:22 <skypers> ok :)
07:45:23 <wingrime> srhb: in ghci?
07:45:23 <edwardk> we have folded, mapped, and traverse / traversed for working wih Foldable, Functor and Traversable as a Fold, Setter or Traversal.
07:45:31 <pranz> foofoobar: yes, haskell excels at back-end web development
07:45:43 <pranz> foofoobar: check out Yesod and Snap
07:45:45 <EvanR> foofoobar: traditional webapps are very good use case for functional programming
07:45:49 <hseg> foofoobar: Yes. Being strongly-typed and functionally pure allows you to reason about your code much more easily.
07:46:06 <skypers> folded?
07:46:07 <skypers> hm
07:46:11 <srhb> > let f :: Int; f = 2 in 2 --wingrime
07:46:12 <skypers> let’s try that then
07:46:14 <lambdabot>  2
07:46:14 <skypers> don’t tell me
07:46:32 <skypers> :t foldel
07:46:33 <lambdabot>     Not in scope: ‘foldel’
07:46:33 <lambdabot>     Perhaps you meant one of these:
07:46:33 <lambdabot>       ‘foldl’ (imported from Data.List),
07:46:34 <skypers> :t folded
07:46:35 <lambdabot> (Contravariant f1, Indexable Int p, Foldable f, Applicative f1) => p a (f1 a) -> f a -> f1 (f a)
07:46:58 <foofoobar> All right, this sounds interesting.
07:47:09 <skypers> > [1..10] & folded %~ (+)
07:47:10 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ t -> t
07:47:10 <lambdabot>  Expected type: t -> t
07:47:10 <lambdabot>    Actual type: t -> t -> t
07:47:20 <skypers> > [1..10] & folded %~ (+1)
07:47:22 <lambdabot>  Could not deduce (Data.Functor.Contravariant.Contravariant
07:47:22 <lambdabot>                      Data.Functor.Identity.Identity)
07:47:22 <lambdabot>    arising from a use of ‘Control.Lens.Fold.folded’
07:47:22 <lambdabot>  from the context (GHC.Num.Num t, GHC.Enum.Enum t)
07:47:22 <lambdabot>    bound by the inferred type of
07:47:27 <skypers> ok lalalala
07:47:29 <foofoobar> Thanks for your explanaitions ;)
07:47:37 <edwardk> folded can only be used to read, not change
07:47:52 <edwardk> traverse can read/write all the targets an can do so with side-effects.
07:47:52 <skypers> :t [1..10] & folded
07:47:54 <lambdabot>     Couldn't match type ‘p0 a’ with ‘[]’
07:47:54 <lambdabot>     Expected type: [f1 a] -> f a -> f1 (f a)
07:47:54 <lambdabot>       Actual type: p0 a (f1 a) -> f a -> f1 (f a)
07:48:03 <edwardk> a setter can only be used to change, not read.
07:48:05 <wingrime> srhb: thanks
07:48:07 <skypers> :t [1..10] & folded id
07:48:08 <lambdabot>     Occurs check: cannot construct the infinite type: t ~ f t
07:48:09 <lambdabot>     Expected type: t -> f t
07:48:09 <lambdabot>       Actual type: t -> t
07:48:09 <srhb> foofoobar: And #haskell is a great reason in itself! :-)
07:48:10 <edwardk> > [1..10]^..folded
07:48:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
07:48:24 <skypers> :t (^..)
07:48:25 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
07:48:36 <skypers> > [1..] ^.. indexed
07:48:38 <lambdabot>  Couldn't match type ‘a
07:48:38 <lambdabot>                       -> Control.Applicative.Const (Data.Monoid.Endo [a]) a’
07:48:38 <lambdabot>                with ‘Control.Applicative.Const (Data.Monoid.Endo [a]) [t0]’
07:48:38 <lambdabot>  Expected type: Control.Lens.Getter.Getting
07:48:38 <lambdabot>                   (Data.Monoid.Endo [a]) [t0] a
07:48:42 <skypers> ok
07:48:44 <skypers> I suck at that.
07:48:46 <edwardk> (^..) gets a list of all of the targets of a getter, fold, traversal, ec.
07:48:58 <skypers> > [1..] ^.. traversed
07:49:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:49:14 <edwardk> > (1,2)^..both
07:49:15 <lambdabot>  [1,2]
07:49:29 * hackagebot cubical 0.2.0 - Implementation of Univalence in Cubical Sets  http://hackage.haskell.org/package/cubical-0.2.0 (AndersMortberg)
07:49:35 <edwardk> > ([1,2],[3,4])^..both.folded
07:49:37 <lambdabot>  [1,2,3,4]
07:49:47 <foofoobar> srhb, yeah I will stay here an see if I can catch some interesting things ;)
07:49:47 <edwardk> > ([1,2],[3,4])^..both.folded.filtered even
07:49:49 <lambdabot>  [2,4]
07:49:52 <skypers> > [1..] ^.. folded.to (*2)
07:49:53 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
07:49:56 <skypers> hm
07:50:08 <srhb> foofoobar: Tends to vary a lot between easy stuff and complex stuff, but yes, do hang. :)
07:50:12 <edwardk> > ([1,2],[3,4])^..both.folded.filtered even.to (`div` 2)
07:50:13 <lambdabot>  [1,2]
07:50:19 <zipper> I guess what I need is to see an example of one of these code parsers in use.
07:50:23 <skypers> this is so crazy edwardk
07:50:28 <EvanR> foofoobar: im working on a video game
07:50:29 <zipper> I mean argument parsers
07:50:30 <edwardk> well, yes.
07:50:49 <skypers> I still don’t understand what ^.. is used for
07:50:51 <skypers> :t (^.)
07:50:52 <lambdabot> s -> Getting a s a -> a
07:50:53 <skypers> :t (^..)
07:50:54 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
07:51:07 <srhb> zipper: Check out the docs for getOptsArgs on hackage in getopt-simple
07:51:20 <edwardk> in lens what we usually do is provide combinators that ape wat you know how to do with Foldable, Traversabe, Functor, etc. right?
07:51:29 <skypers> yep
07:51:46 <edwardk> so if there is a function you can use with a Traversal like mapM, we offer mapMOf that works with any Traversal
07:52:00 <edwardk> foo, becomes fooOf and takes the Traversal, Fold, Lns, whatever as its argument
07:52:19 <edwardk> Foldable offers toList.    (^..) is a convenient infix form of toListOf (flipped)
07:52:25 <zipper> srhb: Maybe the problem is that I expect the parser to work in this way.
07:52:44 <srhb> zipper: Well yeah, these are complete frameworks that hide the parsing from you completely
07:52:46 <zipper> I was hoping there could be a parseArgs function which would be passed the result of getArgs from main
07:52:48 <edwardk> > toList [1..10]
07:52:50 <lambdabot>  can't find file: L.hs
07:52:53 <srhb> zipper: If you really wanted to do it manually, use parsec instead :)
07:52:58 <edwardk> > Data.Foldabe.toList [1..10]
07:52:59 <lambdabot>  Not in scope: ‘Data.Foldabe.toList’
07:53:03 <edwardk> > Data.Foldable.toList [1..10]
07:53:05 <lambdabot>  Not in scope: ‘Data.Foldable.toList’
07:53:05 <lambdabot>  Perhaps you meant ‘Data.Foldable.fold’ (imported from Data.Foldable)
07:53:09 <zipper> srhb: No I don't want to do it manually.
07:53:18 <edwardk> > F.toList [1..10]
07:53:19 <skypers> > Data.Foldable.fromList [1..10]
07:53:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
07:53:20 <lambdabot>  Not in scope: ‘Data.Foldable.fromList’
07:53:20 <lambdabot>  Perhaps you meant one of these:
07:53:20 <lambdabot>    ‘Data.Foldable.fold’ (imported from Data.Foldable),
07:53:20 <lambdabot>    ‘Data.Foldable.foldMap’ (imported from Data.Foldable)
07:53:29 <srhb> zipper: All right, then try the example given. You just specify options and whether they are mandatory or not.
07:53:38 <skypers> btw, http://lpaste.net/103264
07:53:44 <skypers> the difference is quite impressive :D
07:53:45 <edwardk> had to figure out how lambdabot had it in scope
07:54:10 <edwardk> skypers: that is why (some) people like lens ;)
07:54:29 * hackagebot handa-geodata 0.2.0.0 - Geographic and Geometric Data  http://hackage.haskell.org/package/handa-geodata-0.2.0.0 (BrianBush)
07:54:51 <alpounet> edwardk: it's that time of the year when lens gets all the attention, it seems :)
07:55:04 <edwardk> alpounet: its cyclic
07:55:06 <skypers> edwardk: ahah
07:55:17 <skypers> I’m just changing my mind about it
07:55:36 <skypers> I also want to dig in in abstraction, because I lack a lot of stuff
07:55:42 <skypers> like profunctors, and so on
07:55:47 <alpounet> edwardk: it just happens between GHC releases :p
07:55:58 <edwardk> skypers: and gven how hard it was to get you to change your mind, consider the effort of repeating that across the entire ecosystem ;)
07:56:32 <skypers> edwardk: yeah, sure
07:56:56 <skypers> the thing is
07:57:06 <skypers> the more we use that kind of library, the less people will understand our code
07:57:26 <skypers> in my case it’s not a problem since – apart #haskell – I don’t know any other haskellers
07:57:31 <edwardk> yep
07:57:39 <skypers> but now
07:57:46 <skypers> I clearly understand Haskell is some like of elite
07:57:48 <nschoe> Hi all, is there anyone who can help me with network-tcp-tls ? I am trying to establish a TLS connection between a server and a client, both running in local. I created two private keys with openSSL on my machine, but I keep getting HandshakeFailed errors "certificate has unknown CA" when I run the client.
07:58:05 <skypers> it’s like the same talk we had last night edwardk
07:58:13 <skypers> about representing arrays as function from indices to values
07:58:16 <edwardk> on the other hand, many of the things you say borrow vocabulary from other domains. we don't deliberatey try to be exclusionary with lens, we just want it to be general and not to repeat ourselves
07:58:26 <skypers> using functor and adjunctions
07:58:36 <skypers> it’s really hard to people not used to it
07:58:40 <edwardk> sure
07:59:02 <skypers> plus, I always thought boilerplate is _not_ that bad
07:59:08 <skypers> but hm
07:59:10 <edwardk> but i want to write software that functions well. i'm happy to help bring other people along for the ride, but I'm going on the ride regardless ;)
07:59:11 <fizruk> X is hard for people not use to X
07:59:13 <skypers> I’m changing my mind :)
07:59:32 <skypers> yeah I got that edwardk :)
07:59:39 <skypers> I still think you’re crazy :D
07:59:41 <skypers> (laughter)
07:59:44 <edwardk> well, yes.
08:00:29 <skypers> the thing I know: 80% of the libs I use were written by you
08:00:35 <skypers> you’re everywhere
08:00:47 <skypers> you should rename the language Hadward
08:00:50 <skypers> ;)
08:01:29 <nschoe> Anyone who has played with network-simple-tls, perhaps ?
08:01:41 <edwardk> well, just saying, if the kinds of ideas I like to think lend themselves to such wide adoption despite their pie-in-the-sky nature perhaps there is merit to the approach ;)
08:02:11 <skypers> nschoe: nope, sorry
08:02:14 <skypers> edwardk: indeed
08:02:18 <fizruk> nschoe: a year ago, don’t remember anything :p
08:02:28 <skypers> I still understand where you take all that kind of stuff from
08:02:37 <skypers> have you studied in a math course?
08:02:43 <srhb> zipper: http://lpaste.net/103266
08:02:43 <skypers> +don’t
08:02:54 <srhb> zipper: I hope that's minimal enough to be understandable
08:02:56 <nschoe> fizruk, argh. Nevermind, thanks anyway
08:03:11 <zipper> srhb: It's loading. I hope so too :)
08:03:23 <fizruk> nschoe: you can ask a question and perhaps someone will answer it anyways (iirc the library is rather small and simple) :)
08:04:07 <srhb> zipper: The idea is that test is a required flag that takes no arguments. Calling the program with anything but --test will spew a help message. If it does parse correctly, I print the opts Map (which is boring because only test is specified and it takes no arguments)
08:04:17 <srhb> zipper: Try replacing noArg with arg and see if you understand what is happening
08:04:20 <edwardk> skypers: math, CS, AI, bioinformatics, computational linguistics... I like collecting toys
08:04:31 * hackagebot handa-geodata 0.2.0.1 - Geographic and Geometric Data  http://hackage.haskell.org/package/handa-geodata-0.2.0.1 (BrianBush)
08:04:39 <nschoe> fizruk, it is, indeed. But I don't think my problem isrelated to the library itself. I successfully created a minimalistic server app that is listening o na port, and did the same with a client. But when that client connects, I get an error on Handshakem with the "certificate has unknown CA"
08:06:00 <skypers> edwardk: I heard you made some demoscene stuff
08:06:04 <skypers> do you have a pouet link?
08:06:08 <fizruk> nschoe: that certificate thing I forget immediately after using it, but there’s ton of info in the internet. I guess the problem can be unrelated to haskell as well
08:06:16 <nschoe> From what I *seem* to understand, the client rejects the server's certificate because it is not signed by a CA. But I don't know how to bypass it for now : I want to test my app on my computer, I don't care if the certificate is not signed for now.
08:06:37 <fizruk> nschoe: you need a self-signed certificate, iirc
08:07:16 <nschoe> fizruk, that s what I think indeed. But I believe I generated one with openssl command-line. So I don't understand the problem here
08:07:17 <edwardk> i haven't rummaged through there looking for the projects i contributed back in day. i mostly helped other people with their demos by helping out on the algorithm side trying to meet space constraints or figure out a vehicle to get an effect. once that was done the effect itself wasn't really all that interesting to me ;)
08:07:35 <fizruk> edwardk: I wish there were more *simple* examples connecting those fields, so that it would be easier to dig in
08:07:36 <skypers> ok
08:07:43 <skypers> I see
08:07:53 <fizruk> edwardk: perhaps I just don’t know where to look though :p
08:07:56 <nicoo> nschoe: openssl req -new -x509 -key privkey.pem -out cacert.pem -days <whatever expiration time>
08:08:03 <nicoo> nschoe: cf https://www.openssl.org/docs/HOWTO/certificates.txt
08:08:08 <edwardk> skypers: old shout outs to Harmless are about 50% to me and 50% to some german guy ;)
08:08:24 <nschoe> nicoo, yes, exactly what I have done.
08:09:01 <nicoo> nschoe: Then you should have a valid self-signed certificate. What kind of error is your client throwing ?
08:09:08 <nschoe> nicoo, but maybe I'm misunderstanding here, the file cacert.pem that I obtained with this method. Is it a certificate ? Or a certificate store ?
08:09:31 * hackagebot hspec-meta 1.9.3 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.9.3 (SimonHengel)
08:09:32 <nicoo> It is a certificate
08:10:04 <skypers> edwardk: I hope my engine will be working asap
08:10:22 <skypers> I don’t know whether I had a good idea
08:10:26 <skypers> if you look at gpipe
08:10:28 <skypers> or lambdacube
08:10:34 <skypers> they build something really simple
08:10:37 <skypers> not an “engine”
08:10:41 <nschoe> nicoo, okay perfect. So it is the right thing. I use it with fileReadCertificate from the NEtwork.TLS.Extra libray. The error I the nget from my client is : HandshakeFailed (Error_Protocol ("certificate has unknown CA",True,UnknownCa))
08:10:45 <skypers> I directly jumped into the engine construction
08:11:08 <edwardk> maybe we should shunt this conversation over to #haskell-game
08:11:21 <nicoo> nschoe: Sounds right. Can you ask the client not to validate the certificate ?
08:11:38 <nicoo> (for testing *ONLY*)
08:12:48 <nschoe> nicoo, that's what I came asking here actually. But did I get this right ? I issued the openssl req -new [...] command twice : to generate a certificate for 1) the server app and 2) the client app. Am I correct ?
08:14:23 <nicoo> The client application doesn't need a certificate
08:14:32 * hackagebot hspec 1.9.3 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.9.3 (SimonHengel)
08:14:40 <nicoo> (unless you are athenticating clients using certificates, but you would know)
08:16:08 <nschoe> nicoo, well, how the server knows the client's keys and all for encrypting messages then ?
08:17:24 <corgifex> what client keys?
08:17:33 <nicoo> The client and the server usually use a Diffie-Hellman key exchange to agree on a shared key which is then used for encryption (using a symmetric cipher)
08:17:55 <nicoo> In TLS, public-key crypto isn't used for encryption (would be very slow)
08:18:24 <nschoe> nicoo, because on the network-simple-tls there is the 'connect' function (for the client), and it takes a 'ClientSettings' parameter, to get this I use 'makeClientSettings' which takes a [Credential] as its first parameter and a CertificateStore as its third. The Credential is data Credential = !x509 !PrivateKey [x509 so ... how come the client doesn't need a certificate ?
08:19:27 <nschoe> corgifex, nicoo does that mean, that a server will then accept *any* incomming connection from any client then ? I mena... then what are the certificates used for anyway ?
08:21:13 <pnielsen> typically clients aren't authenticated, just the server. If you want mutual authentication (client verifies that the server it's talking to is the one it wants, but the server also verifies that the client is allowed to talk to it), then you should use client certs
08:21:28 <pnielsen> you can check that the client's certificate was signed by you, for example
08:22:22 <nicoo> nschoe: Usually, the certificates are used to authenticate the server
08:22:45 <nicoo> You can have a certificate on the client and authenticate it too, it's just not usually done.
08:23:03 <nschoe> pnielsen, ah ok, thanks
08:23:18 <nschoe> nicoo, why isn't it usually done ?
08:23:30 <zipper> srhb: I replaced it with arg and got confuuussseeeedddddddd
08:23:54 <zipper> srhb: ` -t TEST  --test=TEST  This is a test flag '
08:24:44 <nschoe> But then, the correct way is to create a certificate with openssl req -new x509 [...] for the server, right ?  But then, how do I connect with my client to that server ?
08:24:54 <nicoo> nschoe: Because if you are running a website, for instance, you usually want anyone to be able to connect
08:25:13 <nicoo> Also, most people find authentication by client certs confusing
08:25:46 <srhb> zipper: Yeah, now it requires an argument to -t or --test=
08:25:58 <srhb> zipper: Anything else will throw the help message :)
08:26:00 <nschoe> nicoo, okay
08:26:04 <klrr_> what is "HOF"?
08:26:14 <corgifex> higher order function
08:26:28 <nicoo> nschoe: You can check that the server is handling TLS correctly by running `openssl s_client -connect host:port` (replacing host and port by the correct value)
08:26:32 <nicoo> values*
08:26:54 <nicoo> If it works correctly, then the problem is in your client code.
08:27:50 <klrr_> thanks
08:29:53 <nschoe> nicoo, okay I tried this but this fails
08:30:02 <no-n> :t exitFailure
08:30:03 <lambdabot>     Not in scope: ‘exitFailure’
08:30:03 <lambdabot>     Perhaps you meant ‘expectFailure’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
08:30:25 <nschoe> nicoo, I have "connect: Connection refused errno=111"
08:31:04 <corgifex> no one's listening
08:31:27 <nschoe> And I have nothing on the server's output. Whereas when I used my client app, I had a line telling me that the connection was reset by peer.
08:31:56 <nschoe> corgifex, openssl s_client -connect localhost:1089 is the right syntax, right
08:32:53 <corgifex> no idea
08:33:25 <corgifex> I just know ECONNREFUSED means there's no server listening on that address
08:35:23 <nschoe> corgifex, okay. But then this is weird that when I use "connect" function with localhost and 1089 argument it seems to reach the server (for at least some moment), no ?
08:36:21 <skypers> hm, how should I get a value in MonadState if it’s a Lens?
08:36:27 <skypers> gets renderScene fails
08:36:34 <nicoo> nschoe: Are you sure you used the right port ?
08:36:38 <z0d> hello
08:37:01 <nicoo> You can use netstat -lp (on Linux) to display processes linstening on the network
08:37:07 <nschoe> nicoo, well *starting getting paranoid*, the port is the one the server is set to listen to, right ?
08:37:16 <corgifex> strace is always your friend
08:37:17 <z0d> do you recommend going into a Haskell Hackathon even if you aren't a pro Haskeller?
08:39:04 <nschoe> nicoo, okay I see my program listening with netstat -lp, but I don't see a port ?
08:41:07 <geekosaur> nschoe: you might pastebin that output
08:41:24 <edwardk> skypers: use renderState
08:41:42 <skypers> edwardk: hm?
08:41:46 <nschoe> geekosaur, yeah, sry. Forgot it : was reading some doc in the same time :/
08:41:53 <edwardk> x <- use _1   will get the value of the first part of your state in a state monad
08:41:53 <skypers> without lens
08:42:01 <skypers> oh, use
08:42:04 <skypers> :t use
08:42:05 <lambdabot> MonadState s m => Getting a s a -> m a
08:42:07 <geekosaur> and, if I had to make a guess with no information, my guess would be that you're being bitten by need for ntohs somewhere (in Haskell that's magic behavior hidden in a Port constructor, annoyingly) --- without which you get a byteswapped port number
08:42:08 <skypers> ok
08:42:09 <skypers> thank you
08:42:24 <genkinodenki> I'm trying to call a function in a haskell shared object file from SBCL, but don't know how to init the runtime environment, other than hs_init and possibly hs_add_root being involved.  I don't know what args to pass or how precisely, can anyone help?
08:42:50 <genkinodenki> by SBCL I mean lisp implementation, using CFFI
08:43:40 <nschoe> I've got this when running netstat -lp : http://lpaste.net/103267
08:45:02 <geekosaur> oh, add -n to the netstat flags
08:45:27 <geekosaur> it's showing a truncated port name from /etc/services (ff-annunc)
08:45:34 <corgifex> genkinodenki: http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1700008.7 etc.
08:46:09 <geekosaur> oh, it's not even truncated. ff-annunc       1089/tcp    # FF Annunciation
08:46:29 <nschoe> okay
08:46:49 <geekosaur> so it's on the right port. ipv6 though, I note
08:47:15 <geekosaur> also it's listening on loopback only, if that matters
08:47:26 <geekosaur> won't accept connections from off-system
08:47:26 <nschoe> geekosaur, http://lpaste.net/103267 ok so that is correct : it does listen on 1089
08:47:57 <nschoe> geekosaur, ho ipv6 this is right. Have to change that I think.
08:48:34 <nschoe> geekosaur,  well at the moment I'm testing on the same machine so the loopback should not be a problem. I wonder how to change that, though.
08:48:35 <geekosaur> whether you do or not depends on what kind of system you're on. some linuxes prefer to listen on ipv6 and use a kernel-based ipv6 to ipv4 thing
08:48:52 <nschoe> geekosaur, ah ... well I'm under Archlinux.
08:49:11 <geekosaur> specify the bind address as 0.0.0.0 or the equivalent ipv6 null address instead of the loopback address
08:49:21 <zipper> srhb: I guess I do get your example but it won't take more than one arg per flag.
08:49:36 <zipper> srhb: e.g --test we w00t
08:49:49 <zipper> It only takes the first
08:50:06 <nschoe> geekosaur, let me go check the doc for that ^^
08:51:28 <nschoe> geekosaur, omg thanks !
08:51:54 <nschoe> geekosaur, replaces Host "localhost" with HostAny and when I tried openssl s_client it worked
08:51:56 <srhb> zipper: Yes, that's normal behaviour for command line options
08:52:06 <geekosaur> interesting
08:52:56 <nschoe> geekosaur, yes this is weird : my server and openssl s_client were run on the same machine...
08:53:28 <geekosaur> I wonder if it is binding to both now and openssl was using only ipv4 to try to connect
08:53:43 <skypers> :t (%=)
08:53:44 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
08:54:08 <nschoe> geekosaur, I can test it easily : I can HostIPv{4,6}.
08:54:08 <geekosaur> some of the automagic stuff linux does leads to weird behavior at times
08:54:39 <skypers> :t uses
08:54:40 <lambdabot> (MonadState s m, Profunctor p) => Optical p (->) (Const r) s s a a -> p a r -> m r
08:55:31 <nschoe> geekosaur, nah problem doesn't seem to come from here : I tested with HostIPV4 and HostIpv6 and it bth worked when I tried with  openssl
08:55:47 <nschoe> Only Host "localhost" doesn't work here
08:56:10 <zipper> srhb: I need it to... take many
08:56:26 <srhb> zipper: You can separate them by commas, for instance
08:56:40 <srhb> zipper: If you want something like --opt arg1 arg2 arg2 getOpt-simple won't suffice
08:57:23 <zipper> srhb: I better use getOpt itself?
08:57:43 <zipper> Yeah I need something like --opt arg1 arg2 arg2
08:58:07 <corgifex> zipper: I dislike your interface
08:58:28 <srhb> zipper: I'm not sure if optArg will help either. cmdTheLine might, or roll your own
08:58:33 <srhb> Or better, adhere to standards. :-)
08:59:06 <hseg> Is there a more idiomatic way to write "\p -> map fst . filter (elem p . snd) . (zip <$> id <*> tails)"? It should return the shortest prefix of a list which includes all occurences of p.
08:59:20 <zipper> corgifex: Why?
08:59:23 <srhb> Actually yeah you can do it with getOpt
08:59:57 <nschoe> geekosaur, ahrgh :/ Now this is my client app that won't connect. I don't getthe handshake error anymore, I can't even reach the server :/
08:59:59 <corgifex> zipper: because it doesn't follow the usual standards for command line options
09:00:07 <corgifex> also because it's syntactically ambiguous
09:00:24 <zipper> corgifex: What if you wanted to upload multiple files like --file file1 file2 ?
09:00:40 <corgifex> why not just pass them as arguments
09:00:43 <corgifex> ?
09:00:50 <corgifex> upload_stuff file1 file2 file3
09:00:55 <srhb> zipper: Then --file would be an option with no arguments and the files would be arguments
09:02:25 <zipper> srhb: Like --ext hs --file cat.hs book.hs
09:03:00 <corgifex> what is --file good for?
09:03:18 <zipper> corgifex: The files one wants to upload
09:03:27 <corgifex> why does that need an option?
09:03:33 <pjdelport> hseg: What's the context?
09:03:34 <corgifex> why not just pass them as arguments?
09:04:37 <hseg> Context is that I'm deriving Richard Bird's implementation of minNub. Along the way, I need to give the elements of a list according to the order of their disappearance.
09:04:38 <genkinodenki> corgifex: thanks, but I'm not really getting anywhere.  I've understood passing null as both argc and argv should suffice, but I'm not even sure I'm accomplishing that.  I get call to hs_init to return "no value" in console, but it's a black box to me, and calling the function in the .so just breaks my slime connection.  I guess I'd need handholding from a lisper who's used haskell in conjuction with lisp.
09:04:43 <zipper> corgifex: because one can do other things other than upload files? seems neat. Like specify the extension then filenames?
09:05:09 <corgifex> zipper: what other things?
09:05:29 <wingrime> srhb: haskell are sutable for PDE solve?
09:05:32 <wingrime> srhb: haskell are sutable for PDE solve?
09:05:38 <wingrime> er
09:05:47 <srhb> Why not!
09:05:56 <srhb> You probably have to write the necessary solvers yourself though :-)
09:06:15 <zipper> corgifex: Like login info and file extension
09:06:28 <srhb> zipper: But those are options. No problem
09:06:36 <corgifex> zipper: that's not something you do, that's something that is
09:06:53 <corgifex> I don't understand what the "file extension" bit is good for, though
09:07:59 <skypers> oh
09:08:03 <skypers> if I define a type
09:08:12 <skypers> data Foo { _foo :: Int, _bar :: Float }
09:08:19 <skypers> if I want to export foo and bar (from lens)
09:08:28 <srhb> corgifex: zipper (opts, args) <- getUsingConf option ["files"]; print args
09:08:29 <skypers> do I have to explicitely export them?
09:08:32 <srhb> Oops
09:08:35 <srhb> zipper: ^^^
09:08:39 <wingrime> srhb: I have simple solver made on python, that use vectorized numpy operations, or I can easy implement using two 'for' in C
09:08:50 <srhb> wingrime: Yes, you can do that in Haskell, too.
09:08:53 <pjdelport> hseg: as a cheap shot, you could always do: \p -> reverse . dropWhile (/= p) . reverse
09:08:54 <edwardk> skypers: two approaches, makeLenses ''Foo requires explicit export one by one. makeClassy ''Foo will make a HasFoo class you can export in one go with HasFoo(..)
09:09:01 <edwardk> that HasFoo class has all the accessors in it
09:09:06 <rpetrano> Hi all! I want to make a simple tick tack toe game as exercise. I would like to build a desktop application with UI (can be console as well, but with something like ncurses). Can you suggest me the best library for the job?
09:09:15 <wingrime> srhb: but I have no idea how fast it will be
09:09:25 <srhb> wingrime: Best try it out and find out? :)
09:09:29 <srhb> (As fast as you make it)
09:09:44 <ReinH> you can use comonads :D
09:10:05 <ReinH> on a pointed array
09:10:10 <srhb> rpetrano: Instead of ncurses there's vty-ui which is pure Haskell
09:10:23 <srhb> rpetrano: for gui bits there are many options, but for a simple first iteration gloss is very nice
09:10:30 <ReinH> or, you know, just implement your original iterative solution
09:10:38 <skypers> edwardk: huhu, ok, I’ll go one-by-one then
09:10:47 <pjdelport> hseg: Oh, there's also dropWhileEnd now: \p -> dropWhileEnd (/= p)
09:11:33 <pjdelport> or just "dropWhileEnd . (/=)" :)
09:11:44 <edwardk> skypers: makeClassy is generally the way to go if you can get away with it
09:11:56 <zipper> corgifex: Someone might want to explicitly set it for syntax highlighting and such.
09:12:03 <srhb> Oh, I have yet to try makeClassy. Although it sounds classy.
09:12:24 <zipper> srhb: That reads all args, interesting
09:12:34 <corgifex> zipper: are you writing a pastebin tool?
09:12:39 <srhb> zipper: That's the point. options take one value (optarg) and arguments are "the rest"
09:12:40 <corgifex> BTDT
09:12:43 <zipper> corgifex: Yes
09:12:46 <edwardk> you can get nice subtyping like things wth it by making instances of your HasFoo for larger types that have one Foo in it
09:13:09 <hseg> pjdelport: That's nice. Pity it isn't in Data.List.
09:13:18 <corgifex> then you want --type, not --ext
09:13:27 <corgifex> and filenames shouldn't be option arguments
09:13:34 <corgifex> they should be plain arguments
09:13:37 <pjdelport> hseg: It's since 4.5.0.0, apparently
09:13:37 <zipper> corgifex: What should they be?
09:13:58 <zipper> corgifex: Can't one have the option to set filename?
09:14:01 <pjdelport> hseg: the implementation is simple, though: \p -> foldr (\x xs -> if p x && null xs then [] else x : xs) []
09:14:05 <zipper> I get your point
09:14:21 <pjdelport> inlining (/=) into that gives you a solution
09:14:32 <corgifex> depends on what you mean by "set filename"
09:14:38 * hackagebot flaccuraterip 0.3.0 - Verify FLAC files ripped form CD using AccurateRip"  http://hackage.haskell.org/package/flaccuraterip-0.3.0 (NicolaSquartini)
09:15:08 <Luke_> is there a non-exception version of head anywhere? [a] -> Maybe a or something?
09:15:21 <ReinH> @hackage safe
09:15:21 <lambdabot> http://hackage.haskell.org/package/safe
09:15:23 <corgifex> @hoogle [a] -> Maybe a
09:15:23 <pjdelport> :t listToMaybe
09:15:24 <lambdabot> [a] -> Maybe a
09:15:24 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
09:15:24 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
09:15:24 <lambdabot> Prelude head :: [a] -> a
09:15:35 <zipper> srhb: corgifex:  See if I have --type hs --file one.hs two.hs but make an error in say --type hs sml under args I will find all args bundled into one string as in sml two.hs
09:15:56 <corgifex> wat
09:15:59 <pjdelport> Luke_: listToMaybe is the canonical way to do a safe head, before using the safe package
09:16:00 <srhb> zipper: I didn't catch that
09:16:14 <Luke_> pjdelport: thanks
09:16:14 <pjdelport> Luke_: usually you just want to pattern-match, though
09:16:26 <Luke_> yeah ok that's what i'm doing now
09:16:31 <Luke_> explicitly checking for []
09:16:31 <srhb> Luke_: Generally you're just trading one pattern match for another
09:16:35 <Luke_> right
09:16:41 <srhb> Luke_: Because you'll want to deconstruct the Maybe at some point, too.
09:16:42 <rpetrano> srhb: thanks!
09:16:48 <Luke_> but at least w/ a typesafe head you know you always did it
09:16:53 <srhb> rpetrano: What did I do? :p
09:17:09 <srhb> Luke_: Sure. :)
09:17:11 <Luke_> it's basically grep-able that i'm being safe then if I use a maybe version and no fromJust
09:17:38 <srhb> rpetrano: Oh lol, nevermind me
09:17:45 <rpetrano> srhb: you recommended me vty-ui, I might use it. Thanks :)
09:17:46 <srhb> I apparently can't remember more than 30 seconds into the past
09:17:48 <srhb> :-)
09:18:00 <zipper> srhb: What I mean is that if one passes an extra argument accidentally to --test it will be put in one list with any extra arguments passed to --file
09:18:27 <srhb> There are no "extra arguments" passed anywhere
09:18:33 <srhb> Options take either one or no options
09:18:42 <corgifex> *arguments
09:18:43 <zipper> srhb: e.g--type hs sml --file one.hs two.hs  ["sml", "two.hs"]
09:18:47 <srhb> Yes, sorry
09:19:05 <corgifex> zipper: ok, now get rid of --file
09:19:22 <corgifex> --type=hs sml one.hs two.h
09:19:27 <zipper> corgifex: Well stating --file should be optional
09:19:32 <corgifex> --file shouldn't exist
09:19:57 <zipper> corgifex: At this point I care more about making it actually read the arguments
09:20:24 <zipper> corgifex: Ok forget the --file
09:21:22 <zipper> corgifex: In this case it will throw a fit because there is no such file as sml
09:21:30 <corgifex> right
09:22:10 <zipper> corgifex: That's a bad thing
09:22:16 <corgifex> why?
09:23:38 <srhb> zipper: As I see it you want to create a program that ONLY takes options and their arguments, either delimited by another option or end of line
09:23:58 <srhb> It's nonstandard, but sure it can be done
09:24:05 <srhb> Easy parsec parser right there.
09:25:22 <zipper> srhb: I don't want to make something that is non standard.
09:25:39 <zipper> srhb: I honestly don't know what is standard
09:25:41 <srhb> zipper: Then listen to corgifex :)
09:26:11 <srhb> zipper: How would your program understand --type hs sml foo.hs bar.sml baz.c ?
09:26:28 <srhb> (It wouldn't which is why you want the --file delimiter, which is weird)
09:26:43 <corgifex> solution: don't allow multiple file arguments
09:26:48 <srhb> I agree
09:27:10 <zipper> corgifex: What do you mean don't allow multiple file arguments?
09:27:24 <corgifex> always upload exactly one file
09:27:39 <zipper> srhb: What you talked of is a problem whose solution I haven't figured out.
09:27:45 <srhb> zipper: Indeed.
09:27:47 <zipper> corgifex: That's baaadddd
09:27:53 <srhb> zipper: I think your design is just problematic :)
09:27:56 <corgifex> zipper: why?
09:27:57 <zipper> Only one file at a time?
09:28:04 <corgifex> yes
09:28:26 <zipper> See I am writing something for ix.io that is much better than what we have right now.
09:28:51 <zipper> and ix.io allows for multiple files
09:29:00 <srhb> Group types with filenames then?
09:29:13 <srhb> If you really want to have multiple file names, the parameters that apply to one file should stay with one fil
09:29:15 <srhb> file*
09:29:52 <corgifex> wait, wtf?
09:30:00 <zipper> corgifex: What?
09:30:01 <srhb> hm?
09:30:06 <corgifex> it requires you to send file contents in the url?
09:30:16 <corgifex> as query parameters?
09:30:21 <zipper> Hell yeah it does
09:30:30 <corgifex> that's super stupid
09:30:53 <zipper> corgifex: You are such a frustrated man.
09:30:57 <zipper> or woman
09:31:07 <corgifex> thank you for your interest
09:31:46 <zipper> Sending the file in a post request is the only way.
09:32:11 <zipper> srhb: It can read the last chars after a dot and take that to be the type
09:32:17 <zipper> but that needs regex
09:32:22 <srhb> zipper: No it doesn't.
09:32:38 <corgifex> zipper: yes, exactly
09:32:41 <zipper> srhb: It doesn't?
09:32:53 <corgifex> zipper: that's why post requests usually DON'T USE QUERY PARAMETERS
09:33:23 <noobelina> How do I use functions from here Data.List.Ordered ? http://hackage.haskell.org/package/data-ordlist-0.4.5/docs/Data-List-Ordered.html
09:33:37 <srhb> zipper: Of course not, any kind of parser or even just splitting at some char will work fine
09:34:20 * ReinH shrugs
09:34:24 <zipper> srhb: Ok I don't think I have yet found a solution to my original problem. Parsing arguments
09:34:27 <ReinH> it's valid per the http spec
09:34:50 <corgifex> oh, I see. the API documentation is lying
09:34:57 <srhb> noobelina: What do you mean?
09:35:01 <srhb> noobelina: import it and use them?
09:35:04 <corgifex> it actually wants a url-encoded post body
09:35:15 <srhb> noobelina: Maybe qualified import or hiding the base list functions
09:35:16 <corgifex> as in multipart/form-data
09:35:23 <noobelina> srhb: temp.hs:2:8:
09:35:23 <noobelina>     Could not find module `Data.List.Ordered'
09:35:38 <srhb> noobelina: you have to install data-ordlist
09:35:41 <corgifex> ReinH: yeah, but you wouldn't use it for file uploads
09:35:52 <ReinH> > let ext = reverse . takeWhile (/= '.') . reverse in ext "foo/bar.hs"
09:35:54 <lambdabot>  "hs"
09:36:08 <ReinH> no regexp there
09:36:35 <noobelina> srhb: how do I know that it is "data-ordlist " that I need to install?
09:36:44 <srhb> noobelina: http://hackage.haskell.org/package/data-ordlist-0.4.6.1
09:36:57 <srhb> noobelina: "The data-ordlist package" :-)
09:37:16 <srhb> noobelina: The top bar of Hackage also says so
09:37:40 <noobelina> hmm ok ^^
09:37:47 <zipper> Even tmux won't do what I say
09:39:41 * hackagebot reheat 0.1.4 - to make notes and reduce impact on idle time on writing other programms.  http://hackage.haskell.org/package/reheat-0.1.4 (palo)
09:44:29 <srhb> I think that ordlist package is weird. Not even a wrapper type?
09:52:00 <ReinH> we already have sets and multisets and they don't require you to maintain the ordering requirements yourself
09:53:00 <ReinH> they also have better performance than a list for most things
09:53:16 <ReinH> So yes. It's weird.
09:54:37 <copumpkin> it's not uncommon to want to perform set-like operations on ordered lists
09:54:55 <copumpkin> I think that package was intended to provide just the low-level algorithms on them without much on top of it
09:55:33 <copumpkin> ReinH: and it's slightly more flexible than your typical sets and multisets
09:55:52 <ReinH> copumpkin: I suppose it isn't weird... but maybe it should be :p
09:56:02 <ReinH> s/weird/uncommon
09:56:03 <copumpkin> well, things like merge or subtract, etc.
09:56:11 <copumpkin> can work on infinite lists
09:56:22 <copumpkin> mergeAll can work on infinite lists of infinite lists
09:56:31 <copumpkin> as long as they're sensibly ordered, you get sensible output
09:56:47 <copumpkin> it's an easy way to write a very clean purely functional prime sieve, for example
09:57:15 <copumpkin> generate infinite lists of all multiples of a prime, subtract them from all naturals, and tie the knot
09:58:13 <ReinH> copumpkin: makes sense
09:59:27 <cbarrett> cf. SICP's chapter on streams
10:05:02 <brettweavnet> #Haskell, I'm new to the language and trying to get IO and mixing pure with in-pure functions...
10:05:33 <brettweavnet> Can anyone point me to how to work with an IO String.
10:05:52 <brettweavnet> for example, I'm string to output it from a string that returns IO String
10:05:53 <brettweavnet> https://gist.github.com/11350427.git
10:06:14 <hpc> your link is bad
10:06:16 <brettweavnet> Working link: https://gist.github.com/brettweavnet/11350427
10:07:25 <honza> is there a way to check if a library uses unsafe io?  can i tell ghc to only allow IO within the IO monad in my code and its dependencies?
10:07:54 <mindleyhilner> brettweavnet: putStrLn :: String -> IO ()
10:07:59 <hpc> brettweavnet: you're going to want to do
10:08:03 <hpc> main = do
10:08:07 <hpc>   msg <- getIt
10:08:09 <hpc>   putStrLn msg
10:08:18 <hpc> or more tersely, main = getIt >>= putStrLn
10:08:29 <mindleyhilner> or getIt >>= putStrLn
10:08:32 <hpc> :t (>>=)
10:08:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:08:54 <brettweavnet> @hpc I gave that a shot and get:3.hs:6:7: parse error on input `<-'
10:08:55 <lambdabot> Maybe you meant: src rc pl ghc
10:09:23 <mindleyhilner> you should paste your shot, then
10:09:27 <brettweavnet> @hpc ahhh, never mind, forgot my do.  Thanks
10:09:27 <lambdabot> Maybe you meant: src rc pl ghc
10:09:37 <hpc> brettweavnet: address people like this
10:09:48 <hpc> we're on IRC, not twitter, and lambdabot will go wild with it
10:10:04 <hpc> you can tab-complete names
10:10:13 <brettweavnet> hpc: will do, just moved from github window....
10:10:37 <hpc> the basic "why" of your issue is
10:10:51 <hpc> you can't directly just go do things with IO String like you would a String
10:11:08 <roconnor> honza: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/safe-haskell.html
10:11:11 <hpc> but you can sequence IO actions together with (>>=) (or do-notation which is syntax sugar)
10:11:56 <honza> roconnor: thanks --- bafffled that this isn't the default
10:11:57 <hpc> action >>= nextFunction -- this line is going to do action, and then pass the result to nextFunction by way of specific internals
10:12:34 <roconnor> honza: I don't know much about it.  That whole -XTrustowrothy feels like it defeats the whole purpose of -XSafe.
10:12:35 <hpc> you can use (>>=) with loads of types, and how it sequences actions varies from type to type
10:12:49 <roconnor> honza: I just hope I am misunderstanding something
10:12:51 <brettweavnet> hpc thanks, would it be correct to say, that once something is IO, I need to treat it as such all the way back to main?
10:13:14 <merijn> roconnor: Define "defeats the purpose"
10:13:15 <hpc> brettweavnet: i think so, yes
10:13:34 <brettweavnet> hpc got it, thanks for the help.  appreciate it.
10:13:38 <hpc> brettweavnet: there may be some subtlety that's going to gloss over, but it gets you programming
10:13:50 <roconnor> merijn: can an adversary mark their module as "Trustworthy" and simply subvert the safety system with one flag?
10:14:07 <brettweavnet> hpc I'm sure, one step at a time
10:14:57 <monochrom> brettweavnet: read my http://www.vex.net/~trebla/haskell/IO.xhtml
10:14:59 <merijn> roconnor: No, Trustworthy claims "this is safe even if GHC can't infer it", but (well, depending on flags) GHC only believes Trustworthy flags from trusted packages
10:15:50 <brettweavnet> monochrom thanks, this looks very helpful.
10:15:58 <merijn> roconnor: Specifically, see 7.25.4.1 and 7.25.4.2
10:16:34 <roconnor> honza: -XSafe turns off a couple useful things, like RULES
10:16:47 <ocharles> dreixel, kosmikus - either of you around?
10:18:05 <merijn> I have an intro category theory question (well, questions)
10:18:37 <merijn> So I understand the preorder category where objects are items in the preorder and arrows signify the preorder (i.e. an arrow A -> B signifies A <= B)
10:19:27 <noobelina> List can be infinite, can sets be infinite?
10:19:46 * hackagebot sdl2 1.1.0 - Bindings to SDL2  http://hackage.haskell.org/package/sdl2-1.1.0 (Polarina)
10:19:50 <roconnor> merijn: preorders are awesome!
10:20:11 <merijn> But I'm confused by the monoid category (lets use natural numbers and addition), according to texts I've read this category has one object and an arrow for each natural number, arrow composition being the monoid operation and the identity arrow being 0
10:20:39 <merijn> I mean, wouldn't all arrows in this category be "A -> A" (assuming A is the single object in the category)
10:21:39 <monochrom> that is right
10:21:42 <merijn> That essentially would mean I'd have countably infinite arrows of type "A -> A"? How would you distinguish which 'arrow' corresponds to which natural number? Do arrows have an "identity"?
10:21:56 <monochrom> also right
10:22:20 <merijn> And their identity is generally just their name?
10:22:49 <pjdelport> merijn: in category theory in general, it can make sense to think of "object" as "type", rather than e.g. "vertex"
10:23:01 <merijn> So "9 : A -> A" and "3 : A -> A" would mean "12 : A -> A = 9 . 3"?
10:23:30 <merijn> (or for that matter "3 . 9")
10:23:39 <monochrom> let me put it this way. in a category that uses functions for arrows, "are f1, f2 the same arrow" is settled by "are f1, f2 the same function", because I just said "uses functions for arrows"
10:24:18 <monochrom> therefore, in a category that uses XXX for arrows, "are f1, f2 the same arrow" is settled by "are f1, f2 the same XXX". use XXX's equality.
10:25:14 <monochrom> so if you use natural numbers for arrows, you use natural number equality.
10:25:27 <merijn> monochrom: Right, but that essentially means you need to have (outside the category) some notion of arrow 'f' refers/maps to concept 'x'
10:25:44 <monochrom> every example of category has it
10:26:03 <pjdelport> merijn: Category theory itself doesn't give special identities (in the sense you mean) to arrows: you can see the purpose of CT as being to remove such detail.
10:26:20 <merijn> monochrom: Right, but that's not obvious to confused people like me :p
10:26:27 <pjdelport> being that non-specific is what makes it so general
10:26:44 <monochrom> every example category also tells you to use what for objects. I don't think arrows are treated really differently in this regard.
10:27:40 <monochrom> same question as "are A,B the same object" too. if you use YYY for objects, then use YYY's equality.
10:29:26 <merijn> Right, back to reading!
10:29:36 <aristid> public service announcement: try out :kind! String in your ghci *amazing*
10:29:54 <roconnor> merijn: I found that learning about enriched categories really helped me understand this.  But enriched categories is kinda advanced.
10:30:18 <merijn> aristid: Try using it with less trivial type families :)
10:30:40 <monochrom> hrm, less trivial...
10:30:44 <aristid> merijn: well i actually learned about it in the context of GHC.Generics
10:31:03 <merijn> roconnor: My biggest problem is that most of the "examples" usually employed are so abstract I can't really relate to them well :\
10:31:11 <aristid> so i guess you might want to try: :kind! Rep String
10:31:26 <honza> roconnor: just tried out a few things with -XSafe and it seems to do the right thing, thanks again
10:31:54 <zett_zelett> Is there a good language for coding very basic algorithms acting on arrays, such as sorting algorithms?
10:32:06 <aristid> zett_zelett: ST?
10:32:28 <zett_zelett> Structured Text?
10:32:34 <zett_zelett> What do you mean?
10:32:35 <aristid> no, the ST monad.
10:32:37 <roconnor> Now I see that a category is a preorder except that indead of x being less than y in 0 or 1 ways, we can have x less than y in many (aka some sets worth) of ways.
10:32:53 <aristid> Control.Monad.ST
10:32:59 <roconnor> honza: excellent.  -XSafe is realatively new.
10:33:18 <merijn> roconnor: Really?
10:33:20 <ReinH> monochrom: er, would it be useful to mention equalizers or pullbacks?
10:33:29 <monochrom> it would not
10:33:32 <ReinH> ok :)
10:33:38 <merijn> roconnor: How do you define new?
10:33:39 <ReinH> then I won't
10:33:41 <kosmikus> ocharles: pong
10:33:56 <roconnor> merijn: new?
10:34:07 <ocharles> kosmikus: hey, will you be around at all this evening? quick q about the definitions in GHC.Generics that came up in #haskell-lens
10:34:12 <merijn> roconnor: With regards to -XSafe being relatively new
10:34:23 <honza> roconnor: http://i.imgur.com/C6aH20j.png
10:34:41 <merijn> I don't remember -XSafe not existing, so it should be at least like 4-5 years old?
10:34:44 <kosmikus> ocharles: for what interpretation of "around"?
10:34:45 <srhb> zett_zelett: You can think of it as an extremely restricted IO Monad (so you can mutate things etc.) that you can escape
10:34:47 <roconnor> merijn: I remember a time when it didn't exist. :D
10:35:01 <ocharles> kosmikus: free to talk on IRC for 15 mins or so, if that
10:35:08 <roconnor> merijn: what? 4-5 years?
10:35:42 <kosmikus> ocharles: quick question takes 15 minutes? ;)
10:35:42 <roconnor> merijn: Did it exist for a long time without me knowing about it?  Did cabal start supporting it recently or something?
10:35:46 <merijn> Am I crazy? Did I just miss it being implemented?
10:35:55 <ocharles> kosmikus: the answer and further discussion might :)
10:36:04 <ocharles> kosmikus: but I just need to finish a bit of work first
10:36:04 <zett_zelett> Okay, thanks @aristid, @srhb. But this ain’t probably what I am looking for.
10:36:11 <aristid> merijn: clearly you are crazy:)
10:36:12 <srhb> zett_zelett: Why not?
10:36:24 <kosmikus> ocharles: yeah, I'll probably be around later.
10:36:36 <merijn> hmm
10:36:50 <merijn> Apparently it originally appeard in 7.2 and then got redesigned in 7.4
10:36:54 <merijn> I must be going crazy then
10:37:07 <roconnor> merijn: I see the first mention it on trac 3 years ago
10:37:13 <roconnor> https://ghc.haskell.org/trac/ghc/wiki/SafeHaskell?version=1
10:37:45 <srhb> zett_zelett: You throw a mutable vector in the ST Monad, write your efficient, mutating sorting algorithm and runST to finally do the magic.
10:37:47 <zett_zelett> I actually don’t know. I was hoping to hear of a new language, well-suited for low level algoritms, other than C.
10:37:54 <srhb> zett_zelett: Yes. That's it
10:38:01 <merijn> Ok, so apparently 3 years old, time to go and second guess my memory
10:38:01 <srhb> :-)
10:38:14 <merijn> zett_zelett: Rust?
10:38:19 <roconnor> merijn: 3 years ago some starting writing a design
10:38:45 <merijn> roconnor: Safe Haskell was in 7.2 which was released in 2011
10:39:00 <roconnor> really 2011
10:39:01 <roconnor> wow
10:39:18 <roconnor> wait when was lens first released?
10:39:25 <Polarina> Time runs fast.
10:39:41 <merijn> roconnor: 0.1 release of lens was in 2012
10:39:41 <roconnor> Wed Jul 25 23:03:28 UTC 2012
10:39:49 <roconnor> seems like just yesterday
10:39:50 <edwardk> lens 0.1 2012 some time
10:40:12 <edwardk> roconnor: from the reddit traffic you'd think so ;)
10:40:15 <roconnor> *l*
10:42:09 <roconnor> Erik Meijer is apparently Dr. Jekyll and Mr. Hyde
10:42:57 <zett_zelett> Rust may be what I was looking for.
10:43:15 <zett_zelett> Anyway, I’ll keep both Rust and the ST Monad in mind. Thank you!
10:48:31 <nh2> `data Mydata = Mydata! Int String` <- is there such a thing as a "strict constructor", or was `data Mydata = Mydata !Int String` intended?
10:50:10 <geekosaur> the latter and I would not be surprised if it actually parses that way
10:51:01 <djahandarie> merijn, in particular, the notion of equivalence comes from the set-theoretic foundation of (strict) categories. When you have sets of objects and sets of arrows, that means you get equality automatically, because the objects of the sets are sets (defined in whatever whatever way they are defined).
10:51:33 <merijn> djahandarie: Right
10:52:16 <nh2> geekosaur: thanks
10:54:06 <geekosaur> if that's someone else's code, you might still report it as a potentially confusing typo. I have no trouble thinking like a parser, but wouldn't want to generalize that :)
10:54:41 <monochrom> best of both worlds. Mydata ! Int String.
10:55:03 <nh2> geekosaur: yes, it's probably a typo
10:55:29 <nh2> just wanted to make sure, you never know what new features sneak into ghc
10:56:42 <roconnor> edwardk: does (Monoid e) => Alternative (Either e) exist anywhere or do I use EitherT Identity?
10:58:09 <djahandarie> merijn, basically (many) people think that this equality should be entirely ignored in category theory so you can swap out your foundations (say, types instead of sets), and instead make the focus be entirely on isomorphism. But even with only isomorphism, you can't say that the category with one object and the arrows being the natural numbers is isomorphic to a category with one object and one arrow -- one of those clearly has more ...
10:58:09 <djahandarie> ... information than the other.
10:59:11 <identity> i did not choose a good name to idle in this channel.
10:59:28 <copumpkin> :)
10:59:34 <monochrom> you have an identity crisis. :)
10:59:35 <copumpkin> better than so
10:59:59 <copumpkin> so: your nick basically renders highlights useless across the board :)
11:00:00 <EvanR> if you idle, thats gotta me id in some sense
11:00:06 <EvanR> or mempty
11:02:12 <joelteon> or "you can also /query lambdabot"
11:05:15 <no-n> @src concat
11:05:15 <lambdabot> concat = foldr (++) []
11:06:53 <lispy> @src reverse
11:06:53 <lambdabot> reverse = foldl (flip (:)) []
11:06:59 <no-n> @src exitFailure
11:06:59 <lambdabot> exitFailure = exitWith (ExitFailure 1)
11:07:22 <lispy> the symmetries between those definitions of concat and reverse is kind of beautiful
11:07:45 <no-n> pretty cool
11:08:42 <quchen> Symmetry?
11:09:18 <lispy> Perhaps not the right word. Similarities?
11:09:52 * hackagebot stompl 0.2.0 - Stomp Parser and Utilities  http://hackage.haskell.org/package/stompl-0.2.0 (TobiasSchoofs)
11:09:52 <monochrom> these are symmetric to each other: foldl (flip (:)) [], foldr (:) []
11:10:18 <monochrom> foldr (++) [] is just a step away from foldr (:) []
11:10:42 <quchen> map is just a step away from foldr (:) []
11:10:55 <monochrom> yes
11:11:14 <quchen> I'm just saying lots of things are folds over lists. Anyway, this is a pretty qualitative issue.
11:11:22 <monochrom> yes
11:11:42 <lispy> These particular folds are nice because they just say what to do about the conses.
11:15:13 <tupletriple> is there a specific channel for beginners' questions?
11:15:25 <quchen> Here's fine
11:15:32 <tupletriple> okay :)
11:15:49 <lispy> tupletriple: I guess it depends on what type of beginner :)
11:15:58 <lispy> tupletriple: if you want to know about kite making we may not be much help
11:16:10 <haasn> lispy: And also about what kinds of questions
11:16:15 <merijn> #haskell, the wonderful fusion of confused beginners and advanced type theory discussion :p
11:16:22 <djahandarie> He's probably in the right place if his name is 'tupletriple'.
11:16:31 <tupletriple> well luckily it's not about kites :p
11:16:38 <haasn> Except if it's about kites in Haskell
11:16:51 <tupletriple> djahandarie: exactly that's my problem!
11:17:09 <EvanR> data Kite a = ___
11:17:14 <tupletriple> I've got two triples and want to zip them into a list of tuples
11:17:19 <lispy> tupletriple: One bit of advice about irc, is that it is usually best to ask the question instead of asking if you should ask the question.
11:17:39 <lispy> tupletriple: can you write down the type?
11:17:51 <tupletriple> lispy: it's all ints
11:18:16 <lispy> @hoogle a -> a -> a
11:18:17 <lambdabot> Prelude asTypeOf :: a -> a -> a
11:18:17 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
11:18:17 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
11:18:29 <lispy> tupletriple: we have this cool search engine. If you can write down the type, I bet it can find your function :)
11:18:54 <tupletriple> lispy: so basically I write down the type of the function I want and it tells me how to do it?
11:19:17 <lispy> well, sometimes it's possible to figure out the implementation just from the type. hoogle won't help you with that though.
11:19:28 <merijn> tupletriple: No, Hoogle is a search engine for haskell types :)
11:19:34 <lispy> standard haskell advice is, start with the type
11:19:58 <tupletriple> looks like I'm too much of a beginner then, as I'm kinda confused right now, haha
11:20:13 <lispy> tupletriple: So, how do you write the type for a tripple of int?
11:20:55 <tupletriple> lispy: My guess would be (Int,Int,Int) -> (Int,Int,Int) -> [(Int,Int)] ?
11:21:12 <lispy> that looks like what you described, yes
11:21:27 <tupletriple> well then I'm gonna hoogle it..
11:21:30 <lispy> So then, given (x,y,z) and (a,b,c) what do you want to get out?
11:21:57 <tupletriple> [(x,a),(y,b),(z,c)] lispy
11:22:09 <merijn> I'm guessing "f (a,b,c) (x,y,z) = [(a,x),(b,y),(c,z)]"
11:22:19 <tupletriple> merijn: exactly
11:22:31 <merijn> tupletriple: What I just wrote is literally the entire function definition :)
11:22:39 <lispy> :t f (a,b,c) (x,y,z) = [(a,x),(b,y),(c,z)]
11:22:40 <lambdabot> parse error on input ‘=’
11:22:46 <lispy> :t let f (a,b,c) (x,y,z) = [(a,x),(b,y),(c,z)] in f
11:22:47 <lambdabot> (t, t, t) -> (t1, t1, t1) -> [(t, t1)]
11:23:00 <merijn> > let f (a,b,c) (x,y,z) = [(a,x),(b,y),(c,z)] in f (1,2,3) ('a','b','c')
11:23:01 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
11:23:14 <tupletriple> merijn: oh.. wow
11:23:26 <gridaphobe> is it possible to list all constructors of a given type using GHC.Generics? looks like no, but SYB might work instead
11:23:30 <tupletriple> haskell is just too simple for me
11:24:00 <EvanR> :t (1,2,3)
11:24:01 <lambdabot> (Num t2, Num t1, Num t) => (t, t1, t2)
11:24:02 <merijn> tupletriple: Pattern matching is a wonderful way to write things :)
11:24:05 <monochrom> that is the first time someone nails why haskell is so hard to learn. it is too simple.
11:24:12 <gridaphobe> it's not quite clear to me when to use GHC.Generics vs SYB
11:24:41 <lispy> @djinn (a,a,a) -> (b,b,b) -> ((a,b),(a,b),(a,b))
11:24:41 <lambdabot> f (a, b, c) (d, e, f) = ((c, f), (b, e), (a, d))
11:24:44 <EvanR> unpracticed people like complexity
11:24:52 <tupletriple> monochrom: sounds pretty zen, doesn't it?
11:24:57 <monochrom> yes
11:25:20 <lispy> djinn's definition is not what I expected
11:25:22 <enthropy> what do people use for choosing between multiple GHCs?
11:25:36 <merijn> The more I understand haskell, the more I realise people who think haskell is hard don't realise how hard everything else is
11:25:57 <lispy> enthropy: you could probably use gnu stow, but I've never needed to switch between them.
11:26:04 <monochrom> I install in /usr/local/ghc-7.6.3, /usr/local/ghc-7.8.2, etc, then play with PATH
11:26:14 <geekosaur> enthropy, hsenv?
11:26:21 <merijn> @quote writing.correct.programs
11:26:22 <lambdabot> roconnor says: writing incorrect programs in Haskell is hard. but writing correct programs is hard in every langauge. therefore, writing code in Haskell is hard. <EvanR> everything is hard in haskell ;) <kmc> that's a pretty good summary
11:26:23 <EvanR> the harder the system is to use, the more you get paid to operate it ;)
11:26:45 <merijn> enthropy: I literally just have multiple GHC installations and I switch by changing which comes first in my PATH
11:26:59 <merijn> enthropy: GHC uses a per version database and cabal just uses whichever GHC is first in your path
11:27:03 <enthropy> merijn: yes that's what I do now, I'm wondering if there's a nicer way
11:27:19 <merijn> Nicer in which way?
11:27:57 <EvanR> i refute that quote ;)
11:28:17 <merijn> enthropy: That's not a refutation, just a restatement
11:28:40 <merijn> eh
11:28:46 <merijn> s/enthropy/EvanR
11:29:10 <fizruk> > zip ((a, b, c)^..each) ((x, y, z)^..each)
11:29:11 <lambdabot>  [(a,x),(b,y),(c,z)]
11:29:23 <monochrom> I even have a shell function for playing with PATH.
11:29:25 <enthropy> merijn: not sure exactly what, but there's a reason for stow and hsenv, right?
11:29:51 <merijn> enthropy: Confusion about package databases and GHC?
11:29:53 <lispy> stow is a very general mechanism
11:30:04 <lispy> I don't know the motivation for hsenv
11:30:16 <merijn> enthropy: Stuff like python/ruby don't have per version databases so the python_env things do complicated stuffs to hide that
11:30:23 <monochrom> if you use hsenv for this, you will have one copy of GHC per project. this may not be what you want.
11:30:26 <merijn> hsenv always strucks me as rather useless
11:31:40 <dreixel> gridaphobe: http://hackage.haskell.org/package/generic-deriving-1.6.3/docs/Generics-Deriving-ConNames.html
11:32:21 <SrPx> hi, any idea what is wrong http://lpaste.net/103272
11:33:15 <lispy> SrPx: bug in the shell script?
11:33:36 <SrPx> what do i do
11:33:40 <SaBer> what does it mean when a haskell program exits with <<loop>>? (this is very hard to google...)
11:34:20 <gridaphobe> dreixel: aha, thanks!
11:34:39 <merijn> SaBer: It means your program went into an infinite loop
11:34:49 <erisco> I am not sure what a good let/in style is http://lpaste.net/103273
11:34:51 <lispy> SaBer: the run-time has detected a loop that doesn't make progress between iterations
11:35:16 <merijn> SaBer: The idea is "crashing with a <<loop>> error is probably more productive then silently infinite looping while you're confused what's wrong"
11:35:57 <SaBer> merijn: ok, thanks. Somehow using Debug.Trace is causing this for me...
11:36:08 <merijn> That's...facinating
11:36:09 <srhb> SaBer: That sounds unlikely.
11:36:15 <merijn> srhb: It might
11:36:16 <lispy> SrPx: get a newer version of the script? https://github.com/haskell/cabal/commit/aaa901766eefdc51b74c8d45fdf509736ddd5924#diff-5b7262517ff0909755571cfaaeea0fe7
11:36:26 <srhb> merijn: Creepy. :P
11:36:36 <merijn> GHC can't always detect loops if they're complex. Debug.Trace might let it suddenly find this one
11:36:46 <srhb> Huh.
11:36:47 <merijn> srhb: Unlikely, though
11:36:47 <lispy> SrPx: notice that your version tried to use HTTP-4000.2.12 but the script was recently updated to use HTTP-4000.2.13
11:37:01 <lispy> SrPx: I bet if you look at the deps of HTTP you'll see something about the range for network and 2.5.
11:37:10 <lispy> SrPx: But I'm too lazy to check :)
11:37:17 <srhb> SaBer: You haven't just forgot the last argument to trace or something, right?
11:37:22 <srhb> forgotten*
11:37:46 <SaBer> srhb: it seems to actually be the printf I'm using in the trace
11:37:55 <srhb> SaBer: Time to paste some code? :-)
11:37:58 <SaBer> ...or some of its arguments
11:39:35 <lispy> SrPx: we should change the script to say foo is already installed and the version is X.Y.Z [ok]
11:39:42 <lispy> SrPx: that would take some guesswork out of this
11:43:01 <erisco> a dilemma... I want a Set, but I need each element to contain auxilliary data that is not part of the ordering, but afaik having an Ord instance which does not correctly compare equality is poor practice
11:43:26 <merijn> erisco: newtype it?
11:43:29 <erisco> is my solution to have a Set and a Map where the Map keys are the Set values and the Map values are the auxilliary data?
11:43:30 <monochrom> use a map. put auxilliary data in key
11:44:04 <monochrom> the map already supercedes the set
11:44:08 <erisco> merijn, the problem with newtyping is that solution is based on making an Ord instance which would compare technically unequal values as equal
11:44:43 <enthropy> in my ~/.cabal/config, it is helpful to put lines like  constraint: bytestring installed
11:44:45 <EvanR> if auxillary data doesnt factor into "equal" then who cares
11:44:59 <enthropy> is there a way to get 'installed' that works for packages that are not yet installed?
11:45:19 <enthropy> really the idea is to say "I only want one version installed ever"
11:45:27 <monochrom> no
11:45:28 <erisco> monochrom, ah that makes sense. if the Set values are the Map keys then I already have the set encoded in the Map keys
11:45:46 <erisco> EvanR, the Haskell gods care
11:45:49 <edwardk> roconnor: (Monoid e) => Alternative (Either e) -- doesn't extend to a legal MonadPlus
11:45:56 <monochrom> one day I may submit a patch
11:46:11 <EvanR> erisco: i dunno. i mean, we define "congruent modulo something"
11:46:19 <dcturner> Hiya. If I've built GHC from the source package using just a straight configure/make/make install (no fancy options) do you know what optimization level that would have been using? -O2?
11:46:22 <EvanR> equivalence classes
11:46:35 <edwardk> roconnor: http://hackage.haskell.org/package/validation-0.3.4/docs/Data-Validation.html provides that Alternative under a different name
11:46:37 <dcturner> (same question for the base libs)
11:46:41 <EvanR> but separating the aux data makes sense
11:46:47 <erisco> EvanR, Ord instances are supposed to be totally ordered
11:47:12 <roconnor> edwardk: that is an unexpected response in light of: instance (Monad m, Monoid e) => MonadPlus (EitherT e m)
11:47:50 <edwardk> oh wait, nm, misspoke, its that the Applicative you get for Monoid e doesn't extend to a Monad wth Monoid e
11:47:58 <EvanR> if youre ok with a "set" of these equivalence class representatives, then i dont see the difference
11:48:12 <EvanR> you cant put two "different" things in the set either way
11:48:16 <edwardk> roconnor: i get those confused every time
11:48:37 <roconnor> edwardk: my attempt to implement fizzbuzz has failed. :(
11:49:11 <roconnor> I am a bad programmer
11:49:37 <merijn> roconnor: In which language? :p
11:49:50 <quchen> Haskell's type system? :-þ
11:49:52 <roconnor> merijn: Control.Monad.Trans.Either
11:49:53 <srhb> enthropy: Wouldn't it be sufficient to explicitly install the version you want the be the only one?
11:50:03 <edwardk> roconnor: fizzBuzz = view $ mconcat [3 ~> "fizz", 5 ~> "buzz"] `failing` to show where n ~> s = to (`mod` n).only 0.to (const s)
11:50:13 <monochrom> I know of a game better than fizzbuzz and of the same kind
11:50:52 <monochrom> a round table of people take turn to enumerate the positive integers 1, 2, 3... , with exceptions, just like fizzbuzz
11:51:10 <enthropy> srhb: yes. But cabal cannot satisfy a constraint like 'hashable installed' when you don't have hashable installed yet
11:51:23 <srhb> enthropy: No, of course not.
11:51:28 <enthropy> so I have to either put the specific version in my cabal file
11:51:44 <monochrom> the exception: when you are to announce a multiple of 7, don't announce it, clap once instead. or something. and there is one more...
11:51:53 <enthropy> or install it, and then uncomment the 'constraint: hashable installed'
11:51:58 <erisco> monochrom, lol after further thought I do not think I can use either Set or Map effectively. but thanks for the help
11:52:17 <roconnor> edwardk: Maciej Piróg seems to not like the extra branching caused by `failing`
11:52:21 <srhb> monochrom: I've tried this while slightly imbibed, and the small multiplication tables are a problem for me even when sober. It's terrible.
11:52:23 <srhb> :P
11:52:26 <monochrom> one more exception: when you are to announce a number whose decimal expansion has "7" in it, don't announce it, clap once instead.
11:52:31 <edwardk> roconnor: who?
11:52:42 <monochrom> those are all of the exceptions.
11:52:46 <roconnor> edwardk: http://themonadreader.files.wordpress.com/2014/04/fizzbuzz.pdf
11:52:51 <edwardk> fizzBuzz x = [(3,"fizz"), (5,"buzz")] ^. failing fizz buzz where fizz = each.itraversed.indices (\n -> x `rem` n == 0); buzz = to.const $ show x
11:53:01 <monochrom> therefore, the fun really begins in the interval 70-79
11:53:28 <edwardk> ah
11:54:12 <roconnor> edwardk: I mean the failing solution is quite a good solution.
11:54:21 <roconnor> but I do respect the issue with it.
11:54:32 <edwardk> *nods*
11:54:35 <SaBer> srhb: I had a cyclic dependency on the printf arguments in my trace
11:54:43 <srhb> SaBer: Ah :)
11:55:10 <srhb> SaBer: Usually happens to me when I define let blocks and forget that they are recursive.
11:55:40 <tdammers> monochrom: I've played that game with 3 instead of 7
11:55:45 <SaBer> srhb: 'twas a where clause in my case
11:55:52 <edwardk> roconnor; personally i don't find there is a lot of expository value in the problem ;)
11:55:53 <srhb> SaBer: Aye :P
11:55:54 <yorick> I have a big Data.Trie, can I concatMapM over the thing in random order without running out of heap space? :/
11:55:58 <tdammers> 1 2 skip 4 5 skip 7 8 skip 10 11 skip skip 14 skip ...
11:56:19 <monochrom> that's looks fun too
11:56:34 <srhb> tdammers: It's better with clap and bark and whatnot. Even better if you must stay on one number until each action has been performed, but one person must say at most one thin
11:57:05 <edwardk> srhb: heh that variant is pretty mean
11:57:09 <srhb> I like it. :P
11:57:38 <srhb> Unfortunately it's a self-limiting game (if you have to drink when you fail)
11:58:41 <quchen> If you also drink instead of clapping, it becomes a self-amplifying game.
11:58:57 <srhb> But then people can choose to fail. That's no fun. :P
11:59:05 <erisco> Data.Trees.KdTree appears to be for real numbers only. What library might I use for 2-dimensional querying on any Haskell type (presumably with Ord instance)
11:59:43 <merijn> erisco: Array can support any tuple of types with an Ix instance
11:59:49 <zq> @hoogle poke
11:59:49 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
11:59:49 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
11:59:49 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
11:59:56 <EvanR> is there mconcatMap ?
12:00:11 <roconnor> edwardk: I'm not sure there is really any essential difference between using failing and  Maciej's solution.
12:00:21 <erisco> merijn, but arrays are linear. I need logn lookup time in both dimensions
12:00:33 <pavonia> :t mconcat . map
12:00:34 <lambdabot>     Couldn't match type ‘[a] -> [b]’ with ‘[c]’
12:00:34 <lambdabot>     Expected type: (a -> b) -> [c]
12:00:34 <lambdabot>       Actual type: (a -> b) -> [a] -> [b]
12:00:40 <roconnor> Maybe (and every other data type) is kinda just a reified continutation anyway.
12:00:40 <merijn> erisco: Eh, arrays are O(1) access
12:00:55 <merijn> erisco: That's kinda the point of using an array over a list
12:00:56 <lispy> bisection search
12:01:12 <EvanR> :t mconcat .: map
12:01:13 <lambdabot>     Not in scope: ‘.:’
12:01:13 <lambdabot>     Perhaps you meant one of these:
12:01:13 <lambdabot>       ‘.’ (imported from Data.Function),
12:01:26 <erisco> merijn, sorry I might not be making myself clear.
12:01:28 <pavonia> :t (mconcat .) . map
12:01:29 <lambdabot> Monoid c => (a -> c) -> [a] -> c
12:01:30 <tdammers> oh, and we also played a card game with exceptions
12:01:39 <pavonia> @hoogle Monoid c => (a -> c) -> [a] -> c
12:01:40 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
12:01:40 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
12:01:40 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
12:01:41 <quchen> :t foldMap
12:01:42 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
12:02:04 <tdammers> you know, that game where you have to match either the rank or the file of the card on the stack, and whoever got rid of all their cards wins?
12:02:15 <tdammers> the standard version has maybe 4 or 5 exceptions
12:02:41 <merijn> tdammers: Pesten? :) No clue what it's called in English >.>
12:02:45 <roconnor> I suppose guess the validation package does what I want.
12:03:06 <srhb> merijn: Does that literally mean "the plague"?
12:03:07 <tdammers> merijn: could be, the German version is called "Mau-Mau"
12:03:17 <tdammers> srhb: "teasing"
12:03:24 <merijn> srhb: No, more leaking teasing/bullying
12:03:27 <tdammers> srhb: or maybe "bullying"
12:03:30 <srhb> OK, so not scandinavian :P
12:03:31 <tdammers> :D
12:03:42 <tdammers> anyway, there's a version with more rules
12:04:01 <tdammers> when you are about to play spades, you have to announce it
12:04:18 <tdammers> you are not allowed to say "yes" or "no" during the game
12:04:21 <srhb> Haha
12:04:34 <tdammers> playing a 10 reverses the direction of play
12:04:49 <tdammers> and a dozen or so more rules
12:04:53 <erisco> tdammers, I do not know what you've learned, but the proper way to play is that the winner introduces a new rule for the next round, but they also tell no one what it is
12:05:08 <tdammers> erisco: calvinball?
12:05:13 <erisco> no, Mau
12:05:32 <tdammers> but hey yeah, that sounds nice
12:05:35 <erisco> http://en.wikipedia.org/wiki/Mao_(card_game)
12:05:58 <erisco> it is the perfect game for elitists
12:06:51 <mietek> Is it possible to squelch the "Note: there is a new version of cabal-install available." message?
12:06:54 <mietek> I am already using cabal-install 1.20.0
12:07:15 <merijn> mietek: Are you sure?
12:07:20 <quchen> cabal --version?
12:07:23 <merijn> mietek: What does "cabal --version" say?
12:07:43 <Saizan> are you?
12:07:49 <mietek> Am I?!
12:07:54 <tdammers> http://en.wikipedia.org/wiki/Mau_Mau_%28card_game%29 <- this is the classic version we played in school
12:08:03 <erisco> merijn, imagine I have the 2d data (x, y) where x and y are integers. then say I want to determine if (x, 5) is in the structure for any 'x'
12:08:08 <mietek>  $ cabal --version
12:08:08 <mietek> cabal-install version 1.20.0
12:08:08 <mietek> using version 1.20.0 of the Cabal library
12:08:15 <erisco> merijn, with the proper data structure this can be done efficiently
12:08:47 <tdammers> we didn't introduce new rules though
12:08:50 <srhb> erisco: R trees?
12:09:11 <erisco> srhb, that is one kind of structure for this, yes
12:13:08 <erisco> hrm the GiST package might be of help
12:14:05 <roconnor> is there an applicative version of when
12:14:30 <mietek> merijn, quchen: are you satisfied with my ability to check the version?
12:14:40 <roconnor> maybe now that Applicative is a superclass of Monad the restriction is lifted?
12:14:45 <shachaf> roconnor: Not in base.
12:14:55 <ehabs> I'm using configurator and it works as expected for numerical values. Whenever I try to lookup a key with any other value type, it returns Nothing. Does anyone know why this is happening?
12:14:56 <shachaf> Applicative is not a superclass of Monad.
12:15:02 <shachaf> I think it's planned for 7.10.
12:15:16 <merijn> mietek: Yes, I'm just out of ideas. I was hoping it was the usual "installing didn't update the symlink" issue
12:15:22 <quchen> mietek: Indeed, very well done. I'm clueless too.
12:15:31 <mietek> My guess is, the message appears because only the 'cabal' binary 1.20.0.0 is installed, and not the 'cabal-install-1.20.0.0' package
12:15:40 <quchen> mietek: "cabal install cabal-install" for the fun of it anyway?
12:15:43 <mietek> I was hoping there's an option to just squelch the message
12:16:06 <erisco> well damn, GiST is Int-specific
12:16:27 <mietek> (Note 'cabal-install' is now offered as a binary-only download for OS X: http://www.haskell.org/cabal/download.html)
12:17:42 <mietek> When looking at https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Update.hs I am stumped by the 'Paths_cabal_install' symbol, which does not appear to be defined anywhere in the source tree...
12:18:12 <merijn> mietek: Paths_X is auto generated by cabal
12:18:32 <merijn> mietek: Check under dist/ somewhere
12:21:58 <enthropy> mietek: 'cabal repl' gets the -i flag right (and actually generates that Paths_cabal_install.hs too)
12:26:31 <fragamus> Question: I had my code set up to produce an infinite list of results using iterate; now I have set up the iterated function as a monadic action; is there any way to do sort of the same thing
12:27:42 <no-n> what's a good or idiomatic name for a helper function if you can't think of one
12:27:57 <quchen> no-n: go, loop
12:28:36 <quchen> :t foldr (>=>) return -- fragamus
12:28:37 <lambdabot> Monad m => [c -> m c] -> c -> m c
12:29:17 <shachaf> Of course, what you really want for (>=>) is the free category, not the free monoid.
12:29:45 <mietek> merijn, quchen, enthropy: http://pastie.org/private/scmffnholmebcoo5u0qmjg
12:29:47 <Ralith> no-n: 'helper'
12:29:47 <Ralith> :p
12:29:50 <mietek> (Now talking in #hackage)
12:29:55 <no-n> hehe
12:30:08 <Ralith> better that than something too clever for its own good
12:30:56 <fragamus> quchen: so the return is a place holder for my function right
12:34:18 <quchen> fragamus: No, "foldr (>=>) return" is a thing on its own. It takes a list of monadic functions and feeds them to each other. `foldr (>=>) return [a,b,c] ≡ a >=> b >=> c >=> return ≡ a >=> b >=> c`
12:34:58 <quchen> So when you've got a list of monadic functions (generated by whatever method) you can use that fold to chain them together into one action.
12:35:21 <quchen> If I read the question right that may be something you might want.
12:35:31 <fragamus> oh, I'm not sure that's what I want… here's what I had before:   eternity = iterate moveCells foo
12:35:57 <quchen> Could you write the types of the things you have and want to create down?
12:35:58 <fragamus> and then I take 100 from eternity
12:40:02 * hackagebot rubberband 0.1 - Binding to the C++ audio stretching library Rubber Band  http://hackage.haskell.org/package/rubberband-0.1 (mtolly)
12:50:03 * hackagebot elm-get 0.1.1.2 - Tool for sharing and using Elm libraries  http://hackage.haskell.org/package/elm-get-0.1.1.2 (EvanCzaplicki)
12:55:04 * hackagebot purescript 0.5.0 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.0 (PhilFreeman)
12:58:36 <Guest23700> High I am new to haskell, how to catch "error" function invocation?
12:59:23 <quchen> Guest23700: You should try to write your code so that 'error' is never called. It's not a legitimate way of handling control flow.
12:59:42 <alorente> Hi, I'm having a weird build problem and I've run out of ideas of what to investigate. On an Ubuntu 12.04 server I have two users, `andrewlorente' and `bloge'. Everything is hunky-dory for the andrewlorente user. The bloge user, however, gets an ExitFailure 245 error installing the `lens' package: https://gist.github.com/AndrewLorente/1064f2a77c2a1f4175e6#file-as-bloge-user
12:59:43 <alorente> They're puppet-managed users and everything about their config seems identical. I'm lost…
12:59:54 <EvanR> purescript hmmmmm
13:00:05 <quchen> But suppose you're using a library that throws errors everywhere and you have no choice, look at Control.Exeption.ErrorCall.
13:00:15 <edwardk> alorente: check to make sure nothing has tried to upgrae your template-haskell
13:00:22 <edwardk> alorente: that is the usual source of that sort of problem
13:00:35 <Guest23700> I know this function is given in a college excerise so I cannot change it :-(
13:01:00 <quchen> Guest23700: Call that function so that it is never called with parameters leading to "error"?
13:01:48 <quchen> You could write a safe wrapper around it, for example. Like `safeHead [] = Nothing; safeHead xs = Just (head xs)`, e.g. catching the bad input before
13:02:29 <quchen> (Note that for the particular example above there is a better implementation, but as a hack it'll do)
13:04:30 <Guest23700> quchen: I got your point :-) however the function resembles a tree, so I have to go in there to get fruther nodes or if the pattern doesn't match it gives me an error message which i can match to False
13:05:12 <quchen> You can always go the "catch the error" way, but that'll land you in IO.
13:05:21 <quchen> Could you paste the code? Maybe there's a proper way around this.
13:05:47 <Guest23700> quchen: in here?
13:05:59 <quchen> @paste
13:05:59 <lambdabot> Haskell pastebin: http://lpaste.net/
13:06:20 <quchen> Glad you asked ;-)
13:06:45 <alorente> edwardk: I'm not sure how to go about investigating that.
13:09:50 <alorente> oh wait I see, `cabal info template-haskell`. And indeed the bloge user has a higher version installed
13:09:52 <edwardk> alorente: ghc-pkg list | grep template-haskell
13:10:00 <Guest23700> quchen: I used the link that lambdabot gladly provided: http://lpaste.net/103276
13:10:01 <edwardk> if it shows 2 versions then you are hosed
13:10:58 <quchen> Guest23700: Oh boy that's awful code haha
13:11:01 <edwardk> i really should write something that does a paranoid check to see if there are multiple versions of template-haskell installed, and then complains clearly and loudly
13:11:25 <edwardk> so i don't keep getting people complaining about lens installs breaking when its something else that upgrade TH on them
13:11:30 <quchen> Guest23700: What's the rest of the assignment? Maybe there's something that can still be rescued
13:12:32 <quchen> Guest23700: The right way to write the "mutter" function would be to return a Maybe value, and probably to use a more suitable data structure for the lookup than hardcoding all the names as patterns.
13:13:18 <Guest23700> quchen: the functions are given by the assignment
13:13:31 <Guest23700> quchen: it forms a tree
13:13:53 <Guest23700> and I have to wirte a function to find the grand parents
13:14:16 <Guest23700> I just do not know to handle the erros in case there is no match :-(
13:15:06 <pavonia> Use Maybe as quchen suggested
13:15:26 <quchen> There is no good way of doing this, the assignment is crap. You can either choose to take it as it is -- have the "grandparents" function error if there's no grandparent -- or hack together a safe wrapper using terribly unsafe functions not suitable for a beginner at all.
13:15:27 <alorente> edwardk: I'm actually not sure how to uninstall the wrong template-haskell.
13:15:57 <edwardk> ghc-pkg unregister
13:16:27 <edwardk> that will complain about some other packages that wanted the new version, they're also hosed
13:16:31 <quchen> (You can catch the `error` call, but only when you're in IO. Catching `error` is always the response to a hack that is using `error` in the first place.)
13:19:36 <intrados> Is there a way to do something like `[1,2] & ix 5 <.~ 9` => `(Nothing, [1,2])`?
13:19:38 <Guest23700> quchen: thousand thanks for taking care
13:19:53 <alorente> edwardk: ok, and then recurse into those broken packages?
13:20:10 <quchen> Guest23700: I'm hesitant giving you the "safe wrapper" hack solution because it uses things that you should really not know exist as a beginner.
13:21:13 <enthropy> it might be more convenient to have an actual tree
13:21:55 <enthropy> since those functions only go one way (parents of) instead of other questions (siblings; children)
13:22:05 <quchen> enthropy: Problem is that the 'mutter' function is given by the assignment.
13:22:06 <edwardk> alorente: yep
13:22:18 <edwardk> alorente: somewhere at the bottom is the beast that broke your install
13:22:48 <edwardk> if you use 'cabal install --constraint 'template-haskell installed' going forward you should be fine until you can eventually switch to cabal 1.20
13:23:37 <RaphaelJ> Hey
13:24:29 <RaphaelJ> Does someone has an idea to write a type function to extract the type inside a Maybe, something like "type FromMaybe (Maybe a) = a" ?
13:25:00 <d1323> @src fromJust
13:25:00 <lambdabot> fromJust Nothing  = undefined
13:25:00 <lambdabot> fromJust (Just x) = x
13:25:39 <merijn> RaphaelJ: You mean for DataKinds lifted Maybe?
13:25:46 <merijn> RaphaelJ: wait, no...
13:25:59 <merijn> RaphaelJ: What's the problem with just writing the same variable twice?
13:27:05 <quchen> d1323: Non't use fromJust. Use pattern matching.
13:27:19 <copumpkin> RaphaelJ: a type family can do exactly that
13:28:46 <RaphaelJ> quchen: copumpkin: I'll try to write a little example, it's a little more complex than a simple type familie
13:28:54 <RaphaelJ> *family
13:29:55 <alorente> edwardk: The call is coming from inside the house :~( I got the broken template-haskell removed, ran `cabal install lens==4.0.7`, and the very first dependency it found was template-haskell-2.8
13:30:28 <Athas> ...does GHC really allow me to use '=>' in types whenever I should use '->'?
13:30:29 <edwardk> install it with --constraint='template-haskell installed'
13:30:40 <Athas> I know it desugars to the same, but...
13:30:41 <alorente> oh right *that thing you said*
13:30:48 <merijn> Athas: No and no
13:31:14 <merijn> Athas: It doesn't allow you to use => wherever you want and there's no such thing as "desugaring to the same"
13:32:11 <Athas> merijn: this compiles fine for me in GHC 7.6.3: http://lpaste.net/103279
13:32:28 <Athas> And in most cases, typeclass constraints are being compiled to function dictionaries in the Core language, right?
13:33:55 <quchen> "Compile to somehow" and "desugars to" are vastly different things.
13:34:38 <alorente> edwardk: yes now it is working! Thank you!
13:34:51 <Athas> quchen: the GHC subcomponent that does the HsCore->Core translation is called "deSugar", though, hence my use of the term.
13:34:54 <edwardk> np. good luck!
13:34:57 <merijn> Athas: It's (rightfully so) broken in 7.8
13:35:11 <Athas> merijn: oh, good, so it was just a bug.  I won't report it then.
13:35:14 <Zenol> Hi. I have a question. I'm looking for a simple, easy to use library that allow displaying a window with graphic (acessing pixels directly, it's better if you can use 'standard' vectors to give data), and handle keyboard input. Which should I use?
13:35:15 <merijn> Expected a constraint, but ‘Int’ has kind ‘*’ In the type signature for ‘f’: f :: Int => Int => (Int, Int)
13:35:53 <allsystemsarego> hi all, is there a generic way to get a list of all data constructors for a sum type?
13:37:18 <merijn> allsystemsarego: In terms of documentation, you mean?
13:37:29 <edwardk> allsystemsarego: Data.Data can do it
13:37:57 <allsystemsarego> edwardk, thanks, I'll look into that
13:38:14 <edwardk> > dataTypeOf [()]
13:38:16 <lambdabot>  DataType {tycon = "Prelude.[]", datarep = AlgRep [[],(:)]}
13:38:27 <edwardk> > dataTypeOf ((),())
13:38:28 <lambdabot>  DataType {tycon = "Prelude.(,)", datarep = AlgRep [(,)]}
13:38:47 <edwardk> > dataTypeOf (Left 4 :: Either Int Double)
13:38:48 <lambdabot>  DataType {tycon = "Prelude.Either", datarep = AlgRep [Left,Right]}
13:39:15 <edwardk> you can rummage through that for the constructors
13:39:23 <edwardk> you can also go in through GHC.Generics
13:39:31 <edwardk> but that takes a custom class
13:39:34 <allsystemsarego> > dataTypeOf True
13:39:35 <lambdabot>  DataType {tycon = "Prelude.Bool", datarep = AlgRep [False,True]}
13:39:40 <allsystemsarego> yay
13:39:51 <allsystemsarego> exactly what I needed, thanks
13:41:54 <taktoa> I'm using System.Process.readProcess on a process that dumps binary data to stdout
13:42:14 <taktoa> and then I want to push that binary data out with Network.CGI
13:42:34 <taktoa> I'm having some trouble with this
13:42:56 <taktoa> (paste incoming)
13:44:18 <taktoa> http://lpaste.net/103280
13:44:46 <dwcook> taktoa, String is unsuitable for general binary data. Try ByteString.
13:45:20 <taktoa> I figured, but is there a way to use readProcess (or similar) with ByteString?
13:46:28 <taktoa> nevermind, found this http://hackage.haskell.org/package/process-extras
13:47:20 <wombawomba> So I've been trying to teach myself Haskell by solving Project Euler problems: https://github.com/aeriksson/project-euler-solutions/tree/master/haskell . Would love some feedback on the code!
13:53:00 <epta> wombawomba: 50 consequtive problems for a week, not bad
13:54:59 <NemesisD> hey guys. working on a free monad using the free package. not sure how i could specify a recursive constructor: data RedisCmd next = RPut String String next | RMulti (RedisCmd next) deriving (Functor)
13:55:01 <wombawomba> heh, thanks
13:56:05 <NemesisD> Control.Monad.Free.TH seems to be unable to derive free, it is complaining "don't know how to make Arg"
13:57:06 <srhb> wombawomba: Checked a few random ones. It's hard to say anything about them because they all use the same tools and don't really contain a lot of interesting Haskell-stuff. a lot could be said about lists and performance, depending on what you do, but also head and other things. Your syntax looks fine to me. Do something other than Euler, you'll actually learn something. :)
13:57:21 <k00mi> wombawomba: two things:
13:57:26 <k00mi> 1. project euler people really don't like it if you make your solutions public
13:57:36 <k00mi> 2. project euler is not a good way to learn a language
13:57:40 <merijn> Euler is really sucky for programming exercises anyway
13:57:43 <merijn> @where exercises
13:57:43 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
13:58:11 <monochrom> project euler is a great way to practice for-loops
13:58:15 <srhb> You've learned how to abuse lists a lot for stuff you probably shouldn't
13:58:19 <srhb> But yeah :D
13:58:27 <monochrom> at least, until you learn number theory for real.
13:58:38 <monochrom> then it is a great way to practice number theory
13:59:00 <dwcook> NemesisD, what purpose does your RMulti constructor serve?
13:59:13 <dwcook> And I'm unclear what you mean by "specify" – It looks like you already have
14:00:11 <dwcook> NemesisD, posting actual code (including whatever you're doing with free) and a full error message would be helpful
14:00:26 <wombawomba> hehe alright
14:01:01 <wombawomba> k00mi: I figured it'd be okay since there's already solutions to all the problems at http://www.haskell.org/haskellwiki/Euler_problems
14:01:49 <wombawomba> merijn: thanks for the links
14:02:05 <srhb> wombawomba: Oh and did you do typeclassopedia?
14:02:19 <nh2> I want to use SPECIALIZE on, say, a function like `a -> m ()` Is it enough to write SPECIALIZE pragmas for a and m separately (e.g. {Int, Word32} for a and {IO, ST} for m) to obtain say a specialisation of Word32 -> IO (), or do I have to list all specializations manually?
14:02:23 <NemesisD> dwcook: http://lpaste.net/103281
14:02:53 <srhb> nh2: Hey, thanks for bringing attention to the forM_ stuff and NCG vs LLVM on SO and the bug tracker :)
14:03:08 <srhb> I was quite surprised with your results.
14:03:13 <wombawomba> srhb: nope; I've just read LYAH and now this
14:03:18 <nh2> srhb: yeah that stuff bothers me for long :/
14:03:27 <wombawomba> I'll check it out
14:03:35 <srhb> nh2: I suppose I shouldn't thank you at all -- now it bothers me too! >:/
14:04:07 <srhb> Guess I'll be sprinking more go a b c = ... everywhere for a while
14:04:40 <srhb> wombawomba: Implementing class instances in Haskell is really eye-opening. Or at least it was for me. :)
14:06:20 <monochrom> NemesisD: I wonder if you really need the branch "RMulti (RedisCmd next)"
14:06:22 <nh2> srhb: sorry for that :D I'm currently trying to make a package that contains `loop` so that one can use that in the meantime until ghc has forM_ fixed to be fast, but it's not even straightforward since it's not clear what type it should have
14:06:49 <NemesisD> monochrom: what's the alternative?
14:07:03 <srhb> nh2: No, it's hard if you want to generalize the predicate for when to stop and also what to do with the iterator argument between each loop
14:07:05 <monochrom> the alternative is to delete it
14:07:06 <nh2> I'm currently going for `loop :: (Enum e, Eq e, Monad m) => e -> e -> (e -> m ()) -> m ()` but it's kinda bad that it needs Eq (or alternatively Ord, but I guess Eq is smaller)
14:07:13 <srhb> nh2: I generally just slap one together myself, or go monadically
14:07:30 <srhb> I mean it's easy to do a for loop in ST, say
14:07:55 <NemesisD> monochrom: oh so i should specify, i'm modelling a real protocol that uses multi. in the "real" interpreter it would issue a command for that multi and an "exec" at the end
14:08:03 <nh2> sure but I don't want to write that number counting up all the time
14:08:37 <monochrom> then I don't know what is "multi".
14:09:07 <NemesisD> monochrom: like what it means in redis? its a transaction
14:09:35 <monochrom> alright, i don't know what is redis either. but is it simply RMulti next?
14:10:18 <monochrom> because, really, Free alright does all the recursion for you
14:10:24 <monochrom> s/alright/already/
14:11:11 <NemesisD> redis is an in memory key/value database. and i'm not sure about that. i need to embed a monadic expression inside of a multi so i can know when it starts and ends
14:12:50 <NemesisD> monochrom: annotated http://lpaste.net/103281
14:13:35 <NemesisD> I also thought briefly it would be RMulti (RedisCmd next -> next), but that wasn't it
14:14:20 <NemesisD> because "constructor RMulti must not use the type variable in a function argument"
14:18:04 <fizruk> NemesisD: if you want to control where multi starts and ends, why not separate it in a different monad (something like STM-IO)? (I’m a bit out of context, so if this does not make sense, ignore)
14:18:46 <philed> I've just had a nagging finger from ghc about the Applicative Monad proposal, and have a question: I've got a datatype where I've defined the monad instance differently to the applicative instance (pretty similar to using the usual list monad but having the applicative based on zip). I quite liked this, rather than wrapping the datatype with something like ZipList, but it's going to smell bad with the AMP proposal. Are there c
14:18:46 <philed> arguments about this sort of situation?
14:18:54 <NemesisD> fizruk: i'm using free monads to have a pure AST that I can then run through an impure or otherwise interpreter a la www.haskellforall.com/2012/07/purify-code-using-free-monads.html
14:19:01 <philed> *clear
14:19:22 <copumpkin> philed: they need to be compatible, but not identical
14:19:31 <copumpkin> I don't think any of that changes with AMP
14:19:38 <NemesisD> fizruk: so the part i'm getting stuck on is embedding the AST and then allowing the interpreter to continue
14:19:47 <NemesisD> wheres Tekmo when you need him, heh
14:19:56 <merijn> copumpkin: I think he's saying they already aren't compatible
14:20:04 <philed> copumpkin: Compatible in the sense of observationally identical, but possibly different implementations? But not inconsistent?
14:20:19 <copumpkin> oh, you actually have ziplist vs. list
14:20:24 <copumpkin> yeah, that's asking for trouble
14:20:37 <philed> How so?
14:20:40 <merijn> That was already asking for trouble *before* AMP :p
14:20:52 <merijn> philed: Because it confuses users of your library
14:20:55 <copumpkin> philed: people have been assuming they're compatible
14:20:58 <copumpkin> philed: for years
14:21:11 <monochrom> NemesisD: then it's RMulti (next -> next)
14:21:11 <copumpkin> this change is just formalizing that assumption
14:21:32 <fizruk> monochrom: that’s not a Functor, is it?
14:21:38 <philed> Ack.
14:21:44 <monochrom> no, it isn't
14:21:52 <NemesisD> monochrom: it can't derive the functor then, so no free monad
14:21:56 <fizruk> monochrom: he need it to be for Free
14:22:04 <monochrom> perhaps free monads are not suitable for this
14:22:07 <philed> See, even though it was a mistake not to have AMP, the fact that you have liftA2 versus liftM2 meant I was happy to read them differentyl.
14:22:09 <philed> *differently
14:22:32 <NemesisD> i wasn't aware that this wasn't possible with free monads
14:22:59 <merijn> philed: The main reason liftA2, etc. even exist is because Monad predates Applicative by several years (if not a decade) and people didn't want to break all monad code to introduce Applicative everywhere
14:23:21 <merijn> philed: Of course, in hindsight not breaking everyone's code turned out to be a big mistake, hence breaking everything now ;)
14:24:11 <fizruk> NemesisD: I’d go with RMulti next next where first next would be your multi block
14:24:39 <fizruk> NemesisD: it’s just like Fork next next, only with different semantics
14:24:41 <monochrom> perhaps RMulti next next is right
14:24:55 <philed> merijn: I understand the reasons, but now that we've got these two different typeclasses without a subclass relationship, I was wondering whether anyone was relying on the sort of thing I'm doing: using the fact that you've got two versions of the same, one in Applicative and one in Monad, and using the difference to signal a different semantics.
14:25:12 <philed> If everyone's been assuming compatibility, then I guess that's not the case.
14:25:14 <NemesisD> hmm. interesting. from that i'm getting an error from the free TH "can't accept 2 mere parameters". how cryptic
14:25:31 <fizruk> NemesisD: otoh, multi block would depend on return type of the overall computation, which is not good i think
14:25:34 <monochrom> then you have to screw makeFree
14:25:36 <merijn> philed: Well, the main reason for ZipList not being the default applicative is people expecting the applicative and monad instance to be similar
14:25:39 <quchen> It's a Applicative/Monad law to have "pure = return; (<*>) = ap" the same way "m >>= return = m" is one. I think Control.Applicative's documentation mentions this.
14:25:51 <fizruk> monochrom: :p
14:26:09 <fizruk> monochrom: I thought I was the only user
14:26:31 <NemesisD> fizruk: you may be right. am i barking up the wrong tree then?
14:26:34 <enthropy> quchen: I disagree that is required
14:26:45 <quchen> Okay.
14:27:06 <merijn> enthropy: How so?
14:27:34 <augur> ski: for languages with so called "string interpolation"/quasiquotation:   "foo #{x} bar" :: (Show a, x :: a) => String
14:27:50 <merijn> enthropy: I would say that for any type X I expect pure/return to be identical and similar for <*> and ap
14:27:52 <monochrom> it's okay here to preserve the return type
14:27:53 <philed> quchen: Not sure if that's really a law in the sense of the abstraction. Certainly, it's a law if you want to interpret your monad as an applicative. But that's not the default at the moment.
14:28:00 <fizruk> NemesisD: oh I got it
14:28:01 <augur> ski: so we have some good examples of presuppositions in programming languages :)
14:28:15 <augur> ski: like, actual presuppositions, not just constraints
14:28:30 <srhb> nh2: How about for :: a -> (a -> Bool) -> (a -> a) -> (IORef a -> IO b) -> IO b
14:28:31 <NemesisD> fizruk: ahh actually it may not be necessary. IRL, multi does not return a meaningful result from the computation
14:28:31 <deni> is it practice to have capital first letters in module file names?
14:28:37 <fizruk> NemesisD: RMulti (YourMonad a) (a -> next)
14:28:47 <quchen> deni: It's not an option. Modules *have* to start with capitals.
14:28:49 <enthropy> merijn: yes that is how things work. But ideally you could have ZipList not exist, and Applicative [] would do what ziplist does
14:28:50 <merijn> deni: It's mandatory, even
14:28:54 <fizruk> NemesisD: or RMulti (YourMonad ()) next
14:29:06 <NemesisD> fizruk: in the real protocol it only returns more or less Maybe AnError
14:29:08 <merijn> enthropy: I disagree that's ideally
14:29:10 <augur> ski: tho this is also a presupposition for a particular variable name, x, not just a value, which is interesting in its own right. implicit args are curious
14:29:10 <fizruk> NemesisD: though I feel awkward to use YourMonad there
14:29:20 <quchen> philed: What's "a law in the sense of the abstraction"?
14:29:21 <merijn> enthropy: The Applicative implementation can be more efficient than Monad for some types
14:29:47 <merijn> enthropy: Throwing out the Applicative type for Monads loses that ability
14:29:54 <srhb> nh2: Then you could do: for 0 (<100) (+1) (readIORef >=> print)
14:30:06 <fizruk> NemesisD: hm… but when you use YourMonad you get back your makeFree :)
14:30:10 <deni> quchen: merijn ok tnx. i guess i though that i could define a Module inside the file and the filename didn't matter
14:30:15 * hackagebot contravariant 0.5 - Contravariant functors  http://hackage.haskell.org/package/contravariant-0.5 (EdwardKmett)
14:30:15 <NemesisD> fizruk: it compiles :D
14:30:28 <merijn> enthropy: Additionally, somethings like traversable require applicative, if they don't match you lose the ability to use monads on those and need a separate TraversableM class
14:30:29 <philed> quchen: In the sense of it being an instrinsic law, like associativity for a monoid. The compatibility law seems more extrinsic to me.
14:30:35 <NemesisD> now lets see if its actually possible to implement the interpreter
14:30:36 <quchen> The AMP will probably even provide Applicative's (*>) as default implementation for Monad's (>>).
14:30:43 <quchen> (Similarly for return)
14:30:55 <fizruk> NemesisD: and makeFree should generate a suitable command: rmulti $ do …
14:31:13 <merijn> enthropy: Further furthermore what if a type has more than 2 possible Applicatives?
14:31:13 <mm_freak> hi there
14:31:37 <quchen> philed: I always read it the way "Every Monad gives rise to a unique Applicative; if a type is a Monad, its Applicative should be that unique Applicative."
14:31:46 <mm_freak> when i write a RULE to rewrite "f (g x)" to "x" for all x, should i write an extra rule for "f . g = id"?
14:32:33 <NemesisD> fizruk: thanks for walking me through that. it worked. so cool
14:32:42 <fizruk> NemesisD: makeFree worked as well?
14:32:52 <quchen> deni: Module names and filenames are tightly coupled in GHC (not sure about Haskell in general)
14:33:12 <merijn> quchen: Undefined in haskell
14:33:21 <quchen> Good to know!
14:33:25 <merijn> It's rather inconvenient
14:33:51 <enthropy> merijn: I'm not sure how those points suggost "I disagree that's ideally"
14:34:55 <merijn> All of these things would break if you don't make "pure = return, (<*>) = ap" a law, do you really think having ZipList as Applicative for [] is worth all that?
14:34:56 <philed> quchen: And that's fine and should have been captured by subclassing. But now we've got these duplicated functions like liftM2 and liftA2, I'd been willing to treat the syntactic distinction as a semantic one. I was wondering if other people had too, because the Applicative-Monad proposal puts a stop to it as far as I can see.
14:35:21 <NemesisD> fizruk: yeah. went with RMulti (RedisCmdM ()) next
14:36:06 <fizruk> NemesisD: cool :)
14:36:16 <quchen> philed: Ah. Well, no, liftA2 should always be liftM2. Note that liftM2 may still not be redundant because there maaay be a type for which defining (<*>) in terms of liftM2 is easy/useful/...
14:36:17 <philed> merijn: On applicatives being able to do certain things more efficently, can't that be handled by making >>= and return the minimal complete definitions, but allowing users to define <*>.
14:36:56 <joneshf-laptop> hmm
14:37:13 <joneshf-laptop> how come `Eq` isn't a superclass of `Semigroup`?
14:37:20 <quchen> philed: Similarly, fmap does not make liftA redundant, because you can use "fmap = liftA" to define a Functor if you have an Applicative instance.
14:37:22 <merijn> philed: Users are already allowed to define <*>, when I (or quchen) say "pure = return, <*> = ap" we mean semantically, not as in having the literal same implementatio
14:37:26 <NemesisD> fizruk: i'm thinking of writing a blog post on it. redis is a key/value database. its super cool to have a free monad limited dialect of the protocol, then you could strap it to an interpreter that's basically Map String String in the state monad
14:37:26 <joelteon> joneshf-laptop: why would it be?
14:37:27 <joneshf-laptop> aside from the fact that `Semigroup` isn't in base
14:37:47 <joneshf-laptop> joelteon, be more inline with the definition of a semigroup
14:37:48 <fizruk> joneshf: instance Semigroup Endo
14:37:53 <monochrom> people do not even want Eq to be a superclass of Num. so nevermind Semigroup
14:37:54 <merijn> philed: *but* that only makes sense if the Applicative of Foo is the same as the Monad of Foo, if the Applicative is different then you can't use <*> as a more efficient version of the Monad
14:38:29 <deni> quchen: merijn tnx
14:38:34 <philed> merijn: What I mean is that if users are allowed to provide more efficient definition of <*> in instance declarations for Monad, then functions like sequence become more efficient. That's not the current situation.
14:38:53 <merijn> philed: <*> is a function in Applicative, though
14:39:11 <joneshf-laptop> fizruk, i don't follow
14:39:33 <monochrom> Endo refers to "Endo a = a->a"
14:39:35 <merijn> philed: That'd require even more drastic reshuffling of methods, because what would become <*> in Applicative, then?
14:39:43 <fizruk> joneshf-laptop: Endo obviously forms a Semigroup, but cannot be made Eq
14:40:06 <joneshf-laptop> fizruk, is that Semigroup's fault or Endo's?
14:40:16 <fizruk> NemesisD: i think that’s a good idea :)
14:41:14 <ocharles> Can anyone remember what package defines: data One a = One  with a monad instance?
14:41:16 <fizruk> joneshf-laptop: ehm.. none? it’s just that Semigroup and Eq are unrelated and Endo is an example of a valid Semigroup which is not Eq
14:41:16 <joneshf-laptop> fizruk, so are you suggesting it would break things is the reason why?
14:41:42 <philed> merijn: Something else. The hypothetical I was considering was keeping Applicative and Monad separate anyway. If you want to optimise functions like sequence for monads by using the applicative implementation, you could do that by adding an optional <*> like method to the monad class.
14:41:53 <philed> But this is total hypothetical. I wouldn't want to go down that road.
14:43:03 <merijn> philed: In general people seem to be of the opinion that newtype is the lesser evil/simplest solution
14:43:04 <joneshf-laptop> maybe i should rephrase
14:43:20 <joneshf-laptop> why doesn't Semigroup have a Set as its superclass?
14:43:43 <enthropy> merijn: should mappend and mplus do the same thing?
14:43:49 <joneshf-laptop> or osme kind of constraint?
14:43:52 <merijn> joneshf-laptop: That makes no sense, all haskell types already form sets, what operations would this set class have?
14:43:53 <fizruk> joneshf-laptop: oh, that’s because Semigroup uses type, not set
14:44:08 <merijn> enthropy: mappend and mplus don't even have the same type
14:44:10 <merijn> :t mappend
14:44:11 <lambdabot> Monoid a => a -> a -> a
14:44:12 <EvanR> Set isnt a class?
14:44:13 <merijn> :t mplus
14:44:14 <lambdabot> MonadPlus m => m a -> m a -> m a
14:44:39 <SrPx> How do you create a 3D game in Haskell and deploy it to iOS/Android/the browser, like you do in Unity3D?
14:44:57 <enthropy> > ("of" <> "course", "of" `mplus` "course")
14:44:58 <lambdabot>  ("ofcourse","ofcourse")
14:45:32 <EvanR> SrPx: this guy seems to have a few words to say http://blog.reactiveprogramming.org/
14:46:41 <quchen> > (Just "of" <> Just "course", Just "of" `mplus` Just "course") -- enthropy
14:46:42 <lambdabot>  (Just "ofcourse",Just "of")
14:46:55 <SrPx> reading
14:47:27 <enthropy> quchen: horrible :p
14:48:28 <dreixel> ocharles: nice ticket, but if you could list all the required instances it would be great!
14:48:31 <DarkLinkXXXX> I tried creating a tax function for a constantly decreasing bank account in ghci with `let {tax _ 0 _ = 0; tax i p s = i * p + tax i (p-s) s }`. How do I declare the type for this in ghci?
14:48:45 <ocharles> dreixel: I was going to do that after I wrote the patch :)
14:48:50 <DarkLinkXXXX> Forgot to mention, it couldn't infer the type.
14:48:55 <dreixel> ocharles: oh, you're writing a patch, perfect!
14:49:04 <ocharles> dreixel: yep - low hanging fruit :)
14:49:06 <monochrom> let {tax :: type; tax _ 0 = ...}
14:49:10 <dreixel> ocharles: thanks
14:49:15 <ocharles> np
14:49:27 <DarkLinkXXXX> monochrom, thanks
14:49:27 <dreixel> ocharles: I'm happy to validate and push it for you, once it's ready
14:49:30 <ocharles> dreixel: it gives me a good project to learn how to build GHC and all that
14:49:40 <ocharles> dreixel: great, i'll be sure to ping you when it's cooked
14:49:46 <dreixel> ocharles: thanks!
14:50:04 <philed> merijn: Yeah, I'll happily concede to it, and if we could start from scratch, it's how I'd have done it. I'm just a bit sad having to wrap things in newtype. It says to me that this business of there being a default structure defined by a type class instance isn't ideal.
14:54:02 <Iceland_jack> > unwords $ (pure <> pure <> (map pure <$> map toUpper)) "what"
14:54:04 <lambdabot>  "what what W H A T"
15:15:58 <augur> hmm
15:16:52 <augur> possibility: use predicates like logic gates and variables like wires, in a constraint propogation style circuit?
15:19:57 <monochrom> both circuit monads and circuit arrows already do that
15:20:48 <augur> monochrom: i mean on a lower level, like, with some kind of primitive machine that lets you spawn little new processors (not processes!) for predicates
15:20:49 <edwardk> augur: ersatz, kansas lava, various arrow combinator libraries all follow that path
15:21:05 <edwardk> oh, magic =)
15:21:09 <augur> yeah!
15:21:10 <augur> magic :D
15:21:15 <augur> or FPGAs
15:21:30 <merijn> augur: Guys in Twente are working on compiling Haskell code to VHDL and FPGAs
15:21:32 <augur> little known fact: harry potter is actually a story about FPGAs
15:21:47 <monochrom> are you talking about nano technology?
15:21:56 <augur> merijn: neat. i have some (bad) ideas for using FPGAs for using LC as machine code
15:22:00 <edwardk> bluespec can compile down a haskell like language to get partial specifications that run in a control loop and partially on an FPGA
15:22:05 <merijn> augur: http://hackage.haskell.org/package/clash-ghc
15:22:11 <augur> monochrom: eh, not really, but sure, if you want
15:22:20 <augur> i guess chip litho is technically nanotech
15:22:26 <monochrom> if not really, then you are not low level enough
15:22:43 <nh2> srhb: that's a great idea - I'll try that. Probably remote the IORef though and just pss in the a. I'm currently benchmarking a few more things. The situation is bad. If you pick INLINABLE ghc seems to not do the right decision sometimes, and I can't get `loop` to be fast as soon as it's not in the same module any more :(
15:22:44 <edwardk> this is also conal's current project if i recall correctly
15:22:54 <augur> monochrom: i want self-replicating domino-based machines!
15:23:14 <merijn> edwardk: Yeah, Conal is working on haskell-to-hardware using Cartesian Closed Categories
15:23:32 <srhb> nh2: Ugh. I wonder if this is some kind of weird regression, I believe I remember having tested similar things some time ago with none of these issues. Are you on 7.8?
15:23:39 <augur> monochrom: what are circuit monads? link?
15:23:42 <conal> yep. it's my main work focus.
15:24:06 <monochrom> I have forgotten the links
15:24:14 <nh2> srhb: no, 7.6
15:24:20 <srhb> nh2: Hm
15:24:41 <monochrom> but papers on MonadFix have examples. it's the poster boy of MonadFix
15:24:44 <augur> conal: the big sticking point ive had in my musings is that you have to do lots of copying of code if you want to use LC as the machine code
15:24:51 <augur> monochrom: ah, interesting. ill check it out
15:25:40 <edwardk> there is a nice operad for synchronous circuits as well, such that sussman and radul's propagators form an algebra over the operad
15:25:56 <merijn> augur: Actually, another guy in Twente was working on designing a CPU for the execution of lazy functional languages :)
15:26:05 <joneshf-laptop> fizruk, hmm, i see
15:26:32 <augur> merijn: neat. what you really want for that, i think, is a _lot_ of registers. like, ram-levels of memory as registers. which i suspect is not possible
15:26:47 <nh2> srhb: (also it has to be IO () instead of IO b, since when the loop ends you have no b to return, except from picking the last one or so)
15:27:10 <merijn> augur: Some ideas were builtin support for vectored returns and bigger caches to hold the nursery for closures
15:27:25 <fizruk> why DeriveFunctor is not working with Existentials?
15:27:32 <shachaf> The original thesis introducing MonadFix was good.
15:27:35 <merijn> I'd have to check exactly what they've been doing recently, I haven't talked to anyone there since January or so
15:27:37 <joneshf-laptop> that's a bit confusion since we usually think of how the Semigroup acts on the values of the type
15:27:41 <monochrom> because DeriveFunctor is simplistic
15:27:41 <joneshf-laptop> not the type itself
15:27:53 <srhb> nh2: That's true
15:27:54 <joneshf-laptop> although, not that confusing
15:27:55 <edwardk> conal: when you figure it out perhaps i can borrow the tech to implement spivak/wisnesky's FQL as a target non-standard interpretaton for real haskell (or more likely something agda like due to problems with fixed points) as well. They have a couple of embeddings of the STLC into it as a topos.
15:28:02 <srhb> nh2: Oversight. :)
15:28:15 <fizruk> monochrom: so there’s no big reason, good to know
15:28:52 <conal> edwardk: sounds great.
15:29:16 <merijn> fizruk: DeriveFunctor, like the other derived stuff can't deal with as many things as a hardcoded instance could. So not every possible functor, Eq, Ord, etc. instance is derivable
15:30:06 <edwardk> we could do more to make DeriveFunctor work for GADTs though
15:30:33 <edwardk> same with DeriveFoldable/DeriveTraversable
15:30:55 <fizruk> cool, i guess that would not be very difficult?
15:31:11 <augur> remember: special meta programming techniques are unnecessary with dependent types!
15:31:44 <edwardk> augur: sure you just have to give all that sexy typeclass stuff
15:32:00 <augur> edwardk: :p
15:32:29 <augur> edwardk: well, if you have a typeclass system, you could probably figure out some way to lift computed values into type classes
15:32:54 <merijn> Actually, speaking of dependent types
15:33:13 <hunt> hey guys im trying to pick a framework to run a webserver in haskell
15:33:24 <augur> like, you dont need metaprogramming cause you can use codes (ala Levitation), and have special flags for instances maybe, to make Derive's just boring old functions in the language, rather than some special hook
15:33:34 <hunt> any tips? ive perused through snap scotty and yesod but am uncomfortable making a decision as i know really not thatmuch about them
15:33:54 <hunt> its not for production its more of a personal fun project and i prefer writing efficiently and eloquently than super speed
15:34:02 <merijn> I was thinking of implementing a dependently typed language without requiring code to be total (mostly because that seems Hard (TM)) and instead of having undefined/bottom for partial patterns, etc. drop the user into a debugger
15:34:32 <merijn> But I'm running into the conceptual problem that, fixing anything in a debugger means changing the code/state, which would make things fundamentally impure...
15:34:40 <edwardk> merijn: up until that last comment you were describing idris
15:34:42 <hunt> if anyone has any experience with this advice would be much appreciated
15:34:54 <monochrom> it only makes the interpreter impure
15:35:11 <hunt> is idris good?
15:35:28 <merijn> monochrom: Well, if you update some code that is called by other pure code, then clearly your breaking the purity
15:35:36 <edwardk> hunt: i tend to just use warp directly, yesod vs snap is a matter of convenience vs template haskell build times
15:35:42 <merijn> monochrom: I don't see how you could do that without breaking purity
15:36:02 <hunt> edwardk: where do i get warp? i can only find references to it on the yesod page
15:36:15 <merijn> monochrom: i.e. imagine a bug in a top level function 'foo', how could you update 'foo' without breaking referential transparency for any function using foo?
15:36:33 <edwardk> http://hackage.haskell.org/package/warp
15:37:08 <hunt> edwardk: any reasons why you choose warp in particular/ good learning resources?
15:37:13 <edwardk> hunt: anyways, i like snap's structure to think in. i like yesod's convenience.
15:37:28 <edwardk> it comes down to what you want to do
15:37:45 <edwardk> yesod is basically ruby on rails in haskell with much better type safety.
15:38:03 <edwardk> and sometimes a little too much sugar from typeclasses making it hard to figure out what is going on
15:38:43 <hunt> edwardk: do you think itd be easy as a beginner to use warp?
15:38:49 <edwardk> snap is a little less magic, but without some of the fancier template-haskell edsl's offered by snap it is easier to get your head around, but a little less power.
15:39:08 <monochrom> I think I would not worry about it. once you turn off the debugger, you are back to purity again. you will turn off the debugger during user time, won't you?
15:39:14 <gentleben> does anyone know what the minimum version of ld ghc requires?
15:39:29 <edwardk> i'd go with snap or yesod or happstack mostly because you get a community with them to help you along.
15:39:37 <edwardk> scotty is small but its small ;)
15:40:31 <edwardk> hunt: i tend to recommend that beginners avoid hcking n web frameworks in haskell as it leads to a very distorted view of the ecosystem, but YMMV ;)
15:40:40 <edwardk> er hacking on
15:41:03 <merijn> monochrom: No
15:41:22 <hunt> edwardk: not a beginner to haskell as much as web in haskell
15:41:30 <merijn> monochrom: I'm thinking Lisp machine inspired language runtime as OS type dealio
15:41:50 <merijn> monochrom: So having the "drop to debugger" is explicitly supposed to be possible at user runtime
15:42:15 <monochrom> then there be dragons and God be with you
15:42:35 <merijn> monochrom: Yes, I quickly realised the first bit, yes :p
15:42:42 <hunt> on a side note, Text has never successfully installed for me
15:42:53 <hunt> im cabal install cabal-install and it fails consistently
15:42:59 <hunt> with ghc 7.8.1
15:43:23 <merijn> I'm thinking it might be better to track function inputs and "replay" after changing code, but still that does not interact with IO in a nice way
15:43:42 <merijn> Maybe I can turn this concept into a 2nd phd topic >.>
15:45:21 <hunt> merijn youre getting a second phd?
15:46:01 <monochrom> it's like leveling up from "the 1st doctor who" to "the 2nd doctor who" :)
15:46:15 <merijn> hunt: No, I'm working on my first, but I'm pretty sure if I get this (the whole statically typed, drop to debugger in a sane way) to work, I'm pretty sure it's worth a phd :p
15:46:28 <edwardk> hunt: my recommendation would be try #snap-framework. and if they aren't helpful try #yesod and #happstack =) by the end you'll get an understanding of the parts and what works
15:46:36 <nh2> srhb: oh damn, succ is half as fast as (+1) :(
15:46:52 <edwardk> nh2: it has to deal with overflow specially
15:46:57 <edwardk> > succ maxBound :: Int
15:46:58 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
15:47:05 <edwardk> > maxBound + 1 :: Int
15:47:06 <lambdabot>  -9223372036854775808
15:47:35 <edwardk> you're paying for the branch
15:48:13 <nh2> edwardk: yep
15:48:19 <hunt> solutions to cabal failing to install text 1.1.0.1? does it work for others?
15:48:46 <edwardk> hunt: 'works for me', what is it saying?
15:50:00 <nh2> I don't like that; I like that it prevents my loop from overflowing which I'm pretty sure I never want, but the penalty sucks. I wonder if llvm can figure out that the branch is not needed when the loop upper bound is known statically
15:50:29 <Iblues76> Hello. I have a university course a while back in functional programming using ML. I'm looking at some books about Haskell in Amazon. Is there any recommendation ?
15:50:32 <Algebr> Sometimes it feels like haskell related data structures are just data structures by convention, for example [(a, b)]
15:51:10 <hunt> output for "cabal install text -v3"
15:51:11 <hunt> http://lpaste.net/103286
15:51:13 <hunt> edwardk ^
15:51:17 <merijn> Algebr: What do you mean by that?
15:51:25 <erisco> @pl \ma mb -> ma >>= \a -> mb >>= \b -> return (a,b)
15:51:25 <lambdabot> liftM2 (,)
15:51:51 <shachaf> Iblues76: Hutton's _Programming in Haskell_ is quite good (if a bit old).
15:51:56 <monochrom> data structures are data structures. that is a correct statement. every tautology is correct.
15:52:30 <Algebr> like [(a, b)] is just a list of tuples, with no restiction on a or b but hey we can use it as if it was meta data about some thing, like [("name", "os x"), ("cpus", "4")]
15:52:37 <monochrom> hmm, is Hutton's old? ok, "a bit old" is right, but it's also the 2nd newest.
15:52:38 <nh2> aha. Turns out LLVM can't figure that out, but it does figure out what the result of the loop with (+1) is and replaces it by a no-op, so now I can't compare any more ...
15:52:46 <augur> Algebr: ???
15:52:54 <hunt> edwardk any idea whats going on here?
15:53:32 <monochrom> metadata is data too, just for a different level. that's another tautology.
15:54:15 <bergey> Algebr: That's a very lisp-like way to write an association list / Map.  I don't see that style all that often in Haskell, though it's certainly an option.
15:54:19 <Iblues76> shachaf: I would look into it.... thanks... I notice some titles in amazon such as: Real World Haskell, Learn you a Haskell for a great good, Beginning Haskell, and I also sow Programming in Haskell
15:54:32 <Algebr> I suppose I'm not getting the point across, perhaps in another language I would create an object, and do Machine.Cpus, and Machine.name, or at the very least a hashtable
15:54:43 <monochrom> at this rate, tomorrow I'll have to hand over the maintenance of http://www.vex.net/~trebla/humour/tautologies.html to you
15:54:55 <merijn> Iblues76: Learn you a Haskell is good, but depending on how much ML you remember it might be too slow for you
15:55:13 <mhr> What would be a good way to achieve some kind of integration of static and dynamic typing in a programming language (not necessarily Haskell)? What would be the benefits and costs of doing so? Sorry if this is off-topic. If it is, I'll take this question to some other channel. I just figured you guys would know quite a bit type theory (probably) and might be
15:55:13 <mhr> able to give me some ideas.
15:55:14 <nh2> hunt: that doesn't look great. Looks to me like cabal or the http library it uses tries to compare an etag, but can't deal with the etag not existing on your system? What cabal version are you running there? Also using ghc 7.8.1 is not recommended, use 7.8.2 if you can
15:55:21 <Algebr> bergey: Its an example inspired by an example in real world haskell
15:55:23 <dcoutts_> hunt: mm, that's interesting, failing to write the etag file
15:55:25 <monochrom> objects and hashtables are data structures too. since when have they not been data structures?
15:55:29 <dcoutts_> hunt: does the directory exist?
15:55:45 <nh2> dcoutts_: writing? not reading?
15:55:49 <Iblues76> thanks... I will see how much amazon let me browse some pages to see which one to go for.
15:55:49 <erisco> where is State defined? I thought it was defined in Control.Monad.State.Strict
15:55:52 <hunt> dcoutts: yes it does (if you mean the cabal packages directory)
15:56:01 <augur> monochrom: there's something hinting at the scandal of deduction in that page
15:56:09 <merijn> erisco: Control.Monad.Trans.State
15:56:15 <dcoutts_> hunt: I mean the dir /Users/hunt/.cabal/packages/hackage.haskell.org/text/1.1.0.1/
15:56:20 <monochrom> what is the scandal of deduction?
15:56:24 <hunt>  nh2: i thought 7.8.1 was the latest, im not totally sure on how im meant to update this stuff
15:56:29 <apples> mhr, you might be interested in gradual typing. wadler has written some about it
15:56:35 <merijn> erisco: State is just "StateT s Identity" nowadays :)
15:56:37 <erisco> merijn, hrm, does not seem to be there either
15:56:40 <dcoutts_> nh2: if it failed reading it'd have failed earlier
15:56:43 <Algebr> monochrom: Right, but I'm saying its more general in Haskell, instead of creating a named object, you could just use a list of tuples.
15:56:55 <geekosaur> hunt: 7.8.2 was released a few days after 7.8.1 due to a severe bug in typechecking
15:56:57 <augur> monochrom: basically, deductions provide 0 information in the information theoretic sense, yet they're still informative somehow
15:57:01 <hunt> dcoutts_: no it doesnt! only 1.1.0.0 exists
15:57:05 <nh2> hunt: how did you get 7.8.1? Probably you can get .2 in the same way
15:57:06 <erisco> merijn, yes. I suppose I'll just define it myself then
15:57:10 <nh2> hunt: also what is you cabal version?
15:57:27 <merijn> erisco: What's wrong with the one in Trans.State?
15:57:33 <erisco> merijn, it is not there
15:57:42 <hunt> nh2: cabal install version 1.18.0.3, and using cabal library 1.18.1.3
15:57:43 <monochrom> I think of it as the human scandal: humans work so hard to violate tautologies.
15:58:01 <erisco> *shrug* I dunno, I import it and still I have the error that State is not in scope
15:58:03 <merijn> erisco: http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-Trans-State-Lazy.html#t:State
15:58:09 <erisco> I know I looked at it
15:58:12 <erisco> that is why I thought it was there
15:58:16 <hunt> geekosaur: ah i see, i updated as soon as i heard about 7.8.1 releasing. why is one bug fix its own number?
15:58:16 <erisco> yet I import it and it is not
15:58:18 <merijn> Then you're importing wrong
15:58:18 <augur> monochrom: its not about violating tautologies tho, right. its something about how truths arent always obvious
15:58:28 <geekosaur> erisco: what are you doing exactly? if it's old enough then there is no State data constructor; use state (lowercase)
15:58:38 <monochrom> for example, a person who asks a vague question and wants a specific answer works against "the answer depends on the question".
15:58:40 <erisco> geekosaur, ohh
15:58:42 <geekosaur> (mtl1 had one, mtl2 uses a type alias)
15:58:49 <augur> monochrom: like, the fact that there are infinitely many prime numbers isnt obvious from, say, peano axioms, but its entailed, so somehow its informative to prove it
15:59:18 <hunt> nh2 & dcoutts_ i get permission denied when i try and mkdir ~/.cabal/packages/hackage.../text/1.1.0.1 ... what does this indicate?
15:59:21 <erisco> geekosaur, good catch thanks
15:59:34 <augur> monochrom: or another classic example is, when you see someone at a party and someone says, "That's Bob", the person is stating something true, and therefore its deductive information content is 0, but its new information to you somehow
16:00:27 <nh2> hunt: the fact that you have different binary and library versions is already a bit weird. Try `cabal install cabal-install` to get cabal 1.20, make sure that that version is being used (with library any binary having the same version), and if it still has the same problem please tell us
16:01:00 <anthezium> anybody know the options that you can pass to the ghc literate preprocessor "unlit"?  i'm trying to get it to ignore bird tracks or pay attention to "\begin{spec}" in addition to "\begin{code}"
16:01:10 <monochrom> however, the tautologies I include on my page are nowhere near the "peano axioms plus set axioms imply infinitely many primes" kind of difficulty.
16:01:23 <dcoutts_> nh2: though none of that directly seem relevant
16:01:30 <augur> monochrom: for instance, "not all constraints can be satisfied" is non-obvious (and probably dependent on what the constraints are allowed to be in general!), so in some real sense its informative to know
16:01:50 <dcoutts_> nh2: hunt says the dir itself does not exist, which is very odd since it creates it before doing the download
16:02:05 <augur> even tho it may well be provably true about your system in question, and therefore the information content is 0
16:02:11 <hunt> dcoutts_: i think cabal doesnt have the priveleges to create it
16:02:19 <mhr> apples: all the gradually typed programming languages seem to start with a dynamically typed language and add annotations, which I'm trying to avoid. I'm thinking that it might be cool to have a gradually typed scripting language.
16:02:37 <dcoutts_> hunt: but then it should have failed earlier
16:02:49 <dcoutts_> hunt: at the point at which it tried to create it
16:02:59 <dcoutts_> hunt: in ghci, what happens if you do:
16:03:03 <nh2> dcoutts_: true, but it probably can't hurt to check if 1.20 fixed it
16:03:29 <dcoutts_> hunt: System.Directory.createDirectory "/Users/hunt/.cabal/packages/hackage.haskell.org/text/1.1.0.1/"
16:03:45 <dcoutts_> hunt: and double check it doesn't exist first
16:04:03 <dcoutts_> hunt: assuming you don't have permissions, it should fail with an exception
16:04:21 <dcoutts_> and if it doesn't fail, then the dir should be created
16:04:41 <dcoutts_> hunt: oh, wait, wrong function, try...
16:04:54 <dcoutts_> System.Directory.createDirectoryIfMissing True "/Users/hunt/.cabal/packages/hackage.haskell.org/text/1.1.0.1/"
16:05:28 <Iblues76> how about Real World Haskell... has anyone use this book?
16:05:37 <augur> monochrom: but more importantly, why are _those_ tautologies empty, but others arent? thats the scandal
16:05:57 <hunt> dcoutts_ ive chmoddedthe text directory to be writeable and im trying to install text now, if it fails ill try that
16:05:59 <hunt> thanks
16:06:15 <dcoutts_> hunt: actually I'd like to see if we can track down the problem
16:06:24 <dcoutts_> otherwise we cannot fix anything
16:06:42 <hunt> dcoutts_ im pretty sure i at some point installed hackage or cabal or something with sudo
16:06:46 <hunt> and wiped it and reinstalled
16:06:51 <hunt> and perhaps missed this text folder
16:06:55 <hunt> which is now unaccessable
16:06:58 <hunt> by cabal
16:06:59 <dcoutts_> hunt: that sounds likely, but it still smells like a bug
16:07:11 <dcoutts_> it smells like we've found a bug where a failing operation doesn't actually trigger an exception
16:07:16 <dcoutts_> when it really should
16:07:27 <hunt> the text folder is definitely not writeable by cabal without sudo
16:07:40 <dcoutts_> and since we're just using the ordinary System.Directory functions, then that could be a bug in that core lib
16:07:43 <hunt> so it should be recreatable just by modding any folder to be unwriteable
16:07:45 <ski> augur : i'd rather thought it'd be `x :: String |- "foo #{x} bar" :: String' or `Show a,x :: a |- "foo #{x} bar" :: String' (or `x :: a |- "foo #{x} bar" :: Show a => String' if you prefer)
16:08:01 <dcoutts_> hunt: but perhaps only on OSX, and I don't have access to OSX
16:08:18 <hunt> dcoutts_ guess which text library just installed successfully? what do you want me to do to get the data on this bug?
16:09:05 <dcoutts_> hunt: ok, so chmod the dir to be unwritable again, and then using ghci run the code I pasted above, the System.Directory.createDirectory one
16:09:06 <augur> ski: sure, you could do something like that i guess, if you want to enforce type safety. i was just thinking, in a language like ruby where you could just write some junk without type checking, it seems more like a presupposition
16:09:15 <augur> ski: well, really, all variable access is like that, i guess
16:09:28 <dcoutts_> hunt: but give it a different dir to create this time, e.g. a pretend new version of text
16:09:42 <hunt> dcoutts_ im going to run it in a different directory if thats alright, because im installing some much needed libs that depended on text now
16:11:09 <dcoutts_> hunt: sure, any dir should do, ie creating a dir in a non-writable dir
16:11:36 <dcoutts_> e.g. System.Directory.createDirectory "./unwritable/tstdir"
16:11:39 <dcoutts_> erm
16:12:01 <dcoutts_> hunt: sorry, it's the System.Directory.createDirectoryIfMissing True   one we have to test
16:12:06 <dcoutts_> not createDirectory
16:12:32 <hunt> dcoutts_ i created a readonly folder, ran the function, and it returned nothing at all, no exceptions and no data
16:12:45 <nh2> is there some law that says that Enums must be contiguous, e.g. that a type can't map to 0, 1, 4 for example?
16:13:32 <hunt> dcoutts_ there is however an exception thrown if i use only createDirectory function
16:13:48 <geekosaur> nh2, not /per se/ but you have the problem of what to do with toEnum 3
16:13:58 <dcoutts_> hunt: ok thanks, that's the culprit
16:14:12 <geekosaur> and that generally Haskell does not get along with subtyping like that
16:14:15 <dcoutts_> hunt: I'll see on linux and file a ticket
16:14:17 <hunt> dcoutts_ you going to make a bug report?
16:14:19 <hunt> cool
16:14:32 <geekosaur> (a good example of this btw is the Enum instance for Double, which does not enumerate all Double values)
16:15:38 <dcoutts_> hunt: mm, it works on linux, I suspect some difference in return codes on osx. What OSX version?
16:15:44 <nh2> geekosaur: exactly, and then succ doesn't work any more
16:15:46 <akurilin> Those of you using vim2hs, do you know how to prevent it from collapsing every function in a file?
16:16:16 <nh2> but I'm quite sure I have seen FFI wrappers that give enum instances based on a C enum, which often has holes in
16:16:54 <merijn> nh2: You can easily work around that though
16:17:56 <hunt> dcoutts_ 10.9.2
16:18:18 <merijn> nh2: See for example https://github.com/haskell/c2hs/issues/78
16:18:40 <dcoutts_> hunt: and just for completeness, can you try the same with createDirectoryIfMissing False
16:18:52 <hunt> i did
16:18:54 <hunt> same results
16:18:57 <dcoutts_> hunt: ok thanks
16:19:15 <hunt> np, cool to actuallyhave an impact on haskell
16:19:23 <merijn> I plan to make a quasiquoter that generates Enum instances and pattern synonyms for newtypes of C enums, that should make things nicer. Unfortunately you won't be able (for now) to get exhaustiveness checks from GHC with that
16:19:54 <hunt> has anyone used idris much?
16:19:58 <hunt> how does it stack up
16:21:47 <dcoutts_> hunt: ghc version?
16:22:09 <dcoutts_> hunt: oh 7.8.1, found it, ta
16:22:19 <nh2> merijn: ah, I was thinking about exactly that problem. I definitely agree with your guys opinion that Enum and C enums should be different things, and that Haskell Enums better be contiguous. I will upvote a CEnum, and have written it many times myself
16:23:23 <merijn> nh2: I proposed adding nicer enums to GHC's FFI, but that was shot down as to "niche"
16:24:08 <hunt> how do you guys update ghc?
16:24:11 <merijn> If I can succesfully campaign for "closed sets of pattern synonyms" (i.e. get exhaustiveness checks for groups of synonyms) I can fake it with a quasiquoter and pattern synonyms, so that'd be ok too
16:24:13 <startling> merijn, well, they're right
16:24:16 <hunt> brew only has up to7.6
16:24:17 <dcoutts_> hunt: ok, filed, thanks for taking the time to help us find it. https://ghc.haskell.org/trac/ghc/ticket/9044
16:24:18 <startling> merijn, who would want to use the FFI?
16:24:26 <hunt> dcoutts_ no problem at all
16:24:37 <hunt> dcoutts_ thanks fo rthe help solving it
16:24:41 <erisco> if I have the tuples (x,y) and (m,n) how do I get the Ix range from (x,y) to (m,n) ?
16:24:42 <dcoutts_> np
16:24:50 <johnw> does "foldr (<|>)" have a name?
16:24:53 <erisco> ie to construct the array bounds
16:25:06 <merijn> :t msum
16:25:07 <lambdabot> MonadPlus m => [m a] -> m a
16:25:08 <hunt> whats the standard method to update ghc guys?
16:25:13 <merijn> johnw: msum? :p
16:25:29 <l0cust> hunt: Your distro's package manager
16:25:37 <johnw> msum is foldr mplus
16:25:46 <johnw> ah, asum
16:25:54 <merijn> johnw: mplus and <|> should be the same for most types?
16:25:55 <johnw> thanks!
16:26:17 <johnw> merijn: it is in my case too, I was just curious
16:26:21 <hunt> l0cust: on os x, so brew, which is sadly onlyup to ghc 7.6.3
16:26:44 <merijn> hunt: On OSX I just install GHC directly from either binary package or source on the GHC page
16:27:09 <l0cust> hunt: Maybe manually install haskell platform?
16:27:09 <merijn> There should be a binary for 10.9, I'm still on 10.7 so I just built from source
16:28:13 <nh2> merijn: yes I read that. In the proposal, do you address what would be the actual benefit over just making a CEnum typeclass?
16:28:58 <hunt> merijn: damni  wish there was a better solution; locust yea i guess i will
16:29:26 <startling> hunt: I'd recommend the .pkg
16:29:38 <merijn> nh2: My proposal conversion is a no-op
16:29:56 <hunt> startling: of the haskell platform or of ghc? if of ghc i dont see a .pkganywhere
16:30:03 <startling> hunt: ghc
16:30:04 <merijn> nh2: A CEnum typeclass means still having to explicitly marshall after/before FFI call
16:30:11 <startling> you can install everything in the platform with cabal
16:30:29 <startling> hm, I may have installed from the bootstrapped source
16:30:32 <startling> that's also not a bad option
16:30:53 <startling> hunt: ah, yeah, I just used http://www.haskell.org/ghc/download_ghc_7_8_2#macosx_x86_64
16:31:46 <orzo> I've been reading about roles and Coercible
16:32:07 <merijn> ]
16:32:43 <orzo> I have a question:  Why do we bother to distinguish the role "representational" from the rule "phantom" ?  it seems like if we used a single role "parametric" to mean either would suffice for all purposes
16:33:04 <hunt> startling: ah alright i was going to use that anyways i think
16:33:07 <nh2> merijn: I see. I probably wouldn't call it niche, and would welcome it, but practically a CEnum class is probably the fastest way to get improvements into the wild
16:34:50 <migimunz> Hello. Is it possible to define generic type synonyms, like type Value a = Either String [a] ? It compiles, but I can't construct a Value using Right and Left.
16:35:36 <startling> migimunz, could you paste your code and errors to lpaste.net/new/haskell ?
16:35:44 <vermeille> If I write `0 * foo n`, how comes that `foo n` is evaluated? Can't ghc elide the call to foo as it would do with `False && foo n`?
16:36:08 <joelteon> depends on what Num instance you're using
16:36:10 <startling> vermeille, it can't for Int or Integer
16:36:29 <startling> vermeille, but if you had e.g. data Nat = Z | S Nat it could
16:36:30 <monochrom> (*) for most types are defined to evaluate both unconditionally
16:36:57 <migimunz> startling, nevermind, found out what the problem was :) . Poor refactoring. I'm reimplementing an exercise using the Either monad to indicate failure, and I used Value [a] instead of Value a, which disagrees with the function signature. Not sure how I missed it.
16:36:58 <joelteon> oh no hackage is down :(
16:37:00 <monochrom> you may, of course, write your own Num instance and write your own (*) to be less strict
16:37:13 <erisco> joelteon, noes!
16:37:14 <startling> migimunz: ah. :)
16:37:27 <migimunz> thanks anyway!
16:37:32 <monochrom> there is no real "why". someone made one decision. you can make the opposite decision.
16:38:02 <vermeille> Is there a good rationale not to optimise that? Actually it can even be done at compile-time if foo is strictly pure
16:38:14 <monochrom> no
16:38:27 <startling> vermeille: it's not an easy thing to do, and the payoffs are dubious
16:39:47 <bss03> http://lpaste.net/103287 <-- Is there a good way to do this without existentials?
16:40:02 <enthropy> vermeille: somebody might argue that  0 * error "something" -- should be an error, not 0?
16:40:12 <erisco> joelteon, yays it is alive again
16:41:49 <pjdelport> vermeille: Note that special-casing 0 isn't necessarily an optimization: additional branching logic has its own cost.
16:41:57 <monochrom> bss03: is "p" usually Proxy?
16:43:30 <bss03> monochrom: It's either [real_value] or (parseJSON undefined) in the existing code.
16:44:07 <bss03> monochrom: Put, yeah, it's suppored to be something like Proxy, I'm just not depending on tagged, yet.
16:44:13 <bss03> *But
16:44:14 <vermeille> enthropy: isn't your example falling in the debate of laziness?
16:44:50 <enthropy> yes
16:44:54 <jle`> why is <$> for fmap when it makes more sense for what <*> is ... :'(
16:45:01 <enthropy> > 0 * (1/0)
16:45:02 <lambdabot>  NaN
16:45:20 <startling> jle`, <*> has kind of a weird history
16:45:33 <startling> jle`, it used to be f a -> f b -> f (a, b)
16:45:38 <startling> so it makes sense as a "lifted product"
16:45:38 <vermeille> pjdelport: true, I'm just saying that the compiler could do more things at compile time (like evaluating pure functions with all arguments provided and some elisions)
16:45:44 <bss03> jle' = <$> is "lifted" $, <*> is "lifted" .
16:45:51 <monochrom> jle`, I see what you mean. too bad there are so many different things analogous to "application", eh?
16:46:01 <startling> bss03: no it's not?
16:46:05 <copumpkin> bss03: unless you need to talk about two message values having the same type,  I'd just turn Message into a data type
16:46:09 <copumpkin> and pass that around
16:46:15 <jle`> bss03: f (a -> b) -> f a -> f b
16:46:23 <jle`> sounds more like "lifted $" to me
16:46:27 <jle`> :t $
16:46:28 <lambdabot>     parse error on input ‘$’
16:46:28 <lambdabot>     Perhaps you intended to use TemplateHaskell
16:46:30 <jle`> :t ($)
16:46:31 <lambdabot> (a -> b) -> a -> b
16:46:44 <startling> hm, fmap should be ($>)
16:46:48 <jle`> i am being facetious of course
16:46:51 <startling> then (<$>) could be "ap"
16:47:01 <startling> mnemonic: point to the lifted values
16:47:41 <bss03> copumpkin: I guess I'm not sure how to do that.
16:47:47 <pjdelport> vermeille: The compiler does do that to some extent (constant folding), but in general, this is a hard and open-ended problem.
16:48:00 <jle`> f $> x <$> y <$> z
16:48:06 <jle`> i am ok with that
16:48:14 <bss03> copumpkin: msgJSON sort of depends on msgType working without a value, but giving different results as differnt types.
16:48:48 <copumpkin> oh I see, there is a compatibility requirement there
16:48:51 <jle`> > (+) 1 $ 2
16:48:52 <lambdabot>  3
16:49:05 <copumpkin> bss03: either way, you can keep the existential and get rid of the class
16:49:22 <jle`> (\x y z -> x + y + z) 1 $ 2 $ 3
16:49:25 <pjdelport> vermeille: The limit of this is known as supercompilation: there's a whole Haskell implementation dedicated to it: http://community.haskell.org/~ndm/supero/
16:49:28 <jle`> > (\x y z -> x + y + z) 1 $ 2 $ 3
16:49:29 <lambdabot>  Could not deduce (GHC.Num.Num (s0 -> s))
16:49:29 <lambdabot>    arising from the ambiguity check for ‘e_1123’
16:49:29 <lambdabot>  from the context (GHC.Num.Num (s1 -> s),
16:49:29 <lambdabot>                    GHC.Num.Num s1,
16:49:29 <lambdabot>                    GHC.Num.Num s)
16:49:37 <jle`> oh does $ not work that way
16:49:43 <haasn> $ is right associative
16:49:55 <bss03> copumpkin: So, instead of the typeclass, I'd... inline it into the existential?
16:50:07 <pjdelport> There's been some work to make GHC do this too, to some extent, apparently: https://ghc.haskell.org/trac/ghc/wiki/Supercompilation
16:50:21 <copumpkin> bss03: probably :)
16:54:56 <bss03> copumpkin: Can you maybe point me at an example of the transformation... or is it not really a "cookbook" transformation?
16:55:24 <akurilin> Quick question for you vim guys: did you get a lot of value out of neco-ghc and ghcmod-vim ?
16:56:07 <bss03> akurilin: I don't think I've used either yet.  I just got syntastic working today. :P
16:56:51 <akurilin> bss03: that's another one of those I've had installed forever but always disabled, heh
16:56:56 <copumpkin> bss03: did I mess it up? http://lpaste.net/103288
16:57:06 <akurilin> need to start leveraging tools more
16:57:20 <copumpkin> anyway, not really sure how useful that all is
17:01:20 <bss03> copumpkin: Probably not at all, but what' I'm trying to do is read a JSON message, look at one value in it and then decide on a parser to use, each of the parers returns a different type, but then I stuff them into a sum type.
17:01:38 <copumpkin> I see
17:02:06 <bss03> copumpkin: Also, the msgType is used for writing, basically it generates a toJSON in terms of jsonMsg.
17:02:07 <copumpkin> that doesn't feel like the ideal design
17:02:17 <timmy_tofu> GhcModType is nice
17:02:43 <timmy_tofu> when debugging, doing it repeatedly until i get the type sig of a sub-part of something i'm working on
17:02:47 * copumpkin 's head is about to explode so can't think very clearly
17:04:10 <bss03> copumpkin: It's probably not, but the differnt message differ in contents quite a bit -- so I wanted separate types for each message.  But, there's also a lot of message types, so the church encoding (of my sum type) or cps transformation of the existing loop seems... more awkward.
17:06:37 <timmy_tofu> And I use neco-ghc (with neocomplete), very handy... too handy, maybe. Like when I'm at the command line, I get mildly irritated on the rare occassion when I hit the first two characters and then tab and it doesn't know exactly what I want
17:08:16 <bss03> copumpkin: But, even with my approach, I have nearly a dozen instances of Message to write which is annoying.
17:08:33 <bss03> copumpkin: What's causing your head to explode?  I hope you feel better soon.
17:08:49 <copumpkin> just a bad headache :( don't really feel like thinking hard right now, sorry :/
17:08:56 <copumpkin> or I'd help you with your design
17:09:31 <bss03> copumpkin: No worries; thanks for your help so far.
17:16:37 <erisco> (==1) . length . take 2         is there a better way to lazily test if a list is a singleton?
17:19:08 <jle`> you can pattern match on _:[] i guess
17:19:25 <Total_1mmersion> I'm incrementing a counter in the State monad, but it appears that within a do block, the values appear in reverse order. Any idea why that is happening?
17:19:36 <jle`> or null . drop 1 maybe
17:19:42 <jle`> Total_1mmersion: can you post some code?
17:19:42 <geekosaur> prob ably ~(_:[])
17:19:57 <geekosaur> so it's not a strict pattern
17:20:03 <shachaf> Total_1mmersion: No one will have an idea without seeing your code.
17:20:05 <d1323> > (null . drop 1) []  -- nope
17:20:06 <lambdabot>  True
17:20:13 <jle`> oh yeah
17:21:12 <jle`> > [ x | ~x@(_:[]) <- [[1,2,3],[4],[5,6],[7]] ]
17:21:14 <lambdabot>  [*Exception: <interactive>:3:1-44: Irrefutable pattern failed for pattern x@...
17:21:26 <jle`> > [ x | x@(_:[]) <- [[1,2,3],[4],[5,6],[7]] ]
17:21:28 <lambdabot>  [[4],[7]]
17:21:57 <jle`> that's weird, i don't even know why it would throw an exception there
17:22:23 <jle`> if all you throw is x...doesn't that lose the information about whether or not it's a singleton
17:25:17 <quchen> jle`: The irrefutable pattern matches every element of the list, so the comprehension builds up a list of length 4.
17:25:20 <quchen> > length [ x | ~x@(_:[]) <- [[1,2,3],[4],[5,6],[7]] ]
17:25:21 <lambdabot>  4
17:25:58 <quchen> When you're forcing the list elements though, the pattern is evaluated and turns out not to match, so it errors out.
17:29:15 <Total_1mmersion> Here is my code which appears to be generating values out of order (search for "Here elseN") http://lpaste.net/3648611942433554432
17:31:42 <jle`> quchen: but why would the pattern need to be evaluated?
17:31:53 <jle`> nothing about x depends on the pattern
17:31:58 <jle`> oh
17:32:05 <jle`> it needs to figure out which ones are actually in the list
17:32:32 <jle`> hm
17:32:47 <jle`> i jsut don't see how ~x@(_:[]) should be any different than x@_
17:35:01 <quchen> Well let's evaluate it then. Step 1, list comprehension.  [ e | p <- l, Q ] = let ok p = [ e | Q ]; ok _ = [] in concatMap ok l
17:35:26 <quchen> Since your pattern is irrefutable, `ok _ = []` is never reached.
17:36:58 <jle`> ah
17:37:09 <jle`> is that how it actaully desugars?
17:37:38 <quchen> Not sure how GHC does it, but that's how the Haskell Report specifies it.
17:37:43 <jle`> i see
17:37:49 <jle`> that makes sense
17:37:50 <quchen> In other words it's valid, but may not be the most efficient way of doing it.
17:38:00 <jle`> but semantically it has to be the same
17:38:27 <jle`> hm but wait.
17:38:55 <jle`> > let f ~x@(_:[]) = True; f _ = False in f [1,2,3]
17:38:56 <lambdabot>  True
17:39:02 <jle`> :o
17:39:09 <jle`> wait
17:39:17 <jle`> > let f ~x@(_:[]) = x; f _ = [] in f [1,2,3]
17:39:19 <lambdabot>  *Exception: <interactive>:3:5-29: Irrefutable pattern failed for pattern x@(...
17:39:21 <jle`> oh
17:39:48 <quchen> So you've got [ x | ~x@(_:[]) <- [[1,2,3],[4],[5,6],[7]] ]  ⇒  let ok ~x@(_:[]) = [x] in concatMap ok [[1,2,3],[4],[5,6],[7]]]
17:40:03 <quchen> And that reduces to something similar to what you just posted.
17:40:38 <jle`> > let f ~x@(Just _) = x; f _ = Nothing in (f Nothing, f (Just 1))
17:40:40 <lambdabot>  (*Exception: <interactive>:3:5-36: Irrefutable pattern failed for pattern x@...
17:40:57 <jle`> > let f ~x@(Just _) = x; f _ = Nothing in f (Just 1)
17:40:59 <lambdabot>  Just 1
17:41:03 <jle`> i'm not sure why the first one has to fail
17:41:18 <jle`> maybe i am misunderstanding the lazy pattern matching semantics
17:41:49 <jle`> but i would have expected ~x@(Just _) to be the same as ~x@_
17:42:36 <timmy_tofu> > let f ~x@(Just _) = x; f _ = Nothing in f Nothing -- this is more like the other
17:42:37 <lambdabot>  *Exception: <interactive>:3:5-36: Irrefutable pattern failed for pattern x@(...
17:42:53 <jle`> yeah, i don't understand why that has to have an exception
17:43:01 <quchen> "~" doesn't say "this pattern always matches", it means "I promise this always matches". It essentially delays the time when the pattern is actually checked; that check may be omitted if the compiler does not require the pattern to match.
17:43:06 <jle`> ah
17:43:11 <jle`> so it's still checked
17:43:18 <quchen> But if you reference the "x" later the pattern has to be used
17:43:19 <jle`> just later
17:43:49 <jle`> i always thought it was this pattern always matches, but it'll throw an exception if you try to get something named inside it
17:44:12 <jle`> if it's not there
17:44:40 <quchen> > let f ~(Just 1) = 1 in f Nothing -- The pattern is never needed, and it promises that it matches. Since nothing is bound and referenced in the pattern, there's no need to check it.
17:44:42 <lambdabot>  1
17:45:12 <quchen> You can view the precise semantics in the report
17:45:22 <jle`> ah thanks. i'll definitely look that over
17:46:16 <quchen> There's even an "informal" section that's a little more approachable. It has several refutable/irrefutable examples.
17:46:34 <jle`> i guess i just thought, you never "look inside", so why does it care what's inside :|
17:49:32 <quchen> jle`: The point is this: usually, when you have a definition "def pat = something; def otherPat = somethingElse", you have to evaluate the RHS to check which of the patterns match. This evaluation may be expensive or otherwise unwanted.
17:50:08 <quchen> So using an irrefutable pattern delays this "check whether this is the right definition, or whether the next case should be evaluated".
17:51:00 <quchen> But even when you delay the checking, asking for it at some later point makes it necessary to match against the pattern.
17:51:20 <quchen> Usage example: the difference between strict/lazy State is just "~"
17:51:54 <quchen> lazy has ~(x, s') <- runState ...; strict doesn't have the tilde
17:59:20 <nh2> kfish: such a PITA. I just wanted to reinterpret_cast a Float to a Word32 (C's `* (uint32_t *) &f`), for which I wrote a library, for which I wanted to write an exhaustive test over Word32, for which loops were 10x too slow, so I wrote a library, for which I now have > 300 lines of benchmarking code.
18:00:21 <jle`> thanks quchen
18:09:04 <pjdelport> nh2: Are your yaks reproducing?
18:12:00 <hunt> is it wrong to have anxieties about using language extensions?
18:12:19 <lispy> hunt: it really depends on the extension and the problem you're using it on
18:12:49 <lispy> hunt: few haskell libraries just stick to Haskell2010
18:13:20 <hunt> is there a web framework that doesnt use cabal to build
18:13:59 <lispy> cabal is the standard build system for haskell
18:14:40 <joelteon> i hope there is not one that doesn't use cabal
18:14:42 <nh2> pjdelport: absolutely
18:15:04 <nisstyre> is it wrong to be anxious about all of the threaded code out there that incorrectly uses synchronization primitives?
18:15:41 * hackagebot yesod-pagination 1.0.0.0 - Pagination in Yesod  http://hackage.haskell.org/package/yesod-pagination-1.0.0.0 (JoelTaylor)
18:15:46 <AshyIsMe> probably in the same way that it's wrong to worry about your plane crashing
18:16:11 <AshyIsMe> it's always a possibility, and it takes a lot of effort to try to make sure it doesnt happen, but once you're flying...
18:16:18 <nisstyre> AshyIsMe: Ada is usually single threaded no?
18:17:03 <pjdelport> AshyIsMe: multithreading bugs are way, way more common than planes crashing
18:17:44 <AshyIsMe> hehe, it's probably not the best analogy
18:18:06 <tommd> How about more common than model planes crashing?
18:21:41 <nh2> hunt: no, language extensions are not bad in general. There are a few different categories: 1) syntactical - use as you please, 2) obviously useful and harmless ones like MultiParamTypeClasses, GADTs, etc. - by all means use, 3) sick shit that most people and sometimes the type inference engine don't understand (ImpredicativeTypes) - fine to use if at least you understand what is going on, 4) things that can stop the compiler fr
18:22:13 <lispy> nh2: intentionally cut off or joke?
18:22:27 <lispy> "4) things that can stop the compiler fr"
18:22:28 <shachaf> ImpredicativeTypes is easy for people to understand. Only GHC has trouble.
18:23:04 <nh2> lispy: I think that is your IRC client's fault
18:23:27 <lispy> nh2: other way around
18:23:29 <nh2> or mine if it allows me to send arbitrary lenght messages without feedback that that isn't allowed
18:23:41 <lispy> Sadly, lots of IRC clients have that feature
18:23:49 <nh2> 4) things that can stop the compiler from terminating (UndecidableInstances), but who cares about that, it's just the compiler, not the final code, and 5) things that can actually make your code wrong (IncoherentInstances) - probably better don't use
18:24:11 <nh2> pls correct me if I'm wrong on one of these
18:24:27 <lispy> That more-or-less matches my understanding
18:25:03 <lispy> I'm not sure which bucket the type nats, polykinds, and those sorts of things fit. Maybe (2).
18:25:54 <nh2> hunt: there is also a tooling point-of-view: You might abstain totally new syntax extensions if you rely on non-ghc tools (like haskell-src-exts, which many tools build upon), they usually lag behind being able to parse new syntax
18:27:50 <thoughtpolice> i don't understand why we haven't just nuked -XImpredicativeTypes at this point.
18:28:07 * lispy thought we had
18:28:07 <thoughtpolice> like, 7 out of the approximately 9 tests GHC has for it are known to be broken
18:28:11 <lispy> Did something bring it back?
18:28:21 <thoughtpolice> no, it's just hung around AFAIK
18:29:43 <thoughtpolice> yeah, there's still some code lingering around in here relating to it. i don't see why we should keep it around when pretty much nobody understands how it should even work.
18:30:38 <shachaf> It would be nice if it worked, though.
18:30:43 <jle`> is a monoid action on a set simply a mapping of the monoid elements to endofunctors
18:30:50 <lispy> Normally it would mean Type : Type, but what does it mean for Haskell?
18:30:59 <jle`> and where the identity is mapped to id
18:34:13 <erisco> thoughtpolice, I need them =\
18:35:40 <albeit> Bit random, but for those who are fairly fluent in Haskell, do you program in it for your day job? Or is it just a hobby? Are you in academia? Just curious about whos on here!
18:36:11 <erisco> albeit, neither for me :D
18:36:30 <erisco> or... trither...
18:36:31 <LordBrain> I don't have a day job atm
18:36:50 <LordBrain> at least not one that pays
18:38:12 <thoughtpolice> shachaf: yes, but when it hasn't worked for a long time, it's time to give it the boot
18:38:17 <timmy_tofu> starting to introduce it at my day job, looking to gradually refactor a rails app inherited from multiple consultancies
18:39:03 <thoughtpolice> erisco: well, you'd better have a fairly compelling case, tbh. even edwardk i think might have some, but realistically i don't even know if that's worth caring for honestly, and i'd probably still be inclined to get rid of it if possible.
18:39:41 <erisco> thoughtpolice, my compelling case is that there is seemingly no other solution to have multiple reactive-banana networks
18:39:49 <erisco> if there is another solution no one was able to provide it
18:40:31 <albeit> Interesting, so most of you just picked up Haskell for the fun/challenge of it?
18:41:08 <thoughtpolice> Richard said this earlier today, but we constantly add things to GHC. sometimes we need to remove things, and things that are so inconsistent they don't even work sensibly work between versions of GHC, and furthermore nobody even knows how they work, are candidates
18:41:09 <erisco> thoughtpolice, and if impredicativetypes was removed I'd be SOL on this project because of it
18:41:38 <thoughtpolice> there's no guarantee, as far as I understand, that pretty much any of that will work tomorrow or the day after. if it does, you're probably lucky
18:41:43 <LordBrain> SOL?
18:41:49 <thoughtpolice> Shit-outta-luck
18:41:54 <LordBrain> ty
18:44:15 <LordBrain> I have to admit that with haskell... the lifespan of code seems to be significantly less than in most other languages, despite genuine effort at backward compatibility
18:44:18 <thoughtpolice> again, like i said above, we don't even really seem to even *test* ImpredicativeTypes, most of the tests are broken, or they are things that *should* fail because -XImpredicativeTypes weirded out the typechecking behavior sometimes, they're negative tests. so literally it is a question of *when* your code will break, not if.
18:45:42 <LordBrain> i suppose if you stick to haskell98, that's immortal
18:46:24 <LordBrain> perhaps haskell2010 will prove of equal longevity
18:47:07 <erisco> thoughtpolice, it seems the capability I need is to have a forall on a data type
18:47:34 <shachaf> thoughtpolice: I'm not disagreeing.
18:47:53 <shachaf> thoughtpolice: What's a case where nobody understands how it should work?
18:48:20 <erisco> but I do not really understand how I am using it or why it works :P
18:48:47 <erisco> my guess is that it makes the forall "existential"
18:49:01 <enthropy> erisco: what does it look like? Can RankNTypes work with a bit of rearrangement?
18:49:47 <erisco> enthropy, this is the extent of it: http://lpaste.net/103296 I literally do  unPage . Page
18:50:50 <erisco> as far as I understand it, a value implicitly has a forall out front. however, it will be instantiated to concrete types when used. by wrapping and unwrapping I no longer instantiate t
18:51:14 <thoughtpolice> shachaf: i mean in general - what's there is just the shattered remnants of the Boxy type stuff Simon implemented long ago, but it was way too fragile, and from what I understand now 'nobody' knows how to make it work in the sense nobody actually knows how the type checker should behave at all.
18:52:23 <shachaf> thoughtpolice: Is there a concrete case where it's not certain what the type checker should do?
18:52:46 <shachaf> (I'd certainly believe that there is. I'm just wondering what a simple one would be.)
18:53:19 <erisco> enthropy, but I find it weird...
18:53:29 <thoughtpolice> i don't know off the top of my head. but the 7 out of 9 tests marked broken in ./testsuite/tests/boxy in the GHC source is probably a start (and they have ticket numbers too)
18:53:36 <shachaf> Hmm, it's not very hard to come up with a case that confuses GHC.
18:55:38 <erisco> basically, I think, I just need to have this function: (forall a. f a) -> (forall a. f a)
18:56:23 <erisco> and impredicative types gives me the implementation for it
19:00:21 <hunt> so
19:00:27 <hunt> whats your favorite templating engine
19:00:30 <LordBrain> I am not especially familiar with unpredicative types, however, from reading this wiki page: http://www.haskell.org/haskellwiki/Impredicative_types   It seems to me that the type of unPage is equivalently written as forall t. Frameworks t => Page -> Moment t (Behavior t [Node])
19:00:32 <hunt> for html
19:00:35 <hunt> in haskell
19:00:55 <LordBrain> which is simpler to read, as it is what we are used to in haskell...
19:01:05 <erisco> LordBrain, no that is much different
19:01:16 <erisco> I specifically need the forall to be right of the ->
19:01:18 <bss03> hunt: I've heard good things about hamlet, although the only one I've actually used is...
19:01:43 <bss03> hunt: HStringTemplate
19:01:49 <zomg> blaze-html is kinda nice
19:01:52 <hunt> have you heard of Blaze? the tutorial im reading about scotty uses it
19:02:01 <hunt> zomg: do you think i should use it or consider something else?
19:02:27 <zomg> personally I like it but if you want the templates to actually resemble HTML, you probably would want something else :)
19:02:40 <zomg> since blaze is more like a Haskell EDSL for that
19:02:48 <LordBrain> Erisco, this wiki page says having it to the right is uninteresting, but in their example there is no type class constraint as you have here, so maybe i am over generalizing from their example:   Int -> forall a. a -> [a]  is the same as forall a. Int -> a -> [a]
19:03:12 <hunt> zomg: ok i guess ill look into it more
19:04:05 <LordBrain> That example is near the top of the wiki, which i admit i didn't finish reading... but from the sentence, " It turns out that appearing to the right of function arrows is not interesting: ..." I inferred that this applies to any occurrence of forall to the right of a function arrow.
19:04:46 <erisco> LordBrain, forall a b. a -> b  says "pick types 'a' and 'b' and I'll take a value of 'a' and return a value of 'b'", whereas  forall a. a -> forall b. b  says "pick a type 'a' and I'll return an unknown type 'b'"
19:05:09 <hunt> zomg: the thing is im working with a separate guy whose doing frontend, and he doesnt know haskell, so it seems like it would make more sense to just be replacing the relevant pieces of the doc with corresponding template lang
19:06:01 <zomg> yeah if you're working with someone else maybe Hamlet would be easier for them to deal with
19:06:38 <LordBrain> erisco, i think you are correct, but then that means the third paragraph of this wiki is clearly wrong, or worded strangely.. see what i mean --> http://www.haskell.org/haskellwiki/Impredicative_types
19:07:54 <erisco> LordBrain, they floated it to another argument, which might be different
19:08:03 <erisco> but I am not claiming any knowledge about how impredicative types works
19:08:16 <LordBrain> saying they are the same to me is a very strong suggestion that the typechecker should do the same thing in every case
19:09:25 <edwardk> ImpredicativeTypes is pretty much irredeemably broken at this point
19:10:31 <erisco> if it worked on an argument like it worked on the return then you'd be left with an uncallable function
19:10:35 <dmwit> I'm not sure LordBrain's question is actually about impredicative types. Is it?
19:11:01 <erisco> but it does not make much sense to have it be inconsistent
19:12:13 <dmwit> The type (forall a. f a) -> (forall a. f a) doesn't look impredicative to me.
19:12:32 <dmwit> Now, if you instantiate some of those a's or f's with polymorphic types, *then* it's impredicative.
19:12:40 <LordBrain> dmwit, erisco posted an example code: http://lpaste.net/103296  I was arguing (not with a lot of experience or certainty, but merely on a quick read of this wiki) that erisco's type signature for unPage should be precisely equivalent to forall t. Frameworks t => Page -> Moment t (Behavior t [Node])   Notice the forall floated out to the far left.
19:13:06 <erisco> the normal case in Haskell is that the caller determines the type vars (afaik) while the callee does not know. the forall in the return allows the callee to determine the type while the caller does not know
19:13:17 <LordBrain> based on my understanding of the third paragraph of the wiki here: http://www.haskell.org/haskellwiki/Impredicative_types
19:13:53 <dmwit> erisco: I don't think that's quite right.
19:14:09 <erisco> dmwit, that is my best guess to what is going on =\ but I am seeking clarification
19:14:24 <dmwit> Although the existence of => in that type does throw things a bit wonky.
19:15:09 <dmwit> I don't actually know what GHC thinks of that type. I don't even know what I would *want* it to think of that type, to be honest.
19:15:13 <LordBrain> yes, the example they gave on the wiki didn't have a type class constraint, it just said forall a.
19:15:17 <flazz> is there a recommended way to group quickcheck properties together like test suites on other platforms?
19:15:20 <LordBrain> so maybe i over generalized their point
19:15:29 <erisco> dmwit, well I can describe for you the problem that it solves
19:17:00 <erisco> (and maybe it is actually a broken unit test that I am exploiting... the types are phantoms anyways)
19:17:42 <LordBrain> ghc 7.8/
19:17:47 <LordBrain> ?
19:18:07 <LordBrain> 7.6 didn't have roles did it?
19:18:11 <erisco> anyways, I need to get the type   [forall t. (Frameworks t) => Moment t (Behavior t [Node])]   which is impredicative
19:18:29 <dmwit> Yes, that's impredicative.
19:18:38 <dmwit> And I suspect you will have rather a lot of trouble using something of that type.
19:18:58 <erisco> but all I have are values of   (Frameworks t) => Moment t (Behavior t [Node])  which is implicitly  forall t. (Frameworks t) => Moment t (Behavior t [Node])
19:19:00 <dmwit> Because, as edwardk mentioned, ImpredicativeTypes is hopelessly broken.
19:19:06 <erisco> dmwit, no I do not, it works fine
19:19:22 <dmwit> Good for you!
19:19:24 <dmwit> (seriously)
19:19:40 <LordBrain> maybe it just seems broken to the moguls
19:19:40 <edwardk> dmwit: you can use if for any one version of ghc in a few marginal usecases, but those usecases vary version by version
19:19:58 <edwardk> and trivial changes to the code break it
19:20:30 <erisco> anyways, even though the values implicitly have the forall t., the 't' will be homogenous over the list, so I would end up with  forall t. [(Frameworks t) => Moment t (Behavior t [Node])]  instead
19:20:38 <edwardk> erisco: my recommenation is to take that type you need a list of, and make a newtype for it
19:21:10 <erisco> which is why I need the  forall t. (Frameworks t) => Moment t (Behavior t [Node]) -> forall t. (Frameworks t) => Moment t (Behavior t [Node])  function which is  unPage . Page
19:21:29 <edwardk> data Foo t = Foo { runFoo :: forall t. Frameworks t => Moment t (Behavior t [Node]) }  -- now [Foo t] is no longer impredicative
19:21:36 <edwardk> and you can open that box whenever you want
19:21:45 <dmwit> Yes, I too would recommend pushing unPage a bit deeper in your code.
19:21:50 <dmwit> Avoid ImpredicativeTypes.
19:21:58 <edwardk> s/data/newtype
19:22:08 <edwardk> er
19:22:17 <erisco> sorry, it is "pushed up", I was just simplifying
19:22:23 <shachaf> GHC has a void ImpredicativeTypes.
19:22:24 <erisco> I actually keep [Page]
19:22:26 <edwardk> newtype Foo = Foo { runFoo :: forall t. Frameworks t => Moment t (Behavior t [Node]) }
19:22:26 <dmwit> edwardk: (He already has this newtype, but he called it Page/unPage instead of Foo/runFoo.)
19:22:31 <edwardk> ok
19:22:34 <edwardk> then what is the problem?
19:22:42 <erisco> well to define Page I need impredicative types
19:22:47 <edwardk> why?
19:22:51 <dmwit> Yeah, why?
19:23:13 <edwardk> Page is perfectly predicative unless Moment or Behavior are weird
19:24:49 <erisco> edwardk, dmwit I do not know. let me remove impredicative types and see what happens
19:27:09 <erisco> okay... virtualisation is randomly not working right now
19:30:36 <erisco> edwardk, dmwit could you explain why Page is not impredicative?
19:31:30 <dmwit> You know you can substitute type variables with types, right?
19:31:36 <dmwit> The question is: which types?
19:31:43 <edwardk> Impredicative types allow quantifiers to occur underneath arbitrary type constructors. Normally with Rank-N types they can only occur under the left or right hand side of (->) (thought the latter all get lifted across)
19:31:51 <dmwit> If you can substitute a type variable with a *polymorphic* type, that is called an "impredicative" system.
19:32:07 <edwardk> if you take apart Page and runPage that never occurs
19:32:26 * dmwit steps aside and lets edwardk explain
19:32:31 <dmwit> too many cooks and all that
19:32:36 <edwardk> Page :: (forall t. Frameworks t => Moment t (Behavior t [Node])) -> Page
19:32:45 <edwardk> runPage :: Page ->  forall t. Frameworks t => Moment t (Behavior t [Node])
19:33:06 <edwardk> -- which gets lifted to the rank1 type: runPage :: forall t. Frameworks t => Page ->  Frameworks t => Moment t (Behavior t [Node])
19:33:41 <edwardk> Page has a rank-2 type. runPage has a rank-1 type.
19:33:52 <edwardk> neither is impredicative
19:33:56 <lispy> dmwit: I don't think that's the definition of impredicative system. I think that's the mechanism that we used to get impredicativity in haskell.
19:34:25 <edwardk> lispy: i'm focusing on what the ImpredicativeTypes extension kinda sorta lamely does here
19:34:35 <edwardk> technically everything we do is impredicative ;)
19:34:36 <dmwit> lispy: I'm pretty sure what I said is the definition, and what edwardk said is the consequence.
19:34:59 <dmwit> lispy: From wikipedia: "a definition is said to be impredicative if it invokes (mentions or quantifies over) the set being defined".
19:35:22 <dmwit> lispy: In the setting of a type system, this means: do the types we're polymorphic over mention other (polymorphic) types?
19:35:31 <dmwit> Or just a different set (namely, monomorphic types)?
19:35:52 * hackagebot yesod-pagination 1.1.0.0 - Pagination in Yesod  http://hackage.haskell.org/package/yesod-pagination-1.1.0.0 (JoelTaylor)
19:35:56 <erisco> mkay well I have to reboot to see what is up with my virtualisation
19:36:02 <lispy> dmwit: I guess I was objecting because things like Type : Type are sufficient to be impredicative.
19:36:57 <edwardk> i was focusing solely on the language extension, not the logical implications
19:36:57 <dmwit> lispy: Think about what Type : Type means in terms of what type variables can be substituted to. You might come around to my way of thinking. ;-)
19:37:43 <edwardk> heh, true.
19:43:23 <jle`> probability distributions are a monad, what
19:43:37 <dmwit> It's like [a], but with weights.
19:43:38 <jle`> can't we mondle quantum computation algorithms in a monad
19:45:22 <edwardk> jle`: yes, though you need linear types
19:45:40 <jle`> hm. linear types?
19:45:50 <jle`> do you mean that the size of the vector is in the type?
19:45:50 <edwardk> jle`: you can fake it though with complex probability distrbutons but it oesn't check linearity
19:45:51 <lispy> dmwit: I agree that what you said is sufficient for type systems. Is it necessary?
19:46:01 <hiptobecubic> in the idiomatic way to do compound sorting that makes use of Monoid (a -> a), is there a way to pull the repeated (compare `on`) out? It looks like there should be.
19:46:14 <hiptobecubic> In something like  comp = (compare `on` fst) <> (compare `on` snd)
19:46:39 <jle`> :t on
19:46:40 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
19:46:46 <jle`> :t on compare
19:46:47 <lambdabot> Ord b => (a -> b) -> a -> a -> Ordering
19:47:07 <jle`> :t (compare `on` fst)
19:47:08 <lambdabot> Ord b => (b, b1) -> (b, b1) -> Ordering
19:47:25 <edwardk> jle`: no linear types say something about variable reuse
19:47:37 <edwardk> jle`: you know how observing a thing collapses the waveform?
19:47:43 <jle`> edwardk: yea
19:47:43 <edwardk> you need to typecheck that
19:48:11 <edwardk> you can only encode "unitary operators" in a quantum system
19:48:17 <edwardk> that's what you get by entangling bits
19:48:56 <jle`> edwardk: ah
19:50:49 <jle`> hiptobecubic: well you can foldMap (on compare)
19:51:23 <lispy> dmwit: I think I just convinced myself that is is necessary. Having self-referential types in your type system isn't enough. You need for the type system as a whole to have this property.
19:52:18 <hiptobecubic> :t foldMap
19:52:19 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
19:52:24 <dmwit> err
19:52:38 <jle`> :t foldMap (on compare) [fst, snd]
19:52:39 <lambdabot> Ord b => (b, b) -> (b, b) -> Ordering
19:52:42 <jle`> not sure how idiomatic it is tho
19:53:08 <hiptobecubic> @src foldMap
19:53:08 <lambdabot> Source not found. My pet ferret can type better than you!
19:53:23 <jle`> foldMap f = mconcat . fmap f
19:53:33 <lispy> dmwit: For instance, does data Mu f = Mu (f (Mu f)), make your type system impredicative or just give you some self-referential types?
19:53:45 <hiptobecubic> jle`, thanks
19:54:04 <dmwit> Recursion is a different kind of self-reference, I think.
19:54:06 <jle`> mconcat = foldr (<>) mempty or something
19:54:31 <dmwit> We're really talking about treating the type system as a logical proof system.
19:55:33 <jle`> functions are so weird
19:55:40 <hiptobecubic> jle`, yes.
19:55:59 <jle`> whose idea was it to build an entire programming paradigm out of them
19:56:12 <dmwit> I mean, "necessary" and "sufficient" are weird terms when you're asking about the definition of a thing.
19:57:38 <dmwit> lispy: https://en.wikipedia.org/wiki/Impredicative_polymorphism#Impredicative_polymorphism
19:57:41 <lispy> Not sure I follow what you mean by that. It's a pretty standard approach to understanding what is required to make something hold.
19:58:30 <dmwit> My understanding of the conversation was like this: I claimed "the definition of X is Y". Then you asked, "is Y necessary and sufficient for X"?
19:58:52 <hiptobecubic> :t msum
19:58:53 <lambdabot> MonadPlus m => [m a] -> m a
19:59:15 <dmwit> I probably misunderstood you.
19:59:20 <dmwit> I'm good at that.
19:59:41 <hiptobecubic> :t mconcat
19:59:42 <lambdabot> Monoid a => [a] -> a
19:59:53 <lispy> dmwit: yeah, so a precise definition (where I just made up that terminology) would have Y being necessary and sufficient
20:00:17 <lispy> sometimes you see definitions written as iff
20:01:03 <dmwit> sure
20:01:14 <hunt> im trying to implement an "instance Show ((->) a b)" for curiosities sake but cant get anythingn about it working, help?
20:01:30 <dmwit> hunt: You could check the universe package's instance for ideas about how to do it.
20:01:53 <dmwit> hunt: http://hackage.haskell.org/package/universe-reverse-instances-1.0/docs/src/Data-Universe-Instances-Show.html
20:01:57 <jle`> hunt: well you can have show _ = "function" :)
20:02:24 <hunt> ohhh im silly thanks jle` and dmwit
20:02:27 <dmwit> hunt: Definition of the Finite class is here: http://hackage.haskell.org/package/universe-base-1.0/docs/src/Data-Universe-Class.html
20:02:45 <jle`> for funsies you can try implementing lambdabot's instance
20:02:49 <jle`> > (+)
20:02:50 <lambdabot>  <Integer -> Integer -> Integer>
20:03:05 <jle`> but you're going to need constraints of some kind
20:03:15 <jle`> becuase due to parametricity you can't really get anything out of ((->) a b) in general
20:03:31 <jle`> er
20:03:32 <jle`> any String out of it
20:03:43 <jle`> just like there is no possible function f :: a -> String
20:03:56 <jle`> er
20:03:58 <jle`> that doesn't ignore a
20:04:42 <gamegoblin> I’ve got a hex string. Best way to convert to Int?
20:05:07 <lispy> dmwit: My conclusion is that you gave the correct definition. Moreover, the Mu thing I gave leads to self-referential types but not a self-referential type system.
20:05:18 <shachaf> > "c0ffee" ^? hex
20:05:19 <lambdabot>  Just 12648430
20:05:45 <dmwit> lispy: Yeah, that seems like a good summary of Mu.
20:05:53 <jle`> but if you have a constraint like f :: Ord a => a -> String, then it's possible to implement while using a
20:05:56 <gamegoblin> shachaf: what is that operator?
20:06:03 <joelteon> it's from lens
20:06:05 <shachaf> Which Mu is this?
20:06:13 <joelteon> > readHex "c0ffee"
20:06:14 <lambdabot>  [(12648430,"")]
20:06:15 <lispy> shachaf: the type level fixed point
20:06:15 <shachaf> gamegoblin: lens nonsense
20:06:20 <joelteon> use readHex
20:06:22 <joelteon> it's from Numeric
20:06:32 <shachaf> lispy: Which one?
20:06:34 <hiptobecubic> > (+) (,)
20:06:35 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
20:06:35 <lambdabot>    arising from a use of ‘M110595818010489386917493.show_M1105958180104893869...
20:06:35 <lambdabot>  The type variable ‘b0’ is ambiguous
20:06:35 <lambdabot>  Note: there are several potential instances:
20:06:35 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
20:06:41 <edwardk> i can never tell if shachaf actually likes lens these days
20:06:49 <lispy> shachaf: I think it's data Mu f = Mu (f (Mu f)), but I typed that from memory.
20:07:34 <shachaf> edwardk: Well. I wouldn't recommend that you install lens and/or make it a dependency of your package just for preview hex.
20:07:50 <shachaf> It's great when you're already using it.
20:07:51 <lispy> shachaf: so then, a type like Mu Maybe, should be self-referential
20:08:01 <hiptobecubic> :t hex
20:08:02 <lambdabot> (Choice p, Applicative f, Integral a) => p a (f a) -> p String (f String)
20:08:05 <shachaf> But I felt a little unhelpful for mentioning it.
20:08:14 <shachaf> lispy: You should call that type Fix instead of Mu.
20:08:19 <hiptobecubic> the hell is that
20:08:40 <lispy> shachaf: that's so many letters!
20:08:48 <shachaf> Mu has another meaning.
20:08:50 <bss03> Because Mu and Nu coincide in Haskell?  So we should just call both of them Fix?
20:08:54 <shachaf> (Actually it has several other meanings.)
20:08:54 <lispy> shachaf: what is mu?
20:09:09 <shachaf> newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r } is the one I like.
20:09:38 <shachaf> Whereas newtype Fix f = Fix { runFix :: f (Fix f) } corresponds exactly to value-level fix.
20:10:25 <edwardk> hiptobecubic: Integral a => Prism' String a
20:10:41 <edwardk> > hex # 12
20:10:42 <lambdabot>  "c"
20:10:46 <edwardk> > "c"^?hex
20:10:48 <lambdabot>  Just 12
20:11:00 <edwardk> lets you do those things and a use a few hundred other combinators on it
20:11:11 <edwardk> > "c" & hex +~ 4
20:11:12 <lambdabot>  "10"
20:11:22 <itunes7897987> "15"
20:11:43 <itunes7897987> quit
20:11:47 <itunes7897987> wtf
20:16:27 <hunt> in Blaze is there any way touse the blaze markup for the templated sections and raw html for others?
20:16:28 <jle`> "c" %~ hex
20:16:52 <hunt> like i am trying to convert a page to blaze but some sections, after conversion, just become silly to try and convert
20:17:05 <hunt> and impossible for the designer to edit
20:17:34 <d1323> :t (&)
20:17:34 <jle`> > "c" & hex %~ even
20:17:35 <lambdabot> a -> (a -> b) -> b
20:17:35 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Bool)
20:17:35 <lambdabot>    arising from a use of ‘Numeric.Lens.hex’
20:17:49 <jle`> it has to leave it an Int
20:17:51 <jle`> er, Integral
20:17:57 <jle`> because it's a prism
20:18:03 <jle`> of that fixed type?
20:18:20 <jle`> > "c" & hex %~ (`mod` 3)
20:18:22 <lambdabot>  "0"
20:18:30 <edwardk> > "c"^?hex.to even
20:18:32 <lambdabot>  Just True
20:19:30 <shachaf> Is there anything relating to "GCing" pure values that take a lot of memory back to the original uncomputed thunk?
20:19:30 <edwardk> when you use %~ on hex it is trying to decode it into a number (which may fail), then it wants to reencode the number back into a hex string which will always succeed.
20:19:30 <edwardk> with ^? you're just doing the decoding and continuing
20:19:48 <lispy> shachaf: do you have a reference you'd recommend for this Mu/Nu/Fix stuff? I see you have talked about it here before (looking at the irc browse site)
20:19:55 <dmwit> shachaf: No, and also it's bloody hard to hack it together yourself.
20:19:55 <jle`> it like...uses the getter, applies, it and uses the setter (both of fixed input and output)
20:20:00 <edwardk> shachaf: that transformation in general isn't 'work safe'
20:20:04 <dmwit> shachaf: I think Neil Mitchell has a package that sometimes sort of does it.
20:20:11 <shachaf> edwardk: I don't mean in general.
20:20:13 <dmwit> Let me see if I can find the info.
20:20:31 <mhr> I read something that surprised me: Haskell can no longer be totally inferred, and it has gone beyond Hindley-Milner. What parts of Haskell are now no longer inferrable? http://stackoverflow.com/a/3788822 is where I saw that.
20:20:54 <jle`> aren't rank-n types undecidable?
20:21:11 <edwardk> mhr: rank-2+ types, impredicative types, advanced cases with ScopedTypeVariables, let doesn't generalize its arguments
20:21:15 <shachaf> Something like, say, memoization is also not reasonable to do in general, but we can do it explicitly in various ways to get the memory/CPU trade-off in the other direction.
20:21:29 <shachaf> mhr: Even in plain Haskell 98, polymorphic recursion isn't inferrable.
20:21:54 <shachaf> lispy: Write out the isomorphism between Mu/Nu/Fix, see which directions are easy to convert in and which are hard.
20:22:05 <edwardk> mhr: (so MonoLocalBinds), polymorphic recursion,
20:22:11 <edwardk> jle`: yes
20:22:21 <shachaf> lispy: Define Nat as Mu Maybe and Nu Maybe along with some operations.
20:22:22 <lispy> shachaf: I saw that propsed exercise from the logs. Where did you get it?
20:22:23 <dmwit> shachaf: http://stackoverflow.com/q/11675807/791604
20:22:37 <shachaf> lispy: I think the "write the isomorphism" exercise was from edwardk.
20:22:39 <dmwit> shachaf: It was Joachim Breitner, not Neil, who tried to do it.
20:22:49 <jle`> > "c" & hex %~ (+ 3)
20:22:50 <lambdabot>  "f"
20:22:50 <edwardk> lispy: i give Mu/Nu/Fix those 3 names in recursion-schemes
20:22:52 <jle`> neat
20:23:34 <shachaf> dmwit: I think what I was going for is even more complicated, actually.
20:23:37 <hunt> language extensions in ghci?
20:23:46 <shachaf> dmwit: But I think I've seen this post before, now that I look at it. Thanks.
20:23:50 <lispy> edwardk: ah, okay. This is based on the lenses and barbed wire paper?
20:24:08 <edwardk> lispy: the nomenclature for different fixed points goes back farther
20:25:35 <edwardk> http://en.wikipedia.org/wiki/Least_fixed_point (and greatest)
20:25:55 <freakhill> hello
20:25:57 <lispy> thanks
20:26:41 <freakhill> I'm just here to write a minirant about haskell being very difficult to install for me as a beginner. Hopefully it might help.
20:26:42 <edwardk> http://en.wikipedia.org/wiki/Knaster%E2%80%93Tarski_theorem is also useful
20:26:56 <jle`> freakhill: platform install doesnlt work for you?
20:26:57 <edwardk> freakhill: what platform and what did you try?
20:27:04 <freakhill> Centos
20:27:15 <jle`> i don't remember having any toruble installing haskell :|
20:27:17 <edwardk> freakhill: is centos the one stuck in 7.0?
20:27:23 <freakhill> On a centos vm, first there is no haskell in the repositories
20:27:30 <freakhill> so i foudn a repository with 7.0
20:27:38 <freakhill> then i wanted to update to 7.8.2
20:27:42 <freakhill> but the compile crashed
20:27:46 <edwardk> yeah centos is stuck in the stone ages =(
20:28:06 <edwardk> freakhill: if it makes you feel better you are pretty much in a known haskell deadzone
20:28:24 <freakhill> i couldnt find the ghc website link on a 7.4 ghc that 7.8 required for compile
20:28:27 <freakhill> so i googled it
20:28:31 <freakhill> and installed 7.4.1
20:28:35 <freakhill> then 7.8.2
20:28:49 <freakhill> then i download the haskell platform and the compile crashes on opengl
20:29:07 <freakhill> becaus eof a change of interface of Typeable betweeb 7.6.something and 7.8.2
20:29:23 <freakhill> so i try to see if i can do something to update the cabal definition
20:29:27 <freakhill> so i try to update cabal
20:29:34 <freakhill> cabal update cabal cabal-install
20:29:37 <freakhill> and it crashes with
20:29:38 <edwardk> we don't have a platform shipped with 7.8 yet
20:29:48 <edwardk> tryng to build 7.6.3 mght be a better idea
20:30:12 <edwardk> so you went from the stoneage to the near future
20:30:13 <freakhill> "cabal needs http4000" thingie
20:30:19 <freakhill> so i cant update cabal from cabal
20:30:20 <freakhill> :(
20:30:36 <edwardk> freakhill: can you go o he 7.4.1 install you have and try building 7.6.3?
20:30:41 <edwardk> er to the
20:30:52 <freakhill> i'll do that
20:30:53 <edwardk> you should be able to be pretty productive there
20:31:01 <freakhill> just telling that installing on centos is a real pain
20:31:26 <edwardk> i don't know what the story is with centos not having a recent ghc off hand. thoughtpolice might know more
20:31:28 <erisco> okay dmwit, edwardk I have resolved my virtualisation issues and then removed impredicative types from the language options
20:31:45 <edwardk> erisco: success or defeat?
20:31:54 <erisco> error is "illegal polymorphic or qualified type ... perhaps you intended to use rankntypes or rank2types"
20:32:01 <erisco> evidently impredicativetypes made it go away
20:32:10 <freakhill> sorry for just the minirant, back to work, then installing haskell at my next lunchbreak tomorrow!
20:32:13 <edwardk> RankNTypes you will need
20:32:20 <lispy> freakhill: that version of opengl is probably old. I thought we removed the typeable macros from the OpenGL source
20:32:31 <erisco> edwardk, yes if I use rankntypes instead of impredicativetypes it also works
20:32:41 <erisco> but I do not really understand the difference
20:32:46 <erisco> what does polymorphic type mean?
20:32:46 <edwardk> erisco: ok, then that is what you should do =)
20:33:02 <edwardk> rank-n means you can have foralls on the left hand side of (->)'s
20:33:11 <edwardk> (foral a. a -> a) -> b -> b
20:33:34 <edwardk> its a limited form of what you get from ImpredicativeTypes that we can actually reason about
20:33:41 <lispy> freakhill: I recently had to install a recent gcc (4.8.2) on centos 6 and it was a pain. I had to install my own gmp, mpfr, and mpc just to build gcc.
20:34:04 <lispy> freakhill: I think you're likely to need to upgrade your gcc for ghc, but I'm not certain.
20:34:17 <erisco> edwardk, I see, okay, so I just won't worry about the rest of impredicativetypes then
20:34:34 <edwardk> erisco: sounds like a plan
20:34:48 <mhr> Is there a good resource I can read to better understand Haskell's type system (without mathematical symbols)?
20:34:52 <freakhill> lispy: i had some pain with emacs too, but still nothing compared with haskell... it might be nice to have a tool to install from source like ruby does.
20:34:58 <lispy> freakhill: I also had to upgrade binutils, but you may not need to do that.
20:35:16 <erisco> edwardk, well why does it apply to  newtype Page = Page (forall t. Frameworks t => Moment t (Behavior t [Node]))  ?
20:35:18 <lispy> freakhill: recent fedora is much nicer to work with if you can switch
20:35:30 <erisco> there is no arrow there
20:35:42 <lispy> freakhill: much nicer in the sense that it's similar and the package set is much newer
20:35:51 <edwardk> erisco: look at the constructor's type:
20:35:53 <freakhill> lispy: i ll do that if i encounter other problems!
20:35:53 <edwardk> Page :: (forall t. Frameworks t => Moment t (Behavor t [Node]) -> Page
20:36:04 <freakhill> lispy: thanks a lot for your help!
20:36:04 <edwardk> that has a forall t. under the left of the (->)
20:36:12 <lispy> freakhill: yw, good luck!
20:36:13 <erisco> ah it was hiding
20:36:24 <edwardk> erisco: it is clearer if you use GADT syntax.
20:36:48 <edwardk> brb
20:37:04 <erisco> I am not sure why that has different meaning than the implicit forall
20:37:33 <lispy> the implicit one quantifies over the whole type
20:37:50 <lispy> So you can think of it as fixing the value, instantiating the type, and moving on
20:38:05 <erisco> but Page does not reference t
20:38:05 <lispy> When you move it to the left of an arrow it changes when you instantiate the forall.
20:38:34 <edwardk> forall x. x -> Foo is different than (forall x. x) -> Foo
20:39:13 <pingu> I'm trying to do this: http://lpaste.net/103298
20:39:17 <erisco> lispy, when is it instantiated then?
20:39:20 <pingu> But type system failing :(
20:39:28 <pingu> Does anyone know the idiomatic way of doing what I'm trying to do?
20:39:42 <edwardk> the former is a function that takes _any_ x at all and gives you a Foo. the latter s a function that takes something that no matter what x you pick is a member of that x, and gives you a Foo.
20:39:43 <pingu> I totally thought I might be able to get away with that.
20:39:56 <pingu> (GADT related)
20:40:26 <dmwit> pingu: data SomeRequest where SomeRequest :: Request typ -> SomeRequest
20:40:28 <erisco> edwardk, "no matter what x you pick it is a member of that x" I do not understand
20:40:50 <dmwit> pingu: Then: if length str > 42 then SomeRequest (Extended str) else SomeRequest (Simple str)
20:41:40 <pingu> dmwit: awesome, thanks. You've seen it done that way before?
20:41:51 <dmwit> That's a pretty standard trick.
20:42:13 <lispy> erisco: "later" :)
20:42:29 <lispy> erisco: I'm realizing that thinking of it as "when" is not going to help you.
20:43:23 <pingu> dmwit: there's no other way of doing it, is there?
20:43:35 <pingu> other than re-using datatypes like either for two choices
20:44:01 <dmwit> I'm not really sure what "it" is. Probably the answer is "yes, there's another way".
20:44:17 <dmwit> What's the top-level goal?
20:44:31 <mzarella> If the module I loaded into ghci with :load doesn't have a main function, how do I get it to run after setting a break point?
20:44:50 <pingu> dmwit: to have a function mapping from an input to any number of GADT datatypes
20:45:11 <lispy> erisco: are you familiar with the relationship between forall and exists in logic?
20:45:17 <erisco> lispy, yes
20:45:24 <dmwit> I don't really believe that's the top-level goal. =)
20:45:36 <kadoban> mzarella: the same way you get it to run outside of ghci? you need to run something that uses it, or use something in it directly, afaik
20:45:42 <pingu> not sure what you mean by top-level.
20:46:04 <pingu> I'm happy with this solution though. I thought it would be neat if there was an alternative solution is all.
20:46:06 <mzarella> kadoban: interesting
20:46:07 <pingu> I can't think of anyi.
20:46:25 <erisco> forall x. p(x) = ~ exists x. ~p(x)
20:46:40 <lispy> erisco: so, when you have `forall a. a -> a`, that forall is what you're used to. If we move it to be to the left of an ->, then it changes to exists. foo :: (forall a. a -> a) -> Int
20:46:46 <dmwit> Top-level means "what program are you trying to write".
20:47:09 <pingu> dmwit: right, I'm trying to classify incoming network messages based on bits of the payload
20:47:41 <lispy> erisco: I think that's what edwardk was getting at when he said "no matter what x you pick..."
20:48:06 <erisco> lispy, so there exists a type, but we don't know what it is
20:48:12 <lispy> erisco: yup
20:48:50 <erisco> okay, so why is  [forall x. x] impredicative?
20:49:03 <lispy> because x could be [forall x. x]
20:49:32 <erisco> is that exactly what makes it impredicative?
20:50:07 <dmwit> pingu: Okay. Why are you using a GADT? (Instead of, say, two different types?)
20:50:22 <lispy> impredicative means self-referential. In type systems (as we discussed earlier, you might have missed it), that means type variables can be instantiated to a polymorphic type.
20:50:27 <dmwit> Not to say you shouldn't use a GADT.
20:50:43 <erisco> yes and I asked what "polymorphic type" meant because I do not understand it
20:50:57 <lispy> erisco: for this conversation, forall.
20:51:19 <lispy> Type classes are a form of polymorphism but not in the same sense.
20:51:22 <erisco> a forall on the left? ie exists?
20:52:29 <erisco> I mean, forall is implicit everywhere, so what actually is a polymorphic type? are all parametric types polymorphic types?
20:52:46 <pingu> dmwit: I could use different types given the that SomeMessage trick. That had eluded me at the time is all.
20:53:10 <Tekmo> lispy: So if you implement type classes within the language as records then it technically is polymorphism in the same sense
20:53:12 <pingu> dmwit: so I have no reason anymore, other than grouping them into one type seems much cleaner
20:53:19 <dmwit> Right. It can be cleaner.
20:53:30 <lispy> erisco: http://research.microsoft.com/en-us/um/people/simonpj/papers/boxy/boxy-icfp.pdf
20:53:36 <dmwit> But I don't think it will be for that particular type.
20:53:49 <lispy> erisco: It may clear up some confusion if you take a look at that paper
20:54:05 <erisco> okay thanks
20:54:30 <erisco> it just seems confusing that [forall x. x] is impredicative but somehow Page is not
20:55:18 <lispy> I get a bit fuzzy here so I'm afraid to answer (for fear of giving you bad info)
20:55:19 <erisco> what if it was  [forall x. Maybe x]  is that impredicative?
20:55:25 <lispy> I think rank-n is related to impredicativity
20:55:32 <lispy> (but not sure)
20:56:40 <dmwit> erisco: It is impredicative, because the a in [a] has been replaced by a polymorphic type.
20:56:52 <pingu> dwierenga: I suppose the other reason would be that it allows less polymorphism in the SomeRequest type.
20:57:14 <pingu> I.e. if you remove the Request GADT, you can create a non-sensical SomeRequest "POTATO"
20:57:17 <erisco> dmwit, and Page is not impredicative because it has no type variables?
20:57:39 <dmwit> pingu: I'm not sure I understood that.
20:57:41 <erisco> well, not because of that reason alone, but particularly a type variable is not being replaced with a polymorphic type
20:57:48 <dmwit> erisco: right
20:58:08 <erisco> hrm okay well at least this starts to shed some light on things
20:58:11 <pingu> dmwit: well, if data SomeRequest where SomeRequest :: Request typ -> SomeRequest
20:58:22 <dmwit> pingu: Here's a little puzzle for you: what's the difference between Either String String and SomeRequest?
20:58:23 <pingu> became SomeRequest :: typ -> SomeRequest
20:58:39 <dmwit> Yes, you wouldn't want SomeRequest :: typ -> SomeRequest.
20:58:52 <erisco> I will read that paper sometime
20:58:57 <erisco> alright good night. thanks for the help
20:59:02 <lispy> erisco: the part I'm not sure about is whether rank-2 in considered impredicative (not in the haskell extension sense but in the more general usage)
20:59:06 <erisco> and you can remove impredicativetypes now because I no longer need them, hehe
20:59:14 <pingu> dmwit: not sure what I'm getting from your puzzle?
20:59:38 <dmwit> pingu: Did you try to answer it?
21:00:25 <pingu> dmwit: well, yes. I'm still trying to work out what I'm gleaning.
21:00:32 <dmwit> Okay, what's your answer?
21:00:38 <pingu> SomeRequest defined as your first definition?
21:00:43 <dmwit> yeah
21:00:48 <dmwit> And Request as in your paste.
21:01:01 * hackagebot http-kit 0.2.1 - A low-level HTTP library  http://hackage.haskell.org/package/http-kit-0.2.1 (SimonHengel)
21:02:19 <pingu> dmwit: well, very little in terms of it's kind
21:02:59 <pingu> It's a different type though
21:03:00 <dmwit> Okay. Any other way they're different?
21:03:09 <edwardk> erisco: yes
21:03:09 <dmwit> Yes, it's a different type according to the type system.
21:03:15 <dmwit> But I mean, what is the important difference?
21:03:26 <pingu> dmwit: the level of polymorphism?
21:03:31 <dmwit> What does this mean?
21:03:39 <dmwit> What can you do with SomeRequest that you can't do with Either String String?
21:03:46 <pingu> we can range over any Request
21:04:03 <dmwit> pingu: Show me some code of something you can do.
21:04:39 <jle`> show me your moves
21:04:42 <dmwit> (...that seems hard to emulate with Either String String, I mean.)
21:06:05 <pingu> dmwit: do you mean Either ResponseTypeA ResponseTypeB then?
21:06:43 <dmwit> pingu: I don't think that's what I mean.
21:06:52 <dmwit> I don't see ResponseTypeA or ResponseTypeB anywhere in your paste!
21:07:47 <pingu> dmwit: I think I see what you're trying to get at here. The reason I'm trying to use more than an either in my other code is that it's got three types now
21:07:58 <pingu> and soon possibly five
21:08:10 <pingu> I'll paste what I have of that so far...
21:08:43 <pingu> dmwit: http://lpaste.net/103299
21:09:03 <pingu> so that's what I'm actually looking at
21:09:08 <dmwit> Naturally you would want a custom sum type instead of Either.
21:09:26 <dmwit> But what I'm getting at is that you are not using the power of GADTs anywhere that I can see. I'll look at your paste, though.
21:10:15 <dmwit> pingu: Right, so why don't you write processSimple :: ReadDetails -> Daemon (), for example?
21:10:24 <dmwit> And use a sum type instead of SomeRequest?
21:10:39 <pingu> I've not heard of a sum type
21:10:45 <pingu> is that simply something like SomeRequest?
21:10:46 <dmwit> I mean, SomeRequest *is* a sum type. You just have obscured that fact through a bunch of type-system tomfoolery.
21:10:59 <dmwit> pingu: Either is the canonical sum type, but it's easy to make your own. =)
21:11:01 <dmwit> pingu: e.g.
21:11:17 <dmwit> data Request = Simple ReadDetails | Extended ReadDetails | Invalid String
21:11:19 <pingu> dmwit: well, the reason I didn't do that was that I wanted to clearly differentiate at the type level between a simple message and an extended one
21:11:25 <pingu> right. Okay.
21:12:08 <dmwit> pingu: Why do you want that?
21:12:09 <pingu> dmwit: I'm not sure anymore ;)
21:12:42 <jle`> i always get this weird sinking feeling when iintroduce an error and the compiler/typechekcer doesn't catch it
21:13:01 <Ralith> iy means your types aren't specific enough!
21:13:03 <Ralith> it*
21:13:11 <jle`> yeah :/
21:13:15 <dmwit> pingu: I mean, I get the idea in principle.
21:13:23 <jle`> well i wrote an improper Binary instance (a bad Put)
21:13:35 <dmwit> pingu: But if what you're going to do with it is turn around and use SomeRequest everywhere, it sort of seems like it defeats that purpose.
21:13:38 <pingu> dmwit: I don't see how I can get the same level of type safety from what you are suggesting
21:14:16 <dmwit> pingu: Okay. What piece of type safety do you seem to be missing, in your opinion?
21:14:26 <albeit> If I need to parse a message of say 300 bytes, with a specific, guaranteed, format (ie first four bytes compose an integer, next is a char, next 4 and 4 are the exponent and mantissa of a real, etc...), how close to I get the performance of optimized C?
21:14:38 <albeit> *can I get
21:14:46 <pingu> dmwit: in the individual request handlers. processExtended has type Request Extended -> Daemon ()
21:15:08 <pingu> changing that to ReadDetails would allow me to pass a Simple message to the same function
21:15:23 * dmwit nods agreeably
21:15:37 <dmwit> That's true.
21:15:40 <pingu> dmwit: I was hoping to handle the sum type once, in handleRequest
21:15:43 <lispy> albeit: if you directly used bytestring for that you should be totally on par with optimized C. If you went up a tiny bit in abstraction to cereal then I would still expect it to be comparable to C (probably just as fast as the bytestring)
21:15:50 <pingu> where it is classified once, in classifyMessage
21:16:55 <dmwit> pingu: It's definitely something to hope for.
21:16:59 <albeit> lispy: Good to know, thanks
21:17:02 <pingu> dmwit: I could do the same thing without GADTs and just a phantom type, certainly.
21:17:10 <pingu> I just think the GADTs look cleaner
21:17:13 <dmwit> pingu: Just watch out to make sure you aren't doing a test, putting a constructor on, and immediately taking the constructor off to pass it somewhere.
21:17:48 <dmwit> pingu: If you find that's what your code looks like, you should consider just doing the test and passing it on instead. That's all I'm saying.
21:17:53 <dmwit> But maybe it won't!
21:18:02 <pingu> dmwit: okay, I get what you're saying. thanks.
21:18:03 <dmwit> Maybe you'll pass non-SomeRequest things around.
21:18:24 <orion> How come the Maybe monad is referred to as "Monad Maybe", but the Either monad is referred to as "Monad (Either e)"?
21:18:37 <orion> Shouldn't the Maybe monad be referred to as "Monad Maybe a"?
21:18:51 <lispy> orion: it has to do with the kinds
21:18:56 <lispy> :k Maybe
21:18:57 <lambdabot> * -> *
21:19:00 <lispy> :k Maybe a
21:19:01 <lambdabot> Not in scope: type variable ‘a’
21:19:07 <lispy> :k Either Int
21:19:08 <lambdabot> * -> *
21:19:15 <lispy> :k Maybe Int
21:19:16 <lambdabot> *
21:19:27 <lispy> orion: Haskell's monads are always kind * -> *
21:20:01 <orion> weird
21:21:39 <jle`> orion: think about the function return :: a -> m a
21:21:45 <jle`> orion: this makes sense for m ~ Maybe
21:21:49 <jle`> a -> Maybe a
21:21:56 <jle`> this doens't make any sense for m ~ Maybe a
21:22:01 <jle`> a -> Maybe a a
21:22:09 <jle`> this doesn't make sense for m ~ Either
21:22:10 <jle`> a -> Either a
21:22:16 <jle`> but it does make sense for m ~ Either e
21:22:18 <jle`> a -> Either e a
21:25:39 <orion> > let x = Right 'x' :: Either Int Char
21:25:40 <lambdabot>  not an expression: ‘let x = Right 'x' :: Either Int Char’
21:26:21 <Ralith> > Right 'x' :: Either Int Char
21:26:23 <lambdabot>  Right 'x'
21:26:25 <orion> :/
21:27:26 <orion> So, let's say I've done: let x = Right 'x' :: Either Int Char
21:27:42 <orion> let y = do { return x; } -- What's the type signature supposed to be?
21:28:12 <jle`> @undo do { return x; }
21:28:12 <lambdabot> return x
21:28:35 <jle`> well it's supposed to be...whatever you want it to be?
21:28:39 <jle`> :t monad
21:28:40 <lambdabot> Not in scope: ‘monad’
21:28:42 <jle`> :t return
21:28:43 <lambdabot> Monad m => a -> m a
21:28:52 <jle`> so return x is something of type m a, where x :: a
21:29:07 <johnw> correct
21:29:09 <orion> jle`: Assuming I defined x as above.
21:29:15 <enthropy> it'll help to be more concrete
21:29:17 <orion> Either Int Char
21:29:35 <jle`> return (Right 'x') :: Monad m => m (Either Int Char)
21:30:39 <orion> Oh, Either isn't a Monad?
21:30:49 <orion> wait
21:30:52 <dmwit> (Either e) is a Monad for any e.
21:31:00 <dmwit> That's how the conversation got started in the first place. ;-)
21:31:07 <dmwit> well
21:31:27 <dmwit> (Either e) is a monad for any e. And it's probably a Monad for any e in some appropriate type class.
21:31:54 <jle`> orion: remember the type of return
21:32:00 <jle`> it just wraps what it is given inside that monad
21:32:05 <jle`> but
21:32:10 <jle`> > return 'c' :: Either Int Char
21:32:11 <lambdabot>  Right 'c'
21:32:21 <orion> That's what I was trying to do...
21:32:35 <enthropy> there isn't any automatic flattening of nested Eithers
21:33:02 <orion> Ok, this makes sense now.
21:33:07 <orion> Thank you.
21:33:14 <jle`> but you do have join
21:33:20 <jle`> join :: m (m a) -> m a
21:33:36 <jle`> and if m ~ Either Int, the join :: Either Int (Either Int a) -> Either Int a
21:36:05 * hackagebot fgl 5.5.0.1 - Martin Erwig's Functional Graph Library  http://hackage.haskell.org/package/fgl-5.5.0.1 (IvanMiljenovic)
22:37:27 <Yoctogon> anyone have any programming project ideas for practicing with haskell?
22:37:50 <Yoctogon> the only thing i can think of, is a basic IRC bot
22:40:24 <Yoctogon> not having any good ideas for things to program is what tends to make me lose interest in haskell
22:40:33 <AshyIsMe> vindinium was fun
22:40:44 <AshyIsMe> http://vindinium.org/
22:40:53 <AshyIsMe> you make ai bots to fight in the arena
22:40:57 <Yoctogon> hmm
22:41:00 <AshyIsMe> there's a haskell template on github to start with
22:41:21 <dmwit> haskell_proposals.reddit.com
22:41:50 <dmwit> Or write a shell.
22:41:54 <Yoctogon> oh, huh, that's a thing
22:41:54 <dmwit> Or invent a language.
22:42:20 <dmwit> Or check out the GSOC Trac.
22:42:37 <dmwit> Run through Project Euler or another programming contest.
22:42:42 <dmwit> Make an IRC bot.
22:43:06 <dmwit> Think of some annoyance you have on your computer and automate it.
22:43:22 <Yoctogon> i've solved 33 problems in PE already with haskell, basically the last resort when i don't have anything else
22:43:22 <dmwit> ...I usually have more ideas than time. =P
22:43:25 <itsmonktastic> if there's nothing you want to program, maybe do something else entirely :P
22:43:50 <dmwit> You could help me write a program to merge gnome keyrings.
22:43:55 <dmwit> It's a pretty simple file format.
22:44:03 <Yoctogon> but it's so annoying, since haskell is interesting in and of itself, but it's hard to make progress without applications
22:44:45 <Yoctogon> yeah, i'll just do the IRC bot for now
22:47:02 <Yoctogon> i used to be much better at generating ideas for things to program-- before i became more mathematically/abstractly inclined
22:47:48 <ski> edwardk : btw, would you know what an "MP solver" is (mentions in the same sentence as "SAT solver") ?
22:47:48 <jle`> Yoctogon: i have an IRC bot written in FRP/automation/declarative syntax if you want
22:47:55 <ski> monochrom : "it's the poster boy of MonadFix" -- do you mean Levent Erkök ? or perhaps Magnus Carlsson ?
22:48:06 <jle`> Yoctogon: um. my first major project as a numerical simulation, calculating some physics stuff
22:48:09 <ski> merijn : "I'm thinking it might be better to track function inputs and "replay" after changing code, but still that does not interact with IO in a nice way"
22:48:11 <jle`> my second major project was my blog engine
22:48:27 <ski> merijn : that sounds like adaptive/incremental computation
22:48:42 <ski> merijn : see "Adaptive Functional Programming" by Umut Acar,Blelloch,Harper (2002,POPL at <http://www.umut-acar.org/publications/popl2002.pdf>, 2006,TOPLAS at <http://www.umut-acar.org/publications/toplas2006.pdf>)
22:48:59 <ski> merijn : and also "Monads for Incremental Computing" (Functional Pearl) by Magnus Carlsson in 2002 at <http://www.carlssonia.org/ogi/papers/icfp-2002.pdf>,<http://www.carlssonia.org/ogi/Adaptive/>,<http://hackage.haskell.org/package/Adaptive>
22:49:03 <ski> augur : not sure i see why it would be more like a presupposition in a language like ruby ..
22:52:19 <hunt> guys
22:52:20 <hunt> crisis
22:52:27 <hunt> im using Blaze html5 temlpating
22:52:36 <hunt> and i have OverloadedString enabled
22:52:51 <hunt> but when i try and pass an ambiguous IsString a into li
22:52:53 <hunt> it errors
22:53:10 <dmwit> so... disambiguate it?
22:53:11 <hunt> saying it cant equate IsString a ~ Html
22:53:48 <dmwit> uh
22:53:58 <dmwit> I suspect you're not being precise and/or using the wrong words in a few places.
22:54:02 <hunt> but it should work
22:54:05 <dmwit> Could you post some exact code/error messages somewhere?
22:54:08 <dmwit> e.g. lpaste
22:54:10 <hunt> yea ok
22:54:39 <jle`> you are probaly using a string literal where an Html is expected
22:54:51 <jle`> there is a Text -> Html function
22:54:55 <jle`> um
22:54:59 * jle` digs around
22:55:41 <hunt> relevant info and code and errors
22:55:42 <hunt> http://lpaste.net/103301
22:55:48 <jle`> hm.
22:55:56 <jle`> no wait Html already is an IsString
22:55:58 <hunt> yea
22:56:05 <hunt> so i thought this would work
22:56:06 <hunt> oh wait
22:56:07 <hunt> im silly
22:56:13 <hunt> all IsStrings are not alike
22:56:15 <hunt> eh?
22:56:22 <hunt> so i should just use Html
22:56:57 <hunt> correct?
22:57:13 <jle`> hunt: you use ptitle, pinfo, etc.
22:57:21 <jle`> in class_
22:57:31 <jle`> er, in div
22:57:38 <jle`> but div only takes Html
22:57:44 <jle`> it doesn't take a generic IsString
22:57:55 <jle`> that's like saying
22:58:07 <hunt> all black people are the same
22:58:08 <jle`> > let foo :: Eq a => a; foo = 1 in foo
22:58:09 <lambdabot>  Could not deduce (GHC.Num.Num a1) arising from the literal ‘1’
22:58:09 <lambdabot>  from the context (GHC.Classes.Eq a)
22:58:09 <lambdabot>    bound by the inferred type of it :: GHC.Classes.Eq a => a
22:58:09 <lambdabot>    at Top level
22:58:09 <lambdabot>  or from (GHC.Classes.Eq a1)
22:58:09 <hunt> im being a haskell racist
22:58:19 <jle`> you can't say foo works for all Eq a
22:58:19 <hunt> im sorry gods of haskell
22:58:22 <hunt> thanks jle`
22:58:27 <jle`> and yet use it as a Num
22:58:30 <jle`> what are you, a liar?
22:58:44 <jle`> > let foo :: Eq a => a; foo = True in foo
22:58:45 <lambdabot>  Could not deduce (a1 ~ GHC.Types.Bool)
22:58:45 <lambdabot>  from the context (GHC.Classes.Eq a)
22:58:45 <lambdabot>    bound by the inferred type of it :: GHC.Classes.Eq a => a
22:58:45 <lambdabot>    at Top level
22:58:45 <lambdabot>  or from (GHC.Classes.Eq a1)
22:58:45 <hunt> i never lie
22:59:08 <jle`> so you say foo works for all Eq a => a, but then clearly a has to be a Bool
22:59:22 <jle`> what you can do to make it work is instead of using pstring directly
22:59:31 <jle`> you can use (fromString ptitle)
22:59:42 <jle`> er no
23:00:07 <jle`> actually you can't do anything
23:00:23 <jle`> to make it work with that type signature and what you want to do
23:00:37 <jle`> what's wrong with Post Html -> Html ?
23:01:06 <hunt> jle` yea im going to change it
23:01:12 <hunt> i was just being an idiot
23:01:24 <hunt> but its 2am so i forgive mysefl
23:01:31 <jle`> also i'm not totally sure why you want to parameterize Post, but i don't know your total use case
23:02:21 <hunt> jle` what do you mean by parametrize? you mean have functions for _ptitle ...?
23:02:35 <hunt> oh
23:02:38 <hunt> i wanted to parametrize it
23:02:44 <hunt> so i could use the IsString class
23:02:45 <jasonjckn> fmap and >>= seem almost identical, why is >>= so much more powerful generally speaking?
23:02:48 <hunt> instead of giving hard types
23:02:51 <hunt> to each of the fields
23:03:22 <jle`> hunt: yeah that's what i mean
23:03:37 <jle`> jasonjckn: hm.  >>= can do things fmap can't
23:04:06 <jasonjckn> jle`: for example >>= let's you alter the parser state in parsec, but not fmap?
23:04:19 <jasonjckn> because of the a -> M b intsead of a -> b
23:04:32 <jle`> yeah, if you fmap an a -> m b
23:04:37 <jle`> you get m (m b)
23:04:48 <jle`> do note that >>= is as powerful as fmap + join
23:04:53 <jle`> join :: m (m b) -> m b
23:04:57 <jasonjckn> ah
23:05:05 <jle`> the join is what fmap is lacking
23:05:17 <jasonjckn> thanks
23:05:21 <jle`> and what Functors in general cannot do
23:05:25 <dmwit> > 1680/7
23:05:27 <lambdabot>  240.0
23:05:36 <ReinH> well, also return
23:06:03 <jle`> ah yeah.  well, specifically in regards to >>= vs fmap and why fmap can't copy >>= alone
23:06:31 <ReinH> I'm actually not sure why Functor doesn't include pure/return
23:06:41 <jle`> Pointed
23:06:44 <ReinH> I know
23:06:47 <ReinH> but functors map objects
23:06:51 <ReinH> as well as arrows
23:06:54 <jle`> hm.
23:07:52 <jle`> well the functor laws (coming from math) do not say anything about return
23:08:12 <jle`> i think functor just basically implies a meaningful fmap
23:08:15 <jle`> and nothing more
23:08:27 <ReinH> A functor F : C -> D assigns each object X in C an object F(X) in D
23:08:28 <ReinH> that's return
23:09:01 <ReinH> it also assigns each morphism f : X -> Y in C a morphism F(f) : F(X) -> F(Y) in D
23:09:04 <ReinH> that's fmap
23:09:07 <supki> ReinH: type constructor maps objects
23:09:10 <jle`> ah
23:09:16 <supki> point is something different
23:09:20 <ReinH> supki: but it isn't generalized
23:09:56 <ReinH> it's not a part of the Functor class
23:10:40 <ReinH> That always struck me as odd
23:10:47 <jle`> if that's what a functor is
23:10:52 <jle`> then it makes sense to have return
23:10:54 <jle`> what gives
23:10:55 <itsmonktastic> I don't understand "that's return"
23:11:30 <itsmonktastic> objects would be e.g. Int, Char etc. So IO is a functor because it maps each object like, Int to IO Int, Char to IO Char, I think?
23:11:49 <ReinH> IO is a Functor because it implements fmap
23:12:16 * shachaf sighs
23:12:44 <itsmonktastic> ReinH: yes, that's the second part
23:12:44 <shachaf> Anyway, itsmonktastic is correct.
23:13:31 <ReinH> Ah, you need the type constructor, not the data constructor
23:13:44 <itsmonktastic> the point is that the first part you mentioned isn't about return. I've not found the classical category theory definition that useful when writing haskell code, tbh.
23:13:44 <ReinH> since objects are types, not values
23:13:48 <itsmonktastic> yeah
23:13:54 <ReinH> ok never mind then
23:14:07 <ReinH> shachaf: instead of sighing, just tell me something constructive
23:14:09 <ReinH> this is getting frustrating
23:16:05 <corgifex> ooh, you're the constructive/frustrating guy
23:16:16 <ReinH> corgifex: ?
23:16:40 <shachaf> ReinH: I agree.
23:16:59 <ReinH> shachaf: I promise I'm not making mistakes just to annoy you
23:18:08 <hunt> how do i import a module from the local directory? I have a file with "module Templates.Blaze.Essentials where" at the top but in an adjacent file when i try to "import Templates.Blaze.Essentials" i get could not find module
23:18:53 <dmwit> supki gave the answer. The type that is an instance of Functor *is* the object-level map.
23:19:02 <ReinH> dmwit: Yes, I understand.
23:19:02 <dmwit> return does not correspond to an object-level map in that way.
23:19:10 <dmwit> Oh. Then I am the one that doesn't understand.
23:19:21 <shachaf> Yes, supki is also correct (before I started reading).
23:19:42 <ReinH> dmwit: I made a mistake. A couple people were nice enough to correct me.
23:19:49 <pavonia> hunt: In what directory are these modules?
23:19:50 <dmwit> oh, great!
23:20:17 <hunt> theyre in a directory called "templates" (lower case) pavonia
23:20:33 <dmwit> hunt: module Foo.Bar.Baz should be in a file named Foo/Bar/Baz.l?hs
23:21:17 <hunt> whats the .l?
23:21:34 <kadoban> .lhs is literate haskell
23:21:42 <hunt> oh ok
23:21:46 <kadoban> (comments and code reversed, you have to mark code)
23:26:54 <_flatline_> What is the safest way to get the last element of a list?
23:26:59 <_flatline_> Apparently using "last" is unsafe
23:27:34 <pavonia> > listToMaybe . reverse $ [1,2,3]
23:27:36 <lambdabot>  Just 3
23:27:39 <pavonia> > listToMaybe . reverse $ []
23:27:40 <lambdabot>  Nothing
23:27:57 <opqdonut> I don't think the simplest safe way is implemented in the standard library, but it's "safeLast :: [a] -> Maybe a; safeLast [] = Nothing; safeLast [x] = Just x; safeLast (_:xs) = safeLast xs"
23:28:11 <opqdonut> listToMaybe . reverse works too as you just saw
23:28:24 <opqdonut> and because of laziness it's not even that slow
23:29:28 <_flatline_> awesome thanks
23:31:21 * hackagebot modulespection 0.1.1.0 - Template Haskell for introspecting a module's declarations  http://hackage.haskell.org/package/modulespection-0.1.1.0 (JonathanFischoff)
23:36:22 * hackagebot lens-family-th 0.3.0.0 - Generate lens-family style lenses  http://hackage.haskell.org/package/lens-family-th-0.3.0.0 (DanBurton)
23:46:23 * hackagebot modulespection 0.1.2.0 - Template Haskell for introspecting a module's declarations  http://hackage.haskell.org/package/modulespection-0.1.2.0 (JonathanFischoff)
23:46:25 * hackagebot text 1.1.1.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.1.1.0 (BryanOSullivan)
23:51:24 * hackagebot find-conduit 0.4.0 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.4.0 (JohnWiegley)
23:51:26 * hackagebot modulespection 0.1.2.1 - Template Haskell for introspecting a module's declarations  http://hackage.haskell.org/package/modulespection-0.1.2.1 (JonathanFischoff)
23:54:50 <ReinH> > foldl (const Just) Nothing [1,2,3] -- or as a fold :)
23:54:52 <lambdabot>  Just 3
23:56:24 * hackagebot text 1.1.1.1 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.1.1.1 (BryanOSullivan)
