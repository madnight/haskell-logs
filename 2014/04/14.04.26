00:01:30 <jakex> > "123\0457"
00:01:31 <lambdabot>  "123\457"
00:01:52 <jakex> > "123\0 457"
00:01:53 <lambdabot>  "123\NUL 457"
00:02:27 <corgifex> > "123\0\&457"
00:02:29 <lambdabot>  "123\NUL457"
00:23:29 <SrPx> Is there a way to match multiple values in a single spot? For example, fun (1 or 2 or 3 as x) = x . Obviously not like that... probably like with aliases or something on the type level?
00:23:50 <haasn> fun x | x `elem` [1,2,3] = ...
00:23:58 <haasn> or fun x | x < 4 -- if that works
00:24:53 <SrPx> haasn: but isn't that going to be problematic, as it will match numbers that are not 1 2 3, thus overshadowing other functions which could match 4, 5 etc?
00:25:17 <Cale> SrPx: hm?
00:25:40 <Cale> Why will it match things which aren't 1, 2 or 3?
00:25:47 <SrPx> fun x | x < 4 = x; fun 4 = 8; what will be the output of fun 4?
00:26:03 <haasn> > let fun x | x < 4 = x; fun 4 = 8 in fun 4
00:26:04 <lambdabot>  8
00:26:12 * SrPx shrugs
00:26:29 <haasn> SrPx: If the condition of the guard is false, you move on to the next clause/pattern
00:26:41 <SrPx> okay, cool (:
00:27:08 <SrPx> > let fun x = case x of 1 -> 2; fun 2 = 4 in fun 2
00:27:10 <lambdabot>  <hint>:1:31: Parse error in pattern: fun
00:27:24 <haasn> case { x of 1 -> 2 };
00:27:33 <haasn> But that will be a pattern match exception
00:27:35 <SrPx> > let fun x = case { x of 1 -> 2 }; fun 2 = 4 in fun 2
00:27:36 <lambdabot>  <hint>:1:18: parse error on input ‚Äò{‚Äô
00:27:39 <haasn> oh?
00:27:39 <SrPx> u.u
00:27:44 <haasn> err
00:27:47 <haasn> case x of { 1 -> 2 };
00:27:59 <SrPx> > let fun x = case x of { 1 -> 2 }; fun 2 = 4 in fun 2
00:28:00 <lambdabot>  *Exception: <interactive>:3:13-32: Non-exhaustive patterns in case
00:28:08 <SrPx> so it is not the sabe as
00:28:18 <SrPx> > let fun x | x == 1 = 2; fun 2 = 4 in fun 2
00:28:19 <lambdabot>  4
00:28:23 <SrPx> interesting
00:28:26 <SrPx> thanks
00:28:30 <haasn> that one is the same as fun 1 = 2; fun 2 = 4
00:28:40 <SrPx> uh huh
00:28:49 <SrPx> so you can guard anything
00:28:51 <haasn> (because that's how pattern matches on numeric literals get translated)
00:29:10 <SrPx> and guards are essentially not syntax sugards for functions that return case expressions, I see.
00:29:23 <haasn> > case 4 of x | x < 4 -> 1; 4 -> 8
00:29:25 <lambdabot>  8
00:29:41 <haasn> SrPx: they are, but in a different way - you need to translate all of the rules of the function at the same time
00:29:56 <nisstyre> > case 8 of x | x < 4 -> 1; 4 -> 8
00:29:56 <no-n> > let (xxs@(x:xs),_) = ([1,2,3],"hello") in xxs
00:29:57 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
00:29:58 <lambdabot>  [1,2,3]
00:30:01 <haasn> See the haskell report for the full desugaring rules
00:30:02 <ski> SrPx : sorry, no disjunctive patterns ("or-patterns") in Haskell :(
00:30:05 <SrPx> I see, that explains it
00:30:06 <nisstyre> always make your case expressions total kids
00:30:36 <SrPx> no-n: ?
00:30:40 <SrPx> ski: what?
00:30:46 <wombawomba> I'm looking for a function equivalent to http://clojuredocs.org/clojure_core/clojure.core/partition in haskell, but I can't seem to find one. Is there one? Otherwise, what's a good way to write one?
00:30:48 <no-n> what
00:31:01 <no-n> oh i was just seeing if you could do that
00:31:04 <no-n> unrelated sorry
00:31:18 <nisstyre> :t partition
00:31:19 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
00:31:41 <nisstyre> probably not what you wanted I gather?
00:32:47 <ski> (Ocaml has them <http://caml.inria.fr/pub/docs/manual-ocaml-4.01/patterns.html#sec108>. and Successor ML <http://web.archive.org/web/20120730114550/http://successor-ml.org/index.php?title=Disjunctive_patterns>)
00:33:22 <SrPx> nisstyre: yes but still
00:33:51 <nisstyre> wombawomba: Data.List.Split.splitEvery
00:33:53 <nisstyre> http://hackage.haskell.org/package/split-0.1.1/docs/src/Data-List-Split-Internals.html#splitEvery
00:34:00 <klugez> wombawomba: http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split-Internals.html#v:chunksOf probably gives the simple case if I understood right.
00:34:52 <nisstyre> also for some reason that did not show up when I hoogled
00:35:02 <SrPx> data Foo = A Int | B Int | C Int; fun (A x) = 7; fun (B x) = 7; fun (C x) = 7; is there a way to fuse those into one as the result is the same? fun (c x) | c `elem` [A,B,C] = 7 won't work
00:36:43 <ski> SrPx : one could write `let foo ((1 | 2 | 3) as x) = x' in OCaml, and `fun (x as (1 | 2 | 3)) = x' in Successor ML
00:36:50 <wombawomba> thanks!
00:37:26 <SrPx> oh I see
00:37:31 <SrPx> nothing like that in haskell, then?
00:38:15 <ski> <http://rosettacode.org/wiki/Pattern_Matching#OCaml> has a more advanced example of using them in OCaml
00:38:22 <ski> SrPx : unfortunately not
00:38:48 <ski> (er, `fun foo (x as (1 | 2 | 3)) = x' in Successor ML)
00:39:04 <SrPx> okays
00:40:04 <SrPx> writting in successor ML must be a lot of fun
00:40:18 <SrPx> C: ill go sleep now
00:47:06 <jle`> is STM built on normal ghc primitives
00:47:08 <jle`> ?
00:47:11 <jle`> or is it magical
00:56:06 <copumpkin> jle`: you'll find the STM-related primitives in here: http://www.haskell.org/ghc/docs/7.8.2/html/libraries/ghc-prim-0.3.1.0/GHC-Prim.html
00:56:13 <copumpkin> just search for things with STM in their name
00:56:23 <copumpkin> everything else is built on top as a standard haskell library
00:57:05 <jle`> so there is magic
00:57:07 <jle`> darn
00:57:40 <startling> I don't understand why there needs to be.
00:57:47 <copumpkin> I'd imagine you could simulate it in Haskell, but it'd probably be less efficient
00:57:53 <startling> Yeah.
00:57:57 <startling> I think IO would be hard, too.
00:58:06 <copumpkin> there are papers on it iirc
00:58:10 <copumpkin> from a few years back
01:01:20 * hackagebot scat 1.1.0.0 - Generates unique passwords for various websites from a single password.  http://hackage.haskell.org/package/scat-1.1.0.0 (RomainEdelmann)
01:08:05 <certainty> ok i can't get this to work. http://lpaste.net/103222 I just don't find a way to implement runVMWith. Anyone cares to have a look? I will definitely read up on monadtransformers this evening
01:19:16 <supki> :t \r s m -> runRWST (runErrorT m) r s
01:19:17 <lambdabot> r -> s -> ErrorT e (RWST r w s m) a -> m (Either e a, s, w)
01:19:23 <supki> :t \r s m -> runErrorT (runRWST m r s)
01:19:24 <lambdabot> r -> s -> RWST r w s (ErrorT e m) a -> m (Either e (a, s, w))
01:20:18 <jle`> b 12
01:20:22 <jle`> sorry
01:37:38 <certainty> supki: thanks! I went for runRWST (runErrorT (runVM vm)) program state .. one reason it didn't work earlier was a typo in my code, which i didn't see :/
01:53:20 <no-n> @hoogle EitherT
01:53:20 <lambdabot> package EitherT
01:53:29 <no-n> wot
01:55:44 <no-n> :r ReaderT
01:55:54 <no-n> :t ReaderT
01:55:54 <lambdabot> (r -> m a) -> ReaderT r m a
01:56:08 <no-n> :t StateT
01:56:09 <lambdabot> (s -> m (a, s)) -> StateT s m a
01:56:39 <Phillemann> Is anyone using inf-haskell? Not sure how it's supposed to be used in a project with cabal and multiple source files.
01:59:44 <startling> Phillemann, haskell-process is the new thing that people are very slowly moving to
02:00:00 <Phillemann> Ah, didn't know that
02:00:11 <startling> Phillemann: (it's also distributed as part of haskell-mode)
02:07:26 <no-n> :k ReaderT
02:07:27 <lambdabot> * -> (* -> *) -> * -> *
02:11:29 * hackagebot hcltest 0.3 - A testing library for command line applications.  http://hackage.haskell.org/package/hcltest-0.3 (BennoFuenfstueck)
02:12:13 <corgifex> imagine speed-upgraded zerglings sitting outside your natural expo: S Z :: Nat
02:12:48 <tomejaguar> I can't "cabal install" haddock because of #if __GLASGOW_HASKELL__ == 709 in InterfaceFile.hs.  What's going on?
02:14:03 <merijn> tomejaguar: Your haddock is too old or new for your GHC
02:14:16 <tomejaguar> So how do I locally build haddocks?
02:14:29 <tomejaguar> I mean the documentation for a particular cabal package.
02:14:40 <merijn> wait
02:14:48 <merijn> You were doing "cabal install haddock"?
02:14:53 <tomejaguar> Yes
02:14:57 <merijn> You can't
02:15:01 <merijn> haddock ships with GHC
02:15:19 <tomejaguar> Oh I see.  It's called haddock-ghc-7.6.3 on my system
02:15:34 <merijn> The install should've made a symlink for it...
02:16:12 <startling> Why would is there an instance TraversableWithIndex i f => TraversableWithIndex [i] (Free f) somewhere?
02:16:16 <merijn> This is the 3rd time I see someone trying to manually install haddock, did some linux distro break it again?
02:16:16 <startling> blegh, mispaste
02:16:23 <tomejaguar> Oh I guess I didn't install it properly.
02:16:32 <tomejaguar> Thanks.
02:16:42 <startling> why would that instance need UndecidableInstances?
02:17:10 <startling> I get "Reason: lhs type ‚ÄòFree f‚Äô does not determine rhs type ‚Äò[i]‚Äô", but don't FunDeps provide that?
02:17:43 <merijn> startling: You use fundeps to unbreak the enabling of undecidableinstances to make that work
02:17:57 <merijn> startling: I don't think fundeps make sense without undecidableinstances?
02:18:02 <merijn> Not sure, though
02:18:19 <startling> oh, hm.
02:19:40 <tomejaguar> How do I get " to appear in Haddock without having it assume that it surrounds an identifier name?
02:20:14 <startling> @pl (f . (:) i)
02:20:14 <lambdabot> f . (i :)
02:20:32 <startling> @pl map (f . (:) i)
02:20:32 <lambdabot> map (f . (i :))
02:20:36 <tomejaguar> It assumes "quit" is a module called quit.
02:20:49 <startling> @pl imap (\i -> f . (:) i)
02:20:49 <lambdabot> imap ((f .) . (:))
02:21:01 <startling> @pl imap (\i -> imap (f . (:) i))
02:21:01 <lambdabot> imap (imap . (f .) . (:))
02:21:06 <tomejaguar> Oh \".  That was easy.
02:46:18 <jen412> what does the operator ** does? I can't find it anywhere...
02:47:05 <Maior> :t (**)
02:47:06 <lambdabot> Floating a => a -> a -> a
02:47:24 <startling> > 10 ** 2
02:47:26 <lambdabot>  100.0
02:47:50 <steshaw1> > 2 ** 3
02:47:51 <lambdabot>  8.0
02:47:54 <startling> jen412: it's exponentiation. This may help: http://www.haskell.org/haskellwiki/Power_function
02:48:04 <jen412> oh right thanks!
02:53:50 <startling> Is there a package of bounded numbers out there somewhere?
02:54:36 <startling> I mean types that would be called e.g. "Fin 8" in a dependently-typed languages.
03:06:35 * hackagebot timeout 0.1.0 - Generalized sleep and timeout functions  http://hackage.haskell.org/package/timeout-0.1.0 (FedorGogolev)
03:07:39 <simukis_> Can somebody explain me why `(<**>)` is `liftA2 (flip ($))` and not `(<**>) = flip (<*>)`?
03:08:05 <startling> :t (<**>)
03:08:06 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
03:08:17 <startling> :t ((<*>) .) fmap flip
03:08:18 <lambdabot> ((a -> a1 -> b -> c) -> a) -> (a -> a1 -> b -> c) -> b -> a1 -> c
03:08:46 <simukis_> > :t flip (<*>)
03:08:47 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
03:08:57 <corgifex> simukis_: presumably because <**> is more useful
03:09:09 <startling> yeah, I'm not sure flip (<*>) is worthwhile
03:09:11 <corgifex> when would you need flip (<*>)?
03:09:24 <startling> :t ((<*>) .) . fmap flip
03:09:25 <lambdabot> (a -> a1 -> b1 -> b) -> a -> (b1 -> a1) -> b1 -> b
03:09:34 <startling> hm, no, that's not it either.
03:09:40 <simukis_> I‚Äôm just wondering as comment above says `-- | A variant of '<*>' with the arguments reversed.`.
03:09:57 <corgifex> arguments reversed, but not order of effects
03:10:05 <startling> simukis_: oh.
03:10:15 <startling> simukis_: it may help to realize that <*> induces an order of evaluation
03:10:38 <startling> or, it can.
03:10:55 <simukis_> I see. Thanks, corgifex.
03:11:14 <startling> simukis_, consider print <*> getLine
03:11:34 <corgifex> :t (putStrLn "A" >> return 21) <**> (putStrLn "B" >> return (* 2))
03:11:35 <lambdabot> Num b => IO b
03:12:13 <startling> oh, I've got a type error
03:12:15 <simukis_> startling: yes, I know, it just wasn‚Äôt obvious when I first saw it.
03:12:32 <corgifex> this is also why <* isn't just flip (*>)
03:12:51 <startling> yeah.
03:13:02 <corgifex> (<* is so useful in parsing I had to invent it myself before I knew Applicative)
03:13:14 <startling> corgifex, did you call it >> ?
03:13:23 <startling> or rather (<<)
03:13:58 <corgifex> <<, yes
03:14:05 <corgifex> and then people complained that it wasn't flip (>>)
03:14:18 <startling> heh
03:14:36 <corgifex> peoplewhatabunchofbastards.gif
03:16:49 <startling> I guess (=<<) confuses things
03:57:05 <agreco> is the online version of learnyouahaskell worth pursuing over the paperback? Online version seems to have slight more content in its chapters..
03:59:54 <jle`> fwiw i read the online version
04:00:44 <quchen> I don't think the difference is enough to prefer one over the other, compared to whether you prefer paper or not.
04:01:20 <agreco> fair enough, I just noticed a difference in certain chapter
04:01:44 <no-n> :t StateT
04:01:45 <lambdabot> (s -> m (a, s)) -> StateT s m a
04:01:54 <no-n> :k StateT
04:01:55 <lambdabot> * -> (* -> *) -> * -> *
04:06:12 <jle`> @unmtl StateT
04:06:12 <lambdabot> Plugin `unmtl' failed with: `StateT' is not applied to enough arguments, giving `/\A B C. A -> B (C, A)'
04:06:21 <jle`> @unmtl StateT s m a
04:06:21 <lambdabot> s -> m (a, s)
04:06:42 * hackagebot find-conduit 0.3.0 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.3.0 (JohnWiegley)
04:44:28 <wombawomba> Why am I getting different results here? https://gist.github.com/aeriksson/dbb90a76b1d4d19dcce3
04:47:48 <ski> @let digits 0 = []; digits n = digits (quot n 10) ++ [mod n 10]
04:47:49 <lambdabot>  Defined.
04:47:54 <ski> @let f n m = take (20 - m) . digits . sum . map (\x -> x^x) $ [1..n]
04:47:55 <lambdabot>  Defined.
04:47:59 <ski> @let g n m = take (n - m)  . digits . sum . map (\x -> x^x) $ [1..n]
04:48:00 <lambdabot>  Defined.
04:48:07 <ski> > g 20 10
04:48:08 <lambdabot>  Ambiguous occurrence ‚Äòg‚Äô
04:48:08 <lambdabot>  It could refer to either ‚ÄòL.g‚Äô, defined at L.hs:148:1
04:48:08 <lambdabot>                        or ‚ÄòDebug.SimpleReflect.Vars.g‚Äô,
04:48:08 <lambdabot>                           imported from ‚ÄòDebug.SimpleReflect‚Äô at L.hs:109:1-26
04:48:08 <lambdabot>                           (and originally defined in ‚Äòsimple-reflect-0.3.2:De...
04:48:13 <ski> > L.g 20 10
04:48:14 <lambdabot>  [1,3,4,1,3,7,9,2,9,1]
04:48:19 <ski> > L.f 20 10
04:48:21 <lambdabot>  [1,0,6,8,7,6,2,1,2,2]
04:48:26 <ski> > L.f (20 :: Int) 10
04:48:28 <lambdabot>  [1,3,4,1,3,7,9,2,9,1]
04:48:32 <ski> @typeL.f
04:48:32 <lambdabot> Unknown command, try @list
04:48:34 <ski> @type L.f
04:48:35 <lambdabot> Integral b => b -> Int -> [b]
04:48:36 <ski> @type L.g
04:48:37 <lambdabot> Int -> Int -> [Int]
04:50:25 <wombawomba> so, overflow?
04:50:30 <ski> wombawomba : because of overflow on `Int' vs. no overflow on `Integer', plus that `f' defaulted to using `Integer', unless you constrain it to use `Int' (which is what `g' uses, because `take' wants an `Int', so in `g' `n' must be an `Int', while in `f' it can also be e.g. `Integer' or `Double' or some other numeric type)
04:51:28 <ski> (hm, actually i suppose it can't be `Double')
04:51:35 <ski> > L.f (20 :: Double) 10
04:51:37 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Double)
04:51:37 <lambdabot>    arising from a use of ‚ÄòL.f‚Äô
04:52:52 <srhb> > sum . map (\x -> x^x) $ [1..17]
04:52:53 <lambdabot>  846136323944176515621
04:53:02 <srhb> > sum . map (\x -> x^x) $ [1..17] :: Int
04:53:03 <lambdabot>  -2413903446462858715
04:56:02 <wombawomba> got it, thanks!
04:59:43 <quchen> @undef
04:59:43 <lambdabot> Undefined.
05:02:39 <fikusz> I'm looking for a function: Word8 -> [Bool]
05:02:41 <fikusz> any ideas?
05:04:30 <supki> :t toListOf bits
05:04:31 <lambdabot> (Bits s, Num s) => s -> [Bool]
05:05:23 <fikusz> supki: exactly, thanks: which package?
05:05:51 <quchen> fikusz: Lens
05:06:43 <fikusz> quchen: that doesn't look like it
05:07:29 <quchen> Okay.
05:08:12 <fikusz> quchen: maybe I'm looking at the wrong thing, could you provide a link to the hackage doc?
05:08:32 <quchen> http://hackage.haskell.org/package/lens
05:09:16 <quchen> More specifically, http://hackage.haskell.org/package/lens-4.1.2/docs/Data-Bits-Lens.html#v:bits
05:09:32 <fikusz> quchen: I see, thanks
05:09:48 <fikusz> although this looks like a huge dependency for such a minor thing
05:11:41 <quchen> It's a small function, you can write it yourself :-)
05:11:42 <fikusz> I think I'll just write something which works by converting to int and then comparing against the modulo
05:12:07 <srhb> fikusz: Or you can use Data.Bits
05:12:44 <fikusz> srhb: hm, I'll look into it. thank you
05:13:15 <bms1> fikusz: A rough implementation:
05:13:21 <bms1> let f x = if x == 0 then [] else case x `quotRem` 2 of (y,r) -> (r == 1) : f y
05:13:30 <quchen> > let toBools :: Word8 -> [Bool]; toBools n = map (testBit n) [1..8] in toBools 127
05:13:31 <lambdabot>  [True,True,True,True,True,True,False,False]
05:13:33 <bms1> (depending on your desired endian-ness)
05:14:02 <fikusz> bms1: looks good, thanks
05:14:24 <bms1> fikusz: Wait, I realized with a fixed size, you should probably do quchen's function
05:15:04 <fikusz> bms1: yeah, I'm working with Word8
05:16:01 <quchen> You can also get rid of the hardcoded "8" there.
05:16:03 <quchen> :t let toBools n = map (testBit n) [1..finiteBitSize n] in toBools
05:16:04 <lambdabot> FiniteBits b => b -> [Bool]
05:17:59 <fikusz> quchen: thanks, 8 will do fine since I'm parsing a binary format which is mixed with ascii
05:19:11 <quchen> I'm not sure converting to [Bool] is a good idea in general.
05:19:24 <quchen> There may be a more efficient way of doing what you want to do.
05:20:01 <fikusz> quchen: I'm parsing a bitmap into a black & white image
05:21:23 <fikusz> I need to go over the bits one by one to decide if that pixel is white or black
05:22:48 <fikusz> not sure how else I could approach this
05:26:22 <quchen> Hmm. Can't come up with anything much better here.
05:34:52 <ClaudiusMaximus> fikusz: my http://hackage.haskell.org/package/bitwise might be useful? has some Bits -> [Bool] functions but also PBM codec
05:37:57 <fikusz> ClaudiusMaximus: looks great, thanks
05:48:11 <Rc43> Has anybody seen a service with visualization of scientific references?
05:50:24 <noway___> anyone heard about ( .sii ) ?
05:53:39 <no-n> what's a free monad and where do i learn about them
05:56:55 <no-n> @hoogle fromEither
05:56:55 <lambdabot> No results found
05:56:59 <no-n> >:#
05:57:36 <vanila> no-n, there's some good info here but it's very "abstract" http://hackage.haskell.org/package/free-4.6.1/docs/Control-Monad-Free.html
05:58:02 <no-n> thanks
05:58:31 <no-n> oh, did edward k invent them?
05:59:02 <benmachine> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
05:59:08 <benmachine> he did not invent them, no
05:59:15 <hvr> ...but he could have
05:59:18 <benmachine> they have existed in mathematics for decades
05:59:18 <no-n> (it just says he's the maintainer )
05:59:25 <no-n> ahh
05:59:37 <benmachine> (which is a relatively new invention in maths terms, but still)
06:00:03 <benmachine> although I guess if by "them" you mean "their use in computer science" then
06:00:49 <benmachine> I'm not sure who invented that
06:01:21 <benmachine> probably wasn't a single person
06:01:43 <benmachine> probably someone came up with a thing and someone else was like "hey, that looks like a free monad!" and they went "hey, I think you're right!" and then high fives all round
06:01:51 <benmachine> that's roughly how I imagine it
06:01:54 * hackagebot present 0.0.0 - Make presentations for data types.  http://hackage.haskell.org/package/present-0.0.0 (ChrisDone)
06:01:56 * hackagebot swish 0.9.0.13 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.13 (DouglasBurke)
06:05:36 <no-n> I'm going to try to solve my current problem with combined monads before looking into free monads
06:05:46 <no-n> though I want to learn free monads soonish anyway
06:06:23 <no-n> I should probably learn continuation too @_@
06:06:57 <vanila> combined monads?
06:07:13 <no-n> you know transformers and stuff
06:07:23 <vanila> oh yeah
06:09:27 <srhb> benmachine: I think there was probably a song and dance too, but yeah, pretty accurate.
06:09:29 <srhb> :-)
06:09:58 <benmachine> no-n: the continuation monad is great
06:10:02 <benmachine> and also kinda crazy
06:10:05 <benmachine> but also kinda great
06:10:23 <no-n> benmachine: I am writing a brainf**k interpreter in haskell
06:10:25 <benmachine> no-n: I recommend this http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
06:10:28 <benmachine> oh
06:10:33 <benmachine> well, have fun with that :P
06:10:34 <no-n> benmachine: I'm not sure which would be the best monad for looping etc
06:10:37 <benmachine> oh
06:10:47 <benmachine> sometimes the best monad is no monad at all?
06:10:48 <vanila> how about brainfuck with setjmp/longjmp?
06:10:56 <no-n> benmachine: perhaps!
06:10:58 <vanila> then you can actually use the continuation monad
06:11:03 <no-n> haha :)
06:11:30 <no-n> benmachine: oh yeah, I've read that. Didn't understand it though :3
06:11:50 <vanila> for brainfuck you probably want state monad so that you can hold a mutable(?) vector for memory cells, and the stack point and program counter
06:11:55 <bms1> The way I normally think of the "free" version of a typeclass is one where all class methods are just constructors
06:12:11 <benmachine> you might want a state monad and then again you might not
06:12:15 <no-n> vanila: i'm doing something like that
06:12:16 <benmachine> you can use state without using State
06:12:18 <vanila> zipper (two stacks back to back) could work well
06:12:31 <benmachine> zipper sounds pretty cool
06:12:40 <bms1> You can then break down the constructors, and replace them with the actual methods for a specific class - hence you can turn a "free" version of the typeclass into any version of the typeclass
06:12:41 <benmachine> in fact it sounds pretty ideal
06:12:44 <no-n> well there's the source code, the tape and the instruction pointer to pass around
06:13:01 <benmachine> bms1: it's a bit more subtle than that in the presence of laws, but that's a good way of looking at it, yeah
06:13:08 <ski> vanila : you can't jump into functions you've returned from, with that ..
06:13:34 <benmachine> no-n: if you use zippers the tape and instruction pointer are basically the same
06:13:44 <no-n> haven't learnt zippers yet
06:13:48 <benmachine> learn zippers
06:13:52 <no-n> I know that LYAH ends with them
06:13:58 <vanila> ski - ahh, so you could only have shift/reset with that I guess?
06:14:05 <no-n> and I haven't even read the monad stuff yet, lol
06:14:13 <no-n> (though I've read about them elsewhere)
06:14:22 <vanila> no-n, it's not hard, ([a],[a]) with the view reverse x + y
06:14:24 <no-n> I should finish LYAH
06:14:50 <ski> vanila : no, that also requires being able to jump back
06:14:58 <vanila> hmm
06:15:36 <benmachine> no-n: sec, there's a cute tutorial somewhere that explains zippers, I'll see if I can find it
06:15:54 <ski> you can do one-shot continuations with it
06:16:54 <benmachine> no-n: http://en.wikibooks.org/wiki/Haskell/Zippers
06:17:06 <no-n> thanks benmachine
06:22:09 <srhb> Why is it that instance Functor (Either e) where fmap f (Right x) = Right (f x); fmap _ l = l -- is not valid?
06:22:58 <vanila> it looks correct
06:23:58 <srhb> Well I know what is wrong but I'm having trouble arguing about it
06:24:17 <vanila> well I think it is correct, what is wrong with it?
06:24:24 <srhb> l :: Either e a -- but should be Either e b
06:24:47 <srhb> So the argument goes along the lines of " we need to create a new value to get the new type"
06:24:54 <srhb> But basically it's a coerce?
06:25:00 <benmachine> srhb: it's not a coerce
06:25:10 <srhb> Well, I could do it with coerce, right?
06:25:23 <benmachine> ...you could write fmap _ l = unsafeCoerce l, yes
06:25:26 <benmachine> if you were completely mad
06:25:26 <srhb> Gotcha.
06:25:29 <srhb> Why mad? :P
06:25:33 <vanila> no dont use unsafeCoerce
06:25:40 <benmachine> because it's terrifying
06:25:46 <srhb> Hmm, I don't understand why
06:25:49 <benmachine> what if you accidentally write unsafeCoerce l l
06:25:53 <benmachine> it will typecheck, and then segfault
06:26:04 <vanila> srhb, I think your code is correct
06:26:07 <vanila> are you referring to this error?
06:26:08 <srhb> vanila: It's not
06:26:10 <vanila>       instance Functor (Either e) -- Defined at test.hs:1:10
06:26:11 <vanila>       instance Functor (Either a) -- Defined in `Data.Either'
06:26:30 <srhb> because l really does have type Either e a -- obviously
06:26:39 <srhb> And fmap _ l needs to give us a type Either e b
06:27:01 <vanila> ohh
06:27:06 <srhb> So the "right way" is to construct a new value with Left
06:27:13 <vanila> I'm sorry I totally missed it
06:30:22 <vanila> yeah it's exactly what you said l :: Either e a -- but should be Either e b
06:30:30 <ski> srhb : hehe, i had an idea years ago that after failing to match `Right ...', the matched value now sould have type `forall b. Either (...) b' -- which would fix this issue :)
06:31:40 <vanila> in fmap _ (Left y) = Left y -- you can imagine the two different Left's :: forall e x. e -> Either e x   having the type variables instantiated differently
06:32:04 <vanila> fmap _ (Left {- e -} {- a -} y) = Left {- e -} {- b -} y
06:32:06 <srhb> Righto.
06:32:17 <dwcook> srhb, the problem is that l :: Either e a and cannot have type Either e b
06:32:18 <vanila> sorry for all that confusion :|
06:32:42 <ski> (because `a' and `b' are distinct skolems ..)
06:32:50 <srhb> Don't worry about it, I mean I knew that was the problem but somehow my brain didn't like constructing a value that looked the same just to get a different type
06:32:53 <srhb> But it makes fine sense.
06:33:26 * ski doesn't like it
06:33:42 <vanila> In this System F (lambda calculus) which haskell is sort of based around.. there's two types of lambda
06:34:03 <vanila> one for function and one for forall's.. and type variable application is done explicitly rather than implicitly
06:34:20 <vanila> so knowing that can help think about things
06:34:56 <ski> vanila : and iiuc, you can't code `(forall a. Either (f a) (g a)) -> Either (forall a. f a) (forall a. g a)' in System F ..
06:35:44 <no-n> okay
06:35:55 <no-n> should I read/learn about zippers first? or free monads?
06:36:14 <vanila> ski - that's surprising to me!
06:37:26 <vanila> ski, oh i see it - because you can't know which constructor you'll have before instantiating the type variable (even though it's impossible for that to change it)
06:38:31 <ski> vanila : yes, it seems like some kind of parametricity-like (?) property should guarantee this to be provable
06:38:42 <no-n> please somebody direct me :P
06:38:59 <ski> no-n : zippers are fun
06:39:01 <vanila> no-n, zips more relevant to what you're implementing so I'd start with that
06:39:10 <no-n> ok
06:39:12 <vanila> and that tutorial benmachine linked looks really nice
06:39:38 <no-n> the wikibooks one?
06:39:42 <vanila> yeah
06:40:00 <no-n> will give it a go
06:40:33 <vanila> ski, I wonder you would keep parametricity if you added functions like that one to the language?
06:46:29 <vanila> ski, I guess there would be no new provable equations so it should be ok
06:52:03 <ski> vanila : in intutionistic math, there's a "uniformity principle" `(forall s : Power |N. exists n : |N. R (s,n)) -> (exists n : |N. forall s : Power |N. R (s,n))' that seems similar in spirit to the above distribution
06:52:59 <augur> ski: is that true? goodness
06:54:17 <ski> vanila : the idea being that when given *any* subset of `|N', the only way you can pick a natural number `|N' is to pick the same one regardless of which subset you were given -- because `|N' is a discrete set and `Power |N' is a very non-discrete set -- you can't *test* any properties of a given subset, you can only be *given* properties of it (and in this case, you're given no properties of `s')
06:54:53 <ski> augur : it's a candidate axiom, like bar recursion -- obviously they contradict classical math
06:54:57 <vanila> wow that's fascinating
06:55:42 <augur> ski: axioms? feh!
06:55:44 <ski> here `Power |N' is basically the same as `|N -> Prop' (*not* `|N -> Bool' !)
06:55:51 <augur> i dont accept your axioms
06:56:08 <ski> augur : possibly one can build a nicer system on it, with a computational interpretation
06:56:15 <augur> ski: :)
06:56:37 <vanila> ski, I wonder if you could use the halting theory and that explanation you gave in a proof that the axiom is admissable?
06:57:19 <ski> but i think, in the end, whether the system is strongly normalizing would depend on whether you believe in the contents of the axiom or not (like with Markov's Principle)
06:58:26 <ski> (one could probably replace `Prop' with `Set' above, btw)
06:59:26 <ski> (while `|N -> Sierpinski' is the set of semi-observable properties/subsets of `|N' -- so in this case one can, sortof, test -- though if the test fails, one'll just not terminate)
06:59:45 <ski> vanila : btw, do you know bar recursion ?
07:00:06 <vanila> no
07:01:08 <ski> vanila : well, consider any (total) function of type `|N -> A', this is basically the same as `Stream A', the type of infinite streams of `A's
07:02:30 <ski> vanila : now consider a function of type `(|N -> A) -> B', where `B' is a *discrete* type like `Bool' or `|N'
07:02:44 <vanila> okay yes
07:03:07 <vanila> you can only ever look at finite portion of the stream
07:03:10 <ski> vanila : this function computes a *finite* piece of data, so, accordingly, it can only inspect finitely many elements of the stream
07:03:44 <ski> and so there is some prefix of the stream such that, if you take any other stream with the same prefix, the function will give the same result
07:06:54 <ski>   (forall as : |N -> A. exists b : B. R (as,b)) -> (forall as : |N -> A. exists b : B. exists n : |N. forall as' : |N -> A. take n as = take n as' => R (as',b))
07:07:03 <ski> this is a kind of continuity principle
07:08:07 <ski> using it, one can prove that any such function of type `(|N -> A) -> B' is continuous
07:09:31 <vanila> what is the proof?
07:09:53 <ski> well, the principle is assumed as an axiom
07:11:39 <ski> (and the continuity is wrt the discrete topology on `B', and in case `A' is `|N', then the Baire topology on `|N -> A' (Cantor if `A' is `Bool'))
07:11:56 * ski doesn't recall the details, though
07:13:38 <ski> vanila : further, one could imagine that given `f : (|N -> A) -> B', one could determine whether a given finite prefix of the input stream is enough to compute the output -- giving rise to computing modulus of continuity
07:15:13 <ski> vanila : anyway, Bar induction/recursion is in some sense a kind of "backward induction" on streams
07:16:20 <ski> vanila : we can view the set `|N -> A' of streams of `A' as an infinite tree with `A' as branching factor
07:17:21 <vanila> I see
07:17:36 <ski> vanila : then, let's say we know `forall as : |N -> A. P as = True' (with `P : (|N -> A) -> Bool')
07:18:26 <ski> then, for any such `as', there must be a finite prefix thereof, such that all streams with that prefix also yield `True' when passed to `P'
07:19:53 <dart> hi
07:19:56 <ski> in terms of the infinite tree : regardless of what infinite path we take, we will hit a node where we're guaranteed that whichever way we go, `P' will give `True'
07:20:16 <ski> these nodes are known as a "bar" for the infinite tree
07:20:22 <dart> i'm struggling getting a decent editor setup with ghc 7.8.2 + cabal sandboxes
07:20:23 <MagneticDuck> can somebody refresh my memory -- why is the dreaded monomorphisim restriction on by default?
07:20:26 <MagneticDuck> when is it ever useful?
07:20:27 <dart> what is everyone using ?
07:21:03 <pjdelport> MagneticDuck: hysterical raisins?
07:21:07 <ski> now, `P' is a decidable property, but assume we also have `Q : (|N -> A) -> Prop', and that we know `forall as : |N -> A. P as = True => Q as'
07:21:15 <MagneticDuck> pjdelport: hysterical raisins?
07:21:18 <vanila> ski, I follow
07:21:29 <ski> vanila : we'd now like to be able to conclude `forall as : |N -> A. Q as'
07:21:37 <vanila> nice to understand the meaning of bar in that sense!
07:21:44 <pjdelport> MagneticDuck: it's an amusing rendition of "historical reasons"
07:21:45 <dart> i find myself dreading developing in haskell because there is no good editor that wors out of the box
07:22:03 <vanila> dart I use emacs
07:22:18 <MagneticDuck> pjdelport: ahahahahahahha ahahahahahh AHAhhaHAHAH
07:22:23 <MagneticDuck> that was mildly amusing
07:22:28 <MagneticDuck> actually it was alright
07:22:51 <MagneticDuck> dart: vim + plugins?
07:23:00 <MagneticDuck> ...
07:23:02 <ski> vanila : we need one extra hypothesis, the "backward induction step" : `forall as : |N -> A. (forall a : A. Q (cons a as)) => Q as'
07:23:08 <pjdelport> MagneticDuck: basically, it's to avoid unexpected recomputation and polymorphism
07:23:25 <ski> vanila : so that if we know `Q' holds at every child node of some node, then we also know it holds for that node
07:23:45 <vanila> ski - aha that's the backwards step
07:23:51 <pjdelport> but "unexpected" is a bit subjective; for better or for worse, no one really seems to have argued with enough inertia to change the current default
07:23:56 <ski> vanila : combined with the "base case" of knowing `Q' holds at the bar nodes, given that `P' holds there, the "backwards induction" is complete
07:24:28 <vanila> That's clear!
07:24:29 <ski> vanila : "nice to understand the meaning of bar in that sense!" -- hehe, perhaps you know another (relevant) sense ?
07:24:37 <bss03> So, Profunctors compose as Functors... but is there a function: Profuctor p => p a b -> p b c -> p a c?  I'm guessing not... since I can't imagine an implementation for p ~ UpStar f
07:24:46 <pjdelport> MagneticDuck: have you read http://www.haskell.org/haskellwiki/Monomorphism_restriction ?
07:25:11 <ski> vanila : anyway, this can't be proven in intuitionistic logic. it's an axiom suggested by Brouwer, upon reflection on normal/canonical forms of proofs
07:26:02 <ski> vanila : while the axiom is anti-classical, one can nevertheless use it to prove classical results in analysis that would otherwise not be provable intuitionistically
07:26:49 <ski> vanila : also, yes, this is related to K√∂nig's lemma (which is not intuitionistically valid), in case you wonder
07:27:56 <bss03> Although, it seems like the "most useful" profunctors have that function... It's available for Kleisli, Cokleisli, Arrow, (->)... Is there maybe another type class / name for "Profunctor with compose"?
07:30:46 <ski> vanila : "Constructivism in Mathematics : An introduction - volume 1" by Dirk van Dalen,Anne Sjerp Troelstra in 1988 and also "Elements of Intuitionism" by Michael Dummett in 1977 talk about this, if you're interested
07:31:22 <vanila> thanks :)
07:31:36 <ski> vanila : also, i think there's some relation to Mart√≠n Escard√≥'s recent work on computation-related topology
07:31:43 <ski> @where impossible
07:31:43 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
07:31:46 <ski> @where topology
07:31:46 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|dvi|ps)> by MartÌn EscardÛ
07:32:32 <c_wraith> bss03: most profunctors are categories, which is slightly stronger of a statement than you're making.  But I don't see any deep reason for that.
07:33:05 <ski> that last paper e.g. talks about how a space `A' being compact means there's a (semi-computable) quantifier `forall_A : (A -> Sierpinski) -> Sierpinski'
07:33:13 <benmachine> c_wraith: well, perhaps it is simply "categories give rise to profunctors, and there are lots of categories"?
07:33:54 * ski can never recall whether profunctors are just difunctors, or slightly different
07:34:08 <c_wraith> benmachine: do they? It's not obvious to me that all categories with the right kind are profunctors
07:34:14 <bss03> Maybe "Monoidal Profuctor"?  (Category p, Profunctor p) is very similar to what I want, but I'm not sure I need id :: p a a explicitly.
07:34:17 <benmachine> profunctors are what homfunctors are, aren't they?
07:34:33 <benmachine> bss03: "semigroupoid" is the usual name for "category without identity"
07:34:45 <benmachine> bss03: see also http://hackage.haskell.org/package/semigroupoids
07:36:33 <benmachine> c_wraith: I think category + Arrow arr will get you profunctor
07:37:07 <benmachine> c_wraith: or perhaps, categories always give you profunctors with a small p, but you need a way to get the morphisms into Hask in order to have a Profunctor
07:37:13 <benmachine> er, out of Hask
07:37:37 <bss03> benmachine: Do you even need category?  I think Data.Profunctor provides a general wrapper to make any Arrow a Profunctor.
07:37:55 <c_wraith> bss03: Arrow is strictly stronger than Categorry
07:37:55 <benmachine> bss03: every Arrow is a Category already
07:37:59 <c_wraith> *Category
07:38:28 <benmachine> but you don't need all the tuple faff that Arrow gets you as well
07:38:38 <benmachine> just arr is enough
07:38:40 <benmachine> well
07:38:50 <benmachine> enough to make the types work, anyway, dunno about the laws
07:39:58 <bss03> The "tuple faff" is a part of a "strong profunctor".
07:43:58 <bss03> While I see something like arr for all the Profunctors in the profunctors package, I don't think Profunctor p => a -> b -> p a b is required.
07:47:02 <bss03> If you have the arrow law: arr (f >>> g) = arr f >>> arr g, and You define lmap f pg = arr f >>> pg (and similarly with dimap, and rmap) the profunctor laws arise, yes.
07:48:52 <jakex> given cellMode CellRendererModeActivatable what signal is raised when a cell is activated?
07:48:54 <jakex> gtk2hs
08:05:13 * ski . o O ( `map (\(_ :: a) -> _ :: b) (_ :: [a]) :: [b]' )
08:06:56 <bss03> I'm having trouble googling something that I think has a name that I can't remember.  What do you call it when you have two types A, B, two functions f : A -> B, g : B -> A where f and g are "almost" inverses.
08:07:01 * ski . o O ( `map (\(_ :: a) -> _ :: b) [_ :: a ..] !! _ :: b' )
08:07:43 <bss03> By almost I mean that (f . g) . f = id . f and (g . f) . g = id . g
08:07:50 <ski> bss03 : if you only want `g . f = id', then this is a retract situation, with `g' being the retraction and `f' the section
08:08:08 <ski> bss03 : oh .. iirc that's called "pseudo-inverse"
08:08:53 <bss03> Okay, I've been informally calling it a quasi-isomorphism and I *knew* that was wrong.
08:09:34 <bss03> Yay! Found what I was looking for: http://www.reddit.com/r/haskell/comments/1l4ph3/dsls_and_towers_of_abstraction_with_gershom/
08:11:12 <ski> bss03 : see <http://en.wikipedia.org/wiki/Generalized_inverse> and also <http://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse>
08:23:32 <quchen> Is there a reason there are no Set-specific seuquence/traverse functions in Data.Set?
08:23:49 <quchen> I've been needing it a couple of times, just wondering
08:25:04 <quchen> Similar to Set.map, one could simply define `traverseSet f = fmap S.fromList . T.traverse f . S.toList`
08:26:31 <DR6> actually, it should be an instance of Traversable
08:26:36 <DR6> I don't know why it isn't
08:26:38 <skypers> hi
08:26:45 <skypers> is there a way to ‚Äútransport‚Äù a MVector?
08:26:54 <quchen> DR6: It cannot be, because you would need an Ord constraint
08:27:00 <quchen> Similarly, Set isn't a Functor
08:27:08 <DR6> oh wait
08:27:11 <DR6> right
08:27:18 <quchen> traverseSet :: (Applicative f, Ord b) => (a -> f b) -> Set a -> f (Set b)
08:27:19 <DR6> I looked at Data.Maop
08:27:23 * hackagebot websockets 0.8.2.2 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.2.2 (JasperVanDerJeugt)
08:27:25 * hackagebot packunused 0.1.1.0 - Tool for detecting redundant Cabal package dependencies  http://hackage.haskell.org/package/packunused-0.1.1.0 (HerbertValerioRiedel)
08:27:28 <skypers> I‚Äôd like to hold a MVector in a monad, do something with it in ST, then freeze it, use the Vector version but keep allocated the MVector memory in order to use it later again
08:27:32 <skypers> any way to do that?
08:27:51 <c_wraith> sure
08:28:11 <quchen> Oh? I thought that wasn't possible.
08:28:18 <DR6> shouldn't freeze make a new copy anyway?
08:28:21 <c_wraith> well, you can't use unsafeFreeze
08:28:23 <DR6> unsafeFreeze doesn't
08:28:45 <skypers> let me tell you more about the context
08:28:53 <c_wraith> And you need to do something terrifying like use unsafeInterleaveST
08:28:59 <quchen> Oh, unsafeFreeze doesn't leave ST, nevermind.
08:29:10 <skypers> I have a monad that glues some stuff in a State
08:29:28 <skypers> up to now, I ‚Äúcache‚Äù some stuff in a Vector each frame (it‚Äôs a 3D engine)
08:29:37 <skypers> the problem is I build and rebuild the Vector each frame
08:29:42 <skypers> it‚Äôll result in poor performanc
08:29:43 <skypers> e
08:29:51 <skypers> my idea was to create a MVector before the frame
08:29:56 <skypers> and is it when needed
08:30:41 <c_wraith> if you can guarantee linear use, you might choose to use unsafeFreeze/unsafeThaw
08:31:04 <skypers> :t unsafeFreeze
08:31:04 <lambdabot> Not in scope: ‚ÄòunsafeFreeze‚Äô
08:31:08 <skypers> hm
08:31:09 <c_wraith> But you'd better know *exactly* what you're doing
08:31:11 <skypers> I‚Äôll check that out
08:31:15 <skypers> yes I am
08:31:27 <noobelina> What is the convention to end function names with a tick? replicate' from http://learnyouahaskell.com/recursion for example
08:31:30 <skypers> I‚Äôm using Vector‚Äôs index a LOT for performance purpose
08:31:34 <c_wraith> laziness can make that combination lead to violating referential transparency
08:31:38 <skypers> noobelina: strictness
08:31:55 <c_wraith> skypers: not really.  The convention is just "a slightly modified version"
08:32:00 <skypers> foldl' for instance, is the strict in accum version of foldl
08:32:12 <noobelina> in accum?
08:32:33 <skypers> noobelina: foldl1 (+), it will create a lot of thunks using the accumulator
08:32:37 <skypers> foldld1' won‚Äôt
08:33:01 <c_wraith> skypers: that's *also* oversimplified.  foldl' can easily create huge chains of thunks, too
08:33:14 <skypers> huh?
08:33:34 <DR6> in which case?
08:33:47 <c_wraith> : foldl' ((*) *** (+)) (1,0)
08:33:47 <DR6> with complicated structures?
08:33:54 <c_wraith> :t foldl' ((*) *** (+)) (1,0)
08:33:55 <lambdabot>     Couldn't match type ‚Äò(t -> t, t1 -> t1)‚Äô with ‚Äòa -> (t, t1)‚Äô
08:33:55 <lambdabot>     Expected type: (t, t1) -> a -> (t, t1)
08:33:55 <lambdabot>       Actual type: (t, t1) -> (t -> t, t1 -> t1)
08:34:05 <c_wraith> oh, whoops
08:34:50 <DR6> should that take just a list of numbers?
08:35:05 <DR6> or of pairs?
08:35:32 <c_wraith> :t foldl' (\(y, z) x -> (x * y, x + z)) (1, 0)
08:35:33 <lambdabot> Num t => [t] -> (t, t)
08:35:36 <c_wraith> There
08:35:44 <c_wraith> That will still create huge chains of thunks
08:36:09 <DR6> because pairs are lazy and just evaluated to WHNF?
08:36:13 <DR6> or something else?
08:36:15 <skypers> yeah
08:36:17 <skypers> right
08:36:23 <alpounet> put bangs on y and z: \(!y, !z) x -> ... -- you need {-# LANGUAGE BangPatterns #-} though
08:37:00 <c_wraith> skypers: and this is *exactly* the sort of laziness issue you need to understand thoroughly before combining unsafeFreeze and unsafeThaw
08:38:49 <skypers> c_wraith: ok :)
08:38:52 <skypers> anyway
08:39:02 <skypers> I‚Äôm looking for a way to store ‚Äúallocated‚Äù vectors
08:39:12 <skypers> in a way I won‚Äôt have to allocate again and again
08:39:16 <nh2> If I want a memory representation cast of Float -> Word32, is unsafeCoerce the best way?
08:39:18 <skypers> because it‚Äôd kill my framerate otheriwse
08:39:34 <nh2> or should U use storable
08:39:38 <nh2> s/U/I
08:42:31 <c_wraith> skypers: I would recommend using IO instead of ST, so you can just return the MVector.  Also, freezing and thawing take exactly the same amount of time.
08:43:29 <ski> @hoogle Ix i => (forall s. ST s (STArray s i e)) -> Array i e
08:43:29 <lambdabot> Data.Array.ST runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
08:43:29 <lambdabot> Data.Array.ST.Safe runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
08:43:34 <ski> @hoogle Ix i => (forall s. ST s (STUArray s i e)) -> UArray i e
08:43:34 <lambdabot> Data.Array.ST runSTUArray :: Ix i => (forall s. ST s (STUArray s i e)) -> UArray i e
08:43:34 <lambdabot> Data.Array.ST.Safe runSTUArray :: Ix i => (forall s. ST s (STUArray s i e)) -> UArray i e
08:45:11 <skypers> c_wraith: hm
08:45:30 <skypers> so using IO enables me to use transport it?
08:45:47 <aviraldg> Is there a convenient way to add logging to a pure function? (ps. I know about the Writer monad)
08:46:05 <c_wraith> aviraldg: debugging, or production logging?
08:46:13 <aviraldg> debugging is more like it
08:46:26 <c_wraith> then look at the Debug.Trace module
08:46:35 <aviraldg> Thanks!
08:47:35 <aviraldg> Exactly what I was looking for.
08:47:39 <c_wraith> skypers: using IO instead of ST probably means a significant redesign.  But it also means you don't worry about entering and leaving the context causing you to, well, lose the context.
08:48:20 <c_wraith> aviraldg: note that it does expose the inner workings of evaluation order..  Sometimes what it prints can be kind of tricky to understand, until you really understand that.
08:48:43 <skypers> c_wraith: indeed
08:48:56 <skypers> but I use the Vector in a monad over IO (rendering)
08:49:00 <skypers> so it‚Äôs not a problem
08:59:08 <aviraldg> c_wraith, ... as is evident from the lack of said logging in my program's output.
08:59:12 <aviraldg> c_wraith, trying to log the arguments to solve before each function call: http://dpaste.com/1798770/
09:00:54 <c_wraith> aviraldg: insert before line 11:  solve k xs ys | traceShow (k, xs, ys) False = undefined
09:01:21 <c_wraith> that's a super-handy trick to know with tracing.  It will alter strictness properties, though
09:01:29 <c_wraith> In that it will force the arguments to be fully evaluated
09:01:46 <aviraldg> seq should force the traceShow to be evaluated right?
09:01:59 <aviraldg> Okay, I'll try that.
09:02:14 <c_wraith> you got lost in the laziness/unsafePerformIO trap
09:02:33 <c_wraith> That code would work if you removed the seq entirely
09:02:52 <c_wraith> traceShow takes two arguments
09:03:00 <c_wraith> The first one is the value to output
09:03:07 <c_wraith> The second one is the value to return
09:03:21 <c_wraith> the output will only happen at the time the return value is forced
09:03:37 <aviraldg> ... reverse order?
09:03:41 <c_wraith> The guard hack makes sure the return value is forced promptly
09:04:00 <c_wraith> Because it needs to check the guard before proceeding with function evaluation
09:04:11 <aviraldg> It worked!
09:05:34 <Kiryx> Hey, I'm trying to teach myself haskell through online programming contests
09:06:09 <aviraldg> same here (kind of) :)
09:06:17 <Kiryx> how Can I read this line: "1 2 3" both as an array and separate variables x,y,z
09:07:18 <DR6> a <- getLine
09:07:38 <DR6> let [x,y,z] = words a
09:07:47 <DR6> I wouldn't recommend it
09:08:03 <DR6> what if the input doesn't have exactly three words?
09:08:13 <aviraldg> a@[x, y, z] <- map read . words <$> getLine
09:08:15 <Kiryx> I can assume it's validity
09:08:18 <aviraldg> should work (I guess?)
09:08:31 <Kiryx> its*
09:08:32 <vanila> that's easy to fix  case words a of [x,y,z] -> ... ; _ -> error handle other case
09:08:44 <DR6> oh, in mine x,y,z :: String
09:08:53 <Kiryx> True
09:09:10 <DR6> are you sure you need them in separate variables?
09:09:16 <DR6> what are you doing?
09:09:44 <Kiryx> I just want to cover the general case i.e. sometimes I need to read a line of integers/floats of arbitrary length
09:10:23 <Kiryx> and sometimes its input sizes, e.g. 2 integers in a line
09:10:48 <aviraldg> http://dpaste.com/1798770/
09:10:56 <aviraldg> I'm doing pretty much the same thing there.
09:11:07 <aviraldg> (ignore the rest)
09:13:45 <DR6> :r
09:13:48 <DR6> oops
09:14:34 <SwashBuckla> is there a tool to generate a call stack diagram from running a Haskell program?
09:14:52 <SwashBuckla> or a "UML" diagram (some diagram to illustrate how different functions interact)
09:15:19 <c_wraith> SwashBuckla: one of those is a static property.  one is a dynamic property.  Which are you looking for?
09:15:29 <SwashBuckla> either!
09:15:31 <SwashBuckla> both!
09:16:35 <Kiryx> aviraldg: This looks like a good template for the start
09:16:37 <SwashBuckla> e.g. an example of the latter diagram is one that illustrates how IO String comes in from the outside world, gets read into a String and passed to function doSomething, doSomething then does something and calls fooBar [String]
09:16:41 <SwashBuckla> blah blah blah
09:16:57 <SwashBuckla> I just would like a nice overview of how stuff fits together/is interrelated
09:17:04 <c_wraith> Huh.  Was 7.8 the version of GHC that was supposed to include stack traces in profiling mode?
09:17:16 <nolrai66> I think the profiling tools give you a call graph..but I am not sure.
09:20:11 <aviraldg> c_wraith, what if you need immediate evaluation? Why doesn't seq work with traceShow?
09:20:43 <c_wraith> aviraldg: well, seq *does* work with traceshow...  If you do it right.
09:20:49 <aviraldg> (don't want to bug you too much -- where can I read about it?)
09:20:49 <c_wraith> aviraldg: but you didn't
09:21:12 <c_wraith> traceShow :: (Show a) => a -> b -> b
09:21:25 <c_wraith> If you only apply one argument to it, you still have a function
09:21:33 <c_wraith> err, feed one argument to it
09:21:48 <c_wraith> seq on a function doesn't (usually) do anything
09:22:18 <srhb> Why only usually? Are there any cases where that would not be the case?
09:22:22 <srhb> I can't think of any offhand.
09:22:33 <c_wraith> I can. :)
09:22:37 <srhb> Hmm
09:22:48 <aviraldg> ah, I see my mistake there
09:23:02 <srhb> c_wraith: Do tell :P
09:23:12 <c_wraith> like... seq (trace "hello" id) ()
09:23:28 <c_wraith> Just as an example
09:23:40 <int-e> aviraldg: You could insert  solve k xs xs' | traceShow (k,xs,xs') False = undefined   after line 12, that way the debug output is easy to comment out.
09:23:54 <c_wraith> int-e: I already gave him that advice. :)
09:24:04 <aviraldg> :)
09:24:31 <SwashBuckla> so... what could I use (if you know of a tool/method)?
09:24:39 <c_wraith> aviraldg: anyway, you could do something like seq (traceShow foo ()) bar
09:24:55 <c_wraith> aviraldg: but that ends up being the same as traceShow foo bar
09:25:47 <aviraldg> But that isn't evaluated immediately. So it's shown in reverse order.
09:25:59 <c_wraith> neither one is evaluated immediately
09:26:11 <c_wraith> Both of them are evaluated when the result is forced
09:26:18 <c_wraith> Both of them produce output at that time
09:26:28 <srhb> c_wraith: What's the difference between that and trace "hello" id $ () ?
09:26:57 <c_wraith> srhb: you're comparing it to the wrong thing.  Compare it to flip const (trace "hello" id) ()
09:27:25 <c_wraith> srhb: since seq is most comparable to flip const, if you ignore the strictness
09:27:43 <aviraldg> Here's what I'm talking about: http://dpaste.com/1798785/ and http://dpaste.com/1798786/
09:27:50 <aviraldg> Evaluation rules really are quite confusing.
09:28:06 <aviraldg> Okay.
09:28:07 <aviraldg> Sorry.
09:28:10 <aviraldg> Forget that.
09:28:13 <aviraldg> Don't look at it.
09:28:26 <aviraldg> It's cool.
09:28:26 <c_wraith> aviraldg: I told you that Debug.Trace reveals evaluation order
09:28:27 <srhb> aviraldg: TOO LATE
09:28:37 * aviraldg feels stupid
09:28:41 <c_wraith> aviraldg: if you want things to print in a different order, you need to change the evaluation order
09:29:39 <srhb> Also I do think applying seq to (trace "hello" id) does nothing.
09:30:39 <chrisw_> Is there a more concise way to write do { a <- getA; b <- getB; _ <- getC; return (a, b) }
09:30:47 <c_wraith> srhb: ghci disagrees with you
09:31:13 <srhb> My GHCI must be broken then.
09:32:09 <shachaf> liftA3 (\a b _ -> (a,b)) getA getB getC
09:32:22 <shachaf> Or maybe something like (,) <$> getA <*> getB <* getC
09:32:24 <srhb> chrisw_: (,) <$> getA <*> getB <* getC
09:32:26 <c_wraith> I see:  Prelude Debug.Trace> seq (trace "hello" id) ()\nhello\n()
09:33:16 <srhb> c_wraith: Me too. Just like with (trace "hello" id) ()
09:33:32 <chrisw_> srhb, wow thanks!
09:33:33 <c_wraith> You're still comparing it to the wrong thing
09:33:45 <srhb> c_wraith: I think we're arguing semantics now. Nevermind. :)
09:33:52 <c_wraith> replace seq with something that *doesn't* evaluate the function
09:34:08 <shachaf> what's wrong with semantics?
09:34:22 <c_wraith> My whole point was that seq on a function can result in more than nothing happening, compared to not evaluating the function
09:34:38 <srhb> Why would I replace seq with something else when the point of it was an example where seq somehow DOES do something when applied to a function
09:34:39 <c_wraith> applying a function certainly causes the function to be evaluated
09:34:50 <srhb> Okay.
09:36:08 <c_wraith> You asked when applying seq to a function would do something.  I provided an example of when applying seq to a function has different semantics than ignoring the function.
09:36:41 <c_wraith> You can also find examples that don't involve trace
09:36:45 <shachaf> Another example is when the function is _|_.
09:36:47 <c_wraith> But all the other examples involve bottom
09:36:55 <shachaf> Calling trace's behavior "semantics" is stretching things a little, though.
09:37:04 <srhb> I wasn't talking about the semantics of trace
09:37:07 <srhb> I don't care about trace
09:37:21 <c_wraith> trace has definite operational semantics.
09:37:32 <c_wraith> Denotationally?  not so much.
09:40:37 <c_wraith> well.  Ok, all the examples involve either bottom or unsafePerformIO
09:42:01 <SwashBuckla> c_wraith: do you know what I could use for making a diagram of how functions interact in a Haskell program?
09:42:38 * hackagebot aws-route53 0.1.0 - Route53 plugin for the aws package  http://hackage.haskell.org/package/aws-route53-0.1.0 (AmitLevy)
09:44:08 <c_wraith> SwashBuckla: no. There are lots of edge cases if trying to do it statically, and I don't know enough about the state of tracing in ghc profiling builds to do anything with that, either
09:44:35 <SwashBuckla> i'll just do it manually then
10:02:40 <shachaf> "type Natural f g = (Functor f, Functor g) => forall a. f a -> g a"
10:03:02 <shachaf> ski: I wonder whether that => should be *> or something?
10:03:37 <shachaf> I mean, usually the (Functor f, Functor g) isn't written at all, and presumably this works because it's always instantiated at concrete functors or something.
10:03:51 <shachaf> Well. Not really. You want id to work, for instance.
10:09:22 <osa1> hlint doesn't work on hsc files ;-(
10:23:45 <Twey> With what reasoning is [] proclaimed the ‚Äòfree‚Äô monoid as opposed to, say, Set or Bag?  It seems either of those imposes ‚Äòless structure‚Äô (not in the Haskell Ord-based implementation, obviously, but hypothetically)
10:23:57 <noobelina> why do I need parenthese around -10 in this case
10:23:57 <noobelina> partition n
10:23:58 <noobelina>  | n <= 0 = 1
10:23:58 <noobelina> main = print $ partition -10
10:24:13 <noobelina> (sorry about the blank lines) -.-
10:24:26 <quchen> That parses as "partition - 10", so you're subtracting 10 from the partition function.
10:24:29 * hackagebot packunused 0.1.1.1 - Tool for detecting redundant Cabal package dependencies  http://hackage.haskell.org/package/packunused-0.1.1.1 (HerbertValerioRiedel)
10:24:30 <Twey> noobelina: Because Haskell doesn't distinguish a - b and a -b
10:24:40 <Twey> noobelina: Whitespace isn't significant around operators
10:25:03 <Twey> You can also write print . partition $ -10
10:25:07 <wingrime> can I overload (+) between different types ?
10:25:15 <Twey> wingrime: No
10:25:22 <chrisdone> quchen: !!
10:25:31 <quchen> !!
10:25:48 <chrisdone> :t (!!)
10:25:48 <lambdabot> [a] -> Int -> a
10:25:58 <Twey> chrisdone: There was something I was going to ask you, but I've completely forgotten what it is
10:26:17 <quchen> Margin too narrow to write it down eh
10:26:18 <chrisdone> twey: would it help jog your memory if i jogged on the spot?
10:26:28 <chrisdone> quchen: check this out! http://www.youtube.com/watch?v=4rcPfZveGZc&feature=youtu.be
10:26:30 <Twey> chrisdone: Probably not, but feel free ‚Äî I hear it's healthy
10:26:33 <c_wraith> Twey: Set obvious can't be a free monoid, it throws away duplicates.  you can't map the (+,0) monoid onto a set, because 5 + 5 /= 5
10:26:43 <c_wraith> *obviously, that is
10:26:45 <Twey> c_wraith: That's true
10:26:48 <Twey> What about Bag?
10:26:54 <c_wraith> Bag loses ordering
10:26:55 <quchen> chrisdone: Woooo neat :-D
10:27:08 <c_wraith> Bag would work if monoids were required to be commutative, but they aren't
10:27:08 <shachaf> c_wraith: Except Set Void!
10:27:09 <Twey> Ah, because monoids aren't commutative
10:27:09 <quchen> chrisdone: Looks like the meeting is redundant now :-√æ
10:27:13 <Twey> Cool, thanks!
10:27:18 <vanila> Twey, [] is free since it's a data type decl - set and bag can't be define with 'data'
10:27:20 <shachaf> And Bag Void/Bag ()
10:27:33 <shachaf> But those are bad examples, of course.
10:27:42 <quchen> What's Bag?
10:27:44 <shachaf> vanila: Huh?
10:27:48 <c_wraith> quchen: multiset
10:28:00 <c_wraith> quchen: unordered, duplicates allowed
10:28:07 <shachaf> Bag is a free commutative idempotent monoid or something like that.
10:28:08 <chrisdone> quchen: haha
10:28:16 * Twey nods.
10:28:22 <wingrime> Twey: I want write numpy like arrays vectroized operations between rows and columns
10:28:33 <quchen> Ah, thanks.
10:28:44 <shachaf> Free (bounded?) semilattice, maybe?
10:29:09 <Twey> wingrime: You can introduce a new operator, (.+) or something
10:29:20 <Twey> It's just not (+)
10:29:30 <quchen> chrisdone: What kind of GUI is that?
10:29:52 <osa1> is there a way to generate hackage landing page for a package on my system? I want to check how description field looks like
10:29:52 <wingrime> Twey: ok, I know this way
10:30:01 <shachaf> Wait, I meant Set, not Bag, of course.
10:30:08 <chrisdone> quchen: it's haskell-interactive-mode. similar to inf-haskell mode, for talking to ghci
10:30:10 <Twey> wingrime: You might be interested in checking out the ‚Äòlinear‚Äô and ‚Äòvect‚Äô packages if you haven't already
10:30:12 <shachaf> That's why I wrote idempotent.
10:30:21 <osa1> (sorry if I sent this before, I lost my connection) is there a way to generate hackage landing page for a package on my system? I want to check how description field looks like
10:30:29 <quchen> chrisdone: Emacs? Browser?
10:30:39 <chrisdone> quchen: yeah, emacs
10:30:41 <quchen> (Why am I even asking haha)
10:30:51 <Twey> Silly question.
10:30:55 <chrisdone> but the browser is another possible front-end, or vim or w/e
10:31:28 <chrisdone> =)
10:31:39 <Twey> chrisdone: Shiny
10:31:39 <wingrime> Twey: nice suggest
10:32:01 <chrisdone> twey :D
10:32:03 <quchen> This reminds me a little of Luite's GHCJS toy project that shows the memory layout of a program during evaluation.
10:32:14 <chrisdone> yeah, that's cool
10:32:38 <wingrime> Twey: I realy want solve PDE, on grind, so thats not need matrix operations,
10:33:24 <chrisdone> quchen: the Presentation type can render to sexp or json http://hackage.haskell.org/package/present-0.0.0/docs/Present.html
10:33:37 <ReinH> chrisdone: omg hi
10:33:40 <ReinH> chrisdone: welcome back to the internet
10:33:44 <chrisdone> quchen: i think use of the present function should be pretty obvious. make a request for a value, then subsequent requests to drill down
10:33:51 <chrisdone> reinh: hi =)
10:34:54 <quchen> chrisdone: Alg is the general case of an ADT, Tuple/String/List are provided for prettier printing?
10:35:12 <Maior> so https://www.cs.kent.ac.uk/projects/refactor-fp/hare.html says vim is supported by hare, https://github.com/alanz/HaRe#emacs-integration says only emacs - if vim _is_ supported, can anyone point me at docs please?
10:35:52 <c_wraith> is hare even still under active development?  It is, isn't it?
10:35:57 <chrisdone> quchen: indeed. it's just convenience
10:36:41 <c_wraith> Maior: I think someone restarted work on hare only recently.  It's quite possible that person isn't a vim user, so didn't bother getting vim support working again.
10:36:55 <Cale> c_wraith: Yeah, it does seem to be
10:37:10 <Maior> c_wraith: ahh ok thanks
10:37:39 <c_wraith> Maior: try contacting him.  He might be able to give you info on what it'd take to get working again
10:39:22 <Maior> c_wraith: cheers
10:40:44 <quchen> chrisdone: What does that 'gindex' function do? It doesn't appear to be in Data#
10:41:12 <chrisdone> quchen: ah, you're reading the sauces =p it's in the same package, just a helper module
10:41:29 <Kiryx> can anyone decipher what actually happens here: "xs <- map read . words <$> getLine" ?
10:41:31 <quchen> Ah, an unexposed one. I see.
10:41:50 <chrisdone> https://github.com/chrisdone/present/blob/master/src/Data/Data/Indexed.hs
10:41:54 <quchen> ‚ô• haddock --internal
10:42:14 <c_wraith> Kiryx: it would be the same as :  xs' <- getline ; let xs = map read (words xs)
10:42:25 <c_wraith> err, that last one should be xs'
10:42:28 <chrisdone> not efficient or anything, just simple data stuff
10:42:42 <bss03> Kiryx: It's reading a space-separated list of somethings on one line from stdin.
10:42:49 * hackagebot filestore 0.6.0.2 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.6.0.2 (JohnMacFarlane)
10:42:51 * hackagebot hslua 0.3.12 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.12 (OmerAgacan)
10:43:00 <gamegoblin> Best way to find the last index of an element in an array?
10:43:08 <Kiryx> so "<$> getLine" is an expression version of  "xs <- getLine"
10:43:20 <bss03> (<$>) = fmap
10:43:25 <chrisdone> gamegoblin: a list or an array? most array types have a size function
10:43:26 <c_wraith> gamegoblin: array or list?
10:43:30 <gamegoblin> list
10:43:32 <gamegoblin> My bad
10:43:37 <chrisdone> c_wraith: i'm so faster than u
10:43:53 <c_wraith> and are you looking for the last index of an element equal to a target, or just the last index?
10:43:58 <noobelina> Where can I read chat history? Accidentally closed the chat room -.-
10:43:58 <chrisdone> gamegoblin: maybe fst . last . zip [0..] -- but that's partial
10:43:59 <bss03> gamegoblin: length l - 1?
10:44:10 <c_wraith> noobelina: the topic has a link to logs
10:44:16 <Kiryx> how does it know it's space separater ?
10:44:20 <Kiryx> separated*
10:44:25 <gamegoblin> The last occurence of a specific target element
10:44:31 <quchen> noobelina: ircbrowse.net with shiny interface etc
10:44:38 <gamegoblin> i.e. ‚Äúfind the index of the last 1337 in a list of numbers‚Äù
10:44:38 <c_wraith> > words "Hello there, Kiryx"
10:44:39 <lambdabot>  ["Hello","there,","Kiryx"]
10:44:47 <Kiryx> ah, ok
10:45:04 <Kiryx> the absolute last thing and I get it, what does the dot '.' do ?
10:45:17 <gamegoblin> Kiryx : Composes functions
10:45:36 <c_wraith> map read . words === \x -> map read (words x)
10:46:00 <gamegoblin> Kiryx: if you do f = g . h, that‚Äôs the same as f x = g (h x)
10:46:19 <Kiryx> why should I avoid parentheses ?
10:46:33 <quchen> You should avoid parentheses?
10:47:01 <jakedust> (not (avoid (parens)))
10:47:44 <c_wraith> gamegoblin: something like...  \x -> fst . last . filter ((== x) . snd) . zipWith [0..]
10:47:58 <c_wraith> gamegoblin: though you need something smarter than that if the target may not be in the list
10:48:12 <c_wraith> gamegoblin: if the target isn't the list, last will be an error
10:48:23 <quchen> findIndex p . reverse?
10:48:24 <chrisdone> c_wraith: actually maybe lookup is good
10:48:32 <chrisdone> lookup n . zip [0..]
10:48:39 <c_wraith> chrisdone: if you throw in a reverse
10:48:44 <c_wraith> chrisdone: remember, *last*
10:49:06 <quchen> You have to walk the entire list anyway, so reverse doesn't make things worse
10:49:12 <chrisdone> there're duplicates?
10:49:32 <gamegoblin> I feel like this could also be done with a fold
10:49:35 <gamegoblin> a fold and a zip
10:49:38 <c_wraith> eh.  reverse isn't a good consumer, so it always can make things worse
10:49:42 <gamegoblin> actually just a fold
10:50:05 <c_wraith> you could do it with foldr and a zip, yes
10:50:18 <c_wraith> or foldl without a zip.  Hmm.
10:50:22 <gamegoblin> exactly
10:50:30 <gamegoblin> foldl with a counter and an index in a tuple
10:50:54 <c_wraith> anyway, there.  you have a hundred options now. :)
10:51:07 <gamegoblin> As I always expect upon asking anything in this channel ;D
10:51:33 <i-tu> For substituting \ -> Œª (lambda), is there some rule for differentiating from backslash string escaping?
10:51:58 <c_wraith> i-tu: it's not in quotes?
10:52:45 <i-tu> c_wraith: so if it's not in quotes, it's a taken for granted lambda? thanks :)
10:52:51 * hackagebot zip-archive 0.2.2.1 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2.2.1 (JohnMacFarlane)
10:53:04 <c_wraith> i-tu: I guess you need to be a little more careful due to the single-quote case, and ' being a valid identifier character.  But you can do it.
10:53:16 <corgifex> also, comments
10:53:26 <corgifex> assuming this is a string parsing problem
10:53:46 <c_wraith> oh, yeah.  comments.  But who uses *those*?
10:54:18 <i-tu> I'm making a font for haskell, and I want to add glyph substitution for some characters
10:54:21 <i-tu> https://github.com/i-tu/Hasklig/
10:54:32 <corgifex> > let (---+) = () in 42 ---- yo
10:54:34 <lambdabot>  42
10:55:47 <corgifex> i-tu: I think \ is much superior to lambda
10:56:00 <corgifex> and you have to be careful with . because unicode has an actual ring operator
10:56:24 <vanila> i-tu, some text editors (have an option to) do that substitution - maybe you could leave it as a preprocessing thing rather than part oft he font?
10:56:45 <c_wraith> corgifex: at least with a ligature system, you can just not use it, and not have to face the terribleness of characters displaying stupidly.  Unlike character substitution systems.
10:57:07 <i-tu> there's no substitution - it would just display the slash as a lambda
10:57:10 <bss03> vanilla: The goal is to have it work many text editors, not just one, I think.  It already works in nearly a dozen, IIRC.
11:01:01 <chrisdone> i-tu: that's pretty interesting!
11:01:43 <chrisdone> NO EMACS SUPPORT!?
11:02:19 <chrisdone> surely you must be joking, mr i-tuman
11:02:35 <i-tu> chrisone: I wish I was :(
11:03:42 <fuzzy_id> i want a function (echoList :: Show a => [a] -> IO [a]) which simply echos the elements as they are processed from the list
11:04:09 <fuzzy_id> such that e.g. `echoList [1..]` is possible
11:04:15 <corgifex> mapM_ print
11:04:28 <corgifex> wait, IO [a]?
11:04:32 <i-tu> chrisdone: but thanks! hopefully someone will compile a GUI of emacs with support
11:04:37 <fuzzy_id> it's not possible right?
11:04:51 <fuzzy_id> should be [IO a] or something like that
11:05:00 <notdan> fuzzy_id: well.. it will loop forever, trying to print the numbers
11:05:08 <notdan> yeah, [IO a] is possible
11:05:19 <ReinH> well, it's possible, but things like print are IO () actions so recovering the a will be a bit of extra work
11:05:28 <ReinH> :t mapM_ print
11:05:29 <lambdabot> Show a => [a] -> IO ()
11:05:31 <notdan> that's just map (\x -> do print x; return x)
11:05:35 <notdan> :t map (\x -> do print x; return x)
11:05:36 <lambdabot> Show b => [b] -> [IO b]
11:05:38 <nisstyre> usually you want the opposite
11:06:02 <ReinH> notdan: that won't print anything :)
11:06:03 <fuzzy_id> i want it lazy‚Ä¶
11:06:15 <monochrom> fuzzy_id: what does "echo" mean? does it just mean outputting to stdout?
11:06:24 <corgifex> fuzzy_id: it is lazy
11:06:26 <notdan> ReinH: I know, but it will work with infinite lists
11:06:26 <fuzzy_id> yep
11:06:40 <ReinH> notdan: fsvo "work" that doesn't include "printing anything"?
11:06:47 <monochrom> then just use "mapM_ print" and accept the type Show a => [a] -> IO ()
11:07:01 <notdan> well
11:07:06 <notdan> I mean
11:07:14 <fuzzy_id> that won't work with [1..], will it?
11:07:15 <ReinH> or mapM (\x -> do { print x; return x })
11:07:22 <monochrom> it works
11:07:25 <notdan> if you want a function like that to work on infinite lists it is going to loop
11:07:25 <ReinH> if you really want to get back an IO [a]
11:07:32 <nisstyre> :t map return ["a", "b", "c"] :: [IO String]
11:07:33 <lambdabot> [IO String]
11:07:38 <monochrom> I am against IO [a] for this.
11:07:41 <notdan> tbh, I don't understand the required specification
11:07:50 <ReinH> monochrom: in favor of what?
11:07:56 <monochrom> in favour of IO ()
11:08:00 <ReinH> monochrom: me too
11:08:03 <corgifex> fuzzy_id: "doesn't work" is meaningless
11:08:07 <corgifex> explain what you mean
11:08:43 <nisstyre> you can of course use 'print' there but then the type becomes [IO ()]
11:08:48 <nisstyre> which is fairly useless
11:08:55 <fuzzy_id> ok, more specifically: i'm querying the file system producing a list of all files, so the list is huge and could probably not fit entirely in memory
11:08:55 <nisstyre> might as well use mapM
11:09:10 <fuzzy_id> so i want a function which echos the files as they are processed
11:09:15 <nisstyre> fuzzy_id: I seriously doubt it will not fit
11:09:25 <corgifex> fuzzy_id: wrong end. how are you going to get [a] in the first place?
11:09:30 <nisstyre> your average filename is like 20 bytes maybe?
11:09:32 <fuzzy_id> but i want that seperated from the actual worker function‚Ä¶
11:09:48 <corgifex> the tricky bit is the producer, not the consumer
11:09:53 <monochrom> that is vastly different. the laziness should be at querying the file system already. nothing to do with echoing.
11:10:20 <nisstyre> or you could just use a shell script for whatever it is
11:10:28 <nisstyre> maybe even a single call to find
11:10:30 <fuzzy_id> monochrom: good point, haven't thought about that sufficiently, yet
11:10:45 <monochrom> you may need unsafeInterleaveIO for this
11:11:27 <corgifex> inb4 pipes
11:11:30 <nisstyre> fuzzy_id: what's the problem you're trying to solve?
11:12:05 <fuzzy_id> monochrom: i think that was the right pointer, thanks!
11:12:34 <fuzzy_id> nisstyre: i write a deduplication tool for our rsnapshot backup routines
11:12:55 * hackagebot mediawiki2latex 7.5 - Convert MediaWiki text to LaTeX  http://hackage.haskell.org/package/mediawiki2latex-7.5 (dhun)
11:12:56 <nisstyre> fuzzy_id: that sounds like something your filesystem should be taking care of
11:13:01 <nisstyre> most do COW, copy-on-write now
11:13:04 <nisstyre> or at least good ones
11:13:17 <corgifex> oh, I have one of those somewhere
11:13:30 <nisstyre> that means it will not store duplicates of copies
11:13:39 <nisstyre> until you change one of them, hence "copy on write"
11:13:44 <corgifex> it's split into two parts, a duplicate finder and a remover
11:14:00 <corgifex> (they're also written in perl)
11:14:16 <fuzzy_id> yeah, there are several tools out there, but they don't exactly fit our requirements
11:14:16 <ReinH> monochrom: or Debug.Trace if you want to let someone else do your unsafe IO for you?
11:14:25 <fuzzy_id> especially when it comes to speed‚Ä¶
11:14:38 <nisstyre> fuzzy_id: xfs isn't fast enough?
11:14:52 <corgifex> in my case speed = 1 / memory usage
11:14:54 <monochrom> Debug.Trace only does unsafe O. we need unsafe I.
11:14:58 <fuzzy_id> nisstyre: COW is not a possibility here‚Ä¶
11:15:03 <nisstyre> fuzzy_id: okay fair enough
11:15:32 <corgifex> because the slow part was dealing with that duplicate finder data structure (and swapping to disk, even)
11:15:58 <monochrom> there was a huge thread on both haskell-cafe and reddit and stackoverflow on incrementally enumerating directory trees
11:16:30 <corgifex> my tool didn't read the directories itself; it just took input from find
11:16:31 <nisstyre> monochrom: I tried my hand at it, rewrote it in Racket and it was way easier >.>, still probably not great
11:16:36 <nisstyre> find is still a million times faster
11:16:53 <chrisdone> monochrom: were conduits involved?
11:17:07 <chrisdone> and pipes and other continuation-based approaches
11:17:07 <monochrom> no, conduits had not been invented
11:17:16 <monochrom> pipes had not been invented either
11:17:45 <chrisdone> how did sewage systems work back in those days, grandpa monochrom?
11:17:58 * hackagebot simple-form 0.4.2 - Forms that configure themselves based on type  http://hackage.haskell.org/package/simple-form-0.4.2 (StephenWeber)
11:18:21 <quchen> Pipes is continuation-based?
11:18:35 <monochrom> oleg's iteratees had been invented, but it couldn't be applied. you need the standard library to offer you an option of reading just one unit, before any of the inventions apply
11:18:35 <ReinH> we used iteratees uphill both ways
11:18:36 <ReinH> in the snow
11:19:00 <chrisdone> quchen: i don't know, i only know conduits =)
11:19:07 <monochrom> and the standard library offers only System.Directory.getDirectoryContent which isn't incremental
11:19:27 <quchen> I always assumed pipes were something with free monads and that's it. Maybe it's a free monad to build something evaluated using Cont in the end.
11:19:54 <corgifex> getDirectoryContents is incremental in the sense that it only does one level
11:20:08 <monochrom> if you go less standard, System.Posix offers openDir, readDir, closeDir which could be combined with iteratees, conduits, or pipes.
11:20:28 <chrisdone> reinh: oleg used to write his papers in the sand and laugh as we frantically tried to read them before tide came in
11:20:40 <ReinH> hahaha
11:22:59 * hackagebot Yampa 0.9.5 - Library for programming hybrid systems.  http://hackage.haskell.org/package/Yampa-0.9.5 (IvanPerez)
11:23:01 * hackagebot ripple-federation 0.1 - Utilities and types to work with the Ripple federation protocol  http://hackage.haskell.org/package/ripple-federation-0.1 (StephenWeber)
11:23:03 <corgifex> isn't readdir just a buffering wrapper around getdents, which returns a whole chunk of entries?
11:24:34 <monochrom> yes. caller controls chunk size.
11:26:00 <ski> shachaf : hm, i think `type (Functor f, Functor g) => Natural f g = forall a. f a -> g a' is probably better
11:28:25 <chrisdone> ski: does that not make more sense as a type class type function?
11:28:51 <benmachine> I remember that listing-directory thread, there were hylomorphisms
11:29:10 <chrisdone> ski: eh, i guess it's useful like that. n/m
11:29:46 <ski> chrisdone : if you mean `class (Functor f,Functor g) => Natural f g where eta :: forall a. f a -> g a', then emphatically not -- that would require canonically selecting at most one natural transformation between any two functors ..
11:31:09 <chrisdone> ski: right, the type alias is completely open
11:33:02 * hackagebot pointedlist 0.6.1 - A zipper-like comonad which works as a list, tracking a position.  http://hackage.haskell.org/package/pointedlist-0.6.1 (fread2281)
11:33:22 <ski> anyway `type (Functor f, Functor g) => Natural f g = forall a. f a -> g a' vs. `type Natural f g = (Functor f, Functor g) => forall a. f a -> g a' is a somewhat subtle distinction
11:34:18 <edwardk> i tend to prefer not explicitly requiring the user to pass witnesses of functoriality with the natural transformation
11:34:29 <edwardk> more applications, fewer unused dictonaries flying around
11:38:03 * hackagebot mediawiki2latex 7.6 - Convert MediaWiki text to LaTeX  http://hackage.haskell.org/package/mediawiki2latex-7.6 (dhun)
11:38:05 <guesting> Can someone explain to me the difference between Elm and Threepenny-gui and why someone should use one or the other?
11:39:21 <quchen> guesting: Elm is a standalone language to program interactive websites. Threepenni-GUI is a Haskell library to build a GUI that only happens to run in the browser.
11:39:30 <ski> if we define `P' by `forall x. P(x) <=> (Q(x) => ..x..)', then it means that for `x' not satisfying `Q', `P' is automatically true (and if we define it by `forall x. P(x) <=> (Q(x) /\ ..x..)', then it means that for `x' not satisfying `Q', `P' is automatically false) -- otoh, if we define it by `forall x. Q(x) => (P(x) <=> ..x..)', then we're silent about whether `P(x)' holds. we simply haven't defined it (yet, at least)
11:40:19 <guesting> quchen: So Elm has no interaction with Haskell at all in the sense that I can give it a Haskell function ?
11:41:00 <monochrom> ski: are you sure you have no typo? you define P by a formula that uses P again.
11:41:05 <ski> (basically, in the last definition of `P', `Q' is a *presupposition* on `P')
11:41:27 <monochrom> oh nevermind, I see what you mean now
11:41:43 <quchen> guesting: Maybe Elm allows calling Haskell via some FFI mechanism, but I don't know about it. Taken on their own, Haskell and Elm are completely independent.
11:41:49 <ski> monochrom : the formulae are what is assumed to be true, not what `P' is defined to be equivalent to
11:42:09 <monochrom> "forall x. Q(x) => (P(x) <=> ..x..)" could be called an axiom
11:42:16 <ski> (er, `Q' is a *presupposition* on `x', in `P(x)', i mean)
11:42:21 <ski> monochrom : yes
11:42:36 <guesting> quchen: I see. It seems like threepenny gui is more appropriate then. I just need to learn how to make it pretty ahah
11:43:03 * hackagebot data-r-tree 0.0.1.0 - R-Tree is a spartial data structure similar to Quadtrees or B-Trees.  http://hackage.haskell.org/package/data-r-tree-0.0.1.0 (SebastianPhilipp)
11:43:04 <ski> just like `(x:xs) ++ ys = x : (xs ++ ys)' (with implicit wrapping `forall x,xs,ys. ' understood) can be called an axiom
11:43:28 <ski> it's a defining equation
11:43:40 <monochrom> sometimes, we still call it a definition. we just accept that P is partially defined. when Q(x) is false, we say that we don't know what happens to P(x). when Q(x) holds, we know everything about P(x).
11:44:05 <ski> the three formulae above are (alternative) defining (universal, and for the last case, conditional) equivalences
11:44:09 <MitchellSalad> is it possible to do generic programming on a type with a loop? (such as a control flow graph of a language with backloops)
11:44:22 <ski> monochrom : right
11:44:42 <monochrom> for example: (n /= 0) => (whee(n) <=> 10 is divisible by n)
11:45:20 <monochrom> and we leave it that way because we don't want to entertain "what does it mean to say 10 is divisble by 0"
11:46:02 <ski> if we use the last alternative for defining `P', then (assuming the domain/type of `x' here is `A'), the definition establishes (given `Q : A -> Prop', say) the typing `P : (x : A) -> Q(x) => Prop' (a dependent type)
11:46:03 <heatsink> It is possible to use cyclic data structures, MitchellSalad.  Generic programming doesn't require data structures to be acyclic.
11:46:30 <benmachine> 0 is a maximal element in the divisibility partial order
11:46:41 <ski> if we later extend the definition of `P' to cover also the cases where `Q' fails, then we have extended the typing to `P : A -> Prop'
11:46:44 <quchen> Does installing the 'llvm' package fail for anyone else since 7.8? It seems some definition is missing. Build log: http://lpaste.net/103231
11:47:02 <ski> monochrom : yes, exactly
11:47:39 <monochrom> for benmachine's benefit: second example: (n /= 0) => (happy(n) <=> 10/n = 5)
11:47:51 * ski grins
11:48:08 * hackagebot mediawiki2latex 7.7 - Convert MediaWiki text to LaTeX  http://hackage.haskell.org/package/mediawiki2latex-7.7 (dhun)
11:48:46 <benmachine> monochrom: don't mind me, just making observations
11:48:54 <EvanR> hey can someone please explain this type signature to me
11:48:58 <EvanR> ray :: (VectorSpace a, Scalar a ~ T) => a -> a -> Signal a
11:48:59 <EvanR> ray a m = integral a (constant m)
11:49:18 <ski> so .. with the "presupposition" alternative, the `Q(x) =>' condition appears in the *type* of `P' -- which doesn't happen with the two alternatives which wrap the "main definiens" in `Q(x) =>' or `Q(x) /\'
11:49:59 <bms1> EvanR: the ~ operator means the two types are equivalent; essentially T = Scalar a
11:50:11 <ski> monochrom : it's also useful here to use the dependent formation rules for `=>' and `/\'
11:50:25 <EvanR> bms1: thats what i was hoping it meant, since thats what i wanted
11:51:03 <ski> monochrom : if `A' is well-formed (including well-typed); and *assuming* `A' is true, `B' is well-formed; then `A /\ B' and `A => B' are well-formed
11:51:51 <ski> monochrom : this makes sure `10 / n' is actually well-formed in `(n /= 0) => (happy(n) <=> 10/n = 5)'
11:52:35 <afrikka> Is anyone working on a simpler implementation of Haskell?  One with fewer types, smaller footprint.
11:53:10 * hackagebot mediawiki2latex 7.8 - Convert MediaWiki text to LaTeX  http://hackage.haskell.org/package/mediawiki2latex-7.8 (dhun)
11:53:31 <monochrom> does Elm count as fewer types, smaller footprint? :)
11:54:30 <vanila> oh come on GHC is only a gigabyte
11:54:35 <afrikka> I will look at elm, thank you!  I have seen livescript, but doesn't appear to be actively developed.
11:54:44 <monochrom> but GHC has more types, not fewer types
11:56:38 <afrikka> Also livescript isn't "small footprint" either, since you need nodejs as well as other dependencies.
11:57:13 <monochrom> regrettably, "elm" was also a name of an archaic email program
11:57:14 <augur> OK EVERYBODY HOLD UP
11:57:22 <augur> LEMME READ WHAT SKI'S BEEN SAYIN
11:57:38 <monochrom> you can just use the pgup key, you know
11:57:49 <EvanR> then maybe my issue is with type synonym instances
11:58:18 * hackagebot mediawiki2latex 7.9 - Convert MediaWiki text to LaTeX  http://hackage.haskell.org/package/mediawiki2latex-7.9 (dhun)
11:58:21 <afrikka> monochrom: haha, I use mutt for mail, a long-lost spirutual descendent of elm/pine/mail
11:58:41 <augur> mm
11:58:48 <EvanR> type R2 = (R,R)
11:58:49 <augur> ski: i dont think thats true really
11:58:50 <EvanR> instance VectorSpace R2 where type Scalar R2 = R
11:58:59 <EvanR> would this make sense
11:59:24 <augur> ski: at least in that, its not a presupposition in the linguistic sense
12:00:00 <augur> ski: a presupposition on P is more, something that has to be true for P(x) to be well-formed in the first place
12:00:23 <dwcook> augur, like "Have you stopped beating your wife?"?
12:00:33 <dwcook> having a presupposition of "you beat your wife
12:00:36 <augur> dwcook: yes, thats a classic presupposition example
12:01:05 <augur> ski: with your Q example tho, Q(x) doesnt have to be true for P(x) to be true
12:01:14 <monochrom> I think ski's scheme already models "something that has to be true for P(x) to be well-formed in the first place", or as close as you can get with dependent types
12:01:16 <ski> well, afaiui, the definition `happy(n) <=> 10/n = 5' of `happy' surely presupposes that `n' is nonzero (for `happy(n)' to be well-formed, i.e.) -- which in my understanding seems to correspond to the examples i've seen in linguistics -- i'm interested in hearing feedback and possible corrections
12:01:22 <augur> ski: merely, if Q(x) is true, the P(x) and ...x... agree
12:01:35 <augur> ski: whereas if Q(x) is false, then maybe P(x) and ...x... agree, maybe they dont
12:01:45 <augur> but in both cases, P(x) may still be true/false
12:02:03 <augur> a presupposition, on the other hand, is something which is a precondition for the possibility of truth or falsity
12:02:16 <ski> augur : well, given the typing `P : (x : A) -> Q(x) => Prop', `P(x)' isn't well-formed (well-typed) unless `Q(x)' is true
12:02:18 <monochrom> happy(0) is both unprovable and undisprovable. as far as logic is concerned, that is enough for me. if linguistics demands more than both unprovable and undisprovable, too bad, perhaps it's why I don't go into linguistics.
12:02:34 <augur> eg: "the largest triangle has four sides" is neither true or false, since there is no largest triangle
12:02:51 <augur> ski: right
12:03:02 <augur> if you're interpreting => as a type class constraint, yes
12:03:05 <c_wraith> the largest triangle has sides of length n
12:03:06 <ski> augur : so i still don't see the distinction
12:03:11 <c_wraith> where n is larger than any other number
12:03:16 <augur> ski: but, thats not quite what you wrote before
12:03:16 <ski> augur : yes, or implicit argument
12:03:43 <augur> ski: here you're giving the type of P, whereas before you were merely talking about P
12:04:02 <augur> ski: consider this:   Q(x) => (P(x) <=> P(x))
12:04:05 <augur> this will always be true
12:04:46 <augur> Q(x) is really irrelevant
12:04:48 <ski> augur : i agree that if we're *quantifying* (say universally) over `P', and *assuming* `forall x. Q(x) => (P(x) <=> ..x..)', *then* "whereas if Q(x) is false, then maybe P(x) and ...x... agree, maybe they dont" holds
12:05:00 <augur> its true also if yo replace Q(x) with ~Q(x)
12:05:14 <augur> so Q(x) isnt really a prespposition at all
12:05:31 <augur> ski: no we dont have to quantify over P
12:05:34 <augur> just pick some P
12:05:40 <monochrom> wait, ski's scheme makes sures that ~Q(x) => (P(x) <=> P(x)) doesn't even type-check, no?
12:05:55 <afrikka> have a good weekend
12:06:05 <augur> monochrom: if you give P the type that he mentioned recently, yes. but if you dont do that, then no
12:06:28 <ski> augur : however, if we're using `forall x. Q(x) => (P(x) <=> ..x..)' as a (in this case partial) *definition* of `P', i don't think one can argue like that -- in that case we're not "getting `P' from somewhere else, plus perhaps also getting some extra knowledge about `P'" -- outside the subset of `A' characterized by `Q', `P' is simply not defined, so `P(x)' isn't (at least not yet) well-formed
12:06:54 <augur> ski: even so, partially-defined is not the same thing as "ill-formed" i would argue
12:06:54 <ski> isn't (at least not yet) well-formed, for an `x' for which `Q' fails, i mean
12:07:22 <ski> augur : if we later *augment* the definition to cover all of `A', then at that point `P(x)' would be wellformed even if `Q(x)' fails
12:07:25 <augur> there's a difference between "i dont know what the answer is, but there is an answer" and "there is no answer"
12:08:04 <monochrom> ok, so use the dependent type scheme that works, and be done with it
12:08:09 <augur> partial definitions are the former, arguably
12:08:18 <ski> augur : well, `forall x. Q(x) => (P(x) <=> P(x)' isn'
12:08:21 <augur> or perhaps a better way of saying it is
12:08:23 <monochrom> I am happy to agree "classical logic is not rich enough to do this" and move on.
12:08:30 <ski> t sutiable as a definition of `P' (partial or otherwise)
12:08:33 <augur> "there is no answer (as of now)" vs "there cannot be an answer ever"
12:08:47 <augur> presupposition failures are the latter
12:09:13 <ski> (it's not suitable since it's viciously circular)
12:09:17 <augur> "the largest triangle has four sides" is neither true nor false, and cannot ever be made to be true or false, since there is no largest triangle
12:09:34 <ski> (as an *assumption*, `forall x. Q(x) => (P(x) <=> P(x)' would be ok, though)
12:09:54 <DR6_> wouldn't it be vacuously true, precisely because there is no largest triangle?
12:09:59 <augur> so i think there's a big difference between partiality and failure to type check
12:10:10 <augur> DR6_: how can it be vacuously true?
12:10:29 <DR6_> the statement would be
12:10:30 <augur> DR6_: there is no such thing, so _it_ cant have four sides, since _it_ isnt
12:11:24 <ski> monochrom : "... ~Q(x) => (P(x) <=> P(x)) doesn't even type-check, no?" -- given a preexisting `P' ? or taken as a supposed definition of `P' ?
12:11:24 <DR6_> but precisely because of that
12:11:24 <DR6_> I mean
12:11:24 <DR6_> your statement is equivalent to
12:11:24 <augur> DR6_: no no
12:11:24 <augur> dont claim equivalence
12:11:24 <DR6_> is_largest_triangle(x) => has_four_sides(p)
12:11:26 <DR6_> *x
12:11:27 <augur> we can play that game all day
12:11:43 <DR6_> in classical logic this works
12:11:51 <augur> except it doesnt
12:11:59 <augur> since "the largest triangle has four sides" isnt true!
12:12:08 <ski> given a preexisting `P', it's just an assumption (or conjunctive condition, if you want that instead) -- taken as a supposed definition it fails to define, because it's not of the appropriate syntactical shape to be a definition (cf. strictly positive check and termination check in Agda)
12:12:46 <DR6_> augur: of course that isn't true
12:12:48 <augur> DR6_: fwiw, russell believed that "the" was existential, not universal, quantification
12:12:50 <DR6_> precisely because of that
12:13:00 <ski> augur : "even so, partially-defined is not the same thing as \"ill-formed\" i would argue" -- maybe, maybe not -- this is where i might learn something, i think ;)
12:13:16 <augur> ski: im not sure what there is to learn
12:13:25 <DR6_> so you don't believe my statement is equal yo yours
12:13:25 <Tomsik> Hello, is there a an alternative to plethora of lens operators? A package with them renamed to something meaningful and textual?
12:13:31 <augur> DR6_: no, i dont.
12:13:42 <DR6_> ok then
12:13:45 <augur> your statement is true, my statement is not!
12:14:00 <augur> DR6_: and russell's statement is false, whereas mine is not!
12:14:47 <dwcook> Tomsik, yes, lens has them
12:14:54 <DarkLinkXXXX> Is haskell practical for embedded devices?
12:15:09 <augur> ski: consider this: lets assume P : (x : X) -> Q x => Prop
12:15:28 <DR6_> augur: I don't think I follow your logic
12:15:33 <ski> augur : "there's a difference between \"i dont know what the answer is, but there is an answer\" and \"there is no answer\"" -- yes, and afaics, thats the distinction between stating a condition on knowledged on a preexisting `P' and stating a condition on a definition of `P' (with the option of possibly later extending the definition to also cover the case where the condition fails)
12:15:36 <edwardk> Tomsik: you can write code with lens without ever using or seeing an operator. Control.Lens.Combinators skips the operators
12:15:46 <augur> ski: P can be fully defined for x and Q x, but it still does not mean that P(a) is true or false
12:15:47 <DR6_> if your statement isn't s_largest_triangle(x) => has_four_sides(p)
12:15:49 <DR6_> what is it?
12:15:59 <ski> augur : "so i think there's a big difference between partiality and failure to type check" -- maybe, i'm not sure
12:16:02 <augur> DR6_: my statement is   "the largest triangle has four sides"!
12:16:18 <augur> ski: let me change the example, if you'll permit
12:16:29 <DR6_> can't you write that more formally?
12:16:33 <augur> ski: can we agree that this function is fully defined:   \() : Void -> One
12:16:49 <augur> DR6_: nope, that's all you get. :)
12:17:04 <DR6_> then how can you claim you can analize it logically?
12:17:05 <augur> ski: using agda, of course
12:17:07 <ski> DR6_ : i don't agree with your `is_largest_triangle(x) => has_four_sides(p)' -- we need real presuppositions
12:17:20 <augur> DR6_: i never claimed i could. i said it's simply neither true nor false. :)
12:17:50 <ski> DR6_,augur : "russell believed that \"the\" was existential, not universal, quantification" -- *nod*, and i believe that's also wrong
12:17:58 <augur> DR6_: i can perfectly well judge its truth or falsity. im a native speaker of english and i understand what it means, even if i cant give you a logical representation of it
12:18:08 <augur> ski: indeed, russell's view is also wrong.
12:18:18 <DR6_> so you don't believe that statement is representable in first order logic?
12:18:27 <augur> DR6_: oh i never said that
12:18:33 <Tomsik> Thanks
12:18:42 <DR6_> so you believe it can be represented, but you don't know how to?
12:18:51 <augur> DR6_: tho i WILL say it now :)
12:19:05 <Tomsik> Though documentation for this module on hackage could be more useful
12:19:13 <augur> the problem with the statement is that it has a presupposition, which is the big mystery
12:19:32 <ski> DR6_ : "can't you write that more formally?" -- *how* to render it more formally is exactly the issue ! :)
12:19:43 <DR6_> I said a way
12:19:46 <augur> DR6_: i have some ideas for how to represent presuppositions, but they're not very useful here, since the issue isnt how to code things up
12:19:47 <DR6_> in first order logic
12:19:52 <DR6_> just llike what I did
12:20:03 <augur> ski: i disagree that the issue is about coding it formally
12:20:11 <augur> ski: i think the issue is more fundamental than that
12:20:11 * ski is currently lagging behind in the conversation about 5 minutes ..
12:20:17 <DR6_> then how do you analize it mathematically?
12:20:28 <corgifex> :3
12:20:33 <augur> DR6_: you dont
12:20:41 <jle`> i wish there was some sort of Bool -> a -> Maybe a, that is Just x when true and Nothing when false
12:20:43 <jle`> hm
12:20:43 <ski> augur : i don't follow what you mean by "it still does not mean that P(a) is true or false"
12:20:46 <DR6_> then how are you analizing it?
12:20:51 <augur> DR6_: ?
12:20:59 <augur> ski: first lets just deal with the empty function
12:21:02 <ski> augur : yes, `\() : Void -> One' is fully defined
12:21:20 <jle`> > let f b x = x <$ when b in (f True 4, f False 8)
12:21:22 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable m1)
12:21:22 <lambdabot>    arising from a use of ‚ÄòM733856028685470825824207.show_M7338560286854708258...
12:21:22 <lambdabot>  The type variable ‚Äòm1‚Äô is ambiguous
12:21:22 <lambdabot>  Note: there are several potential instances:
12:21:22 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Complex.Complex
12:21:34 <augur> ski: ok. now: is there any value x for which (\()) x : One
12:21:43 <jle`> > let f b x = x <$ guard b in (f True 4, f False 8)
12:21:45 <lambdabot>  No instance for (GHC.Show.Show (f1 a1))
12:21:45 <lambdabot>    arising from a use of ‚ÄòM97100779824925157224219.show_M97100779824925157224...
12:21:47 <lambdabot>  The type variables ‚Äòf1‚Äô, ‚Äòa1‚Äô are ambiguous
12:21:49 <lambdabot>  Note: there are several potential instances:
12:21:51 <lambdabot>    instance [safe] GHC.Show.Show a =>
12:22:06 <vanila> what do these numberes mean
12:22:28 <ski> DR6_ : "so you don't believe that statement is representable in first order logic?" -- i think first order logic has no notion of (or way to represent/simulate) presuppositions
12:22:31 <supki> :t flip $ bool Nothing . Just
12:22:32 <lambdabot> Bool -> a -> Maybe a
12:22:37 <augur> ski: no, right. ok so now:   suppose   foo : Void => One   is there any way for foo to typecheck ever?
12:22:44 <ski> DR6_ : .. at least for standard accounts of FOL
12:23:03 <quchen> > let f :: Bool -> a -> Maybe a; f b x = x <$ guard b in (f True 4, f False 8)
12:23:05 <lambdabot>  (Just 4,Nothing)
12:23:06 <DR6_> ski: not directly, admittedly
12:23:26 <jle`> > let f :: Bool -> a -> Maybe a; f b x = x <$ guard b in (f True 4, f False 8)
12:23:27 <lambdabot>  (Just 4,Nothing)
12:23:35 <jle`> oh ty quchen
12:23:37 <DR6_> but I believe my statement is logically equivalent to the statement in englishenglish statement
12:23:45 <ski> augur : "is there any value x for which (\()) x : One" -- in the empty context, we believe the answer is "no"
12:23:52 <quchen> jle`: The problem is that the MonadPlus you're using with the guard is undecidable without type sig
12:23:56 <augur> DR6_: and yet one is true and the other is not. therefore they cannot be equivalent
12:24:09 <augur> ski: right. so now with foo?
12:24:21 <DR6_> what was your argument to say the english one wasn't
12:24:37 <vanila> DR6_: the english statement isn't a well formed logical claim
12:24:39 <augur> DR6_: im a native speaker of english and im judging it as such
12:24:50 <jle`> quchen: hopefully it would be inferrable later in the program
12:24:56 <vanila> because it references an object that doesn't exist
12:24:57 <ski> augur : "suppose   foo : Void => One   is there any way for foo to typecheck ever?" -- depends if you mean it to typecheck with or without a `Void =>' presupposition (if that's what it is)
12:25:09 <augur> DR6_: if you'd like to move out of the domain of math, to a domain where we can be more certain of our intuitions, we can, but the result is the same
12:25:38 <DR6_> I don't believe our intuitions are something we should trust in these things
12:25:44 <quchen> :t let f b x = x <$ guard b in (f True 4, f False 8) -- jle`, it typechecks even without annotation. You just can't print it because it can't Show because it can't MonadPlus ;-)
12:25:45 <lambdabot> (MonadPlus f1, MonadPlus f, Num a1, Num a, Functor f1, Functor f) => (f a, f1 a1)
12:26:05 <jle`> that is a gnarly type signature
12:26:05 <augur> ski: just, can i use foo ever, in some program that type checks. eg, let x : One = foo in ...
12:26:10 <DR6_> our intuitions fail for edge cases like this
12:26:22 <quchen> jle`: At least the Functors will soon be nostalgia in there.
12:26:24 <augur> DR6_: ahh but there you're wrong
12:26:25 <ski> DR6_ : e.g. i don't like kludgey accounts that define reciprocal of zero to be zero (or the `iota' selection function on an empty set to be the empty set) -- and such generally doesn't work constructively anyway
12:26:38 <augur> DR6_: by definition our intuitions cannot fail, because or intuitions are what we're trying to model!
12:26:41 <jle`> quchen: heh
12:26:48 <jle`> still need to get used to the fact
12:26:50 <DR6_> augur: since when?
12:26:51 <ski> DR6_ : so it's clear you *at least* needs a multi-sorted logic
12:27:00 <augur> DR6_: since we were talking about what a sentence of english means :)
12:27:17 <augur> DR6_: there is no source of meaning EXCEPT our intuitions about truth/falsity/etc.
12:27:22 <DR6_> yes
12:27:24 <DR6_> a sentence
12:27:28 <DR6_> not a concept, or a thought
12:28:00 <augur> DR6_: use more words. stray NPs dont tell me much
12:28:11 <DR6_> woah that's a strong statement there
12:28:17 <DR6_> no other source of meaning?
12:28:32 * hackagebot purescript 0.4.20 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.20 (PhilFreeman)
12:28:34 <augur> DR6_: well, we can also look at behavior, but thats even harder to pin down
12:28:55 <ski> augur : "can i use foo ever" -- yes, obviously you can. e.g. say `bar : (Void => One) -> One; bar _ = Star'
12:29:11 <DR6_> I just took the sentence you gave at face value
12:29:30 <DR6_> and tried to assign it a logical truth value
12:29:36 <ski> augur : "eg, let x : One = foo in ..." -- *if* that's inside a context which is wrapped by `Void =>', then yes
12:29:37 <augur> ski: ok sorry, can you use it at type One even :P
12:29:49 <noobelina> is there a difference between && and `and`
12:29:49 <augur> DR6_: then you werent playing the game properly :)
12:30:02 <DR6_> I wasn't playing the game the way you wanted, maybe
12:30:06 <augur> ski: ok, so then, barring assumptions that provide us with what we need, the answer is no
12:30:21 <DR6_> I don't think your way of playing it was productive
12:30:27 <monochrom> noobelina, they are not even of the same type
12:30:28 <geekosaur> noobelina, and works on lists, not individual boolean expressions
12:30:34 <augur> DR6_: it's productive given the question at hand
12:30:46 <DR6_> what question?
12:30:46 <augur> DR6_: you just want to pretend that there's no problem to solve and call it a day
12:31:06 <augur> DR6_: the question of what "the largest triangle has four sides" means, and what presuppositions are
12:31:36 <DR6_> I answered with the most sensible meaning of the question
12:31:40 <ski> noobelina : `and' takes a list of `Bool'eans, `(&&)' takes two `Bool'eans
12:31:43 <DR6_> if it's not the meaning you wanted
12:31:47 <DR6_> that's something different
12:31:47 <augur> DR6_: and yet that answer is wrong.
12:31:55 <noobelina> ok
12:31:56 <augur> DR6_: its not about want
12:32:04 <DR6_> yes it is
12:32:15 <augur> DR6_: your proposal is falsified, and must be abandoned!
12:32:15 <DR6_> my meaning is a correct interpretation of the question
12:32:15 <ski> augur : "barring assumptions that provide us with what we need, the answer is no" -- *nod*
12:32:16 <jle`> :t and
12:32:17 <lambdabot> [Bool] -> Bool
12:32:18 <augur> thats just how science works
12:32:21 <jle`> :t (&&)
12:32:21 <lambdabot> Bool -> Bool -> Bool
12:32:29 <DR6_> unless you go from the axiom that the statement *must* be wrong
12:32:47 <augur> ski: ok, so: we have a fully defined function, foo, which is, never the less, not well typed
12:32:49 <monochrom> science? I thought it's linguistic.
12:33:06 <augur> monochrom: linguistics is a science
12:33:13 <augur> DR6_: what?
12:33:28 <monochrom> I agree to disagree
12:33:35 <augur> monochrom: why?
12:33:45 <augur> (i dont agree to disagree :p)
12:33:56 <ski> augur : well, `foo' taken at type `Void => One' is well-typed, but taken at type `One' isn't (assuming no free `Void' roaming in scope)
12:34:00 <DR6_> your argument is: the statement is wrong, my interpretation is right, therefore my interpretation is incorrect
12:34:05 <augur> ski: right
12:34:14 <ski> augur : which is why i'm coming back to implicit arguments ;)
12:34:44 <augur> DR6_: yes.
12:35:15 <DR6_> the conclusion only follows if you believe the statement is wrong prior
12:35:23 <DR6_> but my argument goes the other way
12:35:27 <ski> augur : .. so that with a suitable elaboration, those two uses of `foo' would actually be different expressions
12:35:29 <augur> DR6_: no, we just do some empirical work
12:35:36 <DR6_> "empirical"?
12:35:40 <augur> DR6_: we go out, and test whether people judge it to be true or false
12:35:58 <augur> ski: yes, of course
12:36:16 <augur> ski: but thats the point im trying to make: there is no way to make foo : One type check, even tho foo is fully defined
12:36:53 <augur> ski: which of course makes sense, since here, secretly, the difference is well-typed vs. provable
12:36:56 <DR6_> augur: yeah, I don't think that's enough
12:37:07 <augur> DR6_: that's all there is
12:37:19 <augur> DR6_: there is literally nothing beyond that that can be used
12:37:39 <DR6_> to make judgements, people use their prior beliefs
12:37:47 <augur> yes they do
12:38:01 <DR6_> so meanings depend on the beliefs of the person who makes the judgement
12:38:05 <DR6_> you will agree with me
12:38:08 <augur> yes it does
12:38:40 <augur> DR6_: but again, we can go outside of the domain of mathematics where you will definitely agree with me
12:38:41 <DR6_> actually, assigning a meaning is just believing that the sentence means X
12:38:50 <augur> DR6_: not quite
12:38:58 <vanila> it's a science
12:38:58 <DR6_> not quite?
12:39:12 <augur> DR6_: all of that is very intentional-sounding. like people think "whats the meaning of this, let me analyze" etc.
12:39:22 <augur> DR6_: like its a conscious act of assigning, etc.
12:39:30 <DR6_> it doesn't have to be conscious
12:39:40 <DR6_> but it's still a kind of belief
12:39:46 <DR6_> conscious or unconscious
12:39:48 <DR6_> right?
12:39:49 <augur> for some definition of belief, perhaps
12:40:02 <monochrom> this has gone on for too long
12:40:04 <augur> in so much as knowing how to walk is a kind of belief
12:40:11 <byorgey> I have no idea what is being argued about here, can it go to -blah please?
12:40:18 <augur> yeah thats a good idea
12:40:19 <monochrom> no, not even -blah. pm.
12:40:23 <augur> DR6_: to -blah!
12:40:33 <DR6_> okay
12:40:33 <ski> augur : "there is no way to make foo : One type check, even tho foo is fully defined" -- in my mind, that's similar to : there's no way to make `foo : List Void' type check, even though `foo', defined by `foo : {A : Set} -> List A; foo = Nil', is fully defined
12:40:59 <augur> ski: [] : List Void
12:41:00 <augur> =x
12:41:23 <augur> oh wait what
12:41:29 <augur> ski: that sentence doesnt make much sense
12:41:38 <ski> hm, i probably goofed that one up. mea culpa
12:42:58 <ski> hm, i had a vague idea, and i for some reason thought that this would be an instance of it, but it isn't
12:43:02 <ski> i stand corrected
12:43:22 <ski> (now, i'm not sure whether the vague idea makes sense)
12:44:08 <ski> augur : anyway, i'm not sure i follow "here, secretly, the difference is well-typed vs. provable"
12:45:07 * ski reaches the "to -blah!" note in the scrollback
12:46:26 <heatsink> Is it a bad idea to put QuickCheck property checks in a unit testing framework?
12:47:30 <monochrom> it is a good idea
12:48:02 <monochrom> put SmallCheck properties there, QuickCheck properties there, and hand-written tests there.
12:48:33 <heatsink> ok
12:49:34 * heatsink is still on page 2 of the smallcheck paper
12:50:47 <monochrom> there is no hurry. you don't have to add SmallCheck now. do it in the future.
12:56:13 <nh2> does anybody know how to use -ddump-asm with -fllvm?
12:58:00 <heatsink> nh2: You can use -S flag to create an assembly file
12:58:43 <nh2> heatsink: won't that give me the asm of the runtime and all used libs as well?
12:59:08 <nh2> ah no doesn't look like that, nice
13:01:02 <jakex> golf question, "10 foo" -> Just (10, "foo"). is there a shorter and/or more elegant way than this? let [x,y] = words line in (,) <$> readMay x <*> Just y
13:01:37 <begriffs> The binaries that ghc creates have absolute paths in them and I'm trying to override them but having problems. When I say "cabal configure --datadir=/foo/bar" it adds other junk onto the path like "/foo/bar/x86_64-linux-ghc-7.8.2/mylibrary". Can I force it to install to a specific spot and not make all the subdirs?
13:02:15 <jakex> > let [x,y] = words "10 foo" in (,) <$> readMay x <*> Just y
13:02:17 <lambdabot>  Not in scope: ‚ÄòreadMay‚Äô
13:02:51 <monochrom> it's called readMaybe, but I don't know whether lambdabot has it or not
13:03:12 <jakex> I am using readMay from the Safe package
13:03:21 <nh2> jakex: depends a bit on your requirements: I wouldn't be happy in the general case because the [x,y] = words ... can pattern match fail, but maybe you have guaranteed that it doesn't
13:03:52 <heatsink> > let ff = (\[(x,' ':s)]->Just(x,s)).reads
13:03:53 <lambdabot>  not an expression: ‚Äòlet ff = (\[(x,' ':s)]->Just(x,s)).reads‚Äô
13:03:53 <jakex> nh2 I do but good point.
13:04:00 <heatsink> @let ff = (\[(x,' ':s)]->Just(x,s)).reads
13:04:01 <lambdabot>  .L.hs:141:42:
13:04:02 <lambdabot>      No instance for (Read t0) arising from a use of ‚Äòreads‚Äô
13:04:02 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
13:04:02 <lambdabot>      Relevant bindings include
13:04:02 <lambdabot>        ff :: String -> Maybe (t0, [Char]) (bound at .L.hs:141:1)
13:04:14 <heatsink> @let ff = (\[(x,' ':s)]->Just(x,s)).reads :: String -> Maybe (Int, String)
13:04:16 <lambdabot>  Defined.
13:04:17 <monochrom> begriffs: $HOME/.cabal/config has lines for that, near the end
13:04:21 <heatsink> > ff "10 foo"
13:04:23 <lambdabot>  Just (10,"foo")
13:05:06 <jakex> oh wow reads fits this problem perfectly
13:05:43 <noobelina> How do I say to show this as a float? main = print $ div 3.0 2.0
13:06:07 <jakex> :t div
13:06:08 <monochrom> div is emphatically not float. use 3.0/2.0
13:06:08 <lambdabot> Integral a => a -> a -> a
13:06:20 <begriffs> monochrom: Thank you!! Looks like datasubdir in ~/.cabal/config is adding the stuff
13:06:23 <Iceland_jack> > 3.0 / 2.0
13:06:25 <lambdabot>  1.5
13:06:25 <jakex> that won't even compile I think
13:06:30 <Cale> Right, it won't.
13:07:05 <noobelina> ok
13:07:14 <Cale> What did you want the program to print?
13:07:19 <Cale> 1.5 or 1.0?
13:08:08 <Cale> You could write something like  main = print (fromIntegral (div 3 2))
13:08:11 <noobelina> jakex: yeah, i know it didn't compile, I thought it was because I hade t say f it was going to show as a double or single float :)
13:08:20 <Cale> main = print (fromIntegral (div 3 2) :: Double) -- rather
13:08:25 <monochrom> don't think too much
13:08:26 <noobelina> (because of the error message)
13:08:35 <noobelina> monochrom:why?
13:09:23 <monochrom> human thinking tends to leave reality
13:09:33 <noobelina> uh
13:09:38 <noobelina> and that's.. bad?
13:09:53 <\tim> What are some good examples of type level symbols?
13:10:10 <Iceland_jack> \tim: check out the upcoming overloaded record syntax
13:10:32 <monochrom> it is good if you're writing a novel. but you aren't writing a novel. you're writing a program to be run in reality.
13:10:54 <monochrom> a program that is also type-checked in reality.
13:11:26 <monochrom> are you a novelist? a poet?
13:11:31 <\tim> Iceland_jack: Have a link?
13:11:33 <noobelina> I dont understand why thinking is bad :)
13:11:36 <noobelina> just that
13:11:42 <monochrom> now you do
13:11:57 <Iceland_jack> \tim: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Design search for 'Symbol'
13:12:50 <monochrom> replace thinking by calculation. calculation using rules that have been checked against reality.
13:12:58 <jakex> heatsink thanks for the idea. taking advantage of Safe package I got this: (headMay . reads)
13:13:41 <jakex> it doesn't have pattern matching issues either, like my first attempt
13:13:45 <noobelina> no I dont
13:13:46 <monochrom> for example, to deduce types, do not think. calculuate. for example http://lpaste.net/99842
13:14:00 <jakex> unlike*
13:14:18 <noobelina> It's like a teacher I had several years ago. "You see everything upside down" I thought he was stupid...
13:14:32 <Algebr> is accurate to say that fmap is closed under composition?
13:14:38 <Algebr> is it*
13:15:13 <monochrom> do you want to write a program that you think works correctly, but fails in reality?
13:16:03 <noobelina> no
13:20:22 <shachaf> monochrom: prerequisite.xhtml is good.
13:21:23 <Algebr> if everyone agrees that Monads are instances of Functor, then why isn't it already this way and presumably that's a change coming in 7.10?
13:22:23 <heatsink> Algebr: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
13:22:27 <nh2> Algebr: because that took them longer to figure out than to come up with monads
13:22:56 <Algebr> But what's to figure out, isn't that the case already in category theory, that monads are functors?
13:23:01 <mandu> I wrote a program in a non monadic style which has many simple nested functions (top level functions calls simpler functions, etc...). Is it possible to put monad transformers, for example WriterT, on top level function so that it would be usable on nested function calls? Or is it only possible by changing the types of all ne nested functions aswell?
13:24:00 <\tim> Algebr: Its coming https://ghc.haskell.org/trac/ghc/browser/ghc/libraries/base/GHC/Base.lhs
13:24:28 <mandu> Like this SO comment suggests http://stackoverflow.com/questions/22828137/how-do-i-use-the-supply-monad-to-create-a-function-that-generates-globally-uniqu#comment34875318_22828427
13:24:30 <nh2> mandu: I'm not 100% sure I understand your thing right but yes, you probably have to change the call sites and the function types when you want to make them monadic
13:25:13 <nh2> mandu: however, once you have them monadic, changing the transformer stack is less invasive; the pure vs some-monad change is what will make most of the effort
13:26:11 <\tim> Algebr: https://ghc.haskell.org/trac/ghc/browser/ghc/libraries/base/GHC/Base.lhs?rev=88c9403264950326e39a05f262bbbb069cf12977#L382
13:28:16 <mandu> nh2: so for example in each level where I need an error handling, I need to specify a separate monad transformer stack? One upper level stack is not possible?
13:30:13 <Cale> There's something about the whole way of thinking in terms of "stacks" of monad transformers which I find distasteful
13:31:04 <Cale> When you're writing the main part of your program, if you can see bare monad transformers, you're doing it wrong. (at least in my opinion)
13:32:40 <Cale> They can be useful for implementing particular monads, but those monads should be part of a library which hides the implementation in terms of monad transformers and presents a clean interface which doesn't involve explicitly lifting things.
13:32:51 <chrisw_> What's a decent way to pass information between the parts of a compiler? I have a parsing stage, SSA generation, type checking, register allocation, and finally code generation. I'm thinking about making a CompilerState datatype and using the State monad.
13:32:56 <Cale> (at least hopefully a majority of the time)
13:33:24 <Cale> mandu: If you have a pure implementation, why not use something like Either for errors?
13:34:24 <dbelange> Cale do u liek coalgebras
13:35:29 <Cale> dbelange: sure, I guess :)
13:35:57 <dbelange> have you seen uses for coinduction outside of automata theory
13:36:03 <flazz> ghci complains that "module 'X' is not interpreted when calling :ctags. any idea why?
13:36:12 <mandu> Cale: actually I need Supply monad for naming variables, I just thought that writer/error handling would have been easier to start with
13:39:07 <monochrom> I have seen uses of coinduction for Haskell's infinite lists. does that count as outside automata theory?
13:39:10 <Cale> dbelange: Yes. There are cases in higher category theory where coinductive arguments simplify things a good deal. Coinduction is also important in total functional programming if you want to reason about programs which don't terminate.
13:39:33 <monochrom> (also, why is it not "automaton theory"? compare with "group theory" not "groups theory")
13:39:50 <Cale> and yeah, all the things we do in Haskell with lazy infinite structures are secretly coinductive
13:40:51 <corgifex> because english likes to singularize plurals
13:40:58 <corgifex> especially foreign ones
13:41:11 <corgifex> "a visa", "an alumni", "a criteria", ...
13:41:17 <flazz> might be a UK/US thing, math vs maths
13:41:31 <shachaf> Clearly it should be "a criterium".
13:41:39 <dbelange> Cale: interesting, thanks.  I may bug you later
13:41:51 <Cale> Well, there's the "theory of groups"
13:42:05 <Cale> I would expect "automaton theory" and "theory of automata"
13:42:37 <monochrom> yeah, theory of <plural here> is normal
13:42:38 <nh2> mandu: I think what you ask needs some example, but my intuitive answer is no, you don't need separate transformer stacks, and you can write the code that belongs together in the same stacked monad
13:43:27 <corgifex> oh, recently seen in a comment: "a larvae"
13:49:45 <Anarchos> who uses ghc ?
13:49:53 <monochrom> I use ghc
13:50:05 <monochrom> are you going to kill me?
13:50:11 <silasm> Anarchos: who doesn't is probably a question with a shorter answer.
13:50:14 <byorgey> Anarchos: people who want to compile Haskell programs, generally
13:50:25 <silasm> in this channel, at least.
13:50:34 <Anarchos> i just need the result of "ghc --version" on a running ghc
13:50:50 <monochrom> "The Glorious Glasgow Haskell Compilation System, version 7.6.3"
13:51:08 <monochrom> and exit code 0
13:51:14 <jakex> what does System.Random use as a seed on linux? windows?
13:51:29 <monochrom> on linux I think it uses time
13:51:49 <monochrom> hmm, time to read the source!
13:51:51 <Anarchos> monochrom thanks
13:53:35 <jakex> if anyone else is interested: http://hackage.haskell.org/package/random-1.0.1.1/docs/src/System-Random.html#mkStdRNG
13:54:56 <monochrom> it uses a combination of getCurrentTime and getCPUTime. it does the same on linux and windows
13:55:17 <monochrom> yeah, that one, with o = 0
13:59:17 <Anarchos> why is haskell so rude to port to another architecture ?
13:59:38 <monochrom> what do you mean?
14:00:17 <Anarchos> monochrom i would prefer just to compile a runtime coded in C/C++, cause gcc is everywhere, and run a bytecode version of a boot compiler on this runtime.
14:00:34 <monochrom> you can use hugs. it's written in C only.
14:02:17 <sebastian> is anyone using haskell for spartial databases, spartial queries, 2d rendering?
14:07:27 <sebastian> anyway. if someone is using haskell for spartial data, I've created an r-tree for in-memory representation. ...
14:11:03 <srhb> sebastian: Link?
14:11:14 <__sebastian___> http://hackage.haskell.org/package/data-r-tree-0.0.1.0
14:11:22 <srhb> __sebastian___: Thankee.
14:12:15 <srhb> __sebastian___: Also I think it's spatial, not spartial
14:12:36 <__sebastian___> srhb: jup :)
14:15:54 <__sebastian___> fixed
14:24:48 <mm_freak_> hi there
14:25:03 <mm_freak_>     RULE left-hand side too complicated to desugar
14:25:10 <mm_freak_> it's for a SPECIALIZE rule
14:25:23 <mm_freak_> when is a rule too complicated?
14:25:41 <mm_freak_> (please note that i have no experience with RULE itself, only with SPECIALIZE)
14:25:50 <hseg> Hi. In http://blog.sigfpe.com/2014/04/the-monad-called-free.html, what's the InstanceSigs language extension? I can't find it in the docs.
14:26:06 <mm_freak_> hseg: allows you to write type signatures for instance values
14:26:14 <mm_freak_> mappend :: ‚Ä¶
14:28:02 <hseg> mm_freak_: Please clarify
14:29:05 <mm_freak_> hseg: you're writing a monad instance for ((->) e)
14:29:18 <mm_freak_> InstanceSigs allows you to write:  return :: a -> e -> a
14:29:32 <mm_freak_> normally you may not write a type signature for 'return', because it's an instance value
14:30:04 <hseg> As in, instance Monad ((->) e) where {return :: a -> e -> a; return = const ....} ?
14:30:12 <mm_freak_> hseg: exactly
14:30:59 <hseg> OK. A) Where is the documentation for this? B) What caused the old behaviour? and C) I can't find an example of that in that post.
14:31:58 <benmachine> who here loves lax monoidal functors? I want someone who loves lax monoidal functors http://stackoverflow.com/q/23316255/812053
14:34:38 <corgifex> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-sigs
14:36:24 <EvanR> is there a non empty list type
14:37:13 <corgifex> (a, [a]) technically
14:37:15 <Iceland_jack> yes, also (a, [a]) :)
14:37:25 <Iceland_jack> there are several implementations on Hackage
14:37:35 <EvanR> oh nice
14:37:42 <EvanR> that is clever
14:38:26 <benmachine> http://hackage.haskell.org/package/semigroups this has a NonEmpty type that is basically the same as (a, [a])
14:38:29 <hseg> OK. But A) why was the old behavior like that to begin with? and B)  why doesn't it appear in the flag reference?
14:38:59 <Iceland_jack> EvanR: I used a similar trick when enforcing invariants in https://ghc.haskell.org/trac/ghc/attachment/ticket/8782/OrdList.lhs
14:39:15 <hseg> Also, I don't see why it was used in that blog post.
14:39:43 <Iceland_jack> where
14:39:43 <Iceland_jack>     Many ‚à∂ a ‚Üí [a] ‚Üí ‚Ä¶
14:39:43 <Iceland_jack> instead of the older
14:39:43 <Iceland_jack>     Many ‚à∂ [a] ‚Üí ‚Ä¶ -- | Always non-empty
14:43:41 <mm_freak_> hseg: the old behavior is standard haskell‚Ä¶  i'm not sure why it's that way, but i guess it was thought to be redundant
14:44:36 <mm_freak_> EvanR: non-emptyness can be characterized by comonads, which is what i sometimes do
14:44:47 <EvanR> interesting
14:44:49 <hseg> OK. Questions remaining: Why isn't it in the flag reference and why is it used in the blog post?
14:45:07 <mm_freak_> hseg: i'm pretty sure it is in the extensions reference
14:46:08 <mm_freak_> hseg: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-sigs
14:47:33 <EvanR> looking comonads now
14:49:30 <mm_freak_> EvanR: it's useful sometimes, when you don't care about the structure of the type, only that it is nonempty and extending
14:49:59 <Algebr> Is there something in ghci that says what a module exports? Like :i Data.Char
14:50:08 <mm_freak_> Algebr: :browse
14:50:14 <mm_freak_> or just :bro
14:50:27 <todaystomorrow> Is it bad that I want to do everything in haskell ?
14:50:28 <hseg> mm_freak_: Yeah, but I'd expect it to be listed in section 4.20.12 - http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#idp14615552
14:50:29 <Algebr> super, spot on.
14:50:32 <Algebr> Thank you.
14:50:47 <mm_freak_> you're welcome
14:51:14 <nh2> todaystomorrow: no, as long as you are aware that some things take big effort
14:51:19 <mm_freak_> hseg: not sure‚Ä¶  it probably links to the extensions section somehow‚Ä¶  if you find this confusing, you could submit a bug report =)
14:51:31 <todaystomorrow> hmm
14:51:54 <hseg> Think I'll do so. Anyway, I still don't see why sigfpe used that extension.
14:52:08 <mm_freak_> hseg: i sometimes use it for documentation
14:52:23 <hseg> Documentation?
14:52:36 <mm_freak_> hseg: but in some cases it is useful with ScopedTypeVariables
14:52:50 <mm_freak_> because without InstanceSigs the type variables are not in scope
14:53:19 <mm_freak_> return :: forall a. a -> M a;  return x = ‚Ä¶ (blah :: a) ‚Ä¶
14:53:25 <mm_freak_> you need InstanceSigs to write that
14:53:29 <EvanR> comonads interface isnt jumping out at my for any of the types in my game, but copointed looks cool
14:53:57 <hseg> Right. I'm not questioning the utility of the extension. Rather, I don't see why sigfpe used it in his code - I don't see him using it.
14:54:18 <mm_freak_> i haven't read it, so i can't tell
14:54:31 <mm_freak_> EvanR: my favorite example is a blur filter for pictures
14:54:41 <mm_freak_> EvanR: blur :: Picture RGB -> RGB
14:54:54 <mm_freak_> extend :: (Picture RGB -> RGB) -> (Picture RGB -> Picture RGB)
14:55:10 <mm_freak_> describe blurring for a single pixel, extend it to all pixels
14:55:48 <hseg> mm_freak_: A simple search will show you that no instance declaration in that post has a signature.
14:57:05 <EvanR> not sure how this extends to Picture a
14:57:16 <Kiryx> > fooBar = map read (words "1 2 3 4") :: [Int]
14:57:17 <lambdabot>  <hint>:1:8: parse error on input ‚Äò=‚Äô
14:57:26 <Kiryx> > let fooBar = map read (words "1 2 3 4") :: [Int]
14:57:27 <lambdabot>  not an expression: ‚Äòlet fooBar = map read (words "1 2 3 4") :: [Int]‚Äô
14:57:37 <mm_freak_> EvanR: example: type Picture = Store (V2 Int)
14:57:45 <mm_freak_> it's basically a pixel array with a position
14:58:02 <mm_freak_> data Store ix a = Store (ix -> a) ix
14:58:47 <EvanR> ix is the V2
14:58:53 <mm_freak_> yeah
14:59:07 <mm_freak_> V2 from 'linear', btw:  data V2 a = V2 a a
14:59:14 <mm_freak_> (modulo strictness)
14:59:47 <SirDarjeeling> Hey there
15:00:09 <mm_freak_> hi SirCeylon
15:00:10 <mm_freak_> oops
15:00:13 <EvanR> ok so you have several kinds of pixels (or of anything) in your picture but still not seeing the relation to comonad
15:00:13 <mm_freak_> SirDarjeeling
15:01:01 <mm_freak_> EvanR: extend :: (Comonad w) => (w a -> b) -> (w a -> w b)
15:01:04 <EvanR> the class of image processing functions of that form is the comonad?
15:01:05 <SirDarjeeling> Does anyone around here know why, when I first perform the putStr Action and after that a getLn, haskell executes the getLn first?
15:01:34 <mm_freak_> EvanR: a comonad allows extending a function-at-a-point to an overall-function, in intuitive terms
15:01:37 <EvanR> SirDarjeeling: i/o buffering?
15:01:49 <DR6> SirDarjeeling: can you give us the code?
15:02:21 <DR6> maybe it's buffering
15:03:17 <SirDarjeeling> Buffering might be the thing, yeah... the code I tried it out whith was just:
15:03:32 <mm_freak_> EvanR: other interesting comonads include zippers, for example a list zipper:  data Zipped a = Zipped [a] a [a]
15:03:37 <SirDarjeeling> putStr "Why does this appear after the input?"
15:03:39 <EvanR> i see that makes sense from the extend signature, but in your example a = b, but i suppose in an exotic case it does not have to, for blur-like plans
15:03:42 <SirDarjeeling> bla <- getLine
15:03:55 <SirDarjeeling> and then
15:04:04 <EvanR> maybe should be called Comonad Blur ;)
15:04:39 <SirDarjeeling> putStrLn $ "The input was \"" ++ bla ++ "\"."
15:04:46 <c_wraith> the gaussian blur comonad?
15:04:48 <mm_freak_> EvanR: well, let me explain it differently:  look at fmap
15:05:03 <edwardk> EvanR: the pointer comonad?
15:05:08 <mm_freak_> EvanR: fmap takes an (a -> b), so the function can look at exactly one point and return exactly one point
15:05:10 <EvanR> that zipper thing might be fun to try in my game
15:05:20 <DR6> SirDarjeeling: what happens if you put putStrLn first?
15:05:31 <mm_freak_> EvanR: look at (=<<), it takes an (a -> f b), so it can look at exactly one point and return a neighbourhood
15:05:49 <mm_freak_> EvanR: now look at extend, which takes an (f a -> b), so it can look at a neighbourhood and return exactly one point
15:06:01 <mm_freak_> in all three cases the function is extended to (f a -> f b)
15:06:36 <EvanR> :t (=<<)
15:06:37 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:06:45 <EvanR> nice
15:07:10 <mm_freak_> that's the continuum from Comonad (f a -> b) over Functor (a -> b) to Monad (a -> f b)
15:07:17 <EvanR> that is a cool way to see monads from
15:07:56 <EvanR> i would very much like to know more about the nature of this continuum ;)
15:08:12 <EvanR> lerp 0.3456 Comonad Functor
15:08:23 <mm_freak_> hehe
15:08:34 <mm_freak_> it's a topological continuum =P
15:08:38 <EvanR> lol
15:08:55 <SirDarjeeling> DR6 then it works, but i was just curious how to fix that while still using just putStr instead of putStrLn
15:09:08 <edwardk> the comonadic extend gets to look at views of the whole input from the point of view of any one 'a' to make its output 'b', the functor only gets to look at one a to make one b, and the monadic (>>=) gets to make a whole thing, and has to be able to stitch together all those results.
15:09:25 <edwardk> the comonad and functor never get to 'change the shape'
15:09:34 <edwardk> they merely redecorate
15:09:40 <edwardk> monads substitute
15:10:13 <SirDarjeeling> But I was able to work around that issue by just setting the buffering of stdin and stdout to NoBuffering, thanks you all :)
15:12:58 <EvanR> im representing my level as a graph, and the graph as a set of edges, pairs of node IDs. maybe i can define it as a recursive structure, maybe a zipper instead
15:13:49 <mm_freak_> EvanR: if you have a proper zipper, chances are you have a comonad‚Ä¶  in fact i think all zippers are comonads
15:14:09 <edwardk> mm_freak_: not usefully in Hask, but in a broader categorical sense, yes.
15:14:29 <edwardk> http://cs.ioc.ee/~tarmo/tsem05/uustalu0812-slides.pdf
15:14:30 <EvanR> hmm
15:14:57 <EvanR> in your zipper spec above it seems you can only go one of two ways?
15:15:18 <EvanR> seems straight foward to have three
15:15:54 <EvanR> have never tried this
15:16:12 <c_wraith> 3?  If you go in direction 1, where does the current element go?
15:16:31 <EvanR> one of the other two ;)
15:16:38 <c_wraith> "one of".  very specific. :P
15:16:54 <EvanR> well it makes sense in my head, though i dont know how to tell the computer
15:17:11 <c_wraith> With 2 directions, there's no ambiguity there.  With 3 directions?  There's a bit of ambiguity
15:17:26 <EvanR> whats a bit between friends
15:17:48 <c_wraith> pfft.  You only think the compiler is your friend because it has your back.
15:17:58 <c_wraith> But that's just a side effect of it being out to get you.
15:18:13 <c_wraith> It likes to throw your errors in your face, all the time.
15:20:54 <EvanR> let a = Z 0 [b] [c] [d]; b = Z 1 [a] [] []; c = Z 2 [] [a] [d]; d = Z 3 [] [] [c] in a
15:21:22 <EvanR> hmm
15:21:28 * morjoff
15:21:47 <EvanR> oops
15:22:01 <EvanR> nevermind
15:25:21 <dfarm> Hi all, I've got an attoparsec question. I'm trying to parse a file that specifies lines (i.e., geometric lines) like x, y, 0 (initial point) x1, y1, 1 (next point), x2, y2, 1 (another point), x3, y3, 0 (new line segment)
15:26:13 <dfarm> So the 0 and 1 "tags" tell you when to start a new Line versus continuing to add vertexes. I was trying to figure out how to do an attoparsec parser like that... I saw scan says it's a stateful parser but I couldn't figure out how to use it...
15:27:22 <dfarm> (it's a funky old format but the actual docs for it are in the wayback machine: https://web.archive.org/web/20020319232715/http://iris.usc.edu/~afrancoi/research/viewworld/Format.htm -- I only need to do the basic types 0,1,2)
15:28:14 <c_wraith> dfarm: it's stateful like a recursive descent parser
15:28:32 <c_wraith> dfarm: the state is the current production it's attempting to match
15:29:44 <c_wraith> dfarm: so you'd say a parser that generates a Line matches any number of values with the correct tag
15:29:47 <hseg> mm_freak_: Do you have papers on this Comonad -> Functor -> Monad continuum? Also, do Applicatives, Arrows and their dualizations appear in this continuum?
15:33:17 <danilo2> Hello! :) Could somebody tell me please what would be the equivalent of following GADT's code, but without GAD's extension? Would it be an existential data type? "data Term a where Pair :: Term a -> Term b -> Term (a,b)"
15:34:08 <enthropy> danilo2: what's the point of using -XExistentialQuantification instead of -XGADTs?
15:34:31 <c_wraith> danilo2: that is not existential
15:34:46 <danilo2> enthropy: I do not know. I'm just reading about GAD's and trying to understand it
15:35:06 <edwardk> Arrows are sort of a historical accident and most sit off to the side of any sort of continuum.
15:35:18 <roconnor> enthropy: because you want ExistentailQuantifiation without getting Type Equality?
15:35:54 <danilo2> c_wraith, enthropy: So, hmm, the type variable "b" does not exist on the left side - is this not exactly the same as writing existewntai ltype with "forall b." ? What will be the differences?
15:36:40 <c_wraith> danilo2: the type variable b exists in both the arguments to the constructor and in the type of the result
15:36:50 <enthropy> data Term a = forall b. Term (Term a) (Term b) -- is close
15:36:55 <c_wraith> (the types of the arguments to the constructor)
15:36:57 <edwardk> data Term c = forall a b. (c ~ (a,b)) => Term (Term a) (Term b)
15:36:58 <hseg> edwardk: Why do you consider them a historical accident? I'd have thought Wadler's "Idioms are oblivious, Arrows are meticulous, Monads are promiscuous" paper should have shown that Arrows have a place in this continuum.
15:37:35 <sdfsdf_> Chimpout Forum
15:37:36 <sdfsdf_> is the place to be
15:37:38 <sdfsdf_> Join us today!
15:37:57 <sdfsdf_> http://www.chimpout.com/forum    Join Chimpout for the best news commentary and social community organizing.
15:38:18 <mm_freak_> hseg: "continuum" was just a rhetorical style
15:38:30 <mm_freak_> hseg: to answer your question:  no, sorry
15:38:38 <edwardk> hseg: if applicative captures context-free, and monad captures context-sensitive, what does arrow capture? its something strangely in the middle. it is really a monad in a different category. you can show how all strong profunctors that have a category instance are arrows, but that isn't _really_ talking about Hask, its kind of off to the side
15:38:49 <mm_freak_> hseg: i learn most of this stuff by solving practical problems
15:39:00 <danilo2> edwardk, c_wraith, enthropy: So I understand, that "data Term c = forall a b. (c ~ (a,b)) => Term (Term a) (Term b)" is **exact** equivalent with the GADs code? I'm "feeling" the difference but cannot exactly tell it - so what is the difference between this one and "data Term a = forall b. Term (Term a) (Term b)" ?
15:39:47 <edwardk> hseg: data Term a = forall b. Term (Term a) (Term b)  is data Term a where Term :: Term a -> Term b -> Term a
15:39:54 <edwardk> notice how b is being dropped on the floor?
15:40:25 <edwardk> in the version i showed we're saying that the result type 'c' is the same as the pair of (a,b)
15:40:49 <edwardk> you can desugar in the GADT form as well
15:41:03 <hseg> edwardk: I'm still trying to wrap my head around that paper, but as far as I understood it, arrows captures context-sensitive in a non-recombining fashion.
15:41:09 <edwardk> data Term a where Term :: (c ~ (a,b)) => Term a -> Term b -> Term c
15:41:49 <hseg> edwardk: That is, while you may reuse parts of the context in multiple computations, and may have context-sensitive computations, you cannot combine the results of to context-sensitive computations.
15:42:13 <edwardk> hseg: yes, that is the same notion captured by the profunctor, but freyd categories are sort of a weird 'hey this is what i've got what laws do i have' mathematical construction by a computer scientist, not the sort of thing that comes up outside of our little corner of the world.
15:42:43 <danilo2> edwardk: Ok, I get it, thank you. But one thing is still not clear to me. I know that "b" is dropped on the floor in one of the examples, but what are the consequences in later usage?
15:42:49 <edwardk> hseg: it is really a painfully strange beast from a category theory perspective
15:43:00 <edwardk> danilo2: well you're saying two completely different things
15:43:20 <edwardk> in one yu're sayng you're going to take two terms that have types a and b, and get a term annotated with the pair
15:43:36 <edwardk> in the other yu're saying you take a term of type a, a term of type b, and the result is a term of type a
15:43:44 <edwardk> the two forms are completely incomporable
15:43:50 <edwardk> er incomparable
15:44:20 <mm_freak_> hseg: the relationship between arrows and monads can be understood by looking at (>>=): it takes an (a -> m b) and constructs an (m a -> m b)‚Ä¶  see how that function is allowed to change structure
15:44:22 <hseg> edwardk: I'm not that well-versed in profunctors, so I can't really comment. So you're saying that basically, Freyd categories arose as a simplification of Hughes' formulation of arrows, and not from a simple mathematical structure?
15:44:28 <mm_freak_> an arrow is not allowed to do that
15:44:46 <mm_freak_> it's about the most expressive concept that doesn't allow to change structure just yet
15:44:55 <hseg> mm_freak_: I'm not sure arrows have a concept of structure
15:45:12 <edwardk> hseg: well, what i'm saying is the original motivation of arrows was for things like swierstra and duponcheel's parser... which is merely applicative, but the vocabulary didn't exist at the time
15:45:13 <mm_freak_> hseg: they do
15:45:22 <edwardk> so a bunch of stuff was thrown in a blender and arrows came out
15:45:24 <hseg> edwardk: In what way are arrows "strange beasts"
15:45:37 <edwardk> they have a claim to existence, but it isn't for their original stated purpose ;)
15:46:02 <hseg> edwardk: Really? I didn't think  that parser was applicative. Don't they have a context-sensitive part?
15:46:19 <edwardk> hseg: i've written it a half dozen times to teach people how it wrks
15:46:25 <edwardk> there is nothing in there that requires arrows
15:46:45 <hseg> edwardk: Do you have links to some of your writeups?
15:46:53 <edwardk> now, i find profunctors valuable, so its not a surprise that folks find something that happens to be a profunctor valuable ;)
15:47:11 <edwardk> but its not a good base buildng block because it's already bolted extra crap in
15:47:42 <edwardk> its too big for what make lens out of, too big for most applicative usecases, but it has elements of both
15:48:00 <danilo2> edwardk: Ok, hmm - one more question :) So in this case, the code "data Parser a where MultP :: Parser (a -> b) -> Parser a -> Parser b" is equivalent to "data Parser b = forall a. MultP (Parser (a -> b)) (Parser a)" ?
15:48:08 <edwardk> so when you deconstruct and try to find what you actually need you rarely find that an arrow is at the heart of what you're building
15:48:23 <edwardk> danilo2: yes
15:48:43 <edwardk> danilo2: you can always desugar
15:49:08 <edwardk> er "for what we make lens out of"
15:49:11 <danilo2> edwardk: Hmm, with some kind of a compilation flag?
15:49:46 <edwardk> danilo2: no. just sayin that ExistentialQuantification + TypeFamilies and GADTs have the same expressive power for data types.
15:51:02 <danilo2> edwardk: ah ok, thnak you! :)
15:51:25 <edwardk> hseg: not handy. mostly i've done this in person =)
15:51:40 <edwardk> or in rants on various channels when this comes up ;)
15:53:24 <hseg> Oh. I'm trying to look it up. The most I've found is this ML post of yours: http://www.haskell.org/pipermail/libraries/2012-July/018175.html
15:53:47 <danilo2> edwardk: Are arrows not something more powerfull than monads and applicative together? They can have both context sensitive as well context-insensitive informations. So we can build monads with them, applicatives with the or something like monad-aplicative - am I wrong?
15:54:25 <EvanR> grand unified typeclasses ;)
15:54:57 <hseg> danilo2: No. Give me apply :: Arrow (~>) => (a ~> b, a) ~> b
15:55:08 <edwardk> danilo2: you can do more with a monad than with an arrow. there are however, arrows that are not monads. so no, arrows aren't more powerful, every monad gives rise to an arrow through Kleisli m. arrows are weaker but there are more of them.
15:55:39 <hseg> danilo2: You can't. For those arrows where you can do that, you obtain a class isomorphic to Monads
15:56:23 <edwardk> basically the 'monad-like arrows' are all representable profunctors that are represented by a monad in hask
15:57:06 <danilo2> hseg: I'm sorry I do not get your example with apply :(
15:57:25 <danilo2> edwardk, hseg: Hm, so are there monads, that could not be represented as arrows?
15:57:30 <edwardk> representable profunctors are all 'strong', so first/second follow.
15:57:30 <hseg> danilo2: Basically, Monad ~ Arrow + apply as given above
15:57:38 <edwardk> danilo2: other way around.
15:57:42 <edwardk> there are arrows that are not monads
15:57:48 <hseg> danilo2: No, it's the other way around
15:57:56 <edwardk> every monad gives you a kleisli arrow.
15:58:03 <edwardk> so there are a lot _more_ arrows
15:58:08 <edwardk> but you can do less with them
15:58:34 <edwardk> so in terms of 'power'  arrows are more ubiquitous but less powerful
15:58:50 <edwardk> applicatives have even less 'power' and are more ubiquitous still
15:59:04 <danilo2> edwardk: Ok, so that is exactly I was thinking. So why do you think arrows are not more powerfull? we can replace every monad with an arrow + arrows can do more. I'm feeling like being blind and not seeing something very improtant
15:59:07 <hseg> edwardk: I'll need to brush up on my category theory in order to understand these remarks.
15:59:10 <mm_freak_> i like to give this example of a non-monad that can be expressed as an arrow:  data State s a = State { usesPut :: Bool, runState :: s -> (a, s) }
15:59:19 <edwardk> that's because an arrow is a monad in a place where you have to preserve more structure
15:59:31 <mm_freak_> try to implement (>>=) for this one
15:59:42 <mm_freak_> the usesPut is true, if the computation uses 'put'
15:59:52 <edwardk> it is however, trivial to build the applicative for that
16:00:02 <danilo2> mm_freak_: Of course it is impossible to implement bind for sometihng like that, because it depends on the contexts from previosu computation
16:00:25 <danilo2> mm_freak_: we can define arrow or applicative for something like that easly
16:00:30 <mm_freak_> danilo2: but it helps people understand the point of arrows and why there are more arrows than monads
16:00:44 <edwardk> a mealy machine makes a good arrow, but a moore machine does not.
16:01:12 <edwardk> and mm_freak_ 's example is basically a simplified version of the S&D parser that spawned arrows in the first place
16:01:14 <mm_freak_> Mealy is an interesting example:  it is in fact a monad, but a horribly inefficient one, which is why we use it with an arrow interface
16:01:31 <edwardk> yep
16:01:32 <danilo2> mm_freak_: I understand the point. It is clear to me. The only not clear thing is that "arrows are not more powerfull". If every monad can be expressed with an arrow, this implices, that everything we can do with monads, can be done with arrows (kleisli arrows if I'm not wonmg)., so why are they not "more powerfull" ?
16:01:56 <edwardk> danilo2: no, every monad givs you an arrow, but you can't do all the monadic things with it with just the arrow ap
16:01:57 <edwardk> er api
16:02:05 <mm_freak_> danilo2: no, it implies that everything we can do with the arrow interface we can do with the monad interface
16:02:18 <edwardk> you need ArrowApply at which point you've restrained yourself to the point where you really have a Monad in disguise
16:02:19 <mm_freak_> danilo2: power lies in what an interface can express
16:02:35 <lispy> Applicative-Wan (refering to Darth Arrow): He's moore machine now than mealy.
16:02:36 <mm_freak_> every monad can express what i like to call "switching" or "dependent structure"
16:02:44 <edwardk> lispy: =P
16:04:05 <danilo2> edwardk, mm_freak_: ah, ok, but in this case - ArrowApply, which gives us the apply function - allow us to do the same as monads? But are they still not "more powerfull"? We can use apply function or other function to compute something not context sensitive? (while using monads we can compute only context-sensitive thingS)
16:04:30 <mm_freak_> danilo2: every proper ArrowApply is really just a monad in disguise
16:04:34 <edwardk> An ArrowApply can be turned back into a Monad
16:04:46 <edwardk> there is nothing extra you gain there
16:04:47 <mm_freak_> see WrappedMonad
16:04:56 <edwardk> an WrappedArrow
16:04:58 <hseg> mm_freak_: Are you're claiming that (Bool, s -> (a,s) is an Arrow, but not a Monad? I've never seen it before.
16:05:11 <mm_freak_> hseg: it's not an arrow per se
16:05:29 <hseg> mm_freak_: OK, then what *were* you saying?
16:05:35 <edwardk> it is applicative
16:05:39 <mm_freak_> hseg: but here is the corresponding arrow:  data State s a b = State { usesPut :: Bool, runState :: (a, s) -> (b, s) }
16:05:55 <edwardk> better
16:06:00 <edwardk> now the variance needs are met
16:06:30 <danilo2> mm_freak_,  edwardk, hseg: Ok I think I'm starting to see the point. So basically if something is monad and applicative, we gain just nothing by turning it into arrow?
16:06:49 <mm_freak_> the transfer from monads to arrows or vice versa is not trivial, because monads are * -> * types, while arrows are * -> * -> * types
16:06:54 <edwardk> danilo2: if you have 2 arguments you get to play with some more combinators
16:06:56 <mm_freak_> so you can't just say "IO is an arrow"
16:07:01 <mm_freak_> but rather "IO has a corresponding arrow"
16:07:06 <mm_freak_> namely Kleisli IO
16:07:23 <edwardk> you can also work with all the profunctor combinators in Data.Profunctor.* if you are something with 2 argumnts of kind * that can be an arrow
16:07:35 <edwardk> which lets you directly pass your thing to a lens/prism and do fun stuff
16:07:50 <edwardk> but its no more power than what you can get wanking around with newtypes
16:08:34 <hseg> I'll have to play around with that type a bit, but it's not immediately obvious to me whether it's an Applicative/Arrow/Monad. mm_freak_ , you claim it's an Arrow, and edwardk, you claim it's an Applicative?
16:08:49 <mm_freak_> hseg: it's both
16:08:57 <mm_freak_> Applicative (State s a)
16:08:59 <danilo2> edwardk: Ok, thank you:) I'm going to read about profunctors and prisms right now :)
16:09:01 <mm_freak_> Arrow (State s)
16:09:03 <edwardk> hseg: applicative is easy. its a functor product of two applicatives
16:09:20 <mm_freak_> and it's a profunctor and functor, where 'rmap' is just fmap
16:09:37 <mm_freak_> and lmap corresponds to (. arr f)
16:09:47 <edwardk> both versions are a valid applicative
16:10:16 <edwardk> the one with the extra param is needed to shoehorn it into arrow.
16:10:19 <mm_freak_> hseg: let's return to the single-argument state:  data State s a = ‚Ä¶
16:10:37 <mm_freak_> hseg: this is an applicative functor, but it's not a category or arrow
16:10:48 <mm_freak_> obviously, because it has the wrong kind
16:10:59 <mm_freak_> so you can combine results, but you can not communicate them
16:11:02 <edwardk> kind is right for arrow, variance is wrong
16:11:14 <mm_freak_> well, yeah
16:12:24 <hseg> Actually, the s isn't necessary, IIUC. You could use the analogue of ST and universally quantify over s.
16:12:48 <lispy> if you did than, then you can't use s
16:13:01 <hseg> Oh right. Never mind.
16:14:39 <mm_freak_> in either case understanding why you can't write (>>=) is key to understanding what arrows are about
16:14:57 <mm_freak_> they give you almost the same expressive power as monads, but support those types which don't have a sensible (>>=)
16:15:05 <mm_freak_> like the State from above
16:15:27 <hseg> OK. I'll play around with the two versions of State to see what you're talking about, as I'm only confused now.
16:15:48 <mm_freak_> use the simple variant:  data State s a
16:15:53 <mm_freak_> try to write a Monad instance for it
16:16:07 <skypers> ok, what do you think it‚Äôs the best: write my own linear algebra library or use an already existing one? I just need a few stuff, nothing fancy
16:16:10 <mm_freak_> by now you know that it's not possible, but just convince yourself
16:16:21 <mm_freak_> skypers: what do you need?
16:16:38 <skypers> mm_freak_: well
16:17:00 <skypers> basic arithmetic
16:17:08 <skypers> +, -, *, /
16:17:11 <mm_freak_> skypers: have you checked out the 'linear' library?
16:17:13 <skypers> normalizing
16:17:14 <skypers> norm
16:17:21 <skypers> dot, cross
16:17:24 <skypers> and matrix
16:17:27 <skypers> with transpose
16:17:30 <skypers> invert, mult
16:17:37 <skypers> vector matrix mult
16:17:43 <skypers> and it‚Äôs quite all
16:17:45 <skypers> linear?
16:17:46 <mm_freak_> it gives you vector space arithmetic, including the stuff you just wrote, but it doesn't give you 'invert' for matrices
16:18:09 <rom1504> wg 3
16:18:09 <mm_freak_> i.e. it gives you everything that is arithmetic and does not involve equation algebra
16:18:18 <skypers> well it‚Äôs not that bad
16:18:19 <hseg> mm_freak_: OK. So basically, the exercise is: Show that "data State s a = State (Bool, s -> (s, a))" has no Monad instance, but does have an applicative instance?
16:18:22 <skypers> I‚Äôll check it out
16:18:26 <skypers> so you advise to use it
16:18:29 <skypers> not to write my own?
16:18:32 <mm_freak_> hseg: yeah
16:18:43 <skypers> why does it require hashable?
16:19:15 <mm_freak_> skypers: because it defines instances for unordered-containers as well
16:19:28 <mm_freak_> skypers: vectors and matrices are expressed in terms of functors
16:19:31 <mm_freak_> f (g a)
16:19:43 <lispy> skypers: whenever a computation requires an inverse matrix you almost always want find an equivalent expression that doesn't actually require inverting the matrix. (numerical reasons)
16:20:18 <skypers> ‚Äúalmost‚Äù, lispy
16:20:25 <skypers> in my case, I do want it.
16:20:42 <mm_freak_> then you will have to write gauss-jordan or something like that yourself
16:20:51 <skypers> yep
16:20:53 <skypers> well well
16:20:54 <skypers> el :: forall x. Lens' (t x) x
16:20:59 <skypers> it uses lens?
16:21:14 <edwardk> yeah. linear builds on lens
16:21:25 <lispy> skypers: if you need a fast library for large matrices, you probably want the BLAS binding
16:21:30 <skypers> bloody hell you‚Äôre everywhere edwardk :D
16:21:31 * lispy forgets the name
16:21:40 <skypers> LAPLACK?
16:21:50 <skypers> -L
16:21:52 <skypers> hmatrix I guess?
16:22:08 <mm_freak_> there is also hmatrix, which gives you solutions to linear equations, but it's purely numerical (read: monomorphic and simply-typed) and also depends on an external library, i think
16:22:14 <lispy> skypers: ah right. hmatrix. I just noticed this as wel: http://hackage.haskell.org/package/blas
16:22:38 <skypers> yeah it requires blas and lapack, I‚Äôm not sure it‚Äôs a good idea to me
16:22:54 <lispy> there is a matrix lib on hackage called numeric adventures or some crap. It's terribly slow and buggy.
16:23:15 <mm_freak_> if your matrices are reasonably small, you can write static solutions
16:23:27 <skypers> ahah lispy :)
16:23:51 <mm_freak_> just fire up your favorite CAS and copy the solution
16:24:50 <mm_freak_> that also allows you to apply some transformations to the solution to make it more numerically stable, if you happen to work with floating point numbers
16:25:03 <mm_freak_> gauss-jordan can get horribly unstable
16:25:23 <skypers> edwardk: I see it also uses adjunctions
16:25:29 <skypers> something I don‚Äôt know, once again
16:25:30 <skypers> :)
16:25:40 <edwardk> skypers: it uses representabilty
16:25:59 <edwardk> representability and vector spaces are closely connected
16:26:13 <edwardk> lets's play with functors for a sec
16:27:03 <edwardk> a functor f is considered (co)representable if there exists an "representation x" such that for all a, f a  is isomorphic to (x -> a)
16:27:05 <skypers> sometimes, I really wonder how you know all that shit
16:27:18 <edwardk> that says the functor looks a lot like a function arrow
16:27:35 <edwardk> so far so good?
16:27:42 <skypers> yep
16:27:49 <edwardk> in adjunctions i give that as a pair of functions that witness this isomorphism
16:28:00 <edwardk> tabulate :: (Rep f -> a) -> f a
16:28:09 <edwardk> index :: f a -> (Rep f -> a)
16:28:27 <edwardk> such that tabulate . index = id; index . tabulate = id
16:28:33 <edwardk> Rep f is what we call 'x'
16:28:56 <skypers> hm
16:29:03 <edwardk> now, vector spaces have a neat property. _all_ vector spaces are 'free vector spaces'
16:29:18 <edwardk> a free vector space looks like x -> r  for some basis x and some field r.
16:29:38 <skypers> you‚Äôre totally losing me
16:29:39 <edwardk> so i choose to represent vector spaces with representable functors
16:29:51 <edwardk> You've heard of R^3?
16:29:58 <skypers> I‚Äôm working in there
16:30:06 <skypers> even in R‚Å¥
16:30:09 <edwardk> we write exponents as 3 -> R  in Haskell
16:30:20 <edwardk> so you want a function from a set with 3 elements to R
16:30:34 <skypers> fair enough
16:31:00 <edwardk> its the same as R3 = 3 -> R  is isomorphic to V3 R   for   data V3 a = V3 a a a
16:31:21 <edwardk> the former looks like a function, the later looks like data
16:31:27 <edwardk> with exactly one place to store each answer
16:31:30 <edwardk> so it can get memoized
16:31:49 <mm_freak_> ‚Ñù^2 = Bool ‚Üí ‚Ñù, ‚Ñù^3 = Trool ‚Üí ‚Ñù, ‚Ñù^4 = Quool ‚Üí ‚Ñù
16:31:50 * ski . o O ( "What is a Naperian container?" <http://sneezy.cs.nott.ac.uk/containers/blog/?p=14> )
16:31:51 <edwardk> tabulate f = V3 (f X) (f Y) (f Z)
16:32:04 <lispy> mm_freak_: quool!
16:32:16 <mm_freak_> ‚Ñù^5 = Queel ‚Üí ‚Ñù
16:32:34 <mm_freak_> and then came the Hool‚Ä¶
16:32:44 <mm_freak_> oh, and Queel has a dual, Queer
16:32:45 <edwardk> index (V3 x y z) X = x; ...
16:32:54 <mm_freak_> sorry, continue
16:33:13 <edwardk> so linear represents all vector spaces in this form.
16:33:30 <skypers> this drives me crazy
16:33:34 <edwardk> since they are all isomorphic to functions, all the things you know about the monad (->) e   holds for them
16:33:54 <lispy> edwardk: huh, I never thought about it in those abstractions, but I ended up with something equivalent to tabulate/index in my lin-alg package
16:34:00 <edwardk> so you can (>>=) them, use MonadReader, play a bunch of games with the representaton, use applicatives, etc.
16:34:11 <mm_freak_> skypers: newtype V2 a = V2 (2 -> a)
16:34:14 <mm_freak_> skypers: where 2 = Bool
16:34:17 <mm_freak_> does that make sense?
16:34:21 <skypers> not even close.
16:34:22 <skypers> :D
16:34:34 <skypers> to me
16:34:38 <skypers> 2 -> a
16:34:39 <edwardk> skypers: well, you can call the function with 2 inputs getting out two different a's
16:34:42 <skypers> is a compilation error.
16:34:53 <mm_freak_> ok, here is the vector (3, 5):  V2 (\x -> if x then 3 else 5)
16:34:55 <edwardk> 2 -> a = a^2 = a*a
16:35:11 <edwardk> so you can call that first function with False and True and get two answers
16:35:16 <hseg> OK. Thanks for all the help guys. You've certainly given me food for thought. Goodnight.
16:35:17 <mm_freak_> extract the x component:  x (V2 f) = f True
16:35:23 <mm_freak_> extract the y component:  x (V2 f) = f False
16:35:25 <mm_freak_> uhm
16:35:28 <mm_freak_> extract the y component:  y (V2 f) = f False
16:35:33 <edwardk> an you ca construct a function that returns one of the two answers based on the bool it is given
16:35:47 <skypers> :‚Äì‚Äô
16:35:56 <skypers> is there anyway left it‚Äôs simple?
16:35:58 <mm_freak_> skypers: do you see how every array is just a function from indices to elements?
16:36:09 <skypers> why everything is so complicated with edwardk‚Äôs stuff ? :( :D
16:36:22 <skypers> mm_freak_: yes, but it‚Äôs stupid to represent arrays that way
16:36:25 <mm_freak_> skypers: it's not complicated‚Ä¶  the true definition is:  data V2 a = V2 !a !a
16:36:29 <mm_freak_> skypers: no, it's not
16:36:33 <skypers> it is
16:36:51 <skypers> representing a hash that way would be more acceptable
16:37:12 <mm_freak_> skypers: this representation has a number of advantages
16:37:23 <mm_freak_> firstly it's useful to be aware of that representation, because it lets you know that you have a reader monad, but you call it "array"
16:37:29 <mm_freak_> "reader monad" as in "(->) e"
16:37:29 <skypers> mm_freak_: I guess performance is not among them
16:37:39 <mm_freak_> skypers: performance is among them
16:37:44 <edwardk> skypers: lets play a performance game for a sec.
16:37:45 <skypers> I don‚Äôt see how
16:37:47 <edwardk> =)
16:37:55 <mm_freak_> skypers: repa uses this representation to get extremely fast parallel array operations
16:38:04 <edwardk> skypers: when we get done with this we can CPS an entire linear transformation
16:38:10 <edwardk> and pay NOTHING FOR ZEROS
16:38:29 <skypers> isn‚Äôt repa GPU accellerated?
16:38:31 <edwardk> you only pay for the ops that contribute to the answer when you write it right
16:38:36 <mm_freak_> skypers: i've also used this representation to represent sparse arrays compactly
16:38:44 <mm_freak_> skypers: no, that's 'accelerate'
16:38:54 <skypers> mm_freak_: are we talking about the same abstraction?
16:39:00 <mm_freak_> skypers: yes
16:39:10 <skypers> the same that Array uses for updating its content?
16:39:13 <skypers> with (//)
16:39:22 <mm_freak_> skypers: now you lost me
16:39:34 <skypers> mm_freak_: it just basically maps indices to values
16:39:55 <mm_freak_> skypers: no, this is about the array representation itself
16:40:02 <mm_freak_> newtype Array ix a = Array (ix -> a)
16:40:19 <skypers> this is so fucked up
16:40:43 <skypers> how do you build an array of 100000 elements with that?
16:41:04 <mm_freak_> skypers: depends on where those 100000 elements are coming from
16:41:07 <edwardk> skypers: nothing says that isn't looking at an array of 100000 elements under the hood
16:41:18 <edwardk> its a function it can do anything it wants
16:41:21 <mm_freak_> skypers: it can be an actual array in memory
16:41:30 <skypers> where would you put the actual array?
16:41:44 <mm_freak_> skypers: myArray = Array (\ix -> arr ! ix)
16:41:52 <mm_freak_> where 'arr' is an actual array
16:42:07 <skypers> mm_freak_: how do you change its content?
16:42:19 <skypers> how do you get fast performance with such a representation seriously?
16:42:27 <mm_freak_> skypers: "change"?  it's an immutable array
16:42:38 <skypers> mm_freak_: like (//)
16:43:03 <mm_freak_> skypers: this is probably a good exercise for you =)
16:43:25 <skypers> sometimes
16:43:33 <skypers> I‚Äôm really happy using Haskell
16:43:35 <skypers> other times
16:43:40 <mm_freak_> in any case it's not more expensive than the (//) you get for concrete arrays, and in many cases actually cheaper
16:43:48 <skypers> I really wonder ‚Äúhow have we ended up there‚Äù
16:43:48 <mm_freak_> because you only pay for the operations you actually perform in the end
16:44:54 <mm_freak_> perhaps you have a wrong picture of functions
16:45:03 <skypers> how could it be?
16:45:13 <mm_freak_> functions are the cheapest thing in haskell
16:45:27 <skypers> does that make any sense?
16:45:31 <skypers> ‚Äúcheapest thing‚Äù
16:45:32 <mm_freak_> yes
16:45:43 <mm_freak_> cheap in terms of memory and CPU time
16:45:45 <skypers> in what terms? compared to what?
16:45:49 <hpc> functions $5
16:45:52 <hpc> all other values $10
16:46:07 <mm_freak_> for example here is an array of 2^64 elements, filled with zeroes:  Array (const 0)
16:46:07 <hpc> polymorphism 10% surcharge
16:46:39 <mm_freak_> 2^64 elements expressed using a function that likely uses only a few bytes in memory and probably takes only a single cycle to run for each indexing
16:47:07 <skypers> mm_freak_: something that quite scares is the fact that really simple concepts in C, C++ or other languages requires you a LOT of knowledge to implement it efficiently in Haskell
16:47:34 <mm_freak_> skypers: this representation beats C in performance‚Ä¶  you get C-like performance with the usual mutable arrays =)
16:47:45 <skypers> what?
16:47:50 <EvanR> and simple concepts in haskell are insane to implement efficiently or not in C
16:48:11 <mm_freak_> skypers: it's also a lot less to type for the programmer
16:48:21 <skypers> mm_freak_: how do you know it beats the C version?
16:48:25 <skypers> which C version btw ?
16:48:30 <mm_freak_> and the concept is not really much more than "arrays are functions of indices"
16:48:34 <EvanR> nothing can go faster than C
16:49:23 <eswar> Fortran?
16:49:29 <skypers> is sounds so weird designing vector spaces by functions
16:49:39 <skypers> R^2 for instance
16:49:46 <skypers> in pure mathematics
16:49:51 <mm_freak_> skypers: i've benchmarked it:  https://twitter.com/ertesx/status/449983416428396544
16:49:52 <bjorkintosh> EvanR, asm
16:50:05 <EvanR> nevermind
16:50:07 <skypers> an element of R^2 is a pair
16:50:09 <skypers> not a function
16:50:20 <mm_freak_> skypers: written highly efficient versions in both C and haskell, added crazy amounts of compiler optimizations to both and benchmarked the result
16:50:23 <EvanR> :t (,)
16:50:24 <lambdabot> a -> b -> (a, b)
16:50:31 <copumpkin> skypers: it can easily be a function
16:50:41 <skypers> that‚Äôs great
16:50:43 <skypers> it ‚Äúcan‚Äù
16:50:46 <skypers> but it‚Äôs not
16:50:48 <skypers> it‚Äôs a pair
16:50:52 <skypers> (x,y)
16:50:56 <ski>   (u + v)_i  =  u_i + v_i  -- the vectors `u' and `v' are functions taking indices to scalars. this is basically the environment idiom/monad
16:51:00 <startling> skypers, mathematicians don't use "is" like that
16:51:26 <skypers> I just don‚Äôt get the benefit of putting abstractions _everywhere_
16:51:35 <skypers> it leads people to misconfusing
16:51:41 <skypers> and it‚Äôs harder to get into
16:51:45 <copumpkin> skypers: I'm saying that it's isomorphic to a function, too
16:51:46 <EvanR> you have to unlearn C
16:52:00 <mm_freak_> skypers: ok, let me ask this:  do you see any /disadvantage/ of representing arrays as functions?  we've already shown you that it's more powerful, but perhaps concrete arrays do something better
16:52:03 <skypers> mm_freak_: oh
16:52:04 <copumpkin> skypers: in fact, your syntax is often used to denote a function
16:52:07 <skypers> you write that
16:52:12 <skypers> your C version is wrong
16:52:14 <skypers> it could be faster
16:52:22 <skypers> I read that with a friend
16:52:35 <mm_freak_> skypers: if you can make it faster, i'm happy to rebenchmark
16:52:43 <mm_freak_> but don't tell me that it's possible‚Ä¶  do it! ;)
16:52:55 <Leidy> hey guys! little question, where found an example with snap and https ?
16:52:58 <skypers> mm_freak_: well, how do you slice it? how do you update it like (//) efficiently? how do you iterate over it?
16:53:23 <startling> skypers, do you normally iterate over R^2?
16:53:29 <mm_freak_> skypers: slicing is trivial:  you add a value to the index
16:53:36 <lispy> Leidy: I think there is a snap book. Maybe in there?
16:53:37 <skypers> startling: it‚Äôs not the question there
16:53:40 <skypers> we‚Äôre talking about arrays
16:53:57 <mm_freak_> skypers: please define (//)
16:54:06 <mm_freak_> changing elements at arbitrary positions?
16:54:09 <startling> I think there are too many concurrent conversations here.
16:54:09 <EvanR> iterating over a 1D array, maybe use Vector
16:54:16 <copumpkin> EvanR: tanking
16:54:17 <skypers> (//) :: Array a -> [(Int,a)] -> Array a
16:54:28 <skypers> mm_freak_: yes
16:54:43 <EvanR> copumpkin: <$>
16:54:44 <mm_freak_> skypers: depends on how i'm going to use the result
16:54:51 <lispy> Leidy: I don't know if this is a good idea or not, but you could use a reverse proxy with another web server (like apache or ngix) that handles the ssl but delegates everything to snap.
16:54:56 <skypers> you see how it‚Äôs complex?
16:54:59 <skypers> where the machine
16:55:01 <skypers> the _hardware_
16:55:11 <skypers> itselfs, provides you simple way to do that
16:55:11 <EvanR> machine? gross
16:55:14 * copumpkin tunes out
16:55:24 <mm_freak_> skypers: it's not complex, it's understanding the structure of the problem
16:55:28 <Leidy> lispy: interesting , i'm going to think about
16:55:47 <mm_freak_> skypers: for a general (//) i'd say i'd convert that list to a Map first and then index that map
16:55:58 <skypers> :‚Äì‚Äô
16:56:09 <skypers> it‚Äôd be so bad in performance
16:56:27 <EvanR> but you cant even write a general version in C so its incomparible
16:56:28 <mm_freak_> that's for a general (//)‚Ä¶  your question is just too broad
16:56:42 <mm_freak_> you're asking, "how do you build a house?"
16:56:50 <skypers> no, mm_freak_
16:56:54 <skypers> if you think so
16:56:58 <skypers> it‚Äôs terrible to you
16:57:09 <skypers> because if updating an array is building a house to you
16:57:16 <skypers> what making a descend and nice program in Haskell is?
16:57:18 <mm_freak_> skypers: that's not the point
16:57:22 <skypers> it is
16:57:39 <skypers> this is _exactly_ what scares me about Haskell
16:57:40 <Leidy> lispy: where is the snap book ?
16:57:52 <mm_freak_> skypers: alright, so we disagree‚Ä¶  i'm tired of this, sorry
16:58:01 <EvanR> skypers: what are you using arrays for anyway
16:59:04 <mm_freak_> skypers: you're judging something by your intuitive feeling without even trying it, and it's not possible to convince you that it's both easier and more powerful using words‚Ä¶  you have to solve an actual problem using this to understand its power
16:59:21 <skypers> mm_freak_: you mention a Map
16:59:26 <skypers> I‚Äôm writing a 3D engine
16:59:26 <lispy> Leidy: perhaps it wasn't finished. I thought someone said they were writing one. It's been a while, maybe a year or two since then.
16:59:42 <skypers> and the single idea of using a Map to update my stuff, each frame, in realtime
16:59:56 <skypers> yeah, no need to experience it to know it‚Äôll be seriously bad
17:00:01 <EvanR> maps are good
17:00:01 <mm_freak_> skypers: because you asked a question that doesn't come up in code you write using the functional representation
17:00:09 <mm_freak_> i have never used (//) for arrays
17:00:24 <mm_freak_> skypers: and you're wrong about Map performance
17:00:35 <skypers> mm_freak_: ‚Ä¶
17:00:36 <skypers> yeah sure
17:00:49 <skypers> even if it has fucking great logarithmic lookup performance
17:00:54 <skypers> arrays have constant one
17:00:58 <lispy> skypers: low dimensional linear algebra is fairly different, performance-wise, than arbitrary dimensional.
17:01:03 <skypers> and O(1) is _required_
17:01:08 <mm_freak_> skypers: arrays have constant lookup and constant update
17:01:13 <mm_freak_> Map has constant insert
17:01:17 <mm_freak_> uhm
17:01:20 <mm_freak_> logarithmic
17:01:32 <lispy> skypers: You should have mentioned your usecase sooner :)
17:01:49 <skypers> lispy: yeah, I should have
17:02:01 <skypers> the thing is: I‚Äôm quite worried about all that stuff
17:02:19 <skypers> the functional paradigm is seriously powerful and nice
17:02:19 <mm_freak_> skypers: Map has m+n union and still retains logarithmic insert
17:02:20 <EvanR> skypers: im writing a 3d graphics game right now
17:02:24 <skypers> and I use it everywhere know
17:02:26 <skypers> _but_
17:02:32 <skypers> sometimes, I think it‚Äôs just wrong
17:02:42 <skypers> EvanR: in Haskell?
17:02:45 <EvanR> yeah
17:03:01 <mm_freak_> skypers: so am i
17:03:12 <startling> ludum dare weekend !
17:03:18 <EvanR> im waiting to see the performance
17:03:25 <EvanR> am hopeful
17:03:26 <lispy> skypers: this is what i use in my ray-tracer and it works well enough: https://github.com/dagit/lin-alg
17:03:27 <skypers> you‚Äôll tell me
17:03:31 <skypers> mine is almoste done
17:03:37 <skypers> I‚Äôll benchmark
17:03:51 <skypers> lispy: ok
17:04:18 <srhb> What's the issue? If a Map is too slow, you throw some vectors at it, right?
17:04:24 <lispy> skypers: if I were starting over tomorrow I'd just use edwardk's linear package
17:04:39 <startling> linear is nice.
17:04:43 <srhb> Very.
17:05:09 <edwardk> skypers: i get very good performance for EDSLs that just happen to use linear as an intermediate representation on the way to generating GPU code.
17:05:34 <skypers> it‚Äôs about linear I‚Äôm worried
17:05:40 <skypers> but ways we represent some stuff in Haskell
17:05:48 <skypers> it gets really hard for nothing special
17:05:54 <startling> sigh.
17:06:02 <EvanR> i find C very hard for nothing special
17:06:05 <mm_freak_> skypers: linear doesn't represent vectors as functions, but it uses the isomorphism between vectors and functions
17:06:41 <edwardk> skypers: i wrote c for a long long time before i found haskell. i can write the boring simple low hanging fruit solution. it works pretty well right up until you smack into the limits of the optimization opportunities it affords.
17:06:58 <edwardk> the benefits of the 'crazy complicated functional stuff' is that it has a higher ceiling.
17:06:59 <mm_freak_> and i'm not sure how 'const 0' is harder than "for (int i = 0; i < len; i++) { ‚Ä¶"
17:07:15 <mm_freak_> oh my god, how did i ever type that without feeling stupid or sorry for myself‚Ä¶
17:07:20 <skypers> mm_freak_: you throw simple examples
17:07:20 <startling> ^ this is a good point
17:07:30 <skypers> I‚Äôm talking about complexe situations
17:07:31 <startling> it makes sparse arrays very nice.
17:07:38 <skypers> const 0 is not
17:07:39 <mm_freak_> skypers: like what?  you're talking abstractly
17:07:40 <edwardk> skypers: so am i.
17:07:51 <skypers> mm_freak_: like using vertices, for instances
17:07:54 <srhb> Complex situations is exactly where Haskell becomes easier than C, imo.
17:08:03 <mm_freak_> skypers: go on
17:08:08 <skypers> morphing objects, iterating on vertices
17:08:29 <skypers> removing doubles, connecting them
17:08:30 <skypers> and so on
17:09:06 <mm_freak_> skypers: you write these things just like you would normally in haskell
17:09:21 <skypers> mm_freak_: I have another example
17:09:25 <skypers> not related to arrays
17:09:36 <skypers> it‚Äôs an issue I‚Äôve been experiencing for weeks now
17:09:45 <skypers> and no one gave me a correct and appropriate answer
17:09:54 <mm_freak_> skypers: go ahead
17:10:11 <skypers> I want to embed materials in meshes in a way if the material changes, it must change in all meshes
17:10:20 <skypers> doing that, in C++, is _simple_
17:10:27 <skypers> you can even do it a safe way
17:10:30 <skypers> without pointers
17:10:37 <skypers> in Haskell
17:10:41 <skypers> it‚Äôs a pain in the ass.
17:10:44 <startling> skypers, give your material a unique name?
17:10:45 <mm_freak_> i remember that question, and i also remember answering it, but you didn't seem to like my answer =)
17:10:52 <mm_freak_> FRP
17:10:55 <skypers> yeah
17:11:05 <skypers> FRP is the bazooka again the ant
17:11:11 <skypers> see
17:11:14 <mm_freak_> huh?
17:11:16 <edwardk> skypers: yes, now go make changes and roll them back in the haskell version vs. the c version
17:11:17 <skypers> the dude in C uses references
17:11:25 <skypers> the dude in Haskell uses FRP
17:11:30 <startling> skypers, you can use references in haskell
17:11:33 <skypers> see how ridiculous that is
17:11:38 <skypers> startling: no I can‚Äôt
17:11:41 <startling> skypers: ???
17:11:44 <startling> of course you can.
17:11:46 <skypers> STRefs dies when I leave ST
17:11:49 <FreeFull> FRP is cool
17:11:50 <edwardk> i choose to exploit the benefits i get from immutable representations over gains i get from using mutable references everywhere
17:11:52 <skypers> and I‚Äôm in pure code
17:11:53 <skypers> so no IO
17:12:05 <skypers> the way I do it now
17:12:10 <startling> skypers, ok, so use indices into a map or array or something
17:12:15 <skypers> is to insert my materials in a Vector
17:12:15 <startling> that's pretty much a reference.
17:12:17 <skypers> and get back indices
17:12:21 <skypers> that represents my materials
17:12:24 <startling> yes, exactly.
17:12:27 <edwardk> take a c style physics engine and try to let agents use it to predict the world. you can't safely because any simulations they ran with what they know about would mutate the state.
17:12:29 <mm_freak_> skypers: depends on who you ask‚Ä¶  the guy in C writes a lot more code, has a much harder time maintaining and reading it
17:12:39 <skypers> startling: the thing is
17:12:41 <skypers> I‚Äôm using a Vector
17:12:46 <LordBrain> i much favor haskell, it is my favorite language, but generally it is best at problems where you don't want to micromanage every little thing your code is doing, but want the compiler to figure out the small stuff for you.
17:12:49 <edwardk> but a haskell one can just filter to what it can see/know and continue purely functionally.
17:13:10 <skypers> now, imagine I add some materials
17:13:15 <srhb> LordBrain: I find I have great and high-level tools to guide the compiler even when I want to hand-tune stuff.
17:13:17 <skypers> doing that with Vectors will kill performance
17:13:25 <skypers> because snoc is O(l)
17:13:30 <edwardk> skypers: if you want references. use references. or don't or use a map from id's to materials. or a vector or not.
17:13:42 <skypers> what?
17:13:51 <EvanR> skypers: initialize the vector to be bigger
17:13:59 <skypers> EvanR: it‚Äôs impossible with Vector
17:14:01 <EvanR> to have room to add some, just like in C
17:14:03 <skypers> I need MVector
17:14:03 <mm_freak_> <skypers> the dude in C uses references <skypers> the dude in Haskell uses FRP <skypers> see how ridiculous that is
17:14:09 <mm_freak_> at this point i see only two options
17:14:13 <EvanR> skypers: use IO
17:14:14 <startling> or use an IntMap.
17:14:24 <skypers> EvanR: I can‚Äôt, pure code.
17:14:25 <mm_freak_> either you're a troll or the only proper response is:  "if you don't like haskell, don't use it"
17:14:33 <edwardk> you can make a pseudo-purely functional data structure with O(log n) append cost that has O(1) access time by Overmars and van Leeuwen.
17:14:49 <skypers> mm_freak_: you might have noticed I‚Äôm in #haskell for a while now
17:14:52 <skypers> and I like Haskell
17:14:57 <LordBrain> srhb, yes, and ultimately haskell programs need that kind of love. but it's not as straight forward really.. you dont see all the memory allocations explicitely coded and all that, but then again, these days c code is optimized to a point that its not really that close to the hardware either as it once was...
17:15:00 <skypers> I‚Äôm just hitting some issues with it
17:15:07 <skypers> and it makes me crazy
17:15:28 <LordBrain> i think eventually haskell will improve a lot at low level things
17:15:31 <mm_freak_> skypers: alright, but we try hard to answer your questions and give you useful solutions, but you reject everything we give you
17:15:35 <srhb> LordBrain: I suppose so. Reasoning about it is different for sure, at least. And reasoning about memory specifically can get hairy, sure. :)
17:15:37 <mm_freak_> skypers: so how are we supposed to help you?
17:16:02 <skypers> mm_freak_: I‚Äôm not rejecting, I just don‚Äôt understand
17:16:27 <skypers> I don‚Äôt understand how you can think that a ‚ÄúMap‚Äù would be better than a bare array
17:16:38 <mm_freak_> skypers: but you don't understand in a very opinionated way‚Ä¶  it's by far not the first time i told you, "just try it!"
17:16:38 <startling> sigh.
17:16:44 <srhb> When I started doing small games in Haskell I used to pass everything around explicitly because Monads are hard.
17:16:54 <mm_freak_> skypers: you can't learn haskell by reading or talking‚Ä¶  you can only learn it by coding
17:17:05 <srhb> I could not for the life of me see how things would end up better even than what I was used to in other languages by doing it right. :-)
17:17:09 <skypers> mm_freak_: very true statement
17:17:14 <skypers> and my engine is almost done
17:17:21 <skypers> I‚Äôll have my ‚Äúconcrete‚Äù answers soon
17:17:23 <skypers> but hm
17:17:31 <EvanR> srhb: im avoiding monads too
17:17:39 <skypers> for sure it‚Äôll be poor in performance first
17:17:49 <srhb> EvanR: I'm less scared about throwing StateT at problems now tbh.
17:17:56 <skypers> I‚Äôll profile, and I‚Äôm worried to be lost
17:18:11 <mm_freak_> skypers: don't try everything in the context of your game engine‚Ä¶  there is nothing wrong with firing up your editor and writing some short toy code
17:18:15 <skypers> because of the reference issue for instance
17:18:19 <srhb> skypers: Stop worrying, finish it, then rewrite it with different methods, profit? :-)
17:18:31 <skypers> yeha
17:18:36 <LordBrain> in some ways, i think our lower level stuff should adapt to haskell actually... like c compilers outputing to an object format that makes .hi files unnecessary..
17:18:37 <skypers> I should stop thinking of that
17:19:12 <EvanR> srhb: i guess i got annoyed with ReaderT because i felt silly not just passing the reader context in as the first param, exactly what Reader(T) does
17:19:31 <EvanR> one less line of code so you dont have to asks ;)
17:19:37 <skypers> monads are great, especially State(T)
17:19:40 <mm_freak_> skypers: most of the time when i measure performance, i do it outside of any real project
17:19:41 <srhb> EvanR: Haha
17:19:49 <mm_freak_> that's why i post all those snippets all the time
17:19:54 <mm_freak_> lpaste must be full of my benchmarks
17:19:57 <skypers> mm_freak_: and this might be a terrible mistake
17:20:17 <mm_freak_> skypers: no, because then i have a rough idea how things will behave, before i integrate them
17:20:25 <skypers> because ‚Äúother people‚Äù point their fingers at us and claim we benchmark ‚Äútoy examples, not seriousl business‚Äù
17:20:34 <skypers> -l
17:20:54 <monochrom> I recommend ignoring "other people"
17:21:01 <skypers> no monochrom
17:21:02 <mm_freak_> me, too
17:21:06 <skypers> other people are important
17:21:17 <mm_freak_> other people yes, but "other people" probably not
17:21:20 <skypers> they have enough hindsight we sometimes don‚Äôt
17:21:25 <srhb> Ehm.
17:21:27 <srhb> Okay.
17:21:28 <edwardk> skypers: the reason why people can look at you with a straight face and recommend trying to use a map rather than a direct reference is because frankly it works, and it often works better than the naive reference.
17:21:36 <edwardk> there is a time and a place for a reference
17:21:40 <edwardk> but there is a _real cost_
17:21:51 <skypers> what cost?
17:22:00 <edwardk> you lose the ability to backtrack to previous versions, snapshot, readers now conflict with writers...
17:22:10 <mm_freak_> skypers: also i'd like to point out that i have these things in use in real systems that i have written in haskell
17:22:15 <edwardk> add non-determinism and backtracking
17:22:25 <skypers> mm_freak_: which things?
17:22:29 <edwardk> and you're screwed in a world with mutation everywhere and references
17:22:40 <skypers> yeah
17:22:43 <edwardk> they become very brittle and hard to get right
17:22:45 <mm_freak_> skypers: i'm doing network services
17:22:53 <monochrom> I don't mean to ignore their hindsight
17:22:58 <skypers> so my currently in-place solution is not that bad after all (i.e. using indices as references)
17:23:07 <skypers> ok mm_freak_
17:23:09 <skypers> interesting
17:23:26 <edwardk> skypers: the systems i like to work on are pretty much the antithesis of toy examples ;)
17:23:37 <mm_freak_> skypers: that was my original motivation for writing an FRP framework in the first place, and that's where "netwire" got its name from =)
17:23:38 <skypers> :)
17:23:47 <edwardk> skypers: the toy examples are because its hard to introduce the theory and the hard cases at the same time
17:23:53 <mm_freak_> i wanted a high-performance declarative event-handling abstraction
17:23:55 <edwardk> so we stop and introduce simple cases to showcase the theory
17:24:14 <skypers> ok, I see
17:24:43 <jle`> i always thought it was from nethack
17:24:54 <mm_freak_> and it's completely functional, inside as well as outside‚Ä¶  no mutable variables, no references, no updates, ‚Ä¶
17:25:09 <edwardk> he thing is when you only know one way to optimize you've shut down all access to the 'work smarter not harder' alternatives
17:25:33 <edwardk> i turn to brute force constant-focused optimization as a last resort
17:25:49 <skypers> edwardk: you‚Äôre also the guy who thinks boilerplate is wrong
17:25:56 <edwardk> yes.
17:26:22 <skypers> I think boilerplate-avoiding introduces complexity and kills the learning curve
17:26:27 <mm_freak_> we have a compiler that writes most of the boilerplate code for us‚Ä¶  why would we repeat? =)
17:26:33 <edwardk> i'd rather collect the salaries of the people who would still be writing the boilerplate solution when mine spits out the answer.
17:26:59 <skypers> you‚Äôre tyranic! :)
17:27:06 <mm_freak_> skypers: it has a learning curve, but it's not really more complex
17:27:13 <mm_freak_> just don't be afraid of new terminology
17:27:20 <mm_freak_> and yes, i'm like edwardk in that regard =)
17:27:21 <LordBrain> what is a boilerplate solution vs a non boilerplate? are we just talking about the level of polymorphism or something?
17:27:28 <skypers> Haskell is always ‚Äúnew‚Äù
17:27:36 <mm_freak_> LordBrain: the level of reinventing stuff
17:27:39 <nh2> edwardk: do you actually get paid in number-of-programmers-equivalent?
17:27:39 <skypers> LordBrain: best example to me: lens.
17:27:44 <edwardk> skypers: the tools i like to use have a learning curve that looks like http://images.mmorpg.com/features/4577/images/LearningCurve.jpg
17:27:54 <edwardk> nh2: i have in the past
17:27:55 <srhb> nh2: I do. Approx 1/10 of one programmer.
17:27:56 <skypers> I‚Äôd rather prefer my one way to traverse an indexed stuff
17:28:02 <LordBrain> lens is a word, not a sentence, not sure what you are saying
17:28:04 <srhb> :<
17:28:07 <skypers> than using !.@"¬ª-)‚Åæ operator
17:28:10 <skypers> and so on
17:28:15 <LordBrain> oh i see
17:28:21 <skypers> LordBrain: I mean the lens library
17:28:38 <orion> I am trying to understand the Writer Monad. If it didn't have the "tell" function, would the whole monad be useless?
17:28:42 <srhb> Forgoing abstraction in Haskell is going to be terrible.
17:28:52 <edwardk> anyways, i have no objection to trying to flatten the curves on the best tools i know. i'm all for it. but i'll be damned if i'm going to choose to work with worse ones.
17:28:53 <EvanR> orion: yeah
17:29:06 <monochrom> skypers, you are really welcome to use whatever method you like, and compete with edwardk. it's a free market.
17:29:14 <LordBrain> i avoid lens only because it uses template haskell
17:29:18 <mm_freak_> edwardk: i think the graph confuses its axes
17:29:21 <jle`> LordBrain: it does?
17:29:24 <jle`> ...?
17:29:26 <skypers> I don‚Äôt want to compete with edwardk
17:29:34 <edwardk> LordBrain: you don't need to use TH to use lens
17:29:43 <jle`> lens is just...normal haskell
17:29:51 <skypers> for two reasons: I‚Äôm weaker for sure, and I have no idea what all abstractions he uses are
17:29:59 <LordBrain> which lens library?
17:30:02 <jle`> what part of lens requires template haskell
17:30:03 <skypers> lens
17:30:17 <edwardk> LordBrain: you don't need to use makeLenses to work with the 'lens' package.
17:30:21 <srhb> LordBrain: These days I think you can safely assume "lens" at all times.
17:30:24 <edwardk> LordBrain: it just make it easier
17:30:27 <orion> So, in general, all monads are merely a way to sequence actions where each action operates in the context of a particular state.
17:30:29 <mm_freak_> orion: without 'tell' you would get a constant out of every run:  mempty
17:30:34 <orion> Is that an accudate description?
17:30:35 <mm_freak_> orion: so it would be equivalent to Identity
17:30:38 <orion> accurate*
17:30:40 <LordBrain> it's a package dependency
17:30:48 <jle`> orion: well. that's not all they are.
17:30:55 <mm_freak_> orion: well, your idea seems correct, but your terminology is way off =)
17:30:56 <skypers> the lens package, that lets you make coffee
17:30:56 <srhb> orion: You've described some monads.
17:31:00 <edwardk> orion: that is an accurate description of the _state_ monad, but not all monads are the state monad.
17:31:02 <jle`> all they are: return, join, fmap, following laws
17:31:04 <skypers> and also bake some food ‚Äúif you want to‚Äù
17:31:05 <skypers> ;)
17:31:09 <srhb> orion: But really, finding a new burrito analogy is not going to do you any good.
17:31:16 <jle`> that's like saying "is Eq only a way to compare numbers?"
17:31:24 <orion> But I like burritos? :(
17:31:30 <skypers> :D
17:31:31 <LordBrain> Dependencies: template-haskell (>=2.4 && <2.11)   <--- taken from https://hackage.haskell.org/package/lens
17:31:33 <srhb> orion: Fine :P
17:31:51 <edwardk> LordBrain: i'm working with some folks to enable building lens on stage1 platforms.
17:31:55 <jle`> LordBrain: that's only for some extra and unecessary but useful features
17:32:01 <mm_freak_> orion: monads have some monadic-specific effects‚Ä¶  the monadic interface allows you to compose values with such effects, respecting the effects, but the monadic interface itself cannot /introduce/ those effects
17:32:03 <monochrom> orion: I am not sure in what sense every monad has a "context of state". I think you can safely delete it.
17:32:21 <LordBrain> well someone should maybe separate it out and have a lens-noth package
17:32:23 <mm_freak_> orion: in other words you can't construct a Nothing, you can't change the state, you can't read the environment, you can't yield a value, etc.
17:32:51 <monochrom> and if you say, after deleting it, the sentence "sequencing some actions" is too bland, that is exactly right. the combo of merely "return" and ">>=" is really bland.
17:32:51 <mm_freak_> you need monad-specific functions for that
17:32:53 <nh2> for IO things that run fast (e.g. a point cloud viewer with opengl), I made a very positive experience with passing in a State record full of IORefs. The full mutability doesn't feel very nice, but it's very simple to use, great to read, and is free of performance traps that come with monad transformer stacks
17:32:53 <edwardk> LordBrain: IIRC nothing prevents you BUILDING template-haskell on a stage1 system, merely using it.
17:33:42 <samba1> I've read this today, an old post about backtracking as an intro to monads: http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes
17:33:47 <samba1> and so I tried to redo it with a distinct Choice type (not just an alias to List) and made it an instance of Monad. It works, but it's ugly. Am I missing a better way? The important code:
17:33:50 <edwardk> LordBrain: the template-haskell package and the TemplateHaskell language extension are two different things.
17:33:51 <samba1> data Choice a = Choice { getChoice :: [a] }
17:33:53 <samba1> choose :: [a] -> Choice a
17:33:56 <samba1> choose xs = Choice xs
17:33:58 <samba1> instance Monad Choice where return x = choose [x] choices >>= f = Choice . concatMap getChoice . map f . getChoice $ choices
17:34:12 <samba1> errr, the instance didn't paste well
17:34:19 <srhb> samba1: lpaste.net is nice and doesn't flood as much :-)
17:34:20 <edwardk> LordBrain: what do you run on that can't use template-haskell?
17:34:25 <mm_freak_> nh2: next time pass a storable vector to a buffer object
17:34:36 <mm_freak_> nh2: that gives you pretty much C speed
17:34:42 <monochrom> nh2: would it be faster replacing State by Reader? (and before that, would it give the same answer?)
17:34:48 <jle`> LordBrain: would you not use the Aeson library either?  it provides lots of tools for json parsing and loading and serialization
17:34:52 <samba1> http://lpaste.net/103235
17:34:55 <LordBrain> i was working on a project with others and a conscious decision was made not to introduce that dependency. my hardware can run template haskell fine
17:35:01 <mm_freak_> nh2: + you get most of what OpenGL can give you in performance =)
17:35:12 <jle`> one of the extra features is to automatically write a toJson instance for a given data type
17:35:19 <jle`> but...you don't have to use it, you can always just write them manually
17:35:22 <nh2> mm_freak_: I think you are talking about something else (more specific), and something that I'm doing
17:35:25 <jle`> would you be against aeson?
17:35:34 <jle`> (the automatically written tojson instances are TH)
17:35:41 <edwardk> LordBrain: *shrug* then I can't help you. I _will_ make lens build without TemplateHaskell, but the template-haskell dependency will remain unused even on stage1 platforms.
17:35:54 <edwardk> the alternatives are not tenable from an API perspectiv.
17:36:04 <skypers> ok
17:36:10 <mm_freak_> nh2: i'm just providing a way to get high speed rendering without mutability =)
17:36:13 <skypers> I‚Äôm off, it‚Äôs 2:35 AM
17:36:19 <skypers> thank you all for your help
17:36:34 <skypers> I still think and I will that I‚Äôm a dog poo
17:36:38 <nh2> monochrom: by "State" do you mean my State record or the StateT? What I mean that I'm writing is functions of type MyState -> IO ()
17:36:44 <jle`> samba1: well you can pattern match out the list
17:36:46 <edwardk> LordBrain: all i can do is make lens compelling enough that you guys are driven to reconsider your decision ;)
17:36:49 <srhb> samba1: Isn't concatMap kinda cheating?
17:36:51 <skypers> but hm, it‚Äôs normal, I‚Äôm writing Haskell code :D
17:36:56 <skypers> see you
17:36:56 <jle`> (Choice xs) >>= f =
17:37:15 <orion> Is this a correct statement?: A Maybe monad is a sequence of actions that ultimately results in a "Maybe a", where 'a' is some type. Users can pull the value of type 'a' out of the Maybe monad by using pattern matching.
17:37:23 <mm_freak_> orion: no
17:37:30 <monochrom> nh2: I thought StateT. I now see you don't mean that. then you've got it as fast as possible. :)
17:37:30 <mm_freak_> /the/ Maybe monad
17:37:35 <jle`> orion: Maybe is a monad
17:37:42 <samba1> um... i dunno
17:37:46 <mm_freak_> orion: a monad is a type (!) of kind * -> *
17:38:10 <skypers> yeah, Maybe is _considered_ as monad
17:38:14 <skypers> in your case
17:38:16 <mm_freak_> orion: also if you're currently writing a monad tutorial, you may want to read byorgey's monad tutorial fallacy first =)
17:38:19 <srhb> samba1: Well, not sure what you're trying to learn from this. But the key intuition in instance Monad [] where... is exactly concatMap
17:38:21 <samba1> yeah, the (Choice xs) helps a bit
17:38:34 <jle`> notice that all the functions in the Monad typeclass return (m a)
17:38:35 <nh2> mm_freak_: you mean creating `BufferObject`s from Storable vectors, yes, I'm doing that; what I meant is that I have a MyState{ ... } passing around that contains IORefs containing my allocated BufferObjects, the current view position etc.
17:38:36 <jle`> :t (>>=)
17:38:37 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:38:40 <orion> mm_freak_: I am not. I am trying to teach Haskell to myself by regurgitating what other people write in my own words.
17:38:41 <jle`> :t join
17:38:42 <lambdabot> Monad m => m (m a) -> m a
17:38:55 <edwardk> LordBrain: if the complaint is that you don't want the build times of using TemplateHaskell I can address that, but ruling out a package is somewhat more of a non-starter.
17:38:56 <mm_freak_> nh2: ah
17:38:57 <jle`> :t return
17:38:58 <lambdabot> Monad m => a -> m a
17:39:08 <mm_freak_> orion: ah, that's fine =)
17:39:09 <jle`> but you can't say that a monad is a sequence of actions
17:39:15 <orion> ok
17:39:16 <glguy> especially a package that comes with GHC which you never update yourself
17:39:16 <jle`> a monad is just...what it is.
17:39:20 <monochrom> @type concatMap
17:39:21 <lambdabot> (a -> [b]) -> [a] -> [b]
17:39:24 <edwardk> yep
17:39:36 <mm_freak_> orion: the general idea is correct, but always keep in mind that monads are /types/, and not concrete types, but type constructors
17:39:46 <mm_freak_> orion: IO is a monad, IO String is not, Maybe is a monad, Maybe Int is not
17:39:52 <mm_freak_> and Nothing is not a monad, because it's not even a type
17:39:58 <orion> So, when I write "myFunc = do { ...; }", what do I call "myFunc"?
17:40:14 <mm_freak_> orion: is it over a specific monad?
17:40:15 <jle`> myFunc
17:40:20 <EvanR> i remember all this jargon being very confusing when i started learning haskell
17:40:22 <jle`> it is a value :)
17:40:33 <jle`> there actually isn't a generic term for "m a"
17:40:36 <jle`> where m is a monad
17:40:41 <jle`> i have heard it called a mote
17:40:48 <jle`> but that's a little silly
17:40:54 <jle`> in IO, IO a is often called an IO action
17:40:55 <orion> What makes "myFunc = do { ...; }" different from "myOtherFunc = 1+2+3+4" ?
17:40:57 * monochrom has a cunning plan!
17:41:03 <jle`> orion: nothing?
17:41:03 <mm_freak_> orion: if the monad is general, you could call it 'monadic value'
17:41:13 <mm_freak_> orion: for some monads 'action' is appropriate, but only for some
17:41:25 <mm_freak_> "IO action", "state transition", "parametric value (reader)", ‚Ä¶
17:41:28 <LordBrain> edwardk, Partly the build time was a concern, but i think also the concern is that we might end up hacking on something that uses TH, which we wanted to avoid because we didn't consider it's api stable.. And back then there were calls for an alternative meta programming system.
17:41:28 <samba1> instnace Monad [] where --- what is concatMap?
17:41:36 <nh2> orion: I call it a "monadic function" or a "monadic value" or an "action"
17:41:38 <EvanR> heh the documentation for applicative is referring to "actions" that is confusing
17:41:53 <jle`> samba1: concatMap is a function that happens to do exactly what (>>=) is supposed to do
17:42:13 <startling> :t concatMap
17:42:14 <lambdabot> (a -> [b]) -> [a] -> [b]
17:42:14 <jle`> for lists
17:42:29 <startling> > concatMap (\a -> [1, a]) [2, 4, 6, 8]
17:42:30 <lambdabot>  [1,2,1,4,1,6,1,8]
17:42:31 <monochrom> samba1: it seems to me "(Choice xs) >>= f = Choice (xs >>= f)" would look really slick or smartass depending on how you look at it :)  the RHS >>= refers to []'s. I rationalize it by saying "you already used concatMap originally, which is equivalent"
17:42:41 <orion> nh2: Are functions merely just unevaluated values?
17:42:42 <jle`> :t (>>=) `asAppliedTo` []
17:42:43 <lambdabot> [a] -> (a -> [b]) -> [b]
17:42:50 <jle`> orion: well...functions are values
17:42:53 <monochrom> oh wait, nevermind, it's a type error
17:42:54 <mm_freak_> orion: dependent values
17:42:55 <startling> orion: no
17:42:55 <jle`> with type a -> b
17:43:03 <mm_freak_> orion: parametric values‚Ä¶  values that depend on other values
17:43:37 <srhb> samba1: It is how >>= is defined for []
17:43:49 <mm_freak_> just like in math, where you can view a line as a parametric point =)
17:43:57 <orion> So when I write, "x = do { ... }", x is a value.
17:43:58 <monochrom> oh, I see how to fix it. Choice xs >>= f = Choice (xs >>= (getChoice . f))
17:44:03 <mm_freak_> orion: yes
17:44:06 <jle`> orion: yes, just like anything else
17:44:09 <orion> It's a value whose type is some Monad.
17:44:16 <mm_freak_> orion: no
17:44:17 <jle`> er no
17:44:20 <jle`> Monad is not a type
17:44:22 <mm_freak_> orion: it has a monad in its type
17:44:24 <glguy> LordBrain: All you do is omit template-haskell from *your* packages build-depends list and it won't be available for you to accidentally wake up one night and find yourself having started using it
17:44:27 <mm_freak_> orion: x :: Maybe Int
17:44:32 <glguy> you have the package installed already
17:44:33 <mm_freak_> notice that its type is /not/ a monad
17:44:34 <orion> mm_freak_: Hence, "/some/ Monad"
17:44:45 <mm_freak_> orion: Maybe is a monad, but Maybe Int is not
17:44:46 <jle`> if m is a Monad, then its type is m a
17:44:52 <jle`> m a is not m
17:44:52 <orion> oh, weird.
17:45:03 <mm_freak_> orion: note also that you cannot have a value of type Maybe
17:45:05 <jle`> > "m a" == "m"
17:45:06 <lambdabot>  False
17:45:09 <orion> ok
17:45:17 <samba1> hm, well, i'm not sure how else to do it... maybe the problem is the data type of choice, keeping it as a list internally and just decorating
17:45:50 <mm_freak_> orion: what's the type of getLine?
17:45:51 <jle`> samba1: do you like monochrom's solution
17:46:01 <nh2> orion: no, when I'm using Haskell functions are things that take some or 0 parameters, so a value is for me a function that always returns the same result
17:46:03 <jle`> well
17:46:09 <jle`> remember that (>>=) is just an fmap and a join
17:46:17 <jle`> so if you implemented fmap and join on your data
17:46:31 <jle`> then you can just say x >>= f = join (fmap f x)
17:46:38 <mm_freak_> nh2: IMO that's a horrible way to look at non-function values‚Ä¶
17:46:39 <orion> :t getLine
17:46:40 <lambdabot> IO String
17:46:44 <orion> mm_freak_: ^
17:46:46 <glguy> Functions in Haskell take exactly one argument
17:46:50 <mm_freak_> orion: what's the kind of that type?
17:46:58 <LordBrain> glguy, that assumes the package we use never needs customizing by us, something which i think is probably fair, but not an assumption my collaborator would make.
17:47:07 <monochrom> here is how to write using just map and concat. Choice xs >>= f = Choice (concat (map (getChoice . f) xs))
17:47:09 <mm_freak_> orion: answer this without cheating =)
17:47:17 <edwardk> LordBrain: i ship versions of packages that work stably back to ghc 6.8 and which work with template-haskell. he patches to deal with TH changes are smaller than the patches to deal with other changes in the compiler and it comes with ghc.
17:47:30 <orion> *
17:47:34 <nh2> mm_freak_: how do you find it horrible?
17:47:40 <edwardk> LordBrain: I can totaly sympathize about the build times argument, but that is about the extension, not a transitive dependency on the package per se.
17:47:41 <orion> Because it's a value.
17:47:42 <mm_freak_> orion: is the type of getLine a monad?
17:47:48 <orion> No.
17:47:52 <mm_freak_> why not?
17:48:03 <orion> Its type is "IO String"
17:48:07 <mm_freak_> nh2: because every function in haskell takes exactly one argument
17:48:16 <mm_freak_> orion: why can't that be a monad?
17:48:56 <edwardk> LordBrain: the libraries I write have literally all of their guts exposed via internals modules. if you find you need a part exposed that I don't expose? i'd probably consider that a design defect. =P
17:48:59 <orion> Because "IO String" != "Monad IO"?
17:49:10 <mm_freak_> orion: try to answer in terms of kinds
17:49:17 <jle`> i wish join was in the Monad typeclass
17:49:17 <LordBrain> edwardk, if you can cut the build times, i might be able to persuade my collaborator at some point
17:49:30 <mm_freak_> nh2: functions are well-defined‚Ä¶  you're introducing taint into that definition, because suddenly you have functions that can't be applied, which seems weird
17:49:33 <jle`> actually, do i
17:49:40 <jle`> maybe i do not
17:49:41 <monochrom> nh2: when I speak precisely, I expect "v is a function" to mean "v :: X -> Y" and "v undefined" type-checks. when I speak loosely, of course I am fine with "getLine is a library function" even though "getLine undefined" does not type-check.
17:49:42 * jle` ponders
17:49:46 <mm_freak_> jle`: i believe after the AMP join will be in Monad
17:50:00 <jle`> oh neat
17:50:02 <edwardk> LordBrain: the current plan is to remove the need for TemplateHaskell the extension itself from building lens itself.
17:50:03 <orion> mm_freak_: The kind of IO String is * (making it a type).
17:50:06 <jle`> i am... amped.
17:50:14 <jle`> orion: and waht is the kind of a Monad?
17:50:15 <orion> mm_freak_: The kind of Monad is "* -> *"
17:50:36 <mm_freak_> orion: well, the kind of monads, not the kind of Monad =)
17:50:40 <mm_freak_> orion: but yeah, you got it
17:50:43 <jle`> :k Monad
17:50:44 <lambdabot> (* -> *) -> Constraint
17:50:44 <jle`> oops
17:50:47 <jle`> :P
17:50:54 <edwardk> the dependency set will remain what it is, but it'll make it deployable for stage1 systems. built times for lens are admittedly on the high side, if they are your bottleneck something like lens-family might be a better entrypoint
17:51:04 <jle`> mm_freak_: have you ever explored discrete Auto's...just your wires without a dt
17:51:06 <orion> So, Monad is not a type, it's more abstract than a type... it's a class.
17:51:18 <orion> A class which can have instances.
17:51:25 <jle`> like... Eq?
17:51:26 <mm_freak_> jle`: yes, use Wire with s = ()
17:51:27 <edwardk> mm_freak_: yes it will be
17:51:28 <nh2> mm_freak_, monochrom: true that, technically speaking that's probably a better way to treat it. My point was that on a conceptual level, a, a->b and a->b->c are similarly "functions" to me
17:51:28 <jle`> Ord?
17:51:31 <hpc> not more abstract, just different
17:51:36 <jle`> mm_freak_: well, the semantics are much different
17:51:39 <jle`> have you found them useful?
17:51:48 <jle`> i wrote a large-ish irc bot using it
17:52:01 <nh2> edwardk: why is it that lens takes long to build?
17:52:04 <jle`> and it allows me to have everything declarative
17:52:11 <jle`> and i like it.  but do other people do this?
17:52:18 <mm_freak_> jle`: absolutely‚Ä¶  in the 'wires' library the inhibition semantics will go away, but i'm back to a fixed time type
17:52:24 <mm_freak_> jle`: making 's' polymorphic was a mistake
17:52:29 <LordBrain> edwardk, it's a shame that people use TH as an argument against extensions, because we'd prefer that actually, if some modest extensions short of TH were implemented that enabled lens without it, we'd be all for that.
17:52:44 <jle`> yeah, why was it again?.  i remember you saying that someone requested it
17:52:59 <shachaf> nh2: Because it has a lot of code.
17:53:07 <shachaf> (In a lot of files.)
17:53:08 <mm_freak_> jle`: yes, someone requested a polymorphic time type, so i turned it into a generic Monoid
17:53:13 <jle`> so kind of you
17:53:14 <orion> hpc: What is one level more abstract than a type?
17:53:30 <srhb> samba1: If you were to not reuse concatMap (but still map) maybe this would do? Choice xs >>= f = Choice . concat . fmap (getChoice . f) $ xs
17:53:42 <mm_freak_> jle`: but it made everything unnecessarily complicated‚Ä¶  in the new abstraction i'm focussing on simplicity
17:54:07 <jle`> mm_freak_: i wrote my own Auto library for this irc bot and i have adopted a lot of similar design decisions that i observe from wires.  things are neat
17:54:11 <orion> Could a class be called a polymorphic type with constraints?
17:54:20 <jle`> so...thanks
17:54:31 <mm_freak_> jle`: you're welcome, but you may have reinvented 'wires' then =)
17:54:33 <edwardk> LordBrain: people who want to supply a lens don't need to use TH at all right now. heck they don't need to even depend on lens.
17:54:39 <srhb> orion: Not really.
17:54:45 <jle`> mm_freak_: well, it is with completely discrete
17:54:46 <samba1> srhb: yes, someone else suggested that too. it works. As does implementing fmap, which i like a little better even. i'm not sure what i'm looking for... it just doesn't seem nice like other monad instances are nice
17:54:52 <samba1> but, it's a weird thing
17:54:56 <jle`> the drive/stepper is incoming IRC messages
17:55:03 <monochrom> samba1: you're looking at the phenomenon that []'s >>= come from concat and map. your only freedom is in how much you re-invent them.
17:55:04 <jle`> with an attached timestamp
17:55:10 <mm_freak_> jle`: you don't have to use dt
17:55:14 <samba1> since it's just an obfuscated list
17:55:15 <edwardk> with ghc 7.10 we're getting the ORF proposal in which lets us convert field accessors to lenses just with a combinator, no TH at all.
17:55:19 <srhb> samba1: Well, the wrapping may be complicating things more for you? Why not try starting with data MyList a = Cons a | Nil ?
17:55:24 <jle`> samba1: typically...we like to use map if we know we have a list
17:55:33 <edwardk> The TH approach is still convenient, but not critical then
17:55:48 <glguy_> Edward, you don't even need lens package to consume them.
17:55:52 <jle`> mm_freak_: yeah, but...semantics are all weird.  i like separating it in my mind
17:55:58 <glguy_> Its just an infectious idea
17:56:06 <jle`> all that training you gave me
17:56:10 <jle`> with recognizing continuous time semantics
17:56:17 <edwardk> glguy_: exactly =)
17:56:21 <jle`> i get nauseous when considering discrete time with Wire
17:56:27 <jle`> some kind of pavlovian reinforcement
17:56:32 <mm_freak_> jle`: actually i'm rewriting the library to include the savegames-for-free idea‚Ä¶  you should be able to define your Auto, give it a Reactive instance and get most wires for free for your own type
17:56:49 <shachaf> You don't need lens to produce or consume lenses. You just need it to complain about them.
17:56:56 <monochrom> mm_freak_: if time is a Monoid, what is time's mempty? :)
17:57:03 <nh2> orion: in difference to many OO languages, where interfaces can be used as types (say Object o = ...), Haskell's interfaces (type classes) are not types. You can't create something "of type Eq", you can only create something of type a with the a constraint that it please implement type class Eq
17:57:06 <edwardk> @remember shachaf You don't need lens to produce or consume lenses. You just need it to complain about them.
17:57:06 <lambdabot> Done.
17:57:06 <mm_freak_> monochrom: "now"
17:57:08 <jle`> mm_freak_: oh hum hum. that is a neat idea
17:57:19 <jle`> mm_freak_: that's deep :P
17:57:20 <monochrom> oh yikes, you got it right
17:57:37 <jle`> mm_freak_: actually i have been exploring some expansions on the save games for free concept
17:57:39 <srhb> Erm.. Cons a (MyList a).. :P
17:58:12 <jle`> because it has been slightly hard to work with for ongoing development of something
17:58:24 <EvanR> whats is Monoid Time's mappend ?
17:58:31 <glguy_> Reddit has shown you don't need to have used the lens package to complain about it, either
17:58:33 <jle`> and it is a slight pain to upgrade savestates...without keeping track of the old structure exactly, i think (?)
17:58:37 <jle`> glguy_: heh
17:58:39 <edwardk> glguy_: ahahahhaa
17:58:45 <mm_freak_> EvanR: +
17:58:48 <EvanR> jle`: safeCopy ;)
17:58:52 <Rarrikins> Guess what time it is! It's Monoid Time!
17:58:55 <EvanR> lol
17:59:05 <mm_freak_> jle`: i have still to figure out how to integrate safecopy nicely
17:59:16 <edwardk> @remember glguy_ Reddit has shown you don't need to have used the lens package to complain about it, either
17:59:16 <lambdabot> I will remember.
17:59:26 <mm_freak_> jle`: but it should be possible, even if it is a bit hacky
17:59:27 <monochrom> hahaha
17:59:33 <mm_freak_> i'm more worried about performance there
17:59:33 <jle`> what is safecopy in this context?
17:59:40 <edwardk> mm_freak_: i still have to figure out how to implement safecopy almost at all =(
17:59:49 <EvanR> jle`: a way to version your serialized values
17:59:55 <EvanR> and auto upgrade them
17:59:57 <edwardk> mm_freak_: its crippled just enough by what it exports that i can't use it
18:00:02 <mm_freak_> jle`: versioned, safely written serialization
18:00:05 <jle`> yeah, if you modify any small part of the auto structure, the naive re-loading fails
18:00:08 <jle`> mm_freak_: ah i see.
18:00:19 <mm_freak_> edwardk: i have exactly the same problem, it seems
18:00:21 <jle`> well my current avenue of exploration seems a little naive then
18:00:46 <mm_freak_> jle`: the main feature of safecopy is automatic migration to new versions
18:01:03 <jle`> are you talkig about a library, or some design thing
18:01:12 <mm_freak_> @hackage safecopy
18:01:12 <lambdabot> http://hackage.haskell.org/package/safecopy
18:01:22 <mm_freak_> its main user is acid-state
18:01:23 <jle`> ah
18:01:50 <LordBrain> edwardk, what exactly is the source of the TH dependency?
18:01:52 <jle`> ah
18:01:56 <jle`> so you keep track of migrations
18:02:15 <mm_freak_> jle`: you define the migrations, and when necessary safecopy performs them
18:02:18 <jle`> clever
18:02:34 <mm_freak_> it's pretty much just applying a function to MyDataV2 to get MyDataV3
18:02:36 <mm_freak_> nothing fancy
18:02:39 <edwardk> LordBrain: http://www.reddit.com/r/haskell/comments/23uzpg/lens_is_unidiomatic_haskell/ch0xy12
18:02:43 <jle`> abstracting it is the neat part
18:03:17 <mm_freak_> jle`: the neat part is that safecopy's TH helper does 99% of the work for you
18:03:31 <jle`> oh
18:03:35 <edwardk> LordBrain: but frankly, 90% of the consumers of the package use makeLenses or makeClassy, so removing the template-haskell package dependency is frankly not an option.
18:03:38 <jle`> wow that's
18:03:41 <jle`> pretty neat
18:04:06 <jle`> are you working on safecopy stuff now? i could put some time into exploring it
18:04:11 <EvanR> safe copy also uses TH
18:04:16 <EvanR> which wierds me out
18:04:25 <edwardk> removing the TemplateHaskell dependency to build clean on exotic platforms is doable.
18:04:41 <mm_freak_> jle`: safecopy is difficult to integrate into anything that changes
18:04:46 <mm_freak_> like a wire
18:04:49 <mm_freak_> or an automaton
18:05:00 <orion> Is there a Venn diagram somewhere containing Haskell terminology?
18:05:13 <jle`> orion: hm?
18:05:18 <edwardk> http://packdeps.haskellers.com/reverse/lens is just the first order dependencies
18:05:18 <EvanR> orion: i would like to see such a thing too
18:05:32 <mm_freak_> jle`: but something like safecopy is the key to full savegames-for-free‚Ä¶  i'm afraid i'll have to reinvent it though
18:05:41 <mm_freak_> the current safecopy is really awkward for this kind of project
18:06:03 <orion> http://jdcruzan.tripod.com/Images/NumbersVennDiagram.png
18:06:18 <orion> Something like that except for classes, types, kinds, values, etc.
18:06:32 <mm_freak_> most likely safecopy was and is written mainly with acid-state in mind, not with general versioned serialization
18:07:06 <jle`> well my current approach was to basically associate some sort of optional namespace for every wire, which is by default empty for wire primitives and will be serialized normally like how it would be as you had it so far
18:07:15 <jle`> but offer a function
18:07:21 <edwardk> mm_freak_: exactly
18:07:28 <jle`> editNamespace :: Wire a b -> NameSpace -> Wire a b
18:07:38 <mm_freak_> jle`: i'm going for a different approach
18:07:42 <edwardk> what i want is something i can do explicit extensions to the protocol, leave off defaults, etc.
18:07:57 <edwardk> i'm okay if that has to be some applicative noise
18:08:11 <edwardk> or something like a lens like ting where i pass through 'f's
18:08:13 <edwardk> er thing
18:08:40 <mm_freak_> jle`: savegame regions
18:08:58 <mm_freak_> (i'm still calling it "savegame", which is not really appropriate)
18:09:01 <mm_freak_> state regions
18:09:03 <jle`> from my english semantic evaluation capabilities
18:09:05 <jle`> this sounds similar
18:09:10 <mm_freak_> edwardk: i can poke you when i start working on it
18:09:24 <jle`> but i am likely wrong
18:09:44 <edwardk> mm_freak_: do so. i've also got some work i've been doing on succinct lazy (de)serialization as well that i'm looking to integrate into something
18:10:04 <mm_freak_> jle`: i don't have namespaces, i have this:  save :: Wire m a b -> Wire m a (b, WireState m a b)
18:10:11 <edwardk> so you can make a form of Data.Binary that you only pay for the parts of the resulting structure you look at, but the storage remains tight.
18:10:34 <jle`> mm_freak_: ah
18:11:13 <mm_freak_> edwardk: that sounds like a simple applicative/category combinator library to me, similar to boomerang
18:11:35 <edwardk> mm_freak_: its very similar in many ways
18:12:49 <mm_freak_> so pretty much a binary boomerang
18:13:00 <edwardk> i've been meaning to build a profunctor based pretty/parser
18:13:34 <edwardk> well, more like a succinctly encoded lazily deserialized Data.Binary
18:13:37 <mm_freak_> hmm‚Ä¶  that wouldn't work for me, though
18:13:47 <edwardk> not sure if i care that it can be switched to a boomerang style
18:14:03 <mm_freak_> my current approach to deserializing wires is:  you give me a template wire together with a binary blob, i give you a wire with updated state
18:14:20 <edwardk> i've been relatively underwhelmed by that approach, but it'd be nice to just have on thing to compose rather than 2
18:14:58 <jle`> mm_freak_: what is the template wire?
18:15:07 <mm_freak_> jle`: the initial wire
18:15:24 <jle`> oh, you mean right now
18:15:38 <jle`> not in regards to safecopy/updating stuff
18:15:46 <mm_freak_> jle`: the trouble is that you can't serialize haskell programs, but you can serialize their state, and given the haskell program (which knows its compositional structure) and the state, you can get a program back
18:15:51 <edwardk> anyways a prism seems to give the right vocabulary for the matching combinators
18:16:15 <edwardk> so i may be able to do a principled boomerang clone in that regard
18:16:29 <jle`> ofc
18:17:15 <mm_freak_> jle`: that concept is what i refer to as "savegames for free"
18:18:08 <jle`> which is...all fine and dandy, until you change your program and lose the original program structure, right?
18:18:31 <mm_freak_> correct‚Ä¶  unless you have something like safecopy to rescue it
18:18:40 <mm_freak_> that's why i'm researching it
18:19:11 <Algebr> Do there exist like pictures of graphs of prelude typeclasses? Something on numbers would be awesome.
18:19:23 <jle`> hm there is one on the number typeclasses floating around
18:19:34 <jle`> the hierarchy
18:19:51 <srhb> Typeclassopedia has some for the more interesting classes, I think
18:19:59 <mm_freak_> anyway, i remember why i left this channel =)
18:20:00 <mm_freak_> bye everyone
18:20:09 <Algebr> oh, simple google image search yields lots of good results.
18:22:58 <nh2> this one looks useful http://www.haskell.org/onlinereport/haskell2010/haskell2x.png
18:27:44 <LordBrain> edwardk, well, i don't mean to be a nussiance here but 90% of the users could also just install another package
18:28:25 <LordBrain> as in a recommended package called make-lens or something
18:29:41 <edwardk> LordBrain: Control.Lens directly re-exports the Control.Lens.TH API. It is a breaking change that affects all of my users. You've already pointed out that the sole reason you'd want it is because of an internal team decision, not for a technical reason. I get a half a dozen of these requests all requesting I remove some piece of lens from the package. They all want different parts removed!
18:30:16 <edwardk> LordBrain: If I gave into them all lens would be 8 packages and unmaintainable.
18:30:45 <LordBrain> hmmm
18:31:04 <edwardk> If you want to have something that is crippled in that particular fashion because of deployment requirements or otherwise, I can invite you to investigate lens-family, which uses no template-haskell
18:31:16 <edwardk> or lens-family-core which is entirely 100% haskell 98 compatible
18:31:39 <edwardk> both of those packages are lens compatible
18:40:35 <lispy> edwardk: so they're pretty good packages?
18:41:06 <edwardk> lispy: well, i disliked them enough to go and write lens, but i can say they are compatible enough to get you started ;)
18:41:16 <edwardk> I just couldn't bring myself to use a module named Lens.Family2
18:41:18 <edwardk> =)
18:41:52 <lispy> edwardk: some of us at work were lamenting the size of lens (as people often do) while simultaneously wishing that some kernel of lens (someone suggestion, "monocle") was in base.
18:42:38 <shachaf> I frequently lament how small lens is. But we're doing our best.
18:42:44 <edwardk> 'how to make a slimmed down lens without crippling it' is actually a deceptively difficult problem
18:43:05 <edwardk> heh
18:43:16 <lispy> shachaf: Excellent
18:43:34 <lispy> although, I don't think anyone was objecting to the size of lens
18:43:42 <lispy> I should have said lens's dependencies
18:44:28 <edwardk> lispy: this comes up a lot on #haskell-lens. there are roughly 4-5 of lens's dependencies that are gratuitous. the rest come from the API we expose
18:44:49 <lispy> edwardk: Is it possible to peel off part of it for base while leaving the rest of the goodness to a lens-extras package?
18:45:06 <edwardk> i honestly think it is currenty not
18:45:21 <edwardk> i keep revisiting this problem and bouncing off of it
18:45:22 <lispy> do you know what the challenges are?
18:45:25 <edwardk> yes
18:45:50 <edwardk> we've gone through and spend a week here and a week there trying it
18:45:55 <lispy> I don't; so it's easy for me to be all "peanut gallery" about it
18:45:57 <LordBrain> seems like part of the challenge is figuring out what to peel
18:46:13 <edwardk> there are at least 4 audiences all of which want very different things out of any core.
18:46:29 <edwardk> so to be honest you don't get one core.
18:46:50 <jonsterling> I honestly don't mind having all the "astronautics" packages as dependencies... I'm less excited about the dependencies which export mainly concrete types & functions. But is does seem super hard to figure out what the right things are to keep in core w/o frustrating some 80% of users...
18:47:32 <edwardk> one crowd doesn't want TH at all. one only wants TH, one wants the types, one doesn't want the indexed types because they take you up to a world with extensions, another crowd wants some basic combinators for building them. another wants some stuff for consuming them.
18:47:49 <jonsterling> Seems pretty intractable to please everyone...
18:48:17 <lispy> edwardk: If base was the goal then you'd have to cut the TH
18:48:26 <edwardk> jonsterling: as a rule i've chosen to do what is best for the continuing development of lens, which is to keep things in one place that we can build together and which exposes a single consistent API for users
18:48:31 <lispy> (I presume anyway)
18:48:31 <edwardk> lispy: of course
18:48:32 <LordBrain> just please me
18:48:39 <edwardk> i'm not aiming for base
18:48:47 <edwardk> i'm not really aiming for the platform either
18:48:47 <LordBrain> :)
18:49:46 <lispy> edwardk: if there is anything I can do to make it more of a PITA to please everyone, then let me know :)
18:49:48 <edwardk> jonsterling: the 'concrete types and functions' packages are a pretty small set of dependencies. other than aeson, which i will admit shouldn't have been added! they are all packages in the platform
18:49:50 <jonsterling> edwardk: Yeah, that seems pretty sane... If the lens revelations are ever totally exhausted, it might make sense to break it up. But it would be a shame to make further development intractable by breaking it up now...
18:50:23 <lispy> are those ones deps just to avoid orphans?
18:50:24 <jonsterling> edwardk: Yeah, aeson is the one that makes me a little queasy :)...
18:50:47 <edwardk> lispy: no
18:50:59 <edwardk> lispy: we use unordered-containers to implement TH for instance
18:51:16 <edwardk> we also have a bunch of classes for things like At, those classes are really for orphans
18:51:34 <edwardk> and frankly any solution that leaves me beholden to orphan packages is not a solution
18:52:02 <edwardk> but those classes exist because we _already had the dependencies_
18:52:09 <nh2> edwardk: might the now-implemented OverloadedRecordFields change the way lens can work, or maybe rid it of the TH? I don't know much about the extension yet, but I hope the talk on Monday enlightens me
18:52:13 <jonsterling> üé∂ * M O D U L E S     A R E      A L L     Y O U    N E E D *  üé∂
18:52:15 <edwardk> we have some stuff that is in the platform that we write lenses for just to write lenses fror them
18:52:44 <rgrinberg> is it possible to reuse the same cabal sandbox between 2 packages?
18:52:46 <edwardk> but ts only the stuff in the platform that we break the 'only what we need rules for, or a couple of other packages.
18:53:06 <edwardk> nh2: ORF doesn't give you enough to fully eradicate the desire for TH
18:53:12 <edwardk> nh2: it removes a lot of pressure though
18:53:23 <edwardk> but ORF lenses will always require a combinator to access
18:53:55 <edwardk> this makes them more verbose, and they are going to be less principed to use than makeClassy style lenses
18:53:58 <lispy> rgrinberg: yes, there is flag that you use when you run cabal sandbox init that tells it where to store the goodies
18:54:05 <edwardk> even with ORF I will keep using makeClassy.
18:54:37 <edwardk> they are closer to makeFields
18:55:07 <nh2> thanks
18:55:12 <edwardk> nh2: also keep in mind something going into GHC 7.10 won't clear lens of a dependency regardless. we support versions of lens back to GHC 7.0
18:55:39 <edwardk> (3.7 for >= 7.0 and < 7.4, lens 4.1.x for 7.4+)
18:56:03 <lispy> edwardk: I only find two things cumbersome about the deps: build times and TH doesn't work everywhere (hasn't been a problem for me lately). So for me, complaining about the deps is mostly just wishing things were more ideal and not about being a show stopper.
18:56:23 <edwardk> lispy: we're removing the need for TemplateHaskell in the build of lens itself to support stage1 builds
18:56:26 <edwardk> that is happening already
18:56:40 <startling> neat!
18:56:57 <edwardk> we'll still need template-haskell to avoid exporting a changing API, but not LANGUAGE TemplateHaskell
18:57:18 <edwardk> build times? i can sympathize with
18:57:58 <lispy> oh, will ghc start to use lens?
18:58:01 <lispy> that's exciting
18:58:22 <edwardk> lispy: ORF makes it possible for 'lens to support itself' with the new machinery
18:58:39 <edwardk> it actually works better for all the other lens libraries than for lens itself.
18:58:44 <startling> heh
18:58:49 <lispy> I hadn't heard of the proposal until now.
18:58:53 <lispy> I should go read up
18:59:00 <edwardk> fclabels and data-lens will have a good day when it ships
19:02:01 <carter> lispy: whats this about ghc using lense?
19:02:11 <carter> ???
19:04:03 <lispy> edwardk: the article on the well-typed blog makes me think of row types
19:04:07 <lispy> http://www.well-typed.com/blog/84/
19:04:11 <edwardk> carter: the records proposal makes it possble for us to wrte a combinator to use any field accessor as a lens in a slightly more principled way than 'upon'
19:04:18 <carter> yes
19:04:28 <carter> i thought lispy was waying "ghc will use lenses internally"
19:04:44 <lispy> carter: it was a question
19:04:44 <carter> not "ORF is coming"
19:04:52 <edwardk> hence my efforts to diffuse your enthusiasm ;)
19:04:54 <lispy> edwardk mentioned lens and stage1
19:05:08 <carter> lispy: i think the rule of thumb is you need to be able to build GHC X with the previous two major versions
19:05:17 <carter> eg, 7.9 needs to build with 7.8 and 7.6
19:05:28 <carter> as will 7.10
19:05:37 <carter> 7.14 can have lenses internaly
19:05:44 <carter> afaik
19:05:54 <edwardk> unlikely =)
19:05:58 <carter> true
19:06:12 <carter> would not help with the "make ghc faster at compiling"
19:06:12 <edwardk> it has yet to embrace such radical notions as monad transformers internally ;)
19:06:19 <carter> edwardk: should it?
19:06:26 <EvanR> nooo
19:06:48 <startling> edwardk: haha
19:06:54 <edwardk> carter: when i look at 8 functions all taking the same 15 arguments i cry.
19:07:17 <lispy> edwardk: you weep ReaderT?
19:07:17 <carter> edwardk: ok
19:07:19 <carter> you win
19:07:30 <carter> edwardk: oh and GHC COMES with transformers right?
19:07:37 <edwardk> yes
19:07:42 <carter> ok
19:07:43 <carter> fuck
19:07:45 <carter> fine
19:07:45 <edwardk> i don't even care about it using the package
19:08:02 <edwardk> merely the idea of making a custom monad when you are going t do the same thing over and over
19:08:26 <carter> i may do that as my "getting back into the thick of things" patch
19:08:37 <carter> edwardk: if i do that, will you help with the code review?
19:08:41 <edwardk> there be dragons
19:08:49 <carter> hence why i need a wingman
19:08:56 <carter> to help fight em
19:09:06 <startling> wait wait
19:09:14 <carter> even if it passed validate, that'd still have to get ok'd to merge in
19:09:15 <startling> he's on the dragon's wings?
19:09:23 <edwardk> yeah, not sure i want to get caught in someone's jetwash ;)
19:09:33 <carter> :P
19:12:02 <Crowds> Is there another interpreter that is better than ghci?
19:12:11 <edwardk> Crowds: no
19:12:26 <Crowds> alright
19:12:35 <startling> cabal repl :)
19:12:37 <edwardk> Crowds: there are a couple of others you might use if you need a secured environment or a bot to run untrusted code, etc.
19:12:52 <edwardk> but ghci is the best repl for playing around in
19:14:01 <Crowds> okay, it's just that it's not very descriptive when it comes to errors like the python interpreter is
19:14:24 <carter> Crowds: you mean stack ttraces?
19:14:27 <startling> Crowds, could you give an example?
19:14:30 <carter> those are coming in ghc 7.10
19:14:39 <carter> startling: python gives stack traces
19:14:40 <startling> ghci is *very* descriptive about type errors.
19:14:47 <startling> carter, I know.
19:14:50 <carter> true
19:14:57 <startling> ghci is less good at syntax errors and code errors
19:15:01 <carter> yeah
19:15:18 <startling> but this is mostly because you shouldn't use partial functions. :)
19:15:31 <Crowds> >less good at syntax errors and code errors
19:15:35 <Crowds> that might be it
19:15:45 <rgrinberg> lispy: thanks
19:15:56 <startling> Crowds, Debug.Trace is sometimes useful, and has facilities for doing stacktraces
19:16:27 <Crowds> startling, I'll look into that now, thanks
19:17:40 <startling> My favorite haskell interpreter is #haskell.
19:17:46 <startling> It gives really good error messages.
19:18:55 <carter> startling: but its latency is terrible
19:21:38 <Crowds> startling: ok, then I guess I'll show you guys the code and explain why I'm doing this
19:21:50 <edwardk> @hpaste
19:21:50 <lambdabot> Haskell pastebin: http://lpaste.net/
19:22:01 <edwardk> ^- throw code there and ask questions about it with the link here
19:22:58 <Crowds> here:http://lpaste.net/103240
19:23:16 <Crowds> its purpose is to simulate the rolling of a dice
19:23:19 <Crowds> or dices
19:23:31 <Crowds> the input is in the form of "NdM"
19:23:47 <Crowds> where N is how many dices there are, and M is how many faces it has
19:24:11 <startling> cool.
19:24:30 <Tekmo> You need to `show` x
19:24:31 <geekosaur> ...
19:24:35 <geekosaur> "dices"
19:24:55 <Tekmo> Crowds: You want: putStr " " ++ show x
19:25:03 <startling> Crowds: what's the error you're seeing?
19:25:04 <Tekmo> Crowds: You also need to give `x` a type annotation
19:25:04 <Tekmo> i.e.
19:25:09 <Tekmo> Crowds: You want: putStr " " ++ show (x :: Int)
19:25:27 <Tekmo> Crowds: Oh, sorry, one last fix
19:25:30 <Tekmo> Crowds: You need parentheses
19:25:31 <Crowds> ohh, and geekosaur lol srry, english is not my first language
19:25:39 <Tekmo> Crowds: putStr (" " ++ show (x :: Int))
19:25:56 <Crowds> Tekmo, thanks for the feedback
19:26:02 <Tekmo> Crowds: You're welcome!
19:26:21 <Crowds> startling, I'll fix the code with Tekmo's suggestions and let you know
19:27:37 <jle`> howdy Tekmo
19:27:42 <Tekmo> jle`: Hi!
19:27:52 <shachaf> Crowds: Maybe startling is hinting that it's more polite to paste your full code along with your error, rather than hoping people will guess what's wrong or run the code themselves.
19:28:21 <startling> well, usually there's a couple errors
19:28:31 <startling> and it can be confusing to have someone correct one you haven't gotten to yet. :)
19:28:37 <shachaf> Yep.
19:28:41 <shachaf> It makes everybody's life better.
19:29:00 <lispy> Making the world a better place one #haskell question at a time.
19:30:33 <Crowds> startling, here's the error: Couldn't match expected type `IO b0' with actual type `[a0]'
19:30:42 <Crowds> line 8
19:31:15 <Tekmo> Crowds: If you add parentheses, it will fix the problem
19:31:21 <Tekmo> Crowds: I can explain the problem
19:31:23 <lispy> :t putStr " " ++ x
19:31:24 <lambdabot>     Couldn't match expected type ‚Äò[a]‚Äô with actual type ‚ÄòIO ()‚Äô
19:31:24 <lambdabot>     In the first argument of ‚Äò(++)‚Äô, namely ‚ÄòputStr " "‚Äô
19:31:24 <lambdabot>     In the expression: putStr " " ++ x
19:31:30 <lispy> seems familiar
19:31:32 <startling> Crowds, it's usually useful to give the whole error
19:31:41 <startling> Crowds: i.e., to paste it on lpaste along with your code
19:31:46 <Crowds> ok
19:31:51 <Tekmo> Crowds: What happened is that since you left out the parentheses, that line was parsed like this:
19:31:57 <startling> but yes, this sounds like the thing Tekmo corrected
19:32:00 <Tekmo> Crowds: (putStr " ") ++ xx
19:32:14 <Tekmo> Crowds: So `ghc` looks at that very superficially and sees the `(++)` and thinks:
19:32:18 <Tekmo> Crowds: "Hmmm, these must be lists"
19:32:46 <Tekmo> Crowds: So then it infers that since `mapM` is returning a list that you must be using the list monad
19:32:55 <Tekmo> Crowds: But then it notices that other statements use the `IO` monad
19:33:12 <Tekmo> Crowds: So it raises a type error, saying that you can't use both the list monad and `IO` monad in the same `do` block
19:33:43 <Tekmo> Crowds: When you add parentheses, then it you get
19:33:49 <Tekmo> Crowds: putStr (" " ++ x)
19:33:49 <shachaf> ?
19:33:55 <lispy> mapM?
19:33:57 <shachaf> I don't think the error has anything to do with monads.
19:34:02 <Tekmo> That's still a type error, but at least `ghc` can figure out that it is an `IO action
19:34:17 <Tekmo> Oh, whoops
19:34:19 <Tekmo> shachaf is right
19:34:21 <Tekmo> The error is more local
19:34:23 <shachaf> (x :: IO ()) ++ (y :: [Char]) is a type error for the reason you said.
19:34:56 <Tekmo> However, adding parentheses is not enough:
19:34:57 <Crowds> yup that was it
19:35:04 <Tekmo> putStr (" " ++ x) -- still a type error
19:35:07 <Crowds> now there's just an indentation error
19:35:34 <lispy> Crowds: don't use tabs
19:35:52 <Crowds> ok
19:35:58 <Tekmo> Crowds: Use 4 tabs.  It's the standard
19:36:01 <Tekmo> *4 spaces
19:36:10 <lispy> Crowds: http://urchin.earth.li/~ian/style/haskell.html
19:37:53 <EvanR> 4 spaces? uhg
19:38:16 <EvanR> everyone in the whole world should use 2 like me!
19:38:45 <Crowds> http://lpaste.net/103242
19:38:54 <Crowds> lispy, thanks, I'll read that
19:39:19 <Crowds> also, it's telling me there's an indentation error at line 9...but there is no line 9...
19:39:54 <Tekmo> Crowds: You can update the lpaste using the `Edit` button
19:40:15 <ion> It reached the line 9 looking for the closing )
19:41:28 <ion> You should avoid tail. In this case, drop 1 should be fine.
19:41:50 <EvanR> :t tail
19:41:51 <lambdabot> [a] -> [a]
19:41:57 <michaeltbaker> ion: Why is that?
19:41:59 <Crowds> ok, fixed that, also there's a mistake I made, I forgot to convert the string input into Ints
19:42:31 <ion> > tail []
19:42:32 <lambdabot>  *Exception: Prelude.tail: empty list
19:42:57 <lispy> > drop 1 []
19:42:58 <lambdabot>  []
19:43:25 <lispy> EvanR: I prefer 2 spaces as well
19:43:47 <EvanR> it simply does not crash, in general drop 1 [] not crashing may be a silent failure for a case you forgot
19:43:59 <ion> Also, you can use span or break instead of takeWhile and dropWhile.
19:45:04 <Crowds> ion, tried that, but the 'd' character still survived, which is something I don't need or want
19:45:35 <lispy> mapM_ (\x -> (putStr (" " ++ show(x::Int))) (take m (randomRs(1, n) g))
19:45:37 <lispy> oops
19:45:48 <ion>   Then use drop 1 or pattern matching to get rid of it.
19:47:40 <ion> (Or use a parser library)
19:47:46 <lispy> let prints = [ putStr (" " ++ show(x::Int)) | x <- randomRs (1, n) g ]); sequence_ (take m prints)
19:48:06 <lispy> That's untested
19:48:21 <michaeltbaker> EvanR: That's what I was thinking. drop vs tail seems very situational.
19:48:43 <lispy> I might write it that way to separate the generation of the printing actions from the act of taking only m of the actions
19:49:04 <lispy> (and then mapM_ becomes sequence_ because you've already plumbed the x's around)
19:49:42 <lispy> I also ended up with an extra paren at the end of the let line
19:49:45 <Crowds> lispy, interesting, thanks
19:50:37 <Crowds> I am having another error trying to 'read' the M number of "NdM"
19:50:42 <lispy> Actually, that's going to be a type error in this case.
19:50:49 <lispy> :t readMaybe
19:50:50 <lambdabot> Not in scope: ‚ÄòreadMaybe‚Äô
19:51:15 <lispy> That list comp is bogus because "x <- randomRs ..." is wrong
19:54:49 <Crowds> it works now!
19:54:55 <Crowds> thanks everyone =)
19:55:22 <jasonjckn> I don't understand this line of code: (+) <$> (+3) <*> (*100) $ 5 , I thought <$> accepts a function and a functor, and yet here it's being passed two functions.
19:55:26 <lispy> > break (=='d') "3d4"
19:55:27 <lambdabot>  ("3","d4")
19:55:54 <lispy> Crowds: I don't know how you fixed your problem, but the break function might be helpful for extracting the 'd'
19:56:21 <bergmark> @type ((+) <$>)
19:56:22 <lambdabot> (Num a, Functor f) => f a -> f (a -> a)
19:56:30 <bergmark> @type ((+) <$> (+3))
19:56:30 <lambdabot> Num a => a -> a -> a
19:56:48 <Crowds> lispy, here's the updated version http://lpaste.net/103242
19:58:28 <meretrix> My threaded application requires quite a bit of state. Is it generally preferable to pass around a bunch of TVars to functions as needed or use a monolithic monad with all TVars embedded?
19:58:33 <shachaf> jasonjckn: A value of type "F A" isn't a functor. F is the functor.
19:58:39 <shachaf> jasonjckn: (An important distinction.)
19:59:30 <shachaf> jasonjckn: So (<$>) :: (a -> b) -> F a -> F b, but both arguments -- the (a -> b) and the F a -- are functions.
20:00:31 <shachaf> As it turns out that can work fine depending on what F is.
20:01:00 <jasonjckn> hmh, ok, thanks, i'm thinking
20:01:55 <shachaf> A hint: Type-level operators -- including -> -- work like value-level operators.
20:02:08 <shachaf> So (a + b) means ((+) a b) which means (((+) a) b)
20:02:18 <shachaf> And (a -> b) means ((->) a b) which means (((->) a) b)
20:06:39 <jle`> your functor here is ((->) a).  or (a ->), if we are allowed to do sections.  so (+) is (a ->) (a -> a), (+3) is (a ->) a.  so with a little substitution magic, (+) is f (a -> a), and (+3) is f a
20:06:53 <jle`> where f is (a ->)
20:07:04 <jasonjckn> schlumpi: is type signature ((->) r) equivalent to r ?  if not how do I implement something that has typ ((->) r)
20:07:10 <jasonjckn> shachaf: *
20:07:22 <jle`> you can't have a value of type ((->) r)
20:07:24 <shachaf> Nothing can have type ((->) r)
20:07:28 <jle`> just like you can't have a value of type Maybe
20:07:29 <shachaf> Just like nothing can have type Maybe.
20:07:33 <jle`> oh
20:07:37 <jle`> heh
20:07:41 <shachaf> (However, Nothing can't have type Maybe.)
20:07:43 <jle`> i'll get out of your way
20:07:47 <shachaf> (OK, that was a confusing choice.)
20:07:54 <jasonjckn> thanks :)
20:07:59 <jle`> (the pun is appreciated nonetheless)
20:08:09 <shachaf> The point is that (x :: Maybe) doesn't make sense, only (x :: Maybe Int)
20:08:21 <jle`> this idea is formalized in the concept of kinds
20:09:36 <jle`> values can only have kind *.  Int is *.  Maybe is * -> * (it takes something of kind * and returns a new thing of kind *).  Maybe Int is kind *.  if that makes sense.  you apply the "type function" Maybe, to the type Int.
20:09:40 <jle`> :k Maybe
20:09:41 <lambdabot> * -> *
20:09:43 <jle`> :k Int
20:09:44 <lambdabot> *
20:09:46 <jle`> :k Maybe Int
20:09:46 <lambdabot> *
20:09:59 <jle`> so notice that all Functors have to be of kind (* -> *)
20:10:09 <jle`> :k (->)
20:10:10 <lambdabot> * -> * -> *
20:10:37 <jle`> (->) takes two *'s and returns a concerete *.  so you can have values of type (->) a b, but not of type (->) a
20:10:41 <jle`> :k (->) a b
20:10:41 <lambdabot> Not in scope: type variable ‚Äòa‚Äô
20:10:42 <lambdabot> Not in scope: type variable ‚Äòb‚Äô
20:10:45 <jle`> :k (->) Int Int
20:10:46 <lambdabot> *
20:10:49 <jle`> :k (->) Int
20:10:50 <lambdabot> * -> *
20:11:04 <jasonjckn> jle`: that makes sense
20:11:11 <jle`> also note that (->) can't be a functor, because functors are only * -> *
20:11:16 <jle`> and (->) is * -> * -> *
20:11:21 <jasonjckn> instance Functor ((->) r) -- Defined in `GHC.Base'
20:11:23 <jle`> but....(->) a can be a functor.
20:11:30 <jle`> because (->) r is * -> *
20:11:34 <jle`> magique
20:12:27 <lispy> As a reminder: There is more to being a functor than having the right kind.
20:12:53 <lispy> It's an important first requirement though.
20:13:06 <jle`> it's required to even have it typecheck, at least
20:13:11 <jle`> or...kindcheck
20:13:13 <jle`> hehe
20:24:56 <startling> jasonjckn: might be useful to note that there are a handful of higher-kinded generalizatons of Functor, too
20:38:35 <jasonjckn> So a type of kind * -> * -> * can never be an instance of Functor, however (+) is an instance of functor because of currying it can have kind * -> * OR * -> * -> * ?
20:39:34 <jasonjckn> i finally understanding why (+3) is a functor, but then also I can f `fmap` onto (+) ;-)
20:39:56 <shachaf> jasonjckn: (+3) is still not a functor.
20:40:04 <shachaf> (Int ->) is a functor.
20:40:24 <Aetherspawn> > (+3) `fmap` (+2) $ 1
20:40:26 <lambdabot>  6
20:40:30 <Aetherspawn> what the hell
20:40:31 <Aetherspawn> no way.
20:40:33 <startling> jasonjckn, you're confusing kinds and types
20:40:36 <startling> Aetherspawn: haha
20:40:52 <shachaf> You can call (+3) an "action" or something if you feel like it needs a name.
20:40:55 <startling> jasonjckn, (+)'s type is Num n => n -> n -> n
20:41:01 <startling> jasonjckn, (+) has no kind
20:41:01 <Aetherspawn> seriously, I had no idea
20:41:11 <startling> Aetherspawn, (->) r is a Functor
20:41:18 <shachaf> You may be confusing kinds and unkinds. I'm an unkind.
20:41:19 <Aetherspawn> where fmap = ap ?
20:41:26 <startling> Aetherspawn: no?
20:41:32 <copumpkin> fmap = (.)
20:41:38 <Aetherspawn> oh, that
20:41:44 <Aetherspawn> *that's what I meant sorry, forgot ap /= (.)
20:41:59 <startling> :t ap `asAppliedTo` (+ 3)
20:42:00 <lambdabot> Num (a -> b) => ((a -> b) -> a -> b) -> ((a -> b) -> a) -> (a -> b) -> b
20:42:13 <startling> :t ap `asAppliedTo` (+)
20:42:14 <lambdabot> Num a => (a -> a -> a) -> (a -> a) -> a -> a
20:42:44 <startling> jasonjckn, so, (+)'s type is Num n => n -> n -> n
20:43:22 <startling> jasonjckn, this type is "Num n => n -> (n -> n)", so it matches the "instance Functor ((->) r)"
20:43:31 <startling> (+ 3)'s type is Num n => n -> n
20:43:42 <startling> this also matches the instance Functor ((->) r).
20:43:47 <startling> jasonjckn: does that help?
20:44:15 <jasonjckn> Yah that helps
20:44:27 <jasonjckn> i think I kind of got the concept, but not the right words
20:44:38 <startling> it can be rough at first. good luck!
20:44:41 <jasonjckn> thanks!
20:44:55 <jasonjckn> (+) <$> (+3) <*> (+3) $ 5 is making sense to me now
20:45:10 <startling> ah, that's a fun thing
20:46:28 <EvanR> i was wondering about a "binary" <$> <*> combo thing earlier
20:46:57 <meretrix> @hoogle Monad m => m a -> (a -> m b) -> m a
20:46:58 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
20:46:58 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
20:46:58 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
20:47:06 <startling> EvanR, it's called "applicative style"
20:47:09 <EvanR> can you somehow do a (+3) <$>+<*> (+3) $ 5
20:47:15 <EvanR> obviously not correct
20:47:25 <startling> EvanR: It's not clear what you mean.
20:47:32 <startling> you could do something like
20:47:32 <EvanR> but can you arrange it so the operator is infix
20:47:56 <jasonjckn> > 3
20:47:57 <lambdabot>  3
20:47:58 <startling> :t let a <+> b = (+) <$> a <*> b in (+ 3) <+> (+ 2)
20:47:59 <lambdabot> Num a => a -> a
20:48:11 <EvanR> yeah i have that
20:48:22 <jasonjckn> > (+) <$> (+1) <*> (+1) $ 100
20:48:24 <lambdabot>  202
20:48:59 <EvanR> f <:> x = (:) <$> f <*> x
20:49:00 <jasonjckn> > (+) <$> (+0) <*> (+0) $ 100
20:49:02 <lambdabot>  200
20:49:03 <startling> :t (<**>)
20:49:04 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
20:49:25 <vermeille> wut
20:49:59 <startling> > (+ 3) <**> (+) <$> (+ 3)
20:50:00 <lambdabot>  <Integer -> Integer>
20:50:04 <EvanR> ah
20:50:04 <startling> :t (+ 3) <**> (+) <$> (+ 3)
20:50:05 <lambdabot> Num a => a -> a
20:50:08 <startling> EvanR: ^
20:50:08 <EvanR> thats what i was thinking of
20:50:11 <vermeille> :t (+) <$> (+1)
20:50:12 <lambdabot> Num a => a -> a -> a
20:50:35 <EvanR> in the nice weirdo ordering humans came up
20:50:45 <vermeille> wtf
20:50:59 <jle`> oh <**>, neat
20:51:07 <jle`> EvanR: you can also look into banana brackets
20:51:13 <EvanR> banana brackets
20:51:18 <startling> yeah, I've never used it before. Someone mentioned it here before and I just thought of it. :)
20:51:18 <jle`> to solve more or less this exact problem
20:51:28 <triliyn> [| (+3) + (+5) |]
20:51:31 <EvanR> rofl
20:51:42 <triliyn> They are also known as idiom brackets
20:51:56 <EvanR> reminds me of {x + y} notation for lisp
20:51:59 <jle`> oh sorry
20:52:01 <jle`> idiom brackets
20:52:06 <lispy> I thought banana brackets and idiom brackets were different
20:52:09 <jle`> yeah
20:52:13 <jle`> sorry
20:52:18 <lispy> banana brackets == catamorphisms, IIRC
20:52:21 <wingrime> can I define two functions with same name and different type?
20:52:28 <jle`> wingrime: in different modules :)
20:52:34 <EvanR> wingrime: or use a type class
20:52:35 <jle`> and in different scope in general
20:53:06 <lispy> or if you use a record
20:53:45 <lispy> (define the function in the record and then when you make values of that record you can put whatever functions in there. Use some type parameters to change the type)
20:53:55 * ski . o O ( "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire" by Erik Meijer,Maarten Fokkinga,Ross Paterson in 1991 at <http://wwwhome.cs.utwente.nl/~fokkinga/mmf91m.p(s|df)> )
20:54:03 <wingrime> I want operator that works between  Num and my type , in both directions
20:54:13 <ski> EvanR : which lisp ?
20:54:16 <wingrime> a\\b and b\\a
20:54:17 <shachaf> lispy: By that sort of logic you can say id :: Int -> Int and also id :: Char -> Char
20:54:49 <lispy> shachaf: sure
20:55:15 <jle`> wingrime: yeah that's not going to work without typeclass magic
20:55:18 <lispy> shachaf: pick a side of the lambda cube :)
20:55:24 <jle`> or type directed name resolution
20:55:32 <EvanR> ski: i found it here http://readable.sourceforge.net/
20:55:47 <EvanR> i dont know how popular this is, or even at all implemented by anything
20:56:18 <startling> I think that's different.
20:58:52 <ski> EvanR : oh, another "let's skip brackets for sexps syntax"
20:59:11 <EvanR> yeah
20:59:42 <EvanR> i found discussions on this entertaining
21:00:34 <EvanR> ideas like {a + b * c} either doesnt work or has undefined precedence, just use more brackets
21:00:58 <EvanR> not that i would want to implement what haskell has
21:01:22 <ski> reminds me of "SRFI 49: Indentation-sensitive syntax" by Egil M√∂ller in 2003 at <http://srfi.schemers.org/srfi-49/srfi-49.html>
21:01:22 <AshyIsMe> is there a way to name a whole record value in pattern matching instead of having to name each field i want?
21:01:25 <AshyIsMe> http://en.wikibooks.org/wiki/Haskell/Pattern_matching#Introduction_to_records
21:01:34 <AshyIsMe> h Baz2 {bazName=name} = length name
21:02:05 <nisstyre> EvanR: I have implemented a parser that handles both prefix and infix nicely, i.e. you can define your own operators, and it will let you do (* 3 4 (a+b*c)) etc..
21:02:05 <AshyIsMe> something like:  h Baz2 b{} = length (bazName b)
21:02:05 <startling> AshyIsMe, h (Baz2 name) = length name
21:02:26 <startling> AshyIsMe: or h b = length (bazName b)
21:02:37 <nisstyre> precedence and associativity is well defined
21:02:43 <EvanR> nisstyre: yeesh
21:03:10 <EvanR> AshyIsMe: you can name the patterns as a whole
21:03:38 <AshyIsMe> startling: so if i have a Baz3 that i want to have another definition of h for, how does it find which one i mean in which definition of h?
21:03:39 <EvanR> h b@(Baz2 ...) =
21:03:53 <startling> AshyIsMe: ah
21:04:04 <AshyIsMe> EvanR: ah that looks like what im after
21:04:19 <startling> AshyIsMe: you can do Baz{}, yeah
21:04:20 <EvanR> record sum types are weird
21:04:51 <startling> :t \x j@(Just{}) = j
21:04:51 <lambdabot> parse error on input ‚Äò=‚Äô
21:04:55 <startling> :t \x j@(Just{}) -> j
21:04:56 <lambdabot> t -> Maybe t1 -> Maybe t1
21:05:10 <startling> :t \x j@Just{} -> j -- I wonder if you can drop the parens
21:05:11 <lambdabot> t -> Maybe t1 -> Maybe t1
21:05:14 <startling> yep!
21:05:16 <EvanR> didnt know about that
21:05:23 <jle`> neat
21:05:37 <EvanR> though ive never used sum type records
21:06:12 <AshyIsMe> cool, cheers guys (and/or girls)
21:06:34 <jle`> who is Ashy
21:10:25 * AshyIsMe .
21:25:57 <chrisw_> What kind of data structure or workflow would be good for the intermediate representation of code (like SSA) in a compiler? The IR will go through a type checker (and add type information) and a register allocator (to add register information to each statement). I'm currently thinking about have 3 sets of datatypes (SSA with no types and no registers, SSA with types but no registers, and SSA with both), but that seems highly repeti
21:26:59 <chrisw_> An alternative is to have one set of datatypes and the extra information for types and registers would be Maybes in the SSA statements.
21:27:51 <shachaf> You can have a data type parameterized on the type of extra information.
21:33:26 <chrisw_> Ah yes that's another alternative, thanks. Do you see any glaring disadvantages to using any of these alternatives? I think that putting the extra information in Maybes is bad because it forces pattern matches all over the place and doesn't represent the fact that registers won't be allocated until after types are set, unless it was something like (Maybe (Type, Maybe Register)).
21:34:02 <chrisw_>  However, even using nested Maybes wouldn't convey the fact that having types is an all-or-nothing characteristic of set of all statements in a program. A parameterized datatype would solve that.
21:35:38 <shachaf> It's nice when your type represents exactly what you have rather than having to do runtime checks.
21:35:47 <shachaf> It's also nice not to duplicate code too much.
21:38:57 <chrisw_> Good points, I'll try the parameterized types.
21:58:46 <samrat> if I have a list of type [Maybe Int] is there any way to filter out the Nothing's ?
22:00:00 <shachaf> @hoogle [Maybe Int] -> [Int]
22:00:00 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
22:00:00 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
22:00:00 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
22:01:04 <EvanR> @hoogle [F a] -> F [a]
22:01:05 <lambdabot> Warning: Unknown type F
22:01:05 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
22:01:05 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
22:01:44 <EvanR> @hoogle Applicative F => [F a] -> F [a]
22:01:45 <lambdabot> Did you mean: [F a] -> F [a]
22:01:45 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
22:01:45 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
22:03:22 <samrat> shachaf: cool. I didn't know you could search on hoogle with the type signature
22:03:42 <samrat> shachaf: also catMaybes was what I wanted.
22:03:57 <shachaf> Yep.
22:04:01 <shachaf> @src catMaybes
22:04:01 <lambdabot> catMaybes ls = [x | Just x <- ls]
22:04:29 <EvanR> monad fail
22:04:46 <samrat> shachaf: is there any way to view the source and docs offline? instead of having to do a search on hoogle
22:04:51 <shachaf> It's a list comprehension.
22:05:02 <shachaf> samrat: You can run Hoogle yourself.
22:05:51 <EvanR> list comp ignores pattern failures?
22:07:21 <samrat> shachaf: cool. thanks
22:16:58 <kjnsdkjb> hi
22:19:28 <kjnsdkjb> > (5*) <$> [1..10]
22:19:30 <lambdabot>  [5,10,15,20,25,30,35,40,45,50]
22:23:11 <kjnsdkjb> anyone know the name of the haskell like language that shows the graph reduction?
22:26:35 <Yoctogon> Question: how does one implement and use a state monad that properly garbage collects old states during a simple (non-branching) iterating computation?
22:27:21 <shachaf> I think the question is a bit vague to answer as it is.
22:27:30 <shachaf> Do you have some code that's causing you a problem?
22:32:56 <Yoctogon> shachaf: for example, i have a state monad implemented here: http://lpaste.net/103250   and a list as state that is modified each iteration and fed into the next iteration, but isn't really "used" anymore
22:33:16 <Yoctogon> here i have an infinite loop, and what i'm trying to obtain is memory use not increasing without bound
22:33:24 <jle`> EvanR: well you can think of it as a pattern match fail triggering the fail function, and fail for list is []
22:33:30 <Yoctogon> this is purely for my own educational purposes, by the way
22:33:31 <jle`> or const []
22:33:38 <EvanR> thats what i thought
22:33:48 <shachaf> I doubt it has anything to do with State.
22:34:01 <Yoctogon> what do you think it is, then?
22:34:09 <Yoctogon> because i'm at a loss at this point
22:34:10 <jle`> Yoctogon: values not used are garbage collected anyways
22:34:11 <jle`> but
22:34:15 <jle`> whta are you trying to do with that code?
22:34:17 <jle`> what do you expect it to do?
22:34:30 <Yoctogon> use a constant amount of memory
22:34:35 <jle`> to do what?
22:34:40 <Yoctogon> but this code just eats up more and more memory
22:34:41 <shachaf> You're not evaluating your list, just making bigger and bigger thunks l, map (+1) l, map (+1) (map (+1) l), ...
22:34:57 <shachaf> Try writing it without State and you'll probably see the same behavior.
22:35:24 <Yoctogon> how do i fix it?
22:35:29 <jle`> do you expect your code to terminate?
22:35:32 <jle`> because you are doing stuff forever ...
22:35:33 <Yoctogon> no
22:35:36 <jle`> oh
22:35:42 <jle`> you are checking memory usage
22:35:53 <Yoctogon> all i want (at this point) is for it to not eat up memory
22:35:58 <shachaf> No what?
22:36:05 <EvanR> print out the intermediate values or something
22:36:14 <EvanR> debug.trace
22:36:14 <Yoctogon> well
22:36:33 <jle`> i...don't even think that that code will actaully evaluate anything
22:36:38 <jle`> so wouldn't that be 0 memory usage?
22:36:38 <shachaf> Start by simplifying.
22:36:50 <shachaf> Use a simple state like an Int instead of a list.
22:36:56 <Yoctogon> okay
22:36:59 <Yoctogon> good point
22:37:11 <shachaf> See if getting rid of State gets rid of the issue (it probably won't, so you can stop worrying about State).
22:37:20 <EvanR> use a simple state like a lazy int ;)
22:37:46 <shachaf> Then try to force the value on each iteration or something.
22:38:01 <shachaf> You'll want to read about how laziness works if you're not generally familiar with how to do that.
22:39:55 <EvanR> how do you check memory usage ?
22:40:02 <Yoctogon> that's weird.. using an Int as state makes it complete immediately..
22:40:23 <Yoctogon> i'm using a task manager, essentially
22:41:40 <Yoctogon> ah
22:41:56 <Yoctogon> i have print s as the last line, so that the result is "used"
22:42:04 <Yoctogon> int uses memory without bound as well
22:43:33 <Yoctogon> shachaf: i've used all sorts of combinations of bang patterns and seq's, with no luck
22:43:56 <Yoctogon> also, compiling with -O2, etc
22:49:58 <shachaf> Maybe Control.Monad.State.Strict would help.
22:50:21 <Yoctogon> well
22:50:41 <Yoctogon> i want to implement it myself, for educational purposes
22:50:54 <Yoctogon> i could very well use that, and it'd probably work, but that's not the point right now
22:51:00 <EvanR> maybe youre holding onto the original state
22:51:16 <EvanR> original state action
22:51:22 <Yoctogon> well, that's what i'm assuming is happening, but i'm not sure how to "discard" it
22:51:47 <EvanR> is it a top level definition
22:51:57 <Yoctogon> what is?
22:51:59 <shachaf> Oh, right, you're implementing your own State.
22:52:17 <shachaf> Well, think carefully and simplify until you see what's wrong.
22:52:27 <shachaf> Or simplify until you can't simplify anymore and then post the code. :-)
22:52:33 <Yoctogon> there's not much to simplify
22:52:42 <Yoctogon> since there's really no functionality or use in this code
22:52:46 <EvanR> nevermind what i said
22:53:17 <Yoctogon> the only way i could simplify, really, is to just use the built-in state monads
22:53:30 <EvanR> you can read the source for State on hackage
22:53:47 <Yoctogon> on the other hand,
22:53:52 <shachaf> You can try to reproduce the problem without State. :-)
22:53:57 <jle`> @djinn a -> (s -> (a, s))
22:53:57 <lambdabot> f a b = (a, b)
22:53:57 <shachaf> You said it still happens with Int?
22:54:07 <Yoctogon> i ought to try using their strict state monad and see if i /can/ achieve what i want with it
22:54:10 <Yoctogon> yes
22:54:32 <jle`> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
22:54:32 <lambdabot> f a b c =
22:54:32 <lambdabot>     case a c of
22:54:32 <lambdabot>     (d, e) -> b d e
22:54:49 <jle`> why do we even need humans
22:55:04 <EvanR> to name stuff ;)
22:55:28 <jle`> @djinn (s -> (a, s)) -> (s -> (b, s)) -> (s -> (b, s))
22:55:28 <lambdabot> f a b c =
22:55:28 <lambdabot>     case b c of
22:55:28 <lambdabot>     (d, _) -> case a c of
22:55:28 <lambdabot>               (_, e) -> (d, e)
22:55:35 <EvanR> a function i would really appreciate a computer to be able to do
22:55:35 * shachaf mumbles something about how lambdabot accepts /msg
22:55:52 <Yoctogon> :p
22:56:08 * jle` pretends it is relevant because it relates to implementing state monad...but is only kidding himself
22:56:19 <shachaf> For best results use an indexed state monad.
22:56:19 <ReinH> EvanR: computers can name things just fine
22:56:46 <jle`> ah hah!  @djinn's implementation of  (>>) is wrong.
22:56:53 <jle`> humans triumph.
22:59:24 <bitemyapp> so there are things djinn can't do.
22:59:42 <corgifex> @djinn [a] -> Int
22:59:42 <lambdabot> Error: Undefined type []
23:01:14 <jle`> i wonder if there would be any good in having ghc enforce parametricity in type signatures
23:01:26 <jle`> in that it won't let something like f :: a -> b typecheck
23:01:50 <jle`> but i guess every type is inhabited by bottom anyways
23:01:52 <Yoctogon> built in strict monad appears to use memory without bound as well, in this situation
23:01:54 <EvanR> yes
23:02:04 <Yoctogon> strict state monad*
23:04:46 <jle`> is there some dependent typing mechanism that would forbid functions f :: a -> b  in dependently typed languages?
23:06:26 <Yoctogon> any ideas?
23:06:50 <EvanR> you posted code?
23:07:04 <jle`> i...still don't even know why your code evaluates anything
23:07:09 <jle`> s/know/understand
23:07:14 <Yoctogon> it doesn't
23:07:20 <Yoctogon> it sits there as an infinite loop
23:07:25 <Yoctogon> er
23:07:26 <Yoctogon> i mean
23:07:30 <Yoctogon> it does evaluate things
23:07:30 <jle`> why is it even infinitely looping
23:07:33 <Yoctogon> just never.. finishes
23:07:35 <jle`> you never use s
23:07:40 <jle`> hm.
23:07:51 <jle`> does the pattern match force it?
23:07:51 <Yoctogon> i have it infinitely looping to see if it uses memory endlessly
23:07:53 <Yoctogon> and it does
23:08:04 <Yoctogon> i have print s so that it doesn't optimize everything away
23:08:14 <jle`> it's not about optimization
23:08:18 <jle`> it's about laziness
23:08:24 <Yoctogon> eh?
23:08:25 <jle`> all you do is define 'how to compute s'
23:08:31 <jle`> and if your program just returns ()
23:08:49 <jle`> it wouldn't ever need to compute s
23:09:04 <Yoctogon> i don't follow
23:09:32 <jle`> let (_, s) = ... doesn't actually evaluate/execute anything
23:09:38 <Yoctogon> i know
23:09:50 <jle`> it's just how to compute s if you need it
23:09:52 <Yoctogon> i have that and the print thing there so that it will bother to try running it (forever)
23:10:07 <Yoctogon> otherwise it completes instantly by noticing it doesn't have to do anything with the result
23:10:19 <jle`> just a technicality
23:10:25 <jle`> of vocabulary, i guess.
23:10:33 <jle`> it's the same as if you had another top level definition
23:10:38 <jle`> sumall = sum [1..]
23:10:46 <jle`> somewhere in your file, and you never use it
23:11:01 <Yoctogon> anyway, that isn't the point
23:11:05 <Yoctogon> the point is the memory use
23:11:07 <EvanR> Yoctogon: i read the code
23:11:11 <EvanR> from your post
23:11:33 <Yoctogon> i also did a trace of intermediate states, they are indeed updating as expected, and memory still grows
23:11:38 <EvanR> if you put a print s at the end, then youll cause an infinite loop which eats up unlimited memory in an attempt to evaluate s
23:11:51 <Yoctogon> i know
23:11:54 <EvanR> so dont do that
23:12:02 <jle`> EvanR: yeah, but you should still be able to run the computation in constant space
23:12:05 <Yoctogon> that's not the point...
23:12:05 <jle`> even if it never terminates
23:12:23 <Yoctogon> i'm trying to see if its possible for it to discard intermediate states
23:12:33 <Yoctogon> and not have memory grow, if that's possible
23:12:33 <EvanR> jle`: i dont know about that..
23:12:53 <jle`> by should, i mean hopefully ;)
23:12:53 <Yoctogon> i only have it running infinitely as a test, it could very well be just a very long loop
23:13:09 <jle`> foldl' (+) 0 [1..] never terminates, but it should use constant space
23:13:14 <EvanR> right, and that would be like the foldl vs foldl' thing
23:13:27 <no-n> How would I write a Makefile so that output goes to a given directory? (when I type ghc --make whatever)
23:13:37 <EvanR> foldl' uses seq or some magic to work without causing a huge thunk
23:13:52 <Yoctogon> so anyway: how do i achieve stateful computation with proper garbage collection)?
23:14:08 <Yoctogon> (without using built in stuff, i want to understand how its done)
23:14:27 <jle`> does seq count as built in stuff?
23:14:34 <corgifex> no-n: ghc --make doesn't use makefiles
23:14:44 <Yoctogon> i mean
23:14:48 <Yoctogon> built in monads, etc
23:14:55 <EvanR> you usually dont bother
23:14:55 <Yoctogon> also note: not trying to achieve mutability, i'm fine with overhead of duplication
23:15:06 <no-n> how do I use a makefile?
23:16:04 <jle`> one problem might be that forcing s doesn't force its contents
23:16:13 <jle`> it only forces (_:_) vs []
23:16:18 <Yoctogon> hmm
23:16:21 <jle`> you might try using deepseq
23:16:29 <Yoctogon> oh, didn't realize that was a thing
23:16:29 <jle`> which is generally discouraged in normal code
23:16:33 <jle`> i'm not sure though
23:16:40 <jle`> have you tried just using seq normally?
23:16:43 <Yoctogon> yes.
23:16:46 <Yoctogon> in many combinations
23:16:57 <jle`> let s' = s + 1; s' `seq` putState ...
23:17:03 <Yoctogon> yes.
23:17:28 <EvanR> you need a real program to optimize
23:17:39 <Yoctogon> why?
23:18:01 <jle`> wait, does using Int make the space usage better?
23:18:16 <Yoctogon> this isn't even about optimization, this is about actually being able to implement an algorithm without using up gigs of memory fast
23:18:33 <EvanR> i dont know about the strategy of using deepseq and stuff in typical "State" code
23:18:51 <EvanR> implement the algorithm first, then check if it still happens
23:19:23 <Yoctogon> i *know* it will happen..
23:19:28 <EvanR> whatever
23:19:34 <Yoctogon> because it will basically doing code like this..
23:19:37 <shachaf> Hopefully don't use deepSeq. :-(
23:19:44 <Yoctogon> lots of intermediate states, of large arrays
23:19:50 <shachaf> Using deepSeq is often a sign that you're doing something wrong.
23:19:58 <Yoctogon> well, deepseq is an entire package apparently, i don't think i want to use it
23:20:41 <shachaf> What's your latest code? I can have a look.
23:20:48 <Yoctogon> holy crap
23:20:48 <jle`> does using Int make the space usage constant?
23:20:55 <Yoctogon> no
23:21:00 <Yoctogon> i think i got it working
23:21:13 <shachaf> Even better.
23:21:39 <Yoctogon> shachaf: i was using seq wrong, apparently
23:21:49 <Yoctogon> i tried the s' = s+1, etc thing you suggested
23:21:51 <Yoctogon> works
23:22:03 <jle`> oh neat
23:22:14 <Yoctogon> which then, why is this wrong:
23:22:24 <Yoctogon> s `seq` putState (s+1)
23:22:46 <jle`> you are deferring the evaluation of (s+1)
23:22:46 <Yoctogon> as opposed to let s' = s+1; s' `seq` putState s'
23:22:47 <shachaf> Hmm, can you @paste the version that wasn't working?
23:23:03 <jle`> which is the cause of the problem in the first place
23:23:14 <Yoctogon> welp
23:23:46 <Yoctogon> alright, good, just a lapse in understanding then, and i know what i have to look at carefully
23:23:58 <Yoctogon> and now i*
23:24:03 <EvanR> Yoctogon: since you had s `seq` ... s+1, you are causing another thunk involving old s to be created
23:25:17 <shachaf> I'm not sure the current #haskell consensus reflects a correct understanding of the situation either.
23:25:32 <jle`> hm
23:25:34 <jle`> don't listen to me
23:25:37 <jle`> i don't know anyhting :|
23:25:52 <jle`> for tight loops i usually just throw my hands up and use ST
23:25:58 <shachaf> @src ($!)
23:25:59 <lambdabot> f $! x = x `seq` f x
23:27:00 <Yoctogon> huh..
23:27:19 <EvanR> i cant explain it
23:27:36 <EvanR> but code would be good
23:27:38 <no-n> dammit
23:27:42 <jle`> putState $! s + 1 --?
23:27:52 <Yoctogon> okay does this work: (s' `seq` putState (s+1)) but not (s' `seq` putState s')
23:27:58 <Yoctogon> why does*
23:28:15 <Yoctogon> even though s' = s+1
23:28:23 <shachaf> Are you sure it's not the other way?
23:28:29 <Yoctogon> yes.
23:28:31 <Yoctogon> just tested it
23:28:31 <EvanR> thats two different s+1
23:28:32 <shachaf> It sounds like something is being confusing here, at any rate.
23:28:38 <Yoctogon> first uses constant memory, the other doesn't
23:28:48 <shachaf> I won't comment further without seeing code.
23:29:16 <Yoctogon> shachaf: http://lpaste.net/103254
23:29:33 <Yoctogon> that code works, and if (s+1) is replaced with s', it doesn't work
23:30:43 <EvanR> seems like you are successfully evaluating the s+1, but also avoiding it by writing s+1 again, avoiding the point of seq
23:31:30 <shachaf> And how are you compiling it? -O2?
23:32:27 <Yoctogon> yes
23:32:41 <shachaf> When I run your file I get <<loop>>
23:33:09 <Yoctogon> i'm just doing ghc -O2 <file>, etc
23:33:16 <shachaf> GHC version?
23:33:21 <Yoctogon> uhh
23:33:24 <shachaf> The type of s isn't even Int, by the way.
23:33:25 <shachaf> It's Integer.
23:33:31 <shachaf> Please write type signatures. :-)
23:33:32 <Yoctogon> 7.6.3
23:34:06 <Yoctogon> well, doesn't matter which it is anyway, i guess
23:34:20 <jle`> this is so weird, everything is weird, i don't know anything anymore
23:34:28 <Yoctogon> i do write type signatures usually, except for hacky prototypy code
23:34:31 <Yoctogon> lol.
23:35:09 <EvanR> you cant rely on common expression elimination
23:35:11 <shachaf> Showing your code to others means that they'll have to read it, which is much easier with types. :-)
23:35:21 <EvanR> two s+1 in the code are two different computations
23:35:38 <shachaf> Anyway, you have a <<loop>>
23:36:04 <jle`> EvanR: the thing is, the way with s' and s+1 works in constnat space, but the s' and s' is not.
23:36:51 <EvanR> jle`: ... i thought it was the other way around
23:36:56 <EvanR> rereading the log
23:37:53 <shachaf> Let me see.
23:38:52 <shachaf> OK, I think GHC is just being too smart.
23:40:05 <Yoctogon> shachaf: how do thing work?
23:40:19 <shachaf> Oh, GHC 7.8 is smarter than 7.6. OK.
23:42:21 <shachaf> 7.8 optimizes the whole forever $ do { s <- getState; putState (s+1) } away into something like x = x
23:42:40 <corgifex> nice
23:43:07 <shachaf> So probably 7.6 is doing something else not quite as clever but still unexpected.
23:43:51 <Yoctogon> shit
23:43:59 <EvanR> thats crazy
23:44:14 <Yoctogon> i used replicateM <big number>
23:44:17 <Yoctogon> instead of forever
23:44:21 <Yoctogon> now it uses memory again
23:44:36 <Yoctogon> instead of constant
23:45:12 <Yoctogon> i.e. http://lpaste.net/103255
23:45:13 <EvanR> try replicateM_
23:45:35 <Yoctogon> well
23:45:44 <shachaf> Yes, replicateM_ instead of replicateM, otherwise it wastes memory making a big list of ()s.
23:45:53 <Yoctogon> i get a stack overflow with _
23:47:07 <Yoctogon> actually
23:47:12 <Yoctogon> i get a stack overflow for either
23:47:12 <shachaf> A stack overflow sounds like a reasonable thing.
23:47:23 <Yoctogon> hm
23:47:36 <Yoctogon> well then.. how do i work around a stack overflow?
23:47:39 <EvanR> need to test the real algorithm
23:47:52 <shachaf> Now is maybe the time to experiment with strictness.
23:48:13 <shachaf> Try something like let foo :: Int -> (); foo 0 = (); foo n = foo (n-1) in foo bigNumber
23:48:15 <Yoctogon> wasn't `seq` doing that?
23:48:18 <shachaf> I imagine it'll have the same problem.
23:48:31 <shachaf> It probably was, but I have no idea what your code looks like now.
23:48:49 <Yoctogon> i posted it earlier
23:49:02 <shachaf> But you changed it since. :-) And you had multiple different versions.
23:49:10 <Yoctogon> i actually havent
23:49:12 <shachaf> You might want to turn your let (x,y) = ... into a case ... of (x,y), or use let !(x,y) = ... in your implementation of instance Monad (State s), by the way.
23:49:16 <Yoctogon> http://lpaste.net/103255
23:49:38 <Yoctogon> right
23:49:39 <Yoctogon> hm
23:49:54 <shachaf> Or not. Who knows. It's an adventure.
23:49:59 <Yoctogon> actually
23:50:01 <Yoctogon> that makes sense
23:50:49 <klugez> Yoctogon: And putState the forced s' instead of a lazy s+1.
23:51:09 <EvanR> btw i tried your foo bigNumber shachaf and it is simply taking forever, not using memory
23:51:26 <shachaf> Right, GHC is probably being smart about it.
23:51:58 <Yoctogon> well
23:52:50 <shachaf> Try something like, I don't know, {-# NOINLINE foo #-}; foo :: (Int -> Int) -> Int -> (); foo _ 0 = (); foo f n = foo f (f n) with a strict function.
23:52:59 <shachaf> Something like that.
23:53:37 <gansteed> Is there some good vim scripts for Haskell syntax highlight ? haskell.vim can't display for type class
23:54:42 <shachaf> What does it mean to display for type class?
23:56:32 <gansteed>  If I input Ord, it will not highlight for it.
23:56:50 <corgifex> what does it mean to highlight for it?
23:58:43 <fizruk> I guess he wants to highlight class names in constraints, or just common class names
23:58:54 <Yoctogon> holy crap
23:59:03 <Yoctogon> shachaf: got it working i think
23:59:45 <Yoctogon> http://lpaste.net/103256
