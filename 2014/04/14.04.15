00:01:24 * hackagebot purescript 0.4.18.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.18.1 (PhilFreeman)
00:07:48 <exicer> Is there a way to use sequence with data.vector?
00:12:03 <johnw> can't you use sequenceA?
00:12:30 * hackagebot monad-unify 0.2.2 - Generic first-order unification  http://hackage.haskell.org/package/monad-unify-0.2.2 (PhilFreeman)
00:12:30 * hackagebot purescript 0.4.18.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.18.1 (PhilFreeman)
00:13:43 <Nik05> ok ReinH last night i didnt make any sense
00:14:09 <Nik05> i said i didnt checked for flush all the time. But thats ofcourse correct because you cant have a flush and a pair, etc...
00:22:26 * hackagebot sizes 2.3.1.1 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.3.1.1 (JohnWiegley)
00:24:19 <neumond> function :: (TypeClass a, TypeClass b) => a -> b -> c
00:24:27 <neumond> how can I cut down this line?
00:26:18 <neumond> something like TypeClass a, b
00:26:45 <pavonia> Maybe there's a way to use constraint synonyms here
00:28:55 <startling> neumond: why?
00:29:02 <they> Oh boy. I'm nested 3 cases. Will that hurt performance a lot?
00:29:12 <startling> they: why would it?
00:29:30 <they> I heard that cases were the most performance-inhibiting thing in Haskell.
00:30:22 <neumond> startling: you mean there is no way to do that?
00:30:44 <startling> neumond: I just don't understand why you want it.
00:30:47 <startling> I don't think there is.
00:30:52 <startling> they: you may have misunderstood.
00:31:06 <startling> they, cases in Haskell are hard to optimize because of laziness.
00:31:18 <they> Ah. That is what I read.
00:31:25 <startling> that doesn't mean they're the most performance-inhibiting thing in Haskell.
00:31:37 <they> But I assumed that a lack of optimization == negative performance implications.
00:32:02 <neumond> startling: laconic syntax is a good thing, isn't it?
00:32:36 <startling> they, it just means that cases in haskell can't be optimized the same way they can be optimized in strict languages. I doubt it would be a problem in most programs.
00:33:09 <startling> neumond, I guess so.
00:33:47 <startling> I wonder if GHC is smart enough to do case magic on constructors with strict fields.
00:34:02 <pavonia> neumond: "type Both a b = (TypeClass a, TypeClass b); func :: Both a b => a -> b -> c" should work
00:34:27 <pavonia> with a recent GHC, that is
00:34:54 <startling> Isn't there an extension you need?
00:34:59 <pavonia> I'm wondering if even "type Both cls a b = (cls a, cls b)" works
00:35:31 <pavonia> I guess so
00:35:44 <startling> I think it would work with ConstraintKinds.
00:35:52 <startling> I don't know if it would work without it.
00:36:18 <startling> (Otherwise, what's the kind of Both?)
00:36:47 <startling> I think you'd need to annotate it, too, otherwise you'd get a tuple.
00:36:55 <pavonia> yeah
00:37:47 <startling> (i.e., it'd be (* -> *) -> * -> * -> * rather than (* -> Constraint) -> * -> * -> Constraint
00:37:50 <startling> )
00:38:17 <pavonia> Wouldn't it be possible to use it in both context?
00:38:26 <startling> maybe with PolyKinds
00:38:27 <pavonia> +s
00:38:49 <startling> I've never used PolyKinds with ConstraintKinds, so I dunno.
00:42:21 <killy9999> bergmark: thanks
00:45:28 <bitemyapp> startling: I'd be more curious about how much performance could be won from an optimization of case.
00:45:52 <startling> bitemyapp: well, it's tricky in Haskell, because laziness
00:46:34 <bitemyapp> startling: does case just wrap it in a thunk?
00:46:51 <startling> bitemyapp, I don't know what you mean
00:47:07 <startling> bitemyapp, checking if a value matches a case has to evaluate it a bit.
00:47:23 <startling> so reordering cases is not, in general, a valid optimization
00:47:29 * hackagebot uulib 0.9.16 - Haskell Utrecht Tools Library  http://hackage.haskell.org/package/uulib-0.9.16 (JeroenBransen)
00:47:32 <bitemyapp> my point is the case evaluation happens when the whole value is unwrapped, not when the case evaluation might otherwise be conventionally understood to occur.
00:47:39 <bitemyapp> or rather, my conjecture.
00:48:18 <startling> Sure. case expressions are lazy, like most other haskell expressions.
00:48:29 <bitemyapp> yeah. well. Can't do much there :)
00:59:52 <pharaun> man i feel like i'm doing something naughty -_- (playing with data.dynamic)
01:03:22 <Saizan> pharaun: it is
01:07:35 <zq> is there any difference between (Functor f, Monad f) => f () and Monad f => f ()?
01:07:46 <zq> oh wait, functors are strictly supersets of monads yet
01:07:51 <zq> faq
01:08:11 <Aetherspawn> uhh
01:08:23 <Aetherspawn> bitemyapp: and others who wanted to know the significance of church encoding in gabriels blogpost
01:08:30 <Aetherspawn> "Sorry, I forgot to answer this.  So the answer is that Church encoding encodes a data type non-recursively, and `ghc` is very good at optimizing non-recursive code.  This is a much more deep and interesting topic than that quick summary indicates, but I'm writing up a post on this subject that will hopefully illuminate this more."
01:08:35 <Aetherspawn> -- Tekmo
01:08:42 <MP2E> Nice
01:08:58 <MP2E> That blog post had me interested as well
01:09:13 <Aetherspawn> yeah when I asked it on the channel a few weeks ago
01:09:20 <Aetherspawn> people were like "that's the 8th time that's been asked this hour!"
01:09:24 <MP2E> rofl
01:13:42 <Nik05> hey guys back to the forall stuff. ghc gives me warning again, so i think lets just copy that function signature and paste it. But now ghc doesnt like the '.' in forall syntax
01:14:54 <bergmark> Nik05: the forall is implicit for top level declarations, but you can keep it if you enable RankNTypes
01:16:24 <Nik05> hm ok
01:37:35 * hackagebot halberd 0.1.2.5 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1.2.5 (ErikHesselink)
01:40:07 <Nik05> can i use lambdabot in private message?
01:40:40 <merijn> Nik05: Yes
01:42:01 <Nik05> thanks merijn, ah also need to use @ in private messages
01:51:48 <Nik05> does sort keep ordering?
01:51:59 <merijn> What does that mean?
01:52:20 <lieven_> whether it is stable probably
01:52:42 <Nik05> sorry how do i say this.
01:52:49 <Nik05> let me check what stable sort is
01:53:02 <bergmark> it sounds like a bad idea to assume that
01:53:39 <lieven_> some languages have both sort and stablesort in their standard library
01:54:20 <Nik05> yes i think i mean stable sort, thank you lieven_ and merijn :)
01:54:25 <bergmark> oh the docs says it is stable
01:54:51 <bergmark> then it's fine to assume it is ;)
01:57:36 <merijn> Does anyone have cliff's notes for the difference between EitherT and ErrorT
01:57:39 <merijn> ?
01:57:55 <Nik05> hm i dont get this i have some pointless function when i do :type [function body] in ghci it tells me its a Ord a => [a] -> [[a]]
01:58:11 <startling> Nik05: what's confusing about that?
01:58:20 <Nik05> but when i assign that function body to foo, and i do :type foo it says [()] -> [[()]]
01:58:29 <merijn> Nik05: Ah, you're working in ghci?
01:58:42 <merijn> Nik05: Sounds like you hit the Dreaded Monomorphism Restriction
01:58:44 <merijn> @where dmr
01:58:45 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
01:58:47 <merijn> Nik05: Read that
01:58:48 <startling> merijn, ErrorT's MonadError instance requires Error on the error type
01:58:59 <startling> (for no reason)
01:59:00 * startling error error error error error
01:59:11 <pharaun> this is what i feel like right now over the fact that i'm using Data.Dynamic -> http://this-plt-life.tumblr.com/post/44462204757/simon-peyton-jones-adding-the-io-monad-to-haskell
01:59:11 <merijn> startling: The either docs claims there are more differences, but doesn't specify what
01:59:21 <Nik05> noooo, merijn i talked about Monomorphism yesterday :P
01:59:26 <pharaun> I just feel like there has to be a better way to do it but i don't see it >_<
01:59:34 <startling> merijn: what docs?
01:59:42 <merijn> startling: "Either is a perfectly usable Monad without such a constraint. ErrorT is not the generalization of the current Either monad, it is something else."
01:59:57 <merijn> So clearly there is a difference between EitherT and ErrorT, but I'm unsure what
02:00:03 <startling> merijn, that's what I said.
02:00:06 <Nik05> whats the problem with Monomorphism with this? sortBy (flip (comparing length)) . group . sortBy (flip compare)
02:01:05 <bergmark> ErrorT introduced an Error constraint
02:01:52 <startling> merijn: I'm pretty sure that's all there is, and I'm not sure how you're reading that to suggest there's more to it.
02:02:07 <Nik05> huh :S when i put in into a file and compile it with ghc, it works fine
02:02:34 <bergmark> found this gem in our codebase that explains it
02:02:38 * hackagebot testing-feat 0.4.0.2 - Functional Enumeration of Algebraic Types  http://hackage.haskell.org/package/testing-feat-0.4.0.2 (JonasDuregard)
02:02:39 <bergmark> instance Error MailChimpError where noMsg = error "Fuck you, error class."
02:03:01 <quchen_> git blame && git send-nukes
02:03:24 <merijn> startling: ok, then I should probably just use ErrorT as I avoid on transformer already anyway
02:05:22 <MP2E> ahah
02:05:44 * MP2E aliases git send-nukes as git push --force
02:08:09 <merijn> hmm, is there a more efficient way to move arrays between haskell and C then serialising to/from list, because that seems a bit expensive
02:08:31 <Earnestly> bytestrings? :I
02:09:03 <MP2E> ^
02:09:26 <merijn> How do ByteStrings help?
02:09:58 <startling> merijn: it depends on what you want to do with the arrays I guess
02:10:56 <merijn> startling: Dump primitive types (CInt, Int32, Word8, that sort of thing) in/out and read them
02:10:56 <MP2E> They are very fast. Also strict by default, which is nice for speedy IO.
02:12:29 <MP2E> if you're dealing with text, maybe http://hackage.haskell.org/package/text instead?
02:13:08 <merijn> MP2E: I'm not sure why any of that is relevant for moving data through the FFI?
02:13:17 <MP2E> Oh FFI whoop.
02:13:18 <tdammers> merijn: you said "serialize"
02:13:42 <startling> merijn, isn't that just peek and advanceArray ?
02:13:47 <startling> or the ST equivalents
02:14:11 <merijn> tdammers: Well, how else would you call "pokeArray :: Storable a => Ptr a -> [a] -> IO ()"
02:15:36 <tdammers> idk... "serialize" usually implies converting to a string or byte array representation
02:16:01 <tdammers> not sure if that's what you're doing
02:17:40 * hackagebot cookbook 2.3.2.0 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.3.2.0 (NatePisarski)
02:17:46 <merijn> tdammers: I need to pass significantly long arrays between C and Haskell (like millions of values), so creating a new list everytime seems rather expensive. Although may I should just only interact with as a Ptr and just not have a haskell representation
02:18:17 <tdammers> lists are lazy
02:18:51 <tdammers> as long as you traverse them linearly, I don't really see a problem, at least not on the haskell side
02:19:12 <tdammers> or are we talking millions of lists here?
02:23:18 <quicksilver> the most efficient thing is just use the Ptr directly
02:23:38 <quicksilver> if you want a haskell-side copy, then copy the Ptr into a Vector or something like that.
02:26:13 <merijn> quicksilver: Yeah, that's what I figured, I just wasn't sure if there were primitives for directly marshalling to/from Vector
02:27:10 <remdez> Hello! How can I make do-while loop in haskell? I found http://hackage.haskell.org/package/loop-while but it seems to be outdated: has dependency old mtl (>=1.0 && <1.2) and wasn't updated since 2010
02:27:36 <Yaniel> don't?
02:27:41 * hackagebot rest-gen 0.9.0.7 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.9.0.7 (ErikHesselink)
02:27:43 * hackagebot rest-core 0.28.0.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.28.0.1 (ErikHesselink)
02:27:44 <merijn> remdez: That seems like a silly package...
02:27:49 <quicksilver> merijn: sounds a bit like you're suffering from premature optimisation. Stop worrying, start *doing*, and optimise later where required ;)
02:28:30 <merijn> quicksilver: Need to do something while I'm compiling :p
02:29:33 <quicksilver> merijn: since you asked, though, http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector-Storable.html
02:30:13 <remdez> merijn: I agree. I'm sure I found some reasonable function some time ago but don't remember now
02:30:28 <merijn> @hackage monad-loops
02:30:29 <lambdabot> http://hackage.haskell.org/package/monad-loops
02:30:34 <merijn> remdez: Take a look at monad-loops?
02:32:20 <simon> can I run a ReadP-style parser within a monad without using readP_to_S?
02:32:51 <remdez> merijn: thanks!
02:33:00 <simon> within the IO monad, that is.
02:37:43 * hackagebot uri-encode 1.5.0.2 - Unicode aware uri-encoding.  http://hackage.haskell.org/package/uri-encode-1.5.0.2 (ErikHesselink)
02:58:31 <samnardoni> Why does `mconcat (repeat LT)` terminate while `mconcat (repeat Eq)` doesn't?
02:59:05 <samnardoni> I understand it logically... but how does "Haskell" know it doesn't need to run forever?
02:59:16 <erisco> :t mconcat
02:59:18 <lambdabot> Monoid a => [a] -> a
02:59:44 <erisco> > LT <> EQ <> GT <> LT
02:59:46 <lambdabot>  LT
02:59:51 <quchen_> mconcat (repeat EQ) = mconcat (EQ : repeat EQ) = EQ <> mconcat (repeat EQ) = mconcat (repeat EQ) -- samnardoni
02:59:53 <erisco> guess that was not a good test
03:00:00 <quchen_> So your equation reduces to itself.
03:00:26 <quchen_> On the other hand,
03:00:26 <quchen_> mconcat (repeat LT) = mconcat (LT : repeat LT) = LT <> mconcat (repeat LT) = LT
03:01:04 <erisco> > mempty :: Ordering
03:01:05 <lambdabot>  EQ
03:01:34 <samnardoni> Is it just because EQ is the mempty then?
03:01:50 <jakex_> samnardoni for the same reason why if (true || foo()) wouldn't evaluate foo in other languages.. lazy evaluation
03:02:13 <erisco> no it is because  LT <> x = x  for Ordering Monoid it seems
03:02:16 <erisco> sorry
03:02:20 <erisco> LT <> x = LT
03:02:43 <quchen_> It's because LT is mempty, and mappend is non-strict in its second argument (for the Ordering instance).
03:03:07 <quchen_> > LT <> undefined
03:03:09 <lambdabot>  LT
03:04:03 <samnardoni> From the definitions...  LT `mappend` x = LT ... EQ `mappend` x = x
03:04:30 <samnardoni> What's different with the Eq defintion?
03:04:44 <samnardoni> apart from obviously that it returns x instead of LT
03:04:57 <quchen_> Nothing.
03:05:13 <erisco> Eq is a type class. EQ is a value of Ordering... do you mean the latter?
03:05:31 <samnardoni> Yes, sorry, EQ
03:05:35 <erisco> just making sure :)
03:05:44 <samnardoni> So it's just via lazy evaluation that this works?
03:06:29 <tdammers> lazy evaluation makes it terminate, yes
03:07:25 <tdammers> specifically, in order to evaluate a <> b, a is evaluated first, and if a pattern matches unconditionally based on a alone, b doesn't need to be evaluated, and thus it won't
03:07:26 <erisco> samnardoni, it is not much different than  take 5 [1..]  for example
03:08:18 <erisco> samnardoni, eventually the function hits a case where it does not need to know what the rest of the list is, and so it will not be evaluated thanks to lazy evaluation
03:09:02 <samnardoni> But if I do... LT `mappend` x = GT ... GT `mappend` x = LT ...
03:09:10 <samnardoni> (I know this breaks the monoid laws)
03:09:17 <samnardoni> it still terminates...
03:09:33 <samnardoni> Shouldn't it be flipping between LT and GT indefinitely?
03:09:52 <quchen_> mconcat (repeat LT') = mconcat (LT' : repeat LT') = LT' <> mconcat (repeat LT') = GT'
03:10:02 <mietek> Does anyone knows who owns the heroku-buildpack-haskell AWS S3 bucket?
03:11:02 <erisco> as quchen_ is doing you can simply substitute terms to understand how it will evaluate samnardoni
03:11:19 <erisco> thank referential transparency for that :)
03:11:25 <samnardoni> I *think* I understand it... a bit at least...
03:11:29 <samnardoni> thanks for the help guys :)
03:12:17 <quchen> Just uase pen and paper to work things like this out. It'll teach you not only why certain things work, but how Haskell evaluates things in general.
03:13:59 <samnardoni> quchen: I have a hard enough time working it out with ghci in front of me... I think a pen and paper would not help!
03:18:27 <samnardoni> So... I think I've got an intuition about Monoids -- combing 2 things of one type into 1 thing of the same type... Is there a one-line intuition for Monads?
03:18:39 <samnardoni> *combining
03:19:05 <vanila> monoid is associative
03:19:20 <samnardoni> (comb does sounds like a cool function name though -- the opposite of zip?)
03:20:06 <dagle> Not even types can save the code I wrote during high feaver.
03:37:25 <SplinterOfChaos> I'm trying to write a REPL using the GHC modules, but I can't figure out how to evaluate "let" statements. Anyone know what function or module I should look into? Can't find too much online about this.
03:40:56 <merijn> samnardoni: Maybe not one line, but what may help is to take a look at a different monad operator
03:41:20 <merijn> samnardoni: So usually people define Monad as "return" and ">>=", because that's what's in the typeclass (because those are usually easy to define)
03:41:58 <merijn> samnardoni: But one could also define an identical Monad typeclass using "return :: a -> m a" and "(>=>) :: (a -> m b) -> (b -> m c) -> a -> m c"
03:42:53 <merijn> samnardoni: Note the conceptual similarity between (>=>) and (.) (in fact, >=> *is* (.) in the Kleisli category)
03:43:19 <prophile> modulo argument order
03:43:45 <merijn> prophile: No, category composition has the same order as >=> I think
03:43:53 <merijn> :t (Control.Category..)
03:43:55 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
03:43:59 <merijn> ah
03:44:02 <merijn> No, you're right
03:44:02 <prophile> hence >>>
03:44:04 <prophile> :)
03:44:13 <prophile> I think there's a <=< in Control.Monad though
03:44:23 <merijn> Yes,
03:44:44 <vanila> he was talking about monoid though
03:45:06 <merijn> vanila: His last question was "Is there a one-line intuition for Monads"
03:45:13 <vanila> ah
03:45:34 <prophile> "They're just monoids in a category of endofunctors, what's the problem?"
03:46:13 <vanila> that is not true
03:46:20 <merijn> samnardoni: Alternatively, one can define Monad as "fmap :: (a -> b) -> m a -> m b", "return :: a -> m a" and "join :: m (m a) -> m a"
03:46:30 <jtcwang> Hey guys, I just tried cabal install Conduit, but it seems like a few packages such as Data.Conduit.Binary is missing
03:46:44 <jtcwang> http://lpaste.net/102711
03:47:11 <jtcwang> did I miss something important here?
03:47:16 <merijn> jtcwang: You reinstalled with --force?
03:47:27 <prophile> jtcwang: I don't know conduit well, but hackage only lists those four modules
03:47:30 <jtcwang> nope just --reinstall
03:47:39 <merijn> jtcwang: Yeah, that's almost always wrong
03:47:52 <samnardoni> merijn: Thanks for the explanation. I think I see the similarities a bit more...
03:48:01 <merijn> jtcwang: You overwrote the existing conduit installation with the one for 1.0.1 which no longer has a Binary module
03:48:09 <jtcwang> merijn, on first install there were only 4 packages, hence reinstall
03:48:21 <merijn> jtcwang: Which will probably have broken anything dependent on conduit
03:48:53 <prophile> merijn: I think he reinstalled the same version thinking the first install went wrong
03:48:56 <prophile> jtcwang: http://hackage.haskell.org/package/conduit
03:49:11 <merijn> Data.Conduit.Binary last appeared in 1.0.17 it no longer exists in 1.1.0
03:49:27 <merijn> You should read the docs to see what happened to it
03:49:30 <jtcwang> merijn, i'll keep that in mind, but currently i only have like 2 packages installed so it should be ok
03:49:31 <jtcwang> https://hackage.haskell.org/package/conduit-0.5.0/docs/Data-Conduit.html
03:49:40 <jtcwang> yeah will do
03:49:46 <merijn> jtcwang: That's docs for 0.5.0
03:49:51 <merijn> That's ancient :)
03:50:05 <jtcwang> haha i did a cabal list conduit
03:50:10 <notdan> > Refactoring into conduit and conduit-extra packages. Core functionality is now in conduit, whereas most common helper modules (including Text, Binary, Zlib, etc) are in conduit-extra. To upgrade to this version, there should only be import list and conduit file changes necessary.
03:50:11 <lambdabot>  <hint>:1:80: parse error on input ‘in’
03:50:21 <notdan> try installing conduit-extra
03:50:23 <merijn> jtcwang: If you go to the Contents link in the top right you should have links to docs for all versions
03:50:32 <jtcwang> filesystem-conduit is by Michael, but deprecated..
03:50:44 <notdan> jtcwang: try https://hackage.haskell.org/package/conduit-extra
03:50:49 <notdan> it got filesystem and binary modules
03:51:07 <jtcwang> notdan, lovely, thx for that
03:51:23 <jtcwang> i must've missed it while browsing through cabal list
03:51:26 <notdan> btw i got that from https://hackage.haskell.org/package/conduit-1.1.0.1/changelog
03:52:09 <jtcwang> yeap i'll try harder next time :P
03:53:33 <jtcwang> ty too merijn
03:59:05 <Flonk> Things get so weird when you redefine half of Prelude. http://lpaste.net/102712
04:01:45 <Maior> so, having non-total functions in base - am I alone in disliking this?
04:01:59 <Cale> Flonk: I think that's just the monomorphism restriction
04:02:18 <vanila> Maior, fix is good
04:02:21 <Cale> Flonk: combined with GHCi's rather aggressive defaulting
04:02:46 <Maior> vanila: ok, but digitToInt? head?
04:03:09 <vanila> hm they're kind of useful for scripting
04:03:35 <Maior> I may mean something more specific than base
04:03:37 <Flonk> Cale: Oh, I should consider turning that off, then
04:04:35 <Cale> Maior: head is useful for various idioms like  map head . group . sort
04:05:12 <Maior> :t map head . group . sort
04:05:13 <lambdabot> Ord b => [b] -> [b]
04:05:32 <Maior> :t group
04:05:33 <lambdabot> Eq a => [a] -> [[a]]
04:05:46 <vanila> so there is a condition on the output of group, that makes use of map head total?
04:06:01 <vanila> i.e. every element has length at least one
04:06:19 <Maior> hm
04:06:30 <Maior> I think group lets me rewrite my function much nicer
04:06:53 <Maior> (https://github.com/doismellburning/hess/blob/master/src/Hess/Core.hs#L162-L172)
04:11:30 <Flonk> Cale: I'm not sure I understand what's going on, but writing the function definition inside the .hs-file seems to have worked
04:31:56 <srhb> Flonk: you can always :set -XNoMonomorphismRestriction
04:32:04 <srhb> Flonk: That's the default in the new ghci anyway
04:35:44 <merijn> ugh, if I have a haskell ADT that maps to a primitive foreign type is there no convenient way to marshal between them? Right now I just keep doing "toEnum . fromIntegral" everywhere :\
04:36:29 <fizruk> :t toEnum . fromIntegral
04:36:30 <lambdabot> (Integral a, Enum c) => a -> c
04:36:43 <fizruk> :t toEnum
04:36:44 <lambdabot> Enum a => Int -> a
04:40:59 <Rehty77> He keeps crashing :D
04:49:04 <noname> hi
04:49:15 <noname> I'm new in haskell
04:49:20 <Nik05> hello
04:49:51 <noname> I've done several programming (toy) to learn and catch up with the language
04:50:31 <noname> I want to know that can haskell language itself being embedded to another language ?
04:50:37 <noname> for an example C++ ?
04:50:55 <erisco> what do you mean by embedded?
04:51:08 <noname> like having a script engine
04:51:11 <noname> in C++
04:51:29 <erisco> um, are you saying you want a Haskell interpreter?
04:51:37 <noname> yeah (sorry)
04:51:58 <noname> is there anybody know about how to do this ?
04:52:04 <merijn> Hmm, does haddock support PatternSynonyms for 7.8?
04:52:25 <noname> because I think it's good to have for an example AI system embedded using haskell
04:52:29 <noname> (dunno)
04:52:37 <noname> for game engine maybe
04:53:07 <hc> noname: i like the idea :)
04:54:07 <noname> is there anybody in here know how at least to embed simple function
04:54:20 <noname> like a hello world ?
04:54:33 <haasn> merijn: yes
04:54:42 <haasn> At least in theory
04:54:48 <noname> I even dunno that ABI interface for C are compatible
04:55:45 <erisco> I have not heard of a haskell interpreter other than Hugs... probably not any help
04:55:55 <nh2> noname: I think you are talking about 2 different things: Exporting a function written in Haskell with a C api (very easy, "foreign export") and embedding a full Haskell typechecker+interpreter+... (compiler stack) into some other program
04:56:15 <erisco> you could compile Haskell with ghc and then do ffi
04:56:34 <tdammers> or you could cheat
04:56:42 <noname> nh2 : yes probably
04:56:49 <tdammers> run a haskell interpreter in a separate process
04:56:57 <tdammers> and implement some sort of IPC
04:57:18 <merijn> haasn: I don't suppose there's a convenient way to group multiple patterns to look like a single datatype? :\
04:57:19 <erisco> for little game scripts? sounds intensive
04:57:32 <haasn> merijn: I don't suppose there is
04:57:53 <haasn> merijn: I wonder if you could actually export a datatype, but only when HADDOCK (or whatever) is defined, using CPP
04:57:57 <noname> ok I'll try for an IPC
04:58:11 <haasn> (and export pattern synonyms to actual non-Haddock users of the library)
04:58:18 <noname> haasn: any examples ?
04:58:33 <nh2> noname: I think that in theory it would be very possible to just link in ghc's library and using FFI exports to expose a full haskell interpreter
04:58:57 <noname> I try to list functions from very simple static lib of haskell lib
04:59:04 <klrr_> haskell has become quite popular on HN lately :)
04:59:05 <noname> and it so damn many #hahaha
04:59:28 <noname> objdump (lib) -t | wc -l
04:59:40 <nh2> however, take into account that an embedded Haskell interpreter based on GHC's library is not the size of e.g. an embedded Lua interpreter; I think you can count in 20-50 MB for that
04:59:47 <merijn> haasn: That doesn't really help, though?
04:59:59 <haasn> merijn: I'm not sure why not
04:59:59 <noname> nh2 : you're right
05:00:23 <haasn> merijn: that way haddock would, if my theory is correct, generate docs as if it were an actual single datatype
05:00:33 <nh2> noname: I don't think that should be a reason to stop you though :)
05:00:37 <merijn> haasn: Oh, that's what you meant
05:00:46 <merijn> haasn: That'd be a humnongous pain, though
05:00:59 <merijn> haasn: I'd need to specify the entire datatype twice!
05:01:08 <noname> hopefully :)
05:01:14 <haasn> merijn: oh, it's that big?
05:01:16 <nh2> noname: as an example for the latter, http://hackage.haskell.org/package/hint-0.4.1.0/docs/Language-Haskell-Interpreter.html#g:8 - hint uses the GHC API and gives you functions that take a string and compile (and run) it as a Haskell function
05:01:29 <merijn> haasn: I have approximately 700 lines of constructors, atm
05:01:40 <haasn> And you're exporting 700 pattern synonyms? :P
05:01:54 <merijn> haasn: Well, if I can get pattern synonyms to work, then yes.
05:02:01 <haasn> That is a big datatype.
05:02:03 <merijn> Although that'd let me delete all the datatypes
05:02:09 <merijn> haasn: It's multiple datatypes
05:02:16 <haasn> Oh, I see
05:02:21 <merijn> I guess the biggest is about 60 constructors
05:03:03 * hackagebot fay-builder 0.1.0.5 - Compile Fay code on cabal install, and ad-hoc recompile during development  http://hackage.haskell.org/package/fay-builder-0.1.0.5 (AdamBergmark)
05:03:23 <merijn> But I figure with PatternSynonyms I can pretend they're a single datatype while just directly mapping to a marshallable foreign type
05:04:07 <merijn> haasn: Basically, I have a C int with 60 defined error codes and mapping that to a single ADT with a constructor per error code, but that's really annoying to convert back and forth
05:04:32 <merijn> haasn: I figured I could just define a pattern synonym for a newtype wrapper around CInt and have them transparently converted :)
05:04:50 <noname> merijn: any gists ?
05:05:06 <merijn> That'd have 0 conversion overhead and would be more convenient to work with
05:05:19 <merijn> The downside is, I wouldn't be able to document them as a single datatype
05:05:24 <merijn> noname: Of what?
05:05:55 <noname> from what you've been doing there ?
05:06:06 <bernalex> can someone briefly hit me with a cluebat as to why you can do (+1) <$> [0..5], but not putChar <$> getLine? also, related, putChar =<< getChar, but not (+1) =<< [5].
05:06:30 <tdammers> bernalex: (+1) is pure, putChar isn't
05:06:56 <tdammers> also, compare the types of (>>=) and (<$>)
05:06:56 <haasn> merijn: that makes sense. Random idea: algebraic pattern synonym types, define an ADT structure on top of pattern synonyms that gives them coverage checking (and ADT-style documentation)! ;)
05:07:00 <bernalex> tdammers: doh.
05:07:07 <merijn> haasn: Right
05:07:18 <haasn> pattern data Foo where PatA = ...; PatB = ...
05:07:20 <merijn> haasn: That's exactly what I want
05:07:40 <tdammers> bernalex: did I hit hard enough, or do you need more clubbing? :D
05:08:03 <jmcarthur> Oh, great, I can see it now. Haskell developers everywhere using newtype wrappers around Ints in place of enumeration types to work around the GHC limitation of not being able to unpack enumeration types into fields of other data types, and calling it a somewhat solved problem because at least they can use pattern synonyms.
05:08:07 <bernalex> tdammers: no, it hit me. with full "duhhhh this is obvious you dunce" force it could.
05:08:08 <haasn> :t putChar <$> getChar
05:08:10 <lambdabot> IO (IO ())
05:08:13 <nh2> bernalex: see the core difference in the type signatures of <$> and >>=: <$> has a (a -> b) while >>= has a (a -> m b)
05:08:25 <haasn> (I'm assuming you meant getChar, not getLine)
05:08:34 <haasn> (If you actually meant getLine: String is not ~ Char)
05:08:47 <merijn> jmcarthur: I'm open to better solutions if you have any
05:08:50 <haasn> :t join $ putChar <$> getChar
05:08:51 <lambdabot> IO ()
05:08:52 <bernalex> haasn: I meant getLine.
05:09:01 <merijn> jmcarthur: Because at moment I'm having a real pain with that problem
05:09:01 <bernalex> haasn: as in mapping putChar on a [Char].
05:09:03 <jmcarthur> merijn: I think for FFI it makes slightly more sense, at least.
05:09:12 <haasn> :t map putChar <$> getLine
05:09:14 <lambdabot> IO [IO ()]
05:09:25 <bernalex> haasn: yes, I know.
05:09:27 <jmcarthur> merijn: It's just that you idea made me think of that.
05:09:28 <jmcarthur> *your
05:09:33 <nh2> bernalex: (a -> m b) fits your putChar :: Char -> IO (), while (a -> b) doesn't in the same way
05:09:37 <merijn> jmcarthur: I have no convenient way of marshalling back and forth :\
05:09:52 <jakex_> :t join $ map putChar <$> getLine
05:09:53 <lambdabot>     Couldn't match type ‘IO’ with ‘[]’
05:09:53 <lambdabot>     Expected type: [[Char]]
05:09:53 <lambdabot>       Actual type: IO String
05:09:58 <jmcarthur> newtypes around the C types aren't convenient already?
05:09:59 <merijn> jmcarthur: Except like I said explicitly doing "toEnum . fromIntegral" on every call and every result, which makes me sad
05:10:01 <bernalex> nh2: yes, the cluebat has hit me already.
05:10:11 <merijn> jmcarthur: Then you don't have constructors for use in the haskell code
05:10:22 <jmcarthur> you can use newtypes in the foreign declarations directly
05:10:27 <merijn> jmcarthur: I know
05:10:36 <merijn> jmcarthur: But how do you specify values of that type in your code?
05:10:38 <jmcarthur> and you can use smart constructors and pattern synonyms as you suggested for the interface
05:10:46 <jakex_> :t sequence $ map putChar <$> getLine
05:10:47 <lambdabot>     Couldn't match type ‘IO’ with ‘[]’
05:10:48 <lambdabot>     Expected type: [[Char]]
05:10:48 <lambdabot>       Actual type: IO String
05:10:51 <jmcarthur> like i said, i don't think it's terrible for FFI to do this
05:10:56 <merijn> jmcarthur: You lose coverage checking that way :\
05:11:05 <jmcarthur> ah
05:11:06 <jmcarthur> that's a shame
05:11:22 <jmcarthur> i guess you could always define a big combinator, but that sucks
05:11:24 <jakex_> :t sequence_ =<< map putChar <$> getLine
05:11:25 <lambdabot> IO ()
05:11:32 <jakex_> \o/
05:11:37 <merijn> Although you lose coverage checking with the pattern synonym approach to
05:11:45 <haasn> nh2: except it does, with b ~ m b
05:11:48 <haasn> m b'
05:11:49 <merijn> jmcarthur: What do you mean by "define a big combinator"?
05:12:12 <jakex_> of course you could just do mapM_ putChar =<< getLine
05:12:29 <Kinnison> win 59
05:12:37 <jmcarthur> merijn: a terrible thing:    foldMyEnumType :: a -> a -> a -> a -> a -> a -> MyEnumType -> a
05:13:00 <merijn> jmcarthur: I have no clue what that's supposed to do?
05:13:17 <jmcarthur> merijn: return whichever argument corresponds to the constructor in MyEnumType
05:13:27 <jmcarthur> merijn: the function would be constructed such that every case must be handled
05:13:32 <nh2> haasn: sure but not if you want the end result to be IO instead of nested IO
05:13:39 <grogger> is haskell suitable for building a GUI application quickly?
05:13:52 <jmcarthur> grogger: haskell is, but the existing libraries aren't
05:13:57 <merijn> jmcarthur: Read my earlier remark of some of my ADTs having 60+ constructors
05:14:05 <jmcarthur> merijn: I did say it was terrible.
05:14:12 <merijn> jmcarthur: I really, *really*, *REALLY* don't want to do that :\
05:15:10 <grogger> jmcarthur: haskell lacks good gui library bindings?
05:17:53 <bernalex> grogger: personally I've found elm more pleasant than gtk2haskell, wxhaskell and so on.
05:18:05 * hackagebot fay-builder 0.1.0.6 - Compile Fay code on cabal install, and ad-hoc recompile during development  http://hackage.haskell.org/package/fay-builder-0.1.0.6 (AdamBergmark)
05:18:05 <bernalex> grogger: threepenny-gui is supposedly quite good though.
05:18:42 <bernalex> grogger: the thing about elm is that it makes frp real easy, and you don't need one library for gtk bindings, then one for frp, then maybe one for arrowised frp, then ugh, then ugrhgrhrgh, then guhrugrurgurhhgr. which is what my experience with haskell gui programming has been.
05:18:58 <bernalex> jmcarthur knows a lot more than me though, so listen to him if he says different. ;-)
05:21:10 <exicer> Using cabal, if I create a library in the directory /Lib1, then create a new program at /Prog1, how can I use Lib1 in Prog1 ?
05:21:22 <merijn> haasn: Alternatively, it'd make sense to have a "class Marshallable a where type Marshalled a :: *; marshall :: a -> Marshalled a"
05:21:30 <merijn> exicer: At your library as a build-depends
05:21:34 <merijn> s/At/Add
05:22:16 <allsystemsarego> hi all, with GeneralizedNewtypeDeriving, how can I recover bind and return definitions for this: "newtype MyOwnType a = MkMyOwnType (Identity a) deriving (Monad)"
05:23:52 <exicer> merijn: How do I let cabal know where that library is?
05:24:06 <merijn> exicer: Shouldn't need to
05:24:17 <bergmark> allsystemsarego: "recover"?
05:24:41 <allsystemsarego> bergmark, find out what they are
05:24:42 <exicer> merijn: Ah, I'm also using cabal sandboxes..
05:25:56 <bergmark> allsystemsarego: exactly the same as for Identity, except for the types because of the (un)wrapping
05:26:14 <allsystemsarego> ok
05:27:06 <allsystemsarego> thanks
05:27:18 <nh2> exicer: you don't have to let cabal know where your library is; when referencing your own library in a cabal executable section, it will figure it out automatically
05:27:59 <b1nery> So I’ve just ported some code from C++ to Haskell, and it’s massively slower. Is there a straightforward way to profile the code and see why it’s taking so long?
05:28:38 <bergmark> b1nery: check the chapter in real world haskell
05:28:55 <b1nery> bergmark: ah ok, thanks
05:30:30 <merijn> Did anyone manage to install 7.8.2 on OSX?
05:31:05 <bitemyapp> merijn: moi
05:31:11 <merijn> bitemyapp: Which OSX?
05:31:14 <bitemyapp> merijn: uh, I think I cheated tho.
05:31:20 <bitemyapp> merijn: whatever the latest is.
05:31:23 <merijn> How?
05:31:29 <exicer> nh2: I seem to be doing something wrong then! I get "unknown package"
05:31:31 <merijn> (as in cheated how)
05:31:43 <bitemyapp> used a prebuilt binary build made by a friend :)
05:32:07 <merijn> I downloaded the prebuilt binary from haskell.org but configure won't work due to ghc-pwd crashing :\
05:33:16 <bergmark> merijn: yes, no problems
05:33:17 <merijn> And I seem to have chased everyone in #ghc away so I'm kinda stuck on wth I'm supposed to do to unbreak it
05:33:40 <dzelzs> hi everyone, I have encountered a problem in regex searching, I can paste code here, but it will consume some space
05:34:05 <bergmark> @where lpaste -- dzelzs
05:34:05 <lambdabot> http://lpaste.net/new/haskell
05:34:46 <dzelzs> thanks a lot
05:34:46 <dzelzs> http://lpaste.net/102719
05:34:50 <dzelzs> here it is
05:35:33 <dzelzs> http://lpaste.net/102720
05:35:53 <dzelzs> and this is output
05:36:25 <dzelzs> so I'm a little bit confused
05:37:17 <dzelzs> sorry for cumbersome code :)
05:37:23 <fizruk> dzelzs: looks strange
05:37:37 <dzelzs> yeah, I know, that is why I'm here
05:42:52 <nh2> exicer: can you lpaste your cabal file?
05:42:56 <fizruk> dzelzs: "а" =~ "0" :: Bool returns True
05:43:20 <dzelzs> fizruk: I already know that :)
05:43:22 <fizruk> dzelzs: I would consider this a bug, I guess you should report it
05:43:37 <dzelzs> fizruk: and 'е' is 5 or 7
05:43:46 <dzelzs> fizruk: I don't remember
05:43:56 <dzelzs> ну русская е, епта
05:44:01 <dzelzs> ты русский, ты воткнешь)
05:44:51 <dzelzs> fizruk: I mean Russian 'е'
05:45:26 <sepp2k> "а" in UTF-16 contains the byte 48, which is ASCII for "0".
05:46:56 <sepp2k> So presumably the regex engine internally works on bytes and doesn't handle Unicode properly.
05:47:10 <fizruk> dzelzs: I got that, anyway it's a bug and you should report it
05:47:18 <dzelzs> sepp2k: so this IS a bug I and should report
05:47:35 <quchen> dzelzs: "Note that the posix library works with single byte characters, and does not understand Unicode. If you need Unicode support you will have to use a different backend. "
05:47:40 <dzelzs> fizruk: I'm noob at the World of Haskell, where to report?
05:47:46 <quchen> Source: http://hackage.haskell.org/package/regex-posix-0.95.2/docs/Text-Regex-Posix.html
05:48:03 <dzelzs> quchen: lol, I'm fool
05:48:09 <dzelzs> quchen: thanks :)
05:48:29 <fizruk> quchen: ah, missed that too
05:48:44 <quchen> You could still tell the maintainer to provide a more prominent warning. Like in the package description.
05:50:01 <fizruk> dzelzs: package maintainer contacts should be available on package description page http://hackage.haskell.org/package/regex-posix
05:50:14 <dzelzs> quchen: well, one should read docs before using the library I suppose
05:50:43 <dzelzs> thanks anyway, I have to go now :)
05:50:50 <quchen> dzelzs: The obvious pitfalls should not be a sentence in the middle of … well, anything.
05:51:47 <quchen> You wouldn't find a tiny sentence "by the way, works only up to 255" as a small intermediate remark in a library working with Integer everywhere.
05:52:27 <dzelzs> quchen: )) you're right :) I'll write to the maintainer
05:54:59 <killy9999> does anyne have experience with ott ?
05:59:13 <samnardoni> Are there any alternatives to monad transformers? i.e., if I want to use multiple monads at the same time, is there any other way?
06:00:09 <MagneticDuck> um, how do I easily generate / make vim use a tags file for a cabalised project?
06:00:21 <Ywen> samnardoni: One way can be to run each monad in a separate thread
06:00:22 <MagneticDuck> I know ghc can do it, but I'm not sure exactly how, and not sure where I'm supposed to put it :x
06:00:28 <MagneticDuck> (again, using vim)
06:00:44 <fizruk> samnardoni: there are extensible effects http://hackage.haskell.org/package/extensible-effects
06:01:00 <Ywen> samnardoni: ...yes, or you have extensible-effects
06:03:06 <fizruk> samnardoni: if you only need applicatives, you can also just compose them (like in http://hackage.haskell.org/package/transformers/docs/Data-Functor-Compose.html)
06:03:11 <serutsubi> How come this definition doesn't work: let prod :: (Num a) => [a] -> a; prod [] = 1; prod [a] = foldr1 (*) [a]
06:03:22 <Ywen> fizruk: but do you have other to learn how to use it except than the paper by Oleg Kiselyov?
06:03:31 <samnardoni> Are extensible effects used much?
06:04:10 <bergmark> samnardoni: no, it's really new
06:04:46 <samnardoni> ah, cool
06:04:52 <serutsubi> Nvm, I saw the mistake. :)
06:05:06 <germanmushroom> I'm having some issues using the network module on windows, using it gives me about 15 resolve warnings followed by all of them giving undefined reference errors. I'm on windows 7 using the haskell platform 2013, tried grabbing the network package from both cygwin and msys. getting really desperate here.
06:05:11 <fizruk> Ywen: there are some examples in code
06:05:30 <fizruk> Ywen: https://github.com/RobotGymnast/extensible-effects
06:05:51 <Ywen> fizruk: Thank you for deciphering my awfully written question ;)
06:06:12 <fizruk> Ywen: np :)
06:06:14 <Ywen> fizruk: actually it redirects towards the paper
06:06:26 <fizruk> Ywen: I meant in *code*
06:07:09 <fizruk> Ywen: there seem to be not much though https://github.com/RobotGymnast/extensible-effects/blob/master/src/Control/Eff.hs
06:07:45 <Ywen> fizruk: apparently the doc contains examples, that should be a good start
06:17:23 <ocharles> Ywen: I've also blogged about extensible-effects
06:17:38 <ocharles> http://ocharles.org.uk/blog/posts/2013-12-04-24-days-of-hackage-extensible-effects.html
06:17:51 <BoR0> consider I have data Vector = Vector (Int, Int) deriving (Show). I want to make a monoid instance for +. that works fine. but how can I make two instances for both + and * ?
06:18:02 <Ywen> ocharles: Thanks, I remember reading it now! I forgot quickly...
06:18:58 <ocharles> BoR0: you use newtypes
06:19:08 <bennofs> BoR0: you need to use newtypes if you want a monoid instance for both (newtype ProductVector = ProductVector Vector, etc)
06:19:20 <BoR0> aha, I see. ok, thanks
06:23:13 * hackagebot th-instance-reification 0.1.2 - Fixed versions of instances reification functions  http://hackage.haskell.org/package/th-instance-reification-0.1.2 (NikitaVolkov)
06:40:33 <BoR0> is this how you would do it? http://lpaste.net/102726
06:42:50 <BoR0> and what is the main difference between data and newtype?
06:43:25 <fizruk> Bor0: newtype has the same runtime representation as the underlying type
06:43:44 <tdammers> data can do sum types (using |) and multi-element records
06:44:13 <BoR0> I see
06:44:33 <Ywen> ocharles: A question about Eff: you no longer 'stack' anything, but you still run the effects in some order. Can this order have an impact?
06:44:37 <bennofs> @let newtype Newtype = Newtype Int
06:44:39 <lambdabot>  Defined.
06:44:45 <bennofs> @let data Data = Data Int
06:44:46 <lambdabot>  .L.hs:144:34:
06:44:46 <lambdabot>      Ambiguous occurrence ‘Data’
06:44:46 <lambdabot>      It could refer to either ‘L.Data’, defined at .L.hs:153:1
06:44:46 <lambdabot>                            or ‘Data.Data.Data’, imported from ‘Data.Data’ at ...
06:44:54 <bennofs> @let data Dat = Dat Int
06:44:55 <ocharles> Ywen: I think so
06:44:56 <lambdabot>  Defined.
06:45:22 <tdammers> you'd use newtype for performance reasons, when it is possible to do so
06:45:36 <bennofs> > let f (Newtype _) = 3; g (Dat _) = 3; in (f undefined, g undefined) -- there is also a slight difference in semantics
06:45:38 <lambdabot>  (3,*Exception: Prelude.undefined
06:45:43 <tdammers> also, you can use GeneralizedNewtypeDeriving to pull existing instances into your new type
06:46:11 <tdammers> e.g., suppose you have data Foobar { ... } and instance ToJSON Foobar
06:46:23 <tdammers> then you can do newtype Baz = Baz Foobar deriving (ToJSON)
06:46:31 <tdammers> you can't do that with data Baz = Baz Foobar
06:47:18 <pranz> is there a "gets" function that has signature "Monad m => (s -> m a) -> StateT s m a" ?
06:47:25 <pranz> instead of the normal "Monad m => (s -> a) -> StateT s m a"
06:47:46 <bennofs> :t StateT
06:47:47 <lambdabot> (s -> m (a, s)) -> StateT s m a
06:47:51 <bennofs> almost :p
06:48:02 <pranz> huh
06:48:19 <tdammers> pranz: have you tried hoogle?
06:48:38 <tdammers> :hoogle Monad m => (s -> m a) -> StateT s m a
06:48:39 <pranz> tdammers: yeah, no results
06:48:42 <tdammers> hm
06:49:05 <pranz> I guess you could just do
06:49:10 <bennofs> :t (get >>=)
06:49:11 <merijn> pranz: If that exists I've missed it for ages
06:49:16 <lambdabot> MonadState a m => (a -> m b) -> m b
06:49:33 <bennofs> I've always wanted a shortcut for that too
06:49:54 <merijn> bennofs: No, not the same
06:50:08 <merijn> "lift . (get >>=)"
06:50:21 <bennofs> you mean (get >>=) . lift?
06:50:34 <bennofs> :t (get >>=) . lift
06:50:35 <lambdabot>     Kind incompatibility when matching types:
06:50:35 <lambdabot>       m1 :: * -> *
06:50:35 <lambdabot>       a0 :: *
06:50:40 <bennofs> :t (get >>=) . fmap lift
06:50:41 <lambdabot> (MonadState a (t m), MonadTrans t, Monad m) => (a -> m a1) -> t m a1
06:50:49 <pranz> ah
06:50:51 <pranz> nice
06:50:52 <pranz> thanks all
06:51:38 <neumond> @print 4
06:51:39 <lambdabot> Not enough privileges
06:51:46 <bennofs> @help print
06:51:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:52:06 <bennofs> what does @print auto-correct to? :P
06:52:33 <neumond> it doesn't allow actually evaluate expressions
06:52:46 <bennofs> > 4
06:52:48 <lambdabot>  4
06:52:54 <neumond> wow
06:53:01 <neumond> > lol 4
06:53:06 <lambdabot>  mueval-core: Time limit exceeded
06:53:07 <lambdabot>  mueval: ExitFailure 1
06:53:10 <neumond> haha
06:53:10 <pranz> what the hell
06:53:21 <dv-> :t lol
06:53:23 <pranz> got a ghc panic warning
06:53:23 <lambdabot> Num a => t -> a
06:53:33 <pranz> "the 'impossible' happened"
06:53:45 <neumond> > 4 / 0
06:53:46 <lambdabot>  Infinity
06:53:48 <rom1504> haskell seem nice, is it very different from ocaml ?
06:54:05 <int-e> rom1504: it's pure, and it has a saner syntax (says the Haskell programmer)
06:54:10 <jakex_> > 4 / 0 :: Int
06:54:11 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
06:54:12 <lambdabot>    arising from a use of ‘GHC.Real./’
06:54:20 <int-e> rom1504: no objects though, and no first class modules.
06:54:26 <tdammers> rom1504: kind of relative
06:54:48 <int-e> Haskell is also lazy, which I imagine takes some time getting used to.
06:54:54 <rom1504> yeah I mean, I shouldn't have too much problem learning it then (I already know ocaml)
06:54:56 <bennofs> pranz: yeah, unfortunately, GHC seems to panic a lot if you use lift in a chain of functions and it doesn't typecheck (another candidate for that is hoist)
06:55:06 <bennofs> :t hoist
06:55:07 <lambdabot> Not in scope: ‘hoist’
06:55:21 <bennofs> :t hoist
06:55:23 <lambdabot> (MFunctor t, Monad m) => (forall a. m a -> n a) -> t m b -> t n b
06:55:49 <bennofs> I get a panic from GHC nearly everytime I mess up using that function :|
06:55:54 <int-e> rom1504: most notablyh you shouldn't run into trouble with higher order functions, which is a major stumbling block coming from non-functional programming languages.
06:55:56 <merijn> rom1504: Well, some major differences that int-e skipped over are typeclasses, higher kinded types and (with extensions) type functions, etc.
06:56:27 <merijn> rom1504: But learning typeclasses and higher kinded types with a decent understanding of ocaml should be pretty trivial
06:56:31 <int-e> bennofs: not good. if that's ghc 7.8.2 then it's definitely worth a bug report.
06:56:39 <bennofs> int-e: was ghc 7.6.3
06:57:51 <merijn> rom1504: Also, (imo :p) haskell syntax is way prettier than ocaml
06:57:57 <int-e> rom1504, merijn: The type systems go in different directions from a common Hindley-Milner basis.
06:58:17 * hackagebot simple-reflect 0.3.2 - Simple reflection of expressions containing variables  http://hackage.haskell.org/package/simple-reflect-0.3.2 (TwanVanLaarhoven)
06:58:21 <int-e> @type 0
06:58:22 <lambdabot> Num a => a
06:58:30 <rom1504> ok thanks for the information
06:58:44 <int-e> that's probably one of the first "odd" types you'll encounter.
06:59:15 <int-e> (which says that 0 is polymorphic, it works for all numeric types)
06:59:30 <Maior> bennofs: did I just see you do `:t hoist` twice with different results and no interim change?
06:59:36 <rom1504> what is a "numeric type" ?
06:59:52 <int-e> rom1504: an instance of the Num typeclass... ;-)
06:59:53 <merijn> rom1504: Whatever users define it to be :)
06:59:56 <bennofs> Maior: I cheated an did /msg lambdabot @let import Control.Monad.Morph :)
07:00:03 <Maior> bennofs: ahhh
07:00:32 <rom1504> oh ok
07:01:05 <merijn> rom1504: Rather than having a monomorphic (+), haskell has "(+) :: Num a => a -> a -> a", which says that (+) works for any type 'a' that is an instance of the typeclass Num, there's a bunch of predefined ones (like Int, Integer, Double, etc.), but users can define their own instances for their own datatypes
07:01:25 <Denommus> any way to improve on this code? https://gist.github.com/Denommus/10691765
07:01:29 <int-e> rom1504: type  :i Num   in ghci to get an overview of the operations that that typeclass has. It covers basic operations on numbers.
07:01:33 <merijn> rom1504: Suppose you define "data Nat = Zero | Succ Nat" then you could define a Num instance and cause (+) to work on that datatype
07:02:41 <int-e> (Oh, ghci is a big boon. I wish ocaml had something comparable when it comes to querying information about identifiers.)
07:03:40 <bennofs> Denommus: I suggest you to install hlint, a haskell style checker. I posted it's output as a comment to that gist
07:03:40 <rom1504> so a typeclass is a bit like a module ?
07:04:05 <int-e> rom1504: a bit.
07:04:30 <rom1504> or an abstract class in c++
07:04:35 <rom1504> I see the idea
07:05:28 <joneshf-laptop> geez, what happened to haskell on arch linux
07:06:15 <rom1504> no more like a module really, class Num a where                                                                                                                                                                              (+) :: a -> a -> a
07:06:19 <rom1504> ok
07:06:54 <simukis_> joneshf-laptop: what do you mean?
07:06:58 <srhb> joneshf-laptop: I think currently onlt the broken 7.8.1 is available
07:07:15 <joneshf-laptop> srhb, that's a pain
07:07:25 <simukis_> srhb: [staging] has 7.8.2
07:07:28 <joneshf-laptop> simukis_, i can't update anything because of dep hell
07:07:49 <srhb> joneshf-laptop: I personally just fried the pacman version and installed 7.8.2 in /usr/local for now
07:08:00 <srhb> simukis_: How does one get things from staging?
07:08:04 <trolling> rm -rf ~/.ghc && rm -rf ~/.cabal :)
07:08:32 <simukis_> srhb, joneshf-laptop: http://mirror.nl.leaseweb.net/archlinux/staging/os/x86_64/
07:08:52 <simukis_> works for all mirrors that mirror staging repo
07:09:04 <Denommus> bennofs: thanks
07:09:08 <joneshf-laptop> can that be installed from 7.6.3?
07:10:20 <srhb> joneshf-laptop: What do you mean "from"? You should still uninstall everything Haskell really.
07:10:39 <joneshf-laptop> srhb, yeah, i'm going through that
07:11:04 <joneshf-laptop> i've only ever had trouble with haskell and arch
07:11:08 <joneshf-laptop> why's it such a mess?
07:11:29 <srhb> Oh, looks like it's already in the main repos
07:11:42 <srhb> joneshf-laptop: Is it a mess?
07:11:55 <srhb> joneshf-laptop: I have no problems with it
07:12:17 <joneshf-laptop> srhb, can you pass some of that luck my way? ;)
07:13:36 <simukis_> joneshf-laptop: using sandboxes contributes a lot to not having to deal with cabahells.
07:13:39 <srhb> joneshf-laptop: Probably, if you tell me what's going wrong. :P
07:16:15 <joneshf-laptop> well, maybe i need to go try using cabal only again. the last time was a while ago and i wasn't using sandbox/cabal-dev
07:16:43 <srhb> joneshf-laptop: I basically only have ghc installed globally
07:16:54 <joneshf-laptop> srhb, do you use xmonad?
07:16:58 <srhb> joneshf-laptop: I do
07:17:32 <joneshf-laptop> srhb, hmm, i'll try that way
07:17:47 <joneshf-laptop> since apparently i had to uninstall everything
07:17:47 <srhb> joneshf-laptop: I have it installed (unsandboxed) in my homedir :)
07:17:51 <bennofs> joneshf-laptop: reading http://www.vex.net/~trebla/haskell/sicp.xhtml and http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml could help to avoid cabal hell
07:18:03 <srhb> Be careful though, the hackage version of xmonad-contrib is not yet updated for ghc 7.8.2
07:18:19 * hackagebot fixed-vector 0.6.4.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.6.4.0 (AlexeyKhudyakov)
07:27:52 <joneshf-laptop> bennofs, so basically cabal tries to be smarter than it is?
07:34:13 <pranz> the function string from Parsec doesn't consume any input if the input doesn't match, right?
07:34:17 <pranz> so it fails directly
07:35:46 <Darwin226> Is it possible to use the Haskells typesystem to define syntax of a new langauge? Something like data Term = Number | Expression and data Expression = Term .+. Term
07:36:23 <tdammers> Darwin226: yes. People do it all the time.
07:36:33 <Darwin226> Can you give me an example I could look at?
07:37:18 <Darwin226> tdammers
07:37:49 <tdammers> Darwin226: pandoc, I think, is a nice example of an AST implementation
07:37:55 <tdammers> (or rather, *contains*)
07:37:59 <joneshf-laptop> Darwin226, how in depth do you want it?
07:38:06 <joneshf-laptop> Darwin226, the example
07:38:09 <tdammers> not sure what *exactly* you're looking for though
07:38:17 <tdammers> a DSL? an AST?
07:38:21 <Darwin226> I'm not sure either to be honest :)
07:38:33 <Darwin226> Well, I'd like to try and implement a DSL
07:38:41 <joneshf-laptop> Darwin226, how about an entire programming language: https://github.com/purescript/purescript
07:38:42 <Darwin226> but I assume an AST would be simpler
07:38:55 <albeit> Is there a simple way of splitting a list into two lists depending on a condition? Something like splitWith (<5) [1,4,5,6] would result in [[1,4], [5,6]]?
07:39:26 <dwcook> When building pipes in a clean environment under cabal 1.18.0.3, I get the following error: "/usr/bin/ld: no se puede encontrar -lHSmtl-2.1.3.1-ghc7.8.1" ("no se puede encontrar" means "cannot be found")
07:39:36 <tdammers> Darwin226: the line between the two is a bit blurry in Haskell :D
07:39:38 <ocharles> albeit: there is span and break that split a list into a tuple of two lists
07:39:40 <dwcook> What could the problem be?
07:39:42 <ocharles> Is that what you want?
07:39:50 <b_jonas> > let { splitWith f s = [filter f s, filter (not . f) s]; } in splitWith (<5) [1,4,5,6,1]
07:39:52 <lambdabot>  [[1,4,1],[5,6]]
07:39:56 <b_jonas> albeit: ^
07:40:01 <Darwin226> For starters, is there a way I could make my example work? So I could for example make an eval function like this http://lpaste.net/102728
07:40:17 <albeit> @ocharles: A split is perfect, forgot about that, thanks!
07:40:17 <lambdabot> Unknown command, try @list
07:40:19 <joneshf-laptop> Darwin226, the important bits are: https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Declarations.hs and https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Types.hs
07:40:23 <tdammers> runMyAST $ Program [ Literal 1 .+. Literal 3 ] -- eDSL or AST?
07:40:36 <albeit> ocharles: A split is perfect, forgot about that, thanks!
07:43:28 <albeit> *span
07:48:25 * hackagebot clash-ghc 0.3.0.1 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.3.0.1 (ChristiaanBaaij)
07:50:02 <merijn> Cabal doesn't support elif/else if?
07:55:49 <Okasu> merijn: http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
07:56:58 <albeit> Is there a way to use partial application instead of the lambda "\x -> (length x)==6"? Something like (6 == length)... but that doesnt work.
07:57:27 <merijn> Okasu: How is that relevant for my question? Cabal files aren't preprocessed using CPP
07:57:37 <Maior> @pl \x -> (length x) == 6
07:57:37 <lambdabot> (6 ==) . length
07:57:43 <Maior> albeit: ^
07:58:31 <albeit> @pl \y-> (length y) < 3
07:58:32 <lambdabot> (< 3) . length
07:58:37 * merijn sighs
07:58:39 <albeit> Maior: A cool, thanks
07:59:06 <Maior> merijn: ?
07:59:19 <pranz> liftA2 (<) length (const 3)
07:59:47 <merijn> Maior: cabal has support for stuff like "if os(windows) ... else ..." but it seems to lack an elif/elseif version
07:59:53 <merijn> At least, I don't see it in the docs
08:01:39 <Okasu> Ah, misread what you're asking for, sorry.
08:02:52 <dwcook> Cabal needs but cannot find the library HSmtl-2.1.3.1-ghc7.8.1 at some stage of the compilation of the pipes package. Any idea what the problem could be?
08:03:05 <Okasu> merijn: http://urchin.earth.li/~ganesh/temp/darcs.cabal Look like "else if" is used there.
08:03:09 <dwcook> Or ld needs it, I should say
08:03:13 <arossouw> i'm a haskell newbie, code runs http://lpaste.net/102729 , but its slow and innefficient any advice?
08:03:46 <saml> write some fast code
08:03:51 <arossouw> lol
08:03:59 <saml> what's slow?
08:04:05 <saml> i don't know how to profile
08:04:31 <arossouw> ghc -O2 -auto-all -prof
08:04:56 <saml> you parse some file
08:05:09 <fragamus> edwardk: I think I am on to something. I am using Mathematica to take an integral and produce a mathematical expression which can then be resolved numerically. I have code to hoist common sub-expressions and emit haskell.   *I think*  that the integral is the source code. I think that this is a direction we should be going in.
08:05:10 <saml> i think you should read file and write file in chunks
08:05:25 <arossouw> ok, with bytestrings , blazer maybe?
08:06:26 <arossouw> saml: takes about 15 seconds to read from 65MB file and write to output
08:06:32 <pmade> arossouw: Have you profiled the code to see where the bottlenecks are?  I'm guessing using String might be one of them, but I'd want to back that up with profile data.
08:06:55 <arossouw> ok, Perhaps you haven't installed the profiling libraries for package `split-0.2.2'?
08:07:10 <merijn> arossouw: Oh, quick question: Are you using String?
08:07:32 <arossouw> yes, Data.List and standard strings
08:07:34 <merijn> 65MB + slow IO sounds like typical symptoms of using String :>
08:07:56 <merijn> arossouw: Yeah...String sucks balls and you don't want to use it for any form of IO other than playing around
08:08:01 <merijn> arossouw: You want Data.Text
08:08:29 <arossouw> i see, i'll read up on the documentation, thank you
08:08:35 <tdammers> meh, String is fine for trivial things
08:08:42 <arossouw> http://newartisans.com/2012/08/parsing-with-haskell-and-attoparsec/ , wow . 26secs 1GB file
08:08:44 <tdammers> but yeah, generally you want Text
08:08:59 <saml> for 1GB you need to process in 1 sec
08:09:09 <merijn> arossouw: Basically, String is just a linked list of unicode code points and can (on some architectures) take >20 bytes per character
08:09:27 <tdammers> merijn: and that's fine if you process them one by one
08:09:29 <arossouw> oo, so you end up wasting ram too?
08:09:43 <merijn> arossouw: Data.Text is densely packed blobs of unicode text
08:09:51 <saml> arossouw, do you have non-haskell version? it's hard to see what's going on with test and getMq
08:10:09 <geekosaur> arossouw, sometimes, sometimes not. the flip side is String fuses quite wel in many cases so you never have more than one Char allocated at a time
08:10:10 <merijn> arossouw: Data.Text in comparison should be around 2-3 bytes per code point
08:10:16 <arossouw> saml: no :-(, yeah sorry i'm a newbie
08:10:36 <saml> getMq = head . splitOn ": " . unwords . tail . splitOn "]: "
08:10:44 <dwcook> If your data is in a non-unicode format, there's also ByteString
08:10:53 <saml> so "hello]: world: bro" => "bro"  ?
08:10:55 <tdammers> merijn: 2-4 bytes per code point plus a constant overhead
08:10:56 <arossouw> saml: bassicly , let c = splitOn ": " . unwords . tail . splitOn "]: "
08:10:57 <arossouw> map c (lines string)
08:11:14 <saml> >  head . splitOn ": " . unwords . tail . splitOn "]: " $  "hello]: world: bro" => "bro"
08:11:16 <lambdabot>  <hint>:1:78: parse error on input ‘=>’
08:11:32 <arossouw> let string = "Jan 08 00:06:15 quire <info> postfix/pipe[30578]: 9A8CEABE1212: to=<asdf@wxxxx.co.za>, "
08:11:51 <saml> you want 9A8CEABE1212  ?
08:11:56 <arossouw> yes :-)
08:12:04 <saml> i bet haskell has regex
08:12:21 <arossouw> i seen that, but not sure if its slower to do a regex
08:15:47 <kuribas> regexes are pretty fast
08:16:16 <kuribas> But also a bit messy.
08:16:28 <arossouw> i see, i'll try that too
08:16:29 <joneshf-laptop> so what's the easiest way to get away from using the distro to manage haskell packages?
08:16:35 <joneshf-laptop> load a new package-db
08:16:36 <joneshf-laptop> ?
08:16:50 <joneshf-laptop> and put it in the config file
08:16:57 <Yaniel> cabal-install
08:17:06 <saml> arossouw, https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
08:17:12 <saml> there's a section about parsing logs
08:17:23 <arossouw> great , thanks
08:17:34 <bartavelle> arossouw, do you need to parse postfix logs ?
08:17:37 <arossouw> might take me years to get good at haskell, hehe
08:17:53 <bartavelle> coz I already have a parser lying somewhere, pm me if you need this
08:18:00 <arossouw> bartavelle: just experimenting with haskell, not crucial, wrote something in c++
08:18:03 <bartavelle> ok
08:18:34 <saml> arossouw, can i have C++ version?
08:19:15 <arossouw> the c++ , just does --from email --filename, will post it in few secs, have to login to server
08:20:10 <snowble> I bet there's a perl module for that
08:21:09 <arossouw> saml: http://slexy.org/raw/s204xocnr5
08:21:21 <arossouw> warning, not good with c++
08:21:48 <saml> thanks
08:23:03 <snowble> error messages should go to cerr, and -1 is not a sensible exit code
08:23:31 <snowble> no error checks
08:23:31 <arossouw> ok
08:23:59 <snowble> queue keeps its value across loop iterations
08:24:42 <arossouw> ok, is bad code
08:29:54 <yoeight> I try to compile ghc 7.8.2 on Gentoo but here's what I got when make install
08:29:56 <yoeight> ghc-cabal: Cannot find the program 'ghc' at
08:30:23 <yoeight> of course I got a previous ghc in my $PATH
08:30:36 <yoeight> any idea ?
08:31:17 <yoeight> I try to build ghc from linux source distribution
08:31:39 <snowble> what's the error message?
08:31:54 <yoeight> snowble: ghc-cabal: Cannot find the program 'ghc'
08:32:07 <snowble> is that all?
08:32:11 <yoeight> yes
08:32:45 <snowble> then why did it say "at" in your original message?
08:33:00 <yoeight> snowble: '/home/a/tmp/ghc-7.8.2/inplace/bin/ghc-stage1' or on the path
08:33:58 <yoeight> snowble: I don't remember having this issue when building from git repo
08:35:20 <monochrom> must you build ghc from source?
08:35:47 <yoeight> monochrom: I have no problem with that
08:36:43 <haasn> yoeight: try #Gentoo-Haskell
08:36:44 <yoeight> monochrom: just having a linux source distribution not building on my machine seems weird
08:36:52 <haasn> although it works fine here (also gentoo)
08:37:05 <yoeight> haasn: it's still in 7.6.
08:37:26 <haasn> yoeight: then update your overlays
08:37:30 <yoeight> haasn: and I don't want to rely on this
08:37:59 <haasn> Oh, sorry, at first I thought you were talking about the ghc package
08:38:15 <haasn> Not your own clone of the tree
08:38:28 <haasn> Then never mind, #Gentoo-Haskell is irrelevant
08:38:29 <pyon> Is there anything like the "interact" function, but which lets you specify which input and output handles you want to read from and write to, respectively?
08:38:37 <haasn> (Still, why not use the package?)
08:39:11 <snowble> @src interact
08:39:11 <lambdabot> interact f = do s <- getContents; putStr (f s)
08:39:28 <snowble> hInteract in out f = do s <- hGetContents in; hPutStr out (f s)
08:40:50 <pyon> Mmm... "hGetContents in >>= hPutStr out . f" ... nice :-)
08:48:30 <Dongyancai> hello, I'm trying to use STArray in my code. but it doesn't work, I want to know the reason. the code is http://pastebin.com/qvVcrwrm.
08:50:53 <dwcook> @type runSTArray
08:50:54 <lambdabot> Not in scope: ‘runSTArray’
08:51:00 <dwcook> Dongyancai, runSTArray gives an Array, not a list
08:55:14 <joneshf-laptop> okay, so how do I know if i want tosmething installed as global with cabal, instead of user?
08:55:41 <joneshf-laptop> i cn see executables that need to be accesed by multiple users
08:55:47 <joneshf-laptop> but what about stuff for libraries?
08:55:54 <joneshf-laptop> do i just choose arbitrarily?
08:55:59 <pmade> joneshf-laptop: I'm not sure there's ever a good reason to install a package in the global store
08:56:10 <joneshf-laptop> oh?
08:56:16 <dmwit> I don't agree with pmade.
08:56:16 <pmade> At least I never do.
08:56:27 <dmwit> However, I think it's rare, because typically you are not administering a truly multi-user machine.
08:57:56 <joneshf-laptop> hmm
08:58:20 <Dongyancai> dwcook, I moved into getElems (runSTArray $ do ... return arr)  , but have no idea on the error message.  http://pastebin.com/0vRkcha9
08:59:04 <joneshf-laptop> well maybe a better question would be, wha'ts the best way to resolve this: http://lpaste.net/102731
09:01:04 <pmade> joneshf-laptop: Is this due to you installing Haskell packages from your OS vendor in addition to installing them through cabal-install?
09:01:06 <dwcook> Dongyancai, stylistic note, do { a' <- a ; return a' } is exactly a for a proper Monad. wrap = getElems . runSTArray $ newArray (0, 9) e
09:01:20 <bergmark> joneshf-laptop: i'd try to figure out why it wants to downgrade bytestring
09:01:45 <dwcook> Dongyancai, I think that might make it easier to see the problems
09:02:09 <bergmark> cabal install aeson haskell-src-exts haddock --constraint='bytestring == 0.10.4.0' might work or give a more informative error
09:02:18 <joneshf-laptop> pmade, probably, i tried to remove everything from the distro, but looks like it's still biting me
09:02:24 <dwcook> For one thing newArray must run in a specific monad but runSTArray deals with a non-monadic value
09:03:30 <dwcook> Dongyancai, have you been looking at the types of the bindings you're using?
09:03:34 <dwcook> Doing so is vital
09:03:35 * hackagebot alsa-mixer 0.2.0.2 - Bindings to the ALSA simple mixer API.  http://hackage.haskell.org/package/alsa-mixer-0.2.0.2 (ThomasTuegel)
09:04:22 <ReinH> Nik05: :p
09:05:32 <fizbin> When I find myself a State with two states, what is it I want?
09:05:46 <fizbin> Do I really want a state with a state that's a tuple?
09:06:00 <prophile> yup
09:06:46 <fizbin> If so, is there something with the signature: State (a1, a2) b -> a2 -> State a1 b ?
09:06:47 <davidthomas> fizbin: case I just hit was needing one state for myself and another for a library...
09:07:09 <ReinH> fizbin: what would that do?
09:07:31 <davidthomas> ReinH: I read it as "run half the state"
09:07:32 <fizruk> fizbin: do you want State a r -> State (a, b) r ?
09:07:37 <dwcook> fizbin, either a tuple or a user-defined data type, which could be nicer because you could give it descriptive field names, for example
09:07:56 <davidthomas> ReinH: Would seem to have to work like currying...
09:08:14 <davidthomas> not sure whether it could actually be worked out or not, though
09:08:23 <ReinH> davidthomas: I'm just curious what fizbin wants it to do :)
09:08:42 <ReinH> you can use lens to work with your state in a variety of ways
09:08:45 <fizbin> thing actWithTwoStates initialState2Value should mean "run the action with two states with the given initial state, using the state of the external world for the first state"
09:08:55 <fizruk> davidthomas: i doubt you can run half state, after all it can depend on another half
09:09:45 <dwcook> There are two fizzies :o
09:10:28 <ReinH> dwcook: o_O
09:10:33 <ReinH> I can't deal with this.
09:10:43 <fizbin> I guess a definition of what I want might be:
09:11:27 <joneshf-laptop> byorgey, that seems to have worked, though i wonder why it needed the constraint to begin with
09:12:24 <fizbin> thing actWithTwoStates initialState2Value = StateT (\a1 -> runStateT actWithTwoStates (a1, initialState2Value))
09:13:16 <fizruk> :t state
09:13:18 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
09:13:20 <ReinH> fizbin: ah
09:14:13 <fizruk> fizbin: state (\s -> runStateT actWithTwoStates (s, initialState2Value)) ?
09:14:19 <monochrom> joneshf-laptop: the short story is that aeson has explicit "bytestring < 0.10.4.0" (but ghc 7.8.2 emphatically comes with 0.10.4.0).
09:14:47 <joneshf-laptop> monochrom, ah
09:14:55 <fizbin> fizruk: sure.
09:15:27 <fizbin> Oh, wait. Not quite what I want though.
09:15:40 <ReinH> Shame that it doesn't typecheck though
09:16:29 <fizruk> :(
09:16:40 <monochrom> the long story is more complicated. if bytestring >= 0.10 && < 0.10.4.0, then aeson uses bytestring's fast builder. else if bytestring < 0.10.4.0, then aeson uses blaze-builder because older bytestring did not have fast builder. else, don't use either.
09:17:34 <monochrom> therefore --constraint='bytestring = installed' is a "success" but likely tells aeson to be slow.
09:18:28 <monochrom> err no, aeson has an explicit "bytestring >= 0.10.4.0" case. I now don't know what it does.
09:18:45 <predator117> > let add1 = modify (+1) :: State Int () in flip execState (1,2) $ zoom _2 add1 >> zoom _1 add1
09:18:47 <lambdabot>  (2,3)
09:18:53 <predator117> fizruk: does zoom what you want?
09:19:09 <fizruk> predator117: redirect to fizbin
09:19:25 <predator117> oh sorry :)
09:19:27 <fizbin> @type zoom
09:19:28 <lambdabot> (Zoom m n s t, Control.Lens.Internal.Zoom.Zoomed n ~ Control.Lens.Internal.Zoom.Zoomed m) => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
09:19:34 <predator117> yeah its from lens
09:19:50 <fizbin> How on earth could I know if it does what I want?
09:19:57 <fizruk> fizbin: zoom _1 allows to do State a r -> State (a, b) r
09:19:57 <fizbin> From the example, maybe?
09:20:02 <predator117> > let add1 = modify (+1) :: State Int () in flip execState (1,2) $ zoom _2 add1 >> zoom _1 add1
09:20:04 <lambdabot>  (2,3)
09:20:29 <predator117> running add1 in a state with a tuple, and applying it only to a part
09:20:37 <fizbin> Ah. I need the opposite.
09:20:50 <ReinH> fizbin: are you sure?
09:21:23 <monochrom> oh I see. aeson the flag for >=0.10.4.0 is given the default "False"
09:21:29 <monochrom> err typo
09:21:34 <fizbin> I'm doing a calculation in a state X, but to actually do that calculation I either need to do a really nasty fold or have access to a Map that I modify as I go along.
09:21:48 <monochrom> aeson's flag for "should I use bytestring>=0.10.4.0" is given the default "False"
09:23:01 <ReinH> fizbin: oh, I'd just run another State computation
09:23:09 <ReinH> for that case
09:23:22 <ReinH> rather than try to join them into a single state
09:23:50 <monochrom> sigh. this is why cabal-install should default to "forbid multiple versions" so that package authors do not have to choose a default that is bound to be wrong for the future
09:23:53 <fizbin> Except that this second calculation may, at some point, in the middle of the computation, reasonably conclude "right, we need to change this bit of the global X state"
09:24:05 <ReinH> ah
09:24:10 <ReinH> well that's weird then
09:26:00 <fizbin> Ah, there:
09:26:04 <fizbin> @type \x y -> state (\s -> id *** fst $ runState x (s, y))
09:26:06 <lambdabot> MonadState t m => State (t, t1) a -> t1 -> m a
09:26:39 <ReinH> fizbin: o_O
09:27:27 <Dongyancai> dwcook, I don't know why "getElems ( runSTArray $ (newArray (0, 9) e))" and "getElems . runSTArray $ (newArray (0, 9) e" makes different error message. in the latter case, I got a "forall s. ST s (STArray s i0 e0)", but how can I specify the s?
09:27:45 <fizbin> @type let thing actWithTwoStates initialState2Value = state (\a1 -> id *** fst $ runStateT actWithTwoStates (a1, initialState2Value)) in thing
09:27:46 <lambdabot> MonadState t m => StateT (t, t1) ((,) a) t -> t1 -> m a
09:28:28 <fizruk> fizbin: I guess, you need StateT there in place of state
09:28:48 <fizbin> Not necessarily.
09:28:51 <ReinH> fizbin: wouldn't it be more clear to just do { let s2 = whatever; s1 <- get; flip runState (s1, s2) $ do { ... } }
09:29:42 <fizbin> ReinH: assuming you then followed that with the necessary stuff to shove the fst of the final state back in.
09:30:31 <ReinH> fizbin: { let s2 = whatever; s1 <- get; put . fst . snd $ flip runState (s1, s2) $ do { ... } }
09:30:45 <ReinH> but yeah
09:31:01 <ReinH> I'd rather read that than id *** fst $ runState x (s,y)
09:31:07 <fizbin> Still not quite, because put returns (), but...
09:31:24 <fizbin> I dunno. I find (id *** fst) pretty readable.
09:31:30 * ReinH shrugs
09:31:36 <ReinH> I guess it depends on your familiarity with Arrow
09:32:06 <fizbin> Right. You need to know that *** is the "do different functions to each side of a tuple" operator
09:32:18 <Maior> :t ***
09:32:20 <lambdabot> parse error on input ‘***’
09:32:24 <Maior> :t (***)
09:32:25 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
09:32:45 <aviraldg> Haskell newbie here - I get the following when trying to `cabal install haddock' on Windows (Haskell Platform 2013.2...): src\Haddock\InterfaceFile.hs:85:2:
09:32:45 <aviraldg>      error: #error Unsupported GHC version
09:33:33 <monochrom> yes, haddock version has fairly tight tie-in to GHC version. you need newer GHC for newer haddock.
09:34:10 <fizbin> Or, conversely, you need to tell cabal to get exactly the right version of haddock for your installed version of ghc.
09:34:19 <monochrom> if you stick with Haskell Platform 2013.2 (recommended), please don't bother with newer haddock
09:34:33 <monochrom> you already has a good haddock for your GHC
09:36:10 <aviraldg> I believe it's included with Haskell Platform, but for some reason it's still giving me problems with SublimeHaskell's install process (and the recommended fix is to update Haddock?)
09:36:26 <fizbin> :t (***) :: (a1 -> b1) -> (a2 -> b2) -> (a1, a2) -> (b1, b2)
09:36:28 <lambdabot> (a1 -> b1) -> (a2 -> b2) -> (a1, a2) -> (b1, b2)
09:36:45 <Maior> fizbin: ahhhh that helps
09:37:24 <Maior> fizbin: I don't understand how that is a somethingable type from above, but, ok
09:37:31 <Nik05> 18:01 < ReinH> Nik05: :p
09:37:42 <monochrom> does it recommend an exact haddock version, and have you verified that the recommended exact version is right for your GHC (7.6.3)?
09:37:48 <Nik05> ReinH i found the problem :P
09:38:07 <ReinH> Maior: it's Arrow instantiated to the function arrow :P
09:38:09 <ReinH> Nik05: :)
09:38:18 <fizbin> Maior: (->) is the canonical Arrow impl. The other moderately common one is the Kleisli arrow. All other arrow types are really specialized library types.
09:38:23 <Nik05> well didnt found the problem. I threw away everything and wrote it again, now it works :)
09:38:26 <aviraldg> monochrom, The error I get is: Could not find module `Documentation.Haddock', and indeed, `import Documentation.Haddock' in GHCi does not work.
09:38:28 <monochrom> you know, a vague "use a newer version" is very cheap advise. as in, cheap to give, easy to say.
09:38:30 <ReinH> Nik05: seems good
09:39:04 <ReinH> aviraldg: maybe SublimeHaskell should be made to work with the haddock that comes standard on the standard Haskell installation
09:39:16 <ReinH> rather than telling people to "update" to a version that apparently doesn't work with same
09:40:06 <ReinH> aviraldg: Sorry that isn't an answer to your question, but "update haddock" seems like making it the user's problem instead of the developer's.
09:40:31 <aviraldg> Hmm, thanks anyway :)
09:40:39 <aviraldg> Any alternative recommendations for an IDE?
09:40:47 <monochrom> eh? "If you are using GHC 7.6, you might have trouble with too new versions of haddock"?!
09:40:49 <fizbin> Maybe there's an older version of SublimeText?
09:40:55 <monochrom> it wants older, not newer?
09:41:00 <Maior> aviraldg: IDEA?
09:41:04 <ReinH> monochrom: oh it wants older.
09:41:06 <ReinH> Weird.
09:41:21 <ReinH> monochrom: yeah, I'd say it's their job to fix their haddock support but what do I know
09:41:33 <aviraldg> Looks like IDEA's plugin hasn't been updated recently.
09:41:33 <monochrom> this sounds like I get to say, "SublimeHaskell needs to be updated"
09:41:39 <ReinH> monochrom: yep :)
09:42:37 <ReinH> I mean seriously, if you ship haskell developer tools, you probably want to make them work with the current Haskell Platform as a priority
09:42:48 <fizbin> I've found emacs + flycheck quite convenient, but I already used emacs.
09:42:59 <athan> Hey guys noob question: When testing the success of a library, what is a good way to keep the source of the lib segregated from your simple tests, yet still load the module in your library? I'm thinking of something like "import ../foo/Network.Wai.Middleware.Foo"
09:43:05 <ReinH> also vim + ghc-mod + vim2hs but I've already used vim
09:43:08 <aviraldg> I'm 90% through LYAH and I think an IDE with autocomplete might help me get acquainted with the standard library.
09:43:28 <ReinH> athan: Put your tests in a different file.
09:43:31 <Maior> aviraldg: define "hasn't been updated recently"?
09:43:33 <ReinH> And a different module
09:43:37 <athan> I really want to try yi + leskeh
09:44:13 <athan> ReinH: I'm not trying to write formal tests, I just want to play with my lib without having to upload it to hackage lol
09:44:38 <ReinH> athan: I'm not sure what you're asking... write a cabal file and write your imports the normal way? You don't have to upload it.
09:44:41 <aviraldg> If we're talking about the same thing (http://plugins.jetbrains.com/plugin/6330?pr=), > 2 years?
09:44:52 <athan> aviraldg: FP Complete's is probably one of the best solutions for now
09:44:59 <Maior> aviraldg: yep, what's the problem?
09:45:01 <ReinH> athan: oh good one
09:45:10 <ReinH> I enjoyed using FP Complete IDE
09:45:44 <athan> ReinH: I'm just trying to play around with my lib - use it in other projects
09:45:58 <athan> I'm trying to import the modules I defined in my lib
09:46:06 <athan> in a completely different project
09:46:13 <athan> does that make sense? Sorry man
09:46:24 <athan> I don't really know how to use cabal skillfully
09:46:49 <aviraldg> Maior, more effort setting things up? Usually the case with stuff that hasn't been updated in a while.
09:46:53 <athan> Would I add the path to my lib's source code in my toy project's cabal file?
09:46:59 <aviraldg> FP Complete - the "cloud" IDE?
09:47:16 <Maior> aviraldg: not ime
09:47:33 <athan> aviraldg: It's actually pretty nice
09:47:41 <ReinH> It is.
09:47:52 <athan> I'd say it's niche is more for education than for production, though
09:48:31 <athan> aviraldg: But to be successful in haskell, you're going to have to be resourceful ;P
09:48:57 <Maior> I've been using it, with near zero setup effort
09:48:58 <aviraldg> I've tried it too, though I was a little unconvinced about the entire Cloud IDE thing.
09:49:00 <athan> ReinH: How do you load a custom library in a new project, if it hasn't been uploaded to hackage?
09:49:01 <Maior> plus vim
09:49:07 <Maior> (by "it" I mean IDEA)
09:49:20 <aviraldg> I'll try it out then :)
09:49:24 <athan> aviraldg: "Now, with space-lazer technology"
09:49:27 <athan> :)
09:49:45 <fizbin> I have... issues with FP Complete IDE. But that's from using the pro, self-hosted version.
09:50:05 <fizbin> And the issues could very well be in the hardware we're hosting it on.
09:50:24 <fizbin> Or because our sysadmin has no time to keep the version updated.
09:50:34 <athan> Hahaha. I never got keter to work
09:51:01 <athan> I'm excited to play with nixOS though, not sure how that'll get integrated into a deployment platform
09:53:07 <aviraldg> FP Complete seems to have ... limited autocomplete?
09:53:21 <athan> hahaha
09:53:42 <aviraldg> I was hoping for inline documentation / parameter information at least :P
09:54:01 <athan> aviraldg: I KNOW!!!! I wish they had that
09:54:09 <athan> or like... implicit type signatures or something
09:54:23 <athan> I really want to make a really fluid, dynamic openGL based editor haha
09:56:21 <Jafet> Type system in the vertex shader
09:56:46 <quchen> There is no somewhat standard class for indexed folds, is there?
09:57:55 <ReinH> quchen: well lens has FoldableWithIndex
09:58:26 <ReinH> quchen: http://hackage.haskell.org/package/lens-4.1.2/docs/Control-Lens-Indexed.html
09:58:46 <quchen> Oh, it's in Lens after all. I thought it just had indexed folds as lensy things.
09:59:02 <ReinH> quchen: it's super useful :)
09:59:17 <edwardk> we use it a lot in the ermine compiler
09:59:33 <quchen> It's somewhat tied to Lens due to 'ifolded' though.
10:00:00 <edwardk> well, yes. it is part of lens, so the naming was made to fit the local conventions ;)
10:00:14 <quchen> I was just using Data.Map.foldMapWithKey a lot and it seemed a little non-generic.
10:00:26 <ReinH> quchen: well yes, it isn't, is it? :p
10:00:54 <edwardk> you can define ifoldMap in FoldableWithIndex and ifolded will be defined in terms of t
10:01:22 <edwardk> so instance FoldableWithIndex Int IntMap where ifoldMap = IntMap.foldMapWithKey
10:01:48 <quchen> edwardk: Sure, it makes sense to have it like that if it's part of Lens. But it's a huge dependency.
10:01:50 <edwardk> we chose ifoldFoo rather than foldMapWith(Key|Index) because then when you import Map unqualified it doesn't uselessly conflict
10:01:57 * edwardk shrugs.
10:02:05 <quchen> I'm not arguing against Lens here, I just wondered whether this (pretty useful) class existed elsewhere.
10:02:10 <quchen> That said, I'm using Lens anyway :-)
10:02:20 <edwardk> you need to pick up half the dependencies of lens to define the class instances sans orphans
10:02:33 <edwardk> so factoring it out saves almost nobody anything
10:03:08 <edwardk> At, Ixed, FoldableWithIndex, etc. are one of several reasons why lens depends on half of the platform
10:03:19 <ReinH> lens will eventually assimilate all typeclasses
10:03:36 <ReinH> and then the entire platform
10:03:41 <ReinH> there is no platform only lens
10:04:25 <Peaker_> edwardk, if "base" somehow got a "newtype LensLike f s t a b = ... " or such in it, so everyone can define newtype-wrapped LensLike's, and then lens worked with that newtype (still subtyping on the "f"),  besides losing "traverse" compatibility (and gaining better error messages?) what would be lost?
10:04:54 <Peaker_> I guess it would need to look a little different for the profunctor representation
10:05:25 <Peaker_> of course a newtype-wrapped "traverse" would exist somewhere too
10:06:56 <ReinH> Peaker_: treat yo self to a newtype wrapper https://www.youtube.com/results?search_query=treat+yo+self
10:09:13 <ReinH> I suppose linking to the actual video would have been better
10:16:19 <athan> How do I get cabal to load one of my packages? I added the path to the folder in "include-dirs", but cabal is still saying that it can't find my package
10:16:35 <athan> my package _is_ listed in "build-depends", though. Could that cause the issue?
10:17:43 <athan> or really, how do I get cabal to include a custom package into a sandbox?
10:18:13 <dmj`> cabal sandbox add-source package
10:18:22 <dmj`> where package is the name of your custom package
10:18:24 <Dongyancai> well, I think I need to ask in another way. as the code http://pastebin.com/0iwSXVe8 shows. I can make a [Int] by casting to "ST s (STArray s Int Int)", but how can I get a function of type "Integral a => [a]"? (there is a typo on the pastebin post).
10:18:36 <athan> dmj`: Too cool! Thank you!
10:18:47 <dmj`> np
10:19:25 <athan> dmj`: What if my package isn't in hackage, and it's just parked in my filesystem somewhere?
10:19:41 <athan> cabal sandbox add-sources path/to/package/folder?
10:19:45 <dmj`> yes
10:20:15 <athan> WOO! You just saved me a wall of headache, thank you dmj`
10:20:18 <athan> how've you been?
10:22:21 <delinquentme> OKE sooo trying to do web scraping ... TagSoup or Shpider?
10:22:34 <dmj`> athan: I'm good thank you, yourself?
10:22:51 <delinquentme> also I've got Shpider installed and I'm trying to run a .hs file containing the intro example (http://hackage.haskell.org/package/shpider ) with no luck
10:23:27 <athan> delinquentme: It all depends on the website you're scraping. If you know the target's layout, you can easilly extract the data. Tagsoup worked well for me, it was nice and forgiving
10:23:35 <athan> just remember that javascript events might be a pain
10:23:43 <delinquentme> https://gist.github.com/carlcrott/10749441
10:24:24 <athan> dmj`: I've been good :) I'm taking on the Texts in Computing series right now, it's a really good set of entry-level haskell stuff
10:24:42 <carlosgaldino> hey guys, just want to let you know, if you use mac and alfred app, I created a workflow so you search hoogle using alfred: https://github.com/carlosgaldino/alfred-hoogle-workflow
10:25:08 <athan> any interesting projects lately?
10:25:18 <Maior> carlosgaldino: <3
10:26:01 <delinquentme> athan, right now I cant even get the example to execute
10:26:19 <athan> delinquentme: Do you know haskell yet? :P
10:26:38 <delinquentme> athan, nope! but tutorials fail to keep me interested
10:26:41 <athan> sometimes libraries can be a little outdated. I find it's best to dig to get your gold :)
10:26:50 <delinquentme> I'm writing a client to keep me perpetually logged into dating websites
10:27:05 <athan> Gettin the babes, eh?
10:27:10 <delinquentme> Haskell fails quietly on a bad lib build?
10:27:12 <athan> delinquentme: haha
10:27:20 <athan> delinquentme: Mmmm, no not really
10:27:21 <delinquentme> yeah ^_^ or at least gaming the algo :D
10:27:55 <athan> delinquentme: I suggest you learn haskell well first
10:28:17 <delinquentme> haha I wish it worked like that =/
10:28:22 <athan> delinquentme: It's necessary to know, in order to use it
10:28:25 <athan> :/
10:28:28 <Dongyancai> I think I missed a lot of thing, by a misconfig on irssi...  very sorry for that. Is my question answered?
10:28:30 <athan> what are you having trouble with
10:28:31 <athan> ?
10:28:33 <delinquentme> THATS WHAT THEY ALL SAY :D
10:28:35 <athan> other than the lib haha
10:28:50 <delinquentme> nah I've got the lib installed
10:29:08 <athan> oh? Hmm
10:29:23 <athan> delinquentme: Can you paste the error you get to lpaste?
10:29:51 <delinquentme> yea ... with $ runhaskell Setup configure && runhaskell Setup build && sudo runhaskell Setup install
10:30:14 <athan> just use cabal man
10:30:27 <athan> replace that whole line with `cabal install`
10:30:33 <athan> or better yet
10:30:36 <Dongyancai> athan, I think I posted a question about http://pastebin.com/0iwSXVe8, simply, I want to get (Integral a => [a]) on the wrap function.
10:30:39 <delinquentme> http://lpaste.net/102733
10:30:41 <athan> `cabal sandbox init && cabal install`
10:31:38 <athan> Dongyancai: Okay, hold on, my computer is a little overencumbered right now
10:32:27 <briskies> can someone help me get cabal working... I downloaded GHC 7.8.2, put the required folders in the path, then downloaded the Windows cabal.exe, but when trying to use it to install anything I just get "setup.exe: does not exist"
10:32:56 <S11001001> briskies: I'd wait for the platform to get it working on windows.
10:33:04 <athan> delinquentme: google "naked top-level expression haskell" ;)
10:35:18 <athan> Dongyancai: I can't say that I know ST arrays well, but let me dig a little and I'll tell you what I find
10:35:56 <Dongyancai> athan, thank you, I'll hold on.
10:37:50 <athan> Dongyancai: I think this one may be beyond me. `newArray` and `getElems` use the monadic interpretation of mutable arrays, correct?
10:37:56 <athan> and STArray is an instance of it?
10:38:11 <Phillemann> I'm trying to install the latest cabal, so I downloaded the cabal-install tarball, extracted it and rand ./bootstrap.sh. This fails with Setup: At least the following dependencies are missing: Cabal >=1.18.0 && <1.19
10:38:47 <athan> Phillemann: You may be better off with `cabal install cabal-install`
10:39:08 <athan> Phillemann: You do have haskell platform installed, right? What version of GHC do you have installed?
10:39:08 <Phillemann> And using my distribution's cabal as a "base", so to speak?
10:39:20 <athan> yes!
10:39:23 <Phillemann> 7.6.3
10:39:24 <snowble> Phillemann: cabal-install is not cabal
10:39:32 <athan> it's not?
10:39:33 <athan> o.O
10:39:48 <Phillemann> I want to use cabal sandbox, which is not included in my distribution's cabal version yet.
10:40:04 <athan> Phillemann: I may be mistaken, but I believe 1.18.x requires GHC >= 7.8
10:40:05 <Phillemann> Which is why I wanted to upgrade manually. But ok, I'll try cabal install cabal-install.
10:40:13 <Phillemann> athan: Oh!
10:40:16 <athan> give it a shot!
10:40:27 <athan> yeah, you may have to compile ghc as well :/
10:40:34 <snowble> Phillemann: can't you install Cabal >= 1.18?
10:40:36 <athan> That's what I had to do anyway. What distro are you running on?
10:40:44 <Phillemann> Fedora 21
10:40:45 <Dongyancai> athan, I'm not sure. I'm very new on monadic things but I need it... I'm finding a way to make ghc know newArray's result casted to some type according to real type.
10:40:49 <snowble> I mean, that's what the error message wants
10:41:19 <athan> ahh okay
10:41:19 <athan> hmm
10:42:13 <athan> Phillemann: Try compiling ghc from scratch (maybe even head! :P), then see if you can shortcut your .cabal/bin in your PATH, like:
10:42:31 <athan> export PATH=/home/you/.cabal/bin:PATH
10:42:51 <athan> then, try and run `cabal install cabal-install`
10:43:10 <athan> that's what did the trick for me, although I'm not sure if I'm wrong or not (snowble, you have any comments?)
10:43:34 <Phillemann> Hm, building a compiler sounds a bit daunting, but I'll check the guide.
10:43:53 <athan> Dongyancai: That's a really good practice. The monadic generalization makes it so that your functions would not have any ability to cast to a concrete type without that signature
10:43:56 <athan> my guess
10:44:02 <athan> is that it would be something like
10:44:04 <snowble> athan: my comment is, why not try the obvious first?
10:44:18 <snowble> i.e. install Cabal 1.18
10:44:24 <Phillemann> snowble: Well, how do I do that?
10:44:26 <athan> :: (Integral a) => ST s (STArray s a a)
10:44:42 <int-e> Cabal 1.18.x works fine with ghc 7.6, but you have to avoid installing network-2.5
10:44:43 <Phillemann> It's kind of a chicken and egg problem, isn't it? At the moment, I only have ghc installed.
10:44:59 <athan> snowble: Well, fedora doesn't have that version available, and isn't the source of cabal written in haskell?
10:45:00 <snowble> ah
10:45:01 <Phillemann> My distribution gives me 1.16
10:45:02 <Dongyancai> arthan, I'll try it.
10:45:11 <athan> int-e: Well noted! Thank you
10:45:23 <ReinH> athan: I'm running cabal 1.18.0.2 with ghc 7.6.3
10:45:28 <ReinH> oh never mind
10:45:28 <athan> o.O
10:45:36 <Phillemann> Ok, so I'll install cabal-install and then try cabal install cabal-install.
10:45:52 <Phillemann> cabal-install-1.16, that is.
10:46:06 <Phillemann> And then take care not to use the global cabal anymore.
10:46:10 <athan> Phillemann: Yeah that's a good idea. It's generally a good idea to keep the whole platform available, even if they're lower versions
10:46:18 <athan> yeah that's what I did
10:46:35 <Phillemann> Thanks for the help so far. Hope this works. :)
10:46:37 <athan> I used my distro's platform as a host for cross-compilation
10:46:43 <athan> me too! No prob :)
10:46:52 <snowble> you'll just have to make sure ~/.cabal/bin is first in your path
10:47:00 <snowble> because that's where programs go by default
10:47:07 <geekosaur> usually
10:47:32 <Phillemann> What's that about the network package, though?
10:47:34 <athan> rut roh
10:47:45 <Phillemann> Should I...black list it, or something?
10:47:58 <athan> "Configuring x509-1.4.11...
10:47:59 <athan> cabal: internal error: evacuate: strange closure type -2131979758"
10:48:08 <athan> what do I do? D:
10:48:28 <snowble> report a ghc bug, maybe
10:48:29 <athan> Phillemann: That's tricky...
10:48:44 <snowble> int-e: what's the issue with network-2.5?
10:48:47 * hackagebot purescript 0.4.18.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.18.2 (PhilFreeman)
10:48:48 <Phillemann> Or, hm...can I install a newer ghc version via cabal? :D
10:48:48 <athan> Phillemann: I really suggest building the latest ghc, it makes life a lot easier :)
10:48:58 <athan> yes!
10:49:12 <athan> you can grab the ghc-head source from github
10:49:18 <athan> ...if you're daring
10:49:20 <monochrom> must you build ghc from source?
10:49:36 <athan> Unfortunately, I think 7.8.x is source only
10:49:39 <athan> I'll check though
10:49:41 <snowble> athan: nonsense
10:49:48 <monochrom> 7.8.2 is not source-only
10:49:52 <int-e> snowble: cabal-install in its infinite wisdom installs HTTP-4000.2.4 and network-2.5.0.0, but they are not compatible; later versions of HTTP have an upper bound on the network package.
10:49:58 <athan> oh, cool beans
10:49:59 <snowble> and I wouldn't recommend 7.8 because I doubt most packages have been updated yet
10:50:11 <athan> snowble: Sorry, that was my experience about 2/3 months ago
10:50:13 <int-e> Phillemann: just cabal install 'network<2.5' cabal-install
10:50:26 <Phillemann> http://lpaste.net/102734 - this is the output of just running cabal install cabal-install.
10:50:32 <Phillemann> int-e: Ah, ok then.
10:50:57 <int-e> Phillemann: yes, that's the error.
10:51:30 <int-e> snowble: (the fault is with the HTTP maintainers who did not put an upper bound on network in that version of HTTP)
10:51:51 <monochrom> cabal-install 1.18 is quite buildable and uneventful with ghc 7.6 and haskell platform 2013.2.0.0
10:52:30 <bernalex> with haskell's ad-hoc polymorphism and pattern matching, you may do this sort of pattern matching where you have multiple entry points for a function. what is this more specifically called? random example:
10:52:32 <bernalex> curWord (ToRead (_ , cw:_)) = Just cw
10:52:35 <bernalex> curWord _ = Nothing
10:52:41 <athan> Phillemann: https://github.com/ghc/ghc >:D
10:52:43 <monochrom> the only new lib it must bring in is Cabal-1.18
10:53:48 <athan> bernalex: Type inference
10:54:03 <bernalex> athan: I mean the ability to define multiple function entry points
10:54:21 <athan> bernalex: Mmmm, that's not entirely possible without qualified types (type classes)
10:54:24 <monochrom> it is very saddening to me that cabal-install is so eager to bring in new lib versions at a whim
10:54:38 <snowble> athan: nonsense
10:54:38 <athan> bernalex: I think all functions have one entry point technically, with a well defined type
10:54:47 <bernalex> in e.g. Elm, you cannot do that. you have type inference, pattern matching and ad-hoc polymorphism, and you can use it with e.g. case, but you cannot have multiple function entry points.
10:54:47 <snowble> oh, that's what you mean
10:54:51 <snowble> athan: right
10:54:52 <athan> and the qualified type signature merely opens the door more
10:55:00 <bernalex> athan: right, but in practice you sort of have multiple.
10:55:10 <athan> bernalex: It's an illusion :)
10:55:18 <monochrom> what does "multiple function entry point" mean?
10:55:22 <snowble> bernalex: I don't know if it has a specific name
10:55:23 <bernalex> athan: yes. I get what you mean. thanks for the clarification.
10:55:30 <athan> :) No prob!
10:55:31 <snowble> monochrom: defining a function with multiple equations
10:55:48 <monochrom> that is, really, syntax sugar for "case"
10:55:48 <snowble> i.e. syntactic sugar for case / pattern matching
10:56:05 <Jafet> Those are normally called equations.
10:56:22 <bernalex> monochrom: snowble: yes.
10:56:27 <Jafet> (The equals sign tends to give it away.)
10:56:32 <bernalex> Jafet: so what do you say, multiple equations?
10:56:44 <Jafet> "equations" is already plural
10:56:50 <monochrom> and the sum type involved, "data X = Case1 ... | Case2 ... | Case3 ...", is really one single union type with tags, not multiple types.
10:57:34 <athan> the equations are merely discretely defined, yet coherant to the monolithic type signature of the function. Any case expression can be rewritten with if statements.
10:58:08 <athan> monochrom: Ahh! That's a lot more puzzle-fitting than I'm used to, thank you!!
10:58:10 <bernalex> Jafet: I meant in a context where you want to make a point of a language which allows you to have multiple equations.
10:58:40 <Jafet> isJust cannot be written with "if statements" (mainly because "if statements" don't exist, but also for other reasons)
10:58:45 <dwcook> athan, could you provide an example of rewriting an arbitrary case expression with if?
10:59:03 <athan> foo :: Int -> Maybe Int
10:59:32 <athan> foo a | a < 4 = 4
10:59:42 <athan> foo a | otherwise = 0
10:59:51 <athan> that's the guarded version
11:00:01 <athan> and the if-based version is
11:00:12 <dwcook> athan, that is not a case expression.
11:00:13 <athan> foo a = if (a < 4) then 4 else 0
11:00:22 <monochrom> I think you can safely replace "multiple entry points" by "pattern matching".
11:00:27 <athan> dwcook: My mistake. Isn't a case expression similar?
11:00:40 <athan> dwcook: They all revolve around the same pivotal idea
11:00:46 <dwcook> athan, no. Case expressions pattern match, guards check boolean conditions.
11:00:51 <monochrom> "Haskell has pattern matching" is a very down-to-earth way to say that feature
11:00:54 <athan> hmm, very intersting
11:01:33 <athan> Couldn't you implement pattern matching via if-else?
11:01:39 <dwcook> athan, no.
11:01:57 <carter> int-e: what happened with http?
11:02:00 <monochrom> in haskell, "case" is more fundamental. but you can replace "case" by a suite of predicates and selectors.
11:02:04 <dwcook> There is not a general way to turn a pattern into a predicate.
11:02:04 <athan> thank you for educating me, dwcook :)
11:02:26 <athan> now that's interesting
11:02:51 <dwcook> athan, for example, isNothing and isJust are sufficient to replace case on Maybe types, but in general Haskell does not provide such predicates automatically.
11:02:58 <dwcook> Well, no
11:02:58 <monochrom> for example predicates and selectors are fundamental in scheme. 3rd-party "case" libraries are derived from them.
11:03:00 <ReinH> dwcook: sure there is... use a case statement! ;)
11:03:06 <athan> dwcook: due to polymorphism?
11:03:15 <delinquentme> package managers are supposed to work =/  cabal install curl ... fails with ExitFailure1
11:03:18 <dwcook> athan, if you use those you can't get the actual thing inside the Just without another function
11:03:25 <athan> exactly!
11:03:27 <delinquentme> I mean this is CURL ... how can that fail?
11:03:30 <athan> just like head []!
11:03:35 <athan> wow
11:03:37 <dwcook> ReinH, right, I mean other than that :)
11:03:39 <athan> mind = blown
11:04:07 <athan> delinquentme: Do you have libcurl-dev installed?
11:04:08 <monochrom> athan, you may like to read my http://www.vex.net/~trebla/haskell/crossroad.xhtml
11:04:15 <dwcook> ReinH, or really, first-class patterns would be nice here
11:04:21 <athan> monochrom: Will do!
11:04:26 <athan> thank you :)
11:04:47 <monochrom> however, you are not wrong to say that if-then-else with a suite of predicates and selectors has equivalent expressive power
11:05:05 <athan> dwcook: So you can freely choose pattern matching / case statements for concrete sum types though, right?
11:05:06 <dwcook> If I had first-class patterns, I could write a function to turn any pattern into a predicate. Since I don't, I'd have to write the predicates by hand.
11:05:19 <dwcook> athan, I don't know what you mean.
11:05:28 <athan> ie
11:05:34 <athan> data Foo = Bar | Baz
11:05:39 <Jafet> Or a suitable functional encoding
11:05:48 <athan> fooMatch Bar = 4
11:05:48 <Jafet> applybot: term sum_case
11:05:49 <applybot>  "sum_case" ∷ "('a => 'b) => ('c => 'b) => 'a + 'c => 'b"
11:05:55 <athan> fooMatch Baz = 5
11:06:16 <athan> fooIf x = if (x == Bar) then 4 else 5
11:06:26 <athan> there just isn't total coverage or something...
11:06:33 <athan> hmm, this is a very interesting topic
11:07:00 <aphury> Hey there. I guess this questions was asked many times before .. .so I’m just another lost soul within the cabal hell: I’ve downloaded the Haskell Platform for MacOS X and tried a „cabal install cabal-install“ which fails with some problems about the „HTML-4000.2.4“ Package. Does anyone know how to come around this?
11:07:05 <Jafet> applybot: term Abs_sum term Rep_sum
11:07:08 <applybot>  Abs_sum ∷ "('a => 'b => bool => bool) => 'a + 'b"  \  Rep_sum ∷ "'a + 'b => 'a => 'b => bool => bool"
11:07:16 <athan> dwcook: Is a predicate the if-statement's test?
11:07:22 <monochrom> yes
11:07:36 <Dongyancai> athan: thank you, it seems to be working now. though I cannot convert it to list directly using getElems, now I use ! operator to access.
11:07:37 <monochrom> a predicate has a type like X -> Bool
11:07:38 <athan> ahh okay
11:07:46 <monochrom> @type isNothing
11:07:47 <dwcook> athan, you can't, in general, replace pattern matching with testing for equality against a constructor
11:07:48 <lambdabot> Maybe a -> Bool
11:07:54 <monochrom> therefore isNothing is a predicate
11:08:00 <athan> Dongyancai: I'm happy you got something working! Cheers!
11:08:16 <dwcook> @type \xs -> if xs == [] then True else False
11:08:18 <lambdabot> Eq t => [t] -> Bool
11:08:21 <mietek> What's a modern XML parsing library?
11:08:25 <dwcook> @type \xs -> case xs of [] -> True ; _ -> False
11:08:26 <lambdabot> [t] -> Bool
11:08:36 <dwcook> athan, notice how the former incurs an extra restriction
11:08:51 <athan> dwcook: Because predicates have more of a complete view of the data, ie values passed must be concrete, while pattern matching can deconstruct complex, rich types, correct?
11:09:06 <dwcook> That's another reason, yes
11:09:10 <Jafet> I'm still waiting for if..then..else to be removed from the language
11:09:24 <athan> ahh I see!
11:09:37 <athan> predicates need full scope of the details?
11:09:40 <jle`> there are times when i have found if/then/else useful
11:09:57 <dwcook> athan, that question is too vague for me to know how to answer it
11:10:02 <athan> sorry haha
11:10:11 <athan> I think I am on the right track though. Thank you for your help
11:10:17 <monochrom> sometimes, you can safely answer "yes"
11:10:17 <Jafet> Or at least, not require "then" to be indented.
11:10:18 <ReinH> mietek: XML or HTML?
11:10:25 <athan> monochrom: hahaha
11:10:35 <mietek> ReinH: XML.
11:10:47 <monochrom> Haskell 2010 already does not require "then" to be indented
11:11:17 <jle`> the then being indented makes if x then y else z kind of like case x of True -> y; _ -> z
11:11:36 <ReinH> mietek: Maybe HXT? http://www.haskell.org/haskellwiki/HXT
11:11:37 <monochrom> http://lpaste.net/81623 has examples
11:11:54 <ReinH> or maybe just xml, depending on your needs
11:11:59 <ReinH> @hackage xml
11:11:59 <lambdabot> http://hackage.haskell.org/package/xml
11:12:15 <int-e> carter: http://hackage.haskell.org/package/HTTP-4000.2.4 ... had no upper bound on network, and network-2.5 changes some function's type (I forgot which)
11:12:22 <ReinH> mietek: conduit-xml might be interesting too http://www.yesodweb.com/book/xml
11:12:24 <carter> oh
11:12:28 <carter> so broke in HEAD
11:12:29 <carter> ?
11:12:30 <Jafet> jle: if I wanted my code to lean like a case-expression... I would write a case-expression.
11:12:37 <Noldorin> why does [a] as a monad concat the result whereas [a] as an applicative does not? i.e. (\x -> [x,-x]) <$> [3,4,5]   vs   (\x -> [x,-x]) =<< [3,4,5]
11:12:54 <ReinH> Noldorin: <$> is fmap
11:12:56 <jle`> Noldorin: that's fmap
11:13:00 <mietek> ReinH: fast and maintained would be nice
11:13:07 <Noldorin> ReinH, jle` , point being?
11:13:09 <Noldorin> I know that
11:13:16 <mietek> ReinH: I was looking at hexpat, but it looks a bit overgrown
11:13:25 <ReinH> mietek: http://hackage.haskell.org/package/xml-conduit
11:13:26 <jle`> applicative/functor does not know how to "flatten" a structure
11:13:29 <carter> fmap should preserver the elemtns
11:13:35 <shachaf> Noldorin: You're using different functions. Why should they behave the same way?
11:13:39 <carter> monads have join
11:13:43 <carter> which is a merge / flatten
11:13:44 <ReinH> mietek: last update March 27 2014 and it's Snoyman so you know it's quality
11:13:44 <carter> :t join
11:13:46 <lambdabot> Monad m => m (m a) -> m a
11:13:51 <Noldorin> schlumpi, because a monad is just an applicative functor + extra functionality
11:13:57 <carter> applicative doesn't have join
11:13:58 <jle`> :t fmap
11:13:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:14:02 <Noldorin> and these are equivalent operations afaik
11:14:04 <ReinH> Noldorin: fmap and >>= do different things
11:14:05 <carter> nope
11:14:12 <shachaf> Noldorin: So use the same function: (\x -> [x,-x]) `liftM` [3,4,5]
11:14:12 <carter> fmap is "pointwise"
11:14:18 <monochrom> fmap and >>= are not equivalent
11:14:21 <Noldorin> ReinH, what's the applicative equivlaent then?
11:14:27 <Noldorin> shachaf, aha
11:14:29 <ReinH> Noldorin: the "extra functionality" is join, which takes [[a]] -> [a]
11:14:31 <monochrom> even liftM and >>= are not equivalent
11:14:32 <carter> yes
11:14:40 <int-e> carter: With a plain ghc-7.6.3 installation, the build plan cabal-install comes up with installs network-2.5.0.0 and HTTP-4000.2.4, which fails. In ghc-7.8.2 the Cabal library is up to date and everything works fine.
11:14:52 <shachaf> Noldorin: There is no Applicative equivalent to (>>=). That is the "extra functionality".
11:14:56 <ReinH> Noldorin: applicative can't join, so it can't concat
11:14:57 <carter> glad i'm on my 7.8.2 + custom patches
11:15:03 <int-e> carter: nothing dramatic
11:15:04 <carter> who's on mac and wants a sweet 7.8.2 build ;)
11:15:14 <mietek> carter: what's sweet about it?
11:15:20 <Noldorin> shachaf, ReinH , okay. how about emulating fmap using the monadic operations then?
11:15:21 <int-e> carter: just another dependencies pitfall.
11:15:33 <ReinH> Noldorin: do you know the monad laws?
11:15:43 <Noldorin> ReinH, I know the applicative laws...
11:15:45 <jle`> fmap just applies the function to every list, so [3,4,5] becomes [(\x -> [x,-x]) 3, (\x -> [x,-x]) 4, (\x -> [x,-x]) 5]
11:15:49 <jle`> @src liftM
11:15:49 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:15:50 <ReinH> Noldorin: go look up the monad laws :)
11:15:51 <monochrom> fmap f x = x >>= return . f
11:15:51 <jle`> there ya go
11:16:08 <shachaf> Noldorin: I don't think your question has anything to do with lists.
11:16:13 <carter> mietek: the RTS is built with GCC, static linked gmp so that binaries are easy to share (ie don't require having gmp installed on the users machine), AND can use either clang or gcc for CPP (unlike the current 7.8.2 release)
11:16:13 <ReinH> Noldorin: specifically http://en.wikipedia.org/wiki/Monad_(functional_programming)#fmap_and_join
11:16:23 <int-e> But perhaps some hackage admin could add a 2.5 upper bound on Network to http://hackage.haskell.org/package/HTTP-4000.2.4?
11:16:23 <monochrom> ≠ x >>= f
11:16:27 <athan> wtf Trac. Trac won't let me register because it thinks I'm a spam bot... even though I answered it's question correctly haha
11:16:31 <Jafet> fmap = liftM
11:16:31 <jle`> @undo do { x <- m1; return (f x1) }
11:16:32 <lambdabot> m1 >>= \ x -> return (f x1)
11:16:44 <int-e> (that is, the underlying .cabal file)
11:16:45 <carter> mietek: when you build GHC with clang, certain state has to use thread local storage, which is slower on mac currently
11:16:54 <Noldorin> ReinH, ah that's helpful. thanks. I guess I was thinking it woudl be more consistent for monad to be defined in those terms
11:16:54 <carter> average 20% perf drop i think
11:16:58 <monochrom> jle`, you have a typo, x vs x1
11:17:00 <mietek> carter: ah, so that was the slowdown mentioned in the release notes?
11:17:07 <jle`> monochrom: thanks
11:17:10 <jle`> >.<
11:17:11 <ReinH> Noldorin: Consistent with one point of view, perhaps
11:17:18 <jle`> @undo do { x1 <- m1; return (f x1) }
11:17:19 <lambdabot> m1 >>= \ x1 -> return (f x1)
11:17:24 <Noldorin> ReinH, consistent with Applicative and Functor typeclasses
11:17:35 <ReinH> Noldorin: I personally do like the fmap, join, return definition of a monad
11:17:46 <dwcook> @. @pl @undo do { x1 <- m1; return (f x1) }
11:17:46 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
11:17:51 <monochrom> Functor+Applicative does not give you Monad. you're missing either >>= or join.
11:17:54 <ReinH> Noldorin: but defining in terms of >>= is consistent with their most common use case (do notation)
11:17:58 <jle`> dwcook: heh
11:18:00 <jle`> try the infix
11:18:04 <Noldorin> monochrom, you misunderstand. no-one was claiming that
11:18:08 <jle`> (@pl . @undo)
11:18:08 <monochrom> ok good
11:18:16 <geekosaur> @. pl undo do { x1 <- m1; return (f x1) }
11:18:16 <lambdabot> f `fmap` m1
11:18:19 <ReinH> Noldorin: so it depends on what you value
11:18:29 <jle`> oh that actaully works :|
11:18:35 <Noldorin> ReinH, fair enough.
11:18:36 <monochrom> they based Monad on >>= because I liked it that way.
11:18:40 <ReinH> Noldorin: I definitely think that examining monads using the fmap, return, join construction is educational
11:18:41 <carter> mietek: "On OS X 10.7 and beyond, with default build settings, the runtime system currently suffers from a fairly large (approx. 30%) performance regression in the parallel garbage collector when using -threaded."
11:18:41 <carter> yup
11:18:45 <dwcook> @. pl undo do { x1 <- m1; return (f x1) }
11:18:45 <S11001001> Applicatives are grey things, Monads are elephants
11:18:45 <lambdabot> f `fmap` m1
11:18:56 <ReinH> Noldorin: that's also the category theory definition
11:18:57 <carter> mietek: my build solves that compat issue
11:19:01 <carter> you can use it with clang
11:19:01 <mietek> carter: interesting. Are you on github?
11:19:06 <Noldorin> ReinH, yeah. I appreciate both motivations now. personally I'm with you. from a theoretical perspective I think fmap + join is nicer :)
11:19:14 <Noldorin> ReinH, but yeah "practically"...
11:19:15 <carter> mietek: no, you want my bindist
11:19:17 <carter> :)
11:19:23 <jle`> i like the (>=>) formulation
11:19:28 <jle`> (just to be different)
11:19:32 <dwcook> I like the "burrito" formulation
11:19:44 <mietek> carter: not really, but thanks :)
11:19:49 <jle`> (>=>) & return
11:19:50 <carter> i am on github
11:19:51 <c_wraith> I like burritos for lunch
11:19:53 <carter> but thats not relevent
11:19:58 <ReinH> jle`: I like the Kleisli formulation of the laws
11:20:02 <carter> http://wellposed.com.s3.amazonaws.com/opensource/ghc/ghc-7.8.2%2BcppPatch%2BintreeGMP/ghc-7.8.2-x86_64-apple-darwin.tar.bz2
11:20:04 <mietek> The patches are the interesting part.
11:20:04 <ReinH> jle`: since it shows that they are category laws
11:20:08 <dwcook> Which has nothing to do with Monads, of course. I'm just feeling a bit peckish.
11:20:15 <carter> mietek: the patches are on trac, and slated for 7.8.3
11:20:17 <carter> they're really boring
11:20:18 <ReinH> dwcook: spacesuit burrito
11:20:21 <mietek> Ah.
11:20:22 <carter> mostly just cleaning up the build system
11:20:23 <jle`> they have the best formulation of the laws
11:20:37 <jle`> but thinking about monads as arrows might be illuminating in their usage as well
11:20:37 <ReinH> jle`: everything else follows from the category laws :)
11:20:43 <ReinH> monads, monoids, etc
11:20:53 <ReinH> well, especially since monads are monoids
11:21:14 <monochrom> an Indian eatery advertises its invention: curritos. it means curry burritos. that's Applicative right there for you.
11:21:27 <c_wraith> I'd eat a currito
11:21:30 <jle`> well their monoidness over (>=>) and return and over fmap and join are wholly different, right?
11:21:30 <dwcook> monochrom++
11:21:33 <ReinH> jle`: monads are arrows in the CT construction. They are functors, which are arrows between categories. :p
11:21:43 <carter> jle`: arrows won't help :)
11:21:45 <ReinH> monochrom: heh well played :)
11:21:49 <carter> at least haskell style arrows
11:21:54 <ReinH> monochrom: lax curried burritos
11:22:12 <ReinH> carter: not Arrow, good god
11:22:16 <jle`> carter: heh yeah, meant the equivalent of Category in haskell terms
11:22:17 <ReinH> :p
11:22:52 <monochrom> have you all seen my latest I/O tutorial? http://www.vex.net/~trebla/haskell/IO.xhtml
11:22:52 <carter> most fancy haskell code needs a tuple of names (REAL MATH TERM, HASKELL LIB TERM)
11:23:00 <ReinH> monochrom: no but I'm sure it's awesome
11:23:07 <jle`> carter: i like differentiating them using capital letters
11:23:12 <ReinH> carter: often the former is the latter
11:23:12 <jle`> monoid vs Monoid
11:23:24 <ReinH> carter: at least in edwardk libraries
11:23:25 <monochrom> and my monad tutorial? the best and the shortest monad tutorial ever! http://www.vex.net/~trebla/haskell/Monad.xhtml
11:24:13 <c_wraith> monochrom: interact is also both lazy IO and in the prelude
11:24:13 <ReinH> heh
11:24:23 <ReinH> monochrom: RTFP?
11:24:49 <monochrom> yeah I think I may have to add interact to the name list. but interact is very strange.
11:25:05 <monochrom> well, I'll deliberate over it for a week :)
11:25:16 <jle`> deliberate
11:25:25 <jle`> what an interesting word
11:25:43 <Jafet> deliexalt
11:25:55 <monochrom> well, as in, the jury deliberates for several days
11:25:59 <c_wraith> Jafet llikes his deli
11:26:01 <jle`> its adjective and verb forms are pronunced differently
11:26:07 <jle`> and mean different things
11:26:09 <jle`> yet
11:26:11 <jle`> are close enough
11:26:26 <jle`> to make it eerie.
11:27:38 <ReinH> jle`: english is weird
11:27:39 <neumond> is there any good tutorial for making mutable values?
11:28:06 <jle`> neumond: depends on what you want, but the documentation of IORef is pretty thorough
11:28:19 <mmachenry> neumond: Share mutable values in concurrent programs or State in a program for imperative programming?
11:28:38 <orbital_> have many people done the NICTA course? Would be interesting to compare solutions, but I cannot find any.
11:28:41 <jle`> oh yeah :|
11:28:41 <neumond> State
11:29:01 <mmachenry> RealWorld Haskell has a nice champter on state.
11:29:09 <neumond> I have gtk callback where I need store state
11:29:38 <ReinH> mmachenry: for concurrency, read Simon Marlow's Parallel and Concurrent Haskell
11:29:45 <ReinH> er
11:29:46 <ReinH> neumond: ^^
11:29:55 <neumond> thx :)
11:30:22 <ReinH> neumond: If your gtk lib is heavily bound to IO you might need to use an IORef :/
11:31:10 <neumond> look like it is
11:33:53 * hackagebot language-ecmascript 0.16.2 - JavaScript parser and pretty-printer library  http://hackage.haskell.org/package/language-ecmascript-0.16.2 (AndreyChudnov)
11:37:30 <yoeight_> Hi, what I'm doing wrong here please, OverleadedLists on
11:37:40 <yoeight_> test :: M.Map String Int
11:37:40 <yoeight_> test = [("1", 1), ("2", 2)]
11:37:51 <yoeight_>     Couldn't match type ‘GHC.Exts.Item (M.Map String Int)’
11:37:51 <yoeight_>                   with ‘(t0, t1)’
11:37:51 <yoeight_>     The type variables ‘t0’, ‘t1’ are ambiguous
11:37:51 <yoeight_>     Expected type: Int -> [(t0, t1)] -> M.Map String Int
11:37:51 <yoeight_>       Actual type: Int
11:37:52 <yoeight_>                    -> [GHC.Exts.Item (M.Map String Int)] -> M.Map String Int
11:37:54 <yoeight_>     In the expression: [("1", 1), ("2", 2)]
11:37:56 <yoeight_>     In an equation for ‘test’: test = [("1", 1), ("2", 2)]
11:37:59 <jakex_> :(
11:38:22 <yoeight_> because I don't understand the error message
11:38:29 <davidthomas> yoeight_: try it with unleaded lists :-P
11:38:39 <davidthomas> (... sorry)
11:38:52 <dwcook> yoeight_, it doesn't know the type of your "1" and 1
11:38:56 <dwcook> Or, no
11:38:58 <dwcook> I'm confused
11:39:04 <supki> yoeight_: does M.Map have the IsList instance?
11:40:33 <yoeight_> supki: yes because error message knows I want a Map and doesn't complain about it
11:40:49 <yoeight_> according to https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists, this is supposed to work
11:41:01 <yoeight_> unless I'm missing something
11:41:52 <S11001001> yoeight_: there was a thread on cafe about this very recently.
11:42:25 <dwcook> yoeight_, you don't know that from what the compiler tells you.
11:43:03 <yoeight_> dwcook: Yes, I do
11:43:31 <yoeight_> dwcook: otherwise I would have Map doesn't have IsList instances
11:43:32 <S11001001> yoeight_: http://www.haskell.org/pipermail/haskell-cafe/2014-April/113625.html
11:43:46 <yoeight_> S11001001: thanks
11:44:44 <yoeight_> S11001001: Why the compiler doesn't complaint about a missing Instance then ?
11:44:58 <yoeight_> S11001001: like OverloadedStrings
11:45:40 <linman24> hi. i'm getting a build error w/ lens-4.1.2. ExitFailure 139
11:45:44 <linman24> anyone know what that might be?
11:46:09 <bitemyapp> does anyone know what's new in Cabal 1.20?
11:46:16 <dwcook> yoeight_, that's not correct. It doesn't even know to look for an instance of IsList yet since it can't match those types.
11:46:31 <supki> linman24: a segfault
11:46:34 <dwcook> yoeight_, change Map String Int to something that definitely doesn't have an instance and the error message will be the same.
11:46:48 <supki> linman24: which is caused by OOM probably
11:47:57 <linman24> supki: thanks. RAM or HDD?
11:48:08 <yoeight_> dwcook: So I can infer that it has to match ‘GHC.Exts.Item (M.Map String Int) but doesn't know what IsList instance it has to lookup ?
11:48:15 <yoeight_> s/I/it
11:49:07 <supki> linman24: RAM
11:50:22 <dwcook> yoeight_, I suggest looking at the type of the expression [("1", 1), ("2", 2)]
11:50:29 <yoeight_> dwcook: anyway, you were right
11:50:37 <dwcook> Notice the constraint: GHC.Exts.Item l ~ ([Char], t)
11:51:11 <yoeight_> dwcook: I don't have that constraint in the error
11:51:29 <dwcook> yoeight_, on the previous line I suggested looking at the type of an expression.
11:51:29 <athan> this is probably a weird question... but, could you make a simple list sorting function run forever if there were some strictness annotations, because ([] < xs), and the result would append a new []?
11:51:36 <linman24> supki: just tried running it again. looks like i didn't even hit 2gb ram during fail
11:51:46 <linman24> supki: i'm supposed to have 8gb
11:51:53 <yoeight_> dwcook: I understand your point
11:51:55 <linman24> supki: so it shouldn't be running out of mem
11:52:01 <dwcook> yoeight_, in `ghci -XOverloadedLists` enter: :t [("1", 1), ("2", 2)]
11:52:27 <yoeight_> dwcook: we basically have the kind of error with Int :: String
11:52:56 <dwcook> That's one way to put it
11:53:02 <dwcook> You can't satisfy the constraint since the types don't unify
11:53:22 <dwcook> (I've never actually used OverloadedLists so I don't know what you actually need to do)
11:53:29 <yoeight_> dwcook: Yet 1 :: String is clearer
11:53:50 <dwcook> What do you mean?
11:54:26 <yoeight_> dwcook:  [("1", 1), ("2", 2)] should yield can't match Map String Int actual [(String, Int)]
11:54:31 <dwcook> Actually now I'm confused
11:54:40 <supki> linman24: hmm, could you paste the build log on lpaste or something?
11:55:22 <supki> linman24: another common cause of such weird errors is that template-haskell package is upgraded
11:55:57 <yoeight_> dwcook: Displaying GHC.Exts.Item in the error is confusing if the error is about a missing typeclass
11:56:17 <linman24> supki: http://pastebin.com/qHtmH6dH
11:56:22 <dwcook> yoeight_, sorry, I was confused. Item is a type synonym
11:56:29 <quchen> bitemyapp: I think invoking sandbox-aware GHC will be in 1.20.
11:56:34 <dwcook> So it could unify
11:56:39 <yoeight_> a inner type familly actually
11:57:55 <yoeight_> dwcook: you were right on the cause, not the explanation :-)
11:58:34 <supki> linman24: what does  ghc-pkg list template-haskell  list?
11:58:40 <yoeight_> dwcook: I was completely wrong :-)
12:00:00 <linman24> supki: http://pastebin.com/v2tz90eC
12:01:04 <supki> linman24: ok, that's bad
12:01:16 <bitemyapp> quchen: sorry, invoking sandbox-aware GHC?
12:01:18 <supki> linman24: you'll need to unregister th-2.8.0.0
12:02:04 <linman24> supki: ok. how do i do that? i have never used haskell before..
12:02:30 <supki> linman24: ghc-pkg unregister template-haskell-2.8.0.0
12:02:42 <supki> linman24: that will probably break some packages
12:03:04 <supki> linman24: you'll need to reinstall them with the template-haskell-2.7.0.0 then
12:03:13 <joelteon> you can't reinstall TH...
12:05:04 <geekosaur> you misunderstood, the idea is to reinstall packages built against the wrong template haskell. not reinstall template-haskell
12:05:24 <linman24> supki: http://pastebin.com/6hXVQgRJ
12:05:30 <quchen> bitemyapp: Are you familiar with Cabal sandboxes?
12:05:56 <linman24> supki: how should i handle that?
12:06:28 <geekosaur> linman24, remove it, reinstall those packages with --constraint='template-haskell installed'
12:07:11 <geekosaur> those packages are already broken because you can only use the template haskell that came with ghc
12:07:23 <geekosaur> (the one in the global part of the package list)
12:08:24 <bitemyapp> quchen: yeah
12:08:26 <quchen> bitemyapp: To make GHC use your sandbox right now, you need to (very) explicitly provide it as a parameter, like `ghc -no-user-package-db -package-db $(shell find .cabal-sandbox/ -name "*packages.conf.d")`, or something along those lines. That sort of script is very hacky though. Cabal 1.20, if I recall correctly, will allow you to run GHC without all the noise, yet aware of the sandbox.
12:08:50 <bitemyapp> quchen: oh, with a prefix like `cabal ghc` or some such?
12:08:53 <bitemyapp> quchen: that would be really nice
12:09:00 <bitemyapp> I've had to do the -package-db thing.
12:09:02 <bitemyapp> annoying.
12:09:29 <quchen> There was a blog post about this a couple of weeks ago, let's see whether I can find it again.
12:10:34 <quchen> Hmm, that may have been it: https://mappend.net/posts/ghc-and-cabal-sandbox-playing-ni
12:10:42 <quchen> But it's not as detailed as I remember.
12:11:43 <quchen> This one also talks about the issue briefly. http://ro-che.info/articles/2014-03-05-cabal-sandbox-tips.html
12:13:58 * hackagebot quantities 0.3.0 - Unit conversion and manipulation library.  http://hackage.haskell.org/package/quantities-0.3.0 (jdreaver)
12:21:20 <linman24> geekosaur: i unregistered the packages. how do i install again?
12:23:49 <athan> is there a way to query lambdabot for the instance of a particular class/data type pair, if any?
12:24:26 <dwcook> athan, pair of what?
12:25:17 <n-dolio> @src [] return
12:25:18 <lambdabot> return x    = [x]
12:25:32 <geekosaur> for each package: cabal install packagename --constraint="template-haskell installed"
12:27:02 <n-dolio> @src IO (>>=)
12:27:03 <lambdabot> m >>= k     = bindIO m k
12:27:34 <dwcook> Is there a proposal that might allow GHC to disambiguate between two bindings of the same name when their types could be distinguished unambiguously?
12:28:03 <n-dolio> There exists a proposal for that.
12:28:11 <dwcook> Where?
12:28:13 <geekosaur> http://www.haskell.org/haskellwiki/TypeDirectedNameResolution ?
12:28:16 <n-dolio> Hopefully no one ever implements it.
12:28:21 <bennofs> dwcook: for record fields, there is an extension
12:28:32 <athan> dwcook: not (,), but say something like @query Maybe Monad, and it gives you the instance
12:28:38 <bennofs> dwcook: DisambiguateRecordFields, or smth like that
12:28:48 <benmachine> TDNR feels like a bad idea
12:28:58 <dwcook> That seems to be what I'm talking about
12:29:03 <prophile> @hoogle (Monad m) => (a -> a -> m Ordering) -> [a] -> m [a]
12:29:03 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
12:29:03 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
12:29:04 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
12:29:15 <dwcook> athan, see n-dolio's examples
12:29:17 <prophile> ah well
12:29:30 <n-dolio> @src Maybe (>>=)
12:29:30 <lambdabot> (Just x) >>= k      = k x
12:29:30 <lambdabot> Nothing  >>= _      = Nothing
12:29:31 <athan> oh! Sorry, I didn't see! thank you!
12:29:43 <athan> thank you n-dolio :)
12:30:03 <benmachine> lambdabot's @src is sometimes lies
12:30:05 <benmachine> fyi
12:30:10 <athan> I had a feeling
12:30:14 <benmachine> it's just a text file somewhere
12:30:23 <benmachine> it doesn't... mean anything, as such
12:30:35 <athan> hmm
12:30:41 <n-dolio> Yeah. Some of it is from the Haskell report. Some is from base or other libraries.
12:30:42 <athan> @src [] ==
12:30:43 <lambdabot> Source not found. Abort, Retry, Panic?
12:30:45 <athan> :(
12:30:55 <n-dolio> @src [] (==)
12:30:56 <lambdabot> []     == []     = True
12:30:56 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
12:30:56 <lambdabot> _      == _        = False
12:30:59 <athan> ><
12:31:01 <athan> thank you
12:31:09 <n-dolio> @src sort
12:31:10 <lambdabot> sort = sortBy compare
12:31:14 <n-dolio> @src sortBy
12:31:14 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
12:31:23 <athan> :D
12:31:46 <n-dolio> That one's from the Haskell report.
12:31:55 <n-dolio> But it's obviously not that in base.
12:32:22 <glosoli> "The community is much smaller than that of other functional programming groups and key attendees of Haskell meet-ups are very well known to each other." would you think this could be said about Haskell.. ?
12:32:42 <bitemyapp> anybody else wish ghci could pull the source for a function?
12:33:29 <orbital_> bitemyapp: mememe
12:33:46 <dwcook> n-dolio, benmachine, why do you think TDNR is a bad idea?
12:33:55 <athan> n-dolio: Why wouldn't it be??
12:33:59 <athan> hm
12:34:06 <n-dolio> Because it's the worst solution that's just barely good enough to stop people from complaining.
12:34:16 <athan> hahaha
12:34:23 <bitemyapp> orbital_: you could just patch ghci you know.
12:34:27 <bitemyapp> orbital_: might be a good learning experience.
12:34:37 <orbital_> whoa.
12:34:48 <benmachine> dwcook: it seems overcomplicated
12:35:05 <n-dolio> There used to be a way that you could run ghci with an interactive lambdabot for extra functionality.
12:35:09 <athan> n-dolio: What makes it the worst implementation? The fold?
12:35:12 <n-dolio> I imagine it's bit rotted at this point, though.
12:35:14 <benmachine> and edge-casey
12:35:18 <athan> hmm
12:35:19 <n-dolio> athan: That definition is insertion sort.
12:35:24 <athan> :/
12:35:25 <bennofs> bitemyapp: ghci is actually not that complicated (you can even write a ghci program outside of the ghc source code, for example the ghci-ng cabal package on hackage)
12:35:29 <athan> I need more programming bg
12:35:30 <Jafet> bitemyapp: :list
12:35:35 <n-dolio> I was talking about TDNR, though.
12:35:38 <athan> thank you n-dolio
12:35:40 <athan> tdnr?
12:36:06 <benmachine> athan: type directed name resolution
12:36:48 <Rc43> Who can say what is category with _finite_ products?
12:36:49 <Rc43> Here (http://nlab.mathforge.org/nlab/show/product) is described finite product for Set category, what is in general case?
12:36:50 <bitemyapp> orbital_: yep, :list does what you want.
12:36:57 <athan> Thank you benmachine. I'll have to catch another convorsation once I'm tempered.
12:37:09 <bitemyapp> orbital_: ghc has all the toys :P
12:37:15 <Jafet> TDNR is great. Even better is syntax resolution. Nothing like waiting an exponential time to parse terms.
12:37:47 <orbital_> Jafet bitemyapp: oh, far out
12:37:56 <orbital_> thanks :)
12:37:58 <bitemyapp> Jafet: thank you :)
12:39:04 <bitemyapp> Jafet: I don't know if I like TDNR for its own sake.
12:40:01 <athan> there's no list instance for Ord, is there
12:40:09 <n-dolio> There is.
12:40:16 <athan> :S
12:40:27 <n-dolio> > [2] < [3]
12:40:29 <lambdabot>  True
12:40:32 <benmachine> athan: the elements have to also be Ord
12:40:38 <athan> n-dolio: Can you direct me to the source
12:40:39 <athan> ?
12:41:01 <athan> how do you compare [] to _? Always less-than?
12:41:21 <bitemyapp> > [] < [3]
12:41:22 <lambdabot>  True
12:41:36 <benmachine> athan: less than or equal to, yeah
12:41:37 <n-dolio> It's lexicographic.
12:41:39 <athan> So two lists of the same length delegate to their elements, while a shorter list will always be comparably less than another?
12:41:48 <benmachine> no
12:41:52 <athan> hmm
12:41:56 <jakex_> [1,2,3] < [10]
12:41:57 <bitemyapp> > [1] < [1, 2]
12:41:59 <lambdabot>  True
12:41:59 <jakex_> > [1,2,3] < [10]
12:42:01 <lambdabot>  True
12:42:03 <athan> lol
12:42:09 <Jafet> Try reading a dictionary or phone book.
12:42:11 <athan> monoid?
12:42:46 <bitemyapp> There needs to be an Animaniacs introduction to the typeclasses
12:42:49 <jakex_> mongloid
12:42:54 <benmachine> athan: try writing a comparison function on lists yourself
12:43:00 <bitemyapp> like the one that names all of the countries of the world.
12:43:06 <athan> benmachine: That's why I came here :)
12:43:39 <benmachine> I think there's one thing that's more obvious than any other thing to do
12:43:42 <athan> does the default implementation progress through each element or something? Is the source for the instance available?
12:44:02 * hackagebot hledger-web 0.22.5 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.22.5 (SimonMichael)
12:44:11 <benmachine> athan: writing it yourself is probably easier than finding the source, to be honest :P
12:44:35 <grogger> when scraping a web page should I use Text or String?
12:44:39 <athan> D:)dunce>
12:44:47 <Jafet> You should use ByteString.
12:45:09 <bitemyapp> grogger: you should use lists of ASCII chars represented by ints.
12:45:30 <grogger> hmm what?
12:45:39 <grogger> I want to handle unicode
12:45:40 <bitemyapp> grogger: sorry, kidding :)
12:45:42 <benmachine> grogger: that depends on whether or not you expect to be able to "trust" the webpage
12:45:42 <athan> benmachine: Okay will do. I have a feeling it works element-by-element progressively until an edge case of [] arises
12:45:44 <grogger> :)
12:46:02 <benmachine> athan: right (but I'd say base case, rather than edge case, it's not exactly uncommon)
12:46:08 <grogger> I already did it with String so I am wondering if switching to Text is likely to speed things up
12:46:26 <Jafet> If you want to handle unicode, you should use ByteString. You can then attempt to convert to Text.
12:46:31 <athan> benmachine: Good point. Delimiting case? :P
12:46:35 <benmachine> grogger: switching from String to Text probably won't make things worse, and might make them much better
12:47:35 <Ywen> Hello! I'm trying to build haskell-src-exts, but v1.14.0.1 (the one
12:47:35 <Ywen>   GHCJS depends on) cannot build because of this: http://pastebin.com/UCJ69KNQ . Any chance someone has used this version of haskell-src-exts?
12:47:42 <aviraldg> I was hoping for inline documentation / parameter information at least :P
12:47:46 <aviraldg> oops
12:47:58 <aviraldg> *ignore, sorry
12:48:02 <benmachine> grogger: it's better if you can ensure that it actually comes in as Text, avoid string conversions if possible
12:48:37 <Ywen> The big error seems to be at line 38 of the pastebin
12:49:05 <benmachine> Ywen: hmm. I've not tried installing it on 7.8 yet, but my first guess would be try upgrading happy
12:49:09 <benmachine> cabal update; cabal install happy
12:49:22 <Ywen> benmachine: thx, I'm trying that
12:49:59 <Ywen> benmachine: I'm using ghc 7.8 because ghcjs specifically tells to
12:51:08 <[swift]> has anyone else seen an issue in emacs where the help text for haskell-mode-hook keeps popping up?
12:51:15 <benmachine> Ywen: right, sensible thing to do in general, but it was released like a handful of days ago, so there may be sharp edges still
12:51:31 <[swift]> i suspect an interaction between haskell-mode and evil. it's weird, though - this didn't start happening until just recently
12:52:00 <dmj`> swift: did you just install it? ootb haskell-mode doesn't specify an indentation level you need to to that in your emacs file
12:52:06 <dmj`> to do*
12:52:18 <Ywen> benmachine: released? I don't see a release, I cloned & built from the git repo
12:52:37 <[swift]> dmj`: i didn't just install it, but it's possible i busted my configuration by accident somehow. i'll check on that
12:53:11 <dmj`> swift: do you have an indentation level specified?
12:53:36 <[swift]> dmj`: actually i don't i think i do, unless you mean an indentation mode, but i think that's not what you mean
12:53:47 <benmachine> Ywen: sure, 7.8.2 is out
12:53:55 <benmachine> Ywen: so new it might not be in repositories yet
12:54:11 <Ywen> benmachine: Oh, I thought you meant the GHC*JS* release
12:54:12 <[swift]> dmj`: just to be sure, how i would i specify that? i have this: (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
12:54:14 <benmachine> oh, no
12:54:41 <[swift]> that's actually about it
12:54:42 <aviraldg> How would you rewrite: get16 :: IO [[Int]]
12:54:42 <aviraldg> get16 = do
12:54:42 <aviraldg> 	m <- sequence $ replicate 4 getLine
12:54:42 <aviraldg> 	return $ map (map read . words) m
12:54:43 <aviraldg> ?
12:54:56 <solarus> [swift]: you could also do M-x customize-variable RET haskell-mode-hook RET and specify things from there
12:54:58 <angerman> is using IORef or generally mutable state frowned up in haskell with UIs?
12:55:28 <[swift]> solarus: ah nice. i never used customize-variable for hooks before; didn't realize that was possible
12:56:00 <aviraldg> (if at all?)
12:56:05 <athan> is there a reference for exitfailure codes? I can't seem to find one on google
12:56:52 <Jafet> angerman: it is frowned upon, and people will wag their fingers at you and tut
12:57:08 <geekosaur> most of the time they don't mean much of anything
12:57:20 <[swift]> athan: it's sort of freeform but google sysexits.h
12:57:31 <Jafet> @src replicateM
12:57:32 <lambdabot> replicateM n x = sequence (replicate n x)
12:57:50 <geekosaur> that's only useful for a limited subset of exit codes, and even then only for certain kinds of services
12:58:01 <geekosaur> (it was originally developed for sendmail)
12:58:21 <joelteon> yeah, it's pretty much just "failure, and this is the number they associated with it"
12:58:41 <[swift]> geekosaur: right, but it's the closest thing to a set of "standard" exit codes i know of
12:58:59 <aviraldg> Jafet, ah! Anything else?
12:58:59 <Ptival> hello, I have a Happy problem, explained briefly here http://paste.awesom.eu/Ig8L
12:59:04 <athan> [swift]: Thank you :)
12:59:24 <angerman> Jafet: ok, how would the following be handled usually? Say we have a Record x that represents some data. Now we want to show a form/view/widget that shows the elements of x with edit boxes, ... when the editing is done, we somehow need to mutate x to contain the updated information from the UI, and return the x'.
12:59:36 <athan> geekosaur: Wow! Interesting history!
12:59:46 <Ywen> benmachine: It worked, thanks ;)
12:59:51 <angerman> Jafet: do you know of a gtk, or xw or vty-ui sample code for that situation?
13:00:04 <athan> I'm guessing > 50 or so are proprietary?
13:00:21 <athan> I'm currently getting an exitfailure 134, and couldn't find anything immediately on google
13:00:40 <[swift]> athan: you should look up what it means for the actual program you're running
13:00:57 <Jafet> I believe all practical UI libraries use IO, so use IORefs, and be finger-wagged
13:01:18 <athan> [swift]: Is there a cabal reference?
13:01:36 <[swift]> athan: you're getting that from cabal itself?
13:01:46 <athan> yes I believe so
13:01:49 <athan> from xml-conduit
13:02:25 <[swift]> is there more to the error that you could paste somewhere?
13:03:00 <angerman> Jafet aye!
13:03:15 <athan> I wish I could see, cabal doesn't normally log anything else than what is printed to the console, right?
13:03:26 <athan> would there be a sandbox log?
13:04:11 <Jafet> :t replicateM 4 $ (map read . words) <$> getLine
13:04:13 <lambdabot> Read b => IO [[b]]
13:04:26 <[swift]> athan: at a minimum you could try "cabal -v <whatever>"
13:04:38 <athan> ahh okay, sorry. Thank you
13:05:44 <zzzzzzzziiii> can cabal tell me which dependency pulls a certain package?
13:05:51 <aviraldg> Jafet, thanks! I'm new -- what does <$> do?
13:06:05 <[swift]> athan: actually i just checked the docs, and you might want to use "-v3". looks like that will give you the maximum amount of debug info
13:06:27 <Jafet> <$> is shorter to type than liftM.
13:06:41 <athan> [swift]: Which docs? I need to add it to my arsenal :)
13:07:26 <[swift]> athan: i actually just typed "cabal install --help" and looked at the list of flags =)
13:09:35 <athan> I have an off-minded question, that isn't completely thought through because of it's difficulty (in my eyes): is it possible to church-encode, or beta/eta convert arrows? (I feel as though graph reduction covers this in system F.. but I honestly have no idea)
13:10:48 <c_wraith> athan: all data types can be church encoded, in one way or another.
13:11:03 <athan> aha! That's exactly the insight I needed! Thank you!
13:13:45 <shachaf> Sort of.
13:18:47 <r4pha> I'm trying to use "let ... in" in a recursive function but it always return an empty list. Can someone please point me where I'm wrong? Code on http://pastebin.com/N6Y48Yzv
13:18:51 <athan> hmm. How can I get cabal to see my custom library that hasn't been published to hackage?
13:19:12 <hexagoxel> zzzzzzzziiii: cabal-db can make diagrams of dependencies. i have no idea if there is a way to get an un-formatted listing
13:21:05 <corgifex> r4pha: http://codepad.org/7Chbmhva
13:22:16 <athan> corgifex: I think drop needs to have "1", the literal, as it's 2nd input
13:22:24 <athan> or really, it should be replaced with tail
13:22:27 <athan> right?
13:22:33 <corgifex> no
13:22:40 <athan> oh wait
13:22:42 <athan> yeah, sorry
13:25:47 <sdf_> Has anyone here played with server-sent events in wai-eventsource?
13:25:53 <r4pha> corgifex: thanks. I added patterns for empty and single-item list on countChar and it works now
13:25:58 <athan> I don't think `cabal sandbox add-source ../../foobar` is properly adding my package
13:28:17 <athan> it's not showing up in dist/dist-sandbox-ef4df87c/build/autogen
13:31:47 <athan> Actually, nevermind, it shows up in .cabal-sandbox/lib/x86_64-linux-ghc-7.6.3/ ...
13:31:48 <athan> hmm
13:33:04 <athan> Does cabal clean the sandbox folder in dist after each build?
13:33:10 <athan> or, sorry
13:33:31 <athan> does "cabal" itself clear the folders in dist?
13:34:01 <athan> ie dist/dist-sandbox-ef4df87c?
13:34:32 <athan> in a failure, does cabal clear the files out?
13:36:31 <athan> The .hi file is in my sandbox folder for my module, but not the .hs file...
13:37:11 <Eduard_Munteanu> athan: why would there be a .hs there?
13:38:05 <athan> I'm not exactly sure how it works...
13:38:15 <kgadek> anyone could recommend some haskell plotting lib? I'm preparing my master thesis, I'll need to plot quite a lot. Or shall I use matplotlib for python? What's the best bet?
13:38:58 <athan> Eduard_Munteanu: I'll try reading the docs, but I think this may be a bug
13:39:27 <athan> cabal isn't seeing the package when I clearly have a .hi file in the sandbox
13:39:44 <Ywen> while I'm at it, has somebody made benchmarks comparing GHCJS & Haste? It seems both are still developed and have close aims (haste aiming apparently at being simpler to install that GHCJS, but given I managed in installing it that won't help them much to tell them apart...)
13:40:24 <athan> Ywen: I think Roy may be interesting to you as well, possibly Fay too.
13:41:13 <Ywen> athan: actually, I believed Fay was on a hiatus, development-wise. And Roy/Elm are different languages (still useful, but fall in a different category, then)
13:41:38 <athan> yeah, good point
13:42:36 <athan> I'm unsure, but I've been wanting to research them
13:43:43 <Ywen> athan: when I went on installing Ghcjs, I believed it subsumed the other Haskell-on-javascript initiatives, but I was wrong as haste is still developped.
13:45:43 <Ywen> ^^ haste fails to install
13:46:17 <athan> Ywen: We'll have to see. I'm currently writing a cross-browser assistive library for yesod right now, hopefully I'll be able to integrate
13:46:51 <athan> so that non-ecma 4/5/6 browsers can be easily evaded and compiled javascript can be more efficient
13:47:10 <athan> but automatically balanced. I just hope it won't be too difficult
13:48:02 <athan> It may be difficult scaling from live-compiling the javascript per-request to caching + cdn hosting for pre-rendered files
13:48:43 <athan> it would be nice to integrate market statistics
13:49:44 <Ywen> athan: and you are planning on getting an integration of server-haskell and client-haskell?
13:50:23 <athan> Yes!
13:50:54 <athan> possibly even make a websockets-based peer-to-peer cluster via distributed-haskell too :)
13:51:01 <athan> or just simple client-server ones
13:51:17 <athan> maybe with scaling complexity for the end-program (and hosting)
13:51:42 <zzzzzzzziiii> thx hexagoxel, cabal-db is awesome :)
13:52:04 <athan> zzzzzzzziiii: cabal-db?? o.O
13:52:26 <zzzzzzzziiii> athan, http://hackage.haskell.org/package/cabal-db
13:53:27 <athan> zzzzzzzziiii: thank you!
13:54:16 * hackagebot http-client-lens 0.1.0 - Optics for http-client  http://hackage.haskell.org/package/http-client-lens-0.1.0 (ReinH)
13:55:11 <Ywen> http-client-lens? looks great!
13:56:47 <johnw> nice, that was something I was thinking about writing too; thanks Reinh!
13:58:24 <Ywen> my, a lens-theme package that _actually_ depends on lens ^^
13:59:16 <shachaf> It doesn't really need to depend on lens, I think.
14:00:04 <ReinH> johnw: I actually cribbed them from supki :)
14:00:33 <ReinH> shachaf: Ok, I just don't use the type synonyms?
14:00:51 <Ywen> ReinH: Don't worry, it's actually better
14:01:09 <ReinH> Ywen: if you say so :)
14:01:21 <shachaf> I don't care.
14:01:33 <ReinH> shachaf: ok :)
14:01:36 <davd> can the recursion-schemes package be used over monads? http://hackage.haskell.org/package/recursion-schemes-4.0/docs/Data-Functor-Foldable.html
14:01:48 <Ywen> when the lib provides a small lensy interface, it can be cool if it doesn't depend on it, even if it makes the types harder to understand
14:02:05 <ReinH> davd: monads are functors.
14:02:12 <Ywen> but the whole point of yours is to be used with lens, so it wouldn't make much sense
14:02:22 <ReinH> Ywen: ok :)
14:02:34 <ion> ywen: It makes the types harder to understand?
14:02:37 <davd> ReinH: sorry, I'm thinking in terms of monadic algebras
14:02:52 <ReinH> davd: monads are monad-algebras. Ok I'll stop now.
14:03:02 <Ywen> ion: lens type are type synonyms, so you're not obliged to depend on lens to provide a lens-friendly API
14:03:10 <ion> ywen: http://hackage.haskell.org/package/quadratic-irrational-0.0.5/docs/Numeric-QuadraticIrrational.html#g:2 does not depend on lens.
14:03:42 <Ywen> ion: it must re-declare the type synonyms somewhere, then
14:03:42 <shachaf> ion: You don't think (Choice p, Applicative f) => p a (f b) -> p s (f t) is harder to understand than Prism s t a b?
14:03:56 <ion> shachaf: I do.
14:04:03 <shachaf> Oh, you define your own lens. OK.
14:04:05 <Ywen> shachaf: ...provided you know what a Prism is
14:04:15 <shachaf> Ywen: And if you don't?
14:04:35 <ion> http://hackage.haskell.org/package/quadratic-irrational-0.0.5/docs/src/Numeric-QuadraticIrrational-Internal-Lens.html isn’t really a pain at all.
14:04:35 <Ywen> well maybe the full type is better. Maybe.
14:04:42 <Ywen> in that case.
14:04:45 <ReinH> ion: true.
14:04:51 <danbst> [Q] hi. How can I load library from source in GHCi? Wanna some hacking, but it is sandboxed
14:05:00 <ReinH> davd: cabal repl
14:05:01 <ReinH> er
14:05:03 <ReinH> danbst: cabal repl
14:05:06 <ReinH> sorry
14:05:15 <Ywen> ion: yes, because as I suspected, it redeclares the type aliases of lens
14:05:26 <shachaf> Good luck figuring out the full type.
14:05:44 <shachaf> Prism is easy to look up (it's one click to the documentation).
14:05:52 <danbst> ReinH: thanks!
14:06:28 <Ywen> ReinH: I haven't checked http-client. Is it usable without a conduit/piping library?
14:06:50 <ion> pinduit/coping
14:07:21 <shachaf> I need a coping library to handle all the ridiculous libraries people write.
14:09:03 <Ywen> it's basically midnight where I am, too late for me for puns like these
14:11:18 <joelteon> :set -X#haskellPuns
14:14:18 * hackagebot QuickCheck-GenT 0.1.2 - A GenT monad transformer for QuickCheck library.  http://hackage.haskell.org/package/QuickCheck-GenT-0.1.2 (NikitaVolkov)
14:16:16 <acomar> so I thought ghc 7.8 was supposed to fix the ghci/linking issue... I'm on 7.8.2 but most definitely bumping into cases where ghc can compile the code fine, but the necessary libraries can't be loaded into ghci
14:17:03 <napping> I thought it was kind of the other way around - that ghci can now use the system dynamic linker, but you have to build everything both ways
14:17:40 <acomar> napping: what do you mean both ways?
14:17:58 <napping> compiled as a shard library, and a plain .o
14:18:35 <acomar> how can I get cabal to build the libraries that way for me?
14:18:50 <carter> acomar: 1) use cabal-install 1.18 or  newer
14:19:01 <acomar> good on that point
14:19:08 <napping> I haven't tried 7.8, just telling you that I read the release notice quite differently
14:19:23 <carter> 2) make usre you don't have an old ~/.cabal/config (delet the one you have if its pre 1.18, cabal update will gen a fresh one)
14:19:26 <acomar> napping: I'm remembering discussions on #haskell from a long while back
14:19:36 <carter> its a good thing that ghci defaults to dynlinking
14:19:38 <carter> now
14:19:41 <carter> many bugs died
14:19:45 <ap1988> what would cause my ~/.cabal/bin to not exist?
14:19:51 <acomar> carter: I created .cabal/config after switching to cabal 1.18 :/
14:19:59 <eiluan> @pf countEven l = length $ filter isEven l
14:19:59 <lambdabot> Maybe you meant: pl bf
14:20:00 <carter> acomar:?
14:20:08 <eiluan> @pl countEven l = length $ filter isEven l
14:20:09 <lambdabot> countEven = length . filter isEven
14:20:10 <carter> ap1988:  you installed haskell platform
14:20:12 <carter> on your mac
14:20:14 <carter> ap1988: thats why
14:20:17 <ap1988> correct
14:20:23 <ReinH> Ywen: sure it works with IO
14:20:26 <acomar> carter: I deleted the file and recreated it when upgrading to 1.18
14:20:28 <ap1988> @carter so where do my cabal binaries install then?
14:20:29 <lambdabot> I was held up about an hour casting feathers on oily water.
14:20:43 <carter> ap1988: 1) cabal update ; cabal install cabal-install ; rm ~/.cabal/config ; cabal install cabal-install
14:20:46 <ap1988> I've just run cabal install yesod, which gives me -bash: yesod: command not found
14:20:52 <carter> ap1988: do that
14:20:53 <ap1988> thank you
14:20:58 <nomeata> Hi. The "snap" binary name is already taken in Debian, and we need to rename it. Any suggestions? snap-manage? snap-tool? snap-create?
14:21:13 <carter> snapweb-init ?
14:21:22 <carter> nomeata: ask on #snapfrewmork
14:21:23 <nomeata> carter: does it only init?
14:21:27 <carter> idk
14:21:27 <nomeata> good idea
14:21:34 <carter> ignore my spelling
14:21:43 <BeardedCoder> ap1988: maybe you need yesod-bin
14:21:54 <carter> ap1988: aosl don't use yesod :P
14:21:57 <carter> i kid
14:23:57 <ap1988> carter any reason why not?
14:24:09 <Ywen> nomeata: why not snap-framework?
14:24:17 <carter> or scotty or happstack
14:24:19 * hackagebot zeromq4-haskell 0.5 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.5 (ToralfWittner)
14:24:25 <carter> oh
14:24:36 <carter> ap1988: i just don't like how they have crazy fragile version constraints
14:24:41 <ap1988> hmm
14:24:43 <nomeata> Ywen: also a good idea, and likely to work well when they add further commands besides init
14:24:45 <nomeata> taken :-)
14:24:48 <skypers> ok, I have something that’ll work but in term of design I really don’t like it
14:24:55 <carter> or snapweb
14:24:58 <ap1988> carter: that's fair. So which web framework would you recommend as the most feature complete?
14:25:23 <carter> ap1988: whats the goal?
14:25:36 <carter> remembber, with most haskell tools you can mix and match the libs
14:25:45 <carter> ap1988: always start with "my goal is X"
14:26:05 <carter> ap1988:  have you used cabal sandboxes before?
14:26:10 <skypers> I have a newtype really simple, newtype ID a = ID Int deriving (a lot of convenient stuff); this type is used to represent the index of a value stored in a Vector. Then when I want to share my object, I use ID. I guess it’s seriously wrong because if the Vector changes, IDs could be violated
14:26:20 <ap1988> carter: my short term goal is to master haskell, my long term goal is to build a "production ready" web application in Haskell
14:26:25 <carter> ok
14:26:27 <ap1988> carter: and no, I have not used cabal sandboxes
14:26:30 <carter> ok
14:26:36 <carter> you should use sandbox for any serious dev
14:26:37 <BeardedCoder> ap1988: sorry incase you didn't get the answer to the cabal question. Check ~/Library/Haskell/bin
14:26:47 <carter> BeardedCoder: got him to fix it
14:26:48 <BeardedCoder> and +1 for sandboxes
14:26:48 <carter> :)
14:26:48 <skypers> the handy stuff with that is that I can manipulate a value, and map the vector: the mapped version is still available with the old index
14:26:53 <BeardedCoder> k
14:26:55 <carter> skypers: whats the goal
14:26:57 <skypers> any idea to a similar approach, but stronger?
14:27:09 <skypers> carter: not to duplicate object (reference semantic)
14:27:12 <carter> skypers: I have newtype Address = Address Int
14:27:27 <fragamus> edwardk: I think I am on to something. I am using Mathematica to take an integral and produce a mathematical expression which can then be resolved numerically. I have code to hoist common sub-expressions and emit haskell.   *I think*  that the integral is the source code. I think that this is a direction the haskell community should be taking
14:27:27 <ap1988> I was about to say, "sounds like RVM for Haskell"
14:27:28 <skypers> it’s kinda pointer yes
14:27:38 <ap1988> then I read the blog post and htat's the comparison they make themselves
14:27:45 <carter> ap1988: not quite
14:27:59 <carter> but close enough
14:28:02 <skypers> carter: I’m really interesting in something stronger
14:28:06 <carter> skypers: why
14:28:15 <skypers> if I use STRef, it’s stronger, but I lose the hability to map
14:28:16 <carter> if you care about object ident, you'd use stablenames
14:28:25 <carter> skypers: whats teh goal
14:28:31 <carter> your'e telling me paths to the goal
14:28:32 <carter> not the goal
14:28:40 <edwardk> fragamus: i have a half-started 'automatic integration' package that uses piecewise padé approximation to compute more or less what mathematica is doing, just more naively
14:29:01 <Clint> ap1988: use happstack if you want to master haskell and are in no hurry to get your webapp finished
14:29:03 <fragamus> edwardk: I am concerned that another language, dominated by a company, has a huge leg up in the symbolic computation area, and that this is fundamental to computation
14:29:06 <edwardk> fragamus: once rounded works fully I can start to dust it off
14:29:16 <skypers> carter: well, the idea is to modelize data that can be embedded in each others; if an embedded data changes, every embedded data of the same “reference” should change
14:29:17 <carter> ap1988: all of happstack and snap and yesod are used
14:29:29 <edwardk> fragamus: Mathematica has a much easier job as it is basically only pushing untyped symbols
14:29:50 <skypers> my newtype ID is quite nice because I can change the implementation, and I think I will, my Vector indexed-base implementation is not that great
14:30:01 <carter> ap1988: if the goal is to learn, try writing some basic stuff in all three
14:30:06 <skypers> (even though it might be performant)
14:30:06 <carter> they're all different styles
14:30:09 <fragamus> I am not sure, but maybe this part of "greater haskell" could be untyped
14:30:11 <carter> skypers: whats the end goal
14:30:22 <carter> you're not telling me what your'e using it for
14:30:47 <ap1988> carter: just ran cabal update; cabal install cabal-install; rm ~/.cabal/config, cabal install cabal-install
14:30:48 <edwardk> fragamus: personally i'd rather take a longer view and figure out how to do it right without giving up the good stuff =P
14:30:53 <ap1988> 1) ~/.cabal/bin is still empty
14:31:03 <skypers> carter: well, it’s about materials and mesh for instance. A mesh can have a material, but the material is an “entity”, it’s not a simple value
14:31:04 <carter> oh
14:31:06 <skypers> it’s a living object
14:31:08 <ap1988> 2)cabal: unrecognised command: sandbox (try --help)
14:31:10 <carter> ap1988: you needed to do cabal update
14:31:17 <carter> after the rm
14:31:23 <edwardk> i don't particularly care if Mathematica is better at it now, if we can com up with a more principled solution that lets us reach greater heights in the long term.
14:31:34 <geekosaur> also probably hash -r after installing the new cabal-install
14:31:45 <carter> ap1988: open a new terminal tab
14:31:53 <geekosaur> (and possibly $PATH adjustments to make sure the new one is found before the old)
14:31:53 <carter> and add ~/.cabal/bin to path
14:31:54 <fragamus> anyhow they have "wolfram" language, and although it's baroque and the runtime is or was shit, the symbolic stuff is a huge advantage
14:32:06 <carter> fragamus: isn't the new language just mathematica
14:32:16 <fragamus> cater: yes
14:32:28 <carter> ......
14:32:31 <ap1988> should I also be deleting config.platform?
14:32:31 <cschneid> are effects are viable way to structure a  program? As opposed to monad transformers? I've been slowly reading the paper - but was wondering more from a practical point of view
14:32:35 <fragamus> carter even
14:32:49 <carter> ?
14:33:04 <fragamus> i misspelled your name in a previous message
14:33:07 <carter> ah
14:33:22 <carter> fragamus: btw #numerical-haskell is a thing
14:33:22 <carter> :)
14:33:24 <skypers> carter: if you have an idea for my material / mesh (indirection) issue, I’m all ears :)
14:33:33 <carter> skypers: whats the use case goal
14:33:38 <carter> youve still not told me that
14:33:38 <carter> :)
14:33:48 <carter> whats the *transitive* goal
14:33:51 <carter> no the one step up goal
14:33:52 <skypers> I told you
14:33:58 <fragamus> well anyhow we have a shitload of work to do to get symbolic haskell going
14:34:02 <skypers> 23:27 < skypers> carter: well, it’s about materials and mesh for instance. A mesh can
14:34:05 <skypers>                  have a material, but the material is an “entity”, it’s not a simple value
14:34:06 <carter> yes
14:34:10 <carter> thats one level of a goal
14:34:15 <carter> whats the big big picture goal
14:34:21 <carter> fragamus: yeah join #numerical-haskell channel
14:34:21 <carter> :)
14:34:43 <carter> fragamus: i *think* some of the stuff i'm doing for numerical-core can help with symbolic at some level
14:34:44 <carter> not sure though
14:35:12 <carter> fragamus: "/join #numeircal-haskell"
14:35:12 <skypers> carter: I want materials to be accessible from no model, like in a general scope, in order to change them since they’re like models ; when they change, they must change in the meshes
14:35:13 <ap1988> also (and I'm not sure if this should trouble me), cabal install cabal-install is throwing these guys: /var/folders/4l/qbdvy5xj4q53skv0zn0lhw940000gp/T/74501.c:1:12:      warning: control reaches end of non-void function [-Wreturn-type] int foo() {}
14:35:16 <skypers> that’s the only goal
14:35:22 <carter> ap1988: i KNOW
14:35:26 <carter> ap1988: hangon
14:35:36 <carter> ap1988: you have ghc 7.6
14:35:39 <carter> and clang
14:35:44 <acomar> ahh carter: thanks for the tip -- one of my packages installs globally (unfortunately unavoidable for the moment) and root's .cabal/config was old. Regenerating it and setting the library for ghci setting generated a .o file for the library
14:35:47 <napping> skypers: for sharing references like that, the basic options are to use IDs and look them up in a separate table, or to make a mutable data structure
14:36:03 <geekosaur> ap1988: that's just clang being pedantic about configure-isms
14:36:09 <skypers> napping: for now I use IDs but the implementation sounds crappy
14:36:12 <carter> ap1988: ap1988  https://gist.github.com/cartazio/7131371
14:36:13 <Ywen> cschneid: I'm really not sure of what I say, but it seems that everytime you want to run an effect, this recurs through the "stack" of effects trying to find the relevant part
14:36:16 <carter> is my directions to fix that issue
14:36:16 <skypers> it’s not a table, but index for Vector
14:36:24 <geekosaur> which are (inevitably) written to gcc's level of pedantic-ness
14:36:40 <skypers> an IntMap could be okay, but access would be in O(n log n), not O(1)
14:36:54 <Ywen> cschneid: (that's what the handleRelay fn seems to do)
14:37:08 <skypers> IORef is O(1) I guess, but it suffers a huge issue I mentionned above
14:37:33 <cschneid> Ywen: I think that's right? Is that a practical concern in an app, or are monad transformer stacks better? That's the kind of thing I'm wondering
14:37:34 <skypers> STRef*
14:37:43 <cschneid> I like the idea of tighter promises on what each function can and can't do
14:38:00 <napping> you can often clean up the ID thing by carrying around the context in a monad or something
14:38:40 <skypers> napping: what do you mean?
14:38:44 <napping> and on the other hand, with stuff like Traversable you can keep some convenience while working over mutable data
14:38:48 <Ywen> cschneid: extensible-effects are too recent so that this question may be answered, I'm afraid
14:39:11 <ap1988> carter: I can't actually follow those instructions to the letter
14:39:16 <carter> why not
14:39:20 <napping> If you define some monad carrying around the current Vector/IntMap etc, you can have lookup functions that give you an assembled object
14:39:21 * hackagebot linear 1.10.1.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.10.1.1 (EdwardKmett)
14:39:24 <Ywen> I must admit that for now, I fail to grasp their essential advantage compared with transformers
14:39:27 <ap1988> I've got some RubyGems which kinda depend on me NOT having Xcode 5 CLI tools
14:39:35 <ap1988> because the latest clang changes are....
14:39:36 <skypers> napping: it’s already the case
14:39:37 <ap1988> how do I put this
14:39:38 <carter> ap1988: sorry, You DO have cli toos
14:39:41 <carter> thats why you get this error
14:39:45 <skypers> I use such a thing to “create” my object
14:39:49 <skypers> assemble it
14:39:53 <ap1988> I have CLI tools 4 I believe
14:39:55 <cschneid> Ywen: as far as I can tell, you can do stuff like "this function can email people, but not read files off disk" - which would both just be the MonadIO in a stack.
14:39:57 <ap1988> or I should do
14:40:03 <skypers> but if the vector changes, all IDs become crap
14:40:04 <carter> gcc --version
14:40:07 <carter> clang --version
14:40:13 <ap1988> well hot damn
14:40:14 <napping> isn't that the point?
14:40:14 <skypers> it’s a huge side effect I want to avoid
14:40:24 <napping> you want to be able to change what the IDs resolve to by changing the vector?
14:40:24 <cschneid> Ywen: for now, I'll stick with monad trans stacks and play with some eff on the side. I just saw its use recently so got curious
14:40:27 <ap1988> carter: you're right, my bad
14:40:30 <carter> :)))
14:40:31 <skypers> no napping
14:40:44 <carter> ap1988: this is why i just tell people "do what i say, literally"
14:40:48 <skypers> the Vector is just an implementation detail
14:40:48 <napping> Then why do you even indirect through IDs?
14:40:50 <carter> because i've been fixing EVERYONESs macs
14:40:55 <Ywen> cschneid: nope, you could also make a MailMonad and a FileMonad. And on the other hand, you can stick (Lift IO) at the "bottom" of your effects
14:40:56 <carter> via irc
14:41:01 <skypers> napping: because I want reference semantic
14:41:01 <cschneid> I suppose I can do that same "email, no files" restriction in a monad stack by having a MonadEmail type class,
14:41:08 <skypers> a material can be shared over several meshes
14:41:16 <skypers> if it changes, it must changes in all meshes
14:41:20 <skypers> how would you do that?
14:41:20 <napping> Right
14:41:24 <cschneid> Ywen: yep, ok - convinced me - I'll stick with monads for the moment.
14:41:30 <napping> and if you change the material it changes everywhere
14:41:35 <skypers> yep
14:41:42 <carter> ap1988: its 'cause you updated to mavericks, as everyone inevitably does
14:41:49 <napping> so trashing all the references is the expected behavior if you trash all the references
14:41:57 <skypers> I can also represent the material by a function
14:42:19 <skypers> napping: well
14:42:19 <Ywen> cschneid: The way I usually proceed is by having polymorphic functions: e.g. myStateFn :: (Monad m) => Fizz -> StateT MyStateRecord m Buzz
14:42:31 <skypers> if I trash one reference somewhere
14:42:37 <skypers> all other materials should just be fine
14:42:47 <ap1988> carter: yeah I'd been delaying that update for a while now. it's broken my system in new and interesting ways
14:42:50 <napping> and if you overwrite one slot in the vector, everything else should be fine
14:42:55 <Ywen> cschneid: This way I can run myStateFn whatever the context, possibly by just adding lifts
14:42:57 <skypers> yes
14:42:57 <carter> ap1988: well
14:42:58 <carter> do exactly my direction
14:43:00 <carter> s
14:43:03 <carter> and haskell will be fine
14:43:06 <ap1988> I'm on it :)
14:43:06 <napping> If you do something crazy like sliding over slots, of course that ruins everything
14:43:08 <skypers> but forget about the vector, it’s the current implementation
14:43:09 <carter> OR you could use my ghc 7.8.2 build
14:43:14 <skypers> yes
14:43:18 <napping> but otherwise it should work just fine
14:43:19 <skypers> I think it’s not a robust solution
14:43:39 <napping> What's not robust?
14:43:41 <cschneid> Ywen: that's a nice pattern - I'll have to play with that (gotta see some code of that style to grok properly)
14:43:43 <carter> ap1988: once you start caring about web app parallel perf, you'll wanna update to 7.8
14:43:47 <carter> but no hurry for now
14:43:56 <skypers> the fact that ID are like iterator in C++
14:43:59 <Ywen> cschneid: And if it needs IO, I can simply change it to: myStateFnNeedingIO :: (Monad*IO* m) => Fizz -> StateT MyStateRecord m Buzz. Simple enough, I believe
14:44:02 <skypers> if the vector changes, it ruins everything
14:44:17 <napping> what do you mean "changes"?
14:44:33 <napping> It's not different from indirecting through a lookup table of materials in any other language
14:44:46 <skypers> hm
14:44:48 <napping> if you do something that disturbs the whole table instead of a single slot, you'll mess up all materials
14:45:07 <skypers> you might be right
14:45:09 <Ywen> cschneid: The idea is to *always* make as if you were using a monad transformer. This way you you never need more than lifts
14:45:14 <skypers> so it’s not a so huge side effect in the end
14:45:34 <napping> Of course, if you are using a mutable vector to back the IDs, there's probably no point to using a completely pure data structure for the mesh
14:45:35 <skypers> adding materials in the vector don’t violate anything
14:45:35 <cschneid> Ywen: StateT always instead of State basically?
14:45:51 <skypers> no, I use immutable vectors
14:45:52 <Ywen> cschneid: Yes, if I were using bare State, I'd need extra conversions
14:46:06 <napping> Oh, then you're rebuilding the whole vector each time!
14:46:12 <cschneid> Ywen: cool - I learned similar things too while playing (learning) with MaybeT and EitherT
14:46:18 <napping> I guess an IntMap would be faster
14:46:18 <skypers> and I generate the ID using length
14:46:25 <cschneid> basically always use the T versions and it's more composable.
14:46:27 <skypers> napping: what?
14:46:35 <skypers> snoc doesn’t rebuilt the whole vector
14:46:40 <skypers> it’s O(1)
14:46:43 <Ywen> cschneid: and the conversion in the other way around is much easier: just stick Identity where fn type mentions an m
14:46:47 <skypers> rebuild*
14:46:48 <napping> Are you sure it's an immutable vector?
14:46:53 <thinkpad20> hey guys, I recently upgraded to GHC 7.8.2, and now all of the sudden GHCi says that it can't find module Data.Text... what's goin on?
14:47:00 <skypers> it’s Vector, not MVector
14:47:10 <Ywen> cschneid: I mean, you just make runIndentity $ runState ...
14:47:45 <napping> You mean the O(n) Data.Vector.snoc?
14:47:51 <Ywen> cschneid: the type system works for you. And this way it feels much simpler than extensible-effects and doesn't need Typeable
14:48:16 <skypers> napping: is it really O(n)?!
14:48:29 <napping> What else can it do except copy the vector?
14:48:29 <skypers> what’s the point then?
14:48:34 <cschneid> Ywen: yep - I like that. I'm going to play with it the next app I make. I've spent too much time "learning" without enough "doing" I think
14:48:40 <cschneid> (over the last ~2 years at this point)
14:48:45 <skypers> napping: something faster, like DList
14:49:02 <napping> Huh? DList isn't good for indexing
14:49:19 <skypers> I was talking about the snoc operation
14:49:23 <skypers> on DList it’s O(1)
14:49:24 <ap1988> carter: ok so I've stepped through your instructions, now I rm -rf ~/.cabal, then cabal update, cabal install cabal-install?
14:49:31 <napping> Sure, but you also expect to look up IDs
14:49:36 <skypers> yep
14:49:43 <napping> If you want it to be pure all the way through, IntMap is probably the best balance
14:50:33 <napping> What are you actually doing with the data?
14:51:24 <skypers> napping: well, those data are shared, then I have a huge function that “represents” those data with other attached data (at the same index, in a parallel structure)
14:51:33 <Ywen> cschneid: it just feels weird that no more people use monads this way, as it makes your life easier without having to resort on mtl extra typeclasses & explosion of instances. The simple cost for this is a few explicit lift-ing
14:51:34 <skypers> it’s a way to attach a “view” to a data, if you know what I mean
14:51:42 <skypers> then I use that data to render it
14:51:42 <napping> Are you editing the data structures, or rendering them, or what?
14:51:44 <eiluan> I have homework that says "do not use functions other then ....". (==) is not in this list. Is there any way to implement this on my own? (I'm not asking for a solution) I feel like I just should use it
14:52:07 <skypers> napping: both, yes
14:53:12 <corgifex> eiluan: for which type?
14:53:20 <eiluan> Integers
14:53:33 <eiluan> oops, not Ints
14:53:33 <eiluan> *no
14:53:36 <fragamus> OK you guys I need to talk this through… I need some kind of monad here… I am starting with a list and...
14:53:56 <corgifex> eiluan: what functions are allowed?
14:54:38 <skypers> napping: btw
14:54:41 <Ywen> cschneid: the only problem is when your function needs several monads: you need to fix things more in the type and then pay attention to be coherent with the rest of your code. But even in that case it's better to know which monad is on which, as it affects their behaviour
14:54:49 <skypers> I could consider using STRef in the end
14:55:02 <napping> you probably want IORef if it goes mutable at all
14:55:13 <skypers> I don’t absolutely need IDs lookup, IDs lookup is the best way I’ve found so far
14:55:16 <napping> STRef has to go away when the ST computation ends
14:55:21 <skypers> napping: no I can’t
14:55:32 <skypers> ah
14:55:35 <skypers> hm
14:55:45 <skypers> I feel like trapped dammit :D
14:56:05 <napping> I think it's pretty reasonable to use mutable unboxed data here
14:56:18 <napping> especially if you can get the meshes and materials into nice forms for rendering calls
14:56:28 <skypers> yeah
14:56:38 <skypers> well I’m not fond of “mutable” data
14:56:49 <skypers> otherwise I’d go back to D or Rust
14:56:50 <skypers> :(
14:57:02 <ap1988> so I've just installed cabal-install v 1.18
14:57:15 <ap1988> however ~/.cabal/bin is nonexistent, and cabal --version shows 1.16
14:57:23 <ap1988> any way to specify which version I want to be using?
14:57:25 <skypers> it’s a curious phenomena not having papers talking about that kind of issue, napping
14:57:25 <eiluan> corgifex: Ok, i just realised that for this task only delete from Data.List. I have no clue what i should do with it, the rest of the problem can be solved without. I guess that impossible.
14:57:39 <eiluan> I could use pattern maching for the first n numbers
14:57:59 <eiluan> but i guess that's not intended
14:58:07 <corgifex> oh, if pattern matching is allowed ...
14:58:22 <corgifex> are n+k patterns allowed?
14:58:42 <corgifex> if not, you may have to write your own numbers
14:58:43 <napping> skypers: you could look up graph libraries
14:59:00 <fizruk> how's `elem` symbol called?
14:59:49 <skypers> napping: I think it’s overkilling for such a little problem
14:59:54 <skypers> in C++ it’d be already solved
14:59:55 <skypers> :(
15:00:10 <eiluan> corgifex, ok, k+n patters are a elegant way. I thought they where outdated and thrown out.
15:00:12 <napping> If you want "already solved", go for the MVar
15:00:14 <joneshf-laptop> is there a uml-esque specification for non-OO stuff?
15:00:15 <napping> MVector, I mean
15:00:25 <corgifex> eiluan: they are
15:00:32 <skypers> what is the drawback of MVector napping ?
15:00:33 <corgifex> but the rules of homework are mysterious
15:00:51 <eiluan> yes, definifily.
15:00:58 <eiluan> thanks for the hint
15:01:01 <napping> The only drawbacks there is that it's mutable, and you have to manage IDs yourself, neither particularly issues with MVector
15:01:20 <napping> and I think the main thing purity gives you here would be persistence, for keeping old states around
15:01:53 <skypers> hm
15:02:14 <skypers> I’ll go on with Vector, and if performances are too bad I’ll try something clever
15:02:23 <skypers> when I add something, it’s a snoc call
15:02:27 <skypers> so I guess it’s bad
15:02:38 <napping> Yeah, I'd carry around a bunch of MVectors in a monad
15:02:43 <napping> and write nice accessors
15:02:50 <skypers> I have my combinators
15:02:53 <skypers> something like
15:03:05 <napping> and you can probably write nice traversal schemes or whatever that take pure functions for the local work, however the structure is implemented
15:03:22 <skypers> v @! (ID i) = v ! i; and v @? (ID i) = v !? i
15:03:42 <eiluan> ghc find parse errors inside my commented out code...
15:04:01 <carter> ap1988: you need to do:  rm the ~/.cabal/config  ; cabal update ;  cabal install cabal-install
15:04:51 <skypers> napping: don’t MVectors suffer from the same thing ST s does?
15:05:00 <skypers> when the monad goes out, the MVector dies
15:05:03 <carter> then *again* rm ~/.cabal/config  ; cabal update
15:05:12 <carter> what shell are you using?
15:05:27 <napping> no, MVectors can live in IO or ST
15:05:58 <stolaruk> :t finally
15:05:59 <lambdabot> IO a -> IO b -> IO a
15:06:18 <stolaruk> Is it possible to use this ^^ with functions in a transformer stack?
15:06:24 <skypers> napping: since I don’t want IO
15:06:28 <skypers> I’m stuck to ST
15:06:40 <stolaruk> Is there a way to lift "finally"?
15:06:52 <skypers> yes stolaruk
15:06:56 <stolaruk> :t liftM3
15:06:57 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
15:07:03 <stolaruk> :t liftM2
15:07:04 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:07:13 <skypers> how do you want it lifted?
15:07:44 <napping> skypers: uh, how do you expect to do any rendering or user interatction in ST?
15:08:12 <skypers> napping: as I said earlier, I have two type of data
15:08:19 <skypers> the raw one, and the view one
15:08:31 <skypers> the raw runs in a monad A and the view runs in a monad B
15:08:37 <skypers> the A monad is pure
15:08:40 <stolaruk> skypers: I have a stack of type "StateT WorldState IO" and I want "finally" to work with functions that return type "StateT WorldState IO ()" (instead of "IO a")
15:08:44 <skypers> where B is IO
15:08:59 <napping> Oh, okay
15:09:11 <skypers> stolaruk: liftIO (finally a b)
15:09:19 <napping> as long as you don't mind rebuilding everything every step
15:09:28 <napping> then yeah, an ST mvector during the building should work just fine
15:09:46 <c_wraith> skypers: that doesn't work.
15:09:49 <skypers> well, I’m still confused napping
15:10:01 <skypers> c_wraith: why?
15:10:08 <stolaruk> skypers: I get "Couldn't match type `StateT WorldState IO ()' with `IO ()'"
15:10:11 <c_wraith> skypers: liftIO only works with things that only mention IO in the *return* position
15:10:26 <c_wraith> skypers: if it has IO as arguments, too, you need much more complexity
15:10:27 <skypers> oh yeah, well lift
15:10:35 <skypers> ah you’re right
15:10:38 <skypers> maybe something like hm
15:11:22 <skypers> control $ \run -> finally $ \a b -> run $ -- I have no idea what I’m doing sorry stolaruk :D
15:12:04 <stolaruk> Well yeah I'm wondering if I need to pull out the IO from the stack
15:12:39 <c_wraith> There have been a number of attempts to solve things like this.
15:12:55 <ReinH> You can write a function :: StateT WorldState IO a -> StateT WorldState IO b -> StateT WorldState IO a
15:12:56 <c_wraith> MonadCatchIO was an early attempt, and completely flawed for finally.
15:13:06 <skypers> :t finally
15:13:07 <lambdabot> IO a -> IO b -> IO a
15:13:18 <skypers> :t lift $ finally (return ()) (return ())
15:13:19 <lambdabot> MonadTrans t => t IO ()
15:13:36 <skypers> you want both the param to run StateT WorldState IO, stolaruk ?
15:13:56 <ReinH> but it's pretty hard to write it correctly
15:14:02 <ReinH> stolaruk: see https://www.fpcomplete.com/user/snoyberg/general-haskell/exceptions/exceptions-and-monad-transformers
15:14:16 <stolaruk> skypers: Both parameters are in that stack
15:14:20 <ReinH> since you have to thread the state through yourself
15:14:24 <skypers> hm
15:14:35 <skypers> I guess with MonadTransControl
15:14:39 <skypers> it might be feasable
15:14:44 <stolaruk> ReinH: I'll check that out, thanks
15:15:35 <ReinH> there are actually a lot of different subtle ways to get it wrong
15:15:44 <ReinH> but that article does a good job of discussing them
15:19:26 * hackagebot BiobaseXNA 0.8.3.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.8.3.0 (ChristianHoener)
15:23:51 <ap1988> I've just installed yesod with cabal install yesod
15:24:19 <ap1988> however ~/.cabal/bin does not exist, .cabal-sandbox/bin does not contain yesod, and yesod devel produces: -bash: yesod: command not found
15:24:23 <ap1988> thoughts?
15:24:26 * hackagebot haskell-modbus 0.3.2 - A cereal-based parser for the Modbus protocol  http://hackage.haskell.org/package/haskell-modbus-0.3.2 (JasonHickner)
15:24:48 <shachaf> I,I strace cabal
15:28:26 <joelteon> ap1988: yesod-bin
15:28:29 <joelteon> is the package you need
15:28:40 <eiluan> Is it good haskell style to add whitspaces before the equality sign to make conresponding equality signs line up?
15:29:02 <[swift]> eiluan: i do it unless it's inconvenient
15:29:46 <ap1988> there appears to be a dependency conflict with yesod-bin
15:30:00 <[swift]> eiluan: i find that, for me, it makes code more readable. YMMV. i usually almost line up the beginning of guards (|) and the arrows in case statements (->)
15:30:15 <[swift]> sorry, i usually *also line up...
15:30:50 <simon> eiluan, I don't think there is a clear agreement.
15:31:17 <simon> eiluan, although I doubt you will find much alignment in the standard library.
15:31:22 <eiluan> ok. I think its more readable, but maybe there is an argument against it, in advanced code
15:31:38 <eiluan> but if that does not seem the case, great
15:31:39 <jchee> if there are any thrift users out there I'd be interested in votes or comments on https://issues.apache.org/jira/browse/THRIFT-2401 and https://issues.apache.org/jira/browse/THRIFT-2453
15:32:55 <[swift]> when i work on projects with many developers, the argument against such alignment is that it can make you update lines of code just to fix their alignment, when you didn't change anything else, which breaks 'git blame' and such to some extent
15:33:10 <ap1988> oddly enough, removing my cabal-sandbox fixes the dependency conflict
15:33:18 <[swift]> you'll have to decide if that's actually a problem for me
15:33:34 <dionyziz> Hi. I'm trying to use cabal-install on mac os x with homebrew. I installed cabal-install using `brew install cabal-install`. Afterwards, I tried to update cabal, and it told me a new version of cabal-install is available. I tried to install the new version, with an error on HTTP 4000. Here it is: http://pastebin.com/raw.php?i=nLdYGKgD
15:33:38 <[swift]> personally i don't think it's enough of a problem to care, but i know others that disagree
15:33:41 <dionyziz> Any ideas what I could be doing wrong?
15:34:42 <[swift]> dionyziz: i don't know but i'd like an answer to this as well, because Travis CI started failing to run my haskell tests with the exact same error
15:34:47 <[swift]> dionyziz: just started yesterday
15:35:47 <jle`> don't vcs systems like darcs attempt to differentiate between real code changes and alignment fixes?
15:37:25 <[swift]> dionyziz: so it looks like tibbe updated the 'network' package on sunday, and broke 'http', because 'http' doesn't have version bounds on 'network'. totally not your fault
15:37:55 <[swift]> dionyziz: are you running into an issue where you need to update cabal-install? if not, my advice would be to hold off
15:38:04 <[swift]> dionyziz: it'll probably be fixed very quickly
15:38:11 <dionyziz> [swift]: Thanks for the information. No, I don't know to update right now. That's all I needed to know :)
15:38:16 <dionyziz> I don't need to update*
15:38:31 <dionyziz> I'll hold off for a couple of days.
15:38:41 <[swift]> dionyziz: sounds good. =) i'll go make sure there's an issue open about this
15:39:01 <BeardedCoder> [swift] https://github.com/haskell/HTTP/issues/55
15:39:26 <[swift]> BeardedCoder: awesome! thanks
15:40:15 <cwvh> I have a parsec function that looks like:     f = try p1 <|> try p2 <|> p3              am I building a parsing anti-pattern with the `try' across alternatives?
15:40:36 <cwvh> it feels odd
15:46:00 <flebron> In naming some settings variables, is "numberOfRoles", "numberOfPatterns" and the like too verbose, or is it standard Haskell?
15:49:29 <Jafet> do a <- p123; b <- (do c <- p12; d <- p1 <|> p2; return $ c ++ d) <|> p3; return $ a ++ b -- yoda parsing
15:51:40 <conal> What's the notation for the superkind of * that also includes unlifted types? And is it part of the language (GHC Haskell) syntax, or just for built-in magic? I remember something about "#", "?", and "??", but GHC isn't liking those kind annotations.
15:53:42 <conal> and i don't know how to google for those symbols.
15:55:21 <pfn> is there a jvm targeting haskell compiler anywhere? heh
15:56:07 <Jafet> Last time I checked, kind # and ? are output-only.
15:59:24 <prophile> conal: https://github.com/ghc/ghc/blob/master/compiler/parser/ParserCore.y#L241 suggests it's ?
16:00:05 <conal> prophile: it sure does. thanks! hm.
16:00:09 <Algebr> Anyone used the curl library? I'm having trouble with it.
16:06:33 <Algebr> Actually, I think my problem might be with string, is there no way to get raw strings or like nest strings with " ' ' " or maybe triple quoted strings like python?
16:07:32 <geekosaur> nesting is done with backslash-escapes
16:08:01 <Algebr> Right...I was hoping for something less clunky.
16:08:16 <Jafet> > iterate show ":-)\n"
16:08:17 <lambdabot>  [":-)\n","\":-)\\n\"","\"\\\":-)\\\\n\\\"\"","\"\\\"\\\\\\\":-)\\\\\\\\n\\\\...
16:09:23 <c_wraith> > fix show
16:09:24 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:10:32 <dmj`> is there a way to parallelize the addition of integers in a list?
16:11:11 <conal> c_wraith: :)
16:11:45 <[swift]> Algebr: http://kwangyulseo.com/2014/02/06/multi-line-strings-in-haskell/
16:11:46 <c_wraith> dmj`: list is not a good structure for that.  the cost of traversing it is greater than the cost of adding integers.
16:12:02 <c_wraith> dmj`: unless the integers are *really* big.
16:12:20 <[swift]> Algebr: a wise person told me once "The answer is... Yes! Haskell can do that!"
16:12:26 <dmj`> c_wraith: I'm trying to map reduce a HashMap of HashMaps, the resulting data structure is a list of ints
16:12:40 <Jafet> :t sum
16:12:41 <lambdabot> Num a => [a] -> a
16:12:45 <dmj`> c_wraith: what I have is this
16:13:01 <dmj`> runPar $ parMap (H.foldl' (\a Job{..} -> a + charge) 0) (H.elems mapOfJobMaps)
16:13:08 <dmj`> it returns a [Int]
16:13:13 <benmachine> I started compiling GHC too soon before bedtime :(
16:13:31 <Algebr> first two are hacks, third is decent.
16:15:14 <[swift]> Algebr: yeah, i mostly meant the third one. didn't feel like pasting the names of 4 different quasiquotation libraries for strings
16:15:24 <dmj`> c_wraith: any ideas?
16:15:47 <Algebr> this is a real failing of the language =/
16:16:04 <[swift]> Algebr: do you think? i actually think the quasiquote-based solutions are prefect
16:16:04 <Jafet> You might love the cat language, then.
16:16:08 <Jafet> #!/bin/cat
16:16:13 <Jafet> Check it out.
16:16:26 <fragamus> pipes or conduit?
16:16:29 <[swift]> Algebr: is there something they don't give you that you need? you get raw strings, ruby-like string interpolation, all sorts of things
16:16:29 <benmachine> I wrote a CGI script in tail once
16:17:07 <c_wraith> dmj`: if parMap is sufficiently parallel, running sum on the result list is as good as you'll get
16:17:31 <Algebr> processing strings is bread and butter, Haskell is lacking in this department compared to the mainstream.
16:17:49 <dmj`> c_wraith: thanks, figured as much
16:18:51 <c_wraith> Algebr: the mainstream like C and Java, which are even worse?
16:18:53 <Jafet> You seem to be lacking in some other department
16:19:10 <fragamus> pipes or conduit?
16:19:23 <c_wraith> fragamus: whichever you want.  They're both fine.
16:19:25 <Algebr> c_wraith: I wouldn't say string processing is easy in C, but its certainly easy in Python/Java
16:20:00 <c_wraith> python doesn't even distinguish between strings and characters.  It's a mess.
16:20:12 <fragamus> c_wraith: I get that they're interchangable, but I'm asking for opinions
16:20:13 <[swift]> Algebr: you know Java doesn't have multiline string literals, right?
16:20:23 <Algebr> When do I ever care about the distinction of strings and chars?
16:20:34 <[swift]> IMO it's easier in Haskell than Java, but YMMV
16:20:37 <c_wraith> whenever you want to have semantics
16:20:46 <c_wraith> a character means something different from a string
16:20:50 <c_wraith> So don't pretend they're the same
16:21:20 <Algebr> I'm not seeing how it benefits me as a working programmer, if anything its simplier to just have strings.
16:21:44 <prophile> because strings are just lists
16:21:53 <[swift]> ^^ this
16:21:56 <Algebr> Okay, and?
16:22:01 <prophile> and lists have an element type
16:22:21 <prophile> because wacky special cases are bad
16:23:00 <[swift]> basically you can use all your list-processing functions on strings, and it Just Works
16:23:29 <fizbin> Is it possible to declare a data type inside a function instead of at top level?
16:23:50 <Algebr> I guess so, in Python I don't really have this concern, I can iterate over any sequnces.
16:24:33 <flebron> Sure, but a char is not a sequence.
16:24:57 <fizbin> I've got an algorithm that I think requires a specialized zipper-like type to do its thing with, and I see no reason to pollute my module's exports with this internal type
16:25:09 <prophile> flebron: well actually
16:25:09 <Jafet> Don't export it, then
16:25:14 <flebron> fizbin: You can just not export it.
16:25:31 <prophile> you could imagine it as a sequence of 8-bit ints for its UTF-8 encoding
16:25:57 <Jafet> Char is a unicode codepoint. It is not encoded
16:26:21 <fizbin> Yeah, but then in this module I have to switch over to naming everything I want trio export, which is something I've been able to avoid until now
16:26:38 <prophile> making your intentions clear on what you want to export is generally a good idea anyway
16:26:47 <ReinH> Wow, coalgebras are everywhere
16:26:51 <ReinH> crasy
16:26:52 <fizbin> "want to export" - silly autocorrect
16:27:03 <prophile> ReinH: no, that's just the LSD
16:27:26 <fizbin> What is a coagulants, anyway?
16:27:43 <MagBo> autocorrect strikes again.
16:27:52 <ReinH> prophile: I was looking at NFA with epsilon transitions and sure enough http://arxiv.org/pdf/1402.6281.pdf
16:27:54 <fizbin> No, a coalgebra. I need to stop using autocorrect
16:27:56 <ReinH> boom coalgebra
16:28:26 <prophile> neat
16:28:39 <shachaf> terminal coalgebras are the best
16:29:05 <ReinH> fizbin: type Coalgebra f a = a -> f a is an F-Coalgebra
16:29:10 <c_wraith> terminal coalgebras sound like something I'd rather not contract.
16:29:29 <ReinH> ha
16:29:42 <aheller> shachaf: I don't know that I like whath that implies about initial algebras.
16:29:59 <aheller> if you'd said "the greatest…."
16:30:32 <shachaf> aheller: "best" is self-dual
16:30:37 <shachaf> or maybe not
16:30:42 <shachaf> but the dual of the best is usually also the best
16:30:50 <flebron> <Doctor> I'm sorry, your object has too many arrows going into it. We hoped it would be the case, but all indications are that your object is terminal.
16:31:13 <flebron> <Patient> But... in the opposite category it's initial? :)  :(  :)  :(
16:32:17 <SwashBuckla> aww, printed Haskell code listings are pretty
16:32:30 <SwashBuckla> especially with pandoc!
16:32:47 <MagBo> http://f.nn.lv/n4/3i/ko/coalgebra.png
16:32:57 <MagBo> ^ this is koalgebra
16:32:58 <fizbin> ReinH: that doesn't help much, since it is far from clear why a -> f a is that interesting a type
16:33:52 <dmwit> fizbin: An "a -> f a" is a function which tells how to unfold an a-typed seed into an f-shape with further a-type seeds for further unfolding.
16:34:01 <dmwit> ...in the holes.
16:34:28 <fizbin> I mean, if f is a monad, then a -> f a is the Kliesli arrow, but otherwise...
16:34:33 <aheller> f needs to be a functor...
16:35:24 <ReinH> aheller: an endofunctor, in fact
16:35:39 <aheller> ReinH: hard to get the type signature if it isn't :)
16:35:46 <ReinH> aheller: :)
16:35:52 <dmwit> I don't understand symbolic links.
16:35:57 <flebron> You can see a -> f a as a natural transformation from Id to f, which is how a Monad uses it.
16:36:12 <aheller> dmwit: ?
16:37:15 <dmwit> ln -s filename directoryname doesn't work well. Why not? I freely admit this is not really a Haskell question.
16:37:27 <flebron> ln -s target link_name
16:37:39 <flebron> (I have that koan memorized.)
16:37:46 <dmwit> err
16:37:48 <dmwit> Are you sure?
16:37:53 <aheller> I find repeating "ln is like cp" helps.
16:37:55 <ion> How about ln -s filename directoryname/linkname?
16:38:06 <ion> (Note that it will point to filename in the same directory)
16:38:17 <flebron> Yeah, pretty sure.
16:38:29 <mindleyhilner> except it isn't
16:38:29 <fizbin> flebron: unfortunately, that does you good only if you have reason to want natural transformations. Since too much category theory always sounds indistinguishable to me from Smurf theory, I never understood why that would help.
16:38:30 <ReinH> flebron: well if you want to use "target" to mean "source" then yes
16:38:36 <dmwit> ion: Right, the latter "note" is what is strange to me.
16:38:40 <ReinH> usually "target" is used to mean "target" and "source" is used to mean "source"
16:38:41 <dmwit> That seems like a dumb behavior.
16:38:50 <ReinH> so you get `ln source_file target_file'
16:38:52 <flebron> ReinH: I mean link_name will be a sign that says "Hey, go to target."
16:39:02 <ReinH> except "target" is the source
16:39:03 <flebron> This command has not been sponsored by Target(tm).
16:39:03 <ReinH> not the target
16:39:07 <dmwit> flebron: Oh, your terminology sucks.
16:39:29 <dmwit> Like, it's explicable. But it still sucks.
16:39:30 <ReinH> as in, is exactly opposite from what the manpage uses
16:39:51 <flebron> Well, it helps me remember it :)
16:39:55 <flebron> (Whereas the manpage didn't.)
16:40:03 <fizbin> ln a b is like echo a > b, except that it puts the stuff into b's directory listing instead of into b's data.
16:40:17 <aheller> which is why "ln is like cp" works so well.  If you wanted to copy foo to bar, you'd do "cp foo bar".
16:40:17 <dmwit> fizbin: No, it's not.
16:40:26 <fizbin> Rather, ln -s is like that.
16:40:43 <dmwit> fizbin: Compare ln a directory with echo a >directory. One produces a wrong link; the other produces an error.
16:41:26 <fizbin> True. ln -s a directory is like echo a > dir/a
16:41:36 <dmwit> fizbin: Again, it's not.
16:42:02 <dmwit> fizbin: Compare ln -s a dir with echo a >dir/a. One produces a wrong link; the other produces a correct file.
16:42:16 <flebron> fizbin: Well, the reason you want eta :: a -> m a in a monad is because you want (mu, eta) to behave like a monoid, where eta x puts x in a sort of "default context", which can be removed by mu :: m (m a) -> m a without any effects. That is, mu . eta = id :: m a -> m a.
16:42:21 <dmwit> That's what started this entire chain of complaint. =P
16:42:54 <fizbin> dmwit: no, both create the wrong link.
16:43:00 <ion> If you write a program that goes to dir and recursively reads “a” and goes to the file the contents point to, it *is* like echo a >dir/a. :-P
16:43:20 <dmwit> fizbin: ...okay =)
16:43:21 <flebron> fizbin: Which a -> m a were you interested in?
16:43:49 <dmwit> I'm wrong, as usual.
16:43:55 <dmwit> Because I read "echo" but thought "cat".
16:47:39 <mietek> How do you write a simple data-conduit sink, say, to count stream elements?
16:47:45 <mietek> The sinkState function in http://www.yesodweb.com/blog/2011/12/conduits-sink has been long since deprecated and removed
16:51:23 <jle`> mietek: count the number of items received?
16:52:04 <mietek> jle`: yeah?
16:53:45 <intrados> Is there a way to chain `at`s in lens? Like `^. at 1 . at 2` ?
16:53:58 <Peaker> why is +RTS -N not the default?
16:54:06 <jle`> mietek: i don't know what is idiomatic, but one way you could do it is something like encoding the state in the recursive call
16:54:26 <mietek> jle`: do you have an example?
16:56:02 <mietek> Oh, interesting.  Data.Conduit.List
16:57:12 <Peaker> intrados: you chain them like that, yeah, but "at" will result in a Maybe, so you can: A) traverse inside the Maybe,  B) use "ix" instead of "at" to go inside the Maybe and get a traversal instead of a lens directly
16:57:35 <Peaker> intrados: then if you don't want an implied mconcat, you might want to use ^.. or ^? instead of ^.
16:58:30 <Peaker> intrados: for example:  foo ^? at 1 . traverse . at 2 . traverse        or more simply:   foo ^? ix 1 . ix 2
16:59:07 <intrados> Peaker: Ah, thanks.
17:04:18 <fizruk> hi all! i'm trying to use free applicatives for simple forms with validation
17:04:42 <fizruk> when validation function is pure everything's fine https://gist.github.com/fizruk/65b4ac64e9ab85772b33#file-pure-hs
17:05:27 <fizruk> but when I want validation function to be arbitrary (e.g. monadic), I get some weird implementation https://gist.github.com/fizruk/65b4ac64e9ab85772b33#file-eff-hs
17:06:48 <fizruk> the most unpleasant thing is that to get help message (see help function) I need to use monad m from validation function
17:07:23 <srhb> mietek: fmap length consume?
17:08:42 <sm> I have a bit of shady lazy knot-tying that works in GHCI but prints <<loop>> when compiled, why is that ?
17:09:23 <fizruk> is it possible to make help function pure in Validation.Eff?
17:11:43 <Welkin> what is the significance of monoids?
17:11:55 <Welkin> the explanation in LYAH is weak in my opinion
17:11:58 <pavonia> sm: Do you have a sample?
17:12:16 <Welkin> (applicative) functors are explained well
17:12:38 <Welkin> but monoids leave me wondering when I would want to use one
17:12:45 <fizruk> Welkin: monoids are very general and appear everywhere
17:12:49 <Welkin> well
17:12:52 <Welkin> I list is a monoid
17:12:53 <Welkin> sure
17:12:59 <Welkin> but when would I want to construct my own?
17:13:03 <c_wraith> Welkin: monoids are more or less "associativity is good", expressed more formally.
17:13:32 <aheller> Another (partial) intuition is that monoids capture aggregation.
17:14:15 <Clint> Welkin: when you want to use functions that take a Monoid
17:15:31 <srhb> Welkin: In the beginning it will be more about "when can I use <> and mempty" rather than "when can I make my own Monoid"
17:16:24 <srhb> > 1 <> 2 :: Sum Int
17:16:25 <lambdabot>  Sum {getSum = 3}
17:16:36 <tcard> mietek: how about http://lpaste.net/102750
17:16:38 <srhb> "Hello " <> "World!"
17:16:43 <srhb> > "Hello " <> "World!"
17:16:44 <lambdabot>  "Hello World!"
17:16:57 <mietek> tcard, srhb, jle`: http://pastie.org/private/siointnqikqexc7kn9q
17:17:05 <mietek> Here's what I came up with
17:17:22 <mietek> tcard: thanks
17:17:30 <cschneid> srhb: hmm - didn't know you could do that without having to apply the Sum constructor to left & right. I assume it works due to the Num conversion trickery that numeric literals are?
17:17:31 <tcard> mietek: CL.fold: nice! :)
17:18:22 <jakex_> there's no Num conversion trickery, 1 and 2 *are* Nums
17:18:23 <srhb> cschneid: Yeah, Num a => Num (Sum a) I assume
17:18:25 <jakex_> :t 1
17:18:26 <lambdabot> Num a => a
17:18:51 <cschneid> jakex_: I meant the specialization down to (Sum a)
17:19:03 <cschneid> makes perfect sense but hadn't ever noticed it :)
17:19:16 <jakex_> yeah, Sum has a num instance
17:19:19 <jakex_> Num*
17:19:21 <fizruk> > sortBy (comparing length <> compare) ["now", "I", "just", "ate", "my", "own", "dog"] -- i like this one
17:19:23 <lambdabot>  ["I","my","ate","dog","now","own","just"]
17:19:53 <srhb> WEll actually I guess Num a => Monoid (Sum a) :-)
17:21:22 <fizruk> cschneid: afaik Sum and Product are Num's since 7.8
17:21:57 <cschneid> :t sortBy
17:21:58 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
17:22:00 <cschneid> :t comparing
17:22:01 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
17:22:02 <cschneid> :t compare
17:22:03 <lambdabot> Ord a => a -> a -> Ordering
17:22:51 <cschneid> fizruk: so your sortBy example is "sort by Length, then sort by default ordering (alphabetical in this case)
17:23:03 <fizruk> cschneid: yes
17:24:17 <cschneid> fizruk: how would you do descending length? descending alphabetical is just `flip` on it.
17:24:48 <fizruk> cschneid: so is with comparing length
17:25:00 <fizruk> > sortBy (flip (comparing length) <> compare) ["now", "I", "just", "ate", "my", "own", "dog"]
17:25:01 <cschneid> oh of course.
17:25:01 <lambdabot>  ["just","ate","dog","now","own","my","I"]
17:25:17 <cschneid> yeah, I got stuck on comparing taking 3 args, and flip working only on 2 :)
17:25:41 <cschneid> which of course ignores the obvious solution
17:25:55 <fizruk> :)
17:26:04 <aheller> > sortBy (comparing (Down . length) <> compare) ["now", "I", "just", "ate", "my", "own", "dog"]
17:26:06 <lambdabot>  ["just","ate","dog","now","own","my","I"]
17:26:24 <cschneid> :t Down
17:26:25 <lambdabot> a -> Down a
17:26:32 <cschneid> @info Down
17:26:33 <lambdabot> Down
17:26:33 <aheller> cschneid: :)
17:26:41 <cschneid> lol. Where are you!
17:26:47 <aheller> Data.Ord
17:27:14 <aheller> :t getDown
17:27:15 <lambdabot> Not in scope: ‘getDown’
17:27:17 <aheller> Damn.
17:27:23 <aheller> I was hoping that got in.
17:27:34 <cschneid> hmm, I found it in GHC-Exts
17:28:53 <aheller> > sortBy (Dual $ comparing length) <> compare) ["now", "I", "just", "ate", "my", "own", "dog"]
17:28:54 <lambdabot>  <hint>:1:44: parse error on input ‘)’
17:29:15 <c_wraith> aheller: not enough ( in there
17:29:17 <aheller> > sortBy ((Dual $ comparing length) <> compare) ["now", "I", "just", "ate", "my", "own", "dog"]
17:29:18 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]
17:29:19 <lambdabot>                                -> [GHC.Types.Char] -> GHC.Types.Ordering’
17:29:19 <lambdabot>              with actual type ‘Data.Monoid.Dual
17:29:19 <lambdabot>                                  ([a0] -> [a0] -> GHC.Types.Ordering)’
17:29:34 <aheller> I should probably think about the code I'm pasting before pasting it.
17:30:22 <fizruk> or pm lambdabot
17:30:59 <aheller> I am covered in shame.
17:31:10 <erisco> ah I was not aware of instance (Monoid r) => Monoid (a -> r)  that is pretty cool
17:31:55 <erisco> most cool because it recursively applies down to the monoid return type
17:33:23 <cschneid> > Dual True
17:33:24 <lambdabot>  Dual {getDual = True}
17:33:34 <cschneid> > getDual (Dual True)
17:33:36 <lambdabot>  True
17:33:39 <aheller> :)
17:33:48 <cschneid> I should just read docs rather than guess at stuff
17:34:08 <c_wraith> > True < False
17:34:09 <lambdabot>  False
17:34:13 <cschneid> ahh, flips the left and right of monoids
17:34:15 <c_wraith> > Dual True < Dual False
17:34:16 <lambdabot>  False
17:34:42 * hackagebot foldl-incremental 0.1.0.2 - incremental folds  http://hackage.haskell.org/package/foldl-incremental-0.1.0.2 (tonyday)
17:35:09 <cschneid> c_wraith: weird - why'd that work on an Ord thing? Does Dual do more than the docs say? http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Monoid.html#t:Dual
17:35:15 <cschneid> docs only say it flips monoid left & right sides
17:35:24 <cschneid> but it apparently flips Ord rules too
17:35:28 <c_wraith> > LT <> GT
17:35:30 <lambdabot>  LT
17:35:44 <c_wraith> > Dual LT <> Dual GT
17:35:45 <aheller> cschneid: it didn't.
17:35:45 <lambdabot>  Dual {getDual = GT}
17:36:06 <cschneid> Dual True < Dual False uses the Ord class's < right?
17:36:14 <c_wraith> I'm not sure that's actually associative
17:36:21 <aheller> It's not a monoid.
17:36:37 <c_wraith> But it has a monoid instance.  Oh no.
17:37:01 <fizruk> c_wraith: you meant Ordering?
17:37:04 <aheller> > Dual True <> Dual False
17:37:05 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Bool)
17:37:06 <lambdabot>    arising from a use of ‘Data.Monoid.<>’
17:37:12 <c_wraith> fizruk: I mean Dual Ordering
17:37:21 <c_wraith> fizruk: I know Ordering is a monoid
17:37:41 <fizruk> c_wraith: Dual a is Monoid whenever a is Monoid :)
17:37:48 <cschneid> I'm confused at the parsing & function lookup in that.   (Dual True) < (Dual False) =>   Dual { getDual=True} < Dual {getDual=False} -- then it evals the < funciton, right?
17:38:17 <cschneid> that's defined by Ord, not Monoid afaik?
17:38:41 <fizruk> cschneid: monoid is not used for Ord instance of Dual
17:38:50 <cschneid> oh, I got super confused by misreading c_wraith's original example. I'm sorry
17:38:53 <aheller> cschneid: Yes.  Just constructing a value of type (Dual a) doesn't mean that (Dual a) is a monoid.
17:39:09 <fragamus>     Could not find module `Pipes.Prelude'
17:39:09 <fragamus> WTF
17:39:10 <cschneid> hah, I understood correctly, but misread his lambdabot code. :-/
17:44:43 * hackagebot route-planning 0.0.2 - A library and utilities for creating a route  http://hackage.haskell.org/package/route-planning-0.0.2 (TonyMorris)
17:50:14 <fizruk> > map fst [(1, return 1), (2, return 2)]
17:50:16 <lambdabot>  Could not deduce (GHC.Base.Monad m0)
17:50:16 <lambdabot>    arising from a use of ‘GHC.Base.return’
17:50:16 <lambdabot>  from the context (GHC.Num.Num b)
17:50:16 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num b => [b]
17:50:16 <lambdabot>    at Top level
17:52:07 <Algebr> not sure if my last message went through..
17:52:13 <jakex_> > map fst [(1, return 1 :: [Int]), (2, return 2)]
17:52:15 <lambdabot>  [1,2]
17:52:49 <Algebr> I was reading a tutorial on type classes and page said that ghc erases types at compile time, that there are no types at run time. What does that even mean?
17:53:39 <aheller> Algebr: That there's no type tag or anything after compilation.
17:54:28 <Algebr> aheller: You can't find out the type of something at run-time? I guess there would be no point?
17:54:40 <aheller> Exactly.
17:54:50 <Algebr> wow, my mind is blown.
17:54:56 <aheller> Suppose you have: is_int :: Int -> Bool
17:55:05 <aheller> Exactly.
17:59:29 <sgeisenh> I was under the impression that you could make restrictive type annotations specifically avoid polymorphism
17:59:35 <sgeisenh> specifically to*
18:11:01 <tristan__> anyone deal with font-lock issues with haskell mode in emacs?
18:11:06 <tristan__> I keep getting (void-variable haskell-font-lock-choose-syntactic-keywords)
18:11:16 <tristan__> so must be missing some definition somewhere
18:13:34 <athan> how do you add sources to a cabal project?
18:14:06 <athan> I used `cabal sandbox add-source ...`, but cabal still says it can't find my module
18:14:36 <athan> even though the module's .hi file is inside the .cabal-sandbox folder
18:18:21 <geekosaur> a source would be .hs, .hi denotes a compiled module and should be a package for cabal
18:21:36 <pingu> Does anyone know how you would go about translating C library calls that look like item *get_next_item()
18:21:56 <pingu> into something that looks like a list in haskell, but is lazily evaluated?
18:22:09 <pingu> Is that kind of functionality exposed above the ghc level?
18:25:46 <pavonia> pingu: Wrapping it in unsafeInterleaveIO is the common way, I think
18:26:31 <dwcook> pingu, that looks more like a Producer (from pipes) than a list to me
18:26:38 <pingu> the obvious way prevails :)
18:26:57 <pingu> dwcook: certainly, yes. I'm reluctant to add pipes to a library such as mine though
18:27:08 <pingu> everyone knows how to use lists already
18:27:46 <pingu> pavonia, dwcook, thanks
18:39:49 * hackagebot dns 1.2.2 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.2.2 (KazuYamamoto)
18:43:57 <heatsink> I've noticed that a lot of packages have been on Hackage for over two years, yet >10% of their downloads were in the last 30 days
18:44:19 <heatsink> Has there been a recent jump in hackage downloads?
18:44:53 <Taslem> in the Data.ByteString package, `concat` is said to be O(n)- is this in the length of the given list, or the total size of the resulting bytestring?
18:45:50 <athan> has anyone here used vault before?
18:46:13 <geekosaur> Taslem, size of the list of strings
18:46:46 <geekosaur> hm, I think. might be size of the final bytestring possibly minus the last segment, come to think of it
18:47:00 <geekosaur> I would expect lazy bytestrings to be the former and strict to be the latter
18:47:02 <Taslem> see, that's the ambiguity I was referring
18:47:24 <Taslem> The obvious way would probably be in the size of the string, but I wasn't sure if it somehow cheated and made it faster
18:47:27 <geekosaur> so there's also an ambiguity in your question: which bytestring?
18:47:55 <geekosaur> (a lazy bytestring ls a lazy list of strict bytestring "chunks"; concat is pretty trivial for this type)
18:48:26 <heatsink> What does O(n\c) mean in the bytestring documentation?
18:48:39 <pingu> number of chunks I have presumed personally
18:48:41 <pingu> I'm not sure though
18:49:06 <Taslem> is there anyone here who wrote any of the functions/documentation who could say?
18:49:26 <linman24> hi all. getting an error when installing lens-4.1.2: http://pastebin.com/uMLiXwww
18:49:30 <aheller> if you have a whole bunch of empty strings and little else, concat should probably be dominated by the length of the list even in the strict case.
18:49:31 <heatsink> geekosaur: Then wouldn't append would be O(n) in the number of chunks, which is proportional to the number of characters?
18:49:43 <Jafet> heatsink: presumably you are meant to use the set construction for n in some way
18:49:59 <Taslem> Okay, so the source shows it's cheating with unsafe pointers (though it does it in a safe way)
18:50:12 <Taslem> unsafeCreate len $ \ptr -> go xs ptr
18:50:40 <Taslem> and it uses withForeignPtr p $ \fp -> memcpy ptr (fp `plusPtr` s) (fromIntegral l) to actually copy them
18:50:55 <heatsink> What is the set construction, Jafet?
18:50:59 <Taslem> I assume that memcpy is O(n) in size but probably really fast.
18:51:50 <jle`> well...
18:51:51 <Sculptor> it should be natively supported by the uc
18:51:57 <Sculptor> by the cpu*
18:52:08 <jle`> the difference between n of the final bytestring and teh n of the thing you are adding
18:52:11 <jle`> is a constant factor
18:52:18 <jle`> so it is absorbed in O(n) notation, isn't it?
18:52:40 <jle`> if it was O(n^2) then that would make a difference probably
18:52:51 <Taslem> Provided it's a small part of it
18:53:52 <linman24> ubuntu 12.01 is giving me a dependency install error
18:53:52 <linman24> http://pastebin.com/uMLiXwww
18:53:56 <Jafet> heatsink: 0 -> {}, n+1 -> {{}, {n}}
18:55:03 <heatsink> jle`: In the limit as length(x) --> ∞, concat [x, x] could be either O(1) or O(n) depending on the implementation
18:55:13 <heatsink> so it's not necessarily absorbed into the O(n) notation
18:55:42 <Jafet> jle: not necessarily
18:55:44 <Taslem> internally, aren't (strict) ByteStrings just arrays?
18:55:55 <Jafet> foldl1 (++) vs. foldr1 (++)
18:56:30 <heatsink> Not clear whether n is 2 or approaching ∞ for concat [x, x] with large x.
18:56:50 <heatsink> Jafet: Interpreting \ as the set difference operator?
18:59:06 <linman24> supki and geekosaur were helping earlier today w/ issue
18:59:16 <linman24> pastebin.com/1KkpQxkG
18:59:52 * hackagebot rainbox 0.4.0.2 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.4.0.2 (OmariNorman)
19:04:08 <flebron> What are interesting uses of DataKinds for pseudo-dependent typing in Haskell? I know of the usual Vector, NonNullList, and balanced binary search trees. Any more?
19:07:06 <dwcook> I haven't tried but I think you could implement the type of nats no bigger than some n
19:10:37 <athan> could someone see why my code is failing? http://lpaste.net/102753
19:11:04 <athan> I have a feeling that `Key RealWorld` is actually a function
19:13:44 <heatsink> athan: The type of 'insert' is Key a -> a -> Vault -> Vault
19:14:10 <heatsink> The first two arguments are the key and value.  Note how their types are related.
19:14:24 <athan> hmm
19:14:27 <heatsink> A Key RealWorld is only for keeping track of RealWorld objects.
19:14:50 <athan> Still though, if I replace Key RealWorld with a Key UAResult, it will still complain, won't it?
19:15:07 <Cale> What happens if you remove the type signature altogether?
19:15:50 <athan> wow...
19:15:53 <athan> it worked...
19:16:03 <athan> Thank you heatsink :)
19:16:05 <Cale> What's the inferred type?
19:16:19 <Cale> (Probably Key UAResult)
19:16:40 <athan> That's a good question... is there any way to set line breaks for the type system, to print out the type of an expression without having to go into ghci?
19:16:49 <Cale> uh, no
19:16:49 <athan> that's my guess too
19:17:00 <athan> :/
19:17:01 <Cale> The type system is purely a compile-time construction
19:17:07 <Cale> It doesn't exist at runtime
19:17:14 <athan> no special macros?
19:17:20 <Cale> Why not just open this in ghci?
19:17:36 <ChongLi> Cale: barring certain libraries :)
19:17:47 <athan> like... super-splice or something... maybe in TH?
19:17:49 <Cale> You should always keep ghci open alongside your text editor while you work.
19:18:08 <Cale> You can type :r in ghci to reload whenever you make a change
19:18:15 <athan> Cale: I'm following the language philosophy, so to speak
19:18:21 <Cale> and test things interactively as you go
19:18:25 <athan> oh huh
19:18:29 <athan> that's actually a good idea
19:18:30 <athan> hmm
19:18:39 <athan> cabal repl loads it all though, right?
19:19:12 <Cale> I don't know much about cabal repl, but presumably it just runs ghci appropriately for your project
19:20:01 <ChongLi> Cale: yeah
19:20:06 <ChongLi> it runs ghci within your sandbox
19:20:09 <athan> Cale, here's the interpreted type:
19:20:10 <athan>   :: UAConfig
19:20:10 <athan>      -> Data.Vault.ST.Lazy.Key RealWorld UAResult
19:20:10 <athan>      -> (Network.Wai.Internal.Request -> t)
19:20:10 <athan>      -> Network.Wai.Internal.Request
19:20:10 <athan>      -> t
19:20:50 <saml_> that type
19:20:56 <athan> I like how wai interprets that
19:21:00 <athan> yeah
19:21:20 <athan> is there any way to test equivalence of types? Like a kind-class called Eq? :P
19:21:35 <athan> erm actually nevermind
19:21:40 <erisco> athan, yes
19:21:47 <athan> no kindclass, but literally test equivalence?
19:21:52 <athan> erisco: Oh wow, how?
19:21:53 <saml_> it takes a config, and realworld result, and a request handler, and a request, and returns result of applying the request to the request handler
19:22:06 <erisco> athan, you won't like my idea :P you could use a type family
19:22:20 <athan> hmm...
19:22:37 <athan> how would you interpret the haskell `type` and `newtype` declarations?
19:22:46 <saml_> type is alias
19:22:52 <saml_> newtype is not alias
19:23:04 <athan> right, but how would you make the code?
19:23:06 <athan> so that
19:23:16 <athan> type Foo = Bar Int
19:23:18 <erisco> there might be a possibility to use overloaded instances... something like 'EqType a a' vs 'EqType a b'
19:23:36 <saml_> x :: Foo  means that x :: Bar Int
19:23:38 <athan> could you make a program that tests types?
19:23:51 <athan> or really, just like changes the gear one notch or something?
19:23:56 <saml_> :t "abc"
19:23:57 <lambdabot> [Char]
19:24:03 <athan> erisco: I was thinking that first
19:24:19 <erisco> athan, the brain-dead way is to use a type family and enumerate all the cases you want
19:24:19 <athan> saml_: Right. but at run time, how can you tell the difference?
19:24:24 <erisco> but that might be ugly
19:24:28 <athan> or really, is there a library
19:24:32 <athan> that I could make a repl with
19:24:33 <[swift]> athan: what does equivalence mean here?
19:24:33 <saml_> why do you want to test for types?
19:24:37 <saml_> isinstance and stuff?
19:24:37 <athan> simply to do type arithmetic?
19:24:44 <[swift]> athan: you have the type level equality operator ~
19:24:50 <athan> [swift]: Good point
19:24:55 * hackagebot chell-quickcheck 0.2.3 - QuickCheck support for the Chell testing library  http://hackage.haskell.org/package/chell-quickcheck-0.2.3 (JohnMillikin)
19:25:02 <erisco> athan, I do not think that will work for overload because 'b' can be inferred as 'a' after the fact
19:25:09 <athan> [swift]: Nevermind, I think I'm misunderstanding the type system haha
19:25:19 <athan> no not really
19:25:23 <athan> my ideal world would be
19:25:26 <athan> in ghci
19:25:29 <noah> athan: add a variable like "t :: ()" and then "t = complexExpression" to get a compilation error with the expect type
19:25:40 <erisco> athan, basically it has to be able to select the correct instance regardless of what the parameters may instantiate to
19:25:43 <noah> athan: its messy, but it would give you a type without ghci
19:25:44 <erisco> athan, as far as I understand it
19:25:45 <athan> have a type comparison command
19:25:59 <athan> so you could say :typecomp Foo (Bar Int)
19:26:06 <athan> and it would return == or something
19:26:31 <[swift]> athan: it should be possible to do that using type families
19:26:49 <athan> noah: Yeah, I may look into type holes. I need to learn language / logic more though
19:27:00 <erisco> [swift], if there is a way to do it without enumerating all the cases I'd like to know it
19:27:27 <aheller> typecomp :: a -> a -> Bool
19:27:32 <aheller> typecomp _ _ = True
19:27:43 <erisco> aheller, how do you get False?
19:28:05 <aheller> erisco: by calling typecomp on two types that aren't equivalent.
19:28:14 <athan> [swift]: I was hoping for something more interactive. Would there be any way to make the type system interactive?
19:28:16 <aheller> well, unifiable.
19:29:11 <[swift]> erisco: tbh i'm not totally sure, but i could swear i saw someone do it somewhere using ~ and type families. it seems intuitively possible to me
19:29:31 <[swift]> aheller: that's brilliantly simple!
19:29:59 <linman24> anyone get this error when running cabal install cabal-install?
19:30:00 <linman24> cabal-install-1.18.0.3 depends on HTTP-4000.2.4 which failed to install.
19:31:19 <erisco> it is not the same thing as what I was hoping for
19:31:25 <athan> aheller: Holy crap!!
19:31:41 <erisco> you would need   a -> a -> True   and   a -> b -> False   or something similar
19:32:12 <athan> erisco: Compile time failure = false haha
19:32:25 <athan> I think this is where Omega comes into play
19:32:40 <athan> but i honestly have no clue
19:34:39 <alkabetz> Has anyone here created a dlopenable library with Cabal?
19:34:55 <erisco> well if you just want a compile failure for unequal types then sure, that is simple
19:34:56 * hackagebot diagrams-builder 0.5.0.8 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5.0.8 (BrentYorgey)
19:35:15 <Ralith> you can dlopen any dynamic library; the hard part is doing something useful with it.
19:35:16 <erisco> but that has little to do with a function on types
19:37:05 <aheller> class TypeEq a a where; instance TypeEq a a — or something similar?
19:38:03 <erisco> the class definition does not make sense because it has two parameters of the same name... it is like defining the function  f x x = 5
19:38:54 <aheller> type classes are prolog, not ml :)
19:40:25 <carter> use closed type families
19:40:33 <aheller> http://hackage.haskell.org/package/lens-4.1.2/docs/Control-Lens-Equality.html does it with more type variables
19:41:36 <erisco> carter, is that possible? I would like to know how
19:42:18 <carter> data family Eq a b where
19:42:36 <carter> i mean
19:42:53 <carter> oh
19:42:54 <carter> yeah
19:43:02 <carter> Refl :: Eq a a
19:43:12 <carter> OR
19:43:21 <erisco> type family Eq a b where Eq a a = TypeIsEQ; EQ a b = TypeIsNEQ;  but these rules overlap
19:43:34 <carter> erisco: closed type families are ordered :)
19:43:40 <erisco> does not matter afaik
19:43:45 <carter> nope
19:43:50 <carter> closed type families are ordered
19:44:04 <erisco> I know they are but I am saying I do not think it matters. I was unable to make a very similar case work
19:44:11 <erisco> because the parameters are not inferred until later
19:44:23 <carter> then you wrote it wrong :)
19:44:24 <erisco> so there is no way to know if 'b' will end up inferred as 'a'
19:44:37 <erisco> well I will try this specific example
19:44:57 * hackagebot diagrams-builder 0.5.0.9 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5.0.9 (BrentYorgey)
19:45:02 <carter> erisco: that would be a bug
19:45:40 <erisco> carter, if this is supposed to work then I must have been doing something wrong or experiencing a bug
19:45:49 <carter> 7.8 ?
19:45:52 <erisco> yes
19:46:06 <erisco> I was trying to write rules for concatenating tuples
19:46:19 <carter> you need a condition like (Eq a b ~ True)=> Foo
19:47:34 <erisco> *shrug* guess I'll try again in a few minutes
19:47:43 <erisco> have to read a paper and then start up vagrant
19:48:00 <carter> 7.8.2?
19:48:10 <erisco> dunno
19:53:45 <AncientPC> I can't build cabal on ghc 7.8.2 due to Data.Text error: http://pastebin.com/W5r7xnWj
19:54:04 <AncientPC> I can't find it in cabal's bug reports either, am I doing something wrong?
19:54:58 * hackagebot diagrams-haddock 0.2.2.6 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.6 (BrentYorgey)
19:59:39 <heatsink> AncientPC: The output message isn't helpful.  Does it use up all the available memory before it is killed?
19:59:58 <carter> AncientPC: what OS?
19:59:59 * hackagebot lhslatex 0.1.0.0 - Tool for using pdflatex with .lhs files  http://hackage.haskell.org/package/lhslatex-0.1.0.0 (TvH)
20:00:46 <heatsink> There isn't an error message in the output, just warnings.
20:01:09 <carter> oh that would do it
20:03:38 <AncientPC> carter: Ubuntu 12.04 LTS
20:04:08 <augur> boy dibblego sure is going at it...
20:04:11 <carter> AncientPC: use hvr's build of cabal 1.18 to bootstrap your own
20:04:15 <carter> also what is your swap disk size
20:05:39 <AncientPC> heatsink: it uses 444/512MB before crashing, but I have swap enabled and 0/1GB swap is used.
20:06:36 <carter> AncientPC: use hvr's cabal install build
20:06:50 <augur> http://arxiv.org/pdf/1404.3782v1.pdf
20:10:10 <AncientPC> actually I just realized I can bootstrap off ubuntu's cabal-install package. D:
20:10:23 <carter> well yeah
20:10:29 <AncientPC> lol nvm it just died
20:12:47 <AncientPC> hmm, both Ubuntu and hvr cabal's crash during update: http://pastebin.com/EqiEz4Qh
20:13:52 <carter> where the heck is your machine?
20:14:09 <carter> is your swap configured correclty?
20:14:56 <bitemyapp> AncientPC: how much memory do you have?
20:17:07 <AncientPC> 512MB, and a 1GB swap partition confirmed via cat /proc/swaps
20:17:30 <carter> wheres it hosted?
20:18:04 <AncientPC> DigitalOcean NYC
20:18:14 <athan> record syntax can update data in a datatype, right? So you could have data Foo = Foo {bar :: Baz}; let cue = Foo 1 :: Foo Baz; let doo = cue {bar = 2}
20:19:08 <bitemyapp> athan: "update" means returning a new record with only that data changed.
20:19:15 <athan> right
20:19:17 <bitemyapp> AncientPC: you have to force swappiness
20:19:18 <athan> it's all simulated
20:19:20 <erisco> carter, it works fine so I was wrong
20:19:25 <bitemyapp> AncientPC: jack up the swappiness ALLLLLLLLLL the way.
20:19:25 <carter> ay
20:19:34 <carter> AncientPC: 7.8.2?
20:19:36 <bitemyapp> AncientPC: *alllllllll* the way.
20:19:38 <athan> bitemyapp: But that syntax works, right?
20:19:40 <bitemyapp> carter: dude, nothing to do with that.
20:19:42 <carter> also is it current text tip?
20:19:53 <bitemyapp> athan: left of { should be constructor, otherwise yeah
20:20:00 <bitemyapp> carter: doesn't matter. I've run into this myself.
20:20:04 <carter> there was a blow up in previous minor version of text
20:20:04 <carter> ok
20:20:06 <bitemyapp> carter: I've gone through exactly what they're encountering.
20:20:09 <bitemyapp> carter: it's swappiness.
20:20:13 <carter> fair
20:20:20 <bitemyapp> carter: cabal tries to yank too much swap all at once from the heap
20:20:28 <bitemyapp> carter: kernel freaks out because it doesn't start swapping soon enough.
20:20:33 <carter> rea?
20:20:37 <bitemyapp> yeah
20:20:41 <bitemyapp> you have to turn swappiness all the way up
20:20:52 <bitemyapp> the kernel is trying too hard to avoid resorting to swap.
20:21:16 <athan> bitemyapp: You mean in the 3rd line? How should it look?
20:21:24 <bitemyapp> carter: I'm one of those sad fucks whose builds/installs have broken on them so many times that I'm simply impervious to failure now.
20:21:26 <athan> I'm not getting any type errors and mine is similar
20:21:49 <bitemyapp> athan: what's the problem here exactly?
20:21:54 <bitemyapp> you said it type checks
20:22:05 <athan> So I'm testing my middleware for wai
20:22:11 <athan> via another middleware
20:22:15 <erisco> aheller, [swift], athan 'data TrueType; data FalseType; type family EqType a b where EqType a a = TrueType; EqType a b = FalseType;' works fine. this requires closed type families in 7.8
20:22:23 <athan> using the vault in between
20:22:36 <AncientPC> carter, bitemyapp: yeah it's a swap issue. I tested with a memory eater program that was autokilled once mem usage hit 512MB.
20:22:40 <athan> each request is the record, at least I think
20:22:52 <bitemyapp> AncientPC: I know it's a swap issue. Now jack up swappiness via proc.
20:23:11 <athan> erisco: Heck yeah!!!
20:23:13 <bitemyapp> spent way too much time debugging this for somebody else to also waste their time debugging this.
20:23:20 <carter> erisco: with data kinds you can use bool
20:23:38 <erisco> carter, ah interesting. I do not know anything about data kinds
20:24:32 <erisco> athan, by the way if it is not clear the way to use EqType is something like  'foo :: EqType Int Int'  which will be equivalent to  'foo :: TrueType'
20:25:16 <athan> haha that's too cool
20:25:37 <carter> nah
20:25:40 <carter> type class constraints
20:25:45 <carter> (Eq a b ~ True)
20:25:45 <carter> :)
20:25:52 <athan> but that's at compile time, right? So type families are basically like `type` declarations? (or can be)?
20:25:55 <erisco> yes that would work too
20:26:19 <erisco> if you wanted to use the types 'a' and 'b' of course
20:26:36 <erisco> (carter's usage is more useful for sure)
20:27:58 <erisco> carter, armed with this corrected information I'll see if I can improve my tuple concatenation code :D
20:28:53 <erisco> athan, yes it is compile time. type families are like functions on types
20:30:00 <erisco> like a normal function you do case analysis on the left and define the corresponding value on the right
20:34:29 <erisco> it would be nice to have recursive data structures to contain types... not sure how to do that yet
20:34:55 <pyon-away> erisco: what do you mean by "contain types"?
20:35:11 <pingu> pavonia: unsafeInterleaveIO worked perfectly, thanks :D
20:35:14 <erisco> for example a list of types as [Int, Char, Bool]
20:35:23 <pyon-away> erisco: HList
20:35:28 <pavonia> pingu: ?
20:35:36 <erisco> pyon-away, no I mean a compile-time list of types
20:35:38 <pavonia> pingu: Ah, I recall :)
20:35:42 <carter> erisco: these exist
20:35:45 <carter> you can do them
20:35:49 <erisco> oh? how? :)
20:36:01 <carter> umm
20:36:10 <carter> modern HList IS an example
20:36:24 <carter> and closed type families let you write arbitrary magic now
20:36:25 <erisco> oh okay sorry
20:36:25 <Iceland_jack> erisco: Something like
20:36:25 <Iceland_jack>     data HL :: [*] -> * where
20:36:25 <Iceland_jack>       N :: HN '[]
20:36:25 <Iceland_jack>       C :: a -> HN as -> HN (a ': as)
20:36:26 <carter> plus data kinds
20:37:37 <erisco> Iceland_jack, that is a GADT?
20:37:44 <Iceland_jack> yes
20:37:51 <pyon-away> btw just like HLists let you build arbitrary tuples is there any analog for sum types?
20:38:04 <erisco> N and C are data constructors though yes? how would I be able to use those at the type level?
20:38:17 <Iceland_jack> erisco: you wouldn't, they're on the value level
20:38:45 <erisco> oh =\ well that is what I thought the hetrogenous lists were... I was looking for something on the type level
20:38:46 <Iceland_jack>     N :: HN '[]
20:38:46 <Iceland_jack>     C 'a' N :: HN '[Char]
20:38:46 <Iceland_jack>     C True (C 'a' N) :: HN '[Bool, Char]
20:38:46 <Iceland_jack>     etc.
20:39:01 <Iceland_jack> erisco: the value constructors are always on the value level
20:39:08 <Iceland_jack> but they construct the list on the type level
20:39:26 <pyon-away> erisco: the point to having lists at the type level is making arbitrary tuple or variant types
20:39:39 <erisco> pyon-away, yes indeed
20:39:53 <pyon-away> erisco: and "arbitrary tuples" is indeed what HLists are
20:40:16 <erisco> hm well I'll take a close look then
20:41:48 <erisco> ah duh I thought of possibly another way to do what I want
20:42:09 <[swift]> erisco: super late reply, but thanks for showing how to write EqType. i need to play with closed type families more; cool stuff!
20:42:17 <pyon-away> erisco: making a type-level list, and applying a special constructor to it?
20:43:07 <erisco> pyon-away, no I was reading on the HList hackage page and it helpfully pointed out that HList '[Int,Double,b] is basically (Int, (Double, (b, ()))) which is exactly the recursive structure I wanted
20:43:15 <carter> [swift]: datakinds + closedtype famileis
20:43:28 <carter> erisco: sounds like you've got lots of learning :)
20:43:44 <erisco> do why? what do I look at next?
20:43:46 <erisco> do I?*
20:44:04 <carter> erisco: read ALL of oleg's crazy stuff
20:44:05 <carter> :)
20:44:08 <carter> plus hlist on hackage
20:44:09 <erisco> where?
20:44:10 <carter> plus umm
20:44:12 <carter> repa
20:44:14 <carter> and stuff
20:44:29 <carter> if google doesn't give you a life time of reading, holler :)
20:44:32 <pyon-away> closed type families are basically like pattern matching at the type level right?
20:44:49 <carter> pyon-away: yes, so you can have over lapp
20:44:53 <carter> because they get tried in order
20:45:10 * shapr gives Finland a case of over lapp
20:45:11 <carter> nb, certain inference things don't work as well with closed type families
20:45:35 <carter> because theres not a unique match for partially applied things
20:45:35 <pyon-away> yea
20:45:36 <pyon-away> normally i only used associated families
20:45:39 <carter> yeah
20:45:46 <pyon-away> it seem to me they're the sanest to reason about
20:45:52 <carter> associated data families are evne better
20:45:55 <carter> because they have injectivity
20:46:03 <carter> and you can keep them cheap by using associated newtypes
20:46:05 <pyon-away> i use both
20:46:11 <carter> yay
20:46:13 <carter> whats your use case?
20:46:27 <pyon-away> carter: i have a notion of "stream" that can be fed chunks
20:46:56 <pyon-away> carter: the Stream class (actually there's lot of classes that together make up the concept of a stream) has an associated Chunk type
20:47:06 <carter> cool
20:47:08 <carter> is it public?
20:47:08 <pyon-away> carter: and that one is an associated type
20:47:15 <pyon-away> as in open source?
20:47:18 <carter> sure
20:47:21 <carter> soke if not
20:47:22 <carter> :)
20:47:26 <pyon-away> err i'm probably posting it this weekend
20:47:33 <pyon-away> actually i had hosted it then took it down
21:21:32 <erisco> carter, ah now I remember... I was interested in giving implementations for each case
21:21:43 <erisco> and class instances are not ordered
21:21:58 <carter> erisco: thats called inductive defns and inlining :)
21:22:09 <erisco> I do not understand
21:22:34 <carter> its late
21:22:52 <erisco> but you hold the secrets to my future
21:23:08 <carter> well
21:25:34 <erisco> best I can think of is to invent a unique type for each case to tag the result with
21:25:42 <erisco> otherwise my instances conflict
21:26:22 <erisco> or I am using it wrong... wait a second :)
21:27:13 <athan> Can someone help me see what's wrong with this? http://lpaste.net/102756
21:27:22 <athan> I'm doing a basic "print to screen" test
21:27:45 <athan> the weird thing is that I have another middleware in the same pipeline that does print, while this one doesn't. Any ideas?
21:27:55 <athan> I'm wondering if it has to do with lazyness
21:28:47 <geekosaur> it could. but if stdout isn't a terminal it could be buffering
21:29:43 <athan> hmm, I wonder if it is. Thank you!
21:31:47 <erisco> hrm I am a bit puzzled
21:31:57 <erisco> I had to give all these type annotations to get this to compile http://lpaste.net/102758
21:32:23 <erisco> I understand the  :: FromList (Int,(Int,Int))  though I wish I did not need that... I do not understand why I had to specify Int
21:32:28 <athan> geekosaur: Aha! You were right!
21:32:59 <geekosaur> because numbers are polymorphic, and you provided no way to do inference
21:33:20 <erisco> geekosaur, didn't I? I do not understand =\
21:33:44 <geekosaur> your type family uses b and c without saying what they are or providing any way for it to guess
21:34:16 <erisco> well when I say  :: FromList (Int,(Int,Int))   I would have expected it to infer Int
21:34:30 <erisco> but instead I had to annotate every literal with :: Int ... not sure why
21:34:55 <kazagistar> erisco: but Float would also work, right?
21:35:04 <erisco> how could it? :s
21:35:32 <erisco> if I use Float I get a type error
21:35:48 <erisco> oh
21:36:20 <erisco> it is because my class is FromTyList a r  so it will hunt for any ol' instance at all
21:36:32 <erisco> I think you meant to tell me that geekosaur instead of my type family
21:36:48 <geekosaur> possibly
21:37:43 <geekosaur> I am not sure if both come into it but IIRC type families that aren't associated end up with a hidden class that they're associated with? which class would, I would expect, also mess with type resolution?
21:37:56 <geekosaur> I am not entirely clear on this stuff but I seem to recall something like that
21:38:29 <tcard> Does anybody have any specific examples of problems caused by too many --global packages in Haskell Platform?
21:40:07 <pavonia> What kind of problems?
21:41:14 <geekosaur> I think it comes down to two main cases: (1) use in restricted VMs such as S3 where provisioning the extra space for them costs extra money, (2) developers who want to track the bleeding edge and do not want to fight with fixed platform versions of things?
21:41:16 <tcard> pavonia: Please see the quote in http://www.haskell.org/pipermail/haskell-cafe/2014-April/113642.html
21:42:06 <tcard> Personally, I have not run into issues, as newer versions of packages can be installed in a sandbox, but I am investigating the idea.
21:43:03 <erisco> well now I am trying this but now I am even worse off: http://lpaste.net/102759
21:43:46 <erisco> when resolving the instance there is no information on whether 'c' is a tuple or not, it seems, and so the compile fails
21:44:04 <erisco> saying that (a,b,c) does not match FromList (a,(b,c))
21:44:08 <erisco> because, well, it doesn't in all cases
21:44:35 <Wizek> @pl f a = g $ h a
21:44:36 <lambdabot> f = g . h
21:44:41 <Wizek> @pl f a b = g $ h a b
21:44:41 <lambdabot> f = (g .) . h
21:44:46 <Wizek> Good morning!
21:45:05 <Wizek> @pl f a b c = g $ h a b c
21:45:06 <lambdabot> f = ((g .) .) . h
21:45:30 <Welkin> @pl
21:45:30 <lambdabot> (line 1, column 1):
21:45:31 <lambdabot> unexpected end of input
21:45:31 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
21:46:24 <Wizek> :t (.)
21:46:25 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:48:08 <erisco> mkay I tried adding a constraint but GHC could not infer the facts http://lpaste.net/102760
21:48:19 <Welkin> @pl <-
21:48:19 <lambdabot> (line 1, column 1):
21:48:19 <lambdabot> unexpected "<"
21:48:19 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
21:48:24 <Welkin> @pl (->)
21:48:24 <lambdabot> (line 1, column 3):
21:48:24 <lambdabot> unexpected '-'
21:48:24 <lambdabot> expecting expression
21:48:28 <Welkin> @pl (<-)
21:48:28 <lambdabot> (<-)
21:48:37 <erisco> if 'c' is not a 2-tuple then there is only one case for FromList! but I guess GHC doesn't know that
21:48:54 <carter> erisco: you cant compute in instance heads
21:49:01 <Welkin> @pl (*>)
21:49:01 <lambdabot> (*>)
21:49:10 <Welkin> > t: (*>)
21:49:12 <lambdabot>  Couldn't match expected type ‘[Debug.SimpleReflect.Expr.Expr]’
21:49:12 <lambdabot>              with actual type ‘f0 a0 -> f0 b0 -> f0 b0’
21:49:15 <erisco> carter, any tips?
21:49:19 <carter> dont do that
21:49:21 <carter> :)
21:49:26 <erisco> but what do I do instead? :P
21:49:36 <carter> learn how ghc works :)
21:49:45 <StoneCypher> :|
21:49:45 <erisco> that is quite broad
21:50:17 <StoneCypher> carter: the last time i spoke my mind in here about that kind of answer, i was told to ask the person to give real answers instead, rather than to say what i had said previously
21:50:26 <carter> :)
21:50:31 <carter> yes
21:50:42 <carter> but i'm honestly not the right person for that
21:50:48 <carter> and i'm busy helping someone on several other channels
21:50:49 <carter> so
21:50:54 <carter> someone else should opine
21:51:01 <StoneCypher> silence is generally better than a morale deflating non-answer
21:51:13 <Welkin> "because I said so!"
21:51:14 <carter> true
21:51:25 <carter> :)
21:51:27 <carter> i'm off
21:51:29 <carter> its late
21:51:36 <luite> it' not :p
21:51:38 <StoneCypher> erisco: i apologize; i don't speak haskell at all or i'd do what carter should have done
21:51:54 <carter> StoneCypher: erisco  stare at the Hlist package :)
21:52:03 <carter> it has lots of examples of fancy typees that ghc likes
21:52:15 <carter> http://hackage.haskell.org/package/HList
21:52:23 <carter> even though you say you want other things
21:52:25 <carter> stare at it
21:52:27 <carter> LOTS
21:52:38 <shachaf> Most of HList can be done in much simpler ways these days.
21:52:46 <shachaf> GHC has all sorts of extensions for that now.
21:53:51 <carter> i think hlist is more modern now, enthropy did a lot of changes that modernized it last fall
21:54:02 <carter> http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-HList.html
21:54:11 <carter> http://hackage.haskell.org/package/HList-0.3.4.1/docs/src/Data-HList-HList.html#HList
21:55:44 <Wizek> How would you do "transparent augmentation" with Haskell? Let's say I have function h that I want to augment (transform the return value of, in this case) by function g, and call the augmented function f. I tried f = g . h, but it seems I need to write `f = ((g .) .) . h`. Number of dots depend on the number of argument of h. Is there a way not to tie the implementation of f to
21:55:44 <Wizek> the number of args h may recieve?
21:55:57 <carter> how do i block StoneCypher  from pming me?
21:56:17 <StoneCypher> carter, i am doing what the ops told me to.
21:56:46 <carter> then stop cursing at me
21:57:29 <erisco> Wizek, I had to do that but the way I did it may not be great... I used newtype wrappers to annotate the function arity and then a Functor instance
21:57:55 <erisco> after seeing the Monoid instance for Monoid r => (a -> r) I wonder if there is a better way
21:58:13 <erisco> well since the tuple thing is not working I guess I'll try fixing that then
21:59:42 <erisco> Wizek, to be more specifc I'd do  fmap g (Arity2 const)  for example
21:59:49 <erisco> but I am wagering there is a better way
22:00:17 <Wizek> Would uncurry + curry work, maybe? '~'
22:00:37 <Wizek> :t uncurry
22:00:38 <lambdabot> (a -> b -> c) -> (a, b) -> c
22:01:00 <Wizek> :t curry
22:01:01 <lambdabot> ((a, b) -> c) -> a -> b -> c
22:01:23 <erisco> Wizek, well you can use the clever operators described here http://matt.immute.net/content/pointless-fun which is based on Conal's work http://matt.immute.net/content/pointless-fun
22:02:13 <erisco> but that is more verbose than just mapping the return value
22:02:31 <erisco> actually it does not cope with what you are looking for I do not think
22:04:22 <sgronblo> Could someone explain the meaning of the bind without equals at the end?
22:04:29 <linman24> gettin installation errors when i try to run cabal install
22:04:29 <linman24> http://pastebin.com/zwFL5gX3
22:04:40 <Iceland_jack> sgronblo: Do you mean (>>)?
22:04:42 <Iceland_jack> @ty (>>)
22:04:43 <lambdabot> Monad m => m a -> m b -> m b
22:05:01 <sgronblo> Most monad explanations just talk about the normal bind
22:05:05 <sgronblo> Iceland_jack: yeah that one
22:05:05 <erisco> sgronblo,  a >>= \_ -> b   is equivalent to   a >> b
22:05:31 <Iceland_jack> sgronblo: If you understand (>>=) then erisco's explanation might be what you need, but I can give you a more intuitive feel for it
22:05:43 <Iceland_jack> (>>) is called ‘then’ for a good reason
22:05:54 <sgronblo> Ah its called then
22:05:59 <Iceland_jack> If you're in the IO monad, (>>) has type
22:05:59 <Iceland_jack> @ty (>>) :: IO a -> IO b -> IO b
22:06:00 <lambdabot> IO a -> IO b -> IO b
22:06:11 <Iceland_jack> and it's similar to semicolons in C or Java
22:06:26 <Iceland_jack>     printf("Hello "); printf("World\n");
22:06:30 <sgronblo> Is it nonsensical for something like Maybe?
22:06:34 <Iceland_jack> no
22:06:44 <Iceland_jack> > Just 5 >> Just 10
22:06:46 <lambdabot>  Just 10
22:06:49 <Iceland_jack> > Nothing >> Just 10
22:06:51 <lambdabot>  Nothing
22:06:59 <corgifex> exception semantics
22:07:03 <dmj`> (>>) is implicitly defined for any monad instance given definitions of return and (>>=)
22:07:16 <Iceland_jack> So you don't depend on the value of 'Just 5' or 'Nothing', but you depend on their success or failure
22:07:16 <Wizek> main = print("Hello ") >> print("World\n")
22:07:29 <sgronblo> Iceland_jack: I think I see
22:07:40 <Wizek> Sneaky Haskell™
22:07:44 <Iceland_jack> sgronblo: Try understanding the IO example first, it's very simple
22:07:52 <Iceland_jack> Like what Wizek wrote
22:07:54 <dmj`> sgronblo: are you familiar with interfaces in OOP languages?
22:08:01 <sgronblo> Ah yeah Maybes bind would actually cause Nothing >> Just 42 to become Nothing
22:08:14 <Iceland_jack> @ty putStr "Hello " >> putStrLn "World"
22:08:15 <lambdabot> IO ()
22:08:29 <Iceland_jack> is basically the same as
22:08:29 <Iceland_jack> @ty putStrLn "Hello World"
22:08:30 <lambdabot> IO ()
22:09:08 <sgronblo> In the case of the IO though, can printf("Hello ") fail?
22:09:20 <Iceland_jack> sgronblo: not in the sense of Maybe
22:09:24 <Iceland_jack> *not like
22:09:25 <sgronblo> Or is >> used for ordering the "computations" in this case?
22:09:27 <Iceland_jack> yes
22:09:49 <Iceland_jack> You *can* combine IO actions and Maybe failures together into a single monad
22:10:43 <sgronblo> I've been trying to enumerate the benefits of using Monads and right now it seems that I have: Sequencing of "actions", short-circuiting of actions on failure and you dont need to manually unwrap values in Monads.
22:12:33 <sgronblo> Am I missing something?
22:13:08 <Iceland_jack> They're just a common pattern
22:13:24 <carter> threading something around
22:13:35 <carter> but i think you covered that
22:13:41 <sgronblo> Yeah, but if somebody asked you "what can you do with a monad?" or "why should I use this?"
22:13:45 <carter> parsers are both a good and bad example
22:13:51 <Iceland_jack> If you find that your problem fits the Monad pattern, chances are you're going in the right direction
22:13:56 <carter> because you can still write pretty awesome parsers with just applicative
22:13:56 <Iceland_jack> And you get nice syntax for it
22:14:54 <urbanslug> I have this weird problem where cabal install after sandbox init is still complaining about conflicts. Shouldn't everything install in the sandbox?
22:15:22 <Iceland_jack> sgronblo: You can read this http://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/
22:16:01 <sgronblo> Iceland_jack: Yeah I have that one in my Pocket
22:16:10 <Iceland_jack> Don't store articles in your pocket
22:16:21 <sgronblo> Why not?
22:16:29 <Iceland_jack> Pockets are for keys and wallets
22:16:44 <sgronblo> And smart phones
22:17:01 <Iceland_jack> Those go in your socks
22:17:15 <sgronblo> carter: whats the canonic example of "threading something around"
22:17:19 <Iceland_jack> sgronblo: State monad
22:17:21 <sgronblo> sounds uncomfortable :)
22:17:25 <carter> parsers
22:17:28 <carter> or umm
22:17:30 <carter> STM
22:17:33 <sgronblo> Ah havent used the state monad yet
22:17:34 <carter> umm
22:17:45 <sgronblo> I did see Meijers presentation about monadic parsing though
22:17:48 <Iceland_jack> sgronblo: I'm sure you can emulate the State monad very simply :)
22:18:01 <sgronblo> Not sure how it relates to "threading around" though?
22:18:13 <sgronblo> Do you mean wrapping in a context?
22:18:41 <Iceland_jack>     let (state1, val1) = foo initialState
22:18:41 <Iceland_jack>         (state2, val2) = bar state1
22:18:41 <Iceland_jack>         (state3, val3) = haz state2
22:18:41 <Iceland_jack>     in (state3, val1 + val2 + val3)
22:18:59 <urbanslug> I have a problem so weird I don't think I can even be helped.
22:19:07 <Iceland_jack> It's basically what the random functions in System.Random do, where you have to thread it manually
22:19:09 <Iceland_jack> dreadful
22:19:12 <gamegoblin> Are there any benchmarks of the various haskell webservers now using the new ghc 7.8 io thread stuff?
22:19:40 <dalaing> sgronblo: I came across a good motivation for monads the other day at a local meetup talk
22:20:11 <sgronblo> dalaing: please share
22:20:20 <dalaing> sgronblo: imagine your language had no polymorphism, so you had to write a list instance by hand for every type you wanted to put in a list
22:20:21 <carter> gamegoblin: wait till snap 1.0 is launched
22:20:46 <dalaing> sgronblo: when polymorphism reaches your language, people are going to add lists, since it would be a known, useful thing to do
22:20:48 <sgronblo> ah i have so many questions right now
22:20:55 <gamegoblin> carter: when’s that?
22:20:59 <carter> idk
22:21:02 <sgronblo> dalaing: ah you mean generic lists?
22:21:04 <dalaing> monads are like that but with higher kinded types - once you have them, there's some useful patterns of things you can do
22:21:05 <dalaing> yeah
22:21:06 <dmj`> gamegoblin: I'm using snap w/ 7.8.2, it seems faster, I haven't ran benchmarks tho
22:21:09 <carter> probably after zurihac
22:21:17 <dalaing> monads are one of them
22:21:30 <xaimus> dl
22:21:33 <dalaing> there's more to them then just being a useful pattern of doing things, but you can start with that
22:21:38 <xaimus> wrong window, sorry!
22:21:55 <sgronblo> Btw, I seem to remember reading that Haskell had something similar to promises but not called promises right?
22:21:56 <dalaing> like functor is a useful pattern of being able to apply a element-wise function across a container
22:22:02 <Iceland_jack> sgronblo: Do you understand Functors? Don't attempt Monads before those make sense
22:22:13 <Iceland_jack> dalaing: Element-wise?
22:22:34 <dalaing> like if you can double an int, you can use functors to double a list of ints, a tree of ints, etc...
22:22:38 <dalaing> it's not the whole story
22:22:39 <Iceland_jack> That's a rather narrow view :)
22:22:41 <sgronblo> To me it now seems like Promises are a special case of monads?
22:22:43 <dalaing> but it's enought to get going with
22:23:02 <Welkin> sgronblo, don't try to transfer your knowledge of "functional programming" from javascript or any other language into Haskell
22:23:02 <dalaing> or to get over thinking monads are some big hard thing to struggle with
22:23:04 <sgronblo> With "then" instead of bind
22:23:04 <Iceland_jack> You can make a Functor that has *no* values
22:23:10 <Welkin> just learn the concepts from the ground up
22:23:45 <dalaing> Iceland_jack: I know, but I'm currently trying to explain them like I would to someone who is stuck on monads
22:24:00 <Welkin> use this: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
22:24:08 <Iceland_jack> Fair enough
22:24:18 <sgronblo> Nobody is addressing the actual question though
22:24:19 <Welkin> it is an excellent overview of Haskell from 10,000 feet
22:24:29 <dalaing> I tend to prefer this - http://www.seas.upenn.edu/~cis194/lectures.html
22:24:45 <Iceland_jack> sgronblo: Example of threading?
22:25:34 <sgronblo> No, the promise equivalent in Haskell.
22:25:37 <dmj`> > flip execState 1 $ modify (+1)
22:25:39 <lambdabot>  2
22:25:47 <dmj`> there's an example of a threaded state that was evaluated
22:27:06 <Iceland_jack> I'm not sure if promises are monads, what would join be?
22:27:42 <sgronblo> In other languages that dont have a strong notion of monads you add promises as a new type and it has a special case bind-like function called then or onComplete or something, but in Haskell you could just have some monadic wrapper that represents an asynchronous computation that will return a value of type a.
22:28:09 <Iceland_jack> Asynchronous computation is not exactly the same as promises
22:28:14 <Iceland_jack> there does exist and Async monad
22:28:21 <sgronblo> Ah
22:28:30 <Iceland_jack> *an
22:28:38 <sgronblo> But there are some subtle differences?
22:28:55 <Iceland_jack> http://hackage.haskell.org/package/async
22:28:56 <jedws> Future is definitely a Monad, but it depends what you mean by Promise
22:29:21 <sgronblo> Yeah maybe I'm thinking more about Futures
22:29:45 <Iceland_jack> sgronblo: The link I posted talked about futures being monads
22:29:50 <carter> theres different semantics
22:30:06 <sgronblo> I wish this terminology was more consequently used and more well defined
22:30:34 <carter> sgronblo: have you seen the lvish lib?
22:30:38 <carter> @hackage lvish
22:30:38 <lambdabot> http://hackage.haskell.org/package/lvish
22:30:40 <sgronblo> carter: nope
22:30:45 <jedws> I usually think of Promise as something producer related, "I Promise to give this to you when it is ready"
22:30:47 <carter> deterministic parallelism
22:31:01 <jedws> a Future is what you consume
22:31:46 <jedws> but, that isn't Haskell necessarily…
22:31:58 <carter> problem is what are the semantics of composing them
22:32:11 <urbanslug> After building yesod in a sandbox should I just move the contents /lib and /bin of the sandbox to .cabals /bin and /lib?
22:32:19 <carter> https://hackage.haskell.org/package/async-2.0.1.5/docs/Control-Concurrent-Async.html
22:32:35 <carter> asynch package is pretty neat for "sane promise things"
22:33:10 <Iceland_jack>     data Rubbish a = Rubbish
22:33:10 <Iceland_jack> Rubbish is a monad!
22:33:39 <carter> :)
22:33:52 <Iceland_jack> It's a Rubbish monad but still :)
22:34:09 <sgronblo> Write a blog post
22:34:12 <carter> Iceland_jack: everything runs in unit time?
22:34:14 <sgronblo> Monads are rubbish
22:34:34 <Iceland_jack> sgronblo: Yes the word needs more of those monad blog posts
22:35:50 <pyon> Iceland_jack: It is also simultaneously a covariant and a contravariant functor! :-)
22:36:10 <sdf_> Is there a better way to consume AMQP messages forever than to just put a getLine after subscribing like in the example here: http://hackage.haskell.org/package/amqp-0.8.2/docs/Network-AMQP.html
22:36:20 <Iceland_jack> pyon: With all those fancy words, it must be useful!
22:37:10 <erisco> Wizek I cannot figure out another way to map the return value
22:37:17 <sgronblo> Anyway our rubbish nodejs callback hell with async.waterfall feels like it could be improved a lot by do notation
22:37:32 <sgronblo> And thats where I started philosophising whether promises are monads
22:37:44 <erisco> despite the new meta programming added with type families I still cannot get away from enumerating all cases explicitly... recursive meta programming is evidently still difficult
22:37:48 <sgronblo> I think promises in JS are mostly used like futures anyway
22:38:23 <erisco> closed classes like we have closed type families would at least help
22:38:50 <jedws> sgronblo AFAIK that is true, the problems come in that they have an undisciplined bind/map
22:39:06 <Iceland_jack> I hear jQuery is a monad! *waits*
22:39:28 <sgronblo> gonads are monads
22:39:34 <Iceland_jack> god I hated that video
22:39:36 <carter> nooooo
22:39:38 <sgronblo> haha
22:39:41 <carter> don't talk about that stuff
22:39:49 * Iceland_jack puts blanket over carter
22:39:51 <Iceland_jack> I'm sorry.
22:39:58 <carter> Iceland_jack: hows the hardware hacking?
22:40:01 <jedws> carter there, there
22:40:02 <carter> (am i remembering right?)
22:40:23 <StoneCypher> Iceland_jack: http://i.stack.imgur.com/ssRUr.gif
22:40:23 <Iceland_jack> carter: Yes you are :) I'm programming the EDSL atm
22:40:40 <Iceland_jack> StoneCypher: hah ;)
22:40:47 <sgronblo> when i watched it I had an even more incomplete understanding than I do now, but I could still feel that mr crockford didnt really know what he was talking about.
22:40:57 <StoneCypher> crockford is like joe armstrong
22:40:59 <erisco> or a way to use type families in instance heads would be nice
22:41:00 * Iceland_jack . o O ( Blankets actually form monads )
22:41:09 <erisco> then you could more easily disambiguate your instances
22:41:13 <StoneCypher> he lives in this weird nether space between approx 5/6 really getting it and 1/6 just not getting it at a blinding level
22:41:21 <carter> erisco: data families ftw!
22:41:36 <Iceland_jack> sgronblo: So the thing is, the definition of monads are so simple people think there must be more to them so they start projecting all sorts of properties of what they 'must be'
22:41:37 <erisco> carter, ah I suppose I have not looked at data families yet
22:41:38 <sgronblo> are you sure crockford really got 5/6
22:41:45 <erisco> I did not understand them when I read the docs
22:41:47 <carter> data families have injectivity
22:41:51 <erisco> anyone care to help? :)
22:41:55 <carter> ie the type determines the constructor
22:42:02 <carter> and vice versa
22:42:10 <carter> type families don't have that bi directional property
22:42:16 <sgronblo> yeah for me i had been mystified by monads for a long time, reading a few tutorials here and there but not really having time to use haskell
22:42:35 <carter> look at how vector is designed if you wanna see a good example of a data families api
22:43:00 <sgronblo> but now i think the definition is quite simple and was able to bring up one of my coworkers to almost the same level as me in the span of one lunch break
22:43:21 <Iceland_jack>     ☑ return ∶ a → M a
22:43:21 <Iceland_jack>     ☑ bind ∶ M a → (a → M b) → M b
22:43:21 <Iceland_jack>     ☑ Satisfies unit/associativity laws
22:43:21 <Iceland_jack> boom, M is a monad
22:43:40 <Iceland_jack> for M = lists, return is trivial
22:44:00 <Iceland_jack> and the laws are trivial as well when you stop formulating them in terms of bind (>>=) and use (>=>) instead
22:44:43 <Iceland_jack> Unit laws:
22:44:43 <Iceland_jack>     return >=> f = f
22:44:43 <Iceland_jack>     f >=> return = f
22:44:43 <Iceland_jack> which are just like
22:44:46 <Iceland_jack>     0 + a = a
22:44:49 <Iceland_jack>     a + 0 = a
22:44:53 <pyon> Iceland_jack: Using Kleisli is cheating.
22:44:57 <Iceland_jack> pff
22:45:39 <Iceland_jack> and associativity laws:
22:45:39 <Iceland_jack>     (f >=> g) >=> h = f >=> (g >=> h)
22:45:39 <Iceland_jack> just like
22:45:42 <Iceland_jack>     (a + b) + c     = a + (b + c)
22:46:37 <Iceland_jack> It's like asking someone 'what's the deal with numbers?'
22:46:37 <pyon> The real fun is using 'pure', 'join' and commutative diagrams where the objects are functors and the arrows are natural transformations.
22:46:54 <Iceland_jack> the real fun is then string diagrams :)
22:47:24 <urbanslug> How can I have yesod installed but runhaskell still says it can't find it?
22:47:30 <urbanslug> or ghci etc
22:47:54 <pyon> urbanslug: ghc-pkg list | grep yesod
22:48:19 <dmj`> urbanslug: are you using a sandbox
22:48:57 <urbanslug> dmj`: Yes
22:49:11 <urbanslug> but I added the sandox's /bin to path
22:49:16 <urbanslug> *PTH
22:49:20 <urbanslug> *PATH
22:49:45 <urbanslug> pyon: Nothing FML
22:49:52 <pyon> urbanslug: That is why.
22:50:04 <pyon> urbanslug: ghc is not finding it as a registered installed package.
22:50:04 <dmj`> urbanslug: cabal sandbox hc-pkg list | grep yesod
22:50:44 <urbanslug> I thought building yesod in a sandbox would give me an executable I could just move into .cabal/bin
22:50:45 <dmj`> why not use cabal run ?
22:50:51 <urbanslug> but no
22:51:01 <urbanslug> dmj`: I didn't know of cabal run
22:51:29 <dmj`> urbanslug: In snap after I cabal install --only-depencies and cabal build web I just run it like dist/build/web/web -p 2222
22:51:37 <ddere> urbanslug: you also shouldn't have to add a sandbox /bin to your PATH
22:51:39 <urbanslug> SO now I have to learn yesod while restricted to a sandbox?
22:51:52 <ddere> urbanslug: yesod-bin would result in a binary
22:52:12 <urbanslug> ddere: let me try that
22:52:32 <ddere> urbanslug: the yesod package would just have the libs to build your yesod app
22:54:11 <urbanslug> ddere: This from cabal install --only-dependencies "cabal: No cabal file found."
22:54:37 <dmj`> are you sure you're in your project's working directory
22:54:40 <ddere> urbanslug: i should ask which binary in particular you are after?
22:55:15 <urbanslug> ddere: I am trying to learn yesod so I am in a directory I just created.
22:55:16 <ddere> the one for your yesod web app or the "yesod" bin specifcially, the one you would run with "yesod devel"
22:55:30 <urbanslug> ddere: I don't have a web app yet.
22:55:50 <ddere> ok well you willneed the yesod binary for that, `cabal sandbox init; cabal install yesod-bin`
22:56:22 <ddere> urbanslug: and try removing the sandbox from your PATH
22:56:27 <dmj`> urbanslug: I'm sure when you call yesod init a cabal file gets generated.
22:56:58 <ddere> dmj`: I could be wrong but i believe he doesnt have the yesod binary to call `yesod init` with yet
22:57:13 <urbanslug> ddere: You're right
22:57:34 <urbanslug> and typing in frustration is giving my pinky finger RSI
22:57:54 <dmj`> ddere: oh I see, good point
22:58:00 <urbanslug> ddere: So with the yesod binary I will be ok?
22:58:05 <dmj`> urbanslug: do you use emacs?
22:58:17 <ddere> urbanslug: `cabal install yesod-bin`, if you do that in a sandbox, it'll give you a bin you can move to ~/.cabal/bin
22:58:33 <urbanslug> The tutorial talked of a need to install yesod-platform.
22:58:40 <ddere> urbanslug: yeah you would be ok with the yesod binary
22:58:42 <urbanslug> dmj`: Yes I use emacs
22:58:55 <urbanslug> dmj`: It's not emacs fault.
22:58:56 <ddere> urbanslug: I personally get away with not installing yesod-platform
22:58:57 <urbanslug> lol
22:58:59 <dmj`> urbanslug: there's always snap :P
22:59:30 <urbanslug> dmj`: I was writing rails before I started on haskell so I want something closer to rails.
22:59:54 <urbanslug> I heard that yesod is the closest to rails.
23:00:14 <urbanslug> but it doesn't mention being MVC which is worrying.
23:01:35 <zRecursive> urbanslug: i suggest you stay with Rails though
23:02:02 <klugez> urbanslug: It's at least roughly MVC. Database models with persistent, templates with hamlet and handler functions as controllers.
23:02:37 <urbanslug> zRecursive: Why?
23:03:16 <urbanslug> zRecursive: Why stay with rails? I have put a lot of effort learning haskell and all its math things.
23:03:19 <zRecursive> just personal feeling
23:03:44 <StoneCypher> urbanslug: if you want rails, probably don't try to turn something else into it
23:04:05 <StoneCypher> imo, ymmv
23:04:26 <urbanslug> zRecursive: lol I don't like what you are saying. Are you implying that I am intellectually inferior or unable to learn?
23:04:39 <zRecursive> no
23:04:39 <sgronblo> Thats what it sounds like to me :)
23:04:46 <urbanslug> sgronblo: IKR?
23:04:51 <Iceland_jack> urbanslug: It sounded more to me like zRecursive was saying that RoR was better
23:05:03 <urbanslug> sgronblo: I should grab zRecursive by the collar.
23:05:18 <urbanslug> Iceland_jack: Oh well there is no better
23:05:27 <sgronblo> Why would anyone doing Haskell recommend RoR? :)
23:05:38 <urbanslug> It's all about trying out new things.
23:05:38 <Iceland_jack> sgronblo: It depends on what your needs are
23:05:42 <klugez> urbanslug: I recommend reading the yesod book, which is available at http://www.yesodweb.com/book
23:05:45 <zRecursive> you should embrace yesod and forgetting Rails temporarily
23:05:52 <sgronblo> Dynamic typing + monkey patching
23:05:57 <urbanslug> klugez: I am reading that book.
23:05:58 <Iceland_jack> Haskell has a very different focus than Ruby
23:07:50 <urbanslug> It's very weird how you people are telling me not to learn yesod. Of course it's going to be different and that's what life is about YOLO!
23:07:57 <aviraldg> Hey. Could someone help me understand how composed functions (where each function has multiple arguments) are applied (in terms of the order of the parameters?) I did some tests, but I'd like it stated formally somehow. ie. ((+) . (*3)) - how do you parse this mentally and where does each function parameter "go"? I have some intuition about how fmap works on Functors, but this seems to work in a different way: ie. ((+) . (*3)) 3 4 == 13, not 15
23:07:59 <fragamus> I need a stateful pipes example
23:08:32 <Iceland_jack> aviraldg: Check out the definition of (.)
23:08:32 <Iceland_jack> @src (.)
23:08:32 <lambdabot> (f . g) x = f (g x)
23:08:32 <lambdabot> NB: In lambdabot,  (.) = fmap
23:08:38 <Iceland_jack> and see if you can figure it out :)
23:08:43 <ddere> urbanslug: I think yesod is worthwhile learning, but its hard to find good learning material forit
23:08:51 <Iceland_jack> (namely, replacing f with (+) and g with (*3))
23:09:13 <aviraldg> Yeah, I kind of have it figured out where you have functions with single arguments. More than that? Nope :(
23:09:15 <dmj`> > ((+1) . (+1)) $ 2
23:09:16 <lambdabot>  4
23:09:16 <ddere> urbanslug: I found the yesod book to be great for illustrating the broad strokes, but when i sat down and treied to actually do anything i found it hard to do the simple little things
23:09:54 <sgronblo> Dont stay with Rails, get away from dynamic typing while you have the chance
23:10:04 <zRecursive> ddere: same feeling
23:10:07 <ddere> urbanslug: theres a very small part of that API that you need to get started, and its hard to find that in all the existing documentation.  a lot of whats in the book is kind of automated now with template haskell
23:10:25 <shanks29> hi all
23:10:27 <Iceland_jack> aviraldg: Let me walk you through it :)
23:10:27 <Iceland_jack>       ((+) . (* 3)) 3 4
23:10:27 <Iceland_jack>     = (((+) . (* 3)) 3) 4
23:10:27 <Iceland_jack>     ⇒ ((+) ((* 3) 3)) 4
23:10:30 <Iceland_jack>     = ((+) 9) 4
23:10:33 <Iceland_jack>     = 9 + 4
23:10:37 <Iceland_jack>     = 13
23:10:44 <shanks29> i have a beginner issue with writing an int to a file
23:11:03 <Iceland_jack> aviraldg: Recall that
23:11:03 <Iceland_jack>     a b c d
23:11:03 <Iceland_jack> is
23:11:03 <Iceland_jack>     ((a b) c) d
23:11:04 <ddere> urbanslug: its great once you get into the groove of it, the learning curve is just really steep and doesnt feel too rewarding until you get to the other side
23:11:23 <Iceland_jack> shanks29: writeFile "/tmp/foobarint" (show 5) :)
23:11:26 <dmj`> @typ writeFile "file.txt" $ show 1
23:11:27 <lambdabot> IO ()
23:11:41 <aviraldg> So they're applied from the innermost function to the outermost?
23:11:46 <ddere> zRecursive: :)
23:11:50 <aviraldg> (going left to right)
23:12:17 <Iceland_jack> aviraldg: Yes, left to right: do you understand how 'multi-argument' functions work in Haskell?
23:12:31 <aviraldg> Yeah
23:12:44 <Iceland_jack> That when you have a function
23:12:45 <Iceland_jack>     plus :: Int -> Int -> Int
23:12:45 <Iceland_jack> it doesn't actually take two arguments
23:12:55 <aviraldg> Yep, read up on currying
23:13:00 <Iceland_jack> in that case
23:13:00 <Iceland_jack>     plus 4 10
23:13:00 <Iceland_jack> is
23:13:00 <Iceland_jack>     (plus 4) 10
23:13:09 <Iceland_jack> where 'plus 4' is a new function
23:13:19 <shanks29> I have a line that takes a read file (a txt file with a list of numbers) and adds them together and prints the sum
23:13:22 <shanks29> print $ foldl (+) 0 $ convert $ lines contents
23:13:29 <shanks29> this works fine
23:13:50 <shanks29> but when i replace "print" with "writeFile outFile" it doesn't work
23:13:58 <shanks29> works fine as in it prints to stdout
23:14:07 <Iceland_jack> shanks29: because you need show
23:14:12 <Iceland_jack> The types are different
23:14:14 <Iceland_jack> :t print
23:14:15 <lambdabot> Show a => a -> IO ()
23:14:18 <Iceland_jack> :t writeFile "file"
23:14:19 <lambdabot> String -> IO ()
23:14:37 <Iceland_jack> However
23:14:38 <Iceland_jack> :t writeFile "file" . show
23:14:39 <lambdabot> Show a => a -> IO ()
23:14:46 <Iceland_jack> has the same type as 'print'
23:14:58 <urbanslug> I built yesod-bin in a sandbox and moved the binaries to ~/.cabal/bin. I can run yesod init successfully but for some reason it still can't find the yrsod module.
23:15:00 <Iceland_jack> aviraldg: Do you understand the composition example above?
23:15:43 <ddere> urbanslug: the yesod module doesnt get installed with yesod-bin
23:15:48 <shanks29> now i get an error saying 2.txt: openFile: resource busy (file is locked)
23:15:52 <startling> urbanslug: why would you move the binaries to ~/.cabal/bin?
23:16:05 <startling> you can just add whatever to your $PATH instead.
23:16:11 <shanks29> how do i "unlock" this file to write to it?
23:16:29 <shanks29> i already created a handle to open the file in writemode
23:16:48 <ddere> startling: he built it in a sandbox, its probably not worthwhile for him to add a sandbox bin dir to his path
23:17:02 * startling shrugs
23:17:03 <aviraldg> Iceland_jack, yep, thanks :)
23:17:13 <ddere> ~/.cabal/bin is likely to be in his PATH
23:17:18 <Iceland_jack> aviraldg: It feels more complicated because you example had operators
23:17:47 <urbanslug> ddere: How did I get the yesod module then?
23:17:51 <aviraldg> Becomes more obvious when you rewrite it as (+ (* 3)) and apply the left-to-right rule
23:18:09 <urbanslug> I added the sandbox's bin/ to my PATH but still nothing
23:18:12 <Iceland_jack> aviraldg: well I didn't rewrite it as (+ (* 3)) because that would be adding a function :
23:18:12 <ddere> urbanslug: check the .cabal file in the generated project, it should list yesod as a depdencies
23:18:13 <Iceland_jack> :)
23:18:27 <shanks29> okay, i got it to work... basically the reason it was locked was that I opened a handle for the file to write to, but then used writeFile directly on the filename... resulting in the previously opened handle to conflict with it
23:18:58 <shanks29> Iceland_jack: thanks for your help!
23:19:00 <ddere> urbanslug: if its in there, running (`cabal sandbox init` first) `cabal install --only-dependencies` should install it for you
23:19:05 <Iceland_jack> shanks29: You're welcome!
23:19:15 <Iceland_jack> aviraldg: See how much simpler it is!
23:19:15 <Iceland_jack>       (plus . mult 3) 3 4
23:19:15 <Iceland_jack>     = ((plus . mult 3) 3) 4
23:19:15 <Iceland_jack>     ⇒ (plus (mult 3 3)) 4
23:19:18 <Iceland_jack>     = (plus 9) 4
23:19:21 <Iceland_jack>     = plus 9 4
23:19:39 <Iceland_jack> I flipped the mult for simplicity
23:20:42 <aviraldg> Yeah!
23:20:46 <zRecursive> a bit like lisp code ;)
23:21:13 <Iceland_jack> ((comp plus (partial mult 3)) 3 4) :)
23:21:38 <zRecursive> hehe
23:22:04 <urbanslug> ddere: I have cabal.sandbox.config as the only file there
23:22:22 <zRecursive> sometimes lisp form is helpful  for understand haskell code
23:22:33 <Iceland_jack> zRecursive: Really?
23:22:40 <Iceland_jack> How so, is it because of fixity?
23:22:41 <zRecursive> fix f = (f (f (f ...)))
23:22:53 <ddere> urbanslug: hmm `yesod init` should have created a directory with the name you provided
23:22:55 <Iceland_jack> how is that different from
23:22:55 <Iceland_jack>     fix f = f (f (f ...))
23:22:55 <Iceland_jack> ?
23:23:02 <Iceland_jack> You just added one parentheses
23:23:13 <zRecursive> yeah
23:23:16 <erisco> mkay maybe I just need incoherent instances
23:23:18 <urbanslug> ddere: I didn't let yesod init run to the very end.
23:23:19 <Iceland_jack> Does that help?
23:23:33 <ddere> urbanslug: oh, yeah you need to do that
23:23:34 <urbanslug> ddere: let me do that
23:24:01 <zRecursive> Iceland_jack: f (f ...) == (f (f ...))  in haskell, right ?
23:24:04 <ddere> urbanslug: then navigate to that directory
23:24:13 <Iceland_jack> zRecursive: Sure
23:24:44 <Iceland_jack> Parentheses are fundamentally different in Haskell and Lisp
23:25:13 <zRecursive> yeah
23:26:04 <urbanslug> ddere: Yeah, seems to be installing.
23:26:29 <ddere> urbanslug: cool, so you've run `cabal install --only-dependencies` in that dir?
23:26:39 <urbanslug> ddere: yeah
23:26:59 <ddere> urbanslug: did you create another sandbox in that dir?
23:27:05 <urbanslug> I'm waiting for it to cmpile
23:27:09 <dmj`> given a balanced binary tree of integers is there a way to use parallelism to sum all the elements
23:27:19 <dmj`> like a parallel fold
23:27:26 <urbanslug> ddere: Yes I ran sandbox init
23:27:53 <ddere> urbanslug: awesome, hopefully the tutorial should work out for you now
23:30:05 <urbanslug> ddere: You see yesod init generated a direcory and that is why my sandbox is. Are you saying that I will have to do stuff from that directory? Adding the generated /bin to my PATH will make it so much easier.
23:32:01 <ddere> urbanslug: there shouldnt be any reason to add a directory in your sandbox to your PATH, by their very nature, you would have one of those for every haskell project you work on, it doesnt really scale
23:32:30 <ddere> `yesod devel` will run the binary that is a product of your project
23:32:44 <ddere> urbanslug: (which isnt in your sandbox anyway)
23:33:29 <urbanslug> ddere: OMG haskell is messed up. So I will have sandboxes all over?
23:33:47 <urbanslug> SMH I try to minimize the number of sandboxes for some reason.
23:34:24 <ddere> urbanslug: In terms of "where you need to do stuff" you need to do stuff where the .cabal file is, and cabal only uses the sandbox thats in the same dir as the cabal file, so you need a sandbox at the same level as the cabal file
23:35:27 * hackagebot shakespeare 2.0.0.3 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.0.3 (MichaelSnoyman)
23:35:41 <ddere> urbanslug: the point of the sandbox is to insulate one projects dependencies from one another, otherwise a problem you are likely (incredibly likely to come across with yesod) are conflicts in the versions of deps installed
23:36:15 <yezariaely> is there a short form of creating an instance of a record? I don't want to write Record {a1 = 1, a2 = 2} but Record 1 2 and order should be definition order?
23:36:38 <ddere> urbanslug: you want one for each project (but realistically if you are working on multiple projects and one of them depends on others, you can work from one sandbox, but deal with learning that later
23:36:43 <eatman> Hello
23:36:43 <pingu> yezariaely: yes, you can do precicely that
23:36:52 <yezariaely> oh, really?
23:36:54 <Iceland_jack> yezariaely: You can write 'Record 1 2'
23:37:20 <urbanslug> ddere: I guess I have experienced a similar behaviour with rails and Gemfiles.
23:37:23 <Iceland_jack> you can also write
23:37:23 <Iceland_jack>     let a1 = 1
23:37:23 <Iceland_jack>         a2 = 2
23:37:23 <Iceland_jack>      in Record{..}
23:37:26 <Iceland_jack> with the RecordWildCards extension
23:37:41 <pingu> that's weird. I've never seen that.
23:38:08 <Iceland_jack> Most people only know about using wildcards for *unpacking* a record
23:38:10 <yezariaely> pingu:  Iceland_jack thanks and sorry, I tried that but probably had a typo somewhere. Sorry :/
23:38:13 <Iceland_jack> but it also works for packing one
23:38:25 <Iceland_jack> yezariaely: No need to apologize :)
23:38:26 <ddere> urbanslug: i've gotten used to it and dont find it that "messed up", but its all relative, you can try not bothering with sandboxes at all and experience the problem it tries to solve (and its not the best solution admittedly)
23:38:40 <urbanslug> Which is what we are calling a .cabal file.
23:39:05 <urbanslug> ddere: Yeah I've been stuck in cabal hell once.
23:44:16 <aviraldg> Iceland_jack, nope, still confused :(
23:44:41 <Iceland_jack> aviraldg: Still confused with what? :)
23:45:03 <aviraldg> Why is :t ((+) . (*)) :: a -> (a -> a) -> a -> a and not a -> a -> a -> a?
23:45:39 <Iceland_jack> the type of (.) is (b -> c) -> (a -> b) -> a -> c
23:45:55 <Iceland_jack> and you're fitting (+) and (*) as its first and second argument
23:46:16 <urbanslug> ddere: Yeah I think it worked. `cabal sandbox hc-pkg list | grep yesod' finds but ghci can't find it. Mind telling me why this is happening?
23:46:20 <Iceland_jack> in fact, the type is a bit different from what you wrote
23:46:22 <Iceland_jack> :t ((+) . (*))
23:46:23 <lambdabot> (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
23:46:42 <Iceland_jack> It requires _functions_ to be numbers
23:46:42 <Iceland_jack>     (Num (a -> a), ...) => ...
23:46:58 <Iceland_jack> You may want something like (.:) = (.) . (.)
23:47:11 <Iceland_jack> :t let (.:) = (.).(.) in (+) .: (*)
23:47:12 <lambdabot> Num b => b -> b -> b -> b
23:47:22 <Iceland_jack> but that may be needlessly complicated
23:48:01 <Iceland_jack> a better way would be to just write
23:48:01 <Iceland_jack> @ty \a b c -> a + b * c
23:48:03 <lambdabot> Num a => a -> a -> a -> a
23:48:21 <ddere> urbanslug: ah ghci can't ordinarily find anything in your sandbox, try `cabal repl` that will load up ghci with the sandbox stuff and try to interpret your source
23:48:39 <aviraldg> `It requires functions to be numbers`? (btw, what exactly does Num (a -> a) mean?)
23:48:55 <aviraldg> Yeah, but I'm trying to understand (.) here ;)
23:48:59 <Iceland_jack> aviraldg: Num (a -> a) means exactly that :) 'a -> a' must be a number
23:49:26 <Iceland_jack> well okay, the actual response is: you can write that with (.)
23:50:01 <Iceland_jack> If you _must_ you may write it as
23:50:02 <Iceland_jack> :t ((+) .) . (*)
23:50:03 <lambdabot> Num b => b -> b -> b -> b
23:50:38 <Iceland_jack> > (((+) .) . (*)) 10 15 8
23:50:40 <lambdabot>  158
23:51:01 <Iceland_jack> > let (.:) = (.).(.) in ((+) .: (*)) 10 15 8
23:51:02 <lambdabot>  158
23:51:24 <Iceland_jack> You said you wanted to understand (.) and (.:) is built on top of that :)
23:52:32 <aviraldg> Hmm ... how would you call ((+) . (*)) ?
23:52:49 <Iceland_jack> You wouldn't :)
23:52:57 <aviraldg> If you had to?
23:53:17 <geekosaur> uggg. I'm not going to be allowed to sleep tonight, am I? (the cpp issue)
23:53:22 <aviraldg> Num (a -> a) is what's tripping me up there.
23:53:49 <aviraldg> Is that the same as (Num a) => a -> a?
23:53:52 <Iceland_jack> no
23:53:57 <Iceland_jack> like I said, it means that functions are numbers
23:54:01 <Iceland_jack> so you can add two functions
23:54:16 <Iceland_jack> or multiply two functions
23:54:29 <MP2E> Category theory is truly a beautiful thing
23:54:43 <aviraldg> * head scratching intensifies *
23:54:49 <ddere> urbanslug: did it work?
23:55:08 <Iceland_jack> Right.. so I think a better exercise would be to unfold the definition of (.) for your example above
23:55:21 <Iceland_jack> and see why it's not a jolly thing to do
23:55:24 <augur> aviraldg: it might be good if you expanded (+) . (*)
23:55:40 <Iceland_jack> Indeed
23:56:50 <urbanslug> ddere: What did cabal repl just do? Will it make runhaskell also work?
23:56:55 <dveim> hello
23:56:57 <augur> aviraldg: so, throw in some vars:   (+) . (*)   =>   (+) (*x)   =>   (*x) + y   and bind them:   \x y -> (*x) + y
23:57:12 <augur> aviraldg: so you see, that expression is trying to add (*x) to y
23:57:20 <urbanslug> ddere: Ignore that question
23:57:25 <augur> aviraldg: does that much make sense, at least?
23:57:32 <dveim> can you suggest some useful libraries for building convex polygon intersection & union?
23:57:37 <urbanslug> ddere: Cabal repl is run from ghci
23:58:19 <urbanslug> ddere: I wanna see this first example http://www.yesodweb.com/book/basics in localhost
23:58:46 <ddere> urbanslug: it runs ghci with some extra flags, `cabal build` would do what runhaskell was doing before i suppose
23:59:26 <augur> aviraldg: so what is the type of x? well, some `a', provided `a' is a number; so (*x) is a -> a, and y must also be a -> a, and the sum of them must also therefore be a -> a. so the function has type a -> (a -> a) -> a -> a
23:59:56 <augur> aviraldg: but with two caveats: first, a has to be a number, or, well, a Num, at least. but a -> a _also_ has to be a Num, cause you're using + on it
