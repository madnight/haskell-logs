00:05:50 <cwvh> eiro: print =<< sizes . map read . offsets <$> getArgs
00:08:09 * hackagebot riak-protobuf 0.16.0.2 - Haskell types for the Riak protocol buffer API  http://hackage.haskell.org/package/riak-protobuf-0.16.0.2 (MarkHibberd)
00:08:09 * hackagebot riak 0.7.0.3 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.7.0.3 (MarkHibberd)
00:11:33 <eiro> cwvh, TMI for today. thanks anyway
00:12:54 <haasn> cwvh: print . sizes . map read . offsets =<< getArgs
00:13:04 * hackagebot hsdev 0.1.0.0 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.0.0 (AlexandrRuchkin)
00:28:29 <nwf> Hey channel; is there a way in a .lhs file to hide code from LaTeX but still have it go through to the compiler?  In particular, I need some language pragmas at the top that I don't want in the TeX rendering.
00:29:35 <nwf> Ah ha, the wiki has it.  Carry on, then.
01:06:21 <jakex> what was that syntactic sugar that makes `foo >>= \bar -> case bar of' shoter?
01:07:32 <pyon> jakex: foo >>= \case
01:07:42 <pyon> jakex: {-# LANGUAGE LambdaCase #-}
01:08:06 <jakex> thanks. I actually tried that, but just got a parsing error, and not a suggestion to use that extension.
01:08:08 * hackagebot hslua 0.3.11 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.11 (OmerAgacan)
01:08:44 <jtcwang> hey ppl, can anyone tell me what otraverse_ do?
01:09:30 <jtcwang> i think its related to Traversable, but i can't seem to find good information on it
01:09:31 <skypers> I was about to get desperate about Haskell and games
01:09:37 <skypers> then I read the Frag source
01:09:42 <skypers> and now it’s way better :)
01:09:46 <jle`> :)
01:09:52 <skypers> plus, it has a few dependencies
01:09:55 <skypers> totally rocks
01:12:07 <cloudpirate> dsa
01:12:14 <cloudpirate> ;afds
01:12:18 <cloudpirate> ;aoe4arogjia
01:12:19 <cloudpirate> sl;faskdj
01:12:19 <cloudpirate> asdf
01:12:20 <cloudpirate> asd
01:12:20 <cloudpirate> fagrh
01:12:21 <cloudpirate> yhjty
01:12:21 <cloudpirate> jrty
01:12:22 <cloudpirate> j
01:12:23 <cloudpirate> fg
01:12:29 <cloudpirate> herp a derp
01:12:36 <merijn> @where ops
01:12:36 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
01:12:45 --- mode: ChanServ set +o shachaf
01:12:50 --- mode: shachaf set +b *!*6ca17b24@*.108.161.123.36
01:12:50 --- kick: cloudpirate was kicked by shachaf (cloudpirate)
01:12:54 --- mode: shachaf set -o shachaf
01:18:20 * palo has some questions about working with leksah, or in general. I wanna craeate an awesome bin. And start with creating the data + data-functions, I wanna test them interactive and later using unit tests. Any impressions? 
01:19:05 <palo> I mean, any advice about some technics or tools?
01:23:51 <merijn> palo: For testing QuickCheck and hunit are probably the way to go
01:26:20 <palo> merijn: thx. I'll have a look at that,
01:27:30 <johnw> I find hspec an easy way to setup testing with hunit
01:28:18 <supki> and quickcheck
01:33:10 * hackagebot app-settings 0.1.0.3 - A library to manage application settings (INI file-like)  http://hackage.haskell.org/package/app-settings-0.1.0.3 (EmmanuelTouzery)
01:33:12 * hackagebot hsexif 0.1.0.1 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.1.0.1 (EmmanuelTouzery)
01:49:14 <osa1> any ideas why !false condition in Cabal is not executed?
01:56:54 <pavonia> Is there a way to pattern match on the first n characters of a ByteString?
01:57:32 <shachaf> You can use a view pattern.
01:58:16 <shachaf> A while ago I used something like unconsN :: Int64 -> B.ByteString -> ([Word8], B.ByteString); unconsN i (B.splitAt i -> (vals, rest)) = (B.unpack vals, rest)
01:58:19 <Yuu_chan> shachaf: I know of active patterns in F#, are they similar?
01:58:33 <shachaf> I think GHC 7.8 has a fancy new mechanism for pattern synonyms or something, but I haven't looked into it.
01:58:36 <shachaf> Yuu_chan: I don't know.
01:59:01 <Yuu_chan> @google haskell view patterns
01:59:01 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
01:59:41 <pavonia> shachaf: So I would convert the ByteString to a String and match on that?
01:59:52 <merijn> Yuu_chan: view patterns are essentially "first apply a function, then pattern match the result"
02:00:00 <shachaf> pavonia: No, ByteString is a different type from String, you can't really "convert".
02:00:12 <merijn> "can't really" -> really can't
02:00:35 <shachaf> String (and Text) a sequence of characters, as in [Char]. ByteString is a sequence of bytes, as in [Word8].
02:00:48 <pavonia> Well, I want something like "case bs of (c : d : cs) -> ..."
02:01:00 <pavonia> Yeah, I know that
02:02:12 <merijn> pavonia: I would use a view pattern, ByteString has "unpack :: ByteString -> [Word8]" so using a view pattern you could match on that. Or just do "case unpack bs of (c:d:cs) -> ..."
02:02:30 <shachaf> Oh, you don't need the thing I wrote, of course.
02:02:34 <shachaf> That was for a very specific use case.
02:02:46 <shachaf> (Or do you?)
02:03:02 <shachaf> merijn: unpack as a view pattern won't give you the rest of the ByteString.
02:03:08 <pavonia> Okay, that looks nice
02:03:39 <merijn> shachaf: True
02:03:49 <merijn> pavonia: So it kinda depends on what you want
02:04:09 <merijn> Do you want "1 byte" + ByteString, a list of bytes, or...?
02:04:50 <pavonia> merijn: No, something like checking different prefixes of a ByteString
02:05:03 <pavonia> and then processing the rest of the string
02:05:43 <merijn> pavonia: There a lots of functions for finding prefixes and splitting ByteString already in Data.ByteString
02:05:51 <merijn> Have you tried those instead of pattern matching?
02:06:47 <pavonia> It's not a fixed prefix but more like checking several predicates for individual chars
02:06:58 <Yuu_chan> merijn: will (a :: ByteString) == pack (b :: [Word8]) be faster than unpack a == b?
02:07:17 <merijn> Yuu_chan: No clue
02:07:30 <merijn> Interesting question
02:07:31 <pavonia> I see there's Data.ByteString.Char8, is that Char8 equal to a normal Char (clipped to ASCII)?
02:07:50 <merijn> pavonia: No, Char8 is an abomination
02:07:59 <shachaf> Char8 is evil and you shouldn't use it unless you know what you're doing.
02:08:14 <shachaf> Hmm, is there really no web page to link to that explains Char8?
02:08:35 <merijn> shachaf: Not sure, I should probably write one instead of manually ranting against it every time someone asks...
02:08:37 <pavonia> It links to Data.Char, which is weird
02:08:47 <shachaf> Data.ByteString.Char8.ByteString is the same type as Data.ByteString.ByteString, except that all the functions pretend that a Char is a byte.
02:08:50 <shachaf> Which it isn't.
02:09:08 <Yuu_chan> merijn: I heard that pack "someLiteral" can be eliminated in compile-time due to term rewriting, but it's Char8 again
02:09:11 <merijn> Which also means it'll silently drop stuff and corrupt your data
02:09:36 <pavonia> That sound exactly like what I want :D
02:09:48 <shachaf> Maybe you should want better things.
02:09:52 <merijn> Yuu_chan: String literals are compiled as dense blobs and Text/ByteString use rules to abuse that fact to be more efficient
02:10:31 <merijn> pavonia: You still haven't mentioned your actual usecase, so we still can't really help you do what you're actually trying
02:11:02 <shachaf> (Sometimes Char8 is indeed what you want, or the lesser among a few evils. But more often people want it because it's convenient, and it just encourages them to write bad code.)
02:11:50 <merijn> Char8 is like threads in C/Python, if you need to ask whether you want them, you don't know enough to safely use them yet.
02:12:19 <Yuu_chan> Why Data.Text.take is O(n)?
02:12:53 <merijn> Yuu_chan: Well, what else would it be?
02:13:30 <shachaf> Yuu_chan: Because Data.Text is represented as UTF-16 internally.
02:13:58 <Yuu_chan> It depends. Its ByteString counterpart is O(n). This one may treat surrogate part and be O(n) in worst case. That was my question
02:14:11 <pavonia> Hhm, not sure how to put that properly ... I want to tokenize a sequence of bytes with the result being of type [Annotated String] where each charcter in String is an character in the byte range
02:14:12 <Yuu_chan> s/O(n)/O(1)
02:14:23 <Yuu_chan> s/part/pairs
02:14:47 <shachaf> Yuu_chan: It's O(n) in every case.
02:16:09 * Yuu_chan hasn't fully цщлут гз нуе
02:16:27 <orion> Do Haskell programmers often find themselves designing applications from the bottom up or the top down?
02:17:33 <pavonia> I usually start top-down but finally end up bottom-up :p
02:17:36 <Yuu_chan> orion: I personally try top-down
02:17:52 <merijn> orion: I do both alternatingly :p
02:18:10 <merijn> I do top-to-middle and bottom-to-middle design :p
02:18:14 * hackagebot control-monad-exception 0.11.1 - Explicitly typed, checked exceptions with stack traces  http://hackage.haskell.org/package/control-monad-exception-0.11.1 (PepeIborra)
02:18:37 <pavonia> merijn: Exactly that!
02:18:56 <merijn> orion: Generally I also start by writing down datatypes and type signatures leaving most implementation empty
02:19:19 <merijn> An approach greatly helped by 7.8's TypeHoles :)
02:19:27 <merijn> Or was it TypedHoles? I forget
02:21:42 <exicer> How much pain will I go through installing 7.8 on mavericks ?
02:22:24 <merijn> exicer: It should just work, afaik?
02:22:53 * merijn is still waiting for the 7.8 platform release before finally upgrading to Mavericks >.>
02:22:57 <exicer> Awesome
02:23:09 <exicer> Just wanted to make sure :p
03:03:18 * hackagebot marmalade-upload 0.6 - Upload packages to Marmalade  http://hackage.haskell.org/package/marmalade-upload-0.6 (lunaryorn)
03:33:01 <sunjazz> how do I confgure Emacs/haskell-mode to send current line (if possible, expression) to REPL via some keyboard shortcut?
03:34:24 <foobarrr> l
03:34:42 <foobarrr> is there a term for a value that isn't a function?
03:34:54 <shachaf> Not really.
03:35:10 <merijn> "non-function value"? :)
03:35:31 <johnw> foobarrr: some languages call them "atoms"
03:35:41 <foobarrr> Hm, okay
03:36:32 <shachaf> Huh?
03:36:35 <shachaf> Oh, never mind.
03:36:36 <foobarrr> Somehow felt like that deserved a name of its own
03:36:56 <shachaf> There're rarely names for things that *aren't* something.
03:37:04 <shachaf> Just like it's kind of awkward to talk about types that don't unify.
03:37:09 <unem> how can i display several pictures in haskell gloss?
03:37:27 <shachaf> id :: a -> a -- Is "a" a "non-function"? We don't know. For instance.
03:37:33 <foobarrr> shachaf: I see
03:37:43 <unem> for instance, if i want to make another circle like this one? https://hackage.haskell.org/package/gloss-examples-1.8.0.2/src/picture/Easy/Main.hs
03:37:46 <foobarrr> Haskell's type system doesn't play well with negation :)
03:37:52 <vermeille> Where can I find a Lenses tutorial with plenty of examples, and why not with exercises?
03:38:01 <Yuu_chan> shachaf: Invertebrates :)
03:38:08 <shachaf> In my head.
03:38:35 <Yuu_chan> unem: pictures [pic1, pic2, ...]
03:39:34 <unem> Yuu_chan: thanks
03:41:48 <Yuu_chan> shachaf: the whole point of monophiletic taxonomy in modern biology is to get rid of terms that mean things which "aren't something"
03:42:51 <Yuu_chan> foobarrr: another variant would be "an irreducible value"
04:26:36 <grayling_> Can anyone expain to me why this prime algoritm gets almost exponentially more time consuming as the number range grows? http://lpaste.net/103021
04:27:50 <grayling_> On my pc it takes about 237s to finish. Compared to 26s for a similar algoritm in Go.
04:29:42 <johnw> instead of counting the length of a list whose members are primes, why not just count the number of primes?
04:30:03 <johnw> for example, have isPrime return 0 or 1, and use "sum"
04:30:58 <grayling_> But if I profile it all the work happens in isPrime - not in length
04:32:47 <grayling_> And I thought it would be more functional thinking to check for primality using booleans.
04:33:20 <johnw> you want to take advantage of GHC's ability to optimize away temporary lists
04:33:49 <prophile> does isPrime take longer when you give it higher values?
04:33:53 <johnw> are you are compiling with -O2?
04:34:22 <johnw> also, without type signatures, you are defaulting to Integer
04:34:53 <grayling_> I'm compiling with -O2 yes.
04:35:12 <johnw> try adding: isPrime :: Int -> Bool
04:35:13 <grayling_> gch -O2 --make Sieve.hs
04:36:25 <jesyspa> Why check for whether n is a multiple of 2 on every step?
04:37:17 <grayling_> jesyspa: Yes that is inefficient, I know. But efficiency was not the purpose.
04:37:39 <grayling_> johnw: That took the time down to 65s
04:38:01 <grayling_> Nice
04:38:12 <johnw> I image not using "length" will help considerably as well
04:38:31 <johnw> since lists are not the cheapest things
04:38:34 <grayling_> That'll teach me to always remember types...
04:38:42 <grayling_> I'll try with sum.
04:39:12 <supki> replacing mod with rem should speed up things
04:39:26 <merijn> johnw: Shouldn't lenght and filter fuse?
04:39:41 <johnw> merijn: I wondered if they would
04:40:53 <haasn> Try skipping the even integers altogether
04:41:20 <haasn> eg. [1,3..24453435]
04:41:28 <haasn> (but be sure to account for the extra 2)
04:41:42 <grayling_> haasn: Did that. I'm starting with 3 and moving 2.
04:42:27 <haasn> seconding supki's recommendation btw, `rem` is faster than `mod` and returns the same results for non-negative integers
04:42:30 <johnw> would f > sqrt n be faster than f*f > n?
04:42:31 <haasn> it skips an extra sign check
04:42:39 <haasn> johnw: doubt it
04:42:57 <haasn> actually, maybe if the ‘n’ is shared
04:43:05 <haasn> try it!
04:43:10 <merijn> Wouldn't "testBit 0" be even faster than mod 2?
04:43:13 <haasn> Also, you could remove the ‘n’ parameter from isPrime'
04:43:14 <merijn> :t testBit
04:43:17 <lambdabot> Bits a => a -> Int -> Bool
04:43:33 <haasn> merijn: probably, but the check can be skipped either way
04:43:38 <merijn> > 3 `testBit` 0
04:43:39 <lambdabot>  True
04:43:52 <prophile> I'd imagine `rem` 2 will get eaten in the optimisations
04:44:13 <prophile> LLVM will do this sort of thing with great gusto
04:44:13 <matematikaadit> what is the difference between rem and mod?
04:44:17 <haasn> grayling_: no, you misundersatnd
04:44:23 <haasn> grayling_: not for the trial division, but for the actual list
04:44:27 <haasn> in countPrimes
04:45:09 <prophile> > 5 `rem` (-2)
04:45:10 <lambdabot>  1
04:45:14 <prophile> > 5 `mod` (-2)
04:45:16 <lambdabot>  -1
04:45:21 <prophile> matematikaadit: ^
04:45:37 <haasn> grayling_: Even if you include the check, you don't need to re-test whether n `mod` 2 == 0 on every single step of the trial division
04:45:50 <grayling_> haasn: Ah. Yes. I could do that.
04:46:34 <haasn> also johnw's f > sqrt n suggestion also makes sense, since you have a static limit instead of needing to compute f*f at every step; be wary of the types though - would need integerSquareRoot or something (from arithmoi) ideally
04:46:36 <johnw> if the input list only contains odds, we don't need the n `mod` 2 check at all
04:47:47 <matematikaadit> prophile: yes, I mean why `rem` faster than `mod` (from haasn comment above)?
04:48:20 <prophile> (`rem` 2) == (.&. 1)
04:48:33 <grayling_> Wouldn't sum demand a much longer list than filter and length?
04:49:51 <haasn> matematikaadit: I'm not actually sure but I think the gist is that there's an efficient hardware instruction for rem, and mod needs this + an extra check for the sign (to negate it afterwards)
04:55:31 <matematikaadit> oh, ok. I'll keep that in mind.
04:58:04 <dshad> does anybody know good tutorial about ST monad, using vectors, etc
05:04:08 <johnw> dshad: is that two separate questions, or do you mean using vectors with the ST monad?
05:06:30 <dshad> johnw: its one question about using ST monad, vectors are just example.
05:06:47 <grayling_> johnw: Sum takes exactly the same amount of time. 65s.
05:06:56 <johnw> grayling_: interesting, thanks
05:07:37 <grayling_> Yeah. So both must end up optimized as the same thing.
05:07:56 <grayling_> I did a sum map isPrime
05:10:38 <grayling_> The mod to rem actually did do a difference. From 64s to 48s.
05:11:27 <johnw> so it sounds like you're doing a ton of math
05:11:34 <johnw> I wonder if unboxed integers would help here
05:11:49 <MagneticDuck> hey guys, what do you think is the fastest and easiest way of getting the comment tree of a reddit post?
05:11:54 <MagneticDuck> I'm just looking for a little brainstorm
05:12:20 <MagneticDuck> the only way I can think of right now is.. perhaps some simple parsing and tagsoup?
05:12:26 <MagneticDuck> is there any reddit API out there? :D
05:12:36 * MagneticDuck searches hoogle for "reddit"
05:12:41 <johnw> @google haskell reddit api
05:12:42 <lambdabot> https://github.com/th3p1nkh4sk3llun1k0rn/reddit-api
05:12:44 <grayling_> I'll look into unboxed integers...
05:12:45 <MagneticDuck> aaand, nothing (that was dissapointing)
05:12:53 <MagneticDuck> johnw: oo cool
05:12:54 <Iceland_jack> MagneticDuck: Hoogle? Search on Hackage
05:13:04 <johnw> Hoogle searches very little
05:13:13 <MagneticDuck> Iceland_jack: oups, yeah
05:13:18 <MagneticDuck> >_<
05:13:20 <MagneticDuck> yeah to say hackage
05:13:25 <MagneticDuck> s/yeah/meant Oo
05:15:27 <MagneticDuck> pretty cool how reddit is open source
05:18:58 <d3lxa> how can I runhaskell with a cabal sandbox?
05:23:34 <mmmm> you mean something like cabal repl?
05:25:34 <d3lxa> mmmm: usually I used my system-wide packages to run one .hs of mine, but now I'm using sandboxes and I can't just runhaskell anymore
05:25:56 <mmmm> maybe cabal exec in 1.20 is what you want?
05:26:01 <d3lxa> I installed the dependencies of
05:26:04 <d3lxa> oh let's test
05:26:40 <d3lxa> mmmm: oh yes, that's it! :)
05:26:52 <mmmm> perfect timing!
05:27:05 <mmmm> perfect timing! You would have been stuck yesterday
05:27:49 <d3lxa> mmmm: hum… wait, it doesn't work, I specified garbage and it doesn't complain, why is this so?
05:28:02 <d3lxa> cabal exec yourfile.hs ?
05:28:33 <mmmm> I don't have any deep insight to it sorry
05:28:59 <srhb> d3lxa: cabal run?
05:29:29 <mmmm> maybe try "cabal exec sh" then runhaskell ~~~
05:30:06 <d3lxa> srhb: seems it require a .cabal, right? (it's better to have one anyway)
05:30:18 <srhb> d3lxa: Yes
05:30:51 <d3lxa> alright, a .cabal it is, :) done
05:32:06 <d3lxa> what's cabal exec anyway?
05:32:47 <d3lxa> mmmm: your hack works but that's a shame (so ugly :P)
05:34:08 <mmmm> "cabal exec allows you to launch any binary in an environment where the sandbox package DB is used by default. In particular you can launch a new shell using cabal exec [ba]sh."
05:34:26 <d3lxa> I've found why your hack works and how I don't need it anymore
05:34:51 <d3lxa> it sets the GHC_PACKAGE_PATH env var by appending the sandbox, so I can do it in my shell directly and it works
05:35:39 <d3lxa> runhaskell is then 0.2 faster than cabal run, what a shame
05:41:05 <d3lxa> srhb, mmmm: thank you both :)
05:53:32 * hackagebot treeviz 0.0.8 - Visualization of computation decomposition trees.  http://hackage.haskell.org/package/treeviz-0.0.8 (DavidBanas)
06:29:20 <bergmark> hmm i'm stumped, is there some way to write this function without duplicating the operands?
06:29:33 <bergmark> \p -> comparing $ (if p then flip else id) (&&&) (round :: Double -> Int) (show :: Double -> String)
06:31:42 <bergmark> in my case i can hack it by converting both elements to the same type, but it feels hacky
06:31:52 <xpika> is there a group by which will gather all list elements into sublists?
06:33:00 <Maior> I don't suppose anyone can tell me how to run `cabal haddock` on https://github.com/doismellburning/hess/tree/feature/haddock to get more than `haddock: No input file(s).` - how am I supposed to tell haddock about my src dir?
06:33:30 <bergmark> xpika: You could do it with Map.fromListWith and then going back to a list
06:35:01 <supki> Maior: I think I've answered that yesterday?
06:35:12 <supki> Maior: you need to fill exposed-modules: field in
06:36:41 <Maior> supki: ah I had to go but didn't see anything in my logs
06:36:45 <Maior> supki: thanks very much
06:43:39 <aristid> i wonder if switching back to conduit from pipes is a good idea
06:44:51 <johnw> why wouldn't it be?
06:50:17 <aristid> johnw: i was excited for pipes for a while
06:50:41 <aristid> johnw: but i feel disillusioned a bit
06:51:13 <aristid> so i guess conduit's builtin leftover stuff would make life a lot easier for me
06:51:23 <johnw> it does have convenience going for it
06:51:42 <johnw> easily detecting upstream termination is also quite nice
06:51:59 <aristid> "it" being conduit? or pipes?
06:52:02 <johnw> conduit
06:52:44 <aristid> johnw: in pipes i do feel like detecting EOF is the most complex problem in the world:D
06:52:52 <johnw> it seems that in pipes, theoretic purity in the library comes at a cost to application complexity; conduit is the reverse
06:53:17 <aristid> i want all the purities! have the cake and eat it too
06:53:20 <edsko__> @pf \p -> fold . fmap p
06:53:20 <lambdabot> Maybe you meant: pl bf
06:53:23 <edsko__> @pl \p -> fold . fmap p
06:53:24 <lambdabot> (fold .) . fmap
06:53:33 <johnw> aka fold .: fmap
06:53:38 <xpika> bergmark: alas now i have to think about a key
06:53:39 <johnw> if you pull in pointless-fun
06:53:57 <edsko__> ah, thanks johnw
06:54:11 <aristid> i think there are many packages with .:
06:54:22 <edsko__> yeah, even my own :P
06:54:23 * edsko__ hangs head
06:54:37 <johnw> haha
06:54:38 <aristid> i have one too
06:54:44 <aristid> i forgot its name tho
06:54:57 <johnw> edsko, I didn't recognize you with those underscores!
06:55:09 <edsko> johnw: sorry :)
06:55:20 <johnw> my IRC client colors nicks based on a hash of the name
06:55:25 <aristid> ah, "functors"
06:55:27 <johnw> so I've gotten to the point of recognizing people based on their color
06:55:48 <edsko> johnw: incidentally, saw your answer about free monads on stack overflow recently. "assign meaning to join" -- really like it.
06:55:49 <johnw> "edsko" is magenta, but "edsko__" is bluish gray
06:56:01 <johnw> edsko: thanks!
06:56:05 <edsko> johnw: can't have that! hope I'm a pretty magenta again now :)
06:56:13 <johnw> indeed
06:56:19 <edsko> (although have to say, like bluish gray better than magenta :)
06:56:20 <johnw> aristid is a minty green
06:56:25 <aristid> edsko__ and lambdabot are the same color for me
06:56:33 <edsko> uhoh
06:56:43 <edsko> another reason to get rid of my underscores:)
06:56:58 <aristid> you're still the same color as lambdabot
06:57:07 <aristid> what weechat does with colors is confusing
07:00:20 <aristid> johnw: ok i think i will switch over to conduit: it should also make life easier due to more external libraries
07:00:31 <aristid> like my own aws:D
07:00:35 <johnw> and the new conduit (1.1) is very nice
07:00:43 <johnw> these days you "import Conduit", and use unqualified names for everything
07:00:57 <johnw> by appending C for conduit function, and E for element-based rather than value-based
07:00:58 <aristid> johnw: conduit <1.0 was pretty stupid:P
07:01:32 <johnw> so, you can use mapM_C, and takeE, etc.
07:02:44 <aristid> johnw: there is no Conduit without Data. according to hackage
07:02:57 <johnw> it's in the new conduit-combinators package
07:03:15 <johnw> and a lot of other -conduit libraries are all joined into conduit-extra now
07:03:58 <StoneToad> isn't it import Data.Conduit?
07:04:16 <johnw> it was
07:04:24 <aristid> StoneToad: that's just the core
07:04:27 <johnw> with conduit-combinators, use import Conduit to get the unqualified stuff
07:04:36 <aristid> "Conduit" is apparently the whole thing
07:04:47 <merijn> orion: mapM_C is a pretty horrific name >.>
07:04:51 <merijn> eh
07:04:54 <merijn> s/orion/johnw
07:04:59 <johnw> yeah, but it grows on you
07:04:59 <merijn> Tab fail :\
07:05:08 <johnw> there is also Data.Conduit.Qualified now
07:05:14 <johnw> if you want C.mapM_ instead :)
07:05:44 <johnw> I actually suggested the C suffix to snoyberg, so blame me if you must
07:06:30 <aristid> jorionw
07:07:56 <StoneToad> I'm not looking forward to upgrading to the new conduit, was such a pain getting it working the first time :(
07:08:28 <StoneToad> gave up updating my bytestring version, just copy-pasted the function I needed into my code....
07:11:07 <johnw> StoneToad: yeah, it does take a bit of time
07:11:15 <johnw> I've been gradually updating all of my packages to it
07:11:40 <johnw> the biggest change for me was the move from sourceList/sourceLbs/sinkLbs, to sourceLazy/sinkLazy
07:17:52 <edsko_> johnw: which client are you using? I just moved from xchat azure to textual and I now appear magenta here too :)
07:18:03 <johnw> ERC
07:18:10 <johnw> with one underbar you are orange!
07:18:24 <edsko_> aaah, emacs, I see.
07:18:27 * edsko_ shakes head sadly
07:18:36 <johnw> it's not easy being orange?
07:18:45 <edsko> no, you're using emacs :)
07:19:07 <johnw> oh, it goes far beyond mere usage
07:19:13 <edsko> LOL
07:19:26 <edsko> you live it?
07:19:31 <thoughtpolice> <something something emacs something something 'only zuul'>
07:19:44 <edsko> :D
07:19:51 <taktoa> if I have a list of functions (z -> z) and a single z, how can I apply all the functions in order to z?
07:20:03 <johnw> edsko: I commune with my editor
07:20:09 <saml> taktoa, fold
07:20:10 <taktoa> i.e.: f :: [(z -> z)] -> z -> z
07:20:18 <saml> :t foldl
07:20:21 <lambdabot> (b -> a -> b) -> b -> [a] -> b
07:20:29 <saml> :t foldr
07:20:30 <lambdabot> (a -> b -> b) -> b -> [a] -> b
07:20:34 <saml> oh crap
07:20:38 <edsko> taktoa: foldr (.) id . reverse
07:20:39 <taktoa> so in this case a = b?
07:20:46 <taktoa> thanks
07:20:53 <saml> > foldl (-1) 0 [1,2,3,4]
07:20:55 <lambdabot>  Could not deduce (GHC.Num.Num (b -> a0 -> b))
07:20:55 <lambdabot>    arising from the ambiguity check for ‘e_1101234’
07:20:55 <lambdabot>  from the context (GHC.Num.Num (b -> a -> b),
07:20:55 <lambdabot>                    GHC.Num.Num a,
07:20:55 <lambdabot>                    GHC.Num.Num b)
07:20:58 <thoughtpolice> or even nicer:
07:21:01 <saml> oh it's not fold
07:21:01 <thoughtpolice> :t foldr ($)
07:21:02 <lambdabot> b -> [b -> b] -> b
07:21:08 <saml> you have a list of functions
07:21:20 <srhb> If only erc were a little like Weechat...
07:21:24 <thoughtpolice> > foldr ($) 1 [(+1), (*3)]
07:21:25 <lambdabot>  4
07:21:26 <saml> that sounds like iter  or scan
07:21:34 <saml> :t fix
07:21:35 <lambdabot> (a -> a) -> a
07:21:40 <thoughtpolice> wait nvm
07:22:02 <taktoa> :t flip . foldr ($)
07:22:02 <lambdabot> (b -> c) -> b -> [(b -> c) -> b -> c] -> c
07:22:07 <taktoa> lol
07:22:11 <taktoa> :t flip $ foldr ($)
07:22:12 <lambdabot> [c -> c] -> c -> c
07:22:17 <saml> > map ($) [(+1), (-1)] 0
07:22:19 <lambdabot>  Couldn't match expected type ‘a1 -> t’
07:22:19 <lambdabot>              with actual type ‘[a0 -> a0]’
07:23:40 * hackagebot azure-servicebus 0.1.0.1 - Windows Azure ServiceBus API  http://hackage.haskell.org/package/azure-servicebus-0.1.0.1 (kapilash)
07:24:12 <saml> > let f acc (x:xs) = f (x acc) xs; f acc [] = acc  in f 42 [(-1), (+1)]
07:24:13 <lambdabot>  No instance for (GHC.Show.Show a0)
07:24:13 <lambdabot>    arising from a use of ‘M554287470250674115824592.show_M5542874702506741158...
07:24:13 <lambdabot>  The type variable ‘a0’ is ambiguous
07:24:13 <lambdabot>  Note: there are several potential instances:
07:24:13 <lambdabot>    instance [safe] GHC.Show.Show
07:25:38 <saml> > let f acc (x:xs) = f (x acc) xs; f acc [] = acc  in f 42 [(\a -> a - 1), (\a -> a + 1)]
07:25:40 <lambdabot>  42
07:25:44 <saml> hehe i mastered haskell now
07:26:03 <saml> dont' use foldr and stuff. it's hard to read. it's not Forth or something
07:26:58 <Luke> tibbe: you around? have some questions about collections
07:27:09 <tibbe> Luke: shoot
07:27:26 <Luke> formulating...
07:27:45 <Luke> http://hackage.haskell.org/package/containers-0.5.5.1/docs/src/Data-IntMap-Strict.html#mapAccumWithKey why's mapAccumL a separate internal function?
07:29:13 <Luke> tibbe: also, any chance of making a mapAccumMaybe and mapAccumMaybeR? it seems like there's a lot of variants of this idea. Perhaps even an 'alter' based traverse?
07:30:04 <Luke> tibbe: one more thing: can you clarify this? Does this mean there aren't strict instances of these classes for IntMap.Strict? "Be aware that the Functor, Traversable and Data instances are the same as for the Data.IntMap.Lazy module, so if they are used on strict maps, the resulting maps will be lazy."
07:30:24 <tibbe> Luke: the general rule to adding this is: can it already be expressed efficiently using the current API? If not, it’s a candidate
07:31:17 <tibbe> Luke: yes, since the type is shared across Strict/Lazy, there can only be one set of instances (the lazy ones)
07:31:33 <Luke> tibbe: re: mapAccumMaybe(R) I don't see an efficient way to do it. It's kinda the same reason we have alter right?
07:31:49 <tibbe> Luke: so make a case on libraries@ why the new function is useful and hopefully general enough to cover similar cases
07:31:54 <Luke> tibbe: ok thanks. so long story short, don't use Traverse instance in a strict setting
07:31:58 <tibbe> Luke: sounds about right
07:32:02 <tibbe> Luke: yes
07:32:24 <Luke> I don't know if i'm qualified to be making such a case =)
07:35:44 <Luke> i suppose at this point I can mapAccum(R)WithKey, throw out the key, and then filter empty values as a second step. that's really the only alternative I see at this point
08:03:44 * hackagebot Rasterific 0.2.1 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.2.1 (VincentBerthoux)
08:09:09 <deweyvm> is there a way to search for the maximum element of a set with a different ordering that avoids the toList conversion?
08:09:30 <deweyvm> nvm toList is only O(n)
08:09:36 <deweyvm> and my search is O(n) anyway
08:12:45 <deweyvm> this is where explicit typeclass passing would come in handy though
08:13:45 * hackagebot JunkDB 0.1.1.0 -   http://hackage.haskell.org/package/JunkDB-0.1.1.0 (seagull)
08:13:47 * hackagebot JunkDB-driver-gdbm 0.1.1.0 -   http://hackage.haskell.org/package/JunkDB-driver-gdbm-0.1.1.0 (seagull)
08:13:49 * hackagebot JunkDB-driver-hashtables 0.1.1.0 -   http://hackage.haskell.org/package/JunkDB-driver-hashtables-0.1.1.0 (seagull)
08:15:13 <identity> deweyvm: What do you mean by 'explicit typeclass passing'?
08:15:37 <deweyvm> in haskell you can pass implicit parameters (which are often typeclasses) explicitly if you choose
08:15:47 <deweyvm> so i could pass a different ordering instance to set if i wanted
08:15:54 <deweyvm> in scala**
08:16:15 <yogurt_truck> explicit type class instance passing, then
08:16:23 <deweyvm> ahh yes
08:16:27 <identity> Ah, I see.
08:16:29 <deweyvm> thats what i meant
08:16:40 <identity> So you could pass an instance that, say, did reverse ordering compared to the default?
08:16:46 <deweyvm> right
08:16:49 <identity> ah.
08:17:05 <deweyvm> or as in this case, compared a different member of a datatype
08:17:19 <deweyvm> maximumBy isnt too much of a hassle really though
08:17:41 <identity> That sounds like a strange solution, really, when you could just pass a predicate function(like with maximumBy and cohorts)
08:18:16 <deweyvm> perhaps
08:19:23 <deweyvm> i dont find the newtype method of having multiple type class instances (like list vs ziplist) particularly graceful either though
08:19:25 <Fernandos> hi
08:19:59 <Fernandos> I know Julia is sought to be solution to this problem, but does someone have experience with https://www.fpcomplete.com/ and can tell me, if it's worth it?
08:21:53 <Fernandos> The problem not mentioned is: A fast and efficient R/Matlab replacement, one that also allows integration with existing code.
08:22:15 <Fernandos> But fpcomplete looks interesting in general, just found about it
08:26:57 <shergill> in hoogle, can you search by specifying positive/negative positions?
08:30:12 <mmachenry> shergill: What's a positive or negative position?
08:30:37 <shergill> in 'f :: a -> b' a is in negative position and b in positive
08:31:13 <shergill> iiuc, in '(a -> b) -> c', a and c are in positive position and b in negative
08:32:05 <mmachenry> This is something I've never heard of sorry. What's the significance to your search? What exactly are you trying to find?
08:33:09 <Maior> I still don't really get what they are
08:36:19 <shergill> the itch i had i've managed to scratch. this is useful when you're working with a lib and you want to go from a to b. if you have 'a', you want to look at functions which consume 'a' in some sense. places where it occurs in negative position are a good place to look. in the above example, b is in negative position and if you think about it it's clear that internally a function with that type signature needs to have a function of the
08:36:19 <shergill> form 'b -> c' in order to produce c from 'a -> b'
08:36:33 <shergill> anyway, back to code
08:36:56 <deweyvm> shergill: isnt that what type holes tries to do?
08:37:30 <deweyvm> *typedholes
08:37:39 <srhb> shergill: a -> _ ?
08:38:13 <Guest38601> @pl \x -> f x x
08:38:13 <lambdabot> join f
08:38:53 <Maior> :t join
08:38:54 <lambdabot> Monad m => m (m a) -> m a
08:40:06 <srhb> > join (+) $ 2
08:40:08 <lambdabot>  4
08:40:11 <srhb> Reader monad magic.
08:41:03 <Smilex> Are monads a commonly used thing in Haskell? I'm asking because I've been reading the Wikibook for 3 days straight, and am looking to stop short, make some stuff and then get back to it
08:41:17 <mmachenry> Smilex: Very!
08:41:19 <srhb> Smilex: Very much so
08:41:25 <srhb> Smilex: They are integral to doing IO, for instance.
08:41:27 <geekosaur> that is a strange question
08:41:40 <shergill> deweyvm: iiuc, type holes tells you the type of the hole in the code you're writing. similar to what you have in coq etc
08:41:51 <Smilex> Damn. Ok, thanks guys
08:41:58 <srhb> Smilex: You'll learn to love them :-)
08:42:01 <Smilex> geekosaur: it is?
08:42:07 <Heffalump> Smilex: depends what you're trying to achieve
08:42:17 <mmachenry> Smilex: You can write a decent amount of code without monads in a way. You can solve lots of Project Euler problems, for example.
08:42:23 <Heffalump> you don't really need to understand the Monad class to do IO, just use the syntax of which you can find lots of examples
08:42:31 <Smilex> srhb: I bet. I'm loving Haskell theoretically (haven't used it practically yet)
08:42:38 <Heffalump> and what mmachenry said - there's plenty of "pure" code you can write
08:43:09 <srhb> Smilex: If you want an introduction where you can get started fast without thinking about IO etc. have you read LYAH?
08:43:12 <mmachenry> Smilex: In theory, every program needs the IO monad (unless you're in ghci) but that's not going to require learning monads. Just "main = putStrlLn (show value)"
08:43:17 <srhb> (Which is totally recommended reading anywa)
08:43:30 <Smilex> mmachenry: Ah. Maybe I should get back to Project Euler, just to do something in between reading
08:43:37 <klrr_> mmachenry: isnt ghci inside the IO monad?
08:43:57 <srhb> Ew, project Euler
08:44:01 <srhb> It will teach you nothing of Haskell.
08:44:07 * srhb ducks
08:44:17 <klrr_> Smilex: if you want to learn haskell i suggest reading Write Yourself a Scheme in 48 hours, you learn a bit about monads and actually got to write a "useful" program
08:44:18 <mmachenry> srhb: Speaking of LYAH, are the books named after it any good? I'm thinking of reading LYAErlang
08:44:23 <Smilex> srhb: No. I started with the Wikibook. Am it Intermediate Haskell / Other data structures, so far
08:44:27 <srhb> mmachenry: I have no idea.
08:44:28 <Guest38601> readFile "text.txt" >>= print . reverse :D
08:44:30 <srhb> @where lyah
08:44:30 <lambdabot> http://www.learnyouahaskell.com/
08:44:36 <srhb> Smilex: Keep it for reference at least :)
08:44:45 <Maior> ?? euler
08:44:45 <lambdabot>  euler
08:44:47 <Maior> er
08:46:10 <Smilex> srhb: LYAH is http://learnyouahaskell.com right?
08:46:18 <srhb> Smilex: Yes :)
08:46:21 <Smilex> oh sorry, didn't see the bot message
08:46:26 <srhb> No worries.
08:46:36 <Smilex> Ok thanks
08:53:50 * hackagebot git-annex 5.20140421 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140421 (JoeyHess)
08:58:11 <srhb> Is there a list of things that will be included in the Prelude in 7.10? I just bumped into a warning that join will be moved (yay!)
09:04:27 <srhb> Ah, it seems to be because it's part of the AMP.
09:05:40 <cschneid> is there a difference between `point` and `return`? I see some scala guys talking about point, and was wondering if it's 1:1 with return.
09:08:04 <danilo2> Hello! Reading some articles, we can find informations that "arrows are generalization of monads. ""They can do everything monads can do, and more. They are roughly comparable to monads with a static component." However "Arrows do have some problems"" What are these problems?
09:08:12 <danilo2> (accrding to: http://www.haskell.org/haskellwiki/Arrow)
09:08:50 <srhb> cschneid: What's point? Where is it from?
09:08:53 <danilo2> Is it not true, that every monad can be achieved by a kleisli arrow?
09:09:01 <srhb> danilo2: Yes
09:09:23 <cschneid> srhb: it's a term I've seen in haskell world too - http://hackage.haskell.org/package/category-extras-0.53.1/docs/Control-Functor-Pointed.html
09:09:34 <cschneid> srhb: seems to be the same as return - move an a into (f a)
09:09:51 <danilo2> srhb: Great, so what is the "problem" with arrows? (according to the "However Arrows do have some problems" from http://www.haskell.org/haskellwiki/Arrow) ?
09:10:00 <srhb> cschneid: Ah, okay. Well, yes, some people seem to think we should have Pointed sit at the bottom (or between Functor and Applicative) and provide return
09:11:12 <srhb> danilo2: I don't know specifically. My guess is that they are too powerful, and the extra power makes them unwieldly.
09:11:32 <srhb> danilo2: Just like we prefer to use functors or applicatives when we don't need the full power of monads.
09:11:36 <geekosaur> danilo2: (1) in some ways it's an abstraction without a purpose, since (2) the only sensible Arrow instance as currently formulated is the function arrow
09:12:08 <geekosaur> and the way it's currently formulated, you pretty much can't escape that function arrow to form a different generalization
09:13:25 <geekosaur> that is, the various arrow utility functions can be used with a lot of things, but the syntactic sugar etc. is all predicated on the `arr` combinator, for which the only sensible instance is the function arrow
09:17:11 <danilo2> srhb, geekosaur: Ok, I see. So they are more gneeral, but that does not mean they are worse in any cases? I mean when it comes down to performance and possibilities htey are the same ?
09:17:12 <Athas> /
09:17:21 <cschneid> srhb: ok - so point == return, or does return do something else?
09:17:39 <srhb> cschneid: point == return
09:17:57 <xpte> danilo2: arrows have more opportunity for static optimizations
09:18:08 <xpte> that was the point of one of the arrow formulations of parsers
09:21:11 <danilo2> xpte: Oh, that is very interesting. Do you know where can I find more informations about it? Or if you migh, I wuld be thankful if you could tell a little more about such optimizaton possibilities
09:21:38 <vermeille> Do you know any Lenses tutorial with a lot of examples? and why not exercises
09:22:22 <shapr> vermeille: Have you seen the video of the lens talk given by Simon Peyton-Jones?
09:22:24 <edwardk> vermeille: i've wanted to write a lens tutorial that is based on you reinventing things step by step like dibblego's monad tutorial, just haven't gotten around to it
09:22:46 <shapr> edwardk: I hear the author of the lens library is active and easy to contact.
09:22:49 <xpte> danilo2: read the first few paragraphs of http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf
09:23:20 <xpte> in particular the part about Swierstra and Duponcheel's parser
09:23:34 <shapr> @quote spear
09:23:35 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
09:23:43 <edwardk> shapr: then tell him to stop gallivanting around the globe and patch his damn code. ;)
09:23:48 <cfoch> I remember that there was a function which worked like 'map' and 'and'... for example ..
09:24:17 <shapr> edwardk: I hear he's following in the footsteps or Erdos, writing code all over the world... but I also hear he does diet coke instead of the heavy stimulants Erdos used.
09:24:33 <edwardk> stimulants would probably be easier
09:24:40 <cfoch> AminorThan 10 [3, 4, 5, 6] ----> TRUE
09:24:49 <danilo2> xpte: Ok, thank you! :)
09:24:57 <cfoch> AminorThan 2 [3, 4, 5, 6] ----> FALSE
09:25:05 <merijn> shapr: Fortunately getting a low edwardk number is significantly easier than a low Erdõs number :p
09:25:06 <cfoch>  I don't remember the name of the function
09:25:14 <cfoch> you remember maybe? :S
09:25:22 <shapr> ooh, I want a low edwardk number! But first I'd have to publish something >:-(
09:25:40 <edwardk> merijn: well, since i haven't bothered coauthoring a paper that might be hard to get ;)
09:25:49 <supki> @@ @hoogle @type \f -> and . map f
09:25:52 <lambdabot>  Prelude all :: (a -> Bool) -> [a] -> Bool
09:25:52 <lambdabot>  Data.List all :: (a -> Bool) -> [a] -> Bool
09:25:52 <lambdabot>  Prelude any :: (a -> Bool) -> [a] -> Bool
09:26:02 <merijn> edwardk: I was thinking of number of steps between repository collaboratos
09:26:06 <merijn> edwardk: Instead of papers
09:26:18 <edwardk> besides they should probably run the other way. # of lines of patches I've accepted.
09:26:29 <edwardk> I think shachaf would have the high score
09:26:49 <cfoch> yes... I think it is "all" :)
09:27:01 <cfoch> thanks lambdabot :)
09:27:07 <edwardk> cfoch: 'elem'
09:27:12 <edwardk> > elem 2 [3,4,5,6]
09:27:15 <lambdabot>  False
09:27:17 <edwardk> > elem 3 [3,4,5,6]
09:27:20 <lambdabot>  True
09:27:38 <edwardk> elem = any . (==)
09:28:07 <srhb> @hoogle a -> [a] -> Bool
09:28:08 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
09:28:08 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
09:28:08 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
09:37:18 <cfoch> "all" is what I am looking for, thanks
09:37:42 <cfoch> long time I don't write in Haskell... I am forgetting functions :(
09:49:23 <lechip> question: how to i make a function that iterates over a list and gets a list of the sum of the n element like this foo [1,2,3,4] == [1,3,6,10]
09:49:58 <pjdelport> lechip: scanl?
09:50:13 <pjdelport> > scanl (+) 0 [1,2,3,4]
09:50:15 <lambdabot>  [0,1,3,6,10]
09:50:24 <pjdelport> > scanl1 (+) [1,2,3,4]
09:50:25 <lambdabot>  [1,3,6,10]
09:51:04 <lechip> i i have to implement it however
09:51:09 <lechip> like scanl1
09:51:13 <Polarina> @src scanl1
09:51:14 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
09:51:14 <lambdabot> scanl1 _ []     =  []
09:52:00 <Polarina> @src scanl
09:52:00 <lambdabot> scanl f q ls = q : case ls of
09:52:00 <lambdabot>     []   -> []
09:52:00 <lambdabot>     x:xs -> scanl f (f q x) xs
09:54:41 <pjdelport> lechip: If you're trying to work with your own definition from scratch, you could paste where you get stuck, for advice.
09:55:30 <lechip> pjdelport: prefixsum :: [Int] -> [Int]; prefixsum [] = []; prefixsum [x] = [x]; prefixsum (x:xs) = prefixsum (prefixsum x):xs
09:55:54 <lechip> im having trouble making recursion so i can sum and append and the same time
09:56:59 <pjdelport> lechip: The key is having an accumulation parameter.
09:57:46 <lechip> pjdelport: do explain
09:57:51 <pjdelport> While recursing through the list, you need the previous sum to compute the next one.
09:58:45 <lechip> pjdelport: so how do i do it without changing the prefixsum :: [Int] -> [Int] type?
09:58:47 <pjdelport> lechip: So you can't do it by having prefixsum directly recurse; you need an auxiliary function that keeps track of the running total, in addition to the list.
09:59:14 <exicer> I'm writing an api wrapper, that I would like to run for long periods of time without crashing. What is the best way to deal with error that may arrise from IO? Maybe seems good, but can you tie it to logging some how ?
09:59:35 <pjdelport> lechip: You can make the auxiliary function separate, or define it inside prefixsum with a where clause.
10:00:38 <lechip> pjdelport: let me try then
10:07:30 <lechip> pjdelport: not working, can you give me some light here?
10:08:07 <pjdelport> lechip: Want to paste what you have so far on http://lpaste.net/new/haskell ?
10:09:02 <lechip> pjdelport: http://lpaste.net/5211583419422605312
10:09:49 <lechip> pjdelport: missed parenthesis
10:10:46 <pjdelport> lechip: That's in the right direction, but you'll want the inner function (sumfunction) do the actual recursion.
10:11:24 <lechip> pjdelport: you will forgive me but I am actually just starting into recursion
10:11:28 <pjdelport> lechip: prefixsum will then just invoke it to kick it off with the right initial parameters.
10:12:07 <pjdelport> lechip: No worries. :) That's why I'm trying to explain.
10:12:32 <pjdelport> lechip: it might be easier to have the extra function be separate, at first, instead of using "where"
10:13:41 <lechip> pjdelport: let me see then
10:13:52 <pjdelport> lechip: So make "sumfunction" a separate top-level function, which uses a running total parameter in addition to the list.
10:14:01 * hackagebot hcltest 0.2 - A testing library for command line applications.  http://hackage.haskell.org/package/hcltest-0.2 (BennoFuenfstueck)
10:16:37 <pjdelport> lechip: Approach it from the basic case: given two values, a running total and a (remaining) list, how do you get the following running total?
10:16:45 <Maior> what's the total version of (!) ?
10:16:59 <Maior> can't seem to find one; I assume it exists?
10:23:45 <pjdelport> Maior: It might not. (You mean the Array (!), right?)
10:24:38 <Fuuzetsu> or Map ;)
10:24:45 <Fuuzetsu> IIRC for Map it's 'lookup'
10:24:51 <Fuuzetsu> @hoogle (!)
10:24:51 <lambdabot> Data.IntMap.Strict (!) :: IntMap a -> Key -> a
10:24:51 <lambdabot> Data.IntMap.Lazy (!) :: IntMap a -> Key -> a
10:24:51 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
10:25:15 <Fuuzetsu> @hoogle lookup
10:25:16 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
10:25:16 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
10:25:16 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
10:25:26 <Fuuzetsu> :t Map.lookup
10:25:28 <lambdabot>     Not in scope: ‘Map.lookup’
10:25:28 <lambdabot>     Perhaps you meant one of these:
10:25:28 <lambdabot>       ‘M.lookup’ (imported from Data.Map),
10:25:32 <Fuuzetsu> :t M.lookup
10:25:33 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
10:27:10 <orion> Hey uhh
10:27:13 <orion> http://www.haskell.org/haskellwiki/Implement_a_chat_server
10:27:23 <orion> I compiled the example at the bottom, and I think there is a bug in it.
10:27:54 <pjdelport> The safe package has a version for the Prelude's alist lookup, at least. :P
10:28:11 <vermeille> Just a simple & stupid question : why are the url of Hayoo and Hoogle so ugly?
10:28:37 <Fuuzetsu> orion: Well, can you say what the bug is without us having to run it?
10:28:45 <Fuuzetsu> vermeille: Hm?
10:28:47 <orion> Fuuzetsu: Yes. I am trying to be polite and pastebin the problem.
10:29:52 <orion> http://ideone.com/btyb5k
10:30:11 <vermeille> Fuuzetsu: respectively : http://www.haskell.org/hoogle/ (ok this one is alright, but hoogle.com could be better) and http://holumbus.fh-wedel.de/hayoo/hayoo.html (daaamn!)
10:30:29 <srhb> orion: Yes, it is bugged. :)
10:30:33 <srhb> orion: The fix is easy though
10:31:03 <c_wraith> orion: it assumes it's being connected to with telnet, not nc
10:31:16 <Fuuzetsu> vermeille: Does it matter? You should be happy someone is hosting them ;P I suspect you could ask the infrastructure guys to have haskell.org/hayoo point to holumbus page.
10:31:22 <c_wraith> orion: so it's attempting to strip the \r off
10:31:34 <c_wraith> orion: but netcat doesn't use \r\n as the line terminator
10:31:36 <srhb> Which is easily fixed, (if that's what you want)
10:32:23 <orion> srhb: https://www.youtube.com/watch?v=ijEgfnJuirA
10:32:23 <Fuuzetsu> I hate having to drop from the end if I have to check the end first. I usually end up with ugly code like ‘reverse . f . reverse’
10:32:23 <vermeille> Fuuzetsu: yes it, it does matter, that's ergonomy, ease of access, etc. Haskell is a really great product and that's sad some details are just left aside
10:32:31 <orion> srhb: (That's what I want)
10:32:48 <srhb> orion: remove the init if that's what you want
10:32:51 <c_wraith> orion: so remove the code that's stripping the last character
10:32:56 <Fuuzetsu> vermeille: Well, technically hayoo is just a service that someone chose to host, it's not Haskell.org Endorsed™.
10:33:13 <srhb> orion: name <- liftM init (hGetLine hdl)
10:33:30 <Fuuzetsu> If you feel that haskell.org should umbrella it then perhaps you should be talkning with the owner and the infrastructure guys
10:33:32 <srhb> orion: Also you might learn more from working up to that from a much simpler example so that you know what each line does
10:33:49 <Fuuzetsu> talking*
10:33:59 <vermeille> Okay, I'll buy hayoo.something to make it point to the host, it will be better
10:34:11 <Athas> Does this combinator have a standard name? http://lpaste.net/103036
10:34:38 <vermeille> Those tools are just great to have such a bad url :D
10:34:52 <Fuuzetsu> vermeille: With all the new TLDs, there might be a great one somewhere.
10:35:02 <orion> srhb: I've been creating my own examples.
10:35:10 <lechip> pjdelport: I got this http://lpaste.net/103037
10:35:12 <Fuuzetsu> like hay.oo or something great
10:35:31 <lechip> pjdelport: but i am still unable to put the thing in the array right
10:36:01 <Fuuzetsu> lechip: should it not be ‘x + sumSubFunction y ys’?
10:36:17 <orion> The first program I wrote was a root finder (bisection), the second program I wrote outputs 10 random numbers, the third program I wrote is a TCP echo server, and the fourth program I wrote is a simple happstack "Hello World".
10:36:20 <Fuuzetsu> also god damn, it's ‘Function’ not ‘Fucntion’!!
10:36:34 <orion> I find my progress delightful.
10:36:58 <srhb> orion: Yes, it's nice that such small programs are really, really small and easy in Haskell. :)
10:37:22 <lechip> sorry about the scrambled letters, right now is irrelevant to the solution
10:37:35 <orion> I've kind of fallen in love with this language, probably because I have OCPD and am obsessed with formality.
10:37:38 <Athas> You should really grade a language on how easily *big* programs are written, though.
10:37:46 <srhb> orion: Probably not. :P
10:38:18 <orion> I also correct people when they use "your" and "you're" incorrectly.
10:38:20 <srhb> Athas: Absolutely. But it transfers well, especially in FP. Building larger components from smaller ones is great when the smaller ones are even smaller than in other languages. :)
10:38:21 <Athas> orion: have you read the blog "Boolean Blindness"?  It really shows a nice and low-overhead way to make Haskell more formal.
10:38:50 <lechip> orion:  see no problem with that, I was just putting code quickly, ill correct
10:39:04 * hackagebot log-domain 0.9 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.9 (EdwardKmett)
10:39:06 * hackagebot compensated 0.6.1 - Compensated floating-point arithmetic  http://hackage.haskell.org/package/compensated-0.6.1 (EdwardKmett)
10:39:12 <orion> I also correct people when they use "their", "they're" and "there" incorrectly. As a result, I think Haskell is the perfect for me.
10:39:24 <orion> s/the perfect/perfect
10:39:25 <Athas> srhb: sure, although my experience is that at the overall architecture-level, Haskell isn't too different from procedural languages.
10:39:30 <pjdelport> (because the end result must be a list)
10:39:36 <srhb> Athas: Could sure use a nicer module system.
10:39:46 <srhb> Athas: MosML-style.
10:39:47 <orion> lechip: Never heard of it. I still have my training wheels on.
10:39:48 <Athas> Now, there aren't many big Haskell programs with public source code, but GHC has a pretty classic procedural design.
10:40:01 <Athas> srhb: indeed, I have missed functors at times.
10:40:23 <srhb> Especially with lazy/strict variants of data structures.
10:40:33 <pjdelport> lechip: Then, in the last case, you also need to start building up the result list, in addition to the recursive call
10:42:27 <Athas> Also, laziness is incompatible with parallel computing, but that's a different issue. :-)
10:42:47 <ReinH> Athas: it is?
10:42:54 <pjdelport> lechip: In other words, "sumSubFunction (x+y) ys" gives you the *rest* of the result, but you also need to put the current sum in front of it.
10:43:00 <Athas> ReinH: yes.  The thunks are shared state.
10:43:12 <ReinH> Athas: er.
10:43:15 <identity> Given that I have ghc 7.6.3 installed via the haskell platform, what would be the right way of replacing that ghc with 7.8?
10:43:20 <ReinH> Not in the usual sense of the term?
10:43:28 <Athas> ReinH: operationally, they are.
10:43:32 <srhb> identity: Deleting everything and installing ghc 7.8 from anything.
10:43:35 <ReinH> It doesn't matter if immutable state is shared
10:43:42 <Athas> There are other issues as well... note that most parallel libraries for Haskell use NFData/deepseq to ensure that computation is essentially eager.
10:43:52 <Athas> ReinH: thunks are mutable - they are overwritten the first time they are forced.
10:44:06 <Athas> That does not mesh well with modern heterogenous and non-local parallel computing.
10:44:18 <ReinH> Why not?
10:44:21 <Athas> You can still do call-by-name, though, but it becomes tricky to control evaluation.
10:44:37 <Athas> Because you cannot copy the thunks without violating the laziness.
10:44:44 <ReinH> Why do you need to copy the thunks?
10:44:55 <lechip> pjdelport: i'm sorry but i dont know what do you reffer to the *rest*
10:45:12 <Athas> Because in a non-local system (think a cluster, or just a computer with NUMA), having a single thunk accessed by every processor would cause contention.
10:45:33 <lechip> pjdelport: and I dont know if you reffer to making that into the main dunciton or this auxiliar function
10:45:40 <ReinH> Why do you need to share the thunks in the first place?
10:45:43 <c_wraith> ReinH: alternatively, there's the case where parallel computing does nothing because nothing is forced in the parallel steps, only on the final result of them
10:46:17 <pjdelport> lechip: By rest, I mean the remainder of the list of partial sums, after the value that the current call is calculating.
10:46:19 <Athas> ReinH: for the same reason you pass the same parameter to several function calls.
10:46:44 <Athas> c_wraith: that can be solved with deepseq-like mechanisms, but it really does reveal that laziness isn't a natural fit for parallelism.
10:46:54 <pjdelport> And I mean inside this auxiliary function, yes; you can ignore the main function for now :)
10:47:02 <ReinH> I agree that laziness poses problems. I don't agree that it's "incompatible".
10:47:11 <ughugh> ughugh: test
10:48:01 <c_wraith> ReinH: also, unsafePerformIO is a mess when you start copying thunks from one machine to another.  As long as it exists, copying thunks isn't a safe operation.
10:48:30 <ReinH> In some ways it's even beneficial as you don't need to wrap an expression with a closure to delay it
10:48:31 <Athas> ReinH: the distinction between laziness and call-by-name is that in the former, the thunk is only ever computed once.  That implies a single, shared state, which is not really parallel.
10:49:01 <c_wraith> ReinH: the result of hGetContents, for instance, cannot be sent from one process to another without fully forcing it first.
10:49:04 <Athas> To get good parallel performance, it's often better to duplicate computation, if it reduces memory contention.
10:50:08 <srhb> Cloud Haskell has some interesting primitives for working with this
10:50:31 <srhb> But generally it means producing your own closures
10:50:51 <ReinH> I think there's a difference between data parallelism and task parallelism
10:51:05 <Athas> srhb: looks like they intend that you fully serialise everything you send across the wire.
10:51:11 <srhb> Yes.
10:51:24 <ReinH> (Which poses its own problems)
10:51:30 <Athas> So... laziness doesn't really exist at the parallel level.
10:51:59 <ReinH> Athas: I think what you're concerned about isn't laziness per se, it's shared/observable laziness
10:52:07 <Athas> And if you serialise closures (which is possible - look at the Eden library for example), you get call-by-name, but not real laziness.
10:52:09 <pjdelport> lechip: So basically, your base case will have to be: sumSubFunction x [] = [x]
10:52:24 <Athas> ReinH: laziness is a cost model issue, basically.
10:52:34 <Athas> That said, does Haskell even guarantee laziness, or just non-strict evaluation?
10:52:34 <pjdelport> lechip: or perhaps as a better hint: sumSubFunction x [] = x : []
10:52:48 <ReinH> Athas: Haskell the language? non-strict evaluation.
10:52:50 <srhb> Athas: The latter.
10:53:06 <Athas> Yeah, I assumed as much.  You can't observe the distinction anyway.
10:53:08 <ReinH> GHC implements via lazy evaluation
10:53:34 <ReinH> Athas: it sounds like the sharing requirement is the biggest problem
10:53:38 <rusk101> Hello everyone
10:53:43 <srhb> rusk101: o/
10:53:47 <pjdelport> lechip: Now, the case for "sumSubFunction x (y:ys) = ..." should look very similar to the above
10:54:01 <Athas> ReinH: indeed.
10:54:03 <ReinH> Athas: but generally the solution is to structure your computation such that you don't need to share thunks. Map/reduce, etc.
10:54:26 <ReinH> share data (forced values) not computation
10:54:28 <Athas> Sure, you need to write your program strictly, which is exactly my point.
10:54:28 <pjdelport> lechip: Except that instead of "x : []", you'll need something else instead of the empty list.
10:54:32 <rusk101> I got a problem building this last function. Can anybody take a look? It's at the bottom. http://lpaste.net/103040
10:54:34 <ReinH> Athas: makes sense
10:54:54 <pjdelport> lechip: Does that help?
10:54:55 <ReinH> Athas: or at least the parts that can be observed non-locally
10:55:03 <ReinH> it's ok if your local computation uses laziness
10:55:04 <Athas> That just means you can't use normal non-strict algorithm design techniques (which sucks, because they can perform really well).
10:55:16 <Athas> Yes, certainly, and also if the part that orchestrates the parallel computation is lazy.
10:55:33 <srhb> rusk101: Heh, pjdelport is helping lechip with that right now
10:55:34 <Athas> For example, you could use lazy evaluation to construct a parallel computation in an embedded DSL.
10:55:52 <ReinH> Athas: makes sense
10:55:53 <Athas> I'm definitely in favour of using laziness whenever you have complex control flow.
10:55:53 <tomejaguar> Suppose I a type 'exists s. (Foo s, Bar s)', i.e. the two 's' are the same, but they can't unify with anything else.  How do I achieve this in Haskell?  I've never got to grips with existential types.
10:55:54 <srhb> rusk101: Oh wait, no
10:56:04 <tomejaguar> s/Suppose I a/Suppose I want a/
10:56:20 <lechip> pjdelport: im actually running in circles now, I tough the idea of making another function was to have a sub result, but with sumSubFunction x [] = x : [] im understanding that I need that function to be sumSubFunction:: Int -> [Int] -> [Int] which does not match with what I got...
10:57:07 <pjdelport> lechip: No, that's correct; the type matches.
10:57:19 <ReinH> lechip: x : [] = [x]
10:57:53 <pjdelport> lechip: That's basically saying that once you reach the end of the list, you stop: x is the last partial sum.
10:59:22 <pjdelport> And yes, "[x]" means the same as "x : []", but I mentioned the latter to hint at what the other (recursive) case should do.
11:00:06 <lechip> sumSubFunction:: Int -> [Int] -> Int; sumSubFunction x : [] how does that make into Int????
11:00:55 <ReinH> lechip: you just said Int
11:00:57 <ReinH> woops
11:01:08 <ReinH> You just said Int -> [Int] -> [Int]
11:01:47 <srhb> lechip: You are right, your type needs to change to [Int] at the end
11:02:03 <srhb> I think you misunderstood each other
11:02:09 <Athas> ...would people be upset if I defined € as a left-associative $?
11:02:10 <lechip> srhb: tnx  that clarifies
11:02:11 <rusk101> anybody with a little help? How can I use scanl to write the algorithm for the last function? http://lpaste.net/103040
11:02:15 <srhb> Athas: Massively.
11:03:37 <ReinH> Athas: haha
11:06:09 <lechip> nope, ended up in the same spot as before, I'm sorry but I only got more confused, i got this http://lpaste.net/103038
11:06:43 <lechip> again, the idea is to make something like foo [1,2,3,4] == [1,3,6,10]
11:08:06 <triliyn> lechip: do you know about scans or are you trying to write the recursion yourself?
11:08:24 <lechip> yep, I know about it, I want to do it myself
11:08:30 <srhb> lechip: You can't add a list to a number
11:08:49 <lechip> srhb i know, its retarded, Ill scrap all of that, it makes no sense
11:09:03 <srhb> lechip: Well, it's mostly on the right track, ish
11:09:11 <ReinH> lechip: let's start with something very simple.
11:09:20 <lechip> allrite
11:09:47 <ReinH> lechip: can you write an identity transformation on lists recursively? So: f [1,2,3,4] = [1,2,3,4]
11:10:30 <ReinH> f [] = []; f (x:xs) = ???
11:10:45 <lechip> prefixsum [] = []; prefixsum (x:xs) = x: prefixsum xs
11:10:51 <ReinH> yep
11:11:02 <lechip> allrite
11:12:05 <monochrom> also define ¥ to be unassociated $ :)
11:12:55 <ReinH> lechip: sorry one sec
11:13:19 <lechip> ReinH: no prob, im trying something meanwhile
11:13:38 <pjdelport> lechip: The previous one you had was almost right.
11:14:13 <pjdelport> lechip: Here's a version that puts it together: http://lpaste.net/103037
11:17:09 <ReinH> lechip: now can you write a version that maps a function onto each element as it goes?
11:17:28 <ReinH> so f g [1,2,3,4] = f [g 1, g 2, g 3, g 4]?
11:19:50 <lechip> f [] = []; f g (x:xs) = g x : f g (xs)
11:20:11 <ReinH> lechip: yep
11:20:16 <lechip> allrite
11:20:27 <pjdelport> lechip: Does that help?
11:20:36 <danilo2> Hello! I'm new to Arrows and I'm reading the article: http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf . I understand, now arrow interface could look a little different, so could anybody help me figure out how to create "readFile >>> print". Such example exists in the paper but does not compile with Control.Arrow
11:22:06 <ReinH> lechip: now let's take a step back. Write me a recursive function that prepends an element onto a list: f z [1,2,3] = [z,1,2,3]
11:22:12 <danilo2> Ah, nvm. we shoudl be explicit aobut the Kleisli arrow!
11:22:48 <rusk101> What am I doing wrong here? first time working with ratio's helper2 :: Integer -> Ratio helper2 x = (1 % x)
11:22:48 <ReinH> lechip: this one is going to be more difficult, so it's ok if you can't figure it out immediately. We'll walk through it.
11:23:35 <ion> See :info Ratio, :info Rational
11:23:37 <ion> in ghci
11:23:47 <lechip> f z (x:xs) = z:x:xs maybe?
11:24:58 <ReinH> maybe?
11:25:07 <ReinH> lechip: well yes, but it isn't recursive :)
11:25:18 <lechip> ReinH: ah, let me try again
11:25:32 <ReinH> lechip: (or just f = (:) because you're implementing cons)
11:25:49 <ReinH> lechip: the thing is: there isn't a simple solution that recurses on f
11:25:58 <ReinH> lechip: in order to do this recursively, you have to write scanl :)
11:26:12 <ReinH> or something equivalent
11:26:18 <lechip> ReinH: ah, which is my problem sort of
11:28:35 <SrPx> Serious, I have an important, difficult problem that I am not sure how to solve and don't have enough time to research further due to too much work to do. People on SO and similars won't answer, probably because that is not trivial enough for a volunteer to solve it for free. Is there any similar site I can actually offer some money for someone who solves the problem for me?
11:29:25 <lechip> ReinH: I think I got it tnx to you and pjdelport
11:29:30 <ReinH> lechip: <3
11:29:50 <lechip> I used a auxiliary function that keeps the partial result
11:30:05 <ReinH> > scanl (\a b -> b) 1 [2,3,4] -- lechip: an inefficient (:) :)
11:30:07 <lambdabot>  [1,2,3,4]
11:36:32 <pjdelport> SrPx: What's the problem?
11:40:46 <jle`> > let f x xs = go (length xs) [] where go 0 ys = reverse (ys ++ [x]); go n ys = go (n-1) (ys ++ (xs !! (n-1))) in f 1 [2,3,4]
11:40:48 <lambdabot>  No instance for (GHC.Show.Show a0)
11:40:49 <lambdabot>    arising from a use of ‘M761330144761071468125597.show_M7613301447610714681...
11:40:49 <lambdabot>  The type variable ‘a0’ is ambiguous
11:40:50 <lambdabot>  Note: there are several potential instances:
11:40:52 <lambdabot>    instance [safe] GHC.Show.Show
11:42:42 <jle`> > let f x xs = go (length xs) [] where go 0 ys = reverse (ys ++ [x]); go n ys = go (n-1) (ys ++ [xs !! (n-1)]) in f 1 [2,3,4]
11:42:44 <lambdabot>  [1,2,3,4]
11:42:50 <vermeille> Where can I find the list of repos included in Stackage?
11:57:09 <SrPx> pjdelport: http://cs.stackexchange.com/questions/23992/is-there-a-decidable-algorithm-to-compose-two-well-behaved-recursive-functions-t
11:58:03 <SrPx> pjdelport: it is not quantum-level complicate, just the kind of question that would need too much effort and have so few people that know how to answer, that nobody volunteers to. I often find myself on that situation.
12:00:17 <pjdelport> SrPx: Is there a specific context to this?
12:00:46 <SrPx> pjdelport: nothing much out of the scope of that, I am trying to implement an inliner in an interpreter for a subset of haskell which has only one datatype and well behaved recursion
12:00:55 <pjdelport> SrPx: It might just be that the definitions are a bit fuzzy; specifically "without any reference to f and g"
12:01:05 <pjdelport> if you simply perform inlining, would that count?
12:02:15 <SrPx> pjdelport: how to perform the inlining is the complicate part... I want to fuse those recursive functions in a way they perform the recursion in one pass. Kinda like stream fusion, but for arbitrary recursive folds on tree-like structures.
12:14:21 <mgdm> Hi. I'm a bit of a newbie. I'm wondering if I'm overengineering something I'm doing. Would someone mind critiquing https://gist.github.com/mgdm/f0f628d6a59fea4aeaba for me?
12:15:00 <pxqr> s/[Char]/String ?
12:15:35 <mgdm> ah - the book I'm reading seems to use [Char] everywhere, I'll try that
12:16:43 <pjdelport> SrPx: The answers on there seem sensible
12:17:03 <pxqr> mgdm: foldr (++) [] = concat
12:17:36 <mgdm> ah ha :-)
12:17:43 <jle`> mgdm: also you should really never have to use head or tail
12:17:50 <airportyh> Hello there. I am trying to learn haskell, wrote a simple web server using wai/warp. I am really stuck on how to read the request body from a POST request. Here is a gist https://gist.github.com/airportyh/11153250
12:17:50 <jle`> except for performance or code golf
12:18:41 <mgdm> jle`: what would you recommend instead in that case?
12:18:47 <jle`> pattern matching
12:18:53 <mgdm> ahh
12:19:10 <bennofs>  jle`: when would one need to use head/tail for performance?
12:19:39 <jle`> bennofs: hm. i would suspect the same time one would use fromJust, or lazy pattern matches?
12:19:57 <begriffs> I'm having trouble building cabal-install 1.20.0.0 on Heroku. On the linking step it says "Setup: /usr/bin/ar: permission denied". However I can run the "ar" command manually just fine. Anyone know what might be going on?
12:20:20 <jle`> mgdm: case split '-' r of [f,l] -> [f..l]; _ -> []
12:20:30 <jle`> or f:l:[] if that is your fancy
12:20:35 <etrepum> mgdm: you could use `split '-'` and `map read` in there to make it a bit shorter, just match on how many elements you get in the result list.
12:21:29 <jle`> also you don't need to type annotate f and g
12:21:32 <jle`> er, f and l
12:21:42 <jle`> because you specify that you want Ints later in the type siganture of parseRange
12:22:00 <jle`> same for line 23
12:22:17 <pxqr> airportyh: you need to pipe conduits like: requestBody $$ consume
12:22:32 <pxqr> instead of consume (requestBody req)
12:23:10 <jle`> parseColumns = concatMap parseColumn . split ','
12:23:58 <jle`> or parseColumns str = do { col <- split ',' str; parseColumn col } for fun :)
12:24:09 <airportyh> pxqr: oh ok, that's actually what I had before, but had the same trouble so I tried different things
12:24:09 <mgdm> hehe
12:24:40 <jle`> i have a bad habit of abusing do notation though >.>
12:25:04 <mgdm> jle`: etrepum: pxqr: thanks, that's been useful
12:25:47 <pxqr> airportyh: you might want to have a look at scotty for simple servers
12:25:53 <airportyh> pxqr: new code and output, similar error https://gist.github.com/airportyh/11153250
12:26:56 <pxqr> airportyh: you don't need to runResourceT because requestBody returns Source *IO* ByteString
12:28:36 <airportyh> pxqr: that worked! Thanks tons!
12:28:47 <airportyh> pxqr: and yeah scotty seems promising
12:29:18 <pjdelport> SrPx: Do you have a concrete example of where usual inlining fails?
12:30:40 <pjdelport> SrPx: As the one commenter noted, the problem with the non-total example is just that it's non-total.
12:32:43 <pjdelport> SrPx: Without knowing more about the actual implementation your targeting, it seems like it should be just a matter of handling all the cases when inlining.
12:39:52 <etrepum> mgdm: here's how I would break it down, I made revisions for each step https://gist.github.com/etrepum/c9f9a61d3e11deeea180
12:41:03 <etrepum> mgdm: you might want to check out http://exercism.io/ if you are looking for Haskell exercises like this with code review
12:41:05 <mgdm> etrepum: wow, thanks very much
12:41:24 <mgdm> and I'll check that out, thanks
12:51:06 <metzger> hello
12:52:35 <hseg> Hi. Can someone explain how Wadler's arrow calculus is "meticulous" in distinguishing between effectful and noneffectful variables?
12:53:44 <metzger> I am looking for a windowing toolkit which will work under linux, without opengl, and will easily allow me to create sliders and test boxes and an image which will be computed by my code. I would like to be able to move the slider and see the changes happen on the image. Is there a good library for that purpose?
12:54:35 <hseg_> I.e. I don't understand the rationale behind the design.
13:00:37 <pjdelport> hseg_: is this in the context of http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf ?
13:01:45 <identity> metzger: I'm not sure how far along it is, but I've heard good things about threepenny-gui
13:01:49 <identity> which runs in the browser
13:02:14 <hseg_> Yes, the famous oblivious/meticulous/promiscuous characterization of idioms/arrows/monads
13:03:06 <hattusili_III> anyone familiar with data.aeson?
13:04:57 <BeardedCoder> hattusili_III: What's your question?
13:05:30 <hattusili_III> so i have a sort of nested json object, and i want to navigate it to parse an inner value
13:05:37 <hattusili_III> into a haskell type
13:06:00 <mmachenry> You'll probably need to parse the whole thing and then walk the tree to extract the piece that you want.
13:06:01 <DR6> have you tried lens-aeson?
13:06:07 <DR6> Or aeson-lens
13:06:32 <edwardk> DR6: lens 4 just includes Data.Aeson.Lens for direct consumption
13:06:41 <DR6> oh really?
13:06:46 <hattusili_III> i haven't i'll look into it
13:06:52 <DR6> cool!
13:07:13 <hattusili_III> also nmachenry, parse it to a an Aeson Value, or into a haskell type?
13:07:28 <Okasu> > let f xs = let x = takeWhile (/= ',') xs in if x /= "" then (if not $ any (=='-') x then (read x :: Int) : f (tail $ dropWhile (/= ',') xs) else ([read (takeWhile (/= '-') xs) .. read (tail $ dropWhile (/= '-') xs)] :: [Int])) else [] in f "1,2,5-10"
13:07:29 <lambdabot>  [1,2,5,6,7,8,9,10]
13:07:32 <Okasu> Blurgh.
13:12:04 <albeit> I have a Map.Map (Int, Int) Float, basically a map of edges in a graph to their weights. Edges are updated one a time. It seems inefficient to create brand new maps every time an edges is updated... should I be using a different data structure?
13:12:55 <gamegoblin> So in ghci I’m doing :l myFile but it’s saying that none of the functions are in scope. Ideas?
13:13:34 <identity> gamegoblin: Does your file start with module File () where .. ?
13:13:36 <BeardedCoder> gamegoblin: not to sound silly but are you exporting anything?
13:13:40 <hseg_> Are you exporting the functions from the module?
13:13:57 <gamegoblin> No, I was just doing it like this: http://www.haskell.org/platform/doc/2013.2.0.0/ghc-doc/users_guide/loading-source-files.html
13:14:32 <gamegoblin> I really rarely use ghci so I’m not super familiar with how it handles this sort of thing
13:15:18 <BeardedCoder> gamegoblin: I just followed those instructions minus the :cd and it worked
13:15:37 <Leidy> hey guys ! how i can implement a "instance ToField [String]" for postgres-simple ?
13:15:54 <gamegoblin> The weird thing is, it worke dbouat 15 minutes ago, I added a function, then it stopped working… changed it to a module and exports though and it works fine now
13:17:22 <hseg_> Question. Type-theoretically, why does Loeb here: http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html?m=1 work with only a Functor constraint? Surely the Curry-Howard correspondence as applied to the modal logic K should bring in an Applicative constraint?
13:22:35 <Anarchos> i try to port haskell to another OS. But configure failed with "Can't work out build platform"
13:24:16 <Cale> Anarchos: Generally you're going to have to expect porting GHC to be a lot of work, because it's written in GHC Haskell.
13:24:43 <Anarchos> Cale HaikuOS is very near from other unices
13:25:14 <pjdelport> albeit: Can you update many edges at a time?
13:25:49 <albeit> pjdelport: No... edges to update are external information and they arrive one at a time.
13:26:09 <Cale> Anarchos: Yeah, but if you don't already have a working GHC binary... https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
13:27:52 <pjdelport> albeit: It should probably be okay, then; I'm not intimately familiar with Map's implementation, but when when you alter a node, it doesn't return an entirely new tree, but shares unchanged nodes with the old tree.
13:28:25 <AncientPC> How do you filter record types based on its attributes? Let's say there's a Person with gender and age. How would you retrieve all males above 18 years old?
13:28:45 <Cale> AncientPC: In what sort of data structure? A list?
13:28:57 <AncientPC> a list of Person records.
13:29:30 <Cale> [p | p <- people, gender p == Male, age p >= 18]
13:29:31 <pjdelport> albeit: So amortized, it should be efficient enough. (Someone else might know more exact details about its performance properties.)
13:30:01 <AncientPC> Cale: What would the filter alternative?
13:30:14 <Cale> Or of course, filter (\p -> gender p == Male && age p >= 18) people
13:30:15 <gamegoblin> @pf
13:30:15 <lambdabot> Maybe you meant: pl bf
13:30:22 <AncientPC> Cale: ahh I was overthinking it, thanks.
13:37:19 <Cale> Anarchos: You'll probably want to talk with the people in #ghc about how to get a cross compiler, say Linux -> Haiku working. I believe you'll need to similarly get a bunch of cross tools (C compiler, linker, etc.) which produce output in whatever form Haiku expects, but which run on Linux or whatever your build OS is.
13:37:52 <hseg_>  Actually,  I should ask first how interpreting the types as modal logic allows you to get around the fact that lob's theorem demands the use of the diagonal lemma.
13:38:14 <Cale> Anarchos: and then once you have a Linux -> Haiku cross compiling GHC, you can use it to build a Haiku proper GHC.
13:41:44 <schlegel> Isn't Haiku BSD based
13:41:59 <schlegel> ah no BeOS
13:44:24 <albeit> pjdelport: Looks like your right, insertion is just log(n), so I guess it essentially acting as a semi-mutable structure.
13:44:48 <pjdelport> albeit: well, a lazy structure
13:45:08 <pjdelport> lazily avoiding unnecessary work is efficient :)
13:45:38 <identity> tell that to my boss <.<
13:45:47 <identity> Nah, just kidding. I'm unemployed.
13:46:48 <monochrom> the trick is that the boss does not consider work to be unnecessary
13:47:21 <c_wraith> Hmm.  a question on SO made me look at erlang-style string matching.  It seems I can't emulate it using ViewPatterns and PatternSynonyms.  Boo.
13:49:35 <identity> c_wraith: how does that work in erlang? got a link?
13:51:00 <c_wraith> Hmm, I guess it's just bit strings in erlang that work that way.
13:51:16 <c_wraith> But more or less, it gives you convenient syntax to match on a literal prefix
13:51:28 <c_wraith> and then get the suffix when the prefix matched
13:52:05 <tapuu> What's the state of the art for making guis in haskell right now?
13:53:54 <albeit> When using record syntax, is there a accepted style for field names? I have custom types that may both have a getSize field... should I rename them to getFooSize, getBarSize where Foo and Bar are the data type names?
13:54:25 <pjdelport> c_wraith: What's an example of that?
13:55:16 <metzger> hi again
13:55:27 <bergmark> albeit: use qualified imports
13:55:38 <Maior> albeit: afaict convention is `Foo { fooBar :: Bar}` but I may be wrong
13:55:49 <Maior> but yeah, qualified imports ftw
13:55:57 <metzger> Is wx a good lib for my use? (I asked above)
13:55:57 <Maior> massively hoping for awesomeness re .
13:56:05 <albeit> So each data type should be in its own file / module?
13:56:12 <bergmark> albeit: overloaded record names is coming though, (GHC 7.10?)
13:56:22 <bergmark> albeit: yes
13:56:32 <Maior> albeit: if you fancy some reading, https://ghc.haskell.org/trac/ghc/wiki/Records
13:56:36 <Cale> bergmark: Really? How is that going to work?
13:56:38 <pjdelport> There's also DisambiguateRecordFields
13:56:56 <Maior> magic
13:56:57 <bergmark> Cale: funky types! I don't really remember
13:57:56 <bergmark> i think this is it: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Design
13:57:57 <hseg_> Cale: basically, records with a field of a specific name belong to a type class Has parametrized by that name.
13:58:01 <hattusili_III> anyone familiar with Aeson lenses?
13:58:11 <Cale> hmm
13:59:01 <Cale> That sounds like it sells out the common case for the extreme one.
13:59:33 <bergmark> i'm guessing it will be an extension
13:59:48 <bergmark> ok it clearly states that :-)
13:59:49 <hseg_> Why? common case is I have foo, bar, both with field baz.
14:00:33 <begriffs> Anyone else having trouble building cabal 1.20? Its "Setup configure" command refuses to use binaries in /usr/bin on Heroku. Keeps saying permission denied despite full read and execute permissions on the files.
14:00:37 <Cale> hseg_: Common case is the status quo :)
14:01:37 <Cale> hseg_: where all your fields have distinct names, and the type of the record involved can be inferred from their use.
14:01:38 <hseg_> baz, instead of being a function Foo -> a *and* Bar -> b, is a function Has "baz" r c => r -> c
14:01:44 <Anarchos> Cale thanks for the link
14:02:03 <Cale> Anarchos: It'll be interesting to hear if you have any success :)
14:03:07 <hseg_> Cale: status quo should still work. it's just that now multiple records can have the same field name, with differing field types.
14:03:10 <schlegel> Anarchos: do join #ghc if you have questions
14:03:21 <mgdm> Could someone tell me what I'm doing wrong here? https://gist.github.com/mgdm/e00c78f15a006020406f
14:03:25 <Cale> hseg_: It'll result in ambiguities
14:04:25 <Cale> mgdm: What's that 0 at the end?
14:04:39 <Cale> mgdm: also, there are tab characters in this file
14:04:41 <mgdm> Cale: it's to allow it to compile (it says the last thing in a do block needs to be an expression)
14:04:51 <Cale> mgdm: yeah, but 0 isn't an IO action
14:05:05 <Cale> mgdm: try  return ()  as the last line of the do-block
14:05:23 <Cale> and turn on whatever option your editor has for converting tabs to spaces automatically
14:05:32 <bitemyapp> mgdm: specifically, return is a -> m a, and if m is IO, then return () is IO ()
14:05:48 <mgdm> Cale: Thanks - I've retabbed the file, but I'm getting the same thing
14:06:02 <bitemyapp> mgdm: make sure you're using spaces. What editor is it?
14:06:10 <Cale> yeah, there wasn't a specific problem with the indentation yet, but it's always scary :)
14:06:19 <mgdm> bitemyapp: it's Vim. I've fixed it now.
14:06:23 <bitemyapp> mgdm: the usual is 2 or 4 spaces per indent. Okay.
14:06:30 <hseg_> Cale: example please
14:06:49 <bergmark> i love that haskell pretty much has settled the tabs-vs-spaces debate
14:06:53 <mgdm> I've now updated the gist to match
14:07:00 <bitemyapp> bergmark: golangers tried to set us back though.
14:07:04 <c_wraith> is ghc-mode ever going to support syntax from extensions, like type families and pattern synonyms?
14:07:10 <bitemyapp> obnoxious gits.
14:07:22 <bergmark> bitemyapp: :-( luckily i don't touch go
14:07:22 <Peaker> bitemyapp: golang standard format is tabby? :(
14:07:25 <Cale> mgdm: What error are you getting now?
14:07:27 <bitemyapp> Peaker: yep :\
14:07:31 <bitemyapp> Peaker: gofmt even enforces it.
14:07:32 <identity> c_wraith: i hope so.
14:07:34 <Cale> oh, I see
14:07:37 <bergmark> wow
14:07:39 <bitemyapp> Peaker: drove me up a wall.
14:07:40 <Anarchos> schlegel ok thanks
14:07:47 <bergmark> do they distinguish between indentation and formatting?
14:07:50 <bitemyapp> bergmark: when you're writing Haskell you have more important things than fiddling with indent :)
14:07:56 <Peaker> bitemyapp: does it at least do it correctly -- i.e: tabs for indent, spaces for alignment? or does it have no alignments at all?
14:08:05 <mgdm> Cale: the one in the comment at the top of the file, still
14:08:07 <bitemyapp> bergmark: gofmt cleans up a lot of things, indentation is one of them.
14:08:18 <bitemyapp> Peaker: no alignments.
14:08:32 <Peaker> bitemyapp: so you can't break a statement into multiple lines?
14:08:52 <Peaker> or you can, but something funny happens to the spacing of the next lines?
14:09:11 <bitemyapp> Peaker: you can do multiple line statements if you begin the next with an operator but I haven't seen how gofmt handles it.
14:09:11 <hseg_> ugh. they could at least do the elastic tabs proppdal
14:09:19 <bitemyapp> Peaker: the tabbed indentation is roughly analogous to the introduction of scopes from what I remember.
14:09:42 <bitemyapp> the code tends to be pretty flat from memory though.
14:09:58 <Peaker> kill \x09 characters with fire :(
14:10:00 <bitemyapp> they don't really have a lot to work with. It's just funcs, structs, go blocks.
14:10:15 <bitemyapp> and you don't define structs inline, so.
14:10:17 <Cale>  (ReqArg (\arg opts -> return opts { optColumns = arg }) -- get rid of the 'return' here
14:10:44 <mgdm> Cale: done
14:10:55 <mgdm> Sadly the same error, though
14:10:58 <bitemyapp> Peaker: notably, the reason the operator has to begin the next line on a multiple line statement in golang is so the automatic semicolon insertion works.
14:11:10 <bitemyapp> yeap, JS isn't the only lang with that >:)
14:11:16 <Cale> okay, I'll take a closer look :)
14:11:24 <mgdm> Cale: thank you :)
14:11:38 <Cale> mgdm: oh, it's not quite the same error anymore
14:11:44 <bitemyapp> shake-n-bake sandboxes that worked with dependencies in lpaste a la fpcomplete for helping people would be nice.
14:11:56 <mgdm> Oh, oops
14:12:08 <pjdelport> Peaker: "Say "Nein!" to 9!" ?
14:12:11 <Cale> mgdm: The problem is now that it's giving you a function of some parameter opts
14:12:11 <mgdm> the m0 has disappeared, which is an improvement
14:12:38 <Cale> So you don't get a list of type [Options] as your type signature says, but a list of functions [Options -> Options]
14:12:39 <mgdm> Cale: heh. I took off the type definition for parseARgs, and now it's fine
14:12:45 <Cale> Well, yes
14:13:03 <Cale> But when you go to use parseArgs, you'll have to be aware that you're getting a list of functions
14:13:20 <Peaker> bitemyapp: it has both explicit and implicit semicolons?
14:13:26 <Peaker> bitemyapp: like Python?
14:14:26 <bitemyapp> Peaker: nobody actually writes the semicolons in practice, but you have to think about them when you're splitting lines.
14:14:30 <Cale> mgdm: It would make more sense to have something like:  data Options = Columns String
14:14:32 <bitemyapp> because the layout of the code can break the ASI.
14:14:37 <Cale> and then  (ReqArg (\arg -> Columns arg)
14:14:51 <Cale> or simply (ReqArg Columns)
14:15:01 <Peaker> bitemyapp: so like Python indeed
14:15:06 <bitemyapp> Peaker: I've been quoted describing Golang as being pharaonic in nature.
14:15:14 <Cale> er, (ReqArg Columns "COLUMNS") of course
14:15:20 <bitemyapp> I stand by this statement.
14:15:49 <Cale> mgdm: and then your original type signature should work
14:15:50 <bitemyapp> Peaker: I hear drips and drabs about your company using Haskell in some SRE groups or some-such. You know anything about that?
14:15:51 <hseg_> pharaonic?
14:15:51 <Peaker> bitemyapp: not sure what that means
14:16:05 <mgdm> Cale: cool, thanks
14:16:08 <Peaker> hseg_: yeah
14:16:13 <bitemyapp> Peaker: it's somewhat ahistorical, but I'm trying to be evocative of mass-slave-labor.
14:16:18 <c_wraith> Aaargh.  PatternSynonyms is now making me thing about how much I'd like a more flexible extension that makes patterns *more* first-class.  Like, they can be returned from functions.
14:16:21 <hseg_> define?
14:16:26 <Peaker> bitemyapp: heh
14:16:31 <Peaker> bitemyapp: I'm writing a build system for my company's C code, in Haskell
14:16:36 <Cale> mgdm: You'll add more cases to the Options type as you add more command line flags
14:16:43 <Cale> (rather than more fields)
14:16:51 <Peaker> bitemyapp: I am sick of build systems that don't really work correctly unless you "make clean"
14:16:56 <Lethalman_> Peaker, shake?
14:17:04 <bitemyapp> Peaker: that's quite cool. Is this related to that tool I heard about that pulls down all the company projects to make something work auto-magically?
14:17:14 <Peaker> Lethalman_: it doesn't give the guarantees I need either
14:17:17 <bitemyapp> Lethalman_: based on what I know about Google build tools, almost certainly not.
14:17:19 <Lethalman_> Peaker, which ones?
14:17:28 <Cale> mgdm: However, it would make some amount of sense to do it like you were, constructing a list of functions on some kind of options record which can be composed together and applied to the default options
14:17:33 <Peaker> Lethalman_: determinism on file system access
14:17:43 <hseg_> nm, saw above. what does slavery have to do with it, though?
14:17:46 <Lethalman_> Peaker, mh for example?
14:18:02 <Cale> I don't understand why anyone thinks Go is interesting.
14:18:03 <triliyn> Cale: more cases might be convenient while you're parsing the options, but I find it nice to also have a product type that describes the entire option-state
14:18:04 <bitemyapp> hseg_: golang is designed so that you can leverage large amounts of labor inefficiently.
14:18:12 <Lethalman_> Cale, me neither
14:18:15 <bitemyapp> hseg_: large amounts of unskilled labor, that is.
14:18:17 <Cale> (the language, not the game)
14:18:18 <triliyn> Because repeated options, for example, might combine in ways that aren't obvious from [Option]
14:18:36 <Peaker> Lethalman_: example:   gcc -Ia -Ib   on a file with  "#include <x.h>"   found b/x.h.  It needs to know to rebuild if a/x.h was created
14:19:01 <Lethalman_> Peaker, I see, iirc nix has an example in the thesis that shows that problem
14:19:03 <Cale> triliyn: right
14:19:09 <Peaker> Lethalman_: so I need to be able to depend on the inexistence of files (not sure if shake can do this). Moreover, I want this dependence to be auto-discovered so I don't accidentally mess it up (like all #include scanners inadvertedly do)
14:19:24 <mgdm> I considered learning Go, because the concurrency side was interesting, but I'm doing Haskell instead. I think I'm learning more. :-)
14:19:39 <bitemyapp> mgdm: well, not only are you learning more, but Haskell's concurrency primitives are a superset of what Golang offers.
14:19:40 <Peaker> Lethalman_: so I use file system hooking to discover FS dependencies, and so you don't have to explicitly "need" stuff, and you get more guarantees.  Both convenience and safety, yay
14:19:42 <shachaf> Haskell has all sorts of concurrency. It's great.
14:19:44 <Cale> mgdm: Yeah, and Haskell's concurrency stuff makes Go's concurrency stuff look boring.
14:19:49 <bitemyapp> mgdm: you can do CSP just fine with chans and forkIO in Haskell.
14:20:00 <hseg_> bitemyapp, do you have an example of efficient use of unskilled labor?
14:20:05 <bitemyapp> realistically, you'll probably end up just using MVars and TVars. :)
14:20:09 <Lethalman_> Peaker, shake does not know about C files, but you can let it depend dynamically on files... so that may work if you transform include paths to absolute paths and feed them to the deps dynamically
14:20:09 <mgdm> I did GPH stuff in Uni about 10 years ago, but I have forgotten all of that long ago
14:20:23 <bitemyapp> hseg_: early days of the Ford Motor Company come to mind.
14:20:34 <Peaker> Lethalman_: but you need to say: "I depend on the *inexistence* of a/x.h"
14:20:43 <Peaker> Lethalman_: (as it does not exist now)
14:21:16 <Lethalman_> Peaker, right, but in shake you get headers of the C file, and add dependencies dynamically... so the next time you run it, headers change, and deps change
14:21:39 <Peaker> Lethalman_: but "headers change" needs to also include "headers get created"
14:22:05 <Peaker> Lethalman_: will    need "missing.h"     in shake fail if "missing.h" is missing?
14:22:29 <hseg_> bitemyapp - so you have a skilled designer in a static + rich language specify the code that's then sent to be implemented?
14:22:30 <Peaker> Lethalman_: also, shake does the standard explicit input dependencies, which I wanted to avoid -- given that it is too easy to mess up, imagine also having a Python script auto-generate some code.  Too easy to forget what extra Python libs it depends on
14:22:48 <Lethalman_> Peaker, explicit input deps?
14:22:49 <Peaker> Lethalman_: also, I track global dependencies too -- i.e: if a new C compiler is installed globally, I will know to rebuild
14:22:54 <mgdm> Cale: thanks for the help
14:22:59 <Lethalman_> Peaker, ah, nix does that
14:23:00 <Peaker> Lethalman_: yeah, explicit "need" calls, rather than detected file system access
14:23:16 <Peaker> Lethalman_: I thought nix was a package manager?
14:23:31 <Lethalman_> Peaker, yes, but you could use it as build system... at least in the thesis there's an example
14:23:48 <Peaker> Lethalman_: does nix require me to specify exactly what I depend on?
14:23:54 <Peaker> (like all build systems do, afaik?)
14:24:15 <Lethalman_> Peaker, at build time yes... unless you do something dynamically to discover... at runtime no
14:24:16 <Peaker> ^^ this is one of the major goals I wanted: auto-detect dependencies by hooking file access
14:24:21 <bitemyapp> hseg_: you're machete'ing your own path here and not expressing anything that was in my head.
14:24:31 * hackagebot Tables 0.1.0.0 - A client for Quill databases  http://hackage.haskell.org/package/Tables-0.1.0.0 (NatePisarski)
14:24:33 <bitemyapp> hseg_: proceed without me.
14:24:35 <Lethalman_> Peaker, about hooking file access, iirc there's a build system that uses nfs
14:24:44 <Peaker> Lethalman_: there's tup which uses fuse
14:24:45 * Lethalman_ doesn't remember the name, but if you're interested I can look
14:25:01 <Lethalman_> tup misses top-down builds
14:25:08 <Peaker> Lethalman_: but it does so only for the local project, and only for verification, I want it for detection
14:25:14 <Peaker> Lethalman_: what are top-down builds?
14:25:26 <Lethalman_> Peaker, tup works bottom up... therefore if you want to build only a single path, you can't
14:25:37 <Lethalman_> make is top down, and all others
14:25:45 <Peaker> Lethalman_: you can tell tup to build only one path, I don't understand?
14:25:49 <Lethalman_> you can?
14:25:55 <Lethalman_> only a target, like make foo
14:25:55 <Peaker> it will build stuff that one path depends on
14:26:01 <Lethalman_> oh
14:26:04 <Peaker> I'm not sure, I think so
14:26:07 <Peaker> (I always assumed it!)
14:26:34 <hseg_> bitemyapp - no, don't leave me alone out here I'm this cold uncaring world. :p
14:26:34 <Lethalman_> also tup, at the time, missed the multi outputs
14:26:41 <Lethalman_> make misses also (you have to use stamps)
14:27:01 <Peaker> Lethalman_: anyway, I have "top down builds".  I also verify mtimes don't change during a build to avoid confusing the build system if sources are edited while you build
14:27:19 <Peaker> Lethalman_: I also capture the stdout and stderr of a build, so compilation warnings don't disappear after a successful build
14:27:22 <Lethalman_> Peaker, in nix sources can't be edited, they are copied in the store and immutable
14:27:40 <Peaker> Lethalman_: well, that's not quite what one would want in a build system, I reckon
14:28:01 <Peaker> Lethalman_: you've got your git repo of the sources, and you want to edit them and incrementally rebuild just the part you need, reliably.  AFAIK, I am writing the only build system that can do this :P
14:28:10 <fizbin> Is there a pure functional analogue of UML? That is, some sort of visual/graphical language that can communicate important bits of a large haskell program/library from one person to another, and maybe serve as a map for walking through a large system?
14:28:34 <Lethalman_> Peaker, right for a build system it might not be a good choice, for package managing it works exceptionally well however
14:28:39 <Peaker> Lethalman_: yeah
14:28:44 <mmachenry> fizbin: How about UML?
14:29:19 <Lethalman_> Peaker, unless you copy the current state, in the sense of git reset --hard
14:29:26 <Lethalman_> Peaker, after all a git clone should be cheap
14:29:37 <fizbin> mmachenry: Many aspects of UML are rather fundamentally object-based. Admittedly, for some stuff sequence diagrams would work, but otherwise...
14:29:43 <Peaker> Lethalman_: anyway, shake doesn't have these features that we want (auto-detecting deps, depending on missing files, reliability [checking mtimes don't change during build]) and we also have a future plan of doing a generalized "ccache" for any command - that's shared across the entire company
14:29:55 <Peaker> Lethalman_: a git clone is not cheap, on a large company repo
14:30:01 <Lethalman_> Peaker, that's nice indeed
14:30:14 <mmachenry> fizbin: What does UML fail to model that you need?
14:30:56 <Lethalman_> Peaker, auto detect deps at build time?
14:32:00 <hseg_> question. how does the interpretation of löb's theorem here http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html?m=1 avoid the dependency the proof has on the diagonalization lemma?
14:32:08 <fizbin> mmachenry: It's not clear to me how haskell type classes could be shown in UML, and I'd really like a good representation for complicated zipper-like data structures.
14:32:11 <Lethalman_> that's nice, doesn't it mean you need to have a list of installed files of each project to depend upon it?
14:32:59 <fizbin> Maybe I should dig up my CT book and see what I can steal from category theory diagrams.
14:33:04 <srhb> fizbin: I think centering the diagrams on the important data structures and something else for the important functions that operate on these types makes sense
14:33:23 <hseg_> AFAIK, that lemma can't be expressed in intuitionistic logic, and thus the Haskell type system.
14:33:29 <srhb> I honestly haven't felt the need to formalize it though.
14:33:43 <Peaker> Lethalman_: I auto-detect the list of files by seeing which libc calls are done on which paths, and pausing those that need to be built
14:34:06 <Lethalman_> Peaker, but you have to know they will be built
14:34:34 <Peaker> Yes, you have to specify the outputs of your commands, just not the inputs
14:34:51 <pjdelport> hseg_: I think the translation is purely from the theorem to the type; not necessarily with respect to any particular proof of the theorem.
14:35:00 <Lethalman_> Peaker, but then that's not auto detecting deps, it's just locking
14:35:31 <hseg_> but the Curry-Howard correspondence only works on proofs AFAIK.
14:35:44 <Peaker> Lethalman_: imagine:   foo.o foo.hi: ghc -o foo.o foo.hs         <-- this will auto-detect that the cmd depends on bar.hi, bar_dep.hi, etc
14:36:00 <Peaker> Lethalman_: it will also auto-detect that it depends on /usr/bin/ghc, and various other stuff that are used by it
14:36:19 <Peaker> Lethalman_: you have to specify the outputs explicitly (which are then verified, because they too are detected)
14:36:31 <Lethalman_> ok
14:36:35 <Peaker> Lethalman_: but you don't have to specify inputs (and the inputs are the much harder part, not the outputs)
14:36:47 <Lethalman_> that's indeed nice, have to tell that in #nixos :)
14:37:14 <Lethalman_> but I feel that's a harder problem
14:37:15 <pjdelport> hseg_: That just means you could translate a particular proof to a corresponding program, not that it's the only one.
14:37:25 <Lethalman_> since some inputs are optional for example
14:37:38 <Lethalman_> or some inputs may later be needed at runtime, and you don't know
14:38:24 <hseg_> OK. but how do you prove lobs theorem without that lemma?
14:38:36 <pjdelport> hseg_: So the implementation Piponi comes up with would correspond to a proof. A family of proofs, for each choice of functor?
14:38:59 <Peaker> Lethalman_: I'm confused by what you're saying: the point of auto-detecting inputs is that it knows what the cmd *actually* depended on
14:39:12 <Peaker> Lethalman_: there's only cmd runtime (a.k.a "build time") no other "time"
14:39:39 <Peaker> Lethalman_: it will re-run the command if any of the inputs it *actually* has, changed. And this includes non-existing inputs
14:40:13 <hseg_> OK. two problems though. one, functors are not equivalent to modal logic and two, translating back from the program, what's the proof of the theorem?
14:40:15 <Lethalman_> Peaker, let's say you build foo, and you auto discovered it depends on bar
14:40:37 <Lethalman_> Peaker, then you run foo and it fails because it depended dynamically on qux at runtime
14:40:58 <pjdelport> hseg_: It might actually be good to ask Dan Piponi that. Bonus points, for getting him to write an article about it. :)
14:41:01 <Peaker> Lethalman_: when is "runtime"?
14:41:11 <Lethalman_> Peaker, when you run foo.... ./foo
14:41:11 <Peaker> Lethalman_: running the cmd to generate "foo"?
14:41:20 <Lethalman_> Peaker, no, actually running the application
14:41:20 <Peaker> Lethalman_: why is depending on qux an error?
14:41:32 <Peaker> Lethalman_: ah, that's not part of the build system
14:41:34 <DR6> the loeb function on haskell is recursive
14:41:45 <Peaker> Lethalman_: not in the project's scope
14:41:47 <Lethalman_> Peaker, eh ok :) that's indeed part of packaging
14:41:52 <DR6> that means that the "proof" depends on (a -> a) -> a
14:42:05 <Peaker> Lethalman_: we're probably going to use it to generate static executables anyway
14:42:09 <DR6> so yeah, there's not a translation to actual logic
14:42:45 <Peaker> Lethalman_: Seems like an orthogonal problem to me anyway :)
14:43:01 <Lethalman_> Peaker, thanks for the thoughts
14:43:07 <hseg_> DRG, why?
14:43:15 <Lethalman_> I wish this could apply to nix, but... I fear that's not possible :(
14:43:31 <Peaker> Lethalman_: sure, thanks for the interest :)  we need to figure out which OSS license to use for buildsome and then we hope it catches on :)
14:43:39 <hseg_> Couldn't you just add that to your axioms?
14:43:58 <Lethalman_> Peaker, I always hope for gpl :)
14:44:21 <DR6> yes, but that axiom lets you prove anything
14:44:37 <Peaker> Lethalman_: I am a GPL fan myself, but this will be my company's decision, of course :)  Also, in the Haskell world, BSD is more conventional, so I tend to use BSD for Haskell packages
14:44:43 <hseg_> Really? why?
14:46:00 <hseg_> oh, of course. a -> a is a tautology, and therefore modus ponens gives you that a is true for all a
14:46:29 <DR6> yes
14:46:45 <DR6> in general, you have fix id :: a
14:46:58 <hseg_> so intuitionistic logic maps to Haskell but not vice versa?
14:47:09 <DR6> that's my understa
14:47:44 <hseg_> right, fix I'd = _|_
14:47:56 <hseg_> damn autocorrect
14:48:13 <benmachine> just because something uses recursion, doesn't mean it muse use fix
14:48:18 <benmachine> there are "well-behaved" recursions
14:48:28 <benmachine> but they're... pretty hard
14:48:31 <orion> What does STM stand for?
14:48:35 <hseg_> primitive recursion,
14:48:41 <bergmark> orion: software transactional memory
14:48:47 <hseg_> ?
14:49:24 <benmachine> hseg_: I have decided that actually I'm not sure what I'm talking about
14:49:34 * hackagebot groundhog 0.5.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.5.0 (BorisLykah)
14:49:36 * hackagebot groundhog-th 0.5.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.5.0 (BorisLykah)
14:49:38 * hackagebot groundhog-sqlite 0.5.0 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.5.0 (BorisLykah)
14:49:40 * hackagebot groundhog-postgresql 0.5.0 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.5.0 (BorisLykah)
14:49:42 * hackagebot groundhog-mysql 0.5.0 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.5.0 (BorisLykah)
14:51:04 <Phillemann> I have two sets of elements and I want to apply a a function on each (unordered) pair. Is there a good way in Haskell to do that?
14:51:32 <hseg_> f <$> xs <*> ys
14:51:48 <DR6> what datatype are you using
14:51:50 <DR6> data.set?
14:52:08 <Phillemann> Plain lists currently.
14:52:11 <hseg_> where xs, ys the sets and f the binary fubction
14:52:13 <Phillemann> And the sets are very small.
14:52:38 <Phillemann> hseg_: Ah, I remember reading about applicatives being able to do that.
14:52:39 <DR6> I think hseg_'s solution works
14:52:50 <Phillemann> Or rather, lists as applicatives.
14:52:51 <DR6> it's also what monadic bind does
14:52:57 <DR6> and therefore list comprehensions
14:53:06 <Phillemann> This is so cool :>
14:53:15 <DR6> [f x y | x <- xs, y <- ys]
14:53:24 <DR6> but I recommend applicatives
14:53:40 <hseg_> generalization ftw!
14:54:13 <DR6> note that actually lists have *two* interpretations as applicatives
14:54:22 <DR6> the second is provided with the ZipList newtype
14:54:46 <DR6> the current applicative instance is there because it's the one that fits with the monad one
14:55:09 <hseg_> getting late. thanks for the help guys.
14:55:40 <Phillemann> It works, thanks you two :)
15:11:52 <albeit> I have a data type declared "data dir = North | South | West | East". When I try and compare two different directions, it says I need to make it Ord. Is there a shorter way to do that?
15:12:03 <albeit> (Instead of declaring == and < type classes)
15:12:10 <quchen> deriving (Eq, Ord)?
15:12:39 <mmachenry> quchen: That's correct.
15:12:40 <albeit> Ha, doh, I did deriving (Ord) without Eq and it failed
15:12:44 <quchen> Iff you want to use (==), you have to define an Eq instance (and similarly for (<) and Ord). Deriving them is one way.
15:13:23 <shachaf> I'm not sure that's "iff".
15:14:04 <quchen> shachaf: Well, I meant (==) :: Ord a -> a -> a -> Bool, but with the implicit type you're right.
15:14:12 <quchen> In other words, "the" (==).
15:14:24 <quchen> s/Ord/Eq/
15:14:49 <quchen> If I'm still wrong please correct me.
15:20:50 <schlegel>  quchen: He's just saying 'If I have to define an Eq instance then I want to use (==)' doesn't always hold
15:20:57 <schlegel> Like in albeit's case
15:21:26 <schlegel> he has to define an Eq instance but doesn't necessarily want to use (==)
15:21:38 <schlegel> Just being picky :P
15:23:44 <toooookoja> type environments  \Gamma ::= \cdot | x:A,\Gamma what does the \cdot there stand for? empty environment? (idioms are oblivious, monads...)
15:24:56 <johnw`> does it mean "empty"?  good question
15:26:03 <triliyn> Empty sounds like a pretty good guess
15:27:40 <shachaf> Yes.
15:27:49 <shachaf> It doesn't have to stand for anything, just to be a thing.
15:28:12 <shachaf> Like data Gamma = Nil | Cons ... Gamma
15:29:54 <toooookoja> ok thanks
15:42:10 <johnw`> is Greg Weber ever on this channel?
15:52:44 <SwashBuckla> is there an "automatically-wrap-to-80-characters" tool for Haskell?
15:53:15 <SwashBuckla> i.e. I feed said tool a Haskell source file, and it spits out the same source but formatted so each line is no greater than 80 LOC
15:53:24 <SwashBuckla> it's particularly important for code listings for me
15:55:12 <SwashBuckla> it's also in the Haskell programming guidelines to stick to no more than 80 character lines: http://www.haskell.org/haskellwiki/Programming_guidelines
15:55:18 <bergmark> SwashBuckla: i think there isn't one, reformatting can be quite tricky since haskell is indentation aware
15:55:26 <WraithM> SwashBuckla: afaik, there are editor-specific versions of this, ie. one for emacs, one for vim, but there isn't a cmd-line tool. You may enjoy sylish-haskell though! https://hackage.haskell.org/package/stylish-haskell
15:55:41 <SwashBuckla> ok
15:55:51 <bergmark> haskell-src-exts is pretty terrible at these things :-(
15:57:01 <bergmark> SwashBuckla: that wiki page is very subjective :-)
15:57:27 <SwashBuckla> hmm
15:58:03 <bergmark> i agree with a lot of it though
15:58:24 <bergmark> but things like "All Haskell source files start with a haddock header of the form:" ... noone does this anymore
15:59:09 <victorkr> what is haskell
15:59:25 <johnw`> victorkr: a computer programming language
16:01:39 <bergmark> and it comes with this nifty bag
16:05:18 <SwashBuckla> I didn't get a bag
16:05:39 <SwashBuckla> where's my bag?!
16:11:42 <orion> If an application segfaults, is it always a problem with GHC?
16:12:02 <bergmark> orion: no, it could be a faulty C library too, for instance
16:12:26 <stepcut> or bad bindings to a C library, or bad use of unsafe*
16:14:47 <c_wraith> You can easily segfault with the Foreign module, if you so desire.  Without even involving C code.
16:15:42 <c_wraith> But it does have involve unsafe*
16:15:49 <bitemyapp> orion: pull up a firing squad and line up the unsafe code.
16:15:49 <c_wraith> -have
16:17:21 <geekosaur> my experience is segfaults are often type bugs in FFI interfaces
16:17:40 <geekosaur> then again that's because I work with xmonad a lot and the X11 bindings are full of type errors >.>
16:18:17 <geekosaur> (I really need to submit some of the lesser used ones I dug out at one point... not sure I even have a record of them any more, too many machine changes since then)
16:42:18 <Smilex> Theoretically, how would one make a game that has a Javascript version, and a desktop version, and an Android version, etc. in Haskell? I come from C, so I would use #ifdef, but I don't think Haskell has that.
16:43:18 <Smilex> I'm primarily thinking. I want to 'import GL', which would either import OpenGL, OpenGL ES or WebGL, depending on what I was building for
16:46:06 <sipa> Smilex: there is an extension to pipe your sourcecode through a preprocessor before compiling, actually
16:46:34 <Smilex> sipa: And is that is usually done?
16:49:17 <ParahSailin> strictly speaking yes, ghc supports cpp directives
16:52:26 <Smilex> Ok thanks
16:53:51 <ParahSailin> Smilex: http://www.haskell.org/ghc/docs/7.8.1/html/libraries/Cabal-1.18.1.3/Language-Haskell-Extension.html
17:04:43 <jle`> Smilex: remember that #IFDEF and CPP are their own standalone things
17:05:11 <jle`> so you could use cpp standalone to compile def's etc. for anything
17:05:39 <jle`> even java etc. :)
17:06:39 <jle`> or latex
17:07:01 <Smilex> jle`: what do you mean? They are standalone to Haskell?
17:07:26 <jle`> cpp is its own program
17:07:28 <jle`> like sed
17:07:35 <jle`> or grep
17:07:45 <jle`> or...ghc
17:08:43 <prophile> or [
17:10:53 <Smilex> Do you guys know how the OpenGL package on hackage deals with OGL function loading? Is it a function loader library, or does it mimic OGL as much as possible?
17:19:21 <afleck> Hi, I'm an experienced LISP user, and I've thoroughly familiarized myself with haskell syntax, and I've done some tinkering. What's a good introduction to haskell-specific concepts like Types, Typeclasses, and Monads for people who already know functional programming?
17:19:40 <gamegoblin> Skip ahead in Learn You A Haskell for Great Good
17:20:15 <imalsogreg> afleck: http://www.haskell.org/haskellwiki/Typeclassopedia
17:20:32 <afleck> should I read the chapter about types and typeclasses and then like 6+?
17:21:02 <gamegoblin> If you aren’t familiar with Haskell basics, such as pattern matching, you should probably at least skim the whole first bit, too
17:21:29 <gamegoblin> Not sure if the flavor of LISP you use has pattern matching
17:21:55 <afleck> I get the part about patterm matching and all that
17:22:17 <gamegoblin> Mmm that go ahead and skip to data declarations, type classes, etc. Backtrack if you run into issues.
17:22:18 <afleck> but i haven't touched typeclasses or monads nearly at all
17:22:22 <afleck> ok
17:22:29 <afleck> imalsogreg: thanks, this looks good
17:22:35 <gamegoblin> typeclasses are like better versions of C#/Java interfaces
17:22:47 <gamegoblin> Monads are… pretty abstract and should really just be learned by using them a lot
17:22:57 <imalsogreg> afleck: It may be tricky at first. But it's really fantastic. :) Hope you enjoy it.
17:24:02 <gamegoblin> Some lisps have some typeclass like things with a numeric tower (scheme, for one) but it’s pretty limited to numerics whereas Haskell’s is very general
17:29:16 <afleck> gamegoblin: I'm used to common lisp
17:41:24 <vermeille> The lens talk by Simon Peyton Jones is absolutely wonderful, thanks!
17:44:03 <nuser> vermeille: is there a link?
17:45:45 <ion> @google lens talk simon peyton jones
17:45:46 <lambdabot> https://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation
17:46:14 <edwardk> you'll need to register with the site, but it is worth it
17:46:29 <ion> Is that new? I have watched that talk without registering in the past.
17:46:32 <edwardk> IIRC, http://ftp.newartisans.com/pub/Lenses.mp4 is a mirror that johnw has of it
17:46:40 <nuser> Cool, thanks
17:46:47 <edwardk> they put up the register wall a couple months after the talk
17:47:06 <toooookoja> can i somehow write newtype SF a b = SF {runSF :: [a] -> [b]} without record syntax?
17:47:12 <vermeille> Do you have something about Prisms so that I can continue to learn :D ?
17:47:23 <shachaf> newtype SF a b = SF ([a] -> [b])
17:47:28 <edwardk> newtype SF a b = SF ([a] -> [b]); runSF (SF xs) = xs
17:48:29 <orion> > [0, 1] + [1, 2]
17:48:31 <lambdabot>  No instance for (GHC.Show.Show t0)
17:48:31 <lambdabot>    arising from a use of ‘M633752544185818972126804.show_M6337525441858189721...
17:48:31 <lambdabot>  The type variable ‘t0’ is ambiguous
17:48:31 <lambdabot>  Note: there are several potential instances:
17:48:31 <lambdabot>    instance [safe] GHC.Show.Show
17:48:46 <toooookoja> oh thanks i forget to write the new before type: type SF a b = SF ([a] -> [b]) doesn't work
17:50:08 <orion> Is there any real difference between mapping and lifting [] ?
18:01:17 <albeit> If I have "data Foo = { bar :: Map.Map Int Int }; a = Foo Map.fromList [(0,1)]; b = Foo (bar a)", does the bar value get copied, or does b's bar just point to a's bar?
18:04:12 <ParahSailin> not copied
18:05:03 <ion> Things don't need to be copied in general because of purity.
18:05:49 <nisstyre> ion: it also means you *can* copy them without worrying
18:06:56 <albeit> Great, thanks
18:22:51 <albeit> But what if I do "c = Foo ((bar a) Map.insert 1 2)"? Does c get a brand new tree?
18:28:02 <thoughtpolice> it's truly amazing how hard Google must have worked to make the GSOC2014 page so unusably stupid
18:31:27 <pavonia> thoughtpolice: Stupid in what way?
18:31:49 <carter> pavonia: it summons cthulu every 2 page clicks
18:32:51 <pavonia> Huh?
18:33:44 <thoughtpolice> it's annoyingly slow, must refresh everything upon hitting back, the UI is *terrible* as it on-demand loads every time, AND it forgets my search queries
18:33:57 <thoughtpolice> would it have been so hard to spit out HTML with anchor tags? probably not
18:34:18 <pavonia> Oh, I enables JS and now I see what you mean :D
18:35:07 <kfish> thoughtpolice, they worked hard to make it useful, and it uses cutting edge techniques for its time
18:35:28 <l0cust> Hey, how do I get a string from the shell editor?
18:35:29 <kfish> which was ~2005 perhaps?
18:36:02 <l0cust> My apologies if I'm interrupting something
18:36:12 <carter> kfish: :)
18:36:15 <carter> how're you doing?
18:36:52 <pavonia> Maybe the techniques they use are the future or web browsing experience
18:36:58 <pavonia> *of
18:37:05 <kfish> carter: good mate
18:37:19 <carter> pavonia: then be very very sad :)
18:37:27 <carter> kfish: cool
18:37:35 <carter> been a bit buried all winter
18:37:37 <carter> starting to surface
18:37:42 <kfish> (i mentored gsoc for a few years around 2005ish, and i just looked at it and the UI hasn't changed :)
18:37:51 <pavonia> l0cust: What shell editor do you mean?
18:39:07 <l0cust> pavonia: So, I have a program with a CLI interface. If I issue a certain command, I want it to pop up Vim, so I can enter some data, then get the data.
18:39:31 <l0cust> Other than having vim open up a temporary file, and then leeching the data from the temporary file, is there a good way to do this?
18:39:57 <pavonia> Oh, I have no idea if or how that is possible, sorry
18:40:43 <l0cust> pavonia: Thanks, I think I'll do the thing with the tmpfs file
18:42:14 <orion> Is Chan not thread safe?
18:43:31 <pavonia> It really should be
18:44:34 <orion> In general, is it better to use TChan because you won't be as likely to mess things up?
18:45:00 <carter> depends
18:49:25 <orion> In what cases is it better to use Chan instead of TChan?
19:04:25 <carter> depend son what youre doing
19:04:30 <carter> they are fundamentally diffferent
19:04:51 <carter> if you just want a "transcational" semantics to your concurrency and thats your only need, STM based ops will leave you happier
19:05:00 <carter> if you have certain liveness / progress guarantee needs
19:05:06 <carter> or certain contention loads
19:05:10 <carter> STM may not be the way to roll
19:06:05 <orion> I see.
19:14:50 <Rusk101> I'm so close guys and gals, I can taste it. If anybody has a few minutes. Please let me know why my solvePoly function wont work, but will compile. (memory loss)? http://lpaste.net/103058
19:18:10 <dmj`> Rusk101: solvePoly seems very inefficient at first glance
19:18:41 <Rusk101> Yes, it probably is. But I'm trying to get it to work first, and then improve.
19:19:41 <Rusk101> I'm thinking the problem is when Im trying to pass mkPoly of a single element in a list
19:20:04 <Rusk101> *solvePoly
19:20:30 <l0cust> Hey, so I'm having another odd problem
19:20:36 <l0cust> getArgs seems to be failing me
19:21:03 <l0cust> No matter what I put as arguments, it doesn't work
19:22:14 <carter> hows it not work Rusk101 ?
19:22:46 <carter> @tell srhb you've been very helpful some point in the past week, thanks! (i forget when, but don't recall if I said thank you)
19:22:46 <lambdabot> Consider it noted.
19:25:06 * hackagebot ffmpeg-light 0.3 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.3 (AnthonyCowley)
19:26:06 <pavonia> l0cust: How are you using it?
19:28:57 <jakex> why does this work, over (_1._Just) (+1) (Just 1,2), but this doesn't: view (_1._Just) (Just 1,2)?
19:29:05 <jakex> > view (_1._Just) (Just 1,2)?
19:29:07 <lambdabot>  <hint>:1:28:
19:29:07 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:29:14 <jakex> > view (_1._Just) (Just 1,2)
19:29:17 <lambdabot>  No instance for (GHC.Show.Show a0)
19:29:18 <lambdabot>    arising from a use of ‘M641350835763633540826930.show_M6413508357636335408...
19:29:18 <lambdabot>  The type variable ‘a0’ is ambiguous
19:29:18 <lambdabot>  Note: there are several potential instances:
19:29:18 <lambdabot>    instance [safe] GHC.Show.Show
19:29:24 <Rusk101> carter: It doesnt work when I pass solvePoly [5]
19:29:34 <jakex> > view (_1._Just) (Just (1 :: Int), 2)
19:29:35 <carter> writing good solvers is tricky!
19:29:36 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
19:29:36 <lambdabot>    arising from a use of ‘Control.Lens.Prism._Just’
19:29:53 <carter> what is the solving alg?
19:30:11 <edwardk> > prevew (_1._Just) (Just 1, 2)
19:30:12 <lambdabot>  Not in scope: ‘prevew’
19:30:12 <lambdabot>  Perhaps you meant one of these:
19:30:12 <lambdabot>    ‘preview’ (imported from Control.Lens),
19:30:12 <lambdabot>    ‘ipreview’ (imported from Control.Lens),
19:30:12 <lambdabot>    ‘previews’ (imported from Control.Lens)
19:30:18 <edwardk> > preview (_1._Just) (Just 1, 2)
19:30:21 <lambdabot>  Just 1
19:30:43 <edwardk> view works for lenses and isomorphisms, where the target is guaranteed to be there.
19:30:44 <jakex> why preview and not view?
19:30:52 <jakex> ah
19:30:55 <edwardk> when you feed it a traversal, however, it needs a monoid
19:31:05 <edwardk> There is no Monoid for Int
19:31:19 <edwardk> after all. what should it say for Nothing?
19:31:21 <jakex> got it, thanks
19:31:44 <jakex> right, it can't return anything
19:31:45 <edwardk> Now, if we _know_ there is a target we can use 'singular' or ^?!'
19:32:03 <edwardk> > [1..10]^.singular (ix 4)
19:32:07 <lambdabot>  mueval-core: Time limit exceeded
19:32:13 <edwardk> > [1..10]^.singular (ix 20)
19:32:16 <lambdabot>  *Exception: singular: empty traversal
19:32:47 <edwardk> x^? y is preview y x         but  x^?!y is effectively     x^.singular y
19:33:19 <edwardk> preview gives back the first match if any and ignores the rest
19:34:29 <edwardk> singular takes any traversal that you trust in your heart of hearts to have at least one target, and gives you a lens to the first such target.
19:35:28 <jakex> I see
19:38:45 <jakex> how about this, I want to return True if _1._Just is less than 0, otherwise False
19:39:29 <jakex> I guess preview (_1._Just) x < Just 0 ?
19:40:29 <jakex> well no, this returns True too.
19:40:35 <jakex> > preview (_1._Just) (Nothing, 0) < Just 0
19:40:39 <lambdabot>  True
19:40:41 <edwardk> > has (_1._Just.filtered (<0)) (Just 1, "buffalo")
19:40:43 <lambdabot>  False
19:40:51 <edwardk> > has (_1._Just.filtered (<0)) (Just (-5), "buffalo")
19:40:53 <lambdabot>  True
19:41:26 <haasn> > "Hello world!" & partsOf (traverse.filtered isLetter) %~ over (traverse.indices even) toUpper . over (traverse.indices odd) toLower
19:41:28 <lambdabot>  Couldn't match expected type ‘(GHC.Types.Char
19:41:28 <lambdabot>                                 -> Data.Functor.Identity.Identity GHC.Types.C...
19:41:28 <lambdabot>                                -> a0 -> Data.Functor.Identity.Identity GHC.Ty...
19:41:28 <lambdabot>              with actual type ‘[i0]’Couldn't match expected type ‘GHC.Arr.Arr...
19:41:28 <lambdabot>              with actual type ‘a1 -> GHC.Types.Bool’Couldn't match expected t...
19:41:30 <jakex> nice
19:41:31 <haasn> I wonder if this can be improved
19:41:37 <haasn> (wait, why isn't it working?)
19:41:53 <edwardk> indices in lambdabot isn't Lens.indices
19:42:07 <haasn> > "Hello world!" & partsOf (traverse.filtered isLetter) %~ over (traversed.Lens.indices even) toUpper . over (traversed.Lens.indices odd) toLower
19:42:07 <edwardk> need to qualify it
19:42:10 <lambdabot>  "HeLlO wOrLd!"
19:42:31 <haasn> > "Hello world!" & partsOf (traverse.filtered isLetter) %~ imap (\i -> if even i then toUpper else toLower)
19:42:33 <lambdabot>  "HeLlO wOrLd!"
19:42:53 <edwardk> bool toUpper toLower . even ?
19:43:08 <haasn> > "Hello world!" & partsOf (traverse.filtered isLetter) %~ imap (bool toLower toUpper . even)
19:43:09 <lambdabot>  "HeLlO wOrLd!"
19:43:16 <haasn> I did not realize we had this in lambdabot already!
19:43:20 <haasn> (and it's the other way around, False True)
19:43:34 <edwardk> %~ imap can become imapped %@~
19:43:55 <haasn> > "Hello world!" & partsOf (traverse.filtered isLetter).imapped %@~ bool toLower toUpper . even
19:43:57 <lambdabot>  "HeLlO wOrLd!"
19:44:02 <haasn> awesome, did not know that transformation
19:44:23 <haasn> I wonder if there's a way to avoid partsOf by reindexing after the filtered
19:44:33 <haasn> > "Hello world!" & indexing (traverse.filtered isLetter).imapped %@~ bool toLower toUpper . even
19:44:34 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘f0 GHC.Types.Char’
19:44:34 <lambdabot>  Expected type: Control.Lens.Internal.Indexed.Indexed
19:44:34 <lambdabot>                   i0 GHC.Types.Char (Data.Functor.Identity.Identity GHC.Types...
19:44:34 <lambdabot>                 -> GHC.Types.Char -> Data.Functor.Identity.Identity GHC.Types...
19:44:34 <lambdabot>    Actual type: Control.Lens.Internal.Indexed.Indexed
19:44:37 <haasn> > "Hello world!" & indexing (traverse.filtered isLetter) %@~ bool toLower toUpper . even
19:44:39 <lambdabot>  "HeLlO wOrLd!"
19:45:05 <edwardk> :t reindexed even traverse
19:45:06 <lambdabot>     Couldn't match type ‘a1 -> f b1’ with ‘Indexed i0 a b’
19:45:06 <lambdabot>     Expected type: Indexed i0 a b -> t a1 -> f (t b1)
19:45:06 <lambdabot>       Actual type: (a1 -> f b1) -> t a1 -> f (t b1)
19:45:14 <edwardk> :t reindexed even traversed
19:45:14 <lambdabot> (Indexable Bool p, Traversable f, Applicative f1) => p a (f1 b) -> f a -> f1 (f b)
19:45:33 <edwardk> > "hello"^@..reindexed even traversed
19:45:35 <lambdabot>  [(True,'h'),(False,'e'),(True,'l'),(False,'l'),(True,'o')]
19:45:41 <haasn> > "Hello world!" & reindexed even (traverse.filtered isLetter) %@~ bool toLower toUpper
19:45:43 <lambdabot>  Couldn't match type ‘Control.Lens.Internal.Indexed.Indexed
19:45:43 <lambdabot>                         i0 GHC.Types.Char (Data.Functor.Identity.Identity GHC...
19:45:43 <lambdabot>                with ‘GHC.Types.Char -> Data.Functor.Identity.Identity b’
19:45:43 <lambdabot>  Expected type: Control.Lens.Internal.Indexed.Indexed
19:45:43 <lambdabot>                   i0 GHC.Types.Char (Data.Functor.Identity.Identity GHC.Types...
19:45:47 <haasn> > "Hello world!" & reindexed even (traversed.filtered isLetter) %@~ bool toLower toUpper
19:45:49 <lambdabot>  "HeLlO WoRlD!"
19:46:07 <haasn> I'm happy with that. Thanks :)
19:46:11 <edwardk> np
19:47:28 <ruzu> haskerru!
19:50:30 <Fuuzetsu> はすける
19:56:33 <hattusili_III> do you have to declare data types in order in a file?
19:57:08 <jle`> hattusili_III: what do you mean?
19:57:20 <haasn> hattusili_III: the order of declarations does not matter
19:57:26 <jle`> haskell declarations technically have no ordering, because of laziness.
19:57:31 <jle`> but there is one slight exception
19:57:34 <haasn> laziness has little to do with this
19:57:56 <haasn> what's the exception?
19:58:02 <hattusili_III> haasn, it doesn't? Not even for `data X = X { b :: B ... } data B = B Int`
19:58:04 <jle`> pattern matches
19:58:07 <jle`> go from top down
19:58:27 <haasn> hattusili_III: correct, the order does not matter - haskell modules are treated as a unit
19:58:57 <jakex> any way to clean up type declaration here? errorIf pred lens msg obj = when (has (lens.filtered pred) obj) (error msg)
19:58:59 <hattusili_III> ah, thank you. something else must be causing my problem
19:59:08 <haasn> hattusili_III: maybe you could paste your code and we can figure it out :)
19:59:08 <jakex> inferred type is this :) : Monad m => (a -> Bool) -> ((a -> Accessor Data.Monoid.Any a) -> s -> Accessor Data.Monoid.Any s) -> [Char] -> s -> m ()
19:59:16 <haasn> jle`: right, but those are part of the same declaration - technically
19:59:23 <haasn> jle`: they have to be adjacent, too
19:59:36 <jle`> yeah, it's a technicality :|
19:59:49 <jle`> they are the same declaration
19:59:58 <jle`> so... in that sense, declarations are unordered
20:00:10 <jle`> declaration in the syntactical/ast sense
20:00:36 <hattusili_III> haasn, here: https://gist.github.com/MarkJr94/11163981#file-types-hs-L23 thanks for the help
20:01:03 <edwardk> errorIf pred lens = lens . filtered pred . error -- perhaps?
20:01:10 <edwardk> er
20:01:25 <edwardk> yeah that should work
20:02:20 <edwardk> that makes more sense if you  eta expand it back though
20:02:34 <jakex> edwardk nice, but I meant the type. is it possible to write a shorter type than what ghc inferred?
20:03:28 <edwardk> You can write it nicer using Monod m => (a -> Bool) -> Gettng Any s a -> String -> s -> m ()
20:03:35 <edwardk> er Getting Any s a
20:03:56 <edwardk> Gettng Any s a expands out to that middle part
20:04:15 <edwardk> er and Monad m obviously
20:04:40 <jakex> looks sweet, let me try
20:05:50 <edwardk> you may want to fail rather than error above as well.
20:06:00 <jakex> in what module is Any?
20:06:10 <edwardk> Data.Monoid.Any
20:06:16 <edwardk> so its in Data.Monoid
20:08:50 <jakex> worked, thanks, this will save me a lot of lines of code. by the way, should I consider throwing IO exception instead of using fail? I am not really sure when to use error, when fail and when IO error
20:11:33 <c_wraith> jakex: A simple hueristic is "never use fail"
20:12:36 <edwardk> c_wraith: =P
20:12:48 <edwardk> i tend to favor fail over error when both could work
20:13:45 <carter> :t fail
20:13:47 <lambdabot> Monad m => String -> m a
20:14:08 <edwardk> fail can smuggle a message out about what went wrong. sure its not really part of Monad per se, but when it is used as an alternative to _error_ I can take it.
20:14:24 <edwardk> since the default after all to error. ;)
20:14:29 <carter> ok
20:14:33 <edwardk> is to
20:14:35 <carter> vs ErrorT
20:14:44 <carter> where fial would be Left String
20:14:46 <edwardk> ErrorT is a nice well meaning mistake
20:14:47 <carter> fail
20:14:51 <carter> ?
20:15:01 <carter> i thought ErrorT = EitherT?
20:15:04 <carter> ???
20:15:16 <edwardk> notice the different constraints on the class in EitherT.
20:15:25 <carter> :k ErrorT
20:15:25 <edwardk> er on the data type
20:15:27 <lambdabot> * -> (* -> *) -> * -> *
20:15:33 <carter> :inof ErrorT
20:16:08 <carter> wheres EitherT defined?
20:16:11 <edwardk> ErrorT e m is a Monad if its underlying type m is a Monad _and_ if the e is an instance of Error.
20:16:18 <edwardk> 'either'
20:16:33 <edwardk> EitherT drops the constraint on 'e'
20:16:50 <edwardk> his screws up 'fail' but nothing of value is lost ;)
20:16:55 <edwardk> er this
20:17:02 <carter> eitherT has no constraints
20:17:07 <edwardk> yep
20:17:12 <carter> yay
20:17:25 <edwardk> which is critical for its use in apomorphisms, etc.
20:18:09 <edwardk> i don't want to destroy something that has a deep fundamental reason to exist as symmetric to paramorphisms just so someone somewhere can call a function that shouln't have been put in Monad to begin with
20:19:37 <SrPx> http://o7.no/1lx8hES this is not a functor?
20:26:06 <pavonia> SrPx: Well, you can define a Functor instance for it
20:29:32 <jle`> SrPx: more context?
20:31:53 <jle`> functor /= Functor
20:33:53 <jakex> is it possible to have do block for a Maybe monad within a do block for an IO monad?
20:34:33 <jle`> jakex: yeah
20:34:37 <jle`> well
20:34:39 <jle`> in a let statement
20:35:09 <jle`> i think you can put any valid declaration in a let statement
20:35:29 <c_wraith> or anywhere else the do block type checks.
20:35:42 <jle`> yea,h that too
20:35:57 <jle`> x <- return $ do ...
20:36:30 <jakex> got it thanks
20:41:42 <jakex> :t \pred lensX lensY msg obj -> when (liftA2 pred (preview lensX obj) (preview lensY obj) == Just True) (error msg)   -- I probably won't have a clue what I did here a week from now
20:41:43 <lambdabot> Monad m => (a -> b -> Bool) -> Getting (First a) t a -> Getting (First b) t b -> [Char] -> t -> m ()
20:42:05 <jakex> why is it `Getting (First a) s a' and not `Getting Any s a' by the way?
20:42:25 <edwardk> preview uses First a
20:42:41 <edwardk> we can do better btw
20:42:46 <jakex> go on :)
20:43:24 <edwardk> we have a few options here
20:44:20 <edwardk> runFold (pred <$> Fold lensX <$> Fold lensY)   -- gives you a Fold that gets both answer and applies pred
20:44:48 <edwardk> so if we do
20:45:45 <edwardk> runFold (pred <$>  Fold lensX <*> Fold lensY).filtered id -- you have one that trivially folds over the cases where pred holds
20:46:30 <jakex> :t \pred lensX lensY msg obj -> when (preview (runFold (pred <$> Fold lensX <$> Fold lensY) obj == Just True) (fail msg)
20:46:32 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
20:47:01 <edwardk> so runFold (pred <$> Fold lensX <*> Fold lensY) (filtered id (error msg)) obj
20:47:11 <jakex> ah
20:47:13 <edwardk> Fold/runFold is newer than the version on lambdabot
20:47:28 <edwardk> anyways once you're there you can start @pl'ing to peel off args
20:49:26 <jakex> cool, thanks again :)
21:03:07 <SrPx> jle`: pavonia sorry I didn't see the answers
21:03:18 <SrPx> well I don't know, just passed by it like it didnt matter
21:12:05 <SrPx> quick question, how do I create a small program (one liner?) that when called on the command line like that "my_program 4" will print 4 on the screen?
21:12:36 <SrPx> main = print (what here)
21:13:35 <mjrosenb> SrPx: I don't think there's a simple thing you can add there to make it work
21:13:45 <SrPx> ):
21:14:02 <mjrosenb> SrPx: since print expects an |a|, and getting the program arguments is IO String
21:15:07 <SrPx> mrowe_away: putStrLn then, just, how'd that look?
21:15:12 <SrPx> I don't know how to get arguments
21:15:22 <mjrosenb> SrPx: that being said |main = getArgs >>= (putStrLn . head) will probably do what you want
21:15:32 <mjrosenb> after importing System.Environment
21:16:09 <SrPx> Hm, can it be more elegant if I input the number after calling the program, then?
21:16:46 <mjrosenb> SrPx: I'm not sure what you're asking?
21:16:54 <liftM> main = getLine >>= putStrLn
21:17:08 <SrPx> getLIne, that is it. is there a getNumber ?
21:17:36 <mjrosenb> SrPx: that reads from stdin, not the command line arguments
21:17:50 <mjrosenb> oh, that *is* what you meant.
21:17:52 <SrPx> yes, that is what I asked, if I could make it more elegant by reading form the stdin instead ^^
21:18:01 <jakex> main = mapM_ putStrLn =<< getArgs
21:18:25 <mjrosenb> SrPx: you can manually do it with read or reads.
21:18:38 <SrPx> just, how do I read a number from stdin?
21:18:44 <liftM> you could use readLn
21:18:53 <SrPx> ie, this will obviously not typecheck main = do { x <- getLine; putStrLn (x+x) }
21:19:03 <SrPx> can I convert x to a number elegantly?
21:19:11 <c_wraith> :t readLn
21:19:13 <lambdabot> Read a => IO a
21:19:17 <jakex> @src readLn
21:19:17 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
21:19:24 <mjrosenb> c_wraith: ooh, is that new?
21:19:30 <jakex> ok that didn't help
21:19:34 <c_wraith> mjrosenb: not particularly
21:19:53 * mjrosenb last read the full base library documentation in 2009, so 'new' is a relative term.
21:20:15 <SrPx> jakex: hmm can I get that in a single line? getLine and readIO? composing them somehow?
21:20:34 <jakex> main = do x <- readLn; print (x+x)
21:20:34 <c_wraith> SrPx: you mean exactly like I showed above?
21:20:54 <mjrosenb> oh, readIO, that makes sense.
21:22:12 <SrPx> oh nevermind, I was stupid
21:22:17 <SrPx> and understand it wrong, thanks (:
21:25:32 <bulletbill22> Hello all. I'm trying to get some code of mine to work. The whole thing is pretty big but I've posted here just the part that I'm working on I need help with: http://pastebin.com/9F9TSabB
21:25:46 <bulletbill22> I'm getting this error: ERROR "./ColtLang.hs":347 - Type error in application *** Expression     : funcMinus'' v vs *** Term           : v *** Type           : Integer *** Does not match : Value
21:27:04 <bulletbill22> Anyone?
21:27:17 <bulletbill22> It says that v is an integer even though it was declared a Number
21:29:30 <dmj`> bulletbill22: it's an integer because you're pattern matching on the constructor
21:29:30 <dmj`>  
21:30:11 <bulletbill22> http://lpaste.net/103059
21:30:37 <dmj`> data Value = Number Integer; f :: [Value] -> Value; f (Number v <----- *v is an Integer here* : vs)
21:31:29 <dmj`> instead of funcMinus' (Number v:vs), try funcMinus' (v:vs)
21:31:46 <dmj`> then it will be a Number
21:31:57 <pavonia> or "v@(Number _) : vs" to keep the pattern match
21:33:27 <bulletbill22> That fixed it, thanks. I still don't really understand why declaring it as Number it gets interpreted as an Integer.
21:33:45 <zzo38> Is an indexed writer monad, the most obvious kind of indexed monad? To me, it is first one I think of.
21:34:49 <dmj`> bulletbill22: suppose we have data Person = Person { name :: String, age :: Int }.... if I have a function f (Person name age), in this context "name" is of type String and "age" of type Int.
21:35:26 <bulletbill22> OK
21:35:36 <dmj`> you pattern matched the data constructor away
21:42:02 <bulletbill22> I get it now
21:46:48 <zzo38> How much indexed monads and indexed comonads would you know of?
21:49:50 <dmj`> bulletbill22: nice
21:53:47 <phy1729> I assume that haskell doesn't do function overloading because currying is that right?
21:54:40 <pavonia> You can have overloaded functions using type classes
21:55:07 * phy1729 goes to google
21:55:49 <phy1729> thanks pavonia
21:55:56 <carter> @faq can haskell do anything we ask it?
21:55:57 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
21:56:09 <carter> darn
21:56:12 <carter> wrong bot comand
21:56:58 <pavonia> No, the command was correct :'(
21:57:36 <mniip> What?
21:57:39 <carter> copumpkin: who's in charge of lambda bot?
21:58:02 <mniip> You're telling me there's something haskell can't do?
21:58:34 <dmj`> carter: I thought lambdabot roamed free
21:58:38 <copumpkin> to find out
21:58:40 <copumpkin> I type /whois lambdabot
21:59:01 <carter> int-e
21:59:01 <copumpkin> and I see [00:58:09] lambdabot has userhost ~lambdabot@silicon.int-e.eu and real name "Lambda_Robots:_100%_Loyal"
21:59:08 <carter> ok
21:59:50 <carter> int-e: is lambda bot heavily loaded lately? @faq is acting funny, and some of edward's lens golf hit mueval limit exceeded on tiny examples
22:02:10 <Guest64052> what is haskel?
22:02:15 <Guest64052> is it C/Python kind of language?
22:02:28 <copumpkin> haskell.org
22:02:40 <MP2E> there is way too much to explain here. Read about it on the website.
22:03:10 <Guest64052> ok
22:04:13 <Guest64052> i heard name of VB, JAVA C & python usually on intenet googling but haskel very rare why?
22:04:24 <copumpkin> because fewer people know about it
22:04:28 <MP2E> pretty much
22:05:07 <MP2E> functional programming just hasn't "caught on" yet. It seems that things are now moving towards more functional languages, but it's more by adding features from FP langauges into other languages
22:05:38 <Guest64052> what are other FP languages?
22:05:42 <MP2E> I kinda doubt that a purely functional language will ever immediately supplant imperative languages, but they probably will gain popularity as things become more multithreaded
22:05:44 <Guest64052> competitor of haskel
22:05:54 <tac_> Scala, Ocaml, F#
22:06:02 <tac_> Clojure, Erlang
22:06:03 <copumpkin> Guest64052: http://en.wikipedia.org/wiki/Functional_programming
22:06:08 <Guest64052> oh thanks
22:06:23 <Guest64052> does it require compiler/interpreter?
22:06:29 <copumpkin> it's much easier to get help if you have specific questions that can't be answered by trivial googling
22:06:32 <Guest64052> why it is called "functioinal"?
22:06:49 <itsmonktastic> seeing stuff like Java streams, people are going to get more and more used to computations as values IMO. All the promise libraries too.
22:07:07 <tac_> Guest64052: It's called functional because functions in Haskell are closer to functions in the mathematical sense
22:07:20 <copumpkin> Guest64052: if you show that you've put some effort into finding basic answers, I'll put some effort into answering your questions. But you haven't shown that
22:07:20 <Guest64052> functions in excel i have used
22:07:22 <Guest64052> like convert
22:07:24 <Guest64052> etc..
22:07:30 <Guest64052> a kind of subroutine
22:07:31 <Guest64052> is it so?
22:08:23 <Guest64052> copumpkin: i can put all efforts but the thign is that i ll be lost a google due to my curious nature & will be out of focus whiel reading numerous blogs, websites, articles etc..
22:08:28 <SrPx> How can I make this point-free? Would it become much more complex? (\x -> print $ take x $ filter even $ fibs)
22:08:31 <Guest64052> hecne need one-to-one chat help someitme
22:08:41 <peddie> SrPx: use @pl with the bot
22:08:42 <copumpkin> Guest64052: this isn't one-to-one chat. This is one-to-1200 chat
22:08:53 <SrPx> @pl (\x -> print $ take x $ filter even $ fibs)
22:08:53 <lambdabot> print . flip take (filter even fibs)
22:08:53 <MP2E> Yeah and it's kinda irritating if you don't look up anything
22:08:54 <Guest64052> copumpkin: sorry for that
22:08:58 <SrPx> peddie: cool, thanks
22:09:06 <Guest64052> but my questions train is no longer
22:09:10 <Guest64052> it will end soon
22:09:38 <albeit> What does the "pl" bot stand for?
22:09:55 <peddie> it's a function in lambdabot, not its own bot, and "pointless"
22:11:56 <Guest64052> ok let me ask one question: which resources ( books/websites/blogs/articles)about haskell cannot be found easily via search engine(google/duckduckgo/others). if you know any such resources please share
22:16:20 <solrize> http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable   next release may 2013
22:16:28 <solrize> does that mean haskell platform is dead?
22:16:36 <Ireneista> Guest64052: if you want your thing to be completely impossible to find, I suggest naming it “Internet”.
22:16:53 <lispy> solrize: I don't think that trac is maintained
22:16:59 <lispy> solrize: didn't the hp move to github?
22:17:02 <solrize> http://www.haskell.org/platform/
22:17:03 <Guest64052> http://tryhaskell.org/#step4 i found this link
22:17:05 <solrize> oh hmm
22:17:08 <Guest64052> it is very helpful & interactive
22:17:15 <Guest64052> thanks
22:17:35 <solrize> clicking "download haskell" from haskell.org home page still goes to that page
22:18:29 <solrize> front page doesn't mention any releases later than 2013.2
22:18:48 <solrize> is haskell.org itself in disrepair?  it doesn't mention upcoming bayhac 2014
22:19:12 <MP2E> No, just a little behind. It says May 2013 because GHC 7.8 took longer to get out the door than expected.
22:19:14 <solrize> https://github.com/haskell/haskell-platform  this is more recent
22:19:56 <SrPx> Hmm what is a short way to get the sum of the digits of a number
22:20:01 <savanni> Ooo, BayHac looks like fun!  I hadn't heard of that one yet.
22:20:06 <MP2E> 2 gsoc projects towards darcs? seriously?
22:20:15 <MP2E> Why isn't the idea to move towarsd git yet?
22:20:39 <pavonia> > sum $ map read "1234"  -- SrPx
22:20:40 <SrPx> I need to convert the number to a decimal string (don't know how to), then convert each digit to an int (don't know how to), then sum... which is the only part I know ?
22:20:40 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
22:20:40 <lambdabot>  Expected type: [GHC.Base.String]
22:20:40 <lambdabot>    Actual type: [GHC.Types.Char]
22:20:43 <MP2E> what does darcs offer that git doesn't. From the perspective of a git user, darcs is inefficient, cumbersome, and 'weird' for the sake of maintaining keyword compat with svn
22:20:48 <SrPx> pavonia: oh that was simple, thanks
22:20:55 <solrize> savanni http://www.haskell.org/haskellwiki/BayHac2014
22:20:56 <pavonia> simple and wrong :p
22:20:57 <lispy> MP2E: some of the GSoC stuff (at least in the past) has been precisely to make it easier to switch to git.
22:21:00 <SrPx> Oh I see what read does now. D'oh
22:21:07 <pavonia> > sum $ map (read . pure) "1234"
22:21:08 <MP2E> I see
22:21:09 <lambdabot>  10
22:21:13 <MP2E> ah yes darcs-bridge
22:21:22 <savanni> solrize: that's exactly the page Google sent me to.
22:21:26 <solrize> mp2e darcs is more logical, git is confusing as hell
22:21:28 <SrPx> pavonia: pure? PS: how do I convert 1234 to "1234"
22:21:37 <solrize> > show 1234
22:21:38 <lambdabot>  "1234"
22:21:43 <MP2E> git is confusing if you're trying to think of it like svn or an older VCS yeah
22:21:58 <MP2E> It's a filesystem containing atomic changes
22:22:02 <SrPx> solrize: ... oh god . D'oh again, thanks
22:22:02 <pavonia> SrPx: pure make a single charcter into a string, like 'c' -> "c"
22:22:11 <MP2E> branches are lightweight and powerful, you can rebase pretty much anything into anythin else and edit history on the fly
22:22:19 <MP2E> darcs has... lots of patches everywhere
22:22:48 <lispy> git vs. darcs isn't really a #haskell topic. You're welcome to discuss it in #haskell-blah.
22:22:55 <MP2E> Ah yes, sorry about that :P
22:23:00 * MP2E stops griping
22:23:53 <itsmonktastic> > ord '1'
22:23:54 <lambdabot>  49
22:24:11 <itsmonktastic> SrPx: Possibly an easy to understand way to read digits ^
22:24:14 <SrPx> pavonia: eh pure is not in scope
22:24:36 <SrPx> hm?
22:25:37 <lispy> MP2E: BTW, if you're dissatisfied with the way the Haskell GSoC works, you can get involved in the process next year.
22:25:45 <itsmonktastic> :t ord
22:25:46 <solrize> is STM now out of favor?
22:25:48 <lambdabot> Char -> Int
22:25:59 <solrize> as opposed to communicating through chans/mvars
22:26:05 <lispy> MP2E: It's good to have lots of people evaluate projects and even mentor!
22:26:34 <itsmonktastic> SrPx: ord allows you to go Char -> Int, instead of having to go Char -> String -> Int
22:26:40 <MP2E> That would be neat, signups are typically march?
22:26:53 <itsmonktastic> SrPx: but you'd have to minus 48 to get the int you want
22:26:56 <tac-tics> solrize: correctness has always been out of favor when performance was a semi-viable alternative.
22:26:56 <savanni> I *hope* it's not out of favor.  I depend on STM to do thread data sharing in my project.
22:29:18 <solrize> i've heard it slows down badly when there's contention...  i haven't used chans in haskell but have programmed in that style in python and erlang and it's pretty easy to get right, you just get some communications overhead
22:29:26 <lispy> MP2E: that sounds right
22:30:30 * hackagebot ffmpeg-light 0.3.0.1 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.3.0.1 (AnthonyCowley)
22:31:31 <pavonia> SrPx: pure is from Control.Applicative, but you can also use return or (: []) in this case
22:31:34 <Heffalump> MP2E: haskell.org typically asks for extra slots specifically for darcs, rather than them coming out of the general haskell pool
22:31:52 <MP2E> good to know :P
22:41:32 <SrPx> Is there a notation to invert "f $ g $ h $ x" ?
22:41:40 <johnw> solrize: it depends on the nature of the contention
22:42:15 <johnw> STM can be a big win for "many brief readers one long writer", but can get resource starved for "many long readers one brief writer".  It all depends on the use case
22:42:33 <zq> Cale: hi, are you around?
22:42:39 <solrize> oh man that's the wrong way from what most ppl would want  hmm thanks
22:43:09 <johnw> solrize: the advantage to having no locks is huge; but if you are rapidly mutating state which causing a bunch of transaction to restart all the time, then you actually *want* locks
22:43:18 <solrize> i guess the reads can be kept short using a single persistent data structure
22:43:46 <johnw> i have a module I've been working on which is meant to address part of this problem
22:44:03 <johnw> it eliminates contention entirely by delaying the rate at which updates are seen
22:44:04 <solrize> well if there's long reads and occasional writes...
22:44:12 <johnw> occasional writes should be fine
22:44:32 <phy1729> is there a way to tell haskell I really do want an Int I know this won't return a frac?  foo x = if (even x) then x / 2 else (3*x)+1
22:44:44 <johnw> x `div` 2
22:44:47 <solrize> ints don't have division
22:44:52 <solrize> x`div`2 or x`quot`2
22:45:09 <solrize>  / is only for fractionals
22:45:14 <phy1729> ah thanks
22:45:43 <solrize> don't use Int unless you have to
22:45:45 <solrize> use Integer
22:46:06 <solrize>  since you don't know if that sequence might overflow Int
22:46:12 <solrize> Int is evil
22:46:44 <phy1729> I just wanted to play with takeWhile and iterate but thanks for the advice
22:47:18 <johnw> as with most evils, we endure it for performance
22:49:53 <solrize> int should at least throw an error if it overflows... otherwise it turns into a completely different type instead of a subrange of Integer
22:51:44 <bulletbill22> How do I get a sebstring from a string using indeces? e.g. I pass "I am a string", 4, and 10 to a function, which returns " a stri"
22:52:01 <johnw> drop 4, then take 10
22:52:20 <lispy> @hoogle String -> Int -> String
22:52:20 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
22:52:20 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
22:52:20 <lambdabot> Prelude drop :: Int -> [a] -> [a]
23:00:23 <bulletbill22> johnw: thanks
23:23:02 <BMeph_> Actually, that'd be take 10, then drop 4.
23:23:32 <Arcsech> Does anybody know what Cabal means by this? http://lpaste.net/103060
23:23:34 <remib> Hi
23:23:38 <Arcsech> I'm trying to install EclipseFP
23:24:22 <red_ph> Hello
23:24:36 <Arcsech> On Fedora 20, alread tried clearing .cabal and .ghc dirs, then reinstalled haskell-platform
23:25:08 <remib> I'm tryinng to understand how monad works. I'm not sure how to interpret "return": When typing "return 3", I don't get how ghci "chooses" what monad to put 3 in ?
23:26:55 <shachaf> ghci defaults to IO
23:27:30 <remib> Ok, and then, how do you choose what to get ?
23:27:37 <shachaf> You might ask: When I type [], how does ghci choose what type the empty list has? It defaults to [()]
23:27:45 <shachaf> Use it in a context where it would get that type.
23:27:57 <shachaf> return 3 :: [Int]
23:28:17 <remib> Ah, yeah
23:29:03 <remib> That's nice, thank you!
23:29:15 <pavonia> Arcsech: Does this happen for all packages?
23:29:54 <Arcsech> Nope, I could install hoogle and a couple others just fine, but buildwrapper and scion-browser both do that
23:32:06 <pavonia> Arcsech: Could you run it again with -v3 and paste the log?
23:35:01 <makalu> everyone says you should use cabal sandboxes. But what if I want to just test some package? I would have to create a cabal project and a sandbox to pull in the dependencies? Is there an easier way?
23:35:11 <makalu> I would imagine Nix although I have never used it
23:38:15 <supki> makalu: you don't need to create a cabal project
23:38:45 <supki> cabal sandbox init && cabal install ...
23:40:13 <makalu> that's great
23:40:15 <makalu> thanks supki
23:43:22 <makalu> If I would like cabal to build a library and then a binary using that library, how would I list the dependencies? If the binary depends on the library then cabal configure fails because it's not built yet.
23:43:25 <Arcsech> pavonia: Here's the -v3 log: http://lpaste.net/103062
23:45:11 <gamegoblin> mmm fastest way to check if a list is homogenous? e.g. [1,1,1,1,1,1]
23:45:39 <lfairy> (<= 1) . length . group
23:45:48 <gamegoblin> That’s what I was thinking
23:46:30 <lfairy> case xs of [] -> True; (y:ys) -> all (== y) ys
23:46:46 <shachaf> That's surely not "fastest" given that it just never returns on infinite lists that it can fail early on.
23:46:48 <gamegoblin> Wonder which is faster
23:46:59 <gamegoblin> Hmmmm
23:47:40 <makalu> never mind my question
23:47:41 <lfairy> shachaf: is the second one better? I think all terminates on the first False
23:48:01 <shachaf> The second one is better.
23:48:21 <shachaf> I won't comment on faster, actually, because I don't like that question.
23:49:16 <lfairy> [insert rant on different definitions of "performance" here]
23:50:38 * hackagebot IPv6Addr 0.5 - Library to deal with IPv6 address text representations.  http://hackage.haskell.org/package/IPv6Addr-0.5 (MichelBoucey)
23:50:40 <pavonia> Arcsech: Hhm, no idea what's the problem, sorry
23:51:29 <Arcsech> pavonia: Oh well, thanks for looking at it anyway
23:51:34 <pavonia> "rejecting: ghc-paths-0.1.0.9 (unknown package: ghc)" looks suspicious
23:51:43 <Arcsech> Yeah, I saw that too but IDK what to make of it
23:53:24 <pavonia> Arcsech: Does "ghc-pkg check" give you any output?
23:55:04 <supki> Arcsech: how did you install ghc?
23:55:22 <supki> some linux distroes (e.g. fedora) pack ghc api package separately
23:55:25 <supki> for some reason
23:56:55 <Arcsech> supki: That's probably it, I'm on fedora.  I just did "yum install haskell-platform"
