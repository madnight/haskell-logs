00:00:10 <Heather> :t ((</> "s") <$> takeDirectory <$> getExecutablePath)
00:00:11 <lambdabot>     Not in scope: `</>'
00:00:11 <lambdabot>     Perhaps you meant one of these:
00:00:11 <lambdabot>       `<>' (imported from Data.Monoid),
00:00:20 <Heather> :t ((++ "s") <$> takeDirectory <$> getExecutablePath)
00:00:22 <lambdabot> Not in scope: `takeDirectory'
00:00:22 <lambdabot> Not in scope: `getExecutablePath'
00:00:23 <erisco> Heather, that may be the type but it will not compile
00:00:36 <Heather> erisco: really?
00:00:43 <erisco> I don't think so
00:00:51 <Heather> erisco: try it
00:02:55 <erisco> hm seems like a fluke
00:03:33 <erisco> let me check the desugared code
00:03:48 <Heather> erisco: ... fluke?
00:04:11 <erisco> yes because it does not make sense
00:04:16 <Heather> erisco: it does
00:05:16 <Heather> but I'm not sure what is the type of (</> "sharingan.yml") <$> takeDirectory <$> getExecutablePath
00:05:22 <Heather> it works different
00:06:08 <startling> :t (</> "whatever")
00:06:09 <lambdabot>     Not in scope: `</>'
00:06:09 <lambdabot>     Perhaps you meant one of these:
00:06:09 <lambdabot>       `<>' (imported from Data.Monoid),
00:06:11 <startling> ugh.
00:07:03 <Heather> startling: you can replace it with ++
00:07:07 <erisco> startling, I am thinking it is  (</>) :: FilePath -> FilePath -> FilePath
00:07:22 <startling> sure. I was just going to walk Heather through figuring out the type of that expression.
00:07:58 <startling> Heather, ok, so you can ignore the last bit.
00:08:07 <erisco> I cannot read core :(
00:08:10 <adas> when creating a class with a single type parameter, it represents a single type, but when im creating a multiparam class .. every type parameter represents a different type but with varying kinds? am i correct?
00:09:58 <erisco> this is what I am looking at though http://lpaste.net/102218
00:10:55 <supki> erisco: what are you looking for in core?
00:10:56 <erisco> > do 5
00:10:57 <lambdabot>  5
00:11:02 <erisco> I do not understand why that is allowed
00:11:08 <supki> erisco: do b <- a; b = join
00:11:11 <supki> join a
00:11:15 <erisco> supki, I am trying to understand why 'blah' compiles
00:12:39 <supki> erisco: do you understand why it typechecks?
00:12:42 <erisco> no
00:12:54 <erisco> I do not know why 'do 5' type checks
00:13:22 <AlecTaylor> hi
00:13:24 <supki> oh, that's just a weird cornercase of the syntactic rules
00:13:35 <supki> I think report describes desugaring pretty well
00:13:44 <AlecTaylor> I can transform haskell source code into C++ source code using LLVM; right?
00:13:46 <erisco> well I fail to see how 'blah' makes sense either
00:14:33 <supki> :t \a -> do b <- a; b
00:14:34 <lambdabot> Monad m => m (m b) -> m b
00:14:37 <erisco> what monad is "" returned into? that is ambiguous, so it should be an ambiguous type error. secondly, what monad is the do-block in? none, it seems, which should be an error
00:14:45 <jjauhien> hello, has anyone heard about any haskell package for linear error-correcting codes (usual coding theory functions)?
00:14:45 <supki> :t \a -> a >>= \b ->  b
00:14:46 <lambdabot> Monad m => m (m b) -> m b
00:14:52 <supki> :t join
00:14:53 <lambdabot> Monad m => m (m a) -> m a
00:14:56 <erisco> supki that should be the type but it isn't!
00:15:37 <supki> erisco: which "" ?
00:15:53 <erisco> sorry I guess I used [1,2,3]
00:15:56 * hackagebot http-reverse-proxy 0.3.1.5 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.3.1.5 (MichaelSnoyman)
00:16:14 <erisco> supki, I edited the paste to show the absurdity http://lpaste.net/102218
00:17:32 <supki> erisco: well,  return [1,2,3] :: Monad m => m [Int],  join demands  m ~ []  so  return [1,2,3] ~ [[Int]]
00:17:34 <erisco> I edited again with a corrected core output
00:17:48 <supki> oops
00:17:55 <supki> the latter ~ is ::
00:18:49 <erisco> supki, ah...
00:18:58 <erisco> it is using the list monad
00:19:06 <erisco> d'oh, okay
00:19:36 <erisco> and the inference works backwards to infer that the return must have been for the list monad
00:19:44 <erisco> thanks supki
00:19:59 <erisco> Heather, okay so to answer your question, you did not escape the monad
00:20:07 <erisco> [] is a Monad
00:20:57 <Heather> erisco: wow, I didn't know it
00:21:05 <Heather> erisco: but IO is also monad
00:21:08 <erisco> yes it is
00:21:46 <erisco> you can put values into a monad, and work with values in the monad, but you cannot get values out of a monad
00:22:17 <Heather> erisco: ehm... what >>= makes then?
00:22:23 <erisco> well, for lists you have functions such as  head :: [a] -> a   which escapes the list monad
00:22:31 <erisco> but there is so such function  IO a -> a
00:22:40 <Heather> and >>= ?
00:22:45 <erisco> :t (>>=)
00:22:46 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:22:48 <erisco> it stays in the monad
00:23:13 <Heather> erisco: and <- ?
00:23:21 <Heather> :t (<-)
00:23:23 <lambdabot> parse error on input `<-'
00:23:23 <erisco> that is sugar for =<< basically
00:23:25 <startling> Heather, <- desugars to (>>=)
00:23:37 <Heather> and it doesn't escape the monad ?
00:23:48 <erisco> no, because the entire do-block is "in" the monad
00:23:53 <startling> > do { a <- [1]; a; }
00:23:54 <lambdabot>  No instance for (GHC.Show.Show b0)
00:23:55 <lambdabot>    arising from a use of `M844918129997010050019898.show_M8449181299970100500...
00:23:55 <lambdabot>  The type variable `b0' is ambiguous
00:23:55 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:23:55 <lambdabot>  Note: there are several potential instances:
00:24:19 <Heather> > do { a <- [1]; a }
00:24:20 <lambdabot>  No instance for (GHC.Show.Show b0)
00:24:20 <lambdabot>    arising from a use of `M819947384426051638319907.show_M8199473844260516383...
00:24:20 <lambdabot>  The type variable `b0' is ambiguous
00:24:20 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:24:20 <lambdabot>  Note: there are several potential instances:
00:24:30 <Heather> :S
00:25:00 <erisco> that would never work because '1' is not a monad
00:25:15 <startling> It's an error in any case.
00:25:29 <adas> when creating a class with a single type parameter, it represents a single type, but when im creating a multiparam class .. every type parameter represents a different type but with varying kinds? am i correct?
00:26:06 <Heather> > do { a <- return 1; a }
00:26:08 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
00:26:08 <lambdabot>    arising from a use of `M31721974052723705919916.show_M31721974052723705919...
00:26:08 <lambdabot>  The type variables `m0', `b0' are ambiguous
00:26:08 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:26:08 <lambdabot>  Note: there are several potential instances:
00:26:10 <startling> adas, sure.
00:26:19 <startling> Heather, hm, maybe this will clarify things:
00:26:26 <startling> @undo { a <- m; return a; }
00:26:27 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
00:26:31 <startling> @undo do { a <- m; return a; }
00:26:32 <lambdabot> m >>= \ a -> return a
00:26:36 <Dtgr> Heather: v <- a; b v is the same as a >>= \v -> b v. you can think the ; as a line break. can you see how they're the same?
00:26:52 <erisco> do { x <- a; y <- f x; y } is equivalent to  a >>= \x -> return (f x)
00:27:21 <erisco> oh sorry, not quite :)
00:27:53 <Heather> erisco: so when I do <- I'm still being in monad but I can use variable there, so my whole function must transfer the monad?
00:28:04 <erisco> do { x <- a; y <- f x; return y } is equivalent to  a >>= \x -> f x >>= \y -> return y
00:28:55 <erisco> Heather, x <- y  is basically  y >>= \x -> ...
00:29:49 <Heather> erisco: how to transfer y >>= \x -> x ?
00:29:56 <erisco> what do you mean "transfer"?
00:30:21 <Heather> erisco: create method that returns it and I willl use it in another place
00:30:31 <erisco> I do not understand still
00:31:01 <erisco> okay lets say you have an   IO String...
00:31:08 <Heather> erisco: I want foo that returns x
00:31:17 <erisco> :t return "hello" :: IO String
00:31:18 <lambdabot> IO String
00:31:32 <erisco> are you asking, for example, how you would append another string onto "hello" ?
00:31:44 <jle`> how do i catch any error ...?  i use catch i (\_ -> ...) and it wants a type for the error i expect :/
00:31:53 <Heather> erisco: I need return String w/o IO
00:31:56 <erisco> jle`, I think you use the type SomeException
00:32:17 <erisco> Heather, you cannot. as we keep saying, you cannot get values out of the IO monad
00:32:40 <erisco> this is by design
00:33:24 <jle`> and it's actaully illogical if you understand how IO works in haskell
00:33:48 <erisco> it would break purity
00:34:16 <erisco> and aside from that would be typically incorrect due to lazy evaluation
00:34:33 <jle`> not only that, it doesn't even make sense :|
00:34:41 <jle`> IO doesn't actaully execute anything
00:35:00 <jle`> it only describes an execution
00:35:13 <startling> Heather, it may make more sense to think of it like this:
00:36:01 <startling> Heather, "Monad is an interface that provides (>>=) and return. It does not provide a general way to extract values from monadic contexts, but individual monads may or may not allow this."
00:36:20 <erisco> yes that is well said :)
00:37:05 <erisco> but the good news is Heather there is no need to get values out of IO
00:37:14 <startling> that too ^
00:37:48 <erisco> for example, say you have  return "hello" :: IO String
00:38:31 <erisco> to append another string onto "hello", you can do  return "hello" >>= return . (++" world")
00:39:10 <erisco> which is the same as  do { x <- return "hello"; return (x ++ "world") }
00:40:18 <erisco> so you are free to operate on values inside any monad, which includes IO, and it does not require getting any values outside of IO
00:40:24 <Heather> erisco: well ... but need to do return everytime
00:40:53 <erisco> yes, you do :) there are helpers for certain situations
00:40:57 <jle`> it depends on what you want to do of course
00:40:59 <erisco> :t liftM2 (++)
00:41:00 <lambdabot> Monad m => m [a] -> m [a] -> m [a]
00:41:25 <erisco> using liftM2 you can convert an ordinary binary function into one that works on values in monads
00:41:32 <jle`> you can also apply a function inside an IO :) with fmap
00:41:58 <jle`> fmap (++ "world") (return "hello")
00:42:08 <jle`> fmap :: (a -> b) -> (IO a -> IO b)
00:42:12 <erisco> indeed, fmap (++" world") (return "hello")   or   (++" world") <$> return "hello"
00:42:18 <jle`> fmap turns a normal function into a function that works 'inside IO'
00:42:31 <Heather> wait but I can get out from "Some" monads
00:42:32 <Heather> right?
00:42:36 <startling> Heather: sure.
00:42:39 <startling> > head [1]
00:42:40 <lambdabot>  1
00:42:47 <jle`> yeah, everything is different
00:42:50 <jle`> monads are all very different
00:42:58 <jle`> they are almost all pretty much their own distinct thing
00:43:02 <startling> > fromJust 1 Nothing
00:43:04 <lambdabot>  Could not deduce (GHC.Num.Num
00:43:04 <lambdabot>                      (Data.Maybe.Maybe (Data.Maybe.Maybe a0 -> t)))
00:43:04 <lambdabot>    arising from the ambiguity check for `e_11'
00:43:04 <lambdabot>  from the context (GHC.Num.Num
00:43:04 <lambdabot>                      (Data.Maybe.Maybe (Data.Maybe.Maybe a -> t)))
00:43:08 <Heather> so I'm right for Some monads and Wrong for some other
00:43:19 <Heather> How can I know which monads are escapeful
00:43:57 <jle`> they will all be unique :)
00:44:02 <erisco> they can be escaped if there is a function  m a -> a   for some Monad 'm'
00:44:12 <jle`> monads are not conceptually one thing
00:44:26 <jle`> they are a lot of completely different things from all walks of life
00:44:29 <erisco> :t head
00:44:29 <lambdabot> [a] -> a
00:44:37 <jle`> who just happen to have a meaningful bind/return defined for them
00:44:46 <erisco> head :: [] a -> a   where [] is a Monad, so it escapes
00:44:48 <jle`> have you used iterators in other languages?
00:45:12 <Heather> yes
00:45:21 <jle`> you can define an iterator on a binary search tree, yes?
00:45:32 <jle`> that does an in-order traversal
00:45:36 <jle`> from lowest to highest element
00:46:04 <startling> Heather: typically you need some other information to "escape"
00:46:19 <startling> Heather, e.g. for Maybe it makes no sense to escape Nothing, so you need to provide a default value.
00:46:28 <jle`> you can ask 'this iterator has a way to get "the root"', or the root of the binary search tree
00:46:40 <startling> Heather, for State you need to provide an initial state.
00:46:42 <jle`> but you can ask  'do all iterators have a way for me to return "the root"' ?
00:47:02 <jle`> some iterators, like an iterator over a vector, you can also do indexed access.  but not all iterators have indexed access
00:47:04 <startling> Heather: 'head' should actually require a default value too, since
00:47:06 <startling> > head []
00:47:08 <lambdabot>  *Exception: Prelude.head: empty list
00:47:17 <jle`> for example, an iterator that iterates over all prime numbers
00:47:19 <shachaf> No monads are escapeful.
00:47:38 <jle`> all iterators are different
00:47:42 <jle`> and unique defined, for their specific container
00:47:50 <shachaf> The idea of "escaping from a monad" will only make you confused and sad, in the long run.
00:47:50 <jle`> the only thing they share in common is prev/next/begin
00:49:19 <startling> Heather: so, in general there's no common interface or common semantics for "escaping".
00:49:56 <erisco> :t sum
00:49:57 <lambdabot> Num a => [a] -> a
00:50:13 <erisco> there is a less error-prone example of escaping a list
00:50:20 <startling> that's a good point.
00:51:09 <erisco> though it should be noted that there are some certain quasi-escapes
00:51:51 <erisco> :t let x = return (5,6) :: IO (Int,Int); in (fmap fst x, fmap snd x)
00:51:52 <lambdabot> (IO Int, IO Int)
00:52:11 <erisco> we can bring the tuple outside of the monad, for example
00:53:05 <Heather> ...
00:53:26 <Heather> foo :: String
00:53:27 <Heather> foo = let a = return ""; a >>= \b ->  b
00:53:30 <Heather> is it valid?
00:53:39 <erisco> try executing it
00:53:44 <Heather> okay... we are repeating the same
00:54:13 <erisco> though these quasi-escapes do not leak any information about the value in the monad. we already statically new that the IO had a tuple in it
00:54:18 <startling> Heather, look at the type signature of (>>=)
00:54:19 <erisco> statically knew*
00:54:21 <startling> :t (>>=)
00:54:22 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:54:59 <startling> :t (>>= id)
00:55:00 <lambdabot> Monad m => m (m b) -> m b
00:55:07 <startling> Heather: aha ^
00:55:41 <startling> so, a >>= \b -> b is only valid if there's a doubly-nested monadic context.
00:55:59 <startling> > [[1, 2], [3, 4]] >>= \b -> b
00:56:00 <lambdabot>  [1,2,3,4]
00:56:09 <ReinH> startling: left identity :)
00:56:22 <startling> ReinH: shhh
00:56:24 <ReinH> return "" >>= id = id "" = ""
00:56:26 <ReinH> oh sorry
00:56:27 <ReinH> :(
00:56:28 <Heather> it compiles
00:56:45 <startling> Heather, sure? I think you're missing the point.
00:56:59 <startling> Heather: that's not "escaping", it's "flattening".
00:57:46 <ReinH> hmm, what monad would be used for return there?
00:58:01 <ReinH> Identity?
00:58:02 <Heather> flattering?
00:58:33 <startling> ReinH: what do you mean?
00:59:00 <startling> :t return "" >>= id
00:59:01 <lambdabot> [Char]
00:59:14 <startling> > return "" >>= id
00:59:15 <lambdabot>  ""
00:59:27 <startling> ReinH: (it's [])
00:59:36 <ReinH> startling: why is it []?
00:59:40 <Heather> isn't it escaping IO
00:59:49 <startling> Heather: no? there's no IO involved.
00:59:54 <startling> :t (>>= id) -- ReinH
00:59:55 <lambdabot> Monad m => m (m b) -> m b
00:59:56 <Heather> well
00:59:57 <Heather> f <- readFile "/etc/passwd"
01:00:02 <Heather> what type is f ?
01:00:40 <startling> Heather, that's not a useful way to think of it
01:00:52 <ReinH> startling: does evaluating return "" >>= id build an intermediate value of type Monad m => m [Char] and, if so, what Monad is chosen (defaulted?) for m?
01:01:03 <startling> ReinH, []
01:01:10 <ReinH> startling: why []?
01:01:14 <startling> ReinH, Monad m => m (m b) -> m b -- notice there's only a single m
01:01:29 <startling> Heather, >>= doesn't unwrap, it applies a function.
01:01:31 <ReinH> Oh.
01:01:35 <ReinH> startling: so it has to be [[Char]]
01:01:38 <ReinH> Thanks
01:01:40 <startling> ReinH: yeah.
01:02:09 <ReinH> startling: it's a bit confusing because "" happens to be a monadic value
01:02:41 <startling> Heather, so, in `readFile "/etc/passwd" >>= \f -> something` f has type String, but it's a type error if something is not in IO
01:02:44 <fntr> any hot chicks out there? I wanna fuck someone tonight
01:02:44 <startling> ReinH: yeah.
01:02:52 <Heather> ...
01:02:53 <MP2E> rofl
01:02:58 <MP2E> wut
01:03:02 --- mode: ChanServ set +o shachaf
01:03:04 <MP2E> i came in at an interesting time
01:03:08 --- mode: shachaf set +b *!*fntr@109.73.64.*
01:03:08 --- kick: fntr was kicked by shachaf (fntr)
01:03:21 <certainty> maybe haskell is also some form of fetish
01:03:28 <MP2E> oh god
01:03:36 <ReinH> Let's not.
01:03:39 <startling> ^
01:03:47 <Heather> startling: strange way of understanding
01:03:54 <certainty> and the poor guy just confused it :)
01:03:58 <startling> Heather, nah, look at the type signature.
01:04:01 <lieven_> lol Haskell is a bondage and discipline language
01:04:04 <erisco> you can also get the spine of an infinite list out of IO...
01:04:05 <startling> :t (>>=) -- Heather
01:04:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:04:26 <erisco> :t \m -> fmap (\n -> fmap (!!n) m) [0..]
01:04:27 <lambdabot> Functor f => f [b] -> [f b]
01:04:46 <startling> Heather: (>>=) says "apply a function with monadic effects to a value in a similar monadic context".
01:04:47 <erisco> but you cannot get a finite list out as you'd learn its length
01:04:50 <Heather> startling: so it escapes from m a
01:04:53 <erisco> interesting stuff :)
01:04:58 <startling> Heather: no, not at all.
01:05:16 --- mode: shachaf set -o shachaf
01:05:24 <Heather> startling: it escapes from m a and becoming m b
01:05:33 <startling> Heather, again, no.
01:05:38 <Heather> startling: ...
01:05:40 <startling> Heather, (>>=) is a function with two arguments.
01:05:48 <startling> Heather, the first is some "m a"
01:05:55 <startling> Heather: the second is a function "a -> m b"
01:05:57 <shachaf> I think even "a value in a monadic context" is misleading.
01:06:09 * hackagebot type-structure 0.1.1 - Type structure analysis  http://hackage.haskell.org/package/type-structure-0.1.1 (NikitaVolkov)
01:06:33 <jle`> yes it should be a 'a value in a monadic burrito'
01:06:35 <startling> Heather: it's more like "apply a function, then flatten the contexts"
01:06:43 <ReinH> startling: For me the CT approach to monads (return, fmap, join) made more sense out of "how come bind doesn't 'escape the monad'"
01:06:54 <Heather> startling: but it returns m b ?
01:06:54 <startling> ReinH: heh, jinx. :)
01:06:59 <ReinH> startling: as in, if all you have is return, fmap, and join, how can you write some function with the type signature of bind?
01:07:36 <startling> Heather: sure. I'm not sure how that's relevant.
01:08:08 <startling> Heather, are you familiar with fmap?
01:08:15 <Heather> no
01:08:21 <ReinH> startling: heh I was about to ask the same thing
01:08:27 <startling> Heather, alright, so that's a better place to start.
01:08:41 <ReinH> Maybe the typeclassopedia would be a good place to go?
01:08:44 <startling> Heather, we have a typeclass Functor f with a method fmap :: (a -> b) -> f a -> f b
01:08:51 * certainty quickly grabs more coffee. I always knew lurking pays off :)
01:08:55 <erisco> :t \f -> join . fmap f
01:08:56 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
01:09:01 <ReinH> Heather: Do you know what typeclasses are?
01:09:04 <erisco> just checking :D
01:09:11 <shachaf> When you see (>>=) :: m a -> (a -> m b) -> m b, it's tempting to think that (>>=) has superpowers, that it extracts the "a" from the "m a" and lets you use it temporarily.
01:09:15 <Heather> ReinH: no
01:09:34 <erisco> Heather, do you know what a Functor is?
01:09:40 <startling> Heather: ah. I suspect you'd need to start there.
01:09:42 <Heather> erisco: no
01:09:43 <shachaf> But there is no " that comes from the m aa", not now and maybe not ever.
01:09:49 <ReinH> We're getting into "in order to bake an apple pie" territory here...
01:09:56 <startling> yeah.
01:10:11 <ReinH> Heather: I would suggest looking at Learn You a Haskell
01:10:14 <ReinH> It's a very friendly introduction
01:10:17 <erisco> Heather, this seems to be a case of not quite knowing enough of more basic Haskell ... it is not feasible to understand Monad without more basic understanding
01:10:32 <ReinH> And will cover all of this stuff
01:10:44 <ReinH> @where lyah
01:10:44 <lambdabot> http://www.learnyouahaskell.com/
01:10:50 <jle`> ReinH: any news on the next haskell cast guests? :)
01:11:13 <ReinH> jle`: We have a plan.
01:11:17 <ReinH> We are implementing that plan.
01:11:40 <jle`> just finished brent yorgey today and was hesitant to start on the snoyman/gonzalez
01:11:54 <ReinH> I think it's one of our better ones
01:11:56 <ReinH> they were pretty great
01:11:58 <jle`> neat
01:12:11 <jle`> oh hesitant because i don't want to be caught up to date and have to wait for the nxt one T.T
01:12:12 <erisco> damn I am supposed to have part of this project done and I got distracted :P
01:12:16 <Heather> okay but it's still confusing how I can get String from some IO String and can't get same from another...
01:12:33 <jle`> Heather: try reading the book, it'll all make sense :)
01:12:46 <shachaf> Oh boy, I know a quote about that.
01:12:52 <ReinH> heh
01:13:02 <startling> Heather, you're making assumptions about what (>>=) does that are unjustified.
01:14:20 <Heather> startling: well now I think that it's not much about >>= but more about applieng type in the end
01:14:32 <startling> Heather: could you be more explicit?
01:14:55 <Heather> startling: basically >>= works same for different monads
01:15:07 <startling> Heather: it doesn't work the same for different monads.
01:15:10 <mm_freak> hi there
01:15:10 <Heather> startling: but different thing happens when I say that it's ::String
01:15:24 <mm_freak> does every lens constructed using 'lens' follow the lens laws?
01:15:36 <startling> mm_freak, no.
01:15:39 <startling> :t lens
01:15:40 <shachaf> mm_freak: Not necessarily.
01:15:40 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
01:15:52 <ReinH> lens is a lying liar.
01:16:05 <shachaf> Also, it's not recommended to make your lenses using the function "lens".
01:16:09 <mniip> Is there some typeclass that represents fallbacking, like short-circuitting `or` operator in some languages, analogous to how Monad's >> is like a short-circuitting `and`
01:16:19 <shachaf> I admit it's confusing. But it's better to make them directly for multiple reasons.
01:16:32 <shachaf> mniip: Perhaps Control.Applicative.Alternative?
01:16:42 <startling> mniip, (<|>) I think, but be aware that (>>) is not "and" in general
01:16:45 <mm_freak> shachaf: for some reason i find constructing directly less confusing, but i always used 'lens' as a control
01:16:45 <makalu> if in the FFI, I have a ForeignPtr to an object that depends on other objects being alive, should I touch those other ForeignPtrs in the finalizer?
01:16:51 <ReinH> > Nothing <|> Just 1 -- something like this?
01:16:53 <lambdabot>  Just 1
01:16:55 <mniip> startling, well, for Maybe an [] it is
01:17:01 <mniip> and*
01:17:20 <archblob> does GHC suppress warnings about unused identifiers when they start with an underscore ?
01:17:23 <startling> Heather, so, when you write code that says "Type m is a Monad", you literally write a (>>=) that fits that type signature + follows some extra "laws"
01:17:44 <startling> mniip: ah, yeah; (<|>) for Maybe is an equivalent "or"
01:17:45 <ReinH> (and a return)
01:17:49 <mm_freak> however, i found firstly that tekmo's pipes lenses (purposely) violate lens laws, and secondly that they can be constructed using 'lens'
01:17:51 <shachaf> mm_freak: (s -> a, s -> b -> t) is isomorphic to (forall f. Functor f => (a -> f b) -> s -> f t)
01:17:53 <startling> > Nothing <|> Just 2 -- mniip
01:17:55 <lambdabot>  Just 2
01:17:59 <archblob> or is this just a -Werror thing ?
01:18:02 <mniip> Hmmm, Alternative looks good
01:18:04 <shachaf> mm_freak: lens just gives you one direction of the isomorphism.
01:18:11 <mniip> thanks
01:18:27 <startling> > Nothing `mplus` Just 2
01:18:29 <lambdabot>  Just 2
01:18:45 <ReinH> Or maybe just a monoid, although the Maybe monoid is rather annoying.
01:18:56 <startling> I don't know. it's nice.
01:18:57 <mm_freak> shachaf: thanks
01:19:11 <startling> It's definitely the less useful one, but ...
01:19:31 <shachaf> Alternative is just a monoid in the category of endofunctors.
01:19:51 <Heather> startling: "laws" ...
01:20:06 <startling> shachaf, it's a little horifying that my mental response is "ah, of course!"
01:20:18 <ReinH> shachaf: that... actually sort of makes sense. I think
01:20:34 <shachaf> If that makes sense to you then you have to explain how.
01:20:37 <startling> Heather, yeah. like "a >>= return" must be "a".
01:20:46 <shachaf> (In particular, what's the monoidal category I'm talking about?)
01:20:57 <ReinH> shachaf: that's what I'm trying to figure out :(
01:21:27 <ReinH> shachaf: are the objects of any interest?
01:21:41 <mm_freak> ReinH: imagine you have only one
01:21:47 <ReinH> well yes
01:21:51 <ReinH> is the object of any interest?
01:21:59 <mm_freak> ReinH: /can/ it be of interest?
01:22:00 <shachaf> What?
01:22:08 <erisco> Heather, to give a little more context, Monad is a type class, and there are many types which can have an instance of that class (such as IO, or []), and each instance does something different with the functions 'return' and '>>='
01:22:21 <Heather> startling: what is happening when I try to apply different type which is not monadic, alike ::String
01:22:22 <ReinH> shachaf: is the object arbitrary?
01:22:27 <shachaf> What object?
01:22:34 <startling> Heather, could you explain what you mean by "applying"?
01:22:39 <startling> Heather, oh.
01:22:47 <startling> Heather, String is just a synonym for [Char].
01:23:00 <erisco> Heather, so to make 'return' and '>>=' less arbitrary, there are laws associated with them. these laws are just written in a text document. all instances of Monad are supposed to follow them
01:23:00 <startling> Heather, and [Char] is just a synonym for "[] Char"
01:23:06 <shachaf> This is kind of off-topic for this channel.
01:23:24 <ReinH> shachaf: Ok, we can take it somewhere else if you'd like
01:23:33 <startling> Heather, I think learning more haskell would really be the most productive thing for you now. I'm sorry if that's unsatisfying.
01:23:38 <erisco> Heather, you can then use these laws to write correct functions which work with any monad. for example, 'sequence' works on any monad because of the laws
01:23:40 <erisco> :t sequence
01:23:41 <lambdabot> Monad m => [m a] -> m [a]
01:24:26 <startling> ReinH, so, a monoid is a category with a single object.
01:24:31 <ReinH> startling: I know that.
01:24:38 <shachaf> startling: That's not the kind of monoid we're talking about here.
01:24:55 <startling> shachaf: I know. I'm trying to generalize. I think I'm doing it badly.
01:25:12 <mm_freak> i'm smelling something along the lines of "strong lax …"
01:25:49 <ReinH> shachaf: Ok, so a monoidal category is a category C equipped with a bifunctor (x) : C x C -> C that is associative
01:25:54 <ReinH> so I need to find C
01:26:20 <shachaf> I already said what C was. You need to find (x).
01:26:29 <ReinH> oh, the category of endofunctors
01:27:33 <Heather> startling: erisco: thanks anyways I think it will better to clarify my confusion by constructing minimal example
01:28:01 <ReinH> shachaf: well, why isn't it (<|>)?
01:28:38 <startling> ReinH, (<|>) doesn't operate on categories
01:29:05 <notdan> I totally forgot, what's wrong with the Maybe monoid instanc?
01:29:06 <mm_freak> i'm pretty sure the objects aren't categories anyway
01:29:12 <notdan> There are certainly several ways of implementing it
01:29:24 <startling> > Just [1, 2] <> Nothing
01:29:25 <lambdabot>  Just [1,2]
01:29:30 <startling> > Just [1, 2] <> Just [2, 3]
01:29:32 <lambdabot>  Just [1,2,2,3]
01:29:41 <shachaf> notdan: It requires the underlying type to be a Monoid and then throws away the identity and adds a new one.
01:29:43 <ReinH> startling: but it operates on functors?
01:29:52 <notdan> shachaf: ah, fair enough
01:29:59 <startling> ReinH: I don't think it does.
01:30:02 <startling> I may be wrong though.
01:30:06 <ReinH> :t (<|>)
01:30:07 <lambdabot> Alternative f => f a -> f a -> f a
01:30:12 <shachaf> notdan: Rather, it should be instance Semigroup m => Monoid (Maybe m) where ...
01:30:12 <startling> ReinH, it operates on objects in the original category
01:30:21 <notdan> shachaf: like in Data.Semigroup
01:30:26 <shachaf> Yep.
01:30:36 <ReinH> notdan: right, Option is what the Maybe instance should have been
01:30:38 <notdan> but semigroup is not in base.. so
01:30:42 <ReinH> right
01:30:49 <ReinH> it's yet another typeclass hierarchy problem
01:31:31 <mm_freak> startling: the objects of the category are functors
01:31:42 <startling> mm_freak: I know. I'm talking about (<|>).
01:32:02 <ReinH> startling: well I'm in the category of endofunctors, where the usual monoidal category is formed by functor composition and the identity functor
01:32:05 <mm_freak> i'm not sure if (<|>) itself has a representation there
01:32:08 <ReinH> this is a.k.a. a monad
01:32:16 <startling> mm_freak: right, that's what I'm saying.
01:32:18 <ReinH> iinm
01:33:13 <startling> (<|>) operates on objects in the category that the endofunctors which are the objects of the category we're considering work on, right?
01:33:18 <ReinH> shachaf: oh this is the "strong lax monoidal functor" thing
01:33:41 <shachaf> No monoidal functors involved.
01:34:03 <ReinH> ok
01:37:09 <chagall> hi, i am new here! I got haskell running on raspberry pi and now trying to install yesod. cabal install yesod-platform did produce some errors. My question is: does cabal writes an errorlog and where could that be found?
01:37:28 <mm_freak_> chagall: usually in ~/.cabal/logs/
01:38:10 <startling> was interpretation (specifically TH) ever fixed on ARM?
01:38:43 <ReinH> wait, I'm confused
01:39:22 <chagall> mm_freak_: thanks
01:40:12 <mm_freak> shachaf: the category of endofunctors on Hask, right?
01:40:14 <ReinH> shachaf: The underlying category that we're talking about is endofunctors on Hask?
01:40:18 <ReinH> mm_freak: :p
01:40:20 <mm_freak> hehe
01:40:28 <ReinH> So Applicative is a monoid on those functors
01:40:39 <shachaf> Yes, with natural transformations as the arrows.
01:41:05 <mm_freak> shachaf: what's the difference between "monoid" and "object"?
01:41:16 <shachaf> ?
01:41:31 <mm_freak> you said that an Alternative is a monoid in that category
01:41:48 <startling> chagall, Template Haskell is still broken on ARM, I think, which is probably your problem.
01:42:01 <shachaf> https://en.wikipedia.org/wiki/Monoid_object
01:42:17 <shachaf> That's what I mean by "monoid".
01:42:21 <mm_freak> oh
01:42:31 <mm_freak> that explains my confusion
01:42:44 <shachaf> That's the same meaning used in "a monad is just a monoid in the category of endofunctors".
01:43:37 <ReinH> Hmm, in "For any category C, the category [C,C] of its endofunctors", why the notation [C,C]?
01:44:21 <ReinH> I haven't seen that before.
01:44:33 <shachaf> I think look up "internal hom".
01:44:55 <mm_freak> shachaf: to be honest, i've never taken that definition seriously, so i never actually read what it means =)
01:45:20 <shachaf> I mean Alternative as a class on its own, by the way, not a subclass of Applicative.
01:45:22 <ReinH> shachaf: ah
01:45:31 <byorgey> ReinH: [C,D] is a very common notation for the category of functors between C and D
01:45:50 <byorgey> and also for internal homs, yes
01:46:22 <shachaf> Well, the former just being a special case of the latter.
01:46:44 <byorgey> right, I see that now, I had never considered it
01:46:46 <ReinH> That makes some sense.
01:46:51 <mm_freak> i'm starting to get why you never need more than functors and bifunctors
01:47:23 <ReinH> mm_freak: why do you never need more than a 2-tuple to construct a list?
01:47:32 <ReinH> (in the lisp fashion)
01:47:44 <chagall> I got a few 'DependencyFailed' messages  vector-0.10.9.1 monad-logger-0.3.4.1 file-embed-0.0.6 QuickCheck-2.7.3,
01:48:09 <mm_freak> ReinH: that one is easy, and for endofunctors on Hask it's easy as well, but if you look at functors in general it's less obvious
01:48:43 <chagall> startling: thanks for sharing this information, do you have a pointer for further news?
01:49:11 <startling> chagall, http://www.haskell.org/haskellwiki/Raspberry_Pi is the best I've got
01:49:17 <ReinH> heh, I like that internal homs are also written hom(-,-)
01:49:40 <mm_freak> and external homs are written hom(^.^)
01:49:41 <ReinH> I will now call them hom-owls.
01:50:02 <startling> chagall: the issue is that ghc's interpretation thing doesn't work on Arm for some silly reason; this means neither ghci nor TH (which works by running arbitrary interpreted haskell at compile-time) will work
01:50:24 <startling> chagall: things on that page seem to indicate that it might be fixed in 7.8, but using 7.8 probably breaks other things.
01:50:27 <startling> chagall: sorry. :(
01:50:47 <startling> chagall, cross-compilation might be your best bet, but cross-compilation with GHC is a can of worms I never bothered opening
01:51:06 <mm_freak> chagall: which is pretty much a killer for yesod, because it relies heavily on QQ/TH
01:51:42 <mm_freak> startling: once you get the cross GHC working, it's fine, but it's a long way to there
01:52:00 <mm_freak> i still have nightmares about GHC stages
01:53:23 <mm_freak> is easier cross-compilation on the feature list of 7.8?
01:53:34 <chagall> startling: crosscompiling is something what i dont want to get into it.
01:54:50 <mm_freak> chagall: if you invest an hour or two working and another 15-120 minutes compiling (depending on your machine and settings), you should be able to get a cross compiler
01:55:03 <mm_freak> at least it integrates nicely with cabal, so you can easily keep them separate
01:55:29 <mm_freak> and it's probably your best bet
01:58:37 <chagall> mm_freak: thanks, i have to reconsider my situation
01:59:46 <mm_freak> alright, enough theory…  time to heat up the CPU =)
02:09:29 <erisco> how do you access the Future value in reactive-banana reactimate' ?
02:09:38 <erisco> reactimate' :: Frameworks t => Event t (Future (IO ())) -> Moment t ()
02:10:01 <erisco> I traced 'Future' as a type alias to 'Dated' which is defined here https://github.com/HeinrichApfelmus/reactive-banana/blob/master/reactive-banana/src/Reactive/Banana/Prim/Dated.hs
02:10:39 <erisco> sure, use 'runDated' you may say, but I have no idea where to get a Vault
02:11:51 <erisco> I guess I use 'empty' for an empty vault? worth a try I guess
02:15:37 <erisco> well that can't be right... shouldn't have to dig into the Future...
02:15:58 <erisco> changes yields Moment t (Event t (Future a)) so it seems clear you are supposed to fmap 'a' to 'IO ()'
02:16:10 <erisco> which I did, but the action is not being run. hm.
02:27:08 <erisco> ah ha.. solved the problem :) my server request was in a liftIOLater is blocking... therefore the compilation of the network blocked until the request finished
02:27:21 <erisco> truncating all the events which were fired since the network did not exist yet
02:27:27 <erisco> forkIO to the rescue! :)
02:31:48 * hackagebot eternal 0.0.3 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.0.3 (Heather)
02:33:13 <bernalex> so what does '!' really mean? as in data D = D !Bool
02:33:30 <erisco> it makes the field strict, and beyond that I have no idea
02:33:55 <bernalex> erisco: I'm in the same boat.
02:35:34 <erisco> sorry :(
02:36:03 <bernalex> trying to figure out why (\ (D True) -> True) ⊥ -> ⊥
02:36:20 <bernalex> but (\ ~(D True) -> True ⊥ -> True
02:36:48 <bernalex> (errr I should have used something else for the last right arrows, but hopefully you get it)
02:39:09 <mr-> bernalex: The issue is ~ here, not !. It's the same behaviour regardless of the strictness.
02:39:42 <bernalex> mr-: feel free to explain ~ then :-)
02:39:42 <mr-> I'm sure ~(D True) is called a "irrefutable pattern" for a reason
02:40:45 <mr-> > (\ ~(Nothing) -> True) (Just 4)
02:40:46 <lambdabot>  True
02:41:02 <mr-> I can't tell you more than that. I have no idea why they are needed.
02:41:14 <bernalex> so the *match* always succeeds
02:42:00 <jle`> ~ is mostly for performance reasons i think
02:42:13 <jle`> for something like ~(x,y) -> ...
02:42:29 <jle`> or ~(Just x) ->, if you know it's going to be a Just
02:42:31 <jle`> for sure
02:42:36 <jle`> then why bother checking it'll be a Just
02:43:30 <bernalex> OK so you sort of "skip it", and it will only fail once you try to evaluate it? (i.e. if it's not Just)
02:43:44 <mr-> > (\ ~(Just a) -> a) (Nothing)
02:43:46 <lambdabot>  *Exception: <interactive>:3:2-17: Irrefutable pattern failed for pattern (Da...
02:44:00 <mr-> just as bad as fromJust
02:44:02 <bernalex> right and the same fail should happen if you use a guard
02:44:04 <jle`> yeah, it's mostly for performance reasons
02:44:22 <jle`> you can play laziness games with it though but i don't think it's too idiomatic
02:44:38 <supki> mr-: well, it's actually slightly better thatn fromJust in that you have a line number at least
02:44:43 <jle`> or normal
02:46:12 <adas> can someone please tell me how i can use Data.Array.ST? just an overview
02:46:31 <adas> it looks like its just the state monad wrapped around Data.Array
02:47:07 <jle`> adas: have you looked for tutorials?
02:47:15 <jle`> do you know how to use the ST monad?
02:47:26 <adas> jle`: yes i do
02:47:29 <jle`> it should be fairly straightforward if you have some familiarity with the ST monad
02:47:34 <jle`> hm
02:47:36 <jle`> well darn
02:47:51 <jle`> what parts are you having problems with?
02:48:01 <adas> jle`: i don't see the point of using it though, if i can simply use the ST monad with Data.Array
02:48:08 <jle`> ah
02:48:22 <jle`> i think it might be to avoid the extra copy
02:48:34 <jle`> wait
02:48:42 <jle`> what
02:48:44 <jle`> Data.Array is not mutable
02:48:51 <jle`> they aren't the same thing
02:50:04 <benj-> using Data.Array with ST would just give you a mutable reference to an immutable data structure
02:50:08 <jle`> Data.Array.ST lets you specify a computation on a mutable ST
02:50:11 <jle`> er
02:50:13 <jle`> a mutable array
02:50:33 <jle`> and you can use runSTArray to run that computation, and generate the resulting array
02:50:44 <jle`> Data.Array arrays are all immutable and persistent
02:50:49 <adas> when you say mutable array you mean the elements in the array are mutable
02:51:04 <jle`> well, no
02:51:18 <jle`> depends on what you mean by elements
02:51:34 <jle`> the pointers in the array are mutable, you can edit the items in the array in-place
02:51:46 <jle`> but if you have an immutable data structure, you can't mutate it inside the array of course
02:51:58 <jle`> but you can change what is in what index of the array
02:52:07 <jle`> but that's probably what you meant
02:52:32 <jle`> for example, say i have an array of 5's; i could replace every index with a 6 in-place to get an array of 6's
02:53:05 <jle`> but this is done in-place in memory, so there is no copying of new arrays involved
02:53:09 <jle`> they are 'destructive'
02:54:49 <adas> when you say destructive .. you mean mutable?
02:55:34 <adas> in the case of an immutable array, im simply creating a new array with the updated elements?
02:56:03 <jle`> adas: yeah
02:56:20 <jle`> when you use Data.Array, every operation gives you a new array
02:56:26 <jle`> copied over
02:56:32 <jle`> and you can always access the old array, as well
02:56:45 <adas> hmm..copied over with updated indices
02:56:54 <jle`> yeah
02:57:12 <jle`> remember that all values in haskell are pure
02:57:20 <jle`> and also
02:57:24 <jle`> there is no real concept of evaluation order
02:57:37 <jle`> so it wouldn't even make sense to have "mutable arrays"
02:57:45 <jle`> as if they were normal values
02:58:06 <jle`> if you perform the same function on the same array twice, you should get the same result
02:58:17 <jle`> this would not be true if you were allowed to mutate an array between those function calls
02:58:59 <adas> thanks for the clarification
02:59:24 <jle`> you *can* do efficient work with mutable arrays, however, in haskell, using completely pure functions.  basically, using the ST monad, you say "here is a list of instructions that you would do to make my array."
02:59:38 <jle`> and the instructions can *describe* destructive/mutable updates
02:59:58 <fizruk> is there a list of side effects modelled in Haskell somewhere?
03:00:00 <jle`> and then you use runSTArray, and it'll execute those instructions, and return the finished aray at the end
03:00:17 <jle`> it'll always return the same finished array, of course
03:00:22 <jle`> because it's a pure function
03:01:52 * hackagebot edentv 4.3.0 - A Tool to Visualize Parallel Functional Program Executions  http://hackage.haskell.org/package/edentv-4.3.0 (JostBerthold)
03:01:58 <jle`> but these "instructions" aren't special; they aren't like statements in an imperative language.  they are just normal haskell data values
03:02:10 <jle`> that runSTArray knows how to interpret
03:02:39 <adas> hmm.. im gonna work on an example
03:02:50 <adas> i think ill uncerstand better if i did that
03:03:47 <jle`> adas: you might want to look at http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-MArray.html if you already haven't
03:03:57 <jle`> it lists all the operations/commands you can do involving a mutable array
03:05:22 <adas> jle`: thanks for that link. .. .all those functions at the bottom making sense.. i already had that page open...even before we started talking. i can't believe i didn't bother scrolling to the bottom !
03:06:37 <jle`> runSTArray $ do { ar <- newListArray (0,10) [0..]; p1 <- readArray ar 2; writeArray ar 3 p1; return ar }
03:06:39 <jle`> that should
03:06:47 <jle`> well, consider the do block
03:07:11 <jle`> it says "to make my array, make a new array from 0 to 10, read the 2nd element, write that at the 3rd index...and there you have it."
03:07:20 <jle`> so you pass that do block into runSTArray
03:07:33 <jle`> and it'll execute it all, and give you a shiny new array that is the result of those instructions
03:08:15 <adas> and ofcourse .. when i run that again i get same array
03:08:55 <jle`> adas: yeah. well, a new array, but identical
03:09:16 <jle`> but you can use the `thaw` function
03:09:22 <jle`> and "load" an immutable array
03:09:26 <jle`> into your ST
03:09:36 <jle`> basically, it copies it over as an immutable array
03:09:38 <jle`> er
03:09:46 <jle`> it copies the immutable array into a mutable array
03:09:53 <jle`> so if i had, say, myArray
03:10:01 <jle`> and i wanted to make a function that swapped the 2nd and 3rd elements
03:10:05 <jle`> i would do something like
03:11:04 <jle`> runSTArray $ do { mut <- thaw myArray; e2 <- readArray mut 2; e3 <- readArray mut 3; writeArray mut 3 e2; writeArray mut 2 e3; return mut }
03:11:29 <jle`> and that will basically copy over myArray into a mutable container, do those mutable actions on it, and return the final result of the mutable actions, as an immutable array again
03:11:43 <jle`> the resulting array you get is always the same for the same myArray
03:12:03 <jle`> *and* your myArray stays the same, unmodified
03:12:14 <jle`> so your functions can still use myArray freely without worrying that it changed
03:12:23 <jle`> but you also have a new myModifiedArray that is the result of runSTArray
03:12:53 <jle`> also, isn't it nice that these 'instructions for building an array from mutations' has a Monad instance?
03:13:10 <jle`> so we can use do notation, and also all of the neat combinators from Control.Monad
03:14:05 <jle`> remember that runSTArray only takes a single 'instruction object'; and this entire time we are composing multiple 'instruction objects' (thaw, readArray, writeArray) into one giant big one.  and runSTArray runs that giant big composed instruction object
03:14:16 <jle`> wouldn't it be such a hassle if we had to compose/combine instructions by hand!
03:14:42 <jle`> monads are neat
03:15:24 <jle`> those last few messages might have gone over your head; feel free to ignore them if they do :)  but this will all click for yourself some day
03:16:54 * hackagebot regular-xmlpickler 0.2 - Generic generation of HXT XmlPickler instances using Regular.  http://hackage.haskell.org/package/regular-xmlpickler-0.2 (ErikHesselink)
03:17:59 <adas> jle`: monads definitely are neat.. thanks for taking the time to explain all this..
03:18:24 <jle`> one of the things monads are really good at are composing instruction objects
03:18:47 <jle`> normal haskell data types that might represent some sort of instruction set, depending on who is eventually going to use them
03:19:20 <jle`> excuse my late night ramblings
03:19:39 <adas> afternoon here
03:19:50 <adas> i want to tip you some doge for helping me out. do you have a dogecoin address?
03:20:24 <jle`> haha. that's not necessary
03:20:32 <jle`> but i appreciate the offer :)
03:21:13 <adas> no problem
03:21:25 <miguel_> Couldn't match type `a' with `Maybe a'http://pastebin.com/z9xXMjBV
03:21:25 <miguel_>       `a' is a rigid type variable bound by
03:21:34 <miguel_>           the type signature for myLast :: [a] -> Maybe a
03:21:43 <miguel_> damnit
03:21:59 <miguel_> let me reformulate that
03:22:02 <jle`> miguel_: "then h"
03:22:07 <jle`> isn't h an a?
03:22:14 <miguel_> yeah
03:22:22 <jle`> so...you have to return a Maybe a
03:22:40 <jle`> but h is an a
03:22:47 <miguel_> so I do Maybe h?
03:23:06 <jle`> @hoogle a -> Maybe a
03:23:07 <lambdabot> Prelude Just :: a -> Maybe a
03:23:07 <lambdabot> Data.Maybe Just :: a -> Maybe a
03:23:08 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
03:23:11 <jle`> try Just
03:23:19 <jle`> Maybe is not a function on values/data
03:23:23 <jle`> it is a type constructor
03:23:26 <jle`> but Just :: a -> Maybe a
03:23:39 <miguel_> oh, ok
03:23:44 <miguel_> Ill try that
03:23:57 <jle`> Maybe lives in the world of types, like Int, Bool, etc.
03:24:02 <jle`> Just is a normal function
03:24:19 <jle`> also, consider pattern matching :)
03:24:23 <jle`> just as a stylistic thing
03:24:41 <jle`> myLast (h:[]) = Just h
03:24:48 <miguel_> oh
03:24:53 <jle`> myLast (h:xs) = myLast xs
03:25:00 <miguel_> i wasnt sure if i could do (h:[])
03:25:21 <miguel_> thx
03:25:21 <jle`> you could also do [h]
03:25:25 <jle`> which matches the same thing
03:25:28 <jle`> but...don't
03:25:29 <jle`> :P
03:25:39 <jle`> h:[] is usually clearer
03:26:28 <jle`> actually
03:26:32 <jle`> [h] is cool too i guess
03:26:53 <jle`> to each his own
03:27:09 <jle`> > case [1] of [h] -> h
03:27:10 <lambdabot>  1
03:27:16 <miguel_> yea, but I think h:[] is clearer
03:27:31 <jle`> me too :)
03:27:41 <miguel_> I solved it now, (thx =) ), but back to the initial problem
03:27:46 <miguel_> i still dont understand what was wrong
03:28:10 <miguel_> i just started programmin haskell so im dont get completely these just and maybe
03:29:43 <miguel_> I thought I should use Maybe a if I sometimes returned something that wasnt a
03:29:48 <jle`> so something like 1 and [1], for example, are just different types
03:29:53 <jle`> same as 1 and Just 1
03:30:00 <jle`> 1 is Int, [1] is [Int]
03:30:06 <jle`> 1 is Int, Just 1 is Maybe Int
03:30:57 <miguel_> ah ok
03:31:11 <miguel_> so what do I do if I want to return Nothing for some instances?
03:31:40 <jle`> then you can return Nothing
03:31:48 <jle`> Nothing is the same type as Just 1
03:31:53 <jle`> :t Just 1
03:31:54 <lambdabot> Num a => Maybe a
03:32:00 <jle`> hm bad example
03:32:04 <jle`> but Nothing :: Maybe Int
03:32:06 <jle`> or Maybe Bool
03:32:09 <jle`> or it can be Maybe anything :)
03:32:27 <jle`> have to run now, sorry, but i'm sure there are people here who can answer further questions :)
03:32:39 <miguel_> sure thing man, thx =)
03:36:56 * hackagebot compensated 0.6 - Compensated floating-point arithmetic  http://hackage.haskell.org/package/compensated-0.6 (EdwardKmett)
04:43:41 <fizruk> i love how hackage makes me daltonic: the last sentences "Blue versions are normal versions. Green are those out of any preferred version ranges. Gray are deprecated." http://hackage.haskell.org/package/persistent/preferred
04:46:38 <Robie> Hallo guys ,
04:47:39 <Robie> I have this code http://lpaste.net/102234
04:48:08 <Robie> and my problem is, that I have a String ( getKleur :: String -> [Geofig] -> [Geofig])
04:48:16 <Robie> but I need a object
04:48:22 <Robie> something like this
04:48:30 <Robie> getKleur :: Color -> [Geofig] -> [Geofig]
04:49:11 <Robie> but If change it.. my code doesnt work anymore
04:53:31 <MagneticDuck> "doesn't work" isn't very helpful!
04:54:12 <MagneticDuck> Robie: first point, catch cases in which x is not one of those matched strings
04:54:22 <MagneticDuck> "  | otherwise = <result> "
04:54:35 <MagneticDuck> ...
04:54:42 <MagneticDuck> uhm
04:54:49 <MagneticDuck> Robie: just paste the whole code, this looks very strange
04:55:05 <MagneticDuck> remember to always match all the patterns =P
04:55:14 <MagneticDuck> (isRood _ = False)
04:55:51 <MagneticDuck> also, if you're not going to use a variable, just use a _
04:55:57 <MagneticDuck> (getKleur x _)
04:56:12 <MagneticDuck> also, try to shy away from errors!
04:56:21 <MagneticDuck> the prelude uses them, but you don't have to =P
04:56:50 <Robie> MagneticDuck: I'll share my code now
04:57:22 <Robie> http://lpaste.net/102236
04:58:04 <Robie> I want to get a certain value out of a datatype.
04:58:27 <Robie> I want to select only on color
04:59:02 <MagneticDuck> ._.
04:59:10 <MagneticDuck> let me work through this =P
04:59:15 <MagneticDuck> I'll fix your problem and your style
05:01:30 <MagneticDuck> uhm
05:01:34 <MagneticDuck> I'm going to refactor this =P
05:03:47 <Robie> oky...
05:05:14 <MagneticDuck> kk
05:05:18 <MagneticDuck> http://ix.io/btt
05:05:20 <MagneticDuck> there you are
05:05:22 <MagneticDuck> all fixed up
05:05:28 <MagneticDuck> that's how I would do it at least
05:05:36 <MagneticDuck> check out what I changed
05:05:57 <MagneticDuck> first things first, there was a huge duplication of structure in the definition of Geofig (everything had a color and a length)
05:06:03 <MagneticDuck> so I made a data type to hold that information
05:06:25 <MagneticDuck> I cleaned the rest of the stuff up as well, including adding type signatures and defining "isRed" correctly
05:06:58 <MagneticDuck> let me know if you don't understand something
05:07:12 * hackagebot querystring-pickle 0.1.9 - Picklers for de/serialising Generic data types to and from query strings  http://hackage.haskell.org/package/querystring-pickle-0.1.9 (BrendanHay)
05:10:15 <MagneticDuck> Robie: still with me>
05:10:16 <Robie> MagneticDuck: thnx. I'm looking into your code now. I'll let you know
05:10:17 <MagneticDuck> ?
05:10:21 <MagneticDuck> cool
05:11:22 <MagneticDuck> the largest problem there was structure duplication: if you have some part of a structure that you repeat a lot (like, every constructor has a color and length parameter), then try to reduce duplication by making a data type to hold that information
05:11:50 <MagneticDuck> uhm
05:11:53 <MagneticDuck> I messed up, sorry
05:11:58 <MagneticDuck> I'm going to change something there
05:13:49 <Robie> MagneticDuck: oky
05:15:20 <MagneticDuck> http://ix.io/btu
05:15:29 <MagneticDuck> hopefully I got it right that time +P
05:15:32 <bernalex> what does it mean for a variable to be "free"?
05:16:51 <MagneticDuck> in the lambda expression (\x -> x), the subexpression "x" is free as a independent expression, but it's not free in the whole lambda
05:17:36 <MagneticDuck> erm, 'x' is free in the subexpression, but not in the larger expression, I mean
05:18:27 <Robie> MagneticDuck: thnx ..
05:18:30 <bernalex> an example doesn't really help when I don't know what "free" means in the first place.
05:18:41 <MagneticDuck> uhm
05:19:14 <MagneticDuck> a free variable isn't bound =P
05:19:24 <MagneticDuck> grr http://en.wikipedia.org/wiki/Free_variables_and_bound_variables
05:19:28 <quchen> bernalex: A free variable is one that is not bound by a lambda abstraction.
05:19:37 <bernalex> MagneticDuck: thanks
05:19:51 <quchen> \x -> f y z  -- Bound: x; free: f, y
05:20:03 <MagneticDuck> Robie: confused?
05:20:11 <bernalex> quchen: ah. thanks.
05:20:25 <Robie> kind of :P..
05:20:32 <quicksilver> quchen: z is also free :)
05:20:38 <MagneticDuck> Robie: or, what DO you understand?
05:20:41 <MagneticDuck> and I can fill in the rest?
05:20:45 <quchen> quicksilver: Woops.
05:20:51 <quchen> \x -> f y x  -- Bound: x; free: f, y
05:21:10 <quicksilver> :)
05:21:27 <Robie> im playing with your code now.
05:21:41 <Robie> I'll keep you posted
05:21:45 <quchen> bernalex: Informally, free variables are the ones accessible from the outside of a function. Bound variables have their own scope.
05:21:53 <Robie> thnx for your help//
05:23:19 <quchen> bernalex: One example of when this matters is α equivalence, or "you can rename bound variables". \x -> x  is the same as  \y -> y.
05:23:44 <quchen> But you can only rename x to y in \x -> SOMETHING if SOMETHING does not involve y already.
05:24:40 <bernalex> quchen: the context I'm reading it in is: forall u. cx => t. -- it says that in any such type, any of the universally-quantified type variables u_i, that are free in cx, must also be free in t.
05:25:15 <MagneticDuck> Robie: http://ix.io/btv
05:25:24 <bernalex> that should have been forall ū, not forall u, btw.
05:27:14 * hackagebot RefSerialize 0.3.1.1 - Write to and read from ByteStrings maintaining internal memory references  http://hackage.haskell.org/package/RefSerialize-0.3.1.1 (AlbertoCorona)
05:29:46 <MagneticDuck> Robie: one last thing: http://ix.io/btw
05:29:59 <MagneticDuck> (to point out how cool record syntax is =P)
05:35:44 <zgredzik> hello, I'm looking for a decent library for describing vector graphics, so far the most satisfying one seems to be the diagrams lib (http://projects.haskell.org/diagrams/), does anyone know any other libs that support things like paths, shapes, etc. ? (rendering not required, scene description is enough)
05:37:25 <byorgey> zgredzik: there is also gloss, but for what you are describing I think diagrams is probably most appropriate.  Of course I am biased. =)
05:37:30 <byorgey> zgredzik: feel free to join us in #diagrams
05:40:11 <MagneticDuck> gloss is mainly for making rendering simple graphics easy, and it's not easily portable to serious projects
05:40:28 <MagneticDuck> aaand my verdict: tagbar is cool!
05:42:07 <pdpi> while we're on this topic, what would you guys recommend for drawing stuff like old school DnD-style maps?
05:42:57 <Yuu_chan> Pen & paper :)
05:43:39 <pdpi> Yuu_chan: Cool. How do I program a map generator that outputs to my arm muscles then?
05:43:41 <bernalex> pdpi: inkscape
05:43:49 <quchen> bernalex: Well, that says that if you provide a type constraint, that constrained type should appear elsewhere in your type, I think.
05:44:00 <zgredzik> byorgey: ty, I've checked out gloss but that's not what I'm looking for =)
05:44:03 <quchen> A counterexample would be "forall a b. Show a => b -> b"
05:44:18 <pdpi> bernalex: In case I wasn't clear, point is to write a map generator. I'm asking about what's a good way to spit it out as an image at the end.
05:44:25 <bernalex> quchen: I see
05:44:38 <quchen> Sorry for the late answer :-)
05:45:01 <bernalex> pdpi: "map generator" seems like a bad idea. don't you know that procedural generation is just a bad form of data compression? ;-)
05:45:05 <bernalex> quchen: NP
05:46:18 <pdpi> bernalex: it's the _best_ form of data compression, where you don't even need the source data to start with ;)
05:47:19 <bernalex> pdpi: I disagree. compare the fantastic work of planescape: torment to the bland same-y work of oblivion. but I don't have an answer for your question.
05:48:39 <Yuu_chan> pdpi: probably gloss, again
05:48:49 <pdpi> bernalex: Fair deuce. Oblivion and friends are a good example of procedural generation gone wrong (and PS:T is amongst the best examples of what you can get through a fair bit of effort). My idea is more to explore nethack-ish sort of map gem
05:48:53 <pdpi> *gen
05:49:02 <pdpi> Yuu_chan: cool, thanks. I'll have a look then.
05:49:45 <MagneticDuck> bernalex: procedural generation is human data compression =P
05:49:54 <bernalex> pdpi: yeah, I guess I picked bad (biased) examples. :-)
05:50:00 <Yuu_chan> pdpi: I can think of defining walls/floors/other basic primitives with RGBA textures, then combining them into tiles, then arranging tiles into a map
05:52:31 <bernalex> it kind of depends on if you're talking about dungeons, world maps, continents, islands, etc.
05:55:28 <MagneticDuck> #haskell-game?!?!
05:58:57 <bernalex> pdpi: just make them in NwN? :-] (srs suggestion)
05:59:34 <pdpi> Wait, NwN as in Neverwinter Nights?
06:00:31 <pdpi> anyhow, I'd take your suggestion if my ultimate purpose was to have the maps. My ultimate purpose is learning more Haskell, and the maps happen to be a good motivator.
06:01:17 <bernalex> pdpi: indeed. that way you can even play out your maps, and be the DM and control the NPCs etc. :-)
06:02:18 * hackagebot bool-extras 0.4.0 - A fold function for Bool  http://hackage.haskell.org/package/bool-extras-0.4.0 (TomLokhorst)
06:02:36 <pdpi> _that_ is the bit I plan on doing with pen and paper! :o)
06:03:41 <bernalex> pdpi: I've always thought it'd be fun to make an AP in nwn and play it out with my regular group. now if only nwn was 3.7.5 instead of 3.0. ;-)
06:03:53 <pdpi> haha
06:17:15 <romildo> Is it possible to have auto-completion in ghci running under emacs? When run in the terminal, the TAB key auto-completes identifiers. In Emacs it does not work.
06:22:50 <predator117> romildo: with haskell-mode at least in haskell-interactive-mode tab completion works
06:23:02 <predator117> (don't know about inferior-haskell)
06:25:37 <tapuu> What does the read instance of bytestring do?
06:30:35 <alpounet> tapuu: https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L219
06:31:21 <c_wraith> tapuu: it works much like the read instance for String
06:31:23 <ion> I wonder how many people have thought of implementing a thing only to notice that there’s a package for it by edwardk on Hackage already?
06:32:42 <edwardk> hey you beat me to quadratic-irrationals at least ;)
06:32:52 <ion> Case in point: http://hackage.haskell.org/package/hash-0.2.0.1/docs/Data-Hash-Rolling.html
06:33:54 <edwardk> you can also adapt the crc code i blogged about to get another hash scheme
06:34:13 <edwardk> that has the same group-like properties
06:34:41 * ion googles
06:35:01 <edwardk> https://www.fpcomplete.com/user/edwardk/parallel-crc
06:35:11 <edwardk> and the later parts of the automata series there
06:36:27 <c_wraith> hashing is weird to me.  There are legitimate security concerns about making hashing a group, even for non-cryptographic hashes.
06:36:36 <ion> edwardk: aye, thanks
06:38:24 <edwardk> yes
06:55:45 <jophish_> I can't remember a word, can you fill in the blank:
06:55:51 <edsko> @pf \f g h a -> f (g a) (h a)
06:55:52 <lambdabot> Maybe you meant: pl bf
06:55:56 <edsko> @pl \f g h a -> f (g a) (h a)
06:55:56 <lambdabot> liftM2
06:56:05 <jophish_> type X = Int -- "X and Int both have the _ type of Int"
06:56:07 <edsko> doh
06:56:44 <jophish_> something meaning, if one resolves all type synonyms, these types are equal because the resolved type is the same
06:57:41 <ion> Ooh, i love mad libs. “smelly”
06:59:02 <vektor> I wanna replace a list element at an index. How'd you guys do this? Basically, looking for something like replace [a] -> a -> Int -> [a], where Int is the index and a the element I want to insert (replacingly) at that index
07:02:07 <vektor> I could go for (take 5 list) ++ (newsixthelement : $ drop 6 list), right?
07:02:40 <merijn> vektor: parens around "take 5 list" are redundant
07:02:55 <merijn> vektor: And the second bit looks like a syntax error
07:03:10 <vektor> meh, I took half a semester of Racket, I'm used to parens everywhere -.-
07:03:39 <vektor> syntax error? because of ": $"?
07:03:53 <vektor> but the smiley face ;-)
07:04:00 <merijn> Yeah
07:04:35 <merijn> vektor: Are you sure you want a list, though?
07:05:02 <merijn> Why not an IntMap or Array?
07:05:07 <vektor> uhhh.. not exactly.
07:05:13 <merijn> (or vector, for that matter)
07:05:19 <vektor> Yeah, I'm considering IntMap or so as well
07:05:21 <merijn> All of those have more efficient index based updates
07:06:07 <vektor> is Array immutable?
07:06:52 <merijn> There are both immutable and mutable arrays
07:09:59 <quchen> I'm having trouble finding the Cabal API function to list the local Hackage index (i.e. what "cabal update" edits). There are plenty of API functions for installed packages, can anyone give me a hint? (I could of course crunch the index.tar.gz myself ...)
07:10:21 <quchen> In other words, I want a list of all packages on Hackage that my harddrive knows about.
07:10:35 <fizbin> @type let (*) = flip in \a b c d -> a * b * c * d
07:10:36 <lambdabot> (a -> b2 -> b1 -> b -> c) -> b2 -> b1 -> b -> a -> c
07:22:27 * hackagebot mangopay 1.1 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.1 (FelipeLessa)
07:22:29 * hackagebot yesod-mangopay 1.1 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.1 (FelipeLessa)
07:26:37 <MagneticDuck> oh boy, it's been a while since I've worked with a non-cabalised test project...
07:26:58 <MagneticDuck> let's say I have a module that simply exports a single module, which I can then import into GHCi
07:27:10 <MagneticDuck> how would I import that module into another module in the same directory?
07:28:33 <c_wraith> you can give :load multiple arguments, iirc
07:29:19 <MagneticDuck> I see... but ghcmod is still confused :<
07:29:54 <MagneticDuck> (using ghcmod-vim because nice)
07:31:06 <MagneticDuck> uhm... and it doesn't work anyway ._.
07:33:17 <d3lxa> Hey, I'm using yesod and there is a TH that generates the type Handler in module A, I need to use it in a module B but I need a function from B in my module A, what to do?
07:33:55 <d3lxa> I've used the hs-boot to define the things of B but now I need the type Handler which is from module A… it falis?
07:33:58 <d3lxa> *it fails?
07:37:28 * hackagebot idris 0.9.12 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.12 (EdwinBrady)
07:40:09 <bhuemer> hello, installing text using cabal fails because of some invalid preprocessing directives. Dr. Google told me it's because my ghc is using clang rather than gcc. I tried replacing it already (according to this https://gist.github.com/pyrtsa/6213784), but it still doesn't work :-/ how can I check what compiler cabal is using?
07:40:56 <absence> which version of ghc is this in? https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures
07:43:03 <isBEKaml> hey guys, I ran into a problem where process doesn't build on ghc-7.4. I narrowed it down to a base version mismatch (older base version)
07:43:33 <isBEKaml> What's the convention here in sending in fixes? base or the library where I had issues (process) ?
07:46:18 <c_wraith> absence: it's a proposal at the moment.  If it gets added (very likely), it won't be before 7.10
07:47:44 <DogeHayashi> If GHC complains about 'non-standard pattern guards', does that mean I've done something disallowed in Haskell 2010 or is it saying it's nonstandard from Haskell 98's POV?
07:49:29 <DogeHayashi> I like pattern guards, but I'm trying to stamp out -Wall warnings :L
07:50:03 <absence> c_wraith: i see, thanks!
07:52:30 * hackagebot diagrams-lib 1.1.0.4 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.1.0.4 (BrentYorgey)
07:59:20 <Dizorder> hi all!
08:01:55 <isBEKaml> This is where I have the problem with `process` not building on my Win7 machine: http://hackage.haskell.org/package/lifted-base-0.2.2.1/docs/src/Control-Concurrent-MVar-Lifted.html#mkWeakMVar
08:02:42 <isBEKaml> `mkWeakMVar` is exported only if base is 4.6.0. I have 4.5.0 - what's the best way to work around it?
08:05:19 <supki> DogeHayashi: if you use cabal to build the project you'll need to add  default-language: Haskell2010  to a build target
08:05:48 <dmwit> isBEKaml: Upgrade GHC.
08:05:49 <supki> DogeHayashi: otherwise cabal passes Haskell98 flag to ghc (the reason is backwards compatibility)
08:06:04 <dmwit> isBEKaml: There are a few packages you should not attempt to replace. base is one of them. It wouldn't surprise me if process was another.
08:06:23 <dmwit> isBEKaml: Do you really need a newer "process" package than what your version of GHC comes with?
08:06:41 <isBEKaml> dmwit: lifted-base, not base. Hey, 7.4.1 isn't *that* old. :-)
08:07:42 <isBEKaml> dmwit: I'm installing yesod. process is whatever it comes with as a dependency.
08:08:06 <edwardk> dmwit: template-haskell, process, ghc-prim, base, bin-package-db, ghc.. i should make a real list of the packages not worth putting bounds on
08:08:13 <SwashBuckla> http://lpaste.net/102245
08:08:27 <SwashBuckla> ^--- any idea what caused this
08:09:07 <dmwit> isBEKaml: I'm not sure I understand your response.
08:09:49 <isBEKaml> dmwit: I don't have process in GHC-7.4.1, it seems. So while installing yesod, cabal pulled in process-1.2.0.0 and failed to build it over my old base versions.
08:10:29 <dmwit> You... don't have process?
08:10:33 <dmwit> Are you sure?
08:10:34 <DogeHayashi> supki: ah, ok
08:10:44 <dmwit> What does ghc-pkg list process say? ghc-pkg check?
08:10:56 <isBEKaml> dmwit: Oh yes, I do. 1.1.0.1
08:11:10 <jjauhien> hello. I need to work with field GF(2) (i.e. one bit, 0 and 1 only). What is the most elegant way to do that?
08:11:30 <isBEKaml> dmwit: Now, I wonder if yesod asked for a newer one.
08:11:35 <dmwit> isBEKaml: Okay. So, perhaps you should try cabal install yesod --constraint 'process installed'.
08:11:53 <dmwit> jjauhien: Bool?
08:12:05 <dmwit> ?quote instance Num Bool
08:12:05 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
08:12:08 <dmwit> lame
08:12:10 <schlegel> isBEKaml: Is upgrading GHC not an option?
08:12:10 <dmwit> oh
08:12:15 <dmwit> ?quote dmwit instance Num Bool
08:12:15 <lambdabot> dmwit says: ?let instance Num Bool where (+) = (/=); (*) = (&&); negate = id; abs = id; signum = id; fromInteger = odd
08:12:35 <isBEKaml> schlegel: not really. Just that I'm on a weak network that downloading GHC is a pain.
08:12:36 <dmwit> schlegel: Even if it is an option, it does seem a bit like overkill.
08:12:40 <supki> SwashBuckla: well, 139 is a segfault, so it's probably OOM or something like this
08:13:07 <dmwit> A bit of education about how GHC manages packages is probably sufficient. ;-)
08:13:17 <dmwit> You might like monochrom's guide, come to think of it.
08:13:30 <dmwit> http://www.vex.net/~trebla/haskell/sicp.xhtml
08:14:05 <isBEKaml> dmwit: yeah, I read that one. Something about "Repeat after me - cabal is not a package manager!" :D
08:14:21 <geekosaur> there's more to it than that, sadly
08:14:22 <isBEKaml> dmwit: I recognised it the moment I saw sicp in it. :P
08:14:36 <dmwit> isBEKaml: That page does not contain the word "manager".
08:14:55 <mniip> Note to self: keep "SysRq+F" in mind when playing with undefined values
08:15:07 <jjauhien> dmwit: hmmmm not really beautiful to call 0 as False... It's maybe better than create data Bit = Zero | One and make it an istance of Num...
08:15:11 <mniip> er, bottom values
08:15:48 <dmwit> jjauhien: As a naming hack, I have seen and enjoyed data Bit = O | I
08:15:57 <jjauhien> :)
08:16:10 <geekosaur> jjauhien, you'll still get 0, it comes from the Num instance
08:16:34 <dmwit> ?let instance Num Bool where (+) = (/=); (*) = (&&); negate = id; abs =  id; signum = id; fromInteger = odd
08:16:36 <lambdabot>  Defined.
08:16:37 <dmwit> > 0 :: Bool
08:16:40 <lambdabot>  False
08:16:48 <isBEKaml> dmwit: constraints don't help, sadly. There are too many packages that insist on process at 1.2.0.0. :(
08:17:17 <dmwit> isBEKaml: If you want good, targeted help, you will need to give much more precise feedback about your goals and what went wrong.
08:18:28 <dmwit> "constraints don't help" is probably not true. "the constraints I tried didn't get yesod to build" might be true, but still a bit short on information. "I want to install yesod. I ran <copy of command> and got <URL pointing to a paste of the output>." would be a good start.
08:18:36 <vektor> Data.Array: are (Int, Int) tuples perfectly okay to use as indices?
08:18:45 <dmwit> vektor: yes
08:19:00 <isBEKaml> dmwit: yeah - I'll be putting out a paste, yes.
08:19:13 <vektor> so (Int, Int) is valid as type of Ix?
08:19:23 <dmwit> vektor: (Int, Int) is an instance of Ix, yes.
08:20:07 <dmwit> ?instances-importing Data.Array Ix
08:20:07 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
08:20:20 <isBEKaml> dmwit: https://gist.github.com/anonymous/9976861
08:21:13 <dmwit> isBEKaml: "installed package" doesn't look like a valid constraint to me. I'm surprised that cabal didn't immediately stop and complain about that.
08:21:29 <isBEKaml> dmwit: before I walked down the path to looking at process sources, I just tried `cabal install yesod`
08:22:13 <dmwit> I believe the correct spelling of the constraint is "process installed".
08:22:36 <SwashBuckla> supki: what can I do about an OOM error? I am on a VPS
08:22:51 <isBEKaml> dmwit: Sheesh.. I must be too tired to not even see that. :(
08:23:34 <dmwit> Gotta run. Good luck. Add more "<packagename> installed" constraints as necessary.
08:24:05 <dmwit> (yesod is a big beast, known to be hard to build sometimes.)
08:24:06 <isBEKaml> dmwit: Thank you for all the help. I'll ask here if I run into more problems after that. It's proceeding with installation (for now) :-)
08:25:16 <pavonia> Hey! Is there a common place for making code examples public that are too small for an extra package but too big for the wiki page?
08:25:52 <schlegel> You could put them in a gist or a github repo and link to the repo
08:26:30 <pavonia> Hhm, do you need to use git post it there?
08:26:50 <pavonia> *to post
08:27:05 <schlegel> If you have a github account you can just go to https://gist.github.com/
08:27:40 <schlegel> There may be a more standard way, just giving my 2 cents
08:28:12 <pavonia> Okay, thanks! If these gists are permanent this sounds like a good idea
08:28:14 <schlegel> If you have multiple files and have git installed it's really simple to throw it up on a repo
08:28:21 <schlegel> Yep gists are :D
08:28:38 <schlegel> gists are git repos, just with a simple interface
08:28:54 <pavonia> that's nice
08:37:31 <vektor> so the optimal way to update arrays is to buffer changes in a list and then reconstruct the array using (//)? Well, unless you need the updated array immediately that is...
08:39:28 <monochrom> or use a mutable array to begin with
08:39:33 <c_wraith> vektor: to update a pure array?  yes.
08:40:32 <bernalex> why is an empty declaration a valid import declaration? am I missing some sort of clever hack here? I can't figure out why on earth this would be reasonable
08:41:10 <c_wraith> bernalex: is it valid in the specified grammar, or just accepted by a particular compiler?
08:42:12 <bernalex> c_wraith: it's in the language definition. though I'm not sure why an empty line wouldn't be accepted by the compiler.
08:42:39 <bernalex> but why an empty line is considered a valid import declaration is beyond me.
08:42:40 <monochrom> > let in 2+2
08:42:41 <lambdabot>  4
08:43:01 <c_wraith> oh, you mean an empty line, not "import " by itself, which is invalid.
08:43:07 <monochrom> I can give you a practical reason, but that practical reason does not apply to "let in 2+2". you're going to argue it all over again.
08:43:33 <bernalex> c_wraith: no, I mean that absolutely nothing (so an empty line) is a valid import declaration.
08:43:38 <nh2> vektor: well that depends a lot on what exactly you want to do; often (in particular when you want it fast) using the ST monad to really mutably update your vectors can be good as well
08:43:52 <monochrom> frankly I'm tired of telling people what's wrong with "because no one uses it, it should be disallowed"
08:43:55 <mangaba_leitosa> > let in let in let in let in let in 2+@
08:43:56 <lambdabot>  <hint>:1:39:
08:43:57 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:43:58 <c_wraith> bernalex: I'm not seeing that in the grammar at all
08:44:01 <mangaba_leitosa> > let in let in let in let in let in 2+2
08:44:03 <lambdabot>  4
08:44:04 <mangaba_leitosa> :-)
08:44:05 <bernalex> monochrom: are you talking to me?
08:44:08 <monochrom> yes
08:44:21 <bernalex> monochrom: uhm what does what you're talking about have to do with what I'm talking aboutL
08:44:31 <bernalex> s/L/?
08:44:53 <supki> SwashBuckla: add more swap
08:45:02 <bernalex> c_wraith: it's in the Haskell '98 definition. impdecl -> import [qualified] modid [as modid! [impspec] |
08:45:19 <c_wraith> Oh.  Somehow I missed that empty line.
08:45:21 <c_wraith> Eh.
08:45:27 <c_wraith> It's just about making desugaring easy
08:45:32 <bernalex> c_wraith: the end there is just empty space. it is even annotated with "(empty declaration)".
08:45:33 <c_wraith> newlines are converted to ;
08:45:45 <bernalex> c_wraith: and why is that a valid import declaration?
08:45:55 <c_wraith> so that the desugaring is easy
08:45:59 <c_wraith> newlines are just converted to ;
08:46:05 <c_wraith> (I did just say this, didn't I?)
08:46:06 <bernalex> c_wraith: it isn't a valid type class constructor or something else random so I don't get why it would be an import declaration
08:46:26 <c_wraith> bernalex: to make desugaring easy?  I, uh...
08:46:37 <bernalex> c_wraith: I don't see how it has anything to do with desugaring
08:46:47 <geekosaur> I suspect that means it's to try to avoid indentation turning into empty declarations
08:47:22 <schlegel> bernalex: It's because you don't -have- to import anything
08:47:37 * hackagebot cantor 0.3 - Application for analysis of java source code  http://hackage.haskell.org/package/cantor-0.3 (klangner)
08:47:41 <bernalex> schlegel: but that's already solved by making importdecls non-mandatory
08:47:55 <bernalex> oh, wait, no it isn't
08:48:11 <fizruk> bernalex: are you talking about import Module () ?
08:48:15 <schlegel> No i see what you mean it is
08:48:17 <bernalex> lolwat. why not make impdecls be n>=1 instead of making impdecls be able to be "nothing".
08:48:31 <bernalex> sorry n>=0. it is presently n>=1.
08:48:38 <schlegel> body -> { impdecls ; topdecls } | { impdecls } | { topdecls }
08:48:51 <schlegel> So I don't see why impdecls should be possibly non-empty
08:48:53 <c_wraith> bernalex: to make desugaring easy.  Blank lines between imports turn into empty imports, instead of needing to be handled specially during desugaring.
08:49:05 <monochrom> bernalex, simply join the Haskell committee next time and push your change
08:49:28 <bernalex> schlegel: ah, I read it wrong the second time and right the first time. you do not need imports in a module for it to be valid.
08:50:04 <bernalex> c_wraith: OK, so it's tied to some rule saying that imports are at the top?
08:50:25 <bernalex> and so when there are no more import... or (empty line)s, imports are "done"?
08:50:30 <schlegel> Yes read 5.1
08:50:35 <bernalex> monochrom: I don't know what you are talking about
08:50:59 <bernalex> schlegel: ahh. OK. now it makes sense. thanks schlegel and c_wraith!
08:51:14 <bernalex> I was being myopic and viewing it too isolated. :-)
08:51:18 <monochrom> you are saying you do no like a rule in Haskell. I am suggesting you to join the Haskell committee and fix it.
08:51:27 <schlegel> it's a good idea to read grammars in order :P
08:51:46 <monochrom> being myopic is also why you don't understand what I say, yes.
08:51:50 <bernalex> schlegel: I did, but became fixated. :-P
08:52:09 <monochrom> humans are so susceptible to depth-first search
08:52:34 <bernalex> monochrom: I never said I did not "like a rule in Haskell". you have been having a different conversation than me all along.
08:53:06 <monochrom> you did suggest changing n>=1 to n>=0
08:53:40 <bernalex> monochrom: no, I asked why it isn't that way, in order to try to understand what was going on.
08:54:20 <bernalex> and also that doesn't even relate to what you are replying to, so I guess I give up trying to understand what you are trying to communicate.
08:56:07 <c_wraith> bernalex: It's important to understand that parsing haskell is done in a couple steps.  The grammer is defined in terms of a stream of tokens. Part of the tokenizing phase involves removing all whitespace and inserting all the semicolons that are inferred from the layout.  That includes inserting semicolons at the end of every line that isn't continued by a line indented afterwards.
08:57:00 <c_wraith> bernalex: that means that the tokenizer converts "import Foo\n\nimport Bar" to ["import", "Foo", ";", ";", "import", "Bar"] (or similar, but better-typed).
08:57:32 <bernalex> c_wraith: that's fine, and I understand that. I just, for some reason, thought it meant that any emptyline in the program was a valid import declaration.
08:57:45 <c_wraith> No.  Just the ones during the imports. :)
08:57:58 <bernalex> yep, that was my missing context. thanks. :-)
08:58:04 <schlegel> Also this means you can split your imports into little groups
08:58:08 <c_wraith> And the tokenizing could work differently, but it'd be more complicated
08:58:20 <schlegel> Say external imports and internal imports, separated by a blank line
08:58:22 <c_wraith> Better to add a null rule to the imports!
08:58:35 <bernalex> schlegel: yes, I do this in practice, though I obviously did not think of the emptylines as "import declarations".
08:58:47 <c_wraith> bernalex: I hadn't thought of them that way, either. :)
08:58:52 <c_wraith> But I will now!
08:59:07 <schlegel> Neither did I!
08:59:08 <bernalex> c_wraith: me too!
09:00:21 <bernalex> c_wraith: and I agree, the null rule makes sense. however, I think adding a clarification line for myopic people like me in the report would be beneficial. :-P
09:01:53 <schlegel> Maybe the report should just come with a pair of glasses
09:02:39 * hackagebot array-memoize 0.6.0 - Memoization combinators using arrays for finite sub-domains of functions  http://hackage.haskell.org/package/array-memoize-0.6.0 (DominicOrchard)
09:09:52 <sm> shouldn't haddock 2.14.1 manage to keep running when it sees "-- $" ? (the horror!)
09:13:50 <zoobab> hi
09:14:02 <zoobab> I tried to install twidge with cabal install twidge
09:14:06 <zoobab> but got the error:
09:14:07 <zoobab> Could not find module `Distribution.Simple'
09:14:20 <zoobab> how do I install this module with cabal?
09:15:15 <geekosaur> uh
09:15:18 <schlegel> Err that's part of cabal
09:15:20 <geekosaur> that module is *from* cabal
09:15:40 <geekosaur> (the library, not the command, but the command won't work without the library. more significantly, neither will the compiler)
09:16:05 <schlegel> How did you install cabal?
09:17:12 <zoobab> equo install cabal
09:17:41 * hackagebot tz 0.0.0.2 - Time zones database and library  http://hackage.haskell.org/package/tz-0.0.0.2 (MihalyBarasz)
09:21:03 <schlegel> Ah never used Sabayon Linux
09:21:41 <geekosaur> actually this makes me think twidge missed declaring a dependency on Cabal
09:23:07 <schlegel> zoobab: Where does the error happen?
09:24:12 <geekosaur> o.O
09:24:15 <geekosaur> #!/usr/bin/env runhugs
09:24:22 <schlegel> Yeah i just saw that
09:24:25 <geekosaur> (Setup.lhs on github)
09:24:49 <Hafydd> # ONLY WORKS WITH HUGS
09:24:58 <schlegel> But his INSTALL says to run 'ghc --make -o setup Setup.lhs'
09:25:10 <geekosaur> yeh, and cabal-install normally does that
09:25:16 <geekosaur> it's just ... wtf
09:26:00 <pavonia> In gtk2hs how do you query if and what mouse button is pressed in a motionNotifyEvent?
09:26:27 <geekosaur> that does seem to be the only reference to Distribution.Simple, which implies some weirdness with your ghc
09:26:59 <schlegel> zoobab: Can you `cabal update; cabal install cabal-install`
09:39:34 <Sonarpulse> it seems the haskell-src package makes no effort to parse right-associative infix operators corrrectly
09:41:15 <geekosaur> I think you have to handle associativity in a separate pass in haskell
09:42:09 <Sonarpulse> convert left associative to right asssociative post parsing?
09:42:10 <Sonarpulse> ugh
09:43:25 <geekosaur> the problem is that the infix declaration can *follow* a use
09:43:31 <absence> putChunk h (runPut -> b) = do ... <- what does the (runPut -> b) part here mean? is it some kind of pattern matching?
09:43:40 <geekosaur> absence, view patterns
09:44:09 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#view-patterns
09:45:05 <absence> geekosaur: ah, thanks!
09:46:44 <michi7x7> hi all. What does the "(...)" stand for when profiling? Is this pattern matching?
09:46:57 <absence> so basically runPut is called on the second argument to putChunk, and the result is named b?
09:47:05 <geekosaur> yes
09:47:59 <geekosaur> it's useful when you can't directly pattern match on something but you can apply something that yields a useful pattern/value
09:50:18 <absence> geekosaur: in this case there's no actual matching, but b is used twice in the do block, so i guess it's a trick to avoid a temporary value
09:50:26 <geekosaur> yes
09:50:53 <geekosaur> I'm not sure I approve of using a view pattern that way, but they did.
09:53:45 <armlesshobo> there really should be a shirt, with "HaskellMan" with a quote saying something like "Your types are safe with me"
09:54:17 <armlesshobo> I would buy the crap out of that shirt.
09:54:51 <michi7x7> really nobody knows what the "(...)" in prof-output stands for?
10:00:26 <meditans> why cabal-install gives me a "collect2: error: ld returned 1 exit status" error, when I'm using no FFI and inside emacs the code compiles correctly?
10:00:59 <meditans> i mean, not the precise reason, but why might it be? I'm struggling to provide a basic error for demonstration
10:02:04 <athan> Anyone here from colorado? Possilby near CSM? I'd like to talk tech and meet if anyone's down
10:05:03 <user_> anyone else attending hac nyc tonight? was wondering about arrival etiquette
10:05:41 <user_> whoops
10:06:21 <edsko> any type level programming enthusiast who can tell me why https://gist.github.com/edsko/9976585 does not type check?
10:09:47 <athan> user_ "Denver Hask" only comes back with "Denver Hash" in google
10:09:49 <athan> ;)
10:10:15 <user_> athan: i don't follow
10:10:26 <athan> thank you though!
10:10:47 <athan> hash is like marijuana
10:10:59 <athan> k. Leaving now.
10:23:16 <shachaf> edsko: I think you'll get a simpler error if you try with NProd0 first.
10:23:29 * shachaf has to go.
10:23:41 <edsko> schachaf: surely that's a trivial case
10:23:53 <shachaf> Does it type-check?
10:25:31 <edsko> schachaf: hmmm
10:25:34 <edsko> it does _not_
10:25:53 <FreakyPenguin> Probably a dumb question: But why does "cabal install" not call the install hook in my Setup.hs? (build hook works just fine) :-/
10:31:34 <ReinH> shachaf: ping
10:32:09 <ReinH> woops never mind
10:41:47 <lispy> FreakyPenguin: How is your build type set?
10:42:03 <FreakyPenguin> Custom
10:42:05 <lispy> FreakyPenguin: oh, I see. It does call one hook but not the other.
10:42:42 <lispy> FreakyPenguin: I'm not really sure what is wrong there. Maybe try increasing the Cabal version in the .cabal file?
10:43:02 <FreakyPenguin> Exactly. But as I now noticed it seems to call the copy hook, so I put my code in there for now. But not exactly sure why this is necessary
10:43:31 <lispy> FreakyPenguin: all I can suggest is to double check what the cabal manual says
10:43:40 <lispy> maybe read the source code of Cabal :)
10:43:59 <FreakyPenguin> Yep thanks :)
10:57:58 * hackagebot elm-repl 0.2.2.1 - a REPL for Elm  http://hackage.haskell.org/package/elm-repl-0.2.2.1 (EvanCzaplicki)
11:02:22 <KatZilla> is there scotty channel ?)
11:02:37 <KatZilla> in irc i mean )
11:09:07 <pavonia> KatZilla: There's #scotty but it's empty
11:10:24 <KatZilla> pavonia: Have you tried haskell framework like that ?
11:11:07 <pavonia> I've used happstack before
11:12:50 <KatZilla> pavonia: is it suitable for json api server?
11:13:27 <pavonia> I think so
11:24:47 <pavonia> In gtk2hs, how do you query if and what mouse button is pressed in a motionNotifyEvent? There's a modifier Button1, but that is never set
11:25:57 <yogert1> Hey all, I'm trying to get a better grasp on monad transformers and I've having trouble making the correct instance for this transformer stack… http://lpaste.net/102258
11:28:06 <yogert1> I guess I'm getting lost as to how to upack my stack inside the bind operator...
11:28:22 <S11001001> Wow, hlint is really awesome.
11:28:53 <jle`> yogert1: you can use generalized newtype deriving to derive the Monad instance for you
11:28:55 <tg2> question about cabal - when I do configure it tells me I need a hihger version than the version installed by cabal install (ex: requires base 4.6 but cabal install only puts 4.5... cabal --version = 1.18.1.3
11:29:46 <yogert1> jle`, yeah I know, but I felt i was relying on that too much without really understanding the underlying concept
11:30:19 <tg2> example: http://pastebin.com/if7XMyCA
11:30:22 <jle`> yogert1: the main problem is that Thingy expects an ErrorT something something
11:30:35 <jle`> but you gave it a function
11:31:38 <saml> hey, teach me haskell
11:31:41 <jle`> are you sure you want a newtype? the typical solution is to just use a type alias
11:32:04 <yogert1> okay, i'll hve to check out the specifics of how ErrorT works…
11:32:07 <yogert1> And good point
11:32:14 <yogert1> that would simplify things
11:32:31 <jle`> if I was yous
11:32:40 <pavonia> tg2: And what is your question?
11:32:42 <jle`> yeah, type aliases are the typical approach
11:32:53 <jle`> but you can use newtypes too
11:33:02 * hackagebot epub-tools 2.5 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-2.5 (DinoMorelli)
11:33:33 <jle`> runThingy m >>= (runThingy . f)
11:33:44 <jle`> that should work I think
11:33:51 <jle`> er
11:33:58 <jle`> and Thingy the whole thing
11:34:02 <yogert1> ha
11:34:05 <yogert1> yeah : )
11:34:35 <dmwit> I want a mix of "break" and "take": a function that extracts (the first n elements of a list matching predicate p, all the other elements of the list).
11:34:44 <yogert1> well I still want to get comfortable with deriving monads
11:34:46 <dmwit> Is there a function like that already somewhere? If not, got any bright ideas for naming it?
11:34:54 <StoneToad> takeabreak!
11:35:07 <yogert1> declaring them.. that works because ErrorT is an instance of monad right?
11:35:31 <jle`> yes
11:35:35 <dmwit> StoneToad: I like that name! =)
11:36:19 <allsystemsarego> hi all, code here: http://lpaste.net/102260 -- how do I monadically compose these two functions?
11:36:38 <sm> dmwit: it's called span
11:36:42 <tg2> pavonia - the package I'm trying to install requires newer versions of packages than cabal installs by default, is there a way to have cabal install a newer version?
11:36:57 <dmwit> sm: span and break are almost the same function.
11:37:20 <tg2> I see that I have ghc 7.4.1, is that inhibiting the installation of base 4.6?
11:37:31 <geekosaur> you cannot install a new base
11:37:38 <sm> your description sounds exactly like span - did I misunderstand ?
11:37:40 <dmwit> I want foo 3 odd [1..10] to result in ([1,3,5],[2,4,6,7,8,9,10]).
11:37:41 <geekosaur> it's wired into the compiler
11:37:52 <tg2> hm
11:37:53 <sm> ahh
11:38:30 <tg2> so how could I get this version of base, reinstall haskell from recent source?
11:38:44 <geekosaur> install a ghc which uses it, yes
11:38:54 <tg2> so 7.6.x?
11:39:20 * geekosaur checking exact dependency
11:39:21 <pavonia> tg2: You can modify the .cabal file to be less restrictive and install a modified version of that package. Make sure to change the package version if you do that
11:39:30 <tg2> yeah but that might not fix it
11:39:50 <pavonia> It's worth a try
11:40:00 <tg2> so modify the .cabal file for the app i'm trying to install
11:40:03 <tg2> so it is more permissive?
11:40:22 <geekosaur> 4.6.0.1 is 7.6.x (possibly 7.6.2+, certainly 7.6.3)
11:40:33 <joseph07> allsystemsarego: is there a monad instance for either?
11:40:58 <tg2> so if I uninstall haskell-platform and install 7.6.2 from source, that should permit cabal to install newest package versions?
11:41:29 <sm> takeabreak n p = let (as,bs) = partition p, (cs:ds) = splitAt n as in (cs, ds ++ bs) ?
11:41:34 <allsystemsarego> joseph07, no, that isn't the intent
11:41:49 <geekosaur> tg2, probably
11:41:50 <yogert1> jle`, do you know of a way to see the derived instances? I thought I had it figured out, but still stuck
11:42:13 <sm> uh, or some such
11:42:26 <tg2> hmm, uninstalled haskell-platofrm but cabal remains
11:42:57 <geekosaur> did you upgrade it locally>
11:42:59 <geekosaur> ?
11:43:16 <tg2> i installed with aptitude
11:43:20 <tg2> apt-get install haskell-package
11:43:21 <geekosaur> removing a system package will not touch anything under ~/.ghc or ~/.cabal
11:43:27 <joseph07> allsystemsarego: If your intent is to use bind with your operations, then you'd need a monad instance
11:43:29 <tg2> did purge too
11:43:41 <tg2> so if I just nuke ~/.cabal that's self-contained?
11:43:43 <dmwit> sm: I can write it. It won't be that (because that mixes up the successes after the break), but I can write it.
11:43:49 <geekosaur> so if you ever did `cabal install cabal-install` then that is still in ~/.cabal/bin and apt will never touch it
11:43:55 <tg2> yeah I did
11:44:02 <geekosaur> should remove both ~/.cabal and ~/.ghc
11:44:03 <tg2> ok so there's nothing lingering out of that dir
11:44:14 <allsystemsarego> joseph07, hmm, I'll think about what that means, thanks
11:44:15 <tg2> thanks
11:44:30 <joseph07> allsystemsarego: if you only need to combine them the one time, you can pattern match on the result of the first function in a case statement
11:44:32 <dmwit> Anyway, I'm thinking maybe that's not the best way to do things anyway now.
11:45:05 <dmwit> But thanks for the suggestions. =)
11:45:10 <tg2> haskell.org has some decent bandwidth! 32MB/s
11:45:13 <sm> dmwit: huh, glad you didn't give me this in a job interview :)
11:45:21 <dmwit> hehe
11:45:47 <dmwit> I'm sure in an interview situation I would have been more careful to specify what it should do. =)
11:46:01 <jle`> yogert1: you can use -ddump-deriv
11:46:04 <jle`> yogert1: but it's not pretty
11:46:24 <jle`> it's not meant for human reading :)
11:46:55 <jle`> did the version i gave above work?
11:47:06 <jle`> Thingy $ runThingy m >>= (runThingy . f)
11:47:29 <jle`> any more than that and you'll have to look into how >>= is defined for ErrorT
11:47:31 <jle`> but
11:47:51 <jle`> that makes for a very inflexible stack
11:48:13 <jle`> normally monad transformer usage hinges upon that sort of recursive abstraction
11:48:37 <jle`> where you don't care about the stack, you only care about the effects that the stack offers
11:48:40 <jle`> at a typeclass level
11:49:48 <jle`> so when you define >>= as Thingy (runThingy m >>= (runThingy . f)), you are saying "i don't care what's inside Thingy, as long as it's a monad"
11:49:58 <jle`> and in fact you might actually have a Thingy2
11:50:00 <jle`> that wraps a Thingy
11:50:04 <jle`> and you can use the exact same code
11:50:15 <jle`> where each monad instance relies on the monad instance of the one below it
11:50:21 <jle`> which relies on the instance of the one below it
11:50:24 <jle`> all the way down...all turtles.
11:50:34 <jle`> the point si that you don't have to care how it is a monad, only that it is.
11:51:33 <jle`> most of the mtl/transformers typeclasses (MonadState, MonadIO, etc.) work on this principle of just deferring the actual definition to the next step in teh stack
11:53:46 <joseph07> allsystemsarego: http://lpaste.net/102261
11:54:21 <joseph07> allsystemsarego: that function does what I think you want it to, collecting any error messages from the other checks
11:55:06 <allsystemsarego> joseph07, thanks, yes, indeed
11:55:10 <joseph07> allsystemsarego: But it doesn't use monadic bind. If you find yourself writing alot of these composite checks you can abstract them using a monad, and combine with the same syntax you tried to use
11:56:48 <fizbin> @hoogle (<~>)
11:56:50 <lambdabot> No results found
11:57:13 <fizbin> @hoogle (<+>)
11:57:13 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
11:57:13 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
11:57:13 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
11:57:32 <fizbin> @hoogle (<%>)
11:57:32 <lambdabot> No results found
12:01:15 <bitemyapp> @hoogle (|||)
12:01:16 <lambdabot> Control.Arrow (|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
12:02:12 <glguy_> dmwit: If the partitioning exercise is to solve the problem using base you can get there nicely with Data.Either.partitionEithers and Data.List.mapAccumL (just having fun) http://lpaste.net/102262
12:03:54 <fizbin> It turns out it's actually quite easy to make a lens by hand: http://lpaste.net/102263 . I don't know why I was making that so hard on myself.
12:04:07 <dmwit> Oh, that's a cute idea.
12:05:23 <dmwit> Though I still like the sharing you get if you write it the naive recursive way.
12:06:12 <tapuu_> How can I throw an exception to the main thread?
12:06:16 <dmwit> I guess you could recover it with a judicious use of takeWhile/dropWhile.
12:06:19 <dmwit> anyway
12:06:22 <dmwit> enough sniping on that
12:12:17 <pavonia> tapuu: Have you tried calling "myThreadId" on the main thread an then "throwTo" with that?
12:14:59 <c_wraith> pavonia: isn't that pretty much the *only* way to do that?
12:15:14 <pavonia> yeah :)
12:20:36 <darthdeus> guys anyone has a good video where someone talks about their experience using haskell in their company or something?
12:20:52 <darthdeus> and not the "running a startup on haskell", i've seen that :P
12:21:50 <pavonia> Hhm, if you know the exact exception in advance you could also communicate with the main thread via a channel or so, and then raise the execption from there
12:22:39 <davean> darthdeus: what exactly are you looking for?
12:22:57 <darthdeus> davean: anything interesting to watch that isn't too advanced
12:23:27 <darthdeus> and that isn't really that technical, or haskell specific ... like nothing that explains how cool are lenses and stuff :P
12:26:45 <ArneL> darthdeus: maybe haskell in the newsroom (NYT): http://www.infoq.com/presentations/haskell-newsroom-nyt or something from barclays: http://www.infoq.com/presentations/haskell-barclays (thought not that good in my opinion)
12:27:09 <darthdeus> ArneL: seen the first one :) that's exactly the type i'm looking for
12:27:20 <darthdeus> i'll check out the second one, thanks
12:33:26 <ArneL> And not a video, but there is a short thread on reddit about haskell at xkcd: http://www.reddit.com/r/haskell/comments/uved7/waldo_the_haskell_powered_codebase_behind_xkcds/ Do not know of that many other videos about haskell in the industry though
12:34:05 <jle`> there's that imvu article?
12:36:06 <bitemyapp> jle`: http://engineering.imvu.com/2014/03/24/what-its-like-to-use-haskell/
12:36:12 <bitemyapp> jle`: came up trivially via Google :P
12:36:17 <bitemyapp> jle`: it's a good article.
12:37:57 <jle`> bitemyapp: meant as a suggestion to darthdeus
12:38:01 <jle`> but i guess eh was looking for videos
12:38:12 <augur> jle`: here's a video!
12:38:13 <augur> https://www.youtube.com/watch?v=NRvK_07KRV8
12:38:24 <jle`> :O darthdeus
12:40:49 <bitemyapp> urrrgh exceptions and conduit
12:41:42 <jle`> it's really weird that my computation was bottlenecking on the single print statement ....
12:41:49 <jle`> i had it evaluate sum [0..10000000] or something twice
12:41:52 <jle`> and then print out the sum
12:42:01 <jle`> and it executed both right away, and the addition too
12:42:05 <jle`> but took like a second to print out the sum
12:42:07 <jle`> how weird
12:42:21 * jle` shrugs
12:42:26 <fizbin> I seem to remember a video or slideshow about Haskell use at Facebook, and specifically about how it turns out that Applicative is the proper thing with which to model computations that might proceed in parallel, or might have dependencies on each other.
12:42:27 <augur> jle`: in haskell? no, not weird
12:42:37 <fizbin> Can't find that video now.
12:42:40 <augur> jle`: because it probably wasnt executing both right away!
12:42:47 <yogert1> jle`, sorry i stepped out for  bit
12:42:48 <augur> laziness is a killer when you're doing IO
12:42:51 <jle`> oh, that makes sense
12:42:56 <yogert1> thanks for the explanation though
12:42:59 <jle`> ahh!
12:43:01 <yogert1> its very helpful
12:43:05 <jle`> everything clicks now
12:43:07 <jle`> haskell is so weird
12:43:12 <augur> jle`: you dont evaluate until you have to
12:43:19 <jle`> yogert1: no problem :)
12:43:24 <augur> so as SPJ jokes: a computer with no IO doesnt need to evaluate anything
12:43:30 <jle`> heh
12:43:43 <augur> IO is what makes computers more than space heaters
12:43:53 <jle`> i put trace statements in the wrong places then
12:43:55 <augur> actually, as SPJ also jokes, heating up is also kind of IO
12:44:08 <jle`> silly me trying to debug trace using putStrLn
12:44:58 <peddie> fizbin: https://skillsmatter.com/skillscasts/4429-simon-marlow ?
12:45:19 <jle`> fizbin: there's also the haskell casts episode with simon marlow
12:45:42 <fizbin> Right, and I think the haskell cast makes reference to this video.
12:46:05 <fizbin> Thing is, I only watched about half of it when I could find it, and can't find it now.
12:46:11 <jle`> now to figure out where to stick the right Debug.Trace.trace's
12:46:22 <fizbin> peddie: Maybe. I'll look.
12:50:00 <osa1> question about codata and coinduction: codata as described in "total functional programming" needs some recursive functions to operate on generated codata, right? I'm having trouble understanding how can codata be useful from that paper.
12:51:28 <jle`> you don't need a recursive function to work with codata?
12:51:30 <jle`> right?
12:51:37 <jle`> > head [1..]
12:51:39 <lambdabot>  1
12:51:47 <jle`> or i guess to leave it as codata you do
12:51:56 <osa1> hm
12:51:59 <jle`> > map (*2) [1..]
12:52:00 <osa1> let's say I have a corecursive function that defines a an infinite list. I want to print elements of that list -- that program obviously non-terminating. how can I write that program using corecursive function for generating the tree and recursive function to print elements?
12:52:00 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
12:52:30 <jle`> you can generate that list fairly easily
12:52:43 <jle`> > let listFrom n = n : listFrom (n+1) in listFrom 0
12:52:45 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:52:50 <osa1> jle`: I know
12:53:05 <ReinH> let a = 1 : a in a
12:53:09 <osa1> jle`: problem is how can I print it. because using recursive function should not work by definition in the paper
12:53:37 <jle`> well you can't print codata like you are saying, but you can manipulate codata and eventually turn it into data to print it.
12:54:15 <osa1> jle`: at one point you need to convert codata to data, right? but as far as I can see the paper does not describe a way to do that.
12:54:53 <jle`> are you talking about Turner?
12:54:59 <osa1> yeah
12:56:36 <jle`> to print it in a non-terminating fashion you need to eventually convert it to data, i believe.
12:56:51 <jle`> if the paper doesn't describe it then it might not be considering that eventual transition
12:56:59 <jle`> and instead describing meaningful things to do with codata as codata
12:57:27 <osa1> how can I do anything useful without destructing codata constructors in a recursive function?
12:58:03 <jle`> you can do a lot of useful things with codata before you eventually turn it into data
12:58:14 <osa1> example?
12:58:22 <jle`> ummm you called my bluff
12:59:29 <jle`> well it's basically the entire idea of codata; you work with it as an abstraction and manipulate it
12:59:34 <jle`> without worrying about later converting it back
12:59:45 <benmachine> hold on
13:00:00 <benmachine> to write non-terminating programs, you don't want to convert things into data
13:00:04 <benmachine> you keep them as codata
13:00:12 <benmachine> your IO type itself is codata
13:00:14 <osa1> benmachine: okay but how can I operate on codata?
13:00:18 <jle`> oh yeah
13:00:23 * jle` backs off
13:00:39 <benmachine> osa1: do you know how to turn codata into other codata?
13:00:54 <osa1> benmachine: shall we move on without giving Haskell examples? since we don't have a separateion of data vs. codata in Haskell I think it just makes things 10x confusing.
13:01:04 <osa1> benmachine: no, is it possible?
13:01:13 <benmachine> sure it is
13:01:31 <osa1> example? :-)
13:01:31 <benmachine> but if I'm not supposed to give examples in Haskell I'm not sure how to give them :P
13:02:19 <benmachine> I'm thinking of, say, length [] = 0; length (x :: xs) = suc (length xs)
13:02:32 <benmachine> this is corecursive because the recursive occurrences of length are guarded by the suc constructor
13:02:59 <benmachine> and length : CoList A → CoNat, or something like that
13:03:06 <osa1> benmachine: but can you write this function? because you're destructing on list constructors so this function is actually recursive?
13:03:57 <benmachine> osa1: you can pattern match on colists just like normal lists
13:04:15 <osa1> benmachine: oh so this is allowed? I didn't know that. is it mentioned in the paper? (total programming)
13:04:29 <benmachine> osa1: I don't remember the paper, let me see if I have a copy
13:04:39 <benmachine> I have read it but not for a while :)
13:05:12 <osa1> benmachine: hmm I think it has an example of that in 4.2
13:05:19 <osa1> coinduction section
13:05:21 <benmachine> no I don't have a copy of the paper
13:05:54 <osa1> ok so I understand that we can convert codata to some other codata
13:06:01 <benmachine> but yes, you can pattern-match on codata, it's just that you can't guarantee termination by only recursing on the parts
13:06:17 <benmachine> you have to guarantee termination by only recursing inside constructor calls
13:06:19 <benmachine> er
13:06:21 <benmachine> not termination
13:06:23 <benmachine> productivity
13:06:24 <osa1> but I can only pattern-match on codata in corecursive functions, right?
13:06:27 <benmachine> no
13:06:34 <benmachine> you can pattern-match on codata whenever you like
13:06:42 <benmachine> there is a function head :: CoList A → Maybe A
13:06:46 <osa1> hm.
13:06:59 <tac> with codata, you're always allowe to look at the constructor
13:07:03 <benmachine> what codata vs. data tells you is when and how you can recurse and still have a well-behaved program
13:07:13 <benmachine> it's the recursion part that is the tricky part
13:07:35 <benmachine> pattern-matching or constructor application themselves are pretty much fine
13:07:35 <tac> The problem with codata, though, (which is dual to the problem with data), is that you can't build up infinite objects "by hand"
13:07:39 <osa1> benmachine: what's tricky about recursion part?
13:07:43 <tac> You have to use a coiterator to build infinite objects
13:07:55 <tac> (or corecursion)
13:07:57 <osa1> tac: what does that mean?
13:08:09 <benmachine> tac: isn't that a bit like saying you can't recurse on lists, you have to use foldr?
13:08:14 <tac> right
13:08:15 * hackagebot mangopay 1.2 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.2 (FelipeLessa)
13:08:17 * hackagebot yesod-mangopay 1.2 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.2 (FelipeLessa)
13:08:19 <tac> 'problem' is the wrong word
13:08:39 <tac> It's easy to build stuff with data -- just use the constructors.
13:08:53 <tac> But deconstructing data is something that freshman fail out of college over :)
13:09:06 <tac> Similarly, inspecting codata is easy -- just pattern-match the constructors
13:09:17 <osa1> tac: I don't understand what's problematic about deconstructing data...
13:09:18 <tac> But constructing codata is something freshman would be equally afraid of
13:09:27 <benmachine> osa1: the tricky problem in general is how to prove a recursing program is well-behaved -- in the data case, you do this by showing that the input keeps getting smaller, with codata you show that the output keeps getting bigger
13:10:01 <tac> When you want to deconstruct a list, osa1, you end up having to use recursion. That's all I'm saying
13:10:12 <tac> Constructing a list never requires recursion
13:10:17 <benmachine> in either case, something has to happen, you don't get stuck in a loop
13:11:00 <osa1> tac: do you mean constructring a list requres corecursion?
13:11:00 <tac> Dually, building codata requires corecursion. But inspecting it doesn't.
13:11:21 <tac> lists require recurison, not correcursion.
13:11:30 <benmachine> so, one thing you can do with codata is turn it into other codata, and I claim this is what you do when you're printing out a colist
13:12:20 <benmachine> the other codata in this case being an IO-like sequence of instructions to the program runtime
13:12:29 <osa1> tac: I can't follow. you first said that "Constructing a list never requires recursion "lists require recurison, not correcursion"
13:12:40 <tac> Another way to think about it:
13:13:02 <tac> with data, you can inspect things that are arbitrarily big, but when constructing it, you must stop somewhere
13:13:03 <benmachine> however you can also turn codata into data, e.g. take : Nat -> CoList A -> List A, this is fine because you recurse on the Nat, so you don't need anything fancy with the CoList to promise good behaviour
13:13:19 <tac> with codata, you can build things that are arbitrarily (or infinitely) big, but when inspecting it, you must stop somewhere
13:13:30 <brbblnch> Hi (noob question): In this code http://lpaste.net/43046593192001536 , ghci gives me an error on line 8 (on '='). Could somebody tell me what the mistake is ?
13:13:55 <osa1> tac: so this inspection function should be recursive, not corecursive, right?
13:14:00 <benmachine> brbblnch: did you use tabs
13:14:05 <benmachine> brbblnch: tabs make GHC sad :(
13:14:19 <osa1> benmachine: yeah I think I got it.
13:14:41 <brbblnch> (which makes me sad) really ? should I use 4 spaces then ?
13:14:52 <benmachine> brbblnch: you should use an appropriate number of spaces
13:14:56 <geekosaur> brbblnch, you need to match indentation
13:15:06 <osa1> I've been playing with Coq for a while now but never really needed CoInductive definitions. maybe I should play with that for a while.
13:15:07 <benmachine> brbblnch: in this case you need each "insert" to start in the same column
13:15:19 <geekosaur> line 8 starts beyond the "insert" on line 7,so it is a *continuation* of the previous expression
13:15:40 <geekosaur> it is not an additional case of `insert`, it is seen as part of the first one
13:15:53 <tac> Coinduction is necessary for IO, but for proving theorems, most mathematicians have done entirely without it
13:16:00 <tac> (With maybe the exception of game theory)
13:16:11 <tac> (and automata theory)
13:16:14 <brbblnch> In vim, with a combination of tabs and space, I didn't see it
13:16:24 <geekosaur> odd
13:16:27 <benmachine> tac: mathematicians can do without all sorts of beautiful and interesting things, more fool them :P
13:16:34 <flebron> Is there a "most general" Functor?
13:17:00 <tac> I think it's just they don't need to study infinitely nested things, usually.
13:17:11 <tac> Or they encode them
13:17:15 <flebron> (Inspired by the "Cont is a very general monad" post by sigfpe)
13:17:16 <cdk> @hoogle (c -> d) -> (a -> b -> c) -> a -> b -> d
13:17:17 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
13:17:17 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
13:17:17 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:17:22 <tapuu> What does the serialize instance of bytestring do?
13:17:23 <tac> Just as any red-blooded programmer would lacking some primitive notion in their progrmaming language
13:17:57 <benmachine> tac: well, someone long ago decided that well-founded sets are the only kind of sets and induction is the biggest deal ever, and I think that limits your imagination
13:18:04 <brbblnch> Thank you benmachine and geekosaur !
13:18:04 <darthdeus> jle`: sorry what was the thing you sent? my irc client doesn't have it in history :\
13:18:13 <tapuu> It seems to be putting in loads of weird characters and I can't find any documentation on what it actually does
13:18:19 <tac> true, but most mathematicians don't know much about set theory
13:18:22 <osa1> tac, benmachine: thanks guys. I think I started to understand it. I'll try implementing some coinductive and inductive functions in Coq.
13:18:38 <tac> They know sets, subsets, intersections and unions, and just enough about Zermelo to give their vectorspaces a basis
13:18:40 <geekosaur> brbblnch, it is generally better to tell your editor to only insert spaces, since interpretation of tabs can vary between programs
13:18:41 <benmachine> flebron: I don't think there's a Functor that's like Cont is for Monads, but I'm not sure
13:19:03 <tac> for what it's worth, I wrote this shitty unpublished page about data and codata a while back osa1:
13:19:03 <tac> http://tac-tics.net/data-vs-codata
13:19:20 <benmachine> flebron: I have actually been meaning to ask the same question about Applicatives on one of the stack* sites for a while
13:19:22 <flebron> (I tried reading ekmett's explanation for Cont, but I had a small aneurism at "you can view ContT as a right Kan extension of a functor F along itself. That can be viewed as a limit taken pointwise over a comma category - just invert the colimit example in the wikipedia article on Kan extensions to take a limit of Ran instead a colimit of Lan. That limit is a terminal object in a category of cones")
13:19:23 <benmachine> not sure which
13:19:33 <osa1> tac: awesome, thanks for sharing!
13:19:40 <benmachine> oh, if we're talking shitty things we've done in the name of codata
13:19:48 <benmachine> I have a youtube video where you can't really hear what I'm saying
13:20:00 <osa1> haha
13:20:10 <benmachine> also it's for an audience of category theorists so YMMV
13:20:14 <benmachine> well no
13:20:19 <benmachine> for undergrads studying category theory
13:20:28 <brbblnch> geekosaur: I personally like space/tabs differentiation, one is for spacing, the other for "levelling". But for haskell, I think I'l do as you say.
13:20:37 <benmachine> https://www.youtube.com/watch?v=wo3QLr8nfrw
13:20:46 <geekosaur> python causes many of the same issues btw
13:20:50 <bitemyapp> flebron: haha what in the
13:21:54 <darthdeus> jle`: ha found it in the log, but that's not a video :P
13:22:05 <flebron> Sometimes reality imitates theproofistrivial.com
13:22:22 <bitemyapp> flebron: seriously.
13:22:23 <tac> benmachine: looks like you define the NNO, then define the coNNO where the arrows are all turned around?
13:22:57 <benmachine> tac: something like that
13:24:20 <benmachine> tac: I'm a bit more general than that
13:24:37 <benmachine> but my coexamples are half-improvised so they're not that good :P
13:24:45 <brbblnch> Thanks again, bye!
13:25:00 <tac> Yeah. Improvision is sometimes hysterial, but rarely instructive :)
13:25:09 <benmachine> only half!
13:25:10 * tac improvises a lot in his presentations
13:25:14 <benmachine> I sort of knew what I wanted to say :P
13:25:16 <benmachine> ish
13:25:32 <bitemyapp> augur: Node.js IST KRIEG
13:26:30 <gleber> Hey. I need tiny bit of help. I have function f :: StateT something Process () and there's a function g :: b -> Process c. How can I invoke function g from within function f?
13:26:56 <gleber> I tried liftM but types do not match
13:27:18 <gleber> And, obviously, I do not fully understand how monad transformers work
13:27:50 <fizbin> return . g ?
13:28:15 <fizbin> That is, return $ g typeBArgument
13:28:23 <gleber> Let me try it
13:28:43 <Cale> You want lift
13:28:45 <Cale> not liftM
13:28:48 <Cale> :t lift
13:28:49 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
13:29:41 <Cale> For any type s, the type constructor StateT s is a suitable 't' in that type
13:29:52 <Cale> So, apply g to its argument of type b, and you get something of type Process c, then apply lift to that to get something of type StateT s Process c
13:30:03 <augur> bitemyapp: :x
13:30:17 <Cale> and then execute that action
13:30:44 <gleber> Yes, lift seems to work!
13:31:26 <schlegel> gleber: If you want to know how take a look at the MonadTrans instance of (State s)
13:31:41 <schlegel> s/State/StateT/
13:31:53 <bitemyapp> augur: with that, I return to my beach and book :)
13:32:02 <gleber> Cale, thanks for the explanation! It makes sense.
13:32:32 <gleber> schlegel: Sorry, I do not understand. Is your sentence a question? :)
13:32:41 <gleber> oh, got it
13:32:46 <gleber> nvm :)
13:32:52 <schlegel> Oh sorry, forgot a comma
13:34:37 <gleber> Can't find the definition of "instance MonadTrans StateT a of" along with def of StateT itself. Where should I look?
13:40:12 <Cale> gleber: Perhaps you could post the whole error message on lpaste.net?
13:40:32 <Cale> oh, you just want to look at the instance?
13:41:18 <Cale> gleber: It's in http://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-Trans-State-Lazy.html
13:41:27 <Cale> Just do a text search for MonadTrans
13:42:44 <gleber> Found it. Thanks!
13:49:13 <cdk> is there any plan to unify Prelude's (.), id with Control.Category's (.), id? So that one can import Control.Category without hiding (.), id in Prelude?
13:49:30 <erisco> cdk, what is the problem with hiding?
13:49:39 <erisco> there are many conflicts... for example in Data.Foldable
13:50:25 <cdk> erisco: it's annoying. Also, Control.Category is strictly more general, so I'd rather have that be the default (unless there are convincing reasons against it)
13:50:38 <cdk> could you please explain how Data.Foldable conflicts?
13:50:55 <erisco> the fold functions, and possibly others
13:51:20 <ReinH> Cale: I have a CT question for you if you have a sec
13:51:40 <benmachine> cdk: more general is not always more better
13:51:58 <jrmithdobbs> Data.Foldable conflicts with prelude on like 40% of what it defines iirc
13:52:01 <erisco> cdk, one argument is that error messages are less clear with the more general versions
13:52:11 <benmachine> cdk: simplicity is a virtue to some extent
13:53:43 <cdk> jrmithdobbs: oh, I thought erisco meant Foldable conflicts with Category somehow.
13:56:10 <Cale> ReinH: go for it
13:56:29 <Cale> ReinH: Or of course, you can ask in ##categorytheory if you think that's more appropriate
13:57:02 <jrmithdobbs> this isn't really the right place but maybe someone here will know
13:57:55 <jrmithdobbs> I know f# doesn't have higher order kinds but it does supposedly do introspection, so is there a way to restrict parameters based on class signal handling (member invocation? mixed paradigms make commucation hard!) ability?
13:58:50 <jrmithdobbs> eg something like let myf (x:something) : something list = match x with | Something x' when ?????? ->
13:59:55 <jrmithdobbs> (i'm trying to work out something semantically similar to liftM if you're wondering)
13:59:56 <malvarez> jrmithdobbs: can you be more specific?
14:00:15 <jrmithdobbs> malvarez: i want to know how to write (Monad m) => m a -> m b in f#, basically
14:00:16 <jle`> cdk: it'd be nice, but imagine your first day in haskell and seeing a type error on Category for using id, or (.)
14:00:36 <jle`> cdk: but i think there's that prelude
14:00:43 <jle`> that imports the generalized versions only
14:00:45 <malvarez> jrmithdobbs: can you use statically determined type parameters?
14:00:56 <jle`> classy-prelude?
14:01:11 <jrmithdobbs> malvarez: eww, i guess i could but that sounds very unhappy overall
14:01:57 <jrmithdobbs> malvarez: what i really want is a way to specify a type should be anything whose class hierarchy can be downcast to 'm, really
14:02:17 <jle`> cdk: http://hackage.haskell.org/package/classy-prelude
14:03:02 <jrmithdobbs> malvarez: i think the basic answer is that it can't be done without really ugly stuff, unfortunately =/
14:03:32 <malvarez> jrmithdobbs: I don't think statically determined type parameters are THAT bad...
14:04:06 <jle`> it breaks parametricity, right?
14:04:10 <malvarez> jrmithdobbs: the usual terminology is statically *resolved* type parameters, my bad
14:04:13 <jrmithdobbs> malvarez: well the whole point is i want a function that actually takes multiple types just restricted by ability to respond to a particular (or set of) methods
14:04:31 <malvarez> jrmithdobbs: yeah, that's what SRTPs do
14:04:32 <jrmithdobbs> (yes, i know i just said i want typeclasses)
14:05:16 <jrmithdobbs> malvarez: maybe you're talking about something different than I thought then, looking into details now
14:05:27 <malvarez> jrmithdobbs: http://msdn.microsoft.com/en-us/library/dd548046.aspx
14:05:35 <jrmithdobbs> ya already there :)
14:06:11 <jrmithdobbs> malvarez: oh, damn, i literally just missed the exact feature i wanted, ha
14:06:14 <malvarez> jrmithdobbs: in case you might be reinventing the wheel, there's this https://code.google.com/p/fsharp-typeclasses/
14:06:20 <jrmithdobbs> malvarez: someone needs to write LYAF# already ;p
14:06:35 <jfischoff> is it wise to use something like a Pipe or Conduit if I want to chunks, not into new ByteStrings, but into the a series of rotating buffers?
14:06:45 <malvarez> jrmithdobbs: I can't agree more. F# has so many neat little features that people don't know about
14:06:46 <jfischoff> s/chunks/chunk
14:06:57 <malvarez> jrmithdobbs: I can't wait till I learn how to use type providers
14:07:15 <jfischoff> ByteStrings cause a malloc which I would like to avoid
14:07:25 <jrmithdobbs> malvarez: haha, ya i started looking at them and the msdn docs made my eyes refuse to continue reading
14:08:04 <malvarez> jrmithdobbs: it's really a shame how poorly documented they are
14:08:20 <jrmithdobbs> malvarez: f# + unity3d is a joy to work with once you get over having to do your clr/code builds outside of the unity ui workflow
14:08:49 <malvarez> jrmithdobbs: how easy is to set that up on Mono? I might be interested (although my go-to language is actually OCaml)
14:08:52 <jrmithdobbs> malvarez: but figuring out how to make the f# interface compat with what unity wants is a bunch of trial and error with cast errors to tell you when you've figured it out + stackoverflow ;p
14:09:52 <jrmithdobbs> malvarez: i just built a simple makefile to build the project, on os x you pretty much install unity, brew install mono fsharp; copy /usr/local/lib/mono/**/mono/2.0/FSharp.Core.dll into the unity assets folder
14:10:28 <jrmithdobbs> malvarez: and when you build your f# framework for linking make sure you target 2.0 not 3.5/4.0 and drop your built dll in the unity assets dir, and you're done
14:10:58 <jrmithdobbs> malvarez: since f# is "clr-pure" (if that's even a thing) you don't even need pro licensing ;p
14:11:13 <malvarez> jrmithdobbs: that sounds easy enough. anything from 4.0 you miss on 2.0?
14:11:37 <jrmithdobbs> malvarez: considering my entire experience with .net/mono has involved playing with unity, not that I know of ;p
14:12:25 <jle`> lazy evaluation is so weird
14:12:29 <jrmithdobbs> malvarez: what's really cool is the coroutine mechanism in unity is literally a downcasted seq { } :?> IEnumerator and then you're literally running a 3d/2d graphics/physics engine to interleave your monandic actions
14:12:29 <jle`> gr
14:12:34 <jrmithdobbs> mlinksva: and that sentence is just awesome.
14:13:10 <malvarez> jrmithdobbs: that sounds pretty nice, yeah
14:13:32 <malvarez> jrmithdobbs: I'm not really into that whole 'running programs' thing, I'm usually happy enough with getting stuff to compile
14:14:06 <jrmithdobbs> i'm sick of writing things i can't explain to anyone because noone cares about it
14:14:10 <jrmithdobbs> people understand games ;p
14:14:59 <malvarez> jrmithdobbs: ah, I'd love to have the patience to develop the simplest of games
14:15:28 <malvarez> jrmithdobbs: alas, I do not
14:16:20 <jle`> malvarez: join us :)
14:16:55 <malvarez> jle`: define 'us'. otherwise I'll assume you to be the Borg.
14:17:10 <jle`> people making games in haskell
14:17:10 <jrmithdobbs> good assumption
14:17:15 <jle`> aka the borg
14:17:24 <jrmithdobbs> jle`: i can't bring myself to do it
14:17:43 <malvarez> known for the most powerful spaceship known to man: the borg lambda-cube
14:17:46 <jle`> don't believe the propaganda
14:18:02 <jrmithdobbs> jle`: after seeing the toolsets available for automating the mundane stuff (like sprite/model animation and such) doing that all manually just seems a waste of time =/
14:18:22 <jle`> then write the things that will let you not do it manually :)
14:18:30 <jle`> you have the opportunity to change the world
14:18:36 <jle`> forever
14:18:41 <jle`> think about it
14:18:47 <jrmithdobbs> jle`: but they already exist and can be used with not-quite-as-nice-as-haskell languages
14:18:57 <jrmithdobbs> jle`: see comments re: unity3d and f# ;p
14:19:23 <jle`> you won't change the world using unity3d and f#
14:19:28 <jle`> unless you are john carmack
14:19:38 <jrmithdobbs> but you may actually complete a project ;p
14:19:45 <malvarez> jle`: actually, since F# is impure, you can change the world at any time...
14:19:52 <jrmithdobbs> and that, lol
14:19:57 <merijn> jle`: You won't if you are John Carmack either, because he'd just write an engine from scratch :p
14:20:13 <jle`> :P
14:20:31 <malvarez> you know what we should do? write a statically typed extension top FORTH (in FORTH itself) and code in that forever.
14:20:45 <jrmithdobbs> jle`: i almost wrote something similar to unity (at least, it's toolset, not the way the engine works) using haskell and lua instead of c++ and the clr ;p
14:20:56 <jrmithdobbs> jle`: but then saw unity and was like "waste of my time then"
14:21:14 <jle`> but you were so close to changing the world
14:21:27 <jle`> :'(
14:21:38 <jle`> everything would have been different
14:21:46 <jrmithdobbs> heh
14:21:53 <jle`> see my 'what if' machine
14:23:35 <jrmithdobbs> jle`: i dunno, even when i get things to a stable/useful point my experience is that last "change the world" step never seems to happen, eg, https://github.com/jrmithdobbs/sdmckt
14:24:14 <jle`> change the world...incrementally :)
14:25:57 <jrmithdobbs> speaking of, i think i'll clean that code up and add haskell/lua bindings this weekend maybe ;p
14:26:32 <jle`> has anyone looked themselves up in the http://osrc.dfm.io/
14:26:45 <jle`> it is a good self esteem booster
14:28:13 <malvarez> jle`: impressive
14:28:50 <malvarez> jle`: it works even if you only have two repos that you don't even bother to mantain
14:29:31 <jrmithdobbs> wish i could point it at a GHE instance
14:33:21 <jfischoff> > It seems like Jonathan is—or should be—friends with Carter Tazio Schonwald
14:33:23 <lambdabot>  Not in scope: data constructor `It'
14:33:23 <lambdabot>  Perhaps you meant `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)...
14:33:23 <lambdabot>  Perhaps you meant one of these:
14:33:23 <lambdabot>    `id' (imported from Data.Function),
14:33:23 <lambdabot>    `C.id' (imported from Control.Category),
14:33:40 <jfischoff> whoops
14:33:50 <jrmithdobbs> malvarez: thanks btw, this is exactly what I was looking for and that should be in FSharp.Core!
14:34:12 <jle`> :t In
14:34:13 <lambdabot> f (Mu f) -> Mu f
14:34:23 <jle`> hm
14:34:43 <malvarez> jrmithdobbs: I'm glad to see that all the time I waste learning obscure features of random languages can be of use
14:34:47 <shachaf> "Mu" :-(
14:34:50 <shachaf> Should be called Fix.
14:35:00 <jle`> that makes more sense
14:35:17 <jrmithdobbs> jle`: ya remember that, every time you see Mu defined somewhere they mean Fix =/
14:35:26 <jrmithdobbs> (almost* every)
14:43:26 * hackagebot bugzilla 0.1.0.1 - A Haskell interface to the Bugzilla native REST API  http://hackage.haskell.org/package/bugzilla-0.1.0.1 (sethfowler)
14:44:09 <vektor> woo! I crashed GHCI!
14:45:18 <jle`> woo
14:46:41 <th3w4c0k1d> How do I write a function implementation of put :: a -> IO (), where put (Int a) = intfn, put (Float a) = floatfn, etc. Can I match just like that, or do I have to create my own type: Acceptable = Float | Int | ...?
14:47:14 <vektor> this probably isn't sufficient, huh? *CommonStatistics Data.List> :l SimpleCellularALife
14:47:16 <vektor> [1 of 2] Compiling CommonStatistics ( CommonStatistics.hs, interpreted )
14:47:17 <vektor> <interactive>: internal error: evacuate: strange closure type 8306
14:47:53 <pavonia> th3w4c0k1d: You can make put a type class function
14:47:55 <jle`> th3w4c0k1d: well, first of all, Int and Float aren't type constructors
14:48:04 <jle`> you can use a typeclass
14:48:08 <jle`> but you can also use your data type
14:48:15 <jle`> data Acceptable = AccFloat Float | AccFloat Int
14:48:17 <SwashBuckla> Help! I get a weird error when I run "./configure --prefix=/usr/local/ghc" : checking for path to top of build tree... ./configure: line 2121: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: No such file or directory
14:48:27 <jle`> what you should do depends on what side of the expression problem you want to fall on
14:48:35 <SwashBuckla> on ghc 7.6.3
14:48:44 <jle`> if you anticipate adding more acceptable types in the future or leaving it open, make a typeclass
14:49:35 <jle`> if you want to let the end -user supply either a int or a float without any knowledge of your Acceptable data type, you might need a typeclass as well
14:51:35 <th3w4c0k1d> jle`: Thank you! I think my use case matches the ignorant end-user case. So, I would define my function as put :: (Puttable a) => a -> IO (), and then write a Puttable class and an Instance for Float, Int, etc?
14:51:51 <jle`> yeah
14:51:57 <jle`> but this isn't really a popular design choice
14:52:03 <jle`> because now your user has to know about the Puttable typeclass
14:52:16 <jle`> and that it is either an Int or a Float
14:52:16 <jrmithdobbs> depends, it's a popular design choice to criticize
14:52:18 <jrmithdobbs> ;p
14:52:22 <jle`> :P
14:52:26 <jle`> yeah, it's done often
14:52:30 <jle`> but often criticized
14:52:38 <jrmithdobbs> and rarely turns out to be useful
14:52:45 <th3w4c0k1d> Why do they have to know about it? They can't just write: put 7?
14:52:49 <jrmithdobbs> because you usually end up with 3-4 types that should have been in one ADT
14:53:01 <jle`> they can, but you have to tell the what you can 'put'
14:53:06 <jle`> it's not obvious from the typesignature of put
14:53:12 <th3w4c0k1d> ah
14:53:12 <jle`> it's a Puttable...but what is a Puttable?
14:53:15 <jle`> *click click*
14:53:22 <jle`> ^ those are clicks through documentation
14:53:27 * hackagebot haskell-plot 0.1.0.0 - A library for generating 2D plots painlessly.  http://hackage.haskell.org/package/haskell-plot-0.1.0.0 (kaizhang)
14:53:41 <jle`> the most sane solution would be to just offer putInt and putFloat
14:53:50 <jle`> or maybe even put :: Num a => a -> IO ()
14:53:59 <jle`> if you are willing to let all Num's be puttable
14:54:09 <jle`> inventing a new typeclass is rarely the right decision
14:55:14 <jle`> some people offer a putInt, a putFloat, and an over-egregious put :: Puttable a => ...
14:55:26 <jle`> http://hackage.haskell.org/package/websockets
14:56:21 <th3w4c0k1d> So, the issue I'm trying to solve is that OpenGL has a function called glUniform1f for "putting" a float, and it also has glUniform1i for putting an int, and it also has glUnfiromMatrix4f for putting a list of lists of floats... and there are about 20 variations. I'd like it to condense into one or two functions call glUniform _ that "knows what to do". Is there a way I should lean (does that info help)?
14:56:52 <pavonia> I'd say that a case for type classes
14:56:57 <pavonia> *that's
14:57:30 <th3w4c0k1d> pavonia: I see
14:57:36 <Cale> http://hackage.haskell.org/package/OpenGL-2.9.1.0/docs/Graphics-Rendering-OpenGL-GL-Shaders-Uniform.html#v:uniform
14:57:53 <Cale> http://hackage.haskell.org/package/OpenGL-2.9.1.0/docs/src/Graphics-Rendering-OpenGL-GL-Shaders-Uniform.html#Uniform
14:58:07 <th3w4c0k1d> Cale: Ah, thanks!
14:58:31 <pavonia> Any ideas why mouse events are not triggered here when the mouse is moved in and out of the drawing area? http://lpaste.net/102269
14:59:19 <vektor> can't reproduce the crash... what now?
15:00:30 <Cale> pavonia: I hazily recall there being some sort of property you need to set in order to receive such events
15:01:57 <pavonia> Cale: Hhm, the documentation doesn't say anything about that
15:02:34 <pavonia> vektor: I think I've seen this once when GHCi was out of memory
15:02:48 <Cale> ah, yeah
15:02:59 <Cale> See the EventMask type
15:03:07 <vektor> now that it has crashed, I have 33% of 4GB free.
15:03:11 <Cale> and the EnterNotifyMask and LeaveNotifyMask values of that
15:03:31 <Cale> widgetAddEvents :: WidgetClass self => self -> [EventMask] -> IO ()
15:03:41 <vektor> How much can GHCi use? Does it leak memory? I wasn't crunching big numbers, but I had the instance open for a while.
15:03:44 <Cale> (or widgetSetEvents)
15:03:52 <vektor> I.e. the files were a few hundred lines at best
15:04:24 <Cale> I honestly don't know why GTK doesn't just manage those according to whether there are handlers set
15:04:27 <Cale> But yeah
15:04:29 <pavonia> Cale: These flags should be set when the event handlers are defined
15:06:16 <vektor> pavonia: report anyways, even though I have little to no information? Or leave it?
15:07:01 <pavonia> I don't know
15:07:16 <niez> how can I reinstall haskell platform on debian?
15:07:18 <pavonia> Cale: They are set indeed, I checked
15:07:35 <Cale> hmm
15:07:40 <Cale> If it's not that, I'm not sure
15:08:08 <Cale> dcoutts might know
15:08:26 <Cale> (if he's here...)
15:08:56 <jle`> they /b 13
15:08:59 <jle`> sorry wrong window
15:09:15 <peddie> niez: sudo aptitude reinstall haskell-platform ?
15:09:39 <niez> peddie, lets try that one...
15:10:12 <jonsterling> So I'm trying to install http-conduit-2.0.0.4, and I'm getting the following error:
15:10:16 <jonsterling> https://www.irccloud.com/pastebin/sKh6S2dZ
15:10:19 <jonsterling> Any ideas?
15:10:32 <niez> no, errors, errors everywhere
15:11:12 <peddie> niez: what kinds of errors?
15:11:15 <niez> I was trying to install yesod, then happstack, then snap, then elm today
15:11:31 <niez> I get errors every time
15:11:48 <peddie> niez: what kinds of errors?
15:11:53 <peddie> niez: do you know about cabal sandboxes?
15:11:57 <niez> reinstall of haskell-platform didn't help
15:11:59 <peddie> @where sandboxes
15:12:00 <lambdabot> I know nothing about sandboxes.
15:12:02 <peddie> dang
15:12:06 <niez> peddie, no, sandboxes?
15:12:16 <peddie> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
15:12:36 <peddie> I suspect it'll be easier if you try to install each of those in its own sandbox
15:13:06 <peddie> it's pretty easy for cabal to get confused by conflicting package versions
15:13:12 <niez> ok, but i would like to make my haskell-platform usable first
15:13:25 <peddie> what isn't usable about it?  what kinds of errors are you getting?
15:14:59 <niez> I opened synaptic, selected everything installed from haskell and removed all packagesm then installed again
15:15:10 <niez> and still after fresh install I get: http://lpaste.net/102270
15:15:26 <peddie> ok
15:15:38 <newsham> anyone here know much about Data.Acid, in particular the file formats it uses?
15:15:40 <peddie> this problem will probably go away if you use one sandbox for yesod, one for elm, etc.
15:16:18 <niez> peddie, but how to remove this trash? my incomplete installation of yesod
15:16:28 <peddie> but beyond that, you can try moving ~/.ghc to ~/.ghc-old or something and starting installs over -- I think ~/.ghc stores the state of what you've installed via cabal
15:17:14 <peddie> but I'm not kidding about the sandboxes :) things in sandboxes shouldn't conflict with what you already have installed!
15:17:36 <niez> peddie, wow, I didn't realised the existence of .ghc, I removed only .cabal
15:20:06 <niez> can I install a specific version of a package in such sandbox?
15:20:21 <peddie> niez: of course
15:21:00 <niez> great, so cabal is more flexible than apt-get in thi matter
15:22:18 <peddie> niez: note also that yesod, happstack and snap _are_ available through apt, though I don't know what versions, and I don't think most people use apt for this
15:22:50 <jle`> are popl talks up yet?
15:23:00 <bitemyapp> niez: you really don't want to use distribution packages for Haskell libraries.
15:23:12 <bitemyapp> niez: it doesn't make any more sense here than it would in node.js or wherever else.
15:23:32 <niez> ok, I did small test, tried to install elm with cabal without sandbox, errors again
15:23:46 <niez> sandbox will fix that?
15:23:55 <davidfetter_disq> elm?!? here i thought i was old school for using mutt
15:24:13 <peddie> niez: I don't know what errors you got, so I don't know whether sandboxes will help
15:24:32 <niez> ok, sorry, wrong terminal, compuilation still running...
15:24:51 <peddie> but the original error you pasted seemed to me like some package versions were in conflict between installing elm and yesod, and I think installing them within their own sandboxes will help with that
15:25:47 <niez> davidfetter_disq, what http://elm-lang.org has to do with mutt? :)
15:26:46 <peddie> ;
15:26:48 <niez> ok, thank you very much, it looks like all my problems are solved
15:27:00 <peddie> niez: great!  have fun
15:29:44 <vektor> filed. with all the gory detail
15:29:51 <vektor> https://ghc.haskell.org/trac/ghc/ticket/8957#ticket
15:29:52 <SwashBuckla> I did ./configure --prefix=/usr/local/ghc as recommended, but how do I let cabal know where GHC is located when doing updates?
15:30:26 <SwashBuckla> it can't find it as it is  only looking in /usr/bin/ghc
15:31:21 <niez> what is wrong: http://lpaste.net/102271 ?
15:31:52 <geekosaur> niez: cabal sandbox was introduced in 1.18
15:31:54 <geekosaur> you have 1.16
15:32:00 <niez> ah, yes
15:32:47 <geekosaur> you can get much the same functionality from cabal-dev if you can't upgrade the Cabal library (which can break template haskell apparently) or cabal-install
15:36:35 <pordan30> i'm trying to install diagrams through cabal, which depends on distributive. while compiling data.distributive, cabal looks for "-lHStransformers-compat-0.1.1.1-ghc7.8.0.20140228" and "-lHStagged-0.7.1-ghc7.8.0.20140228" in /usr/bin/ld and fails when it can't find them. google doesn't reveal any useful information. how can i resolve this problem?
15:36:46 <davidfetter_disq> niez, http://en.wikipedia.org/wiki/Elm_%28e-mail_client%29
15:37:20 <geekosaur> wat
15:37:33 <geekosaur> oh
15:37:40 <pordan30> err, in /usr/bin
15:38:07 <pordan30> i guess it's running ld
15:38:32 <byorgey> pordan30: you may want to try a more recent version of GHC 7.8.  I think there were some linker-related bugs that got fixed, though I don't actually know any details
15:38:32 * hackagebot cereal-plus 0.3.3 - An extended serialization library on top of "cereal"  http://hackage.haskell.org/package/cereal-plus-0.3.3 (NikitaVolkov)
15:38:34 * hackagebot pipes-cereal-plus 0.3.2 - A streaming serialization library on top of "pipes" and "cereal-plus"  http://hackage.haskell.org/package/pipes-cereal-plus-0.3.2 (NikitaVolkov)
15:38:41 <byorgey> pordan30: or just use GHC 7.6.
15:39:59 <pordan30> thanks, byorgey - i'll try a more recent release of 7.8, and if that doesn't work, then 7.6
15:42:03 <byorgey> pordan30: as far as I know diagrams builds with the latest 7.8, please do let us know if you run into problems.  Even if it works fine for you to fall back to 7.6 we'd still like to know.
15:42:38 <geekosaur> that error sounds like possibly you have versions of transformers-compat and tagged that don't match your current compiler
15:43:28 <geekosaur> if you've been updating to 7.8 prereleases as they come out, ghc's insistence (and need for) exact version matching will cause issues unless you rebuild pretty much everything after upgrading ghc
15:49:54 <saml_> i'm at hackathon
15:49:56 <saml_> what do i do?
15:50:27 <jle`> hack
15:50:38 <jle`> or sleep
15:50:49 <jle`> > cycle ["hack","sleep"]
15:50:51 <lambdabot>  ["hack","sleep","hack","sleep","hack","sleep","hack","sleep","hack","sleep",...
15:51:03 <bitemyapp> jle`: not quite right
15:51:12 <saml_> > interleave cycle ["hack"]
15:51:13 <lambdabot>  Not in scope: `interleave'
15:51:25 <bitemyapp> > cycle ["hack", "coffee", "eat", "sleep", "coffee"]
15:51:26 <lambdabot>  ["hack","coffee","eat","sleep","coffee","hack","coffee","eat","sleep","coffe...
15:51:30 <bitemyapp> that's better
15:51:41 <saml_> @hoogle interleve
15:51:42 <lambdabot> No results found
15:51:51 <bitemyapp> @hoogle interleave
15:51:52 <lambdabot> package interleave
15:51:52 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays interleavedArrays :: InterleavedArrays -> Stride -> Ptr a -> IO ()
15:51:52 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays data InterleavedArrays
15:51:57 <bitemyapp> :t interleave
15:51:58 <lambdabot> Not in scope: `interleave'
15:52:06 <saml_> > monad . stuff >>== thanks
15:52:07 <Gothmog_> @hoogle intersperse
15:52:07 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:52:08 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
15:52:08 <lambdabot> Data.ByteString.Lazy.Char8 intersperse :: Char -> ByteString -> ByteString
15:52:09 <lambdabot>  Not in scope: `monad'Not in scope: `stuff'Not in scope: `thanks'Not in scope...
15:52:09 <lambdabot>  Perhaps you meant `>>=' (imported from Control.Monad.Writer)
15:52:20 <saml_> should i write a database?
15:52:34 <saml_> i'll write a hello world
15:52:57 <jle`> hm i just had an idea to write a haskell-based unix filesystem kinda thing with a bash-like browser with my own scripting language
15:52:59 <jle`> it all sounds kinda silly
15:53:09 <pavonia> Is it possible to change the mouse cursor in gtk2hs? There's some support for defining Cursor values, but I can't find a way to actually set them for a widget/window
15:53:11 <jle`> but you can like save files and edit them and stuff with cat, etc.
15:53:13 <saml_> what's your scripting lang?
15:53:14 <jle`> cat/>
15:53:20 <saml_> i can fork it and add llvm
15:53:21 <jle`> using pipes and stuff
15:53:26 <byorgey> saml_: find someone else working on an interesting project, and help them with it
15:53:26 <jle`> i wonder if it has been done before
15:53:34 <peddie> saml_: ghc bugs?
15:53:41 <saml_> i can fix ghc bugs
15:53:43 <saml_> sec
15:53:50 <dwcook> jle`, I think it'd be neat if someone managed to write an actual filesystem compatible with Linux in Haskell
15:53:54 <saml_> assign one to me
15:53:57 <saml_> jira ticket
15:54:02 <jle`> dwcook: what do you mean by compatible
15:54:13 <saml_> how can i find leet in hackathon?
15:54:39 <dwcook> jle`, well, one that you can use like other file systems on Linux, like ext* or ntfs
15:54:51 <jle`> ah
15:55:13 <jle`> i always thought ntfs etc. were just standards/protocols
15:55:28 <jle`> did not know that they were actual software backends
15:55:29 <dwcook> I think they are, but moreover people have written drivers for them for the kernel
15:55:41 <jle`> i could get linux kernel to use my haskell backend?
15:55:57 <dwcook> Maybe? I haven't looked into it in any depth
15:56:25 <jle`> hm
15:56:27 <jle`> ty
15:56:29 <jle`> g2g
15:56:30 <saml_> ok can't find bugs
15:56:35 <saml_> ghc type checks
15:58:09 <saml_> how can i write a chat server? for websockets and android?
16:01:11 <petrie> Does anyone know of any functional programming courses online?
16:02:26 <saml_> is yesod better than scotty?
16:02:51 <aninhumer> Is there any reason this syntax: RecordWithFunc { f x = x + 1 } couldn't be implemented for records? Or is there already an extension which implements it?
16:03:23 <SwashBuckla> I did ./configure --prefix=/usr/local/ghc as recommended, but how do I let cabal know where GHC is located when doing updates?
16:05:36 <saml_> why does cabal use single core?
16:06:49 <c_wraith> Hmm.  I wonder if parallel builds are in cabal yet.
16:06:54 <c_wraith> They're in progress, at least
16:07:04 <c_wraith> saml_: try adding a -j option, see if it does anything!
16:07:12 <c_wraith> saml_: well, -j3
16:07:21 <saml_> let me upgrade cabal-isntall first
16:07:22 <pavonia> aninhumer: What is f there?
16:07:34 <saml_> added jobs: 1024 in ~/.cabal/config
16:07:42 <saml_> full max 1024 cores
16:08:17 <c_wraith> ghc also recently added support for parallel builds, where dependencies allow it
16:08:36 <saml_> still uses single core
16:08:46 <tg2> holy shit you gotta be kiddin gme
16:08:53 <aninhumer> pavonia: a "field" in the record, but one which is a function type
16:08:57 <c_wraith> I have no idea how to pass the necessary flag to ghc through cabal
16:09:06 <tg2> installed ghc 7.6.3, installed haskell-platform from source
16:09:13 <saml_> these should work out of the box
16:09:18 <tg2> cabal: At least the following dependencies are missing:
16:09:18 <tg2> text >=1.0.0.1
16:09:18 <tg2> $ cabal install text
16:09:18 <tg2> Resolving dependencies...
16:09:18 <tg2> All the requested packages are already installed:
16:09:19 <tg2> text-0.11.3.1
16:09:25 <tg2> fuck sakes
16:09:32 <tg2> pro package manager
16:09:51 <geekosaur> what are you trying to install?
16:09:51 <c_wraith> tg2: did you read the error messages?
16:09:58 <aninhumer> pavonia: So essentially it would be equivalent to: RecordWithFunc { f = \x -> x + 1 }
16:10:04 <Cale> tg2: What do you expect?
16:10:04 <tg2> i did
16:10:13 <c_wraith> tg2: because they pretty clearly explain the problem
16:10:16 <tg2> but the NEWEST version doesn't have the required version?
16:10:16 <tg2> come on
16:10:28 <Cale> You don't have the newest version installed.
16:10:33 <c_wraith> tg2: the platform is *far* from the newest verion
16:10:35 <c_wraith> *version
16:10:46 <tg2> https://gist.github.com/Dexyne/5791465
16:10:48 <geekosaur> and you can't sanely upgrade it, things will break :(
16:10:52 <Cale> The newest version of text is 1.1.0.1
16:10:55 <c_wraith> tg2: that particular version of the platform has been out for over a year
16:10:56 <tg2> yeah i know that
16:11:07 <c_wraith> tg2: and you can't just upgrade, because that will break things
16:11:08 <tg2> the version in packages is super old
16:11:15 <c_wraith> tg2: your mistake was installing the platform
16:11:24 <tg2> fuck me for installing a platform that was 8 months old
16:11:25 <tg2> right
16:11:26 <c_wraith> tg2: that forced your system into this state
16:11:49 <tg2> upgrade mechanism is really simple just delete everything and install it all again from scratch
16:11:57 <Cale> tg2: It's worth noting that you can supply a specific version number to cabal install and it will install that version
16:12:04 <c_wraith> tg2: yes.  why don't you do that?  It's 2 commands.
16:12:28 <Cale> tg2: But doing that may break packages (however, if you're paying attention, it's possible to just reinstall everything and unregister the old versions)
16:12:35 <dwcook> Out of curiosity, how do people generally obtain GHC and cabal-install?
16:12:37 <tg2> fuckin mess
16:12:46 <nisstyre> dwcook: pacman -Syu ghc cabal
16:12:47 <Cale> dwcook: I do just those two things exactly
16:12:48 <tg2> want to installa  170kb application
16:12:50 <nisstyre> or w/e
16:12:56 <dwcook> I think I have the platform installed as well (though I've never run into such problems)
16:13:01 <Cale> dwcook: I get the generic linux binary of GHC from the GHC website
16:13:01 <tg2> derp better download 500MB of haskell and then re-downoad it 4 times
16:13:03 <tg2> yeah
16:13:10 <Cale> and then I get the tarball of cabal-install from Hackage
16:13:39 <dwcook> Neat. I'll try that if I run into problems.
16:13:39 <tg2> just hacked hte .cabal file to accep the lower dep
16:13:47 <Cale> tg2: Why don't you just get a binary?
16:13:57 <tg2> >ftw no binaries
16:13:59 <Cale> Is the application you want to install xmonad?
16:14:04 <tg2> no
16:14:07 <kcherkashin__> Anybody is going to the hacNYC thing?
16:14:11 <vozz> How do you handle Ctrl+C in haskell? Everything I've written so far has exited when I Ctrl C, but this little thing doesnt: http://lpaste.net/102273
16:14:13 <tg2> https://github.com/dogestreet/proxypool#building
16:14:17 <newsham> anyone here familiar with Acid-State internals?
16:14:58 <geekosaur> vozz: you can try to trap the exception, or you can use platform specific operations to handle the signal before it is turned into an exception
16:15:04 <Cale> tg2: Wait, you're in a sandbox?
16:15:17 <Cale> tg2: are you following those instructions?
16:15:23 <tg2> yes
16:15:29 <tg2> but the package manager shit is old
16:15:31 <Cale> hmm
16:15:32 <tg2> so had to compile form source
16:15:39 <tg2> for haskell-platform
16:15:44 <tg2> which apparently is the source from 8 months ago
16:15:49 <Cale> ah, right, you have to build cabal-install
16:15:53 <geekosaur> also if that is calling into C a lot then there are complexities
16:16:00 <tg2> anyway, its owrking despite the force dep on text 1.0 -> 0.11
16:18:48 <Cale> vozz: I believe in that case, the reason it's not responding is that it's in a foreign code infinite loop which isn't responding to signals
16:19:10 <Cale> So the GHC runtime has no opportunity to do anything
16:19:35 <Cale> (because the foreign call doesn't return)
16:19:44 <jle`> why do I have the sudden urgency to write a virtual kernel in Haskell
16:19:56 <jle`> urge
16:20:09 <vozz> I guess so
16:20:12 <jle`> it sounds like a fun project
16:20:13 <Cale> jle`: Have you seen House?
16:20:30 <jle`> Cale: no, I'll check it out
16:20:42 <jle`> ty
16:20:50 <Cale> (It's not a VM, it's a real operating system)
16:20:58 <vozz> maybe I should change loop to dispatch and loop inside haskell
16:21:32 <Cale> vozz: Worth trying, I bet
16:21:37 <vozz> but then I don't know if it will miss packet
16:21:38 <vozz> s
16:23:08 <vozz> Cale: it works, thanks
16:23:12 <Cale> Does it respond to the ctrl-C when the next packet is printed?
16:23:17 <Cale> (in the original case)
16:23:21 <vozz> no
16:23:23 <Cale> hm
16:23:57 <Cale> Oh, another thing perhaps to try would be to use the threaded runtime
16:24:11 <vozz> it's responding now, I just put a forever $ in front of withForeignPtr changed loop to dispatch
16:24:17 <Cale> (by compiling with -threaded)
16:24:29 <Cale> Yeah, that'll work
16:24:29 <jle`> Cale: yeah, thanks, it looks neat
16:24:33 <vozz> what does that do?
16:24:43 <vozz> I'm running it as a script with runhaskell at the moment
16:25:43 <vozz> Cale: compiling it with threaded works!!
16:25:47 <vozz> thanks so much
16:26:13 <vozz> in fact just plain compiling it works
16:26:23 <Cale> hm :)
16:26:26 <vozz> weird :D
16:26:43 <Cale> Well, runhaskell/interpreted mode has some oddities
16:28:52 <orzo> haddock seems to be a pita when it comes to code with CPP directives
16:50:43 <pavonia> How do you manually trigger an arbitrary event in gtk2hs?
16:58:42 * hackagebot git-gpush 3.0.1 - More intelligent push-to-GitHub utility.  http://hackage.haskell.org/package/git-gpush-3.0.1 (JohnWiegley)
16:58:44 * hackagebot git-monitor 3.1.1 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-3.1.1 (JohnWiegley)
16:58:47 * hackagebot gitlib 3.0.2 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-3.0.2 (JohnWiegley)
16:58:49 * hackagebot gitlib-cmdline 3.0.1 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-3.0.1 (JohnWiegley)
16:58:51 * hackagebot gitlib-cross 3.0.1 - Run tests between repositories  http://hackage.haskell.org/package/gitlib-cross-3.0.1 (JohnWiegley)
17:00:58 <codygman> How do I add optimizations to a .cabal file?
17:01:05 <codygman> -O3
17:02:12 <Guest55726> Sclv: can you confirm that the website for Hac NYC sent me on a wild goose chase?
17:02:22 <jle`> codygman: ghc-options
17:02:38 <copumpkin> Guest55726: he's not online
17:02:45 <copumpkin> Guest55726: need his phone number?
17:03:44 <codygman> Are there any examples of how a ghc-options filed should look? is it a list?
17:03:53 * hackagebot gitlib-libgit2 3.0.1 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-3.0.1 (JohnWiegley)
17:03:55 * hackagebot gitlib-s3 3.0.2 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-3.0.2 (JohnWiegley)
17:03:57 * hackagebot gitlib-sample 3.0.1 - Sample backend for gitlib showing the basic structure for any backend.  http://hackage.haskell.org/package/gitlib-sample-3.0.1 (JohnWiegley)
17:03:59 * hackagebot gitlib-test 3.0.1 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-3.0.1 (JohnWiegley)
17:04:01 * hackagebot hlibgit2 0.18.0.13 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.13 (JohnWiegley)
17:04:02 <codygman> Should it go under "executable"?
17:04:57 <jle`> codygman: yeah
17:04:58 <jle`> or library
17:05:03 <Guest55726> No phone
17:05:17 <jle`> codygman: ghc-options: -O3
17:05:22 <jle`> it's just like the flags you would add
17:05:32 <jle`> as if you were actually calling ghc
17:05:46 <jle`> like ghc-options: -O3 -Wall
17:05:53 <Guest55726> The 6th ave it mentions is in the wrong zip code based on the one on pivotal's page
17:06:09 <copumpkin> Guest55726: 625 Avenue of the Americas Second Floor New York, NY 10011-2020
17:06:30 <copumpkin> Guest55726: from pivotal's own website
17:06:36 <Guest55726> So I'm pretty sure I just went an hour out of my way based on someone googling the wrong address and posting it
17:06:44 <jle`> :/
17:06:56 <jle`> maybe that's a part of the hac challenge
17:06:58 <Guest55726> The one on the Hac NYC site is out in Brooklyn :)
17:07:06 <jle`> finding the venue
17:07:08 <jle`> challenge #1
17:07:14 <copumpkin> well, the address says Manhattan in it
17:07:32 <copumpkin> but yeah, 10011
17:08:07 <Guest55726> Hence my confusion
17:08:34 <Guest55726> Pretty sure I can't get there before the end of festivities for the night
17:09:14 <copumpkin> :(
17:09:31 <copumpkin> I'll text sclv and chew him out :)
17:09:48 <Guest55726> Worse I had gone down towards the right site before changing to the other second guessing myself because of the address on the site
17:10:29 <pavonia> Oh dear, setting a timeout and regularly checking for the mouse position really feels like doing it the wrong way :|
17:10:37 <lingxiao> hac nyc!
17:11:18 <Guest55726> Going to go hop back on the F, and head back to civilization
17:11:35 <copumpkin> Guest55726: good luck!
17:15:02 <ghast> hello. anybody uses haskell-doc on emacs? it does not seem to be working for me.
17:17:26 <codygman> how can I make an expression in a do block that does nothing? Isn't it something like ()?
17:17:36 <codygman> I basically want to request a website and nothing else in the do block
17:17:38 <copumpkin> return ()
17:17:38 <pavonia> return ()
17:17:46 <copumpkin> why do you need to write that though?
17:18:12 <kcherkashin__> Anybody is going to the hacNYC hackathon?
17:18:23 <copumpkin> kcherkashin__: I'll be there tomorrow and sunday
17:18:29 <jle`> codygman: your request command should probably be IO () or something already?
17:18:42 <kcherkashin__> copumpkin: Awesome, did you pick a project already?
17:18:52 <jle`> oh does it take an IO action to do with it?
17:19:02 <jle`> request :: Url -> (Response -> IO ()) ?
17:19:04 <copumpkin> kcherkashin__: sort of :) will work on rounded a bit and then perhaps on some other stuff
17:19:11 <jle`> yeah you can do (\_ -> return ())
17:19:39 <saml_> kcherkashin__, i'm at hacnyc now
17:19:44 <saml_> and learning haskell
17:20:06 <codygman> jle`: That is correct
17:20:26 <kcherkashin__> saml_: Oh, cool, how long is it going to be today?
17:20:35 <jle`> or const (return ())
17:20:37 <saml_> > let mult a b = [xs++ys | xs <- a, ys <- b]  in mult ["a", "b"] ["1", "2"]
17:20:38 <lambdabot>  ["a1","a2","b1","b2"]
17:20:45 <jle`> but i think (\_ -> return ()) is clearer
17:20:48 <saml_> that's seminearring. TIL
17:20:49 <jle`> just my opinion
17:20:56 <saml_> kcherkashin__, it's lonely
17:21:08 <kcherkashin__> How many people are there?
17:21:11 <jle`> could it also be a semifarring?
17:21:13 <codygman> jle`: why is that? Also is there a way to hide any output besides directing to /dev/null?
17:21:21 <kcherkashin__> saml_: Would it make sense to get there?
17:21:26 <jle`> codygman: just a matter of personal style
17:21:26 <saml_> many people
17:21:31 <jle`> and what do you mean hide any output?
17:21:40 <saml_> kcherkashin__, i don't know.. i came for free pizza. pizza was good
17:21:47 <jle`> does the request command generate output even aside from the handler?
17:21:51 <kcherkashin__> saml_: hahaha
17:21:52 <saml_> there are some serious projects, i think
17:21:53 <Rarrikins> > liftM2 (++) ["a", "b"] ["1", "2"]
17:21:54 <lambdabot>  ["a1","a2","b1","b2"]
17:22:32 <kcherkashin__> saml_: Got it
17:22:41 <kcherkashin__> Probably will get there tomorrow morning
17:22:41 <saml_> copumpkin, mentor me if i come tomorrow to etsy
17:22:52 <saml_> i think you're pretty experienced, right?
17:23:09 <saml_> i wanna see how you work on haskell. toolset.. etc  and some simple program
17:23:15 <saml_> unless you got projects to work on
17:23:38 <saml_> kcherkashin__, come out by 8:30pm and help them set up if you're near
17:24:04 <saml_> am, i mean
17:24:12 <kcherkashin__> saml_: It's a 30 minute commute for me
17:24:24 <saml_> they asked for a volunteer but no one volunteered
17:24:31 <saml_> that's short
17:24:52 <saml_> i think it'll take me... 1.5 hours
17:25:50 <saml_> what's monoid plus?  i did import Data.Monoid
17:25:54 <saml_> @hoogle plus
17:25:54 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
17:25:55 <lambdabot> Control.Arrow class ArrowZero a => ArrowPlus a
17:25:55 <lambdabot> Control.Monad class Monad m => MonadPlus m
17:26:20 <saml_> mappend it's called not plus
17:29:01 <dmwit> :t (<>)
17:29:02 <lambdabot> Monoid m => m -> m -> m
17:29:05 <dmwit> saml_:
17:29:57 <saml_> mappend
17:30:06 <dwcook> A thirty-minute commute sounds like entirely too long a computation – perhaps your abelian group implementation is faulty
17:30:15 <saml_> how can I import instance definitions?  I see  instance Monoid [a] where ...  in Data.Monoid
17:30:29 <dmwit> Instances are automatically, forcefully imported.
17:30:31 <saml_> i'm doing  import Data.Monoid  (Monoid, ... things I want only)
17:30:35 <dmwit> You cannot avoid importing instances.
17:30:42 <saml_> oh i see
17:31:21 <saml_> so i do  import Data.Monoid (Monoid)     in myfile.hs.   and in ghci,  :load myfile.hs.  then I don't get instance Monoid [a]
17:31:33 <saml_> mappend ["a"] ["b"]    errors out
17:32:05 <dmwit> saml_: What is the exact error?
17:32:27 <dmwit> saml_: Oh, perhaps you did not import "mappend".
17:32:33 <jle`> just import Data.Monoid
17:32:35 <saml_> yup that was it
17:33:47 * hackagebot FunGEn 0.4.3 - FUNctional Game ENgine  http://hackage.haskell.org/package/FunGEn-0.4.3 (SimonMichael)
17:33:51 <saml_> The import of `mappend' from module `Data.Monoid' is redundant
17:34:11 <saml_> so it's okay not to import mappend in my module file. but in ghci, i need to import it
17:35:45 <dmwit> Can you show us the exact file you're using?
17:37:47 <ghast> hello. anybody uses haskell-doc on emacs? it does not seem to be working for me.
17:42:34 <saml_> dmwit, https://gist.github.com/saml/9985858   :load PronounceNumber.hs   and you don't have mappend in ghci
17:42:39 <saml_> it makes sense
17:43:29 <dmwit> saml_: You also don't have mappend in that module.
17:44:02 <saml_> ah that's why ghci warned that mappend was redundant when i was included in import list
17:44:28 <dmwit> right
17:46:34 <saml_> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/  i'm trying to follow this for hackathon but too hard
17:46:46 <saml_> i'll give up in 10 minutes
17:46:55 <hiptobecubic> I thought Classing Instances like this was a frowny face?
17:48:09 <saml_> i think class Character is unnecessary
17:48:49 * hackagebot hspec-meta 1.9.1 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.9.1 (SimonHengel)
17:49:06 <Ptival> hello, is the json package usable? it seems to require two versions of parsec and barfs linker errors when loaded :(
17:49:32 <saml_> Ptival, aeson
17:50:01 <Rarrikins> Yeah, aeson
17:50:29 <saml_> http://ocharles.org.uk/blog/posts/2012-12-07-24-days-of-hackage-aeson.html
17:50:34 <saml_> Ptival, ^^
17:51:07 <saml_> okay. learned about seminearring today. took 3 hours
17:51:11 <Ptival> saml_: ok :)
17:51:31 <Ptival> thanks
17:52:02 <jle`> i wonder why there isn't a Functor instance for MVars
17:52:04 <Welkin> does anyone do iOS development in haskell?
17:53:08 <Rarrikins> Welkin: Not sure, but there's this: http://www.reddit.com/r/haskell/comments/1lboh4/announcing_ghc_ios
17:54:26 <Welkin> I know John Carmack rewrote Wolfenstein in Haskell
17:54:38 <Welkin> but I'm not sure if it's the same one that is on the iOS app store
17:55:58 <ghast> JC = God
17:56:57 <Rarrikins> ghast: FSM FTW.
17:57:15 <ghast> FSM ? finite state machine ?
17:57:17 <Welkin> haha
17:57:22 <Welkin> I read that as finite state machine
17:57:34 <Welkin> because of all those digital design classes
17:57:53 <Welkin> at first, I would think "flying spaghetti monster? what does that have to do with circuits?"
17:58:27 <ghast> oh you mean the flying spaghetti monster ...
17:58:42 <ghast> ramen
17:58:50 * hackagebot logging 1.3.0 - Simplified logging in IO for application writers.  http://hackage.haskell.org/package/logging-1.3.0 (JohnWiegley)
17:58:51 <Rarrikins> And meatballs
17:59:04 <hexagoxel_> jle`: because you can not implement fmap, because MVars are fundamentally a side-effect thingy, and fmap is pure
17:59:06 <ghast> no, really. JC is a god.
17:59:58 <pordan30> i'm attempting to install ghc 7.8rc2 and cabal 1.18.0.2 (which are the latest releases, to the best of my knowledge) on a clean system. installing cabal through the bootstrap script gives the complains: the following dependencies are missing: base >= 3 && < 4.7 (this occurs when configuring the HTTP package). i'm not really sure what i should do here.
18:02:11 <johnw> hello from NYC Hac!
18:03:00 <ghast> does anybody use haskell with emacs and haskell-doc ?
18:03:03 <sm> hello johnw!
18:03:08 <Welkin> yes ghast
18:03:28 <Welkin> I wanted to read that as "John Snow"
18:03:29 <ghast> Welkin: does it show the function prototype when you type e.g. "map" in a .hs file?
18:03:38 <Welkin> Game of Thrones season 4 starts on Sunday!
18:04:08 <Welkin> yes
18:04:13 <Welkin> it shows the type definition
18:04:23 <ghast> it does nothing for me. but i already added the hook
18:04:34 <Welkin> did you reload your .emacs file?
18:04:38 <ghast> it says "Doc" in the mode-line
18:04:58 <ghast> i started a new emacs instance, and haskell-doc is loaded. But it just does nothing
18:05:38 <Welkin> is it in haskell-mode?
18:05:39 <ghast> i get "(Haskell Ind Doc)" in the mode-line
18:05:47 <ghast> yeah
18:06:00 <Welkin> nno idea what the problem could be
18:06:12 <bitemyapp> johnw: I am jealous :)
18:06:22 <ghast> then i type, say, "map " (and leave the cursor there) waiting, and nothing happens.
18:07:08 <Welkin> it is a bit slow
18:07:23 <Welkin> but shows up in .5 to 1 second
18:07:39 <ghast> that's fine. but here nothing happens at all
18:07:59 <ghast> weird :/
18:08:10 <Galactic> is it possible to describe what a Monad is in one sentece?
18:08:33 <Welkin> emacs 24?
18:09:11 <ghast> 24.3.1
18:09:13 <Welkin> Galactic, use a car analogy
18:09:17 <AshyIsMe> Galactic: probably, but the original phillip wadler papers are really clear and easy to read
18:09:18 <Welkin> that always works
18:09:33 <ZeroCool> is this hte haskell channnel?
18:09:37 <AshyIsMe> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
18:09:39 <Welkin> at least on slashdot
18:09:51 <AshyIsMe> tell them to read from the bottom up
18:09:56 * Welkin looks at window title bar
18:09:59 <ghast> i've got this line to load the haskell-doc thingy in my config: (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
18:10:03 <Welkin> yes, this is #haskell
18:10:08 <johnw> sm: hi!
18:10:18 <ZeroCool> why you people do haskel when you can do java instead?
18:10:30 <Welkin> ghast, did you load the haskell-mode file?
18:10:59 <Welkin> ZeroCool, we will not answer non-questions
18:11:07 <ghast> haskel-mode is active. i mean, i get the syntax coloring, the indentation stuff, and all. just haskell-doc is taking a vacation
18:11:10 <bitemyapp> Welkin: named after the tactical RPG g?
18:11:30 <Welkin> bitemyapp, that is where I first heard it, yes
18:11:31 <Galactic> Welkin, AshyIsMe...thanks
18:11:38 <Welkin> but I liked the definition
18:11:45 <Welkin> archaic english for "sky/heaven"
18:12:00 <bitemyapp> Welkin: cool. I really liked that game. Wish the sequel had been on a console.
18:12:08 <Welkin> it was a fun game
18:12:26 <[swift]> yeah, it was really great
18:13:06 <milieu> @faq
18:13:06 <lambdabot> The answer is: Yes! Haskell can do that.
18:13:11 <fread2282> @pl (-) a b = a + negate b
18:13:11 <lambdabot> (line 1, column 10):
18:13:11 <lambdabot> unexpected " "
18:13:11 <lambdabot> expecting operator
18:13:18 <fread2282> @pl a - b = a + negate b
18:13:18 <lambdabot> (line 1, column 8):
18:13:18 <lambdabot> unexpected " "
18:13:18 <lambdabot> expecting operator
18:13:33 <fread2282> @help pl
18:13:33 <lambdabot> pointless <expr>. Play with pointfree code.
18:13:46 <fread2282> @pl a + negate b
18:13:47 <lambdabot> a + negate b
18:14:07 <fread2282> @pl m a b = a + negate b
18:14:07 <lambdabot> m = (. negate) . (+)
18:14:16 <ghast> Welkin: i guess i'll have to give up for the time being. thanks a lot anyway. maybe i'll find out later.
18:14:39 <Welkin> ghast, do you have the load line in your config?
18:14:55 <Rarrikins> Neat
18:15:31 <bitemyapp> [swift]: I wish they made more games that actually had a challenge to them like that.
18:15:58 <ghast> Welkin: i've got this: (require 'haskell-mode-autoloads), and then, (autoload 'turn-on-haskell-doc-mode "haskell-doc" nil t), the haskell-mode hooks (Ind and Doc)
18:16:02 <Welkin> bitemyapp, each level would take me 1-2 hours
18:16:05 <Welkin> they felt pretty epic
18:16:08 <ghast> haskell-mode loads fine when i open a .hs file
18:16:24 <Welkin> hm
18:16:32 <bitemyapp> Welkin: which is why they were so much fun. They actually required thought/effort/patience. Most games are a thoughtless romp.
18:17:53 <[swift]> to me a large part of the appeal was that every level felt like a unique puzzle. there was always some new element or tactical situation; it wasn't just more of the same but with more enemy HP like a lot of games
18:18:32 <bitemyapp> [swift]: they did a good job of forcing you to exercise each game mechanic in isolation and in concert with other things.
18:18:47 <bitemyapp> [swift]: I was kinda disappointed in how little return I got on investing in my sniper though.
18:20:19 <[swift]> yeah, ISTR that snipers usually only got a few kills for me, though they could be important in terms of thinning things out for the other troops. been a long time since i played though (maybe i should replay sometime!)
18:20:52 <TheKing> anyone here?
18:20:55 <milieu> hi
18:21:02 <Guest61854> Hello
18:21:23 <Guest61854> Do you know of a Handle that is a combination of stdin and stdout.
18:21:24 <Rarrikins> Hello.
18:21:45 <Guest61854> Namely, it receives input from stdin, and sends its output to stdout?
18:22:08 <Rarrikins> Guest61854: Yes, those are the operations without handles, like getline or whatever instead of hGetline
18:22:22 <Rarrikins> @hoogle getline
18:22:23 <lambdabot> Prelude getLine :: IO String
18:22:23 <lambdabot> System.IO getLine :: IO String
18:22:23 <lambdabot> Data.ByteString getLine :: IO ByteString
18:22:28 <Rarrikins> @hoogle hgetline
18:22:28 <lambdabot> System.IO hGetLine :: Handle -> IO String
18:22:28 <lambdabot> GHC.IO.Handle hGetLine :: Handle -> IO String
18:22:29 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
18:22:51 <geekosaur> but you can't do both with the same Handle. this is an OS restriction, not a Haskell one
18:23:15 <Guest61854> @geekosaur Sockets can do both.
18:23:15 <lambdabot> Unknown command, try @list
18:23:16 <bitemyapp> thebnq: nope.
18:24:02 <geekosaur> (note that you can do input from stdout when it's a terminal --- this is used by pagers, for example. and on *BSD a pipe is actually a socketpair --- you can, and some programs do, do both directions on them. this is NOT the same as being both stdin and stdout!
18:24:27 <Guest61854> I am testing a function that takes a handle as an argument, and want to test it from stdin and stdout, instead of with a socket.
18:24:59 <geekosaur> you may be able to get away with relying on the fact that a terminal is dup()ed
18:25:06 <geekosaur> this will NOT work if you redirect!
18:25:08 <Guest61854> *** Exception: <stdout>: hGetLine: illegal operation (handle is not open for reading)
18:25:21 <Guest61854> I am doing it from ghci by the way.
18:25:24 <Guest61854> Since it is just testing.
18:25:49 <geekosaur> oh, hm, it does that. if you can promise that it's a terminal on a unixlike, you can open /dev/tty for read-write
18:26:50 <geekosaur> it might be nice to be able to ask the runtime to pass through the r/w-ness of a terminal... but you can't easily (and portably!) *determine* that it's actually open that way
18:27:53 <Rarrikins> Guest61854: You might be able to somehow work out how to make a Handle for stdin/stdout. http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-IO-Handle-Types.html#Handle
18:27:57 <geekosaur> and you can't just assume it is because there are lots of cases where it is not
18:31:38 <Guest61854>  /dev/tty worked thx
18:32:07 <Guest61854> And there is a bug in my code. Great.
18:32:21 <Guest61854> Well, see ya. I will look into merging handles then.
18:33:07 <Welkin> [swift], I remember sneaking around buildings to blow up tanks
18:37:48 <Zekka> Just wanted to pop in and say Haskell just made my day great: really hard problem in C# just became trivial now that I'm working in Haskell
18:38:02 <Zekka> well, not quite trivial, but I'm not suffering any more and I expected to be suffering
18:42:59 <bitemyapp> Zekka: awesome, hope you're having fun :)
18:43:18 <bitemyapp> Zekka: I'm writing a client for a search service in Haskell and the first time I fired off a request, it worked! :)
18:43:27 <Zekka> Yeah, I've been getting a lot of 'works on first compile' lately
18:43:58 <Zekka> I haven't even tried to compile this yet aside from a small test program, but I've got a pretty clear strategy in mind to implement it and I'd be surprised if I ended up in an impossible situation
18:45:52 <Zekka> There's not a type for 'lists, but with at least one member', is there?
18:45:59 <bitemyapp> Zekka: there is actually
18:46:11 <Zekka> bitemyapp - What's it called?
18:46:11 <bitemyapp> Zekka: but I don't...totally understand the point of it.
18:46:28 <bitemyapp> Zekka: I prefer to use the safe prelude instead of the aforementioned type, but let me track it down.
18:46:37 <Zekka> In my case I'm trying to define a type with a 'current version' accessor
18:46:39 <Welkin> for a singleton?
18:46:45 <Welkin> oh
18:46:48 <Welkin> "at least"
18:46:54 <Zekka> there always needs to be at least one element in the list, but whatever it grabs will be the head of the list
18:47:15 <Zekka> So you can cons something new onto the back of it to add a new version
18:47:15 <Welkin> why not just use Maybe?
18:47:27 <bitemyapp> Zekka: I really think you just want the Safe Prelude.
18:47:45 <Zekka> bitemyapp - I think I know what it does and I'm not sure I agree, do you mind if I write up an example?
18:48:11 <bitemyapp> Zekka: http://hackage.haskell.org/package/semigroups
18:48:23 <bitemyapp> Zekka: a semigroup has no concept of "empty"
18:48:31 <bitemyapp> Zekka: also: http://hackage.haskell.org/package/non-empty
18:48:49 <bitemyapp> Zekka: if you want to dig into cardinality as a general concept instead of a one-off "one or more": http://hackage.haskell.org/package/Cardinality
18:49:02 <bitemyapp> Zekka: specific to your request, but I still kinda groan at it: http://hackage.haskell.org/package/NonEmptyList
18:49:21 <Zekka> bitemyapp - I strongly suspect there's a better solution to my problem, but let me write up an explanation and we'll see
18:49:26 <bitemyapp> Haskell: we got everything
18:49:35 <bitemyapp> Zekka: well, what I listed above covers a lot of territory.
18:49:50 <bitemyapp> Zekka: but yeah, if you lpaste a description that more thoroughly covers what you're doing, we can be more specific.
18:52:16 <zenkeku> I am using haskell-mode with emacs. When I try to run the function "inferior-haskell-load-file" emacs just hangs.
18:52:26 <zenkeku> Has anyone else experienced this problem?
18:53:53 <bitemyapp> is there a way to get a generic encoding of Nothing from Maybe a to result in elision of the field rather than assignment to Null?
18:54:00 <Zekka> Bitemyapp: In your infinite wisdom, what should I have defined here? http://lpaste.net/102275
18:54:28 <Zekka> You can probably see tha the definition for Alterable looks a *lot* like the definition for list, only instead of ending in an empty node, it ends in a node containing one of the list's type
18:54:51 <bitemyapp> Zekka: I'm sorry if I frustrated you at all, it's just that if somebody doesn't want the non-determinism of lists, they sometimes don't want lists or they want to lift the non-determinism into the type system somehow.
18:55:08 <Zekka> You can probably see that I'm using this to keep a 'version history' of changes to an object so I can freely undo them
18:55:18 <bitemyapp> Zekka: but there's always a base state right?
18:55:26 <Zekka> It's fine: I just wanted to establish before too many recommndations were made what my usecase actually was
18:55:34 <Zekka> because I figured 'nonempty list' was a common request by people who don't actually need one
18:55:47 <Zekka> bitemyapp - Right, there's no 'empty' node
18:56:20 <bitemyapp> Zekka: ordinarily yeah, there are better options than non-empty list. I'd say you actually have multiple good options here.
18:56:47 <bitemyapp> Zekka: you can do a free monadic/listy encoding where you can terminate in a base value but never "nothing"
18:56:59 <bitemyapp> Zekka: you can straight-up use non-empty list
18:57:00 <Zekka> Oh, the second definition of 'alter' should be 'alter f (Original a) = Altered (f a) (Original a)', by the way
18:57:14 <bitemyapp> Zekka: just edit and repost link please.
18:57:26 <Zekka> Oh, right, one moment
18:57:54 <Zekka> Corrected version: http://lpaste.net/102275
18:58:27 <bitemyapp> Zekka: wise choice to record history and make it an append-only log btw.
18:58:39 <Zekka> I'm confused, how would I use a free monad here? Maybe it's just that I don't have a strong intuition for what it does.
18:58:44 <Zekka> bitemyapp - What would the alternative be?
18:58:58 <Zekka> that is, to making it cons-only?
18:59:47 <bitemyapp> Zekka: lets not go down that rabbit-hole, suffice to say, it's a good idea to model state transitions as appends to a log.
19:00:25 <Zekka> I just needed to do time travel here and I didn't want to have to write an inverse operation for every function I could apply to my 'a's
19:00:32 <Zekka> it seemed wasteful if I just wanted to reverse an operation
19:00:49 <bitemyapp> Zekka: free monadic interface would give you a transformable DSL that's independent of the implementation. It's not all that important.
19:01:15 <bitemyapp> from tekmo's blog: data Free f r = Free (f (Free f r)) | Pure r
19:01:56 <bitemyapp> Zekka: so you've got an AST of functors and terminal values.
19:02:04 <Zekka> Yeah, that's the definition I remember -- I've heard it basically described as a linkedlist that uses a functor of a reference to a node instead of a direct reference to a node
19:02:17 <Zekka> so for Free Identity, you've got a linkedlist, while for Free [] you've got a tree
19:02:17 <bitemyapp> Zekka: anyway, that aside, you can probably get away with non-empty list. I don't know that it wins you much.
19:02:40 <Welkin> Zekka, what is the application for this data type?
19:02:46 <bitemyapp> Zekka: the only reason empty lists are a "thing" is that when you recurse you eventually reach the "end" and need some way to signify that.
19:03:14 <bitemyapp> Zekka: so just using Maybe oriented Prelude-y functions would avoid partial functions/mistakes, but none of this seems especially hard.
19:03:35 <Zekka> Welkin - I'm writing some software which will, on occasion, need to modify some data of a particular type temporarily with an arbitrary function (a -> b)
19:03:44 <Zekka> er, a -> a
19:03:59 <Zekka> When the occasion ends, I need to unmodify it
19:04:01 <Welkin> you can't just keep the old value on the stack?
19:04:18 <Zekka> I'm confused, isn't the type I defined basically just a stack of old values?
19:04:51 <Welkin> well, the call stack
19:05:17 <Zekka> Oh, I see what you mean: I don't have any guarantee that the occasion will end while I have access to the old value
19:05:54 <Zekka> I'm using a custom event system which, among other things, can say, 'OK: something just happened - mutate everything in the current state value (I'm under State) with time travel'
19:05:57 <bitemyapp> Welkin: one reason for wanting this interface is wanting to fold/comprehend the history.
19:06:07 <Zekka> and then, when another event triggers, it can respond 'Oh, we're done here: unmutate everything'
19:06:30 <Zekka> I'm going to be defining a couple higher-order functions that manage flow here so there's not much risk of pushing once and popping twice or pushing twice and popping once, or anything like that
19:06:48 <Zekka> It's unlikely I'll actually need to operate on the history beyond using the 'alter' and 'unalter' functions I described
19:10:34 <bitemyapp> Zekka: there's a Data.List.NonEmpty module in the semigroups package btw.
19:10:43 <bitemyapp> Zekka: look it over and see if the types make you happy: http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-List-NonEmpty.html
19:10:51 <Zekka> bitemyapp - One sec, I'll look
19:10:52 <bitemyapp> and no, I have no idea how tail works.
19:11:17 <Zekka> bitemyapp - Guessing it dies like tail []?
19:11:20 <bitemyapp> I mean, it returns a list, so basically when you ask for list semantics you lose the deterministic guarantee.
19:11:28 <bitemyapp> Zekka: no, I think the -> [a] covers it.
19:11:32 <Zekka> Wait, it returns a list?
19:11:39 <bitemyapp> Zekka: look at the API.
19:11:42 <Zekka> That's strange, I wonder why.
19:11:47 <bitemyapp> Zekka: you'll be able to see where you get to keep NonEmpty and where you don't.
19:11:55 <bitemyapp> the latter is because you're breaking the guarantee.
19:11:58 <bitemyapp> You'll see.
19:16:00 <Galactic> > let x = 1 + 2; :sprint x
19:16:01 <lambdabot>  <hint>:1:16: parse error on input `:'
19:16:20 <Galactic> > let x = 1 + 2; sprint x
19:16:22 <lambdabot>  <hint>:1:24:
19:16:22 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:16:32 <roconnor> > let x = 1 + 2 in sprint x
19:16:34 <lambdabot>  Not in scope: `sprint'
19:16:34 <lambdabot>  Perhaps you meant one of these:
19:16:34 <lambdabot>    `print' (imported from Prelude),
19:16:34 <lambdabot>    `BS.split' (imported from Data.ByteString),
19:16:34 <lambdabot>    `BSL.split' (imported from Data.ByteString.Lazy)
19:16:47 <roconnor> > let x = 1 + 2 in show x
19:16:48 <lambdabot>  "3"
19:16:54 <Galactic> sprint x
19:16:59 <Galactic> > sprint x
19:17:01 <lambdabot>  Not in scope: `sprint'
19:17:01 <lambdabot>  Perhaps you meant one of these:
19:17:01 <lambdabot>    `print' (imported from Prelude),
19:17:01 <lambdabot>    `BS.split' (imported from Data.ByteString),
19:17:01 <lambdabot>    `BSL.split' (imported from Data.ByteString.Lazy)
19:17:13 <Galactic> > :sprint x
19:17:14 <lambdabot>  <hint>:1:1: parse error on input `:'
19:17:19 <Galactic> bah
19:17:28 <roconnor> Galactic: I'm not sure what you thin sprint is
19:17:56 <Zekka> I think he might want print
19:18:07 <Zekka> > let x = 1 + 2 in print x
19:18:09 <lambdabot>  <IO ()>
19:18:17 <Zekka> (Although I doubt he wanted that)
19:18:26 <roconnor> sprint sounds like string-print.
19:18:39 <roconnor> which would roughly be show in Haskell.
19:18:57 <Zekka> That's what I thought you meant except you didn't seem satisfied by show
19:19:26 <roconnor> indeed.
19:20:33 <Galactic> yea I am reading a book that they do: let x = 1 + 3 and then they do :sprint x  and it shows  x = _     which shows lazy evaluation
19:21:30 <roconnor> Galactic: probably only works in ghci.
19:22:11 <tsou> Galactic: :sprint is not a function of haskell, it's a command for ghci
19:22:41 <tsou> Galactic: just like you use :t for example to check the type of an expression..
19:23:08 <Galactic> yea, I though that lambdabot would recognize it.
19:23:20 <Galactic> just like :t
19:23:56 <hunt> If i have a :: [a] -> [a] -> [[a]], and b :: [[a]] -> b, why cant i have c = b . a, and then c :: [a] -> [a] -> b?
19:24:46 <Zekka> hunt - Because b doesn't take an ([a] -> [[a]]), but an [[a]]?
19:24:46 <hunt> it seems like it should work
19:24:47 <roconnor> hunt: you need to write (b .) . a
19:24:59 <Zekka> Write what roconnor suggested to compose two arguments in
19:25:18 <hunt> roconnor whoa whoa whoa can you explain that to me, i dont understand how i should read that
19:25:20 <edwardk> or if you are alergic to sections fmap b . a
19:25:23 <edwardk> er allergic
19:25:23 <roconnor> hunt: it is worth trying the unification by hand on b . a to understand why it doesn't work.
19:25:57 <roconnor> hunt: important [a] -> [a] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a means [a] -> ([a] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a)
19:26:00 <roconnor> gah
19:26:09 <roconnor> konversation!!!
19:26:42 <roconnor> hunt: important [a] -> [a] -> [ [a] ] means [a] -> ([a] -> [ [a] ])
19:26:55 <hunt> so am i to understand that using double (.) allows me eto compose a function a -> b -> c with c -> d
19:27:10 <hunt> because double (.) takes a function that takes another arg?
19:27:22 <bitemyapp> :t concat
19:27:23 <lambdabot> [[a]] -> [a]
19:27:24 <bitemyapp> :t map
19:27:25 <lambdabot> (a -> b) -> [a] -> [b]
19:27:26 <edwardk> :t (.).(.)
19:27:27 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:27:27 <bitemyapp> :t (concat .)
19:27:28 <lambdabot> (a -> [[a1]]) -> a -> [a1]
19:27:35 <bitemyapp> :t (concat .) . map
19:27:36 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
19:27:43 <bitemyapp> :t concat . map
19:27:44 <lambdabot>     Couldn't match type `[a1] -> [b0]' with `[[a0]]'
19:27:44 <lambdabot>     Expected type: (a1 -> b0) -> [[a0]]
19:27:44 <lambdabot>       Actual type: (a1 -> b0) -> [a1] -> [b0]
19:27:48 <bitemyapp> hunt: ding ding ^^
19:27:49 <edwardk> :t fmap.fmap
19:27:50 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:28:58 <edwardk> these patterns keep going. fmap.fmap.fmap lets you get under 3 functors.  for functions fmap = (.)   so (.).(.) lets you get under two functions
19:30:01 <bitemyapp> > (fmap.fmap) (+1) [[1]]
19:30:02 <lambdabot>  [[2]]
19:30:09 <bitemyapp> > (fmap.fmap.fmap) (+1) [[[1]]]
19:30:11 <lambdabot>  [[[2]]]
19:30:23 <bitemyapp> turtles all the way down yo.
19:30:24 <Zekka> > :t fmap
19:30:26 <lambdabot>  <hint>:1:1: parse error on input `:'
19:30:27 <hunt> how does haskell infer for (concat .) . map that the function has to return a list?
19:30:29 <roconnor> edwardk: do you guys use nix at your job?
19:30:29 <hunt> bitemyapp
19:30:29 <bitemyapp> :t fmap
19:30:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:30:32 <Zekka> Oh, right
19:30:32 <bitemyapp> Zekka: it doesn't like you.
19:30:36 <edwardk> if you keep playing with this pattern then one of three things happens: 1.) you throw it away as a nice toy. 2.) your head explodes 3.) you write a lens library
19:30:45 <bitemyapp> hahahahaha ^^ yissss
19:30:46 <edwardk> roconnor: unix or nix?
19:30:54 <roconnor> nix
19:31:03 <edwardk> no nix in sight
19:31:11 <roconnor> edwardk: lol re 3.)
19:31:14 <bitemyapp> hunt: concat and map are expressly about lists. If you want something more generic, then you want join and fmap/liftM
19:31:18 <bitemyapp> :t concat
19:31:20 <lambdabot> [[a]] -> [a]
19:31:22 <bitemyapp> see? lists.
19:31:28 <bitemyapp> :t (.)
19:31:29 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:31:34 <Zekka> concat is join over lists and map is fmap over lists
19:31:35 <bitemyapp> :t (concat .)
19:31:36 <lambdabot> (a -> [[a1]]) -> a -> [a1]
19:31:38 <roconnor> edwardk: but haskell yes?
19:31:53 <bitemyapp> Zekka: concat should've been named "smush"
19:32:03 <bitemyapp> oh well.
19:32:08 <edwardk> roconnor: haskell is slowly slipping into the ecosystem here. more ermine right now though.
19:32:09 <hunt> ah ok
19:32:40 <ak3n> Hi. Is there an analogue of virtualenvwrapper, but for cabal sandboxes?
19:32:46 <edwardk> we have a better jvm integration story on the ermine front, so its a lot easier to sell
19:32:54 <roconnor> edwardk: oh right.
19:33:40 <edwardk> the new ermine compiler we're building up over on #ermine is written in haskell though, so we'll see how well that works as a spearhead ;)
19:34:42 <roconnor> is it open source??
19:34:45 <edwardk> yes
19:34:59 <edwardk> and the compiler is lensified all the way down
19:35:01 <edwardk> =)
19:35:14 <roconnor> edwardk: what's the sales pitch vs scala?
19:35:17 <edwardk> http://ermine-language.github.io/ermine/
19:35:29 <edwardk> roconnor: it isn't scala. done. pitch over.
19:36:26 <edwardk> ermine isn't trying to be scala. scala slavishly adheres to the java stack, etc. ermine is a non-strict language that basically runs a spineless tagless g-machine.
19:36:29 <roconnor> so a functional language that isn't scala that runs on the JVM?
19:36:44 <roconnor> oh, it isn't strict.
19:36:58 <edwardk> the goal with the new compiler is to keep it the core pretty portable so you can run interpreters pretty much anywhere
19:37:22 <roconnor> edwardk: Haskell on the JVM?
19:37:36 <edwardk> the surface language is lazy, the core we go through as 4 application types, 3 of them are strict though ;)
19:38:10 <edwardk> roconnor: its not trying to be haskell, but we are doing real typeclasses, rank-n types, polykinds
19:38:23 <roconnor> I have a vague desire to write an experimental language; and I'm thinking I should be ripping off an existing langauge.
19:38:32 <roconnor> real typeclasses?
19:38:40 <edwardk> yeah, real typeclasses
19:38:49 <bitemyapp> what's an irreal typeclass?
19:38:49 <roconnor> what does that mean?
19:38:57 <edwardk> coherent instance resolution, etc =)
19:39:02 <bitemyapp> ahhh :)
19:39:03 <edwardk> bitemyapp: scala calls them implicits ;)
19:39:13 <bitemyapp> edwardk: oh, that garbage.
19:39:19 * bitemyapp grumbles
19:40:09 <roboguy__> edwardk: so it works with incoherent instances?
19:40:28 <edwardk> roboguy__: scala doesn't have a coherent notion of coherence ;)
19:42:05 <roboguy__> edwardk: what's the goal of ermine?
19:42:43 <edwardk> roboguy__: we use it to make it easy to generate tons of pretty reports on lots of backends mostly. i gave a talk. let me see.
19:43:02 <edwardk> https://www.youtube.com/watch?v=o3m2NkusI9k
19:43:15 <roboguy__> edwardk: thanks!
19:49:15 <hunt> im not sure what to do with this error
19:49:26 <roconnor> @paste
19:49:26 <lambdabot> Haskell pastebin: http://lpaste.net/
19:49:28 <hunt> im being told two types could not be matched because the resultant type would escape its scope
19:49:39 <hunt> i dont understand the meaning
19:49:49 <hunt> of this error
19:50:45 <roconnor> hunt: it's a error caued by GADTs (or existental types) I think.
19:51:06 <hunt> well, in my situation i have a function that needs to generate some lists
19:51:06 <Zekka> hunt - What kind of code were you writing?
19:51:20 <roconnor> hunt: this error doesn't occur in standard Haskell.
19:51:29 <hunt> im in standard haskell though!
19:51:53 <pavonia> Paste an examples, please
19:51:57 <pavonia> -s
19:52:05 <roconnor> @paste
19:52:06 <lambdabot> Haskell pastebin: http://lpaste.net/
19:52:06 <edwardk> roboguy__: anyways most of what we do with ermine is program inside of EDSLs inside of it for working with relational data, generating reports, etc. and then expose those DSLs so that other teams can use them. Makes it easy for other groups to make sexy looking reports that are very configurable out of reusable bits and pieces
19:53:57 <hunt> anyways: my code generates the initial data as an unspecified member of a matrix typeclass, then performs a bunch of matrix multiplications and then converts all the matrices to lists and returns the lists. I lose the type here. http://lpaste.net/102277
19:54:39 <hunt> transpose' is the same as Data.List transpose
19:55:31 <hunt> oh sorry, the error: http://lpaste.net/102278
19:55:40 <pavonia> Does it work if you remove the type signature of getTriangles?
19:55:43 <hunt> Zekka, roconner
19:56:09 <hunt> pavonia, probably not, i include that there to try and avoid losing the type of the intermittent matrix
19:57:09 <pavonia> I guess you need -XScopedTypeVariables then
19:57:41 <startling> Is there a Constraint that applies to every type?
19:57:44 <hunt> :/ i think this should be possible without, i solved a similar version of this problem earlier, although that solution now gives me existential errors or w.e.
19:58:37 <pavonia> You can also fiddle with asTypeOf
19:59:10 <roboguy__> startling: would the empty constraint work, or does it need to actually constraint a type?
20:00:40 <c_wraith> startling: () :: Constraint is valid and can be applied to every type, but GHC just throws it away immediately
20:00:59 <c_wraith> startling: like, it doesn't even keep it in the pretty-printer
20:01:04 <startling> I've got an "associated type" of kind Constraint in a typeclass; I want to say that this instance doesn't rely on it being anything
20:01:10 <startling> c_wraith: ooh, that might work
20:01:13 <c_wraith> then yeah, set it to ()
20:01:38 <hunt> so wait theres no way to get around this error?
20:01:45 <hunt> can anyone at least explain to me what it means
20:01:45 <hunt> ?
20:01:57 <c_wraith> startling: by the way, that's what roboguy__ was talking about. :)
20:02:04 <c_wraith> (I think)
20:02:14 <roboguy__> yep!
20:02:52 <roboguy__> I always wondered where that would actually be useful...
20:02:55 <pavonia> hunt: I think the problem is that the m's in both type signatures are not necessarly the same
20:03:23 <hunt> pavonia: doesnt my use of :: force them to be
20:03:35 <roboguy__> hunt: no. ScopedTypeVariables would though
20:03:37 <hunt> i thought i was telling haskell use the same for both
20:03:46 <roboguy__> (that's what ScopedTypeVariables does)
20:03:59 <hunt> well, look at this code that works and avoids this issue (despite doing the same thing)
20:04:28 <hunt> http://lpaste.net/102280
20:04:29 <roconnor> hunt: the m in genTriangles is a new fresh type variable that is unrelated to the top level type.
20:04:50 <hunt> connectArcs uses a similar trick to try and avoid this issue, and it works
20:04:52 <roconnor> hunt: you should give it a fresh name as to not confuse yourself.
20:04:59 <roboguy__> it's sort of like how in the function "\x -> \x -> x", the "x" in the body refers to the second x
20:05:16 <yogert> I'm having trouble with monad transformers and database.persistent. I think I'm almost there, but I don't quite understand the types…. http://lpaste.net/102279
20:06:08 <roconnor> hunt: same goes for connectArcs; you should use a fresh name to not confuse yourself.
20:06:27 <roboguy__> hunt: connectArcs probably doesn't need m to be the same. try taking connectArcs out of sphere for the moment to see if it still works
20:06:34 <roconnor> hunt: the only reason connectArcs works, is that in that case connectArcs is actually polymorphicly independent of the top level definition.
20:07:20 <hunt> roconnor:im sorry im not sure what you mean by polymorphically independant
20:07:37 <hunt> roboguy__ i only added the typedef because the types were lost in transit for that function
20:07:50 <roboguy__> hunt: ?
20:08:22 <roboguy__> I mean try taking connectArcs out of the "where" and put it at the top level (temporarily) and see if it still works (it should)
20:08:27 <roconnor> hunt: I mean that you can write connectAcrs :: (Matrix n) => [n Float] -> [n Float] and the whole thing typechecks.
20:09:07 <hunt> so genTriangles would fail outside of the where clause as well? rocononor
20:09:20 <hunt> or sorry, as well as inside
20:09:35 <roboguy__> unless you have ScopedTypeVariables, yeah
20:09:44 <roboguy__> well, it would *definitely* fail outside
20:09:49 <hunt> roboguy__ alright, i suppose ill work on a version from the top level
20:10:00 <hunt> honestly i feel like i lose so much haskell ability so easily
20:10:11 <roboguy__> you should leave it in the where clause, but just enable ScopedTypeVariables
20:10:29 <hunt> roboguy__ im hesitant to add extensions, i think i should be able to solve this without
20:10:32 <roboguy__> that will ensure that the two "m"s are the same
20:10:38 <roboguy__> hunt: why?
20:10:46 <roconnor> hunt: This is actually one of the few moderate problems with the haskell language: not having Scoped Typed Variables as part of the standard.
20:10:57 <roboguy__> people use extensions all the time and ScopedTypeVariables is a very very common one that has good support
20:11:33 <roconnor> hunt: With a lot of effort you can work around the issue, but you will have to remove the type signature in the where clause.
20:11:40 <roboguy__> roconnor: yeah, it should be on by default, but you should be able to turn it off. that would be nicer
20:11:46 <hunt> roboguy__ im not against extensions when i need them, but im not convinced i need it yet
20:12:13 <hunt> roconnor: hopefully effort that is constructive towards not being a shitty haskell programmer?
20:12:15 <roboguy__> hunt: the other possibility is removing the type signature (which may or may not help)
20:12:28 <roconnor> hunt: the work around is to remove the type signature from the where clause and write rediculous unused where expressions to constrain the types of things.
20:12:45 <hunt> why would removing the type signature help
20:13:23 <roconnor> hunt: because Haskell subexpressions sometypes have inferable types that cannot be denoted in Standard Haskell.
20:13:24 <roboguy__> hunt: the type signature as it stands right now (without extensions) says that you are using an "m" that is different from the first "m"
20:13:53 <hunt> the first m being toplevel m?
20:13:56 <ThatTreeOverTher> does anyone know why my wxHaskell app crashes with "./bin: error while loading shared libraries: libwx_gtk2u_xrc-2.9.so.4: cannot open shared object file: No such file or directory"
20:14:07 <roboguy__> hunt: yeah
20:14:39 <roboguy__> ThatTreeOverTher: do you have wxwindows and gtk installed?
20:15:01 <roconnor> hunt: I'm sorry you had to bump into this language wart so early.
20:15:03 <hunt> i dont understand really why this function fails at top level, it doesnt seem dependant on anything im not supplying it
20:15:20 <hunt> roconnor: yea, oh well though i can work through it
20:15:33 <roconnor> hunt: I've only hit the issue once or twice in my life.
20:15:44 <hunt> haha ive hit it twice this week
20:15:45 <roboguy__> hunt: the type signature for genTriangles is the same as if you wrote something like genTriangles :: (Matrix a) => [a Float] -> [[a Float]]
20:16:06 <ThatTreeOverTher> roboguy__, I have GTK installed and compiled WxWidgets 2.9 manually on Arch Linux
20:16:15 <roboguy__> in both cases, the Matrix constraint of genTriangles is totally separate from the top-level function
20:16:24 <hunt> and yet it cannot exist no matter where it is? to me that looks fine roboguy__
20:16:36 <roboguy__> ThatTreeOverTher: hmm, I'm afraid that's all the help I can be...
20:16:36 <hunt> even if I write genTriangles as its own toplevel function, it fails
20:17:05 <roconnor> hunt: with a simpler error?
20:17:16 <hunt> roconnor: same scope error
20:17:33 <roconnor> ???
20:17:39 <hunt> roconnor: do either of you see anything wrong with this code? its blowing my mind
20:18:01 <hunt> roconnor: about m escaping scope, its the same one i pasted earlier
20:18:05 <roconnor> maybe something more complicated is going on than I imagined.
20:18:20 <hunt> http://lpaste.net/102278
20:18:45 <hunt> i really can't comprehend this bug at all
20:19:03 <hunt> what else can I provide you guys to help? this is beyond my haskell knowledge
20:19:20 <roboguy__> hunt: what is the rest of the code?
20:19:22 <copumpkin> hunt: without the code, it's hard
20:19:33 <hunt> you want the entire source? how much code do you want to see?
20:19:45 <roconnor> hunt: can you write top level definitions for genTriangles, tiangleArcs, and zipTri and give them all top level type signatures that you think they should have?
20:19:47 <copumpkin> the smallest thing that would fail in the sam way :)
20:19:50 <copumpkin> would be ideal
20:20:01 <hunt> ok sure i will
20:20:03 <hunt> brb
20:20:34 <roboguy__> it's a little weird that the type checker is choosing the name f0
20:20:41 <roboguy__> that's weird to me, anyway
20:20:45 <pavonia> ThatTreeOverTher: Do you have enabled shared object support when compiling wx?
20:20:51 <ThatTreeOverTher> pavonia, what does that mean
20:21:23 <pavonia> Maybe I'm completely wrong, but can't you compile to either static or dynamic libraries?
20:21:38 <ThatTreeOverTher> sure, which should I compile to?
20:21:45 <pavonia> dynamic
20:22:01 <ThatTreeOverTher> I'm pretty sure that's the default
20:22:08 <pavonia> Ah, okay
20:22:21 <roboguy__> hunt: by the way, using tabs with haskell is probably a bad idea unless you're really used to how to line things up with tabs and spaces (you can make no assumptions about tab width when you do this). it's generally easier to just use spaces
20:24:40 <pavonia> ThatTreeOverTher: "libwx_gtk2u_xrc-2.9.so.4" <-- that 'u' in there make me suspicious. I recall having some issues when compiling gtk or wx once where there were different flags which lead to different letter combinations in the file names
20:25:10 <pavonia> ThatTreeOverTher: Could you check if you have files with names similar to that one?
20:25:39 <ThatTreeOverTher> what folders do I check?
20:25:53 <hunt> WTF
20:25:54 <hunt> guys wtf
20:26:00 <hunt> after I added the type definitions
20:26:06 <hunt> the error dissapeared....
20:26:10 <hunt> thats almost frustrating
20:26:19 <hunt> because I dont understand
20:26:22 <roboguy__> you were missing type signatures?
20:26:27 <roboguy__> that's usually a bad thing
20:26:35 <hunt> the where functions
20:26:41 <hunt> you asked for me to add type signatures to
20:26:42 <ThatTreeOverTher> pavonia, what folders do I check?
20:26:48 <hunt> the type signatures cleaned it up
20:26:56 <hunt> but, if i add it back into where itll fail
20:26:57 <pavonia> ThatTreeOverTher: Uh, don't know, the standard installation directory :p
20:28:09 <hunt> i wish I understood what had happenned
20:28:12 <hunt> curse you haskell
20:28:28 <roboguy__> well, what specifically did you do?
20:28:39 <roboguy__> the code you showed us already had type signatures
20:29:07 <roboguy__> for the function in the error anyway
20:29:56 <roconnor_> did anyone see polymorphic recursion in hunt's code?  That is the one of the few cases I know where type signatures are really needed
20:30:04 <roconnor_> but I didn't notice anything fancy like that going on.
20:30:30 <ThatTreeOverTher> pavonia, it seems I have those files in /usr/local/lib, but wxhaskell / ghc just don't feel like loading them?
20:31:02 <pavonia> Maybe it's not in your path
20:31:16 <ThatTreeOverTher> how do I add them to my path?
20:31:44 <geekosaur> uh
20:31:53 <geekosaur> shared objects don't go in $PATH
20:32:41 <geekosaur> if you have a wx installed under /usr/local then you probably need to tell cabal something like --extra-lib-dirs=/usr/local/lib
20:32:58 <geekosaur> and possible --extra-include-dirs=/usr/local/include
20:33:32 <hunt> roconnor_ i pulled out the other functions from where and gave them type signatures, the working final code is http://lpaste.net/102281
20:34:05 <hunt> roconnor_ origninal was http://lpaste.net/102277
20:34:08 * hackagebot eternal 0.0.4 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.0.4 (Heather)
20:34:31 <roconnor_> what are typical instances of Matrix?
20:35:15 <roboguy__> hunt: that's not really a minimal example of the problem, since it doesn't compile for other reasons (Matrix isn't in scope, etc)
20:35:35 <ThatTreeOverTher> geekosaur, I did "cabal install wx --reinstall --extra-lib-dirs=/usr/local/lib --extra-include-dirs=/usr/local/include" and rebuilt my executable, same error
20:35:46 <dolio> roconnor_, hunt: The culprit is triangleArcs.
20:35:53 <dolio> It's subject to the monomorphism restriction.
20:36:07 <dolio> But then genTriangles is declared to be polymorphic.
20:36:43 <hunt> dolio: why is it monomorphic by default?
20:36:46 * geekosaur scans back through channel log
20:37:00 <roconnor_> arg  Monomorphism restriction!!
20:37:03 <geekosaur> first question is, what does `ldd ./bin` tell you?
20:37:04 <dolio> It's of the form 'f = ...' and it has a type with a type class in it.
20:37:09 <roboguy__> hunt: if you don't give a polymorphic function a signature, ghc sometimes makes it monomorphic
20:37:20 <geekosaur> second would be, output of `grep /usr/local /etc/ld.so.conf`
20:37:21 <roboguy__> there is a good reason for this, but it can cause problems sometimes
20:37:28 <hunt> ahhhhhhhh!!
20:37:31 <roconnor_> we all lose at the Haskell game ... except dolio
20:37:34 <dolio> :)
20:37:43 <hunt> congrats dolio
20:38:00 <dolio> I probably wouldn't have gotten it until you mentioned that type signatures fixed it.
20:38:19 <roboguy__> the moral is always give an explicit type signature to polymorphic functions
20:38:22 <ThatTreeOverTher> geekosaur, ldd ./bin produces http://lpaste.net/102283
20:38:22 <roconnor_> eta-expanding it would also fix it.
20:38:35 <hunt> ive never had this happen before, also what is eta-expanding
20:38:37 <roconnor_> did the MMR get removed in Hakell 2010?
20:38:50 <geekosaur> roconnor_, no
20:39:00 <ThatTreeOverTher> geekosaur, `grep /usr/local /etc/ld.so.conf` produces nothing
20:39:05 <roconnor_> hunt: in this case I mean replacing foo = expr with foo x = expr x
20:39:09 <roboguy__> hunt: the opposite of eta-reduction. eta-expansion would be turning f x = g (h x) into f x y = g (h x) y
20:39:18 <roconnor_> hunt: literally eta-expansion means replacing f with (\x -> f x)
20:39:34 <ThatTreeOverTher> geekosaur, this is what I get when trying to load GHCi with WX: http://lpaste.net/102282
20:39:39 <geekosaur> ThatCantBe, that's your problem then
20:40:03 <geekosaur> edit (as root) /etc/ld.so.conf, add /usr/local/lib to it, then (still as root) run ldconfig
20:40:11 <geekosaur> then try the ldd thing again
20:40:19 <jrm> I've just gotten haskell-mode in Emacs up and running for the first time.  Is there a way to send the current line (or region) to GHCi in the *haskell* buffer like with ESS/R?  I only see C-c C-b to start (and switch to) the interpreter and C-c C-l to send the hole file.
20:40:41 <jrm> s/hole/whole/
20:40:50 <geekosaur> er. ThatTreeOverTher
20:40:55 <geekosaur> wrong completion :/
20:41:42 <roconnor_> It took me 5 years I think to understand the monomorphism restriction.
20:42:17 <hunt> roconnor_ 5 years is a really long time
20:42:18 <geekosaur> another possible way to deal with this might be to find some way to force -rpath to be sent to ld when building wx-related stuff (wx-config should really be doing that itself, though)
20:42:20 <roboguy__> I think I understand about half of the reasoning behind it
20:42:32 <ThatTreeOverTher> geekosaur, I amended /etc/ld.so.conf to contain the line "include /usr/local/lib", but I still get not found errors from ldd after a `sudo ldconfig`
20:42:38 <hunt> i dont even understand the premise of it really
20:42:38 <geekosaur> no "include"
20:42:49 <geekosaur> if you looked at it, it's just a list of directories
20:42:58 <roboguy__> hunt: sometimes a type that is overly polymorphic can cause a huge performance slowdown
20:43:01 <geekosaur> why did you think you needed "include "?
20:43:05 <roconnor_> hunt: well it hits so rarely and so mysteriously.
20:43:40 <ThatTreeOverTher> geekosaur, the only line in the file that wasn't commented out read "include /etc/ld.so.conf.d/*.conf" so I thought "hey I guess I'll follow the pattern"
20:43:46 <geekosaur> oh
20:43:51 <roboguy__> hunt: it can be easy to accidentally define something without a type signature that is more polymorphic than you need, thus incurring the big slowdown
20:44:02 <roboguy__> that's at least part of the reason behind it
20:44:02 <ThatTreeOverTher> geekosaur, it seems to fill in all the libraries now though
20:44:02 <geekosaur> so they subdirectory-ized it. that's a bit different then
20:44:08 <roconnor_> hunt: the premise is so that you (apparenly) don't expect where x = 2 + 2 to make x polymorphic and repeatedly evaluated.
20:44:25 <ThatTreeOverTher> geekosaur, I got a Hello World! thanks
20:44:32 <hunt_____> i guess i also dont quite understand polymorphism
20:44:39 <geekosaur> you can do it that way, or you can add a file containing only "/usr/local/lib" (without the quotes) to a new file in /etc/ld.so.conf.d (make sure that file's name ends with ".conf")
20:44:50 <hunt_____> as far as how haskell actually deals with it
20:44:55 <roboguy__> hunt_____: if you have something like "x :: Num a => a; x = 5", the "Num" gets turned into a function dictionary at compile time
20:44:58 <hunt_____> multiple evaluations and whatnot
20:45:09 <geekosaur> the problem with the current setup is an arch upgrade may remove the /usr/local/lib entry you aded
20:45:10 <roconnor_> > let x = 2 + 2 in (show x, show (fromRational x))
20:45:11 <lambdabot>  ("4","4.0")
20:45:12 <roboguy__> hunt_____: so, internally, it is like "x :: Num a -> a; x _ = 5"
20:45:22 <roconnor_> that is x behaving polymorphically
20:45:28 <geekosaur> (that may even be what broke your install...)
20:45:30 <roboguy__> hunt_____: this means that each time x is used, the function has to be called and the whole thing needs to be reevaluated
20:45:47 <roconnor_> notice that + needs to be evaluted twice: once for integers and once for rationals.
20:45:53 <roboguy__> if it just 5, that's not so bad, but pretend you do some long calculation
20:46:56 <hunt_____> roconnor_ but its only evaluated twice becasue you request two different forms correct?
20:47:27 <roconnor_> hunt_____: nope; there is no smart-caching in ghc, so it would be reevaluated at every use.
20:47:38 <roconnor_> hunt_____: even if the same instance is used.
20:47:59 <roconnor_> AFAIU
20:48:42 <hunt_____> how is that possible, shouldn't there be something to deal with this somewhere in ghc. Otherwise won't haskell be constantly allocating big blocks of memory? the same question kind of applies to how is everything genuinely static without being slow as hell
20:48:48 <roboguy__> if it has a monomorphic type, like Int, then it gets evaluated only once
20:48:51 <ThatTreeOverTher> geekosaur, my linking fails now: http://lpaste.net/102284
20:49:16 <roconnor_> > let x = 2 + 2 ::Integer in (show x, show (fromRational x))
20:49:17 <lambdabot>  Couldn't match type `GHC.Integer.Type.Integer'
20:49:17 <lambdabot>                with `GHC.Real.Ratio GHC.Integer.Type.Integer'
20:49:17 <lambdabot>  Expected type: GHC.Real.Rational
20:49:17 <lambdabot>    Actual type: GHC.Integer.Type.Integer
20:49:22 <roconnor_> > let x = 2 + 2 ::Integer in (show x, show x)
20:49:23 <lambdabot>  ("4","4")
20:49:34 <roconnor_> here 2 + 2 is only evaluted once
20:49:46 <geekosaur> sigh. it may be necessary to reinstall the wx package with the new ld.so.conf setting
20:49:51 <roconnor_> but now I cannot use fromRational
20:50:04 <roconnor_> geekosaur: have you considered nix :D
20:50:24 <geekosaur> I'm not the one trying to do productive work on Arch :p
20:50:34 <roboguy__> hunt_____: for functions, it's no different than having an extra argument for the class dictionary. for "values", it turns what should be a normal value into a function which causes the slowdown
20:50:54 * roconnor_ 's hobby: waiting for opportune moments to promote nix.
20:51:02 <hunt_____> roboguy__ so with every function call it has to check against the dictionary for the appropriate form?
20:51:37 <ThatTreeOverTher> geekosaur, I did a `cabal install wx --reinstall` but linking still fails
20:51:58 <roboguy__> hunt_____: for something polymorphic like "x :: Num a => a; x = 5 + 5" it turns it into (essentially) "x :: Num a -> a; x numDict = plus numDict 5 5"
20:52:12 <dolio> hunt_____: The biggest problem is that GHC is so smart that examples you construct to show the monomorphism restriction being useful are actually not good examples with optimizations on.
20:53:11 <dolio> Fibonacci numbers is, in theory, a good example, though.
20:53:41 <roboguy__> dolio: you mean a list of fibonacci numbers right?
20:53:46 <dolio> Yes.
20:53:52 <roboguy__> yeah, that is a good example
20:54:00 <dolio> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
20:54:22 <hunt_____> that definition is still really dififuclt for me to understand, even after multiple reading
20:54:23 <hunt_____> s
20:54:43 <dolio> That does O(n) work to find the n-th number if monomorphic, and O(fib(n)) if polymorphic.
20:54:59 <roboguy__> hunt_____: try expanding it a few steps
20:55:08 <dolio> Except the optimizer will generate an O(n) polymorphic one.
20:55:15 <roconnor_> hunt_____: it is safe to wait a few years before trying to grasp the MMR.
20:56:32 <roboguy__> probably the most important thing right now is to just realize that it exists, that it applies to polymorphic functions without type signatures and that it can generally be fixed by adding a type signature
20:56:48 <roconnor_> or by eta-expanding definitions
20:56:52 <dolio> You can do it yourself, I think: fibs :: Num n => [n] ; fibs = let mono = 0 : 1 : zipWith (+) mono (tail mono) in mono
20:59:08 <hunt_____> there should be some sort of error message that indicates the monomorphic restriction took effect
20:59:12 <hunt_____> in ghci
20:59:21 <roboguy__> hunt_____: there is, usually. it just was hidden this time
20:59:34 <hunt_____> do we know why it was hidden?
21:02:31 <pavonia> Heh, havng issues with the MMR now too. I can't give a type signature for a top-level function because the type class isn't exported :S
21:02:41 <dolio> hunt_____: What happens if you compile your original code with -fwarn-monomorphism-restriction?
21:04:06 <roconnor_> pavonia: have you tried eta-expansion?
21:04:17 <pavonia> no
21:04:19 <hunt_____> dolio: exact same error
21:04:26 <dolio> Okay.
21:04:30 <hunt_____> dolio: no mention of MMR :'(
21:04:32 <dolio> I wonder if that flag does anything.
21:04:45 <roboguy__> hunt_____: what about -Wall?
21:04:51 <dolio> -Wall doesn't turn it on.
21:05:07 <roboguy__> really? that's weird...
21:05:11 <dolio> It does turn on warnings about defaulting, but this isn't defaulting.
21:05:31 <pavonia> roconnor_: There's nothing to expand here
21:05:57 <hunt_____> same erros
21:05:58 <hunt_____> rs
21:06:01 <hunt_____> no matter what
21:06:18 <hunt_____> the MMR appears to be quite a bitch
21:06:26 <dolio> You can turn it off.
21:07:19 <roboguy__> pavonia: why isn't the type class exported?
21:07:35 <pavonia> I have no idea
21:08:17 <pavonia> It's gtk's Graphics.UI.Gtk.Gdk.EventM.HasCoordinates
21:08:22 <hunt_____> what would you guys do to shift a list. ie we have [1,2,3] and we want [2,3,1]. My solution is shift l = take (length l) . drop 1 . cycle l
21:09:16 <hunt_____> sorry $ for the lsat .
21:09:35 <hunt_____> and ? for the first
21:10:38 <Cale> Well, you can do: rotate [] = []; rotate (x:xs) = xs ++ [x], however, this is an inherently expensive operation, and if you need to do it a lot, lists are the wrong structure
21:11:22 <hunt_____> Cale well really im just hoping to pair a list and a shifted list
21:11:31 <hunt_____> with zip
21:11:33 <hunt_____> or zipWith
21:11:50 <roboguy__> hunt_____: for what reason?
21:11:53 <Cale> Well, it's common to write zip xs (tail xs)
21:11:55 <roconnor_> hunt_____: you don't even need the take
21:12:10 <hunt_____> roconnor_ oh good point
21:12:14 <roconnor_> > let x = [1,2,3] in zip x (tail (cycle x))
21:12:16 <lambdabot>  [(1,2),(2,3),(3,1)]
21:12:23 <Cale> (however, that misses out one of the elements you had)
21:12:29 <Cale> yeah
21:13:11 <hunt_____> roboguy__ the code we just worked through generates a bunch of triangle Matrices, and to render them i have to convert them to line matrices. this is part of my perceived method of doing that
21:13:34 <hunt_____> i wish i had thought of the takeless form
21:13:34 <roconnor_> hunt_____: you are right, drop 1 is better than tail.
21:13:43 <hunt_____> roconnor_ yea because of the error free
21:13:45 <roconnor_> > let x = [] in zip x (tail (cycle x))
21:13:46 <lambdabot>  []
21:13:57 <roconnor_> I guess it doesn't matter here.
21:14:05 <roconnor_> but tail is bad and I feel bad for using it.
21:14:17 <hunt_____> roconnor_ tails probably faster here because it has less patterns to check
21:15:27 <roboguy__> @src drop
21:15:27 <lambdabot> drop n xs     | n <= 0 =  xs
21:15:28 <lambdabot> drop _ []              =  []
21:15:28 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
21:15:46 <roboguy__> there would be no noticeable speed difference between them
21:18:03 <roboguy__> also, I always forget that guard failure falls through like that...
21:18:14 <roboguy__> that's handy
21:20:26 <roconnor_> hunt_____: the fact that you do not need take is a prime example of the awesomeness of lazy programming.
21:20:53 <roconnor_> laziness mean never needing to tell your producer how much you are going to consume in advance.
21:21:06 <roconnor_> and this occurs everywhere in programming.
21:21:16 <hunt_____> especially in c
21:21:28 <hunt_____> which is great
21:21:34 <hunt_____> because all my classmates are doing this project in c
21:21:34 <LLKCKfan> Hello
21:21:35 <LLKCKfan> Does anyone know about old Caloric Prestige Series Ranges(stove/oven)?
21:22:04 <roconnor_> hunt_____: it is why I have trouble programming in ML now.
21:22:22 <hunt_____> roconnor_ i dont plan on ever going back. is ML matlab?
21:22:34 <roboguy__> LLKCKfan: this is a computer programming channel
21:22:53 <hunt_____> i found some images of it LLKCKfan
21:22:59 <roconnor_> hunt_____: ML is the canonical typed functional programming language.
21:23:42 <LLKCKfan> I do not need images
21:23:53 <LLKCKfan> I know what it looks like
21:24:29 <pavonia> You want to programm it using Haskell, right? ;)
21:24:31 <roconnor_> LLKCKfan: try #haskell-blah
21:24:54 <LLKCKfan> I have a question about one
21:25:12 <hunt_____> LLKCKfan ok shoot
21:25:50 <LLKCKfan> I need to know how to open the top (not the oven door) on one without damaging it
21:26:20 <pavonia> use unsafePerformIO
21:26:49 <hunt_____> unsafeHammerStoveTop
21:27:59 <hunt_____> i have no idea
21:28:37 <hunt_____> but mi on the case
21:29:35 <hunt_____> LLKCKfan do you have the model number? you can get the manual here: http://www.repairclinic.com/Shop-For-Parts/a13b74c52/Caloric-Range-Stove-Oven-Manuals-Care-Guides-Literature-Parts
21:29:51 <LLKCKfan> I have looked
21:29:53 <hunt_____> and then that should give you the knowledge you need to safely unsafePerformIO
21:29:53 <LLKCKfan> No help
21:30:39 <hunt_____> LLKCKfan something in this? http://www.ehow.com/how_6833105_do-replace-caloric-oven-element_.html
21:31:26 <LLKCKfan> no
21:31:51 <hunt_____> LLKCKfan what is this stove anyways and why is it so common
21:32:14 <LLKCKfan> Normal Srange
21:33:06 <hunt_____> LLKCKfan: http://www.justanswer.com/appliance/1s7sc-remove-burners-caloric-prestige-gas-range.html i think he mentions removing the whole top and not just the burners with two clips on the side?
21:33:24 <LLKCKfan> Cannot remove the burnerds
21:33:48 <hunt_____> even with screwdriver?
21:34:22 <LLKCKfan> Does not come off
21:35:04 <hunt_____> LLKCKfan have you seen this manual? http://www.appliancerepair.net/oven-repair-contents.html
21:35:13 <LLKCKfan> not the one I have
21:35:30 --- mode: ChanServ set +o shachaf
21:35:38 <hunt_____> is it possible the instructions carry over?
21:35:46 --- mode: shachaf set +b *!*LLKCKfan@67.213.25.*
21:35:46 --- kick: LLKCKfan was kicked by shachaf (ban evasion)
21:36:16 <hunt_____> his oven will never work
21:36:23 <hunt_____> i hope you realize what youve done
21:36:45 <roconnor_> hunt_____: it would be better if you didn't engage LLKCKfan in this channel.
21:36:50 <hunt_____> who is he?
21:45:40 <geekosaur> offtopic stuff in #haskell, ##sports, and I think once in #calibre that I have seen
21:46:21 --- mode: shachaf set -o shachaf
22:00:57 <pordan30> before i reinvent the wheel, are there any libraries that implement cycle removal or feedback arc set heuristics or algorithms, preferably using the fgl library?
22:09:20 * hackagebot hspec-smallcheck 0.2.0 - SmallCheck support for the Hspec testing framework  http://hackage.haskell.org/package/hspec-smallcheck-0.2.0 (SimonHengel)
22:10:03 <amatsu> !bots
22:10:15 <amatsu> hmm, is lambdabot still around?
22:10:26 <Welkin> of course
22:10:28 <Welkin> @yar
22:10:29 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
22:10:47 <amatsu> cool
22:11:54 <Diablo-D3> hey all
22:12:02 <Diablo-D3> what web framework for haskell is considered the most secure
22:12:19 <nisstyre> Diablo-D3: none of them
22:12:32 <Diablo-D3> what makes you say that
22:12:46 <nisstyre> none of them have any particular advantages in that area
22:12:55 <Welkin> what are you looking for?
22:12:55 <pharaun> someone's familiar
22:13:01 <Welkin> industrial-grade stability?
22:13:21 <roconnor> Diablo-D3: https secure, or not PHP secure?
22:13:40 <Diablo-D3> roconnor: not php secure
22:14:19 <Diablo-D3> Im looking for a framework that automates doing form submission and ajax/websocket type tasks for authenticated users
22:14:48 <Welkin> have you checked out Scotty?
22:16:16 <Diablo-D3> Welkin: no.
22:16:22 <Diablo-D3> Ive never heard of it before
22:16:52 <Welkin> it is a popular haskell microframework
22:17:07 <Diablo-D3> http://www.haskell.org/haskellwiki/Web/Frameworks
22:17:11 <Diablo-D3> Im looking at this list
22:17:18 <Diablo-D3> and maybe half of them arent really what I want
22:18:12 <Welkin> it sounds like you want something lightweight, like Scotty
22:35:54 <Diablo-D3> Welkin: well, Im not against it being lightweight or not
22:36:32 <Diablo-D3> I just dont want to accidentally build in the usual stuff like csrf and cookie hijacking
22:36:59 <Welkin> accidentally?
22:38:11 <Diablo-D3> Welkin: if it was easy to stop that, no one would do it again
22:39:55 <Diablo-D3> Welkin: if I dont write any of the auth code, form creation, submission and validation code, or any of the ajax/websockets code
22:40:07 <Diablo-D3> then if theres a security issue, its most likely not something I wrote
22:40:35 <Welkin> so you want everything included (known as "batteries included")?
22:40:53 <Diablo-D3> somewhat, yeah.
22:41:11 <Diablo-D3> I was looking at play for scala, that seems to be somewhat what I want
22:41:22 <Diablo-D3> but I dont know scala (or haskell, for that matter)
22:43:24 <Diablo-D3> Welkin: like, if it has a half-way tolerable template language, that'd be nice too
22:43:46 <Welkin> I'm not familiar enough with haskell web frameworks
22:43:56 <Welkin> but look into Scotty
22:44:00 <Welkin> it seems popular
22:59:49 <yogert1> why not yesod or snap?
23:07:10 <vegan> :q
23:07:40 <Reta232> hello?
23:08:56 <Reta232> I need some help with some data structures
23:09:32 <Cale> ask away
23:10:31 <Reta232> well I'm trying to modify a tree implementation that my professor gave me so that it only accepts "*" and "+"  as valid branches
23:10:53 <Reta232> data Tree a b = Leaf a | Branch b [Tree a b] deriving (Eq,Read,Show)
23:11:25 <Cale> Well, that seems like you just have to pick an appropriate type b
23:11:45 <Cale> But you could also specialise b to a particular type in the definition of Tree, and remove the parameter
23:15:17 <Reta232> I guess the real problem is that my prof has inadequately taught me anything about haskell in general..... No matter where I go I cannot find an adequate explanation of what haskell does with my code
23:15:39 <Cale> hmm
23:15:47 <Cale> Well, you might enjoy...
23:15:50 <Cale> @where lyah
23:15:51 <lambdabot> http://www.learnyouahaskell.com/
23:16:41 <Cale> But feel free to ask any questions you might have about how things work
23:16:44 <Cale> or what they mean
23:21:27 <zcd> is there any situation where using a Maybe String for the Nothing is better than having a ""?
23:22:01 <pingu> When it means something different?
23:22:58 <pingu> say, when doing something like readFromWetString :: IO (Maybe String)
23:23:14 <pingu> where an empty string is different to your string not being wet enough to recieve a string.
23:23:17 <pingu> string.
23:24:31 <zcd> oh okay
23:24:43 <zcd> but if it's not such a case, there's no point distinguishing?
23:25:15 <Cale> Well, usually it's clear cut
23:25:41 <Cale> The empty string is a very different result from no string at all
23:26:36 <zcd> say i'm parsing irc messages
23:26:45 <zcd> there might be a prefix where the sender would be
23:26:57 <Cale> Consider something that may or may not succeed in getting a line of text from the user. Nothing would represent the case where the operation failed (e.g. the user pressed cancel), while Just "" would represent the case where it succeeded, but the user entered an empty string.
23:27:15 <zcd> but in all cases where there's no prefix, i don't see an appreciable difference in having a prefix as opposed to empty string
23:27:26 <ReinH> Cale: hey sorry
23:27:32 <Cale> ReinH: no problem
23:28:07 <ReinH> Cale: so if Alternative is a monoid in the category of endofunctors, how does it differ from a monad in a CT sense?
23:32:36 <Cale> ReinH: It's not a monoid object in the category of endofunctors
23:32:47 <Cale> (or, instances of it aren't)
23:32:59 <ReinH> Cale: huh, I thought shachaf said that it was.
23:33:01 <Cale> But rather, the instances are just endofunctors which create monoids
23:33:14 <ReinH> I must have misunderstood
23:33:40 <Cale> i.e. if A is some alternative functor, then for each type T, we have that A T is a monoid.
23:33:53 <ReinH> Right, that makes sense.
23:34:50 <ReinH> I'll have to ask shachaf what I missed.
23:40:28 <Cale> ReinH: It's possible that there's some other monoidal operation on endofunctors which he was considering, because what it means to be a monoid object depends on which monoidal category you're talking about. Perhaps just pointwise product?
23:41:18 <ReinH> Cale: iirc he was just talking about [Hask,Hask]
23:41:44 <ReinH> I'll have to ask him, no worries.
23:42:07 <Cale> Well, that just says what category we have, in order to specify a monoidal category, we technically need to give more details
23:42:17 <ReinH> Cale: Right
23:42:27 <Cale> There's a standard monoidal category structure on [C,C] given by composition of functors
23:42:47 <ReinH> Cale: arrows are natural natural transformations
23:42:53 <ReinH> right
23:43:01 <ReinH> s/natural //
23:43:04 <Cale> yeah
23:43:23 <ReinH> Cale: iirc that's the monoidal category he was talking about, which after we finished talking made me wonder "how isn't this just describing a monoid"
23:43:27 <ReinH> but I'll just ask him
23:43:34 <ReinH> er, monad
23:44:07 <ReinH> He asked me what the monoidal category was and I had to pause because I thought it couldn't be the obvious one
23:44:11 <ReinH> since that gives rise to a monad
23:44:18 * ReinH shrugs
23:44:51 <Cale> So, when C has products, there's another thing we could do to define a monoidal category structure on the category [C,C], which is to define the tensor operation by (F (x) G)(A) = F A x G A, where x is the categorical product in C
23:45:29 <Cale> (You also need a terminal object of course, to serve as the identity)
23:45:45 <ReinH> Cale: does this mean C has to be cartesian closed?
23:46:00 <Cale> Cartesian closed would be sufficient but not necessary
23:46:05 <ReinH> ah ok
23:46:21 <ReinH> because you don't need exponentials?
23:46:24 <Cale> right
23:46:31 <ReinH> gotcha
23:46:32 <Cale> just binary products and a terminal object would be enough
23:46:34 <ReinH> hey I'm learning :)
23:59:50 <jle`> okay so i have way too many project ideas for haskell right now :/
23:59:55 <jle`> has anyone ever felt this way
