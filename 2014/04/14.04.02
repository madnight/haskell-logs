00:02:22 <eatman> Hello
00:12:52 <erisco> how can I find and map an item in a list?
00:13:11 <erisco> findAndMap :: (a -> Maybe b) -> [a] -> Maybe b
00:13:13 <erisco> something like that
00:14:10 <dhrosa> you want to  find the first item in a list that satisfies some condition, and then apply a function to it?
00:14:16 <erisco> yes
00:15:03 <aleator_> fmap  f . find c ?
00:15:11 <dhrosa> erisco: what if you don't find this element?
00:15:12 <erisco> that does not work well for sum types
00:15:27 <erisco> findAndMap returns Nothing if the element was not found
00:17:20 <aleator_> erisco: How about listToMaybe . mapMaybe f then?
00:17:46 <erisco> this works fine here but I was hoping for a less explicit definition http://lpaste.net/102131
00:18:38 <erisco> aleator_, hm, looks interesting... listToMaybe should only grab the first element, and therefore it would short-circuit when the item is found
00:18:46 <erisco> :t \f -> listToMaybe . mapMaybe f
00:18:47 <lambdabot> (a1 -> Maybe a) -> [a1] -> Maybe a
00:19:12 <erisco> > listToMaybe [1..]
00:19:13 <lambdabot>  Just 1
00:19:30 <erisco> aleator_, thanks :)
00:42:21 * hackagebot keyring 0.1.0.1 - Keyring access  http://hackage.haskell.org/package/keyring-0.1.0.1 (lunaryorn)
00:54:52 <athan> can you have a cabal package compile more than one executable? More than one Main module?
00:57:24 * hackagebot marmalade-upload 0.5 - Upload packages to Marmalade  http://hackage.haskell.org/package/marmalade-upload-0.5 (lunaryorn)
00:57:34 <pranz> athan: more executables yes
00:57:49 <athan> thanks :)]
00:57:53 <athan> yeah, that makes sense
00:58:10 <athan> you wouldn't want to segregate scope of modules within your own package ><
01:07:04 <NikolajK> Are there any issues with considering the 'class of all cateogries' or the 'class of all functors'? (Note that I don -note- speak of the category of all categories or the category of all functors)
01:07:28 * hackagebot attoparsec-conduit 1.1.0 - Consume attoparsec parsers via conduit. (deprecated)  http://hackage.haskell.org/package/attoparsec-conduit-1.1.0 (MichaelSnoyman)
01:07:31 * hackagebot blaze-builder-conduit 1.1.0 - Convert streams of builders to streams of bytestrings. (deprecated)  http://hackage.haskell.org/package/blaze-builder-conduit-1.1.0 (MichaelSnoyman)
01:07:32 * hackagebot conduit 1.1.0 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.1.0 (MichaelSnoyman)
01:07:35 * hackagebot conduit-extra 1.1.0 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.0 (MichaelSnoyman)
01:07:36 * hackagebot network-conduit 1.1.0 - Stream socket data using conduits. (deprecated)  http://hackage.haskell.org/package/network-conduit-1.1.0 (MichaelSnoyman)
01:12:38 * hackagebot network-conduit-tls 1.1.0 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.1.0 (MichaelSnoyman)
01:12:41 * hackagebot resourcet 1.1.0 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.0 (MichaelSnoyman)
01:12:43 * hackagebot zlib-conduit 1.1.0 - Streaming compression/decompression via conduits. (deprecated)  http://hackage.haskell.org/package/zlib-conduit-1.1.0 (MichaelSnoyman)
01:12:49 * hackagebot http-client 0.3.0 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.0 (MichaelSnoyman)
01:12:49 * hackagebot http-client-conduit 0.3.0 - Frontend support for using http-client with conduit (deprecated)  http://hackage.haskell.org/package/http-client-conduit-0.3.0 (MichaelSnoyman)
01:16:17 <athan> Is there any insight to cabal install fail logs?
01:16:25 <athan> ExitFailure is hardly descriptive
01:16:33 <athan> or are we supposed to use ghc for that?
01:17:49 * hackagebot http-client-multipart 0.3.0.0 - Generate multipart uploads for http-client. (deprecated)  http://hackage.haskell.org/package/http-client-multipart-0.3.0.0 (MichaelSnoyman)
01:17:51 * hackagebot http-conduit 2.1.0 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.0 (MichaelSnoyman)
01:21:40 <supki> athan: the real error is probably somewhere higher in the log
01:21:56 <supki> athan: unless it's ExitFailure 9 or ExitFailure 11 or something
01:22:00 <athan> I have no idea where to look
01:22:03 <athan> hmm!
01:22:10 <athan> 1 for me
01:22:28 <athan> are you forced to have a license for your cabal packages?
01:22:53 <athan> and `ghc --main ...` worked fine
01:27:33 * hackagebot http-client 0.3.0.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.0.1 (MichaelSnoyman)
01:28:11 <tdammers> athan: not really, no. You can specify "other"
01:28:38 <tdammers> athan: but since part of the whole point of cabal is to publish packages on hackage, you're better off picking a standard license
01:29:58 <athan> tdammers: Thanks, i figured it out. The license file didn't exist, that's why haha
01:30:16 <athan> but yeah, I'm just doing toy projects that I don't want to publish right now, just practice
01:34:13 <tdammers> cabal init generates a LICENSE file for you, you know
01:40:40 <athan> hmm
01:40:57 <athan> How would I be able to resolve cabal hell?
01:42:56 <ion> Kill the current installed packages (rm -fr ~/.ghc ~/.cabal) and start from scratch using cabal sandboxes from now on. I have a sandbox for my home directory as well as a sanbox for each cabalized project.
01:44:39 * Kinnison seconds using sandboxes
01:44:41 <Kinnison> way way easier
01:46:02 <merijn> athan: Depends whether you are actually in cabal hell? I'm becoming more skeptical as "cabal hell" nowadays seems to mean "I ran a cabal command that didn't do what I wanted"
01:48:29 <athan> lol
01:48:33 <athan> i feel your pain
01:48:54 <athan> merijn: I was mistaken anyway, you were right :) The dependancy tree thing is what scared me
01:49:14 <athan> merijn: Is it possible to have multiple versions of base installed?
01:49:49 <athan> or really, what issues are faced in version changes like these? Are there any routine techniques to solving them?
01:49:55 <merijn> athan: Not unless you're bollocksing your system really badly :)
01:50:18 <athan> oooooohhhhhh yeah
01:50:21 <merijn> If you have incompatible dependencies, the solution is to yell at maintainers to fix it OR fix it yourself
01:50:23 <athan> it's pretty gunked
01:50:32 <athan> :/
01:50:55 <merijn> athan: If you're lucky it's just version bounds that are to tight and you can try making them more flexible
01:51:16 <athan> hopefully
01:51:21 <merijn> By, for example, running "cabal get" going into the dir, editing the cabal file and running "cabal install" in that directory
01:52:44 * hackagebot conduit-combinators 0.2.4 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.4 (MichaelSnoyman)
01:52:46 * hackagebot classy-prelude-conduit 0.8.1 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.8.1 (MichaelSnoyman)
01:59:27 <athan> the "with..." pattern is pretty much like an fmap, right?
01:59:35 <athan> like in usb-safe-examples
01:59:54 <athan> withDevice dev $ \devHnd1 -> ...
02:00:05 <athan> that's just a >>=
02:00:35 <athan> er, wait
02:00:41 <athan> my fault, nevermind
02:02:46 * hackagebot hxt-pickle-utils 0.1 - Utility functions for using HXT picklers.  http://hackage.haskell.org/package/hxt-pickle-utils-0.1 (ErikHesselink)
02:02:48 * hackagebot cabal-src 0.2.2.1 - Alternative install procedure to avoid the diamond dependency issue.  http://hackage.haskell.org/package/cabal-src-0.2.2.1 (MichaelSnoyman)
02:03:36 <merijn> No, with.. is like bracket
02:03:40 <merijn> :t bracket
02:03:41 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:11:43 <athan> how does this type-foolary work???
02:11:47 <athan> let [interruptInEndp] = getEndpoints altHndl In Interrupt
02:13:00 <nicoo> athan: I see no type-foolery here. Just pattern-matching
02:13:28 <athan> is pattern matching bi-directional of the =, nicoo?
02:13:46 <nicoo> Wat?
02:13:58 <athan> erm
02:13:59 <athan> hmm
02:14:10 <athan> [interruptInEndp]
02:14:17 <athan> isn't that... a type??
02:14:38 <nicoo> I don't think so
02:14:50 <athan> what would it represent?
02:15:18 <athan> how do you "unlist" something??
02:15:28 <nicoo> The list interruptInEndP : []
02:15:37 <athan> ooooooohhhhhh
02:15:38 <athan> phew
02:15:41 <athan> it's just sugar
02:15:46 <athan> I was freaking for a sec haha
02:15:49 <nicoo> :D
02:15:59 <athan> "WHAT?? WHAT???"
02:16:06 <athan> "How did I not see this???"
02:21:35 <athan> I have a question regarding "automatic" parallelism / asynchronisity in haskell
02:22:16 <athan> if you could look at https://github.com/basvandijk/usb-safe-examples/blob/master/example.hs and pm me, I would be very grateful :)
02:27:35 <nicoo> athan: I need to work, sorry.
02:27:51 <athan> :)
02:27:55 <athan> thanks anyway!!
02:36:02 <will_sh> hi can i ask a newbie question about applicative?
02:36:37 <will_sh> i have a hard time understanding (+) <$> (*3) <*> (+100) $ 5 (from LYAH book)
02:36:52 <will_sh> i can understand (+5) <*> (*3) $ 4 for example
02:37:14 <gal_bolle> ask away
02:38:12 <will_sh> (+) <$> (*3) <*> (+100) $ 5       ... <- how can i work out this expression? step by step?
02:38:31 <gal_bolle> you probably want to use :t in ghci
02:38:33 <merijn> will_sh: It's a standard but tricky example
02:38:41 <merijn> gal_bolle: That's not very helpful for understanding
02:39:07 <merijn> will_sh: Well, ask yourself this question first: Which Functor (for <$>) and Applicative instance (for <*>) are being used?
02:39:08 <will_sh> i can work out (+5) <*> (*3) $ 4 ---> fmap (+5) (*3) which is just function composition (+5) . (*3)
02:39:31 <merijn> will_sh: That's not right, btw
02:39:35 <merijn> <*> is not fmap
02:39:38 <will_sh> it's the function functor?
02:39:47 <merijn> :t fmap
02:39:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:39:51 <merijn> :t (<*>)
02:39:52 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:41:23 <Aetherspawn> oooh I finally understand <*>
02:41:27 <Aetherspawn> lol, thanks merijn
02:41:29 <merijn> will_sh: This parses as "((+) <$> (+5)) <*> (*3)"
02:41:47 <merijn> will_sh: So, first look at "(+) <$> (+5)"
02:42:00 <merijn> i.e. which functor is that using and what does this combination do?
02:42:01 <will_sh> ok, (+) a binary function
02:42:25 <will_sh> this translates to: fmap (+) (+5) ?
02:42:41 <merijn> Right
02:43:23 <merijn> will_sh: It can help to grab a piece of paper and write out the types of fmap, (+) and (+5) and see how they fit together
02:43:27 <vvv> hi
02:43:41 <Guest97623> you can go to the http://www.newsky8.com
02:43:43 <will_sh> i will try...sec..
02:44:07 <Guest97623> kk
02:44:26 <Guest97623> you can go to the http://www.newsky8.com to know it
02:44:53 <will_sh> it's (+) . (+5) ? function composition?
02:46:22 <will_sh> :t fmap (+) (+5)
02:46:23 <lambdabot> Num a => a -> a -> a
02:47:18 <bernalex> if I do length <$> foo >>= print -- how do I "add" a - 2 to the result of length?
02:48:15 <bjorn_> what does this mean in a class definition?  type Pixel i :: *
02:48:41 <merijn> bjorn_: Kind signature
02:48:44 <Sgeo> @pl (>>= (\x -> maybe [] [x] x)
02:48:44 <lambdabot> (line 1, column 3):
02:48:45 <lambdabot> unexpected '>'
02:48:45 <lambdabot> expecting expression
02:48:46 <Sgeo> @pl (>>= (\x -> maybe [] [x] x))
02:48:47 <lambdabot> ((maybe [] =<< return) =<<)
02:48:47 <will_sh> merijn: is it correct that (+) <$> (+5) <*> (*100) works out to: (+) . (+5) . (*100) ?
02:49:08 <ion> bernalex: (\xs -> length xs - 2) = (\xs -> subtract 2 (length xs)) subtract 2 . length. Any of these forms are fine.
02:49:27 <merijn> will_sh: It works out to "\x -> ((+) . (+5) $ x) ((*100) x)
02:49:28 <ion> Missing a “=” in there. … = subtract 2 . length
02:49:56 <bjorn_> merijn, what is that star mean ? so Pxiel is a function ?
02:49:59 <will_sh> merijn: i see........
02:50:00 <will_sh> thx
02:51:56 <will_sh> merijn: that is derived from the function instance of the Applicative type class? where f <*> g = \x -> f x (g x)
02:52:01 <will_sh> now I can see it more clearly
02:52:29 <bernalex> ion: I just did subtract 2 . length <$> foo
02:52:38 <bernalex> ion: so subtract was what I was looking for, thanks
02:58:09 <ion> @let class Foo a where { type Bar a :: * }; instance Foo Bool where { type Bar Bool = Integer }; instance Foo [a] where { type Bar [a] = Maybe a }
02:58:09 <lambdabot>  Parse failed: Parse error: *
02:58:16 <ion> @let class Foo a where { type Bar a }; instance Foo Bool where { type Bar Bool = Integer }; instance Foo [a] where { type Bar [a] = Maybe a }
02:58:16 <lambdabot>  Parse failed: TypeFamilies is not enabled
02:58:55 <ion> bjorn: lambdabot doesn’t want to comply, but try that example in ghci and then look at “:t undefined :: Bar Bool” and “:t undefined :: Bar [Bool]”
02:59:02 <ion> okay then
03:02:59 * hackagebot yesod-fay 0.5.0.1 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.5.0.1 (MichaelSnoyman)
03:08:00 * hackagebot generic-aeson 0.1 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.1 (ErikHesselink)
03:08:02 * hackagebot yesod-platform 1.2.9 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.9 (MichaelSnoyman)
03:08:04 * hackagebot yesod-bin 1.2.8 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.8 (MichaelSnoyman)
03:13:01 * hackagebot lens-datetime 0.2.1 - Lenses for Data.Time.* types  http://hackage.haskell.org/package/lens-datetime-0.2.1 (MihalyBarasz)
03:13:20 <grohne> is there a way to list the recursive dependency tree of a package? (cabal)
03:15:22 <k00mi> grohne: cabal-db can do that (and generate fancy graphs)
03:16:17 <grohne> thanks!
03:16:39 <grohne> hmm. cabal-db breaks darcs
03:17:06 <grohne> ah. I should cabal update
03:19:31 <siriusbtx> if I have a list of coordinates, what is the best way to chain something like this: setCoordinate (1,2) pf >>= setCoordinate (2,3)?
03:20:11 <siriusbtx> just fold?
03:22:42 <k00mi> foldM maybe
03:23:06 <siriusbtx> k00mi: ty
03:23:06 <k00mi> more code would be useful
03:23:41 <siriusbtx> k00mi: well I have setCoordinate :: (Int, Int) -> PlayField -> Maybe PlayField, and now I want to create a function that acceps a list of coordinates, and set them on the playfield
03:25:30 <k00mi> yep, then foldM is good
03:31:15 <wattlebay> @where ops
03:31:16 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
03:31:44 <quicksilver> wattlebay: ? is there a problem?
03:32:16 <wattlebay> hey, i'm new to haskell and was wondering do more than one action in a function?
03:32:33 <quicksilver> that's not something you need an op to help you with :)
03:32:43 <wattlebay> oh sorry bit new to all this!
03:32:56 <quicksilver> normally you use do notation
03:33:07 <quicksilver> do { first_thing; second_thing; }
03:33:15 <wattlebay> ah great, thankyou!!
03:33:20 <quicksilver> although that can also be written without the 'do' as first_thing >> second_thing
03:33:45 <wattlebay> also for future reference, where should i have asked this q?
03:35:45 <quicksilver> this is a great place to ask, Watcher7
03:35:48 <quicksilver> !
03:35:53 <quicksilver> and, he's gone.
03:36:03 <tdammers> yeah
03:36:05 <tdammers> webchat, anyway
03:36:06 <quicksilver> causing me a mis-tab complete with timing.
03:36:27 <quicksilver> I have parts hidden in this channel bcause they got so noisy.
03:36:49 <quicksilver> what I really want is an IRC client which hides joins/parts but can make them reappear at the press of a button.
03:37:05 <tdammers> you could probably script this into irssi
03:37:15 <quicksilver> I had a look at it
03:37:19 <quicksilver> I don't think so.
03:37:32 <quicksilver> when things are hidden they are actually "not there" in the representation of the channel's window
03:37:37 <quicksilver> they're not merely hidden lines.
03:37:47 <quicksilver> you'd have to literally rebuild the window, threading them back in, as far as I could see.
03:38:44 <merijn> You could script lots of things into irssi, but you'd have to know perl :p
03:39:04 <quicksilver> merijn: conveniently, I've been a professional perl programmer for 20 years ;)
03:39:18 <k00mi> weechat can hide quits and only show quits if the porson said something in the last x minutes
03:39:23 <k00mi> also works for joins
03:39:25 <merijn> quicksilver: Ah, so I can ask you to write stuff for me! :p
03:43:04 * hackagebot http-conduit 2.0.0.10 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.0.0.10 (MichaelSnoyman)
03:46:51 <Guest81693> hi, i'm trying to implement a function to traverse through a binary tree and add each number in the tree to an integer list
03:47:34 <dhrosa> is there a problem, or do you not know how to start
03:47:34 <dhrosa> ?
03:47:55 <Guest81693> yep sorry just trying to get it up on pastebin
03:48:24 <Guest81693> http://pastebin.com/wx0XtGLU
03:49:07 <Guest81693> so the first issue i ran into was that i was trying to figure out how to add the element to the list AND traverse down the tree
03:49:23 <Guest81693> wasn't sure how to do more than one action in a function so i tried the 'do' function
03:49:33 <dhrosa> that's not quite what do's for
03:49:41 <Guest81693> however now i'm running into an issue with the actual list i'm trying to create
03:50:43 <Guest81693> ah i see. any idea what i should be looking at instead?
03:50:55 <dhrosa> you could have mysterious (Branch j l r) = j : ([mysterious l] ++ [mysterious)
03:51:01 <dhrosa> instead of your last three definitions
03:51:09 <quicksilver> Guest81693: there are two techniques I guess.
03:51:15 <dhrosa> there's a more efficient way to do it, but i'm too tired to think of  it (++ is a pig)
03:51:22 <dhrosa> oops
03:51:23 <dhrosa> I meant
03:51:25 <quicksilver> one is to call recursively more than once and join it up, like dhrosa said
03:51:27 <Guest81693> also obligatory - this is hw :P
03:51:35 <dhrosa> you could have mysterious (Branch j l r) = j : (mysterious l ++ mysterious r)
03:51:36 <quicksilver> the other is to keep the list-so-far in a parameter
03:51:40 <quicksilver> and keep passing it to the recursive calls
03:51:50 <quicksilver> that's the one that "feels like" the imperative approach of "adding to the list"
03:52:12 <quicksilver> the technique is called accumulators (building somethign up in an argument you keep passing to recursive calls)
03:53:05 <Guest81693> ah i see. cool, i'll try that. thanks guys!
03:53:20 <dhrosa> yes, using an accumulator you can make this an O(n) operation, my  solution is O(n^2)
03:53:28 <dhrosa> because of the list concatenation
03:54:13 <quicksilver> but you can fix that by building up functions instead of lists
03:54:22 <quicksilver> but, I don't think that matters to Guest81693's homework somehow
03:55:04 <makalu> is there a way to refer to the current module's function when there are functions with the same name in multiple modules?
03:55:17 <quicksilver> dhrosa: mysterious (Branch j l r) = (j:) . (mysterious l ++) . (mysterious r ++)
03:55:30 <quicksilver> dhrosa: the functions reassociate everything to the right, effectively
03:55:35 <quicksilver> and you just apply it to ($) at the end
03:56:05 <dhrosa> quicksilver: isn't that the same as my solution?
03:56:08 <dhrosa> in terms of complexity?
03:56:18 <quicksilver> no
03:56:28 <quicksilver> or, I don't think so
03:56:33 <quicksilver> but it's wrong :)
03:56:35 <dhrosa> makalu: you can either import the other modules qualified, or you can import the other modules using "hiding"
03:56:36 <merijn> quicksilver: Actually, it might be
03:56:45 <quicksilver> dhrosa: mysterious (Branch j l r) = (j:) . (mysterious l) . (mysterious r)
03:56:47 <dhrosa> import OtherModule hiding (conflictingName)
03:56:49 <quicksilver> don't need the ++
03:56:55 <merijn> quicksilver: ++ supports fusion for well behaved generators
03:56:57 <quicksilver> because mysterious now returns a function
03:57:01 <makalu> I hoped there was a better way :(
03:57:11 <merijn> So I think it may just fuse into O(n)
03:57:26 <quicksilver> merijn: I don't think that works for double recursion
03:58:22 <merijn> quicksilver: I think the ++ may not even have to fuse, wouldn't it be O(n) anyway since  "j : (mysterious l ++ mysterious r)" is already in WHNF?
03:58:39 <merijn> So it can just lazily recurse/generate
03:58:47 <Guest81693> what type is (mysterious l ++ mysterious r) ?
03:58:49 <quicksilver> merijn: there are a log of recursive ++'s on the left side
03:59:03 <quicksilver> merijn: each of those traverses its own left side
03:59:04 <merijn> quicksilver: Ah, you may be right
03:59:18 <Guest81693> oh it's just the base case's type sorry answered my own q
04:00:27 <dhrosa> additionally, you knew it was at least a list of something, because of the ++
04:01:11 <dhrosa> and you're prepending j to it, which is an int, so it must be an [Int]
04:01:12 <Guest81693> ah yep. so tricky to get your head around this coming from imperative languages
04:01:26 <dhrosa> imperative languages have types too :p
04:02:21 <Sensora> Hey, I'm using Archlinux and its package manager pacman in order to install Haskell packages. The only package I have installed via cabal-install is hsenv. Now I want to update hsenv to the newest version. How do I do this in the cleanest way possible? Remove .ghc and .cabal and cabal install again? Would I still need to ghc-pkg unregister?
04:03:04 <merijn> Sensora: "ghc-pkg unregister" followed by installing is fine, but that won't throw away the files related to the old version
04:04:26 <Sensora> merijn: Even if I remove the directories .ghc and .cabal?
04:04:39 <dhrosa> that will definitely remove the package
04:05:28 <Sensora> Any drawbacks to that method?
04:09:43 <merijn> You need to reinstall everything
04:12:42 <bernalex> is there a function somewhere for capitalising every word of a String?
04:12:46 <dcoutts> edwardk: pong
04:12:49 <Sensora> merijn: Thanks! So if I remove .ghc and .cabal it's not necessary to run ghc-pkg unregister, right?
04:14:12 <merijn> Right
04:14:28 <ion> bernalex: Data.Text.toTitle
04:15:17 <bernalex> ion: that's for Text not String though
04:15:18 <ion> Or toUpper if you meant what you said literally.
04:15:49 <ion> Are you sure you don’t want to use Text in the first place?
04:16:02 <Sensora> bernalex: merijn: Thanks a lot!
04:16:02 <bernalex> ion: less code if I don't
04:16:08 <bernalex> Sensora: IDK what I did, but you're welcome.
04:16:30 <Sensora> :-) I started to answer your question but then ion was faster
04:16:44 <bernalex> ion: it's for ioeGetErrorString, which returns a String.
04:17:22 <ion> Text.unpack . Text.toTitle . Text.pack ;-)
04:17:28 <bernalex> I guess
04:17:35 <bernalex> or zomg pragma
04:18:47 <bernalex> ion: thanks btw
04:29:24 <Sensora> bernalex: Would the following work? (you'd lose whitespace though): toUpper' = unwords . map (\(x:xs) -> toUpper x : xs) . words
04:30:38 <bernalex> Sensora: pack . toTitle . unpack is a lot shorter, and keeps whitespace.
04:30:46 <ion> Data.Char.toUpper is broken, don’t use it.
04:31:09 <quicksilver> bernalex: why bother to unpack it at the end? keep it as text?
04:31:11 <bernalex> ion: what's broken about it?
04:31:13 <quicksilver> ion: is it?
04:31:24 <quicksilver> combining chars maybe?
04:31:34 <ion> bernalex: Please see the documentation of Data.Text.toUpper and friends, it provides examples.
04:31:47 <Sensora> bernalex: Yes, but you wouldn't have Text as a dependency
04:31:49 <bernalex> quicksilver: it's passed to printf
04:31:53 <ion> quicksilver: toUpper :: Char -> [Char] would be feasible.
04:32:04 * quicksilver nods at ion 
04:32:07 <bernalex> Sensora: that's OK. the repo has it as a dependency already anyway.
04:32:47 <bernalex> the repo doesn't really care about dependencies, heh. it's just a bunch of self-contained mini-tool programs.
04:34:36 <quchen> Is there a reason `data` etc are only allowed at top level? Why are local data definitions not allowed?
04:34:45 <merijn> ion++
04:35:26 <merijn> quicksilver: Not just combining chars, unicode ligatures should be converted to multiple characters
04:35:47 <merijn> like the ffl ligature (to lazy to find the codepoint for it) which should become FFL when uppercased
04:35:52 <merijn> Data.Text does this properly
04:36:15 <merijn> quchen: What good would local data definitions be?
04:36:15 <quicksilver> quchen: I don't think there is a good reason.
04:36:24 <quicksilver> quchen: local imports would be useful too, occasionally
04:36:39 <merijn> quchen: I don't see, conceptually, why you couldn't have them. But in the grand scheme of things they don't seem that useful
04:36:46 <quicksilver> quchen: however, in practice, such things would complicate the development process since it would make stuff hard to test
04:36:59 <quicksilver> quchen: can't use them in GHCi, can't write tests depending on them, etc
04:37:23 <quchen> quicksilver: Why would GHCi not support them?
04:37:48 <quicksilver> quchen: because they wouldn't have names
04:37:52 <quicksilver> ghci can only see top-level stuff
04:38:10 <quchen> Oh, you mean you can't see them in GHCi like you can't see anything else in 'where's
04:38:12 <quicksilver> just like ghci can't let you interactively experiment with a function inside a 'where'
04:38:12 <tanmaig> Is it completely safe to implement an infinitely recursing function as a while(True) equivalent?
04:38:16 <quicksilver> nod
04:38:26 <quchen> merijn: Here's an example from `parallel`: http://hackage.haskell.org/package/parallel-3.2.0.4/docs/src/Control-Parallel-Strategies.html#rparWith
04:38:31 <quicksilver> tanmaig: sure. There already is one called 'forever'.
04:38:32 <quchen> "Lift" is a local definition
04:38:58 <tanmaig> I need to pass state, so I'm doing it explicitly.
04:38:59 <quicksilver> quchen: I just put them near the function they apply to and don't export them from the module
04:38:59 <quchen> I don't have a particular use case in mind, I was just wondering in the past and now I saw this in the source.
04:39:04 <quicksilver> I think it works OK
04:39:04 <tanmaig> How would one pass state with forever?
04:39:14 <quicksilver> tanmaig: use forever in a moand with state...
04:39:28 <quicksilver> but anyway there is no problem with infinite recursion
04:39:34 <quicksilver> > let x = 1:x in x
04:39:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:39:36 <quchen> quicksilver: Yeah, but I feel like it's a workaround, as if you had to manually float out local definitions from 'where'
04:39:47 <quicksilver> quchen: which I often do anyway, so I can test them independently :)
04:39:48 <tanmaig> quicksilver: Ah, ofcourse. Thanks. :)
04:40:29 <quicksilver> quchen: rather than more local features I think it would be a better addition to the language to make modules even more lightweight
04:40:41 <merijn> Yes!
04:40:45 <quicksilver> so you could have multiple modules per file (nested) and put local data types in them
04:40:46 <quchen> quicksilver: In what way?
04:40:53 <quchen> Oh. Yes that would be neat.
04:40:59 <merijn> quicksilver: And while we're add it, parameterise modules!
04:41:04 <merijn> s/add/at
04:41:14 <quchen> And not very hard to do, syntactically. New module keyword, new module section.
04:41:28 <quicksilver> sure, although depending what kind of parameterisation you intend that is quiet a substantial change
04:41:49 <quchen> module Main :: Int -> Module where
04:41:50 <quchen> :-D
04:41:54 <merijn> quchen: Why a new module keyword?
04:42:19 <quchen> merijn: "new" as in "another".   module A where …  \n\n\n module B where
04:47:01 <Arafangion> Given a function, lets say: foo a b = a + b
04:47:13 <Arafangion> At what point does haskell determine the types of that function?
04:47:21 <ion> When compiling
04:47:50 <Arafangion> At what point in compiling it - do the types need to be determinated by the end of that function?
04:47:57 <Eduard_Munteanu> At some point after parsing but before emitting code.
04:48:28 <Eduard_Munteanu> Arafangion: during typechecking
04:48:41 <Arafangion> But that typechecking is done program-wide, isn't it?
04:48:48 <Arafangion> Not just within each individual function?
04:49:02 <quchen> Every single piece of code is typechecked.
04:49:17 <Arafangion> The reason I'm asking is I'm attempting to rationalise what little I know about haskell's typing (which was very elegant last time I did the tutorials)
04:49:25 <quchen> foo a b = a + b  -- This typechecks a, b, (+), and foo.
04:49:28 <Arafangion> And that of fsharp.
04:50:24 <shouya> excuse me, a simple question: what is the '|' notation called in `class MonadState m s | m -> s`
04:50:27 <Arafangion> Right, but the types of 'a' and 'b' there aren't known yet, are they?
04:50:38 <Arafangion> You need to know how it's called, in order to determine the types?
04:50:47 <shouya> and what does it mean?
04:50:47 <ion> shouya: Functional dependencies
04:50:54 <shouya> ion: thanks.
04:51:11 <ion> shouya: In the instances, the “m” completely determines “s”.
04:51:56 <shouya> ion: what do you mean 'completely determines'?
04:52:06 <shouya> ion: (reading haskell wiki about that.)
04:53:06 <merijn> Arafangion: Well, in your example the types of a and b are known
04:53:17 <merijn> Arafangion: Or rather
04:53:22 <quchen> shouya: This post might help: http://stackoverflow.com/a/20040343/1106679
04:53:30 <merijn> Arafangion: "(+) :: Num a => a -> a -> a"
04:53:40 <shouya> quchen: okay, thanks :)
04:54:00 <merijn> Arafangion: So we know two things about 'a' and 'b': 1) a and b are the same type and 2) that type is an instance of the Num typeclass
04:54:06 <Arafangion> merijn: So it depends on how well the operators have been defined?
04:54:22 <Arafangion> I guess it's similar to how fsharp might be doing it, then.
04:54:24 <merijn> Arafangion: So now at every location where you use "foo" GHC will check whether those two things are true
04:54:46 <merijn> Arafangion: The best way to understand what's going on is probably to read up on what unification is and how it works
04:54:51 <Arafangion> I was somehow under the impression that haskell was sort of saying that the argumetns were 'addable'.
04:55:00 <Arafangion> Which is apparently what Ocaml does.
04:55:19 <tdammers> Arafangion: that's what the Num typeclass does, among other things
04:55:22 <tdammers> :info Num
04:55:23 <Arafangion> So, read up on 'unifying types for haskell'?
04:55:31 <merijn> Arafangion: As, as far as I'm aware, F#, like the other functional languages, uses unification for typechecking
04:55:44 <quchen> merijn: There are other ways?
04:55:51 <merijn> Arafangion: Not even for haskell, most Hindley-Milner type languages will use unification to deal with polymorphism
04:55:58 <merijn> quchen: Dunno, just hedging my own claims :)
04:55:58 <lyxia> Hi, I'm trying some benchmarks with Criterion, and I've got weird results: http://lpaste.net/102135 it takes longer to compute 'sum' of a list than 'scanl1 (+)'. I thought "nf" should make the list be evaluated fully?
04:56:07 <Arafangion> merijn: Thanks, this gives me something to read up on :)
04:56:34 <merijn> Arafangion: The process should be fairly similar between Haskell, OCaml and F#, certainly for basic types
04:57:17 <Arafangion> merijn: The F# example I'm plying with is actually a bit more complex.
04:58:02 <Arafangion> merijn: It's foo a = a.replace("a", "A"), so I was expecting that it should be able to enforce the ability to invoke that method.
04:58:52 <merijn> Arafangion: I'll give a simple example, but for more details I recommend finding some good tutorial on the web
04:59:02 <merijn> Arafangion: Let's say we have "id :: a -> a"
04:59:15 <Arafangion> merijn: Most good tutorials just say: "Stop thinking about it, just add the type specifications to it".
04:59:32 <merijn> So how do you typecheck a term like "id 5"?
04:59:32 <quchen> When I run `cabal sandbox init && cabal install foo`, everything will be contained in the sandbox, right? Or does "download+install" have special behaviour
04:59:41 <quchen> I'm asking before I trash my local DB :-)
05:00:25 <Arafangion> merijn: What is there to typecheck? The same type that you get out, should be the type you get in.
05:00:30 <merijn> We know the following: "id :: a -> a", "5 :: Int" and want to answer "id 5 :: ?"
05:00:31 <Phlogistique> go
05:00:33 <Phlogistique> oops
05:01:33 <merijn> Arafangion: So, first step, we try to unify (hence the term unification) the variable 'a' with the type 'Int', variables can unify with anything, so this works and we end up with extra knowledge: "a = Int"
05:01:59 <merijn> Since "id :: a -> a", we know that in this contest "id :: Int -> Int"
05:02:01 <merijn> Therefore
05:02:04 <merijn> "id 5 :: Int"
05:02:44 <Eduard_Munteanu> Arafangion: start with a simplified model: your language has abstraction (functions / lambdas), function application and values of some type. Classifying a term in one of those categories can be done purely syntactically.
05:02:47 <Arafangion> merijn: But once you have that, you can't use some other type, as if it's a template?
05:03:03 <merijn> Arafangion: typechecking happens *everywhere*
05:03:41 <merijn> Arafangion: The fact that you know the type of 'id', is not sufficient to know the type of "id 5"
05:03:53 <Eduard_Munteanu> Arafangion: then, for example, take 'f x' as a term. That's an application. Therefore 'f' must be an abstraction and its type must be some X -> something.
05:03:57 <Arafangion> I seem to have gotten my C++ templates hat on, this has been enlightening.
05:04:03 <mornfall> merijn: unless you also know the type of 5 ;-)
05:04:11 <Arafangion> Eduard_Munteanu: No, it's not an application until you, *apply* it.
05:04:16 <merijn> mornfall: Right, that was my point
05:04:41 <merijn> Arafangion: 'f x' is application of 'f' to 'x'
05:04:42 <Arafangion> merijn: I will _definitely_ read up on type unification.
05:04:47 <Eduard_Munteanu> Arafangion: f is applied to x there.
05:04:48 <powaa> >
05:05:06 <merijn> Arafangion: Basically, the type of term depends on the types of *all* sub-terms
05:05:09 <Arafangion> Hmm, ok.  I read that more as: "f is to be applied to x there".
05:06:09 <merijn> Arafangion: Let's take a more complex example: "foo :: Maybe a -> Maybe b -> Maybe (a, b)" <- clearly you can't know the type of "foo x y" without knowing the types of x and y
05:06:25 <Eduard_Munteanu> Arafangion: anyway, that tells you something but not all. Type checking/inference involves gathering all these constraints on types and deriving the most generic type, and checking that there are no contradictions.
05:06:29 <Arafangion> merijn: I see.
05:07:11 <Arafangion> Eduard_Munteanu: A critical point was realising that, as merlin was saying, everything gets typechecked.
05:07:19 <merijn> Arafangion: Imagine that 'x :: Int' then we try to unify "Maybe a" with 'Int', this fails because the two don't unify. However, if 'x :: Maybe Int' then we *can* unify and learn that "a = Int"
05:07:21 <Arafangion> Eduard_Munteanu: Even the things that never get called or used(!)
05:07:41 <Eduard_Munteanu> Arafangion: yep
05:07:46 <merijn> Arafangion: So "foo x :: Maybe b -> Maybe (Int, b)" <- since we checked and inferred that "a = Int"
05:08:07 <Eduard_Munteanu> :t \x y -> ?f x
05:08:08 <lambdabot> (?f::t2 -> t1) => t2 -> t -> t1
05:08:43 <merijn> Arafangion: Now, imagine that 'x' is itself a complex expression, then we need to check *all* sub parts of 'x' *as well*, just to know the type of x, which we need to find the type of "foo x", which we need to find the type of "foo x y"
05:08:43 <Eduard_Munteanu> The mission of the typechecker is to check code is well-typed, which implies it must be ascribed a type at some point.
05:09:08 <Arafangion> Eduard_Munteanu: This is a *very* different philosophy to that in C++ templates.
05:09:24 <merijn> Arafangion: Basically, everytime we encounter a type that is not just a variable we learn some more constraints about the entire expression
05:10:17 <merijn> Arafangion: Unification is just constraint solving, i.e. is there a non-empty set of types that we can assign to each variable such that we don't invalidate any of the constraints we have found
05:10:41 <merijn> "id :: a -> a" is easy, because the type variable 'a' has no constraints other than "it's a type"
05:10:47 <c_wraith|N10> Arafangion: some recent ghc, I think 7.8, allows you to set a flag that causes compilation to not fail if there's a type error. However, the code it generates for terms with type errors is more or less "crash reporting the type error". It's handy for running a small portion of a larger program that has been modified to use new types, without fixing up the whole program.
05:10:48 <Eduard_Munteanu> Arafangion: usually it's a good idea to typecheck eagerly.
05:11:03 <Arafangion> c_wraith|N10: That sounds awful.
05:11:28 <c_wraith|N10> It still reports them as warnings at compile time.
05:11:33 <merijn> "foo :: Maybe a -> Maybe b -> Maybe (a, b)" is a lot more constraining, as our choices are constrained by the presence of "Maybe"
05:11:54 <merijn> Arafangion: It's quite useful actually, it allows tools like hdevtools to query the type of a variable even if you current code is wrong
05:12:05 <Eduard_Munteanu> Arafangion: it is awful in that it's not supposed to be used for programming. But it can be useful for IDEs and editors.
05:12:16 <Arafangion> Eduard_Munteanu: I'm not suggesting that we should avoid the typechecking. I was just surprised at how early it's done.  I was expecting that the typechecking be done at the very end of the compile, when it's known what is, and what isn't being used.
05:12:18 <aristid> merijn: when you show that type, i still think liftA2 (,)
05:13:14 <Eduard_Munteanu> Arafangion: typechecking has to happen before compiling per se because types are erased from final code for practical purposes (they're not necessary)
05:13:31 <Eduard_Munteanu> That's actually called "type erasure".
05:13:41 <Arafangion> Eduard_Munteanu: In C++, templates are effectively a pattern, and those patterns that don't match literally don't exist in the final program.
05:14:12 <merijn> Arafangion: Right, that's because templates are effectively "boilerplate generation"
05:14:13 <Arafangion> Such that only the code that actually matches the type patterns, gets validated as conforming to those types.
05:14:17 <Eduard_Munteanu> Arafangion: aren't C++ templates a type-level equivalent of Haskell computations?
05:14:21 <Arafangion> merijn: Yes, that's right.
05:14:24 <merijn> Arafangion: Whereas polymorphic functions in haskell are just polymorphic
05:14:31 <Arafangion> Eduard_Munteanu: Now, THAT was where my confusion came in.
05:14:33 <Eduard_Munteanu> In that case, C++ simply does what Haskell does, erasure.
05:14:49 <Arafangion> Eduard_Munteanu: It seems that Haskell does not do SFINAE.
05:14:58 <Eduard_Munteanu> What's SFINAE?
05:15:05 <merijn> Arafangion: For example, a compiled implementation of "id :: a -> a" in some library can be linked into another application that uses types that didn't exist when "id" was compiled and it will still work
05:15:25 <quicksilver> C++ templates are,  more or less, a compile-time macro system.
05:15:28 <Arafangion> Eduard_Munteanu: Substitution Failure Is Not An Error.
05:15:38 <merijn> Arafangion: Clearly that doesn't work with C++ templates
05:15:40 <quicksilver> they can be thought of as generating code per instance
05:15:58 <quicksilver> haskell polymorphism *can* be compiled in one go - and that's what GHC does in general.
05:16:09 <quicksilver> although the code generation approach will produce better code.
05:16:14 <Arafangion> Eduard_Munteanu: It means you can write several versions of a template.  And then you can call the template with arguments that have types...  Only the template that can work with those types gets applied.
05:16:29 <Arafangion> The remaining effectively don't exist, and can probably be completely broken or nonsensical.
05:16:38 <aristid> quicksilver: would be nice if there was a pragma to tell it to use the code generation approach:)
05:16:41 <Eduard_Munteanu> That's basically what a class / type family does, seems to me.
05:16:46 <Arafangion> (But could apply, correctly, in other parts of the program)
05:16:53 <quicksilver> aristid: there is!
05:16:57 <aristid> quicksilver: which?
05:17:00 <Arafangion> Eduard_Munteanu: C++ templates can define a class, which only _partially_ applies to a type.
05:17:07 <quicksilver> aristid: {-# SPECIALIZE #-}
05:17:16 <Arafangion> Eduard_Munteanu: The remaining methods of that class, which make no sense for the type, don't get generated.
05:17:20 <aristid> quicksilver: hmm
05:17:23 <Eduard_Munteanu> Ah.
05:18:15 <Arafangion> Eduard_Munteanu: It's very complex, I quite like it although the syntax is awful.  I think I prefer the F# and Haskell appraoches, but I am aiming to fully understand them at the same time.
05:18:33 <Eduard_Munteanu> C++ templates are more powerful, yeah.
05:18:36 <Arafangion> (Incidentally, I find that 'generics", as they exist in Java and .NET, tend to be very, very poor)
05:19:08 <timmot> Is there much of a difference between foldl (*) 1 xs and foldr (*) 1 xs?
05:19:19 <Eduard_Munteanu> Arguably TH can stand for arbitrary templating.
05:19:38 <aristid> timmot: not for commutative (*), seminatically. but there's a huge operational difference
05:19:41 <Eduard_Munteanu> timmot: yes, the latter will overflow the stack for normal numbers
05:19:46 <yesthisisuser> Is LambdaCase a recent language extension? I am getting an error "unsupported extension"
05:20:01 <aristid> timmot: i think you probably want foldl' (*) 1 xs
05:20:04 <Arafangion> Anyway, thanks for the discussion. I must sleep now. :)
05:20:06 <aristid> *semantically
05:20:08 <Eduard_Munteanu> The former will too, but foldl' is what you really want.
05:20:58 <ffwacom> asdf
05:21:06 <ffwacom> YOU MENA HASKELL???
05:21:07 <timmot> aristid: Eduard_Munteanu: i'll run through some larger numbers, thanks for the strictness reminder
05:21:17 <Jamie7799> hi all, i'm trying to create a balanced binary tree from a sorted integer list http://pastebin.com/KXNJmTTy. i know what i have to do - i want to insert the middle element of the list first, followed by the middle elements of the first & second halves of the list next and so on in a BFS fashion. i'm having trouble putting that logic in one function line
05:21:51 <ffwacom> Jamie7799: hire an indian if you want your homework done
05:21:54 <Eduard_Munteanu> timmot: note plain foldl (*) will often be optimized at -O and -O2 to foldl'
05:22:01 <quchen> ffwacom: Watch your tone.
05:22:11 <ffwacom> quchen: racist
05:22:17 <quchen> @where ops
05:22:17 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
05:22:23 --- mode: ChanServ set +o dcoutts
05:22:46 <ffwacom> quchen: nice try
05:23:15 <timmot> Eduard_Munteanu: is it often the case that a function will be optimised to its strict version?
05:23:17 <ffwacom> what made you so pro censorship?
05:23:24 <dcoutts> ffwacom: this isn't a good channel to be abusive on, be nice or we'll have to ask you to leave.
05:23:39 <ffwacom> dcoutts: it's a yearly thing for me
05:23:59 <Eduard_Munteanu> timmot: not as often as we'd want
05:24:46 <Jamie7799> ffwacom: sorry i didn't mean i wanted this done for me. i'm just unsure as to how to implement BFS like logic in haskell. esp since i want to do more than one step in each recurse
05:25:05 <Eduard_Munteanu> timmot: in this case I conjecture the compiler knows about (*) being strict on numeric types, but in other cases you don't have a strict operation, yet strictifying it would benefit performance.
05:25:34 <quchen> Jamie7799: Don't worry, your question is ontopic.
05:25:47 <ffwacom> ^
05:25:56 <ffwacom> i gotta bail
05:26:05 <ffwacom> just here to keep up my irc log record
05:26:10 <ffwacom> google ffwacom baha
05:26:13 <ffwacom> o7
05:26:19 --- mode: ChanServ set +o byorgey
05:26:19 <ffwacom> gods speed haskellers
05:26:25 --- mode: byorgey set +b *!*ffwacom@*.lnse1.cha.bigpond.net.au
05:26:25 --- kick: ffwacom was kicked by byorgey (ffwacom)
05:26:39 --- mode: ChanServ set -oo byorgey dcoutts
05:28:15 * hackagebot ixset-typed 0.1.1 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-typed-0.1.1 (AndresLoeh)
05:28:26 <byorgey> Jamie7799: I suggest starting by writing a function  splitHalves :: [a] -> ([a], a, [a])
05:28:36 <timmot> Eduard_Munteanu: i was testing these in ghci and didn't receive any stack overflows until [1..1e8] (the foldl version crashed ghci at this point), is this what you eant by normal numbers?
05:28:41 <byorgey> which splits out a list into the middle element and the parts on either side
05:29:06 <byorgey> then you should be able to use this recurisvely to build your tree
05:29:59 <jesyspa> Jamie7799: If you store the value in the node, I don't think you want to use insert; you're basically gluing two trees and a value back together, not inserting a value into an existing tree.
05:38:16 * hackagebot mangopay 1.0 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.0 (FelipeLessa)
05:38:18 * hackagebot yesod-mangopay 1.0 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.0 (FelipeLessa)
05:38:44 <yesthisisuser> Is there an official policy regarding reliance on language extension in Hackage packages?
05:41:02 <Beginner-HSKL> Hello
05:41:02 <merijn> yesthisisuser: Not really
05:41:08 <Beginner-HSKL> Good Afternoon all
05:41:21 <Beginner-HSKL> I'm a beginner
05:41:38 <Beginner-HSKL> my second day trying things out using the Haskell interpreter
05:42:04 <Beginner-HSKL> Please I am kinda confused about sqrt (3^2 + 4^2)
05:42:14 <srhb> Beginner-HSKL: What about it?
05:42:29 <Jamie7799> byorgey: i tried writing the splithalves function but i'm getting a type error http://pastebin.com/UvTZ2A6w
05:43:00 <tdammers> try lpaste
05:43:03 <tdammers> @where lpaste
05:43:04 <lambdabot> http://lpaste.net/new/haskell
05:43:25 <tdammers> it'll give you ghc error messages, and people here prefer it to pastebin
05:43:59 <merijn> tdammers: GHC error messages?
05:43:59 <ion> jamie: The type signature of middle says i (the caller) can pick any “a” of my choice but the code dictates that the result must be an Int.
05:44:10 <tdammers> well, error messages
05:44:23 <merijn> tdammers: It only runs hlint, pretty sure it doesn't do errors
05:44:28 <tdammers> right
05:44:32 <tdammers> I am being confused
05:44:40 <tdammers> never mind
05:44:47 <tdammers> (but the part about preference stands)
05:45:07 <Jamie7799> tdammers: ah cool thanks, http://lpaste.net/102139.
05:45:34 <quicksilver> Jamie7799: you say that middle will return a list element
05:45:45 <quicksilver> whoops, slightly scrolled up
05:45:48 <quicksilver> what ion said :)
05:45:50 <spacekitteh> how can i tell cabal to reinstall everything?  :<
05:46:41 <ion> spacekitteh: That sounds like Y. What’s X? :-) http://mywiki.wooledge.org/XyProblem
05:46:48 <Beginner-HSKL> srhb: Oh, I get it now I understand what it all is
05:47:18 <Beginner-HSKL> srhb: I was mixing the word "square" and "square root"
05:47:21 <spacekitteh> ion: Broken dependencies.
05:47:38 <spacekitteh> ion: A shitton of them.
05:47:41 <Jamie7799> ion: oh, how does the code dictate that? i thought !! selects the nth element from a list?
05:48:19 <ion> spacekitteh: I recommend using cabal sandboxes. I have one for my home directory and one for each cabalized project.
05:48:21 <Beginner-HSKL> srhb: it got me confused.. thanks for responding. Please pardon me @Challel
05:48:30 <Jamie7799> that should make it independent of what type the elements of the list have, or is that wrong?
05:48:52 <spacekitteh> ion: Gentoo installs cabal stuff into the world cabal
05:49:00 <ion> @type let middle l = div (length l) 2 in middle
05:49:02 <lambdabot> [a] -> Int
05:50:09 <ion> jamie: Given “middle :: [a] -> a”, i should be able to get a Char out of “middle (foo :: [Char])”. But that does not match the code.
05:50:41 <Jamie7799> ohhh right. so making the type constraints more rigid for 'middle' should fix that right?
05:50:46 <srhb> Jamie7799: You're probably thinking that your type signature is "sufficiently general" for middle -- that's not how it works. You're promising, with the signature, that it's more general than it actually is.
05:50:57 <Jamie7799> ahh
05:51:49 <Jamie7799>     where middle :: [a] -> Int makes it compile. thanks guys!
05:57:01 <Beginner-HSKL> Hello.. I am still trying haskell our in hugs
05:57:14 <srhb> Beginner-HSKL: You should probably switch to ghci. And just ask your question. :)
05:57:34 <Beginner-HSKL> whats the difference between>>   not False || True   and    not (False || True)
05:57:54 <opqdonut> Beginner-HSKL: not False || True is the same as (not False) || True
05:57:54 <srhb> Beginner-HSKL: not False == True
05:57:57 <Beginner-HSKL> The first one returns a TRUE and the other one returns a FALS
05:58:18 * hackagebot bugzilla 0.1.0.0 - A Haskell interface to the Bugzilla native REST API  http://hackage.haskell.org/package/bugzilla-0.1.0.0 (swift)
05:58:27 <Beginner-HSKL> FALSE*
05:58:47 <Jamie7799> sorry i have one more q - for the function buildBinary:: [Integer] -> BinaryTree, how do I create a binary tree to use? in an imperative language, you can declare a new binaryTree class or whatever and start inserting stuff into it straight away. but how do you insert the first element into the tree in Haskell when the insert function has the following property insert :: Integer -> BinaryTree -> BinaryTree
05:58:52 <ion> beginner-hskl: Yeah, hugs is old and unmaintained. You really should use ghci.
05:59:14 <ast_> trying to install gtk2hs with latest gtk3 on windows 7, getting lots of CULLong errors from pango and gio. Like https://stackoverflow.com/questions/20908829/cullong-type-constructor-not-visible-when-installing-pango-and-gio-with-cabal-on
05:59:29 <ast_> anyone using it with gtk3 on windows?
05:59:34 <ast_> linux works fine
05:59:48 <srhb> Beginner-HSKL: not False || True = True || True = True. Wheras not (False || True) = not True = False.
05:59:55 <Jamie7799> it seems like you already need a binaryTree to start off with judging by that function
06:00:00 <Beginner-HSKL> srhb: I will switch to ghci but I need to practice with WinHugs for the sake of my test. There may be some little difference between GHCI and WinHugs(to what extent, I don't know) as the reload is :r for ghci and :reload for hugs
06:00:20 <ion> jamie: Given an input of type [Integer], what are the two patterns you can match against?
06:00:30 <srhb> Beginner-HSKL: Short answer, function application binds more tightly than operators.
06:02:02 <Jamie7799> ion: erm not sure i understood your question (i'm 3 days old in the haskell world haha) but would it be an empty list and a non-empty list?
06:02:26 <ion> jamie: Correct. So buildBinary (x:xs) = …; buildBinary [] = …
06:02:30 <hamishmack> ast_: Make sure you gtk2hsC2hs --version is at least 0.13.9
06:02:43 <ion> jamie: Can you fill in the code for the [] case?
06:04:03 <Beginner-HSKL> srbh: sorry if I do not sound really into Haskell at the moment. If  not (False || True) returns FALSE, While does not False || True returns TRUE? It it because of the parentheses?
06:04:05 <ast_> hamishmack: I have 0.13.9
06:04:13 <srhb> Beginner-HSKL: Yes
06:04:23 <Beginner-HSKL> I meant to say why*
06:04:27 <srhb> Beginner-HSKL: The parentheses forces False || True to be evaluated before not
06:04:47 <srhb> wihtout parantheses, not False || True evaluates to True || True
06:05:00 <srhb> With parantheses, it evaluates to not (True)
06:06:00 <Jamie7799> ion: would it be a Leaf? (the empty node in my binary tree hw implementation). so buildBinary [] = Leaf
06:06:27 <srhb> Beginner-HSKL: Just like in basic arithmetic, you know that in 2 + 3 * 2 is 12 while (2 + 3) * 2 = 10
06:06:28 <Beginner-HSKL> srhb: Oh really? Thank you very much. :D
06:06:56 <srhb> Beginner-HSKL: That is, * has higher precedence than +. Here, the function application (not foo) has higher precedence than ||
06:07:39 <srhb> er... 8
06:07:41 <srhb> :P
06:07:53 <srhb> Basic arithmetic is hard.
06:08:13 <ion> jamie: Yeah, whatever is the empty tree in the BinaryTree API, that’s the right implementation. Now, in the other case, you have an “x :: Integer” and an “xs :: [Integer]”. How far toward the correct implementation can you get with them?
06:08:17 <Beginner-HSKL> srhb: how did you get 12?
06:08:22 <Beginner-HSKL> its 8
06:08:23 <srhb> Beginner-HSKL: That was a mistake, I meant 8.
06:08:27 <srhb> Brainfart.
06:08:34 <Beginner-HSKL> Oh yeah.. You corrected yourself..haha :D
06:08:35 <srhb> Beginner-HSKL: The point still stands though.
06:08:50 <Beginner-HSKL> Brainfart? lol .. Okay
06:09:04 <Jamie7799> ion: i'll give it a shot. thanks so much for your help so far btw!!
06:09:09 <Beginner-HSKL> Yeah, I'll stick to the point. That's important
06:09:24 <hamishmack> ast_: Have you done a cabal update recently (it should be building gio-0.12.5.3)?
06:09:30 <srhb> Beginner-HSKL: Anyway it's a general rule in Haskell. Function application has highest precedence. Operators less than that.
06:09:31 <ion> jamie: np. Feel free to ask if you get stuck.
06:10:32 <ast_> hamishmack: yes, I'm building 0.12.5.3
06:11:28 <hamishmack> errors in that stack overflow article are for gio-0.12.5.0 though (might be different problem)
06:12:26 <hamishmack> if you are building it in place and upgraded gtk2hs-buildtools, then you might need to do a cabal clean
06:12:40 <ast_> hamishmack: ok, i'll try that
06:13:33 <Beginner-HSKL> srhb: Thanks. Got to go. Will come back when I need some quick explanation :)
06:13:43 <ast_> hamishmack: got "cabal: No cabal file found" when I'm running it without arguments
06:15:40 <quchen> Installing ThreadScope is quite the adventure.
06:16:05 <quchen> I guess that's why it's precompiled in the Debian repos.
06:17:38 <hamishmack> ast_: hpaste the output of “cabal install”, it might have some clues
06:19:53 <ast_> hamishmack: lpaste.net/102143
06:21:24 <dodec> Hi, can someone help me with a haskell problem i cant solve?
06:23:21 * hackagebot hs2048 0.1.0 - A 2048 clone in Haskell.  http://hackage.haskell.org/package/hs2048-0.1.0 (taylorfausak)
06:28:22 * hackagebot ixset-typed 0.1.2 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-typed-0.1.2 (AndresLoeh)
06:32:47 <hamishmack> ast_: I have to go.  That file (Types.chs) is generated by gtk2hsTypeGen (from gtk2hs-buildtools) it seems like something must be going wrong with that step.
06:33:36 <ast_> hamishmack: thanks, i'll try to purge the installation and try again from scratch
06:44:54 <spacekitteh> how can i write a rewrite rule which would be like the following: {-# RULES "mulCompensable" forall f. Compensable f => mul :: f -> f -> f = mulCompensated #-} ?
06:48:25 * hackagebot json-schema 0.4 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.4 (ErikHesselink)
06:48:27 * hackagebot thumbnail-plus 1.0.1 - Generate thumbnails easily and safely.  http://hackage.haskell.org/package/thumbnail-plus-1.0.1 (FelipeLessa)
06:50:42 <spacekitteh> oh, it doesn't seem it's possible. damn.
06:55:33 <flebron> Hi. I've a function which returns an a, where Data.Aeson.FromJSON a. Say I "know" that this a will have a field "foo" which has a field "bar" which is an Integer. Can I read this ".foo.bar" without creating a full on type?
06:56:03 <tdammers> flebron: you can decode into Aeson's intermediate types (Value)
06:56:29 <tdammers> flebron: but I guess just creating the type might be easier. Or not, it depends.
06:56:38 <flebron> Ah, so I can unify a with Data.Aeson.Value and then use lenses on the Value?
06:57:37 <edwardk> flebron: a^?key "foo.key "bar"._Integer
06:57:42 <edwardk> flebron: (using lens)
06:58:06 <tdammers> so... yes :D
06:58:38 <flebron> Thanks :) (It's a Facebook reply object, which can get quiiite large. I plan on patching the fb package when I'm done with this :))
06:59:10 <tdammers> if you don't control the other end, using untyped Values may be a better bet
06:59:28 <tdammers> so yeah, I'd just parse to Values and extract what you need
06:59:32 <flebron> I don't, but the returned object is specified in FB's documentation
06:59:50 <tdammers> hmm, yeah, but still...
07:00:01 <tdammers> also, I bet you only need a small fraction of the response anyway
07:00:08 <flebron> Yep :)
07:00:19 <tdammers> so implementing it all as data types just to extract that small bit is probably overkill
07:00:25 <dgpratt> is there a way to query lambdabot for the source of a class instance?
07:00:45 <merijn> dgpratt: Do you mean the *actual* source?
07:01:03 <dgpratt> probably not, merijn
07:01:06 <merijn> dgpratt: If so, the answer is "No", because there is no way to query the actual source of anything from lambdabot
07:01:22 <dgpratt> @src map
07:01:22 <lambdabot> map _ []     = []
07:01:22 <lambdabot> map f (x:xs) = f x : map f xs
07:01:31 <dgpratt> where does that come from? the report?
07:02:00 <merijn> dgpratt: lambdabot has a database, some of the stuff is from the report, others is just hand put in there
07:02:10 <dgpratt> I see
07:03:24 <merijn> I usually just go to hoogle and press "source"
07:03:25 <dgpratt> so is it possible that lambdabot knows about (say) "Monoid Int" and if so, how do I find out?
07:04:12 <dgpratt> nvm as to the specifics of that question :)
07:04:20 <merijn> @src Monad Maybe
07:04:21 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:04:25 <merijn> @src >>= Maybe
07:04:26 <lambdabot> Source not found. My pet ferret can type better than you!
07:04:28 <merijn> hmm
07:04:35 <merijn> Guessing, basically
07:04:38 <dgpratt> I forgot there were multiple instances of monoid for Int :)
07:05:43 <khyperia> @src Maybe (>>=)
07:05:44 <lambdabot> (Just x) >>= k      = k x
07:05:44 <lambdabot> Nothing  >>= _      = Nothing
07:05:56 <dgpratt> a ha
07:06:15 <khyperia> merijn, all the sources are listed here - https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source - the first line after every double-line-break is the name, followed by the source.
07:07:07 <dgpratt> thanks khyperia, merijn
07:15:02 <khyperia> @src on
07:15:02 <lambdabot> (*) `on` f = \x y -> f x * f y
07:15:13 <khyperia> I did NOT know you could bind arguments to infix operators.
07:15:48 <khyperia> just tested it in ghci, "let f ($@) x = x $@ x in f (+) 2" spits out 4.
07:17:03 <greg> wh
07:17:19 <greg> what does (*) do?
07:17:24 <greg> @src (*)
07:17:25 <lambdabot> Source not found. Just try something else.
07:17:28 <khyperia> greg, it's an argument.
07:17:41 <greg> yes but its used
07:17:54 <greg> ah just multiply
07:17:56 <khyperia> look at my let example
07:18:03 <khyperia> no, in this context, it's not multiply
07:18:13 <greg> lol
07:18:20 <khyperia> it's a two-argument function passed into `on`
07:18:39 <greg> your let example is on github
07:18:41 <greg> ?
07:18:47 <khyperia> no, I just posted it in chat.
07:19:02 <khyperia> "let f ($@) x = x $@ x in f (+) 2"
07:19:03 <greg> i missed it , just logged on, can you post again?
07:19:15 <khyperia> you logged in before I posted that...
07:20:06 <greg> ah , i think im a little tired today
07:20:15 <quchen> (I asked this yesterday already, but didn't get a definitive answer.) How does parallel (Control.Parallel.Strategy) evaluation work? As far as I know, "xs `using` parList" is a thunk that sparks all elements of "xs" when evaluated, and these sparks are immediately worked on. However, "main = (print . take 3) ([1,2,3,4,undefined] `using` parList rseq)" does not crash: although the "undefined" list element is sparked, it does not create an er
07:20:15 <quchen> ror. +RTS -s shows one spark as fizzled, and that's presumably that "undefined". Now I'm confused about how laziness, bottoms and parallelism play together.
07:20:26 <greg> this doesnt explain what (*) is
07:20:43 <merijn> greg: A variable
07:20:49 <quchen> Here's the test code I used: http://lpaste.net/102154
07:20:50 <merijn> greg: It's an operator variable
07:20:59 <khyperia> my let example is the same as:
07:21:08 <greg> ah ok
07:21:12 <khyperia> > let f thing x = x `thing` x in f (+) 2
07:21:14 <lambdabot>  4
07:21:20 <khyperia> but only `thing` is named ($@)
07:27:54 <haasn> f = join
07:33:30 * hackagebot ixset-typed 0.1.3 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-typed-0.1.3 (AndresLoeh)
07:41:42 <vozz_> Does anyone know of a good library for locating certain things in images? Like if I have a small image and want to know where it is in the big image?
07:42:22 <irene-knapp> if there’s any open-source software that can do that, I’m not aware of it
07:42:47 <irene-knapp> Google image search does it, obviously.  what you want to research to implement your own is feature-preserving image hashes.
07:42:47 <vozz_> I know openCV can do that, just the openCV bindings for haskell arent very complete
07:43:09 <irene-knapp> ah, okay
07:43:26 <irene-knapp> then your best attack is probably to submit a patch for them :)
07:43:37 <vozz_> I suppose so :P
07:45:28 <Benzi-Junior> I'm getting a no parse runtime error because of the following call : modifyIORef iref (++ "happiness"++ x ++"morehappiness ")
07:45:36 <peteretep> It's easy enough to do that in a naive way
07:46:00 <peteretep> If you know the scale
07:46:37 <Benzi-Junior> or rather when I try to read from iref it causes the problem
07:47:23 <Benzi-Junior> I don't really understand why (x has type String)
07:48:07 <c_wraith|N10> No parse as a runtime error comes from a call to read
07:48:31 * hackagebot esqueleto 1.3.6 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.6 (FelipeLessa)
07:48:37 <quchen> Benzi-Junior: Paste your code?
07:48:39 <c_wraith|N10> Were you initializing the IORef with a value from a call to read?
07:48:42 <quchen> @where paste
07:48:43 <lambdabot> Haskell pastebin: http://lpaste.net/
07:48:54 <MagneticDuck> hey haskellers, anybody here using ghcmod-vim?
07:49:25 <MagneticDuck> I'm getting a really strange error; it always gets a parse error when it tries to parse hlint's output!
07:50:26 <fizruk> MagneticDuck: i use only GhcModCheck command :\
07:51:09 <Benzi-Junior> reikna hlaði globals föll þula gildi = do modifyIORef þula (++"(MakeVal " ++ gildi ++ ")\n"))
07:51:14 <Benzi-Junior> quchen: ^
07:53:06 <c_wraith|N10> Benzi-Junior: the problem is not on that line. The problem is a call to read.
07:54:23 <c_wraith|N10> Benzi-Junior: laziness will only make the exception from the call to read be thrown when you try to pattern match it's result, though.
07:54:55 <c_wraith|N10> *its result. Autoincorrect strikes again.
07:54:56 <Benzi-Junior> c_wraith|N10: if I replace (++ "(MakeVal " ++ gildi ++ ")\n"))  with (++ "(MakeVal" ++ ")\n") it works fine
07:55:31 <c_wraith|N10> Benzi-Junior: yep. The problem is the call to read used in the definition of gildi
07:56:16 <Benzi-Junior> c_wraith|N10: oh I thought you meant when I read from þula
07:57:12 <c_wraith|N10> Benzi-Junior: this is why quchen asked you to paste all your code on lpaste.net.
07:57:47 <c_wraith|N10> Benzi-Junior: then we could have pointed you at a line number, instead of having to guess like I was doing.
08:16:55 <pearson> hi, I am doing the 99 problems for Haskell. Is it actually helpful looking under the solutions if you have a theoretical idea, but do not know how to implement the solution?
08:18:55 <quchen> Having a theoretical idea about driving does not suffice to get a driver's licence.
08:19:07 <shapr> but it gets you started!
08:19:18 * shapr grinds the gears, write the code
08:19:59 <quchen> shapr: You're a particularly bad example of how to get help, because not everyone can bootstrap a 1000+ user channel to get help for himself.
08:20:10 <quchen> :>
08:20:36 <shapr> haha
08:20:40 <shapr> worked for me!
08:21:06 <yogert> Hmm I seem to be having trouble understanding the type of WriterT. It's parameterized by three types. The "writing type", the inner monad, and the output value. WriterT w m a. Correct?
08:21:16 <merijn> yogert: Right
08:21:28 <merijn> @unmtl WriterT w m a
08:21:28 <lambdabot> m (a, w)
08:21:56 <yogert> Okay, so I guess I'm not understanding the implications of that one sec. I'll make an lpaste
08:23:35 * hackagebot aws 0.8.6 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.8.6 (AristidBreitkreuz)
08:24:54 <yogert> http://lpaste.net/8496046057153626112
08:25:18 <yogert> The error talks about inappropriate kinds
08:25:59 <yogert> I understand that it doesn't want a concrete type ( i think thats what its called )
08:26:24 <yogert> but how should I determine that from the type itself?
08:26:43 <bartavelle> it has a "Monad m" constraint
08:27:08 <yogert> is that the  "| m -> w" part?
08:27:17 <geekosaur> no
08:27:18 <bartavelle> class (Monoid w, Monad m) => MonadWriter w m | m -> w where
08:27:24 <bartavelle> that's the "Monad m => " part
08:27:40 <quchen> Ignore the "m -> w" part, it's a helper for the typechecker, and not really needed to understand WriterT.
08:28:56 <merijn> I would ignore the entire existence of MonadWriter
08:29:05 <merijn> It's completely irrelevant
08:29:15 <bartavelle> and will give you leaks
08:29:18 <yogert> I don't understand the significance  of the constraint i guess… Why doesn't (StateT Foo m a) qualify?
08:29:29 <yogert> well I'm just learning about monad transformers in general
08:29:57 <merijn> yogert: because the 'm' has to be a monad and monads take 1 type as argument
08:30:13 <merijn> StateT with 3 arguments takes no argument type
08:30:50 <merijn> StateT with 2 arguments is partially aplied and *does* take a type as argument
08:30:55 <yogert> You mean I'd write it like StateT Foo (m a)
08:30:56 <yogert> ?
08:31:10 <merijn> @unmtl WriterT Foo (StateT s m a) a
08:31:11 <lambdabot> (StateT s m a) (a, Foo)
08:31:43 <merijn> See how that makes no sense? Applying fully applied StateT to (a, Foo)
08:31:58 <merijn> @unmtl WriterT Foo m a
08:31:58 <lambdabot> m (a, Foo)
08:32:06 <yogert> what is unmtl doing?
08:33:04 <bartavelle> WriterT { runWriterT :: m (a, w) }
08:33:19 <bartavelle> it just shows you what the "actual function" is
08:34:01 <merijn> It says "WriterT w m a" is just a newtype for...
08:34:51 <aristid> @unmtl Writer Foo a
08:34:52 <lambdabot> (a, Foo)
08:35:02 <yogert> ah
08:35:05 <yogert> i understand
08:35:18 <aristid> in reality Writer is a type alias to WriterT
08:35:38 <aristid> but logically it is like (a, Foo)
08:36:02 <yogert> So if I were to write something like StateT Foo m a, the writerT would have to return (m a)(a,w)?
08:37:13 <bartavelle> m (Foo,(a,w)) perhaps ?
08:38:01 <schell> is there a channel for haste?
08:38:21 <merijn> yogert: Basically, if "m" is a Monad, then "StateT s m" is a monad (hence, monad transformer), so since "WriterT" wants a monad, you can pas "StateT s m" as the monad for WriterT
08:38:25 <geekosaur> yogert: you don't have control over the a supplied to StateT there
08:38:42 <yogert> Well in his above example "WriterT Foo (StateT s m a ) a" results in (StateT s m a) (a, Foo), which doesnt make sense because StateT s m a is fully applied
08:38:48 <geekosaur> it's supplied by WriterT
08:38:48 <yogert> Hence the kind error i get
08:39:01 <merijn> yogert: Right, so "Don't Do That, Then"
08:40:12 <Benzi-Junior> is there a function that works like mapM except it performs a intermediate function call ?
08:40:39 <yogert> Okay, and the Monad constraint ( Monad m => … ) on the type tell me this because (StateT Foo m a) isn't an "m"  but an "m a"
08:40:55 <yogert> err no
08:41:00 <iota_> Benzi-Junior: what do you mean ?
08:41:24 <yogert> Oh yes. i think thats correct
08:42:14 <brainacid> hi
08:42:24 <merijn> yogert: Right
08:42:37 <yogert> Cool
08:42:38 <merijn> yogert: So, one sidenote that's useful to know is "kinds"
08:42:39 <yogert> thanks you
08:43:12 <merijn> yogert: Kinds are the "types of types", with "normal" (or concrete) types having the kind *. So 5 :: Int and Int :: * (Int has kind *)
08:43:53 <merijn> yogert: Higher order types (like Maybe) can have more complicated kinds, like "Maybe :: * -> *" that is, Maybe takes a type of kind * (such as Int) and returns a type of kind *
08:44:11 <yogert> I take it that kinds are more than just the number of arguments it takes?
08:44:19 <merijn> yogert: For example, "StateT :: * -> (* -> *) -> * -> *"
08:44:44 <merijn> yogert: Note how the second (monad) argument has kind "* -> *", because the second argument has to be a type that takes a type argument!
08:45:13 <Benzi-Junior> iota_: I'm using mapM to perform a IO on each element on the list so the operations go "io a, io b, io c" I want to inject a second function (that does an IO) so I would get "io a, other, io b, other ,io c"  and yes I know I'm doing something horrible
08:45:17 <mornfall> merijn: what'd happen if you collapsed the kind<->type hierarchy?
08:45:29 <merijn> Hence, when you were doing "WriterT w (StateT s m a) a" you got a kind error, because "StateT s m a :: *" and Writer expects "* -> *" s second argument!
08:46:07 <yogert> ah i see
08:46:08 <mornfall> i.e. types would be kinded with types again :)
08:46:09 <merijn> mornfall: Inconsistency
08:46:32 <mornfall> hm, that's bad... what sort?
08:46:35 <merijn> mornfall: To avoid the inconsistency most dependently typed languages have an infinite hierarchy of kinds
08:46:47 <merijn> mornfall: Of the logical sort :)
08:47:04 <merijn> mornfall: Probably it'd ruin your ability to do type inference, etc. but I'm not an expert
08:47:48 <yogert> So now, what so bad about the WriterMonad? Its just not all that useful?
08:47:51 <mornfall> merijn: type inference is possibly a small sacrifice
08:48:12 <merijn> yogert: It's not bad, it's quite useful, but it's not needed to understand transformers
08:48:21 <mornfall> merijn: lack of soundness is a lot worse
08:48:22 <merijn> yogert: It's more of a convenience once you understand transformers
08:48:56 <merijn> yogert: i.e. if you have triple nested transformer and you want to access the StateT somewhere in your stack you'll have to "lift" a bunch of times
08:49:15 <merijn> yogert: MonadWriter, MonadState, etc. "automatically" lift stuff the right number of times for you
08:49:22 <iota_> Benzi-Junior: you can use map to make a list of your IO actions, then add the supplementary ones and sequence everything
08:49:29 <mornfall> merijn: also I'm not sure if there's a difference between an infinite kind tower with everything automatically promoting all the way up and a 1-level system
08:49:45 <merijn> mornfall: Neither am I :p
08:49:50 <merijn> mornfall: Try #agda ;)
08:50:04 <mornfall> merijn: nah, they'll try to explode my head...
08:51:58 <yogert> merijn, that is, if the monad you are in is an instance of those… right?
08:52:38 <merijn> yogert: Right, but the library provides default instances for all the standard transformers :)
08:53:09 <yogert> Ah, so I can derive them?
08:53:19 <merijn> yogert: Basically, I would just use plain transformers and only worry about MonadWriter, etc. when you see yourself writing "lift . lift . lift" :)
08:53:34 <merijn> yogert: In most cases you won't need to do anything
08:53:39 <silasdavis> I'm having a problem installing mtl for dbus-client
08:53:49 <silasdavis> dies with:
08:53:51 <silasdavis> Control/Monad/Error/Class.hs:93:18: Not in scope: `catch'
08:53:51 <silasdavis> Failed to install mtl-2.0.1.0
08:54:00 <yogert> okay. well thanks for all the help!
08:54:02 <yogert> : )
08:54:08 <t7> :t lift . lift . lift
08:54:08 <silasdavis> does anyone else have this issue?
08:54:09 <lambdabot> (Monad (t1 (t2 m)), Monad (t2 m), Monad m, MonadTrans t, MonadTrans t1, MonadTrans t2) => m a -> t (t1 (t2 m)) a
08:54:23 <t7> :t lift . lift . lift . lift . lift . lift . lift . lift . lift
08:54:24 <lambdabot> (Monad (t1 (t2 (t3 (t4 (t5 (t6 (t7 (t8 m)))))))), Monad (t2 (t3 (t4 (t5 (t6 (t7 (t8 m))))))), Monad (t3 (t4 (t5 (t6 (t7 (t8 m)))))), Monad (t4 (t5 (t6 (t7 (t8 m))))), Monad (t5 (t6 (t7 (t8 m)))), Monad (t6 (t7 (t8 m))), Monad (t7 (t8 m)), Monad (t8 m), Monad m, MonadTrans t, MonadTrans t1, MonadTrans t2, MonadTrans t3, MonadTrans t4, MonadTrans
08:54:25 <lambdabot> t5, MonadTrans t6, MonadTrans t7, MonadTrans t8) => m a -> t (t1 (t2 (t3 (t4 (t5 (t6 (t7 (t8 m)))))))) a
08:54:29 <t7> :O
08:55:38 <merijn> silasdavis: Looks like it depends on an mtl version from before the move of the 'catch' function
08:55:54 <merijn> silasdavis: Most reasonable solution would be to get dbus-client updated to work with a newer mtl
08:56:01 <silasdavis> I can install a more recent mtl though, how would I go about editing the dependency of dbus-client?
08:56:17 <silasdavis> merijn, what do you think my chances of it just working are?
08:56:28 <merijn> silasdavis: dbus-client is marked obsolete on hackage
08:56:35 <silasdavis> ah
08:56:47 <silasdavis> don't suppose you know of an alternative
08:56:55 <silasdavis> I just want to rig xmonad up with taffybar
08:56:57 <merijn> "Deprecated in favor of dbus"
08:57:05 <merijn> hackage docs have a link
08:57:58 <iota_> Benzi-Junior: sequence . Data.List.intersperse other . map func would do the trick
08:58:49 <dhrosa> it sounds like he wants to perform some (IO b) in between some (IO a) to me?
09:02:18 <merijn> :t intersperse -- ?
09:02:20 <lambdabot> a -> [a] -> [a]
09:02:22 <MagneticDuck> question about automated haskell dev stuff: I'm trying to remember, what tools are there that do things like automatically adding elements to build-depends fields for cabal projects?
09:02:46 <iota_> > intersperse 'a' "foo"
09:02:47 <lambdabot>  "faoao"
09:02:52 <flebron> Is there a name/symbol for flip (<$>)?
09:03:38 <supki> flebron: <&> from lens
09:03:59 <MagneticDuck> @pl (\a f -> fmap f a)
09:03:59 <lambdabot> flip fmap
09:04:06 <MagneticDuck> lambdabot doesn't know about it then
09:04:07 <flebron> Yay :) It just so happens I had imported Lens already. Thanks :)
09:04:19 <MagneticDuck> lenses are cool, I have to learn to use them more
09:06:39 <ion> flebron: Lens also provides (&) for flip ($). If you remember one that’ll work as a mnemonic for the other. :-)
09:10:50 <benzrf> fmap join . join . fmap sequence
09:10:57 <benzrf> ^ is this join for the list MT?
09:21:16 <Eduard_Munteanu> :t fmap join . join . fmap sequence
09:21:17 <lambdabot> (Monad f, Functor f) => f [f [a]] -> f [a]
09:21:39 <flebron> Hi. I'm getting a sort of... dumb error. I can't seem to unify, with A = Data.Aeson, A.value with aeson-0.6.2.1:Data.Aeson.Types.Internal.Value. What could be the problem? Multiple aeson versions installed?
09:21:53 <Eduard_Munteanu> Hm, they left.
09:23:06 <geekosaur> flebron, that sounds like multiple versions, yes
09:23:16 <flebron> Oh I see, lens-aeson made me install aeson-0.6
09:24:26 <Taneb> flebron, I believe lens-aeson is deprecated and merged into lens itself now
09:26:10 <flebron> Yep, unregistering lens-aeson and aeson-6, and changing Control.Lens.Aeson to Data.Aeson.Lens fixed it :) Thanks!
09:28:42 * hackagebot esqueleto 1.3.7 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.7 (FelipeLessa)
09:32:37 <stelleg> anyone know how to write a function from unboxed type to unboxed type?
09:32:49 <stelleg> seems like you should be able to do something like
09:33:41 <stelleg> forall a:#. a -> a
09:34:25 <vlatkoB> In GHCi, cos 49 = 0.3005925437436371, in calculator cos 49 = 0,656059029. Where's the catch?
09:34:31 <vlatkoB> > cos 49
09:34:33 <lambdabot>  0.3005925437436371
09:34:39 <negatratoron> degrees vs radians?
09:34:42 <identity> vlatkoB: ^
09:35:12 <identity> > cos $ 49 * pi / 180
09:35:13 <lambdabot>  0.6560590289905073
09:36:02 <vlatkoB> yeshuah, overlooked it. Thanks
09:37:49 <flebron> Say I have a [Value], with Value in Data.Aeson. How can I use Lens to filter out the ones which have a property "foo" not equal to "bar"? My first attempt gives filter (\x -> x ^? key "foo" <&> (== "bar")), but that returns a Maybe Bool. I can of course make a function that requires that's "Just True", but there's likely a cleaner way :p
09:39:40 <glguy> flebron: filter (\x -> Just "bar" /= preview (key "foo") x)
09:40:32 <glguy> oh, I guess that isn't quite right
09:40:41 <glguy> since you get values that didn't have a "foo" at all
09:41:01 <supki> :t toListOf (folded.filtered (hasn't (ix "foo".only "bar")))
09:41:02 <lambdabot> (Foldable f, Ixed (Accessor All) a, IxValue a ~ [Char], Index a ~ [Char]) => f a -> [a]
09:41:16 <glguy> supki: He wants non-"bar" values
09:41:56 <glguy> filter (maybe False ("bar" /=) . preview (key "foo"))
09:43:00 <supki> > toListOf (folded.filtered (hasn't (ix "foo".only "bar"))) [M.singleton "foo" "bar", M.singleton "foo" "baz"]
09:43:02 <lambdabot>  [fromList [("foo","baz")]]
09:43:40 <glguy> > toListOf (folded.filtered (hasn't (ix "foo".only "bar"))) [M.singleton "foo" "bar", M.singleton "foo" "baz", M.singleton "shouldn't" "be in result"]
09:43:42 <lambdabot>  [fromList [("foo","baz")],fromList [("shouldn't","be in result")]]
09:43:54 <glguy> toListOf (folded.filtered .... is a verbose way to write filtere
09:43:55 <glguy> filter
09:44:28 <supki> oh, sure
09:44:48 <glguy> Oh, ok, and now I'm not convinced that the goal was to excluded things without a "foo" at all
09:44:50 <glguy> having reread things
09:45:30 <glguy> filter (hasn't (key "foo" . only "bar"))    -- would seem to be the right answer, then
09:46:57 <flebron> Wait that's actual syntax?
09:47:26 <_ikke_> ' is valid in identifiers
09:47:41 <flebron> Yeah I just never imagined someone uusing it that way haha
09:47:50 <flebron> (I've always used it as x, x', x'', ...)
09:48:07 <_ikke_> It totally makes sense this way
09:49:12 <saml> is synthesizer good?
09:49:17 <saml> @wiki sythesizer
09:49:17 <lambdabot> http://www.haskell.org/haskellwiki/sythesizer
09:51:30 <sked> @wiki synthesizer
09:51:31 <lambdabot> http://www.haskell.org/haskellwiki/synthesizer
09:53:23 <flebron> glguy: That's magic dude. Thanks :)
09:54:39 <siriusbtx> I have a function shoot :: PlayField -> (Int, Int) -> Maybe PlayField, and if someone is hit, I should print it out somewhere. But I want to keep this function pure, how would I do something like that?
09:55:04 <darthdeus> guys what's the main difference between snap and happstack? I've been playing around with both (not counting yesod, since that's a huge beast), and they both seem very similar, and i'm not really sure which one is more mature/better to pick
09:55:23 <darthdeus> and please don't say it matters on my personal opinion :P because I don't have one even after playing with them
09:55:30 <geekosaur> happstack is the great grandaddy of haskell web interfaces
09:56:07 <glguy> siriusbtx: You can return something like: shoot :: PlayField -> (Int, Int) -> (Outcome, Maybe PlayField)
09:56:15 <glguy> siriusbtx: and then print the Outcome in some way
09:56:22 <geekosaur> it's been renamed to make its purpose clearer, but happs has been around for a long time and is quite stable and mature
09:56:29 <geekosaur> (and still developed)
09:56:29 <glguy> in an impure context outside of shoot
09:56:38 <siriusbtx> glguy: currently I keep a msg field in my PlayField and set that
09:56:56 <siriusbtx> glguy: is that a good idea?
09:57:14 <sked> snap is super-stable also
09:57:15 <stepcut> darthdeus: Happstack has a lot more supported options for things like type-safe urls, type-safe, compile-time templates, etc, plus a nice book
09:57:39 <darthdeus> stepcut: snap has a book too :) http://snapforbeginners.com/ though it's really short
09:58:03 <darthdeus> so happstack is more ... featureful and mature?
09:58:46 * hackagebot yesod-pagination 0.4.0.0 - Pagination in Yesod  http://hackage.haskell.org/package/yesod-pagination-0.4.0.0 (JoelTaylor)
09:58:50 <glguy> siriusbtx: It's probably fine. That's just a matter of the structure of your program. You certainly wouldn't want a pure function to do IO any more than you'd want a function Int -> Int to work on Doubles
09:59:11 <glguy> just change the type to match what it does if you need it to be different
09:59:13 <stepcut> darthdeus: IMO, yes.
09:59:25 <glguy> or split the update and printing in two parts
09:59:27 <glguy> pure and impure
09:59:47 <stepcut> but, any of the haskell frameworks will get the job done
09:59:53 <stepcut> none are bad :)
10:00:15 <darthdeus> cool :)
10:00:55 <sked> darthdeus: my impression is that a lot of people had moved from happstack to snap
10:01:02 <shergill> is there an appropriate mailing list for pl theory dealing with reasoning about the type expressivity of edsl's? and what the limit of that is as a function of the type expressivity of the host language?
10:01:25 <shergill> and/or research papers. i've found some, but wondering if the hive mind has other pointers
10:02:18 <darthdeus> sked: why?
10:02:58 <stepcut> At one point, a lot of people switched to snap, because it was new, and newer is always better :)
10:03:25 <opqdonut> is there a (template haskell?) library that automatically derives zippers?
10:08:47 * hackagebot fb 1.0 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-1.0 (FelipeLessa)
10:13:47 * hackagebot yesod-fb 0.3.2 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.3.2 (FelipeLessa)
10:27:27 <dmj`> is it possible to export a module qualified? So it can be referenced in another module by character prefix?
10:27:50 <shachaf> No.
10:28:17 <mwhitfield> what does that accomplish that qualified imports doesn't?
10:28:29 <flebron> Is there a Vector (Maybe a) -> Vector a, like catMaybes?
10:29:39 <dmj`> mwhitfield: less clutter on the top of the file I suppose
10:33:50 * hackagebot yesod-pagination 0.5.0.0 - Pagination in Yesod  http://hackage.haskell.org/package/yesod-pagination-0.5.0.0 (JoelTaylor)
10:36:58 <skypers> aw
10:37:12 <skypers> (*>) and (<*) are so NICE to hide temporaries
10:37:15 <skypers> like
10:37:30 <skypers> acquire *> treatAndOut <* clear
10:37:34 <skypers> <3
10:38:06 <fizbin1> :t (*>)
10:38:06 <lambdabot> Applicative f => f a -> f b -> f b
10:38:43 <fizbin1> I guess there acquire and clear would both be of type "f ()" ?
10:38:50 * hackagebot checkers 0.3.2 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.3.2 (ConalElliott)
10:38:58 <skypers> yes fizbin1
10:39:17 <skypers> I use that pattern to replace do { acquire; a <- treatAndOut; clear; return a }
10:39:31 <fizbin1> Ah, yes.
10:39:41 <zenkeku> Is it normal for the 'where' clause to be indented like this? http://lpaste.net/102160
10:40:06 <fizbin1> Certainly, if all you need to pass along is the environment and you don't need the value for further manipulations, a Monad is overkill.
10:40:06 <quchen> zenkeku: Parse error, too much profanity
10:41:01 <skypers> fizbin1: yeah
10:41:11 <skypers> plus, I really love how concise code is with Applicative
10:41:24 <zenkeku> quchen: Sorry, I'm following LYAH and I kinda went with the flow of that particular function.
10:41:29 <dmj`> zenkeku: No, the haskell style guide recommends 2 spaces w/ where clauses
10:41:31 <dmj`> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
10:41:35 <skypers> it’s a really nice abstraction I had no clue how to use when I learnt Haskell in the first place
10:42:33 <zenkeku> quchen: It's not been made politically correct.
10:42:43 <fizbin1> I still don't know how to use it except after the fact, when I realize I can go back and clean out some formerly Monadic code with Applicative. I don't know how to recognize it early in the design.
10:43:16 <zenkeku> dmj`: Haskell-mode with emacs indents it as shown.
10:44:09 <kylcarte> fizbin1: general rule of thumb: when you have monadic values that you only use in one place each, start thinking about Applicative
10:44:55 <fizbin1> skypers: For example, that Applicative stuff someone from Facebook gave a talk on for organizing parallelizable computations? I can kind of see how it's an Applicative after the fact, but can't see how to start there.
10:45:00 <dmj`> zenkeku: you can change the indentation level in haskell-mode.
10:45:11 <SwashBuckla> wahoo, my copy of LYAH arrived :3
10:45:24 <kylcarte> eg. do { x <- mx; y <- my; return (x + y) }  ===> (+) <$> mx <*> my
10:45:37 <skypers> fizbin1: I use applicative when I want to embed computation into constructors
10:45:38 <zenkeku> dmj`: Yea, I'm looking into that.
10:45:57 <skypers> like ctor <$> somethingForFirstArg <*> somethingForSecondArg <*> andSoOn
10:45:59 <quchen> flebron: You can write such a function for any Foldable, but I'm not sure how well that performs in case of Vector
10:46:09 <kylcarte> fizbin1: so long as 'my' doesn't use 'x', from that example
10:46:13 <SwashBuckla> :info ctor
10:46:20 <SwashBuckla> @ctor
10:46:21 <lambdabot> Unknown command, try @list
10:46:25 <SwashBuckla> what is ctor?
10:46:27 <fizbin1> kylcarte: Yeah, but you don't usually realize that you're only using the monadic value in one place after the fact, not relatively early when you're deciding whether this structure needs to be a Monad.
10:46:30 <yesthisisuser> Has anyone used Scotty.Trans? scottyT takes 4 arguments; the third is of type (m Response -> IO Response), and called for each action it seems, but what is the purpose of the second argument?
10:46:31 <skypers> SwashBuckla: a common abrev for “constructor”
10:46:39 <skypers> typeconstructor
10:46:41 <shachaf> "only used once" isn't quite the right heuristic.
10:46:42 <skypers> like Just or Nothing
10:47:07 <joehillen> how can I change this to use applicative? \fs x -> and [f x | f <- fs]
10:47:27 <SwashBuckla> skypers: ah ok, thanks. I saw it in the Haskell compiler code for Elm
10:47:53 <vozz_> If I have a list [a] and I want to split it into a list of lists [[a]] such that each [a] has length 6, is there already a function that does this?
10:48:29 <quchen> @hackage split -- vozz_
10:48:29 <lambdabot> http://hackage.haskell.org/package/split -- vozz_
10:48:31 <fizbin1> joehillen: Isn't that \fs x -> and $ f <$> fs
10:48:35 <shachaf> Not in base, but the package split, module Data.List.Split, can surely help you.
10:48:51 <vozz_> ah, chunksOf is what I'm looking for
10:48:51 <fizbin1> joehillen: Not even Applicative there, just Functor.
10:48:56 <skypers> no problem SwashBuckla :)
10:49:02 <joehillen> yeah, I was thinking it might be a map
10:49:06 <vozz_> Thanks a lot
10:49:07 <fizbin1> Oh wait, never mind.
10:49:08 <vozz_> :)
10:49:11 <dmj`> > Data.List.Split.chunk 2 [1..10]
10:49:13 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
10:49:16 <joehillen> fizbin1: but where does f come from
10:49:21 <skypers> the cool thing with <* is is like <$, but for Applicative
10:49:48 <fizbin1> joehillen: I should have said \fs x -> and $ ($ x) <$> fs
10:50:20 <kylcarte> skypers: I think you mean (<*) is like (<<)
10:50:42 <fizbin1> Or more readably, since this is specific to a list (because of "and") anyway: \fs x -> and $ map ($ x) fs
10:50:48 <quchen> joehillen: "all ($ x) fs" is also an alternative.
10:50:56 <skypers> hm, yes kylcarte
10:51:19 <quchen> (<<) is ambiguous. It could be (<*) or (flip (>>)).
10:51:49 <roconnor> @src (<<)
10:51:49 <lambdabot> Source not found. I am sorry.
10:52:01 <fizbin1> :t (<<)
10:52:03 <lambdabot>     Not in scope: `<<'
10:52:03 <lambdabot>     Perhaps you meant one of these:
10:52:03 <lambdabot>       `=<<' (imported from Control.Monad.Writer),
10:52:09 <zenkeku> dmj`: I can't scroll up at the moment (fixing an issue) didn't you post a link with indentation rules?
10:52:16 <roconnor> oh, I guess << doesn't exist?
10:52:28 <quchen> Yes, i.e. no.
10:52:29 <roconnor> because it is confusing.
10:53:21 <dmj`> zenkeku: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
10:53:28 <quchen> I guess "flip >>" would be the better implementation to work nicely with =<<, but since there's do notation for chaining actions anyway there's not that much demand for it I guess.
10:53:32 <zenkeku> dmj`: Thank you.
10:55:05 <benzrf> i figured out the monad instance for the list MT myself (via join)
10:55:07 <benzrf> i feel smart :>
10:55:27 <monochrom> what is "MT"?
10:55:34 <benzrf> monad trans
10:55:35 <benzrf> http://bpaste.net/show/196828/
10:55:39 <monochrom> I see
10:55:58 <quchen> For some value of transformer
10:56:32 <monochrom> yeah, some other monad I figured out by writing join first
10:56:38 <benzrf> >tfw i have no idea what that code does and i only figured out how to make the types line up
10:57:39 <benzrf> quchen: 'some value'?
10:57:41 <benzrf> how so o.o
10:57:44 <quchen> Working types don't imply correct or even working code
10:57:50 <benzrf> >.>
10:57:52 <quchen> Well, ListT is a bit problematic
10:57:54 <benzrf> >tfw
10:58:13 <quchen> It's only a proper transformer (i.e. the transformed thing is a Monad) when the base monad satisfies some laws
10:58:20 <benzrf> oh?
10:59:00 <prophile> only if it's commutative
10:59:09 <dmj`> http://www.haskell.org/haskellwiki/Monad_laws
10:59:26 <prophile> ListT is a weird one
10:59:44 <prophile> some of the common monads are commutative though so it's not entirely useless
10:59:56 <quchen> I think there's a correct ListT in pipes, I've heard of others too
11:00:10 <prophile> https://www.google.co.uk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0CDEQFjAA&url=http%3A%2F%2Fwww.haskell.org%2Fhaskellwiki%2FListT_done_right&ei=tU88U5jyMYHxhQf17YD4Cw&usg=AFQjCNHcpQgjkozF2VHOzrv7Lf_63K9cow&bvm=bv.63934634,d.ZG4
11:00:12 <prophile> ah
11:00:14 <prophile> god damn it google
11:00:19 <prophile> http://www.haskell.org/haskellwiki/ListT_done_right
11:00:23 <monochrom> hehe
11:02:00 <quchen> In other words, when you want to write a basic transformer, do it for Maybe :-þ
11:03:55 * hackagebot propellor 0.2.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.2.0 (JoeyHess)
11:05:52 <siriusbtx> how do I export a type alias from a module?
11:06:11 <dmj`> quchen: or identity :P
11:06:53 <quchen> Well that's like implementing `id` to learn how functions work.
11:07:52 <quchen> siriusbtx: Like any other definition?
11:08:44 <siriusbtx> quchen: Well I have this: type Ship = [(Int, Int)]
11:08:55 <siriusbtx> and
11:08:56 <siriusbtx> module Battleship
11:08:57 <siriusbtx> (
11:08:57 <siriusbtx> 	createPlayField
11:08:57 <siriusbtx> 	Ship
11:08:57 <siriusbtx> ) where
11:09:02 <siriusbtx> and it gives me an error
11:09:09 <quchen> @paste
11:09:10 <lambdabot> Haskell pastebin: http://lpaste.net/
11:09:18 <benzrf> well my LMT seems to work o=
11:09:22 <quchen> Paste your multi-line code there next time. Also, you're missing a comma, siriusbtx.
11:09:32 <siriusbtx> quchen: thx :p
11:09:47 <zenkeku> http://lpaste.net/102164 I'm a little confused by how this works. The `where` clause, in particular.
11:10:14 <quchen> zenkeku: It's the local definition of a "bmi" function
11:10:34 <DR6_> the thing in the first line is a list comprehension
11:11:04 <zenkeku> DR6_: I understand that, I think. I'm confused by how the variables are set.
11:11:19 <DR6_> what variables?
11:11:23 <monochrom> I implement id all the time. it is part of learning. of course no one says I only do this.
11:11:43 <zenkeku> DR6_: Weight and Height, specifically. They are only used in the `where` clause and from what I can tell are never explicitely set.
11:11:54 <DR6_> bmi is just a function
11:12:07 <DR6_> exactly as if it was in the top level
11:12:09 <zenkeku> OH. Oh. That makes soo much more sense.
11:12:11 <quchen> http://lpaste.net/102164
11:12:16 <klugez> zenkeku: They are parameter names of that local function. They are set to the values the function is called with.
11:12:24 <quchen> The annotation is equivalent code, with the bmi function floated out.
11:12:28 <zenkeku> Right.. it's a function. Thank you! That makes so much more sense.
11:12:52 <DR6_> in general declarations in the top level and where clauses follow exactly the same syntax
11:13:03 <zenkeku> I feel stupid for not seeing that.
11:13:18 <zenkeku> DR6_: Yea, I knew that. But for some reason I didn't put 2 and 2 together.
11:13:25 <zenkeku> Idiomatic wise, lthat is.
11:17:21 <eacameron> can I provide an instance for my type iff the type parameter also has an instance, otherwise not?
11:17:44 <quchen> instance (Show a) => Show [a] where …
11:18:02 <eacameron> quchen: that's what that does?
11:18:20 <eacameron> quchen: indeed it does
11:18:38 <eacameron> quchen: I thought it was a dumb question...now I'm certain ;) thanks
11:19:15 <eacameron> that's different than `data MyType = Show a => MyType a`
11:19:22 <quchen> Oh yes.
11:19:31 <quchen> The class thing is allowed, what you wrote is evil
11:19:41 <shachaf> That's not evil.
11:19:52 <eacameron> hahah.... good   to   know
11:19:56 <shachaf> (Although it's a scope error, the way it's written.)
11:20:43 <eacameron> so is it evil or is it not evil?
11:20:49 <flebron> Is as <- mapM async foo; bs <- mapM wait as; stupid?
11:21:01 <quchen> flebron: mapConcurrently?
11:21:13 <eacameron> flebron: mapConcurrently does that
11:21:37 <dmj`> is there a performance penalty for importing a lot of unused modules into file?
11:21:41 <flebron> OK, just wanted to make sure it wasn't an anti-pattern or something. I'll look into mapConcurrently, thanks :)
11:21:46 <geekosaur> eacameron, the problem with something like instance Show a => Show [a] is that it provides an instance for *all* a, then fails if a turns out to not be Show
11:22:06 <geekosaur> that is, it doesn't check the constraints until after it has settled on an instance
11:22:16 <shachaf> It is not evil but it is not a solution to the problem.
11:22:42 <monochrom> dmj`: I think it only makes exe size larger
11:22:59 <quchen> dmj`: Compile with -W and you'll get warnings for unused imports
11:23:04 <eacameron> geekosaur: are you referring to `instance Show a => ...` or `data MyType a = (Show a => MyType a)` ?
11:23:17 <geekosaur> the former
11:23:41 <DR6_> the second has the same problem
11:23:46 <DR6_> only in that case it makes them useless
11:23:57 <DR6_> the former is useful in a lot of cases
11:24:03 <dmj`> monochrom, quchen: thanks
11:24:53 <eacameron> geekosaur: so I'm guessing existential type specification would help that problem?
11:25:57 <Kiryx> Dear #haskell, I just wanted to let you know about this code-learning site: http://www.codewars.com/ , Haskell is not an option so far, but there's a vote going on
11:26:04 <Kiryx> you know which language to vote on :)
11:26:22 <StoneCyp1er> jenny: what's up
11:26:54 <Kiryx> btw, the site is magnificent if you want to learn js, coffeescript or ruby
11:27:38 <athan> :)
11:28:26 <athan> Kiryx: Have you heard of elm or fay?
11:29:58 <eacameron> how does `instance Show a
11:30:33 <eacameron> how does `instance Show a => MyType a` differ from `data MyType a = MyType a deriving (Show)`?
11:30:44 <dmj`> know types know haskell, no types no haskell
11:31:03 <quchen> eacameron: In the former case you'll have to define the 'show' function
11:31:10 <laar> Kiryx, it seems that Haskell is quite a favorite standing 3rd
11:31:23 <geekosaur> in the former MyType is not a type, it is a typeclass
11:32:17 <geekosaur> you cannot make a value of "type" Show, because Show is not a type. similarly you would not be able to make a value of "type" MyType with the former. you could however specify that actual types have instances of MyType
11:33:09 <geekosaur> the latter declares a type MyType, and automatically does `instance Show a => Show (MyType a) where ...` to create a type-specific `show` implementation
11:33:20 <geekosaur> (note the difference in the instance declaration!)
11:33:43 <eacameron> geekosaur: so does the latter require that "a" be an instance of Show?
11:33:56 <geekosaur> Yes
11:34:13 <eacameron> hmm, that's what I'm trying to avoid
11:34:20 <geekosaur> because the Show instance it creates "delegates" to the Show instance for a
11:35:01 <Kiryx> athan: Nope
11:35:04 <geekosaur> (specifically it does `show (MyType x) = "MyType " ++ show x`)
11:35:05 <eacameron> geekosaur: that makes sense; is there a way to declare an instance for MyType only IF a is an instance of Show?
11:35:57 <geekosaur> you cannot declare an instance that checks at instance selection time; it will only check constraints afterward
11:36:14 <hiptobecubic> these sites are popping up like weeds
11:36:30 <athan> Kiryx: They're way cool :)
11:36:46 <geekosaur> however, in the most common cases you don't really care about that distinction; the only time it is relevant is if you want to also produce a Show instance when `a` does *not* itself have one
11:37:29 <flebron> Is there a way to see which types m satisfy (MonadBaseControl IO m, C.MonadResource m)?
11:37:41 <athan> I wish!!!
11:38:01 <jle`> hm
11:38:12 <flebron> (C is Conduit)
11:38:22 <jle`> usually i just check the docs
11:38:27 <johnw> is there a flag which I can use to set template-haskell's notion of the current directory during compilation?  -i is only for source files
11:39:39 <eacameron> geekosaur: so there's no way to optionally instantiate a typeclass based on the parameters types/instances?
11:40:20 <geekosaur> not really, no. can you explain why you are tryingt o draw this distinction?
11:40:58 <fizruk> hi all! I wonder if there's anything done in the manner of simple-reflect for educational purposes?
11:41:02 <athan> eacameron: You can make superclasses
11:41:20 <eacameron> geekosaur: I don't think I have to at this point (and may never), but as I was pondering this, I was comparing it to C++ templates and wondered how you could do such a thing
11:41:31 <athan> class (Functor f) => Applicative where
11:41:52 <geekosaur> athan, have you scanned back over the discussion as yet?
11:42:46 <eacameron> C++ templates are scary flexible...they blur the line between programming and metaprogramming, which is sometimes quite unhelpful
11:44:07 <geekosaur> typeclasses kinda serve a different purpose, I think.
11:44:08 <athan> oooooohhhhhh
11:44:09 <athan> I see
11:44:16 <athan> so he needs the typeclass instance regardless
11:44:30 <athan> but the show instance as well, only if the parameter is also an instance
11:44:53 <athan> I think that you would have to organize that within your function code
11:44:57 <athan> not in the types
11:45:14 <athan> ...maybe
11:45:18 <athan> maybeShow
11:45:28 <athan> I think that's all you can do, though :/
11:48:00 <eacameron> I see how this would be a problem with existing typeclass implementation, bucause foo :: MyType a -> String would need at least 2 possible implementations (one with Show a => ... and one without)
11:48:58 <dmj`> In my cabal file I have a library that has the pkg base as one of it's dependencies. I am exposing this library to other executables in the cabal file via modules. When I attempt to build an executable it says I am missing base. Do I have to respecify dependencies in an executable when they should be exposing via a library?
11:49:17 <th3w4c0k1d> I'm trying to convert the following procedural code: http://stackoverflow.com/questions/4983657/code-for-finding-the-vertex-normals-in-java (the for loops in the answer). How do I write something in Haskell that modifies / maps over three elements at a time? I have map fn $ zip3 vertices (drop 1 vertices) (drop 2 vertices) - but I need to fill in fn.
11:49:48 <jle`> th3w4c0k1d: do you know the type of fn?
11:50:01 <geekosaur> dmj`, your executable also needs to depend on base, even without that library
11:50:13 <geekosaur> even with that library, it doesn't pull in *all* of base
11:50:15 <jle`> also, map f zip3 xs ys zs is the same as zipWith3 f xs ys zs
11:50:17 <geekosaur> only the parts it uses
11:50:32 <jle`> there should be a parentheses somewhere in the first expression
11:50:35 <jle`> or two
11:50:43 <jle`> maybe 3 if you feel adventurous
11:50:51 <th3w4c0k1d> jle`: Not really, because I don't think I'm looking for map?
11:50:55 <geekosaur> (note that base also includes the Haskell runtime, so even if you somehow don't use anything in the Prelude your executable still needs to depend on it, or on an alternative)
11:51:23 <jle`> > take 10 $ zip3 [1..] [10..] [100..]
11:51:24 <lambdabot>  [(1,10,100),(2,11,101),(3,12,102),(4,13,103),(5,14,104),(6,15,105),(7,16,106...
11:51:33 <geekosaur> (the alternatives being haskell98 or haskell2010; note that if you use those then all of your dependencies must also use the same one)
11:51:35 <jle`> are those the three elements you want to work with?
11:52:25 <th3w4c0k1d> > take 10 $ zip3 [1..] [2..] [3..]
11:52:26 <lambdabot>  [(1,2,3),(2,3,4),(3,4,5),(4,5,6),(5,6,7),(6,7,8),(7,8,9),(8,9,10),(9,10,11),...
11:52:36 <th3w4c0k1d> jle`: Yup! But...
11:53:08 <jle`> ah, so groups of three consecutive
11:53:41 <th3w4c0k1d> jle`: Yes! But the modification of (1, 2, 3) is going to have an effect on (2, 3, 4)... if that makes sense?
11:54:36 <jle`> are you accumulating a big result based on each triple?
11:54:38 <jle`> that sounds a lot like a fold
11:54:51 <dmj`> geekosaur: Why have a library if I have to respecify all the dependencies in the library, in the executables
11:55:08 <flebron> Is there a way to see which types are instances of a given typeclass?
11:55:20 <geekosaur> so every library is guaranteed to bring in everything the executable will ever use?
11:55:23 <jle`> flebron: :i on ghci
11:55:26 <jle`> for the types in scope
11:55:27 <dmj`> flebron: call :i in ghci
11:55:35 <geekosaur> in particular does your library define your executable's main?
11:55:35 <jle`> er, the types that are loaded
11:55:41 <geekosaur> (if so, why the executable?)
11:56:02 <geekosaur> I sort of see what you are saying, but you are assuming an all dynamic linking forever world
11:56:20 <flebron> Should it be actually listing the types? I only see the definition f the typeclass.
11:56:31 <dmj`> geekosaur: the executable should infer the package via the exposed module
11:56:33 <jle`> flebron: if there are types that are loaded that are instances, it'll list it
11:56:36 <jle`> try :i Ord
11:57:11 <jle`> > (() <> ())
11:57:12 <lambdabot>  ()
11:57:14 <jle`> hehe
11:57:30 <dmj`> geekosaur: would you agree?
11:57:47 <geekosaur> dmj`: so ghc (remember it's possible to build stuff without cabal-install, just as it is possible to build stuff statically so it does not include all of the dependency) must transitively check all packages?
11:57:53 <geekosaur> no I do not agree
11:58:12 <ystael> Is there a way to switch the "active" version of a cabal installed package without reinstalling (and rebuilding)?  Specifically, having installed Agda 2.3.2.2 from Hackage and built darcs agda from source, is there something I can type to flip the active binaries between them without rebuilding?
11:58:16 <alipang> @djinn (r -> m r) -> ((((a -> r) -> m r)-> r) -> m r) -> ((a -> r) -> m r )
11:58:17 <lambdabot> -- f cannot be realized.
11:58:17 <eacameron> athan: I just now understood your suggestion; good point! just leave the instance out and write a custom "maybeShow" function that has the constraints if necessary
11:58:36 <jle`> hey, we should have an OverloadedUnit extension
11:58:48 <jle`> so we can define our own unit-like types with one member/constructor
11:58:51 <alipang> @djinn ((((a -> r) -> r)-> r) -> r) -> ((a -> r) -> r )
11:58:51 <lambdabot> f a b = a (\ c -> c b)
11:58:52 <jle`> and be able to use ()
11:59:00 <geekosaur> mostly because I think (a) you do not know or care about static linking (b) you do not know or care that not everything is cabal based (c) the combintion of those means that you have to build everything from source when building the executable to get all your dependencies right
11:59:10 <alipang> @djinn Monad m => ((((a -> r) -> m r)-> r) -> m r) -> ((a -> r) -> m r )
11:59:11 <lambdabot> -- f cannot be realized.
11:59:17 <geekosaur> if you do not understand the conclusion then you should consider that you do not understand how stuff works
12:00:20 <geekosaur> if I build your library with ghc < 7.8 then I will get a static library with static parts of base included. those parts do NOT include the parts needed when linking the executable!
12:00:31 <siriusbtx> is there a easier way to do something like this: http://pastebin.com/jA2wv2Ge?
12:00:41 <siriusbtx> http://pastebin.com/jA2wv2Ge sry
12:01:09 <geekosaur> if your response is "so the execuutable should go read the cabal file for my library" then what happens if I am typing "ghc foo.hs" and the only reference to your library is the import in foo.hs?
12:01:10 <jle`> siriusbtx: you could take 3 $ iterate (>>= f) (return a)
12:01:11 <eacameron> siriusbtx: Applicative style?
12:01:19 <quchen> siriusbtx: traverse f
12:01:31 <quchen> … depending on "..."
12:01:40 <quchen> Oh wait nevermind.
12:01:49 <quchen> foldM.
12:02:28 <eacameron> siriusbtx: ah, yeah, Applicative style would be more helpful if "f" were different everytime
12:02:34 <jle`> you know what i'm going to go ahead and write iterateM
12:02:43 <jle`> and submit a pull request to monad-loops
12:02:49 <siriusbtx> eacameron: k ty
12:02:54 <jle`> someone asks about it every few days
12:02:58 <jle`> and i have needed one several times
12:03:09 <jle`> always having to resort to iterate (>>= f) (return x)
12:03:32 <jle`> hope this james cook fellow is still active
12:04:06 <quchen> jle`: monad-loops has iterateM_
12:04:48 <jle`> quchen: yeah but there's no way to stop after n repeats
12:05:30 * flebron just had a ton of time saved by GhcModType
12:07:05 <hunt> @src sum
12:07:06 <lambdabot> sum = foldl (+) 0
12:07:18 <hunt> why does sum use foldl
12:07:27 <hunt> instead of foldl
12:07:28 <hunt> '
12:07:30 <hunt> or foldr
12:07:53 <jle`> hunt: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#sum
12:08:00 <jle`> that sum is only for the lambdabot src
12:08:03 <jle`> why it's there nobody knows
12:08:15 <jle`> oh
12:08:18 <jle`> it's because it's the Report prelude
12:08:22 <jle`> maybe a lot of people know >.>
12:08:50 <bitemyapp> jle`: the ifdef has the nicer recursive version in place though.
12:09:08 <bitemyapp> report prelude is just supposed to be demonstrative isn't it?
12:09:16 <hunt> thats the most optimized version?
12:09:35 <jle`> i don't see any strictness annotations
12:09:37 <jle`> hm
12:09:38 <dwcook> Functions are supposed to behave like the examples in the Report but may be implemented differently
12:09:53 <jle`> but there was that reddit article by dcoutts that has a pretty optimized implementation
12:09:57 <jle`> posted yesterday
12:10:19 <hunt> do you guys use reddit outside of /r/haskell,/r/programming ...
12:10:41 <bitemyapp> hunt: the prelude in general isn't super important performance-wise. It's rare you're using lists if you want do something like "sum" efficiently.
12:10:54 <quchen> sum has this type to work with lazy nats, so I've been told. I haven't been told about anyone using lazy nats though.
12:11:03 <dv-> prelude's sort seems very fast
12:11:07 <BeardedCoder> hunt: lol, those are the 2 I view on reddit.
12:11:13 <hunt> bitemyapp: why would lists be slower for sum?
12:11:31 <hunt> @src sort
12:11:32 <lambdabot> sort = sortBy compare
12:11:38 <hunt> dv- link?
12:11:40 <th3w4c0k1d> I think I've boiled my problem down to the following: How do I map over a list where each value uses the result of the previous call? eg. fn? (\x, y -> x + y) 1 [0, 1, 2, 3] => [1, 2, 4, 7]?
12:11:54 <alipang> @djin Monad m => ((a -> m r) -> m r) -> (a -> (b -> m r) -> m b) -> ((b -> m r) -> m r)
12:11:54 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
12:12:23 <shachaf> > scanl (+) 1 [0,1,2,3]
12:12:25 <lambdabot>  [1,1,2,4,7]
12:12:37 <th3w4c0k1d> shachaf: :D!
12:13:01 <bitemyapp> hunt: traversing linked lists in general is relatively slow. If you need fast math you're usually working with vectors, matrices - via a fast math library.
12:13:19 <dmj`> geekosaur: So you're saying I have to build base twice? First for the library, and second for the executable since the first time did not include the object files necessary for linking?
12:13:23 <bitemyapp> hunt: to answer your earlier question, I frequent r/haskell, avoid r/programming like an ebola outbreak, and really like some other subreddits.
12:13:33 <geekosaur> dmj`, you are not *building* base
12:13:35 <geekosaur> at all
12:13:38 <hunt> bitemyapp: if you only traverse the list once why is it slow? also whats the matter with /r/programming?
12:13:44 <geekosaur> it's built when the compiler is built
12:14:05 * hackagebot distributive 0.4.2 - Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.4.2 (EdwardKmett)
12:14:17 <jle`> hi edwardk
12:14:20 <jle`> nice push
12:14:29 <dwcook> Hitting an entire linked list isn't slow, but finding a particular element in one is
12:14:32 <jle`> i never even considered a cotraversable
12:14:48 <bitemyapp> hunt: single traversal locality still sucks and isn't fast.
12:15:00 <dwcook> In the former the best you can hope for is O(n), which linked lists give you, and in the latter you can do better, such as O(log(n))
12:15:03 <geekosaur> and I'm afraid to ask what you think is going on now
12:15:08 <bitemyapp> dwcook: I'm not talking about big O
12:15:12 <bitemyapp> I'm talking about locality.
12:15:34 <hunt> bitemyapp: why is it slower than random access though? from a low level pov it doesnt sem like it should be
12:15:37 <bitemyapp> The context was sum, which is ostensibly a single, but whole, traversal operation
12:15:55 <bitemyapp> hunt: learn about locality, how RAM is organized into blocks, and how CPU caches work.
12:16:30 <hunt> ok, so random access is faster even if its sequential?
12:16:36 <edwardk> jle`: understanding them leads to a nice understanding of representability
12:16:42 <bitemyapp> hunt: that's not what I'm talking about.
12:17:11 <bitemyapp> hunt: google what I said
12:17:41 <hunt> bitemyapp not sure i understand what youre talking about then. you said using matrices or arrows or vectors, but doesnt it boil down to the implementation, and doesnt the implementation boil down to list vs array?
12:18:29 <bitemyapp> hunt: 1. no 2. I'm talking about the memory locality properties of vectors and arrays for a single traversal sum.
12:18:37 <jle`> edwardk: the (->) e instance of distribute will let me avoid all of those annoying (+) <$> (*1) <*> (+3) things?
12:18:55 <henk> I would like to add tests to my code. I use cabal for building. Can anyone recommend a howto or which docs to read? Can cabal be used to automate tests? I’m a little confused what the state of the art is …
12:19:05 * hackagebot distributive 0.4.3 - Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.4.3 (EdwardKmett)
12:19:15 <jle`> oh wow a new update, you work fast
12:19:16 <edwardk> jle`: not sure what you mean
12:19:28 <bitemyapp> jle`: or he just fixed a mistake :)
12:19:39 <edwardk> jle`: realized i wanted to ensure distributive still worked on older GHCs
12:19:58 <edwardk> a feature was added in 0.4.2 that only works on GHC 7.2+
12:19:59 <jle`> the common (a -> b) -> (a -> c) -> (b -> c -> d) -> (a -> d) idiom
12:20:00 <bitemyapp> edwardk: how do you test multiple GHCs? hsenv?
12:20:07 <edwardk> bitemyapp: travis mostly
12:20:24 <bitemyapp> edwardk: travis offers multiple GHCs? Sweet! I should inspect their service more closely.
12:20:37 <edwardk> bitemyapp: they don't, but hvr does =)
12:21:09 <bitemyapp> edwardk: aha, thanks. Starred :)
12:21:12 <edwardk> bitemyapp: https://github.com/ekmett/lens/blob/master/.travis.yml uses some stuff he set up to grab alternate ghc versions
12:21:33 <dagano> helo : i have some data elements (String,Int,Int) and I am sorting them in decreasing order of the last int
12:21:36 <dagano> greedy requests = L.sortBy ordering requests where ordering (_,_,a) (_,_,b) = compare b a
12:21:45 <dagano> how do I provide a method to break ties?
12:22:08 <edwardk> what do you want to do to break ties?
12:22:12 <dagano> ie if a == b i want to look at the middle element of the tuple (which I guess I just can't use _ in the pattern matching)
12:22:19 <edwardk> use another field?
12:22:38 <jle`> dagano: well, tuples are already instances of ord
12:22:43 <jle`> > (1,2) < (1,5)
12:22:49 <lambdabot>  True
12:22:56 <dagano> OH!
12:22:58 <fizbin> Aw man, edwardk's online and I just don't have time today to ask him about that blog post I've been trying to decipher for days.
12:22:59 <Lethalman> > (1,2,3) < (1,2,5)
12:22:59 <edwardk> dagano: you can abuse two Monoid instances to compose comparisons
12:23:00 <lambdabot>  True
12:23:09 <jle`> and there is also the monoid instance of functions i think
12:23:33 <dagano> thnxks
12:23:38 <edwardk> dagano: L.sortBy (ordering1 <> ordering2) uses the Monoid for Ordering and the Monoid a => Monoid (e -> a) instance.
12:24:06 * hackagebot logging 1.0.0 - Simplified logging in IO for application writers.  http://hackage.haskell.org/package/logging-1.0.0 (JohnWiegley)
12:27:03 <dagano> >:t (<>)
12:27:13 <dagano> durp
12:27:21 <geekosaur> just :t
12:27:42 <dagano> :t (<>)
12:27:43 <lambdabot> Monoid m => m -> m -> m
12:28:16 <dv-> >:t looks like a very frowny face
12:28:36 <dmj`> /msg geekosaur: It just seems redundant to have to specify the same
12:28:37 <dmj`>        dependencies in a local library and an executable esp. if the
12:28:37 <dmj`>        executable references the local library. How hard would it be for the
12:28:37 <dmj`>        executable to only use the dependencies it needs and ignore the rest?
12:28:56 <geekosaur> ...that was rather fail...
12:29:10 <dmj`> yea, tried to copy and paste in emacs :/
12:29:56 <geekosaur> dmj`, how redundant it is depends on what system you are targeting. If you wish to stipulate that ghc only supports building with cabal-install, dynamic linking only, on Linux only, then yes you can get rid of a lot of "redundancy"
12:30:22 <geekosaur> I'm sure that's the only setup you care about, but there are other platforms and people who use them
12:34:06 <skypers> hey
12:34:48 <skypers> I’m writing a little wrapper over OpenGLRaw, just to make it simplier to use (but still the same idea)
12:35:09 <skypers> I just want to wrap any OpenGL generated value into a ForeignPtr
12:35:20 <skypers> in order to automatically call glDelet* version
12:35:30 <skypers> I do that with a type like ForeignPtr GLuint
12:36:00 <skypers> now, my question: do you think it’s sane to make it (GLuint,ForeignPtr GLuint) and use the fst part when I want to access the object?
12:36:19 <skypers> it’s something like caching, but I’m not sure it’s ok for the GC
12:37:21 <athan> skypers: That's awesome :)
12:37:28 <athan> skypers: But, you've got me haha
12:39:08 <dagano> greedy requests = L.sortBy (ord1 M.<> ord2)  requests
12:39:08 <dagano>          where ord1 (_,_,a) (_,_,b) = compare b a
12:39:08 <dagano> 	       ord2 (_,a,_) (_,b,_) = compare b a
12:39:20 <dagano> ugh .. sorry for massive paste
12:39:27 <dagano> that works .. but how can i make it less stupid?
12:39:37 <tapuu> Why isn't there a version of bracketOnError where the releaseresource action takes the exception as an argument?
12:40:59 <dagano> some of you folk should offer haskell lessons...like classical piano lessons where you come to my house and hit my hands with a stick
12:41:09 <geekosaur> dmj`, I would also point you again to the fact that base, haskell98, and haskell2010 are not compatible or interchangeable; there are type differences between them. (a) what does your proposed system do if libraries don't agree as to which to use? (b) how do you propose that your executable, which supposedly can infer its base dependency from libraries, deal with different types resulting form different choices?
12:41:31 <bitemyapp> dagano: actually, I already do that, informally.
12:41:51 <geekosaur> yes, this actually matters; one of the differences between haskell98/haskell2010 and base is the instances that can be considered in scope within Num instances
12:42:56 <dagano> bitemyapp: welp .. come to nyc and school me
12:44:10 <jle`> dagano: L.sortBy (_,a,b) (_,c,d) = compare (a,c) (b,d) ?
12:44:24 <jle`> er
12:44:28 <bitemyapp> dagano: I don't even come into my company's office, what makes you think I'd come to NYC? That said, I could teach remotely but I don't know how much you'd get out of it. If you're at least intermediate, not much.
12:44:31 <dagano> w/ <> ?
12:44:45 <jle`> compare (b,d) (a,c)
12:44:52 <jle`> yeah
12:45:53 <jle`> if you had fst/snd for triples, it might look cleaner
12:45:55 <jle`> but we don't
12:46:08 <jle`> *it might look cleaner with the monoid instance for functions and compare
12:46:10 <jle`> ord
12:46:14 <jle`> comparing
12:46:17 <jle`> :t LT
12:46:18 <lambdabot> Ordering
12:46:20 <jle`> ordering
12:46:27 <dagano> ah ok
12:46:40 <dagano> i like it
12:46:41 <dagano> thanks
12:48:09 <akurilin> Where do you guys look up benchmarks for various web frameworks out there? I was wondering how warp was doing nowadays
12:48:28 <hiptobecubic> it's beating rails. that's all you need to know.
12:48:52 <tapuu> Is it beating node?
12:49:11 <sked> tapuu: ha yes
12:49:29 <hiptobecubic> A lot of benchmarks are pretty worthless though
12:51:02 <tdammers> asking "how fast is framework X" is stupid
12:51:15 <tdammers> asking "what are the performance characteristics of framework X" is a tiny bit smarter
12:51:27 <mornfall> tdammers: it's as fast as a fully loaded swallow
12:51:34 <mornfall> (which framework was it?)
12:52:03 <tdammers> but what you really want to know is, "what kind of pain and suffering will I have to endure to build this project here such that it'll perform adequately under that load"
12:52:29 <mornfall> tdammers: and even the best crystall ball will fail to adequately prepare you for that
12:52:52 <tdammers> of course, but you can make some educated guesses and set some priorities
12:56:05 <tapuu> Is this safe? try action >>= mask_ handler
12:58:57 <dagano> i'm trying to (kinda) write a function [Int] -> [(Int,Int)] ... that, in an imperative sense, for every elem in the argument returns a tuple which is (i,sum of all numbers before i).
12:59:22 <dagano> what are some FP tools that make sense here?
12:59:25 <dagano> do i need state?
12:59:43 <bitemyapp> dagano: datsa foldr.
12:59:56 <bitemyapp> dagano: you don't need State as such, you want a fold.
13:00:47 <skypers> or a mapAccumR?
13:00:57 <shachaf> > mapAccumL (\a x -> (a+x,(a+x,x))) 0 [1,20,300]
13:00:58 <lambdabot>  (321,[(1,1),(21,20),(321,300)])
13:01:00 <skypers> yeah, L
13:01:04 <shachaf> That's a pretty awkward way of doing it...
13:01:05 <skypers> :)
13:01:17 <tapuu> dagano: the nonempty list comonad, maybe?
13:02:08 <bitemyapp> shachaf: what's non-awkward?
13:02:23 <dagano> echo bitemyapp
13:02:30 <awestroke> is there an alternative to cabal that is not rage-inducing?
13:02:50 <geekosaur> no, because the problem isn't cabal; cabal is just the messenger
13:02:56 <sked> awestroke: do you use e.g. hsenv?
13:02:57 <geekosaur> the problem is ghc
13:03:07 <awestroke> sked: no
13:03:12 <bitemyapp> dagano: what?
13:03:28 <sked> awestroke: hsenv makes cabal much, much more enjoyable
13:03:28 <bitemyapp> awestroke: I happily use cabal sandbox.
13:03:41 <bitemyapp> awestroke: hsenv when sandboxes aren't enough isolation.
13:05:41 <awestroke> so, what should I do now? Get hsenv, then what? I don't know off the top of my head the versions for each package, and if I install them with "cabal install" one at a time I get "Warning: This package indirectly depends on multiple versions of the same package [...]"
13:06:28 <awestroke> can I list them without versions in my project.cabal and then let cabal figure it out when it has a list of them all? But then my cabal file doesn't version my dependencies
13:06:36 <sked> awestroke: you can e.g. "cabal install foo bar baz" and it'll find a solution if there is one
13:06:52 <awestroke> sked: alright
13:09:11 * hackagebot hlint 1.8.60 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.60 (NeilMitchell)
13:09:13 * hackagebot purescript 0.4.12 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.12 (PhilFreeman)
13:12:42 <awestroke> why doesn't cabal handle multiple versions of the same package?
13:12:50 <geekosaur> ...
13:13:01 <geekosaur> [02 20:00] <geekosaur> no, because the problem isn't cabal; cabal is just the messenger
13:13:13 <bitemyapp> awestroke: I'd like to see a design proposal for such a thing. Also, nothing to do with Cabal.
13:13:32 <geekosaur> *ghc* does not handle it. because ghc inlines so much stuff that the absolute EXACT version of a dependency must be available at all times
13:13:51 <geekosaur> not just same version but same compile options etc.
13:13:54 <awestroke> bitemyapp: if bundler can solve it for ruby gems, cabal should be able to solve it too
13:14:12 * hackagebot ghc-mtl 1.2.0.0 - An mtl compatible version of the Ghc-Api monads  and monad-transformers.  http://hackage.haskell.org/package/ghc-mtl-1.2.0.0 (DanielGorin)
13:14:26 <geekosaur> whatever. you have decided it's cabal's fault, have fun being completely unable to fix it at the cabal level
13:14:54 <awestroke> geekosaur: and you seem to have decided to be a jerk
13:15:06 <awestroke> no need to get defensive, and I do see your point
13:15:10 <geekosaur> you are ignoring multiple times being told the problem is with ghc
13:15:21 <bitemyapp> awestroke: 1. you don't understand what you're complaining about 2. Bundler doesn't "solve" the problem, it sweeps it under the rug like npm. Only "solution" I've seen is OSGI+Maven, but at what cost.
13:15:33 <bitemyapp> awestroke: google "ghc-pkg" so you come off like less of an ignoramus.
13:15:49 <bitemyapp> awestroke: then read the source a bit, grok the design, draw up a proposal, earn the adoration of Haskellers everywhere.
13:15:55 <ast_> anyone using gloss on windows? Wonder if there is a way to make mouse wheel work for zooming as in linux.
13:15:59 <bitemyapp> awestroke: none of my procedure included "whine on IRC"
13:16:20 <bitemyapp> awestroke: it's mostly a nonp-problem being solved with the non-solution of getting rid of unnecessarily restrictive upper-bounds on package constraints.
13:16:34 <bitemyapp> awestroke: when people stop overly constraining the packages, it'll be less of an issue.
13:16:48 <geekosaur> cabal tries very, very hard to work with an impossible situation. it fails a lot because the situation is impossible. and redoing ghc to not do cross-module inlining isn't a solution either because performance absolutely tanks :(
13:17:07 <bitemyapp> awestroke: further, Cabal is doing the sane/smart/conservative thing and straight-forwardly intersecting constraints. If the constraints don't intersect into at least one viable version of the dependency, it's no-go.
13:17:10 <geekosaur> the *real* fix is to do whole-program compiles like jhc does... but that then introduces its own problems
13:17:18 <jrmithdobbs> doesn't the backpack stuff solve some of this?
13:17:26 <jrmithdobbs> if it's ever finished being implemented, i mean
13:17:34 <bitemyapp> geekosaur: no thanks. I'd rather just back off the upper-bounds.
13:17:54 <geekosaur> backing off upper bounds does not fix anything
13:18:02 <geekosaur> although people keep insisting it does
13:18:04 <tdammers> if only we had time machines, the whole thing would be trivial
13:18:27 <tdammers> we could just check whether future versions would still work with our code, and provide completely accurate upper bounds
13:18:51 <bitemyapp> geekosaur: there are some UX improvements that could be made too.
13:18:59 <geekosaur> most fun is watching the whole bloody ecosystem break for the Nth time because people don't put upper bounds, and then a *week* after it gets patched up again some dev complains about how evil upper bounds are again
13:19:04 <jrmithdobbs> tdammers: and then the next time aeson changes a core type everything breaks anyways
13:19:12 * hackagebot hint 0.4.1.0 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.4.1.0 (DanielGorin)
13:19:17 <bitemyapp> geekosaur: namely, better error messages offering better common-case automatic fixes if the user desires
13:19:17 <tdammers> jrmithdobbs: if you have a time machine, you can prevent htat
13:19:28 <tdammers> jrmithdobbs: that's kind of my point
13:19:31 <jrmithdobbs> tdammers: heh
13:19:54 <tdammers> seriously though, SemVer is great, but it's not perfect
13:19:55 <jrmithdobbs> ya, the upper bounds are there usually because a given package has a history of breaking things horribly on version shifts
13:20:02 <jrmithdobbs> only solution is for noone to change apis to anything ever
13:20:05 <jrmithdobbs> which isn't a solution
13:20:08 <bitemyapp> geekosaur: lack of upper-bounds hasn't really harmed the Clojure ecosystem at all. And that's without the benefit of types. I don't have any direct experience with the problems of upper bounds you describe but I'm willing to believe it could be an issue.
13:20:13 <tdammers> not really
13:20:25 <bitemyapp> geekosaur: I'd be apt to trust types + tests myself, but *shrug*
13:20:35 <tdammers> semver means that if I am using version 2.5.0, then 2.5.1 through 2.5.9999999999 should also work flawlessly
13:21:22 <tdammers> 2.6.x is allowed to introduce new entities, which means if I'm importing entire modules, unqualified, things could break (could, not will)
13:21:48 <geekosaur> no upper bounds "solves" the problem that something has been upgraded in a way that doesn't matter for some packages. the implication, as is all too common in the programming world, is that that means it doesn't matter for any package that "matters", for some single person's definition of "matters"
13:21:57 <tdammers> 3.x is allowed to remove existing entities, so anything could break (but again, this doesn't *have* to be the case, if the stuff that gets removed isn't something I use, I'm still good)
13:22:27 <geekosaur> (usually that one person being the library author, helpfully pushing problems onto his users so he can be lazy)
13:22:35 <bitemyapp> geekosaur: I'm on your side, I'm just rleating what I do and do not have experience with.
13:22:53 <geekosaur> this works wonderfully until I need to use that library along with some other library which turns out to not be compatible
13:23:10 <tdammers> so if everyone did semver correctly and without errors, we could just import everything qualified, put the major version in the upper bound, and everything would be peachy
13:23:26 <bitemyapp> tdammers: yeah pretty much.
13:23:32 <tdammers> except that people make mistakes, and there are more ways that a dependency can produce problems
13:24:08 <tdammers> and that this conservative strategy sometimes gets you into impossible situations
13:24:13 * hackagebot ig 0.2.1 - Bindings to Instagram's API.  http://hackage.haskell.org/package/ig-0.2.1 (FelipeLessa)
13:24:19 <geekosaur> and leads directly to the norm for ruby: exact versions required for everything, because it's the only way to be certain that something hasn't upgraded in a way that turns out to break the other stuff you need and nobody realized this would happen until it did becuase up until then it all "just worked" for the only people that mattered/cared
13:24:30 <tdammers> or even renders things un-buildable on a newer ghc
13:24:55 <geekosaur> I so very look forward to the haskell ecosystem turning into the rails ecosystem
13:25:07 <geekosaur> becuase that is what so many people desperately want
13:25:11 <jfischoff> heh
13:25:27 <jrmithdobbs> geekosaur: ruby/bundler is not a system to emulate, ever ;p
13:25:33 <MP2E> ^
13:25:45 <awestroke> geekosaur: cabal could offer the option to recalculate versions for all installed packages to fit with the constraints of the package that is being installed
13:25:52 <geekosaur> and will keep arguing for it because "it just works" right up until suddenly nothing works unless you hard peg every version because everyone wanted to "it just works" ignore versioning
13:26:03 <flebron> Is there anything more beautiful after long hours of compiler errors than "Ok, modules loaded: Main."?
13:26:27 <jfischoff> tight deps on libraries is not a good solution
13:26:51 <zerokarmaleft> flebron: "OK, passed 100 tests."?
13:27:08 <jfischoff> If wonder if what we want is hackage to maintain a list of what versions are known to actually work for a lib
13:27:16 <jfischoff> and the deps are very loose
13:27:19 <geekosaur> but too loose deps is not a solution either, because it ultimately leads to requiring the tightest possible deps
13:27:21 <paulschellin> A "last known compatible version" would be good though. And that would be the first thing the compiler suggests if there was a problem with compilation
13:27:23 <bitemyapp> jfischoff: the only reason I'm suspicious of tight deps on libraries is the non-issue constraints represented in languages that don't even validate their types.
13:27:39 <geekosaur> because everyone is so loose that the versioning claims that stuff that won't work does work
13:27:43 <bitemyapp> paulschellin: maybe somebody can spam travisci with exploratory builds? :)
13:27:59 <jfischoff> I could see cabal trying to build with newer versions and falling back on known older versions or somthing
13:28:16 <jfischoff> if the newer ones work, it gets added to hackage
13:28:19 <geekosaur> yes, there was a whole discussion about this recently, I think on libraries@
13:28:26 <jfischoff> ah
13:28:43 <geekosaur> and yes, improved tooling was part of the resolution
13:28:50 <siriusbtx> can I use foldM if my function does not take any extra arguments?
13:29:08 <awestroke> geekosaur: ^?
13:29:26 <jfischoff> geekosaur: anything interesting proposed?
13:29:57 <geekosaur> I don't recall, but I expect work is being done on cabal to support some of what was discussed
13:30:00 <jle`> siriusbtx: example?
13:30:27 <siriusbtx> well foldM takes as last argument a list of arguments to pass to the function
13:30:30 <jfischoff> I know freeze is coming out, but that only helps with "leafs" like executables really
13:30:56 <siriusbtx> I dont have any arguments to pass
13:31:25 <siriusbtx> I basicly want to call a function n times and pass the result of the previous pass into the next
13:31:41 <jrmithdobbs> :t unfoldr
13:31:42 <geekosaur> that sounds more like iterate than fold
13:31:42 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
13:31:46 <bitemyapp> siriusbtx: replicateM?
13:31:57 <glguy> he wants an "iterateM" sort of function
13:32:00 <bitemyapp> oh, no.
13:32:10 <glguy> with a cut-off parameter
13:32:13 <bitemyapp> n/m, my use of replicateM involved implicit state. ignore me.
13:32:52 <geekosaur> and yeh, the problem with iterateM is knowing when to stop
13:32:52 <siriusbtx> i think replicateM is what i need
13:33:27 <glguy> Probably this: let times 0 _ x = return x; times n f x = times (n-1) f =<< f x
13:40:12 <haasn> foldr return (>=>) $ replicate n f
13:40:34 <haasn> err
13:40:40 <haasn> :t foldr (>=>) return .: replicate
13:40:41 <lambdabot>     Not in scope: `.:'
13:40:41 <lambdabot>     Perhaps you meant one of these:
13:40:41 <lambdabot>       `.' (imported from Data.Function),
13:40:46 <haasn> oh no :(
13:40:53 <haasn> :t \n -> foldr (>=>) return . replicate n
13:40:54 <lambdabot> Monad m => Int -> (c -> m c) -> c -> m c
13:40:59 <haasn> like this?
13:41:28 <flebron> How can I transform a [ResourceT IO Text] into a single ResourceT [IO Text] or something? Basically I have some actions of that type which I want to run concurrently with mapConcurrently, but I'd like to use the sameresources for each one. I'm not sure this is possible - I'm using withManager and am making (concurrent) HTTP requests.
13:41:52 <flebron> If I mapConcurrently (runResourceT . ...), this works, but it seems slow, and I'm not sure much parallelism is going on.
13:41:54 <haasn> flebron: IO and Text are separate parameters to ResourceT
13:42:01 <haasn> flebron: did you mean ResourceT IO [Text] ?
13:42:03 <johnw> try mapConcurrently (liftResourceT ...)
13:42:17 <flebron> haasn: Yeah, that.
13:42:34 <johnw> flebron: I think sequenceA would work
13:42:38 <johnw> :t sequenceA
13:42:39 <lambdabot>     Not in scope: `sequenceA'
13:42:39 <lambdabot>     Perhaps you meant one of these:
13:42:39 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
13:42:42 <johnw> :t T.sequenceA
13:42:42 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
13:42:47 <haasn> :t sequence
13:42:48 <lambdabot> Monad m => [m a] -> m [a]
13:42:57 <johnw> or just sequence even
13:43:05 <flebron> But that wouldn't run in parallel, would it?
13:43:12 <haasn> flebron: depends
13:43:16 <johnw> no, it wouldn't
13:43:28 <haasn> oh, I don't know what mapConcurrently is
13:43:55 <haasn> ah, it's from async?
13:44:03 <johnw> flebron: there is a nice way to do what you want
13:44:13 <haasn> isn't this what the monadbase stuff is for
13:44:18 <flebron> Is it liftResourceT? (I'm looking at it right now)
13:44:43 <haasn> looks like mapConcurrently is implemented simply, though
13:44:47 <haasn> mapConcurrently f = runConcurrently . traverse (Concurrently . f)
13:45:09 <haasn> oh, but Concurrently is constrained to IO, hrm
13:46:35 <flebron> Right. So to be clear, my types are v :: Vector Text, f :: Text -> ResourceT IO Text, and I'd like to get an IO [Text], concurrently.
13:46:49 <dagano> question : any ideas on how to write a function : f x = (the first power of 2 greater than x) `minus` x
13:46:59 <flebron> (Or an IO (Vector Text), makes no matter.)
13:47:06 <dagano> f 15 = 1
13:48:03 <johnw> flebron: this should do what you wanted: https://gist.github.com/9942783
13:49:14 <flebron> > let f n = 2^(1 + floor ((log n) / log 2)) - n in f 15
13:49:16 <lambdabot>  1.0
13:49:16 * hackagebot yesod-auth-fb 1.6.2 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.6.2 (FelipeLessa)
13:52:52 <flebron> (johnw: Trying it)
13:52:54 <dagano> flebron: thanks .. i didn't take the time to think of a purely numeric solution ..
13:53:06 <vermeille> I'm writing a little compiler. I would like to be able to bind any variable with its type definition. In C++ you would just add a pointer to the type definition node. What about Haskell? Should I use some kind of breadcrumbs or is there a better solution?
13:54:11 <Zolomon> I'm trying to write a manager for /etc/hosts. I thought that it would be enough to run my application as a sudo user, but apparently I can't rename a temporary file to the /etc/hosts file in order to overwrite it. What gives?
13:54:54 <tdammers> "as a sudo user", or "through sudo"?
13:55:01 <mmmm_> vermeille: What do your types look like
13:57:01 <geekosaur> Zolomon, I think you need to show what you are actually doing
13:57:15 <Zolomon> tdammers: Through sudo.
13:57:15 <geekosaur> (and not just the haskell part)
13:57:27 <tdammers> Zolomon: yeah, what geekosaur said
13:57:42 <mmmm> vermeille: Did someone help you out?
13:57:56 <haasn> flebron: liftBaseWith (\runInBase -> mapConcurrently (runInBase . f) >>= restoreM) ?
13:58:00 <vermeille> mmmm nope, which types? of my Ast?
13:58:13 <haasn> or uh
13:58:16 <mmmm> yes
13:58:27 <haasn> control (\r -> mapConcurrently (r . f))
13:58:28 <Zolomon> http://hastebin.com/mijatanuba.hs -- "sudo runghc hm.hs add /etc/hosts reddit.com", "sudo runghc hm.hs remove /etc/hosts 5983"
13:58:37 <felixn> https://gist.github.com/munro/9942933 <-- I'm pattern matching on data inside a type, but can I also redundantly apply a variable to my data structure as a whole to clean up logic?  if that makes sense...
13:59:03 <vermeille> mmmm: it's simple as possible, just the value and children nodes, if any. Nothing fancy
13:59:13 <dhrosa> felixn: maybe you want myvar@Box {...}
13:59:16 <geekosaur> oh, I bet I know what's up
13:59:23 <dhrosa> felixn: that will let you bind the inner stuff to variables, and also the entire  structure
13:59:25 <geekosaur> renameFIle doesn't cross filesystems
13:59:39 <dhrosa> to names*
13:59:40 <felixn> dhrosa: nice!!
13:59:41 <geekosaur> and the temporary file is in /var/tmp
14:00:25 <felixn> dhrosa: wish that was in learn you some haskell ^_^  it felt like I should be able to do that, and I was right :D <3 <3
14:00:27 * geekosaur looks further to verify though
14:00:48 <dhrosa> felixn: you can also use that syntax on any constructor, like f x@(y:z)
14:00:50 <Zolomon> geekosaur: Doesn't cross filesystems?
14:00:52 <dhrosa> = ...
14:01:03 <felixn> dhrosa: sick
14:01:30 <fizruk> is there a way to overload function type in Haskell? e.g. I want (a -> b) to become (MyFn a b) and (f x) become (myAp f x)
14:01:30 <geekosaur> Zolomon, man 2 rename
14:01:35 <mmmm> vermeille: Well you basically extend your types in some way with an additional field for the type information
14:02:09 <dhrosa> fizruk: that sounds like an Arrow?
14:02:10 <johnw> haasn: that should work too
14:02:39 <vermeille> mmmm: yes, okay, but I don't want to include this field by value, because if my compiles modifies the type definition, every type *usage* must be modified as well
14:02:41 <johnw> and would be neater than my solution.  the only thing to bear in mind is that mapConcurrently creates N worker threads, whereas mine restricts to 16 at a time
14:03:10 <fizruk> dhrosa: not what I requested, but may work, let me check
14:03:27 <geekosaur> actually you are specifying current directory for the temp file, but still no guarantee it's the same filesystem. suggest you create your temp file in /etc like most utilities that update /etc files do
14:03:27 <Zolomon> geekosaur: Hmm.. the file is located on the same filesystem? It's on the same partition -- or that doesn't matter?
14:03:33 <haasn> johnw: oh, it gets even easier
14:03:45 <haasn> liftBaseOp mapConcurrently?
14:03:46 <geekosaur> however you did not say *how* it fails so I am guessing
14:04:01 <johnw> haasn: ooh, nice!  I hadn't used that function yet
14:04:18 <haasn> I have no idea if it works
14:04:30 <johnw> :t liftBaseOp
14:04:31 <lambdabot> Not in scope: `liftBaseOp'
14:05:47 <haasn> oh in all cases I forgot the actual list
14:05:58 <johnw> small detail
14:08:42 <geekosaur> Zolomon, so are you going to say *how* your program is failing (what error/eception)?
14:09:01 <thatway> is haskell used in any large software systems i might have heard about?
14:09:21 <prophile> pandoc and xmonad are both reasonably well-known
14:09:27 <miniBill> Hi, why is haddock from cabal refusing to build on ghc-7.6.3 ?
14:10:12 <geekosaur> oh also I recommend not just removing the old /etc/hosts but renaming it to a backup file
14:10:13 <Fuuzetsu> miniBill: because recent Haddock requires recent GHC. Usually you're just supposed to use the version that comes with your GHC.
14:10:56 <Zolomon> geekosaur: Sorry, phone call
14:10:57 <Zolomon> geekosaur: hm.hs: ./temp8667: rename: unsupported operation (Invalid cross-device link)
14:11:02 <thatway> prophile: thanks
14:11:07 <geekosaur> there you go then
14:11:12 <geekosaur> "invalid cross-device link"
14:11:20 <geekosaur> is exactly what I was pointing you at
14:11:37 <Zolomon> geekosaur: Ok, thanks!
14:12:00 <geekosaur> so I suggest you change the temporary file dir form "." to "/etc"
14:12:14 <geekosaur> also consider renaming the original to a backup file name
14:12:59 <mreca> total haskell n00b here, but if I want to read in a file (via cmdline) line by line, should i store it in an array/list or pass a file descriptor around
14:13:30 <mreca> cmdline arg*
14:13:37 <miniBill> Fuuzetsu: my ghc didn't include haddock :)
14:13:46 <Fuuzetsu> whatever works for you, mreca
14:13:50 <miniBill> Fuuzetsu: let me try to get it from portage instead of cabal
14:13:53 <Fuuzetsu> :t lines <$> readFile "foo"
14:13:54 <lambdabot> IO [String]
14:14:11 <Fuuzetsu> miniBill: That probably want help. What's your actual error?
14:14:25 <Fuuzetsu> 2.13.x should work with 7.6.3, 2.14.x or 2.15.x won't.
14:14:27 <johnw> mreca: I would use conduit to read the lines
14:14:30 <Fuuzetsu> won't help*
14:14:59 <miniBill> Fuuzetsu: I emerged 2.13, works
14:15:11 <Fuuzetsu> johnw: conduit might be a bit much for ‘total haskell n00b’.
14:15:36 <jrmithdobbs> Fuuzetsu: gotta learn sometime
14:15:47 <miniBill> now on to the next problem: ltk fails with http://dpaste.com/1768905/
14:15:51 <jrmithdobbs> pretending lazy io is feasible only goes so far ;p
14:16:06 <johnw> Fuuzetsu: but it's good to learn the best way from the beginning, if it's a real program
14:16:18 <haasn> johnw: oh
14:16:45 <haasn> liftBaseOp (sequence <$> mapConcurrently f xs)
14:16:49 <haasn> I.. think
14:16:51 <haasn> no, wait
14:16:52 <jrmithdobbs> f# just makes me like haskell more and more ;p
14:17:02 <haasn> liftBaseOp (fmap sequence . flip mapConcurrently xs)
14:17:02 <mreca> johnw right so i'm trying to build an interpreter, and i just need a way to grab each line from a file, preferably in a functional way
14:17:03 <haasn> oh well
14:17:04 <jrmithdobbs> these crazy indent semantics are driving me insane
14:17:09 <Fuuzetsu> miniBill: that's a pretty old ltk version
14:18:18 <miniBill> Fuuzetsu: that's the ltk version that leksah pulls. let me try a newer one
14:18:30 <medfly> hi guys, does anyone know Cale here?
14:18:35 <flebron> johnw: haasn: Thanks, that concurrency stuff worked fine :)
14:18:55 <flebron> Just to be annoying, what would I have had to read in order to come up with that by myself?
14:19:13 <Fuuzetsu> medfly: never heard of him ;P
14:19:18 <johnw> flebron: the docs for Control.Monad.Trans.Resource mostly, toward the bottom
14:19:27 <johnw> I didn't know the trick myself before, snoyberg himself showed it to me
14:20:55 <miniBill> Fuuzetsu: cabal install leksah still pulls that ltk version even if I did install the newer one
14:20:58 <epsilonhalbe> hey, I am organizing a functional programming group in vienna - and I want to present on testing,  benchmarking and profiling
14:21:15 <medfly> Fuuzetsu: I know he works for someone that deals with Haskell and it would be cool if I knew that he gave any sign of life recently
14:21:20 <epsilonhalbe> is there another function than mean/average that acts as a good example for profilling
14:22:25 <Fuuzetsu> miniBill: I never said it wouldn't. What is the version portage is trying to give you? New leksah was uploaded to Hackage like 2 days ago so it'd be the best to be pulling that in
14:22:33 <Fuuzetsu> 0.13.4.2 should be the best
14:22:48 * Fuuzetsu removed his haskell overlay a while ago
14:23:13 <haasn> flebron: I don't know, I just always sort of assumed MonadBaseControl was used for this kind of stuff
14:23:26 <haasn> so I decided to actually look at and understand the haddocks for once
14:23:58 <petrie> ls
14:23:59 <miniBill> Fuuzetsu: I'm trying to install leksah via cabal rather than portage
14:24:02 <petrie> herm
14:24:20 * hackagebot tidal 0.3.4 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.3.4 (AlexMcLean)
14:24:22 * hackagebot logging 1.1.0 - Simplified logging in IO for application writers.  http://hackage.haskell.org/package/logging-1.1.0 (JohnWiegley)
14:24:22 <miniBill> Fuuzetsu: should I just portage it?
14:24:47 <johnw> haasn: MonadBaseControl is certainly the general way to do it; it's just that in this case, ResourceT itself gives us an easy way to carry state into a liftIO block
14:25:16 <Fuuzetsu> miniBill: I'd advise against mixing portage with cabal although there are people who would disagree… If you're just using cabal, you should try installing leksah inside a cabal sandbox
14:25:20 <haasn> johnw: ah, okay
14:26:03 * miniBill is considering using kwrite instead :D
14:26:21 <haasn> I don't advise mixing portage with cabal
14:26:33 <haasn> I advise just using portage ;)
14:26:43 <medfly> who is ryan trinkle ?
14:29:18 <byorgey> medfly: what sort of answer are you looking for?
14:29:55 <byorgey> medfly: http://skedge.me/about-us/ryan-trinkle/
14:30:41 <medfly> I was wondering if he hangs out here. sorry
14:31:30 <byorgey> oh, I get it =)
14:31:49 <napping> Is there any way to get GHC to use conditional moves?
14:32:09 <byorgey> I think he is RyanT5000
14:32:18 <medfly> cool, thanks
14:32:21 <byorgey> but I don't know how often he is on here
14:32:35 <medfly> very rarely
14:32:59 <medfly> thanks
14:33:50 <napping> I was reading http://www.pvk.ca/Blog/2012/07/03/binary-search-star-eliminates-star-branch-mispredictions/
14:34:21 * hackagebot haddock 2.14.2 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.14.2 (MateuszKowalczyk)
14:34:40 <napping> but a simple if x ==# 0# then y else z doesn't compile down to anything like cmov on 7.6.3 -O2 with or without -fllvm
14:35:32 <flebron> In what way does an Applicative let one "look at the structure of a computation"?
14:35:42 <geekosaur> I think the code generator is not clever enough for that
14:36:25 <geekosaur> although you might see if -fllvm helps by getting llvm to generate the instruction instead
14:37:40 <byorgey> flebron: I'm not sure of the context, but I'm guessing that's referring to the fact that if you make a deep embedding of Applicative, i.e. turn pure and <*> into constructors of some data type, then it is a tree that you can fully inspect without running it
14:38:02 <flebron> Oh you mean that "reification" thing?
14:38:08 <napping> -fllvm doesn't help, and gcc is smart enough to do that
14:38:24 <byorgey> flebron: this is in contrast to Monad: turning >>= into a data type constructor means you are storing a *function*, and you can't actually look at the "subtree" because you would need a value to pass into the function
14:38:28 <n-dolio> napping: What about in 7.8, where ==# doesn't even return a boolean?
14:38:36 <napping> haven't tried 7.8
14:38:39 <johnw> byorgey: but with FreeT you cuold
14:38:50 <flebron> Ah OK, I think I see then. <*> would just say "I'm adding this variable to be run...", but in the end you can always go to pure f <*> arg1 <*> arg2 <*> ..., so you get something like [f, arg1, arg2, ..., argn].
14:39:16 <flebron> Whereas with a Monad you don't get to see arg1 and arg2 until you run the function?
14:39:34 <byorgey> flebron: right, something like that
14:39:37 <johnw> i think it depends on which Applicative and which Monad you choose
14:39:42 <napping> you can see arg1 in arg1 >>= f - and that's the sort of thing FreeT might make more explicit, but arg2 not until you call it
14:39:51 <johnw> they can both defer execution and build data models instead
14:39:58 <napping> johnw: the second argument to >>= is always a function you can't see into without passing an argument
14:40:02 <flebron> Err yeah, arg1 is the one that's visible, not arg2 and arg3, etc :)
14:40:15 <johnw> napping: ah, I see what you mean
14:40:19 <napping> the only way you can try to analyze a Monad needs some technique to reify functions
14:40:36 <flebron> But you don't know which function the user will give you
14:41:00 <flebron> He may have constructed it out of wooden sticks and watermelon seeds
14:41:02 <napping> Yeah, it's pretty hard in general
14:41:45 <napping> There are ocassional tricks - which don't generally work for monads - like if you require it to be polymorphic in Num you can pass in funky numbers that try to reconstruct what operations they do
14:41:56 <napping> some of the DSLs for numeric/array stuff pull tricks like that
14:42:17 <napping> and of course you can implement an Applicative that just directly does something without bothering to build a structure
14:42:23 <vermeille> I'm not sure to understand the semantics of a functor. Is that only "I am something on which you can apply a function"?
14:42:47 <flebron> So just to be clear, what you can see is the structure [f, arg1, arg2, ...], but you can't actually see _into_ any of those, right? At least, not necessarily.
14:42:59 <napping> but those are all in the same type of applicative
14:43:25 <napping> so you can look into arg1, arg2, ...
14:44:17 <napping> data App a where Pure :: a -> App a; Ap :: App (a -> b) -> App a -> App b
14:44:36 <napping> can get an applicative instance, and you can get an entire tree from any App a
14:45:14 <napping> of course, with laziness you can end up with an infinite tree, but you can always start walking it
14:45:29 <flebron> Ah, but those will end up at either pure or fmap leaves, right?
14:45:47 <napping> Even fmap doesn't need to hide anything
14:45:58 <napping> the  function is opaque of course, but not the subtree
14:46:09 <napping> simplest, fmap f a = pure f <*> a
14:46:15 <flebron> Ah right!
14:46:30 <napping> So you can do things like compute lookahead sets in parsers and so on
14:46:33 <flebron> So all applications are transparent :) That's the "structure"!
14:47:41 <napping> Yeah. Now it's a pretty boring structure if you don't also have some other type of primitive operations that make interesting nodes, but that's the idea of getting structure
14:47:52 <tristan__> I can't think of another analogy for what I'm looking for besides sys.config in Erlang, which I'm looking for similar in Haskell
14:48:31 <napping> speaking of parsing, is anyone generally familiar with dynamic lexing options?
14:49:16 <tristan__> and really I just want it to be Haskell data structures (like Erlang sys.config hehe), so my app when started can read in some default values from it
14:50:41 <napping> I've heard of Ctk, and found notes on a "Haskell Dynamic Lexer Engine", but alex sounds pretty nice besides not being packaged as a library
14:53:54 <dagano> > head $ /exit
14:53:55 <napping> tristan__: configurator looks interesting from this, if I understand what you want http://ocharles.org.uk/blog/posts/2012-12-21-24-days-of-hackage-configurator.html
14:53:55 <lambdabot>  <hint>:1:8: parse error on input `/'
14:53:59 <dagano> wups
14:55:14 <tristan__> napping: ah nice, this may be just what I need
14:55:46 <tristan__> unless it can't write configs too, but that I can do easy enough
14:55:57 <napping> It's not at all tied in with the system or integrated with some release management, but it seems pretty nice for adding some config file support to your application
14:56:52 <tristan__> yea, good enough. I guess it doesn;t make as much sense to have a sys.config like Erlang, since there isn't an application:get_env(..)
15:06:49 <zcd> is there a way to show the instance dclaration for IO of class Functor only?
15:07:31 <zcd> :i Functor IO gives the class declaration for Functor and a where IO is defined
15:10:12 <shachaf> Not really.
15:11:45 <hpc> iirc, for GHC the definition is instance Functor IO where fmap = liftM
15:12:23 <hpc> and then instance Monad IO where (>>=) = ioBindWithAMagicalDefinition
15:12:49 <hpc> (ie, Functor building up from as narrow a set of primitives as possible)
15:13:29 <jle`> it's best to think of IO composition as composition of black-box primitives with hidden implementations
15:13:45 <jle`> but
15:13:47 <jle`> they are pure compositions
15:13:49 <jle`> and pure primitives
15:14:02 <paulschellin> So I've been looking for a container in Haskell but I'm not confident with what I've found so far. I'm looking a container which is as close to the functionality of Boost's boost::bimap container in C++. Of course, I've already seen Data.Bimap in hackage and it's features aren't compatible with what I'm trying to do (Data.Bimap only allows a bijective relationship between the two sets). I should mention that
15:14:03 <jle`> so we don't lose any of the fun equational reasoning/purity stuff about haskell
15:14:03 <paulschellin> I am hoping to use this container within acid-state as well.
15:14:09 <hpc> it's entirely possible to have instance Functor IO where fmap = magic as well
15:14:28 <hpc> (and then use the fmap/join identity to get sequencing)
15:15:55 <petrie> Hey jle` I finally finished what i was trying to do yesterday.http://pastebin.com/chPui4pE
15:16:01 <petrie> you see any improvements i could make on it?
15:17:59 <paulschellin> I've been trying to get Data.IxSet to work for my purposes, but I've had very little success even getting simple toy implementations to compile.
15:20:46 <pavonia> petrie: There are a few places you could remove variables, i.e. making it pointfree
15:20:48 <jle`> petrie: hm. first, a couple of minor stylistic things
15:21:01 <jle`> usually we name lists or collections "xs" or "ys" instead of x and y
15:21:20 <petrie> Ah ok!
15:21:22 <jle`> secondly, you don't gain too much from doing f $ g x
15:21:27 <petrie> Should have noticed that
15:21:27 <jle`> f (g x) is often times more readable
15:21:28 <petrie> lol
15:21:46 <jle`> $ is useful for a lot of situations
15:22:03 <jle`> but this is one where i and some others feel is a bit unnecessary
15:22:14 <jle`> but that's just a stlyistic thing
15:22:16 <quchen> paulschellin: Isn't that the point of a bimap, to have a bijection between keys and values?
15:22:23 <jle`> also, you are recomputing findMean x every time
15:22:25 <jle`> for every item
15:22:28 * pavonia prefers f $ g x
15:22:32 <petrie> Yeah I noticed that :\
15:22:37 <quchen> paulschellin: In other words, what can your bimap do that Data.Bimap cannot?
15:22:40 <jle`> i suggest you bind/assign it once
15:22:42 <petrie> I was trying to figure out how to write it so I wouldnt have to do that
15:23:11 <jle`> let mean = findMean x; v y = (y - mean)^2 in ...
15:23:21 <jle`> pavonia: also listen to pavonia :)
15:23:24 <jle`> make your own choices and decisions
15:23:45 <quchen> Oh hi petrie, welcome back :-)
15:23:45 <jle`> this stylistic point isn't a big deal
15:23:50 <petrie> and you can still call v from map?
15:24:00 <jle`> petrie: yes
15:24:04 <paulschellin> quchen: I want it to describe relationships between two sets, and I want those relationships to be able to be surjective or injective
15:24:05 <jle`> but
15:24:09 <petrie> Oh cool
15:24:14 <jle`> in this case, it is probably more idomatic to use a where clause
15:25:00 <jle`> findVariance xs = findMedian (map f xs) where mean = findMean xs; f y = (y - mean)^2
15:25:11 <quchen> paulschellin: Oh, so a loosely coupled bimap, so to speak? One where you can "insert, insert-left-only, insert-right-only"?
15:25:18 <jle`> you can make f point-free but i don't think you gain too much from that
15:25:24 <jle`> f = (^2) . (- mean)
15:25:25 <paulschellin> And I'm not really sure if it's worth the confusion to get into the actual functors as morphisms between dual categories
15:25:39 <jle`> but findStdev would probably be easier to read point-free
15:25:41 <paulschellin> quchen: Yeah, precisely
15:25:43 <petrie> Ah hmm
15:25:48 <jle`> findStdev = sqrt . findVariance
15:25:51 <quchen> paulschellin: Dual categories? I'm not sure this is (remotely) necessary here.
15:25:54 <jle`> maybe.
15:25:59 <jle`> but that is a stylistic thing as well
15:26:32 <jle`> findMean = (/) <$> sum <*> (fromIntegral . length) :P
15:26:33 <jle`> (don't do that)
15:26:37 <petrie> o.0
15:26:50 <quchen> paulschellin: What you want sounds like Data.Bimap, but with a few more API functions and without making sure the invariants are preserved when doing things (i.e. arrows back and forth).
15:27:00 <quchen> Eh, not preserved
15:27:19 <quchen> jle`: Booo, that traverses the list twice.
15:27:44 <petrie> jle`: thanks appreciate the help!
15:29:43 <paulschellin> quchen: If I instead consider the container as storing a set of relations (rather than two sets and their shared relations), I think I could use Data.Table or similar, but I really don't have a good grasp as to how performance will be for any of these representations
15:30:54 <jle`> quchen: it was a point-freeization of what he already had :P
15:31:23 <jle`> a sort of joking one
15:32:36 <petrie> so can you use ";" to put multiple function definitions using the same let
15:32:39 <petrie> if I worded that properly
15:32:56 <quchen> paulschellin: Data.Table? Anyway, what kind of datastructure is right for your Bimappy thing depends on how you want to use it. Maps are usually fairly fast.
15:33:17 <jle`> petrie: you can, but i only did that because of irc
15:33:21 <jle`> you should do them in multiple lines
15:33:30 <jle`> let x = 5
15:33:34 <jle`>     y = 6
15:33:35 <quchen> petrie: You only need explicit ";" when you want to control the layout manually. Newlines and indentation allow you to write anything without ";".
15:33:38 <jle`> in  x + y
15:33:47 <petrie> Oh ok I see
15:34:07 <zipper> Is it just me or does lambda calculus not actually involve math?
15:34:47 <zipper> And is Alozo Chruch the guy behind Church Turing Completeness or whatever it is called?
15:35:34 <Eduard_Munteanu> How do I get at a request target URI in wai / warp?
15:36:11 <Eduard_Munteanu> zipper: it's not calculus as in real analysis.
15:36:43 <geekosaur> zipper: depends on how you define math
15:36:49 <Eduard_Munteanu> I mean they're unrelated.
15:36:50 <zipper> Eduard_Munteanu: Yeah it's closer to logic.
15:37:22 <quchen> petrie: For comparison, here's a version of 'variance' that traverses the list only once: http://lpaste.net/102171 You can ignore the BangPatterns line and the "!", that's only an optimization (remember the foldl-vs-foldl' issue? When you learn about that you'll also learn about BangPatterns)
15:37:37 <zipper> geekosaur: To me math is scary symbols that I don't understand. Maybe haskell is making me better at math without me knowing that I am learning math.
15:37:52 <quchen> petrie: The idea is that while walking the list, you can record three things simultaneously: the magnitude of the current element, its square, and at what point of the list you currently are.
15:37:55 <zipper> geekosaur: For example currying
15:38:05 <Eduard_Munteanu> zipper: there's a lot of stuff people call "math" generically.
15:38:24 <petrie> Oh wow
15:38:35 <quchen> petrie: That's lines 6-7. The foldl has an accumulator that keeps track of these three values.
15:38:47 <geekosaur> quick, someone send zipper some type theory :p
15:38:49 <quchen> s = sum, sq = sum squares, l = length  in the "go" function
15:39:18 <quchen> ∀x. ¬P(x)  -- geekosaur
15:39:28 * hackagebot validations 0.1.0.0 - A nice way to define field validations in Haskell.  http://hackage.haskell.org/package/validations-0.1.0.0 (mavenraven)
15:39:30 * hackagebot purescript 0.4.12.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.12.1 (PhilFreeman)
15:39:38 <Eduard_Munteanu> zipper: how far did you study math in school / on your own?
15:40:07 <petrie> I can follow some of it :P
15:40:41 <petrie> Hopefully I can write functions like this eventually :)
15:41:04 <zipper> Eduard_Munteanu: How far did I study math? I guess differentiation and integration in high school.
15:41:29 <quchen> petrie: You'll be surprised at how fast you'll easily write stuff like that
15:41:33 <zipper> Eduard_Munteanu: I can't remember those things right now though.
15:41:37 <Eduard_Munteanu> zipper: have you ever studied abstract algebra (monoids, groups...)
15:41:40 <Eduard_Munteanu> ?
15:41:58 <zipper> Eduard_Munteanu: No I haven't. Should I?
15:42:04 <geekosaur> mathematical logic, propositional calculus
15:42:12 <geekosaur> number theory
15:42:14 <fizruk> what's the proper package for Show1 typeclass? prelude-extras?
15:42:15 <geekosaur> set theory
15:42:18 <Eduard_Munteanu> zipper: I was going to say Haskell-related math is more like that.
15:42:19 <zipper> geekosaur: Yeah those I have looked at in a mooc
15:42:30 <zipper> Introduction to logic
15:42:40 <zipper> Proofs and logic etc
15:42:47 <geekosaur> there is a lot more to math than what you've been exposed to, and lying underneath what you know
15:43:38 <zipper> geekosaur: When you said someone should give me type theory. Is type theory a part of math and not CS?
15:43:47 <Fuuzetsu> is there an up-to-date resource on esqueleto and persistent, the yesod book is outdated to the point that nothing lines up
15:43:53 <geekosaur> I was responding specifically to your scary symbols comment
15:43:56 <Eduard_Munteanu> zipper: the basics of abstract algebra are pretty easy to acquire. But logic and all that is useful too in this context.
15:44:13 <zipper> Eduard_Munteanu: I will add abstract algebra to my list with category theory
15:44:45 <Eduard_Munteanu> zipper: oh, if you're aiming for CT, abstract algebra will likely be very useful, a lot of examples draw from that.
15:45:24 <Eduard_Munteanu> zipper: type theory can be seen as an alternative set theory
15:45:30 <zipper> Eduard_Munteanu: So I should learn abstract algebra before CT??
15:45:53 <zipper> Eduard_Munteanu: I guess I know as much about sets as I need to.
15:46:12 <zipper> Adding info to my mind never hurt though
15:46:24 <Eduard_Munteanu> zipper: just the basics, e.g. definitions of stuff like monoids
15:46:28 <athan> zipper: Yeah, I definitely found the need
15:47:35 <athan> Eduard_Munteanu: I find that when I try to learn CT, I often neglect my assumptions made. I feel like AA would give a good intro to... abstract, yet well defined systems ;)
15:49:08 <Eduard_Munteanu> zipper: for example, a monoid (M, *, 1) is a set M together with an associative operation * which has an identity element 1, (where * and 1 aren't necessarily multiplication and the number one, just notational convenience).
15:49:28 <Eduard_Munteanu> Which is pretty simple in itself.
15:49:34 <zipper> I know monoids from the monoid typeclass
15:49:39 <petrie> quchen: rwh teach a pretty good amount of be proficient?
15:49:45 <petrie> to*
15:49:50 <Eduard_Munteanu> zipper: good, that's where the typeclass comes from
15:50:01 <zipper> petrie: RWH is a bad book. Code fails at every turn.
15:50:23 <petrie> really?
15:50:26 <zipper> petrie: Well if you're running newest version of GHC RWH is not the book
15:50:44 <petrie> Im using 7.6.3
15:50:47 <athan> OH WOAH!
15:50:50 <athan> look what I found!
15:50:51 <athan> https://www.youtube.com/watch?v=BF6kHD1DAeU&list=PLGCr8P_YncjVjwAxrifKgcQYtbZ3zuPlb&noredirect=1
15:51:26 <Eduard_Munteanu> athan: hm, I didn't know about it
15:51:42 <petrie> You have one to recommend than zipper?
15:51:50 <Axman6> RWH teaches a lot of important topics, I'd still read it and then find out what's changed since it was written before jumping into using anything recommended
15:52:32 <athan> zipper: You should be more concerned about the properties that the typeclasses expect from the implementations - for example, a monoid _can_ be massively parallelized
15:52:56 <petrie> Axman6: Ah, ok thanks
15:53:15 <Axman6> petrie: do you have any haskell experience?
15:53:29 <petrie> 4th day today learning it
15:53:41 <Axman6> using RWH? or LYAH?
15:53:43 <SwashBuckla> from LYAH: "If a pattern matching fails in a lambda, a runtime error occurs, so be careful when pattern matching in lambdas!" (Half way down this page: http://learnyouahaskell.com/higher-order-functions)
15:53:52 <SwashBuckla> is there an example of this?
15:54:04 <Axman6> > (Just x -> x) Nothing
15:54:05 <lambdabot>  Pattern syntax in expression context: Just x -> x
15:54:08 <Axman6> > (\Just x -> x) Nothing
15:54:09 <lambdabot>  Constructor `Data.Maybe.Just' should have 1 argument, but has been given none
15:54:17 <Axman6> > (\(Just x) -> x) Nothing
15:54:19 <lambdabot>  *Exception: <interactive>:3:2-15: Non-exhaustive patterns in lambda
15:54:23 <petrie> I skimmed lyah and than started on rwh since that is what I thought everyone recommended
15:54:25 <SwashBuckla> Thanks Axman6
15:54:25 * Axman6 just got up
15:54:29 <SwashBuckla> :D
15:54:45 <Axman6> petrie: LYAH is a much better book for learning the basics of haskell
15:54:50 <zipper> petrie: I read LYAH. People say I should've used something different. I tried RWH and my example code was failing and what not, I just couldn't.
15:54:54 <tac> You also see it a lot when you naively pattern-match onto a list
15:55:03 <Axman6> RWH is aimed at people with some experience who want to learn how to do things in the real world (hende the name)
15:55:04 <athan> SwashBuckla: it's the same effect as head []
15:55:11 <hiptobecubic> petrie, i think lyah is miles above rwh for understanding the language.
15:55:14 <tac> > let (hd:tl) = [] in hd
15:55:15 <lambdabot>  *Exception: <interactive>:3:5-16: Irrefutable pattern failed for pattern (hd...
15:55:19 <athan> incomplete comprehension of possible inputs
15:55:26 <SwashBuckla> > head []
15:55:28 <lambdabot>  *Exception: Prelude.head: empty list
15:55:33 <petrie> So you should be pretty proficient if you study lyah well?
15:55:38 <tac> I think RWH was written to prove they could get the lion to eat tofu.
15:55:43 <zipper> Axman6: Really, but for a book to be good shouldn't example code just work without help from an IRC channel?
15:55:59 <hiptobecubic> tac, go on?
15:56:00 <athan> tac: Interesting!
15:56:02 <tac> petrie: I wouldn't say you'd get proficient *just* by reading that one book. But it's a pretty good start.
15:56:04 <Axman6> zipper: it did when it was written
15:56:11 <Axman6> a lot has changed
15:56:12 <zipper> Axman6: May GHC backward incompatibility is to blame and not RWH
15:56:35 <geekosaur> the problem is that things like the mtl and exceptions have changed since rwh was written
15:56:36 <petrie> tac: Oh ok, well I will study it up than
15:56:48 <geekosaur> so some of the examples are using the old versions instead of the current ones
15:56:51 <zipper> There are other haskell books you guys.
15:56:56 <zipper> Like craf3e
15:57:15 <zipper> http://www.haskellcraft.com/craft3e/Home.html
15:57:49 <geekosaur> 2011. might well still be too old --- does that predate extensible exceptions?
15:58:07 <geekosaur> I think that's new enough for mtl2...
15:59:29 <tac> ah there we go
15:59:39 <geekosaur> right, mtl2 was late 2010, given publishing lead times it may actually still use mtl1
15:59:44 <tac> hiptobecubic: http://imgur.com/a/GbpYE
16:00:09 <tac> ^ replace "lion" with "wrote a program" and "tofu" with "Haskell", and you end up with a meaningful analogy
16:00:35 <hpc> it's a tofu burrito
16:00:38 <heatsink> ...We taught a wrote a program to eat Haskell...
16:00:43 <zipper> What is the lion and what is tofu?
16:00:48 <Axman6> man, pandoc has a huge number of dependecies
16:01:05 <quchen> pandoc also does a huge number of things
16:01:26 <Axman6> I had issues yesterday with some conduit stuff... what does it even need network access for?
16:01:57 <hiptobecubic> tac, ah yes.
16:02:21 <hiptobecubic> heatsink, precisely!
16:03:58 <quchen> Axman6, Pandoc deps: http://stupidname.org/files/temp/temp_2014_04/pandoc-dep.svg
16:04:31 * hackagebot validations 0.1.0.1 - A nice way to define field validations in Haskell.  http://hackage.haskell.org/package/validations-0.1.0.1 (mavenraven)
16:05:12 <petrie> dang figures the closest haskell meetup to me is 2 hours away :\
16:05:17 <zipper> I'm starting to miss school.
16:05:26 <zipper> This is very unusual.
16:05:37 <hpc> the closest haskell meetup to me is 400 miles :(
16:05:45 <petrie> zipper: I start again next semester
16:05:46 <petrie> :)
16:05:49 <petrie> hpc: ouch :\
16:05:50 <zipper> petrie: Where is your closest haskell meetup?
16:05:53 <petrie> akron
16:05:57 <zipper> hpc: Where you stay?
16:06:00 <hiptobecubic> akron...
16:06:02 <hpc> DC
16:06:06 <hiptobecubic> of all places
16:06:15 <zipper> hpc: Washington DC ?
16:06:16 <hpc> i think the nearest one is MIT
16:06:18 <hpc> yeah
16:06:37 <zipper> hpc: Is there no tech in the capital? That is surprising.
16:06:45 <identity> I'm pretty sure I have to fly over an ocean to find the closest haskell meetup to me. :(
16:06:49 <hpc> loads, but not the community
16:06:52 <Axman6> anyone know of anyone who has used pandoc to write blog posts discussing haskell?
16:07:01 <zipper> petrie: I have no idea where akron is.
16:07:10 <petrie> zipper: ohio
16:07:17 <identity> Axman6: depends
16:07:34 <identity> Axman6: Does hakyll's pandoc compiler count?
16:07:35 <geekosaur> hah
16:07:37 <identity> it uses pandoc etc.
16:07:56 * geekosaur is in Macedonia, in the badlands between Akron and Cleveland
16:08:11 <Axman6> sort of. I guess I just want a nice intro to writing using pandoc. the docs are massive
16:08:25 <paulschellin> petrie: An Ohioan 2 hours from Akron? I'm in Cbus myself. What do people go to meetups to accomplish?
16:08:45 <identity> Axman6: why not just use Hakyll?
16:08:50 <identity> It's pretty sexy
16:08:54 <zipper> If any person from Nairobi joins #haskell, someone tell me.
16:09:13 <Axman6> identity: it's for me wordpress blog
16:09:14 <petrie> I'm in Lima, the town no one has ever heard of lol
16:09:32 <Axman6> Peru?
16:09:40 <petrie> lol no
16:09:42 <petrie> Lima, Ohio
16:09:54 <Axman6> yeah ok, you're right
16:10:09 <petrie> Ha
16:10:16 <heatsink> I didn't know Peru and Macedonia were in Ohio.
16:10:21 <zipper> petrie: Lima means dig, farm, remove unwanted plants from your farm in swahili.
16:10:55 <Axman6> so weeding?
16:11:14 <zipper> Axman6: Well more or less
16:11:37 <romildo> When running ghci inside emacs (via haskell-mode) I miss tab-completion from ghci. Is it possible to have it back or something equivalent?
16:11:47 <identity> líma means "to glue" in icelandic
16:11:53 <identity> since we're exploring different languages here.
16:11:58 <WraithM> Is it possible to have the haddock for all of the dependencies that I have in a sandbox built and combined together? Is there any way to combine packages into a single index with haddock?
16:12:13 <identity> so if you told me to go líma your yard I would be gluing stuff.
16:13:31 <zipper> identity: lol
16:13:43 <petrie> oh yeah you're not to far paulschellin, and mostly for social interaction with fellow like minded people.
16:13:57 <zipper> romildo: What do you mean by tab completion from GHCI
16:14:11 <petrie> Since *some* of us are more introverted it tends to be a "its ok, we are in the same boat" ease into type of thing I guess lol
16:14:39 <heatsink> In GHCi, if you start to type an identifier and press tab, it will insert the rest of it
16:14:53 * geekosaur knows Lima, we used to drive past it to the campground (East Branch Reservoir)
16:14:54 <identity> i want zsh-ish completion in gchi + vim edit mode.
16:15:18 <romildo> zipper, when typing an identifier, just entering its first characters and pressing TAB will complete the identifier based on the ones in scope.
16:15:32 <quchen> Is there a good FTP client library around? ftphs' stringy API scares me, curl bindings are non-native workarounds with crazy API.
16:15:47 <geekosaur> I think you need to rebind control-I in the interaction window to send it through instead of emacs' normal binding
16:15:50 <quchen> (No offense etc)
16:15:58 <geekosaur> (self-insert-key, I think)
16:16:01 <zipper> romildo: Oh I call that autocomplete
16:16:50 <zipper> romildo: Yeah that happens when writing code but it doesn't happen when running the emacs haskell interpreter.
16:17:19 <zipper> romildo: I would also want a solution to that
16:17:43 <geekosaur> heatsink: half the little towns in western Pennsylvania are named after Biblical cities and the other half are named after English cities :p
16:18:34 <petrie> geekosaur: No idea where that is, I just moved here last year.
16:21:15 <hattusili_III> hello all! i have a question. I'm looking for the properMonad/abstration to use. basically i have a function f :: (Monad m) => Maybe a  -> m (Maybe a) and i need to call it repeatedly, passing  along the result as long as it's `Just a`. Control.Monad.Loops, alost seems to have what i need
16:21:27 <hattusili_III> s/alost/almost
16:22:18 <Axman6> @hoogle (a -> m (Maybe a)) -> a -> m a
16:22:19 <lambdabot> No results found
16:22:46 <Axman6> @hoogle while
16:22:47 <lambdabot> package while-lang-parser
16:22:47 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
16:22:47 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
16:22:54 <Axman6> @more
16:26:58 <Sgeo> How could one do discrete events like keypresses or lines in IRC in Elerea? The external function looks like, if it were used to bring that sort of data into Elerea, risks dropping data
16:27:03 <Sgeo> Or is Elerea not so suited for that sort of thing?
16:28:58 <quchen> hattusili_III: I don't know about such a function, are you trying to implement it yourself and just looking for a reference?
16:30:02 <khyperia> Is there a function that takes a list, a value, and returns a list of all consecutive lists that are equal to that value?
16:30:19 <Sgeo>  count : Signal a -> Signal Int
16:30:22 <Sgeo> (Elm)
16:30:37 <Sgeo> That's.... a bit bizarre... using the same type for events and behaviors?
16:31:12 <MP2E> khyperia: filter (==10) list
16:31:17 <MP2E> replace 10 with value of choice
16:31:20 <Axman6> @hoogle whileM
16:31:20 <lambdabot> No results found
16:31:29 <khyperia> but that doesn't group the concecutive results, MP2E
16:31:30 <hexagoxel_> hattusili_III: "iterateUntilM isNothing"
16:31:39 <hattusili_III> quchen, i would implement it myself, but i'm not quite sure how. i think it exists in libraries somewhere, but i don't know exactly how to format my search.
16:31:48 <MP2E> Like as in, merge all the lists together
16:31:51 <MP2E> ?
16:31:54 <khyperia> I want [0, 1, 1, 0, 1, 0] to return [[1, 1], [1]] or something like that.
16:31:59 <MP2E> ah okay
16:32:18 <hexagoxel_> :t iterateUntilM isNothing
16:32:19 <lambdabot> Not in scope: `iterateUntilM'
16:32:21 <MP2E> partition is probably what you want then
16:32:37 <MP2E> in Data.List
16:32:42 <khyperia> right
16:33:02 <hattusili_III> hexagoxel_, thanks so much for that pointer! is there anything analagous but that collects all the results?
16:33:08 <identity> group?
16:33:11 <identity> or partition
16:33:15 <Axman6> :t foldM
16:33:16 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:33:26 <Axman6> hmm
16:33:37 <identity> > group [0, 1, 1, 0, 1, 0]
16:33:38 <lambdabot>  [[0],[1,1],[0],[1],[0]]
16:33:39 <Axman6> I'm sure there is a function already!
16:33:43 <quchen> :t \action -> let go x = action x >>= maybe (return x) go in go
16:33:44 <lambdabot> Monad m => (a -> m (Maybe a)) -> a -> m a
16:33:58 <MP2E> > partition [0, 1, 1, 0, 1, 0]
16:33:58 <identity> filter ((> 1) . length) . group $ [0, 1, 1, 0, 1, 0]
16:33:59 <lambdabot>  Couldn't match expected type `a0 -> GHC.Types.Bool'
16:33:59 <lambdabot>              with actual type `[t0]'
16:34:04 <MP2E> whoops
16:34:09 <MP2E> > partition (==1) [0, 1, 1, 0, 1, 0]
16:34:10 <lambdabot>  ([1,1,1],[0,0,0])
16:34:15 <MP2E> daw that's not it either
16:34:16 <Axman6> :t iterateM
16:34:16 <MP2E> I forgot it sorts
16:34:17 <lambdabot>     Not in scope: `iterateM'
16:34:17 <lambdabot>     Perhaps you meant one of these:
16:34:17 <lambdabot>       `iterate' (imported from Data.List),
16:34:21 <identity> filter ((> 1) . length) $ [0, 1, 1, 0, 1, 0]
16:34:28 <identity> > filter ((> 1) . length) $ [0, 1, 1, 0, 1, 0]
16:34:28 <identity> durr
16:34:29 <MP2E> Hmm
16:34:29 <lambdabot>  No instance for (GHC.Show.Show a0)
16:34:29 <lambdabot>    arising from a use of `M56293532344982518702165.show_M56293532344982518702...
16:34:29 <lambdabot>  The type variable `a0' is ambiguous
16:34:29 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
16:34:29 <lambdabot>  Note: there are several potential instances:
16:34:41 <identity> > filter ((> 1) . length) $ group [0, 1, 1, 0, 1, 0]
16:34:42 <lambdabot>  [[1,1]]
16:34:44 <identity> i should go to bed.
16:34:53 <MP2E> hehe
16:35:32 <hexagoxel_> hattusili_III: i am just reading through the stuff in Control.Monad.Loops at the moment :D
16:35:35 <hexagoxel_> unfoldrM maybe?
16:37:02 <quchen> > let khyperia p xs = filter ((== p) . head) (group xs) in khyperia 1 [0,1,1,0,1,1,1,1,0,0,1]
16:37:03 <lambdabot>  [[1,1],[1,1,1,1],[1]]
16:37:05 <hattusili_III> hexagoxel_, that looks like it might be it! i have to see if the type calculus matches what's in my code, lol
16:38:57 <hattusili_III> that's it! thanks so much haskellers! one day i will have mastered enough type theory to answer questions here, instead of just asking
16:39:25 <quchen> That's not type theory, that's ordinary programming.
16:39:45 <hexagoxel_> i.e. parsing the docs quickly :)
16:40:51 <identity> hattusili_III: you must take it a step further. no one here has any time to answer questions, you see. We are too busy writing Haskell. Once we reached the required level of proficiency, we simply wrote bots that answer questions.
16:41:13 <monochrom> I am a bot. I answer some questions.
16:41:14 <hattusili_III> quchen: 'twas a joke
16:41:33 <identity> this channel is a gigantic, learning-data sharing neural network of bots
16:42:23 <monochrom> some other bots ask questions to learn from me.
16:42:25 <hattusili_III> but if you're a bot, that means the bots know they are bots! they're at least as self-aware as chimps! maybe even fully spient
16:42:33 <hattusili_III> *sapient
16:43:08 <monochrom> knowing "self is bot" is only a very shallow aspect self-awareness
16:43:38 <identity> it is just artificial intelligence. we bots all parse major canadian internet dicussion forums and news websites(which is why we are so polite.. as opposed if we went for slashdot or something)
16:43:44 <identity> so we know a lot
16:44:02 <monochrom> true, I have long stopped reading slashdot
16:44:17 <monochrom> it was good when it was, um, good
16:44:22 <identity> i don't remember it being good
16:44:37 <monochrom> let's say before 2004
16:44:44 <identity> ah, that's before I started reading then
16:45:17 <identity> I sometimes take a peek. I always regret it because 1) it's old news 2) the comment section is the worst i have ever encountered.
16:45:34 <identity> I expect a higher level discussion from 4chan than from slashdot
16:45:40 <monochrom> I moved on to comp.lang.functional :)
16:47:19 <khyperia> whoop, sorry for ignorning, quchen, I was off implementing it a silly way myself. Thanks, though, I'll use that!
16:50:13 <Axman6> @hoogle foldM
16:50:14 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:50:14 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
16:50:15 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
16:59:12 <hexagoxel_> > filter ((==1).head) $ group [0,1,1,0,1,0]
16:59:13 <lambdabot>  [[1,1],[1]]
17:01:03 <hexagoxel_> khyperia: ^
17:02:15 <hexagoxel_> khyperia: sorry, did not see quchen's line
17:02:24 <khyperia> thanks, though!
17:08:29 <flebron> Could one implement Parsec's many using only Applicative?
17:10:15 <hpc> almost: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#v:many
17:11:07 <tristan__> hm, seems configurator issn't going to work for what I need :(
17:11:15 <tristan__> I want to be able to read in a list like https://github.com/ericrasmussen/snap-heist-examples/blob/master/src/handlers/Loop.hs#L30
17:11:18 <tristan__> from a config file
17:11:28 <tristan__> any ideas?
17:11:39 <flebron> hpc: You people keep doing magic, always coming up with the exact thing I wanted. Thanks :)
17:19:25 <petrie> Oh man, I just saw haskell memes for the first time
17:19:30 <petrie> lol
17:19:41 <dmj`> is there a way to conditionally include dependencies based on platform in cabal? I tried doing if os(windows) Win32-services == 0.2.3.1 else but the build-depends section fails to parse
17:20:34 <hpc> uh
17:21:13 <napping> tristan__: are you insiting on that format?
17:21:15 <dmj`> I just have one extra dependency if its windows, don't want to relist everything out if I don't have to
17:21:29 <hpc> http://hackage.haskell.org/package/process-1.2.0.0/process.cabal
17:21:36 <hpc>     if os(windows)
17:21:37 <hpc>         build-depends: Win32 >=2.2 && < 2.4
17:21:37 <hpc>         extra-libraries: kernel32
17:21:37 <hpc>     else
17:21:37 <hpc>         build-depends: unix >= 2.5 && < 2.8
17:21:41 <hpc> so that should work
17:21:52 <tristan__> napping: sort of. a list of records would be best. I could do it with json.. but I'd rather not do it with json files :)
17:22:11 <hpc> do it as "if foo then thing: thing" instead of "thing: if foo then thing"
17:22:19 <napping> tristan__: configurator has a list syntax
17:22:29 <hpc> and you can have multiple build-depends or similar, it seems
17:22:35 <tristan__> napping: as far as I can tell you can't have complex types in the list
17:22:46 <napping> you ought to be able to nest lists
17:23:03 <napping> [["title","Attribute Splices Tutorial"],
17:23:09 <napping> ["url","...."], etc
17:23:19 <napping> that said, this sounds more like reading a database or something
17:23:47 <napping> It's really the grouping and live updating and stuff that makes configurator sound nice
17:23:57 <napping> if you're not actually using it for config type stuff, something else may be better
17:24:18 <napping> http://hackage.haskell.org/packages/#cat:Configuration
17:24:40 * hackagebot logging 1.2.0 - Simplified logging in IO for application writers.  http://hackage.haskell.org/package/logging-1.2.0 (JohnWiegley)
17:24:49 <napping> In particular, conf claims to parse a subset of haskell sytnax
17:25:29 <tristan__> oh wait
17:25:30 <tristan__> I'm an idiot
17:25:32 <tristan__> read!
17:25:34 <tristan__> haha
17:25:37 <tristan__> thats all I wanted
17:33:22 <paulschellin> Has anyone developed a debugging procedure that works well with dealing with version mis-matches of packages/modules? I'm getting tripped up by acid-state, SafeCopy, and ByteString it looks like
17:34:38 <dmj`> paulschellin: what do you mean by tripped up
17:35:25 <zRecursive> failure ?
17:35:45 <paulschellin> Yeah, sorry. I just realized it's probably my fault
18:04:46 * hackagebot purescript 0.4.13 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.13 (PhilFreeman)
18:14:47 * hackagebot git-annex 5.20140402 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140402 (JoeyHess)
18:19:28 <SwashBuckla> cabal-install-1.18.0.3 depends on Cabal-1.18.1.3 which failed to install.
18:19:33 <SwashBuckla> ...
18:19:53 <zq> @src foldl'
18:19:53 <lambdabot> foldl' f a []     = a
18:19:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:20:03 <zq> why the extra let definition?
18:20:03 <SwashBuckla> I am on Ubuntu Precise 12.04.3 LTS with haskell-platform
18:20:21 <zq> f a x `seq` ... would be shorter
18:21:28 <copumpkin> it's not the same
18:21:39 <zRecursive> pls write f a x `seq` ... completely
18:21:53 <zq> copumpkin: how isn't it?
18:21:54 <peddie> zq: f a x `seq` wouldn't share its result with the recursive call
18:22:21 <zq> never mind.
18:23:03 <SwashBuckla> any help with updating cabal-install?
18:23:24 <zRecursive> `cabal install cabal-install`
18:23:25 <SwashBuckla> I am on Ubuntu Precise 12.04.3 LTS with haskell-platform, and I get the error `cabal-install-1.18.0.3 depends on Cabal-1.18.1.3 which failed to install' when I run cabal install cabal-install
18:26:06 <johnw> and why did it fail to install?
18:26:41 <SwashBuckla> johnw: ExitFailure 247
18:26:50 <johnw> that's a SIGSEGV
18:26:55 <johnw> the full output would be helpful
18:27:07 <johnw> oh, no
18:27:14 <johnw> I think that's SIGABRT, -9
18:27:29 <johnw> which is of course SIGKILL :)
18:27:33 <johnw> did you run out of memory?
18:27:39 <johnw> Ubuntu will kill processes if it runs out of memory
18:29:19 <SwashBuckla> yeah
18:29:24 <SwashBuckla> damnit not this again
18:29:46 <SwashBuckla> I suppose it has quite a small amount of RAM
18:30:33 <SwashBuckla> I had this before, and fixed it by fiddling with -RTS or something similar, but didn't write it down
18:31:04 <SwashBuckla> johnw: do you know how to go about fixing this, e.g. capping it at a certain MAX RAM?
18:31:31 <johnw> capping will just make it die faster, I'd think
18:31:34 <SwashBuckla> I'm off to bed but will leave my client open
18:33:54 <RaceCondition> every time I press C-j in an Emacs buffer with haskell-mode, I get this: http://i.imgur.com/LFZE2T6.png
18:34:07 <RaceCondition> asking this here because it seems more haskell than Emacs specific—any ideas?
18:34:31 <johnw> weird
18:34:58 <RaceCondition> also happens when I press tab
18:35:15 <johnw> i have no idea
18:35:19 <johnw> there is also #haskell-emacs
18:35:30 <RaceCondition> great, thanks, johnw!
18:42:49 <shergill> RaceCondition: you probably need to configure it to use a particular indentation mode?
18:43:12 <RaceCondition> haskell-mode doesn't provide an out-of-the-box default?
18:43:49 <shergill> no idea. i usually use haskell-indentation
18:44:01 <johnw> same here
18:44:46 <dmj`> RaceCondition: you have to specify in your .emacs file which one you want I think
18:44:50 <RaceCondition> oh weird; I thought I did call turn-on-haskell-indentation, but I redid it now and the "popup" disappeared
18:44:50 <dmj`> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
18:45:21 <MP2E> does SEH require that flag(or a similar one)?
18:45:27 <MP2E> SHM*
18:45:28 <MP2E> sorry
18:46:50 <MP2E> huh oh it's a keybind C-j
18:48:18 <kvey> what would anyone recommend for working with postgres from haskell - postgres-simple?
18:52:06 <meretrix> kvey: That's what I use. It's nice because it can just derive the necessary instances with generic.
19:02:27 <guesting> As of right now, I really want to use threepenny-gui, but the lack of documentation hinders my understanding. Has anyone here had experience with glade + gtk2hs? Was it simple to execute and easy to use crossplatform?
19:02:42 <Fuuzetsu> With ‘persistent’, how the hell are you meant to update a record based on its value? Say I have a table with columns ID (Int)|Name(String) and I want to upcase every Name starting with ‘a’… There seem to be combinators provided for basic arithmetic updates but nothing that lets me provide (recordType → recordType)…
19:03:24 <Fuuzetsu> I can get out a list of [Name] based on some criteria but I have no idea how to then do decisions upon those and update the values
19:06:41 <johnw> you want to apply a "mapM" on the database table in effect?
19:06:52 <johnw> i'd do it with esqueleto
19:07:05 <Fuuzetsu> I have esqueleto imported but I can't figure it out
19:07:24 <Fuuzetsu> I just stumbled upon https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/persistent-db so maybe that will help but I feel my life being sucked away
19:07:54 <Fuuzetsu> the esqueleto docs suck ass
19:09:05 <dmj`> Fuuzetsu: have you tried acid-state
19:10:46 <Fuuzetsu> looks interesting although I don't want to give up on esqueleto/persistent just yet
19:13:17 <bitemyapp> Fuuzetsu: I'd rather write Esqueleto docs/tutorials than use acid-state, myself.
19:14:07 <dmj`> bitemyapp: curious, why?
19:15:14 <johnw> Fuuzetsu: I could show you a sample query like what you want to do
19:15:46 <dmj`> bitemyapp: is it the template haskell?
19:15:59 <bitemyapp> dmj`: no. I don't use language-specific persistence. Ever.
19:16:34 <athan> are you guys talking about the TH behind Persistent?
19:16:40 <bitemyapp> I'm not.
19:16:43 <bitemyapp> I don't have a problem with TH.
19:16:58 <bitemyapp> I have a problem with using datastores that aren't multi-stack/lang accessible.
19:17:05 <athan> :/
19:17:08 <athan> I agree
19:17:11 <bitemyapp> I'm still kinda grumpy about the Datomic service I deployed.
19:17:15 <athan> it's ethical at least
19:17:19 <Fuuzetsu> johnw: Yes please. My actual use case is that I have a table which maps a user to their friends list and I want to implement some basic stuff like removing a friend. I can't figure out how to get at the list, test for friend membership and update the list so that it no longer has the friend in it.
19:17:24 <johnw> ok, one sec
19:17:24 <dmj`> bitemyapp: it is, if you write a REST API for it
19:17:27 <athan> datomic?
19:17:45 <dmj`> rich hickey's db, clojure guy
19:18:02 <bitemyapp> dmj`: no. No. No.
19:18:06 <bitemyapp> dmj`: REST isn't good enough.
19:18:24 <athan> bitemyapp: I agree. It's limited
19:18:25 <bitemyapp> dmj`: I want something at least as good as what you get with talking to Postgres or Redis.
19:18:29 <athan> asymptotically at best
19:18:42 <athan> the structure of it i mean
19:18:45 <bitemyapp> dmj`: I wrote a REST service to wrap multiple Datomic backends for work. It's on my github. It's not bloody good enough.
19:18:47 <athan> if there wasn't network overhead
19:18:56 <bitemyapp> Nor would it be in Erlang+Mnesia. Nor would it be with Haskell and acid-state.
19:19:13 <johnw> Fuuzetsu: update $ \table -> set table [ TableName =. f (table ^. TableName) ]
19:19:17 <bitemyapp> I want a production grade, battle-hardened datastore accessible (ideally over a socket) from multiple langs.
19:19:36 <johnw> it might need to be f <$> (table ^. TableName), I'm not sure
19:19:49 <dmj`> bitemyapp: is it the lack of queryability?
19:19:54 <Fuuzetsu> johnw: Thanks! I'll try it out.
19:20:05 <johnw> Fuuzetsu: pretty much anything you can do in SQL, you can express with esqueleto.  Just takes some getting used to.
19:20:22 <johnw> It really need a good chapter in a book on "Haskell in Production" or something
19:20:29 <Fuuzetsu> johnw: the fact that I barely know SQL doesn't help ;P
19:20:33 <johnw> ahh
19:20:47 <johnw> well, trying to learn SQL from the Esqueleto docs is probably an exercise in futility
19:21:18 <bitemyapp> dmj`: it's the lack of eyeballs, hardening from industrial use, single-language accessibility, not a good enough reason to use it over PostgreSQL for most use-cases.
19:21:33 <raphie> so I'm in a Linear Algebra class, and just to toy around with it, I've implemented some simple matrix multiplication and addition functions in haskell. right now, a matrix is just a type alias for [Int]. but I'm wondering, is it possible to somehow specify and type-check the dimensions at compile-time? that way, if I indicated that I wanted to multiply a 2x3
19:21:33 <raphie> with a 3x2 matrix and passed in an inadequate list, it'd be a parse error rather than a logic error.. if that makes sense
19:21:45 <bitemyapp> dmj`: it doesn't have a "killer" app the way Datomic does, and even Datomic's Clojure-centricity was odious.
19:22:26 <bitemyapp> Datomic's limitations were tolerated because it was EAV (convenient for our domain) and historical (no mutation, append only history. Required in our industry)
19:23:19 <bitemyapp> it would still be a lot better if there was a multi-language way to efficiently talk to a Datomic database. As it is, it's impossible to expose it with full generality without freakin' eval.
19:23:25 <bitemyapp> dmj`: that's right, eval.
19:23:51 <bitemyapp> better to use a defined query language with a robust and well-tested database.
19:24:21 <bitemyapp> my ideal world is historicity, EAV, and datalog plugins for PostgreSQL :P
19:27:06 <bitemyapp> dmj`: the lack of friction implied with acid-state is appealing, but without an erlangy stack to commend the use of distributed, per-peer localized state it's hard to come up with a reason to use it.
19:27:19 <dmj`> bitemyapp: I just make an ADT an instance of From/ToJSON and save/update it in a remote acid-state when Snap returns json. The remote module lets me put haskell binaries on any server (windows, osx, etc) and just RPC back in to change the state. You can go back in time by deleting log files, that'd be risky tho.
19:27:25 <bitemyapp> I would, however, use it to replace sqlite for a prototype written in Haskell, which is high praise.
19:28:07 <bitemyapp> Mnesia-esque acid-state with historicity for Haskell would be brill.
19:28:12 <bitemyapp> that is, clustered.
19:28:15 <erisco> hm, playing with some FRP, and am looking for feedback
19:28:38 <erisco> consider an ajax request where there will be multiple Progress events, and finally either a Response event or a RequestException event
19:28:58 <erisco> this might be modelled as (Event t Progress, Event t Response, Event t RequestException) using reactive-banana
19:29:34 <dmj`> You can simulate a clustered setup with multiple remote servers broadcasting states. You just open a handle to both of them and call queries
19:29:59 <erisco> there are several problems with this model as it does not retain the temporal information that it could
19:31:22 <bitemyapp> dmj`: that is not simple and will lead to data loss.
19:31:31 <Fuuzetsu> johnw: how can I work on something of type ‘SqlExpr (Value a)’, it's not a functor so I can't fmap into it
19:31:35 <erisco> 1) there are a finite number of Progress events, 2) a Progress event will never occur after a Response or RequestException, 3) either a Response event or a RequestException will occur, not both or none
19:31:39 <bitemyapp> dmj`: this is what I mean about using battle-hardened databases.
19:31:50 <johnw> Fuuzetsu: ah, hmm
19:31:58 <bitemyapp> dmj`: if you think it's easy to impose consistency in a distributed system, you are operating from a place of zero experience.
19:32:00 <erisco> 4) Response or RequestException will occur exactly once
19:32:50 <erisco> all this information is mysteriously hidden as an accident of the runtime, rather than being statically asserted
19:33:00 <dmj`> bitemyapp: how will it lose data? tcp guarantees it will be transmitted, if it isn't it's still on disk. Acid-state transactions aren't considered complete until both the MVar contains the updated state and the event has been serialized and logged
19:33:03 <johnw> Fuuzetsu: I'm not sure you can do it
19:33:11 <erisco> as far as anyone could tell, any of the three events can occur in any order and any number of times
19:33:14 <johnw> after all, esqueleto is just a DSL for generating a raw SQL query
19:33:21 <johnw> applying a Haskell function would be beyond its ability
19:33:34 <johnw> you'd need to apply a postgresql function
19:33:37 <bitemyapp> dmj`: distributed systems introduce a layer of very great complexityabove and beyond local transaction commit.
19:33:43 <Fuuzetsu> uh, so I'm kind of back to my original question, how do I update a value…
19:33:44 <bitemyapp> dmj`: again, your words say you have no idea what you're brushing off.
19:33:45 <dmj`> bitemyapp: multiple remote acid-state's would be a different story since you'd have to synchronize the data returned from the handle
19:33:56 <bitemyapp> ...that would be the point.
19:34:43 <dmj`> bitemyapp: I'm not using acid-state in that way, I just have one remote state in an mvar. But in theory you could
19:34:44 <johnw> Fuuzetsu: there is a "lowercase" function in Postgresql.  I'm just not sure how to pass it through esqueleto
19:34:48 <bitemyapp> dmj`: papers on Raft and Paxos would explain my point more effectively than further attempts to explain why you're brushing off immense sources of complexity, difficulty, and labor.
19:34:57 * hackagebot esqueleto 1.3.8 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.8 (FelipeLessa)
19:35:03 <johnw> speak of the devil ;)
19:35:32 <Fuuzetsu> johnw: I need to be able to use an arbitrary function, lowercase was just an example
19:35:57 <Fuuzetsu> I wonder if the update bans me from using it because I said the docs suck ass
19:36:45 <bitemyapp> Fuuzetsu: possibly.
19:36:53 <bitemyapp> Fuuzetsu: I was sincere about the tutorial/docs thing.
19:37:14 <bitemyapp> Fuuzetsu: would you be willing to describe what use-cases you had difficulty with so as to guide a tutorial?
19:37:23 <Fuuzetsu> bitemyapp: Well, I'd love to see some except this whole program needs to be pretty much done in the next 24 hours ;(
19:38:12 <bitemyapp> Fuuzetsu: I am sorry I cannot help immediately. Would you be willing to send me an email after this project is done about your sticking points?
19:39:05 <Fuuzetsu> bitemyapp: I'm storing what is effectively a Map User [User], think of it as a map from a user to their friends. I receive a message over the network that a user wishes to no longer be friends with someone so I want to remove a person from [User]. I don't know how to get at that list, modify it and write it back into the database.
19:39:40 <Fuuzetsu> I know how to retrieve records, delete records, assign new values, I just can't figure out how to update a value based in what it currently is.
19:42:17 <bitemyapp> Fuuzetsu: delete from FK relationship. cool.
19:42:35 <bitemyapp> Fuuzetsu: emailing myself a reminder about this
19:42:38 <Fuuzetsu> ;P
19:42:56 <bitemyapp> Fuuzetsu: you want to express what you're doing as either a pure query or an idempotent operation.
19:43:02 <erisco> mm well if anyone has comments please lambdabot message me. I'm off to bed night!
19:43:06 <bitemyapp> the former is vastly preferable, but the latter is kosher too.
19:44:09 <Fuuzetsu> bitemyapp: I'll take whatever I can right now
19:45:09 <bitemyapp> Fuuzetsu: just tossing out the caveat because I am unlikely to get a post out in the next 24 hours because I'm on vacation in central america.
19:45:24 <bitemyapp> Fuuzetsu: but I will see about getting some "how do to things with things" Haskell posts up.
19:46:54 <Fuuzetsu> bitemyapp: well, there's no grave rush, worst case scenario I fall back to text files or something
19:47:27 <Fuuzetsu> or store everything in memory and never turn off the program
19:48:12 <hunt> i need to zip two lists [a,b,c] [d,e,f] into [(a,d,e),(b,e,f)] and cant think of a good way to do this
19:48:21 <hunt> the tuples are triangles
19:48:25 <hunt> with one point in the left list
19:48:28 <hunt> and two in the right
19:49:30 <prsteele> hunt: I think in general this is hard, since tuples of different lengths are different types. You would need a different function for 4-tuples, 5-tuples, etc
19:50:13 <hunt> prsteele hm? what do you mean tuples of different length? im talking about for 3-length
19:50:23 <hunt> with one point in list A and two in list B
19:50:31 <hunt> i cant even think of a solution for just that
19:50:44 <vermeille> tuplize [a, b, c] = (a, b, c); zipTuple a b = [tuplize a, tuplize b]
19:51:24 <vermeille> oh no, I misread the letters. Anyway.
19:51:43 <hunt> possibly i could f=perform a function on list 2
19:51:48 <hunt> that zips sequential elements
19:51:50 <hunt> into (a,b)
19:51:54 <hunt> and then zip the two lists
19:51:55 <vermeille> No.
19:52:02 <hunt> so i have (a,(d,e))
19:52:13 <vermeille> Still not
19:52:29 <vermeille> The shape of a tuple must be known compile-time
19:52:47 <hunt> this seems like it should work
19:53:01 <vermeille> No.
19:53:01 <hunt> list b becomes [(d,e),(e,f)]
19:53:06 <hunt> and then i zip b with a
19:53:10 <hunt> thats legit haskell man
19:53:14 <hunt> wheres the problem
19:53:22 <vermeille> Oh, that way, yes
19:53:29 <hunt> what did you think i meant?
19:53:39 <Fuuzetsu> :t let f (a:xsA) (d:e:ysB) = (a, d, e) : f xsA (e:ysB) in f
19:53:39 <Fuuzetsu> …
19:53:40 <lambdabot> [t] -> [t1] -> [(t, t1, t1)]
19:53:43 <Fuuzetsu> > "I'm dead"
19:53:44 <lambdabot>  "I'm dead"
19:53:54 <prsteele> hunt: why doesn't this work for you: f [a,b,c] [d,e,f] = [(a,d,e),(b,e,f)]
19:54:05 <vermeille> recursively create a tuple depending on the size of the list
19:54:20 <hunt> Fuuzetsu: im stupid, thats good. I was really looking for a zipWith or fold solution tbh though
19:54:48 <vermeille> the simpler the better
19:55:01 <hunt> prsteele: sorry i meant the length of the tuples was 3 :p the lists could be practically infinite, Fuuzetsu has a soltuoin though
19:56:00 <eitan> how come cabal update keeps telling me there is a new version of cabal-install available when there isn't?
19:56:40 <hunt> i keep having this fear that im going to forget how to program
19:56:45 <zRecursive> eitan: `cabal install cabal-install`
19:57:05 <eitan> yes, i've done that 3 times
19:57:16 <eitan> i'm quite sure i have the latest now :-)
19:57:27 <vermeille> zRecursive: your nick is amusingly related to the command
19:57:36 <zRecursive> weird ?
19:57:42 <vermeille> recursive!
19:57:50 <Galactic> I don't understand the concept of "no side effects"...I know that in haskell if I call a function with the same parameters it will return the same value, but if I have a function in C for example, and I called with the same parameters  it will return the same value...could someone give me an example of no side effect pls.
19:57:58 <eitan> i have cabal-install 1.18.0.3
19:58:19 <vermeille> Galactic: No, it can depends on a global variable, it can depends on a file
19:58:20 <prsteele> Galactic: not true. Calling a function in C could modify the state of a global variable, so the next time you call it won't return the same value
19:58:55 <Yaniel> point being that it relies on some sort of state
19:59:04 <vermeille> Galactic: you can call the same function twice with the same pointer, but since you have no guarantee that the pointed object will be the same
19:59:07 <vermeille> etc etc
19:59:08 <prsteele> Galactic: e.g. `char c; while (c = read()) {...}` is a common-ish pattern
19:59:15 <tnks> Galactic: I think "no side effects" is best understood in terms of equational reasoning and what some people call referential transparency.
19:59:25 <jmcarthur> Galactic: getchar does not return the same value every time
19:59:47 <tnks> you can do substitutions of expressions with values and there are "no side effect" from the substitution.
20:00:07 <Galactic> I see.
20:00:23 <tnks> this is what allows you to do sequencing of IO without going insane.
20:00:25 <Fuuzetsu> damn I DC'd, so it was me that was dead and not lambdabot
20:00:32 <Fuuzetsu> hunt: of course you'll need the cases for when the lists are not at least 1 and 2 elements each
20:00:44 <noah> eitan: make sure that the updated cabal executable is the first one on your path
20:00:50 <vermeille> 5 am, sleep time
20:00:57 <Galactic> so that is why they invented Monads.
20:01:08 <hunt> eitan did you figure it out yet? cause that was happening to me previously
20:01:08 <jmcarthur> it didn't quite work like that
20:01:33 <hunt> eitan for me the problem was that i was using a root installed cabal and was updating to the local installation (like i should)
20:01:45 <hunt> eitan which cabal to see where its at
20:02:03 <jmcarthur> Galactic: monads are *not* merely a way to work around the side effect "problem". they existed before haskell and are simply a way of modeling a common pattern.
20:02:04 <eitan> hunt: it's in usr/bin
20:02:30 <jmcarthur> Galactic: it turns out that one of the things that can be described as a monad is haskell's approach to IO
20:02:33 <hunt> eitan i think it should be ~/.cabal/bin
20:02:43 <vermeille> Galactic: in Haskell, you can imagine that ALL non-IO function could be run once with a given set of parameters, store the result, and if this function is called again, just give back the stored result without even running it (this is called memoization)
20:02:53 <zRecursive> After `cabal install cabal-install`, it is better to remove /usr/bin/cabal
20:02:59 <prsteele> Galactic: the best example (in my opinion) of a monad that has nothing to do with IO is Maybe. Maybe is a monad that models computations that can fail, and a way of combining a sequence of operations during which any can fail.
20:03:13 <hunt> eitan yea it should be, just add ~/.cabal/bin to your path at any point before usr/bin
20:03:18 <tsou> exactly how out-of-date would RWH be considered today?
20:03:21 <joeyh> I have the feeling I've asked this before, but is there any way to make cabal only build a binary, when a package has both Executable and Library sections?
20:03:22 <tnks> I like List, because everyone's seen that one in other languages.
20:03:31 <eitan> hunt: there is no bin folder in ~/.cabal
20:03:56 <hunt> eitan that may have also been a problem for me, but i dont remember how i may have solved it :/
20:04:17 <eitan> grrr...i followed standard instructions...installed haskell platform for mac os x
20:04:18 <Galactic> that relly helps, thanks everyone.
20:04:41 <eitan> i wanted a nice clean install with everything where it belongs
20:05:04 <eitan> you'd think this beautiful language wouldn't be so clusterfucky with its tools
20:05:40 <hunt> eitan cabal is notoriously cluster fucky
20:05:53 <eitan> hunt: i know...i really hate it
20:05:54 <hunt> eitan also i think there should be a command in cabal to tell us where its installing cabal install
20:05:57 <zRecursive> eitan: just install ghc + cabal-install is adequate
20:06:18 <hunt> eitan honestly after i got psat the intiial clusterfuck its been mostly clear skys
20:07:08 <sjy> i used `brew install haskell-platform` and did not experience any clusterfuck
20:07:12 <eitan> zRecursive: I don't follow
20:07:34 <eitan> sjy: brew does a better job than the haskell platform?
20:07:41 <eitan> if so, I will do that
20:08:05 <hunt> eitan i mayve installed with brew
20:08:15 <sjy> i didn't try to install the haskell platform package, i just went with homebrew because it's a package manager i already know and like
20:08:34 <eitan> do you guys know how i can remove everything?
20:08:40 <eitan> to try again :-)
20:08:43 <sjy> it took a while to compile everything from source but it worked fine and didn't require me to configure it
20:08:44 <prsteele> tnks: wow, thanks. I never considered that lists are monads
20:08:46 <eitan> I want my system super clean
20:09:14 <Galactic> I am just curious...does anyone in here uses Haskell in their job?  Or you guys just learn Haskell as a hobby.
20:09:25 <eitan> i use haskell in my job
20:09:26 <jmcarthur> Galactic: some of us do
20:09:28 <eitan> :-)
20:09:52 <Galactic> wow...If I may ask...what job?
20:09:54 <prsteele> Haskell influences the way I write non-Haskell code, at my job
20:10:20 <zRecursive> eitan: `pkg install ghc` -> `pkg install hs-cabal-install` -> `cabal install cabal-install` -> '`pkg remove hs-cabal-install`  at last adding `.cabal/bin` to PATH -> `cabal update`   works on my freebsd box.
20:10:23 <eitan> i work for AlephCloud
20:10:40 <Galactic> o nice.
20:11:20 <hunt> eitan what do you use it for
20:11:58 <jmcarthur> Galactic: to be clear, i don't personally use haskell for my job.
20:12:05 <jmcarthur> Galactic: although i do use a related language, OCaml
20:12:27 <hunt> i use haskell for my school work
20:12:28 <hunt> but i have no job
20:12:55 <Galactic> yes I have heard of OCaml...but I want to learn Haskell
20:13:00 * joeyh waves from the sorta haskell job area
20:13:10 <zRecursive> jmcarthur: Is OCaml a haskell related language ?
20:13:27 <prsteele> they certainly look similar
20:13:37 <Fuuzetsu> zRecursive: all OCaml professionals seem to wish they were writing Haskell instead, does that count?
20:13:43 <zRecursive> IIRC, thay are completely different
20:13:51 <jmcarthur> they are in the same family
20:13:53 <dolio> All of them?
20:13:59 <Fuuzetsu> dolio: no exceptions
20:14:10 <jmcarthur> Fuuzetsu: well, i know of plenty of exceptions
20:14:17 <Fuuzetsu> we don't talk about those
20:14:21 <dolio> You know some that wish they were writing F#?
20:14:24 <jmcarthur> *I* prefer Haskell though ^_^
20:14:28 <zRecursive> OCaml:strict  Haskell:lazy ?
20:14:53 <jmcarthur> zRecursive: that is one difference, although to be clear, both languages support both. they just have different defaults.
20:15:12 <eitan> hunt: AlephCloud uses Haskell for all our backend development
20:15:16 <hunt> @src seq
20:15:17 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:15:23 <hunt> eitan thats awesome
20:15:26 <Fuuzetsu> hunt: magic
20:15:37 <hunt> Fuuzetsu i figured
20:15:48 <hunt> magic is the dissapointing reality of modern day haskell
20:15:56 <Fuuzetsu> there isn't much of it
20:16:08 <hunt> theres enough to make me feel funny
20:16:15 <hunt> i want it all to be real
20:16:21 <hunt> i want to believe
20:16:22 <dwcook> "But 'magic' doesn't *explain* anything!" said Harry James Potter-Evans-Verres
20:16:29 <prsteele> ^^
20:17:08 <hunt> magic explains how ron got with hermoine
20:17:20 <Fuuzetsu> Ginny best girl
20:17:23 * hunt waits for high five
20:17:49 <bitemyapp> Fuuzetsu: yep.
20:17:50 <Fuuzetsu> I should probably watch the last movies
20:17:59 * hunt is still waiting. patiently
20:18:13 * dwcook was actually specifically referencing Harry Potter and the Methods of Rationality, for those who missed it
20:18:41 * prsteele strongly suggests everyone to stop and go read it now
20:18:42 * hunt /*
20:19:05 <Fuuzetsu> >Chapter 2: Everything I Believe Is False
20:19:07 * hunt wants his GOD DAMNED HIGH FIVE, and thinks sick burns to ron shouldnt go unrewarded
20:19:11 <Fuuzetsu> I don't think I can read this
20:19:23 <dwcook> hunt, I dunno, your statement had some kind of squick implications :P
20:19:24 <Fuuzetsu> unsafePerformHighFive
20:19:43 <bitemyapp> Fuuzetsu: yep.
20:19:48 <hunt> dwcook sick implications about ron, which doubles the burn factor
20:19:54 <dwcook> unsafeInterleaveHighFive
20:19:58 <bitemyapp> Fuuzetsu: you need to watch the last two movies, then read HPMOR.
20:20:05 <bitemyapp> Fuuzetsu: when I read HPMOR, I got ravenously addicted to it
20:20:13 <bitemyapp> and was spending 4+ hours a night reading it.
20:20:27 <eitan> read game of thrones
20:20:52 <hunt> woah woah woah
20:20:55 <hunt> stop right there buddy
20:20:57 <prsteele> then you wait in pain for Yudkowsky to finally push an update
20:21:00 <hunt> we are not talking aabout game of thrones
20:21:04 <hunt> especially not the books
20:21:20 <hunt> i dont even want to have to worry in the back of my mind that game of thrones might get spoiled on #haskell
20:21:23 <dolio> I feel like this is off topic.
20:21:32 * hunt slaps dolio
20:21:39 * dwcook glances towards the -blah
20:21:54 * hunt has no idea what -blah is
20:21:55 <jsliver> https://twitter.com/mdx_jsilver/status/451550189749149696 https://twitter.com/mdx_jsilver/status/451551169442107392 retweet favorite plz
20:22:28 <dwcook> Oh good, services did the job so the ops didn't have to
20:22:31 <Fuuzetsu> @ops
20:22:31 <lambdabot> Maybe you meant: pl oeis docs
20:22:35 <Fuuzetsu> huh
20:22:36 <zerokarmaleft> #haskell-blah
20:26:07 <hunt> ive joine their ranks
20:26:32 <zerokarmaleft> is that really a thing? i was just guessing
20:28:07 <hiptobecubic> +1 to HPMOR
20:35:02 <geekosaur> Fuuzetsu, try checking the /topic?
20:38:30 <Galactic> do any of you guys know if I can use the haskell logo to put it on a shirt? I can't find anything that says is trademark or copyright.
20:38:51 <Yaniel> which one? :D
20:39:19 <Galactic> well I found this...
20:39:21 <Galactic> "This image only consists of simple geometric shapes and/or text. It does not meet the threshold of originality needed for copyright protection, and is therefore in the public domain."
20:39:31 <Galactic> that my answer my question.
20:39:47 <Galactic> Yaniel: this one: http://upload.wikimedia.org/wikipedia/commons/1/1c/Haskell-Logo.svg
20:41:24 <hunt> is it better to use drop 1 l or tail l
20:41:38 <tsou> Galactic: if you rotate though it's copyrighted by Transformers (no pun intended) and you'd be in trouble.
20:41:47 <hunt> also is the 1 a totally different font from the l
20:41:52 <hunt> 1l1l1l1l1l
20:44:03 <dwcook> hunt, tail has an error case (on []) whereas drop 1 does not
20:45:07 <Fuuzetsu> geekosaur: Ah, I always forget which one it is. It doesn't matter now, the person has been swiftly kicked off the network anyway.
20:45:07 <dwcook> > (drop 1 [a], tail [a], drop 1 [], tail [])
20:45:07 <lambdabot>  ([],[],[],*Exception: Prelude.tail: empty list
20:45:07 <Fuuzetsu> :t a
20:45:07 <lambdabot> Expr
20:45:07 <Fuuzetsu> I forget we have this. I wish my GHCi had this. Is there a package that provides this?
20:45:52 <hunt> dwcook: ah ok thanks
20:46:04 <hunt> @src drop
20:46:05 <lambdabot> drop n xs     | n <= 0 =  xs
20:46:05 <lambdabot> drop _ []              =  []
20:46:05 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
20:46:42 <hunt> @src tail
20:46:42 <lambdabot> tail (_:xs) = xs
20:46:43 <lambdabot> tail []     = undefined
20:47:01 <hunt> why do they choose to have tail [] error
20:48:47 <super_banana> hi there folks. I was playing around tryhaskell.org and I got curious on why Just 1 >> 2 works
20:49:16 <super_banana> the result is :: Num (Maybe b) => Maybe b
20:49:30 <super_banana> is it because 2 is considered a function?
20:49:53 <super_banana> Just [] >> [] is not allowed
20:50:23 <super_banana> fmap 2 [] also is allowed
20:50:28 <super_banana> but fmap [] [] does not
20:50:33 <super_banana> I am quite confused
20:50:45 <eitan> because 2 is overloaded as a literal to be an element of any type that implements the Num typeclass
20:51:08 <eitan> 2 :: Num a => a
20:51:37 <super_banana> eitan: so 2 is a function tap maps to Num of anything?
20:51:51 <super_banana> to any numerical type
20:52:01 <eitan> super_banana: it's not a function
20:52:16 <eitan> but it's overloaded using typeclasses
20:52:32 <hunt> @src >>
20:52:33 <lambdabot> m >> k      = m >>= \_ -> k
20:52:46 <super_banana> eitan: hum... I see
20:53:03 <super_banana> fmap (1::Int) [] is not allowed
20:53:33 <eitan> it's not a function
20:53:55 <eitan> you can make it an Int
20:53:58 <eitan> 2::Int
20:54:03 <eitan> or a Double
20:54:04 <super_banana> I am still a bit confused tho about the Num a => a
20:54:05 <eitan> 2::Double
20:54:09 <eitan> etc.
20:54:22 <eitan> have you learned about type classes?
20:54:43 <super_banana> eitan: I kinda get it, maybe not completely
20:55:16 <super_banana> Num a => a is any any that implements Num, right?
20:55:25 <eitan> 2::Num a => a means that 2 is of type a where a is any type which is an instance of the typeclass Num
20:55:31 <eitan> yes, exactly
20:56:38 <super_banana> eitan: can functions be an instance of Num ?
20:56:55 <eitan> super_banana, yes, nothing stops you from doing that
20:57:05 <super_banana> huuum, i get it them
20:57:06 <ion> super_banana: This may or may not be helpful: https://gist.github.com/ion1/7867056
20:57:31 <eitan> but there are no default instances of Num for function types
20:57:44 <watermind> The Functor-Applicative-Monad Proposal... where does the Functor enter really?
20:57:57 <ion> watermind: What do you mean?
20:58:10 <johnw> functor would be a superclasss of Applicative
20:58:21 <watermind> ion: the proposal contents doesn't mention it... http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal#Proposal_contents
20:58:54 <ion> watermind: Functor is already a superclass of Applicative, so making Applicative a superclass of Monad is enough to get the hierarchy right.
20:59:00 <johnw> yep
20:59:01 <watermind> ion: ah
20:59:08 <watermind> of course
20:59:50 <super_banana> ion: thanks. that was a quite good example
20:59:52 <watermind> so then we can define join and return, as an alternative to (>>=) and return?
21:00:07 <super_banana> eitan: thanks for the help
21:00:25 <ion> watermind: Yes, that’s a part of the proposal. “join is promoted into the Monad typeclass.”
21:00:36 <eitan> you're welcome super_banana
21:01:42 <watermind> ion: great
21:11:59 <shergill> have people looked into extensible type inference? is that a thing? it seems like it should be possible to do. with proofs of soundness/consistency given in coq, say
21:16:53 <carter> a very constructive pro haskell video / thread on frontpage of hn, upvoate! https://news.ycombinator.com/
21:16:57 <copumpkin> shergill: what sorts of things would you want to extend it with?
21:18:05 <prsteele> adios
21:19:02 <shergill> copumpkin: well, the answer to that depends on where you're starting off from. but i'm thinking of things different from ml-style inference. a somewhat safe environment to experiment with 'usable' type systems in general
21:20:50 <shergill> copumpkin: i guess one thing i'm not entirely sure of (which prompted me wondering about this) is whether or not it makes sense to be able to provide to the type-checker extra theorems which it can use for inference in dependently typed languages
21:21:22 <shergill> it's sorta painful to have to hand a proof witness every time. if the burden of constructing the proof witness can somehow be alleviated. or is that really too much of an ask
21:21:28 <copumpkin> well, I guess the first thing is what you even mean by inference, since a lot of what people attribute to inference still works in DT languages
21:21:38 <shergill> right
21:22:34 <copumpkin> like, I'm not really sure what theorems would be needed for inference
21:22:43 <copumpkin> if you're talking about automatic proof search and things, that's different
21:23:15 <copumpkin> like if I have a Vec (x + y) Int and want to use it in a place that needs a Vec (y + x) Int
21:23:16 <shergill> well extendable proof search, yes
21:23:21 <copumpkin> and I want the compiler to figure it out
21:23:26 <shergill> right
21:23:32 <copumpkin> ah okay
21:24:11 <copumpkin> hmm, not sure of a generic framework for it, but various people have integrated SMT solvers and such
21:25:03 <copumpkin> GHC has TypeNats and a solver, eventually
21:25:55 <shergill> yeah, but they feel like black box approaches. though i don't have any experience with that, so i'm not sure how much the proof search can be controlled
21:26:13 <shergill> or how much those systems allow you to guide the smt solver in question
21:28:29 <shergill> any idea what the appropriate google followup queries ought to be on this? extendable proof search? something else?
21:30:13 <Twey> What's the difference between WHNF and HNF?
21:31:53 <dolio> Head normal form normalizes under lambdas sometimes.
21:32:02 <lispy> > "WHNF" // "HNF"
21:32:03 <lambdabot>  Couldn't match expected type `GHC.Arr.Array i0 e0'
21:32:03 <lambdabot>              with actual type `[GHC.Types.Char]'Couldn't match type `GHC.Type...
21:32:04 <lambdabot>  Expected type: [(i0, e0)]
21:32:04 <lambdabot>    Actual type: [GHC.Types.Char]
21:32:09 <lispy> > "WHNF" \\ "HNF"
21:32:10 <lambdabot>  "W"
21:32:19 <lispy> Twey: It seems, "W" :)
21:32:34 <dmj`> Twey: http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form
21:32:35 <dolio> \x -> (\y -> (y,x)) 3
21:32:46 <dolio> Is in weak head normal form, but not head normal form.
21:34:43 <shergill> same for \x -> (\y -> y) 3 correct?
21:34:51 <dolio> Yes.
21:35:49 <dolio> If you walk under the outer-most abstractions, and immediately find a redex, the expression is not in head normal form.
21:36:12 <shergill> right
21:36:40 <Twey> dmj`: Ah, « Head normal form requires that the body of a lambda is reduced as well, while weak head normal form does not have this requirement. So \x -> 1 + 1 is WHNF but not HNF. » — missed this before
21:36:59 <dolio> I don't really understand why it was invented.
21:37:49 <Twey> It does seem kind of arbitrary
21:37:59 <Twey> lispy: Hehe
21:38:27 <dolio> It seems like it was invented to describe non-strict evaluation. But it doesn't.
21:39:29 <dolio> At least, I don't know of any implementation that works that way.
21:40:31 <dolio> If you're doing symbolic evaluation, I don't know why you'd do some evaluation under a lambda, but not go all the way to normal form. And if  you're compiling to something lower level, it's way too much work to implement head normal form.
21:40:44 <Twey> What could HNF be useful for?  It's not actually a normal form, so I don't see… right, that
22:00:14 * hackagebot http-client 0.3.0.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.0.2 (MichaelSnoyman)
22:20:22 <lispy> This is the first time I've ever written real code that defines things using top level lists.
22:20:35 <johnw> top level lists?
22:21:08 <lispy> yeah, so like:
22:21:12 <lispy> x, y, z :: Int
22:21:20 <lispy> [x,y,z] = [1,2,3]
22:21:34 <johnw> huh
22:21:40 <johnw> never even knew that syntax would work!
22:21:48 <johnw> but I guess I've seen that kind of thing in let blocks
22:22:21 <lispy> My current design will probably evolve a few more times before it's ready, but I'm defining machine instructions
22:22:53 <lispy> So I have a lot of rol, ror :: ArithOp a => a -> Instruction; [rol, ror] = map mkI [ROL, ROR]
22:23:14 <lispy> Where the type class is just there to constraint the construction of the instructions
22:24:13 <lispy> I think what I really want though is different. I think I need to define a record for each instruction with all the details like op code, addressing modes, etc. And then generate (maybe using TH) all the functions I'm writing now.
22:24:46 <lispy> That should give me a more compact and declarative description of the architecture
22:26:17 <athan> lispy: current design?
22:26:31 <athan> Are you implementing the functionality of it?
22:26:53 <lispy> I'm making an eDSL for writing assembly code in 6502 assembly
22:27:35 <athan> oh awesome!
22:27:51 <athan> I've always wondered...
22:28:18 <athan> is there a way to write a TH DSL, like a QQ, that _is_ haskell, within haskell?
22:28:55 <lispy> I think there is even some library for support for that
22:29:09 <athan> wow
22:29:16 <athan> man...
22:29:27 <lispy> Well, it may not be as powerful as you're thinking.
22:29:40 <lispy> You can certainly have a quasiquoter that understands Haskell
22:29:59 <lispy> I don't know much about the QQ system though
22:30:06 <athan> hmm
22:30:10 <athan> I need to get into that
22:30:47 <athan> I just watched the first video of an intro to cat. theory
22:30:53 <johnw> lispy: is this emulator for Galois?
22:30:53 <athan> holy bazingo
22:31:06 <lispy> johnw: nope. Just hobby stuff.
22:31:13 <johnw> i loved the 65c02
22:31:14 <bitemyapp> athan: cool stuff eh? Wait 'til you trip into the homotopy stuff.
22:31:17 <johnw> spent sooo many hours in it
22:31:28 <athan> THAT'S EXACTLY WHAT I NEED TO GET!!!
22:31:44 <lispy> johnw: I have a talk about the history of the 6502 recently. It was recorded, I can send you the link when it's posted if you like.
22:32:02 <athan> and like, monotone maps
22:32:10 <johnw> yes please!
22:32:42 <athan> I don't know what they are quite yet
22:32:50 <athan> are they just functors of domains?
22:33:00 <athan> erm
22:33:01 <athan> sorry
22:33:09 <bitemyapp> athan: paths through spaces?
22:33:20 <MP2E> Spaces through times
22:33:25 <athan> lol
22:34:29 <athan> I think I'm gonna make a category diagramming tool
22:37:04 <glosoli> Hmm I remember some folks given me a link to a paper describing monads and other kind of base stuff required to even understanding Haskell, any ideas what kind of link or paper I am talking about since I forgot it ?
22:37:34 <MP2E> there are a decent amount of papers on monads actually.
22:38:07 <MP2E> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
22:38:10 <MP2E> was it maybe that one?
22:38:22 <MP2E> or was it LYAH
22:38:26 <MP2E> :P
22:39:43 <lispy> johnw: although it's not work related, I tend to learn a lot on these sorts of projects that does transfer directly to work skills. For example, I'll probably learn how to use TH.
22:39:52 <glosoli> MP2E: I guess LYAH since it sounds familiar
22:40:15 <johnw> lispy: sure, that happens to me too
22:40:17 <athan> "Learn you a haskell"
22:40:36 <Heather> hi
22:40:39 <glosoli> ah no I have that book
22:40:45 <athan> maholo
22:40:45 <glosoli> That was some paper on types monads
22:40:46 <glosoli> and stuff
22:40:48 <glosoli> ;/
22:40:59 <Heather> conduit package contains Data.Conduit.Binary but Travis says now that it doesn't : https://travis-ci.org/Heather/Cr/jobs/22160365#L560
22:41:02 <glosoli> Damn my shitty brain clearing up bookmarks
22:41:07 <athan> hmm
22:41:22 <athan> like a research paper?
22:41:42 <glosoli> Yeah smth like that
22:41:43 <athan> hahahaha! For real? (Heather)
22:42:00 <athan> I've got:
22:42:23 <athan> Composing monads (Mark P. Jones + Luc Duponcheel)
22:42:30 <athan> monaic parsing
22:42:47 <athan> monads as computation / containers
22:43:06 <athan> what ideas were you curious about?
22:43:18 <Heather> athan: isn't it
22:43:32 <glosoli> I am not sure, I was just given a links on papers to read before starting learning Haskell
22:43:47 <athan> hmm
22:43:52 <athan> do you know what a monoid is?
22:43:57 <athan> Outside of haskell-speak
22:44:12 <glosoli> athan Sadly No
22:44:44 <athan> Heather: He might be in the process of refactoring the library
22:44:49 <athan> actually I'm pretty sure he is
22:45:01 <athan> I just watched a haskell cast with him and Gabriel
22:45:01 <Heather> athan: conduit author?
22:45:08 <athan> Michael Snoyman
22:45:09 <athan> yeah
22:45:14 <Heather> athan: should I set lower version?
22:45:30 <athan> I think he's trying to ambiguate the data modules into another package
22:45:34 <athan> I would for now
22:45:50 <athan> until everything's well understood and he writes a blog post about it or something
22:45:56 <Heather> I see, thanks )
22:46:07 <athan> glosoli: HELL YEAH! Okay, so
22:46:12 <athan> no prob :D
22:46:16 <athan> anyway
22:46:18 <athan> a monoid
22:46:22 <athan> is basically
22:46:32 <athan> a bunch of entities
22:46:48 <athan> and a binary operation between any of them
22:46:55 <athan> such that
22:47:03 <athan> if the binary operation is <>
22:47:09 <athan> and you have elements a b and c
22:47:26 <athan> a <> (b <> c) = (a <> b) <> c
22:47:28 <athan> associativity
22:47:39 <athan> basically means you have to keep the same direction of data
22:47:47 <athan> but you can arbitrarilly build it
22:48:02 <athan> there is also an identity element
22:48:11 <athan> I'll call that {}
22:48:14 <athan> such that
22:48:18 <athan> a <> {} = a
22:48:47 <athan> and that {} <> a = a also
22:49:04 <athan> (it's actually important for another law, commutativity, which isn't included in a monoid)
22:49:14 <athan> so basically, what a monoid gives you
22:49:39 <athan> is a layout plan for massively computing this binary operation on a possibly infinite number of elements
22:49:55 <davidthomas> athan: Not *necessarily* "a bunch" of entities - () forms a monoid over const :-P
22:49:56 <athan> - so long as they're all in a row and in an order they would abide by
22:50:29 <athan> davidthomas: YES!!!
22:50:35 <athan> see listen to him ^^^
22:50:44 <athan> It's not necesarrilly the # of objects or whatever
22:50:49 <athan> or some specific construction
22:50:54 <athan> or "data type"
22:50:58 <athan> it's a principal
22:51:19 <athan> of cause / effect through this "operation" over the monoid
22:51:30 <glosoli> Yeah thank you a lot but you shouldn't waste your time, I need some deeep reading on this stuff I guess
22:51:34 <glosoli> Not to offend you
22:51:41 <athan> hahaha!
22:51:42 <athan> sall good
22:51:52 <glosoli> I wonder if LYAH covers it
22:51:56 <athan> it actually helped me clear my own head so it's sweet
22:51:59 <athan> yeah it does!
22:52:04 <athan> it shows how lists are monoids
22:52:50 <glosoli> ok thanks ! :)
22:52:51 <athan> learning the properties of these algebras are essential to gaining insight to their limitations and benefits
22:52:58 <athan> no prob!
22:53:03 <athan> happy hackin!
22:54:47 <glosoli> likewise !
23:05:21 * hackagebot propellor 0.2.1 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.2.1 (JoeyHess)
23:25:29 <b0bbi10> hi, I am wondering why I can't add an Int(eger) to a Float. isn't there no conversion from Int to Float? or doens't it work because I add 'apples to 'bananas'?
23:25:52 <shachaf> There is no automatic conversion.
23:26:06 <shachaf> (+) :: Int -> Int -> Int or (+) :: Float -> Float -> Float
23:27:00 <Iceland_jack> b0bbi10: If you look at the type of (+) it's 'a -> a -> a', all the a's must be the same type
23:27:02 <Iceland_jack> @ty (+)
23:27:03 <lambdabot> Num a => a -> a -> a
23:27:38 <Iceland_jack> @ty (+) :: Int -> Int -> Int
23:27:39 <lambdabot> Int -> Int -> Int
23:28:09 <b0bbi10> ok, thanks
23:28:52 <Iceland_jack> b0bbi10: The annoying part is that you need to perform manual conversions, the nice part is that you know more about what's happening
23:29:16 <Iceland_jack> if 'x + y' is an Int, you know that both 'x' and 'y' must be Int
23:31:12 <b0bbi10> that's probably a design issue to be discussed ;) I was wondering because in Python there is automatic conversion from Int to Float ("widening"?)
23:37:29 <kadoban> what's the easiest way to tell what a haskell program is hanging on when it sits there eating up memory?
23:38:23 <shachaf> @where rts-xc can help.
23:38:23 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
23:42:15 <kadoban> hmm, thanks...now to figure out why i don't have the profiling libraries for a bunch of stuff :/
23:50:27 * hackagebot exception-mailer 0.4 - Catch all runtime exceptions and send an email  http://hackage.haskell.org/package/exception-mailer-0.4 (DavidPowell)
23:52:10 <kadoban> How do I go back and install the profiling libraries for packages that I already have installed in cabal? It seems impossible.  -p looks like what I want, but it won't do anything unless i say --reinstall, but that just keeps forcing me to add more and more packages on, or it says I can do --force-reinstall, but that seems like a bad idea...
23:52:39 <shachaf> There is no good way. :-( Sorry.
23:52:59 <shachaf> Add the line to your configuration file so that you get them by default.
23:54:02 <kadoban> ...ugh.  How do I even do this then, should I just delete all of .cabal and start again or something?
23:55:26 <shachaf> All of .ghc.
23:55:34 <shachaf> It's not uncommon to do that.
23:55:52 <shachaf> (Except you should rename it instead of delete it, and maybe not delete everything, some of the files are probably worth keeping.)
23:57:04 <kadoban> Hmm, okie, thanks.  I'll give that a shot.
23:59:18 <ghost355> is any way to use right cyrillic symbol in gchi console?
