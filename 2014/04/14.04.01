00:03:18 <dolio> athan: One way of thinking about it is that (exists a. P a) -> T is the same as forall a. (P a -> T).
00:03:34 <athan> ahhhh
00:03:35 <athan> hmm
00:03:50 <dolio> So if you except an existential argument, you must be parametric in the same way as having a universal.
00:03:51 <athan> now this is getting interesting
00:04:07 <athan> see, that's where I'm lost
00:04:20 <athan> I just learned the first step today
00:04:40 <athan> so do these statements create wrappers around the whole scope they are in?
00:04:53 <athan> as lambda parameters?
00:05:11 <athan> forall / exists statements, I mean
00:05:11 <dolio> I'm not sure what that means.
00:05:21 <athan> hmm
00:05:58 <dolio> I guess another element is...
00:05:59 <athan> why is T involved in the wrapper?
00:06:04 <athan> of the last one?
00:06:07 <athan> er
00:06:12 <athan> the latter I meant haha
00:06:23 <athan> sorry, not very good at particularization
00:06:37 <dolio> T is involved because I needed a function arrow.
00:06:44 <athan> i mean, correctly particularating
00:06:45 <athan> lol
00:06:54 <athan> hmmmmm
00:06:57 <athan> so the function arrow
00:06:57 <dolio> (exists a. P a) -> ... is the same as forall a. (P a -> ...)
00:07:07 <dolio> As long as that doesn't capture variables.
00:07:09 <athan> fully coveres all values?
00:07:46 <athan> and that's due to how it's equated at the morphism level, correct?
00:07:50 <zipper> Small lens question:
00:07:53 <zipper> While reading https://www.fpcomplete.com/user/tel/lenses-from-scratch#composition I stumbled upon the following issue https://gist.github.com/urbanslug/9909153
00:07:56 <athan> that there are arrows from Type A to Type B
00:08:02 <zipper> My problem is in the composing part of the gist.
00:08:05 <athan> the forall statement requires full comprehension of A
00:08:34 <athan> or, I'm sorry
00:08:50 <athan> the forall statement requires full comprehension of any type within Hask, to B
00:08:56 <athan> correct, dolio?
00:09:06 * hackagebot mime-mail-ses 0.2.2.2 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.2.2.2 (MichaelSnoyman)
00:09:06 * hackagebot tagstream-conduit 0.5.5.1 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.5.5.1 (YiHuang)
00:09:11 <dolio> I guess. :)
00:09:14 <athan> zipper: This one might be tough for me, but I'll stick it out with you!
00:09:15 <athan> hahaha
00:09:27 <zipper> athan: What?
00:09:30 <dolio> So, the thing I was going to mention....
00:09:39 <dolio> If foo has type forall a. ...
00:09:59 <dolio> Then in the definition of foo, it isn't allowed to know what a is.
00:10:02 <athan> zipper: I haven't used lens yet, but I've been meaning to. Anyway, I'm willing to help
00:10:13 <athan> yes!
00:10:16 <athan> exactly
00:10:19 <dolio> If foo has type exists a. ...
00:10:25 <zipper> athan: uh ok so where is the problem?
00:10:33 <dolio> Then _outside_ the definition of foo, no one is allowed to know what a is.
00:11:05 <athan> zipper: I don't know yet, give me a break dude lol
00:11:10 <dolio> So the hiding is flipped.
00:11:15 <athan> HOLY SHIT
00:11:17 <athan> NO KIDDING
00:11:18 <athan> wow
00:11:23 <athan> holy crapcakes
00:11:27 <athan> and corndogs
00:11:34 <athan> that is awesome
00:12:15 <zipper> athan: Sorry :(
00:12:43 <athan> sall good maygne!!
00:12:50 <athan> I just printed out the paper on lenses
00:12:57 <athan> hopefully I'll gain insight
00:13:21 <dolio> So, that's kind of why the exists argument is equivalent to a forall.
00:13:21 <athan> ...too bad lenses are clear.... :|______(
00:13:41 <athan> dolio: I bet
00:13:49 <athan> dolio: that's gonna be tough/fun to realize
00:13:54 <athan> dolio: er recognize
00:13:57 <athan> to get to that level
00:14:11 <zipper> athan: haha why print? You can't read on screen?
00:14:23 <dolio> When you take an exists as an argument, you can't know what's inside, but people who call the function can know when they construct it.
00:14:55 <athan> zipper: I actually can't man, it's getting harder every day
00:15:08 <athan> solice is in the lack of decomposition of my body, now
00:15:10 <athan> :D
00:15:25 <athan> look at that smiley
00:15:28 <athan> LOOK
00:15:29 <athan> lol
00:15:42 <athan> jk hahaha
00:15:50 <athan> not about the eyesight thing, though
00:15:50 <zipper> athan: Damn dude are you old?
00:15:57 <athan> im 22 years old
00:15:58 <athan> lol
00:16:22 <zipper> Sorry man. I'm 21 and I feel old.
00:16:36 <athan> It's all good, something you have to realize with life
00:16:38 <athan> is that pain
00:16:44 <athan> doesn't deserve your attention
00:17:01 <athan> :)
00:17:15 <athan> but i mean
00:17:20 <athan> unless it's like an actual need
00:17:23 <athan> and you want to stay alive
00:17:24 <zipper> athan: Ok while reading I figured that we are passing the composed function a structure similar to ((a,b),c)
00:17:30 <athan> then you may have to choose to fight your instinct
00:17:32 <athan> so idk
00:17:45 <athan> hmm
00:17:46 <athan> okay
00:18:03 <zipper> I might be wrong.
00:18:29 <athan> i think you're right
00:18:37 <zipper> athan: I didn't understand the rest of what you said.
00:18:50 <athan> it's all good haha
00:19:07 <athan> only people that've suffered for extended periods of time really get it
00:19:10 <athan> or idk
00:19:12 <athan> idk
00:19:18 <athan> i might just be a terrible english-er
00:19:22 <athan> er
00:19:27 <athan> think-inizer
00:19:30 <athan> person
00:19:31 <athan> idk
00:19:35 <athan> i hope not
00:19:53 <athan> hahahaha nevermind
00:19:55 <athan> moving on...
00:20:17 <athan> so what's the type of 1b?
00:20:41 <athan> Lens a b?
00:21:56 <athan> i thik
00:21:57 <athan> think
00:22:03 <athan> in your composition definition
00:22:06 <athan> you should have
00:22:09 <athan> get 1b whole
00:22:13 <athan> in the most inner-nest
00:22:29 <athan> i think
00:22:33 <athan> idk man
00:22:40 <athan> this is all type-follary to me
00:22:49 <athan> I don't have the science down yet
00:22:53 <zipper> athan: The inner nesting should give a whole too
00:23:49 <zipper> athan: Let me gist it for you :)
00:24:23 <zipper> I must say it feels human when I see someone else who doesn't seem to just know how everything works.
00:24:46 <athan> oh wait
00:24:48 <athan> yeah you're right
00:25:01 <athan> RIGHT
00:25:02 <athan> lol
00:25:05 <athan> it's weird
00:25:14 <athan> this common interest group we have here
00:25:23 <athan> there's such a learning curve
00:25:35 <athan> I feel like I'm at the point where I can comfortably take on a challenge
00:25:47 <athan> everything a month ago would just give me a heart attack haha
00:26:37 <athan> man
00:26:45 <athan> I feel like this all ties the knot a whole lot
00:31:37 <makalu> I'm interfacing to a C++ library that needs a global object to exist while it's used. How would I do this in Haskell? In every FFI function, I would have to use withForeignPtr to keep it alive. It would be a real pain if every function would have this extra parameter. Maybe "ReaderT IO" would help but that seems too much for a simple library.
00:32:56 <dmwit> Perhaps you overestimate the pain.
00:39:05 * hackagebot cabal2ebuild 0.0.15.8 - make gentoo's .ebuild file from .cabal file  http://hackage.haskell.org/package/cabal2ebuild-0.0.15.8 (YoshikuniJujo)
00:44:08 <zipper> athan: Look again at https://gist.github.com/urbanslug/9909153 composing
00:45:39 <dmj`> Does anyone know why I'd be seeing the error, "Warning the package list for the local repo is missing, the repo is invalid" When I call cabal sandbox init on an existing sandbox?
00:53:20 <zipper> I get that on existing sandboxes too I think. Not sure but I think it happened to me once.
00:59:48 <dmj`> It has to be a bug, the package list is not missing
01:00:31 <dmj`> is there a cabal irc channel?
01:01:48 <byorgey> dmj`: there's #hackage which is the next best thing
01:02:39 <dmj`> byorgey: thanks, will try there
01:03:01 <makalu> http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-ForeignPtr.html why do I get page not found? It's not the first time this has happened.
01:06:01 <dmj`> http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Ptr.html
01:06:10 <dmj`> your URL has a typo in it
01:20:50 <athan> dmwit: Yeah, I probably do. That's why I ignore :)
01:25:02 <makalu> dmj`: I clicked on a link on the main documents page of base
01:25:21 <dmj`> makalu: where
01:26:24 <makalu> http://hackage.haskell.org/package/base search for Foreign.ForeignPtr
01:27:23 <bernalex> is there a way to use flip ($) infix without defining a new function -- or, alternatively, is there such a function defined?
01:27:59 <dmj`> @typ (&)
01:28:00 <lambdabot> a -> (a -> b) -> b
01:28:04 <dmj`> @typ ($)
01:28:05 <lambdabot> (a -> b) -> a -> b
01:28:17 <dmj`> bernalex: I think (&) is from lens
01:28:32 <bernalex> yes, I know lens has it. I should have specified that I meant prelude or similar.
01:30:02 <dmj`> bernalex: not sure
01:30:50 <merijn> There isn't
01:31:04 <merijn> there was a campaign to add (&) from lens, but no success so far, I think
01:31:53 <bernalex> merijn: odd. I'd sure like it. I enjoy |< and |> in f# quite a bit more than $ and certainly flip $.
01:33:16 <dmj`> beralex: there is a package that adds fsharp operators like (|>) to haskell, http://hackage.haskell.org/package/fsharp
01:33:33 <zenkeku> Hey, I have a silly question about type signatures. I'm trying to use the sortBy function but I'm confused by the type signature. Does anyone mind posting a good article or explaining it to me?
01:33:35 <bernalex> dmj`: nice
01:33:49 <dmj`> the entire pkg is like 10 lines. http://hackage.haskell.org/package/fsharp-0.0.4/docs/src/Control-FSharp-Syntax-Operators.html#%3C%7C
01:33:56 <bernalex> zenkeku: the typesig of sortBy? what's confusing you?
01:34:23 <zenkeku> bernalex: I'm pretty new to haskell, so please bear with me. The (a -> a -> Ordering) part.
01:34:36 <bernalex> zenkeku: that means it takes a function that take two as and returns an Ordering
01:35:04 <merijn> :t sortBy
01:35:05 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
01:35:05 <zenkeku> Oh! That's what that means. What is an Ordering?
01:35:18 <bernalex> zenkeku: you know the map function? it takes (a -> b) -> [a] -> [b], which means it takes a function that takes as and returns bs, then it takes a list of as and returns a list of bs.
01:35:18 <opqdonut> @src Ordering
01:35:18 <lambdabot> data Ordering = LT | EQ | GT
01:35:19 <merijn> zenkeku: "data Ordering = LT | EQ | GT"
01:35:28 <zenkeku> Oh! Okay.
01:35:38 <merijn> > compare 3 5
01:35:39 <lambdabot>  LT
01:35:42 <merijn> > compare 5 5
01:35:44 <lambdabot>  EQ
01:35:46 <merijn> > compare 8 5
01:35:47 <lambdabot>  GT
01:35:49 <opqdonut> :t compare
01:35:49 <lambdabot> Ord a => a -> a -> Ordering
01:36:00 <dmj`> > sortBy (\a b -> if a > b then GT else LT) [1,4,3,2,5]
01:36:02 <lambdabot>  [1,2,3,4,5]
01:36:27 <zenkeku> bernalex: Oh, alright. This should help me out a ton, thanks for the help!
01:36:43 <zenkeku> merijn: Thanks for your help, too!
01:36:43 <merijn> zenkeku: Basically, "compare" works for any type that's an instance of Ord, but what if you want to use an ordering than the default? sortBy just lets you pass in a random "compare-like" function that is then used to do the sort
01:37:18 <bernalex> zenkeku: be aware though, that because of a clever trick known as currying, every haskell function takes exactly one argument, and returns exactly one thing. you may not need to know how this works right now, but you might stumble upon it later and get confused, heh.
01:37:54 <zenkeku> bernalex: Yea, I've heard of that before but I didn't know what it meant. I don't fully understand it yet, but I'll keep that in mind.
01:38:01 <bernalex> zenkeku: it's explained here: http://learnyouahaskell.com/higher-order-functions#curried-functions
01:38:24 <bernalex> zenkeku: if you are reading LYAH, don't bother skipping there right now if that's not natural though. it will all fall in place in due time. :-)
01:38:41 <Krikey_Sanchez> if I have a StdGen
01:38:43 <zenkeku> bernalex: I'm currently reading both LYAH and RWH.
01:38:48 <Krikey_Sanchez> can I make a new StdGen from that StdGen
01:38:53 <Krikey_Sanchez> with diferent randomness properties
01:38:56 <Krikey_Sanchez> without using the IO monad?
01:39:05 <bernalex> zenkeku: I much prefered LYAH, but that's not a bad combo. most people read both of those. :-)
01:39:48 <zenkeku> bernalex: Might I ask why you preferred LYAH over RWH?
01:40:21 <dmj`> Krikey_Sanchez: yes
01:40:41 <bernalex> zenkeku: I found that RAW had imprecise language, which might be because I read it after groking most of the basics. furthermore, I don't care about parsing JSON. so the exercises and examples didn't appeal to me.
01:40:56 <awestroke> zenkeku: I think you should read LYAH and then RWH, LYAH is fantastically written
01:41:13 <dmj`> Krikey_Sanchez: look at the "next" function in System.Random
01:41:31 <bernalex> zenkeku: so for me, reading LYAH and doing "real world haskell" by making my own, bigger programs, and reading and contributing to existing programs, was preferable. :-)
01:41:37 <zenkeku> awestroke: I'll take that advice to heart.
01:42:05 <zenkeku> bernalex: That does sound rather preferable. I've noticed that in RWH the exercises require more knowledge of the language than they have provided thus far.
01:42:32 <bernalex> yeh, I guess the common way is to 1. read LYAH. 2. get really confused by the end. 3. read LYAH again. 4. still confused. 5. read RWH. 6. read LYAH. 7. read LYAH. 8. read typeclassopedia. or something. :-P
01:42:45 <zenkeku> Have any of you read or looked into the tutorial book "Write yourself a scheme in 48 hours in haskell"?
01:43:25 <zenkeku> I'm not so confused as of right now, I think I am understanding the basic basics of the language, I just do not have enough knowledge under my belt to be able to work forward at a better pace.
01:44:14 <zenkeku> I am planning on learning scheme, as well. So that book seems to me to be a really interesting prospect.
01:44:15 <dmj`> zenkeku: yes
01:44:30 <zenkeku> dmj`: Yes to what?
01:44:38 <dmj`> I've gone through it
01:45:03 <zenkeku> dmj`: Can you give me a brief review?
01:45:51 <dmj`> zenkeku: a brief review?
01:46:04 <zenkeku> dmj`: Do you recommend it? Was it helpful to you?
01:46:34 <awestroke> > ((*7) <$>) <$> [Just 5, Nothing, Just 3] -- can this be simplified?
01:46:36 <lambdabot>  [Just 35,Nothing,Just 21]
01:46:39 <dmj`> zenkeku: yes it was helpful, but it took most of the weekend
01:46:59 <zenkeku> dmj`: Oh, okay. Thank you.
01:47:04 <awestroke> oh wait map.. but if I want it to stay general to functors
01:47:48 <dibblego> awestroke: in Control.Lens yes
01:48:39 <awestroke> dibblego: how would I do it with lenses? Should I look at traversing lenses?
01:49:00 <dibblego> I just found this explanation https://github.com/ekmett/lens/wiki/Derivation
01:49:11 <dibblego> this is (fmap . fmap)
01:49:23 <dibblego> > (fmap . fmap) (*7) [Just 5, Nothing, Just 3]
01:49:24 <lambdabot>  [Just 35,Nothing,Just 21]
01:54:13 * hackagebot cabal2ebuild 0.0.15.9 - make gentoo's .ebuild file from .cabal file  http://hackage.haskell.org/package/cabal2ebuild-0.0.15.9 (YoshikuniJujo)
02:08:20 <bernalex> is there a wiki entry or something with just a pronounciation guide for common applicatives?
02:09:58 <danilo2> Hello! Does anybody uses OpenGL in Haskell? The newest supported version is 3.2 as far as I see, which is **very** outdated :( There is OpenGLRawgen generator, but it with the newest version of OGL it generates even module names, that cabal cannot parse (starting with number)
02:10:25 <bernalex> danilo2: try #haskell-game
02:11:04 <danilo2> bernalex: Ok, I'll try there, thank you!
02:13:15 <yitz> danilo2: there are also discussions about opengl version on the haskell platform list, since it is included there.
02:36:07 <tero-_> I've been working on a Haskell package to implement "media planning", that is, when to play audio commercials and announcements in retail stores. I was wondering whether if it is too specific to post to hackage... any thoughts?
02:36:46 <merijn> tero-_: I take the "who cares?" approach to putting stuff on hackage, if people wanna use it, great. If not, then fine
02:37:04 <merijn> tero-_: However, if you package is rather specific, try and avoid claiming "valuable" parts of the namespace
02:37:28 <merijn> (i.e. a generic and common package name)
02:40:08 <tero-_> the package translates somewhat high-level definitions of what should be played, e.g. play this commercial 10 times per hour between 9:00-13:00, or play closing announcement exactly at 20:59:00, to a list of accurately scheduled objects using glpk-hs
02:42:41 <tero-_> merijn: okay, so I'll put it but with a less "valuable" name :)
02:43:16 <merijn> tero-_: For comparison I put some stuff up that I just wrote for myself and today someone send me a patch for it, unfortunately it's a patch riddled with linuxisms, but it's a start :p
02:44:03 <tero-_> merijn: always nice when someone finds your stuff useful
02:46:00 <athan> there aren't monads, functors, applicatives, etc. in polymorphic lambda calculus, are there?
02:46:29 <awestroke> why is threadscope being so difficult? Why doesn't it allocate memory on the heap? How can it run out of memory for even trivial eventlogs?
02:46:57 <merijn> athan: Define "are there"
02:47:15 <merijn> athan: Keep in mind haskell  monads are basically syntactic sugar + typeclasses
02:47:42 <merijn> athan: And most (all?)  typeclass uses can be rewritten to explicit function passing
02:48:02 <merijn> athan: See for example this blog post: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
02:48:30 <athan> ah! Okay, great!
02:48:31 <merijn> athan: So you could easily implement your own monads/functors/applicatives in any polymorphic LC that has higher-order types
02:48:41 <athan> hmmm
02:48:42 <athan> okay
02:48:46 <athan> see that's the thing
02:48:52 <athan> what if there's no qualified types
02:48:58 <athan> in the PLC
02:48:59 <athan> ?
02:49:08 <athan> then I feel like everything would be polymorphic
02:49:09 <merijn> That goes beyond my LC expertise :)
02:49:18 <athan> I think that they all reduce!
02:49:24 <athan> to simple application!
02:49:41 <athan> :)
02:54:19 * hackagebot HGamer3D-CEGUI-Binding 0.3.1 - A Game Engine for the Haskell Programmer - CEGUI Bindings  http://hackage.haskell.org/package/HGamer3D-CEGUI-Binding-0.3.1 (PeterAlthainz)
02:54:21 * hackagebot HGamer3D-Enet-Binding 0.3.2 - Enet Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Enet-Binding-0.3.2 (PeterAlthainz)
02:54:23 * hackagebot HGamer3D-Ogre-Binding 0.3.2 - Ogre Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.3.2 (PeterAlthainz)
02:54:25 * hackagebot HGamer3D-SDL2-Binding 0.3.2 - SDL2 Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-SDL2-Binding-0.3.2 (PeterAlthainz)
02:54:27 * hackagebot HGamer3D-SFML-Binding 0.3.2 - SFML Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-SFML-Binding-0.3.2 (PeterAlthainz)
03:04:20 * hackagebot marmalade-upload 0.4 - Upload packages to Marmalade  http://hackage.haskell.org/package/marmalade-upload-0.4 (lunaryorn)
03:07:07 <tero-_> will anyone be sorry if I claim Data.FuzzyTimings?
03:07:30 <awestroke> tero-: a very general name for a not very general package
03:08:02 <Hafydd> As long as you don't touch Data.FuzzyTimes
03:08:03 <awestroke> perhaps you could break out the general functionality into a package and use it to implement your project-specific functionality
03:09:12 <tero-> okay, I put the package at https://github.com/tlaitinen/fuzzy-timings-scheduler/tree/master/src
03:09:42 <tero-> there are ways to attach definitions to "slices" of absolute time and weekly recurring time
03:10:51 <tero-> what would be a more appropriate name for the package?
03:14:22 * hackagebot hakyll 4.5.0.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.5.0.1 (JasperVanDerJeugt)
03:14:42 <unfoobar> hey is there a way to have cabal specify the hackage mirror it fetches from
03:14:48 <unfoobar> ?
03:17:39 <unfoobar> a list of those hackage mirror IP addresses would be useful too...
03:18:02 <unfoobar> if anyone knows ..
03:19:22 * hackagebot tasty-program 1.0.1 - Use tasty framework to test whether a program executes correctly  http://hackage.haskell.org/package/tasty-program-1.0.1 (JanStolarek)
03:21:32 <bergmark> unfoobar: replace the remote-repo in your ~/.cabal/config, or add several ones
03:22:08 <bergmark> unfoobar: the only mirror i know of is hdiff.luite.com:http://hdiff.luite.com/packages/archive
03:25:51 <athan> Has anyone here read Mark P. Jones' "A Theory of Qualified Types"?
03:33:05 <srhb> There used to be a getL in Control.Lens -- where has it gone?
03:38:10 <quicksilver> srhb: it's ^. with args reversed isn't it?
03:38:45 <quicksilver> so "getL foo" is now written (^.foo) if you actually want the function as a function.
03:38:56 <unfoobar> thanks bergmark, that worked, but unfortunately i can't run a cabal update with that mirror due to a "truncated tar archive". are there ANY other mirrors out there?
03:43:11 <bergmark> unfoobar: like i said, that's the only one i know of
03:43:32 <luite> oh hmm, i'll chck
03:43:46 <luite> sometimes it goes wrong
03:46:30 <merijn> tero-: Personally, I'm more and more convinced that using Control.X and Data.X is a mistake, I would just use "FuzzyTimings" as module name
03:49:25 * hackagebot HGamer3D-SDL2-Binding 0.3.3 - SDL2 Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-SDL2-Binding-0.3.3 (PeterAlthainz)
03:51:20 <makalu> If I create a container, 'lookup' usually returns 'Maybe a'. If I have a function that uses error when the key/index is not there, what should the name be? Usually there's just the operator '!'
03:51:39 <merijn> makalu: Well, why not the ! operator?
03:51:53 <merijn> Also, you're a terrible person for not returning Maybe if it can fail >.<
03:53:12 <makalu> merijn: but if I want to get multiple elements then Maybe is inconvenient. It's an IO function, so I can't use the Maybe monad either. I'm not sure I want MaybeT
03:53:29 <k00mi> makalu: how about unsafeLookup?
03:53:38 <CindyLinz> Is there a monad version of 'maybe'? That is.. maybeM :: m b -> (a -> m b) -> Maybe a -> m b   instead of maybe :: b -> (a -> b) -> Maybe a -> b
03:54:37 <dagle> Hmmm. Haskell gtk have no support for gtk overlay?
03:55:16 <mr-> CindyLinz: but.. that is maybe for b specialized to m b
03:55:21 <makalu> k00mi: that's so long :)
03:57:00 <CindyLinz> mr-: oh! thanks
03:57:13 <k00mi> makalu: because you need to be punished for using an unsafe function!
03:57:20 <makalu> I guess I'll go with '!' then. I just don't like using 'M.!'
03:57:59 <mr-> CindyLinz: i.e. stuff like maybe getLine (const $ return "foo") (Just 4) will just work
03:59:14 <athan> can you uncurry a monad transformer?
03:59:36 <CindyLinz> mr-: yes, I have it done :D
03:59:39 <unfoobar> hey luite, is that your hackage mirror? any idea what's up with the truncated 00-index.tar?
04:01:11 <athan> like
04:01:43 <athan> m0 ( m1 ( m2 ( a ) ) ) = m0 a -> m1 a -> m2 a
04:01:54 <athan> through pattern matching?
04:02:13 <athan> er, wait...
04:02:14 <athan> hmm
04:07:03 <athan> > data Unform m1 m2 m3 m4 a = m1 ( m2 ( m3 ( m4 a ) ) )
04:07:04 <lambdabot>  <hint>:1:1: parse error on input `data'
04:07:18 <hhris> > map (+1) [1,2,3]
04:07:19 <lambdabot>  [2,3,4]
04:07:52 <athan> hmmm
04:08:00 <athan> @src MonadT
04:08:01 <lambdabot> Source not found. Sorry.
04:08:05 <athan> @src MonadTransformer
04:08:05 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
04:08:13 <athan> @hoogle MonadT
04:08:13 <lambdabot> Control.Monad.Trans.Class class MonadTrans t
04:08:14 <lambdabot> package monadtransform
04:08:14 <lambdabot> package STMonadTrans
04:08:26 <athan> @src MonadTrans
04:08:27 <lambdabot> Source not found.
04:08:38 <athan> @src Control.Monad.Trans.Class.MonadTrans
04:08:38 <lambdabot> Source not found. That's something I cannot allow to happen.
04:08:47 <athan> @src monadTransform
04:08:47 <lambdabot> Source not found. Just try something else.
04:08:54 <athan> @src monadtransform
04:08:54 <lambdabot> Source not found. Wrong!  You cheating scum!
04:08:58 <athan> wow
04:09:14 <dibblego> class MonadTrans t where lift :: Monad m => m a -> t m a
04:09:28 <quchen> Lambdabot's static (!) @src database: https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
04:10:04 <athan> Thank you :)
04:10:10 <yorick> noob here, looking for [m a] -> (a -> m a) -> [m a]
04:10:26 <athan> might be
04:10:37 <yorick> like map >>= or something?
04:10:40 <kstt> hi
04:10:48 <athan> [m a] -> (a -> b) -> [m b]
04:11:02 <dibblego> @type \x f -> map (>>= f) x
04:11:03 <lambdabot> Monad m => [m a] -> (a -> m b) -> [m b]
04:11:14 <athan> :t >=>
04:11:14 <lambdabot> parse error on input `>=>'
04:11:22 <athan> :t (>=>)
04:11:22 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:11:27 <athan> ahh
04:11:41 <yorick> dibblego: yes! but does that really need a lambda?
04:11:47 <athan> transitive
04:12:05 <dibblego> @type map . (>>=)
04:12:06 <lambdabot> Monad m => m a -> [a -> m b] -> [m b]
04:12:17 <dibblego> @type \f -> map (>>= f)
04:12:18 <lambdabot> Monad m => (a -> m b) -> [m a] -> [m b]
04:12:37 <kstt> I just noticed that "i <- return (i+1)" won't loop while "let i = i + 1" will loop. While I understand technically why, I have been caught by this one, and it took quiet some time to understand what was the cause of the program stalling.
04:13:06 <quchen> kstt: let is "recursive let", known as letrec in other languages.
04:13:18 <athan> dibbelgo: Wat
04:13:23 <quchen> That's often nice to have mutually recursive definitions in let,
04:13:24 <athan> dibbelgo: That's too cool for words
04:13:31 <quchen> > let xs = 1 : xs in xs
04:13:32 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:14:08 <athan> was that a beta reduction?
04:14:18 <dibblego> @pl \f -> map (>>= f)
04:14:18 <lambdabot> map . (=<<)
04:14:28 * hackagebot make-package 1.1.0 - Make a cabalized package  http://hackage.haskell.org/package/make-package-1.1.0 (PhilippBalzarek)
04:14:28 <quchen> kstt: You can use recursive monadic bindings using recursive do-notation though, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#recursive-do-notation
04:14:33 <athan> dibbelgo: Beta reduction?
04:14:48 <quchen> kstt: That requires additional structure (MonadFix instance) for the Monad though.
04:15:28 <yorick> @type map . flip (>>=)
04:15:29 <lambdabot> Monad m => (a -> m b) -> [m a] -> [m b]
04:18:04 <dagle> > replicate 4 "ruby" ++ replicate 3 "Do you" ++ ["Know what you're doing, doing, to me"] ++ replicate 4 "ruby"
04:18:06 <lambdabot>  ["ruby","ruby","ruby","ruby","Do you","Do you","Do you","Know what you're do...
04:19:02 <dagle> Sing along with lambdabot
04:19:09 <kstt> quchen: indeed, let is recursive and this is useful. But in this case, I have been confused by the fact that it was a 'let' in a 'do' notation (always a bit ugly in my opinion), after some "i <- return (i+1)" (well, not exactly that of course, but canonicaly similar).
04:19:29 * hackagebot geojson 1.0.0 - A thin GeoJSON Layer above the json library  http://hackage.haskell.org/package/geojson-1.0.0 (domdere)
04:20:07 <kstt> quchen: maybe, because the "i" was in scope before the "let i = i + 1", I could have expected a warning for smelly usage.
04:20:26 <quchen> kstt: Compile with -Wall and you get shadowing warnings.
04:21:24 <kstt> oh, I was sure I had -Wall in the cabal file, but indeed it seems to be missing.
04:22:18 <kstt> GHC should emit a warning when -Wall is missing ;)
04:22:41 <moofy> Hello
04:22:46 <yorick> -Wno-wall :D
04:23:03 <quchen> > do { let {i = 1}; let {i = 2}; return i } :: [Int]  -- Look mom, mutability in Haskell
04:23:04 <lambdabot>  [2]
04:23:06 <quchen> ;-)
04:25:44 <athan> is state induced?
04:25:47 <athan> like
04:25:51 <athan> the "monad"?
04:26:04 <athan> er the instance
04:26:05 <dibblego> you joke, yet this has been argued
04:26:07 <athan> is that coerced?
04:26:35 <quchen> Huh?
04:26:43 <quchen> athan: You mean my example? It just abuses shadowing
04:27:06 <athan> did ghc make the underlying monad in that statement a State monad?
04:27:16 <quchen> No.
04:27:19 <dagle> No, it has nothing to do with states
04:27:20 <athan> shadowing?
04:27:23 <dagle> change on i to j
04:27:23 <athan> hmm
04:27:46 <athan> huh
04:27:49 <dv-> > let 1 + 1 = 3 in 1 + 1
04:27:50 <lambdabot>  3
04:27:51 <athan> that's interesting...
04:27:58 <athan> wat
04:28:03 <athan> for let statements?
04:28:09 <quchen> > let i = 1 in (let i = 2 in i) -- athan: same thing
04:28:10 <lambdabot>  2
04:28:49 <athan> do those create lambdas?
04:28:56 <dagle> ghc have flags to give warnings about these stuff
04:28:59 <athan> internally?
04:29:07 <athan> hmmmmmmmmmmmm
04:29:20 <quchen> "let i = X ... in expr" replaces all free occurrences of i in expr with X. "let i = 2 in i" does not have any free occurrences of i.
04:29:30 * hackagebot geojson 1.0.1 - A thin GeoJSON Layer above the aeson library  http://hackage.haskell.org/package/geojson-1.0.1 (domdere)
04:29:31 <dv-> i think -Wall will warn you
04:29:32 <athan> yet still, 1 /= 2
04:29:51 <quchen> Of course. Because 1+2 would be 4.
04:29:53 <athan> or would there just be two arrows from i to 1 and 2?
04:29:53 <merijn> > let 1 /= 2 = True in 1 /= 2 -- are you sure?
04:29:55 <lambdabot>  True
04:30:41 <athan> lol
04:31:16 <raichoo> > let _+_ = "foo" in 1 + 2
04:31:17 <lambdabot>  "foo"
04:31:26 <athan> what
04:31:34 <raichoo> :P scnr ^^
04:31:47 <athan> those are lambdas, right?
04:31:54 <athan> then..?
04:31:54 <quchen> No.
04:32:01 <athan> :(_)
04:32:42 <shouya> dv-: it's amazing.
04:32:43 <quchen> I don't know what you meant, but there are no lambdas anywhere above.
04:32:56 <int-e> athan: _ is a pattern matching anything, so let _+_ = "foo" defines an infix operator.
04:33:09 <athan> OH!
04:33:10 <athan> ok
04:33:25 <athan> hmm
04:33:34 <shouya> dv-: but when i evaluate additions with other arguments it prompt an error.
04:33:41 <athan> like a co-quantifier?
04:33:42 <athan> lol
04:33:45 <shouya> > let 1+1=3 in 1+1+2
04:33:46 <lambdabot>  *Exception: <interactive>:3:5-9: Non-exhaustive patterns in function +
04:34:09 <shouya> dv-: so i guess it's a rewritten (+) function right?
04:34:28 <dv-> yes, you're shadowing the (+) definition
04:34:40 <tero-> merijn: okay, I'll use "FuzzyTimings". thanks
04:34:41 <dagle> let also lets you do stuff like: let fix f = let x = fix x in x
04:35:04 <shouya> dv-: interesting XD
04:35:39 <shouya> oh btw, is there any practical uses for 'fix' function?
04:35:46 <shouya> @src fix
04:35:47 <lambdabot> fix f = let x = f x in x
04:36:03 <dagle> oops, I had a typo.
04:36:05 <dv-> it allows you to define anonymous recursive functions
04:36:14 <athan> head [1, fix 1]
04:36:18 <athan> > head [1, fix 1]
04:36:20 <lambdabot>  No instance for (GHC.Show.Show a0)
04:36:20 <lambdabot>    arising from a use of `M389121103590552561128971.show_M3891211035905525611...
04:36:20 <lambdabot>  The type variable `a0' is ambiguous
04:36:20 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
04:36:20 <lambdabot>  Note: there are several potential instances:
04:36:39 <shouya> hum?
04:36:40 <dv-> > fix (\f n -> if n == 1 then 1 else n* f (n - 1)) 10
04:36:42 <lambdabot>  3628800
04:37:02 <shouya> dv-: cool!
04:37:18 <shouya> dv-: some like a y combinator?
04:37:30 <int-e> shouya: exactly
04:37:31 <athan> WOAH!
04:37:42 <dagle> fix is a named y-comibantor?
04:37:53 <dagle> spelling etc
04:37:57 <int-e> it's a fixed point combinator
04:38:09 <int-e> (Y is the name of a specific one that does not correspond to fix)
04:38:14 <athan> and because it's lazilly evaluated
04:38:26 <athan> it's partial application resolves to a result
04:38:34 <athan> even though it can create infinite arity
04:38:37 <athan> ?
04:38:53 <athan> erm...
04:39:09 <athan> oh wait no, I'm stupid. sorry
04:39:15 <athan> this is like a normal function
04:39:24 <athan> the lambdas threw me off
04:39:45 <athan> it's just a higher order function that calls itself
04:40:20 <srhb> Is this not possible? foo :: (Int -> Int) -> Update AcidStore (); foo f = lensbar %= f -- I don't understand why (Int -> Int) needs to be serializable for acid-state to generate the Update event
04:40:29 <athan> through the fix higher order function
04:40:36 <dagle> fix f = f (fix f) , is often easier to reason about.
04:40:42 <athan> which in turn calls it's parameter infinitely
04:40:44 <dagle> But it's not good code.
04:40:54 <athan> exactly
04:41:08 <athan> does good code give you insight to asymptotics?>
04:41:19 <athan> @src fix
04:41:19 <lambdabot> fix f = let x = f x in x
04:41:37 <athan> so in the let binding
04:41:44 <athan> x = f x in x
04:41:48 <athan> the outer two terms
04:41:57 <athan> are ingressing
04:42:05 <athan> from x => f x
04:42:09 <athan> only on demand
04:42:20 <dagle> It creates chunks of computation so you don't blow the stack.
04:42:22 <athan> does f get demanded as well
04:42:45 <athan> and when it itself demands _it's parameter_, does the x in `f x` get demanded as well
04:43:34 <dagle> If you mean what I think you mean it does so lazy.
04:44:35 <dagle> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib
04:44:36 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
04:44:39 <athan> too lazy?
04:45:26 <athan> wow, what?
04:45:29 <athan> how?
04:45:48 <athan> how are each of the fib terms related?
04:46:04 <dagle> To calculate fib, it needs to calculate fib
04:46:11 <athan> oh wait, yeah
04:46:13 <athan> the types match
04:46:18 <athan> lol
04:46:27 <dagle> So it feeds the the old values to caluculate new ones.
04:46:59 <athan> yeah!
04:47:03 <athan> exactly what I meant
04:47:06 <athan> it does so lazy
04:47:10 <athan> lazilly
04:48:26 <Redz> laz
04:48:35 <merijn> makalu: If you want to return multiple elements you could just return a list, that lets you return an empty list for no result, instead of error
04:48:38 <merijn> makalu: Much nicer
04:48:54 <aristid> hmm it would be nice if getLazyByteStringNul instead took a parameter for the separator char
04:48:54 <merijn> makalu: I would just make it "IO [a]"
04:48:57 <athan> > data Foox a = ! Foox a ( Foox a )
04:48:58 <lambdabot>  <hint>:1:1: parse error on input `data'
04:49:04 <athan> > data Foox a = !Foox a ( Foox a )
04:49:04 <lambdabot>  <hint>:1:1: parse error on input `data'
04:49:10 <athan> shit
04:49:21 <athan> @src Free
04:49:21 <lambdabot> Source not found. Maybe you made a typo?
04:49:30 <athan> @src Control.Monad.Free
04:49:30 <lambdabot> Source not found. Maybe you made a typo?
04:50:02 <athan> @hoogle Free
04:50:02 <lambdabot> package FreeTypeGL
04:50:02 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
04:50:02 <lambdabot> package free
04:50:14 <athan> @hoogle MonaxFix
04:50:15 <lambdabot> No results found
04:50:18 <athan> @hoogle MonaxFree
04:50:18 <lambdabot> No results found
04:50:23 <athan> @hoogle FreeMonad
04:50:23 <lambdabot> No results found
04:50:27 <athan> crud
04:53:53 <bahamas> where can I find the Writer monad? LYAH imports it from Control.Monad.Writer, but I get an error about Writer constructor not in data scope
04:54:04 <bahamas> s/in data/in /
04:55:09 <quicksilver> bahamas: well indeed, Writer isn't a constructor
04:55:18 <quicksilver> it is the name of a type
04:55:58 <quicksilver> it seems lyah was written against an old version which exposed a constructor which no longer exists :(
04:56:13 <k00mi> bahamas: use writer not Writer
04:57:15 <bahamas> k00mi: thanks
04:58:26 <tdammers> why would one use the constructor anyway?
04:59:59 <bahamas> tdammers: that's what LYAH uses. why they do it, I don't know
05:01:44 <tdammers> I assumed that people normally constructed writers from existing actions, and by lifting stuff
05:01:49 <tdammers> but never directly
05:02:01 <tdammers> in fact, I'd consider that an implementation detail that should remain hidden
05:03:10 <Wilcov> ctrl-Kctrl-Kctrl-J
05:03:42 <bahamas> tdammers: well, your assumptions are backed by the current implementation at least
05:05:15 <akegalj> does anyone knows will ghc natively target ARM in near future? Are there any plans? I know it can be cross-compiled, but as i can google around, this approach has problems. Doing haskell on embeded system would be great :)
05:08:51 <merijn> akegalj: What do you mean by "natively targeting ARM"?
05:09:59 <dagle> Without patches or additional tools etc?
05:10:09 <dagle> Or dev versions.
05:10:55 <merijn> That's more of a "when will ARM become a tier 1 platform" question and then answer is "when sufficient people test it and help improve it"
05:11:17 <akegalj> merijn: yes thats what i ment
05:13:14 <merijn> The problem is that many of the people working on GHC are already swamped, so improving support on ARM is not a high priority. The best ways to change that are 1) pay someone to work on ARM support or 2) work on ARM support yourself
05:13:42 <merijn> If you don't have the money or time for those you can help by 3) beta testing and writing good bug reports/helping others devs test fixes
05:14:50 <Darwin226> Hey, is there a way to make a Map out of a function? I can do map f [0..] to get an infinite list that I can use as a memoization of f, but indexing a list is O(n). Is there a way to do the same thing but with an infinite Map/HashMap instead?
05:16:23 <akegalj> merijn: yes, that is the reason i asked. I am realy interested in it and trying to hack around arm + ghc but as a newbie hacker will try with 3 first.
05:16:24 <quchen> Darwin226: You cannot have infinite Maps.
05:16:42 <akegalj> merijn: anyways thanks
05:16:57 <quchen> Darwin226: Map is strict in its spine, so the shape of the data is always known.
05:17:20 <quchen> Darwin226: If you want to memoize functions though, there are libraries to help you with that. data-memocombinator comes to mind.
05:17:31 <quchen> http://hackage.haskell.org/package/data-memocombinators
05:17:40 <Darwin226> quchen: I'd like to try and implement it myself.
05:18:20 <merijn> akegalj: You can hang around in #ghc and jump on anything ARM related in the discussion
05:18:24 <Eduard_Munteanu> Darwin226: do you need to lookup by some notion of key?
05:18:47 <Eduard_Munteanu> I'm not sure you're dropping lists for the right reason.
05:18:58 <Darwin226> quchen: Making a generic function that turns any function into a memoized version would be trivial in JS for example. I'm sure there's a relatively simple way to do it in haskell
05:19:44 <akegalj> merijn: thnx, will do it
05:20:08 <Eduard_Munteanu> Darwin226: do you simply mean to cache the results?
05:20:25 <Darwin226> Eduard_Munteanu: Well, this isn't really something that I want to do out of precticallity. Just to see if I can.
05:20:40 <Darwin226> Yeah, I want to cache the results. Didn't realize there was a difference
05:21:11 <Eduard_Munteanu> Darwin226: you can use State for that
05:21:14 <awestroke> Darwin226: the arity of the functions can't be generalized on
05:21:22 <jophish> It's nice to see C++ becoming more and more like Haskell http://www.stroustrup.com/whitespace98.pdf
05:22:08 <awestroke> jophish: the "taking c and bolting on everything he's ever heard of" seems like a good explanation for how c++ was made
05:22:35 <Eduard_Munteanu> Darwin: given f :: A -> B, you could work with cachedF :: A -> State (Map A B) B.
05:22:47 <Darwin226> Eduard_Munteanu: Monads man... How do they work..
05:23:13 <lieven_> he was only joking then. since C++ has overloaded "" to implement dimensioned constants
05:24:04 <Eduard_Munteanu> Darwin226: if you're not comfortable with monads, you can reinvent State by writing a cachedF :: Map A B -> A -> (Map A B, B)
05:24:05 <Darwin226> awestroke: I don't need that level of generalization. In fact, I'd be perfectly fine if it would just operate on single argument functions that took Ints as arguments.
05:24:08 <merijn> lieven_: To be fair, GHC did that too :p
05:24:38 <Darwin226> Eduard_Munteanu: Yeah. I get that. Pass along a new map with updated cache.
05:25:29 <Darwin226> Eduard_Munteanu: The thing is, I feel like that's a huge overkill. I'm not trying to change existing values.
05:25:34 <lieven_> merijn: it will still take hard work to make Haskell as obfuscated as C++
05:25:56 <awestroke> Darwin226: Data.Map is much more performant than a lookup list
05:26:00 <Darwin226> Eduard_Munteanu: If I do map f [0..], I don't need to pass around a new list with extra parameters cached
05:26:01 <Hodapp> ugggh, C++.
05:26:37 <awestroke> Darwin226: you could
05:26:38 <Darwin226> Eduard_Munteanu: Because the list "knows" how to generate data based on the indices.
05:27:06 <awestroke> Darwin226: you could make a function that takes a function and a list of arguments and returns a function with all those arguments memoized
05:27:51 <Darwin226> awestroke: That is a possible solution. In fact, I can already do that with the existing Data.Map functions
05:28:35 <Darwin226> awestroke: But there are still obvious drawbacks. If my function takes numbers from 0-3 000 000 000, I don't want to cache all of them.
05:29:13 <Darwin226> Basically, I want to cache only the values that get used, but in a way that I don't have to do it explicitly by passing an updated map around
05:30:26 <Darwin226> I realize that it might not be feasible, but it really seemed like a common thing to do and as I said, something that would be pretty trivial in an imperative language.
05:30:47 <awestroke> sounds like a monad )
05:31:53 <Darwin226> I don't know if you can tell where I'm comming from. map f [0..] is NEARLY perfect and it's a single line of code. I just need a BIT more. I can't believe that I need to do all these things just so my lookups aren't O(n)
05:32:50 <Eduard_Munteanu> Darwin226: memoization usually refers to *implicit* sharing of results
05:33:38 <Eduard_Munteanu> Darwin226: I'm not sure JS does that, what does the code there do?
05:33:51 <Eduard_Munteanu> s/JS/the JS version/
05:34:13 <Darwin226> I'll whip up an example.
05:34:54 <awestroke> Eduard_Munteanu: http://jsperf.com/jsfibmemo example of memoized fibonacci
05:35:46 <Eduard_Munteanu> I was rather questioning the feasability of a general memoization combinator / procedure.
05:36:30 <awestroke> Eduard_Munteanu: in js?
05:36:51 <Eduard_Munteanu> Yeah, as opposed to using some explicit state to cache results.
05:37:27 <Darwin226> http://pastebin.com/ejGcrWZe
05:37:38 <Darwin226> http://jsfiddle.net/u3St3/
05:37:40 <Darwin226> Here's a fiddle
05:37:51 <Eduard_Munteanu> awestroke: that doesn't look like memoization to me
05:38:15 <Eduard_Munteanu> Oh wait.
05:38:39 <Eduard_Munteanu> Well it is after all.
05:40:36 <Eduard_Munteanu> Darwin226: it's the explicit state tracking there that you have to do differently in Haskell.
05:41:58 <Darwin226> It's kind of a shame that I can't just have a map that takes a function that takes a key and generates a value and then have that map be inifinte by lazily generating values as needed
05:42:51 <yesthisisuser> hmm. ok getEnv is throwing an exception if the variable doesn't exist. There is no equivalent action that returns a Maybe value instead?
05:43:05 <awestroke> Darwin226: you can, you just have to keep the newest version of the map at hand
05:43:23 <supki> yesthisisuser: lookupEnv
05:43:46 <Darwin226> Would you mind writing a short example of how the usage would look like? Maybe something similar to the JS example
05:44:01 <awestroke> Darwin226: sure
05:44:03 <yesthisisuser> supki: thanks.
05:44:16 <yesthisisuser> i was looking at an old version of the docs.. as usual :)
05:45:50 <quchen> Don't use external search engines to look for Haskell docs, ever.
05:46:09 <ClaudiusMaximus> Darwin226: http://hackage.haskell.org/package/data-memocombinators-0.5.1/docs/Data-MemoCombinators.html if you didn't check it already
05:46:12 <quchen> You can use Google to find what package something might be in, but it usually puts you on a very much outdated version.
05:47:09 <Darwin226> ClaudiusMaximus: I actually just saw that. Very nifty to know that someone already did it. I'd still like to do it myself.
05:47:11 <yesthisisuser> quchen: yes.. i guess the best thing is to cabal install with docs
05:48:11 <yesthisisuser> its a bad habit to rely too much on arbitrary googling in general
05:48:51 <Eduard_Munteanu> yesthisisuser: why?
05:49:18 <Eduard_Munteanu> Google is probably the best problem solving tool ever.
05:49:47 <Eduard_Munteanu> (sure, credit also goes to actual content, but it's still the single most important factor)
05:49:55 <yesthisisuser> yes it is not a bad habit to search for information.. but i mean if i find myself constantly looking up stuff in the docs
05:50:07 <yesthisisuser> it indicates that i should have them installed locally
05:50:20 <Eduard_Munteanu> Oh, I see.
05:51:25 <srhb> I'm going to pose my previous question again in case some acid-state buffs have shown up.
05:51:29 <srhb> Is this not possible? foo :: (Int -> Int) -> Update AcidStore (); foo f = lensbar %= f -- I don't understand why (Int -> Int) needs to be serializable for acid-state to generate the Update event
05:54:03 <quicksilver> I agree that that would not require Int -> Int to be serialisable, srhb
05:54:13 <quicksilver> but I can't actually help you.
05:54:33 <quicksilver> pasting actual source and an actual error might help, although not necessarily help me since I'm no acid-state expert.
05:54:39 * hackagebot haroonga 0.1.1.0 - Low level bindings for Groonga.  http://hackage.haskell.org/package/haroonga-0.1.1.0 (cosmo0920)
05:54:50 <srhb> It seems a little weird that there's no analog to modify since the entire idea is that Update is similar to State
05:54:57 <srhb> quicksilver: Right
05:56:36 <merijn> srhb: I can guess why it requires (Int -> Int) to be serialisable
05:56:44 <srhb> merijn: Oh?
05:57:02 <merijn> Note, I'm not an expert (or even knowledgeable about) acid-state, but it makes sense to me
05:58:22 <peteretep> Is there a good reason why -> can't implement Show?
05:58:30 <merijn> srhb: So, to keep up speed acid-state uses an event log were it serialises data to, so that puts a serialisable requirement that goes into the log. Now, afaik the logic is that since you're just composing an update from the function it shoudn't need to serialise it?
05:58:39 <merijn> peteretep: Nope, and in fact lambdabot has one
05:58:44 <merijn> > (+1) :: Int -> Int
05:58:46 <lambdabot>  <Int -> Int>
05:58:59 <merijn> peteretep: It doesn't work for polymorphic functions, though
05:59:17 <peteretep> > show (*2)
05:59:18 <lambdabot>  "<Integer -> Integer>"
05:59:24 <peteretep> hrm
05:59:31 <peteretep> I was hoping to get out "(*2)" :-)
05:59:40 * hackagebot fuzzy-timings 0.0.1 - Translates high-level definitions of "fuzzily" scheduled objects (e.g. play this commercial 10 times per hour between 9:00-13:00) to a list of accurately scheduled objects using glpk-hs.  http://hackage.haskell.org/package/fuzzy-timings-0.0.1 (TeroLaitinen)
05:59:46 <merijn> srhb: As far as I can tell (I'm not good at lens) you're taking an Int out a structure applying the "Int -> Int" to it and writing the result back, right?
05:59:54 <srhb> merijn: Right!
06:01:08 <merijn> srhb: So the problem is, what if "Int -> Int" is really slow? Now doing the update atomically requires, reading the value, blocking any other updates and then writing out the result
06:01:29 <srhb> I see, yes. So it's effectively a tradeoff due to atomicity
06:01:33 <merijn> Yes
06:01:41 <merijn> At least, that's my blind guess
06:02:00 <merijn> If forces you to do expensive computation outside the atomic transaction
06:02:08 <srhb> You're probably right. I've asked a few other places but I think there are timezone issues. Anyway, no reason to get hung up on it for now. Thank you. :)
06:02:17 <k00mi> peteretep: that's the reason why there is no Show instance for functions, you can't inspect them
06:02:18 <awestroke> Darwin226: darn. that's hard
06:03:54 <peteretep> k00mi: That's not a reason
06:04:06 <merijn> peteretep: Why not?
06:04:32 <merijn> peteretep: Actually
06:04:40 * hackagebot HGamer3D-Wire 0.3.2 - Wire Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Wire-0.3.2 (PeterAlthainz)
06:04:42 * hackagebot HGamer3D-Graphics3D 0.3.2 - 3D Graphics Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Graphics3D-0.3.2 (PeterAlthainz)
06:04:56 <merijn> peteretep: Why not try and implement one yourself and see what the problems that you run into are? It'll be fun and educational at the same time :)
06:05:07 <peteretep> Well it's a circular reason: you can't Show it because you can't inspect it because you can't Show it
06:05:18 <peteretep> merijn: It'd need to be done at the compiler level, perhaps as a source map
06:05:36 <merijn> peteretep: What about higher order functions that don't exist until runtime?
06:05:52 <merijn> peteretep: That means the compiler would have to save and store a string representation of every value at all times
06:06:01 <peteretep> When you say "don't exist until runtime", what does that mean?
06:06:03 <merijn> peteretep: Also, how about functions that internally have non-showable values
06:06:38 <merijn> peteretep: "map (*) someListFromStdIn" <- list of functions, value unknown until runtime
06:06:41 <peteretep> You have the text that defined them, and presumably you also have any captured variables
06:07:10 <quicksilver> peteretep: merijn mislead you badly. There is a very good reason why there isn't a Show instance for (->)
06:07:22 <quicksilver> the reason is that a useful one can't be referentially transparent
06:07:34 * peteretep googles that term
06:09:41 * hackagebot HGamer3D-Wire 0.3.3 - Wire Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Wire-0.3.3 (PeterAlthainz)
06:18:15 <yorick> I made this after reading that wikibook zipper thing https://gist.github.com/yorickvP/bba11994d3c0030e55fc but I'm afraid it's terrible
06:18:43 <yorick> https://dl.dropboxusercontent.com/u/22989236/theseus.gif is what it does
06:20:19 <piezoid> hi
06:20:50 <piezoid> I'm stuck for a while now on a Arrow "puzzle" :
06:21:00 <piezoid> i'm trying to make '(a, Either b c) ~> Either (a, b) (a, c)' in arbitrary category
06:21:11 <piezoid> using only &&&, |||, exl/exr = arr fst/snd and inl/inr = arr Left/Right
06:22:12 <piezoid> for example, 'Either (a, b) (a, c) ~> (a, Either b c)' is much simpler, it's 'exl &&& (exr >>> inl) ||| exl &&& (exr >>> inr)'
06:22:24 <merijn> yorick: That's pretty neat actually :)
06:23:10 <yorick> merijn: well, I only made from about line 50, the rest is really from the zipper tutorial
06:23:18 <piezoid> but for my problem, the closest i get is : '\x -> exr >>> (\b -> inl (exl x,b)) ||| (\c -> inr (exl x,c)) $ x' (in Hask) ...
06:23:57 <edwardk> dcoutts: bad choice of date for that article
06:26:25 <djahandarie> edwardk, wait, that wasn't suppose to be an April Fool's joke?
06:28:05 <quchen> Maybe he should add "NO APRIL FOOLS" to the title or something.
06:28:26 <quchen> I'm surprised GHC 7.8 still wasn't realeased multiple times today.
06:31:28 <tdammers> quchen: maybe in another universe?
06:32:36 <edwardk> djahandarie: i've mostly decided to not post to the internet on april 1st after last year i mentioned that "ekmett workshop" in Japan and nobody believed it happened.
06:38:55 <Earnestly> lol
06:40:27 <srhb> CERN is following in the footsteps of Simon PJ today
06:40:42 <srhb> "From today, all of CERN's official communication channels are switching to exclusive use of the font Comic Sans."
06:42:05 <talin> hello
06:42:44 <talin> are there any nice examples of haskell used in production systems somewhere? does it have a sort of "niche"?
06:44:23 <zomg> At work we ran a haskell-based web service used in an advertising campaign
06:44:36 <zomg> Probably not the obvious niche :) so it can certainly be used for pretty much whatever
06:44:45 * hackagebot uhc-util 0.1.3.0 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.3.0 (AtzeDijkstra)
06:44:55 <makalu> Control.Exception has this in an example 'tryJust (guard . isDoesNotExistError) $ getEnv "HOME"'. What's guard?
06:45:02 <narendraj9> zomg, but unfortunately not many places use it.
06:45:20 <zomg> narendraj9: yeah, I'm the only guy in the dev team at work who knows haskell and I wrote that web service... :D
06:45:25 <srhb> talin: You can find Haskell in just about any niche out there.
06:45:34 <vermeille> We had a little of Haskell at Facebook too
06:45:42 <johannes_> production system as in the AI sense or as in a system in general
06:45:44 <narendraj9> zomg, sad.
06:45:57 <zomg> well it's just how life is at most companies I think
06:46:08 <zomg> unless you specialize in FP related tech you probably don't have a lot of guys who know haskell (or other FP langs)
06:46:14 <narendraj9> zomg, After you have a couple of books, you won't find anything to work on, in Haskell.
06:46:29 <narendraj9> *have read
06:46:45 <narendraj9> That's the impression I have got.
06:46:49 <narendraj9> I am new to Haskell.
06:46:51 <narendraj9> Learning.
06:47:10 <zomg> Yeah it's probably a bit more difficult to find work where you'd get to use Haskell
06:47:22 <zomg> but I think the use in the industry is certainly on the rise
06:47:28 <srhb> No doubt about that.
06:47:38 <narendraj9> I hope things change.
06:47:46 <johannes_> it is used in the financial industry quite a bit
06:47:59 <johannes_> https://www.fpcomplete.com/business/haskell-financial-analysis/
06:48:03 <srhb> http://www.haskell.org/haskellwiki/Haskell_in_industry
06:48:10 <zomg> vermeille: FB tried to recruit me at one point but wanted me to move to some other country which pretty much killed the deal for me :P
06:48:31 <vermeille> zomg: California?
06:48:42 <zomg> Yeah probably, I forgot as it's been a while
06:49:01 <t4nk328> @pl diffs xs ys = length . filter (uncurry (/=)) $ zip xs ys
06:49:01 <lambdabot> diffs = ((length . filter (uncurry (/=))) .) . zip
06:49:04 <vermeille> The campus in California is wonderful, you did a mistake :p
06:49:08 <zomg> haha :)
06:49:13 <narendraj9> What do you guys use Haskell for? Any open source project that you contribute to?
06:49:19 <Clint> yes
06:49:35 <talin> srhb: what about systems programming? or OS development?
06:50:24 <Hodapp> I put my Haskell-learning temporarily on hold while I learn Coq.
06:50:25 <Hodapp> I just idle here.
06:50:29 <vermeille> code fap
06:50:57 <srhb> talin: HalVM is probably the most notable project in that regard, but really, Google will be more helpful with those parameters.
06:50:58 <narendraj9> I have asked this question a couple of times here. and I didn't get enough answers.
06:51:16 <waidmann> using it for project euler just now but haven't begun on anything serious with it yet
06:51:22 <srhb> It's usually spammy an opinionated, which is probably why people don't like to answer it much.
06:51:46 <narendraj9> srhb, I see.
06:52:19 <narendraj9> That probably was the reason.
06:52:26 <srhb> Concrete Haskell questions tend to gain more attention than "do you think Haskell is good for this?"
06:52:40 <narendraj9> But I just wanted to have some options.
06:52:46 <talin> srhb: nice
06:53:42 <narendraj9> I think personal projects are the only thing that people write in Haskell.
06:53:49 <narendraj9> *things
06:53:53 <srhb> narendraj9: That's close to flamebait :P
06:54:19 <narendraj9> srcerer, sorry. :-D
06:54:26 <narendraj9> srhb, sorry..
06:54:29 <srhb> ;)
06:54:30 <narendraj9> :-D
06:55:20 <Hodapp> When your employer is afraid to use anything other than C++, it tends to only be personal projects I can do in Haskell.
06:55:25 <narendraj9> But I am learning Haskell anyway.
06:55:29 <Hodapp> ex-employer.
06:55:34 <narendraj9> Because it's kinda cool.
06:55:34 <Hodapp> ignore subject shift.
06:56:12 <narendraj9> Yeah. Right.
06:56:29 <srhb> I feel a lot of people come to this channel, and other #lang channels to be comforted in their choice of time investment. I think that part is less interesting to most of the other occupants of the channels than the actual #lang-related questions. :)
06:57:03 <narendraj9> srhb, yes. That I have learned through experience. :-)
06:57:48 <narendraj9> But learning haskell is quite challenging in its own right. I takes time. The thing that's troubling me these days is how foldl is written in terms of foldr.
06:57:58 <narendraj9> I am following real world haskell.
06:58:38 <narendraj9> I didn't give it much time though. But is obviously isn't easy to understand.
06:59:01 <narendraj9> And when I put time into learning something, it's rational to expect to have rewards later in life.
06:59:51 <saml> canta, how do you layout power adapters in hackathon?
06:59:58 <saml> layout tables, also
07:00:02 <saml> for optimal experience
07:04:24 <flebron> Is there a particularly interesting reason why foldl's f is not b -> a - > a but a -> b -> b? (I know it's just foldl . flip either way)
07:06:10 <srhb> flebron: You mean a -> b -> a -- right?
07:06:44 <flebron> Err, I meant b -> a -> b. :)
07:06:49 <srhb> :-)
07:07:35 <magicman> I just wrote f name@"stuff" = body name, instead of f "stuff" = body "stuff". Because OverloadedStrings is on, and I didn't feel like adding type annotations.
07:08:05 <srhb> flebron: Perhaps just because it makes you remember that the starting value of the accumular is on the left
07:08:16 <srhb> flebron: (((((z `f` x1) ...
07:08:32 <srhb> flebron: Vs. x1 `f` (x2 ...
07:11:02 <John_NL> zijn er Nederlanders aanwezig ?
07:11:32 <tdammers> John_NL: probably, but I suggest you stick with English anyway
07:12:07 <John_NL> I know but I dont know how to explane my problem
07:14:11 <lrocksmashtime> hi quick question. I'm playing around with persist and all the examples wrap things that occur within the DB with the following code: withPostgresqlPool connStr 10 $ \pool -> do; flip runSqlPersistMPool pool do ...
07:14:40 <lrocksmashtime> I'd like to reuse that and do something more like doStuff do selectList ...
07:15:06 <lrocksmashtime> but seeing as how I am a complete newb I cannot for the life of me figure out the proper syntax for such a thing
07:15:17 <lrocksmashtime> any help would be greatly appreciated
07:17:34 <srhb> lrocksmashtime: Not sure what you mean. Within that last do block you will be able to reuse simpler pieces of persistent code freely. can you give us an example?
07:18:23 <lrocksmashtime> srhb: sure
07:18:27 <tdammers> John_NL: give it a try... worst case, people ask more questions
07:25:13 <lrocksmashtime> srhb: https://gist.github.com/lshemesh/9915052   this gist make any sense?
07:26:01 <merijn> lrocksmashtime: Hard to say, I dunno what the types of any of that is
07:26:17 <lrocksmashtime> merijn: me too!
07:26:46 <lrocksmashtime> I'm getting all my info from this link http://www.yesodweb.com/book/persistent
07:26:55 <quicksilver> lrocksmashtime: yes
07:26:59 <quicksilver> lrocksmashtime: that's fine
07:27:08 <quicksilver> you can abstract like that
07:27:23 <quicksilver> you don't even need the 'do'
07:27:24 <srhb> lrocksmashtime: Just uncomment --stuff
07:27:38 <lrocksmashtime> oh shit let me try that
07:27:38 <quicksilver> withPostgresqlPool connStr 10 $ \pool -> flip runSqlPersistMPool pool stuff
07:27:46 <quicksilver> save yourself two dos
07:27:50 <quicksilver> those dos are expensive.
07:28:06 <srhb> quicksilver: What, they are?
07:28:13 <quicksilver> srhb: sorry, it was a bad joke
07:28:15 <srhb> :|
07:28:21 <srhb> I dislike april 1st.
07:28:27 <quicksilver> I meant to imply they were mined in a highly dangerous 'do' mine
07:28:33 <quicksilver> not that they were computationally expensive
07:28:38 <srhb> Good, thanks. ;)
07:28:41 <quicksilver> I'm afraid I make bad jokes 365 days a year, srhb.
07:28:48 <lrocksmashtime> two == dos
07:29:05 <quicksilver> true, I shoul dhave tried to work that into the joke.
07:29:31 <srhb> lrocksmashtime: Anyway, it seems you have basically solved your own problem with your example. :-)
07:31:06 <lrocksmashtime> thanks for the responses. My only issue now is how to construct stuff
07:32:22 <srhb> lrocksmashtime: That's.. a little vague. :-)
07:33:26 <merijn> quicksilver: He can even ditch the flip when he reverses "pool" and stuff
07:33:28 <lrocksmashtime> srhb: in my gist example  (line 17): doStuff do ... gives me a parse error on input `do'
07:33:34 <merijn> lrocksmashtime: Needs a $
07:33:38 <merijn> "doStuff $"
07:33:44 <merijn> lrocksmashtime: That, or parentheses
07:34:06 <lrocksmashtime> merijn: awesome! almost there
07:34:14 <merijn> Actually, can even optimise more
07:34:40 <merijn> This should work: http://lpaste.net/102106
07:34:41 <quicksilver> merijn: yes, that was ging to be my next point
07:34:50 <merijn> eliminate the flip and remove the lambda
07:34:51 <merijn> eh
07:34:58 <merijn> I forgot to remove the pool argument
07:35:35 <merijn> Fixed: http://lpaste.net/102106
07:35:37 <lrocksmashtime> this is great because that flip really looks terrible
07:36:16 <merijn> I annotated it with a pointfree-er version
07:36:25 <merijn> you can drop the explicit "stuff" too
07:40:31 <lrocksmashtime> now i'm trying to figure out what the types are for the doStuff function. ghci gives me "Couldn't match type `PersistEntityBackend val0' with `SqlBackend'"
07:49:53 * hackagebot skype4hs 0.0.0.0 - Skype Desktop API binding for Haskell  http://hackage.haskell.org/package/skype4hs-0.0.0.0 (emonkak)
07:54:54 * hackagebot gang-of-threads 3.1.0 - Non-deterministic parallelism with bags  http://hackage.haskell.org/package/gang-of-threads-3.1.0 (bholst)
08:23:11 <udevd_> where can i find idiot-resistant guide to parallelization? i just want to make something like (parallelMap function list)
08:24:52 <kiddesr> udevd_: http://goo.gl/vNfNa
08:26:26 <udevd_> thanks :) i'll take a look
08:27:11 <quchen> udevd_: There's also Marlow's book on parallel/concurrent Haskell.
08:27:29 <quchen> More up to date, much more in-depth.
08:27:48 <udevd_> i don't know i need whole book for now, but thanks :)
08:27:59 <udevd_> s/know/think/
08:31:35 <yorick> can I use optparse where I specify an argument multiple times, like --without x --without y?
08:34:03 <yorick> oh, thanks
08:39:59 * hackagebot random-eff 0.1.0.0 - A simple random generator library for extensible-effects  http://hackage.haskell.org/package/random-eff-0.1.0.0 (HiromiIshii)
08:59:41 <edsko> (fundeps) why does https://gist.github.com/edsko/9917100 not type check?
09:01:48 <quicksilver> because fundeps don't work like that.
09:02:08 <quicksilver> fundeps can't be used to construct proofs of equality
09:02:21 <quicksilver> they just simplify constraint generation
09:02:52 <edsko> hmm, they ought to :)
09:04:32 <quicksilver> if they did they'd be something else.
09:04:47 <quicksilver> however, you can do clever things with type families and constraint kinds
09:04:58 <edsko> (a -> b, b -> a) tells me a and b are in 1-1 correspondence
09:05:24 <edsko> so I don't see why this conclusion is invalid
09:06:55 <quicksilver> your conclusion is logically correct, edsko
09:07:09 <edsko> I'd have to use type synonym families, and that's a pain in the ass because they are not injective
09:07:10 <quicksilver> but GHC is not a general purpose theorem prover capable of proving all logically correct theorems
09:07:17 <edsko> I know I can define an inverse and ghc will do the right thing but it's painful
09:07:24 <edsko> quicksilver: haha. it ought to be :)
09:07:29 <quicksilver> it's a compiler :)
09:07:34 <edsko> naaah :)
09:07:36 <merijn> Or use TypeFamilies instead of FunDeps :p
09:07:42 <DR6> What do you actually want to do with fundeps?
09:07:47 <DR6> Just that example?
09:07:48 <quicksilver> with typefemailies you have ~ as an explicit equality constraint
09:07:56 <merijn> Although I only say this because I'm not smart enough to get FunDeps to work for me
09:07:57 <quicksilver> and you can do cleverer things which hopefully merijn has an example of to hand
09:08:09 <quicksilver> because he showed it yesterday I think
09:08:32 <merijn> quicksilver: I show it every day when someone mentions TypeFamilies (including when I do!) :p
09:08:39 <merijn> Because I like it ;)
09:08:40 <edsko> lol :)
09:08:41 <merijn> https://gist.github.com/merijn/6130082
09:08:45 * edsko looks
09:09:13 <merijn> There was also an example I made for someone else that has a Tree with statically checked limited depth: https://gist.github.com/merijn/9530680
09:10:31 <aristid> merijn: haskell really is getting more and more dependently typed, and it seems to start to seem not utterly completely cumbersome
09:10:51 <DR6> not completely
09:12:23 <donri> (but still insanely cumbersome, cf. singletons, syntax for type-level functions etc)
09:12:27 <rschulman> Can anyone suggest to me why "theList <- newList (black `on` white)" is giving me an ambiguous type variable error? (This is in vty-ui if there's anyone around who knows that)
09:13:10 <merijn> rschulman: Paste the code + error on lpaste
09:13:32 <merijn> aristid: GADTs + DataKinds + TypeFamilies <3
09:14:59 <rschulman> merijn: http://lpaste.net/102112
09:17:43 <merijn> rschulman: Basically, newList demands a type with a "Show" constraint, but GHC is unable to infer which show instance to use (hence ambiguous type variable) simple solutions would be to add a type annotation with the right type
09:19:04 <rschulman> merijn: Ok, that much I sort of understood. But (black `on` white) returns an Attr which is what newList wants as its input. Is it the Attr that's ambiguous?
09:19:09 <TallerGhostWalt> What is the difference between Binary and Serialize?
09:19:09 <ocharles> yo aristid - does `aws` support stopping and starting EC2 instances?
09:19:44 <TallerGhostWalt> strictness?
09:21:15 <merijn> rschulman: Impossible to say without knowing the types of black, white and newList
09:22:39 <rschulman> black and white are Color, on: Color -> Color -> Attr and newList: Show b => Attr -> IO (Widget (List a b))
09:23:16 <aristid> ocharles: not yet.
09:23:33 <aristid> ocharles: aws-sdk might
09:24:06 <aristid> ocharles: oh that reminds me there's a couple of pull requests that i procrastinated looking at
09:24:08 <ocharles> aristid: ah yes, that does
09:24:47 <edsko> merijn: if I use type families, can I encode that every value in the codomain of the type family must satisfy some constraints?
09:24:51 <edsko> for instance, must satisfy Eq?
09:28:06 <triliyn> rschulman: it's the output type that's ambiguous, then
09:28:08 <edsko> merijn: I guess I can still use a type class for that
09:28:20 <aristid> ocharles: would obviously prefer support for it in aws, as aws is much cooler than aws-sdk obviously!
09:29:10 <rschulman> triliyn: I can understand that, I think. Its the "b" in the widget list type. Sadly this directly follows the api documentation, so I'm stuck muddling through it. :)
09:29:45 <ocharles> aristid: totes cool
09:30:20 <rschulman> well, thank you merijn and triliyn for the help
09:36:28 <Redz> @hoogle Floating a => Int -> a
09:36:29 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
09:36:29 <lambdabot> Prelude (!!) :: [a] -> Int -> a
09:36:29 <lambdabot> Data.List (!!) :: [a] -> Int -> a
09:37:09 <Redz> narf. every time i forget the function name and its simple not findable with hoogle.
09:37:21 <Redz> ly
09:38:45 <Redz> realToFrac .
09:40:07 * hackagebot http-types 0.8.4 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.8.4 (AristidBreitkreuz)
09:43:56 <yitz> @hoogle (Fractional a, Real b) => b -> a -- Redz
09:43:56 <lambdabot> Parse error:
09:43:57 <lambdabot>   (Fractional a, Real b) => b -> a -- Redz
09:43:57 <lambdabot>                                      ^
09:44:02 <yitz> @hoogle (Fractional a, Real b) => b -> a
09:44:02 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
09:44:03 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:44:03 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
09:45:08 <yitz> Redz: the problem is - there are so many combinations of possible type classes. if hoogle tried to cover all of them, there would be too many results (at least too many for the irc interface)
09:45:32 <yitz> Redz: once you get the typeclasses right, or very close, hoogle finds it.
09:46:17 <Redz> but an optimized search engine should try to find out what people really looking for and not what they search for.
09:46:57 <Hafydd> Arguable.
09:47:37 <yitz> Redz: hoogle isn't google. its strength is understanding the haskell type system and libraries. if you want to make it also like google - i'm sure ndm would be thrilled to accept your patches.
09:49:18 <Redz> give me infinite time and i will do it. ;)
09:49:39 <yitz> Redz: also, i think Hafydd's point is that hoogle is not a central server like google that can accumulate usage pattern data
09:50:05 <yitz> Redz: it's software that you install locally on your computer and then install into it information about haskell libraries.
09:50:09 * hackagebot keyring 0.1.0.0 - Keyring access  http://hackage.haskell.org/package/keyring-0.1.0.0 (lunaryorn)
09:50:46 <yitz> Redz: google did their original search engine in finite time with a small number of people. you can too! :)
09:51:42 <Redz> but there are so many other cool projects to work on.
09:52:18 <Redz> hmm. how about a lambdabot mod where people can save suggestions from failed hoogle searches?
09:54:00 <paulschellin> So I've been experimenting with Data.Typeable and Data.Dynamic, and I'm trying to use them to make a very simple type system, one which I can use along with acid-state to make a typed, transactional database. I'm having trouble finding a way to use fromDynamic without providing the type (from which it deduces how to cast the dynamic value) at compile time. I'm becoming convinced that it's not really possible
09:54:02 <paulschellin> to do in a ~safe way. Does anyone have experience with attempting something similar?
09:55:09 * hackagebot aws 0.8.5 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.8.5 (AristidBreitkreuz)
09:57:20 <zipper> Does Yesod give you scale?
09:59:54 <davean> zipper: what do you even mean by that?
10:01:09 <paulschellin> I have to assume that acid-state must do internally basically what I'm trying to do. It's not obvious to me while looking through their implementation, though.
10:02:11 <zipper> davean: Do sites written in haskell work well with a huge number of users?
10:02:21 <zipper> davean: *yesod
10:02:40 <davean> I'd say that is still terribly poorly defined
10:03:15 <bobfang> who
10:03:20 <davean> Of course, I'm too tired after writing a web site for a "huge nubmer of users" for small values of huge to really dissuss it in detail
10:03:31 <davean> but I think if you're asking that question, it probably doesn't really matter to you
10:04:03 <zipper> davean: Yes it doesn't matter to me but I want to know.
10:04:39 <davean> zipper: well, I can't answer anything about yesod wit high precision,
10:04:59 <zipper> davean: Oh ok :(
10:05:14 <davean> but I will say I just wrote http://xkcd.com/1350/ in around 3 days, and without any optimization we're falling behind at around 1000 human submissions per minute
10:06:13 <[swift]_> where do you log in on Hackage?
10:06:24 <davean> I tihnk you're asking nonsensical questions though
10:06:52 <davean> zipper: if you ask most people with actual experiance with scaling code to larger user bases, they'll generalyl say there is no such thing as an answer to that question
10:07:10 <davean> it is all bout specific requirements and which code paths you use how
10:07:59 <c_wraith|N10> davean: that really needs some hint as to what it is for people on mobile. My browser just loads Monday's comic and puts a big empty space below it.
10:08:17 <davean> c_wraith|N10: did you try to use m.xkcd.com or www.xkcd.com?
10:08:20 <davean> if so, thats the problem
10:08:25 <davean> yah, its an April 1st
10:08:35 <davean> we didn't exactly clean up all the rought edges
10:08:50 <S11001001> c_wraith|N10: also https seems to go to the last comic
10:08:55 <davean> You're probably hitting "CORS is boring"
10:09:02 <c_wraith|N10> Oh, it's working better now. That's pretty cool.
10:09:03 <davean> S11001001: we've never supported HTTPS
10:09:49 <c_wraith|N10> Maybe it was just a caching issue. I've noticed that kid caches pretty aggressively before.
10:09:59 * [swift]_ is genuinely puzzled
10:10:11 <c_wraith|N10> .. xkcd. Darn mobile.
10:10:13 <[swift]_> is there no way to enter your username and password for Hackage except to try to uplaod a package?
10:10:43 <davean> c_wraith|N10: we'll fix mobile when we have had some sleep
10:11:04 <Kreap> why does the isInfixOf function run in O(n^2) complexity when there is a lot of well known improvements to that general algorithm?
10:11:13 <davean> well, we'll fix android at least, and iphone is people igve detailed enough bug reports
10:11:15 <zipper> davean: You wrote xkcd.com or that specific picture?
10:11:24 <davean> zipper: yes
10:11:27 <c_wraith|N10> davean: I actually think it's OK, now. Maybe check it out, but don't worry if you can't find any issues.
10:11:40 <zipper> davean: You wrote both?
10:12:07 <davean> zipper: Yah, I wrun xkcd.com and the initial picture comes from my hand-coding of the base case of the state machine :-p
10:12:42 <zipper> Oh nice. I enjoy a lot of what is there
10:12:59 <zipper> You guys once said nothing is ever written in haskell though :(
10:13:05 <c_wraith|N10> zipper: he's not the artist for the site though. That's someone else. Who is often in here, but not right now.
10:13:25 <davean> zipper: :-p
10:14:12 <zipper> c_wraith|N10: Interesting, I didn't know whoever was behind it was into haskell.
10:14:20 <monochrom> @type isInfixOf
10:14:21 <lambdabot> Eq a => [a] -> [a] -> Bool
10:15:05 <alcabrera> zipper: our of curiosity, I dug a little deeper, and found this reddit post from last year about davean's work on xkcd: http://www.reddit.com/r/haskell/comments/uved7/waldo_the_haskell_powered_codebase_behind_xkcds/
10:15:48 <fizbin> zipper: Search http://ircbrowse.net/browse/haskell for "rmunroe"
10:15:49 <alcabrera> btw, thanks for writing that up, davean. very interesting.
10:16:01 <davean> alcabrera: you're welcome
10:16:41 <davean> as for any CORS problems, uh chromakode made a mistake in the JS and I ... ruined is the right word ... the CORS framework trying to track it down on my side
10:16:47 <davean> and I'm way to tired to put it back together again
10:16:55 <amalloy> Kreap: aren't most of the improvements to that algorithm dependent on random access to list elements?
10:18:01 <amalloy> or on stuff like being able to build a tree whose keys are values from the input sequence? like, such that you'd need Ord as well as Eq
10:19:01 <fizbin> Is there anyone here who's able to walk me through http://comonad.com/reader/2011/what-constraints-entail-part-1/ ?
10:19:32 <zipper> fizbin: Wow what a cool tool IRCbrowse
10:19:53 <zipper> Will see if I can point it to my lug
10:19:54 <Kreap> amalloy
10:20:00 <fizbin> Specifically, I can't get through the first bit of code because I think he's referring to earlier posts but without links I can't find it.
10:20:15 * hackagebot tagged-transformer 0.6.2 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.6.2 (EdwardKmett)
10:20:31 <Kreap> amalloy: i don't think so, but either way, I have already written some code that reduced the complexity from O(n*m) to O(n)
10:20:46 <Kreap> i think its the knuth morris pratt algorithm, but i'm not sure
10:21:12 <monochrom> Kreap, does the function you wrote still have type Eq a => [a] -> [a] -> Bool ?
10:21:17 <Kreap> yes
10:21:28 <monochrom> then I believe you
10:21:55 <rabipelais> Hi there, people, I am getting a weird type error using MVectors: "Couldn't match expected type `MVector s Int' with actual type `MVector (PrimState (ST s)) Int'". Minimal code example: http://lpaste.net/102113
10:22:12 <Kreap> here is the code http://pastebin.com/ecMX3vKr
10:22:15 <rabipelais> The code is very similar to a snippet in "Parallel and Concurrent Haskell"
10:22:34 <zipper> IRCbrowse FTW!! CRAY CRAY HASKELL TOOLS UP IN HERE!
10:23:00 <monochrom> zipper, are you feeling well?
10:23:43 <zipper> monochrom: lol just discovered IRCbrowse and I think it's very cool. :)
10:24:08 <glguy> Kreap: try isSublist "abc" "aabc"
10:24:25 <rabipelais> nevermind, just found the mistake. It was the `Unboxed` type
10:24:29 <monochrom> yeah, it is incorrect
10:24:35 <Kreap> oh yeah your right
10:24:39 <Kreap> dang it
10:24:51 <monochrom> you need to do KMP for real :)
10:25:20 <glguy> Kreap: Also, True && x  ==> x   ;-)
10:26:34 <Kreap> im sure i had a reason for that...
10:26:38 <Kreap> looks so stupid now
10:27:51 <fizbin> rabipelais: What tool gave you that error? When I tried your code in ghci, I at least got that the mismatch was between V.MVector ... and M.MVector ... (that is, mine had the V. and M. prefixes)
10:30:05 <rabipelais> fizbin: it got reported by flymake on emacs, which I believe uses ghc. I didn't compile it, let me try that
10:31:17 <cdk> is there an xor :: Bool -> Bool -> Bool in the Prelude?
10:31:23 <fizbin> Because the error is very, very puzzling when the prefixes disappear.
10:31:32 <amalloy> Kreap: it looks like the constant factor in KMP would probably make it slower than the naive approach for most use cases; if you happen to know your input will be particularly bad for isInfixOf, you can choose to use the more complex algorithm
10:31:33 <fizbin> cdk: Beside != ?
10:31:38 <rabipelais> fizbin: uh, that's weird. If I compile it with ghc, I *do* get the V. and M. prefixes
10:31:46 <theguruofreason> will this give me a random bool if gen is an StdGen?: random (gen) :: (Bool, g)
10:31:54 <amalloy> cdk: /=
10:32:01 <fizbin> Sorry, right, /=
10:32:10 <cdk> ahh, of course. thanks amalloy, fizbin
10:32:44 <amalloy> interestingly if i try !=, ghci suggests i might have meant !! or <=, but doesn't consider /=
10:33:13 <geekosaur> I think that's actually (finally) been reported as a bug
10:33:25 <geekosaur> so hopefully future ghc(i) will be smarter about it
10:33:31 <fizbin> So no one else understands where ekmett is going with the Dict type in http://comonad.com/reader/2011/what-constraints-entail-part-1/ either?
10:34:11 <haasn> Kreap: isSublist = search
10:34:24 <haasn> Kreap: you could just expand your definition of “search” as your actual definition of “isSublist”
10:45:35 <WraithM> Is there a commonly used concurrent map (as in key-value store) library?
10:47:10 <silasdavis> hello, I'm trying to understand what's going on in my xmobar configuration
10:47:10 <silasdavis> https://www.refheap.com/70321
10:47:36 <mietek> Does anyone know of a project which would compile Haskell to bash?
10:47:40 <silasdavis> on line 5 I've trying to use the result of a function
10:47:51 <silasdavis> but it doesn't work
10:48:01 <geekosaur> silasdavis, it's not really haskell, it only looks sort of like haskell
10:48:03 <silasdavis> I am assuming TopP is a function, but is it something else
10:48:04 <geekosaur> it does not support functions
10:48:07 <silasdavis> ah
10:48:19 <silasdavis> that's a bit unpleasant
10:48:21 <geekosaur> yes
10:48:22 <silasdavis> thanks
10:48:48 <geekosaur> at one point someone was looking into making it work more like xmonad does with an actual haskell source file for configuration; I have no idea what happened to that effort
10:48:56 <silasdavis> I wish xmonad just had a status bar, and a tray
10:49:25 <silasdavis> awesome has that, but it's configuration is so hideous I had to move
10:49:29 <geekosaur> it wouldn't actually work very well
10:49:45 <silasdavis> no?
10:50:17 <geekosaur> xmonad uses the X11 event loop for everything, so to get e.g. a clock that updates regularly you would need to arrange for it to receive an event once a second
10:50:47 <geekosaur> it *could* be done but involving the X server every time is expensive
10:53:59 <silasdavis> oh I see, perhaps I could do without stalonetray, it feel wrong having to do the maths in two separate files in order to get them to line up, and even then I have to choose a fixed width tray
11:05:22 * hackagebot ad 4.2.0.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-4.2.0.1 (EdwardKmett)
11:05:55 <joejev> For a math class, I am writing a short intro to catagory theory, and how it is applied to computer science. I was wondering if anyone had any good papers or references that I might be interested in
11:07:10 <saml> joejev, do you nkow category theory?
11:07:14 <saml> and computer science?
11:07:35 <saml> hrm for a math class..
11:08:03 <saml> @google category theory computer science
11:08:07 <lambdabot> http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf
11:08:11 <saml> i think that pdf's popular
11:11:09 <kuribas> I find the warning "A do-notation statement discarded a result of type ParamSet." a bit annoying.  Isn't this equivalent to using (>>) ?
11:12:53 <heatsink> kuribas: is ParamSet a monadic value?
11:13:00 <heatsink> monadic type
11:13:08 <kuribas> no
11:13:24 <siriusbtx> Is there a map function that returns Nothing if one the function argument returns Nothing?
11:13:30 <heatsink> The warning for that isn't on by default, then
11:13:46 <kuribas> No, I used -Wall...
11:13:50 <heatsink> siriusbtx: You can use map and sequence
11:14:03 <heatsink> > sequence [Just 3, Just 4, Nothing, Just 5]
11:14:04 <lambdabot>  Nothing
11:14:09 <siriusbtx> thx
11:14:10 <heatsink> > sequence [Just 3, Just 4, Just 1 Just 5]
11:14:11 <lambdabot>  Couldn't match expected type `(a2 -> Data.Maybe.Maybe a2)
11:14:11 <lambdabot>                                -> a3 -> Data.Maybe.Maybe a0'
11:14:11 <lambdabot>              with actual type `Data.Maybe.Maybe a1'
11:14:16 <heatsink> > sequence [Just 3, Just 4, Just 1, Just 5]
11:14:17 <lambdabot>  Just [3,4,1,5]
11:14:41 <geekosaur> with map, is that not then just mapM on Maybe?
11:14:57 <heatsink> There's a command line option to disable that warning, kuribas.  I don't know its name.
11:15:11 <heatsink> Hmm, yes
11:15:20 <siriusbtx> geekosaur: mapM f is equivalent to sequence . map f.
11:15:24 * hackagebot lio-simple 0.0.1.1 - LIO support for the Simple web framework  http://hackage.haskell.org/package/lio-simple-0.0.1.1 (DeianStefan)
11:15:41 <geekosaur> yes
11:15:46 <geekosaur> exactly
11:16:09 <kuribas> heatsink: yes, I'll use that then.
11:16:45 <heatsink> You can also suppress the warning by binding results to the _ pattern.
11:16:58 <heatsink> or using 'void'
11:16:59 <heatsink> :t void
11:17:00 <lambdabot> Functor f => f a -> f ()
11:21:28 <Zolomon> raichoo: http://instagram.com/p/mNfS3yqLAc/ came with the mail yesterday :D
11:21:46 <raichoo> Zolomon: :3
11:21:57 <raichoo> Have fun :) It's a good starting point :)
11:22:52 <skypers> ok, I changed my mind about how I should represent a function in my AST
11:23:08 <skypers> now I don’t know which is the best between F (a -> b) and a -> F b
11:23:34 <skypers> I guess a -> F b is great because it enables me to pass whatever I want in a normal way, binding some stuff in F, and return the result
11:23:37 <johnw> doesn't the latter give you a bit more flexibility?
11:23:41 <skypers> the issue is : how I reduce that
11:24:05 <skypers> and how could I write a chain of functions that ends with a special type
11:24:27 <johnw> is F a monad?
11:24:40 <skypers> yes
11:24:45 <skypers> it wraps a State
11:24:51 <skypers> in order to be able to bind variables
11:24:57 <johnw> then maybe I'm missing something; does that gives you chaining?
11:25:06 <skypers> well I mean
11:25:13 <skypers> a -> b -> c -> d -> F r
11:25:17 <johnw> ahh
11:25:20 <skypers> what is the general form of that?
11:25:27 <skypers> it’s not a -> F r
11:25:37 <johnw> a -> (b -> (c -> (d -> F r)))
11:25:46 <johnw> you should be able to keep distributing out the F
11:25:53 <johnw> a -> (b -> (c -> F (d -> r)))
11:25:54 <johnw> etc.
11:26:30 <skypers> this is exactly what I’ve been trying to do since last night
11:26:41 <skypers> and I just fail
11:26:53 <johnw> one sec
11:27:24 <Zolomon> raichoo: thanks!
11:27:33 <skypers> at first, I represented functions in my AST through expressions
11:27:41 <skypers> but now I know it’s not the best way to do that
11:27:51 <skypers> since if I say a function is just a mapping between two expressions
11:27:52 <skypers> like
11:27:54 <skypers> E a -> E b
11:28:00 <skypers> I can’t introduce variable binding
11:28:03 <johnw> https://gist.github.com/9920034
11:28:08 <skypers> I need a special monad, then F
11:28:25 <johnw> you just need a Distributive constraint
11:28:30 <skypers> dammit
11:28:33 <johnw> which there is on ((->) a)
11:28:46 <skypers> I passed the whole yesterday looking for that abstraction!
11:28:58 <johnw> http://hackage.haskell.org/package/distributive
11:29:04 <johnw> edwardk strikes again :)
11:29:30 <johnw> so, to distribute against uncurried functions, keep fmap'ing
11:29:37 <[swift]_> johnw: hey, i remember you expressed interest in a bugzilla library a few days ago. here you go =) https://github.com/sethfowler/hsbugzilla
11:29:47 <johnw> [swift]_: sweet, thanks!
11:29:57 <skypers> athan: johnw might have founded what I was looking for: Distributive
11:29:58 <johnw> I maintain the github library, so now I just need to marry the two :)
11:30:01 <skypers> thank you johnw
11:30:15 <skypers> I’m gonna try then
11:30:26 * hackagebot snap-loader-dynamic 0.10.0.1 - Snap: A Haskell Web Framework: dynamic loader  http://hackage.haskell.org/package/snap-loader-dynamic-0.10.0.1 (DougBeardsley)
11:30:28 * hackagebot happstack-hamlet 7.0.4 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-7.0.4 (JeremyShaw)
11:30:37 <skypers> ok so hm
11:30:45 <skypers> let say I represent something like that:
11:30:57 <[swift]_> johnw: nice. you got me thinking about that too, since we use both github and bugzilla in our workflow where i work. it'll be interesting to see what comes out of this down the road
11:30:59 <johnw> so, fmap distribute will map Distributive f => a -> b -> f c to a -> f (b -> c).  The question is knowing how many times to fmap
11:31:00 <skypers> foo a = do { sina <- var $ sin a; return a * a *a } -- for instance
11:31:03 <skypers> the type of that is
11:31:21 <skypers> foo :: (Floating a) => E a -> F (E a)
11:31:34 <skypers> and the idea is to pass it to
11:31:37 <skypers> F (E a -> E a)
11:31:51 <johnw> right
11:31:54 <johnw> "distribute foo" :)
11:32:06 <skypers> ok, thank you :)
11:32:18 <johnw> where the Distributive in this case is ((->) (E a)), for which an instance already exists for you
11:32:37 <skypers> that’s quite awesome
11:34:22 <skypers> arf
11:34:29 <skypers> F should be Distributive as well
11:34:35 <johnw> does it need to be?
11:34:38 <skypers> yes
11:34:50 <johnw> ahh, you are right
11:35:00 <johnw> the outer functor is just Functor
11:35:04 <skypers> it’s the outer function that is just a Functor
11:35:07 <skypers> yeah
11:35:19 <johnw> well, that makes sense
11:35:22 <skypers> I think I can do it
11:35:29 <johnw> you need to know how to "unwrap and rewrap" your distributive
11:36:29 <skypers> yeah
11:36:31 <skypers> hm
11:36:49 <lrocksmashtime> Can someone please help me decipher what this type means: SqlPersistM (GHC.Prim.Any *) -> IO (GHC.Prim.Any *)
11:37:16 <johnw> I'm not familiar with Any
11:37:25 <johnw> but it looks like a definition of runSql
11:38:47 <lrocksmashtime> johnw: you're onto something
11:38:56 <athan> skypers: No way!!!!!
11:39:08 <skypers> hm johnw
11:39:15 <skypers> I think I can’t make that instance
11:39:26 <skypers> F is declared as
11:39:41 <skypers> newtype F f = F (State (Vector (SomeB E)) f) deriving (Functor,Monad)
11:40:01 <skypers> distribute f takes f as a functor that wraps my F f
11:40:04 <skypers> well, F g
11:40:31 <johnw> State should be easy to write a Distributive for
11:40:32 <skypers> I can fmap it, but I can’t escape it I guess
11:40:40 <johnw> hmm.. maybe not
11:40:44 <johnw> if it were, edwardk would have done it
11:40:50 <skypers> f (g a) -> g (f a)
11:40:56 <skypers> in my case
11:40:58 <johnw> he has an instance for ReaderT, but not StateT
11:41:08 <skypers> f (F a) -> F (f a)
11:41:12 <skypers> sounds hard
11:41:51 <skypers> I can change F in order to transform it into a GADT
11:42:04 <skypers> with a ctor like
11:42:05 <johnw> let me try
11:42:25 <skypers> FromDist :: (Functor f) => f (F a) -> F (f a)
11:42:53 <skypers> and I just hide that FromDist ctor
11:43:31 <skypers> heh no
11:43:33 <skypers> if I do that
11:43:39 <skypers> I can’t make it a Functor any more
11:43:42 <skypers> DAMMIT seriously
11:43:43 <skypers> :D
11:43:54 <skypers> it’s been a while I’m stuck with AST functions
11:44:26 <jle`> @src sum
11:44:26 <lambdabot> sum = foldl (+) 0
11:44:36 <jle`> is sum really implemented using foldl in prelude?
11:44:39 <jle`> what the heck
11:44:50 <skypers> jle`: ?
11:44:53 <skypers> so what?
11:45:24 <skypers> do you know that compiling a foldl1 (+) with -O2 results in something that acts like foldl1' ? :)
11:45:29 * hackagebot Parry 0.1.0.0 - A proven synchronization server for high performance computing.  http://hackage.haskell.org/package/Parry-0.1.0.0 (pmeunier)
11:45:33 <johnw> jle`: no, that's just lambdabot
11:45:47 <johnw> > sum [1.1000000]
11:45:48 <lambdabot>  1.1
11:45:54 <johnw> > sum [1..1000000]
11:45:55 <lambdabot>  *Exception: stack overflow
11:45:57 <johnw> hmm
11:46:18 <skypers> > foldl1' (+) [1.2000000]
11:46:19 <lambdabot>  1.2
11:46:22 <skypers> > foldl1' (+) [1..2000000]
11:46:23 <lambdabot>  2000001000000
11:47:10 <skypers> johnw: for my function issue, I think it’s quite okay to represent that throuh “bare Haskell” functions
11:47:13 <skypers> like
11:47:20 <skypers> E Float -> E Float -> F (E Float)
11:47:51 <skypers> the issue is when I want to integrate that in my AST as an expression
11:48:50 <skypers> if I want to go the way around, I can make a function E Float -> E Float -> E Float, and wrap that in a F (E Float -> E Float -> E Float)
11:48:54 <skypers> but it’s not monadic anymore :(
11:49:01 <skypers> then I can’t bind variables
11:50:08 <edwardk> dcoutts: around?
11:50:29 * hackagebot random-eff 0.1.0.1 - A simple random generator library for extensible-effects  http://hackage.haskell.org/package/random-eff-0.1.0.1 (HiromiIshii)
11:50:48 <kazagistar> if I curry a function with enough data for an intermediate result, and then use the curried function multiple times, will the intermediate result get reused or recomputed each time?
11:52:25 <skypers> edwardk: do you know a way to express a function by it’s final return value?
11:52:46 <skypers> I know we can partially apply a function (in the type system) to match all function which first argument is a
11:52:48 <skypers> ((->) a)
11:53:02 <skypers> but is there any way to do the same for the return type?
11:54:12 <skypers> yeah I guess it doesn’t make any sense, I won’t be able to use that
11:54:13 <skypers> hm
11:58:38 <johnw> in order to lock files system System.Posix.IO, do I call getLock and then setLock?
11:59:17 <johnw> ah, I think it's just setLock
12:05:17 <siriusbtx> Is there a better way of doing this:
12:05:17 <siriusbtx> line <- getLine
12:05:17 <siriusbtx> parseLine line
12:05:29 <siriusbtx> can I directly pass line to parseLine?
12:06:55 <aristid> siriusbtx: yes! getLine >>= parseLine
12:07:22 <siriusbtx> aristid: thx :P, I am a real noob in haskell
12:07:35 <koala_man> also, parseLine <$> getLine  (import Control.Applicative)
12:07:48 <siriusbtx> we had 4 weeks of lambda calculus and now they want us to write battleship in haskell -,-
12:07:48 <pranz> siriusbtx: that is, if parseLine returns an IO type
12:07:50 <aristid> koala_man: that does something slightly different
12:08:13 <siriusbtx> pranz: what if it returns Maybe a
12:08:35 <pranz> siriusbtx: then what koalaman said
12:08:39 <aristid> what is the type of parseLine?
12:09:03 <siriusbtx> well let me make it more clear
12:09:03 <pranz> the final type of that expression will be "IO (Maybe a)"
12:09:12 <siriusbtx> I have a parseShip function
12:09:16 <siriusbtx> parseShip :: String -> Maybe Ship
12:09:30 <rschulman> I'm still working on this issue... Does anyone have any experience with vty-ui? I'm following the user manual for creating a list but getting an error I don't understand.
12:09:39 <aristid> siriusbtx: ok, then what i said is not the right approach.
12:09:42 <rschulman> Log here: http://lpaste.net/102112
12:09:48 <siriusbtx> and then I want a function that reads in from the stdin and return a list of ships
12:11:48 <siriusbtx> aristid: what is the way to solve something like that in haskell?
12:11:49 <pranz> siriusbtx: then for each line "ln", do "parseShip <$> ln"
12:12:11 <siriusbtx> pranz: mhm k
12:13:04 <aristid> :t lines <$> getContents
12:13:04 <lambdabot> IO [String]
12:13:12 <aristid> siriusbtx: ^ this gives you lines.
12:14:04 <pranz> siriusbtx: oh, and (<$>) is only fmap
12:14:15 <pranz> siriusbtx: I assume you are familliar with that function
12:14:38 <siriusbtx> pranz: not rly
12:15:14 <pranz> siriusbtx: O.o, tough assignment your professor gave you
12:15:24 <pranz> :t fmap
12:15:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:16:29 <pranz> fmap "lifts" a function to work on a context
12:16:36 <pranz> siriusbtx: have you used the map function?
12:16:42 <siriusbtx> pranz: ye
12:16:45 <pranz> :t map
12:16:46 <lambdabot> (a -> b) -> [a] -> [b]
12:16:48 <siriusbtx> pranz: i know basic haskell
12:17:01 <pranz> see how similiar that is
12:17:11 <pranz> map is actually fmap, just restricted for lists
12:17:27 <siriusbtx> pranz: ye
12:17:51 <pranz> so if you have an IO String
12:17:57 <pranz> and a function String -> Maybe Ship
12:18:19 <pranz> you can fmap that function to make it's type IO String -> IO (Maybe Ship)
12:18:47 <pranz> brb
12:19:38 <yoeight_> Hi
12:20:10 <yoeight_> am i the only one having trouble compiling criterion (O.6.2.*)
12:20:14 <yoeight_> ?
12:20:53 <yoeight_> first compilation was fixed by excluding stastistic O.11
12:21:25 <yoeight_> Now I got issue with text 0.11
12:21:33 <athan> I keep thinking that data constructors and functions are different things for some reason
12:21:43 <yoeight_> Criterion/Report.hs:160:44:
12:21:43 <yoeight_>     Couldn't match expected type `text-1.1.0.1:Data.Text.Internal.Text'
12:21:43 <yoeight_>                 with actual type `B.ByteString'
12:22:13 <athan> throw in a pack
12:22:30 <athan> :t pack
12:22:31 <lambdabot>     Not in scope: `pack'
12:22:31 <lambdabot>     Perhaps you meant one of these:
12:22:31 <lambdabot>       `BS.pack' (imported from Data.ByteString),
12:22:36 <athan> :t BS.pack
12:22:37 <lambdabot> [Word8] -> BSC.ByteString
12:22:41 <athan> hmm
12:22:48 <athan> crud
12:22:54 <athan> I forget  :(
12:28:19 <johnw> athan: if you look at how a GADT is declared, it makes the identity of data constructors and functions much more obvious
12:28:47 <athan> that's what I'm starting to kinda see
12:29:02 <johnw> the special thing about data constructors is the ability to use them in pattern matching
12:29:03 <athan> I just glanced over coercion and that whole dealio within kinds
12:29:09 <athan> ahhh i see
12:30:11 <athan> wait, the identity? You don't mean anything property-wise, do you?
12:30:20 <athan> Or are you just meaning how to tell them apart?
12:30:25 <johnw> the latter
12:30:29 <johnw> they are both functions
12:30:51 <athan> hmm
12:31:17 <johnw> we can pattern match on data constructors because it's a closed set, fully knowable at the point where patterns are matched
12:31:44 <athan> hmm!
12:32:29 <pranz> athan: well, see it this way
12:32:35 <pranz> athan: what would make constructors not functions?
12:32:37 <athan> where functions more deal with the 1 directional mapping of unknowns to some other type
12:33:01 <athan> hmmm
12:33:10 <athan> well
12:33:11 <quchen> athan: Data contstructors are special functions though, because they don't actually do any computation besides introducing structure.
12:33:20 <athan> yes!
12:33:25 <athan> Yes, that's what I'm seeing too
12:33:35 <athan> Structure as in, product types?
12:33:52 <athan> hmm
12:34:18 <athan> ahh
12:35:00 <athan> pranz: trying to evaluate an expression with a type of kind >= * -> *?
12:35:03 <athan> ie
12:35:16 <athan> > data List a = Nil | Cons a (List a)
12:35:17 <lambdabot>  <hint>:1:1: parse error on input `data'
12:35:35 * hackagebot zeromq4-haskell 0.4.1 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.4.1 (ToralfWittner)
12:35:47 <athan> Cons itself isn't a value to be computed against
12:35:48 <athan> er...
12:35:49 <athan> wait.
12:35:52 <athan> f**k
12:36:06 <athan> :t (:)
12:36:07 <lambdabot> a -> [a] -> [a]
12:36:14 <DR6__> there are no expressions with type of kind * -> *
12:36:20 <athan> yeah
12:36:26 <athan> i thought I was thinking nonsense
12:36:40 <DR6__> all habitable types are of kind *
12:36:50 <DR6__> that's what the kind * means
12:37:05 <athan> habbitable?
12:37:19 <pranz> athan: when you say that data constructors provide structure, you mean that they don't reduce to anything else
12:37:22 <DR6__> a type is habitable if they are expressions with the type
12:37:30 <athan> ahhh
12:37:30 <pranz> Just 5 doesn't reduce further than Just 5
12:37:31 <athan> okay
12:37:38 <DR6__> so Int is habitable because for example 1 :: Int
12:38:08 <athan> they reduce to the sum instances of the type
12:38:13 <athan> er
12:38:17 <athan> whatever you might call those
12:38:50 <pranz> athan: hmm, I'm not following
12:38:58 <athan> i mean
12:39:02 <pranz> athan: do you mean that the sum type Either () a is the same as Maybe a?
12:39:03 <athan> every possible "value"
12:39:12 <athan> the units, without the terms
12:39:25 <athan> no no
12:39:28 <athan> sorry
12:39:34 <athan> not necessarilly the sum type
12:39:38 <athan> as a higher order data type
12:39:53 <athan> but the segmentation of possabilities that it imposes
12:40:29 <pranz> athan: might you give a concrete example of what you mean?
12:40:30 <athan> types of kind * map at that level
12:40:43 <athan> hmm
12:40:44 <athan> well
12:41:06 <athan> [Bool]
12:41:31 <athan> maps down to the boolean segments - it's possabilities - true or false, mutually exclusive
12:41:36 <athan> but
12:41:39 <athan> within a list
12:41:49 <athan> where the list is a recursive product type
12:41:55 <athan> ~~possibly
12:42:12 <athan> (through it's segmentation outside of the product)
12:42:13 <athan> ie
12:42:32 <lrocksmashtime> Anyone here have a public repository of a Yesod database backed webapp that I can look at?
12:42:56 <athan> data List a = Nil {{seg1}} | Cons {{seg2}} a (List a) {{recursion}}
12:43:03 <pranz> athan: aha
12:43:12 <athan> eventually, all product types reduce to sum types in * kinded types
12:43:15 <pranz> athan: I think I get what you
12:43:38 <athan> pranz: Check out Algebra of Algebraic Data Types
12:43:42 <athan> its a great video
12:43:44 <johnw> lrocksmashtime: you might also ask in #yesod
12:43:45 <pranz> are trying to say
12:43:48 <athan> and blog post series
12:43:54 <lrocksmashtime> johnw: great idea
12:43:55 <pranz> mm have seen some of it
12:44:01 <pranz> and yeah that's true
12:44:21 <athan> the thing is, though
12:44:25 <athan> like with head []
12:44:26 <pranz> [Bool] is [] | [True] | [False] | [True, False] | ....
12:44:36 <athan> it's like... effed haha
12:44:42 <athan> yep
12:44:43 <athan> !
12:45:24 <athan> so really\
12:45:29 <athan> [] :: List a
12:45:31 <athan> while
12:45:40 <athan> [1] :: List Int
12:45:54 <athan> which gives reason why head [] fails -
12:46:03 <athan> it's indefinite and can't reduce
12:46:24 <athan> if the full definition was in head, I feel like it would be a lot faster, too
12:47:34 <athan> so like, List (Bool)
12:47:47 <athan> is a 2 dimentional sum type
12:48:20 <athan> with one dimension being countably infinite
12:48:22 <athan> maybe
12:48:23 <athan> actually
12:48:26 <athan> hmm
12:48:38 <athan> i do believe it's 2-dimensional
12:48:43 <athan> but the recursion makes it multi
12:48:50 <athan> phew
12:48:58 <dwcook> athan, in what sense is [Bool] two-dimensional?
12:51:57 <Mie9> hi
12:52:15 <Mie9> how to detect unised imnports in module?
12:52:29 <johnw> Mie9: you can ask GHC to generate a minimal import set
12:52:40 <johnw> ghc -ddump-minimal-imports
12:53:48 <snardbafulators> every time I try to compile in terminal, I get this message
12:53:49 <snardbafulators> why?
12:53:50 <snardbafulators> http://imgur.com/feq03xk
12:54:40 <mwhitfield> damn you
12:54:46 <Mie9> johnw: hm, it doesn't work when i point it at random module within package
12:54:47 <indigo> :|
12:54:57 <Mie9> Could not find module `System.Random'
12:55:13 <indigo> Don't click on the link snardbafulators posted, it's NSFW.
12:55:14 <Mie9> johnw: can i do it via cabal?
12:55:23 <johnw> Mie9: that's the only way I know
12:55:24 <snardbafulators> bull shit
12:55:28 <simukis_> Can we have snardbafulators discover he wants to learn haskell?
12:55:29 <snardbafulators> it shows my terminal window
12:55:30 <snardbafulators> nothing more
12:56:25 <WraithM> haddock gets confused by this, it doesn't link the proper HTML: module A (module B) where { import A.X as B; import A.Y as B; }
12:57:06 <WraithM> haddock says: Could not find documentation for exported module: B
12:57:18 <heatsink> @op
12:57:18 <lambdabot> Maybe you meant: yow wn v rc pl id do bf @ ? .
12:57:26 <WraithM> Do I have to export explicitly?
12:58:03 --- mode: ChanServ set +o geekosaur
12:58:11 <ClaudiusMaximus> WraithM: i ran into that annoyment, think i just reverted to typing out all the names in full twice
12:58:22 <WraithM> Okay :/ fair enough
12:58:24 <WraithM> Thanks!
12:58:48 <snardbafulators> hey  so
12:58:49 <ClaudiusMaximus> but it might be worth checking/filing a bug against haddock, wherever the most appropriate place to do that is
12:58:50 <snardbafulators> why no answer
12:58:51 <snardbafulators> http://imgur.com/feq03xk
12:58:58 <snardbafulators> this is the compile error that shows up in terminal
12:59:03 <mmmm> Is there a usual reason why your code would work correctly when loaded in the interpreter but fail to build with cabal?
13:00:21 <Mie9> johnw: -Wall emits warnings about unused importes fyi
13:00:28 <ClaudiusMaximus> mmmm: cabal needs you to list all your dependencies, ghci just gives a best effort attempt to load anything
13:00:38 <Mie9> can be used with cabal in ghc-options ofcourse
13:02:24 <heatsink> @msg geekosaur snardbafulators repeatedly posting an nsfw image disguised as a code screenshot in #haskell.  Can you stop it?
13:02:24 <lambdabot> Not enough privileges
13:03:03 <geekosaur> I've been trying to figure out wtf is going on because it actually loads as a terminal image and then gets replaced...
13:03:12 <geekosaur> but, they doth protest too much (and keep reposting)
13:03:18 --- mode: geekosaur set +b *!*suaporraq@200.79.255.*
13:03:19 --- kick: snardbafulators was kicked by geekosaur (snardbafulators)
13:03:24 <heatsink> Thanks
13:03:34 <geekosaur> every so often crappy slow connections have their uses
13:03:46 --- mode: geekosaur set -o geekosaur
13:04:05 <heatsink> It could an animated image.  I didn't check the file type.
13:05:33 <geekosaur> btw it's @where ops
13:05:36 <geekosaur> see /topic
13:06:00 <tsou> someone here recently commented on how genericLength is the worst thing every created by man; can someone briefly explain why?
13:07:00 <heatsink> ok
13:09:11 <siriusbtx> getShip :: IO (Maybe Ship) How can I chain calls to this function with respect to Maybe Ship?
13:09:21 <johnw> you could use MaybeT
13:09:34 <johnw> do you want to chain other IO (Maybe a) functions?
13:09:37 <johnw> or other Maybe a functions?
13:09:54 <siriusbtx> IO (Maybe a)
13:10:00 <johnw> MaybeT then
13:10:11 <johnw> newtype MaybeT m a = MaybeT (m (Maybe a))
13:10:25 <Kaidelonglong> if you are talking about "I want to determine if I'll do more IO by whether or not the last IO action got a Nothing" then what you want is MaybeT IO
13:10:33 <johnw> so you could say: MaybeT getShip >> MaybeT getShip
13:10:41 <siriusbtx> k
13:12:52 <Clint> hoistMaybe
13:13:06 <johnw> :t hoistMaybe
13:13:06 <lambdabot> Not in scope: `hoistMaybe'
13:15:33 <Kaidelonglong> @instances-importing Monoid
13:15:33 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
13:16:32 <Kaidelonglong> is there no general instance for (Monoid t, Applicative f) => Monoid (f t)?
13:17:25 <seanparsons> Is there a way of excluding cost centres from the profiling? In this case ones I can't remove without forking other projects for instance.
13:17:38 <Kaidelonglong> I guess it'd break First and Last
13:17:55 <Mie9> is there a way to reuse portions of definitions across cabal file?
13:18:19 <Mie9> for example i have long list of ghc-options i want to use in library and executable
13:18:55 <Mie9> currenlty i'm resorting to copy-pasting that long list of options but i'd like to know better way to do it
13:22:52 <madjestic> a cabal-related question: what's going on here?: http://lpaste.net/102117
13:23:14 <shergill> if we have a (host) language L1 with type system T1, and we embed a dsl L2 with type system T2 in it, what's the relation between T1 and T2?
13:24:24 <seanparsons> madjestic: Is it requiring that specific version or does it specify bounds?
13:25:42 * hackagebot language-ecmascript 0.16.1 - JavaScript parser and pretty-printer library  http://hackage.haskell.org/package/language-ecmascript-0.16.1 (AndreyChudnov)
13:25:52 <acowley> I find myself wanting to take a type family as a type parameter for a GADT
13:26:09 <acowley> Someone tell me there's a smart way of accomplishing that
13:26:26 <madjestic> seanparsons: the cabal file sais: "cabal-version: >=1.8.0.0"
13:26:36 <seanparsons> Hmmm.
13:26:46 <heatsink> shergill: T2 is modeled in T1.  You can find a correspondence between types in T1 and types in T1 or values in L1.
13:26:52 <madjestic> seanparsons: that was the first thing I checked
13:27:15 <heatsink> uh, there's a T2 missing
13:28:17 <shergill> heatsink: right. what's implications does it have in terms of expressivity? i.e., is there an upper bound of how expressive T2 can be depending on T1?
13:28:22 <shergill> *what
13:28:33 <shergill> *on how
13:28:33 <seanparsons> madjestic: What interests me is that it's complaining about "1.18.0" and not "1.8".
13:29:45 <madjestic> seanparsons: I'll set it to 1.8 and see what happens
13:30:45 <Mie9> anyone?
13:31:02 <heatsink> Certainly there's a limit to what can be expressed in the type system.  I don't know how that would be formalized.
13:31:04 <madjestic> seanparsons: I don't think that changes anything
13:31:06 <seanparsons> madjestic: I just grabbed the latest and it seems to be building fine for me (I did do a "cabal sandbox init" however).
13:31:18 <mm_freak> heatsink: it is limited to computable proofs
13:31:43 <seanparsons> I've even got 1.18.1.3 of the cabal library.
13:32:05 <mm_freak> but since in haskell you can prove anything you want…
13:32:55 <roconnor> computable proof??
13:33:22 <enthropy> acowley: don't they have to be fully applied all the time? Instead of passing around F (type family F a :: *), you can pass around something with an instance of (type family ApplyF f a :: *; type instance ApplyF "F" a = F a)?
13:33:25 <heatsink> I don't think it matters that you have a DSL.  The same problems should arise when writing a library.
13:33:39 <acowley> enthropy: That's exactly what I just tried
13:33:52 <mm_freak> roconnor: "constructive"
13:34:13 <acowley> enthropy: But I don't think it worked, I'll keep playing with it
13:34:15 <roconnor> oh right
13:34:20 <acowley> enthropy: I may have gummed it up
13:34:23 <roconnor> ``limited''
13:34:42 <mm_freak> "decidable"
13:34:54 <acowley> enthropy: I think it's working
13:35:01 <enthropy> that version should work, but it's not very smart
13:35:14 <roconnor> @tell haasn Yes, colour's performance is downright abyssmal
13:35:15 <lambdabot> Consider it noted.
13:37:01 <mm_freak> where do you people run your blogs with haskell syntax highlighting and latex/mathjax math?
13:37:18 <mm_freak> syntax highlighting isn't as important as latex math though
13:37:22 <Mie9> for example i have long list of ghc-options in cabal file and i want to use it in library and executable, how can i avoid duplication?
13:37:36 <acowley> enthropy: What's the problem with that approach?
13:37:44 <seanparsons> madjestic: That "cabal install" in the sandbox worked without a hitch from latest, about the only think I can think of that might be different with mine is that I have nothing installed at the user level.
13:37:52 <enthropy> you need a whole extra type family
13:38:03 <enthropy> you can't just accept any one that has the right kind
13:38:17 <enthropy> because it won't have an instance of the ApplyF
13:38:20 <acowley> Yeah
13:38:35 <acowley> I'm willing to budge on the goal of "smart" :)
13:41:15 <Mie9> help
13:44:18 <shergill> mm_freak: i wirte entries in emacs org-mode and export to html. i serve this html on my blog <http://shergill.su> this gives me both syntax highlighting and mathjax support
13:45:45 * hackagebot wai-predicates 0.3.2 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.3.2 (ToralfWittner)
13:45:47 * hackagebot wai-routing 0.5.2 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.5.2 (ToralfWittner)
13:48:25 <mm_freak> shergill: yeah, i've seen others doing that, although i'd probably prefer hakyll then
13:53:06 <acowley> Now I want to promote type formers
13:53:13 <acowley> Oh Haskell you tease
13:55:46 * hackagebot HaRe 0.7.2.1 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.2.1 (AlanZimmerman)
13:55:48 * hackagebot lio-simple 0.0.2.0 - LIO support for the Simple web framework  http://hackage.haskell.org/package/lio-simple-0.0.2.0 (DeianStefan)
14:00:47 * hackagebot mailgun 0.1.0.0 - Connector to Rackspace's Mailgun Service  http://hackage.haskell.org/package/mailgun-0.1.0.0 (andrewrademacher)
14:05:48 * hackagebot lio-simple 0.0.2.1 - LIO support for the Simple web framework  http://hackage.haskell.org/package/lio-simple-0.0.2.1 (DeianStefan)
14:17:27 <awestroke> how do I nuke my cabal? I removed ~/.cabal, but it seems some packages are still installed
14:17:46 <acowley> There's also ~/.ghc
14:19:31 <geekosaur> removing ~/.cabal removes the installed libraries but the package registry is in ~/.ghc and now reports packages that no longer exist, which will lead to odd errors
14:19:46 <geekosaur> in general you want to remove ~/.ghc instead of ~/.cabal
14:19:57 <awestroke> geekosaur: why not both?
14:20:05 <geekosaur> also see www.vex.net/~trebla/haskell/sicp.xhtml
14:20:13 <acowley> Best to be safe and get a new computer
14:20:17 <geekosaur> for one, you are removing ~/.cabal/config
14:20:46 <awestroke> geekosaur: I have no custom config. any cool stuff I'm missing out on?
14:20:46 <geekosaur> and various cached data that is likely to still be useful if you
14:20:50 <geekosaur> re going to reinstall stuff
14:20:51 * hackagebot smtps-gmail 1.1.1 - Gmail SMTP Client  http://hackage.haskell.org/package/smtps-gmail-1.1.1 (EnzoHaussecker)
14:20:53 <acowley> The extent to which you need type classes to work with type families is kind of a bummer
14:20:58 <Fuuzetsu> acowley: cabal hell is not thwarted by such measly things like physical boundries
14:21:16 <geekosaur> you *could* remove both, it's just often overkill
14:21:40 <awestroke> I just start "cabal install lens" after the nuke to get everything back
14:21:43 <acowley> Yes, a better strategy for escaping cabal hell is to teach someone else Haskell, and then steal their computer once they've set up a development environment.
14:21:43 <awestroke> it depends on all things
14:22:17 <Fuuzetsu> Hm. I usually just draw pentagrams and summon satan but maybe my approach is all wrong.
14:22:49 <romildo> Type classes are the mechanism Haskell does overloading. A method from a type class is clearly overloaded for each type instance of that type class. This means that there is a definition of the method for each instance. And what about a function that is not a method in any class, but uses some method. Is it overloaded to? For instance, the 'read' function uses the 'readsPrec' method of the 'Read' class. Clearly 'readsPrec' is overloaded. Is 'read' over
14:22:49 <romildo> loaded too?
14:23:14 <acowley> It is more that the function is parameterized
14:23:47 <acowley> (parameterized by an instance for the named type class)
14:26:17 <romildo> I used to call 'overloaded' every function with a restricted type variables in its type. But now it looks wrong to me because there is only one definition to it.
14:26:55 <acowley> Exactly, overloaded is when you have differing definitions for different types.
14:27:37 <awestroke> do cabal sandboxes affect ghc or do I need to use a cabal file for my project to use a sandbox?
14:27:40 <romildo> Then only methods of type classes are really overloaded.
14:28:13 <acowley> awestroke: You can give GHC flags to use the sandbox package-db
14:28:40 <merijn> romildo: I think this is one of these cases were thinking to hard on what the exact terminology means might get you even more confused. I don't think there's an unambiguous formal definition of "overloading" :)
14:29:37 <awestroke> how do I solve ExitFailure 1 during cabal package install? Fix the cached source code and retry build?
14:31:06 <romildo> merijn, I am just preparing some slides to my students about types and I am having difficult describing overloading. It is a course on functional programming using Haskell to undergraduate students.
14:31:42 <awestroke> "Couldn't match type `B.ByteString' with `text-0.11.3.1:Data.Text.Internal.Text'" <- should NOT be my problem, I just want the package installed
14:32:22 <merijn> romildo: I would maybe not use the term overloading then
14:32:33 <Fuuzetsu> check what's actually giving that problem, if it's the package itself then you better contact the maintainer
14:33:12 <acowley> While I agree that "overloading" may be somewhat overloaded as a term, what's wrong with what was said so far?
14:33:18 <acowley> It seems like a pretty clear distinction to me.
14:33:43 <merijn> romildo: I would probably avoid finding a specific word for it and just describe what it is, if needed you can make up a term
14:34:08 <acowley> Don't make up a term
14:35:00 <merijn> By make up I mean "let's call this X" hell, use overloading for all I care, but I wouldn't use overloading in the *explanation*
14:35:07 <acowley> Even if the notion of writing different equations at different types doesn't float your boat, acknowledging ambiguity would be better than making up a new term
14:36:07 <acowley> We'll just have people come to #haskell ask what a fluvenbarred function is, then we'll have to back out the invented term and say that it is usually referred to as overloading, etc.
14:36:43 <acowley> Although I do kind of like the sound of a fluvenbarred function
14:37:21 <merijn> i.e. "Typeclasses define a set of functions/values, plus their type. Every instance (can) provide it's own implementation of these functions. One application of this is ad-hoc polymorphism, that is, a way to reuse a generic function for different types, similar (or compare to) C++/Java/whatever's ability to overload functions"
14:37:35 <Vektor> Ok, folks, I was trying to get back into haskell. Been a short while since I've done real problem solving. I'm right now trying to count occurences of chars in a String.
14:38:12 <Vektor> i.e. for "Hello" I'm imagining something like [(2, 'l'), (1, 'H'), ...]
14:38:25 <Vektor> so the obvious first step is to sort the string.
14:39:05 <Vektor> My next step would probably be to use partition on the sorted string, right? How do I best apply that?
14:39:12 <Fuuzetsu> one solution would be to group the letters and the map length
14:39:34 <Fuuzetsu> there was a thread on beginners about such a partition, check it out, it was something like using groupBy without Ord
14:39:53 <Vektor> groupBy doesn't sound bad either :)
14:40:03 <Fuuzetsu> it doesn't do what you want unless you sort first
14:40:25 <Fuuzetsu> > group $ sort "hello world"
14:40:25 <Vektor> sure
14:40:26 <lambdabot>  [" ","d","e","h","lll","oo","r","w"]
14:40:38 <athan> if an infix binary operator (#) binds more tightly than (%), how would `a (#) b (%) c` resolve?
14:40:46 <Fuuzetsu> > map (\x -> (length x, head x)) . group $ sort "hello world"
14:40:47 <lambdabot>  [(1,' '),(1,'d'),(1,'e'),(1,'h'),(3,'l'),(2,'o'),(1,'r'),(1,'w')]
14:41:00 <Vektor> neat
14:41:04 <Fuuzetsu> athan: a # (b % c)
14:41:05 <Vektor> but that
14:41:12 <Vektor> 's the easy way out
14:41:39 <Vektor> I'm gonna tinker on doing it by partition... just to flex my function higher-order muscles.
14:41:56 <athan> Fuuzetsu: Ahh, so the "tighter" the binding, the closer to the bottom of the lambda stack the operator is
14:41:57 <athan> correct?
14:42:04 <athan> or something along those lines?
14:42:26 <Fuuzetsu> athan: not sure where you're getting anything about lambda stack, whatever that is
14:42:49 <Fuuzetsu> something bounds tighter → do that first
14:42:53 <athan> if composition creates a new parameter
14:42:54 <athan> like
14:43:38 <athan> a (#) (\b -> b (%) c)
14:43:40 <athan> or something?
14:44:00 <athan> or... hmmm
14:44:32 <Fuuzetsu> you seem confused
14:44:47 <athan> very
14:44:47 <athan> lol
14:44:56 <Fuuzetsu> also you're putting parenthesis around infix operators which is not good
14:45:01 <Fuuzetsu> it's like saying 3 (+) 5
14:45:01 <athan> I'm reading mpj's "a theory of qualified types"
14:45:12 <merijn> athan: Fuuzetsu answer was wrong, "a (#) b (%) c" parses as a function 'a' getting (#), b, (%) and c as arguments
14:45:12 <athan> eh
14:45:14 <athan> that's not that bad
14:45:29 <athan> ahhhhhhhh
14:45:37 <athan> merijn: Thank you!!!
14:45:37 <Fuuzetsu> merijn: oh, I thought he was just making a mistake
14:45:49 <Fuuzetsu> then yeah, it's just function application ;P
14:45:57 <merijn> Fuuzetsu: So you autocorrect his code and then didn't correct him? :p
14:46:08 <Fuuzetsu> merijn: damn autocorrect
14:46:11 <athan> merijn: so there _isn't_ an implicit quantifying lambda created in (b (%) c)
14:46:11 <merijn> athan: For example, let's pretend 'a' is 'map'
14:46:15 <merijn> :t map (+)
14:46:16 <lambdabot> Num a => [a] -> [a -> a]
14:46:25 <merijn> athan: This passes the function (+) to map
14:46:41 <merijn> athan: In the same way that "map isEven" passes a function to map
14:46:46 <athan> ahhhhhhhhh
14:46:59 <athan> hmm
14:47:07 <merijn> athan: Operators surrounded by () behave *exactly* like normal functions
14:47:32 <athan> ver, very interesting
14:47:34 <athan> but
14:47:38 <athan> hmm
14:47:43 <jrmithdobbs> and functions surrounded by () behave (exactly?) as infxl 0 functions
14:47:48 <athan> ahhh, there's where I've screwed up
14:47:49 <jrmithdobbs> erm ``
14:47:53 <jrmithdobbs> not ()
14:47:54 <merijn> jrmithdobbs: *bzzt*
14:48:05 <athan> I've used the prefix operation as infix
14:48:12 <Fuuzetsu> you can give `` fixity annotations
14:48:13 <merijn> jrmithdobbs: Wrong on two counts :)
14:48:26 <jrmithdobbs> Fuuzetsu: oh? didn't realise that
14:48:33 <merijn> jrmithdobbs: 1) you can give fixity to infix functions and 2) without fixity, the default is infixl 9
14:48:38 <athan> hmm
14:48:39 <athan> okay, so
14:48:42 <Fuuzetsu> and stuff in (+) is just a regular function so it binds the tightest to the left
14:48:49 <merijn> jrmithdobbs: "infixl 4 `elem`" <- this is valid haskell :)
14:48:53 <jrmithdobbs> merijn: doh, two typos, I'm just going home instead of typing any more ;p
14:49:11 <athan> so, then
14:49:13 <athan> how would
14:49:17 <merijn> That's not the *actual* fixity of elem, though, iirc
14:49:19 <jrmithdobbs> had no idea you could give fixity though, good to know
14:49:21 <athan> a `#` b `%` c resolve
14:49:24 <merijn> I think elem is infix 4 `elem`
14:49:32 <merijn> athan: That's a parse error :)
14:49:32 <Fuuzetsu> athan: as an error
14:49:34 <athan> if (#) bound tighter
14:49:44 <merijn> athan: Ok, let's go back to basics
14:50:03 <merijn> athan: The haskell report defines a set of operator characters (I don't remember which ones, check report for details)
14:50:14 <athan> if # :: A -> B -> B
14:50:22 <merijn> athan: Any function whose name consists of *only* operator characters is an operator and gets parsed infix
14:50:43 <merijn> You can get an operator to behave as "normal" functions by surrounding their name in parentheses
14:50:48 <jrmithdobbs> and : is specially defined to be uppercase for constructor case
14:50:59 <Fuuzetsu> … satisfy (`elem` "_.!#$%&*+/<=>?@\\|-~:") …
14:51:03 <athan> oh, right right
14:51:17 <merijn> Fuuzetsu: unicode characters in the operator code page also work
14:51:25 <athan> right
14:51:26 <merijn> Yes, this means a snowman operator is valid haskell (iirc)
14:51:41 <jrmithdobbs> heart too
14:51:43 <jrmithdobbs> iirc
14:51:50 <jrmithdobbs> poop's the best though :)
14:51:52 <Fuuzetsu> merijn: eh, I just pulled this out of the Haddock parser, it catches unicode later
14:51:57 <awestroke> µ doesn't parse as infix :(
14:52:22 <merijn> athan: And "normal" functions are parsed as prefix functions, which can be turned infix with ``, but adding `` to operators does nothing but create an error :)
14:52:50 <athan> merijn: Okay, so say I replace # and % with operator symbols
14:52:59 <merijn> They already are operator symbols :)
14:53:12 <athan> a (..*) b (..+) c
14:53:22 <merijn> > let x % y = x + y in 3 % 4
14:53:31 <athan> lol!
14:53:34 <merijn> @botsnack
14:53:35 <athan> anyway
14:53:37 <merijn> :(
14:53:42 <merijn> Lambdabot is dead
14:53:44 <athan> (..*) :: A -> B -> B
14:53:54 <athan> (..+) :: B -> C -> C
14:53:57 <awestroke> @let x = x + 1 in x
14:53:58 <Benzi-Junior> how does pattern matching work in do notation ?
14:54:01 <athan> erm, shit
14:54:06 <Mie9> hello, how can i enabel colors in "tasty" output when running "cabal test"?
14:54:17 <athan> a `(..*)` b `(..+)` c
14:54:21 <merijn> Benzi-Junior: You mean if you do "Just x <- do someStuff"?
14:54:22 <mwhitfield> noo
14:54:29 <mwhitfield> just a ..* b ..* c
14:54:32 <awestroke> athan: a ..* b ..* c
14:54:35 <athan> if (..*)'s binding is stronger, how does the expression get nested?
14:54:39 <Iceland_jack> (`id (+)`)
14:54:41 <mwhitfield> and # and % are already operator symbols
14:54:45 <merijn> Iceland_jack: Error
14:54:54 <Fuuzetsu> athan: the binding does not matter if the operators are not used infix
14:54:57 <athan> thats all beside the point hahahaha
14:55:07 <Iceland_jack> merijn: what about ``((fmap id (+))`)`?
14:55:10 <awestroke> athan: (..*) turns it into a non-infix function, just like (*)
14:55:18 <awestroke> athan: consider (*3) 5
14:55:19 <athan> I'm just trying to see how the nesting resolves if one operators binding is tighter than another's
14:55:24 <merijn> athan: If ..*'s fixity is higher than ..+, then "a ..* b ..+ c" then it becomes "(a ..* b) ..+ c"
14:55:41 <merijn> Iceland_jack: You can't have non function names in between `
14:55:45 <athan> marijn: AHA! Thank you!!!
14:55:52 <Iceland_jack> merijn: (I'm joking) :)
14:55:52 <athan> s.t.
14:55:59 <athan> ..*
14:56:22 <athan> then has (..+) passed into it as it's furst argument
14:56:23 <athan> erm
14:56:24 <athan> sorry
14:56:32 <merijn> athan: This also explains why function application binds tighter than operators, function application has fixity 10, while the maximum for operators is 9
14:56:45 <athan> ((..*) a b) has ..+ as it's first term applied
14:56:56 <athan> very interesting
14:57:13 <athan> it creates a local nest
14:57:16 <tapuu> Is there a way to make this code have tail call optimisation: http://lpaste.net/102119 ?
14:57:22 <merijn> athan: No, what I wrote is identical to "(..+) ((..*) a b) c"
14:58:10 <athan> OHHHHHHHH
14:58:11 <athan> woah
14:58:14 <athan> holy toleto
14:58:15 <athan> whoops
14:58:17 <athan> okay
14:58:26 <athan> so the tighter the binding, the more local the expression
14:58:45 <Benzi-Junior> merijn: not exactly I have a variable in a do block of type "Either a b" and I need to change how the code runs depending on if it is "Left a" or "Right b"
14:58:46 <athan> weaker bindings become more general expressions
14:58:49 <athan> erm
15:00:26 <tapuu> http://lpaste.net/102119 Does anyone know whether its possible to give this code tail call optimisation?
15:00:39 <geekosaur> tapuu: tail call optimization is kinda not really a thing, since it's only meaningful in a strict/procedural context
15:00:41 <merijn> Benzi-Junior: You can just write a case-of?
15:00:53 <Fuuzetsu> tapuu: We have seen your message the first time, if someone wants to say something about it then they will ;)
15:01:11 <tapuu> Fuuzetsu: Some weird thing happened with like 20 people signing off after I sent it
15:01:13 <geekosaur> haskell's evaluation is outside-in, not inside-out, and to the extent that tail calls matter they're somewhat trickier
15:01:18 <merijn> Benzi-Junior: "case myVar of Left x -> do {- stuff using x -}; Right y -> do {- stuff using y -}"?
15:01:32 <tapuu> Fuuzetsu: I thought a lot of people might have missed it
15:01:41 <merijn> Benzi-Junior: If the blocks are too large, define them in a where clause and call them from the case-of
15:01:53 <Fuuzetsu> Alright. I have my join/part messages turned off so I didn't see. Probably Freenode having trouble again.
15:02:02 <dolio> The secret is, every call is a tail call in Haskell, and they're all costless.
15:02:22 <tapuu> The thing is, the stack is getting bigger and bigger with that code
15:02:38 <geekosaur> also, are you using Cont for a reason, or are you trying to manually do that optimization too?
15:02:40 <tapuu> But the memory stays constant if I use this http://lpaste.net/102120
15:02:40 <merijn> dolio: Not true, there are plenty of cases where tail recursion matters in haskell too
15:02:54 <merijn> dolio: But, that's *far* less often then in non-lazy languages
15:03:11 <dolio> I don't see where I said "tail recursion doesn't matter".
15:03:20 <dolio> But, what I did say is true.
15:03:32 <tapuu> geekosaur: I've removed all the useful code so I can figure out why the stack won't stay constant
15:03:32 <merijn> dolio: You said "every call is a tail call"
15:03:36 <dolio> It is.
15:03:57 <Benzi-Junior> merijn: ahh so I need to have "-> do" ofc I forgot to add the do and was getting an error
15:03:58 <merijn> dolio: Which is not true, as there is an observable difference between tail and non-tail recursive functions in some cases
15:04:10 <athan> dolio: Very nice
15:04:22 <merijn> Benzi-Junior: case-of just wants an expression after ->, but do blocks are valid expressions :)
15:04:23 <athan> dolio: I need to start reading Core()
15:04:35 <dolio> If you go read the paper on the STG machine, you will see that the instruction that corresponds to function application is "tail call".
15:04:46 <skypers> ok
15:04:51 <skypers> I’m beat
15:05:01 <skypers> I give up that @!#^ AST
15:05:01 <Benzi-Junior> merijn: I see
15:05:06 <skypers> it’s going to nowhere
15:05:21 <tapuu> dolio: If every call is a tail call, why is my stack getting bigger :P
15:05:53 <dolio> I don't know. I haven't thought about your code. But just because every call is a tail call doesn't mean that there is no stack.
15:06:05 <dolio> It just means that stack is not used for function application.
15:06:27 <geekosaur> ^^ key point. there is not a function call stack (not in the usual sense at least). there is a pattern match stack
15:06:28 <skypers> athan: I think it’s impossible to do with the current parameters (my w a -> w b -> … -> w r into w (a -> b -> c -> …)
15:06:35 <geekosaur> and stack growth usually means excessive laziness
15:06:41 <skypers> athan: it could be done with Distributive but it can’t be instantiated
15:06:42 <skypers> so…
15:07:01 <monochrom> tapuu: see my http://www.vex.net/~trebla/haskell/lazy.xhtml for lazy evaluation and costs.
15:07:05 <geekosaur> and you need to force evaluation so you aren't building up a stack of pending pattern matches / lazy evaluations
15:07:24 <tapuu> monochrom: thank you
15:07:57 <monochrom> the "stack" is for crunching down a huge expression that uses eager operators throughout.
15:08:35 <athan> wow
15:09:01 <dolio> Anyhow, when you see something like "foldr f z (x:xs) = f x (foldr f z xs)", the instructions are, roughly: build closure c = foldr f z xs ; tail call f x c
15:09:37 <athan> skypers: why is that?
15:09:47 <dolio> So even though foldr is "not tail recursive" it makes a tail call.
15:09:50 <athan> You can't pattern match against a universal quantifier?
15:09:51 <athan> erm
15:09:56 <athan> a higher order function? :)
15:10:06 <skypers> athan: it’s quite simple
15:10:19 <skypers> E a -> E b -> E c -> … -> E d -> F (E r)
15:10:25 <tapuu> I'm not sure how to force evaluation in my code without it getting stuck in a loop
15:10:29 <acowley> dolio: You are good at simplifying STG
15:10:31 <skypers> this is the correct way of representing a function in a EDSL
15:10:48 <acowley> "the" correct way?
15:11:01 <Fuuzetsu> skypers: please, the nbsp hurts
15:12:27 <skypers> well, the best way I’ve found for my problem
15:12:27 <skypers> it’s a monadic EDSL
15:12:27 <skypers> with variable binding
15:12:27 <skypers> a function is then a function between Expressions in a monad that hoists a State, for the variable bindings
15:12:27 <skypers> quite okay to me
15:12:27 <skypers> here, such a monad is F
15:12:27 <acowley> Imma let you finish, but finally tagless is one of the greatest EDSL techniques of all time
15:12:36 <skypers> what do you mean tagless?
15:13:05 <acowley> @google finally tagless
15:13:06 <lambdabot> Plugin `search' failed with: user error (https not supported)
15:13:09 <acowley> :(
15:13:35 <acowley> I guess the place to go is http://okmij.org/ftp/tagless-final/
15:14:02 <skypers> yeah, I’m already reading that
15:15:05 <skypers> but hm, in my case, I use E a -> … -> F (E r)
15:15:13 <Fuuzetsu> ...
15:15:14 <skypers> E is a GADT
15:15:20 <skypers> and F is a state monad
15:15:37 <tapuu> making all the functions in my code strict hasnt helped
15:15:46 <SirDarjeeling> Hey guys... Can one of you tell me how Map.Map is made part of the Functor Typeclass? So, what the implementation looks like?
15:16:16 <monochrom> naw, making everything strict would be too easy. you have to make some things strict and some other things non-strict.
15:16:20 <jrmithdobbs> SirDarjeeling: what are you confused about specifically?
15:16:21 <Fuuzetsu> SirDarjeeling: why not look in the module?
15:16:42 <erisco> SirDarjeeling, Functor (Map k)
15:18:15 <SirDarjeeling> I just couldnt find it until now and confused about how fmap is implemented for the Maps. so the stuff after what erisco wrote
15:18:34 <tapuu> monochrom: Could you help me make this code run without stack usage, please? http://lpaste.net/102119
15:18:59 <skypers> so the tagless mean there’s no E?
15:19:01 <tapuu> monochrom: Well maybe the stack term is wrong, but I mean with constant memory usage
15:19:07 <skypers> an expression is directly represented as-is?
15:19:58 <erisco> SirDarjeeling, the map can be more simply represented as [(k,v)] which is a list of key and value pairs. The fmap instance works on the values, or the second item in the pair
15:20:11 <b0bbi10> hello, do you mind if I ask a very inappropriate Haskell question in here? it's kind of an analogy concerning Haskell, but I think some will think that's kind of a joke
15:20:36 <skypers> hm, interesting
15:20:36 <roconnor> b0bbi10: I mind.
15:20:38 <Fuuzetsu> ‘very inappropriate’ sounds like it's inappropriate here
15:20:48 <skypers> what lam is used to meaning?
15:20:52 <Benzi-Junior> I feel so dirty using all these IORefs and changin values and whatnot
15:20:54 <Fuuzetsu> I think -blah or something might be better.
15:21:48 <Fernandos> hi
15:22:04 <SirDarjeeling> erisco, how does that look like then? fmap f [(k,v)] = [( k,(f v) )] or something like that?
15:22:32 <b0bbi10> well, I once read that high level languages like Java and Python are social skills, and compared to that Haskell is like (slow) sex. I won't comment on the latter, but do you think slow refers to the lazy evaluation of Haskell?
15:22:42 <erisco> SirDarjeeling, well a Map is not actually represented as a list of 2-tuples. it is represented as a tree
15:22:45 <Fernandos> regarding query parallelization, without locks on multiple cpus and databases. What's the proper way to do that? Can FRP help to parallelize the queries and hold the state synced as a bonus?
15:22:59 <b0bbi10> of the execution of speed? (though I read that Haskell competes with C/ C++)
15:23:22 <skypers> b0bbi10: are you saying Haskell is slow while Python’s not?
15:23:22 <monochrom> b0bbi10, I think that at most the author knows what he/she is talking about. at most. that is, perhaps even he/she doesn't know.
15:23:23 <erisco> SirDarjeeling, but if you wanted to write fmap for a list of tuples, that is not quite how you'd do it, though you have the idea
15:23:31 <Fuuzetsu> I think you just read something silly and shouldn't be thinking too much into it.
15:23:41 <monochrom> the internet is full of people speaking before thinking
15:23:51 <b0bbi10> skypers: I don't know honestly
15:24:12 <acowley> b0bbi10: This is more appropriate for #haskell-blah
15:24:13 <[swift]_> i'm having trouble figuring out how to combine splices with Heist in my Snap application. does anyone know what i need to do to get this to work? http://lpaste.net/102121
15:24:14 <erisco> SirDarjeeling, fmap f [] = []; fmap f ((k,v):xs) = (k, f v) : fmap f xs
15:24:27 <skypers> b0bbi10: it’s quite simple : Haskell might be something like 1000x Python in runtime speed performance
15:24:30 <skypers> maybe 10000000000000000x
15:24:32 <skypers> for sure.
15:24:41 <skypers> no seriously, Haskell is quite fast now
15:24:45 <erisco> SirDarjeeling, but note that list [] already has a Functor instance, so you'd have to write your own list type (easiest thing is to wrap [] with a newtype)
15:24:49 <skypers> and it does compete with C/C++
15:24:49 <Fuuzetsu> that's a lot of zeros
15:24:55 <b0bbi10> acowley: looks like the right channel, thanks for pointing me there
15:25:00 <erisco> SirDarjeeling, also pairs (a,b) already have Functor (a,)
15:25:10 <skypers> hey
15:25:16 <erisco> > (fmap . fmap) (+1) [("a",1),("b",2)]
15:25:18 <lambdabot>  [("a",2),("b",3)]
15:25:21 <skypers> designing an EDSL with a lam and app is a good idea
15:25:24 <skypers> I never thought of thta
15:25:26 <skypers> that*
15:25:28 <Fuuzetsu> fmap fmap fmap or go home
15:25:32 <[swift]_> the problem is basically that i want to call "I.bindSplices $ I.mapSplices f rs" and the return type of mapSplices doesn't match what bindSplices requires
15:25:45 <skypers> fmap fmap fmap sounds a bit like… hm, ok, nevermind…
15:26:06 <Fuuzetsu> ;P
15:26:09 <skypers> ;)
15:26:13 <mightybyte> [swift]_: Why don't you ask in #snapframework?
15:26:21 <SirDarjeeling> If you want to know about it, I ask because I am currently working with "Learn you a Haskell for a Great Good" and the book asked the user to think about how to implement fmap specifically for Map.Map
15:26:21 <Fuuzetsu> I want the operator for 3x fmap
15:26:24 <Fuuzetsu> an*
15:26:25 <petrie> I have a more noobish quesiton, I am confused as to why div and / are different types?
15:26:28 <[swift]_> mightybyte: that's a good idea; i tried #snap but it didn't exist
15:26:31 <Fuuzetsu> (and not just .:)
15:26:31 <tapuu> Why not (<$>) <$> (<$>)
15:26:39 <skypers> petrie: div is for integral
15:26:44 <skypers> (/) is for Floating
15:26:49 <skypers> Fractional*
15:26:54 <skypers> :t div
15:26:55 <lambdabot> Integral a => a -> a -> a
15:26:59 <skypers> :t (/)
15:27:00 <lambdabot> Fractional a => a -> a -> a
15:27:04 <skypers> just that :)
15:27:07 <Fuuzetsu> (`fmap` (<$>)) fmap
15:27:34 <petrie> hmm
15:27:47 <skypers> :t (.:)
15:27:47 <lambdabot>     Not in scope: `.:'
15:27:48 <lambdabot>     Perhaps you meant one of these:
15:27:48 <lambdabot>       `.' (imported from Data.Function),
15:27:53 <skypers> :t (:.)
15:27:54 <lambdabot>     Not in scope: data constructor `:.'
15:27:54 <lambdabot>     Perhaps you meant one of these:
15:27:54 <lambdabot>       `Seq.:>' (imported from Data.Sequence),
15:28:02 <Fuuzetsu> it's defined uhh, somewhere
15:28:07 <skypers> yeah
15:28:09 <Fuuzetsu> it's just (.) . (.)
15:28:11 <skypers> I’m pretty sure it is
15:28:13 <petrie> Makes sense, thanks
15:28:22 <skypers> no problem petrie :)
15:28:44 <skypers> ok, I’m gonna transform my EDSL GADT with that tagless paper as help
15:28:46 <skypers> sounds nice
15:30:52 <erisco> hm, for three levels of functors it is fmap fmap fmap fmap fmap fmap fmap fmap
15:31:30 <tapuu> I think church numerals would be useful here
15:31:41 <Fuuzetsu> with an operator like <.$.> it could just be (<.$.>) <.$.> (<.$.>) (I think)
15:31:55 <Fuuzetsu> :t let <.$.> = fmap fmap fmap in (<.$.>) <.$.> (<.$.>)
15:31:56 <lambdabot> parse error on input `<.$.>'
15:32:06 <Fuuzetsu> :t let (<.$.>) = fmap fmap fmap in (<.$.>) <.$.> (<.$.>)
15:32:07 <lambdabot> (Functor f, Functor f1, Functor f2) => (a1 -> b) -> (a -> f2 a1) -> f (f1 a) -> f (f1 (f2 b))
15:32:35 <Fuuzetsu> maybe we should just offer a library with these
15:34:08 <skypers> :t fap fap fap fap fap fap fap
15:34:09 <lambdabot> (Functor f, Functor f1, Functor f2) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
15:34:22 <skypers> ok, ok, it was…
15:34:23 <skypers> sorry…
15:34:27 <skypers> couldn’t resiste
15:34:37 <Fuuzetsu> when did you kids define fap
15:34:56 <skypers> sorry, I can barely hear you
15:34:59 <skypers> :D
15:35:00 <jle`> it's a convenient shorthand for fmap
15:35:12 <skypers> yeah
15:35:14 <tapuu> Why not just church 5 fmap
15:35:16 <skypers> > fap length (Just 3)
15:35:17 <lambdabot>  No instance for (GHC.Num.Num [a0]) arising from the literal `3'
15:35:17 <lambdabot>  Possible fix: add an instance declaration for (GHC.Num.Num [a0])
15:35:21 <Fuuzetsu> :t church
15:35:22 <lambdabot> Not in scope: `church'
15:35:27 <Fuuzetsu> ^ that's why
15:35:30 <skypers> > fap show (Just 3)
15:35:32 <lambdabot>  Just "3"
15:35:45 <tapuu> type Church a = (a -> a) -> a -> a
15:35:45 <tapuu> church :: Integer -> Church a
15:35:45 <tapuu> church 0 = \f -> \x -> x
15:35:51 <tapuu> church n = \f -> \x -> f (church (n-1) f x)
15:37:03 <quchen> I have a question about parallel Haskell (Control.Parallel.Strategies). An expression like "list `using` parTraversable rseq" does, when evaluated to WHNF, essentially map "rseq" over the list. The entire thing is then a thunk that evaluates to an ordinary list, implicitly containing/executing all the parallel calls. In particular, everything is still fully lazy, i.e. ⊥ in the list does not create a crash. Correct so far?
15:41:24 <atn34> anyone have an experience using this library? https://github.com/tanakh/Peggy
15:42:23 <acowley> quchen: I think so! (x `using` parTraversable rseq) is a thunk
15:42:43 <quchen> Now suppose I access the first N elements of that list (e.g. `print . take N`). `take` and `print` work element-per-element, so this should really just force the list's head (i.e. throws it in the spark pool, waits for the computation to finish, prints the result). However, this is obviously sequential: the computation is done "in parallel", but only one element at a time, namely the next one requested by "print". So how does the
15:42:43 <quchen> parallel evaluation (that actually happens) work? How does `print . take N` "know" that it should read the next ten elements at a time so everything gets properly put into the spark pool at the same time?
15:43:15 <quchen> Example code: http://lpaste.net/102122
15:43:44 <Fuuzetsu> quchen: MLs might be a better place for this
15:45:12 <quchen> Fuuzetsu: I think I have a misunderstanding of how parallel Haskell (GHC) works here though. I'm not (just) asking conceptually.
15:45:51 <Fuuzetsu> it just seems to me that no one who can answer easily is on to answer right now
15:45:53 <acowley> quchen: I don't understand the question. What is the result of the code you linked?
15:46:24 <quchen> acowley: Same as "print [1..10]", printing one element every 0.1 seconds
15:46:40 <quchen> i.e. when running it it immediately sparks all the computations
15:46:53 <monochrom> is Zhuangzi going to tell us a philosophy joke? :)
15:47:00 <quchen> (instead of one-at-a-time, in which case the n-th list element would come increasingly later)
15:47:40 <monochrom> http://ro-che.info/ccc/09 :)
15:47:55 <acowley> quchen: So I thought the point was that as soon as you force the constructor of the list result of the "using" constructor it fired off the sparks.
15:48:08 <acowley> quchen: Which I thought is what you said initially
15:49:08 <quchen> acowley: Oh, no, I did not mean that. Is that the case? Does using "using" spark everything? In my example code, that would mean that a list element containing "undefined" is sparked, but I don't see an error.
15:49:14 <acowley> It's like a seq-bomb
15:49:33 <quchen> Or does being in the spark pool not necessarily mean that the thunks are evaluated?
15:49:39 <acowley> Yeah, I don't know how it handles bottoms. It's apparently being nice about that.
15:49:45 <quchen> I thought everything in the spark pool is scheduled for eventual evaluation
15:50:04 <acowley> You could add a print or something to delay
15:50:09 <acowley> to see if it prints for undefineds
15:50:47 <quchen> Nope, no undefined
15:51:29 <acowley> That doesn't seem right
15:51:46 <acowley> I guess I should test this, too
15:52:13 <quchen> http://lpaste.net/102122
15:52:20 <quchen> acowley: ^ see annotation
15:56:06 <quchen> Maybe we should rule out the unsafePerformIO and replace it with an actually long computation.
15:56:16 <quchen> For example  delay () = foldl' (+) 0 [1..10^8]
15:56:32 <acowley> quchen: WHen I run your example, the numbers print out slower and slower
15:56:34 <johnw> you'd need to force the result oto
15:56:39 <acowley> which suggests that unsafePerformIO isn't playing nice
15:57:03 <acowley> Ew
15:57:15 <acowley> It's different with threaded or not threaded
15:57:17 <quchen> acowley: Oh? Hmm. Compilation settings maybe?
15:58:01 <quchen> I'm on 7.6.3; not sure whether that matters
15:58:06 <acowley> Me, too
15:58:16 <acowley> But I would have expected it to perform the same on threaded and non-threaded
15:59:41 <acowley> Yeah
15:59:54 <acowley> If you just write this normally, it behaves the same with both RTSes
16:01:56 <acowley> What I mean by that, is that if you forkIO a bunch of threadDelays, they run concurrently even in the non-threaded runtime
16:03:48 <acowley> Huh, it's neat how it works out.
16:04:02 <acowley> I guess parallel is nop in the non-threaded runtime
16:04:06 <ij> I'd like to map Data.Tree's from each node,path tuple. I'll have to write my own code, any equivalents?
16:04:37 <quchen> acowley: forkIO is different though, it performs an IO action that runs on its own even when not forced.
16:04:56 <quchen> The question I really have here is in "par" code, when does evaluation actually happen?
16:05:10 <quchen> What starts the evaluation? What exactly is in the spark pool?
16:06:20 <jle`> are there any good libraries for graphs in haskell?
16:06:28 <jle`> is the containers Data.Graph any good?
16:06:35 <jle`> i've never seen people use it actaully
16:06:38 <quchen> It's fairly basic.
16:07:03 <jle`> is there a robust one people more often use?
16:07:16 <quchen> FGL?
16:07:22 <quchen> Haven't used it much though.
16:07:41 <jle`> quchen: thanks, i've heard that mentioned somewhere else too; i'll look into it probably
16:07:45 <heatsink> FGL is pretty easy to use and has a comprehensive set of basic graph algorithms
16:08:39 <jle`> ty
16:08:42 <heatsink> Sometimes you want efficient graph mutation, and I don't know of a good library for that
16:09:31 <jle`> i don't need graph mutation, just efficient building, access, traversals
16:11:03 <acowley> Oh
16:12:23 <acowley> quchen: this example is problematic
16:12:29 <acowley> The RTS is not magic
16:12:46 <acowley> It is sparking the undefined, but raising an exception before it does anything
16:12:52 <acowley> you can see it as "fizzled" with -s
16:13:20 <acowley> and if you change the test to increment a global counter or something, you see 11 sparks go
16:13:27 <acowley> So I think it is as I said before
16:13:40 <merijn> acowley: Eh, threadDelays don't "run concurrently even in non-threaded", threadDelay explicitly unschedules the thread until a time in the future, that's not the same as running concurrently
16:13:52 <acowley> In this case, take evaluates the list to WHNF, which sparks all elements
16:14:17 <quchen> acowley: Oh, so "*par" automatically evaluates to WHNF then
16:14:19 <heatsink> I tried replacing undefined with a nonterminating loop.  It still runs quickly
16:14:34 <quchen> In other words, everything in `runEval` is sparked and run as soon as the Eval is unpacked
16:14:38 <heatsink> Wouldn't the nonterminating loop consume processor time after it's sparked?
16:14:55 <acowley> heatsink: Run with +RTS -s to see what it says about converted sparks
16:15:01 <merijn> heatsink: Yes, but GHC uses preemptive threads
16:15:24 <merijn> heatsink: Unless I misunderstand your question
16:15:56 <heatsink> I see.  My nonterminating loops were actually terminating.  with a stack overflow.
16:16:00 <acowley> hah
16:16:47 <quchen> foldl' (+) 0 (cycle [0,1])
16:16:56 <quchen> s/0/-1/
16:17:00 <acowley> quchen: right
16:17:58 <petrie> Would somone mind looking at my horribly written code and given some insight? on my variance function.
16:18:05 <petrie> http://pastebin.com/ATJST384
16:18:05 <petrie> :)
16:18:23 <quchen> Don't use genericLength, it's awful
16:18:40 <quchen> length, or `fromIntegral . length` if you need Integer, is *much* more efficient
16:19:01 <Fuuzetsu> why is genericLength not fromIntegral . length?
16:19:18 <quchen> Fuuzetsu: To work with lazy nats
16:19:37 <quchen> length traverses the entire spine to get a result, genericLength is lazy
16:19:37 <petrie> Ah, didnt know that thanks
16:19:50 <quchen> genericLength is literally "1 + tail"
16:19:56 <quchen> genericLength tail, that is
16:20:27 <Fuuzetsu> and length is?
16:20:52 <jle`> @src length
16:20:52 <lambdabot> Source not found. My pet ferret can type better than you!
16:21:06 <quchen> length = go 0 where go n [] = n; go n (_:xs) = go (n+1) xs   -- That, plus strictness and unboxing
16:21:21 <Fuuzetsu> I see
16:22:05 <quchen> petrie: It's fine to use infix operators, "m - foldl ..." in line 14
16:22:21 <quchen> Also, don't use foldl unless you have a very good reason to. Usually you want foldl'.
16:22:32 <quchen> Or foldr or whatever else. Just not foldl.
16:22:36 <heatsink> Doesn't line 14 translate to (\x -> x - m foldl' ...) ?
16:22:36 <Zhuangzi> genericLength can be used to return the length of an infinite list and then test, e.g. length [1..] /= 0, because (S …) /= Z.
16:23:19 <petrie> Oh
16:24:14 <quchen> What you want here is sum' = foldl' (+) 0
16:24:45 <Zhuangzi> If you think you have a good reason to use foldl, you're probably up past your bed time.
16:25:19 <quchen> If your accumulator is a tuple, foldl is not wrong, for example.
16:25:20 <petrie> I honestly didnt know to much about the difference, only my third day learning this :)
16:25:55 <quchen> petrie: In that case don't worry about it too much, but keep it in the back of your head: foldl is bad, and when it's time read about foldl'.
16:26:06 <quchen> It's a little early to worry about it on the third day.
16:26:11 <petrie> Will do, appreciate it
16:27:02 <quchen> RWH has an example chapter including foldl and strictness. That was my first exposure to it.
16:27:13 * Zhuangzi buttons petrie's jacket and licks thumb and wipes petrie's cheek in a motherly way. Now you go get 'em!
16:27:30 <petrie> Lol
16:27:51 <petrie> Ah yeah, I just got that book
16:28:02 <jle`> petrie: hm. hy are you realToFracing?
16:28:09 <jle`> why do you want a Real?
16:28:44 <petrie> jle`: I originally had it as "let findMean x = (sum x) / (genericLength x) but it wanted fractional?
16:28:47 <petrie> iirc
16:29:35 <jle`> i think you can just do sum x / fromIntegral (length x)
16:29:52 <jle`> and you'd have findMean :: Fractional a => [a] -> a
16:29:54 <petrie> I am passing it a list like "let mylist = [1,2,3,4]"
16:30:08 <jle`> yeah, that shouldn't be a problem?
16:30:46 <petrie> No instance for (Fractional Integer) arising from a use of `findMean'
16:31:38 <merijn> petrie: Right, cause Integer's aren't fractional and "let mylist = [1,2,3,4]" is probably getting hit by the Dread Monomorphism Restriction
16:31:41 <merijn> @where dmr
16:31:41 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
16:32:24 <jle`> that's weird because it should infer that mylist is a list of fractionals
16:32:29 <jle`> unles you're doing it in ghci
16:32:39 <jle`> in which case you should probably enable dmr on ghci by default
16:33:01 <petrie> I always test everything in ghci before I write it in a file usually
16:34:17 <athan> good god I hate my job
16:34:35 <athan> waste time in a pleasant way, and nobody bats an eye
16:34:48 <athan> try and learn haskell on downtime, and everyone looses their minds!
16:35:08 <Fuuzetsu> can't be having that functional garbage in a workplace
16:35:12 <fooozbaz> hello! is it possible to derive a Read instance on a GADT which makes use of phantom types? http://lpaste.net/102125
16:35:16 <athan> I don't suppose there's a combinator for improving your job, is there? :)
16:35:22 <Fuuzetsu> next thing you know you'll be writing unreadable burritos in the codebaase
16:35:33 <Fuuzetsu> athan: unsafeCoerce
16:35:39 <athan> hahahaha
16:35:42 <petrie> oh wow
16:35:57 <petrie> switching it off let that work
16:36:16 <shachaf> fooozbaz: That's not very phantom.
16:36:51 <fooozbaz> shachaf: it's not?
16:38:05 <shachaf> I would say a type F is phantom in its argument when you can write coerce :: F a -> F b
16:38:16 <shachaf> Maybe with laws like coerce = id, coerce . coerce = coerce
16:38:17 <fooozbaz> shachaf: regardless of whether it's phantom, do you know how to make that read instance work?
16:38:32 <shachaf> Anyway, what kind of instance are you hoping for?
16:38:39 <shachaf> I don't think you'll be able to make GHC autogenerate it.
16:38:51 <acowley> fooozbaz: I don't think there's a happy way around this
16:39:00 <acowley> fooozbaz: I hit it all the time, too
16:39:27 <fooozbaz> acowley: hm.. is there an unhappy way?
16:39:41 <acowley> fooozbaz: You write an instance for each index
16:39:53 <shachaf> Can you write the instance you would want by hand first?
16:41:33 <fooozbaz> acowley: i'm not sure i follow.. how can i have multiple instances of Read for one type?
16:41:42 <acowley> They're different types
16:41:49 <acowley> Foo Int and Foo String
16:42:33 <davesq> as someone new to testing in haskell, should I start out with tasty or hspec? (or something else?)
16:42:53 <petrie> So would that be deemed bad practice to use the nomonomorphism pragma in your programs? or is it just under certain circumstances when/why to not use it?
16:43:25 <jle`> petrie: monomorphism restriction will probably help you more than hurt you in actual source code
16:43:31 <jle`> turning it off is more likely to hurt you than help you
16:43:33 <jle`> imo
16:43:35 <shachaf> The monomorphism restriction is controversial, and some people like to turn it off.
16:43:40 <shachaf> Particularly in ghci.
16:43:45 <jle`> at least, once you know what kind of errors it gives you
16:43:48 <athan> davesq: QuickCheck will give you some insight
16:43:49 <jle`> and those errors tend to be obvious-ish
16:43:57 <jle`> but yes in ghci it should really be off by default
16:44:08 <jle`> it's off by default in 7.8
16:44:08 <petrie> Ah, hmm ok
16:44:11 <shachaf> You can read the motivation for it and come to your own conclusions.
16:44:15 <athan> davesq: If you're looking for the philosophy comparison between frameworks, you should learn it's underpinnings
16:44:24 <jle`> you can change default settings using ~/.ghci
16:44:26 <shachaf> You have to watch out for unshared polymorphic values if you turn it off.
16:44:27 <athan> davesq: I myself like hspec though :)
16:44:46 <davesq> athan: don't people generally run quickcheck via test-framework or hspec or tasty?
16:45:08 <petrie> thanks jle`
16:45:12 <jle`> i think the 'downsides' of having dmr off are silent...but the 'downsides' when having it on are explicit and in your face and fail fast.  but as shachaf said you should decide for yourself
16:45:25 <jle`> i can't claim to represent everyone
16:45:48 <acowley> You could
16:47:39 <athan> davesq: Yes, that's right, but I feel like you might gain more insight as to _why_ it's used. But anyway, if you're new to haskell and familiar with rSpec, you'll fit right in. However, I think I should look further into tasty - it looks like a really good project!
16:48:03 <davesq> athan: righto, thanks
16:48:33 <athan> but yeah, these frameworks automate a lot and give you design solutions around the testing, however, I still believe that you should see how quickcheck improves on normal TDD paradigms
16:48:52 <athan> and I think it has something to do with getting closer to "equational reasoning" :)
16:49:03 <athan> something I really really really want to get down right
16:51:25 <athan> but I'm also an idiot, so there's that :p
16:56:33 <davesq> athan: i love the little i've seen of quickcheck. at the moment need something to shove in my cabal file to test a couple of properties. i think i'll try out quickcheck via tasty and see how i go
16:57:23 <erisco> is it reasonable to use Producer to represent a future value? ie there will only be one value yielded
16:57:47 <athan> davesq: If I see you again, I'll ask!
16:59:51 <ij> I've got some regexp questions. How can I get Text.Regex.TDFA and =~~ to match multiple results from one line? And is \d a perl regexp feature?
17:00:06 <athan> I really want to see the logic behind property testing, but in the context of linear algebraic maps (from what I can see, a huge influence of haskell)
17:00:21 <coconnor> I think smallcheck is a bit more approachable than quickcheck. Though my experience was before the new quickcheck release.
17:01:14 <athan> coconnor: I'll have to check that out! What are the differences, mainly?
17:10:09 <acowley> My kingdom for a useful Nat kind
17:10:28 <jle`> the whole kingdom?
17:10:42 <shachaf> {-# LANGUAGE DataKinds #-}; data Nat = Z | S Nat
17:11:46 <acowley> I want a little bit more equality
17:11:58 <acowley> e.g x + 0 = 0 + x
17:12:05 <acowley> s/=/~
17:12:20 <ij> Why does this happen? Why don't two get returned? http://sprunge.us/jNgi
17:13:01 <Eduard_Munteanu> acowley: you can make a type family for that
17:13:30 <Eduard_Munteanu> acowley: as long as you don't rely on the GHC literals.
17:13:43 <haasn> acowley: looks like that actually holds, for GHC's Nat
17:13:46 <acowley> Eduard_Munteanu: I don't follow the tf
17:13:52 <acowley> haasn: That's my point
17:13:55 <haasn> ah
17:13:59 <acowley> haasn: TypeLits does that
17:14:02 <haasn> yes
17:14:12 <acowley> but then I can't so easily define things for TypeLits Nat
17:14:20 <Eduard_Munteanu> Which GHC, 7.6 or 7.8?
17:14:23 <acowley> 7.6.3
17:14:40 <duairc> Is there any way to see the code that GHC generated for derived instances?
17:14:42 <acowley> It's nice to define type families with Peano like shachaf showed
17:14:48 <Eduard_Munteanu> 7.6's Nat addition doesn't reduce at all.
17:14:56 <acowley> But then if you want a few facts about naturals, you're out of luck
17:15:17 <acowley> Oh really? Huh. I'm using my own peano, but I thought TypeLits could do +0 and 0+
17:15:42 <athan> Are there practical uses for peano's and Nat?
17:15:59 <Eduard_Munteanu> acowley: it defines (+) and such but they're only type families with no instances, and the compiler doesn't reduce them at all (which is planned for 7.8 IIRC).
17:16:03 <athan> I'm just wondering outside of the intellectual challenge :)
17:16:29 <Eduard_Munteanu> athan: yes, quite a few, e.g. length-indexed lists.
17:16:31 <jle`> duairc: there's a compiler flag
17:16:35 <jle`> i think
17:16:54 <jle`> -ddump-deriv
17:16:59 <jle`> not sure how useful it is though
17:17:10 <Eduard_Munteanu> acowley: what I meant earlier was that you can define your own naturals and implement addition.
17:17:28 <acowley> Eduard_Munteanu: Yes, but you have to pick an operand to recurse on
17:17:41 <acowley> Eduard_Munteanu: Which leaves you with these annoying issues with zero
17:17:48 <duairc> jle`: Thanks, I'll look into that!
17:18:19 <jle`> duairc: i've been able to inspect some Show instances, but...remember that it wasn't meant for human reading :)
17:18:41 <Eduard_Munteanu> acowley: that happens in Agda too, but you can prove 0 + n == n + 0, I think you can do the same here.
17:18:55 <athan> Eduard_Munteanu: Interesting!!
17:19:06 <acowley> Eduard_Munteanu: I know how to do it in Agda, Idris, or Coq.
17:19:21 <athan> I've got a really general question for you guys... that might spark some fights....
17:19:21 <Eduard_Munteanu> (well, not just an equality proof)
17:19:35 <athan> ....what is the key to understanding haskell?
17:19:54 <Eduard_Munteanu> acowley: in fact, for *specific* naturals you don't have to do anything, I think.
17:19:55 <athan> and all this functional awesomeness?
17:20:06 <acowley> You're right, btw, that 7.6.3 won't simplify the addition of zeros with TypeLits.
17:20:07 <athan> erm, mastering haskell
17:20:11 <athan> what's the key to mastering haskell?
17:20:16 <hpc> athan: you have to beat the final monad boss, and it unlocks the lambda cube
17:21:26 <athan> hpc: Is it's instance undecidable?
17:21:30 <athan> lol
17:23:25 <athan> hpc: seriously, though, what was the most profound realization you had when learning this stuff?
17:26:37 <hpc> it's all fairly ordinary if you learn things in the right order
17:26:46 <hpc> (the right order being, introduce one new concept at a time)
17:26:49 <heatsink> athan: Maybe, that it's important to reason about things algebraically
17:27:09 <heatsink> That's not really one idea though
17:27:22 <jle`> athan: there's no secret, everything is sorta just incremental
17:27:28 <jle`> just take it one step at a time
17:27:29 <tristan__> can I do a hook in cabal of some sort if i want to convert a bunch of files with pandoc post compiling the project
17:27:37 <jle`> i remember when i was first learning math
17:27:38 <greg`> so did everyone read the article about foldl being broken
17:27:43 <jle`> i spent an entire year learning how to add!
17:27:46 <jle`> baby steps.
17:27:47 <heatsink> tristan__, there is a postbuild hook
17:28:01 <heatsink> It runs after the normal build steps
17:28:19 <athan> hahaha! jle`, hpc, heatsink, thank you :)
17:28:23 <heatsink> You can also modify the build hook to run your stuff after the normal build steps
17:28:39 <athan> Soon enough I'll be confident in my understanding and ability
17:28:43 <tristan__> heatsink: sweet, thanks. do you know of examples/docs of that?
17:29:22 <jle`> you should be happy knowing that you might never be :)
17:29:23 <heatsink> tristan__: http://www.haskell.org/cabal/release/cabal-latest/doc/API/Cabal/Distribution-Simple-UserHooks.html
17:30:05 <tristan__> yea, I looked at that, [String] wasn't very clear as an argument :)
17:30:32 <heatsink> Where is [String]?
17:30:40 <tristan__> Args
17:30:53 <heatsink> oh
17:30:57 <heatsink> why do you want args?
17:31:12 <tristan__> oh wait, is that just what args are sent to the cabal run?
17:31:23 <heatsink> Something like that
17:31:44 <tristan__> I just don't see how from this I define a hook in my cabal config
17:32:05 <heatsink> Oh, that doesn't go in the .cabal file.  It goes in Setup.hs
17:32:17 <athan> sorry to interject, but what are the different kinds of church encodings?
17:32:31 <tristan__> heatsink: aaaah
17:32:35 <heatsink> Call defaultMainWithHooks and pass it your hooks
17:32:39 <athan> I know there are sum and product combinations that haskell uses to represent GADT's
17:32:51 <heatsink> you can create the hooks by modifying simpleUserHooks
17:33:02 <athan> I'm just wondering how you can begin to analyze how prosperous the type system would be
17:33:18 <tristan__> heatsink: ok, cool makes more sense now
17:33:24 <athan> or really, what other methods of encoding there are, too
17:33:26 <heatsink> I hear that evangelical church encodings are more prosperous
17:33:36 <athan> hmm!!
17:33:56 <athan> how do they relate to \-calc?
17:34:00 <athan> specifically
17:34:13 <athan> are they just meant to represent types?
17:34:26 <athan> For some reason, I have a feeling that the encoding itself is a \-calc as well
17:34:28 <heatsink> traditionally, lambda calculus doesn't have constructed data or case expressions
17:34:51 <athan> hmm, by case expressions you also include pattern matching?
17:34:51 <heatsink> instead, those are represented by functions via some encoding.  Church encodings are one choice.
17:34:54 <heatsink> yes
17:35:01 <athan> it's purely polymorphic?
17:35:16 <athan> And you analyze the types of reductions, and knots that happen in expressions, correct?
17:35:16 <heatsink> what is?
17:35:32 <athan> traditional lambda calculus
17:35:43 <athan> Oh woah!!!
17:35:56 <heatsink> There are different formulations of lambda calculus
17:36:02 <heatsink> @where TAPL
17:36:02 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
17:36:22 <athan> O.O
17:36:28 <heatsink> There's a whole book about lambda calculi with different type systems!
17:36:39 <athan> OH HELLLS YES
17:36:39 <heatsink> And it has a sequel!
17:36:43 <athan> THANK YOU!!!!!!!!
17:38:35 <athan> I'm gonna go so hard on this book
17:38:41 <athan> I've actually been looking at it for a while
17:39:11 <heatsink> I wish there were a full copy online
17:39:16 <athan> I've been trying to analyze a lot of M.P.Jones' research, and my lack of understanding has been pointing to this book
17:39:20 <athan> right
17:39:29 <athan> I'd gladly fork over like
17:39:32 <athan> even $200 for this
17:39:44 <athan> as a broke mofo- i mean
17:39:52 <heatsink> Fortunately it's not that expensive
17:42:44 <athan> right haha
17:42:47 <athan> I can't wait
17:42:50 <athan> I'm literally drooling
17:42:52 <athan> like actually
17:49:01 <newsham> > (map(" !#ADFHaehikloprsy"`genericIndex`).unfoldr(ap((>>).guard.(0/=))(return.swap.(`divMod`18)))) 77615356229227481219074853389594637052
17:49:02 <lambdabot>  "Happy April Fools Day #haskell!"
17:49:28 <tristan__> heatsink: hm, seems Setup.hs doesn't run in my cabal sandbox. am I suppose to be able to run it with cabal and not 'runhaskell Setup.hs'
17:49:39 <jfischof1> what should I use to convert a Int into a ascii ByteString?
17:50:54 <jle`> jfischof1: maybe you can use fromIntegral to turn it into a Word8?
17:51:20 * hackagebot ipcvar 0.0.1 - Simple inter-process communication through IPCVars.  http://hackage.haskell.org/package/ipcvar-0.0.1 (JohnWiegley)
17:51:37 <jfischof1> No I want 128 to be the 3 character ByteString "128"
17:51:50 <jfischof1> I want show, for ByteString
17:51:59 <nh2> how would I best add a ghci-like prompt to my continuously running opengl application? I would like to have my game state (some IORefs) in scope and conveniently change them at runtime
17:52:02 <athan> holy crap newsham
17:52:22 <jfischof1> I'm just not sure what is the hip way to do that (obviously ascii is not hip)
17:52:35 <heatsink> tristan__: I think you have to run Setup.hs.  The command line arguments are the same as cabal.
17:52:52 <newsham> > BS.pack $ show 128
17:52:53 <lambdabot>  Couldn't match type `GHC.Types.Char' with `GHC.Word.Word8'
17:52:54 <lambdabot>  Expected type: [GHC.Word.Word8]
17:52:54 <lambdabot>    Actual type: GHC.Base.String
17:53:12 <newsham> > BS.pack $ map fromIntegral $ show 128
17:53:14 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Char)
17:53:14 <lambdabot>    arising from a use of `GHC.Real.fromIntegral'
17:53:14 <lambdabot>  Possible fix:
17:53:14 <lambdabot>    add an instance declaration for (GHC.Real.Integral GHC.Types.Char)
17:53:29 <newsham> > BS.pack $ map (toEnum.fromEnum) $ show 128
17:53:30 <lambdabot>  "128"
17:53:38 <athan> lol
17:53:58 <tristan__> heatsink: well cabal works on the sandbox, doing runhaskell Setup.hs isn't
17:54:05 <athan> you need the ambiguity that toEnum.fromEnum makes in the type system?
17:54:16 <jfischof1> newsham: going to Char first seems inefficent
17:54:38 <jle`> athan: not too ambiguous actually, it's all fixed at compile time
17:54:48 <newsham> how efficient do you need your number to bytestring serialization to be?
17:54:50 <jle`> jfischof1: hm. maybe you can use a Text show, and encode the Text?
17:54:56 <heatsink> Hmm, I don't know why that happens
17:55:30 <jfischof1> newsham: I don't now. I thought there might be something double-conversion for Int
17:55:34 <athan> jle` I can see that it needs to resolve at compile time, but the tools used before hand are generally made ambiguously, so that the resolution _can_ happen at compile time, right?
17:55:36 <jfischof1> s/now/know
17:56:01 <newsham> ?hoogle fromString
17:56:01 <heatsink> tristan__: Actually, I think 'cabal' will run Setup.hs.  I was remembering an unrelated problem I had with cabal.
17:56:01 <lambdabot> Data.String fromString :: IsString a => String -> a
17:56:02 <lambdabot> GHC.Exts fromString :: IsString a => String -> a
17:56:02 <lambdabot> Data.Text.Lazy.Builder fromString :: String -> Builder
17:56:31 <newsham> > fromString (show 128) :: BS.ByteString
17:56:32 <lambdabot>  Not in scope: `fromString'
17:56:32 <lambdabot>  Perhaps you meant one of these:
17:56:32 <lambdabot>    `BSLC.fromStrict' (imported from Data.ByteString.Lazy.Char8),
17:56:32 <lambdabot>    `showString' (imported from Prelude)
17:56:42 <athan> WOAH
17:57:04 <athan> sorry, fromStrict threw me off :P
17:57:22 <newsham> > Data.String.fromString (show 128) :: BS.ByteString
17:57:23 <lambdabot>  Not in scope: `Data.String.fromString'
17:57:41 <tristan__> heatsink: ah ok, thought so, but quick test hook I threw together didn't work so wanted to make sure
17:57:51 <athan> newsham: That's my current frustration with lambdabot .-.
17:57:53 <erisco> > (map(" !#ADFHaehikloprsy"`genericIndex`).unfoldr(ap((>>).guard.(0/=))(return.swap.(`divMod`18)))) 3328278
17:57:55 <lambdabot>  "Hello!"
17:58:36 <jle`> newsham: i don't think ByteString is an IsString
17:58:50 <athan> i agree
17:59:04 <athan> it's just an array of bytes, isn't it?
17:59:16 <athan> The encoding isn't defined, and too ambiguous
17:59:17 <newsham> > (map("[' ', '!', 'H', 'c', 'e', 'i', 'l', 'o', 'r', 's']"`genericIndex`).unfoldr(ap((>>).guard.(0/=))(return.swap.(`divMod`10))))1739584076642
17:59:18 <lambdabot>  " ,''![,' ,'!'"
17:59:26 <newsham> oopz!
17:59:30 <athan> I know Unicode has a ByteString -> Text converter
17:59:33 <athan> encoder / decoder
17:59:41 <athan> haha
17:59:43 <newsham> > (map(" !Hceilors"`genericIndex`).unfoldr(ap((>>).guard.(0/=))(return.swap.(`divMod`10))))1739584076642
17:59:44 <lambdabot>  "Hello erisco!"
18:00:31 <newsham> jle: isnt ByteString.Char8 a IsString though?
18:01:00 <erisco> newsham, is this form of compression actually used?
18:01:01 <newsham> what about ByteString.UTF8 ?
18:01:14 <jle`> newsham: yeah, Char8 is an IsString
18:01:21 <newsham> erisco: for some values of N its quite common.. ie 16 and 64 :)
18:01:41 <shachaf> .Char8 and .UTF8 are modules, not types.
18:01:46 <shachaf> There is only one ByteString type.
18:02:07 <jle`> oh, they don't export different types? they export instances?
18:02:13 <newsham> ?instances IsString
18:02:14 <lambdabot> Couldn't find class `IsString'. Try @instances-importing
18:02:24 <jle`> but there's ByteString and ByteString.Lazy, and those are different types, right?
18:02:38 <shachaf> .Char8 is usually evil and the wrong thing to use. Unfortunately IsString ByteString can only have one instance.
18:02:42 <dolio> Yes, normal and lazy are different types.
18:03:23 <dolio> But the .Char8 stuff is just different functions on them.
18:04:35 <erisco> are pipes used with finite streams or are they more typical for infinite streams? it seems somewhat roundabout to signal termination
18:05:04 <athan> they can be used with finite ones
18:05:19 <athan> check out the haskell cast comparing conduits and pipes with their respective creators
18:05:24 <athan> it's actually really awesome
18:05:35 <athan> they talk about how the termination / leftover cases are handles, etc.
18:05:48 <erisco> anything written?
18:06:03 <athan> erisco: Hmmm, probably. Not that I know of, though.
18:06:33 <athan> I know that conduits are really good at resource management
18:06:45 <athan> freeing file descriptors and such
18:07:16 <SrPx_> I've been wondering, what is the simplest total system in which you can define a tree top-down transformer algorithm?
18:07:41 <johnw> erisco: pipes can be used with either
18:07:43 <erisco> it seems that to signal termination you either have to write a monad transformer (and pass the signal behind the scenes) or clutter the yield value 'a' as 'Maybe a' where 'Nothing' signals the termination
18:07:56 <johnw> right, I think that's true
18:08:07 <johnw> conduit signals termination through a Maybe, pipes does not
18:08:22 <erisco> how does pipes do it?
18:08:52 <johnw> see http://hackage.haskell.org/package/pipes-2.1.0/docs/Control-Pipe-Tutorial.html#g:6
18:09:09 <erisco> I am reading it now and must have missed the section that explained how
18:09:23 <johnw> i don't know, I don't use pipes
18:11:23 * hackagebot hexpat-lens 0.1.0 - Lenses for Hexpat.  http://hackage.haskell.org/package/hexpat-lens-0.1.0 (JosephAbrahamson)
18:13:06 <tristan__> heatsink: aaaah, I had 'Build-type: Simple' in my cabal config :)
18:13:08 <Twey> SrPx_: A system in which the only recursion principle is tree recursion
18:13:37 <SrPx_> Twey: uh huh, but how'd that work formally?
18:14:00 <Twey> SrPx_: Depends on your notion of ‘tree’.  And ‘simplest’.
18:15:11 <SrPx_> Twey: I've been thinking something like the simply typed lambda calculus with only a Tree type, but I'm not sure how to introduce recursion without making it turing complete...
18:15:29 <Twey> Actually, you don't even need the whole recursion principle, just the tree map
18:16:12 <Twey> SrPx_: Only general recursion is Turing-complete.  You can have recursion over arbitrary datatypes without breaking totality
18:16:25 <Twey> SrPx_: So long as the data you're recursing over is finite
18:16:51 <SrPx_> Twey: so you suggest I just introduce a primitive such as "topDown"?
18:17:22 <Twey> Sure, that's probably the ‘simplest’ possibility
18:17:50 <SrPx_> Twey: but not the better?
18:18:36 <SrPx_> Twey: also, it is possible to encode any data structure other than cyclic graphs with tree, correct? So pretty much any practical algorithm could be encoded in such language?
18:19:30 <Twey> SrPx_: Well, my first instinct is to use a language with Π-types and W-types, which are a more general notion of ‘function’ and ‘tree’ respectively
18:19:58 <Twey> SrPx_: It gives you expressive power equivalent to Agda, yes (with W-types; maybe not with simply-typed trees)
18:21:11 <athan> SrPx_ Would turing completeness be something to avoid, or attain in a type system?
18:21:30 <SrPx_> athan: pardon?
18:21:37 <athan> nevermind
18:21:38 <athan> haha
18:21:38 <SrPx_> Twey: thanks, googling those now!
18:22:00 <athan> what is "totality"?
18:22:02 <dwcook> athan, it's seen by some as disadvantageous because they believe compilation should be guaranteed to terminate.
18:22:04 <SrPx_> athan: I'm new to haskell, sorry !
18:22:12 <Twey> athan: It's usually considered a bad thing. People don't like their typecheckers to loop infinitely, and Turing-completeness in the term language makes the type system inconsistent
18:22:19 <athan> dwcook: precisely my intuition
18:22:49 <athan> Twey: Very good! Thank you!
18:22:52 <Twey> athan: Totality is the property of a language that says that all programs expressible in that language must (eventually) terminate
18:23:03 <athan> Ahhhhhh!!!
18:23:11 <athan> Now that is something to reason about!
18:23:17 <athan> (chuckle)
18:23:21 <dwcook> Totality rocks
18:23:26 <Twey> athan: For example, Haskell's type system is inconsistent: the term ‘let x = x in x’ can be assigned any type you want, so it's not useful for theorem-proving
18:23:52 <athan> hmmm
18:23:58 <Twey> Of course, that's not necessarily a problem in practice: we tend to just assume people only pass terminating (or at least productive) terms around
18:24:04 <dwcook> Wait, I know how to get Haskell to stop being non-total. I'll just tell it to fix the error, like so
18:24:07 <dwcook> > fix error
18:24:08 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
18:24:21 <Twey> But it breaks your language for theorem-proving, since you can now ‘prove’ any proposition
18:24:24 <Twey> dwcook: Haha
18:24:33 <athan> aha!
18:24:40 <athan> very interesting design decisions
18:24:47 <athan> does adga always terminate?
18:24:48 <athan> er
18:24:58 <athan> expressions in adga I mean?
18:25:06 <SrPx_> oh by the way, is there any total language (could be dependently typed) with a simple open specification such as R5RS? I guess Agda, Idris and CoQ don't have an open spec?
18:25:07 <Twey> athan: Haskell also avoids the non-terminating typechecker problem by having distinct term and type languages
18:25:10 <dwcook> The word you want is "evaluation"
18:25:31 <athan> dwcook: HA!
18:25:32 <Twey> The type language is (as far as I know) total, though I think there are some GHC extensions that break totality
18:25:39 <athan> dwcook: Oh, okay
18:25:40 <Twey> athan: Yes
18:26:10 <SrPx_> Twey: the type system? I don't think so, I've seen people hacking LC into it a few times already?
18:26:19 <Fuuzetsu> with extensions
18:26:22 <athan> hmm!
18:26:34 <jle`> i wonder if dcoutts's foldl proposal is an april fool's joke
18:26:43 <SrPx_> jle`: where
18:26:52 <jle`> on the top of /r/haskell
18:26:54 <jle`> on reddit
18:27:49 <SrPx_> jle`: oh why I feel like that is an indirect answer to my thread last week
18:28:01 <jle`> yeah, i do too
18:28:03 <jle`> i remember your thread
18:28:20 <dwcook> The foldl thing seemed reasonable to me, though I can't say I scrutinized it heavily
18:28:26 <michaelt> erisco: the whole pipeline p >-> q >-> r terminates if any pipe terminates. If you want to know in advance whether what you're getting is the last chunk, there are various devices, e.g. with the function next, or the Maybe trick, or etc
18:28:28 <jle`> yeah, but considering the day
18:28:31 <jle`> i am suspicious of everyhting :)
18:28:36 <athan> so because Haskell... bifricates recursion into the type system and termination system, you can be caught in a non-terminating evaluation, because types can be mutually recursive?
18:28:49 <Twey> jle`: I think this is serious
18:29:09 <dwcook> athan, you don't get unrestricted recursion in types, just values
18:29:10 <Twey> athan: I don't understand your question
18:29:11 <erisco> michaelt, how do you terminate the pipe/producer?
18:29:50 <michaelt> erisco:  each [1,2,3,4,5] >-> P.print terminates with printing 5
18:29:59 <Twey> athan: Haskell has a type language and a term language.  The term language is potentially non-terminating (it's Turing-complete); the type language is simply not powerful enough to express potentially non-terminating computations, modulo GHC extensions
18:30:14 <dwcook> :t let f g = g g in f
18:30:15 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
18:30:15 <lambdabot>     In the first argument of `g', namely `g'
18:30:15 <lambdabot>     In the expression: g g
18:30:19 <athan> dwcook: because expressions can only be of kind *? (as the root cause of it all)?
18:30:34 <erisco> michaelt, but how is the termination signalled?
18:30:36 <athan> ah!
18:30:44 <athan> Twey: Great, thank you!
18:30:55 <erisco> michaelt, ie what prevents the consumers indefinitely blocking by awaiting a value?
18:31:00 <dwcook> athan, that's not the reason. You can still imagine an infinite type :: *.
18:31:13 <SrPx_> Twey: just wondering, why do we need 2 languages? Would it be possible to have only one language for both the type level and the value level?
18:31:24 <dwcook> For an example, [[[…]]] would be * if it existed
18:31:26 <Twey> athan: No, that's irrelevant.  Type expressions can have higher kinds than ★; it's just that ★ is (by definition) the kind of types that can be inhabited by terms
18:31:33 <Twey> SrPx_: Yes.  Agda does this, for example.
18:31:57 <athan> hmm!
18:32:11 <michaelt> erisco: P.print will print infinitely many values if it can get them, but if you link it to the producer 'each [1..5]', it terminates when the producer terminates
18:32:18 <athan> so what differentiates unrestricted and restricted recursion?
18:32:19 <athan> context?
18:32:20 <Twey> SrPx_: But then you need an explicit termination check if you want to keep your type-checker total.  Agda's terminating everywhere, so that's not a problem; if we were to do this for Haskell, you'd probably want a restriction that you can only use terminating functions on the type level, or something.
18:32:38 <Twey> SrPx_: (or a weak term language)
18:32:39 <erisco> michaelt, that's fine but how do I write a producer that terminates?
18:32:55 <michaelt> well, each [1..5] terminates
18:33:12 <Twey> athan: Well, unrestricted recursion has no restrictions placed on it, and restricted recursion has restrictions :þ
18:33:14 <erisco> how do I write a producer that uses 'yield' that terminates?
18:33:27 <michaelt> if you are producing while some condition obtains then when it doesn't obtain write 'return ()'
18:33:28 <athan> haa
18:33:40 <athan> time to learn adga
18:33:54 <Twey> athan: A common restriction is that ‘recursive calls to a function must have at least one argument that is a subexpression of the original argument’, for example
18:34:15 <athan> aha!!!
18:34:17 <erisco> michaelt, okay thanks
18:34:30 <Twey> athan: So f (x : xs) = f xs is allowed, but f (x : xs) = f (x : xs) isn't
18:34:31 <athan> that would force the deduction
18:34:48 <athan> hmmm!
18:35:05 <Twey> athan: I believe that's sufficient to ensure totality, in the absence of other means of recursion
18:35:06 <athan> where pattern matching delimits the "subexpression" through the data constructor?
18:35:17 <Twey> athan: Right
18:35:20 <erisco> what about guarded recursion? f (x:xs) = x : f xs ?
18:35:25 <athan> very, very intersting
18:35:33 <SrPx_> Twey: let me know if I'm asking too much... but is there any reason to have arbitrary recursion / turing completeless in a language?
18:35:35 <Twey> Oh, yes
18:35:35 <athan> :)
18:35:43 <michaelt> erisco suppose it repeatedly checks some external  file or something and then you want to give a value from that, unless something. then write do {x <- ioquery; if p x then yield (f x) else return ()}
18:35:44 <athan> erisco: I beleive that's mutually recursive :)
18:35:50 <guesting> Are there any good threepenny-gui tutorials out there? The example code is too confusing for me and I need someone to walk me through it...
18:36:06 <erisco> athan, it is just 'id' for lists and it terminates
18:36:32 <athan> not quite!
18:36:36 <Twey> athan: guarded recursion is also a useful restriction on recursion, where you can only recurse inside a subexpression of the result.  That doesn't guarantee *termination*, but it does guarantee *productivity*, so your function will always return something useful at the next step
18:36:37 <athan> what if the list is infinite?
18:37:01 <erisco> athan, well, it is productive :)
18:37:14 <Twey> SrPx_: There are some useful non-terminating programs.  And some programs terminate, but are (provably) impossible to prove terminating
18:37:29 <athan> Twey: ***something useful, vs. something that was already there***
18:37:37 <athan> the latter being terminating expressions
18:37:51 <Twey> athan: For example, take 5 (f xs) is guaranteed to be terminating iff f is guaranteed to be productive
18:37:57 <athan> the former being guarded
18:38:18 <athan> Twey: You can prove the ability to prove??
18:38:44 <Twey> Sure, in some cases
18:39:00 <athan> Twey: Only because the lazyness of the language garuntees termination becuase "take 5" has it's... terminability specificed in advance?
18:39:08 <athan> this is all so awesome!!!
18:39:39 <erisco> I wonder how deep the rabbit hole goes... "the provability of provability is unprovable"
18:40:06 <athan> I feel like at that point, you have to engineer the hole
18:40:20 <MP2E> provability of provability is provably improvable
18:41:12 <MP2E> english is fun sometimes :V
18:41:25 <Twey> Heh
18:41:57 <michaelt> erisco: oh i forgot obvious bits; let xxx = do {x <- liftIO ioquery; if p x then yield x >> xxx else return ()}
18:42:25 <johnw> has anyone used System.Posix.SharedMem on OS X?  It seems to be a bit wonky
18:42:39 <johnw> I can't write to the Fd returned from shmOpen name (ShmOpenFlags True True False False) ownerModes
18:42:57 <Twey> guesting: I don't think so, but there are a few reactive-banana tutorials if that's the bit you're having trouble with
18:43:50 <guesting> Twey: I'm just trying to understand how to add a gui to my program, what each element means and how to combine elements and whatnot
18:44:02 <Twey> athan: Right, it's guarenteed because of non-strictness.  In a strict language a productive-but-non-terminating function is just a non-terminating function.
18:44:07 <sjy> athan: 'engineering the hole' is kind of what godel's incompleteness proof does. engineers a statement inside a formal system that asserts its own unprovability.
18:44:27 <Twey> guaranteed**
18:45:18 <erisco> michaelt, I am still not sure how it is known whether a producer has terminated
18:46:02 <erisco> even if you return (), how does that inform the consumers of anything?
18:46:17 <michaelt> erisco: basically yes, the whole pipeline stops
18:46:42 <michaelt> the name of the constructor for return is Done
18:46:48 <michaelt> if I remember
18:47:30 <michaelt> erisco: in that sense, return r is llike the Nothing signal, its just that it has a value
18:48:48 <michaelt> erisco: woops, it's called Pure, not Done, but the point's the same.
18:49:09 <erisco> oh really? hm
18:49:09 <erisco> seems it is called Pure
18:49:19 <michaelt> yeag
18:49:25 <michaelt> yeah, rather.
18:49:53 <michaelt> It's frequently called Done in similar setups.
18:50:37 <Twey> SrPx_: Interestingly, though, even if you have a terminating language, you can still express non-terminating programs using an external source of non-termination, in the same way Haskell uses an external source of impurity to express impure programs in a pure language
18:50:40 <erisco> so what would happen if you returned and then yielded?
18:51:07 <michaelt> erisco: then you're not done, its like return () ; putChar 'a'; return 1
18:52:21 <erisco> but... okay there is something fundamental I do not understand then
18:53:59 <guesting> Twey: Wait...what's the difference between reactive-banana and threepenny-gui?
18:54:23 <guesting> Twey: They both seem to do the same thing--gui programming, but the syntax is different?
18:54:42 <michaelt> the Pure x isn't 'passed' down erisco , >-> is defined so that if either is Pure x, the result is Pure x  see https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/src/Pipes/Core.hs#L523
18:54:47 <michaelt> erisco ^^^
18:55:40 <michaelt> erisco, wait, wrong one.
18:57:36 <erisco> michaelt, okay thanks I'll take a closer look
19:00:08 <michaelt> oh heres the quasi-internal function I was looking for erisco https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/src/Pipes/Core.hs#L631 p >-> q is (\() -> p) +>> q
19:00:28 <SrPx_> Twey: oh true!
19:01:19 <athan> guesting: hmmm, I think reactive-banana is more of an FRP framework than a simple command-induced gui interaction
19:01:29 <athan> but I haven't used either yet
19:01:40 <athan> command-based*
19:01:46 <Twey> guesting: reactive-banana is a Functional Reactive Programming (FRP) library, a way to talk about variables that change value over time
19:01:53 <guesting> this is going to be hard, isn't it
19:02:01 <athan> guesting: It's gonna be worth it
19:02:18 <athan> :)
19:02:23 <guesting> not if I can't figure it out hahaha
19:02:27 <Twey> guesting: It's by Heinrich Apfelmus, who also produced threepenny-gui, so I assume the examples you're looking at are using reactive-banana as well as threepenny-gui
19:02:30 <athan> FRP framworks are actually really cleanly designed!
19:03:08 <athan> they separate GUI behaviour from your application's mechanisms in a way that you don't have to worry about the "binding" part
19:03:32 <athan> it's like event handlers, but they're handling all the time
19:03:52 <guesting> oh boy
19:04:09 <guesting> this will take a while
19:05:26 <athan> you can almost imagine the UI as the result of a pure function (the input)
19:05:37 <athan> but that pure function is being computed all the time
19:05:46 <athan> that's the general idea I've got so far at least haha
19:06:10 <athan> I really want to make an FRP fractil :)
19:09:44 <dmj`> if I have module A where; import Data.List, module A by default exports Data.List correct? Or no?
19:10:17 <athan> hmm!
19:10:35 <athan> dmj`: I think that it hides it
19:11:43 <athan> dmj`: I want to say that cabal negotiates that
19:13:04 <enthropy> dmj`: it exports instances in Data.List
19:13:16 <enthropy> none of the other things from Data.List get included
19:14:28 <Twey> dmj`: Incorrect
19:15:05 <Twey> dmj`: If you don't provide an export list, everything gets exported *except imported modules*.
19:15:22 <Twey> Apart from instances in those modules, because instances are magical and will try to infect every module they can
19:16:34 <dmj`> Twey: I was fearing that. I have some instances that are being exported, but I'd also like to export some modules as well, too bad there is no implicit exports of imported modules. Now I'll have to export everything manually. The instances are TH generated so I don't even know what they look like
19:17:30 <Twey> dmj`: Instances are *always* exported, regardless of whether or not they appear in the export list (in fact, there's no syntax to explicitly export them)
19:17:53 <Twey> So you can just export your modules and other definitions, and not worry about the TH-generated instances
19:18:21 <dmj`> Twey: Wow, good to know. That's perfect then.
19:18:48 <indigo> Twey: Whoa, you're in here too. :P
19:20:01 <Twey> indigo: I'm in lots of places ☺
19:20:06 <indigo> :D
19:20:26 <indigo> I had an awesome April Fool's joke for Haskell, maybe next year...
19:20:39 <indigo> Like Typed Racket, we could have Untyped Haskell. ;)
19:25:15 <Twey> indigo: You joke, but https://www.haskell.org/ghc/docs/latest/html/users_guide/defer-type-errors.html
19:25:33 <irene-knapp> surely that’s a joke
19:25:35 <indigo> Holy crap.
19:25:37 <irene-knapp> it was announced this morning
19:25:53 <Twey> irene-knapp: No, this has been around since GHC 7.6
19:25:56 <irene-knapp> huh
19:25:59 <irene-knapp> who knew :)
19:26:20 <Twey> Truth can be stranger than fiction
19:26:41 <dmj`> Is there a way ghc can spit out packages I'm not using that are defined in my cabal file?
19:27:38 <Twey> dmj`: http://hackage.haskell.org/package/packunused
19:27:54 <johnw> nice!
19:27:59 <johnw> seems much nicer than my approach
19:29:53 <jbkcc> hey all, what's the canonical datatype for graphs in haskell? as in collections of objects with arbitrary connections between them?
19:30:07 <johnw> there are a few
19:30:18 <johnw> Data.Graph, fgl, and at least one other I'm forgetting
19:30:29 <johnw> edwardk wrote something too; graphs I think it was?
19:30:44 <edwardk> graphs is pretty dead these days.
19:31:15 <jbkcc> ah, thanks!
19:31:34 * hackagebot warp-tls-uid 0.1.0.0 - set group and user id before running server  http://hackage.haskell.org/package/warp-tls-uid-0.1.0.0 (YoshikuniJujo)
19:31:55 <dmj`> Twey: Thanks!
19:33:39 <Twey> No problem
19:33:59 <jbkcc> huh, ok
19:34:11 <jbkcc> so it looks like Data.Graph uses an adjacency list as its internal representation
19:34:41 <jbkcc> i suspect this is my C-trained brain getting in the way, but
19:35:03 <dmj`> If my project has a ton of pragmas, is it ok to stick them all in the cabal file and not worry about it? Or in anyone's experience will that come back to bite you in the ass?
19:35:11 <johnw> hmm.. packunused really doesn't like running within an hsenv environment
19:37:34 <dmj`> johnw: I switched to cabal sandboxes, wasn't too bad, miss hsenv sometimes
19:37:37 <jbkcc> I think of "data List a = End | Cons a (List a)" as saying, a list is either empty, or a something together with a reference to a list
19:37:52 <Twey> That's what it says, yes
19:38:38 <johnw> hmm.. i can't get packunused working
19:38:43 <johnw> now it doesn't like that I use a newer cabal
19:38:48 <johnw> packunused: user error (You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.18.1.2, now Cabal-1.16.0).)
19:38:57 <jbkcc> and a tree is either empty or a something together with two references to trees, etc
19:39:03 <jbkcc> so a list is a linear graph
19:39:12 <jbkcc> and a tree is a tree-shaped graph
19:39:19 <athan> yep!
19:39:24 <athan> and it's traversed through lazy evaluation
19:39:31 <jbkcc> and furthermore they are directed graphs
19:39:34 <athan> (packed + unpacked)
19:39:48 <athan> ...so to speak
19:39:51 <jbkcc> so what if i want an arbitrary graph, potentially with cycles?
19:39:53 <athan> have you tied the knot yet?
19:39:59 <athan> ^^
19:40:13 <jbkcc> can i do this with a data type? or must i use an adjacency list and a bunch of algorithmic trickery
19:40:41 <athan> > let cycle a b = a : b : (cycle a b)
19:40:42 <lambdabot>  not an expression: `let cycle a b = a : b : (cycle a b)'
19:40:47 <Twey> jbkcc: Thanks to laziness, a ‘tree’ can actually contain cycles
19:41:30 <athan> jbkcc: I guess it depends on if you want the same identical object
19:41:36 <jbkcc> Twey: would you mind giving an example?
19:41:52 <jbkcc> athan: "identical" seems to be a tricky concept in haskell :)
19:41:54 <Twey> jbkcc: However, it can lead to clumsiness, since you then often need to explicitly check whether you've passed a certain node before
19:42:02 <Twey> jbkcc: Your equality tests &c. also become non-trivial
19:42:22 <Twey> jbkcc: athan just gave you an example
19:42:41 <athan> > sequence [1,2]
19:42:42 <lambdabot>  No instance for (GHC.Show.Show (m0 [a0]))
19:42:43 <lambdabot>    arising from a use of `M78613677322092750931282.show_M78613677322092750931...
19:42:43 <lambdabot>  The type variables `m0', `a0' are ambiguous
19:42:43 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:42:43 <lambdabot>  Note: there are several potential instances:
19:42:48 <jbkcc> Twey: ah! I see
19:42:49 <prophile> data Tree a = Node (Tree a) (Tree a) | Leaf a ; recursiveTree = Node 5 recursiveTree
19:42:52 <Twey> The ‘cycle’ function creates a list that is actually more of a ring
19:42:55 <athan> :t sequence
19:42:55 <prophile> for an actual tree :)
19:42:56 <lambdabot> Monad m => [m a] -> m [a]
19:43:13 <Twey> By pointing the last element back to the first
19:43:16 <athan> > sequence [1]
19:43:17 <lambdabot>  No instance for (GHC.Show.Show (m0 [a0]))
19:43:17 <lambdabot>    arising from a use of `M544126359716577285331295.show_M5441263597165772853...
19:43:17 <lambdabot>  The type variables `m0', `a0' are ambiguous
19:43:17 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:43:17 <lambdabot>  Note: there are several potential instances:
19:43:22 <athan> hmff
19:43:27 <prophile> athan: sequence probably isn't what you want
19:43:33 <Twey> > cycle [1, 2, 3]
19:43:34 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
19:43:53 <athan> derp
19:44:02 <copumpkin> > sequence ["abc", "de"]
19:44:03 <lambdabot>  ["ad","ae","bd","be","cd","ce"]
19:44:08 <jbkcc> huh, this is starting to gel
19:44:17 <athan> oh duh!! It's like a comprehension
19:44:28 <athan> or an mconcat + fold?
19:44:40 <prophile> in which athan discovers monads :)
19:44:43 <Twey> Hehe
19:44:48 <copumpkin> or applicatives in this case
19:44:53 <athan> WAAAAAAAAAAAAAAAAA~~~~~~~~~~
19:44:58 <copumpkin> athan: you can also think of it as a weird transposition
19:45:01 <athan> (lightspeed)
19:45:06 <athan> hmm!
19:45:15 <Twey> Or an n-ary Cartesian product.
19:45:19 <athan> I understand applicatives
19:45:27 <athan> but it's interesting to see application as a monoidal operation
19:45:29 <prophile> :t sequenceA
19:45:31 <lambdabot>     Not in scope: `sequenceA'
19:45:31 <lambdabot>     Perhaps you meant one of these:
19:45:31 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
19:45:33 <prophile> bah
19:45:38 <prophile> :t T.sequenceA
19:45:39 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
19:45:41 <copumpkin> no monoid really appearing here, unless you're talking about the monoidal stuff in applicative itself
19:45:41 <athan> and to see the "arguments" be folded
19:45:54 <athan> Twey: WAY
19:45:57 <athan> WOAH
19:46:00 <athan> okay
19:46:02 <athan> time to math
19:46:06 <copumpkin> :)
19:46:22 <athan> I was!
19:46:46 <shouya> hi,
19:47:01 <dmj`> oh, looks like language pragmas in a cabal file can only be used on one module...
19:47:06 <athan> copumpkin: I wish that the pricipal properties of haskell were as explicit as it's applications
19:47:11 <athan> erm
19:47:17 <athan> something along those lines haha
19:47:36 <shouya> I am somewhat confused with state monad.
19:48:00 <dmj`> > flip evalState 4 $ modify (+1)
19:48:02 <lambdabot>  ()
19:48:13 <dmj`> flip execState 4 $ modify (+1)
19:48:22 <dmj`> > flip execState 4 $ modify (+1)
19:48:24 <lambdabot>  5
19:48:40 <shouya> like, why is a state a wrapped function, rather than a state-value tuple pair.
19:49:10 <athan> same, shouya!
19:49:39 <shouya> i think i still didn't get the point.
19:51:12 <shouya> why isn't a state :: (s,a) but :: s -> (a,s) ?
19:51:23 <johnw> how would you know what the previous state was?
19:51:31 <Twey> shouya: State represents not states but *transitions* between states
19:51:52 <johnw> (s,a) wouldn't be mutable
19:51:55 <Twey> shouya: Something of type State s a is a transition between states that also returns a
19:52:18 <Twey> I.E. s → (s, a) (a function from a state to a state and a return value)
19:52:48 <shouya> so what exactly is meant by the Monad.State?
19:52:50 <athan> shouya: you have to simulate memory by continuously talking to yourself :)
19:52:59 <sjy> nice analogy
19:53:02 <athan> hahaha
19:53:16 <shouya> athan: XD
19:53:24 <athan> what analogy? E:
19:54:33 <shouya> so is State a process of transition?
19:54:49 <athan> it simulates that, yet
19:54:59 <athan> but the whole thing is deterministic (pretty sure)
19:55:16 <athan> wouldn't the monadic bindings create tied knots though the calls to `put` and `get`?
19:55:32 <athan> er
19:55:38 <athan> most of haskell is very deterministic
19:55:47 <athan> so the State monad is kinda like
19:55:55 <athan> one step in the unraveled recursion
19:56:03 <shouya> athan: yep, it's sure that.
19:56:08 <athan> and it *looks* like you're causing state
19:56:12 <Twey> The State monad is kind of like a function from a state to a new state and a return value.  ;)
19:56:48 <dhrosa> shouya: it's a nice abstraction around functions of the  form s -> (a, s)
19:56:55 <dhrosa> where you  want to return a new  value, and also a new state
19:57:04 <shouya> yep
19:57:08 <shouya> Yep I knew that. I mean, I even tried and implemented a State monad alone.
19:57:10 <athan> but keep in mind - state still doesn't exist
19:57:20 <athan> it's just simulated through recursive calls
19:57:25 <shouya> But I just didn't still know what and why it is like so.
19:57:26 <athan> oh
19:57:39 <johnw> try thinking of it without the "Monad" part first
19:57:48 <shouya> So I don't know how to use it.
19:57:53 <athan> think in terms of traversing applications to the function repeatidly
19:57:54 <shouya> hum.
19:58:19 <johnw> state in Haskell in general is represented by functions that transform state
19:58:24 <shouya> that's okay.
19:58:38 <johnw> ok, so any such function would be of type s -> s
19:58:51 <johnw> we end up getting more functionality if we generalize that type to s -> (a, s)
19:58:55 <shouya> so why isn't it :: (a,s) -> (a,s)
19:59:06 <johnw> because we don't need the incoming "a"
19:59:14 <johnw> without a function a -> a, there's nothing we could do with it
19:59:46 <shouya> so we can just generate a return value (and a state) with only an given state?
19:59:53 <johnw> right
20:00:00 <shouya> some like the random number generator?
20:00:11 <shouya> we need a seed so we can generate a value and a new seed?
20:00:14 <johnw> that's one thing you can do with State, if you're talking about PRNGs
20:00:19 <johnw> right
20:00:22 <johnw> good example
20:00:28 <shouya> cool.
20:00:38 <shouya> it gets a little clearer :)
20:00:42 <johnw> Seed -> (Seed, RandomValue)
20:00:45 <johnw> so, if you had a function like that
20:01:02 <johnw> you can abstract it's state-transitioning-nature using State
20:01:17 <shouya> hum.
20:01:29 <johnw> you don't *have* to, but it lets you apply functions that only know about State to it
20:01:33 <shouya> so a State is a wrapper of such a function?
20:01:35 <johnw> yep
20:01:38 <johnw> @src State
20:01:38 <lambdabot> Source not found. Where did you learn to type?
20:01:44 <johnw> @unmtl State a
20:01:44 <lambdabot> Plugin `unmtl' failed with: `State a' is not applied to enough arguments, giving `/\A. a -> (A, a)'
20:02:06 <shouya> hum.
20:02:08 <johnw> newtype State = State (s -> (a, s))
20:02:16 <Clint> @unmtl State s a
20:02:16 <lambdabot> s -> (a, s)
20:02:21 <johnw> ah, thank you
20:02:24 <athan> unmtl?
20:02:26 <shouya> I previously thinking it as a simple value of a specific state.
20:02:28 <athan> Ive heard of the library
20:02:35 <athan> un-monad transformer?
20:02:43 <johnw> no, it generalizes any and all such patterns of state-transitioning-functions
20:03:28 <athan> johnw: Very well said
20:03:39 <shouya> hum, i think the idea is much clearer now.
20:03:49 <shouya> and how is it combined with monad?
20:03:53 <athan> shouya: Really the only "states" a value could be in is definted by it's Sum types
20:03:54 <athan> ie
20:04:00 <johnw> monad gives you a way to compose state-transitioning-functions
20:04:08 <athan> data StatesOfBeing = One | Two | Three ...
20:04:12 <johnw> so that the state moves all the way through the composition
20:04:31 <shouya> composition?
20:04:36 <athan> f . g
20:04:37 <shouya> of the functions?
20:04:41 <johnw> yes
20:04:41 <athan> mhmm
20:04:48 <johnw> the types wouldn't let you write "a . b . c"
20:04:49 <shouya> of the transitioning functions?
20:04:51 <johnw> yes
20:04:55 <athan> where f :: a -> State a?
20:04:57 <shouya> ohhhh
20:05:01 <johnw> s -> (a, s) won't compose with another s -> (a, s)
20:05:08 <athan> g :: a -> State a as well?
20:05:08 <johnw> but if we know it's a Monad, we can
20:05:10 <shouya> so how is it used with Monad?
20:05:29 <athan> >>=
20:05:33 <joelteon> you can't do a . b . c but you can do a =<< b =<< c
20:05:35 <athan> or really, >=>
20:05:39 <joelteon> oh yeah
20:05:41 <joelteon> a <=< b <=< c
20:05:49 <athan> hm!!
20:06:11 <shouya> that's ...
20:06:27 <athan> I'm having a hard time imagining the monad, when it's (s -> (s, a))
20:06:29 <shouya> i think i'd try it.
20:06:38 <athan> when the monad itself is an application
20:07:03 <shouya> yup, it's hard to imagine.
20:07:10 <johnw> so, with Monad *in this case*, composing one s -> (a, s) with another, causes the s from the first function to be passed as the input to the second function
20:07:11 <shachaf> "if we know it's a monad" meaning "if we know how to do it"
20:07:22 <athan> joelton: a =<< b =<< c is analogous to a b c
20:07:29 <athan> right?
20:07:32 <johnw> but this gets very hard to express in IRC without examples of what you actually want to be doing
20:07:39 <athan> not a ( b ( c ) )
20:07:52 <shouya> johnw: use the example of random number generator?
20:07:54 <joelteon> uhh probably
20:07:56 <shachaf> Which is to say that knowing how to do it is part of knowing that it's a monad.
20:08:10 <shachaf> I'm not sure what composing means, actually.
20:08:16 <athan> :t >>=
20:08:17 <lambdabot> parse error on input `>>='
20:08:24 <athan> :t (=<<)
20:08:25 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:08:30 <athan> :t ($)
20:08:31 <lambdabot> (a -> b) -> a -> b
20:08:37 <athan> :t (<=<)
20:08:38 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
20:08:40 <athan> :t (.)
20:08:41 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:08:46 <shouya> hum.
20:09:08 <athan> the composition is what I find most interesting
20:09:09 <Twey> athan: a =<< b =<< c is a generalization of a (b c)
20:09:09 <johnw> shouya: I don't think the random number generator case is not too clarifying here.  I'd suggest writing some examples of code using State first, to get the hang of it
20:09:16 <johnw> s/not//
20:09:26 <athan> so if you have multiple functions of (a -> State a)
20:09:30 <johnw> specific monads are elucidated through use, really
20:09:32 <athan> you can compose them under the hood
20:09:33 <Twey> (a (b c) is isomorphic to a =<< b =<< c when the monad is Identity)
20:09:58 <shouya> okay, is there any examples i can use?
20:10:13 <athan> Twey: Hmm, so the binding of ( ) is loose by default?
20:10:22 <athan> if ( ) were a thing
20:10:28 <shachaf> Twey: Isomorphic?
20:10:38 <Twey> athan: I don't know what that means, but a b c is (a b) c
20:10:47 <athan> ahhhhhhhhhhhhhhhhhhhhhhhh
20:10:51 <athan> i keep forgetting
20:10:52 <athan> arity
20:10:56 <erisco> if you want a weak reference to some ADT, is it best to wrap it in an ioref?
20:11:04 <athan> isn't restrictive
20:11:30 <shouya> ahh (=<<) composes from right?
20:11:47 <athan> yes!
20:11:49 <athan> wow!
20:11:49 <tapuu> I have a strictness problem with the continuation monad, can anyone help?
20:11:53 <shouya> got it.
20:12:04 <athan> so: a b c =====> ( a b ) c
20:12:11 <shouya> hum.
20:12:17 <Twey> shachaf: Well, a is isomorphic to Identity a, and (a → b) is isomorphic to (a → Identity b)
20:12:31 <shouya> thank you folks, i'd make a trial now :) bbl
20:12:36 <Twey> An abuse of terminology, perhaps
20:12:44 <shachaf> tapuu: No one can help unless you say what the problem is. :-)
20:12:51 <shachaf> Twey: But you're talking about values, not types.
20:13:10 <athan> hmm
20:13:16 <athan> :t (>>=)
20:13:16 <tapuu> http://lpaste.net/102129 This code is using more and more memory as it runs, when it should be constant
20:13:17 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:13:26 <athan> hmmm
20:13:34 <athan> is there an infixl (=<<)?
20:13:37 <Twey> shachaf: Rather, sets of values
20:13:41 <athan> to mimic natural function application?
20:13:54 <athan> or is ($) the analogue of (=<<)?
20:13:56 <Twey> shachaf: So types of some kind, perhaps, even if not in Haskell.
20:14:28 <Twey> athan: Yes, something like that
20:14:44 <shouya> :t (>=>)
20:14:44 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:14:53 <shachaf> And these sets are of the same cardinality, is what you're getting at?
20:15:02 <athan> there's no analogue in the monad world, though?
20:15:08 <athan> so there's no monadic currying?
20:15:09 <dwcook> If you use m ~ Identity and then pretend Identity a ~ a, you get ($) out of (=<<)
20:15:25 <Twey> shachaf: No: there's a bijection between them
20:15:26 <shachaf> tapuu: Why should it be constant?
20:15:38 <athan> dwcook: But how do you get ( )?
20:15:46 <athan> dwcook: Application itself?
20:15:49 <dwcook> athan, I don't understand the question.
20:16:02 <athan> dwcook: An infixl ($)
20:16:09 <athan> dwcook: but monadic
20:16:14 <shachaf> I think English phrases such as "is like" or "is the same as" are much simpler than the exercises you have to go through to justify "isomorphic".
20:16:18 <tapuu> shachaf: because f1 and f2 return using the continuation passed to them. I know theres no guarantee that they will do that, though
20:16:23 <shachaf> Any two things are isomorphic in an indiscrete category with two objects.
20:16:27 <athan> dwcook: so you can partially apply monadic computations, and curry them
20:16:35 <Twey> shachaf: I wasn't planning on justifying it.  :þ
20:16:54 <shachaf> tapuu: Hmm?
20:17:03 <shachaf> Oh, you're shadowing "return".
20:17:07 * shachaf shudders.
20:17:14 <Twey> shachaf: ‘Is like’ is too loose (they are actually the same thing, in some sense), and ‘is the same as’ is too strict (it's not the *usual* sense)
20:18:00 <dwcook> athan, what do you mean "partially apply monadic computations"?
20:19:24 <dwcook> athan, I consider (=<<) to be the closest analog among Monad operations to ($) that exists.
20:20:20 <tapuu> I think I am using the wrong monad for what I want
20:20:32 <Twey> athan: partialM ∷ (a → b → m c) → a → (b → m c); partialM = id
20:20:56 <dwcook> tapuu, then how do you know you want a monad at all?
20:21:02 <athan> Twey: NICE!
20:21:07 <Twey> athan: The only thing different about monadic functions is the return type, so partial application is just normal partial application
20:21:25 <shachaf> Cont can do almost anything, so probably it can do what you want, and probably it's the wrong monad.
20:21:27 <flebron> Hey folks. What would be a reasonable set of exercises to see that a person has undestood functors, applicative functors, and monads?
20:21:28 <athan> hmm!
20:21:30 <shachaf> But I don't know what you want.
20:21:37 <athan> typeclassopedia
20:21:41 <tapuu> dwcook: Well I'm already in IO, what I meant was that I'm using the wrong monad transformer
20:21:42 <dwcook> tapuu, I'd say it'd be better to say "wrong structure"; there are many things that aren't monads that could solve your problem
20:22:22 <Twey> flebron: Have them write some non-standard functors/applicatives/monads, perhaps?  Or give them some code to rewrite using functors/applicatives/monads?
20:22:55 <flebron> Ah, the latter seams interesting.
20:23:15 <flebron> (Not entirely sure what "non-standard" would mean)
20:24:15 <Twey> flebron: Monads they aren't likely to encounter elsewhere, even if it's not necessarily useful.  Like a ‘double-counting’ monad, perhaps.
20:24:56 <flebron> Ah OK :)
20:25:32 <shachaf> I don't understand monads well enough to understand what "understand monads" means.
20:27:45 <tapuu> In terms of imperative programming, I want to be able to do a tail call to another IO value from any point in an IO value and discard all memory used by the first IO value. So like doing a tail call with the return statement in the middle of a function in an imperative language with tail call optimisation
20:28:32 <erisco> deRefWeak :: Weak a -> IO (Maybe a)    does the returned value, if a Just value, count as a strong reference? how do we know the value is not duplicated or substituted for something equivalent?
20:29:03 <flebron> shachaf: Well, I'm still unsure as to how I'll present them. I'm thinking first give the "computational context" version, and then go for the natural transformation definition. I think the latter is "understandable", while the first one is something one "gets used to".
20:29:43 <erisco> in a language where values have no identity, how can weak references be reasoned about?
20:29:43 <c_wraith|N10> I just independently discovered https://oeis.org/A233904 via an entirely different method. How often does that happen?
20:29:54 <flebron> (The context of "present them" is a series of talks on functional programming in uni)
20:30:36 <shachaf> c_wraith|N10: Pretty often.
20:30:46 <shachaf> That's a big part of the point of OEIS.
20:31:24 <flebron> See for example how many different interpretations there are of https://oeis.org/A000108
20:32:23 <flebron> What are examples of Arrows other than Hom and Kleisli?
20:32:53 <shachaf> flebron: Forget about Arrow, it is a red herring.
20:33:22 <flebron> In what way?
20:33:28 <shachaf> It's in base so people like to say "Functor, Monad, Arrow", as some sort of inevitable march of complexity of concepts that a beginner must learn to become skilled.
20:33:54 <shachaf> But that's not how abstractions work. Arrow is not relevant to many things.
20:34:53 <erisco> flebron, an Arrow instance may model a DSL that requires runtime compilation or optimisation before execution
20:36:22 <shachaf> I'm not against people learning about Arrow. But I don't like people learning about Arrow because they think they must.
20:37:14 <flebron> I mostly wanted to get a feel for "modern programming in Haskell", after LYAH and knowing RWH isn't exactly up-to-date.
20:38:02 <shachaf> Yes. And Arrow is right there, but it's a trap.
20:40:05 <flebron> What would be better recommended? Control.Concurrent.Async? Free monads? ... weird crap like Kan extensions, forsaking my winter holidays to learn the necessary archery? :p
20:40:42 <shachaf> Those are all more useful things to learn about than Arrow.
20:41:52 <johnw> flebron: async is both interesting and useful
20:41:57 <tsou> exactly how out-of-date would RWH be considered now?
20:41:58 <johnw> and there's a good book about it
20:47:51 <athan> johnw: WHAT BOOK!?!?!?!???!?!
20:47:56 <athan> johnw: :))))))
20:49:17 <johnw> athan: http://chimera.labs.oreilly.com/books/1230000000929
20:51:12 <athan> johnw: Thank you :)
20:51:50 <shouya> hi,
20:51:54 <shouya> i
20:51:56 <shouya> i'
20:52:09 <shouya> i find i'm still confusing
20:52:09 <athan> ayo!
20:52:17 <athan> I confuse all the time :)
20:52:22 <shouya> :)
20:52:28 <athan> what's up?
20:52:28 <shouya> here i made a trial
20:52:32 <athan> Are you in shock yet?
20:52:33 <shouya> type Seed = Integer
20:52:34 <shouya> type MyState = State Seed Integer
20:52:35 <athan> oh okay
20:52:40 <shouya> seed :: Integer -> Seed
20:52:41 <shouya> seed = id
20:52:41 <shouya> genNumber :: Seed -> (Integer, Seed)
20:52:41 <shouya> genNumber seed = (seed `mod` 10, (seed * seed + 71) `mod` 100)
20:52:44 <shouya> right here.
20:52:51 <athan> hmm
20:52:53 <shouya> the question is, how to compose these functions.
20:52:57 <athan> o.o
20:53:01 <athan> that ain't right
20:53:06 <shouya> number :: Integer
20:53:06 <shouya> number = evalState (return (seed 10) >>= genNumber >>= genNumber)
20:53:10 <athan> id :: a -> a
20:53:13 <athan> not
20:53:22 <shouya> that function does nothing.
20:53:27 <johnw> you have to use State to use >>=
20:53:28 <athan> id :: a -> (s -> ( s, a))
20:53:38 <johnw> genNumber :: MyState
20:53:57 <flebron> athan: He's using id as Integer -> Seed, and Seed is Integer
20:54:05 <athan> oh whoop
20:54:06 <athan> s
20:54:07 <athan> sorry
20:54:14 <shouya> hm, okay.
20:54:18 <shouya> genRandomNumber :: MyState
20:54:18 <shouya> genRandomNumber = do
20:54:18 <shouya>   seed <- get
20:54:23 <shouya> then I stuck here :(
20:54:33 <johnw> stuck in what sense?
20:54:35 <athan> flebron: how quickly do you read Haskell?
20:54:36 <shouya> I don't know how to write on.
20:54:55 <flebron> athan: About 12bps.
20:54:56 <prsteele> shouya: you are trying to define a random number generator, and you want to update the internal state over a series of computations?
20:55:00 <shouya> flebron: lol
20:55:01 <athan> hahaha
20:55:14 <athan> \ / s
20:55:17 <shouya> predator117: exactly.
20:55:26 <athan> lambda reductions per second
20:55:46 <athan> o.O
20:56:36 <shouya> hmm...
20:56:49 * hackagebot llvm-general-quote 0.1.0.0 - QuasiQuoting llvm code for llvm-general  http://hackage.haskell.org/package/llvm-general-quote-0.1.0.0 (TvH)
20:56:55 <shouya> any suggestions? or where did I make mistakes?
20:58:05 <athan> genNumber :: Seed -> State Integer Seed
20:58:21 <athan> genNumber >>= genNumber >>= genNumber
20:58:45 <athan> I think o.O
20:58:46 <athan> or really
20:58:51 <shouya> but i thought the state should be the seed
20:58:55 <athan> genNumber :: State Seed Integer
20:58:57 <prsteele> it depends on what results he wants to carry
20:59:02 <athan> nein
20:59:20 <athan> "State" just describes the fact that this will be a stateful action
20:59:27 <shouya> prsteele: i want to carry the seed.
20:59:29 <dhrosa> if genNumber is of type Seed - > State Integer Seed, then you want genNumber a >>= genNumber >>= genNumber ...
20:59:32 <athan> there is no real mutable state, only a simulated result
20:59:50 <athan> that's what she said!
20:59:53 <athan> ~ayoooo
20:59:53 <prsteele> shouya: surely you want to compute some value, so you want to collect some function of the seeds, right?
20:59:59 <dhrosa> or perhaps a starting state then genNumber >== ...
21:00:21 <shouya> prsteele: i don't understand...
21:00:32 <athan> >=<
21:00:35 <shouya> prsteele: i just want to update the seed.
21:00:39 <athan> a coisomorphism!
21:00:45 <athan> aka
21:00:47 <athan> a stroke!
21:01:31 <athan> :k State
21:01:32 <lambdabot>     Type synonym `State' should have 1 argument, but has been given none
21:01:32 <lambdabot>     In a type in a GHCi command: State
21:01:43 <athan> @src State
21:01:43 <lambdabot> Source not found.
21:01:49 <athan> @src Control.Monad.State
21:01:49 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
21:01:55 <shouya> prsteele: i wish to get a result from the second call of the random number generating function.
21:02:09 <shouya> @src Control.Monad.State.Lazy
21:02:10 <lambdabot> Source not found. Where did you learn to type?
21:02:23 <athan> hahahaha
21:02:31 <athan> i love how offensive lambdabot can be
21:02:44 <shouya> athan: lol
21:03:04 <athan> > type State a b = a -> (a, b)
21:03:05 <lambdabot>  <hint>:1:1: parse error on input `type'
21:03:11 <athan> > newtype State a b = a -> (a, b)
21:03:12 <lambdabot>  <hint>:1:1: parse error on input `newtype'
21:03:28 <athan> : type State a b = a -> ( a, b )
21:03:35 <shouya> > let type State a b = a -> (a, b)
21:03:35 <athan> type State a b = a -> ( a, b )
21:03:35 <lambdabot>  <hint>:1:5: parse error on input `type'
21:03:41 <athan> son of a...
21:03:48 <shouya> does not help
21:04:02 <athan> :t State Int
21:04:03 <lambdabot>     Not in scope: data constructor `State'
21:04:03 <lambdabot>     Perhaps you meant `StateT' (imported from Control.Monad.State)
21:04:03 <lambdabot>     Not in scope: data constructor `Int'
21:04:13 <athan> :k State Int
21:04:14 <lambdabot> * -> *
21:04:19 <athan> :k State Int String
21:04:20 <lambdabot> *
21:04:22 <athan> aha
21:04:34 <shouya> yup.
21:05:14 <athan> let foo a = (a `mod` 10, 1)
21:05:39 <athan> foo >>= foo >>= foo :: State Int Int
21:05:46 <athan> > foo >>= foo >>= foo :: State Int Int
21:05:47 <lambdabot>  Not in scope: `foo'
21:05:47 <lambdabot>  Perhaps you meant `T.for' (imported from Data.Traversable)Not in scope: `foo'
21:05:47 <lambdabot>  Perhaps you meant `T.for' (imported from Data.Traversable)Not in scope: `foo'
21:05:47 <lambdabot>  Perhaps you meant `T.for' (imported from Data.Traversable)
21:05:54 <athan> > let foo a = (a `mod` 10, 1)
21:05:55 <lambdabot>  not an expression: `let foo a = (a `mod` 10, 1)'
21:06:04 <joelteon> @let foo a = (a `mod` 10, 1)
21:06:05 <lambdabot>  Defined.
21:06:11 <athan> THANK YOU!!!!!
21:06:15 <shouya> o O
21:06:16 <athan> > foo >>= foo >>= foo :: State Int Int
21:06:18 <lambdabot>  Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
21:06:18 <lambdabot>                                  GHC.Types.Int Data.Functor.Identity.Identity...
21:06:18 <lambdabot>              with actual type `t0 -> (t0, t10)'Couldn't match type `(,) a1'
21:06:18 <lambdabot>                with `Control.Monad.Trans.State.Lazy.StateT
21:06:18 <lambdabot>                        GHC.Types.Int Data.Functor.Identity.Identity'
21:06:21 <athan> > foo >>= foo >>= foo
21:06:22 <lambdabot>  Couldn't match expected type `(a0, a0)'
21:06:22 <lambdabot>              with actual type `t0 -> (t0, t10)'
21:06:38 <joelteon> :t foo >=> foo >=> foo
21:06:39 <lambdabot> (Integral a, Monad ((,) a), Num c) => a -> (a, c)
21:06:47 <athan> thank you!!!!!!
21:06:57 <athan> I should've known .-.
21:07:26 <athan> ( foo >=> foo >=> foo ) 4
21:07:31 <athan> > ( foo >=> foo >=> foo ) 4
21:07:32 <lambdabot>  No instance for (GHC.Show.Show a0)
21:07:32 <lambdabot>    arising from a use of `M902360474151098833331592.show_M9023604741510988333...
21:07:32 <lambdabot>  The type variable `a0' is ambiguous
21:07:32 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:07:32 <lambdabot>  Note: there are several potential instances:
21:07:34 <shouya> wai't
21:07:37 <shouya> wait,
21:07:43 <shachaf> Perhaps you should experiment with lambdabot in /msg, and then, when you've figured out the expression you want, demonstrate it in the channel.
21:08:01 <shouya> shouldn't foo be a simple function?
21:08:13 <athan> I honestly don't know the 1st thing about irc
21:08:34 <athan> shachaf: Thank you, though. I'll respect the resources :)
21:08:43 <shouya> when did it become a State?
21:08:52 <athan> I decided to make it one
21:08:55 <athan> so like
21:09:10 <athan> type State a b = a -> ( a, b )
21:09:19 <shouya> oh.
21:09:21 <athan> if foo :: State a b
21:09:30 <athan> foo :: a -> ( a, b ) also
21:09:39 <athan> so by saying that foo is a state value
21:09:46 <shouya> i thought it was a newtype XD
21:09:48 <athan> you're also saying that it's a function that returns a tuple
21:09:53 <athan> idk anymore lol
21:10:03 <athan> it's all the same general structural idea to me right now
21:10:09 <athan> the syntax can wait imo
21:10:59 <shouya> :t ( foo >=> foo >=> foo ) 4
21:10:59 <lambdabot> (Integral a, Monad ((,) a), Num c) => (a, c)
21:11:18 <shouya> fst $ ( foo >=> foo >=> foo ) 4
21:11:28 <shouya> > fst $ ( foo >=> foo >=> foo ) 4
21:11:29 <lambdabot>  No instance for (GHC.Show.Show a0)
21:11:29 <lambdabot>    arising from a use of `M400955913622318906631652.show_M4009559136223189066...
21:11:29 <lambdabot>  The type variable `a0' is ambiguous
21:11:29 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:11:29 <lambdabot>  Note: there are several potential instances:
21:11:37 <shouya> ahhh
21:11:40 <athan> hmm
21:11:42 <athan> for some reason
21:11:46 <shouya> > fst $ ( foo >=> foo >=> foo ) 4 :: Integer
21:11:47 <lambdabot>  No instance for (GHC.Base.Monad ((,) GHC.Integer.Type.Integer))
21:11:47 <lambdabot>    arising from a use of `Control.Monad.>=>'
21:11:47 <lambdabot>  Possible fix:
21:11:47 <lambdabot>    add an instance declaration for
21:11:47 <lambdabot>    (GHC.Base.Monad ((,) GHC.Integer.Type.Integer))
21:11:55 <athan> the parameter's type (4 :: Int) isn't bound to the tuple...
21:12:04 <shouya> so what's that?
21:13:20 <johnw> you have to "run" the state computation
21:13:29 <shouya> runState?
21:13:43 <johnw> runState ( foo >=> foo >=> foo ) 4
21:13:46 <shouya> but here isn't it a function?
21:13:53 <johnw> it's wrapped in the State type
21:13:56 <shouya> > runState ( foo >=> foo >=> foo ) 4
21:13:57 <lambdabot>  Couldn't match type `a1 -> (a1, c0)'
21:13:57 <lambdabot>                with `Control.Monad.Trans.State.Lazy.StateT
21:13:57 <lambdabot>                        s0 Data.Functor.Identity.Identity a0'
21:13:57 <lambdabot>  Expected type: Control.Monad.Trans.State.Lazy.State s0 a0
21:13:57 <lambdabot>    Actual type: a1 -> (a1, c0)
21:14:01 <johnw> runState just exposes the function underneath
21:14:13 <ion> In (foo >=> foo) where foo :: a -> (a, b) you’re using the ((,) a) Monad instance which is very different from the (State s) Monad instance.
21:14:24 <ion> and also not defined in lambdabot
21:14:49 <shouya> completely confused :(
21:15:26 <shouya> so `(a,)` is also a monad here isn't it?
21:15:31 <ion> @let instance Monoid a => Monad ((,) a) where { return x = (mempty, x); (a,b) >>= f = case f b of { (a',b') -> (a <> a', b') } }
21:15:33 <lambdabot>  Defined.
21:15:48 <johnw> don't even bother thinking about that Monad
21:15:50 <ion> > do { a <- ("foo", 42); ("bar", a + 1) }
21:15:52 <lambdabot>  ("foobar",43)
21:16:12 <johnw> if you're trying to learn State, stick to State
21:16:50 <shouya> johnw: thank you... but i think the concept of State should be clear for me.
21:16:58 <johnw> is Reader also clear?
21:17:10 <shouya> johnw: nay yet.
21:17:24 <johnw> I'd suggest that next
21:17:28 <shouya> johnw: you mean, should i get understood Reader first?
21:17:33 <johnw> yes
21:17:38 <johnw> it's like a State that can't change the state
21:17:44 <shouya> johnw: well, okay.
21:17:48 <johnw> it has "ask" instead of "get", but no "put"
21:17:58 <shouya> hmm.
21:18:04 <shouya> I'd try it :)
21:18:19 <johnw> after that, I'd suggest working with the Maybe and Either monads
21:18:30 <Twey> It would be nice to have the update monad instead of State
21:18:42 <johnw> and then circle around to the more complex ones: (,) a, (->) a, and []
21:18:44 <shouya> Update monad?
21:18:50 <shouya> hmm.
21:18:55 <dhrosa> isn't (->) a exactly the same as the Reader  monad?
21:19:02 <johnw> not quite exactly
21:19:19 <johnw> it's isomorphic to it, but how you use it is rather different
21:19:23 <athan> Twey: I like that idea
21:19:28 <Twey> shouya: The update monad is a generalization of the State monad obtained by literally combining the Reader and Writer monads
21:19:47 <shouya> the 'Update' monad?
21:19:51 <johnw> with Reader, you don't interact with the environment unless you "ask" for it
21:20:14 <Twey> Instead of just replacing the state, you ‘write’ a monoidal ‘update’ language
21:20:17 <johnw> with (->) a, you'll find an extra argument being passed to every function you reference
21:20:30 <shouya> alright.
21:20:32 <shachaf> ?
21:20:38 <shouya> i'd try this afternoon.
21:20:39 <johnw> (provided you reference it in a monadic "statement")
21:20:43 <shachaf> Reader and (->) are the same.
21:20:44 <Twey> johnw: Reader is literally (a →)
21:20:52 <johnw> i'll show you what I mean
21:20:56 <dolio> > ask 5
21:20:57 <Twey> And a newtype in mtl, I think
21:20:58 <lambdabot>  5
21:21:08 <shachaf> You don't interact with the environment unless you "ask" for it -- or you use any Reader action that is allowed to "ask" for it.
21:21:15 <johnw> right
21:21:25 <shachaf> It's exactly the same situation as (->).
21:21:33 <johnw> ok, you're right
21:21:39 <johnw> scratch my last remarks
21:21:49 <shouya> okay :)
21:21:58 <shouya> it's lunch time. thanks & see ya later :)
21:22:14 <Twey> \o
21:23:11 <johnw> so Reader is just a way of writing a -> Reader b c instead of b -> a -> c and that's all?
21:23:37 <dhrosa> I think it's (->) a with less confusing type signatures
21:23:38 <athan> hmm...
21:23:44 <shachaf> Instead of a -> b -> c
21:23:48 <shachaf> Reader = (->)
21:23:54 <shachaf> a -> (->) b c
21:23:57 <shachaf> a -> Reader b c
21:24:02 <johnw> thanks shachaf
21:24:02 <athan> a -> b -> c
21:24:04 <athan> correct?
21:24:13 <shachaf> All the same behavior.
21:24:20 <athan> awesome
21:24:30 <johnw> then the benefit of Reader is what then?
21:24:42 <athan> Twey was referencing how they're isomorphic to eachother, yet behave differently. How so?
21:24:42 <shachaf> ReaderT
21:24:46 <johnw> ahh
21:24:52 <johnw> the one that I actually use :)
21:25:15 <athan> hmmm
21:25:16 <Twey> athan: I what?  :þ
21:25:26 <athan> at least I thought it was you Twey! :P
21:25:43 <athan> How do monad transformers compare to monads?
21:25:45 <Twey> johnw was saying that.  But we shouted him down to save you from Wrong Information.
21:25:47 <athan> i mean
21:25:51 <athan> I know they're basically wrappers
21:25:58 <athan> and can be refactored
21:26:14 <johnw> johnw is grateful for being shouted down in such cases
21:26:17 <Twey> athan: Monad transformers are like monads that can be composed with other monads
21:26:21 <athan> but, from my understanding, they compare similarly to free monads...
21:26:28 <athan> where is my parameterization wrong?
21:26:49 <athan> :)
21:27:10 <athan> ahhhh!
21:27:17 <athan> hmm
21:27:30 <Twey> I don't know this stuff very well, but I think that a monad transformer is the free monad on the composition of two other monads
21:27:33 <athan> and instead of normal function composition, they're "wrapped", right?
21:27:37 <athan> from the type perspective?
21:27:45 <Twey> Yes, something like that
21:27:46 <athan> AH!
21:27:47 <athan> WOW
21:27:53 <athan> that's incredible on many levels!
21:28:02 <athan> probably countably infinite
21:28:06 <shachaf> Twey: ?
21:29:42 <Twey> Hm, no, that's silly: the free monad on two composed monads is just the outer monad
21:29:49 <Twey> … because it's already a monad
21:30:31 <prophile> here's a thought
21:30:41 <prophile> I believe monad transformers have kind (* -> *) -> (* -> *)?
21:30:43 <shachaf> I'm not sure what "the free monad on composed monads" means in the first place, so I don't know what that is.
21:30:55 <shachaf> A monad transformer is a particular kind of function that turns a monad into a monad.
21:31:16 <prophile> that shape reminds me of church-encoded natural numbers
21:31:23 <athan> a free monoid
21:31:24 <athan> :P
21:31:25 <prophile> I wonder what the ordinary numerical operations do to monad transformers
21:31:48 <shachaf> It's not very much like Church-encoded natural numbers.
21:31:49 <Twey> athan: You can write a State s (Maybe a) but you have to deal with the lifting yourself.  Monad transformers are a class of type functions that ‘wrap’ an underlying monad by providing a ‘lift’ method that converts an action in the inner monad into an action in the outer monad.
21:31:54 * hackagebot instrument-chord 0.1.0.7 - Render Instrument Chords  http://hackage.haskell.org/package/instrument-chord-0.1.0.7 (AlanHawkins)
21:32:36 <prophile> shachaf: church naturals are forall a. (a -> a) -> (a -> a), in some sense it's just that instantiated with the type of types for a
21:32:59 <prophile> just an idle thought anyway
21:33:11 <shachaf> The quantification is the point, though.
21:33:17 <prophile> yes, it is
21:33:37 <shachaf> Well, except not really. Church naturals aren't even a typed concept.
21:33:39 <athan> Twey: So any monad can be a monad transformer?
21:33:45 <prophile> but any numerical operation that operates on forall a. (a -> a) -> (a -> a) will by definition operate on that if you instantiate it with any particular a
21:33:59 <athan> shachaf: have you heard of Fix?
21:34:04 <prophile> the church-encoded 1 is IdentityT for instance
21:34:07 <prsteele> sorry, basic question: can I quantify new types? This syntax doesn't work, but I want type (Cls a) => Foo a = [a], say
21:34:15 <prophile> as far as I can tell
21:34:23 <shachaf> "type" doesn't make types, just type synonyms.
21:34:36 <c_wraith|N10> Hmm.. [a] -> (Int -> [a]) -> [a]  ...  Is that signature just totally opaque, or does it actually suggest something? Obviously it has many possible implementations, but is one of them the one you'd expect?
21:34:36 <prsteele> shachaf: and I just want synonyms
21:34:42 <shachaf> But the short answer is "you can't", and the longer answer is that it depends on what exactly you're after.
21:35:11 <prsteele> shachaf: Just trying to alias Int/Integer so I don't pass an Int where I really mean Foo, which is actually an Int
21:35:35 <prsteele> shachaf: easy enough: type Foo = Int. But I _really_ want 'Foo a' is any Integral type
21:36:08 <shachaf> OK. The answer is "not really".
21:36:30 <shachaf> What if you have multiple Foos? plus :: Foo a -> Foo a -> Foo a
21:36:33 <prsteele> shachaf: thanks! Doesn't stop me from doing anything, really, I'll just bump to Integer and be done with it
21:36:41 <shachaf> Now you want the Integral constraint on the very outside.
21:40:25 <Twey> athan: Not any monad, no
21:40:34 <Twey> athan: ~3~
21:41:02 <athan> 3?
21:41:11 <Twey> ~~
21:41:18 <Twey> Sorry
21:41:21 <Twey> Dropped my keyboard
21:41:27 <athan> hahaha
21:41:45 <athan> sawww gough'd
21:42:20 <athan> {D:E---->-<
21:42:47 <Twey> athan: You can only make transformers out of monads for which it makes sense to ‘lift’ their actions into another monad.  For example, you can't produce a well-behaved IOT.
21:43:48 <athan> hmm!
21:44:02 <athan> so only a monad that an cause a natural transformation?
21:44:23 <athan> I'm having a hard time imagining the underlying monad's actions being lifted
21:44:34 <athan> ...but it feels similar to composition / application...
21:45:20 <Twey> athan: If I start talking about natural transformations, shachaf is going to come to my house and stab me
21:45:38 <Twey> But perhaps this will be useful: http://stackoverflow.com/questions/13056663/why-is-there-no-io-transformer-in-haskell
21:45:49 <shachaf> I like natural transformations.
21:46:16 <Twey> shachaf: I'm sure you wouldn't appreciate my abuse of them/their terminology.  :þ
21:46:27 <johnw> shachaf: are they easy? :)
21:48:09 <athan> Ha!
21:48:43 <athan> Twey: That's how it is with category theory, I feel.... It's a very particularly general science
21:48:49 <prsteele> style question... if I find myself using uncurry, am I doing it wrong?
21:49:12 <athan> thank you though!
21:49:17 <athan> hahaha
21:49:34 <athan> i think that's better than pattern matching, prsteele
21:49:46 <athan> but, you might have a higher-level design to consider
21:50:21 <Twey> prsteele: Not necessarily
21:50:47 <prsteele> okay. Thanks!
21:53:12 <johnw> uncurry can be nice when composing functions
21:53:27 <johnw> f . g . uncurry h . k, etc.
21:53:42 <athan> :t (flip . curry) . uncurry
21:53:43 <lambdabot> (a -> b -> c) -> b -> a -> c
21:53:44 <prsteele> johnw: it's what I'm doing, I have lists of pairs and I want to map things like (+)
21:53:54 <athan> :t flip . ((flip . curry) . uncurry)
21:53:55 <lambdabot> (b -> a -> c) -> b -> a -> c
21:54:05 <athan> :t flip ((flip . curry) . uncurry)
21:54:06 <lambdabot> b -> (a -> b -> c) -> a -> c
21:54:06 <startling> prsteele, that's normal
21:54:10 <startling> prsteele, you might look at e.g.
21:54:12 <startling> :t zipWith
21:54:13 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
21:54:14 <startling> instead
21:54:21 <athan> does flip only work with the first 2 args?
21:54:23 <athan> hmm!
21:54:25 <startling> athan: no.
21:54:34 <prsteele> ya, I know zipWith, but I'm generating the pairs in not-fun ways
21:54:36 <startling> it just doesn't behave how you think it does.
21:54:38 <startling> prsteele: sure.
21:54:52 <athan> startling: Yeah, I still have yet to understand it all
21:54:53 <startling> :t uncurry (\a b c d -> d)
21:54:54 <lambdabot> (a, b) -> t -> t1 -> t1
21:55:01 <athan> i imagine it comes down to product types
21:55:05 <startling> athan: nope.
21:55:20 <startling> okay, I guess it only works with the first two args (if I'm understanding you right)
21:55:32 <athan> yep!
21:55:35 <athan> but
21:55:39 <athan> im more concerned with flip
21:55:44 <startling> er, yeah
21:55:49 <startling> :t flip (\a b c d -> d)
21:55:50 <lambdabot> b -> a -> t -> t1 -> t1
21:55:51 <athan> :t flip (\a b c d -> e)
21:55:51 <lambdabot> b -> a -> t -> t1 -> Expr
21:55:57 <athan> schweet
21:55:58 <athan> cool
21:56:02 <athan> so it's almost like...
21:56:04 <athan> currying...
21:56:08 <startling> @src flip
21:56:08 <lambdabot> flip f x y = f y x
21:56:12 <athan> is a free... action
21:56:13 <athan> like
21:56:18 <athan> it traverses the signature
21:56:25 <athan> rather than fully knowing it in advance
21:56:30 <athan> hmm
21:56:33 <athan> that's part of haskell, then
21:56:37 <startling> athan: please stop trying to shoehorn your understanding into existing terminology
21:56:42 <startling> it makes things realllly confusing
21:57:14 <startling> athan, do you understand what (->) is?
21:58:09 <startling> :t (\a b c d -> d) :: a' -> (b' -> (c' -> (d' -> d'))) -- does this make sense
21:58:10 <lambdabot> a' -> b' -> c' -> d' -> d'
21:58:14 <startling> ?
21:59:55 <startling> athan, a two-argument function is actually a one-argument function whose return type is a one-argument functions.
22:00:10 <startling> is that clear?
22:00:43 <andkore> Is there any way to sum a very large list of integers without using seq/foldl'? I suspect this is a dumb question, so sorry.
22:01:17 <startling> :t sum
22:01:18 <lambdabot> Num a => [a] -> a
22:01:31 <athan> right!
22:01:34 <athan> so really
22:01:42 <andkore> startling: I imagine that's implemented with a foldl'? I'll check the source.
22:01:43 <athan> function application itself is a free-wheeling action
22:01:56 <athan> that's all I meant
22:01:56 <johnw> are you asking if there are other ways?
22:01:58 <startling> @src sum
22:01:58 <lambdabot> sum = foldl (+) 0
22:02:52 <athan> andkore: Well, if the summation operation and elements are a commutative monad, then technically you don't have to move in any particular order
22:02:52 <andkore> johnw: who was that directed at?
22:02:57 <startling> athan: I have no idea what means
22:02:59 <johnw> at you
22:02:59 <prsteele> there is a conditional aroudn that definition in the source
22:03:12 <athan> startling: Commutativity means that arguments can be flipped
22:03:19 <athan> startling: yet still return the same result
22:03:24 <andkore> yeah, I was asking if you could introduce strictness without using seq/foldl' (which uses seq, IIRC)
22:03:24 <startling> > sum (replicate maxBound 1)
22:03:30 <lambdabot>  mueval: ExitFailure 1
22:03:30 <lambdabot>  mueval: Prelude.undefined
22:03:36 <athan> so technically, the container doesn't have to be an ordered list, it could be a set
22:03:45 <athan> and have the elements reduced arbitrarilly
22:03:46 <startling> athan: sure, that's not what I'm talking about.
22:03:55 <startling> athan: "function application itself is a free-wheeling action" <- what?
22:04:17 <startling> andkore: I'm not sure you understand strictness.
22:04:17 <athan> you don't have to know the end result in order to apply a function
22:04:18 * Sgeo vaguely wonders what monadic laziness would look like
22:04:29 <athan> that applying an argument is the atomic operation
22:04:33 <athan> not applying all arguments
22:04:36 <athan> that's all I meant
22:04:53 <Sgeo> Laziness as a side-effect tracked through the type system, like I/O, unlike the current system where laziness is as pervasive throughout Haskell as I/O is in other languages
22:05:16 <Sgeo> Or is this what the Partiality monad is? I should probably look at that
22:05:30 <startling> Sgeo: the partiality monad isn't important in Haskell
22:05:40 <andkore> startling: probably not. my understanding is that fold' works because it adds the numbers to one "sum" number, rather than building the entire thing up in the stack before trying to reduce it (which results in a stack overflow)
22:05:53 <Sgeo> What, because of the pervasive omnipresent side-effecting of laziness that Haskell has?
22:06:10 <athan> startling: I meant that the act of applying an argument itself is a means to an end, and can continue on in the same way
22:06:14 <athan> much like a free monad
22:06:17 <startling> Sgeo, I think partiality is an orthagonal concept
22:06:23 <startling> Sgeo, Haskell is partial.
22:06:44 <startling> athan, no, it's nothing like a free monad?
22:07:01 <athan> meh.
22:07:07 <startling> sorry. :<
22:07:12 <athan> sall good :)
22:07:19 <athan> I need to research more :P
22:07:28 <athan> i just feel like
22:07:30 <athan> ( )
22:07:37 <startling> athan, yes, applying an argument to a "Int -> Char" function is the same as applying it to an "Int -> Float -> Char" function.
22:07:38 <athan> is a free monad, with the Identity monad
22:08:04 <athan> or something along those lines
22:08:05 <startling> andkore, right, ok.
22:08:14 <athan> or maybe
22:08:18 <startling> andkore: I think sum uses foldl' now or something
22:08:21 <athan> (->) is the free Identity monad
22:08:24 <athan> er
22:08:28 <athan> identity free monad*
22:08:47 <startling> athan: are we talking about this from a categorical perspective or a Haskell one?
22:09:19 <ni291187> help
22:09:34 <athan> I honestly don't know anymore xD
22:09:41 <athan> neither
22:09:45 <athan> MINE >:D
22:09:49 <athan> hahaha
22:09:50 <startling> athan: do you know category theory?
22:09:52 <athan> thank you for your help though
22:09:54 <prophile> the free monad generated by the identity functor is FreeId a = Pure a | Roll (FreeId a)
22:09:55 <athan> hardly
22:10:02 <athan> enough to know that I don't know what an axiom is
22:10:04 <startling> athan: OK. Stop using words like "free monad".
22:10:19 <startling> and "natural transformation".
22:10:26 <ni291187> how to ge started Haskell
22:10:46 <prophile> ni291187: http://learnyouahaskell.com/ is usually a pretty good starting point :)
22:10:47 <athan> ehhhhhhhhhhhhhh
22:11:00 <athan> maybe :)
22:11:07 <startling> andkore, no, it doesn't. :( sorry.
22:11:43 <andkore> startling: what's that? are you saying sum doesn't use foldl'?
22:11:59 <startling> andkore: correct.
22:12:56 <Sgeo> Is there a laziness monad?
22:13:35 <startling> I think there could be.
22:14:13 <prophile> sum and product use their own foldrs, no?
22:14:26 <startling> Something like data Lazy a = forall b. Apply b (b -> a) ?
22:14:39 <startling> My forall might be misplaced.
22:14:58 <prophile> = Coyoneda Identity
22:15:01 <athan> so can lambda calculus be described with category theory?
22:15:34 <prsteele> prophile: the source from Hoogle shows either foldl (+) 0 or a more explicit recursive version, depending on preprocessor directives
22:15:40 <athan> with surjective arrows being lambda parameters... or something?
22:15:40 <startling> yeah.
22:15:54 <andkore> prsteele: #ifdef USE_REPORT_PRELUDE
22:15:54 <andkore>  <-- do you know what that means?
22:16:02 <andkore> is that referring to the Haskell Report?
22:16:04 <prophile> prsteele: yeah, the recursive version appears to be foldr
22:16:18 <prophile> andkore: presumably, since those are the definitions in the haskell report
22:16:24 <startling> andkore, "if the option USE_REPORT_PRELUDE is set when this is being compiled ..."
22:16:54 <andkore> startling: thanks. I know what a preprocessor directive is, didn't know what "REPORT_PRELUDE" was.
22:17:00 * hackagebot wai-routes 0.5.0 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.5.0 (AnupamJain)
22:17:05 <startling> andkore: ah, sorry! misunderstood
22:17:22 <andkore> startling: no, thanks for trying to help!
22:18:43 <andkore> what's the lambda bot syntax?
22:18:49 <startling> for what?
22:18:54 <andkore> an expression
22:19:06 <prsteele> lambdabot: :t (+)
22:19:14 <andkore> lambdabeta: sum [1.. 100000000]
22:19:14 <startling> > 1 + 2
22:19:15 <lambdabot>  3
22:19:16 <johnw> Free Identity a and Fix (Either a) are isomorphic
22:19:22 <andkore> > sum [1.. 100000000]
22:19:24 <startling> :t 1 + 2
22:19:25 <lambdabot> Num a => a
22:19:27 <lambdabot>  mueval-core: Time limit exceeded
22:19:35 <prsteele> andkore: you can also /msg lambdabot ...
22:19:52 <johnw> because Free f a = Fix (Compose (Either a) f)
22:19:56 <andkore> prsteele: not my intention to spam the channel. was just demonstrating that sum [1.. 100000000] stack overflows.
22:20:04 <andkore> because it's not strict
22:21:29 <startling> andkore, lambdabot has a timeout
22:21:37 <prsteele> andkore: ah, the ... wasn't meant to be tone, it was just 'something'
22:22:48 <startling> andkore: Prelude> sum [1.. 100000000]
22:22:49 <startling> 5000000050000000
22:22:57 <andkore> prsteele: gotcha. I was just explaining why I was typing random stuff into lambda bot.
22:23:25 <startling> Much faster with foldl' though.
22:23:27 <andkore> startling: that's odd. What's the difference?
22:23:35 <startling> andkore, lambdabot has a timeout
22:23:46 <andkore> no, but locally ghci craps out with 0 zeros
22:23:53 <andkore> 8 zeros*
22:24:05 <startling> it's possible my machine GHC has a larger stack than yours, I guess
22:24:16 <andkore> yeah, my thought too. interesting.
22:24:28 <startling> anyway yeah defining sum = foldl' (+) 0 locally is sane.
22:24:41 <startling> andkore, also I have a very large amount of memory
22:24:49 <andkore> I only have 4GB. Could be that.
22:25:10 <andkore> So I'm guessing you have to use seq to sum very large lists?
22:26:28 <startling> andkore: the issue is that each step is not strict on the accumulated value
22:26:34 <startling> (I hope I'm saying that right?)
22:26:54 <startling> andkore, in this case expression that builds the accumulated value is way larger than the accumulated value
22:27:03 <andkore> right
22:27:56 <andkore> I was just wondering if there was another way of introducing strictness somehow. Since seq wasn't always in the language.
22:28:07 <startling> andkore, nope.
22:28:25 <startling> well, ish.
22:28:53 <startling> andkore, "f (Just x) = x" is strict on its argument
22:29:05 <prsteele> couldn't you do something silly like branch on the value of each term, but have those branches do nothing?
22:29:51 <startling> prsteele: depending on what you do with the branches that do nothing the branches may not be evaluated
22:29:58 <andkore> prsteele: sounds interesting. what do you mean branch? pattern match?
22:30:11 <prsteele> andkore: basically startling's suggestion, yes
22:30:42 <prsteele> andkore: set up a condition you know will always fail, and bail when that condition is true, for example
22:30:56 <andkore> I see
22:31:41 <startling> > let strictSum ls = case ls of [] -> 0; (a : as) -> case strictSum as of 0 -> a; n -> a + n; in strictSum [1...1000000]
22:31:42 <lambdabot>  Not in scope: `...'
22:31:42 <lambdabot>  Perhaps you meant one of these:
22:31:42 <lambdabot>    `.&.' (imported from Data.Bits),
22:31:42 <lambdabot>    `.&.' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
22:31:42 <lambdabot>    `^..' (imported from Control.Lens)
22:31:47 <startling> > let strictSum ls = case ls of [] -> 0; (a : as) -> case strictSum as of 0 -> a; n -> a + n; in strictSum [1..1000000]
22:31:49 <lambdabot>  *Exception: stack overflow
22:31:54 <startling> :<
22:32:24 <startling> > let strictSum ls = case ls of [] -> 0; (a : as) -> case strictSum as of 0 -> a; n -> a + n; in strictSum [1..10000]
22:32:25 <lambdabot>  50005000
22:32:35 <startling> > sum [1..10000]
22:32:37 <lambdabot>  50005000
22:32:40 <startling> > let strictSum ls = case ls of [] -> 0; (a : as) -> case strictSum as of 0 -> a; n -> a + n; in strictSum [1..1000000]
22:32:42 <lambdabot>  *Exception: stack overflow
22:32:44 <startling> > let strictSum ls = case ls of [] -> 0; (a : as) -> case strictSum as of 0 -> a; n -> a + n; in strictSum [1..100000]
22:32:46 <lambdabot>  *Exception: stack overflow
22:32:50 <startling> well !
22:32:57 <startling> I feel like something like that should work.
22:33:24 <startling> oh, I see the issue.
22:33:33 <startling> It's a right fold rather than a left one.
22:35:38 <andkore> startling: I'll look over that code, thanks.
22:36:03 <startling> andkore, the short of it is that an Int must be fully-evaluated to match on it
22:36:03 <andkore> Thanks everyone for the help with my silly questions
22:36:09 <andkore> right
22:40:45 <startling> > let strictFoldl f a ls = case ls of [] -> a; (b : bs) -> case a of 0 -> strictFoldl f (f a b) bs; n -> strictFoldl f (f n b) bs; in strictFoldl (+) 0 [1..1000000]
22:40:47 <lambdabot>  500000500000
22:41:30 <Javran> I have a question about basic category theory: does morphism composition imples the existency of the resulting morphism? say I have f and g, does "g . f" have to be a morphism in this category?
22:41:37 <startling> Javran: yes.
22:41:52 <Javran> startling: thanks!
22:41:53 <startling> Javran: you can use this to prove some cool stuff.
22:42:11 <Javran> like what?
22:42:44 <startling> Javran, if there's at most a single morphism for any two objects, and f : A -> B and g : B -> A, f . g = id
22:43:19 <startling> hm, that condition is stronger than it needs to be
22:44:12 <startling> Javran, if Hom(A, B) = {f} and Hom(B, A) = {g}, f . g = id
22:44:49 <Javran> startling: I just get started, don't know what is "Hom"?
22:44:52 <startling> no, that's not right either.
22:45:01 <startling> Javran: Hom(A, B) is the set of morphisms A -> B
22:45:07 <startling> it's just a notation thing
22:45:17 <Javran> startling: I see
22:45:33 <startling> Javran, if Hom(A, B) = {f} and Hom(B, A) = {g}, |Hom(A, A)| = 1, f . g = id -- here
22:46:12 <erisco> does the code here describe a real module or is it just an example? http://www.haskell.org/haskellwiki/Exception is there an ExceptionalT?
22:46:16 <startling> oh! wait.
22:46:39 <startling> Javran: if f : A -> B and g : B -> a and |Hom(A, A)| = 1, f . g = id
22:46:55 <startling> Javran: sorry for the rant, the answer to your question is "yes".
22:47:04 * hackagebot http-client 0.2.3.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.3.1 (MichaelSnoyman)
22:47:05 <startling> Javran: I'm relatively new to categories as well.
22:47:06 * hackagebot http-conduit 2.0.0.9 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.0.0.9 (MichaelSnoyman)
22:48:57 <Javran> startling: I'm reading and working on Basic Category Theory by Jaap van Oosten, this is a question I come up with when doing exercise 2, not sure how far I can go though.
22:51:28 <startling> typically you say this kind of thing by saying "the class of morphisms in C is closed under composition"
22:52:22 <Javran> startling: I see what you mean
22:53:51 <shachaf> startling: Is it?
22:54:03 <startling> shachaf: I don't know.
22:54:42 <startling> shachaf: is it?
22:54:52 <shachaf> I think "closed" usually means "for all a,b in C, a*b is in C"
22:55:09 <shachaf> Which isn't exactly the case for a category, because it might not be defined.
22:55:26 <startling> Oh?
22:55:37 <startling> Oh, I see.
22:55:55 <Javran> I don't get it..
22:56:00 <startling> Yeah, "closed" is not the right word.
22:56:12 <shachaf> It's not really important.
22:56:18 <startling> Javran: if f : A -> B and g : C -> D, f . g is not defined.
22:56:24 <startling> (necessarily)
22:57:02 <prsteele> night all
22:57:15 <Javran> so does that means "closed" suggests "*" being a total function?
22:57:32 <startling> shachaf: is explicitly saying "f : A -> B and g : B -> C => f . g : A -> C" the best way to say it.
22:57:35 <startling> ?
22:57:49 <startling> Javran, almost.
22:58:11 <Javran> startling: thanks, now I get it.
22:58:18 <startling> oops, got the composition backwards. you know what I mean.
22:58:19 <shachaf> That's the usual definition of composition.
22:58:27 <startling> right, ok.
23:32:09 * hackagebot ua-parser 0.4 - A library for parsing User-Agent strings, official Haskell port of ua-parser  http://hackage.haskell.org/package/ua-parser-0.4 (OzgunAtaman)
23:46:50 <joneshf-laptop> What distinguishes the cabal categories?
23:46:54 <joneshf-laptop> is there a list of stuff
23:47:00 <joneshf-laptop> like what is Control about?
23:47:05 <joneshf-laptop> what is Data about?
23:47:13 <joneshf-laptop> why is Functor in Data, and not Control?
23:47:15 <joneshf-laptop> etc
23:47:44 <cbarrett> They're to guide your intuition about what the purpose of the package is.
23:48:27 <cbarrett> fmap is by definition, structure preserving, so they don't really introduce any flow control constructs
23:49:31 <cbarrett> The categories are broad and they're mostly just to help categorize things. AFAIK there are not hard and fast rules.
23:50:17 <shachaf> There is no good reason for Functor to be in Data rather than Control.
23:50:44 <shachaf> (Categories on Hackage are unrelated to the module hierarchy.)
23:51:56 <tdammers> IMO the distinction between Control and Data is somewhat fuzzy
23:52:42 <cbarrett> Control.List wouldn't make much sense ;)
23:52:57 <tdammers> although List is a monad...
23:52:58 <dhrosa> in a way it does
23:53:19 <cbarrett> True, the List monad can model non-determinism
23:53:27 <shachaf> Control.List would make about as much sense as Data.List
23:53:34 <cbarrett> But that's not what the majority of the functions in Data.List provide
23:53:39 <cbarrett> w/e
23:53:50 <cbarrett> This is an awfully silly bikeshed, no matter what color it is painted.
23:54:51 <tdammers> yeah, well...
23:55:08 <tdammers> all I'm saying is there are cases where the distinction is arbitrary
23:55:23 <cbarrett> sure
23:55:37 <cbarrett> my point was that they're not entirely overlapping categories in all cases
23:56:03 <tdammers> I think it's more a gut feeling / intuition thing rather than hard science
23:56:15 <tdammers> Monoid is another example
23:56:28 <cbarrett> I think that's more or less exactly what I said originally, so we agree
23:56:35 <tdammers> yes
23:58:25 <cbarrett> goodnight
