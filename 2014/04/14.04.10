00:00:25 <jle`> :t (^?) -- hm
00:00:26 <lambdabot> s -> Getting (First a) s a -> Maybe a
00:03:04 <dmj`> srhb: this is awesome
00:03:29 <srhb> dmj`: Glad you're happy :-)
00:03:32 <dmj`> https://www.youtube.com/watch?v=StTqXEQ2l-Y
00:08:43 <dmj`> in lenses is there a way to do a strict modify?
00:08:51 <dmj`> res <- flip execStateT (Person "" 0) $ do { name .= "hey"; age .= 99 }
00:08:57 <dmj`> like if I had that
00:09:05 <dmj`> I want the put to use $!
00:10:00 <dmj`> do { p@(Person _name _age) <- get; put $! p { _name = "cool", _age 99 } }
00:11:27 * hackagebot HTF 0.11.3.2 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.3.2 (StefanWehr)
00:16:27 * hackagebot HTF 0.11.3.4 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.3.4 (StefanWehr)
00:16:49 <srhb> "oops" :P
00:22:10 <albertid> srhb, :D
00:33:12 <dmj`> does this mean brew install ghc will be 7.8?
00:36:34 <aleator> Where can I find something like unix exec in the libs? I'd like to replace currently running process with another.
00:39:32 <supki> @hoogle executeFile
00:39:32 <lambdabot> System.Posix.Process executeFile :: FilePath -> Bool -> [String] -> Maybe [(String, String)] -> IO a
00:39:32 <lambdabot> System.Posix.Process.ByteString executeFile :: RawFilePath -> Bool -> [ByteString] -> Maybe [(ByteString, ByteString)] -> IO a
00:41:38 <b0bbi10> hey, what's the offtopic channel of #haskell?
00:42:17 <peddie> #haskell-blah
00:42:31 <aleator> supki: Thanks. I somehow thought that didn't do the replace part.
00:42:37 <b0bbi10> thanks peddie
00:44:57 <supki> aleator: well, the fact it returns an  IO a  is a hint
00:45:59 <aleator> supki: Yeah. Figured that out on the second look :)
00:46:24 <aleator> Curious that the same convention is not followed by exitImmedately.
00:50:47 <prinsen> I have a problem with conduit and WAI, http://lpaste.net/102513
00:51:01 <prinsen> Couldn't match type `b' with `()' `b' is a rigid type variable bound by
00:51:59 <prinsen> As I cant create :: b, Im stuck
00:57:10 <jle`> what line?
01:07:26 <Fuuzetsu> :t () :: b
01:07:26 <lambdabot>     Couldn't match expected type b1 with actual type ()
01:07:26 <lambdabot>       b1 is a rigid type variable bound by
01:07:26 <lambdabot>            an expression type signature: b1 at <interactive>:1:1
01:10:55 <bartavelle> prinsen, I don't think you can mix conduit and pipe stuff like that
01:15:56 <b0bbi10> hi, how does [(x, "")] match "1, 2, 3"? http://ideone.com/E3xJ5Q
01:16:06 <Fuuzetsu> @tell bos Can you make an aeson release with at least https://github.com/bos/aeson/commit/19682fe0a5136eb84e674bda1ab76880bb3281e1 in it? I think that's the only blocker for compiling a lot of packages (lens &c) with 7.9 and considering there's a patch already in master I don't see a reason not to…
01:16:07 <lambdabot> Consider it noted.
01:16:32 <fizruk> > reads "1, 2, 3" :: [(Int, String)]
01:16:33 <lambdabot>  [(1,", 2, 3")]
01:16:34 * hackagebot binary-conduit 1.2.1 - data serialization/deserialization conduit library  http://hackage.haskell.org/package/binary-conduit-1.2.1 (AlexanderVershilov)
01:16:39 <fizruk> b0bbi10: ^
01:18:43 <b0bbi10> fizruk: in the code sample, passing "1,2,3" returns "Just [1,2,3]", so all Integrals. how is the argument being pattern matched?
01:21:15 <quchen> I'm often having trouble finding specific things in the GHC user's guide. Is there a way I can generate it as one long single HTML file? Grep only works as long as there is no HTML noise in the search string.
01:25:01 <jle`> is there any way to force a file to be 'freed' -- kill all handles attached to a file on disk?
01:25:44 <Gothmog_> depends on the OS, I guess.
01:25:58 <quchen> jle`: The lsof command should at least show open handles. Not sure how to kill them though.
01:26:14 <quchen> (Look at --help/manpage first, the output without parameters is quite long)
01:26:23 <jle`> i mean within haskell
01:26:34 <jle`> i have a function that isn't letting go of its handles
01:26:37 <jle`> and isn't returning them for me to close
01:27:11 <quchen> And the function isn't yours to modify?
01:27:44 <startling> jle`: is it hDuplicate? (haha)
01:27:50 <quchen> This really doesn't sound like something a function should do (if the handle might be used elsewhere).
01:28:10 <jle`> well
01:28:21 <jle`> when i run the function once, it reads the file and everything is fine
01:28:33 <jle`> when i run it twice in the same program (after a delay, waiting for input)
01:28:37 <jle`> it errors, saying the file is not found
01:28:41 <jle`> when it's clearly still there
01:28:48 <jle`> i'm interpreting this as the original call does not let go of the file?
01:28:57 <jle`> by function i mean IO a
01:28:58 <quchen> "File not found" does not sound like "file already open".
01:29:18 <jle`> it says copyFile: does not exist
01:29:31 <jle`> i don't know what sort of filesystem trickery is going on
01:29:41 <quchen> Add a "hIsOpen h >>= print"?
01:30:08 <jle`> hm
01:30:11 <jle`> but i don't have the handle
01:30:39 <quchen> I assume you can't just copy out a minimal non-working example here, can you?
01:31:56 <quchen> startling: hDuplicate? What are example uses for this? Having differently buffered inputs?
01:32:00 <int-index> > traversed . both %~ succ $ [('a','b'), ('c', 'd')]
01:32:02 <lambdabot>  [('b','c'),('d','e')]
01:32:12 <int-index> > traversed . both %~ succ $ [(1,2), (3,4)]
01:32:13 <lambdabot>  [(2,3),(4,5)]
01:32:16 <int-index> but ...
01:32:16 <quchen> int-index: You can also message lambdabot in private (/msg lambdabot) when you just want to try things out (as opposed to demonstrating code to others).
01:32:22 <startling> quchen, jle` wanted to mock out stdout
01:32:28 <int-index> I am demonstrating
01:32:35 <int-index> > traversed . both %~ succ $ [(1,'a'), (3,'b')]
01:32:36 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
01:32:36 <lambdabot>    arising from the literal ‘1’
01:32:37 <quchen> startling: I'm asking it unrelated to jle`'s problems
01:32:58 <int-index> Why can't I use the both combinator with tuple of different types?
01:33:23 <startling> quchen, I mean, in a previous conversation; that's why I brought it up. I think I was thinking of hduplicateTo tbh
01:33:30 <quchen> :t both -- int-index: Because of both's type.
01:33:30 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
01:33:38 <jle`> quchen: the other day i wanted to be able to monitor an IO ()'s outputs to stdout
01:34:06 <int-index> quchen, and how do I bypass it?
01:34:06 <quchen> int-index: In other words, 'both' modifies things with equally typed fields.
01:34:12 <jle`> so something like monitorStdout (putStrLn "hello") ===== return "hello"; monitorStdout :: IO a -> IO String
01:34:16 <merijn> startling: FYI, you can already do this (with a dependency on unix)
01:34:27 <int-index> Yes, I know that. I mean, why isn't it done otherwise? What is the solution to the problem?
01:34:29 <startling> jle`: ^^
01:34:34 <jle`> quchen: yeah, i'll get a minimum working example
01:35:49 <quchen> int-index: I mean two independent queries will always work, or you could use a zipper. I don't know of a 'both' that works on differently typed fields (but that does by no means mean there is none).
01:36:12 <merijn> jle`: System.Posix.IO.ByteString has "dupTo :: Fd -> Fd -> IO Fd"
01:36:23 <merijn> jle`: Together with "fdToHandle :: Fd -> IO Handle"
01:36:30 <jle`> oh neat
01:36:32 <jle`> ty
01:36:35 <quchen> int-index: There's also #haskell-lens where lots of the implementors are, you'll probably get a better/quicker answer there
01:36:38 <mgore> hi guys, I'm trying to install the binary package for ghc-7.8.1 (http://www.haskell.org/ghc/dist/7.8.1/ghc-7.8.1-x86_64-unknown-linux-deb7.tar.xz). Unpacking fails with "could not create the hard link file /ghc-7.8.1/utils/haddock/dist/build/tmp/haddock". Suppose the build was packaged wrong? Anyone else noticed?
01:36:40 <int-index> quchen, two separate queries is what I do now in my code, but with huge structures it gets ugly.
01:36:41 <NikolajK> I have here a very short program, "WC.hs", counting the number of lines from a file (it's from the "Real World Haskell" book)
01:36:41 <NikolajK> main = interact (\x -> show (length (lines x)) ++ "\n")
01:36:41 <NikolajK> I call it via "runghc WC < WCtext.txt". How does this actually work? Is this notation for WC(WCtext.txt) and WC gets interpreted as a single function? Is "main" necessary?
01:37:10 <merijn> jle`: Be warned that "handleToFd :: Handle -> IO Fd" will *close* the Handle (i.e. unusable after the conversion), this to avoid buffering issues
01:38:05 <quchen> NikolajK: 'main' is the main entry point of your program, it's what the runtime calls. A program without 'main' is not a program (but merely a library). As to how your example works, did you look at the source of 'interact'? http://hackage.haskell.org/package/base-4.7.0.0/docs/src/System-IO.html#interact
01:38:26 <merijn> jle`: But anyway, you could just create a pipe, dupTo stdout to your pipe then have a thread read everything from your pipe and forward it to stdout and collecting the output in an MVar or whatever
01:38:42 <quchen> NikolajK: Haskell is different compared to Python for example, which simply runs its source files top-to-bottom by default.
01:39:29 <merijn> I would qualify python as the the different one :p
01:39:43 <merijn> Considering C, Go, Java, etc. all have defined entry points too :p
01:40:10 <tdammers> merijn: I raise you Perl, Ruby, JavaScript, ...
01:40:16 <quchen> Let's argue about which operand should go first in a commutative operator (/=) ;-)
01:41:08 <tdammers> quchen: that one is obvious - the left-hand one of course
01:41:18 <NikolajK> it it's "IO ()", why does it show me output?
01:41:25 <NikolajK> in ghci
01:42:00 <tdammers> because ghci evaluates *and* executes?
01:42:10 <tdammers> :t putStrLn "foobar"
01:42:11 <lambdabot> IO ()
01:42:16 <tdammers> > putStrLn "foobar"
01:42:17 <lambdabot>  <IO ()>
01:42:19 <tdammers> eh
01:42:27 <tdammers> anyway, is that what you mean?
01:42:28 <quchen> NikolajK: I think GHCi has special rules for IO. It would be annoying to get "no instance Show" errors when using 'return "hello" :: IO String".
01:43:02 <quchen> Or what tdammers said.
01:44:05 <NikolajK> and if I run it not in ghci, i.e. if it's not returned to be looked at, is the output stored somewhere?
01:44:52 <quchen> main = putStrLn "Hello World" -- does not store "Hello World" in a variable or anything, no
01:45:49 <Gothmog_> NikolajK: only IO-type functions can output anything
01:46:01 <Gothmog_> duh. forgot to scroll down.
01:46:04 <Gothmog_> sorry.
01:48:00 <NikolajK> why do people say category theory isn't polymorphic - natural transformations always work on all objects, that's the same (or in a way even more general) than type polymorphism, no?
01:49:07 <srhb> I'm not even sure what that means.
01:50:55 <srhb> I've never heard category described as being polymorphic or not -- I'm not even sure how one would make sense of that.
01:51:20 <srhb> But category theory has many morphisms, so I guess you could say it's... polymorphic
01:51:23 <srhb> :-)
01:51:50 * srhb sees herself out
01:54:44 <NikolajK> if you have a natural transformation \eta between two functors F and G, for each object A (in the case of Hask, A is a type) each component \eta_A is a function from FA to GA. So \eta is polymorphic w.r.t. objects A.
01:55:12 <NikolajK> that's what I mean
01:56:20 <jutaro> Try to change to ghc7.1, but when installing the vector package I get the error:  libHSprimitive-0.5.2.1.so: cannot open shared object file
01:56:56 <jutaro> Sorry 7.8 obvious. Anyone else has a similar problem?
01:57:43 <srhb> NikolajK: Can't see any problem with that, indeed.
01:58:37 <srhb> Maybe it's just so ubiquitous that it doesn't warrant a name within CT.
01:59:19 <mgccl> If h x = f . g x, how can I write h so I can eliminate x?
01:59:41 <NikolajK> h = f . g?
01:59:53 <srhb> Not like that, no
02:00:01 <quchen> @pl h x = f . g x
02:00:01 <lambdabot> h = (f .) . g
02:00:07 <quchen> In other words, don't do it.
02:00:09 <jle`> it's (f .) . g, but don't do that
02:00:41 <NikolajK> what's wrong with f . g?
02:00:44 <srhb> Nothing
02:00:47 <mgccl> oh, I would have not come up with that...
02:00:48 <srhb> but it's not f . g $ x
02:00:53 <srhb> Which was your answer.
02:01:07 <jle`> NikolajK: the types don't quite line up
02:01:14 <quchen> f . g x = f . (g x) ≠ (f . g) x
02:01:14 <jle`> it has to do with (.)
02:01:28 <ocharles> Does anyone have any tips on debugging the following strace message: "restart_syscall(<... resuming interrupted call ...>" ?
02:01:34 <ocharles> This is a Haskell application, compiled with -threaded
02:01:36 <NikolajK> what is the $ called? I know it's some kind of "read only until there"
02:01:46 <ocharles> I have no idea what it's blocked on, but it's been like that for hours :(
02:01:46 <srhb> NikolajK: apply?
02:01:56 <srhb> Function application more like.
02:01:57 <jle`> NikolajK: id :P
02:02:03 <jle`> or function application
02:02:20 <BoR0> isn't $ "set explicit associativity"
02:02:23 <srhb> "$" is like " " only dollary.
02:02:29 <jle`> f $ x = f x
02:02:33 <dario> ocharles: i think that line is when your programm gets scheduled away while in a syscall and then comes back
02:02:37 <jle`> so maybe dollary " "
02:02:49 <zenzike> I pronounce it "of"
02:02:49 <NikolajK> wait
02:02:57 <NikolajK> so what does $ do exactly, why use it?
02:02:59 <jle`> oh "of" is nice
02:03:06 <jle`> NikolajK: f $ x = f x
02:03:08 <srhb> NikolajK: It brings parantheses aaaaall the way to the right
02:03:09 <jle`> that's what it does :)
02:03:23 <NikolajK> and also "f . g x = f . (g x) ≠ (f . g) x" is the dot used for two different things there? Concatenation and variable placeholder?
02:03:25 <jle`> it just has very low associativity, so it "binds" last
02:03:35 <srhb> NikolajK: No, composition
02:03:38 <jle`> NikolajK: the dot is composition
02:03:46 <ldrndll> NikolajK: it has low associativity, so it allows you to eliminate parentheses
02:04:06 <srhb> NikolajK: (f . g . h) x = f . g . h $ x
02:04:09 <jle`> > f $ x + y, so that's like f $ (x + y) which is like f (x + y)
02:04:10 <lambdabot>  <hint>:1:10: parse error on input ‘,’
02:04:36 <jle`> sorry lambdabot
02:04:45 <NikolajK> ah okay
02:04:52 <NikolajK> so it's a separation, of sort
02:04:59 <jle`> semantically, possibly
02:05:03 <srhb> meh..
02:05:05 <jle`> but it's also just a normal function that you can define yourself
02:05:13 <jle`> there is no magic (kinda)
02:05:14 <ocharles> dario: hmm, it feels like it got scheduled away but never came back
02:05:20 <srhb> It's application. With very low precedence
02:05:25 <NikolajK> so
02:05:25 <NikolajK> $ x = (x)
02:05:25 <NikolajK> ?
02:05:32 <jle`> application is best way to describe it
02:05:32 <BoR0> > (* 2) 3 + 1
02:05:34 <lambdabot>  7
02:05:35 <BoR0> > (* 2) $ 3 + 1
02:05:36 <lambdabot>  8
02:05:41 <jle`> $ x...do you mean ($ x), or ($) x ?
02:05:56 <NikolajK> the second one
02:06:01 <NikolajK> no
02:06:01 <BoR0> you can view $ as "wrap everything after me in parentheses)
02:06:02 <NikolajK> wait
02:06:04 <NikolajK> I don't know
02:06:06 <fizruk> NikolajK: + 1 = (1) ?
02:06:13 <jle`> ($) f = f
02:06:15 <jle`> sooo
02:06:17 <int-index> mgccl, you can also try
02:06:17 <jle`> you're right
02:06:21 <int-index> fmap fmap fmap f g
02:06:22 <jle`> but probably not for the reasons you thought :)
02:06:24 <srhb> It's no more magical than * vs + at least.
02:06:35 <NikolajK> so what does (f .) . g mean
02:06:53 <BoR0> @src (.)
02:06:53 <lambdabot> (f . g) x = f (g x)
02:06:53 <lambdabot> NB: In lambdabot,  (.) = fmap
02:06:54 <jle`> so g :: a -> b -> c
02:06:58 <jle`> f :: c -> d
02:06:59 <NikolajK> I read h x = f . g x, in math notation, as h(x):=f(g(x))
02:07:08 <srhb> NikolajK: That's not what it is
02:07:40 <jle`> you can think of it as "apply g, then apply (f .)"
02:07:45 <jle`> so if i have something of type a
02:07:53 <jle`> if i apply g :: a -> b -> c, to it
02:07:59 <jle`> i get (g a) :: b -> c
02:08:12 <jle`> then if i apply (f .) to that
02:08:13 <srhb> NikolajK: it's h(x) = f(g(x(?))
02:08:21 <srhb> wait...
02:08:27 <jle`> i get (f . g a)
02:08:29 <srhb> that's a lie
02:08:31 <srhb> yeah
02:08:37 <jle`> which is b -> d
02:08:45 <fizruk> srhb: f(g(x,?)) ?
02:08:54 <srhb> f(g(x)(?)) :P
02:09:01 <jle`> zalgo he comes
02:09:02 <srhb> Math notation is bad. :(
02:09:05 <ldrndll> Has anyone had success building network on OS X Mavericks? I get this error: http://lpaste.net/95076
02:09:20 <jle`> NikolajK: try manually applying the points, and you'll see
02:09:21 <ldrndll> is the clang wrapper script still needed?
02:09:26 <srhb> NikolajK: Think of it like this, in order for f to compose with g x, g x must be a function
02:09:50 <NikolajK> so if i have something of type a … i get (g a) :: b -> c … did you use a twice there, as type and as term?
02:10:04 <jle`> yup sorry
02:10:05 <jle`> my bad
02:10:39 <jle`> okay, look at the source of (.)
02:10:41 <jle`> @src (.)
02:10:41 <lambdabot> (f . g) x = f (g x)
02:10:41 <lambdabot> NB: In lambdabot,  (.) = fmap
02:11:13 <jle`> ((f .) . g) x     === (f .) (g x)
02:11:24 <jle`> == f . g x
02:11:33 <NikolajK> so it's postcomposition?
02:11:49 <fizruk> == \y -> f (g x y)
02:11:50 <jle`> now, one more point to go
02:12:07 <jle`> (f . g x) y ==== f (g x y)
02:12:07 <fizruk> jle`: sorry
02:12:09 <jle`> and there ya go
02:12:11 <jle`> oh no worries
02:12:21 <NikolajK> (not sure if postcomposition is the right word, but it's applying f to what comes after, and if it's a function you get the "elonged function")
02:12:29 <jle`> if you're used to math
02:12:34 <jle`> it's the circly operator
02:12:41 <BoR0> it's left associative by default. so with f . g x you have (f . g) x, and not f . (g x)
02:12:52 <srhb> BoR0: Wrong
02:13:00 <jle`> ∘
02:13:00 <fizruk> Bor0: that has nothing to do with associativity
02:13:12 <BoR0> how?
02:13:21 <johannesbodannes> does anyone know of a good way to get a 24H time representation? time package really disorienting
02:13:24 <Eduard_Munteanu> It's precedence.
02:13:27 <jle`> (.) should actaully associate either way and it would be fine, due to category laws
02:13:32 <srhb> f . g x = f . (g x)
02:13:36 <fizruk> Bor0: (.) has lower precedence than function application, so you get f . (g x) actually
02:13:41 <jle`> it's actually required to be the same when you associate left or right
02:14:16 <BoR0> ah, right. it does make sense to have lower precedence than application
02:14:21 <jle`> always remembe that in haskell, function application (space) binds tightest
02:14:36 <srhb> And function application ($) binds loosest
02:14:38 <srhb> >>
02:14:40 <srhb> <<
02:14:55 <jle`> well...i can define any operator that binds the same as ($)
02:14:57 <NikolajK> okay, I get the rough idea, I'll come back to it when I need it, thx all, ciao
02:14:58 <jle`> ($) isn't special
02:15:02 <srhb> Right. :P
02:15:05 <srhb> NikolajK: o/
02:15:09 <johannesbodannes> yeah associativity is more this property, too: (a + b) + c = a + (b + c)
02:15:17 <johannesbodannes> within the same operation
02:15:31 <johannesbodannes> idk how computer scientists abuse that term mind you
02:15:33 <jle`> i still feel weird writing things like sin x^2
02:15:42 <BoR0> but f x y z in haskell is actually (((f x) y) z)
02:15:55 <BoR0> but what I said doesn't hold because composition has lower precedence than application, as said
02:16:31 <fizruk> jle`: i usually write it like sin x ^ 2
02:16:36 <johannesbodannes> i find that annoying actually! function composition feels more verbose than it needs to be
02:16:43 <johannesbodannes> like i feel like it should be possible to write something like...
02:16:47 <jle`> fizruk: yeah but i like feeling weird
02:16:50 <fizruk> jle`: so that it is immediately obvious that it should be sin (x ^ 2)
02:16:55 <johannesbodannes> f . g (x)
02:16:56 <jle`> it gives me a weird buzz
02:17:10 <merijn> johannesbodannes: "f . g $ x"?
02:17:16 <jle`> fizruk: er wait
02:17:21 <jle`> fizruk: do you mean (sin x)^2 ?
02:17:25 <johannesbodannes> i guess that works actually <_<
02:17:37 <merijn> johannesbodannes: That's how I usually write it :p
02:17:40 <srhb> johannesbodannes: That's sort of exactly the case where $ is nice
02:17:45 <johannesbodannes> i usually write it like
02:17:48 <johannesbodannes> (f . g) x
02:17:49 <johannesbodannes> XD
02:17:50 <johannesbodannes> which is awful
02:17:53 <jle`> i like (f . g) x
02:18:00 <jle`> i prefer it to f . g $ x actually
02:18:01 <jle`> idk
02:18:04 <jle`> just stylistic probably
02:18:08 <fizruk> jle`: i read your sin x^2 like you were going to say sin (x^2)
02:18:23 <jle`> fizruk: yeah, i meant that that's what it looks like
02:18:25 <jle`> but
02:18:30 <jle`> it's really parsed as (sin x)^2
02:18:31 <fizruk> jle`: i see :)
02:18:36 <jle`> so it trips me up
02:18:57 <BoR0> @src $
02:18:57 <lambdabot> f $ x = f x
02:19:12 <BoR0> I love the simplicity of that definition, yet we discuss it for some time now. so many things hidden within it :)
02:19:15 <jle`> alternatively, ($) = id
02:19:23 <johannesbodannes> oh right, looking to parse and output 24 hour time (piecemeal, preferably!). does anyone know a good haskell library for that? looking through "time" but having no luck yet...
02:19:47 <jle`> > (*2) `id` 5
02:19:49 <lambdabot>  10
02:19:55 <iota_> jle`: how to confuse newbies
02:19:56 <johannesbodannes> if i need to i can always just calculate it from the seconds in the current day
02:19:58 <johannesbodannes> <_<
02:20:04 <BoR0> > (* 2) `id` 3 + 1
02:20:05 <johannesbodannes> i hate work though
02:20:05 <lambdabot>  7
02:20:08 <BoR0> > (* 2) 3 + 1
02:20:09 <lambdabot>  7
02:20:10 <BoR0> not exactly id...
02:20:17 <srhb> (*2) `fmap` (+3) `id` 2
02:20:40 <jle`> well, not exactly f $ x = f x either, you need to factor in precedence >.>
02:20:59 <srhb> johannesbodannes: Parsec to the rescue!
02:21:05 <BoR0> but if we set x = y z then f y z = ((f y) z), so that works
02:21:23 <BoR0> all is packed within that x
02:21:25 <jle`> but whenever you do things like map ($ x) [f, g, h], we can always do map (`id` x) [f, g, h]
02:21:31 <srhb> johannesbodannes: Or Data.Time.Format
02:21:31 <jle`> for fun or something i guess
02:21:51 <BoR0> in some cases they may be used interchangeably
02:21:52 <johannesbodannes> hmmmm... that's interesting, what does parsec offer to help with time manipulation?
02:22:07 <iota_> BoR0: nope
02:22:13 <srhb> johannesbodannes: Nothing. Just the parsing bit. :P
02:22:20 <johannesbodannes> oh right
02:22:22 <johannesbodannes> ok thanks
02:22:39 <jle`> can you set infix precedences on `backtickfunctions` ?
02:22:46 <iota_> if x is y z then f x is f (y z) and not (f y) z
02:23:09 <BoR0> iota_, correct. that's what I meant, it packs everything to the right
02:23:47 <iota_> jle`: iirc I've seen it in some libraries
02:23:52 <srhb> You can remember this because (->) points to the right and does the exact opposite! (...)
02:23:54 <iota_> don't remember which
02:24:10 <BoR0> haha
02:24:29 <srhb> Though if that weren't true we'd be drowning in parens.
02:24:46 <BoR0> but -> is right associative, but if you apply then it's left?
02:24:54 <jle`> yeah things are weird ok
02:25:06 <jle`> :)
02:25:18 <merijn> BoR0: The *type constructor* is right associative
02:25:24 <merijn> Function application is left associative
02:25:43 <merijn> The only thing that those two have in common is they both deal with functions
02:25:47 <srhb> Huh?
02:25:51 <srhb> Now I'm confused
02:25:56 <srhb> And I know how it works. >_>
02:26:02 <merijn> srhb: Confused by what?
02:26:04 <srhb> Oh wait, no, got it
02:26:06 <srhb> I mixed it up :P
02:26:08 <BoR0> haha. that's interesting
02:26:10 <merijn> srhb: :)
02:26:40 <merijn> BoR0: For some reason people seem to think that the -> type constructor has something to do with function application, while in reality those two are almost completely unrelated
02:26:54 <srhb> I like to think of it as function constructing
02:26:57 <srhb> (Which it totally is)
02:27:03 <merijn> Indeed
02:27:13 <jle`> it's just a constructor that takes two inputs
02:27:13 <BoR0> merijn, well they have some things in common. such as the types that have to match
02:27:14 <jle`> like Either
02:27:36 <jle`> 'the types that have to match' ?
02:28:08 <BoR0> Int->Int->Int is Int->(Int->(Int)), to apply you use ((f x) y), but x and y need be Ints
02:29:00 <srhb> BoR0: Right, but the "two inputs" is on the kind level, not type level
02:29:22 <srhb> Only the arity can "match" -- and then there are a lot of nonexistent choices for (->) but not for Either
02:29:24 <BoR0> what is kind?
02:29:31 <srhb> BoR0: The "type of types"
02:29:47 <BoR0> that's new to me
02:29:59 <srhb> You probably just haven't heard it before, it's quite intuitive
02:30:20 <srhb> (->) has kind * -> * -> *
02:30:27 <srhb> ie it takes two type arguments
02:30:31 <srhb> And returns a type
02:31:10 <BoR0> in what sense is it helpful? it doesn't tell us much about,.. anything?
02:31:23 <jle`> well
02:31:27 <srhb> It tells you how many types you need to make a concrete type. :-)
02:31:34 <jle`> for example, I can't do Maybe -> Int
02:31:56 <jle`> also, let's say you want to write a Functor instance for something
02:32:00 <jle`> Can Either be a Functor?
02:32:26 <jle`> no, it can't.
02:32:31 <jle`> :t fmap
02:32:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:32:32 <BoR0> but how does kind tell you that you can't do Maybe -> Int?
02:32:41 <jle`> you can't have (a -> b) -> Either a -> Either b
02:32:56 <jle`> BoR0: because you can only have things of kind *
02:33:05 <jle`> er, concrete types
02:33:13 <BoR0> so * is a concrete type?
02:33:21 <jle`> Int -> Bool works, becuase Int is * and Bool is *
02:33:23 <jle`> Maybe Int works
02:33:26 <srhb> BoR0: Yep
02:33:27 <BoR0> got it
02:33:32 <jle`> Maybe is * -> *, Int is *, so Maybe Int is *
02:33:43 <jle`> so you can't have (a -> b) -> Either a -> Either b
02:33:47 <jle`> meaning...Either can't be a functor
02:33:50 <jle`> *Functor
02:33:51 <jle`> sorry Either
02:34:05 <jle`> can Either be a monad?
02:34:08 <jle`> :t return
02:34:09 <lambdabot> Monad m => a -> m a
02:34:13 <imeredith> hi, im trying to update cabal on mac, i did cabal install cabal-install, but got...<command line>: cannot satisfy -package-id HTTP-4000.2.8-6bfdcfcdd76275c1f125703086805427    - does anyone know what is happening?
02:34:13 <jle`> a -> Either a
02:34:16 <BoR0> it seems so
02:34:17 <jle`> does not make sense.
02:34:20 <jle`> Either cannot be a monad
02:34:26 <BoR0> ah, right
02:34:31 <BoR0> however, Either Int can be a Functor/Monad?
02:34:34 <srhb> imeredith: Try cabal update?
02:34:35 <jle`> yes
02:34:38 <jle`> it can
02:34:40 <jle`> a -> Either Int a
02:34:40 <imeredith> srhb: did that first
02:34:43 <jle`> that's perfectly fine :)
02:34:46 <BoR0> ok, I see the usefulness of kind
02:34:51 <jle`> chex it out
02:34:53 <jle`> :k Monad
02:34:53 <lambdabot> (* -> *) -> Constraint
02:35:01 <jle`> it says that Monads have to be of kind * -> *
02:35:01 <srhb> imeredith: Hum.
02:35:06 <jle`> :k Monoid
02:35:06 <BoR0> what the constraint?
02:35:07 <lambdabot> * -> Constraint
02:35:13 <srhb> Oh, very old base?
02:35:30 <jle`> oh well basically if you say Monad m, it means that you have a constraint that m has to be a monad.  er.  don't worry too mucha bout it.
02:35:40 <srhb> Next: Dependent types!
02:35:46 <srhb> \o/
02:35:48 <jle`> Monad m => m a, for example, Monad m gives you a constraint on what m can be
02:35:52 <jle`> but that's not important :)
02:36:00 <jle`> can Maybe be a Monoid?
02:36:05 <imeredith> srhb: well, ghc 7.6.3 is installed, so whatever platform contains that
02:36:06 <BoR0> where can I read about this kind of stuff? types in particular. I don't want to bother you with a ton of questions
02:36:15 <srhb> imeredith: Odd.
02:36:27 <jle`> idk i just learned it from the irc channel
02:36:55 <BoR0> yeah  I think I get constraints with =>, but what does (* -> *) -> Constraint tell us?
02:37:01 <srhb> imeredith: Tried the whole recheck, redo ghc cache?
02:37:08 <imeredith> srhb: this happens to me every time i try and use haskell lol, not this specific but some issue with cabal, 2 years and counting, im determined this time though
02:37:14 <srhb> I'm just shooting blindly here, since I barely understand the mechanics. If someone wise wants to jump in, please.
02:37:15 <imeredith> srhb: what are the commands for that?
02:37:23 <jle`> BoR0: think of it as Constraint => types
02:37:30 <srhb> imeredith: ghc-pkg check && ghc-pkg recache
02:37:32 <jle`> so Monad m gives you a Constraint
02:37:47 <jle`> Monad m :: Constraint, so you can do Constraint => type signature
02:37:54 <BoR0> so it only tells us that there's a constraint, but not which one, because it's based on the concrete types?
02:38:01 <jle`> well
02:38:10 <jle`> you can only put constraints on the left hand side of =>
02:38:24 <jle`> it just means that 'this is something you can put to the left of =>'
02:38:30 <srhb> imeredith: The output might shed some light on what's going on
02:38:38 <iota_> I find it easier to understand with existential quantification
02:39:16 <imeredith> srhb:  hmm it says there are a bunch of brokwn things, is there a way i can force a reinstall of all packages i have installed?
02:39:28 <srhb> imeredith: you're not trying to install --global, right?
02:39:31 <iota_> forall m. Monad m => whatever m just means 'whatever m' only exists when m is a Monad
02:39:38 <tdammers> imeredith: throw away you current .cabal and .ghc
02:39:39 <srhb> imeredith: I'd say throw in a fresh haskell platform.
02:39:48 <srhb> At least if those are global problems
02:40:08 <srhb> But yeah, what tdammers said.
02:41:39 <imeredith> identity: well, its compiling something now!
02:43:39 <quchen> How long does Travis need to update to a new (major) compiler version? I haven't used it when the 7.4 → 7.6 jump happened. Can we expect 7.8 support in the near future?
02:44:22 <identity> when will they ship a new HP with 7.8?
02:44:29 <quchen> hvr: You see to be an expert in the area, is there a way we can use 7.8 although it's not officially supported by Travis?
02:45:08 <quchen> identity: It's being planned on the mailing lists right now. But you don't need the Platform, really -- you can just cabal install all the packages you want manually
02:46:09 <identity> quchen: Hmm, I guess. But it's a need vs effort thing. I don't really need it
02:46:22 <identity> (I just have this thing about having up to date software)
02:46:25 <srhb> identity: In my experience, it tends to end up the other way.
02:46:42 <srhb> identity: Once you have a working ghc and cabal-install, it's so much simpler than the Platform shenanigans
02:47:02 <imeredith> tdammers: well, same error, i guess ill reinstall haskell platofmr
02:47:08 <srhb> In fairness though it might be a while before everything is stabilized with 7.8
02:47:27 <quchen> I have a script "reinstall.hs" which outputs everything I need to go from GHC to Platform in an AFK manner. http://lpaste.net/102516
02:47:30 <srhb> Lemmih: Looking at you! ;-)
02:47:40 <identity> I'm fairly interested in the new IO manager. Wasn't that one supposed to improve concurrency performance, specifically stm and such?
02:47:41 <quchen> Paste to console, wait, done :-)
02:47:48 <srhb> identity: Massively
02:47:54 <srhb> Scalability at least.
02:48:02 <quchen> I'm excited for the new web framework benchmarks.
02:48:12 <srhb> quchen: I'm excited for the new web frameworks.
02:48:18 <identity> srhb: yeah, that was how I understood it as well.
02:48:20 <srhb> Seems like the cores are being rewritten all around.
02:51:06 <quchen> Are the 'llvm' and 'cgi' packages broken for anyone else by the way?
02:51:35 <quchen> I don't strictly need them so I filed the failed installations in the "new compiler issues" folder. Just wondering.
02:51:45 * hackagebot nlp-scores 0.6.2 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.6.2 (GrzegorzChrupala)
02:56:46 * hackagebot binary-conduit 1.2.1.1 - data serialization/deserialization conduit library  http://hackage.haskell.org/package/binary-conduit-1.2.1.1 (AlexanderVershilov)
03:01:20 <d3lxa> I've got a problem with classes and a Monad embedded function, here is a minimal example: http://sprunge.us/GKVK any help *really* appreciated, thx
03:01:33 <d3lxa> *a function embedded in a monad, extracted directly
03:02:21 <d3lxa> better sprunge with the error: http://sprunge.us/PHIP
03:02:26 <corgifex> you have several redundant elements in there
03:02:31 <corgifex> let's simplify
03:02:42 <corgifex> > (\f -> (f 'x', f ())) id
03:02:44 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’ with actual type ‘()’
03:02:59 <corgifex> > (id 'x', id ())
03:03:00 <lambdabot>  ('x',())
03:03:12 <d3lxa> corgifex: I tried to make a minimal non-working case, it's hard
03:03:19 <Cale> d3lxa: Your problem is that the type of bind (or even just lambdas by default) isn't higher rank polymorphic
03:03:50 <Cale> So, the result of myprintIO will end up having some specific type, not the polymorphic type you expect here
03:04:16 <d3lxa> Cale: yes, that's what I've learned the hard way, any way to work aronud?
03:04:27 <Cale> Well, yes
03:04:33 <Cale> But what are you actually trying to do?
03:04:37 <d3lxa> you're going to tell me to bind it twice?
03:04:48 <Cale> That would be one way
03:04:59 <Cale> You could also define a wrapper
03:05:23 <d3lxa> Cale: exactly what you see here, I use Yesod that have a render function like this: getMessageRender :: (MonadHandler m, RenderMessage (HandlerSite m) message) => m (message -> Text) and I can't see how to do it
03:05:55 <d3lxa> and I would like to use twice on two different instance of message
03:06:03 <Saizan> d3lxa: since the constraint is outside of 'm' there you'll have to bind it twice
03:06:45 <d3lxa> what do you mean, outside of m?
03:06:47 * hackagebot http-test 0.1.6 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.1.6 (glutamate)
03:07:59 <d3lxa> Cale: can you explain your idea of wrapper?
03:08:26 <Saizan> just like you can't do (a -> m b) -> m (a -> b) you can't go from   forall a. m (.. a ..)   to    m (forall a. .. a ..)
03:08:27 <d3lxa> Cale: something like a wrapper for the instance forall a. (message a) thing?
03:09:24 <Cale> Something like  data ShowInst = SI (forall a. Inst a => a -> String)
03:09:33 <d3lxa> Saizan: so basically, I can rewrite getMessageRender to put an explicit forall outside?
03:09:43 <Cale> But that's awkward
03:10:10 <Cale> You're probably meant to just execute the action again
03:11:48 * hackagebot imagemagick 0.0.3.5 - bindings to imagemagick library  http://hackage.haskell.org/package/imagemagick-0.0.3.5 (AlexanderVershilov)
03:51:52 * hackagebot FontyFruity 0.2 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.2 (VincentBerthoux)
04:00:50 <jtcwang> I got a funny question
04:01:11 <jtcwang> i'm using quickcheck, and my function requires a StdGen
04:01:28 <jtcwang> StdGen is not of Arbitrary typeclass
04:01:44 <jtcwang> my question is, how would I go about doing that
04:02:40 <ClaudiusMaximus> @hoogle String -> StdGen
04:02:41 <lambdabot> Prelude read :: Read a => String -> a
04:02:41 <lambdabot> Text.Read read :: Read a => String -> a
04:02:41 <lambdabot> Prelude error :: [Char] -> a
04:02:51 <merijn> Why String?
04:02:57 <merijn> :t mkStdGen
04:02:58 <lambdabot> Int -> StdGen
04:03:24 <jtcwang> hmm
04:03:51 <ClaudiusMaximus> merijn: ah fair enough, was thinking of this http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:StdGen
04:04:07 <jtcwang> would it be good enuf? since if I do (intVariable :: Int), it'll tend to start at 0
04:04:17 <jtcwang> i thought that's quickcheck
04:06:13 <merijn> jtcwang: "is that good enough?" <- depends on what you're testing
04:06:58 <jtcwang> what i'm saying is quickcheck will tend to start with a small number
04:07:31 <jtcwang> thus mkStdGen will more likely generate the same group of seeds
04:07:46 <jtcwang> but yeah i think its good enuf for my tests
04:07:46 <jtcwang> ty
04:08:53 <merijn> jtcwang: I mean, even "mkStdGen 0" will produce a good set of pseudo-random numbers, so that should be sufficient for your tests, I think
04:09:11 <merijn> "mkStdGen 0" is not "less" random than "mkStdGen 5683"
04:10:12 <jtcwang> what i'm saying is, since quickcheck does only around 100 tests
04:10:29 <jtcwang> and its random ints starts from 0
04:10:42 <jtcwang> we'll likely be testing the same stuff
04:10:55 <merijn> jtcwang: Right, but if the "correctness" of your tests doesn't depend on *which* StdGen you use you should still be fine, no?
04:11:10 <jtcwang> yeah but if the generator is biased
04:11:15 <jtcwang> then i might miss some test cases
04:11:18 <jtcwang> see where i'm coming at?
04:11:30 <merijn> Sure, but that applies to any random generator
04:11:47 <jtcwang> yeah, but isn't quickcheck biased?
04:11:58 <jtcwang> like it starts testing from 0, if you're generating an int
04:12:06 <jtcwang> biased by design
04:13:47 <jtcwang> but yeah, it should be alright
04:14:00 <jtcwang> just being pendantic
04:28:21 <fizruk> what is a correct way of saying that Applicative defines a monoid of effects? or is there?
04:33:13 <merijn> fizruk: Well, that seems like a reasonable way of putting it
04:33:44 <fizruk> merijn: thanks!
04:35:55 <merijn> What is a good way to let users write type level indices? Something like "get (undefined :: Proxy 5)" seems a bit cumbersome
04:36:42 <merijn> Is there a nicer way to lift something to the type level and provide it as argument to a function?
04:36:57 * hackagebot Rasterific 0.2 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.2 (VincentBerthoux)
04:37:28 <ClaudiusMaximus> get (Proxy :: Proxy 5)  might be more appropriate use of Proxy?
04:37:53 <merijn> ClaudiusMaximus: uh, right
04:38:12 <merijn> Anyway, regardless I don't think that's a nice thing to write
04:38:25 <Saizan> http://augustss.blogspot.se/2014/04/a-small-haskell-extension.html <- since there's this proposal i imagine there isn't much better on the table
04:39:02 <merijn> Saizan: That proposal tackles a different usecase, though
04:39:42 <BoR0> why can't I pattern match on derived type?. e.g. data Dog = Dog, data Cat = Cat, and I want f s.t. f Dog = "Woof" and f Cat = "Meow"
04:39:55 <Saizan> merijn: Example 2 is your use case
04:40:10 <Saizan> but iswym
04:40:10 <merijn> BoR0: Because Cat and Dog are not the same type?
04:40:10 <fizruk> Bor0: what do you mean by derived type? there's no such thing afaik
04:40:55 <BoR0> https://paste.softver.org.mk/4d0d6f3a09dfddd40e463822b2534f2b I'm trying to achieve this without using class/instance. e.g. I want doSomething to pattern match on a data type. but I'm missing something it seems
04:41:01 <Saizan> BoR0: you need a single type data CatOrDog = Cat | Dog if you want a function like that
04:41:53 <BoR0> ah, got it, yes
04:41:56 <Saizan> (you can complicate that with gadts though)
04:42:11 <pillar_Young> some layout things wrong in my code?
04:42:12 <pillar_Young> http://lpaste.net/102522
04:42:32 <merijn> Saizan: I don't see how his second example makes sense either
04:42:40 <merijn> Saizan: Unless he's implying changing the type of typeRep
04:43:09 <Saizan> pillar_Young: missing a ) on line 5
04:43:55 <merijn> Actually, maybe I'm going about this wrong
04:43:56 <Saizan> merijn: it makes sense with typeRep :: proxy a -> TypeRep, because ((->) T T) unifies with proxy a
04:44:23 <pillar_Young> thanks it's
04:44:27 <merijn> Maybe I should just use a type family as return type for "get" and just require an explicit annotation on the result of get
04:46:22 <merijn> So instead of "get :: proxy a -> b -> F a b" and writing "get (Proxy :: Proxy 5) foo" do "get :: b -> F a b" and make people write "get foo :: F 5 b"
04:46:55 <merijn> Although I'm open to better/nicer suggestions!
04:48:55 <merijn> Or maybe I should have a class instead of a datatype and so I can write a type annotation directly without a function...
04:50:06 <BoR0> I arrived at this. http://lpaste.net/102523 so is class/instance really just syntactic sugar for that, and nothing more?
04:51:06 <identity> anyone intricately familiar with repa? I changed my array type(e.g. a in Array r sh a) to a custom type, and was thus not able to use U as r anymore, and switching to delayed arrays means I cannot use fromList. What could/should I be using instead?
04:51:27 <identity> I'm using fromList right now to generate a random array from a list.
04:51:37 <Saizan> BoR0: nah, it's more general
04:51:59 * hackagebot generic-aeson 0.1.0.1 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.1.0.1 (AdamBergmark)
04:52:10 <Saizan> BoR0: well, i should say that some stuff is easier in one formulation than the other
04:52:22 <merijn> identity: I think U stands for unboxed, so you can only use those with datatypes that can be unboxed
04:52:34 <Saizan> BoR0: for example with classes you can add another instance of Animal without touching existing code
04:52:38 <BoR0> well, code is well organized using first approach and can be extended with instances easier. for the second approach you'd have to edit the data CatOrDog all the time, which is bad I guess
04:52:48 <Saizan> right
04:53:14 <Saizan> and CatOrDog makes it easier to define new operations
04:53:31 <BoR0> I started this discussion with a friend of mine. he has data Cat = Cat { name :: String } and data Dog = Dog { name :: String } but the conflict here is name. how can we achieve this kind of structure? is class/instance the way to go?
04:53:35 <identity> merijn: Yeah, I understood as much, and I was using it before as my array type was simply Bool before.
04:53:36 <ldrndll> BoR0: it’s more akin to creating a dictionary of functions for each instance
04:53:52 <identity> I would be able to use fromFunction if it allowed IO, which it does not
04:55:11 <ldrndll> BoR0: why exactly do you want name to be the same thing? do you want to be able to pass in any kind of named thing and get a name out, or is it just because you’d like to reuse name?
04:55:37 <ldrndll> as generally, people will just prepend the name of the record to distinguish between the two
04:55:41 <BoR0> is it conventional to go for dog_name and cat_name for all of the functions?
04:55:44 <BoR0> I see.
04:56:12 <BoR0> what if we wanted to work with JSON parser that the server has "name" in both cat and dog?
04:56:39 <BoR0> that the server (that serves the JSON)
04:58:02 <ldrndll> BoR0: using Aeson you could do something like
04:58:03 <ldrndll> http://lpaste.net/102527
04:58:36 <BoR0> so basically class/instance solves that problem for us
05:07:36 <fizruk> i've just observed that State applicative functor uses (s -> s) monoid to combine its effects. is there any such observation (applicative as monoid on effects) packed in a blog post or something?
05:12:01 * hackagebot monad-logger 0.3.6 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.6 (MichaelSnoyman)
05:12:03 * hackagebot yesod-core 1.2.12 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.12 (MichaelSnoyman)
05:21:51 <identity> Looking at http://hackage.haskell.org/package/base-4.7.0.0/docs/Foreign-Storable.html -- why is fixIO being used here?
05:22:48 <identity> in peekElemOff, that is.
05:28:42 <fizruk> hmm, i find it interesting that [] applicative kind of uses (Nat, 1, *) monoid for effects, while ZipList uses (Nat, 0, min) for those
05:30:58 <fizruk> err... (Nat, ∞, min)
05:32:16 <johannesbodannes> is there some haskell extension somewhere that lets me pattern match against functions? <_<
05:32:24 <johannesbodannes> err
05:32:25 <johannesbodannes> ghc
05:32:26 <johannesbodannes> extension
05:32:29 <fizruk> i guess, both (Nat, 0, +) and (Nat, 0, max) make no sense because pure would not use its argument
05:32:53 <fizruk> johannesbodannes: how could that be possible?
05:33:38 <johannesbodannes> not sure. i'm just trying to figure out a way to define a "cyclic" enum without having to define both bounded -and- eq
05:34:24 <johannesbodannes> i guess that's kind of a dumb thing to say
05:34:34 <johannesbodannes> ugh UGH
05:34:40 <johannesbodannes> so annoying
05:34:55 <fizruk> johannesbodannes: do you want something like  cycle [minBound..maxBound] ?
05:34:59 <johannesbodannes> wish there was a better way of handling minBound and maxBound
05:35:55 <johannesbodannes> nah, that list is perpetual forward, but not perpetual backwards. so you can define "next", but not a "prev" that works as expected
05:36:58 <fizruk> > [maxBound, pred maxBound .. minBound] :: [Bool]
05:36:59 <lambdabot>  [True,False]
05:37:30 <fizruk> johannesbodannes: use can use 2 lists: one forwards, one backwards
05:38:24 <fizruk> johannesbodannes: I can't see why you need Eq
05:39:24 <fizruk> :t [minBound..maxBound]
05:39:25 <lambdabot> (Enum t, Bounded t) => [t]
05:39:27 <johannesbodannes> all of the clean/complete implementations in my head had comparisons against maxBound and minBound
05:39:32 <fizruk> :t [maxBound, pred maxBound .. minBound]
05:39:33 <lambdabot> (Enum t, Bounded t) => [t]
05:40:00 <johannesbodannes> is there no other class anywhere that implements cyclic group-esque datatypes? <_<
05:40:12 <johannesbodannes> it seems like it'd be a common need!
05:40:15 <fizruk> johannesbodannes: ^ those 2 lists are all you need, no?
05:40:30 <fizruk> johannesbodannes: actually, I believe there is
05:40:47 <johannesbodannes> fantastic. where can I find that?
05:41:31 <fizruk> johannesbodannes: i don't remember where I've heard of one, let me do some lookup
05:42:05 * hackagebot riff 0.3.0.0 - RIFF parser for Haskell  http://hackage.haskell.org/package/riff-0.3.0.0 (RobertMassaioli)
05:47:20 <kmspriyatham> hi everyone. I am new to this channel.
05:49:00 <kmspriyatham> Can someone please tell me why foldl (:) [] [1,2,3] leads to an infinite type?
05:49:42 <bartavelle> kmspriyatham, compare the type of (:) with the first argument to foldl
05:49:48 <fizruk> johannesbodannes: sorry, can't find anything :(
05:49:58 <johannesbodannes> ah that's too bad, thanks anyway fizruk
05:51:16 <bartavelle> kmspriyatham, and you'll see you are not far off
05:51:43 <fizruk> johannesbodannes: hmm.. have you seen http://stackoverflow.com/questions/5684049/is-there-some-way-to-define-an-enum-in-haskell-that-wraps-around ?
05:52:07 <johannesbodannes> aha! i have not. this looks very interesting...
05:54:35 <kmspriyatham> bartavelle, thanks for the insight. I got it now.
05:54:43 <bartavelle> np
06:01:06 <johannesbodannes> ah
06:01:13 <johannesbodannes> yes actually, this is ingenious!
06:02:49 <johannesbodannes> thanks
06:03:39 <johannesbodannes> i appreciate that the implementation relates back nicely to the modulo operation
06:06:02 <fizruk> where can I find Alternative laws?
06:07:39 <klrr_> fizruk: http://www.haskell.org/haskellwiki/Typeclassopedia#Other_monoidal_classes:_Alternative.2C_MonadPlus.2C_ArrowPlus
06:08:25 <fizruk> klrr_: thanks!
06:08:51 * fizruk wonders why so many classes lack laws in documentation..
06:11:20 <fizruk> klrr_: hm.. there's no analogue for left catch or left distribution law for Alternative, but I guess they are quiet straightforward?
06:12:08 * hackagebot uuagd 0.1.0.2 - A debugger for the UUAG system.  http://hackage.haskell.org/package/uuagd-0.1.0.2 (MatthijsSteen)
06:16:40 <lpsmith> ugh,  moving code from one module to another is a lot harder than it should be
06:17:01 <lpsmith> getting the namespaces and extensions and everything else right :-/
06:17:09 * hackagebot treeviz 0.0.6 - Visualization of computation decomposition trees.  http://hackage.haskell.org/package/treeviz-0.0.6 (DavidBanas)
06:19:53 <luke_wm> ok, I can't grok the fold infinite type question ...
06:20:28 <luke_wm> (:) takes something and a list of something and gives back a list of something
06:22:28 <luke_wm> oh wait, got it ;)
06:22:33 <kmspriyatham> luke_wm, yes, you are right about that and foldl requires the first argument to be a function that takes something a list of something and spits out something (not a list of something) and this lead to an infinite type because the type of something should be the same as the type of list of something
06:25:32 <luke_wm> sweet , thanks!
06:25:47 <kmspriyatham> np
06:26:04 <kmspriyatham> is foldl tail call optimised?
06:27:43 <makalu> if I want to export field names of Foo I can use "Foo(..)". Is there any convenient way of exporting lenses of Foo?
06:29:40 <fizruk> am I right that Alternative version of the left distribution law holds for all the instances?
06:29:55 <fizruk> (f <|> g) <*> x = (f <*> x) <|> (g <*> x)
06:30:32 <fizruk> i can see why MonadPlus version does not hold for every instance, but Alternative seems to behave better here
06:30:58 <fizruk> e.g. the laws holds for Maybe
06:33:19 <fizruk> and iiuc IO and STM follow this one too
06:47:09 <makalu> how can I disable a GHC warning in a file?
06:47:23 <bergmark> {-# OPTIONS -wall #-}
06:47:24 <makalu> (missing top-level binding signature when using mkLenses)
06:47:27 <makalu> thanks
06:47:37 <bergmark> you should probably be more specific than that though
06:47:41 <podsnap_> Does anybody know where the frequently referenced http://haskell-workshop.github.io/tutorials/osx/2013-10-23-mavericks-ghc.html lives now?
06:48:08 <bergmark> -fno-warn-missing-signatures
06:48:54 <bergmark> podsnap_: no, but just installing from homebrew is the best in my experience
06:50:26 <podsnap_> I'll try that.  Thanks.  Never liked installers anyway...
06:52:45 <makalu> if I have multiple types with the same field names, am I supposed to use "foo ^. Module.bar"? That's a bit lame to be honest
06:53:22 <bergmark> makalu: for now, that's how to do it
06:53:50 <makalu> ok thanks
06:54:08 <bergmark> there will be record field overloading at some point
06:54:19 <supki> makalu: take a look at makeFields
06:54:27 <supki> it kinda sorta solves this problem
06:54:29 <makalu> I heard SPJ say it in his talk about lenses
06:55:43 <makalu> supki: I was experimenting with lens-family. Unfortunately, lens is too big to make it a dependency at the moment
06:56:15 <supki> well, you can do the thing makeFields does manually
06:56:21 <deweyvm> is it bad to make a type alias for a tuple? type Point = (Int,Int)
06:56:34 <makalu> manually as in make typeclasses or write TH code?
06:56:49 <supki> makalu: the former
06:57:03 <makalu> not much fun either :(
06:57:14 <makalu> I think I can get by with old fashioned Haskell at the moment
06:57:18 <makalu> but thanks for helping
06:57:32 <deweyvm> its a bit leaky because sometimes Int -> Int is more convenient, but other times (Int, Int)
07:02:14 * hackagebot multipart 0.1 - A partial fork of the cgi package exposing the multipart module  http://hackage.haskell.org/package/multipart-0.1 (AdamBergmark)
07:02:16 * hackagebot multipart 0.1.0.1 - A partial fork of the cgi package exposing the multipart module  http://hackage.haskell.org/package/multipart-0.1.0.1 (AdamBergmark)
07:07:23 <prinsen> Im combining pipes and condiut, and have a general question about composition. I want a forever that needs to be in both monads
07:07:50 <prinsen> http://lpaste.net/102528
07:08:18 <prinsen> doe's anyone understands what I want to do?
07:10:03 <serutsubi> I'm trying to write a function which takes three args. Lower bound (x), Upper bound(y), and a value (z) between 0 and 1. I want it to find all solutions to acos(z) which are in the interval [x,y]. How do I even start
07:12:50 <serutsubi> I tried doing something like: allcosines (x,y,z) = [k*a | k <- [-10,-9..3*y], k*a < y && k*a > x] where; a = acos(z)
07:14:05 <d34df00d> Hi.
07:14:29 <d34df00d> Is there any kind of abstraction or common pattern of combining two Data.Maps into one by performing a function on their values of corresponding keys.
07:14:56 <d34df00d> I want to have something like :: Map k a -> Map k b -> (a -> b -> c) -> Map k c
07:15:22 <deweyvm> @hoogle Map k a -> Map k b -> (a -> b -> c) -> Map k c
07:15:23 <lambdabot> Data.Map.Lazy intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
07:15:23 <lambdabot> Data.Map.Strict intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
07:15:23 <lambdabot> Data.Map.Lazy unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
07:15:37 <d34df00d> Oh, I missed intersectionWith, great.
07:15:42 <deweyvm> :)
07:15:52 <nh2> anybody seen this befor? Linking dist/setup-wrapper/setup ...unrecognized option `--sysconfdir=/home/niklas/.cabal/etc' Failed to install cairo-0.12.5.3
07:16:21 <d34df00d> And what about unions, something like unionWithKey, but I'd like to perform a function on the keys as well?
07:16:31 <int-e> @type M.mergeWithKey
07:16:32 <lambdabot> Ord k => (k -> a -> b -> Maybe c) -> (M.Map k a -> M.Map k c) -> (M.Map k b -> M.Map k c) -> M.Map k a -> M.Map k b -> M.Map k c
07:16:44 <int-e> oh. not on keys
07:16:51 <d34df00d> Yeah, I've seen it but was scared away by "Please make sure you know what is going on when using mergeWithKey, otherwise you can be surprised by unexpected code growth or even corruption of the data structure." :)
07:16:53 <dcoutts> nh2: yes, it's a bug that happens when a new cabal is talking to a Setup.hs using an old Cabal lib (by design new cabal should be able to talk to old Cabal lib, but we sometimes make mistakes)
07:17:16 * hackagebot rest-core 0.27.0.2 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.27.0.2 (AdamBergmark)
07:17:41 <d34df00d> I'm thinking of M.fromList [((k1, k2), f k1 k2 | k1 in m1's keys, k2 in m2's keys], but that seems somewhat kludgy for me.
07:17:43 <int-e> d34df00d: for modifying keys, you probably have to go through an intermediate list, though  mapKeysMonotonic  may sometimes be handy
07:18:04 <nh2> dcoutts: (how) can I make it use the new cabal lib?
07:18:11 <d34df00d> (i need to make a map of cortesian product of the keys of source maps)
07:18:41 <d34df00d> int-e: oh, thanks. mapKeysMonotonic will hardly help me here though :(
07:18:46 <int-e> d34df00d: basically the (M.Map k a -> M.Map k c) function can only modify values and filter the keys; it's not allowed to make up new keys.
07:19:39 <dcoutts> nh2: firstly, make sure it is installed. Then it should be just a matter of doing a clean build, i.e. cabal clean.
07:20:01 <dcoutts> nh2: ie check that the lib version reported by cabal --version is actually registered
07:23:23 <KristofDM> Hey people
07:30:19 <nh2> dcoutts: ah, I get it. Was because I'm using Cabal 1.19 from git, but that was only in my 7.6 ghc-pkg, while not in mye 7.8 ghc-pkg. Thanks
07:30:48 <merijn> Typeclass hackery question: Suppose I have a "class Foo a b where type Gettable a b :: *; get :: Foo a -> Gettable a b", is it possible to avoid having to manually add calls to "get" to the abstract datatype Foo? i.e. can I rewrite things so I can get away with "myFoo :: Gettable a b" instead of having to write "get myFoo :: Gettable a b"?
07:30:52 <nh2> dcoutts: On http://hackage.haskell.org/package/svgcairo, Home page and bug tracker are set to gtk2hs. Intended or copy-paste-error?
07:36:33 <petrie> I thought String and Char could be used interchangeably ?
07:36:51 <shiona> petrie: do you mean String and [Char] ?
07:37:03 <KristofDM> petrie, try putting the char between []
07:37:08 <petrie_> herm
07:37:19 * hackagebot hxt-unicode 9.0.2.2 - Unicode en-/decoding functions for utf8, iso-latin-* and other encodings  http://hackage.haskell.org/package/hxt-unicode-9.0.2.2 (UweSchmidt)
07:37:28 <dagle> @src String
07:37:29 <lambdabot> type String = [Char]
07:38:13 <petrie_> so why would I not be able to do "all isAlpha args" from "args <- getArgs"
07:38:32 <quchen> What is the source code? What do you want to do? What have you tried? What did your attempts amount to? What do you think was wrong?
07:39:31 <KristofDM> Anyone know what's going on here? http://screencloud.net/v/2EeG
07:39:56 <KristofDM> in the extractNumbers
07:40:06 <KristofDM> I did it manually in the interpreter
07:40:11 <KristofDM> checked the type of answer2
07:40:18 <deweyvm> where would i find the monad instances for [], Maybe, etc?
07:40:19 <KristofDM> and it said [(Int, Int)] as it should
07:41:16 <KristofDM> it says the return type is of type (Int, Int) in the file... Really confused
07:41:36 <petrie_> quchen: http://lpaste.net/1032115679572000768
07:41:40 <petrie_> Line 85
07:42:15 <petrie_> I am not sure how else I would convert args
07:42:20 * hackagebot hxt-tagsoup 9.1.3 - TagSoup parser for HXT  http://hackage.haskell.org/package/hxt-tagsoup-9.1.3 (UweSchmidt)
07:42:37 <quchen> petrie_: args :: [String], but all isAlpha :: String -> Bool.
07:44:05 <quchen> And "read (head ...))" is crazy unsafe. Use readMaybe and pattern matching for the list's head.
07:44:30 <sgronblo> very weird, i am installing a bunch of packages with cabal, and i get a warning for each comment line that contains an apostrophe
07:44:36 <petrie_> ok thanks!
07:44:43 <sgronblo> "missing terminating ' character"
07:44:49 <sgronblo> but its a comment!
07:45:19 <sgronblo> actually not only comments all f' functions too generate a warning
07:45:23 <sgronblo> seems broken
07:46:46 <merijn> Is there a nice "learning how to read Core" tutorial?
07:47:20 <lispy> merijn: I don't know of a tutorial, but I have some other sources
07:47:32 <bergmark> merijn: i think chrisdone wrote some things about it on his blog
07:47:49 <merijn> lispy: Other sources are welcome too
07:47:57 <lispy> merijn: okay. firing up evernote note
07:47:59 <lispy> now*
07:50:45 <nh2> dcoutts: https://github.com/gtk2hs/svgcairo/pull/1
07:50:53 <lispy> merijn: http://www.scs.stanford.edu/11au-cs240h/notes/ghc.html
07:51:32 <sgronblo> yeah my yesod install failed because a bunch of packages couldnt be installed
07:52:15 <lispy> merijn: http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/tldi22-sulzmann-with-appendix.pdf
07:53:27 <lispy> merijn: this one is old, but it was written for a course and includes exercises. It teaches you how to implement your own gmachine and works with an intermediate representation that is very similar to core: http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
07:53:48 <edwardk> @tell makalu use makeClassy ''Foo then you can export HasFoo(..)
07:53:48 <lambdabot> Consider it noted.
07:54:30 <lispy> merijn: http://book.realworldhaskell.org/read/profiling-and-optimization.html
07:54:34 <merijn> lispy: Thanks :)
07:54:46 <lispy> merijn: yw!
07:55:01 <merijn> Ugh, why couldn't haskell have dependent types >.>
07:55:42 <lispy> because they're not pratical yet, but haskell is a practical language :)
07:55:55 <lispy> (okay, okay, not a good argument because when it was new it probably wasn't seen as practical...)
07:56:18 <merijn> Yes, but it does mean my live becomes very hard when I want to decide which code to use based on a type
07:56:19 <supki> edwardk: will it export more than foo?
07:56:37 <merijn> Unless I use typeclass hackery, but I'm afraid said typeclass hackery will be to inefficient
07:57:04 <edwardk> supki: all the field lenses wind up in the class
07:57:05 <supki> edwardk: if so, I guess the documentation on makeClassy is incorrect then
07:57:22 * hackagebot hxt 9.3.1.4 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.4 (UweSchmidt)
07:57:29 <edwardk> probably
07:57:30 <supki> which is strange, since I've tried to copy generated splices carefully :(
07:59:06 <NikolajK> I'm doing a problem where you're supposed to count the number of words in a text file (a simpler version which counts the number of lines is already given). My version reads
07:59:06 <NikolajK> main = interact $ \file -> (show $ length $ myflatten $ words `map` lines file) ++ "\n"
07:59:06 <NikolajK> where "myflatten" is just a flatten function (myflatten xs = intercalate [] xs). Any suggestions for improvement?
07:59:32 <deweyvm> is there a way to do function composition in do notation? I have functions a -> a and i think the syntax would be nicer this way
08:00:20 <lispy> merijn: I think the main things you need to know are: a) that strictness is different in core, b) the naming conventions for core, c) the set of transformations that GHC applies (like the A normal form or whatever it's called), d) the optimizations that ghc does and when you can benefit from them
08:00:52 <lispy> merijn: the syntax of core is really just lambda calculus plus pattern matching
08:01:05 <merijn> lispy: I was more interested in a rough understanding of core to get a rough cost indication of the code that's being generated
08:01:17 <cschneid> Does anybody have advice on building larger haskell packages in a low-ram environment? I have a nitrous.io package to get ghc installed, but their free plan is a 384 meg ram box - up to 512 if you do some freebie tasks. That just doesn't compile a lot of packages, making it unusable
08:01:22 <lispy> merijn: in that case, the first link I sent you i s probably enough to get by
08:01:24 <cschneid> are there tricks to get ghc to not blow up?
08:01:25 <merijn> i.e. I wanna know how expensive it is to reify Int from nat
08:01:50 <lispy> cschneid: I doubt you can get it to work. There are some tricks.
08:02:42 <lispy> cschneid: you need to make sure that split-objs is disabled everywhere. This means you'll probably need a special build of ghc. (I don't know what the default setting is these days). You also need to diable it in your ~/.cabal/config
08:03:12 <suyase> haskell or erlang?
08:03:15 <lispy> cschneid: The biggest memory cost is the linker. You might have better luck with gold instead of bfd linker.
08:03:41 <carter> cschneid: don't add INLINE everywhere
08:03:51 <lispy> suyase: Haskell is probably better at DSLs. erlang is interesting for some things, but I don't know too much about it.
08:04:01 <carter> cschneid: if you want to make sure your code stays small,  add NOINLINE
08:04:01 <lispy> suyase: For me, Haskell because types.
08:04:08 <merijn> cschneid: Alternatively, compile on a bigger machine, move compiled code to small target?
08:04:21 <suyase> lispy: thanks =)
08:04:23 <carter> seriously, most projects that have long build times are doing LOTS of TH or lots of inlining
08:04:59 <merijn> carter: Tbh, 384 MB RAM is also really skimping on power :p
08:05:11 <quchen> gamegoblin: pong
08:05:12 <merijn> cschneid: I'm assuming this is some kind of VPS you wanna run your code on?
08:05:16 <carter> merijn: no
08:05:18 <sm> cschneid: adding +RTS -M200m or so can help
08:05:20 <lispy> cschneid: You should also make sure (by doing verbose builds) that ghc is passing the right flags to ld, where "the right flags" are something about the default hash table size. I forgot the actual flag.
08:05:22 <gamegoblin> quchen: ping
08:05:31 <carter> ghc actually has a known issue of needing some work to shrink its resource load
08:05:41 <quchen> gamegoblin: Had to leave just when you pinged me yesterday. Now I'm here for a bit
08:05:50 <cschneid> merijn: yeah, it's a free dev box :)
08:05:51 <gamegoblin> quchen: was just remarking that you’d responding to me on hackernews
08:05:54 <cschneid> merijn: nitrous.io is a free dev box in the cloud, which is cool for getting new people up
08:05:56 <cschneid> "hey, do 2 things and you're ready to go"
08:05:58 <gamegoblin> quchen: knew I recognized your handle
08:06:02 <merijn> cschneid: Ah
08:06:05 <cschneid> merijn: so I have a binary install of ghc and cabal - but then the user wants to install any packages, it blows up on them :)
08:06:11 <cschneid> well, not "any", but lots of common ones
08:06:16 <merijn> cschneid: Yeah, that's trickier then
08:06:23 <lispy> cschneid: does it blow up during 'cabal install' ?
08:06:29 <merijn> cschneid: I was thinking otherwise just dev locally and upload compiled binaries
08:06:29 <gamegoblin> quchen: something about strictness and the ! operator in Haskell
08:06:34 <cschneid> lispy: yeah, haven't dug in further
08:06:43 <merijn> cschneid: But that probably defeats the "introduce newbies" bit :p
08:06:47 <quchen> gamegoblin: Ah yeah, that strict fields are standard Haskell
08:06:51 <deweyvm> basically id like something like: add3 = let add1 = (+1) in do {add1; add1; add1}
08:06:52 <lispy> cschneid: If so, then that's usually due to memory requirements during linking. The split-objs thing has the biggest impact there.
08:06:56 <aloiscochard> is there some good introduction to machines?
08:07:04 <deweyvm> but this just gives me add1
08:07:14 <lispy> cschneid: people will see things like segfaults (exit code 11 from cabal)
08:07:36 <cschneid> lispy: that's a ghc compile time option you said?
08:07:55 <cschneid> because I can do that. I'll look into that. Need to do 7.8.{1,2} as soon as builds come out
08:07:57 <lispy> aloiscochard: This is about the best I've seen: https://github.com/glguy/TwosGame
08:08:10 <lispy> cschneid: yeah, it's a flag you set when you configure your ghc build. And it's a flag in cabal.
08:08:27 <merijn> hmm
08:08:29 <lispy> cschneid: you need to make sure users set it both places
08:08:58 <lispy> aloiscochard: and of course the slide deck linked in the haddocks for machines
08:09:03 <merijn> Do I want the type-level-numbers package if I want to reify Nat to a term level Int?
08:09:42 <aloiscochard> lispy: awesome thank you! hopefully I should be able to reuse what I know from scalaz-stream then :-)
08:10:06 <lispy> cschneid: search tihs page for "SplitObjs" https://ghc.haskell.org/trac/ghc/wiki/Building/Using
08:10:29 <lispy> aloiscochard: all the thanks should go to glguy for writing awesome examples :)
08:10:37 <lispy> glguy++
08:11:05 <aloiscochard> lispy: looks like he did an awesome job indeed! just what I like ... CODE! ;-)
08:11:18 <lispy> cschneid: My experience with haksell on vps is, you need 768 megs and 1GB is better still.
08:11:26 <cschneid> lispy: yeah, that's really too bad.
08:11:43 <lispy> I used to get by with 512 though, by improving the linker performance
08:11:54 <lispy> (the splitobjs, etc)
08:12:09 <lispy> I've never tried less than that
08:12:25 * hackagebot diagrams-lib 1.1.0.6 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.1.0.6 (jeffreyrosenbluth)
08:12:27 * hackagebot rest-core 0.27.0.3 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.27.0.3 (AdamBergmark)
08:12:29 * hackagebot rest-types 1.9.0.2 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.9.0.2 (AdamBergmark)
08:12:31 * hackagebot rest-snap 0.1.17.5 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.5 (AdamBergmark)
08:12:33 * hackagebot rest-gen 0.9.0.3 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.9.0.3 (AdamBergmark)
08:12:35 <cschneid> lispy: cool, it does indeed work for bare-bones learning haskell, where you're not trying to link stuff
08:12:40 <cschneid> but it doesn't compile snap or yesod, which is sad :)
08:12:55 <cschneid> since webdev is a good way to snag people into an ecosystem
08:13:14 <lispy> cschneid: ghc kind of abuses .o files to get ld to be more precise about linking. The result is huge memory consumption.
08:13:28 <cschneid> interesting. I've never dug into how ghc really works. I should at some point
08:13:47 <cschneid> do different -Os type flags help?
08:13:54 <lispy> cschneid: IIRC, when splitobjs = Yes, it puts each function in a separate .o file. the bfd ld (the default ld), creates something like a 1MB hashtable for each .o file it loads.
08:14:31 <lispy> I don't know the effect of the -O levels. For me, it was always the linker that was at fault.
08:14:37 <cschneid> ahh, hah. silly.
08:14:53 <cschneid> every time I learn anything about how computers work, my level of amazement that anything works at all goes up
08:15:43 <lispy> Learning how C does what it does is always enlightening in that way :)
08:15:58 <lispy> I guess I mean, anything below the level of C
08:16:12 <lispy> libc's implementation, kernel stuff, system calls, linkers, etc
08:17:08 <lispy> cschneid: you'll also want to avoid parallel builds
08:17:18 <lispy> (hopefully, the reason is obvious)
08:17:25 * hackagebot hemokit 0.6.1 - Haskell port of the Emokit EEG project  http://hackage.haskell.org/package/hemokit-0.6.1 (NiklasHambuechen)
08:17:35 <merijn> lispy++
08:17:55 <merijn> Most confusion I see in here about haskell libraries is people not understanding the basics of linking, etc. from C :)
08:19:22 <Nik05> what do i need to do to not let my computer hang because everything is written to swap because i made a small mistake in my program? :P
08:20:14 <lispy> merijn: If someone isn't familiar with linkers, send them to this page: http://www.lurklurk.org/linkers/linkers.html
08:20:37 <lispy> Nik05: You can use flag to limit the amount of memory it can use.
08:20:46 <geekosaur> Nik05, limit the heap size? try ./program +RTS --help
08:20:47 <lispy> I don't have them memorize...
08:20:48 <bennofs> Nik05: compile with -rtsopts, run with +RTS -M1000M (1000M is the maximum heap size)
08:20:56 <Nik05> ok thank you
08:21:13 <lispy> I forget, can you also do this with ulimit?
08:21:20 <lispy> There is some sort of resource command...
08:21:30 <fizbin> @type ($)
08:21:31 <lambdabot> (a -> b) -> a -> b
08:22:22 <lispy> Nik05: so, there is also this (with caveats): http://unix.stackexchange.com/a/44987
08:23:40 <fizbin> What's the default fixity of `foo` ? Is that infixl 9 the way otherwise un-infix-declared operators are?
08:23:59 <fizruk> fizbin: can you check that in ghci with :i ?
08:24:05 <geekosaur> isn't the default infixl 5?
08:24:08 <lispy> fizbin: it's in the report, but I think the default infix is 5.
08:24:22 <lispy> http://www.haskell.org/onlinereport/haskell2010/
08:25:34 <cschneid> lispy: thanks a bunch for giving me ideas to look into.
08:26:10 <cschneid> the ghc list indicated that a 7.8.2 might get rolled in a day or two also? So maybe not yet worth digging into?
08:26:53 <monochrom> linux's ulimit for main memory will not help because linux kernel's allocator is a lazy yes-man (think irrefutable pattern)
08:27:24 <lispy> fizbin, geekosaur: looks likke the default is infixl 9: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820004.4.2
08:27:27 * hackagebot diagrams-postscript 1.0.2.3 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.0.2.3 (jeffreyrosenbluth)
08:27:41 <fizbin> lispy: Yep, in the report, and ... yeah, I just found that spot.
08:28:13 <fizbin> Plus then double-checking that the definition of "varop" in the report includes `foo` as well as things like <~@
08:28:15 <lispy> monochrom: ah, interesting. So it doesn't get unforced until the kernel commits to giving you the memory?
08:28:48 <geekosaur> until you actually access it, probably; no reason to allocate the page until it's used
08:28:59 <int-e> monochrom: to be fair you can tell the kernel to not overcommit memory. I suspect quite a bit of software relies on that behaviour though, allocating more memory than needed.
08:29:01 <TallerGhostWalt> Is there a way to declare multiple type variables instances of a class?
08:29:10 <geekosaur> of course, a program should probably initialize the memory it uses
08:29:19 <TallerGhostWalt> Something like (Typeable x,y,z)?
08:29:25 <lispy> cschneid: The steps to build it will be the same. So you could figure out the steps but not deploy/test until then.
08:29:39 <cschneid> lispy: cool. not that I have time anyway :)
08:30:17 <lispy> TallerGhostWalt: You have to use the more verbose (Typeable x, Typeable y, ...)
08:30:46 <lispy> the syntax you mention might be a nice extension.
08:31:38 <dmj`> do you have to use base 4.7 w/ 7.8?
08:32:06 <geekosaur> base is wired in, yes, you can only use the base that comes with it
08:32:27 * hackagebot active 0.1.0.12 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.12 (jeffreyrosenbluth)
08:32:33 <lispy> cschneid: I think it was like: a) create Build.mk, b) add the line SplitObj = No; c) configure/build/install like normal, d) edit user's ~/.cabal/config. If you find yourself doing more than that, you may have gone down the wrong path.
08:32:37 <dmj`> geekosaur: thanks
08:32:56 <cschneid> lispy: cool - all those things are nice & easy w/ the way I need to setup the build script. Thanks
08:33:03 <TallerGhostWalt> lispy: okay thanks
08:37:08 <lispy> It would be kind of neat if you could do something like: (Functor m, Monad m, Applicative m, Functor n, Monad n, Applicative n) => ({Functor, Monad, Applicative}{m, n})
08:37:16 <lispy> Oh, my use of => is probably confusing
08:37:20 <lispy> I just mean, change to that syntax
08:37:28 * hackagebot diagrams-contrib 1.1.1.3 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.1.3 (jeffreyrosenbluth)
08:37:50 <lispy> But, if you're having constraints like that, maybe it's time to introduce a typeclass or something else to package things up.
08:40:39 <magicman> Type-level function :: '[k -> Constraint] -> '[k] -> Constraint.
08:41:50 <lispy> I'm not very good with constraint kinds and promotions yet. That takes a type level list of function from type to constraint and applies them to a list of types?
08:42:19 <lispy> Should the final type be [Constraint] ?
08:42:29 <fizruk> lispy: I have `type FMT f m t = (Functor f, Monad m, MonadTrans t, Monad (t m))` in one of my projects
08:43:10 <fizruk> lispy: [Constraint] can be concatenated into Constraint, iirc
08:43:23 <lispy> fizruk: and that works? I never thought to use `type` just for the class constraints like that.
08:43:40 <lispy> fizruk: eg., foo :: FMT f m t => ... ?
08:44:07 <fizruk> lispy: yes, with ConstraintKinds
08:44:13 <lispy> aaah
08:44:36 <lispy> thanks. I'll have to play with that :)
08:44:47 <lispy> Right now, I should probably head to work.
08:44:53 * lispy disappears
08:47:29 * hackagebot dual-tree 0.1.0.5 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.1.0.5 (jeffreyrosenbluth)
08:50:30 <ghc85> Are there any introductions on how to maintain two different versions of GHC (with cabal packages) on the same account?
08:50:35 <ghc85> I'm using Ubuntu 12.04
08:51:18 <alpounet> --with-ghc --with-hc-pkg flags, something like that, check the cabal-install manual
08:51:55 <alpounet> you could have $GHC78, $GHCHEAD, $GHC763, ready to be used, set in your env
08:52:30 * hackagebot monoid-extras 0.3.3.2 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.3.2 (jeffreyrosenbluth)
08:53:08 <ClaudiusMaximus> the thing that annoys me most about multiple ghc versions is the haddocks getting confuse
08:55:10 <ghc85> alpounet: Thanks, is there some kind of manual for it?
08:55:27 <ghc85> I tried installing 7.8 from source some months ago and it fucked everything up
08:55:35 <alpounet> ghc85: not that I know of, but these two flags and the similar ones in the cabal-install documentation should help you out
08:55:47 <ghc85> now I can't use things like monad transformers with the original ghc
08:56:05 <alpounet> you can if you point cabal-install to its path
08:56:11 <alpounet> which is what these flags are for
08:56:19 <ghc85> okay thanks :) will try it out
08:56:27 <sm> ghc85: it's pretty easy: add -w ghc-x.y to cabal commands when not using the most recently-installed ghc version
08:56:59 <alpounet> sm: you must also specify the ghc-pkg you want to use don't you?
08:57:17 <sm> not for installing stuff.. if you want to inspect the package db yes
08:57:32 * hackagebot dual-tree 0.2.0.2 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.2.0.2 (jeffreyrosenbluth)
08:57:32 <sm> at least that's been my experience
08:57:53 <alpounet> it used to be necessary at some point, or maybe i was doing something wrong. back when i tried out the llvm backend when it had just landed in HEAD
08:58:29 <alpounet> e.g when you're just cabal install'ing a package you work on
08:58:55 <ghc85> Is it possible to uninstall ghc installed from source?
09:00:04 <sm> yes
09:01:05 <jophish_> Out of interest, when is there going to be a new Haskell platform for GHC 4.8?
09:01:20 <sm> never
09:01:34 <geekosaur> 4.8?!
09:01:38 <sm> ask me anything, I'm on a roll
09:01:42 <bergmark> jophish_: if you +3 that, then soon!
09:01:43 <geekosaur> if you meant 7.8 then it's in progress
09:01:59 <ghc85> sm: okay :) how would one uninstall it when installed from source?
09:02:04 <geekosaur> expected release in May, if it doesn't get bogged down by idiocy...
09:02:05 <jophish_> err, yes my mind was on gcc!
09:02:35 <sm> ack. Find the files and remove them. Install again from source and watch what it did.
09:02:46 <ghc85> fair enough, thanks
09:03:54 <d3lxa> is there a tool in haskell to know which lines where executed or not? I need to debug a program but I need to know where my flow went by
09:04:10 <d3lxa> liftIO . print works but it's not very convenient
09:04:19 <bergmark> d3lxa: hpc
09:04:24 <monochrom> this is why I use "./configure --prefix=/usr/local/ghc-7.6.3-for-the-13th-time" to begin with. then I just have to erase /usr/local/ghc-7.6.3-for-the-13th-time
09:04:57 <d3lxa> bergmark: thx!
09:06:26 <sm> d3lxa: more options at http://hackage.haskell.org/packages/#cat:Debug
09:07:03 <bergmark> d3lxa: Debug.Trace is an ad-hoc lightweight option
09:08:08 <jophish_> Why does GHC have a single type (Type) to represent both types and kinds?
09:08:11 <d3lxa> bergmark: is Debug.Trace like print (you need to provide a string) right?
09:08:40 <fizbin> @type over
09:08:40 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
09:08:41 <bergmark> d3lxa: there's a bunch of different ones like traceShowId, check the docs
09:09:28 <d3lxa> hpc seems fine
09:10:17 <pordan30> Is there a package that implements inductive views on graphs, sets, and other similar types from the base library?
09:10:47 <monochrom> not in the base library, but FGL comes with Haskell Platform
09:11:30 <monochrom> err, lowercase, fgl
09:12:15 <tomejaguar> Are IORefs and their contents garbage collected just like any other variables?
09:12:27 <monochrom> yes
09:14:42 <joxn> Hello #haskell
09:15:13 <joxn> Is anyone here familiar with the exercism.io exercises for Haskell? I have some questions about robot-name.
09:15:29 <pordan30> monochrom: thanks - but i'm not entirely comfortable using fgl because of the reliance on 'error' over, e.g., maybe or the error class
09:15:54 <monochrom> yikes, it does error?
09:16:10 <monochrom> that is regrettable. I don't know of another graph theory lib
09:16:51 <quchen> FGL is from 2011. Maybe it was more acceptable to catch 'error's then or whatever. In any case, it could use some patching if you feel like it.
09:18:29 <quchen> (August 2011 was the GHC 7.2.1 release, so it's 4 major releases old.
09:18:31 <quchen> )
09:18:38 <fizbin> Why does lambdabot bother to respond to @info if it isn't going to say anything even vaguely useful?
09:18:43 <fizbin> @info on
09:18:43 <lambdabot> on
09:19:21 <Okasu> @info I like to talk
09:19:21 <lambdabot> I like to talk
09:19:37 <dwcook> @help info
09:19:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:19:45 <dwcook> o_0
09:19:47 <fizbin> @info @info is futile
09:19:47 <lambdabot> <unknown>.hs: 1: 1:Parse error: @
09:19:54 <fizbin> Interesting.
09:19:58 <quchen> Ha, so it's not id after all.
09:20:16 <fizbin> @info :type
09:20:16 <lambdabot> <unknown>.hs: 1: 1:Parse error: :
09:20:22 <dwcook> Currently my impression is "This plugin is terrible". Maybe it's secretly clever though
09:20:37 <fizbin> I know, right?
09:20:47 <fizbin> Maybe it's a game to figure out what it does?
09:21:29 <fizbin> @info Unterminated "quote
09:21:29 <lambdabot> <unknown>.hs: 1: 14:Improperly terminated string
09:21:30 <dwcook> lambdabot is probably correcting "info" to something else
09:21:33 <dwcook> But what?
09:23:36 <OrangeDuck> Hey, does anyone have a recommendation for a linear algebra library for Haskell. Speed doesn't matter to me so much as expressiveness. Something like Numpy with type checked broadcast operations would be awesome.
09:23:37 <NikolajK> I define
09:23:37 <NikolajK> let sexy = \x -> "boom chica wau wau " ++ (show x) ++ " oh, yeah"
09:23:37 <NikolajK> why doesn't it work on numbers, like "sexy 3"
09:23:53 <NikolajK> "a" ++ show 3 ++ "b"
09:23:53 <NikolajK> does work
09:23:57 <dwcook> NikolajK, you need to defined "doesn't work"
09:24:04 <dwcook> My guess is it can't pick a concrete type
09:24:14 <NikolajK> Prelude Data.List> let sexy = \x -> "boom chica wau wau " ++ (show x) ++ " oh, yeah"
09:24:14 <NikolajK> Prelude Data.List> sexy 3
09:24:14 <NikolajK> <interactive>:170:6:
09:24:14 <NikolajK>     No instance for (Num ()) arising from the literal `3'
09:24:14 <dwcook> define*
09:24:14 <NikolajK>     Possible fix: add an instance declaration for (Num ())
09:24:14 <NikolajK>     In the first argument of `sexy', namely `3'
09:24:15 <NikolajK>     In the expression: sexy 3
09:24:15 <NikolajK>     In an equation for `it': it = sexy 3
09:24:16 <NikolajK> Prelude Data.List>
09:24:27 <dwcook> NikolajK, it's trying to default to () in absence of other type information
09:24:31 <dwcook> Give it an explicit type signature
09:24:50 <NikolajK> so what do
09:24:55 <dwcook> (3 :: Integer) for example
09:25:01 <NikolajK> …
09:25:19 <NikolajK> but I can't do that inside a function, no?
09:25:20 <dwcook> 3 is polymorphic – It can be a value of any type that's an instance of Num
09:25:24 <dwcook> @type 3
09:25:25 <lambdabot> Num a => a
09:25:45 <dwcook> NikolajK, you can do it anywhere you like, but if you want the function to be polymorphic, then you should do it at or before the point you pass something in
09:26:07 <fizbin> ghci> let sexy = \x -> "boom chica wau wau " ++ (show x) ++ " oh, yeah"; sexy :: (Show a) => a -> String
09:26:07 <fizbin> ghci> sexy 3
09:26:07 <fizbin> "boom chica wau wau 3 oh, yeah"
09:26:14 <dwcook> > (\x -> "boom chica wau wau " ++ (show x) ++ " oh, yeah") (3 :: Integer)
09:26:15 <lambdabot>  "boom chica wau wau 3 oh, yeah"
09:26:56 <fizbin> NikolajK: In ghci, you need to provide a type signature for your function in the same let clause as when you define it.
09:27:33 <dwcook> Oh this was the DMR at work
09:27:41 <dwcook> Or… no
09:27:54 <fizbin> NikolajK: So use the semicolon and add the type as I did after the definition.
09:28:09 <fizbin> Or be conventional and put the type before the definition.
09:28:30 <NikolajK> okay, thank you
09:28:31 <NikolajK> didn't know the (x :: Integer) syntax works like that too
09:28:47 <NikolajK> not in Haskell at least, I know\lambda(x:N).f(x)
09:28:52 <dwcook> Ah yeah, it was the DMR. I didn't realize ghci did that
09:29:08 <quchen> 7.8 GHCi, now without DMR! :-)
09:29:20 <fizbin> Here's what's going on when you don't specify the type:
09:29:28 <NikolajK> so ghci accepts ";" :P
09:29:45 <dwcook> ghci accepts most valid Haskell code
09:29:47 <fizbin> λ: let sexy = \x -> "boom chica wau wau " ++ (show x) ++ " oh, yeah"
09:29:47 <fizbin> λ: :type sexy
09:29:47 <fizbin> sexy :: () -> [Char]
09:30:01 <dwcook> (And some things that aren't valid Haskell code, like :t)
09:30:23 <fizbin> (My ghci prompt is set to "λ:" because I'm weird like that)
09:31:00 <NikolajK> let sexy = \(x :: Integer) -> "boom chica wau wau " ++ (show x) ++ " oh, yeah"
09:31:00 <NikolajK> doesn't work, right?
09:31:20 <ghc85> > GHC 7.8.1 only works with cabal-install version 1.18 or later. Please upgrade if you have an older version of cabal-install.
09:31:21 <lambdabot>  <hint>:1:79: parse error on input ‘if’
09:31:29 <ghc85> How is best to install cabal?
09:31:31 <quchen> NikolajK: Not in standard Haskell, but ScopedTypeVariables allows you to use that syntax
09:31:50 <ghc85> should I use the existing cabal from the package manager or pull from github
09:31:51 <fizbin> Note that it you don't say it as a lambda expression, ghci infers the correct type from the start:
09:31:53 <NikolajK> thats a package or a dialect?
09:31:53 <fizbin> λ: let sexy x = "boom chica wau wau " ++ (show x) ++ " oh, yeah"
09:31:54 <fizbin> λ: :type sexy
09:31:54 <fizbin> sexy :: Show a => a -> [Char]
09:31:58 <dwcook> ghc85, don't pull from Github :(
09:32:03 <dwcook> ghc85, use a distro package or binary distribution
09:32:06 <quchen> NikolajK: It's a GHC extension.
09:32:23 <ghc85> dwcook: But the distro package is too old
09:32:31 <dwcook> ghc85, then use a binary distribution
09:32:36 <fizbin> NikolajK: ScopedTypeVariables is a LANGUAGE pragma in compiled code; in ghci you enable it with :set -XScopedTypeVariables
09:32:51 <dwcook> ghc85, http://www.haskell.org/haskellwiki/Cabal-Install#Installation
09:32:59 <ghc85> okay thanks dwcook
09:33:18 <c_wraith> I really wish ghci would enable extensions from LANGUAGE pragmas in files you :load
09:33:26 <dwcook> ghc85, of course, pulling from Github is okay if you want to get involved in the development of cabal :)
09:33:41 <dwcook> But not if you want an actual working version
09:33:42 <ghc85> dwcook: are there any low hanging fruits?
09:33:50 <dwcook> I don't know, I'm not on the project
09:33:58 <dwcook> Or rather, I haven't checked out the project
09:33:59 <fizbin> c_wraith: Why? It doesn't automatically import stuff :load'ed files import.
09:34:11 <fizbin> c_wraith: It enables them for the duration of that file.
09:34:25 <c_wraith> fizbin: when you :load a file, you have the imports from that file in scope
09:34:32 <duairc> http://lpaste.net/102533
09:34:41 <duairc> Can anybody help me with this?
09:34:50 <c_wraith> fizbin: assuming it interpreted the file, rather than loaded it from a .hi
09:34:50 <fizbin> Oh, really? Well, that's different then - I hadn't noticed that effect.
09:35:04 <bitemyapp> augur: I agree.
09:35:15 <fizbin> Ah, that's it then. I'm almost always loading from cabal-compiled code.
09:35:38 <dwcook> duairc, existential quantification perhaps
09:35:46 <c_wraith> really, :load is so different depending on whether it's interpreting or using pre-compiled things, it shouldn't be the same command
09:36:43 <fizbin> As an aside, WTF Data.Function.on? Why would anyone define anything as (infixl 0), making it impossible to mix with ($) ?
09:37:27 <duairc> dwcook: How do you think existential quantification would help?
09:37:51 <duairc> Or like, where do I use it exactly to get what I'm looking for?
09:37:55 <dwcook> duairc, it would prevent your phantom type variables from escaping a specific scope
09:38:50 <dwcook> The way to do it hasn't fully formed in my head, but I think that's the right direction to look
09:39:25 <fizbin> c_wraith: The only time I invoke ghci as "ghci", it's to try out tiny stuff for discussions in #haskell. For work it's all "cabl repl", which compiles everything first.
09:42:18 <stevely> is anyone using 7.8.1 on windows? I'm getting linker errors when trying to link against network
09:46:13 <c_wraith> did the singletons stuff get moved out of GHC.TypeLits?
09:50:05 <c_wraith> Huh.  It got changed completely.
09:54:58 <quchen> fizbin: Similar issue: Control.Parallel.Strategies.using
09:58:53 <c_wraith> edwardk: the new singleton stuff in GHC.TypeLits is way easier to use, but it's also a huge change.  When did that get changed?
10:11:50 <thinkpad20> hey guys, can anyone tell me why I'm getting a stack overflow here? I'm writing an evaluator for a language I'm working on, which has for-loops. The code to evaluate the for-loop is here (https://github.com/thinkpad20/llama/blob/master/src/Evaluator.hs#L60). When the number of iterations is sufficiently large, I get a stack overflow, but I don't see why, because the loop should be tail-recursive. What can I do to stop the overflow
10:13:47 <tromp> loop doesnt look tail recursive
10:14:01 <tromp> its body is monadic
10:15:18 <thinkpad20> right, but inside the `loop` code, the only possible outcomes are two returns, and `loop` itself
10:16:26 <c_wraith> that doesn't make it tail-recursive unless >> and >>= are defined very carefully to allow it to be
10:16:27 <tromp> loop doesnt evaluate to loop. loop evals to some monadic value with another loop embedded inside
10:16:46 <tromp> and your monads includes state
10:17:25 <thinkpad20> the monad is a state but internally it's using IORefs and mutable hash tables
10:17:31 <thinkpad20> so it shouldn't accumulate anything
10:17:37 <thinkpad20> and the for loop that it's bombing out on is a line like this: `result = 0; for i = 1; i < 100000; i += 1 { result += i }`
10:17:42 * hackagebot rest-client 0.2.3.2 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.2.3.2 (AdamBergmark)
10:17:44 * hackagebot rest-gen 0.9.0.4 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.9.0.4 (AdamBergmark)
10:17:45 <c_wraith> but how are >>= and >> defined?
10:17:46 * hackagebot rest-happstack 0.2.9.5 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.9.5 (AdamBergmark)
10:17:48 * hackagebot rest-snap 0.1.17.6 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.6 (AdamBergmark)
10:17:59 <thinkpad20> it's an ErrorT StateT IO
10:18:15 <c_wraith> thinkpad20: the only thing that matters is whether >> and >>= are defined to allow tail calls
10:19:00 <thinkpad20> c_wraith: I haven't looked into the ErrorT implementation, but is it not defined in such a way?
10:19:03 <tromp> you cannot tail recurse over a State(T) monad, no matter whether you use IORefs are not
10:19:11 <dEPy> hi
10:19:16 <thinkpad20> argh, well that's the problem then
10:19:31 <c_wraith> thinkpad20: well, ErrorT's implementation depends on the underlying monad. And yeah, StateT is the problem there
10:19:36 <thinkpad20> then how should I encode loops?
10:19:38 <dEPy> Is there a connection between algebraic data types in haskell and BNF notation?
10:20:06 <dEPy> they seem similar to me (read 'untrained eye')
10:20:18 <davidfetter> everything in the universe is related one way or another ;)
10:20:27 <c_wraith> except cats and dogs.
10:20:34 <geekosaur> dEPy, I think they draw on the same inspiration
10:20:35 <c_wraith> Just ask 'em
10:20:41 <davidfetter> as mammals, they have a common ancestor
10:20:46 <dEPy> :)
10:21:42 <tromp> dunno, thinkpad20, requires more thought than i have time for now:(
10:21:56 <thinkpad20> Isn't that a pretty big limitation on StateT, that you can't write tail-recursive code with it?
10:22:25 <thinkpad20> what's the general strategy for writing stateful code with tail-recursion?
10:22:30 <thinkpad20> (if there is one)
10:22:57 <rento> Is there any exciting platform where haskell can actually be used? Is Heroku still awkward? Appengine and mobile phones is no go.
10:23:25 <c_wraith> rento: GHC 7.8.1 (released yesterday) compiles to iOS just fine
10:23:46 <c_wraith> rento: or did you mean you don't consider mobile phones exciting?
10:23:52 <corgifex> thinkpad20: the general strategy is to not use tail recursion because function calls don't use the stack anyway
10:23:56 <rento> interesting. so you can really write iPhone apps with it without any hasssle?
10:24:02 <tromp> the strategy is to move the whole state forward, and allow old state to be garbage collected
10:24:24 <c_wraith> rento: well, there's some hassle, in that you still need to make it play nicely with XCode.  But people have done it for a while now.
10:24:50 <thinkpad20> so, does that mean explicit threading? Or should I put my state in an IORef or similar?
10:24:54 <rento> c_wraith: and what about resource usage? Are the haskell programs not to big?
10:25:01 <tromp> try evaluate one iteration at a time in your main loop?!
10:25:20 <c_wraith> rento: like I said, people have done it for a while.  But that's about all I know on the topic.
10:25:50 <tromp> i think that wld work
10:26:28 <thinkpad20> tromp: I'm not sure how I would do that... it's not like Haskell gives you control over the garbage collector.
10:26:49 <thinkpad20> I guess I could write my own custom state monad, which is tail-recursive... or something.
10:27:00 <tromp> forget GC; try handling one iteration  only in our For case
10:27:13 <thinkpad20> I'm not sure what you mean
10:27:48 <corgifex> I don't understand yet which part actually overflows
10:27:57 <thinkpad20> in the `loop` code, a single iteration occurs on line 66, `eval body`. That's one iteration
10:28:29 <corgifex> what's the definition of Eval?
10:28:53 <thinkpad20> type Eval = ErrorT ErrorList (StateT EvalState IO)
10:29:07 <tromp> consider For to be syntactic sugar for an If followed by another For (with a later start)
10:29:11 <thinkpad20> data EvalState = ES {esStack :: [Frame], esInstrCount :: IORef Int }
10:29:43 <thinkpad20> and a frame consists of a hash table and an argument
10:30:01 <tromp> so each loop iteration will be handled by a new eval calll
10:30:04 <thinkpad20> tromp: isn't that what I'm doing?
10:30:10 <corgifex> tromp: ?
10:30:15 <tromp> no, you're trying to recurse on loop
10:30:22 <tromp> you can instead tail recurse on eval
10:30:42 <tromp> by expanding the For as syntactic sugar
10:31:09 <thinkpad20> but that would still effectively be the same thing; after all `loop` is just a series of `eval` calls anyway
10:31:37 <tromp> no, calling eval on expanded For is actual tail recursion
10:31:57 <corgifex> I don't get it
10:32:46 <tromp> try it; replace eval (For start ...) by  eval (If ... else (For (start+1...)))
10:33:03 <corgifex> that makes no sense
10:33:19 <thinkpad20> I'm really not convinced, I think you still end up with the same problem
10:33:20 <corgifex> you can't add 1 to actions
10:33:58 <thinkpad20> I think the problem is StateT; I'm just going to have to write a custom monad which doesn't persist its state
10:33:59 <tromp> try it; replace eval (For start ...) by  eval (If ... else (For (do step ....)))
10:34:38 <tromp> hmm, you also have to move the start out of there
10:34:43 <corgifex> that's still a few calls to >>=
10:35:27 <tromp> that's ok because you wont get to the nested For until some eval calls later
10:35:49 <tromp> and you won't be needing the old state anymore
10:36:14 <thinkpad20> I know I won't be needing the old state anymore, but Haskell doesn't; that's the problem
10:36:17 <corgifex> which part in the current code hangs on to old state?
10:36:42 <thinkpad20> corgifex: StateT does
10:37:02 <tromp> the nested loop calls over StateT inside the original eval For call
10:37:09 <corgifex> thinkpad20: StateT doesn't contain state
10:37:24 <tromp> its inner monad does
10:37:28 <tromp> sorry
10:37:30 <corgifex> what
10:37:46 <thinkpad20> lol I'm confusing myself
10:37:53 <tromp> StateT has the state in addition to its inner mondad
10:38:02 <corgifex> no, it doesn't
10:39:23 <corgifex> right now my confusion is twofold: 1) I don't see where loop hangs on to old state, and 2) I don't see why doing so would cause a stack overflow
10:39:27 <thinkpad20> corgifex the problem is the definition of bind for StateT is not tail-recursive
10:39:35 <corgifex> thinkpad20: impossible
10:39:36 <thinkpad20> that was what was confusing me too
10:39:46 <corgifex> stack overflow isn't caused by recursion
10:40:09 <ReinH> It shouldn't matter that it's not tail-recursive
10:40:20 <ReinH> it matters more whether it's strict, which it isn't
10:40:49 <ReinH> when you say "stack overflow", which stack are you referring to?
10:41:37 <ReinH> tail call recursion isn't very important for Haskell's runtime because there isn't a call stack to optimize
10:42:09 <thinkpad20> Stack space overflow: current size 8388608 bytes. Use `+RTS -Ksize -RTS' to increase it.
10:42:22 <thinkpad20> that's the error I'm getting
10:42:44 <thinkpad20> when I evaluate a long for-loop in my REPL
10:42:44 <levi> corgifex: I think it might be more correct to say that recursion (even outside of tail position) doesn't necessarily cause "stack overflow" in haskell. But the error reported as "stack overflow" is generally caused by recursion.
10:43:18 <corgifex> not by recursive function calls, though
10:43:25 <ReinH> You might want to look at http://www.haskell.org/haskellwiki/Stack_overflow
10:43:34 <ReinH> What's important is `guarded' recursion, not tail call recursion per se
10:43:46 <corgifex> ReinH: how does that apply in this case?
10:44:01 <thinkpad20> I'm not using folds
10:44:17 <thinkpad20> and the fields in the ASTs I'm using are all strict
10:44:17 <levi> corgifex: Yes, by recursive function calls. Unless I'm misunderstanding what you mean by "recursive function calls".
10:44:17 <ReinH> you're generating thunks
10:44:30 <ReinH> thinkpad20: can we see the code?
10:44:36 <thinkpad20> oh yes sorry
10:44:38 <corgifex> levi: function calls don't use a stack
10:44:52 <corgifex> https://github.com/thinkpad20/llama/blob/master/src/Evaluator.hs#L60
10:44:58 <thinkpad20> Data definitions here: https://github.com/thinkpad20/llama/blob/master/src/EvaluatorLib.hs and the problematic part here: https://github.com/thinkpad20/llama/blob/master/src/Evaluator.hs#L60
10:45:27 <levi> corgifex: That doesn't mean they don't cause "stack overflow" errors.
10:45:34 <corgifex> yes, it does
10:46:12 <ReinH> corgifex: they do use a stack. They use a pattern matching stack.
10:46:34 <tromp> how can your language have for-loop starts but no sequencing?
10:46:55 <thinkpad20> tromp, I'm not sure what you mean
10:47:04 <corgifex> ReinH: for what?
10:47:11 <ReinH> corgifex: ... for pattern matching.
10:47:18 <corgifex> function calls don't use pattern matching
10:47:22 <ReinH> thinkpad20: I suspect that bind in your monad is non-strict
10:47:27 <ReinH> corgifex: uh.
10:47:34 <ReinH> corgifex: yes they do?
10:47:37 <thinkpad20> yeah, that's what I was told by others
10:47:39 <KristofDM> Hey guys. Anyone care to help me out here? What's going wrong here: http://screencloud.net/v/2EeG I've no clue whatsoever and been with this problem for some time now...
10:47:42 <corgifex> ReinH: for what?
10:47:48 <ReinH> corgifex: for pattern matching?
10:47:57 <tromp> does your language have sequencing?
10:47:58 <corgifex> they use pattern matching for pattern matching?
10:48:01 <ReinH> yes?
10:48:02 <corgifex> tautology detected
10:48:10 <thinkpad20> are the ErrorT and StateT in Control.Monad by default lazy?
10:48:11 <ReinH> f Nothing = ... <- pattern matching
10:48:19 <corgifex> ReinH: it's also not a function call
10:48:25 <ReinH> corgifex: I don't understand how you would claim that pattern matching doesn't happen when functions are called
10:48:31 <tromp> oh, you have Block
10:48:34 <ReinH> since it's such a basic part of the Haskell langauge
10:48:35 <thinkpad20> tromp, not sure what you mean by sequencing
10:48:38 <corgifex> I don't understand how you would claim it does
10:48:41 <thinkpad20> yes, it's block-based
10:48:47 <levi> corgifex: Perhaps you could explain your understanding of how a "stack overflow" error occurs, then? Maybe we've got a terminology mismatch here.
10:48:48 <ReinH> corgifex: what do you think happens when f is called?
10:48:56 <c_wraith> KristofDM: I don't think you want that return.  I think you want to remove line 29 entirely, and remove the let from line 28
10:49:16 <c_wraith> KristofDM: make line 28 just the list comprehension, and have it be the last line of the do block
10:49:25 <corgifex> ReinH: the body of f is inserted with its parameter replaced by the argument
10:49:27 <c_wraith> KristofDM: which then, of course, means you don't need a do block
10:49:38 <c_wraith> KristofDM: you could instead move all of those definitions to a where block
10:49:54 <c_wraith> KristofDM: and the list comprehension would just be the result of the function, without a do block
10:50:04 <OrangeDuck> Hey, is there any way I can use a constant integer value like a type?
10:50:10 <ReinH> corgifex: if I have: f :: Maybe String -> String; f (Just a) = a; f Nothing = "Nothing"
10:50:14 <corgifex> levi: nested pattern matching / thunks, basically
10:50:23 <c_wraith> OrangeDuck: yes, but what do you want to do with it?  It only works for some things.
10:50:36 <ReinH> corgifex: and I call f Nothing, how can you claim that Haskell doesn't do pattern matching when it determines to use the branch that provides "Nothing"?
10:50:38 <corgifex> ReinH: that's syntactic sugar for f = \x -> case x of Just a -> a; Nothing -> "Nothing"
10:50:55 <corgifex> ReinH: f Nothing is (case Nothing of Just a -> a; Nothing -> "Nothing")
10:51:01 <corgifex> function call done
10:51:07 <ReinH> corgifex: are trying to make some distinction between function application and evaluation?
10:51:14 <c_wraith> OrangeDuck: since GHC 7.6, the DataKinds extension allows type-level natural literals..  But they have very limited use.
10:51:24 <tromp> is   For start cond step body  equivalent to   Block  [start, If' cond (For (Block []) cond step body)]  ?
10:51:29 <corgifex> very much so
10:51:30 <OrangeDuck> c_wraith - Well I'm vaguely thinking about ways to implement a type safe fixed size array type thing
10:51:47 <tromp> sorry, forgot some step and body in there
10:51:49 <OrangeDuck> for example to compose two arrays together of different fixed lengths would be a compile error
10:52:02 <levi> corgifex: Well, I think it would be difficult to write out a pattern match that nests deeply enough to cause that error, so how would you describe the way such an error-causing construct would be expressed?
10:52:02 <ReinH> corgifex: and you think this distinction is relevant?
10:52:15 <tromp> is   For start cond step body  equivalent to   Block  [start, If' cond (For (Block [body, step]) cond step body)]  ?
10:52:40 <c_wraith> OrangeDuck: you can do that just fine.  It gets tougher when you want to do arithmetic.  If you concatenate two arrays, the result is going to require math which GHC doesn't really support yet.
10:53:04 <OrangeDuck> c_wraith - right I can see that being a problem
10:53:11 <KristofDM> sheesh, c_wraith !
10:53:15 <KristofDM> Thanks a lot man :D
10:53:39 <thinkpad20> tromp: that's one way to do it, yeah
10:53:40 <corgifex> levi: sorry, I have to think about ReinH's question
10:53:51 <c_wraith> OrangeDuck: you can *express* the math, but GHC doesn't calculate with it, so you get lots of error messages like being unable to determine m ~ n from (m + 1) ~ (n + 1)
10:53:57 <OrangeDuck> c_wraith - perhaps template haskell will be a better approach
10:54:00 <ReinH> corgifex: can we just talk about "function evaluation" instead of "function calling" and move on?
10:54:13 <corgifex> ReinH: what is function evaluation?
10:54:24 <thinkpad20> But that's not really a meaningful syntactic sugar because it still has a For in there
10:54:40 <thinkpad20> you could think of a For as a sugared While-loop, but there is no While in my language
10:54:44 <tromp> thinkpad20: try eval For like that and let me know if you still overflow stack
10:54:50 <OrangeDuck> c_wraith - cool. Thanks for the info. I'll have some more of a think
10:55:23 <thinkpad20> tromp, that really wouldn't help, because it still contains a for-loop, and would go through an identical series of steps.
10:55:25 <c_wraith> OrangeDuck: the DataKinds extension enables this, and the GHC.TypeLits module defines useful types and functions, if you want to play with it and see the limits
10:55:40 <ReinH> corgifex: at what point would you claim that pattern matching happens?
10:55:47 <c_wraith> OrangeDuck: I think it's only supported on GHC 7.6+, and the design of GHC.TypeLits changed a lot between 7.6 and 7.8
10:55:57 <c_wraith> OrangeDuck: so it's far from settled :)
10:56:52 <ReinH> corgifex: the point being, if we're talking about the behavior of the pattern matching stack, there's not much point in talking about function application
10:56:55 <corgifex> ReinH: when an expression of the form 'case ... of ...' is evaluated but I haven't thought this through
10:57:15 <OrangeDuck> c_wraith - Thanks. All the extensions to the Kinds system of Haskell are really exciting :)
10:57:25 <c_wraith> OrangeDuck: I agree. :)
10:58:14 <ReinH> corgifex: I thought that "calling a function" included pattern matching in common usage rather than just referring to normalization
10:58:27 <ReinH> since it isn't a defined term afaik
10:58:35 <corgifex> ReinH: but what pattern?!
10:58:43 <ReinH> corgifex: really?
10:58:49 <corgifex> yes
10:58:53 <ReinH> corgifex: in which context are you asking that question?
10:59:08 <corgifex> I don't understand the question
10:59:15 * ReinH sighs
10:59:21 <ReinH> are you claiming that Haskell never does pattern matching?
10:59:26 <corgifex> ... no?
10:59:29 <ReinH> Are you claiming that the code we're talking about doesn't do pattern matching?
10:59:36 <ReinH> In what context are you asking "what pattern?"
10:59:40 <corgifex> I wasn't aware we were talking about code
10:59:49 * ReinH sighs
10:59:50 <ReinH> Ok. Never mind.
10:59:56 <corgifex> you said "I thought that "calling a function" included pattern matching"
11:00:04 <levi> corgifex: You are being too pedantic.
11:00:11 <corgifex> and I don't understand what you're referring to
11:00:20 <corgifex> levi: what
11:00:22 <ReinH> corgifex: and you defined "function call" as "function application" and gave me a tautological answer
11:01:14 <corgifex> levi: if I was "less pedantic", would I then magically understand?
11:01:15 <aloiscochard> carter: maybe better to continue here :-) ty btw
11:01:54 <corgifex> ReinH: what was tautological?
11:01:59 <levi> corgifex: Are you really "not understanding" or are you trying to make some sort of point? I can't tell.
11:02:15 <ReinH> corgifex: defining "function call" as "function application" and then claiming that calling a function doesn't perform pattern matching because application doesn't perform pattern matching
11:02:33 <ReinH> sure, if you want to define it that way
11:02:35 <corgifex> levi: I really don't understand
11:03:04 <corgifex> ReinH: I wasn't aware there was another definition of "function call"
11:03:23 <ReinH> corgifex: you realize we were talking about the evaluation of a haskell program, right?
11:03:40 <corgifex> what does that have to do with anything?
11:03:43 * ReinH sighs
11:03:46 <ReinH> are you trying to troll me?
11:03:46 <levi> Pro tip: If you think a term has only one definition, you're probably mistaken.
11:03:50 <ReinH> because I'm losing patience.
11:04:09 <corgifex> ReinH: it looks like you can't give straight answers
11:04:10 <Iceland_jack> levi: What do you mean 'term'? :)
11:04:43 <levi> Human beings are exceptionally good (usually, anyway) at figuring out which definition is meant from context.
11:04:46 <ReinH> corgifex: I'm not interested in having this incredibly pedantic argument with you any more.
11:04:49 <corgifex> asking me what I think about X, then complaining about the answers I give isn't productive
11:04:57 <ReinH> nothing about this is productive
11:04:59 <ReinH> and I'm done
11:05:01 <corgifex> ReinH: ok, first problem: this isn't an argument
11:05:07 <ReinH> corgifex: please stop talking to me
11:05:18 <thinkpad20> ReinH: putting bangs everywhere stopped the stack overflow. Thanks!!!
11:05:19 <corgifex> this is me trying to understand evaluation / the models used
11:05:34 <thinkpad20> laziness to the rescue again... :/
11:05:39 <ReinH> thinkpad20: :)
11:06:05 <tromp> cool ; now find the minimal set of bangs that solves the prob:)
11:06:08 <aloiscochard> "puttings bangs everywhere" :-/
11:06:11 <corgifex> thinkpad20: ooh, where did you put the bangs?
11:06:28 <thinkpad20> basically on every function which takes an expression or value as an argument
11:06:31 <levi> thinkpad20: It's tricky to figure out where strictness is what you want and where non-strictness is what you want. Alas!
11:06:57 <mietek> XImplicitParams as poor man's ReaderT  - yea or nay?  Saves having to depend on mtl.
11:07:06 <thinkpad20> IMO I'd much rather have laziness be opt-in than opt-out... but others disagree
11:07:13 <aloiscochard> thinkpad20: just saying, but that does not really sound like a good idea
11:07:26 <ReinH> thinkpad20: that language is interesting but it's not Haskell :)
11:07:32 <ReinH> it's ML :)
11:08:01 <thinkpad20> ReinH: yes, but ML doesn't have type classes and several other important features :)
11:08:06 <thinkpad20> and it doesn't have GHC
11:08:10 <ReinH> I'm still not sure why RTS calls this a "stack overflow"?
11:08:15 <ReinH> Thunks are on a heap? Which stack is overflowing?
11:08:32 <corgifex> the pattern matching stack
11:08:39 <thinkpad20> well it must be on a heap, but I guess it keeps track of how much has been used
11:08:40 <ReinH> wow.
11:09:05 <thinkpad20> IE it's on the heap according to the operating system, but there's an internal stack (or some kind of tree)
11:09:10 <ReinH> corgifex: you are ridiculous.
11:09:34 <ReinH> that was easily the most pointless and frustrating argument I've had in here so thanks for that
11:09:45 <thinkpad20> so a "stack overflow" in this case just means "I've accumulated more thunks than I'm configured to do"
11:09:52 <thinkpad20> Or at least, that's what I guess...
11:09:59 <stevely> usually what happens is you build a giant chain of thunks, and then when evaluation finally happens each thunk generates a stack frame, which blows up the stack
11:10:00 <levi> Well, the thunks are analogous to the activation record stack in a strict language. It's probably called that to provide a point of familiarty?
11:10:03 <thinkpad20> Maybe they just didn't want to write "thunk overflow" lol
11:10:15 <thinkpad20> stevely: ohhhh, yeah that must be it
11:10:23 <ReinH> stevely: right
11:10:37 <ReinH> stevely: that's what I was referring to before I got sidetracked on that pointless argument
11:11:12 <corgifex> next time you could just explain how stuff works
11:11:16 <ReinH> corgifex: or you could.
11:11:23 <corgifex> point is, I don't know
11:11:28 <ReinH> "Pattern matching happens during evaluation, not application." Done.
11:11:31 <corgifex> I have a mental model but it's incomplete
11:11:44 <corgifex> and possibly incoherent
11:11:48 <ReinH> That simple explanation could have saved us a lot of trouble
11:12:09 <levi> corgifex: Well, telling others they're wrong is not a great way to ask for an explanation.
11:12:12 <thinkpad20> hey guys I gotta get back to work but thanks to all who helped or tried to, appreciate it!
11:12:20 <ReinH> thinkpad20: np :)
11:13:44 <corgifex> levi: what are you referring to?
11:15:06 <levi> corgifex: I'm tired of this discussion, too. If you can't find what I was referring to in your scrollback or the logs, then either I was imagining things or there's no point in me trying to point it out.
11:15:09 <ReinH> eh, he probably wanted to make his (>>=) strict rather than throw a bunch of ! around but whatever
11:15:32 <ReinH> (maybe just throw a couple ! around)
11:15:42 <monochrom> everyone should read my http://www.vex.net/~trebla/haskell/lazy.xhtml
11:15:53 <monochrom> all of you
11:15:54 <ReinH> monochrom: thanks
11:15:58 <corgifex> I will
11:16:44 <aloiscochard> I'm doing it now
11:17:17 <monochrom> for the most part, stack overflow is due to the artificial cap 8MB on stack space
11:17:24 <corgifex> levi: I searched for "wrong", didn't see anything relevant
11:17:57 <Nik05> damn this functional programming is hard
11:18:00 <monochrom> to use 8MB of stack, first you must build a suitable heap object of more than 8MB
11:18:04 <augur> bitemyapp: 0.0
11:18:06 <augur> agree?
11:18:35 <levi> corgifex: I'm sorry.
11:18:45 <monochrom> therefore, it is cognitive disonnance to put a cap on stack but no cap on heap
11:19:02 <monochrom> there are only two tenable positions. cap both. cap neither.
11:19:13 <aloiscochard> let's can neither then!
11:19:16 <aloiscochard> cap*
11:19:23 <bitemyapp> augur: Sartre was a waste of flesh.
11:20:46 <akurilin2> Quick question: I'm running cabal install --only-dependencies and I'm having an issue building http-conduit-2.0.0.8, supposedly it can't find Network.HTTP.Client.Conduit. First of all this is building fine on the other machine where I makde the repo originally. Second, most of the interesting packages in the .cabal file have their version pinned exactly.
11:20:48 <fryguybob> monochrom: By making the stack discontiguous or by having more indrection?  Both have their costs.
11:21:06 <akurilin2> So I'm wondering how exactly to fix this.
11:21:08 <eizo> for two sets of posets A, B, define: A -> B if: for all p in A, there exists p' in B, s.t. p is "less constrained" than p' (there is a monotone from p to p'); how can i express this is category theory?
11:21:23 <monochrom> fryguybob, do you know that GHC's stack is already growable? the cap is only a default.
11:21:35 <ReinH> eizo: maybe ask in ##categorytheory :)
11:21:45 <ReinH> eizo: lots of the same people but the focus is on CT :)
11:22:02 <monochrom> whatever cost you say, they are already paid. you can no longer opt out of it.
11:22:13 <lispy> monochrom: I don't have time to read it carefully right now (so I skimmed it and added to a list), but it looks like a nice treatment. Thanks!
11:22:24 <kloplop321> ponysq
11:22:28 <monochrom> thank you for choosing monochrom!
11:22:39 <kloplop321> sorry, wrong window.
11:23:17 <ReinH> heh
11:23:26 <kmspriyatham> I wrote a snippet at http://lpaste.net/102536 that converts integers to binary. But it doesn't seem to work for 67679572364657274765. can someone please help. I cannot figure out what's going wrong.
11:23:30 <fryguybob> monochrom: Yes, indeed.
11:23:31 <aloiscochard> monochrom: yeah looks very exhaustive, instant bookmark
11:24:03 <monochrom> in fact, if GHC's stack were not growable, I would not venture to put forth my argument about "cap both or cap neither".
11:24:27 <fryguybob> monochrom: I'm only arguing against the claim that the there are only two tenable positions.
11:24:39 <fryguybob> monochrom: Right
11:24:50 <monochrom> yes yes, I'm saying that within context. I am not saying it in ##c.
11:24:55 <geekosaur> kmspriyatham, the problem is that you used intToDigit, which fixes the type as Int instead of Integer, so it can't handle a number that large (hardware level overflow)
11:25:06 <fryguybob> monochrom: Nor are you saying it in #GHC ;D
11:25:27 <geekosaur> intToDigit (fromIntegral (rem n 2)) -- perhaps
11:25:40 * geekosaur doubl;echecks that
11:25:43 <kmspriyatham> geekosaur, but it works for some numbers much larger than that.
11:26:09 <akurilin2> Ok so regarding the cabal issue, something is attempting to call version 2.1.0 of http-conduit, when I've specifically said it's 2.0.0.8, so it looks like cabal might have picked up a newer dependency. How do I find what's using the too-new code?
11:27:06 <kmspriyatham> geekosaur, the error message is strange too, "0*** Exception: Char.intToDigit: not a digit -1" why is rem giving a -1?
11:27:32 <geekosaur> oh, it helps to include error messages
11:27:47 <eizo> thanks ReinH
11:27:51 * hackagebot cruncher-types 1.1.0 - Request and Response types for Eval.so's API  http://hackage.haskell.org/package/cruncher-types-1.1.0 (RickyElrod)
11:27:58 <pyon> if i want "data Foo l a = Cont a (Foo l a) | Done l" to be a Monad, l has to be a Monoid, right?
11:28:14 <ReinH> eizo: good luck :)
11:28:19 <kmspriyatham> geekosaur, notice the 0 in the beginning of the message.
11:28:31 <geekosaur> but that in fact proves my point, I think... you are seeing hardware overflow. in this case a large negative number happens to result when it gets shifted
11:29:32 <geekosaur> yeh, it's 4 bits too large for a 64 bit integer, and when you shift off one digit with the quot the result (compressed down to a 64 bit integer) is negative
11:30:11 <geekosaur> so you get one digit, then it goes negative and rem reflects that in its return value and intToChar fails
11:30:20 <ReinH> pyon: that's almost a free monad but not quite?
11:30:23 <magicman> > (maxBound + 2) `rem` 2 :: Int
11:30:24 <lambdabot>  -1
11:30:30 <geekosaur> ^
11:30:44 <dwcook> pyon, I dunno about that but it looks to me like you ought to switch the order of your type variables
11:31:26 <dwcook> If return is to be Done then you need it to be of type a -> Cont b a for whatever b and a
11:32:05 <geekosaur> I verified the type of intToChar, btw, it is definitely using Int which depending on your platform / ghc build is either 32 or 64 bits --- and is subject to hardware overflow (with no warning since Intel CPUs don't make it easy to get such)
11:32:08 <ReinH> pyon: the free monad, data Free f r = Free (f (Free f r)) | Pure r, only requires f to be a Functor
11:32:11 <pyon> dwcook: mmm return is more like "return x = Cont x (Done mempty)"
11:32:27 <ReinH> pyon: I'm not sure about yours
11:32:28 <sqrt2_> kmspriyatham: decToBinHelper n = intToDigit(fromIntegral $ rem n 2):decToBinHelper(quot n 2)
11:32:31 <pyon> ReinH: ah!
11:32:33 <sqrt2_> if that works, geekosaur is right
11:32:44 <KristofDM> Anyone has a clue what's wrong with this one? http://screencloud.net/v/8Rz8 For some reason I can't add the other ships to the list. If I put the return right after the first ship everything is just fine.
11:33:40 <pyon> ReinH: basically what i'm trying to do is compose iterators that have leftovers... i'm actually writing it in rust, but it's so much easier to reason about it in haskell first :-)
11:33:56 <ReinH> pyon: ah, you probably want to talk to Tekmo about that ;)
11:34:10 * geekosaur wonders if the porners have branched out...
11:34:15 <kmspriyatham> geekosaur: please clarify, quot gives a negative integer due to overflow?
11:34:29 <pyon> ah :-)
11:34:37 <ReinH> pyon: I know he uses FreeT to make "lists" of producers
11:34:37 <merijn> Why does "fromSing" require a "Sing a" argument to produce a value?
11:34:59 <ReinH> pyon: what is an iterator that has leftovers?
11:35:01 <merijn> Couldn't it just use a Proxy/whatever?
11:35:06 <ReinH> pyon: parsing?
11:35:26 <pyon> ReinH: that's one example
11:35:29 <magicman> > -3 `quot` 2
11:35:31 <lambdabot>  -1
11:35:46 <ReinH> pyon: maybe look at pipes-parse
11:35:48 <pyon> ReinH: so how would FreeT work? i make a nested tree of iterators?
11:35:50 <ReinH> for how Tekmo handles it
11:35:58 <pyon> ok i'm gonna check it out :-)
11:36:15 <geekosaur> kmspriyatham, your number overflowed when converted to Int and no longer is the value you intended. when it divides it, it thinks the number is negative because the high bit is a sign bit, therefore the result it produces is negative. the next pass, rem sees the negative number and produces a negative result. (I think)
11:36:25 <ReinH> pyon: if an iterator that produces a's is like an [a], the FreeT wrapped iterator is like an [[a]]
11:36:37 <geekosaur> have you tried the fromIntegral that I sugested earlier and sqrt2_ emphasized yet?
11:36:52 <pyon> ReinH: i know what a free monad is :-)
11:36:55 <ReinH> pyon: but I'm not sure if this will handle leftovers. I'm pretty sure pipes-parse is about handling leftoves
11:36:59 <ReinH> pyon: sorry :)
11:37:07 <pyon> ReinH: no no worries
11:37:12 <pyon> ReinH: actually thanks! :-)
11:37:15 <ReinH> pyon: np :)
11:37:18 <kmspriyatham> geekosaur: I did and it worked.Also why does the error message start with a '0'?
11:37:27 <geekosaur> because I checked your number and it s definitely larger than fits in Int --- and intToDigit forces the type to Int
11:37:49 <geekosaur> again, because it got through one digit before the number got interpreted as negative
11:37:52 * hackagebot whois 1.1.2 - WHOIS client library.  http://hackage.haskell.org/package/whois-1.1.2 (RickyElrod)
11:38:01 <monochrom> @type intToDigit
11:38:02 <lambdabot> Int -> Char
11:38:20 <ReinH> pyon: I vaguely remember that we talked about the leftovers problem in the haskell cast too
11:38:26 <geekosaur> admittedly you need some understanding of how this stuff works at the CPU/hardware level to understand why it's being interpreted weirdly like that
11:38:31 <ReinH> pyon: so there might be something in there for you too
11:38:32 <monochrom> @let decToBinHelper n = intToDigit(rem n 2):decToBinHelper(quot n 2)
11:38:34 <geekosaur> oh the other thing si, remember Haskell is lazy
11:38:45 <monochrom> @botsnack
11:38:45 <lambdabot> :)
11:38:53 <geekosaur> so it can indeed get through part of the expression and display a digit before hitting the error
11:38:58 <monochrom> @type decToBinHelper
11:38:59 <lambdabot> Not in scope: decToBinHelper
11:39:04 <geekosaur> because your function produces a lazy list
11:39:10 <ion> @botslap
11:39:10 <lambdabot> Unknown command, try @list
11:39:23 <monochrom> hmm, is @let right?
11:39:32 <ReinH> we do not promote violence against computers :)
11:39:38 <levi> pyon: If I understand correctly, pipes-parse uses StateT for the parsing. The FreeT thing is for creating a delimited 'sub-stream' that you can pass to a consumer that shouldn't be able to access beyond the delimiter.
11:39:48 <ReinH> levi: that sounds about right
11:40:04 <kmspriyatham> geekosaur: thanks.
11:40:20 <ReinH> levi: (I think the StateT is for handling leftovers in general and it's called pipes-parse because that was the first use case)
11:40:34 <ReinH> I know pipes-parse deals with more than just parsing, which is why I mention it
11:40:40 <levi> Yeah.
11:40:41 <pyon> ReinH: levi: in the (Alternative) parsing case, the one i actually want to be a Monoid is the type of the error messages... if the parser fails after trying several branches, then i need the combined error messages of all of them
11:40:49 <geekosaur> > fix ""
11:40:50 <lambdabot>  Couldn't match expected type ‘a -> a’
11:40:51 <lambdabot>              with actual type ‘[GHC.Types.Char]’
11:40:55 <geekosaur> whoops
11:41:34 <pyon> ReinH: levi: but in the iterator case, if i join an iterator of iterators of Ts into an iterator of Ts, i need the merged error messages of all the inner iterators
11:41:41 <pyon> errr merged leftovers*
11:41:53 <ReinH> pyon: well, Alternative is a monoid. Not sure if that helps. ;)
11:42:10 <ReinH> (*instances of Alternative)
11:42:43 <ReinH> pyon: I'm pretty sure StateT is for accumulating leftovers...
11:42:51 <monochrom>  @let has died!
11:42:52 <Bor0> what does <*> and <?> represent in this context http://lpaste.net/102527
11:43:01 <MagneticDuck> <*> is fmap
11:43:13 <merijn> No it's not
11:43:16 <merijn> <$> is fmap
11:43:18 <monochrom> no, <$> is fmap, <*> is the other operator
11:43:20 <ReinH> pyon: are either of these useful? http://www.haskellforall.com/2014/02/pipes-parse-30-lens-based-parsing.html http://www.haskellforall.com/2013/06/pipes-parse-100-pushback-delimited.html
11:43:20 <haasn> <*> is ap
11:43:20 <MagneticDuck> oh never mind
11:43:25 <MagneticDuck> yes
11:43:26 <Bor0> what's ap?
11:43:29 <haasn> :t ap
11:43:30 <lambdabot> Monad m => m (a -> b) -> m a -> m b
11:43:32 <pyon> ReinH: lemme see
11:43:33 <haasn> liftM2 id
11:43:33 <monochrom> there is no <?>
11:43:33 <MagneticDuck> for Applicatives
11:43:34 <ion> ap is <*> ;-)
11:43:38 <levi> Leftovers are not error messages, though; they're the part of the input stream that was pulled from upstream but not consumed.
11:43:41 <haasn> I know <?> from parsec
11:43:46 <haasn> and other applicative-style parsers
11:43:47 <MagneticDuck> yeah
11:44:12 <monochrom> Bor0, <*> is from the type class Applicatve
11:44:20 <ReinH> Bor0: http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Applicative.html
11:44:28 <monochrom> yes haasn, there is no <?> in the paste
11:44:32 <ReinH> @where typeclassopedia
11:44:32 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
11:44:32 <Bor0> got it
11:44:33 <levi> I'm just a bit confused about the questions about leftovers and how they relate to error message merging.
11:44:36 <haasn> Bor0: ap mf mx = do { f <- mf; x <- mx; return (f x) }
11:44:41 <ReinH> Bor0: check out the explanations in the typeclassopedia as well
11:45:03 <haasn> <*> is a more general version of what's essentially this, for Applicatives
11:45:15 <pyon> levi: not related at all... sorry
11:45:46 <ReinH> pyon: let me know what you come up with in Rust. I'm interested.
11:45:47 <pyon> levi: merging iterators is more like flattening lists of lists into a single list
11:46:20 <pyon> ReinH: https://github.com/eduardoleon/rust-stl -- this, for the time being
11:46:36 <ReinH> pyon: cool
11:47:02 <levi> If fmap lifts a curried function into a Functor (which happens to also be Applicative) then you can apply extra arguments to that function within the Functor with <*>/ap.
11:47:29 <ReinH> pyon: Given n implementations of the iteratee pattern, you will find approximately 2.5n different names for the parts. ;)
11:48:06 <pyon> :-O
11:48:45 <pyon> producer/consumer, source/sink, inputiterator/outputiterator... :-P
11:49:23 <ReinH> yep
11:49:24 <levi> Don't forget pipe/conduit/tranducer/iteratee
11:49:28 <tomejaguar> Where does Functor ((->) a) live?
11:49:30 <ReinH> also yep
11:49:31 <deweyvm> is there an O(1) way to extract an arbitrary element (if it exists) from a Data.Set?
11:49:34 <tomejaguar> Instances are heard to search.
11:49:42 <ReinH> tomejaguar: somewhere in base?
11:49:51 <ReinH> tomejaguar: I suppose you meant more specifically
11:50:08 <tomejaguar> Yeah I want to import a module.
11:50:12 <tomejaguar> But I don't know which one!
11:50:16 <ReinH> heh yeah
11:50:19 <ReinH> it's rather frustrating
11:50:34 <deweyvm> @hoogle Set a -> (Maybe a, Set a)
11:50:35 <lambdabot> No results found
11:50:49 <tomejaguar> Control.Monad.Instances has it at least.
11:50:55 <monochrom> @hoogle Set a -> Maybe (a, Set a)
11:50:56 <lambdabot> Data.Set maxView :: Set a -> Maybe (a, Set a)
11:50:56 <lambdabot> Data.Set minView :: Set a -> Maybe (a, Set a)
11:50:56 <lambdabot> Data.Set deleteFindMax :: Set a -> (a, Set a)
11:51:08 <deweyvm> those are n* logn iiuc
11:51:12 <monochrom> but all of them are logarithmic, not constant-time
11:51:17 <deweyvm> err
11:51:18 <deweyvm> log n
11:51:18 <deweyvm> yea
11:51:27 <monochrom> I think there is no constant-time option
11:51:29 <deweyvm> oh i was reading it as n log n before
11:51:33 <deweyvm> log n is fast enough
11:51:37 <monochrom> heh
11:51:39 <deweyvm> haha nevermind, thanks
11:51:44 <ReinH> heh
11:51:56 <tomejaguar> There can't be a O(1) version
11:52:07 <tomejaguar> It takes at least O(log n) time to determine what your element is!
11:52:08 <merijn> deweyvm: Keep in mind Set uses an ordered structure inside, so looking up is always log n as it can just binary search
11:52:29 <merijn> tomejaguar: Well, there can if you store both min and max in addition to the tree
11:53:13 <merijn> Actually, shouldn't "head . Set.toList" fuse to be pretty much O(1)?
11:54:10 <tomejaguar> merijn: Well what is n?  max - min can be much larger than the number of stored elements.
11:54:42 <levi> tomejaguar: There seems to be an instance here: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html
11:55:07 <tomejaguar> levi: Ah yes, thanks.
11:55:46 <deweyvm> merijn: probably, i need the set without the element too though
11:56:04 <levi> They were tricky and used 'r' instead of 'a' to hide it from google searches. :P
11:56:06 <deweyvm> which probably needs to eprcolate or whatever
11:56:09 <deweyvm> percolate
11:56:36 <petrie_> http://www.amazon.com/gp/product/0201882957
11:56:37 <merijn> deweyvm: Right, then you'll be log n anyway
11:56:41 <petrie_> does that seem like a decent book?
11:57:06 <tomejaguar> levi: I didn't actually realise googling "instance functor ((->) r)" would work.  Seems to give an OK result.
11:57:14 <tomejaguar> But instances should be made easier to search for, somehow.
11:57:43 <merijn> petrie_: The common recommendations are "Lear You a Haskell", "Real World Haskell" and "Programming in Haskell", the first two being available online for free
11:57:48 <levi> That's basically what I did, except with a instead of r, which did find it but it required a bit more looking through the results.
11:58:24 <tathi> Newbie question: I'm reading Dan Piponi's old article _The Trivial Monad_ and I don't understand how `join x = x >>= id` can typecheck as `Monad m => m (m a) -> m a` (or at all, for that matter).
11:58:38 <ReinH> petrie_: it's definitely a textbook but pretty good for that
11:59:03 <petrie_> merijn: thanks! Is the "Programming in Haskell" one by Graham Hutton?
11:59:06 <ReinH> :t (>>=)
11:59:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:59:09 <tathi> (since `id` does not have type `a -> M a`)
11:59:16 <byorgey> tathi: indeed, it does not
11:59:18 <tathi> er, a -> M b
11:59:19 <petrie_> is says it was published in 2007 so wasn't sure how up to date it would be
11:59:27 <byorgey> tathi: however, it can have type  m a -> m a
12:00:17 <merijn> petrie_: Yes
12:00:25 <tathi> byorgey: I figured it must, but I don't understand why, when the type of >>= says it should be (a -> m b)
12:00:40 <petrie_> merijn: Ah, thanks!
12:01:02 <ReinH> tathi: is m a -> m a a valid a -> m b?
12:01:20 <ReinH> er
12:01:32 <ReinH> is `m b -> m b' a valid `a -> m b'?
12:01:41 <ReinH> what would `a' be?
12:02:01 <tathi> I wouldn't think so. It doesn't add anything to the type.
12:02:12 <ReinH> tathi: why can't `a' be `m b'?
12:02:15 <byorgey> tathi: right, remember that in the type of  >>=  'a' can be *any* type
12:02:31 <tathi> ReinH: it could, but then I'd expect the output would have to be `m (m b)`.
12:02:41 <merijn> tathi: Why?
12:02:49 <byorgey> tathi: what is the type of (>>=) (no peeking)?
12:03:00 <ReinH> byorgey: heh I already looked it up
12:03:04 <merijn> tathi: It says 'a -> m b', if 'a' is 'm b', why would 'b' also have to be 'm b'?
12:03:31 <tathi> oh. not `a -> m a`
12:03:39 <tathi> doh!
12:03:48 <byorgey> =)
12:03:57 <tathi> thanks guys! :)
12:03:58 <geekosaur> it does take some getting used to
12:03:59 <ReinH> tathi: plug in `m b' for `a' and re-evaluate :)
12:04:36 <ReinH> m (m b) -> (m b -> m b) -> m b
12:04:56 <ReinH> tathi: now, what could a function (m b -> m b) possibly be?
12:05:18 <tathi> ReinH: yeah, I get it, now.
12:05:22 <ReinH> tathi: :)
12:05:50 <merijn> Does ghc-core automatically use -O2 when generating core?
12:06:03 <levi> It might help to think of type signatures as a logic statement; to see if two signatures match, you want to see if they unify. At least, that might help if you're familiar with doing logic problems. Otherwise, nevermind. :)
12:06:55 <tathi> Yeah, just stupidly reading the type wrong: I thought the function had to be `(a -> m a)`, not `(a -> m b)`.
12:07:12 <levi> I'm pretty sure I've made that mistake before too.
12:07:15 <tathi> Can't believe I was staring at that for 15 minutes...
12:08:01 <levi> It's easy to gloss over the actual type variable names and just see the shape.
12:09:49 <ReinH> is join free given (>>=)? Since the (m b -> m b) has to be id?
12:11:26 <DR6____> join = (>>= id) if that's what you mean
12:12:48 <byorgey> ReinH: I'm not quite sure what you mean by "free" in this context.
12:14:56 <ReinH> byorgey: me neither I guess
12:15:25 <ReinH> join = (>>= id) is the only possible way to write join in terms of (>>=) is I guess what I mean
12:15:32 <NemesisD> hey guys. i'm working a library that has to do a bunch of datetime math. i've found this will be much easier using datetime-lens (lens laws violations aside). a user i was talking to expressed some concern about bringing in lens as a dependency
12:15:39 <merijn> ReinH: Well, the only sensible one, yes
12:15:54 <merijn> ReinH: I'm sure one can come up with more convoluted implementations to do the same
12:16:23 <merijn> NemesisD: That's not a question :)
12:16:33 <NemesisD> is there a rule of thumb or best practice about bringing in dependencies like lens in a library? i'm not interested in making my implementation much harder to avoid my users waiting an additional minute for deps to compile. is there some other reason I should avoid bringing in that dependency?
12:16:36 <ReinH> merijn: heh, but they'd be equivalent since the only a -> a you can choose is ~ id
12:16:55 <NemesisD> basically i don't fully understand the taboo of actually using helpful cabal libraries as a library mantainer
12:17:13 <merijn> NemesisD: Some people complain about lots of dependencies, because they "add bloat", etc.
12:17:18 <NemesisD> i'm looking to develop an instinct for when to bring in deps and when not to
12:17:35 <merijn> NemesisD: Well, presumably you use your own library, right?
12:17:38 <xpte> lens is not an obscure dependency
12:17:56 <NemesisD> lens is hard not to bring in these days. its broadly useful
12:18:25 <merijn> NemesisD: So the question is "do you mind depending on lens in all your other projects?" followed by "if you don't and it makes your life easy, do you really care about a user whining about too many dependencies?"
12:18:38 <sm> NemesisD: an obvious criteria is do you want to be cross-platform
12:18:50 <NemesisD> oh. lens is not cross platform?
12:19:04 <sm> I'm not speaking about lens, I assume it is
12:19:06 <merijn> NemesisD: I would just use "lens" and if someone complains, reply: "patches welcome"
12:19:30 <NemesisD> sm: just in general, being careful about dependencies not hosing cross platform compat?
12:20:07 <sm> NemesisD: eg if your target users includes windows users, you'll need to avoid packages which build only on unix or which require unusual c libraries
12:20:07 <edwardk_> i for one had to make a choice somewhere along the way. i could listen to the crowd that wants everything minimalist where each tool is hand crafted in isolation to do a job, but doesn't work together with other tools, or I could listen to the crowd who wanted my code to work together with the rest of my code.
12:20:17 <byorgey> NemesisD: you asked about criteria for deciding whether to bring in a dependency.  I think sm was just giving one such criterion.
12:20:18 <edwardk_> i choose to live in the world where stuff works together
12:20:35 <NemesisD> byorgey: sm yeah that's a good one to consider.
12:21:05 <byorgey> NemesisD: did this user say *why* they were concerned about bringing in lens as a dependency?  I am curious.
12:21:37 <NemesisD> edwardk_: as a rubyist for the past few years, i find the eschewing of dependencies baffling. rubyists will pull in dependencies for every single thing, and its probably even more hazardous to do so in ruby than in Haskell
12:22:07 <sm> NemesisD: another criteria is whether it's in the current haskell platform - if not, your users will need to deal with cabal
12:22:10 <ReinH> NemesisD: oh god yes
12:22:15 <NemesisD> byorgey: their particular reason was trifling. they said they were evaluating my library for a prototype and were concerned about it taking several minutes to compile because of lens
12:22:30 <edwardk_> NemesisD: anyways, given the ratio of complaints from the different camps, i think the call i made here has been a net good.
12:22:32 <byorgey> NemesisD: heh, ok
12:22:58 * hackagebot thumbnail-plus 1.0.2 - Generate thumbnails easily and safely.  http://hackage.haskell.org/package/thumbnail-plus-1.0.2 (FelipeLessa)
12:23:00 <NemesisD> i asked them to list any better reasons (haven't heard back yet) because that isn't a case i care to optimize for. i'm not going to spend 5x as long on a feature to save him 1 minute of compile time that he will pay infrequently
12:23:29 <byorgey> NemesisD: and to answer your question, there are no globally valid criteria.  I think the best thing to do is decide on two or three high level goals/values of your project (efficiency? broad user base? elegance? etc.), and then evaluate all your decisions in light of those.
12:23:33 <SrPx> Is anyone aware of an altcoin coded in Haskell?
12:23:40 <NemesisD> i don't want to force users into a cabal hell situation but we've got a slow-ish compiler. comes with the territory
12:23:56 <SrPx> I want to create an altcoin, I don't know where to start, but if I had a Haskell coded altcoin to begin it, that would be sweet
12:23:56 <NemesisD> byorgey: sound advice, thank you
12:24:06 <merijn> NemesisD: Just take a JIT approach to these things, just do whatever's convenient for you, when people complain let them do one of the following: 1) fork your code, 2) submit a patch, 3) pay you, 4) stop complaining :p
12:24:40 <ReinH> trading to minimize compile time while increasing developer time seems almost pessimal to me
12:25:45 <NemesisD> edwardk_: i think people get in a huff when a feature of lens you don't directly need like Data.Aeson.Lens scrolls by while compiling, and they loudly mourn the 90 seconds that steals from their lives
12:25:50 <edwardk_> note: if you build lens once, you can rebuild your projects over and over without pain ;)
12:26:40 <NemesisD> i should really figure out cascading cabal sandboxes or wherever, so i don't pay the lens compile toll on every project, but it really doesn't bother me, i go make tea and i'm good to go
12:26:56 <edwardk_> In retrospect, I probably shouldn't have folded in lens-aeson into the package. at the time i thought it was going into the platform, and thus would have been near free
12:27:33 <edwardk_> i folded it in as if it _was_ in the platform it'd be included in the batteries included mantra of lens
12:27:33 <monochrom> you can cascade sandboxes by hand. http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
12:27:51 <NemesisD> edwardk_: is lens getting into platform any time soon?
12:28:11 <edwardk_> NemesisD: going into the platform is not currently a design goal of lens
12:28:13 <NemesisD> edwardk_: it would help me win a lot more silly arguments if it did. top priority
12:28:35 <monochrom> just coin "the lens platform" :)
12:29:00 <monochrom> "the lens platform --- prisms included" :)
12:29:14 <edwardk_> NemesisD: it isn't a pure win. platform packages can only use platform packages. lens uses comonads, profunctors, bifunctors, etc. indispensibly in its API. it needs unordered-containers for speed internally, etc.
12:29:32 <edwardk_> so bringing it in means bringing a lot of stuff into the platform first
12:30:10 <NemesisD> edwardk_: yeah. thats true. i don't even use platform. i walk into hell with eyes wide open
12:30:13 <edwardk_> so i'm currently not actively pushing for lens in the platform
12:30:51 <gdoteof> how do i send an EOF char in a String
12:31:00 <monochrom> there is no such thing
12:31:01 <edwardk_> what i've been working to do instead is ensure that all of my code everywhere builds clean off stackage, and as much as possible works back as many platforms as makes sense per project
12:31:27 <NemesisD> edwardk_: that seems to resolve the moral argument of its use
12:32:08 <edwardk_> so you can build almost anything I write against the last 2-3 platforms, some stuff builds clear back to ghc 7, other stuff builds all the way back to base 2 + hugs
12:32:34 <gdoteof> ghc is fighting me on named pipes, and i have been able to 'get around' it by using shell commands
12:33:10 <gdoteof> but i am trying to write to a named pipe and writeFile is complaining that there is no file; so i tried use createCommand and hook up to stdin and dump it there
12:33:27 <gdoteof> but now it's blocking on that; i think because i didn't signal the end of input
12:34:06 <edwardk_> With lens I try to ensure that there is a version of lens currently supported that supports GHC all the way back to 7.0. if you use the common features of lens 3.7 and 4.1 you can build on almost any GHC from the last 4-5 years.
12:34:13 <monochrom> IIRC someone else has to be already reading the named pipe before you can write
12:35:07 <edwardk_> (lens 3.8 bumped the support floor to GHC 7.4 due to the multi parameter type class default signatures in places)
12:35:42 <haasn> API freedom >>>>>>>>>>>>>>>>>>>>>>>>> platform integration
12:35:48 <haasn> I hope this expresses my opinion strongly enough
12:36:00 <haasn> Maybe I should have used more >s
12:37:07 <davidfetter> perhaps there should be an explicit multiplier notation for >s
12:37:18 <glosoli> what is the most popular web framework for haskell ?
12:37:27 <haasn> "API freedom" ++ repeat '>' ++ "platform integration"
12:37:30 <monochrom> no, use this: lim (platform integration)/(API freedom) = 0. and this: lim (platform integration)^k / (API freedom) = 0
12:37:45 <cschneid> glosoli: snap & yesod are the big ones I know about. Both are good
12:38:07 <glosoli> thanks sir
12:38:53 <monochrom> it comes to mind because I'll be teaching O(f(n)) very soon. and I think it helps students to point out "if lim n->oo g(n)/f(n) exists and is finite, then g(n) is O(f(n))"
12:39:11 <haasn> The only real arguments for platform integration I can think of is portability to foreign execution environments you have no power over, like online code judge websites
12:41:46 <looma> hi, i want to write parallel code within runDbConn kinda thing is it safe?
12:42:25 <edwardk_> monochrom: i had a lot of fun in a "classical analysis" class that use big-O notation for everything, Knuth style.
12:43:41 <fragamus> hey I made a huge mathematical expression using a symbolic math package and I want to translate it to haskell.   That will be easy BUT...
12:43:49 <fragamus> I need to know how haskell behaves when there is some duplication in the expression
12:44:08 <merijn> I don't suppose there's a way to go from "Sing a" to an unboxed machine word without going through Integer?
12:44:24 <edwardk_> fragamus: if you are hoping for common sub-expression elimination i recommend doing it by hand
12:44:41 <fragamus> I once wrote a code in Mathematica to do it
12:44:46 <glosoli> Probably a dumb question, but is there some way to see how recursion expands ?
12:45:07 <haasn> glosoli: depends on what exactly you want to see
12:45:13 <fragamus> edwardk: but I take it that you are saying "don't trust haskell to do this for you"
12:45:14 <haasn> the easiest answer is: yes, do it by hand
12:45:17 <looma> or should i create a lock on db connection?
12:45:18 <edwardk_> > foldr f z [a,b,c,d,e]
12:45:20 <lambdabot>  f a (f b (f c (f d (f e z))))
12:45:25 <edwardk_> glosoli: like that?
12:45:25 <monochrom> if you know how to use the debugger in ghci, you can get something
12:45:30 <glosoli> edwardk_: hmm yeah
12:45:32 <merijn> fragamus: GHC guarantees that if you have "let x = {- expensive computation -} in f x x" then the expensive computation is only performed once
12:45:36 <edwardk_> > foldl f z [a,b,c,d,e]
12:45:37 <lambdabot>  f (f (f (f (f z a) b) c) d) e
12:45:44 <merijn> fragamus: Same applies for where
12:46:07 <edwardk_> glosoli: that uses http://hackage.haskell.org/package/simple-reflect
12:46:35 <glosoli> Thanks
12:46:50 <looma> anyone knows?
12:47:14 <fragamus> so haskell doesn't analyze for common subexpressions
12:47:19 <augur> i quite like the block comment toggle trick :T
12:47:24 <fragamus> unless they are bound to a variable
12:47:29 <looma> fragamus: haskell != ghc
12:47:38 <fragamus> looma good point
12:47:44 <fragamus> ghc i mean
12:47:54 <fragamus> haskell > ghc
12:47:59 <merijn> fragamus: GHC *does* search for common subexpressions, but it's not guaranteed to find even fairly simple ones
12:48:27 <merijn> fragamus: So if you absolutely *need* it to be evaluated only once, shoving it behind a let/where binding is the best way
12:48:43 <fragamus> yu[
12:48:46 <fragamus> yup even
12:48:59 <looma> for example if im using runSqlite from http://www.yesodweb.com/book/persistent and what happens when withing that runSqlite i'm going parallel?
12:49:00 <fragamus> > thanks
12:49:01 <lambdabot>  Not in scope: ‘thanks’
12:50:08 <looma> will it break?
12:50:39 <looma> anyone?
12:50:43 <looma> jello?
12:51:35 <stelleg> looma:
12:51:41 <stelleg> looma: not sure I can parse that question
12:52:45 <looma> stelleg: i'm asking is it safe to update database in parallel
12:53:02 * hackagebot xhb 0.5.2014.4.10 - X Haskell Bindings  http://hackage.haskell.org/package/xhb-0.5.2014.4.10 (AntoineLatter)
12:53:18 <looma> will it block or will it create inconsitency or what other dangers should i be aware of
12:53:24 <sgregory_> looma: what version of sqlite are you using?
12:53:47 <looma> latest 3.8.4.3
12:54:52 <sgregory_> looma: *I think sqlite makes it ok* https://www.sqlite.org/wal.html
12:55:29 <stelleg> it also looks like every call to runSqlite runs in a transaction
12:56:21 <looma> stelleg: it even runs in a new connection i think :)
12:58:07 <looma> so is it better to create parallel code which update db within runSqlite or outside(i mean every thread will have it's own runSqlite invocation)?
12:58:55 <stelleg> no idea, maybe just try both with a simple example?
12:59:09 <stelleg> apriori it seems more likely that outside will be safer but maybe slower
12:59:58 <NemesisD> i've got an ADT thats got a few constructors that are "nestable" and then a few like lists that explicitly do not allow recursive nesting (no lists within lists). i'm using GADTs
13:00:17 <looma> stelleg: it's not easy to detect if everything is correct, it maybe broken but working seeminlgy okay for time being...
13:00:39 <NemesisD> Specific :: Int -> Exp Nestable; List :: [Exp Nestable] -> Exp a, do i need to create a data NonNestable and specifically make list's constructor Exp NonNestable?
13:00:52 <darthdeu> guys does anyone have a tip for understanding the State monad being represented as  s -> (a, s) ... i've read LYAH and RWH and bunch of other things and I know how to use the state monad, it's just that ... I dunno it doesn't click in my head
13:01:09 <looma> it's surprisingly few people having experience with parallel access to databases in haskell here :D
13:01:13 <stelleg> looma: yeah sorry, not familiar with that library. my only suggestion is to dig into the code (cabal unpack is your friend!) :)
13:01:31 <looma> stelleg: it's library independet question i think
13:02:07 <looma> paralel within db connection or outside? And waht are danger of going parallel with db
13:02:20 <looma> it's even language agnostic i think :D
13:02:26 <hakujin> sounds like an implementation detail of the database
13:02:39 <NemesisD> ah yes. looks like this is not safe until i make List :: [Exp Nestable] -> Exp NonNestable
13:04:10 <looma> hakujin: implementatio detail of database, affects what scenario adn in which way?
13:04:36 <sgregory_> looma: sqlite at least used to have issues regarding threadsafety... i'm not an expert on it
13:06:09 <sgregory_> And in that regard it is definitely specific, Generally speaking you should do better w/ more connections up to some point.
13:06:30 <sgregory_> unless every thread is updating the same record then it probably doesn't matter
13:06:56 <sgregory_> also it depends if you're doing a complex transaction w/ multiple tables or just a single insert/update/query
13:08:16 <sgregory_> but if sqlite does use WAL then it SHOULD be fully acid compliant and if you're setting up your transactions correctly, then all should be well
13:08:17 <looma> sgregory_: sorry, got disconnected but read everything vial chatlogs
13:09:01 <looma> sgregory_: okay, so it seems that transactions is key to safety, no matter how parallel my code is
13:09:04 <looma> thanks!
13:10:37 <looma> sorry, i m really stupid, but trying to lear something every day
13:12:38 <sgregory_> nah, you also probably want to check that you have WAL enabled (looks like a configuration) if you need it
13:12:54 <sgregory_> again I'm definitely not a sqlite expert
13:13:17 <looma> sgregory_: definitely
13:14:13 <looma> it was addressed to point of enablig WAL in configuration, heh, sounds really twofold
13:17:28 <glosoli> http://lpaste.net/102543 any ideas ?
13:17:48 <glosoli> updating cabal-install points me to Network.URI module  not found
13:18:08 <sgregory_> WAL mostly effects what happens if the process gets killed mid-transaction.  The two main mechanisms for transactions are 2PL(two-phase locking) and mvcc (multi-version concurrency control).  MVCC is generally better (less locking).
13:18:58 <gdoteof> does writeFile not work with named pipes?
13:19:15 <gdoteof> i am getting openFile does not exist (no such device or address)
13:19:19 <gdoteof> but the file definitely exists
13:19:37 <gentleben> any idea why some hackage pages are returning 404s? (http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html)
13:19:45 <looma> sgregory_: good to know, thank you once again for your feedback
13:22:00 <looma> gentleben: because there is no such page
13:22:11 <sgregory_>  /play rimshot
13:22:24 <gentleben> looma there used to be
13:22:51 <gentleben> now google is going to get confused by hackage again
13:23:25 <sgregory_> gentleben: my guess it has something to do with "latest" now pointing at 7.8.1 (maybe those docs aren't there yet)
13:24:59 <looma> http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.5.5.1/Data-Map.html
13:25:26 <latro`a> gdoteof, care to explain a little more?
13:25:33 <latro`a> writeFile doesn't take a Handle if that's what you meant
13:27:26 <tomejaguar> Can someone recommend a Haskell integer constraint library?
13:27:54 <looma> i wonder if it good idea to wrap all IO database interaction inside free monad?
13:28:24 <looma> doubting without any particular reason just thinking maybe i'm missing something
13:30:19 <looma> the reason i want to wrap it in free monad is to be able to provide different database-lioke backends, for example for some environments i want to use just a pure hash table or something like that instead of real db
13:30:42 <prinsen> How do I wrap a Pipes.Pipe in a forever?
13:31:28 <looma> forever $ do { x <- await; yield x }
13:31:30 <looma> prinsen: ^
13:31:46 <prinsen> looma: i ment an existing pipe
13:32:19 <Phillemann> Hi, I was wondering if there is a way to write the following a bit more...clever: if f (g x) y then "good" else if f (h x) y then "bad" else "indeterminate"
13:32:55 <looma> any free monad experts here?
13:32:58 <Phillemann> f, g and h are, of course, functions and x, y are values (parameters to the enclosing function, actually).
13:33:06 <c_wraith> looma: yes, there are.
13:33:08 <shachaf> looma: All the monad experts are busy, sorry.
13:33:11 <mm_freak> haasn: i'm not sure i understand your change and how it could lead to unsafeCoerce
13:33:14 <c_wraith> looma: but I'm not one of them!
13:33:26 <shachaf> ("Just ask your question.")
13:33:27 <mm_freak> looma: the others are saying: "just ask" ;)
13:33:39 <looma> shachaf: mm_freak already asked
13:33:41 <prinsen> c_wraith: you seem to know most of my questions ;;)
13:33:56 <looma> i wonder if it good idea to wrap all IO database interaction inside free monad?
13:34:02 <looma> the reason i want to wrap it in free monad is to be able to provide different database-lioke backends, for example for some environments i want to use just a pure hash table or something like that instead of real db
13:34:08 <looma> mm_freak: shachaf ^
13:34:44 <tomejaguar> looma: This is pretty tricky.  The structure of relational queries is not monadic.
13:34:47 <mm_freak> looma: this doesn't seem to have to do with free monads though…  there are a number of ways to support multiple backends
13:35:15 <shachaf> The reason people say "just ask your question" is that if someone volunteers with "I'm a foo expert!" then maybe they won't be able to help you, in which case they'll feel bad for having volunteered.
13:35:24 <looma> got inspired by http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
13:35:31 <looma> tomejaguar: ah, sad
13:35:44 <tomejaguar> Arrows work better.  You can look at this for an example: http://www.haskell.org/pipermail/haskell-cafe/2014-March/113253.html
13:35:55 <shachaf> So if you single out the people who told you to just ask your question, that defeats the point and puts people on the spot.
13:36:01 <haasn> mm_freak: the answer for the first is that GHC 7.8 rejects the code without it - due to it being impossible to auto-derive ArrowApply now due to the addition of roles. My second comment may have been in error, but it may be possible to *somehow* write an instance of ArrowApply for some crazy GADT that abuses the instances' coercion to Schoenfinkel to coerce an unintended type
13:36:19 <mm_freak> looma: do you need access to the structure of the database operation?  that's what free monads give you
13:37:05 <mm_freak> haasn: ah, i see…  would you mind providing a patch through hub.darcs.net?  just fork and make your changes, then i can easily pull them in
13:37:11 <hakujin> mm_freak: I think looma wants to have a generalized persistance structure with multiple interpreters; one for SQL, one for a hash table, etc
13:37:41 <mm_freak> hakujin: we can speculate all day long what looma needs…  better to allow them to explain =)
13:37:56 <looma> mm_freak: well, i'm just thinking just of a way to purify side-effecting code with pure one to ease testing
13:38:22 <haasn> mm_freak: sure, but I'm not sure if the patch is optimal
13:38:40 <looma> that article i linked above does exactly that
13:38:45 <haasn> mm_freak: before that let me try and unsafeCoerce with acme-schoenfinkel :)
13:38:59 <mm_freak> haasn: i'm happy to receive your optimalized version later =)
13:39:23 <mm_freak> i'm not actively working on acme-schoenfinkel, but contributions are always welcome =)
13:39:28 <c_wraith> can I tell cabal repl to load only a single file?
13:39:35 <looma> mm_freak: does it makes sense?
13:39:54 <glosoli> Anyone on Mac installed haskell-platform from Homebrew ?
13:39:58 <mm_freak> looma: yes, but we need more information…  for example you probably have a database connection handle, which itself encodes all database operations
13:39:58 <c_wraith> like..  Yes, I know every other file will have compile errors.  I just want to check *that* one.
13:40:01 <glosoli> Wondering if it always takes soo long
13:40:11 <glosoli> Been like ~15 minutes
13:40:14 <glosoli> still not finished
13:40:22 <mm_freak> looma: testing then amounts to writing a fake database handler that uses an STRef or something
13:40:49 <mm_freak> looma: Free gives you access to the actual structure of the computation, which is normally not necessary for testing
13:41:17 <looma> mm_freak: agree, it looks like overkill
13:41:26 <looma> i have pretty much soething like http://lpaste.net/102544
13:41:39 <mm_freak> looma: example:  you cannot at all take apart an IO action…  once you have an IO action it's completely opaque
13:42:10 <mm_freak> looma: but a 'Free IO' computation can be taken apart, and you will know that some IO action wants to feed its result to another, so you can do something with that information
13:43:17 <looma> mm_freak: for example substitue result of IO operation with fake data for testing, right?
13:43:59 <mm_freak> looma: not quite, because you still can't know /which/ action wants to feed data, and more importantly you can't know /at all/ what the receiving function will give
13:44:15 <mm_freak> looma: notice that (>>=)'s second argument is a function, and functions are also opaque
13:44:55 <mm_freak> looma: what you can do:  you can create a functor that encodes the actual database operations
13:45:02 <corgifex> monochrom: your "function application" example turns "iterate id 'c'" into "'c' : iterate id 'c'". shouldn't that be "'c' : iterate id (id 'c')" (or an id box with two pointers to it)?
13:45:17 <mm_freak> looma: but the question is whether you need this for testing, which of course depends on your application
13:45:21 <looma> mm_freak: hm, why i can't know it if i'm writing free monad interpreter and pretty much enumertaing all possible functions, what they take and what they return?
13:46:23 <mm_freak> looma: this is a general problem with monads: you can only evaluate up to the first action
13:46:30 <mm_freak> but you need to perform that action to be able to continue
13:47:14 <prinsen> Is there any nice way to make a Pipe repeat forever?
13:47:19 <c_wraith> dcoutts: I'd *really* appreciate it if cabal repl didn't try to load all modules in the package.  I'm fine with saying :load Module.Name in order to have cabal repl work when not every module in the file is in compilable shape.
13:47:32 <c_wraith> prinsen: doesn't Pipes have its own forever combinator?
13:47:40 <mm_freak> prinsen: forever (await >>= …)
13:47:50 <looma> mm_freak: free monads gives me basically tree of computation and i can walk it like i want to without evaluated anything
13:48:28 <c_wraith> looma: that's not actually true.  You the tree depends on the results of the evaluation.  You can't walk it without evaluating it, to some extent.
13:48:33 <mm_freak> looma: that's not quite true…  example:  Free c, where c :: F (Free F a)
13:48:42 <c_wraith> looma: free *applicatives* let you walk it without evaluating it
13:48:47 <mm_freak> now to continue you need to turn the F (Free F a) into a Free F a
13:50:04 <monochrom> "how do I extract Free F a from F (Free F a)?" :)
13:50:14 <looma> c_wraith: mm_freak ah, okay
13:50:35 <mm_freak> looma: this is related to (>>=)'s second argument being a function…  you cannot example the further structure of the computation without providing an actual argument to that function
13:50:56 <mm_freak> s/example/examine/
13:51:24 <looma> mm_freak: yeah, i understand
13:51:28 <hakujin> anyone used protocol buffers in a non trivial project and want to damn/praise it?
13:52:04 <looma> mm_freak: could you please expand a little one functor for encoding db operations?
13:52:10 <looma> s/one/on/
13:52:53 <mm_freak> looma: data DbOp k v a = Insert k v a | Delete k | …
13:53:14 <mm_freak> uhm
13:53:18 <mm_freak> looma: data DbOp k v a = Insert k v a | Delete k a | …
13:54:12 <mm_freak> type Db k v = Free (DbOp k v)
13:54:37 <corgifex> monochrom: how does this work with IO? e.g. what's the asymptotic complexity of getLine = getChar >>= \c -> if c == '\n' then return [] else getLine >>= \cs -> return (c : cs) ?
13:54:45 <looma> mm_freak: heh, it still uses free monads :)
13:55:05 <monochrom> it uses linear space
13:55:22 <mm_freak> looma: and it has the same problem =)
13:55:25 <corgifex> but why? :-)
13:55:33 <monochrom> I haven't had time to write about IO
13:55:36 <mm_freak> looma: but the real question is:  what do you need to test exactly?
13:55:52 <corgifex> well, it has to use linear space somewhere to hold the line
13:55:52 <haasn> mm_freak: yes, it's possible to implement unsafeCoerce with acme-schoenfinkel: http://lpaste.net/102546
13:56:00 <corgifex> but how much stack does it use?
13:56:02 <prinsen> mm_freak c_wraith: I think Im unclear, I have a  Pipe that awaits once, I would like to transforme it into a pipe with the same type but that awaits forever
13:56:04 <haasn> this is GHC 7.8 specific but it's easily modifiable to GHC 7.6
13:56:25 <roconnor> corgifex: stack?
13:56:49 <corgifex> roconnor: "Asymptotic stack complexity is the depth of nesting in the evaluation sequence (how many times I zoom into sub-expressions)."
13:57:02 <prinsen> might not be possible
13:57:22 <looma> mm_freak: functions which are using db
13:57:30 <mm_freak> haasn: interesting…  thanks for the information
13:57:34 <roconnor> corgifex: where is that from?
13:57:41 <monochrom> it's from me, roconnor
13:57:51 <monochrom> now don't you dare say I'm wrong! :)
13:57:53 <haasn> mm_freak: and given the other known vulnerabilities with GNT it's also possible with just GADTs and also highly likely to be possible in just H98+acme-schoenfinkel, otherwise at least letting you break invariants
13:58:01 <mm_freak> looma: but what exactly?  the functions themselves or their influence on the database?
13:58:01 <monochrom> anyway, http://www.vex.net/~trebla/haskell/lazy.xhtml
13:58:18 <mm_freak> prinsen: 'forever' should give you that
13:58:33 <mm_freak> prinsen: (>>=) is orthogonal to (>->)
13:58:39 <monochrom> but I haven't covered IO's >>=, so whatever happens to >>= and recursion is not described there
13:58:44 <corgifex> monochrom: what about the (id 'c') thing from earlier?
13:59:01 <roconnor> mm_freak: oh I won't say you are wrong (yet);  It's just that I programmed in haskell for 7 years before I realized that GHC has a stack.
13:59:22 <mm_freak> roconnor: ?
13:59:41 <monochrom> that is just erroneous nick completion :)
13:59:50 <mm_freak> ah =)
14:00:07 <roconnor> mm_freak: ah sorry
14:00:59 <monochrom> I tell you what, a few years ago, I suddenly saw that a stack is an optimization rather than a fundamental necessity. no matter what language you're talking about.
14:01:47 <corgifex> a push-only stack? :-)
14:02:04 <corgifex> no, wait. what are you doing, brain
14:02:12 <hpc> i implement all my stackless languages with a priority queue
14:02:15 <quchen> data () = () -- push-only stack
14:02:25 <hpc> i insert each element with a priority equal to the length of the queue ;)
14:03:00 <prophile> it's useful to have an operation to determine whether a stack is empty
14:03:01 <monochrom> if you use rewriting to execute your program. and if you don't mind that at every rewrite step you begin by a linear scan for "which subexpression do I rewrite this time?", then you need no stack. the stack is just for saving that linear scan.
14:03:02 <mmachenry> Hey everyone. I'm currently in the process of creating a new piece of code at my company. We're mostly a Perl shop and I might end up persuading people to allow me to write this in Haskell. I'm wondering if anyone has any advice or potentially links to good advice about programming in Haskell in large teams and what coding conventions people recommend following.
14:03:05 <prophile> so I'd implement it with a Bool
14:03:17 <mm_freak> but Bool makes you go blind
14:03:41 <quchen> prophile: () has two values already! GHC 7.10 will hopefully be able to pattern match on that other one
14:03:53 <prophile> hah
14:04:11 <cdk> quchen: that second value being _|_ or something else?
14:04:23 <hpc> mmachenry: don't let your types get ridiculous, and name everything you care about
14:04:23 <quchen> cdk: :-)
14:04:31 <prophile> cdk: the second value being FILE_NOT_FOUND, obviously
14:04:32 <hakujin> mmachenry: use hlint. ideally use a tool (vim, emacs, etc) that incorporates it into the development process. unless you really know why not, follow what it suggests.
14:04:54 <mmachenry> hlint, good idea.
14:05:02 <mmachenry> Thanks hakujin.
14:05:18 <roconnor> monochrom corgifex: I imagine that corgifex's getLine definition uses constant stack stape.
14:05:20 <roconnor> *space
14:05:38 <c_wraith> stack tape
14:05:43 <c_wraith> everyone knows computers are made of tapes
14:05:51 <monochrom> yes, I agree, I think it's empirically true
14:06:07 <monochrom> not the tape part! :)
14:06:10 <c_wraith> I mean, they're turing machines, right?
14:06:21 <merijn> c_wraith: Naah, pi-calculus
14:06:29 <monochrom> no, they're duct-taped by engineers :)
14:06:39 <merijn> Just have your computer split into two computers as needed
14:06:43 <mmachenry> Also I have one oddly specific question. Do Haskellers generally recommend importing modules qualified? Qualified but with a shorter, one word alias? Do you recommend specifically listing out which functions you're importing or just import all? Does it depend on the module? Remember I'm writing software at a place with a lot of engineers so I'd like to set up guide lines that can be followed if possible.
14:06:54 <looma> mm_freak: hm, i think influence on db, because i can't think of a think to test with function wich are made to influence db
14:07:00 <corgifex> roconnor: how do I develop an intuition for that?
14:07:04 <monochrom> when you open up your computer, you see the CPU duct-taped to the motherboard, the graphics cards duct-taped to the motherboard...
14:07:13 <corgifex> because if you asked me, I'd have no idea where to even start
14:07:19 <merijn> mmachenry: I mostly import unqualified unless names collide, in which case I add a short prefix (BS for ByteString, T for Text, S for Set, etc.)
14:07:29 <rento> Lets say a client makes a http-request to start a new game to my server. now there might not be another player ready so he has to wait. I send a response to say that  but then I want to send him the game data once there actually is another player. but how would I send it to the client? can I get IP from a http request? how would I know where to send my messsage?
14:07:35 <looma> s/of a think/of a thing/
14:07:41 <roconnor> mmachenry: generally I do not use qualified imports beyond the modules that demand it: e.g. Data.Map.
14:08:05 <roconnor> mmachenry: I generally recommend listing out every import for "serious" code. (PS I don't write serious code).
14:08:31 <mm_freak> mmachenry: my advice is to keep your current methodology, but with haskell instead of perl…  the necessary changes will develop by themselves, and your team can focus on the problem of learning haskell
14:08:46 <gamegoblin> Anyone have a quickcheck tutorial they are particularly fond of?
14:08:49 <zerokarmaleft> mmachenry: I prefer explicit imports by default in whatever current language I'm working
14:09:07 <mm_freak> looma: in that case you don't really need to use Free
14:09:21 <mm_freak> looma: my own in-production approach is to write a fake database handler for testing
14:09:28 <mmachenry> rento http doesn't work that way sadly
14:09:32 <mmachenry> Oops bold
14:09:37 <zerokarmaleft> however, hoogle tends to dampen the effect of not knowing the origin of a function
14:09:44 <roconnor> corgifex: There are two sorts of issue at hand here: one is a mental model of IO, and the other is a mental model of evaluation of "pure" haskell expressions.
14:09:52 <mm_freak> looma: i will release my remote-values library that deals with that sort of thing
14:10:16 <roconnor> corgifex: First you need a mental model of pure expression evaluation.
14:10:33 <mmachenry> zerokarmaleft: So you list out everything you use from the module?
14:10:34 <mm_freak> mmachenry: as for the import question, just do what you find readable
14:10:44 <corgifex> roconnor: I've got one in lazy.xhtml
14:11:54 <geekosaur> rento: you can't do that with http. at all. (I am behind at least 3 layers of NAT, only one of which I have any control over; your web server can not establish a connection to me or send me data on its own volition.)
14:11:58 <mm_freak> rento: "HTTP push" is a good search term
14:12:00 <roconnor> corgifex: okay; once you get comfy with that, then you need to mentally model IO as a free monad.
14:12:03 <looma> mm_freak: could you provide a small example of how one can write such fake handler?
14:12:05 <zerokarmaleft> mmachenry: depending on the module, haskell is odd in that so much "standard" functionality is not included in Prelude
14:12:18 <mm_freak> rento: the basic idea is to keep the connection open until there is news
14:12:38 <mm_freak> looma: that highly depends on the database abstraction you use
14:12:46 <prinsen> mm_freak: I finally got it working. I think this is rather strange of GHC
14:12:50 <mmachenry> rento: Also a lot of HTTP programs poll the server at a constant rate.
14:12:55 <prinsen> mm_freak: forever $
14:12:55 <prinsen>                    ((yqlfacebook_graph_user_feed_postProducer >->
14:12:55 <prinsen>                      yqlfacebook_graph_user_feed_postPipe)
14:12:58 <prinsen>                     :: (MonadIO m) => Pipe Value Dynamic (APIT m) (Maybe Dynamic))
14:13:05 <roconnor> corgifex: lazy evaluation quiz:  What is the value of runState
14:13:07 <corgifex> roconnor: is that the one with data IO a where { Return :: a -> IO a; Bind :: IO a -> (a -> IO b) -> IO b; GetChar :: IO Char } ?
14:13:28 <roconnor> corgifex: no.
14:13:37 <prinsen> Ghc requires me to specify Maybe, or it thinks MonadPlus mp is ambigious
14:13:48 <corgifex> aw
14:14:02 <prinsen> but I obviously dont use it, so why reqire it to be specified
14:14:17 <mm_freak> prinsen: note that there is also the 'for' function
14:14:29 <corgifex> roconnor: runState = \m s -> ...
14:14:35 <prinsen> mm_freak: That does't fit my need here, forever was correct
14:14:40 <mm_freak> prinsen: it is better to:  forever yielder >-> forever awaiter
14:14:46 <looma> mm_freak: persistent/groundhog type of thing
14:14:58 <roconnor> corgifex: sorry I cut myself off
14:14:59 <mm_freak> looma: in that case it's probably a lot of work
14:15:02 <looma> mm_freak: what are you using in production?
14:15:10 <prinsen> mm_freak:  Could not deduce (MonadPlus mp0)
14:15:11 <prinsen>       arising from a use of `yqlfacebook_graph_user_feed_postProducer'
14:15:14 <roconnor> corgifex: lazy evaluation quiz:  What is the value of runState (do { x <- get; undefined; put 5; return x}) 7
14:15:27 <mm_freak> looma: in most cases acid-state, sometimes postgresql-simple
14:15:48 <mm_freak> in the latter case i write high-level wrappers around the SQL stuff
14:16:27 <corgifex> roconnor: which definition of State are we using?
14:17:10 <roconnor> corgifex: data State s a = State {runState :: s -> (a,s) }
14:18:52 <monochrom> that is not quite the point. you have to look at State's >>=
14:19:10 <corgifex> sure, but I know how to write that
14:19:37 <monochrom> and it makes a big difference. because Control.Monad.State.Lazy and Control.Monad.State.Strict differ right there
14:20:13 <monochrom> and you don't really know how to write that until you know two ways of writing that, which is exactly that difference.
14:20:29 <roconnor> x >>= f = State $ \s0 -> let (s1,a) = runState x s0 in runState (f a) s1
14:20:40 <corgifex> oh, I didn't even see the 7
14:29:41 <khyperia> If I want to write a X window manager, would XHB ( http://hackage.haskell.org/package/xhb ) be the right package to use, or is there a different one that's better?
14:29:57 <corgifex> hmm. I seem to be missing an exact definition of let / irrefutable patterns
14:31:03 <geekosaur> khyperia, xmonad uses the X11 package, but if we were reimplementing it from scratch we'd go with xhb
14:31:37 <geekosaur> we (well, sjanssen) actually looked at switching at one point but libX11 is baked a bit too deeply into xmonad's core
14:31:48 <khyperia> Ah, cool, thanks!
14:31:54 <roconnor> corgifex: if you prefer use let {p = runState x s0; s1 = fst p; a = snd p} in ..
14:32:17 <khyperia> I assume you're part of xmonad then, geekosaur?
14:32:18 <roconnor> corgifex: that is more or less what an irrefutable pattern will denote.
14:32:21 <looma> does anyone knows by chance is it possible to move large quasiquote to file?
14:32:22 <geekosaur> yes
14:32:33 <looma> geekosaur: how?
14:32:34 <mm_freak> geekosaur: are there any plans/experiments on adding compositing, possibly with GLX?
14:32:44 <geekosaur> looma, sorry, that wasn't intended for you
14:32:51 <looma> oh, okay
14:33:25 <looma> https://github.com/lykahb/groundhog i'd like to move that yaml out of quasiquotation to separate file
14:33:28 <looma> (mkPersist)
14:33:30 <geekosaur> mm_freak, it's been discussed but it's somewhat painful to do and I am not aware of any current work on it
14:33:44 <geekosaur> at one point we had an open ticket about it
14:34:10 <mm_freak> geekosaur: which part of it is painful?
14:34:15 <geekosaur> https://code.google.com/p/xmonad/issues/detail?id=19
14:34:28 <geekosaur> mostly that x11's compositing interface is horrible
14:34:49 <mm_freak> i see
14:35:25 <SplinterOfChaos> Why is it Haskell doesn't allow equality on functions?
14:35:54 <mm_freak> SplinterOfChaos: because it's undecidable
14:35:57 <looma> i know yesod does something similar, it has sepratae file for routing which are basically quasicotes extrascted to file
14:36:39 <SplinterOfChaos> mm_freak: How so? Do you mean at the language level?
14:36:57 <mm_freak> SplinterOfChaos: perhaps you have a different notion of equality in mind
14:37:42 <SplinterOfChaos> Maybe so.
14:38:38 <SplinterOfChaos> So is there any way to compare two functions to prove they refer to the same definition? (To be more precise.)
14:39:12 <companion_cube> the same syntactic definition, or that they give the same results ?
14:39:12 <mm_freak> SplinterOfChaos: functions in haskell are completely opaque, unless you cheat (TemplateHaskell)
14:39:59 <mm_freak> SplinterOfChaos: there is also a way to compare the memory locations of functions, but that's a rather fragile way to compare functions
14:40:04 <corgifex> SplinterOfChaos: x = 2 + 2; y = 4; is x == y?
14:40:26 <mm_freak> corgifex: yes
14:40:39 <SplinterOfChaos> That's what I was curious about.
14:41:50 * Clint squints.
14:42:06 <ReinH> (x and y aren't functions)
14:42:35 <stian> freqActivities :: Entries -> M.Map S.ByteString Int \n freqActivities x = freqMap $ concatMap events x
14:42:37 <stian> This two-liner works great, but gives an error if I try to eta-reduce? How come?
14:43:15 <corgifex> roconnor: I get (x, s3') where x = fst (runState get 7) and s3' is something terrible
14:43:17 <c_wraith> You know, I was going to spend all day playing video games, but I've spent it all on writing new code instead.  Thanks new compilers!
14:43:38 <hexagoxel> stian: because you need "." instead of "$", probably
14:43:54 <jle`> stian: look at the type of freqMap $ concatPam events
14:44:01 <jle`> and you will see.
14:44:07 <stian> hexagoxel: Indeed... So why does it work with the x?
14:44:22 <jle`> stian: look at the types :)
14:44:29 <corgifex> stian: a x = b (c x) isn't directly eta-reducible
14:44:37 <roconnor> corgifex: runState get = \x -> (x,x)
14:44:40 <corgifex> the x needs to be at the end in both cases
14:45:12 <corgifex> roconnor: sure. you want more than WHNF?
14:45:32 <jle`> consider f x = f $ g x; f :: b -> c; g :: a -> b; x :: a
14:45:35 <jle`> g x :: b
14:45:38 <roconnor> corgifex: I want the normal form.
14:45:41 <jle`> f (g x) :: c
14:45:44 <jle`> all is good
14:45:53 <jle`> now what is the type of f $ g ?
14:46:05 <jle`> :t ($)
14:46:06 <lambdabot> (a -> b) -> a -> b
14:46:06 <stian> jle: The freqMap $ concatMap events doesn't even give me the type info, just error. freqMap $ concatMap events lines works perfectly. In my mind, freqMap should take th result of concatMap events lines, so using $ or () is appropriate.
14:46:17 <jle`> f $ g doesn't even make sense
14:46:24 <jle`> because the right hand side has to be a
14:46:41 <jle`> but in our case we are using (b -> c) and (a -> b)
14:46:44 <corgifex> roconnor: is that where everything is fully evaluated?
14:46:51 <joelteon> How do I run the preprocessor only?
14:47:08 <joelteon> Or at least, figure out what the preprocessor would produce.
14:47:10 <roconnor> corgifex: yes
14:47:14 <roconnor> corgifex: no redexes
14:47:22 <jle`> stian: what is the type of freqMap and (concatMap events) ?
14:47:44 <roconnor> corgifex: well, if you think you are going to infinite loop, please let me know.  I don't want you to hang. :D
14:47:56 <roconnor> corgifex: that shouldn't happen here.
14:48:08 <stian> jle: freqMap :: forall a. Ord a => [a] -> Map a Int, (concatMap events) :: [Entry] -> [ByteString]
14:48:29 <hexagoxel> f $ g x === f (g x) === (f.g) x
14:48:35 <jle`> and look at the type of ($)
14:48:37 <jle`> :t ($)
14:48:38 <lambdabot> (a -> b) -> a -> b
14:48:42 <jle`> you can't get that to unify
14:48:51 <jle`> with freqMap $ concatMap events
14:48:57 <jle`> it just don't make no sense
14:49:04 <roconnor> corgifex: (acutally, what I really wanted was the denotation of the expression, but let's go with normal form for now).
14:49:12 <stian> jle: I'm still developing my intuition of this...
14:49:22 <jle`> do you know what i mean by unify?
14:49:33 <stian> jle: too used to other languages. b produces something, take it and feed it into a...
14:49:35 <corgifex> oh yeah, s3' is 5
14:49:43 <stian> jle: not sure (unify)
14:49:46 <corgifex> roconnor: (7, 5)
14:49:50 <jle`> it makes to make the types match up
14:49:51 <pordan30> is there a function like lookupAlter :: (Maybe a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a) that returns 'a' unaltered (if it exists) and the altered map in a single search (as opposed to lookup followed by alter, that requires two searches)?
14:50:03 <jle`> so if we have something like (+ 3) $ 5
14:50:06 <jle`> (+ 3) is Int -> Int
14:50:08 <jle`> 5 is Int
14:50:18 <jle`> ($) would be (Int -> Int) -> Int -> Int
14:50:19 <roconnor> corgifex: very good.
14:50:22 <jle`> does that make sense?
14:50:36 <jle`> you're taking the type signature of ($), (a -> b) -> a -> b, and you're saying what a and b are
14:50:36 <stian> jle: yes
14:50:43 <jle`> so when you try to do something like
14:50:47 <jle`> freqMap $ concatMap events
14:51:03 <jle`> it just...can't unify.
14:51:14 <jle`> if you use (freqMap $)
14:51:21 <jle`> freqMap :: [a] -> Map a Int
14:51:27 <jle`> then the only thing that can go on the other side
14:51:31 <jle`> is a [a]
14:51:49 <stian> which is what concatMap produces, specificyally a [ByteString]...?
14:51:50 * rento slaps lambdabot around a bit with a large trout
14:51:50 <jle`> freqMap $ [1,2,3] would make sense
14:51:52 <roconnor> corgifex: Okay, so a free monad model of IO looks something like data IO a = Return a | PutCharNode Char (IO a) | GetCharNode (Char -> IO a) | ...
14:52:07 <jle`> stian: (concatMap events) is *not* a [ByteString]
14:52:07 <corgifex> I wouldn't've expected it to survive the undefined
14:52:14 <jle`> it's an [Entry] -> [ByteString]
14:52:33 <jle`> so you can't put an ([Entry] -> [ByteString]) whre you would want a [ByteString]
14:52:34 <stian> I see.. so I'm feeding the function as an argument, not the result of the function.
14:52:39 * stian whacks head.
14:52:42 <corgifex> but it makes sense because we're not binding the result of undefined and >>= is lazy enough to not inspect the state until we override it with put anyway
14:52:47 <roconnor> corgifex: which is a tree with leaves of a, some internal node carrying Char and some branches labeled with Char.
14:52:50 <jle`> stian: yeah
14:52:56 <jle`> that's like using (*2) when you expect an Int
14:53:20 <roconnor> corgifex: right, that state expression evaluates fine because the "undefined" part is "disconnected" from the rest of the expression.
14:53:24 <jle`> no problem, this stuff is very disorienting at first :)
14:53:52 <roconnor> corgifex: lazy evaluation is all about chasing data dependencies.
14:55:07 <roconnor> corgifex: the put statement disconnects the previous undefined state, so it isn't demanded, and the return x demands the state bound before the undefined.
14:55:28 <corgifex> roconnor: why is Return a in there?
14:56:07 <roconnor> corgifex: a free monad always has a "leaf" type holding the return value.
14:56:25 <corgifex> yeah, but nothing cares about the result of main
14:56:36 <roconnor> corgifex: the type of main is (supposed to be) IO ()
14:56:42 <roconnor> meaning the leaves hold no values.
14:56:57 <corgifex> ghc accepts IO anything
14:57:22 <roconnor> corgifex: correct, and ghc will ignore the value held in the Return node.
14:57:44 <stian> jle: Thanks a lot, really helpful!
14:57:45 <roconnor> The main purpose of the Return node is for assembling the IO () value out of little bits.
14:57:49 <jle`> stian: np!
14:57:52 <corgifex> that's why I was thinking you could just use Return | ...
14:58:07 <corgifex> hmm, wait
14:58:27 <hexagoxel> :t updateLookupWithKey
14:58:28 <lambdabot>     Not in scope: updateLookupWithKey
14:58:28 <lambdabot>     Perhaps you meant one of these:
14:58:28 <lambdabot>       IM.updateLookupWithKey (imported from Data.IntMap),
14:58:32 <corgifex> I think I see what's going on
14:58:45 <hexagoxel> :t Data.Map.Strict.updateLookupWithKey
14:58:46 <lambdabot> Ord k => (k -> a -> Maybe a) -> k -> M.Map k a -> (Maybe a, M.Map k a)
14:58:47 <roconnor> corgifex: right, IO () is isomorphic to Return | ...; however Return is used for assembling the tree.  For example
14:58:51 <hexagoxel> pordan30: ^
14:58:56 <hexagoxel> close enough?
14:59:01 <corgifex> yes, you need it in >>=
14:59:02 <roconnor> corgifex: getChar = GetCharNode \c -> Return c
14:59:21 <roconnor> corgifex: getChar = GetCharNode (\c -> Return c)
14:59:40 <corgifex> GetCharNode Return
14:59:44 <roconnor> yes
15:00:15 <hexagoxel> in mtl, why don't the classes have instances that lift over any MonadTrans instance?
15:00:24 <hexagoxel> (more elaborate question at http://lpaste.net/102548)
15:00:26 <pordan30> hexagoxel: oh, that works - i guess my eyes glazed over it when looking at the interface documentation
15:00:33 <roconnor> it builds a little tree with braches for every Char leading to a leaf holding a value which is the same as the label of the branch to it.
15:01:25 <roconnor> putChar c = putCharNode c (Return ())
15:01:30 <corgifex> Return x >>= f = f x; GetCharNode g >>= f = GetCharNode (\c -> g c >>= f); PutCharNode c m >>= f = PutCharNode c (m >>= f)
15:01:48 <hexagoxel> pordan30: wait, that returns the changed value
15:01:49 <roconnor> corgifex: yes
15:02:18 <hexagoxel> sorry, i only looked at the type :D
15:02:52 <roconnor> corgifex: now when you take getChar and bind putChar to it you get (getChar >>= putChar) which evaluates to GetCharNode (\c -> PutCharNode c (Return ()))
15:03:13 <corgifex> evaluating under the lambda? is that legal?
15:04:13 <roconnor> corgifex: well, evaluating under a lambda gives you a value with that denotes the same thing (though can have different complexity).
15:04:32 <roconnor> corgifex: this is helpful for understanding the denotation of IO.
15:05:10 <pordan30> hexagoxel: there's a series of insertLookup functions also, i guess; i was looking for something that would permit deletion or update with lookup of the original value. i guess there isn't anything useful in the interface :/
15:05:49 <roconnor> corgifex: We want to separate our operational concerns of lazy evaluation, and the denotational concerns of what IO might mean, and then we can put them together to have a model of the performance of lazy evaluation of IO values.
15:06:14 <roconnor> corgifex: so GetCharNode (\c -> PutCharNode c (Return ()))
15:06:52 <roconnor> corgifex: this is a tree beginning with a branch for every Char, followed by a PutCharNode holding that Char, followed by a leaf containing ().
15:07:15 <corgifex> ok
15:07:26 <roconnor> corgifex: This tree represents a little program that echos one character.
15:07:37 <hexagoxel> pordan30: yeah i can't find anything either
15:08:10 <pordan30> hexagoxel: in any case, thanks for looking :)
15:08:31 <roconnor> corgifex: the Haskell run time system traverses this tree starting from the root where it sees a "GetCharNode" and pauses to wait for a terminal input.  When a character is received it traverses the corresponding branch and finds a PutCharNode...
15:09:13 <roconnor> corgifex: then the character held at the PutCharNode is sent to the terminal output, and the runtime system proceeds to the next node, which is a Return leaf.  Hitting the leaf causes the run time system to exit the program.
15:09:48 <roconnor> corgifex: Now, as you already noted, the run time system will not put this tree in normal form right away.
15:10:23 <heatsink> Has anyone here used cmdargs?
15:10:30 <roconnor> corgifex: instead it will lazily traverse this tree, performing just enough evaluation to read the next constructor and contents (if any).
15:11:02 <roconnor> corgifex: and only the subtrees under the branches that are demanded will be evalutated.
15:11:23 <roconnor> corgifex: hopefully you can imagine how this process would work.
15:11:24 <ReinH> roconnor: is it relevant here that () is a terminal object?
15:11:32 <corgifex> I'm imagining a C function containing a while loop, a switch, and calls to eval_whnf
15:12:00 <roconnor> corgifex: that is a fairly reasonable model.
15:12:13 <roconnor> ReinH: ghc will ignore the contents of the Return statement.
15:12:25 <ReinH> roconnor: oh right
15:12:27 <roconnor> ReinH: there is an argument to be made that main ought to have type IO Void.
15:12:51 <ReinH> but... then you couldn't construct a value?
15:13:03 <corgifex> exitSuccess
15:13:15 <roconnor> ReinH: this will ensure that there are no Return nodes, forcing the developer to call SystemExitNode as in data IO a = ... | SystemExitNode Int | ...
15:13:24 <ReinH> roconnor: right
15:13:49 <corgifex> kind of sucks for hello world, though
15:13:54 <roconnor> or making sure the program never terminates by having an infinite tree.
15:14:00 <darthdeu> is there an easy way to install a cabal package from git repo directly?
15:14:10 <ReinH> roconnor: makes sense
15:14:13 <roconnor> corgifex: which part sucks for hello world?
15:14:21 <corgifex> "no, you can't write main = putStr "Hello, World!\n", it has to be main = putStr "Hello, World!\n" >> exitSuccess"
15:14:35 <corgifex> otherwise you get an obscure type error
15:14:55 <roconnor> corgifex: this is probably why IO Void isn't enforced.
15:15:11 <darthdeu> or to be specific, i'm getting a weird license error when trying to install the cabal-db package https://gist.github.com/darthdeus/bda3733f32fe49327d68
15:15:16 <tel_> Anyone have any secondary materials useful for understanding Filinski's "Declarative Continuations and Categorical Duality"?
15:15:41 <roconnor> I just imagine the haskell compiler always tacking on a (>> exitSuccess) to main.
15:16:07 <roconnor> corgifex: how long have you been using Haskell?
15:16:16 <corgifex> just like a C compiler will add 'return EXIT_SUCCESS;' :-)
15:17:09 <levi> darthdeu: How 'directly' do you want? If there's a hackage entry for it and it has a git repo as the source, you can cabal unpack -s <package> and then cd to the directory and cabal install.
15:17:09 <tel_> I feel like I'm beginning to understand the SLC but not well enough to get all the bits about duality so casually mentioned
15:17:29 <darthdeu> levi: that's good enough :) thanks
15:17:55 <darthdeu> hmm weird, it fails to build even from git
15:17:59 <darthdeu> failing on Distribution.License.AGPL
15:18:55 <levi> darthdeu: Perhaps you need a newer cabal?
15:19:38 <darthdeu> 1.18.0 isn't new enough?
15:19:39 <corgifex> roconnor: I'm not sure. 7 years maybe?
15:19:47 <darthdeu> trying to update
15:20:17 <levi> darthdeu: Hmm. I don't know then. Although since you now have the source, you can modify it so it'll build.
15:20:59 <darthdeu> levi: yeah it builds when I remove a single line that pattern matches on the AGPL license, though I wonder why this isn't working, i've reinstalled ghc and cabal about 2 weeks ago ... but maybe the update i'm doing now will help
15:21:41 <stolaruk> Should I use "catchIOError" instead of "catch"? I can't seem to import "catch" from "System.IO.Error"...
15:21:42 <roconnor> corgifex: oh good.  You seemed disturbining comfortable with all this.
15:21:49 <roconnor> *disturbingly
15:22:13 <levi> Heh.
15:22:31 <corgifex> I've even see the free monad thing before (in the context of parsing), I just didn't know I knew
15:22:32 <darthdeu> levi: wow it works with new cabal ... that is 1.18.1.3
15:22:36 <darthdeu> thanks for the help :)
15:23:01 <roconnor> corgifex: anyhow, with all this, when the runtime system evaluates getLine, it will use constant stack space because I don't see anywhere where nested case statements will occur.
15:23:40 <levi> darthdeu: It was apparently added on 2013-06-05
15:24:01 <levi> (AGPL as a license known by cabal, I mean)
15:24:55 <darthdeu> hmm, weird why it wasn't in the version i had before
15:25:04 <darthdeu> 2013-06-05 is almost a year ago
15:25:07 <roconnor> corgifex: it will lazilly evaluate a tree with a bunch of GetCharNodes and accumulate a heap conting some mess of unevaluated lambdas and read characters,
15:25:22 <roconnor> corgifex: this heap will be linear in the number of read characters.
15:26:31 <roconnor> I find getting GHC to use stack without using primops is very hard.
15:26:57 <roconnor> partly because I don't write really terrible Haskell code anymore.
15:27:18 <nisstyre> is there a better way of turning a Word24 (represented as a Word32 with the last 8 bytes ignored) than n `rotateL` some_multiple_of_8 `shiftR` 24? My bit twiddling skill is not great :)
15:28:03 <nisstyre> s/8 bytes/8 bits/
15:28:07 <heatsink> What is turning a word?
15:28:08 <roconnor> nisstyre: turning?
15:28:16 <nisstyre> roconnor: as in Word24 -> [Word8]
15:28:20 * hackagebot texmath 0.6.6.1 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.6.1 (JohnMacFarlane)
15:28:36 <nisstyre> where [Word8] is 3 Word8s
15:28:40 <nisstyre> i.e. 24 bits
15:28:50 <levi> darthdeu: That's the git blame date; maybe it took a bit longer to get into the release. Beats me!
15:29:25 <heatsink> [(n `shiftR` o) .&. 0xff | o <- [8, 16, 24]]
15:29:40 <nisstyre> heatsink: that's more concise I guess
15:30:02 <roconnor> [(n `shiftR` o) :: Word8 | o <- [8, 16, 24]]
15:30:16 <corgifex> :t shiftR
15:30:17 <lambdabot> Bits a => a -> Int -> a
15:30:33 <heatsink> :t fromIntegral
15:30:34 <lambdabot> (Num b, Integral a) => a -> b
15:30:57 * roconnor wonders if there is a Traversal' Word32 Word8
15:31:18 <levi> Binary does some stuff like that, IIRC.
15:31:24 <roconnor> gah right
15:31:32 <roconnor> [fromIntegral (n `shiftR` o) :: Word8 | o <- [8, 16, 24]]
15:31:42 <nisstyre> levi: so maybe I should be using the Binary module for this?
15:32:23 <levi> nisstyre: If you have a lot of parsing of bytes out of structured binary data to do, it might help you.
15:33:03 <nisstyre> levi: I'm writing a small program to download TLS certs, so I want to implement a client hello, which is a fair bit of packing bytes
15:33:44 <hakujin> Binary's Put is nice for that. Data.ByteString.Builder works too, if you need performance.
15:33:46 <roconnor> I used cereal for my binary parsing.
15:33:51 <levi> Yeah, I found Binary very helpful for doing wire protocol handling.
15:33:56 <nisstyre> hakujin: yeah I want it to be fast
15:34:28 <nisstyre> thanks for the hints
15:34:29 <levi> roconnor: Wasn't there some sort of merge of ceral and binary at some point? Or am I just imagining it?
15:34:47 <roconnor> levi: I haven't look in 2 years.
15:35:03 * thoughtpolice wants the new version of binary from Duncan
15:35:07 <roconnor> levi: they seemed to have different philophies.
15:35:08 <thoughtpolice> looks quite excellent
15:35:31 <hakujin> iirc Cereal is for strict and Binary is for lazy
15:35:37 <roconnor> levi: e.g. that horrible Data.Map security breach problem.
15:35:59 <nisstyre> hakujin: so probably Cereal performs better yeah?
15:36:07 <Clint> nisstyre: can't you use the tls package and friends?
15:36:37 <roconnor> nisstyre: IMHO, if you want to avoid security bugs, use cereal.
15:36:51 <nisstyre> Clint: I haven't looked, I might be able to, but all I really need is the first part of the handshake, then I can use other tools to parse the response
15:36:54 <thoughtpolice> the TLS package likely doesn't expose an API at the TLS HELLO level
15:37:06 <hakujin> nisstyre: I haven't benched cereal vs Data.ByteString.Builder. Builder has hPutBuilder which is Builder -> Handle -> IO () that is nice for avoiding interim allocations
15:37:18 <thoughtpolice> you'd want to write a HELLO manually if you were checking for Heartbleed, though :)
15:37:34 <nisstyre> thoughtpolice: actually I just want to look for startssl certs
15:37:47 <nisstyre> I could do this with openssl and bash but it would be slow as hell
15:38:33 <thoughtpolice> nisstyre: ah, well frankly i'd probably just go the ghetto way and just manually construct the bytes and pack them into a ByteString manually, but i'm odd like that.
15:38:42 <nisstyre> thoughtpolice: that's what I was going to do
15:38:50 * thoughtpolice came from a world where hand forging packets isn't really a big deal
15:38:58 <thoughtpolice> no need to even involve cereal or anything
15:39:09 <nisstyre> thoughtpolice: I thought I should at least try to be somewhat compliant though
15:39:22 <nisstyre> e.g. by generating pseudorandom values for part of the request as per the spec
15:39:40 <nisstyre> obviously not strong random numbers but still
15:40:04 <nisstyre> I could just copy and paste the request out of wireshark but that might not be robust
15:40:07 <roconnor> nisstyre: use 9.
15:40:15 <thoughtpolice> *nod* if all you need is the TLS HELLO, i imagine the choice of binary vs cereal ultimately isn't a big deal, really. binary may be 'better' just because it's in the platform
15:40:22 <nisstyre> yeah
15:41:10 * thoughtpolice does note dcoutts's new binary package should hopefully obsolete both the current binary and cereal :)
15:41:27 <hakujin> next haskell platform?
15:41:54 <roconnor> thoughtpolice: does it have decode :: ByteString -> Either String a?
15:42:13 <roconnor> thoughtpolice: where the Either part is what is important to me.
15:42:42 <hakujin> current binary has that roconnor, if you need it.
15:42:48 <sm> what's interesting about startssl certs ?
15:42:57 <roconnor> hakujin: oh?
15:43:01 <thoughtpolice> roconnor: it uses a CPS style for the decoder design, more like attoparsec. so you could add an Either variant on top of this quite easily, it's a small combinator
15:43:24 <roconnor> hakujin: when did that happen?
15:43:28 <hakujin> roconnor: decodeOrFail
15:43:54 <thoughtpolice> hakujin: where you referring to me when you said 'next haskell platform?'
15:43:56 <thoughtpolice> *were
15:44:04 <hakujin> yessir
15:44:05 <levi> roconnor: Johan Tibell seems to be trying to fold all Cereal functionality into Binary. I'm not sure if it's been complete, though.
15:44:22 <hakujin> roconnor: looks like 0.7 series
15:44:43 <roconnor> hakujin: nice.
15:44:44 <thoughtpolice> hakujin: ah. no, it's not done yet. it's a much improved design, internally it uses CBOR (RFC 7049) to represent data structures, which means binary values then aren't tied to the internal library representation
15:44:57 <thoughtpolice> (so they have meaning beyond the Haskell data types and you don't 'lose' your schema)
15:45:03 <roconnor> hakujin: does it still decode silently corrupted Data.Map values?
15:45:13 <roconnor> hakujin: those are my only two objections to Binary.
15:45:24 <hakujin> roconnor: I'm not sure
15:45:52 <nisstyre> sm: startssl is charging people lots of money to revoke certs, and they were initially free
15:46:00 <nisstyre> so it is unlikely that people will properly revoke them
15:46:12 <nisstyre> hence one might want to have a list of sites that are using them
15:46:51 <levi> discussion about cereal and binary plans: https://groups.google.com/forum/#!topic/haskell-cafe/3ZLPRsKFz8Q
15:47:08 <nisstyre> sadly it's hard to check if a site revoked their cert because some CAs use the same valid not before date in the reissued one
15:47:09 <hakujin> while we're talking about binary, has anyone benched Network.Socket.ByteString.sendMany vs Data.ByteString.Builder.hPutBuilder?
15:47:23 <nisstyre> and if you download the CRL it's just a bunch of serial numbers with the dates they were revoked
15:47:43 <roconnor> hakujin: looks like it still does.
15:47:50 <roconnor> hakujin: I consider that a security bug.
15:48:08 <roconnor> oh, unless Data.Map was fixed ...
15:49:08 <thoughtpolice> hakujin: ah, here are the slides http://code.haskell.org/~duncan/binary-experiment/binary.pdf
15:49:18 <hakujin> thoughtpolice: thanks!
15:49:22 <thoughtpolice> bonus: it's many times faster too
15:49:25 <thoughtpolice> as well as more sensible
15:50:59 <roconnor> nope
15:51:14 <roconnor> Binary is a security breach waiting to happen.
15:51:47 <levi> So Data.Map has a silent corruption bug still?
15:52:23 <roconnor> levi: I haven't tested it, but my code inspection suggests that it does.
15:53:12 <roconnor> I'm trusting the comment in fromDistinctAscList that "The precondition is not checked" is both true and relevent.
15:54:28 <corgifex> what could you do with a corrupted Map?
15:57:48 <roconnor> corgifex: make a map that appears to not contain invalidate data then appear to contain invalid data after inserting valid data into it.
15:58:04 <corgifex> sweet
16:01:41 <ion> The precondition is not checked. http://lpaste.net/50278
16:04:42 <roconnor> apparently the fix is to simply use formList because it will use the fast fromDistinctAscList until it sees something that isn't ordered.
16:05:14 <roconnor> roconnor: maybe someone who uses Binary and perfers data to not be corrupted should file a bug and/or a patch.
16:11:39 <akurilin> Does anybody know if there's a full list of types that are accepted by persistent-postgresql in the templated block?
16:11:53 <akurilin> I was looking as postgresql-simple for things like TimestampTZ
16:12:02 <akurilin> but I can't see to be able to re-use those types names inside the template block
16:12:13 <akurilin> so there's got to be a different naming scheme for those data types
16:21:15 <srhb> akurilin: Are they not represented by some type class?
16:22:01 <heatsink> There is an example in System.Console.CmdArgs.Implicit showing how you can put parsing annotations into a String field of a user-defined data type.
16:22:21 <srhb> akurilin: PersistField perhaps?
16:22:24 <heatsink> Then you can pass the data value to the parsing function.
16:22:25 <heatsink> I don't understand how that can work.
16:22:52 <srhb> akurilin: http://hackage.haskell.org/package/persistent-1.3.0.6/docs/Database-Persist-Class.html#t:PersistField
16:23:05 <srhb> akurilin: Presumably you can just write your own instance.
16:24:15 <davidthomas> Is there a void that's strict in the inside value?
16:25:11 <c_wraith> I don't see why there would be...
16:25:48 <corgifex> :t evaluate
16:25:49 <lambdabot> a -> IO a
16:26:17 <c_wraith> :t void . evaluate
16:26:17 <lambdabot> a -> IO ()
16:26:50 <c_wraith> :t (>>= (void . evaluate))
16:26:51 <lambdabot> IO a -> IO ()
16:27:02 <corgifex> :t () <$ evaluate ?x
16:27:03 <lambdabot> (?x::b) => IO ()
16:27:32 <darthdeu> if I export a type constructor from a module but not the data constructor that means nobody outside of that module is able to pattern match to deconstruct the type, right?
16:27:59 <corgifex> sounds right
16:28:03 <davidthomas> c_wraith: nice!  Not in IO, though.
16:28:05 <heatsink> They can't pattern match on the constructor
16:28:15 <heatsink> Does using field accessors count as pattern matching?
16:28:17 <akurilin> srhb: I managed to dig through some older code of mine and apparently for things like ZonedTime you just want to import Data.Time (ZonedTime) into that module and then referecing ZonedTime from within the quasiquoted section will work
16:28:22 <c_wraith> darthdeu: Well, no one outside the module is able to pattern match on that constructor.  I'm phrasing it that way because GHC 7.8 added pattern synonyms that could still be matched on.
16:28:44 <davidthomas> I probably don't actually need it, and should restructure things a bit less hacky...
16:28:52 <corgifex> a sufficiently crazy attacker can still get at your data but meh
16:29:02 <akurilin> srhb: seems like with persistent you just need to specify the final Haskell type you want and it will figure out which best representation to use among those PG postgres fields from postgresql-simple
16:29:25 <akurilin> But then again I have no idea what I'm talking about.
16:29:27 <srhb> akurilin: Yes, as you see ZonedTime already has a PersistField instance. :)
16:29:28 <darthdeu> c_wraith: but if I do   module Baz (Foo) where   data Foo a = Bar a  ... that means nobody is able to take the value out of Foo by pattern matching on Bar, right?
16:30:07 <corgifex> darthdeu: right
16:30:16 <darthdeu> awesome
16:30:42 <c_wraith> Yeah, I was just saying that it's possible to create other things to match values of that type against, now.  Just not the real constructor.
16:30:57 <corgifex> but those would have to be exported explicitly
16:31:02 <akurilin> srhb: oh ok I sort of get that persistfield code, I didn't realize I'd have to load the module containing the original data type it's going to conver tto
16:31:04 <darthdeu> yeah
16:31:04 <akurilin> derp
16:31:36 <c_wraith> corgifex: well, you can write your own with ViewPatterns if any functions that operate on the type are defined
16:31:55 <corgifex> and if they allow you to match on the contents
16:32:16 <c_wraith> I think you're misunderstanding me.
16:32:27 <srhb> skarn: Well, without importing ZonedTime you wouldn't be able to specify that that's the type you want. :)
16:32:36 <srhb> akurilin: ^^
16:32:45 <srhb> Mistell
16:33:00 <c_wraith> corgifex: http://lpaste.net/102549
16:33:26 <srhb> akurilin: If Persistent reexported it, you wouldn't have to (but that would be sort of silly)
16:33:26 <c_wraith> corgifex: Data.Set doesn't export its constructors, but I can still write patterns that will match it.
16:33:41 <corgifex> yes, minView is a function that gives you access to the contents
16:33:46 <Rastus_Vernon> Uh… I believe there was a new GHC release some days ago.
16:33:59 <corgifex> you'd have a harder time with id
16:34:00 <Rastus_Vernon> Yet, the latest version of the Haskell Platform seems to be from 2013…
16:34:05 <c_wraith> corgifex: there's nothing about minView that's special that way, though.  It's just a function that operates on values of the type.
16:34:28 <Rastus_Vernon> Does this mean that GHC 7.8.1 cannot be used with the Haskell platform and needs to be installed separately?
16:34:34 <srhb> Rastus_Vernon: New one is forthcoming
16:34:43 <srhb> Rastus_Vernon: If you want to just use the new GHC, forget about the platform
16:34:47 <srhb> Rastus_Vernon: (for now)
16:35:02 <c_wraith> corgifex: a value that you cannot operate on in any way isn't too useful.
16:35:12 <c_wraith> corgifex: and so few libraries will expose that.
16:35:51 <corgifex> consider IO ()
16:37:15 <c_wraith> it has helpful functions like >>= that operate on it
16:37:37 <corgifex> sure, but I don't think that helps you with pattern matching
16:37:44 <c_wraith> I can do it. :)
16:38:00 <Rastus_Vernon> srhb: Ah, I will wait, then.
16:38:23 <srhb> Rastus_Vernon: I think some people are optimistic about a release before summer.
16:38:29 * srhb is not holding her breath :P
16:38:38 <c_wraith> pattern ToPrint <- ((print =<<))
16:38:49 <corgifex> data WTF a = Bin {-# UNPACK #-} !Int !a !(Set a) !(Set a) | Tip;  inspect :: Set a -> WTF a; inspect = unsafeCoerce
16:39:07 <c_wraith> foo :: Show a => IO a -> IO () ; foo (ToPrint x) = x
16:39:15 <c_wraith> works fine!
16:39:23 <corgifex> it does?
16:39:32 <c_wraith> my example does
16:40:12 <corgifex> how is this valid syntax?
16:40:24 <c_wraith> PatternSynonyms and ViewPatterns
16:40:32 <corgifex> I thought the stuff after <- had to be a pattern
16:40:39 <c_wraith> it's a view pattern
16:40:49 <corgifex> oh, is there a new syntax for view patterns?
16:40:53 <c_wraith> Oh, I missed something
16:41:06 <c_wraith> it's <- ((print =<<) -> x)
16:41:08 <c_wraith> there
16:41:16 <corgifex> ahh
16:41:33 <corgifex> probably also pattern ToPrint x
16:41:51 <c_wraith> yeah, whoops
16:42:33 <corgifex> letter vs. spirit
16:42:39 <c_wraith> It's dumb.  Never actually use that.  But it can be done. :)
16:42:52 <c_wraith> I just actually tested it, and it works with those corrections
16:43:02 <corgifex> at that point you're so far away from actually inspecting the value, you might as well do case getChar of x -> ...
16:43:07 <corgifex> H98!
16:43:32 <c_wraith> Still.  I'm doing something that syntactically *looks* like pattern-matching on a value of type IO a :)
16:43:42 <corgifex> (so am I)
16:43:47 <c_wraith> Even though it's nothing like it in spirit
16:45:18 <thoughtpolice> PatternSynonyms are pretty great
16:45:21 <thoughtpolice> i'm happy they went in
16:45:26 <c_wraith> It's going to be way too easy to abuse this, though.
16:45:42 <shachaf> whoa, all these new extensions i don't know anything about
16:45:42 <corgifex> c_wraith: that was my thought when I read about them :-)
16:45:44 <c_wraith> No one should ever do what I did up there. :)
16:45:47 <shachaf> i'll just stick with haskell 1.4
16:46:27 <corgifex> is the pattern synonyms extension detectable?
16:46:42 <c_wraith> in what sense?
16:46:52 <corgifex> that is, can you write code that is valid both with and without and does different things?
16:46:58 <c_wraith> No
16:47:12 <c_wraith> Pattern synonyms go in the namespace as constructors.
16:47:19 <thoughtpolice> c_wraith: it'll probably take some time for users to find the right design points (bordering abuse vs useful), yeah. but i think it fixes a reasonable abstraction hole in the term language.
16:47:21 <c_wraith> Something will fail to compile
16:47:41 <c_wraith> Either there will be duplicate definitions of a constructor, or a constructor that's used won't be defined
16:47:48 <corgifex> hmm, we need shadowable constructors or something
16:48:17 <cdk> > delete 'c' "abcdc"
16:48:18 <lambdabot>  "abdc"
16:48:37 <corgifex> filter . (/=)
16:48:39 <c_wraith> > filter (/= 'c') "abcdc"
16:48:40 <lambdabot>  "abd"
16:49:01 <srhb> I'm curious about the GHC release process - there was a bug that apparently broke much of Yesod and a fix was merged -- why is it not out yet? Just a question of building and testing time?
16:49:24 <thoughtpolice> srhb: because i'm having some people test it first. i have not pushed the tags in case something else comes up, is all
16:49:38 <srhb> thoughtpolice: Great, I thought it was something like that. :)
16:49:47 <srhb> (I totally asked the question because I saw you here :P)
16:51:40 <corgifex> c_wraith: what happens if you compile the file 'pattern True = False; main = return ()' ?
16:53:29 <thoughtpolice> corgifex: it compiles, but if you wanted to use 'True' then you'd have to disambiguate Prelude.True (constructor) vs Main.True (pattern)
16:55:29 <corgifex> does the extension turn 'pattern' into a reserved word everywhere?
16:56:08 <thoughtpolice> yes
16:56:23 <corgifex> damn
16:56:37 <srhb> Well, everywhere being the module wherein you enable it.
16:56:43 <srhb> If you go the usual route
16:56:51 <thoughtpolice> right, depending on what you mean by 'everywhere' that's worth pointing out
16:56:56 <srhb> It's not infectious.
16:57:29 <corgifex> sure, but it means I can't have a local variable called 'pattern'
16:57:36 <srhb> The horror. :-)
16:57:50 <thoughtpolice> so to be clear: it's only reserved iff -XPatternSynonyms is enabled. related: if you want to *use* a pattern synonym in another module, you have to enable it as well, currently.
16:59:50 <srhb> I think I'm a bit of a language extension addict.
17:00:00 * srhb eyes giant bunch of LANGUAGE pragmas
17:00:22 <bitemyapp> srhb: YOU HUNGERRRRRR
17:00:25 <thoughtpolice> just use -fglasgow-exts :)
17:00:27 <srhb> :-)
17:00:34 <srhb> thoughtpolice: That still exists?
17:00:44 <thoughtpolice> it does. it shouldn't, though.
17:00:48 <dwcook> I'm about to install GHC from binaries. Is there any reason I should use a prefix with the configure script?
17:00:50 <srhb> No, indeed. :P
17:01:01 <srhb> dwcook: Not really. Just make sure you have a cabal ready
17:01:03 <thoughtpolice> dwcook: it makes it easy to get rid of it later
17:01:14 <thoughtpolice> or install multiple copies and switch
17:01:18 <srhb> True.
17:01:22 <dwcook> I don't have cabal already installed; I was going to install that from binaries next. Should that be first?
17:01:23 <thoughtpolice> otherwise it'll just clobber itself in /usr/local
17:01:33 <srhb> dwcook: It's easier if you already have cabal-install
17:01:38 <corgifex> https://raw.githubusercontent.com/mauke/poly.poly/master/poly.poly
17:01:46 <srhb> dwcook: Just install one for your user, then nuke the old Haskell stuff, then get the new one
17:01:48 <dwcook> srhb, why is that?
17:01:48 <thoughtpolice> dwcook: you can just bootstrap cabal pretty easily once you have GHC
17:01:50 <srhb> new ghc*
17:02:03 <srhb> Right, cabal install cabal-install is just.. slightly easier.
17:02:12 <srhb> If it's not too late.
17:02:29 <thoughtpolice> dwcook: if you download the cabal-install source code from hackage, it comes with a 'bootstrap.sh' script that will install the binary into your ~/bin
17:02:41 <dwcook> Previously I was using distro packages for ghc and cabal-install. Should I just stick with the package for cabal-install and then `cabal install cabal-install`? I had done that before but I don't know if it makes a difference.
17:02:52 <srhb> dwcook: That's what I'd do
17:02:59 <thoughtpolice> dwcook: it will probably install into your ~/bin, which is fine
17:03:11 <thoughtpolice> then you can set your ~/bin on the front of your $PATH and you'll use the local copy
17:03:17 <dwcook> thoughtpolice, does GHC make it easier to boostrap cabal? How so?
17:03:26 <srhb> Well you need ghc to actually build it.
17:03:36 <thoughtpolice> dwcook: they're unrelated. you just need a version of GHC to build it
17:03:46 <thoughtpolice> doesn't matter which version, cabal-install will work properly still
17:03:59 <srhb> A very nice feature, I might add.
17:04:08 <srhb> Wonder how much trouble compatibility is for cabal-install.
17:04:12 <thoughtpolice> the alternative would be awful :)
17:04:15 <srhb> Definitely
17:04:28 <srhb> I was just wondering how much work that compatibility is.
17:04:42 <thoughtpolice> in practice i don't think it's much of an issue, although there's probably some code we could get rid of at this point
17:04:47 * srhb nods
17:04:57 <dwcook> Regarding a prefix, if I wanted multiple versions installed for some reason, would a prefix like ~/bin/ghcX.Y be reasonable?
17:05:02 * thoughtpolice still thinks there's some GHC 6.4 code in there
17:05:05 <thoughtpolice> that was before my time
17:05:15 <thoughtpolice> dwcook: yes, that's what i do.
17:05:23 <bitemyapp> antediluvian GHC
17:05:25 <srhb> Won't it create symlinks on its own?
17:05:29 <srhb> To the specific versions installed
17:05:52 <thoughtpolice> dwcook: so i have ~/ghc-7.6 and ~/ghc-7.8. if i want to use one temporarily, just say 'export $PATH=$HOME/ghc-7.8/bin:$PATH' - that will make it so your shell temporarily uses ghc 7.8 for example
17:05:58 <dwcook> Oof, just got hit by a lag spike and got those messages all at once.
17:06:39 <thoughtpolice> srhb: i don't know what you mean. if you --prefix=$HOME/ghc-X.Y for example, ghc will install binaries and symlinks under $HOME/ghc-X.Y/{bin,lib,share}
17:06:46 <srhb> Oh, yes, right
17:06:51 <thoughtpolice> inside bin there will be a 'ghc' symlink, sure, but until it's on your $PATH it's fine
17:07:40 <dwcook> Sorry, I think I lost some context – So is installing the distro package for cabal-install and then upgrading it with itself a good idea, or would it be better to grab the binaries for that too?
17:08:29 <srhb> dwcook: No need to grab the binaries. Either will work fine
17:08:49 <srhb> (well, they're not binaries, your distro version is though)
17:08:53 <dwcook> Okay, thanks. I've decided what to do then.
17:08:53 <srhb> Probably.
17:09:30 <dwcook> Oh good, the distro package for cabal-install doesn't depend on ghc.
17:10:19 <srhb> Just zlib and gmp I think.
17:10:21 <hakujin> thoughtpolice: the 7.8.1 note about OSX Mavericks -threaded perf is due to clang correct? so by extension FreeBSD 10 will behave the same?
17:12:05 <thoughtpolice> hakujin: maybe, it's specific to the internals of how Mavericks' __thread is implemented
17:12:22 <thoughtpolice> on Linux it's not a problem, for example - TLS support on linux is always 'fast' and moves directly into a segment register (%fs)
17:12:29 <thoughtpolice> if FreeBSD is the same way, it shouldn't be an issue
17:12:51 <thoughtpolice> hakujin: in any case, Gabor made the binaries for FreeBSD, and based on the README, I speculate they were GCC built, in which case it's not a problem
17:13:13 <thoughtpolice> i base this on the fact he recommends GCC from Ports until Clang receives more testing on FreeBSD - see http://www.haskell.org/ghc/dist/7.8.1/README.fbsd.html
17:13:42 <srhb> Jeez, xz is slow. To imagine we live in a day where I choose lower compression ratios just because it ends up being faster to download the extra data.
17:13:46 * srhb feels old
17:14:15 <thoughtpolice> -9e is worth it for GHC. :) you should try tweaking the settings
17:16:13 <hakujin> thoughtpolice: thanks
17:16:19 <srhb> How do I make a cabal sandbox use a locally modified dependency rather than get it from hackage?
17:16:21 <srhb> I'm ge
17:16:26 <srhb> I'm guessing it's some register magic.
17:16:36 <hpc> srhb: oh, i know how
17:16:44 <hpc> hang on, i have a project using it
17:16:49 <srhb> hpc: Thanks! :D
17:17:01 <thoughtpolice> srhb: cabal sandbox add-source /path/to/package/source
17:17:09 <hpc> yeah, that
17:17:23 <hpc> i am using cabal-dev, but the syntax is the same for just about everything
17:18:06 <srhb> Awesome, thank you both. :)
17:18:38 <srhb> The olden days without sandboxes are becoming a distant nightmare finally.
17:22:03 <haasn> @tell mm_freak I would have sent you a darcs patch by now but it seems like darcs is completely and utterly broken on my system
17:22:03 <lambdabot> Consider it noted.
17:22:29 <srhb> Hmm, what happens if I cabal install -j --ghc-options=-j ?
17:22:36 <srhb> n * n ghc processes?
17:23:44 <thoughtpolice> GHC does not use multiple processes for -j support
17:24:03 <srhb> Ah.
17:24:19 <thoughtpolice> i guess in theory you could get N copies of GCC or something potentially running, as the upsweep/compilation will happen in parallel
17:24:26 <srhb> Right.
17:24:31 <thoughtpolice> and compile modules in paralle. but anyway
17:24:36 <thoughtpolice> +l
17:24:42 <srhb> Things are faaast now :3
17:25:08 <haasn> @tell mm_freak The only changes I've made since the earlier diff was making the tuple match lazy, ie. \(~(x,y)) -> ... and bumping the version to 0.1.2 so 7.8.x users can add a lower bound on it
17:25:08 <lambdabot> Consider it noted.
17:25:15 <thoughtpolice> -j didn't have as good of improvements as we'd like (i think it only tops out close to 2x scalability) but it has almost no overhead when unused, so it was pretty worth it.
17:25:28 <thoughtpolice> and parcs' patches were great
17:25:30 <srhb> I learned using the -j tag with cabal and mistakenly thought it would be sane other places too. That day I learned not to make install -j in /usr/src/linux
17:25:57 <srhb> 80GB of swap later....
17:26:41 <srhb> thoughtpolice: The main improvement seems to be that if my install gets caught in some linear dependencies, I don't get stuck on one core.
17:26:45 <srhb> with ghc -j that is
17:27:01 <augur> someone remind me who http://www.haskellforall.com/2014/04/scalable-program-architectures.html is on irc
17:27:50 <mgsloan> augur: that's tekmo!
17:28:02 <augur> right, ok
17:28:23 <thoughtpolice> srhb: FWIW, cabal 1.19 will use -j implicitly if it's supported I believe and correctly tries to balance the package building parallelism vs the GHC-level parallelism
17:28:37 <srhb> thoughtpolice: Very nice!
17:28:40 <thoughtpolice> which is probably what you really want (this is already upstream IIRC)
17:28:44 <srhb> Yes, definitely
17:28:52 <srhb> Not that both -j options are a problem on my system
17:28:54 <srhb> At least I think not
17:30:49 <thoughtpolice> in practice it's probably not a huge deal as much as it is a precaution, and convenient - i imagine there are some cases where the combination could result in an unsustainable amount of modules being compiled concurrently, but it's unclear really if 'traditional' or typical dependency graphs for modules/packages expose that much parallelism
17:31:10 <thoughtpolice> (which is related to the limits of -j anyway, a lot of packages just don't show that much intra-package parallelism at the module level)
17:31:51 <srhb> *nods*
17:31:56 <thoughtpolice> clearly we need parallel type inferencing or something now
17:32:02 <srhb> That would be nice ;)
17:32:09 <srhb> Though tbh builds are really, really fast these days
17:32:24 <srhb> cabal -j probably made the biggest difference for most of my stuff
17:32:58 <thoughtpolice> mmm, i do wonder how much better GHC can do itself
17:33:01 <haasn> yitz: how long until we get a fixed timezone-series?
17:33:09 <srhb> It's nice watching one ghc process take 300% cpu. :-)
17:33:18 <mgsloan> It'd be cool if modules could be partially typechecked, out of order with their dependencies
17:33:39 <srhb> Can't we just defer type errors? :P
17:33:44 <mgsloan> In other words, typechecking would proceed as far as it could even though some scope info isn't there yet :)
17:33:47 <srhb> build ALL THE THINGS
17:34:14 <thoughtpolice> srhb: that doesn't defer type *checking* - just type *errors* ;)
17:34:22 <srhb> Right, right.. :P
17:34:39 <mgsloan> Howsabout deferred parse errors? :)
17:34:52 <srhb> Yeah, just defer ghc
17:35:08 <srhb> runhaskell for a project that depends on lens will be fun
17:35:20 <corgifex> ooh, a Just Too Late compiler
17:35:25 <srhb> Haha
17:35:26 <corgifex> someone's done that for intercal
17:46:23 <petrie> Is it bad practice to recursively call main?
17:46:37 <srhb> meh, I don't see the problem
17:47:05 <catalyst> so long as it's tail recursion
17:47:13 <catalyst> I imagine it's fine
17:47:22 <geekosaur> not necessarily bad practice but can limit flexibility since you lose the ability to use main for things like parameter parsing
17:47:23 <hpc> it's weird though
17:47:24 <srhb> tail recursion isn't that big a deal
17:47:36 <geekosaur> catalyst, tail recursion isn't really an issue in a non-strict language
17:47:47 <catalyst> that's interesting :o
17:47:47 <petrie> Hmm ok, thanks :)
17:48:04 <Cale> Especially as there isn't exactly a call stack as such :)
17:48:36 <petrie> Well, probably bad design on my part then. I am basically making an interactive prompt. So It will run until user quits.
17:48:38 <catalyst> if it doesn't have a stack, how does it reconstruct the state when it returns?
17:48:45 <petrie> So I suppose I shouldn't be doing that in main.
17:48:47 <geekosaur> function calls immediately return a closure. the problem is making sure reduction of those closures happens
17:48:55 <srhb> Does anyone have time to help me do some debugging? I'm trying to bring acid-state to compile on 7.8.1 but I'm a little out of my depth
17:49:22 <srhb> I'd like to submit a pull request if I manage. :-)
17:49:39 <kadoban> Is there a way to handle module import failure in any way in GHC, like if one can't be found, default some values or something?
17:49:40 <catalyst> learning anything at all about how Haskell does things seems to be having the same effect as when I first learned Scheme, which is nice
17:49:51 <srhb> catalyst: Yeah, it's great! Brain gymnastics.
17:50:06 <geekosaur> evaluation in a non-strict language proceeds *very* differently from what you will be used to in most other languages; in Haskell your concern is the pattern match stack which controls when expressions get reduced.
17:50:10 <catalyst> geekosaur: so what's the degenerate case then? there must be some way to break it that's equivalent to a stack overflow?
17:50:28 <geekosaur> there is; build up too lazy an expression and you overflow the pattern match stack
17:50:32 <corgifex> you can get a stack overflow with nested thunks
17:50:34 <catalyst> ah, right
17:50:58 <corgifex> tail recursion is an efficient method to build nested thunks
17:51:05 <corgifex> (hi, foldl)
17:51:24 <catalyst> presumably because the pattern match stack remains very small since it's not needing to hold onto thunks for very long?
17:51:43 <srhb> Are there any general tricks for handling "Could not deduce" type errors?
17:51:53 <geekosaur> there are no function calls as such in that; individual expressions are involved, not functions. (normal numbers are generally strict and don't pile up, but lots of other things do, especially if lists are involved)
17:53:05 <corgifex> srhb: if there are, I don't have them reified. I generally look at the whole error message and think real hard
17:53:11 <geekosaur> basically, if you code naïvely, you build up huge thunks that get forced when you do output (or overflow the pattern match stack with unevaluated lazy expressions).
17:53:22 <srhb> corgifex: Yeah, I was afraid of that. :-)
17:53:27 <Algebr> I think I hit a moment of clarity and just want to run it by here, just to see if I'm on the right track. So a functor is a container like object that can be matter over, where the container is the type contructor, like Maybe.  For example, if we had data FinancialProduct a = Stock a | Bond a. A functor would take you from say a Stock to a Bond, or vice versa, but it would have to be limited to whatever FinancialProduct is defined
17:53:34 <Algebr> over.
17:53:44 <geekosaur> not all functors are containers
17:53:48 <geekosaur> IO is a functor
17:53:54 <geekosaur> IO is most definitely *not* a container
17:53:57 <c_wraith> (a ->) is a functor.
17:54:01 <catalyst> geekosaur: is the application order guaranteed to be deterministic?
17:54:19 <geekosaur> it is deterministic but the determinants may not be what you expect
17:54:33 <geekosaur> if you are working from analogy to languages like C, Python, Perl, Java, etc.
17:54:41 <corgifex> Algebr: it could not take you from Stock to Bond
17:54:43 <Algebr> oops, mistyped matter for mapped, but i think everyone still understood what i said.
17:55:02 <corgifex> Algebr: the point of fmap is that it doesn't change the structure, only the contained values
17:55:51 <srhb> fsvo "contained" that may definitely not be very much like containing
17:56:30 <srhb> > (+2) `fmap` (+4) $ 2
17:56:31 <Algebr> Why is IO a functor ?
17:56:32 <lambdabot>  8
17:56:42 <corgifex> Algebr: because it supports fmap
17:57:02 <corgifex> because it obeys the functor laws
17:57:07 <Algebr> So it goes....for a thing to be a functor, it must implment fmap?
17:57:08 <corgifex> because it's a monad and all monads are functors
17:57:25 <geekosaur> ^ pretty much :) but any monad is conceptually a functor, since the original formulation (if not the one Haskell conventionally uses) relies on it
17:57:42 <corgifex> Algebr: yes, and fmap needs to follow a few rules
17:57:46 <corgifex> like fmap id = id
17:58:02 <geekosaur> (haskell uses bind, (>>=), but the traditional formulation is in terms of what haskell calls fmap and join)
17:58:30 <geekosaur> (this is most evident for the list monad, where fmap is map and join is concat)
17:58:49 <corgifex> exercise: define join in terms of return/>>=; define >>= in terms of return/fmap/join
18:02:17 <srhb> http://lpaste.net/102551 -- am I understanding this error correct, that it can't see that EventState ev has a MonadState instance?
18:07:30 <corgifex> wait, are you working on acid-state?
18:08:09 <srhb> corgifex: Eh, I'm trying to learn something by maybe figuring this out and making it compile on 7.8.1
18:08:13 <srhb> corgifex: That's about the extent of it
18:09:35 <monochrom> no, rather, the combination EventState ev and StateT st1 m does not have a MonadState instance. recall that MonadState is a 2-parameter type class, it is not one single thing, but the combination of two things, that makes or breaks.
18:09:57 <monochrom> moreover, MonadState has a functional dependency.
18:10:02 <srhb> Ah, ok. Hmm.
18:10:30 <monochrom> therefore, whenever StateT is involved, then only the combination st1 and StateT st1 m is allowed.
18:10:57 <srhb> I didn't quite get the last bit. Time to read up on functional dependencies I guess. :)
18:11:05 <monochrom> for example, the combination of Int and StateT st1 m is not allowed. must change Int to st1
18:11:23 <srhb> monochrom: Where exactly do you read that from the error?
18:11:42 <monochrom> no, not from the error. from the definition of MonadState
18:12:08 <srhb> Oh.
18:12:18 <monochrom> err, no, the instance declaration of "instance MonadState s (StateT s m)"
18:13:35 <srhb> OK. I'm out of my depth. :-)
18:13:47 <monochrom> it is "s" in the first position, and the same "s" again under StateT. they must not differ.
18:13:51 <srhb> Right
18:14:15 <srhb> So... EventState ev and st1 differ, therefore error?
18:14:17 <corgifex> doesn't it say it has "st1 ~ MethodState ev" in the context?
18:14:21 <monochrom> yes
18:14:36 <srhb> It apparently has troubles seeing that MethodState ev and EventState ev are the same things
18:14:38 <srhb> Which I think they are
18:14:57 <srhb> Yes indeed.
18:15:17 <monochrom> well, I have trouble seeing that, too. what says they're the same?
18:15:27 <srhb> type eventState ev = MethodState ev
18:15:33 <srhb> in the source
18:16:10 <monochrom> alright, then I don't know what is happening
18:16:22 <srhb> That does mean they should be the same, right? I'm not nuts?
18:17:09 <thoughtpolice> srhb: what is MethodState?
18:17:13 <thoughtpolice> is it a type family?
18:17:17 <corgifex> argh, who put these asstypes in my GADTs
18:17:20 <corgifex> yes
18:17:27 <thoughtpolice> https://ghc.haskell.org/trac/ghc/ticket/8978
18:17:32 <thoughtpolice> this is why 7.8.2 is being released
18:17:35 <srhb> oh.. derp
18:17:40 <srhb> Can you explain the workaround?
18:17:46 <monochrom> w00t when will we get 7.8.2? :)
18:17:51 <thoughtpolice> given the example in the ticket:
18:17:56 <thoughtpolice> type Syn a = Associated a
18:17:57 <thoughtpolice> becomes
18:18:03 <thoughtpolice> type family Syn a = Associated a
18:18:05 <thoughtpolice> that's all
18:18:08 <srhb> haha
18:18:40 <thoughtpolice> i.e. all synonyms become a 1 equation type family, if the synonym mentioned a type family on the RHS
18:18:48 <thoughtpolice> but really people should probably just ignore 7.8.1 because of this bug
18:19:14 <srhb> thoughtpolice: But in this case I hav eclas ... where type MethodState ev
18:19:29 <monochrom> this doesn't bode well to those who waited hours downloading 7.8.1 :)
18:19:38 <thoughtpolice> srhb: right, that means MethodState is a type family
18:19:54 <corgifex> I'm having trouble keeping 6.8.1 and 7.8.1 apart in my head
18:20:13 <thoughtpolice> because it's a 'type' declaration attached to a class, which makes it so. 'type family' is just syntax for top-level declarations which is the more common case
18:20:20 <monochrom> solution: erase 6.8.1 from your head :)
18:20:25 <thoughtpolice> and as you said above, type EventState ev = MethodState ev
18:20:34 <thoughtpolice> so it mentions the family on the RHS. i speculate it's the exact same bug
18:20:45 <corgifex> monochrom: no mutation!
18:20:47 <guesting> How does Haskell handle database like variables? I am trying to make a gui for a database in threepenny, but when I write to the file after each add or remove, it "lags" behind, adding several removed elements at once, etc. I'm assuming this is due to laziness in the UI monad? Is there a way to avoid that?
18:20:48 <srhb> thoughtpolice: Hmm. Then I just can't figure out how to work around it at least
18:21:27 <thoughtpolice> srhb: if it's in a library, it's out of your control. if it's your own code, then turning EventState into a type family as well will work
18:21:33 <dmj`> conduit 1.1.0 got rid of Data.Conduit.Util, anyone know where it was put?
18:21:38 <thoughtpolice> but again you should probably just wait for 7.8.2 anyway as it looks like the exact same bug
18:21:45 <srhb> thoughtpolice: type family EventState ev = MethodState ev --right?
18:21:47 <thoughtpolice> yes
18:21:48 <monochrom> try "type family EventState ev = MethodState ev"
18:21:59 <srhb> parse error on input `=`.. what
18:22:17 <corgifex> may need a LANGUAGE
18:22:22 <monochrom> yeah
18:22:36 <srhb> I have {-# LANGUAGE TypeFamilies #-}
18:22:37 <corgifex> (I speak parsertongue)
18:22:56 <srhb> New bug? :P
18:22:58 <monochrom> then I don't know
18:23:30 <thoughtpolice> oh
18:23:36 <thoughtpolice> type instance EventState ev = MethodState ev
18:23:44 <thoughtpolice> the family is only for the decl, not the instances
18:23:48 <srhb> aaah
18:23:56 <thoughtpolice> er, well, you'll really need
18:24:08 <thoughtpolice> type family EventState ev :: *; type instance EventState ev = MethodState ev
18:24:10 <thoughtpolice> that should do it
18:24:17 <dmj`> why does conduit change everyday and when it does change it breaks everything
18:24:20 <haasn> srhb: that is a syntax error
18:24:25 <haasn> oh, already mentioned
18:24:41 <haasn> type family EventState ev where type instance EventState ev = MethodState ev -- closed TFs ftw
18:25:14 <Sgeo> Is it reasonable to use reactive-banana solely for its Control.Event.Handler.AddHandler type?
18:25:16 <srhb> Funstuffs. :)
18:25:20 <monochrom> I guess you may as well do that anyway since it's 7.8
18:25:35 <thoughtpolice> haasn: sure, if you don't want pre-7.8 support
18:25:40 <thoughtpolice> the open family works fine for this bug though
18:25:47 <haasn> this is 7.8.1-specific work-around either way, right?
18:25:50 <thoughtpolice> yes
18:26:22 <srhb> Yeah, just getting wiser (hopefully)
18:26:25 <thoughtpolice> and anyway it's bad and terrible and you should just wait another day or whatever, really, because otherwise you'll just end up undoing the work you did :P
18:26:36 <srhb> That's fine. Just toying around.
18:26:37 <srhb> :)
18:26:38 <haasn> at the very least it should have an #if ghc version == 7.8.1 around it
18:26:50 <srhb> It's just my own toy modifications
18:27:39 <haasn> By the way, would it be possible for GHC to output better error messages when GNT fails due to a type role?
18:27:40 <corgifex> heh, and the patch fixing it introduces a typo :-)
18:28:06 <haasn> Something like a simple note saying what the type role of the class/ctor is and why they mismatch
18:28:30 <haasn> or, rather, why they disallow coercion
18:30:23 <thoughtpolice> haasn: you should open a ticket and maybe we can find out if it's possible
18:30:41 <corgifex> https://ghc.haskell.org/trac/ghc/browser/ghc/compiler/typecheck/TcCanonical.lhs?rev=b8132a9d2fdb93c5d30107b1d531dd73ac27b262#L557 =~ s/functoin/function/
18:31:46 <hpc> functoin is the functional alternative to pen-and-paper based cryptocurrency such as BICtoin
18:32:12 <c_wraith> Hmm.  Are there cases in which AutoDeriveTypeable doesn't work?
18:32:38 <c_wraith> Of 3 modules in this project, AutoDeriveTypeable works with 1 of them
18:42:14 <HalfMadDad> Hi Everyone. Haskell is too hard for me! I just wanted to stop by to mention that tiobe has Haskell in the garbage range, below the top 50, but that there are 1192 people in this chat room. Makes me think there is something quite wrong with tiobe. link http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
18:42:22 <srhb> HalfMadDad++
18:42:26 <srhb> We should all go home now.
18:43:29 <HalfMadDad> srhb, :)  <sarcasm>yep if tiobe thinks haskell is no good must be time to quite</sarcasm>
18:43:42 <srhb> :-)
18:44:05 <petrie> I'm not very bright and I am catching on so there must be something wrong. >:)
18:44:24 <srhb> But hey, it's just a popularity index, right?
18:44:52 <HalfMadDad> petrie, I am sure you have good teacher here, the number of people in this channel is incredible
18:45:36 <petrie> HalfMadDad: True, people here are very generous with helping us newbies :)
18:45:58 <srhb> HalfMadDad: Jests aside, what's too hard about Haskell for you, or was that just a joke too? :)
18:46:04 <HalfMadDad> srhb,  yes but freenode numbers could be used for popularity too!
18:46:06 <srhb> And yes, I too appreciate the help in here a lot
18:46:09 <srhb> HalfMadDad: Very true
18:46:35 <HalfMadDad> srhb, partly a joke but there is quite a bit to learn with haskell
18:46:48 <srhb> True :)
18:47:01 <zerokarmaleft> quite a bit to unlearn as well, for that matter
18:47:04 <srhb> Very satisfying.
18:47:09 <srhb> That, too.
18:47:12 <corgifex> the same could be said of PHP
18:47:39 <dwcook> HalfMadDad, ew, that site has alert debugging, and in the production version :(
18:47:40 <HalfMadDad> corgifex, or perhaps we coudl say there is a lot to unlearn after PHP
18:48:49 <HalfMadDad> dwcook they didn't say they were good programmers... :) also not very encouraging to have them ranking programming languages
18:49:18 <corgifex> it's just google results for "X programming"
18:49:21 <HalfMadDad> I have been following it for years and really believed everything for the longest time
18:50:13 <HalfMadDad> corgifex, yep, and you have to wonder how accurate some names are like C or D
18:50:41 <HalfMadDad> sesemee street might be pushing up there popularity
18:51:14 <HalfMadDad> gotta go guys, just thought I would share that... take care
18:55:57 <petrie> So i am trying to create an interactive prompt, but it doesn't show the putStr before the getLine does this having something to do with how the wonderful world of IO works?
18:56:14 <Ireneista> actually, no
18:56:17 <c_wraith> petrie: no, that's how the wonderful world of buffered IO works
18:56:18 <Ireneista> it’s standard Unix semantics
18:56:18 <monochrom> no, it's just buffering. use hFlush.
18:56:34 <petrie> Oh hmm
18:56:55 <monochrom> the buffering is standard Unix semantics
18:57:26 <petrie> does that usually happen behind the scenes?
18:57:28 <monochrom> "if the Handle is attached to a terminal then line-buffer else block-buffer"
18:57:36 <monochrom> it always happens
18:57:58 <c_wraith> lots of languages cheat, and if attached to a terminal, their functions that read stdin flush stdout first.
18:58:05 <monochrom> line-buffer means buffer up until newline or buffer full
18:58:06 <petrie> well for example in c if I did printf() than a scanf() or what not it would print the printf first
18:58:16 <corgifex> petrie: no, it wouldn't
18:58:17 <petrie> ah ok that is what I was wondering c_wraith
18:58:24 <corgifex> also, don't use scanf for user input
18:58:50 <petrie> hm
18:58:54 <geekosaur> actually it does, because if you don't reopen either stdin or stdout then they're linked and stdout gets autoflushed when a stdio function is used to read from stdin
18:59:11 <geekosaur> this is an ugly hack that is common in C stdio
18:59:14 <corgifex> oh, interesting
18:59:28 <geekosaur> hence c_wraith's earlier comment abotu cheating
18:59:59 <corgifex> that was about languages though, not implementations
19:00:09 <corgifex> I'm pretty sure C++ cheats at the language level
19:00:37 <corgifex> related: http://c-faq.com/stdio/fflush.html
19:00:55 <petrie> ah
19:01:04 <sm> petrie: in short, print a newline or use hFlush stdout to force output. Or, consider using the great wizards library
19:01:16 <petrie> Thanks whoever said hFlush, it worked perfect
19:01:37 <c_wraith> you could also use hSetBuffering NoBuffering, but that's overkill
19:02:01 <corgifex> c_wraith: it also looks horrible in strace
19:02:18 <c_wraith> oh yeah, putStr issues a syscall for every character, doesn't it?
19:02:27 <corgifex> if you disable buffering, yes
19:02:38 <zerokarmaleft> interesting
19:02:53 <zerokarmaleft> didn't know that about hSetBuffering
19:03:01 <c_wraith> let this be a lesson: don't use putStr for performance-oriented code. :)
19:03:15 <corgifex> or don't disable buffering
19:03:20 <tb01110100> !gn
19:03:24 <petrie> I used putStr so I could have a prompt on the same line for a getLine, unless there is a better way?
19:03:31 <c_wraith> petrie: it's fine for your case
19:03:41 <c_wraith> petrie: I was talking about something else entirely.
19:03:47 <petrie> Oh ok
19:03:54 <monochrom> real users use a USB port
19:04:26 <dwcook> @type hSetBufferingMode
19:04:27 <lambdabot> Not in scope: hSetBufferingMode
19:04:29 <dwcook> @type hSetBuffering
19:04:30 <lambdabot> Not in scope: hSetBuffering
19:04:45 <c_wraith> someone needs to tell \bot that it's not using a unicode-enabled terminal
19:04:59 <dwcook> petrie, http://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO.html#v:hSetBuffering
19:05:24 <dwcook> Oh, someone already mentioned it
19:05:32 <dwcook> Was scanning the scrollback but missed that
19:05:37 <corgifex> dwcook: lookofdisapproval.jpg
19:05:43 <petrie> lol
19:05:48 <dwcook> corgifex, yes?
19:07:29 <srhb> Odd, the perl script to get subpackages for ghc doesn't seem to be doing the s/\//-/ substitution properly here
19:07:49 <srhb> ./sync-all get -- that is
19:13:01 <carter> srhb: patches welcome
19:13:02 <carter> seriously
19:13:08 <carter> people will owe you beers
19:13:31 <corgifex> if it looks anything like the evil mangler ...
19:13:46 <cmccann> corgifex: I think you mean ಠ_ಠ
19:13:52 <cmccann> what's the point of unicode if you don't abuse it
19:14:06 <carter> the only things they have in common  is perl
19:14:11 <carter> cmccann: how do you form the eys?
19:14:17 <corgifex> good
19:14:20 <cmccann> ...copy and paste?
19:14:23 <carter> is that just a bunch of strokes on an o?
19:14:31 <cmccann> no it's a letter
19:14:31 <corgifex> no, it's a kannada letter
19:14:39 <haasn> cmccann: great motto! ☃
19:14:43 <corgifex> so the whole thing is a valid identifier too :-)
19:14:49 <carter> KANNADA LETTER TTHA
19:15:03 <carter> 👊
19:15:09 <carter> fistbump
19:15:37 <corgifex> cat face with wry smile
19:15:49 <srhb> carter: No idea about perl. From what I can glean it _should_ work. :-)
19:15:58 <haasn> When the Haskell Report says “letter”, what does it mean?
19:16:04 <carter> 🐈
19:16:10 <cmccann> haasn: it makes me very happy to know that unicodesnowmanforyou.com exists
19:16:15 <carter> haasn: when is that do?
19:16:20 <carter> due
19:16:25 <haasn> cmccann: I just have it bound to my keyboard, comes in handy often
19:16:30 <cmccann> haasn: what unicode means by "letter", afaik
19:17:14 <haasn> carter: It's as part of the definition of identifiers and operators in section 2.4; it speaks of a “letter followed by zero or more letters”
19:17:28 <haasn> (or digits, underscores and single quotes)
19:17:46 <cmccann> so yes ಠ_ಠ is a valid (and lowercase) variable. I think unicode snowman is a valid operator.
19:18:10 <haasn> uniSmall  →  any Unicode lowercase letter
19:18:11 <cmccann> about the only code points you can't use as Haskell identifiers are quote marks and whitespace characters
19:18:18 <haasn> What is “any Unicode lowercase letter”?
19:18:38 <haasn> cmccann: control characters, lots of them
19:18:43 <srhb> ☭ is the only important operator
19:18:48 <cmccann> yeah, and any non-printing characters
19:18:54 <cmccann> I guess that one seemed obvious :P
19:19:17 <haasn> but I want my operators named RIGHT-TO-LEFT-OVERRIDE :(
19:19:17 <corgifex> haasn: my guess would be anything matched by perl's /[[:lower:]]/
19:20:00 <cmccann> I remain disappointed that despite unicode having a "whitespace representing multiplication written by juxtaposition" code point we can't use it as an operator in Haskell code
19:20:41 <dwcook> cmccann, trying to enter an obfuscated Haskell contest?
19:20:51 <haasn> cmccann: is there a distinction in unicode between - as used for negative literals and - as used for mathematical subtraction?
19:21:01 <cmccann> dwcook: no just for personal entertainment
19:21:16 <corgifex> U+200C is a valid identifier char in ecmascript
19:21:38 <haasn> Hmm.
19:21:38 <cmccann> haasn: probably. I assume literal negation is pre-determined
19:21:53 <cmccann> but there's likely a separate code point for a subtration sign
19:22:01 <corgifex> > ""++ printf "%d" 'A'
19:22:02 <lambdabot>  "65"
19:22:26 <haasn> > let x̤ = toUpper 'ß' in x̤
19:22:27 <lambdabot>  <hint>:1:6: lexical error at character '\804'
19:22:30 <cmccann> remember unicode has like five different alphabets representing different typeface styles used in mathematics
19:22:35 <haasn> I have reason to believe GHC does not conform to the Haskell standard.
19:22:37 <cmccann> like blackboard bold and fraktur and all that
19:22:47 <haasn> x̤ is a valid lowercase letter in Unicode.
19:22:53 <haasn> It should be accepted by GHC, yet it is not
19:22:53 <corgifex> > concatMap (printf "\\u%04x") "var"
19:22:55 <lambdabot>  No instance for (GHC.Show.Show b0)
19:22:55 <lambdabot>    arising from a use of ‘M574869488254017812719814.show_M5748694882540178127...
19:22:55 <lambdabot>  The type variable ‘b0’ is ambiguous
19:22:55 <lambdabot>  Note: there are several potential instances:
19:22:55 <lambdabot>    instance [safe] GHC.Show.Show
19:22:55 <cmccann> it has just about anything even remotely sensible
19:22:59 <corgifex> > concatMap (printf "\\u%04x") "var" ++ ""
19:23:00 <lambdabot>  "\\u0076\\u0061\\u0072"
19:23:39 <corgifex> > var $ concatMap (printf "\\u%04x") "var"
19:23:40 <lambdabot>  \u0076\u0061\u0072
19:23:50 <corgifex> now that's valid ecmascript
19:24:42 <haasn> cmccann: I have this script on my PC but firefox decided to remove the source of it from my history: http://bpaste.net/show/200633/
19:25:06 <cmccann> haasn: that one's not mine
19:25:19 <cmccann> maybe ion? I can't recall.
19:25:50 <haasn> https://gist.github.com/ion1/3909452
19:25:50 <cmccann> I had a much sloppier version which may have helped inspire someone to make a better one
19:25:55 <haasn> github's search API found it
19:26:29 <cmccann> ah, my memory is better than I thought
19:26:38 <haasn> Is this issue worth creating a bug report on the GHC trac for? :)
19:26:49 <haasn> They should use a proper Unicode library like text-icu to split on characters, not code points
19:26:54 <haasn> This would probably make parsing a billion times slwoer
19:26:55 <corgifex> that's missing the fullwidth versions
19:27:29 <corgifex> also. small caps
19:35:27 <Rastus_Vernon> Is this the list of all the classes of which instances can be ordered? https://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#control.i:Ord
19:35:37 <Rastus_Vernon> If so, then there is really a lot of them.
19:36:42 <cmccann> so will GHC 7.8.2 be the fastest release in terms of "days since previous major or minor version"?
19:36:48 <corgifex> no, that's the list of instances of the single class Ord
19:37:08 <Rastus_Vernon> corgifex: I see. What is that class?
19:37:29 <corgifex> er. it's defined right above
19:37:46 <cmccann> Rastus_Vernon: the phrasing of your questions makes me think you're misunderstanding some terminology here
19:38:04 <cmccann> you might want to review what "type classes" in Haskell are
19:38:15 <Rastus_Vernon> Good idea!
19:38:41 <corgifex> a type class is a class of types. it classifies types
19:39:30 <haasn> > text "\u0076\u0061\u0072"
19:39:31 <lambdabot>  <hint>:1:8:
19:39:31 <lambdabot>      lexical error in string/character literal at character 'u'
19:39:41 <haasn> > text "\76\61\72"
19:39:42 <lambdabot>  L=H
19:40:39 <fread2282> how can I get GHC to compile faster? I'm using -O0 -fobject-code -dynamic
19:41:04 <haasn> -jN
19:41:07 <srhb> -fasm?
19:41:11 <srhb> oh
19:41:23 <startling> fread2282: get more memory. :/
19:41:39 <thoughtpolice> if you're using -O0 that's probably as fast as it's gonna get
19:41:57 <thoughtpolice> in general, anyway. i'm not sure what else to do to speed it up OTTOMH, at least
19:42:20 <thoughtpolice> (modulo something like typechecking taking forever or something, of course, which could be the case for some code)
19:42:59 <cmccann> you usually have to try pretty hard to make typechecking take that long though
19:43:06 <thoughtpolice> yeah
19:43:31 <cmccann> though I crashed my computer once due to inferred types that were too large
19:43:41 <cmccann> or nearly crashed, I think I killed GHC before I ran out of memory
19:43:44 <srhb> How serious are the speed differences of GHC itself if built without all the optimizations?
19:44:09 <srhb> Compared to a fully optimized one, I mean
19:44:11 <thoughtpolice> pretty severe
19:44:25 <srhb> OK.
19:44:27 <thoughtpolice> you almost never want to use an unoptimized GHC, it's a terrible trade off in most situations
19:44:52 <srhb> Aye.
19:44:55 <thoughtpolice> (the source tree has various 'build settings' that tweak the optimization/perf tradeoff in various ways to make builds fast, but without making the compiler unusably slow, etc)
19:45:13 <thoughtpolice> releases are always built at full -O level across the board, roughly
19:45:55 <srhb> That's what perl boot does as well, right?
19:46:36 <thoughtpolice> boot does autoreconf and some other stuff. the general build settings are in mk/build.mk
19:46:46 <thoughtpolice> the default is to build fully optimized, which takes a while
19:46:55 <haasn> cmccann: say that once we get lazy IfThenElse :: Bool -> k -> k -> k -- :(
19:47:21 <srhb> OK :)
19:48:38 <cmccann> haasn: you can sorta implement that with remarkably egregious type hackery
19:49:40 <dwcook> I don't get it, what's hard about writing that lazily?
19:49:50 <haasn> cmccann: how?
19:50:26 <cmccann> haasn: um, some trickery with sketchy overlapping instances and delaying instance selection in the usual manner
19:50:53 <cmccann> it works for the same reason you can make instance resolution hang GHC without hitting the recursion depth limit
19:50:56 <haasn> interesting
19:51:06 <cmccann> I forget the specifics though it's not terribly helpful
19:51:14 <haasn> maybe I should look into this and revive type-level-Rationals
19:51:35 <haasn> LCM :: Nat -> Nat -> Nat -- was a killer for me
19:51:51 <haasn> Or, er, GCD
19:51:55 <cmccann> you end up needing a simple sort of interpreter at that point if memory serves me
19:52:11 <cmccann> and since basically nothing is first-class it's just awful
19:52:32 <cmccann> it might be easier these days with even more and fancier extensions, I dunno
19:53:08 <c_wraith> nah, they don't really help with that stuff.
19:53:08 <cmccann> with closed type families it might work without fundeps? that would help readability at least.
19:53:17 <haasn> Might also be less sever with actual Nats rather than data Nat = Z | S Nat
19:53:23 <cmccann> but possibly not given how awful what you had to do before was
19:53:43 <c_wraith> haasn: no, type-level Nat literals are actually still less powerful than that.
19:53:50 <haasn> c_wraith: oh?
19:53:54 <c_wraith> haasn: prettier, but less powerful.
19:54:08 <haasn> c_wraith: I'm not sure if I need the extra power, whatever it is
19:54:20 <ezrios> > (mod 3) $ 6
19:54:21 <lambdabot>  3
19:54:21 <c_wraith> haasn: You probably do.
19:54:24 <ezrios> > 6 `mod` 3
19:54:25 <lambdabot>  0
19:54:27 <ezrios> wat?
19:54:33 <haasn> c_wraith: can you be more specific?
19:54:40 <c_wraith> ezrios: what do you expect to happen when you reverse argument order?
19:54:56 <ezrios> ah shit
19:55:00 <ezrios> it is too late to be doing haskell
19:55:08 <ezrios> I thought I was sectioning mod
19:55:10 <ezrios> ._.
19:55:40 <c_wraith> haasn: data Vec (n :: Nat) a where Nil :: Vec 0 a ; Cons :: a -> Vec n a -> Vec (n + 1) a
19:55:57 <c_wraith> haasn: you can't write an Eq instance for that type without unsafeCoerce, at the moment
19:56:03 <haasn> c_wraith: right, I don't think I need anything like that
19:56:13 <haasn> but good to know regardless
19:56:22 <c_wraith> haasn: you never need to know if two types are the same?
19:56:32 <c_wraith> (after doing arithmetic on them, that is)
19:57:56 <haasn> well, I never need to deconstruct anything into the form var+x. I think
19:58:13 <haasn> GHC can certainly tell you whether some types are the same
19:58:49 <haasn> it satisfies eg. (1+1)~2
19:59:01 * haasn tries it out
20:00:19 <haasn> “No instance for (SingKind 'KProxy) arising from a use of ‘fromSing’”
20:00:27 <haasn> GHC should really print kind annotations in cases like these
20:00:43 <haasn> The old SingKing k 'KProxy was a lot clearer
20:00:53 <haasn> even though it was a horrible format to print anything in
20:02:50 <enthropy> it's not just hiding the k because you don't have -XPolyKinds?
20:06:36 <haasn> I have PolyKinds, though
20:06:38 <haasn> That was the old behavior
20:06:48 <haasn> it changed in 7.8
20:06:50 <haasn> (apparently)
20:08:23 <srhb> Adventures in ghc building continue: Where'd Language.Haskell.TH.classP go? :o
20:08:45 <ezrios> 6'V)w?
20:08:50 <ezrios> damnit
20:10:39 <Rastus_Vernon> What is the reason we should use `null []` instead of `[] == []`?
20:11:00 <srhb> Erm
20:11:04 <tac> Rastus_Vernon: == only works if the thing inside the list is Eq
20:11:07 <startling> Rastus_Vernon, the latter rquires an Eq constraint
20:11:08 <tac> for instance
20:11:08 <startling> yeah
20:11:27 <startling> > [print "hi"] == []
20:11:28 <lambdabot>  No instance for (GHC.Classes.Eq (GHC.Types.IO ()))
20:11:28 <lambdabot>    arising from a use of ‘GHC.Classes.==’
20:11:32 <tac> > ([] :: [Int -> Int]) == []
20:11:33 <lambdabot>  No instance for (GHC.Classes.Eq (GHC.Types.Int -> GHC.Types.Int))
20:11:33 <lambdabot>    arising from a use of ‘GHC.Classes.==’
20:11:35 <startling> > null [print "hi"]
20:11:35 <Rastus_Vernon> But for checking if a list is empty, won’t both always work?
20:11:36 <lambdabot>  False
20:11:37 <tac> > ([] :: [Int]) == []
20:11:38 <lambdabot>  True
20:11:39 <startling> Rastus_Vernon: no.
20:11:57 <startling> Rastus_Vernon, Eq is either defined for a type or not defined for a type.
20:12:03 <lispy> > ([] :: [IO ()]) == []
20:12:04 <lambdabot>  No instance for (GHC.Classes.Eq (GHC.Types.IO ()))
20:12:04 <lambdabot>    arising from a use of ‘GHC.Classes.==’
20:12:04 <dwcook> The type system is not aware of what an empty list is
20:12:19 <startling> Rastus_Vernon, Eq is defined for [Something] if and only if Eq is defined for Something.
20:13:14 <Rastus_Vernon> I see.
20:13:49 <Rastus_Vernon> So if the list is empty but its type doesn’t have the Eq constraint defined for it, it will indicate an error.
20:13:59 <startling> Rastus_Vernon: it will be a type error, yes
20:14:15 <Rastus_Vernon> However, `null list` is the same as `length list == 0`, right?
20:14:28 <haasn> Oh wow, we have CmpSymbol m n :: Ordering now?!
20:14:32 <haasn> That is amazing, absolutely amazing
20:14:37 <Rastus_Vernon> Surely length cannot be a constraint…
20:14:40 <startling> Rastus_Vernon: the latter can have terrible performance
20:14:45 <c_wraith> haasn: now go write type-level sort
20:14:53 <dmj`> I think acid-state breaks w/ 7.8
20:14:55 <Rastus_Vernon> (because it has to do with the list, not with the type… or so I’d think)
20:14:58 <startling> Rastus_Vernon: (it also may diverge)
20:15:00 <dmj`> http://lpaste.net/102554
20:15:02 <startling> Rastus_Vernon: but yes.
20:15:05 <haasn> c_wraith: been there done that. Hand-rolled my own String implementation on the type level
20:15:14 <haasn> It was awful for performance
20:15:17 <haasn> And error messages
20:15:49 <startling> > count (repeat "oops") == 1
20:15:50 <lambdabot>  Not in scope: ‘count’
20:15:50 <lambdabot>  Perhaps you meant one of these:
20:15:50 <lambdabot>    ‘BS.count’ (imported from Data.ByteString),
20:15:50 <lambdabot>    ‘BSL.count’ (imported from Data.ByteString.Lazy),
20:15:50 <lambdabot>    ‘BSLC.count’ (imported from Data.ByteString.Lazy.Char8)
20:15:57 <startling> > length (repeat "oops") == 1
20:16:01 <startling> (too much clojure. :/)
20:16:02 <lambdabot>  mueval: ExitFailure 1
20:16:29 <startling> > length (replicate 250 "oops") == 1
20:16:30 <lambdabot>  False
20:16:42 <startling> Rastus_Vernon: does that make sense?
20:16:59 <Rastus_Vernon> It makes sense that it wouldn’t have good performance.
20:17:09 <startling> ok, good.
20:17:15 <startling> @src null
20:17:15 <lambdabot> null []     = True
20:17:15 <lambdabot> null (_:_)  = False
20:17:23 <startling> ^ that's how it's defined, btw
20:17:35 <Rastus_Vernon> Oh, that’s a way to define it I wouldn’t have thought of.
20:18:24 <Rastus_Vernon> I suppose not the length of any function can be found, though. For example, the length function… I hardly see how it could be defined in Haskell.
20:18:44 <lispy> > length [1..]
20:18:48 <lambdabot>  mueval-core: Time limit exceeded
20:19:03 <lispy> Rastus_Vernon: it won't always terminate, but for finite list length makes sense.
20:19:17 <startling> Rastus_Vernon: it's not so hard.
20:19:19 <lispy> (the type is a bit silly though as Int can overflow)
20:19:23 <startling> Rastus_Vernon, what''s the length of []?
20:19:30 <Rastus_Vernon> startling: 0?
20:19:40 <startling> Rastus_Vernon: yep. What's the length of (a : as)?
20:19:56 <Rastus_Vernon> 1 + length as?
20:20:00 <startling> @src length
20:20:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:20:01 <fread2282> @src length
20:20:02 <lambdabot> Source not found. There are some things that I just don't know.
20:20:06 <startling> Rastus_Vernon: yeah, exactly.
20:20:36 <lispy> > let len [] = 0; len (a : as) = 1 + len as in len [1..10]
20:20:37 <lambdabot>  10
20:20:40 <srhb> lambdabot: There are quite a lot of things you don't know.
20:20:48 <Rastus_Vernon> And that would work in… hm
20:20:48 <startling> @botsnack
20:20:48 <lambdabot> :)
20:21:23 <Rastus_Vernon> Yeah, pattern matching is really powerful, as I can see.
20:21:48 <startling> it's nice.
20:22:21 <Rastus_Vernon> Of course, pretty much anything can be decomposed.
20:22:22 <fread2282> Is there any efficienty difference between (length (a:as) = 1 + length as) and (length (a:as) = length as + 1)?
20:23:03 <Rastus_Vernon> Certainly swapping two parameters of (+) cannot create a efficiency difference, can it?
20:23:10 <lispy> fread2282: if your numeric representation was lazy you might be able to find a difference.
20:23:34 <dwcook> Depends on how (+) is defined
20:23:34 <startling> It's foldl vs foldr
20:23:35 <srhb> Actually shouldn't length use an accumulating parameter for that exact reason?
20:23:56 <startling> Rastus_Vernon: if only. :)
20:23:58 <srhb> Well I guess no more than one + is waiting for an argument
20:24:06 <srhb> So no matter.
20:24:20 <lispy> Let's say that instead of + we use ++
20:24:29 <Rastus_Vernon> > let x = (+) in x 1 2
20:24:30 <lambdabot>  3
20:24:32 <Rastus_Vernon> Yay!
20:24:36 <srhb> Scratch that, GHC does use an accumulating parameter. :)
20:24:54 <srhb> I'm (still) not insane.
20:25:05 <dwcook> s/still/not yet/
20:25:07 <fread2282> let in 3
20:25:11 <Rastus_Vernon> > let x = (+2) in x 1
20:25:12 <lispy> > let ones [] = []; ones (a:as) = [1] ++ ones as in ones [-1,-2..]
20:25:12 <srhb> dwcook: Good point.
20:25:12 <lambdabot>  3
20:25:13 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:25:13 <fread2282> > let in 3
20:25:15 <lambdabot>  3
20:25:15 <dwcook> Err, s/(still) not/not yet/
20:25:27 <lispy> > let ones [] = []; ones (a:as) = ones as ++ [1] in ones [-1,-2..]
20:25:29 <srhb> not yet not!
20:25:32 <lambdabot>  mueval-core: Time limit exceeded
20:26:03 <dwcook> Don't leave 3 out in the cold, let it in
20:26:42 <lispy> fread2282, Rastus_Vernon: did that example help?
20:27:30 <Rastus_Vernon> lispy: It creates a list with an infinity of occurrences of 1?
20:27:41 <dmj`> why would acid-state break on 7.8?
20:27:53 <lispy> Rastus_Vernon: well, in the first case it does, then I swapped the order of arguments to (++) and suddenly it never returns.
20:28:13 <Rastus_Vernon> Oh.
20:28:41 <lispy> Rastus_Vernon: You can think of (++) as being similar to (+), and it's lazy
20:29:00 <lispy> So in the first case there, you can always "make progress" before the recursion
20:29:11 <lispy> in the second case, the recursion happens before a value is produced
20:29:19 <Rastus_Vernon> That's because the second form doesn’t make it possible for Haskell to be lazy and output only the values you want; it forces it to calculate all of them first, which is impossible since there is an infinity?
20:29:34 <lispy> pretty much.
20:29:48 <lispy> Haskell is still lazy, but you're right that it has to chase the end of the list before it can produce anything.
20:29:56 <Rastus_Vernon> If that’s the case, that means it is always better to put literal values as the first parameter rather than parameters.
20:30:37 <lispy> "always" is a bit strong, but in this case yes.
20:30:54 <Rastus_Vernon> Are there cases where it is better to put parameters before literal values?
20:31:25 <lispy> Because a + b == b + a, it doesn't really matter but a ++ b != b ++ a
20:31:27 <Rastus_Vernon> That prevents Haskell from being lazy. Of course, it has no effect in some cases, and I do have to admit putting literals after looks better, but it has no practical advantage.
20:31:40 <lispy> So you still have to, you know, have the correct definition :)
20:32:06 <Rastus_Vernon> For example, we always write (not in Haskell, just in general mathematical notation) `x + 1` and not `1 + x` because the latter doesn’t look as good.
20:32:20 <lispy> Haskell is always lazy, but sometimes specific terms cannot be lazily computed.
20:32:29 <Rastus_Vernon> How can a ++ b != b ++ a be True?
20:32:41 <Rastus_Vernon> I mean, in theory.
20:32:47 <startling> Rastus_Vernon, ++ is list concatenation
20:32:50 <startling> Rastus_Vernon: so, trivially.
20:32:59 <Rastus_Vernon> Of course it is true in practice because if it can never be calculated, it certainly cannot be equal.
20:33:02 <lispy> > let a = [1,2,3]; b = [4,5] in a ++ b == b ++ a
20:33:03 <lambdabot>  False
20:33:10 <srhb> Rastus_Vernon: Are you talking about infinite lists?
20:33:18 <startling> Rastus_Vernon, are you talking about +?
20:33:23 <Rastus_Vernon> No, no.
20:33:30 * srhb is confused
20:33:37 <Rastus_Vernon> I know what ++ is, but I forgot lists have an order for a moment.
20:33:41 <startling> haha
20:33:41 <srhb> ah.
20:33:43 <srhb> :P
20:34:14 <Rastus_Vernon> Of course "apple" ++ " and pears" isn’t the same as " and pears" ++ "apple"
20:35:29 <Rastus_Vernon> > let a = "a" in (a ++ b) == (b ++ a) when b = "b"
20:35:30 <lambdabot>  <hint>:1:44: parse error on input ‘=’
20:35:43 <Rastus_Vernon> Uh
20:35:47 <srhb> No when
20:35:48 <Rastus_Vernon> Of course…
20:36:11 <Rastus_Vernon> > let a = "a" b = "b" in (a ++ b) == (b ++ a)
20:36:12 <lambdabot>  <hint>:1:15: parse error on input ‘=’
20:36:14 <dwcook> > "a" ++ "b" == "b" ++ "a"
20:36:15 <lambdabot>  False
20:36:21 <dwcook> Rastus_Vernon, ;
20:36:31 <dwcook> > let a = "a" ; b = "b" in (a ++ b) == (b ++ a)
20:36:32 <lambdabot>  False
20:36:33 <Rastus_Vernon> It is easier to do on multiple lines. :(
20:36:50 <dwcook> Or, I think most people don't write a space before the semicolon. I'm just weird like that
20:36:58 <dmj`> [1,2] == [2,1]
20:37:04 <dmj`> > [1,2] == [2,1]
20:37:06 <lambdabot>  False
20:38:09 <Rastus_Vernon> let a = "a" ; b = "b" in (a ++ b) == (reverse (b ++ a))
20:38:16 <Rastus_Vernon> > let a = "a" ; b = "b" in (a ++ b) == (reverse (b ++ a))
20:38:17 <lambdabot>  True
20:39:10 <Rastus_Vernon> Let’s try this…
20:39:12 <Rastus_Vernon> > let a = "a" : b ; b = "b" : a in (a ++ b) == (reverse (b ++ a))
20:39:17 <lambdabot>  mueval: ExitFailure 1
20:39:22 <Rastus_Vernon> Yeah, it won’t end.
20:39:27 <dmj`> > let (a,b) = over both (+1) $ (1,2) in a == b
20:39:29 <lambdabot>  False
20:39:35 <lispy> > reverse [1..]
20:39:39 <lambdabot>  mueval-core: Time limit exceeded
20:39:40 <dwcook> Just a note, function application binds tighter than anything (except record syntax), so given that you can always get rid of the parens around reverse there
20:39:55 <dwcook> As it happens, (==) has particularly low precedence, so you can also get rid of them around the (++) expressions
20:40:13 <dmj`> :i ($)
20:40:17 <Rastus_Vernon> dwcook: In the case of reverse, removing them would have the opposite effect of what I want.
20:40:24 <Rastus_Vernon> dwcook: You are right about ==, though, I guess.
20:40:26 <dwcook> No, observe
20:40:34 <Rastus_Vernon> I really don’t know operator precedence.
20:40:40 <dwcook> > ("a" ++ "b") == (reverse ("b" ++ "a"))
20:40:41 <lambdabot>  True
20:40:44 <dwcook> > ("a" ++ "b") == reverse ("b" ++ "a")
20:40:45 <lambdabot>  True
20:40:46 <dwcook> Same answer
20:41:00 <Rastus_Vernon> Yeah, but that’s the parentheses.
20:41:02 <dwcook> Right, I figured you didn't, that's why I was giving you the tip here
20:41:04 <Rastus_Vernon> Oh, I see what you meant.
20:41:07 <dwcook> Yes, that's what I was talking about
20:41:20 <lispy> ?pl \a b -> a ++ b == reverse (b ++ a)
20:41:20 <lambdabot> ap (ap . ((==) .) . (++)) ((reverse .) . flip (++))
20:41:21 <Rastus_Vernon> I thought you were talking about the other parentheses after reverse.
20:41:39 <dwcook> Ah, no, those are mandatory unless you use ($) or something
20:42:00 <dwcook> > (reverse ("b" ++ "a"), reverse $ "b" ++ "a")
20:42:01 <lambdabot>  ("ab","ab")
20:42:10 <Rastus_Vernon> But if function application has the highest precedence…
20:42:18 <Rastus_Vernon> … that means parentheses are always necessary.
20:42:28 <Rastus_Vernon> uh
20:42:32 <lispy> operators don't count as functions in this case
20:42:37 <nisstyre> Rastus_Vernon: lolno
20:43:04 <nisstyre> Rastus_Vernon: operator precedence is pretty simple
20:43:08 <nisstyre> you learned it in grade 6
20:43:14 <nisstyre> or earlier
20:43:25 <dwcook> Rastus_Vernon, that's false. Here's a counterexample: f a b. That parses as ((f a) b). If that's what you wanted, lucky you, no parens needed
20:43:32 * lispy wonders how long nisstyre has been stalking Rastus_Vernon 
20:43:35 <dwcook> If you wanted f (a b) then you need parens
20:43:41 <nisstyre> lispy: I am like the NSA
20:43:54 <Rastus_Vernon> dwcook: I know that. Rather, I meant…
20:44:36 <Rastus_Vernon> dwcook: I meant that when you want to give the result of an expression that is a function application where the function is an operator, you need parentheses.
20:44:47 <Rastus_Vernon> Now, what I don’t understand is how $ makes this not necessary.
20:44:57 <dwcook> Rastus_Vernon, if I understand your meaning correctly, yes, that's true
20:44:58 <srhb> It has very low precedence
20:44:58 <Rastus_Vernon> Isn’t it just a function that does nothing?
20:45:05 <srhb> No, it's function application
20:45:07 <dwcook> Rastus_Vernon, you're more right than you know
20:45:13 <srhb> Well, yeah, ish
20:45:15 <srhb> :P
20:45:19 <nisstyre> Rastus_Vernon: say # has prec 2 and is left associative, say % has prec 1 and is right associative, then: 1 # 3 % 6 % 3 = ((#) 1 ((%) 3 ((%) 6 3)))
20:45:25 <dwcook> ($) :: (a -> b) -> (a -> b) ; ($) = id
20:45:35 <nisstyre> make sense?
20:45:37 <dwcook> The point of ($) is it has very low precedence
20:45:52 <lispy> ($) is infixr 0
20:45:57 <startling> @src ($)
20:45:57 <lambdabot> f $ x = f x
20:45:58 <lispy> 0 being the lowest
20:46:10 <Rastus_Vernon> > reverse "b" ++ "a"
20:46:11 <lambdabot>  "ba"
20:46:12 <Rastus_Vernon> > reverse $ "b" ++ "a"
20:46:13 <lambdabot>  "ab"
20:46:21 <Rastus_Vernon> My question is why those two are different.
20:46:34 <nisstyre> Rastus_Vernon: because $ has a higher precedence than ++
20:46:35 <Rastus_Vernon> Shouldn’t reverse $ "b" evaluate to "b" and then "a" be added to it?
20:46:52 <haasn> I wonder if this issue I'm having is related to the GHC 7.8.2 thing
20:46:54 <nisstyre> (($) reverse ((++) "b" "a"))
20:46:56 <Rastus_Vernon> Oh, I see.
20:47:05 <nisstyre> > (($) reverse ((++) "b" "a"))
20:47:06 <lambdabot>  "ab"
20:47:06 <lispy> the first one is, (revese "b") ++ "a", and the second is reverse ("b" ++ "a")
20:47:09 <haasn> I'm getting a type error like “cannot match X with Y” where :kind! X and :kind! Y both evaluate to the exact same thing
20:47:16 <Rastus_Vernon> It is because the $ separates the application from it, making the ++ operation have precedence.
20:47:17 <dwcook> Rastus_Vernon, imagine the space that means "apply this thing to this other thing" as an operator that has higher precedence than any other operator
20:47:21 <haasn> but it seems like GHC doesn't evaluate it far enough before deciding they're not equal
20:47:39 <nisstyre> Rastus_Vernon: make sense?
20:48:01 <lispy> haasn: I'm pretty sure we'd need to play with your example.
20:48:12 <Rastus_Vernon> nisstyre: Yes, I understand.
20:48:27 <nisstyre> Rastus_Vernon: okay glad I could help
20:48:40 <haasn> Note: GHC pretty-prints some expressions involving promoted constructors in a way that doesn't actually parse
20:48:50 <haasn> eg. '['Promoted]
20:49:05 <lispy> haasn: sounds like a bug report is in order
20:49:11 <lispy> (or maybe it's already reported?)
20:50:06 <glosoli> Unregistering package from ghc-pkg removes its dir too ?
20:50:40 <pavonia> no
20:50:52 <glosoli> Any way to automatically get rid of that too ?
20:51:23 <carter> nope
20:51:23 <haasn> “It affects any type synonym whose RHS mentions a type family.” That'll be every single one of them, in my case :)
20:51:45 <glosoli> so what do people do  in Haskell when they no longer need some package ?
20:52:01 <carter> glosoli: they use cabal sandbox
20:52:04 <carter> and delete the sandbox
20:52:13 <glosoli> never heard of it, thanks
20:52:50 <carter> cabal install cabal-isntall
20:52:55 <carter> *cabal-install
20:53:00 <carter> then mkdir foo
20:53:02 <carter> cd foo
20:53:04 <carter> cabal sandbox init
20:53:05 <dwcook> cabal isn't all
20:53:15 <carter> hah
20:53:16 <carter> punny
20:53:24 <dwcook> Puns? Where?
20:53:38 <carter> under your chair
20:53:49 <haasn> yuck, 7.8.1 breaks my previously-valid code, even
20:54:02 <glosoli> I have cabal install, I guess sandbox is separate package ?
20:54:05 <haasn> So this is unrelated to the GHC-Nat refactoring I did
20:54:06 <hakujin> glosoli: ghc-pkg unregister is an alternative if you need to kill specific packages
20:54:06 <glosoli> cabal-install"
20:54:22 <dwcook> glosoli, it's a feature of the latest version of cabal-install. You need to upgrade if you don't have it
20:54:44 <dwcook> glosoli, do what carter said: cabal install cabal-install
20:54:59 <dwcook> (after a cabal update if necessary)
20:55:11 <glosoli> Weird I think I have the lastest
20:55:16 <glosoli> I did cabal install cabal-install yesterday
20:55:26 <dwcook> What does `cabal -V` say?
20:55:43 <glosoli> using version 1.16.0 of the Cabal library
20:55:43 <carter> cabal --version
20:55:47 <carter> no
20:55:49 <carter> the other line
20:55:54 <glosoli> cabal-install version 1.16.0.2
20:55:59 <carter> ok
20:56:03 <dwcook> You don't have it then
20:56:07 <carter> cabal update ; cabal install cabal-install
20:56:11 <carter> glosoli: mac or linux?
20:56:16 <carter> ok
20:56:17 <glosoli> Mac
20:56:19 <carter> do the following
20:56:28 <carter> rm ~/.cabal/config
20:56:32 <glosoli> yeah found new pkg
20:56:37 <glosoli> trying to install it, weird
20:56:41 <carter> then add ~/.cabal/bin to PATH
20:56:42 <glosoli> Must have missed smth
20:56:43 <carter> then
20:56:46 <glosoli> Already added
20:56:54 <carter> cabal update ; cabal install cabal-install
20:56:57 <carter> di dyou do the rm first?
20:57:07 <haasn> lispy: oh, I figured it out: type Kilo  = Deca^3 -- I'm quite sure this triggers the conditions for the bug, in fact it's Kilo failing to be expanded that's causing my issue.
20:57:12 <glosoli> carter: Do I nreally need to remove it, or it's just in case ?
20:57:14 <carter> glosoli: now open a new terminal shell
20:57:15 <carter> YES
20:57:18 <carter> KILLLL THE FUCKER
20:57:22 <carter> clear?
20:57:25 <carter> :)
20:57:37 <carter> 1.16 cabal config file is wrong for 1.18
20:58:11 <carter> i've tried letting it live,
20:58:11 <carter> nope
20:58:29 <carter> i only give directions that are always work
20:58:34 <glosoli> ok deleted config, running cabal install cabal-install
20:58:36 <dwcook> It sure is work
20:58:43 <carter> dwcook: :P
20:58:51 <glosoli> Still using older version of cabal-install
20:58:55 <glosoli> when I do cabal -V
20:58:57 <carter> glosoli: open new tab
20:59:01 <carter> cabal --version
20:59:07 <dwcook> glosoli, remember to cabal update if you haven't
20:59:08 * hackagebot cereal-conduit 0.7.2.1 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.7.2.1 (MichaelSnoyman)
20:59:11 <carter> also check that you added ~/.cabal/bin to path
20:59:14 <carter> you HAVE TO DO THIS
20:59:51 <carter> i'ma gona let srhb  take over
21:00:37 <glosoli> Weird, still the same and I have ~/.cabal/bin in the path
21:00:52 <jle`> um
21:00:59 <jle`> try clearing your cach
21:01:05 <carter> jle`: what cache
21:01:06 <jle`> cache
21:01:08 <jle`> um
21:01:10 <carter> glosoli: did you open a new tab
21:01:10 <jle`> bache
21:01:12 <jle`> bash
21:01:15 <glosoli> carter: I did
21:01:15 <carter> in terminal
21:01:17 <carter> ok
21:01:18 <dwcook> glosoli, what does `~/.cabal/bin/cabal -V` say?
21:01:29 <carter> glosoli: is it in the FRONT of the path
21:01:30 <glosoli> dwcook: hmmm
21:01:34 <carter> also "which cabal"
21:01:46 <glosoli> it's using cabal from /usr/local/bin
21:01:47 <glosoli> weird
21:01:50 <glosoli> priority shit
21:01:53 <glosoli> thanks
21:01:54 <jle`> hash -r
21:01:59 <carter> whats that do
21:02:02 <glosoli> it's my stupidity :)
21:02:08 <carter> glosoli: nailed it
21:02:10 <carter> :P
21:02:10 <glosoli> It's not using ~/.cabal/bin as a first cabal path
21:02:11 <dmj`> "GHC now has a parallel compilation driver"... so this means I can do cabal build -jN ?
21:02:25 <carter> glosoli: you put ~/.cabal/bin in the FRONT of the path :)
21:02:31 <carter> not back
21:02:43 <glosoli> I did
21:02:48 <carter> clearly not
21:02:49 * dwcook did not have to manually mess with the path when upgrading cabal and is not sure what makes the difference
21:02:49 <carter> :)
21:02:51 <glosoli> though there was /usr/local/bin
21:02:52 <glosoli> there
21:02:57 <glosoli> more in the front that ~/.cabal/bin
21:02:59 <carter> yes
21:03:02 <carter> thats not the front then
21:03:05 <dwcook> glosoli, if necessary, `source .profile` or wherever your path is set
21:03:09 <carter> :)
21:03:14 <carter> front means "before everyone else"
21:03:20 <glosoli> Yeah sorry
21:03:29 <glosoli> seems fine now thanks
21:03:29 <carter> glosoli: if i sound grumpy, its because every night this week someone has this problem
21:03:36 <carter> or a lreated one
21:03:36 <carter> :)
21:03:48 <glosoli> Nah, doesn't sound grumpy at all
21:03:54 <carter> heh
21:03:59 <carter> well
21:04:03 <carter> clearly i'm polite when grumpy
21:04:12 <dwcook> A polite grump is better than a rude one
21:04:17 <carter> dwcook: bullshit
21:04:30 <dwcook> I mean for everyone else involved :P
21:04:31 <carter> at least with the rude one you know' they're grumpy
21:04:32 <carter> :P
21:04:40 <dwcook> I see your point
21:05:01 <carter> hah
21:05:07 <carter> i should take a break
21:05:07 <glosoli> carter: Ok when I have cabal sandbox initialized, do I need to do something else, or whenever I will run cabal install it will install to that sandbox if I will be in that dir ?
21:05:15 <carter> idk
21:05:32 <carter> i just type commands from muscle memory and read the manual :)
21:05:37 <dwcook> glosoli, if your PWD is the sandbox directory, cabal install will install to the sandbox
21:05:51 <carter> i'll leave you in the gentle hands of the rest of the channel
21:06:09 <glosoli> Ok thanks folks!
21:06:41 <startling> @remember carter i'll leave you in the gentle hands of the rest of the channel
21:06:41 <lambdabot> It is stored.
21:06:45 <dwcook> I'm not sure if it works in child directories, would be a good thing to check
21:06:55 <startling> oh, shoot, it's @quote add isn't it
21:07:10 <dwcook> @help remember
21:07:11 <lambdabot> remember <nick> <quote>: Remember that <nick> said <quote>.
21:07:13 <dwcook> You're good
21:07:27 <startling> ah. :)
21:08:50 <glosoli> dwcook: it doesn't
21:10:09 <dwcook> Yeah, I just tried installing a package from a child directory of a sandbox and it installed user-globally
21:10:21 <dwcook> I hope they let you do that in the future
21:10:24 <dwcook> cabal sandbox is still new
21:10:28 <glosoli> Sure they will
21:10:32 <glosoli> That's the only logical path
21:10:53 <dwcook> Well, I wouldn't go that far
21:11:02 <dwcook> as to say it's the *only* one, that is
21:11:30 <haasn> Awesome, now I can use Nat *and* Symbol
21:11:34 <glosoli> Well it's not like I can think of any other, unless they do like things like virtualenv in python, where you just switch to virtual environment and all the commands you execute are in that sandbox
21:11:38 <haasn> My library just got catapulted into the future
21:11:49 <dwcook> haasn, better run and catch it
21:12:04 <dwcook> or hop in the catapult yourself, if you don't mind a few broken bones
21:13:21 <dwcook> I think I took that metaphor too literally
21:21:10 <startling> Why does STM require compiler support?
21:22:28 <dwcook> startling, it's not implementable at the language level
21:22:46 <dwcook> You can't just have a package that provides it
21:23:03 <startling> dwcook, right. why not?
21:23:16 <dwcook> Because it's internally impure even though it has a pure interface
21:23:22 <dwcook> Oh, sorry
21:23:25 <dwcook> Misread ST
21:23:29 <startling> heh.
21:27:12 <dwcook> Is it possible to run a REPL (probably ghci) but have available the packages in the current sandbox, without having a cabal package file?
21:28:34 <carter> setup a sandbox and a dummy cabl file
21:28:38 <carter> :)
21:28:43 <startling> dwcook, ghci -package-db .cabal-sandbox/my-platform-whatever.conf.d
21:28:45 <carter> and then use cabal repl
21:28:49 <carter> or that
21:31:05 <gamegoblin> Mmmm vim parses and syntax highlights “ dash dash colon “ as a comment, but GHC disagrees
21:31:08 <dwcook> startling, thanks
21:31:29 <dwcook> gamegoblin, Vim's syntax highlighting for Haskell can be naïve
21:31:38 <dwcook> Let's see what the report says
21:31:39 <gamegoblin> I figured as much
21:31:47 <startling> gamegoblin: needs to be dash dash space
21:31:57 <gamegoblin> startling: I know, I was just remarking that vim was silly
21:32:05 <startling> ah.
21:32:34 <dwcook> The sequence of dashes must not form part of a legal lexeme. For example, “-->”
21:32:37 <dwcook> or “|--” do not begin a comment,
21:32:41 <dwcook> gamegoblin, ^
21:32:47 <dwcook> Quote from Haskell 2010 report
21:33:34 <gamegoblin> Quoth Simon Marlow, Lord and Saviour
21:33:38 <dwcook> > --not dash dash space but still a comment
21:33:39 <lambdabot>  not an expression: ‘--not dash dash space but still a comment’
21:33:41 <dwcook> Woops
21:33:44 <dwcook> > 10 --not dash dash space but still a comment
21:33:45 <lambdabot>  10
21:34:15 <dwcook> > 10 --- not a comment?
21:34:16 <lambdabot>  10
21:34:20 <dwcook> Heh, woop
21:34:24 <dwcook> > 10 --> not a comment
21:34:25 <lambdabot>  Not in scope: ‘comment’
21:34:25 <lambdabot>  Perhaps you meant ‘comments’ (imported from Lambdabot.Plugin.Haskell.Eval.Tr...
21:34:31 <gamegoblin> Lollllll
21:34:35 <startling> :t (-->)
21:34:36 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
21:34:48 <shachaf> > let comment = False in   not comment
21:34:49 <lambdabot>  True
21:34:50 <gamegoblin> mmm just made a haskell regex engineeee
21:34:53 <startling> :t comments
21:34:54 <lambdabot> OEISSequence -> [String]
21:34:59 <startling> what's that?
21:35:14 <gamegoblin> online encyclopedia of integer sequences?
21:35:19 <gamegoblin> would be my guess
21:35:25 <gamegoblin> that’s the only OEIS I know ;)
21:35:36 <derek_c> has anyone here done the *course*?  https://github.com/NICTA/course/
21:35:57 <startling> http://hackage.haskell.org/package/oeis-0.3.5/docs/Math-OEIS.html
21:36:12 <gamegoblin> CALLED IT
21:36:34 <gamegoblin> I was just on OEIS today looking at the partition function
21:36:47 <dmj`> derek_c: have you?
21:37:06 <startling> gamegoblin: bell numbers?
21:37:11 <gamegoblin> yes
21:37:24 <startling> those are fun. they were introduced to me as an exercise in a book.
21:37:40 <haasn> > generalCategory ' '
21:37:41 <lambdabot>  Space
21:37:45 <gamegoblin> In particular, I was wondering how many ways the regular expression (a+)* could be interpreted for the input of 1000 ‘a’s
21:37:49 <haasn> > ' '
21:37:50 <lambdabot>  '\5760'
21:37:58 <derek_c> dmj`, nope, just have some questions
21:38:16 <gamegoblin> which, it turns out, is a very big number. Something like 10^36
21:39:14 <dmj`> derek_c: this is the place to ask
21:39:40 <haasn> gamegoblin: all combinations of positive integers i_n so that i_0 + i_1 + i_2 + ... i_n = 1000 ?
21:39:43 <haasn> for any n
21:40:18 <gamegoblin> haasn: close, since you might not match all 1000 ‘a’s
21:40:25 <haasn> oh
21:40:27 <gamegoblin> So it’s the function you said, but for 1 to 1000
21:40:29 <gamegoblin> not just 1000
21:40:59 <startling> "How many distinct partitions are there of a set with n members?" <- Look how innocent this question looks
21:41:36 <dmj`> derek_c: what are you q's?
21:41:39 <dmj`> your*
21:41:43 <haasn> gamegoblin: as for the actual computation, I guess you first divide by whether or not they include 1 or not, so it's something like f(1,1000) = f(2,1000) + f(1,999)
21:41:55 <derek_c> dmj`: I was wondering how do run tests
21:41:56 <haasn> recurse until you get to f(n,n) or f(_,0)
21:41:58 <Cale> Well, it is like one of the first things you should probably look into if you're studying enumerative combinatorics, once you have the basic tools of generating series under your belt :)
21:42:08 <derek_c> dmj`: i.e. how do I know if the code I'm writting is correct
21:42:32 <Cale> I suppose *set* partitions require slightly more advanced machinery than *integer* partitions.
21:43:06 <startling> "The first exhaustive enumeration of set partitions appears to have occurred in medieval Japan, where (inspired by the popularity of the book The Tale of Genji) a parlor game called genji-ko sprang up, in which guests were given five packets of incense to smell and were asked to guess which ones were the same as each other and which were different. The 52 possible solutions, counted by the Bell number B5, were recorded by 52 diffe
21:43:22 <Cale> "by 52 diff"
21:43:28 <Cale> (cut off)
21:43:29 <dmj`> derek_c: well tests can help, as long as the tests are correct :P If you want to run tests in haskell I'd recommend using QuickCheck for pure code and HUnit (or another framework) for more "unit test" like things
21:43:42 <derek_c> dmj`: no no no.......
21:43:50 <dmj`> derek_c: explain
21:43:58 <derek_c> dmj`: I'm talking about the project *course*
21:44:02 <derek_c> it's a set of exercises
21:44:18 <startling> Cale: this was in the introduction of a book called "Basic Algebra". I was not prepared.
21:44:19 <derek_c> I was assuming there are also tests for those exercises
21:44:32 <derek_c> https://github.com/NICTA/course/
21:44:52 <Cale> startling: (I meant your message was longer than the IRC line length limit and was truncated there)
21:45:18 <startling> oh, "erent diagrams, which were printed above the chapter headings in some editions of The Tale of Genji."
21:45:26 <dmj`> derek_c: make an issue on github
21:45:28 <startling> I was responding to what you said before, though. :)
21:45:33 <Cale> ah
21:47:37 <Cale> There's some beautiful machinery to make the problem of finding an appropriate generating series easy to solve. Eventually, it just comes down to noting that set partitions are sets of nonempty sets, noting that the exponential generating series for sets is exp(x), and for nonempty sets is then exp(x) - 1, and so set partitions are counted by exp(exp(x) - 1)
21:48:02 <Cale> (i.e. the coefficient of x^n / n! in that formal power series is the number of such partitions)
21:48:53 <srhb> Great, now I made the ghc-stage-1 panic. This truly IS an adventure. :3
21:49:18 <startling> Cale: oh, that's interesting.
21:49:27 <startling> I just drew about five pages of diagrams.
21:49:59 <startling> (But didn't come up with a general solution).
21:52:11 <Cale> e.g. the coefficient of x^5 in that series is 13/30, which translates to the coefficient of x^5/5! being 5! * 13/30 = 52
21:54:08 <carter> startling: Cale  theres some really nice books free online on this topic
21:54:35 <Cale> There's also some really terrible ones ;)
21:54:48 <startling> carter: I'd love a recommendation.
21:54:57 <carter> Cale: you'll like my suggestions
21:55:08 <carter> start with http://www.math.upenn.edu/~wilf/DownldGF.html
21:55:35 <Cale> that one was what I had in mind when I made my remark :(
21:55:37 <carter> then spend a career savoring http://algo.inria.fr/flajolet/Publications/book.pdf and http://www-math.mit.edu/~rstan/ec/ec1.pdf
21:55:42 <carter> Cale: why?
21:55:45 <carter> ok
21:55:56 <carter> i think the wilf one is simple and gives some nice bsaic ideas
21:55:58 <Cale> Well, it misses the big picture
21:56:04 <carter> the flajolet one is MAGIC
21:56:11 <carter> and the stanley one is deep
21:56:24 <Cale> That you're connecting algebraic operations on series to structural operations on weighted sets
21:56:28 <carter> yes
21:56:35 <carter> wilf is the warm up
21:56:38 <carter> not  the deep bit
21:56:59 <startling> carter: it's amazing how many "book.pdf"s I end up with
21:57:00 <carter> stanley and flajolet aren't intro books, though supper accessible
21:57:08 <carter> startling: save them with the title
21:57:12 <Cale> and it does a horrible job of explaining exponential generating series, to the point that I was confused and I already knew what was going on :P
21:57:12 <carter> and the author names
21:57:29 <carter> Cale: the flajolet book first chapter is great for teaching that
21:58:10 <gamegoblin> Going to put my first package on hackage soon, woo so exciting
21:58:16 <carter> gamegoblin: whats it for?
21:58:35 <Cale> Yeah, Flajolet's book has the right kind of approach
21:58:43 <gamegoblin> carter: a parser that merges a lot of what I like about Parsec, Attoparsec, and Regular Expressions into one place
21:59:01 <carter> on github yet?
21:59:08 <Cale> I really really wish I could get Dr. Jackson to publish or release the PDFs for his notes on enumerative combinatorics.
21:59:16 <carter> but?
21:59:39 <gamegoblin> carter: can parse arbitrary stream types (like Parsec), allows partial parses (like attoparsec), and finds all possible parses (unlike both of them), and can convert regex into a parser (unlike both of them)
21:59:54 <carter> gamegoblin: does it share all the parses
21:59:58 <carter> or give you a list of parses
22:00:06 <carter> applicative parser/
22:00:11 <gamegoblin> It returns a list of all possible parses
22:00:12 <carter> or does it give a monadic api
22:00:14 <carter> ahhh
22:00:16 <carter> so no sharing?
22:00:20 <gamegoblin> Define sharing
22:00:22 <carter> or does it do sharing internally
22:01:57 <gamegoblin> carter: by sharing you mean?
22:02:09 <carter> the sub trees of parses
22:02:16 <carter> for the same sequence
22:02:19 <carter> is shared in all the results
22:02:23 <carter> or is it copies
22:03:50 <gamegoblin> Uhhh still not entirely sure what you mean, but it behaves very similarly to the list monad
22:04:52 <carter> @google GLL
22:04:52 <lambdabot> No Result Found.
22:05:39 <gamegoblin> carter: https://github.com/grantslatton/JustParse
22:05:58 <carter> gamegoblin: have you seen edwardk 's parses lib?
22:06:05 <gamegoblin> Nope
22:06:23 <carter> you may wanna check i tout
22:06:40 <gamegoblin> Any particular reason?
22:06:59 <carter> https://github.com/ekmett/parsers
22:07:04 <carter> its even more generic than yours
22:07:06 <carter> :)
22:07:24 <gamegoblin> Heh cool
22:07:29 <carter> http://hackage.haskell.org/package/parsers
22:07:35 <haasn> ghc: panic! (the 'impossible' happened) # oops
22:08:19 <gamegoblin> My goal is to make an entire haskell web server and framework using no external libraries
22:08:28 <gamegoblin> just for learning purposes, mainly
22:08:37 <carter> ok
22:08:38 <carter> cool
22:08:45 <haasn> what's an “external library” for this definition?
22:08:51 <carter> it need not be on hackage then :)
22:09:05 <startling> I doubt gamegoblin's thing could implement Parsing
22:09:10 <carter> yeah
22:09:13 <carter> could be
22:09:17 <carter> i've not read it closely enough
22:09:20 <startling> "try" limits things a lot
22:09:21 <carter> looks cute though
22:09:31 <gamegoblin> startling: what do you mean?
22:10:44 <startling> gamegoblin: can you write a combinator 'try' that "[takes] a parser that may consume input, and on failure, go back to where we started and fail as if we didn't consume input."
22:10:47 <startling> ?
22:11:04 <gamegoblin> startling: my parsers always backtrack on failure
22:11:27 <gamegoblin> It’s not a monadT either, so I don’t need to worry about craziness with the IO monad
22:11:48 <startling> I wonder if try = id breaks 'parsers'.
22:12:01 <gamegoblin> That being said, it isn’t strict like Attoparsec. It will parse any Stream type like Parsec.
22:12:44 <gamegoblin> Anything you can implement in parsec or attoparsec, you can implement in my parser
22:12:45 <startling> gamegoblin: anyway I'm talking about http://hackage.haskell.org/package/parsers-0.11/docs/Text-Parser-Combinators.html#t:Parsing
22:13:58 <gamegoblin> Mmm I don’t have the ability to name a parser, but that wouldn’t be hard to implement
22:14:10 <gamegoblin> But other than that, got it
22:14:41 <gamegoblin> the only thing about my parser is that it’s slower than parsec or attoparsec, since it explores all possible parse trees (until the branch fails, of course), rather than just a greedy one
22:15:07 <startling> sure.
22:15:28 <gamegoblin> so something like “many alpha >> alpha” will fail in Parsec
22:15:28 <startling> gamegoblin: 'parsers' will let you write code that can be shared between parsec, attoparsec, and your thing. :)
22:15:40 <gamegoblin> since the many alpha will consume the final alpha you want
22:15:49 <startling> sure, understood.
22:16:03 <gamegoblin> Mmmmm gotcha. I hadn’t heard of parsers
22:16:11 <gamegoblin> do parsec and attoparsec use it?
22:18:58 <startling> no, but they are instances of Parsing.
22:19:16 <startling> (and some other typeclasses)
22:19:31 <gamegoblin> Huh gotcha
22:19:41 <carter> gamegoblin: you should look up GLL parsing
22:19:50 <carter> it does your thing
22:19:52 <carter> but efficiently
22:19:59 <carter> with worst case cubic complexity
22:20:39 <gamegoblin> Reading it now
22:20:48 <gamegoblin> Yeah mine is exponential worse case, of course
22:21:00 <gamegoblin> The core machinery of mine is like 50 lines of code ;)
22:21:26 <kadoban> I notice that when I'm using a string of monad transformers, I have about a thousand different ways to run it, depending on what I want to supply and what results I care about. Is there some standard I should use in naming them, or some cute way to handle that mess?
22:21:59 <jle`> kadoban: do you mean the order the stack?
22:22:07 <jle`> or...how to name your type synonym? ...
22:23:31 <kadoban> jle`: I mean like, I can "run" the thing giving it an environment for ReaderT, or not. I can run it and check the Log (WriterT), or not care about the log, I can run it and check the result or not, I can run it with a default State or not, etc.  I'm not entirely sure what I'm looking for, but it seems like maybe there's something I should be doing, even if it's just naming the different options consistently?
22:24:00 <startling> kadoban, you might like RWST
22:24:28 <startling> there's a half-baked eval / exec distinction but I'm not sure it's useful for you.
22:24:46 <NemesisD> i've a datatype like data MinuteSpec = forall a. Minutes (CronField a). is there a sensible way to derive eq where Eq a?
22:24:59 <kadoban> Ahh, hmm, I didn't know that existed...I wonder if that's what I'm looking for
22:25:01 <startling> NemesisD: no.
22:25:17 <jle`> how would you even begin to typecheck that
22:25:22 <startling> kadoban, mostly I avoid running things except in a couple of places.
22:25:34 <jle`> if i said x == y
22:25:40 <jle`> there is no information about the a
22:25:41 <startling> NemesisD, how would you guarantee that two MinuteSpecs use the same a?
22:26:03 <startling> NemesisD: you could maybe write an Eq by writing a typeclass that all those a must satisfy.
22:26:08 <jle`> (x :: Minutes) == (y :: Minutes)
22:26:19 <kadoban> startling: yeah...honestly most of these I think just exist so I can conveniently test some property or other...possibly I should just eliminate a bunch
22:26:22 <startling> e.g. toSeconds :: a -> Int or something, but at that point you might as well just use Int.
22:26:47 <jle`> *MinuteSpec
22:27:03 <NemesisD> ah i see. i think existential quantification may have been a mistake
22:27:38 <jle`> you can use GADT syntax
22:27:44 <jle`> to make sure that all a's you put into MinuteSpec
22:27:46 <jle`> are always Eq
22:28:06 <jle`> Minutes :: Eq a => CronField a -> MinuteSpec
22:28:16 <jle`> but
22:28:26 <jle`> you still can't guaruntee that they will be the same a
22:28:26 <NemesisD> the annoying thing is that in real life a can only be 1 of 2 types
22:28:42 <jle`> why don't you just split it into a sum of some sort
22:29:08 <startling> NemesisD: it usually is.
22:29:13 <jle`> data A = A1 a1 | A2 a2
22:29:20 * hackagebot propellor 0.3.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.3.0 (JoeyHess)
22:29:25 <NemesisD> CronField a is a GADT, i segregate its constructors, some of them are tagged Nestable, some are tagged UnNestable
22:29:29 <jle`> existential quantification is generally considered a bad idea
22:29:38 <startling> It's sometimes useful.
22:31:44 <srhb> If I change flags in ghc/mk/build.mk can I just run make again to get the results of that or do I need to do some cleaning?
22:33:17 <NemesisD> startling: jle` maybe i can get your opinion here. i'm modelling a field of a cron line, which can be a star, number, range, list, or numerator (*/2)
22:33:50 <NemesisD> it is invalid to nest lists within lists or numerators
22:34:13 <startling> NemesisD, data BaseField = Star | Number Double | Range Double Double
22:34:38 <startling> data Field = Field BaseField | List BaseField | Numerator BaseField
22:35:39 <NemesisD> hmm, i suppose that could work
22:36:37 <deathbird> > take 5 [1..]
22:36:38 <lambdabot>  [1,2,3,4,5]
22:37:38 <Sgeo> Is EclipseFP still maintained?
22:37:43 <Sgeo> I'm considering trying it
22:37:50 <Sgeo> Although I currently use NetBeans for Java code
22:38:20 <davidfetter> > take 5 ['bruebeck'...]
22:38:21 <lambdabot>  A section must be enclosed in parentheses thus: ('bruebeck' ...)Syntax error...
22:38:21 <lambdabot>  Perhaps you intended to use TemplateHaskell
22:38:37 <davidfetter> i guess i'll need to practice
22:43:38 <dmj`> > take 5 "bruebeck"
22:43:39 <lambdabot>  "brueb"
22:45:24 <c_wraith> now give them back
22:52:05 <startling> davidfetter, '...' indicates a character
22:52:07 <startling> > 'a'
22:52:08 <lambdabot>  'a'
22:52:10 <startling> > 'abc'
22:52:11 <lambdabot>  Syntax error on 'abc'
22:52:11 <lambdabot>  Perhaps you intended to use TemplateHaskell
22:52:44 <SrPx> Anyone knows a fast, simple way to load a image, transform its pixels somehow (writing them directly with something like `set img 5 5 255`) and save them?
22:53:57 <cmears> SrPx, maybe the JuicyPixels library?
22:59:03 <davidfetter> some day, when i understand enough about haskell, something that starts with 'take 5' will play same
22:59:44 <eguim> play same?
23:04:11 <deathbird> What is the best way to express an Octree in Haskell? I'm currently using "data Octree a = Node AABB [Octree a] | Leaf AABB [a] Int"
23:04:58 <davidfetter> http://www.youtube.com/watch?v=o2In5a9LDNg
23:06:42 <dmj`> davidfetter: have you tried learn you a haskell?
23:06:52 <davidfetter> dmj`, just starting :)
23:07:20 <dmj`> cool :) enjoy the journey, never give up ! you'll be stackin' monads in no time
23:07:23 <davidfetter> long ago, i did a degree in math, so i have that part of the background
23:07:37 <davidfetter> or at least enough of it :)
23:07:51 <dmj`> davidfetter: here's a dirty secret, you don't need to know category theory to program in Haskell :)
23:08:16 <solidus-river> hey all
23:08:17 <SrPx> cmears: maybe but pixelMap doesn't allow me to play with the coordinates... I'd want to write something similar to a flip function
23:08:24 <dmj`> you really just need to understand haskell's type system. Since it's very different from any other language really
23:08:36 <solidus-river> i'm trying to get used to coding some haskell and as an excersize am making a program that just does ls <dir>
23:08:45 <solidus-river> is there a cleaner way to write this, i'm definitely writing it wrong right now
23:08:47 <solidus-river> http://lpaste.net/102556
23:09:49 <dmj`> @typ filterM
23:09:50 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
23:10:41 <dmj`> @typ putStrLn =<< filterM (`notElem` [".", ".."]) <$> getDirectoryContents
23:10:42 <lambdabot> Not in scope: getDirectoryContents
23:10:51 <deathbird> SrPx: This might help: https://github.com/fiendfan1/Haskell-OpenGL/blob/master/Modern/Engine/Graphics/Textures.hs
23:11:58 <deathbird> SrPx: Lines 46-49
23:14:46 <davidfetter> how do i add a license to cabal? i find BSD3 pretty obnoxious
23:15:19 <pillar_Young> @where <-
23:15:19 <lambdabot> I know nothing about <-.
23:15:43 <SrPx> deathbird: (: ty
23:17:12 <solidus-river> hey all, so is there a way to do this cleaner without do notation? http://lpaste.net/102556
23:17:29 <solidus-river> or a way to do it without do notation in general
23:18:05 <jle`> i think there's a get files (non-directories)
23:18:07 <jle`> but
23:18:10 <caseof> Hi all. Can somebody help me understand a declaration like: newtype Action m a = Action {unAction :: ErrorT Failure (ReaderT Context m) a}
23:18:14 <solidus-river> and does it matter from a performance perspective and whats the preferred way of writing it
23:18:29 <jle`> print =<< filter blah <$> getDirectoryContents =<< getArgs
23:18:54 <jle`> you might have to do fmap (filter blah) in case of precedence issues
23:18:58 <solidus-river> jle`: is that more efficient than the do notation method or is it just easier to read?
23:19:08 <jle`> oh, it's equivalent to your do notation
23:19:15 <pavonia> caseof: What part is not clear to you?
23:19:59 <caseof> pavonia: unAction -> is it a constructor?
23:20:13 <caseof> I don't see an implementation for it
23:20:29 <solidus-river> jle`: thanks :) so its purely a readability thing
23:20:34 <jle`> yes
23:20:40 <pavonia> No, a function :: Action -> ErrorT ...
23:20:44 <jle`> or well
23:20:53 <jle`> one would argue about whether it's more readable or not
23:20:54 <solidus-river> also interesting i did learn you a haskell and it talked a lot about >>= but i dont remember <<= is that pretty much the same except in reversa and is there also an equivalent <<?
23:20:58 <jle`> but it's just a non-do version
23:21:07 <jle`> =<< is the reverse =>>
23:21:09 <jle`> <<= is different
23:21:29 <caseof> pavonia: Ok, thx. So how do I construct a value of type Action?
23:21:45 <jle`> sorry, =<< is teh reverse >>=
23:21:47 <solidus-river> so =<< takes a value out of a monad and gives it as input to the left side, what does <<= do?
23:22:00 <jle`> <<= does not work with monads
23:22:06 <dmj`> @typ <<=
23:22:07 <lambdabot> parse error on input <<=
23:22:23 <jle`> (=<<) is just flip (>>=)
23:22:24 <dmj`> =<< or >>=
23:22:34 <pavonia> caseof: "Action" here is like an ordinate construtor taking an argument of type ErrorT ...
23:22:39 <jle`> (=>>) and (<<=) work with comonads
23:23:06 <jle`> so they're not quite relevant here
23:23:35 <pavonia> caseof: So you can construct one like "Action value" or using explicite record syntax "Action { unAction = value }"
23:23:36 <deathbird> caseof: unAction is an argument of the constructor. The code you gave could be written: "newtype Action m a = Action (ErrorT Failure (ReaderT Context m) a)"
23:23:41 <solidus-river> comonads, is there a learn you a haskell chapter on them or where can i go to learn more what that means
23:24:22 <jle`> they're not quite an beginner haskell concept
23:24:38 <jle`> but typically people refer to edwardk's cellular automata series
23:24:40 <jle`> https://www.fpcomplete.com/user/edwardk/cellular-automata
23:24:44 <pavonia> caseof: Think of unAction as a named argument of Action
23:25:22 <jle`> solidus-river: for now, =<< is just a flipped >>=
23:26:20 <caseof> pavonia: Ok. But how does the compiler know the implementation for unAction?
23:26:39 <solidus-river> jle`: kk, thanks :) i'm goign to try to wrap my head around comonads tomorrow, its been a long time since i was last in haskell land, i shoudl also freshen up on the end of learn you a haskell :\
23:27:04 <mgsloan>                                                                                                                                     
23:27:05 <shachaf> There was a time before learnyouahaskell chapters, a world of books and papers and articles and the Internet. A world we have lost.
23:27:05 <pavonia> caseof: What implementaion? It's just an accessor to a constructor arguement
23:27:35 <jle`> solidus-river: =<< is usually preferred over >>= when you use (.) and stuff
23:27:48 <jle`> consider f . g =<< h
23:27:52 <jle`> compared to h >>= f . g
23:27:56 <deathbird> caseof: unAction could be written "unAction (Action x) = x"
23:27:59 <jle`> h happens first, then g, then f
23:28:05 <jle`> in the second version, your eyes jump back and forth
23:28:33 <dmj`> shachaf: the typeclassoepdia still exists
23:29:04 <caseof> pavonia: deathbird oh, ok actually it's a trivial function. Thx!
23:31:46 <deathbird> I'm currently writing a game engine in Haskell and one of the things I don't know how to go about is complex animations of 3D models. I just don't see how it could be done efficiently without mutablility
23:31:58 <jle`> deathbird: nothing wrong with mutability
23:32:06 <deathbird> Well...
23:32:35 <deathbird> I would prefer not to use it
23:32:57 <deathbird> I might as well use an external C library
23:33:13 <jle`> ew
23:33:15 <bitemyapp> quite a leap.
23:33:22 <jle`> you can handle mutability in a pure and first-class way
23:33:56 <deathbird> Is use of the FFI frowned upon?
23:34:13 <jle`> naked ffi
23:34:24 <jle`> but if you wrap it in pure composable abstractions
23:34:32 <jle`> then
23:34:36 <jle`> you have Data.Array
23:34:38 <jle`> etc.
23:34:40 <dmj`> deathbird: then use mutability
23:34:58 <jle`> haskell is good at reasoning with mutability in safe and equational ways
23:35:00 <dmj`> what jle` said
23:35:01 <deathbird> Yeah I guess it's the only solutuin
23:35:26 <dmj`> using ST you can malloc ararys, freeze things, and make them pure
23:35:43 <zq> suits season finale
23:35:48 <zq> whoops
23:35:57 <jle`> and ST is pure :)
23:36:11 <jle`> and obeys equational reaosning
23:36:23 <deathbird> That sounds enticing
23:37:23 <jle`> also i might advise trying to build a game to test these principles etc. before building a game engine
23:37:55 <deathbird> Well I'm a bit late for that...
23:38:19 <jle`> :)
23:39:09 <jle`> why am i building a pokemon library
23:39:23 <jle`> when did i come to the conclusion that this would be a good investment of my time
23:40:18 <deathbird> jle`: Make sure to use Type Families - https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon
23:40:33 <dmj`> there is a haskell game engine out there I thought
23:40:36 <dmj`> called Helm
23:40:43 <deathbird> Yeah helm is ok
23:40:48 <deathbird> 2D
23:40:53 <dmj`> http://helm-engine.org/
23:41:17 <deathbird> I really like the FRP library they use, Elerea
23:41:28 <deathbird> If only I could understand it
23:41:37 <dmj`> deathbird: are you using opengl libs?
23:41:56 <deathbird> OpenGLRaw
23:42:18 <deathbird> And some OpenGL
23:42:51 <deathbird> dmj`: Source is on GitHub if interested: https://github.com/fiendfan1/Haskell-OpenGL
23:44:26 <dmj`> intellesting
23:45:40 <dmj`> he has no cabal file
23:46:16 <dmj`> and has a 20mb binary stored in git
23:46:20 <deathbird> dmj`: Who has no cabal?
23:46:38 <dmj`> the link you sent
23:46:58 <dmj`> Haskell-OpenGL
23:47:07 <deathbird> dmj`: Oh thats me. It's not for release. And I'm too lazy to delete the executable
23:47:49 <solidus-river> is cabal good at large binaries?
23:47:57 <solidus-river> err, grr, darcs
23:48:07 <dmj`> deathbird: sure you don't have to put it on hackage, but I'd like to use it. Hard for me to know what dependencies you have
23:48:53 <deathbird> It's not stable in any way right now. It's not even intended for use. I don't even know my dependencies..
23:49:19 <deathbird> I'll try to cabalize it soon
23:49:43 <deathbird> I really don't like cabal
23:50:02 <solidus-river> deathbird: what don't you like about cabal?
23:50:09 <solidus-river> deathbird: what do you use instead?
23:50:53 <deathbird> Well... cabal-install actually. I'm on arch linux, so I'm trying to use the cabal2arch script to install all my cabal packages
23:51:16 <dmj`> deathbird: cabal isn't bad, are you using sandboxes? What editor?
23:51:28 <bitemyapp> deathbird: like ice skating uphill eh?
23:51:40 <solidus-river> deathbird: i'm on gentoo and its very friendly to using cabal to manage haskell
23:51:51 <deathbird> dmj`: Most of my dislike is probably a result of me not knowing how to use it
23:51:59 <solidus-river> deathbird: pretty sure the haskell ebuilds wrap cabal simply with deps translated into emerge
23:52:06 <solidus-river> wonder what cabal2arch does
23:52:23 <solidus-river> it wouldn't hurt you to just use cabal unless your making a specific arc package that will rely on your lib that you want to use
23:52:29 <solidus-river> *arch
23:52:55 <solidus-river> but.. kinda talking out my bum, i know arch is based on gentoo / emerge but never really looked at it
23:53:28 <deathbird> solidus-river: Arch isn't based on anything. It's basically linux with a package manager
23:54:48 <solidus-river> whoa, i thought arch was just binaries pacaked for a preset chunk of use flags and architectures from emerge
23:55:37 * solidus-river sits in corner for a while
23:56:37 <dmj`> deathbird: to learn cabal I just copied a lot of cabal files from projects I used, then eventually read the user guide
23:57:23 <deathbird> dmj`: Yeah it doesn't seem too complex, and I really should learn
23:57:50 <solidus-river> deathbird: yeah, i had a hell of a time trying to learn how to set up a good workflow with cabal, there are 2 examples on the haskell wiki that both seem out of date, ended up reading them then doing a mix of what they said and some stuff based on what https://github.com/ekmett/lens does
23:59:48 <deathbird> solidus-river: I put up an OpenGL Matrix library on Hackage using a script that does most of it for you. That was useful.
