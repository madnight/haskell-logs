00:00:22 <jle`> even when i drive around town i bounce between fleshing out like five different rojects
00:09:25 * hackagebot eternal 0.0.4 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.0.4 (Heather)
00:09:25 * hackagebot hspec-smallcheck 0.2.0 - SmallCheck support for the Hspec testing framework  http://hackage.haskell.org/package/hspec-smallcheck-0.2.0 (SimonHengel)
00:24:09 <no-n> :t void
00:24:10 <lambdabot> Functor f => f a -> f ()
00:25:16 <jle`> void will be much more useful after the applicative/monad thing is all sorted out
00:25:52 <no-n> what applicative/monad thing?
00:26:18 <no-n> making them the same class?
00:26:19 <jle`> applicative is a superclass of monad
00:26:34 <no-n> i thought it was the other way around
00:26:49 <no-n> wait
00:26:49 <jle`> applicative is a more general monad
00:26:51 <no-n> no, nmv
00:27:07 <no-n> @hoogle FilePath -> IO Bool
00:27:08 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
00:27:08 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
00:27:08 <lambdabot> System.Posix.Files fileExist :: FilePath -> IO Bool
00:30:27 <no-n> @hoogle Word8
00:30:28 <lambdabot> Data.Word data Word8
00:30:28 <lambdabot> Data.ByteString.Builder.Prim word8 :: FixedPrim Word8
00:30:28 <lambdabot> Data.ByteString.Builder word8 :: Word8 -> Builder
00:30:34 <no-n> @hoogle Char8
00:30:34 <lambdabot> Data.ByteString.Char8 module Data.ByteString.Char8
00:30:34 <lambdabot> Data.ByteString.Lazy.Char8 module Data.ByteString.Lazy.Char8
00:30:34 <lambdabot> Data.ByteString.Builder.Prim char8 :: FixedPrim Char
00:30:52 <no-n> what's the difference between Char8 and Word8?
00:33:02 <jle`> Char8 is a module for typeclass instances iirc
00:33:13 <jle`> it's not an actual type
00:33:45 <jle`> it's a module for using ByteStrings as if they were strings of 8-bit characters
00:33:53 <no-n> okay
00:33:55 <jle`> with meaningful instances like IsString
00:34:00 <no-n> ty
00:34:05 <jle`> np
00:35:46 <no-n> readFile name   =  openFile name ReadMode >>= hGetContents <- when does it get closed?
00:46:10 <abir1729> hello
00:46:23 <abir1729> i am a haskell newbie coming from a c++ background
00:46:56 <jle`> abir1729: hello abir :)
00:47:44 <abir1729> jle`: hi justin :)
00:48:43 <abir1729> can anybody please suggest a good tutorial on haskell which is intended for math enthusiasts
00:48:52 <abir1729> any book/blog/website?
00:49:01 <jle`> how much haskell do you know already?
00:49:30 <abir1729> i'm just starting out
00:50:16 <zol_> hi! I have a tuple (8,8,8,8,8), and I can add 1 a total of 25 times in total (to a max of 23 for a single element) over all elements. So I could get something like (23,18,8,8,8), (22,19,8,8,8), ..., (8,8,8,18,23) for example. Anyone got any hints on where I could start with this? I'm feeling really lost at the moment.
00:50:44 <jle`> well, "learn you a haskell" is generally suggested as a general introduction to haskell that should get you up to speed
00:50:56 <jle`> as for blogs specific to math enthusiasts...what kind of math?
00:51:03 <abir1729> yes..thanks..presently i'm going through that :)
00:52:12 <jle`> zol_: what are you trying to do? generate all possible ways you can add 1 25 times?
00:52:57 <zol_> jle`: Yeah
00:53:26 <pordan30> abir1729: you might appreciate graham hutton's "programming in haskell" and the accompanying lectures by erik meijer
00:53:28 <jle`> zol_: well...this is a problem where i would suggest doing a bit of the combinatorics work and figuring out the math yourself
00:53:44 <jle`> but you could also brute-force it
00:54:06 <jle`> write a function returning all the ways you can add one once
00:54:23 <jle`> addOne :: (Int,Int,Int,Int,Int) -> [(Int,Int,Int,Int,Int)]
00:55:24 <jle`> and then you can do something like (iterate (>>= addOne) (return (8,8,8,8)) !! 25
00:55:33 <jle`> and then nub it
00:55:39 <zol_> jle`: nub it?
00:55:41 <jle`> horribly inefficient :)
00:56:01 <jle`> nub, keep only unique elements
00:56:16 <jle`> you can also do the whole thing inside the Set 'monad', to save the nubbing...that probably makes more sense too
00:56:43 <zol_> Hm..
00:56:44 <jle`> so write addOne :: (Int,Int,Int,Int,Int) -> Set (Int,Int,Int,Int,Int)
00:57:10 <jle`> basically you are doing return (8,8,8,8,8) >>= addOne >>= addOne >>= addOne >>= addOne
00:57:13 <jle`> ...
00:57:15 <jle`> 25 times
00:58:13 <jle`> for an actually sane solution, try seeing how many ways you can split 25 into five addends
00:58:36 <jle`> with the constraint that no single addend can be greater than 15
00:59:16 <zol_> jle`: Ah, yeah, thanks -- then I could just map those addends to the base state, and shift the results around five times?
00:59:43 <zol_> No, that is unnecessary
01:05:21 <zol_> jle`: I realized I can do it as a list comprehension: [(str,dex,con,int,wis) | str <- [8..23], dex <- [8..23],..., str+dex+int+wis+con==65]
01:06:13 <jle`> zol_: ah yeah, that works :)
01:06:24 <zol_> I love haskell!
01:07:07 <zol_> Will be terribly slow however :D
01:07:51 <jle`> well...it's basically a nested loop
01:07:53 <jle`> :)
01:08:37 <zol_> Yeah.. I haven't worked with monads before very much, so the approach you suggested feels very scary. :/
01:08:39 <jle`> > [(str,dex,con,int,wis) | str <- [8..23], dex <- [8..23], con <- [8..23], int <- [8..23], wis <- [8..23], str+dex+int+wis+con==65]
01:08:40 <lambdabot>  [(8,8,8,18,23),(8,8,8,19,22),(8,8,8,20,21),(8,8,8,21,20),(8,8,8,22,19),(8,8,...
01:08:44 <jle`> not too bad
01:10:46 <jle`> > do { stats@(a,b,c,d,e) <- (,,,,) <$> [8..23] <*> [8..23] <*> [8..23] <*> [8..23] <*> [8..23]; guard (a+b+c+d+e == 65); return stats }
01:10:47 <lambdabot>  [(8,8,8,18,23),(8,8,8,19,22),(8,8,8,20,21),(8,8,8,21,20),(8,8,8,22,19),(8,8,...
01:10:50 <jle`> hm
01:11:46 <jle`> > filter (\(a,b,c,d,e) -> a+b+c+d+e+f == 65) ( (,,,,) <$> [8..23] <*> [8..23] <*> [8..23] <*> [8..23] <*> [8..23] )
01:11:47 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
01:11:47 <lambdabot>    arising from a use of `e_165823823823823823'
01:11:47 <lambdabot>  The type variable `a0' is ambiguous
01:11:47 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
01:11:47 <lambdabot>  Note: there are several potential instances:
01:12:03 <jle`> > filter (\(a,b,c,d,e) -> a+b+c+d+e == 65) ( (,,,,) <$> [8..23] <*> [8..23] <*> [8..23] <*> [8..23] <*> [8..23] )
01:12:04 <lambdabot>  [(8,8,8,18,23),(8,8,8,19,22),(8,8,8,20,21),(8,8,8,21,20),(8,8,8,22,19),(8,8,...
01:13:27 <jle`> maybe that one?
01:13:48 <jle`> also i might suggest not using a tuple
01:13:54 <jle`> and using an actual data type
01:13:57 <jle`> with five fields :)
01:16:15 <zol_> jle`: Oh, how come a data type instead, easier to optimize?
01:17:40 <jle`> zol_: well, so you have some sort of semantics and type safety
01:17:49 <jle`> and also you get accessors, too
01:18:07 <jle`> data Stats = Stats { statStr :: Int, statDex :: Int ... }
01:18:18 <jle`> and also, say you have a function that takes stats
01:18:31 <jle`> you don' want to be able to let anyone pass any ol 5-tuple into it
01:18:55 <jle`> you want to say "this takes Stats. if you try to pass a normal 5 tuple then i won't compile."
01:19:30 <zol_> jle`: Yeah, true! I hadn't thought of that. Thanks
01:19:53 <jle`> also...structured data
01:19:55 <jle`> yeah :)
01:20:08 <jle`> usually tuples more than three elements are a sign of structured data of some sort
01:20:18 <jle`> it is rarely idiomatic to use more than a 2-tuple
01:20:35 <jle`> also it's really annoying because you don't have fst and snd for 3+
01:22:29 * zol_ nodnods in agreement
01:23:51 <zol_> jle`: What package do I need to import for <*>?
01:24:00 <jle`> zol_: Control.Applicative
01:24:07 <jle`> have you used applicatives before?
01:24:19 <zol_> jle`: No
01:24:30 <jle`> ah
01:24:46 <jle`> well
01:24:50 <jle`> have you used functors before?
01:25:00 <zol_> jle`: You mean lik map?
01:25:03 <zol_> like*
01:25:11 <jle`> yeah
01:25:14 <zol_> Yes :)
01:25:19 <jle`> let's say you have a function (a -> b)
01:25:27 <jle`> but you have an (f a)
01:25:30 <jle`> that you want to turn into an (f b)
01:25:44 <jle`> you can apply (a -> b) to your (f a) with the operator <$>
01:25:47 <jle`> kind of like...
01:25:54 <jle`> > (*2) $ 3
01:25:55 <lambdabot>  6
01:25:58 <jle`> > (*2) <$> Just 3
01:25:59 <lambdabot>  Just 6
01:26:22 <jle`> but what if you wanted to multiply things inside two maybes?
01:26:22 <zol_> So it's like lifting?
01:26:27 <jle`> Just 3 * Just 7
01:26:29 <jle`> yeah, exactly
01:26:35 <jle`> the type signature of <$> should give it away
01:26:42 <jle`> (<$>) :: (a -> b) -> (f a -> f b)
01:27:10 <jle`> so what you can do if you want to multiply two Just values
01:27:16 <jle`> is apply (*) to Just 3
01:27:28 <jle`> if you do (*) <$> Just 3, you get Just (*3)
01:27:42 <jle`> and then you can use <*> to apply functions inside applicatives
01:27:46 <jle`> :t (<*>)
01:27:47 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:28:03 <jle`> so Just (*3) <*> Just 7   = Just 21
01:28:33 <jle`> > (*) <$> Just 3 <*> Just 7
01:28:34 <lambdabot>  Just 21
01:28:40 <zol_> Wow
01:28:48 <jle`> it's important to remember the association
01:28:53 <zol_> That will  take some practice to get accustomed to
01:28:58 <jle`> > ((*) <$> Just 3) <*> Just 7
01:28:59 <lambdabot>  Just 21
01:29:15 <jle`> you might have seen this sort of functionality before in the form of lift2 etc. functions
01:29:36 <jle`> > liftA2 (*) (Just 3) (Just 7)
01:29:37 <lambdabot>  Just 21
01:29:41 <zol_> I just read about lifting the other day, so I have not used any lifting functions before :/
01:29:56 <jle`> but using <$> and <*> lets you do arbitrary liftA3,4,5,6,7...etc.
01:30:05 <jle`> by taking advantage of partial application and currying
01:30:08 <jle`> ah, no problem :)
01:30:21 <jle`> there's a nice blog entry by tekmo that is about similar things
01:30:29 <jle`> http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
01:30:54 <jle`> basically, a nice way to look at haskell is that you have a bunch of data types that abstract over things
01:31:04 <jle`> maybe at different levels
01:31:21 <jle`> and what you can do is find a 'lowest common denominator'...and then lift everything you do to 'that level'
01:31:29 <jle`> so let's say your entire program lives in a Maybe
01:31:36 <jle`> you can use normal functions on your Maybe things, just by lifting
01:31:41 <jle`> so normal functions can live in your Maybe world too
01:31:56 <mniip> bro, do you even lift
01:32:05 <zol_> mniip: :D
01:32:08 <Walther> :Z
01:32:11 <jle`> :P
01:32:11 <Walther> :D*
01:32:20 <mniip> :Ь
01:32:30 <jle`> anyways so the whole 'trick' in haskell then is to just...find a way to lift everything to the level you want it :)
01:34:12 <Lethalman> and the other trick is to find the most simple abstractions that let you do the work easily
01:34:14 <Lethalman> imo
01:35:07 <Lethalman> at least I find myself often using complex stuff because I created the wrong abstractions
01:41:24 <no-n> how does readFile work about closing files?
01:41:48 <Athas> no-n: closed by the garbage collector, more or less.
01:42:00 <no-n> ok
01:48:16 <no-n> @hoogle FilePath -> IO Bool
01:48:16 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
01:48:17 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
01:48:17 <lambdabot> System.Posix.Files fileExist :: FilePath -> IO Bool
01:56:57 <zol_> http://hastebin.com/cucebibalo.haskell I'm getting this error when compiling, but it works in GHCi
01:58:03 <zol_> Fixed it
02:05:18 <zol_> Is it possible to do a pattern match guard like "| 0 <= levels <= 20 = 5 * levels" ?
02:05:43 <zol_> Or will I have to split the boolean expression out?
02:05:56 <Cale> That looks like a type error
02:06:43 <Cale> oh, no, it's just plain syntactically incorrect, because <= is non-associative
02:06:47 <predator217> how about | levels `elem` [0..20] = 5 * levels
02:07:29 <Cale> Yeah, or define  beteween a b x = a <= x && x <= b
02:07:39 <Cale> typo
02:07:47 <Cale> between a b x = a <= x && x <= b
02:10:17 <darthdeus> anyone here using simple.cx? I've just found that it uses wai-handler-devel (http://hackage.haskell.org/package/wai-handler-devel), which seems to be deprecated in favor of yesod-bin, though that seems to be doing something completely different no?
02:10:45 <darthdeus> I mean my understanding is that wai-handler-devel allows to reload any WAI compatible app, while yesod-bin is just something yesod uses to manage it's apps, no?
02:11:31 <adas> s :: Show a => a; s = "string" does not work. Why? isn't the [Char] type an instance of the class "Show"?
02:12:09 <jle`> adas: your type signature is too generic
02:12:11 <jle`> for what it is
02:12:24 <jle`> when you say s :: Show a => a
02:12:29 <jle`> you mean that s can return *any* Show
02:12:47 <Cale> (of the user's choosing, not s's choosing)
02:12:48 <jle`> but when you say s = "string"...s can only return a String.  (or an IsString if you have overloaded strings on)
02:13:09 <jle`> yeah, the user can choose to have s be any Show they want
02:13:21 <jle`> i should be able to do x = s :: Int
02:14:37 * hackagebot hackport 0.4 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.4 (SergeiTrofimovich)
02:17:35 <adas> since saying "s :: Show a => a" means s can return any Show and since making s = "string" only returns a string, it doesn't typecheck. am i correct?
02:19:20 <haasn> s can be any ‘a’ that is an instance of Show
02:19:25 <haasn> otherwise yes that sounds sound
02:19:36 <haasn> technically, ‘a’ is rigid because it has to be polymorphic, so it can't unify with String
02:20:15 <adas> i think i kinda get it. saying something like "s :: Show a => a" means that 's' should be able to return any type that is an instance of 'Show' .. but when define s = "string", I am contradicting my type specification since the type says it can return anything thats an instance of 'Show' and definition only returns a 'String'?
02:20:55 <haasn> ‘s’ is not (necessarily) a function; it doesn't *return* anything - it is
02:21:15 <jle`> well you can also think of it as a function that takes a method dictionary
02:21:28 <adas> haasn: return is the worong word to use .. yes
02:21:37 <jle`> but yeah, you can also think of it as 'i can ask s to be anything that is Show'
02:25:09 <adas> so i guess, the take away is that for a type "s :: Show a => a" ........................... 'a' can never be a String, Bool, Char, Int, Integer. Does that mean, I can never create a useful binding for 's' unless it returns an 'a' which is an instance of 'Show'
02:25:52 <adas> so i should be able to do something like "s :: Show a => a; s = ("string" :: Show a => a)"
02:25:59 <adas> not sure if thats even syntactically valid
02:26:16 <haasn> ‘a’ can of course be instantiated to any of String, Bool, Char, Int, Integer, etc.
02:27:01 <jle`> i can't think of a non-bottom possible definition of s, hm
02:27:33 <jle`> i don't think one can exist
02:28:30 <haasn> adas: what you wrote is “syntactically” correct, but of course it doesn't type check - for the same reasons
02:28:44 <haasn> Yes, I agree with jle`, I can't think of any definition for ‘s’ other than bottom
02:29:02 <adas> is 'undefined' a valid bottom?
02:29:10 <haasn> yes, absolutely
02:29:17 <haasn> s = undefined -- is perfectly valid
02:29:17 <jle`> @src undefined
02:29:17 <lambdabot> undefined =  error "Prelude.undefined"
02:29:23 <jle`> yup
02:29:28 <haasn> so is s = s; and s = error "whatever"
02:29:37 <jle`> but i can think of a few s :: Show a => a -> Int
02:29:43 <jle`> s :: Show a => a -> Bool
02:29:44 <jle`> etc.
02:30:05 <jle`> but s :: Show a => a ...
02:30:23 <adas> so saying something like "somefunc :: Show a => a" is a useless type because it has no useful or useable binding
02:30:25 <haasn> contra vs. covariant positions of ‘a’
02:30:38 <haasn> adas: yes; like :: a -> b
02:30:38 <jle`> useless type?
02:30:42 <jle`> ah yeah
02:30:45 <jle`> in that sense.
02:30:46 <haasn> or :: a
02:31:48 <haasn> ‘a’ never occurs in a covariant position in the methods of ‘Show’, so there can be no possible way other than bottom to generate an arbitrary ‘a’ given just the methods of Show
02:32:46 <adas> does that mean that it is good practice to ...  unless you exactly know the type of your function, its better to write the function first and then let haskell determine the type at which point you can annotate the function?
02:33:05 <jle`> well
02:33:23 <haasn> I think opinions may be divided here. If you know precisely what function you want to write and you don't know what its type signature would be; sure, go ahead, ask GHC to infer it for you
02:33:24 <jle`> that's a very broad 'unless'
02:33:41 <haasn> But I think generally you have some specific type in mind when writing a function
02:33:42 <jle`> most of the time i approach it by trying to think of a type signature, then writing it
02:33:53 <jle`> i think it's rare that i have no idea what type i want
02:34:02 <jle`> but if i don't have any idea...then i can't give a type signature meaningfully anyway
02:34:15 <haasn> Usually I do the same; I have the type in my head when I want to implement something, or I automatically know what the type of the function I'm in the process of writing will end up as - but exceptions exist
02:34:40 <haasn> For example, when writing something involving heavy usage of lens or diagrams in an abstract way, I often don't immediately know what the exact context etc. on the result will be, but I know that the code expresses the right thing
02:34:55 <MP2E> agreed, I feel like the type definition allows me to 'gather my initial thoughts' so to speak
02:35:00 <MP2E> think about what I'm actually *doing*
02:35:36 <MP2E> hehe the beauty is, ghc usually catches glaring logic errors before it ever compiles
02:42:44 <no-n> @pl write xs = WriterT . return . (,xs)
02:42:44 <lambdabot> (line 1, column 11):
02:42:44 <lambdabot> unexpected " "
02:42:44 <lambdabot> expecting operator
02:45:40 <Iceland_jack> @pl write xs = WriterT . return . (\x -> (x, xs))
02:45:40 <lambdabot> write = ((WriterT . return) .) . flip (,)
02:45:59 <quchen> Is it considered bad style to use printf? It's fairly convenient, but only semi-typesafe.
02:46:23 <haasn> I think it's fine as long as you localize it
02:46:35 <companion_cube> why is it unsafe?
02:46:36 <haasn> and the type is well-defined as either IO () or String
02:46:52 <Iceland_jack> companion_cube: because it can fail at runtime?
02:46:56 <quchen> companion_cube: Well, it produces something like runtime type errors,  printf "%d" "hello"
02:47:04 <haasn> companion_cube: printf "%d %s" "hello" 3 -- runtime error
02:47:06 <companion_cube> oh that's bad
02:47:20 <haasn> But you can use one of the TH-based alternatives to make it type-safe
02:47:37 <companion_cube> looks like OCaml is safer on this issue ;)
02:47:45 <quchen> On the other hand, this is like a non-checked type error. When a printf works once, it should always work.
02:47:50 <quchen> But that's rather informal of course.
02:47:55 <Iceland_jack> Looks like C + modern compilers is safer on that issue!
02:48:26 <nicoo> Iceland_jack: Isn't it only a warning that gets issued ?
02:48:45 <Iceland_jack> Yes
02:48:55 <quchen> Anyway, here is why I asked the first question: to not get yelled at for the next one.
02:49:19 <quchen> Would it be a worthwhile suggestion to make PrintfType an exported typeclass? It's really annoying that you cannot printf Text, for example.
02:49:55 <haasn> As long as you promise me nobody is going to write a PrintfType ByteString instance with .Char8 semantics.
02:50:12 <quchen> Haha
02:50:46 * quchen used BS8 the other day and still feels dirty
02:51:02 <nicoo> quchen: BS8 ?
02:51:07 <quchen> ByteString.Char8
02:51:10 <nicoo> Ah
02:51:17 <nicoo> Indeed
02:51:29 <quchen> But I imported it very qualified ;-) https://github.com/quchen/hackage-graph/blob/master/src/MakeGraph.hs#L6
02:52:10 <lukky513> someone knows about at least a blog post concerning how performant is Haskell on low-level? (eg. branch and cache misses)
02:52:35 <nicoo> quchen: Ahahah
02:55:10 <Lethalman> lukky513, you better search for ghc instead of haskell
02:55:17 <Lethalman> ghc cache misses show some results
02:55:18 <lukky513> Lethalman: makes sense
02:56:32 <Lethalman> lukky513, also https://github.com/ghc/nofib
02:59:01 <lukky513> Lethalman: yeah, well, I rather wanted a wider overview, cause I don't exactly have much code to test :)
02:59:51 <lukky513> something about how well naive implementations of common problems behave in different languages
03:00:00 <lukky513> I don't have anything specific in mind, though
03:00:11 <merijn> lukky513: I don't know specifically about branch/cache misses, but this post was interesting from a low-level performance point of view: http://neilmitchell.blogspot.nl/2014/01/optimising-haskell-for-tight-inner-loop.html
03:01:03 <lukky513> merijn: looks promising, thanks
03:07:10 <jle`> is there a meaningful way to check if a value is an error
03:07:12 <jle`> inside IO
03:07:19 <jle`> it's kinda hacky but it will be hidden behind many layers of abstraction >.>
03:08:08 <jle`> basically i have a value inside an MVar
03:08:13 <jle`> which might actually be an error
03:08:17 <jle`> and i want to branch on if it is or not
03:08:26 <jle`> *an exception
03:15:36 <jle`> this is a very bad idea
03:26:28 <quchen> jle`: Evaluate it in a catchall block?
03:26:42 <jle`> oh i used `try . evaluate`
03:27:32 <quchen> try (readMVar >>= evaluate)
03:28:46 <jle`> ah yeah, that.
03:28:49 <jle`> this all feels so wrong though
03:28:53 <jle`> :/
03:28:59 <quchen> As it should! :-þ
03:29:14 <jle`> but i just need that implicit 'null' >.>
03:29:20 <haasn> Lethalman: do you know if that includes a test for (block-buffered) I/O performance?
03:29:28 <haasn> I made some modifications to that code a while ago that I'd really like to test properly
03:29:46 <Lethalman> no idea
03:31:08 <solo_tj> can some one please help me how can i right java codes and put it in a cd
03:31:23 <arboris_> what are my options if I want to use a half-edge data structure in haskell?
03:38:47 <pyon> @hoogle Arrow a => (c -> d) -> a b c -> a b d
03:38:48 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
03:38:48 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
03:38:48 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
03:38:50 <kcc> @pl \x y -> sqrt (x * x + y * y)
03:38:51 <lambdabot> (sqrt .) . (. join (*)) . (+) . join (*)
03:39:01 <jle`> yes do that.
03:39:06 <anon_555> myCompare :: (Ord a) => a -> a -> Ordering a 'myCompare' b 	| a > b = GT 	| a == b = EQ 	| otherwise = LT
03:39:12 <anon_555> what is error in this
03:39:27 <jle`> anon_555: you probably want `myCompare`
03:39:30 <jle`> with backticks
03:39:45 <jle`> also, i'm sure you meant to put a semicolon/new line somewhere there
03:39:51 <pyon> right after Ordering
03:40:54 <anon_555> jle` it worked but what parameter i should pass
03:41:02 <daniel-s> Are there practical reasons to learning lambda calculus outside of computer science specifically?
03:41:22 <jle`> anon_555: what
03:42:17 <heaumer_> daniel-s: mathematics, fun
03:43:08 <pyon> daniel-s: to understand functional programming? (most programming, even functional programming, has nothing to do with "computer science")
03:54:21 <haasn> break f = span (not . f) ?
03:54:32 <haasn> oh, yes
04:03:00 <kcc> Is this a good way of getting sqrt only for Integral? intSqrt n | testval * testval == n = Just testval | otherwise = Nothing where testval = floor . sqrt . fromIntegral $ n
04:03:37 <haasn> @hoogle integerSquareroot
04:03:37 <lambdabot> No results found
04:03:40 <haasn> @hoogle integerSquareRoot
04:03:41 <lambdabot> No results found
04:03:46 <haasn> http://hackage.haskell.org/package/arithmoi-0.4.0.4/docs/Math-NumberTheory-Powers.html#v:integerSquareRoot
04:04:32 <haasn> looks like that's sort of what arithmoi does; computes an approximate sqrt using floating point and then finds an exact result by basing its guesses off that
04:05:07 <haasn> kcc: your method is imprecise though
04:05:20 <kcc> So it would fail for very large numbers I guess?
04:05:26 <haasn> Yeah
04:06:17 <haasn> > floor . sqrt . fromIntegral $ 10^500
04:06:18 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
04:06:40 <kcc> Indeed
04:06:48 <haasn> > floor (1/0) -- yuck
04:06:49 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
04:06:55 <aristid> haha
04:07:12 <aristid> > floor (0/0)
04:07:14 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
04:07:18 <aristid> hahahaha
04:07:43 <hpc> aristid: you'll love the reason it does that
04:07:44 <aristid> > floor (0/0) == floor (-1/0)
04:07:45 <lambdabot>  False
04:07:52 <aristid> hpc: do tell
04:08:08 <hpc> NaN and the infinities have their own particular binary representations
04:08:15 <hpc> with specific values of exponent and mantissa
04:08:29 <hpc> but if you don't take those into account, and continue using the same bitwise ops as for normal numbers....
04:08:29 <aristid> hpc: ah it just uses the binary representation as if it was a standard number? hah
04:08:43 <hpc> > floor (0/0) - floor (-1/0)
04:08:45 <lambdabot>  -898846567431157953864652595394512366808988489471153286367150405788663379027...
04:08:56 <kcc> There's more than one NaN, at least in C, like quiet and signaling
04:09:10 <aristid> there's 2^52 of them iirc
04:09:22 <hpc> yeah, there's loads of NaNs, one infinity of each sign
04:10:00 <aristid> iirc it's just an all-1 exponent, for all these special values
04:10:13 <hpc> 2^52 - 2
04:10:19 <hpc> max exp, non-zero mantissa
04:10:32 <hpc> the infinities are max exp, zero mantissa, and the sign bit is which infinity is which
04:11:00 <Rarrikins> NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN Batman!
04:11:06 <hpc> and there's 52 bits of mantissa
04:11:53 <hpc> er, so 2^53-1 NaNs
04:12:01 <hpc> because the sign bit counts, woo!
04:12:07 <aristid> ah so you can use the sign bit too hah
04:12:24 <hpc> -2
04:12:43 * hpc shouldn't ieee754 so early in the day
04:13:01 <aristid> don't drink and ieee754, also
04:19:52 * hackagebot temporary 1.2.0.2 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.2.0.2 (MaxBolingbroke)
04:22:26 <Yuu_chan> > show $ 0 / 0
04:22:27 <lambdabot>  "NaN"
04:23:40 <Yuu_chan> concatMap show (replicate 15 $ 0 / 0) ++ " Batman!"
04:23:46 <Yuu_chan> > concatMap show (replicate 15 $ 0 / 0) ++ " Batman!"
04:23:47 <lambdabot>  "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!"
04:25:59 <mniip> > (++" Batman!")$concatMap show$[1..15]>>[0/0..]
04:26:00 <lambdabot>  "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN...
04:26:23 <mniip> Oh wait
04:26:30 <Iceland_jack> > ['a'..] ++ "help me!"
04:26:31 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
04:26:51 <mniip> > (++" Batman!")$concatMap show$[1..15]>>[0/0] --there
04:26:52 <lambdabot>  "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!"
04:32:08 <_ikke_> How can I change this so that I can just return an empty [] on line 2? Otherwise I get an exception when trying to execute head on an empty list
04:34:48 <_ikke_> Sorry, link: http://lpaste.net/102290
04:35:51 <quchen> _ikke_: Don't use head/tail, pattern matching is usually a much better alternative. See also https://github.com/quchen/articles/blob/master/fbut.md#dont-use-
04:37:03 <Iceland_jack> _ikke_: you may be interested in the function 'break'
04:37:04 <Iceland_jack> @ty break
04:37:05 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
04:37:11 <Iceland_jack> > break (== '\n') "hello\nworld"
04:37:13 <lambdabot>  ("hello","\nworld")
04:37:47 <Iceland_jack> I assume you're already aware of the function 'lines' that does the same thing
04:37:52 <Iceland_jack> > lines "hello\nworld"
04:37:53 <lambdabot>  ["hello","world"]
04:37:59 <_ikke_> Iceland_jack: I suspected something exists, but I found it a nice excercise
04:38:03 <haasn> [c] ++ x is c : x
04:38:12 <Iceland_jack> _ikke_: Good!
04:38:16 <haasn> absolutely use pattern matching instead of head/tail
04:39:25 <b0bbi10> 5
04:39:34 <mniip> Wat
04:39:38 <Iceland_jack> mniip: 5
04:39:52 <mniip> Yeah
04:39:55 <haasn> don't mind him, he's just conting down the days until the world ends
04:39:56 <_ikke_> How do I use pattern matching in this case?
04:40:27 <haasn> _ikke_: I would suggest changing line 6 to “where (h:t) = splitNl s” and then using h and t instead of “head r” and “tail r”
04:40:43 <_ikke_> haasn: Ah, like I suspected
04:40:46 <_ikke_> haasn: thanks
04:41:15 * mniip takes notes
04:41:20 <Iceland_jack> _ikke_: another approach is to use an auxiliary function for collecting all the list up until the newline, and the rest of the list
04:41:36 <Iceland_jack> (rest of the list, not including the newline)
04:41:38 <_ikke_> Irrefutable pattern failed for pattern (h : t)
04:42:15 <haasn> Hmm. I don't understand how that is possible; all cases of splitNl return a (:)
04:42:48 <_ikke_> http://lpaste.net/102290
04:43:02 <Iceland_jack> Not anymore
04:43:02 <Iceland_jack>     splitNl "" = []
04:43:39 <haasn> I don't see that, for some reason
04:43:41 <_ikke_> Yeah, if I change that back, it works
04:43:48 <haasn> Oh, now I do
04:44:23 <mniip> Is it a bad style to write "" like [] ?
04:44:27 <haasn> _ikke_: then you need to think about what your logic is and what your function really should be doing; if the irrefutible pattern failed then it just means “head” and “tail” would have crashed as well - but with less informative error messages
04:44:59 <Iceland_jack> mniip: If you're defining a function only for strings you may as well use ""
04:45:30 <_ikke_> haasn: I understand why the error happens. It tries to split an empty string in two, which fails obviously
04:45:41 <mniip> Yeah, my question is whether is [] acceptable in ""'s place
04:46:03 <Iceland_jack> It doesn't really matter, but I wouldn't do it
04:46:05 <_ikke_> It is iirc
04:46:26 <_ikke_> just like [[], ""] is acceptable
04:46:39 <Iceland_jack> _ikke_: I don't think mniip is asking whether it works or not
04:46:46 <Iceland_jack> > [] :: String
04:46:47 <lambdabot>  ""
04:46:54 <mniip> _ikke_, stylistically, not syntactically
04:47:00 <_ikke_> right
04:47:44 <Iceland_jack> writing "" contains more information than []
04:48:50 <mniip> I prefer [] over "" just like you write 1 intead of (1::Int)
04:49:07 <mniip> (Except some very obscure places)
04:49:09 <haasn> (Is it possible that "" is ambiguous in the presence of OverloadedStrings but [] is not?)
04:49:27 <Taneb> @type ""
04:49:28 <lambdabot> [Char]
04:49:44 <Taneb> haasn, I think if you deal with, say, mappend
04:49:58 <haasn> mniip: I think 1 vs (1::Int) is mainly a question about length, before clarity
04:50:01 <haasn> "" and [] have the same length
04:50:07 <Fuuzetsu> pretty sure defaulting takes care of any ambiguous cases
04:50:17 <Iceland_jack> Yes, 1 v. (1::Int) are not comparable
04:50:28 <Hafydd> splitNL ""          = [""]
04:50:29 <Hafydd> splitNL ('\n' : s)  = "" : splitNL s
04:50:29 <Hafydd> splitNL (c : s)     = (c : h) : t where h:t = splitNL s
04:51:39 <_ikke_> Hafydd: Ah, that's a nice approach too
04:53:53 <Iceland_jack> _ikke_: for comparison
04:53:55 <Iceland_jack> @src words
04:53:55 <lambdabot> words s = case dropWhile isSpace s of
04:53:55 <lambdabot>     "" -> []
04:53:55 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
04:56:22 <_ikke_> :t words
04:56:23 <lambdabot> String -> [String]
04:58:00 <augur> _ikke_: why are you always so negative?
04:58:08 <augur> 8D
05:16:22 <vozz> How do you take four Chars or bytes and return a signed integer?
05:18:43 <Fuuzetsu> f _ _ _ _ = 1
05:18:48 <Fuuzetsu> ;)
05:19:26 <vozz> ha :) not quite what I'm looking for
05:19:27 <Lethalman> vozz, maybe Data.Binary
05:20:05 <Lethalman> vozz, your char list is the ByteString, then you get an Int
05:20:19 <Lethalman> vozz, this: http://hackage.haskell.org/package/binary-0.3/docs/Data-Binary.html#v%3Adecode
05:22:04 <vozz> Lethalman: How will decode know to return an Int32 rather than four chars?
05:22:24 <vozz> hm, i mean other than some other 4 byte long structure
05:22:43 <_ikke_> How come I cannot import things like Text, Text.Regex etc. It says could not find module `Text`
05:22:46 <_ikke_> (ghci)
05:23:08 <_ikke_> ghc-pkg find-module Text returns /usr/lib/ghc-7.6.3/package.conf.d
05:24:01 <Fuuzetsu> _ikke_: is text in your ghc-pkg list?
05:24:13 <Fuuzetsu> also, it's Data.Text
05:24:36 <_ikke_> Fuuzetsu: It isn't
05:24:58 <Fuuzetsu> it isn't there or it isn't Data.Text?
05:25:03 <Fuuzetsu> cabal install text
05:25:06 <_ikke_> the former
05:26:26 <vozz> Ah, you just add a type declaration to the statement, awesome
05:26:30 <vozz> Thanks a ton Lethalman
05:35:13 <vozz> Anyone familiar with Parsec or Attoparsec? If i've got a parser, and ByteString to parse with a load of junk data at the beginning then the thing I want to parse, how do I run the parser on it so it keeps trying until it gets a match?
05:38:30 <klrr_> vozz: maybe try skipMany
05:38:38 <klrr_> http://hackage.haskell.org/package/attoparsec-0.11.2.1/docs/Data-Attoparsec-Combinator.html
05:41:24 <vozz> klrr_: thanks :)
05:54:47 <skypers> hey
05:54:51 <skypers> I have a general question
05:55:05 <skypers> let’s say I have a few values with a big memory cost
05:55:58 <skypers> I want to put those values in a collection – e.g. a Vector – and use them in external computations ; sometimes I want to change those values (alter,delete,add,and so on). ; is it FRP related?
05:56:18 <skypers> at first, I thought I could “register” values
05:56:21 <skypers> and then use index
05:57:16 <skypers> like adding it and returning a wrapper over the size
05:57:44 <skypers> the issue with that is 1. not really elegant and 2. it depends on the container, if it changes it breaks all objects
05:57:51 <skypers> then if I introduce FRP
05:58:28 <skypers> I can put my object in a container in the monad, and provide a way to access them with a reactive value
05:58:31 <skypers> what do you think?
05:58:51 <Kiryx> Do variables in haskell need to be 2 characters or longer ?
05:58:59 <sipa> no
05:59:07 <Kiryx> let p = [2,3,5,7,11]
05:59:28 <Kiryx> ahhh
05:59:30 <Kiryx> nevermind :)
06:00:18 <skypers> (also, I don’t want to use IORef, it’s nasty to me)
06:00:44 <Kiryx> I used "let" in a script outside ghci
06:01:35 <skypers> > let p = "p" in p
06:01:37 <lambdabot>  "p"
06:10:05 * hackagebot casadi-bindings 1.9.0.0 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-1.9.0.0 (GregHorn)
06:10:07 * hackagebot quickcheck-io 0.1.1 - Use HUnit assertions as QuickCheck properties  http://hackage.haskell.org/package/quickcheck-io-0.1.1 (SimonHengel)
06:10:16 <no-n> :t exitWith
06:10:17 <lambdabot> Not in scope: `exitWith'
06:10:21 <no-n> >_>
06:12:33 <Rarrikins> @hoogle exitWith
06:12:34 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
06:12:47 <Rarrikins> no-n: ^
06:15:23 <no-n> ty
06:15:31 <no-n> @hoogle exitFailure
06:15:32 <lambdabot> System.Exit exitFailure :: IO a
06:15:32 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
06:21:53 <Kiryx> Hey, what's the "stop" criterion of a list range ?
06:22:28 <Kiryx> e.g. why does this [0.1, 0.3 .. 1.0] have 1.099999
06:22:33 <Kiryx> as the last value
06:22:41 <Kiryx> nevermind the floating point inaccuracies
06:22:57 <Kiryx> does it first create an element, append it and terminate when it's >= than the end of the range ?
06:23:43 <Lethalman> > [0.1, 0.3 .. 1.0]
06:23:45 <lambdabot>  [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
06:23:56 <Lethalman> that's unexpected to me
06:24:25 <int-e> Kiryx: because [a,b..c] stops at the last value smaller than c + (b-a)/2.
06:24:52 <int-e> Kiryx: which, presumably, was done so that [0.1,0.3..1.1] would reliably include 1.1
06:25:04 <kcc> > [1%10,3%10..1]
06:25:05 <lambdabot>  [1 % 10,3 % 10,1 % 2,7 % 10,9 % 10,11 % 10]
06:25:18 <shachaf> Cale: Yes, I meant the monoidal category of endofunctors with (:*:) as the product.
06:25:48 <int-e> the Enum instances of floating point types and Rational is a wart.
06:26:34 <shachaf> Cale: Which is just as legitimate a product as composition.
06:26:48 <kcc> > [1,3..10]
06:26:50 <lambdabot>  [1,3,5,7,9]
06:28:13 <Maxdamantus> You can't represent 0.1 with binary floats.
06:28:36 <Maxdamantus> or 0.2
06:29:19 <Maxdamantus> it rounds it to some repeated binary number, but it's only repeated a finite number of times.
06:29:24 <Taneb> Or any number that isn't a finite sum of integer multiples of an integer powers of 2
06:29:36 <kcc> But Rational should be arbitrary precision
06:29:46 <Taneb> Rational is any rational number
06:30:06 <Taneb> It uses Integer, which is arbitrary precision
06:31:27 <kcc> I still couldn't quite grok the discrepancy between [1,3..10] and [1%10,3%10..1]
06:31:42 <kcc> Did I miss something?
06:32:01 <geekosaur> the Enum instance is weird
06:32:18 <Kiryx> kcc: I try to find an explanation for that as well
06:32:18 <vozz> How do I make a parser fail? I want to parse a char, return something if it matches a condition, and fail otherwise
06:32:43 <TheKing42> what you parsing with?
06:32:57 <geekosaur> most parsers are monadic so the Monad `fail` mechanism works
06:33:36 <vozz> Attoparsec, I'll try using fail
06:41:25 <ThatTreeOverTher> I'm trying to write an application that uses wxHaskell, but linking fails... can anyone be of help?
06:42:46 <banister> ThatTreeOverTher if you believe in yourself u can do anything
06:43:01 <TheKing42> Does it give an error message?
06:43:35 <ThatTreeOverTher> banister, that's really insightful. I feel better now... I'd still like help though :)
06:43:41 <ThatTreeOverTher> TheKing42, it looks like this: http://lpaste.net/102293
06:43:47 <kcc> Kiryx: I think I found something: the enumFronThenTo function from the Enum class internally uses (/) which is defined for Fractional; I guess in the end the discrepancy between [1,3..10] and [1%10,3%10..1] is still due to imprecise floating point numbers
06:44:27 <TheKing42> what if you just try runhaskell?
06:45:06 <Earnestly> ThatTreeOverTher: fwiw: http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/problem-report-standard-litany.html
06:45:07 <Kiryx> kcc: I know very little haskell to confirm that :)
06:46:03 <ThatTreeOverTher> TheKing42, runhaskell just sits there... and doesn't appear to do anything... but `ghci -library wx` does this: http://lpaste.net/102294
06:46:04 <kcc> Kiryx: guess we can only hope for the days when (/) returns Rational, just like a plain integers gets Integer, not Int
06:46:08 <Kiryx> I expected floating point inaccuracies in the intermediary terms, but not reaching a value outside the scope
06:46:55 <TheKing42> maybe try reinstalling it with cabal?
06:47:41 <favetelinguis> anyone that has gotten haskell mode to work in lighttable?
06:47:54 <ThatTreeOverTher> TheKing42, it reinstalled successfully, but the linking still fails
06:48:57 <ThatTreeOverTher> someone told me yesterday to add "/usr/local/lib" to my /etc/ld.so.conf file because other things weren't working but now it doesn't even link
06:50:07 <kcc> Kiryx: That's because the last value is technically 1.0999999999999999, which according to the definition of enumFromThenTo should be taken, since it fulfills (<=c + (b-a)/2) as mentioned by int-e just now
06:55:16 <nh2> with Unboxed vectors: " In particular, unboxed vectors of pairs are represented as pairs of unboxed  vectors. " - why is this?
06:55:30 <nh2> why can I not just make an unboxed record and store 1000 of them sequentially in memory?
06:59:06 <nh2> ThatTreeOverTher: what is the error message when you build with cabal?
06:59:48 <ThatTreeOverTher> nh2, cabal doesn't give an error message, but rather ghc does: http://lpaste.net/102293
07:00:11 <TheKing42> could we see your code?
07:00:16 <Kiryx> kcc: I see, the end condition (c + (b-a)/2) is simply an odd one to fix on when designing the range
07:00:38 <geekosaur> ThatTreeOverTher, I did not see last night why you have a wx installed in /usr/local
07:00:42 <ThatTreeOverTher> TheKing42, nh2: http://lpaste.net/102296
07:00:43 <geekosaur> that did not come from pacman, did it?
07:00:53 <haasn> nh2: unboxed vector types are abstracted over by a data family Vector :: * -> *; if you want to write an instance Vector (a, b) you'd have to somehow construct an internal representation for whatever ‘a’, ‘b’ are passed - but we have no idea what the Vector a representation looks like (it's abstracted by the data family)
07:00:58 <ThatTreeOverTher> geekosaur, nope, I compiled it myself
07:01:00 <haasn> at least that's my naive interpretation of things
07:01:12 <haasn> so the only thing we can do is write an instance where Vector (a,b) ~ (Vector a, Vector b)
07:01:26 <geekosaur> in general, you either get everything from pacman or get as little as possible from pacman (in this case ghc) and build everything else yourself
07:01:31 <TheKing42> what happens if you try to build up your program in ghci?
07:01:32 <geekosaur> anything else leads to weird errors
07:01:48 <TheKing42> (Like not run it directly, but recreate it in ghci)
07:01:53 <haasn> nh2: the only other option I see is building manual instances for Vector (Bool, Bool), Vector (Bool, Char), etc. etc.
07:01:57 <haasn> but that gets exponential
07:02:22 <ThatTreeOverTher> TheKing42, I'm currently reinstalling wx and wxc but trying to load ghci with wx did this: http://lpaste.net/102294
07:02:37 <nh2> haasn: but is that not only the case if I have type parameters like in your example `instance Vector (a, b)`? That shouldn't hold for instance Vector Point3D where Point3D is my unboxed Point3D !Int !Int !Int, should it?
07:02:55 <geekosaur> there is no `-library`
07:02:59 <geekosaur> did you mean `-package`
07:03:34 <TheKing42> from ghci, you could try tying "import Graphics.UI.WX"
07:03:58 <nh2> ThatTreeOverTher: which version of wx do you have installed on your computer? http://hackage.haskell.org/package/wx says the latest package "works with wxWidgets 2.9 only"
07:05:06 <nh2> haasn: or can I actually already do that and I just don't know it?
07:06:12 <haasn> nh2: I don't actually know; I think for that you'd have to write your own Vector instance
07:06:36 <haasn> I'm not actually sure how those work internally, hmm
07:07:04 <chrisdotcode> edwardk_: is it too late to go to Hac NYC?
07:07:06 <nh2> haasn: in http://stackoverflow.com/questions/10866676/how-do-i-write-a-data-vector-unboxed-instance-in-haskell it looks like for imple newtypes you can auto-derive everything - I'll see what happens if I use data instead
07:07:08 <ThatTreeOverTher> nh2, TheKing42, geekosaur, gimme a moment, i'm going to recompile everything
07:08:05 <edwardk_> chrisdotcode: ping sclv. he's the man with the plan
07:08:25 <chrisdotcode> thanks!
07:08:30 <nh2> I don't know for sure, but it seems to me the Vector API sucks. Everything is called "Vector": The Type class, the data family, the naive type
07:08:34 <chrisdotcode> sclv_: is it too late to go to Hac NYC?
07:08:34 <haasn> nh2: that just looks GND in action basing off the existing instances for Double
07:08:40 <djahandarie> NYC is so far away man
07:08:48 <chrisdotcode> sclv_: (I'm already registered)
07:09:01 <chrisdotcode> djahandarie: are you kidding? it's only 20 minuts away! ;)
07:09:17 <edwardk_> chrisdotcode: if you are registered then why do you need to ask?
07:09:42 <chrisdotcode> edwardk_: thought I might have already missed all the good stuff!
07:09:44 <haasn> nh2: looks like the instances are all newtypes for yet another Vector type
07:09:53 <edwardk_> the talks aren't until this afternoon
07:09:53 <haasn> from Data.Vector.Primitive!
07:10:03 <chrisdotcode> did I miss any good hacking?
07:10:12 <shachaf> djahandarie: It's only a four hour bus ride!
07:10:35 <edwardk_> nh2: the reason for the API is that it was intended that you could refactor your code to switch by just changing the import.
07:10:53 <edwardk_> nh2: i happen to dislike that kind of API, but i understand why some things are built that way
07:11:44 <haasn> nh2: I found http://hackage.haskell.org/package/primitive-0.5.2.1/docs/Data-Primitive-Types.html
07:12:00 <haasn> which seems to be what governs what primitive (and therefore unboxed) arrays can actually store internally
07:12:07 <haasn> and the tuple instance is just using multiple of those
07:12:34 <haasn> So it seems to me like if you want your type to be storable in an unboxed way, you'd somehow have to come up with a Prim instance for it?!
07:13:19 <haasn> That is, if you want things to be local
07:13:38 <nh2> edwardk_: but sure naming the typeclass like the type family won't help with that, and same for naming the type family like the non-family basic type doesn't either?
07:14:18 <haasn> array certainly loves to abuse qualified imports
07:14:25 <haasn> it doesn't help that every module exports Prelude names :)
07:14:50 <nh2> that the names are the same across Boxed, Unboxed and Storable is OK, but having 3x the same names for different type-level concepts in *each of them* gets close to violence
07:15:33 <athan> Hmm... I'm finding GADT's to be a bit weird, am I alone?
07:16:16 <athan> The thing that gets me is that you can then write functions that have case statements that return different underlying types than the GADT
07:16:24 <athan> so I'm just wondering what the type signature would be
07:16:37 <athan> for instance
07:17:07 <athan> data Foo a where Bar :: Int -> Foo Int; Baz :: Bool -> Foo Bool
07:17:26 <athan> derp :: Foo a -> a
07:17:52 <haasn> athan: if you pattern match on a GADT constructor you bring its constraints into context
07:18:02 <athan> derp (Bar a) = a + 5 {= ::Int =}
07:18:03 <haasn> athan: so in the body of, say, derp (Bar x) we have a ~ Int
07:18:12 <athan> derp (Baz a) = !a
07:18:14 <haasn> so it's fine to just return an int
07:18:19 <athan> hmmm!
07:18:22 <haasn> by !a do you mean not a
07:18:23 <athan> Now that's interesting
07:18:34 <athan> a ~ Int... hmm
07:18:38 <haasn> athan: note:
07:18:42 <athan> yeah sorry haha
07:18:44 <haasn> where Bar :: Int -> Foo Int
07:18:45 <haasn> is the same type as
07:18:51 <haasn> where Bar :: (a ~ Int) => a -> Foo a
07:19:04 <athan> Now that's interesting
07:19:16 <haasn> in effect, a GADT is just like an existentially quantified data constructor data Foo a = (a ~ Int) => Bar a
07:19:22 <athan> That means (~) is an equivalence constraint, correct?
07:19:24 <haasn> I think
07:19:25 <edwardk_> athan: consider that you couldn't have costructed a Baz with the type necessary to get it out as an Int
07:19:26 <haasn> athan: yes
07:19:33 <athan> And typeclasses just implement another qualification of the type?
07:19:48 <athan> hmm!
07:20:00 <haasn> typeclass constraints are also valid in contexts, not sure if that's what you were trying to say
07:20:16 <haasn> note: (~) is an equality constraint, not just an equivalence constraint
07:20:27 <haasn> that might be nitpicking, though
07:20:31 <athan> yeah, I think I was
07:20:34 <haasn> but for example Int is not ~ Sum Int
07:20:35 <athan> ahhhh
07:20:36 <athan> hmm
07:20:45 <haasn> (even though newtype Sum a = Sum a)
07:20:58 <athan> hmm
07:21:12 <athan> where (~) only works with sum types, not a product like Sum a?
07:21:18 <athan> ie
07:21:30 <athan> newtype Dummy a = DummyProduct a
07:21:41 <haasn> I'm not sure what you mean by that
07:21:42 <athan> that wrapper would fail the equality?
07:22:03 <athan> well, from my understanding, Sums are Eithers, and Products are Tuples
07:22:03 <haasn> a ~ b just says that “a” and “b” are precisely the same type; you can rewrite them into eachother without changing any semantics
07:22:21 <haasn> what kind of type it is doesn't matter here, it's purely about the type system
07:22:22 <athan> so a 1tuple wrapped around Int would have Int ~ DummyWrapper Int fail
07:22:29 <athan> Oh!!!
07:22:34 <haasn> I was just emphasizing that newtypes introduce fundamentally distinct types
07:22:40 <haasn> that, while they may be “equivalent”, are not equal
07:22:43 <athan> They are _exactly_ same
07:22:47 <haasn> yes
07:23:03 <mizu_no_oto> How do you get profiling results from an executable built with 'cabal build'?  I already ran "cabal configure --enable-executable-profiling", but I'm having trouble figuring out how to get to the results
07:23:08 <athan> hmm
07:23:08 <haasn> for example, you can give ‘id’ this equally valid type signature:
07:23:12 <haasn> id :: (a ~ b) => a -> b
07:23:16 <athan> at the kind level they introduce the difference?
07:23:26 <haasn> kind level?
07:23:29 <athan> hmmm
07:23:33 <athan> that's interesting
07:23:43 <athan> actually nevermind, sorry
07:23:49 <athan> kinds classify possibly different types
07:23:51 <athan> my mistake
07:23:56 <haasn> yes
07:23:57 <athan> man, this is all very intersting
07:24:06 <haasn> the kind of (~) is a bit interesting
07:24:14 <haasn> (~) :: forall k. k -> k -> Constraint
07:24:16 <geekosaur> mizu_no_oto, I think you don't just automatically get profiling, you need to set some stuff in the RTS ($GHCRTS environment variable or +RTS option; try yourprogram +RTS --help)
07:24:17 <athan> I'm guessing it's like
07:24:19 <athan> YEAH!
07:24:21 <athan> hell yes!
07:24:35 <athan> now that's what I'm talking about hahaha
07:25:13 <athan> So only kinds of Constraint can qualify polymorphic arguments (which will be of kind *) in functions, correct?
07:25:25 <haasn> fwiw, I tried and it is indeed equivalent to the GADT: data Foo a = (a ~ Int) => Bar Int | (a ~ Bool) => Baz Bool
07:25:45 <athan> !!!
07:26:00 <haasn> athan: you mean kinds of (* -> Constraint)?
07:26:20 <athan> haasn: Ahhhhhhhhhhhh
07:26:25 <athan> perfection
07:26:27 <haasn> eg. (Show :: * -> Constraint); Int :: *; so Show Int :: Constraint
07:26:27 <athan> hmm
07:26:48 <athan> instances are of kind Constraint
07:26:50 <haasn> note:  f :: Show Int => String -- is perfectly valid; at least with FlexibleContexts
07:27:11 <athan> ahhhh wow
07:27:15 <haasn> athan: basically, yes; you need an instance to resolve a constraint
07:27:25 <haasn> athan: but instances aren't formally in the type system, nor do they formally have a “kind”
07:27:39 <athan> hmm!
07:27:42 <haasn> the Constraint is just there to tell GHC what instances it needs to resolve to type check every function
07:28:05 <athan> ahh, I see
07:28:07 <haasn> eg. the type of ‘show’, with all annotations:
07:28:10 <athan> that's where the contexts come into play?
07:28:21 <haasn> show :: forall (a :: *). (Show a :: Constraint) => a -> String
07:28:43 <athan> hmm!
07:28:44 <haasn> athan: yes, contexts allow you to introduce a constraint (of kind Constraint) into a type
07:29:07 <athan> hmm
07:29:24 <athan> like (Show Int) => String?
07:29:28 <haasn> Exactly
07:29:38 <athan> would that introduce the constraint _in_ the type String?
07:29:39 <haasn> Show Int :: Constraint; String :: *; and (Show Int => String) :: *
07:29:40 <athan> wow
07:30:17 <haasn> athan: well, the constraint is added - something of type (Show Int => String) is just a String, but in order to use it you need to satisfy the Show Int constraint
07:30:33 <athan> yeah hahha
07:30:37 <haasn> this is distinct from GADTs, where the constraint is on the constructor itself (formally: existential quantification)
07:30:42 <athan> you'd have to like... reverse the origionation of the data
07:30:43 <athan> or something
07:30:53 <athan> like... deduce the function that created the string :P
07:30:55 <haasn> the constructor for a GADT is sort of like “packaging up the data together with a constraint”
07:31:03 <athan> hmm!
07:31:14 <ThatTreeOverTher> nh2, TheKing42, geekosaur: trying to build up my program in GHCi does this: http://lpaste.net/102298
07:31:19 <athan> yeah, I can see there's a lot of sugar going on
07:31:27 <haasn> that's why the constraint is on the type constructor; eg. Bar :: (a ~ Int) => Int -> Foo a
07:31:32 <haasn> athan: definitely
07:31:43 <haasn> athan: though it may help to forget about constraint kinds and existential quantification and just take GADTs for what they are
07:31:50 <athan> ahhh, yes I can see
07:31:55 <haasn> this is just a trip down the rabbit hole of how it all desugars into the internal logic :)
07:31:56 <athan> naw
07:31:59 <athan> I need the depth haha
07:32:06 <athan> :D!
07:32:17 <haasn> athan: are you familiar with existential quantification in general?
07:32:21 <athan> fairly
07:32:23 <crodjer> How can I use a cabal sandbox with ghci?
07:32:37 <athan> hmm
07:32:44 <johnw> crodjer: "cabal repl", after setting up the sandbox?
07:32:50 <athan> it's interesting how the constraint's can be deduced from simply the type sig
07:32:50 <athan> Thanks,
07:32:50 <athan> Athan Clark
07:32:51 <athan> Peerless Network
07:32:51 <athan> Phone: 720-889-6789
07:32:51 <athan> Email: peeringsupport@peerlessnetwork.com
07:32:53 <athan> in GADTs
07:32:55 <athan> whoops
07:32:57 <athan> lol
07:33:02 <athan> I have a macro processor
07:33:09 <haasn> ‘sig’ :)
07:33:10 <athan> (please don't spam me)
07:33:12 <crodjer> johnw: But, that needs a .cabal file.
07:33:33 <athan> haasn: Have you ever gotten into Omega?
07:33:34 <crodjer> I am not really working in a package, but just writing scripts to learn haskell
07:34:05 <haasn> athan: that's a specialty for GADT syntax and it's really, really trivial: normally a type constructor looks like (Foo a b c d); so if the right hand side of a GADT-style constructor is -> Foo x y z w; we just add (a ~ x, b ~ y, c ~ z, d ~ w)!
07:34:08 <haasn> athan: Nope
07:34:36 <athan> hmm
07:34:37 <athan> wow
07:34:41 <athan> so it just term matches
07:34:48 <athan> You _may_ want to check it out...
07:35:04 <athan> I've heard (from LTU) that Omega : Haskell is like Haskell : Imperative
07:35:30 <athan> Omega : Dependent / H-M type systems
07:36:03 * haasn loves X:Y comparison
07:36:08 <athan> :D
07:36:16 <athan> relations...
07:36:24 <athan> (imagines Brian Griffin)
07:37:14 <haasn> athan: this one? https://code.google.com/p/omega/
07:37:32 <nh2> haasn: I put it up on http://stackoverflow.com/questions/22882228/how-to-store-a-haskell-data-type-in-an-unboxed-vector-in-continuous-memory - hopefully we will be enlightened
07:37:32 <athan> yep!
07:37:39 <athan> here, lemme find the LTU article
07:37:46 <athan> there's like... no info on it
07:38:01 <haasn> athan: hmm, judging by that description, it's like Haskell with stronger type-level facilities? IT doesn't seem to be fully dependent
07:38:06 <athan> I could only find a pdf manual from the teacher who invented it
07:38:14 <athan> I think you're right
07:38:17 <athan> not sure though
07:38:18 <athan> but
07:38:29 <haasn> athan: note that newer GHC-Haskell has really strong support for type level computations
07:38:30 <athan> I'm pretty sure microsoft is using it with Cw
07:38:34 <haasn> with some boilerplate
07:38:44 <athan> I believe it!
07:38:58 <haasn> you still have to write singleton types etc. by hand (though the ‘singletons’ library can derive and auto-lift a lot using TH)
07:38:58 <athan> does 7.8 have deriving (Applicative)?
07:39:11 <athan> hmm!
07:39:12 <haasn> Applicative can't possibly be derivable
07:39:16 <athan> :/
07:39:25 <haasn> Proof: ZipList and [] are both valid Applicative instances for []
07:39:28 <athan> http://lambda-the-ultimate.org/node/4088
07:39:44 <haasn> (although you could maybe come up with some “default” instance, I guess)
07:39:48 <S11001001> where's my deriving MonadTrans :)
07:39:49 <athan> Tim Sheard is the guy who made it
07:40:00 <athan> yeah :/
07:40:36 <athan> yeah that just sound abominable
07:40:39 <athan> hmm
07:40:45 <haasn> athan: GHC-Haskell also allows promoting (non-GADT) types to the kind level
07:41:10 <haasn> I'm not sure how much that agrees with his notion of “Extensible Kinds”
07:41:12 <athan> so equality relations are like the bread and butter that GHC uses when coercing types, too?
07:41:15 <haasn> I'm not familiar with the term
07:41:31 <haasn> athan: I guess so!
07:41:31 <athan> hmm
07:41:35 <athan> yeah I'm not sure
07:41:40 <athan> I think it's like an extensible record
07:42:18 <athan> but instead of extending the type + creating "member" functions, i think he extends the sort, and creates type families
07:42:26 <athan> or something like that hahaha
07:42:46 <athan> I'm pretty sure the type system is way different than the hierarchical system of H-M
07:42:57 <athan> like how dependent type systems are all just at one level
07:43:01 <haasn> Time to open the .ps :)
07:43:06 <athan> :D
07:44:42 <haasn> “Once a language has GADTs and extensible kinds it can support several closely related concepts such as Refinement Types[12,46,9], Guarded Recursive Datatype Constructors[42], Inductive Families[8,11], First-class phantom types[6], Wobbly types[17], Silly Type Families[1], and Equality Qualified Types[32,35].”
07:44:46 <haasn> Help, why don't I know any of these terms?
07:44:51 <haasn> I want to know what a silly type family is
07:45:04 <athan> :D
07:45:08 <athan> I wish I knew!
07:45:15 <athan> I literally just found out about it yesterday
07:45:23 <athan> on an idris adventure :)
07:46:18 <athan> I'm pretty sure this is "up there" with research topics lol
07:46:38 <haasn> Ωmega has a cute syntax for kinds; Term :: *0 ~> *0
07:46:45 <haasn> Or is that *O? I really can't tell :(
07:47:16 <athan> :/
07:47:25 <meretrix> If I have a foreign function that returns a CString, do I need to call "free" on the pointer when I'm done using it in order to avoid memory leaks? Or will the GC automatically clean it up?
07:47:34 <haasn> athan: Section 4 explains the GADTs are just equality constrainted types thing
07:48:23 <athan> :D!!!
07:49:35 <haasn> heh, and they use = for what we use ~ for
07:49:46 <athan> :P
07:49:50 <haasn> I wonder what = is in the GHC type system, is that even valid?
07:49:59 <haasn> Nope, parse error
07:50:08 <haasn> It's a reserved symbol
07:50:21 <athan> I think we use it, but traversing levels, with ::
07:50:34 <athan> hmm
07:50:39 <athan> that's a good question
07:50:43 <athan> I still haven't read it yet
07:50:52 <athan> I've just read the buzz
07:52:32 <haasn> athan: it looks pretty much exactly like what we have as DataKinds now :)
07:53:14 <haasn> athan: from what I'm seeing, it has the same kinds (it uses *0 for what we use * for), and only a single sort (it uses *1 for what we use BOX); nothing above that (other than trivial *2, *3, *4, etc. moving up)
07:53:34 <athan> oh!!!
07:54:02 <athan> hmm! Man, I had no idea
07:54:10 <athan> What could datakinds be used for?
07:54:15 <athan> And also, BOX?
07:54:20 <athan> what other sorts are there?
07:54:37 <skypers> how do you aggregate huge objects that are shared between several objects?
07:54:38 <haasn> none
07:54:45 <skypers> in C we’d use pointers for instance
07:54:49 <skypers> in Haskell, I have no idea
07:54:54 <haasn> athan: the haskell sort system is pretty degenerate; the last interesting things happen in the kind level
07:54:55 <skypers> I don’t want to use IORef
07:55:22 <athan> hmm
07:55:28 <athan> okay, well, I'll keep digging :)
07:55:49 <athan> skypers: Aggregate? You mean, share the contents?
07:55:53 <athan> are the objects files?
07:56:04 <skypers> I mean embed them in other ones
07:56:13 <skypers> share them
07:56:19 <athan> ahhh i see
07:56:23 <athan> "share the instances"
07:56:24 <athan> ?
07:56:56 <skypers> hm, I’m not sure about what your instances mean, but it’s quite transparent: you have one huge value you need from a lot of objects
07:57:13 <athan> hmm
07:57:18 <skypers> if you copy it in all objects, you’ll have several issues: memory cost, broken logic when the value is updated
07:57:21 <athan> are they all requesting it at once?
07:57:21 <skypers> and so on
07:57:28 <skypers> I guess FRP is a clue there
07:57:30 <athan> yeah
07:57:33 <athan> concurrency
07:57:50 <skypers> the issue is not concurrency
07:58:01 <skypers> it’s sharability
07:58:07 <athan> hmm
07:58:16 <skypers> I don’t know how to efficiently do that in Haskell
07:58:20 <athan> what is your parallelism model?
07:58:28 <skypers> I don’t have one yet
07:58:30 <athan> are all the objects requesting the data at once?
07:58:33 <athan> or sparatically?
07:58:38 <skypers> sequentially
07:58:43 <athan> ahhh....
07:58:44 <athan> man
07:58:50 <haasn> skypers: STRef maybe?
07:59:09 <skypers> gonna look into that direction
07:59:10 <skypers> for now
07:59:11 <haasn> what you want calls for mutability, because I can update one object somewhere and have its copy embedded into a totally different object (that I didn't touch) changed, too?
07:59:15 <skypers> I put my values in a Vector
07:59:21 <haasn> ST is like a constrained subset of IO that allows a pure runST :: ST a -> a
07:59:26 <skypers> and “represent” them through newtype Stuff = Stuff Int
07:59:32 <skypers> when the Int is the index in the vector
07:59:39 <haasn> there are mutable vectors for ST, too
07:59:42 <haasn> Ah
07:59:47 <haasn> I understand, yes
07:59:53 <haasn> You can model your own environment like that, too
07:59:57 <haasn> ST does it for you
08:00:18 <skypers> thank you haasn
08:00:20 <haasn> (I think using a Vector like that would be a valid implementation of ‘ST’. Of course, GHC's is much more efficient)
08:00:30 <skypers> what is ST for btw?
08:00:44 <haasn> mutation in pure contexts, basically
08:01:08 <skypers> I thought ST standed for state thread
08:01:11 <skypers> or something like that
08:01:22 <haasn> no, “state-transformer” I think
08:01:23 <athan> I think it's the lower level of State, right?
08:01:25 <athan> ahhhhh
08:01:36 <haasn> State transformation is how the mutation is modelled, basically; but it's at a much more primitive level than State
08:01:43 <haasn> athan: no, State is implemented with lambdas and tuples
08:02:00 <skypers> yeah
08:02:09 <athan> yeah that's what I imagined, haasn, I've seen it like that before. I've just also seen ST in the same contexts sometimes
08:02:13 <skypers> a State is a simple function
08:02:19 <haasn> skypers: have a look at http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-STRef.html#t:STRef for some of the API
08:02:20 <athan> hmm!
08:02:20 <skypers> s -> (s,a)
08:02:31 <skypers> thank you haasn
08:02:32 <johnw> ST lets you model state as a group of "mutable variables", STRefs, within a specific execution of the ST monad
08:02:33 <haasn> athan: maybe you've also seen STM? :)
08:02:42 <athan> ahh!
08:02:51 <johnw> STM is completely different, but in some ways like an ST where multiple concurrent executions can share the same TVars
08:02:52 <athan> yes :)
08:02:55 <skypers> STM is nothing related to that
08:03:01 <skypers> atomically ;)
08:03:20 <haasn> STM is a monad for providing atomic access to references
08:03:29 <haasn> and failure, I think
08:03:51 <skypers> is ST a very used Monad?
08:04:02 <athan> and failure? nice!!
08:04:03 <skypers> it sounds pretty good to me now
08:04:06 <haasn> I don't know. It can be good for in-place vector algorithms that need to be efficient
08:04:17 <athan> I've seen it a lot
08:04:27 <athan> yeah
08:04:38 <athan> I've heard it's really close to IORefs as far as efficiency
08:05:33 <skypers> well the idea is that a lot of my library relies on that kind of update
08:05:38 <athan> I'm gonna start playing with the Par monad here pretty soon, I'm really excited for that
08:05:46 <skypers> :)
08:05:55 <skypers> god, my cat’s trying to eat some bees
08:05:59 <haasn> I believe they're fairly equivalent in terms of underlying implementation; so equivalent in fact that stuff like mutable vectors tend to be parametrized over both.
08:06:00 <skypers> it’s gonna be a total mess :D
08:06:39 <athan> hmm!
08:06:50 <athan> haasn: STM and ST, you mean?
08:06:58 <haasn> No, ST and IO
08:07:02 <athan> ahh, oops
08:07:19 <haasn> ST is implemented pretty much the same way that IO is, except using type system trickery to make sure runST is pure
08:07:26 <haasn> (no state can escape the invocation)
08:07:31 <haasn> no state variables, that is
08:07:37 <athan> escape...?
08:07:41 <skypers> yeah
08:07:58 <athan> oh! I think I see
08:08:02 <skypers> ok hm
08:08:04 <haasn> athan: it's not possibly to, say, return a state variable in one computation; then plug that variable into a *different* computation and modify the result of the first one after the fact
08:08:08 <skypers> ST s a
08:08:15 <skypers> s is my group of varying variables?
08:08:31 <jrm> For emacs/haskell-mode users: Is there a way to send the current line or region to the repl?
08:08:35 <athan> ahh, yeah
08:08:42 <haasn> skypers: ‘s’ is polymorphic; when using the API you don't care what it is. But in an abstract sort of way, you can say that ‘s’ describes which variables that computation uses, yes
08:08:49 <athan> the mutations are encapsulated and atomicized
08:08:59 <haasn> athan: that's for STM!
08:09:01 <haasn> (atomicity)
08:09:04 <athan> hmm
08:09:07 <haasn> Well, I guess you could say ST is sort of atomic, too
08:09:09 <athan> while ST is wholesale?
08:09:10 <c_wraith> skypers: s is never actually any type.  That's sort of the point.  You can never have a value of type s
08:09:15 <skypers> I don’t really understand what s is
08:09:19 <haasn> ST being atomic or not doesn't really make any sense because it's pure
08:09:30 <athan> hmm!
08:09:31 <haasn> skypers: runST :: (forall s. ST s a) -> a
08:09:36 <athan> it's organizational
08:09:45 <athan> ahh!
08:09:46 <skypers> is it mandatory?
08:09:49 <haasn> skypers: you have to write your code for any ‘s’, and the runST implementation gets to pick it
08:09:59 <skypers> I see
08:10:05 <skypers> I read it can pass RealWorld
08:10:12 <haasn> for IO, sure
08:10:13 <c_wraith> heck, s could be polykinded
08:10:19 <athan> hahaha
08:10:26 <athan> changing a constraint...
08:10:27 <haasn> but for ST, it doesn't really matter what the actual value is; let me show you why it's there:
08:10:29 <tristan__> You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.16.0, now Cabal-1.18.1.3).
08:10:39 <tristan__> I keep getting that!
08:10:49 <haasn> skypers: newSTRef :: a -> ST s (STRef s a)
08:10:57 <tristan__> running configure doens't help and I only have cabal 1.18 installed
08:11:28 <haasn> skypers: suppose you tried to evaluate: runST (newSTRef (3 :: Int))
08:11:30 <tristan__> well no, I have 1.16 in /usr/bin/cabal, grr, but the one used when I run cabal is 1.18
08:11:51 <skypers> yep haasn
08:11:54 <haasn> skypers: and then pass that variable to another computation, and modify if there. That would be bad, because it would allow arbitrary mutation of the number you could have gotten out of it (in a pure context)
08:12:06 <athan> tristan__: I feel your pain
08:12:17 <tristan__> :(
08:12:17 <haasn> skypers: but the type of runST is (forall s. ST s a) -> a; so in this case (forall s. ST s (STRef s a)) -> STRef s a
08:12:28 <haasn> the ‘s’ on the right hand side wants to escape the quantification
08:12:30 <tristan__> I was trying to use cabal-constraints
08:12:31 <haasn> Which is not possible
08:12:39 <athan> I just deleted cabal system-wide lol
08:12:39 <c_wraith> tristan__: try a cabal clean.  and then get rid of /usr/bin/cabal because it'll only break things
08:12:49 <athan> and added ~/.cabal/bin to PATH
08:12:58 <skypers> I see haasn
08:13:02 <haasn> skypers: this is why you can't return anything that's local to that single computation; because they're all parametrized by the phantom ‘s’, which can't ever leave the ST monad (via runST)
08:13:03 <skypers> pretty smart
08:13:14 <tristan__> c_wraith: hah, tha tworked, thanks :)
08:13:15 <haasn> yeah
08:13:23 <skypers> ok, I got it
08:13:28 <skypers> pretty clever :)
08:13:30 <haasn> it's just a mind-bender if you're using it for the first time, I guess. The key thing is to just write ‘s’ in your type signatures and pass it everywhere :
08:13:32 <haasn> :)
08:13:41 <skypers> so hm
08:13:42 <skypers> in ST
08:13:44 <skypers> I can do
08:13:46 <skypers> well
08:13:47 <skypers> :t runST
08:13:48 <lambdabot> (forall s. ST s a) -> a
08:13:58 <c_wraith> skypers: it's a bit more subtle than that.  you can use an existentially-quantified container to leak an STRef, or something..  But then that s still saves the day, because it prevents it from being used elsewhere
08:14:17 <haasn> c_wraith: good point; so you can escape but not in a meaningful sense
08:14:19 <athan> c_wraith: O.o
08:14:24 <athan> wow
08:14:28 <haasn> the type variable loses its identity outside of the ‘forall’
08:14:29 <athan> that's insanely sane
08:14:50 <athan> holy...
08:15:00 <athan> mackerel
08:15:06 <skypers> > runST $ do { a <- newSTRef "hello"; readSTRef a }
08:15:07 <lambdabot>  "hello"
08:15:25 <skypers> > runST $ do { a <- newSTRef "hello"; writeSTRef a "heehee" >>readSTRef a }
08:15:26 <lambdabot>  "heehee"
08:15:29 <skypers> ahah
08:15:38 <skypers> this is _exactly_ what I need
08:16:03 <skypers> how does it die though?
08:16:17 <c_wraith> want to know a secret?  runST's implementation is the same as unsafePerformIO.  It's just got a more clever type that makes it safe. :)
08:16:18 <athan> GC I'm sure
08:16:20 <skypers> if I create a lot of STRef
08:16:25 <skypers> GC you think?
08:16:32 <athan> hmm!
08:16:42 <athan> I'd bet
08:16:46 <skypers> ah, it’s the same thing as unsafePerformIO :(
08:16:50 <skypers> does it make ST a poor habit?
08:16:55 <c_wraith> nope!
08:16:57 <athan> but... you should definitely test
08:16:59 <johnw> ST is a good abstraction
08:17:01 <c_wraith> ST is limited enough to be safe
08:17:04 <athan> yeah, Par uses unsafe too
08:17:14 <c_wraith> So even though the implementation might be dirty, the interface is clean. :)
08:17:31 <skypers> ok :)
08:17:40 <c_wraith> and seriously, that describes a lot of stuff.  Have you ever looked at the bytestring internals?
08:17:41 <haasn> skypers: no, ST is completely pure; unsafePerformIO is GHC's little implementation hack, that it uses because it knows it's safe
08:17:50 <athan> what are you making, skypers? Video game?
08:18:01 <haasn> skypers: think about it like the implementation of “reflection” using unsafeCoerce :)
08:18:04 <c_wraith> bytestring defines its own even-unsafer version of unsafePerformIO.
08:18:14 <haasn> there is a perfectly valid and fully pure alternative implementation. This is just for performance, it's equivalent and safe
08:18:15 <skypers> athan: I’m a demomaker and planning to write my next demo in Haskell
08:18:24 <skypers> it’s a bit messy since I clearly lack a lot of stuff
08:18:26 <skypers> ST, for instance
08:18:31 <skypers> now it sounds better ;)
08:18:47 <haasn> athan: have you looked at simon marlow's book on concurrency and parallelism, since you seemed interested?
08:18:53 <athan> c_wraith: That's rediculous haha
08:18:57 <athan> I just bought it!!!
08:19:00 <skypers> I always thought *Ref was “kinda” like bare C pointers with a bit more safety, but it was dirty as well
08:19:34 <haasn> skypers: there's no arithmetic on *Ref
08:19:42 <haasn> And they can't be NULL
08:19:45 <haasn> Two very big distinctions :)
08:19:51 <skypers> yeah
08:19:52 <athan> skypers: That's awesome! but yeah, *Ref's are technically references, but immutable ones
08:19:53 <skypers> but I mean
08:19:54 <haasn> skypers: for the “bare C pointers” version, see Ptr
08:19:58 <skypers> Haskell is not event oriented
08:20:10 <haasn> athan: that's a good way to describe them :)
08:20:15 <haasn> immutable references to mutable values
08:20:26 <athan> :)
08:20:27 <ReinH> haasn: +1 SimonM's book
08:20:32 <haasn> skypers: not without FRP ;)
08:20:43 <athan> ReinH: What's your favorite Haskell book?
08:20:43 <skypers> yeah but I mean
08:20:49 <c_wraith> The IO manager is secretly event-oriented underneath.
08:20:55 <skypers> event-driven _could_ be implemented with STRef
08:21:00 <athan> very secretly
08:21:00 <ReinH> athan: maybe Richard Bird's Pearls of Functional Algorithm Design
08:21:13 <athan> :D!!!!
08:21:23 <athan> ReinH: Thank you!!
08:21:50 <athan> ReinH: Have you read Benjamin Pierce's Types and Programming Langauges?
08:21:53 <ReinH> skypers: you should talk to edwardk about that
08:21:56 <ReinH> athan: I've started it
08:22:03 <skypers> I will
08:22:06 <skypers> thank you anyway
08:22:07 <athan> heck yeaaaaa
08:22:12 <skypers> gonna try that ST stuff now :)
08:22:16 <athan> we're all gonna level up at the same time! lol
08:23:42 <c_wraith> skypers: do you know about the vector package?  It has high-performance mutable vectors that work in ST, which might be of interest to you.
08:23:58 <haasn> and so we come full circle
08:24:01 <skypers> I use Vectors
08:24:02 <skypers> but hm
08:24:12 <skypers> doesn’t ST introduce some kind of side-effects?
08:24:25 <c_wraith> not side..  It introduces effects.
08:24:25 <haasn> skypers: only within the scope of the action ran by “runST”
08:24:58 <haasn> skypers: all effects are constrained to happen within its execution, in a pure (reproducible, deterministic fashion)
08:24:59 <c_wraith> be very wary of unsafeInterleaveST, though.  It's first-order evil, when misused.
08:25:16 <haasn> c_wraith: is that like lazy ST?
08:25:23 <skypers> ok
08:25:28 <c_wraith> haasn: no, it's a different mechanism entirely
08:25:43 <c_wraith> haasn: http://lpaste.net/92226
08:26:45 <jophish> Yo yo yo
08:26:48 <c_wraith> that function violates referential transparency in a really terrible way.
08:26:50 <jophish> does this look ok: http://lpaste.net/102299
08:27:22 <jophish> It's pretty simple, but I'm not 100% certain that it's perfect
08:28:06 <haasn> c_wraith: looking at the internal implementation of unsafeInterleaveST, it is indeed like unsafePerformIO - in that side effects are performed “lazily” as you evaluate values; so you can modify already-computed values afterwards; the same as unsafeInterleaveIO + IORef
08:28:26 <c_wraith> jophish: If it's not 100% perfect, you can fix it when troubles arise.  That's the nice thing about haskell.  Confidence in radical refactoring!
08:28:27 <athan> skypers: You're good at mapping, right? From inside the runST, you're basically affecting it's internal ST datatype. You could (writeState "foo") `fmap` runState $..., and it'd still work
08:28:31 <athan> (right)?
08:28:43 <haasn> +1 for haskell refactoring
08:28:49 <skypers> no athan
08:28:50 <athan> the Functor encapsulates the purpose
08:28:59 <athan> hahaha
08:29:04 <c_wraith> haasn: it's actually the same as unsafeInterleaveIO, which is..  basically return . unsafePerformIO
08:29:04 <athan> why not, skypers?
08:29:16 <skypers> because runState escape the State :)
08:29:21 <skypers> escapes*
08:29:25 <haasn> I had no issues diving into GHC and Haddock code bases - just change the type of some API you need changed or data constructor you need amended, and GHC will tell you all the locations of where you need to update things to compensate.
08:29:28 <athan> see, that's where you're mistaken
08:29:33 <skypers> you might think of
08:29:37 <athan> the fmap applies the internals before the state is returned
08:29:40 <skypers> (modify (+1)) `fmap` myState
08:29:46 <athan> yes!
08:30:04 <athan> moreso "runMyState", I believe
08:30:10 <jophish> c_wraith: I suppose you're right. It's often nice to get things right from the start though
08:30:12 <skypers> hm, not even sure
08:30:14 <athan> but please ignore me if I'm just creating confusion lol
08:30:17 <skypers> no
08:30:19 <c_wraith> haasn: the thing is, with unsafeInterleaveIO, the result you get back is still in IO, so you know it won't be referentially transparent.  With unsafeInterleaveST, the failure to be referentially transparent can be stripped out of the type signature.
08:30:29 <skypers> you can’t access the statet with Functor, athan
08:30:39 <haasn> c_wraith: that makes sense
08:30:47 <athan> yeah you can!
08:30:52 <skypers> > fmap (+1) (put 3 >> return 3))
08:30:53 <lambdabot>  <hint>:1:30: parse error on input `)'
08:30:57 <athan> the function isn't typechecked before the fmap!
08:30:58 <skypers> > fmap (+1) (put 3 >> return 3)
08:30:59 <lambdabot>  No instance for (Control.Monad.State.Class.MonadState s0 f0)
08:30:59 <lambdabot>    arising from a use of `e_1133'
08:30:59 <lambdabot>  The type variables `f0', `s0' are ambiguous
08:30:59 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
08:30:59 <lambdabot>  Note: there are several potential instances:
08:31:04 <athan> nonono
08:31:14 <haasn> c_wraith: I guess it makes sense in that in the context of the lambda function you bind to such a misbehaved “IO a”, the ‘a’ can spontaneously combust
08:31:16 <athan> fmap (put 3) (return)
08:31:21 <athan> > fmap (put 3) (return)
08:31:22 <lambdabot>  Could not deduce (Control.Monad.State.Class.MonadState
08:31:22 <lambdabot>                      GHC.Integer.Type.Integer ((->) (m0 a)))
08:31:22 <lambdabot>    arising from the ambiguity check for `e_13'
08:31:22 <lambdabot>  from the context (GHC.Base.Monad m,
08:31:22 <lambdabot>                    GHC.Num.Num s,
08:31:24 <haasn> c_wraith: except for ST, the ‘context’ is the entire universe
08:31:24 <athan> hmm
08:31:33 <c_wraith> haasn: the example I pointed out on lpaste a bunch of lines back is..  super evil.  Did you take a look at it?
08:31:51 <skypers> you’re in (->) monad, athan
08:32:00 <athan> meh
08:32:03 <athan> same difference though
08:32:11 <athan> you can map the state mutations
08:32:16 <athan> not the value mutations
08:32:23 <athan> because there's no target for the functor
08:32:39 <skypers> what Functor are you mapping?
08:32:45 <athan> ST
08:32:51 <skypers> oh, ok
08:32:53 <athan> (imaginarilly)
08:33:06 <athan> and I'm mapping (writeState)'s
08:33:07 <skypers> I thought you were talking about State
08:33:11 <athan> or whatever ST's counterpart is
08:33:14 <haasn> c_wraith: I'm sort of looking at it; from what I gather it horribly generates a value like ([n],n+1), ([n+1,n+1],n+2), ([n+2,n+2,n+2],n+3) that spontaneously mutates itself every time you look at it the wrong way?
08:33:16 <athan> naw haha
08:33:20 * haasn tries it out
08:33:22 <athan> but, it should still work with that, too
08:34:06 <c_wraith> haasn: it doesn't spontaneously mutate itself.  It's just that the value returned depends on how you read it.
08:34:08 <haasn> Oh, no, it does something else
08:34:25 <c_wraith> the list portion will always be the same
08:34:31 <c_wraith> The issue is the second component of the tuple
08:34:44 <athan> the difference with State is that "put" and "get" are already functor manipulating values
08:34:46 <athan> er
08:34:47 <athan> functions
08:34:51 <c_wraith> Which is different depending on how much of the list has been consumed when you force it
08:35:00 <haasn> c_wraith: ah, the second component mutates itself to reflect how many elements you've forced so far?
08:35:12 <athan> while writeST is a datatype-specific function for manipulating the functor internally
08:35:18 <athan> from the inside
08:35:25 <c_wraith> Well.  how many elements you've forced at the time you force the second component.  It doesn't mutate after being forced.
08:35:27 <athan> so you could map those onto the functor
08:35:29 <haasn> c_wraith: oh, it doesn't even mutate itself; since GHC shares back the result
08:35:33 <haasn> okay, this is a misconception I had
08:35:36 <monochrom> unsafeInterleaveIO and unsafeInterleaveST expose evaluation order
08:35:36 <athan> (at least this is my basic understanding)
08:35:52 <haasn> Right, in the presence of sharing, this is just determined by which order you evaluate them in
08:35:56 <haasn> Not how many times
08:36:19 <haasn> Which makes me wonder: Can I construct a situation in which GHC *wouldn't* share the second value, but stillwould re-use the same STRef internally?
08:36:30 <haasn> I guess not, since it's an Int
08:36:43 <c_wraith> You'd have to change the type, and then defeat GHC's sharing
08:36:52 <c_wraith> you'd have to change it to a function
08:37:01 <haasn> (What I mean by “sharing” is “rewriting”)
08:37:03 <skypers> ok so hm
08:37:11 <skypers> if I have a mutable vector
08:37:16 <skypers> and I want to add someting into it
08:37:20 <skypers> how should I proceed?
08:37:28 <skypers> do I get an STRef?
08:38:08 <monochrom> what is "add"? make the vector larger?
08:38:17 <skypers> snoc
08:38:28 <monochrom> create a larger vector. copy over.
08:38:50 <haasn> c_wraith: I tried i <- unsafeInterleaveST $ fmap const (readSTRef i) -- but re-evaluating “snd x ()” after evaluating “take 10 (fst x)” still doesn't get updated :(
08:38:52 <skypers> what?…
08:38:55 <c_wraith> If you're going to be doing that much, it's worth it to pre-allocate larger and track the number of used elements manually
08:39:27 <skypers> I see that snoc is Vector a -> a -> Vector a
08:39:37 <skypers> why isn’t there a version for MVector?
08:39:55 <skypers> I think I can just use Vector (STRef a)
08:40:23 <skypers> since I might modify the value from outside the Vector
08:40:26 <monochrom> that's for immutable vectors. and you don't know how it is done internally.
08:40:44 <c_wraith> haasn: yeah, that's still only going to read the STRef once
08:40:44 <haasn> skypers: STRef is parametrized by ‘s’
08:40:52 <ReinH> skypers: maybe we could talk about what you're doing with the vectors
08:41:03 <ReinH> there might be a better option
08:41:17 <skypers> well
08:41:26 <skypers> they represent objects in a 3D scene
08:41:31 <skypers> for instance meshes, materials, and so on
08:41:33 <c_wraith> haasn: You'll need to be much trickier than that.  I haven't actually thought about how to do so.
08:41:37 <skypers> materials can be embedded in mesh
08:41:43 <skypers> but they have to be registered in the scene
08:41:54 <skypers> the user can change materials
08:41:56 <haasn> c_wraith: my thought was forcing it inside “runST” somehow; is there an unsaferunST other than unsafePerformIO . unsafeSTtoIO?
08:42:04 <skypers> then the materials have to change “everywhere” they’re used in
08:42:56 <c_wraith> haasn: I don't believe there is. The whole point of ST is not having that mechanism. :)
08:43:00 <haasn> c_wraith: oh, I see now why you misunderstood my “lazy ST” earlier - there actually is a lazy version of the ST monad! but that isn't related to the “lazy IO” kind of “lazy” I meant
08:43:25 <c_wraith> haasn: ah.  Yes, I was indeed thinking of the lazy version of ST.  And yes, it's different. :)
08:43:33 <shachaf> Well, you can probably use unsafeDupablePerformIO there.
08:43:42 <skypers> ReinH: any idea?
08:44:11 <haasn> c_wraith: success
08:44:11 <ReinH> skypers: My idea is that you should talk to edwardk when he's around :)
08:44:16 <ReinH> skypers: he's an old school demomaker
08:44:27 <ReinH> shachaf: so about our chat yesterday about Alternative.
08:44:34 <skypers> I know ReinH
08:44:44 <skypers> but my issue is mor general
08:44:45 <haasn> c_wraith: unsafePerformIO . unsafeSTToIO -- now I can construct a function that gives me back the “number of already evaluated elements” every time I apply it to something
08:44:47 <ReinH> shachaf: you said it's a monoid in the category of endofunctors, right? What differentiates it from the one that gives rise to a monad?
08:45:17 <shachaf> A monoid is a thing in a monoidal category, not just in any category.
08:45:21 <c_wraith> haasn: yes, but at this point you've moved on to higher-order evil.  unsafeInterleaveST is only first-order evil. :)
08:45:23 <shachaf> It's a different monoidal category.
08:45:42 <haasn> c_wraith: fair enough :)
08:45:51 <shachaf> unsafeInterleaveST is probably a good deal more evil than unsafeInterleaveIO.
08:45:53 <ReinH> shachaf: Right, how is that monoidal category structured? Is it the cartesian product?
08:46:01 <c_wraith> haasn: once you've thrown in unsafePerformIO, it can format the filesystem *while* being non-RT :)
08:46:13 <shachaf> That is the puzzle.
08:46:20 <ReinH> shachaf: those are the only two I know of on [C,C] :/
08:46:30 <shachaf> What does cartesian product mean?
08:47:16 <darthdeus> guys how can i use something like wai-devel-handler with scotty to get automatic reloading?
08:47:21 <darthdeus> or something else than wai-devel-handler
08:47:42 <bitemyapp> darthdeus: you can use wai-devel-handler, but I don't have a shake-n-bake template for you to use.
08:47:58 <bitemyapp> darthdeus: if you want me to follow up on this, I'm just going to be googling queries that you could probably come up with yourself.
08:48:13 <bitemyapp> darthdeus: http://stackoverflow.com/questions/8462493/how-do-i-use-wai-handler-devel-with-a-simple-wai-application
08:48:15 <c_wraith> scotty uses wai, right?  It should just be a matter of inserting wai-devel-handler in the right spot
08:48:19 <bitemyapp> darthdeus: ding, first result.
08:48:40 <ReinH> shachaf: sorry, if your category has a categorical product and a terminal object it forms a monoidal category, right?
08:48:41 <darthdeus> bitemyapp: oh nice :) thanks, i didn't think it would be this easy
08:48:51 <bitemyapp> darthdeus: scotty is just WAI, which is like half of why I love it.
08:48:52 <taktoa> shachaf: take two sets and return the set of all tuples of elements of each set
08:49:11 <shachaf> taktoa: We're talking about a category of functors and natural transformations here, though.
08:49:19 <taktoa> oh sorry
08:49:30 <shachaf> ReinH: That is one way to make a monoidal category. I'm not sure whether this category actually has products.
08:49:54 <ReinH> shachaf: Well, I guess that depends on whether Hask is cartesian closed
08:49:59 <ReinH> although it wouldn't need expnentials
08:50:10 <ReinH> shachaf: anyway those are the only two I know of
08:50:12 <shachaf> I'm not sure what you mean.
08:50:35 <shachaf> Anyway, say f and g are Functors. Figure out ways of combining them into a new functor.
08:50:49 <ReinH> shachaf: er, wait, the category is [Hask,Hask] right?
08:51:04 <shachaf> What category?
08:51:37 <ReinH> we're talking about a monoidal category of endofunctors on Hask, right?
08:52:12 <taktoa> lol, just googled "<subject> haskell" and got a chatlog of myself talking about <subject> on here
08:52:33 <ReinH> taktoa: well I guess that makes you the definitive expert on <subject> in Haskell
08:52:44 <athan> I think I'm gonna make a category diagramming tool / chat room...
08:52:46 <athan> ...just for us
08:52:52 <ReinH> athan: heh :)
08:53:10 <ReinH> I want a commutativity diagram drawing tool for diagrams
08:53:14 <ReinH> which has arrows now so
08:53:28 <athan> wat
08:53:29 <athan> lol
08:53:30 <taktoa> to be fair, <subject> is a certain non-open source voip program
08:53:35 <athan> are you talking about the library, ReinH?
08:53:38 <ReinH> taktoa: heh well
08:53:43 <bitemyapp> athan: that's a good idea.
08:53:44 <ReinH> athan: ah yes I can see how that would be confusing
08:53:58 <ReinH> @hackage diagrams
08:53:58 <lambdabot> http://hackage.haskell.org/package/diagrams
08:54:00 <ReinH> ofc
08:54:11 <athan> bitemyapp: I WILL DO THE EXERCISES I PROMISE
08:54:29 <shouya1> excuse me, folks. i met an error in installing cabal on gentoo: Could not find module `Control.DeepSeq'...
08:54:31 <athan> ReinH: Is a diagram a particular type of category?
08:54:34 <taktoa> a lambdabot plugin that processes diagrams expressions, renders them, and uploads them to imgur or similar
08:54:39 <taktoa> would be really cool
08:54:46 <shouya1> anyone can help? here's the log: http://pastebin.com/cwWKzAxW
08:54:54 <ReinH> athan: http://en.wikipedia.org/wiki/Commutative_diagram
08:55:01 <athan> o.o
08:55:08 <ReinH> diagrams form a monoid so yes, I suppose they are a particular type of category.
08:55:20 <ReinH> the diagrams in the `diagrams' library, that is
08:55:22 <taktoa> shouya1: you probably have to install the haskell deepseq library first
08:55:26 <bitemyapp> athan: you're learning to anticipate the bamboo swinging down. This is good.
08:55:32 <shouya1> i've installed that.
08:55:39 <taktoa> beats me, then
08:55:42 <athan> ooohhhhhh
08:55:43 <athan> yeah
08:55:50 <taktoa> probably a bad package
08:56:06 <ReinH> shachaf: so a way of composing Functors f and g. Other than the one provided by (<|>)?
08:56:09 <athan> ReinH: You will have it :)
08:56:15 <shouya1> taktoa: hmm. how can i check it?
08:56:21 <athan> to automatically make a commutativity diagram from an object
08:56:22 <shachaf> What does (<|>) have to do with it?
08:56:26 <athan> it will be a weird algorithm...
08:56:33 <ReinH> :t (<|>)
08:56:34 <lambdabot> Alternative f => f a -> f a -> f a
08:56:35 <shachaf> I am confused.
08:56:40 <taktoa> I forget the name for gentoo's equivalent to arch's PKGBUILDs
08:56:45 <athan> portage
08:56:46 <taktoa> but just find the one for that package
08:56:50 <taktoa> and edit it
08:56:51 <ReinH> shachaf: we're talking about Alternative. (<|>) is the monoidal operation for Alternative, right?
08:57:08 <taktoa> well portage is the program overall, I was talking about the script or whatever
08:57:10 <supki> shouya1: I suggest you ask in #gentoo-haskell too
08:57:10 <shachaf> "monoidal operation" meaning what?
08:57:27 <shouya1> supki: sure, i'd try :)
08:57:47 <shachaf> I am not trying to be unhelpful. I'm confused about your thought process.
08:58:04 <ReinH> shachaf: Er, the usual meaning? A closed, associative binary operation?
08:58:37 <ReinH> shachaf: I know. I'm sorry about what I said before. I appreciate your rigour. It helps keep me honest.
08:58:38 <bitemyapp> ReinH: point of clarification requested: what would an open, associative binary operation be like?
08:59:04 <bitemyapp> taktoa: I prefer use the term 'suffering', when referring to Gentoo packaging.
08:59:11 <taktoa> lol
08:59:12 <bitemyapp> taktoa: your mileage may vary.
08:59:24 <ReinH> bitemyapp: touche
08:59:31 <bitemyapp> ReinH: it's a serious question.
08:59:40 <bitemyapp> I have no intuition for the distinction.
08:59:41 <ReinH> bitemyapp: Well, it couldn't exist, could it?
08:59:47 <taktoa> I don't use gentoo, myself. I use Arch and am thinking of moving to NixOS or something like it
08:59:59 <c_wraith> Could it?  I can't see any way for a binary op to be associative without being closed.
09:00:04 <bitemyapp> I guess not, open/closed only have meaning to me WRT sum types.
09:00:21 <athan> takota: I really want to get in on it too
09:00:28 * hackagebot random-fu 0.2.5.0 - Random number generation  http://hackage.haskell.org/package/random-fu-0.2.5.0 (JamesCook)
09:00:32 <bitemyapp>  /topic everybody nitpick what ReinH is saying
09:00:38 <ReinH> bitemyapp: it's fine
09:00:38 <athan> it's kinda difficult to set up if you're not comfortable with various distros though
09:00:44 <athan> and setting it all up yourself
09:00:56 <ReinH> I don't have a proof but it seems impossible?
09:01:02 <bitemyapp> athan: I'm not paid to sysadmin manually, so fiddling with packages just isn't a high-value use of my time.
09:01:17 <bitemyapp> ReinH: but putting aside possibility, what does closed and open mean WRT to a binary associative operation?
09:01:20 <athan> I'm currently at a block where I can't get the system to load the right filesystem modules, or something along those lines, when the kernel boots. It would be trivial if I knew what I was doing :)
09:01:32 <bitemyapp> athan: you should be at a block with figuring out some NICTA exercises.
09:01:42 <athan> >>
09:01:43 <taktoa> well I was thinking of moving my server over to CoreOS, then have a docker vm for NixOS when I want to do Haskell dev
09:01:44 <ReinH> bitemyapp: well, for example non-endomorphisms don't form a monoid because they are not closed.
09:01:55 <athan> hmm!
09:01:57 <athan> CoreOS?
09:02:06 <bitemyapp> ReinH: okay, so closed is like a -> a, and open would be a -> b?
09:02:17 <bitemyapp> ReinH: which is to say, it can somehow change types in the process?
09:02:18 <taktoa> lightweight operating system designed to run docker VMs
09:02:26 <athan> ahhhhh
09:02:26 <bitemyapp> ReinH: endomorphism explained a lot here for me.
09:02:26 <athan> nice
09:02:27 <taktoa> docker is a declarative way to build vms
09:02:36 <athan> now that's cool
09:02:38 <bitemyapp> I don't know that I would call docker declarative.
09:02:47 <taktoa> well, it's more declarative
09:02:51 <athan> gotta be better than XEN
09:02:53 <ReinH> bitemyapp: I'm referring to clusure for operations on sets, i.e. the operation on members of that set always produces members of that set
09:02:55 <taktoa> than a bash script
09:02:59 <athan> that made my teeth hurt
09:03:01 <bitemyapp> ReinH: yep! thanks.
09:03:06 <Kototama> hi, i have managed to query some JSON with the Lens library. http://paste2.org/1mnGmf3K Can somebody explain to me how to use setters with lens+json ?
09:03:17 <shouya1> sorry i'm back.. nobody responses in #gentoo-gentoo ...
09:03:18 <Lethalman> and docker does not build vms
09:03:36 <taktoa> yeah it's paravirtualization or something
09:03:37 <taktoa> containers
09:03:38 <taktoa> sorry
09:03:41 <bitemyapp> ReinH: does binary operation imply the two elements are the same type/of-the-same-set?
09:03:58 <ReinH> bitemyapp: I believe so.
09:04:10 <ReinH> since it's defined on a set
09:04:11 <bitemyapp> Cool.
09:04:39 <bitemyapp> I wonder if a Docker container for experimenting with/learning Haskell would help new people get started.
09:04:53 <bitemyapp> since some people get caught up on getting Haskell installed, packages compiling, etc.
09:05:01 <taktoa> honestly not a bad idea, just have to wait until docker gets a bit more stable
09:05:03 <ReinH> shachaf: anyway, Alternative forms a monoid on applicative functors  with (<|>) and empty, right? That's the sense in which (<|>) is a monoidal operation.
09:05:13 <darthdeus> bitemyapp: i'm a bit confused, the wai-devel-handler requires a different signature than i have ... for example in here https://gist.github.com/darthdeus/a6b4a2941044a0dae00f I can't do wai-devel-handler 3000 Example handler, because it fails with the type signature
09:05:14 <ReinH> bitemyapp: maybe Vagrant?
09:05:26 <taktoa> also docker could be really good for building haskell programs
09:05:34 <ReinH> bitemyapp: a vagrant image w/ Haskell Platform installed would work on a lot of systems with a minimal install footprint
09:05:42 <bitemyapp> ReinH: Vagrant is associated with unhappy memories and anger for me.
09:05:56 <bitemyapp> ReinH: but lightweight/minimal footprint to get going is important, yes.
09:06:13 <bitemyapp> ReinH: I'm pretty sure you can generate virtualbox images from docker.
09:06:13 <ReinH> bitemyapp: Ok, but it works pretty well for simple things. And "boot up a VM and install Haskell Platform" or "boot up an image with pre-installed Haskell Platform" are pretty simple
09:06:14 <athan> what about virtualbox though?
09:06:21 <athan> I always get a lot of overhead with that
09:06:23 <bitemyapp> ReinH: realistically, Vagrant is just generating stuff for virtualbox IIRC
09:06:36 <ReinH> bitemyapp: yep, but the point is that it's portable and easy to get running
09:06:45 <athan> valid point
09:06:48 <ReinH> Although just a virtualbox image might be easy as well
09:06:50 <bitemyapp> is docker not? I thought the cool kids liked it because it was easy.
09:06:56 <athan> hmm
09:07:06 <taktoa> idk if there is docker on winblows
09:07:11 <athan> is there a low-level virtualbox hyper visor?
09:07:13 <ReinH> bitemyapp: docker is easy for sysadmins but maybe less so for people who just want to get ghc and ghci
09:07:29 <ReinH> certainly less easy than "vagrant up"
09:07:49 <ReinH> shachaf: is "monoidal operation" not a term I should use?
09:08:08 <athan> <>!
09:08:08 <bitemyapp> ReinH: I'll have to just walk through the process, see what I can come up with.
09:08:25 <taktoa> oh the other neat thing about coreos is that it provides a configuration daemon, IIRC
09:08:29 <bitemyapp> ReinH: my only hesitation with vbox is that I remember vbox being kind of annoying to install/manage sometimes.
09:08:32 <athan> ReinH: I think that's a very valid description for an operation over a collection :)
09:08:38 <ReinH> bitemyapp: Hmm does apt have a modern haskell platform package?
09:08:49 <monochrom> no
09:08:50 <bitemyapp> ReinH: 7.4.1 or some-such. Cabal 1.14
09:08:55 <ReinH> monochrom: *sigh* they never do, do they
09:08:57 <athan> no
09:08:57 <bitemyapp> ReinH: it's pretty abysmal.
09:08:57 <athan> lol
09:08:59 <taktoa> > no cabal 1.18
09:09:00 <lambdabot>  Not in scope: `no'
09:09:01 <lambdabot>  Perhaps you meant one of these:
09:09:01 <lambdabot>    `not' (imported from Data.Bool),
09:09:01 <lambdabot>    `n' (imported from Debug.SimpleReflect),
09:09:01 <lambdabot>    `o' (imported from Debug.SimpleReflect)Not in scope: `cabal'
09:09:02 <taktoa> > 2014
09:09:03 <lambdabot>  2014
09:09:05 <monochrom> they sometimes do. but not often enough.
09:09:06 <taktoa> lol
09:09:14 <athan> ReinH: It's terrible D:
09:09:28 <ReinH> monochrom: I used to work on Puppet. I have some experience dealing with package managers...
09:09:35 <ReinH> monochrom: it's never good.
09:09:38 <bitemyapp> it just occurred to me that I don't even remember where my ghc on this linux machine came from.
09:09:39 <monochrom> therefore, in practice, I ignore them. it's the most reliable thing to do. if you ignore them, you can't go wrong.
09:09:45 <ReinH> monochrom: but at least it's not yum
09:09:48 <ReinH> nothing can be as bad as yum
09:09:50 <bitemyapp> it's 7.6.3, but I have no idea who/what installed it.
09:09:57 <bitemyapp> ReinH: sometimes I think yum was invented to mock Python for being slow.
09:10:07 <athan> hahahaha
09:10:11 <bitemyapp> it's one big, tub of molasses joke.
09:10:17 <taktoa> I've just decided to always install things in cabal sandboxes
09:10:18 <monochrom> santa claus installed it for you last christmas
09:10:21 <ReinH> We had to rewrite our package management subsystem to deal with yum
09:10:33 <taktoa> and never deal with package management and haskell
09:10:36 <ReinH> You'd think in a *nix world that getting a package manager to install a package without human intervention would be easy
09:10:39 <athan> ReinH: Sheeesh!
09:10:42 <ReinH> NOT WITH YUM
09:10:44 <bitemyapp> ReinH: I would've banned CentOS instead.
09:10:50 <athan> yeah
09:11:02 <taktoa> it's weird that a package manager is just a program
09:11:03 <bitemyapp> "debian, 'buntu, or containerized installs only"
09:11:04 <ReinH> bitemyapp: well RedHat is a client/vendor so we don't have a choice but to make it work on RHEL-likes ;)
09:11:07 <athan> If I were developing a "for sale" application, I would quarantine everything
09:11:11 <ReinH> *didn't. I'm not there any more.
09:11:15 <bitemyapp> ReinH: well. as long as money is involved.
09:11:18 <taktoa> it feels tightly integrated but it isn't necessarily
09:11:22 <bitemyapp> but yum for love? nope.
09:11:24 <ReinH> bitemyapp: pretty much
09:11:27 <bitemyapp> nooooooope
09:11:33 <ReinH> bitemyapp: nope indeed, 1000 nopes
09:11:50 <bitemyapp> ReinH: it's annoying enough to write idempotent, "just fucking do it" scripts with apt, I can't imagine the same with yum.
09:12:03 <bitemyapp> "I have to write to a config file just to install this package in an automated fashion?"
09:12:10 <bitemyapp> "are you serious? I'm quitting to start a goat farm."
09:12:19 <taktoa> lol gar1t
09:12:30 <davean> bitemyapp: have you seen how much human interaction goats require?
09:12:33 <ReinH> bitemyapp: and idempotence was a pretty core part of puppet :/
09:13:21 <taktoa> googling "puppet" gives me IT-related results at the top
09:13:26 <bitemyapp> ReinH: I'd really like a Haskell alternative to Puppet/Chef/Fabric/Salt/Ansible
09:13:31 <ReinH> taktoa: SEO WINNINGS
09:13:34 <bitemyapp> taktoa: that's basically what it is.
09:13:36 <taktoa> yup
09:13:40 <monochrom> well, you could also argue, "I have to write a cabal files just to install this package?"
09:13:46 <ReinH> bitemyapp: Nix?
09:13:54 <bitemyapp> ReinH: gooby pls. No.
09:14:07 <bitemyapp> ReinH: distro/OS agnostic.
09:14:11 * ReinH shrugs
09:14:14 <monochrom> but I guess I forgot "cabal init"
09:14:15 <taktoa> Nix is agnostic IIRC
09:14:22 <bitemyapp> taktoa: getting it working isn't
09:14:30 <taktoa> oh so it's a PITA
09:14:52 <taktoa> the main problem I've seen with Nix is that nixpkgs has not very many programs
09:14:54 <bitemyapp> I need to make an alias for a non-interactive cabal init.
09:14:58 <ReinH> bitemyapp: the thing is, most of those tools do far too much. 80% of config management isn't provisioning, it's convergence. Convergence is really fucking hard. And also not necessary.
09:15:07 <taktoa> I mean, I could make my own, but I'm lazy
09:15:27 <shouya1> sorry, but how do i check if a package is installed correctly? (not broken)
09:15:28 <bitemyapp> ReinH: Convergence on a golden state becomes unnecessary if you don't have long-running machines right?
09:15:46 <ReinH> People are starting to take an Erlang "let it fail" approach to systems. Which means you don't need convergence at all. Just failure detection.
09:15:51 <ReinH> (Starting... it only took 30 years...)
09:16:10 <bitemyapp> ReinH: when I say I script for idempotence, I mean the single-shot to provision/resume provisioning the machine
09:16:13 <athan> Anyone have an observium alternative?
09:16:15 <ReinH> anyway this isn't about haskell any more. #haskell-blah?
09:16:17 <athan> in mind?
09:16:26 <bitemyapp> ReinH: by all means
09:16:30 <athan> I'm down
09:17:23 <shouya1> like just taktoa said it's possible that i had Control.DeepSeq mis-installed?
09:18:36 <mizu_no_oto> Can anyone else observe this error (http://lpaste.net/102302) when cabal installing language-javascript-0.5.9?  I'm using 7.8, if it makes a difference
09:19:56 <geekosaur> don't you need a newer alex for 7.8?
09:20:30 * hackagebot Win32-errors 0.2 - Alternative error handling for Win32 foreign calls  http://hackage.haskell.org/package/Win32-errors-0.2 (MichaelSteele)
09:22:11 <darthdeus> uhm so i've found this http://hackage.haskell.org/package/scotty-0.7.1/docs/Web-Scotty-Trans.html#g:1 which defines scottyAppT, which says it turns scotty app into WAI app, which seems what I need ... and also there's scottyApp which is ScottyM () -> IO Application, but still no clue how to use those :\
09:22:27 <darthdeus> scottyAppT seems to require much more than just a handler, and scottyApp doesn't have the right signature for the wai-handler-devel
09:23:59 <MagneticDuck> grrr.. there are barely any tutorials using the new parsec!
09:24:25 <MagneticDuck> oh well, hopefully not that much has changed
09:24:48 <monochrom> I have an advanced tutorial but it's advanced: http://www.vex.net/~trebla/haskell/parsec-generally.xhtml
09:25:10 <ReinH> advanced tutorial is advanced
09:25:18 <MagneticDuck> advanced is nice
09:27:13 <MagneticDuck> hmmm... I should use Text =P
09:27:18 <veryrandomname> How do I construct a Lens/Traversal/Prism similar to Data.List.find ? I don't know how to deal with Maybe.
09:28:08 <MagneticDuck> btw what do they mean by "subject to fusion" as a warning for a bunch of functions exported by Data.Text?
09:28:35 <MagneticDuck> tail: O(1) Returns all characters after the head of a Text, which must be non-empty. Subject to fusion.
09:28:48 <MagneticDuck>                                                                                       ^^^
09:29:02 <c_wraith> MagneticDuck: that tells you that it can be converted to a faster form if it's used in a chain of Text operations
09:29:24 <MagneticDuck> ah
09:29:24 <monochrom> it is not a warning. it is an encouragement :)
09:29:27 <MagneticDuck> I see.
09:29:52 <MagneticDuck> they're just saying, "Watch out, be sure to use your head before you compose a bunch of these things"
09:29:52 <edwardk> :t find
09:29:53 <lambdabot> (a -> Bool) -> [a] -> Maybe a
09:30:07 <edwardk> you can write a fold for it, but not really a traversal.
09:30:20 <edwardk> :t \p -> traverse.filtered p
09:30:21 <lambdabot> (Applicative f, Traversable t) => (a -> Bool) -> (a -> f a) -> t a -> f (t a)
09:30:24 <c_wraith> MagneticDuck: In particular, Text uses stream fusion.  In the stream form, tail is just dropping the first element.
09:30:45 <edwardk> > [1..10] ^? traverse.filtered (> 5)
09:30:47 <lambdabot>  Just 6
09:30:54 <edwardk> > [1..10] & traverse.filtered (> 5) *~ 100
09:30:56 <lambdabot>  [1,2,3,4,5,600,700,800,900,1000]
09:31:14 <MagneticDuck> !
09:31:18 <edwardk> fltered is technically only a legal fold, but it can be used as an (illegal) prism, traversal, etc.
09:32:43 <ReinH> edwardk: hai
09:32:55 <veryrandomname> when I want to have a Maybe instead of a List, I have to use it as an illegal prism?
09:33:17 <c_wraith> MagneticDuck: more or less, stream fusion for Text means that if you compose a bunch of operations that are subject to fusion, they get converted into a bunch of loops that don't allocate a result Text object until the end of the computation
09:33:46 <ReinH> edwardk: skypers was working on some demoscene stuff and had a question I thought you could probably answer
09:33:46 <MagneticDuck> oh
09:34:21 <c_wraith> MagneticDuck: this is a good thing, and you want to make it work wherever you can. :)
09:37:18 <darthdeus> i'm so confused ... I've got either ScottyM () or IO Application, but the handler requires (Application -> IO ()) -> IO () ... I dont understand why is that needed
09:37:23 <darthdeus> there's no docs on wai-handler-devel
09:38:02 <shachaf> ReinH: I don't know if it's a term you should use.
09:38:20 <shachaf> ReinH: I thought you were talking about a monoidal category.
09:38:44 <ReinH> shachaf: Ok, if it's confusing that's a good reason to drop it :)
09:38:53 <jophish> Let's pretend that I have the data structure Tree = Tree [Fruit]; Fruit = Apple | Orange, and a function removeOranges :: Tree -> Tree. removeOranges (Tree fs) = Tree $ filter (==Apple) fs. Is it possible to specify somehow at the type level that removeOranges returns a tree which can't contain the constructor Orange?
09:39:07 <shachaf> ReinH: Anyway, be careful with your terminoogy. (<|>) doesn't operate on functors (those are type-level things like f and g), it operates on, uh, "actions" (those are value-level things like x :: f Int).
09:39:31 <ReinH> shachaf: Yep, thanks for correcting me.
09:39:53 <jophish> a more simple example may be, can we alter the List and Bool to ensure that (filter id) doesn't leave any Trues in the list
09:40:11 <bitemyapp> jophish: you're kinda asking for dependent typing.
09:40:13 <ReinH> shachaf: so I don't think I'm going to be able to guess which monoidal category we're talking about here. Can you give me a hint?
09:40:25 <jophish> bitemyapp: something towards that, yes
09:40:26 <bitemyapp> jophish: you could split out the sum type.
09:40:32 * hackagebot Win32-errors 0.2.0.1 - Alternative error handling for Win32 foreign calls  http://hackage.haskell.org/package/Win32-errors-0.2.0.1 (MichaelSteele)
09:40:34 <nh2> I'm trying to use Vec3 from vect: http://hackage.haskell.org/package/vect-0.4.7/docs/Data-Vect-Float-Base.html#t:Vec3 - Haddock clealy says that thing has an Eq instance, but I can't find one in the code and my GHCI also complains about it missing - what's going on?
09:40:38 <bitemyapp> jophish: then make a sum type of the types.
09:40:47 <bitemyapp> jophish: then you'd have what you want, I think.
09:40:49 <shachaf> ReinH: There are a few different ways of figuring it out. You could look at the type of (<|>) carefully.
09:41:16 <shachaf> ReinH: There are three straightforward ways I can think of of combining two functors f and g to make a functor h that are associative and have an identity.
09:41:22 <roboguy_> jophish: you could use a GADT
09:41:23 <bitemyapp> jophish: FruitOrange vs. Orange, since you can't discriminate at the type level between the inhabitants.
09:41:27 <shachaf> One of them is newtype Compose f g a = Compose (f (g a))
09:41:28 <bitemyapp> roboguy_: dude, no.
09:41:32 <roboguy_> bitemyapp: no?
09:41:39 <bitemyapp> roboguy_: lets not pimp thy ride as a first resort please :(
09:41:42 <jophish> bitemyapp: have you got a link for Sum types, it's tricky to google
09:41:50 <bitemyapp> jophish: well you already made a sum type.
09:41:58 <roboguy_> haha, you're probably right
09:42:00 <bitemyapp> data Maybe a = Nothing | Just a
09:42:14 <bitemyapp> | is or. Or is summation. And is product. Product is a record type.
09:42:22 <bitemyapp> jophish: capiche?
09:42:27 <jophish> The actual problem is a little more complicated, so perhaps GADTs would be worth considering. roboguy_ may you explain a bit more?
09:42:28 <ReinH> :t (<|>)
09:42:29 <lambdabot> Alternative f => f a -> f a -> f a
09:42:31 <bitemyapp> jophish: no.
09:42:39 <edwardk> ReinH, skypers: sure. maybe in #haskell-game?
09:42:42 <bitemyapp> jophish: no, stop. Seriously. You want to understand what I'm suggesting before resorting to GADTs.
09:42:45 <jophish> bitemyapp: following so far
09:42:49 <bitemyapp> roboguy_: I blame you.
09:43:08 <bitemyapp> jophish: I'm saying lift the members of your existing sum type into being types of their own, then making a sum type *of* those types.
09:43:18 <shachaf> ReinH: There are two straightforward ways I can think of of combining two types to make a new type that are associative and have an identity. I think you've already named one of them.
09:43:29 <bitemyapp> jophish: Orange being a type instead of just a value constructor. Then it can be a return type.
09:43:52 <bitemyapp> jophish: you just have to make a function that goes from FruitOrange (inhabitant of Fruit sum type) to Orange (independent type)
09:43:54 <jophish> removeOranges :: Tree (Either Apple Orange) -> Tree Orange
09:44:04 <bitemyapp> That works.
09:44:12 <jophish> gotcha
09:44:36 <bitemyapp> jophish: I was using sum type generically rather than specifying Either because I didn't want to bind it to a specific cardinality without knowing the "real" problem.
09:44:45 <roboguy_> I mean, I don't think GADTs are that hard to understand if you have a use-case for them (that was always what caused me problems when I learned them), and this *would* be a use case for them. but maybe this way is best for now
09:45:10 <jophish> I'd be interested in knowing, purely for curiosities sake
09:45:12 <bitemyapp> roboguy_: it's not about being hard to understand.
09:45:19 <roboguy_> bitemyapp: what is it about?
09:45:39 <roboguy_> also with GADTs, you don't need to really worry about conversion functions as much
09:45:45 <bitemyapp> roboguy_: I come from language communities that were constantly about leaving the $MOREMAGIC switch turned on.
09:46:04 <roboguy_> bitemyapp: in haskell, extensions are used *way* more often than not
09:46:05 <bitemyapp> there is a very simple, very straight-forward solution to this problem that is simpler and easier to understand than GADTs.
09:46:20 <bitemyapp> roboguy_: I am fully aware of that and I use them where it makes sense.
09:46:26 <roboguy_> well, we will probably have to disagree there.
09:47:00 <roboguy_> it may be simpler for this case, but if you expand the number of branches it gets messy
09:47:03 <bitemyapp> well until I spoke up they didn't know what product and sum types were, so there was *some* value in exploring the simple and straight-forward solution.
09:47:11 <roboguy_> true
09:47:23 <MagneticDuck> parsec question: is 'satisfy $ flip elem "aeiou"' somehow.. faster than 'oneOf "aeiou"'?
09:47:31 <MagneticDuck> I mean...
09:47:33 <MagneticDuck> xD
09:47:35 <MagneticDuck> does it matter?
09:47:49 <ReinH> shachaf: so, first, three ways of combining functors... composition, First, and Last? Or am I off base?
09:47:54 <jophish> bitemyapp: the actual problem is this: I'm tidying up a basic Haskell compiler, I have a selection of data types for representing the Haskell AST. One of these is TypeVarBind = Unkinded ... | Kinded ...; After the kind checker I want to ensure that no TypeVarBinds exist with the Unkinded constructor
09:47:58 <shachaf> What are First and Last?
09:48:09 <roboguy_> MagneticDuck: it's exactly the same: http://hackage.haskell.org/package/parsec-3.1.5/docs/src/Text-Parsec-Char.html#oneOf
09:48:20 <jophish> TypeVarBind is one example of this, it would be a pain to have to parameterise the Module type over all these sum types
09:48:24 <bitemyapp> ReinH: seconding first and last. Dunno what that is.
09:48:24 <shachaf> @let newtype Compose f g a = Compose (f (g a))
09:48:26 <lambdabot>  Defined.
09:48:26 <ReinH> shachaf: f a (x) g a = f a and f a (x) g a = g a ?
09:48:50 <bitemyapp> roboguy_: if you don't have a firm grasp of type constructors, value constructors, products, and sums then there's more value in plumbing that than flipping GADTs on.
09:48:50 <shachaf> What's the identity for these?
09:48:59 <roboguy_> bitemyapp: on the other hand, he is writing a haskell compiler
09:49:03 <bitemyapp> roboguy_: I know GADTs can clean up certain patterns, but lets get the fundamentals first?
09:49:15 <bitemyapp> roboguy_: and didn't know what sum/product were. Iunno.
09:49:19 <shachaf> Try the simpler version first, with types rather than functors.
09:49:36 <jophish> I was aware of Sum and product types, Either / Tuple. I thought you were referring to something more specific
09:49:46 <bitemyapp> jophish: ah, sorry.
09:49:49 <roboguy_> well, I'll write up a GADT example and let you decide.
09:49:51 <jophish> no problem :)
09:49:56 <ReinH> shachaf: the identity functor?
09:50:01 <jophish> roboguy_: that would be useful, thanks
09:50:06 <bitemyapp> roboguy_: using the Fruit/Orange/Apple example?
09:50:24 <jophish> bitemyapp: I totally agree that it's a bad idea to overcomplicate things :)
09:50:28 <shachaf> This is too loud for this channel. I'll go to #haskell-overflow.
09:50:31 <ReinH> shachaf: ok
09:51:04 <bitemyapp> jophish: do you want an example of what I'm talking using the Fruit/Orange thing?
09:51:06 <roboguy_> actually, that might not work now that I think about it. it would be hard to have a collection of things that could be either type
09:51:10 <bitemyapp> BAHAHAHAHAHA
09:51:12 <bitemyapp> roboguy_: I WIN
09:51:14 <jophish> bitemyapp: more examples can't hurt
09:51:23 <roboguy_> bitemyapp: yeah. jeez relax
09:51:27 * bitemyapp gets on the floor; does the dinosaur
09:51:29 <bitemyapp> roboguy_: sorry :)
09:51:34 <bitemyapp> jophish: uno momento.
09:51:36 <roboguy_> that's alright haha
09:52:03 <bitemyapp> jophish: the essence of the pattern is, "lift value constructors into type constructors, then convert between value inhabitants of the sum to the inhabitants of the reified type"
09:52:23 <jophish> gotcha
09:53:15 <jophish> I think what would be cleanest in this example would be to parameterise the Module type over the compilation stage. Each sub data type could become more restricted as the stages progress.
09:53:47 <jophish> bitemyapp: ah, what example did you mean just now
09:53:56 <jophish> sum types aren't a problem to understand
09:56:39 <bitemyapp> jophish: h/o, working on the basic reification example
09:56:48 <jophish> thanks!
09:59:27 <bitemyapp> jophish: my example gets nicer if you use lenses/prisms as well, by the by.
10:00:34 * hackagebot Win32-dhcp-server 0.2 - Win32 DHCP Server Management API.  http://hackage.haskell.org/package/Win32-dhcp-server-0.2 (MichaelSteele)
10:00:36 * hackagebot concraft 0.9.1 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.9.1 (JakubWaszczuk)
10:03:05 <bitemyapp> jophish: got it: http://lpaste.net/102308
10:04:36 <bitemyapp> jophish: anyway, discriminateApple doesn't have to be implemented yourself if you derive lenses/prisms for your stuff.
10:05:19 <jophish> thanks, bitemyapp
10:05:20 <bitemyapp> jophish: see what I mean about how simple it can be?
10:05:23 <bitemyapp> roboguy_: ^^
10:05:29 <bitemyapp> roboguy_: want your opinion :)
10:05:35 * hackagebot cabal-cargs 0.4 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.4 (DanielTrstenjak)
10:05:51 <jophish> that is nice and simple, and solves my initial question well. Nice to know new stuff
10:05:53 <bitemyapp> jophish: I validated it with my REPL, so I know the idea works.
10:05:56 <roboguy_> bitemyapp: looks good
10:06:15 <bitemyapp> roboguy_: sorry for curb-slamming you. I get competitive. It's out of love :)
10:06:22 <roboguy_> haha that's ok
10:06:44 <bitemyapp> part of the reason for the vim and vigor is that I *just* solved this problem for myself in the library I'm working on.
10:06:46 <roboguy_> if you have 7.8, you can use pattern synonyms to make that a little easier
10:06:58 <bitemyapp> roboguy_: I haven't touched that yet. I need to.
10:07:02 <jophish> I'm not entirely sure how to apply this to the more complicated example, where the types to be filtered are far down in a hierarchy
10:07:26 <jophish> where there are lots of these cases
10:07:41 <roboguy_> bitemyapp: you can essentially make a new pattern like "pattern RealApple a = FruitApple (Apple a)" so you can remove some of the unnecessary verbosity
10:08:15 <bitemyapp> jophish: well, break it down to its essence. You want the type system to discriminate between the inhabitants of a sum.
10:08:39 <bitemyapp> jophish: so you basically need two things. The reified type (Apple in our example) and the prism/discriminator
10:09:15 <bitemyapp> jophish: so anytime you have a value constructor of a sum whose propagation you want to track at the type level, you reify it to a type instead of a stand-alone inhabitant of a sum and then derive a prism or write a discriminator for it.
10:10:04 <jophish> seems simple. It still seems a little awkward having to thread this data down the hierarchy though
10:10:26 <bitemyapp> jophish: the new value constructor based on the new type provides the path from Reified Member -> Member of Sum, to get the reverse you use a prism/manual function and handle the non-determinism with Maybe.
10:10:37 <bitemyapp> jophish: yeah ubut the awkwardness you speak of is why we use lenses and prisms.
10:11:08 <bitemyapp> jophish: you can describe a "attempt this path and if it doesn't work, spit out a Nothing" into an arbitrarily nested type hierarchy as long as they all have the appropriate lenses/prisms derived.
10:11:18 <bitemyapp> jophish: the lens library will even do the work of deriving them for you.
10:11:31 <bitemyapp> sorry for the lens marketing, but this is literally what they're made for.
10:11:45 <bitemyapp> jophish: how well do you know lenses and prisms?
10:11:47 <jophish> I've still not quite got my head around them
10:11:51 <roboguy_> I definitely second using lenses
10:12:02 <bitemyapp> jophish: neither do I, but I can still use them.
10:12:06 <bitemyapp> which I think speaks well to the UX.
10:13:16 <nh2> is there an easy way to see if vector fuses away my map.filter.imap chain?
10:19:36 <jophish> bitemyapp: In the example code you gave, if I wanted to contain the list of Fruits in that Tree data type, it would be necessary to specify whether it's a Tree of Fruit or a Tree of Apples. If for example we made it Tree [Fruit] [Animal]; data Animal = Bird | Bee. After reification we'd have something like. removeApplesAndBees :: Tree Fruit Animal -> Tree Orange Bird; Is it possible to encode this in a more suc
10:19:37 <jophish> cinct way, something like removeApplesAndBees :: Tree Everything -> Tree RemovedApplesAndBees
10:19:48 <jophish> this example is becoming worse and worse
10:20:34 <bitemyapp> jophish: whut
10:21:16 <bitemyapp> jophish: yes fruits and apples are different types, fruits are a summation category of other types rather than having sole inhabitants that don't exist as types outside of the sum.
10:21:39 <bitemyapp> jophish: the only problem I see is if you want a bunch of different sub-categories
10:21:46 <bitemyapp> jophish: like Fruit vs. FruitExceptApples
10:21:52 <darthdeus> http://stackoverflow.com/questions/22884134/how-can-i-set-up-wai-handler-devel-with-scotty-to-have-automatic-code-reloading
10:21:58 <bitemyapp> jophish: but thtat would be a pain in the ass in any language, including dependently typed ones.
10:22:08 <bitemyapp> jophish: you'll still have to specify what you want/mean
10:22:13 <jophish> phrasing it another way. Can I say that Tree A is a tree with every kind of fruit, and Tree B is a tree with only apples
10:22:21 <jophish> and also be able to put other constraints under A and B
10:22:23 <bitemyapp> Tree Fruit vs. Tree Apple
10:22:26 <bitemyapp> that's it.
10:22:42 <bitemyapp> Apple is a type, Fruit is a type. a parameterized Tree can contain either/.
10:22:59 <jophish> sure, I get that
10:23:17 <bitemyapp> the "many sub-categories" problem would be ameliorated if we had a Vinyl for sum types.
10:23:29 <bitemyapp> I need to make an example for sterling and cowley.
10:23:52 <bitemyapp> jophish: I don't see the sticking point yet, sorry. Could you restate the sticking point concisely please?
10:23:59 <jophish> sure, sorry
10:24:01 <tristan__> sterling?
10:24:11 <bitemyapp> tristan__: one of the authors of Vinyl
10:24:21 <tristan__> oh, nm then :)
10:24:31 <bitemyapp> tristan__: Vinyl is a sweet library >:)
10:25:09 <tristan__> hm, looks interesting
10:26:09 <tristan__> everyone usually says to just use Lens for record fixing, I haven't bothered to deal with Lens outside of libraries that already use it
10:26:41 <darthdeus> please guys if anyone could even hint me a little bit about that question, or just point me to something i should read
10:27:01 <jophish> bitemyapp: In my AST for Haskell, kind inference may look like: ki :: Module KindedOrUnkindedTypeVariable -> Module KindedTypeVariable, right?
10:27:20 <bitemyapp> jophish: okay, that's Module Fruit -> Module Apple
10:27:24 <bitemyapp> jophish: next?
10:27:26 <jophish> exactly
10:28:18 <bitemyapp> jophish: but...I asked for what the problem was ;_;
10:28:26 <jophish> typing more ...
10:28:30 <bitemyapp> ah sorry
10:29:16 <jophish> bitemyapp: type inference would be something like: ti :: Module UntypedOrExplicitlyTypedTermVariables -> Module TypedTermVariables
10:29:47 <bitemyapp> jophish: problem. Give me a problem.
10:29:49 <jophish> but in order to use the same Module type for kind and type inference, this leads to: ti :: Module KindedTypeVariables UntypedOrExplicitlyTypedTermVariables -> Module KindedTypeVariables TypedTermVariables
10:29:54 <bitemyapp> hrm.
10:30:16 <bitemyapp> jophish: then you need functions for each.
10:30:19 <jophish> there are lots of these, and it leads to huge signatures, with lots of terms which aren't so relevant in them
10:30:23 <jophish> ah
10:30:24 <jophish> yes
10:30:26 <jophish> of course
10:30:34 <jophish> as soon as I typed that I realised
10:30:46 <bitemyapp> jophish: if it makes you feel any better, I need to rubber ducky sometimes too.
10:30:54 <jophish> bitemyapp: thanks so much for all your help in this, you've been super
10:31:00 <bitemyapp> jophish: np, I enjoyed it.
10:31:18 <bitemyapp> I like keeping the lid on the $MOREMAGIC while still giving people tools/ideas for their problems :)
10:31:48 <bitemyapp> jophish: really the only thing that could make this stuff even nicer than what we have with lenses and prisms would be a vinyl for sum types. That would be superrrrrr but it sounds like even your use-case won't have much cruft anyway.
10:32:12 <bitemyapp> I have a use-case which will involve a lot of overlapping sum-types so I've been grumpy lately.
10:32:23 <roboguy_> I've never used vinyl, what's it like?
10:32:50 <roboguy_> I always assumed that it overlapped enough with lens that I wouldn't really need it
10:32:52 <Fuuzetsu> I used vinyl, it solved my problem of parsing data from multiple sites with some of the properties being the same
10:32:53 <bitemyapp> roboguy_: well, the description "modern records for Haskell" is written by somebody that *really* likes Harper.
10:33:05 <bitemyapp> roboguy_: it cleans up overlapping product types nicely.
10:33:14 <bitemyapp> That's all I really want for sum types. Clean up the overlap.
10:33:19 <jonsterling> Hi
10:33:22 <bitemyapp> I've got a ton of non-determinism I want to squash.
10:33:28 <bitemyapp> jonsterling: welcome!
10:33:41 <bitemyapp> jonsterling: we were just discussing Vinyl and a hypothetical sum type variation of the theme.
10:33:54 <Fuuzetsu> I don't know about sum types, I had a ton of overlap between product type fields ;)
10:34:07 <bitemyapp> Fuuzetsu: I've got the...dual of your problem?
10:34:18 <Fuuzetsu> a coproblem?
10:34:22 <bitemyapp> what's the dual of vinyl? cotton? cassette?
10:34:24 <ccnp123> hey guys, quick question... need to convert a MongoDB Binary value to a ByteString... can't quite figure out how to use the casting functions
10:34:27 <Fuuzetsu> or is coproblem a solution
10:34:37 <bitemyapp> problem . coproblem = id?
10:34:48 <bitemyapp> problem . solution = problem . coproblem = id?
10:35:07 <bitemyapp> jonsterling: anything to add?
10:35:19 <bitemyapp> jonsterling: I was marketing your library for you :)
10:35:44 <hk3380> what does a | in patern matching mean? is it 'or'?
10:36:15 <Fuuzetsu> nothing, it's just a delimiter although I guess it could mean ‘or’ for constructors
10:36:36 <jonsterling> Well, nothing quite to add, but I think Runar did write like a six line extensible sums thing. might be a good place to start.
10:36:49 <bitemyapp> jonsterling: oh damn, link please?
10:36:56 <bitemyapp> jonsterling: I could very much end up needing that.
10:37:12 <jonsterling> Anyone who wants to know more about vinyl though should probably come to BayHac next month.
10:37:15 <bitemyapp> hk3380: "or" ~ +, "and" ~ *
10:37:21 <monochrom> hk3380: it is a delimiter. (what isn't?) it adds a boolean condition
10:37:37 <bitemyapp> jonsterling: damn. I picked the wrong time to move from SF -> Austin
10:37:41 <jonsterling> bitemyapp: I think it's on his twitter somewhere, I'll see if I can pull it up later...
10:37:42 <hk3380> okay, thanks guys
10:37:44 <roboguy_> vinyl uses a subtyping relation? I thought that doesn't work well in haskell?
10:37:54 <Fuuzetsu> it defines one itself
10:37:55 <bitemyapp> jonsterling: don't bother, I'll spelunk it.
10:38:00 <monochrom> "f (x:xs) | even x = ..." means: matching the pattern x:xs, and x is an even number
10:38:33 <bitemyapp> roboguy_: I don't remember if the problem was subtyping or override-style inheritance.
10:38:39 <skypers> hey, do you think it’s sane to use FRP when dealing with shared values that can change?
10:38:42 <jonsterling> It has the subtyping so that you can coerce larger records to smaller ones. But it is not used "judgmentally".
10:38:51 <roboguy_> bitemyapp: hmm, I thought it was both
10:38:53 <bitemyapp> skypers: it can work, depending on how your state is structured.
10:39:04 <skypers> for instance, instantiating a value and access them from a lot of different places
10:39:13 <skypers> bitemyapp: I’m looking for the correct abstraction to do that
10:39:16 <bitemyapp> skypers: you can (I cringe as I say this) think of FRP as message sources sinking into stateful sinks.
10:39:30 <bitemyapp> skypers: actors'ish negotiated via a graph of functions
10:39:38 <bitemyapp> roboguy_: I dunno, I just work here.
10:39:42 <bitemyapp> ;)
10:39:54 <Fuuzetsu> jonsterling: by the way, is there a way to have vinyl see that records put together in the unexpected order are in the end same records? I had some tens-fields-long records and it was quite a ride to figure out if I had a missing field or a field out of order
10:40:15 <bitemyapp> runar for the love of god tweet less.
10:40:25 <bitemyapp> Apocalisp: where's your subtyping sum type thingy
10:40:28 <Fuuzetsu> bitemyapp: use search?
10:40:39 <bitemyapp> Fuuzetsu: you know, doesn't actually work that well for searching a single individual's tweet history.
10:40:46 <skypers> bitemyapp: hm
10:40:58 <skypers> do you know another way to solve that issue?
10:41:08 <skypers> STRef sounds a bit overkill
10:41:13 <jonsterling> Fuuzetsu: if you have a canonical order for the fields, you can just try casting each one to that and see what happens...
10:41:27 <bitemyapp> Fuuzetsu: long-standing gripe with Twitter, that.
10:42:24 <Fuuzetsu> jonsterling: nah, my problem was that I was parsing XML and while many sites had the same fields, they weren't necessarily in the same order so copy+paste hackjobs didn't work too well once it came to creating the records
10:42:33 <bitemyapp> Choice Runar quote from Twitter: "OK, no more subtyping. Subtyping is for assholes.'
10:42:46 <bitemyapp> I need to get drunk and just bring up every tweet of his that has curses in it.
10:43:00 <jonsterling> ah I see... yeah, I'm not sure what the best thing is there. probably a utility c
10:43:05 <jonsterling> Function could be written to help.
10:43:08 <monochrom> who is Runar?
10:43:18 <jmcarthur> sudden obvious realization: just as you can model a lot of things in typed languages as categories, you can model a lot of things in untyped/unityped languages as monoids.
10:43:41 <roboguy_> jmcarthur: you can model a lot of things as categories, including monoids
10:43:41 <bitemyapp> monochrom: Apocalisp I think. Scala/Haskell person. Worked on Scalaz I think.
10:43:42 <jmcarthur> monochrom: Apocalisp's name is Runar. that's probably the one
10:43:52 <jonsterling> Anyway, I need to go have my cup of oolong. Also, it's tiny, but if there are any Vinyl questions, I also live on #vinyl.
10:44:01 <jmcarthur> roboguy_: yes, but a monoid is more to the point when talking about untyped languages
10:44:03 <c_wraith> I do agree with him about subtyping.
10:44:06 <roboguy_> jmcarthur: but I know what you mean
10:44:35 <bitemyapp> jonsterling: this? https://gist.github.com/runarorama/9770894
10:44:42 <jmcarthur> roboguy_: the whole untyped is really unityped, so you have a category with one object, blah blah blah
10:44:48 <roboguy_> jmcarthur: right
10:44:49 <hiptobecubic> what makes un(i)typed languages better suited to monoids categories?
10:44:52 <hiptobecubic> than*
10:45:05 <roboguy_> hiptobecubic: they can be thought of as having only one type
10:45:19 <hiptobecubic> roboguy_, how is that useful, though?
10:45:19 <jmcarthur> hiptobecubic: monoids are kind of a specialization of categories
10:45:21 <jonsterling> bitemyapp: that's the one.
10:45:22 <c_wraith> hiptobecubic: well..  There's only one object in the set of types, so you don't need the power of categories.  monoids do the same thing
10:45:25 <roboguy_> hiptobecubic: and therefore they are sort of like a category with one object (i.e., a monoid)
10:45:49 <bitemyapp> jonsterling: cool. Thanks for verifying. Oolong is a favorite of mine, I usually got my tea at Vital or TenRen, where do you get yours?
10:45:53 <monochrom> I would think you would first make an untyped language typed (even with the help of imaginary depedent predicate types), and then you're back in a typed language
10:46:45 <jmcarthur> monochrom: one can often add extra structure to some monoid to get a category
10:46:53 <jonsterling> Read the nuprl book...
10:47:27 <monochrom> oh, so Runar is the Runar who posted "monad/comonad annihilation" https://twitter.com/runarorama/status/383648832174583808
10:47:46 <monochrom> ok, I commend Runar, everything he says is right!
10:48:00 <hiptobecubic> jmcarthur, on paper i understand the relationship between monoids and categories and that languages like python are unityped. What I don't understand is why it matters here.
10:48:13 <bitemyapp> monochrom: huh?
10:48:28 <jmcarthur> hiptobecubic: it matters only to the same extent that category theory matters
10:48:28 <monochrom> jmcarthur: I see. now I see that you're exactly right.
10:48:44 <monochrom> bitemyapp, what is your question? :)
10:49:41 <bitemyapp> monochrom: how did you conclude Runar is right about everything?
10:50:18 <monochrom> the same way I conclude that I am right about everything :)
10:50:29 <bitemyapp> monochrom: via the Tao? Got it.
10:50:36 <monochrom> I like monochrom. I like Runar. therefore they're right. :)
10:50:50 <bitemyapp> monochrom: groovy. :)
10:50:53 <Apocalisp> I like you too, monochrom
10:50:58 <monochrom> \∩/
10:51:08 <john_not_jenny> Out of curiosity, have you guys ever heard of any junior programmer positions that involve Haskell?
10:51:33 <c_wraith> john_not_jenny: well, I worked at a company that hired several people to junior positions involving haskell.
10:51:43 <bitemyapp> john_not_jenny: Galois has internships periodically.
10:51:47 <c_wraith> john_not_jenny: so, it happens.
10:51:59 <bitemyapp> john_not_jenny: it probably depends on how much of a training culture they have.
10:52:02 <john_not_jenny> Okay, so there is hope!
10:52:05 <bitemyapp> which is really the kind of company you want to work at anyway.
10:58:54 <hiptobecubic> c_wraith, interesting. doing what?
10:59:07 <c_wraith> web service development
10:59:39 <athan> I can't get into their website lol
10:59:44 <Tene> I think my company hired a couple, but they're not hiring any junior positions right now.
10:59:49 <bitemyapp> c_wraith: I would argue it's wiser to have the jun-yahs using Haskell than something untyped :)
10:59:53 <john_not_jenny> athan, I was having that problem. I think it was my VPN.
11:00:02 <BrianHV> I'm trying to write a test for a "pure" function that calls error, to make sure error is called under the appropriate circumstances. my test case succeeds if I print the expression that calls error, but I haven't figured out the seq-like magic to make it work without print. any tips?
11:00:03 <BrianHV> https://github.com/brianhv/heist/blob/master/test/suite/Heist/SpliceAPI/Tests.hs
11:00:04 <athan> hmm, maybe
11:00:05 <jmcarthur> i guess the untyped equivalent of an endofunctor would be a... monoid endomorphism?
11:00:26 <monochrom> indeed, beginners and juniors alike should be inflicted the most restrictive language possible.
11:00:34 <roboguy_> jmcarthur: it would probably still be an endofunctor
11:00:59 <roboguy_> all of them would be on the same type though
11:01:38 <roboguy_> (looking at it from the monoid perspective at least)
11:01:40 <bitemyapp> roboguy_: it'd be an existential all-in-one type a for everything, always, forever.
11:02:06 <bitemyapp> so it's still the same endofunctor, but there isn't the possibility of anything else.
11:02:07 <jmcarthur> roboguy_: it still has some laws though, which is nice
11:02:48 <jmcarthur> roboguy_: f(x.y)=fx.fy  and  f(id)=id
11:02:52 <roboguy_> jmcarthur: yeah. well, laws are independent of whether things are statically checked or not (a lot of laws can't be statically checked in haskell)
11:02:59 <jmcarthur> right
11:03:23 <roboguy_> jmcarthur: I think that's a monoid homomorphism, more specifically
11:03:56 <jmcarthur> roboguy_: wikipedia says "Monoid homomorphisms are sometimes simply called monoid morphisms."
11:04:17 <jmcarthur> roboguy_: and i'm using "endomorphism" instead of "morphism" because it's the same monoid on both sides
11:04:45 <roboguy_> hmm, I guess all morphisms on a monoid have to be monoid homomorphisms because of the category laws. didn't think of that
11:05:42 * hackagebot bound 1.0.1 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-1.0.1 (EdwardKmett)
11:05:58 <monochrom> great title
11:06:31 <Fuuzetsu> cool package
11:06:39 <bitemyapp> that's pretty funny :)
11:07:10 <jmcarthur> i do like bound
11:07:15 <jmcarthur> it's very nice to use
11:07:29 <jmcarthur> something you can't say often when programming with binders
11:07:39 <_ikke_> Why is composing multipe function calls with . called point(less| free) style?
11:07:40 <jmcarthur> at least when first getting started
11:07:49 <roboguy_> _ikke_: a point is a binding
11:07:51 <roboguy_> not the .
11:08:02 <roboguy_> so if you have something like f x = x, the x is a point
11:08:10 <_ikke_> ah ok
11:08:13 <ph88> hey
11:08:18 <ph88> anyone know lenses ?
11:08:29 <jmcarthur> somebody does
11:08:29 <roboguy_> _ikke_: pointless style is specifically when a function is defined so that it has no explicit arguments (points)
11:08:33 <Fuuzetsu> never heard of them
11:08:48 <_ikke_> everybody has 2 lenses
11:08:50 <Fuuzetsu> ph88: there's #haskell-lens but you're pretty safe asking here too
11:08:50 <bitemyapp> ph88: never heard of them
11:08:54 <_ikke_> roboguy_: Right, makes sense that way
11:09:52 <ph88> Fuuzetsu: how do they work ? i wawtched some videos but i dont understand it
11:10:42 * hackagebot music-util 0.9 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.9 (HansHoglund)
11:12:07 <Fuuzetsu> ph88: by type magic, watch more videos
11:12:32 <ph88> like which one ?
11:13:57 <ReinH> ph88: the SPJ one is good
11:14:03 <ph88> what's referential transparaceny ?
11:14:35 <Fuuzetsu> there's a bunch on the net; do you need to know how they work or just how to use them?
11:14:48 <bitemyapp> ph88: don't worry about referential transparency
11:15:10 <ph88> Fuuzetsu: i need to know why they are useful and what you can do with it
11:15:17 <ReinH> jmcarthur: is a monoid endomorphism automatically iso and therefore an automorphism?
11:15:19 <bitemyapp> ph88: all that really matters if you're new to Haskell is, "effects are explicit and typed, rather than implicit and untyped"
11:15:43 * hackagebot bound 1.0.2 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-1.0.2 (EdwardKmett)
11:15:45 * hackagebot music-util 0.9.1 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.9.1 (HansHoglund)
11:15:49 <bitemyapp> ph88: I use lenses and prisms for striding across paths of nested types without breaking out intermediate cases I don't care about.
11:15:59 <bitemyapp> ph88: lenses stride products, prisms stride sums.
11:16:06 <bitemyapp> each are the dual of the other.
11:16:30 <ph88> is a prisms the same as a fold then ?
11:16:35 <jmcarthur> ReinH: i doubt it, but haven't come up with a good explanation of why yet
11:16:38 <ReinH> bitemyapp: also monoid endomorphisms form... a monoid.
11:16:57 <Fuuzetsu> we have to go deeper
11:16:59 <jmcarthur> endomorphisms for a monoid :)
11:17:02 <jmcarthur> *form
11:17:10 <ReinH> yep :)
11:17:28 <ReinH> Monoidception
11:18:05 <roboguy_> ReinH: you could have a monoid endomorphism that forgets some of it's internal structure and there for be unable to define an isomorphism
11:18:14 <bitemyapp> ph88: I've no idea. My initial impulse is to say no, but it's intuition not something I've proven.
11:18:17 <_ikke_> How does this work: "where   foldingFunction (x:y:ys) "*" = (x * y):ys". I'm refering to the pattern matching part
11:18:18 <ReinH> roboguy_: what structure might it forget?
11:18:30 <jmcarthur> ReinH: consider the monoid endomorphism that maps every morphism to the identity function (at least i think that's a monoid endomorphism. i'm not used to thinking about these yet)
11:18:31 <ReinH> The monoid structure is the product and unit, which the morphism preserves
11:18:32 <roboguy_> ReinH: maybe it turns real numbers into integers
11:19:05 <roboguy_> there aren't enough integers to go back
11:19:13 <ReinH> roboguy_: that's not an endomorphism
11:19:14 <jmcarthur> i think my use of "morphism" is too category theory oriented for this
11:19:30 <roboguy_> ReinH: it's an endomorphism on reals. the function just happens to pick reals that are integers
11:19:49 <roboguy_> morphism, I should say
11:20:03 <ReinH> Ok, so if the mapping is surjective but not injective. That makes sense, doesn't it.
11:20:10 <roboguy_> yeah
11:21:00 <ReinH> wait
11:21:07 <ReinH> does that preserve distribution?
11:21:12 <roboguy_> distribution?
11:21:18 <jmcarthur> ReinH: a better way of stating my example, i think.   map every function to the identity.
11:21:28 <ReinH> f (x . y) = f x . f y
11:21:30 <jmcarthur> ReinH: in haskell:     f (Endo _) = Endo id
11:21:31 <favetelinguis> anyone using lighttable with haskell?
11:21:34 <roboguy_> right, that is a better example jmcarthur
11:21:54 <roboguy_> ReinH: why does that need to hold?
11:22:08 <ReinH> roboguy_: because it's necessary for a monoid morphism?
11:22:13 <jmcarthur> roboguy_: it's a law of monoid morphisms
11:22:17 <roboguy_> oh right
11:22:21 <jmcarthur> roboguy_: so is   f id = id
11:23:19 <Fuuzetsu> @hoogle Map k v -> (v -> Bool) -> k
11:23:20 <lambdabot> No results found
11:23:22 <Fuuzetsu> @hoogle Map k v -> (v -> Bool) -> [k]
11:23:23 <lambdabot> No results found
11:23:34 <ReinH> jmcarthur: so in your case, it does hold right?
11:23:46 <ReinH> Fuuzetsu: what are you trying to do?
11:23:47 <_ikke_> Can anyone explain how the pattern matching in this code works? http://lpaste.net/102312 It seems it is matching in two parts.
11:24:17 <jmcarthur> ReinH: yes
11:24:27 <jmcarthur> ReinH: but it's not an automorphism
11:24:29 <ReinH> yep, since everything is just id
11:24:33 <ReinH> jmcarthur: yep
11:24:37 <ReinH> jmcarthur: so QED
11:24:37 <Fuuzetsu> ReinH: check each entry to the map and if one matches up with whatever function, I want to return that one. I guess I'll just use filter with safeHead
11:24:50 <roboguy_> _ikke_: foldingFunction is just a normal function. it just happens to be in a "where" clause of another function
11:25:14 <ReinH> Fuuzetsu: you want to return the first or all of them?
11:25:29 <Fuuzetsu> first
11:25:34 <ReinH> Fuuzetsu: safeHead or listToMaybe, yes
11:25:35 <Fuuzetsu> I only ever should have 1 but who knows
11:25:53 <Fuuzetsu> IIRC safeHead doesn't actually exist, I just keep forgetting the name of listToMaybe
11:26:13 <roboguy_> _ikke_: does that help?
11:26:45 <_ikke_> roboguy_: But how does (x:y:ys) "*" work? It seems to first match the whole list, (x:y:xs), and then another "*". Where is that last "*" matched against?\
11:27:05 <roboguy_> _ikke_: ignore the (x:y:ys) for the moment. "*" just matches on the second argument
11:27:07 <jmcarthur> that was the untyped equivalent of a functor. now i wonder what the untyped equivalent of a monad is.
11:27:10 <tommd> Fuuzetsu: See the 'safe' package for functions like that.
11:27:34 <jmcarthur> presumably it is different, since it is typically different operationally
11:27:50 <roboguy_> _ikke_: (x:y:ys) is for the first argument and "*" is for the second argument
11:27:55 <_ikke_> roboguy_: right
11:28:10 <_ikke_> Ah, ok, right
11:28:52 <jmcarthur> i guess it's a monoid on monoid endomorphisms?
11:29:54 <ReinH> Fuuzetsu: ala First foldMap . mapWithKey (\k v -> if p k then Just v else Nothing)
11:30:00 <Fuuzetsu> tommd: listToMaybe is in Data.Maybe
11:30:03 <skypers> if I have newtype M a b = … deriving (Monad)
11:30:18 <skypers> it instances Monad (M a)
11:30:21 <skypers> right?
11:30:24 <roboguy_> jmcarthur: that makes sense to me
11:30:29 <ReinH> monochrom: uh, insert obligatory "monoid in the category of endomorphisms"
11:30:45 * hackagebot dvda 0.4 - Efficient automatic differentiation and code generation  http://hackage.haskell.org/package/dvda-0.4 (GregHorn)
11:31:38 <Fuuzetsu> findKeyFromValue f = listToMaybe . M.keys . flip M.filter f
11:31:42 <Fuuzetsu> is what I have
11:31:46 <tommd> Fuuzetsu: Yes, I know.  It was my impression you were looking for total functions to replace some or many partial functions common in the Prelude, in which case you can look at the 'safe' package.
11:32:06 <Fuuzetsu> tommd: Ah, right. Nah, I know about safe, I usually just pattern match everything though
11:32:12 <Fuuzetsu> when sensible
11:32:23 <ReinH> Fuuzetsu: hmm, you could fuse mine into a single pass using fold/map fusion laws
11:32:29 <ReinH> I wonder if GHC would do that for you
11:32:35 <ReinH> Fuuzetsu: yours too probably
11:32:50 <Fuuzetsu> ReinH: First from lens right?
11:32:58 <ReinH> First is from Monoid iirc
11:33:01 <Fuuzetsu> oh
11:33:04 <ReinH> ala is from lens
11:33:08 <Fuuzetsu> pfft
11:33:23 <ReinH> same as getFirst . foldMap First if you aren't already using lens
11:33:28 <Fuuzetsu> I'll consider using it when I inevitably end up adding lens to the project
11:34:37 <ReinH> Fuuzetsu: a single fold over the map would probably be pretty easy to write
11:35:10 <ReinH> hmm
11:40:43 * int-e ponders the abuse potential of adding https://github.com/mokus0/lambdabot/pull/77 to lambdabot
11:41:42 <Fuuzetsu> -1
11:42:02 <Fuuzetsu> seems pointless, just use /away or something
11:42:29 <Fuuzetsu> oh unless it's meant to work with @tell
11:42:38 <int-e> it's for @tell
11:42:50 <Fuuzetsu> then I see no problem or potential for abuse
11:43:08 <Fuuzetsu> just rate limit the auto-reply to the same user
11:50:47 * hackagebot wai-route 0.1.2 - Minimalistic, efficient routing for WAI  http://hackage.haskell.org/package/wai-route-0.1.2 (romanb)
11:58:01 <Fuuzetsu> why does aeson offer decodeStrict but not encodeStrict
12:03:06 <haasn> what would encodeStrict do?
12:03:38 <haasn> oh, I see; it returns a Lazy BS
12:07:02 <Fuuzetsu> yeah
12:07:32 <Fuuzetsu> sure you can argue that you can just use toStrict but the same holds for encode[Strict]
12:07:38 <Fuuzetsu> decode[Strict] rather
12:15:25 <int-e> edwardk: Can you think of a reason why any of these modules should not be Trustworthy: Control.Lens.Action, Control.Lens.Each, Control.Lens.Empty, Control.Lens.Level, one of Control.Lens.Internal.ByteString or Data.ByteString.Lens? If not I can make a pull request.
12:15:50 * hackagebot learn-physics 0.3 - Haskell code for learning physics  http://hackage.haskell.org/package/learn-physics-0.3 (ScottWalck)
12:15:57 <int-e> edwardk: (the list is demand driven; those modules are pulled in by lambdabot)
12:16:22 <ReinH> Fuuzetsu: well, making that fold productive was an interesting exercise
12:17:03 <Fuuzetsu> ReinH: I managed to forget all about it already, blazing through to the next parts ;P
12:17:06 <Fuuzetsu> what did you get?
12:17:19 <ReinH> https://gist.github.com/
12:17:39 <ReinH> Fuuzetsu: basically just fused the foldMap First with the function from k v to Maybe v
12:18:10 <ReinH> Fuuzetsu: I found out that there are lots of ways to write that folding function that aren't productive
12:18:29 <ph88> Fuuzetsu: i'm watching this video   https://www.youtube.com/watch?v=efv0SQNde5Q   the guy does bar = foo.copy(_2 = foo._2.copy(_2 = 4))    why does he do that ?
12:18:39 <Fuuzetsu> you didn't actually paste in the appropriate gist, ReinH
12:18:46 <ReinH> er you are right
12:18:52 <ReinH> oh I have to save it. I suck at internets
12:18:55 <ReinH> https://gist.github.com/reinh/1df9a59e1e8887a91379
12:19:14 <ph88> what does that mean "change a field of a field" ?? it's like a 2 dimensional array ?
12:19:15 <Fuuzetsu> ph88: that guys is edwardk so you might want to ask him personally ;P
12:19:27 <ph88> oh lol
12:19:35 <ph88> i will if he's around then :P
12:19:41 <Fuuzetsu> and no, it just means nested structure (but it could be a list in a list, maybe representing a 2D array)
12:19:57 <ph88> ah right gotcha
12:20:28 <ph88> why can't he grab the second element directly and copy that ?  like foo._2._2.copy()  or something
12:20:35 <ReinH> Fuuzetsu: I tried to just write the folding function out a few times before I gave up and just did the fusing by simple mechanical substitution :p
12:20:42 * DogeHayashi notes he needs to learn lens at some point
12:21:30 <Fuuzetsu> ReinH: bleh, 4 lines
12:21:33 <ReinH> Fuuzetsu: I couldn't figure out a way to make it non-strict in its second argument :/
12:21:43 <ReinH> Fuuzetsu: it's just an exercise at this point
12:22:18 <Fuuzetsu> sure; I don't expect to have a nonstrict list of connected network clients anyway ;)
12:22:34 <Fuuzetsu> well, where strictness matters anyway
12:22:42 <ReinH> it's basically getFirst . Map.foldMapWithKey ( \k v -> First (go k v) ) where go k v = if p k then Just v else Nothing
12:23:54 <ReinH> or Map.foldMapWithKey ((First .) . go) if you're into that kind of thing
12:24:30 <ReinH> Fuuzetsu: it was interesting how difficult it was to write a productive folding function without leveraging the fold/map fusion laws
12:24:32 <Fuuzetsu> (f .) . g
12:24:49 <ReinH> Fuuzetsu: a rather annoying way to compose functions of two arguments
12:24:49 <Fuuzetsu> saddens me because there's still no official place where it is defined
12:24:52 <ReinH> yep
12:25:00 <ReinH> fmap f . g is sort of ok though
12:25:04 <ReinH> maybe
12:25:17 <Fuuzetsu> …I think that's worse
12:25:20 <ReinH> heh
12:25:39 <Fuuzetsu> it does save parens but makes it much harder to see which fmap it actually is
12:25:57 <ReinH> yeah I dunno
12:27:09 <ReinH> Fuuzetsu: anyway the foldMap takes advantage of First's productivity and does it in a single pass without depending on GHC to optimize away via foldr/map or map/filter fusion rules
12:27:17 <ReinH> who knows if that's important to your use case :)
12:27:53 * Fuuzetsu writes code until the types line up, worries about strictness later if need be
12:27:59 <ReinH> Fuuzetsu: :) seems good
12:28:25 <ReinH> Fuuzetsu: I just enjoy opportunities to excercise with strictness because I still don't grok it
12:28:45 <Fuuzetsu> me neither, wasn't forced to yet
12:29:47 <ReinH> figuring out that you (generally) want the folding function for foldl to be strict in its first argument and foldr to be non-strict in its second helped me grok things a bit better
12:35:38 <Fuuzetsu> I'm guessing nesting withMVar on the same MVar will deadlock?
12:36:02 <mizu_no_oto> Are there any profiler visualization tools for time spent in cost centers other than tkyprof?
12:36:15 <Kiryx> > let a = read "5"
12:36:16 <lambdabot>  not an expression: `let a = read "5"'
12:36:29 <Fuuzetsu> > let a = read "5" in (a :: Int)
12:36:30 <lambdabot>  5
12:36:42 <Kiryx> Fuuzetsu: Thanks :)
12:36:47 <Kiryx> I haven't got to "in" yet
12:37:15 <Fuuzetsu> ‘let’ without ‘in’ only works inside of ‘do’
12:37:35 <Kiryx> not there yet either :)
12:38:01 <Fuuzetsu> I'm surprise you know about ‘let’ and not ‘in’ then
12:38:06 <Fuuzetsu> surprised*
12:38:13 <ReinH> Fuuzetsu: and ghci (which is more or less inside a do block)
12:38:24 <Fuuzetsu> Right.
12:38:25 <Kiryx> I take is as magic word which makes definitions possible in ghci for now
12:38:31 <ReinH> ^ ;)
12:38:53 <Fuuzetsu> Yeah, I see. lambdabot is a bit different than GHCi and GHCi is a bit different than writing in a file ;P
12:39:04 <prophile> let x = y in z just constrains the definition to the expression "z"
12:42:43 <Kron> holy crap why can't haskell-mode split pattern variables into clauses, or can it?
12:42:50 <Kron> I'm learning about idris mode and it's really nice
12:43:32 <Fuuzetsu> it wasn't nice few months ago
12:43:47 <Fuuzetsu> does it show messages without having to mouse over underlined parts in the buffer yet?
12:43:57 <Kron> yeah but C-c C-c to split pattern variables into new clauses based on the constructor is really quite wonderful
12:43:58 <Fuuzetsu> Agda-mode is the amazing one
12:44:03 <migimunz> Hello. I'm writing a module that works solely with Data.Text, and most functions from that module (tail, head, etc) tend to clash with Prelude. Since I don't really need those functions in prelude, is there a way to use the unqualified versions of Data.Text.tail|head|etc without causing a clash?
12:44:05 <Kron> heh, alright
12:44:12 <Kron> then why doesn't haskell mode have agda mode stuff?
12:44:21 <Kron> yeah, migimunz
12:44:25 <Fuuzetsu> Kron: http://fuuzetsu.co.uk/blog/images/case-split-s.gif ;)
12:44:28 <Kron> import Prelude hiding (blah, blah)
12:44:32 <migimunz> Kron, thanks!
12:44:33 <Kron> it'll import all of prelude except those bits
12:44:35 <Kron> I do this a lot:
12:44:40 <Kron> import Prelude hiding (foldr)
12:44:48 <Kron> import Data.Foldable (foldr)
12:44:53 <migimunz> makes sense, thank you :)
12:45:07 <Kron> it means you get to keep the obvious useful ones like ++ and the like while scrapping the bits you want to upgrade
12:45:42 <Kron> Fuuzetsu: you are the best pony
12:46:10 <Fuuzetsu> I'm not a pony
12:46:11 <davean> would someone at hack nyc let us in?
12:46:39 <Fuuzetsu> usually one would call someone inside but I guess IRC works
12:47:53 <athan> hahaha
12:48:30 <davean> I tried calls
12:48:37 <davean> their phones seem off
12:48:46 <davean> at least he nubers I have
12:50:28 <copumpkin> @ask ClaudiusMaximus let's talk about the MPFR changes you made to rounded
12:50:28 <lambdabot> Consider it noted.
12:54:24 <Kiryx> > :t fromIntegral
12:54:25 <lambdabot>  <hint>:1:1: parse error on input `:'
12:54:43 <Kiryx> It's not ghci after all
12:54:49 <davean> Thanks, we're in
12:58:28 <johnw> @remember edwardk Zombies are expensive.
12:58:34 <lambdabot> Done.
12:58:56 <Fuuzetsu> is edwardk giving a talk at hack nyc right now, johnw?
12:59:06 <johnw> he's talking about some zombies in a javascript game he wrote
12:59:24 <johnw> he meant that their physics slows down the CPU
12:59:40 <haasn> johnw: is the conclusion that switching to ghcjs+linear is superior?
12:59:43 <Fuuzetsu> Yes, I imagined as much.
12:59:48 <johnw> haha
12:59:50 <haasn> Because if not, I'll be disappointed
12:59:56 <Fuuzetsu> does GHCJS produce enterprise quality code yet?
13:00:07 <Fuuzetsu> sorry, ENTERPRISE
13:00:22 <srhb> No, just webscale.
13:00:27 <ReinH> roflscale
13:05:01 <Fuuzetsu> Why does GHCi ignore the language extensions turned on in the module we're directly loading? It will load the file fine but if we try to use anything in GHCi using any of the extensions, it will complain and we have to enable them manually
13:07:01 <Tobani> That kind of makes sense... If you import a module from another file, it doesn't turn those extensions on transitively for the importing file.
13:07:31 <pavonia> It's not ignoring them, it activates them in the module being loaded, not in the interpreter
13:08:54 <mizu_no_oto> If I put a cost centre on the first expression in a function, will is capture computation from the function's where clauses?
13:09:45 <copumpkin> @ask ClaudiusMaximus specifically, the src directory used to contain a bunch of arch-specific folders (and a generic one) that are now missing and it's breaking my build :(
13:09:45 <lambdabot> Consider it noted.
13:10:10 <mizu_no_oto> i.e. "foo = {-# SCC foo #-} ackerman + 10 where  ackerman = ..."  will ackermann be attributed to the cost centre foo?
13:13:45 <c_wraith> mizu_no_oto: unless it has SCC annotations inside its own evaluation, yes.
13:14:00 <mizu_no_oto> thanks
13:22:22 <pjdelport> not strictly Haskell-related, but for puzzle enthusiasts: http://www.reddit.com/r/crypto/comments/2289mg/are_there_any_hand_ciphers_that_allow/
13:22:57 <pjdelport> What's a public-key cryptosystem that could be implemented by hand?
13:23:19 <dwcook> With enough paper, all of them!
13:23:50 * dwcook goes to the "not being helpful" corner
13:24:14 <pjdelport> (For some relevance, I implemented the factoradic deck-of-cards data encoding that I link to there using Haskell.)
13:36:11 <jophish> Why do types and unboxed types have different kinds?
13:36:14 <jophish> * and !
13:38:49 <Eduard_Munteanu> jophish: unboxed types have a different representation and semantics
13:39:21 <Eduard_Munteanu> jophish: e.g. functions need to know what they take in and return
13:39:32 <jophish> I suppose that makes sense
13:39:35 <startling> jophish, I suspect http://research.microsoft.com/Users/simonpj/Papers/unboxed-values.ps.Z has some answers but it's a ".ps.Z" file, annoyingly
13:39:49 <mizu_no_oto> How good is spilt for System.Random.Mersenne.Pure64?
13:40:08 <jophish> startling: OSX opened it somehow
13:40:09 <startling> jophish: I can upload a .pdf of it if you'd like
13:40:12 <jophish> Thanks Eduard_Munteanu, startling
13:40:20 <startling> jophish: yeah, os x knows how to do postscript
13:40:27 <joe9>  Conceptual_Mathematics_A_First_Introduction_to_Categories -- good read.
13:40:29 <Eduard_Munteanu> How do I make a HandleStream for HTTP's receiveHTTP if I intend to listen on a port?
13:40:39 <Eduard_Munteanu> @hoogle receiveHTTP
13:40:39 <lambdabot> Network.HTTP.HandleStream receiveHTTP :: HStream bufTy => HandleStream bufTy -> IO (Result (Request bufTy))
13:40:39 <lambdabot> Network.HTTP receiveHTTP :: HStream ty => HandleStream ty -> IO (Result (Request ty))
13:40:39 <lambdabot> Network.HTTP.Stream receiveHTTP :: Stream s => s -> IO (Result Request_String)
13:40:43 <startling> (but it actually renders to pdf)
13:41:55 <Eduard_Munteanu> @kind (->)
13:41:56 <lambdabot> * -> * -> *
13:42:02 <Eduard_Munteanu> Bleh.
13:42:44 <mizu_no_oto> Do I really want to keep my entire computation in the Rand monad, or can i keep a PureMT in a state monad, use split, and call runRand on each of my random simulations?
13:42:56 <beaky> hello
13:42:59 <beaky> how does cycle work
13:43:11 <dwcook> @src cycle
13:43:11 <lambdabot> cycle [] = undefined
13:43:11 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:43:19 <dwcook> beaky, it replaces the tail by the entire rest of the list.
13:43:19 <Eduard_Munteanu> Hi beaky.
13:43:37 <dwcook> Errr
13:43:40 <dwcook> not tail, []
13:43:43 <beaky> its pretty magical :D
13:43:52 <dwcook> It's not magical, it's just recursive
13:44:37 <matheus23> hello, has anybody experience with GTK2Hs? How do I draw a Font on a Surface that is Selectable and that I can find the metrics of? I'm not talking about showText or cairo's textPath
13:44:39 <dwcook> Basically xs' in that definition is defined in terms of itself
13:45:03 <beaky> how would i define cycle in C
13:45:09 <beaky> to make an infinite array
13:45:15 <Eduard_Munteanu> beaky: you wouldn't
13:45:18 <dwcook> You can't make an infinite array
13:45:22 <beaky> :(
13:45:27 <dwcook> You *can* do something similar with a linked list, which a Haskell list is
13:45:55 <dwcook> You just find the last element in the linked list and set its next element to the first element you were given
13:46:01 <dwcook> That'd mutate the list to be cyclic
13:46:35 <Eduard_Munteanu> That'd be a completely different thing though.
13:47:19 <johnw> you could make a cycle _iterator_ in C++, but not a cycled vector or array
13:47:53 * Eduard_Munteanu sighs...
13:48:04 <Eduard_Munteanu> Where do you get a HTTP parser?
13:48:13 <johnw> you hire an intern
13:48:29 <johnw> http-client doesn't have one?
13:48:36 <identity> i'm afraid @src cycle just broke my brain.
13:48:43 <johnw> @src cycle
13:48:43 <lambdabot> cycle [] = undefined
13:48:43 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:48:50 <dwcook> identity, what part do you have trouble with?
13:48:53 <johnw> identity: it's called "tying the knot"
13:48:59 <johnw> if you google that, you'll find some interesting articles
13:49:00 <identity> dwcook: the part with the cycle
13:49:01 <beaky> is it normal for bubblesort on 1000 reverse elements to take 49550 swaps?
13:49:20 <beaky> 4995008
13:49:25 <beaky> 499500*
13:49:27 <dwcook> identity, which part would that be?
13:49:32 <identity> dwcook: haha, the entire thing
13:49:37 <Eduard_Munteanu> johnw: I want to parse requests, and I can't tell how HTTP can be convinced to parse it for me. It seems to insist on some weird streams.
13:49:50 <peddie> beaky: is that O(n^2) would you say?  :P
13:49:50 <identity> let me .. hmm.
13:49:53 <amalloy> beaky: that sounds about right. that's close to 1000^2/2, right?
13:49:58 <beaky> oh
13:49:58 <dwcook> Well cycle [] is pretty straightforward – Trying to cycle an empty list is an error
13:50:07 <identity> dwcook: oh, yeah
13:50:08 <identity> I know that much
13:50:12 <johnw> > 1000^2/2
13:50:13 <lambdabot>  500000.0
13:50:15 <identity> I'm just not quite grokking how that's working
13:50:17 <dwcook> The other part can be rephrased like so: cycle xs = let xs' = xs ++ xs' in xs'
13:50:28 <johnw> Eduard_Munteanu: huh?
13:50:36 <identity> dwcook: yeah, but that doesn't make it any simpler really
13:50:40 <dwcook> So our result is this xs', which is defined as the given list appended to… xs'
13:50:51 <amalloy> prepended
13:51:04 <dwcook> Yes, prepended
13:51:11 <identity> hmm, oh, yeah
13:51:12 <identity> I get it.
13:51:33 <Eduard_Munteanu> johnw: I'm writing a proxy, and thought Network.HTTP.receiveHTTP :: HStream ty => HandleStream ty -> IO (Result (Request ty))  would help, but I can't tell how to make a HandleStream
13:51:34 <identity> it reminds me of the zip fib (tail fib)
13:51:35 <amalloy> identity: it's creating a circular data structure, where xs' has all the elements of xs, and then a pointer back to the start of xs'
13:51:45 <identity> I'm not sure if they are semantically similar but it 'clicks' in the same way for me
13:51:58 <amalloy> well, they're both self-referential data structures, yes
13:52:10 <johnw> Eduard_Munteanu: openStream or openSocketStream
13:52:36 <identity> amalloy: yeah, it's just the whole "defining itself in terms of itself" exactly in that manner that can be a bit weird to grok
13:53:28 <johnw> identity: http://www.haskell.org/haskellwiki/Tying_the_Knot
13:53:33 <identity> johnw: I'll take a look
13:53:40 <identity> thanks!
13:54:13 <Eduard_Munteanu> johnw: any idea what the parameters to openSocketStream mean?
13:54:16 <johnw> identity: you could have something like it in C by having a linked list whose final pointer is overwritten with a pointer back to the beginning.  Then to the person following the links, it seems infinite, but really it's not
13:54:53 <Eduard_Munteanu> openSocketStream :: String -> Int -> Socket -> IO (HandleStream bufType)
13:54:58 <identity> johnw: yeah, linked lists with the explicit pointer and so on are still simpler
13:55:00 <jophish> OverloadedStrings seems like a handy thing. Is this correct?
13:55:10 <Eduard_Munteanu> jophish: yes
13:55:19 <jophish> super
13:55:21 <identity> (IMO)
13:55:22 <jophish> thanks, Eduard_Munteanu
13:55:51 <dwcook> There is an explicit pointer, it's the second argument to (:)
13:55:53 <johnw> Eduard_Munteanu: probably a hostname for the binding, port and the socket?
13:56:25 <dwcook> cycle (1:[]) = let xs = 1:xs in xs
13:56:29 <johnw> it's pretty horribly under-documented
13:56:33 <johnw> even in all the instances I'm finding
13:57:02 <Eduard_Munteanu> johnw: er, looking at the instances, it doesn't do that at all... it seems to connect *to* the target
13:57:18 <johnw> oh, yeah, hmm
13:57:20 <Eduard_Munteanu> e.g. openStream       = openTCPConnection
13:57:23 <johnw> right
13:57:37 <johnw> my brain was desrever
13:59:02 <JagaJaga> hi! I'm trying to write my own parsec (just a little copy with few functions). Can smone give me ideas, how to get errors from many and many1 functions?
13:59:38 <Eduard_Munteanu> JagaJaga: it may help to use (<?>)
13:59:53 <JagaJaga> Eduard_Munteanu, can you explaing it work?
14:00:01 <JagaJaga> explain
14:00:05 <PhineasRex> Does anyone know of an excerpt function for blaze-html where "excerpt 5 <p>Five characters</p>" == "<p>Five </p>"> I'l,'['
14:00:17 <beaky> I love object-oriented programming
14:00:19 <Eduard_Munteanu> JagaJaga: p <?> "foo" annotates p by "foo" such that it's displayed as an error message if p fails.
14:00:42 <PhineasRex> I'm prepared to write it myself, I just feel like this should already exist.
14:01:09 <JagaJaga> Eduard_Munteanu, oh! nice.
14:01:19 <jmcarthur> beaky: i believe you like to push peoples' buttons :)
14:01:37 <Eduard_Munteanu> I love buttons!
14:02:10 <beaky> but i wonder how hard can it be to make a dsl with smalltalk-style oo or something
14:02:14 <beaky> in haskell
14:02:24 <jmcarthur> beaky: look at OHaskell
14:03:11 <pordan30> is there a preferred graph library for haskell? hackage lists several, including fgl and data.graph from containers. the use case is data visualization and layout, so having access to standard graph algorithms (minimum spanning tree, feedback arc set heuristics, etc.) would be a plus.
14:03:25 <jmcarthur> beaky: http://arxiv.org/pdf/cs/0509027.pdf
14:04:56 <pavonia> PhineasRex: Are you parsing HTML code?
14:05:06 <PhineasRex> Yes.
14:05:59 <PhineasRex> pavonia: I'm switching my website over to Yesod.
14:06:17 <pavonia> Hhm, I thought blaze-html is only for the opposite, i.e. rendering
14:08:38 <JagaJaga> Eduard_Munteanu, I'm right, that we use it usually after some <|>?
14:10:35 <PhineasRex> pavonia: The parsing happens in Yesod's Forms package.
14:10:48 <pordan30> beaky: there is also a good discussion of purely functional object systems in peirce's tapl, although the implementation won't map directly to haskell
14:10:57 <Lethalman> about blaze-html
14:11:09 <Lethalman> what would be the name of such a monad where "return" is not allowed?
14:11:11 <Lethalman> i.e. only bind
14:13:09 <pavonia> PhineasRex: Well, if you have a blaze HTML structure you could use "fmap (take 5) paragraph"
14:13:37 <pavonia> Lethalman: That wouldn't be a monad
14:13:48 <Lethalman> pavonia, eh what's the name
14:14:06 <pavonia> I don't know
14:14:07 <dwcook> Lethalman, just (>>=), or just that and the Applicative operations besides return/pure?
14:14:46 <dwcook> i.e., are fmap and (<*>) still available?
14:14:48 <Lethalman> dwcook, mh I think just >>=, blaze-html is only that... not sure it's also applicative, don't remember
14:15:26 <dwcook> So you want to know if there's a categorical term for things that you just know how to do f a -> (a -> f b) -> f b on?
14:15:58 * dwcook guesses there isn't
14:16:21 <Lethalman> dwcook, yes...
14:16:38 <Lethalman> dwcook, something that builds things up, and ends up in ()
14:16:58 <dwcook> I say that because not only do you no longer have a monoid, which "monad" implies, but (>>=) isn't in the standard categorical formulation
14:17:04 <dwcook> Ends up in ()? What?
14:17:06 <Lethalman> mh no
14:17:09 <Lethalman> sorry confused ;)
14:18:10 <Lethalman> dwcook, see MarkupM http://hackage.haskell.org/package/blaze-markup-0.6.0.0/docs/src/Text-Blaze-Internal.html
14:18:35 <dwcook> Which part in particular?
14:18:44 <pavonia> You can use return in blaze-html but only with ()
14:19:00 <Lethalman> dwcook, Monad MarkupM
14:19:05 <Lethalman> dwcook, also Markup = MarkupM ()
14:19:42 <dwcook> Seems like an abuse of Monad to me
14:19:59 <startling> it should just be Writer.
14:20:02 <dwcook> At a glance this might be better used as a Monoid
14:20:11 <startling> yeah, Writer + a monoid
14:20:28 <startling> I think the (>>=) semantics are kind of weird though.
14:20:35 <Lethalman> yes it's an abuse for using "do"
14:21:18 <johnw> MarkupM defines return _ = Empty, which I think violates the laws, for the same reason that Const can't be a Monad: return x >>= f /= f x
14:26:05 * hackagebot hpc-coveralls 0.1.2 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.1.2 (killy971)
14:33:45 <PhineasRex> pavonia: Does fmap work that way for Html?
14:33:54 <PhineasRex> Isn't it MarkupM ()
14:34:15 <jforce93> I'm building a haskell program that essentually does Monte Carlo simulation to approximate the are under a curve (the definite integral). I'm using randomR to generate an x value, and randomR to generate a y value; but I don't want to pass around the limits of these ranges. Is it possible to 'wrap up' the following code: "randomR (0.0, 2.0)" to get a function that I can pass the generator to, and get out a random value between 0 a
14:34:38 <pavonia> PhineasRex: Html = Markup = MarkupM ()
14:35:11 <Lethalman> :t randomR (0.0, 2.0)
14:35:12 <lambdabot> (Fractional a, RandomGen g, Random a) => g -> (a, g)
14:35:18 <Lethalman> jforce93, ^^ this is your function
14:36:49 <bergmark> jforce93: if defining a top level value isn't what you want, take a look at Control.Monad.Reader
14:38:07 <PhineasRex> pavonia: Exactly. Blaze just disregards the first argument to fmap and then unsafeCoerces the second.
14:39:08 <pavonia> PhineasRex: Oh, you're right, it doesn't make sense here
14:40:43 <jforce93> Okay, thanks!
14:43:14 <jophish> Would it make sense to have 1-tuples?
14:43:19 <hpc> no
14:43:37 <hpc> or yes, and it's called Identity
14:46:17 <Fuuzetsu> isn't there a function somewhere in conduit that's a shortcut for ‘shortcut f = awaitForever . yield f’?
14:49:27 <Fuuzetsu> mapOutput looks good
14:51:30 <Fuuzetsu> I'd imagine there would be an operator for this…
14:51:58 <nh2> is there any package that implements finding the k-th largest element in a list?
14:52:27 <Cale> nh2: You could just use Data.List.sortBy (flip compare)
14:52:29 <johnw> Fuuzetsu: isn't that just mapC?
14:52:32 <Cale> and then take the kth element
14:53:11 <johnw> @src (&&&)
14:53:12 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
14:53:35 <johnw> hmm.. I was expecting: \x -> (f x, x)
14:53:45 <nh2> Cale: do I have a guarantee that it will be linear time?
14:53:47 <ion> @type first
14:53:48 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
14:53:51 <Cale> nh2: I believe so.
14:54:09 <nh2> Cale: how comes? I don't even know which sorting algorithm `sort` uses
14:54:15 <pavonia> Sorting in linear time?
14:54:17 <Cale> nh2: So long as you only observe a number of elements of the list which is bounded by a constant
14:54:20 <Fuuzetsu> johnw: No idea! I barely speak conduit
14:54:22 <nh2> pavonia: not sorting, selection
14:55:05 <Twey> johnw: Not all arrows are functions.
14:55:16 <Cale> nh2: I believe the sorting algorithm used is a bottom-up mergesort which splits the list into single element lists and successively merges them.
14:55:20 <Twey> :t (&&&)
14:55:20 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
14:55:43 <Twey> johnw: a may not be (→), so returning a lambda doesn't match the type
14:55:49 <Cale> If you don't use the entire resulting list, you do save work.
14:55:57 <johnw> Twey: Ah
14:56:06 <johnw> I keep forgetting Arrow can have other instances ;)
14:56:11 * Twey chuckles.
14:56:41 <johnw> Fuuzetsu: I'm pretty sure that's exactly what that is.  Also, don't you mean awaitForever . yield . f?
14:57:10 <Fuuzetsu> Yeah, I did mean that
14:57:38 <johnw> yep, that's mapC :)
15:00:51 <nh2> Cale: oh well, this in ghci eats all my memory: `sort [1..40000000] !! 0`
15:01:23 <Cale> nh2: Ah, it might be time-efficient, but it's probably not space-efficient.
15:02:02 <nh2> Cale: wikipedia even says it: http://en.wikipedia.org/wiki/Selection_algorithm "Indeed for lazy languages, this simplistic approach can even achieve the best complexity possible for the k smallest/greatest sorted (with maximum/minimum as a special case) if the sort is lazy enough."
15:02:16 <nh2> would be nice if they actually gave an example
15:02:50 <schlegel> hmm
15:04:20 <startling> nh2: takes roughly equal time as "minimum [1..40000000]" for me (and I've got plenty of memory)
15:05:26 <schlegel> [1..40] is just sugar for `enumFromTo 1 40` is it not?
15:05:48 <startling> yeah.
15:06:13 <johnw> schlegel: all the transforms are listed here: https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
15:08:15 <schlegel> so couldn't you optimize using a rewrite rule of some sort
15:14:01 <tristan__> to lowercase a ByteString should I relaly just convert to Text and then back to ByteString...
15:14:31 <startling> tristan__: lowercasing a bytestring isn't a well-defined operation.
15:14:49 <tristan__> figured, since it doesn't know the encoding?
15:14:53 <startling> tristan__: yeah.
15:15:13 <startling> tristan__: also, if you want to deal with most unicode encodings, folds are hard.
15:15:16 <tristan__> with more libs used Text instead of ByteString
15:15:36 <startling> i wonder if stream fusion works with char-wise folds of bytestrings.
15:16:11 * hackagebot data-extra 2.5.4 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-2.5.4 (ChrisDone)
15:17:50 <lispy> Does lambdabot have Data.Map in scope? Looks like it has IntMap
15:18:14 <monochrom> it does, but not sure under which name. perhaps Map.
15:18:15 <startling> > M.fromList [("lispy", "yes")]
15:18:16 <lambdabot>  fromList [("lispy","yes")]
15:18:26 <startling> :t M.fromList [("lispy", "yes")]
15:18:26 <lambdabot> M.Map [Char] [Char]
15:19:38 <lispy> thanks
15:20:20 <tlevine> Is there a nice library for parsing Nginx logs?
15:24:15 <koala_man> I have a maybeDoStuff :: Maybe (IO ()) that I run with  fromMaybe (return ()) maybeDoStuff, but I can't help but feel like there's a better way
15:24:38 <bitemyapp> tlevine: Probably not baked into a library as such but: https://github.com/tobie/ua-parser
15:24:47 <bitemyapp> tlevine: that plus parsec should do the trick.
15:25:32 <monochrom> @type maybe
15:25:33 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:25:41 <lispy> :t for
15:25:42 <lambdabot>     Not in scope: `for'
15:25:42 <lambdabot>     Perhaps you meant one of these:
15:25:42 <lambdabot>       `T.for' (imported from Data.Traversable),
15:25:43 <monochrom> @type fromMaybe
15:25:44 <lambdabot> a -> Maybe a -> a
15:25:46 <lispy> :t T.for
15:25:47 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
15:26:13 <monochrom> I think fromMaybe is as good as you can get
15:26:37 <koala_man> aww. ok, thanks
15:26:57 <ion> @type F.sequence_
15:26:58 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
15:27:12 <ion> @type F.sequence_ `asAppliedTo` (undefined :: Maybe (IO ()))
15:27:13 <lambdabot> Maybe (IO ()) -> IO ()
15:27:40 <johnw> that's good
15:28:01 <johnw> i keep forgetting that Foldable's sequence can be used with Maybe
15:30:07 <lispy> :t sequenceA_ (Just (return ())
15:30:08 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:30:16 <lispy> :t sequenceA_ (Just (return ()))
15:30:17 <lambdabot>     Not in scope: `sequenceA_'
15:30:17 <lambdabot>     Perhaps you meant one of these:
15:30:17 <lambdabot>       `F.sequenceA_' (imported from Data.Foldable),
15:30:22 <lispy> :t F.sequenceA_ (Just (return ()))
15:30:23 <lambdabot> (Monad f, Applicative f) => f ()
15:30:44 <amalloy> ion: what is asAappliedTo? i don't see it on hoogle. is it something like: f `asAppliedTo` x = snd (f x, f)?
15:31:04 <johnw> it's something lambdabot has defined
15:31:07 <johnw> @src asAppliedTo
15:31:07 <lambdabot> Source not found. My brain just exploded
15:31:25 <lispy> :t asAppliedTo
15:31:25 <lambdabot> (a -> b) -> a -> a -> b
15:31:34 <dwcook> It's just const, basically
15:31:48 <lispy> Yeah, you probably should read it as (a -> b) -> a -> (a -> b)
15:31:51 <dwcook> asAppliedTo :: (a -> b) -> a -> a -> b ; asAppliedTo = const
15:41:18 * hackagebot git-annex 5.20140405 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140405 (JoeyHess)
15:46:35 <haasn> amalloy's definition works and infers to the exact same type, too
15:50:06 <amalloy> i bet with optimizations on they compile to the same thing as well
15:52:46 <dwcook> Yeah, wasn't saying it was wrong, but there's value in noticing how things unify
15:56:43 <quchen> asAppliedTo can be anything, since its only use is having the type that it has
15:57:23 <dwcook> I don't know, someone could have found some use for its type-restricting properties
15:57:55 <dwcook> Well one I can think of off the top of my head is to make an ambiguous instance monomorphic
16:01:54 <mindleyhilner> is it possible to remote compile a cabal install?
16:03:54 <bitemyapp> jonsterling: *thank* you for tweeting that defunctionalization blog post.
16:04:07 <bitemyapp> I really should've been paying more attention to Singletons.
16:04:11 <hpc> bitemyapp: what is this?
16:04:15 <bitemyapp> jonsterling: this dove-tails with something I did just earlier today!
16:04:18 <bitemyapp> http://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/
16:04:23 <bitemyapp> hpc: great post :)
16:04:45 <jonsterling> Np! Depending on how much evil I can force it to do, it may become very useful to me.
16:04:59 <bitemyapp> jonsterling: I saw the bits about improving Vinyl. Sounds exciting.
16:05:14 <bitemyapp> jonsterling: it's cool when we can steal from things like SHE :)
16:05:26 <jonsterling> Right—If it's flexible enough, I may be able to fix a lot of the complication arising in Vinyl. But it might make it worse, I'm not certain yet.
16:06:12 <hpc> that's awesome
16:06:21 <bitemyapp> jonsterling: any concern about runtime benchmarks?
16:06:32 <jonsterling> bitemyapp: I haven't thought that far yet...
16:06:43 <bitemyapp> jonsterling: s'okay. Just idly curious as I read this article.
16:06:58 <jonsterling> bitemyapp: More just thinking as to whether I can force this to do just what I want... Any thoughts on the performance implications of using something like that?
16:07:33 <bitemyapp> jonsterling: oy vey, none. You're way way ahead of me, so if anybody had any intuition for such, it'd be you.
16:07:45 <jonsterling> Agh, but I literally know nothing about performance or anything like that.
16:07:51 <jonsterling> I just do astronautics pretty much.
16:07:58 <bitemyapp> jonsterling: I was momentarily contemplating compile-time resolution of kinds given an N cardinality, but that's just another idle thought.
16:09:12 <bitemyapp> jonsterling: my experience and knowledge around performance concern bytecode languages, more traditional static languages like C and C++, and dynamically interpreted ones like Python and Ruby. I can squint at Haskell and make an educated guess, but stuff this far off into the blue yonder I've got no experience with for benchmarking.
16:09:50 <bitemyapp> jonsterling: I can speak to what'll kill performance for basic numerics, parsing, etc work from having work on or with libraries from either category, but again, not much to do with Vinyl or Singletons.
16:10:06 <bitemyapp> It's not even clear to me which parts of this library are compile vs. runtime.
16:11:08 <bitemyapp> gad. this is making me want to write a benchmark. Must resist.
16:11:30 <bitemyapp> benchmarks without specific goals/preferences are unprincipled and unwise.
16:21:17 <luite> hm, i got the static init working also with the packed static data now, but i missed some things required for incremental linking (too many distractions here, like hiking... err, tramping) so i'll need to fix that first
16:21:57 <luite> and that was meant for #ghcjs, sorry, mobile connection is laggy
16:23:00 <dfrey> Hi, I'm trying to work through the exercises from https://github.com/NICTA/course    I'm working on the Apply.hs file and am trying to understand the (*>) operator aka "right apply".  I am looking at the solution here (https://github.com/tonymorris/course/blob/master/src/Course/Apply.hs#L165) and I understand the solution, but I don't understand the purpose of the function in general.  So my question is:
16:23:02 <dfrey> What is the general usefulness of such a function?
16:23:35 <Eduard_Munteanu> dfrey: when you want to skip something in a parser, for example
16:24:26 <jmcarthur> dfrey: it is the same as (>>), so if you know the purpose of that then you know the purpose of (*>)
16:24:37 <jmcarthur> dfrey: (*>) just has a more general type
16:24:40 <Eduard_Munteanu> dfrey: it's not the same thing as flip (<*), mind.
16:24:42 <dfrey> Eduard_Munteanu: So it's basically here's two things, now take the second one?
16:25:10 <jmcarthur> dfrey: A *> B is "do the effects of A, then do the effects of B, then return the result of B"
16:25:13 <jmcarthur> ish
16:26:24 <jmcarthur> dfrey: i'm kind of lying, because there's not necessary a sequential order of operation like that. the point is that the effects are "ordered", not that they are evaluated in that order, but their meanings are ordered.
16:26:54 <jmcarthur> dfrey: and A <* B means arrange the effects in A-then-B order, returning the result of A
16:27:23 <dfrey> In the example in the comment, they do "Full 7 *> Full 8 ---> Full 8"  That makes sense.  What seems odd to me is the other example where they have "[1,2] *> [4,5,6] ---> [4,5,6,4,5,6]"
16:27:33 <jmcarthur> dfrey: since i like that latter phrasing better, i'll rephrase the first one:  A *> B means arrange the effects in A-then-B order, returning the result of B
16:27:52 <jmcarthur> dfrey: so think about what the effect of the list applicative is
16:28:21 <Eduard_Munteanu> [1,2] *> [4,5,6] is like [1,2] >>= \_ -> [4,5,6]
16:28:22 <jmcarthur> > liftA2 (,) [1,2] [4,5,6]
16:28:23 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6)]
16:28:29 <jmcarthur> > liftA2 (\a b -> b) [1,2] [4,5,6]
16:28:30 <lambdabot>  [4,5,6,4,5,6]
16:29:23 <tlevine> bitemyapp ooh that's cool
16:29:31 <jmcarthur> :t liftA2 (\a b -> b) `asTypeOf` (*>)
16:29:31 <lambdabot> Applicative f => f a -> f c -> f c
16:30:00 <Eduard_Munteanu> > Just *> Just 5
16:30:01 <lambdabot>  Couldn't match expected type `Data.Maybe.Maybe a0'
16:30:01 <lambdabot>              with actual type `a1 -> Data.Maybe.Maybe a1'
16:30:05 <Eduard_Munteanu> > Just 3 *> Just 5
16:30:06 <lambdabot>  Just 5
16:30:11 <Eduard_Munteanu> > Nothing *> Just 5
16:30:12 <lambdabot>  Nothing
16:30:28 <Eduard_Munteanu> This may be more clear.
16:30:40 <jmcarthur> i think Writer would be especially clear here
16:30:40 <mizu_no_oto> Is there anything that's like a set, but multiple keys point to a shared value?  Basically, I'd like to memoize the calculation of a connected component calculation, so I can easily grab the set of points that any one point is connected to
16:31:00 <jmcarthur> > Writer (3, "foo") *> Writer (5, "bar")
16:31:01 <lambdabot>  Not in scope: data constructor `Writer'
16:31:01 <lambdabot>  Perhaps you meant `WriterT' (imported from Control.Monad.Writer)Not in scope...
16:31:01 <lambdabot>  Perhaps you meant `WriterT' (imported from Control.Monad.Writer)
16:31:05 <jmcarthur> bah
16:31:09 <jmcarthur> > writer (3, "foo") *> writer (5, "bar")
16:31:10 <lambdabot>  No instance for (Control.Monad.Writer.Class.MonadWriter
16:31:10 <lambdabot>                     [GHC.Types.Char] f0)
16:31:10 <lambdabot>    arising from a use of `e_135'
16:31:10 <lambdabot>  The type variable `f0' is ambiguous
16:31:10 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
16:31:13 <jmcarthur> :(
16:31:22 <jmcarthur> :t writer
16:31:22 <lambdabot> MonadWriter w m => (a, w) -> m a
16:31:24 * hackagebot purescript 0.4.16 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.16 (PhilFreeman)
16:31:32 <mizu_no_oto> Expecially because I'm constantly adding things to the graph (the graph is actually a go board, and the connected components are the chains of stones)
16:31:34 <jmcarthur> > runWriter $ writer (3, "foo") *> writer (5, "bar")
16:31:35 <lambdabot>  (5,"foobar")
16:31:39 <jmcarthur> > runWriter $ writer (3, "foo") <* writer (5, "bar")
16:31:41 <lambdabot>  (3,"foobar")
16:33:02 <jmcarthur> mizu_no_oto: you could just use a normal set and be careful to only generate the value to point to once and insert it multiple times
16:33:11 <Eduard_Munteanu> How do I get Network.HTTP.
16:33:14 <jmcarthur> mizu_no_oto: it would point to the same thing in memory that way
16:33:30 <jmcarthur> mizu_no_oto: this is all assuming the point is to save memory. right?
16:33:43 <Eduard_Munteanu> How do I get 'Network.HTTP.respondHTTP :: HStream ty => HandleStream ty -> Response ty -> IO ()' to listen for requests and parse them?
16:33:51 <Eduard_Munteanu> Er.
16:34:01 <Eduard_Munteanu> receiveHTTP :: HStream ty => HandleStream ty -> IO (Result (Request ty))
16:34:02 <mizu_no_oto> jmcarthur: the point is basically that I'm wasting time by repeatedly generating connected components
16:34:19 <jmcarthur> mizu_no_oto: there are a lot of memoization libraries out there if that's all you need
16:34:38 <Eduard_Munteanu> I can't see any way to do it, is there some other lib that does this?
16:34:51 <Eduard_Munteanu> I want to implement a proxy.
16:35:01 <mizu_no_oto> jmcarthur: the other issue is that the actual result is constantly changing, but never by much
16:35:22 <mizu_no_oto> i.e. I'm adding a single node to my graph at each time step, essentially
16:35:36 <jmcarthur> mizu_no_oto: for pure functions:  if you want by-value memoization, i recommend conal's MemoTrie. if you want by-identity memoization, i recommend my stable-memo.
16:36:03 <mizu_no_oto> And it's much faster to update a mostly-correct connected component than to do a depth first search
16:36:04 <Eduard_Munteanu> BTW, why don't these libs just expose an HTTP message parser?
16:37:02 <Eduard_Munteanu> I would implement my own parser if it wasn't for the crappy complexity involved in decoding HTTP message boundaries.
16:38:09 <mizu_no_oto> So a straight memoization library really doesn't help, because I very rarely try to get a given group multiple times from the same graph.  But the past results have done almost all of the work to get the correct answer.
16:38:20 <jmcarthur> mizu_no_oto: i'm not *entirely* sure i understand. is it that you want to be able to have multiple keys mapped to one value such then when you update the value via one key then all the other keys will also map to the new value?
16:38:25 <mizu_no_oto> And I can patch up a data structure when I add a node to the graph
16:38:57 <jmcarthur> mizu_no_oto: e.g. you just want some sort of aliasing?
16:39:23 <mizu_no_oto> jmcarthur: basically.  That way, indexing with a node gets the set of all components it's connected to
16:39:47 <jmcarthur> mizu_no_oto: there are two ways i would consider, if i wanted that much power (i usually try to avoid it)
16:40:07 <jmcarthur> mizu_no_oto: one would be to map your keys to STRefs so i can just update those
16:40:28 <hae> Memoization for the win.
16:40:37 <jmcarthur> mizu_no_oto: the other would be to simulate refs using Ints and an IntMap on the side to serve as my environment
16:41:09 <mizu_no_oto> With
16:41:14 <hae> Conversion of functions into data structures. Awesome.
16:41:37 <mizu_no_oto> Oh, right, have one map mapping points to a group number, and another set of group number to group?
16:41:42 <jmcarthur> yes
16:41:55 <amalloy> mizu_no_oto: if you're just finding connected components of a graph that doesn't change, http://en.wikipedia.org/wiki/Disjoint-set_data_structure is an algorithm that's efficient, and can be done functionally
16:42:02 <jmcarthur> roughly equivalent to ST, but persistent
16:42:38 <mizu_no_oto> amalloy: The graph is a game board; the graph changes each time a move is played
16:43:05 <jmcarthur> mizu_no_oto: are you writing an AI or just a simulator?
16:43:08 <amalloy> then my suggestion won't help much
16:43:32 <jmcarthur> mizu_no_oto: if the former, i'd definitely prefer the IntMap version of this, since it gives you free backtracking
16:43:38 <mizu_no_oto> jmcarthur: A monte carlo tree search for Go.
16:43:48 <mizu_no_oto> the intmap version also sounds easier
16:43:49 <jmcarthur> mizu_no_oto: ah yeah. definitely want purely functional then :)
16:44:17 <jmcarthur> mizu_no_oto: UCT?
16:44:17 <mizu_no_oto> You don't have to deal with threading ST everywhere, and it can be nicely encapsulated
16:44:25 <mizu_no_oto> yeah
16:44:32 <jmcarthur> mizu_no_oto: i have done this in haskell before if you want a link
16:44:39 <mizu_no_oto> Sure
16:44:47 <jmcarthur> mizu_no_oto: i did something weird though. it might confuse you even more...
16:44:49 <greymalkin> How on earth do I get the string out of a 'fail "something wrong"' in the IO monad?
16:44:58 <jmcarthur> mizu_no_oto: and unbeknownst to me at the time, very unsafe
16:45:16 <Eduard_Munteanu> greymalkin: you may 'catch' the exception
16:45:30 <greymalkin> I'm following each piece of documentation I can find -- and the best one just says the exception is ambiguous, and I can't find anything that describes how to match the pattern
16:46:02 <greymalkin> and since it won't pop out in ghci I can't interrogate the type
16:46:03 <Eduard_Munteanu> greymalkin: it might be easier to use the ErrorT transformer
16:46:23 <jmcarthur> mizu_no_oto: https://patch-tag.com/r/jmcarthur/uct-tronbot/snapshot/current/content/pretty/GameTree.hs
16:47:30 <jmcarthur> mizu_no_oto: (it wasn't Go, if that isn't obvious, but that game tree is quite generic)
16:47:54 <jmcarthur> mizu_no_oto: you just generate it lazily and then traverse it a bit at a time, updating the scores of each node
16:48:29 <jmcarthur> mizu_no_oto: and as the actual game progresses, you just forget the root of the tree and save the rest of your computation so you aren't starting over on each turn
16:48:40 <greymalkin> Eduard_Munteanu: Maybe... but this program is so stupid-small that I'd rather just figure out how to do this, rather than getting deeper than I (yet) understand.
16:49:25 <yogert> Hey all, I have a question regarding databases, and Database.Persist in particular. I'm a bit unclear on what is going on behind the scenes when I do something like "withSqliteConn ":memory:" $ runSqlConn $ foo". Intuition tells me that I shouldn't do that every time I write to the database, but then must i run the whole program inside of SqlPersistM?
16:49:31 <Eduard_Munteanu> > runErrorT (fail "fail message")
16:49:31 <jmcarthur> mizu_no_oto: the unsafe thing i did is in another module. i used unsafeInterleaveIO so that as i generated the tree i could use random walks for the initial scores of the nodes
16:49:32 <lambdabot>  No instance for (Control.Monad.Trans.Error.Error e0)
16:49:32 <lambdabot>    arising from a use of `e_1'
16:49:32 <lambdabot>  The type variable `e0' is ambiguous
16:49:32 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
16:49:32 <lambdabot>  Note: there are several potential instances:
16:49:46 <jmcarthur> mizu_no_oto: i don't recommend that approach. it was too subtle, and not a good heuristic anyway.
16:49:51 <Eduard_Munteanu> > runErrorT (fail "fail message" >> return ())
16:49:52 <lambdabot>  No instance for (Control.Monad.Trans.Error.Error e0)
16:49:52 <lambdabot>    arising from a use of `e_1'
16:49:52 <lambdabot>  The type variable `e0' is ambiguous
16:49:52 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
16:49:52 <lambdabot>  Note: there are several potential instances:
16:50:37 <Eduard_Munteanu> > runError (fail "fail message" >> return ())
16:50:38 <lambdabot>  Not in scope: `runError'
16:50:38 <lambdabot>  Perhaps you meant `runErrorT' (imported from Control.Monad.Error)
16:50:53 <Eduard_Munteanu> > runErrorT (fail "fail message" >> return ()) :: Error String ()
16:50:53 <lambdabot>  `Control.Monad.Trans.Error.Error' is applied to too many type arguments
16:50:56 <jmcarthur> mizu_no_oto: i also don't even know if the math in that implementation is correct, but that should at least be fixable if it's wrong. it seemed to work fine in practice.
16:51:00 <Eduard_Munteanu> Er.
16:51:06 <Eduard_Munteanu> > runErrorT (fail "fail message" >> return ()) :: Either String ()
16:51:07 <lambdabot>  Couldn't match type `Data.Either.Either e0 ()' with `()'
16:51:07 <lambdabot>  Expected type: Data.Either.Either GHC.Base.String ()
16:51:07 <lambdabot>    Actual type: Data.Either.Either
16:51:07 <lambdabot>                   GHC.Base.String (Data.Either.Either e0 ())
16:51:11 * Eduard_Munteanu gives up
16:51:31 <Eduard_Munteanu> Ok, this is seriously annoying, not only HTTP is a stupidly complex protocol to parse, but Haskell libs don't expose the parsers. Really, now, does everyone keep reparsing this crap?
16:52:10 <startling> Eduard_Munteanu, maybe they just copy-paste them
16:52:51 <irene-knapp> hmm
16:53:11 <mizu_no_oto> jmcarthur: I have my gametree as "Cofree [] (game, score)", where score is monoidal, ordered, and can generate an initial observation from a game result (i.e. it has a function from Bool -> a)
16:53:18 <irene-knapp> yes, that appears to be correct :(
16:53:49 <mizu_no_oto> The monte carlo code doesn't need that much more work, but I do need to speed up my random games by at least an order of magnitude
16:55:35 <irene-knapp> Eduard_Munteanu: what are you trying to obtain regarding HTTP that extant libraries don’t give you?
16:55:51 <Eduard_Munteanu> irene-knapp: writing a proxy
16:55:55 <irene-knapp> ah!
16:56:22 <irene-knapp> I mean, if you’re a conduits fan, there is always http://hackage.haskell.org/package/http-proxy
16:56:32 <jmcarthur> mizu_no_oto: ah, that seems reasonable
16:56:43 <Eduard_Munteanu> 'HTTP' doesn't seem to provide any way to invoke a parser on some Bytestring.
16:56:49 <irene-knapp> well, indeed, it doesn't
16:57:10 <Eduard_Munteanu> irene-knapp: yeah, I've seen that, maybe I should take a closer look
16:57:22 <irene-knapp> btw, if you ARE writing your own binary parser, I’d like to take a moment to plug my own package, http://hackage.haskell.org/package/direct-binary-files
16:57:29 <irene-knapp> which is a monad for binary parsers and generators
16:57:44 <Eduard_Munteanu> Heh, I wish HTTP was a binary format.\
16:57:56 <irene-knapp> it can run purely on a ByteString, or under IO for a file on-disk.  I would definitely extend it to other backends if anyone expressed interest.
16:57:57 * irene-knapp nods
16:57:58 <irene-knapp> fair
16:58:00 <flebron> Is there any way to make λ a ctor, or even :λ or something like that?
16:58:12 <Eduard_Munteanu> It's a contrived mess of barely human-readable text.
16:58:14 <startling> flebron: :λ should work
16:58:22 <irene-knapp> yeah, I know
16:58:39 <flebron> I tried "data X = Char :λ Int" and I get "Illegal binding of built-in syntax: :"
16:58:40 <geekosaur> actually neither one
16:58:42 <irene-knapp> and it’s necessary to parse it exactly right, because there are security holes related to smuggling stuff through proxies by exploiting parser differences :(
16:58:43 <geekosaur> it's a lowercase letter
16:58:46 <geekosaur> not a symbol
16:58:52 <geekosaur> nor uppercase
16:58:55 <startling> oh, right.
16:59:03 <flebron> Sure, I know it's lowercase letter :)
16:59:22 <startling> data Λ a = Λ a
16:59:33 <irene-knapp> Haskell differentiates between ordinary values and constructors based on case
16:59:49 <irene-knapp> so, Greek letters are a casualty
17:00:29 <steamboat> mizu_no_oto: have you considered union-find?
17:00:36 <Eduard_Munteanu> I really don't know what they were thinking when they invented HTTP.
17:00:49 <irene-knapp> they thought they’d put something out and nobody would really use it
17:00:50 <StoneCypher>  
17:01:16 <amalloy> steamboat: i recommended that already, but his graph is changing all the time
17:01:20 <steamboat> mizu_no_oto: coincidentally I'm working on implementing generic mcts right now -- working with 9 Mens morris as a toy game though
17:01:20 <StoneCypher> that a simple, easy to parse, error tolerant text based protocol would be very useful
17:01:35 <Eduard_Munteanu> Or HTML, XML and whatnot.
17:01:36 <StoneCypher> that's something the unix people also did that programmers, quick to judge what they don't understand, despite that it's actually well explained, often miss
17:01:58 <StoneCypher> yeah, i agree, the world's most successful protocols and formats really screwed up in your opinion
17:02:01 <StoneCypher> maybe you should do a better job.
17:02:29 <jmcarthur> wait, i'm not sure i see what's wrong with HTTP
17:02:44 <jmcarthur> i don't think it's actually that bad. it's fairly simple, easily extensible...
17:03:05 <irene-knapp> in fairness, when it was invented, nobody was thinking about security implications at all
17:03:10 <StoneCypher> false.
17:03:10 <irene-knapp> the net was a much safer place
17:03:13 <StoneCypher> also false.
17:03:14 <mizu_no_oto> steamboat:  I need something slightly stronger than union-find; I need to get the entire set an item is associated with
17:03:20 <Eduard_Munteanu> It's fairly complex to parse, when length + message as binary would have done just as well.
17:03:28 <StoneCypher> http was designed expressly with security in mind, at a high security facility with a long history of attacks
17:03:42 <StoneCypher> you should probably actually know something about its design history before commenting on its design history
17:03:45 <steamboat> amalloy: not entirely sure but for chains on a go board, this may be sufficient as we're only adding stones to groups
17:04:00 <amalloy> uhhhhhh, except for the times when stones disappear
17:04:05 <irene-knapp> I thought I heard a little voice trying to say something, but I guess it was just the wind
17:04:14 <mizu_no_oto> amalloy: when that happens, the entire chain goes
17:04:25 <StoneCypher> "i thought i heard factual criticism, but then i became elitist and ignored my own errors"
17:04:29 <mizu_no_oto> i.e. we delete the *entire* set
17:04:44 <steamboat> mizu_no_oto: maybe try wrapping the set and the union-find together
17:04:49 <StoneCypher> irene-knapp: it's unfortunate the way you react to being informed that your factual claims are in error
17:05:05 <jmcarthur> StoneCypher, irene-knapp: :(
17:05:11 <steamboat> mizu_no_oto: so you can index in with the union-find and then get the entire set
17:05:28 <Eduard_Munteanu> I don't see why you'd come up with a so-called human readable protocol chuck full of escaping rules and what not, when a binary machine-readable protocol would've been just as good if not better, especially 20 years ago.
17:05:39 <StoneCypher> jmcarthur: may i /msg please?
17:05:46 <jmcarthur> sure
17:05:46 <steamboat> amalloy: it depends on how strongly a chain needs to be connected
17:05:50 <StoneCypher> jmcarthur: thank you
17:06:03 <mizu_no_oto> steamboat: that's much like the map + set idea, isn't it?
17:06:21 <mizu_no_oto> i.e. you use one data structure to generate the index into the next noe
17:07:30 <steamboat> mizu_no_oto: I think so (I'll have to scroll up and read), though union-find seems like the ideal structure for doing the indexing into
17:07:48 <mizu_no_oto> steamboat: currently reading up on it
17:08:44 <schlegel> Does anyone have a good graph BFS reference
17:08:46 <schlegel> ?
17:09:05 <Eduard_Munteanu> schlegel: what about it?
17:09:41 <StoneCypher> irene-knapp: I have been instructed to ask you publically not to behave in this fashion: [17:01:54] <irene-knapp> I thought I heard a little voice trying to say something, but I guess it was just the wind
17:10:11 <irene-knapp> I have no intention of responding to anything you say in future; have no fear.
17:10:31 <StoneCypher> you've said that before
17:10:48 <irene-knapp> For the record, StoneCypher has been sending me private communications (which I have been ignoring) for several weeks now, after being asked to stop several times.
17:10:50 <schlegel> Trying to show someone a simple graph BFS algorithm but they're confused by Data.Graph.Algorithm.BreadthFirstSearch
17:11:00 <StoneCypher> irene-knapp: lol no you haven't
17:11:02 <StoneCypher> be honest at least :)
17:11:18 <StoneCypher> would you like logs of your highly public reactions?
17:11:26 <Eduard_Munteanu> schlegel: it's not difficult to reimplement it yourself
17:11:42 <schlegel> Yeah I know I'm just busy on other things :P
17:11:51 <steamboat> mizu_no_oto: http://hackage.haskell.org/package/union-find-0.2/docs/Data-UnionFind-ST.html
17:12:11 <steamboat> mizu_no_oto: seems like it may include the the referencing capability
17:12:17 <Eduard_Munteanu> schlegel: a recursive traversal with a queue (say Data.Sequence) instead of a stack (list) is basically BFS
17:12:25 <irene-knapp> If I go elsewhere to discuss harrassment by you with my friends, that’s pretty damn entitled of you to try to paint yourself as the victim because you don’t like people having recourse.
17:12:35 <greymalkin> > catch (fail "Something bad") (\e -> putStrLn $ "Exception happened: " ++ (show e))
17:12:36 <lambdabot>  No instance for (GHC.Exception.Exception a0)
17:12:36 <lambdabot>    arising from a use of `Control.Exception.Base.catch'
17:12:36 <lambdabot>  The type variable `a0' is ambiguous
17:12:36 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
17:12:36 <lambdabot>  Note: there are several potential instances:
17:12:50 <mizu_no_oto> steamboat: you mean the referencer function?
17:12:51 <johnw> you need (show (e :: SomeException))
17:13:10 <mizu_no_oto> steamboat: err, discriptor
17:13:12 <greymalkin> > catch (fail "Something bad") (\e -> putStrLn $ "Exception happened: " ++ (show (e :: IOError)))
17:13:13 <lambdabot>  <IO ()>
17:13:21 <steamboat> mizu_no_oto: yeah, that's my initial though
17:13:28 <greymalkin> How do I get the "Something bad" part back out?
17:13:29 <jmcarthur> irene-knapp, StoneCypher: maybe it would be best for you two to just /ignore each other? i don't normally see bad behavior out of either of you
17:13:41 <StoneCypher> <irene-knapp> You are entitled because I complain in public that you /msged me politely, but I should be able to complain about you in front of hundreds of people without staying honest
17:13:47 <irene-knapp> I am willing to do that if it is an official position, sure.
17:13:50 <StoneCypher> jmcarthur: she claims she has
17:13:53 <irene-knapp> it’s done
17:14:10 <irene-knapp> I have multiple computers which it needs to be applied on all of
17:14:24 <akurilin> Quick question: is system-fileio the module I should be looking into if I want to list files, rename them etc in haskell?
17:14:26 <akurilin> or can I do better?
17:14:52 <greymalkin> Or do I have to have the "user error" part at the beginning?
17:15:01 <akurilin> I guess System.Directory has a lot of goodies in it too
17:19:16 <jle`> :t fail
17:19:17 <lambdabot> Monad m => String -> m a
17:19:20 <jle`> oh yeah.
17:19:21 <jle`> how weird
17:19:26 <jle`> @src IO fail
17:19:27 <lambdabot> fail s  = failIO s
17:19:32 <jle`> :t failIO
17:19:33 <lambdabot>     Not in scope: `failIO'
17:19:33 <lambdabot>     Perhaps you meant `fail' (imported from Control.Monad.Writer)
17:20:44 <jle`> ReinH: have you considered finding a prominent female member of the haskell community for your haskell casts
17:23:22 <greymalkin> Got it.... ioeGetErrorString e
17:31:42 <__zeratul__> I'm having trouble installing interpolatedstring-qq cabal package. Says it can't find module 'Language.Haskell.TH.Syntax.Internals'. Anyone have any ideas?
17:32:44 <__zeratul__> No cabal masters here?
17:32:50 <lispy> can you use yoneda to get (forall a. (a -> r) -> (f a -> s)) ~ f r -> s ?
17:33:28 <lispy> __zeratul__: I think that can happen when something has tried to install a version of TH instead of using the one that comes with your ghc.
17:33:35 <lispy> TH isn't something you can upgrade with cabal.
17:34:05 <__zeratul__> Hmm. So I need to upgrade it? How do I do that?
17:34:21 <Fuuzetsu> yeah, the TH version on that package probably needs to be updated to accomodate for newer ones
17:34:42 <lispy> __zeratul__: first I would check what version of th is installed and where (ghc-pkg list template-haskell). You should have just one version. Then check the dependencies for the package you want to install.
17:38:02 <haasn> lispy: I don't understand how that is even supposed to be equivalent
17:38:28 <haasn> think about f = [], r = Int, s = Int; what's the isomorphic value for ‘sum’?  forall a. (a -> Int) -> [a] -> Int
17:39:24 <__zeratul__> What fails to install is haskell-src-meta-mwotton  http://hackage.haskell.org/package/haskell-src-meta-mwotton
17:39:36 <__zeratul__> And ghc-pkg says I have template-haskell 2.7.0.0
17:39:51 <__zeratul__> And the mwotton package only needs template-haskell > 2.4.0.0
17:39:52 <haasn> Wait, even better: f = Identity; r = Void; s = ()
17:39:57 <haasn> Identity Void -> () -- clearly inhabited by const ()
17:40:20 <haasn> oh, bad choice actually
17:42:34 <__zeratul__> Ok, I'm getting a new message now:  Could not find module `Language.Haskell.TH.Syntax.Internals'
17:42:37 <__zeratul__>  It is a member of the hidden package `template-haskell-2.7.0.0'.
17:42:37 <__zeratul__>  Perhaps you need to add `template-haskell' to the build-depends in your .cabal file.
17:43:50 <__zeratul__> I think I have template-haskell 2.8.0.0 and 2.7.0.0, and the haskell-src-meta-mwotton wants the 2.7.0.0 but can't get to it
17:44:54 <__zeratul__> Any thoughts on that?
17:46:55 <lispy> __zeratul__: template-haskell is wired in the compiler. You really should only have the one in your global package database. If you have any others that is an error. The way to fix the error is to either a) install a different version of ghc to get a different TH or; b) change the packages to be compatible with your TH version
17:52:09 <dinkarganti> i am facing seg fault 11 when running my application on mac The Glorious Glasgow Haskell Compilation System, version 7.6.3
17:52:30 <dinkarganti> os x version 10.9.2
17:52:36 <dinkarganti> How do I even debug this?
17:52:39 <geekosaur> floating point by any chance?
17:53:04 <dinkarganti> could be....the test cases that i am running
17:53:08 <geekosaur> I think they finally tracked that down and the fix is in 7.8, in earlier versions they kept trying to fix it and missing
17:53:14 <dinkarganti> include websockets threads and arbitrary quick check.
17:53:21 <lispy> dinkarganti: Is it doing anything to stress your system like using lots of ram?
17:53:33 <geekosaur> that doesn't scream floating point to me, but hard to tell without seeing code
17:53:40 <dinkarganti> none. 4 threads and 5 quick property checks.
17:53:50 <dinkarganti> how can i send some traces of the fault
17:54:13 <dinkarganti> i mention floating point because some attributes are floats.
17:54:14 <StoneCypher> what is arbitrary quickcheck?  (i use quickcheck in a different language, so i know the basics)
17:54:23 <lispy> dinkarganti: do you use ffi?
17:54:29 <dinkarganti> nope.
17:54:34 <flebron> When simonmar says he's building a DSL (Haxl) for parallelism and that Applicative can look at the structure of computation to do that, he means he's defining some useful operators that only require Applicative, he's not using do-notation, and that he's reifying <*> and pure and later "running" that AST exploiting parallelism, something like that?
17:54:36 <dinkarganti> not directly.
17:54:36 <geekosaur> most of the segfaults I'm aware of are related to `floor`, occasionally there are interpreter (ghci) crashes because of weird thread stuff (if -fno-ghci-sandbox changes behavior then it's this)
17:55:08 <geekosaur> there's also potential for weirder stuff, like the damned iconv issue that plagues macports and homebrew in different ways
17:55:20 <dinkarganti> i am not using homebrew.
17:55:35 <dinkarganti> i downloaded the xcode command line tools, and the clang wrapper
17:55:43 <StoneCypher> dinkarganti: is "arbitrary quickcheck" a thing, or am i conflating literate speech with a name
17:56:03 <geekosaur> (macports solved it in a way that can cause link errors if you try to mix apple and macports iconv, early homebrew solved it in a way that can cause sig11s, dunno about their current state)
17:56:09 <dinkarganti> @StoneCypher: I meant I had some arbitrary implementations that use float.
17:56:09 <lambdabot> Unknown command, try @list
17:56:13 <StoneCypher> oh oh
17:56:26 <geekosaur> if it's calling floor at any point it could segfault there
17:56:31 <StoneCypher> dinkarganti: gotcha.  thanks; i'm a testing enthusiast and thought i was missing out on a tool.  :)
17:56:54 <geekosaur> (this includes any calls buried in quickcheck, which I wouldn't know about)
17:57:05 <jle`> flebron: well, on the haskell cast he mentioned that he did not build up an AST
17:57:07 <dinkarganti> @StoneCypher: No..not yet..but I am looking for a good one myself..quickcheck seems fine for now.
17:57:07 <lambdabot> Unknown command, try @list
17:57:17 <jle`> flebron: but i have not looked into enough to be able to definitively answer
17:57:32 <StoneCypher> dinkarganti: cool.  i'm aware of a really awesome alternate tool, but i only know of one implementation, and it's in a language i don't enjoy (ruby)
17:57:46 <StoneCypher> dinkarganti: i don't really know enough about haskell to know if it makes sense here
17:57:54 <jle`> StoneCypher: /b 6
17:57:57 <jle`> oh sorry wrong window
17:58:16 <StoneCypher> lol
17:58:56 <dinkarganti> @geekosaur: If arbitrary is calling floor..it could be that.
17:58:57 <lambdabot> Unknown command, try @list
17:59:30 <lispy> dinkarganti: In that case, I would work on narrowing it down to a minimal bit of code you can run to get the segfault
17:59:48 <dinkarganti> Is there a way to dump core?
18:00:06 <dinkarganti> I tried that: as soon as my quick check properties: the first one is run..i get a seg fault.
18:00:06 <lispy> dinkarganti: You could try gdb but the run-time doesn't ship with debug symbols and it requires pretty intimate knowledge of the compiler's run-time to do that debugging.
18:00:28 <dinkarganti> i figured..i only wanted to generate a trace for pasting it.
18:00:44 <dinkarganti> @lispy: i figured as much.
18:00:44 <lambdabot> Unknown command, try @list
18:01:24 <lispy> if you want to dumpcore check your ulimit. I know that's how you do it on linux, no idea on osx
18:01:31 * lispy has to run
18:01:51 <geekosaur> same
18:02:06 <geekosaur> default ulimit -c is 0, so no core file
18:02:42 <dinkarganti> thanks geekosaur..let me try that.
18:03:23 <geekosaur> you could also try running it under lldb (you said you were on 10.9 right?)
18:03:31 <geekosaur> gdb on 10.8 and earlier
18:04:10 <khushildep> Hello all - I wanted to ask, is it a breach of guidelines to post a link to a position we are looking to fill in our company for strong functional programmers?
18:04:14 <dinkarganti> I will try lldb. Thanks.
18:04:32 <geekosaur> khushildep, probably best to send those to the haskell-cafe mailing list
18:04:34 <dinkarganti> gotta run..but will try it. I am in the nychac.
18:04:50 <dinkarganti> Thanks all. Will let you know if i am finally able to fix it.
18:04:56 <khushildep> geekosaur: thanks for the advice
18:05:25 <geekosaur> dinkarganti, if it does turn out to be the floor / floating point issue thjen your best bet may be to try the 7.8 RC
18:06:51 <dinkarganti> I see.
18:07:51 <enferex> Aside from internet resources, what is the most common way of looking for a particular function in haskell?
18:08:11 <enferex> In C, I usually use grep.  But I cant grep binary haskell modules
18:08:11 <Eduard_Munteanu> enferex: hoogle?
18:08:21 <Eduard_Munteanu> Also hayoo.
18:08:56 <Eduard_Munteanu> enferex: there's hasktags but that's only useful for source code you have around
18:09:17 <luite> a local hoogle installation with all your installed packages is very useful, i think :)
18:09:43 <luite> (in particular when you're on a not so good internet connection or on the move)
18:10:00 <zzing> I am attempting to compile a virgin copy of hakyll, and I am getting an error: https://gist.github.com/iaefai/64ad3bb85ff881f934e5   that I have attempted to fix it, but I so rusty. The source code is here: https://github.com/jaspervdj/hakyll/blob/master/src/Hakyll/Check.hs  (line 202). Any ideas on how to fix this properly?
18:10:18 <enferex> luite: Ok
18:10:21 <geekosaur> could probably come up with a script which did ghc --show-iface on a .hi file and grepped the result
18:10:26 <geekosaur> er
18:10:31 <geekosaur> not the right option
18:10:40 <geekosaur> oh, yes it is
18:10:49 <geekosaur> confused it with -ddump-iface for some reason
18:11:38 <enferex> thx
18:14:37 <enferex> geekosaur: Ultimately I want to see if I havea  md5 or sha1 function somewhere in my haskell modules.
18:16:27 <geekosaur> a local hoogle is probably best for that kind of thing, yeh
18:16:27 <quchen> zzing: Did you sandbox the Hakyll installation?
18:16:41 <zq> ugh
18:16:54 <quchen> zzing: cabal sandbox init && cabal install hakyll
18:17:07 <zzing> quchen, no
18:17:15 <zzing> sandbox must be new
18:17:23 <quchen> Somewhat new, yes. Couple of months.
18:17:26 <zq> i accidentally deleted package.cache of my sandbox. is it possible to rebuild it without recompiling everything?
18:17:33 <zzing> My cabal hasn't it
18:17:39 <quchen> zzing: It came with 1.18
18:17:54 <quchen> So "cabal install cabal-install" first
18:17:55 <geekosaur> zq: ghc-pkg recache
18:18:09 <zq> geekosaur: uh, would that be cabal sandbox hc-pkg recache?
18:18:16 <geekosaur> possibly
18:18:26 <enferex> geekosaur: thank you
18:18:27 <geekosaur> was abotu to say you'd probably have to point it at the sandbox package db somehow
18:18:40 <zzing> Does haskell platform install cabal into /usr/bin?
18:18:52 <geekosaur> I don't know if the sandbox stuff supports wrapping recache
18:18:57 <geekosaur> zzing, on what platform
18:19:18 <geekosaur> and depending on platform, whose haskell-platform package
18:19:48 <zq> how come ${pkgroot} isn't expanded out inside package.cache?
18:19:48 <zzing> mac
18:20:02 <geekosaur> (for example, on OS X the official platform installer puts it under /Library/Haskell/bin with a symlink in /usr/bin, but homebrew's will be in /usr/local/bin and macports' in /opt/local/bin
18:20:05 <zzing> I just did a --global install of it and it just threw it into /usr/local
18:20:17 <zzing> official platform
18:20:45 <geekosaur> a manual install of cabal-install would go into /usr/local by default, yes
18:21:04 <geekosaur> the official package would, as I said, be /Library/Haskell/bin wiht a symlink in /usr/bin
18:21:28 <geekosaur> actually there's probably some version foo in there somewhere
18:22:24 <zzing> removed the symlink then, will see if this thing works now
18:24:32 <zq> cool, i just made my sandbox relocatable
18:25:07 <zzing> So is the idea that the sandbox gets specific versions that hakyll specifies?
18:26:38 * hackagebot type-unary 0.2.13 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.2.13 (ConalElliott)
18:27:15 <quchen> zq: ?
18:27:31 <quchen> Are sandboxes normally bound to an absolute path? I've never moved one.
18:28:55 <zq> quchen: yes
18:29:03 <zq> mv sandbox sandbox2
18:31:10 <conal> I'm updating some libraries for GHC 7.8. I'd like my code to keep working with older GHCs, so I thought I'd use some #if ... #endif, but how might I know what CPP symbols to use for base library changes?
18:32:32 <Algebr> Are modules objects of interest? Like I'd like to be able to do something like dir(someModule) and get back a list of strings of the names of things that the module exposes
18:33:18 <Eduard_Munteanu> Algebr: they're not first-class at all in Haskell.
18:33:40 <Eduard_Munteanu> They're basically namespaces and that's about it.
18:34:04 <Algebr> Eduard_Munteanu: So what kind of reflection can I get in Haskell?
18:34:20 <Eduard_Munteanu> Algebr: if you just want to get names of exports, try using tab completion in ghci e.g. Data.Map.Lazy.<tab>
18:34:43 <zq> or :browse
18:34:47 <zq> Algebr: ^
18:35:04 <Eduard_Munteanu> Algebr: not anything like that, really, unless you call GHC as a library perhaps.
18:35:46 <Eduard_Munteanu> Not sure if TH does anything about modules at all.
18:35:52 <Algebr> Eduard_Munteanu: Ah, bummer. Thanks.
18:36:44 <Algebr> Eduard_Munteanu: Speaking of first-class objects, since they are so in Haskell, I can put them in arbirtrary data structures, right?
18:37:22 <Eduard_Munteanu> Algebr: who are "they"? Modules are *not* first-class.
18:37:41 <zzing> quchen, I just tried with sandbox, cabal fails to compile in the exact same way
18:38:38 <Algebr> Oh sorry sorry, I forgot to type functions, I meant to ask about functions.
18:39:11 <Eduard_Munteanu> Algebr: then yeah, functions are values too.
18:41:39 * hackagebot TypeCompose 0.9.10 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.9.10 (ConalElliott)
18:41:41 * hackagebot type-unary 0.2.14 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.2.14 (ConalElliott)
18:49:53 <quchen> zzing: Hmm. Try "cabal install --only-dependencies" before "cabal install hakyll".
18:50:33 <zzing> quchen, it already installed all of thme
18:50:37 <quchen> I've had similar problems in the past, and I think some of them were because I only installed missing packages in the sandbox (while having wrong versions in my user package DB)
18:50:51 <quchen> Well then I'm clueless :-x
18:51:16 <zzing> I will have to post on the mailing list. I am very surprised I haven't been able to find *anything* on this. There is nothing special about my system.
18:51:34 <quchen> I'm sure there is a simple solution.
18:51:42 <zzing> Its probably a change in code :P
18:51:46 <zzing> no more than 20 characters
18:52:03 <quchen> You just chose a poor time to ask this, since I'm the only one who responds, and I'm really not good with Cabal problems.
18:55:35 <zzing> Always a risk
19:06:52 <Algebr> Is it nonsense to ask if I can have something akin to like deriving Show but on a function?
19:07:42 <Eduard_Munteanu> Algebr: you can't, generally, because e.g. Integer -> Integer wouldn't make sense to 'show'.
19:07:44 <zzing> Algebr, you want a Show instance for a function?
19:08:17 <Algebr> zzing: Yes, so that if I did print functionName, it wouldn't crap out.
19:08:48 <kazagistar> Algebr: I don't think you can use deriving, but you can certainly attempt to do you own, but I am not sure what you would want to show, plus it would be unlikely to hold at all to what I assume are the "laws" of Read and Show
19:10:59 <pavonia> Algebr: There's one in Text.Show.Functions
19:11:11 <dmwit> There's another in Data.Universe.Instances
19:12:06 <bitemyapp> Algebr: are you sure you want that?
19:12:57 <Algebr> I guess I"m just relying on my usual Python flow in Haskell.
19:13:19 <heatsink> I want to see how much memory strings are using in my program.  Is there a way to distinguish String from other lists in heap profiling?
19:16:44 <kazagistar> Algebr: generally the type system and type errors provide a pretty decent amount of information, to the point where printing actual data contents is significantly less important then it was in python, for me at least
19:18:34 <Algebr> kazagistar: Ha, yea, I guess I have to trust my code more that it will be right.
19:18:55 <kazagistar> the primary use for printing stuff in python, for me at least, is always "find out what exactly is at this location", but the type system covers most of it here, so the remaining questions tend to be pretty firmly about data only (which is almost always showable)
19:21:44 <dinkarganti> Process 0 stopped
19:21:44 <dinkarganti> * thread #1: tid = 0x0000, 0x95d95364 libsystem_platform.dylib`_platform_memmove$VARIANT$sse42 + 84, stop reason = signal SIGSTOP
19:21:47 <dinkarganti> I am trying to run my application on mac and get this in the core file:
19:21:58 <dinkarganti> Any pointers?
19:22:26 <geekosaur> need more than that
19:22:46 <dinkarganti> Sure: I have run thread bactrace all.
19:23:15 <dinkarganti> TOP
19:23:15 <dinkarganti>     frame #0: 0x95d95364 libsystem_platform.dylib`_platform_memmove$VARIANT$sse42 + 84
19:23:15 <dinkarganti> libsystem_platform.dylib`_platform_memmove$VARIANT$sse42 + 84:
19:23:17 <dinkarganti> -> 0x95d95364:  movb   (%esi), %al
19:23:18 <dinkarganti>    0x95d95366:  incl   %esi
19:23:21 <dinkarganti>    0x95d95367:  movb   %al, (%edi)
19:23:22 <dinkarganti>    0x95d95369:  incl   %edi
19:23:25 <dinkarganti> (lldb) thread backtrace all
19:23:26 <dinkarganti> does this help?
19:23:28 <geekosaur> don't paste
19:23:32 <dmwit> ?lpaste
19:23:33 <lambdabot> Haskell pastebin: http://lpaste.net/
19:23:38 <dinkarganti> Oh ok.
19:23:41 <dinkarganti> let me try it
19:23:46 <geekosaur> and no, that does not help, need the actual traceback through the calls
19:24:26 <dinkarganti> http://lpaste.net/102318
19:25:20 <geekosaur> that still isn;t a full backtrace
19:25:52 <dinkarganti> Geekosaur: do i need to enable a -g (-DDEBUG) option in the exe as well as the library?
19:26:31 <geekosaur> is there really no information about the call stack, just about the current assembly code?
19:26:46 <dinkarganti> unfortunately thats all I see.
19:26:53 <dinkarganti> I was hoping to see some function call.
19:26:57 <geekosaur> debug is helpful to see parameters but just knowing the functions on the call stack can proviude a lot of information
19:27:12 <dinkarganti> indeed.
19:27:30 <dinkarganti> I am going to run each test case one by one to see which one is failing.
19:27:38 <dinkarganti> narrow it down.
19:29:05 <dinkarganti> geekosour: can i ignore this warning: clang: nodefaultlibs?
19:34:43 <geekosaur> I have no idea what that is
19:35:11 <geekosaur> unless it's clang complaining about a gcc option it doesn't implement, in which case probably yes
19:35:21 <dinkarganti> geekosaur : what is the libtrace equivalent on mac osx?
19:36:01 <dinkarganti> it is a clang warning..and I did not paste it. Let me paste it in pastebin.
19:36:22 <geekosaur> ...libtrace is a packet tracer. did you mean ltrace? if so maybe you want dtruss
19:36:49 <dinkarganti> http://lpaste.net/102319
19:37:38 <dinkarganti> i meant ltrace .
19:37:41 <dinkarganti> let me try dttruss.
19:37:43 <dinkarganti> dtruss
19:39:40 <geekosaur> dtruss isn't really the same thing but the fancier interfaces are in Instruments which is part of Xcode
19:43:51 <dinkarganti> geekosaur: i have some more info..let me paste it..
19:46:24 <dinkarganti> http://lpaste.net/102320
19:47:54 <geekosaur> yeh, that's not actually helpful though. I can't believe there's no backtrace from the core file
19:48:10 <geekosaur> although.. careful trying to use gdb commands with lldb, they're not entirely compatible
19:50:52 <dinkarganti> geekosaur let me dump a new core file and see if there is a way to get a backtrace.
20:09:21 <akurilin> Quick question: I'm recursively producing lists of filepaths at the leaves of directories, so I want to end up with an IO [[FilePath]]. If I recursively call my fn, how do I concat multiple IO [[Filepath]] into one?
20:09:31 <akurilin> (disclaimer: monad newbie here)
20:09:52 <akurilin> should I foldM with a regular ++ ?
20:10:26 <pingu> akurilin: you mean [IO [Filepath]]?
20:10:31 <sordina> Hi haskellers :)
20:10:51 <pingu> because if you mean IO [[Filepath]] you could just  concat <$>
20:10:56 <sordina> I'm looking at building a little compiler example using free monads to compile an edsl to bash
20:10:59 <eazar001> Hi All, I noticed that because of Haskell's lazy evaluation, at times I will write up instructions for a large Data-Map for example, and when a calling function executes a lookup, it goes through the necessary overhead of evaluating the data structure and after termination it is garbage-collected. However, when I re-attempt a function call and the lookup is performed again the same time overhead occurs
20:11:01 <eazar001> because it re-evaluates the list and reads it back into memory, only to garbage-collect again. Is there a way to keep structures (such as Maps) permanently held in memory (without keeping the calling function alive indefinitely)? Sorry if this was too long winded of a question.
20:11:06 <sordina> There's a great example at:
20:11:20 <akurilin> pingu: I don't quite have a good understanding of where I should keep the IO
20:11:29 <akurilin> pingu: maybe at the very top or at each sub-list?
20:11:49 <pingu> akurilin: do you have an actual code example? Or concrete signatures?
20:11:51 <roboguy_> akurilin: what type do you want the function to be?
20:13:10 <sordina> http://stackoverflow.com/a/14084654/708134
20:13:22 <akurilin> pingu: roboguy_ pasting
20:13:30 <sordina> I'm just having trouble adding conditionals...
20:13:43 <sordina> Does anyone have an example of compiling edsl conditional statements?
20:13:52 <akurilin> http://lpaste.net/6925208291727376384
20:14:06 <akurilin> Again I have no clue if I want [IO [FilePath]] or IO [[FilePath]]
20:14:27 <akurilin> I was trying to extend the example from RHW to group files into lists based on folders
20:14:40 <c_wraith> akurilin: do you want a list of actions that each produce a list of filepaths?  Or do you want a single action to produce a list of lists of filepaths?
20:14:58 <akurilin> assumption for now is that if there's a dir in the current dir, there's never a file, and if there's a file, there's never another folder to recurse into
20:15:19 <akurilin> c_wraith: is there a good reason to choose one over the other?
20:16:09 <c_wraith> akurilin: They mean different things.  You should pick the one that matches the meaning you want.
20:17:15 <pingu> akurilin: are you trying to get one big list out at the end?
20:17:26 <pingu> i.e. you want IO [FilePath]?
20:17:29 <akurilin> a list of lists, one list per folder
20:17:36 <pingu> right.
20:17:37 <akurilin> leaf folder.
20:17:43 <c_wraith> akurilin: it sounds kind of like you *really* want a tree
20:18:07 <akurilin> c_wraith: well I will eventually loop through that list and rename those files 1.png 2.png etc based on the index
20:18:11 <akurilin> so I don't need anything more sophisticated
20:18:17 <akurilin> and having a list of lists fits that scenario very well for me
20:18:44 <akurilin> pingu: so what's your recommendation?
20:19:21 <akurilin> (to clarify, 1.png, 2.png etc once for each distinct folder)
20:19:21 <roboguy_> akurilin: you should probably start by breaking that up into more functions
20:20:41 <pingu> akurilin: still trying to grok your code and what you're trying to achieve
20:21:42 <akurilin> pingu: if you have 2 folders, folder A and folder B, and a bunch of files in them, I'd like to get [["A/a.txt", "A/b.txt"], ["B/a.txt", "B/b.txt"]]
20:22:09 <akurilin> that's all I need at this stage
20:22:11 <bitemyapp> akurilin: quick question, why is depth constrained?
20:22:24 <akurilin> bitemyapp: shouldn't be
20:22:35 <bitemyapp> akurilin: [[a]] constrains your depth yo.
20:22:36 <roboguy_> akurilin: it has to be though
20:22:39 <roboguy_> because of the type system
20:22:45 <akurilin> Oh I mean, I only care about the leaves
20:22:50 <bitemyapp> yeah but
20:22:58 <bitemyapp> your depth is constrained o_o
20:23:01 <roboguy_> you should really consider a tree
20:23:11 <akurilin> again, the assumption is that you're either a dir with no files and another dir in you, or you're a dir with only files
20:23:26 <enthropy> you don't need to make up an intermediate tree
20:23:30 <bitemyapp> akurilin: right but it can go arbitrarily deep.
20:23:41 <bitemyapp> which is our point
20:23:58 <roboguy_> akurilin: do you want to be able to have something like this: [["A/a.txt", "A/b.txt"], ["B/b.txt", ["B/1/a.txt"]]?
20:24:06 <akurilin> roboguy_: no
20:24:18 <akurilin> roboguy_: 1 level of nesting at most
20:24:34 <roboguy_> I feel like a more general solution with trees would actually be simpler in this case
20:24:41 <akurilin> at least in the list itself, maybe the actual folder tree could be deeper
20:24:46 <roboguy_> than arbitrarily constraining it to lists of lists
20:26:40 <dmwit> akurilin: Have you poked in the "directory" package?
20:26:44 <dmwit> It should have all the tools you need
20:26:45 <dmwit> .
20:26:47 <c_wraith> akurilin: or http://hackage.haskell.org/package/directory-tree
20:26:58 <roboguy_> akurilin: if you have the kind of recursion you have in "map getGroupsOfPaths", you will probably end up with an impossible type (if you use lists)
20:27:13 <dmwit> Oh, is there actual code we're commenting on somewhere?
20:27:20 <roboguy_> dmwit: http://lpaste.net/6925208291727376384
20:27:23 <dmwit> I've only read the last five minutes or so of conversation.
20:27:25 <dmwit> roboguy_: thanks
20:27:57 <akurilin> roboguy_: I get your point now
20:28:16 <pingu> akurilin: I'm not sure if your foldM is doing what you think it is either.
20:28:19 <akurilin> I think in the past when I implement similar logic I knew how deep something could go and it was consistent/predictable
20:28:51 <akurilin> directory-tree could be neat
20:29:23 <akurilin> could just build a tree and then extract the leaves from it into one list of lists
20:29:33 <bitemyapp> akurilin: clean types, clean code, sane mind.
20:29:38 <dmwit> Okay. I think this code could be fixed without too much trouble, if that's what you want to do.
20:29:51 <bitemyapp> akurilin: people whine about getting bossed around about the compiler, but sometimes it's the canary in the coal mine for stupidity.
20:29:57 <dmwit> Just use mapM instead of map in the else branch, then throw a concat in for good measure.
20:29:58 <bitemyapp> (usually, if I'm honest)
20:30:05 <dmwit> concat <$> mapM getGroupsOfPaths prepended
20:31:04 <dmwit> I agree in principle with other folks that you should think a bit more about what you're doing. But one way to gain the wisdom that makes you ask this is to do it the wrong way a few times and watch it break. ;-)
20:31:24 <bitemyapp> dmwit: oh definitely. akurilin knows I'm not picking on him specifically.
20:31:39 <bitemyapp> dmwit: he and I both came to Haskell from Clojure, so we're well familiar with the "boo hoo types" brigade :)
20:36:45 <ThatTreeOverTher> I'm getting the error message "No instance for (ButtonClass EventBox) arising from a use of `onClicked'"
20:36:52 <ThatTreeOverTher> what do I do to fix that? I'm lost
20:38:00 <roboguy_> ThatTreeOverTher: we need more information than that
20:38:22 <dmwit> I don't really think you do need much more information than that, actually.
20:38:30 <dmwit> Provided you're a gtk2hs expert. ;-)
20:38:35 <geekosaur> aside from, gtk2hs, yeh
20:38:48 <dmwit> ThatTreeOverTher: You might like the buttonPressEvent/buttonReleaseEvent events, which work for any widget.
20:39:09 <dmwit> I don't think widgets other than buttons have an analog for the "clicked" event.
20:39:27 <ThatTreeOverTher> I'm trying to get events on an EventBox like so 'onClicked eb (putStrLn "cheese")'
20:39:53 <akurilin> heh directory-tree's readDirectory seems to read the contents of the file and print them given the opportunity
20:39:58 <akurilin> which is interesting for images
20:40:06 * lispy waves at dmwit 
20:40:12 <akurilin> maybe I shouldn't using Data.ByteString.readFile?
20:40:16 * dmwit waves at lispy
20:40:17 <ThatTreeOverTher> dmwit, so how do I get the buttonPressEvent on an EventBox?
20:40:20 <geekosaur> right, Clicked is a button specific high level event, if you are using an EventBox then you get low level events like buttonPressEvent
20:40:33 <dmwit> lispy: See you soon!
20:40:38 <lispy> dmwit: yay!
20:41:02 <ThatTreeOverTher> but how do I get these events?
20:41:14 <lispy> bitemyapp: heh, "boo hoo types" brigade. I haven't heard that before.
20:41:27 <ThatTreeOverTher> "onButtonPressEvent eventBox (putStrLn "cheese")" didn't work
20:41:29 <geekosaur> also onClicked sounds like an obsolete interface to me? isn't it just on with an event?
20:41:32 <pavonia> Everyone interested in gtk in Haskell please join #gtk2hs, we seriously need more people there
20:41:44 <bitemyapp> lispy: it's descriptive of approximately how much substance they bring to the table.
20:41:55 <bitemyapp> akurilin: please notify when your script works :)
20:42:53 <pavonia> ThatTreeOverTher: eventBox `on` buttonPressEvent $ do ...
20:43:20 <dmwit> ThatTreeOverTher: And read about the EventM monad (linked from the documentation for buttonPressEvent) to know what to put in the "do".
20:43:27 <lispy> Does freenode have a category theory channel?
20:43:39 <dmwit> pavonia: Does gtk2hs really need its own channel?
20:43:46 <pavonia> Yes
20:43:47 <ThatTreeOverTher> what's a monad
20:43:48 <roboguy_> lispy: ##categorytheory
20:43:57 <lispy> roboguy_: ah, right the old double hash. Thanks!
20:44:24 <dmwit> pavonia: Okay, I walked into that one. What would be better if there were a separate gtk2hs channel?
20:44:32 <roboguy_> lispy: unfortunately it's quite a bit quieter. no one was there when I was asking about Conceptual Mathematics earlier
20:44:52 <ThatTreeOverTher> pavonia, dmwit alright i'll sleep on this and hopefully i'll understand tomorrow; thanks
20:44:59 <pavonia> dmwit: The biggest problem with #haskell is that questions only few people can answer float away too quickly
20:45:49 <dmwit> Okay.
20:46:26 <dmwit> But I think for the level of traffic we would get on a #gtk2hs, a mailing list is just as good.
20:46:30 <dmwit> And we've got three of those.
20:47:32 <pavonia> A mailing list is usually slower than an IRC channel
20:49:00 <lispy> pavonia: yes, but aren't you saying that slow responses on IRC are a problem with gtk questions?
20:49:19 <c107> Anybody heard of the Yi text editor?
20:49:29 <lispy> c107: yes
20:49:41 <lispy> although, I haven't used yi for quite some time
20:49:52 <pavonia> lispy: Yeah, that's true
20:49:56 <c107> lispy: Why?
20:50:45 <lispy> c107: No real reason. vim and emacs are already installed and fully featured so I guess I just use them.
20:50:56 <pavonia> lispy: I mean with the huge number of messages in #haskell, some minutes not looking at the channel can be enough to miss a question
20:51:09 <lispy> I think at one point yi became graphical instead of terminal based and that made me less interested, but I'm weird that.
20:51:43 <c107> lispy: Are you serious?  Graaphical Emacs is great, so surely a graphical Yi would, too.
20:51:54 <c107> (I can view images in Dired.)
20:52:25 <lispy> c107: it's not really relavant to #haskell, but yes I prefer terminal mode for vim and emacs :)
20:53:18 <c107> I should get Yi so I have more encouragement to learn Haskell and, in turn, learn WEB.
20:53:57 <lispy> c107: are you a student? Can you use Haskell to do your assignments? I did that a lot when learning it.
20:57:36 <c107> lispy: No, I'm not a student, and programming is discouraged at my school.  We are forced to use Macintoshes, and the terminal is prohibited.  I can't get Emacs or execute Bash scripts.  It sucks.
20:58:16 <c107> (I'm in a high school.  I am no student of programming.)
20:58:20 <roboguy_> c107: I use a macintosh but I definitely use the terminal
20:58:24 <roboguy_> that's unfortunate
20:58:51 <roboguy_> c107: you could look into fpcomplete's web based haskell ide
20:59:09 <c107> roboguy_: I have refused to use the Macintoshes because they are effectively speakwrites/telescreens.
20:59:29 <roboguy_> c107: I completely disagree, but that's totally irrelevant to the topic at hand
20:59:48 <c107> roboguy_: At my school, they are speakwrites and telescreens.
20:59:53 <roboguy_> ahh, I see
21:01:04 <c107> The school logs every keystroke, every screen change, every website visited.  The screen goes dark if the camera is covered.  For a while, I was forced to type in QWERTY, which hurt my left hand.
21:01:29 <c107> Now, they monitor all notes, and the teacher can erase and write on it at any time.
21:01:29 <bitemyapp> c107: that is dystopian.
21:01:45 <c107> bitemyapp: It's reality.
21:01:49 <bitemyapp> c107: where is this?
21:02:00 <c107> bitemyapp: Schools with Apple's 1:1 program.
21:02:04 <roboguy_> c107: well, like I said, the fpcomplete ide might work (if they don't block it for some reason)
21:02:40 <c107> roboguy_: Yes, infinite loops in JavaScript still work.  Huehuehuhe!
21:02:58 <roboguy_> c107: you've had an infinite loop with it? I haven't...
21:03:45 <c107> I'm just saying that their security objections are wrong, because they still let students execute JS programs all willy-nilly (because they don't believe JS to be programs.)
21:04:10 <c107> And yet, date(1) is a nasty program to be banned.
21:04:28 <c107> You can run an infinite loop in JavaScript, but date(1) is banned.
21:04:48 <roboguy_> c107: oh. well, anyway you should take a look at https://www.fpcomplete.com/
21:05:03 <roboguy_> that is pretty strange though
21:05:17 <roboguy_> although not too surprising
21:05:46 <c107> roboguy_: That is proprietary.
21:05:53 <roboguy_> c107: there are free student accounts
21:06:01 <roboguy_> I use one, actually
21:06:13 <c107> roboguy_: I wasn't talking about price.
21:06:19 <roboguy_> c107: what where you talking about?
21:06:24 <roboguy_> *were
21:06:27 <c107> roboguy_: It's proprietary.
21:06:36 <roboguy_> c107: yes... so?
21:07:16 <c107> roboguy_: So, I have no community and can't do what I want.  I can only do what the developer wants.  That's not right.
21:07:26 <c107> (When it's on my computer.)
21:07:59 <roboguy_> c107: that's not true at all. Visual Studio is proprietary but that doesn't stop anyone from doing whatever they want with it, as far as writing programs goes
21:08:33 <roboguy_> what do you think you wouldn't be allowed to do?
21:09:21 <c107> roboguy_: Run the server software for this program myself.
21:09:44 <roboguy_> c107: by "this program" do you mean the ide itself?
21:10:02 <c107> roboguy_: The whole service, whatever it is.
21:10:10 <roboguy_> c107: why does that matter?
21:10:17 <shergill> hmm how do you declare common build-depends for library and executable portions in a cabal file?
21:10:27 <c107> roboguy_: For example, I don't publish  to YouTube because I can't run my own instance of YouTube.
21:10:53 <c107> roboguy_: It matters a lot.  It matters, whetehr or not yoru work is on your own computer or someone's server.
21:10:56 <roboguy_> c107: ok... but why do you care? I used to worry about things like that when I was younger, but then I realized there were no practical implications to it
21:11:14 <roboguy_> c107: legally, your youtube videos still belong to you, I believe
21:11:28 <c107> roboguy_: I learned that there are grave implications.  I lost many memories because I lived in the Cloud.
21:12:13 <roboguy_> c107: it also lets you download your code at any time. with such restrictions you will also have to avoid things like github. which is a *huge* shame because github is really really awesome
21:12:41 <c107> roboguy_: GitHub is bad, yes.  Gitorious is right.
21:13:10 <kazagistar> (c107: I agree in principle, but in practice, google and such let you download in convenient formats all the stuff you uploaded whenever)
21:13:37 <vu3rdd> hello haskell hackers!
21:13:47 <c107> kazagistar: I write all my stuff in a lightweight Markup and use a program to convert it.
21:14:02 <roboguy_> c107: well, do what you want. just realize that fpcomplete may provide you with something that will allow you to learn haskell wherever you want in a way that something else wouldn't
21:14:18 <vu3rdd> trying to follow along jekor's pandoc youtube video. Ran into a problem getting cabal-dev to work.
21:14:45 <roboguy_> I would just say keep local copies if you're worried though
21:14:47 <vu3rdd> I first checked out 1.11.1 of pandoc, since that's what I am running at the moment
21:15:03 <vu3rdd> and then did a cabal-dev install
21:15:14 <vu3rdd> and then cabal-dev ghci but get this error: http://lpaste.net/102322
21:15:49 <c107> Is there an info document introduction to Haskell?
21:15:57 <vu3rdd> cabal-dev .. can't parse --info output of ghc
21:16:25 <roboguy_> c107: you mean something like a tutorial/book? usually "learn you a haskell" is recommended
21:17:01 <roboguy_> c107: oh, one last thing about fpcomplete: they have resources to learn haskell and you can execute the code examples even without an fpcomplete account
21:19:20 <c107> roboguy_: I appreciate this new awareness, even though I won't be using it.
21:21:12 <roboguy_> c107: ok. it is just a normal website though, so you might consider at least giving it a shot. but that's all I'll say
21:22:41 <c107> roboguy_: Google Docs and Instagram are normal websites.
21:22:57 <intrados> I can `cabal install haste-compiler` but a .cabal with `haste-compiler` errors out with `unknown package: haste-compiler` during `cabal build`
21:23:04 <intrados> Does that make sense?
21:23:13 <c107> i gotta catch some z's
21:23:27 <roboguy_> c107: but with fpcomplete's tutorial info (which by the way, totally unrelated to learn you a haskell) is something you don't even need an account of *any* kind. it just happens to have a button that will let you run code examples and show you the output, even if you change them a bit
21:23:32 <roboguy_> good night
21:24:30 <roboguy_> well, that was really frustrating
21:28:11 <shergill> how do you declare common build-depends for library and executable portions in a cabal file?
21:28:29 <shergill> having the executable depend on the library doesn't seem to do the trick
21:49:35 <randomclown> is there a list type that's unordered?
21:49:36 <lispy> shergill: what is the cabal version set at?
21:49:59 <jle`> randomclown: what do you mean
21:50:06 <shergill> lispy: hmm the default. >=1.10
21:50:08 <jle`> like a set with duplicates?
21:50:11 <randomclown> yep
21:50:22 <randomclown> I suppose I can just use the Map
21:50:26 <dmwit> Yes, there are bag implementations.
21:50:32 <dmwit> Generally done with Map, as you say.
21:51:11 <dmwit> ?hackage multiset
21:51:11 <lambdabot> http://hackage.haskell.org/package/multiset
21:51:27 <shergill> lispy: changing the cabal-version to >=1.18 doesn't seem to alter the behaviour
21:51:32 <dmwit> There's also
21:51:40 <dmwit> ?hackage signed-multiset
21:51:40 <lambdabot> http://hackage.haskell.org/package/signed-multiset
21:51:44 <hamid> isn't haskel.org down?
21:51:57 <randomclown> dmwit: cool
21:51:59 <dmwit> hamid: WFM
21:53:56 <hamid> dmwit, alright
21:54:16 <jle`> well
21:54:20 <hamid> it was my proxy :/
21:54:23 <jle`> are you using haskel.org ?
21:54:31 <jle`> ah
21:54:47 <shergill> does everyone just duplicate the build-depends (between library and executable)?
21:55:32 <dmwit> Only if the library and executable depend on the same stuff. ;-)
21:55:41 <shergill> heh
21:56:51 <shergill> it's somewhat surprising to me that there isn't a let x in syntax or a way to remove the redundancy. there seem to be online claims that making the executable depend on the library is supposed to solve it, but i'm unable to reproduce. i should try from scratch
21:56:56 <jle`> sometimes the executable needs more than the library
21:57:33 <jle`> there is some redundancy, but the cabal file spec isn't exactly meant to be too intelligent
21:58:04 <dmwit> shergill: Also, I'm pretty sure lispy was asking you to lower the cabal version, not increase it.
21:58:18 <dmwit> Older cabals shared build-depends across library/executable blocks.
21:58:25 <dmwit> (This was confusing and generally wrong.)
21:58:43 <shergill> oh
21:58:52 <shergill> interesting
22:02:02 * hackagebot twitter-types 0.2.20140406 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.2.20140406 (TakahiroHimura)
22:02:48 <shergill> dmwit: why would it *generally* be wrong?
22:04:42 <dmwit> Usually the two things don't depend on *exactly* the same packages.
22:05:05 <pordan30> can anyone point me in the direction of efficient graph representations in haskell? i'm modelling directed (possibly cyclic) graphs with node and edge attributes, and am running into some problems with the standard representation, namely mapping node indices to contexts containing node attributes and adjacency lists. this seems to eliminate the problem of storing node attributes more than once, but doesn't handle the problem of edg
22:05:05 <lispy> shergill: This .cabal file does what I think you're asking: https://github.com/dagit/haray/blob/master/haray.cabal
22:05:05 <pordan30> e attributes well (i.e., edges are inferred from the mapping, so where should edge attributes go to reduce duplication). my current idea is to store attributes in a separate table, but this isn't particularly sightly.
22:05:18 <dmwit> pordan30: fgl
22:05:59 <lispy> pordan30: there is a binding to igraph. It's supposed to be really efficient. I don't know if it supports your particular representation
22:06:17 <lispy> pordan30: the downside being the FFI dependency
22:07:30 <shergill> lispy: it seems to, yes. thanks
22:07:48 <lispy> pordan30: The sort of typical graph representation for a sparse graph is adjacency lists.
22:09:26 <lispy> shergill: but notice I still have to duplicate a fair bit
22:09:55 <lispy> shergill: I guess the rule is, you have to duplicate it if the modules of the executable directly use it
22:10:54 <pordan30> thanks, dmwit and lispy - i'll give fgl and igraph a look
22:11:51 <shergill> lispy: right. the duplication feels very unhaskell-y. makes me sad
22:13:32 <lispy> pordan30: fgl is well-known, but it has a lot of partial functions and I've heard the performance scaling is not so great. YMMV.
22:13:50 <kazagistar> so, I was thinking about ways to make a practical regex-based string generator for Arbitrary (genex has a number of severe limitations) but keep getting stuck because I don't know enough graph topology or something, dunno
22:13:55 <lispy> the authors of the igraph binding said that fgl just didn't scale for them.
22:14:09 <jle`> is there a reason why there is no killer graph library for haskell
22:14:31 <jle`> i have been searching myself recently
22:14:42 <pordan30> yeah, i'm reading the interface right now, and was surprised that even simple operations like lookup don't return in a monad (or even maybe)
22:14:55 <lispy> jle`: I think it's entirely possible to make one, we just haven't. fgl could become that with a lot of work.
22:15:13 <kazagistar> man, I miss networkx from python
22:16:17 <jle`> any /b 6
22:16:26 <jle`> any papers?
22:16:32 <jle`> many good libraries seem to come from good papers
22:16:45 <dmwit> fgl came from a good paper.
22:16:54 <lispy> jle`: I think a lot of times people work on graphs that have a lot of restrictions for their problem domain and utilizing those constraints leads to more efficient algorithms and representations that are not fully general. So in most settings/languages a good generic graph library just doesn't exist (as far as I can tell)
22:17:32 <jle`> lispy: that does make sense
22:17:39 <lispy> jle`: I've been meaning to read this: https://www.cs.utexas.edu/~wcook/Drafts/2012/graphs.pdf
22:17:40 <dmwit> I think there's another piece.
22:17:40 <pordan30> it also looks like the default implementation of Gr using IntMap has a relatively large space profile
22:17:57 <kazagistar> I am starting to think that for regex and graphs, arbitrary is a grossly insufficient abstraction which is sad...
22:18:04 <dmwit> People use tree-structured data a *lot* in Haskell. But you don't see Data.Tree getting used a lot.
22:18:10 <erisco> jle`, I have looked a fair bit the graph thing and it seems the main inhibitor is that there is no optimal way to do things
22:18:14 <dmwit> Why not? Answer: all data stored in a Tree has to be the same type.
22:18:30 <dmwit> Instead, you want the type system to do more for you.
22:18:57 <dmwit> You want *this* part of the tree to always have two Ints, and *this* part to have one recursive child, and *this* part to fulfill this data schema...
22:19:08 <dmwit> So it seems natural to want that kind of thing when you turn to graphs, too.
22:19:27 <erisco> jle`, I have come up with three (iirc) basic strategies for representing a graph that each have unique advantages
22:19:33 <dmwit> But a graph library can't provide that. It can only provide the "one-type-fits-all" approach.
22:19:45 <jle`> erisco: i see a blog post coming?
22:19:54 <erisco> jle`, I do not blog =\
22:20:09 <jle`> erisco: you should :) it is a haskell rite of passage or something
22:20:14 <lispy> dmwit: yeah, those are good points too
22:20:17 <jle`> hm
22:20:39 <jle`> i need some sort of graph for my markov processes library
22:20:49 <jle`> a simple adjacency matrix would work fine
22:20:50 <lispy> and there is this: http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Graph.html
22:20:51 <jle`> but
22:20:57 <jle`> what about infinite state spaces
22:21:16 <kazagistar> jle`: you might just be seeing a bias of visibility... everyone in haskell blogs, you know it because all the haskell bloggers who you see are blogging :P
22:21:48 <erisco> jle`, there are two prevalent approaches in existing libraries. 1) graphs are constructed and edited piecewise and are backed with an indirect and dynamic representation (basically tree maps or something)
22:22:07 <jle`> kazagistar: maybe i am just projecting my ideal world :)
22:22:16 <dmwit> Other languages deal with that by just having cycles in the heap. You can do that in Haskell, too, but without mutability/observable sharing a lot of the benefit of taht approach is lost.
22:22:39 <erisco> jle`, 2) the graph is fixed and is backed by fixed structures (such as vector) giving optimal lookup times
22:24:20 <erisco> jle`, and something that I have not seen, and I received much contention about, is a representation which is the infinite unfolding of the graph
22:25:04 <dmwit> Yeah. There's a lot of nice things about infinite unfoldings. There's a lot of really unfortunate things, too, though.
22:25:14 <erisco> jle`, and that is optimal when you do not need certain capabilities such as random node access
22:26:21 <erisco> jle`, basically the infinite unfolding is great if all you ever need is to walk the graph
22:26:47 <lispy> jle`: I think with a generic graph library your audience is going to be people who want an easy solution to a graph problem that is secondary to their real concern.
22:27:53 <lispy> If the core of someone's problem is graph theoretic, I bet they will want to roll their own implementation to take advantage of something specific to their problem.
22:28:27 <erisco> there are other headaches as well, though... do you label nodes and edges? how do you represent directional vs undirectional? you *can* generalise to accomodate all cases... but if your generalised form is too verbose for certain cases, your lib will not be used
22:28:28 <lispy> (like the tree analogy given above)
22:28:50 <erisco> kind of like Data.Tree is seldomly used, it seems, because it is more convenient to define your own tree-like structures
22:29:29 <kazagistar> as I said earlier, my favorite graph library (that I have used) is http://networkx.github.io/documentation/development/... it is slow and inefficient, but it is well documented and provides great reference material for understanding the giant collection of algorithms and implementing your own
22:29:52 <erisco> also how are edges stored? for generating DFAs you really need to store them in an IntervalMap
22:29:55 <kazagistar> an actually functional and native one would just rick though
22:30:11 <erisco> and so you can try and define the graph such that the edges are stored in something Foldable or Traversable
22:30:17 <erisco> but it is yet another headache to worry about :P
22:31:31 <dmwit> kazagistar: fgl is actually functional. not sure what "native" entails
22:32:19 <kazagistar> dmwit: if its haskell it provides what I meant, in that it does not run 1000 times slower then C
22:32:40 <dmwit> It is Haskell.
22:32:50 <erisco> jle`, but I would like to see a library that can at least offer algorithms for a majority of possible graph representations
22:33:16 <lispy> Given the wide range of options with graphs and the different ways you might want to implement the algorithms, it almost seem like we should have a DSL for working with graphs instead of just a library.
22:33:19 <erisco> even if you want to define your own data type, it would be awesome if you could instance some classes and then gain access to all the common algos
22:34:01 <kazagistar> dmwit: I got that, thought its library seems a little sparse and less documented... it might be worth poking around and contributing to though
22:34:18 <dmwit> kazagistar: There's a good paper that doubles as documentation.
22:35:25 <kazagistar> dmwit: in networkx, most of the hundreds of algorithms have a list of citations, so competition is fierce :P
22:37:54 <dmwit> =)
22:39:34 <lispy> ideally you specify the details of your model/problem and the DSL would take care of optimizing the representation and picking good algorithms.
22:40:36 <dmwit> lispy: You might be interested in unql or something like that.
22:42:49 <lispy> https://github.com/tinkerpop/gremlin/wiki
22:43:00 <lispy> unql? /me googles it
22:43:16 <jle`> erisco: i see
22:44:18 <dmwit> hrm
22:44:32 <dmwit> Google's first hit seems to be for something else.
22:45:16 <dmwit> lispy: ftp://ftp.cse.buffalo.edu/users/azhang/disc/disc01/cd1/out/papers/vldbj/9.1.76.pdf
22:46:34 <lispy> thanks
22:50:08 <mhitza> is there a way I can configure hoogle such that it would only work with the packages inside a sandbox? (hoogle is installed in the sandbox as well)
22:54:41 <yogert> When doing threaded stuff using forkio etc, what precautions should I take when writing to files from the threads?
22:54:41 <yogert> or does haskell prevent problems from occurring somehow...?
22:56:28 <erisco> yogert, you should prevent two threads from writing to the same file simultaneously
22:56:28 <Cale> yogert: Don't write to the same file from different threads would be a good rule
22:57:47 <erisco> well, simultaneous is a bit of a misnomer... concurrently is more accurate
22:58:16 <yogert1> sorry was that to me? I lost connection for a bit. ill have to go through the logs to see what was sad
22:58:18 <yogert1> said
22:59:48 <yogert1> Cale, yeah i was thinking that : ). Well what if i had several threads pushing stuff onto a TQueue that would be written by another thread
22:59:56 <yogert1> that would be fine, yes?
23:00:00 <Cale> Yeah, that's fine
23:00:38 <Cale> (or even just a Chan will usually do, unless you're using STM for more than just this)
23:02:09 * hackagebot cryptohash-cryptoapi 0.1.3 - Crypto-api interfaces for cryptohash  http://hackage.haskell.org/package/cryptohash-cryptoapi-0.1.3 (VincentHanquez)
23:02:18 <yogert1> What the difference between a Chan and a Queue? I think i read somewhere that the difference is Queues don't cant be duplicated, and are implemented using arrays or something
23:03:29 <c_wraith> yogert1: what Queue do you mean?
23:04:26 <yogert1> TQueue
23:04:38 <yogert1> I haven't made use of TBQueue yet...
23:05:10 <c_wraith> yogert1: the very first section of http://hackage.haskell.org/package/stm-2.4.3/docs/Control-Concurrent-STM-TQueue.html seems to answer your question
23:05:20 <yogert1> yeah i was just reading that
23:05:38 <yogert1> i just didn't understand the suggestion to use a Chan
23:05:42 <Cale> hm, I didn't know that TQueue was faster than Chan
23:05:48 <Cale> That's interesting
23:06:28 <c_wraith> Chan is slowed down by handling errors properly, IIRC
23:06:45 <c_wraith> If it didn't have error handling, it'd be way faster.
23:07:21 <c_wraith> But the fact that a thread blocked on an MVar read/write can be interrupted by asynchronous exceptions means that it needs to be kind of careful.
23:11:03 <yogert1> Also, I asked this question earlier regarding the Database.Persistent package, but didn't get a response… I don't know how familiar you guys are with it, but what would be the best way to access it from threads? I'm not too clear on whats going on under the hood, but intuitively, I'd say doing "withSqliteConn 'myDB.db3' $ runSqlConn $ foo" is a bad idea
23:11:28 <bitemyapp> yogert1: if you care about multi-threaded access, you can't use sqlite period.
23:11:38 <yogert1> yeah, i read that
23:11:43 <yogert1> well postgres then
23:11:44 <yogert1> : )
23:11:45 <bitemyapp> yogert1: no database library can or will save you from that kind of raw unwisdom.
23:11:55 <yogert1> ha
23:11:59 <bitemyapp> unwisdom? cowisdom. The dual of wisdom.
23:12:28 <bitemyapp> yogert1: use postgresql, live longer due to less stress.
23:13:19 <yogert1> Well using Persist though, would I have to perform all of the thread actions inside a SqlPersistM to also access the database?
23:14:37 <mhitza> bitemyapp, couldn't he "guard" access to the sqlite handler via STM?
23:16:02 <yogert1> mhitza, ah so there is a "handler"?
23:16:18 <yogert1> that can be passed around
23:16:29 <mhitza> yogert1, "handler", I actually meant a connection resource, which I assume is returned upon connection
23:16:30 <yogert1> Sorry, I've been trying to get all the types straight
23:16:38 <bitemyapp> you could serialize operations against the side-effecting resource
23:16:47 <bitemyapp> but again, multiple threads imply sqlite is inappropriate.
23:17:01 <yogert1> yeah sure, I'm not tied to it
23:17:31 <bitemyapp> sqlite is generally used where one wants an embedded database
23:17:53 <bitemyapp> if you do in fact want an embedded database, acid-state might actually be a lot nicer if you aren't specifically tied to using Persistent.
23:18:07 <bitemyapp> but if you have no specific needs: postgres
23:18:34 <yogert1> okay. i'll do that
23:18:58 <yogert1> do you know of any projects I could look at to see how they access the database?
23:19:05 <yogert1> I
23:19:18 <yogert1> ve been having problems getting the types to work heh
23:23:33 <kcc> Is there a builtin function that, for example takes [1..10] and returns [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]]?
23:23:52 <kcc> I wrote my own, but I'm new in haskell and I feel it's probably builtin
23:23:57 <kcc> subsequenceL n l = sequence ((\i -> drop i . take (i+n)) <$> [0..length l - n]) l
23:24:55 <kcc> @let subsequenceL n l = sequence ((\i -> drop i . take (i+n)) <$> [0..length l - n]) l
23:24:56 <lambdabot>  Defined.
23:25:06 <kcc> > subsequence 2 [1..15]
23:25:07 <lambdabot>  Not in scope: `subsequence'
23:25:07 <lambdabot>  Perhaps you meant one of these:
23:25:07 <lambdabot>    `subsequenceL' (line 153),
23:25:07 <lambdabot>    `subsequences' (imported from Data.List),
23:25:07 <lambdabot>    `sequence' (imported from Control.Monad.Writer)
23:25:18 <kcc> > subsequenceL 2 [1..15]
23:25:21 <lambdabot>  [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12,...
23:26:58 <enthropy> > map (take 2) (tails [1 .. 5])
23:26:59 <lambdabot>  [[1,2],[2,3],[3,4],[4,5],[5],[]]
23:27:25 <kcc> Ah that looks much simpler
23:28:08 <keshav> hello
23:28:12 <pavonia> > (\c -> zipWith (\x y -> [x, y]) c (tail c)) [1..10]
23:28:13 <lambdabot>  [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]]
23:29:01 <keshav> can anyone please help me in my assignment
23:29:32 <pordan30> what is your assignment?
23:30:13 <keshav> its on c programing
23:31:27 <pavonia> This channel is about programming in Haskell
23:31:27 <keshav> is there some1 who has done c programing
23:31:34 <keshav> ok
23:32:02 <pordan30> you might consider asking for help in ##c if your question regards c
23:32:36 <keshav> i dnt know where to get a cc chanel
23:33:17 <pordan30> type "/join ##c" to access the c channel on freenode, i believe
23:34:41 <keshav> ok thanks
23:48:03 <vivaldi> hello, for example I have a list "haskellhaskellhaskell" I want to print every "haskell" in a line. How can I do that?
23:49:25 <jle`> is there a simple way to flush stdout?
23:49:35 <jle`> vivaldi: is your list a list of haskells
23:49:41 <jle`> or a list of letters?
23:49:45 <jle`> > repeat "haskell"
23:49:46 <lambdabot>  ["haskell","haskell","haskell","haskell","haskell","haskell","haskell","hask...
23:49:48 <vivaldi> letters
23:49:50 <jle`> > cycle "haskell"
23:49:51 <lambdabot>  "haskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhaske...
23:49:53 <jle`> ah
23:50:04 <pavonia> vivaldi: How do you determine the length of the word to print on each line?
23:50:06 <jle`> well
23:50:14 <jle`> you can use length
23:50:19 <jle`> of the string
23:50:26 <jle`> and divide it by 7
23:50:27 <vivaldi> : pavonia, it's fixed length of "haskell"
23:50:32 <jle`> and print haskell n times
23:51:22 <erisco> > splitAt 7 "haskellhaskellhaskell"
23:51:22 <lambdabot>  ("haskell","haskellhaskell")
23:51:23 <vivaldi> length of the string and length of each line is fixed, but every lines should not be same
23:51:27 <erisco> there is a clue for your hw :)
23:51:37 <jle`> every line should not be the same?
23:51:42 <vivaldi> yes
23:51:48 <pavonia> > chunksOf 7 $ cycle "haskell"
23:51:49 <jle`> but every line is "haskell"
23:51:49 <lambdabot>  ["haskell","haskell","haskell","haskell","haskell","haskell","haskell","hask...
23:52:23 <vivaldi> it's just an example, everyline is different, but their lengths are same
23:52:36 <jle`> chunksOf might be useful for you
23:52:45 <jle`> can you give a better example?
23:53:41 <vivaldi> for example  my string is "haskellmrcurryexample"
23:54:08 <vivaldi> first line should be "haskell" second should be "mrcurry" third should be "example"
23:54:12 <jle`> > chunksOf 6 "haskellmrcurryexample"
23:54:13 <lambdabot>  ["haskel","lmrcur","ryexam","ple"]
23:54:16 <jle`> > chunksOf 7 "haskellmrcurryexample"
23:54:17 <lambdabot>  ["haskell","mrcurry","example"]
23:55:18 <vivaldi> ok thank youé
23:55:23 <vivaldi> you!
23:55:58 <pordan30> before using imported functions like chunksOf, have you thought through how to divide the input string into blocks of equal length (except the last block) using explicit recursion and/or combinations of take/drop? it sounds like this is an exercise for a class, is why i ask...
23:56:40 <vivaldi> yeah, I got the idea, I will figure it out somehow
23:57:23 <jle`> aw
23:57:27 <jle`> figure it out tonight :)
