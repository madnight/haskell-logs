00:06:32 <Wizek> Good Morning!
00:13:12 <jle`> good morning Wizek :)
00:29:13 <lispy> ⊤ of the morning to ya!
00:30:34 <bitemyapp> lispy: LOL
00:31:01 <[swift]_> it really amazes me how easy it is to install ghc and cabal-install from scratch
00:31:09 <[swift]_> not sure why i've been relying on the haskell platform all this time
00:31:25 <bitemyapp> [swift]_: *shrug8
00:32:16 <lispy> [swift]_: That's the way I do it. I use sandboxes and I never pay attention to the version in the HP, so it buys me nothing.
00:32:23 <pavonia> Is there a monadic version of fromMaybe/maybe somewhere?
00:32:41 <bitemyapp> pavonia: >>=?
00:32:49 <[swift]_> lispy: yeah, that's what i've started doing too since cabal's builtin sandboxes arrived
00:32:53 <lispy> [swift]_: I do wish I could download a binary of cabal-install to make bootstrapping just that much easier.
00:33:03 <[swift]_> on OS X you can =)
00:33:30 <[swift]_> i'm actually setting it up on linux VM now and was surprised that there wasn't a binary version for linux
00:33:47 <pavonia> bitemyapp: I mean something like Monad m => m b -> (a -> m b) -> Maybe a -> m b
00:34:20 <lispy> :t fromMaybe
00:34:21 <pavonia> Err, wait
00:34:21 <lambdabot> a -> Maybe a -> a
00:34:24 <jack_rabbit> [swift], there is for many platforms.
00:34:28 <lispy> :t maybe
00:34:29 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:34:30 <jack_rabbit> s/platforms/distros/
00:34:51 <pavonia> lispy: Yeah, I just noted that :D
00:35:00 <lispy> > maybe (return ()) id (Just ())
00:35:01 <lambdabot>  Couldn't match expected type ‘m ()’ with actual type ‘()’
00:35:15 <lispy> > maybe (return ()) (const ()) (Just ())
00:35:16 <lambdabot>  Couldn't match expected type ‘m ()’ with actual type ‘()’
00:35:26 * lispy should just go to bed instead of trying to do this tired
00:35:40 <mikeplus64> > :t maybe Nothing id
00:35:41 <lambdabot>  <hint>:1:1: parse error on input ‘:’
00:35:47 <mikeplus64> :t maybe Nothing id
00:35:48 <lambdabot> Maybe (Maybe a) -> Maybe a
00:35:49 <lispy> > maybe (return ()) (const (return ())) (Just ())
00:35:50 <lambdabot>  No instance for (GHC.Show.Show (m0 ()))
00:35:50 <lambdabot>    arising from a use of ‘M358807033652950105728515.show_M3588070336529501057...
00:35:50 <lambdabot>  The type variable ‘m0’ is ambiguous
00:35:50 <lambdabot>  Note: there are several potential instances:
00:35:50 <lambdabot>    instance [safe] GHC.Show.Show a =>
00:35:53 <mikeplus64> hurp
00:35:59 <lispy> nice error there
00:36:55 <mikeplus64> :t traverse
00:36:56 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
00:37:47 <lispy> pavonia: I assume from your comment that you already figured it out.
00:37:56 <lispy> @type maybe (return ()) (const (return ())) (Just ())
00:37:57 <lambdabot> Monad m => m ()
00:38:29 <[swift]_> jack_rabbit: really? i don't see them here: http://www.haskell.org/cabal/download.html
00:38:39 <[swift]_> jack_rabbit: or do you mean in the distro's package repos?
00:38:51 <pavonia> lispy: Yup, thanks anyway
00:38:53 <lispy> @type maybe (putStrLn "hello!") (\x -> putStrLn ("Hello, " ++ x)) (Just "Steve")
00:38:54 <lambdabot> IO ()
00:40:35 <lispy> :t maybe maybe (const maybe) Nothing
00:40:35 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:42:56 <lispy> > (maybe maybe (const maybe) Nothing) "default" (\a -> "non-default: " ++ a) (Just "a")
00:42:57 <lambdabot>  "non-default: a"
00:43:01 <lispy> > (maybe maybe (const maybe) Nothing) "default" (\a -> "non-default: " ++ a) Nothing
00:43:02 <lambdabot>  "default"
00:43:13 <lispy> What is the opposite of golf?
00:43:44 <trolling> squirrels
01:00:54 <jack_rabbit> [swift], I did, yes.
01:09:57 <Wizek> > show _
01:09:58 <lambdabot>  Found hole ‘_’ with type: a0
01:09:58 <lambdabot>  Where: ‘a0’ is an ambiguous type variable
01:10:48 <Wizek> Hmm. Is there a way to make GHC give me the type class constraints of typed holes?
01:13:47 <gtrambly> HRMM
01:14:03 <gtrambly> is it probably better to prefer the top or the bottom approach?
01:14:04 <gtrambly> http://screencloud.net/v/tJR3
01:14:12 <gtrambly> both lines of code are the same
01:14:26 <gtrambly> it's just two different ways of doing it
01:14:47 <SwashBuckla> hmph id not heard _ named hole before
01:15:28 <gtrambly> the top is more verbose i guess but...
01:15:34 <laar> > show (_::a)
01:15:35 <lambdabot>  Found hole ‘_’ with type: a
01:15:35 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
01:15:35 <lambdabot>             an expression type signature: a at <interactive>:1:7
01:15:50 <gtrambly> ...i guess it means i'm free to redefine FractionalHour as I please later on? <_<
01:15:56 <gtrambly> is that something to aspire to, reasonably?
01:16:04 <gtrambly> to make that simpler?
01:16:55 <gtrambly> is it better to interact with an Applicative if so defined as opposed to trying to interact with the underlying datatype of using the Applicative class makes the operation more verbose?
01:16:58 <SwashBuckla> doesnt that abuse the purpose of _? (catch-all)
01:17:16 <gtrambly> if using the Applicative*
01:18:02 <SwashBuckla> or can you use several typed holes to match against polymorphic types?
01:21:21 <gtrambly> http://screencloud.net/v/yHWJ <--- is this completely overengineering the problem, even? is it better just to define a function that applies to the Applicative directly as opposed to expecting an application via <*>?
01:23:18 <gtrambly> so confusing trying to do things the haskell way. i just keep tripping up by making my code even more complicated
01:24:09 <bennofs> gtrambly: what do you use fractional hour for?
01:24:35 <gtrambly> to indicate what fraction of a shift hour a guard is compensated for
01:27:02 <gtrambly> basically depending on the precise hour, federal legislature regarding fair pay may impose different rates of pay. so i split a day into 24 units (each an hour long) and superimpose a shift over the 24 units. the individual units can be reasoned about more simply individually than in one big lump
01:28:13 <gtrambly> it's basically integration by pieces
01:28:35 <gtrambly> parts* sorry, french education : (
01:30:47 <aristid> gtrambly: what's the definition of FractionalHour? and why does it have a functor structure?
01:31:38 <gtrambly> http://screencloud.net/v/FrpX
01:31:44 <gtrambly> that's the more complete definition
01:32:04 <aristid> gtrambly: it does seem a bit like you're overcomplicating it, but it's hard to say without more context
01:32:09 <aristid> @where hpaste
01:32:09 <lambdabot> http://lpaste.net/new/haskell
01:32:09 <gtrambly> basically as the shift data becomes more and more refined the type of a changes
01:32:33 <shachaf> A screenshot is a terrible way to share code with the channel. :-(
01:32:37 <aristid> what's a typical "a" then?
01:32:42 <gtrambly> sorry : (
01:32:52 <gtrambly> well, here are a couple:
01:33:57 <gtrambly> grah, sorry, i think i have to screenshot again. can't seem to copy inside my VM
01:34:12 <shachaf> FractionalHour is like (Product Double,)
01:34:24 <gtrambly> http://screencloud.net/v/11OV
01:34:26 <shachaf> I.e. Writer
01:34:39 <gtrambly> oh?
01:34:45 <gtrambly> i never considered that
01:34:51 <gtrambly> but basically -
01:34:57 <gtrambly> ShiftHour is one
01:35:05 <gtrambly> ShiftPayCategory is derived from ShiftHour
01:35:17 <aristid> gtrambly: why do you multiply fractional hours?
01:35:26 <aristid> that gives you square hours oO
01:36:00 <gtrambly> since by default the fraction is 1.0, which is the multiplicative identity i guess
01:36:01 <aristid> no ShiftPayCategory is evidently not derived from ShiftHour:)
01:36:07 <gtrambly> nonono
01:36:08 <gtrambly> i mean
01:36:16 <gtrambly> you calculate ShiftPayCategory
01:36:18 <gtrambly> from ShiftHour
01:36:23 <aristid> ah.
01:36:52 <gtrambly> http://screencloud.net/v/aEa7
01:36:52 <gtrambly> like that
01:37:22 <aristid> most VMs support copy&paste
01:37:31 <aristid> you may need to configure it properly
01:38:15 <gtrambly> let me check my configuration
01:38:19 <aristid> gtrambly: can you show an operation that involves a full "FractionalHour" object?
01:39:11 <Wizek> https://stackoverflow.com/questions/23028124/is-there-a-way-to-make-ghc-provide-the-type-class-constraints-of-typed-holes
01:39:30 <aristid> Wizek: oh ghc 7.8 doesn't?
01:39:46 <gtrambly> http://screencloud.net/v/tGzt
01:39:48 <gtrambly> here's one
01:40:03 <Wizek> aristid: Not in a way that I know of.
01:40:51 <aristid> gtrambly: and shiftHoursForTimePeriod?
01:41:16 <aristid> Wizek: that's a shame
01:41:42 <aristid> Wizek: but then type holes are new, so no wonder they aren't perfekt yet?
01:42:26 <gtrambly> oh, sorry. in the process of being written: http://screencloud.net/v/aOfO
01:43:22 <aristid> gtrambly: ok, i think what you might want is this:
01:43:24 <Wizek> aristid: True. I am hoping that either a) someone will come along and tell me how it is in fact possible currently, or b) reassure me that it is planned for 7.8.2.
01:44:22 <aristid> newtype FractionalHour = FractionalHour Double, and then just use tuples (FractionalHour, ShiftHour)
01:44:51 <aristid> gtrambly: and instead of imposeFractional n <*> pure x you just do (FractionalHour n, x)
01:45:30 <aristid> gtrambly: instead of a tuple you can also use a dedicated data type, doesn't really matter
01:45:30 <gtrambly> hm, i see! alright thanks for the input, i'll reel the functors/applicatives back
01:45:46 <aristid> gtrambly: but do get rid of that phony applicative. multiplying hours does not make sense.
01:45:56 <gtrambly> oh not hours as such
01:45:58 <gtrambly> fractions of hours
01:46:07 <aristid> no sense either.
01:48:07 <aristid> gtrambly: i think what you were trying to capture in that multiplication, which is still not really necessary is something like Last/Maybe: it can be either Nothing or Just something, and then you have a Monoidal identity on Nothing
01:48:11 <gtrambly> my rationale behind that was ease of manipulation when later needing to multiply those fractional hours by some scalar value (since under federal law, the value of any period of work beneath a certain number of hours is worth higher)
01:48:28 <gtrambly> lots and lots and lots of red tape
01:48:41 <aristid> ok multiplying scalars with a hour is an asymmetric operation
01:48:51 <aristid> one one side you have the scalar on the other you have the hour
01:49:16 <aristid> scalarMult :: Double -> FractionalHour -> FractionalHour
01:49:34 <aristid> (this being my newtype version of FractionalHour here)
01:54:45 <angerman> What library is recommended for storing persisted data? Writing it to tsv files could work, but using sqlite would be a little more powerful and give a more unified interface. What's the idiomatic approach in haskell?
01:57:28 <aristid> angerman: i don't think there's a standard approach, but there are fairly decent json libraries maybe that makes sense (aeson)
01:58:04 <mikeplus64> angerman: http://hackage.haskell.org/package/sqlite-simple is pretty nice
01:58:23 <gtrambly> isn't acid-state supposed to be really interesting?
01:58:53 <gtrambly> http://acid-state.seize.it/
01:58:53 <angerman> aristid: thanks. Will have to see if going down the file/json based route or a database will be a better approach.
01:58:55 <gtrambly> this one here!
01:59:35 <gtrambly> it's not SQL but it gives full ACID guarantees, and lets you use a subset of Haskell datastructures directly for storage
01:59:46 <angerman> mikeplus64: thanks. Did read the part about the hdbc sqlite driver on the RWH book. Yesod's Persistent lib seems to abstract that all away a little, but looks slightly complex.
02:01:08 <angerman> gtrambly: that looks interesting as well.
02:01:15 <mikeplus64> angerman: yeah, i find persistent is a bit too much
02:05:17 <merijn> angerman: Acid-state is really neat for persisting program state type things, it's less good if you expect your data to be bigger than what you can have in memory, so it doesn't really replace a real database
02:05:43 <merijn> But if you just have like a daemon that needs to persist it's state or something, it's great
02:05:49 <angerman> merijn: ahh thanks. Didn't register taht at first.
02:06:41 <merijn> Basically, it's usecase can be summed up as "I have a haskell data structure in memory that needs to survive a program crash"
02:06:55 <merijn> (or program restart, whatever)
02:07:00 <angerman> that HDBC.Sqlite3 looks a little too low level for what I want. Persistent looks awesome, but I don't grok it yet. sqlite-simple seems to be a nice middleground. Though schema creation would be a nice bonus I think I can do without for now :)
02:07:44 <angerman> merijn: no I'm going to build an invoicing system, so I need to keep track of lists of customers and invoices :)
02:08:07 <aristid> angerman: and i presume you don't want a postgres daemon?
02:08:50 <merijn> angerman: Then I would probably go with an SQL database
02:08:51 <angerman> Oh no. this should be single binary only.
02:09:09 <merijn> SQLite is always a decent starting point
02:09:11 <angerman> which is why I'm looking at sqlite and not a full blown one.
02:09:33 <aristid> fair enough
02:11:01 <angerman> I've basically assembled a list of tools I intend to use: decimal, hastache, vty-ui and now sqlite-simple
02:12:08 <angerman> though, decimal and hastache do not yet work together as I'd like. Effectively decimal and hastache don't work together at all :) so instead of doning the conversion in hastache's template, I have to turn decimals into strings before feeding them into hastache.
02:28:32 <merijn> angerman: I think you could make decimal and hastache work together by providing an orphan instance for MuVar for Decimal?
02:29:20 <angerman> merijn: I assume something like that, but then this syb stuff is also very new to me.
02:29:52 <merijn> It'll probably be a bit tricky, yeah :)
02:51:34 <angerman> O_o sqlite-simple worked out of the box... what just happend?
03:22:50 <kirelagin> hmm, something's wrong with lambdabot…
03:22:54 <kirelagin> @unmtl MaybeT (State s) a
03:22:54 <lambdabot> (State s) (Maybe a)
03:23:01 <kirelagin> @unmtl State s (Maybe a)
03:23:02 <lambdabot> s -> ((Maybe a), s)
03:23:12 <kirelagin> @unmtl (State s) (Maybe a)
03:23:12 <lambdabot> (State s) (Maybe a)
03:23:23 <gtrambly> is there a way to express (\x -> someValue - x) without having to throw around full-blown lambda syntax? i can't seem to get (-someValue) to work, and obviously ((-)someValue) is the wrong way around...
03:23:55 <gtrambly> ugh neg
03:24:00 <gtrambly> that's the problem, isn't it?
03:24:05 <kirelagin> gtrambly: (-) is actually the only exception that doesn't has this kind of section
03:24:16 <kirelagin> gtrambly: flip (-) someValue
03:24:21 <gtrambly> thanks
03:25:14 <identity> > let someValue = 3 in (+ (-x)) where x = 1
03:25:15 <lambdabot>  <hint>:1:31: parse error on input ‘where’
03:25:17 <identity> eh
03:25:22 <identity> > let someValue = 3 in (+ (-1))
03:25:23 <lambdabot>  <Integer -> Integer>
03:25:38 <identity> > let someValue = 3 in (+ (-1)) someValue
03:25:39 <lambdabot>  2
03:25:42 <identity> it looks stupid
03:26:05 <kirelagin> identity: my bet is that (-1) is a single literal
03:27:05 <kirelagin> hm, no
03:27:11 <kqr> gtrambly, (-someValue) represents the negative version of someValue
03:27:19 <kqr> gtrambly, you might be looking for the function "subtract"
03:28:03 <kqr> gtrambly, subtract 3 = \x -> x - 3
03:31:52 <quchen> Are these two definitions of the free Applicative (type) equivalent? Is the explicit forall in the :$: "floated out" to yield a non-higher-ranked type? http://lpaste.net/102597
03:33:08 <quchen> When looking at :$: as a standalone function generated by the first case it's clear that the forall isn't introducing a rank-2-type. But in the type definition it looks like it's somehow on the inside, so I'm not 100% sure about that.
03:38:29 <fizruk> quchen: those definitions look the same to me
03:39:06 <kqr> merijn, does it survive an unexpected power outage? (wrt acid-state)
03:39:40 <fizruk> quchen: :$: introduces existentially quantified type, not rank-2, iiuc
03:40:02 <shachaf> Yes. That's an existential.
03:40:12 <shachaf> Those definitions are equivalent. That's how GADTs work.
03:47:20 <quchen> Okay, thanks.
03:48:28 * hackagebot unordered-containers 0.2.4.0 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.4.0 (JohanTibell)
03:54:49 <Bor0> how can I show `map putStrLn ["hi"]` ? I can execute that with sequence $ but I'd like to know if I can just show it
03:55:11 <jle`> Bor0: show the IO action?
03:55:27 <jle`> what would you expect it to return?
03:55:28 <Bor0> how can I do that?
03:55:39 <Bor0> [putStrLn "hi"] or something, I dunno
03:55:43 <jle`> do you expect IO () -> String?
03:55:44 <jle`> ah
03:55:49 <jle`> like put the name of the IO action?
03:55:53 <Bor0> yeah
03:56:08 <jle`> hm
03:56:21 <jle`> not all IO actions have meaningful names in this sense
03:56:23 <k00mi> no, you can't
03:56:45 <jle`> what about printing a complex IO action composed of several?
03:57:04 <jle`> also, you'd drop referential transparency, i'd think
03:57:12 <jle`> you either lose that or you lose equational reasoning
03:57:33 <alpounet> > sequence_ [putStrLn "hello", putStrLn "world"]
03:57:34 <lambdabot>  <IO ()>
03:57:39 <alpounet> is that what you're after?
03:58:10 <Bor0> if you map the strings with putStrLn, you cannot view it as a list like that
03:58:49 <jle`> > map putStrLn ["hello","world"]
03:58:50 <lambdabot>  [<IO ()>,<IO ()>]
03:58:51 <Bor0> what I want is a representation just like that, to give me such a list
03:58:59 <jle`> is that ok?
03:59:07 <Bor0> yes, but ghci whines that there's no Show instance
03:59:13 <jle`> just write your own :)
03:59:35 <Bor0> that's an interesting thing to do, I'll try it. thanks :)
03:59:43 <jle`> instance Typeable a => Show (IO a) where show = show . typeOf
03:59:45 <jle`> i think
03:59:48 <jle`> hm.
03:59:55 <jle`> that might not work
04:00:34 <jle`> oh it worked
04:00:38 <jle`> what do ya know
04:01:31 <Bor0> got it
04:01:55 <identity> > show . typeOf $ return () :: IO ()
04:01:56 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘GHC.Types.IO ()’
04:01:56 <lambdabot>  Expected type: GHC.Types.IO ()
04:01:56 <lambdabot>    Actual type: GHC.Base.String
04:02:07 <k00mi> ugh, blasphemous
04:02:11 <identity> > show . typeOf $ (return () :: IO ())
04:02:13 <lambdabot>  "IO ()"
04:02:15 <identity> huh.
04:02:26 <corgifex> > putStr "" >> return (typeOf ())
04:02:27 <lambdabot>  <IO TypeRep>
04:07:10 <jtcwang> can someone take a look quickly and tell my while this isn't comipling? http://lpaste.net/102600
04:07:22 <jtcwang> i have a feeling that it has to do with the 'where' keyword
04:07:37 <identity> jtcwang: yes. degree does not exist in the where clause
04:07:43 <identity> it's only in scope in the lambda
04:08:01 <jtcwang> i keep getting confused with the usage of where
04:08:10 <corgifex> 'where' attaches to declarations, not expressions
04:08:15 <ClaudiusMaximus> the where attaches to the = in the first line
04:08:21 <jtcwang> i've always used let + in, and am trying to use where more for readability
04:08:46 <identity> jtcwang: something like: \degree -> let ys = encode xs d degree g in d == decode xs ys
04:08:54 <identity> ah.
04:09:04 <jtcwang> yeah i guess i'll have to do that
04:09:07 <dart> hi
04:09:26 <miniBill> which one of those is more idiomatic? -> http://dpaste.com/1777334/
04:09:55 <jtcwang> great it works, thx guys
04:10:01 <dart> i'm struggling trying to understand "visually" comonads, do you know any good resource ?
04:19:35 <fizruk> dart: this one http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
04:19:43 <fizruk> dart: and this one http://www.reddit.com/r/haskell/comments/1hficb/comonads_are_not_objects/
04:20:05 <fizruk> dart: don't know what you mean by "visually" though
04:27:32 <jle`> comonads are like co-burritos
04:27:52 <fizruk> exactly
04:29:32 <MagneticDuck> :D
04:32:42 <troydm> guys i'm doing presentation for my company about haskell and other fp languages where can i find hackage packages count?
04:40:18 <shasts> hello all, first timer here. Trying to do some exercises here. Need to install text-icu package
04:40:37 <shasts> but error says, * Missing C libraries: icui18n, icudata, icuuc
04:40:44 <shasts> OS, Debian
04:40:57 <athan> do you have those libs installed?
04:41:10 <shasts> even cabal install text-icu --extra-lib-dirs=/usr/lib/x86_64-linux-gnudoesnt work
04:41:10 <athan> It may be a good idea to install the "-dev" versions as well
04:41:40 <athan> shasts: Do you have those libs installed from apt?
04:41:50 <athan> cabal is depending on your system having them
04:41:53 <athan> through an ffi
04:42:03 <shasts> locate icui18n gives /usr/local# locate icui18n /usr/lib/x86_64-linux-gnu/libicui18n.so.48
04:42:22 <athan> is this a production machine?
04:42:27 <shasts> no.
04:42:33 <shasts> my laptop
04:42:44 <athan> I suggest installing the "icui18n-dev", or something similar, libraries
04:42:51 <athan> but I'm unsure
04:42:53 <shasts> ok. let me try. Thanks.
04:45:54 <shasts> Thank you. install libicu-dev solved the problem.
04:54:41 <thrakcattack> :t  (>>=)
04:54:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:05:20 <no-n> hi
05:05:24 <jakex> hello. how can I catch all exceptions? Will specifying SomeException in catch handler do it?
05:06:48 <MagneticDuck> ey guys, anybody here using ghc-mod and ghcmod-vim?
05:07:05 <MagneticDuck> I'm.. having a bit of a problem
05:07:13 <MagneticDuck> ghc-mod lint results are not being parsed by the vim plugin!!
05:07:41 <MagneticDuck> I'll make sure everything is up to date
05:08:25 <MagneticDuck> (when I run GhcModLint, I get the following error: http://ix.io/bDX
05:08:28 <MagneticDuck> )
05:08:42 * hackagebot lifted-async 0.1.2 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.1.2 (MitsutoshiAoe)
05:13:20 <MagneticDuck> yeah, everything is updated and double-checked, I'm still getting a parsing error.
05:13:32 <MagneticDuck> ghc-mod lint output seems to be normal, but the vim plugin isn't parsing it
05:13:39 <MagneticDuck> please tell me somebody else can recreate the error :<
05:16:37 <MagneticDuck> uhm, nobody here uses ghcmod-vim?
05:16:40 <MagneticDuck> hmm.
05:25:15 <MagneticDuck> lol guys? xD
05:25:58 <MagneticDuck> this is probably the SECOND time that you guys have let me down in all the time I've been here =P
05:28:25 <jakex> how would I catch all exceptions, on all threads? for error loging purposes
05:28:42 <jakex> is there some "catchAllErrors" handler I can set or tap into?
05:30:58 <jakex> make that "all uncaught exceptions"
05:31:53 <MagneticDuck> one sec, I'll read up on errors a bit
05:31:57 <MagneticDuck> s/errors/exceptions
05:32:03 <MagneticDuck> I don't do much of that usually =P
05:32:21 <MagneticDuck> exceptions seem unhaskelly :<
05:32:35 <jakex> I thought catching in main will do it, but this does not handle Gtk events. example, if exceptions is thrown when a button is clicked
05:32:45 <jakex> exception*
05:33:02 <MagneticDuck> mm.
05:33:55 <MagneticDuck> well, perhaps they're not errors thrown inside the scope of the haskell program?
05:34:20 <MagneticDuck> I mean, if you call a C library to do something, and that C library has some sort of an error...
05:34:22 <MagneticDuck> not sure how that's handled
05:34:33 <benmachine> jakex: no, you can't catch all exceptions in that way
05:34:38 <jakex> I am throwing error myself, in an onClicked function
05:34:42 <MagneticDuck> ohk
05:34:43 <identity> MagneticDuck: I use ghcmod-vim
05:34:52 <benmachine> jakex: it would be nice if when an exception was unhandled in a thread it got thrown to the main thread, it is not so
05:35:09 <benmachine> it just gets printed to stderr I think
05:35:20 <MagneticDuck> identity: put extra parens on something, run GhcModLint
05:35:27 <MagneticDuck> what do you get in the quickfix buffer?
05:35:33 <identity> MagneticDuck: just redundant parens?
05:35:33 <benmachine> jakex: I do not promise I am right about this, there might be a trick I've missed, but that's what I think
05:35:44 <MagneticDuck> identity: anything that ghc-mod lint would complain about
05:35:49 <benmachine> jakex: write a wrapper and apply it to all your threads?
05:36:09 <jakex> benmachine I expected that Gtk would call onClicked handler in the main thread. but if it did what I am doing should just work, I believe
05:36:29 <benmachine> jakex: maybe it does, but also catches exceptions it throws?
05:36:33 <MagneticDuck> identity: well how is it?
05:36:43 <jakex> that is possible
05:36:55 <identity> MagneticDuck: putting redundant parentheses somewhere just tells me I should remove them when I run lint
05:37:10 <benmachine> jakex: you could find out by printing myThreadId, but I suppose it's not really relevant
05:37:15 <MagneticDuck> identity: uh, one sec then
05:37:24 <identity> MagneticDuck: which version of ghc-mod are you using?
05:37:43 <MagneticDuck> latest one
05:38:20 <MagneticDuck> identity: I get this: http://ix.io/bDY
05:38:22 <MagneticDuck> :<
05:38:49 <MagneticDuck> identity: the ghc-mod lint output looks nice, but the plugin isn't parsing it
05:39:29 <identity> MagneticDuck: hmm. what if you run ghc-mod from the terminal on the source file?
05:39:54 <MagneticDuck> http://ix.io/bDZ
05:39:56 <MagneticDuck> looks clean to me
05:39:59 <MagneticDuck> =P
05:42:49 <identity> strange. I'm not sure what's going on -- maybe you should submit a bug report?
05:43:47 * hackagebot bert 1.2.2.2 - BERT implementation  http://hackage.haskell.org/package/bert-1.2.2.2 (RomanCheplyaka)
05:43:49 <MagneticDuck> identity: you have the updated version of everything?
05:44:39 <identity> I'm not sure. I have hdevtools and ghc-mod installed and I'm about to drop ghc-mod in favor of hdevtools
05:44:59 <MagneticDuck> I might do that I suppose...
05:45:02 <MagneticDuck> that would fix the issue
05:45:06 <MagneticDuck> btw why are you going to do that?
05:46:05 <madjestic> trying to compile the reactive banana copy-paste example from here: http://www.haskell.org/haskellwiki/FRP_explanation_using_reactive-banana .  With latest reactive banana I am getting this error: http://lpaste.net/102604 Somebody must have solved that.  A sollution?
05:46:40 <identity> Because I have been getting some parsing errors when using MultiWayIf, and been unable to reproduce it. I figure there's no reason to use both checkers when hdevtools is supposed to be a replacement for ghcmod
05:48:53 <MagneticDuck> identity: btw how do I make hdevtools check with hlint too?
05:49:22 <identity> MagneticDuck: Not entirely sure it does that, but you can just make syntastic do that
05:49:34 <identity> I'm not very familiar with hdevtools. Looking into it right now
05:49:59 <MagneticDuck> identity: syntastic already uses hlint as a compiler
05:50:04 <MagneticDuck> s/compiler/chcker
05:50:15 <MagneticDuck> but it would be nice to get nice text in the quickfix buffer
05:51:47 <identity> MagneticDuck: I'm pretty sure that's just a matter of configuration wrt. syntastic. I currently have ghcmod running on bufwritepost, but I'm sure it's possible to simply replace that with a command from syntastic.
05:53:06 <identity> You might want to set g:syntastic_aggregate_errors=1
05:53:41 <MagneticDuck> alright cool
05:53:50 <MagneticDuck> that will make syntastic put errors in the quickfix?
05:58:51 <identity> Nope, but that will run all checkers and collect all errors
05:58:59 <identity> I'm about to test something out, give me a sec.
06:01:49 <identity> MagneticDuck: https://gist.github.com/10534509
06:02:44 <identity> It uses the "location list". I'm not sure how that is different from the quickfixlist
06:03:14 <MagneticDuck> identity: alright that's workin' now
06:03:20 <MagneticDuck> however...
06:03:26 <MagneticDuck> ouch. They're hard to read.
06:03:38 <MagneticDuck> with GhcModVim I got nice errors
06:03:43 <MagneticDuck> pretty, indented, etc
06:03:47 <MagneticDuck> this is a bit hard to read >_>
06:03:49 <identity> yeah. I liked ghcmod's output better as well
06:04:18 <MagneticDuck> :<
06:11:34 <AshyIsMe> argh frustrating, ghc-mod isnt working properly in vim for some reason
06:11:55 <AshyIsMe> seems to be because im using cabal build
06:12:33 <identity> AshyIsMe: how is it not working precisely?
06:14:53 <yorick> I forgot how to arrow, it seems :/. deep (hasName "h2" >>> (proc a -> do returnA True)) should return a ArrowMagic [Bool], right?
06:15:00 <yorick> instead it's returning an ArrowMagic Bool
06:16:05 <yorick> I tried adding a listA in some places, but that just made it return the first result in a list
06:16:17 <AshyIsMe> identity: it can't check the type of anything
06:16:50 <identity> AshyIsMe: It can hardly ever infer the type for me, really
06:19:48 <Saizan> the binaries for 7.8.2 on 64bit linux give me 404
06:21:58 <AshyIsMe> identity: oh, it works so long as everything actually compiles
06:22:02 <AshyIsMe> that makes sense, heh
06:23:10 <miniBill> I'm looking for suggestions on this -> https://codereview.stackexchange.com/questions/47000/whats-more-idiomatic-in-haskell
06:23:30 <yorick> what would I do to 'map' the hasName "h2" elements to a (proc a -> do) thing?
06:31:39 <Eduard_Munteanu> Is there a variant of 'bracket' that is suitable when the bracketed computation spawns a thread, such that the final action waits for it to terminate before running?
06:33:29 <bennofs> Eduard_Munteanu: is there a difference between letting the final action wait for the thread and letting the bracketed computation wait for the thread? It seems to be the same to me
06:33:34 <MagneticDuck> http://ix.io/bE1
06:33:44 <MagneticDuck> ^ hlint says that I employed a "redundant flip"
06:33:51 <MagneticDuck> I see its point... but is that really bad style?
06:34:45 <bennofs> MagneticDuck: well, you can just write (`PathMovement` 0) instead of (flip PathMovement 0)
06:35:26 <Eduard_Munteanu> bennofs: the bracketed computation spawns a thread and returns, so the final action would run too soon
06:36:29 <bennofs> Eduard_Munteanu: forkFinally?
06:37:54 <Eduard_Munteanu> bennofs: in that case, how do you keep bracket-like behavior for the resource acquiring computation?
06:38:15 <Eduard_Munteanu> bennofs: bracket runs it with exceptions masked, for one thing.
06:38:27 <bennofs> ah I didn't think about that
06:39:15 <Eduard_Munteanu> But yes, I want something like acquire >>= \r -> forkIO (finally (inbetween r) (release r))
06:39:31 <Eduard_Munteanu> As far as flow control alone is concerned.
06:40:12 <Eduard_Munteanu> I think I'll write my own 'bracket' in terms of 'mask' then.
06:40:48 <MagneticDuck> bennofs: ah cool
06:45:12 <jmcarthur> i love the discussion about SSL in haskell on reddit and hackernews. "WUT ABOUT TIMING ATACKS I HERAD ABOUT THOSE" ... what about them exactly?
06:46:00 <Eduard_Munteanu> The concern is valid, though.
06:48:07 <jmcarthur> I agree that it's worth addressing, but most of the people crying shenanigans are just jumping on the bandwagon and adding nothing.
06:54:30 <angerman> did anyone use vty-ui?
06:54:42 <yorick> hey! I'm parsing XML using XHT. I'm trying to get a deep (stuff) >>> (proc a -> do x <- stuff -< a; returnA -< Thing x) , to return a [Thing x]
06:54:46 <yorick> instead, it's returning only one
06:54:52 <yorick> how do I get it to return all of them?
06:56:34 <AshyIsMe> does anyone use a ternary operator like this in their haskell? http://stackoverflow.com/a/213956
06:57:37 <fizruk> AshyIsMe: i don't think it's popular if any
06:57:47 <dwcook> AshyIsMe, the conditional/ternary operator in most languages that have it is analogous with the if syntax of Haskell, so there's not much reason for it.
06:58:34 <dwcook> I will grant that this (?) function is more easily combined with other things though.
06:59:09 <dwcook> Since it's a function rather than syntax.
07:01:31 <yorick> dwcook: do you know much about arrows?
07:01:47 <dwcook> yorick, never played with them, sorry.
07:02:09 <Eduard_Munteanu> yorick: IIRC, there's a 'deep' combinator for this purpose
07:02:48 <yorick> Eduard_Munteanu: http://pastie.org/private/p2qgpjxr0dnwcw3voep7ca
07:04:08 <Eduard_Munteanu> Oops, I missed your 'deep' above.
07:04:25 <jmcarthur> AshyIsMe: i prefer the arguments in another order:    bool :: a -> a -> Bool -> a
07:04:53 <jmcarthur> AshyIsMe: it tends to work nicer when composing with other functions
07:07:12 <Eduard_Munteanu> Though boolM would better be :: Bool -> m a -> m a -> m a, a-la when/unless.
07:07:16 <yorick> I think I want something like mapL?
07:12:08 <yorick> someone please help :(
07:12:13 <dwcook> Eduard_Munteanu, it'd be nice if we could just define everything monadically and have some reasonable rules for when to default to m ~ Identity
07:13:18 <Eduard_Munteanu> dwcook: you can already do that if you use applicative notation everywhere :)
07:13:43 <dwcook> Eduard_Munteanu, what do you mean? And I should clarify: I don't want to runIdentity everywhere. :P
07:13:51 <Eduard_Munteanu> I suspect this asks for overloaded function application.
07:14:09 <dwcook> Ah, that's a good point.
07:14:25 <yorick> I think I want something like this? (a b c -> a b d) -> a b [c] -> a b [d]
07:14:26 <dwcook> Doesn't Idris or something have that?
07:15:08 <Eduard_Munteanu> dwcook: all instances of 'f x y z ...' can be replaced by 'f <$> x <*> y <*> z <*> ...' if you put everything in an Identity.
07:15:40 <dwcook> Yep, that'd be pretty ugly without overloaded application :P
07:16:38 * yorick is going crazy
07:16:47 <dwcook> When I try to search the web for "overloaded function application", it just brings up results about function overloading -_-
07:16:56 <dwcook> yorick, I wish I knew how to help
07:18:28 <dwcook> Oh of course, "overloaded function application" could mean either "overloaded application of functions" or "application of overloaded functions". Silly ambiguous natural language
07:21:11 <jmcarthur> man, i hate C APIs. FFI bindings wouldn't really be so bad except that the interface you're wrapping usually just stinks.
07:21:35 <jmcarthur> Create an object. Set various attributes of it one at a time. Call some "run" function. Extract the results you want. Destroy the object.
07:22:22 <dwcook> jmcarthur, is that to prevent excessive copying of arguments?
07:22:23 <jmcarthur> Worse when you have to create several auxiliary objects, too.
07:22:40 <dwcook> I mean, the reason the API was designed that way
07:23:02 <jmcarthur> What, by making you do the copying yourself?
07:23:10 <jmcarthur> It still stores everything in the object.
07:23:17 <dwcook> Well, rather, if the run function wants to pass on the data, it just passes a single pointer
07:23:39 <jmcarthur> In this case, there aren't even any pointers involved.
07:23:58 <dwcook> Maybe the designer thought it was clearer :P
07:24:14 <jmcarthur> The object stores array-like data and you have to supply each element of each array individually.
07:24:24 <jmcarthur> This is so common in C, for some reason.
07:24:31 <jmcarthur> this is GLPK!
07:24:33 <jmcarthur> ugh
07:24:59 <jmcarthur> I *wish* I could just hand it a pointer.
07:26:18 <jmcarthur> actually it looks like one of these function calls does take a pointer to a matrix, but only after you have set of all kinds of other individual parameters for each row
07:26:48 <jmcarthur> the run function also seems to write directly to stdout :(
07:27:19 <jmcarthur> i should really be in -blah. sorry
07:27:41 <vivaldi> Hi I have a problem with this code : http://lpaste.net/102607 . Can you tell me how I can fix it?
07:28:23 <jmcarthur> :t unzip3
07:28:24 <lambdabot> [(a, b, c)] -> ([a], [b], [c])
07:28:41 <corgifex> oh god, so many uses of head/tail/==
07:28:42 <defanor> Data.Graph is all about directed grahps, and the 'reachable' function respects directions, right?
07:29:03 <jmcarthur> @src unzip3
07:29:03 <lambdabot> Source not found. :(
07:29:13 <vivaldi> I am a begineer Haskell coder so :/
07:29:19 <jmcarthur> defanor: i believe so, but it's been a while
07:29:44 <defanor> jmcarthur: thanks
07:29:48 <jmcarthur> vivaldi: since the number of your lists in the output is static, i recommend making it a triple of lists rather than a list of lists.
07:30:00 <jmcarthur> vivaldi: also, the unzip3 function i mentioned just now does exactly what you want
07:30:21 <corgifex> jmcarthur: doesn't look that way
07:30:34 <corgifex> vivaldi: you seem to have a precedence problem
07:30:45 <jmcarthur> corgifex: "I have a list of tuples, the first element of the tuples can be 'a','b','c' . I want to create a list of 3 lists from that tuple list. First list has to have 'a' tuples, second 'b' tuples and third 'c' tuples."
07:31:04 <jmcarthur> corgifex: that sounds exactly like unzip3 to me except for the list of lists bit
07:31:09 <vivaldi> jmcarthur : I think unzip3 wouldn't help me
07:31:19 <jmcarthur> i don't understand the problem statement then
07:31:40 <corgifex> jmcarthur: first element of the tuples
07:31:50 <corgifex> unzip3 doesn't look at the elements
07:32:16 <corgifex> vivaldi: (init xs) ++ ... should be (init xs + ...)
07:32:16 <jmcarthur> yeah, i'm certain i don't understand now. what is the type of the function vivaldi is trying to write?
07:33:01 <corgifex> [(Char,a,b)] -> [[(Char,a,b)],[(Char,a,b)],[(Char,a,b)]]
07:33:04 <jmcarthur> oh, is it   [(Char, a)] -> (a, a, a)  ?
07:33:11 <jmcarthur> ah, right, the tuples
07:33:15 <vivaldi> corgifex is right yes, tuples
07:33:21 <jmcarthur> oh, is it   [(Char, a)] -> ((Char, a), (Char, a), (Char, a))  ?
07:33:35 <vivaldi> corgifex : why should it be + instead of ++
07:33:56 <corgifex> oops, my typo
07:33:57 <corgifex> dammit
07:33:59 <jmcarthur> bah, i stink
07:34:06 <jmcarthur> i still got it wrong. anyway, i understand now
07:34:19 <corgifex> vivaldi: that's a typo, should be ++
07:34:24 <vivaldi> sorry I got disconnected
07:35:49 <vivaldi> corgifex : did you see what I am doing wrong?
07:36:06 <corgifex> I think so, yes
07:36:40 <vivaldi> what do you think it is?
07:36:58 <corgifex> uh
07:37:01 <corgifex> exactly what I told you
07:37:15 <corgifex> <corgifex> vivaldi: you seem to have a precedence problem
07:37:22 <MagneticDuck> question about syntastic guys: how do I get hlint to take a few arguments?
07:37:28 <corgifex> <corgifex> vivaldi: (init xs) ++ ... should be (init xs + ...)
07:37:29 <MagneticDuck> it's being used as a syntax checker
07:37:36 <corgifex> except I typo'd and it should be (init xs ++ ...)
07:37:36 <jmcarthur> :t Map.toList . Map.fromListWith (++) . (map.second) pure    -- uses Ord instead of Eq, but is quite terse :)
07:37:37 <MagneticDuck> (using vim, syntastic, hdevtools)
07:37:37 <lambdabot>     Not in scope: Map.toList
07:37:37 <lambdabot>     Perhaps you meant one of these:
07:37:37 <lambdabot>       M.toList (imported from Data.Map),
07:37:46 <jmcarthur> :t M.toList . M.fromListWith (++) . (map.second) pure    -- uses Ord instead of Eq, but is quite terse :)
07:37:47 <lambdabot> Ord k => [(k, a)] -> [(k, [a])]
07:38:29 <AshyIsMe> damn im bad at haskell haha
07:38:30 <MagneticDuck> I found where the hlint syntax checker is defined in the syntastic vim bundle, but I can't figure out how to work with it or add command line arguments
07:38:39 <MagneticDuck> AshyIsMe: !
07:38:43 <corgifex> jmcarthur: you're assuming 2-tuples
07:39:05 <jmcarthur> corgifex: what you have something more generic in mind?
07:39:11 <vivaldi> I get the error at this line : group mylist = group2 mylist [[],[],[]]
07:39:20 <corgifex> jmcarthur: no, but the error message says (Char, t0, t1)
07:39:27 <corgifex> vivaldi: so?
07:39:35 <corgifex> did you try my suggestion?
07:39:42 <vivaldi> yes, still same error
07:40:11 <corgifex> oh, then I'm wrong
07:41:10 <corgifex> looks like you have the same issue in all three branches
07:41:41 <vivaldi> true
07:42:08 <corgifex> these parentheses make the code quite hard to read
07:42:23 <vivaldi> let me make the code more readable
07:42:26 <flebron> Just reading about type families. Say I have a "data family Foo :: * -> *", say I have data instance Foo Int = I Int, data instance Foo Char = C Char, is there a sensible way to have f :: Foo t -> t?
07:43:01 <flebron> More generally, what can I "do" with Foo?
07:44:45 <vivaldi> corgifex : http://lpaste.net/102607 I changed it a little bit
07:45:22 <vivaldi> on thing I realized when I change group mylist = group2 mylist [[],[],[]] to group mylist = group2 mylist [], I get some results and then empty head error
07:45:27 <corgifex> yeah, try changing all those instances of f a ++ b to f (a ++ b)
07:46:05 <meretrix> If I am writing a low latency application that processes streaming data, is it generally safe to say that I want to use bangs in all of my data constructors?
07:47:10 <meretrix> Or should bangs be used with more discretion?
07:50:30 <jmcarthur> meretrix: i would say it depends
07:50:37 <corgifex> vivaldi: http://lpaste.net/102609
07:50:48 <corgifex> I haven't actually tried it, though
07:51:06 <jmcarthur> meretrix: best is to become familiar with when you should and shouldn't use bangs. it becomes very natural after a while. before that happens, though, you should probably just think carefully.
07:51:45 <jmcarthur> meretrix: e.g. you clearly don't want to use bangs on the recursive field of a data type you intend to make infinitely large
07:52:37 <jmcarthur> meretrix: and e.g. it's weird if you have a strict collection of spine lazy elements
07:52:39 <meretrix> jmcarthur: Would you say it's enough to learn the cases when one shouldn't use it and then just use it everywhere else?
07:53:05 <jmcarthur> meretrix: i think it's just a binary decision, not one which is best with a "default" at all
07:53:16 <jmcarthur> meretrix: others disagree with me though
07:53:26 <jmcarthur> and in different ways...
07:54:10 <meretrix> Ok thanks, that's what I was afraid of. :)
07:54:30 <jmcarthur> meretrix: i actually prefer thinking of it this way because it means it's not some "gotcha" or "corner case"
07:54:34 <jmcarthur> meretrix: it's actually semantics
07:55:02 <jmcarthur> meretrix: the ability to decide whether a field is strict or non-strict is a very powerful tool, not to be ignored in everyday programming, IMO
07:55:42 <jmcarthur> i actually wish there was syntax required for either choice, so that you can't just "not make the choice" and default to laziness
07:56:50 <meretrix> I guess I just need more experience, but when I think about my application, it seems like everything should be strict.
07:57:12 <jmcarthur> meretrix: maybe that turns out to be true in this case :)
07:57:41 <meretrix> It's a (somewhat) high-frequency trading application, so processing small bits of data very quickly is critical.
07:58:13 <identity> meretrix: Lazy lists can be used to implement streaming, so to speak. So putting a bang on the list that is supposed to be your stream would of course not be optimal
07:58:22 <identity> but I'm assuming you're not simply using lists
08:02:17 <Algebr> Fair to say? Monads in other languages would help reduce if not get rid of null pointer exceptions.
08:02:59 <identity> Algebr: possibly, I guess. Depending on how they are implemented in said language
08:03:20 <identity> If you could still use null pointers and so on, they wouldn't
08:03:51 <Algebr> I think i just realized that monads are just a design pattern.
08:04:20 <MagneticDuck> yep
08:04:37 <MagneticDuck> it sure helps that haskell is a language that allows higher order functions and type classes though =P
08:08:24 <flebron> Essentially all typeclasses in use are design patterns, only functional programming gets its pattern names from mathematics
08:08:47 <dwcook> What even is a design pattern? I keep hearing people use that term.
08:09:10 <flebron> A common solution to a problem in software engineering
08:09:12 <Algebr> dwcook: I guess I would say its a "pattern" of structuring code?
08:09:40 <dwcook> Why is the term useful?
08:09:51 <flebron> Why is any term useful?
08:09:58 <MagneticDuck> why is language useful?
08:10:01 <dwcook> That's a non-answer.
08:10:03 <flebron> It allows you to communicate that idea to another entity
08:10:08 <MagneticDuck> dwcook: "mu" =P
08:10:08 <flebron> The same way any term is useful.
08:10:17 <dwcook> Sure, so the real question is why you need to know what these design pattern things are.
08:10:19 <Algebr> I suppose its fair to say that making new types is trivial in Haskell, like Maybe <anything>, boom, theres a type.
08:10:29 <MagneticDuck> algebraic data types yay
08:10:40 <flebron> dwcook: Because it's useful to say "You should use a Memento pattern here" instead of describing the same pattern again every time.
08:10:48 <flebron> Since it comes up frequently, you give it a name.
08:10:54 <Algebr> but like, would this make sense? Maybe Maybe Int
08:11:01 <flebron> No, but Maybe (Maybe Int) would.
08:11:11 <dwcook> flebron, so why not write a module for it and then point people to that?
08:11:11 <MagneticDuck> why, that's the same thing as Maybe Int, for my purposes!
08:11:26 * MagneticDuck makes structure with a "join" operation
08:11:37 <Algebr> dwcook: Because its much easier to say one word than to stare at code.
08:11:39 <flebron> dwcook: Because there's not a single implementation of such an idea. It is not a specific set of lines of code or an algorithm. It's a pattern of code.
08:11:48 <srhb> :t join
08:11:49 <lambdabot> Monad m => m (m a) -> m a
08:11:50 <srhb> @type join
08:11:51 <lambdabot> Monad m => m (m a) -> m a
08:11:56 <corgifex> dwcook: because not all patterns can be abstracted in all languages
08:12:10 <dwcook> flebron, my point is I think if you need a "pattern" for something, you ought to be able to abstract it away with a function or the like.
08:12:12 <Algebr> flebron: So you could go N levels deep in Maybe (Maybe (Maybe...
08:12:18 <MagneticDuck> srhb: I'm narrating a hypothetical, simplified example of the birth of a structure
08:12:19 <flebron> Algebr: Yes.
08:12:19 <dwcook> corgifex, there we go, that's a relevant objection
08:12:23 <flebron> dwcook: That's not necessarily true.
08:12:32 <flebron> (And it's the objection corgiflex is making.)
08:12:50 <dwcook> flebron, you probably misunderstood what I meant by "ought to"
08:12:54 <corgifex> patterns are very much language dependent
08:12:55 <srhb> MagneticDuck: I see :P
08:12:56 <flebron> Some patterns can indeed be abstracted away, you can make a SingletonMaker if you want. This does not remove the need to name the thing "Singleton".
08:13:04 <corgifex> e.g. "subroutine" is a design pattern in asm
08:13:18 <dwcook> I mean ideally I wouldn't have to repeat myself. That's the computer's job.
08:13:31 <flebron> You're not repeating yourself in the semantics of the term, only in the term.
08:13:38 <flebron> In the same way, you copy a pointer around, not the pointee.
08:14:03 <flebron> "Singleton" is a pointer to a way of structuring code with a certain goal.
08:14:19 <flebron> So is Functor, or "loop".
08:14:21 <dwcook> flebron, I think we're talking about different things here.
08:14:43 <flebron> You asked why we give these things names.
08:14:46 <dwcook> flebron, but a point you haven't raised that I think would be the right one is that these pattern things you're discussing are useful to talk about cross-language.
08:15:08 <flebron> That's one benefit, but not necessary to see why they are useful
08:15:19 <corgifex> dwcook: http://blog.plover.com/prog/design-patterns.html
08:15:33 <flebron> (And not all languages have the same facility to use the same patterns.)
08:15:45 <dwcook> Right. That point was made earlier by corgifex.
08:16:22 <flebron> I mean, both of the things you say I should have raised are useful, but the usefulness comes, at least to me, in being able to communicate an idea of code structure to your peer.
08:16:28 <dwcook> So the idea is that some languages are deficient for some "design patterns" and that some "design patterns" are useful to talk about in generalities without tying them to a specific language, it seems.
08:16:34 <MagneticDuck> btw guys, I'm a bit suprised that there doesn't seem to be a widely used type synonym for a -> a
08:16:40 <MagneticDuck> =P
08:16:50 <dwcook> MagneticDuck, Endo?
08:16:52 <MagneticDuck> ahk
08:16:54 <dwcook> @src Endo
08:16:54 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:16:55 <flebron> This idea may or may not be abstracted away into some first-class object in your language, and it may or may not survive cross-language translation, the important part is tha tyou are communicatinng the intent of your architecture to a peer.
08:17:05 <dwcook> @hoogle Endo
08:17:06 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
08:17:06 <lambdabot> Data.Monoid newtype Endo a
08:17:06 <lambdabot> System.Posix.Terminal.ByteString EndOfFile :: ControlCharacter
08:17:21 <dwcook> MagneticDuck, it's a newtype rather than a synonym for the sake of instances
08:17:31 <flebron> No idea why you say "are deficient".
08:17:46 <MagneticDuck> dwcook: ahk
08:17:56 <dwcook> flebron, unable to abstract into something composable.
08:17:59 <MagneticDuck> @hoogle Endo a -> a -> a
08:18:00 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
08:18:00 <lambdabot> Prelude asTypeOf :: a -> a -> a
08:18:00 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
08:18:05 <MagneticDuck> wonderful
08:18:33 <dwcook> MagneticDuck, what do your "ahk"s mean? :P
08:18:33 <MagneticDuck> dwcook: however, just for type signature simplicity, isn't there a type synonym like Endo?
08:18:40 <MagneticDuck> read: ahh okay
08:18:49 <MagneticDuck> maybe one less h
08:18:53 <Algebr> Hmm, when I give hoogle say: `hoogle --info "String -> String", it only gives me one hit, but surely there are more things that match that signature.
08:18:54 <MagneticDuck> or really no h at all
08:18:58 <Algebr> How can I make it show all of them
08:18:59 <flebron> I wouldn't necessarily that's a deficienct, at least, not in any way different than "Unable to produce coffee" - you may or may not want your language to have that.
08:19:21 <flebron> But anyway, I think I've expressed myself as to why I think the concept of a design pattern is useful.
08:20:37 <MagneticDuck> Algebr: well, without the "--info" flag, it returns all of 'em
08:20:47 <petrie> Am I reinventing the wheel trying to write a function that will count a multidimensional list or is there already a easier way?
08:20:47 <Algebr> Whoever invented do notation was very clever.
08:20:58 <MagneticDuck> and the --info flag can get haddock documentation for a particular function...
08:21:17 <MagneticDuck> petrie: what's the problem?
08:21:21 <Algebr> MagneticDuck: Oh thanks!
08:21:29 <srhb> petrie: something something map something :)
08:21:35 <MagneticDuck> I mean, "sum . map length" works for 2d
08:21:46 <Eduard_Munteanu> petrie: is the number of dimensions variable?
08:21:49 <emma> do you guys make programs with haskell that would be used by people who don't know math or haskell to do things they would enjoy? Or do you primarily make things with haskel that are for theory?
08:21:54 <MagneticDuck> "sum . map (sum . map length)" works for 3d...
08:21:55 <dwcook> petrie, what do you mean "count a multidimensional list"?
08:21:56 <MagneticDuck> see the pattern? =P
08:22:01 <srhb> emma: Yes to the first :)
08:22:02 <petrie> [[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]]
08:22:05 <emma> cool :)
08:23:03 <dwcook> emma, Haskell programs generally don't require much math to understand. Understanding the language is usually sufficient.
08:23:05 <srhb> emma: Personally I find the theory heavy stuff super interesting, but I'm too much of a newbie to actually "make" any of it myself, so I just use it.
08:23:10 <petrie> wow MagneticDuck I feel retarded now
08:23:13 <petrie> lol
08:23:13 <Eduard_Munteanu> petrie: and the result for that is 15?
08:23:19 <petrie> yes
08:23:23 <MagneticDuck> petrie: haskell has the effect :)
08:23:26 <MagneticDuck> s/the/that
08:23:28 <Algebr> emma: I'm working on a GUI program myself.
08:24:40 <Eduard_Munteanu> petrie: ok, does 'sum . map length' suit your needs?
08:24:49 <MagneticDuck> yes, I think we solved his problem
08:25:00 <petrie> Eduard_Munteanu: yes that was what I needed
08:25:05 <emma> what kind of problems does Haskell usually get used to deal with?
08:25:16 <srhb> emma: It's a general purpose language, so any problem :)
08:25:17 <Eduard_Munteanu> Oh, ok, I thought you wanted to generalize it.
08:25:18 <dwcook> emma, it's a general-purpose language
08:25:19 <MagneticDuck> emma: basically everything
08:25:20 <petrie> I literally had like 4 lines folding and accessing single elements trying to get it :\
08:25:25 <emma> okay cool
08:25:39 <MagneticDuck> @faq can haskell deal with a large forest fire?
08:25:39 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
08:25:44 <srhb> D:
08:25:46 <srhb> Who did that
08:25:48 <emma> for some reason i thought haskell might be tricky to interact with stuff outside of itself.
08:25:49 <MagneticDuck> :0
08:25:51 <emma> if that makes sense
08:25:55 <srhb> emma: not at all
08:26:01 <srhb> emma: In fact, it makes it more sane.
08:26:11 <Eduard_Munteanu> Yikes, old @faq is gone. :(
08:26:24 <srhb> emma: The safeties of the type system mean you generally spot corner cases when dealing with the interaction with "the world" much more easily
08:26:33 <dwcook> emma, is that because you heard Haskell was pure and so couldn't do side effects? Well it's true that evaluation of expressions is pure, but there is an IO system capable of performing effects.
08:26:46 <emma> dwcook: i see
08:27:03 <MagneticDuck> Eduard_Munteanu: btw, you'd generalise a multidimensional list in the kind of way that printf deals with a "mutable" type signature right?
08:27:05 <srhb> emma: Most of my things are general web infrastructure stuffs.
08:27:07 * MagneticDuck tries to think
08:27:19 <srhb> I much prefer to do it in Haskell over anything else.
08:27:33 <MagneticDuck> emma: I use haskell when other people use bash :D
08:27:56 <emma> wow you guys are very positive :)
08:28:01 <dwcook> emma, see this, by the way: http://www.haskell.org/haskellwiki/FAQ#I_heard_Haskell_is_pure_functional._Does_that_mean_it_can.27t_do_IO.3F
08:28:01 <MagneticDuck> (as soon as my script start having to do some rudimentary parsing of strings... ich, bash is terrible, haskell to the rescue)
08:28:08 <srhb> emma: Well, we're here mostly because we love the language. :D
08:28:25 <srhb> emma: Same probably goes for any #lang-channel
08:29:15 <MagneticDuck> well...
08:29:19 <Eduard_Munteanu> MagneticDuck: I was only thinking of a typeclass
08:29:32 <MagneticDuck> I don't want to hear java programmers saying they're using java as a scripting language :D
08:29:58 <srhb> True, and it would be nice if #!/usr/bin/runhaskell weren't so terribly slow, but eh.
08:30:00 <Platz> emma: what do you mean by "tricky to interact with stuff outside of itself"?  Do you have a particular use case in mind?
08:30:01 <srhb> Binaries work, too.
08:30:04 <corgifex> I use perl mostly
08:30:04 <emma> haskell sounds very good. This FAQ seems very encouraging.
08:30:27 <srhb> emma: Give it a shot. Have you seen LYAH?
08:30:31 <srhb> @where LYAH
08:30:31 <lambdabot> http://www.learnyouahaskell.com/
08:30:35 <corgifex> but haskell is lots of fun, too
08:30:42 <emma> Platz: yeah like making a bot for a website or something where you need to receive data that isn't haskell and do stuff with it, and make stuff happen that isn't haskell.
08:30:57 <corgifex> I've written an IRC bot in haskell
08:30:59 <emma> or like making program with a GUI or something.
08:31:08 <corgifex> there's an X window manager written in haskell
08:31:13 <dwcook> emma, yes, Haskell is perfectly capable of those things.
08:31:15 <Biohazard> xmonad?
08:31:17 <emma> the kind of stuff people make with python
08:31:19 <corgifex> yeah
08:31:19 <dwcook> lambdabot even is written in Haskell
08:31:31 <srhb> emma: We make all that stuff, too. :)
08:31:31 <MagneticDuck> emma: HASKELL IS AMAZING USE IT USE IT USE IT
08:31:34 <emma> i don't mean that as an insult to haskell. I just thought haskell was for solving math problems and stuff like that.
08:31:39 <dwcook> @botsnack
08:31:40 <lambdabot> :)
08:31:42 <MagneticDuck> dwcook: lol, lambdabot is written in haskell?? =P
08:31:42 <corgifex> ew, math
08:31:56 <MagneticDuck> wait, what? "ew, math"?
08:31:58 <dwcook> MagneticDuck, sure, what else would you expect from #haskell? :)
08:31:59 <corgifex> > let 2 + 2 = 5 in 2 + 2
08:32:00 <MagneticDuck> you're on #haskell
08:32:01 <lambdabot>  5
08:32:16 <Biohazard> haha
08:32:35 <Algebr> How are people getting autocomplete in emacs? Like not things you already typed but real autocomplete
08:32:49 <srhb> Algebr: ghc-mod can do that I think?
08:32:52 <emma> does haskell have a REPL like scheme?
08:32:52 <srhb> Coupled with auto-complete
08:32:53 <Eduard_Munteanu> emma: no, but certain solving certain math problems / concepts did help Haskell
08:32:56 <emma> i like repls
08:32:58 <srhb> emma: Sort of :)
08:32:58 <corgifex> emma: ghci
08:32:59 <dwcook> emma, see this: http://www.haskell.org/haskellwiki/FAQ#Do_I_need_to_know_advanced_math_in_order_to_use_Haskell.3F
08:33:49 <srhb> Well, emphatically yes, there are just minor differences to how it works
08:33:53 <Eduard_Munteanu> Just like quantum physics help with making a computer tremendously but computers aren't about quantum physics.
08:33:54 * corgifex hugs ghci
08:34:06 * Algebr laughs.
08:36:01 <no-n> :t M.delete
08:36:04 <lambdabot> Ord k => k -> M.Map k a -> M.Map k a
08:38:14 <corgifex> > M.delete "bar" (M.fromList [("foo", 1), ("bar", 2), ("baz", 3)])
08:38:16 <lambdabot>  fromList [("baz",3),("foo",1)]
08:39:34 <Eduard_Munteanu> I wonder if this has a name... do { mv <- newMVar (); forever $ do { takeMVar mv; forkIO $ bracket acquire release (putMVar mv () >> worker) } }
08:40:18 <dwcook> Eduard_Munteanu, what's the point of it?
08:40:19 <Eduard_Munteanu> My particular use is 'acquire' is something like Network.Socket.accept.
08:41:05 <Eduard_Munteanu> dwcook: a loop that accepts connections and makes sure to close them when an exception occurs
08:41:20 <dwcook> Oh I see
08:41:40 <corgifex> why do you need that MVar?
08:41:58 <dwcook> My solution is not bound to be optimal but for that I forkFinally and have a new thread handle the socket IO
08:42:25 <Eduard_Munteanu> corgifex: so the loop waits for 'accept' instead of spawning an infinite number of threads.
08:42:40 <corgifex> Eduard_Munteanu: why not just accept in the main thread/
08:42:57 <corgifex> you only need to forkIO once you have a connection
08:43:11 <Eduard_Munteanu> corgifex: how do you bracket it then?
08:43:23 <dwcook> @hoogle forkFinally
08:43:23 <lambdabot> No results found
08:44:01 <dwcook> Eduard_Munteanu, forkFinally here? http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Concurrent.html
08:44:13 <dwcook> I don't know if that's sufficient for what you want
08:44:28 <Eduard_Munteanu> corgifex: consider 'bracket accept close (forkIO . worker)', it won't work because close runs immediately after the fork.
08:44:59 <Eduard_Munteanu> dwcook: no, because that'd run accept unbracketed, without masking exceptions for instancec.
08:45:03 <srhb> flip it into workers and make workers wait for all workers?
08:46:06 <Eduard_Munteanu> srhb: er, what do you mean? I only wait for accept to return something.
08:46:13 <srhb> Ah.
08:46:41 <corgifex> mask $ \restore $ do s <- accept; forkIO (restore (handle s) `finally` sClose s)
08:47:05 <Eduard_Munteanu> Yeah, I was trying to get that effect without messing with 'mask' directly.
08:47:59 <Eduard_Munteanu> corgifex: also, the nice thing is accept, close and the worker are already on the same thread, not sure if it makes a difference but it seems safer.
08:49:52 <dwcook> Eduard_Munteanu, why would that be better than forking after accept?
08:50:00 <dwcook> Or why would it seem that way?
08:50:26 <dwcook> I'm curious for my own purposes – I'm still relatively new to networking
08:50:30 <dwcook> and concurrency
08:50:30 <corgifex> Eduard_Munteanu: if accept fails in your code, it deadlocks
08:50:43 <Eduard_Munteanu> corgifex: yeah, I just realized that
08:51:03 <corgifex> I need to look at the async package
08:51:13 <jmcarthur> async is lovely
08:51:23 <Eduard_Munteanu> corgifex: I think I should putMVar like accept >> putMVar ()
08:51:53 <corgifex> what's the difference?
08:52:13 <Eduard_Munteanu> corgifex: 'accept >> putMVar ()' runs with exceptions masked
08:52:34 <corgifex> async exceptions masked
08:52:40 <corgifex> that doesn't help you if accept throws
08:53:09 <Eduard_Munteanu> Right, but if accept fails synchronously then it's pretty much a disaster already.
08:53:34 <copumpkin> ClaudiusMaximus: allo
08:54:12 <ClaudiusMaximus> copumpkin: yo
08:54:29 <Eduard_Munteanu> dwcook: if I fork after accept, then an exception is thrown in that thread, then the handler would run on the main thread.
08:54:40 <copumpkin> ClaudiusMaximus: you should come to #haskell-lens, 'tis where the rounded talk happens :) did you see the recent changes?
08:55:18 <ClaudiusMaximus> copumpkin: ok..  i browsed the git a bit, but only enough to see that things had been changed recently
08:55:48 <dmj`> hmmm looks like type synonym instance declaration construction changed in the new template haskell
08:56:06 <dmj`> from: tySynInstD :: Name -> [TypeQ] -> TypeQ -> DecQ, to: tySynInstD :: Name -> TySynEqnQ -> DecQ
08:56:26 <corgifex> Eduard_Munteanu: why a disaster?
08:58:27 <Eduard_Munteanu> corgifex: synchronous exceptions tend to be more serious, don't they? Like divide by zero, or throwing an exception right from within accept which makes it difficult to recover from sanely.
08:59:18 <corgifex> you've lost me
09:00:15 <corgifex> accept can fail for any number of reasons (connection aborted, process is out of file descriptors, OS is out of file descriptors, insufficient buffer memory, firewall, ...)
09:00:30 <corgifex> in haskell all of those show up as exceptions
09:01:07 <mmachenry> I am looking to use a semaphore for a project. One of the warnings on the TSem page has me worried and there's no warning on SSem but also I don't know the difference.
09:01:15 <mmachenry> http://hackage.haskell.org/package/stm-2.4.3/docs/Control-Concurrent-STM-TSem.html
09:01:32 <Eduard_Munteanu> corgifex: the asynchronous exceptions I'm concerned about are more benign, like the user pressing Ctrl+C.
09:01:46 <jmcarthur> how is that more benign?
09:01:49 <corgifex> Eduard_Munteanu: but you still have to handle errors
09:01:58 <corgifex> even if it's just by aborting the program
09:02:06 <mmachenry> Does anyone have any experience with these libraries?
09:02:15 <corgifex> that's probably not appropriate for a server, though
09:03:37 <jmcarthur> mmachenry: the point of TSem is that you can use it in STM
09:03:45 <Eduard_Munteanu> Hm, let me think about it some more.
09:03:46 <corgifex> Eduard_Munteanu: now I see what was bothering me. your code still transfers a resource between threads, but instead of a file descriptor it's MVar state
09:04:02 <mmachenry> jmcarthur: SSem is in the STM monad as well
09:04:11 <jmcarthur> ah, let me look at that
09:04:12 * hackagebot explicit-exception 0.1.7.2 - Exceptions which are explicit in the type signature.  http://hackage.haskell.org/package/explicit-exception-0.1.7.2 (HenningThielemann)
09:04:19 <corgifex> so you'd have to protect the MVar release action (putMVar mv ()) somehow
09:04:27 <mmachenry> https://hackage.haskell.org/package/SafeSemaphore-0.10.0/docs/Control-Concurrent-STM-SSem.html
09:04:48 <jmcarthur> mmachenry: i don't see any way that SSem wouldn't have the same problem
09:04:52 <jmcarthur> mmachenry: it's a property of STM
09:05:05 <mmachenry> jmcarthur: Ah I see.
09:05:10 <jmcarthur> mmachenry: the representations are the same, in fact
09:05:19 <Eduard_Munteanu> corgifex: I'm thinking of   bracket (accept sk `finally` putMVar mv ()) close worker   but I'm unsure about it.
09:05:32 <mmachenry> jmcarthur: What exactly do they mean by large number of threads?
09:05:44 <corgifex> mmachenry: " If several threads are retying then which one succeeds next is undefined -- an unlucky thread might starve. "
09:05:46 <mmachenry> 10, 1k?
09:06:01 <jmcarthur> mmachenry: it depends on the application how large is too large for you
09:06:16 <mmachenry> I suppose that's true.
09:06:17 <jmcarthur> mmachenry: the problem is just that all those threads will wake up at once
09:06:19 <Eduard_Munteanu> corgifex: if accept fails, then it will free the MVar. If it succeeds it will do too.
09:06:26 <jmcarthur> mmachenry: even if the end result is that only one wins the race
09:07:08 <mmachenry> If they wake up and don't get the lock the they'll just block though, right?
09:07:12 <jmcarthur> right
09:07:20 <mmachenry> And potentially go back to sleep and be woken up again?
09:07:23 <Eduard_Munteanu> I wonder if takeMVar / putMVar should be part of a bracket too.
09:07:39 <jmcarthur> as far as your haskell program is concerned, the only thing observable is that one thread woke up. operationally, though, they all woke up, checked the TSem, and all but one went back to sleep
09:07:39 <corgifex> why do both TSem and SSem exist?
09:08:13 <jmcarthur> mmachenry: the point is that TSem operations can take computing resources linear in the number of threads blocked on it
09:08:28 <jmcarthur> corgifex: maybe TSem didn't exist when SSem was written?
09:08:34 <mmachenry> jmcarthur: What's the problem with all of them being woken up like this other than it's possibly not a fair algorithm? Is it resourse intensive?
09:08:52 <jmcarthur> mmachenry: it could be. consider the possibility that it's a million threads
09:08:59 <Eduard_Munteanu> corgifex: T* stuff is mostly there because STM has different semantics (it rolls back and retries).
09:09:04 <mmachenry> jmcarthur: I see you answered just before I asked.
09:09:12 <corgifex> (haskell is one of the few languages that will actually let you spawn a million threads)
09:09:21 <Eduard_Munteanu> s/semantics/behavior/
09:09:24 <corgifex> Eduard_Munteanu: they're both in STM
09:09:25 <jmcarthur> corgifex: it's awesome
09:09:44 <Eduard_Munteanu> Hm, are they? http://hackage.haskell.org/package/SafeSemaphore-0.9.0/docs/Control-Concurrent-SSem.html
09:09:55 <jmcarthur> mmachenry: yeah, as corgifex points out, this is kind of a "first world problem" ;)
09:10:29 <jmcarthur> mmachenry: but for, say, very low latency servers, even "just" waking up a thousand threads unnecessarily could be bad
09:10:37 <mmachenry> This is actually fine. I have a fairly  small thread count (10) but I need to process a queue occasionally 5k records in just a few milliseconds.
09:10:45 <corgifex> Eduard_Munteanu: that's a wrapper around https://hackage.haskell.org/package/SafeSemaphore-0.10.0/docs/Control-Concurrent-STM-SSem.html
09:10:56 <jmcarthur> mmachenry: also, since this is STM, it could be that they all "successfully" take the semaphore and then all do expensive computations and then all but one roll back the transaction! that would be awful
09:11:31 <mmachenry> jmcarthur: Noted.
09:11:34 <kuribas> Is UHC often used?  I read it can compile to javascript, and GHC cannot, are there other reasons to use UHC?
09:11:51 <mmachenry> jmcarthur: My STM transactions are all fairly light weight but I'll keep that in mind.
09:11:54 <jmcarthur> kuribas: actually, ghc can be used to generate javascript now
09:12:01 <jmcarthur> kuribas: check out ghcjs for more info
09:12:10 <kuribas> jmcarthur: great, I will!
09:12:34 <jmcarthur> kuribas: i think of UHC mainly as a research compiler to test some ideas
09:12:47 <kuribas> jmcarthur: And GHC isn't?
09:12:57 <jmcarthur> GHC is both a research compiler and a practical tool
09:13:20 <kuribas> yes
09:13:43 <kuribas> Could I compile a library to javascript, and use it from a (non-haskell) javascript project?
09:13:45 <jmcarthur> but many decisions about GHC are based on practical applications, whereas i doubt that is so for UHC
09:13:56 <kuribas> jmcarthur: That makes sense.
09:13:57 <jmcarthur> kuribas: i believe so, yes
09:14:12 * hackagebot monoid-transformer 0.0.3 - Monoid counterparts to some ubiquitous monad transformers  http://hackage.haskell.org/package/monoid-transformer-0.0.3 (HenningThielemann)
09:14:23 <jmcarthur> yay, ghc 7.8.2 released
09:15:47 <augur> off topic but: anyone know any (free?) mailing list services?
09:16:27 <Eduard_Munteanu> augur: Google Groups perhaps?
09:16:48 <augur> Eduard_Munteanu: ahh neat, ill check it out. :)
09:22:21 <spookyfork> greetings. I'm having trouble installing haddock
09:22:34 <spookyfork> http://lpaste.net/102613
09:25:44 <c_wraith> spookyfork: you know haddock comes with ghc?
09:26:08 <spookyfork> updating that is
09:26:37 <c_wraith> haddock is often based on GHC internals.  Wouldn't surprise me if you can't update it usefully
09:26:47 <spookyfork> I download haskell platform
09:26:58 <spookyfork> is there anyway to update it?
09:27:09 <c_wraith> why do you want to update it?
09:27:56 <geekosaur> if you're looking for a platform release with ghc 7.8, it's in progress and scheduled for next month
09:29:12 <benzrf> hey, what's the simplest way to do paralellism in haskell?
09:29:22 <benzrf> like, take list of expressions and do a map in paralell
09:29:28 <benzrf> or something
09:29:37 <benzrf> *parallel
09:29:51 <Eduard_Munteanu> @hoogle parMap
09:29:51 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
09:30:01 <benzrf> cool o=
09:30:07 <benzrf> what is a strategy?
09:30:24 <Eduard_Munteanu> benzrf: u(+Zi)] [3:Freenode/#haskel [Act: 1,4,5,6,7,8,9,10,11,13]
09:30:24 <DR6> a way to evaluate something
09:30:28 <Eduard_Munteanu> Er.
09:30:37 <benzrf> Eduard_Munteanu: lol
09:30:41 <Eduard_Munteanu> benzrf: http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html#t:Strategy
09:30:44 <benzrf> wow thats a lotta channels o-o
09:30:52 <DR6> it lets you choose which things you blcok for, which ones are sparked for evaluation in parallel
09:31:02 <ahill-89> I suggest perusing "Parallel and Concurrent Programming in Haskell" by Simon Marlow.
09:31:15 <Eduard_Munteanu> benzrf: that's what I thought too until someone in here mentioned being in more than 80 channels :)
09:31:24 <benzrf> are simons just naturally attracted to haskell or something
09:31:33 <ahill-89> It seems that way.
09:33:30 <c_wraith> Simon is actually the title given to GHC benevolent dictators for life
09:34:05 <Eduard_Munteanu> Is that like Earl? :)
09:34:27 <c_wraith> and duke!
09:34:37 <Eduard_Munteanu> The Great Simon of Glasgow.
09:37:05 <benzrf> > 3 `using` r0
09:37:06 <lambdabot>  Not in scope: ‘r0’
09:37:06 <lambdabot>  Perhaps you meant one of these:
09:37:06 <lambdabot>    ‘r’ (imported from Debug.SimpleReflect),
09:37:06 <lambdabot>    ‘re’ (imported from Control.Lens)Not in scope: ‘using’
09:37:08 <benzrf> o-o
09:37:19 <dwcook> @type using
09:37:20 <lambdabot> Not in scope: using
09:37:28 <dwcook> ?_?
09:37:38 <benzrf> 12:34 < dwcook> ?_?
09:37:45 <benzrf> is that unicode
09:38:01 <dwcook> XD No, it's an emoticon with question mark eyebrows
09:38:06 <benzrf> oh
09:38:29 <mmachenry> ahill-89: I just bought that book due to starting to write a large concurrent system in Haskell. Have you read it?
09:39:16 <ahill-89> I've skimmed sections.
09:40:26 <flebron> Just reading about type families. Say I have a "data family Foo :: * -> *", say I have data instance Foo Int = I Int, data instance Foo Char = C Char, is there a sensible way to have f :: Foo t -> t? More generally, what can I "do" with Foo?
09:41:28 <benzrf> the Eval monad is just Identity with strictness right?
09:41:35 <benzrf> at least, partial strictness
09:42:22 <Eduard_Munteanu> flebron: if you make it an associated data family and 'f' a method of that class
09:43:00 <flebron> Right, like a typeclass method. But can one do anything with just Foo t?
09:43:36 <flebron> (Since it doesn't have a unique ctor list one wouldn't seem to be able to pattern match on it...)
09:43:37 <Eduard_Munteanu> flebron: sure, you can make 'Foo t's and extract the ones you know about.
09:44:07 <Eduard_Munteanu> flebron: f :: Foo t -> Maybe t   should work fine
09:44:16 * hackagebot prizm 0.3.1.1 - Compute with colors and differenct color spaces  http://hackage.haskell.org/package/prizm-0.3.1.1 (ParnellSpringmeyer)
09:44:38 <flebron> Where... f (C x) = Just x, f (I x) = Just x, f _ = Nothing?
09:44:46 <Eduard_Munteanu> (er, I meant you can make some Foo t for some particular t.
09:44:53 <Eduard_Munteanu> flebron: yeah
09:45:05 <c_wraith> benzrf: to be precise, it's Identity where pattern-matching on the constructor (as in the first argument to >>= for instance) causes evaluation.
09:45:20 <flebron> Ah OK, so I can pattern match on it, it's just I'll have to pattern match on any possible ctor one has added to that family.
09:45:26 <c_wraith> benzrf: as opposed to newtype-based Identity, where pattern-matching on the constructor is a no-op.
09:45:32 <benzrf> c_wraith: kk
09:45:41 <benzrf> wait, identity is a newtype?
09:45:43 <flebron> i.e. if someone then creates data instance Foo Bool = B Bool, I will return Nothing.
09:46:17 <c_wraith> benzrf: yeah.  newtype Identity a = Identity { runIdentity :: a }
09:46:26 <Eduard_Munteanu> flebron: more generally, it's just the pattern coverage requirement, and the only way to make your function total is to provide a pattern that matches everything eventually.
09:46:30 <benzrf> col
09:46:44 <flebron> Right.
09:46:51 <c_wraith> benzrf: in contrast, Eval is data.  The difference is what makes Eval work differently
09:47:41 <flebron> OK, and stupid question but... other than the possibility of extending the type, why would this be better than data Foo = B Bool | C Char | I Int?
09:47:43 <Eduard_Munteanu> flebron: also note you don't have to have exactly one constructor for each instance
09:48:03 <flebron> Right, yeah, I'll need to cover \sum_i |ctors_i| cases.
09:48:23 <Eduard_Munteanu> flebron: the extending part is the issue, yeah
09:49:17 <Eduard_Munteanu> flebron: e.g. see http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-TypeLits.html for example
09:50:06 <flebron> I understood DataKinds w.r.t. their use in making sized vectors, now I was trying to understand "type families" as functions from types to types
09:50:08 <Eduard_Munteanu> Actually that may be too complex if you're looking for a simple example.
09:50:20 <flebron> (As far as I knew, Maybe was already a function from types to types)
09:51:00 <Eduard_Munteanu> flebron: it is
09:51:30 <Eduard_Munteanu> flebron: type families let you match on the lefthand side of said "functions"
09:51:33 <c_wraith> Type constructors are very special functions between types.  They're guaranteed to be injective.
09:51:42 <c_wraith> Type families have no such restriction
09:52:03 <flebron> Yeah I was thinking that - something like maybe x = {some tag} x, whereas a type family would be f x = {whatever i want} x {whatever i want}
09:52:05 <Eduard_Munteanu> Also they can be partial.
09:53:04 <flebron> Err, that's not what I meant to write haha, something like f Int = ..., f Char = ...
09:53:30 <flebron> But that seems kind of weird, because if you now give me an f Int, I have no idea what it could be.
09:53:42 <Eduard_Munteanu> flebron: yeah, consider   type family F a; type instance F Int = Bool; type instance F () = Char
09:54:46 <Eduard_Munteanu> F is open and partial, compared to things like Maybe.
09:55:10 <flebron> "open" because you can add new types to its definition, partial because it's not defined for some already-defined types?
09:55:10 <c_wraith> I guess you could call Maybe open.
09:55:27 <Eduard_Munteanu> flebron: yeah
09:55:47 <Eduard_Munteanu> Mm, true.
09:55:55 <Eduard_Munteanu> Since * itself is an open kind.
09:55:56 <c_wraith> But only because it's some sort of natural transformation.  Everything is valid input.
09:56:19 <Eduard_Munteanu> "Instances" of * are data declarations. :)
09:56:33 <flebron> Oh, would this be useful for something like, data TrueType; data FalseType; type family IsZero k; type instance IsZero Z = TrueType; type instance IsZero (S n) = FalseType?
09:56:52 * flebron feels smalltalkish making True and False types
09:57:31 <c_wraith> flebron: if you want to get fance, you can just use DataKinds to promote Bool
09:57:34 <c_wraith> *fancy
09:57:50 <Eduard_Munteanu> flebron: it's probably more useful to have IsZero as a class
09:57:53 <flebron> Or better, something like type family LessThan k k', instance LessThan Z (S n) = TrueType; type instance (LessThan n m) => LessThan n (S m) = TrueType or something
09:58:02 * flebron has just made up syntax, likely.
09:58:59 <flebron> Hrm, right. So what's a case where type families would solve a problem?
09:59:05 <chrisw_> What would be a good data structure for writing a register allocator on a list of SSA statements, where some statements (such as variable assignment) point to other statements? I think a mutable vector would be a good choice, except that "references" to other statements would actually be indices into the vector, which is a bit cumbersome.
10:00:20 <Eduard_Munteanu> flebron: you can define stuff like nat addition or substraction
10:00:34 <Eduard_Munteanu> Arguably most of these cases can be dealt with using classes too.
10:00:39 <flebron> Yeah I saw "type family   Plus (n :: Nat) (m :: Nat) :: Nat
10:00:51 <flebron> But I'm not sure how to grok that - "Nat" here is a kind?
10:00:58 <c_wraith> yes, Nat is a kind
10:01:32 <c_wraith> It might be the built-in Nat kind in GHC 7.6+
10:01:33 <Eduard_Munteanu> flebron: if you mean the one in TypeLits, it's sort of bogus because arithmetic doesn't reduce yet on GHC 7.6
10:02:07 <flebron> Hrm, OK. So the previous example where I used FalseType and TrueType is best dealt with typeclasses because they are sort of "boolean" - either you are a member or you aren't, while type families can output whatever they want?
10:02:45 <DR6> no, type families can't output what they want either
10:02:49 <Eduard_Munteanu> flebron: you can define   data N = Z | S N;  type family (+) (m :: N) (n :: N) :: N;  type instance m + Z = m;  type instance m + (S n) = S (m + n)
10:02:51 <DR6> not with datakinds
10:03:40 <DR6> datakinds just makes it that for every value a of type t (if t is simple enough) there is a type a of kind t
10:03:45 <flebron> And just to be clear, there are never any values of type Z or type S Z or any of those, they are purely proof materials?
10:03:47 <Eduard_Munteanu> flebron: type families are kinded just like ordinary type functions, though you can overload them based on the kind if you use PolyKinds
10:03:48 <DR6> that's what's happening with nat
10:04:05 <DR6> yes, only type of kind * have elements
10:04:32 <Eduard_Munteanu> flebron: there aren't, but you could have a Sing Z, if you want
10:04:33 <flebron> Eduard_Munteanu: So you could define + for Nats and + for * -> *s?
10:04:51 <flebron> (With PolyKinds.)
10:05:08 <Eduard_Munteanu> flebron: only if (+) is polykinded, above it isn't, it's restricted to N
10:05:40 <Eduard_Munteanu> flebron: e.g. if it was  type family (+) (m :: k) (n :: k) :: k
10:06:12 <flebron> Oh right, k would be a kind variable, and * would be an instantiation of that k? (As would Nat)
10:06:25 <Eduard_Munteanu> Yeah.
10:06:39 <Eduard_Munteanu> flebron: the Sing data family from TypeLits is overloaded based on kind, for instance
10:06:53 <flebron> Cool. Thanks, I'll keep reading about this stuff, currently https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
10:07:21 <Eduard_Munteanu> flebron: for my N, I could declare   data instance Sing (n :: Nat) where SingZero :: Sing Z; SingSucc :: Sing n -> Sing (S n)
10:07:52 <Eduard_Munteanu> Er, n :: N
10:08:00 <flebron> When TypeLits writes "type family (m :: Nat) <=? (n :: Nat) :: Bool
10:08:07 <flebron> Bool here is a kind?
10:08:28 <Eduard_Munteanu> flebron: yes, the lifted Bool, when using DataKinds
10:08:38 <flebron> Ah OK, so that's my TrueType and FalseType :p
10:08:55 <c_wraith> flebron: that's why I said you could just lift Bool
10:08:57 <Eduard_Munteanu> flebron: no, your TrueTYpe and FalseType were types in *
10:09:08 <flebron> Ah OK, fair enough.
10:09:23 <c_wraith> err.  "promote" is the proper term, and I always forget it
10:09:54 <flebron> This is also a dumb question but, I don't see in http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-TypeLits.html#%3C%3D where <= is being given instances?
10:09:55 <Eduard_Munteanu> flebron: data Bool = False | True gives you (1) False and True type constructors for the Bool type in *, and (2) False and True type constructors as members of the Bool kind
10:10:06 <flebron> Right, right.
10:10:45 <Eduard_Munteanu> flebron: they don't give them instances, GHC pre-7.8 can't reduce operations on Nats.
10:16:19 <flebron> What do you mean by "reduce" and "operations"? (I assume operations means type families which work on Nat-kinded things?)
10:17:00 <c_wraith> it doesn't know (1 + 0) ~ 1
10:17:02 <Eduard_Munteanu> flebron: e.g. you don't get 1 + 1 ~ 2, it stays 1 + 1
10:18:03 <carter> yes
10:18:06 <carter> so don't ue it
10:18:12 <carter> use type families and your own peanos
10:18:20 <c_wraith> well.  Don't use it if you need arithmetic
10:18:22 <flebron> Oh, so if I defined :+: as a type family, then had another type family matching on S Z, it wouldn't understand that this S Z is the same as Z :+: S Z?
10:18:38 <carter> ??
10:18:46 <Eduard_Munteanu> flebron: no no, it works for your own defined nats
10:19:02 <flebron> Oh, it doesn't work for the TypeLits Nat?
10:19:02 <Eduard_Munteanu> flebron: just not on the GHC type-level literals
10:19:11 <Eduard_Munteanu> Yeah.
10:19:17 <carter> nope
10:19:17 <c_wraith> If you don't need type-level arithmetic, Nat works fine :)
10:19:21 <carter> yeah
10:19:24 <flebron> But presumably, when/if they work for GHC's Nat, they'll have an efficient implementation? (At least, more than the unary encoding mine would have)
10:19:36 <carter> flebron: well
10:19:37 <carter> doesn't amtter
10:19:42 <carter> thats a year or more out
10:20:20 <c_wraith> There's something on hackage that uses a binary encode for type-level nats, just to make compiling with large ones much faster
10:20:25 <flebron> I'm just wondering why one would use TypeLit Nats over ones own
10:20:33 <c_wraith> flebron: syntax
10:20:47 <c_wraith> sometimes you really want to just say 5 and be done with it
10:21:04 <c_wraith> Because you'll never do arithmetic on the types
10:21:12 <flebron> Oooh, so there's that benefit. OK, I didn't know when you wrote "1 + 0" you literally meant "1 + 0".
10:22:54 <flebron> So if GHC doesn't do arithmetic on TypeLit Nats, why even have the family "type family (m :: Nat) * (n :: Nat) :: Nat"?
10:23:06 <c_wraith> That's more or less about reserving namespace
10:23:16 <c_wraith> When the feature gets added, the names will be there
10:23:27 <c_wraith> Also, GHC 7.8 does *some* arithmetic.  Just not enough
10:23:49 <c_wraith> GHC 7.8 does know that 1 + 0 ~ 1
10:24:04 <carter> which is still kinda boring
10:24:09 <c_wraith> But it doesn't know that m + 1 ~ n + 1  implies m ~ n
10:24:19 <carter> you can use closed type fmailies to use the pretty syntax to get peanos
10:24:20 <c_wraith> Which is the sort of thing you need in order to make arithmetic useful
10:24:34 <flebron> Right, using induction.
10:24:37 <carter> type family U :: TypeLit.Nat -> PeanoNat where
10:24:46 <carter>  U 0 = Z
10:24:53 <carter>  U n = S (n-1)
10:24:57 <carter> actaully works
10:25:01 <carter> which is kinda cool
10:25:14 <flebron> Wouldn't it be U n = S (U (n - 1))?
10:25:28 <flebron> Or U (S n) = S (U n)?
10:25:38 <carter> oy eah
10:25:40 <carter> nope
10:25:42 <Eduard_Munteanu> The former, I think
10:25:43 <carter> flebron: no S
10:25:45 <carter> yes
10:25:49 <carter> U n (S u (n-1))
10:25:57 <carter> U n  = (S u (n-1))
10:25:59 <Eduard_Munteanu> Nats aren't defined inductively.
10:26:02 <carter> yeah
10:26:05 <carter> which annoys
10:26:08 <flebron> Oh yeah, no "U (S n)", that'd make no sense
10:26:30 <c_wraith> Need full type-level integers, though.  Why are negative numbers discriminated against?
10:27:10 <Eduard_Munteanu> That might be even easier, since you don't have corner cases for subtraction.
10:27:12 <flebron> GHC 8 might have Complex as a built in type, and maybe we can do transfinite induction if Ordinal is now a kind :)
10:27:13 <c_wraith> discriminating against negative numbers made sense with the unary inductive encoding
10:27:42 <c_wraith> But when the encoding is not the unary inductive encoding, you don't need to restrict yourself to non-negative
10:28:50 <Eduard_Munteanu> Z is pretty much Either N N if you want to preserve the unary encoding.
10:29:12 <c_wraith> then you get two zeros.  Ick.
10:29:22 <Eduard_Munteanu> (Left n --> + n,  Right n --> - 1 - n)
10:29:26 <Eduard_Munteanu> No, not that way.
10:29:29 <c_wraith> oh, encoding that way
10:29:31 <c_wraith> makes more sense
10:29:32 <Eduard_Munteanu> Agda uses that.
10:29:44 <Eduard_Munteanu> (the one I described above, not 2 zeros)
10:30:20 <c_wraith> Obviously, if you're doing it inductively, you should be using balanced ternary.
10:30:33 <c_wraith> negative values for free!
10:31:14 <Eduard_Munteanu> 0, -1, 1, -2, 2, -3, 3 ... ?
10:31:43 <c_wraith> balanced ternary uses -1, 0, and 1 as digits.
10:31:49 <c_wraith> and is base-3
10:32:13 <Eduard_Munteanu> Oh, you really mean that.
10:32:20 <Algebr> If you see a do, does that always mean something related to a Monad?
10:32:34 <Hafydd> > do "hello"
10:32:36 <c_wraith> Algebr: in practice, yes.  pedantically, no.
10:32:37 <lambdabot>  "hello"
10:32:39 <Hafydd> No.
10:32:44 <c_wraith> Hafydd: bad example.
10:32:55 <Hafydd> That doesn't use String's Monad instance.
10:33:03 <c_wraith> Hafydd: but String has one
10:33:08 <c_wraith> > do ()
10:33:09 <lambdabot>  ()
10:33:10 <Hafydd> Irrellevant.
10:33:16 <Hafydd> -l
10:33:17 <c_wraith> on the other hand, () doesn't have one
10:33:25 <c_wraith> Making it a much better example
10:34:25 <c_wraith> Hafydd: with String, there is a type with a Monad instance involved, even if no ops from that instance are used.  It clouds the issue.
10:34:32 <Hafydd> Perhaps.
10:34:45 <allsystemsarego> Hi all, what does the (:.) mean here? "import Data.Array.Accelerate (indexArray,Z(..),(:.)(..))"
10:34:59 <c_wraith> allsystemsarego: it's a name defined in the module
10:35:11 <c_wraith> allsystemsarego: what it *means* depends on what the module says it means
10:35:16 <allsystemsarego> c_wraith, thanks
10:35:57 <allsystemsarego> it doesn't look like a type constructor hence my question
10:36:03 <c_wraith> allsystemsarego: though with that syntax, I can tell you it's either a type or a class, and all of its stuff is being imported. (It's probably a type, so all the constructors are being imported)
10:36:28 <allsystemsarego> ok, I'll look into that
10:36:32 <c_wraith> allsystemsarego: why not? : is treated as a capital letter
10:36:38 <allsystemsarego> oh
10:36:46 <allsystemsarego> good to know
10:37:19 <int-e> oops. forgot to build lens for lambdabot. *twiddles thumbs*
10:37:21 <c_wraith> It's the only operator character that works as a capital letter, as far as I know
10:37:44 <Drezil> allsystemsarego: :. is dimension-chaning in data.array .. iirc.
10:38:14 <Drezil> your array is then of type (Int :. Int :. Z) or something ..
10:38:20 <c_wraith> Drezil: not in Data.Array.  You're thinking of repa, I think
10:38:27 <Drezil> aww.. -.-
10:38:31 <Drezil> right. repa.
10:38:33 <Drezil> :/
10:38:36 <Drezil> nvm then.
10:38:36 <allsystemsarego> this is from accelerate
10:38:40 <pyon> 3 days between GHC 7.8.1 and GHC 7.8.2? Was some serious error fixed or what?
10:38:57 <c_wraith> pyon: yeah, there was a bug that prevented acid-state (among others) from compiling
10:39:07 <int-e> > 1
10:39:13 <lambdabot>  1
10:39:15 <int-e> @botsnack
10:39:19 <lambdabot> :)
10:45:22 <corgifex> @let greeting = "hello"
10:45:23 <lambdabot>  Defined.
10:45:28 <corgifex> > greetin
10:45:29 <lambdabot>  Not in scope: ‘greetin’
10:45:29 <lambdabot>  Perhaps you meant ‘greeting’ (line 150)
10:45:38 <corgifex> good
10:50:35 <ruzu> :t love
10:50:36 <lambdabot> Not in scope: love
10:50:46 <ruzu> :-(
10:59:47 <kqr> we all love you lambdabot
11:03:09 <int-e> argh! another encoding mismatch.
11:05:30 <MagneticDuck> hey guys, having trouble installing the haskell ncurses library
11:05:34 <monochrom> poor int-e :)
11:06:10 <MagneticDuck> (getting errors)
11:06:13 <MagneticDuck> http://ix.io/bE6
11:06:29 <MagneticDuck> I have dah ncurses installed on my system
11:06:40 <MagneticDuck> so... is there some sort of dev package I need to have installed?
11:06:42 <dv-> not the right one then
11:06:49 <MagneticDuck> mm
11:07:17 <dv-> libncursesw5-dev i think
11:07:33 <MagneticDuck> (using arch)
11:08:31 <MagneticDuck> hm...
11:08:36 <MagneticDuck> https://bbs.archlinux.org/viewtopic.php?id=117029
11:08:53 <MagneticDuck> but I have the package of which they speak installed!
11:09:17 <MagneticDuck> and that library you're talking about isn't available here dv- :<
11:10:03 <dv-> i guess you need to edit the haskell library to include ncurses.h rather than ncursesw/ncurses.h
11:10:15 <MagneticDuck> :<
11:10:46 <allsystemsarego> MagneticDuck, I think I have the solution to your problem
11:10:53 <MagneticDuck> wonderful/11
11:10:56 <MagneticDuck> !!!one11
11:11:03 <MagneticDuck> what is it?
11:11:10 <allsystemsarego> as root cd to /usr/include
11:11:14 <geekosaur> the haskell ncurses library needs to be updated; ncursesw was folded in years ago
11:11:20 <MagneticDuck> yeah.
11:11:44 <allsystemsarego> MagneticDuck, then create symlinks ncurses.h to curses.h
11:11:53 <MagneticDuck> yeah that could work
11:12:00 <allsystemsarego> and ncursesw.h to cursesw.h
11:12:01 <MagneticDuck> I'll just have to remember to do it every time I reinstall ncurses :/
11:12:07 <allsystemsarego> yup
11:13:10 <MagneticDuck> allsystemsarego: ...
11:13:11 <MagneticDuck> strange...
11:13:23 <MagneticDuck> I already have all of those filesA!
11:13:29 <allsystemsarego> oh
11:13:37 <MagneticDuck> yet I still get the error message
11:14:01 <allsystemsarego> pastebin the results of ls -lh *curses*.h
11:14:21 <MagneticDuck> http://ix.io/bE8
11:14:32 <MagneticDuck> wait a sec
11:14:37 <MagneticDuck> uh...
11:14:40 <MagneticDuck> did I make that link?
11:14:51 * MagneticDuck got distracted because his cat did something funny
11:14:56 <MagneticDuck> >_>
11:15:34 <MagneticDuck> oh huh, that's funny.. the ncurses package exports that link
11:15:48 <bennofs> The saner way is to fix the ncurses package IMO
11:16:18 <allsystemsarego> yeah, file a bug report is the better solution
11:16:38 <allsystemsarego> or dig through the code and submit a pull request
11:16:52 <MagneticDuck> I'll do that
11:18:44 <meretrix> Why can't I write a generic newtype unwrapper like "f x y = z where x z = y"?  So to unwrap "newtype Price = Price Double", I would call "f Price (Price 3.4)".
11:19:37 <meretrix> f would have type (a -> b) -> b -> a
11:20:06 <jmcarthur> meretrix: why not:     newtype Price = Price { getPrice :: Double }    which would allow you to just use getPrice
11:20:28 <meretrix> jmcarthur: The newtypes are all defined in another library.
11:21:42 <jmcarthur> meretrix: maybe once you have ghc 7.8 you can just use the new Coercible type class
11:22:03 <meretrix> I'll check that out, thanks.
11:22:03 <Ralith> meretrix: because patterns are not first-class
11:22:18 <meretrix> Ah that explains it.
11:22:54 <Ralith> meretrix: however, functions are, so you could just pass the accessor around
11:23:29 <jmcarthur> meretrix: in particular, with the new machinery you could say   coerce :: Price -> Double
11:24:27 * hackagebot conduit-combinators 0.2.4.1 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.4.1 (MichaelSnoyman)
11:24:27 <jmcarthur> but note that coerce is not always going to play very nicely with type inference, since there is no functional dependency or anything
11:25:07 <int-e> @type xyzzy
11:25:12 <lambdabot> Not in scope: ‘xyzzy’
11:25:16 <int-e> @type ä
11:25:22 <lambdabot> Not in scope: ‘ä’
11:27:30 <meretrix> jmcarthur: Awesome! coerce is exactly what I wanted. I'm really liking ghc-7.8. :D
11:29:22 <no-n> > do { let a = 5 in return a} :: Maybe Int -- How would I split the let/in statement over two lines without "parse error on in"
11:29:29 <lambdabot>  Just 5
11:30:55 <maxcan> you don't need the "in" inside of a do block
11:31:07 <no-n> i want it though
11:31:23 <no-n> to keep bindings local to single expressions
11:31:24 <maxcan> if you really want to have it (i think it will prevent the binding from affecting the trailing part), just make sure that the "in" is indented at least as much as the "let"
11:31:34 <maxcan> maybe need to indent more than the let
11:31:37 <haasn> further, actually.
11:31:59 <no-n> actually if you do let blah in, then newline indent it works
11:32:19 <haasn> indenting it too far back will terminate the do block, on the same line will introduce a new do-block-statement, and past the current line will treat it as part of the previous
11:32:23 <no-n> but that's not good for multiline blah
11:33:35 <angerman> So I have: getEditText :: Widget Edit -> IO T.Text and T.unpack :: T.Text -> String, how Do I get x :: Widget Edit -> IO String ?
11:34:26 <no-n> ok that'll do
11:35:15 <angerman> x y = do { z <- getEditText y; return $ T.unpack z } ? There must be a simpler solution.
11:36:17 <foobarbaz_> Hi guys, I was wondering if there's any notation similar to Sigma to represent folding?
11:36:34 <foobarbaz_> I have a bunch of elements that I want to fold left and union
11:36:54 <foobarbaz_> And I'm wondering if there's a notation commonly used for that within papers
11:36:54 <croyd> liftM T.unpack . getEditText
11:38:09 <angerman> ahh liftM.
11:38:19 <angerman> (facepalm)
11:42:58 <bennofs> in showsPrec d, what does d stand for?
11:43:40 <bennofs> I don't understand what "operator precendence of surrounding context" should be
11:44:17 <c_wraith> bennofs: it has to do with whether it needs to put things in parens or not
11:44:50 <quuN> hello, how can i compase "(.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a)" and "(.:) :: FromJSON a => Object -> Text -> Parser a" together? these are functions from Aeson
11:44:54 <quuN> compose*
11:45:22 <bennofs> for example in 'showString "Leaf " . showsPrec (app_prec+1) m' (where appPrec = 10) , why is d set to 11? I thought the "surrounding context" is function application here, and function application has precendence 10?
11:45:24 <ion> In “foo (Just 5)”, the Just 5 should be in parens. Function application has a precedence of “11” so d = 11. In “n + Just 5” it does not need to be in parens. + has a precedence of 6.
11:45:38 <quuN> i want to get nested json from optional json field
11:45:54 <bennofs> ion: quoting the documentation: "the operator precedence of the enclosing context (a number from 0 to 11). Function application has precedence *10*."
11:47:08 <bennofs> ion: is that an error in the documentation then?
11:49:03 <quuN> e.g i can compose (.:) together like this: (obj .: "foo") >>= (.: "bar")
11:49:16 <quuN> but i'm not sure how to do it with (.:?)
11:49:32 <c_wraith> bennofs: nah, 10 is correct.  It's just easy to forget
11:50:02 <bennofs> quuN: (obj .:? "someField") >>= traverse (.: "anotherField") should be of type Parser (Maybe TypeOfAnotherField)
11:50:09 <bennofs> quuN: traverse is from Data.Traversable
11:50:21 <quuN> :t traverse
11:50:22 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:50:30 <bennofs> quuN: Maybe is an instance of Traversable
11:50:57 <bennofs> c_wraith: why does the example set d to 11 then when it calls itself?
11:51:10 <ion> Sorry, function application has a precedence of “10” indeed. If we have, say, Just (Just 5), the inner Maybe needs to have parens. The show instance for Maybe will use application precedence *plus one* for the inner value to make sure it has parens when appropriate. showsPrec 10 (Just 5) will not add parens because a plain “Just 5” does not need them.
11:52:59 <c_wraith> bennofs: record modification/initialization syntax is at priority 11
11:53:11 <bennofs> so showsPrec d means: "surround the resulting expression with parens if the operator used to construct this expression has a precendence less or equal to d" ?
11:53:27 <c_wraith> bennofs: that is  foo F {bar = baz}  is parsed as foo (F {bar = baz})
11:53:35 <bennofs> s/less or equal/less
11:54:17 <bennofs> so in Just (Just 5), d is set to 11. Just 5 is constructed via function application (which has precendence 11), therefore it is surrounded with parens?
11:54:28 <bennofs> The second 11 should be a 10
11:54:59 <c_wraith> bennofs: I haven't worked through the details myself.  I just know it's about intelligent use of parens.
11:55:04 <quuN> bennofs: thanks, that compiles now but fails at run time, currently i'm having ((o .:? "foo") >>= traverse (.: "bar")) .!= ""
11:55:22 <monochrom> bennofs: I think your description is right
11:55:23 <ion> > showString "Foo " . showsPrec 10 (Just 42) $ ""
11:55:24 <lambdabot>  "Foo Just 42"
11:55:27 <ion> > showString "Foo " . showsPrec 11 (Just 42) $ ""
11:55:28 <lambdabot>  "Foo (Just 42)"
11:55:41 <quuN> i just want to get value of "bar" field if "foo" is available and if it's not then return "".
11:55:45 <bennofs> IMO if d was always one less than it's currently, that would be more intuitive
11:56:23 <bennofs> quuN: can you show an example of the json you want to parse?
11:58:17 <quuN> bennofs: sure {"alwaysThere": 1, "foo": {"bar": 2}}
12:00:13 <heatsink> I want to make a class like Binary where put and get memoize some data types.  Repeatedly putting the same Text into a file, for instance, would serialize the text, then emit integer indices referring to the previously serialized text.
12:00:59 <heatsink> I could do this by wrapping the Put and Get types with a state monad that keeps track of memoization tables for each memoized type.
12:04:03 <heatsink> The serializer's state monad needs a table for each memoizable type.  That feels like a bad design because it centralizes memoization, which should work independently for each type.
12:04:25 <heatsink> Does that seem reasonable?  Is there a better approach?  Should I explain it more concretely?
12:04:51 <quuN> bennofs: sorry, 2 should be a string {"alwaysThere": 1, "foo": {"bar": "2"}} because of .!= "" but that mistake inexample, not in code. :)
12:05:03 <Eduard_Munteanu> quuN: option "" (x .: "foo" >>= (.: "bar")) ?
12:05:44 <quuN> Eduard_Munteanu: No.
12:05:50 <Eduard_Munteanu> Er, rather   (x .: "foo" >>= (.: "bar")) <|> pure ""   since option is an attoparsec thing.
12:06:19 <bennofs> quuN: that doesn't crash for me on your example
12:06:30 <Eduard_Munteanu> quuN: why no?
12:06:41 <bennofs> quuN: parseMaybe (\obj -> ((obj .:? "foo") >>= traverse (.: "bar")) .!= "") $ fromJust $ decode "{\"alwaysThere\": 1, \"foo\": {\"bar\": \"2\"}}" :: Maybe String
12:06:48 <bennofs> quuN: prints Just "2"
12:06:48 <Eduard_Munteanu> (I'm expecting a "no because..." instead.)
12:08:34 <TheKing42> Anyone know a version of getContents that will only give what has been currently entered without blocking?
12:08:51 <quuN> bennofs: it doesn't crash because you have "foo" in example probably. :)
12:09:07 <quuN> and the point of .:? is to specify that field is optional
12:09:37 <bennofs> quuN: also doesn't crash if I try to parse the empty document {} with it
12:10:01 <bennofs> quuN: it won't work though if foo is there but bar is missing
12:10:36 <Eduard_Munteanu> TheKing42: any reason why you want that?
12:10:54 <Eduard_Munteanu> Perhaps there's some other way to accomplish it.
12:11:12 <TheKing42> running a program with system.process, want to get some input, but it is terribly important, and it is okay if it gets cut off.
12:11:26 <TheKing42> I was going to look up a "h" version of whatever the answer was.
12:12:56 <jophish> Every value has a type, and every type has a kind = * (ignoring unboxed values for now). Is it correct to say that every value has a kind?
12:13:09 <jophish> where that kind = *, of course
12:13:29 <Eduard_Munteanu> TheKing42: it might be possible with hGetBufSome but AFAICT you don't really want that. Could you describe the usecase a bit more detailed?
12:14:11 <TheKing42> Okay, I am making a code golf challenge, and I am having the programs output commentary to stderr. I don't want to block though for there witty banter.
12:15:24 <Eduard_Munteanu> TheKing42: oh, then just spawn a thread that reads stderr and logs it or whatever else you want to do with it.
12:16:25 <Eduard_Munteanu> e.g. forkIO (hGetContents stderr >>= doSomethingWithIt)
12:17:15 <quuN> bennofs: what is parseMaybe?
12:17:16 <TheKing42> I don't really care about it though once it is done. I would be killing the program soon anyway.
12:17:38 <TheKing42> Would killing it allow hGetContents to finish?
12:17:42 <Eduard_Munteanu> jophish: not really, you should say the kind of that value's type is *
12:17:45 <bennofs> quuN: it's just part of the setup code I used in GHCi to parse json without writing a datatype + fromJson instance first :)
12:18:32 <Eduard_Munteanu> TheKing42: if you kill it, hGetContents will terminate at some point
12:18:40 <TheKing42> Cool
12:18:40 <jophish> Eduard_Munteanu: yeah, that's pretty much what I suspected
12:18:48 <TheKing42> I'll do that I think.
12:18:57 <jmcarthur> TheKing42: i recommend looking at the async package
12:19:00 <TheKing42> And it won't close it, right?
12:19:08 <Eduard_Munteanu> jophish: for this particular case, I would say "* is the kind of inhabited types" if that's what you mean.
12:19:23 <jmcarthur> TheKing42: makes it very easy to spawn a thread that eventually gives you some output, and you can kill it whenever you want
12:19:55 <TheKing42> I do not think I need concurrency.
12:19:58 <Eduard_Munteanu> TheKing42: close what? hGetContents already puts the handle in a semi-closed state in which it gets garbage collected when it isn't needed anymore.
12:20:00 <jophish> Eduard_Munteanu: ah yes, thank you
12:20:45 <jmcarthur> TheKing42: isn't what you are describing fundamentally concurrent?
12:21:20 <TheKing42> Not really. It doesn't run the programs concurrently.
12:21:22 <Eduard_Munteanu> TheKing42: in Haskell you usually do concurrency instead of polling / select()-like / nonblocking stuff.
12:21:28 <TheKing42> Wait, actually it does.
12:21:43 <jmcarthur> TheKing42: even if it doesn't, you are waiting on concurrent streams of data
12:21:53 <TheKing42> But that is handled by System.Process.runInteractiveCommand
12:22:07 <TheKing42> I don't think I need explicit concurrency.
12:22:12 <jmcarthur> TheKing42: that just gives you multiple handles
12:22:12 <Eduard_Munteanu> TheKing42: well, that's the evilness of lazy IO :)
12:22:20 <jmcarthur> TheKing42: you still have to do something with them
12:22:36 <TheKing42> It also runs the programs concurrently.
12:23:07 <jmcarthur> TheKing42: I think a lot of people are irrationally afraid of concurrency. It's really not that bad in general, and is especially nice in Haskell relative to most other languages I've used.
12:23:42 <TheKing42> I am have written concurrent servers before with extra threads just to prevent nesting.
12:24:34 <TheKing42> Wait a sec.
12:24:35 <TheKing42> Hmm
12:24:39 <jmcarthur> TheKing42: In Haskell, if it kind of looks like concurrency, we tend to embrace that, even if it means tons of threads.
12:25:16 <jmcarthur> TheKing42: The GHC runtime system is one of the few that can reasonably support millions of threads.
12:27:23 <corgifex> putStr' = mapM_ (forkIO . putChar)
12:28:03 <jmcarthur> @slap corgifex
12:28:03 * lambdabot is overcome by a sudden desire to hurt corgifex
12:28:04 <TheKing42> Hmm, yeah, that would work I think.
12:28:25 <TheKing42> @slap ***lambdabot
12:28:26 * lambdabot pokes ***lambdabot in the eye
12:28:41 <jmcarthur> well that wasn't very intelligent
12:29:09 <TheKing42> @poke lambdabot
12:29:09 <lambdabot> Maybe you meant: vote more
12:29:09 <corgifex> @nixon
12:29:10 <lambdabot> A man who has never lost himself in a cause bigger than himself has missed one of life's mountaintop experiences. Only in losing himself does he find himself. Only then does he discover all the latent strengths he never knew he had and which otherwise would have remained dormant.
12:29:13 <TheKing42> @vote
12:29:13 <lambdabot> Missing argument. Check @help vote for info.
12:29:17 <heatsink> @slap itself
12:29:18 * lambdabot pushes itself from his chair
12:29:18 <TheKing42> @help vote
12:29:19 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
12:29:37 <TheKing42> @vote Is the answer to question no?
12:29:37 <lambdabot> usage: @vote <poll> <choice>
12:29:37 <Eduard_Munteanu> /query lambdabot
12:30:00 <TheKing42> @vote <Is the answer to this question no?> <Yes> <No>
12:30:00 <lambdabot> usage: @vote <poll> <choice>
12:30:06 <TheKing42> @help poll
12:30:06 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
12:30:12 <TheKing42> @poll-list
12:30:12 <lambdabot> ["\"WhyDoesLabmdabotSuckSoBad?\"","(++)","ConfusedWithVixenSituation","FlavaOfJRuby","Prelude-(.)?","best-programming-language","best-spoken-language","food","funniest-thing-in-the-whole-world","naming","nethack","president","prove->","remove@src","sleep"]
12:30:33 <Eduard_Munteanu> TheKing42: you should talk with lambdabot privately if you want to explore its commands
12:30:44 <TheKing42> sorry, I am done
12:31:02 <nstdloop> Hey everyone. Having some trouble with updating cabal to 1.18.0.3, it fails when generating documentation with "invalid argument"
12:31:26 <nstdloop> with --verbose it fails during this step: Installing ~/Library/Haskell/doc/tmphaddock-17555/synopsis.png
12:31:26 <nstdloop> to /Users/Jonathan/Library/Haskell/doc/synopsis.png
12:34:35 * hackagebot yesod-platform 1.2.9.3 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.9.3 (MichaelSnoyman)
12:34:37 * hackagebot yesod-bin 1.2.8.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.8.1 (MichaelSnoyman)
12:34:42 <heatsink> Does synopsis.png exist?
12:35:09 <nstdloop> yes
12:35:19 <nstdloop> ~/Library/Haskell/doc/synopsis.png exists
12:36:18 <nstdloop> is there a way to install with no docs?
12:38:49 <zzzzzzzz> in the arrow calculus, why are some terms called commands and why the typing judgment needs t2 environments?
12:39:11 <zzzzzzzz> s/t2/2
12:40:05 <petrie> Where am I messing up that this is only returning a partial list and not the full list "board" with the element changed? http://lpaste.net/7335661707567562752
12:40:49 <heatsink> I don't know what's causing the problem.  Is cabal invoking another program to install the documentation?  Sometimes you can run the program with --verbose to get more information.
12:41:06 <nstdloop> Running it with verbose only tells me it fails right after copying synopsis.png
12:41:17 <nstdloop> I'm trying now without docs
12:41:31 <heatsink> Running what with verbose?  If you run cabal with --verbose, that doesn't run other programs with --verbose.
12:41:52 <nstdloop> cabal install cabal-install --verbose
12:43:22 <jmcarthur> petrie: you are extracting the list from board, splitting it, and then returning the list. you have to put the new list into the board and return that instead
12:43:54 <petrie> Doh
12:43:58 <petrie> :) thanks jmcarthur
12:49:37 * hackagebot keyring 0.1.0.3 - Keyring access  http://hackage.haskell.org/package/keyring-0.1.0.3 (lunaryorn)
12:52:44 <CindyLinz> How can I determine the ghc-pkg's user package database path from my haskell program?
12:56:21 <dmj`> does hackage have an api anyone can connect with? Like let's say I want to get notified if a package gets update
12:56:22 <dmj`> d
12:56:54 <corgifex> IIRC hackagebot uses an rss feed
12:59:05 <NikolajK> All the types I encountered so far are constructed from older ones via -> and/or recursion. Do we define new types just to restrict the place we can use it?
13:00:12 <TheKing42> @NikolajK Essentially. We do use them to represent things, so that things can't be confused for one another.
13:00:13 <lambdabot> Unknown command, try @list
13:00:35 <dmj`> corgifex: what's the address of this feed?
13:00:40 <jmcarthur> NikolajK: ADTs aren't generally just defined in terms of existing types
13:00:52 <dmj`> oo! http://hackage.haskell.org/packages/archive/recent.rss
13:01:02 <NikolajK> what is a type which is differnet?
13:01:40 <jmcarthur> a dumb example:    data Nat = Zero | Succ Nat
13:01:42 <TheKing42> for example:
13:01:42 <TheKing42> Gold = newtype Int
13:01:43 <TheKing42> HP     = newtype Int
13:01:52 <TheKing42> wait no
13:02:06 <TheKing42> newtype Gold = Gold Int
13:02:06 <TheKing42> newtype HP     = HP Int
13:02:19 <jmcarthur> TheKing42: those are defined in terms of other types and so are not what NikolajK is looking for
13:02:37 <TheKing42> Oh, I thought he was asking why types are important.
13:02:49 <Eduard_Munteanu> If you're asking if all types boil down to sums, products and primitive types, then yes, they do.
13:02:53 <byorgey> TheKing42: better use Integer instead, you don't want to be limited to a max of 9223372036854775807 gold, do you? ;-)
13:02:57 <stephenmac7> Is trace unsafe?
13:03:04 <NikolajK> so you say it's different because you specify the terms directly and it's unrelated to a term of of other types in all ways
13:03:10 <AncientPC> I tend to write Haskell in a naive recursive fashion. Is it more idiomatic to use folds or to write recursive parts within where clauses to prevent additional stack frames? e.g. http://scienceblogs.com/goodmath/2006/12/20/tail-recursion-iteration-in-ha-1/
13:03:24 <byorgey> stephenmac7: only in the sense that its output may not be completely predictable.
13:03:26 <NikolajK> What is beyond the scope of W-types, if that makes sense
13:03:38 <byorgey> stephenmac7: but it can't, e.g., make your program crash
13:03:43 <TheKing42> @stephemac7 I wouldn't use it in production code, but that is okay since it just for debugging.
13:03:44 <lambdabot> Unknown command, try @list
13:03:53 <TheKing42> @slap yourself
13:03:54 * lambdabot is overcome by a sudden desire to hurt lambdabot
13:04:24 <stephenmac7> byorgey: Does it use unsafePerformIO?
13:04:34 <byorgey> AncientPC: it's more idiomatic to write code using folds or other sorts of recursion patterns.  But it has nothing to do with stack frames.
13:04:41 <Eduard_Munteanu> stephenmac7: it does
13:05:15 <stephenmac7> Eduard_Munteanu: I see, so it's just like that for convenience, thank you.
13:06:06 <NikolajK> also, where does Haskells if-function come from? in terms of what is it defined? is there some simply understandable pattern maching going on?
13:06:09 <AncientPC> byorgey: thanks, now I get to go read up on foldl vs foldr vs fold', etc. :P
13:06:19 <byorgey> NikolajK: if is syntax, not a function
13:06:26 <byorgey> NikolajK: it just pattern matches on a Bool
13:06:49 <byorgey> NikolajK: if you look in the Haskell Report, I bet it even specifies how if desugars into a case
13:06:51 <NikolajK> mhm, okay. I though RealWorldHaskell claims its a function
13:07:12 <NikolajK> with lazy evaluation and stuff
13:07:51 <byorgey> NikolajK: it *could be* implemented as a function, because of lazy evaluation.
13:07:52 <Eduard_Munteanu> You can write an if-like function but 'if' has its own syntax.
13:07:53 <corgifex> you could define it as if' c t e = case c of True -> t; False -> e
13:09:48 <NikolajK> okay, thx
13:10:30 <ruzu> girl -> boy -> baby
13:11:02 <jmcarthur> NikolajK: ifThenElse True a _ = a; ifThenElse False _ b = b
13:14:43 * hackagebot marmalade-upload 0.5.2 - Upload packages to Marmalade  http://hackage.haskell.org/package/marmalade-upload-0.5.2 (lunaryorn)
13:16:10 <ruzu> i wonder if ruby could support structural typing
13:16:50 <petrie> jmcarthur: is my syntax wrong trying to add it to the board list http://lpaste.net/2646327452137160704
13:17:07 <ruzu> user "nois" just sent me a webcam spam link, fyi
13:18:21 <corgifex> petrie: what is that $ doing in there?
13:18:34 <corgifex> ruzu: me too
13:18:45 <Eduard_Munteanu> Can I have one too?
13:19:01 <Eduard_Munteanu> That didn't work apparently.
13:19:02 <petrie> corgifex: Oi, I meant to put .
13:19:15 <gdoteof> i am trying to write a dataURI image to a file and running into issues.  i tried gd-3000 loadJpegByteString (dataURI :: String)   as well as loadJpegByteString $ Data.ByteString.Base64.URL.decode (dataURI :: String)
13:19:28 <petrie> I wasn't sure exactly how to after making that list concat that to the next one like I have
13:20:14 --- mode: ChanServ set +o corgifex
13:20:40 --- mode: corgifex set +b *!*@80.30.148.77
13:20:44 <Eduard_Munteanu> Oh, corgifex is mauke.
13:20:52 --- kick: nois was kicked by corgifex (no spam plz)
13:20:56 <Eduard_Munteanu> I got one now. :)
13:21:26 --- mode: corgifex set -o corgifex
13:21:51 <gdoteof> perhaps there is an easier way?  the data uri looks like "data:image/jpeg;base64,/9j/4AQAA4k...."
13:38:26 <stephenmac7> What are arrows useful for and why don't I see them being used anywhere?
13:38:58 <stephenmac7> Nevermind, found http://programmers.stackexchange.com/questions/114681/what-is-the-purpose-of-arrows
13:39:46 <Eduard_Munteanu> stephenmac7: HXT is one package that uses arrows pervasively
13:40:20 <startling> stephenmac7, they aren't very commonly-used. You probably don't need to care about them.
13:44:24 <johnw> I think HXT is the only case of them I've ever encountered, even
13:44:46 * hackagebot midi 0.2.1.2 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.2.1.2 (HenningThielemann)
13:46:27 <startling> well, functions.
13:46:35 <startling> hakyll, too.
13:49:34 <Eduard_Munteanu> asyncBracket spawns a thread for the bracketed computation and waits until the resource has been acquired, does this seem sensible to you? http://lpaste.net/102629
13:49:42 <neumond|2> gtk2hs related question: there is "destroy" signal used in gtk tutorial, along with "delete-event"; in gtk2hs tutorial only deleteEvent used - did they intentionally omit destroyEvent here?
13:50:31 <Eduard_Munteanu> It's meant to be used like  asyncBracket accept close serve  for sockets / servers.
13:51:01 <neumond|2> additionally, destroyEvent successfully binds to window object, but callback seems to be not called. what logic used there?
13:51:09 <Eduard_Munteanu> The reason for waiting is you'd normally put that in a loop and 'accept' would block until a connection has been received.
13:54:38 <Eduard_Munteanu> corgifex: do any of your previous concerns still apply to the version above?
13:58:04 <Peaker> Eduard_Munteanu: I don't understand why not have 'accept' -> create thread for socket, as normally done?
13:59:07 <Eduard_Munteanu> Peaker: I want to make sure the socket is closed properly, even if an exception is thrown midway
13:59:23 <NikolajK> how would one actually go about coding the pair type, so that you can use notation like "(1,2)"
13:59:23 <Peaker> Eduard_Munteanu: MVars are a bit dangerous.. here if an async exception happens before "bracket" is executed, in that thread, you will get a deadlock
13:59:33 <Peaker> Eduard_Munteanu: the listener socket?
13:59:50 <Eduard_Munteanu> Peaker: no, the connection socket
13:59:56 <joejev> Is there a name for the category of 0 objects and 0 morhpisms, I am refering to it as the tribial category, does that seem okay or is there a formal name?
14:00:14 <Eduard_Munteanu> Oh.
14:00:15 <johnw> I think it's the 0 category
14:00:42 <DR6__> the trivial category is more likely 1
14:00:51 <DR6__> that is, with one object and morphism
14:00:56 <DR6__> but I'm talking out my ass
14:01:08 <Eduard_Munteanu> Peaker: I guess I should do 'bracket ... `onException` putMVar mv ()'?
14:01:09 <joejev> DR6__: Isn't that called 1?
14:01:18 <NikolajK> empty category?
14:01:19 <Peaker> Eduard_Munteanu: I'd use mask -- like bracket does internally
14:01:27 <johnw> is 0 initial in Cat, and 1 final?
14:01:36 <DR6__> joejev: yes, I said that
14:02:18 <joejev> DR6__: oops, I missed that line, hmm, I guess I will call it 0 then, thanks
14:02:19 <Eduard_Munteanu> Hm. I suppose I should do that after all. I thought it might be simpler to put the entire bracket on another thread.
14:02:27 <NikolajK> If I define "data Foo = Bar Int Int", is there a way I can make Bar 1 2 and Bar 4 5 equal?
14:02:34 <Peaker> Eduard_Munteanu: why not a simpler:   safeAccept handler = mask $ \restore -> do { (conn, addr) <- accept sock ; restore (handler conn) `finally` closeSocket conn } ?
14:02:36 <DR6__> oh, while we're at it, I have a question about universal properties
14:02:42 <DR6__> let's say in Hask
14:02:51 <NikolajK> is "Bar 1 2 " the last thing this can be, or can it be evaluated?
14:02:52 <DR6__> I understand why () is terminal
14:02:57 <DR6__> but why is Void initial?
14:03:09 <Eduard_Munteanu> Peaker: I suspect you mean 'async (handler ...)'?
14:03:23 <Peaker> Eduard_Munteanu: no no -- leave the thread creation to the handler, separately
14:03:38 <Peaker> Eduard_Munteanu: this is meant to be a thin, exception-safe wrapper for "accept"
14:03:48 <Eduard_Munteanu> Peaker: I can't do that, otherwise closeSocket will run immediately and close the socket.
14:04:00 <Peaker> Eduard_Munteanu: oh, right :-)
14:04:12 <NikolajK> DR6__: would this be answered by knowing why there is exactly one function from {} to {1,2,3}
14:04:26 <Eduard_Munteanu> I would have used  bracket accept (async handler) close  if I could.
14:04:55 <monochrom> NikolajK: "Bar 1 2" is already most evaluated. it cannot be reduced further.
14:05:23 <DR6__> NikolajK: yes
14:05:27 <NikolajK> monochrom: so if I set up Foo like that, can I also put other terms in it?
14:05:40 <Peaker> Eduard_Munteanu: hmm.. I'll use lpaste, too long for a one-liner here
14:05:55 <monochrom> what is "put other terms in it"?
14:06:12 <DR6__> isn't there a function \_ -> c :: Void -> a for every element of a?
14:06:48 <Peaker> Eduard_Munteanu: http://lpaste.net/102630 ?
14:08:39 <startling> DR6__: nope.
14:08:48 <DR6__> why?
14:08:51 <monochrom> that may have caused an infinite loop :)
14:08:57 <startling> DR6__, think of the functions graph-wise rather than haskell-wise
14:09:03 <Peaker> Eduard_Munteanu: looking?
14:09:07 <startling> DR6__, what is the graph of \_ -> c :: Void -> a
14:09:08 <startling> ?
14:09:16 <DR6__> ... oh, so in Set it works
14:09:35 <Eduard_Munteanu> Peaker: yes... I'm unsure why I shouldn't use plain mask, that seems more sensible if the outer context is already masked.
14:09:38 <DR6__> I assume Hask interprets Void so that it works like that?
14:09:51 <DR6__> I already know bottoms break things in the Hask category
14:09:51 <startling> DR6__, not sure what you mean?
14:10:01 <Peaker> Eduard_Munteanu: because unmask is not valid across threads
14:10:08 <Eduard_Munteanu> Hm.
14:10:17 <Peaker> Eduard_Munteanu: and in a new thread, there's less/little reason to preserve masking of parent thread
14:10:34 <startling> Void is the empty type. all functions Void -> a are extensionally equal.
14:11:03 <DR6__> what does "extensionally equal" mean here?
14:11:19 <monochrom> well, then the sentence "for every c::a, (\_ -> c) :: Void -> a exists" is exactly right.
14:11:49 <startling> DR6__, "returns the same things when applied to the same arguments", I guess
14:11:55 <Eduard_Munteanu> DR6__: f is extensionally equal to g iff f x == g x for all x
14:12:04 <monochrom> they are not distinct. but they all exist, and they are one.
14:12:11 <DR6__> but then it doesn't work in haskell
14:12:18 <DR6__> or yes?
14:12:19 <startling> as opposed to syntactic equality.
14:12:21 <startling> DR6__: huh?
14:13:06 <corgifex> Peaker: if unmask is not valid across threads, that should really be mentioned in the docs
14:13:06 <DR6__> oh hold on
14:13:06 <benmachine> so yes, \_ -> c :: Void -> a exists for every c
14:13:06 <Peaker> Eduard_Munteanu: hmm.. I think I was wrong:  unmask is valid in a new thread -- the "unmask" passed to *WithUnmask is only valid in that thread
14:13:06 <DR6__> it's a vacuous truth right?
14:13:06 <corgifex> ah
14:13:06 <startling> DR6__, typicall Hask is not concerned with syntax
14:13:06 <benmachine> however there is only one function Void -> a
14:13:06 <startling> monochrom: does it exist?
14:13:06 <benmachine> these statements are not inconsistent
14:13:06 <startling> I guess so.
14:13:06 <DR6__> yes I wasn't talking about syntax either
14:13:06 <Eduard_Munteanu> Peaker: ah, so plain 'mask' would work.
14:13:06 <corgifex> semantically different, though
14:13:06 <Peaker> corgifex, Eduard_Munteanu: But in a new thread, "restore" the masking to whatever it was in parent thread may make less sense.. you might just want the new thread to be unmasked
14:13:10 <startling> DR6__, ok, so what's the difference between \_ -> a and \_ -> b ?
14:13:21 <Peaker> Eduard_Munteanu: if you're creating a new thread, might as well be unmasked in it, no?
14:13:34 <corgifex> 'zactly
14:13:37 <DR6__> they differ when applied to bottom
14:13:39 <Eduard_Munteanu> I would expect the same behavior as forkIO, which inherits the masked state.
14:13:49 <benmachine> DR6__: if you allow bottoms to be applied, then Void is not initial
14:13:57 <DR6__> ok
14:14:00 <benmachine> nor is () terminal, in fact
14:14:08 <Peaker> Eduard_Munteanu: hmm.. so probably a good idea to pass the "unmask" to the handler so it *can* unmask at all
14:14:44 <Peaker> Eduard_Munteanu: (or create "WithUnmask" function like forkIO and async both do)
14:14:54 <startling> benmachine: hm, how's that?
14:14:59 <benmachine> startling: which?
14:15:08 <startling> "if you allow bottoms to be applied, then Void is not initial"
14:15:12 <corgifex> hmm. mask return.
14:15:29 <benmachine> startling: by exactly DR6__'s observation
14:15:40 <startling> oh, right, because bottom is in Void
14:15:44 <benmachine> yep
14:15:49 <startling> good point.
14:15:58 <Eduard_Munteanu> I wonder if there's any reasonable way to salvage my MVar-based version. Probably not, there's way too much in there already.
14:16:19 <NikolajK> is there a way to create notation like "(,)", which tuples have?
14:16:26 <benmachine> actually if you allow bottoms then Void is terminal
14:16:40 <benmachine> if you allow bottoms but consider all bottoms to be the same
14:16:48 <benmachine> which is a common way of doing things
14:17:02 <Eduard_Munteanu> Thanks, I think I'll go with mask.
14:17:52 <corgifex> NikolajK: no
14:17:56 <startling> NikolajK: you want to define an operator named (,)? no.
14:18:17 <Eduard_Munteanu> I think he means (,,,)-like sectioning.
14:18:28 <Eduard_Munteanu> (The answer is still no.)
14:18:36 <monochrom> he never clarifies what he means.
14:19:02 <dart> hi
14:19:24 <NikolajK> I mean there is the possibility to write (1,2), but I don't know if I can make a type with terms jau 4, 5, 7 endmyjau
14:19:41 <NikolajK> which is formed from three ints like (4,5,7)
14:20:11 <Peaker> if we killed "seq", and had unlifted products, and thus didn't need any tuple but the 2-tuple, we could have (,) be a true data constructor operator, perhaps
14:20:39 <Peaker> I guess we'd still need the 0-tuple, but that's a separate data-type/constructor anyway
14:21:22 <NikolajK> since apearently not, I wonder if ( ) is primitive "primitive" to the semantics of the type system. It has the arrow type, but the sum type seems to be kinda faked only, and the product is also suspect to me a little
14:21:40 <Peaker> or maybe :, could be the data constructor, and (1,2,3)  could be (1 :, 2 :, 3 :, ()) and we could use HList-like stuff for ordinary tuples
14:21:44 <dart> i'm trying to understand what a Comonad is, does anyone have a intuitive metaphore ?
14:22:00 <corgifex> it's like a coburrito
14:22:29 <Peaker> dart: what would be an intuitive metaphore for Monad, for instance?
14:22:55 <NikolajK> the categorical definition? :P
14:23:17 <startling> dart, there's no intuitive definition; you just have to look at a bunch of comonads
14:23:38 <startling> NikolajK: what is "( )" ?
14:23:53 <NikolajK> the brackets from terms like (1,2,3)
14:23:59 <startling> > (1 + 2)
14:24:01 <lambdabot>  3
14:24:14 <NikolajK> I also don't know why they decided to make \times and the brackets the same symbol
14:24:28 <startling> NikolajK: what?
14:24:47 <NikolajK> startling: not sure where the problem lies here
14:24:50 <int-e> I suppose comonads are like ntainers. ;-)
14:25:09 <startling> NikolajK, you can define infix type constructor
14:25:10 <startling> s
14:25:17 <startling> NikolajK, but (->) and (,) are syntax.
14:25:28 <corgifex> type a :*: b = (a, b)
14:25:31 <startling> @quote edwardk (->)
14:25:31 <lambdabot> edwardk says: f -| g   means that   f a -> b is isomorphic to  a -> g b (for arrows in the appropriate categories)
14:25:39 <startling> @quote edwardk "(->) is syntax"
14:25:39 <lambdabot> No quotes match. Just try something else.
14:25:43 <startling> aw.
14:25:47 <stephenmac7> After about a year with haskell and half-using monads I feel like I finally understand them... after reading http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
14:26:00 <stephenmac7> I wish I had read that six months ago
14:26:09 <startling> stephenmac7: it is good.
14:27:43 <NikolajK> if I open a link like that (in adium), how do I get back without closing the window?
14:28:44 <startling> NikolajK, adium is kind of a bad irc client
14:28:54 <NikolajK> ic
14:30:04 <monochrom> startling: in @quotes x y, y is taking as a regex. (perhaps x is too, dunno). therefore, for example, if you add a " there, that " is taken literally.
14:30:13 <petrie> just use the client of the future :)
14:30:15 <monochrom> s/taking/taken/
14:30:36 <NikolajK> stephenmac7: the programmers blog/Q&A answers explaining monads confuse the hell out of me. I don't know yet how far removed Haskell monads are from category theory monads, but defining functors and natural transformations can be done in 3-4 pages and then monads have a straight forward definition in terms of them.
14:30:45 <monochrom> @quote edwardk is.syntax
14:30:45 <lambdabot> No quotes match. My brain just exploded
14:30:55 <monochrom> @quote is.syntax
14:30:55 <lambdabot> No quotes match. The more you drive -- the dumber you get.
14:31:45 <NikolajK> (and I mean in 3-4 pages where you start out without requirements on the user than but pattern maching and natural numbers)
14:31:48 <geekosaur> I don't understand the question about adium. it should be opening the url in your browser, so just switch apps?
14:32:36 <NikolajK> geekosaur: when I click, the current window with these chat lines goes away in favor of the link (inside adium). then I don't know how to get back
14:32:46 <monochrom> unless adium is right in the browser...
14:32:50 <startling> it isn't.
14:32:52 <geekosaur> it isn't
14:32:58 <monochrom> I see. my bad.
14:33:04 <startling> NikolajK, monads for programming have a different flavor than monads in the category-theoretic sense.
14:33:10 <startling> I think this is just adium being terrible.
14:33:16 <geekosaur> and whenever I've clicked a link in adium it opens my browser (which dependong on machine is safari or chrome)
14:33:33 <monochrom> ok, while we're at it, I am not getting the full speed promised by USB 3.0, any insight? :)
14:33:47 <startling> monochrom, buy better-quality devices
14:34:07 <monochrom> and my virus scanner takes forever to finish scanning!
14:35:31 <corgifex> haskell monads are type constructors with operations return/fmap/join
14:36:10 <bitemyapp> There are types that implement the monad typeclass which is return/join/bind
14:36:25 <corgifex> if you have bind, you don't need join
14:37:29 <NikolajK> and fmap
14:37:50 <bitemyapp> fmap isn't in Monad, it's in Functor. I realize liftM is identical, but there's no point confusing people.
14:38:30 <corgifex> bind isn't in Monad either
14:38:36 <corgifex> it doesn't even exist
14:38:46 <corgifex> fail is, though
14:38:58 <bitemyapp> bind doesn't even real. Brilliant insight, that.
14:39:07 <akurilin> Quick question: is it completely quixotic of me to try to use Haskell like a ruby script? I want to run a quick script on a few .json files as part of our asset build pipeline and I'd love to write that in Haskell rather than ruby, but now I just don't know
14:39:21 <bitemyapp> akurilin: does it need to be a script?
14:39:23 <akurilin> if I can sanely make sure this will run without too much hassle on various machines and OS
14:39:26 <bitemyapp> akurilin: can you just make a binary?
14:39:37 <bitemyapp> akurilin: because if you're parsing JSON you need librar(y|ies)
14:39:40 <geekosaur> what's wrong with runhaskell?
14:39:52 <corgifex> requires ghc to be installed
14:39:53 * hackagebot rehoo 0.3.1 - Rebuild default.hoo from many .hoo files in the current directory  http://hackage.haskell.org/package/rehoo-0.3.1 (JohnWiegley)
14:40:01 <bitemyapp> geekosaur: nothing, except for the part where he needs ghc, http-conduit, and Aeson.
14:40:13 <bitemyapp> I'd say deploy a binary. Shouldn't be any more time-consuming. less even.
14:40:20 <akurilin> so if this needs to work on osx and ubuntu, I'd have to have two binaries, no?
14:40:35 <bitemyapp> akurilin: unless you've devised an emulation layer, yes.
14:40:37 <corgifex> at minimum
14:40:42 <monochrom> I don't think "script" and "not script" is an important distinction.
14:40:46 <bitemyapp> corgifex: at pessimum
14:40:53 <pyon> Is there any way to control how other modules can use data constructors? Sometimes, I want other modules to be able to perform pattern-matching, but not to be able to use constructors for... well... constructing.
14:41:06 <corgifex> bitemyapp: what if there are different architectures involved?
14:41:10 <monochrom> the question "can I write a Haskell program to replace a Ruby program" has the answer "yes".
14:41:14 <bitemyapp> corgifex: loldontcare
14:41:25 <corgifex> bitemyapp: huh?
14:41:32 <bitemyapp> akurilin: having random bits of infrastructure like that be typed is pretty nice.
14:41:44 <akurilin> so the answer is yes -> make a few binaries?
14:41:52 <bitemyapp> akurilin: yes
14:42:21 <corgifex> pyon: do you happen to have ghc 7.8?
14:42:28 <pyon> corgifex: Yes.
14:42:36 <pyon> corgifex: Well, right now I am compiling GHC 7.8.2.
14:42:44 <pyon> With GHC 7.8.1.
14:42:48 <corgifex> what a coincidence. have I got a language extension for you!
14:42:58 <corgifex> pattern Foo <- Bar
14:43:06 <akurilin> on that note, what's the easiest way of setting up everything I need to build haskell on OSX? I don't own OSX myself, my coworker does, and he has very low patience for environments that take hours to set up
14:43:13 <pyon> corgifex: What's it do?
14:43:19 <akurilin> (aka something like rbenv if you've never done it before)
14:43:31 <geekosaur> akurilin, given the xcode 5 nonsense the right answer there is wait a month, I think
14:43:32 <pyon> corgifex: Or, rather, how is the extension called so I can read the user manual?
14:43:44 <NikolajK> since I've seen it in this discussion: do people actually use hom-set adjunctions in coding?
14:43:44 <pyon> read about* it*
14:43:45 <corgifex> pyon: http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/syntax-extns.html#pattern-synonyms
14:43:50 <monochrom> oh 7.8.2 already! \∩/
14:43:59 <jmcarthur> yup
14:44:02 <jmcarthur> it's released already
14:44:07 <johnw> yeah, 7.8.1 broke type checking for a few packages
14:44:09 <joelteon> good job ghc team
14:44:12 <bitemyapp> akurilin: You've got a couple options. I have one option that worked reasonably well for me on my mac, but if I say it out loud here, people will get grumpy.
14:44:12 <pyon> corgifex: Thank you. :-)
14:44:23 <geekosaur> (since the new haskell platform should be out by then, based on ghc 7.8 so the xcode 5 hackery won't be needed any more)
14:44:38 <bitemyapp> akurilin: the recommended/purist way is to download a GHC binary for Mac OS X and ./bootstrap.sh 7.6.3 or 7.8.2
14:44:47 <monochrom> yes, right here a few days ago I learned about that bug and that 7.8.2 was imminent for it. glad to see that it happens.
14:44:52 <akurilin> ok got it, I'll just run the tool on linux for now and check in with you guys a month later
14:45:07 * geekosaur used macports, no problem but nobody wants to here about that, they want the messes homebrew's ghc stuff kept getting in to (no idea if it's even fixed yet)
14:45:16 <akurilin> speaking of which, I have whatever previous version of ghc on linux, is there a magical auto-upgrade flow I can use?
14:45:30 <bitemyapp> akurilin: I used the homebrew install of ghc quite happily until I moved to 7.8
14:45:40 <johnw> geekosaur: I'm moving my Haskell development on the Mac over to Nix
14:45:44 <bitemyapp> akurilin: but the homebrew version isn't perfect if you're doing deeper things with Haskell.
14:45:52 <bitemyapp> akurilin: 99% of the time it just won't matter.
14:45:58 <akurilin> bitemyapp: roger that
14:46:07 <startling> what problems did you guys have with brew and 7.8?
14:46:18 <startling> (I haven't had any).
14:46:30 <akurilin> Is #haskell platform-war-friendly?
14:46:32 <akurilin> I kid :P
14:46:57 <corgifex> pyon: for a more conservative approach, see viewl/viewr from Data.Sequence
14:47:07 <akurilin> Again, is there a self-update option anywhere with ghc so I can go from 7.6.3 to the new one?
14:47:18 <akurilin> I have no recollection of how I installed it the first time
14:47:35 <startling> akurilin, no.
14:47:38 <bitemyapp> akurilin: GHC is just a compiler + packaging.
14:47:44 <monochrom> Apple IIe is the best platform ever
14:47:46 <bitemyapp> akurilin: cabal is a separate tool even.
14:47:56 <akurilin> I think I used whatever default 12.04 package and then cabal did some magic, maybe?
14:48:02 <monochrom> 128KB ought to be enough for GHC's stack :)
14:48:14 <corgifex> more like snack
14:48:16 <bitemyapp> akurilin: you can use your current compiler to bootstrap 7.8.2 if you feel like upgrading.
14:48:19 <corgifex> om nom nom gone
14:48:24 <akurilin> bitemyapp: yes, that
14:48:29 <monochrom> you win :)
14:48:36 <akurilin> bitemyapp: cabal also updates itself, oui?
14:48:40 <DR6__> which program holds the installed packages: ghc or cabal?
14:48:45 <kadoban> akurilin: If you're like me, you're stuck on some hugely old crap that 12.04 came with.  Been too lazy to figure out how to upgrade, it wasn't too smooth the last time I tried.
14:49:07 <monochrom> ghc holds the installed packages. cabal is just a store front receptionist
14:49:21 <bitemyapp> akurilin: sorta. it won't replace a separately installed copy of the Cabal binary, but it can compile the latest one which you can then symlink into your path and use.
14:49:28 <akurilin> kadoban: honestly I don't recall having any trouble, but then I might have gotten lucky. I don't remember building from source either.
14:49:35 <bitemyapp> monochrom: good way of putting it.
14:50:15 <bitemyapp> akurilin: if you run `cabal install cabal-install` it'll probably plant that in ~/.cabal/bin/ which you can add to your path or symlink.
14:50:30 <kadoban> akurilin: Yeah, I should probably bite the bullet at some point, I think I just ran into errors last time and didn't bother figuring it out :/
14:50:35 <pyon> corgifex: Whoa, these pattern synonyms are perfect! Thank you!
14:50:51 <startling> akurilin, cabal shouldn't hurt anything wrt upgrading
14:50:53 <bitemyapp> akurilin: so you could end up having multiple cabals floating around, /usr/bin:/usr/local/bin:/usr/local/Cellar/* in addition to ~/.cabal/bin
14:52:39 <corgifex> hmm, not quite
14:52:50 <corgifex> it's not transparent to users
14:53:48 <pyon> corgifex: Well, it seems to me that, with unidirectional patterns, I can allow users to destructure values but not construct new ones, which is exactly what I need.
14:54:17 <corgifex> I'm talking about import lists
14:54:30 <pyon> Oh.
14:54:39 <pyon> Do patterns have to be explicitly imported? :-O
14:54:50 <corgifex> no
14:54:58 <corgifex> but they can be
14:55:43 <petrie> what does this error mean? Occurs check: cannot construct the infinite type: a0 = [a0]
14:55:54 <pyon> corgifex: The only issue I can see is that there is no way to guarantee pattern synonyms are exhaustive.
14:56:27 <geekosaur> petrie, you have a type which you are trying to use simultaneously as a list and as an item in that list, usually
14:56:34 <corgifex> petrie: it means you tried to make a list that contained itself as an element
14:56:51 <akurilin> bitemyapp: ah yeah that's very possible
14:56:53 <petrie> hmm :\
14:57:09 <monochrom> one way to cause this error is: f x = f [x]
14:57:47 <petrie> I dont see how I am doing that
14:57:53 <petrie> http://lpaste.net/905085678126104576
14:58:05 <monochrom> sure, real cases are more subtle than toy examples
14:58:09 <geekosaur> one way I often see it is you have some multi-case recursive function, without a type signature (sot it's trying to infer it), and one of the cases returns a list and another an item
14:58:11 <ticktockman> Are there any good libraries for playing audio files?
14:58:20 <corgifex> petrie: what's the error message?
14:58:29 <petrie>     Occurs check: cannot construct the infinite type: a0 = [a0]
14:58:30 <petrie>     Expected type: [[a0]]
14:58:30 <petrie>       Actual type: [a0]
14:58:37 <corgifex> go on
14:58:43 <geekosaur> it's that ++ 0 ++, I think
14:58:43 <petrie>     In the second argument of `(++)', namely `xs'
14:58:43 <benmachine> petrie: you concatenate zs and makeRow, so you expect them to be the same type
14:58:43 <petrie>     In the expression: zs ++ xs
14:58:44 <petrie>     In an equation for `newBoard': newBoard = zs ++ x
14:58:46 <startling> :t splitAt
14:58:47 <lambdabot> Int -> [a] -> ([a], [a])
14:58:48 <monochrom> what is the meaning of "xs ++ 0"?
14:58:50 <geekosaur> sure that's not ++ [0] ++ ?
14:59:34 <startling> oh, I see, it's a list-of-lists
14:59:35 <petrie> well basically i have this list [[0],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]] and I am trying to replace one of the 1's to a 0
14:59:36 <benmachine> petrie: but zs is the same type as board, because it's an initial segment of board
14:59:46 <petrie> and return the new list
14:59:51 <monochrom> is "board !! c" a list? is it of the right type?
14:59:52 <corgifex> petrie: that code doesn't contain newBoard = zs ++ xs
14:59:59 <startling> monochrom: yeah, I think it is.
15:00:11 <Renderwahn> i'm trying to use aeson to parse a simple nested json object but all i get is Nothing, http://codepad.org/GWV8RAnw
15:00:16 <Renderwahn> and i have no idea how to debug it
15:00:22 <benmachine> petrie: it will help if you try to work out the exact types of all the lists involved
15:00:27 <monochrom> since the paste is not self-containing, I cannot infer types
15:00:59 <petrie> hmm, ill post full source so far sorry
15:01:21 <caseof> I have this type: TVar (Map k (TVar v)) I have a function f :: TVar (Map k (TVar v)) -> k -> v -> STM v   that accesses both TVars. Am i absolutely sure access will be atomic across both TVars?
15:01:23 <petrie> http://lpaste.net/1103000936516681728
15:01:23 <akurilin> Random question: what's up with the !Text syntax? As seen here: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json
15:01:24 <startling> monochrom, what if I have you a paste of all the pastes that are not self-containing?
15:01:25 <geekosaur> petrie: the reason I focused on the ++ 0 ++ is that (++) requires two lists
15:01:28 <geekosaur> not a list and an item
15:01:42 <geekosaur> 0 is not a list unless you have a seriously weird Num instance in scope somewhere
15:01:45 <startling> akurilin: it makes the whole structure strict on that element
15:01:56 <petrie> I was trying to add that element between the lists
15:01:57 <corgifex> caseof: yes
15:01:59 <monochrom> then I will die of reading too much code
15:02:06 <geekosaur> yes, and?
15:02:11 <geekosaur> ++ does not add *items*
15:02:12 <startling> monochrom: but will you be able to infer the types? :)
15:02:13 <benmachine> Renderwahn: looks to me like your code expects a thing with a field foo that is a thing with a field bar
15:02:17 <geekosaur> it combines *lists*
15:02:22 <benmachine> Renderwahn: but that's not what you have, your field foo has fields x and y
15:02:23 <akurilin> startling: Meaning? Not sure I get it.
15:02:25 <monochrom> I guess I can say, "I'll die trying"
15:02:33 <petrie> hmm
15:02:34 <Renderwahn> hmm
15:02:37 <geekosaur> if you want to use it to add an item, you must give it a *list* containing the item
15:02:41 <caseof> corgifex: Ok, thanks. Wasn't sure that worked for hierarchical TVars like that.
15:02:52 <petrie> Ah so thats why you said [0]
15:02:55 <geekosaur> yes
15:03:02 <startling> akurilin, data X = X !Char !Int -- if an X is ever evaluated, its Char and Int members are also evaluated
15:03:18 <corgifex> caseof: anything within a single runSTM is atomic, which is why there is no runSTM and it's actually called 'atomically'
15:03:25 <startling> akurilin: does that make sense?
15:03:34 <corgifex> also, 'atomically' is the only way to run a combined STM action
15:03:58 <startling> akurilin: whearas with data Y = Y Char Int, a Y can be evaluated without that Char and that Int ever being evaluated
15:04:28 <startling> e.g. with "\(Y _ _) -> ..."
15:04:46 <Renderwahn> benmachine: i thought it's foo is an object with any number of fields of any name of type Nested
15:05:22 <startling> akurilin: it amounts to better performance in many (but not all) cases
15:05:26 <benmachine> Renderwahn: it's possible that my understanding of aeson is wrong, it's been a while since I used it
15:05:34 <int-e> Renderwahn: shouldn't the type of the "nested" field be just Int rather than a map?
15:06:20 <benmachine> Renderwahn: however if I wanted to debug this, I would try replacing the inner field with an Object, so that it always decodes, then seeing what object I get and how I can parse that
15:06:36 <benmachine> Renderwahn: basically first isolate which bit of the code fails and then work out how to make it succeed instead
15:06:38 <int-e> Renderwahn: unpacking your type, we now have that Test is isomorphic to  Map String (Map String Int), while the json seems to encode a Map String Int, with some indirections (the "foo" and "bar" labels).
15:06:48 <akurilin> startling: Oh interesting, doesn't matter where the underlying type is lazy or strict, correct?
15:07:03 <startling> akurilin: which "underlying type"?
15:07:16 <Renderwahn> benmachine: the object thing is a good idea
15:07:18 <akurilin> startling: well say I could choose between strict and lazy bytestring
15:07:24 <startling> akurilin: right.
15:07:44 <startling> akurilin: a strict bytestring is a bytestring that if any part of it is evaluated the whole is evaluated
15:07:50 <benmachine> int-e: I don't understand; it looks to /me/ like the JSON given encodes a Map String (Map String (Map String Int))
15:07:57 <akurilin> startling: I'd still want the ! even if the bytestring was strict, yes?
15:08:06 <startling> whereas a lazy bytestring might be partially evaluated.
15:08:16 <startling> akurilin, ! on a lazy bytestring doesn't mean very much
15:08:20 <Renderwahn> hmm, making test :: Map String Object still produces nothing
15:08:24 <benmachine> int-e: I suppose it depends on what you think the role of foo or bar is
15:08:28 <Renderwahn> benmachine: that was my intention
15:08:31 <int-e> benmachine: There are two views of {"a":x, "b":y} in JSON, one is a map with keys "a" and "b"; the other is a record with fields names "a" and "b".
15:08:41 <int-e> *named
15:08:47 <benmachine> int-e: right
15:09:04 <int-e> benmachine: I'm guessing from the code that "foo" and "bar" are field names.
15:09:41 <corgifex> @let data Pair' a b = P !a !b deriving (Eq, Ord, Read, Show)
15:09:42 <lambdabot>  Defined.
15:09:56 * hackagebot cookbook 2.2.1.0 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.2.1.0 (NatePisarski)
15:10:10 <corgifex> > case (,) undefined "hi" of (,) _ x -> x
15:10:11 <lambdabot>  "hi"
15:10:20 <corgifex> > case P undefined "hi" of P _ x -> x
15:10:21 <lambdabot>  "*Exception: Prelude.undefined
15:10:25 <akurilin> startling: so I guess if say I'm doing some aeson parsing and I might not even use some text fields in the type I'm decoding to, ! might actually make things slower, right?
15:10:38 <startling> akurilin: it's possible.
15:10:50 <startling> I don't know enough about anything to say with any certainty.
15:10:54 <Renderwahn> benmachine: ah, doing it properly i get Just (Test {test = fromList [("x",fromList [("bar",Number 1)]),("y",fromList [("bar",Number 2)])]})
15:11:05 <benmachine> Renderwahn: sounds like progress
15:11:20 <startling> akurilin: if it were not Text it'd be more likely, I think
15:11:43 <startling> akurilin, (since Texts can easily be smaller than the computations that produce them)
15:12:00 <benmachine> Renderwahn: what is the result that you actually want?
15:12:18 <startling> akurilin: you should benchmark if you're worried about it.
15:12:49 <startling> akurilin: the typical length of the Text probably has an effect.
15:12:59 <akurilin> I'm not, I'm just trying to understand the reasoning behind that being in the sample code
15:13:24 <startling> some people think you should use ! unless you know you want otherwise.
15:13:32 <startling> This is a somewhat controversial position.
15:14:00 <startling> I tend not to worry about performance until I need to, so I don't bother.
15:14:23 <startling> (and I don't often need to).
15:14:59 <Renderwahn> benmachine: Test {test = fromList [("x",Nested{nested = 1}),("y",Nested{nested= 2})])]})
15:15:05 <Renderwahn> if that is even valid syntax
15:16:02 <bennofs> Wow, GHC 7.8.2 got -XNegativeLiterals!
15:16:26 <benmachine> neat
15:16:41 * benmachine would have also liked -XNoPrefixNegation, perhaps
15:16:42 <bennofs> Now we can finally write 3 + -4  :)
15:17:04 <bennofs> I wonder why 3--4 is 3 though ...
15:17:19 <startling> > 3 -- 4
15:17:19 <bennofs> Anyone know how GHC could arrive at 3 for 3--4 ?
15:17:20 <lambdabot>  3
15:17:24 <corgifex> no comment
15:17:28 <startling> wow.
15:17:29 <bennofs> ah :D
15:17:40 <benmachine> corgifex: iswydt
15:17:47 <startling> oh, heh
15:17:54 <startling> > 3 - - 4
15:17:56 <lambdabot>  Precedence parsing error
15:17:56 <lambdabot>      cannot mix ‘GHC.Num.-’ [infixl 6] and prefix `-' [infixl 6] in the same ...
15:18:06 <bennofs> > 3 - -4
15:18:07 <lambdabot>  Precedence parsing error
15:18:07 <lambdabot>      cannot mix ‘GHC.Num.-’ [infixl 6] and prefix `-' [infixl 6] in the same ...
15:18:14 <bennofs> lambdabot doesn't have it enabled :|
15:18:53 <benmachine> Renderwahn: so, I guess what you want to do is not v .: "bar" but rather to do .: "bar" to each value inside v?
15:19:46 <benmachine> Renderwahn: I suggest Test have type Map String (Map String Nested), and then Nested have type Int
15:19:57 <benmachine> Renderwahn: i.e. move one Map String from Nested to Tes
15:19:59 <benmachine> *Test
15:20:17 <Renderwahn> *headdesk* benmachine int-e, yes, the Map in Nested is wrong
15:20:51 <Renderwahn> now lets see if this is the same problem in the code from which the testcase was derived
15:21:05 <Renderwahn> thanks for the help
15:22:47 <int-e> Ok, I'm happy; what I suggested works, i.e., changing  nested :: Map String Int  to  nested :: Int.
15:23:29 <pyon> So, what exactly was the problem with GHC 7.8.1, that required a quick fix?
15:23:30 <int-e> (I had to compile aeson to see it for myself, sorry for being redundant now.)
15:23:48 <int-e> pyon: https://ghc.haskell.org/trac/ghc/ticket/8978
15:24:03 <pyon> int-e: Thanks. :-)
15:24:05 <corgifex> http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/release-7-8-2.html
15:24:33 <benmachine> int-e: oh, I think I just worked out what you were talking about
15:24:38 <benmachine> int-e: I think you were probably right :P
15:24:51 * benmachine is the slowest to this realisation
15:26:13 <Renderwahn> hurray, it works \o/
15:26:32 <Renderwahn> the idea with chinging stuff to Object was very helpful
15:39:59 * hackagebot purescript 0.4.18 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.18 (PhilFreeman)
15:41:09 <kgadek> hi. could anybody help me… well, trying to learn Arrows. I want to make `map fst . filter (foo.fst) . filter (bar.snd) . map (\c -> (c, f c))` a bit prettier. How could filtering like here be accomplished?
15:41:26 <kgadek> (articles/tutorials/hints are welcome)
15:42:26 <corgifex> filter (\c -> foo c && bar (f c))
15:44:24 <Welkin> is there a way to update ghc in haskell-platform?
15:44:45 <Welkin> I'm stuck on 7.4.1
15:45:57 <startling> Welkin: what operating system are you on? (Ubuntu 12.something, I suspect?)
15:46:10 <Welkin> ubuntu 12.4 lts
15:46:41 <startling> Welkin: yeah, 12.4 doesn't have any newer ghcs (the haskell platform part is irrelevant). You may want to install from source or find a deb somewhere
15:50:04 <jmcarthur> kgadek:    filter . liftA2 (&&) foo $ bar . f
15:51:01 <corgifex> @unpl filter . liftA2 (&&) foo $ bar . f
15:51:02 <lambdabot> (filter (liftA2 (&&) foo (\ i -> bar (f i))))
15:51:16 <gtrambly> will anything break if a datatype is defined whereby there exist x and y such that x <= y and y <= x but x /= y? say... a two dimensional vector, only one dimension of which is actually compared
15:51:21 <kgadek> wow. okay, thanks guys, just give me a moment to understand what's happening there… :D
15:51:36 <gtrambly> in haskell, not mathematics <_<
15:52:43 <Welkin> gtrambly, that makes no sense
15:52:53 <jmcarthur> gtrambly: yes, i do think that can break a lot of common assumptions about the relationship between Ord and Eq
15:52:54 <kadoban> gtrambly: I'm not sure, but it seems likely.  I'd avoid doing that, regardless of language.
15:53:14 <gtrambly> hm, ok thanks
15:53:21 <jmcarthur> gtrambly: for example, i think that would break Data.Map and Data.Set
15:53:28 <gtrambly> ew
15:53:36 <jmcarthur> or is at least highly likely to
15:53:39 <startling> would it?
15:54:00 * geekosaur points to floating point...
15:54:01 <jmcarthur> it only wouldn't if it doesn't use (==), i think
15:54:22 * startling floats
15:54:39 <corgifex> > let nan = 0/0 in nan `S.elem` S.singleton nan
15:54:40 <lambdabot>  Not in scope: ‘S.elem’
15:54:40 <lambdabot>  Perhaps you meant one of these:
15:54:40 <lambdabot>    ‘F.elem’ (imported from Data.Foldable),
15:54:40 <lambdabot>    ‘BS.elem’ (imported from Data.ByteString),
15:54:40 <lambdabot>    ‘S.elems’ (imported from Data.Set)
15:54:42 <jmcarthur> huh
15:54:46 <jmcarthur> it works
15:55:02 <jmcarthur> > M.lookup (1/0) $ M.insert (1/0) "foo" M.empty
15:55:04 <lambdabot>  Just "foo"
15:55:05 <corgifex> > let nan = 0/0 in nan `S.member` S.singleton nan
15:55:07 <lambdabot>  False
15:55:19 <startling> it might degrade performance.
15:55:19 <jmcarthur> > M.member (1/0) $ M.insert (1/0) "foo" M.empty
15:55:21 <lambdabot>  True
15:55:29 <corgifex> > let nan = 0/0 in S.elems (S.singleton nan)
15:55:30 <lambdabot>  [NaN]
15:55:56 <jmcarthur> oh
15:56:00 <jmcarthur> i didn't use nan
15:56:06 <jmcarthur> > M.lookup (0/0) $ M.insert (0/0) "foo" M.empty
15:56:08 <lambdabot>  Nothing
15:56:09 <jmcarthur> there
15:56:12 <jmcarthur> breakage
15:56:12 <kadoban> Isn't it obvious that a single element would work?  I would think the fun would happen when you start doing more interesting things.
15:56:17 <corgifex> > let nan = 0/0 in compare nan nan
15:56:19 <lambdabot>  GT
15:56:23 <benmachine> it's really nan that ruins things, ±inf mostly make sense
15:56:26 <startling> hm, interesting
15:56:36 <jmcarthur> > S.fromList [0/0,0/0,0/0]
15:56:38 <lambdabot>  fromList [NaN,NaN,NaN]
15:56:40 <jmcarthur> heh
15:56:50 <gtrambly> why would 1/0 work but not 0/0? i can't see either being defined
15:56:55 <jmcarthur> > 1/0
15:56:56 <lambdabot>  Infinity
15:56:57 <jmcarthur> ^^ infinity
15:57:01 <gtrambly> ????
15:57:02 <corgifex> gtrambly: both are defined
15:57:03 <gtrambly> that's disgusting
15:57:06 <gtrambly> that's not infinity
15:57:09 <benmachine> gtrambly: that's floating point
15:57:10 <jmcarthur> Infinity actually has meaningful Ord semantics
15:57:10 <gtrambly> wtf
15:57:16 <gtrambly> wtf wtf
15:57:20 <corgifex> welcom2math
15:57:22 <benmachine> nono
15:57:25 <benmachine> welcom2engineering
15:57:28 <gtrambly> what mathematician signed off on this
15:57:30 <akurilin> Does anybody know how to extract more information from aeson about what exactly failed to decode? I'm using eitherDecodeStrict and it's giving me an error message, except doesn't tell me at all which field it's related to
15:57:32 <benmachine> mathematicians wouldn't go anywhere near this :P
15:57:37 <benmachine> gtrambly: see IEEE
15:57:41 <jmcarthur> Infinity and -Infinity are nowhere near as annoying as NaN, though
15:57:48 <corgifex> the one who extended the reals with +/-Inf
15:57:57 <jmcarthur> who says floats are reals?
15:58:18 <benmachine> (no-one tell gtrambly about negative zero)
15:58:24 <jmcarthur> :)
15:58:32 <jmcarthur> > -0 :: Double
15:58:33 <lambdabot>  -0.0
15:58:41 <gtrambly> ew ew ew
15:58:41 <monochrom> I disagree. Mathematicians have "extended real numbers" and "two-point compactification of the real numbers" (same thing) which has +infinity and -infinity in exactly the natural way. look them up.
15:58:43 <jmcarthur> > (-0 :: Double) == 0
15:58:45 <lambdabot>  True
15:58:48 <jmcarthur> :D
15:59:02 <benmachine> monochrom: I'm aware of both of them
15:59:04 <jmcarthur> > (-0 :: Double) < 0
15:59:05 <lambdabot>  False
15:59:19 <monochrom> good, benmachine, then I am not complaining to you.
15:59:20 <Welkin> > -0 == 0
15:59:22 <lambdabot>  True
15:59:35 <benmachine> monochrom: oh, I thought it was exactly my comment you were disagreeing with
15:59:39 <CaptainK> > -0 /= 0
15:59:40 <jmcarthur> > 1 / (-0)
15:59:41 <lambdabot>  False
15:59:42 <lambdabot>  can't find file: L.hs
15:59:45 <gtrambly> yes, but even on extended real numbers you don't equate infinity and 1/0
15:59:46 <gtrambly> <_<
15:59:54 <jmcarthur> > 1 / negate 0
15:59:55 <lambdabot>  -Infinity
15:59:56 <corgifex> gtrambly: yes, I do
15:59:58 <jmcarthur> > 1 / negate 0
15:59:59 <lambdabot>  -Infinity
16:00:00 <jmcarthur> oops
16:00:01 <startling> I wonder how complex numbers work with this.
16:00:02 * hackagebot syb-with-class 0.6.1.5 - Scrap Your Boilerplate With Class  http://hackage.haskell.org/package/syb-with-class-0.6.1.5 (AndreaVezzosi)
16:00:02 <jmcarthur> > 1 / 0
16:00:03 <lambdabot>  Infinity
16:00:21 <benmachine> startling: there's a lot to be said for a one-point compactification of the complex numbers
16:00:26 <benmachine> so you just have one infinity, without any sign
16:00:32 <benmachine> see also: Riemann sphere
16:00:41 <jmcarthur> gtrambly: it's really just a way of doing something as reasonable as possible instead of truncating or overflowing
16:00:49 <corgifex> > let foo x y = (x == y, show x == show y) in [foo 0 (-0), foo 0 (-0.0)]
16:00:51 <lambdabot>  [(True,True),(True,False)]
16:00:58 <jmcarthur> gtrambly: all the woes of floating point numbers stem from limited bits
16:00:59 <geekosaur> when you say complex numbers, do you men the polar or rectangular form?
16:01:06 <monochrom> in complex analysis, "in a neighbourhood of infinity" is common and makes sense.
16:01:09 <CaptainK> > -1 / 0
16:01:11 <lambdabot>  -Infinity
16:01:38 <gtrambly> 1 / (-0)
16:01:42 <gtrambly> > 1 / (-0)
16:01:43 <lambdabot>  -Infinity
16:01:51 <jmcarthur> I think my new favority discovery of the day is that you can have a multiset of NaNs using Data.Set.
16:01:52 <gtrambly> > (-1) / (-0)
16:01:54 <lambdabot>  Infinity
16:01:56 <gtrambly> : (
16:02:01 <gtrambly> : ((((((
16:02:08 <benmachine> jmcarthur: in what way
16:02:16 <jmcarthur> > S.fromList [0/0,0/0,0/0]
16:02:17 <lambdabot>  fromList [NaN,NaN,NaN]
16:02:44 <jmcarthur> benmachine: denotationally it's neither a multiset nor a set, though...
16:02:45 <monochrom> oh!!! complex numbers and rectangular vs polar. I have a paper to recommend to you on this! it's Reynolds's "types, abstraction and parametric polymorphism". it opens with exactly that subject.
16:03:01 <jmcarthur> > S.member (0/0) $ S.fromList [0/0,0/0,0/0]
16:03:03 <lambdabot>  False
16:03:05 <benmachine> > S.delete (0/0) (S.fromList [0/0])
16:03:07 <lambdabot>  fromList [NaN]
16:03:31 <jmcarthur> it's a set of Doubles that also tells you how many times you have ever inserted NaN
16:03:38 <benmachine> heh
16:03:38 <startling> benmachine: haha
16:03:59 <startling> (Set Double, Nat)?
16:04:30 <benmachine> > S.filter (join (==)) (S.fromList [-1, 0/0, 1])
16:04:32 <lambdabot>  fromList [-1.0,1.0]
16:04:32 <jmcarthur> (Set DoubleWithoutNaN, Nat)
16:04:40 <geekosaur> (it's a natcase)
16:05:04 <ezrios> (++ " Batman!") . intercalate " " . Prelude.map show . replicate 16 $ 0/0
16:05:06 <jmcarthur> benmachine: nice
16:05:06 <ezrios> > (++ " Batman!") . intercalate " " . Prelude.map show . replicate 16 $ 0/0
16:05:08 <lambdabot>  "NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN Batman!"
16:05:10 <corgifex> > S.fromList "random set"
16:05:12 <lambdabot>  fromList " ademnorst"
16:05:28 <corgifex> > S.fromList [1, -1, 0, 1/0, -1/0, 0/0]
16:05:29 <startling> wow, surprised it prints as a string
16:05:30 <lambdabot>  fromList [-Infinity,-1.0,0.0,1.0,Infinity,NaN]
16:05:35 <gtrambly> i really have to disagree on the link with mathematics that people are trying to assert though. it really doesn't work like that.
16:05:46 <startling> ?
16:05:47 <benmachine> jmcarthur: I worry a bit also about what would happen if you had a 0/0 at the root of your tree, I wonder if you could get things inserted in the wrong branches
16:06:08 <gtrambly> extending R with + and - infinity is just a convenient way of expressing limit notation without having to do so explicitly
16:06:24 <startling> greymalkin, no, you can actually extend R with + and - infinity.
16:06:29 <benmachine> gtrambly: so, there's a few perspectives on this
16:06:42 <startling> er,gtrambly ^
16:06:48 <jmcarthur> > S.insert 1 $ S.singleton (0/0)
16:06:50 <lambdabot>  fromList [NaN,1.0]
16:06:50 <gtrambly> and there are so many ways for 0 / h(x) to tend x -> infty that don't give infty
16:06:53 <jmcarthur> > S.insert (-1) $ S.singleton (0/0)
16:06:54 <lambdabot>  fromList [NaN,-1.0]
16:07:05 <benmachine> gtrambly: one would be, don't take the terms quite literally, in the sense that infinity is really just "too big to represent" and -0 is just "too small to represent"
16:07:08 <gtrambly> let alone breaking symmetry on the division by picking one infinity or the other? (???)
16:07:23 <jmcarthur> > compare (0/0) 0
16:07:24 <lambdabot>  GT
16:07:26 <jmcarthur> > compare (0/0) 1
16:07:28 <lambdabot>  GT
16:07:31 <benmachine> gtrambly: wait a sec, no-one said 0/0 is infinity
16:07:33 <startling> gtrambly: I think you are confused
16:07:39 <gtrambly> pardon
16:07:52 <gtrambly> 1/h(x)
16:07:55 <jmcarthur> gtrambly: in floating point, Infinity just means "too big for me to represent"
16:08:13 <jmcarthur> gtrambly: or "error"
16:08:17 <startling> gtrambly, floats are specified by ieee
16:08:19 <jmcarthur> gtrambly: up for interpretation
16:09:39 <benmachine> startling: p.s. wrt extending R with ±inf, I guess there are a few ways to do it, each inadequate in its own individual way?
16:09:46 <corgifex> > S.fromList [1, 0/0, 1]
16:09:48 <lambdabot>  fromList [1.0,NaN,1.0]
16:09:58 <startling> benmachine: yeah, but that doesn't mean you *can't*
16:10:11 <benmachine> startling: really depends on your criterion for success :P
16:10:19 <corgifex> > S.fromList [1, 0/0, 1, 0/0, 1]
16:10:20 <lambdabot>  fromList [1.0,NaN,1.0,NaN,1.0]
16:10:24 <corgifex> multipass
16:10:25 <gtrambly> there is a single extremely rigorous way of extending R with +-inf
16:10:25 <benmachine> startling: I can define an additive structure on {0, 1, banana}, doesn't mean I've done anything that *means* anything
16:10:30 <gtrambly> no interpretation
16:10:35 <gtrambly> at all
16:10:51 <gtrambly> especially not how it's done here
16:10:52 <benmachine> gtrambly: on what basis do you make the assertion that there are no alternatives?
16:10:53 <jle`> all of math is arbitrary definitions so.....
16:11:05 <startling> gtrambly, "done here" is just the ieee float specification
16:11:12 <benmachine> jle`: wrong in several distinct ways :P
16:11:13 <startling> it's not something we have decided on.
16:11:22 <benmachine> startling: we have chosen to follow IEEE, to be fair
16:11:23 <jle`> ieee float is an engineering feat, not a mathematical feat
16:11:27 <benmachine> we didn't need to do that
16:11:31 <startling> benmachine: heh, true !
16:11:35 <jle`> it's meant for convenient engineering
16:11:41 <benmachine> of course when I say "we" I don't mean any of actual *us*
16:11:42 <gtrambly> because any mathematician understands what \overline{R} means
16:11:43 <benmachine> other people :P
16:11:44 <jle`> not meaningful maths :)
16:11:50 <geekosaur> but seeing as how most CPUs follow IEEE FP, it's kinda dumb to not follow it
16:11:58 <jmcarthur> gtrambly: i can define any axioms i want, and even call the system "rigorous" as long as I handle them consistently. you're not really making a mathematical argument here, but just stating an opinion about this particular system.
16:11:58 <benmachine> gtrambly: sure, it means C
16:12:01 <gtrambly> they don't need to disambiguate
16:12:06 <benmachine> gtrambly: oh wait, not algebraic closure? :P
16:12:07 <d1av_g3p> Is it accurate to say that    (==) is inextricably linked to the Eq type class, so we can't use (==) again in another type class of our own     or more generally    that     a function that is used in a type class is inextricably linked to that type class and cannot be used for another type class      ?
16:12:08 <d1av_g3p> Just wondering if I'm thinking about it correctly.
16:12:23 <benmachine> gtrambly: sure, it means the circle, oh wait, you mean two-point, not one-point
16:12:33 <jle`> d1av_g3p: well...just look at the definition of (==)
16:12:35 <jle`> :t (==)
16:12:36 <benmachine> gtrambly: maths is rife with ambiguity of notation, at least
16:12:37 <lambdabot> Eq a => a -> a -> Bool
16:12:38 <jle`> that's just...what it is
16:12:39 <corgifex> d1av_g3p: well, you can reuse names in different modules
16:12:41 <startling> d1av_g3p: you can define another (==)
16:12:43 <jle`> you are welcome to define your own (==)
16:12:45 <geekosaur> it follows the usual scoping rules
16:12:50 <jle`> and it'll be different
16:13:00 <jle`> > let a == b = True in 5 == 9
16:13:02 <lambdabot>  True
16:13:10 <jle`> but that's a different eq
16:13:12 <jle`> (==)
16:13:13 <geekosaur> if you defined your own and you have Eq's imported, then unqualified use is an error
16:13:15 <gtrambly> we're talking about \overline{R} in which contextually we're clearly talking about the extension of R with +- infty <_<
16:13:27 <jle`> > let a * b = 9 in True * "hello"
16:13:28 <lambdabot>  9
16:13:33 <startling> gtrambly: I don't understand what your point is.
16:13:38 <geekosaur> (well, if it's not defined int he exact scope you are in)
16:13:48 <geekosaur> (or something like that, I should take a nap)
16:13:50 <jle`> well, the normal scoping rules apply
16:13:55 <jle`> just like for redefining any function/operator
16:14:00 <d1av_g3p> But is that normally the case? Normally we don't override funcs like that
16:14:10 <gtrambly> in that kind of set there's -still- no definition for 1/0
16:14:11 <jle`> what is normally the case?
16:14:18 <jle`> we override functions all the time
16:14:22 <startling> d1av_g3p: correct, redefining (==) is only likely to confuse people
16:14:26 <benmachine> gtrambly: I will certainly agree with you that one way of adding ±infinity to the real numbers is /overwhelmingly/ more common and important than any other
16:14:26 <startling> gtrambly, agreed.
16:14:27 <jle`> Data.Foldable has its own mapM_
16:14:32 <gtrambly> augh
16:14:33 <geekosaur> d1av_g3p, the reason we don't normally do that is to avoid confusion. convention, not necessity
16:14:35 <gtrambly> so we agree after all?
16:14:35 <jle`> Data.Category has its own id
16:14:37 <benmachine> gtrambly: but that's quite a way from saying no other exists
16:14:44 <jle`> separate from Prelude's id
16:14:50 <startling> gtrambly, there are multiple concurrent conversations here.
16:14:56 <jle`> Data.Set and Data.Map have their own fromList
16:14:59 <d1av_g3p> If I define my own (==) I can't use it. I get "ambigious occurrence"
16:15:08 <corgifex> d1av_g3p: hide the one from prelude
16:15:09 <jle`> well...it's the same rules
16:15:09 <startling> d1av_g3p: you need to hide the original somehow
16:15:13 <jle`> as for any function
16:15:13 <rasfar> Apparently the Alexandroff one-point compactification is unique; I'm not sure about the extended real line.
16:15:18 <corgifex> or use qualified names
16:15:29 <jle`> you either hide it when you import prelude, qualify names, or shadow it in a let/where binding
16:15:37 <jle`> just like any normal function
16:15:40 <benmachine> rasfar: unique among one-point compactifications?
16:15:48 <d1av_g3p> Ok, I see what you're getting at. But did I still grasp it correctly for functions in the same "namespace"?
16:15:50 <d1av_g3p> the SAME FUNCTION
16:16:01 <d1av_g3p> hmm
16:16:02 <jle`> um
16:16:28 <jle`> (==) from Eq is not ambiguous...it has a type, (==) :: Eq a => a -> a -> Bool
16:16:32 <jle`> if you want it to do something else
16:16:34 <rasfar> benmachine: I think so... now sure :)
16:16:36 <jle`> and have a different type
16:16:38 <jle`> etc.
16:16:40 <jle`> you have to define a new function
16:17:02 <jmcarthur> gtrambly: Double is not in anyway related to the reals
16:17:10 <jmcarthur> gtrambly: and I don't think anybody claimed otherwise
16:17:12 <jle`> i guess it's 'linked' to Eq in the same way that (&&) :: Bool -> Bool -> Bool is linked to Bools
16:17:14 <benmachine> jmcarthur: that's probably a bit over the top
16:17:26 <benmachine> jmcarthur: Double is meant to be at least analogous to reals
16:17:28 <jle`> it's a function that operators on Eq a, just like (&&) is a function that operators on Bool
16:17:44 <gtrambly> it's supposed to be a close representation, as reasonably close as we can manage with constraints on computers
16:17:45 <d1av_g3p> Oh, good point..
16:17:46 <d1av_g3p> well said
16:17:47 <jle`> jmcarthur: well, Prelude claims it is :P
16:17:50 <jmcarthur> benmachine: but nobody claims it's faithful
16:17:57 <benmachine> jmcarthur: ah, agreed
16:17:59 <jle`> instance Double RealFrac
16:18:02 <jle`> er
16:18:04 <jle`> that should be backwards
16:18:11 <jmcarthur> jle`: sadness
16:18:15 <fizruk> RealFrac Double instance
16:18:20 <jle`> yes exactly
16:18:27 <jle`> instance Real Double
16:18:34 <jmcarthur> jle`: I don't even know why we have such names
16:18:39 <jmcarthur> they are meaningless here
16:18:52 <gtrambly> the names are kind of dumb, honestly
16:18:52 <jle`> oh it was a joke, you said 'nobody claimed double is related to reals'
16:18:54 <benmachine> jle`: toRational pi
16:18:58 <jle`> so >.>
16:19:01 <jle`> it was meant as a jest.
16:19:06 <jmcarthur> I suppose my wording was quite poor.
16:19:11 <corgifex> > toRational pi
16:19:12 <lambdabot>  884279719003555 % 281474976710656
16:19:18 <rasfar> Unique only if the original space is Hausdorff, I guess: http://math.stackexchange.com/questions/427052/showing-one-point-compactification-is-unique-up-to-homeomorphism
16:19:22 <jle`> oh good, glad mankind has finally solved that problem
16:19:24 <corgifex> > toRational (0 / 0)
16:19:26 <lambdabot>  (-26965397022934738615939577861835371004269654684134598591014512173659901370...
16:19:33 <ij> wow, that's nice
16:19:37 <jle`> that too
16:19:40 <jmcarthur> lol
16:20:01 <jmcarthur> > toRational (1/0)
16:20:02 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
16:20:09 <jmcarthur> the value of infinity
16:20:13 <benmachine> those are the first digits of infinity
16:20:15 <corgifex> > S.elems (S.fromList [1, 0/0, 1, 0/0, 1])
16:20:16 <lambdabot>  [1.0,NaN,1.0,NaN,1.0]
16:20:20 <benmachine> the rest are lopped off by that ellipsis
16:20:21 <jmcarthur> benmachine: the ... means infinity!
16:20:25 <benmachine> yep
16:20:39 <jle`> haha
16:20:46 <gtrambly> i will kill myself now
16:20:59 <jle`> Double is an engineering tool, not a math tool
16:21:01 <benmachine> alternatively, lambdabot is an ultrafinitist, and believes that is the biggest number
16:21:16 <fizruk> corgifex: is that a nice Ord instance over there?
16:21:18 <benmachine> gtrambly: suicide is not recommended
16:21:22 <rasfar> How does one share an MVar with code outside of a Snap Heist application? I know how to add the MVar to App and initialise it.
16:21:28 <jmcarthur> corgifex: nice!
16:21:29 <corgifex> > toRational (-1/0) == negate (toRational (1/0))
16:21:31 <lambdabot>  True
16:22:03 <jmcarthur> > S.elems (S.fromList [1, 0/0, -1, 0/0, 1])
16:22:04 <lambdabot>  [1.0,NaN,-1.0,NaN,1.0]
16:22:11 <rasfar> Maybe I should finally ask a question on SO... chances of that being answered here are really small.
16:22:21 <akurilin> I'm so not getting the indentation of case foo of
16:22:31 <akurilin> can I not indent the different cases on the next line?
16:23:10 <jle`> i think you have to
16:23:14 <jle`> if they are on the next line
16:23:16 <akurilin> or does the first case HAVE to be on the same line?
16:23:17 <fizruk> akurilin: in ghci?
16:23:28 <jle`> akurilin: no, they can be on separate lines
16:23:29 <akurilin> fizruk: well I'm loading the file from ghci
16:23:38 <jle`> case foo of
16:23:38 <jmcarthur> akurilin: you must indent if you go to the next line
16:23:41 <geekosaur> that shouldn't be different
16:23:44 <jle`>     Just x -> True
16:23:47 <jle`>     Nothing -> False
16:24:29 <geekosaur> that is, a file loaded into ghci is the same as a file loaded from ghc; it's ghci's own prompt that differs (and even then there are multiline modes, which need to obey layout last I checked)
16:24:57 <jle`> yes, and there is no autoindent so it's kind of annoying :/
16:25:09 <akurilin> http://lpaste.net/2729974023285899264
16:25:14 <akurilin> is the let somehow ruining it?
16:25:23 <corgifex> yes
16:25:25 <geekosaur> yes
16:25:27 <akurilin> :(
16:25:28 <rasfar> acutally the cases don't /have/ to be indented past the "case" in the line above it...
16:25:30 <geekosaur> you must indent past the *case*
16:25:31 <jle`> you need let .. in
16:25:33 <geekosaur> otherwise it's part of the let
16:25:38 <jmcarthur> akurilin: if that should be a top level definition then don't use let at all
16:25:40 <jle`> actually do you really?
16:25:48 <akurilin> it's in a do block
16:25:53 <jmcarthur> akurilin: if that is a part of another function definition, use let ... in ...
16:25:55 <jle`> oh
16:25:55 <jmcarthur> ah
16:26:03 <akurilin> (sorry, not giving you guys any context)
16:26:07 <jmcarthur> it looks right to me then
16:26:15 <corgifex> let triggers layout
16:26:18 <jle`> that looks...right...
16:26:24 <corgifex> lern2indent
16:26:29 <jmcarthur> maybe you have to ident beyond the q?
16:26:36 <jmcarthur> i would be surprised
16:26:55 <corgifex> of course you have to indent beyond the q; otherwise a } is inserted
16:26:55 <jle`> oh
16:26:55 <geekosaur> I wouldn't actually
16:26:57 <geekosaur> seems right
16:26:59 <jle`> you have to indent beyond q
16:27:05 <jle`> yeah
16:27:14 <jle`> otherwise you aren't in the same "let"
16:27:15 <akurilin> OK I updated it
16:27:17 <jmcarthur> i rely so much on haskell-mode i sometimes forget these details
16:27:18 <akurilin> http://lpaste.net/2729974023285899264
16:27:20 <akurilin> the second one works
16:27:29 <akurilin> :|
16:27:32 <CaptainK> anyone have a good torrent link to the latest ghc win binary?  bad connection here
16:27:34 <corgifex> let { qs = take 100 $ case of {} }
16:27:35 <jle`> so every time you are at the level of the q, let's a new binding
16:27:50 <jle`> it has to be another k = ... or something
16:27:58 <akurilin> jle`: oooh because I can chain multiple binding declarations under on elet
16:28:00 <benmachine> it's the first token after the let that sets the new indentation level
16:28:01 <jle`> yeah
16:28:07 <jle`> oh, really?
16:28:09 <jle`> :|
16:28:12 <jle`> oh yeah
16:28:20 <benmachine> yeah I'm agreeing with you
16:28:33 <akurilin> man that was a head-scratcher
16:28:34 <geekosaur> same problem as when people try to one-line do blocks with let in them, which is why you need to insert braces
16:28:57 <jle`> it...makes sense after a bit
16:29:07 <jle`> but at first it is a bit confusing when you just look at the error messages
16:29:28 <corgifex> > do "k"; let { x = 42 }; return x
16:29:30 <lambdabot>  [42]
16:29:53 <corgifex> people generally try to fix this by adding braces to the 'do' instead, which has no effect
16:29:54 <jle`> heh
16:31:01 <akurilin> I've already dumped one language for crazy indentation problems (Coffeescript), but I'm willing to suck it up for Haskell
16:31:12 <corgifex> you can just use explicit { }
16:31:24 <rasfar> a lot (most) of the difficulty of programming in Haskell is about interpreting the error messages.
16:31:41 <geekosaur> haskell's indentation in my experience is a lot saner than many others
16:31:41 <jle`> i don't notice indenting any more
16:31:56 <jle`> but it is admittedly hard to convince someone of this before they get past the intuition
16:31:59 <akurilin> rasfar: Yeah man, Haskell is a cakewalk compared to Clojure's interpreter stack dump
16:32:03 <rasfar> it's getting crazier all the time as library writers depend on greater abstractions
16:32:42 <rasfar> heh, alright...
16:33:01 <akurilin> at least you get something valuable out of the error msg
16:33:23 <d1av_g3p> infix functions only work on functions with 2 parameters right? infix and currying is not possible is it?
16:33:25 <akurilin> in clj 90% of the time it's something along the lines of "you can't use this seq as a fn, bad bad you"
16:33:42 <corgifex> d1av_g3p: I don't understand the question
16:34:00 <geekosaur> if yo actually mean partial application, see sections
16:34:10 <geekosaur> :t (1+)
16:34:11 <lambdabot> Num a => a -> a
16:34:26 <d1av_g3p> corgifex: if I have   boom x y z = x+y+z     does it make any sense to write `boom` ever?
16:34:40 <geekosaur> it can
16:34:42 <Cale> d1av_g3p: sure
16:34:43 <d1av_g3p> oh
16:34:44 <corgifex> > let boom x y z = x+y+z in (1 `boom` 2) 3
16:34:46 <lambdabot>  6
16:34:52 <d1av_g3p> i'll be damned
16:35:01 <Cale> > let boom x y z = x+y+z in map (1 `boom` 2) [10,20,30,40,50]
16:35:03 <lambdabot>  [13,23,33,43,53]
16:35:05 <d1av_g3p> so it's basically the first two params
16:35:09 <geekosaur> you're only able to use 2 parameters, but partial application lets you do that sensibly
16:35:14 <d1av_g3p> ok
16:35:15 <jle`> well
16:35:21 <jle`> remember that boom x y z
16:35:22 <Cale> Every function in Haskell really has exactly one parameter
16:35:36 <jle`> is just boom \x y -> (\z -> x+y+z)
16:35:44 <Cale> and those which appear to have more are producing other functions as their result
16:35:54 <corgifex> jle`: the enter key is not punctuation
16:35:55 <jle`> so boom can be interpreted to only have two parameters, and return a function once given two parameters
16:36:03 <monochrom> this is why I say:
16:36:07 <monochrom> @quote monochrom 17-ary
16:36:07 <d1av_g3p> nice
16:36:07 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
16:36:11 <Cale> boom x y z = ((boom x) y) z
16:36:17 <jle`> corgifex: ah, i'll take that into account
16:36:39 <monochrom> never press enter
16:36:56 * corgifex presses ctrl-M
16:37:26 <jle`> oh that works well
16:37:38 <rasfar> is that others' experience, that 90% of development time in Haskell is spent understanding compiler errors?EOL
16:37:47 <monochrom> not me
16:37:55 <jle`> i...wouldn't say that is me
16:38:06 <rasfar> where does your time go mostly, monochrom and jle`
16:38:12 <corgifex> > (max `zipWith` [1, 10, 2, 20]) [3 .. 12]
16:38:14 <lambdabot>  [3,10,5,20]
16:38:18 <monochrom> design and implementation
16:38:26 <jle`> pen and paper :)
16:38:44 <rasfar> design comes very easily for me somehow; implementation seems to be a matter of getting rid of the compiler errors...
16:38:54 <d1av_g3p> But why do I need the parentheses here, (2 `boom` 3) 5?   2 `boom` 3 5    errs. That's strange becuase `boom` is an infix and couldn't possibly take both 3 and 5
16:38:57 <jle`> getting rid of compiler errors is not understanding compiler errors
16:39:11 <corgifex> d1av_g3p: because that's applying 3 to 5
16:39:11 <rasfar> how so?
16:39:18 <d1av_g3p> lol
16:39:20 <d1av_g3p> wtf
16:39:21 <corgifex> d1av_g3p: and 3 is normally not a function
16:39:23 <monochrom> 2 `boom` (3 5) is a type error
16:39:27 <jle`> type errors are good, they check our program for correctness
16:39:30 <gtrambly> i find no problems with the haskell compiler messages at all
16:39:46 <jle`> time spent debugging type errors is time otherwise spent debugging runtime errors, or a small fraction of it :)
16:39:49 <gtrambly> even if the message is a bit weird, if it points out a line number it's usually immediately obvious what the problem is
16:39:51 <geekosaur> there *are* function instances of Num, in which case that could be non-erroneous --- but probably not do what you intended
16:39:55 <rasfar> i'm done with pen and paper in an hour, for a week's worth of implementation
16:39:55 <jle`> *understanding* the type errors isn't the hard part
16:40:24 <d1av_g3p> but why doesn't it figure out  (2 `boom` 3) 5   on its own
16:40:27 <rasfar> this situation isn't improving as fast as I'd like, in part due to use of scads of libraries I'd not used before
16:40:39 <monochrom> because it is told not to
16:40:51 <gtrambly> :t boom
16:40:53 <lambdabot>     Not in scope: ‘boom’
16:40:53 <lambdabot>     Perhaps you meant one of these:
16:40:53 <lambdabot>       ‘zoom’ (imported from Control.Lens),
16:41:04 <gtrambly> <_<
16:41:17 <rasfar> in C it used to be about 50:50 writing (pen/paper) and implementation, sigh
16:41:29 <d1av_g3p> ok whatever, just precedence rule i gotta live with eh
16:41:30 <Welkin> haha
16:41:34 <rasfar> so, Snap -- anyone using it?
16:41:49 <Welkin> in C it is more like 10:90 writing: implementation
16:42:06 <d1av_g3p> rasfar: at some point i want to ditch node.js for snap
16:42:20 <rasfar> welkin, in all honesty with thousands of hours in with both languages, the case is the opposite for me
16:42:21 <corgifex> reading that as "writhing"
16:42:29 <d1av_g3p> (or happstack/yoda)
16:42:34 <d1av_g3p> err, yesod
16:42:38 <Welkin> corgifex, that works too
16:42:47 <Welkin> but the writhing would be a lot more than 10%
16:42:54 <gtrambly> how do you ditch node.js for snap, d1av_g3p? don't the two serve completely different purposes
16:42:55 <rasfar> i looked at happstack, snap and yesod and decided to go with snap for the present
16:43:09 <d1av_g3p> gtrambly: i want to make web apps
16:43:32 <d1av_g3p> gtrambly: what purposes?
16:43:33 <gtrambly> there is actually this fantastic library offered by haste, though, that does web sockets in this ingenious way...
16:43:37 <gtrambly> have you seen Haste.App?
16:43:45 <d1av_g3p> nope
16:43:54 <gtrambly> let me fetch the paper
16:44:09 <rasfar> my trouble is, using Heist, you have to use TH, and now I'm having trouble sharing state with the larger system.
16:44:12 <akurilin> declaring two data types with record syntax in the same file, both with same field name. Is moving them into separate modules unavoidable?
16:44:30 <d1av_g3p> rasfar: what's th
16:44:36 <rasfar> template haskell
16:44:42 <d1av_g3p> ok
16:44:52 <monochrom> yes akurilin, if you really insist same name.
16:45:09 <gtrambly> i think this will blow your mind, d1av_g3p : ) : http://tinyurl.com/ph53oxz
16:45:15 <rasfar> akurilin: are you on the newest version of GHC? I read about an extension someplace that allows same named selectors.
16:45:22 <akurilin> monochrom: I mean, if both types have a field "foo", and there's a legitimate reason for it
16:45:27 <monochrom> I wouldn't insist same name. even when different modules.
16:45:29 <akurilin> rasfar: no I'm on 7.6.2
16:45:40 <gtrambly> exciting things are happening in haskell web applications
16:45:58 <rasfar> ah; I think it's not there yet... checking if I can find the reference
16:46:14 <d1av_g3p> have a direct pdf link?
16:47:09 <rasfar> working on it; as usual my machine is very bogged down so loading pages is slow
16:47:19 <d1av_g3p> np
16:47:26 <rasfar> https://ghc.haskell.org/trac/ghc/wiki/Records is what I was reading I think
16:48:02 <rasfar> that's certainly to the purpose, but I'm not sure of the status
16:48:10 <gtrambly> http://ekblad.cc/icfp14.pdf <-- d1av_g3p
16:49:58 <d1av_g3p> gtrambly: thanks
16:51:03 <d1av_g3p> gtrambly: very recent stuff!
16:51:13 <gtrambly> yes very!
16:51:50 <gtrambly> it's still virgin territory, but it's extremely promising
16:51:57 <gtrambly> it works too, i can confirm
16:52:10 <gtrambly> the libraries are available on hackage and everything
16:52:25 <roconnor> fg
16:52:28 <dcahilla> preflex: karma dcahilla
16:52:43 <gtrambly> be prepared to use linux or mac for your compilation for now though, since it chokes on windows
16:52:53 <roconnor> grr
16:53:05 <dcahilla> @help
16:53:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:53:13 <dcahilla> @list
16:53:14 <lambdabot> What module?  Try @listmodules for some ideas.
16:53:28 <d1av_g3p> hehe, nice
16:53:30 <dcahilla> @karma dcahilla
16:53:30 <lambdabot> You have a karma of 0
16:53:31 <d1av_g3p> i will look at this
16:54:11 <AshyIsMe> can anyone see what im doing wrong here?  https://gist.github.com/anonymous/10562508#file-newsitem-hs-L86
16:54:29 <AshyIsMe> im getting: parse error (possibly incorrect indentation or mismatched brackets)
16:56:23 <corgifex> AshyIsMe: where?
16:57:00 <AshyIsMe> line 86
16:57:05 <AshyIsMe> it should be highlighted with that link
16:57:35 <corgifex> does it give a column?
16:57:58 <AshyIsMe> oh yeap, 13
16:58:21 <AshyIsMe> which is the "c" of case
16:58:46 <AshyIsMe> ive lined it up with the line above: nItemResult <- ...
16:58:53 <AshyIsMe> as it should be part of that do block
16:59:42 <corgifex> oh, duh
16:59:55 <corgifex> dangling <*>
17:00:19 <geekosaur> looks like it, yes
17:08:21 <petrie> Does majority of people in here develop in haskell at work?
17:09:49 <AshyIsMe> oh haha
17:10:02 <AshyIsMe> copy paste brainfart
17:19:22 <rasfar> @paste
17:19:22 <lambdabot> Haskell pastebin: http://lpaste.net/
17:21:39 <gtrambly> hrm
17:21:41 <gtrambly> that's odd
17:21:46 <gtrambly> http://screencloud.net/v/xe58
17:21:56 <gtrambly> how do i circumvent this little problem?
17:22:24 <akurilin> Shameless newbie question: what do I use if I want something along the lines of an else if with somewhat complex checks inside of it? Can I have a guard with multipel conditions?
17:22:33 <Eduard_Munteanu> gtrambly: make a cabal project for your code
17:22:53 <Eduard_Munteanu> gtrambly: then you can make it depend on one of those (likely you want 'mtl')
17:22:56 <gtrambly> alright, i guess i will
17:22:59 <gtrambly> thank you
17:23:51 <haasn> I love GHC 7.8.2 <3  https://github.com/haasn/units/blob/master/src/Units/SI.hs
17:23:57 <Eduard_Munteanu> akurilin: guards don't have any special syntax, you can write any expression that is a Bool
17:23:57 <haasn> way cleaner, way prettier and way faster
17:24:06 <haasn> proper Nat and Symbol support is awesome
17:24:27 <Eduard_Munteanu> 7.8.2... what, was 7.8 released? :O
17:24:30 <rasfar> akurilin, if the predicates get long and compound, I tend to define them locally in a where block, then the guards can stay concise
17:24:55 <Eduard_Munteanu> Wow, cool. Both 7.8.1 and 7.8.2.
17:25:55 <geekosaur> 7.8.1 came out midweek, major issue with type families immediately found. 7.8.2 released this morning
17:28:28 <akurilin> Eduard_Munteanu, rasfar thanks!
17:32:12 <Algebr> I'm using gtk2hs and having a fat main, so I'm trying to break things up, but how can I have the state in one Monad be share in an encompassing monad? of course this is easier shown with code. http://lpaste.net/102636
17:33:23 <Algebr> will be afaik for a second...
17:33:33 <Algebr> err, brb.
17:33:34 <Eduard_Munteanu> Algebr: you could use ReaderT
17:33:49 <gtrambly> is there a parameter you can supply to ghci to make it load from a cabal file?
17:40:48 <Algebr> Eduard_Munteanu: Ah, I don't know what that is, have to look up...any easy examples? (pizza came)
17:41:52 <Eduard_Munteanu> Algebr: are you familiar with the Reader monad?
17:42:19 <Algebr> no
17:42:26 <neumond|2> haskell is great. much, MUCH less iterations required to make things work. It just do what you wrote. Awesome. No more missing somewhere-freakin-symbol pain.
17:43:54 <Eduard_Munteanu> Algebr: ok... you could start by defining a data type to hold those controls. Then you can pass that around as a whole.
17:50:15 * hackagebot mcmc-synthesis 0.1.2.2 - MCMC applied to probabilistic program synthesis  http://hackage.haskell.org/package/mcmc-synthesis-0.1.2.2 (TikhonJelvis)
18:02:58 <zq> how do i do the equivalent of, in c, (-n & 8)?
18:03:14 <zq> > (-9) .&. 8
18:03:15 <lambdabot>  Ambiguous occurrence ‘.&.’
18:03:15 <lambdabot>  It could refer to either ‘Data.Bits..&.’,
18:03:16 <lambdabot>                           imported from ‘Data.Bits’ at L.hs:55:1-16
18:03:16 <lambdabot>                        or ‘Test.QuickCheck.Property..&.’,
18:03:16 <lambdabot>                           imported from ‘Lambdabot.Plugin.Haskell.Eval.Truste...
18:03:26 <Cale> yeah, that would be how
18:03:30 <zq> but it don't work
18:03:38 <Cale> Well, lambdabot has too many modules imported
18:03:43 <zq> > Data.Bits.(.&.) (-9) 8
18:03:44 <lambdabot>  Not in scope: data constructor ‘Data.Bits’Ambiguous occurrence ‘.&.’
18:03:44 <lambdabot>  It could refer to either ‘Data.Bits..&.’,
18:03:44 <lambdabot>                           imported from ‘Data.Bits’ at L.hs:55:1-16
18:03:44 <lambdabot>                        or ‘Test.QuickCheck.Property..&.’,
18:03:44 <lambdabot>                           imported from ‘Lambdabot.Plugin.Haskell.Eval.Truste...
18:04:02 <Cale> > (-9) Data.Bits..&. 8
18:04:04 <lambdabot>  0
18:04:30 <geekosaur> zq: the module goes *inside* the parens
18:05:19 <Cale> I originally thought it would work like zq assumed too.
18:05:40 <Cale> Data.Bits.(.&.) would be much more readable
18:06:15 <zq> geekosaur: (Data.Bits..&.)?
18:06:20 <Cale> zq: yeah
18:06:24 <geekosaur> but to me you;'re qualifying the name and the name is inside the parens
18:06:35 <geekosaur> and to the compiler as well
18:06:50 <nisstyre> > 2 .|. 1
18:06:51 <geekosaur> (yes, I readily grant my perceptions here are uncommon)
18:06:52 <lambdabot>  3
18:07:03 <zq> is 7.6.3 smart enough to tranlsate (mod 8) . negate into (.&. 7) . negate?
18:07:08 <rasfar> the (...) in this case is that special operator syntax though I guess (threw me off too)
18:07:34 <geekosaur> it is, but what's inside is still a name (a symbolic name, but a name)
18:07:41 <geekosaur> so I expect the qualification on the name
18:07:44 <rasfar> :t (Data.Bits.(.&.))  -- ??
18:07:45 <lambdabot> Not in scope: data constructor ‘Data.Bits’
18:07:45 <lambdabot>     Ambiguous occurrence ‘.&.’
18:07:45 <lambdabot>     It could refer to either ‘Data.Bits..&.’,
18:08:08 <geekosaur> :t (Data.Bits..&.)
18:08:09 <lambdabot> Bits a => a -> a -> a
18:08:12 <rasfar> :t Data.Bits.(.&.)
18:08:14 <lambdabot> Not in scope: data constructor ‘Data.Bits’
18:08:14 <lambdabot>     Ambiguous occurrence ‘.&.’
18:08:14 <lambdabot>     It could refer to either ‘Data.Bits..&.’,
18:09:21 <rasfar> (oops, that operator syntax is inapplicable in this context anyhow)
18:09:38 <geekosaur> and that is parsed as composition of a constructor Data.Bits with a function-syntax operator (.&.)
18:09:48 <nisstyre> > 1 `shiftL` 16
18:09:50 <lambdabot>  65536
18:10:00 <rasfar> :t (+)
18:10:02 <lambdabot> Num a => a -> a -> a
18:10:23 <rasfar> hard to know how those parens were interpreted
18:10:41 <geekosaur> er? look at the error message
18:10:42 <rasfar> (type is the same in any case obviously)
18:11:37 <rasfar> geekosaur, oh right, re. constructor . func syntax
18:12:10 <rasfar> although my context was :t so I'm not sure
18:12:11 <zq> anyone?
18:12:23 <zq> meh, guess i'll check the asm
18:12:57 <geekosaur> I don;t think anyone here knows. I'd guess not unless someone actually defined a RULE for it, though
18:13:37 <zq> geekosaur: is RULE a proper noun there?
18:14:03 <geekosaur> it's a specific compiler pragma directing ghc to replace one expression with another under certain conditions
18:15:08 <zq> hm
18:15:18 * hackagebot rainbow 0.14.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.14.0.0 (OmariNorman)
18:16:04 <geekosaur> those kinds of optimizations tend not to be builtins in ghc, they're accomplished by pragmas
18:16:38 <geekosaur> (I suspect one of the reasons the LLVM backend outperforms the asm backend for math is because LLVM's optimizer does these kinds of things)
18:18:03 <haasn> :t (Data.Bits..&.) -- rasfar: The qualification is on the name, the parens () are not part of the name
18:18:04 <lambdabot> Bits a => a -> a -> a
18:18:23 <haasn> > 3 Data.Bits..&. 5
18:18:25 <lambdabot>  1
18:18:31 <geekosaur> yes, that's what I was saying
18:19:30 <geekosaur> and it does look strange, because . is overloaded for so many things
18:19:46 <rasfar> hassn: yes, but my uncertitude was whether those parens are acting as operator syntax in that context (very idle question)
18:20:13 <geekosaur> they wrap an operator name. that name can be qualified.
18:20:47 <geekosaur> the qualification goes on the *name*
18:20:56 <rasfar> I mean (+) and `mod` type syntax -- the () there is not just a plain grouping right?
18:21:16 <geekosaur> right, it's not just grouping
18:21:46 <rasfar> zq originally wanted to write (.&.) arg1 arg2
18:22:10 <rasfar> but because it's preceded by :t I was unsure what syntax rules were in effect
18:22:13 <geekosaur> if it were just grouping, the parens wouldn't actually be doing anything and could be omitted
18:22:40 <rasfar> and in particular wouldn't report an error
18:22:46 <geekosaur> but in this case they are syntactically necessary to indicate "using an operator name as a function"
18:23:13 <rasfar> right, except after a :t you'd never notice the difference as the types are the same
18:24:09 <geekosaur> hrm?
18:24:21 <geekosaur> :t .&. -- syntax error
18:24:23 <lambdabot> parse error on input ‘.&.’
18:26:30 <geekosaur> operators can only be parsed in a linguistic operator context. the extra parens are a "magical" way to provide that context. but if the operator needs to be qualified, it is the operator and not the parens providing it context that must be qualified
18:26:32 <rasfar> hm. i see (kindof)
18:27:12 <rasfar> (oops, flip those two messages)
18:27:53 <rasfar> yeah i get that. i didn't realise :t + would be a syntax error however
18:28:39 <rasfar> thanks, that does shed some clarity on an obscure area
18:34:58 <petrie> geekosaur: Did you say you were from toledo?
18:35:20 <geekosaur> Cleveland/Akron, roughly
18:35:48 <joelteon> northern ohio represent!
18:40:33 <dmj`> geekosaur: sorry about lebron
18:40:37 <xpika> what is the deal with the haskell platform? Can I be of any assistance?
18:40:59 <dmj`> xpika: what's wrong?
18:41:02 <geekosaur> the deal is that it was waiting on ghc 7.8 and a real fix for the xcode 5 issue
18:41:04 <heatsink> I have a dynamic type checking function that uses unsafeCoerce# to generate evidence of type equality: http://lpaste.net/102637
18:41:08 <heatsink> Is there a way to write it without unsafeCoerce#?
18:41:17 <geekosaur> 7.8 was supposed to have shipped last october
18:41:32 <zq> guhhhh
18:41:43 <zq> is Network.ByteString.sendAll lazy or something?
18:41:45 <petrie> Doh, phone died.
18:41:51 <petrie> geekosaur: You see my last message?
18:41:53 <geekosaur> now that it is finally out, the platform is targeting a release next month (giving time for everything to be verified against it)
18:42:05 <geekosaur> [13 01:32] <petrie> geekosaur: Did you say you were from toledo?
18:42:05 <geekosaur> [13 01:32] <geekosaur> Cleveland/Akron, roughly
18:42:18 <petrie> Oh, I asked if you go to the meetup there
18:42:25 <geekosaur> nope
18:42:38 <petrie> Ah ok
18:42:42 * geekosaur is kinda transport-less at the moment, if he can't walk there he doesn't go there. working ion it...
18:42:49 <xpika> dmj`: according to the website, the next release is april last year
18:42:51 <petrie> Ah :\
18:43:09 <geekosaur> yeh, the website is behind a bit
18:43:29 <geekosaur> although if it really says april last year then it missed one somehow
18:43:57 <xpika> http://www.haskell.org/platform/
18:44:01 <geekosaur> the release that was missed was the fall 2013 release
18:45:02 <xpika> geekosaur: what is the issue with xcode?
18:45:13 <geekosaur> where an explicit decision was made after 7.8 missed the "during ICFP" release that it would be skipped, because otherwise it would be necessary to deal with the hacks needed to work with xcode 5 in a number of different environments (stock package, and both macports and homebrew package the platform)
18:45:14 <xpika> geekosaur: i run a mac
18:45:32 <geekosaur> as in the /topic: XCode 5 issues? http://is.gd/H4sEub
18:45:45 <geekosaur> the problem is apple dropped gcc, and clang's cpp does not like being invoked on haskell code
18:46:14 <geekosaur> if you add a certain set of options, you can make it work about 95% of the time, but there are still haskell constructs that it will throw up on
18:46:29 <xpika> geekosaur: can someone write a new standalone C pre processor?
18:46:35 <geekosaur> ghc 7.8 has a custom preprocessor instead of relying on one from a C compiler
18:46:46 <geekosaur> which is why the platform has been on hold waiting for 7.8
18:46:51 <dmj`> xpika: I'm running ghc 7.8.2 on 3 OS's and it's great
18:46:52 <xpika> geekosaur: very good
18:47:05 <xpika> dmj`:  great to hear
18:47:24 <heatsink> Ooh, it's good to hear that there's a CPP replacement
18:47:41 <geekosaur> (this should have been done long ago; using cpp for non-C has been known to be a problem ever since ANSI C was standardized)
18:47:42 <heatsink> Now I don't have to make sure to use an even number of primed variables on every line of code :)
18:48:38 <xpika> heatsink: really?
18:48:58 <xpika> heatsink: that would be bad'''
18:48:59 <geekosaur> yes, that'd be something I would expect to fail
18:49:52 <geekosaur> also string gaps, user defined operators using #, and a few other things
18:51:11 <Axman6> 22
18:51:16 <Axman6> bleh
18:51:17 <geekosaur> (gcc -P -traditional probably handles most of those; clang's cpp I would expect to have problems with all of them)
18:52:06 <Cale> > text$ap(++)show"text$ap(++)show"
18:52:07 <lambdabot>  text$ap(++)show"text$ap(++)show"
18:52:16 <geekosaur> because an ANSI C-compliant preprocessor must actually know C, it can't just do text substitution like K&R-style cpp did
18:52:41 <rasfar> I really like using CPP to comment out blocks of code; hopefully the semantics of that won't change with the replacement preprocessor...
18:53:10 <xpika> ghc seems to be emancipating itself from its external build tool requirements nicely.
18:53:32 <heatsink> Is GHC's CPP based on Warp?
18:54:10 <geekosaur> (and yes, it must parse string and char literals outside of preprocessor directives in order to recognize both when to expand macros and to handle # and ## splices)
18:55:47 <dmj`> are there lenses on strict hash maps?
18:55:56 <dmj`> I see a Data.Map.Lens
18:56:01 <edwardk> strict hashmaps are the same type as regular
18:56:08 <edwardk> Data.Map.Lens is just a documentaton module
18:56:17 <edwardk> 'at' works for HashMap, Map, IntMap, tc.
18:56:32 <edwardk> > HM.fromList [(1,2)]^.at 1
18:56:34 <lambdabot>  Not in scope: ‘HM.fromList’
18:56:34 <lambdabot>  Perhaps you meant one of these:
18:56:34 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
18:56:34 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
18:56:34 <lambdabot>    ‘S.fromList’ (imported from Data.Set)
18:56:54 <edwardk> @let import Data.HashMap as HM
18:56:54 <lambdabot>  .L.hs:79:1:
18:56:55 <lambdabot>      Failed to load interface for ‘Data.HashMap’
18:56:55 <lambdabot>      Perhaps you meant Data.HashSet (from unordered-containers-0.2.4.0)
18:56:55 <lambdabot>      Use -v to see a list of the files searched for.
18:57:02 <edwardk> @let import Data.HashMap.Strict as HM
18:57:03 <lambdabot>  .L.hs:79:1:
18:57:03 <lambdabot>      Data.HashMap.Strict: Can't be safely imported!
18:57:03 <lambdabot>      The package (unordered-containers-0.2.4.0) the module resides in isn't t...
18:57:06 <edwardk> bah
18:57:10 <edwardk> anyways, it works
18:57:33 <edwardk> at, traverse, ix, itraversed, ifolded, imapped are all valid on hashmaps.
18:58:33 <dmj`> ah beautiful! I'm trying to update a HashMap of HashMaps
18:58:34 <dmj`> http://lpaste.net/102638
18:59:19 <dmj`> I like the ^.at "id"
19:03:02 <heatsink> Is it possible to dynamically prove that Typeable types are equal without unsafeCoerce#?
19:03:09 <heatsink> using unsafeCoerce# http://lpaste.net/102637
19:03:35 <jmcarthur> i think there has been some recent conversation about changing Typeable to basically give you exactly that
19:03:51 <jle`> jmcarthur: hm. really?
19:04:00 <jmcarthur> mailing list discussion somewhere
19:06:44 <heatsink> Guess I'll go with this code then
19:10:17 <byorgey> heatsink: I think the version of base that comes with GHC 7.8 defines that function for you
19:11:43 <heatsink> oh
19:11:58 <jmcarthur> jle`: check this out (GHC 7.8...)     let refl :: forall a b. (Typeable a, Typeable b) => Maybe (a :~: b); refl = cast (Refl :: a :~: a)
19:12:01 <jmcarthur> jle`: works
19:12:10 <dmj`> @typ isn't
19:12:11 <lambdabot> APrism s t a b -> s -> Bool
19:12:16 <jmcarthur> heatsink: you're the one i really meant to send that to ^^^
19:13:01 <heatsink> Wow, it's defined almost identically to what I wrote
19:13:08 <akurilin> quick question: is aeson smart enough to be able to parse a JSON tree where each node is a data type I define? I probably have a couple of node types at most.
19:14:32 * heatsink doesn't have 7.8, though
19:16:52 <byorgey> akurilin: not automatically, you have to define some instances which tell it how to parse JSON into your data types
19:17:04 <byorgey> akurilin: it's pretty easy though, see the documentation and examples at http://hackage.haskell.org/package/aeson-0.7.0.3/docs/Data-Aeson.html
19:17:32 <heatsink> Thanks for pointing out the new Typeable code, byorgey and jmcarthur
19:18:53 <jmcarthur> byorgey: sadness! the built in eqT uses unsafeCoerce even though my definition would work
19:19:20 <byorgey> jmcarthur: but cast uses unsafeCoerce, doesn't it?
19:19:32 <jmcarthur> sure, but it's nice to have as few unsafeCoerces as possible
19:19:33 <carter> heatsink: have you seen the coerce machery in 7.8?
19:20:00 <carter> btw, who wants my build of 7.8.2 for OS X :)
19:20:03 <carter> mwahahahah
19:20:09 <jmcarthur> it's not like i'm super bothered by it, but it just seems a small shame
19:20:27 <heatsink> carter: Nope.  But it seems to use the new kind polymorphism features.
19:20:30 <byorgey> jmcarthur: meh, I think the only important difference is between zero and more than zero.
19:20:37 <carter> heatsink: ?
19:21:09 <heatsink> For example, you have Typeable Int and Typeable IO
19:21:20 <byorgey> jmcarthur: but I guess there is a certain elegance in having the minimal number of unsafeCoerces, so you can see exactly what is required
19:21:22 <heatsink> even though they have different kinds
19:21:42 <carter> its oh yeah, typeable is polykinded
19:21:49 <carter> i'm talking about Coercable :)
19:21:58 <heatsink> Oh, I didn't know about that
19:22:25 <carter> http://www.haskell.org/ghc/docs/7.8.2/html/libraries/ghc-prim-0.3.1.0/GHC-Prim.html#g:26
19:22:30 <carter> coerce :: Coercible a b => a -> b
19:24:52 <pyon> Let "newtype Compose f g a = Compose (f (g x))". Then, "(Functor f, Functor g) => Functor (Compose f g)", and "(Contravariant f, Functor g) => Contravariant (Compose f g)", right?
19:25:27 <pyon> errr s/x/a/
19:27:04 <haasn> pyon: other way round
19:27:08 <haasn> (Functor f, Contravariant g)
19:27:23 <pyon> Oh.
19:27:25 <haasn> fmap (contramap f)
19:27:55 <haasn> f (g b) -> f (g a)
19:28:16 <rasfar> modifyIORef' (global :: IORef (MVar Int)) (\m->m)  -- works
19:28:20 <rasfar> modifyIORef' global (\m->do return m)  -- doesn't
19:28:21 <haasn> Actually, I think both work
19:28:41 <rasfar> what's wrong with the latter?
19:28:49 <haasn> contramap (fmap f :: g a -> g b) :: f (g b) -> f (g a)
19:28:56 <haasn> and both satisfy the identity law
19:29:13 <heatsink> carter: Looks nice and automatic.
19:29:18 <haasn> pyon: hmm, looks like ‘contravariant’ supplies both instances, under different newtypes
19:29:20 <carter> yup
19:30:03 <pyon> Mmm...
19:30:20 <dmj`> > M.fromList [("hello", M.fromList [("a","b")])] & at "hello" . non M.empty . at "a" ?~ "!!!"
19:30:21 <rasfar> (this is in IO obviously)
19:30:22 <lambdabot>  fromList [("hello",fromList [("a","!!!")])]
19:30:27 <pavonia> rasfar: \m -> return m has a different type than \m -> m
19:30:34 <pyon> @type contramap
19:30:36 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
19:30:37 <rasfar> \m -> do return m
19:30:41 <pyon> Oh, nice, lambdabot has it.
19:30:58 <pavonia> :t \m -> m
19:30:59 <lambdabot> t -> t
19:31:05 <pavonia> :t \m -> return m
19:31:06 <lambdabot> Monad m => a -> m a
19:31:10 <rasfar> not return m
19:31:24 <rasfar> :r \m -> do return m :: IO (MVar Int)
19:31:32 <rasfar> oops, you get the idea
19:31:47 <rasfar> (i need a monadic block on the RHS of the lambda)
19:31:48 <pavonia> "do return m" is the same as "return m"
19:31:55 <rasfar> oh, sorry pavonia
19:32:24 <rasfar> :t return 4
19:32:26 <lambdabot> (Num a, Monad m) => m a
19:32:32 <rasfar> :t do return 4
19:32:34 <lambdabot> (Num a, Monad m) => m a
19:32:53 <Adeon> did you got the answer for your modifyIORef' question?
19:32:55 <Adeon> get*
19:32:57 <haasn> :t non
19:32:59 <lambdabot> (Profunctor p, Functor f, Eq a) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
19:33:02 <rasfar> it seems you're right (I am laughing) -- how HOW can I still be confused about this when using it daily
19:33:09 <rasfar> Adeon, hell no
19:33:31 <henk> hi, I need to parse something and I’m looking at Parsec. Is that still developed? I’m trying to parse a ;-seperated string using "sepBy" in http://lpaste.net/102639 but it just eats the whole string. When I do s/many anyChar/many noneOf ";"/ it "works", but I wonder what the point of sepBy is if it does not recognize the seperator … Am I doing anything wrong?
19:33:37 <Adeon> in \m -> return m (latter modifyIORef' m and return m don't have the same types
19:33:40 <rasfar> I have an IORef (MVar Int) global [temporary hack...]
19:33:43 <Adeon> :t modifyIORef'
19:33:44 <lambdabot>     Not in scope: ‘modifyIORef'’
19:33:44 <lambdabot>     Perhaps you meant one of these:
19:33:44 <lambdabot>       ‘modifySTRef'’ (imported from Data.STRef),
19:33:47 <Adeon> :t modifyIORef
19:33:49 <lambdabot>     Not in scope: ‘modifyIORef’
19:33:49 <lambdabot>     Perhaps you meant one of these:
19:33:49 <lambdabot>       ‘modifySTRef’ (imported from Data.STRef),
19:33:51 <Adeon> argh
19:33:51 <haasn> :t \m -> do m
19:33:53 <lambdabot> t -> t
19:34:13 <Adeon> anyway, the modification cannot change types; it looks like as if you are trying to run an IO action inside the modification
19:34:17 <rasfar> what I expected to work:
19:34:19 <rasfar>       (\m -> do
19:34:20 <rasfar>                 i <- takeMVar m :: IO Int
19:34:20 <rasfar>                 let i2 = i + 1 :: Int
19:34:20 <rasfar>                 putMVar m i2 :: IO ()
19:34:20 <rasfar>                 return m)
19:35:03 <rasfar> I could swear I was doing this with modifyMVar_ recently sigh; sorry for being so slow about monads
19:35:34 <haasn> why are you returning m?
19:35:39 <pavonia> "modifyIORef' :: IORef a -> (a -> a) -> IO () " -- So you can't use a monadic function with modifyIORef'
19:35:53 <rasfar> well, the function updates the contents of the IORef, so it should be MVar Int -> MVar Int
19:36:18 <rasfar> I thought I was accomplishing that by "do ... return m" -- I thought without the "do" it would still be IO (MVar Int)
19:36:19 <Adeon> it can change which MVar is inside the IORef but it cannot touch the MVar itself
19:36:30 <Adeon> because modifying the contents of an MVar requires an IO action
19:36:31 <haasn> why do you have the MVar inside an IORef?
19:36:39 <akurilin> Can I implement parseJSON for multiple data constructors under the same sum type?
19:36:56 <rasfar> because it's uncertain there's another way for a Snaplet to communicate the MVar to the outside
19:36:58 <Axman6> o.O
19:37:11 <rasfar> this quick hack was suggested by cheater over in #snapframework
19:37:21 <haasn> why are you updating the IORef?
19:37:23 <Adeon> if you want something like IORef but with IO action modifications then you can use an MVar
19:37:24 <rasfar> until someone with a better idea can weight in
19:37:49 <rasfar> i'm just trying to accomplish the hack; i almost never touch IORef's and rarely deal with MVar's so it's a bit of a flounder, sorry
19:37:54 <heatsink> henk: If you use an ambiguous grammar that could be parsed in multiple ways, then Parsec will resolve the ambiguity by a greedy parsing strategy.
19:38:08 <haasn> I don't understand the context of the problem. What do you need to communicate from where to where?
19:38:26 <heatsink> henk: Your parser allows ";;;" to be parsed as [";;;"], so that's what happens
19:38:46 <rasfar> hassn: due (I think) to some TH stuff involved with the Snaplet design (in particular)
19:39:09 <rasfar> i cannot partially apply my web server to get the MVar shared, as I do in a non-Snaplet Snap application
19:39:36 <rasfar> this is a work-around, but I'm probably misusing the global IORef
19:39:54 <haasn> if you're sure the MVar is going to be used globally and you make sure the type is monomorphic, you could perhaps unsafePerformIO it as a top level value
19:40:34 <rasfar> okay -- the suggestion I got was to wrap it: IORef (MVar a), so I assumed there was some need for both
19:40:35 <haasn> But that's with the disclaimer of me not knowing about snap or snaplets. It sounds to me there is a fundamental design issue somewhere if you need those kinds of hacks to get functionality
19:41:12 <rasfar> well, Snap was an afterthought in this case; the system is already big, and stands outside the snap framework.
19:41:29 <augur> anyone have a good intro book for functional programming i could recommend to people?
19:41:49 <augur> preferably something that focuses heavily on what counts as good (pure) functional design, etc.
19:41:56 <haasn> I like https://en.wikipedia.org/wiki/Functional_programming
19:42:04 <haasn> (non-sarcastic response)
19:42:12 <augur> haasn: :P
19:42:26 <rasfar> (this would be no problem if everybody needing the MVar lived under the snap umbrella)
19:42:45 <haasn> It's such a broad label that wikipedia's overview of the design space is the best thing I can attribute to it
19:42:55 <haasn> For more specialized information, see: more specialized resources
19:43:31 <haasn> rasfar: you could perhaps also use global configurations via ‘reflection’ or implicit params
19:43:39 <rasfar> i'll try it with a global MVar and no IORef wrapper, thank you -- this hack will not live more than two days
19:44:00 <rasfar> thanks hassn, i'll research those things too
19:44:30 <rasfar> *haasn even
19:44:34 <haasn> that is; generate something globally/on a top level; then pass it to whatever local context needs it via a type class - but that way you need to add the constraint to every type signature, recursively
19:44:38 <augur> also: anyone have a nice example of a monadic type checker that i could look at?
19:44:46 <haasn> so you might as well add a function parameter in the first place
19:44:58 <haasn> augur: like edwardk's bound?
19:45:05 <augur> haasn: no, bound isnt a type checker
19:45:11 <haasn> oh
19:45:20 <augur> bound is a way of handling names and binders
19:46:17 <edwardk> augur: you can look at daan leijen's HMF type checker. he does it 2 ways, with ST based references in one version an with maps, etc. in another.
19:46:19 <rasfar> haasn: it seems that adding a function parameter is not possible due to the template haskell, but I'm still uncertain and hoping
19:46:33 <augur> edwardk: ill give it a look
19:46:40 <augur> edwardk: i ask because http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/HaskellRetrospective.pdf
19:46:45 <augur> mentions a type checker that looks interesting
19:47:00 <augur> with code like this:
19:47:21 <augur> tcExpr (App fun arg)
19:47:22 <augur> = do { fun_ty <- tcExpr fun
19:47:22 <augur>    ; arg_ty <- tcExpr arg
19:47:23 <augur>    ; res_ty <- newTyVar
19:47:25 <augur>    ; unify fun_ty (arg_ty --> res_ty)
19:47:27 <augur>    ; return res_ty }
19:47:47 <haasn> I realized it was a simonpj paper the moment I saw those leading ;s
19:48:02 <edwardk> mark p jones wrote a typechecker for haskell that is probably the one in question, but it doesn't include generating a useful 'core' like witness
19:48:04 <haasn> I wonder why he does that
19:48:18 <edwardk> that was something we had to rediscover how to do in ermine
19:48:25 <augur> which apparently handles plumbing for exceptions/failure, current unification, type env, current source loc, and the fresh type vars
19:48:35 <heatsink> edwardk: Typechecking, or leading semicolons?
19:48:51 <edwardk> augur: anyways, what you probably are looking for is http://web.cecs.pdx.edu/~mpj/thih/
19:49:02 <augur> im especially interested in how this works. i dont know much about how people engineer these super fancy monads
19:49:16 <augur> Idris's backend monad is probably especially interesting
19:50:11 <augur> edwardk: hm! ill give this a look
19:50:54 <gtrambly> hrrrrrrrmmmm, does haskell have some kind of unordered tuple datatype somewhere?
19:51:04 <gtrambly> or will i just need to make one?
19:51:04 <heatsink> No
19:51:11 <haasn> gtrambly: depends on what you mean by unordered tuple
19:51:21 <gtrambly> just that (a, b) == (b, a)
19:51:22 <gtrambly> mostly
19:51:24 <heatsink> How would you pattern match on it?
19:51:31 <gtrambly> you wouldn't i don't think
19:51:44 <haasn> gtrambly: are you okay with requiring Ord on the members?
19:52:00 <gtrambly> mmmm that's acceptable i think
19:52:06 <gtrambly> oh
19:52:08 <augur> Set
19:52:11 <gtrambly> i see where you're going with this
19:52:32 <gtrambly> that's a good idea
19:52:38 <haasn> newtype Pair a = Pair (a,a); instance Ord a => Eq (Pair a) where Pair (x,y) == Pair (x',y') = sort [x,y] == sort [x',y']
19:53:09 <gtrambly> awesome, thanks!
19:53:22 <haasn> Haskell does not make this very easy otherwise. Things in Haskell have a rigid structure and order
19:53:45 <haasn> The best thing to do is to abstract around it
19:54:18 <haasn> (note: alternatively, hide Pair and write pair (x,y) = Pair (min x y, max x y); derive Eq etc.)
19:54:35 <henk> heatsink: IMHO non-greedy would make a hell of a lot more sense, would you agree?
19:55:07 <haasn> A first wild guess for me would be that greedy is more what I'd expect
19:55:07 <henk> heatsink: Just for sepBy I mean.
19:55:15 <haasn> But I haven't though about it a lot
19:57:01 <haasn> the solution, obviously, is to write an unambiguous parser
19:57:12 <haasn> That way the implementation detail does not matter
19:57:37 <haasn> I would be strongly in favor of noneOf ";"
19:57:41 <haasn> or satisfy (/= ';')
19:57:43 <haasn> or whatever
19:57:54 <rasfar> thanks haasn, pavonia: I see my mistake -- the type of the second argument in modifyIORef is not an action, but that of modifyMVar is. I'm having better luck without the IORef wrapper, which would seem to be unnecessary.
19:58:51 <heatsink> henk: Your example is parsing a semicolon-separated list of arbitrary strings.
19:59:16 <heatsink> henk: What should happen if ";;;;;" is parsed as a semicolon-separated list of semicolon-separated list of arbitrary strings?
19:59:42 <heatsink> Should the semicolons be part of the arbitrary strings, or inner list separators, or outer list separators?
20:00:21 <heatsink> The parser can't know which choice is right.
20:01:24 <kadoban> Anyone have strong thoughts on what database package to use for just simple web development work?  HDBC?  HaskellDB? Takusen? Other?
20:03:07 <monochrom> new article: http://www.vex.net/~trebla/haskell/IO.xhtml
20:05:12 <henk> heatsink: I come over and shoot you for choosing a seperator that may appear in entries.
20:06:35 <heatsink> henk: You're already dead for choosing entries that may contain separators.
20:08:36 <enthropy> kadoban: not all of those are mutually exclusive
20:09:18 <enthropy> haskellDB can use sqlite or postgres through some lower-level library (HDBC probably?)
20:10:22 <enthropy> there's also some newer ones (persistent / esqueleto)
20:11:14 <henk> heatsink: hm, choosing entries? I don’t quite follow, sorry.
20:11:51 <kadoban> enthropy: Yeah, I can't figure if there's a best choice or if I should just pick one/a combination or what
20:12:45 <enthropy> there aren't really many combinations that make sense
20:15:04 <heatsink> henk: A parser says how to translate some prefixes of the input into Haskell data.  Through parsers, we can relate strings to Haskell values.
20:15:36 <heatsink> For instance, the parser 'int' matches "0", "1", and "10", among other strings.  We can think of these strings as integers.
20:15:49 <heatsink> The parser (char ';') matches only ";".  We can think of that string as a separator.
20:16:08 <heatsink> The parser (many anyChar) matches "", ";", and "a", among other strings.  We can think of these strings as entries.
20:16:16 <heatsink> So ";" is both a separator and an entry.
20:20:05 <henk> heatsink: hrm, ok, good point, thanks. But I’m still not convinced it shouldn’t be non-greedy. I need to think about that some more though …
22:36:09 <alphonse23> would anybody mind looking at some code that creates a fractal
22:36:15 <alphonse23> I'm getting an error
22:36:19 <alphonse23> a really easy one
22:36:24 <alphonse23> about an argument
22:37:06 <Cale> lpaste.net :)
22:37:24 <joxn> hello #haskell
22:37:27 <joxn> anyone awake?
22:37:47 <alphonse23> here
22:37:51 <joxn> I want to declare a new type using data
22:38:11 <joxn> data Tree = Node a (Tree a) (Tree a) | Nil
22:38:19 <joxn> and I would like to restrict this type
22:38:29 <joxn> so that a has to be Ord
22:38:36 <joxn> can I do this in the data declaration?
22:38:42 <joxn> this is maddening to search for
22:40:51 * hackagebot gtk2hs-buildtools 0.12.5.2 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.12.5.2 (HamishMackenzie)
22:40:53 * hackagebot glib 0.12.5.4 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.12.5.4 (HamishMackenzie)
22:40:55 * hackagebot gtk3 0.12.5.7 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.12.5.7 (HamishMackenzie)
22:41:01 <heatsink> That feature isn't really useful
22:41:17 <heatsink> You can get the same result by restricting functions that operate on trees
22:41:32 <heatsink> It was removed in Haskell 2010
22:43:01 <cwvh> data Tree a = forall a. Ord a => Node a (Tree a) (Tree a) | Leaf
22:43:31 <alphonse23> what does an error like this mean? Expecting one more argument to `Array DIM2 R'
22:43:31 <alphonse23>     In the type signature for
22:43:32 <heatsink> That makes 'a' an existential typ
22:43:52 <heatsink> alphonse23: The type 'Array' takes another type parameter
22:44:00 <alphonse23> you need to include it
22:44:01 <alphonse23> ?
22:44:16 <alphonse23> can I just tac on a null in there
22:44:46 <alphonse23> like toImage :: Array DIM2 R null -> ...
22:44:49 <alphonse23> is that enough?
22:45:03 <alphonse23> enough to remove that specific error
22:45:14 <heatsink> > show (1 +)
22:45:16 <lambdabot>  "<Integer -> Integer>"
22:45:31 <heatsink> > 2 * (1 +)
22:45:32 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
22:45:33 <lambdabot>    arising from a use of ‘M60890273758996163397341.show_M60890273758996163397...
22:45:33 <lambdabot>  The type variable ‘a0’ is ambiguous
22:45:33 <lambdabot>  Note: there are several potential instances:
22:45:33 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
22:45:52 * hackagebot gtk 0.12.5.7 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.5.7 (HamishMackenzie)
22:45:54 * hackagebot svgcairo 0.12.5.1 - Binding to the libsvg-cairo library.  http://hackage.haskell.org/package/svgcairo-0.12.5.1 (HamishMackenzie)
22:46:01 <heatsink> alphonse23: What do you do if you don't want to give two arguments to (+) ?
22:46:48 <heatsink> > find [1, 2]
22:46:50 <lambdabot>  Couldn't match expected type ‘a -> GHC.Types.Bool’
22:46:50 <lambdabot>              with actual type ‘[t0]’
22:46:50 <alphonse23> well, say it wants two arguments, but you only want to give it one, then just stick in a null value. it will cause an error, but a different one from the first
22:47:04 <joxn> Can't make a derived instance of `Show (Tree a)':
22:47:04 <joxn>       Constructor `Node' must have a Haskell-98 type
22:47:04 <joxn>       Possible fix: use a standalone deriving declaration instead
22:47:04 <joxn>     In the data declaration for `Tree'
22:47:04 <pyon> Is there relatively low-precedence infix version of either?
22:47:18 <joxn> so is this why it's not useful?
22:47:18 <pyon> (either as in the function from Data.Either)
22:47:42 <heatsink> alphonse23: Usually your goal is to make working code, not to produce a different error.
22:47:53 <alphonse23> i suppose
22:48:14 <alphonse23> I'm still just trying to understand haskell
22:48:24 <heatsink> joxn: Are you using what cwvh wrote?
22:48:36 <cwvh> joxn: for the love of god don't use what I wrote
22:49:08 <cwvh> total brain fart
22:49:20 <heatsink> alphonse23:  Is two bigger than?
22:49:48 <alphonse23> what are you trying to ask?
22:49:53 <alphonse23> heatsink:
22:50:22 <heatsink> alphonse: I want to ask, "Is two bigger than?"
22:50:38 <heatsink> I know that usually you expect another word after "bigger than", but I don't want to put one there.
22:50:45 <jle`> alphonse23: null in hat case is just a normal type variable btw
22:50:52 * hackagebot webkitgtk3 0.12.6.1 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.12.6.1 (HamishMackenzie)
22:50:54 <jle`> Array DIM2 R null is the same as Array DIM2 R a
22:51:24 <heatsink> alphonse23: Saying "Array DIM2 R" is like saying "Is two bigger than?"
22:51:36 <cwvh> joxn: if you want to explore, re-write it like this:   data Tree = forall a. Ord a => Node Tree a Tree a | Leaf          then play around in ghci>   :t Node Leaf 3 (Node Leaf 'c' Leaf)         notice that you can stick heterogenous objects into the tree so long as they are Ord
22:51:42 <jle`> joxn: well, that just means that it can't derive the instance, but you can always write your own show instance
22:51:45 <heatsink> alphonse23: By leaving out information, you write something that is nonsense.
22:51:59 <alphonse23> okay, point understood
22:52:29 <cwvh> joxn: what heatsink wrote is how you want to approach it. Use constraints on your functions that manipulate your tree:     insert :: Ord a => a -> Tree a -> Tree a
22:52:40 <heatsink> The last parameter is the type that the array contains.  Does it contain Int?
22:53:39 <joxn> cwvh: I have done so
22:54:08 <alphonse23> > toImage :: Array DIM2 R -> Array DIM3 Word8
22:54:09 <joxn> I was just hoping that I could provide a restriction on the type and do away with the restrictions on the functions
22:54:10 <lambdabot>  Not in scope: type constructor or class ‘DIM2’Not in scope: type constructor...
22:54:21 <alphonse23> i think that line is from the repa library
22:54:35 <jle`> you joxn why?
22:54:38 <jle`> sorry
22:54:40 <jle`> joxn: why?
22:54:52 <jle`> joxn: those functions would have those restrictions anyway, right?
22:55:53 * hackagebot webkit 0.12.6.1 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.12.6.1 (HamishMackenzie)
22:56:23 <jle`> those functions wouldn't magically work for non-Ord things
22:56:25 <joxn> jle`: couldn't the type checker infer the restrictions on the functions given the restrictons on the type?
22:56:36 <cwvh> joxn: unfortunately not
22:56:38 <jle`> the functions would still be limited to Ordy things anyway
22:56:43 <jle`> even if it did
22:56:44 <heatsink> alphonse23: 'Array' takes three parameters: a representation, a shape, and an element type.
22:57:09 <jle`> you only want to avoid explicitly writing them out?
22:57:17 <heatsink> alphonse23: Repa uses types in sophisticated ways.  It's not a good place to start learning Haskell.
22:57:27 <alphonse23> so i need the specify its type in the last parameter
22:57:38 <jle`> the type of the things it contains
22:57:47 <heatsink> ^
22:57:55 <jle`> an array of Ints, an array of Doubles
22:57:56 <jle`> etc.
22:58:16 <jle`> try checking out simon marlow's repa tut, it is a good companion :)
22:58:45 <joxn> jle`: it seems to me if we know that: f :: a -> Tree a, and Tree a => Ord a, then f :: Ord a => a -> Tree a
22:58:58 <joxn> but whatever, it's not like I care too much
22:59:00 <jle`> http://chimera.labs.oreilly.com/books/1230000000929/ch05.html
22:59:12 <jle`> joxn: well, even if that is the case
22:59:15 <jle`> then f is still restricted
22:59:20 <jle`> you just want to move where the restriction is written
22:59:44 <joxn> yeah, but I have 4 functions that need an Ord a restriction whereas I could put it in one place on the Type'
22:59:59 <codygman> Anyone installed the X11 library on osx mavericks? I get ld: library not found for -lXss even though I have the command line tools installed.
23:00:21 <joxn> three functions
23:00:23 <joxn> anyway
23:00:57 <nisstyre> codygman: this may not be the right channel for that. Also are you sure you have the right linker command?
23:01:27 <jle`> i think the general consensus is that it's better to explicitly specify the constraint per function
23:01:36 <jle`> explicitly
23:01:39 <joxn> the real reason I care is that I spent a lot of time trying to figure out how to put a class restriction on a data declaration only to begin to suspect that it's not possible.
23:01:41 <jle`> oh i said that already
23:01:45 <nisstyre> codygman: seems to be -lx11
23:01:51 <joxn> but now I know!
23:01:52 <nisstyre> er -lX11
23:01:55 <joxn> thanks!
23:01:55 <jle`> joxn: it's actaully possible with an unmaintained, strongly discouraged extension
23:01:58 <jle`> but don't tell anyone :)
23:02:08 <codygman> nisstyre: Hmm, I guess I'll have to figure out how to change that in the installer for X11. Thanks!
23:02:47 <nisstyre> codygman: are you using a makefile or something?
23:02:51 <jle`> and also i don't think it'd work the way you think
23:03:08 <jle`> s/unmaintained/unsupported
23:03:40 <codygman> nisstyre: I'm not sure what the x11 binding is using, I'm cloning the source now though.
23:04:02 <nisstyre> codygman: what I mean is are you building it by typing "make" or some variant of that?
23:04:18 <codygman> nisstyre: No, I was just doing "cabal install"
23:04:23 <nisstyre> ah okay
23:05:04 <nisstyre> codygman: can you link to the package you're trying to install?
23:05:34 <codygman> nisstyre: http://hackage.haskell.org/package/X11-1.6.0.2 (I'm using ghc 7.8.1)
23:06:01 <nisstyre> codygman: and you have installed X11 itself, right?
23:06:17 <nisstyre> you have xlib available and everything right?
23:06:57 <nisstyre> (tbh I would recommend against it even if you did have it)
23:07:05 <nisstyre> using xlib is not a great idea
23:07:12 <nisstyre> unless you really need it for some task
23:08:21 <notadog> I am trying to learn/use error handling, and after importing Control.Exception (try) and using try, I get
23:08:26 <notadog> No instance for (GHC.Exception.Exception e0)
23:08:28 <notadog>       arising from a use of `try'
23:08:30 <notadog>     The type variable `e0' is ambiguous
23:08:32 <notadog>     Possible fix: add a type signature that fixes these type variable(s)
23:08:34 <notadog>     Note: there are several potential instances:
23:08:35 <codygman> nisstyre: Basically I'm just trying to use osxmonad: https://bitbucket.org/puffnfresh/osxmonad
23:08:49 <codygman> though I'm starting to think I should just install debian on the macbook my work gave me
23:08:51 <notadog> it then lists quite a few instances available. How do I specify which one to use?
23:09:01 <nisstyre> codygman: that would be a good idea
23:09:09 <heatsink> notadog: Choose based on which errors you want to catch
23:09:29 <notadog> heatsink: sure, I mean how do I actually choose. Ie if I want NonTermination instance.
23:09:31 <codygman> nisstyre: Or maybe nix ;)
23:09:42 <codygman> nixOS*
23:09:44 <nisstyre> codygman: so if you do cabal install xmonad, it tries to pull in X11, which fails to build, right?
23:09:52 <codygman> nisstyre: That is correct
23:10:09 <nisstyre> yeah, I don't know. I don't have a mac to try and reproduce it
23:10:15 <heatsink> notadog: Add a type signature to the return value of 'try'
23:10:18 * nisstyre is on Linux everywhere
23:10:38 <heatsink> notadog: Is the return value used somewhere?
23:11:09 <codygman> nisstyre: Yeah, this is the first time I've used osx. It's pretty but I' not nearly as productive without apt-get(brew is okay) and xmonad.
23:11:36 <notadog> heatsink: so I am trying to run an IO function called client, which has no return value. so would I do something like "try client :: NonTermination"?
23:11:58 <notadog> heatsink: I am new to haskell, and it is my first language as well so...
23:12:33 <heatsink> :t try
23:12:34 <lambdabot> Exception e => IO a -> IO (Either e a)
23:13:21 <heatsink> That type says that 'try' takes an action returning an 'a', and produces an action returning an 'Either e a'
23:13:40 <heatsink> :t print "hello"
23:13:41 <lambdabot> IO ()
23:14:04 <heatsink> That is an action that doesn't return anything interesting.  In this case, 'a' is ().
23:14:17 <Cale> Actually, you probably just want to case on the result, and match against some constructor of NonTermination in the Left branch
23:14:30 <heatsink> :t try (print "hello")
23:14:31 <lambdabot> Exception e => IO (Either e ())
23:14:39 <Cale> res <- try client
23:14:42 <Cale> case res of
23:14:59 <Cale>   Left (NonTermination ...) -> ... handle exception somehow ...
23:15:20 <Cale>   Right () -> ... success ...
23:15:30 <notadog> heatsink: Cale: "try (print "hello") gives me the same error when I try and compile.....
23:15:37 <notadog> oops missed a quote there.
23:15:50 <Cale> notadog: The key is just to pin down what type the result has in the exceptional case
23:15:57 <startling> notadog, yes, because it can't guess what 'e' you have.
23:16:00 <Cale> You need to write enough code to make that obvious
23:16:08 <notadog> Oh ok, sorry. I think I get it now.
23:16:31 <Cale> If you don't want to write that code, you can write an explicit type signature, but usually whatever you were going to do in the exceptional case will help determine the type anyway.
23:16:40 <notadog> Like how "read" needs to be used somewhere so ghc knows whether to cast to Int, String, etc.
23:16:42 <notadog> ?
23:16:47 <Cale> right
23:17:18 <alphonse23> is it possible to tell ghc to run with a particular version of a library
23:17:25 <alphonse23> or even a particular version of haskell?
23:17:28 <notadog> Hmmmm ok. Thanks Cale, startling and heatsink.
23:17:54 <startling> alphonse23: it depends what you mean by "version of haskell".
23:17:54 <alphonse23> like what if I wanted my script to run with repa 3.1, currently it's 3.2.3
23:18:02 <heatsink> alphonse23: You can use a command line flag to specify a version number, like -package repa-3.1
23:18:10 <startling> alphonse23: but yes, that's possible. typically we manage that with cabal.
23:18:51 <alphonse23> cool, i think that specifying the type in repa arrays only came about recently, the reason I've been asking about it is because I'm trying to get a piece of code from 2011 to work
23:20:56 * hackagebot tianbar 0.4.0.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.4.0.0 (AlexeyKotlyarov)
23:28:18 <heatsink> alphonse23: The first parameter, 'R', was added in Repa version 3.
23:28:45 <heatsink> alphonse23: So Array DIM2 Int becomes Array U DIM2 Int
23:31:06 <alphonse23> when was the type parameter added, or was that there before version 3.x?
23:31:17 <alphonse23> heatsink:
23:32:09 <heatsink> It appeared in version 3
23:33:35 <heatsink> You can browse older versions' documentation on hackage to see how the API changed
23:33:46 <alphonse23> i will check that out
23:34:17 <zzing> Is there a common name for <*>? (imagine if I were trying to implement this is another unnamed language, what might it be called)
23:34:19 <alphonse23> i feel like version control must be a really important aspect of haskell since it's old -- i guess....
23:34:54 <prophile> zzing: ap
23:35:11 <zzing> prophile: any longer name?  (apply?)
23:35:26 <heatsink> applicious
23:35:40 <prophile> app jr.
23:36:03 <zzing> applicious? :P
23:46:00 * hackagebot tianbar 0.4.0.1 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.4.0.1 (AlexeyKotlyarov)
