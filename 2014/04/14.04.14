00:00:20 <haasn> http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Graph.html is an example of this in action, by the way
00:01:30 <startling> raphie_: I don't understand what kind of pattern-matching you're talking about.
00:02:20 <startling> raphie_: anyway, you don't *need* to represent a cyclic graph this way; you just need to if you want to be able to detect cycles.
00:02:32 <raphie_> yeah, that makes sense
00:03:00 <raphie_> well an example of pattern-matching would be:
00:03:33 <raphie_> actually nevermind, solved my own problem!
00:03:37 <startling> :)
00:07:08 <eatman> Hello
00:07:40 <tar_> howdy
00:18:50 <Ptival> hello, I have a Parsec issue, I have a parser termP = p1 <|> p2, and a term that ought to be p2, but it has a prefix that is a p1. My problem is that (termP <* eof) is not the same as (p1 <* eof) <|> (p2 <* eof), so the parse fails with (termP <* eof) because p1 finishes succesfully but then eof is not there yet
00:20:08 <Feuerbach> Ptival: either refactor your parser or use try
00:20:16 <Feuerbach> the former is preferable if possible
00:20:51 <Feuerbach> i.e. f <$> p1 <*> (eof <|> p3 <* eof)
00:21:07 <startling> the latter is easier and not as much of a big deal as people act like it is. :)
00:21:19 <identity> why do they? @ startling
00:21:22 <identity> wrt try.
00:22:47 <Feuerbach> or even f <$> p1 <*> (pure something <|> p3) <* eof
00:23:38 <Feuerbach> startling: it depends on the error reporting strategy used by the library
00:23:55 <Feuerbach> e.g. in trifecta using try may ruin error messages
00:24:07 <Feuerbach> in parsec it shouldn't, but error reporting is broken in parsec anyway
00:24:26 <startling> Why does using try ruin error messages in trifecta?
00:25:11 <Feuerbach> I do think that limiting backtracking is not that important, and am experimenting with a library to implement that
00:25:35 <Feuerbach> https://github.com/ekmett/trifecta/issues/28
00:27:33 <startling> ah, interesting
00:28:17 <tdammers> IMO, getting error reporting right in a backtracking parser-combinator requires extra information
00:28:36 <startling> I'm not sure that's *wrong*, but it is a little confusing.
00:28:45 <startling> I think giving the parser a name is the right answer.
00:28:53 <tdammers> idk
00:28:57 <tdammers> depends what you want
00:29:07 <startling> Yeah.
00:29:49 <tdammers> I think most of the time, confusion arises when you have a try parser that fails because of a syntax error in one of its child parsers
00:30:02 <Ptival> how would try help me though?
00:30:05 <startling> mhm.
00:30:15 <tdammers> the error is reported at the starting point of the backtracking, not at the point where the actual syntax error occurs
00:30:32 <Feuerbach> tdammers: again, that depends on the library
00:31:02 <tdammers> Feuerbach: does it? How can you tell which of several try-wrapped alternatives that all fail the user meant?
00:31:04 <Feuerbach> in Parsec, the error should be reported at the right position, although there are other issues with the error msgs
00:31:17 <Ptival> (also the problem is that termP is defined recursively, so I'd like the outermost call to require reaching eof, but not the recursive calls obviously)
00:31:21 <startling> tdammers, typically you go with the deepest one
00:31:33 <tdammers> example:
00:31:39 <tdammers> try A <|> try B
00:31:47 <tdammers> A fails in one of its sub parsers
00:31:51 <tdammers> B also fails
00:31:55 <Feuerbach> tdammers: easy: see which branch consumed more input
00:32:16 <tdammers> Feuerbach: that would be a guess, though, and not necessarily the right one
00:32:30 <Feuerbach> it's almost always is the right one
00:32:34 <startling> ^
00:32:38 <Feuerbach> except when you have an all-consuming branch
00:32:38 <tdammers> almost
00:32:43 <startling> I've seen some parsing libraries display errors as trees.
00:32:53 <tdammers> but yeah
00:32:53 <Ptival> tdammers: my problem is that when A succeeds, (A <|> B) <* eof may fail while B <* eof would have succeeded
00:33:14 <tdammers> Ptival: that's kind of an inherent problem of parser-combinators
00:34:11 <startling> Ptival, doesn't try (A <* eof) <|> (B <* eof) work?
00:34:43 <Ptival> startling: sure, but that's not very compositional :)
00:34:58 <tdammers> it's semantic though... kind of...
00:35:03 <Ptival> yeah it is
00:35:21 <startling> I'm not sure compositionality makes sense here.
00:35:26 <Ptival> I understand that (A <|> B) <* eof is not going to do what I want
00:35:33 <Ptival> I just wonder if I have to do something
00:35:41 <Ptival> I'll post my code and see your feedback
00:35:52 <tdammers> maybe adjust your mental model of what it is you're expressing and why (A <|> B) <* eof isn't the same
00:36:34 <Ptival> tdammers: as I said, I understand why it does not work
00:36:38 <startling> (<*) isn't distributive over (<|>)
00:37:11 <tdammers> startling: yeah, I guess that's the professional way of putting it :)
00:37:57 <startling> if you wanted compositionality, you'd do let f = (<* eof) in f a <|> f b or something
00:39:37 <Ptival> startling: yeah I guess I'm going to do that all over everything :\
00:40:04 <Feuerbach> wait, are you saying that (a <|> b) <* eof may be worse than (a <* eof) <|> (b <* eof)? How's that?
00:40:21 <Ptival> Feuerbach: if a successfully parses a prefix of the input
00:40:36 <Feuerbach> so what?
00:40:48 <Feuerbach> try should fix that
00:40:49 <Ptival> and if the input is "b<eof>"the left one fails, the right one succeeds
00:40:50 <erisco> Feuerbach, probably a backtracking problem
00:41:29 <Ptival> it is a backtracking problem
00:41:34 <erisco> if it were a parser with backtracking it would distribute
00:41:40 <Ptival> yes
00:43:32 <Feuerbach> (a <|> b) <* eof should be exactly equivalent to (a <* eof) <|> (b <* eof)
00:44:19 <Ptival> so maybe *I* should backtrack and ask this question: is there a way to, a posteriori, ask that a parsec parser consumes its entire stream?
00:44:51 <Feuerbach> eof does exactly that, doesn't it
00:45:20 <erisco> Feuerbach, imagine 'a' matches strings of a's and 'b' matches strings of b's, then imagine the input is "aaaaz"
00:45:54 <erisco> Feuerbach, (a <|> b) <* eof  and (a <* eof) <|> (b <* eof)  will do something different without backtracking
00:46:11 <Ptival> oh wait, I tried another example and it doesn't seem to do what I thought it would :\
00:46:28 <Feuerbach> erisco: can you create an executable example that'll show the difference?
00:46:29 <erisco> Feuerbach, oh sorry I gave a bad input example to demonstrate the problem
00:47:15 <Feuerbach> I mean, can you *try* to create one? :)
00:48:17 <erisco> Feuerbach, let me try again.  'a' matches the string "hello" and 'b' matches the string "helloworld".  if the input is "helloworld" then (a <|> b) <* eof  will fail  but  (a <* eof) <|> (b <* eof)  will succeed
00:48:18 <shachaf> Does there exist a good introduction to things like rank-n types to point people to?
00:48:48 <erisco> Feuerbach, in general the problem arises when 'a' has a word which is a prefix of some word of 'b'
00:50:08 <Feuerbach> erisco: did you try that?
00:50:17 <erisco> Feuerbach, yes
00:51:46 <Feuerbach> erisco: can you paste your test code?
00:52:04 <erisco> Feuerbach, I do not have test code but I can explain how a non-backtracking parser would fail
00:52:23 <Feuerbach> erisco: you said you tried it
00:52:27 <erisco> I have
00:53:23 <Feuerbach> here's my test code: http://lpaste.net/102677
00:53:24 <erisco> perhaps you do not trust me, but I am not inclined to bother to write the code for you :P
00:55:29 <jle`> is there a useful application of a Group typeclass
00:55:43 <jle`> i guess we could factor out Num into Group and Ring
00:55:57 <jle`> and have * and / be overloaded for all group/ring operations
00:56:00 <jle`> and + and -
00:56:06 <jle`> and...zero/one
00:56:35 <jle`> would there be any useful Group instances besides on numbers?
00:57:06 <jle`> finite lists maybe
00:57:19 <jle`> hm maybe not.
00:57:39 <erisco> Feuerbach, I do not know much about parsec
00:58:17 * hackagebot validation 0.3.3 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.3.3 (TonyMorris)
01:02:48 <viper99> > toLower <$> "hihi"
01:02:49 <viper99> smart
01:02:50 <lambdabot>  "hihi"
01:03:23 <viper99> do you prefer <$> or fmap?
01:04:00 <jle`> well for lists i almost always use map
01:04:34 <jle`> i usually use <$> when i am "applying" a function to a fote/wrapped object
01:04:39 <jle`> and fmap when i am lifting a function
01:04:44 <jle`> to work on wrapped objects
01:05:06 <jle`> like in a composition chain or sosmething
01:08:50 <c_wraith> I choose between <$> and fmap depending on whether I would rather have prefix or infix application
01:09:42 <Ptival> here's what I did, is this a reasonable/standard approach? http://paste.awesom.eu/frMJ
01:10:08 <Cale> I mostly use <$> if I'm also using <*> and not as much otherwise
01:11:45 <bergmark> i want 'kliesli fmap', <$< and >$>
01:12:29 <merijn> bergmark: You mean like "(a -> f b) -> (b -> f c) -> a -> f c"?
01:12:34 <merijn> bergmark: Because that's not possible
01:13:07 <merijn> That signature requires Monad to work
01:14:08 <bergmark> f <$< g = fmap f . g
01:14:58 <bergmark> so you can do f <$< g <=< h
01:15:39 <erisco> looks like fishes
01:15:46 <merijn> bergmark: That last line makes me think it's probably good that that doesn't exist
01:16:08 <merijn> erisco: ">=>" and "<=<" are usually called the fish operator :)
01:20:10 <bergmark> merijn: :-(
01:20:24 <startling>  different fishes.
01:20:29 <haasn> merijn: wait, why?
01:20:32 <haasn> (re: good idea)
01:20:43 <bergmark> it's annoying when i change something and have to reformat the line from f x <=< b to fmap (f x) . b
01:21:10 <haasn> bergmark: http://hackage.haskell.org/package/Kleislify-0.0.4/docs/Control-Kleislify.html
01:21:22 <haasn> Does this help?
01:21:53 <bergmark> well... i'll probably get fired if i use that or my version :-(
01:23:13 <merijn> haasn: Because I had no clue what that line did even with looking at the definition of "f <$< g"
01:23:31 <merijn> Which is not a good sign :)
01:23:40 <haasn> Huh, I thought it was pretty clear to me
01:23:41 <Cale> That module deserves to be under Acme.*
01:23:58 <haasn> It's like return . f <=> g
01:24:00 <haasn> err
01:24:05 <haasn> (return . f) <=< g <=< h
01:24:08 <haasn> sorry, I'm tired :P
01:25:07 <merijn> haasn: Why not just write  "fmap f . g <=< h", seems much simpler to understand
01:25:11 <haasn> merijn: compare with f <$> x <*> y <*> z  = pure f <*> x <*> y <*> z
01:25:17 <merijn> People know fmap, (.) and <=< already
01:26:09 <haasn> Personally I'm thrown off by figuring out which way that expression associates, but I guess in this case it doesn't really matter
01:26:09 <tdammers> the plural of "fish" is "fish".
01:26:42 <haasn> Cale: along with http://hackage.haskell.org/package/pointless-fun-1.1.0.5/docs/Data-Function-Pointless.html ?
01:27:34 <merijn> tdammers: fishes is an acceptable plural too
01:28:15 <iota_> .w 4
01:28:21 <iota_> oops, sorry
01:28:29 <tdammers> next you'll tell me it's "octopi" and "virii"
01:28:37 <tdammers> "oxes"
01:28:41 <tdammers> "childs"
01:28:49 <c_wraith> the great Seuss offers a lesson here:  "One fish, two fish, red fish, blue fish."
01:28:49 <haasn> “fishies”
01:28:58 <tdammers> swimmy thingies
01:29:28 <pharaun> @pl a b = c b & d b
01:29:28 <lambdabot> a = liftM2 (&) c d
01:29:31 <pharaun> doh
01:30:45 <merijn> tdammers: oxes is for the informal meaning of clumsy/stupid fellow according to my dictionary :p
01:30:52 <merijn> oxen is only for bovines
01:31:16 <Jafet> Dr. Seu
01:48:42 <merijn> hmm, why do I get "Sorry, it's just not here." for docs from base on hackage?
01:51:59 <quicksilver> "fishes" was good enough for don corleone and he wasn't the kind of guy you argue grammar with.
01:55:00 <lwm> haha
01:55:01 <merijn> And unrelatedly, how reliable are ForeignPtr's in terms of "prompt" finalisation, is it better to rely on explicit malloc/free (which brings with it the problem of tracking lifetime)
01:58:49 <quicksilver> my recollection is that foreignptr finalisers are guaranteed to run immediately after the GC in which the thing gets collected
01:59:04 <quicksilver> so your only uncertainty is the normal uncertainty of GC
01:59:14 <quicksilver> which you have at least some control over.
02:00:57 <merijn> Well, my question is basically: I care about efficiency, but I could probably live with finalizers lagging a couple of tens of ms after the Ptr gets GCed if that means not having to implement my own lifetime management
02:02:20 <quicksilver> that depends on all kinds of stuff
02:02:28 <quicksilver> like which generation they are in when they get GCed
02:02:36 <quicksilver> well
02:02:50 <quicksilver> there isn't a significant delay between GC and finalizers running (that happens immediately)
02:02:54 <quicksilver> the question is when the GC happens
02:03:13 <jle`> fishii ?
02:03:43 <merijn> quicksilver: Is there any heuristic for estimating how long until something is GCed?
02:06:48 <quicksilver> merijn: well you can tell the RTS you require major GCs every 100ms
02:06:51 <quicksilver> for example
02:06:52 <quicksilver> if you wish to.
02:07:05 <quicksilver> although it doesn't quite guarantee to *exactly* meet the time you ask for.
02:08:35 <merijn> quicksilver: ok, that's probably enough for me to live with
02:09:18 <merijn> Might be I could get away with considerably longer delays, I just don't wanna find out my API needs to be completely rewritten to not rely on ForeignPtr if it turns out I need shorter :)
02:09:31 <quicksilver> I suspect try it and see will be your friend :)
02:10:19 <rejuvyesh> Updated timezone-series for new GHC: https://github.com/rejuvyesh/timezone-series-git. Should I mail yitz to update the package?
02:10:28 <merijn> quicksilver: Right, but 100ms is well within my upperbound, so that means I can get it to work even in the worst case :)
02:10:31 <quicksilver> finalizers are slightly smelly, but doing resource tracking properly is hard.
02:12:05 <Jafet> The kinda-bad-but-we-totally-unit-tested-this case
02:13:01 <merijn> quicksilver: Well, I'm interacting with OpenCL, which explicitly allocates/deallocates things in the driver, and tracking lifetimes can be rather a pain there
02:13:17 <merijn> And leaking would be expensive in terms of memory
02:23:28 * hackagebot PBKDF2 0.3.1.4 - Make password-based security schemes more secure.  http://hackage.haskell.org/package/PBKDF2-0.3.1.4 (ErikHesselink)
02:49:45 <merijn> I take it there's no real difference between chs' inline "{# call safe someFoo #}" and an explicit "foreign import safe "someHeader.h someFoo" someFoo :: {- type here -}" and just using "someFoo"?
02:53:31 * hackagebot halberd 0.1.2.4 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1.2.4 (ErikHesselink)
03:08:33 * hackagebot pcre-light 0.4.0.1 - A small, efficient and portable regex library for Perl 5 compatible regular expressions  http://hackage.haskell.org/package/pcre-light-0.4.0.1 (DanielDiaz)
03:08:38 * tcard always uses Haskell Platform but is now investigating the comments by mightybyte on http://www.reddit.com/r/haskell/comments/22up8l/ghc_782_released/
03:09:24 <tcard> mightybyte recommends just installing cabal-install (via bootstrap.sh) on GHC
03:09:42 <tcard> and not installing any other global packages...
03:09:47 <tcard> any opinions on this?
03:10:00 <tcard> I have run into problems in my tests, for example with happy
03:10:18 * Lethalman never used haskell platform, at least on linux
03:10:41 <tcard> Lethalman: I am on Linux
03:10:44 <Lethalman> plain ghc with cabal
03:10:58 <MP2E> It's a matter of avoiding dependency hell
03:11:16 <bezirg> guys, are you upto for a cloud-haskell question? because all ppl at #distributed-haskell are away... :(
03:11:21 <Lethalman> MP2E, you may get in even worse hell if your distro does not ship with an up-to-date haskell lib
03:11:37 <tcard> Do you avoid installing happy in --global?
03:11:43 <Lethalman> in which case, you are back to cabal
03:11:59 <MP2E> True, which is why I'd generally advise against using distro repositories for haskell
03:12:02 <MP2E> that's the same issue
03:12:11 <bezirg> Locally, playing with Cloud Haskell, I used the simplelocalnet backend, but for deployment I cannot support UDP multicast. How can I connect two haskell nodes if I have both their IPs?
03:13:28 <tcard> I get a "setup: The program happy is required but it could not be found" error when running "cabal install happy".
03:13:56 <tcard> If I just "cabal fetch happy" and then configure and build cabal via Setup.py, it compiles without error.
03:14:41 <tcard> I am installing happy directly because it was not installed when I did a "cabal install hlint"
03:19:37 <anax> I want to declare a type alias to Data.Map with particular key and value types. I tried newtype Env = M.Map String Var but it doesn't compile because I use a qualified name for Map
03:20:48 <Jafet> No, it is because newtypes need new constructors.
03:21:39 <ocharles> @djinn (forall a. m a -> n a) -> ((msg -> m ()) -> m a) -> ((msg ->
03:21:39 <ocharles>            n ()) -> n a)
03:21:39 <lambdabot> Cannot parse command
03:21:41 <ocharles> bah
03:21:42 <anax> Thank you. I tried Env = Env (M.Map ....) and it works
03:21:50 <ocharles> @djinn (forall a. m a -> n a) -> ((msg -> m ()) -> m a) -> ((msg -> n ()) -> n a)
03:21:50 <lambdabot> -- f cannot be realized.
03:21:54 <ocharles> is djinn right in its assement there?
03:22:05 <ocharles> I think I need an (n a -> m a) too to make it work
03:24:36 <Maxdamantus> @djinn (forall a. a -> b) -> c -> b
03:24:37 <lambdabot> -- f cannot be realized.
03:29:48 <mozjag> I'm sure this is a solved problem, but I can't seem to Google my way out of this: `which cabal` -V  -->  1.18.0.3   while cabal -V --> 1.16.0.2
03:30:29 <fprivacy> bezirg: There was a zeromq backend for cloud haskell posted recently
03:31:33 <fprivacy> bezirg: http://haskell.1045720.n5.nabble.com/ANN-network-transport-zeromq-0-1-td5746568.html
03:31:44 <k00mi> mozjag: you probably have cabal installed via your package manager and via cabal itself
03:32:23 <mozjag> k00mi: I used the haskell platform package to install it on my Mac, then after cabal update I ran cabal install cabal-install
03:32:37 <mozjag> k00mi: so yes, so far, I'm with you. What next though?
03:32:52 <supki> mozjag: have you tried restarting the shell?
03:33:22 <mozjag> Let me try that
03:33:37 * hackagebot hums 0.6.0 - Haskell UPnP Media Server  http://hackage.haskell.org/package/hums-0.6.0 (BardurArantsson)
03:33:47 <mozjag> *groan*
03:33:49 <geekosaur> mozjag: hash -r
03:33:51 <mozjag> Thank you :-)
03:34:21 <geekosaur> (makes the shell forget its current hash table of found commands and check $PATH again)
03:34:36 <mozjag> Thank you both!
03:34:59 <mozjag> Also: cached path look-up? Urgh, good to know.
03:35:28 <mozjag> Alright, gotta run now, but again thank you for the quick help
03:35:35 <geekosaur> (also a good example of why `which` shouldn't be blindly trusted; it shows what a new PATH search would show, `type` shows what the shell itself believes)
03:35:57 <mozjag> Ooh! TIL :-)
03:37:02 <geekosaur> ...except that in some shells `which` may do what `type` does, or may do something different like showing what your dotfiles currently say and therefore what logging out and back in would show but possibly not what a new shell would show depending on how you started it)
03:37:59 * tcard is trying to install happy into a cabal sandbox using "cabal install happy" but gets "setup: The program happy is required but it could not be found"
03:38:01 <tcard> any tips?
03:38:03 <geekosaur> `which` is not exactly the most consistent command out there
03:51:03 <merijn> I take it there's no real difference between chs' inline "{# call safe someFoo #}" and an explicit "foreign import safe "someHeader.h someFoo" someFoo :: {- type here -}" and just using "someFoo"?
04:07:52 <bahamas> anyone know why the person who made the 99 problems for haskell page doesn't like the letter 'j'?
04:13:20 <techtangents> Hi, all. Wondering if somebody could please help me?
04:13:20 <techtangents> I'm building an 'alternating list' of two types, e.g. 3 :/ 'a' :/ 5 :/ 'c
04:13:28 <techtangents> ':/ ABNil
04:13:39 <techtangents> Basic code here: https://gist.github.com/anonymous/10638436
04:13:50 <techtangents> I would like to know how to reverse the list.
04:13:51 <matheus23> > 0 / 0
04:13:53 <lambdabot>  NaN
04:13:55 <techtangents> And I'm pretty stuck.
04:14:00 <matheus23> shouldn't this be 0?
04:14:15 <merijn> matheus23: Why?
04:14:33 <matheus23> merijn: Well... I'm not mathematician, but that's what I learned in school :S
04:14:38 <merijn> matheus23: Pretty sure IEEE754 defines all division by 0 to be NaN
04:14:53 <merijn> matheus23: What school taught you is completely irrelevant to Double
04:15:03 <matheus23> merijn: And what about 'real' mathematics?
04:15:04 <merijn> matheus23: Double follows IEEE754 floating point standard
04:15:17 <merijn> Real mathematics is even more irrelevant for Double
04:15:38 <matheus23> Hmm... But why didn't they allow 0 / 0 = 0? What are their reasons?
04:15:41 <techtangents> IEEE doubles aside, 0 / 0 should be a compile error, shouldn't it?  Divide by zero is not defined.
04:15:44 <jesyspa> > 1 / 0
04:15:46 <byorgey> matheus23: in that case, unfortunately, your school taught you incorrectly.  even in real mathematics  0 / 0  is not 0.
04:15:46 <lambdabot>  Infinity
04:16:03 <jesyspa> I think pos / 0 is +Infinity and neg / 0 is -Infinity.
04:16:14 <merijn> techtangents: "division by zero is not defined" <- for the naturals, real, etc. but that's irrelevant as Double are none of those
04:16:39 <matheus23> byorgey: okay...
04:16:55 <merijn> For all the bad things you can say about floating points (and there's a lot!), at least everything is very specifically defined
04:17:11 <identity> > (3 :: Int) / 0
04:17:13 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
04:17:13 <lambdabot>    arising from a use of ‘GHC.Real./’
04:17:16 <identity> eh
04:17:18 <merijn> And the only specification of what is correct for floating points is IEEE754
04:17:21 <identity> > (3 :: Int) `div` 0
04:17:23 <lambdabot>  *Exception: divide by zero
04:17:26 <matheus23> > (3 :: Int) `div` 0
04:17:28 <lambdabot>  *Exception: divide by zero
04:17:49 <matheus23> merijn: do they say something about their reasons?
04:18:30 <merijn> matheus23: Probably, they're specified in a way to be convenient and predictable when doing stuff like computational physics
04:18:45 <merijn> i.e. avoiding errors due to drift, etc.
04:18:56 <tcard> https://www.google.com/#q=zero+divided+by+zero
04:19:15 <tcard> (for example, see the Khan Academy video for an easy explanation)
04:19:37 <identity> merijn: so there are no purely technical reasons for 0 / 0 being that? I don't remember the ieee754 implementation well enough
04:19:37 <merijn> Khan Academy is hardly an authorative math source
04:20:05 <merijn> identity: The purely technical reasons are: division by 0 is not defined
04:20:08 <tdammers> floats are weird anyway
04:20:19 <merijn> identity: What else would you expect it to return?
04:20:37 <tcard> merijn: true, but it might be approachable to people who do not already know about 0/0
04:20:39 <byorgey> merijn: oh come on, "X is not defined" is not a reason for anything.
04:21:03 <identity> merijn: Yes, I know as much. But using integers, etc, you get an exception. I merely wondered if some implementation detail required/lead to 0/0 = NaN or something.
04:21:05 <tdammers> anyway, the way I see it, there are two arguably correct responses for 0/0: erroring out, and returning a "magic" value like NaN
04:21:09 <merijn> byorgey: Isn't it?
04:21:12 <merijn> byorgey: Why not?
04:21:30 <merijn> identity: Adherence to IEEE754 requires returning NaN
04:21:41 <identity> merijn: Okay then. so it's just a matter of definition
04:21:45 <byorgey> it is a reason, I suppose, but it is rather unsatisfactory, since it has no explanatory power
04:21:47 <merijn> identity: Right
04:21:55 <byorgey> and it raises the immediate question of *why* something is not defined
04:22:04 <tcard> http://www.math.utah.edu/~pa/math/0by0.html
04:22:16 <merijn> byorgey: The explanation is: lots of smart people thought hard on it and defined 0/0 = NaN in IEEE754 and haskell just follows IEEE754 for Double
04:22:30 <merijn> byorgey: If people want a rationale they can go read IEEE754...
04:22:42 <quicksilver> pedantic interjection: haskell does not specify that 0/0 is NaN.
04:22:56 <identity> quicksilver: i think that has already been established
04:22:58 <quicksilver> haskell merely allows that implementations *may* follow ieee754 if they wish.
04:22:59 <byorgey> merijn: OK, for IEEE754, sure, but I think IEEE754 is just a red herring here.  apparently matheus23 learned *in school* that  0/0 = 0, which is the more important issue.
04:23:07 <merijn> Although the most likely reasoning for them defining 0/0=NaN is that division by zero is not defined
04:23:11 <identity> byorgey: hah, that's true.
04:23:18 <identity> Or he remembers incorrectly.
04:23:43 * hackagebot creatur 5.3.1 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.3.1 (AmyDeBuitleir)
04:23:46 <merijn> byorgey: Probably he was taught "0/x=0"
04:23:47 <byorgey> in fact, of any division by 0,  0/0 = 0  is the most defensible, since one would expect  a/b = c  iff  a = b*c
04:23:55 <byorgey> which is satisfied for  a,b,c = 0
04:24:00 <tdammers> merijn: OTOH, arguing in terms of real numbers when the topic is floats is kind of wrong, too
04:24:08 <byorgey> there ARE good reasons for saying  0/0  is undefined/indeterminate but they are a bit more subtle.
04:24:16 <tdammers> for IEEE floats, 0/0 *is* defined
04:24:26 <tdammers> (as NaN)
04:25:40 <techtangents> NaN: the number that isn't. The oxymoron of floats :)
04:26:02 <tdammers> techtangents: NaN is a perfectly well-defined value for floats
04:26:26 <tdammers> it doesn't match up with real-number based expectations, but floats aren't like reals anyway
04:26:29 <matheus23> > 10 / 0
04:26:30 <lambdabot>  Infinity
04:26:34 <matheus23> > 0 / 0
04:26:35 <lambdabot>  NaN
04:26:51 <tdammers> > (-10) / 0
04:26:53 <prophile> NaN is useful, what else would you expect {}+{} to evaluate to in JavaScript?
04:26:53 <lambdabot>  -Infinity
04:27:01 <techtangents> ehehe
04:27:02 <matheus23> > (- (0 :: Double)) / 0
04:27:04 <lambdabot>  NaN
04:27:15 <matheus23> prophile: good one ;)
04:27:28 <nh2> does anybody know if with accelerate I can allocate a large array on the GPU, and then run interleaved Acc and IO actions, with the large array staying and being modified on the GPU all the time?
04:27:32 <tdammers> not the "wat" one again nplease
04:27:53 <matheus23> tdammers: I loved it ^^
04:27:53 <prophile> all the examples from the wat talk make sense once you know the details
04:27:57 <prophile> a warped kind of sense
04:28:06 <tcard> techtangents: what do you want (reverse ABList) to do?
04:28:16 <matheus23> prophile: implicit type conversion doesn't make sense at that level anymore, does it?
04:28:17 <techtangents> Reverse the list.
04:28:29 <prophile> it basically boils down to automatic stringification and the fact that {}+whatever turns into +whatever because {} is an empty code block
04:28:39 <tdammers> "wat" is nice and funny and all, but it doesn't really prove a lot
04:29:03 <matheus23> prophile: so why doesn't it return the function +?
04:29:04 <tdammers> except that when you feed improper stuff to a dynamically typed language, the results aren't going to be intuitive
04:29:08 <tdammers> duh.
04:29:09 <prophile> matheus23: hah
04:29:27 <prophile> + is a unary operator if you're actually looking for the answer to that
04:29:52 <matheus23> prophile: so it automatically converts {}+{} into {};+{}?
04:30:06 <prophile> I wouldn't say that
04:30:15 <prophile> more that {}+{} *IS* {}; +{}
04:30:22 <prophile> that's what the parsing rules specify
04:30:42 <identity> prophile: I understand what you mean by 'makes sense' as in 'it can be explained', but it still doesn't .. make sense.
04:30:47 <identity> why not a parsing error? etc..
04:30:55 <matheus23> how does it know that doStuff() + myResult() is not doStuff(); + myResult()?
04:31:06 <tdammers> identity: because it's not invalid syntax
04:31:06 <matheus23> identity: that's exactly what I'm thinking
04:31:09 <prophile> identity: I'd argue it's a semantic thing rather than a syntactic thing
04:31:26 <tim-m89> map (^2) [2, 3, 4]
04:31:29 <prophile> and the answer is "because Brendan Eich"
04:31:43 <matheus23> > map (^2) [2, 3, 4] -- tim-m89
04:31:45 <lambdabot>  [4,9,16]
04:31:49 <identity> prophile: well, you said 'parsing rules' specify. It's silly semnatics / language parsing / voodoo magic / whatever in any case
04:31:57 <jonathanj> so what is {1}? the number value 1?
04:31:58 <prophile> oh, I see what you mean
04:32:12 <techtangents> tcard: the reverse of an ABList a b can either be an ABList a b or an ABList b a, depending on whether the list ends in an a or a b.
04:32:13 <techtangents> so reverse (a :/ b :/ ABNil) = b :/ a :/ ABNil, which is an ABList b a
04:32:13 <techtangents> but reverse (a1 :/b :/ a2 :/ ABNil) = a2 :/ b :/ a1 :/ ABNil, which is an ABList a b
04:32:26 <tcard> techtangents: how about using [Either a b] instead?
04:32:32 <prophile> jonathanj: presumably so, yes
04:32:34 <matheus23> jonathanj: yup, {1} = 1 (evaluated in chrome console)
04:32:39 <jonathanj> but +{1} is a syntax error
04:32:48 <jonathanj> (in the Firefox console)
04:32:54 <identity> what about {1}+{1}?
04:32:57 <prophile> yes, because there the {} is parsed as an object literal
04:33:00 <identity> or {1}+1?
04:33:04 <prophile> and an object literal needs keys
04:33:09 <jonathanj> {1}+1 is 1
04:33:11 <prophile> {1}+1 is 1
04:33:13 <prophile> yeah
04:33:29 <identity> wat.
04:33:35 <merijn> This seems moderately offtopic
04:33:36 <jonathanj> prophile: so why is +{1} parsed as an object literal but {1} isn't?
04:33:47 <techtangents> tcard: I have that operation in the library I'm building. Keen on this signature.
04:34:00 <jonathanj> merijn: massively, sorry
04:34:20 <prophile> essentially, because as a statement blocks are prefers, but in the former case it's inside an expression context
04:34:33 <prophile> merijn: apologies
04:34:38 <matheus23> I think, having {} characters as literal for blocks and objects at the same time, is not only confusing the parser/compiler, but also the newcomers trying to learn javascript
04:36:31 <tcard> techtangents: are you able to create an instance of ABList (before calling reverse)?
04:37:08 <techtangents> tcard: sorry, not sure what you mean
04:37:45 <tcard> techtangents: can you create an example of an ABList?  For example, use let to assign an instance of ABList to a variable in ghci.
04:38:45 * hackagebot cookie 0.4.1.1 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.4.1.1 (MichaelSnoyman)
04:39:28 <tcard> techtangents: I ask because it might point out the difficulty of this type of signature when using ambiguous values (such as `1`).
04:39:39 <techtangents> tcard: https://gist.github.com/techtangents/10640134
04:40:58 <tero-> what's happening with haskell platform? "Next release: 2013.4.0.0"
04:41:11 <tcard> techtangents: ah, sorry about tha, I forgot a `:/`! ;)
04:41:17 <merijn> tero-: On hold due to the delay of 7.8
04:41:24 <tero-> merijn: ok
04:41:35 <merijn> tero-: They didn't want to release a new 7.6 platform because 7.6 is broken on OSX 10.9
04:41:55 <merijn> tero-: With GHC7.8 released last week the new platform should be soon
04:41:56 <tero-> not breaking things is a virtue
04:42:01 <spacekitteh> is Yampa still the go-to FRP library?
04:42:11 <prophile> netwire seems nice
04:43:32 <spacekitteh> hmm, oh yeah, i forgot about netwire
04:43:38 <Philonous> spacekitteh, Yampa hasn't been updated in years. reactive banana and netwire seem to be en vogue now.
04:44:54 <techtangents> tcard: thanks for your help. I've gotta go to bed. If you're curious, the full code is at https://github.com/techtangents/ablist
04:45:18 <tcard> techtangents: no problem
04:47:03 <edwardk> haasn: i prefer to think that trifecta does the right thing when try is used for parsing LL style grammars, while parsec randomly loses tokens it should tell you about. ;) that said, for the scenario where you need to race parsers trifecta needs to pick up another combinator so both usecases are covered.
04:48:10 * haasn is not sure what that was a reply to
04:49:11 <edwardk> oh, it was to startling, my bad
04:52:35 <spacekitteh> Philonous: yeah, looks that way.
04:58:12 <\tim> Wld anyone benefit if i develop this fork: https://github.com/tim-m89/Salsa
04:58:48 * hackagebot shellmate 0.1.4 - Simple interface for shell scripting in Haskell.  http://hackage.haskell.org/package/shellmate-0.1.4 (AntonEkblad)
05:02:10 <pordan30> Is it possible to write an instance of Foldable for Data.Map.Map that reduces with key values (e.g., foldMap (Bin s k v l r) = foldMap f l `mappend` f (k, v) `mappend` foldMap f r)? My guess is no, given the types of the Foldable members, but I'd rather be safe than sorry.
05:03:39 <erisco> pordan30, not sure if it helps but you could consider converting the map to [(k,v)] which is Foldable
05:06:53 <pordan30> erisco: Thanks for the suggestion. I was hoping to eliminate the construction of intermediate data structures, but it appears this isn't possible.
05:07:19 <BoR0> the main difference between foldr and foldl is that foldr defers the calculation. but, in this sense, in what cases  is foldr useful?
05:07:30 <haasn> pordan30: lens exports FoldableWithIndex
05:07:43 <Adeon> does haste compiler have an IRC channel or some other place where I could ask quick questions?
05:07:50 <haasn> which is basically an abstraction for this kind of thing
05:07:57 <erisco> BoR0, they have different associativity, that is the main thing
05:08:02 <edwardk> :t ifoldMap
05:08:03 <lambdabot> (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
05:08:16 <BoR0> erisco, I understand that. but in what cases would I use foldr instead of foldl ?
05:08:32 <erisco> > (foldr (+) 0 [-1,-1,-1], foldl (+) 0 [-1,-1,-1])
05:08:33 <lambdabot>  (-3,-3)
05:08:39 <erisco> erm
05:08:47 <merijn> + is associative
05:08:51 <erisco> thanks
05:08:55 <BoR0> aha
05:09:02 <BoR0> > (foldr (-) 0 [-1,-1,-1], foldl (-) 0 [-1,-1,-1])
05:09:04 <lambdabot>  (-1,3)
05:09:06 <erisco> > (foldr (-) 0 [1,1,1], foldl (-) 0 [1,1,1])
05:09:07 <lambdabot>  (1,-3)
05:09:08 <haasn> > (foldr const 0 [1,2,3], foldl const 0 [1,2,3])
05:09:09 <erisco> that is what I meant
05:09:10 <lambdabot>  (1,0)
05:09:16 <BoR0> excellent
05:09:17 <BoR0> thanks
05:09:28 <haasn> > foldr f z [a,b,c]
05:09:29 <lambdabot>  f a (f b (f c z))
05:09:30 <haasn> > foldl f z [a,b,c]
05:09:32 <lambdabot>  f (f (f z a) b) c
05:09:41 <erisco> so you decide which you want based on the associativity you want
05:09:58 <pordan30> haasn: Thanks, I'll take a look at FoldableWithIndex.
05:09:58 <erisco> if it does not matter than you can use either :)
05:10:10 <BoR0> but foldr is prone to stack overflow error, isn't it? or did I read wrong
05:10:36 <Peaker> whew.. had a modifyMVarMasked hidden somewhere, causing almost all of my code to run (incorrectly) masked, getting weird deadlocks.. finally found that one
05:10:47 <Peaker> Haskell could really use some better debugging facilities
05:10:58 <Peaker> adding prints everywhere wasn't the most efficient thing in the world
05:11:00 <quchen> No, it's not about (primarily) about associativity. foldr can consume a list lazily, foldl cannot. But there are tons of blog posts about this issue.
05:11:03 <haasn> pordan30: it's much more complicated than that, and mostly implementation specific
05:11:07 <tcard> http://www.well-typed.com/blog/90/
05:11:19 <haasn> pordan30: there's no sweeping generalization - all three have a reason for existing
05:11:21 <tcard> BoR0: ^ Fixing foldl
05:12:02 <Peaker> I even searched for "mask" to review all places I was masking.. case-sensitivity made me miss that one :(
05:12:07 <Peaker> bitten by camel-case!
05:12:44 <haasn> I always hear GHCi has amazing debugging facilities, but I've never learned about, seen or used them
05:13:12 <BoR0> ah, so foldl was the one that's broken and not foldr
05:13:49 <Peaker> haasn: I don't think ghci is actually usable on a large project
05:14:13 <Peaker> the deadlock bug reproduces in a big concurrent execution
05:14:45 <Peaker> at least all the concurrency bugs I had were all relatively deterministic/simple, because of the excellent concurrency facilities. However, even finding them was sometimes hard because all I have is print-debugging!
05:50:04 * matheus23 wonders why idris isn't installed on his system anymore... Checks yaourt's packages (archlinux), finds that idris is not installed. Is even more confused, because he hasn't reset his system for ages and is sure he used idris before... Realizes that he installed it with "cabal install" and has reset cabal multiple times...
06:06:38 <alhimik45> hi, I have some fuctions, that called with same first argument (Handle). Is there ways, not to write it every time?
06:06:57 <Rembane> g = f x
06:07:13 <exicer> I'm just starting to learn how to use cabal. How can I do the equivilant of ghc -O2 with cabal install ?
06:08:55 <alhimik45> it says Not in scope: `h'
06:08:59 * hackagebot rest-core 0.27.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.27.1 (ErikHesselink)
06:09:01 * hackagebot rest-gen 0.9.0.5 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.9.0.5 (ErikHesselink)
06:10:17 <alhimik45> oh, yes, it works, thanks!
06:15:12 <exfalso> hi, i'm trying to use cabal-test as described here http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites using detailed-1.0, however it says only detailed-0.9 is supported. i'm using the latest cabal. any tips?
06:16:25 <tobani> do you have the latest cabal-install ?
06:16:41 <exfalso> tobani: test
06:16:43 <exfalso> yes
06:17:33 <exfalso> tobani: i set cabal-version >= 1.18 in the .cabal
06:17:48 <exfalso> it should be supported from 1.9 on
06:18:07 <tobani> what does cabal -V  say
06:18:40 <dcoutts> exfalso: I think the version really is only 0.9
06:18:46 <exfalso> cabal-install version 1.18.0.3
06:18:47 <exfalso> using version 1.18.1.3 of the Cabal library
06:19:02 <tobani> (I don't know the answer, I've just found my asking stupid questions helps sometimes)
06:19:09 <exfalso> dcoutts: ah!
06:19:15 <exfalso> tobani: :) thank anyway
06:26:24 <simon> can I expect that GHC will perform CSE on something like the repeated use of 'zipWith3 (,,) a b c' within a pure context?
06:27:45 <merijn> simon: CSE is still kind of brittle, I wouldn't rely on it to happen
06:27:52 <geekosaur> nope, if you want a common subexpression, make a let binding. (otherwise ghc may assume laziness will require it track each one as a separate closure)
06:27:55 <fizruk> simon: i don't know, but would not be relying on that
06:29:36 <simon> thanks.
06:31:49 <dcoutts> simon: doing that kind of transformation (sharing something rather than recalculating it) will sometimes use more memory (if you're caching and then using at rather different times). So GHC will not do it in general, only in some small local cases (where it can see the result is reused quickly, so doesn't have to be kept around for a long time pushing up mem use).
06:32:20 <simon> dcoutts, okay, so long lists are hard to be certain about. I get it.
06:32:52 <dcoutts> simon: you may know, but it's not easy for ghc to work out.
06:33:18 <dcoutts> or you may know it does increase mem use, but it's still an improvement in your view
06:34:00 <merijn> dcoutts: There's no way to decide build-depends on some system/IO command, right?
06:34:13 <dcoutts> merijn: no, that would not be declarative
06:34:34 <merijn> dcoutts: bah :\
06:34:43 <dcoutts> which would break automatic package management :-)
06:35:56 <merijn> dcoutts: What if I need to determine which dependency to use based on the environment? What's the best way, just requires to always transitively specify flags to select dependencies?
06:36:06 <merijn> dcoutts: i.e. when relying on external libs
06:36:27 <dcoutts> merijn: you declare your optional dependencies using flags
06:36:44 <dcoutts> merijn: you don't get to simply inspect the current environment and decide yourself
06:37:08 <merijn> dcoutts: That's a real pain if a library can use three different versions of a dependency, because everyone that transitively relies on it would need to specify flags when installing
06:37:15 <dcoutts> again, that's to enable automatic package management (and to preserve the control of the builder)
06:37:35 <dcoutts> merijn: it should not propagate beyond one package, since the interface of a package isn't allowed to change based on flags
06:38:51 <merijn> dcoutts: Concrete example, I'm wrapping OpenCL and publishing 3 versions (1.0, 1.1 and 1.2) a library can work with either of those 3 haskell packages, but it's not allowed to detect which to use from the environment. The end result is that any transitive user has to specify which version to use
06:38:52 <dcoutts> merijn: or you're saying that these other packages will themselves also directly depend on one of three packages? In which case yes they also have to declare their optional deps.
06:40:08 <merijn> dcoutts: Trying to install my wrapper for 1.1 on a machine with 1.0 will break, so even though the package of a library foo won't have a changing interface (it's the same regardless of opencl version), it's impossible to install "foo" without installing *A* version of OpenCL, which is impossible without specifying which OpenCL is installed locally
06:40:49 <Galactic> wow this: A.B is different than A . B  ??
06:41:05 <merijn> Galactic: It can be, if A.B is a qualified module name
06:41:16 <xplat> merijn: well, alternatively you could just break the ability to install OpenCL-wrapper automatically when installing 'foo'
06:41:25 <dcoutts> merijn: right so in this case the optional dep is on a system C lib. In principle that's ok, though cabal-install doesn't currently automatically resolve based on C libs, only Haskell libs.
06:41:29 <Galactic> a k
06:41:44 <merijn> dcoutts: Hence why I wanted to use a system thing to detect the C version to repair it
06:42:13 <merijn> You could just enable the right OpenCL-wrapper dependency based on whichever version of opencl you find on the system
06:42:31 <dcoutts> merijn: ooi, does opencl C lib use pkgconfig?
06:42:53 <merijn> I have no clue what pkgconfig is, but I don't think this question makes sense
06:43:16 <merijn> Because there is no single opencl C library
06:43:28 <merijn> There's umpteen different vendor specific ones
06:43:40 <xplat> pkgconfig is a simple configuration-management thingy for C libs
06:43:41 <dcoutts> ah, ok, they're not likely all to use it then
06:44:29 <xplat> well, i should perhaps say simplistic, since nothing is simple with C libs :)
06:45:26 <merijn> dcoutts: In essence, the ability to just check a C header file and decide on that would be sufficient
06:45:47 <dcoutts> merijn: and on that basis do what exactly?
06:46:12 <dcoutts> merijn: you can in practice make some changes like that, but you cannot add new build-depends, because it's too late by that time
06:46:59 <merijn> dcoutts: "build-depends: ... #ifdef OPENCL_VERSION_1_2 opencl-wrapper-1.2 #elif defined(OPENCL_VERSION_1_1) opencl-wrapper-1.1 #else opencl-wrapper-1.0 #endif"
06:47:43 <merijn> dcoutts: Because then any library wrapping opencl-wrapper can just have that as build-depends and transitive users won't have to worry
06:47:44 <dcoutts> merijn: no it's too late to change that in the Setup.hs, the package manager has already selected the dependencies
06:48:32 <merijn> dcoutts: Yeah, that's what I was afraid off :)
06:49:37 <xplat> most of the language-specific package managers have this problem
06:56:47 <fizbin> @hoogle ([a] -> a) -> [(b -> a)] -> (b -> a)
06:56:47 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
06:57:01 <fizbin> No, that isn't what I want...
06:57:33 <Guest77325> http://www.marketglory.com/strategygame/galahad1st for online gamers, if you didn't already, use this link to register on MerketGlory: a free2play financial strategy game where virtual currency can be converted into real money. It starts out slow but in time you can turn a good profit that is if you have the necessary patience to grow a little bit every day :P
06:59:05 * hackagebot multipart 0.1.1 - A partial fork of the cgi package exposing the multipart module  http://hackage.haskell.org/package/multipart-0.1.1 (ErikHesselink)
07:02:21 <Chaze> Hi. I haven't used Haskell for a while and wanted to try out the Eclipse FP plugin as an IDE. Is anyone running it on windows and can verify that it works? :)
07:04:05 * hackagebot rest-core 0.28 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.28 (ErikHesselink)
07:04:07 * hackagebot rest-gen 0.9.0.6 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.9.0.6 (ErikHesselink)
07:04:09 * hackagebot rest-happstack 0.2.9.6 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.9.6 (ErikHesselink)
07:04:11 * hackagebot rest-snap 0.1.17.7 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.7 (ErikHesselink)
07:09:06 * hackagebot data-textual 0.2.0.1 - Human-friendly textual representations.  http://hackage.haskell.org/package/data-textual-0.2.0.1 (MikhailVorozhtsov)
07:13:06 <arrdem> suggestions for a combined rss/atom reader?
07:13:14 <arrdem> apparently thunderbird doesn't like atom...
07:13:58 <arrdem> oh crap. sorry, wrong chan.
07:14:49 <jorgno> Hi guys, I'm having some strange problems which seems to originate from the ST monad. I have some code which was initially run in the MonadRandom monad, but after several threads on reddit and the need for more speed I decided to move to mwc-random-monad since it seemed like the most recommended. After changing my program started to leek memory and a profile show that its is FUN_1_0(partially applied functions?) which is to blame. I was wondering if anyone h
07:14:49 <jorgno> ad any suggestion as to fix this. In my code the only thing I changed(apart from the specific random method calls) was "evalRand generator" to "runST $ runWithVector vector"
07:15:31 <jorgno> *or suggestions as to where to look for a solution I should say
07:22:06 <merijn> Is there any reason not to always derive Typeable/Data for datatypes?
07:26:04 <bergmark> merijn: more generated code, longer compile time
07:32:32 <Chaze> I'm having issue building a cabal package, and this issue https://github.com/JPMoresmau/BuildWrapper/issues/20 suggests "forcing" a dependency to a specific version. how can i do that?
07:35:18 <merijn> Ah, bollocks, c2hs doesn't allow CPP macros within c2hs command blocks? :(
07:35:37 <supki> Chaze: cabal install ... --constraint='package == version'
07:35:52 <Chaze> supki: perfect. thank you!
07:51:00 <pyon-vb6> Is it just me, or haskell-mode does not indent guards properly when inside of an instance declaration?
08:02:51 <Nik05> hello. I just programmed something that parses a string and returns true or false (or 1 or 0 if that is simpler) and now i want to read lines from input and count the times the function returns true (or 1) for each line
08:03:17 <ziman> @pl \x1 -> s1 (s2 v2 $ g1 x1) x1
08:03:18 <lambdabot> s1 =<< s2 v2 . g1
08:04:11 <Nik05> does someone know some book which can help me with this?
08:04:13 * hackagebot ottparse-pretty 0.1.2.4 - Pretty-printer for Ott parse trees  http://hackage.haskell.org/package/ottparse-pretty-0.1.2.4 (BrentYorgey)
08:04:15 * hackagebot hack2-contrib 2014.4.14 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2014.4.14 (JinjingWang)
08:05:07 <identity> Nik05: You could do something with replicateM, getline, map and filter
08:05:25 <identity> (and length)
08:05:58 <jTT_> Hi, I am very new to Haskell and have, as practice, tried to play around with case expressions. I tried to write a function that replaces the char ‘e’ with ‘a’. Hard-coded, this works fine when> replaceEs :: String -> String;   replaceEs xs = [replacedString | x <- xs, let replacedString = case x of 'e'-> 'a'; x -> x]         BUT: when I try to make the characters to-be-replaced variable, it says “Pattern match(es) are overlapped”. Here is 
08:05:59 <jTT_> code: replaceEs' :: String -> Char -> Char -> String;  replaceEs' xs replaceMe withThis = [replacedString | x <- xs, let replacedString = case x of replaceMe -> withThis; x -> x].  I do not understand why x is always matched with replaceMe. Thanks for any comments.
08:06:20 <Nik05> ah ok with replicate i can just do it n times. This works for my problem now. But what if you arent sure how many lines there are going to be?
08:06:34 <identity> main = do { lines <- replicateM 10 getLine; let transformed = map yourFunction lines; return . length . filter (== True) $ lines; }
08:07:00 <Nik05> thats fast :P
08:07:52 <identity> Nik05: In that case, you could just use something like interact and lines
08:09:14 * hackagebot RepLib 0.5.3.2 - Generic programming library with representation types  http://hackage.haskell.org/package/RepLib-0.5.3.2 (BrentYorgey)
08:09:41 <identity> Nik05: If your use case is something like piping a file into the program, then interact is a good choice
08:09:54 <Nik05> ok thank you
08:09:54 <simon> jTT_, replaceMe is a pattern that matches *anything*. when it figures as the first pattern, it will always be triggered.
08:10:46 <identity> Nik05: No problem. Feel free to ask if you need more assistance
08:10:53 <jTT_> hmk, i hoped that by calling replaceEs’ “Hello” ‘e’ ‘a’, replaceMe would only be known as ‘e’
08:11:11 <jTT_> as I said, I’m working on fundamentals here
08:11:30 <simon> jTT_, if you're working on fundamentals, you should probably drop the list comprehensions.
08:11:34 <Nik05> its just the way of thinking about all this. Feels like its all harder with haskell. But turn out the solution is much simpler
08:11:44 <tdammers> 'case' is a bad keyword IMO
08:11:54 <tdammers> especially for people who come from an imperative background
08:12:13 <Nik05> yes, me :)
08:12:15 <tdammers> took me a good while to figure out that 'case' in Haskell does not work like 'switch/case' in C/C++/Java/PHP/...
08:12:35 <simon> jTT_, https://gist.github.com/anonymous/10656703
08:12:35 <Jafet> No, it is not a bad keyword.
08:12:48 <tdammers> I mean the name. Just the name.
08:12:59 <Jafet> (The worst keyword is "in", because it is not the same length as "let".)
08:14:14 * hackagebot miku 2014.4.14 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/miku-2014.4.14 (JinjingWang)
08:14:38 <jTT_> cheers simon. That’s neat. I sought, however, to grasp what cases do and tried out some silly stuff. I am still unsure why replaceMe matches anything
08:15:39 <simon> jTT_, as a value, replaceMe is a variable reference. as a pattern, replaceMe is a pattern that matches anything (and binds this to the variable replaceMe)
08:15:47 <jTT_> ohhh I think I get it.
08:15:55 <identity> Nik05: Yep, it's somewhat hard to get your mind around sometimes yeah
08:16:00 <jTT_> just like in my last line where i do x -> x
08:16:18 <simon> jTT_, so it loops through the two cases until a pattern matches and executes the corresponding body, which in your case is always the first body.
08:16:25 <jTT_> simon: thanks a lot
08:16:47 <identity> Nik05: But it's a natural way to think about things. In the case of interact, you only have to define a function that transforms your input, which is a string, into another string.
08:17:08 <identity> This transformation function can of course be composed of many other functions, with your 'work' functions somewhere in the middle.
08:17:35 <simon> jTT_, there is a very natural correspondence between using case-of and multiple declarations for the same function. look at my example.
08:18:00 <identity> Since it's a pure function(the transformation function), you have to define the 'pipeline' in reverse because of the composition operator, but you get used to that.
08:18:10 <Jafet> Also nothing beats the case syntax in algol 68
08:18:44 <bernalex> hm. is there a smart way of "unrolling" a list? say you want to draw [foo, bar, fu, baz] -- and foo, bar, and baz are 'Graphic's, but fu is a [Graphic]. how would you go about doing that?
08:19:15 * hackagebot moe 2014.4.14 - html with style  http://hackage.haskell.org/package/moe-2014.4.14 (JinjingWang)
08:19:15 <Jafet> :t concat
08:19:17 <lambdabot> [[a]] -> [a]
08:19:23 <fizruk> [foo, bar] ++ fu ++ [baz]
08:20:12 <Nik05> ok thank you for explaining identity :)
08:20:20 <iota_> .w 5
08:20:21 <Nik05> lets try out if this works
08:20:46 <fizruk> > let xs = [c, d] in concat [[a, b], xs, [d]]
08:20:48 <lambdabot>  [a,b,c,d,d]
08:22:34 <bernalex> fizruk: Jafet: yes this was essentially what I did *not* want to do. :P should have mentioned that, sorry.
08:23:24 <fizbin> bernalex: I'm a bit confused as to the type of your list.
08:23:32 <fizruk> bernalex: you want metaprogramming? like in lisp?
08:24:14 <bernalex> fizruk: I wanna be able to do draw [this, that, these] where this & that are Foo and these are [Foo] with no fuzz
08:24:16 * hackagebot mzv 0.1.0.0 - Implementation of the "Monads, Zippers and Views" (Schrijvers and Oliveira, ICFP'11)  http://hackage.haskell.org/package/mzv-0.1.0.0 (IsmaelFigueroa)
08:24:20 * fizbin activates the "Look beyond the first three letters" flashing sign for a conversation involving the two of us.
08:24:33 <fizruk> bernalex: this : that : these
08:24:55 <bernalex> yes that's the minimum work I've come up with
08:25:26 <fizruk> bernalex: personally I don't see any "fuzz" in concat or ++
08:25:46 <fizbin> bernalex: Again, though, what's the type of [this, that, these] ? If that list is of type [Foo], then "these" can't be of type [Foo]. If that list is of type [[Foo]], then "this" can't be of type Foo.
08:26:27 <fizbin> Though I will admit that a well-chosen binary operator is often convenient at combining two related yet distinct types.
08:26:37 <bernalex> fizbin: no, it will not work. that's the point.
08:26:47 <fizbin> Such as, in this case, (:)
08:27:00 <fizbin> bernalex: I guess then I don't understand your situation.
08:27:36 <fizbin> Since you seem to be saying "I want to do X to impossible thing Y, and the problem is that Y is impossible"
08:27:43 <fizruk> bernalex: i guess you want something like `(foo bar ~@fu baz) in clojure
08:27:53 <bernalex> fizruk: exactly
08:28:27 <fizruk> bernalex: perhaps you could use TH for that, but I'd recommend you to stick with concat/++
08:29:02 <jorgno> I found out why my program was leaking FUN_1_0 it was this code: http://lpaste.net/102685 which made the difference, is there something I have not understood about type or is this a situation which should not have happened?
08:29:16 * hackagebot mzv 0.1.0.1 - Implementation of the "Monads, Zippers and Views" (Schrijvers and Oliveira, ICFP'11)  http://hackage.haskell.org/package/mzv-0.1.0.1 (IsmaelFigueroa)
08:31:20 <fizbin> Though if you had a list of [Either Foo [Foo]], you could do: processFoos fooList = map processFoo [x | x <- either (:[]) id y | y <- fooList]
08:32:03 <fizruk> :T concatMap (either (:[]) id)
08:32:09 <fizruk> :t concatMap (either (:[]) id)
08:32:10 <lambdabot> [Either b [b]] -> [b]
08:34:51 <fizruk> bernalex: hm... depending on your use case there might be another way
08:35:09 <Fernandos> hi
08:35:25 <fizruk> bernalex: e.g. for Picture from gloss package you could write [foo, bar, pictures fu, baz] :: [Picture]
08:36:03 <fizruk> bernalex: this is not exactly "unrolling" but might fit for your purposes
08:36:17 <fizruk> Fernandos: hi!
08:36:55 <bernalex> fizruk: I was mostly asking because I was curious what you guys came up with. ;-) I have a real world issue here as well, but that's not in haskell. can't even use concat here! =/
08:38:01 <Fernandos> Is there proofable way to guarantee that a service is run using heartbeats and to kill/restart the service on the other case in less than 200 lines?
08:39:17 * hackagebot yesod-dsl 0.1.1.16 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.16 (TeroLaitinen)
08:39:19 * hackagebot effective-aspects-mzv 0.1.0.0 - A monadic embedding of aspect oriented programming, using "Monads, Zippers and Views" instead of mtl.  http://hackage.haskell.org/package/effective-aspects-mzv-0.1.0.0 (IsmaelFigueroa)
08:39:32 <bernalex> fizruk: oh, actually, I have concat. I was using $ in the wrong place. :-P
08:39:38 <identity> Fernandos: proofable?
08:40:18 <Jafet> heartbeat exploit does not allow you to control the other side. Also try to work haskell into your question.
08:40:50 <identity> Fernandos: You could just use a manager thread with a channel and poll the chan with a delay, etc.
08:40:55 <identity> it can then kill the thread and start it again
08:40:58 <identity> using throwTo
08:41:39 <Fernandos> identity: There maybe infinite ways to realize that, i'm specifically asking, if there is an establish algorithm or recent method to realize such a thing
08:41:49 <Fernandos> *established^
08:42:59 <identity> Fernandos: which is why I asked about "proofable".. but in that case, I don't know
08:42:59 <Jafet> Ok, there is a program named heartbeat.
08:47:22 <jakex_> is there a macro that auto generates NFData instances?
08:49:22 <Nik05> identity im trying to get your code working. replicateM gives me IO [String] and when i do fmap (map myFunction) lines it gives me IO [Bool]. Should i now also do a fmap (map filter ...) on that?
08:49:29 <Nik05> im confused now :P
08:49:45 <identity> Nik05: Is this inside your main function or some such?
08:50:05 <identity> You could just use do notation
08:51:46 <identity> that is: yourFunction = do { lines <- replicateM n getLine; ... do stuff .. } if you do that, you can deal with lines as if it's not in the IO monad.
08:52:12 <pyon-vb6> Is there any shorthand for the owl operator in the standard library?
08:53:11 <identity> The alternative is: replicateM n getLine >>= \lines -> let filtered = map yourFunction lines in print . length . filter id $ lines
08:53:55 <Fernandos> identity: usually just implementing the observer pattern and periodically syncing the the time via ntp, could offer a guarantee
08:54:13 <Fernandos> but there are surely more sophisticated or elegant solutions
08:54:32 <thrakcattack> :t filterM
08:54:33 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
08:55:55 <identity> Fernandos: Oh, I hadn't even really noticed you said 'service'. I assumed we were dealing with a single program or some such, not two separate entities in possibly two separate places
08:56:46 <Nik05> in my main function yes identity
08:57:41 <Nik05> oh wait i get it now :)
08:57:43 <ReinH> Fernandos: any distributed algorithm that depends on a real clock is fundamentally broken
08:57:57 <ReinH> because there is no actual way to keep clocks in sync across systems
08:58:39 <ReinH> identity: there are a variety of failure detection algorithms that vary in complexity as the failure modes of the underlying system vary in complexity
08:58:40 <joelteon> :t (sequence .) . fmap
08:58:41 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
08:58:52 <Fernandos> ReinH: ok, glad you jumped in. Yeah, it's not an easy to solve problem. That's why realtime systems have to met all those extra compliances.
08:58:56 <joelteon> :t (Data.Traversable.sequence .) . fmap
08:58:57 <lambdabot> (Traversable t, Monad m) => (a1 -> m a) -> t a1 -> m (t a)
08:59:04 <ReinH> identity: for a primer on these (and a bunch of other) algorithms, check out http://www.amazon.com/Introduction-Reliable-Secure-Distributed-Programming/dp/3642152597
08:59:11 <fizruk> :t traverse
08:59:11 <Fernandos> I don't know a solution to this, it's maybe called "service control algorithm"
08:59:12 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
08:59:20 * hackagebot terminal-progress-bar 0.0.1.4 - A simple progress bar in the terminal  http://hackage.haskell.org/package/terminal-progress-bar-0.0.1.4 (RoelVanDijk)
08:59:30 <sclv> Fuuzetsu: ping
08:59:55 <Fernandos> ReinH: oh, that's cool, I'm trying to implement it in less than 200 LoC
09:00:14 <ReinH> Fernandos: well, some of the algorithms can be expressed in about 20 lines of code
09:00:30 <ReinH> Fernandos: modulo networking boilerplate, etc
09:00:50 <ReinH> it depends on the behavior of the system you are trying to detect failures in
09:01:11 <identity> ReinH: Interesting. Thank you!
09:01:15 <ReinH> probably the most modern algo for failure detection is Phi Accrual (http://ddg.jaist.ac.jp/pub/HDY+04.pdf)
09:01:24 <Nik05> ah it works identity :)
09:01:38 <Fernandos> Ah, then I think this is a Distributed Message Passing Algorithm I'm trying to do
09:01:39 <ReinH> but sometimes all you need is to keep a couple sets around and update their memmberships based on heartbeats
09:01:56 <Fernandos> To restart/kill service that don't respond
09:02:04 <ReinH> Fernandos: check out that book, it's full of distributed algorithms and presents a principled way to reason about them
09:02:08 <identity> Nik05: excellent
09:02:31 <Fernandos> ReinH: cool! thank you!
09:02:40 <ReinH> np :)
09:02:43 <Nik05> damn answer incorrect :P
09:02:55 * Nik05 is doing project euler problem...
09:02:56 <joseph07> identity: Oh you're here too, I guess you probably know about abstracting things into functions then
09:03:29 <identity> joseph07: I guess I do
09:03:43 <identity> not sure that my presence here automatically means that I do, but I think I do :)
09:03:51 <Fernandos> ReinH: I was thinking about writing a minimal Finite State Automata and a recursive function to pass the hearbeats and kill services, if the time difference is too high.. guess it's amateurish :)
09:03:59 <Fernandos> Using the observer pattern^
09:07:48 <Fernandos> The paper titled: "The φ Accrual Failure Detector" looks really nice. Hope I find a minimal implementation or pseudo-code, somewhere
09:39:00 <zomg> Is there a function for folding that gives you the remainder of the list you're folding over or something along those lines?
09:39:18 <zomg> Guess it would be reasonably trivial to implement but.. :)
09:39:48 <Chaze> Is there any convenient way to have one global declaration of an "input stream", which could be anything from stdin, a file, or a socket?
09:40:05 <Chaze> I'm looking into System.IO.Streams, but it doesn't seem to have what I'm looking for
09:40:48 <srhb> Chaze: Sort of -- keep it in a reader monad?
09:40:51 <srhb> Or something similar.
09:42:09 <geekosaur> on unix they're all the same thing. on windows it's harder... there should be an operation in Network.Socket to give you a Handle for a Socket (but you still need to only use it within a withSocketsDo or it will stop working)
09:42:41 <srhb> Chaze: runReader ask "myGlobalConfig"
09:42:50 <Chaze> well, I'm just asking if there's some package that already does that for me.
09:42:52 <srhb> Chaze: In practice you will probably want a ReaderT
09:42:55 <srhb> Ah
09:43:25 <joelteon> Is there any method of providing hlint with global default options, like you can do with e.g. ack?
09:43:35 <stian> I feel like there should be some built-in map functionality that I'm missing here: I have a list of maps, and I want to normalize the maps according to a whitelist, all the keys in the whitelist map should be present in each map (with a default value if necessary), and all keys not in the whitelist should be struck... So if I have a map with all keys having the default value, and then want to "update" the map with values from a
09:43:35 <stian> nother map, but without adding any new keys? Union and intersect don't seem to cut it?
09:43:48 <dmj`> can you specify multiple authors in a cabal file?
09:44:03 <dcoutts> sure, just separate with commas
09:46:11 <Fuuzetsu> sclv: sup
09:46:35 <sclv> was wondering about the reusability of haddock?
09:46:37 <Ywen> zomg: I'm not I understand what you want. Is by any chance 'scanl' related?
09:46:40 <dmj`> dcoutts: perfect thanks
09:46:49 <sclv> Fuuzetsu: like suppose i had some other language that was almost haskell but not
09:46:55 <sclv> and i wanted to just “use haddock for it"
09:47:01 <sclv> obviously haddock is deeply tied to the ghc api
09:47:22 <sclv> but would there be a nice way to just “patch in” a different way of generating those structures the api does
09:47:34 <Ywen> x
09:47:36 <Ywen> woops
09:47:44 <sclv> and where in the pipeline would i do it?
09:48:08 <sclv> or is this a terrible idea and we should just run off and roll our own doc system from scratch
09:48:12 <Fuuzetsu> sclv: nope; we plan to split out the comment parser (so you could use that as long as you followed the markup) but the backends work on specific types
09:48:22 <Fuuzetsu> honestly the backends are just pretty printers for GHC types
09:48:30 <sclv> ah so they take ghc types directly?
09:48:53 <sclv> and you wouldn’t recommend translating our types into ghc types?
09:48:57 <Fuuzetsu> yeah; so after we split up you could use the parser without a problem without dependency on GHC but you wouldn't be able to use backends (easily)
09:48:58 <sclv> even if they’re nearly the same :-)
09:49:00 <zomg> Ywen: hm maybe, but basically if I fold over [1,2,3], on first fold I'd get [1,2,3], then on next, [2,3], and then [3] etc.
09:49:10 <Fuuzetsu> no, I definitely don't recommend doing that
09:49:17 <sclv> ok, gotcha, thanks
09:49:24 <sclv> maybe we can just steal the stylesheet :-P
09:49:25 <Fuuzetsu> maybe it would work, cool experiment I guess, but really hacky
09:51:11 <Fuuzetsu> Maybe. If you can translate to GHC types closely (honestly, RdrName and OccName is what you need to properly make) then it could work, maybe. Seems like a lot of work.
09:52:55 <Ywen> zomg: Oh you want CLisp mapcdr, then. you can do map over the subsequences : http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#v:subsequences
09:53:33 <Ywen> zomg: sorry, you'd have to reverse the subsequences, actually
09:53:56 <monochrom> subsequences? tails?
09:54:09 <dmj`> monads-tf or mtl?
09:54:19 <Ywen> zomg: monochrom: yep, actually tails is what you want
09:54:24 <zomg> Yeah
09:54:27 <fizbin> @pl \x -> map ($ x) [funcA, funcB, funcC]
09:54:27 <lambdabot> flip map [funcA, funcB, funcC] . flip id
09:54:29 <monochrom> mtl, just because it's already in Haskell Platform :)
09:54:41 <fizbin> Really, @pl? That's the best you can do?
09:55:07 <monochrom> at least it get rids of the $. good riddance.
09:55:22 <fizbin> Surely there's some way to abuse the (->) monad or something to make that sorter.
09:55:27 <fizbin> shorter, rather.
09:56:48 <supki> fizbin: sequence
09:56:57 <fizbin> @type sequence
09:56:59 <lambdabot> Monad m => [m a] -> m [a]
09:57:11 <fizbin> Right.
09:58:03 <alcabrera> ReinH: thanks for the thoughts on that book (Introduction to Reliable and Secure Distributed Programming). I've been watching that one and thinking about it.
10:01:02 <benj_> real world haskell: http://hackage.haskell.org/package/toilet
10:02:06 <srhb> > (<*>) . [id, const 3] . pure $ 2
10:02:08 <lambdabot>  Couldn't match expected type ‘f0 s0 -> f (a -> b)’
10:02:08 <lambdabot>              with actual type ‘[a0 -> a0]’
10:02:17 <srhb> > (<*>) [id, const 3] . pure $ 2
10:02:18 <lambdabot>  [2,3]
10:02:24 <monochrom> that toilet is bizarre :)
10:02:26 <srhb> :D
10:02:51 <Jaak> > [id, const 3] <*> [2, 3]
10:02:53 <lambdabot>  [2,3,3,3]
10:04:27 * hackagebot tidal 0.3.6 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.3.6 (AlexMcLean)
10:05:21 <srhb> Maybe just zipWith.
10:05:28 <Nik05> anyone with some card game knowledge or haskell knowledge. That can give me some hint in 1. if there is some major flaw or 2. code that can be written much nicer?
10:05:45 <Nik05> can i just paste a (failed) haskell problem solver here?
10:05:49 <srhb> Nik05: Post it, easier to get responses then :P
10:05:52 <srhb> lpaste.net
10:05:54 <Nik05> ok thank you :)
10:06:06 <Nik05> yes thats what i meant with paste, not here in channel :P
10:06:20 <srhb> :)
10:07:12 <tpsinnem> in pipes or conduit or any of the other newer stream processing libraries, is there a way to nicely have something a stream having two sources, one of which is a wrapper for data coming in from something like a TCP socket, and not have the other source be blocked while the TCP source waits?
10:07:30 <tpsinnem> s/have something/have something like/
10:08:32 <c_wraith> tpsinnem: there is in edwardk's machines library.  But..  That library isn't really ready for prime-time yet.
10:08:45 <JoaoPortela> > [id, const 3]
10:08:47 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>]
10:08:53 <JoaoPortela> > :t [id, const 3]
10:08:54 <lambdabot>  <hint>:1:1: parse error on input ‘:’
10:09:09 <c_wraith> tpsinnem: otherwise, you're going to need to get some sort of concurrency involved.
10:09:10 <tpsinnem> c_wraith: yeah, i was sort of planning to ask that -- i probably have some 'machines' questions to ask for #haskell-lens
10:09:32 <tpsinnem> c_wraith: do you know how non-ready exactly is it? :
10:09:34 <tpsinnem> :)
10:09:42 <joelteon> machines is pretty neat
10:09:49 <pordan30> Is there an existing class that captures just the notion of a container or context that (a) satisfies the monoid laws under some operation and identity, and (b) has an injection like pure, return, or point?
10:10:14 <c_wraith> tpsinnem: I know it's very likely to have significant design changes in the future.  However, what it currently has functions - it's just not final.
10:10:35 <tpsinnem> c_wraith: ok, interesting. chances are i could live with that
10:11:31 <tpsinnem> c_wraith: might you be able to point to relevant reads on what might be going on with changes and such -- plans for the future?
10:12:01 <c_wraith> tpsinnem: For that, you should probably ask in #haskell-lens (which is actually #haskell-edwardk with an odd name)
10:12:32 <c_wraith> tpsinnem: I don't remember why he's not happy with the current design.  Just that he's not.
10:12:44 <tpsinnem> c_wraith: ok. apparently edwardk himself is not in atm though :/
10:13:21 <Nik05> ok i added some more comments to it http://lpaste.net/2393946948961828864
10:13:33 <Nik05> hm nice warning Redundant brackets and stuff :P
10:18:13 <Nik05> how do i get those redundant warnings with ghc?
10:19:11 <Nik05> and ghc gives me a warning: Top-level binding with no type signature: sortByLenD :: forall a. [[a]] -> [[a]]
10:19:13 <popx> the warnings are probably from hslint
10:19:29 <Nik05> does it matter if i leave the "forall a." out?
10:19:30 <popx> sorry hlint
10:19:59 <shachaf> Nik05: No, the forall is implied in that signature.
10:20:02 <LordBrain> i get them in vim with a plugin, redundant brackets and redundant module imports, the latter seems more useful
10:20:44 <popx> LordBrain: probably syntastic right? still uses hlint to generate them I believe
10:21:13 <LordBrain> i wouldn't mind disabling the ones about brackets
10:21:30 <zomg> Ywen: seems it might just be best to use mapAccumL since with that, I can easily pass two values around... one for the final product, one for the remainder of the list
10:24:12 <LordBrain> yes it is syntastic
10:24:18 <Nik05> shachaf i think i understand that forall a little now :)
10:26:00 <shachaf> Nik05: It stands for "for all".
10:26:39 <shachaf> You can write "idInt :: Int -> Int; idInt x = x" and "idChar :: Char -> Char; idChar x = x", but that's wasteful, so you write "id :: forall a. a -> a; id x = x", meaning that it works for all types a.
10:26:52 <Nik05> ∀
10:27:48 <Nik05> but cant you just do id :: a -> a ? why the forall a.?
10:29:20 <fizbin> Nik05: True, in most contexts, you don't need to specify the "forall a."
10:29:44 <fizbin> Nik05: There are though some complicated types where you do need to specify that.
10:30:42 <Nik05> yes i saw something like foo :: (forall x. x -> x) -> (a, b) -> (a, b)
10:31:00 <shachaf> Nik05: It's implied in Haskell.
10:31:29 <shachaf> If you don't specify it, you get a "forall ..." right after the ::
10:31:32 <Nik05> does it need that in my example?
10:31:35 <shachaf> No.
10:33:00 <fizbin> But since ghc is auto-generating the error, it doesn't take the type and try to minimize its text representation by removing everything that could be omitted as implied.
10:33:03 <Nik05> then when is it needed?
10:33:21 <shachaf> It's needed in your example, for instance.
10:33:40 <shachaf> Only one is needed there, though; the full type is foo :: forall a b. (forall x. x -> x) -> (a, b) -> (a, b)
10:33:57 <Nik05> ah ok
10:34:03 <fizbin> But there the "forall x" is needed.
10:34:29 <Nik05> and are there more use cases, you need to use it?
10:34:49 <fizbin> In general, you need it when the forall isn't at the outermost level.
10:35:30 <shachaf> GHC uses forall to mean all sorts of things.
10:35:41 <shachaf> For instance, ScopedTypeVariables requires "forall".
10:36:09 <fizbin> Oh, right. And you can do neat things with forall in data definitions
10:37:12 <fizbin> See http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#The_forall_keyword
10:39:50 <shachaf> That introduction looks kind of unpromising.
10:39:54 <shachaf> But I don't really know.
10:45:40 <Nik05> ok i removed the redundant brackets lpaste said. and now it doesnt compile anymore :P
10:46:08 <geekosaur> hlint works by heuristics; sometimes they are wrong
10:46:11 <MagneticDuck> Nik05: that's hlint
10:46:20 <MagneticDuck> yeah
10:46:29 <MagneticDuck> (sorry I just got here, no context =P)
10:46:56 <ReinH> alcabrera: it's a great book
10:47:12 <ReinH> alcabrera: the only downside is that it doesn't really deal with partition failure explicitly
10:47:19 <ReinH> alcabrera: (and to be fair, that's a significant downside)
10:47:33 <ReinH> but I still like it :)
10:47:52 <alcabrera> ReinH: sounds like it's a good start, in any case. :)
10:49:08 <ReinH> alcabrera: yep :)
10:49:10 <monochrom> Nik05: (f x) > (g y) can have its parentheses omitted. similarly (f x) == (g y). but Flush (f x) (g y) must retain its parentheses.
10:50:30 <Nik05> ok
10:50:32 <jakex_> `flush f x g y' would attempt to pass four arguments to flush
10:50:57 <Nik05> but why doesnt it try to pass more arguments to == ?
10:51:09 <monochrom> I don't understand that sentence.
10:51:47 <monochrom> are you even using a correct mental model of Haskell syntax?
10:51:54 <jakex_> function operator (space) has higher precedence than operators
10:52:04 <jakex_> function application*
10:52:08 <Nik05> ok
10:57:47 <stainer> in emacs haskell mode I can change function declaration with inferior-haskell-sebd-decl, and function is changed. but all the other functions that call that function still call the old version. is this a bug or expected behavior?
10:58:57 <carter> stainer: functional definitions ;)
10:59:01 <geekosaur> expected. function values are no more immutable than other values
10:59:09 <geekosaur> if you create a new binding, it does not replace the old one
10:59:28 <geekosaur> rtaher, no less immutable
11:00:53 <stainer> understand. it is a bit annoying though, that I have to restart entire environment if I want to recompile a function
11:02:29 <monochrom> perhaps there is a "reload" command without total restart.
11:03:31 <stainer> I still have to reassign variables in ghci, etc
11:04:34 * hackagebot esqueleto 1.3.12 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.12 (FelipeLessa)
11:04:37 <stainer> and reset the gui windows, and everything else
11:12:59 <Nik05> so anyone else got some more hints for my program?
11:13:41 <ReinH> Nik05: hints?
11:14:08 <Nik05> http://lpaste.net/6877460539002322944 for this
11:15:36 <ReinH> Nik05: I think you should use Either instead of error
11:16:25 <Nik05> oh
11:18:14 <zennist> How do I sort such that capitals come last?
11:18:40 <zennist> e.g. ["ABC", "abc"] -> ["abc", "ABC"]
11:19:07 <corgifex> [xs !! 1, xs !! 0]
11:19:14 <ReinH> Nik05: your checkHand then becomes: cards <- mapM mkCard (words cs); hand1 <- fmap mkHand (take 5 cards); hand2 <- fmap mHand (drop 5 cards); return (liftA2 (>) hand1 hand2)
11:19:18 <corgifex> your problem is underspecified
11:19:19 <Drezil> o/ can someone help me with a minor monad-matter?
11:19:29 <Drezil> i basically want to extend a  monad
11:19:38 <Drezil> im using attoparsecs parser
11:19:40 <ReinH> Drezil: not until you ask your question :)
11:19:48 <Drezil> and i want to keep track of the chars consumed ..
11:20:07 <nh2> hamishmack: could you uplaod your fix for svgcairo to hackage?
11:20:09 <Drezil> currently i have readFoo :: Parser (Foo, Int64)
11:20:22 <Drezil> and i want the monad to take care of the Int64-counting..
11:20:51 <Drezil> so i have readParser :: MyParser Foo, which has the chars read so far stored internally
11:20:53 <Nik05> ok ReinH guess i can do that too
11:21:19 <Drezil> should be doable with monad-transformers and StateT ..
11:21:28 <Drezil> but i don't  know how to write it exactly
11:21:33 <ReinH> operators are the only place I really want banana brackets. (| hand1 < hand2 |) is nicer than `liftA2 (<) hand1 hand2' or `(<) <$> hand1 <*> hand2' :/
11:21:47 <Nik05> but now it doenst give any error, so i would first like to fix the other problem.
11:21:57 <ReinH> Nik05: which problem? You just asked for "hints" :p
11:22:08 <Nik05> yes its a nice hint, will work on that
11:22:35 <hamishmack> nh2: http://hackage.haskell.org/package/svgcairo
11:22:36 <Nik05> well it should order hands of a card game, seems its not working correctly. Let me try to state my question
11:23:21 <mmachenry> Does anyone have any experience debugging link errors building cabal packages? The Googles are full of results for this error that are responses to bug reports where a new patch has fixed the problem. I suspect, however, mine is likely to be a config error on my end. I'm on Redhat enterprise Linux 6 and here's the error linking postgresql-simple Loading package postgresql-libpq-0.9.0.0 ... linking ... ghc: /home/mmachenry/.cabal/lib/postgresql-libpq-0.9.0
11:23:21 <mmachenry> ghc: unable to load package `postgresql-libpq-0.9.0.0'
11:23:21 <mmachenry> ghc --make: /usr/hs/ghc/7.6.3/bin/ghc failure (return code=1)
11:23:21 <mmachenry> Failed to install postgresql-simple-0.4.2.1
11:23:21 <mmachenry> cabal-1.16.0.2: Error: some packages failed to install:
11:23:21 <mmachenry> postgresql-simple-0.4.2.1 failed during the building phase. The exception was:
11:23:22 <mmachenry> ExitFailure 1
11:23:22 <mmachenry> cabal install: /usr/hs/tools/cabal-1.16.0.2 failure (return code=1)
11:23:32 <mmachenry> Shoot sorry
11:23:35 <ReinH> mmachenry: please use lpaste for multiple lines
11:23:36 <bernalex> mmachenry: FFR, please pastebin long messages.
11:23:39 <mmachenry> I meant to http://lpaste.net/102691
11:23:51 <mmachenry> I just had the wrong thing in my clipboard :( Sorry
11:23:55 <ReinH> np
11:24:07 <hamishmack> nh2: Uploaded it over the weekend, but forgot to comment that it was done on your pull request
11:24:12 <Drezil> mmachenry: use irssi .. :p that warns you when you try to paste more than 4 lines in irc :p
11:24:12 <mmachenry> Had the paste bin all ready to go too :-\
11:24:30 <bernalex> mmachenry: I suggest you install a plug-in for your terminal emulator which warns you about what you are about to paste if it's has '\n's in it.
11:24:46 <mmachenry> Also a good idea.
11:24:53 <Nik05> ReinH do you see any problems with the data Rank and data Hand?
11:25:20 <bernalex> mmachenry: if you happen to use urxvt, set URxvt.perl-ext: confirm-paste :-)
11:25:39 <Nik05> they both derive from Ord, and my question is if they are both ordered correctly when comparing them
11:25:41 <mmachenry> Anyone have advice on the actually problem though? :)
11:25:47 <ReinH> Nik05: is the Ord instance doing what you think it's doing?
11:26:41 <ReinH> Nik05: you can use -ddump-deriv when compiling to show the derived instances
11:26:51 <ReinH> Nik05: or write a test :)
11:27:13 <Nik05> well i think so if comparing two Hands it first needs to compare the Constructors(?) of Hand and if they are equal it then compares the "things after the constructor"?
11:28:09 <Nik05> ReinH how would that -ddump-deriv work?
11:29:26 <zq> man
11:29:37 <zq> why don't people use ${pkgroot} like they should
11:30:00 <zq> cabal sandbox still installing to /path/to/lib/x86_64-linux-blah/asdf
11:30:07 <zq> hsenv sae
11:30:11 <ReinH> Nik05: it's a ghc flag
11:30:27 <Nik05> yes but how to use it?
11:30:34 <ReinH> Nik05: you pass it to ghc
11:30:38 <seanparsons> Is there a way to export everything that another module exports without just manually typing everything out? Thereby creating a convenience module that just needs a single import.
11:30:43 <ReinH> Nik05: one issue is that aces are both low and high, which you don't seem to account for
11:30:58 <Nik05> Oh
11:31:02 <ReinH> so [1,2,3,4,5] and [10,J,Q,K,A] are both valid straights
11:31:03 <c_wraith> seanparsons: yes.  add module Foo to the export list
11:31:12 <ReinH> well, [A,2,3,4,5]
11:31:15 <c_wraith> seanparsons: it'll export everything your module imports from Foo
11:31:19 <seanparsons> c_wraith: Amazing, cheers for that!
11:31:24 <ReinH> Nik05: that probably won't affect comparisons but it is a bug
11:31:27 <Nik05> i have a Card pack that has a 1 instead of a A
11:31:35 <Nik05> i guess thats the problem
11:31:47 <ReinH> Nik05: but then you need an equivalency class for 1 and A for pairs, trips, etc
11:32:12 <Nik05> ReinH well the problem im doing states that Ace is the highest value
11:32:29 <ReinH> it's high for pairs
11:32:32 <ReinH> but it can be low for straights
11:32:41 <ReinH> if you're doing poker rankings
11:33:06 <Nik05> oh dman
11:33:10 <Nik05> damn*
11:33:31 <Nik05> how could i implement that?
11:33:38 <ReinH> Nik05: btw your Eq instance for Card can be (==) = (==) `on` rank
11:33:43 <ReinH> well
11:33:55 <ReinH> it's rather frustrating, actually
11:33:57 <nh2> hamishmack: ah, I see. Would you mind making another upload?
11:33:59 <ReinH> I remember having a conversation in here
11:34:15 <Nik05> no ReinH, well im cheating. THis is probably not how i should do this? :P
11:35:04 <Nik05> otherwise it also checks for Suit, which i dont want when just checking for rank
11:35:45 <ReinH> @src on
11:35:45 <lambdabot> (*) `on` f = \x y -> f x * f y
11:36:03 <ReinH> (==) `on` rank = \x y -> rank x == rank y
11:36:07 <hamishmack> nh2: did I miss something?
11:36:27 <hamishmack> nh2: or do you have another fix?
11:36:31 <ReinH> and Ord can be compare `on` rank
11:36:40 <ReinH> except this doesn't handle the pesky Ace
11:36:56 <bennofs> seanparsons: I recommend to read http://www.vex.net/~trebla/haskell/module.xhtml, should protect you from some unexpected things :)
11:37:21 <seanparsons> bennofs: Uh oh, landmines ahead.
11:37:38 <nh2> hamishmack: ah sorry, I misread what you wrote - let me double check
11:39:18 <ReinH> Nik05: I'm looking for that discussion I had about this
11:39:34 <Nik05> discussion about what?
11:40:20 <bennofs> seanparsons: that site also contains alot of useful information about cabal :)
11:40:26 <bennofs> s/alot/a lot
11:40:34 <seanparsons> Now this I need.
11:41:07 <nh2> hamishmack: I'm sorry, I forgot one part in the pull request :( I imported `System.IO.Unsafe as Unsafe`, but I forgot to add my change of `unsafePerformIO` to `Unsafe.unsafePerformIO` to the pull request
11:41:16 <ReinH> Nik05: dealing with ace when checking for straights
11:41:21 <Nik05> ah ok
11:41:44 <nh2> hamishmack: would you mind if I send you another PR, or do you want to add that yourself? (in https://github.com/nh2/svgcairo/blob/fd9ec831bdb9ab8c3bc97f42c8a017dd2a2a169b/Graphics/Rendering/Cairo/SVG.chs#L222)
11:42:56 <Nik05> ReinH guess i can just add || rankGroup 0 == Ace && rankGroup 1 == Two etc...
11:42:59 <ReinH> Nik05: because if Rank formed a bounded enum you could just do isStraight hand = sort hand `isInfixOf` [minBound..maxBound]
11:43:04 <ReinH> which is rather nice
11:43:07 <ReinH> but it doesn't
11:43:09 <ReinH> because it's cyclic
11:43:24 <Nik05> ah right yes
11:44:08 <ReinH> (http://en.wikipedia.org/wiki/Cyclic_order)
11:44:12 <hamishmack> nh2: Just going to bed.  Can you please send a pull quest and I will merge and upload to hackage when I wake?
11:44:16 <Nik05> well maybe i can do sort hand `isInFixOf` Ace:[minBound..maxBound]
11:44:39 <ReinH> Nik05: except that it's not *really* a cyclic order because KQA23 is not a straight
11:44:43 <ReinH> *sigh*
11:44:45 <Nik05> no wait then the Ace is not lower
11:44:54 <nh2> hamishmack: will do. Thanks!
11:45:10 <ReinH> Nik05: actually if your ranks are [R2..Ace] then that might just work
11:45:58 <ReinH> Nik05: heh, A:[R2..A] is exactly what I had before
11:46:11 <Nik05> but then the sort hand doesnt work :)
11:46:24 <Nik05> because then you get [2, 3, 4, 5, Ace]
11:47:06 <ReinH> Nik05: right, so
11:47:42 <ReinH> Nik05: create a typeclass where A is the lowest rank
11:47:59 <ReinH> er
11:48:02 <ReinH> newtype, not typeclass
11:48:05 <ReinH> check for straights once with the normal ordering, once with the newtype
11:48:11 <Nik05> oh ok
11:48:58 <Nik05> and the highest card in [Ace, 2, 3, 4, 5] is 5, right?
11:49:09 <ReinH> with the newtype's Ord, yes
11:49:48 <ReinH> make them both bounded enums and you can use the isInfixOf definition
11:50:04 <ReinH> hmm
11:52:20 <srhb> Where do I find the function monoid?
11:52:40 <shachaf> Are you asking about a function named "monoid" or a monoid instance for functions or what?
11:53:05 <c_wraith> the latter
11:53:06 <srhb> Haha
11:53:09 <srhb> Yeah the latter.
11:53:13 <ReinH> @hoogle Endo
11:53:13 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
11:53:14 <lambdabot> Data.Monoid newtype Endo a
11:53:14 <lambdabot> System.Posix.Terminal.ByteString EndOfFile :: ControlCharacter
11:53:18 <shachaf> :i in ghci can tell you where an instance is defined.
11:53:26 <shachaf> instance Monoid b => Monoid (a -> b) -- Defined in `Data.Monoid'
11:53:44 <ReinH> oh tha tone
11:53:47 <ReinH> *that one
11:53:57 <shachaf> There's also Endo, which is another kind of Monoid you can make out of some functions.
11:53:58 <Nik05> so ReinH how do i actually get ghc to through out derived instances with -ddump-deriv?
11:54:06 <Nik05> cant get it to give me them
11:54:33 <ReinH> Nik05: it should just print them out http://stackoverflow.com/questions/18538055/how-to-automatically-generate-and-see-the-code-for-read-and-show-in-haskell
11:55:02 <shachaf> Maybe your code isn't being compiled because you haven't changed it since the last time you compiled and you didn't use -fforce-recomp
11:55:46 <Rylee> @src reverse
11:55:47 <lambdabot> reverse = foldl (flip (:)) []
11:56:57 <ReinH> shachaf: oh good point
11:57:38 <bennofs> Rylee: note that lambdabot simply uses a hardcoded database for src, so @src might not give exactly the same thing that GHC uses when compiling code (although the behaviour should be identical, but GHC might use different implementations that have better performance)
11:58:57 <Nik05> oh ReinH wait now its printing out all crap :)
12:00:12 <Nik05> ReinH i think it wasnt compiling, something todo with the --make wowo of ghc or something
12:02:33 <Nik05> ok seems to work now ReinH :)
12:02:47 <kuribas> @hoogle a -> b
12:02:47 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:02:47 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:02:47 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
12:03:24 <kuribas> > unsafeCoerce 2 :: String
12:03:26 <lambdabot>  Not in scope: ‘unsafeCoerce’
12:04:17 <Nik05> ReinH seems like the problem doesnt have any low straights in it. I am doing project euler problem 54. But also still getting wrong result :(
12:04:43 <identity> @src span
12:04:44 * int-e eyes kuribas suspiciously.
12:04:44 <lambdabot> span _ xs@[]                     =  (xs, xs)
12:04:44 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
12:04:44 <lambdabot>                   | otherwise    =  ([],xs)
12:04:46 <identity> @src partition
12:04:47 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
12:04:47 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
12:04:47 <lambdabot>                               | otherwise = (ts, x:fs)
12:05:09 <identity> oh.
12:05:12 <Nik05> maybe the problem in project euler 54 isnt really wants going on with poker
12:05:38 <kuribas> int-e: I was reading that there are only a limited number of implementations for functions with type variables.
12:05:54 <kuribas> int-e: So a -> b shouldn't exist?
12:05:56 <Nik05> ReinH: like what is the rank of three of a kind?
12:06:03 <Nik05> no i mean Full House
12:06:36 <merijn> kuribas: Well, there's several implementations of that type, although most of them not very useful
12:06:57 <merijn> kuribas: i.e. "undefined", "\x -> undefined"
12:07:05 <int-e> kuribas: There is  const undefined, and  seq
12:07:18 <kuribas> merijn: Yeah, undefined breaks that law.
12:07:30 <Nik05> ah damn
12:07:36 <int-e> (and some people dislike the latter because it interacts badly with eta reduction.)
12:07:36 <Nik05> Project Euler made a mistake...
12:07:40 <dwat3r> hi guys, i have a bit of an implementation problem
12:07:52 <int-e> Nik05: oh?
12:08:26 <kuribas> int-e: why seq?
12:08:28 <dwat3r> i have a lot of data definitions, and i would like to make a function which concatenates them,keeping their data for later accessing and modifying
12:08:28 <kuribas> :t seq
12:08:29 <lambdabot> a -> b -> b
12:08:53 <int-e> kuribas: oops. sorry, brain failed.
12:09:24 <Nik05> int-e well if two players have Full House, first the Ranks of the three cards are matched, if they are the same then the pairs are matched
12:09:27 <dwat3r> with what can I achieve this? Like I have: Point x y :+: Circle x y
12:09:47 <dwat3r> and :+: is a data typeoperator
12:09:50 <int-e> kuribas: I guess I wanted  \x -> x `seq` undefined, which is denotationally the same as \x -> undefined, but may return different bottoms. Never mind.
12:09:52 <Nik05> to get the right project euler answer you shouldnt do it that way but just rank by highest card
12:10:51 <kuribas> int-e: the question is if you can get the type (a -> b) without undefined, or error?
12:10:52 <Nik05> (well i think so let me check again :P)
12:11:05 <int-e> Nik05: Ah. But the page specifies the rules, and the problem works fine if you follow that specification.
12:11:47 <Nik05> no not really
12:11:52 <merijn> int-e: "denotationally the same"and "different bottoms" in the same sentence makes little sense
12:12:00 <monochrom> hehehe
12:12:03 <int-e> merijn: I know!
12:12:05 <merijn> int-e: Denotationally there is only one bottom
12:12:21 <Nik05> int-e: it says "If two players have the same ranked hands then the rank made up of the highest value wins" But i think they calculate the rank wrong
12:12:29 <kuribas> :t fix
12:12:30 <lambdabot> (a -> a) -> a
12:12:33 <monochrom> how about "denotationally same, operationall different"
12:12:46 <monochrom> and I forgot a "y"
12:14:02 <ReinH> Nik05: well the problem explicitly defines the ranking as [R2..A] so I don't think you need to worry about ace low
12:14:19 <Nik05> correct ReinH
12:14:29 <kuribas> :t let x = x in x
12:14:30 <lambdabot> t
12:14:45 <monochrom> anyway, have you seen my newly finished I/O tutorial! http://www.vex.net/~trebla/haskell/IO.xhtml
12:15:07 <monochrom> and my monad tutorial! http://www.vex.net/~trebla/haskell/Monad.xhtml
12:15:18 <monochrom> my monad tutorial is the best and shortest ever!
12:15:18 <kuribas> Could it be possible for a haskell compiler to detect bottom (in some cases)?
12:15:35 <monochrom> yes
12:15:51 <Nik05> no wait thats not the problem :S
12:16:01 <int-e> Nik05: I see, you're right. The interesting bit is how that mix of 'three of a kind' and 'two of a kind' that the full house is are compared. I guess that's what example 5 is for.
12:16:20 <int-e> Nik05: "If two players have the same ranked hands then the rank made up of the highest value wins"
12:16:37 <Nik05> int-e i just tried out and it seems the problem doesnt have a hand in which this occures
12:17:14 <monochrom> GHC runtime detects the "x = x && x" kind because a good implementation of lazy evaluation cannot avoid noticing it anyway. and if you also support parallel evaluation you really want to notice it.
12:17:18 <fizbin> What's the natural way to structure this computation? I have a [Foo], and I need to try several optimizations on [Foo] to make it into a different [Foo]. I was going to write each optimization as [Foo] -> Maybe [Foo] to indicate when an optimization was able to improve things, and then do something like:
12:18:03 <fizbin> repeatUntilNothing $ sequence [optimization1, optimization2, ... ] >>> foldr (<|>) empty
12:18:25 <fizbin> Where "repeatUntilNothing" has the type (a -> Maybe a) -> a -> a
12:19:09 <monochrom> sequence will not be right, but otherwise you are on the right track
12:19:14 <Nik05> int-e: but it seems i still dont get the right result :( (im 12 off)
12:19:36 <monochrom> hmm, sequence will be right if you give it the right stuff
12:19:48 <fizbin> But the thing is, some of these optimizations work recursively and with this signature of (a -> Maybe a) for an optimization is annoying to do recursively.
12:20:09 <Nik05> so maybe 12 are incorrect or more are incorrect which equal out to 12
12:20:13 <fizbin> monochrom: Each optimization has the signature [Foo] -> Maybe [Foo]
12:20:23 <aloiscochard> does anyone know how I can reify a GHC.TypeLits.Nat from an Integer?
12:21:03 <ReinH> Nik05: if you care about the "correct" way to check for a straight, http://lpaste.net/102693
12:21:35 <merijn> > let x = x && x in x -- now I'm curious
12:21:38 <lambdabot>  mueval-core: Time limit exceeded
12:21:42 <merijn> Right
12:22:41 <fizbin> Because with the recursive step, what I end up with is something that feels unnatural where I take the result of applying the optimization to each part and if each part returns Nothing and I can't do anything to the top-level, I return Nothing, but if anything returns (Just x), then I need to replace all the Nothing return values with their inputs, reconstruct the thing, and return Just that.
12:23:08 <fizbin> It feels unnatural to be combining things like that.
12:23:10 <Nik05> ah ReinH you can also map a type constructor
12:23:21 <ReinH> Nik05: a data constructor?
12:23:25 <Nik05> well ofcrouse its just a function...
12:23:32 <fizbin> Maybe I should write this up as actual code, since my hand-waving seems pretty incoherent.
12:23:34 <ReinH> Maybe is a type constructor, Just is a data constructor :)
12:23:47 <Nik05> ReinH uh ok i mean data constructor
12:24:01 <ReinH> Nik05: yep, it's just a function :)
12:24:31 <Nik05> make sense, just wouldnt come up in my head
12:25:05 <Drezil> meh ... im not getting the monad-transformer-thing for my purpose ... having a state of "Int64" and bind taking care of increasing that by a user-supplied number in do-notation ..
12:25:54 <Drezil> can anyone help me with that?
12:26:43 <kakos> What's the best FRP library at the moment?
12:26:50 <Drezil> kakos: depends.
12:26:52 <prophile> bacon.js
12:27:06 <kakos> Drezil: On?
12:27:09 <Drezil> netwire or wire is good for games and other real-time-stuff..
12:27:43 <Drezil> and there are others which are more relaxed from the constraints of the *wire .. but are not suited for realtime
12:28:04 <kakos> Why aren't others suited for realtime?
12:28:07 <Drezil> (not explicitely suited)
12:28:21 <Drezil> the
12:28:54 <Drezil> they have some relaxed constraints which allow for long computations at runtime
12:29:09 <Drezil> wires have discrete steps ..
12:29:13 <identity> How would I use a viewpattern to check if the length of a list is even? Is this possible? I've never used them before, would like to try them out
12:29:34 <Drezil> i think the others support continuous time-functions as well..
12:29:44 <monochrom> f (even . length -> True) = "length is even"
12:29:53 <monochrom> untested
12:30:28 <identity> oh, there we go
12:30:29 <identity> thanks!
12:30:37 <kuribas> What's a good starting point for learning FRP for widgets?
12:30:38 <monochrom> I almost told ghci ":m + ViewPatterns". yikes.
12:31:37 <kakos> Drezil: Hmmm. So, the others could theoretically support more realtime applications, but the functionality isn't built in
12:31:56 <kakos> Drezil: Of the non-wire libraries, which is the "best"?
12:32:07 <monochrom> general f ((\x -> blahblah) -> pattern) = ... also works :)
12:32:09 <Drezil> kakos: i dont know .. for my game i needed a rt-capable :p
12:32:32 <kakos> Drezil: Ha. Okay. You use Netwire?
12:32:50 <Drezil> kakos: with relaxed constraints you cannot guarantee that your code is finished after X cycles...
12:33:09 <Drezil> so you can't assume "instant" calculation..
12:33:13 <Drezil> therefore no "realtime"
12:33:38 <Drezil> but more close to "simulating reality in respect to time"
12:33:43 <Drezil> kakos: yup.
12:33:54 <Drezil> i mean .. we want to ..
12:34:01 <kakos> Drezil: Pretty good experience with it so far?
12:34:13 <Drezil> the programmer responsible has not had his presentation yet .. :p
12:34:33 <kakos> Haha
12:34:36 <Drezil> not much .. just a few samples
12:34:48 <Drezil> its bad to have a game without "game-logic" ..
12:35:03 <Drezil> but atm we have just map-generation, graphics and a rudimentary gui
12:35:20 <kakos> Thanks for the info!
12:35:23 <Drezil> np
12:35:51 <kakos> Is netwire still in active development?
12:36:05 <Drezil> kind of
12:36:17 <Drezil> the author just rewrites it to "wire" ...
12:36:23 <kakos> Last change looks like 2 Jan 2014
12:36:25 <Drezil> with further optimisations ..
12:36:27 <monochrom> it is bad to have a program without program logic
12:36:38 <Drezil> to get it even faster
12:36:50 <Drezil> like C fast.
12:36:51 <monochrom> well, generally, it is bad to engineer X without an X logic
12:37:05 <Drezil> monochrom: we are not finished :p
12:37:06 <Drezil> far from it
12:37:13 <Drezil> we just get the parts together atm
12:37:22 <monochrom> but of course, some programmers insists that they're crafting art, not engineering a construction.
12:37:26 <Drezil> im writing a binary-parser for the models we want to load .. :/
12:37:50 <Drezil> never done OpenGL3.x before .. now i have :D
12:37:57 <kakos> Drezil: So, FRP.Netwire is the old stuff and Control.Wire is the new optimized version?
12:38:06 <Drezil> never worked with RWST .. now i have :p
12:38:25 <Drezil> kakos: im not sure. maybe he has not pushed it onto hackage ..
12:38:43 <Drezil> hi edwardk!
12:38:58 <Drezil> you can answer my question about monad-transformers for sure :D
12:39:13 <corgifex> monochrom: I'm arting math!
12:39:23 <kakos> Be careful. They're more than meets the eye.
12:39:45 <corgifex> comonad-decepticons
12:40:37 * edwardk waves hello.
12:40:39 <edwardk> if i knew what the question was ;)
12:40:59 <Drezil> and i need to keep edwardk: haskell-game .. i thik it fits better there
12:44:05 <monochrom> I think I have found it. <Drezil> meh ... im not getting the monad-transformer-thing for my purpose ... having a state of "Int64" and bind taking care of increasing that by a user-supplied number in do-notation ..
12:47:06 <ReinH> monochrom: that is not, in fact, a question.
12:47:15 <ReinH> You can tell because it doesn't end with a "?"
12:47:16 <ReinH> ;)
12:48:01 <monochrom> I know a person who uses "." for questions, "?" for answers.
12:48:48 <corgifex> that's ridiculous,
12:49:29 <monochrom> it is natural after you have heard him speak vocally. the "." and "?" denote intonations in speech.
12:49:30 <tobani> monochrom:  wait was that a question?
12:49:47 * hackagebot tiempo 0.0.1.0 - Specify time intervals in different units (secs, mins, hours, etc.)  http://hackage.haskell.org/package/tiempo-0.0.1.0 (RomanGonzalez)
12:50:21 <monochrom> for example, when he answers your question, he puts an accent at the end (denoted by "?"), perhaps to indicate "does that answer your question?"
12:50:28 <corgifex> how does chinese do questions? it's so toney
12:51:04 <monochrom> the exact wording tells you
12:51:57 <corgifex> so you can't form a question just with a rising tone?
12:52:03 <Zekka> Question is here: topic is dependency hell with ghc-mod: http://lpaste.net/102694
12:52:18 <Zekka> Sorry to bother folks.
12:52:34 <monochrom> why, what, how etc questions have word-for-word translations in Chinese. you do not need punctuation or intonation to tell you that "how to learn Haskell" is a question.
12:53:06 <merijn> monochrom: Not always
12:53:19 <monochrom> as for "do you have suggestions", the Chinese wording is "have or not have suggestions".
12:53:20 <merijn> monochrom: It could be a title of a book/talk :p
12:53:36 <corgifex> monochrom: interesting
12:53:44 <c_wraith> How to learn haskell, chapter one:  study.
12:54:05 <merijn> c_wraith: I thought step one was to get an implant by the martians
12:54:28 <c_wraith> That's chapter one of how to become Oleg
12:54:33 <mmachenry> merijn: No step one is to change your name to Simon.
12:55:03 <Zekka> In retrospect that might have been kind of a rude way to present a question: sorry about that, I was trying to be concise
12:55:24 <monochrom> I don't see rudeness. don't worry.
12:55:26 <corgifex> Zekka: I thought it was unnecessarily polite
12:55:32 <corgifex> but I don't have a solution
12:55:32 <merijn> c2hs is amazingly brittle ಠ_ಠ
12:55:47 <merijn> It died on indented CPP directions
12:55:47 <Zekka> I've been trying to solve this problem for about four days without much success
12:55:53 <mmachenry> Learn Haskell: Step 1) Legally change your name to Simon. Step 2) Get a PhD in math with your thesis focused on category theory. Step 3) Read the language definition for Haskell.
12:56:09 <Zekka> it's irritating me because Haskell is probably my favorite language to actually work in but the build system likes to fight me at every turn
12:57:30 <awestroke> Zekka: rm -rf ~/.ghc ~/.cabal, or get hsenv
12:57:34 <merijn> Zekka: afaict it's not the projects depending on HSdirectory that's the problem
12:57:40 <merijn> Zekka: ghc-mod itself seems broken
12:57:57 <Zekka> awestroke - Already tried the first, including clearing global packages
12:58:04 <merijn> awestroke: That's not very constructive advice and hsenv is a bit of a non-solution
12:58:09 <Zekka> I haven't tried hsenv, is that similar to cabal sandbox?
12:58:15 <Zekka> merijn - I suspected it but couldn't confirm
12:58:45 <monochrom> be careful what global packages you clear. don't touch packages that come with GHC
12:58:52 <Zekka> ghc-mod lint works correctly, though: I'm assuming that you mean that ghc-mod check is incorrectly determining what it needs to load to run my code, not that ghc-mod was built incorrectly?
12:58:59 <awestroke> merijn: I've never heard of another solution, people always just say "nuke it"
12:59:13 <Zekka> monochrom - I reinstalled GHC after and most of my builds work fine.
12:59:14 <merijn> awestroke: Depends on how you broke it
12:59:28 <merijn> Zekka: Did you nuke those folders before reinstalling?
12:59:43 <Zekka> merijn - Both the local ones and the ones which (from what I can tell) were the global ones
12:59:44 <srhb> am I the only one missing foo Nothing _ = return (); foo (Just x) f = f x ?
12:59:49 <srhb> I seem to need it all the time...
12:59:58 <srhb> time to abuse fromMaybe.
13:00:10 <merijn> srhb: Same here
13:00:14 <monochrom> @type fromMaybe
13:00:15 <lambdabot> a -> Maybe a -> a
13:00:17 <corgifex> maybe (return ()) f
13:00:21 <corgifex> maybe def f
13:00:23 <merijn> srhb: I once proposed it on the mailing list but it got shot down
13:00:24 <dmj`> srhb: I like Data.Foldable.forM_
13:00:32 <monochrom> yeah, "maybe" is better for this
13:00:46 <srhb> Right, that's the one I meant
13:00:47 <monochrom> @type Data.Foldable.forM_
13:00:48 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
13:00:53 <Zekka> I couldn't find clear documentation on what the global directories were so I looked for directories containing 'ghc' and 'cabal' and then inspected their contents
13:01:01 <monochrom> @type Data.Foldable.forM
13:01:02 <lambdabot>     Not in scope: ‘Data.Foldable.forM’
13:01:02 <lambdabot>     Perhaps you meant one of these:
13:01:03 <lambdabot>       ‘Data.Foldable.fold’ (imported from Data.Foldable),
13:01:15 <dmj`> @src Data.Foldable.forM_
13:01:15 <lambdabot> Source not found. My mind is going. I can feel it.
13:01:16 <merijn> monochrom: forM is in Traversable
13:01:17 <Zekka> merijn - If ghc-mod is broken, then can you suggest any comparable tools? That's all googling found me
13:01:25 <Zekka> er, ghc-mod is
13:01:26 <monochrom> @type Data.Traversable.forM
13:01:27 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
13:01:35 <dmj`> forM_ *
13:01:37 <monochrom> that won't do
13:01:49 <merijn> Zekka: I always use hdevtools with syntastic
13:01:57 <Zekka> merijn - Good suggestion, I'll check it out
13:02:15 <kuribas> Are most haskell programmers computer scientists?
13:02:23 <corgifex> not me
13:02:26 <monochrom> Zekka: my http://www.vex.net/~trebla/haskell/sicp.xhtml lists directories
13:02:27 <Zekka> I'm not
13:02:31 <aloiscochard> not me
13:02:41 <monochrom> most haskell programmers are programmers
13:02:44 <Zekka> monochrom - Thanks.
13:02:51 <aloiscochard> or haskellers
13:03:02 <monochrom> most programmer humans are humans
13:03:08 <aloiscochard> :-D
13:03:29 <monochrom> tautologies are more informative than people think :)
13:03:49 <corgifex> hofstadter's number
13:03:50 <kuribas> monochrom: Well, it's not uncommon to get an answer about semantics on this channel, which would be very unusual on ruby or perl or so...
13:03:51 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html
13:04:25 <corgifex> kuribas: I don't think it would be unusual in #perl
13:04:29 <corgifex> (I'm in #perl)
13:04:42 <monochrom> then you're looking at one or both of these phenomena: 1. vocal minority; 2. programmers who happen to be more knowledgeable than average
13:04:42 <Zekka> Can you clarify what you mean when you say "an answer about semantics"?
13:04:44 <aloiscochard> it's very common in #scalaz or #shapeless
13:04:53 <[swift]> this output from cabal install is strange to me: https://gist.github.com/sethfowler/9fdd7da43cff35360ccf
13:05:13 <[swift]> doesn't that mean that regex-posix would work if built with a newer bytestring?
13:05:24 <[swift]> i don't understand why it doesn't just do that automatically
13:05:38 <[swift]> i checked and regex-posix doesn't put version bounds on bytestring at all
13:05:49 <kuribas> Zekka: Well, an answer involving precise terminology from semantics.
13:06:09 <c_wraith> [swift]: it looks a lot like you already have two different versions of bytestring installed, which is dangerous thing
13:06:15 <merijn> [swift]: It's saying that LibClang and regex-posix have incompatible bounds on bytestring
13:06:18 <monochrom> actually, how about one more possible phenomenon: 3. people in #ruby or #perl do not qualify as programmers (esp. if you raise the bar on programmer qualifications)
13:06:29 <[swift]> c_wraith: that is true. not sure how that happened =\
13:06:31 <Zekka> merijn - hdevtools seems to say 'could not find module' very often for me
13:06:39 <Zekka> Should I configure it differently than I have?
13:06:48 <Zekka> I've just installed it and started staring at my code
13:07:06 <[swift]> merijn: well, LibClang's bound is >= 0.10 & < 0.11
13:07:12 <corgifex> kuribas: does "don't do that, it has undefined behavior" count?
13:07:18 <[swift]> so it should be compatible, i'd think...
13:07:28 <awestroke> monochrom: that kind of elitism is toxic to programming communities
13:07:31 <kuribas> corgifex: no
13:07:43 <Zekka> I can see that you can pass it a source folder directly, but is there a way I can ask it to find/read my cabal file on its own?
13:07:44 <geekosaur> right, but it shows a /installed-... so it already is installed and linked against a *different* installed bytestring
13:07:49 <geekosaur> which all by itself means trouble
13:08:02 <kuribas> corgifex: I mean precise terminology from denotational semantics.
13:08:18 <geekosaur> because you have at least two versions of bytestring installed, and different librairs linked against different versions
13:08:20 <merijn> Zekka: Are your module in a different place from your working dir?
13:08:22 <dmj`> are there any ghc-ios apps on the apple app store?
13:08:33 <corgifex> kuribas: ok, that's very unlikely
13:08:34 <merijn> Zekka: By default it searches your working dir for modules
13:08:35 <Zekka> merijn - My working dir is the directory of my cabal project
13:08:45 <Zekka> The source code is in a source folder
13:08:48 <[swift]> geekosaur: yeah.. i thought it was OK to do that, but i guess not
13:09:00 <kuribas> I am not trying to be derogatory on ruby or perl programmers, it's probably because haskell has a more solid basis from CS.
13:09:00 <Zekka> The source folder for each part of my project is listed in the cabal file, which I feel it ought ot be able to analyze
13:09:00 <merijn> Zekka: Right but is your source in cabal-pkg/src/ or in cabal-pkg/
13:09:09 <Zekka> merijn - It's in pkg/src/
13:09:14 <geekosaur> it's rarely ok, and never safe for bootlibs (that is, stuff the compiler depends on)
13:09:15 <merijn> Zekka: It ought to be, but doesn't
13:09:22 <[swift]> geekosaur: what i'm trying to do is get my application to build with *both* ghc 7.6 and ghc 7.8
13:09:25 <Zekka> There's also code in pkg/exe and pkg/test though
13:09:26 <merijn> Zekka: I tried adding cabal parsing to hdevtools, but gave up
13:09:46 <Zekka> So what, should I just list all of the source directories I usually use as -i arguments?
13:09:47 <monochrom> awestroke, that gets really deep into "what is a programming community" or rather "what do you want a programming community to behave like". for the other end of the spectrum, anti-elitism leads to an ignorant, self-congratulating community, which counts as a strong community as well. do you will it?
13:09:51 <geekosaur> how are you getting the same libraries visible in both? ghc 7.6 can only see its own libs, likewise 7.8
13:09:55 <[swift]> geekosaur: i suspect that's how i've introduced this problem.. probably one of the dependencies i've added has pulled in some ghc 7.8 stuff
13:10:05 <geekosaur> they have separate package repos
13:10:07 <Zekka> It seems hacky but most of the folks I know are consistent enough it shouldn't actually break anything
13:10:08 <merijn> Zekka: https://github.com/merijn/dotfiles/blob/master/vimrc#L152
13:10:24 <[swift]> geekosaur: sure, but what i'm sharing between them is the cabal file
13:10:24 <merijn> Zekka: I just pass directories as -i arguments, yes
13:11:14 <Zekka> And you change it if you need to work on someone else's code and they use different directories?
13:11:33 <merijn> Zekka: Hasn't occured that often yet
13:11:51 <merijn> Zekka: That or cd to the source dir to open files from there
13:12:07 <awestroke> monochrom: do you think that saying that everyone who likes ruby or perl are not even worth classifying as programmers is a good thing? I think it's childish and ignorant. Different tools etc.
13:12:22 <monochrom> but I did not say that
13:12:47 <Zekka> merijn - I'll try it and report back if things don't work well
13:12:58 <Zekka> I like how quickly it was able to check for errors -- that's promising
13:13:13 <kuribas> monochrom: I agree.  Anti-elitism is often used as an excuse for people who don't want to learn more.
13:13:16 <corgifex> let me quote you out of context: "people in #ruby or #perl do not qualify as programmers"
13:13:23 <geekosaur> awestroke, as a member of the Perl community I can tell you that there is a LOT of crap from people masquerading as Perl programmers
13:13:32 <merijn> Zekka: The main difference between hdevtools and ghc-mod is that hdevtools spawns a background server that stays running to query for types, etc.
13:13:41 <Zekka> merijn - Yeah, I saw it on their readme page
13:13:44 <merijn> Zekka: ghc-mod has to startup the compiler every time you call it
13:13:48 <geekosaur> unfortunately aided and abetted by such things as O'Reilly Perl books that haven't actually been updated in years and still teach slightly-warmed-up perl 4
13:13:51 <Zekka> ghc-mod runs hlint and then feeds your project to ghci, right
13:13:53 <Zekka> ?*
13:13:53 <lambdabot> Maybe you meant: v @ ? .
13:14:16 <Zekka> (putting ghc errors and hlint ones respectively in the appropriate places in the code)
13:14:35 <merijn> I'm all in favour of next year having a GSoC project to extend hdevtools with cabal, sandbox and chs/etc support
13:14:46 <aloiscochard> merijn: does hdevtools play well with cabal sandbox? I remember at the time I tried it I had issue and gave up
13:15:01 <merijn> Zekka: syntastic also supports hlint directly
13:15:02 <Zekka> You mind if I steal that from your vimrc by the way? I don't feel like recreating it from scratch
13:15:06 <Zekka> ditto on aloisco's comment by the way
13:15:09 <merijn> aloiscochard: I don't think it does
13:15:24 <aloiscochard> merijn: that's kind of a killer, not for you?
13:15:45 <merijn> aloiscochard: I tried adding it, but it was not as trivial as I hoped and it stranded on the pile of "I should be doing productive work instead"
13:15:55 <merijn> aloiscochard: tbh I don't use sandboxes that often
13:16:14 <kuribas> awestroke: you can be a good programmer without knowing math or CS, but I do believe that knowing it makes you a _better_ programmer.
13:16:17 <leroux> make
13:16:37 <aloiscochard> merijn: interesting, atm I'm switching between project compiled with GHC 6 / 7. would be impossible without I suppose
13:16:54 <Zekka> merijn - It doesn't seem to be throwing up on my code which relies on a sandbox
13:17:13 <merijn> aloiscochard: Why? sandboxes are completely redundant in case of different GHC versions
13:17:16 <Zekka> actually, though, it's not throwing up on obviously incorrect code either
13:17:21 <merijn> aloiscochard: GHC maintains separate databases per version
13:17:52 <merijn> Zekka: I think by default I have it set to only run on save in my vimrc
13:18:02 <aloiscochard> merijn: ah! very good to know :-)
13:18:03 <merijn> aloiscochard: So different GHC versions can never interfere
13:18:19 <Zekka> merijn - I'm getting interesting behavior
13:18:26 <merijn> aloiscochard: I run multiple GHC in parallel by just doing updating which comes first in my PATH, no problems
13:18:26 <corgifex> I think you can't be a good programmer by knowing math/CS *only*
13:18:28 <aloiscochard> merijn: I see, so if I work on projects which share roughly the same "stack", I don't really need sandboxing ever?
13:18:38 <merijn> aloiscochard: Right
13:18:43 <Zekka> It doesn't respond to bad imports unless I have other obviously incorrect code
13:18:56 <aloiscochard> merijn: the only thing is that when I forked an open source lib... but wait, usually it's part of the stack too
13:19:01 <Zekka> at that point it complains exclusivevly about the imports
13:19:09 * aloiscochard realize he's over-sandboxing
13:19:23 <Zekka> I usually have a sandbox per project, is there a reason I would not want to do this?
13:19:37 <Zekka> Other than "it breaks hdevtools"?
13:19:39 <merijn> aloiscochard: Right so when I tend to work on an open source lib I also have installed (say pandoc), I sandbox the dev version, but it shares all the global dependencies without problem so hdevtools still works
13:19:41 <aloiscochard> Zekka: using a tool that don't support it, and avoid multiple recompilatino
13:19:53 <merijn> Zekka: Wastes compile time and library sharing :)
13:20:06 <Zekka> merijn - How often do you run into mutually exclusive dependencies?
13:20:14 <aloiscochard> merijn: oh my, that sound so nice. So you create a "sub" sandbox kind of thing, right?
13:20:17 <Zekka> (and/or other "dependency hell" situations)
13:20:34 <merijn> aloiscochard: sandboxes automatically default to using the system installed libraries if they work
13:20:54 <aloiscochard> merijn: oh I see, but I completely cleaned my system one (aside cabal)
13:21:01 <merijn> Zekka: Almost never, but most of my haskell code is very light on dependencies (i.e. I don't use Yesod style dependency jungles)
13:21:17 <aloiscochard> merijn: thank you for all this explanation, that will improve my fresh working flow
13:21:30 <aloiscochard> merijn: do you have a trick to get ctags for all  the stuff in system then?
13:21:31 <bitemyapp> thoughtpolice: hey, thanks for adding me to the meetup group :)
13:21:45 <bitemyapp> thoughtpolice: now that GHC 7.8.2 is out, is there going to be a Haskell meetup anytime soon?
13:21:59 <Zekka> It looks like someone wrote up a quick hack to make hdevtools play nice witih sandboxes
13:22:02 <bitemyapp> thoughtpolice: if there are no topics or speakers lined up, I'd be willing to do a hands-on "learn Haskell" class if a venue can be found.
13:22:02 <Zekka> going to see if itw orks
13:22:13 <thoughtpolice> bitemyapp: yes, i need to organize another meetup. I was talking with Francesco (one of the Rackspace engineers) about it just this week actually
13:22:43 <thoughtpolice> Rackspace has actually internally adopted Haskell somewhat (apparently because my talk convinced some of them ;) so they speculate they can also get some people to step up and talk
13:23:00 <merijn> aloiscochard: I use hdevtools for local tags and I don't really use global tags, mostly because I haven't found a good tag generator for haskell
13:23:09 <thoughtpolice> at the time I had something else I wanted to demo earlier last year, but I got swamped with the release and couldn't find time to finish it (JSON/HTTP REST API blah thing that's so popular these days)
13:23:14 <thoughtpolice> so i can dust it off and talk about that as wel
13:23:16 <thoughtpolice> *well
13:23:19 <bitemyapp> thoughtpolice: excellent. I'm Chris Allen btw. That sounds great. I've an interest in ops code for Haskell myself. I've found Joey Hess's posts on Propellor to be pretty neat.
13:23:39 <aloiscochard> merijn: yeah, I came to same conclusion yesterday... but I waste so many time on google, did you tried running a local hoogle or something like that?
13:23:40 <bitemyapp> thoughtpolice: I've got an initial version of an elasticsearch client for Haskell I'm working on, it's usable and demoable but still needs refinement.
13:24:48 <bitemyapp> thoughtpolice: not necessarily right now, but I'd actually love some API advice from more experienced Haskellers.
13:24:51 <bitemyapp> https://github.com/bitemyapp/Bloodhound/
13:24:52 <thoughtpolice> oh, i probably need that sometime soon. also for deployment I'm all about NixOS all the time these days :P
13:25:03 <bitemyapp> thoughtpolice: you'll my ES library or Propellor?
13:25:07 <bitemyapp> you'll need*
13:25:08 <thoughtpolice> the ES library
13:25:22 <thoughtpolice> i was thinking of writing it myself a while back but didn't have the time
13:25:27 <bitemyapp> thoughtpolice: oh that'd be great! I'd love it if an expert Haskell user dug into it. I think I could use the feedback.
13:25:44 <merijn> aloiscochard: Yes, but building a local hoogle database of all of hackage broke, so in the end I reverted back to using hoogle + my browser
13:26:16 <merijn> aloiscochard: A lot of these tools (hoogle, hdevtools) could use a little love/polish to be a bit more robust, but I don't have the time for more yaks to shave :p
13:26:55 <kuribas> Can I use (a)jhc to make a C library from my haskell library?
13:28:24 <merijn> kuribas: Eh, why not use GHC?
13:29:04 <kuribas> merijn:  is it possible?
13:29:19 <aloiscochard> merijn: cool, I'm might thru all of that into a Lucene index ;-)
13:29:22 <kuribas> I read that jhc doesn't have a large runtime...
13:29:37 <gilligan_> Anyone here coming to ZuriHac in Zurich in June ?
13:29:41 <merijn> kuribas: Why wouldn't it be?
13:29:44 <aloiscochard> merijn: I'm really only starting serious stuff with haskell, so I have a bit of time to waste on such thing
13:29:51 <Zekka> merijn - Got someone's cabal sandbox hack to work with hdevtools, thanks
13:29:57 <aloiscochard> merijn: specially that I won't care later ... once I'll  be familiar with the APIs ;-)
13:30:14 <aloiscochard> gilligan_: I'll be there
13:30:59 <merijn> Zekka: Ooh, do you have a link?
13:31:03 <aloiscochard> gilligan_: awesome talks for a free events
13:31:07 <kuribas> merijn: because ghc requires a large runtime library?
13:31:12 <gilligan_> aloiscochard, indeed
13:31:22 <merijn> kuribas: That just means the resulting C library will be a bit bigger
13:31:25 <aloiscochard> gilligan_: are you from CH?
13:31:28 <Zekka> merijn: Fair warning, it's a massive hack
13:31:30 <Zekka> http://lpaste.net/94999
13:32:07 <merijn> Zekka: I'm used to awful hacks :)
13:32:16 <Zekka> merijn - Of course! You use hdevtools.
13:32:23 <kuribas> merijn: Would it be possible to generate the C files only so the library could be compiled without requiring GHC?
13:33:10 <gilligan_> aloiscochard, nope, Konstanz
13:33:30 <gilligan_> aloiscochard, so Zurich is just like 40min train ride for me
13:33:37 <gilligan_> aloiscochard, you?
13:33:42 <aloiscochard> gilligan_: well it's in CH mate ;-)
13:33:50 <aloiscochard> gilligan_: originally from Lausanne, but living in London atm
13:34:19 <gilligan_> aloiscochard, flying over just for zurihac then?
13:34:27 <aloiscochard> gilligan_: you might know Gerolf Seitz btw?
13:34:53 <Zekka> merijn - Out of curiosity, do you know why Syntastic now displays all warnings as errors?
13:35:09 <Zekka> I can't find where it determines whether an entry is a warning or an error, even though I know it did that at least for ghcmod
13:35:20 <aloiscochard> gilligan_: yes, I take the oppurtinty to go see the familiy/friends and before I go to that conf, perfect match!
13:36:13 <gilligan_> aloiscochard :-)
13:36:15 <Zekka> Wait, I think I found it
13:38:43 <kuribas> merijn: I like the idea of a small selfcontained library, though ghc is also an option, being the standard haskell compiler/
13:39:21 <merijn> kuribas: GHC doesn't generate C (well, maybe the deprecate C backend still exists)
13:39:47 <merijn> kuribas: Libraries don't have a language and when you use the FFI GHC will just create a binary with symbols that the linker will understand
13:39:53 * hackagebot group-with 0.2.0.0 - Classify objects by key-generating function, like SQL GROUP BY  http://hackage.haskell.org/package/group-with-0.2.0.0 (ulikoehler)
13:40:06 <merijn> Zekka: If you copied my config, I set it to do that, I think :)
13:40:18 <geekosaur> the old C backend still exists apparently, yes. but even so it requires a runtime
13:40:50 <geekosaur> (even C requires a runtime of sorts, it's built into crt0/crtn and libc typically)
13:41:20 <Zekka> merijn - It's possible you did but I don't see it
13:41:28 <identity> A bang on a tuple  forces the entire tuple, right?
13:41:28 <monochrom> you can use GHC to turn Haskell code into a *.so or *.DLL, if that helps your project
13:41:36 <merijn> Not even "of sorts", C requires a runtime, period (Unless you're not using hosted C but standalone C)
13:41:39 <MP2E> Is GHC going to remove the C backend at some point? And if so, wouldn't that make it more difficult to port GHC to new architectures? Or does the LLVM backend supercede that?
13:42:00 <merijn> MP2E: I think the C backend *only* exists in the interest of porting to new architectures
13:42:02 <Zekka> MP2E - As far as I'm aware recent versions of GHC already don't support unregistered compilation by default
13:42:09 <MP2E> Ah I see
13:42:15 <merijn> MP2E: It's been deprecated for 2 releases, I think
13:42:15 <MP2E> That makes sense
13:42:26 <thoughtpolice> the C backend is only for porting, yes. but in the future, cross compilation should hopefully subsume the need to port GHC via C
13:42:49 <thoughtpolice> also, porting GHC via C is insanely painful and ridiculous and I only accomplished it once like, 5 years ago. take that as you will.
13:42:58 <MP2E> Yikes :P
13:42:58 <merijn> MP2E: Native code gen and LLVM do better than the C backend on almost any benchmark, iirc
13:43:05 <thoughtpolice> (and i wasn't even porting to a very hard platform, just 64bit Mac)
13:43:17 <identity> > let !(a, b) = (3, undefined) in a
13:43:19 <lambdabot>  3
13:43:25 <MP2E> I don't doubt that it's *mucH* slower, I was curious about porting. Mostly because I'm considering buying an ARMv8 board when they come out
13:43:30 <identity> > let (!a, !b) = (3, undefined) in a
13:43:31 <MP2E> I'm sure at some point I'm going to miss haskell
13:43:32 <lambdabot>  *Exception: Prelude.undefined
13:43:34 <MP2E> and want to port ghc to it :P
13:43:36 <identity> ah, it does not.
13:43:42 <monochrom> yes, you need an inner ! for that
13:43:49 <thoughtpolice> MP2E: mmmm, an AArch64 port was WIP by someone. not sure what it's current status is.
13:43:59 <monochrom> the outer ! is just for the (,) itself
13:44:01 <merijn> MP2E: Well, ARM cross compilation is slowly improving
13:44:02 <thoughtpolice> (it was just using emulators which are intolerably slow, really)
13:44:15 <monochrom> isn't strictness exciting!
13:44:26 * thoughtpolice doesn't even know when AArch64 devchips will arive
13:44:28 <thoughtpolice> *arrive
13:44:45 <monochrom> the opposite, ~, is also similarly subtle about outer and inner
13:44:54 * hackagebot derive 2.5.15 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.15 (NeilMitchell)
13:45:20 <Wizek> Good morning!
13:45:23 <Wizek> @djinn a -> IO a
13:45:23 <lambdabot> Error: Undefined type IO
13:45:32 <Wizek> @hoogle a -> IO a
13:45:32 <monochrom> return
13:45:33 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
13:45:33 <lambdabot> Control.Exception evaluate :: a -> IO a
13:45:33 <lambdabot> Control.OldException evaluate :: a -> IO a
13:45:38 <monochrom> heh
13:46:02 <monochrom> what are you looking for? perhaps "return" is all you need
13:46:09 <Wizek> oh, return, I knew there was something obvius I was overlooking!
13:46:25 <monochrom> read my http://www.vex.net/~trebla/haskell/IO.xhtml !
13:46:54 <Wizek> monochrom: Thanks. I wonder wht hoogle doesn't know.
13:47:05 <identity> @src divMod
13:47:05 <lambdabot> Source not found. Are you typing with your feet?
13:47:09 <monochrom> let me see if a very general query finds it
13:47:14 <monochrom> @hoogle a -> ma
13:47:14 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:47:15 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:47:15 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
13:47:16 <monochrom> @hoogle a -> m a
13:47:17 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
13:47:17 <lambdabot> Prelude return :: Monad m => a -> m a
13:47:17 <lambdabot> Control.Monad return :: Monad m => a -> m a
13:47:26 <monochrom> yeah, IO is too specific for it
13:47:37 <merijn> Is there a way to pass flags to build tools used by cabal? i.e. pass a flag to c2hs?
13:47:54 <monochrom> the problem is that you never know how general you need. so don't blame yourself.
13:47:57 <merijn> Or should I hook the build process in Setup.hs for that?
13:48:25 <monochrom> I think there is
13:49:14 <monochrom> things like "--c2h2-options", generally "--PROG-options". type in "cabal install --help" and read the end
13:49:32 <merijn> monochrom: Well, I'd prefer to specify in the cabal file
13:49:39 <monochrom> oh, oops, then I forgot how
13:49:47 <fizbin> Okay, it took me way too long, but I rephrased my question about how to structure optimizing a structure by a series of optimization passes that may or may not work: http://lpaste.net/102696
13:49:54 * hackagebot rss2irc 1.0.6 - watches an RSS/Atom feed and writes it to an IRC channel  http://hackage.haskell.org/package/rss2irc-1.0.6 (SimonMichael)
13:50:25 <fizbin> I'd say "rephrased in terms of working code", but I don't actually know that. It compiles, though.
13:51:10 <aloiscochard> does hackagebot send update of himself??
13:51:14 <aloiscochard> he reached singularity
13:51:25 <sm> ha
13:51:29 <fizbin> So my basic question is: what type should I have made optConstExpr in http://lpaste.net/102696 ? Right now, the type it is makes it painful to work with.
13:52:01 <monochrom> probably doesn't have c2hs-options, but it has everything else: ghc-options, hugs-options, ld-options...
13:52:17 <hakujin> I want to understand GHC's evaluation semantics for a HashMap (I'll be using unordered-containers). I want to define the HashMap once (using fromList?) and have a function be able to query it without rebuilding the HashMap. Do I make it a top level function? e.g. hm :: HashMap Text Text, and have other functions reference this?
13:52:21 <geekosaur> it does, actually
13:52:28 <monochrom> oh, good to hear
13:52:53 <hakujin> or if I include the HashMap fromList inside the querying function will GHC know not to rebuild it? when does this thing get GC'ed?
13:53:16 <monochrom> yeah, probably just a user-guide omission. it would be strange to support command line --c2hs-options and forgot to support in *.cabal
13:54:06 <merijn> monochrom: No alex/happy/etc options either
13:54:32 <monochrom> hakujin: top-level is the surest way to make it a shared singleton. there are other ways, if needed.
13:54:34 <merijn> monochrom: I have a year old open issue on github that says those options indeed don't exist
13:54:45 <hakujin> monochrom: thanks
13:54:48 <merijn> Bollocks
13:54:56 <merijn> Another layer of yak's to shave
13:55:20 <sm> when you stack them up too high the yaks get ornery
13:55:35 <Wizek> Can a do block have an associated where clause? I'm using HSpec and I have quite a few `do`-s nested
13:55:57 <monochrom> no, cannot, a do-block is just an expression. "where" is not attached to an expression.
13:56:17 <Wizek> I guess  I'll need to use let-in then
13:56:30 <monochrom> instead, in "xxx = do { ... } where y=0", that is attached to "xxx =", not to the "do".
13:56:43 <geekosaur> or attach the where to an outer binding
13:56:49 <hakujin> Wizek: could always use the built in sugar for let within a do as well
13:57:27 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml#do :)
13:59:56 * hackagebot hlint 1.8.61 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.61 (NeilMitchell)
14:02:59 <monochrom> "whimsical"! that is the word I was looking for, in place of "magical" which is not whimsical enough :)
14:05:21 <monochrom> "If your program appears to postpone an I/O action, there is always a less magical explanation than “lazy”". s/magical/whimsical/ works better there :)
14:06:10 <S3thc0n> Is there a 'reverse' map function in Prelude which allows me to apply a list of functions to a single value or should I roll my own?
14:06:26 <merijn> S3thc0n: Yes, map and ($) :p
14:06:32 <merijn> :t map ($3)
14:06:32 <monochrom> consider: map ($ pi) [sin, cos, tan]
14:06:33 <lambdabot> Num a => [a -> b] -> [b]
14:07:07 <monochrom> details: map ($ pi) [sin, cos, tan] = [sin $ pi, cos $ pi, tan $ pi] = [sin pi, cos pi, tan pi]
14:07:14 <merijn> S3thc0n: Which is essentially "map (\f -> f 3)"
14:07:17 <corgifex> S3thc0n: sequence
14:07:30 <letrec> What does ~ mean in a team constraint? Like:  EnvType (t m) ~ (Action a b1 c -> m b)
14:07:39 <merijn> letrec: "unifies with"
14:07:40 <shachaf> Equality.
14:07:58 <merijn> letrec: Which is (approximately) type equality
14:08:00 <S3thc0n> Sounds logical. Sorry for not seeing that.^^
14:08:25 <corgifex> always remember haskell's motto: there's more than one way to do it
14:08:38 <monochrom> hi shachaf have you seen my finally-finished monad tutorial? :)
14:08:52 <corgifex> > sequence [sin, cos, tan] pi
14:08:54 <lambdabot>  [1.2246467991473532e-16,-1.0,-1.2246467991473532e-16]
14:09:02 <corgifex> > sequence [sin, cos, tan] pi :: [Expr]
14:09:04 <lambdabot>  [sin pi,cos pi,sin pi / cos pi]
14:09:32 <S3thc0n> corgifex: Thanks, that's what I looked for :)
14:09:33 <shachaf> monochrom: I have not.
14:09:53 <shachaf> I,I finally-finished, partially-evaluated
14:09:55 <monochrom> it's the world's shortest monad tutorial! http://www.vex.net/~trebla/haskell/Monad.xhtml
14:09:57 * hackagebot clash-prelude 0.5 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.5 (ChristiaanBaaij)
14:09:59 * hackagebot ghc-events-parallel 0.5.0.0 - Library and tool for parsing .eventlog files from parallel GHC  http://hackage.haskell.org/package/ghc-events-parallel-0.5.0.0 (JostBerthold)
14:10:03 <letrec> merijn: thanks. Any pointer to a doc on that? Couldn't find any.
14:10:20 <fizbin> Do the monad laws imply that (>=>) is associative?
14:10:24 <shachaf> monochrom: Can I have a list tutorial too?
14:10:26 <shachaf> fizbin: Yes.
14:10:29 <monochrom> haha
14:10:30 <fizbin> @type foldr (>=>) return
14:10:31 <lambdabot> Monad m => [c -> m c] -> c -> m c
14:10:44 <ReinH> I have a Text containing escaped UTF8 characters. e.g. literal "\333" instead of "ō". Is there a simple way to convert "\\333" to "ō"?
14:11:18 <corgifex> ReinH: what are the semantics of \999999999999999999999999999999?
14:11:28 <monochrom> hahaha
14:12:02 <corgifex> wait. "UTF8 characters"? what the heck
14:12:12 <shachaf> > read "\"\\333\"" :: String
14:12:14 <lambdabot>  "\333"
14:12:36 <ReinH> unicode character encoded as utf8 if you prefer
14:12:49 <corgifex> where does utf8 come in?
14:12:53 <merijn> letrec: I think the docs on it are fairly minimal. Some simple examples should perhaps clarify "Int ~ Int" holds, "Int ~ Float" doesn't hold, "Maybe a ~ Maybe Int" holds iff "a ~ Int"
14:12:58 <corgifex> I thought this was a text->text transformation
14:13:07 <ReinH> corgifex: I'm not sure what you're asking.
14:13:22 <ReinH> Instead of "\333", a utf8-encoded ō, I have "\\333"
14:13:32 <merijn> ReinH: Well, there's no such thing as UTF8 characters, for one
14:13:33 <corgifex> how is "\333" utf8-encoded?
14:13:44 <merijn> corgifex++
14:13:56 <merijn> \333 is a unicode codepoint, presumably
14:14:01 <merijn> > '\333'
14:14:02 <lambdabot>  '\333'
14:14:05 <corgifex> yes
14:14:13 <ReinH> U+014D is a unicode codepoint.
14:14:15 <corgifex> U+014D (c5 8d): LATIN SMALL LETTER O WITH MACRON [ō]
14:14:15 <monochrom> ReinH, please forgive me for not believing you. could you report the answer to this? map fromEnum (unpack your_text)
14:14:23 <ekun_> >
14:14:25 <corgifex> ReinH: 0x14d == 333
14:14:27 <joneshf> can you parameterize a typeclass on a function?
14:14:39 <corgifex> the UTF-8 representation is C5 8D
14:14:45 <merijn> joneshf: Depends what you mean
14:14:56 <ReinH> corgifex: good point. My question was poorly phrased.
14:14:58 * hackagebot clash-lib 0.3 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.3 (ChristiaanBaaij)
14:15:00 * hackagebot edentv 4.4.0 - A Tool to Visualize Parallel Functional Program Executions  http://hackage.haskell.org/package/edentv-4.4.0 (JostBerthold)
14:15:26 <corgifex> phew, so I wasn't completely misunderstanding
14:15:28 <letrec> merijn: Ok. Can I think about it as a partial unification of the two types?
14:15:30 <merijn> joneshf: Although, for all sensible interpretations of your question: No
14:15:44 <corgifex> corgifex: still, what do you want to happen if the input string is \999999999999999999?
14:15:46 <corgifex> wtf
14:15:49 <corgifex> ReinH: ^
14:15:57 <merijn> letrec: ~ *is* unification :) a ~ constraint holds IFF both sides unify
14:16:04 <joneshf> merijn, let's look at Monoid, can we somehow use the type system to actually differntiate between two Monoids for the same type?
14:16:15 <merijn> joneshf: Nope
14:16:19 <ReinH> corgifex: That's another good point. What I actually need to do is intercept the bytestring before it gets converted to Text and decode the characters manually.
14:16:32 <merijn> joneshf: Hence why we have a Sum and Product newtype for the Sum and Product monoids :)
14:16:41 <joneshf> that seems like we've failed as a community
14:16:50 <shachaf> corgifex: An error?
14:16:50 <merijn> joneshf: How so?
14:16:56 <ReinH> corgifex: They are actually encoded as "\uXXXX" where XXXX is the unicode codepoint. Because for whatever reason this API endpoint returns ASCII with manually encoded unicode characters.
14:17:01 <joneshf> merijn, i assumed that was just an artifact of it being old
14:17:05 <ReinH> well, "\\uXXXX"
14:17:09 <ReinH> corgifex: this API is idiotic :/
14:17:25 <joneshf> merijn, because we've got to use these workarounds like newtypes in order to halfway get there
14:17:26 <corgifex> sounds JSONy
14:17:41 <merijn> joneshf: No, it's unclear how to overload typeclasses (like Monoid) for a single type in a theoretically sound way
14:17:47 <corgifex> ReinH: what does it do with characters outside the BMP?
14:17:51 <monochrom> does aeson do that for you already?
14:18:01 <ReinH> corgifex: it is.
14:18:14 <monochrom> outside the BMP may be \uXXXXXXXXXXXXXX
14:18:17 <merijn> joneshf: I would say that having a solution to this problem would be quite an outstanding paper in type theory/functional programming
14:18:26 <letrec> merijn: Yes but when two types are unified.. they become one single type :) And here they are two. Anyway, I think I get it. Thanks for your help!
14:18:28 <shachaf> monochrom: That's a lot of Xs.
14:18:29 <joneshf> merijn, bear in mind most of this is conjecture in my heac
14:18:36 <monochrom> I'm exaggerating :)
14:18:37 <corgifex> ReinH: then you have to interpret other escape sequences too
14:18:49 <joneshf> merijn, but cant we tell the typeclass which function to use for <>
14:19:00 <merijn> joneshf: How?
14:19:07 <joneshf> and what identity to use for mempty
14:19:10 <ReinH> monochrom: I thought so but I'm seeing literal "\\333" instead of "\333"
14:19:18 <joneshf> merijn, when defining the typeclass
14:19:20 <merijn> joneshf: Yes, but then you wouldn't have a typeclass
14:19:25 <monochrom> I see
14:19:28 <ReinH> (irt aeson's handling of JSON encoded unicode)
14:19:29 <joneshf> merijn, what would we have?
14:19:34 <merijn> joneshf: You'd have a record type with functions in it :)
14:19:54 <joneshf> merijn, is that a bad thing?
14:19:58 * hackagebot clash-ghc 0.3 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.3 (ChristiaanBaaij)
14:20:29 <merijn> joneshf: "data MonoidRecord a = MonoidRec { mempty :: a, mappend :: a -> a -> a }", "(<>) :: MonoidRecord a -> a -> a -> a"
14:20:46 <merijn> joneshf: No, but the reason typeclasses were created is to do this record passing automatically
14:21:00 <merijn> joneshf: In fact, with this solution you don't even need typeclasses at all anymore
14:21:28 <corgifex> did somebody say http://hackage.haskell.org/package/reflection-1.4/docs/Data-Reflection.html ?
14:21:51 <merijn> joneshf: So, yes, you can solve it by replacing typeclasses with records. But typeclasses were invented to avoid manually having to do that everywhere :)
14:22:04 <joneshf> hmm,
14:22:28 <joneshf> merijn, then maybe a combination of the two is what it'll take to make things more expressive
14:22:32 <prophile> I seem to remember some kind of mechanism for explicitly passing a dictionary
14:22:40 <prophile> though I can't remember if that's haskell or idris
14:22:53 <joneshf> we clearly cant rely entirely on the compiler to sort things out for us
14:23:06 <joneshf> but that doesnt mean we have to give up all hope, right?
14:23:34 <merijn> joneshf: Well, you could just do exactly what I wrote
14:23:37 <joneshf> s/sort things/sort everything/
14:23:57 <merijn> prophile: Maybe ImplicitParameters?
14:24:10 <prophile> no, I'm certain it involved typeclass instances
14:24:14 <merijn> > let ?y = (+1) in ?y 2
14:24:15 <lambdabot>  3
14:24:25 <merijn> :t ?y
14:24:26 <lambdabot> (?y::t) => t
14:24:27 <prophile> though as I say I'm not certain it wasn't an idris feature rather than a haskell feature
14:24:38 <merijn> :t ?y :: Int -> Bool
14:24:39 <lambdabot> (?y::Int -> Bool) => Int -> Bool
14:24:41 <prophile> though it'd be mighty convenient in Haskell
14:24:56 <corgifex> see that Data.Reflection link for something similar
14:25:22 <joneshf> merijn, prophile corgifex thanks
14:26:34 <k00mi> agda's instance arguments are somewhere between typeclasses and manual dictionary passing
14:30:20 <ReinH> Huh.
14:30:42 <ReinH> monochrom: So here's a reproduction of my issue:
14:31:01 <ReinH> decode "[\"foo\\u014d\"]" :: Maybe [Text] --> Just ["foo\333"]
14:31:12 <[swift]> is there a way to access unexported functions with GHCi?
14:31:31 <ReinH> Should be Just ["fooō"] unless Aeson is no longer Doing The Right Thing for encoded unicode codepoints
14:31:48 <corgifex> ReinH: is that output from print/show?
14:32:01 <corgifex> because show re-encodes as \333
14:32:47 <corgifex> > let x = "\333" in (x, length x)
14:32:48 <lambdabot>  ("\333",1)
14:33:18 <marsam> \q lambdabot
14:33:34 <armlesshobo> is there a UTF8 type?
14:33:35 <geekosaur> [swift], if it's interpreted then it can access them, if not then not
14:33:54 <geekosaur> armlesshobo, that's kinda not entirely meaningful?
14:34:11 <[swift]> geekosaur: do i have control over that?
14:34:13 * armlesshobo shrugs
14:34:16 <geekosaur> Char and Text handle Unicode codepoints, and attempt to translate UTF8 on input/output
14:34:21 <armlesshobo> I see
14:34:27 <armlesshobo> then it's unnecessary
14:34:37 <geekosaur> [swift], in ghci if you preced a module/file name with * it should force interpretation
14:34:54 <geekosaur> not sure if that works with import though
14:35:00 * hackagebot happstack-server 7.3.5 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.3.5 (JeremyShaw)
14:35:02 <ReinH> corgifex: I'm trying to figure that out right now, in fact.
14:35:21 <ReinH> corgifex: I'm pretty sure I'm going to feel like an idiot in about 30 seconds
14:35:43 <[swift]> geekosaur: hmm, so actually i just ran ":show modules" and it lists the module in question as interpreted. i'm puzzled
14:36:04 <geekosaur> interesting
14:36:14 <geekosaur> maybe you need to :load it for that to work, then
14:36:22 <merijn> monochrom: Not only is a c2hs-options field missing from cabal file parsing, but as far as I can tell it's been designed to make it a major pain to add >.>
14:36:37 <mietek> Any idea how to redirect a command's output to /dev/null using HSH?
14:36:39 <merijn> monochrom: Apparently it's simpler to overwrite it in Setup.hs using UserHooks
14:36:44 <[swift]> geekosaur: yeah, :load indeed worked
14:36:46 <Galactic_> hey, guys...how could I take something like   [[1],[1,1],[1,2,1],[1,3,3,1]]  and print it having each list on a line with spaces between numbers? like:
14:36:47 <Galactic_> 1   1 1   1 2 1   1 3 3 1
14:36:52 <Athas> Can anyone point at a project that integrates the test-framework package with the cabal test-running functionality?
14:36:54 <[swift]> geekosaur: using m +foo didn't
14:36:56 <Athas> I just want too se the best way to do it.
14:36:59 <[swift]> geekosaur: that must be the difference
14:37:18 <corgifex> putStr . unlines . map (unwords . map show)
14:37:24 <monochrom> yikes, merijn
14:37:57 <mietek> Shell scripting in Haskell is a bit of a pain.  Shelly has a nice variadic interface, but doesn't actually seem to work properly.  HSH doesn't expose all functions.  I haven't tried HsShellScript yet, but I think I need to...
14:38:15 <corgifex> Galactic_: that was for you, btw
14:38:50 <Galactic_> corgifex: Thanks, I am testing it.
14:39:05 <ReinH> corgifex: confirm I am an idiot.
14:39:14 <corgifex> ReinH: yay!
14:39:16 <ReinH> corgifex: yay!
14:39:25 <corgifex> there's an mst quote that applies here
14:39:29 <ReinH> corgifex: that's way better than Aeson being broken :)
14:39:34 <ReinH> (and way less surprising)
14:40:00 * hackagebot hoogle 4.2.32 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.32 (NeilMitchell)
14:40:06 <clahey> I know this is somewhat off topic, but can you guys remind me of the name for a computation that can be called multiple times without changing the result?
14:40:14 <clahey> I.e., calling it once is the same as calling it multiple times?
14:40:18 <corgifex> idempotent
14:40:19 <identity> clahey: idempotence?
14:40:19 <geekosaur> idempotent
14:40:22 <clahey> Thank you!
14:40:33 <corgifex> what a nice set of idempotent answers
14:40:36 <merijn> monochrom: Basically all the parameters are specified in Cabal which is only indirectly accessed by cabal-install via the default hooks, so you'd need to parameterise the defaultBuildHook and everything between it and the program specification, gratuitously breaking *everyone's* custom Setup.hs build hooks >.>
14:41:06 <clahey> corgifex, Except I only asked once and it was answered multiple times.  Kinda the opposite of idempotence.
14:41:08 <Galactic_> wow thanks a lot corgifex that works.
14:41:31 <ReinH> corgifex: I broke my own rule! https://twitter.com/ReinH/status/243771861576589312 :(
14:41:53 <corgifex> clahey: but all answers had the same effect, i.e. getting one answer had the same result as getting all three
14:41:56 <merijn> monochrom: Now I understand why everyone uses "-U__BLOCKS__" to disable blocks via CPP rather than passing the "-b" flag to c2hs >.>
14:42:07 <clahey> corgifex, Fair enough.
14:42:39 <merijn> This design makes me very sad :(
14:42:48 <jle`> i wonder if there is a #haskell quine
14:42:56 <jle`> a question where the answer is the same text as the question itself
14:43:06 <ReinH> clahey: a unary function f is idempotent if f . f = f
14:43:14 <ReinH> jle`: I think I've seen one
14:43:39 <ReinH> clahey: a binary function g is idempotent if g x x = x
14:43:39 <corgifex> "what question can be answered by itself?"
14:43:44 <ReinH> clahey: those are the usual definitions, at least
14:43:57 <jle`> corgifex: the class of questions that are answered by themselves
14:44:03 <jle`> :)
14:44:30 <corgifex> jle`: "what?"
14:44:40 <jle`> hm
14:44:46 <jle`> i don't know anyhting anymore
14:44:54 <clahey> ReinH, My function isn't in haskell, so it's actually of type SuccessHandler -> FailureHandler -> IO Void, but that's neither here nor there.
14:45:14 <clahey> ReinH: So it's not idempotent by that definition.
14:45:41 <corgifex> HTTP PUT requests are idempotent
14:45:51 <ReinH> clahey: "idempotent" is also used morally for things that don't change their environment if run multiple times
14:45:55 <ReinH> like PUT
14:46:08 <clahey> Right.
14:46:09 <ReinH> and puppet configurations
14:46:11 <clahey> It's exactly that.
14:46:17 <clahey> It's more like GET though. :)
14:46:32 <merijn> ReinH: PUT is not typically idempotent
14:46:36 <merijn> GET is, though
14:46:44 <corgifex> GET is effectless
14:46:48 <ReinH> merijn: PUT is supposed to be.
14:46:50 <corgifex> (ostensibly)
14:46:56 <clahey> merijn, How is PUT not idempotent?
14:47:16 <merijn> clahey: Frequently PUT is a form submission that changes server state
14:47:16 <ReinH> merijn: GET, HEAD, PUT, DELETE are idempotent http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
14:47:27 <corgifex> merijn: I've never seen a form submit via PUT
14:47:40 <clahey> merijn, Yes, idempotent doesn't mean it doesn't change state.
14:47:47 <merijn> corgifex: How did you see them submit, then?
14:47:50 <corgifex> POST
14:47:50 <clahey> merijn, It just means that calling it twice is no different from calling it once.
14:47:52 <corgifex> or GET
14:47:57 <ReinH> merijn: using the definitions in that RFC, at least
14:48:04 <merijn> corgifex: Oh, maybe I'm confusing them with POST
14:48:22 <ReinH> Which is "Methods can also have the property of "idempotence" in that (aside from error or expiration issues) the side-effects of N > 0 identical requests is the same as for a single request."
14:48:37 <ReinH> ... modulo effects we don't care about like logging ;)
14:48:45 <ReinH> for some value of "side-effects"
14:49:52 <clahey> ReinH, Oh, also aside from ordering with other requests.
14:49:58 <clahey> ReinH, Or is that what expiration means?
14:51:41 <monochrom> ReinH: http://lpaste.net/102697
14:52:00 <merijn> dcoutts: In Distribution.Client.Init.Heuristics knownSuffixHandlers has the following comment "-- Unfortunately we cannot use the version exported by Distribution.Simple.Program", I'm unsure what this comment means? Why can't that version be used?
14:53:24 <dcoutts> merijn: presumably it means Distribution.Simple.PreProcess
14:54:13 <merijn> dcoutts: Oh, I didn't notice the module was wrong. I was more curious about why it can't use the one defined in Cabal (regardless of which module)
14:55:02 * hackagebot muon 0.1.0.3 - Static blog generator  http://hackage.haskell.org/package/muon-0.1.0.3 (kaashif)
14:55:38 <dcoutts> merijn: because what that module needs is the name of the pre-processor, and Distribution.Simple.PreProcess does not provide it
14:55:52 <dcoutts> it provides a function to run the pre-processor
14:56:13 <merijn> dcoutts: Right, that's what I figured but I was a bit confused by the comment whether there was some other obscure reason that didn't work
14:56:41 <dcoutts> merijn: not that I know of
14:56:57 <merijn> ok, then I'll see if I can hack my fix in tomorrow :)
14:57:07 <dcoutts> merijn: note that not all suffix handlers will correspond to an external pre-processor build tool
14:57:58 <dcoutts> e.g. unlit has no external tool
14:58:58 <merijn> dcoutts: Right, but that's not very important to me. I wanted to see if I could add "c2hs-options", "alex-options", etc. to the cabal file parser so it becomes possible to specify those without having to write your own Setup.hs and hooking the relevant tools yourself
14:59:11 <dcoutts> merijn: they're not there by design
14:59:18 <merijn> dcoutts: Why?
14:59:39 <dcoutts> merijn: because package authors (as opposed to package builders) should not need to set them
14:59:54 <dcoutts> that's particularly the case for haddock
15:00:29 <merijn> dcoutts: I disagree, c2hs has the options to disable OSX' blocks (else it dies on "syntax error" during preprocessing on OSX)
15:01:03 <merijn> dcoutts: Similarly, johnw's c2hsc (although that's not currently supported by cabal) has options that need to be specified by package authors too
15:01:24 <dcoutts> merijn: if it's something the author needs to specify (as opposed to the build system) then it should be specified inside the file
15:02:12 <merijn> Right now I would need write a custom Setup.hs and manually write a user hook for c2hs, just to make it add "-b" to the c2hs call
15:02:41 <merijn> Alternatively, I would have to patch c2hs to parse haskell files for options and add that options to every single chs file
15:02:41 <Galactic_> what is the difference between: map (unwords . map show) $ [[1],[1,1],[1,2,1]]     and    map unwords ["[1]","[1,1]","[1,2,1]"]?  map show [[1],[1,1],[1,2,1]]   returns ["[1]","[1,1]","[1,2,1]"]  so why map unwords ["[1]","[1,1]","[1,2,1]"] does not work?
15:03:01 <dcoutts> c2hs is a good example, it has a syntax for directives already
15:03:06 <dcoutts> as does alex, happy
15:04:08 <merijn> dcoutts: Which directives for c2hs? I don't see them in the documentation?
15:04:10 <corgifex> Galactic_: why are you calling map show on the list?
15:04:25 <merijn> dcoutts: Additionally, how do I enable such a directive only on some OS?
15:04:31 <corgifex> Galactic_: map (unwords . map show) == map unwords . map (map show)
15:05:03 <Galactic_> corgifex: just trying to understand the solution that you gave me.
15:05:24 <monochrom> Galactic_, you are asking the equivalent of "what is the difference between f (g x) and f x". the difference is, therefore, omitting g.
15:06:35 <dcoutts> merijn: gah, can't find the user manual now, the old site is just redirecting
15:06:51 <dcoutts> merijn: so this -b flag, should it always be set on OSX or what?
15:06:59 <dcoutts> when/why should it be set?
15:07:15 <merijn> dcoutts: It should *probably* always be set
15:07:20 <merijn> But I'm not 100% sure
15:07:37 <merijn> dcoutts: User guide is now at https://github.com/haskell/c2hs/wiki/User-Guide
15:08:03 <Galactic_> corgifex: I see so there are 3 map.
15:08:28 <merijn> dcoutts: Some Apple headers have code using their "code blocks" extension, which (at least in my case) causes the CPP to choke on the generated files
15:08:36 <dcoutts> merijn: so it looks like those two new command line flags are a mistake
15:08:51 <dcoutts> merijn: they should be in-file directives (or just system defaults)
15:08:54 <merijn> dcoutts: Probably those should always be turned on, but I'm not sure
15:09:10 <cschneid> Are there any other good books aimed at new haskell programmers other than RWH, LYAH?
15:09:22 <dcoutts> merijn: note how none of the other flags need to be set by the author, just by the build system
15:09:43 <dcoutts> merijn: people sometimes make these mistakes, e.g. recently in happy, but since fixed (to be an in-file directive)
15:09:51 <Earnestly> cschneid: Craft of Functional Programming
15:10:16 <merijn> dcoutts: I could live with an in-file directive (since I have only one relevant file, I think?) but I didn't see how to do that
15:10:34 <dcoutts> merijn: I'm not claiming one exists, just that it should if the author needs to specify it.
15:10:57 <dcoutts> merijn: and noting that c2hs does already have syntax for such things (though perhaps not these ones)
15:11:17 <cschneid> Earnestly: cool, hadn't seen that one.  Mostly I'm looking for a way forward for a friend who's an experienced programmer, and has worked his way through LYAH / RWH. It's a pretty big hurdle to go from knowlegable beginner => proficient in actually solving problems quickly
15:11:18 <dcoutts> merijn: and so the right place to fix it is in the tool itself, not in cabal
15:11:48 <dcoutts> merijn: we don't want a general "any old flags for any old tools" system in the .cabal file
15:12:02 <Earnestly> cschneid: Right, if he's done both of them, then the rest is basically up to him
15:12:03 <pjdelport> cschneid: What kind of problems do they want to solve?
15:12:17 <dcoutts> merijn: that becomes rather brittle. It sort-of works for ghc because we heavily restrict what flags you can specify
15:12:37 <cschneid> pjdelport: well, I lied, he's big into rust and asks questions where rust has a specific solution, and I say "ohh, that's just fmap", and that leads to a longer discussion about how unobviously named lots of the haskell abstractions are
15:13:04 <pjdelport> cschneid: Everythings unfamiliar until you become familiar with them. :)
15:13:27 <cschneid> Earnestly / pjdelport: I was thinking of writing a list of "Common task" -> "Copy/pastable solution" -> "Explaination of how it works".
15:13:31 <merijn> dcoutts: I'll see what I can do with c2hs tomorrow, bed time now
15:13:36 <pjdelport> Rather than have long discussions about it, just become familiar with them.
15:14:11 <dcoutts> merijn: and because it's simply a better approach to put these things in the files themselves. Sometimes it makes sense to put things in the .cabal file, but they generally have to be semantic things (like header files, deps on system libs) not just random flags
15:14:28 <pjdelport> cschneid: http://rosettacode.org/wiki/Category:Haskell ?
15:15:08 <pjdelport> cschneid: It's really hard to give any generic advice; once you know the basics of the language, the next step is simply to go out and do stuff.
15:15:11 <cschneid> pjdelport: heh, of course stuff becomes more familiar, but I like the idea of having real examples that we run into as day-to-day programmers. Which then push the reader toward the underlying abstraction to solve it.
15:15:28 <cschneid> pjdelport: of course. Thanks to you and Earnestly for the few links to books & such
15:16:13 <pjdelport> cschneid: You don't always need to do things in the "best" way; Haskell has many ways of accomplishing things. A lot of the time, it's fine to do stuff just using the tools you like and are familiar with.
15:17:11 <pjdelport> cschneid: So it's easiest to just go ahead, and ask questions if you run into a block.
15:17:23 <cschneid> pjdelport: which is how I learned. This channel has been great.
15:19:19 <cschneid> pjdelport: I just know that I cargo cult answers to solve a problem I'm actually running into (stack overflow & similar), then loop back and learn. That cargo-culted code is a useful step in learning :)
15:19:36 <cschneid> anyway, thanks for the resources - looking at stuff now
15:19:38 <cschneid> gonna order that book
15:23:40 <dcoutts> merijn: https://github.com/haskell/c2hs/issues/77
15:27:14 <Maior> so I _think_ I can use `foldM` to turn my `[Maybe a]` into a `Maybe [a]` (that's Nothing if any member is Nothing, and Just[a] if all the members are Just a), but I suspect there's an easier way I've missed?
15:27:38 <Maior> sequence perhaps?
15:28:01 <shachaf> sequence is the answer.
15:28:13 <shachaf> Or Control.Applicative.sequenceA (does the same thing).
15:28:44 <shachaf> Instead of "Just [a]" you should say "Just (xs :: [a])" or something like that, otherwise it's confusing.
15:29:18 <Maior> why?
15:30:00 <jakex_> :t sequence :: [Maybe a] -> Maybe [a]
15:30:01 <lambdabot> [Maybe a] -> Maybe [a]
15:31:13 <shachaf> Because [a] is a type (which looks like a value) and Just takes a value.
15:31:53 <Athas> I wish the cabal build-depends field permitted a trailing comma.
15:32:07 <srhb> Athas: Stick the commas in front instead.
15:32:35 <dcoutts> Athas: it's one of the things I want to liberalise in my new parser, still stuck on using parsec as a dependency however :-(
15:32:48 <Athas> srhb: then I ould wish that it permitted a leading comma.
15:33:00 <srhb> Athas: Well, you can always have base there. :P
15:33:04 <Athas> Well, I suppose that it's unlikely I take out the base dep...
15:33:21 <srhb> That's what I do at least. Preserves my sanity.
15:33:42 * dcoutts has a number of other minor .cabal parser annoyances he wants to fix
15:33:47 <kuribas> Isn't there a recompile-all option for cabal, when I change something in .cabal/config?
15:33:48 <dcoutts> all depends on the new parser though
15:34:08 <srhb> dcoutts: What are you changing about the parser?
15:34:21 <dcoutts> srhb: mainly rewriting it from scratch to be sane
15:34:24 <srhb> dcoutts: Ah.
15:35:06 <dcoutts> srhb: in terms of surface syntax, not that much. Better error messages. Fixing a few weird corners. Much faster.
15:35:19 <rasfar> Athas: I sympathise; basically every context of comma should permit extra leading and trailing commas!
15:35:22 <srhb> dcoutts: Why the sadness about Parsec?
15:35:27 <dcoutts> srhb: giving it an actual grammar :-)
15:35:29 <srhb> rasfar: Agreed.
15:35:34 <srhb> dcoutts: Heh.
15:36:00 <dcoutts> srhb: making ghc depend on even more libs would cause problems. I wanted to add parsec but it pulls in so many more things as core libs.
15:36:35 <srhb> True. Though one could argue that there really ought to be a combinator parser somewhere in there anyway. Oh well.
15:36:46 <Athas> dcoutts: can't you just use happy/alex?
15:36:55 <dcoutts> Athas: using alex actually
15:36:58 <Athas> I mean, they suck in their ways, but they are already GHC dependencies, aren't they?
15:37:05 <srhb> They are.
15:37:09 <srhb> Well, bootstrappable
15:37:13 <srhb> (I think)
15:37:14 <dcoutts> srhb: there's an idea to rearrange the deps so that only ghc-pkg depends on Cabal, not ghc proper. Then we could use parsec (as parsec would only be needed to build it, not need to be installed)
15:37:27 <srhb> dcoutts: That sounds like a good solution.
15:37:54 <dcoutts> srhb: parsec is a platforms lib of course, but one does want to minimse the number of things that the ghc lib depends on because those become effectively non-upgradeable
15:38:28 <srhb> If only different versions could coexist more peacefully.
15:38:38 <dcoutts> Athas: and they're nice because they don't add runtime deps. Sadly I couldn't construct a grammar for what I needed using happy.
15:39:01 <dcoutts> Athas: also, happy doesn't really do error messages, and that was one of the big motivations.
15:39:11 <Athas> By the way, can someone explain why I need to add non-public modules to the Other-Modules field of my .cabal file?
15:39:15 <dcoutts> happy just gives you a source location
15:39:17 <Athas> Why does it matter whether I list them or not?
15:39:24 <dcoutts> which is why ghc's parse error messages are so bad
15:39:47 <dcoutts> Athas: in general, the build systems needs to know all the modules in a component.
15:39:58 <Athas> dcoutts: actually, happy doesn't even give you that, you have to stuff it into your lexemes.  And you could put source context there, if you wanted to!
15:40:22 <dcoutts> Athas: scr loc yes, but not location/context in the grammar
15:40:28 <Athas> dcoutts: for an executable, I only have to list the location of Main, don't I?
15:40:43 <Athas> That's true.  I've struggled quite a bit with happy as well.
15:41:08 <dcoutts> Athas: exes you can sometimes get away with it. But if you have any pre-processors then it's necessary, and if you want to make a src dist then it's necessary.
15:41:19 <srhb> Can we make a parsec-exec that pulls in ghc-lib and works as a standalone? :)
15:41:34 <Athas> Yes, I accept the need when you have a preprocessor.  What is a source distribution in the cabal sense, though?
15:41:42 <Athas> Isn't that just a tarball of my source repository?
15:41:42 <dcoutts> Athas: the rule is that you should always list them all, it's just that Cabal doesn't enforce/check it.
15:42:25 <Athas> Then I will be lazy for now.  I have 70 modules, and there's no chance I'll remember to maintain the list anyway.
15:42:26 <dcoutts> Athas: cabal sdist. You don't have to use it, but it does include just the right bits.
15:42:59 <dcoutts> Athas: one day Cabal will enforce it, but it'll also help/remind you when it can.
15:43:08 <Athas> Sure, and that'll be fine.
15:43:17 <Athas> If I ever set up our CI suite to check it for me, that'll also be fine.
15:43:28 <Athas> But I'm bad at following rules if the machine doesn't yell at me when I break them.
15:43:33 <dcoutts> aye
15:44:06 <Athas> It would be nice if I could use a pattern to describe the modules, though.
15:44:15 <Athas> Like, "every .hs file in this tree is a module".
15:45:30 <dmwit> I think that's one of the things they explicitly have chosen not to do.
15:45:31 <aloiscochard> indeed, maintaining that list feel like pure boilerplate
15:47:52 <aloiscochard> it looks like one can use cabal as lib, does anybody know any tool who do that?
15:48:25 <dcoutts> aloiscochard: lots do, e.g. the tools that convert cabal packages to native/distro package formats
15:48:40 <geekosaur> the biggest consumer is probably ghc itself though
15:48:42 <dcoutts> aloiscochard: cabal-install does of course, as does the hackage-server
15:48:52 <dcoutts> geekosaur: actually it only uses it a tiny bit
15:49:56 <aloiscochard> dcoutts: I know it's a noob question but I promise I tried with google: I heard about a way to do kind of reverse lookup in hackage? like I could search all pack with dep to cabal?
15:50:40 <dcoutts> aloiscochard: there's http://packdeps.haskellers.com/reverse
15:50:53 <dcoutts> and someday we'll fix the impl of reverse deps on the main hackage site
15:51:18 <aloiscochard> dcoutts: ty!
15:52:04 <rasfar> cabal init generates your dep list for you, based on import statements in all modules it finds under the current directory (barring extra directives). And exposed modules are just those with Haddock pages, right? Why can't cabal give messages when the lists of modules in the .cabal file are not consistent with that?
15:52:57 <rasfar> (this is not a complaint, just a question)
15:52:58 <copumpkin> ohai dcoutts :) :) :) :)
15:53:03 <Noldorin> why are the arguments of (>>=) the other way round compared to (<*>) and fmap? it doesn't help consistency for sure..
15:53:25 <dcoutts> rasfar: partly nobody doing the work, and then when someone did (mostly/partly) people complained that the extra checks would slow down builds too much
15:53:36 <corgifex> Noldorin: =<<
15:53:42 <dcoutts> rasfar: so there's a patch floating around but not fixed & merged
15:53:58 <rasfar> i see; thanks.
15:54:06 <Noldorin> corgifex, hah oh right! no idea it existed. (just learning from LYAH here, so maybe it's mentioned later)
15:54:11 <Noldorin> corgifex, >>= is more common though perhaps?
15:54:25 <corgifex> do-notation desugars to >>=
15:55:07 <kaiz> who has efficient implementation of Kendall's tau?
15:55:10 * hackagebot hpc-coveralls 0.2.0 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.2.0 (killy971)
15:55:14 <Noldorin> corgifex, yeah was just thinking about that. probably why it's more common. thanks
15:55:28 <jakex_> Noldorin >>= is part of Monad class. =<< is flip (>>=)
15:55:47 <Noldorin> jakex_, sure, but that's arbitrary convention. neither is more fundamental than the other :)
15:56:08 <jakex_> yeah
15:56:12 <Noldorin> the do syntax explains why the former is preferred perhaps... given conventional preference
15:56:15 <Noldorin> but thanks!
15:56:25 <Noldorin> all clear now
15:57:24 <corgifex> od { putChar c; c <- getChar }  ==>  (\c -> putChar c) =<< getChar
15:58:32 <Noldorin> corgifex, oh there's an 'od' statement too, intriguing!
15:58:41 <corgifex> there isn't, actually
15:58:44 <Noldorin> oh :(
15:58:46 <Rarrikins> @undo do { putChar c; c <- getChar }
15:58:46 <lambdabot> <unknown>.hs: 1: 31:Parse error: Last statement in a do-block must be an expression
15:59:04 <Rarrikins> Ahh
16:04:47 <b1nery> How do you write binary data to a file? System.IO only appears to do text, and Data.Binary doesn’t work with Handles. Just need to write an array of Ints as a byte stream.
16:06:30 <Rarrikins> @hoogle ByteString
16:06:30 <lambdabot> Data.ByteString data ByteString
16:06:30 <lambdabot> Data.ByteString.Char8 data ByteString
16:06:30 <lambdabot> Data.ByteString.Lazy data ByteString
16:07:37 <b1nery> Rarrikins: aha, thanks!
16:07:51 <Rarrikins> b1nery: http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#g:28 in particular
16:07:58 <Rarrikins> b1nery: No problem.
16:08:35 <b1nery> Rarrikins: just getting my first real Haskell app working (Mandelbrot generator). It’s very exciting… :)
16:09:44 <zq> hi
16:10:00 <zq> Data.Int.Int32 == GHC.Int.Int32 ?!
16:12:43 <mgomes> how can i call a perl script from haskell?
16:17:42 <haasn> Mandelbrot! \o/
16:17:46 <Denommus> is there a function like replicateM_, but that takes a function that accepts the index of the repetition as parameter?
16:17:50 <haasn> :t noneOf (taking 50 $ iterated (\z -> z^2+c)) diverges 0
16:17:52 <lambdabot> Not in scope: ‘diverges’
16:18:12 <haasn> :t let diverges (x :+ y) = x^2 + y^2 > 4 in noneOf (taking 50 $ iterated (\z -> z^2+c)) diverges 0
16:18:13 <lambdabot>     Could not deduce (Integral b0) arising from a use of ‘^’
16:18:13 <lambdabot>     from the context (Ord a, Num a)
16:18:13 <lambdabot>       bound by the inferred type of
16:18:23 <Zekka> Does GHC expose a parser for its error messages?
16:18:35 <shachaf> No.
16:18:41 <Zekka> Alright, thanks
16:19:28 <haasn> Oh, ‘c’ is out of scope
16:19:37 <ReinH> Denommus: What do you mean by "the index of the repitition"?
16:19:47 <haasn> :t let diverges (x :+ y) = x^2 + y^2 > 4 in \c -> noneOf (taking 50 $ iterated (\z -> z^2+c)) diverges 0
16:19:48 <lambdabot> RealFloat a => Complex a -> Bool
16:20:00 <haasn> Great! I wonder where RealFloat comes from
16:20:15 <ReinH> haasn: the Prelude?
16:20:22 <haasn> I meant, why that constraint is there
16:20:25 <ReinH> heh
16:20:33 <Denommus> ReinH: something similar to how "for" works in C, for example. I need something to be repeated a n number of times, and each time to have an index
16:20:39 <haasn> instance RealFloat a => Num (Complex a)
16:21:11 <jakex_> :t forM_ [1..10] print
16:21:12 <lambdabot> IO ()
16:21:55 <Denommus> jakex_: that'll do, thanks
16:23:11 <RchrdB> Denommus, fyi, [1..10] == [1,2,3,4,5,6,7,8,9,10], not [1,2,3,4,5,6,7,8,9], in case you're expecting it to work exactly like a C for-loop with '<' in the conditional.
16:23:50 <eurythmia> Is there any way to specify a function's type in ghci? I'm working through LYAH, but I don't seem to be able to specify the function type in ghci because it tries to print the evaluated expression.
16:24:15 <dwcook> eurythmia, f :: T
16:24:19 <petrie> could someone help me out with this error? http://lpaste.net/720791796845641728
16:24:20 <RchrdB> eurythmia, you can put :: into expressions.
16:24:27 <RchrdB> > 1 :: Float
16:24:28 <lambdabot>  1.0
16:24:42 <ReinH> eurythmia: let f :: Int -> Int; f = succ
16:25:19 <jakex_> I love how `forM_ [1..] print' doesn't eat up all the memory
16:25:48 <haasn> eurythmia: if you introduce definitions using the “let <decl>” syntax in GHCi; you can write something like this: “let f :: a -> a; f x = x”
16:25:55 <jakex_> is that just the effect of laziness?
16:26:28 <haasn> Does LYAH explain how to use GHCi yet?
16:27:07 <quchen> haasn: The absolute basics, yes.
16:27:33 <RchrdB> jakex_, yes. (Strictly speaking, it might, if that 1::Integer, because integers are unbounded, but… the sun will burn out your computer ever counts that high.)
16:27:42 <haasn> jakex_: Yes. If you compile that with optimization, GHC will probably eliminate the list altogether. Also, note that doing it this way is still far less than optimal
16:27:53 <quchen> The problem with using 'let' as a beginner in GHCi is usually that there's no "in" for reasons that appear exotic.
16:28:15 <jakex_> haasn for what reason?
16:28:55 <eurythmia> ReinH haasn , thanks. That works well. I can see that I can also do something like the following (taking from LYAH)  let lucky :: (Integral a) => a-> String; lucky 7 = "Lucky number 7!"; lucky x = "You're not so lucky"
16:28:59 <ReinH> petrie: I think your parens are misplaced, but why not:
16:29:02 <ReinH> > sum . map (sum . filter (==1)) $ [[1,2,3,1],[1,2,1,4]]
16:29:04 <lambdabot>  4
16:29:19 <haasn> jakex_: using forM_ xs print is equivalent to print 1 >> print 2 >> print 3 >> ... which comes out as multiple I/O calls, one for each integer. I/O syscalls are sloooooooooow
16:29:21 <petrie> doh :(
16:29:39 <haasn> jakex_: I would use something like putStr $ unlines (map show [1..])
16:29:39 <petrie> ReinH: Thank you, I still kind of want to know whats wrong with what I had though :\
16:29:57 <ReinH> petrie: extract subexpressions and make sure they typecheck
16:30:24 <haasn> jakex_: which is still nonstrict, hence shares the same neat properties. It just gets streamed really nicely
16:30:29 <ReinH> (extract the anonymous lambdas and give them names)
16:30:48 <petrie> Ah ok
16:30:51 <petrie> thanks!
16:30:56 <ReinH> petrie: np
16:31:47 <eurythmia> quchen: could you explain (or link me to a document) explaining your statement about let/in ?
16:31:58 <ReinH> petrie: or even better:
16:32:15 <ReinH> > length . filter (==1) . concat $ [[1,2,3,1],[1,2,1,4]]
16:32:16 <lambdabot>  4
16:33:33 <quchen> eurythmia: In GHCi, you can read "let <definition>" as "let <definition> in <everything I'm going to type from here on>". The second part is implicit, and it'll make more sense when you learn about 'do' notation for IO, which is a couple of chapters later.
16:33:56 <haasn> > lengthOf (each.each.only 1) [[1,2,3,1],[1,2,1,4]]
16:33:58 <lambdabot>  4
16:34:02 <ReinH> haasn: shush
16:34:05 <petrie> o.0
16:34:10 <ReinH> haasn: :p
16:34:12 <ReinH> that is nice though
16:34:29 <petrie> Now mine really looks bad
16:34:35 <ReinH> haasn: we need a lensbot that replaces expressions with lensified versions
16:34:36 <eurythmia> quchen: Cool. I'll tuck that into the back of my brain until I reach that section. Thank you.
16:34:39 <ReinH> haasn: since you probably don't scale
16:34:50 <haasn> > length [() | xs <- [[1,2,3,1],[1,2,1,4]], 1 <- x]
16:34:52 <lambdabot>  Couldn't match expected type ‘[t1]’
16:34:52 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
16:34:57 <haasn> > length [() | xs <- [[1,2,3,1],[1,2,1,4]], 1 <- xs]
16:34:59 <lambdabot>  4
16:35:01 <ReinH> heh
16:35:10 <quchen> eurythmia: You can of course use "let … in" in GHCi as well, but then the definitions will only span over what's in the "in", and not everything you type later.
16:35:25 <quchen> > let x = 3 in x + 2   -- like so, eurythmia
16:35:26 <lambdabot>  5
16:35:47 <quchen> Asking for "x" again now will give you an error because x isn't in scope.
16:35:55 <Zekka> I feel cheated: my code worked on the second compile instead of the first.
16:36:03 <eurythmia> quchen: which, for most cases defeats the purpose of using the interactive interpreter. It is good to know, though, that there *is* an "in", but it's just implicit.
16:37:20 <monochrom> part of it is because x is a constant, not a mutable variable, in functional programming
16:38:25 <haasn> Zekka: now how about that GSoC proposal for making GHC deterministic?..
16:42:30 <zq> haasn: the gc prevents you from doing that
16:48:33 <Zekka> merijn - FYI, the reason that warnings were showing up as errors for me earlier is complicated and involves incorrectly-written errorformats in Syntastic
16:49:01 <Zekka> I've fixed the problem but it took wrapping hdevtools with a homemade script that fixes the output so it's easy to parse
16:49:43 <elmiko> hi all, i've been running across this operator "<+>" recently, could someone point me to a section in the docs that might help me understand?
16:50:03 <apples> @hoogle (<+>)
16:50:04 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
16:50:04 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
16:50:04 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
16:50:10 <ReinH> Zekka: why do you have to do that stuff? It Just Works for me.
16:50:32 <Zekka> ReinH - Hdevtools with syntastic?
16:50:43 <haasn> elmiko: I've most commonly seen it in connection to pretty-printers
16:50:45 <Zekka> It worked inasmuch as it generated errors and warnings, but it represented warnings as errors
16:51:00 <ReinH> Zekka: :/
16:51:00 <Zekka> and an hour and a half of errorformat hacking wasn't enough to fix it
16:51:12 <ReinH> errorformat is a pretty annoying beast
16:51:13 <haasn> elmiko: but it's not “standardized” as, say, <*> is
16:51:15 <Zekka> and I'm a perfectionist so I felt the need to fix it
16:51:16 <elmiko> apples, haasn, thanks
16:51:16 <Nik05> ReinH you are stuill here :) I finally know the problem. just got into bed and the problem popped up in my head
16:51:27 <elmiko> haasn: i see it often in xmonad configs
16:51:29 <ReinH> Nik05: I'm pretty much always here
16:51:34 <elmiko> but i was having trouble searching for it
16:51:45 <Zekka> If you're wondering, this is the code I ended up writing (not very clean FWIW) to fix the problem: http://pastebin.com/B5f5HA7s
16:51:47 <haasn> elmiko: http://hackage.haskell.org/package/xmonad-0.11/docs/XMonad-ManageHook.html#v:-60--43--62-
16:51:57 <Zekka> I just pipe the output through that and parse the much cleaner resulting output
16:51:59 <haasn> Looks like it's just a synonym for mappend from before we had <> in base
16:52:24 <Nik05> ok :) the problem is that one i have a flush but also something like a pair, it would count it as a pair
16:52:24 <elmiko> haasn: thank you much :)
16:52:46 <ReinH> Nik05: well then your rankings are ordered poorly :p
16:52:50 <haasn> that is generally sort of the usage of <+> I've seen, in general - appending things in a style reminiscent of monoids; sometimes with stuff like extra spaces in between
16:52:53 <Nik05> sorry for my typing in bed now, dont make sense
16:53:01 <geekosaur> haasn, yes. (also once upon a time it was specific to ManageHooks)
16:53:07 <ReinH> Nik05: also you can't have a flush and a pair at the same time
16:53:37 <Nik05> well you van but than it is a flush
16:53:50 <Nik05> because flush rans higher
16:54:46 <Nik05> im going to rewrite it
16:54:46 <monochrom> a flush is like {king, king, queen, queen, queen}, is that right?
16:54:59 <Nik05> no
16:55:08 <monochrom> oops, that's full house, haha
16:55:13 <zq> that's a house
16:55:17 <Nik05> full house with rank queen and then king
16:55:40 <zq> flush would be all of the same oneOf ["diamonds".."spades
16:55:41 <zq> "]
16:55:44 * tcard is getting a "setup: The program happy is required but it could not be found" when installing happy using "cabal install happy"
16:55:49 <eurythmia> monochrom: a flush is everything of the same suit
16:55:56 <zq> :: Suit
16:56:05 <monochrom> I was never a fan of flush and straight
16:56:05 <zq> [ ]
16:56:27 <eurythmia> monochrom: straight flushes are pretty epic.
16:56:29 <monochrom> I prefer "same colour" for suits, and "prime sequence" for the other field.
16:57:02 <monochrom> and "even sequence" such as {2, 4, 6, 8, 10}
16:57:06 <ReinH> Nik05: no, you literally can't have a 5 card poker hand that is both a flush and a pair
16:57:42 <ReinH> if you have a pair then you have two cards of different suits
16:57:50 <[swift]> do people use ST in a nested fashion?
16:57:53 <Nik05> ok :P
16:58:21 <Nik05> to exclude the flush, i get it :)
16:58:41 <haasn> [swift]: nested?
16:58:41 <[swift]> i'm working on a library that uses a similar universal quantification trick to keep values from leaking, but uses of this library *will* need to use things in a nested fashion
16:58:58 <[swift]> haasn: yeah, like runST inside runST
16:59:00 <monochrom> I also prefer to cheat. substitute cards from my sleeve. I will gladly make {spade 2, spade 2, spade 2, spade 2, spade 2} :)
16:59:01 <haasn> you mean like runST $ do a; b; let x = runST somethingElse; f x ?
16:59:08 <Nik05> does three of a kind and pair also exclude eachother?
16:59:08 <[swift]> yup, exactly
16:59:26 <ReinH> Nik05: no
16:59:47 <monochrom> I have not used runST inside runST. but it is legal.
16:59:48 <haasn> [swift]: I think that is fine, but try it to be sure
16:59:55 <ReinH> well, in that any hand with trips in it also has a pair. 3 of them, in fact.
16:59:56 <Nik05> so you can have a pair, three of a kind and a full house?
16:59:59 <[swift]> what i'm wondering is: is there a safety issue in providing a function of type "TaggedType s -> MyMonad s' (TaggedType s')"
16:59:59 <ReinH> But it would be scored as trips of course
17:00:16 <Nik05> trips?
17:00:21 <ReinH> Nik05: trips = three of a kind
17:00:21 <haasn> I don't think ST exposes any “safety” issues apart from unsafe* functions
17:00:26 * hackagebot hpc-coveralls 0.2.1 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.2.1 (killy971)
17:00:28 <haasn> If it type checks, runST permits it
17:00:44 <ReinH> if you're scoring {2,2,2,3,3} as a pair then you're scoring it wrong
17:00:44 <[swift]> to make it concrete, imagine if ST provided "fromOuterScope :: STRef s -> ST s' (STRef s')"
17:00:44 <monochrom> if you don't use any unsafeXXX, you don't have a safety issue
17:00:55 <[swift]> this would let you pull a value from an outer scope into an inner scope
17:00:59 <Nik05> trips as in tri - p[air] - s?
17:01:06 <haasn> [swift]: how would you implement it?
17:01:17 <ReinH> Nik05: trips probably as in triple -> trip -> trips
17:01:33 <ReinH> it's just a slang that poker players use a lot
17:01:38 <haasn> I can't think of a way to do that other than unsafeCoerce
17:01:38 <ReinH> three of a kind is also called a set
17:01:47 <[swift]> you can of course refer to values in outer scopes already, but the fact that they have a different type makes it annoying to write something like "if cond then (valueFromOuterScope :: ST s) else (valueFromInnerScope :: ST s')"
17:02:02 <Nik05> trips seems more like a three of a kinds.
17:02:04 <monochrom> haasn, I believe [swift] is speaking figuratively
17:02:11 <[swift]> haasn: i'm not actually doing this with ST, but with my own monad
17:02:12 <ReinH> Nik05: trips is a three of a kind
17:02:29 <Nik05> oh thought you said full house
17:02:36 <ReinH> nope
17:02:43 <[swift]> the problem is that an expression like that "if" expression i just described doesn't type check, since the phantom type parameter is different
17:03:14 <[swift]> it can make working with nested universally quantified scopes annoying, but i'm not sure if it's safe to provide a way to promote values. i *think* it is - i can't think of an issue - but i figured others might know better
17:03:19 <Nik05> ok now im really going to sleep. thanks for all the help ReinH
17:03:30 <ReinH> Nik05: you score by the highest rank of any 4 of a kind, then 3, then 2, then 1
17:03:45 <ReinH> Nik05: er, you score by hand strength, then that
17:03:53 <Nik05> yes
17:04:02 <[swift]> my concern is that people could somehow play a trick to escape the runST-like function and leak values out of their proper scope
17:04:12 <haasn> [swift]: I think in principle that is an unsafeOperation as it would probably let you leak values in the other direction and hence break ST
17:04:19 <haasn> oops, I did not mean to write that in camel case :)
17:04:40 <[swift]> haha, at least you didn't use underscores =)
17:05:14 <[swift]> haasn: that's exactly what i feared, and i'm not sure how to be sure i've prevented it
17:05:23 <tcard> Anybody putting just GHC and cabal(-install) in --global?  Are you able to install happy in a sandbox?
17:07:08 <ReinH> > let kind n = filter ((n==) . length) ranks; ranks = (group . reverse . sort) [1,4,3,3,1] in [4,3,2,1] >>= kind -- Nik05
17:07:10 <lambdabot>  [[3,3],[1,1],[4]]
17:10:01 <Nik05> ReinH thats my algorithm :D
17:10:05 <ReinH> Nik05: :p
17:10:13 <haasn> [swift]: I'm not sure why you need to nest runST invocations if you're passing STRefs in between them
17:10:51 <haasn> It doesn't make sens from an abstraction point of view
17:10:57 <[swift]> haasn: because i'm just using ST as an example so i don't have to give more background than people maybe want to hear
17:11:15 <Nik05> but what are you doing with that bind ReinH?
17:11:16 <[swift]> haasn: i'm actually trying to model arena allocation on the C side in an FFI binding
17:11:39 <[swift]> haasn: nested invocations of my monad correspond to nested arena scopes
17:12:01 <haasn> [swift]: ah, okay; that makes sense, it seems my answer is too specific to ST to be of much use, but I don't understand enough about your specific domain to formulate a better answer
17:13:35 <[swift]> haasn: no worries; it helped me to type out my concerns, in any case
17:14:01 <perses> if i have empty graph G, and i want to do this, and want to add 1, 2, 3 one by one to g, my technique is: add-nodes (add-nodes (add-nodes G 1) 2) 3, add-nodes G node will return a new graph with nodes, how can i implement this?
17:14:55 <Rarrikins> > foldr f 0 [1, 2, 3]
17:14:57 <lambdabot>  No instance for (GHC.Show.Show a0)
17:14:57 <lambdabot>    arising from a use of ‘M587806482332013567815716.show_M5878064823320135678...
17:14:57 <lambdabot>  The type variable ‘a0’ is ambiguous
17:14:57 <lambdabot>  Note: there are several potential instances:
17:14:57 <lambdabot>    instance [safe] GHC.Show.Show
17:15:07 * Rarrikins shakes his claws at lambdabot 
17:15:15 <napping> Is there a version of Lens's uniplate which doesn't recurse under type arguments?
17:15:40 <perses>  > foldr f 0 [1, 2, 3]
17:15:44 <perses> > foldr f 0 [1, 2, 3]
17:15:46 <lambdabot>  No instance for (GHC.Show.Show a0)
17:15:46 <lambdabot>    arising from a use of ‘M66283248691934265515769.show_M66283248691934265515...
17:15:46 <lambdabot>  The type variable ‘a0’ is ambiguous
17:15:46 <lambdabot>  Note: there are several potential instances:
17:15:46 <lambdabot>    instance [safe] GHC.Show.Show
17:15:57 <ReinH> Nik05: using the list monad
17:15:58 <Rarrikins> > f x
17:15:59 <lambdabot>  No instance for (GHC.Show.Show a0)
17:16:00 <lambdabot>    arising from a use of ‘M896000382814618537315794.show_M8960003828146185373...
17:16:00 <lambdabot>  The type variable ‘a0’ is ambiguous
17:16:00 <lambdabot>  Note: there are several potential instances:
17:16:00 <lambdabot>    instance [safe] GHC.Show.Show
17:16:29 <Nik05> so ReinH what should that code do?
17:16:44 <ReinH> > let kind n = filter ((n==) . length) ranks; ranks = (group . reverse . sort) [1,4,3,3,1] in concat [ kind n | n <- [4,3,2,1]] -- Nik05
17:16:46 <lambdabot>  [[3,3],[1,1],[4]]
17:17:57 <Nik05> and what does kind do?
17:17:58 <ReinH> Nik05: or, remembering that bind for [a] is concatMap
17:18:14 <ReinH> > let kind n = filter ((n==) . length) ranks; ranks = (group . reverse . sort) [1,4,3,3,1] in concatMap kind [4,3,2,1]
17:18:15 <lambdabot>  [[3,3],[1,1],[4]]
17:18:43 <ReinH> Nik05: gets the members of the hand of kind n
17:18:48 <ReinH> where kind 2 are pairs
17:18:57 <ReinH> kind 4 are quads
17:18:57 <ReinH> etc
17:20:12 <haasn> ReinH: I want to lens-golf this but I have no idea what that function is supposed to be doing
17:20:17 <ReinH> haasn: :p
17:20:22 <ReinH> haasn: have you tried reading it?
17:20:42 <ReinH> > group . reverse . sort $ [1,2,3,1,2]
17:20:43 <Nik05> still dont get it...
17:20:43 <lambdabot>  [[3],[2,2],[1,1]]
17:20:51 <athan> hey guys is there a function that simply returns a value wrapped in a "Just", but throws an exception otherwise?
17:21:08 <haasn> Oh, oh, wait a minute.
17:21:14 <ReinH> > filter ((==2) . length) . group . reverse . sort $ [1,2,3,1,2]
17:21:15 <lambdabot>  [[2,2],[1,1]]
17:21:28 <Nik05> why filter?
17:21:32 <haasn> You want to produce a list containing all 4-pairs, then all 3-pairs, then all 2-pairs then all 1-pairs?
17:21:43 <ReinH> > let kind n = filter ((==n) . length); ranks = group . reverse . sort in (kind 2 . ranks) [1,2,3,1,2]
17:21:44 <lambdabot>  [[2,2],[1,1]]
17:21:46 <ReinH> haasn: yes
17:21:58 <apples> athan: fromJust
17:22:01 <Nik05> why not sortBy length of the lists
17:22:15 <athan> apples: DERP! Weird, why didn't that show up in hoogle?
17:22:27 <ReinH> Nik05: hmm, should be fine if the sort is stable
17:22:32 <apples> @hoogle Maybe a -> a
17:22:33 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
17:22:33 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
17:22:33 <lambdabot> Data.Monoid First :: Maybe a -> First a
17:22:39 <apples> dunno :)
17:22:51 <athan> ><
17:23:21 <Nik05> > sortBy (\a b -> compare (length b) (length a)) . group . reverse . sort
17:23:23 <lambdabot>  <[()] -> [[()]]>
17:24:22 <ReinH> > sortBy (flip (comparing length)) . group . reverse . sort $ [1,2,3,1,2]
17:24:23 <lambdabot>  [[2,2],[1,1],[3]]
17:24:26 <ReinH> Nik05: not bad
17:24:28 <Nik05> > sortBy (\a b -> compare (length b) (length a)) . group . reverse . sort $ [1,2,3,1,2]
17:24:29 <lambdabot>  [[2,2],[1,1],[3]]
17:24:32 <ReinH> well, I just reversed twice, so...
17:24:42 <Rarrikins> orly
17:24:46 <ReinH> nope
17:24:53 <Nik05> does the same...
17:24:57 <ReinH> Nik05: yep
17:24:58 <ReinH> so it would work
17:25:22 <Nik05> oh you can just do comparing length?
17:25:22 * ReinH shrugs
17:25:29 <ReinH> comparing f = compare `on` f
17:25:48 <Nik05> whats on?
17:25:51 <ReinH> @src on
17:25:52 <lambdabot> (*) `on` f = \x y -> f x * f y
17:26:12 <Nik05> whats *?
17:26:13 <Rarrikins> > sortBy (comparing (\xs -> (length xs, head xs))) . group . sort $ [1, 2, 3, 1, 2]
17:26:14 <ReinH> applies f to either side
17:26:15 <lambdabot>  [[3],[1,1],[2,2]]
17:26:18 <ReinH> Nik05: some random operator
17:26:21 <Rarrikins> > sortBy (comparing (\xs -> (-length xs, head xs))) . group . sort $ [1, 2, 3, 1, 2]
17:26:22 <lambdabot>  [[1,1],[2,2],[3]]
17:26:32 <Rarrikins> Take that, out of order numbers!
17:26:34 <ReinH> Rarrikins: they're already sorted by rank
17:26:39 <Rarrikins> Oh
17:26:41 <ReinH> Rarrikins: so as long as the sort is stable they'll stay sorted by rank
17:26:53 <Rarrikins> I was looking at Nik05's thingy.
17:27:14 <Rarrikins> [[2,2],[1,1]...] is the work of Satan.
17:27:21 <ReinH> Rarrikins: why?
17:27:36 <haasn> ReinH: I came up with this which isn't exactly short but I thought it was worth demonstrating: http://lpaste.net/102701
17:27:52 <haasn> I wish TransformListComp was less verbose
17:27:57 <ReinH> it does what you'd expect
17:27:59 <ReinH> > [[2,2],[1,1],[7]] > [[2,2],[1,1],[6]]
17:28:01 <lambdabot>  True
17:28:03 <haasn> “then group by x using groupWith” :(
17:28:13 <ReinH> > [[2,2],[1,1],[7]] > [[9,9],[1,1],[6]]
17:28:14 <lambdabot>  False
17:28:30 <Algebr> I'm on ghci 7.4.1 and when I run a script using import System, I get that ghci can't find the module System, yes I have random installed.
17:28:47 <ReinH> haasn: yeah not bad
17:28:58 <ReinH> "sort with by"
17:28:59 <geekosaur> Algebr, System is from 1998. you want System.Random
17:29:28 <geekosaur> or you want to force Haskell98 compatibility mode but that will lock you out of a bunch of stuff that requires post-1998 features
17:29:32 <haasn> ReinH: it tried to read like english but it fails miserably in this case :P
17:29:32 <ReinH> Unless you want non-biased random numbers, in which case you don't
17:29:37 <ReinH> haasn: yeah
17:29:38 <haasn> “then sort with by down length x, the x”
17:29:39 <ReinH> oh well
17:29:44 <ReinH> haasn: heh
17:29:54 <ReinH> haasn: to be fair, english is its second language
17:30:04 <haasn> its first is SQL
17:30:06 <ReinH> or at least not its first language
17:30:24 <Algebr> geekosaur: ah, I was reading through an dated tutorial I guess.
17:31:17 <geekosaur> the System module, and other flat modules, were getting way too full. there are hierarchical modules now
17:31:24 <haasn> ReinH: I still like to show off TransformListComp where possible, because it sometimes makes lengthy list-transformations very easy to write
17:31:29 <haasn> and very easy to refactor
17:33:03 <athan> Hey guys, so I'm having a little trouble building a simple program
17:33:29 <athan> I'm trying to just quick-and-dirty compile it with ghc, but it's telling me that it can't find a module, and I just installed the package containing it
17:33:49 <dwcook> athan, what's the error message say?
17:34:10 <athan> main.hs:14:18:
17:34:11 <athan>     Could not find module `Web.UAParser'
17:34:12 <athan>     Locations searched:
17:34:12 <athan>       Web/UAParser.hs
17:34:12 <athan>       Web/UAParser.lhs
17:34:32 <athan> it's very general :/
17:34:38 <dwcook> Is that part of your project or from some other package?
17:34:47 <athan> that's actually some other package
17:35:41 <athan> should I just bite the bullet and set up a sane cabal environment & sandbox it?
17:35:42 <ReinH> haasn: seems good :)
17:36:04 <ReinH> athan: biting the bullet involves 3 shell commands...
17:36:16 <athan> but... but... thinking...
17:36:26 <ReinH> thinking is the worst
17:36:27 <haasn> ReinH: https://github.com/haasn/haddock/blob/master/src/Haddock/Backends/Xhtml/Decl.hs#L177 :)
17:36:28 <athan> :P Sorry, might as well. Thanks anyway
17:37:18 <Algebr> I keep getting a parse error when on the line where I declare `module SendSms where`
17:37:19 <ReinH> haasn: how do you ensure that `the' is safe?
17:37:30 <Guest84344> ReinH my screen/irssi crashed/stopped printing info to screen
17:37:52 <haasn> ReinH: ‘group’ won't ever produce empty lists
17:38:06 <ReinH> haasn: so you have to think about it. :/
17:38:20 <ReinH> haasn: I prefer correct-by-construction to correct-by-thinking-about-it
17:38:22 <ReinH> :p
17:39:06 <Algebr> nvm, brain freeze about making module come before imports.
17:41:05 <haasn> > myQuickCheck $ all (not . null) . group
17:41:07 <lambdabot>  Not in scope: ‘myQuickCheck’
17:41:07 <lambdabot>  Perhaps you meant one of these:
17:41:07 <lambdabot>    ‘myquickcheck’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
17:41:07 <lambdabot>    ‘polyQuickCheck’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
17:41:07 <lambdabot>    ‘quickCheck’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
17:41:07 <haasn> ReinH: yeah, ‘the’ is a bit unfortunate in this regard
17:41:09 <haasn> ReinH: but you can work around it
17:41:11 <haasn> ReinH: if correctness is what you want; you can add an extra “x':_ <- x”
17:41:13 <haasn> and this x' will be equivalent to (the x) except where x is [] that case is simply omitted from the results
17:41:22 <Nik05> ReinH i think i crashed
17:41:33 <haasn> > myquickcheck $ all (not . null) . group
17:41:35 <lambdabot>  +++ OK, passed 100 tests.
17:41:35 <lambdabot>  "OK, passed 100 tests."
17:42:22 <roconnor_> @check  all (not . null) . group
17:42:24 <lambdabot>  +++ OK, passed 100 tests.
17:43:13 <haasn> Oh, neat, that works “again”
17:43:49 <roconnor_> @check  (not . null) . group
17:43:51 <lambdabot>  *** Failed! Falsifiable (after 1 test):
17:43:51 <lambdabot>  []
17:44:25 <Nik05> ReinH did yosay anything to me?
17:45:18 <hpc> :t myquickcheck
17:45:20 <lambdabot> Testable prop => prop -> String
17:45:27 <hpc> > myquickcheck True
17:45:29 <lambdabot>  +++ OK, passed 1 tests.
17:45:29 <lambdabot>  "OK, passed 1 tests."
17:45:34 <hpc> weeeeeird
17:45:49 <Rarrikins> @check const True
17:45:51 <lambdabot>  +++ OK, passed 100 tests.
17:46:16 <hpc> i like how it can't use the type to infer a size of the function space
17:47:15 <zq> what
17:47:20 <zq> lambdabot has qc now?
17:47:38 <Rarrikins> No!
17:47:46 <sipa> quantum computer?
17:47:52 <zq> :t myquickcheck
17:47:53 <lambdabot> Testable prop => prop -> String
17:48:29 <joelteon> @check (==)
17:48:32 <lambdabot>  +++ OK, passed 100 tests.
17:48:36 <joelteon> @check (/=)
17:48:38 <lambdabot>  *** Failed! Falsifiable (after 1 test):
17:48:38 <lambdabot>  () ()
17:48:55 <Rarrikins> @check ((==) :: Int -> Int -> Bool)
17:48:56 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 2 shrinks):
17:48:57 <lambdabot>  0 1
17:49:10 <Rarrikins> @check ((/=) :: Int -> Int -> Bool)
17:49:12 <lambdabot>  *** Failed! Falsifiable (after 1 test):
17:49:12 <lambdabot>  0 0
17:49:19 <joelteon> I hope shachaf doesn't come back and see us using lambdabot.
17:50:16 <zq> he'll be back quicker if you highlight him like that
17:52:02 <Algebr> I have this response from playing with curl, and its of type IO (), but that doesn't make sense, why isn't it type IO String? I mean I can print it to the screen
17:52:23 <johnw> maybe it is itself printing directly to the screen?
17:52:40 <Algebr> what's even weirder is that I can just do b, where b is the thing I'm talking about, but doing print b craps out.
17:53:04 <Algebr> doing this in ghci, fwiw
17:53:36 <johnw> wouldn't that need to be print =<< b?
17:54:11 <Algebr> That does work.
17:54:45 <Algebr> didn't even know about that =<<
17:57:34 <smiller2> In Pipes, "The concrete type synonyms use () to close unused inputs and X (the uninhabited type) to close unused outputs" - why is () rather than Void used to closed unused inputs?
17:59:56 <srhb> Algebr: Where do you have the curl function from?
18:00:11 <intrados> Is there a preexisting way of escaping only a subset of HTML when using blaze's toHtml?
18:01:00 <srhb> Algebr: (also you shouldn't use curl)
18:03:14 <Iceland_jack> hopefully not :)
18:03:14 <Iceland_jack> @ty System.Process.readProcess "/usr/bin/curl" ["-s", "..."] []
18:03:16 <lambdabot> IO String
18:03:27 <srhb> Iceland_jack: :|
18:03:54 <wavewave> hello.
18:03:59 <srhb> wavewave: o/ o/
18:04:11 <wavewave> srhb: hi!
18:04:31 <luite> hello
18:04:44 <wavewave> luite: hey! I was looking for you ;-)
18:04:51 <luite> cool :p
18:05:06 <luite> it's rainy here today so i have some time for hacking
18:05:17 <wavewave> sounds good.
18:05:47 <wavewave> how is ghcjs these days? I haven't followed it recently.
18:06:35 <wavewave> luite: do you have release schedule with ghc-7.8?
18:07:24 <albeit_> How would I convert the following to point-free form? "toPrice (read (tokens !! 2) :: Float)". I'm getting caught up forcing read to Float...
18:07:59 <Iceland_jack> albeit_: augustsson proposed a feature to solve something similar :) allowing (:: Float) sections
18:08:05 <dwcook> smiller2, the same reason you might use 1 instead of 0 as an argument to an arithmetic operator
18:08:36 <dwcook> smiller2, as a trivial example, () -> A is equivalent to A but Void -> A cannot give you an A at all.
18:08:41 <luite> wavewave: yeah fixing the most important issues in the next two weeks and then upload to hackage :)
18:08:59 <albeit_> Iceland_jack: Ah okay, so I guess that's the best I can do for it then?
18:09:07 <wavewave> luite: sounds good~ :D
18:09:21 <Iceland_jack> albeit_: let me link you the discussion, it had multiple alternative solutions :)
18:09:46 <wavewave> luite: I would like to help ghcjs with nix package manager.
18:09:56 <luite> just did a big commit changing how global static data is encoded, that's probably the last big change before release
18:10:35 <wavewave> luite: last few months, I happened to become an experienced developer of nix..
18:10:39 <Iceland_jack> albeit_: http://www.reddit.com/r/haskell/comments/2239wh/a_small_haskell_extension/
18:10:49 <albeit_> Iceland_jack: Great! Thanks!
18:10:50 <luite> wavewave: ok cool :)
18:10:59 <Iceland_jack> That being said, I wouldn't really recommend making that point-free
18:11:02 <luite> wavewave: are you going to the next zurihac btw?
18:11:03 <wavewave> luite: :)
18:11:14 <wavewave> luite: sure.
18:11:25 <Iceland_jack> albeit_: is the type of toPrices polymorphic?
18:11:26 <wavewave> luite: I am also thinking of visiting Budafest, too.
18:11:36 <luite> wavewave: cool. i'll be back from new zealand just in time for zurihac (and budhac)
18:11:41 <Iceland_jack> @ty ?toPrices . read . (!! 2)
18:11:42 <lambdabot> (?toPrices::b -> c, Read b) => [String] -> c
18:12:09 <albeit_> Iceland_jack: No, toPrice :: Float -> Int
18:12:19 <Iceland_jack> albeit_: then you don't need the annotations at all
18:12:46 <Iceland_jack> @ty (undefined :: Float -> Int) . read . (!! 2)
18:12:48 <lambdabot> [String] -> Int
18:13:16 <wavewave> luite: so, to start, where should I start? I remember some vagrant script before, but I cannot locate it..
18:13:20 <Iceland_jack> You only need to annotate read if the resulting type is ambiguous
18:13:28 <luite> wavewave: vagrant isn't necessary anymore
18:13:35 <zq> if toPrice is annotated then the result of read would be inferred
18:13:36 <albeit_> Iceland_jack: Ahh thats better, still learning the whole type system ;)
18:13:42 <zq> albeit_: ^
18:13:57 <Iceland_jack> If you do something like
18:13:58 <Iceland_jack> > if read "True" then 0 else 1
18:13:58 <Iceland_jack> Haskell knows which type 'read "True"' should be
18:13:59 <lambdabot>  0
18:14:09 <luite> wavewave: install ghc 7.8.2, then updat your cabal lib / executable with the ghcjs branch from our stuff, then just cabal install it and run ghcjs-boot --init
18:14:16 <Iceland_jack> same as writing
18:14:16 <Iceland_jack> > if read "True" :: Bool then 0 else 1
18:14:18 <lambdabot>  0
18:14:43 <wavewave> luite: oh... that's super-easier than before ;-)
18:15:10 <luite> wavewave: well it used to be pretty horible :p
18:16:00 <Iceland_jack> albeit_: Another example, here lambdabot know that 'read "Nothing"' should have type 'Maybe Bool'
18:16:04 <wavewave> luite: will it replace original Cabal with ghc-7.8?
18:16:04 <Iceland_jack> :t if True then read "Nothing" else Just True
18:16:05 <lambdabot> Maybe Bool
18:16:12 <Iceland_jack> > if True then read "Nothing" else Just True
18:16:13 <lambdabot>  Nothing
18:16:23 <Iceland_jack> Can you tell why? :)
18:16:23 <luite> wavewave: it adds it as an installed package, the old one will still be there
18:16:38 <rasfar> hi luite; you're on the GHC team now? last time we chatted you were wrestling with using SYB in the GHC API, guess that was 2012 or so...
18:17:44 <zq> that's a pretty ip6
18:17:50 <wavewave> luite: Okay, I see the version is now updated.
18:19:11 <luite> rasfar: not really, i'm still using the GHC API and working on GHCJS (which is almost ready for release now), got a few patches into GHC 7.8 to support GHCJS, but i don't do regular maintnance work atm
18:20:37 * hackagebot simple-sendfile 0.2.14 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.14 (KazuYamamoto)
18:21:08 <wavewave> luite: what will "ghcjs-boot --init" do?
18:21:26 <wavewave> luite: in terms of file-copying and registering packages..
18:23:15 <luite> wavewave: it gets the ghcjs-boot repo from github, inits all submodules, applies patches and then builds the standard libs for ghcjs (ghc-prim, ghcjs-prim, integer-gmp, base, ghcjs-base, text, vector, containers, aeson, bytestring etc)
18:23:37 <luite> all in ~/.ghcjs/platform-version/ghcjs-boot
18:24:05 <rasfar> okay! i'd not read about GHCJS before now, but that's certainly something I could use right about now. Was looking in Fay's direction, but never took the plunge yet.
18:24:07 <luite> wavewave: for release i'd like to include them in an archive
18:25:24 <luite> rasfar: it's pretty much complete for standard haskell stuff, with threading, stm, exceptions and all
18:25:37 * hackagebot cookbook 2.3.1.0 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.3.1.0 (NatePisarski)
18:25:46 <wavewave> luite: okay, cool. For nix, i may need patch the ~/.ghcjs directory to some nix-way location, but it should not be very difficult.
18:26:20 <wavewave> luite: if it is released just as an archive, then it will be again much easier..
18:26:38 <luite> wavewave: i think the ghcjs-boot thing needs some changes anyway to make it easier to do releases, so i'm open to suggestions :)
18:28:07 <luite> also the cabal stuff still needs to be merged upstream
18:28:12 <rasfar> would this be suitable for re-writing a JS UI? (it's in its first iteration and needs a complete rewrite anyway) Or is it less suited to those (UI) aspects of JS?
18:28:47 <luite> but travelling ing in new zealand has made it a bit harder to get thse things done :)
18:29:08 <luite> rasfar: sure it can work with fpr libs like sodium
18:29:21 <luite> frp
18:29:24 <rasfar> I'd prefer to develop/maintain Haskell than JS, if it wasn't too much of a stretch
18:30:24 <luite> there's still a fair bit of low-level things to build up, no ready to go gui toolkit yet
18:30:27 <rasfar> ah ... well, what I have is mostly a Canvas and callbacks, kind of traditional HTML5...
18:31:35 <wavewave> luite: I am looking at https://github.com/ghcjs/ghcjs/blob/master/src-bin/Boot.hs. I guess this is all that it does..
18:32:08 <rasfar> i wouldn't really be able to do much here with a GUI toolkit anyhow; but a switch to FRP isn't out of the question.
18:32:12 <luite> wavewave: yeah it's just a setup script
18:33:34 <rasfar> this is good incentive to get 7.8 installed
18:34:06 <wavewave> luite: by the way, nix is super-cool to use. have you tried to use it?
18:34:37 <luite> wavewave: haven't yet
18:35:24 <luite> rasfar: installation could still be a bit bumpy, i'm updating the boot repository packages to the latest version soon. hop onto #ghcjs if you have any problems
18:35:38 * hackagebot isiz 0.0.1 - A program to show the size of image and whether suitable for wallpaper.  http://hackage.haskell.org/package/isiz-0.0.1 (HironaoKomatsu)
18:36:33 <rasfar> thanks - i need to purchase a new machine first ... verily this one would go up in smoke with another GHC build; probably in a month i'll be there.
18:36:47 <wavewave> I think that nix is the first platform where ghc-7.8.2 and all other haskell packages are being build-tested now. see http://hydra.nixos.org/eval/1096078
18:36:50 <albeit_> Trying to get an idea of how to start writing a program. It should insert a list of key-value pairs into a Data.Map one by one, checking to see if the Map satisfies a condition, then exit once the condition is met. Thinking of folding over the list of pairs with a Maybe, when the condition is true, make it a Just?
18:37:29 <albeit_> (Well, a "reversed" Maybe. Not sure on how to "exit" when the condition is met).
18:37:40 <MagBo_> greetings, people! I think that question is asked here a lot, but how to build things properly (whithout using cabal because it just doesn't work).
18:38:24 <luite> rasfar: ok then i'm back in europ and ghcjs should be up on hackage :)
18:38:53 <MagBo_> for instance, just now cabal update && cabal install cabal-install yielded
18:39:13 <zq> meh, why cn't haskell just use (!=) like everyone else
18:39:32 <MagBo_> https://gist.github.com/anonymous/7fb8f1cb0b5992f5ba3f
18:41:35 <wavewave> MagBo_: checking all package combinations' compatibility is beyond cabal's ability and scope.
18:41:59 <rasfar> wavewave: is that all of platform, or all of hackage? (http://hydra.nixos.org/eval/1096078)
18:42:39 <MagBo_> A proper way to do that in other languages is well known — build tool doesn't install things, instead we have a project definitions that can be automatically fetched from well-known locations with build tool as dependencies and compiled locally, honouring the version lock file. Then packaging is up to OS users powered by tools for packaging software one or another OS offers. So, I guess, my question is how to adopt this way of usage of cab
18:42:50 <rasfar> if hackage could report buildability status on the package pages that would be nice
18:42:55 <wavewave> rasfar: only packages in nixpkgs. But it's covering a fairly large portion.
18:43:27 <wavewave> MagBo_ : use nix. ;-)
18:43:57 <MagBo_> wavewave: I'm using arch linux, thank you very much, and we have second best package manager that I'm aware of. Why is this relevant?
18:44:13 <wavewave> MagBo_ : I am using nix on arch linux.
18:44:23 <wavewave> MagBo_ : nix is installable anywhere.
18:44:27 <roconnor_> heh, nix is a good answer when the question is how to build things properly. :)
18:44:28 <MagBo_> then I don't know what nix is!
18:44:32 <dcoutts> MagBo_: you are of course welcome to use the tools that convert cabal packages to arch packages
18:44:57 <wavewave> for example, on my mac machine.
18:45:55 <MagBo_> dcoutts: we all know how this ends (see ton of orphaned haskell-* packages on AUR and dead haskell-web package repository).
18:45:57 <wavewave> MagBo_ : my answer is quite relevant in the sense of what you said, seriously.. nix does the part of that job quite satisfiably.
18:46:09 <MagBo_> wavewave: I'm trying to look up nix online.
18:46:26 <wavewave> MagBo_ : but of course, just with cabal, situation is as you see.
18:46:30 <tcard> dcoutts: FYI: I just posted a message on Haskell-Cafe that relates to Cabal: http://www.haskell.org/pipermail/haskell-cafe/2014-April/113642.html
18:46:41 <MagBo_> https://en.wikipedia.org/wiki/Nix_Package_Manager
18:47:16 <wavewave> using cabal, build success is not guaranteed.
18:47:50 <dcoutts> tcard: on a minor point, yes of course it should do build-tools, it's just never been implemented
18:48:05 <wavewave> http://nixos.org
18:48:14 <tcard> dcoutts: ah :)
18:48:24 <dcoutts> tcard: as for the global vs minimal, yes I see it's an issue. One sometimes wants to start a sandbox with a very minimal set.
18:49:03 <dcoutts> tcard: the issue with making a minimal sandbox is simply knowing which packages should be in it, and we currently just base them all off of the global one.
18:49:23 <dcoutts> tcard: but that's not the only solution, it'd also be possible to copy a subset, if we knew what subset to copy
18:50:08 <dcoutts> tcard: and I have a somewhat cunning plan along these lines (related to some other ghc-pkg/cabal improvement work) which might make that rather easier
18:50:30 <tcard> dcoutts: In the haskell-platform source, the file packages/platform.packages defines the packages to install.  Perhaps a packages/platform-minimal.packages would be an easy way to install a minimal subset.
18:50:40 <tcard> dcoutts: Great! :)
18:51:35 <dcoutts> tcard: what I want is for ghc itself to come with multiple profiles, with one being the minimum (base + rts + deps), and that could be used as a basis for new envs
18:51:53 <wavewave> MagBo_ : if you allow /nix directory as your permission, then you can just untar http://hydra.nixos.org/build/10272842/download/1/nix-1.7-x86_64-linux.tar.bz2 (which can be found in http://hydra.nixos.org/release/nix/nix-1.7) and start nix. it contains everything to bootstrap.
18:53:07 <tcard> dcoutts: That would be very convenient.
18:53:41 <wavewave> MagBo_ : anyway, I will not advertise nix beyond this. I just want to say that it's very satisfying solution.
19:01:08 <meretrix> Is it possible to do something like "instance forall a . Show a => ToField a where toField = toField . show"?
19:02:05 <srhb> meretrix: You mean createa an instance of ToField where a is determined by it being showable?
19:02:18 <meretrix> srhb: Yes.
19:02:34 <meretrix> So all types of class Show become instances of ToField.
19:03:47 <srhb> meretrix: Yeah, you need instance contexts or something like that
19:05:49 <srhb> meretrix: FlexibleContexts
19:07:13 <srhb> No, FlexibleInstances is correct, I think.
19:07:21 <srhb> (I haven't actually used it)
19:08:10 <MagBo_> wavewave: thank you, I'm now a happy user as well. Reading the paper now and it's very good. Cheers!
19:08:43 <MagBo_> Still I wonder how on Earth do the packages magically get from hackage to nix, but I'll figure it out eventually.
19:08:55 <wavewave> MagBo_ : cool! and fast ;-)
19:09:09 <wavewave> MagBo_: they use cabal2nix
19:09:29 <wavewave> it creates nix expression from cabal automatically.
19:09:42 <MagBo_> wavewave: rage/frustration-driven development sometimes yields fast results.
19:09:50 <roconnor_> did MagBo_ just convert to nix in 20 minutes?
19:10:11 <albeit_> Is the best way to create an empty Data.Map to use "fromList []"?
19:10:24 <roconnor_> > Data.Map.empty
19:10:26 <lambdabot>  Not in scope: ‘Data.Map.empty’
19:10:28 <wavewave> cabal2nix works most of the time without modification. sometimes need to be adjusted though.
19:10:49 <albeit_> roconnor_: Thanks!
19:11:11 <bricksterhipster> HI GUYS
19:11:27 <wavewave> btw, I am now managing my own nix overlay of the softwares in my field.
19:12:08 <roconnor_> wow.  Most people moan about disk space and "static linking" for some reason.
19:12:46 <wavewave> roconnor_ : you mean as for nix?
19:13:00 <roconnor_> er right.
19:13:47 <MagBo_> roconnor_: given that I had very similar ideas when I was working at my last place, finding out that someone had actually implemented this was awesome.
19:14:20 <wavewave> MagBo_ : yeah. that's also how I started.
19:14:21 <MagBo_> besides, disk space. really?
19:14:50 <roconnor_> I like to tell Eelco that I would never have believed that NixOS would have been possible if it didn't exist.
19:15:49 <zq> does nix do binary distributions?
19:15:58 <MagBo_> guys, maybe we should go to #nothaskell because we're getting off the topic
19:16:07 <wavewave> I think some disciplined way of doing garbage collection is needed at least for managing storage.
19:16:13 <zq> #haskell-blah you mmean
19:16:21 <roconnor_> zq: nix supports binary deployment as a transparent cache operation.
19:16:25 <MagBo_> I used freenode-wide convention
19:16:30 <roconnor_> oops, MagBo_ is right
19:16:33 <MagBo_> but if it's -blah here
19:16:38 <wavewave> MagBo_ : yeah. probably #nixos is better.
19:16:58 <MagBo_> well, I wanted to ask you some generic off-topic questions
19:17:23 <wavewave> MagBo_ : Okay, i will be in #haskell-blah too
19:19:47 <carlosgaldino> is there someplace with more information about hoogle json api?
19:19:56 <carlosgaldino> more information than this: https://github.com/ndmitchell/hoogle/blob/master/docs/Developers.md
19:23:29 <sm> ghc is saying it can't find section '.data' when linking in a certain package, even after reinstalling that package. Would anyone remember how to fix this ?
19:23:56 <jle`> albeit_: you can also juse use mempty
19:24:00 <jle`> *just use
19:24:32 <jle`> and take advantage of the monoid instance
19:24:52 <srhb> Mmmmonoids.
19:26:10 <jle`> mono-id's
19:26:12 <jle`> oh
19:26:19 <jle`> is that why monoids are restricted categories
19:26:23 <jle`> they are categories with only one id
19:26:32 <jle`> instead of one for every type pair
19:26:36 <jle`> badum pshh
19:27:34 <srhb> :D
19:58:49 <haasn> I love restricted categories
19:58:51 <haasn> they are so easy
19:59:52 <dmwit> Check out my little toy.
19:59:56 <dmwit> https://github.com/dmwit/jitterbug/blob/master/jitterbug.hs
20:00:23 <dmwit> Compile with -threaded, then start whacking the space bar at a steady pace.
20:00:37 <dmwit> (Slower is a bit easier.)
20:00:55 <haasn> http://bpaste.net/show/204914/ :(
20:01:45 <dmwit> oh
20:01:50 <dmwit> You might need the gtk3 package.
20:01:53 <dmwit> I should set up a cabal file.
20:02:44 <haasn> Huh, I wonder why my package manager didn't pick it up as a version upgrade
20:04:59 <haasn> dmwit: Is there no namespace separation between gtk2 and gtk3? I'm wondering since your code didn't pick up an import error
20:05:13 <dmwit> correct =P
20:05:14 <haasn> Will having both gtk2 and gtk3 on my machine lead to lots of monads-tf-style “Ambiguous import” errors?
20:05:22 <dmwit> ...probably!
20:05:30 <haasn> ..including your package?
20:05:34 <haasn> program*
20:05:38 <dmwit> probably!
20:05:39 <haasn> Sounds wonderful!
20:05:45 <haasn> Another reason to write a .cabal file
20:05:51 * hackagebot azurify 0.4.0.2 - A simple library for accessing Azure blob storage  http://hackage.haskell.org/package/azurify-0.4.0.2 (GregWeber)
20:05:53 <dmwit> ghc-pkg hide gtk
20:05:56 <dmwit> ;-)
20:07:03 <haasn> Works now! Cute
20:07:24 <haasn> What am I seeing, cruel proof that humans are painfully inadequate metronomes?
20:07:27 <pharaun> i have a question, what's the best way to store user generated state? IE i want to do a plugin arch in which most plugin can be pure, but thers's occasional ones that need to store/persist state (one example would be "timestamp of startup") is there a good way of doing it in a generic manner
20:07:35 <dmwit> Yeah! =)
20:07:42 <dmwit> It's like a little rhythm trainer.
20:07:58 <pharaun> the most generic way i've seen is to maybe store it as a bytestring and do serialization to and from in the plugin (via say cereal/binary) ? is there a better way
20:08:13 <haasn> dmwit: the vertical line certainly looks very weird on my 60 Hz monitor
20:08:26 <dmwit> vertical line?
20:08:30 <dmwit> There should be no vertical lines.
20:08:41 <haasn> The one that moves vertically*
20:09:00 <dmwit> Oh, yeah, I'm not sure what to do about that.
20:09:05 <dmwit> I'm still thinking.
20:09:08 <dmwit> smear it out somehow
20:09:53 <no-n> @pl \x y -> [x,y]
20:09:53 <lambdabot> (. return) . (:)
20:10:51 <haasn> dmwit: oh, it measures deviation at every cycle, rather than cumulative deviation. Would support for the latter be possible to implement? What do the numbers on STDOUt represent? Milliseconds?
20:10:52 * hackagebot azurify 0.4.0.3 - A simple library for accessing Azure blob storage  http://hackage.haskell.org/package/azurify-0.4.0.3 (GregWeber)
20:11:28 <javac> @pl \x y -> x:y:xs
20:11:28 <lambdabot> (. (: xs)) . (:)
20:11:42 <dmwit> haasn: Cumulative deviation should be easy. It's on the TODO list for sure.
20:11:50 <dmwit> Numbers on STDOUT range from -1000 to 1000.
20:12:01 <dmwit> They're linear (the display is not, as I'm sure you noticed).
20:12:14 <dmwit> So -1000/1000 means you're exactly off-beat.
20:12:16 <dmwit> 0 means on-beat
20:12:28 <dmwit> -500 means a quarter of a beat early
20:12:40 <haasn> That makes sense
20:12:53 <haasn> I noticed they wrap around
20:12:59 <haasn> As my errors started to get more and more atrocious
20:15:09 <haasn> dmwit: Is there any real restriction on what kind of timescales it supports? It would be cool to hook this up to some sort of external signal and use it to visualize the variation in frequency of an arbitrary event
20:16:23 <dmwit> Well... at the moment it uses UTCTime/NominalDiffTime.
20:16:29 <dmwit> So whatever the limits on those types are, I guess.
20:16:55 <haasn> “It has a precision of 10^-12 s.”
20:17:06 <dmwit> ...but that says nothing about accuracy.
20:17:47 <haasn> Yeah, there would probably be a ton of factors influencing this on small scales, including but not limited to Gtk
20:17:55 <dmwit> right
20:18:05 <haasn> And below a certain threshold there would be no benefit from visualizing it since the screen wouldn't be able to keep up
20:18:07 <dmwit> You'd want to do the updates to the core data structures on a separate thread for sure.
20:18:24 <haasn> I was thinking about more infrequent events
20:18:50 <pharaun> surely no one has not had to deal with states in plugins ?
20:18:57 <haasn> Like using it to track the precession of a pendulum over the course of a day :)
20:19:15 <erisco> pharaun, what is a plugin?
20:21:09 <pharaun> basically a piece of say isolated code for most part, basically i want to make it so that anyone can write additional code/extension points, say its an irc bot for ex, one such plugin would be "listen for a !uptime message" it would need upon init store the start timestamp so it can calculate the uptime
20:21:34 <pharaun> i'm not sure if i'm just approaching it from the wrong angle?
20:21:51 <dmwit> haasn: Could be fun. For the moment it's intended to help people who haven't got a sense of a steady beat get trained in that.
20:22:01 <dmwit> So I'm focusing on very human timescales and UI.
20:22:12 <erisco> pharaun, no that is fine. you will need to expose an API for the plugins to use
20:22:30 <dmwit> I'm thinking next steps are to have some rhythm (rather than just a steady beat) and give some hinting with sound effects somehow.
20:23:17 <erisco> pharaun, you can provide persistence for the plugins by the API. what kind of data you accept and how you save it is up to you. an easy approach is to let the plugins do the serialisation themselves and they hand you byte strings
20:23:21 <erisco> which you can then save to disk
20:27:25 <pharaun> erisco: cool i was going to take the easy approach for now and have the center system manage the bytestring and let the plugin decide the types/stuff they want
20:27:50 <pharaun> and if i notice a specific pattern over and over i can probably extend the type i offer up for persistence
20:28:26 <pharaun> anyway great thanks erisco i wasn't for sure if that was a wrong approach or something
20:30:08 <haasn> dmwit: If you're interested in frequency drift and such: http://www.leapsecond.com/ten/clock-powers-of-ten-tvb.pdf http://leapsecond.com/nawcc2013/tvb-2013-Extreme-Amateur-Timekeeping.ppt.pdf
20:30:13 <haasn> Very amusing resources :)
20:34:28 <haasn> I was surprised by how accurate mains electricity is
20:34:35 <haasn> Oh, sorry, this should probably go into -blah
20:44:12 <dmwit> haasn: cool =)
20:45:43 <[swift]> i'm curious how many LOC is considered a "big" project in Haskell
20:46:05 <carter> more than 5,
20:46:09 <carter> or more than 1k
20:46:12 <carter> or more than 10k
20:46:14 <carter> or more than 100k
20:46:17 <carter> or 1mm
20:46:19 <carter> depends :)
20:46:25 <haasn> more than 5
20:46:26 <[swift]> you've really narrowed it down =)
20:46:34 <carter> big for whom?
20:46:42 <carter> i mean is ghc big?
20:46:53 <carter> its like > 50k loc
20:46:53 <erisco> [swift], for one person 1000+ lines starts to feel big I think
20:46:58 <[swift]> it seems reasonable to me to consider ghc big, although i have no idea how many lines of code it has
20:47:30 <dmwit> erisco: dunno about that
20:47:58 <dmwit> My latest hobby project is over 1000 lines and doesn't feel big to me. =P
20:48:14 <carter> whats the project?
20:48:20 <carter> you can do A LOT in 1k lines
20:48:26 <dmwit> https://github.com/dmwit/pulp
20:48:38 <dmwit> Parse LaTeX's output and grab just the interesting errors/warnings.
20:48:42 <carter> oh sweet
20:48:51 <dmwit> tagline: "Process your log with pulp and produce a better paper."
20:49:11 <erisco> well "feeling big" is relativistic. my point with 1000+ lines is that discards most toy code
20:49:21 <[swift]> dmwit: heh. that's pretty good
20:49:43 <[swift]> i guess to me, something like firefox or eclipse is a "big" project
20:50:05 <[swift]> firefox is probably unreasonable. that's a huge project
20:50:15 <erisco> dmwit, also I count <600 lines in Pulp.hs
20:50:22 <carter> [swift]: thats too big a bar
20:50:35 <carter> ff and chrome are some of the biggest software projects that are public in existence
20:50:45 <dmwit> erisco: pulp.hs, Config.hs, and Pulp.hs together come out to a bit more than 1000 lines, no?
20:50:54 <dmwit> wc tells me 41+322+588
20:51:00 <[swift]> carter: yeah, that's fair, particularly w.r.t. firefox. i can't think of a good example that's on the next tier, though. llvm?
20:51:18 <carter> cloc barfed on the ghc code base!
20:51:19 <dmwit> Oh, that's less than 1000, huh.
20:51:23 <dmwit> I am good at math!
20:51:50 <erisco> when you write that 1000th line you'll suddenly feel "wow, this is big now"
20:51:50 <dmwit> Okay, no wonder it doesn't feel big. ;-)
20:51:58 <dmwit> exactly, hehehe
20:52:00 <carter> somehow numerical-core has hit the 1k threshold  1147
20:52:03 <carter> to be exact
20:52:22 <carter> not sure how
20:52:26 <carter> but i've manage dto do tha
20:52:28 <carter> to do that
20:52:38 <carter> and all i've writen are some basic array algs so far
20:52:40 <carter> barely a scratch
20:52:40 <zq> @hoogle [Maybe a] -> a
20:52:41 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
20:52:41 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
20:52:41 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
20:52:48 <zq> blah
20:53:13 <zq> is there a function that takes [Maybe a] and returns me the x of the first (Just x) in the list?
20:53:33 <dmwit> :t ala First foldMap
20:53:34 <lambdabot> Foldable t => t (Maybe b) -> Unwrapped (First b)
20:53:34 <zq> wait
20:53:41 <zq> > Just 3 >>= Just 5
20:53:43 <lambdabot>  Couldn't match expected type ‘a0 -> Data.Maybe.Maybe b’
20:53:43 <lambdabot>              with actual type ‘Data.Maybe.Maybe a1’
20:53:48 <dmwit> > msum [Just 3, Just 5]
20:53:49 <lambdabot>  Just 3
20:53:55 <zq> well that was embarrassing
20:54:11 <zq> :t msum
20:54:12 <lambdabot> MonadPlus m => [m a] -> m a
20:54:14 <dmwit> (It's even in the results list you got from hoogle.)
20:54:33 <zq> > msum $ map Just [1..23]
20:54:34 <lambdabot>  Just 1
20:54:35 <erisco> @src msum
20:54:35 <lambdabot> msum =  foldr mplus mzero
20:54:50 <erisco> > Just 3 <|> Just 5
20:54:51 <lambdabot>  Just 3
20:54:53 <erisco> okay
20:55:10 <zq> :info (<|>)
20:55:24 <erisco> is there an msum for applicative?
20:55:45 <erisco> @hoogle (Applicative a) => [a] -> a
20:55:45 <lambdabot> Prelude head :: [a] -> a
20:55:45 <lambdabot> Data.List head :: [a] -> a
20:55:46 <lambdabot> Prelude last :: [a] -> a
20:55:47 <dmwit> > asum [Just 3, Just 5]
20:55:49 <lambdabot>  Not in scope: ‘asum’
20:55:49 <lambdabot>  Perhaps you meant one of these:
20:55:49 <lambdabot>    ‘F.asum’ (imported from Data.Foldable),
20:55:49 <lambdabot>    ‘sum’ (imported from Data.List),
20:55:51 <lambdabot>    ‘F.sum’ (imported from Data.Foldable)
20:55:54 <dmwit> > F.asum [Just 3, Just 5]
20:55:55 <lambdabot>  Just 3
20:55:58 <erisco> sorry for alternative
20:56:08 <dmwit> :t F.asum
20:56:09 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
20:56:16 <erisco> coolio
20:56:40 <dmwit> :t F.foldr (<|>) empty
20:56:41 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
20:56:50 <dmwit> almost the same implementation as msum =)
20:57:06 <erisco> it would be nice if Haskell had a way to express these algorithms in a more unified way
20:57:44 <dmwit> What do you mean?
20:57:46 <erisco> in fact the structure is similar to dodgey OO inheritance
20:58:06 <dmwit> I think the main reason we have such similar functions is historical, not technological.
20:58:34 <dmwit> Nobody wants to throw out the less-general functions in favor of the new hotness on grounds of backwards compatibility.
20:58:40 <erisco> hm, yes I suppose there is no reason that functions like msum have to exist
20:58:59 <MitchellSalad> just installed GHC 7.8.2 and now hdevtools hangs (i.e. hdevtools check Foo.hs), googled around a bit and saw someone complaining about the same problem some time last year, so I don't think it has to do with 7.8.2 itself, just some misconfiguration somewhere. has this happened to anyone else?
20:59:20 <erisco> other than Monad is not yet a superclass of Applicative
21:01:24 <johnw> MitchellSalad: have you tried running it yourself on the command-line with "-n", to see if it's trying to say something?
21:01:49 <erisco> dmwit, I was thinking more about MonadPlus but was conflated
21:02:00 <johnw> of course, try just "hdevtools check Foo.hs" first, to see if it can even typecheck files
21:02:04 <erisco> is MonadPlus necessary? why does it exist?
21:02:18 <johnw> MonadPlus is needed because Monoids have to be of kind *
21:02:29 <johnw> MonadPlus takes types of kind (* -> *)
21:02:41 <erisco> what is wrong with Monad + Alternative?
21:02:45 <MitchellSalad> johnw: what's -n? and "hdevtools check Foo.hs" is what's hanging
21:02:52 <johnw> ah, I see
21:03:32 <johnw> MitchellSalad: I'd recommend putting tracing statements into hdevtools, then, to track down where it's hanging.  If you bisect that way, it shouldn't take too long to track it down
21:03:55 <erisco> you see things like MonadPlus in OO inheritance hierarchies gone wrong where you start seeing a class for different combinations of base classes
21:04:02 <MitchellSalad> johnw: that's... annoying :(
21:04:15 <MitchellSalad> thanks though
21:04:50 <dmwit> erisco: http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
21:05:07 <dmwit> erisco: good explanation of a possible distinction between MonadPlus/Alternative
21:09:09 <jle`> MonadPlus
21:09:27 <jle`> Alternative does not attempt to define sensible laws over >>=
21:09:47 <jle`> MonadPlus doesn't really provide too definitive of laws either, but...if there were, that's where it'd be
21:10:07 <erisco> if the laws were different that would be a just reason
21:10:18 <jle`> Alternative can't comprehend >>=
21:10:24 <jle`> but
21:10:38 <jle`> i think that mplus and <|> should sensibly obey the same laws
21:11:00 * hackagebot svgcairo 0.12.5.2 - Binding to the libsvg-cairo library.  http://hackage.haskell.org/package/svgcairo-0.12.5.2 (HamishMackenzie)
21:11:07 <jle`> they are suppose dto be the same thing, right?
21:11:33 <jle`> i like to think of it as Alternative provides horizontal combination, MonadPlus provides vertical sequencing
21:12:13 <jle`> ideally we would not have mplus at all and just Alternative m => MonadZero m
21:12:34 <jle`> or whatever generalization of MonadPlus you would like
21:12:46 <erisco> well I would have thought (Monad m, Alternative m) => ...
21:12:55 <jle`> because really if you are only using mplus you would use <|>/alternative instad
21:13:00 <jle`> erisco: ah yeah, that :P
21:13:41 <erisco> and if that is too long then  type MonadPlus m = (Monad m, Alternative m)   or whatever the notation is
21:14:48 <jle`> hm
21:15:05 <jle`> i guess in this case the MonadPlus with <|> and mzero robbed...wouldn't really have any methods
21:15:30 <jle`> /functions/members
21:15:45 <jle`> so it only would be like a type synonym, yeah :|
21:15:50 <jle`> except with laws
21:15:52 <jle`> that's kinda weird
21:16:40 <erisco> since laws are not enforced by the language it may be reasonable to say that Monad and Alternative types must obey  empty >>= f = empty  and whatever other laws are desired
21:16:51 <jle`> i guess
21:16:55 <jle`> but where would you put that?
21:17:02 <jle`> who would own those laws?
21:17:07 <erisco> where do the laws exist now? in documentation
21:17:12 <jle`> but where in documentation
21:17:14 <jle`> in Monad?
21:17:19 <jle`> in Alternative?
21:17:26 <jle`> it's probably not a big deal :|
21:17:56 <dmwit> You would document the "type MonadPlus m = (...)" declaration, naturally.
21:17:57 <jle`> maybe just defining the type synonym and having the documentation there
21:18:00 <jle`> yeah
21:18:13 <erisco> I am still looking for a proof of  fmap f empty = empty  now that I am reminded :)
21:19:16 <dmwit> Oh, neat, haddock shows fixity these days.
21:20:16 <dmwit> erisco: I doubt there is one, except perhaps in the limited world of Haskell. Then parametricity might get you that.
21:20:33 <jle`> um
21:20:41 <jle`> well
21:20:47 <jle`> you can probably say that liftM f empty = empty
21:20:53 <jle`> with the default implementation of liftM
21:21:01 <dmwit> I doubt it.
21:21:11 <dmwit> As you said, Alternative knows nothing about (>>=).
21:21:14 <erisco> dmwit, if only I knew more about parametricity
21:21:15 <jle`> oh yeah
21:21:29 <dmwit> erisco: Wadler has a fine paper.
21:21:35 <dmwit> You'll know something about it for half an hour at least.
21:21:41 <erisco> dmwit, I probably have it
21:22:00 <dmwit> It's called "Theorems for Free!" if you have a way to search by title.
21:22:12 <dmwit> If not, Google Scholar has it.
21:22:30 <erisco> I have no counter-examples for fmap f empty = empty in Haskell so there ought to be some way to prove it
21:23:03 <erisco> if I cannot prove that then I cannot prove that my class instance obeys its laws so I am stuck
21:23:23 <jle`> erisco: what alternative laws are you trying to prove it from
21:23:34 <jle`> just that <|> and empty form a monoid?
21:23:54 <erisco> well I have the laws of Functor and the laws of Alternative
21:24:16 <jle`> what laws of alternative, i mean. just the monoid loaws w/ <|> and empty?
21:24:26 <erisco> yes
21:25:01 <jle`> if empty is the identity, can't it be said that there is only one?
21:25:04 <dmwit> Since none of those laws mention both fmap and an Alternative function, any theorem that mixes them is hopeless.
21:25:20 <erisco> dmwit, yup that was the start of my problem
21:25:21 <jle`> there is a unique empty for every Alternative?
21:25:47 <jle`> but oh yeah i see where the problem is
21:25:53 <dmwit> jle`: Certainly. But I shouldn't think fmap f need be a monoid homomorphism or anything like that.
21:26:11 <johnw> jle`: heh: http://www.proofwiki.org/wiki/Identity_of_Monoid_is_Unique
21:26:34 <johnw> ah, the link gives much more
21:28:31 <dmwit> Actually, "fmap f is a monoid homomorphism" strikes me as quite a natural law.
21:28:39 <dmwit> Now that I've said it out loud.
21:30:02 <dmwit> What is the right mailing list to push algebraic laws? Not libraries@, I guess. =P
21:30:27 <jle`> would that be strong enough to imply that fmap f (x <|> y) === fmap f x <|> fmap f y
21:30:42 <dmwit> Yes, it's that law plus fmap f empty = empty.
21:31:07 <erisco> is what strong enough? I am oblivious
21:31:19 <jle`> the that fmap f is a monoid homomorphism
21:31:28 <dmwit> erisco: I am proposing that the Alternative laws should be "it's a monoid + fmap f is a monoid homomorphism"
21:31:29 <erisco> another category theory thing?
21:31:42 <dmwit> No CT needed to say that.
21:31:51 <dmwit> Monoid homomorphisms were a thing long before CT came around.
21:33:35 <jle`> doesn't monoid homorphism already give you fmap f empty = empty
21:33:47 <srhb> Yes, it must map identity
21:34:11 <dmwit> Again, yes: "fmap f is a monoid homomorphism" means exactly "fmap f empty = empty" and "fmap f (x <|> y) = fmap f x <|> fmap f y".
21:34:18 <erisco> any good abstract algebra books? :)
21:34:19 <srhb> Right.
21:34:32 <jle`> oh, i thought you meant "monoid homorphism, *plus* fmap f empty = empty is required to imply that"
21:34:45 <jle`> you meant monoid homomorphism implies that *plus* fmap f empty = empty
21:34:49 <dmwit> yes
21:35:12 <zq> :t let k = [const 3] in k
21:35:13 <lambdabot> Num a => [b -> a]
21:35:19 <jle`> fmap f (x <|> y) === fmap f x <|> fmap f y sounds like reasonable behavior to go along with Alternative semantics
21:35:19 <srhb> Though isn't <|> a bit weird in this context?
21:35:26 <erisco> dmwit, well thanks that will allow me to finish the proof. hopefully I can add my improved data.tree library to hackage in the near future
21:35:35 <zq> uh
21:35:49 <erisco> though I will have to call it data.tree.somethingelse :)
21:35:54 <zq> let k = [const 3]; :t k yields [b -> Integer]
21:35:54 <srhb> Oh, we're talking about Alternative
21:36:09 <srhb> zq: Yes?
21:36:15 <srhb> > const 3 $ 2
21:36:16 <lambdabot>  3
21:36:21 <dmwit> zq: Welcome to the Monomorphism Restriction.
21:36:21 <srhb> > const 3 $ "foo"
21:36:23 <lambdabot>  3
21:36:25 <srhb> Oh
21:36:28 <zq> so i assume let bindings qualify as top eve
21:36:30 <zq> level*
21:36:37 <dmwit> zq: At least we don't have to explain Extended Defaulting to tell you what happened this time.
21:36:59 <zq> dmwit: i knew it was monorestrict, just didn't expect it to kick in with a let
21:37:08 <zq> "let-generalizations"
21:37:15 <jle`> is this in ghci or actual source code?
21:37:19 <zq> ghci
21:37:26 <jle`> upgrade to 7.8 :)
21:37:34 <zq> do elaborate
21:37:47 <jle`> in 7.8 NoMonorphismRestriction is set by default on ghci
21:37:53 <jle`> but you can also set it yourself if you aren't on 7.8
21:37:56 <jle`> in .ghci
21:38:26 <zq> monorestrict and i are pals; what i want to clarify is how "let binding = expr" counts as a top level
21:38:30 <pingu> Is there a better way of doing this?
21:38:33 <pingu> (foldr max 0 . map (foldr max 0)) [[1], [5]]
21:38:45 <jle`> zq: it happens for all bindings
21:39:01 <jle`> without explicitly general type signatures
21:39:10 <zq> jle`: not let in
21:39:21 <zq> which is an expression, technically
21:40:54 <erisco> pingu, what is your function supposed to do?
21:41:07 <pingu> find the max of a nested structure
21:41:17 <srhb> pingu: Flatten it first?
21:41:17 <erisco> :t maximum
21:41:18 <lambdabot> Ord a => [a] -> a
21:41:24 <erisco> :t maximum . concat
21:41:25 <lambdabot> Ord c => [[c]] -> c
21:41:32 <erisco> maybe that will work for you?
21:41:55 <pingu> maybe. I'm actually folding two hashmaps. Ill see if that'll work.
21:41:59 <dmwit> pingu: maximum . (0:) . concat
21:42:12 <erisco> > maximum []
21:42:13 <pingu> that's kind of neat.
21:42:14 <lambdabot>  *Exception: Prelude.maximum: empty list
21:42:27 <erisco> naughty non-total function... yeah do what dmwit says :)
21:42:31 <pingu> that's no good :\
21:42:41 <dmwit> If you don't like that, use maximum from monoid-extras.
21:42:41 <ruzu> HASKELL!
21:43:09 <dmwit> http://hackage.haskell.org/package/monoid-extras-0.3.3.2/docs/Data-Monoid-Inf.html#v:maximum
21:43:29 <erisco> hrm but then if you want to find the maximum of numbers you'd have to wrap in Sum yes?
21:43:38 <dmwit> what
21:43:55 <dmwit> Why would computing a maximum require Sum?
21:44:37 <erisco> oh this is a different module, sorry. I thought you were suggesting to fold using a monoid for Int
21:44:45 <dmwit> I am.
21:44:51 <dmwit> It's just that somebody else wrote the fold.
21:46:00 <erisco> ah okay. I suppose Sum would not make sense
21:47:01 <erisco> not sure what I was thinking :P
21:47:24 <athan> hey everyone, I'm having a little cabal trouble
21:47:46 <jle`> zq: what you wrote was not a let in
21:47:48 <athan> oh wait, I think i may have just thought of the solution... false alarm :)
21:47:51 <jle`> it was just a let
21:48:14 <jle`> it's slightly different in ghci than in normal
21:48:37 <jle`> but...i would think that let ... in ... activates DMR as well
21:48:52 <jle`> > let x = 5 in (x :: Integer, x :: Int)
21:48:53 <lambdabot>  (5,5)
21:48:56 <jle`> oops
21:48:58 <jle`> hm
21:49:02 <Griffin_> how do i generate a list of lists in haskell? e.g. [ [1,2,3], [1,2,3], [1,2,3] ] if I put max len 3
21:49:30 <dmwit> Griffin_: Just like that.
21:49:32 <jle`> Griffin_: well depending on what you make
21:49:37 <dmwit> > [ [1,2,3], [1,2,3], [1,2,3] ]
21:49:38 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
21:49:44 <erisco> > let f n = replicate n [1..n] in f 3
21:49:44 <Griffin_> rather
21:49:45 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
21:49:46 <Griffin_> a function
21:49:48 <Griffin_> to do so
21:50:17 <srhb> > let f n = replicate n [1..n] in f 4
21:50:18 <lambdabot>  [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
21:50:21 <Griffin_> ah
21:50:22 <Griffin_> ty
21:50:30 <srhb> Oh wow, lag
21:50:51 <erisco> but I made it to the patent office first :(
21:50:58 <srhb> erisco: *shakes fist*
21:51:14 <athan> why is cabal looking in dist/dist-sandbox-f851e10c/build/autogen for a module I'm trying to expose as a library?
21:51:31 <srhb> athan: Is it in other modules? Just guessing
21:51:34 <athan> Or do I misunderstand how you write a module / library?
21:51:37 <srhb> other-modules rather
21:51:37 <athan> nope
21:51:53 <athan> no, it's in "exposed-modules"
21:51:57 <srhb> Oh.
21:52:02 <dmwit> athan: Be sure to have a directory that all your code goes in so it isn't visible to ghc straight away. Then put an hs-source-dirs to reveal it again.
21:52:02 <zq> jle`: yes, i know
21:52:14 <athan> that's the field that's used for modules you write yourself, right?
21:52:35 <zq> jle`: no, the point of let-in in mindleyhilner is to allow for generalize
21:52:38 <athan> And not for just forwarding all of the exports of an already present one
21:52:40 <zq> generalization
21:53:14 <erisco> > let f = replicate <*> enumFromTo 1 in f 3
21:53:15 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
21:53:18 <dmwit> athan: But do show us your cabal file and we can give more targeted advice.
21:53:38 <zq> jle`: i wasn't exactly sure under which conditions MR would kick in
21:53:44 <erisco> @pl \n -> replicate n [1..n]
21:53:45 <lambdabot> ap replicate (enumFromTo 1)
21:53:52 <athan> okay! Here let me paste it. Thanks, dmwit
21:53:52 <dmwit> athan: You could look at https://github.com/dmwit/pulp/blob/master/pulp.cabal for a small-ish example of how to have a single package with both library and executable blocks.
21:54:25 <zq> jle`: i know MR occurs with top level bindings in a file, but i didn't think that let ... in ghci counts as a top level
21:54:35 <zq> since every op in ghci is inside one big IO
21:55:24 <athan> dmwit: http://lpaste.net/102704
21:55:37 <athan> ah okay!
21:55:39 <athan> thank you!
21:56:13 <dmwit> wait
21:56:19 <dmwit> Maybe I misunderstood the question.
21:56:24 <dmwit> Since there's no executable block here at all.
21:56:35 <athan> yeah :/
21:56:43 <athan> Sorry
21:57:14 <athan> Cabal isn't finding the source file that defines Network.Wai.Middleware.UAParser, even though it's simply in /src
21:57:32 <dmwit> Is it in a file name src/Network/Wai/Middleware/UAParser.hs?
21:57:37 <dmwit> .lhs is also acceptable
21:57:50 <dmwit> This is a GHC thing: module names and file names must match.
21:57:59 <athan> no it's not!!
21:58:06 <athan> wow
21:58:09 <athan> I had no idea
21:58:23 <athan> perfect, I'll fix that! Thank you!
21:58:46 <fragamus> hey I am realizing that symbolic manipulation of mathematical expressions (ala Mathematica) is essential to programming in general
21:59:08 <srhb> fragamus: Oh? :P
21:59:17 <srhb> What do you mean by essential?
21:59:17 <fragamus> I have a nasty integral and I integrate in Mathematica, and then through a series of automated steps I produce lovely haskell code
21:59:31 <fragamus> BUT… the integral is the true source code
21:59:39 <fragamus> not the emitted code
22:00:03 <erisco> code generation
22:00:24 <fragamus> They are making a language called Wolfram and I kind of think we should be growing haskell to be able to do the same kind of manipulation
22:01:02 <dmwit> CA is one of those fields you can dump a couple hundred man-years into and still have a ways to go.
22:01:09 <dmwit> Which is why Mathematica costs $1000.
22:01:16 <fragamus> yeah
22:02:36 <fragamus> Well at the very least we should be pouring some man years into making the kind of transformation I'm doing a more commonplace thing… I want my source code to be the integral
22:02:53 <fragamus> I would prefer that it wasn't in Mathematica
22:03:06 <dmwit> The lovely thing about open source is that "Somebody should..." is actually code for "I should...".
22:03:16 <dmwit> So let us know in a few years how those man-years you spent on it turned out! =)
22:03:26 <erisco> thanks for volunterring fragamus :)
22:03:28 <fragamus> I don't want a company to take over providing the language of choice
22:03:36 <fragamus> : P
22:04:25 <fragamus> well ok
22:04:57 <fragamus> so what would you prefer- a bridge for taking mathematica expressions and emitting haskell expressions OR
22:05:16 <fragamus> me spending a couple of hundred man years reinventing mathematica
22:05:22 <srhb> The latter.
22:05:24 <srhb> :P
22:05:30 <fragamus> shit!
22:05:39 <dmwit> You stepped right into that one. =P
22:06:18 <fragamus> there are some open source symbolic math packages but they all suck
22:07:01 <fragamus> I hope you guys see what I mean about wanting my source code to be the Integral and not the emitted haskell code
22:07:19 <fragamus> It's just the right way to do things
22:07:37 <erisco> fragamus, I dunno some people would disagree it seems
22:07:43 <fragamus> WHO
22:08:04 <fragamus> the emitted code is freaky looking
22:08:15 <fragamus> and no human alive understands it
22:08:27 <erisco> fragamus, well there are various approaches you can take. what you are suggesting sounds like a separate language + a compiler which makes building code a bit more complicated
22:08:51 <erisco> fragamus, so for that reason a DSL hosted in the target language can be more appealing
22:09:11 <erisco> consider Parsec vs Happy as an example
22:09:17 <fragamus> yes but we need all of the identities and algorithms for combining them
22:10:06 <fragamus> There is a shit load of math knowledge that is in Mathematica, and it is fundamentally the right abstraction to code at that level
22:10:23 <fragamus> and then let the system crunch that down to some haskell
22:10:54 <fragamus> I just dont want it to be Mathematica
22:16:09 * hackagebot azurify 0.4.0.4 - A simple library for accessing Azure blob storage  http://hackage.haskell.org/package/azurify-0.4.0.4 (GregWeber)
22:17:12 <fragamus> i am all for a DSL but… where will we find a decent symbolic math system that's free
22:18:20 <dmwit> I don't think srhb was serious.
22:19:42 <fragamus> i just want haskell to be the language I use, but *does anybody* see the point that high level math expressions should be source code
22:20:07 <dmwit> fragamus, everyone in here is in favor of bringing the level of discourse up. Even with the machine.
22:20:14 <dmwit> You don't need to sell us on abstraction.
22:20:54 <fragamus> ok
22:21:35 <fragamus> Well I just want to suggest that we discuss this as a group to figure out what to do
22:22:10 <fragamus> it's more than poor fragamus can handle on his own
22:24:55 <ivanm> so I've just built 7.8.2 and am trying to upgrade all the packages I've installed, but for some I get errors like this: Setup: Error: Could not find module: Network.Socks5 with any suffix:
22:24:56 <ivanm> ["dyn_hi"] in the search path: ["dist/build"]
22:25:03 <ivanm> what do I have to do to fix this?
22:26:35 <luite> ivanm: what version of cabal-install are you running?
22:26:47 <ivanm> this isn't cabal-install
22:26:59 <ivanm> this is the system packages built using runhaskell Setup.hs
22:37:03 <erisco> O-justification is not a monad
22:37:31 <erisco> funny to see this pattern in a philosophy paper
22:38:33 * ivanm grumbles about internet playing up
22:38:55 <ivanm> luite: did you respond again after asking what version of cabal-install I was running? I didn't get any more messages after that :/
22:39:13 <luite> ivanm: no
22:39:27 <ivanm> OK
22:39:50 <ivanm> does anyone know what I have to do to deal with this?  All the mentions I found online were for either windows or cabal-install :s
22:42:44 <erisco> ivanm, I do not know =\ when I had cabal troubles I had to look at the cabal directories and files to get any sense of what was wrong
22:43:31 <erisco> ivanm, I would start looking for where Network.Socks5 might be
22:43:32 <ivanm> except this appears to be a GHC problem, not a Cabal one :s
22:44:31 <ivanm> I know which package it is
22:44:41 <ivanm> I have at least two packages which fail with this problem
22:52:36 <ivanm> the issue specifically seems to only be a problem when installing
23:14:16 <ivanm> apparently this isn't a new problem: http://www.haskell.org/pipermail/glasgow-haskell-users/2014-April/024879.html
23:26:04 <killy9999> is there a conference fee for participation in ICFP and Haskell Symposium?
23:26:19 <killy9999> Can't seem to find any info about it on official webpage
23:26:42 <killy9999> But it seems unusual that there would be no conference fee
23:27:45 <bergmark> killy9999: there is
23:29:30 <killy9999> bergmark: can you give me any link to official info about it?
23:30:09 <bergmark> killy9999: i couldn't find it either ;-(
23:30:17 <killy9999> right
23:30:34 <killy9999> can you at least estimate how much is that?
23:30:36 <killy9999> urgh...
23:30:42 * killy9999 needs to go afk
23:30:48 <killy9999> bbl
23:32:23 <bergmark> killy9999: i think it's somewhere in the 500-1000 euro range
23:56:24 * hackagebot monad-unify 0.2.2 - Generic first-order unification  http://hackage.haskell.org/package/monad-unify-0.2.2 (PhilFreeman)
