00:04:41 <carter> ok
00:04:43 <carter> time to crash
00:04:45 <carter> happy hacking
00:04:51 <carter> and merry type checking
00:14:07 <joelteon> @pl fix (\f g x -> yield x >> f g (g x))
00:14:07 <lambdabot> fix ((liftM2 (>>) yield .) . ((.) =<<))
00:14:14 <joelteon> That sucks
00:20:38 <startling> @pl \f g x -> f g (g x)
00:20:38 <lambdabot> ((.) =<<)
00:22:10 <copumpkin> that's kinda cute
00:22:19 <no-n> I need a copy of The Elements of Computing Systems.
00:24:53 <startling> no-n: that sounds like "Code"
00:29:27 <mgccl> so I'm trying to implement a matrix class. a matrix is just (Int->Int->a, Int, Int) where first gives one a function to access the elements, and the remaining two are the number of rows and cols. I want to implement transposition as transposition (f,n,m) = (flip f, n, m). the question would be, after say k transpositions, does the access time of the new matrix become O(k)? or flip flip f gets optimized away to f?
00:33:03 <Jafet> You can arrange for that to happen: MatrixFun a = Direct (Int -> Int -> a) | Flip (MatrixFun a); simplify (Flip (Flip f)) = simplify f
00:34:50 <startling> mgccl: it depends.
00:38:48 <mgccl> Jafet: thanks, this is definitely one way to do it.
00:39:21 <Jafet> See also repa: http://hackage.haskell.org/package/repa-3.2.3.3/docs/Data-Array-Repa.html
00:41:05 <mgccl> startling: so I defined t = flip applied 100000 times to (+), and I find only the first time using t, it uses up a lot of time, afterwards it takes the same amount of time as (+). so I'm curious do you have a example where flip's are not optimized away.
00:41:53 <haasn> The efficiency of function transformations like that really confuses me
00:41:56 <haasn> especially the DList stuff
00:42:12 <startling> mgccl, the example you just gave is one where the flips are not optimized away, I think
00:42:20 <haasn> I mean, it's clear to me that each individual operation is ‚ÄúO(1)‚Äù, but how the heck does that scale into an actual implementation?
00:42:31 <tibbe> You know lens is too big when it triggers a library stripping bug due to too many files named Lens. ;)
00:42:33 <startling> I think sharing is another thing here.
00:43:22 <startling> :t natural
00:43:23 <lambdabot> Not in scope: ‚Äònatural‚Äô
00:43:30 <startling> :t Data.Numerica.Natural.natural
00:43:31 <lambdabot> Not in scope: ‚ÄòData.Numerica.Natural.natural‚Äô
00:43:36 <startling> :t Data.Numeric.Natural.natural
00:43:37 <lambdabot> Not in scope: ‚ÄòData.Numeric.Natural.natural‚Äô
00:43:39 <startling> :/
00:44:04 <Jafet> mgccl: check GHC base definition of flip, it is probably defined as "flip f = \x y -> ..."
00:44:21 <Jafet> This means that "flip ... flip (+)" can be evaluated before applying it to any arguments
00:44:39 <startling> yeah, that's a good as well.
00:44:46 <startling> a good point, too.
00:46:04 <augur> the pi calculus is awful
00:46:06 <augur> just FYI
00:47:43 <Taneb> Is there a calculus for EVERY greek letter!?
00:47:46 <mgccl> Jafet: the definition says flip f x y =  f y x, is that different from flip f = \x y -> f y x definition?
00:47:53 <augur> Taneb: yes
00:48:09 <shachaf> Those definitions can be different in some ways.
00:48:16 <augur> Taneb: probably not, tho, since alpha, beta, and eta have meanings in the various LCs
00:48:26 <Jafet> mgccl: when talking about performance, yes.
00:48:34 <shachaf> For example, for inlining (GHC will generally only inline a function if it's applied to all its arguments, which is three in the first case and one in the second).
00:49:52 <augur> Taneb: the pi calc is a concurrent computation calculus, fwiw
00:50:02 <Jafet> Well, I don't know how ghc actually evaluates nested flips.
00:50:11 <augur> pi presumably by conflation of parallelism and concurrency (which arent the same thing!)
00:50:32 <mgccl> oh god... :( it's so hard to predict how fast my code will be...
00:50:48 <augur> mgccl: in haskell, yes. performance is usually a pain in the but. itll be fast tho!
00:51:13 <augur> laziness is the source of the mystery
00:51:22 <shachaf> tibbe: Good bug.
00:51:37 <tibbe> shachaf: I thought so too. :)
00:51:41 <startling> mgccl, you can look at the "core" that GHC generates
00:52:07 <Cale> mgccl: There's lots of good information in Simon Marlow's newish book on concurrency and parallelism on understanding the performance of Haskell code which is good even in the uniprocessor case.
00:52:57 <augur> for all interesting:   what effect would there be in changing this:   foo :: (C, D) => A ; foo = blah   into a new construction   foo :: A ; foo = require (C, D) in blah
00:53:43 <Jafet> Doesn't ghc have partial type signatures already?
00:54:06 <augur> oh hey Cale
00:54:11 <augur> fancy seeing you here!
00:54:20 <shachaf> Every function type is partial, clearly.
00:54:48 <mgccl> Cale: cool, I shall check that out.
00:58:08 <haasn> shachaf: Is there a difference other than GHC internal behavior? Something to do with _|_?
00:58:26 <shachaf> Semantically they are the same.
00:58:47 <shachaf> foo x y z = ... means foo = \x y z -> ... which means foo = \x -> \y -> \z -> ...
00:58:50 <shachaf> Or something along those lines.
00:59:23 <tibbe> If someone can help me test a new Cabal release candidate on Windows, I can make the Cabal 1.20 release today.
00:59:25 <tibbe> Any takers?
00:59:28 <shachaf> Of course, you could come up with things to put in the ... that break that translation. But not expressions, I think. :-)
00:59:44 <Jafet> > let f () () = () in f undefined `seq` ()
00:59:46 <lambdabot>  ()
00:59:52 <Jafet> > let f () = \() -> () in f undefined `seq` ()
00:59:54 <lambdabot>  *Exception: Prelude.undefined
01:00:21 <Axman6> I thought foo x = ... and foo = \x -> ... could behave differently but can't remember how
01:00:26 <shachaf> Yes, it's also different when you're pattern-matching, of course. x y z were specifically variables in my example.
01:00:34 <shachaf> Axman6: Well, there's also the monomorphism restriction.
01:02:40 <haasn> Oh, I think the monomorphism restriction was also what made me suspicious that there could be a difference
01:03:41 <shachaf> @quote ::.*Int.*::.*Int
01:03:41 <lambdabot> shachaf says: (\l -> Data.Array.IArray.elems $ runST $ do { arr <- newListArray (0,length l - 1) l :: ST s (STArray s Int Int); (`fix` 0) $ \loop i -> do { v <- readArray arr i; writeArray arr i (v^2); when (i < (length l - 1)) (loop (i+1))}; iarr <- unsafeFreeze arr; return (iarr :: Array Int Int) })  That's the best way to square all the
01:03:41 <lambdabot> elements of a list in Haskell, by far.
01:03:44 <shachaf> Ugh.
01:03:48 <shachaf> Why is that a quote?
01:03:54 <shachaf> @quote cmccann ::.*Int.*::.*Int
01:03:54 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
01:04:35 <haasn> According to the haskell report f p1 p2 p3 = .. is indeed semantically equivalent to f = \x y z -> case (x,y,z) of (p1,p2,p3) -> ...
01:05:15 <haasn> I wonder why this ‚Äúsemantically equivalent‚Äù doesn't include the monomorphism restriction. Isn't that also part of Haskell's semantics?
01:05:28 <haasn> Or is that only considered part of the syntax?
01:05:30 <shachaf> Given that they have the same type.
01:05:32 <Jafet> mgccl: by the way, transpositions are usually done eagerly, they are not deferred. Transposition is expensive.
01:07:24 <haasn> Wow, I've never seen that example of type signature scoping before
01:07:36 <haasn> I'd figure ‚Äúa :: b :: c‚Äù is ‚Äú(a :: b) :: c‚Äù
01:07:50 <haasn> > (1 :: Int) :: Int
01:07:52 <lambdabot>  1
01:09:24 <shachaf> > Just $ 5 :: Int
01:09:26 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
01:09:26 <lambdabot>              with actual type ‚ÄòData.Maybe.Maybe s0‚Äô
01:09:27 <shachaf> > Just $ do 5 :: Int
01:09:28 <lambdabot>  Just 5
01:09:31 <cmccann> type signatures apply to whatever complete expression is to the left of ::. lambdas extend as far to the right as syntactically allowed. this has strange consequences given sufficiently pathological syntax.
01:09:41 <haasn> > Just $ do 5 :: Int :: Maybe Int
01:09:42 <lambdabot>  Just 5
01:09:48 <shachaf> whoa, cmccann
01:09:59 <cmccann> whoa, shachaf
01:10:22 <mgccl> Jafet: ahh, that breaks the algorithm I'm implementing, I need to make sure transposition can be done in constant time... (that's why I just consider flip the accessor function)
01:10:51 <haasn> cmccann: I don't understand from those rules why the lambda in (\x -> y :: a :: b) doesn't scope all the way to the )
01:10:57 <Jafet> For larger arrays, transposition is still constant time, but the constant is terrible.
01:11:37 <haasn> > 1 :: Int :: Int
01:11:40 <lambdabot>  <hint>:1:10: parse error on input ‚Äò::‚Äô
01:11:43 <haasn> Oh, now I get it
01:11:44 <shachaf> Transposition via this kind of flip trick is probably pretty bad for your cache. Then again, maybe your matrix representation isn't good for your cache in the first place.
01:11:53 <haasn> ‚Äú1 :: Int‚Äù is not something that's valid on the left of a ::
01:12:07 <haasn> On its own, at least
01:12:19 <cmccann> haasn: which cuts off parsing the lambda
01:12:25 <haasn> That makes sense
01:12:32 <cmccann> which means the next type signature applies to the lambda as a whole
01:12:57 <cmccann> repeat again to get the monstrosity shachaf asked lambdabot for
01:13:40 <haasn> > Just if True then () else ()
01:13:42 <lambdabot>  <hint>:1:6: parse error on input ‚Äòif‚Äô
01:15:34 <cmccann> haasn: fwiw I came up with the expression in the lambdabot quote after reading the language grammar and thinking about how to misuse the parsing rules
01:15:46 <cmccann> I can't imagine anyone ever writing code like that in practice
01:16:27 <haasn> http://lpaste.net/102979
01:16:33 <haasn> ‚ÄúWarning: use camelCase‚Äù thanks, hlint
01:17:01 <Axman6> yeah, stop being wrong, use camelCase
01:18:00 <mgccl> shachaf: True. In my application, the values of the matrix are generated on the fly(just some function on a pair of integers), thus this is not a problem.
01:18:22 <haasn> Apparently, that evaluates to " let let let let let let let let let let let let"
01:23:10 <skypers> @hoogle maybe (return ())
01:23:11 <lambdabot> Did you mean: :: Maybe AccumOp
01:23:11 <lambdabot> Data.Functor.Compose getCompose :: Compose f g a -> f (g a)
01:23:11 <lambdabot> System.Mem performGC :: IO ()
01:23:27 <skypers> there‚Äôs no liftJust?
01:23:38 <startling> skypers: what's liftJust?
01:23:58 <skypers> something that will apply a monadic function on a Maybe a only if isJust x
01:24:13 <skypers> maybe with liftBase
01:24:25 <startling> > \f -> maybe f (return ())
01:24:27 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
01:24:27 <lambdabot>    arising from a use of ‚ÄòM6489959451587129049473.show_M6489959451587129049473‚Äô
01:24:27 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
01:24:27 <lambdabot>  Note: there are several potential instances:
01:24:27 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
01:24:29 <startling> :t \f -> maybe f (return ())
01:24:30 <lambdabot> () -> Maybe a -> ()
01:24:37 <startling> er
01:24:37 <skypers> no
01:24:40 <skypers> something like
01:24:46 <startling> :t maybe (return ())
01:24:48 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
01:24:59 <haasn> skypers: I don't understand; start with the type signature
01:25:18 <skypers> > let a = Just 3 in when (isJust a) $ print (fromJust a)
01:25:19 <lambdabot>  <IO ()>
01:25:22 <skypers> something like that
01:25:38 <skypers> or
01:25:42 <startling> :t traverse print
01:25:43 <lambdabot> (Traversable t, Show a) => t a -> IO (t ())
01:25:48 <startling> :t traverse_ print
01:25:49 <lambdabot>     Not in scope: ‚Äòtraverse_‚Äô
01:25:49 <lambdabot>     Perhaps you meant one of these:
01:25:49 <lambdabot>       ‚ÄòF.traverse_‚Äô (imported from Data.Foldable),
01:25:49 <skypers> oh yeah
01:25:53 <skypers> mapM_
01:25:56 <startling> :t F.traverse_ print
01:25:57 <lambdabot> (Foldable t, Show a) => t a -> IO ()
01:25:57 <skypers> thank you ;)
01:26:06 <startling> :t F.traverse_ print (Just 3)
01:26:08 <lambdabot> IO ()
01:26:08 <skypers> > mapM print Nothing
01:26:09 <lambdabot>  Couldn't match expected type ‚Äò[a0]‚Äô
01:26:10 <lambdabot>              with actual type ‚ÄòData.Maybe.Maybe a1‚Äô
01:26:20 <startling> skypers, mapM only works for lists.
01:26:29 <skypers> > F.mapM print Nothing
01:26:30 <lambdabot>  Not in scope: ‚ÄòF.mapM‚Äô
01:26:30 <lambdabot>  Perhaps you meant one of these:
01:26:30 <lambdabot>    ‚ÄòT.mapM‚Äô (imported from Data.Traversable),
01:26:30 <lambdabot>    ‚ÄòF.mapM_‚Äô (imported from Data.Foldable),
01:26:30 <lambdabot>    ‚ÄòM.map‚Äô (imported from Data.Map)
01:26:36 <startling> ah
01:26:38 <skypers> > F.mapM_ print Nothing
01:26:40 <lambdabot>  <IO ()>
01:26:48 <skypers> but yeah, I also prefer traverse
01:26:55 <skypers> btw, talking about foldable and traversal
01:26:59 <startling> there's no real reason to use those unless you don't have Applicative
01:27:04 <startling> (which you should)
01:27:16 <skypers> ?
01:27:21 <skypers> I have a (Maybe Something)
01:27:24 <startling> :t traverse
01:27:25 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
01:27:28 <skypers> and I want to perform some IO over it
01:27:31 <startling> :t T.mapM
01:27:32 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
01:27:36 <skypers> mapM_ / traverse sounds great for that
01:27:48 <startling> skypers, sure. I mean the type of the action you're applying
01:28:04 <skypers> btw, why Foldable has _ functions where Traversal has return capturing?
01:28:09 <skypers> I thought it was the opposite
01:28:19 <skypers> fold a value is accumulating something along
01:28:29 <skypers> then mapM should be in Foldable
01:28:30 <skypers> right?
01:28:42 <startling> skypers, a traversal lets you rebuild the structure with the results of the applicative action
01:28:42 <johnw> mapM is in Traversable
01:29:02 <skypers> johnw: I know and I wonder why.
01:29:05 <johnw> Foldable has _ functions, for folding a container to ()
01:29:06 <startling> skypers, a fold lets you collect results, but doesn't let you rebuild the structure in-place
01:29:15 <startling> johnw, we've already established that.
01:29:22 <skypers> I did, actually :)
01:29:27 <skypers> a few lines above
01:29:28 <skypers> the thing is
01:29:35 <skypers> if you consider the list fold
01:29:37 <skypers> like
01:29:38 <skypers> foldl
01:29:50 <skypers> it doesn‚Äôt discard the result
01:29:55 <johnw> but it could
01:29:56 <johnw> map couldn't
01:30:08 <johnw> that's why you can implement map with fold, but not vice-versa
01:30:09 <skypers> so why Foldable provides *only* discarding function?
01:30:15 <johnw> ah, I see
01:30:15 <skypers> why isn‚Äôt mapM in Foldable as well?
01:30:27 <johnw> Foldable also provides a general 'foldr'
01:30:35 <skypers> in the typeclass yes
01:30:37 <johnw> the _ variants are just common special cases
01:30:37 <skypers> but hm
01:30:43 <startling> skypers, you're confusing two notions of discarding, I think
01:30:51 <startling> folds discard *structure*.
01:30:57 <skypers> I think it‚Äôs weird having mapM and mapM_ in different modules
01:31:14 <skypers> startling: I don‚Äôt really get your point yeah
01:31:17 <johnw> folds don't have to discard structure, they are just not bound to preserve it
01:31:25 <startling> skypers, why? you can do mapM_ with only Foldable but you can't do mapM unless you have Traversable
01:31:27 <shachaf> The class Foldable is almost Tolistable, with method toList :: Foldable t => t a -> [a]
01:31:36 <skypers> startling: why?!
01:31:50 <startling> skypers, because folds don't rebuild the structure
01:31:50 <skypers> why isn‚Äôt it possible to mapM a Foldable without Traversal?
01:32:00 <startling> :t foldMap
01:32:02 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
01:32:20 <startling> skypers, ^ this doesn't give you a way to rebuild the t in general
01:32:25 <skypers> :t F.mapM_
01:32:27 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
01:32:29 <shachaf> That's (almost) all it is. The fancy monoid business is nearly an implementation detail.
01:32:33 <startling> :t T.mapM
01:32:33 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
01:32:35 <skypers> :t T.mapM
01:32:36 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
01:32:37 <skypers> ok
01:32:39 <skypers> I got it
01:32:57 <skypers> so I misunderstood structure discarding and value discarding
01:32:57 <startling> ^ that puts the result back in the structure and gives you the structure back
01:33:01 <startling> yeah.
01:33:10 <skypers> :t traverse
01:33:11 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
01:33:16 <startling> skypers: writing some Foldable and Traversable instances by hand might be useful.
01:33:24 <startling> and re-deriving the combinator
01:33:25 <skypers> :t traverse print $ Just 4
01:33:26 <startling> s
01:33:26 <lambdabot> IO (Maybe ())
01:33:45 <startling> skypers, ^ that gives you a "Just ()", since print gives you a ()
01:33:57 <shachaf> "combinator" meaning "function". :-)
01:34:00 <skypers> yeah
01:34:10 <skypers> :t traverse_ print $ Just 4
01:34:11 <lambdabot>     Not in scope: ‚Äòtraverse_‚Äô
01:34:11 <lambdabot>     Perhaps you meant one of these:
01:34:11 <lambdabot>       ‚ÄòF.traverse_‚Äô (imported from Data.Foldable),
01:34:17 <skypers> :t F.traverse_ print $ Just 4
01:34:18 <lambdabot> IO ()
01:34:18 <startling> shachaf, the trivial combinators. :)
01:34:22 <skypers> oooook
01:34:29 <skypers> I got the difference :)
01:34:43 <skypers> btw, isn‚Äôt traverse_ = mapM_?
01:34:47 <startling> I guess I think of functions relying on typeclass methods as combinators.
01:34:48 <skypers> F.mapM_
01:34:51 <startling> skypers: it's close.
01:34:54 <shachaf> ?
01:35:00 <skypers> :t F.mapM_
01:35:00 <startling> skypers: mapM_ has a silly Monad constraint
01:35:01 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
01:35:04 <skypers> :t F.traverse_
01:35:04 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
01:35:11 <shachaf> I guess that's yet another meaning. Oh well. "combinator" can mean anything.
01:35:14 <startling> skypers: where all you need is Applicative
01:35:14 <skypers> ok
01:35:27 <shachaf> Anyway, properly understanding foldMap and why that's the right method for Foldable involves a lot more understanding than just understanding what Foldable gives you, which is toList.
01:35:39 <skypers> it‚Äôs exactly the same thing, but on a different level of abstraction
01:35:45 <startling> skypers, no.
01:35:51 * soclialita please helpme please join new webchat page www.ChatSocial.org please 2 clisk http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org
01:36:02 <startling> skypers, it's exactly the same thing, but one has a spurious constraint if Applicative is regarded as a superclass of Monad
01:36:05 <skypers> shachaf: yeah I know foldMap
01:36:13 <skypers> I wrote some instances implementing that
01:36:27 <johnw> skypers: I just tried to implement mapM using only Foldable.  What Foldable doesn't give me is a way to create a new structure equivalent in "shape" to the input
01:36:30 <skypers> startling: and what if you have a Monad but not an Applicative?
01:36:38 <johnw> that's something Traversable does in its instance
01:36:43 <skypers> johnw: yeah yeah I got that :)
01:36:52 <skypers> you‚Äôd need the t in the result
01:36:54 <startling> skypers: you shouldn't.
01:37:02 <skypers> ok :)
01:37:09 <skypers> thank you for your precious explanations :)
01:37:35 <startling> (if you do, you can just write instance Applicative X where pure = return; (<*>) = Control.Monad.ap;
01:37:53 <skypers> I‚Äôm gonna pee right now, I‚Äôm at a demoparty and too much beer ahah (Revision 2014)
01:37:56 <skypers> sure startling :)
01:38:53 <haasn> skypers: won't be possible in GHC 7.10!
01:39:03 <startling> ^ that too
01:39:45 <haasn> I wonder what will actually happen when that lands, are the Monad versions going to get DEPRECATED notices?
01:39:58 <haasn> Will this cause compile failures with -Werror?
01:40:12 <startling> haasn, 7.8. warns iirc
01:40:23 <startling> haasn, so 7.10 will be an error
01:40:56 <startling> oh, I see what you mean.
01:41:05 <startling> haasn: I wish. I doubt it for some reason, though.
01:41:22 <startling> (I did this to Idris about a year ago. It felt really good).
01:41:28 <BurnIrl> How do you compile Haskell?
01:41:42 <haasn> BurnIrl: using a Haskell compiler, eg. GHC
02:01:57 * hackagebot lio-simple 0.0.2.2 - LIO support for the Simple web framework  http://hackage.haskell.org/package/lio-simple-0.0.2.2 (DeianStefan)
02:03:09 <skypers> 10:37 < haasn> skypers: won't be possible in GHC 7.10!
02:03:15 <skypers> what won‚Äôt be possible in 7.10?
02:04:01 <startling> skypers, having Monads that aren't Applicatives
02:04:01 <startling> i.e. it'll be an error
02:13:09 <skypers> oh
02:13:20 <skypers> 11:02 < startling> skypers, having Monads that aren't Applicatives
02:13:20 <skypers> 11:02 < startling> i.e. it'll be an error
02:13:41 <skypers> so Monad will have to have an Applicative superclass constraint?
02:13:58 <startling> yes.
02:14:14 <skypers> ok
02:14:42 <startling> the only reason it doesn't already is that Monad was invented before Applicative, and people prefer not to break old code.
02:54:24 <BurnIrl> Hello
03:04:02 <skypers> hey
03:04:23 <skypers> is it considered orphan instances having, in the same package, the instances declaration in a separate module?
03:06:11 <Cale> skypers: Orphan instances are instances which are neither defined in the module where the class is defined, nor in the module where the data type is defined.
03:07:39 <Cale> skypers: When an orphan instance exists, say in module A, someone writing module B can simply not import module A and define their own instance of the class for that type, thereby making code which imports module A incompatible with code which imports module B
03:07:41 <skypers> ok
03:07:49 <skypers> I know the issue of orphan instance
03:07:55 <skypers> :)
03:08:28 <skypers> does -W -Wall shows them?
03:10:18 <Cale> skypers: I think they should be reported by default even with no flags, but if not, I think the flag is -fwarn-orphan-instances
03:10:35 <skypers> thank you Cale <3
03:10:50 <Cale> oh, nope, it's -fwarn-orphans
03:17:03 * hackagebot azure-acs 0.0.1.0 - Windows Azure ACS  http://hackage.haskell.org/package/azure-acs-0.0.1.0 (kapilash)
03:23:01 <Maior> I assume I'm missing something obvious - when I run `cabal haddock` in https://github.com/doismellburning/hess/tree/feature/haddock I get `haddock: No input file(s).` - how am I supposed to tell haddock about my src dir?
03:26:00 <Maior> ...helps if I read `haddock --help` rather than `cabal haddock --help`, though any recommendations of "standard ways" would be good please
03:32:04 * hackagebot Cabal 1.20.0.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.20.0.0 (JohanTibell)
03:33:38 * hackagebot cabal-install 1.20.0.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.20.0.0 (JohanTibell)
03:42:45 <Phillemann> Hmmm, why is Functor in Data.Functor but Monad is in Control.Monad?
03:43:57 <startling> Phillemann, it's largely arbitrary
03:44:22 <startling> Data.Function is the weirdest imo
03:44:25 <Jafet> The same reason that Data.Functor but Control.Applicative
03:50:39 <johnw> nice, cabal-install 1.20!
03:51:15 <simukis_> Phillemann: I was wondering about it too and conclusion I came to after some thinking was that Functor, Monoid, Function all abstract over some kind of data, while Monad or Applicative are coined to control the flow of the data instead of abstarcting the data itself.
03:52:05 <aloiscochard> simukis_: agree, same if you think about Monoid/Monad
03:52:23 <aloiscochard> at least that's a way to remember
03:54:04 <Phillemann> Oh, interesting idea.
03:54:51 <jle`> that is too how i have rationalized it
03:54:56 <jle`> but again
03:54:58 <jle`> completely arbitrary
03:55:21 <jle`> if they had put Functor in Control i would have probably have been able to come up with just a plausible of a rationalization
03:55:49 <jle`> but that could answer 'what would be a reason in favor of...'
03:56:08 <jle`> but it can't answer 'why is it...'
03:56:17 <jle`> or maybe it can. i't slate :)
03:56:57 <startling> Applicative and Monad don't inherently have anything to do with control flow, though
03:57:27 <startling> (but lots of control-flowy things are applicatives and monads, I guess)
04:00:10 <Phillemann> I'm having a little trouble im- and exporting data constructors. Say I have a simple record-like type: data Point a = Point { getX :: a, getY :: a }. What do I export to let people construct points using "Point x y"?
04:00:17 <Phillemann> Also, what do people have to import?
04:00:29 <Jafet> Point(Point)
04:00:39 <Phillemann> Answer to both questions? :>
04:01:09 <Jafet> Yes, haskell is not that insane that there would be different answers to those questions
04:02:11 <Phillemann> Ok, thanks :)
04:02:39 <Phillemann> And I can export "getX" and "getY" separately, and I can just type Point(..) to export the getters as well as the data constructor, right?
04:04:51 <simukis_> Phillemann: yes.
04:05:05 <Jafet> Field names are handled like constructors: http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2
04:05:33 <Jafet> (I didn't know that)
04:06:46 <Phillemann> Ok, thanks.
04:08:02 <Maior> I don't suppose anyone can tell me how to run `cabal haddock` on https://github.com/doismellburning/hess/tree/feature/haddock to get more than `haddock: No input file(s).` - how am I supposed to tell haddock about my src dir?
04:08:24 <Maior> short of passing files explicitly
04:11:04 <jkarni> any libraries that compare TH Decs, Exp etc. for equality modulo variable renaming?
04:11:36 <jkarni> it seems like a common enough need, though perhaps also relatively easy to solve without libraries
04:11:39 <jakex> quchen thanks for that code yesterday, I like it more than nested cases. but, as far as I can see, I am forced to use Maybe monad with optparse-applicative, no? since that is what their function accept
04:11:53 <jakex> Monad m, not maybe monad
04:20:39 <supki> Maior: you'd need to list library modules under the exposed-modules: section
04:20:48 <supki> Maior: e.g. exposed-modules: Hess.Core
04:53:11 <tibbe> Cabal 1.20 is out, get it while it‚Äôs fresh. :)
04:54:17 <srhb> tibbe: Any highlights?
04:54:26 <c_wraith> yay, I can finally run "cabal exec ghci" to get sane behavior (unlike cabal repl)
04:54:32 <tibbe> srhb: http://blog.johantibell.com/2014/04/announcing-cabal-120.html
04:54:44 <tibbe> c_wraith: what doesn‚Äôt work with cabal repl?
04:54:46 <srhb> tibbe: Thanks!
04:54:56 <tibbe> srhb: you‚Äôre welcome
04:55:11 <tibbe> c_wraith: I‚Äôd be interested in fixing any cabal repl problems
04:55:14 <c_wraith> tibbe: it compiles all modules in the package before starting the repl, and loads all the modules when it does.  Neither of those is a good idea.
04:55:42 <tibbe> c_wraith: it shouldn‚Äôt compile any modules before, just run the neccesary preprocessors.
04:55:54 <tibbe> c_wraith: i.e. we call ghci <modules> and let ghci sort it out
04:55:56 <c_wraith> tibbe: about 75% of the time, I want to test an experimental change to a module that will break everything else
04:56:02 <tibbe> c_wraith: perhaps you want us to pass fewer modules?
04:56:08 <c_wraith> I want 0 modules passed in
04:56:29 <tibbe> c_wraith: I see, we ought to support cabal repl <target> that just passes a single module
04:56:43 <c_wraith> I can load the one I'm modifying.  I don't want to deal with compile errors in every module when I'm testing breaking changes to one of them.
04:56:44 <tibbe> or cabal target <lib/exe/test/bench>
04:56:52 <c_wraith> Yeah, that'd be reasonable
04:56:58 <tibbe> c_wraith: it‚Äôs in the plans
04:57:11 <c_wraith> But for now, cabal exec ghci does what I want
04:57:14 <tibbe> c_wraith: I think there‚Äôs some ghci short-coming that were giving us issues when trying to implement it
04:57:21 <tibbe> c_wraith: can you file a feature request to remind us?
04:57:33 <c_wraith> Yeah
04:57:41 <tibbe> c_wraith: that‚Äôs great, but I also want to fix repl so it‚Äôs always smooth sailing
04:58:20 <srhb> tibbe: Looks great, good work :-)
04:58:32 <jakex> filterM can't be written as applicative, right?
04:59:37 <c_wraith> jakex: it can, actually, but it's sneaky
05:00:13 <jakex> I am curious how
05:00:15 <c_wraith> jakex: (I once thought the same as you..  But it turns out the structure of the recursion doesn't change based on the output of the predicate, so it can work)
05:04:33 <c_wraith> :t let filterA p = go where go [] = pure [] ; go (x:xs) = (\y z -> if y then x : z else z) <$> p x <*> go xs in filterA -- jakex
05:04:33 <lambdabot> Applicative f => (t -> f Bool) -> [t] -> f [t]
05:04:35 <no-n> [00:00:03]  <no-n>	 > replicateM 2 [0,1]
05:04:35 <no-n> [00:00:08]  <lambdabot>	 mueval-core: Time limit exceeded
05:04:38 <no-n> why did that happen?
05:04:55 <c_wraith> load on the machine lambdabot runs on?
05:05:31 <no-n> makes sense
05:07:33 <c_wraith> jakex: the important part is that the structure of effect application doesn't change depending on the result of the predicate.  No matter whether it returns True or False, p will be applied to every element of the list, in order.
05:08:44 <jakex> I see. so we can't skip applying next effect based on the previous one with Applicative (but we can with Monad).
05:08:46 <orion> main = doFork ; where doFork = forkIO (doFork) >> doFork -- huehuehue
05:09:23 <jakex> well actually we could have skipped elements too.. I am puzzled again
05:09:40 <c_wraith> jakex: you can't skip *testing* an element
05:09:51 <c_wraith> jakex: you can only skip including it in the result
05:10:09 <c_wraith> jakex: and only the test has effects in the applicative
05:11:21 <c_wraith> jakex: and yes, Monad lets you use the result of an action to determine what action to execute next, if any.  Applicative requires that the structure of action exection be static.
05:11:53 <jakex> ok I think I am getting it
05:11:55 <c_wraith> ... of *the action.
05:14:53 <jakex> so, if say f in (a -> f Bool) was (a -> IO Bool), and it also printed something to stdout prior to returning a Bool, we couldn't have prevented printing with Applicative but could with Monad?
05:15:50 <c_wraith> jakex: correct
05:16:30 <c_wraith> jakex: though filterM doesn't do that, of course.
05:16:41 <jakex> yeah
05:17:35 <maxx_> there was a concise way of printing something N times, anyone knows off hand?
05:17:54 <c_wraith> :t \n -> replicateM n print
05:17:56 <lambdabot> Show a => Int -> a -> [IO ()]
05:18:02 <c_wraith> :t \n -> replicateM_ n print
05:18:03 <lambdabot> Show a => Int -> a -> ()
05:18:08 <maxx_> thanks
05:18:14 <c_wraith> err.  That's totally not right.
05:18:39 <c_wraith> :t replicateM
05:18:40 <lambdabot> Monad m => Int -> m a -> m [a]
05:18:54 <c_wraith> what?
05:19:20 <srhb> @type \n s -> replicateM_ n (print s)
05:19:21 <lambdabot> Show a => Int -> a -> IO ()
05:19:29 <c_wraith> oh, whoops
05:19:32 <srhb> :)
05:19:36 <c_wraith> Trapped in function monad!
05:19:44 <c_wraith> :t \n -> replicateM_ n . print
05:19:45 <lambdabot> Show a => Int -> a -> IO ()
05:20:12 <c_wraith> Too early for me!
05:20:29 <werdna> hi there! I'm doing a homework assignment, and my professor has asked me to "Write a data type with name Tag, which we will use as a kind, that has two variants, called Empty and NonEmpty. Then, adjust the GADT type of BinaryTree to be indexed by one of these two data types. BinaryTree Empty Integer should refer to an empty tree of integers, whereas BinaryTree NonEmpty Integer should refer to a tree containing one or more integers."
05:20:29 <werdna> I don't understand what he means by "indexed by", though
05:20:41 <werdna> I can write the Tag GADT, but I don't quite get how I can change the BinaryTree to use it
05:21:21 <hpc> werdna: imagine you have two types
05:21:36 <hpc> EmptyBinaryTree, NonEmptyBinaryTree
05:21:41 <werdna> uhuh
05:21:53 <hpc> but that's gross, they are both binary trees
05:22:01 <hpc> so you pass a parameter to a single BinaryTree type
05:22:10 <werdna> right
05:22:17 <hpc> and that's going to be either Empty or NonEmpty
05:22:44 <hpc> to gloss over a whole ton of nuance and higher level theory, that's exactly what indexed means
05:23:01 <hpc> the type BinaryTree does different things based on that type parameter
05:23:18 <werdna> okay, so I understand having type parameters and GADTs, but I guess something is missing, because I don't understand why I need two types for this
05:23:35 <hpc> because eventually, you are going to have many operations on BinaryTree
05:23:46 <hpc> only some of which can correctly handle the empty tree
05:23:49 <hpc> so for instance
05:24:02 <hpc> depth :: BinaryTree t a -> Int
05:24:07 <hpc> easy, empty tree has depth zero
05:24:18 <hpc> root :: BinaryTree NonEmpty a -> a
05:24:41 <hpc> that's going to be the same as head for lists, but it can't error because we explicitly deny that an empty tree is valid
05:24:58 <hpc> passing in the empty tree is going to typecheck as BinaryTree Empty a
05:25:14 <hpc> and Empty doesn't unify with NonEmpty and you get an error
05:25:21 <no-n> @hoogle Word
05:25:22 <lambdabot> Data.Word module Data.Word
05:25:22 <lambdabot> Data.Word data Word
05:25:22 <lambdabot> GHC.Exts data Word
05:25:34 <hpc> werdna: do you know the syntax for GADTs?
05:25:55 <werdna> hmmm, interesting. Okay, so I understand then that I need to change the Leaf constructor to read: Leaf :: BinaryTree Empty a and then the Branch constructor to read Branch :: a -> BinaryTree t a -> BinaryTree t a -> BinaryTree NonEmpty a
05:26:41 <werdna> the last piece of the puzzle is this: it looks weird that I haven't specified that the first parameter to BinaryTree is a Tag.
05:27:00 <werdna> do I need to do that somewhere?
05:28:09 <hpc> werdna: maybe; see if it can infer the correct kind and if not the syntax is
05:28:29 <hpc> data BinaryTree :: Tag -> a -> * where -- iirc, something like this
05:28:43 <hpc> werdna: also a tiny nuance, your definition is balanced binary trees
05:28:50 <hpc> which might be what you want
05:28:59 <c_wraith> tibbe: issue filed.
05:29:14 <werdna> hpc: Not sure I understand why it is. A Branch is defined as value leftSide rightSide
05:29:24 <hpc> er, not balanced, but close to it
05:29:40 <hpc> you are using the same 't' tag for both branches, so you can't have
05:29:52 <hpc> Branch 5 Leaf (Branch 6 Leaf Leaf)
05:29:55 <werdna> yeah, just realised that as you were typing :p
05:30:00 <hpc> ;)
05:30:23 <k00mi> I think this also works: data BinaryTree (t :: Tag) a where
05:30:35 <tibbe> c_wraith: thanks
05:31:01 <werdna> k00mi: it does indeed, but now I get this:     The first argument of `BinaryTree' should have kind `Tag',    but `Empty' has kind `*'
05:31:17 <werdna> I'm using "data Tag = Empty | NotEmpty"
05:31:33 <werdna> perhaps that's not the right way to set up Tag.
05:32:51 <k00mi> uhm, should be correct, did you enable DataKinds?
05:33:02 <jakex> c_wraith any special reason why you wrote filterA using go instead of `filterA p (x:xs) = (..) <$> p x <*> filterA p xs go'?
05:33:16 <jakex> s/go// in the code
05:33:34 <werdna> k00mi: yeah, here's what I have so far: http://p.defau.lt/?7hlnsaeL2_USeRkoPioarg
05:34:08 <werdna> man, GADTs are the first thing to really do my head in about Haskell
05:34:26 <k00mi> werdna: ah, you don't need the "data Empty" and "data NonEmpty"
05:35:29 <werdna> got it
05:35:31 <werdna> aaand it's working
05:35:42 <k00mi> :)
05:35:52 <werdna> thanks a million, I appreciate you guys being patient and helpful. I guess I'm having trouble with a lot of the terminology flying around Haskell.
05:37:12 <k00mi> no problem
05:37:26 <c_wraith> jakex: No good reason, in terms of being an example.  For library code, though, you nearly always want to worker/wrapper transform like that - it enables significantly more inlining.
05:38:03 <jakex> I see. I thought both would compile to the same resulting code
05:43:00 <c_wraith> jakex: Due to details of how GHC does inlining, that's not true.  recursive definitions don't get inlined, of course.  But if you make the function a non-recursive wrapper around a locally-defined recursive worker, it will inline the definition of the wrapper, when it can.  When it does that, it also copies the definition of the worker in, which lets it see the argument it closed over during inlining.
05:43:01 <c_wraith>  That means it can inline p inside the worker, in that example - something it wouldn't be able to do without that transformation.
05:53:23 <aloiscochard> how can I `Either a (IO b) -> IO (Either a b)`?
05:54:03 <Peaker> Data.Traversable.sequenceA
05:54:29 <Peaker> alternatively:
05:54:30 <jakex> curious how you ended up with Either a (IO b)?
05:54:48 <Peaker> @type either (return . Left) (Right <$>)
05:54:49 <lambdabot> (Functor m, Monad m) => Either a (m b) -> m (Either a b)
05:55:24 <sipa> > either (return . Left) (Right <$>) $ Left ["a"]
05:55:26 <lambdabot>  No instance for (GHC.Show.Show
05:55:26 <lambdabot>                     (m0 (Data.Either.Either [[GHC.Types.Char]] b0)))
05:55:26 <lambdabot>    arising from a use of ‚ÄòM75692464623604290012688.show_M75692464623604290012...
05:55:26 <lambdabot>  The type variables ‚Äòm0‚Äô, ‚Äòb0‚Äô are ambiguous
05:55:26 <lambdabot>  Note: there are several potential instances:
05:55:35 <Peaker> sipa: ambiguous monad instance there
05:55:47 <sipa> > either (return . Left) (Right <$>) $ Left (Just "a")
05:55:49 <lambdabot>  No instance for (GHC.Show.Show
05:55:49 <lambdabot>                     (m0 (Data.Either.Either (Data.Maybe.Maybe [GHC.Types.Char...
05:55:49 <lambdabot>    arising from a use of ‚ÄòM104842901127577643212713.show_M1048429011275776432...
05:55:49 <lambdabot>  The type variables ‚Äòm0‚Äô, ‚Äòb0‚Äô are ambiguous
05:55:49 <lambdabot>  Note: there are several potential instances:
05:55:52 <sipa> same
05:55:53 <aloiscochard> jakex: yeah maybe I can avoid it, basicaly I have 'Either a b' and then 'b -> IO c'
05:56:04 <orion> What does (->) do?
05:56:14 <aloiscochard> jakex: at the end i want 'Either a (IO c)'
05:56:19 <aloiscochard> jakex: sorry err...
05:56:28 <aloiscochard> jakex: IO first obviously
05:56:32 <sipa> orion: (a -> b) is the same type as (->) a b
05:56:35 <Peaker> sipa: Just needs to be in the Right
05:56:39 <Peaker> sipa: so that it forces m=Maybe
05:56:52 <Peaker> > either (return . Left) (Right <$>) $ Right (Just "a")
05:56:54 <lambdabot>  Just (Right "a")
05:57:23 <supki> :t _Right :: (a -> IO b) -> Either e a -> IO (Either e b)
05:57:24 <lambdabot> (a -> IO b) -> Either e a -> IO (Either e b)
05:58:04 <Peaker> > either (return . Left) (Right <$>) $ (Left 5 :: Either Int (Maybe Char))
05:58:06 <lambdabot>  Just (Left 5)
05:58:49 <aloiscochard> Peaker: I like sequenceA
05:59:03 <aloiscochard> Peaker: not sure how to import Traversable to avoid Prelude clashes do
05:59:04 <aloiscochard> though*
05:59:10 <aloiscochard> I hidded 'sequence'
05:59:28 <Peaker> aloiscochard: import Data.Traversable (sequenceA)
05:59:36 <aloiscochard> all right, ty Peaker
06:02:54 <orion> handleWriter lvar config@Config{..} handle writer = do -- what is this {..} notation?
06:02:55 <aviraldg> What's the recommended workflow for developing a cabal package? A link would be fine. Using `cabal build` and running the resulting binary appears to use the installed versions of some files.
06:03:52 <aviraldg> * developing == contributing to an existing package
06:07:17 <Taneb> orion, it matches each field to an identifier with the name of the field
06:07:18 * hackagebot azure-servicebus 0.1.0.0 - Windows Azure ServiceBus API  http://hackage.haskell.org/package/azure-servicebus-0.1.0.0 (kapilash)
06:07:43 <Taneb> So Foo{foo = foo, bar = bar} is the same as Foo{..} if Foo has fields foo and bar
06:07:48 <c_wraith> orion: it's part of the RecordWildCards extension
06:08:44 <orion> thank you
06:23:56 <Benzi-Junior> hey I'm trying to construct a parser that parses a sequence of digits and then optionally can parse at most one instance of another kind of token at any point in the sequence is there a clever way to do this
06:25:07 <Benzi-Junior> this would be the same as a parser that can parse integers and floating point numbers (the dot beeing the other kind of token in that instance)
06:25:29 <jakex> are you using Parsec?
06:26:00 <Benzi-Junior> jakex: yes
06:26:24 <byorgey> Benzi-Junior: not that I can think of.  Just do  sequence followed-by (optionally (other-token followed-by sequence))
06:27:08 <Benzi-Junior> byorgey: what's the best way to do the optionally bit just use try ?
06:27:30 <byorgey> Benzi-Junior: no, try has nothing to do with whether something is optional, it means to backtrack upon failure
06:27:42 <byorgey> Benzi-Junior: I think there is a combinator called 'optional'
06:28:20 <byorgey> and also 'option'
06:28:34 <Benzi-Junior> byorgey: there is thank
06:32:59 <\tim> Is there a nice table somewhere with all common fixity declarations in 1 place?
06:37:27 <mietek> If IOError and IOErrorType are opaque in Haskell 2010, how does one us mkIOError?
06:37:32 <mietek> s/us/use/
06:39:04 <mietek> Ah, never mind.
06:39:21 <mietek> There seems to be no OtherError equivalent, though.
06:45:58 <Benzi-Junior> isn't there a operator on parsers that sequentially joins them (i.e. if I have parser p and q  then p++q would first parse p and then q  and return the total result)
06:46:11 <matheus23> What libraries would you guys suggest if I want to have networked serialization of haskell data's?
06:47:14 <simukis_> Benzi-Junior: `>>=` if you‚Äôre in monadic context and `<$> p <*> q` if you‚Äôre in applicative context.
06:47:47 <aviraldg> Using Haskell Platform instead of independently installed versions of packages is recommended, right?
06:47:54 <srhb> aviraldg: Umm..
06:48:03 <aviraldg> Newbie here.
06:48:09 <aviraldg> Here's the thing:
06:48:10 <srhb> aviraldg: Well, I don't recommend it for sure.
06:48:28 <srhb> I don't know the general feeling, but Haskell Platform has caused me too many issues to bother with it.
06:48:59 <geekosaur> it's something of a religious question, I'm afraid
06:49:09 <aviraldg> Hmm. Just got started with Cabal and realised the packaged version doesn't support sandboxes (?)
06:49:29 <srhb> aviraldg: Just install the fresh one.
06:49:34 <srhb> aviraldg: 1.18 or 1.20
06:49:37 <fizruk> hi! what's the status with gloss? is someone maintaining it? it seems to lack documentation as well as some basic features (e.g. thick lines) and hasn't been updated since January
06:49:51 <srhb> fizruk: Lacks documentation?
06:50:24 <geekosaur> yes, the current platform release is a bit behind because ghc 7.8 took so long to come out (and was needed to fix Mac support, between Apple switching to clang and ghc using a C preprocessor on Haskell code /o\ )
06:50:45 <aviraldg> ... which I did, but it appears to be incompatible with ghc7.6
06:50:58 <srhb> aviraldg: 1.18 is not incompatible with ghc7.6 for sure
06:51:04 <srhb> I don't know about 1.20
06:51:10 <srhb> (I don't think it is)
06:52:13 <aviraldg> Hmm...
06:52:30 <aviraldg> Is ghc 7.8 ... bleeding edge?
06:52:31 <fizruk> srhb: hm.. no, documentation's fine, but still it can be less limited
06:52:43 <srhb> aviraldg: No, it's the new stable release
06:52:58 <srhb> aviraldg: Quite a few packages have not been updated on Hackage to build on it yet, though
06:53:40 <aviraldg> Somewhat like that, then.
07:05:06 <srhb> aviraldg: How are you trying to install the new cabal-install anyway?
07:06:52 <aviraldg> `cabal install --global Cabal cabal-install`
07:07:07 <aviraldg> then getting rid of the the system package
07:09:30 <srhb> eck, global install are not nice
07:10:45 <aviraldg> mmm... How should it be done, then?
07:16:29 <matheus23> fizruk: Maybe you like my library? :) https://github.com/matheus23/DeclarativeGraphics
07:16:40 <matheus23> It's very early development, though...
07:19:14 <srhb> aviraldg: Just cabal install cabal-install
07:19:34 <motuleno> MOHAMMED GAVE BLOWJOBS TO HIS GRANDSON:
07:19:34 <motuleno> SURA 52:24
07:19:34 <motuleno> ìAnd there shall wait on them [the Muslim men] young boys of their own, as fair as virgin pearls.î
07:19:34 <motuleno> Hadith Number 16245, Volume Title: ìThe Sayings of the Syrians,î Chapter
07:19:34 <motuleno> Title: ìHadith of Muíawiya Ibn Abu Sufyanî: ìI saw the prophet ñ pbuh ñ
07:19:36 <motuleno> sucking on the tongue or the lips of Al-Hassan son of Ali, may the
07:19:38 <motuleno> prayers of Allah be upon him. For no tongue or lips that the prophet
07:19:40 <motuleno> sucked on will be tormented (by hell fire)
07:19:42 <motuleno> He (the Prophet) lift up his (al Hasanís) shirt & kissed his (little) penis..î
07:19:42 <srhb> @where ops
07:19:43 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
07:19:44 <motuleno> ÿ±ŸàŸâ ÿ£ŸÜŸá ÿµŸÑŸâ ÿßŸÑŸÑŸá ÿπŸÑŸäŸá Ÿà ÿ≥ŸÑŸÖ ŸÇÿ®ŸÑ ÿ≤ÿ®Ÿäÿ®ÿ© ÿßŸÑÿ≠ÿ≥ŸÜ ÿ£Ÿà ÿßŸÑÿ≠ÿ≥ŸäŸÜ
07:19:46 <motuleno> He (the prophet) kissed the (little) penis of al Hasan or al Husein
07:19:48 <motuleno> ÿ±ÿ£Ÿäÿ™ ÿßŸÑŸÜÿ®Ÿä ÿµŸÑŸâ ÿßŸÑŸÑŸá ÿπŸÑŸäŸá Ÿà ÿ≥ŸÑŸÖ ŸÅÿ±ÿ¨ ŸÖÿß ÿ®ŸäŸÜ ŸÅÿÆÿ∞Ÿä ÿßŸÑÿ≠ÿ≥ŸäŸÜ Ÿà ŸÇÿ®ŸÑ ÿ≤ÿ®Ÿäÿ®ÿ™Ÿá
07:19:53 <motuleno> He (the prophet) put Huseinís legs apart & kissed his (little) penis
07:19:55 <motuleno> Another Hadith. Majma al-Zawa‚Äôid, Ali ibn Abu Bakr al-Haythami, 299/9 ŸÖÿ¨ŸÖÿπ ÿßŸÑÿ≤Ÿàÿßÿ¶ÿØ ŸÑÿπŸÑŸä ÿ®ŸÜ ÿ£ÿ®Ÿâ ÿ®ŸÉÿ± ÿßŸÑŸáŸäÿ´ŸÖŸä
07:19:55 --- mode: ChanServ set +o Cale
07:19:56 --- mode: ChanServ set +o edwardk
07:19:58 <motuleno> ÿ±ÿ£Ÿäÿ™ ÿ±ÿ≥ŸàŸÑ ÿßŸÑŸÑŸá ÿµŸÑŸâ ÿßŸÑŸÑŸá ÿπŸÑŸäŸá Ÿà ÿ≥ŸÑŸÖ ŸÅÿ±ÿ¨ ŸÖÿß ÿ®ŸäŸÜ ŸÅÿÆÿ∞Ÿä ÿßŸÑÿ≠ÿ≥ŸäŸÜ Ÿà ŸÇÿ®ŸÑ ÿ≤ÿ®Ÿäÿ®ÿ™Ÿá
07:19:59 --- mode: Cale set +b *!*@scheisseparty.fecalsmear.powerbrownie.com.br
07:20:00 --- kick: motuleno was kicked by Cale (motuleno)
07:20:05 <srhb> Cale: Thanks
07:20:53 <aviraldg> srhb,  It seems I've also managed to break a lot of stuff :( http://dpaste.com/1788238/
07:20:55 <srhb> Pretty sure we could permaban *fecalsmear*
07:21:08 <jkarni> any easy way to do alpha equivalence/alpha conversion on template haskell Exps and Decs?
07:22:15 <srhb> aviraldg: What did you do exactly?
07:23:18 <fizruk> matheus23: are you planning to have simulate/play analogues?
07:23:51 <aviraldg> 1. cabal install --global Cabal cabal-install 2. <remove system haskell-platform and deps> 3. cabal install <list of packages in haskell platform (minus version numbers - probably a bad move in hindsight)> 4. discover everything was broken
07:23:52 <srhb> aviraldg: What you should do: Clear out everything. install ghc and cabal from your distro, or from the webs. Then cabal update; cabal install cabal-install
07:24:06 <srhb> aviraldg: Ugh, yes.
07:24:29 <srhb> aviraldg: Clean out everything and start from a fresh ghc and cabal
07:24:45 <srhb> aviraldg: And don't do global install
07:24:46 <matheus23> fizruk: you mean... animation? Sorry I don't get what you mean by "analogues" :)
07:26:35 <fizruk> matheus23: yeah, animation and user input handlers
07:27:01 <orion> I just wrote an echo server in Haskell: http://ideone.com/FchwDK Are there any glaring newbie mistakes that I am making? Is there a more concise way to write what I wrote?
07:27:12 <matheus23> fizruk: Well, the idea is to leave this to the user. I'm currently working on something "higher level" widgets. Those would react to mouse and keyboard input
07:27:17 <fizruk> matheus23: I'm actually pretty happy with gloss except it's too limited
07:27:35 <matheus23> you can put all your input handling needs on top of my lib :) ;D
07:27:51 <fizruk> matheus23: I see :)
07:27:58 <srhb> orion: It's fine.
07:28:38 <srhb> Perhaps aside from the forking.
07:28:39 <matheus23> fizruk: I'll get back to you in a couple of days (maybe more, depends) when I've got the widget stuff ready :)
07:29:27 <fizruk> matheus23: okay :)
07:30:12 <simon> srhb, because it can be abused?
07:30:37 <srhb> simon: No, because I wasn't sure about the semantics on listenSock. Assuming it blocks until a connection is established, it's fine
07:33:00 <orion> thank you
07:33:27 <orion> Is there a way to combine "text <- hGetLine handle" and "hPutStrLn handle text" ?
07:33:41 <srhb> hGetLine handle >>= hPutStrLn handle
07:34:56 <simon> which is equivalent to:  hGetLine handle >>= (\text -> hPutStrLin handle text)
07:35:03 <orion> How would that change if the order of the input arguments for hPutStrLn were reversed?
07:35:24 <simon> orion, then you might do hGetLine handle >>= flip hPutStrLn handle :)
07:36:00 <simon> orion, or hGetLine handle >>= (\text -> hPutStrLn text handle)
07:36:16 <orion> I see.
07:36:18 <Fernandos> hi
07:36:20 <orion> interesting
07:36:24 <simon> orion, but it seems nice if you can leave out the explicit argument when using the bind operator.
07:36:32 <Fernandos> I tried to emerge sci-mathematics/agda, but it somehow failed, can someone provide me with assistance in debugging it?
07:36:49 <orion> right
07:37:18 <Fernandos> Is something broken in the haskell repos?
07:37:43 <orion> I saw somewhere in someone's code the use of the "fix" function. I read a bit about fixed-point combinators but I am still confused. What does fix do?
07:38:08 <quchen> @src fix
07:38:09 <lambdabot> fix f = let x = f x in x
07:38:09 <tristan__> I need help figuring out why I am an idiot and/or crazy
07:38:15 <orion> I saw it in this context: "void $ forkIO $ fix $ \loop -> do ..."
07:38:29 <quchen> Hmm, might be clearer to define it as  `fix f = f (fix f)`
07:39:23 <quchen> Fix basically allows you to write recursive lambdas.
07:39:27 <hpc> it is, but lambdabot's is an optimization
07:39:35 <quchen> When you've got "\x -> ...", you cannot call that lambda from itself.
07:39:47 <simon> orion, fix f = f (f (f (f (... x)))), i.e. apply a function to its own output infinitely.
07:40:47 <supki> Fernandos: I suggest asking that in #gentoo-haskell
07:40:49 <quchen> So fix gives you a way of doing just that.  fix (\x -> 1:x) = (\x -> 1:x) (fix (\x -> 1:x)) = 1 : (fix (\x -> 1:x))
07:41:02 <quchen> This applies the function "\x -> 1:x" repeatedly to itself.
07:41:07 <quchen> > fix (1:)
07:41:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:41:15 <Fernandos> supki: aw.. yeah right, Thanks for the pointer
07:41:28 <orion> Interesting
07:42:08 <tristan__> anyone know why I am stupid and/or crazy and don't undrestand why these are different https://gist.github.com/tsloughter/11115747
07:42:17 <quchen> In your forkIO example above, you're using the idiom "fix $ \loop -> ...". This runs (...), and allows recursing to itself by calling 'loop' again.
07:42:56 <mietek> How likely it is that generic-deriving will make it into the next GHC distribution?
07:43:11 <quchen> DeriveGeneric is in GHC already.
07:43:26 <orion> Doesn't there need to be an initial condition with fix?
07:43:27 <mietek> Right, I mean support for deriving things like Monoid
07:43:28 <quchen> orion: You can read "fix $ \x -> ..." somewhat similar to a top-level definition a la "x = ...".
07:43:48 <mietek> quchen: specifically http://hackage.haskell.org/package/generic-deriving-1.6.3/docs/Generics-Deriving-Monoid.html
07:43:53 <CindyLinz> tristan__: I guess that haskell's showDigest is not binary, but the python's digest is binary?
07:44:37 <orion> @src forever
07:44:38 <lambdabot> Source not found. It can only be attributed to human error.
07:44:56 <orion> quchen: In what cases would you use forever instead of fix?
07:45:06 <orion> Seems like they do almost the same thing.
07:45:07 <quchen> forever x = x >> forever x
07:45:08 <tristan__> CindyLinz: dear god, thanks CindyLinz :)
07:45:12 <tristan__> Œª> B64.encode . L.toStrict . bytestringDigest $ hmacSha256 "secret" "message"
07:45:12 <tristan__> "i19IcCmVwVmMVz2x4hhmqbgl1KeU0WnXBgoDYFeWNgs="
07:45:36 <quchen> orion: fix isn't used very often, because of functions like 'forever', or using explicit definitions in recursive 'let's.
07:45:36 <tristan__> I could have swore I tried that, haha
07:45:38 <CindyLinz> tristan__: nice ^^
07:45:43 <tristan__> thanks :)
07:45:51 <orion> I see.
07:46:02 <quchen> orion: If you wanted a forever that could "loop back" at any point, and not just at the end automatically, you could do that with fix.
07:46:23 <quchen> You could also not loop back, so fix can terminate.
07:46:23 <orion> ah
07:46:29 <orion> oh wow
07:47:19 <orion> So, in my echo server, I can use fix instead of forever if, say, I detect an error on the socket.
07:47:24 <CindyLinz> The lambdabot @pl use fix frequently.. :p
07:49:09 <quchen> orion: http://lpaste.net/102984
07:49:29 <orion> Yes!
07:50:24 <srhb> orion: Of course, you should just do this with explicit recursion without fix. :-)
07:50:24 <quchen> orion: I edited the paste to show an alternative way of writing it with explicit naming.
07:50:38 <quchen> I think that version is more common.
07:51:44 <orion> hmm
07:51:56 <orion> Actually, that does seem to be a lot more reasonable.
07:52:22 <orion> What if you want the result back though?
07:54:19 <quchen> orion: You can also maintain some state this way, http://lpaste.net/102986
07:54:33 <quchen> This counts a counter up every time you enter something.
07:54:53 <quchen> "`fix` 1" is much less clear than the "go" variant I think. But other than that the examples are pretty much identical.
07:55:13 <benmachine> to count a counter you presumably need a counter counter
07:55:41 <quchen> If you want the result back, you could change the `_else  -> putStrLn "Parse error"` to something that returns your desired result, such as which input produced the parse error.
07:55:45 <no-n> if i had a nickel for every time i'd counted a counter
07:55:51 <no-n> well i'd need another counter for that as well
07:55:53 <orion> What is the type of bar?
07:56:04 <quchen> IO ()
07:56:37 <pejo> I'm not sure what to ask, but I'll throw out my problem and hope someone responds. I'm using ghci and my function does not terminate on some particular input, unless I have a trace that shows the structure in question, in which case it runs just fine. If I install the package I'm interpreting everything works fine. If I compile a binary everything works fine. How do I debug my ghci problem?
07:57:08 <quchen> bar = go 1, so the type of bar is the type of "go 1". "go 1" takes an Int and terminates with an IO action of type "IO ()", so "go :: Int -> IO ()", therefore "bar :: IO ()".
07:58:05 <orion> quchen: What if bar had a set of conditions on which it would terminate the recursion, and I wanted to run a case on that result?
07:58:09 <orion> I.e., in main
07:58:09 <MagneticDuck> pejo: by posting the code?
07:58:11 <MagneticDuck> sounds interesting
07:58:13 <quchen> pejo: Have you tried compiling with -Wall? That catches many things.
07:58:28 <benmachine> pejo: I have a wild guess
07:59:22 <benmachine> pejo: it might be that your function performs very poorly when executed lazily, it accumulates thunks in an accumulator or something
07:59:45 <benmachine> pejo: if you trace it then that forces the accumulator, so makes things efficient again
07:59:55 <pejo> benmachine, yeah, but getting a grip on space behavior is rather tricky if the problem disappears when I try to profile the thing.
07:59:59 <benmachine> pejo: likewise if you compile with optimisations the strictness analyser will bypass the problem
08:00:35 <benmachine> pejo: how are you profiling? are you using GHC's inbuilt profiling stuff?
08:00:52 <benmachine> pejo: another question would be, if it works fine when compiled, does it matter so much?
08:01:01 <aviraldg> srhb, https://www.haskell.org/ghc/download_ghc_7_8_2 -- not very encouraging
08:02:15 <meretrix> Say I have a socket application that accepts two commands "start" and "stop".  When a client sends "start", the server sends a random number once per second (the thread sleeps in between).  How do I cleanly implement the "stop" command?  Just kill the thread? Or do I need to check state every time the thread wakes up?
08:02:50 <pejo> benmachine, there's not really a frontend available, so compiling isn't very user friendly. I'll try turning off optimization.
08:03:00 <merijn> meretrix: I would use bracket to install a proper "disconnect/shutdown" handler and then just kill the thread, yes
08:03:21 <merijn> meretrix: bracket being similar to "try {} finally {}" in other languages
08:03:32 <lispy> :t bracket
08:03:34 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:03:54 <benmachine> meretrix: either of those seem acceptable solutions
08:04:05 <quchen> orion: Like so? http://lpaste.net/102987 This recurses only on odd inputs, and reports+recurses on even ones.
08:04:07 <pejo> quchen, anything particular that I should be looking for?
08:04:18 <benmachine> killing the thread has the benefit of having it not stick around longer than necessary
08:04:39 <srhb> aviraldg: Well why not use your platform ghc version?
08:04:39 <pejo> benmachine, cabal install --disable-optimization also makes the problem go away.
08:04:50 <srhb> aviraldg: I mean, the one that comes with your distro
08:05:18 <aviraldg> incompatible with the latest cabal
08:05:26 <benmachine> pejo: huh, weird
08:05:31 <srhb> aviraldg: I find that unlikely?
08:05:33 <quchen> pejo: You should fix all warnings in general. Sometimes it helps, sometimes it doesn't (but makes your code better anyway). Without code I can't help you any further.
08:05:47 <srhb> aviraldg: Or at least not incompatible with a cabal that has sandboxes
08:06:04 <aviraldg> either that, or it was a result of whatever mucking around I did before trying
08:06:05 <benmachine> aviraldg: it's fine to install the latest Cabal library, typically, but that doesn't mean you should uninstall the global one
08:06:09 <mietek> The very latest Cabal does something weird with ar
08:06:19 <pejo> quchen, everything except for the input is rather big.
08:06:28 <lispy> mietek: how so?
08:07:04 <pejo> benmachine, any other optimization that I can turn off?
08:07:04 <mietek> lispy: I think Cabal 1.20.0.0 fails to build with GHC 7.6.3
08:07:26 <benmachine> pejo: not sure, haven't much tried :)
08:07:33 <lispy> I haven't tried 1.20, but that sounds like a big deal
08:07:37 <benmachine> pejo: maybe invoke GHC directly with -O0
08:07:59 <mietek> Has anyone else tried?  I'll double-check in a bit
08:08:00 <srhb> aviraldg: I would say the result of your mucking. :-) But either way, you can just use cabal 1.18 with your distro ghc
08:08:03 <pejo> benmachine, hm. Can try.
08:08:15 <quchen> orion: `fix` is really only useful if you don't want to give a function an explicit name. Sometimes that happens in ordinary code (but rarely); workers like my "go" are much more common instead. By the way, "fix" is called so because it's the fixed point combinator. In untyped lambda calculus that's also known as the Y combinator.
08:08:34 <orion> I see
08:08:45 <benmachine> fix f is a fixed point of f
08:08:45 <Peaker> A nicer name for "fix" could be "recursively"
08:09:01 <Peaker> recursively $ \rec -> ...
08:09:02 <lispy> fix is actually slightly different from Y
08:09:30 <Peaker> "fix" is the semantic. "Y" is the implementation in unsoundly-typed LC without using recursions
08:09:31 <lispy> Is Y even typeable in Haskell?
08:09:48 <quchen> Depends on what Y is to you.
08:09:56 <Peaker> lispy: it is on a type like:  newtype LC = LC (LC -> LC) :)
08:09:58 <jmcarthur> it is with newtype
08:10:03 <lispy> The other thing we change is sharing the rest of the computation.
08:10:13 <quchen> The usual way of writing Y doesn't typecheck in typed lambda calculus.
08:10:13 <Peaker> and when you use "Y" on LC, ghc hangs forever trying to inline it
08:10:28 <taktoa> anyone have experience with Network.FastCGI?
08:10:29 <quchen> But if "Y" means "Y f = f (Y f)" to you, then you can have it in STLC as well.
08:10:35 <taktoa> especially with lighttpd
08:10:44 <pejo> benmachine, ok, compiling now.
08:11:16 <quchen> Peaker: I've seen "Y" used for the semantic as well. Is that uncommon?
08:11:34 <taktoa> because I'm pretty confused as to how to configure the host+port / socket with a Network.FastCGI binary
08:11:36 <benmachine> quchen: it's common, I think, but that doesn't make it right :P
08:11:36 <Peaker> quchen: AFAIK, yeah
08:11:39 <quchen> In particular, there are many combinators called "Y", and they all suffice the recursion relation
08:11:52 <quchen> ‚Ä¶ from what I've read. Anyway, now we're arguing semantics ;-)
08:12:02 <taktoa> given that none of Network.FastCGI talks about sockets, hostnames, or ports
08:12:14 <lispy> the other thing I wanted to point out is that we define it using let, fix f = let x = f x in x, so that it has the right sharing behavior
08:12:15 <Peaker> arguing semantics is fruitful. Arguing terminology is less interesting :)
08:12:28 <pejo> benmachine, sob.Even if I "ghc --make -O0 -imodule1/src:module2/src file.hs -o file" it terminates immediately.
08:12:46 <quchen> lispy: That's just an optimization.
08:12:47 <lispy> Using that definition the sub computation gets shared
08:13:01 <lispy> quchen: true
08:13:09 <benmachine> pejo: friiig
08:13:24 <benmachine> pejo: are you doing something like not actually forcing the answer so it isn't actually computed
08:13:41 <benmachine> quchen: an important optimisation, I'd argue
08:14:35 <lispy> > take 10 . map length . group . fix $ show
08:14:36 <lambdabot>  [1,1,1,3,1,7,1,15,1,31]
08:15:04 <pejo> benmachine, there are some (simple, local) circular structures in the program, and those are not forced. A reasonable chunk of the output is forced though (it's a compiler..)
08:15:49 <benmachine> pejo: yeah I was just wondering if it was the fact that GHCi was trying to print the result that was causing problems
08:15:52 <benmachine> shrug
08:15:55 <benmachine> that's all I can think of
08:16:09 <benmachine> you might be on your own unless you can come up with a small enough example for us to look at
08:17:07 <pejo> benmachine, I'm happy showing the code, but it's 14 000 lines
08:17:28 <MagneticDuck> github? :D
08:17:43 <benmachine> pejo: I'm not happy reading 14k lines :P
08:18:01 <MagneticDuck> with any luck you'll only have to read HALF of them
08:18:10 <MagneticDuck> and 14k lines is probably counting documentation, right? :D
08:18:15 <orion> About how long does it take to write a 14,000 line Haskell application?
08:18:20 <lispy> pejo: have you read this article? http://www.vex.net/~trebla/haskell/lazy.xhtml
08:18:26 <MagneticDuck> a long time, orion, as far as I can tell
08:18:33 <pejo> MagneticDuck, I used sloccount, not sure what that includes.
08:20:17 <orion> Surely 14,000 lines of Haskell contains more functionality than, say, 14,000 lines of C++ code, am I rite?
08:20:36 <Peaker> orion: indeed
08:21:11 <MagneticDuck> u r rite.
08:21:16 <pejo> lispy, it's really long. Is the point that I should derive something with the help of my code?
08:22:35 <epal_> How concise is Haskell compared to C++ in a large project? (2x, 5x)?
08:22:53 <quchen> At least n times.
08:22:59 <quchen> n ‚àà ‚Ñù
08:23:04 <Peaker> epal_: I don't think it's possible to quantify. Both languages have huge variance in length depending on style, skill, design, etc.
08:23:29 <pejo> epal, if you're trying to do dependent types in Haskell it quickly gets pretty verbose to convince the type checker about certain properties.
08:23:37 <taktoa> quchen: you really like unicode
08:23:56 <lispy> pejo: I missed the description of your problem, but what I inferred from the log I did read is that something isn't evaluating correctly. I think that article serves as good background reading.
08:24:45 <pejo> lispy, the gist is that the problem goes away as soon as I compile my program, but in ghci it doesn't seem to terminate unless I put a trace in the right place.
08:25:06 <pejo> lispy, even if I compile everything with -O0
08:25:29 <lispy> epal_: I had a project at work that used C (and some C++) for most stuff and Haskell for the complicated bits. We spent far less time in writing the Haskell code and we have quite a bit less even though it does more. Exact numbers would be meaningless though because the C and Haskell do different things.
08:26:16 <epal_> Ok, thanks
08:26:22 <lispy> epal_: and we spend less time revisiting the Haskell code as well.
08:26:52 <pejo> epal, here's a link to a couple of comparisons for Erlang: http://www.informatik.uni-trier.de/~ley/pers/hd/n/Nystr=ouml=m:Jan_Henry
08:27:24 <epal_> pejo: thanks, I will go thorugh it
08:27:36 <lispy> epal_: I did this comparison between the darcs and git source code a few years back: http://blog.codersbase.com/posts/2010-08-29-fun-pointless-code-metrics.html
08:28:04 <orion> What is "Right x <- f" desugared?
08:28:15 <quchen> f >>= \Right x ->
08:28:30 <quchen> (Right x), that is
08:28:41 <lispy> pejo: ghci uses a bytecode interpreter instead of the normal run-time.
08:28:49 <Axman6> is it not f >>= \x -> case x of Right y -> ...; _ -> fail "Pattern match fail..."
08:29:04 * quchen doesn't talk about `fail`
08:29:07 <lispy> pejo: What if you do something like ghci -O2 ? Does it change the termination behavior?
08:29:27 <Axman6> quchen: well, that is the reason it exists iirc
08:29:36 <pejo> lispy, ghci says -O conflicts with --interactive, disabling -O
08:29:54 <lispy> pejo: ah.
08:30:04 <lispy> pejo: Do you have any RULES?
08:30:09 <orion> oh
08:30:22 <orion> quchen: So, there is pattern matching going on... NOT construction
08:30:31 <quchen> Axman6, orion: I don't think you should ever have patterns on the LHS of <- that can fail.
08:30:51 <quchen> Right x <- return (Right 1) is alright of course.
08:31:00 <orion> What happens if they do fail? :s
08:31:05 <Axman6> sure, but fail exists for when people get it wrong
08:31:06 <lispy> pejo: Do you have any type class instances that might lead to non-termination in the definitions? This can happen if you forget to define a function. Happens with Eq if you just write "instance Eq Foo where" because the default definition of (==) is in terms of (/=) and the default for (/=) calls (==).
08:31:15 <quchen> orion: Runtime crash if your Monad cannot implement 'fail'.
08:31:17 <pejo> lispy, there's no occurrence of "RULE" in any file. Can it sneak in somewhere else?
08:31:38 <quchen> orion: See the "fail" entry at https://github.com/quchen/articles/blob/master/fbut.md#dont-use-
08:31:45 <Axman6> does fail default to fail str = error str?
08:31:55 <lispy> pejo: Yeah, it could be in a library. And there are some related pragmas but I can't remember them off the top of my head.
08:31:58 <MagneticDuck> Axman6: yes
08:32:13 <quchen> Axman6: Yes.
08:32:30 <quchen> For some Monads, that's the only thing it can do.
08:32:36 <quchen> You *cannot* write 'fail' for Reader, for example.
08:33:05 <pejo> lispy,why would those non-terminating type classes be ignored for the compiled binary?
08:33:53 <lispy> pejo: a rewrite rule could find a way to eliminate the call of the non-terminating method
08:35:47 <pejo> lispy, don't think there are any rewrite rules. Will see if I simply can turn off all optimizations and have the problem appear.'
08:37:29 * hackagebot bus-pirate 0.1 - Haskell interface to the Bus Pirate binary interface  http://hackage.haskell.org/package/bus-pirate-0.1 (BenGamari)
08:37:47 <lispy> pejo: I would encourage you to scrutinize any type class instances in that code. Test them, etc. Fully convince yourself they are not the problem.
08:38:20 <orion> Is anyone familiar with Cloud Haskell? I want to know how a master can spawn a slave on a remote machine.
08:38:35 <copumpkin> pejo: try reducing it from 14000 lines? :) if you file a bug it'll help and it might also help you isolate it
08:38:38 <copumpkin> even if it isn't a bug
08:40:38 <Axman6> orion: I think that's out of the scope of cloud haskell itself, it's left to one of the transport backends (so MPI would take care of it if you were using MPI)
08:41:54 <pejo> lispy, the AST itself is typed by reflecting it into HAskell's type system. I need to narrow the problem into something smaller than "Verify that 200 instances are correct".
08:42:42 <lispy> pejo: Can you list the extensions you use?
08:42:49 <lispy> like maybe paste the list to lpaste
08:43:20 <copumpkin> pejo: what I usually do is make a file Bug.hs and copy the immediate thing I'm using that causes the bad behavior, and its immediate dependencies. Any dependencies beyond that I stub out in some way, and see if it still happens
08:43:30 <copumpkin> if it stops happening, pull in more deps until it does again :P
08:43:52 <copumpkin> then once you have it happening, try cutting other crap out until it works again
08:43:59 <lispy> ah yes, the tried and true method of bisection search over problem space :)
08:44:07 <copumpkin> yeah, it's loads of fun
08:44:17 <copumpkin> I spent a while on it yesterday when I found an obscure GHC bug
08:44:18 <lispy> surprisingly effective
08:47:31 <orion> Axman6: I see.
08:47:39 <pejo> lispy, http://lpaste.net/102989
08:47:47 <orion> I just looked up the documentation for Happstack. There is a record defined there:
08:47:50 <orion> , logAccess  :: forall t. FormatTime t => Maybe (LogAccess t)
08:48:13 <orion> What is "forall t." doing in a type signature?
08:48:32 <stepcut> orion: it is because the 't' does not appear in the type for Conf itself
08:49:20 <stepcut> so if it just said, logAccess :: FormatTime t => Maybe (LogAccess t), the type checker would be all -- "Where did this `t' come from?"
08:49:52 <pejo> copumpkin, any idea on how to stub out the compiler frontend?
08:49:56 <orion> What is "forall"? Why does the t have a "." next to it?
08:50:41 <copumpkin> pejo: how much of it are you using in the piece of code that fails? I was just talking about replacing calls that you use with undefined
08:50:51 <stepcut> orion: the . is part of the forall syntax.. maybe this will help? http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do
08:51:25 <pejo> orion, it's an existential type, it's the same forall as the upside-down A you see in math.
08:51:44 <orion> oh
08:51:49 <orion> forall is a keyword, not a function
08:53:25 <pejo> copumpkin, I know what pass that shows the problem, which is about 2/3 through the pipeline of our code.It doesn't happen for all inputs.
08:54:17 <copumpkin> pejo: hmm, not sure :/
08:54:22 <copumpkin> pejo: is this your supercompiler?
08:54:42 <pejo> copumpkin, nah, but I can't stop working on compilers it seems
08:54:44 <orion> pejo, stepcut: I see. I think I am just going to chalk that one up to, "Stuff I won't understand until I have a Ph.D in CS"
08:54:59 <copumpkin> pejo: all I can suggest is to pick out the smallest part of the program that still exhibits the problem and then trim it down
08:55:03 <copumpkin> pejo: what kind of compiler is it?
08:55:05 <stepcut> orion: :)
08:55:28 <MagneticDuck> orion: huh? getting a Ph.D in CS just means that you've spent a bunch of time learning stuff about things
08:55:38 <pejo> copumpkin, it's the Feldspar compiler. DSL for signal processing codes
08:55:41 <MagneticDuck> it's not as if not having one is stopping you from learning things just the same...
08:55:51 <MagneticDuck> ugh I don't like that attitude =P
08:56:14 <orion> MagneticDuck: I don't have the will to dive that deep in to CS.
08:56:16 <Axman6> orion: basically it's saying that it can contain any t at all (that implements FormatTime) and things should be able to use it. Basically it's saying that the t value will only ever be used through the FormatTime class (because we know nothing else at all about it)
08:56:20 <benmachine> MagneticDuck: universities are pretty good at what they do, so it /does/ make it a heck of a lot easier
08:56:33 <MagneticDuck> #haskell is nice too =P
08:56:46 <jrm2k6> Hi, anybody using elm here? (Try to aks something on the elm channel but it is really empty) :)
08:56:47 <benmachine> #haskell is not a substitute for years of dedicated study
08:56:59 <MagneticDuck> okay
08:57:31 * hackagebot bus-pirate 0.2 - Haskell interface to the Bus Pirate binary interface  http://hackage.haskell.org/package/bus-pirate-0.2 (BenGamari)
08:57:45 <orion> I need to put food on the table. I can't waste it trying to learn stuff about deep CS theory. In the end, all an employer cares about is whether you can get the job done.
08:58:06 <copumpkin> pejo: ah
08:58:19 <benmachine> orion: what your employer cares about should certainly be much less than what /you/ care about :)
08:58:38 <orion> I care about writing software that works. ;x
08:58:44 <benmachine> there are even cases in which your employer can be made to care about what you care about, since your employer cares about keeping you around
08:58:59 <stepcut> orion: in this case, it is pretty straight forward. It would be really annoying for 'Conf' to always have a type parameter for the type used to represent time in the logAccess function. And, really, the only thing that log function needs to do with that type is convert it to a String via FormatTime. Since the 't' does not appear in the data Conf declaration -- the code has to work for all possible `t' -- (aka, forall t.) though we do h
08:58:59 <stepcut>  constraint that it must be a `t' that implements FormatTime (aka, FormatTime =>). Since all we know about the `t' is that it implements format time -- we can't do much with it but call the functions in the FormatTime class on it.
08:59:55 <orion> That makes sense.
09:05:16 <MagneticDuck> any particular reason ghc has decided to not parse empty record updates?
09:06:53 <pejo> copumpkin, guess this is a case of "don't do that".
09:08:02 <pejo> copumpkin, I noticed Neil was pushing a load of commits to supero the other day though, if you're interested in that
09:09:22 <quchen> MagneticDuck: GHC didn't choose to do this, it's dictated by the Haskell standard. I don't know why it's in the standard this way, though.
09:09:52 <quchen> See section 3.15.3, "Updates Using Field Labels", of the H10 report.
09:11:01 <pejo> copumpkin, and Ilya Klyuchnikov has a supercompiler for Martin Lˆf's type theory called TT Lite
09:11:56 <nadirs> Hey there, the other day I was watching a video lecture at MIT opencourseware: it was Sussman (SICP) talking about different space and time performances.
09:11:59 <nadirs> As an example he writes the classic Fibonacci function that expands to a tree (e.g. `fib 5 = fib 4 + fib 3`).  Sussman writes down the consequent expansions showing the duplication in computing the tree (`fib 3` is computed twice, for instance).
09:12:11 <nadirs> At this point comes my question about Haskell: since it's lazy and referentially transparent (don't know if these two facts both come into play or just the latter), is it able to reuse the common subtree of that kind of Fibonacci implementation and thus eliminate the duplication or you still undergo the exponential complexity?
09:13:17 <quchen> nadirs: The naive implementation of fibonacci is exponential in Haskell too.
09:13:42 <quchen> fib n | n <= 1 = n | otherwise = fib (n-1) + fib (n-2), that is
09:15:01 <MagneticDuck> j'ai des questions about what appears to be an update in cabal install... it seems that "cabal install" no longer prints the progress GHC as it builds each module, although cabal configure; cabal build does.
09:15:12 <MagneticDuck> do I have to use some sort of verbose flag to get that now?
09:15:13 <quchen> Conceptually I think you should be able to optimize this into a version with better sharing, I'm not sure why it isn't done. Maybe implementing the general case of common subexpression elimination in arbitrarily sized syntax trees is awfully slow.
09:15:15 <MagneticDuck> it's.. kind of nice =P
09:15:37 <quchen> MagneticDuck: There's the -v flag, yes.
09:16:07 <MagneticDuck> hmm
09:16:28 <nadirs> quchen: yes, that one
09:16:38 <quchen> I'm not sure why the behaviour changed; maybe because it leads to crazy results when compiling in parallel.
09:16:59 <MagneticDuck> it's not quite the same thing :<
09:17:18 <copumpkin> pejo: that's exciting :)
09:17:35 <copumpkin> pejo: now if only a few of those would make it to GHC integration :)
09:17:36 <nadirs> I was thinking that maybe with caching, a Haskell implementation (GHC or whatever) is able to reuse the calls
09:17:50 <nadirs> I mean, the results
09:18:21 <pejo> quchen, CSE can cause space leaks in lazy languages
09:18:22 <nadirs> so in `fib n` you can call `fib (n-2)` just once
09:19:13 <pejo> copumpkin, I think robust supercompilation is pretty hard. :-)
09:19:17 <copumpkin> yup
09:19:28 <copumpkin> might as well start with Agda that's already strongly normalizing :P
09:19:32 <copumpkin> then there's less work to do!
09:20:46 <pejo> copumpkin, open terms in agda can still be non-terminating if you "evaluate" them
09:20:48 <monochrom> and less work that can be done to begin with :)
09:21:18 <copumpkin> pejo: sure, but it seems like there's more machinery in place to help you with that (and a language that has more guarantees)
09:22:33 * hackagebot bus-pirate 0.4 - Haskell interface to the Bus Pirate binary interface  http://hackage.haskell.org/package/bus-pirate-0.4 (BenGamari)
09:22:52 <quchen> pejo: Oh right, if you have common subexpressions in places far apart in time
09:25:29 <merijn> I have a better idea, why not just write a non-recursive fibonacci? :p
09:25:43 <merijn> recursive fibonacci is a dumb example of recursion >.>
09:26:43 <merijn> nadirs: If you want a neat example of laziness and fibonacci take a look at this instead of recursion:
09:26:48 <CindyLinz> merijn: I think you mean one-way recursion instead of two-way recursion?
09:26:58 <BitPuffin> isn't haskell kinda loop-less though
09:27:01 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
09:27:03 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:27:36 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 10000
09:27:37 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
09:27:47 <merijn> constant space usage and fast! \o/
09:27:50 <CindyLinz> it's still recursion.. XD   fibs recurring fibs.. XD
09:27:56 <BitPuffin> yeah
09:28:00 <BitPuffin> that's what I was thiking as well lol
09:28:21 <CindyLinz> btw, I like this version.. ^^
09:28:28 <merijn> By recursive fibonacci I mean the naive standard example of "fibs n = fibs (n - 1) + fibs (n - 2)"
09:29:09 <BitPuffin> fib is not really useful that often though
09:29:23 <pejo> copumpkin, I don't think the types/strong normalization helps that much with the hard problems in supercompilation, but I could be wrong. At least I didn't find any way to exploit the types in System F_c that much
09:29:33 <copumpkin> you'd know better than I do :)
09:29:37 <merijn> BitPuffin: That's true and secondly that example of fibonacci is horribly inefficient in any language, so :)
09:29:41 <BitPuffin> so trying to implement the most efficient fib is perhaps not the best way to spend the time :)
09:30:01 <BitPuffin> merijn: yep :) probably faster in languages that love recursion though
09:30:05 <CindyLinz> > let fibs n = go 0 1 n ; go a b 0 = a ; go a b n = go b (a+b) (n-1) in fibs 5
09:30:07 <lambdabot>  5
09:30:11 <CindyLinz> > let fibs n = go 0 1 n ; go a b 0 = a ; go a b n = go b (a+b) (n-1) in fibs 6
09:30:12 <merijn> BitPuffin: Perhaps not, but that implementation of fibs is a rather common trick with laziness in haskell
09:30:12 <lambdabot>  8
09:30:24 <BitPuffin> merijn: it's pretty cool :D
09:30:24 <merijn> CindyLinz: Now try 10000 like mine :p
09:30:37 <CindyLinz> merijn: I need to seq it ^^|
09:31:53 <CindyLinz> > let fibs n = go 0 1 n ; go a b 0 = a ; go a b n = let b2 = a + b ; n2 = n - 1 in b2 `seq` n2 `seq` go b b2 n2 in fibs 10000
09:31:56 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
09:32:39 <lispy> pejo: sorry, I got pulled away by other stuff and I need to work on other things. I hope you figure out your non-termination problem. Good luck!
09:32:50 <nadirs> merijn: of cous
09:32:54 <pejo> lispy, cheers
09:33:08 <nadirs> merijn: of course you're right that that fibonacci implementation is bad
09:33:25 <nadirs> but I was just trying to reason about different aspects of Haskell
09:33:26 <merijn> let fibs 0 = 0; fibs 1 = 1; fibs n = fibs (n-1) + fibs (n-2) in fibs 10000 -- this won't make it
09:33:29 <merijn> eh
09:33:32 <merijn> > let fibs 0 = 0; fibs 1 = 1; fibs n = fibs (n-1) + fibs (n-2) in fibs 10000 -- this won't make it
09:33:36 <lambdabot>  mueval-core: Time limit exceeded
09:34:21 <merijn> nadirs: Sure, like I said, my implementation is a good and interesting example of laziness for that :)
09:35:11 <CindyLinz> merijn: I've just showed your version to many non-haskellers weeks ago :p
09:35:28 <benmachine> http://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Fibonacci_Number_Program#Closed-form_version I wrote this once, for a better-than-linear fibonacci calculation
09:35:48 <nadirs> merijn: your implementation takes advantage of that ability to reuse computation?
09:36:33 <nadirs> also, that's an example of the famous "tying the knot", right?
09:37:19 <KatZilla1> Hi there )
09:38:15 <KatZilla1> Is there any solution to watch files for changes and then run: cabal build && cabal run ?
09:38:24 <KatZilla1> i need to refresh my code of Scotty web server
09:38:35 <hpc> you need a continuous build system?
09:38:47 <hpc> jenkins maybe?
09:40:58 <KatZilla1> hpc: thx for info	
09:41:12 <lispy> KatZilla1: http://hackage.haskell.org/package/fsnotify
09:41:16 <quchen> WOOOO Cabal 1.20 allows automatically generating source links! monochrom, our lives just got so much better :-D
09:41:30 <lispy> KatZilla1: I don't think jenkins is continous in the right sense. You have to push your changes for it to do a build.
09:41:52 <NickHu> Hi, I'm trying to install a package with cabal, but it seems to want to reinstall some of my existing packages (e.g. zlib) to use and older version of bytestring than I already have installed - the strange thing is, the original package I'm trying to install does not specify and version range for bytestring at all
09:41:55 <monochrom> interesting
09:43:21 <srhb> NickHu: One of its dependencies probably does
09:43:24 <bergey> NickHu: Maybe the package you are installing depends on one which in turn depends on bytestring?  Have you tried running cabal install with -v3?
09:43:24 <quchen> monochrom: http://blog.johantibell.com/2014/04/announcing-cabal-120.html
09:43:35 <quchen> There's now a Haddock section in the cabal config.
09:43:45 <KatZilla1> lispy: fsnotify  is just notification center
09:44:24 <NickHu> This is my output from cabal install git-annex: http://lpaste.net/102994
09:44:46 <KatZilla1> lispy: I ve tried Ruby Guard, but it cant start server (cabal run).
09:44:49 <NickHu> bergey: I just did that and it seems to thing cereal-0.4.0.1 doesn't like bytestring-0.10.4.0
09:44:57 <NickHu> [149] rejecting: cereal-0.4.0.1/installed-617... (conflict: cereal => bytestring==0.10.4.0/installed-7de..., aeson-0.7.0.3:new-bytestring-builder => bytestring<0.10.4.0)
09:45:21 <KatZilla1> lispy: But when I force Guard to start listening server, it Guard crashesh on Deadlock
09:45:24 <NickHu> Ah, it's aeson
09:45:29 <NickHu> Should've read that more carefully
09:47:12 <lispy> KatZilla1: ah right. I can't really help right now, but I know you can build what you want with fsnotify because a co-worker wrote a little Haskell script to call make when files changes. It was so short that I don't think he bothered to put it on hackage or anything.
09:47:34 <jakex> :\
09:47:35 * hackagebot tidal-vis 0.1 - Visual rendering for Tidal patterns  http://hackage.haskell.org/package/tidal-vis-0.1 (AlexMcLean)
09:50:33 <KatZilla1> lispy: thx. I will do some research
09:51:18 <spacekitteh> is there a reason why the stream-fusion package hasn't been merged into base?
09:58:44 <SaBer> I'm finding this ridiculously hard to figure out: Can I return Infinity as a Float? If yes, how do I do it?
09:59:30 <quchen> > 1/0
09:59:31 <lambdabot>  Infinity
09:59:43 <quchen> > 1/0 :: Float
09:59:44 <lambdabot>  Infinity
10:00:06 <SaBer> Is there no direct way to return it? Do I have to divide by zero?
10:00:15 <quchen> Yes.
10:00:19 <spacekitteh> > Infinity :: Float
10:00:20 <lambdabot>  Not in scope: data constructor ‚ÄòInfinity‚Äô
10:00:23 <spacekitteh> =[
10:00:36 <SaBer> is there a good reason for this?
10:01:08 <supki> > 10**309
10:01:09 <lambdabot>  Infinity
10:01:10 <quchen> Infinity isn't a number, it's used as the concept of a divergent operation in floats. What would you want to do with Infinity?
10:01:34 <hiptobecubic_> a fold?
10:02:15 <quchen> SaBer: For checking whether something is infinite, use isInfninite.
10:02:17 <quchen> :t isInfinite
10:02:17 <monochrom> it was thought that not all computers do IEEE 754, i.e., not all computers provided infinity
10:02:18 <lambdabot> RealFloat a => a -> Bool
10:02:19 <SaBer> I have straight pieces and curved pieces, I want to make a function that returns the radius
10:02:52 <SaBer> so I thought Infinity would be a good value to return for the straight pieces
10:02:58 <monochrom> I agree
10:03:40 <quchen> I think "data Curvature = Straight | Radius Int" would be a better representation.
10:03:47 <quchen> s/Int/Double/
10:04:21 <deweyvm> flood fill on a 200x200 grid should be near instantaneous no matter the shape inside right?
10:04:52 <monochrom> that depends on whether you're talking to me or to Lt Cmdr Data
10:05:05 <armlesshobo> anybody want an invite to keybase.io?
10:05:11 <armlesshobo> i have 4 invites available
10:05:19 <deweyvm> haha
10:05:28 <deweyvm> mine takes over 3 minutes and i cant figure out why
10:06:08 <NickHu> armlesshobo: I wouldn't mind one if you don't mind
10:06:10 <sm> armlesshobo: sure
10:06:28 <armlesshobo> pm me an email to send it to
10:06:39 <deweyvm> oh dear i believe i found it
10:06:49 <deweyvm> im calling zipWithIndex on every neighbor query
10:07:18 <r444> armlesshobo: i'd really like one
10:07:19 <spacekitteh> quchen: but then you run into trouble with curved manifolds. What's straight there?
10:07:40 <armlesshobo> r444: pm me an email please :)
10:08:00 <quchen> spacekitteh: Paths that satisfy the geodesic equation, of course.
10:08:17 <armlesshobo> NickHu, sm: email has been sent
10:08:19 <spacekitteh> yeah but isn't that kinda stretching the definition of straight?
10:08:35 <quchen> data Curvature = RiemannTensorInNDimensions Double Double Double Double Double ‚Ä¶
10:09:28 <spacekitteh> Riemann tensors would be a great example for dependant types
10:09:29 <NickHu> armlesshobo: Thank you
10:10:13 <deweyvm> down to 0.2s now nvm!
10:10:28 <monochrom> if you stretch it more, it becomes closer to straight :)
10:10:33 <spacekitteh> hehe
10:10:46 <quchen> deweyvm: If your grid is [[Entry]], then you should consider a Vector-based implementation, deweyvm.
10:10:53 <fragamus> http://lpaste.net/102997
10:11:04 <quchen> A singly linked list of singly linked lists isn't a very good representation for a 200*200 picture.
10:11:09 <deweyvm> quchen: i use a Vector backed custom data type
10:11:36 <deweyvm> along with Data.Set and Data.Seq for the algorithm
10:11:50 <quchen> Alright then, just wanted to make sure List wasn't the bottleneck here.
10:11:56 <deweyvm> :)
10:12:02 <quchen> No offense ;-)
10:12:08 <deweyvm> none taken
10:12:53 <quchen> While we're at it, flood fill might be a good candidate for using ST to do mutable updates on the Vector.
10:13:27 <fragamus> can someone have a look at my paste
10:13:37 <deweyvm> still havent gotten around to learning how to use state
10:14:03 <quchen> deweyvm: You mean State?
10:14:09 <deweyvm> yes
10:15:15 <deweyvm> algorithm looks like this atm http://pastebin.com/7U61pjWq
10:15:40 <quchen> fragamus: 7.0 doesn't have type Double, it has type ‚Ä¶
10:15:42 <quchen> :t 7.0
10:15:43 <lambdabot> Fractional a => a
10:15:51 <fragamus> oh
10:16:23 <quchen> (/) on your Vector is presumably component-wise division, and 7.0 is converted to V2 7.0 7.0
10:17:22 <fragamus> i want b to be coverted too
10:18:16 <supki> :t realToFrac
10:18:16 <lambdabot> (Real a, Fractional b) => a -> b
10:20:32 <fragamus> I just did V2 b b
10:20:44 <fragamus> thanks
10:27:38 * hackagebot active 0.1.0.13 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.13 (BrentYorgey)
10:30:26 <vshenoy> hi guys
10:31:35 <vshenoy> i am vikram, a programmer from india
10:31:44 <deweyvm> hi vikram
10:34:00 <vshenoy> hi deweyvm
10:34:48 <vshenoy>  i am learning haskell and as a part of this am translating examples in miranda language given in the 'why functional programming matters' paper by John Hughes
10:35:16 <vshenoy> i was wondering if its ok to post literate haskell version of this paper to github
10:35:45 <vshenoy> i tried to reach professor Hughes at his email address in his home page
10:36:14 <vshenoy> but did not get a reply (probably it slipped through)
10:38:00 <duhj> I'm having an issue with conduit-http, i'm doing this call applyBasicAuth user pass $ fromJust $ parseUrl "https://theurl" , as is written on hackage, but when i try to compile i get "Couldn't match expected type `m0 t0' with actual type `Request'
10:38:40 <duhj> anyone have any guidance on using applyBasicAuth with conduits?
10:41:39 <glassem> is there a function that will give me the id of a value?
10:41:46 <glassem> like the memory address or something
10:42:06 <glassem> I'm lazy and don't want to generate and pass around ids everywhere
10:42:16 <glassem> and would prefer to just use the value memory address
10:45:25 <supki> duhj: could you paste the exact code you're trying to compile?
10:45:43 <supki> @paste
10:45:43 <lambdabot> Haskell pastebin: http://lpaste.net/
10:46:11 <gamegoblin> Hey everyone. I‚Äôm trying to make headers in haddock ‚Äî the markdown guide says to use = through ======= for h1 through h6 headers. They are just rendering as equals signs though. Ideas?
10:46:13 <duhj> sure
10:47:15 <CindyLinz> glassem: this one? http://www.haskell.org/ghc/docs/7.6.2/html/libraries/base-4.6.0.1/Foreign-StablePtr.html
10:49:32 <dolio> gamegoblin: Haddock isn't markdown, if that's what you're saying.
10:49:51 <gamegoblin> markup, rather
10:49:58 <gamegoblin> see: http://www.haskell.org/haddock/doc/html/ch03s08.html#idp1371110852
10:50:10 <gamegoblin> It says to use the == sign, but it‚Äôs just not doing anything...
10:50:12 <dolio> Oh. As long as you're reading an actual haddock guide.
10:50:23 <dolio> I don't know the answer.
10:50:27 <duhj> supki: http://lpaste.net/102998
10:51:14 <supki> duhj: change  initReq <-  to  let initReq =
10:51:22 <mmmm> gamegoblin: show us the code
10:51:39 <supki> duhj: applyBasicAuth isn't a monadic action
10:51:52 <duhj> oh whooops
10:52:05 <duhj> i missed it there's  a fromJust in there
10:52:31 <supki> well, that too
10:53:03 <duhj> supki: sorry that was wrong code : http://lpaste.net/103002
10:53:57 * geekosaur snorts. you know how badly markdown has failed when people start using it as a generic term for unrelated markup systems
10:54:38 <duhj> okoh ok
10:55:26 <supki> duhj: ok, so it's either  let initReq = applyBasicAuth user pass $ fromJust $ parseUrl ...  or  initReq <- applyBasicAuth user pass $ parseUrl ...  depending on which monad you want failure in
10:55:33 <supki> oops
10:55:38 <vshenoy> guys any thoughts ? should it be ok to post literate haskell version of whyfp paper to github ?
10:55:55 <supki> the latter is  initReq <- applyBasicAuth user pass <$> parseUrl ..., I think
10:56:03 <gamegoblin> geekosaur: any idea why the markUP isn‚Äôt working, though?
10:56:04 <duhj> supki: wow thanks alot it works
10:56:36 <duhj> supki: i understand it better now
10:56:40 <geekosaur> not really, no
10:58:16 <identity> I'm workign on some old code of mine that hasn't been worked on since conduit was split up differently. It contains a type signature of the form: foo :: MyType -> Application IO
10:58:34 <identity> it seems Application doesn't exist anymore. I'm not sure what to replace it with
10:59:20 <identity> Granted, I can figure a type signature out using inference, but it uses some typeclass in some auxiliary library and it doesn't quite look like it's supposed to used like that
10:59:28 <orion> https://addons.mozilla.org/en-US/firefox/search/?q=hoogle&appver=27.0&platform=other <-- "No results found."
10:59:29 <orion> sadface
11:00:21 <identity> orion: use duckduckgo
11:00:25 <identity> then it's just !hoogle
11:00:30 <identity> (and !hackage and many more)
11:01:16 <orion> oh wow
11:01:24 <orion> That's cool.
11:04:46 <osa1> I want to call ghc --make using a cabal sandbox for libraries, how can I do that?
11:05:58 <no-n> @hoogle off
11:05:59 <lambdabot> package off-simple
11:05:59 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects type Offset = GLintptr
11:05:59 <lambdabot> GHC.Constants oFFSET_bdescr_blocks :: Int
11:08:55 <MagneticDuck> !
11:09:42 <osa1> hmm I tried $GHC_PACKAGE_PATH but now it can't even find Prelude
11:16:43 <osa1> -package-db
11:16:46 <osa1> found it
11:17:42 * hackagebot tidal 0.3.7 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.3.7 (AlexMcLean)
11:17:44 * hackagebot sloane 1.7 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-1.7 (AndersClaesson)
11:17:46 * hackagebot tidal-vis 0.1.1 - Visual rendering for Tidal patterns  http://hackage.haskell.org/package/tidal-vis-0.1.1 (AlexMcLean)
11:24:15 <osa1> how can I force cabal to not use system-wide installed C libs?
11:27:14 <geekosaur> I think we need more detail... because you're not going to get very far at all if you are planning to exclude libc
11:33:59 <vshenoy> please let me know about this or if i can ask some where else
11:34:06 <vshenoy> signing off, bye.
11:34:19 <jesyspa> I'm using the Bound package and would like to allow abstraction for some types and prohibit it for others.  I came up with this http://lpaste.net/103004 solution, but it fails due to the kind being infinite.  Is there a (better) way to do this?
11:35:13 <KatZilla1> hi there ) ! I am trying to imort Prelude.IO and got this error     Could not find module `Prelude.IO'
11:35:13 <KatZilla1>     Perhaps you meant
11:35:13 <KatZilla1>       Prelude (from base)
11:35:13 <KatZilla1>       Prelude (needs flag -package haskell2010-1.1.1.0)
11:35:13 <KatZilla1>       Prelude (needs flag -package haskell98-2.0.0.2)
11:35:13 <KatZilla1>     Use -v to see a list of the files searched for.
11:35:23 <KatZilla1> where should i set this flag ?
11:35:49 <mmmm> ghci -v <fname>
11:36:26 <KatZilla1> mmmm: I am using cabal repl
11:36:31 <KatZilla1> should it work ?
11:36:40 <mzero> KatZilla1: is there a reason you need to import Prelude.IO over just what is in Prelude?
11:36:57 <mzero> and ... not sure what you mean by "cabal repl" - cabal doesn't provide a reply
11:37:01 <mzero> er a repl
11:37:25 <mmmm> with sandboxes
11:37:27 <KatZilla1> mzero: Yes. I am trying to implement hFSevent to reload code and start scotty server, when file is changed
11:37:33 <mzero> and -v isn't really going to help you -
11:37:48 <KatZilla1> Yes. I use sandbox
11:38:19 <KatZilla1> mzero: http://hackage.haskell.org/package/fsnotify-0.0.11/docs/System-FSNotify-Devel.html
11:38:28 <KatZilla1> here is an example, of using "system" fn
11:38:45 <mzero> I'm still not clear what you need from Prelude.IO
11:39:28 <mzero> normally everyting in Prelude.IO is already exported from Prelude --- and that is imported automatically
11:40:30 <KatZilla1> "system" fn
11:40:34 <KatZilla1> to use shell
11:41:06 <KatZilla1> mzero: sry
11:41:11 <mzero> System.Process
11:41:11 <KatZilla1> bad info
11:41:19 <KatZilla1> I know
11:41:28 <mzero> Mind you, system is a depricated function
11:41:59 <mzero> but you can run commands, using the shell, using the other functions in that module
11:42:07 <KatZilla1> mzero: http://hackage.haskell.org/package/fsnotify-0.0.11/docs/System-FSNotify-Devel.html
11:42:16 <KatZilla1> look at treeExtExists
11:42:23 <KatZilla1> do you see "when" fn ?
11:42:57 <mzero> you mean the action argument?
11:43:15 <mzero> yes
11:43:40 <mzero> you are trying to write a function for that argument that takes a FilePath, and executes some other process?
11:45:01 <KatZilla1> mzero:
11:45:03 <mzero> if so - try callProcess or callCommand in System.Process -- that is the right way to go about it... you can use createProcess, shell, and proc, for even more control
11:45:03 <KatZilla1> Not in scope: `Prelude.when'
11:45:04 <KatZilla1>     Perhaps you meant one of these:
11:45:04 <KatZilla1>       `Prelude.even' (imported from Prelude),
11:45:04 <KatZilla1>       `Prelude.pred' (imported from Prelude),
11:45:04 <KatZilla1>       `Prelude.asin' (imported from Prelude)
11:45:17 <mzero> when in in Control.Monad
11:45:44 <mzero> KatZilla1: use this tool for finding things: http://www.haskell.org/hoogle/?hoogle=when
11:46:33 <KatZilla1> mzero: livereload.hs:22:5:
11:46:33 <KatZilla1>     Couldn't match type `[]' with `IO'
11:46:33 <KatZilla1>     Expected type: IO ()
11:46:33 <KatZilla1>       Actual type: [()]
11:47:02 <mzero> please paste your code in the pastebin: s: http://lpaste.net/new/haskell
11:48:17 <mzero> your function needs to take a FilePath and return IO () --- that is, it's an action that returns (), (essentially a void imperative function)
11:50:26 <neumond> can mutable values be avoided at all?
11:50:39 <ezrios> ugh
11:50:54 <ezrios> is there a way to find out who depends on a cabal package?
11:51:10 <ezrios> I accidentally installed something globally and not in a sandbox
11:51:21 <ezrios> and now I want to get rid of it
11:51:51 <mzero> neumond: yes
11:52:04 <gamegoblin> How do you namespace refer to an infix operator. e.g. I import something as C, and from it I import a function called <?>  Do I refer to it as C.<?>   or C.(<?>) etc
11:52:12 <pavonia> ezrios: If you unregister a package, it will tell you if other packages depend on it
11:52:18 <mzero> ezrios: then you're only concerned with who depends on it in the global package list
11:52:42 <pavonia> gamegoblin: (C.<?>)
11:52:42 <quchen> :t (Prelude.+) -- gamegoblin
11:52:43 <lambdabot> Num a => a -> a -> a
11:52:49 <mzero> C.<?>
11:52:49 <gamegoblin> Thanks
11:52:58 <ezrios> pavonia: I see, thanks
11:53:45 <neumond> mzero: I have callback function, called by gtk. I need this function to make 2 actions: 1, 2, 1, 2, 1, 2 etc. Every call must do "toggled" action. So I want to avoid using mutable values here. Is it possible?
11:54:39 <mzero> well... not sure - is it easy to reset the callback function from within the callback itself?
11:55:22 <mzero> but there are several ways to use a mutable variable, but keep it so localized that "it's safe"
11:56:19 <neumond> so, you mean the clean, haskell-style solution is switching callback, right?
11:56:36 <ezrios> goddamn cabal is a piece of shit ._.
11:56:55 <mzero> well... no, it is even clean to use, say, and MVar
11:56:57 <neumond> thanks anyway, didn't think that direction
11:57:22 <pavonia> neumond: I'd just use an IORef/MVar, Gtk uses so much state it doesn't matter if there's one more or less :p
11:57:23 <mzero> The issue is what is clearer - and what implements the semantics you want
11:58:33 <pavonia> Redefining callbacks probably triggers a lot of other overhead internally
11:58:42 <neumond> it is not much about gtk, I've just been scared of perspective taunting my pure code every time I meet similar task
11:59:06 <mzero> so, imagine:     do { m <- newMvar (cycle [actionA, actionB]); setGtkCallback (modifyMVar_ m (\(a:as) -> a >> return as) }
11:59:58 <mzero> Here's my insight on this: The value isn't avoiding impure code entirely - the value is in localizing the impure code so much that it is correct by inspection
12:00:56 <mzero> consider the code above - the mutable variable is confined to that one do block - and not even available to the actions! All operations on that mutable variable are right there - and can't be anywhere else in the code
12:01:25 <mzero> so you can be certain that this confined use of a mutable variable does what you want, and can't possibly be affected by some code way elsewhere in the program
12:01:54 <mzero> THIS is the value of pure functional langague even in a non-pure context (like GTK... or the real world)
12:03:09 <MagneticDuck> any way to force a reinstall of a package that will break other packages and then automatically reinstall everything that was broken using cabal?
12:03:22 <mzero> sigh... no
12:03:40 <MagneticDuck> why the sigh?
12:03:48 <MagneticDuck> I mean =P
12:03:50 <mzero> because this should be easy
12:03:54 <MagneticDuck> well I know
12:04:06 <MagneticDuck> but I don't feel like making my own utility...
12:04:07 <neumond> thank you mzero
12:04:12 <MagneticDuck> just wondering if there's some cool default cabal command thingy
12:04:13 <sm> MagneticDuck: https://gist.github.com/simonmichael/1185421 can clean the broken packages, then you can just reinstall lens :)
12:04:57 <sm> s/lens/BIG-DEPENDER-OF-CHOICE/
12:06:04 <MagneticDuck> mzero: but anyway, they didn't implement a simple feature in cabal to do that for me because it's too easy to scrape the warning of cabal install <package> for the broken packages in question and reinstall them?
12:06:30 <MagneticDuck> hm.
12:08:31 <aloiscochard> where does cabal store the package list from hackage?
12:09:31 <lispy> aloiscochard: it's in ~/.cabal somewhere
12:09:50 <MagneticDuck> aloiscochard: I'm looking around in there.. =P
12:09:53 <aloiscochard> lispy: well... that this somewhere that I'm after :-)
12:10:19 <MagneticDuck> .cabal/packages/hackage.haskell.org/00-index.cache
12:10:21 <aloiscochard> looks like it's not anymore in 'packages'
12:10:32 <aloiscochard> MagneticDuck: I just did 'cabal update' and that file don't exist
12:10:38 <MagneticDuck> interesting
12:10:41 <mzero> are you on Mac, aloiscochard -- then look in ~/Library/Haskell
12:10:41 <aloiscochard> (I'm out of a sandbox)
12:10:47 <aloiscochard> mzero: no on linux
12:11:03 <MagneticDuck> yeah then it's there
12:11:09 * aloiscochard retry
12:11:19 <MagneticDuck> here, I can DCC you the cache file =P
12:11:31 <aloiscochard> it' definitely not with cabal 1.20 MagneticDuck
12:11:57 <aloiscochard> I did a rm -rf of the folder, then 'cabal update', and nothnig
12:12:13 <MagneticDuck> uhh?
12:12:40 <lispy> aloiscochard: huh. I wouldn't expect them to change that.
12:13:00 <lispy> aloiscochard: Maybe list all the files under there that have changed in the last few minutes?
12:13:01 <MagneticDuck> aloiscochard: find .cabal | grep index
12:13:08 <MagneticDuck> oops
12:13:17 <MagneticDuck> 00-index
12:13:18 <MagneticDuck> or something
12:13:23 * MagneticDuck is out of ideas
12:13:30 <aloiscochard> cabal/.cabal/packages/hackage.haskell.org/
12:13:44 <aloiscochard> sorry, I wanted to say it's there.. but in a double '.cabal/.cabal'
12:13:47 <MagneticDuck> no 00-index.cache?
12:13:51 <aloiscochard> damn, why so much hate
12:14:05 <MagneticDuck> um
12:14:07 <MagneticDuck> where's the hate?
12:14:57 <MagneticDuck> aaaanyway
12:14:59 <aloiscochard> MagneticDuck: the hate is that I just finished writing a tools that generate tags for vim for dependencies, and when I investigate why some dep are not resolved
12:15:14 <aloiscochard> it's because cabal use cache in two different places :-s
12:15:17 <lispy> using a double .cabal/.cabal directory sounds like a pathing bug
12:15:20 <MagneticDuck> dafaq
12:15:30 <aloiscochard> must be with my config, but it's definitely a regression
12:15:58 <tristan__> whats with some haskell projects using 4 version numbers
12:16:19 <aloiscochard> MagneticDuck: lispy thanks for the help
12:16:20 <quchen> 1.2.3.4, tristan__?
12:16:38 <MagneticDuck> the cabal version number specs say that three version numbers are defined in their usage, the other version numbers can be doin' whatever the author wants them to do
12:16:59 <MagneticDuck> they can even be like a mini-checksum for the package :D
12:17:04 <MagneticDuck> ^ good idea
12:17:09 <MagneticDuck> ^ sarcasm
12:17:55 * aloiscochard symlink 'packages' in despair
12:18:28 <MagneticDuck> symlink is always the answer
12:27:48 * hackagebot pubnub 1.0.0 - PubNub Haskell SDK  http://hackage.haskell.org/package/pubnub-1.0.0 (tsloughter)
12:30:30 <tristan__> hm, when I run 'cabal haddock' locally it generates docs fine, why are the modules on hacakge not links to their docs? do I have to do something more?
12:30:59 <MagneticDuck> you have to show it love
12:31:53 <mzero> when did you upload? it takes some time for hackage to do this I think
12:32:26 <MagneticDuck> that's a pretty recurring problem
12:32:39 <MagneticDuck> basically all the packages I encounter have the latest version without docs :<
12:32:58 <tristan__> mzero: I just uploaded
12:33:02 <tristan__> ah
12:33:37 <tristan__> hm, though the 0.1.0 version also has no docs and it was uploaded yesterday
12:33:47 * aloiscochard have finally found his 'real' cabal folder
12:33:55 <thoughtpolice> Hackage does builds over time, not instantly. so it will appear later most likely. if you're really impatient, you can use CURL to directly upload documentation.
12:34:06 <thoughtpolice> https://github.com/haskell/hackage-server/issues/56
12:34:22 <tristan__> cool, thanks
12:34:32 <aloiscochard> so I have ~/cabal ~/.cabal and ~/.cabal/.cabal ... if anyone had similar issues I'm interested
12:35:10 <MagneticDuck> aloiscochard: try reinstalling linux!
12:35:50 <aloiscochard> MagneticDuck: I *never* reinstall it, that's precisely why I moved from ubunto to arch - and one might reply, precisely why I'm having issues ;-)
12:36:14 <aloiscochard> anyway, symlink to the rescue again
12:41:54 <aloiscochard> so that's it *it work*, if there is some vimers around I have a working tool that generate tags file from sources of all deps of a cabal project
12:45:49 <JagaJaga> aloiscochard: it's better than lushtags?
12:47:16 <aloiscochard> JagaJaga: I believe it's very different, lushtags sounds like a tag generator. My tool call a tag generator (here ctags) on source of dependencies and then aggregate per project.
12:47:31 <aloiscochard> JagaJaga: maybe lushtags do both? (doesn't look like according to the doc)
12:50:57 <Platz> if only emac's hosting of ghci supported tab completion of keywords, wouldn't ever leave it then
12:51:40 <Wizek> Good morning!
12:52:51 <Wizek> What can you suggest if I want to run `ghc -threaded Spec.hs && ./Spec` every time I save my Spec.hs file?
12:53:19 <aloiscochard> Wizek: I have a custom script that use inotifywait
12:53:41 <aloiscochard> a kind of continuous mode for cabal
12:54:27 <Wizek> aloiscochard: Is it available through cabal-install?
12:54:42 <aloiscochard> Wizek: no, it's a custom script
12:55:04 <tobiasgw> I'm trying to understand the type ActionM in Scotty
12:55:21 <aloiscochard> Wizek: do 'man inotifywait'
12:55:37 <aloiscochard> Wizek: you might have to install it
12:56:20 <Platz> I was using ruby and guard for that, but i'm sure are better solutions
12:56:28 <tobiasgw> this is how the type is defined: type ActionM = Web.Scotty.Types.ActionT      Data.Text.Lazy.Internal.Text      IO
12:57:35 <identity> using ruby and guard would make it very easy to do
12:57:36 <tobiasgw> man, I don't even know how to pose a question
12:57:43 <identity> I ran something similar once before I learned of ghcmod-vim
12:57:45 <tobiasgw> never mind
12:58:03 <identity> tobiasgw: doesn't hurt to try?
12:58:32 <tobiasgw> well, I'm trying to understand the type definiton
12:58:42 <tobiasgw> ActionT Text IO
12:59:04 <aloiscochard> identity: ghcmod-vim support running of test suites as well?
12:59:07 <tobiasgw> ... and is ActionM a monad?
12:59:08 <Platz> example guardfile for running _test.hs files on save in subdirs https://gist.github.com/jonschoning/11123627
12:59:15 <identity> aloiscochard: no, not that I know of unfortunately
12:59:25 <identity> aloiscochard: but that doesn't quite sound like something you would like to do every time you save
12:59:42 <identity> tobiasgw: I don't know if it is, but I would guess so. I don't know scotty
12:59:43 <aloiscochard> identity: well, that sound like we don't have the same flow :-)
13:00:26 <aloiscochard> identity: not necessary *all* tests, but at least the part you are working on
13:00:30 <tobiasgw> identity: how would you explain the type definition "ActionT Text IO"? Or how would you go about investigating it?
13:00:35 <aloiscochard> identity: sometime compiling is enough (and I prefer that)
13:01:40 <identity> tobiasgw: I would look at the source, if that's what you mean. On hackage. or by fetching the source with cabal
13:02:15 <identity> tobiasgw: But ActionM is a type synonym for ActionT parametrized over those two types
13:02:24 <aloiscochard> generic continous shell script: http://lpaste.net/103005 /cc Wizek
13:02:25 <identity> (Text and IO)
13:02:54 <identity> tobiasgw: Where ActionT is most likely a transformer monad wrapper around some state or some such(That is what the T says)
13:02:55 <tobiasgw> aha! So Text and IO are type params?
13:03:23 <identity> Yes. I think that is the correct term, anyway
13:03:44 <identity> so somewhere, there's most likely something like: newtype ActionT a b = ActionT { .. something .. }
13:04:09 <tobiasgw> or "data ActionT ab = ActionT ..."?
13:04:23 <tobiasgw> I meant "ActionT a b ..."
13:04:32 <tobiasgw> yeah
13:04:34 <identity> Yes, in theory.
13:04:39 <tobiasgw> cool
13:04:51 <lispy> in that example, IO is a type parameter. It's also a type constructor because it too takes a type parameter, like in IO ()
13:05:22 <tobiasgw> Yup
13:07:51 * hackagebot app-settings 0.1.0.1 - A library to manage application settings (INI file-like)  http://hackage.haskell.org/package/app-settings-0.1.0.1 (EmmanuelTouzery)
13:09:11 <tobiasgw> so when you know that you have a function (called "get" in this example) with the signature "get :: RoutePattern -> ActionM () -> ScottyM ()", how would you go about figuring out what to pass it
13:09:33 <tobiasgw> You need to understand hwo RoutePattern and ActionM works, right?
13:09:45 <identity> tobiasgw: Yes. I'd look at the hackage documentation for those two types
13:09:48 <johnw> tobiasgw: it would look like:
13:09:55 <johnw> get PATTERN $ do ACTION ...
13:09:57 <johnw> typically
13:10:15 <johnw> like: get "index.html" $ do html "<P>Hello!</P>"
13:10:24 <identity> tobiasgw: I think scotty was covered in 24 days of hackage
13:10:25 <johnw> (the "do" here just for demonstration)
13:10:33 <tobiasgw> but you're depending on the written documentation for understanding that, right?
13:10:40 <identity> indeed it was.
13:10:41 <identity> yes
13:10:43 <johnw> of course, why would I not read documentation?
13:10:47 <identity> http://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html
13:11:02 <tobiasgw> johnw: because it would be awesome not to :)
13:11:11 <identity> tobiasgw: But not all packages are documented very well.
13:11:17 <identity> tobiasgw: Why would it be awesome?
13:11:43 <tobiasgw> because it puts less pressure on the quality of the documentation
13:11:52 <johnw> uhh
13:11:55 <johnw> that makes no sense
13:11:59 <identity> tobiasgw: .. yeah, what he said
13:12:10 <johnw> the fact that people read documentation is unfair pressure on documentation writers?
13:12:51 * hackagebot app-settings 0.1.0.2 - A library to manage application settings (INI file-like)  http://hackage.haskell.org/package/app-settings-0.1.0.2 (EmmanuelTouzery)
13:13:29 <tobiasgw> I just wish the code was sort of self explanatory
13:14:09 <identity> tobiasgw: Well, I'd argue that Haskell's type system is the closest you could ever get to code documenting itself
13:14:29 * lispy submits patches to cabal so rarely that he didn't realize he had contributed to the 1.20 release until reading the release notes :)
13:14:33 <identity> and that you have a bigger chance of being able to understand a library without docs by just looking at the types in Haskell more than in any other language
13:14:35 <tobiasgw> identity: yes, exactly, and I want to push that even further
13:15:10 <tobiasgw> because documentation is just text and unlike code there are no compilers, linters or tests for text
13:15:19 <lispy> liquid haskell adds an interesting dimension to self-documenting types.
13:15:45 <quchen> Self-documenting code is a nice idea, like communism. And works just as well in practice.
13:15:52 <lispy> http://goto.ucsd.edu:8090/index.html
13:16:03 <identity> tobiasgw: there is doctest
13:16:03 <geekosaur> fly in that ointment is that without dependent types, the type can't actually tell you *everything* you need to know
13:16:15 <identity> which is .. something like that
13:16:48 <identity> tobiasgw: But in reality, you can't really know what's going on without documentation or by looking at the code. I mean, for all you know, the get action in scotty could delete your home directory
13:16:58 <lispy> geekosaur: I don't think dependent types are necessary or sufficient here.
13:17:12 <lispy> geekosaur: they can help if used well
13:17:20 <identity> So, you could go ahead and download all the code and understand all of it and so on, or you can just ... look at documentation and assume that it's correct
13:17:35 <geekosaur> probably not, but haskell types as is are certainly not sufficient
13:18:59 <lispy> documentation is still one of the best ways to express motivation, intention, and caveats.
13:19:53 <lispy> code and formal specifications (like dependent types) are good at capturing properties, invariants, and other such mathematical details
13:21:58 <tobiasgw> identity: that's true, but given that I know what get does and all I want to know is what to pass it, documentation should not be strictly necessary (in my dream world)
13:22:18 <identity> I disagree
13:24:03 <Eduard_Munteanu> Wow, I really can't go back to Parsec after getting too comfortable using Attoparsec.
13:24:23 <lispy> Parsec has some serious flaws :(
13:24:39 <lispy> That whole try business is tedious.
13:25:16 <joelteon> But it *can* parse things that aren't strings
13:25:17 <Eduard_Munteanu> Not only that, but there are a bunch of inefficient combinators instead of stuff like takeWhile.
13:26:04 <Eduard_Munteanu> joelteon: indeed. Although Attoparsec can be layered as well with some care.
13:26:14 <lispy> joelteon: so can parsers made by traditional lalr parser generators :) You just need the right lexer.
13:26:56 <Eduard_Munteanu> Ah, regarding lexers, it's rather annoying the only alternative is Alex, which is rather tied to [String] as well.
13:27:41 <Eduard_Munteanu> (Well, you can wire it to use Text / ByteString, just not out of the box)
13:31:53 <epta> Any happy cygwin users?
13:32:29 <epta> Trying to install @hackage double-conversion and got "can't load .so/.DLL for: stdc++.dll (addDLL: could not load DLL)" :[
13:32:39 <epta> What package should I install for that?
13:32:55 <epta> I've already installed libstdc++6
13:33:00 <Heffalump> epta: cygwin as opposed to mingw?
13:33:08 <epta> Not sure, prolly
13:36:03 <Heffalump> I'd recommend having mingw available, it's what GHC actually uses to build etc
13:36:39 <epta> what is the difference between mingw and cygwin?
13:37:11 <klrr_> why do i get "finset.hs:10:4: parse error on input `fZ'" when i try compile this? http://lpaste.net/103007
13:37:38 <Heffalump> epta: mingw is more of a Windows native view of the world and therefore doesn't support some of the UNIXy stuff.
13:38:07 <Heffalump> I'm not sure of the precise details but I think cygwin-built binaries generally have a dependency on a cygwin DLL whereas mingw-built ones don't
13:38:31 <Heffalump> many Haskell thing seem to build happily from either shell, but I have both mingw and cygwin installed and fallback to mingw if I see any strangeness
13:39:05 <epta> Heffalump: any conflict issues?
13:39:23 <sepp2k> klrr_: Because data constructors need to start with a capital letter.
13:39:25 <Heffalump> epta: double-conversion installs fine for me on MingW (Windows 7), FYI
13:39:40 <klrr_> sepp2k: oh, forgot that! thanks :)
13:39:45 <epta> Heffalump: ok, lemme try mingw
13:39:54 <Heffalump> epta: with having both installed? Not really. You do end up having two home directories which was annoying - I did something to point cygwin and the MinGW one but I can't remember what I did now.
13:40:14 <Heffalump> and you can get quite confused about not being able to do things in one or the other shell :-)
13:40:44 <epta> ok, I'll live without double-conversion
13:41:17 <Heffalump> I guess in general things that need non-Haskell libraries are the most likely to misbehave
13:59:38 <lispy> Heffalump: another difference is that mingw doesn't provide a working tty() implementation so some types of job control just don't work.
14:00:14 <lispy> on the other hand, because cygwin tries to implement unix you get all their bugs :)
14:04:50 <ezoo> how can i use graphics.gloss? import fails
14:06:40 <ezoo> nvm it wasn't installed
14:07:53 <epta> lispy: you're using Windows GHC build inside a cygwin?
14:08:58 <bjorkintosh> why not just run the damned thing in a virtualbox, instead of fooling around with cygwin or mingw?
14:09:10 <bjorkintosh> if you absolutely have to use windows, ie.
14:09:51 <lispy> epta: I use the 32bit ghc on windows without cygwin.
14:09:59 <lispy> epta: I mostly do it to test compatibility.
14:10:14 <lispy> epta: osx and linux work much better for actual development (windows tends to get neglected)
14:10:40 <epta> bjorkintosh: because I need to use haskell tools or smth builded with ghc over a windows files
14:10:58 <epta> lispy: sad but true
14:11:18 <bjorkintosh> epta, weird. is it for production or for your own stuff?
14:11:58 <epta> It's my own tools over a production code :]
14:12:07 <bjorkintosh> ah. you're making do.
14:12:56 * hackagebot tidal-vis 0.1.2 - Visual rendering for Tidal patterns  http://hackage.haskell.org/package/tidal-vis-0.1.2 (AlexMcLean)
14:14:32 <vozz> Is there a charting/plotting library that lets me specify pixel width for candlestick/box diagram/vertical line type things? http://a.pomf.se/noqecn.png I did this with the package "Chart", and the width of the candlestick and the linewidth are both set to 1, but it's clearly not 1 pixel, and not aligned with the pixels.
14:15:00 <joelteon> Is there a library that can parse something into a Dec?
14:15:03 <joelteon> a template-haskell one
14:15:40 <pavonia> haskel-src-exts?
14:15:48 <joelteon> no, they have their own ADT thing
14:16:16 <pavonia> Ah, there was a conversion package
14:16:45 <joelteon> Oh, haskell-src-meta
14:17:08 <pavonia> yeah, that
14:20:13 <pavonia> ?seen mmorrow
14:20:14 <lambdabot> mmoRrOW
14:26:01 --- mode: Cale set -o Cale
14:32:16 <abhaykumar> join
14:33:57 <byorgey> vozz: I think you'll be able to do that more easily with Chart + the next release of diagrams, which will let you specify widths in pixels. I don't know of anything which lets you do that at the moment.
14:35:55 <SwashBuckla> A while back, I was struggling with this: http://lpaste.net/102897
14:36:04 <SwashBuckla> I have since found a workaround: http://lpaste.net/103010
14:36:39 <SwashBuckla> I still don't know why the error was occuring, but this workaround allows me to achieve my result, with the help of a Makefile for output formats
14:47:56 <mmmm> SwashBuckla: You can't have a filter from Block -> IO [Block]
14:54:15 <SwashBuckla> mmmm: why not?
14:54:21 <SwashBuckla> it compiles
14:55:12 <SwashBuckla> mmmm: also, what would be the solution that allows me to be format agnostic? my current solution is hardcoded to output markdown
14:55:25 <mmmm> Filters have to have type a -> a or a -> IO a
14:56:37 <mmmm> hmm actually, I don't think that's true
14:56:40 <mmmm> lemme try and find where I read it
14:57:01 <startling> mmmm, it's not "filter"
14:57:09 <mmmm> I know
14:58:24 <mmmm> SwashBuckla: http://hackage.haskell.org/package/pandoc-types-1.12/docs/Text-Pandoc-JSON.html
14:58:47 <mmmm> althought it seems to work with Inline -> [Inline]
14:59:43 <mmmm> so ideally you want to be able to include latex source for example?
15:00:09 <mmmm> and compile the markdown to latex and have it process correctly?
15:00:49 <gamegoblin> Hmmmm getting really sick of the haddock documentation being wrong‚Ä¶ trying to use __bold text__ and it‚Äôs just rendering as underscores...
15:03:47 <SwashBuckla> mmmm: yea
15:03:53 <SwashBuckla> language agnosticism please!
15:04:39 <mmmm> look at the documentation where it says "an alternative is to use the type..."
15:04:42 <mmmm> that should be what you want
15:05:32 <ezoo> i've installed the cabal package gloss-examples, how can i access the commands gloss-easy etc.? they're not in my prompt
15:05:35 <mmmm> be warned though - this doesn't work like \input in latex as this input happens during the parsing.
15:13:13 <tobiasgw> is there a "local hoogle" in GHCi? So I can say "list all functions that return a String (in the currently loaded modules)"?
15:13:39 <shachaf> No.
15:13:49 <shachaf> You can install Hoogle but you'll have to specify an index for it in advance.
15:14:05 <shachaf> You can use :browse to look at everything exported from a particular module.
15:16:04 <tobiasgw> yeah, right now I use :browse and then grep for the types I'm looking for
15:16:11 <SwashBuckla> mmmm: this isn't really what I wanted
15:16:22 <SwashBuckla> I want it to be agnostic input and output
15:16:25 <SwashBuckla> like the other filters
15:18:57 <mmmm> Can you please (quickly) explain exactly it is that you want
15:22:41 <gamegoblin> something about running `cabal install cabal-install` makes me giggle
15:23:02 * hackagebot JustParse 1.0 - A simple and comprehensive Haskell parsing library  http://hackage.haskell.org/package/JustParse-1.0 (grantslatton)
15:23:21 <hae> We are not amused.
15:23:54 <mmmm> SwashBuckla: I want to help you but I need to go very soon
15:23:58 <SwashBuckla> mmmm: ok
15:24:15 <SwashBuckla> ok so I want to be able to insert external markdown files into an existing markdown file
15:24:25 <SwashBuckla> but the eventual output format can be anything
15:27:00 <mmmm> SwashBuckla:  embedTags = string "{{" *> anyChar `manyTill` (try $ string "}}")
15:27:02 <mmmm> woops
15:27:36 <mmmm> SwashBuckla: http://lpaste.net/101413
15:31:49 <SwashBuckla> thanks ;)
15:33:17 <mmmm> If you have any more pandoc questions it's probably best to ask on the pandoc-discuss mailing list
15:33:43 <SwashBuckla> ok :)
15:37:04 <orion> What is the "Haskell Application Server"?
15:37:17 <SwashBuckla> a barebones web framework
15:37:28 <mietek> https://github.com/acowley/roshask/wiki/Dynamic-Linking
15:37:40 <mietek> Does anyone know if the state of dynamic linking is still as described here?
15:38:04 <mietek> I.e. not happy with Template Haskell
15:38:17 <orion> SwashBuckla: Is it analogous to Ruby+Rack?
15:43:04 * hackagebot HTTP 4000.2.13 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.13 (GaneshSittampalam)
16:01:31 <tobiasgw> orion: I *think* WAI is to Haskell what Rack is to Ruby
16:02:22 <tobiasgw> orion: although I'm not sure if Rack is an actual implementation or just an interface?
16:03:47 <srhb> tobiasgw: That sounds pretty accurate
16:04:09 <hiptobecubic> What is rack?
16:04:17 <hiptobecubic> ... or WAI
16:04:20 <orion> hiptobecubic: Boobs
16:04:44 <hiptobecubic> Buby
16:05:36 <srhb> hiptobecubic: It's what sits between your app and your http server, basically
16:06:12 <orion> What does WAI stand for?
16:06:21 <srhb> orion: Web Application Interface, I think
16:06:27 <SwashBuckla> google is your friend :)
16:06:31 <SwashBuckla> http://hackage.haskell.org/package/wai
16:06:34 <Welkin> it also means "why"
16:06:42 <johnw> WAI is pretty nice to use
16:06:53 <Welkin> in internet pigin
16:07:01 <orion> ok
16:07:01 <orion> so
16:07:09 <Welkin> pidgin*
16:07:12 <orion> Is FPComplete like Heroku?
16:07:17 <theuzez> does haskell comes with a standard math library?
16:07:26 <srhb> orion: FP Complete is a company.
16:07:29 <orion> theuzez: It can do sin/cos/tan out of the box. :)
16:07:30 <johnw> orion: in some ways it could be
16:07:33 <orion> srhb: So is Heroku
16:07:40 <srhb> orion: Then yes
16:08:00 <SwashBuckla> >_>
16:08:04 <srhb> :-)
16:08:06 <orion> Heroku is really cool because all you do is push code to their git repository and you're online.
16:08:20 <srhb> orion: That's not Heroku the company, though.
16:08:28 <orion> It would be cool if there was something like that for Haskell
16:08:50 <theuzez> ahh, sqrt.
16:08:51 <srhb> orion: I think people run Haskell stuff on Heroky.
16:08:57 <srhb> s/y/u
16:09:01 <thoughtpolice> you can use Haskell with Heroku already, with some caveats
16:09:03 <SwashBuckla> oh, FPComplete's platform can support hosting & pushing to git, but you have to pay for it
16:09:30 <davidfetter> thoughtpolice, what caveats?
16:09:37 <SwashBuckla> I'm not sure if you can point FPComplete's haskell platform to a git repository and have it hosted
16:10:07 <SwashBuckla> recently, Google App Engine has introduced support for running web apps on their appspot platform from github
16:10:36 <SwashBuckla> they support Python, Go, Java, perhaps others (not Haskell yet, AFAIK)
16:10:55 <thoughtpolice> davidfetter: i think the major one is that the amount is the time limits, sometimes you can trigger the build timeout on their services. you can get around it rather easily, though
16:11:07 <thoughtpolice> https://github.com/begriffs/heroku-buildpack-ghc
16:12:42 <davidfetter> thoughtpolice, neato :)
16:13:06 <Welkin> it's the thoughtpolice ...
16:18:37 <mark_otaris> >let a x y = x ++ tail y in a "h" "aello"
16:19:08 <geekosaur> space after > is required
16:19:15 <mark_otaris> Oh, I see.
16:19:16 <mark_otaris> > let a x y = x ++ tail y in a "h" "aello"
16:19:18 <lambdabot>  "hello"
16:19:37 <Quenty> Does : pass arguments in some way?
16:19:46 <geekosaur> what?
16:19:51 <Quenty> Sorry, just learning Haskell
16:19:54 <mark_otaris> (:) is a function that adds a value to the start of a list.
16:20:10 <mark_otaris> > 'a' : "ttack"
16:20:11 <lambdabot>  "attack"
16:20:18 <mark_otaris> That‚Äôs an example.
16:20:21 <Quenty> What does the () mean, when you say "(:)" is a function?
16:20:34 <Quenty> Oh. I see. : is the function's name.
16:20:34 <geekosaur> the parens turn an infix operator into a prefix function
16:20:35 <mark_otaris> : is the name of a function.
16:20:37 <triliyn> The () make it a valid expression
16:20:42 <geekosaur> > (:) 'h' "ello"
16:20:43 <lambdabot>  "hello"
16:20:46 <triliyn> :t (:)
16:20:47 <hae> What they said.
16:20:47 <lambdabot> a -> [a] -> [a]
16:20:52 <triliyn> :t :
16:20:53 <lambdabot> parse error on input ‚Äò:‚Äô
16:21:01 <Quenty> Right.
16:21:06 <hae> The actual name of the function is "cons", by the way.
16:21:07 <triliyn> Without the parentheses, you can only use it in a fully applied call
16:21:13 <mark_otaris> Characters are denoted with single quotes, while double quotes denote strings, or lists of characters, if you prefer.
16:21:53 <Quenty> Are functions declared as prefix or infix on declaration, or is it assumed?
16:21:58 <Quenty> Can you do postfix?
16:22:03 <mark_otaris> Postfix, no.
16:22:13 <mark_otaris> Functions are normally used as prefix functions.
16:22:21 <mark_otaris> You can use them as infix functions with ``.
16:22:22 <hae> If you want postfix, use Forth lol.
16:22:23 <geekosaur> actually there's an extension for postfix, based on sections
16:22:30 <Welkin> I was reading that last night, that strings in haskell are just lists of characters, whereas in other languages strings are just a series of bytes, rather than a list
16:22:40 <Quenty> But you can declare them as either.
16:22:47 <Welkin> or is this just the interface to strings, and not the actual implementation?
16:22:48 <mark_otaris> > 5 `max` 4 == max 5 4
16:22:49 <geekosaur> but infix (and the postfix extension) use symbol-character names, while prefix functions use identifier-character names
16:22:49 <lambdabot>  True
16:22:50 <Quenty> (as either a postfix or infix)
16:22:58 <mark_otaris> You can use them in this way.
16:23:14 <geekosaur> but () wrapped around a symbol-name makes it a prefix function, and `` wrapped around an identifier-name makes it an infix operator
16:23:15 <Quenty> Ah.
16:23:20 <mark_otaris> Any function can be used as infix or prefix, but you need the ` characters if you want to use it infix.
16:23:26 <hae> (==) happens to be an infix function, too.
16:23:38 <Quenty> > (`fst`) ['A', 'B']
16:23:40 <lambdabot>  <hint>:1:7: parse error on input ‚Äò)‚Äô
16:23:43 <Quenty> lol
16:23:48 <hae> > :t (==)
16:23:49 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
16:24:02 <johnw> i'd love a variant of Aeson based on trifecta
16:24:03 <hae> Oops forgot it's not like ghci.
16:24:04 <Quenty> ohhh everything is a function or data.
16:24:13 <pranz> :t (==)
16:24:14 <lambdabot> Eq a => a -> a -> Bool
16:24:15 <Quenty> Er... list
16:24:28 <Welkin> :t cons
16:24:29 <lambdabot> Cons s s a a => a -> s -> s
16:24:33 <mark_otaris> Yes, more or less everything is a function.
16:24:55 <mark_otaris> > cons 'a' "ttack"
16:24:57 <lambdabot>  "attack"
16:25:01 <Cale> What?
16:25:05 <mark_otaris> cons is the name of the (:) function
16:25:08 <hae> Actually functions could be considered data as they are a first-class entity.
16:25:08 <mark_otaris> more or less.
16:25:09 <Cale> Many things in Haskell are not functions...
16:25:22 <startling> Data.Function :/
16:25:25 <Quenty> > (==) 'a' ['a']
16:25:26 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Char‚Äô
16:25:26 <lambdabot>              with actual type ‚Äò[GHC.Types.Char]‚Äô
16:25:29 <mark_otaris> hae: And vice-versa, no? Data could be considered functions with no parameter.
16:25:30 <Welkin> everything is a voltage level!
16:25:32 <Cale> Functions are things whose type is of the form A -> B, where A and B are any types
16:25:35 <startling> mark_otaris: not really.
16:25:39 <hae> Exactly.
16:25:50 <Cale> Every function has a parameter
16:25:54 <Cale> That's what makes it a function
16:26:05 <mark_otaris> Cale: I wasn‚Äôt talking about Haskell functions specifically, sorry.
16:26:31 <mark_otaris> Quenty: You cannot compare values of two different types in normal circumstances.
16:26:32 <iron_houzi> Does anybody know the underlying memory implementation of lists in Haskell? Are they like the cons-cells I know from SICP a.k.a linked lists, or are they more like C-arrays?
16:26:48 <Welkin> a arrays are not lists
16:26:52 <Welkin> c arrays*
16:26:57 <Welkin> they are arrays
16:27:05 <hae> ^
16:27:07 <Quenty> mark_otaris: Does "map" execute a function upon a list of data?
16:27:09 <Welkin> javascript stupidly calls its list an "array"
16:27:13 <mark_otaris> Quenty: Yes.
16:27:19 <Quenty> In what order?
16:27:26 <mark_otaris> > map (*5) [1,2,3]
16:27:28 <lambdabot>  [5,10,15]
16:27:29 <hae> It doesn't matter, Quenty.
16:27:35 <Cale> Well, in mathematics, if A and B are sets, then a function f: A -> B is typically defined as a triple (A,B,G), where G is a set of pairs (a,b) with a in A and b in B such that for each a in A, there is exactly one b in B so that (a,b) is in G. When (a,b) is in G, we write f(a) = b.
16:27:44 <iron_houzi> Welkin: Well, apparently, Pythons lists are implemented as arrays..
16:27:54 <Cale> The set A is called the domain of f and the set B is called the codomain
16:28:01 <Cale> G is called the graph of f
16:28:23 <Quenty> Oh, I see.
16:28:26 <mark_otaris> Quenty: You‚Äôll understand quite a bit after completing tryhaskell.org ; not much, but it‚Äôs still that
16:28:31 <k00mi> mark_otaris: how do you define "function" if it includes everything?
16:28:43 <Quenty> Wait, when I say (*99) is the function (*99) or *?
16:28:47 <iron_houzi> Welkin: There are all kinds of ways to use different data structures. Binary trees are tree data structures, but they can easily be implemented using arrays..
16:28:51 <Quenty> Wait, does * construct a new function?
16:28:55 <mark_otaris> k00mi: uh‚Ä¶ ok, fine, I abandon my claim
16:29:08 <Quenty> wait, nevermind
16:29:11 <pranz> Quenty: not really construct
16:29:11 <hae> Quenty, you'll want to look up "currying".
16:29:25 <Cale> Well, (*99) is notation for (\x -> x*99)
16:29:30 <mark_otaris> :t (*66)
16:29:31 <lambdabot> Num a => a -> a
16:29:43 <Quenty> I'm thinking of map as applying an operator between each item in a list, versus map applying an operator between each item and another piece of data.
16:29:46 <Welkin> Quenty, use this http://www.seas.upenn.edu/~cis194/lectures.html and http://learnyouahaskell.com/chapters
16:29:46 <mark_otaris> (*66) is a function that takes a number and gives a number
16:30:07 <Quenty> but 66 is the number?
16:30:08 <hae> :t map
16:30:09 <lambdabot> (a -> b) -> [a] -> [b]
16:30:11 <Quenty> Wait, oh!
16:30:14 <Cale> Quenty: map is a function which simply applies a given function f to each element of a list, obtaining a list of the results
16:30:14 <hae> The type signature tells it all.
16:30:38 <Welkin> iron_houzi, sure, but an array is not a list
16:30:42 <hae> Quenty, what you described is more like a fold or zip?
16:30:45 <Quenty> So you pass it one argument, and then turn it from infix to prefix, and then pass it to map.
16:30:51 <Quenty> I have no idea, I just started 10 minutes ago.
16:31:03 <srhb> Quenty: (*) is a function that takes two numbers and gives you a number. (*66) and (66*) are functions that take one number and give you a number
16:31:13 <iron_houzi> Welkin: I was just asking how the list structure in haskell is implemented.
16:31:23 <Quenty> Weird
16:31:23 <Welkin> iron_houzi, you could always look at the source
16:31:27 <k00mi> iron_houzi: lists in haskell are singly linked lists
16:31:31 <srhb> Quenty: The syntax is called sectioning and is \x -> x * 66 and \x -> 66 * x respectivately
16:31:33 <Welkin> !h list
16:31:40 <k00mi> the ones defined in prelude, that is
16:31:44 <iron_houzi> k00mi: Thank you.
16:31:45 <srhb> Quenty: It's a way of "preloading" an operator with one of its arguments based on side.
16:31:57 <Quenty> Ah, that makes more sense. Thank you!
16:32:14 <srhb> Quenty: The fact that you can partially apply a function is general to all of Haskell though
16:32:21 <Quenty> Haskell is quite elegant.
16:32:31 <hae> ^
16:32:36 <Quenty> I guess that is the nature of functional programming.
16:32:45 <srhb> Quenty: That is, map (*2) is a function that takes a list of numbers and gives you back a list of numbers that are twice that of the originals
16:32:51 <pranz> another way to look at it is just to inspect the type
16:32:51 <srhb> etc.
16:33:02 <pranz> (*) :: Num a => a -> a -> a
16:33:20 <pranz> if you give (*) one a, then only "Num a => a -> a" is left
16:33:29 <Quenty> I'm assuming you can have a list of functions?
16:33:34 <pranz> so (*2) is now a function that accept only one argument
16:33:37 <hae> Well of course.
16:33:37 <pranz> Quenty: yes
16:34:02 <hae> The functions all have to have the same type, though.
16:34:08 <Quenty> Is .. a function? When I do [1..10] what is ..?
16:34:15 <geekosaur> it's syntax
16:34:20 <geekosaur> but it is translated to a function
16:34:26 <geekosaur> > [1..10]
16:34:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:34:31 <srhb> > enumFromTo 1 10
16:34:32 <geekosaur> > enumFromTo 1 10
16:34:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:34:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:34:36 <Quenty> > ..
16:34:37 <lambdabot>  <hint>:1:1: parse error on input ‚Äò..‚Äô
16:34:40 <Quenty> uh
16:34:46 <geekosaur> it's not valid by itself
16:34:51 <Welkin> > :t (..)
16:34:52 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
16:34:56 <Welkin> :t (..)
16:34:56 <lambdabot> parse error on input ‚Äò..‚Äô
16:35:02 <srhb> Welkin: It really isn't a function :P
16:35:04 <geekosaur> it's only meaningful inside of brackets and only when used in specific ways
16:35:07 <hexagoxel> > a..b
16:35:08 <lambdabot>  <hint>:1:2: parse error on input ‚Äò..‚Äô
16:35:09 <Welkin> syntactic sugar
16:35:15 <hexagoxel> > [a..b]
16:35:16 <geekosaur> and is translated into functions depending on the exact way it's used
16:35:16 <lambdabot>  *Exception: not a number
16:35:20 <hexagoxel> aww
16:35:21 <Quenty> > 1 `enumtFromTo` 10
16:35:22 <lambdabot>  Not in scope: ‚ÄòenumtFromTo‚Äô
16:35:23 <lambdabot>  Perhaps you meant one of these:
16:35:23 <lambdabot>    ‚ÄòenumFromTo‚Äô (imported from Prelude),
16:35:23 <lambdabot>    ‚ÄòenumFrom‚Äô (imported from Prelude)
16:35:33 <hae> Okay can we stop now?
16:35:34 <Quenty> > 1 `enumFromTo` 10
16:35:35 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:35:54 <orion> In industry, how do programmers debug runtime bugs?
16:35:57 <Welkin> Quenty, did you install ghci?
16:36:05 <Welkin> orion, debugger
16:36:07 <Quenty> No, I have not.
16:36:17 <Quenty> Will do
16:36:19 <merijn> orion: Usually Debug.Trace, ghci and ghci's debugger
16:36:31 <merijn> @quote Debug.Trace
16:36:31 <lambdabot> bfig says: i have been reborn as a haskell programer after finding Debug.Trace
16:36:34 <merijn> hmm
16:36:37 <merijn> wrong quote :\
16:37:03 <merijn> @quote refreshing.desert
16:37:04 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
16:37:21 <srhb> Quenty: For the record you can also have private conversations with lambdabot. :)
16:37:29 <Welkin> who else is going to enjoy the latest episode of Game of Thrones?
16:37:33 <Quenty> srhb: Thanks.
16:37:39 <srhb> Welkin: #haskell-blah :P
16:37:41 <Quenty> srhb: I'll try not to spam the room in the future
16:37:47 <srhb> Quenty: No worries :)
16:37:48 <Welkin> srhb, which is like having a conversation with yourself
16:37:58 <orion> merijn: Are runtime bugs in Haskell as common as they are in imperative languages?
16:38:03 <Welkin> can you do rubber duck debugging using lambdabot ?
16:38:35 <srhb> I do rubber duck decoding with my stuffed elephant, I'm sure lambdabot is a fine target as well.
16:38:37 <Welkin> orion, haskell has no side effects, so no
16:38:41 <merijn> orion: I'm unsure, but the complexity distribution seems very different
16:39:07 <hae> orion, it shifts the debugging up-front, to compile time, for the most part.
16:39:09 <djkdfj033> Welkin: how long have you used Haskell?
16:39:13 <Welkin> supposedly memory leaks can occur
16:39:25 <srhb> It's quite easy to start leaking, sadly.
16:39:30 <orion> How?
16:39:37 <srhb> But once you start seeing the pattern, you make those mistakes less often.
16:40:26 <merijn> orion: Same way you leak memory in any garbage collected language, you hold on to data longer than needed. And due to laziness you can leak a lot in the form of large thunk build-ups
16:40:30 <orion> What does the pattern look like, srhb?
16:41:02 <srhb> orion: It's not always easily described, but the most common one encountered by newbies is folding a strict operator with a non-strict fold
16:41:02 <merijn> orion: It looks like "foldl (+) 0" :p
16:41:42 <hae> One reason why foldr is superior.
16:41:43 <srhb> Or at least strict in its right-hand argument.
16:41:45 <Welkin> foldl' (+) 0
16:41:49 <srhb> hae: Eh... no :P
16:42:07 <srhb> hae: You'll just get a different kind of leak.
16:42:25 <mark_otaris> > (:)(:) 'T' 'E' 'S'
16:42:26 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Char
16:42:26 <lambdabot>                                -> GHC.Types.Char -> t‚Äô
16:42:26 <lambdabot>              with actual type ‚Äò[a0 -> [a0] -> [a0]]‚ÄôCouldn't match expected t...
16:42:26 <lambdabot>              with actual type ‚ÄòGHC.Types.Char‚Äô
16:42:27 <hae> At least it'll leak on the left side instead of the right, though.
16:42:33 <mark_otaris> Quenty: Nope
16:42:50 <Quenty> Maybe if you grouped them
16:43:08 * hackagebot music-dynamics-literal 1.6.1 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.6.1 (HansHoglund)
16:43:10 * hackagebot music-pitch-literal 1.6.1 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.6.1 (HansHoglund)
16:43:12 * hackagebot abcnotation 1.6.1 - Haskell representation and parser for ABC notation.  http://hackage.haskell.org/package/abcnotation-1.6.1 (HansHoglund)
16:43:14 * hackagebot musicxml2 1.6.1 - A representation of the MusicXML format.  http://hackage.haskell.org/package/musicxml2-1.6.1 (HansHoglund)
16:43:16 * hackagebot lilypond 1.6.1 - Bindings to Lilypond  http://hackage.haskell.org/package/lilypond-1.6.1 (HansHoglund)
16:43:17 <Quenty> (:)'T' ((:) 'T' [])
16:43:18 <Quenty> That works
16:43:29 <Quenty> What is hackagebot doing?
16:43:35 <srhb> Quenty: Announcing new stuff uploaded
16:43:46 <hae> > 'C' : 'o' : 'n
16:43:47 <lambdabot>  Syntax error on 'n
16:43:47 <lambdabot>  Perhaps you intended to use TemplateHaskell
16:43:51 <Welkin> > foldr (:) [] ['G', 'o', 'T']
16:43:52 <lambdabot>  "GoT"
16:44:04 <triliyn> > 'C' : 'o' : 'n' : []
16:44:05 <lambdabot>  "Con"
16:44:08 <Welkin> hae, you need an empty list
16:44:13 <hae> Dammit hit Enter too soon
16:44:15 <hae> I know.
16:44:40 <orion> > forever $ do print 'x'
16:44:41 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
16:44:42 <lambdabot>    arising from a use of ‚ÄòM108077481127130657119318.show_M1080774811271306571...
16:44:42 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
16:44:42 <lambdabot>  Note: there are several potential instances:
16:44:42 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
16:44:44 <hae> Apostrophe is right next to it, though.
16:45:13 <hae> > 'C' : 'o' : 'n' : 's' : []
16:45:14 <lambdabot>  "Cons"
16:45:15 <hae> There.
16:45:15 <startling> :t forever $ do print 'x'
16:45:16 <lambdabot> IO b
16:45:25 <Welkin> lambdabot sure is long-winded
16:45:28 <startling> orion: ^ lambdabot tries to print things in a dumb way if you >
16:45:33 <orion> I see.
16:45:37 <Welkin> imagine lambdabot as a person
16:45:41 <Welkin> with whom are are conversing
16:45:41 <hae> ^
16:45:42 <startling> > (+) 1
16:45:44 <lambdabot>  <Integer -> Integer>
16:45:51 <startling> ^ it's really fragile, though
16:45:56 <triliyn> > id
16:45:57 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
16:45:57 <lambdabot>    arising from a use of ‚ÄòM685970701863594239619361.show_M6859707018635942396...
16:45:57 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
16:45:57 <lambdabot>  Note: there are several potential instances:
16:45:57 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
16:46:01 <startling> :)
16:46:12 <startling> > id `asAppliedTo` ()
16:46:16 <lambdabot>  mueval-core: Time limit exceeded
16:46:19 <startling> > id `asAppliedTo` ()
16:46:21 <lambdabot>  <() -> ()>
16:46:35 <srhb> > id :: () -> ()
16:46:36 <lambdabot>  <() -> ()>
16:46:46 <srhb> How pointless.
16:47:23 <hae> But without id, we wouldn't have anything at all!
16:47:33 <Quenty> What do the <> indicate in lambdabot's statement?
16:47:37 <orion> > fac 10000
16:47:38 <lambdabot>  Not in scope: ‚Äòfac‚Äô
16:47:49 <srhb> Quenty: It's a weird notation for type that is completely nonstandard
16:47:50 <orion> > let fac 0 = 1
16:47:51 <lambdabot>  not an expression: ‚Äòlet fac 0 = 1‚Äô
16:48:12 <orion> > fac 0 = 1
16:48:13 <lambdabot>  <hint>:1:7: parse error on input ‚Äò=‚Äô
16:48:18 * hackagebot music-score 1.6.1 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.6.1 (HansHoglund)
16:48:18 <Quenty> srhb: Thanks!
16:48:20 * hackagebot music-pitch 1.6.1 - Abstract representation of musical pitch.  http://hackage.haskell.org/package/music-pitch-1.6.1 (HansHoglund)
16:48:22 <srhb> orion: You can talk to lambdabot privately to make sure things work :)
16:48:22 * hackagebot music-dynamics 1.6.1 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.6.1 (HansHoglund)
16:48:23 <startling> it should be "it :: ..." or something
16:48:24 * hackagebot music-articulation 1.6.1 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.6.1 (HansHoglund)
16:48:26 * hackagebot music-parts 1.6.1 - To be written.  http://hackage.haskell.org/package/music-parts-1.6.1 (HansHoglund)
16:48:29 <srhb> orion: Also it has to be an expression, so let ... in ...
16:49:08 <srhb> Quenty: Usually everywhere else you will see types denoted after ::
16:49:14 <hae> > let fac n = product [1..n] in fac 6
16:49:16 <lambdabot>  720
16:49:25 <orion> > let fac n = product [1..n] in fac 10000
16:49:26 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
16:49:26 <hae> First!
16:49:31 <orion> > let fac n = product [1..n] in fac 10000000000000
16:49:36 <lambdabot>  mueval: ExitFailure 1
16:49:39 <orion> :<
16:50:25 <startling> that's odd.
16:50:28 <Welkin> is there a symbolic math package?
16:50:54 <srhb> Welkin: Not to my knowledge. Nothing mature at least.
16:51:08 <Welkin> has anyone written a symbolic integrator in haskell?
16:51:13 <Welkin> similar to ones written in lisp
16:51:57 <FrankTominc> how many bytes haskell uses to represent an integer??
16:52:14 <orion> I wish there were Haskell libraries as powerful as what Mathematica or MATLAB could provide.
16:52:27 <srhb> > sizeOf (2 :: Int)
16:52:28 <lambdabot>  Not in scope: ‚ÄòsizeOf‚Äô
16:52:28 <lambdabot>  Perhaps you meant one of these:
16:52:28 <lambdabot>    ‚ÄòIM.size‚Äô (imported from Data.IntMap),
16:52:28 <lambdabot>    ‚ÄòM.size‚Äô (imported from Data.Map),
16:52:28 <lambdabot>    ‚ÄòS.size‚Äô (imported from Data.Set)
16:52:30 <srhb> Aw
16:52:31 <Eduard_Munteanu> FrankTominc: Integer? Depends on its size.
16:52:45 <Eduard_Munteanu> @src Integer
16:52:45 <lambdabot> data Integer = S# Int#
16:52:45 <lambdabot>              | J# Int# ByteArray#
16:53:10 <srhb> FrankTominc: And yes, Integer can store arbitrarily large integer numbers
16:53:22 <srhb> FrankTominc: Int cannot, however, but I also think its size is implementation dependent.
16:53:28 * hackagebot music-preludes 1.6.1 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.6.1 (HansHoglund)
16:53:30 * hackagebot music-graphics 1.6.1 - Diagrams-based visualization of musical data structures.  http://hackage.haskell.org/package/music-graphics-1.6.1 (HansHoglund)
16:53:32 * hackagebot music-sibelius 1.6.1 - To be written.  http://hackage.haskell.org/package/music-sibelius-1.6.1 (HansHoglund)
16:54:31 <FrankTominc> so there Integers doesn't have max values??
16:54:41 <startling> FrankTominc: correct.
16:54:45 <johnw> ‚àû
16:54:47 <srhb> FrankTominc: Barring running out of memory. :)
16:54:53 <FrankTominc> cool
16:55:00 <Welkin> tip: use Int
16:55:02 <srhb> FrankTominc: They are also slower than Int
16:55:05 <srhb> For many things.
16:55:07 <Welkin> it will be faster
16:55:08 <orion> Does Haskell have variable precision floating point numbers?
16:55:22 <hae> orion, Float and Double are the basic kind.
16:55:34 <FrankTominc> ok
16:55:56 <Eduard_Munteanu> Welkin: also not entirely correct for certain usecases, and one should favor correctness when possible
16:56:07 <FrankTominc> thank's guys
16:56:09 <srhb> orion: I think numbers has such types
16:56:26 <Welkin> Eduard_Munteanu, when would it be better to use Integer?
16:56:27 <Eduard_Munteanu> Float / Double aren't arbitrary-precision floats.
16:56:38 <srhb> Welkin: When you may have something bigger than what Int can contain
16:56:49 <srhb> Welkin: Ie. when you're not _absolutely certain_ it will fit in an Int
16:56:53 <Eduard_Munteanu> Welkin: one should use Integer by default, really
16:57:19 <Welkin> is Int the size of a word?
16:57:29 <Welkin> or is it implemented as a Long?
16:57:31 <srhb> Welkin: It's platform and implementation specific
16:57:40 <srhb> Welkin: "A fixed-precision integer type with at least the range [-2^29 .. 2^29-1]. The exact range for a given implementation can be determined by using minBound and maxBound from the Bounded class."
16:57:46 <Eduard_Munteanu> Welkin: Int has the same size as Word, but I'm not sure what you mean by "word".
16:58:09 * hackagebot music-dynamics-literal 1.6.2 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.6.2 (HansHoglund)
16:58:11 * hackagebot music-pitch-literal 1.6.2 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.6.2 (HansHoglund)
16:58:13 * hackagebot abcnotation 1.6.2 - Haskell representation and parser for ABC notation.  http://hackage.haskell.org/package/abcnotation-1.6.2 (HansHoglund)
16:58:15 * hackagebot musicxml2 1.6.2 - A representation of the MusicXML format.  http://hackage.haskell.org/package/musicxml2-1.6.2 (HansHoglund)
16:58:17 * hackagebot lilypond 1.6.2 - Bindings to Lilypond  http://hackage.haskell.org/package/lilypond-1.6.2 (HansHoglund)
16:58:29 <Eduard_Munteanu> > maxBound :: Integer
16:58:30 <Welkin> 4 bytes for 32-bit and 8 bytes for 64-bit systems
16:58:30 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
16:58:31 <lambdabot>    arising from a use of ‚ÄòGHC.Enum.maxBound‚Äô
16:58:34 <Welkin> is what I mean by "word"
16:58:37 <Eduard_Munteanu> Er.
16:58:39 <Eduard_Munteanu> > maxBound :: Int
16:58:40 <lambdabot>  9223372036854775807
16:58:51 <haasn> maxBound :: Int is machine dependent
16:58:58 <haasn> (and implementation)
16:59:20 <Eduard_Munteanu> I was going to illustrate it's not C int-sized.
16:59:43 <Eduard_Munteanu> Welkin: on 64-bit machines it's 64-bit IIRC
17:00:43 <srhb> > 2^64 `div` 2 - 1
17:00:44 <lambdabot>  9223372036854775807
17:00:59 <srhb> > 2^64 `div` 2 - 1 == maxBound :: Int
17:01:00 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
17:01:00 <lambdabot>              with actual type ‚ÄòGHC.Types.Bool‚Äô
17:01:22 <startling> > 2^64 `div` 2 - 1 == (maxBound :: Int)
17:01:24 <lambdabot>  False
17:01:31 <Eduard_Munteanu> (2^64 `div` 2) - 1 == maxBound :: Int
17:01:34 <Eduard_Munteanu> > (2^64 `div` 2) - 1 == maxBound :: Int
17:01:35 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
17:01:35 <lambdabot>              with actual type ‚ÄòGHC.Types.Bool‚Äô
17:01:41 <srhb> Well, damn.
17:01:44 <srhb> :P
17:01:46 <Eduard_Munteanu> Er.
17:02:06 <srhb> > (2^64 `div` 2 - 1) == maxBound
17:02:07 <lambdabot>  No instance for (GHC.Real.Integral a0)
17:02:07 <lambdabot>    arising from a use of ‚ÄòGHC.Real.div‚Äô
17:02:07 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
17:02:07 <lambdabot>  Note: there are several potential instances:
17:02:07 <lambdabot>    instance GHC.Real.Integral GHC.Types.Int
17:02:09 <srhb> D:
17:02:30 <srhb> > (2^64 `div` 2 - 1) :: Int == maxBound
17:02:31 <lambdabot>  Not in scope: type constructor or class ‚Äò==‚Äô
17:02:33 <Eduard_Munteanu> > (2^64 `div` 2) - 1 == (maxBound :: Int)
17:02:34 <lambdabot>  False
17:02:36 <srhb> Screw you lambdabot
17:02:37 <Welkin> > ((2^64 `div` 2) - 1) - (maxBound :: Int)
17:02:38 <lambdabot>  -9223372036854775808
17:02:39 <srhb> You're lyind!
17:03:03 <Welkin> > (2^64 `div` 2) == (maxBound :: Int)
17:03:05 <lambdabot>  False
17:03:19 * hackagebot music-score 1.6.2 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.6.2 (HansHoglund)
17:03:21 <srhb> Ok, what the heck is going wrong here :P
17:03:21 * hackagebot music-pitch 1.6.2 - Abstract representation of musical pitch.  http://hackage.haskell.org/package/music-pitch-1.6.2 (HansHoglund)
17:03:23 * hackagebot music-dynamics 1.6.2 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.6.2 (HansHoglund)
17:03:25 * hackagebot music-articulation 1.6.2 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.6.2 (HansHoglund)
17:03:27 * hackagebot music-parts 1.6.2 - To be written.  http://hackage.haskell.org/package/music-parts-1.6.2 (HansHoglund)
17:03:33 <Welkin> is there a way to play with bits in haskell?
17:03:38 <Welkin> such as bit operators?
17:03:54 <startling> srhb: does it associate the right way?
17:04:02 <srhb> Welkin: Yes.
17:04:06 <startling> > (2^64 `div` 2) - 1
17:04:07 <lambdabot>  9223372036854775807
17:04:15 <startling> > 2^64 `div` (2 - 1)
17:04:16 <lambdabot>  18446744073709551616
17:04:17 <Eduard_Munteanu> Welkin: yes, see Data.Bits
17:04:25 <startling> > maxBound :: Int
17:04:26 <lambdabot>  9223372036854775807
17:04:28 <srhb> > 2^64 `div` 2 :: Int
17:04:29 <lambdabot>  0
17:04:29 <Eduard_Munteanu> > 4 .|. 2
17:04:30 <lambdabot>  6
17:04:31 <srhb> wat
17:04:45 <srhb> oooh
17:04:50 <startling> > > (2^64 `div` 2) - 1  == (maxBound :: Int)
17:04:51 <srhb> > (2^64) `div` 2 :: Int
17:04:51 <lambdabot>  <hint>:1:1: parse error on input ‚Äò>‚Äô
17:04:52 <lambdabot>  0
17:04:52 <Welkin> I guess >> and << are already taken
17:04:54 <startling> > (2^64 `div` 2) - 1  == (maxBound :: Int)
17:04:56 <lambdabot>  False
17:04:59 <srhb> ???
17:05:06 <hpc> > 2 ^ 64 :: Int
17:05:07 <srhb> Welkin: Yes, >> is quite important
17:05:08 <lambdabot>  0
17:05:18 <hpc> > 0 `div` 2
17:05:19 <startling> > "9223372036854775807" == "9223372036854775807"
17:05:19 <lambdabot>  0
17:05:20 <lambdabot>  True
17:05:23 <startling> haha
17:05:40 <startling> > (2^64 `div` 2) - 1 :: Int
17:05:41 <lambdabot>  -1
17:05:43 <srhb> OK, lambdabot is just being mean.
17:05:43 <startling> aha
17:05:57 <startling> srhb: no, it's different when it's Int. :)
17:06:15 <Eduard_Munteanu> > 1 `shiftL` 3
17:06:16 <lambdabot>  8
17:06:37 <Eduard_Munteanu> > 1 `shift` 3
17:06:38 <startling> > (2^64 `div` 2) - 1 :: Integer
17:06:38 <lambdabot>  8
17:06:39 <lambdabot>  9223372036854775807
17:06:58 <Eduard_Munteanu> I guess .<<. would have been shorter by only one char. :)
17:06:58 <srhb> Ah
17:07:06 <startling> srhb: so when you say == (maxBound :: Int) you change the inferred type
17:07:55 <srhb> > (2^64 `div` 2 - 1 :: Integer) == fromIntegral (maxBound :: Int)
17:07:56 <lambdabot>  True
17:07:59 <srhb> SUCCESS
17:08:08 <srhb> And this is why we don't use Int. :-(
17:08:16 <srhb> Clearly I'm too stupid to use it, at least
17:08:29 * hackagebot music-preludes 1.6.2 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.6.2 (HansHoglund)
17:08:31 * hackagebot music-graphics 1.6.2 - Diagrams-based visualization of musical data structures.  http://hackage.haskell.org/package/music-graphics-1.6.2 (HansHoglund)
17:08:33 * hackagebot music-sibelius 1.6.2 - To be written.  http://hackage.haskell.org/package/music-sibelius-1.6.2 (HansHoglund)
17:09:06 <orion> What's the difference between Int and Integer?
17:09:12 <srhb> orion: Integer is unbounded
17:09:19 <geekosaur> Int is a machine word; Integer is an unbounded integral value
17:09:25 <orion> ah
17:09:39 <orion> word
17:09:50 <Welkin> yes, a word
17:10:33 <orion> No, I was saying "word" as in, http://www.urbandictionary.com/define.php?term=word
17:10:37 <orion> As a joke. :x
17:10:40 <geekosaur> (so either 32 or 64 bits depending on architecture and how ghc was built; and behaves like machine words do, in particular it wraps without an error because on most CPUs catching overflow is moderately expensive)
17:10:41 <Welkin> I know
17:11:43 <geekosaur> like on x86/x86_64 you need to add an extra instruction after every math opcode
17:14:13 <hae> There's also a Byte type for you 8-bit freaks.
17:14:29 <startling> Word8?
17:15:30 <srhb> Or just Int8, if you want the sign
17:15:45 <geekosaur> although secretly it's still a full machine word as implemented by ghc
17:15:57 <Eduard_Munteanu> As for us pedantic freaks, we're not happy with Byte being called 8-bit. :P
17:16:04 <srhb> Eduard_Munteanu: Oh?
17:16:10 <orion> hmm
17:16:24 <Welkin> Eduard_Munteanu, do you also have a problem with Nibbles?
17:16:42 * geekosaur would bap you with a decsystem/20 but that would almost certainly be deadly
17:16:48 <orion> My psychiatrist diagnosed me with OCPD. That must be why I am in love with Haskell, minus the record type syntax.
17:16:50 <hae> Eduard_Munteanu, do you prefer a baker's byte? 9 bits to the byte, since you're such a good customer?
17:17:11 <hae> What's OCPD? >_>
17:17:15 <srhb> OCD.
17:17:15 <geekosaur> hae, don't laugh, I just mentioned decsystem 20 for a reason
17:17:22 <Welkin> the baker's dozen is so the baker can eat one item from every batch to "test" it
17:17:43 <orion> "Obsessive‚Äìcompulsive personality disorder (OCPD), also called anankastic personality disorder, is a personality disorder characterized by a pervasive pattern of preoccupation with orderliness, perfectionism, mental and interpersonal control and a need for power over one's environment, at the expense of flexibility, openness, and efficienc."
17:17:45 <Welkin> this is why bakers are so fat
17:17:48 <geekosaur> depending on what operations you use, a "byte" could be 5, 6, 7, 8, or 9 bits
17:18:01 <geekosaur> pdp10s were run
17:18:03 <geekosaur> *fun
17:20:44 <Eduard_Munteanu> It's not quite OCD.
17:21:31 <Welkin> it is pointless to try to categorize yourself
17:21:35 <Welkin> you are who you are
17:22:09 <Welkin> psychiatry and their various texts on "disorders" and "syndromes" are worthless
17:22:24 <haasn> Eduard_Munteanu: I read that the IEC standardized ‚Äúbyte‚Äù as meaning precisely ‚Äú8 bits‚Äù in one of their documents
17:22:37 <haasn> I'm almost inclined to follow that, we use ‚Äúword‚Äù for the affected size of machine operations, no?
17:22:51 <Welkin> every person on the planet could easily diagnose oneself with any number of "diseases" from those texts
17:23:07 <geekosaur> these days it's probably safe. anyone remember ftp's tenex mode?
17:23:13 <Eduard_Munteanu> haasn: perhaps as a "local" definition of byte for the purpose of that document alone?
17:23:15 <geekosaur> (TYPE L 8 in the protocol)
17:23:28 <Welkin> what machines in common use today do *not* use 8-bit Bytes?
17:23:31 <haasn> Eduard_Munteanu: https://en.wikipedia.org/wiki/IEC_80000-13
17:23:47 <Eduard_Munteanu> Welkin: none really
17:23:52 <Welkin> besides, perhaps, microcontrollers
17:24:21 <haasn> Whoa, it also codifies the meanings of ‚Äúerlang (E), octet (o), baud (Bd), shannon (Sh), hartley (Hart) and the natural unit of information (nat)‚Äù
17:24:26 <geekosaur> ancient microcontrollers... modern ones are generally emulated on commodity CPUs
17:25:11 <gamegoblin> How does one include docs in a cabal dist?
17:25:30 <Eduard_Munteanu> haasn: I guess it makes sense for units like MiB or MB, they'd have to s/B/O/ everywhere.
17:26:05 <Eduard_Munteanu> But how do you call a possibly non-8bit byte then?
17:26:22 <haasn> I have no idea
17:26:25 <geekosaur> "archaic"?
17:27:02 <Eduard_Munteanu> I'm not sure 8-bit bytes are particularly nice to work with, nicer than other possible choices.
17:27:19 <Eduard_Munteanu> Or even relevant to interoperability.
17:27:30 <geekosaur> blame IBM
17:27:52 <srhb> Byte_7 ala how logarithm types are denoted? :P
17:28:38 <Welkin> each hexcode is 4 bits
17:28:41 <Welkin> known as a nibble
17:28:46 <Welkin> two hexcodes are a byte
17:28:46 <edwardk> johnw: i'm slowly building up a version of it based on my succinct machinery, at least the parsing side of it
17:29:37 <edwardk> sadly the hashmaps are too strict so i can't just dump into aeson's Value type
17:29:58 <Eduard_Munteanu> 10-bit bytes would be quite convenient too, and you could represent two of them with 5 hex digits, quite close to the Hrair limit. :)
17:32:15 <hae> How about we just switch to tetrary and get it over with?
17:32:34 <monochrom> the average byte has 7.99143 bits
17:33:01 <hae> That would be base 4, for those of you following along.
17:33:06 <Eduard_Munteanu> hae: tetrary would be tougher to do in hardware though.
17:33:39 <monochrom> tetrary can be used in a polynomial-time reduction from 3SAT to SUBSET-SUM
17:33:41 <Eduard_Munteanu> Not a lot tougher, but enough to upset what you've got, unless you only change the abstraction.
17:33:58 <hae> Who ever said anything about practicality?
17:33:59 <monochrom> (I am sorry, I have been grading such reductions lately!)
17:34:05 <Eduard_Munteanu> I did. :P
17:35:21 <hae> In any case, memristors will solve all our problems.
17:35:46 <monochrom> memristors can defeat Chuck Norris in one kick!
17:36:28 <monochrom> Oleg can do a tetrary digit at the type level!
17:36:32 <FrankTominc> > 1/0
17:36:33 <lambdabot>  Infinity
17:36:44 <identity> ^ oleg's level
17:36:54 <FrankTominc> > 1/0.000000000000000000000000000000000000000000000000000000000000000000000000000001
17:36:55 <lambdabot>  1.0e78
17:38:08 <hae> Wait, infinity?
17:38:24 <startling> hae: it's a Float thin
17:38:25 <startling> g
17:38:30 <startling> :t 1/0
17:38:32 <lambdabot> Fractional a => a
17:38:33 <monochrom> IEEE 754 infinity
17:39:05 <monochrom> because it's harder to find a non-IEEE-754 computer than a tetrary computer
17:39:05 <hae> That's a little unnverving.
17:39:06 <identity> not this again
17:39:52 <startling> hae, every other IEEE-754 float implemenetation has the same thing
17:39:52 <Eduard_Munteanu> > 1/0 - 1/0
17:39:54 <lambdabot>  NaN
17:41:08 <hae> Standards continue to ruin everyone's fun.
17:42:14 <orion> What about countable infinities?
17:42:51 <monochrom> I don't understand the question.
17:42:54 <gamegoblin> So‚Ä¶ I uploaded a package here (http://hackage.haskell.org/package/JustParse-1.0), how long till the docs get generated, or did I do something wrong upon uploading..?
17:43:19 <hpc> give it a day
17:43:24 <gamegoblin> Gotcha
17:43:42 <orion> monochrom: Nevermind. I am drunk.
17:43:45 <monochrom> I think you haven't done anything wrong
17:43:48 <gamegoblin> I‚Äôve been told conflicting things by different people, some said hackage 2 did it instantly, some said did not‚Ä¶ infinite confusion‚Ä¶
17:44:43 <hpc> blargh, new hackage doesn't show build logs
17:44:57 <gamegoblin> T_T
17:45:15 <startling> gamegoblin, so long as your docs build locally it should work
17:45:19 <startling> it definitely takes some time though
17:45:22 <gamegoblin> Alright awesome
17:46:57 <monochrom> I just downloaded and tested "cabal configure, build, haddock". no error. since you only depend on base, this is strong evidence of no error on hackage's server either.
17:47:53 <gamegoblin> So I just have to wait for the documentation fairy to come by?
17:48:06 <monochrom> yes
17:49:04 <FrankTominc> > map(/0) [1 ..]
17:49:06 <lambdabot>  [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Inf...
17:49:31 <monochrom> that is countable infinity :)
17:49:32 <FrankTominc> cool, now i have an infinity list of infinityes
17:49:39 <gamegoblin> haaa...
17:49:45 <FrankTominc> i fucking love Haskell
17:50:06 <tristan__> does anyone know where in the docs for http conduit client it says how to handle a chunked response
17:50:33 <c_wraith> If that requires special handling, I'd call it a significant abstraction leak
17:52:57 <tristan__> well responseBody just returns the body, I have a chunked stream that lasts "forever"
17:53:31 <hae> > last [1..]
17:53:33 <ParahSailin> use teh conduit stuff
17:53:34 <lambdabot>  mueval-core: Time limit exceeded
17:53:57 <hae> See I can do infinity things too.
17:54:21 <monochrom> I can do infinity minus 1. init [1..] :)
17:56:22 <FrankTominc> > succ (1/0)
17:56:24 <lambdabot>  Infinity
17:57:31 <tristan__> ParahSailin: yea, I don't get if it returns a body with a Source by default if it gets a chunked response or if I have to request it
17:57:45 <srhb> > concat . map show . repeat $ 1/0 - 1/0
17:57:46 <lambdabot>  "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN...
17:57:51 <srhb> :3
17:58:08 <FrankTominc> cool, batman song :v
17:58:12 <monochrom> > "batman! " ++ (concat . map show . repeat $ 1/0 - 1/0)
17:58:13 <lambdabot>  "batman! NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNN...
17:58:38 <hae> Lol Batman.
17:58:40 <Eduard_Munteanu> > concatMap (init . show) . repeat $ 1/0 - 1/0
17:58:41 <lambdabot>  "NaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNaN...
17:58:47 <hae> That's actually pretty cool.
17:58:54 <Eduard_Munteanu> Sodium overload.
17:59:18 <FrankTominc> be careful, you can die from it...
17:59:36 <imalsogreg> > Array(16).join("wat" - 1) + " Batman!"
17:59:37 <lambdabot>  Not in scope: data constructor ‚ÄòArray‚Äô
18:00:02 <imalsogreg> (for anyone who hasn't seen the Wat talk)
18:00:20 <tristan__> cool, found an example in the tests
18:00:35 <orion> The Wat talk was hilarious.
18:00:38 <silasm> > (repeat $ 1/0 - 1/0) >>= show
18:00:39 <lambdabot>  "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN...
18:01:05 <hae> I wish the other talks weren't behind a paywall...
18:03:12 <FrankTominc> Hey guys, where do you live?
18:03:16 <FrankTominc> i'm from Brazil
18:03:28 <bjorkintosh> i'm from irc
18:03:31 <srhb> FrankTominc: People in this channel are from all over the world.
18:05:38 <hae> Don't worry, I'm from the Internet and I'm here to help.
18:10:33 <orion> https://github.com/johngunderman/buckets-dht <-- wow, this guy made a ton of progress over the last 4 years
18:15:57 <orion> nxor a b = (a .|. b) `xor` (a .&. b) <-- what is this ".|." and ".&." syntax?
18:16:26 <silasm> orion: bitwise and and or, I believe.
18:16:41 <geekosaur> orion: http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Data-Bits.html
18:17:09 <silasm> Is there a "let me hoogle that for you?"
18:17:17 <silasm> I guess you could just use lmddgtfy
18:17:33 <geekosaur> condescencion doesn't really seem to be called for here
18:17:45 <geekosaur> *condescension
18:17:46 <silasm> geekosaur: heh, sorry.
18:17:58 <shackleford> Hey guys. So, I decided to give write yourself a scheme a try, and spiced it up with a REPL to test out my parser. My problem occurs in my main, found here: http://lpaste.net/103013. I'd like for the "> " to appear as a prompt to the user for their input, but it prints with the evaluated expression. Anyone know what I'm doing incorrectly?
18:18:03 <silasm> more curiosity than saying it would necessarily apply to this situation.
18:20:11 <Welkin> is there a hoogle trigger, such as !h ?
18:20:22 <Welkin> I love that DDG has one built in: !h
18:21:00 <silasm> oh neat, I always used the full !hoogle, didn't know just !h worked.
18:21:41 <geekosaur> @hoogle a -> a
18:21:42 <lambdabot> Prelude id :: a -> a
18:21:42 <lambdabot> Data.Function id :: a -> a
18:21:42 <lambdabot> GHC.Exts breakpoint :: a -> a
18:22:11 <silasm> @hoogle (.&.)
18:22:11 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
18:22:11 <lambdabot> Test.QuickCheck.Property (.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
18:22:11 <lambdabot> Test.QuickCheck (.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
18:22:41 <hae> DDG is so awesome.
18:23:16 * hackagebot ffmpeg-light 0.2 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.2 (AnthonyCowley)
18:25:28 <Welkin> does anyone develop in haskell using an ARM platform like a chromebook running linux?
18:26:22 <ion> I have tried GHC on Debian on ARM with success.
18:27:26 <imalsogreg> Welkin: I've compiled on it. I heard a while ago that ghci doesn't work. Not sure if that's still true?
18:28:37 <geekosaur> there are various hacks for 7.6.x but no official support. 7.8 should support it
18:38:17 * hackagebot ffmpeg-light 0.2.0.1 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.2.0.1 (AnthonyCowley)
18:41:30 <carter> geekosaur: hacks for which?
18:41:32 <carter> oh arm?
18:41:39 <carter> NB: on arm i think you need to use the gold linker
18:41:50 <carter> but other wise should work
18:41:59 <geekosaur> carter, yeh
18:42:24 <carter> geekosaur: on a sadder note, i may have stumbled into a ghc bug this evening in 7.8
18:42:35 <geekosaur> another?
18:42:38 <carter> well
18:43:02 <geekosaur> (is anyone else kinda sad that a compiler that was going to be released in October is finally out now and immediately bugs found...)
18:43:04 <carter> unless its a bug in vector head that only gets tripped in 7.8 and not 7.0 / 7.2/ 7.4/ 7.6
18:43:17 <carter> geekosaur: nah, a LOT fewer bugs than would have happened then
18:43:27 <carter> geekosaur: if you helped us, the next time ti'll be faster still!
18:49:37 <carter> geekosaur: ooo
18:49:38 <carter> not a bug
18:49:40 <carter> yay
18:49:44 <carter> just floating point trolling me
18:49:47 <carter> pesky floats
18:50:16 <hae> Using ArchHaskell, I think it'll be at least a year before all the packages are updated to depend on GHC 7.8.
18:50:45 <hae> Though why they need specific compiler versions, for most of them, is anyone's guess.
18:51:12 * geekosaur kinda surprised that a rolling release distribution doesn't follow the latest and greatest automatically
18:53:14 <carter> i'd guess because they dont' want things to have bugs
18:53:16 <carter> so they lag
18:53:31 <geekosaur> that's never stopped them before
18:53:37 <Welkin> I learned the hard way to use stable releases
18:54:03 <geekosaur> we generally find out about bugs that affect xmonad way sooner from the arch users because they get the bugs in xmobar, nvidia drivers, etc. up to a couple months before everyone else >.>
19:01:09 <hiptobecubic> unfortunately, yes
19:06:08 <startling> Do you need happy to install happy?
19:07:33 <hae> It's not an official repo, though.
19:07:50 <geekosaur> I don't think you're supposed to need it, but it's a known problem that the latest one asks for it
19:08:20 * hackagebot distributed-process-monad-control 0.4.2 - Orphan instances for MonadBase and MonadBaseControl.  http://hackage.haskell.org/package/distributed-process-monad-control-0.4.2 (jeremyjh)
19:08:24 <geekosaur> I suspect someone forgot to provide bootstrap files in a release version, just dumped their repo
19:08:27 <startling> geekosaur, ah
19:08:39 <startling> that's sort of a pain.
19:11:59 <vamega2> Hi
19:12:27 <vamega2> Is it valid to define multiple type signatures in a single line?
19:12:51 <vamega2> Something like transform1, transform2, transform3 :: String -> String?
19:12:58 <geekosaur> exactly like that, in fact
19:13:07 <vamega2> Oh great. Thanks
19:13:23 <vamega2> The compiler wasn't borking on it.
19:13:33 <vamega2> But just wanted to ensure it was doing what I thought it was doing.
19:13:40 <geekosaur> valid but not common because people tend to prefer that type signatures appear just above the bindings they apply to
19:17:44 <carter> startling: nope
19:17:50 <carter> itshould boot strap
19:17:51 <carter> startling: oooo
19:17:56 <carter> are you trying to buil dhappy in a sandbox?
19:18:31 <tristan__> hm, I'm getting an error on build that Data.Conduit.Binary is in hidden package conduit-1.0.5.1, but I do have conduit in build-depends...
19:19:08 <startling> I'm not trying to do anything. I just heard that, looked at happy's .cabal file and didn't see Build-Tools: happy and so was confused
19:21:56 <carter> startling: do cabal sdist
19:22:05 <carter> and then opent he sdist tar ball elsewhere
19:22:07 <carter> you'll see
19:22:13 <carter> some processed files
19:27:24 <tristan__> anyone had an issue with 'hidden package' that is actually included? it doesn't complain on import Data.Conduit only Data.Conduit.Binary
19:29:19 <jakex> from what ghc version does Prelude no longer export catch (the IO version)?
19:31:25 <tristan__> oh. Data.Conduit.Binary doesn't exist in later versions
19:31:32 <carter> jakex: 76?
19:38:15 <Welkin> what is the best way to split up long lines?
19:38:55 <geekosaur> I generally use string gaps
19:39:28 <geekosaur> http://lpaste.net/92725
19:40:21 <geekosaur> or, hm, do you mean long lines as strings or long lines of code?
19:40:38 <Welkin> lines of code
19:41:11 <geekosaur> generally you can just split at a reasonable place and indent the next line more
19:41:35 <hae> You could also use curly brackets.
19:46:15 <koninkje> [A
19:49:38 <Platz> spent some time checking out zippers today.  whereas clojure has a core zipper lib haskell appears to have several, some customzed to trees (rosezipper). we also have lens based zippers too!
19:52:25 <Platz> It's good though, would rather have as much as possible outside of the base distribution
19:52:52 <Welkin> like this: http://lpaste.net/103015
19:53:03 <Welkin> how would I break those lines?
19:53:24 <Welkin> also, it is probably not the best way to parse a string
19:55:02 <bjorkintosh> Welkin, use the unix tools :)
19:55:13 <bjorkintosh> that's what they're there for.
19:55:44 <bjorkintosh> no need to reinvent the broken wagon wheel.
19:56:05 <Welkin> this is an exercise in learning haskell
19:56:26 <Welkin> so that is not the response I am looking for
20:00:13 <jakex> I just learned that you can split long strings literals into multiple lines with \.. pretty neat
20:00:18 <jakex> string*
20:00:27 <jakex> (.. is not part of the syntax)
20:00:51 <Welkin> yes, but I am asking about code
20:01:09 <Welkin> also, if there are improvements I can make to this code: http://lpaste.net/103015
20:01:12 <jakex> nicer than unwords ["foo",\n"bar"] or "foo" ++\n"bar"
20:24:06 <CindyLinz> Why can't Haskell's string literals expand multiple lines directly.. T_T
20:25:06 <tommd> I don't understand the question.
20:25:36 <geekosaur> I think they consider the fact that strings can't arbitrarily run on forever to be a bug
20:28:05 <Axman6> CindyLinz: what would the syntax be? many languages have some kind of terminator to show where a string ends and begins again
20:29:17 <Axman6> and when you combine this with the fact Haskell has indentation aware syntax, it can get kind of confusing
20:30:19 <CindyLinz> Axman6: Still using " is ok. Many languages, perl, php, coffeescript have this feature~
20:30:42 <CindyLinz> Coffeescript is indentation aware, too.
20:30:43 <Axman6> they also don't have function application via juxtaposition
20:31:03 <Axman6> is foo "hello"\n"world" two string arguments or one?
20:31:21 <Axman6> (assuming approlriate indentation)
20:31:24 <Axman6> -l
20:31:38 <CindyLinz> Axman6: Um.. Not like this.. It should be "hello\nworld"
20:31:55 <Axman6> right, haskell's syntax is basically that
20:32:06 <Axman6> oh, no
20:32:12 <Axman6> missed then n
20:32:33 <kfish> CindyLinz, do you want here to syntax (like in shell), or multiline quote syntax like python """" ?
20:34:00 <CindyLinz> kfish: I don't care ^^|  It's just a symbol
20:37:38 <CindyLinz> But.... when deal with the Template Haskell quotations, I hope there's some way to nest them :Q   That is, [abc| ... [def| ... |] ... |] is not working now.
20:44:27 <Axman6> CindyLinz: does [abs| ... $([def| ...|]) ... |] work?
20:49:02 <CindyLinz> Axman6: trying... I think not.. because how to treate the $(...) is controlled by some user code for abs, and the first |] will be captured by GHC.
20:51:16 <CindyLinz> hmm.... Additionally, I think I could customize a [str| ... |] for multi-line string literal... XD
20:52:56 <monochrom> there are like 4 of those on hackage already, and I think 3 of them were written by Audrey Tang XD
20:54:06 <CindyLinz> XDD
20:54:21 <CindyLinz> Why she wrote it three times.... OAO
20:55:16 <CindyLinz> Axman6: GHC said: Template Haskell brackets cannot be nested (without intervening splices)
20:55:36 <CindyLinz> I don't know what does "intervening splices" mean..
20:55:52 <monochrom> it was hoped that the $(...) would serve as the intervening splice
20:56:19 <monochrom> but if you can't guarantee its existence, then too bad
20:59:30 <vamega2> Hi
20:59:37 <CindyLinz> I think that if we change the closing symbol |] into |abc], then we could at least nest different type of quotations. But if we need to nest the same type of quotations.. Maybe we could add an arbitrary label, like: [abc-1| ... [abc-x| ... |x] ... |1]
20:59:41 <vamega2> What's the recommended way to parse XML in Haskell?
21:01:06 <monochrom> you may begin with http://hackage.haskell.org/package/xml . but there are many, many more choices suiting more complex purposes
21:02:00 <vamega2> monochrom
21:02:10 <vamega2> Would you say that provides the simplest interface?
21:02:33 <[swift]> this error is just for haddock documentation, right? "Warning: We do not support associated types in instances yet."
21:02:53 <vamega2> I'm not all that experienced with Haskell.
21:02:53 <startling> [swift]: pretty sure that's right.
21:02:58 <startling> it just won't display in the docs.
21:03:03 <monochrom> yes, it's why this is a good first thing to try
21:03:10 <vamega2> Alright thanks.
21:03:26 <[swift]> startling: thanks! i can live with that.
21:03:59 <startling> I think it may have been fixed in Haddock HEAD.
21:06:18 <[swift]> nice.
21:15:26 <carter> haskell has magic parsing tools
21:34:25 <[swift]> i wish that you could rename things on export as well as import
21:38:37 <pavonia> [swift]: Well, you can define alias functions
21:38:57 <[swift]> pavonia: yeah, that's what i do for functions, but for types it's less clean
21:39:22 <[swift]> pavonia: you can define a type synonym but you'll still end up with the original name in the haddock
21:39:28 <smiller2> Hmm, Control.Category defines "class Category cat where".  But doesn't this only let you construct a category by specifying just the arrows of a category, where the objects are always types?
21:40:17 <startling> smiller2: I think so, yeah (barring PolyKinds)
21:40:36 <startling> I think there was talk of making Categry kind-polymorphic, but I forget if it happened or not
21:42:09 <shachaf> smiller2: Yep. A Category instance has Haskell types as objects, no matter what the arrows are.
21:42:57 <shachaf> There are a few ways to get a more general class. Polykinds is one, as startling mentioned. http://hackage.haskell.org/package/data-category has another approach.
22:13:35 * hackagebot riak-protobuf 0.16.0.2 - Haskell types for the Riak protocol buffer API  http://hackage.haskell.org/package/riak-protobuf-0.16.0.2 (MarkHibberd)
22:16:21 <jakex> are Monads not required to implement Functor?
22:16:52 <shachaf> An instance of Monad isn't required to be an instance of Functor, yes.
22:18:11 <jakex> I thought only applicative was an odd ball.. oh well, I'll just use liftM
22:19:36 <pavonia> In practice there shouldn't be any Monad without a corresponding Functor instance
22:20:29 <jakex> pavonia, yeah, but if I have a Monad m => signature I can't use fmap.
22:20:50 <pavonia> Ah, right
22:22:19 <dmj`> jakex: use liftM?
22:22:26 <startling> ^
22:22:36 <startling> oh, you said that already
22:28:08 <ReinH> jakex: No, Monad is not required to implement Functor.
22:28:23 <ReinH> jakex: a Monad is a Functor plus some other stuff.
22:28:44 <shachaf> You took a slightly imprecise phrasing and made it worse. :-(
22:28:50 <ReinH> :(
22:29:12 <ReinH> shachaf: how did I make it worse?
22:29:16 <shachaf> And your second sentence is missing the point, I think.
22:29:26 <shachaf> So I don't even know what you mean anymore.
22:29:27 <shachaf> Oh well.
22:29:39 <ReinH> shachaf: :(
22:30:13 <ReinH> shachaf: seriously, how did I make it worse?
22:30:25 <ReinH> what I said seems reasonable to me so I would like to know
22:31:28 <ReinH> I guess there are two interpretations of the question and I picked the wrong one.
22:34:04 <ReinH> shachaf: but I do wish your criticisms would be more informative than "you made it worse" "you're missing the point" "I don't even know what you mean any more"
22:34:33 <joelteon> well, that's how it is
22:34:51 <ReinH> joelteon: ...
22:35:07 <raphie_> what GUI framework would you folks recommend?
22:35:18 <shachaf> Ignore what I said. Nothing good will come of interaction between us.
22:35:56 <ReinH> shachaf: I'm not trying to be rude. I just wish I knew what you meant so I could learn.
22:37:43 <dmj`> raphie_: what are you trying to make
22:37:52 <raphie_> dmj`: mac text editor
22:38:12 <dmj`> raphie_: ooooh sounds cool :P
22:38:13 <joelteon> raphie_: Cocoa
22:38:19 <pavonia> raphie_: gtk2hs is the most sophisticated available for Haskell in my view
22:38:26 <ReinH> shachaf: :/
22:38:38 <joelteon> yeah, but nobody is going to use a mac editor based on GTK
22:38:39 * hackagebot riak 0.7.0.3 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.7.0.3 (MarkHibberd)
22:38:54 <joelteon> But if you don't care about that, then use gtk
22:38:58 <dmj`> raphie_: there used to be haskell bindings to objective-c... http://hoc.sourceforge.net/ ... not sure what the status is, maybe ask the ghc-ios people
22:39:08 <pavonia> joelteon: I don't know what that is
22:39:17 <joelteon> what what is
22:39:19 <joelteon> GTK?
22:39:24 <pavonia> a mac editor
22:39:30 <joelteon> OSX
22:40:05 <pavonia> I'm confused, isn't gtk supposed to work on all systems?
22:40:24 <joelteon> Yeah, I didn't say it didn't work, I said nobody would use it.
22:40:37 <dmj`> pavonia: it doesn't look native
22:40:41 <joelteon> There are already 50,000 text editors on OSX and building it on GTK is a massive step backward from the ones that have native GUI bindings.
22:40:47 <pavonia> Ahh
22:41:00 <joelteon> Doesn't look or act native
22:41:46 <startling> it's true.
22:42:29 <dmj`> raphie_: why not make the editor in the browser
22:42:49 <raphie_> dmj`: javascript is the devil and I like native speed / polish
22:43:09 <startling> raphie_, there's ghcjs
22:44:22 <joelteon> I don't know what the state of HOC is, but in the screenshots on the wiki they're still using the Aqua GUI.
22:45:52 <augur> Mon_Ouie: youre doing it backwards
22:45:56 <augur> the batman comes last
22:46:10 <augur> ugh
22:46:13 <augur> not Mon_Ouie
22:46:17 <augur> monochrom^
22:46:19 <augur> grrr
22:46:22 <augur> sorry Mon_Ouie :(
22:47:32 <ethercrow> raphie_: you could resurrect yi's cocoa frontend
22:51:48 <dmj`> canvas <- document ^. getElementById "canvas"
22:51:53 <dmj`> that looks pretty cool
22:51:57 <dmj`> from ghcjs
22:52:43 <startling> is that lens' (^.) or something else?
22:52:50 <startling> I guess something else.
22:52:53 <dmj`> yea, here: https://github.com/ghcjs/ghcjs-examples/blob/master/ghcjs-hello/src/Main.hs
22:53:11 <dmj`> its lens
22:53:57 <startling> I wonder what getElementById is, then
22:54:29 <startling> I guess a Lens' Document (IO DomNode), but that's weird.
22:55:53 <startling> hm, js1 makes it.
22:56:21 <startling> so I guess it's polymorphic
23:23:41 <eiro> hello
23:24:04 <eiro> i would like to simplify the expression
23:24:11 <eiro> map ( \x -> read x ::Int ) foo
23:24:29 <eiro> something like map read::Int foo
23:24:40 <eiro> any idea ?
23:25:03 <jakex> not sure if this is simplified, but.. map ( \x -> read x) foo :: [Int]
23:25:37 <jakex> you can also get away without writing any explicit types if type can be inferred from the context
23:26:52 <eiro> that's right: it is passed to as [Int] -> [Int] function so it will know what to do :)
23:27:16 <jakex> oh and that can be written as map read foo
23:28:05 <eiro> yep
23:28:22 <eiro> close to what i want :)
23:28:57 <eiro> offsets <- getArgs; print $ sizes $ map read offsets
23:29:17 <eiro> any way to escape from the <- ?
23:29:26 <eiro> i'm trying fmap
23:30:07 <shachaf> @undo do { offsets <- getArgs; print (sizes (map read offsets)) }
23:30:08 <lambdabot> getArgs >>= \ offsets -> print (sizes (map read offsets))
23:30:19 <eiro> no: fmap returns a IO [Int]
23:30:28 <jakex> perhaps this: print . sizes . map read offsets =<< getArgs
23:30:35 <jakex> maybe need parens
23:31:04 <jakex> remove offsets
23:32:03 <jakex> > print . length . words =<< getLine
23:32:04 <lambdabot>  <IO ()>
23:32:07 <eiro> [experimenting your lines]
23:42:32 <eiro> ok. i was unable to remove the intermediate name (offsets) so i'll keep my version.
23:42:37 <eiro> thanks!
23:43:27 <eiro> another question: sizes [] = []; sizes xs = zipWith (-) xs (0:xs)
23:43:40 <eiro> any way to remove the first pattern matching ?
23:45:10 <jakex> this did not work?  print . sizes . map read =<< getArgs
23:45:27 <SaBer> > zipWith (-) [] (0:[]) -- eiro
23:45:29 <lambdabot>  []
23:47:21 <eiro> SaBer, right: i just removed the line :)
23:47:24 <eiro> thanks
23:48:49 <eiro> jakex, you're right! i thought i tested it but i probably made a mistake
23:49:09 <eiro> now i'm trying to understand why it works :)
23:50:29 <shachaf> First understand the version lambdabot gave.
23:50:36 <SaBer> eiro: usually functions taking two lists terminate the result when one of the lists ends
23:55:46 <eiro> i got it! thanks everyone
23:56:04 <eiro> and yes shachaf: lambdabot helped :)
23:58:02 <eiro> + i discovered the >>= \ -> combo which will help for sure
