00:01:04 <yitz> zRecursive: ignore "Arrow =>", and interpret "a b c" as "(b -> c)", etc.
00:01:24 <zRecursive> sure
00:14:55 <jle`> i actualy kinda like the _ <- ... idiom
00:14:59 <jle`> am i crazy
00:16:16 <gamegoblin> Is there a way to make this prettier with something like liftM2?
00:16:18 <gamegoblin> g x = o >>= \f -> p >>= \y -> g (f x y)
00:18:32 <joelteon> @pl g x = o >>= \f -> p >>= \y -> g (f x y)
00:18:32 <lambdabot> g = fix ((((o >>=) . ((p >>=) .)) .) . (. flip id) . (.) . (.))
00:18:35 <joelteon> no
00:19:07 <shachaf> edsko: Did you figure out your typefamilies problem from a while ago?
00:20:47 <gamegoblin> That point free form is HILARIOUS
00:21:04 <joelteon> @pl g f = g f g
00:21:05 <lambdabot> g = fix (join flip)
00:30:39 <edsko> shachaf: I think I need agda :)
00:39:26 <thoughtpolice> haasn: maybe i wasn't clear. at the time i posted that info earlier, we were still at Openssl 1.0.1e+deb7u4. the Fix is in 101.e+deb7u5, which should now be available
00:39:29 <thoughtpolice> earlier it wasn't in the repositories
00:56:24 <zRecursive> :t fix
00:56:25 <lambdabot> (a -> a) -> a
00:58:29 <DogeHayashi> Is there a more concise way of writing a function whose patterns are all variants on f (G x) = H x?
01:22:26 <jle`> DogeHayashi: is H the same for all?
01:25:44 <DogeHayashi> jle`: Sadly not, but it's always either a type constructor from the same type, or (rarely) such a type constructor composed on top of a chain of functions
01:35:24 <jle`> DogeHayashi: can you give an example?
01:41:11 <DogeHayashi> jle`: http://lpaste.net/102416 (though, now I come to think of it, this is probably the most concise I'll get)
01:41:21 <DogeHayashi> (given that each leg has a different value type)
01:42:24 <DogeHayashi> just the fact that there's (almost) a pattern there and it hasn't been factored out in some way makes me itchy =p
01:50:05 <jle`> DogeHayashi: yeah, i'm not sure if you can make that any more precise
01:50:09 <jle`> er
01:50:11 <jle`> concise
01:50:28 <jle`> cause you have to handle every case
01:52:12 <DogeHayashi> jle`: ah well, thanks anyway =D
01:52:40 <jle`> np :)
02:04:52 <DogeHayashi> Fuuzetsu: (sorry for singling you out, you seem to be active with haddock stuff though): Is there any way to get the latest haddock working on ghc7.6, or is it ghc7.8 only?
02:06:16 <mietek> https://hackage.haskell.org/package/postgresql-orm — is this anywhere on GitHub? Is there a project page?
02:09:17 <merijn> DogeHayashi: Haddock is tied rather closely to GHC, so my guess is "7.8 only"
02:09:28 <pordan30> DogeHayashi: you should probably separate constants in ZExpression into a separate data type in order to avoid the partial function in your code. one way to simplify, however, and one that would save lots of time later, would be to define folds over your types and use those (or use the generic traversals library and so forth).
02:09:47 <merijn> mietek: Contact the maintainer?
02:10:21 <pordan30> whoops, i read the constantToZ the wrong way, it's not partial - sorry
02:11:06 <mietek> It appears to be quite frehs
02:11:09 <mietek> fresh*
02:11:09 <mietek> https://github.com/alevy/simple
02:11:24 <mietek> Has anyone tried using Simple?
02:22:56 * hackagebot tasty 0.8.0.4 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8.0.4 (RomanCheplyaka)
02:22:58 * hackagebot hails 0.11.1.1 - Multi-app web platform framework  http://hackage.haskell.org/package/hails-0.11.1.1 (DeianStefan)
02:26:36 <bernalex> http://lpaste.net/8418421927802044416 how would I do this using record syntax for the return?
02:26:54 <bernalex> (by return, I mean the new World that handle makes)
02:28:15 <merijn> bernalex: "w { runningWorld = updateRunning r }" (assuming the World is 'w')
02:28:43 <bernalex> merijn: ah. that easy. thanks.
02:31:54 <bernalex> merijn: however, with this I still need to match the r. is it possible to do this more elegantly?
02:32:04 <bernalex>     w { runningWorld = updateRunning (runningWorld w) }
02:32:06 <bernalex> is a bit clumsy
02:32:34 <tdammers> bernalex: lenses
02:32:54 <tdammers> if you lensify your record types, you can do something like:
02:33:11 <tdammers> set runningWorld whatever m
02:33:20 <bernalex> tdammers: except for lenses. I have been constantly swamped with work, so I haven't had time to learn lenses. it sucks, I know. but I don't even have weekends free. =/ hope I can find the time to learn them over Easter break.
02:33:52 <tdammers> I understand
02:34:06 <tdammers> I usually just keep this handy:
02:34:08 <tdammers> https://github.com/ekmett/lens/wiki/Operators
02:34:22 <bernalex> tdammers: looking at the github examples and an ekmett talk, I know they look infinitely useful.
02:34:54 <tdammers> the good news is that even if you only use a super small fraction of their power, you can already reap benefits galore
02:34:58 <bernalex> and while I do think that I would benefit (time-wise) if I stop up and learn them right now, psychology and things like that prevent me from doing it. ;-) too much other crap to do.
02:35:04 <tdammers> $(makeLenses ''MyType)
02:35:09 <tdammers> prefix all fields with _
02:35:20 <tdammers> use the first 5 entries in that link I pasted
02:35:34 <tdammers> that's really all you need to get to the break-even point
02:45:56 <ij> Has it ended?
02:47:45 <ocharles> bitemyapp: :D
02:47:48 <ocharles> Xb
02:47:51 <ocharles> oops
02:50:55 <DogeHayashi> dat netsplit
02:52:27 <nicoo> DogeHayashi: freenode's servers are being restarted to apply the OpenSSL fix
02:53:47 <malinus> why am I getting this "type error" in haskell? http://hastebin.com/kugadufema.hs . Both types inside Integral are part of Show. I don't get it
02:55:10 <tdammers> you have to explicitly declare that a has to be an instance of Show
02:55:18 <tdammers> you are declaring Integral, but not Show
03:03:10 <hc> not quite yet i think
03:04:38 <ast_> have seen this question in archives, but: is it normal that gloss (with glut) takes 100% cpu on linux?
03:09:36 <malinus> tdammers, I don't understand. What am I suposed to do then?
03:09:50 <tdammers> where it says (Integral a) =>
03:09:59 <tdammers> you have to say (Integral a, Show a) =>
03:10:08 <malinus> oh I see, thanks
03:18:10 <edsko> @pf \f g h a -> f (g a) (h a)
03:18:10 <lambdabot> Maybe you meant: pl bf
03:18:13 <edsko> @pl \f g h a -> f (g a) (h a)
03:18:13 <lambdabot> liftM2
03:18:19 <edsko> why do I keep forgetting that/
03:23:42 <zxq9> I've been making toy chat servers in C to experiment with different poll/event/select ways of handling sockets. Is there a Haskell tutorial or something for basic socket networking? What is the Haskellish way of doing concurrent connections?
03:24:15 <Axman6> lots of threads!
03:25:08 <zxq9> Axman6: Not really familiar with threads in Haskell. In C and Erlang I've been doing processes, not threads (seems easier to me). I haven't ever touched multiprocessing in Haskell.
03:25:16 <Axman6> zxq9: http://www.haskell.org/haskellwiki/Simple_Servers is probably a bit out of date but good
03:25:41 <Axman6> zxq9: it's dead simple, and extremely fast
03:26:14 <Axman6> basically you fork a new thread for each connection and the IO manager makes everything run really fast.
03:26:29 <tdammers> zxq9: Haskell does "green threads", so what you get is similar to Erlang processes - you get virtual threads multiplexed onto one or more hardware/OS threads
03:26:38 <zxq9> Axman6: Sounds comforting. I'm trying to get a better grip on this in several langauges, and learn new things each time.
03:26:45 <zxq9> Ahhh... That sounds nice.
03:27:07 <zxq9> I've avoided threading in C because that whole semaphore/lock business drives me up the wall, but Erlang was really easy.
03:27:18 <Axman6> Haskell will spoil you, you'll pine for the ease of concurrency in Haskell when you go back to other languages
03:27:25 <zxq9> Thanks for the link. I'll play with this. I love it when I have an evening to myself to try stuff like this.
03:27:48 <tdammers> concurrency is a lot easier (in *any* language) when you don't use mutable state though
03:28:00 <Axman6> sure is
03:28:17 <tdammers> (shared mutable state, that is - thread-local mutable state is much less problematic)
03:28:26 <quicksilver> in fact a few years ago the normal way to use GHC was not to use 'real threads'
03:28:33 <quicksilver> but you still used threads for multiplexed IO
03:28:40 <zxq9> Absolutely. I've sidestepped that entirely in C and Python with processes, but it seems that's uncommon. At least, there seems to be a lot more threading tutorials than multi-p tutorials.
03:28:41 <quicksilver> and it just woke up the right thread behind the scenes
03:28:47 <quicksilver> the real implementation was using select()
03:29:00 <quicksilver> these days most people actually do use real threads though.
03:29:47 <zxq9> Bah.. split :-/
03:30:18 <tdammers> zxq9: processes are nice in that they isolate things more thoroughly and at the OS level - you just can't have shared memory, and that's that
03:30:36 <k00mi> openssl update!
03:31:41 <zxq9> k00mi: Yeah, that bit us today. Again. :-/
03:35:17 <Axman6> wheeeee
03:35:19 <zxq9> Hahaha. The last few days I've been doing this in C and assembler, so Haskell's Network library looks soooooo tiny and simple by comparison.
03:38:16 <k00mi> I really like network-fancy
03:39:31 <zxq9> What are the advantages? (Not that I have a good basis for comparison just yet)
03:40:30 <LnL_> Does anyone know how to install glib on mavericks?
03:41:00 <mlen> LnL_: brew install glib
03:41:02 <zxq9> Axman6: That's really it? Basically loop sock, accept, fork, loop sock? Why don't they teach *this* in beginner tutorials?
03:41:17 <mlen> LnL_: if you're using homebrew. Otherwise you should start using it :)
03:41:38 <LnL_> mlen: I mean the package, I’m getting a syntax error in a C header
03:43:07 <mlen> LnL_: they have a precompiled version in homebrew
03:43:12 <mlen> if that's what you want
03:43:28 <pordan30> i have a sequence of data of fixed size that i would like to mutate with constant time access - is there some variation of array or vector that is most appropriate and plays nicely with pure code for these kinds of operations? i haven't explored these libraries much.
03:43:30 <mlen> s/precompiled/build/
03:43:39 <k00mi> zxq9: much higher-level API
03:44:48 <zxq9> k00mi: Than Network? Wow. You realize I just saw Network after writing in assembler and C, so this is taking a moment for my brain to adjust...
03:46:08 <LnL_> mlen: I’m trying to install ghc-viz, this is the cabal output https://gist.github.com/LnL7/c31a4fb7c14bc5bdf977
03:46:11 <k00mi> zxq9: network is pretty low-level by haskell standards ;)
03:47:56 <Axman6> zxq9: that Is the beginner tutorial :P
03:48:08 * hackagebot fpco-api 1.1.1.1 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.1.1.1 (MichaelSnoyman)
03:48:14 <zxq9> k00mi: I'll take your word for it. I'm not a complete Haskell noob, but networking code (application or kernel stack or drivers) is usually a bit of a bear.
03:48:38 <BoR0> I think I got basic intuition as to why associativity is important (so that a specific diagram can commute). but why is identity important for categories? what is its purpose?
03:48:42 <zxq9> but not on this side of the fence, apparently.
03:49:16 <BoR0> I understand why identity is important for multiplication or addition, but I can't abstract it away from that
03:53:08 * hackagebot conduit-extra 1.0.0.1 - Temporary placeholder package.  http://hackage.haskell.org/package/conduit-extra-1.0.0.1 (MichaelSnoyman)
03:55:42 <mlen> LnL_: oh, I thought you wanted a regular glib, not the Haskell bindings. sorry for the mixup. By the way, I don't see '=' symbols on the line mentioned by the script
03:56:08 <mlen> unfortunately it also fails to build on my mavericks
03:57:26 <LnL_> mlen: I think it might be an issue with xcode 5/clang
03:58:07 <mlen> LnL_: you can try to install gcc and update path/environment to prefer it over clang
04:01:51 <merijn> BoR0: Right, so why is identity important for multiplication/addition?
04:02:01 <LnL_> mlen: With gcc-4.2 I get symbol `^’
04:03:49 <mlen> LnL_: then you should contact the maintainer. You can try to compile gcc newer than 4.2, but it won't have the "extensions" that apple added to 4.2
04:04:31 <darthdeus> guys this is probably a noob quesiton, but are conferences like ICFP only for people who submit their paper? because for example here http://www.icfpconference.org/icfp2014/index.html i dont see anything like "register"
04:04:56 <mlen> LnL_: AFAIR I was able to compile gcc 4.6 on mac, but I don't know how it'll behave, as some flags that OSX uses don't work on vanilla gcc
04:09:47 <sagittarian> hey everyone, i have read (somewhere) that list concatenation is an example of a category, with ++ as the composition operator
04:10:10 <sagittarian> but if that's the case (from what i've read about category theory), that means that lists are morphism
04:10:19 <sagittarian> so what are the objects in this category?
04:10:59 <pranz> sagittarian: well, lists are monoids
04:11:07 <pranz> and monoids are categories with only one object
04:11:13 <mr-> sagittarian: if you like.. it has one object *
04:11:24 <pranz> so that all morphisms compose
04:11:24 <mr-> (what pranz said)
04:11:46 <sagittarian> ah i better read up on monoids
04:12:40 <mr-> don't.. You already gave the prototypical example. A set with a (n associative) binary operation and an identity element.
04:13:57 <sagittarian> so this one object is just some theoretical object that lists when thought of as morphism work on?
04:14:07 <sagittarian> i.e. it doesn't have any representation in Haskell's type system, right?
04:15:33 <pranz> sagittarian: I'm uncertain, but if I would guess what mr- said
04:15:42 <pranz> (*), the category of types
04:16:00 <pranz> but that sounds a little odd too
04:16:40 <mr-> Oh, that's not what I meant to say. I forgot about kinds.
04:17:09 <pranz> (the category of haskell types i should say)
04:17:14 <pranz> but hmm
04:17:22 <mr-> sagittarian: Haskell does not know that a monoid is a category. You'd have to define that instance yourself
04:17:32 <sagittarian> yeah i understand that
04:17:37 <sagittarian> i'm just trying to understand the theory
04:17:38 <mr-> (or maybe it's in Data.Category..)
04:17:42 <pranz> Cale: sup
04:17:54 <fizruk> could * be a set/type of all lists? each list xs can be thought of as (xs ++) section and xs <> ys then would be (xs ++) . (ys ++)?
04:18:26 <pranz> well, all lists are just [a] isn't it?
04:19:14 <mr-> sagittarian: in theory, it's just some object whose morphisms are lists ;-)
04:19:35 <mr-> sagittarian: if you want to be fancy, you could pick as object the type a such that the morphisms are [a]
04:19:40 <fizruk> i guess what I said does not make much sense, ignore
04:19:48 <pranz> sagittarian: I don't think it makes much sense to talk about this object, at least not in haskell
04:21:39 <sagittarian> okay, thanks everyone
04:22:39 <BoR0> merijn, why is it important I don't know. but I know it allows fancy stuff like m*1 = 1*m = m, i.e. when we apply the operation between identity element and some other object, we get the other object in return
04:23:46 <sagittarian> so monoids are a type of category, and functors/monads are mappings from one category to another (or the same one)?
04:24:49 <merijn> BoR0: Right, identity for category has the exact same effect
04:24:57 <mr-> sagittarian: yes
04:25:29 <sagittarian> ah, and if integers are also a category with + as the composition operator, then integers are also a monoid like lists, whose single object is also some abstract thing whose morphisms are integers
04:25:32 <sagittarian> right?
04:25:38 <mr-> sagittarian: monads are a little more, though
04:25:45 <merijn> BoR0: Note the similarity between monoid (mempty <> m = m, m <> mempty = m) and category (f . id = f, id . f = f)
04:25:46 <quchen_> fizruk: I don't know what you meant with "*", but the list type you described is DList.
04:25:49 <pranz> sagittarian: yes
04:25:51 <sagittarian> right, naturally
04:25:58 <pranz> sagittarian: but you should also check otu monoidal categories
04:26:09 <pranz> monoids only exist in relation to a monoidal category
04:26:25 <sagittarian> whoa
04:26:27 <pranz> or well
04:26:38 <pranz> a monoidal category is also a monoid
04:26:41 <mr-> sagittarian: now that you have lists as monoids and natural numbers as monoids, there's a nice functor between them ;-)
04:27:42 <pranz> which is also a monoid homomorphism
04:27:49 <BoR0> merijn, so one example would be if we don't have identity we can't have base case for some function which accepts list monoid and is recursive?
04:28:15 <mr-> bonus points on showing that monoid morphisms are the same as functors
04:28:27 <sagittarian> mr-, yes, length, that's what set me out on this whole journey
04:28:48 <sagittarian> i don't get what the difference is between a monoidal category and a monoid yet
04:28:57 <sagittarian> or what the relationship is between them
04:29:28 <pranz> a quick run
04:29:50 <mr-> sagittarian: You can define "monoid object" in any monoidal object. The "monoid is a set with binary operation..." is then a monoid object in the category of sets (which is a monoidal category with x)
04:30:10 <sagittarian> what's the relationship between the tensor product and the composition operator?
04:31:44 <merijn> BoR0: Well, let's take an example using functions instead of arrows
04:31:55 <mr-> sagittarian: what tensor product?
04:32:15 <merijn> BoR0: "foldr (.) id [f,g,h]"
04:32:18 <pranz> sagittarian: if you have tensor product T and composition operator mappend, mappend must have type (T a a -> a) for it to form a monoid on a
04:32:20 <sagittarian> wikipedia says that a monoidal category is defined with a tensor product
04:32:39 <fizruk> quchen_: i meant the only object in a list monoid category
04:32:54 <merijn> > foldr (.) id [f,g,h]
04:32:56 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
04:32:56 <lambdabot>    arising from a use of `e_1'
04:32:56 <lambdabot>  The type variable `b0' is ambiguous
04:32:56 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
04:32:56 <lambdabot>  Note: there are several potential instances:
04:32:57 <pranz> for example, (*) and (,) (the type constructor) forms a monoidal category with id ()
04:32:58 <merijn> aww
04:33:01 <pranz> the unit type
04:33:05 <merijn> > foldr (.) id [f,g,h] :: Expr
04:33:06 <lambdabot>  Couldn't match type `a0 -> b0' with `Debug.SimpleReflect.Expr.Expr'
04:33:06 <lambdabot>  Expected type: (b0 -> c0)
04:33:06 <lambdabot>                 -> Debug.SimpleReflect.Expr.Expr -> Debug.SimpleReflect.Expr....
04:33:06 <lambdabot>    Actual type: (b0 -> c0) -> (a0 -> b0) -> a0 -> c0Couldn't match expected t...
04:33:06 <lambdabot>              with actual type `a1 -> a1'
04:33:33 <merijn> > foldr (.) id ([f,g,h] :: Int -> Int)
04:33:34 <lambdabot>  Couldn't match expected type `GHC.Types.Int -> GHC.Types.Int'
04:33:34 <lambdabot>              with actual type `[t0]'Couldn't match expected type `[b0 -> b0]'
04:33:34 <lambdabot>              with actual type `GHC.Types.Int -> GHC.Types.Int'
04:33:40 <pranz> for example with list contatentation
04:33:50 <merijn> > foldr (.) id ([f,g,h] :: [Int -> Int]) -- last attempt
04:33:51 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr GHC.Types.Int)
04:33:51 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.f'
04:33:51 <lambdabot>  Possible fix:
04:33:51 <lambdabot>    add an instance declaration for
04:33:51 <lambdabot>    (Debug.SimpleReflect.Expr.FromExpr GHC.Types.Int)
04:33:54 <pranz> (++) :: [a] -> [a] -> [a]
04:33:57 <pranz> is isomorphic to
04:34:11 <pranz> ([a],[a]) -> [a]
04:34:19 <pranz> since (,) is the tensor product
04:34:29 <pranz> (++) and [a] forms a monoid with the empty list
04:34:51 <pranz> another example
04:35:19 <pranz> the category of endofunctors forms a monoidal category with functor composition as the tensor product and Identity functor as identity
04:36:08 <pranz> so a composition operator for a monoidal object must have type (m (m a) -> m a)
04:36:26 <pranz> join has that type, and with the return as identity, every monad is a monoid in the category of endofunctors
04:37:19 <sagittarian> (++) and [a] forms a monoid with the empty list as the identity, yes?
04:37:27 <pranz> sagittarian: yes
04:37:52 * sagittarian runs off to read about endofunctors
04:38:19 <pranz> sagittarian: endofunctors are just functions that map to the same category
04:38:22 <merijn> sagittarian: Endofunctors = functors that map to their origin category (if I understood this stuff correctly)
04:38:31 <sagittarian> ah got it
04:38:44 <merijn> \o/
04:38:47 <merijn> I was right
04:38:52 <bennofs> what does a "monoid in a category" mean? I thought a monoid is a 1-element category
04:38:55 <Axman6> @src Endo
04:38:55 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
04:39:00 <Axman6> @hoogle Endo
04:39:01 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
04:39:01 <lambdabot> Data.Monoid newtype Endo a
04:39:01 <lambdabot> System.Posix.Terminal EndOfFile :: ControlCharacter
04:39:12 <bennofs> :t Endo
04:39:12 <lambdabot> (a -> a) -> Endo a
04:40:15 <merijn> bennofs: You can model a monoid as a 1-element category, however, you can also have monoids arise within more complicated categories
04:40:37 <merijn> bennofs: In the same way that list being a monoid doesn't stop you from having a list filled with another monoid
04:41:44 <pranz> sagittarian: ^
04:42:20 <pranz> sagittarian: in what you said earlier that you saw monoids as a type of category
04:42:31 <pranz> sagittarian: as merjin says, you can model every monoid as a category
04:44:24 <sagittarian> ah wait, so a monoid (a monoid object) is the one object in a monoidal category (or at least that's one way to look at it)?
04:44:25 <pranz> but you can model every object as a category
04:45:15 <pranz> sagittarian: a monoidal category can have more than one object
04:45:54 <pranz> sagittarian: and a monoidal category isn't directly a monoid, but it forms a monoid with it's tensor product and the identity object from it
04:46:09 <sagittarian> ah okay
04:46:14 <pranz> so that "one" object is the category itself
04:46:17 <pranz> and not it's object
04:46:29 <pranz> objects*
04:49:47 <sagittarian> ah, so a category does not necessarily have an identity morphism
04:50:12 <sagittarian> if we can define one, then we can use that to make a monoidal category, with that identity object as the monoid
04:50:14 <sagittarian> yes?
04:52:19 <pranz> sagittarian: a category must have an identity morphism
04:52:31 <sagittarian> oh then nevermind
04:52:52 <pranz> sagittarian: but that doesn't make every category a monoid, because if it has several objects all morphisms won't compose
04:52:56 <bennofs> Can there be multiple monoid objects in one category? I think yes, because (), List, etc are all in haskell. Is this correct?
04:53:16 * hackagebot monad-logger 0.3.5 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.5 (MichaelSnoyman)
04:53:17 <pranz> bennofs: yes
04:56:38 <george2> I see . being used with words/unwords/etc a lot, in a way that seems similar to $, but the two are not the same. what is . used for?
04:57:06 <george2> it's hard to search for this kind of thing
04:57:35 <bennofs> @ty (.)
04:57:36 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:57:41 <bennofs> :t ($)
04:57:42 <lambdabot> (a -> b) -> a -> b
04:58:11 <bahamas> is it possible to define a function with multiple pattern matches in 'let' or 'where'?
04:58:16 * hackagebot streaming-commons 0.1.1 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.1 (MichaelSnoyman)
04:58:29 <bahamas> :t (.)
04:58:30 <AshyIsMe> george2: it's function composition
04:58:30 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:58:35 <AshyIsMe> http://learnyouahaskell.com/higher-order-functions
04:58:48 <pranz> george2: (f . g) x = f (g x)
04:58:58 <pranz> george2: f $ x = f x
04:59:06 <george2> interesting. so same idea, but different order.
04:59:44 <pranz> george2: not really, (.) composes functions
04:59:52 <sagittarian> okay, so a monoidal category is a category whose morphisms are all composable? is that at least an informally accurate way to look at it?
04:59:55 <pranz> george2: ($) applies a function to it's argument
05:00:13 <george2> ah, I confused composition and application
05:01:02 <sagittarian> and a monoid is the identity morphism in a monidal category?
05:01:05 <pranz> sagittarian: not quite
05:01:14 <bahamas> so, if I want to define a function to match multiple patterns in 'where' or 'let', using 'case' is my only option?
05:01:41 <pranz> sagittarian: do you understand how (*) is a monoidal category?
05:01:53 <pranz> :k (,)
05:01:54 <lambdabot> * -> * -> *
05:01:59 <pranz> (a hint)
05:02:39 <sagittarian> * meaning multiplication or the type of a type?
05:02:49 <corgifex> bahamas: no
05:02:55 <nicoo> * is the kind of types
05:02:59 <nicoo> sagittarian: ^
05:03:16 <sagittarian> i'm trying to understand what a monoidal category is in general, so no, not really
05:03:59 <pranz> a monoidal category is a category C with a tensor product (C -> C -> C)
05:04:07 <pranz> that is, the tensor product takes two object from C
05:04:13 <pranz> and gives a new object in C
05:04:39 <pranz> also, there must be an identity object
05:04:43 <pranz> if the tensor product is T
05:05:10 <pranz> T id x is isomorphic to x
05:05:25 <pranz> T x id is isomorphic to x
05:05:46 <bahamas> corgifex: myeah. I had forgotten to surround the x:[] pattern in parentheses
05:05:58 <sagittarian> okay, so a morphism is a mapping from one object to another, and the tensor product is a mapping from two objects to another, is that right?
05:06:17 <pranz> sagittarian: yes
05:06:29 <pranz> and you can see "T id" as the Identity functor
05:08:12 <sagittarian> okay, so what's the difference or relationship between the tensor product of a monoidal category and the composition operator of the category?
05:08:27 <sagittarian> ah the tensor product is defined on objects and composition is defined on morphisms?
05:08:39 <sagittarian> of a given category
05:10:48 <bennofs> sagittarian: as I understand it, the tensor product gives you a way to define "multiple argument morphisms": You only choose the source to be the tensor product of all the "inputs" (you "merge" multiply objects into one. )
05:11:00 <pranz> sagittarian: the tensor product is a compositional operator, since T, C and id object forms a monoid
05:11:39 <sagittarian> okay, so lists are a category (monoid), ++ is the composition operator, is ++ also the tensor product?
05:15:01 <pranz> sagittarian: yes, in that sense
05:15:46 <sagittarian> i still don't see the difference between the tensor product and categorical composition of morphisms
05:15:56 <sagittarian> what's an example of a category that is not a monoidal category?
05:17:40 <pranz> sagittarian: a category with no objects
05:18:29 <sagittarian> okay, so for practical purposes can we say that basically all categories are monoidal?
05:18:39 <sagittarian> wait
05:18:42 <sagittarian> uh
05:19:01 <sagittarian> haskell types with functions as morphisms are a category right?
05:19:06 <sagittarian> but they're not a monoidal category?
05:19:20 <sagittarian> why not?
05:19:21 <bennofs> sagittarian: they are.
05:19:27 <sagittarian> they are?
05:19:44 <bennofs> I think (,) :: * -> * -> * is the tensor product
05:21:07 <yitz> sagittarian: you can always define a tensor product of some kind, as long as there is at least one object you can use as the identity. the question is how useful your tensor product is.
05:22:02 <sagittarian> ah okay
05:22:06 <yitz> bennofs: or Either, if you allow the void type.
05:23:43 <sagittarian> so given a category (with at least one object), can i always define a monoidal category using the set of morphisms to define the tensor product and the identity morphism?
05:27:30 <yitz> sagittarian: the tensor product is a functor, not a morphism. you can define the functor however you'd like, as long as it satisfies the functor laws.
05:27:55 <yitz> sagittarian: again - that doesn't mean it will necessarily be useful.
05:28:33 <byorgey> bennofs: Hask is monoidal in multiple ways.  Either is also a tensor product.
05:28:59 <sagittarian> right, i mean, define the tensor product T such that T x y = x . y for all x, y
05:29:22 <yitz> byorgey: only if you allow the void type, which isn't in haskell 98.
05:30:04 <bennofs> yitz: how can the tensor object be a functor? Doesn't a functor take one object to one object? But this functor takes two objects to one object
05:30:16 <sagittarian> oh wait a sec
05:30:52 <mr-> bennofs: it's a functor from the product category
05:31:01 <yitz> bennofs: the tensor product is by definition a bifunctor from C X C -> C
05:31:16 <byorgey> yitz: fair enough.
05:32:09 <byorgey> yitz: uh, it's in Haskell 2010 though.
05:32:23 <LnL_> mlen: Thanks for the help, it took a while to compile, but it works with gcc-4.8 from homebrew-dupes
05:33:16 <yitz> byorgey: is it? ok. then Either is a pretty darn good tensor product.
05:37:30 <byorgey> =)
05:37:45 <bennofs> Is A -> A both a morphism and an object in Hask?
05:38:08 <byorgey> bennofs: A -> A is an object in Hask.  Functions of type  A -> A  are morphisms.
05:38:19 <bennofs> Ah ok
05:39:11 <sagittarian> where A is any type, so really a -> a?
05:39:21 <augur> no
05:39:26 <augur> A has to be fixed
05:39:33 <augur> otherwise its not an arrow in hask
05:39:44 <byorgey> where A is any type, yes.  But  a -> a === forall a. a -> a  is a different beast.
05:40:58 <augur> byorgey: is forall a. a -> a even an nattrans? i think there's some reason why polymorphism and naturality arent the same thing, no?
05:41:19 <byorgey> augur: yes, forall a. a -> a  is a natural transformation
05:41:29 <augur> byorgey: well, that particular one is :p
05:41:38 <byorgey> polymorphism is the same as a suitably generalized notion of naturality
05:41:54 <augur> really?
05:42:05 <byorgey> natural transformations in particular don't cover everything.  But dinatural transformations do.
05:42:12 <augur> hm
05:42:20 <byorgey> (assuming you stick to rank-1 polymorphism)
05:42:29 <augur> interesting
05:42:40 <byorgey> I have an almost-finished blog post about this.  I really ought to finish it up.
05:43:23 <byorgey> in particular, natural transformations are between two covariant functors.  But that doesn't cover situations where the type variable shows up contravariantly.
05:49:08 <jophish> There's no syntax to say: type (F :: * -> *) a = a; is there?
05:49:26 <jophish> one can only specify kinds on the type variables
05:57:10 <dart> hi
06:05:00 <sagittarian> hi dart
06:05:32 <joneshf-laptop> is there a typeclass that encapsulates the ideas of a collection?
06:06:52 <New2Haskell> Hello guys, i am currently working on some functions to practise recursive functions in Haskell. I have made a function that calculates the surface of different shapes called oppervlakte. I now try to create a function that accepts a list of figures and returns  the one with the biggest surface. This is what I have atm: http://lpaste.net/102422 it wont compile and Idk why, it seems logical to me
06:06:53 <sagittarian> joneshf-laptop, what operations do you want defined on a collections?
06:07:27 <joneshf-laptop> sagittarian, good question
06:08:08 <joneshf-laptop> New2Haskell, what's the error?
06:08:24 * hackagebot hPDB 1.1.2 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.1.2 (MichalGajda)
06:08:32 <New2Haskell> Couldn't match expected type `Float' with actual type `Geofig'     In the second argument of `(>)', namely `maxTail'     In the expression: oppervlakte x > maxTail     In a stmt of a pattern guard for                    an equation for `maximumopp':       oppervlakte x > maxTail
06:09:39 <joneshf-laptop> New2Haskell, so that pretty much tells you the problem. The gist of it is, you've got a type mismatch
06:10:10 <joneshf-laptop> :t (>)
06:10:11 <lambdabot> Ord a => a -> a -> Bool
06:10:26 <joneshf-laptop> New2Haskell, `Float` and `Geofig` aren't in the same `Ord` class it seems
06:10:32 <New2Haskell> oh
06:10:45 <New2Haskell> But maximumopp figuur1 returns a float
06:10:48 <New2Haskell> float is ord right?
06:11:07 <croyd> New2Haskell: maximumopp returns the max Geofig but not its area
06:11:26 <New2Haskell> yes that is correct I need the object itself
06:11:44 <New2Haskell> And hoped the inner functions would handle the comparisson
06:11:48 <joneshf-laptop> New2Haskell, the problem is directly that line
06:12:00 <joneshf-laptop> New2Haskell, it seems to be an operator precedence line
06:12:06 <joneshf-laptop> s/line/error/
06:12:44 <joneshf-laptop> because `oppervlakte` has type `Geofig -> Float`
06:13:08 <New2Haskell> oppervlakte has Geofig -> float
06:13:16 <croyd> `oppervlakte x > maxTail` compares a Float (oppervlakte x) to a Geofig (maxTail)
06:13:17 <New2Haskell> and x is  a geofig in that particular line
06:13:25 * hackagebot hPDB-examples 1.1.2 - Examples for hPDB library  http://hackage.haskell.org/package/hPDB-examples-1.1.2 (MichalGajda)
06:13:52 <New2Haskell> so i'd have to convert maxtail to a float
06:13:55 <New2Haskell> basicly
06:14:21 <New2Haskell> But I do want to return the object itself and not the float number so doesnt that get messed up?
06:14:24 <joneshf-laptop> or make `Geofig` an instance of `Ord` and not do the conversion manually
06:14:26 <sagittarian> New2Haskell, try maximumopp = maximumBy (compare `on` oppervlakte)
06:14:37 <joneshf-laptop> or that ^
06:14:52 <joneshf-laptop> although that gets rid of the recursion
06:14:54 <New2Haskell> Yeh ive tried that, didnt work out for me yet
06:15:09 <New2Haskell> But I tried to break it down to the basics just for learning purposes
06:16:28 <joneshf-laptop> actually, isn't line 13 returning the wrong type anyway?
06:17:12 <joneshf-laptop> `oppervlakte x` is a `Float`
06:17:23 <New2Haskell> I dont think so because in the end x gets returned and not oppervlakte x
06:17:27 <New2Haskell> not sure about this though
06:19:22 <joneshf-laptop> also, what language is that?
06:19:29 <joneshf-laptop> i want to say Dutch?
06:19:46 <New2Haskell> Yes its Dutch
06:19:55 <joneshf-laptop> cool
06:20:21 <New2Haskell> oppervlakte means surface
06:20:46 <joneshf-laptop> Vierkant = square?
06:20:49 <New2Haskell> yes
06:20:55 <joneshf-laptop> cool
06:21:04 <New2Haskell> driehoek = triangle and rechthoek = regtangle
06:21:38 <joneshf-laptop> so in anycase, you should be able to fix the comparison type issue on line 13, and see whether or not the return value on line 13 is right
06:21:52 <joneshf-laptop> if you get stuck with stuff, you can always check types in ghci
06:22:41 <joneshf-laptop> :t  oppervlakte (Cirkel 3 "wat")
06:22:42 <lambdabot> Not in scope: `oppervlakte'
06:22:42 <lambdabot> Not in scope: data constructor `Cirkel'
06:22:43 <joneshf-laptop> and whatever
06:24:40 <New2Haskell> ill try to go on with it
06:24:43 <New2Haskell> thx 4 the advice
06:28:28 <joneshf-laptop> sagittarian, as far as collections, things like adding, removing, count/length, emptiness, filtering
06:29:37 <bezirg> question: I compiled a Haskell program to bin code (let's call it Main.exe). Can I create a Haskell programming construct that sends itself (the bin code loaded and currently executing) to another machine? For example `sendMyCode "example.com"`. Can this be achieved in Haskell or any other language? Ofcourse, let's assume that the target machine is of the same os and arch
06:30:26 <tdammers> bezirg: at least on *nix, you can fake it by simply getting your 0-th argument and passing that to openFile
06:30:41 <bezirg> tdammers: awsm
06:30:50 <bezirg> tdammers: thank you!
06:34:23 <sgronblo> I'm trying to do cabal install cabal-install, but getting an "ExitFailure 1" error when building.
06:34:43 <Guest99083> Hi guys ..I made a binaryTree http://lpaste.net/102424. is it possible to write a function to check if my tree is complate
06:35:09 <merijn> sgronblo: Try running with -v3
06:35:09 <gansteed> Hi,everybody, Can you tell me how to understand "like normal functions, you can pattern match in lambdas. The only difference is that you can't define several patterns for one parameter, like making a [] and a (x:xs) pattern for the same parameter"?
06:35:10 <bezirg> tdammers: can it be the case even if I use the same os/arch for my target , that the code will not run there?
06:35:30 <merijn> bezirg: Yes, if you are dynamically linking libraries not installed on the target
06:35:34 <bezirg> tdammers: assuming I don't use any dynamic link in Haskell
06:35:50 <merijn> bezirg: By default ghc dynamically links all C libraries
06:35:51 <gansteed> and why like (x:xs) calls several patterns ?
06:35:58 <yitz> gansteed: only one equation for a lambda
06:36:03 <bezirg> merijn: ahh u r right
06:36:14 <merijn> bezirg: Which should only by libgmp unless you're dependency include other libraries
06:36:48 <yitz> gansteed: they mean, with a named function you can do "let foo (x:xs) = stuff; foo [] = other stuff"
06:36:58 <sgronblo> merijn: Uh that produced a whole lot of output
06:37:16 <tdammers> bezirg: normally, you have at least a dependency on libgmp (for Integer)
06:37:32 <tdammers> bezirg: plus any libraries that FFI packages depend upon
06:37:34 <merijn> sgronblo: Right, that's verbose mode, right before "ExitFailure" it should say something about why it fails
06:38:19 <Jonh_nL> Can some one help me with my tree?, I made a tree http://lpaste.net/102424. now I want to check of my tree is complate ( left and right node must be the same value.
06:38:31 <yitz> sgronblo: it's not always right before the ExitFailure. if there's not obvious problem there, browse further up for something that looks like it's going wrong. or just paste the whole thing and we'll look at it.
06:38:49 <Jonh_nL> http://lpaste.net/102425
06:39:42 <sgronblo> I dont see anything that looks like an obvious error
06:40:06 <yitz> Jonh_nL: looks good to me. give it a try.
06:41:27 <Jonh_nL> yitz: I need a function that check the left and the right node, and if the left/right node has the same value ( than the tree is complate
06:41:34 <Jonh_nL> I need something like that
06:42:17 <Jonh_nL> my Tree http://lpaste.net/102425
06:42:54 <sgronblo> Is "World file is already up to date" an error?
06:43:01 <yitz> Jonh_nL: did you try writing that? where are you stuck?
06:43:27 <Jonh_nL> I have no idea how to begin
06:43:46 <Jonh_nL> I need to define a function to determine whether a binary tree is complete.
06:44:03 <Jonh_nL> so I make a Tree
06:45:21 <sgronblo> http://lpaste.net/1709398353902567424 here is the output in case any one has the time to try to help me
06:45:53 <Jonh_nL> you understand my problem
06:46:01 <Jonh_nL> yitz: you understand my problem
06:46:28 <tobani_> Jonh_nL:  so you want something like isComplete:: Tree a -> Bool ?
06:46:42 <sagittarian> joneshf-laptop, you could define your collection typeclass very easily, are you just asking about whether something already exists in order to reuse it?
06:46:50 <Jonh_nL> such a thing
06:47:24 <Jonh_nL> tobani_: such a thing yes .. I have no idea how to begin with writing
06:47:33 <joneshf-laptop> sagittarian, yes
06:47:51 <tobani_> Jonh_nL:  so split it up into the same cases like you did with add
06:48:05 <tobani_> isComplete Leaf l = ?
06:48:40 <joneshf-laptop> sagittarian, more, is there some defacto that I don't know about
06:48:55 <Jonh_nL> A binary tree is complete if the two branches (sub-trees) of each button a similar large. Define a function to determine whether a binary tree is complete
06:49:30 <Jonh_nL> tobani_: can you please help me out a bit .. If I have a  start it would be nice
06:50:46 <merijn> How can I check whether I have 64bit or 32bit ghc?
06:51:15 <tobani_> Jonh_nL:  I feel like something like something is being lost in the translation there?  You want to know if they're a similiar size, or if they have the same sum of values?
06:51:53 <CindyLinz> merijn: use   maxBound :: Int ?
06:51:58 <CindyLinz> > maxBound :: Int
06:51:59 <lambdabot>  9223372036854775807
06:52:11 <CindyLinz> lambdabot is 64 bit.. :p
06:52:19 <Jonh_nL> same sum of values
06:52:27 <Jonh_nL> sorry for my Engelish
06:52:34 <merijn> CindyLinz: No
06:52:35 <joneshf-laptop> > log maxBound / log 2
06:52:36 <lambdabot>  No instance for (GHC.Show.Show a0)
06:52:36 <lambdabot>    arising from a use of `M85912523415066712117944.show_M85912523415066712117...
06:52:36 <lambdabot>  The type variable `a0' is ambiguous
06:52:36 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
06:52:36 <lambdabot>  Note: there are several potential instances:
06:52:45 <joneshf-laptop> > log maxBound / log 2 :: Int
06:52:46 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
06:52:46 <lambdabot>    arising from a use of `GHC.Real./'
06:52:46 <lambdabot>  Possible fix:
06:52:46 <lambdabot>    add an instance declaration for (GHC.Real.Fractional GHC.Types.Int)No inst...
06:52:46 <lambdabot>    arising from a use of `GHC.Float.log'
06:52:54 <joneshf-laptop> oh bother
06:53:05 <merijn> CindyLinz: That seems very unreliable, considering the report doesn't state Int is a machine word
06:53:12 <tobani_> Jonh_nL: no problem I'm just making sure wre' on the same page
06:53:17 <CindyLinz> merijn: true..  XD
06:53:19 <tobani_> we're*
06:53:40 <merijn> hmm
06:54:01 <tobani_> Jonh_nL: is a leaf node complete?
06:56:52 <Jonh_nL> tobani_: yes so I need to check if my tree leaf ( right and left) has the same value
06:57:34 <byorgey> > log (fromIntegral (maxBound :: Int)) / log 2
06:57:36 <lambdabot>  63.0
06:57:49 <byorgey> joneshf-laptop: ^^^
06:59:02 <tobani_> Jonh_nL: then you've go this so far http://lpaste.net/102424
06:59:38 <byorgey> sgronblo: that is very strange.  It looks like GHC just... gives up
06:59:41 <Algebr> Are all the symbolic functions meant to be used infix?
06:59:53 <yitz> merijn: in practice CindyLinz's solution does work for ghc though
07:00:23 <sgronblo> byorgey: well i hadnt used haskell on my laptop in months
07:00:43 <yitz> merijn: we have 32-bit and 64-bit ghc builds around, and that does distinguish between them.
07:00:45 <byorgey> sgronblo: ah, so GHC was out of practice? ;-)
07:00:46 <Jonh_nL> tobani_: thnx let me play and understand your code
07:00:50 <sgronblo> i might have installed ghc through brew and then upgraded to mavericks or something
07:01:03 <sgronblo> byorgey: yeah i think it still
07:01:06 <sgronblo> is
07:01:30 <spacekitteh> can you override typeclass implementations for newtypes?
07:01:43 <sgronblo> well actually yesterday, brew was telling me i didnt have haskell-platform installed but i did have ghc
07:01:45 <yitz> Algebr: yes.
07:02:00 <sgronblo> i dont think i would have installed ghc without installing haskell-platform
07:02:03 <byorgey> spacekitteh: what do you mean?
07:02:04 <yitz> Algebr: you can use them prefix if you surround them by parens:
07:02:07 <dwcook> Algebr, if by "symbolic functions" you mean the infix functions, probably whoever named it decided it would be most convenient to make it infix than prefix
07:02:08 <yitz> > 5 + 3
07:02:09 <lambdabot>  8
07:02:12 <yitz> > (+) 5 3
07:02:13 <lambdabot>  8
07:02:19 <dwcook> But you can switch at will between infix and prefix anyway
07:02:27 <dwcook> > let f = (+) in 1 `f` 2
07:02:29 <lambdabot>  3
07:02:36 <Algebr> yitz: right, so >> and >>= are really infix functions too, right
07:02:44 <yitz> Algebr: yes
07:02:44 <joneshf-laptop> byorgey, thanks
07:02:50 <tobani_> Jonh_nL:  You can define isComplete the same way you did add, define a case for Leaf and a case for Node.  You have a way of getting the sum of a subtree (add), you just need a comparison on there... unless I'm missing something.  Do all subtrees of every node need to be equal?
07:03:31 * hackagebot tz 0.0.0.5 - Efficient time zone handling  http://hackage.haskell.org/package/tz-0.0.0.5 (MihalyBarasz)
07:03:34 <spacekitteh> byorgey: say i have a datatype "Vector" and i have implemented the Num class for it. let's say that i newtype it to "Manifold" and "ManifoldTangent". can i override the (+) function for the Manifold newtype so that i cannot add two manifolds together?
07:03:35 <yitz> Algebr: you can do the opposite, too: for regular prefix functions, you can use them as infix if you enclose them in backticks (only works for functions of 2 or more arguments of course):
07:03:57 <yitz> Algebr: > map head ["abc", "def"]
07:04:04 <yitz> > map head ["abc", "def"]
07:04:05 <lambdabot>  "ad"
07:04:12 <Jonh_nL> tobani_; yes
07:04:13 <yitz> > head `map` ["abc", "def"]
07:04:13 <lambdabot>  "ad"
07:04:22 <byorgey> spacekitteh: yes.  There is no need to override, in fact.  If  newtype Manifold = Manifold Vector  then Manifold does NOT inherit any instances of Vector, unless you tell it to
07:04:31 <byorgey> spacekitteh: so by default you cannot add two Manifolds
07:04:56 <spacekitteh> byorgey: really? weird, okay. i thought i was doing that before :S
07:05:01 <Algebr> yitz: thanks.
07:05:25 <byorgey> spacekitteh: doing what before?
07:05:48 <spacekitteh> i thought i was using (+) with two newtype'd things
07:06:28 <byorgey> spacekitteh: well, you can if you have   'deriving (Num)'  after the newtype declaration
07:06:41 <yitz> byorgey: now here's where we need lambdabot to support newtypes
07:06:53 <byorgey> yitz: yes, that would be nice!
07:06:56 <dwcook> byorgey, think that also requires GeneralizedNewtypeDeriving, right?
07:07:00 <byorgey> dwcook: yes
07:07:07 <spacekitteh> alright, cool. :)
07:07:22 <spacekitteh> incidentally, i wish (+) allowed you to add two different types together, lol.
07:07:51 <spacekitteh> not always, of course :D just in this instance it'd be nice to be able to add a point of an affine space to a vector space
07:08:04 <byorgey> spacekitteh: ah, in that case you don't want Num =)
07:08:11 <dwcook> You can define your own adding operation that does that
07:08:15 <byorgey> spacekitteh: you want the AffineSpace type class from the 'vector' package
07:08:23 <byorgey> uh, 'vector-space', not 'vector'
07:08:34 <byorgey> spacekitteh: http://hackage.haskell.org/package/vector-space-0.8.6/docs/Data-AffineSpace.html
07:09:35 <spacekitteh> byorgey: oooh, that's a nice package.
07:09:49 <byorgey> you could also use the 'Affine' class from the 'linear' package: http://hackage.haskell.org/package/linear-1.10/docs/Linear-Affine.html  though I think vector-space is a bit more beginner-friendly.
07:10:06 <spacekitteh> do you know of anything from numeric-prelude which has the same behavior?
07:10:42 <byorgey> it's been a long time since I used numeric-prelude
07:10:52 <byorgey> looks like numeric-prelude defines vector spaces but not affine spaces
07:10:56 <spacekitteh> yeah :(
07:11:54 <zq> fmap fmap fmap
07:12:02 <zq> god i love fmapping
07:15:01 <dwcook> @type fmap fmap fmap
07:15:02 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:15:04 <dwcook> @type fmap . fmap
07:15:04 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:15:07 <Algebr> Since the do notation is just sugar, that's why doing :t (<-) doesn't work?
07:15:13 <corgifex> Algebr: yes
07:15:24 <byorgey> Algebr: right. <-  is syntax, not an operator.
07:15:26 <dwcook> Algebr, the real reason is that <- is syntax, not an operator.
07:15:40 <tdammers> :t then -- doesn't work either
07:15:40 <lambdabot> parse error on input `then'
07:16:16 <tdammers> nothing to do with sugaring, really
07:16:23 <tdammers> :t (=>)
07:16:24 <lambdabot> parse error on input `=>'
07:16:25 <tdammers> same
07:16:46 <corgifex> you could argue that if/then/else is sugar
07:16:57 <tdammers> all syntax is sugar ;)
07:17:06 <george2> why, when I do "interact $ unlines . words. unwords . lines", does nothing print until I Ctrl-D? If I do "interact $ unlines . lines", it prints after each newline.
07:17:12 <dwcook> corgifex, sure, but that's not the reason why you can't get the type of then
07:17:43 <dwcook> "then" is part of a syntactic production. It doesn't matter whether the syntax it's part of "desugars" to anything else.
07:18:59 <christiaanb> hello, is there a way in the .cabal file or Setup.hs to force dynamic-executable ?
07:19:12 <byorgey> george2: lazy I/O is a strange, inscrutable beast.
07:19:23 <corgifex> it's totally scrutable
07:20:19 <george2> Is there a way to change that behavior? Maybe something with hSetBuffering or something?
07:20:33 <corgifex> nothing to do with I/O
07:20:44 <corgifex> the algorithm you wrote requires it
07:20:57 <george2> hrm :/
07:20:59 <merijn> christiaanb: You mean dynamically linking the program?
07:21:27 <corgifex> george2: in effect, words . unwords. lines lags one line behind
07:21:32 <christiaanb> merijn: yes, there's normally the option in the user's cabal config file
07:21:42 <christiaanb> merijn: but it's disabled by default
07:21:43 <corgifex> george2: i.e. if you type three lines into the program, it will output two
07:22:15 <christiaanb> merijn: but I want people who do a 'cabal install' "my_executable" to get the dynamically linked version
07:22:18 <corgifex> you can think about this in terms of stream processors
07:22:33 <merijn> christiaanb: Just set the right flag in your Ghc-Options field?
07:22:54 <george2> but `words $ unwords $ lines "hi\nthere"` has the expected results, why is it different if the input is from IO rather than String?
07:23:09 <corgifex> george2: what does that have to do with anything?
07:23:24 <george2> I don't understand why it lags a line behind
07:25:12 <christiaanb> merijn: yeah… I guess I can try that
07:25:31 <corgifex> > (words . unwords . lines) ("foo\nbar\n" ++ error "!")
07:25:32 <lambdabot>  ["foo"*Exception: !
07:25:45 <corgifex> see? it explodes after "foo". no "bar" in the result
07:26:09 <corgifex> this demonstrates that it has to read ahead before it can return "bar"
07:26:17 <corgifex> (thus triggering the exception)
07:26:30 <george2> hm, ok
07:26:33 <corgifex> in the I/O case, that "reading ahead" will simply sit there, waiting for more input
07:26:35 <byorgey> george2: it's because after doing  unwords . lines,  there's no way to know whether the last word is complete yet or whether more letters are coming
07:26:54 <byorgey> even though we "know" looking from the outside that it is
07:26:58 <byorgey> but 'words' can't tell
07:26:59 <corgifex> words looks for spaces to know whether the current word is done
07:27:11 <corgifex> unwords adds spaces only between words, not after the last word
07:27:23 <corgifex> so unwords needs to know whether it has reached the end
07:28:02 <corgifex> so unwords can't proceed before it has seen either the end of the input or the beginning of the next word
07:28:11 <george2> well then maybe I'm doing this the wrong way. How can I operate on each "word" of an input string, but accept/print one line at a time?
07:28:17 <corgifex> which in turn means words can't proceed because it hasn't seen end or space
07:28:33 * hackagebot HTF 0.11.3.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.3.0 (StefanWehr)
07:28:39 <corgifex> george2: example/
07:28:41 <corgifex> ?
07:30:12 <merijn> What's the simplest way to change an element at index i in a list? "\x -> take i list ++ (x : drop (i+1) list)"?
07:30:40 <quchen_> merijn: That will append x when the list is too short, though.
07:30:43 <george2> Reading https://stackoverflow.com/questions/6190496/haskell-io-with-interact-and-map, I saw that I can operate on lines of input with interpret. However, I need to work with words, not just lines. so for that example, "test test\n" would print  "test! test!\n"
07:30:52 <merijn> quchen_: Don't care
07:31:18 <quchen_> merijn: I think you should do a `splitAt` instead of take+drop, but apart from that that's the simplest way I think.
07:31:24 <merijn> actually
07:31:28 <merijn> I can do simpler, I think
07:32:03 <corgifex> george2: interact (unlines . map (unwords . map (++ "!") . words) . lines)
07:33:00 <george2> corgifex: ... really? I just need to handle words inside the map?
07:33:37 <george2> well, I wish I had thought of that. thanks.
07:34:04 <corgifex> interact (unlines . map f . lines) is a reasonably common pattern
07:34:15 <corgifex> "loop over input lines"
07:34:22 <quchen_> merijn: Oh, I just realized ViewPatterns can make use of bindings of the same pattern matching, i.e.
07:34:25 <quchen_> > let insert n x (splitAt n -> (before, after)) = before ++ [x] ++ after in insert 3 42 [1..10]
07:34:26 <lambdabot>  [1,2,3,42,4,5,6,7,8,9,10]
07:34:30 <quchen_> Fancy.
07:34:49 <merijn> quchen_: Everyone keeps trying to tell me to do things "properly" even though I just want quick ghetto hacks to get my code to run >.>
07:35:14 <corgifex> quchen_: have you seen the view pattern version of map?
07:35:42 <quchen_> corgifex: A long time ago when I didn't know ViewPatterns. Got it handy?
07:35:52 <corgifex> map _ [] = []; map f ((f -> y) : (map f -> ys)) = y : ys or something like that
07:36:38 <quchen_> > foldr (.) id (replicate 3 tail) [1..10] -- take 3. Ghetto enough, merijn?
07:36:39 <lambdabot>  [4,5,6,7,8,9,10]
07:36:45 <quchen_> s/take/drop/
07:37:26 <quchen_> corgifex: I think they even made it so the RHS only had a single letter. Might be misremembering though
07:37:30 <merijn> quchen_: That's not very ghetto, that's just convoluted for no reason
07:37:45 <corgifex> > iterate tail [1 .. 10] !! 3
07:37:46 <lambdabot>  [4,5,6,7,8,9,10]
07:37:49 <quchen_> > foldr (.) id (replicate 3 tail) [1] -- Oh it is ghetto.
07:37:50 <lambdabot>  *Exception: Prelude.tail: empty list
07:38:16 <fizbin> "ghetto" == "brittle" ?
07:38:27 <merijn> fizbin: That's implied, yes :p
07:38:38 <merijn> Witness this beauty from the current code
07:38:51 <quchen_> I'm not sure what ghetto means. Just picture it as a number, where it's clear that it's at least numberwang.
07:39:18 <merijn> ((_:_:num_edges:_):_:(_:_:num_vertices:_):_) <- map (map read . words) . lines <$> readFile meta
07:39:29 <corgifex> do not want
07:39:55 <quchen_> I think calling a bash script via System.Process would be cleaner :s
07:40:43 <fizbin> To be fair, the task being asked for is kind of ugly.
07:41:07 <Mango_Man> in ghci, i see this: Use -v to see a list of the files searched for.
07:41:19 <Mango_Man> but :l <some_file>.hs -v doesn't work!
07:41:29 <geekosaur> nice only the least useful line of the error
07:41:38 <Mango_Man> is that the right syntax?
07:41:53 <corgifex> Mango_Man: no
07:42:09 <Mango_Man> corgifex: what's the right syntax?
07:42:14 <corgifex> ghci -v
07:42:25 <fizbin> I mean "take the third word of the first line and the third word of the third line, and read them both" is a kind of ugly thing to ask.
07:43:05 <Mango_Man> corgifex: d'oh, why would that message be in the interpreter? thanks though!
07:44:01 <corgifex> Mango_Man: :set -v might work, too
07:44:30 <merijn> fizbin: Well, the alternative is "implement a proper parser for a metadata format file I have no interest in", so yeah, I figured I'd just go with "whatever is quickest to get working" :p
07:44:37 <geekosaur> Mango_Man: that error is generated at a level which doesn't know if it's compiling from a file or working from the interpreter
07:44:51 <geekosaur> so it assumes the compiling one and that you know how to do options from ghci (namely :set)
07:45:54 <Mango_Man> ah okay
07:47:18 <fizbin> Is there some type lambdabot knows about that has a constructor with 4 or more parameters? (besides tuples)
07:47:55 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
07:47:55 --- topic: set by johnw!~johnw@c-69-245-200-160.hsd1.il.comcast.net on [Mon Feb 17 18:32:10 2014]
07:47:55 --- names: list (clog tamiko ChewieBeardy dhrosa obcode Ornedan CapybaraToast malinus inarru ofan sbjorn tabo Phlogistique chipdude sgray10 iota_ ixmatus ustunozgur cfricke haskellNoob889 tensorpudding _ctc_1 qxjit_ shergill akahn_ shintahW Mango_Man ckinni MercurialAlchemi stolaruk ddellacosta nilg GLaDER favetelinguis eyebloom derdon _sebastian_ `^_^v ystael_ OscarZ yogert agjacome klao augur tfng geekosaur Yaniel fussman fran Velpoman anRch ajcoppa ndrei meoblast001)
07:47:55 --- names: list (christiaanb nbouscal mietek divyanshu goldkatze lieven_ john_not_jenny pvt_petey petrie osa1 Jesin importantshock coltfred mizu_no_oto anachrome rnons flebron raichoo1 deweyvm jbetzend tommd qzr Algebr dustinswan kfish carlo_au Apocalisp pamojarpan ktun_ dwcook pmade seantall_ Platz paper nus OlegYch zeroknowledge mgomes mrowe_away Wizek gansteed oubiwann fizbin Edoxile Jonh_nL tobani_ DarwinIsGod matheus23 chad julmae oleo lrocksmashtime bezirg b3tamax)
07:47:55 --- names: list (hamarukusa sritchie stianhj caumeslasal merijn nh2 irene_ egis eacameron ceii talzeus_ ArneL iswilson fizruk hexagoxel armyriad ts33kr_ hannese Wedamm nwf telser jackneill perspectival petermw zarul Dtgr Wuzzy mjs2600 arborist serutsubi runde eyenx Fuuzetsu` JobV araujo entheos dolio edwardk haasn liff c74d l4u Plasmastar kylcarte utj Vbitz ConstantineXVI Guest54636 joelteon jroesch peddie SegFaultAX cwvh dario| ortmage carter mikeizbicki gereedy mirsal)
07:47:55 --- names: list (Philonous vili petantik Spaceghost wjlroe BrianHV acfoltzer jrmithdobbs PHO_ wjm KaneTW Biohazard Svedrin alexherbo2 jmct TakSuyu lpaste joeyh RogueShadow zeroskillor bitraten meretrix neurocyte utkarsh ryanakca helgar pii majackson ``rawr wizonesolutions davorb ehamberg raphie arnihr Imdsm lacrosse kini qwandor heath SLi rschulman idnar Raynos Bigcheese aloiscochard werdna lopex zpconn_____ strmpnk superjudge dsirenko avdi jodaro dlackty akraut__ si14)
07:47:55 --- names: list (Scorchin fujimura xrl gauthier_ MMuse_ LnL_ dalaing flux ousado mada schlegel_ u_ Sorella asmyers artyomkazak dgpratt MindfulMonk funfunctor Eduard_Munteanu yacks igniting archblob Sebastien-L jophish mceier biscarch Rho-Mu_31 ilmig ZioCrocifisso bennofs tb01110100 HongFaeBu qxjit joneshf-laptop Nik05 hc paintcan Argue Sonderblade defanor manji011_ isomorphic JoaoPortela maattdd_ Krakarn Rryy blast_hardcheese HalfWayMan anachron tonbo ampharmex silver shesek)
07:47:55 --- names: list (fannye RayNbow`TU edunham Internet13 seschwar BoR0 levitation[A] dju mornfall janua darthdeus knyppeldynan ruzu yggr Paks apaku zcourts otto_s valdyn mantovani oinkina mangaba_leitosa sordina1 FUZxxl wagle bjorkintosh drbean aleator_ akurilin gseitz xymox pp^ integral v0|d``` daniel-s kludge` cdk Guest54139 msgodf numberten croys cross Myk267 pierreghz warpy joachifm mrshoe Swizec Boney arenz pi8027 Elision intrados` xintron Th0mas Cr8 peder koala_man zalzane)
07:47:55 --- names: list (ThomasLocke Nimatek enk0 magicman lokydor gargawel morolin BMeph jle` DT` yorick kazagistar companion_cube sajith tsou benbangert WarzoneCommand thebnq eatman Vq AtnNn DustyDingo thrakcattack maaku saiam ghorn__ solirc absence iross pieter_ Kinnison jzl blenny Tehnix djahandarie npcomp irssi_ Jei FreakyPenguin finnrobi iteratee byorgey Olive` elrancho mami studmuf banister_ zeiris alpounet yitz tinyghost honkfestival mike4- conal ft jaspervdj AshyIsMe)
07:47:55 --- names: list (predator117 nik_89 copton tero- Syneh monje socksy SpaceWizard fall_ vobi RchrdB pjdelport greymalkin Jello_Raptor uu1101 drdo kcliu sohum ixian mikeplus64 Axman6 bgyss yeshuah himikof _tca ggherdov_ hashcat Gunni Yawgmoth zalami thunderrd TheFuzzball meandi pyon yumike joshsz mgajda shennyg wchun Matrixiumn esmooov_ GGMethos gal_bolle khyperia evax hpd Thooms sa1 ompaul waterlaz deevus stephenmac7 asm89 jmob plhk_ deavid Rufflewind jefimenko stvc alcabrera)
07:47:55 --- names: list (corgifex lpsmith robj_ archaic suls sleuth stepcut brixen h_chiro deni n-dolio BeardedCoder IanKelling jaysonsantos d3f stevely__ myme rekahsoft albertid AncientPC rgrinberg AntiSpamMeta DogeHayashi quchen_ harski erkin tromp__ Lindrian ziman hamishmack anders^^ tessier copumpkin reizuki_ c_wraith ahf s_e Hafydd tanguy` jrslepak bsmt nominolo emma yeltzooo cmccann glowcoil releaf drmegahertz dixie_ aoh Adios nesqi Liskni_si zoobab cjay popx MasseR Ezku jix)
07:47:55 --- names: list (zomg shepheb Igloo ernst vhz exicer osnr dsantiago Tene tlevine luite delimax identity thoughtpolice srenatus ThatOtherPerson Lethalman cmears gniourf k00mi jack_rabbit kilian0815 gauthier xinming_ Baughn jchee rtl prinsen dcoutts bjz kinslayer_ og01 Enigmagic jackhill vendethiel sjy dqd raek dilinger Dodek pingu kryft descender Starfire sked` nabilhassein george2 Gracenotes horlicks_ xpika io2 eriksensei _5kg quicksilver mbrcknl badamson2 mariomystic Nahra)
07:47:55 --- names: list (drjfreeze tumdedum davean DarkFox fredyr levi rs0 Karethoth jagtalon_ ttuegel kiddesr b_jonas shoerain Corey tridactyla drewr annulus vijaykiran knyon schlumpi vermeille jrw dv- Rutger` sleepynate bcoppens helmut AeroNotix mikecaruso duairc Khisanth andrewsw crs_ passiveobserver stelleg Jaak kosmikus mokus Shammah alexsdut1on davd jang earldouglas skypers SwashBuckla satshabad ValicekB cschneid djapo coconnor Galactic Guest69132 Guest96956 mechairoi n4l `0660)
07:47:55 --- names: list (shachaf niko sw1nn guampa DrCode heikkih earthy ClarusCogitatio martingale Adeon tippenein killy9999 quaestor1 Raynes mgaare egads mandelbr0t grohne nokken pfoetchen nkoep yan_ certainty Martty Ke zerokarmaleft Chousuke Tril Walther arch_ _8680__ mshroyer andyo_ cognominal bartavelle timmot bens jrib chatsiri_ skarn MitchW jlewis ninegrid t7 xplat fryguybob mars-92 mrd lambdabeta seantallen taruti sclv dj_ryan mathu __main__ noteventime pyrtsa Moiman frawgie)
07:47:55 --- names: list (notdan pharaun paz jml Brando753 dmead relrod dagle betawaffle sam_d carlosgaldino tomaw cmsd2 mero Hardolaf dawik osfameron @ChanServ epsylon epta mmaruseacph2 Deewiant cryzed elgot Laney stiell brainproxy seliopou eyem natte rasmusto GaveUp cods Derander [swift] topi` honza XMunkki lispy leroux adimit iNode001 Valodim henk felipe_ tych0 Ulrar uncleBlazer pdxleif simlay saurik tomejaguar statusfailed necroyeti happy0 ted1 spion lattenwald jamwt1 ciaranm)
07:47:55 --- names: list (claudiyoh joefiorini ec heaumer_ martin ibab Lemmih pqmodn Hodapp otulp otterdam bernalex td123 iulian katis LordDeath Reiser mrb_bk audax333 jroesch_ tdammers gemelen hvr fnordbert clementd robinbb seanparsons etrepum eribeiro leifw nkpart Xorlev brackets davidthomas whispurr sipa profmakx puzza007____ lyxia mniip Rembane sunnavy Elriel Arnar_ stbuehler xaimus theDon ByronJohnson Dashkal oldmanstan kipras jlouis qrada brisbin cynick KitB Twey PatrickRobotham)
07:47:55 --- names: list (SethTisue______ Sycamore janne pnielsen bitemyapp zenzike hdevalence|away bxc adnap Thulsadum kmicu chrra Kabaka_ japesinator keko_ kalloc linduxed iXeno noddy dogmaT boegel|afk lurker6 swen shapr Iceland_jack DigitalKiwi korpse_____ Spockz Nickeeh Fubar^ drlemon_ Paprikachu spaceships Jaxan kaol jliikka burp_ farn yano CindyLinz aristid arrdem gfontenot codeburg redtricy1le klugez __class__ indigo dp_wiz kshannon dropdrive macron terlar ocharles NobbZ|ZZzz)
07:47:55 --- names: list (ekroon neptunepink demolithion Saizan yam M-ou-se rieper_ moop n0v gbarboza paulschellin felixn phryk s4msung dsfox hammi StoneToad marienz FliPPeh comboy froztbyte thorstadt bgamari Cale dabradley vital monsieurp theorbtwo mimi_vx eyck PierreM yusukesuzuki-off Sornaensis srcerer gthorslund ederign Ralith Excurio vmeson DasIch bvad sellout Tesseraction Atrumx ormaaj zq ahihi ljhms mak` \q noam ChongLi_ drbop aji Averell unkn ForNeVeR catsup bobobo1618)
07:47:55 --- names: list (sgronblo liszt pikhq gpampara smarter dmwit DexterLB BlankVerse ninzine Luke Eagle_Erwin khushildep canta gienah peterhil` thirsteh_ LeNsTR|away Eridius ArneB gaze_ `bps bhek_ d-snp_ alang srhb hegge opqdonut dmilith Cerise johnw mortberg petanqk inr shutdown_-h_now _flow_ majoh skrio albel727 joar Belgarion0 ts33kr tavelram_ kvey buzzykins edk aninhumer MrRacoon MK_FG _ikke_ dlundy vikraman favonia jabbslad_ klaut Itkovian jayne xnyhps Aune aib PJBoy pdpi)
07:47:55 --- names: list (Earnestly ccasin Blkt johnny934759 Rylee lahwran mountaingoat hive-mind nick1234abcd kcherkashin__ JPuff mandu qz Excedrin bocaneri yac ParahSailin Razz kragniz Maxdamantus Nshag brandonw ircbrowse lamilami FireFly kxra stephe__ c_14 vera tobyp__ jonathanj dreixel Reite docsis__ willb1 dgvncsz0` imalsogreg shiona gdsx taktoa zso Javafant mattp_ SHODAN organmeat jzelinskie Soft bryan1 posco_ cin ZsoL mindleyhilner edwinb hongminhee Sylarr solarus JPohlmann)
07:47:55 --- names: list (Sagi Someguy123 monochrom flori robbert cYmen jonsterling Futurian tekacs slobo hpc Peaker_ JesuZ davidfetter ibid tomprince drone| idoru kalz nicoo andares peltchu Licenser phunker fergusnoble saarin AivarasK liori acharles kerrick stevejb callumacrae danvet cyphase nikola sxn juhp amatsu thorkilnaur zymurgy ion ReinH agundry edsko klarh wto unsymbol confound keyvan nemesit|znc ivan` Clint ClaudiusMaximus twn bergmark lulf benj_ Gothmog_)
07:48:03 <merijn> RWST?
07:48:22 <fizbin> :t RWST
07:48:33 <fizbin> @type RWST
07:48:35 <merijn> :t runRWST
07:48:47 <merijn> @botsnack
07:48:50 <merijn> awww
07:48:53 <fizbin> Um...
07:49:05 * geekosaur sees no bot
07:49:12 <fizbin> openssl vulnerability took out lambdabot?
07:49:19 <quchen_> I don't think there are a lot of types like that in the standard libs (exposed).
07:49:39 <haskellNoob889> hey guys - hw question sorry :p i am trying to write a quickCheck property that checks whether an element has been removed from a binary tree. the way i thought of doing it was searching the number of times the item appears in the binary tree and making sure that it's 1 less after the deleteFunction is called. here is the property that I have written so far:
07:49:57 <haskellNoob889> ( length . filter (== integer) (makeArray (deleteFunction integer tree)) == length . filter (== integer) (makeArray tree) - 1 )
07:50:20 <haskellNoob889> i'm getting a matching error
07:51:11 <quchen_> RWST :: * -> * -> * -> (* -> *) -> * -> *
07:51:11 <quchen_> If that counts
07:51:17 <corgifex> haskellNoob889: that . looks wrong
07:52:11 <quchen_> merijn: Reader+Writer+State transformer packed into one type
07:52:18 <quchen_> Lambdabot was netsplit
07:52:23 * hackagebot tz 0.0.0.5 - Efficient time zone handling  http://hackage.haskell.org/package/tz-0.0.0.5 (MihalyBarasz)
07:52:23 * hackagebot HTF 0.11.3.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.3.0 (StefanWehr)
07:52:37 <merijn> I know what RWST is
07:53:00 <merijn> It was an answer to the qeustion "is there a type with 4 or more parameters that lambdabot knows?"
07:53:20 <merijn> Since it takes reader, writer, state, monad and result, so 5 params
07:53:55 <asmyers> haskellNoob889: Is this a Binary Search Tree or just any old binary tree?
07:54:12 <quchen_> merijn: Oh, you wrote that two lines after I said RWST already, so it looked like a question.
07:54:15 <asmyers> haskellNoob889: I'm wondering what the semantics of inserting a number are
07:54:41 <bezirg> hi, I am porting some code that used an old version of conduit and stm-conduit. Yet I have some strange errors and I don't know how to solve. The errors are something like  Couldn't match type `conduit-1.0.8:Data.Conduit.Internal.ConduitM a1 Data.Void.Void m1 ()' with `ConduitM IntType Data.Void.Void IO ()'
07:54:41 <bezirg>  
07:55:30 <haskellNoob889> asmyers: it's a binary search tree. changing the . to brackets eliminated the matching error
07:55:33 <merijn> quchen_: You never said RWST? >.>
07:55:54 <quchen_> merijn: You probably didn't see it for the same reason Lambdabot is gone, someone is having fun with Freenode again.
07:55:56 <asmyers> haskellNoob889: You shouldn't have the same number in the tree multiple times then right?
07:56:03 <quchen_> <quchen_> RWST :: * -> * -> * -> (* -> *) -> * -> * <quchen_> If that counts <merijn> RWST?
07:56:19 <merijn> quchen_: Ah, that happened 3 minutes later for me :p
07:56:49 <corgifex> bezirg: sounds like you have code compiled against the old version of conduit
07:56:54 <asmyers> haskellNoob889: Or does it allow duplicates?
07:57:09 <quchen_> :k RWST -- :-D
07:57:09 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
07:57:10 <bezirg> corgifex: how can I port it?
07:57:16 <asmyers> haskellNoob889: *do you allow duplicates?
07:57:17 <quchen_> @botsnack
07:57:17 <lambdabot> :)
07:57:50 <haskellNoob889> asmyers: not 100% sure because my lecturer generates the binary tree that's checked against my quickCheck properties. i'm just allowing for duplicates just in case
07:58:01 <asmyers> haskellNoob889: ah
08:02:52 <corgifex> bezirg: recompile the code
08:04:08 <merijn> I'm guessing the only way I can use fancy static typechecking tricks using GADTs/type families on dynamically loaded values is to resort to Typeable abuse?
08:04:29 <haskellNoob889> for a binary tree insert function, would anyone know what the purpose of the newInteger argument might be for in the quickCheck property: <code> prop_insert_does_not_change_other_elements insertFunction integer newInteger  </code> i cannot for the life of me figure out why my lecturer included it in the spec haha
08:07:39 <dwcook> haskellNoob889, you're not by any chance supposed to replace it, are you?
08:07:50 <dwcook> haskellNoob889, you might ask your lecturer for clarification
08:10:08 <vermeille> Hey guys
08:10:11 <quchen_> delete i . insert i = delete i -- haskellNoob889, that might be worth considering
08:10:36 <vermeille> I'm writing an interpreter, and I would like to implement a "print" function
08:10:56 <vermeille> What is  the best way to do this IO in my Interpreter Monad?
08:11:10 <Fuuzetsu`> DogeHayashi: 7.8 only
08:11:15 <corgifex> vermeille: how is Interpreter defined?
08:11:28 <vermeille> corgifex: State SymbolTable
08:12:08 <corgifex> you could use StateT SymbolTable IO
08:12:20 <Fuuzetsu`> Honestly, many of the features would work in 7.6 but the big problem is the interface file compatibility. Perhaps in the future when dcoutts finishes his CBOR work for binary we can have much better compatibility between versions.
08:12:52 <dwcook> If you wanted to be able to embed print but not arbitrary IO, you could use a Free monad and an interpreter that does IO
08:13:00 <vermeille> Is that the most idiomatic way to do it or just a quickfix ?
08:13:19 <vermeille> dwcook: what is a Free monad?
08:13:32 <whald> hi. is someone aware of a library providing cheap, monotonically increasing timestamps akin to Java's System.nanoTime()? I don't need nanosecond resolution, though.
08:13:38 <dwcook> @where free
08:13:38 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
08:13:42 <dwcook> Not that
08:13:44 <dwcook> @where free monad
08:13:44 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
08:13:46 <dwcook> Or maybe
08:14:00 <quchen_> https://skillsmatter.com/skillscasts/4430-monads-for-free
08:14:01 <quchen_> That one.
08:14:10 <dwcook> I found http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html helpful
08:15:04 <vermeille> dwcook: I'm reading it now, thx!
08:15:50 <yesthisisuser> Surely there must be a better way to write: if a == b then something else return ()
08:16:14 <fizruk> yesthisisuser: when (a == b) something ?
08:16:15 <quchen_> something <$ guard (a == b)
08:16:21 <quchen_> Eh, ^
08:16:25 <whald> yesthisisuser, you're looking for "unless"
08:16:36 <fizruk> :t when
08:16:37 <lambdabot> Monad m => Bool -> m () -> m ()
08:16:42 <whald> yesthisisuser, meh, I mean when :-)
08:17:00 <yesthisisuser> great.. i can't believe I haven't come across that before
08:17:00 <yesthisisuser> thanks
08:17:04 <fizruk> :t guard
08:17:05 <lambdabot> MonadPlus m => Bool -> m ()
08:17:06 <yesthisisuser> or.. probably I have :)
08:17:24 <whald> yesthisisuser, it's "hidden" in Control.Monad
08:22:36 <benzrf> hello
08:22:45 <benzrf> im using an iterateM on the list monad
08:22:49 <yesthisisuser> "when" is semantically much more transparent than return ().. at least for someone with an imperative programming background
08:23:09 <benzrf> is there a way to use monadplus to stop recursing and return when mzero is hit?
08:23:31 <benzrf> i feel like == mzero is the wrong way to ho
08:24:00 <corgifex> @hoogle iterateM
08:24:01 <lambdabot> No results found
08:24:13 <benzrf> corgifex: i got it off stackoverflow :p
08:24:14 <benzrf> 1 sec
08:24:43 <benzrf> iterateM :: MonadPlus m => (a -> m a) -> a -> m [a]
08:24:47 <benzrf> *Monad not monadplus
08:25:12 <corgifex> that doesn't really help me run it
08:25:22 <benzrf> @djinn (m a -> (a -> m b) -> m b) -> (a -> m a) -> a -> m [a]
08:25:22 <lambdabot> Error: Undefined type []
08:25:25 <benzrf> wut
08:25:30 <yac> is here anyone using haskell in business/work?
08:25:41 <benzrf> corgifex: http://bpaste.net/show/199201/
08:25:42 <yac> I wonder what linux distro you are running
08:26:13 <merijn> yac: Why are you assuming people are running linux distros? :)
08:26:31 <yac> oh well, whatever OS
08:26:40 <yac> I assume people are not running it on windows
08:26:42 <corgifex> ok, so that's broken anyway
08:26:56 <nbouscal> yac: the number of people using ubuntu is >= 2
08:27:02 <yesthisisuser> yac: I use Debian and the Haskell Platform. i think a lot of people are using it on Win however
08:27:07 <bergmark> yac: we run ubuntu in production
08:27:17 <merijn> I'm using a mix of OSX, FreeBSD, linux and solaris boxes
08:27:20 <yac> is ubuntu commercially supported?
08:27:23 * hackagebot linux-xattr 0.1.0.1 - Read, set and list extended attributes  http://hackage.haskell.org/package/linux-xattr-0.1.0.1 (NicolaSquartini)
08:27:31 <colDrMcBeardman> yac, yes, you can pay canonical for support.
08:27:40 <merijn> Everything is commercially supported if you have sufficient money :p
08:27:43 <yac> now I'm wondering if you would consider suse enterprise linux if it supported haskell
08:28:13 <colDrMcBeardman> yac, what difference does a distro make? unless you're trying to sell something...
08:28:20 <kadoban> haskell is pretty well supported on whatever OS i would think, I'm not sure I'd make an OS choice based around haskell really...
08:28:22 <yesthisisuser> I think you can pretty much use Haskell on any mainstream distro? or..?
08:28:39 <benzrf> corgifex: got anything
08:28:45 <yac> yes, but it's also about maintenance support
08:28:59 <yac> actually, I am kinda trying to sell something. But it's a side-effect
08:29:06 <bergmark> support in  what sense?
08:29:10 <bergmark> upgrading haskell packages?
08:29:25 <tobani_> centos has only ghc 7.0 or something so that can be a drag
08:29:35 <colDrMcBeardman> bergmark, I think a paid-for distro support since yac was talking about business
08:30:07 <yac> bergmark: my understanding is in enterprise it's about bug/security fixes and reliable regression testing with long term support (years, up to a decade or so)
08:30:33 <merijn> hmm, I don't suppose there's something like variable argument constructors and I will just have to use a heterogeneous list for ugliness like that?
08:30:40 <colDrMcBeardman> yac, canonical supports ubuntu LTSs for five years.
08:30:43 <benzrf> merijn: neh?
08:30:49 <benzrf> variable arg cons?
08:30:55 <merijn> benzrf: I'm thinking of ugly hackery :)
08:30:58 <yac> suse provides support up to 10 years afaik
08:31:03 <benzrf> lol grose
08:31:12 <colDrMcBeardman> merijn, variadic macros in CPP might be a good start.
08:31:22 <yac> I'd like to see ghc/haskell platform in suse but it needs to be justified by customer request
08:31:31 <merijn> benzrf: I was thinking of making a "struct" datatype to mimic C structs and make it work for arbitrary structs without needing to manually specify the translation
08:31:56 <benzrf> lol goodluck
08:32:08 <merijn> benzrf: But I'm worried having a struct represented as a heterogeneous list (i.e. one list item per struct member) may be horrific >.>
08:32:08 <colDrMcBeardman> yac, I would advise you against it. haskell is a fast-moving target and keeping distro packages up-to-date with respect to ghc, haskell platform, and hackage is damn near impossible.
08:32:12 <Platz> some less popular libraries might depend on terminal stuff that needs a posix environment
08:32:18 <benzrf> 'may be'
08:32:25 <benzrf> merijn: just use codegen :y
08:32:40 <merijn> benzrf: Well, I meant horrific in the sense of slow
08:32:41 <Platz> even Hakyll had a lot of unixpipe stuff that didn't work well onw windows for a while, might be fixed now but not sure if it does true piping
08:32:48 <merijn> benzrf: I need this for code gen
08:32:52 <colDrMcBeardman> I'm not the only person here that's nuked the entire [apt,rpm,etc] install of haskell and redone it from source.
08:33:05 <merijn> benzrf: i.e. I want to generate structs for C code and use them in a typesafe way in haskell
08:33:10 <yac> colDrMcBeardman: yeah possibly. I see this in gentoo where everything is an equals dependency but I don't know if it comes from upstream or it's our packaging weirdness
08:33:13 <colDrMcBeardman> the only people that seem to have luck with it are arch and gentoo users.
08:33:55 <colDrMcBeardman> yac, the thing is cabal isn't a package mangler. so you might be able to get ghc and haskell platform as packages, but you can't try to mirror hackage in apt or what have you.
08:34:12 <benzrf> 'package mangler'
08:34:13 <benzrf> lol
08:34:23 <colDrMcBeardman> gentoo can handle it because portage is closer to cabal in that it builds from src.
08:34:38 <merijn> benzrf: So have a strongly typed representation of "struct { int i; float bar; void *foo }" as "Struct [CInt, CFloat, Ptr Void]" in haskell
08:35:00 <yac> colDrMcBeardman: thing is, my understanding is that dependencies in haskell packages can be expressed only as "need exactly this version". Not as "need  X or higher" as normal in other languages
08:35:09 <colDrMcBeardman> yac, not true.
08:35:22 <colDrMcBeardman> you can have a dep like base >= 4 && <=5
08:35:47 <yac> but I don't know if it is just our weirdness or just most packages do this or haskell packages just change so much that it "X or higher" is not happening often
08:36:02 <merijn> benzrf: But that would be nicer if I could have GHC pack those things tightly, unfortunately that means the number of args taken by a "Struct" constructor has to depend on its type, which I don't think is possible
08:36:03 <yac> colDrMcBeardman: that's right, but I don't see this in practice much
08:36:13 <colDrMcBeardman> yac, that's what cabal does when you cabal init, and it's a good thing the way the ecosystem is, i think.
08:36:15 <yac> maybe I just need to do more research
08:36:25 <shapr> I need to do more research too!
08:36:30 <shapr> Howdy Ryan, ltns
08:36:34 <colDrMcBeardman> yac, honestly, just get ghc and haskell platform in the repos.
08:36:36 <merijn> I don't suppose we have a #haskell-ridiculous-hackery channel? :>
08:36:48 <shapr> merijn: tried #keal?
08:36:55 <colDrMcBeardman> don't try to start mirroring "blessed" or "hand-picked" hackage packages because you will just screw people.
08:36:55 <yac> I like my packages managed by my distributions package manager
08:36:57 <shapr> oh wait, that's a different sort of ridiculous.
08:37:07 <Platz> yac: my understanding that the upper bounds on deps were to prevent bugs with packages that make backwards-incompatible changes.  kind of a loose-loose situation
08:37:20 <colDrMcBeardman> yac, you're destined to fail if you try to put cabal into something like apt.
08:37:23 <yac> my experience is that every language level PM sucks horribly
08:37:40 <shapr> yac: It was worse before Cabal, I promise.
08:37:41 <yac> colDrMcBeardman: why? Is it different from ebuilds?
08:38:05 <colDrMcBeardman> yac, a good ebuild could shell out to cabal. apt can't.
08:38:14 <yac> it probably does
08:38:35 <colDrMcBeardman> that means YOU have to go through all of hackage, and find compatible versions of everything, or a subset thereof, like debian does, and then repackage it all.
08:38:37 <merijn> yac: Yeah, people whine loudly about cabal, but in my personal experience cabal is lightyears ahead of the tools in any other language
08:38:43 <yac> and I would be surprised if debpkgbuild or what it is called wasn't using cabal during build too
08:38:56 <shapr> yac: Got any specific improvements you think would help cabal?
08:39:01 <yac> oh right. So that's not the case with ebuilds
08:39:24 <colDrMcBeardman> yac, right, the ebuilds are more dynamic at the user end.
08:39:27 <merijn> "hur-dur, I never have dependency issues in node.js" <- right, because the node.js solution to dependencies is "wholesale copy your dependencies into your tree" >.>
08:39:42 <colDrMcBeardman> merijn, kind of sounds like sandboxes.
08:39:48 <yac> but as far as I noticed, when I do upgrades, it usualy bumps many haskell packages at the same time. OTOH I'm doing updates once a month or two
08:39:50 <bergmark> there was some article about upgrading rails applications recently
08:39:59 <merijn> colDrMcBeardman: Right, except without the ability to easily update when upstream changes!
08:40:07 <colDrMcBeardman> merijn, i feel sick.
08:40:10 <merijn> colDrMcBeardman: Oh, and it messes up your repo history
08:40:18 <colDrMcBeardman> merijn, now i am sick.
08:40:18 <bergmark> in short: it's too hard to bother with :-)
08:40:33 <yac> shapr: I don't have much experience with cabal TBH, but I do with python, ruby and I saw the abomination that is npm
08:40:34 <colDrMcBeardman> yac upgrades in what? cabal?
08:40:40 <yac> in gentoo
08:40:46 <yac> system wide updates
08:40:49 <Platz> merijn: probably not a good idea to have vendor modules in git
08:41:07 <colDrMcBeardman> oh. yeah, try setting ubongo up in a vm or something and install a bunch of things from apt.
08:41:09 <Platz> but everyone does it anyway
08:41:13 <colDrMcBeardman> then try and use cabal to install things not in apt.
08:41:17 <colDrMcBeardman> hilarity will ensue.
08:41:36 <shapr> colDrMcBeardman: How do you think it could be improved?
08:41:46 <colDrMcBeardman> telling people "just use cabal"
08:42:16 <colDrMcBeardman> I don't think it's a good idea for the distro people to strain themselves maintaining a mirror of something they don't really have to.
08:42:25 * hackagebot http-test 0.1.4 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.1.4 (glutamate)
08:42:42 <colDrMcBeardman> current ghc and haskell platform in apt? good idea. hackage subset? bad idea.
08:43:09 <vermeille> dwcook: I don't see how a Free monad can solve my IO issue
08:43:25 <dwcook> colDrMcBeardman, would you suggest not putting things like xmonad in the distro repo?
08:44:08 <colDrMcBeardman> dwcook, ehhh. hard to say. probably the safest answer would be 'no' but, then again, that's a binary, not just a library, so they could put that in apt.
08:44:09 <yac> well, I like to install stable packages when I am not absolutely sure I need a testing one
08:44:14 <colDrMcBeardman> but they might have to statically link it.
08:44:17 <bergmark> distros should just use stackage, there the actual maintainers are responsible for fixing issues
08:44:19 <dwcook> vermeille, the idea would be that instead of embedding the actual IO procedure in your interpreter, you create a type of programs that your interpreter can interpret and a function that takes one of those programs onto an IO procedure
08:44:24 <colDrMcBeardman> which, i think dynamic linking is dumb, anyway, so.
08:44:39 <yac> tested working condition and integration with the distro ...
08:44:41 <colDrMcBeardman> yac, you can install 'stable' things with cabal
08:44:51 <dwcook> vermeille, one of the "steps" available in those programs might be Print String next :: Program result next
08:44:55 <colDrMcBeardman> --constraint=package==x.y.z
08:44:57 <yac> colDrMcBeardman: stable upstream maybe, not in distro
08:45:00 <vermeille> dwcook: wow, Doesn't that sounds pretty complex for something that should be simple?
08:45:13 <dwcook> vermeille, how is it complex?
08:45:34 <vermeille> Because I'm not familiar with it :D
08:45:37 <colDrMcBeardman> yac, again, i think it's a bad idea to ask that distro maintainers try to do that job for every single language out there.
08:46:15 <vermeille> dwcook: Well, because It's quite far away from a typical AST
08:46:16 <colDrMcBeardman> a saner policy would be to have them package binaries, interpreters, "standard libraries" like platform, and let the end user sort things out sanely.
08:46:30 <yac> colDrMcBeardman: why is dynamic linking dumb? I belive it was introduced to save disk space, however I think it's nice to be able to update libraries separately from the consumers. A security fix is released and suddendly you need to rebuild half of the system
08:46:34 <colDrMcBeardman> in the end, the user of a programming language environment will want to customize it for their deployment.
08:46:36 <dwcook> vermeille, it might seem hard at first but it gives you a good amount of power, like the ability to inspect the ASTs of your programs (which you wouldn't be able to do as easily with the transformer option since IO procedures can't be shown)
08:46:38 <geekosaur> the problem there is you package something like irssi
08:46:51 <dwcook> vermeille, Free monads basically *are* ASTs
08:46:54 <colDrMcBeardman> yac, it causes security holes, versioning problems, loading-time increases and doesn't save space.
08:47:00 <geekosaur> where people would like *its* batteries included.. which includes a bunch of perl, some of which has deps
08:47:02 <dwcook> With the advantage that you can use do notation with them
08:47:03 <colDrMcBeardman> ahem... memory space, i mean.
08:47:07 <geekosaur> there's no good solution
08:47:07 <colDrMcBeardman> no one cares about disk space.
08:47:23 <vermeille> dwcook: okay, I'll read more, I didn't get that point
08:47:30 <colDrMcBeardman> in a sane OS with COW, a lot of that library stuff will not be duplicated overmuch in memory.
08:47:51 <colDrMcBeardman> I've had so many annoyances that were caused by dynamic linking i don't even want to think about it.
08:47:59 <yac> colDrMcBeardman: not anymore. But back in the day, I believe disk space is the reason we have dynamic linking in the first place
08:48:03 <dwcook> vermeille, the first section touches on that part :)
08:48:03 <colDrMcBeardman> yes.
08:48:16 <colDrMcBeardman> and now we're stuck with it because everyone thinks it's a Good Idea (tm)
08:48:30 <yac> colDrMcBeardman: I understand there's more upfront maintenance wrt versioning but security issues caused by dynlinking?
08:48:41 <colDrMcBeardman> yac, yep.
08:48:53 <dwcook> Or the inspection part anyhow
08:48:56 <vermeille> dwcook: well, on the first section I see a linked list, not a tree
08:49:02 <colDrMcBeardman> infect one libc and you can infect bazillions of other programs once they're run.
08:49:06 <colDrMcBeardman> if you're smart enough.
08:49:09 <yac> well, golang is linked statically. And if you are on gentoo you can enabled static-linking
08:49:14 <colDrMcBeardman> yep.
08:49:22 <yac> colDrMcBeardman: please expand
08:49:24 <colDrMcBeardman> although, go, wow... Snoooooore.
08:49:27 <yac> on the security issues
08:49:30 <Fuuzetsu`> there's not enough hype here about 7.8.1
08:49:51 <dwcook> vermeille, well the first example is kind of trivial, yeah. There are better examples later in the post.
08:49:52 <colDrMcBeardman> i think we're veering off-topic, i'll pm you.
08:50:52 <dwcook> vermeille, the section entitled "Interpreters - Revisited" shows a more useful program type
08:51:50 <vermeille> dwcook: okay, I keep reading so!
08:52:27 <hunt> lambdaless expression that takes a -> b and creates [a,b]?
08:52:47 <c_wraith> hunt: that doesn't even make sense.
08:52:59 <fizruk> dwcook: just in case, are you aware of usages for free applicatives (except option parser mentioned in the paper)?
08:53:16 <dwcook> fizruk, no, are you looking for information on that?
08:53:18 <hunt> c_wraith: why not? i want some weird combinations of (:) and whatever else to take a -> a and make [a,a]
08:53:45 <c_wraith> hunt: you're mixing types and values
08:53:46 <fizruk> dwcook: not exactly, just interested :)
08:54:10 <c_wraith> hunt: (a -> a) is a type.  [a, a] is a value.
08:54:33 <dwcook> fizruk, have you taken a look at Control.Applicative.Free from the free package?
08:54:54 <c_wraith> hunt: what's the type of what you're thinking of?
08:56:07 <hunt> c_wraith sorry i didnt write it in formal haskell notation, the type is a -> a -> [a] and it takes f a b = [a,b], but id like a composition function instead of declared
08:56:15 <fizruk> dwcook: sure, there are no hints on usage yet
08:56:45 <dwcook> fizruk, check out the paper linked from there
08:56:51 <dwcook> Errr, from the docs
08:56:55 <c_wraith> hunt: ah.  That's possible, but not pretty.
08:57:00 <dwcook> http://paolocapriotti.com/assets/applicative.pdf
08:57:07 <fizruk> dwcook: I think I've seen something on statically checking permissions for a sequence of commands, using free applicatives
08:57:17 <c_wraith> @pl f a b = a:b:[]
08:57:17 <lambdabot> f = (. return) . (:)
08:57:43 <hunt> what does @pl do
08:57:54 <c_wraith> It does exactly what you asked about.
08:57:57 <fizruk> dwcook: yeah, I read the paper, and their main example is option parser
08:58:03 <dwcook> Makes everything pointless
08:58:06 <c_wraith> Converts a function to pointless (point-free) form
08:58:48 <hunt> what monad is operating here? list?
08:58:49 <fizruk> dwcook: they also mention limited IO
08:58:53 <c_wraith> hunt: yes
08:58:55 <dwcook> Yep
08:59:04 <c_wraith> hunt: it's converting something to a single-element list
08:59:08 <hunt> yea
08:59:15 <hunt> any  ideas on how we could kill that return
08:59:24 <hunt> and get some more (:)
08:59:27 <dwcook> return = (: [])
08:59:29 <c_wraith> sure, replace it with (:[])
08:59:49 <dwcook> The duck combinator
08:59:57 <c_wraith> I thought it was the robot monkey
09:00:03 <dwcook> Or that
09:00:04 <mwhitfield> So can I ask why the Haskell community seems to find so much interest in making funcions point-free at all costs? I think I've figured out every initially bizarre convention Haskell has except that one.
09:00:07 <dwcook> What would be duck then?
09:00:22 <dwcook> mwhitfield, for fun
09:00:36 <dwcook> Also sometimes a misguided sense of optimization
09:00:49 <fizruk> dwcook: I was looking for something to view free applicatives from a different perspective. anyway thanks!
09:00:55 <Phlogistique> what's the reverse of @pl?
09:00:56 <Saizan> mwhitfield: @pl is not meant to be a model of good code
09:00:56 <hunt> mwhitfield: its kind of in line with the functional style
09:00:59 <c_wraith> mwhitfield: in general, real code (not golf) has just enough points to reduce things to chains of composition.  No more.
09:01:07 <dwcook> @unpl (. return) . (:)
09:01:07 <Saizan> Phlogistique: @unpl
09:01:07 <lambdabot> (\ d g -> ((:)) d (return g))
09:01:12 <dwcook> Ick
09:01:31 <hunt> unpl is blaeh
09:01:39 <Phlogistique> Saizan: thanks
09:01:43 <hunt> how does @pl work?
09:01:59 <c_wraith> mwhitfield: that is...  f a b = g $ h a b  will get reduced to f a = g . h a, but not further
09:02:03 <mwhitfield> c_wraith (et al): Ok, I guess that makes more sense. That's basically how I try to write. I thought it was seen more as "best practices" and less as a code-golf type thing
09:02:21 * dwcook has used (g .) . h before :P
09:02:34 <c_wraith> bad dwcook!
09:02:35 <hunt> ive been using that too much lately
09:02:44 * hunt hates points
09:02:54 * dwcook goes to the pointless corner
09:03:14 <Phlogistique> dwcook: why didn't you define (.).(.)?
09:03:15 <hunt> @pl dwcook
09:03:15 <lambdabot> dwcook
09:03:18 <hexagoxel> is there a flag for the commandline pointfree application for "unpl"?
09:03:27 <dwcook> Phlogistique, didn't occur to me
09:03:30 <hunt> :t (.).(.)
09:03:32 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:03:34 <Saizan> hunt: some mess of rewriting rules, the core is based on the translation from lambda calculus to SKI combinators, i believe
09:03:58 <hexagoxel> or which application does handle @unpl?
09:04:16 <Phlogistique> dwcook: well, let (.:) = (.).(.) in g .: h
09:04:34 <Fuuzetsu`> a.k.a. tits operataor
09:04:36 <Fuuzetsu`> operator*
09:04:38 <dwcook> @pl (.) . (.)
09:04:39 <lambdabot> (.) . (.)
09:05:05 <dwcook> (That was already point-free but I wondered if it knew about something else like that)
09:05:23 <n-dolio> dwcook: You should use 'fmap g . h'. Much clearer.
09:05:32 <dwcook> I feel like I've seen (.) . (.) somewhere else, in another form
09:05:33 <Fuuzetsu`> no it isn't
09:05:40 <dwcook> n-dolio, are you kidding?
09:05:54 <n-dolio> Am I?
09:05:58 <Fuuzetsu`> you arae
09:06:19 <n-dolio> We actually did do that in some code here.
09:06:29 <hexagoxel> ah, @pl is pointless and @unpl is pointful
09:06:31 <c_wraith> dwcook: it's often named .:
09:06:32 <dwcook> I don't know, my initial impression is "n-dolio is making a joke", but it can be hard to tell without intonation :P
09:06:35 <n-dolio> Then came back two days later and spent like 5 minutes trying to figure out what it was doing.
09:06:41 <mwhitfield> @pl f = fmap g . h
09:06:42 <lambdabot> f = fmap g . h
09:06:43 <hexagoxel> s/pointless/pointfree/
09:06:47 <mwhitfield> oh ha
09:06:51 <mwhitfield> duh
09:06:58 <dwcook> Is the S combinator defined somewhere standard in Haskell?
09:07:13 <c_wraith> :t (<*>)
09:07:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:07:18 <c_wraith> there you go.
09:07:26 <dwcook> Yay
09:07:41 <c_wraith> just read f as (c ->)
09:08:23 <c_wraith> > (zip <*> tail) [1..]
09:08:24 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
09:15:47 <Jonh_nL> can some help me with a problem. I have this tree http://lpaste.net/102430 . I  a function to check if left and right is balanced
09:16:03 <Jonh_nL> the value of left and right must be the to get True
09:16:05 <joneshf-laptop> :t (<*>) `asAppliedTo` (undefined :: c -> d)
09:16:06 <lambdabot> (c -> a -> b) -> (c -> a) -> c -> b
09:16:08 <Jonh_nL> otherwise false
09:16:14 <joneshf-laptop> c_wraith, ^
09:22:30 * hackagebot web-routes-wai 0.23.2 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.23.2 (JeremyShaw)
09:25:11 <vermeille> ~
09:25:24 <pordan30> John_nL: you have a function to check whether the tree is balanced, or you need help writing such a function?
09:31:59 <john_not_jenny> Let's say I have a list [0,0,0,0] and I want to generate a list of lists that replace each occurence of '0' with a '1' (but only one per sublist). So a function that goes from [0,0,0,0] -> [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]].  I've thought about this for 20 minutes and I'm stumped.
09:34:58 <New2Haskell> Hello guys, I am looking for some mental support with my assignment. I was given a Binary Tree in the form of a recursive dataset. The assignment is to write a function to check if this whenever this Tree is balanced. I have already concluded that the three is balanced when the first and last half of the set are the same length. However I dont know how to check this or if is this the best way. Can any1 steer me in the right dire
09:35:26 <New2Haskell> http://lpaste.net/102432
09:39:53 <shyGuy> hello
09:40:26 <New2Haskell> hi
09:40:32 <shyGuy> how are you?
09:40:43 <New2Haskell> great what about you
09:40:47 <pordan30> New2Haskell: a binary tree is balanced whenever, for each node n, |depth(left n) - depth(right n)| <= delta (for some delta). can you think of a way to calculate the depth of a tree, and then recursively test for this condition?
09:40:48 <shyGuy> i see you are new to haskell... as am I ... I am good
09:41:01 <shyGuy> about to leave for school but always wanted to come see this place
09:41:39 <New2Haskell> ok that sounds logical @pordan
09:42:00 <shyGuy> are you guys talkking about AVL trees or self balancing trees in generalÉ
09:42:59 <cschneid> What's the human name for the monoid <> operator?  And is it different on semigroup?
09:43:02 <cschneid> how would I pronounce it
09:43:32 <Clint> cschneid: mappend, maybe?
09:44:09 <cschneid> (I'm implementing a semigroup in ruby, and I can't use arbitrary symbols :)  ) -- also I love that haskell has made me see these common patterns.
09:45:44 <shyGuy> join #reddit-depression
09:48:27 <cschneid> Clint: mappend - the m is for monoid - do you know if there's a more generic name for both monoid and semigroup <> operator? "merge" or "combine" or "smush"
09:49:07 <Clint> cschneid: i'd ask edwardk
09:50:40 <cschneid> reading wikipedia: "By definition, a semigroup is an associative magma" - I don't know what a magma is, but it sounds cool
09:50:54 <cschneid> those math guys come up with some cool names
09:51:07 <ocharles> A magma isn't much of anything
09:51:09 <ystael> cschneid: a magma is a not necessarily associative semigroup :)
09:51:10 <ReinH> cschneid: heh, a magma is a set equipped with a binary operation
09:51:21 <cschneid> lol, everybody starts badmouthing magmas.
09:51:23 <ReinH> which is about the simplest structure on sets one could imagine
09:51:25 <cschneid> I was just saying it's a cool name :)
09:51:27 <ystael> i think we can thank Bourbaki for that word
09:52:25 <mwhitfield> cschneid: as far as I can tell the only general name for it is "the binary operation of a semigroup"
09:52:33 <mwhitfield> cschneid: a little verbose for a function name, perhaps
09:52:35 <ReinH> You can use "times" if it's clear from context.
09:52:45 <cschneid> mwhitfield: well that's a bit big.  Honestly I think I'll just overload + on this class.
09:52:49 <ocharles> ReinH: But... but... additive groups!
09:53:01 <ReinH> ocharles: please note my caveat :p
09:53:02 <cschneid> so it works well with .sum and friends in ruby. Close... enough... :)
09:53:09 <ocharles> an operation is by definition binary btw
09:53:15 <ocharles> at least by my text books
09:53:29 <ReinH> ocharles: and yet they keep saying "binary operation" everywhere you look :p
09:54:02 <ReinH> vsayer: in Ruby it's + pretty much everywhere.
09:54:06 <ReinH> er cschneid ^
09:54:09 <ReinH> no idea how that happened
09:55:13 <cschneid> ReinH: yeah, I'll go with that.  I think I scare my coworkers when I say that I'm implementing a semigroup definition... :)
09:55:26 <ReinH> cschneid: I gave a talk about monoids in Ruby at rubyonales :)
09:55:34 <cschneid> video anywhere?
09:55:37 <mwhitfield> cschneid: why not just go with like "sgappend", it's about as real a term as mappend
09:55:39 <ReinH> not sure if it's up yet
09:55:54 <ocharles> I like ed kmetts term
09:55:55 <ocharles> "smash"
09:55:58 <bitemyapp> ReinH: how'd they react to the subject?
09:55:59 <cschneid> mwhitfield: well, for practicality, absent a really good name I'll use `+`
09:56:00 <mwhitfield> well maybe not "append" but something else
09:56:07 <bitemyapp> ocharles: semigroup SMAAAASH
09:56:09 <cschneid> maybe aliased as SMASH
09:56:15 <bitemyapp> yisssss
09:56:15 <mwhitfield> oh i do like smash
09:56:37 <bitemyapp> you can pretend smash stands for semigroup-mash for plausible deniability.
09:56:53 <cschneid> nope. Not gonna pretend.
09:56:59 <ReinH> cschneid: doesn't look like it
09:57:01 <bitemyapp> good :)
09:57:09 <ystael> smash is a specific operation though :)
09:57:10 <ReinH> bitemyapp: surprisingly well
09:57:14 <cschneid> def smash(other);.. alias_method :+, :smash
09:57:16 <cschneid> done.
09:57:29 <ystael> people will wonder where the rest of homotopy theory is
09:59:11 <Algebr> Can I tell ghc to make an exectuable for a different platform than I"m currently on?
10:02:53 <pmade> Algebr: https://ghc.haskell.org/trac/ghc/wiki/CrossCompilation
10:14:26 <khs> Hi,
10:14:42 <khs> has anyone tried implementing an octree in haskell?
10:17:55 <hexagoxel> http://hackage.haskell.org/package/Octree
10:18:03 <hexagoxel> feel free to use hoogle yourself next time :D
10:19:43 <cschneid> damn, this may not be a semigroup.  I have a list of things [a,b,c,d,e,f] and a function that can sometimes reduce them. so output would be another list [(a+b+f), d, (e+b)].  so, 3 items in this made up example.  Is there a structure which does this?  Note that combination doesn't need to be in order.
10:21:57 <cschneid> a Set, keyed on the combination criteria, then join the values of the set w/ the semigroup between two conforming items? (so if I can combine of an element's "name" field or something, build set on that, then "score" can be a monoid as the value of the set.)
10:22:02 <malvarez> cschneid: does it behave well wrt. list concatenation? i.e. reduce (l1 ++ l2) == reduce ((reduce l1) ++ (reduce l2))
10:22:11 <cschneid> malvarez: yes
10:22:38 <malvarez> cschneid: then I believe your List t may be a quotient over the free monoid that is List t
10:23:50 <cschneid>  [a, b, c] => [(a<>c), b] for instance. I'm not sure what you just said. :) Just looking for the algebraic structure for this - I think my set approach will work out ok
10:24:32 <cschneid> because really my input isn't a list, it is a set. {a,b,c}. there's no inherent order.
10:25:35 <fcsa> Hello, #haskell. I would like to present a free as in freedom Skype replacement: Tox. Tox is a P2P, totally distributed, trustless network. The core is written in ANSI C and there are many clients/frontends for it.
10:25:36 <fcsa> I would like to invite you to make a Haskell wrapper and Client for it, as there is no good Multi-platform (Windows, Linux, OS X, BSD, etc.) for it.
10:26:00 <bitemyapp> IRC is like the agora sometimes.
10:26:13 <bitemyapp> fcsa: is it written in Hsakell?
10:26:21 <fcsa> Website: http://tox.im/ Github: https://github.com/irungentoo/ProjectTox-Core Development Introduction: http://api.libtoxcore.so/
10:26:33 <malvarez> cschneid: so then you've got a set of items, {a, b, c} and some of those items can be combined, right?
10:26:47 <fcsa> bitemyapp: The core is written in ANSI C. The many clients are written in other languages, such as Vala, Racket, Java and Objective-C
10:27:17 <f-a> meh, I got disconnected. Did you receive my message, #haskell?
10:27:32 <fcsa> http://wiki.tox.im/Clients
10:28:04 <Haxander> Hello everyone, Haskell newbie here... Is it possible to use cabel install and keep the package sources extracted on the file system for reference and learning purposes? Or should i extract the sources manually myself?
10:28:08 <cschneid> malvarez: yes, and the final set is one or more final combined items. So for any input, the combined arity is less than input arity. But likely not 1, which is what a semigroup/monoid would imply
10:28:17 <cschneid> since there are some combos that don't have a valid <>
10:28:31 <bennofs> Haxander: use cabal get or cabal unpack, depending on your cabal version
10:28:42 <bennofs> Haxander: for example, cabal get lens will get the source code of the lens package
10:28:57 <malvarez> cschneid: let's call the type of your set elements T, ok?
10:28:59 <Haxander> bennofs: ah super, that was what i was looking for!
10:29:13 <cschneid> of so we have Set T
10:29:15 <cschneid> ok
10:29:28 <malvarez> cschneid: so, while T is not an algebraic structure (technically, it would be a semigroupoid, but that's...awkward to represent)
10:29:58 <malvarez> In fact (Set T) is a monoid
10:30:01 <Haxander> bennofs: Thanks :)
10:30:24 <malvarez> Of course, Set t is a monoid for any t, but (Set T) can be made a monoid in a different way
10:30:32 <cschneid> malvarez: ok. So I can do   setT <> setT2, {a,b,c} <> {d,e,f} => makes sense
10:30:53 <cschneid> you're suggesting that the definition of <> for this type can be smarter then?
10:31:08 <cschneid> so setT <> setT => combinedVersionOfSetT
10:31:09 <malvarez> cschneid: The thing is, you could define mappend s1 s2 = reduce (s1 <> s2)
10:31:36 <malvarez> Exactly. Then your new <> is still associative and also has an identity element (the empty set), so it's a monoid
10:32:00 <cschneid> and it works as well because  reduce(a a) is just a. So no biggie trying to reduce against itself.
10:32:28 <chagall> (set
10:32:48 <malvarez> cschneid: unfortunately you can't make Set T an instance of Monoid because Set t already is, so you'll need to wrap it in a newtype
10:33:26 <cschneid> malvarez: well, I'm using haskell ideas in ruby. so it's a bit more than that :)
10:33:40 <cschneid> but of course the newtype works in haskell land :)
10:33:41 <cschneid> thanks
10:34:14 <malvarez> cschneid: i'm into ruby as well, perhaps I can help with the translation?
10:34:30 <cschneid> no worries, I've got it.
10:34:34 <cschneid> maybe I'll write it up when done :)
10:34:51 <malvarez> I'd love to read it
10:44:30 <Algebr> Regarding Monads, anytime I want to pass around State, I use a Monad right?
10:45:46 <johnw> Algebr: pretty much
10:46:12 <cschneid> Algebr: well, you can manually just pass around a data structure, and return the modified (updated state) version of it
10:46:17 <cschneid> but the state monad does that wiring for you
10:46:25 <johnw> Algebr: the ability to carry along a "mutating context" with explicitly sequential mutations is sort of what monads excel at
10:46:43 <shachaf> Every time you call a function you are "passing around state".
10:46:52 <johnw> if you never modify that context, you have a Reader; if you never read it and only modify it, you have a Writer, for example
10:47:10 <johnw> well, roughly speaking
10:47:21 <johnw> in general, shachaf and cschneid are correct
10:47:34 <Algebr> So How could I do something like a global variable?
10:47:39 <johnw> monads are just a way of abstracting a common pattern, it's not the only way that pattern must be expressed
10:48:05 <johnw> you can do a global variable with a gross hack, but generally you should avoid it
10:48:08 <cschneid> Algebr: a state monad can have a scoped, mutating variable across many function calls, and is likely what you're looking for
10:48:17 <cschneid> s/mutating/updating/
10:48:24 <Algebr> a global variable that could be changed, like say I have a debug =False flag in my app, and I want to be able to change it to True from wherever in my ap
10:48:25 <Algebr> app
10:49:03 <johnw> Algebr: if you really, really need to, you can see how I do such a thing here: https://github.com/jwiegley/logging/blob/master/Control/Logging.hs
10:49:10 <johnw> see logLevel, and setLogLevel
10:49:16 <mwhitfield> Algebr: you're drastically underestimating how much you need to unlearn to write haskell i think
10:49:21 * shapr hugs johnw randomly
10:49:27 * johnw hugs shapr back!!
10:49:36 <johnw> shapr: we missed you at NYC Hac
10:49:45 <pavonia> Algebr: There's also IORef
10:49:48 <shapr> johnw: Couldn't make it, sorry
10:49:58 <shapr> Probably won't be at bangbangcon either.
10:50:27 <Algebr> NYC hac was fun.
10:50:29 <johnw> gitlib made some very nice progress at Hac NYC
10:50:35 <johnw> Algebr: you were there??
10:50:37 <Algebr> yes.
10:50:43 <johnw> Algebr: what is your RL name?
10:50:46 <Algebr> Edgar
10:50:48 <cschneid> Algebr: you don't want global variables - you want a data structure like `AppState = AppState { debug :: Bool }`, a function to make default one `defaultState = AppState false` and a `runState defaultState $ do ....`
10:50:53 <johnw> I'm sorry I didn't get a chance to meet you!
10:50:54 <shapr> I haven't been to a Haskell hackathon in so long :-(
10:51:02 <Algebr> Bummer, do you go to the meetups?
10:51:03 <johnw> shapr: BayHac has a very nice speaker lineup
10:51:09 <cschneid> Algebr: then in your code you can use the state monad options to update the app state if needed.
10:51:21 <Algebr> cschneid: ah, thank you.
10:51:45 <johnw> Algebr: usually in my applications I find myself creating an "App" monad, which is usually ReaderT e IO, or StateT e IO, so that I can do just what you're asking about
10:52:10 <cschneid> Algebr: what johnw just suggested is the "real" answer that combines my answer with how to get back to doing IO at the same time
10:52:37 <cschneid> play with the bare state monad a bit in a few small scripts to get a feel for it. StateT just wraps another monad (IO in his example), so you can use both.
10:52:43 * hackagebot monad-logger 0.3.5.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.5.1 (MichaelSnoyman)
10:52:45 * hackagebot ghc-prim 0.3.1.0 - GHC primitives  http://hackage.haskell.org/package/ghc-prim-0.3.1.0 (HerbertValerioRiedel)
10:52:49 <cschneid> `e` in his type signature would be the `AppState` record I described
10:55:37 <boogie> Hello. Do you guys know of a way to fix the compilation of ghci-ng-7.6.3.4 with ghc 7.6.3, and cabal-install-1.18.0.2?
10:56:42 <hvr> boogie: plz file an issue at https://github.com/hvr/ghci-ng/issues
10:57:31 * hvr can't look at it right now, but I may lateron
10:57:44 * hackagebot network-simple 0.3.1 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.3.1 (RenzoCarbonara)
10:57:46 * hackagebot integer-gmp 0.5.1.0 - Integer library based on GMP  http://hackage.haskell.org/package/integer-gmp-0.5.1.0 (HerbertValerioRiedel)
10:58:34 <boogie> hvr: Sure thing.
11:02:48 * hackagebot base 4.7.0.0 - Basic libraries  http://hackage.haskell.org/package/base-4.7.0.0 (HerbertValerioRiedel)
11:03:16 <cschneid> 4.7 base? Is something getting locked down for next release of something?
11:03:23 <johnw> 7.8.1 tarball is actually done
11:03:27 <johnw> it's just waiting on binary builds now
11:03:31 <cschneid> fun!
11:03:56 <cschneid> so I can rebuild ghc from source now by pointing at that tarball? It's final?
11:04:02 <johnw> looks like it
11:04:10 <johnw> http://www.haskell.org/ghc/dist/7.8.1/
11:04:22 <boogie> hvr: You got it: https://github.com/hvr/ghci-ng/issues/1
11:04:34 <cschneid> fun. need to go update my nitrous.io build to it.
11:05:17 <cschneid> anybody have suggestions for running ghc under low memory conditions? at 384 megs ram, it fails to compile common dependencies. Is there a way to say "take your time, it's ok to swap"?
11:10:07 <Zetatron> Hey, I need a bijective mapping between keys and values (Int <-> String in my case). Is there a library that implements this?
11:10:30 <johnw> http://hackage.haskell.org/package/bimap-0.2.4/docs/Data-Bimap.html?
11:11:59 <Zetatron> johnw: That looks promising, thanks!
11:12:46 * hackagebot tpdb 0.8.4 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-0.8.4 (JohannesWaldmann)
11:13:30 <Hafydd> There's no bijective mapping between Int and String, because their cardinalities differ.
11:14:32 <johnw> ah, I had read it as Integer and String
11:16:48 <ReinH> (A bijection between subsets)
11:16:49 <Zetatron> Well, of course you are right but I guess in real world applications this issue is negligible :)
11:18:29 <Sculptor> hi!
11:18:50 <Hafydd> I wouldn't be so sure, but if Data.Bimap is what you wanted, I suppose it's an unrelated issue.
11:19:53 <ReinH> what matters is whether the in-use subsets biject :)
11:20:34 <srhb> "For a suficciently small amount of Strings (...)" -- #haskellproblems
11:23:07 <Zetatron> The english language has around 600000 words so in my case I will be completely fine with Int :-). Thanks again!
11:24:13 <Sculptor> 600000, 1000 of which is used by the common folk
11:25:35 <haasn> Zetatron: what do you need the bijectivity for?
11:27:04 <Algebr> Hmm, does hoogle need some extra arguments for it to search through installed packages?
11:28:30 <johnw> Algebr: I find that I need to cabal install with --haddock-hoogle, and then copy the .txt files into my hoogle databases directory before running "hoogle data -l"
11:33:09 <Zetatron> haasn: It's just that the data I am using is inherently bijective so I thought it would be a good idea to model this directly in the code
11:34:31 <AntiCorrupcion> why am I getting this compile error
11:34:35 <AntiCorrupcion> that is not listed anywhere?
11:34:36 <AntiCorrupcion> http://imgur.com/feq03xk
11:34:38 <AntiCorrupcion> what does it mean?
11:35:27 --- mode: ChanServ set +o Cale
11:35:45 <ReinH> ^ porn
11:35:47 --- mode: Cale set +b *!*@denuncia.anonima.empleosonora.gob.mx
11:35:47 --- kick: AntiCorrupcion was kicked by Cale (AntiCorrupcion)
11:35:58 <johnw> i wondered if that link was fishy
11:36:09 <haasn> I wonder if he accidentally had the wrong thing in his clipboard
11:36:16 <ReinH> nope
11:36:28 <Cale> No, this guy has been trolling dozens of channels for the last several days
11:36:29 <Hafydd> Couldn't he have bothered to change it from Erlang to Haskell?
11:36:42 <geekosaur> no, it loads as a terminal and then changes to porn at the last minute. has been hitting a bunch of chanels
11:36:44 <geekosaur> *channels
11:36:48 <ReinH> Hafydd: riak even
11:36:51 <carter> ReinH: i see you have resolvers repo access to
11:37:00 <carter> too :)
11:37:05 <ReinH> carter: which?
11:37:27 <geekosaur> also a rather formulaic presentation, so once you've been stung you recognize it pretty quickly...
11:38:49 <ReinH> your first clue is that it's a gif...
11:40:20 <Edoxile> ReinH, you don't see that unless you open the link ;)
11:40:53 <colDrMcBeardman> i see the troll has become more sophisticated.
11:41:36 <ReinH> aaanyway
11:44:48 <rento> Making an in-memory sql database in haskell would be a terrible choice right? to much mem use and poor performance compared to C+
11:44:52 <rento> C?
11:45:29 <joelteon> maybe, but it would certainly be less painful
11:45:29 <jrmithdobbs> rento: not any worse idea than doing an in-memory sql db in any other language
11:45:36 <jrmithdobbs> rento: (so yes, horrible idea)
11:45:44 <joelteon> look at edwardk's tables library
11:46:07 <jrmithdobbs> (my objection being the sql part, to be clear)
11:48:25 <johnw> rento: plus it's pretty easy to use sqlite as an in memory database, so it's probably not worth the effort
11:51:56 <rento> jrmithdobbs: dont like sql, why?
11:53:05 <jrmithdobbs> rento: solution in search of a problem
11:53:37 <jrmithdobbs> rento: if you actually have a relational problem it's great, but you rarely do.
11:54:30 <jaffachi_> is this the right place to discuss issues compiling ghc?
11:54:43 <shachaf> It's not a wrong place.
11:54:57 <shachaf> But it depends on your issues. How can people know if you don't ask?
11:56:05 <jaffachi_> ok then, linking fails when trying to compile ghc 7.8 in a fedora docker container, but works fine in 'regular' fedora
11:56:14 <augur> anyone know if there are efficient ways of handling large collections of set-like information?
11:57:04 <ixmatus> what's "handling" mean?
11:57:27 <augur> ixmatus: building and querying
11:57:34 <johnw> jaffachi_: "linking fails" really say nothing at all
11:57:36 <johnw> says
11:57:36 <ReinH> also what does "large" mean and what does "set-like" mean?
11:57:58 <augur> ReinH: large, as in very, set-like as in membership is the primary thing of interest
11:58:09 <ixmatus> Data.Set ?
11:58:34 <ReinH> What does "very large" mean? :p
11:58:40 <ReinH> Yes also why not Data.Set?
11:58:44 <corgifex> more than 200
11:58:50 <[swift]_> man, i'm amazed at how badly factored my older code is. i had no idea how to structure haskell code a couple years ago =(
11:58:53 <ReinH> corgifex: oh is that the "very" part?
11:59:03 <foobarbaz_> Hi guys; A long time ago someone here (or in #scala) linked to a pretty cool demonstration of haskell/scala being used in Facebook as a DSL - does anyone know the URL of it?
11:59:22 <ReinH> foobarbaz_: Simon Marlow's Haxl project?
11:59:27 <jaffachi_> I don't have the exact error message to hand but a linking error occurs when building Data.Array.Parallel, telling me to recompile with -fPIC
11:59:36 <augur> specifically, the task is, given a corpus of English, say, construct the k-contexts for all n-grams, and then compare them for overlap and find clusters therein
11:59:42 <jaffachi_> I was just wondering if there were any known issues with docker
12:00:09 <foobarbaz_> ReinH: Thanks! :)
12:00:30 <augur> ReinH: very large, as in you might have hundreds of thousands or millions of n-grams, each with hundreds of thousands of k-contexts
12:01:17 <augur> if you did this naively, there would just be too many pair-wise comparisons to make
12:01:50 <ixmatus> do you have to stream it from the filesystem or a DB? or is all of this being loaded into memory?
12:02:09 <augur> ixmatus: im not sure it matters. take your pick.
12:03:44 <ixmatus> I think it matters a great deal; if you're streaming the stored data then take your pick - at that point I/O matters more. If you're operating a single data set and that data set *must* be loaded into memory, then you're more limited in the data structures and operations you can use
12:03:48 <mwhitfield> this really seems like more of a general algorithms question. Haskell can support log(n) membership checks easily, or constant-time with a bit more trouble, it doesn't really seem like that's your problem.
12:04:16 <foobarbaz_> ReinH: Is there any official publications on that project?
12:04:23 <augur> yes, im sure its more a general algorithms question, but since im probably going to code it in haskell.. :P
12:04:54 <ixmatus> augur, do a first naive pass of it; my favorites for data structures come from the containers package
12:05:03 <ixmatus> Data.Set, Sequential, and Map
12:05:06 <ixmatus> are all very useful
12:05:33 <augur> probably an ideal option would be to find all the k-contexts and then, for each n-gram, assign a binary string with yes/no for each k-context
12:05:50 <augur> then probably some kind of clustering algorithm on top of that maybe?
12:06:05 <augur> maybe some kind of sparse vector clustering
12:06:41 <mwhitfield> should probably have asked about matrix/sparse matrix support then. (Don't know that much about Haskell's offerings there personally)
12:06:59 <augur> i dont know if thats a solution, but it seems like a possibility
12:17:54 * hackagebot scotty 0.7.2 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.7.2 (AndrewFarmer)
12:26:21 <mightrs> book with which they can learn the concepts of functional programming?
12:38:48 <[swift]_> is there a standard function somewhere "m a -> m b -> m (a, b)"? i can just use (,) with applicative stuff, i know, but this feels like something that might be clean with a single binary operator
12:39:04 <[swift]_> maybe something from Control.Arrow? i couldn't immediately make it work but i'm not a very experienced arrow user
12:39:34 <shachaf> I don't think you'll do better than lift2 (,)
12:40:11 <[swift]_> well i can always define my own =)
12:40:19 <shachaf> Yes.
12:40:22 * [swift]_ didn't know about lift2 though
12:40:48 <shachaf> This has a name but it's not in the standard library.
12:41:10 <[swift]_> doesn't come up on hoogle.. just shorthand for liftA2/liftM2?
12:41:22 <shachaf> It was actually me not pressing the A key.
12:41:31 <[swift]_> that would explain it, heh
12:43:57 <McEnroe> cabal/ghc-check thinks I have a package installed, although I don't. How do I fix that?
12:46:22 <JagaJaga> McEnroe, ghc-pkg unregister <pkgname>
12:47:17 <McEnroe> JagaJaga: Thanks. What if it's cascading? Is there a method for that too?
12:47:52 <JagaJaga> McEnroe, you mean you have registered but not presented pkgs?
12:48:23 <pordan30> is there a safe port of fgl available? i've been banging my head against the wall for several days with representations of graphs, attempting to eliminate the standard log n and log n! overheads incurred by traditional representations, but without a real satisfactory solution. as far as i can tell, fgl is highly optimized (especially, match operates in constant time) but unsafe, and attempting to catch each thrown error is tireso
12:48:23 <pordan30> me. for reference, the intended use face is layered drawings of (sparse) digraphs generated from graph reduction algorithms using the sugiyama framework. it's just - well, not pleasant.
12:51:45 <Cale> pordan30: log(n!)?
12:53:12 <cschneid> is the 7.8.1 tarball that's floating around suitable for building if I don't have an existing ghc? Or is that a "system-specific" version that'll come out soon, with all the appropriate bootstrapping?
12:53:18 <Cale> pordan30: It's really really hard to do better than Data.Map in practice because that library is so finely tuned, even if your asymptotics are theoretically better.
12:53:52 <Cale> pordan30: There's the unordered-containers package which has some nice almost-drop-in replacements that use hashing
12:54:13 <Cale> pordan30: Sometimes they're faster, sometimes they're slower.
12:55:09 <Cale> cschneid: Bootstrapping GHC is not trivial
12:55:32 <HasnNL> hallo guys...
12:55:33 <Cale> cschneid: at least as far as I'm aware, you need to actually know what you're doing to bootstrap on a platform where there's no existing binary
12:55:49 <HasnNL> I have a problem, I need to get this done ( A binary tree is complete if the two sub-trees of
12:55:49 <HasnNL> every node are of equal size. Define a function
12:55:49 <HasnNL> that decides if a binary tree is complete.)
12:56:24 <pordan30> Cale: log (n!) from, say, log 1 + log 2 + ... + log n
12:56:28 <HasnNL> so far i have this http://lpaste.net/102444
12:56:40 <HasnNL> can someone help me ?
12:57:27 <Cale> HasnNL: So, you might start by writing something which computes the size of a subtree.
12:57:29 <pordan30> Cale: data.map also has the advantage of a complete and intuitive api, so i'm using it for a test implementation
12:58:07 <fragamus> hey can you guys help me? I am trying to find the centroid of an area defined in polar coordinates
12:58:11 <pordan30> but i will look at unordered containers; it's unfortunate that the highly advertised graph library isn't pure :/
12:58:11 <fragamus> I have a start angle and end angle for the area
12:58:15 <fragamus> and a function of angle
12:58:15 <HasnNL> Cale: how ? I have been trying the whole time
12:58:19 <fragamus> that gives the radial boundary
12:58:33 <HasnNL> Cale: size :: Tree a -> Int
12:58:33 <HasnNL> size Empty   = 0
12:58:33 <HasnNL> size (Leaf n)    = 1
12:58:33 <HasnNL> size (Node left elem right) = size left + size right + 1
12:58:38 <HasnNL> I wrote this
12:58:56 <HasnNL> but It doesnt  work
12:59:05 <Cale> HasnNL: oh?
12:59:11 <jrmithdobbs> is it lazy? sit on the couch all day?
12:59:15 <cschneid> Cale: I built ghc 7.6.3 off a "bootstrappable" tarball, which had static linked versions of ghc & friends to do enough to start into the cycle.
12:59:33 <Cale> cschneid: cool
12:59:39 <cschneid> was hoping to update my nitrous.io build to 7.8.1 - but I need that tarball to do it :)
12:59:41 <Cale> cschneid: I didn't know people made such things :)
12:59:46 <cschneid> (due to their silly package manager)
13:00:05 <Cale> cschneid: I usually just get the binary package. You gain essentially nothing by building it yoursefl.
13:00:10 <Cale> yourself*
13:00:42 <cschneid> Cale: yeah, but I need to install it into userspace, with appropriate prefix & such - building it on their specific systems was the way I figured it out
13:00:46 <jrmithdobbs> unless you're wanting dynamic linking on/off by default and such
13:01:07 <gdoteof> i am trying to create a named pipe in haskell.  it is asking for a CMode, presumably so i can tell it is r or rw; but i don't understand how to construct a cmode.  constructor asks for a word32
13:01:12 <HasnNL> Cale: any suggestions?
13:01:21 <corgifex> HasnNL: what's the problem?
13:01:26 <Cale> HasnNL: That code looks fine for computing the size.
13:01:27 <Algebr> Any special I need to add in my .emacs so that haskell mode shows breakpoints or some visual queue when I'm stepping through breakpoints while in haskell-mode?
13:01:32 <Cale> HasnNL: What's going wrong?
13:01:41 <pordan30> HasnNL: what do you mean "it doesn't work"? are you getting compiler errors or is it not computing the correct values (it looks like it should)
13:02:07 <HasnNL> I need to get this done A binary tree is complete if the two sub-trees of
13:02:08 <HasnNL> every node are of equal size. Define a function
13:02:08 <HasnNL> that decides if a binary tree is complete.
13:02:28 <corgifex> cool story, bro
13:02:33 <HasnNL> and I dont know how to get further
13:02:38 <jrmithdobbs> well, repeating yourself in the face of questioning is obviously the best approach to completing the task! good luck!
13:03:06 <HasnNL> I dont have any erros
13:03:12 <HasnNL> errors
13:03:21 <corgifex> what do you have?
13:03:38 <HasnNL> i'll paste my code
13:03:41 <HasnNL> one sec
13:03:52 <cschneid> Cale: yeah, I need the -unknown-linux build to do what I want. It's probably coming down the pipe soonish, I'll hold off :)
13:04:03 <HasnNL> http://lpaste.net/102445
13:06:15 <HasnNL> Cale: are you there ?
13:06:16 <Cale> HasnNL: Well, you now know how to check what the size of a tree is. Similarly to your function for computing the size, do another case analysis by pattern matching.
13:06:31 <Cale> HasnNL: (yes, but I'm also participating in conversations in a couple other channels)
13:07:06 <Cale> The empty tree, and a single leaf are surely complete
13:07:26 <Cale> A branch is complete if its subtrees are of the same size, and each of them is complete.
13:08:18 <HasnNL> Cale: can you help me out with the code .. I need start
13:09:09 <Cale> complete Empty = ...
13:09:14 <Cale> complete (Leaf x) = ...
13:09:28 <Cale> complete (Node l x r) = ...
13:09:37 <pordan30> HasnNL: you should define a function, say 'complete :: Tree a -> Bool' that uses 'size', '(==)', and '(&&)'  to determine whether the left and right subtrees of a node have the same size (this function will not be efficient)
13:13:00 * hackagebot sha-streams 0.1.1 - SHA hashes for io-streams.  http://hackage.haskell.org/package/sha-streams-0.1.1 (VoMinhThu)
13:14:21 <rusk101> Hello everyone, I have a problem here that I do now want to do recursively. How do I take a list [1,4,11,22] and get a list of differences -> [3,7,11]?
13:14:29 <rusk101> I can do it recursively but wish not to
13:14:57 <cschneid> why not recursively? It's basically all haskell does. recursion.
13:15:11 <corgifex> > ap (zipWith (-)) tail [1,4,11,22]
13:15:12 <lambdabot>  [-3,-7,-11]
13:15:17 <corgifex> almost
13:15:32 <rusk101> ap?
13:15:49 <cschneid> ahh do you just mean "without a function I implement myself", then ok. But zipWith uses recursion :)
13:15:55 <corgifex> > (=<<) (zipWith (-)) tail [1,4,11,22]
13:15:57 <lambdabot>  [3,7,11]
13:16:58 <rusk101> I dont understand neither 'ap' nor '(=<<)'
13:17:35 <cschneid> here's a simpler one along the same lines:
13:17:36 <cschneid> > let x = [1,4,11,22] in zipWith (-) (tail x) x
13:17:40 <lambdabot>  [3,7,11]
13:17:54 <student01> Hi, I have a pattern matching question... basically following this pseudo: A char can have a value from 0 to 10 inclusive, if x == 10 then replace with 'X' else don't replace. The replacement is giving me problems!
13:18:34 <Ralith> lots of people with haskell homework today
13:18:43 <cschneid> student01: well, a char represents a single character.  "10" is two characters when in string form.
13:19:46 <Rembane> I wonder which university.
13:20:03 <rusk101> ap (zipWith (-)) tail [1,4,11,22]
13:20:14 <student01> okay let me try explaining another way: (and sorry, homeworkish puzzles are the only way I know to learn this!) some function f(x) can return 0 to 10 inclusive, but if it's a 10 I want to change it to X
13:20:25 <cschneid> rusk101: lead with a > in this channel to have lambdabot run the code for you
13:20:48 <cschneid> student01: so f returns a number, Int or Integer presumably?
13:20:53 <corgifex> student01: what are the types here?
13:21:31 <student01> it will be a number, but then I take that number and append it to a string. ex. mystring1, mystring2, ..... mystringX
13:21:39 <rusk101> What is 'ap' in   ap (zipWith (-)) tail [1,4,11,22]
13:21:42 <rusk101> a>   ap (zipWith (-)) tail [1,4,11,22]
13:21:45 <ajcoppa> :t ap
13:21:46 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:21:53 <rusk101> >  ap (zipWith (-)) tail [1,4,11,22]
13:21:55 <lambdabot>  [-3,-7,-11]
13:21:59 <corgifex> student01: how is X a number?
13:22:22 <student01> X represents 10. when f() calculates some value to be 10, I want it to return X instead.
13:22:36 <haasn> :t ap `asTypeIn` \ap ->  ap (zipWith (-)) tail [1,4,11,22] -- rusk101
13:22:38 <pordan30> so what is the type signature of your function?
13:22:40 <lambdabot> Num t => ([t] -> [t] -> [t]) -> ([t] -> [t]) -> [t] -> [t]
13:22:42 <corgifex> student01: you keep repeating that, but it still doesn't make sense
13:23:02 <haasn> rusk101: this tells us (->) [t] is the Monad instance we're dealing with
13:23:18 <cschneid> student01: haskell makes a very strict distinction between numbers and characters. So you can't just replace a number sometimes with a character.  You could take a number, get its character representation, then modify that representation if needed.
13:23:41 <ReinH> cschneid: except that not all numbers have character representations
13:23:45 <ReinH> only 10 of them, in fact
13:23:49 <cschneid> ReinH: boom! mind blown
13:23:58 <ReinH> cschneid: :p
13:24:00 <cschneid> you're right. String would have been better.
13:24:06 <cschneid> or [Char] :)
13:24:09 <ReinH> :)
13:24:15 <corgifex> > chr 10
13:24:16 <student01> corgifex: sorry, let me try again: I have f(y) where y is some arbitrary number. f() returns y `mod` 11, so sometimes 10 gets returned. But instead of 10, I want X.  (roman numeral representation of 10). That way only one char is ever returned (as 10 is two chars, X is one)
13:24:16 <lambdabot>  '\n'
13:24:22 <ReinH> > show 10
13:24:23 <lambdabot>  "10"
13:24:30 <cschneid> student01: so you want a function of type   myNumber :: Integer => Char
13:24:32 <haasn> > chr (10^50)
13:24:34 <lambdabot>  *Exception: Prelude.chr: bad argument: (-5376172055173529600)
13:24:38 <haasn> Yuck
13:24:45 <cschneid> such that it returns the exact representation for 0-9, and 'X' for 10
13:24:47 <haasn> > chr maxBound
13:24:48 <lambdabot>  *Exception: Prelude.chr: bad argument: 9223372036854775807
13:24:53 <ReinH> student01: You cannot have a Haskell function that sometimes returns one type and sometimes returns a different type
13:24:54 <cschneid> and uh... crashes for anything bigger I suppose
13:24:55 <corgifex> student01: the other numbers aren't chars
13:25:12 <haasn> ReinH: unless, of course, it's polymorphic
13:25:24 <student01> ReinH: can I have it return the char representation of a number though? so it returns '1', '2', 'X'?
13:25:30 <student01> because that's okay
13:25:31 <cschneid> I screwed up earlier, and made a fat arrow.  numberToChar :: Integer -> Char
13:25:31 <ReinH> student01: yes.
13:25:39 <haasn> student01: if you figure out what a Char representation of a number means
13:25:48 <cschneid> student01: exactly, so first just figure out how to turn an integer directly into a string (which is just a list of chars)
13:25:55 <haasn> oh, it's modulo 11
13:26:00 <haasn> then that should be relatively easy
13:26:07 <corgifex> cschneid: why a string?
13:26:26 <student01> right, I've got that part. Like I said this function works perfectly when y `mod` 11 returns the char representation of 0 thru 9, but when it returns 10 I want to convert it to X.
13:26:41 <corgifex> student01: what is "this function"?
13:26:47 <corgifex> do you have code?
13:26:48 <cschneid> corgifex: eh, a char would work too of course. Sorry, I rarely thing of individuals chars.
13:27:57 <student01> an ISBN checksum. takes a 9 digit number, computes the 10th digit by summing the digits `mod` 11. ex. 758391038-1 maybe, and 671047209-X also.
13:28:26 <jrmithdobbs> now cover the 5 (6?) other isbn types
13:28:35 <corgifex> student01: do you have code or not?
13:28:39 <jrmithdobbs> stupid non-standard standards
13:28:52 <ReinH> student01: can you write a function f :: Int -> Char that takes 0..9 to '0'..'9' and 10 to 'X'?
13:28:58 <student01> appendChecksum str = str ++  show (sum (zipWith (*) [1..9] (map digitToInt (take 9 str))) `mod` 11)
13:29:36 <student01> the checksum is computed by each digit multiplied by its index in the number mod 11
13:29:51 <student01> the total sum of each digit * its index I mean
13:29:53 <student01> mod 11
13:31:01 <student01> so I was thinking to wrap something around it like [if f(x) `mod` 11 equals 10 then 'X' else 'whatever f(x) returned originally']
13:31:18 <cschneid> student01: write more functions, no need to do this in one line
13:31:21 <Nik05> hello, im reading realworldhaskell about compling and linking modules
13:31:45 <cschneid> write a function that does one thing first: "change a Int from 0-10 into 0-9 plus X"
13:31:52 <corgifex> student01: nah, just write that helper function ReinH mentioned
13:32:07 <haasn> (digitToInt? uh oh)
13:32:35 <Nik05> compiled a module with ghc -c, and trying to compile and link with ghc -o foo Main.hs bar.o, but with bar.o im getting "multiple definition" with bar.hs it is linking
13:33:06 <jrmithdobbs> Nik05: basically: ignore everything rwh says re: how to build things and go read cabal docs and/or LYAH for that, it's more updated
13:33:23 <Nik05> oh ok
13:33:27 <jrmithdobbs> Nik05: everything that doesn't start with ghc --make; anyways
13:33:37 <corgifex> --make is the default
13:33:45 <yitz> it is?
13:34:05 <Nik05> well i still dont get why it doesnt compile with bar.o. With gcc this just works fine :P
13:34:05 <geekosaur> ghc is building the module automaticallu because it is referenced from Main.hs, then linking it in twice because you specified it and --make has been the default for a while
13:34:24 <geekosaur> gcc doesn't do "make" like stuff automatically
13:34:35 <geekosaur> I am not sure if this *should* work
13:34:45 <Nik05> ok
13:34:59 <corgifex> Nik05: try compiling your main file with -c too
13:35:03 <geekosaur> but RWH predates automatic "make mode" and assumes you need to do it manually
13:35:08 <corgifex> then you can probably link all the *.o files
13:35:14 <geekosaur> while chrrent ghc does it automatically
13:35:18 <geekosaur> *current
13:35:37 <yitz> wow never noticed that --make is now the default. manual ghc compiles have bitrotted in my brain due to cabal use.
13:35:48 <corgifex> "now"
13:35:52 <Nik05> ah thank you corgifex now it works :)
13:35:57 <corgifex> how many years has it been?
13:36:47 <yitz> corgifex: i still type --make or use cabal so i have no idea
13:37:42 <yitz> corgifex: so then what if you don't want --make?
13:37:54 <yitz> --dont-make?
13:38:04 * hackagebot template-haskell 2.9.0.0 - Support library for Template Haskell  http://hackage.haskell.org/package/template-haskell-2.9.0.0 (HerbertValerioRiedel)
13:38:41 <student01> ReinH: thank you. I think what you wrote earlier will solve my problem. do I implement the function with an if-then-else or filter or ? guards I think? very new ha
13:39:34 <corgifex> yitz: -c
13:40:30 <yitz> corgifex: ok tnx.
13:41:26 <sx> Hi, I need to abstract out some logic from a "data"-definition, in order to extend it, the problem is that the base type itself is recursive. I sketched how it could be solved, but maybe one of you has a better idea how to do it?  http://lpaste.net/102450
13:42:22 <corgifex> external recursion seems to be missing
13:42:47 <corgifex> data Base rec = B | R rec
13:42:55 <corgifex> type Base' = Mu Base
13:42:59 <yomee> logout
13:43:07 <ReinH> student01: I'd probably use pattern matching
13:43:48 <corgifex> student01: I'd use a guard
13:44:30 <sx> corgifex: so what would Mu be?
13:44:37 * yitz is with corgifex 
13:45:34 <corgifex> newtype Mu f = Mu (f (Mu f))
13:45:37 <corgifex> or something like that
13:46:53 <sx> corgifex: Alright thanks, I'll give it a try.
13:47:19 <corgifex> data Ext = E T C | B (Base Ext)
13:47:42 <mmachenry> I'm looking to write a TCP server and I've found a decent number of packages and wiki nodes on the topic. A lot of them seem (or even say they are) out of date. I want to check with people on which packages are recommended for writing TCP servers.
13:48:29 <mmachenry> Network, Network.Simple.TCP seem slightly incompatible when it comes to how they treat sockets vs. handles. What does everyone really use?
13:54:19 <Algebr> Say you have `foo = putStrLn "howdy"`, foo is not a function, nor is it a constant, it just causes side effects, what do you call foo?
13:54:32 <cschneid> mmachenry: conduits based servers might be useful - maybe look into that? (I know very little other than it powers yesod).
13:54:37 <corgifex> it's a constant and causes nothing
13:54:37 <kayloos> How do I launch `cabal repl` with OverloadedStrings? Help says to pass `--PROG-options=OPTS` but I don't quite know what to put in place of PROG.
13:54:50 <cschneid> Algebr: "io action" is a reasonable name.
13:55:05 <eitan_> IO ()
13:55:27 <mmachenry> cschneid: Thanks I'll check it out.
13:55:28 <Algebr> Ah, got it.
13:55:45 <ReinH> it is a constant to the extent that any value is a constant
13:55:53 <cschneid> mmachenry: http://www.yesodweb.com/blog/2014/03/network-conduit-async
13:58:36 <haasn> Algebr: foo is a constant, though
13:58:47 <student01> ReinH: if you're still around, I really appreciate it -was stuck on that problem for too long, all working now!
13:58:55 <ReinH> student01: you're welcome!
13:59:50 <yogert> When Ghclint says "use section" for something like "(flip splitAt l)" what does it mean?
14:00:23 <shachaf> It means (`splitAt` l)
14:00:25 <corgifex> (`splitAt` l)
14:00:34 <yogert> oh, so make it infix
14:00:35 <yogert> ok
14:01:00 <yogert> thanks
14:01:16 <DerGuteMoritz> hello! I am wondering whether there is a library that allows for using a parsec parser definition to "unparse" a parse result. AFAICT parsec itself does not offer this and my guess is that it can't be doen for the general case anyway so it would require some restrictions.
14:01:58 <ReinH> DerGuteMoritz: Not generally, although "invertible parsers" is an area of research
14:02:10 <DerGuteMoritz> ah!
14:02:25 <ReinH> @hackage boomerang
14:02:25 <lambdabot> http://hackage.haskell.org/package/boomerang
14:02:31 <DerGuteMoritz> ReinH: thanks, just wanted to make sure I'm not overlooking something :-)
14:02:34 <ReinH> http://camlunity.ru/swap/Library/Computer%20Science/Parsers/Invertible%20Syntax%20Descriptions.%20Unifying%20Parsing%20and%20Pretty-Printing.pdf
14:02:47 <DerGuteMoritz> ReinH: oh, very nice! thanks a lot
14:02:52 <ReinH> np
14:03:07 * hackagebot hoopl 3.10.0.1 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.10.0.1 (HerbertValerioRiedel)
14:04:59 <sx> corgifex: http://lpaste.net/102454 this is what I have now, works as expected, the only drawback is that when only using the Base type, I always have to use the newtype wrapper. But I can't fix that I guess?
14:13:08 * hackagebot purescript 0.4.17 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.17 (PhilFreeman)
14:14:49 <dart> hi
14:15:07 <walpen> dart hi
14:15:24 <dart> i really don't understand this error, http://lpaste.net/102456
14:17:10 <Apocalisp> jfischoff: Let's talk about #bayhac
14:19:21 <walpen> dart so what I'm getting is that the type of `lift` is `m a -> t m a` where `m` has kind `* -> *` (that `t0` in the error message is the `t` in the type of `lift`, as near as I can tell)
14:19:31 <shachaf> dart: It sounds like you want liftIO, not lift.
14:19:43 <shachaf> dart: Or lift . liftIO, or something.
14:19:56 <shachaf> dart: (But please include complete error messages, including line numbers, with pastes like this!)
14:23:43 <johnw> lift . liftIO would be impossible, you cannot lift through IO
14:24:17 <shachaf> :t lift . liftIO
14:24:18 <lambdabot> (MonadIO m, MonadTrans t) => IO a -> t m a
14:24:38 <johnw> ack, you are right, I was thinking in reverse
14:25:03 <shachaf> I'm always right. Except when I'm wrong.
14:25:06 <johnw> :)
14:25:43 <kqr> hi. i've begun to appreciate Text.Printf (printf) more and more as time passes. however, I don't like that it's so unsafe. is there some variant of it that has more compile-time guarantees or do I just have to be careful?
14:26:20 <joelteon> kqr: not without template haskell, quasiquotation, or really ugly format strings.
14:26:25 <joelteon> pick your poison
14:26:36 <geekosaur> isn't there a type safe applicative version?
14:26:44 <joelteon> is there? i'd like to see it
14:27:20 <johnw> compile-time type safety based on the contents of a string value?  sounds like dependent types...
14:32:44 <akurilin> Quick newbie question: given purity, is there still something I can use to printf to stdout without having to now carve an IO path all the way back to main?
14:33:11 * hackagebot http-test 0.1.5 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.1.5 (glutamate)
14:33:31 <Hafydd> akurilin: do you mean for the purposes of debugging?
14:33:36 <akurilin> yes
14:33:46 <kqr> akurilin, use the trace function for debugging
14:34:00 <kqr> akurilin, but don't use it for anything else.
14:34:20 <kqr> akurilin, if you need I/O deep down in your application you should probably refactor it
14:34:29 <byorgey> akurilin: http://hackage.haskell.org/package/base-4.7.0.0/docs/Debug-Trace.html
14:34:57 <mjrosenb> why is https://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Map.html the first result when I search "haskell data.map" :-(
14:35:43 <byorgey> mjrosenb: pagerank doesn't work very well for documentation.  Hardly anyone actually links directly to a page of documentation.
14:35:50 <kqr> mjrosenb, add "latest" to the search terms
14:36:16 <byorgey> mjrosenb: it's generally not a good idea to use Google to search for Haskell documentation. Use Hoogle or Hayoo instead.
14:36:18 <akurilin> kqr: byorgey perfefct thanks. Yeah exclusively for seeing the state in some fns when I'm debugging
14:37:05 <mjrosenb> byorgey: but tying in the awesomebar is the easiest :-(
14:37:19 <yitz> akurilin: also, have a look at ghci and its debugger facilities
14:38:35 <akurilin> yitz: there's nothing even remotely close to a stepping debugger in haskell, is there?
14:38:48 <byorgey> mjrosenb: you can create smart keywords for the awesomebar to search hoogle and hayoo
14:38:50 <yitz> akurilin: that's exactly what i was referring to
14:39:02 <davidthomas> Is (Monoid v => Map k v) a monoid over (unionWith mappend)?
14:39:10 <mjrosenb> byorgey: yeah, I should do that.
14:39:12 <byorgey> so you can search hoogle just by typing e.g. 'hoogle data.map' into the awesomebar.
14:39:20 <byorgey> that's no harder than typing 'haskell data.map'.
14:39:26 <akurilin> tbh after a year in Clojure I'm used to chewing on glass and debugging large dynamically typed systems with printf :)
14:39:34 <akurilin> so it only gets better from here
14:39:51 <yitz> akurilin: type :help in ghci, and look at the ghc user manual.
14:39:51 <Cale> akurilin: There'
14:40:08 <Cale> There's a debugger in ghci, but only few people actually use it from what I gather
14:40:15 <Cale> (I've never actually used it)
14:40:22 <byorgey> davidthomas: yes
14:40:48 <yitz> Cale: i do use it sometimes. not too often, but only because i usually just don't need it. it's nice when you do though.
14:40:50 <jrmithdobbs> Cale: i've tried a couple times but every time by the time i figure it out enough for it to be useful i realize i'm hunting something i didn't need a debugger for in the first place, heh
14:40:53 <Cale> akurilin: It's much more common to just lean hard on the fact that evaluation in Haskell is referentially transparent, so testing things in isolation will have the same result as when they are used in the full program.
14:41:11 <kqr> byorgey, i've found hoogle gives weird results when i search for modules
14:41:22 <kqr> byorgey, it seems as though it only wants to search for function names, type signatures and package names
14:41:22 <yitz> @hoogle modules
14:41:23 <lambdabot> System.Posix.DynamicLinker.Module moduleSymbol :: Module -> String -> IO (FunPtr a)
14:41:23 <lambdabot> System.Posix.DynamicLinker.Module.ByteString moduleSymbol :: Module -> String -> IO (FunPtr a)
14:41:23 <lambdabot> package edenmodules
14:41:30 <davidthomas> byorgey: Thought so... is it defined anywhere?
14:41:34 <yitz> kqr: yeah, that's weird
14:41:40 <davidthomas> I guess it'd be orphan
14:41:42 <byorgey> kqr: yeah, actually, I agree.  So it was a bad example.  maybe hayoo does better on module names.
14:41:52 <kqr> maybe. i haven't use hayoo much at all
14:41:53 <akurilin> Cale: that's what I do every, it's certainly a strong option. It gets tricky when you have a large set of params you're passing into a function, but maybe that's an indication of a design issue.
14:42:34 <yitz> akurilin: define helper functions in ghci. or ghci user-defined commands.
14:43:04 <byorgey> davidthomas: it wouldn't be orphan, because Data.Map already has a different Monoid instance defined (left-biased union)
14:43:11 <yitz> akurilin: or (what i usually do, to my embarassment) type them all once, and then use the up arrow heavily
14:43:18 <byorgey> davidthomas: so if it is defined somewhere it would have to be for a newtype.
14:43:20 <davidthomas> ah
14:43:25 <davidthomas> gotcha
14:44:25 <kqr> akurilin, and don't be afraid to create data types to collect multiple related arguments into one thing, where it makes sense
14:44:31 <Cale> akurilin: Also, there is Debug.Trace for capturing real-world arguments to something
14:44:40 <kqr> akurilin, if you have a lot of default values you can also create a constructor function that fills most of those in
14:44:43 <pavonia> Can anyone help my reducing some do-block boilerplate? I think you can reduce the part after "p <- " to something like "... <|> ... >>= ..." but I can't get it right http://lpaste.net/102458
14:45:11 <Cale> You can do something like  myFunction x y z | trace (concat ["myFunction ", show x, show y, show z]) False = undefined
14:45:16 <Cale> at the start of the definition
14:45:18 <byorgey> davidthomas: in any case, I'm not aware of it being defined somewhere, though I think I remember seeing that instance discussed in the past
14:45:30 <Cale> er, unwords, I mean :)
14:45:37 <davidthomas> byorgey: 'k, thanks a bunch :)
14:45:43 <byorgey> in particular I seem to recall there was some discussion of replacing the current Monoid instance with yours
14:45:43 <Cale> (you'll want some spaces there :)
14:45:54 <davidthomas> gotcha
14:45:54 <byorgey> since it is more general.
14:46:02 <davidthomas> right, and less lossy
14:46:40 <akurilin> kqr, Cale good tips, thank you
14:46:46 <corgifex> > Just "a" <|> Just "b"
14:46:48 <lambdabot>  Just "a"
14:46:54 <corgifex> > Nothing <|> Just "b"
14:46:55 <lambdabot>  Just "b"
14:48:25 <corgifex> p <- maybe (failure "no parser") return $ mbParser <|> (mbHdr >>= hdrParser)
14:48:54 <yitz> > M.singleton 0 "abc" <> M.singleton 0 "def" -- davidthomas
14:48:55 <lambdabot>  fromList [(0,"abc")]
14:49:41 <byorgey> yitz: ?
14:50:00 <corgifex> maybe (failure "no parser") (hostEither . readParser) $ mbParser <|> (mbHdr >>= hdrParser)
14:50:03 <athan> Hey everyone, why do I see `type` expressions within type class defintion clauses?
14:50:17 <yitz> byorgey: that pesky "other" Monoid instance
14:50:26 <corgifex> asstypes
14:50:42 <athan> yitz: Ahh, I could see that
14:50:46 <byorgey> athan: those are "associated types"
14:50:47 <ijp> is there a name for the generic concept of composing a function with a foldr, e.g. foo = bar . foldr f b
14:50:50 <athan> yitz: What instance would you want?
14:50:57 <byorgey> athan: search for "type families" and "associated types"
14:51:04 <athan> byorgey: Hmm, I'll have to look into it. Thank you!
14:51:22 <byorgey> ijp: not that I know of
14:51:37 <yitz> athan: davidthomas was asking for (Monoid v => Map k v) a monoid over (unionWith mappend)
14:52:54 <pavonia> corgifex: Awesome, thanks!
14:53:34 <athan> yitz: Hmm. Do you think it would be easy to fix the list translation? M.Singleton just turns into a list for the monoid instance, right?
14:54:36 <yitz> athan: the fromList thing is just the Show instance for Data.Map.
14:55:56 <athan> yitz: Ahh my mistake. Thanks
14:56:31 <athan> byorgey: Would associated types be like H-M's style of dependent typing? Or some kind of similar motivation?
14:58:08 <johnw> no, they do not provide dependent typing
14:58:27 <johnw> a dependent type is like having a function which, based on the value you pass it, returns a different *type*
14:58:49 <athan> yeah I'd imagine they don't provide anything nearly as powerful / compatible
14:58:59 <athan> johnw: Oh wow, that's a new take on it for me
14:59:28 <johnw> athan: http://en.wikipedia.org/wiki/Dependent_type
14:59:45 <athan> johnw: Thank you!
15:00:18 <erisco> erm does anyone know of a brief tutorial for web-routes?
15:00:45 <johnw> note that with closed type families, GADTs and singletons, you can get really near the expressivity of dependent types
15:00:49 <erisco> there was something in the happsack docs but it immediately going into template Haskell which I do not want
15:00:51 <johnw> erisco: which web framework?
15:00:56 <erisco> johnw, none
15:01:10 <johnw> ah
15:01:34 <erisco> I am developing a client-side application and just need a routing library
15:03:12 <athan> johnw: Ahh! See, that's what I was wondering - if combinations of extensions could bring haskell's type system closer to something like System-F_sub or something
15:03:57 <erisco> [String -> Maybe t]  is about all I need so I guess I'll just implement it myself
15:04:18 <erisco> hrm, I suppose having the reverse direction would be helpful too though
15:04:22 <johnw> athan: Richard Eisenberg, who wrote the singletons package, actually has a full proof that his sort function returns a ordered list containing a permutation of the elements of the input list -- in regular Haskell using that library
15:04:49 <johnw> but he told me that the proof was tortuous to write, and hard to read
15:05:06 <johnw> fully dependently typed languages make such things much nicer to express
15:05:16 <djahandarie> I've written a proof for that too, it was not pretty.
15:05:19 <athan> ahh! That's amazing!!
15:05:24 <athan> that's too cool
15:05:45 <athan> I can't wait to dig into proofs. I haven't written one yet
15:06:07 <athan> Quick question, though. Would GADT's still be considered a semi-nearring?
15:06:09 <johnw> athan: I highly recommend playing with http://www.cis.upenn.edu/~bcpierce/sf/ and the Coq language to start out
15:06:27 <athan> I feel like the design in beyond the two product/sum operations with GADTS
15:06:28 <johnw> athan: yes
15:06:48 <johnw> GADTs can be seen as a yoneda embedding of a regular ADT
15:07:13 <johnw> as shown in detail here: http://www.haskellforall.com/2012/06/gadts.html
15:07:54 <athan> johnw: Just bought his book :)
15:08:12 <johnw> whose book?
15:08:24 <athan> johnw: I still don't understand what the Yoneda lemma implies, though :/
15:08:39 <athan> johnw: Benjamin Pierce's Types and Programming langs
15:09:10 <athan> johnw: Oh wow! I haven't seen this one yet! Thank you!
15:10:31 <heatsink> Should the test-suite stanza in a cabal file repeat all the build information from the executable stanza?
15:11:06 <johnw> athan: yoneda will take some time and study, but it comes up over and over again
15:11:21 <johnw> heatsink: I know there's a way to avoid that, but I've forgotten how :(
15:11:37 <athan> johnw: I hear everyone mentioning it - it seems as pivotal as church encodings.
15:11:38 <heatsink> hmm
15:12:07 <shachaf> That post looks like a stretch to me.
15:12:09 <athan> What kind of background would I need to understand it's impact?
15:12:22 <athan> **seems** ;P
15:12:47 <athan> Abstract Algebra? Should I have CT down before I take a look at it?
15:13:06 <heatsink> No, you should be familiar with abstract algebra before looking at CT
15:13:27 <mmachenry> Could someone explain to me why a simple client server I just wrote is communicating just fine and quite rapidly until for unknown reasons the client stops sending data? http://lpaste.net/102460
15:13:42 <shachaf> In fact I'm not sure that it makes any sense. Perhaps I'm misunderstanding it.
15:13:47 <johnw> is a church encoding for "a" just Yoneda applied to the identity functor?
15:13:48 <athan> heatsink: I'm wondering what the pre-req's are for understanding the yeonda lemma
15:13:52 <mmachenry> It's a 3 line client program that should just send data forever but it only sends a few hundred lines and freezes.
15:14:01 <athan> johnw: Now that's interesting
15:15:25 <johnw> there is a proof of such in the first answer listed here: http://stackoverflow.com/questions/10453558/algebraically-interpreting-polymorphism
15:17:10 <athan> johnw: Your willingness to share your mastery is much appreciated :)
15:17:29 <johnw> I would not ever call myself a master where math or Haskell is concerned, so beware
15:17:45 <johnw> part of my willingness to speak comes from knowing that people like shachaf are here to correct me if I misinform you
15:18:12 <shachaf> Is there someone here who understands the post that johnw linked to and thinks it makes sense?
15:18:46 <shachaf> johnw: That is a terrible system. :-(
15:19:10 <athan> Ha!
15:19:22 <johnw> shachaf: is a better alternative to be silent for years until I feel that I have mastered it?
15:19:35 <athan> shachaf: The latest SO post? I might
15:19:37 <johnw> my right/wrong percentage is steadily improving, I would hope
15:19:51 <c_wraith> shachaf: I understood it.  And I see where it went wrong.
15:19:57 <haasn> the one on GADTs?
15:20:13 <flebron> Perhaps one of your may know - is there something that allows me to conclude that f :: a -> a, f total, is the identity? (Free theorem just says g . f = f . g, but it doesn't say this is = g)
15:20:24 <c_wraith> err.  I was referring to the one on algebraic data types
15:20:53 <jle`> well...the intuition is where are you going to get an 'a'
15:20:54 <shachaf> I'm talking about the "GADTs" post.
15:21:05 <c_wraith> ah
15:21:30 <flebron> Yeah I can't see how it'd be anything but id, but can't seem to prove it.
15:21:56 <athan> jle`: So it's more of a comparison of domains / codomains?
15:21:57 <johnw> flebron: can you show uniqueness?  assume another f' :: a -> a, and show that they must be the same?
15:21:58 <shachaf> It says things like that an empty type Z isn't initial because you can write a function :: Z -> String (?).
15:22:24 * heatsink thinks it understands that SO post, but isn't sure
15:22:54 <haasn> “... but the Yoneda lemma says that if List a is a functor, then the following constructor is isomorphic: ”
15:23:05 <haasn> But List a is not a Functor
15:23:23 <shachaf> Yep. That's the point of a GADT.
15:23:53 <haasn> Unless “functor” means something other than “Functor”, but in that case, why present the yoneda lemma in its Functor/Haske form?
15:23:56 <haasn> Hask*
15:23:57 <athan> WOAH
15:24:23 <athan> sorry
15:24:27 <flebron> haasn: There's an instance Functor in that post for List a
15:24:30 <athan> still perpetually dumbfounded
15:24:39 <shachaf> Ye Olde Haske Functore
15:24:45 <athan> hahaha
15:25:05 <haasn> flebron: but that presents a functor instance on the “new” List a, which is trivial because Yoneda f is a functor for any f
15:25:20 <shachaf> That post has multiple different types named List.
15:25:25 <haasn> it doesn't justify List' a n ⇔ List a n
15:25:33 <shachaf> Proof-by-giving-things-the-same-name.
15:25:50 <ReinH> shachaf: wait so proof-by-equivocation isn't valid?
15:26:05 <athan> so when I start to write proofs, where is a good place to get criticism?
15:26:13 <athan> just here? :P
15:26:16 <WraithM> For a broadcast TChan, do I have to dupTChan for every reading end? Or can I just dupTChan once, and distribute that to all of the places I read that TChan from?
15:26:28 <johnw> athan: you will definitely get some here :)
15:26:35 <athan> sweet :)
15:27:27 <athan> could someone show me how (forall r . (a -> r) -> r) ~ a?
15:27:37 <shachaf> Rank-2 types give you almost as much power as GHC GADTs.
15:28:29 <c_wraith> athan: What can you do with a value of type (forall r. (a -> r) -> r)?
15:28:57 <athan> c_wraith: Conclude any result with a particular input?
15:29:18 <c_wraith> athan: well, I was thinking at a more basic level.  It's a function.  You can apply it.
15:29:32 <athan> hmm
15:29:35 <athan> I'm not sure I follow
15:29:40 <athan> oh!
15:29:40 <haasn> (You can also force it, but that won't get you far)
15:29:51 <eitan> when is the applicative instance derivable from a monad instance not the same as the applicative instance you may want to use?
15:29:56 <athan> You can create any result?
15:30:06 <c_wraith> athan: well, look at what happens when you apply a function of type (a -> b) to it...  You get a value of type b.
15:30:13 <haasn> eitan: ZipList is an example
15:30:25 <joelteon> When do we get --ignore-upper-constraints in cabal
15:30:31 <haasn> eitan: but in this case, you need a newtype to distinguish between them because it is an Applicative law that the Monad instance and the Applicative instance must agree
15:30:32 <c_wraith> athan: That's exactly the same thing you get with a value of type a and a function of type (a -> b)
15:30:51 <athan> hmmmm
15:30:57 <athan> that's really interesting...
15:31:07 <eitan> haasn: that's not the kind of example I'm trying to get at but I agree it's an example.
15:31:40 <athan> c_wraith: How can you tell that it will reduce?
15:31:41 <haasn> eitan: are you looking for cases where writing your own instance instead of using the derived functions has a non-semantic but practical benefit? (eg. performance)
15:31:42 <athan> ie
15:31:51 <eitan> haasn: yes, exactly
15:32:06 <c_wraith> athan: it's polymorphic.  It has to work with any function of type (a -> b) as an argument.
15:32:15 <c_wraith> athan: if it doesn't, it's not polymorphic
15:32:23 <athan> (forall r . ((a -> r) -> r)) (forall a, b . a -> b) =
15:32:33 <c_wraith> (or at least, not parametrically polymorphic)
15:32:38 <athan> hmm
15:32:43 <c_wraith> Oh!
15:32:50 <eitan> haasn: also, how is it decided which instance gets used?
15:33:02 <c_wraith> no, it's *not* (forall a b. a -> b)
15:33:08 <c_wraith> it's the same a
15:33:10 <athan> ahhh okay!
15:33:16 <athan> That's what I was wondering!
15:33:17 <athan> okay
15:33:19 <haasn> eitan: I can't think of any examples for your first question but that's mainly because I'm hardly familiar with the efficiency of Applicative instances; I don't understand your second question. What do you mean?
15:33:23 <athan> so then the a's reduce, right?
15:33:30 <athan> so it would then turn from
15:34:01 <athan> ((a -> (a -> b)) -> (a -> b))
15:34:15 <eitan> haasn: I mean if you define an Applicative instance and a Monad instance, then there are two Applicative instances defined, yours and the derivable one. How does Haskell pick which one is used?
15:34:20 <athan> erm... wait
15:34:25 <athan> I feel like I've got the logic off
15:34:31 <mightrs> book with which they can learn the concepts of functional programming?
15:34:38 <c_wraith> Uh.  It goes to ((a -> b) -> b) -> (a -> b) -> b
15:34:48 <athan> O.O
15:34:55 <c_wraith> athan: which is...  not very interesting.  it's just id. :)
15:34:58 <athan> so you applied (a -> b) to a?
15:35:04 <athan> hmmmm
15:35:15 <athan> in (forall r. (a -> r) -> r)
15:35:32 <c_wraith> Let's summon a value like that.
15:35:43 <eitan> haasn: I have one example for my question but I was hoping to find some more general treatment to build intuition about where monads fall down
15:35:44 <shachaf> I feel like explicit foralls would be good for teaching, even if they're often too verbose in actual code.
15:35:58 <athan> shachaf: I NEED THEM!!! lol
15:36:04 <haasn> eitan: Haskell does not automatically derive instances; it picks whichever one was declared - be that by an explicit instance declaration “instance Applicative T where ...” or a derived instance “data T = ... deriving Applicative”
15:36:29 <athan> c_wraith: I'm going to start using \/ as forall from now on, if that's okay
15:36:47 <erisco> what is the simplest alternative to 'readMaybe' which also returns the remaining string? ie it should greedily parse data off the front of the string
15:36:52 <haasn> eitan: you cannot declare both, as they would overlap - if you pull in two modules exporting both as orphan instances, I think you would get an ambiguous instance error
15:37:01 <c_wraith> erisco: reads?
15:37:18 <c_wraith> @let newtype Id a = Id { runId :: forall r. (a -> r) -> r) } -- let's see if this works.
15:37:18 <lambdabot>  Parse failed: TypeOperators is not enabled
15:37:20 <eitan> haasn: So then let me rephrase the question, if I define a Monad instance for a type constructor, then it won't automatically get the Monad m => Applicative m instance?
15:37:24 <athan> shachaf: Do forall statements affect the arity of type signatures? ie: the order of the arguments -> terms?
15:37:28 <haasn> eitan: no
15:37:36 <haasn> at least, not to my knowledge. Has this changed in GHC HEAD?
15:37:42 <erisco> c_wraith, oh thanks
15:37:56 <c_wraith> erisco: It may or may not actually work, depending on the Read instance
15:38:08 <eitan> haasn: thanks
15:38:17 <erisco> > reads "123abc" :: [(Int,String)]
15:38:18 <lambdabot>  [(123,"abc")]
15:38:19 <athan> c_wraith: Okay, let's just pretend it did :P
15:38:19 * hackagebot esqueleto 1.3.10 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.10 (FelipeLessa)
15:39:25 <athan> c_wraith: So runID returns a new type (possibly non-concrete)?
15:39:30 <haasn> eitan: Are you thinking of the DefaultSuperclassInstances proposal? https://ghc.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances
15:39:42 <athan> (just for my own clearity, I know it's not the purpose of this tutorial)
15:40:06 <c_wraith> athan: no, runId is the destructor.  It strips the newtype constructor away, returning a polymorphic function
15:40:17 <athan> hmm okay
15:40:51 <c_wraith> athan: to go the other direction, you'd have something like:  toId :: a -> Id a ; toId x = ....  you figure this out.  :)
15:41:02 <haasn> eitan: It describes an example of where there's a semantic difference between a derived-from-Monad Applicative and a manual Applicative instance, by the way
15:41:18 <haasn> eitan: https://ghc.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances#Theopt-outmechanism
15:41:20 <eitan> haasn: no, I'm just trying to understand if the `ap` function defined in Control.Monad automatically gives you an Applicative instance for any Monad, but the answer is no
15:41:20 <athan> c_wraith: toId x = ID x :P
15:41:28 <c_wraith> athan: that's a type error!
15:41:29 <haasn> eitan: it doesn't; no
15:41:33 <athan> o.O
15:41:37 <c_wraith> athan: try this stuff out in GHC.  :)
15:41:58 <haasn> There's nothing magic going on with `ap`, it's just a plain old function that happens to be a valid implementation of (<*>)
15:42:05 <ReinH> haasn: why not?
15:42:09 <ReinH> liftM is a valid fmap
15:42:18 <haasn> ReinH: yes, but it doesn't automatically give GHC an instance
15:42:23 <ReinH> oh, in that sense no
15:42:34 <athan> c_wraith: Would you have to give a type declaration to resolve r?
15:42:36 <athan> O.o
15:42:37 <ReinH> there is no instance Monad m => Applicative m
15:42:46 <ReinH> just like there is no instance Monad m => Functor m
15:42:50 <ReinH> which is why ap and liftM exist
15:42:56 <c_wraith> athan: nope.  You need to generate a polymorphic function
15:43:40 <ReinH> eitan: return, ap and liftM give you the behavior of an Applicative but not the instance.
15:44:14 <eitan> ReinH: Thanks.
15:44:24 <ReinH> if those instances were defined then you'd be stuck with them even if there was a more performant way to write fmap or <*>
15:44:35 <ReinH> (which there often is)
15:44:49 <athan> c_wraith: toId x = ID x :: forall a. ID a?
15:45:08 <athan> sheet
15:45:21 <c_wraith> athan: the Id constructor's argument has to be a function.  x isn't a function (in any way you can know about)
15:45:26 <eitan> ReinH: Is there a general intuition for when ap will be less performant than <*>?
15:45:43 <c_wraith> athan: all you know about x is that it's a value of type a.
15:45:48 <athan> oh!
15:45:50 <athan> wow...
15:45:52 <athan> hmm
15:46:11 <ReinH> eitan: well, ap requires two (>>=) and one return
15:47:08 <haasn> I think Stream could be an example; since the Monad instance requires diagonalization
15:47:18 <athan> c_wraith: Why would it need to be a function? That just feels weird to me, knowing that ID has only one parameter, and runId returns a polymorphic type
15:47:21 <haasn> while the Applicative instance just requires zipping
15:47:38 <c_wraith> athan: maybe it's easier to strip out the destructor.
15:47:44 <athan> c_wraith: But, here it is: toId x = ID x :: ID (a -> b)?
15:47:46 <eitan> ReinH: I have an example I'm working with in PureScript involving asynchronous functions where using ap cannot run the functions asynchronously
15:47:48 <ReinH> eitan: return and ap are used for a lot of the instances defined by Control.Applicative, so "often" might be an overstatement
15:48:01 <haasn> and the ‘ap’ implementation is, I think; basically turning every value into an infinite cartesian product-like 2D stream and then diagonalizing that to get the zip
15:48:13 <athan> And I'm guessing it has to be forall a b.
15:48:42 <haasn> eitan: what does ‘asynchronously’ mean?
15:48:57 <c_wraith> athan: http://lpaste.net/102461
15:49:06 <c_wraith> athan: there's a concrete file to start from
15:49:35 <athan> c_wraith: Thank you :)
15:49:52 <eitan> basically, they're running in a continuation monad, and I want them to run "in parallel" which won't work with the monadic ap
15:50:09 <athan> c_wraith: Can I ask why Rank-N types are needed?
15:50:36 <c_wraith> athan: I need to tell GHC what my use of forall there means.
15:50:45 <athan> ahh!
15:50:49 <athan> hmm!
15:50:52 <athan> very interesting!
15:50:57 <c_wraith> athan: though I guess you could get away with the PolymorphicComponents extension
15:51:11 <c_wraith> athan: RankNTypes is just a generalization of that to all contexts.
15:51:35 <athan> hmm
15:52:47 <c_wraith> athan: But that slightly simpler version strips out the syntactic noise of the destructor.  It makes it easier to see that what the Id constructor wraps is a function.
15:54:36 <athan> c_wraith: I'm confused :)
15:54:38 <athan> :(*
15:54:51 <c_wraith> athan: ok.  Help me figure out where you're confused.
15:54:52 <athan> c_wraith: What does the forall r. imply, exactly?
15:55:00 <athan> sorry haha
15:55:08 <c_wraith> that's a good start
15:55:15 <athan> specifically - why did you need an extesion?
15:55:22 <c_wraith> athan: are you comfortable with rank n types in general?
15:55:24 <athan> What would GHC normally understand that as?
15:55:32 <athan> not at all really?
15:55:34 <athan> really.
15:55:35 <athan> sorry
15:55:40 <schlegel_> It's all about where the forall takes place
15:55:43 <acowley> Has anyone ever had an issue with having too many type constraints on a definition?
15:55:56 <c_wraith> athan: normally, GHC would call it an error, because it uses a type variable not present on the left side of the =
15:56:12 <haasn> acowley: do you mean, so many constraints that GHC fails to accept it?
15:56:21 <haasn> or just so many constraints that it's not readable? :)
15:56:21 <schlegel_> athan: Look at http://www.haskell.org/haskellwiki/Rank-N_types
15:56:30 <acowley> haasn: Either fails, or it just leads to a performance collapse
15:56:37 <acowley> haasn: readability is for the birds
15:56:46 <acowley> (and constraint synonyms)
15:57:03 <schlegel_> athan: Oh sorry I think I jumped in at the wrong point
15:57:15 <c_wraith> athan: compare to:  newtype NotId r a = NotId ((a -> r) -> r)
15:57:25 <haasn> I've had performance collapse from gratuitous overuse of constraints and type algebra
15:57:42 <athan> c_wraith: So having a higher ranked type would allow you to control the quantification of the resulting type?
15:57:51 <c_wraith> athan: that's what you'd have to write without the forall - the type variable would have to be present on the left side of the =
15:57:52 <haasn> compiler-time performance, that is
15:58:06 <athan> c_wraith: And it would pair the types
15:58:24 <c_wraith> athan: higher-rank types allow you to indicate values must be polymorphic, more or less.
15:58:48 <athan> c_wraith: It would only give `notId` for explicit pairs of types?
15:58:59 <athan> hmm, okay
15:58:59 <c_wraith> athan: the thing is, with NotId, at any point you're creating a value of type NotId r a, you what both type r and a are
15:59:15 <athan> yeah!
15:59:17 <athan> okay
15:59:50 <c_wraith> athan: so with Id, when you're creating values of type Id, you have *no* idea what type r is.
16:00:11 <c_wraith> athan: the function it wraps has to work for *all* possible choices of r
16:00:26 <c_wraith> athan: (hence the terminology "forall")
16:00:34 <mjrosenb> do I need explicit synchronization between writeFile and runCommand (or vice-versa?)
16:00:59 <athan> c_wraith: Where normally, newtypes add explicit logic on top of known components
16:01:28 <athan> and with this technique, you can create a polymorphic mechanism out of one component
16:01:49 <athan> maybe relating the pure polymorphism to the explicit component type through the newtype?
16:01:51 <c_wraith> athan: Hmm.  Yes, that's a way to look at it.
16:02:02 <athan> yeah sorry for the different vocab haha
16:02:09 <athan> it's one of the only ways I can actually understand :S
16:02:32 <mjrosenb> I have a some code that works correctly on individual elements of a list, and works when I use a long-running program, but fail when I use a quick-running program on a list.
16:02:40 <c_wraith> athan: I'd say that a way to look at is that all types that appear in a newtype definition must be either concrete, or brought into scope on the left side of the =
16:02:50 <c_wraith> athan: Which is, I think, what you're saying
16:03:10 <athan> ahh!
16:03:12 <athan> yes!
16:03:42 <athan> okay...
16:03:44 <athan> hmm
16:03:51 <c_wraith> athan: so, enabling RankNTypes adds an addition way to bring type variables into scope - with a forall.
16:03:59 <mjrosenb> http://lpaste.net/102462 is my code for anyone that feels like my description was lacking.
16:04:06 <c_wraith> *additional
16:05:40 <athan> c_wraith: Do forall's work only on concrete types as well?
16:05:53 <athan> ie: r must still be concrete?
16:06:36 <c_wraith> athan: That's one's a bit subtle.
16:06:53 <c_wraith> athan: at any point you *use* the function, r must be concrete
16:07:25 <c_wraith> athan: however, until you use the function, r does not need to be concrete
16:07:27 <athan> ahh!
16:07:36 <athan> okay, cool beans
16:08:36 <athan> good god this is difficult to reason about lol
16:08:56 <c_wraith> athan: it's not very hard, once you understand it. :)
16:09:20 <c_wraith> athan: until you get there, ok, it's tricky.  But once you have a solid grasp, you won't find it takes too much thought to work with.
16:09:26 <heatsink> mjrosenb: What happens when it doesn't work?
16:09:48 <athan> c_wraith: I still don't understand why fromId (ID f) = f isn't right :/
16:09:48 <mjrosenb> heatsink: the first invocation of diff sees an empty file for /tmp/there
16:09:58 <athan> I feel like there's no way to "run" the ID function
16:10:05 <athan> to get _r_
16:10:15 <athan> but then again, r /= a in the type signature
16:10:18 <c_wraith> athan: do you have toId yet?  It's a bit easier.
16:10:27 <athan> fromId :: ID a -> a
16:10:33 <athan> no not yet :/
16:10:45 <athan> All I can think of is toId x = ID x lol
16:10:50 <schlegel_> To me it seems like the issue is with "forall r. (a -> r)"
16:10:55 <athan> yet that still doesn't work...
16:10:58 <schlegel_> How do I return -any- r?
16:11:15 <c_wraith> schlegel_: if that was the type, you wouldn't. :)
16:11:17 <schlegel_> The only instance common to all types is bottom
16:11:35 <schlegel_> I was looking at let newtype Id a = Id { runId :: forall r. (a -> r) -> r)
16:11:38 <mjrosenb> wait, does runCommand return control to haskell before the command has finished running?
16:11:40 <c_wraith> schlegel_: the actual type is importantly different. :)
16:11:57 <mjrosenb> for some interpretation of those words that actually matches what is going on.
16:12:11 <schlegel_> My issue is with the runId type
16:12:12 <c_wraith> schlegel_: yes.  forall r. (a -> r) would be impossible to write.  forall r. (a -> r) -> r  is possible
16:12:26 <heatsink> mjrosenb: Have you verified that 'there' is not an empty string?
16:12:28 <schlegel_> Ah
16:12:29 <hunt> guys when i cabal list ghc, version 7.803 comes up, but when i cabal install ghc i get an error that there is no package g=called ghc
16:12:41 <schlegel_> So you can fix the r with you call with (a -> b)
16:12:52 <mjrosenb> when I change the command from "diff..." to "sleep 3; diff...", my program *exits*, then diff starts spewing.
16:13:01 <mjrosenb> so the issue is definitely with runCommand
16:13:01 <schlegel_> Because (a -> b) -> b is the identity
16:13:05 <c_wraith> schlegel_: you're on the right path, yeah
16:13:20 <mjrosenb> heatsink: yes.
16:13:23 * hackagebot rng-utils 0.2 - RNG within an MVar for convenient concurrent use  http://hackage.haskell.org/package/rng-utils-0.2 (OzgunAtaman)
16:13:34 <c_wraith> athan: ok..  What's the type of the Id constructor?
16:14:04 <hunt> actually, how do i update my ghc? do i use brew?
16:14:05 <athan> umm
16:14:09 <mjrosenb> runCommand "diff  -U 8 -p /tmp/there /tmp/expected" >>= waitForProcess was the answer.
16:14:22 <heatsink> Ah, runCommand returns a ProcessHandle
16:14:26 <c_wraith> athan: you could cheat and just ask ghci about it. :)
16:14:34 <athan> c_wraith: a -> (forall r. (a -> r) -> r)?
16:14:39 <athan> hahaha
16:14:51 <athan> :t Id
16:14:52 <lambdabot>     Not in scope: data constructor `Id'
16:14:52 <lambdabot>     Perhaps you meant `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
16:15:03 <c_wraith> athan: your local ghci.  lambdabot doesn't know about the type. :P
16:15:14 <athan> I thought you newtyped it! :P
16:15:23 <c_wraith> athan: didn't work, for some reason.
16:16:02 <c_wraith> athan: anyway.  The important part here is that it's a constructor for the Id type.  Id :: something -> Id a
16:16:13 <c_wraith> athan: it's a constructor.  It *has* to have that form.
16:16:35 <c_wraith> athan: (well, it's a newtype constructor, so it only has one argument, so it must be of that form.  minor detail)
16:16:54 <athan> ahhhhhh okay!!
16:17:09 <athan> yeah, I can't help myself but convolute type / data constructors :S
16:17:43 <c_wraith> that's a serious problem.  The difference is why this all works!
16:18:28 <erisco> is there a way to tell ghc to choose an instance based on order of declaration?
16:18:31 <athan> @#$@#%%^
16:18:31 <lambdabot> Unknown command, try @list
16:18:36 <athan> I can't get it lol
16:18:40 <erisco> particularly I want to to pick a "most specific" instance
16:19:01 <eitan> it's unfortunate that type constructors and data constructors look so similar
16:19:31 <c_wraith> athan: Well, save that lpaste I provided a while back, and take a break.  Come back to it later.
16:19:52 <athan> Yeah :/
16:20:09 <athan> I have a feeling the implementations need `const` and `id`
16:20:13 <c_wraith> athan: don't be afraid to load it in ghci and just play with it.
16:20:18 <c_wraith> you're close
16:24:29 <erisco> is there some way to prioritise instances that ghc selects?
16:24:33 <erisco> I am trying to solve a disambiguity
16:25:09 <athan> c_wraith: I give
16:25:12 <athan> c_wraith: I can't do it
16:25:18 <athan> :(
16:26:01 <acowley> erisco: Probably not
16:26:12 <erisco> I want instance 7 to be used only when 5&6 are not applicable http://lpaste.net/102464
16:26:58 <athan> I think i got fromId!
16:27:11 <athan> c_wraith: fromId (Id f) = f id
16:27:55 <erisco> I guess I'll have to wrap the types up so that I do not have naked parameters such as 'a' and 'b'
16:28:25 * hackagebot csv-conduit 0.6.3 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.6.3 (OzgunAtaman)
16:28:26 <c_wraith> athan: that's correct.  But why does it work?
16:28:32 <athan> I have no idea!
16:28:34 <athan> lol
16:28:54 <athan> I feel like it's not obvious
16:29:37 <athan> that applying a universally quantified, unary function to the `a` parameter would satisfy the resoltuion of `r`
16:29:46 <mjrosenb> ok, so I have N lists of sorted, unique integers, and I want to find which number appears the most, I don't care what happens on ties.
16:30:08 <c_wraith> athan:  f :: (forall r. (a -> r) -> r).  id :: (a' -> a').    applying f to id  unifies all 3 type variables.
16:30:13 <mjrosenb> head . maximumBy (comparing length) . group . sort . concat $ allIndices is the code that I am using right now
16:30:28 <c_wraith> athan: so f's type becomes (a -> a) -> a
16:30:43 <c_wraith> athan: so what you have left is just a value of type a
16:30:50 <athan> don't you mean "id to f"??
16:30:54 <athan> O.O
16:30:55 <mjrosenb> > head . maximumBy (comparing length) . group . sort . concat $ [[1,2,3], [2,4,6], [2, 4, 8], [3,6,9]]
16:30:56 <lambdabot>  2
16:30:59 <c_wraith> athan: no, you apply functions to values.
16:31:11 <c_wraith> athan: in this case, f is the function being applied to the value id
16:31:11 <mjrosenb> any suggestions for making that less ugly?
16:31:23 <athan> what the...
16:31:26 <Kludgy> Hi all, I'm trying to modify a repa for output with Data.Array.Repa.IO.BMP.writeImageToBMP, but I'm missing something (probably obvious?): is there a common pattern for unfolding a lower dimension array (Array DIM2 Word32) into a higher dimension array (Array DIM3 Word8)?
16:32:02 <athan> c_wraith: How do you manage that idea?
16:32:09 <athan> that the function gets applied to values?
16:32:16 <athan> like `value function`?
16:32:44 <athan> or, does the parameter, from the type system's point of view
16:33:00 <athan> does the parameter's type appear as more of a "target" for f?
16:33:13 <triliyn> athan, c_wraith: I think it's just a terminological difference. Some people use "f is applied to x" to describe "f x", but some people say "x is applied to f"
16:33:33 <ReinH> mjrosenb: it's not super ugly, although it will error on []
16:33:41 <athan> triliyn: Ahh okay, thanks
16:34:00 <mjrosenb> ReinH: this code would have errored on [] much earlier :-p
16:34:28 <mjrosenb> ReinH: I feel like it is abusing goup
16:34:42 <Kludgy> .. never mind just answered my own question. traverse will enable this :)
16:34:42 <mjrosenb> then again, I don't think I've ever actually used it for anything else.
16:34:44 <ReinH> mjrosenb: seems like a pretty standard use of group
16:34:59 <ReinH> but you could certainly fold elements up into a frequency map instead
16:35:26 <athan> c_wraith: OH!!!
16:35:38 <mjrosenb> oh man, is there a frequency map in the standard library?
16:35:44 <ReinH> mjrosenb: no :)
16:35:47 <athan> c_wraith: Does universal quantification resolve terms under a common name?
16:35:58 <ReinH> mjrosenb: but there is in http://hackage.haskell.org/package/multiset-0.1/docs/Data-MultiSet.html#10
16:36:15 <athan> so (forall a b. a -> b) ~ (forall a. a -> a)?
16:37:05 <ReinH> mjrosenb: findMax . toOccurList . fromList . concat
16:37:12 <c_wraith> athan: no.  They're independent type variables
16:38:02 <Platz> hrm, so  "monad morphisms" in wadler's monad paper are actually monad transformers
16:38:23 <Platz> i take it
16:38:29 <athan> c_wraith: So what would cause the 3 to unify?
16:38:46 <triliyn> athan: it's the function application
16:39:36 <shachaf> Platz: You mistake it.
16:39:37 <athan> wouldn't it just be `forall r. ((a' -> a
16:39:42 <athan> shoot lemme retry
16:39:53 <shachaf> Assuming you're talking about http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
16:39:57 <athan> wouldn't it just be `forall r. ((a' -> a') -> r) -> r`, c_wraith?
16:40:08 <athan> for `f id`?
16:40:26 <athan> `forall r a'. ((a' -> a') -> r) -> r`?
16:40:37 <Platz> shachaf: yes, in the eval section
16:40:45 <shachaf> Yes.
16:40:48 <ReinH> :t liftIO
16:40:49 <lambdabot> MonadIO m => IO a -> m a
16:41:03 <shachaf> "A monad morphism from a monad M' to a monadM is a function h :: M' a -> M a that ..."
16:41:03 <Platz> coerce is lift
16:41:24 <shachaf> A monad transformer isn't a function.
16:41:35 <c_wraith> athan: the use of id as an argument to f is what makes them unify.
16:41:50 <shachaf> It's true that lift is a monad morphism.
16:41:55 <c_wraith> athan: id needs to match up with the argument to f
16:42:14 <athan> c_wraith: ???
16:42:39 <triliyn> athan: f :: (a -> r) -> r, id :: a -> a
16:42:56 <triliyn> When we try to unify a -> r (the type of f's argument) with a -> a, we find that they can be unified
16:43:01 <triliyn> And that r ~ a
16:43:04 <shachaf> Lots of things that arnen't lift are also monad morphisms, though.
16:43:07 <Platz> yeah, was just expecting to see something more transformer-ish in the types, like stacking the monads up you see sometimes
16:43:18 <Platz> but guess then it takes advantage that reader and state are so similiar
16:43:33 <ReinH> Platz: no stacking is required.
16:45:47 <ReinH> Platz: in Haskell terms a monad morphism is (Monad m, Monad n) => forall a. m a -> n a
16:46:04 <ReinH> Platz: m or n could be a monad transformer "stack" or not.
16:46:50 <eitan> natural transformation of monads
16:46:53 <Platz> is this defined in some library?
16:46:56 <shachaf> A monad morphism is a function :: forall a. M a -> N a, where M and N are monads.
16:47:01 <eitan> mmorph
16:47:09 <ReinH> @hackage mmorph
16:47:09 <lambdabot> http://hackage.haskell.org/package/mmorph
16:47:37 <Platz> interesting, well a first time for everything
16:47:46 <shachaf> (Monad m, Monad n) => ... is misleading syntax, but ReinH will just get annoyed again if I belabor it.
16:48:06 <ReinH> shachaf: I won't get annoyed. How is it misleading? What would be correct?
16:48:10 <shachaf> Anyway, it's not just any such function, it's such a function that satisfies some laws.
16:48:16 <erisco> undecidableinstances ftw
16:48:40 <ReinH> shachaf: I was getting to that but I couldn't decide whether to write them in do form or functor law form
16:48:57 <triliyn> ReinH: it seems to suggest that the function should be polymorphic in m and n
16:49:07 <ReinH> triliyn: ah
16:49:12 <eyebloom> Does anyone have any interest or experience with supercompilers?
16:49:20 <athan> WOAH
16:49:23 <athan> WOAH
16:49:25 <athan> WOAH
16:49:28 <athan> okay
16:49:37 <athan> thank you triliyn, c_wraith
16:49:44 <athan> I think I'm starting to understand
16:49:59 <Kron> good for you!
16:50:08 <athan> so x :: (a -> r), and not just a?
16:50:33 <athan> for some reason
16:50:37 <triliyn> No, x :: a
16:50:52 <athan> newtype Id a = (forall r. (a -> r) -> r)
16:51:02 <athan> oh what the hell
16:51:02 <triliyn> But in fromId, the argument isn't x, it's this Id f
16:51:06 <athan> I thought I was on to something lol
16:51:19 <Kron> enilghtenment snatched from your hands!
16:51:31 <athan> Kron: Then it wasn't true :P
16:51:46 <Kron> how philosophical o.o
16:51:59 <athan> I'm dead inside! :D
16:52:21 <athan> triliyn: f :: (a -> r)?
16:52:32 <triliyn> f :: forall r. (a -> r) -> r
16:52:45 <athan> oh hell
16:52:55 <triliyn> The same type that the Id constructor takes
16:53:06 <athan> I need to ponder about this. Thank you for your help
16:53:09 <athan> wait
16:53:15 <athan> I thought the constructor took a type :: a
16:53:22 <athan> ><!
16:53:30 <triliyn> Type type constructor takes a type a :: *
16:53:44 <triliyn> The data constructor takes a value f :: forall r. (a -> r) -> r
16:53:54 <athan> ahhhhh
16:54:07 <triliyn> If you find this confusing (I often do too), it might be helpful to rename the data constructor to MkId
16:54:33 <athan> I agree, thanks for the idea
16:56:08 <hakujin> what is the ideal way to concat bytestrings (basic framing protocol) for a socket? Network.Socket.ByteString.sendMany? Data.ByteString.Builder.hPutBuilder?
16:56:11 <Kron> I never name my constructors the same as my types
16:56:13 <triliyn> ("Type type constructor" should have been "The type constructor" above)
16:56:14 <Kron> super confusing to me
16:56:50 <athan> yeah it's definitely easy to cross your beams
16:56:54 <athan> hmm
16:57:12 <athan> so in toId a, a :: (forall r. ((x -> r) -> r))?
16:57:25 <athan> or do you have to come up with that?
16:57:43 <triliyn> No, a :: a
16:57:51 <athan> I just do not see how you could possibly write a function with that type signature
16:57:54 <triliyn> Remember the type of toId
16:58:00 <athan> a function that can return _any_ type
16:58:14 <triliyn> toId :: a -> Id a
16:58:31 <athan> yet, from Id's perspective
16:58:48 <triliyn> The key to Id is that you don't have to write a function that can return anything
16:58:51 <joelteon> athan: no, a function that can return the type of the return type of the function it's passed
16:58:57 <triliyn> You RECEIVE a function, and you don't know what it returns
16:59:04 <triliyn> But you have to return the same thing that it returns
16:59:05 <athan> newtype Id a = ..., a :: (forall r. (a -> r) -> r)
16:59:31 <athan> joelteon: Ahhh, that helps a lot
17:00:10 <athan> triliyn: Okay, that clears up a whole lot of gunk haha
17:02:27 <hakujin> or I suppose, what is the ideal way to concat values (UTF-8 Text, Word8, Word16, Word32) into their binary representations in order to stream to a socket? Data.Binary.Put? Data.ByteString.Builder? Or just convert each to a ByteString and push them all to the socket with Network.Socket.ByteString.sendMany?
17:03:04 <erisco> hm I just realized that Read is oriented around serialisation ... is there a similar utility to read primitives? for example, "bar" should parse as the string "bar" whereas in read only "\"bar\"" parses as "bar"
17:05:31 <erisco> well, I guess that is sort of silly because the input string would already be the desired string
17:05:37 <erisco> but nonetheless :P
17:06:51 <erisco> I've figured out something else. thanks
17:08:33 <athan> triliyn: How do you construct a function of type (forall r. (a -> r) -> r) out of an a?
17:09:13 <joelteon> :t f x = x
17:09:18 <joelteon> oh whoops
17:09:38 <johnw> I think: \f -> f a
17:10:00 <athan> oh woah
17:10:02 <johnw> or ($ a)
17:10:03 <athan> wat
17:10:11 <athan> johnw: That's what I was trying!
17:10:13 <athan> cool!!!
17:10:21 <johnw> it didn't work?
17:10:49 <athan> no, for some reason it wasn't
17:10:54 <athan> I was doing ($) a
17:11:06 <lispy> :t ($ a)
17:11:12 <merijn_> athan: That's something very different
17:11:12 <lambdabot> (Expr -> b) -> b
17:11:19 <lispy> oh heh, lambdabot scoping...
17:11:24 <athan> Mind = blown
17:11:40 <johnw> ($) a is the same as (a $), not ($ a)
17:12:04 <lispy> This is a case where I prefer the more verbose \f -> f a
17:12:09 <athan> merijn_: (&) a? :)
17:12:22 <athan> My goodness
17:12:27 <athan> i find it rediculous
17:12:35 <athan> that you can apply "afterward"
17:12:38 <athan> ...in advance
17:12:53 <lispy> :t ($ ?a)
17:13:00 <lambdabot> (?a::a) => (a -> b) -> b
17:13:11 <lispy> (that examples works by using implicit parameters)
17:13:24 <srhb> athan: It's totally not ridiculous, it's often quite nice. :)
17:13:47 <athan> srhb: The mechanics are astounding!!
17:14:16 <athan> lispy: ?a?
17:14:20 <athan> (?a)?
17:15:00 <athan> is that like a polymorphic-izer?
17:16:13 <lispy> athan: don't worry about it too much yet, but it uses a ghc extension where values can be implicitly defined
17:16:40 <lispy> athan: it's sometimes useful in examples in ghci/lambdabot
17:17:17 <athan> hmm, by binding them to constraints or something? (I don't even know what sense is anymore)
17:17:53 <athan> also, when lambdabot came back with "Expr -> ...", it did so because it wasn't able to find a specific expression associated with the term "a", right?
17:18:13 <lispy> It did that because it has single letter values in scope of type Expr
17:18:14 <lispy> :t a
17:18:15 <lambdabot> Expr
17:18:16 <athan> lispy: Sorry for the 1000 questions, I'm just kinda like... bleeding out my eyes
17:18:27 <lispy> It's meant for things like this:
17:18:36 <hexagoxel_> @src a
17:18:36 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:18:37 <lispy> > foldr (+) z [a,b,c,d]
17:18:38 <lambdabot>  a + (b + (c + (d + z)))
17:18:39 <athan> oooh okay
17:19:15 <lispy> Basically, some expressions can be evaluated symbolically using those names
17:19:27 <lispy> > sum [a,b,c,d,e]
17:19:28 <lambdabot>  0 + a + b + c + d + e
17:19:30 <athan> ahh okay!
17:19:43 <heatsink> > read $ show [(a, b), (c, d)]
17:19:44 <lambdabot>  *Exception: Prelude.read: no parse
17:19:51 <lispy> > scanl (+) 0 [a,b,c,d]
17:19:52 <lambdabot>  [0,0 + a,0 + a + b,0 + a + b + c,0 + a + b + c + d]
17:20:04 <athan> that's crazy lol
17:20:12 <heatsink> :t a
17:20:13 <lambdabot> Expr
17:20:15 <athan> it doesn't try and evaluate those symbols?
17:20:19 <heatsink> > read "a" :: Expr
17:20:20 <lambdabot>  No instance for (GHC.Read.Read Debug.SimpleReflect.Expr.Expr)
17:20:20 <lambdabot>    arising from a use of `Text.Read.read'
17:20:20 <lambdabot>  Possible fix:
17:20:20 <lambdabot>    add an instance declaration for
17:20:20 <lambdabot>    (GHC.Read.Read Debug.SimpleReflect.Expr.Expr)
17:20:37 <athan> instead of lazy evaluation of them... it just gives up? :P
17:20:59 <heatsink> No, it evaluates them as normal
17:21:25 <heatsink> There is a data structure something like Expr "a", which prints as a
17:21:45 <zRecursive> :t e
17:21:46 <lambdabot> Expr
17:22:11 <heatsink> :t α
17:22:12 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:22:40 <hexagoxel_> > fmap f (Just a)
17:22:41 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
17:22:41 <lambdabot>    arising from a use of `e_1'
17:22:41 <lambdabot>  The type variable `b0' is ambiguous
17:22:41 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
17:22:42 <lambdabot>  Note: there are several potential instances:
17:23:57 <pavonia> > let π = 3 in π
17:23:57 <lambdabot>  3
17:24:24 <Welkin> lambdabot can read unicode?
17:24:41 <pavonia> Yeah, I'm wondering why it complained before
17:24:59 <heatsink> > let π = 3 in π
17:25:00 <lambdabot>  3
17:25:09 <hpc> Welkin: S∃λ
17:25:09 <pavonia> :t let π = 3 in π
17:25:10 <lambdabot> lexical error at character '\128'
17:25:33 <Welkin> it can't print it though
17:26:38 <zRecursive> > fmap (\x -> x) (Just e)
17:26:39 <lambdabot>  Just e
17:26:44 <hexagoxel_> > (λ x → x + 1) 3
17:26:45 <lambdabot>  Pattern syntax in expression context: λ x -> x + 1
17:27:10 <hexagoxel_> aww
17:27:21 <pavonia> I think you can't use λ for \
17:27:56 <lispy> athan: I believe this is how the Expr stuff works: http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-1.html
17:28:42 <lispy> athan: Although, I think this is the specific library used: http://hackage.haskell.org/package/simple-reflect
17:29:01 <roboguy_> the letter lambda wasn't even Church's first choice actually
17:29:04 <lispy> so the first article explains how you might go about this and the second link is the implementation we actually use
17:30:14 <Welkin> all the cool greek symbols were already taken!
17:30:28 <roboguy_> he wanted a caret, I believe
17:30:31 <Welkin> he should have chosen a rare chinese character
17:30:42 <Welkin> the one with 46 lines
17:31:13 <Welkin> probably the coolest greek symbol is capital sigma
17:31:19 <Welkin> it's fun to write summations
17:31:32 <Welkin> capital omega is second
17:31:46 <drbean> 人
17:31:49 <heatsink> They have that "important" look to them
17:31:58 <Welkin> drbean, that is chinese for "person"
17:32:25 <heatsink> (ə ʇsnɾ) (1 + x <- x\) dɐɯɟ
17:32:26 <Welkin> renren
17:32:29 <Welkin> 人人
17:32:30 <athan> that would be cool
17:32:34 <athan> heatsink: hahaha
17:33:16 <drbean> 入
17:33:24 <heatsink> enter?
17:33:33 * hackagebot wai-app-file-cgi 2.0.4 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-2.0.4 (KazuYamamoto)
17:33:37 <athan> Why even need a descrete character?
17:34:01 <conal> Is there a convenient way to switch between installed GHC versions?
17:34:22 <shachaf> conal: You can use them both at once.
17:34:25 <hpc> there's a ghc-X.X.X for each installed version you have
17:34:27 <lispy> conal: there is that gnu tool, stash?
17:34:32 <shachaf> Or what do you mean? Change which version "ghc" runs?
17:34:49 <conal> lispy: thx. i couldn't remember the name.
17:34:58 <conal> shachaf: yes. "ghc", "ghc-pkg", etc
17:35:04 <lispy> conal: I might still have the wrong name :)
17:35:09 <shachaf> With cabal you can use cabal -w ghc-a.b.c ...
17:35:18 <conal> what's hsenv about? related?
17:35:19 <hpc> ditto for ghc-pkg, and yeah, use that cabal option
17:35:49 <conal> hpc: oh. just don't use the short-cut names. thx.
17:35:54 <zRecursive> cabal ... --with-ghc=xxx/ghc ?
17:36:01 <drbean> /sbin/alternatives ?
17:36:20 <hpc> i don't see the purpose of hsenv in the presence of those options and binaries
17:36:36 <hpc> might be some subtlety i am missing, or might be history
17:36:36 <lispy> conal: gnu stow?
17:36:43 <conal> zRecursive: thx.
17:36:46 <lispy> conal: http://www.gnu.org/software/stow/
17:36:52 <shachaf> I,I gnusto
17:36:53 <conal> lispy: thx (again).
17:37:25 <shachaf> You can't gnusto girgol, certainly.
17:38:16 <athan> ugh god, a snowboard company? Really?
17:39:26 <hpc> gnu stow? i hardly gnu her!
17:53:14 <Luke> anyone know how to list targets in Shake?
17:58:00 <athan> Why can't you pattern match against (->)?
17:58:27 <roboguy_> athan: isn't that invalid syntax?
17:58:31 <roboguy_> because of lambda, etc
17:59:03 <lispy> athan: Because functions are opaque
17:59:16 <athan> roboguy_: I'm sure it is, but isn't it still a constructor? (technically)?
17:59:27 <lispy> athan: In that regard they are like any data type where the data constructors are not exported
17:59:28 <athan> lispy: hmmmmmmmmmm
17:59:30 <roboguy_> athan: it's not a data constructor
17:59:38 <athan> ahh!
17:59:50 <roboguy_> it's a type constructor, but not a data constructor
18:00:17 <lispy> (and there is a recent ghc extension where you can case on types, closed type families, where it does make sense to case on (->))
18:01:36 <lispy> athan: you might want to think about why functions don't provide data constructors. What would we gain/lose?
18:01:57 <athan> Would applying data to a function be kinda like deconstruction? (kidding, I don't even know anymore)
18:01:59 <lispy> Would it be meaningful to compare them?
18:02:17 <athan> Yeah, see that's the wall I'm at now
18:02:22 <lispy> You can think of it as an elimination rule
18:02:26 <athan> hmmmm
18:02:39 <lispy> f :: a -> b, f a :: b
18:02:53 <lispy> that looks a lot like implication elimination
18:03:07 <athan> implication elimination? :(
18:03:19 <lispy> It's an idea from logic
18:03:40 <athan> hmm. I'm going to need to finish that logic/haskell/maths book :/
18:03:56 <roboguy_> athan: like "a implies b" is often written "a -> b"
18:03:57 <athan> This, however, was incredibly insightful
18:03:59 <athan> thank you :)
18:04:00 <roboguy_> and it is similar
18:04:07 <athan> Oh!
18:04:08 <athan> hmm!
18:04:20 <roboguy_> athan: with a function "a -> b" if you have an a, you can get a b
18:04:23 <roboguy_> likewise with "implies"
18:05:37 <athan> roboguy_: Whereas data construction / deconstruction is more about _how_ you imply?
18:06:26 <roboguy_> athan: I'm not really sure what you mean
18:06:35 <roboguy_> maybe
18:06:53 <athan> :P
18:08:50 <roboguy_> I think Either would be like logical disjunction and (,) would be like conjunction. also I think somehow forall sort of corresponds to negation, but I'm not totally sure about those things
18:09:06 <roboguy_> I'm more sure about the "->"/implication thing
18:09:24 <dolio> forall is like forall.
18:09:49 <roboguy_> oh, right. I think I was thinking about how it turns into exists when you move the parentheses
18:09:51 <Iceland_jack> roboguy_: a -> Void is like a negated
18:10:02 <roboguy_> Iceland_jack: hmm, good point
18:10:25 <athan> hmm
18:10:58 <roboguy_> Iceland_jack: wait, you can replace Void with forall and essentially get the same code though, right? like "a -> Void" ~= "forall b. a -> b"?
18:11:24 <roboguy_> maybe that should be "a -> (forall b. b)"
18:11:32 <Iceland_jack> yes, the latter version is right
18:12:09 <edwardk> roboguy_: yes, since you can pick b = Void. ;)
18:12:28 <roboguy_> right, and you have to account "forall"
18:12:39 <roboguy_> possibilities
18:12:43 <athan> how would I learn quantification arithmetic?
18:14:04 <roboguy_> athan: logical quantification or the haskell foralls (or both)?
18:14:07 <athan> Does anyone know of good resources?
18:14:15 <athan> both :)
18:14:22 <roboguy_> athan: "rank n types" is the key phrase for the haskell stuff
18:14:23 <athan> ideally, anyway
18:14:30 <athan> Ahhhh, okay
18:14:35 <Iceland_jack> it's not arithmetic
18:14:49 <bitemyapp> athan: keep in mind, there are threee different extensions tied to forall
18:14:57 <athan> Iceland_jack: What would you call it?
18:15:05 <athan> bitemyapp: !!!
18:15:15 <roboguy_> bitemyapp: as far as I know, they're all compatible with each other though (though they do different things)
18:15:40 <Iceland_jack> athan: quantification in logic and rank-N/scoped type variables/...
18:15:46 <athan> bitemyapp: could you list them?
18:16:23 <athan> Iceland_jack: Sorry, I'm not well versed
18:16:26 <roboguy_> RankNTypes, ExistentialQuantification, ScopedTypeVariables
18:16:26 <bitemyapp> athan: scoped type variables, rankN/rank2, existentials.
18:16:33 <athan> ahhhhhh
18:16:46 <bitemyapp> athan: and for the love of god, resist the urge re: existentials
18:16:47 <Iceland_jack> No need to apologize to me
18:17:04 <roboguy_> I don't even fully remember what ExistentialQuantification does. I mostly use the other two
18:17:17 <Iceland_jack> existentials is generalized by GADTs
18:17:21 <Iceland_jack> *are
18:17:26 <athan> Oh no way!
18:17:26 <roboguy_> that's probably why I never use it individually
18:17:38 <bitemyapp> https://ghc.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
18:17:48 <bitemyapp> "Existential quantification hides a type variable within a data constructor."
18:17:49 <roboguy_> athan: GADTs are just a combination of different extensions+some syntactic sugar
18:17:55 <athan> bitemyapp: Resist the urge...?
18:18:06 <athan> Woah!
18:18:26 <bitemyapp> athan: people from other language communities will sometimes get over-eager to use heterogenous collections when they shouldn't.
18:18:35 <athan> roboguy_: Ahh see I had no idea, I thought that ADT's were GADT's under-the-hood the whole time
18:18:37 <bitemyapp> jus' sayin' :)
18:18:48 <athan> hmm!
18:18:48 <roboguy_> athan: nope. it's closer to the other way around
18:18:52 <roboguy_> (plus extensions)
18:18:59 <athan> I see!
18:19:00 <bitemyapp> athan: it's easier to make the distinction when you bump into the limits of un-pragma'd  ADTs.
18:19:01 <athan> very nice
18:19:14 <bitemyapp> athan: in particular, I see people use GADTs to craft a finer negative space around what's not allowed for the types.
18:19:19 <athan> bitemyapp: I think I'm almost there
18:19:32 <athan> yeah
18:19:42 <athan> yeah exactly, you have more control over the possabilities
18:21:01 <athan> bitemyapp: Heterogenous collections?
18:21:08 <athan> How would existentials do so?
18:21:41 <bitemyapp> athan: when you have [a], it's "there an exists an 'a'"
18:22:20 <bitemyapp> athan: existential quantification makes the polymorphism prismatic within a single construction rather than all constructions
18:22:38 <bitemyapp> you still can't really do anything with a unless you add a typeclass qualification.
18:22:47 <bitemyapp> athan: note: doing this breaks monomorphization.
18:22:55 <athan> bitemyapp: So the garuntees of pure polymorphism degrade after the first use..?
18:23:05 <bitemyapp> uhm, no.
18:23:06 <athan> ahh!
18:23:10 <bitemyapp> polymorphism doesn't degrade
18:23:16 <athan> yeeah I thought I was getting silly
18:23:19 <bitemyapp> but typeclass dictionaries are no longer separate of the data types.
18:23:32 <athan> !
18:23:36 <Iceland_jack> !!
18:23:41 <bitemyapp> so instead of TC dicts being part of the universal "aether", they now have to be embedded in the objects to handle the polymorphism.
18:23:46 <bitemyapp> that's why it breaks monomorphization.
18:23:48 <roboguy_> http://www.haskell.org/haskellwiki/Heterogenous_collections#Existential_types
18:23:49 <erisco> > replicate '!'
18:23:49 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
18:23:49 <lambdabot>              with actual type `GHC.Types.Char'
18:23:52 <bitemyapp> So...please don't do that.
18:24:12 <athan> :)
18:24:31 <bitemyapp> it also makes the code harder to understand
18:24:37 <bitemyapp> needlessly.
18:24:48 <bitemyapp> Usually at the most you'll need a sum type inside the coll.
18:24:50 <athan> I believe it
18:24:52 <Iceland_jack> > replicate =<< ord $ '1'
18:24:53 <lambdabot>  "1111111111111111111111111111111111111111111111111"
18:25:07 <bitemyapp> you don't need total prismatic polymorphism unless you're exposing a library with weird needs.
18:25:57 <athan> bitemyapp: ...prismatic...?
18:26:13 <athan> sorry man
18:26:15 <bitemyapp> athan: infinite rainbow of types.
18:26:21 <athan> :D
18:26:23 <athan> much better
18:26:28 <roboguy_> I've never heard that term before, huh
18:26:41 <Iceland_jack> > replicate =<< ord $ '!'
18:26:43 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
18:26:44 <bitemyapp> that's because I made it up to describe the type squashing existential quantification performs.
18:26:59 <Iceland_jack> bitemyapp: 'running the gamut'!
18:27:03 <bitemyapp> it's kinda worse than the usual sum type determinism.
18:27:08 <bitemyapp> Iceland_jack: sorry?
18:27:10 <Iceland_jack> types tend to run gamuts
18:27:12 <bitemyapp> non-determinism
18:27:15 <Iceland_jack> Nothing :)
18:27:44 <roboguy_> do you guys know of a good example to explain the general idea of type-directed/hole-driven programming to non-haskell programmers?
18:28:08 <roboguy_> my teacher said I could talk about it some next class (he'd never heard of it, so he's interested), but no one is very familiar with haskell
18:28:16 <bitemyapp> roboguy_: type genie
18:28:23 <roboguy_> bitemyapp: djinn?
18:28:27 <bitemyapp> roboguy_: "I got you 80% of the way there, help me out"
18:28:32 <bitemyapp> roboguy_: your people won't know what djinn is.
18:28:34 <bitemyapp> roboguy_: type genie.
18:28:44 <bitemyapp> roboguy_: "quest giver"
18:28:45 <roboguy_> well, I was thinking something more concrete
18:28:55 <roboguy_> they do know about programming, just not haskell
18:28:57 <bitemyapp> roboguy_: "your quest is to fill this hole with something that goes from Int -> Int -> Int
18:29:07 <bitemyapp> goal-oriented programming :P
18:29:11 <bitemyapp> I dunno.
18:29:22 <bitemyapp> having a type-checking repl, let alone one with holes, was life-changing for me :)
18:29:27 <athan> "squre peg, square hole" programming
18:29:35 <bitemyapp> ^^ not bad.
18:29:37 <roboguy_> I was thinking going through the implementation of >>= for lists (nondeterministic bind) without mentioning monads, given join and fmap
18:29:41 <erisco> is it assumed the type is as general as possible?
18:29:42 <bitemyapp> I think a live demonstration might be best.
18:30:06 <bitemyapp> erisco: I've seen it monomorphize based on explicit type, but I have to assume so.
18:30:24 <bitemyapp> erisco: 7.8 doesn't have the restriction anymore, so inferring the most general type is more true than it was before.
18:30:52 <erisco> I am just curious how if you can rule out 'const' and 'flip const' as a solution for Int -> Int -> Int
18:31:07 <roboguy_> there are many solutions to Int -> Int -> Int because of the Ints
18:31:13 <Iceland_jack> You can't, it's not a good example
18:31:24 <Iceland_jack>     f _ _ = 0
18:31:27 <Iceland_jack>     f _ _ = 1
18:31:40 <roboguy_> polymorphic types are better examples
18:31:46 <Iceland_jack> yes
18:32:01 <erisco> Iceland_jack, well if you required that the type be as general as possible, then those would not suffice, because they are 'a -> b -> Int'
18:32:01 <roboguy_> I don't want to go overboard though, since like I said, not really any haskell experience
18:32:08 <bitemyapp> roboguy_: free theorems and all that :)
18:32:13 <roboguy_> but polymorphism is probably a must
18:32:21 <roboguy_> (to a degree anyway)
18:32:30 <Iceland_jack> roboguy_: Yes, use some basic list functions that everyone can understand
18:32:38 <Iceland_jack> maybe zipWith
18:32:51 <roboguy_> they are all familiar with Racket, by the way. my teacher is a Racket guy
18:33:00 <roboguy_> so lists would probably be good for that reason too
18:33:21 <Iceland_jack> 'here it wants [c], we have a function of type (a → b → c) and two elements of type 'a' and 'b', hmmm'
18:34:01 <erisco> const . const []
18:34:08 <erisco> you are often going to have a degenerate solution
18:34:25 <erisco> unless it is something like  (a -> b) -> a -> b  then at least you must use function application
18:34:39 <Iceland_jack> erisco: no doubt, it's still better than Int → Int → Int, roboguy_ said they didn't want to go overboard
18:34:53 <Iceland_jack> zipWith is a nice, concrete function
18:35:22 <jle`> is there a shortcut for \f -> return . f
18:35:26 <roboguy_> yeah zipWith is good. >>= specialized to lists might be a little too much
18:35:47 <c_wraith> :t flip concatMap
18:35:48 <lambdabot> [a] -> (a -> [b]) -> [b]
18:36:00 <c_wraith> look, I specialized (>>=)
18:36:03 <Iceland_jack> jle`: (return .)
18:36:15 <Iceland_jack> or fmap f
18:36:17 <erisco> Iceland_jack, actually I am trying to ask a question about how djinn finds solutions
18:36:17 <roboguy_> haha, yeah I know the definition
18:36:25 <Iceland_jack> *liftM
18:36:58 <roboguy_> maybe I'll start with zipWith. I don't want to take too much time either (although, the class is usually longer than we probably need)
18:37:24 <erisco> (a -> b -> c) -> [a] -> [b] -> [c]   may be zipWith or may be  const.const.const[]
18:37:34 <Iceland_jack> ignore fmap/liftM
18:38:13 <roboguy_> erisco: yeah, but that's clearly not a useful solution. the context here is using types to guide implementation and I think most people would know that const.const.const[] isn't a very useful implementation
18:38:14 <erisco> or may be   foo f xs ys = f <$> listToMaybe xs <*> listToMaybe ys
18:38:52 <roboguy_> erisco: wrong type
18:38:56 <erisco> is it? :(
18:39:02 <roboguy_> it gives a Maybe
18:39:05 <malvarez> Does anyone have a good paper on codata and correcursion?
18:39:10 <erisco> oh I need...
18:39:15 <erisco> @hoogle Maybe a -> [a]
18:39:15 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
18:39:15 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
18:39:15 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
18:39:27 <erisco> I need maybeToList afterwards
18:39:38 <athan> malvarez: Gabriel's blog post is really good
18:39:39 <roboguy_> yeah, that would work
18:39:43 <roboguy_> foo f xs ys = maybeToList $ f <$> listToMaybe xs <*> listToMaybe ys
18:40:06 <roboguy_> "wrong" behavior of course, but it would be the right type
18:40:08 <athan> malvarez: http://blog.sigfpe.com/2007/07/data-and-codata.html
18:40:16 <athan> malvarez: http://blog.sigfpe.com/2007/07/data-and-codata.html
18:40:21 <athan> malvarez: check out http://blog.sigfpe.com/2007/07/data-and-codata.html
18:40:25 <athan> gah
18:40:27 <athan> sorry
18:40:31 <malvarez> athan: got it, thanks!
18:40:33 <athan> didn't see the newlines ><
18:40:37 <erisco> roboguy_, I was listening to a discussion a while ago about djinn and I am still not certain what is actually being done
18:40:48 <erisco> roboguy_, or how it ever makes sense to automatically derive an implementation based on the type
18:40:48 <athan> erisco: djinn?
18:41:01 <erisco> is that not the name? :(
18:41:06 <roboguy_> @djinn a -> a
18:41:06 <lambdabot> f a = a
18:41:08 <geekosaur> @help djinn
18:41:08 <lambdabot> djinn <type>.
18:41:08 <lambdabot> Generates Haskell code from a type.
18:41:08 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
18:41:10 <roboguy_> athan: ^
18:41:21 <roboguy_> @djinn a -> b -> a
18:41:21 <lambdabot> f a _ = a
18:41:24 <athan> ahh!
18:41:35 <roboguy_> erisco: sometimes it's only possible to have a very small number of implementations given a polymorphic type
18:41:38 <roboguy_> that can be useful to realize
18:41:40 <geekosaur> basically, just from knowing a type, you can say some things about iut
18:41:47 <athan> Nice!!!
18:42:02 <athan> You can deduce it's properties that it should abide by?
18:42:08 <erisco> roboguy_, in the examples you gave the implementation is clearly unique ... but it seemed to extend beyond those cases
18:42:10 <geekosaur> if you know enough about it (true of many ADTs), you can automatically generate code from it.
18:42:16 <geekosaur> yes
18:42:22 <athan> is this somewhat like uniplate?
18:42:55 <geekosaur> uniplate is generics, which is kinda a different direction from this
18:43:03 <athan> & the other "scrap your boilerplate"-like projects, or does this cover much broader ideas?
18:43:17 <geekosaur> this is simplert
18:43:26 <athan> ahh okay
18:44:00 <geekosaur> in some sense, generics can be seen as using this stuff, but it does much more with it
18:44:57 <geekosaur> this is the simplest level: you can treat a type as a logical proposition, and from that proposition you can derive consequential logical propositions. it's not very powerful by itself.
18:45:30 <Twey> :t map
18:45:31 <lambdabot> (a -> b) -> [a] -> [b]
18:45:58 <geekosaur> but you can use the idea to build more complex stuff
18:46:16 <Twey> :t fmap
18:46:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:46:19 <roboguy_> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
18:46:19 <lambdabot> f a b c = a (\ d -> b d c)
18:46:35 <roboguy_> that's more complex
18:46:43 <roboguy_> I think that's >>= for Cont
18:47:25 <geekosaur> I recognized it, yes. it is still however simple deductive logic treating the type as a logical proposition
18:47:39 <erisco> unrelated question... class UnWrap a r | a -> r where unwrap :: a -> r;  instance UnWrap (Sum a) a where unwrap = getSum;   how do I provide the default instance 'unwrap = id' for types which there is no other instance for?
18:47:45 <geekosaur> (as I understand it, at least)
18:48:08 <erisco> basically I want to perform an operation on a type that may fail, and have a default on failure
18:48:12 <geekosaur> this can take ou to some surprising places, but there are lots of places that it's not powerful enough to reach
18:48:52 <Algebr> on a fresh install of debian, so I installed haskell + haskell platform from source....jesus christ that took forever.
18:49:11 <benbangert> there's an error on http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Argument_handling#Parsing_the_flags
18:49:22 <benbangert> it says, "First we need a couple of libraries" then it fails to list them, so the example shown doesn't ork
18:49:25 <benbangert> work
18:49:37 <benbangert> ie the 'set' function there is not around
18:50:38 <athan> lolwut? Djinn failed to install for me
18:51:24 <geekosaur> hm, also missing from the source
18:52:07 <benbangert> geekosaur: yea, I looked there first thinking maybe just a wiki formatting error
18:52:59 <athan> does djinn require a very recent version of gcc?
18:53:15 <hunt_> is Network.Socket the best option for haskell networking?
18:53:19 <geekosaur> if anything, it may break with sufficiently new ghc
18:53:28 <athan> no no no, gcc
18:53:32 <Twey> athan: Djinn is old and unmaintained
18:53:32 <geekosaur> oh
18:53:36 <athan> :/
18:53:38 <athan> ahh
18:53:39 <geekosaur> it's ancient, yes :/
18:53:44 <athan> blast
18:53:44 <hunt_> i know a lot of haskell platform stuff is not the best
18:54:11 <athan> There's this ruby version manager, rvm... is there something like that for haskell?
18:54:18 <athan> Where everything could be segregated?
18:54:19 <geekosaur> hunt_: depends. it's the lowest level network library that lies underneath everything else. unfortunately the best maintained higher level libraries are things like pipes and conduits that may, uh, stretch you a bit
18:54:32 <geekosaur> athan: hsenv
18:54:42 <athan> ahhh cool, thank you
18:54:58 <geekosaur> cabal sandbox can sandbox the user package db, hsenv sandboxes the whole thing
18:55:00 <athan> yeah, djinn's last version is from 2011
18:55:06 <hunt_> geekosaur: expand on stretch you a bit?
18:55:08 <athan> ahh!
18:55:50 <geekosaur> hunt_: they're rather complex compared to something like Network (which is old but serviceable if you don't care about e.g. high performance or exactly correct exception handling)
18:56:04 <roboguy_> athan: hmm, what's the error? it installed for me on ghc 7.8
18:56:29 <athan> gcc: error: unrecognized command line option `-Wl`
18:56:42 <erisco> oh OverlappingInstances can help me
18:56:45 <athan> and I've got gcc version 4.8.1 installed
18:57:02 <geekosaur> hm, something in there has a bug
18:57:03 <roboguy_> athan: oh, I used clang
18:57:12 <geekosaur> -Wl is not valid by itself
18:57:32 <geekosaur> it's -Wl,some_linker_option_here
18:57:34 <roboguy_> they removed -Wl altogether
18:57:38 <athan> yeah, I have a feeling I'll have to invent the universe to fix it
18:57:39 <roboguy_> I think
18:57:47 <athan> hmm
18:58:29 <geekosaur> (someone's been watching Cosmos...)
18:58:36 <roboguy_> I'm pretty sure it was deprecated and removed but I guess the djinn people didn't update it
18:59:10 <athan> hahaha
18:59:12 <athan> I wish
18:59:17 <athan> I really need to watch that series
18:59:28 <athan> :/
19:00:15 <erisco> ah but that conflicts with fundeps
19:00:15 <roboguy_> athan: it still worked for me when I went into the .cabal file for djinn and removed the -optl-Wl parts. I wonder if that would fix it
19:00:16 <erisco> shoot
19:00:45 <athan> roboguy_: Yeah... I think my system needs to get cleaned
19:00:54 <roboguy_> athan: ?
19:01:09 <athan> ...speaking of, does anyone have any tips or tricks to keeping your *nix systems organized?
19:01:31 <athan> roboguy_: I really just don't want to pull the repo and install it :/
19:01:40 <roboguy_> athan: I just used "cabal unpack djinn"
19:01:52 <roboguy_> that gives you a directory with the code
19:02:01 <erisco> it seems you cannot force the selection of one instance over another when it could be either...
19:02:08 <athan> I feel like I need to focus more on maintaining system sanity than getting djinn to work atm. I will definitely check it out once I have good practices under my belt
19:02:17 <athan> oh woah
19:02:17 <erisco> still complains about ambiguity... usually you use fundeps to resolve but then you cannot overlap
19:02:20 <athan> I had no idea haha
19:02:36 <athan> roboguy_: Thanks for the tip!
19:02:44 <roboguy_> athan: no problem!
19:03:07 <roboguy_> I've had to use it many times to patch something to work on a new version of ghc haha
19:03:32 <athan> haha I can only imagine
19:05:44 <erisco> as cute as this is... I wonder if code generation is simply better. what would the c++ programmer think? hmm
19:06:38 <malvarez> erisco: the real question is: what would lispers think?
19:06:48 <erisco> I don't know lisp =\
19:07:14 <malvarez> the big thing about lisp is that you can very easily evaluate arbitrary code at compile-time to do code generation
19:07:33 <erisco> oh, okay, then I can think about D then (I don't know much D but a little bit)
19:07:49 <erisco> this is the routing module I am working on http://lpaste.net/102468
19:08:11 <erisco> at the bottom you can see 'foo :: Static `Then` Var Int `Then` Static' which is basically describing the URL format by the type
19:08:42 <erisco> then 'parseFoo :: String -> Maybe (Int, String)' has the result type 'Int' because there is one int variable in the URL... and that is decided through type classing
19:09:01 <erisco> I can do similar to generate the reverse direction (given parameters, give the URL string)
19:09:17 <malvarez> erisco: lisp macros are basically D mixins with nicer syntax (i.e. none at all)
19:10:06 <erisco> which is very much how the meta-programmer would like to do things... but I am of the mindset that if you are going to have that much type deduction, you may as well do code generation
19:10:58 <erisco> I could just write a tool that reads in a file of routes, where a route is something like "/foo/$int/bar/" and it generates a Haskell module
19:12:40 <erisco> malvarez, you sound savvy on this topic. what say you? :)
19:13:10 <malvarez> erisco, I'm very, very biased towards code generation. I think it's both simpler and more general
19:13:10 <erisco> when should elaborate meta-programming give way to writing a separate compiler?
19:13:36 <malvarez> never! there have been entire new languages implemented as just sets of lisp macros
19:14:08 <erisco> but how is this different than writing a simple compiler?
19:14:42 <erisco> well, I do not know lisp, but if you know C++ a bit then you can quickly see how obscure things become
19:14:54 <erisco> even now in Haskell I am using instances as branching for types
19:14:57 <malvarez> well, yeah, but then again c++ was never intended for code generation
19:15:36 <erisco> and I have ugliness such as UnResult where I have to explicitly list all types which are not (Result a)
19:15:52 <erisco> because there is no way (I can find) to have a default instance
19:16:13 <erisco> unless I use OverlappingInstances but then types no longer infer
19:16:25 <erisco> and I have to through out fundeps
19:16:29 <erisco> throw out*
19:16:58 <malvarez> you probably need a simpler language for compile-time code generation to be a good solution
19:17:08 <mjo> Since when is hackage rejecting the tarballs created by "runghc Setup.hs sdist"
19:17:11 <erisco> you are suggesting template haskell?
19:17:16 <mjo> and whyyyyyyyyyyyyyyy
19:17:55 <malvarez> I wouldn't dare say 'suggesting', since I don't know much about it, but the TH approach seems more comfortable to me
19:19:31 <erisco> malvarez, well I suppose I should take a look at it
19:19:54 <erisco> though my idea for routing succeeded I do not like it :P
19:20:46 <erisco> malvarez, what about when your desired DSL is different than what is expressable in the language?
19:21:37 <malvarez> then you get a tradeoff, I guess: either make some kind of compiler or modify your DSL
19:21:37 <erisco> for example, I have html templates which contain $variables. I wrote a separate tool to parse these and generate a Haskell module
19:21:41 <Welkin> then write a new language to implement your DSL
19:21:59 <jle`> i don't think fmap is the same as (return .)
19:22:06 <erisco> the Haskell module creates the equivalent templates by calling into javascript functions such as document.createElement and appendChild and so on
19:22:16 <erisco> it also hooks up data binding with reactive-banana
19:22:30 <erisco> would you suggest I rather use meta-programming?
19:23:00 <malvarez> I'm not saying it would be a good idea, but it's definitely what I'd do
19:23:00 <athan> lol
19:23:04 <enthropy> erisco: use the overlapping instance, but don't use the fundep
19:23:34 <erisco> enthropy, well the pain is that if I take off the fundep then I do not benefit from type inference
19:23:45 * hackagebot direct-sqlite 2.3.12 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.12 (IreneKnapp)
19:23:52 <erisco> even though there is only one choice that I want to qualify as correct
19:23:58 <erisco> I cannot express this =\
19:24:07 <enthropy> this is the pattern http://okmij.org/ftp/Haskell/typecast.html#local-fd
19:24:25 <enthropy> but instead of  (TypeCast a b), do  (a ~ b)
19:25:38 <erisco> enthropy, hm I'll take a look thanks
19:25:57 <erisco> malvarez, you'd rather a DSL to write html code in the language?
19:26:15 <erisco> than simply writing HTML itself?
19:26:37 <enthropy> the advantage of the ~ is that you don't need to write the typeCast function
19:26:43 <johann> I've been trying to find out what does 'Just' do for days but achieved almost nothing. Could anyone give me some help?
19:26:54 <malvarez> erisco, i'm afraid so. but I tend to overengineer stuff a lot
19:27:05 <malvarez> ideally, your dsl would basically look like html anyways
19:27:15 <erisco> johann, do you have some code you are trying to make work?
19:27:20 <Cale> johann: Practically everything you need to know about what it does is stated in its type
19:27:38 <Cale> Just :: a -> Maybe a
19:27:47 <erisco> malvarez, *shrug* I guess we see differently then
19:28:05 <Cale> For any type a, it makes a value of type Maybe a from a value of type a
19:28:14 <Cale> For example,  Just 5 :: Maybe Integer
19:28:27 <roboguy_> johann: it might help to read the type outloud: it takes something that is an "a" and gives you a "Maybe a"
19:28:27 <Cale> Or  Just "hello" :: Maybe String
19:28:27 <johann> I did get this information, which is also puzzling me still.
19:28:40 <malvarez> erisco, while I understand that my way of doing things is too convoluted, I can't but find this kind of thing http://www.seaside.st/about/examples/counter incredibly elegant
19:29:02 <malvarez> 'this kind of thing' being a smalltalk web framework implemented as a dsl
19:29:03 <Cale> johann: Do you program in any other languages? Perhaps I could relate this to something you're more familiar with.
19:29:56 <Cale> johann: The Maybe type is used to indicate success or failure in producing a value, or the option as to whether or not a value is there.
19:30:00 <johann> Yes, C/C++ please.
19:30:47 <Cale> Okay, so you know in C how you often have to do this awkward thing where an operation which would produce an int would fail, and you have to invent a magic number (often -1) for representing the case where really there's no result?
19:31:24 <erisco> malvarez, I would not want to write a hundred or more lines of HTML in that way
19:31:35 <johann> Yes.
19:31:41 <Cale> Or, less awkwardly, if you're producing a pointer, you might produce a null pointer in some cases, because the operation was unsuccessful, or didn't need to produce a result in that case.
19:32:01 <Cale> In Haskell, we have a systematic answer to this problem, which is the Maybe datatype.
19:32:09 <johann> Yes
19:32:24 <malvarez> erisco, i can see why, but this offers the advantage that you can abstract html away
19:32:43 <erisco> malvarez, how is it "abstracted away"?
19:32:51 <Cale> A value of type  Maybe t  is either the value  Nothing  or it is of the form  Just x  where x has type t.
19:33:20 <erisco> malvarez, pretty sure I see "html" and "anchor" and assumption that anchors have some callback and some text to click as so on
19:33:38 <Cale> So, instead of producing an Int and using magic values like -1 to represent failure, you can let your caller know that you might fail by producing something of type Maybe Int
19:33:39 <malvarez> erisco, my bad, that was too vague. since in seaside html is generated by executing methods on an 'html' object, you can easily abstract over common patterns as functions
19:33:40 <jle`> is there a better way to write (return .) ?
19:33:51 * hackagebot htsn 0.0.8 - Parse XML files from The Sports Network feed.  http://hackage.haskell.org/package/htsn-0.0.8 (MichaelOrlitzky)
19:33:52 <Cale> and giving Nothing in the case where you would have produced -1 (or whatever)
19:33:56 <malvarez> erisco, i probably should have said 'abstract over html', not 'abstract html away'
19:34:06 <Cale> and Just x in the case where your successful result would have been x
19:34:15 <johann> I guess I've got what you mean about Maybe. But what is the difference between 'Just' and 'Mayge'?
19:34:27 <jle`> @hoogle (a -> b) -> a -> m b
19:34:28 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:34:28 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
19:34:28 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
19:34:40 <Cale> Just is a value constructor, it exists at runtime, and occurs on the left of the ::
19:34:42 <johann> They seem equal to each other.
19:34:59 <Cale> Maybe is a type constructor, it exists only at compile time, and occurs on the right of the ::
19:35:06 <Cale> Just 5 :: Maybe Integer
19:35:11 <malvarez> johann, it's a gross oversimplification, but you might think of Maybe as an abstract class and both Just and Nothing being constructors of concrete subclasses
19:35:14 <Cale> There's no such thing as Maybe 5
19:35:51 <erisco> malvarez, actually I do not think that is a very good translation
19:35:57 <Cale> :t Just
19:35:58 <lambdabot> a -> Maybe a
19:36:01 <xnil> johann: i believe Maybe is defined as
19:36:17 <Cale> data Maybe a = Nothing | Just a
19:36:19 <xnil> data Maybe a = Just a | Nothing
19:36:24 <xnil> yeah
19:36:25 <erisco> malvarez, I found that simply having one class and distinguishing constructor by an enum flag was better
19:36:59 <Cale> Or if you prefer the new style GADT syntax (which sometimes makes more sense to beginners),
19:37:11 <Cale> data Maybe a where
19:37:15 <Cale>   Nothing :: Maybe a
19:37:19 <Cale>   Just :: a -> Maybe a
19:37:40 <roboguy_> Cale: a couple months ago I would have found that statement kinda ironic haha
19:37:40 <xnil> i think the non-GADT syntax is more clear in this case
19:37:59 <malvarez> erisco, I'm not a c++ guy so I might be completely wrong, but with C++11 and lambdas wouldn't it be nicer to use inversion-of-control to provide an abstract interface with a 'fmap' method?
19:38:14 <Cale> Possibly. If you've ever seen BNF syntax for grammars, the non-GADT syntax is quite reminiscent of it
19:38:52 * hackagebot htsn-import 0.0.4 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.0.4 (MichaelOrlitzky)
19:39:14 <Cale> johann: C++'s Boost library has an Optional type which is I believe pretty much the same thing as Maybe
19:39:19 <erisco> malvarez, I used the Church encoding to do case analysis instead of virtual methods ... though if the language was C++ it might be okay
19:39:54 <erisco> malvarez, I was mainly worried about my Maybe class being subclassed by things other than Just and Nothing... I think in C++ you can prevent that? cannot remember
19:40:07 <Cale> johann: Though, I think they use the same name for the value constructor and the type constructor, because that's just how C++ is.
19:40:33 <roboguy_> Cale: you'd have to do something a little fancy otherwise, probably
19:40:51 <Cale> i.e. they write optional<int>(5) where we'd write Just 5
19:41:03 <Cale> and optional<int>() where we'd write Nothing
19:41:20 <roboguy_> erisco: you cannot
19:41:39 <johann> I guess I've got the idea of similarity between 'Just' and 'Maybe'. I am trying to distinguish them from each other now.
19:41:40 <erisco> oh, well in that case, I would not want to use inheritance =\
19:41:42 <roboguy_> that's a major point where the metaphor breaks down
19:41:55 <erisco> much rather the constructor enum
19:42:07 <roboguy_> erisco: well, haskell type classes have that aspect to them too (and sometimes that causes some issues, especially inference-wise)
19:42:36 <roboguy_> johann: "Maybe a" is a type and "Just ..." is a value
19:42:42 <MedDev> I'm trying to install one of my own libraries via cabal install but I'm getting a weird error. http://lpaste.net/102469 I've tried changing my .cabal files to require different versions of cabal, but that doesn't seem to work? Anyone have any ideas?
19:42:45 <roboguy_> johann: just like how "15" is a value and "int" is a type in C
19:42:53 <joneshf-laptop> edwardk, in semigroupoids, you've got an arrow diagramming Functor as a superclass of Foldable, how does that work?
19:42:57 <MedDev> mind you that running 'cabal build' works just fine
19:43:09 <edwardk> joneshf-laptop: it doesn't. its an error
19:43:30 <joneshf-laptop> ah
19:43:47 <Cale> johann: In Haskell, the constructors for the values of a particular type don't have to be named the same as the type itself.
19:43:49 <edwardk> feel free to figure out how to relay things out and patch =)
19:43:52 * hackagebot applicative-numbers 0.1.3 - Applicative-based numeric instances  http://hackage.haskell.org/package/applicative-numbers-0.1.3 (ConalElliott)
19:44:01 <joneshf-laptop> edwardk, pull request?
19:44:04 <joneshf-laptop> edwardk, heh, k
19:44:06 <malvarez> erisco, roboguy_, I didn't know myself until now, but apparently you can mark classes as final in c++11
19:44:10 <edwardk> joneshf-laptop: yeah
19:44:13 <malvarez> which prevents them from being inherited from
19:44:16 <roboguy_> malvarez: really? huh
19:44:30 <roboguy_> c++11 has lots of stuff I still need to figure out one of these days
19:44:33 <Cale> johann: You can have something like  data Employee = Boss { name :: String, salary :: Integer } | Peon { name :: String }
19:44:36 <edwardk> or send me your github user name and i can add you directly to the repo
19:44:38 <akurilin> Quick question: do any of the vim plugins out there automatically start the newline right below the curly brace in record syntax?
19:44:55 <Cale> johann: and then there's no data constructor called Employee, it's only the name of a type
19:45:10 <roboguy_> sometimes you have this in C++: the factory pattern
19:45:19 <roboguy_> (when types have different names than their constructors)
19:45:48 <erisco> malvarez, wrt meta-programming vs compiler, the best of both worlds that I have been thinking about is having both
19:46:01 <johann> Let me think for a while...
19:46:03 <erisco> malvarez, where you use the meta-programmed api as a compile target
19:46:04 <Cale> johann: and then Boss and Peon are data constructors which build values of type Employee
19:46:52 <erisco> malvarez, so if it fits your tool chain / build process / preferences you can use the idealised dsl + compiler, and if you just need to write something quick you can use the meta-programmed api
19:47:09 <malvarez> erisco, I'm going to agree on that, more choices are always a good thing
19:48:00 <erisco> malvarez, the benefit is that most of the hard parts of the compilation are removed to the meta-programming ... ideally it is a 1:1 correspondance
19:48:30 <johann> But when I type 'Just 5' in the interactive mode, I get 'Just 5' but not '5' as the return. Why?
19:48:38 <malvarez> erisco, one thing to consider, however, is that if the meta-programming api is very good, the added complexity of a compiler might not be worth it for that extra syntactic niceness
19:49:05 <Cale> johann: Because the Just is actually part of your value.
19:49:21 <roboguy_> johann: the type of your result is also Maybe Int, not Int
19:49:26 <roboguy_> (essentially)
19:49:47 <Cale> johann: Perhaps it would be good to look at a slightly more complicated data type
19:49:49 <malvarez> erisco, also, please completely ignore my encoding of Maybe as an abstract class, since I just discovered you can't have polymorphic methods within a parameterized class in C++
19:50:12 <Cale> Because Maybe is sufficiently simple that perhaps it's actually confusing why it looks the way it does :)
19:50:26 <akurilin> Quick question: is there a workaround for declaring multiple types in the same file that share the same accessor function? Or do most people just segregate them into separate files?
19:50:28 <erisco> malvarez, I'd tend to agree but for large sources (large html templates, or hundreds of routes) the small syntatic gains add up
19:50:30 <Cale> Let's adjust Maybe a little bit into a type for binary trees:
19:50:42 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
19:50:50 <akurilin> *function name
19:50:53 <Cale> compare this with:
19:51:00 <Cale> data Maybe a = Nothing | Just a
19:51:19 <erisco> malvarez, unless the meta-programmed api is perfect, in which case sure, just use it :)
19:51:22 <Cale> So, like Nothing, the Tip constructor has no arguments, it's just a newly defined plain value
19:51:51 <malvarez> erisco, true, but still I'm not entirely sure that I like losing the composability that templates give me
19:52:02 <Cale> and like Just, the Branch constructor takes an argument of type a, but it also takes two more arguments, values of type Tree a, to serve as the left and right subtrees
19:52:05 <MedDev> ah ok i have to nuke my .cabal-sandbox after updating the cabal library, a shame
19:52:16 <malvarez> erisco, in your compiler + meta-programming approach, how would one go about making a function that returns some HTML component with some values spliced into it?
19:52:16 <Cale> So, for instance, we can build a tree of this type like:
19:52:50 <erisco> malvarez, I am not completely sure what you mean
19:52:57 <Cale> Branch 3 (Branch 2 Tip (Branch 1 Tip Tip)) (Branch 6 (Branch 5 Tip Tip) Tip) :: Tree Integer
19:53:19 <erisco> malvarez, remember that the compiler's target is the same language the meta-programming is being done in, so the compiler-generated code and the meta-programmed stuff can work together
19:53:20 <Cale> (The type annotation is optional, I'm including it just to be clear)
19:53:28 <Cale> johann: Make sense?
19:53:53 * hackagebot higher-leveldb 0.1.0.3 - A rich monadic API for working with leveldb databases.  http://hackage.haskell.org/package/higher-leveldb-0.1.0.3 (jeremyjh)
19:53:57 <Cale> johann: So this represents a tree whose root node is labelled 3, with two subtrees, one of whose root nodes is labelled 2 and the other 6
19:53:59 <johann> Why isn't it defined as 'Maybe a = Just a', which I think is more concise?
19:54:05 <hunt> good Network.Socket tutorial?
19:54:12 <Cale> johann: Because that doesn't allow for the Nothing case.
19:54:51 <roboguy_> well, I wrote up an example of how Maybe could be represented in C++, but it might confuse even more. it's hard to represent sum types in C++ (types with multiple "paths", like Maybe's Just and Nothing)
19:54:56 <hunt> or good alternative to network.socket
19:55:01 --- mode: Cale set -o Cale
19:55:33 <malvarez> erisco, let's say you have a HTML DSL implemented as a compiler
19:55:36 <erisco> Cale, perhaps try explaining with lists instead of Maybe? ie listToMaybe and maybeToList ... C++ has typed lists
19:55:38 <Cale> johann: The whole point of Maybe is to allow for an additional "empty" case.
19:56:01 <Cale> johann: Yeah, Maybe a is similar to [a], except the lists have length at most 1 :)
19:56:02 <malvarez> erisco, how would you go about creating a function that takes a certain string and then returns a button with that string as label?
19:56:15 <Cale> Nothing corresponds to the case of an empty list
19:56:27 <Cale> and Just x corresponds to the case of a list with a single element which is x
19:56:29 <johann> Why not? Given Nothing is a possible result for Just.
19:56:34 <Cale> What?
19:56:43 <roboguy_> johann: Just is not a type
19:56:55 <Cale> Nothing and Just x are never equal.
19:56:59 <malvarez> 'Nothing' corresponds to the case of an empty list. Quotes for clarity
19:57:10 <Cale> The constructors of a data type are injective, if that means anything to you.
19:57:28 <roboguy_> johann: Maybe a is exactly like a 'list' that can only either have one element or zero elements
19:57:48 <erisco> malvarez, well that depends on how the compiled DSL is designed. in my case it is straight-forward
19:57:53 <Cale> (well, more than that, they have disjoint ranges)
19:58:15 <erisco> malvarez, I am creating data bindings to reactive-banana, so in my templates file I would write '<button>$buttonText</button>' and the compiler would emit a function
19:58:20 <Cale> johann: We can pattern match on a Maybe value to determine if it was Nothing, or Just x, after the fact.
19:58:35 <erisco> malvarez, that looked like  myTpl :: Behaviour Text -> Template
19:58:37 <roboguy_> playing around in ghci will probably help the most
19:58:45 <Cale> e.g.
19:58:46 <erisco> malvarez, (types not exact for simplicity)
19:59:01 <Cale> greeting :: Maybe String -> String
19:59:16 <Cale> greeting Nothing = "Uh, hello. I don't believe we've met."
19:59:18 <malvarez> erisco, that's nice, but how about more general stuff? like taking a list of 'components' and a list of 'labels' and rendering each component using each label?
19:59:18 <johann> Or why doesn't the definition take on another more concise form like 'Maybe a = Nothing | a'?
19:59:39 <roboguy_> johann: you need a constructor. that doesn't have constructor in the second case
19:59:43 <c_wraith> Oh, hey.  Typed holes apply for *all* unbound names in a file, not just ones that start with _
19:59:43 <Cale> greeting (Just name) = "Hello " ++ name ++ "! It's good to see you again."
19:59:52 <roboguy_> johann: there would be no way to tell if "5" was an Int or a Maybe Int also
20:00:07 <malvarez> erisco, perhaps my problem is that my only involvement with external DSL's for HTML generation is Java Server Faces, which is IMHO a scary, horrible thing
20:00:15 <Cale> johann: You need a data constructor to tell you that the value has type Maybe a and not a.
20:00:19 <erisco> malvarez, what is a component and a label?
20:00:40 <malvarez> erisco, a label is a String and a component is something of type String -> HTML
20:00:47 <Cale> johann: It's important for type inference, for one.
20:01:16 <erisco> malvarez, well I would zipWith ($) the labels and components together first...
20:01:35 <shachaf> It doesn't really make sense to write that. "Just x" is a different value from "x".
20:01:52 <shachaf> They have different types. "Just (Just x)" is yet another value.
20:01:55 <malvarez> erisco, you mean you'd do that in Haskell and then splice the resulting HTML in the template?
20:01:57 <erisco> malvarez, then I'd be left with [HTML], which I could insert into some surrounding template
20:02:09 <Cale> yes
20:02:09 <shachaf> "Nothing" and "Just Nothing" are two different values of type "Maybe (Maybe Int)"
20:02:13 <hunt> sorry, does anyone have experience with sockety haskell code? what did you use?
20:02:29 <malvarez> erisco, fair enough, that seems a nice solution. although I'm still convinced that it would be unnecessary for a 'nice enough' metaprogramming api
20:02:34 <erisco> malvarez, my templates contain no logic other than substitution of variables (no loops, no branching) .. all the composition is done in Haskell
20:02:41 <sabalaba> Hi, could anybody recommend a library for loading images (png, jpgs) for use with hmatrix? I just want to load them into memory and use hmatrix on them. Preferably something without OpenCV as a dep.
20:02:43 <malvarez> for arbitrarily advanced values of 'nice enough'
20:03:17 <erisco> malvarez, one might come up with a DSL for what I have (it is certainly possible) but it won't look like HTML code... and I know HTML and want to write HTML
20:03:22 <johann> Let me think for sometime over it. Thank you for your kindness help!
20:03:27 <erisco> I don't want to write vaguely-resembles HTML
20:03:40 <johann> Let me think for sometime over it. Thank you for your kindly help!
20:04:01 <johann> :quit
20:04:12 <Cale> > lookup 3 [(1,"hello"), (2,"there"), (3, "world")]
20:04:13 <lambdabot>  Just "world"
20:04:17 <Cale> > lookup 4 [(1,"hello"), (2,"there"), (3, "world")]
20:04:18 <lambdabot>  Nothing
20:04:24 <malvarez> erisco, fair enough. given that, then I completely agree with the compiler + dsl approach
20:04:31 <Cale> :t lookup 4 [(1,"hello"), (2,"there"), (3, "world")]
20:04:32 <lambdabot> Maybe [Char]
20:05:06 <bms1> sabalaba: Have you considered JuicyPixels?
20:05:16 <johann> :Quit
20:05:24 <erisco> malvarez, that might mean we're both insane then :P
20:05:29 <roboguy_> johann: try /quit
20:05:49 <roboguy_> hmm, or is it /part
20:05:52 <bms1> it loads images into the type Data.Vector.Storable, which I'm pretty sure is what hmatrix uses as well
20:05:52 <malvarez> erisco, this is #haskell, that's a given
20:06:02 <erisco> malvarez, good point =\
20:06:20 <johann> Thank you :)
20:06:38 <roboguy_> johann: no problem. you might want to look up "learn you a haskell" if you haven't already, btw
20:06:46 <roboguy_> aw, too late
20:06:53 <malvarez> you know, it would be awesome to write an IRC client in haskell as a DSL
20:07:00 <erisco> roboguy_, I think /quit is to disconnect from freenode?
20:07:03 <malvarez> so you can chat within GHCI and then type :quit to quit
20:07:09 <roboguy_> erisco: I always just Cmd-Q
20:07:25 <roboguy_> I usually want to leave everything at once though
20:07:27 <erisco> I click the 'x'... do you use Mac perchance?
20:07:33 <roboguy_> erisco: yeah
20:07:51 <roboguy_> I could click the x too, but I like keyboard stuff
20:08:04 <erisco> I get made fun of but I like using the mouse...
20:08:26 <roboguy_> if that's what you're most comfortable with, that's what you should use
20:08:44 <sabalaba> bms1: Ah, I hadn't thought of that! I'll give it a shot, Thanks!
20:09:03 <roboguy_> I doubt there would be a *huge* difference in anything meaningful if you switched. I just like that I feel faster, but I'm not even sure if that's accurate
20:09:36 <roboguy_> malvarez: combine that with the haskell shell and no one would ever have to leave ghci!
20:09:48 <erisco> oh my...
20:10:03 <roboguy_> I would get burned out so fast though
20:10:32 <hunt> seriously guys what should i use for networking!
20:10:49 <malvarez> a router seems like a good idea to me...
20:11:02 <roboguy_> hunt: I wish I could help you, but I haven't done any networking with haskell yet. I'd just type hackage socket into google and see what comes up
20:11:03 <hunt> get out of here malvarez we both know there are no haskell routers
20:11:22 <dwcook> hunt, network package is okay
20:11:22 <roboguy_> that's usually how I find libraries
20:11:38 <malvarez> hunt, I should hope not
20:11:39 <roboguy_> well, lens I found because everybody talks about it at all times
20:11:48 <roboguy_> ahha
20:12:01 <chrisw_> Can I use the continuation monad to chain together IO actions which are triggered by UI events such as mouse clicks?
20:13:01 <chrisw_> Say for example I want to print "hello, " then "world" on two successive clicks of a button
20:13:39 <dwcook> chrisw_, why use Cont for that?
20:14:26 <dwcook> (I'm not saying it's a bad idea, I'm actually curious why it occurred to you)
20:14:34 <malvarez> while not entirely the same, OCaml does routing http://www.cl.cam.ac.uk/~tgg22/metarouting/
20:14:57 <chrisw_> I don't know what to use, and I've been passing continuations "by hand" so to speak, so I figured this was a solved problem
20:15:00 <roboguy_> dwcook: well, continuations are kind of like callbacks and that seems like it might be useful for something like that
20:16:09 <dwcook> chrisw_, you might be able to get good suggestions posting a bit of how you're doing it now
20:16:55 <erisco> enthropy, I do not follow why the type is inferred as  (Num a, Num b, Product a (Vec b) c) => c
20:17:30 <erisco> enthropy, there is only one instance so I would expect 'c' to be inferred as 'Vec a'
20:19:28 <enthropy> instances usually don't get picked "because there is only one instance"
20:19:42 <enthropy> at least not without -XIncoherentInstances, which you aren't using
20:20:01 <erisco> hrm, then I am not understanding how instance selection works
20:20:39 <enthropy> they get picked based on whether the stuff to the right of the => in the instance decl matches what is to the left of the =>
20:20:41 <bms1> chrisw_: Have you considered using a "Wire" sort of abstraction like in Netwire. Essentially, a "Wire m a b" is a function "a -> m (b, Wire m a b)" - so the "b" is the result, and the "Wire m a b" is the next wire that you'll use
20:21:23 <chrisw_> dwcook, sure, let me briefly describe what my code is actually trying to do. I have successive windows which the user can go through by selecting information on each one, then hitting a keystroke to go to the next. I know the sequence of forms ahead of time, so my code looks something like: firstWindow (secondWindow (thirdWindow fourthWindow)), where each window takes as its first argument the next window to display.
20:21:46 <erisco> enthropy, hrm, okay
20:22:25 <erisco> enthropy, I am not sure how modifying the constraint on the instance changes the inference then
20:22:52 <enthropy> you make the instance head more general
20:22:53 <t4nk385> @pl (f @@ g) x y = f $ g x y
20:22:53 <lambdabot> (line 1, column 15):
20:22:53 <lambdabot> unexpected " "
20:22:53 <lambdabot> expecting operator
20:23:06 <t4nk385> @pl h f g x y = f $ g x y
20:23:06 <lambdabot> h = (.) . (.)
20:23:30 <enthropy> instance Product a (Vec b) (Vec b) -- matches    uses of  Product Int (Vec Double) (Vec Double)
20:23:53 <erisco> enthropy, but if 'c' does not match 'Vec a' then how does 'c' match 'Vec b'?
20:24:00 <enthropy> in fact, that instance also get selected if you know   Product t (Vec Double) (Vec Double)
20:24:38 <enthropy> erisco, that "(Num a, Num b, Product a (Vec b) c) => c" is just showing why you needed the fundep (or some alternative to it)
20:24:57 <codygman> #haskell, can you help my MySQL simple typeclass woes? I think it's because I don't really understand what "*" is doing, though it reminds me of aeson for some reason. Here is my code+error: http://lpaste.net/102470
20:25:56 <erisco> enthropy, it is saying that the RHS of the 'test' expression is that type, and it does not type check due to ambiguity ... that is how I understood it anyways
20:26:02 <enthropy> on the other hand maybe oleg should have   instance (Num a,Num b, a ~ b, c ~ Vec b)=> Product a (Vec b) c where
20:26:39 <gamegoblin> Type problems with my Stream type class, help appreciated: http://lpaste.net/102471
20:26:40 <enthropy> it can type check if you add that instance however
20:27:16 <geekosaur> codygman, I don't understand what that * is doing either
20:27:17 <erisco> sure but... I do not understand how this TypeCast thing changes anything
20:27:24 <geekosaur> it's not the normal *, certainly
20:27:37 <geekosaur> and if it's playing evil games with Num instances... I don't think I want to know
20:27:39 <erisco> sure it changes the instance head, but I do not understand why this modified instance head matches and the previous one did not
20:28:05 <enthropy> it makes the instance head more general
20:28:50 <erisco> yes I know but I do not know why it matches
20:29:34 <geekosaur> codygman, where did you get the * stuff there from?
20:30:33 <MedDev> Anyone know why my 'cabal install' would be tied to a certain version of the cabal library (1.18.1.1 and have 1.18.1.3 installed) when I use `cabal install` but not when i use `cabal build`?
20:30:36 <geekosaur> (given that it's not likely to be Num's *, I am reading it as an attempt at using ML type syntax...)
20:30:42 <erisco> enthropy, it is trying to match 'Product a (Vec b) c' ... first attempt we had an instance for 'Product a (Vec a) (Vec a)' ... so a match would be 'b = a; c = Vec a' but evidently GHC does not assume this
20:31:19 <geekosaur> why are you expecting it to assume anything?
20:31:38 <erisco> enthropy, with TypeCast, we change the instance to 'Product a (Vec b) (Vec b)' ... so a match would be 'c = Vec b' ... why is GHC willing to instantiate 'c' but not 'b'?
20:31:54 <erisco> ie why will it do 'c = Vec b' but not 'b = a; c = Vec a' ?
20:32:31 <enthropy> because you can write instances that don't have b ~ a
20:32:59 <enthropy>  instance Product Int (Vec Double) (Vec Double) -- perfectly good
20:33:30 <erisco> ah okay... it will do 'c = Vec a' because of the fundep
20:33:35 <enthropy> so it's not going to assume b ~ a, and ignore that perfectly good instance (which hasn't been written yet)
20:34:20 <enthropy> no it doesn't need a fundep for the c = Vec b
20:34:23 <enthropy> that's the point
20:34:31 <codygman> geekosaur: http://hackage.haskell.org/package/mysql-simple-0.2.2.4/docs/Database-MySQL-Simple-QueryResults.html
20:34:42 <erisco> enthropy, okay I do not understand why it would not need the fundep
20:34:44 <erisco> or what that is the point
20:34:53 <erisco> or why*
20:35:43 <enthropy> because the situation where you eventually write an `instance b (Vec b) (Vec b)' is not so bad because it neeeds -XOverlappingInstances
20:36:29 <geekosaur> aaaagh. that makes no sense
20:36:30 <erisco> mm I do not understand =\
20:36:38 <enthropy> geekosaur: me?
20:36:47 <geekosaur> no
20:36:55 <geekosaur> codygman's thing
20:37:07 <geekosaur> so now I am trying to figure out what insanity bos was up to
20:38:49 <erisco> enthropy, if the fundep a b -> c was not on Product, and the constraint on 'c' is inferred as 'Product a (Vec b) c' then why could I not have  instance Product a (Vec b) Int where ...
20:38:50 <enthropy> erisco: I would just use a "mechanical" translation    class C a b | a -> b; instance C Int Bool;    class C' a b; instance (b ~ Bool) => C Int b
20:38:52 <geekosaur> codygman, in the absence of whatever strangeness is going on there, you want Publisher a b, not Publisher $ a * b
20:39:02 <enthropy> erisco: I would just use a "mechanical" translation    class C a b | a -> b; instance C Int Bool;    class C' a b; instance (b ~ Bool) => C' Int b
20:39:07 <erisco> enthropy, alongside  instance Product a (Vec b) (Vec b) where ...
20:39:49 <enthropy> it's not allowed if you have the fundep
20:39:56 <erisco> I know
20:39:56 <geekosaur> this does look like some type theoretical thing is going on that you don't have loaded because the page doesn't say where it came from... (because "*" and it is a product type... which is why I keep trying to read it as ML)
20:40:18 <erisco> enthropy, I originally said along the lines of "oh, the reason GHC will match c = Vec b is because of the fundep"
20:40:23 <geekosaur> and I think you'll have to ask bos what he is up to there
20:40:37 <erisco> enthropy, and you said along the lines of "no, the fundep is unnecessary if you use the TypeCast solution"
20:40:50 <erisco> and I am now providing what I think is a counter-example
20:40:51 <codygman> geekosaur: Yeah, it was boggling my mind.
20:42:21 <erisco> if GHC assumed c = Vec b and there was no fundep a b -> c, then GHC would be ignoring possible instances ... just as you explained why GHC cannot assume b = a
20:42:52 <enthropy> geekosaur: the doc source code has ...  [va,vb] = User <$> a <*> b
20:43:06 <geekosaur> ...that makes more sense. bad markup
20:43:13 <codygman> enthropy: That makes sense, its like aeson.
20:43:18 <geekosaur> it's applicative
20:43:35 <codygman> which I kind of sort of understand ;)
20:44:01 * hackagebot purescript 0.4.17.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.17.1 (PhilFreeman)
20:44:07 <geekosaur> applicatives aren't that hard to understand. (unless something has hosed the markup while converting it to html, at least...)
20:44:09 <enthropy> erisco: it is allowed to ignore some possible instances with -XOverlappingInstances
20:44:45 <enthropy> I mean it is allowed to ignore instances that are possible only with -XOverlappingInstances
20:44:54 <geekosaur> and, come to think of it, that both makes sense and means that what I told you before was wrong
20:45:06 <geekosaur> so you want to use the applicative syntax, with the brackets
20:45:20 <geekosaur> Publisher <$> a <*> b
20:46:03 * Sgeo thinks an applicative do syntax would be a good idea
20:46:42 <geekosaur> ado was proposed at some point...
20:46:43 <erisco> enthropy, I have forgotten how this applies to my original problem :P
20:47:03 <erisco> enthropy, http://lpaste.net/102473 if you take a look at CombineResult (line 67)
20:47:28 <erisco> enthropy, ideally I want line 74 to read  instance CombineResult a b (a,b) where ...
20:48:06 <enthropy> no it'll look lke     instance ( (a,b) ~ c ) => CombineResult a b c
20:48:13 <erisco> enthropy, but I cannot make ghc happy about it... so I wrapped with the Result newtype and I later unwrap
20:49:39 <erisco> enthropy, interesting I'll try that...
20:53:40 <erisco> fascinating I'll have to think about what happened
20:53:59 <enthropy> it doesn't compose that nicely however
20:54:09 <erisco> what does not compose?
20:54:57 <enthropy> http://hackage.haskell.org/package/HList-0.3.4.1/docs/src/Data-HList-FakePrelude.html#HComp
20:55:15 <enthropy> has a type annotation that could possibly be unnecessary
20:55:31 <enthropy> the :: b
20:56:01 <erisco> ah right... I remember now
20:56:16 <enthropy> remember what?
20:56:30 <erisco> instance CombineResult a b (a,b) where ... worked as far as OverlappingInstances is concerned (it will only use it when there is not a more specific instance)
20:56:34 <erisco> but it made fundeps cry
20:56:50 <gamegoblin> geekosaur: still around?
20:57:01 <geekosaur> sort of
20:57:29 <gamegoblin> Any chance you could take a look at this? http://lpaste.net/102474
20:57:46 <gamegoblin> my Stream class refuses to compile due to some type error in my length function
20:58:26 <geekosaur> uncons can't possibly come up with a type for t because the only things that could provide it are part of the result
20:58:42 <gamegoblin> Mmmm so is there anything I can do?
20:58:48 <geekosaur> a fundep might fix it, since that way it can determine t from s
20:59:57 <geekosaur> class (Eq s, Monoid s) => Stream s t | s -> t where
21:00:01 <gamegoblin> mmmm yep
21:00:02 <gamegoblin> works
21:00:04 <gamegoblin> Thanks a lot
21:00:16 <gamegoblin> never used those before
21:00:39 <gamegoblin> been scratching my head to fix that one for an hour now
21:01:19 <joelteon> how do I allocate a zeroed chunk of memory?
21:01:25 <joelteon> do I have to foreign import memset?
21:01:30 <chance> pardon my noobieness, im still getting used to some of the quirks in haskell. I'm aware of the $ function, and im wondering, if i have an expression like "move (Pt (4,4)) (1,1)", can i use $ to remove the parens around (Pt (4,4))?
21:01:41 <erisco> enthropy, so when I make the instance ((a,b) ~ c) => CombineResult a b c  how does fundeps see this?
21:01:51 <gamegoblin> chance: not easily since it isn’t the rightmost term
21:02:10 <enthropy> it won't because you're supposed to remove the fundep
21:02:30 <chance> right. i mean i know how to use $ in some cases, but in others where i see parens, i *feel* like they can be removed, but am not sure how in many cases.
21:02:33 <erisco> enthropy, it seems odd that 'a' and 'b' can be any type, but fundeps takes no issue with that
21:02:59 <gamegoblin> joelteon: wouldn’t you want calloc?
21:02:59 <enthropy> which ghc do you use?
21:03:20 <chance> that's okay though.
21:03:27 <joelteon> gamegoblin: sure i guess
21:03:31 <chance> guess i'll deal with the ugly parens
21:03:40 <erisco> enthropy, 7.6
21:03:47 <gamegoblin> chance: When I first started I wanted to use $ all over the place, but parens aren’t so bad now :)
21:03:48 <enthropy> 7.8 is more serious about rejecting instances that possibly violate the fundeps
21:04:08 <erisco> enthropy, you are saying that fundeps should have complained?
21:04:17 <chance> gamegoblin: yeah thats how i feel basically
21:04:51 <erisco> if I remove the fundep it asks me to enable incoherentinstances
21:05:26 <jle`> why can't i seem to write a timeout for a long pure computation?
21:05:33 <erisco> I was thinking that fundep sees 'a b c' uniquely from '(Maybe a) b c' for example
21:05:38 <jle`> it seems like the pure computation hugs the runtime so strongly
21:05:43 <chance> gamegoblin: thanks for the quick reply, appreciate it!
21:06:19 <gamegoblin> chance: this IRC channel is the best place to get help ever. I am not a super noob anymore, but still an intermediate noob and the folks here are great.
21:08:08 <chance> yeah, im aware, thats why i came here. I was learning haskell like 6 months ago, and trailed off after needing to do other things. but now im taking a class where we use haskell so im back at it
21:08:41 <erisco> enthropy, the extension must be designed to assume the most specific instance when resolving the dependency...
21:08:51 <gamegoblin> I started and stopped using haskell like 3 times before it really clicked with me
21:09:07 <erisco> "intermediate noob"
21:09:13 <erisco> one day you'll graduate and be a full noob
21:09:16 <erisco> like me!
21:09:26 <chance> lol
21:09:56 <enthropy> you can try other things like    instance (a' ~ a, b' ~ b) => CombineResult a b (a', b')
21:10:04 <gamegoblin> I finally grok monads
21:10:09 <gamegoblin> still not all the way there with applicative voodoo
21:10:24 <chance> i wonder if my proff hangs in here..he has no IRC contacts on haskellers or his website.
21:10:34 <chance> martin: ping
21:10:59 <Ralith> if I was a CS professor who gave out haskell assignments, I would hang out here and yell at people
21:11:12 <chance> lol
21:11:14 <Ralith> (when they asked someone to do their homework for them)
21:11:40 <chance> i hate when people ask for 'help' -> DO_HW_FOR_ME
21:12:31 <erisco> enthropy, hrm using that I get an error I have not yet seen
21:12:38 <chance> gotta say one of my favorite parts so far about haskell is just how simple things really are when you look at the code.
21:12:46 <enthropy> @ghc
21:12:46 <lambdabot> Can't splice the polymorphic local variable
21:12:54 <erisco> "Couldn't match type Int with (a', b') when using functional dependencies to combine ..."
21:13:02 <gamegoblin> I wish I got homework in Haskell
21:13:10 <enthropy> you're supposed to get rid of the fundep
21:13:30 <erisco> oh right
21:13:48 <chance> when learning haskell i used a lot of the class exercises for practice, now im coming back to those same exercises and im like "hey this looks familiar"
21:13:49 <erisco> well then I get an ambiguous type error
21:13:57 <erisco> [overlap ok] whatever that means
21:14:09 <erisco> I am not precisely sure of the machinery going on anymore
21:15:31 <erisco> I am worried about keeping the fundep if it is actually erroneous that it happened to work
21:15:57 <enthropy> chance: Pt (4,4) `move` (1,1)
21:16:27 <chance> enthropy: ooh, didnt think of that.
21:16:44 <chance> is enthropy++ too unpure?
21:16:52 <erisco> chance, I dunno I would not consider this class instance stuff simple
21:17:19 <Algebr> I'm not understanding the appeal of newtype, it just like doing data but with just one value constructor...so what would I want to do newtype?
21:17:34 <erisco> Algebr, it has no overhead at runtime
21:17:56 <erisco> there are some differences outside that... others could explain because I don't know
21:17:57 <chance> what do you mean? idk, when i look at haskell code, if i understand the concepts being used (most of which i can grasp at this point), its way easier to comprehend than any python/imperative code i see daily
21:17:59 <erisco> undefined or bottom or something
21:18:33 <erisco> chance, well I guess if you speak comparatively then Haskell may be simpler
21:19:35 <erisco> I'd really like to just bang out a function rather than trying to cobble together nonsense with these instance extensions
21:20:09 <erisco> all I am doing is appending tuples and tossing away units
21:20:22 <erisco> stupidly simple to write if I was writing a function
21:20:33 <erisco> highly confusing to write if I am trying to use class instances
21:21:49 <chance> do you mean type classes?
21:21:56 <erisco> () ++ b = b; a ++ () = b; (a,b) ++ c = (a,b,c); a ++ (b,c) = (a,b,c) and so on
21:22:02 <erisco> chance, yes type classes
21:22:10 <erisco> but the branching is done by instancing the class
21:22:12 <chance> havent heard of the term class instances
21:22:13 <erisco> and various constraints and such
21:22:34 <erisco> stuff that begins with the keyword 'instance'
21:23:18 <chance> ah. well yeah.
21:23:39 <erisco> suppose I should look at template haskell now and see what it is about
21:23:40 <enthropy> you're doing this because it's suppsed to be extensible somehow?
21:23:59 <erisco> enthropy, extensible? not sure what you mean
21:24:06 * hackagebot iteratee 0.8.4.5 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.4.5 (JohnLato)
21:24:34 <enthropy> as in you want to support additional equations that define your function
21:24:41 <enthropy> provided by people writing instances
21:24:44 <erisco> if you are asking if it is some abstraction such as Monad or Applicative then no ... it is merely meta-programming
21:25:28 <erisco> given tuple types 'a' and 'b' (including unit) I want to return the tuple 'c' which is the concatentation
21:25:42 <erisco> if you assume concatentation is the obvious thing
21:25:42 <chance> i mean class instances aren't any worse than most other options in a lot of languages ive used
21:26:33 <chance> better than duck typing and inheritance to fullfil an interface..
21:26:52 <erisco> why do I want to do this? because it provides a better interface (for my usage) than nested tuples and tuples with units in them
21:27:25 <gamegoblin> type classes give you the best of duck typing and interfaces, plus some more
21:27:45 <erisco> sure, I'm not really using them for that though :P
21:27:50 <chance> gamegoblin: totally. i just wish Go did a better job of interfaces in the polymorphic aspect.. :\
21:27:52 <erisco> mistake #1 it seems
21:28:02 <Algebr> Speaking of typeclasses...why does code compile even if you don't implement all the methods of a class?
21:28:11 <chance> <3 Go, but everytime i want to do something fancy, i wish it was more like haskell
21:28:17 <erisco> Algebr, they must have default definitions
21:28:24 <enthropy> Algebr: unfortunately it does
21:28:32 <erisco> or it does... what do I know
21:28:46 <gamegoblin> Go and Haskell are the two languages I have used that that seem like they were designed by very smart people
21:28:50 <enthropy> a source of unpleasant bugs
21:29:02 <startling> Algebr: historical reasons
21:29:14 <Algebr> Yea, just calling an unimplemented method just gives an exception....would rather it just not compile at all.
21:29:26 <chance> is that due to the compiler not being smart enough to be sure it does fullfill all methods?
21:29:27 <enthropy> you can enable some more warnings
21:29:49 <enthropy> -fwarn-missing-methods
21:29:51 <chance> or is it just the preferred default in the compiler
21:30:01 <chance> ah, well i learned a new compiler option i need to use.
21:30:03 <startling> chance: no, it's just how haskell was specified and no one has bothered to change it
21:30:05 <gamegoblin> chance: It’s because it used to not be enforced and now we can’t enforce it without breaking old stuff
21:30:33 <startling> I think default methods were hard to do in the past, and loosening that made them doable.
21:30:36 <chance> i see. well im glad to know. another reason I love haskell. 90% of the time if it compiles im pretty sure it'll work.
21:30:50 <startling> Now that we have real default methods, it probably ought to be changed
21:30:51 <gamegoblin> It’s the 10% that kills your brain ;)
21:31:00 <chance> yeah..
21:31:11 <Algebr> I'm curious, it seems that exceptions are basically a deathknell, can a program not "catch" the exception?
21:31:14 <gamegoblin> I’m currently hunting down a 10% right now
21:31:16 <chance> spent way too long debugging 10% earlier today.
21:31:33 <erisco> Algebr, look at Control.Exception (yes you can if you mean IO exceptions)
21:31:48 <startling> Algebr: only in IO
21:32:06 <startling> (but there are some hacks that let you do it outside of IO if you really need to)
21:32:35 <chance> anyways, time to take a break and play battlefield. thanks guys
21:32:38 <startling> in general you should prefer rewriting code to not throw exceptions, but sometimes that's not possible.
21:32:46 <startling> (i.e., if it's other peoples' code)
21:33:04 <Algebr> So there isn't something analgous to try: head [] except: putStrLn "Empty list, oops"
21:33:24 <ReinH> Algebr: nope
21:33:27 <erisco> that is not an exception I am fairly sure
21:33:29 <erisco> that is an "error"
21:33:31 <startling> Algebr: there is in IO
21:33:43 <startling> hm, maybe I'm wrong
21:34:17 <ReinH> bottom subsumes non-termination
21:34:28 <ReinH> so any function that caught _|_ would have to solve the halting problem
21:34:52 <erisco> simple
21:34:52 <ReinH> Algebr: that is not an exception
21:35:11 <ReinH> head and other partial functions are "dangerous" for this reason
21:35:11 <Algebr> ReinH: Sounds like an expceiton, head []
21:35:13 <Algebr> *** Exception: Prelude.head: empty list
21:35:16 <enthropy> @hackage spoon
21:35:17 <lambdabot> http://hackage.haskell.org/package/spoon
21:35:39 <jle`> Algebr: it's only an expression if you try to evaluate it
21:35:41 <jle`> er
21:35:43 <jle`> an exception
21:36:02 <jle`> spoon is a neat package that forces evaluation using unsafePerformIO
21:36:07 <erisco> ghci is doing putStrLn (show x) afaik
21:36:36 <jle`> you have to sort of think about how expressions in Haskell work
21:36:41 <jle`> and how evaluating and executing works
21:37:01 <Algebr> jle`: that they aren't evaluated until actually needed, right
21:37:07 <ReinH> It isn't an exception that can be caught
21:37:08 <jle`> it's not just that
21:37:13 <ReinH> It's probably a mistake for GHC to call it an exception
21:37:15 <jle`> it's a fundamental difference
21:37:17 <ReinH> > catch (error "bla") (\msg -> putStrLn $ "caught " ++ show msg)
21:37:18 <lambdabot>  No instance for (GHC.Exception.Exception a0)
21:37:18 <lambdabot>    arising from a use of `Control.Exception.Base.catch'
21:37:18 <lambdabot>  The type variable `a0' is ambiguous
21:37:18 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:37:18 <lambdabot>  Note: there are several potential instances:
21:37:24 <startling> Prelude Control.Exception> catch (error "oops") $ ((const $ putStrLn ":)") :: SomeException -> IO ())
21:37:27 <startling> :)
21:37:44 <ReinH> startling: er.
21:37:46 <jle`> for example, your try head [] putStrLn example doesn't make sense
21:37:51 <jle`> because what would that expression return?
21:38:02 <jle`> IO ()?
21:38:05 <jle`> IO a ?
21:38:19 <jle`> IO (Either () a) ?
21:38:34 <startling> anyway, no, 'error' isn't actually _|_
21:38:36 <erisco> > catch (error "bla") (\(msg :: SomeException) -> putStrLn $ "caught " ++ show msg)
21:38:37 <lambdabot>  <IO ()>
21:38:56 <jle`> :t catch
21:38:57 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
21:39:07 <jle`> see, in catch, you have to have an IO a
21:39:11 <jle`> you can't just use head []
21:39:24 <jle`> and you can't even do (return (head []))
21:39:37 <jle`> because that just returns a thunk
21:39:39 <startling> :t \x h -> catch (return x) h
21:39:40 <lambdabot> Exception e => a -> (e -> IO a) -> IO a
21:39:57 <startling> :t \x h -> catch (return x >> return ()) h
21:39:58 <lambdabot> Exception e => a -> (e -> IO ()) -> IO ()
21:40:03 <startling> jle`, ^
21:40:03 <erisco> you'd have to force error "bla" to see if it worked
21:40:09 <erisco> not sure how one does that
21:40:15 <ReinH> startling: what do you mean error isn't bottom?
21:40:24 <startling> ReinH, it's not actually non-termination.
21:41:47 <jle`> startling: that doesn't error on my ghci :/
21:42:18 <startling> jle`: which doesn't?
21:42:25 <jle`> your return x >> return ()
21:42:28 <jle`> inside a catch
21:42:33 <startling> oh, right
21:42:43 <startling> > catch (head [] `seq` return ()) (\(a :: SomeException) -> putStrLn "hi")
21:42:44 <startling> hi
21:42:44 <lambdabot>  <IO ()>
21:43:03 <startling> it won't work in general, but it works for head [].
21:43:27 <jle`> yeah, you'd ahve to deepseq
21:43:28 <startling> Algebr: in conclusion, don't use errors.
21:43:43 <startling> Algebr, especially if you want people in #haskell to be able to tell what your code does. :)
21:43:45 <jle`> Algebr: hopefully if you think about it more, you can see that errors occupy a weird space
21:43:55 <jle`> it doesn't make sense to use errors in many ways that you are used to seeing them
21:44:02 <jle`> and it's not because of lazy evaluation, necessarily
21:44:14 <jle`> you sort of have to think about them differently than in other languages
21:44:30 <startling> Using the primitive exceptions is silly in haskell because there are first-class notions of exceptions.
21:45:03 <startling> e.g. Maybe, Either e, MonadError e m => m, ...
21:45:39 <jle`> there are certain cases where errors are somewhat idiomatic to use, and as you might guess, it is with IO actions
21:45:45 <jle`> like reading a file that doesn't exist
21:46:01 <jle`> or checking if sig interrupt was sent
21:46:26 <jle`> but for pure code...
21:46:33 <jle`> yeah, errors don't really make too much sense at all
21:46:43 <jle`> and the more yout hink about them the less they make sense
21:46:51 <ReinH> startling: oh right, Control.Exception.catch cheats
21:47:01 <jle`> especially when you have first-class error handling as "normal data types"
21:47:44 <startling> ReinH: does it? I'd assume 'error' cheats
21:49:09 * hackagebot mime-types 0.1.0.4 - Basic mime-type handling types and functions  http://hackage.haskell.org/package/mime-types-0.1.0.4 (MichaelSnoyman)
21:49:11 * hackagebot wai 2.1.0.2 - Web Application Interface.  http://hackage.haskell.org/package/wai-2.1.0.2 (MichaelSnoyman)
21:49:13 * hackagebot warp 2.1.4 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.4 (MichaelSnoyman)
21:49:15 * hackagebot warp-tls 2.0.3.3 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-2.0.3.3 (MichaelSnoyman)
21:50:27 <ReinH> startling: show me the definition of `catchException' :)
21:51:30 <startling> ReinH: show me the definition of `error'. :)
21:51:45 <startling> Anyway probably they both cheat.
21:52:00 <ReinH> startling: probably
21:52:17 <ReinH> error is semantically supposed to be bottom
21:52:31 <ReinH> but GHC lets you cheat both ways
21:54:09 * hackagebot yesod-core 1.2.11.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.11.1 (MichaelSnoyman)
21:57:16 <erisco> is there an extension to enable the syntax for 'type family X a where ...'? I get a syntax error on 'where'
21:59:50 <erisco> or did closed type families never get implemented?
22:01:10 <erisco> a property of the closed type family was that the rules were tried in order
22:01:19 <startling> erisco: just {-# LANGUAGE TypeFamilies #-}
22:01:24 <erisco> I have that enabled
22:01:44 <startling> works for me (on 7.8 at least).
22:02:00 <erisco> I am on 7.6
22:03:14 <copumpkin> closed type families are 7.8
22:03:27 <erisco> damn
22:03:50 <erisco> good news is that I have 7.8 on vagrant... bad news is that it is on vagrant
22:06:02 <erisco> is there another way to get ordering? a way to get ghc to pick the most specific instance perhaps?
22:06:12 <musicalchair> Hi.  I'm looking to achieve something similar to what's seen in nanopass: https://gist.github.com/anonymous/10227203  Any advice? Is Template Haskell a good fit for implementing something similar?
22:12:09 <athan> HAHAHAHAHA Wow. BonerPlusPlus...
22:12:18 <athan> nice.
22:13:37 <athan> musicalchair: Are you looking to make a parser?
22:13:58 <athan> musicalchair: You might want to check out Haskell's BNFC lib if you are
22:14:02 <athan> @where BNFC
22:14:02 <lambdabot> BNF Converter, http://bnfc.digitalgrammars.com/
22:14:19 <athan> @hoogle BNFC
22:14:19 <lambdabot> package BNFC
22:14:19 <lambdabot> package BNFC-meta
22:19:47 <lispy> I like happy + alex for parsers
22:19:52 <lispy> I should try bnfc at some point
22:21:07 <athan> (ditto)
22:21:15 <athan> (actually, I need to do all 3)
22:21:27 <jle`> hm is there any IO () -> IO String
22:21:39 <jle`> that executes the IO and returns the result of stdout
22:21:44 <jle`> inside the given IO ()
22:23:00 <musicalchair> athan: a parser, perhaps eventually.  I'm specifically wanting to play with the nanopass approach but in Haskell.  I don't need the syntax sugar, I guess
22:23:09 <athan> jle` You're not forking a command?
22:23:10 <musicalchair> bnfc does look very cool
22:23:14 <athan> right??
22:23:18 <athan> I need to get into it :)
22:23:21 <jle`> something like
22:23:32 <jle`> collectStdout (putStrLn "hello world") === return "hello world"
22:23:45 <athan> oh okay
22:23:54 <athan> you might want to work with the system commands
22:23:56 <athan> or shelly
22:24:06 <athan> i liked shelly, but it has a lot of other stuff
22:24:20 <jle`> hm ok.
22:24:40 <athan> but, something that troubles me is that I don't think you can really see a program's stdout from within that program
22:24:42 <lispy> jle`: shelly has a way to do this
22:24:48 <athan> it just seems couter-intuitive to me
22:25:06 <startling> jle`: I think forking would be a way
22:25:46 <lispy> jle`: if you want to build it yourself, this is probably the api to start with: http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html
22:25:58 <athan> ^ that's what I used to do
22:26:02 <jle`> thanks all
22:26:32 <lispy> jle`: I may have misunderstood. You want the output from the haskell IO?
22:26:34 <athan> I feel like we should have purpose-based project organization
22:26:40 <lispy> jle`: or the output from a subprocess?
22:26:55 <athan> does anyone know of a nice taxonomy of programs?
22:27:18 <athan> that's not bound to a particular programming language or OS?
22:27:24 <jle`> lispy: just something that executes the given IO () and returns the collected things sent to stdout
22:27:27 <lispy> jle`: if you want to capture output that happens during the IO () (but not from a subprocess) then you can probably get that by duping stdout and reading from it.
22:27:32 <jle`> collectStdout (putStrLn "hello world") === return "hello world"
22:27:54 <athan> oooh
22:27:58 <lispy> oh but reading from stdout doesn't make sense
22:28:07 <lispy> jle`: not sure this is possible without support from the rts
22:28:09 <athan> jle`: For some reason this doesn't smell right :/
22:28:33 <jle`> i mean it is a well defined IO transformer isn't it
22:28:43 <athan> jle`: I just feel like you're trying to obtain the result of an IO call from within it's context
22:28:48 <athan> making the operation impure
22:28:57 <jle`> it's not impure, it's an IO action
22:29:11 <jle`> collectStdout io :: IO String
22:33:48 <lispy> jle`: the output operation isn't really part of the IO _monad_.
22:33:57 <lispy> It's a side-effect that lives in the RTS
22:34:07 <athan> see that's how I feel about it
22:34:12 <jle`> hm
22:34:13 <athan> I feel like collecting is also an event
22:34:24 <jle`> i see, yeah, it's not a part of the monad
22:34:43 <jle`> is there any 'collection' part of the monad?
22:34:51 <athan> You may get away with it by recording all stdout from the initiation of the program
22:34:54 <athan> as a stream or something
22:34:58 <lispy> jle`: You mean like writer?
22:35:01 <athan> to be able to use within your program
22:35:18 <jle`> although from what i understand the implementation of the IO monad is a bit ad-hoc
22:35:18 <lispy> jle`: there are probably clever ways to do this.
22:36:01 <lispy> jle`: I supect that if you dup'd stdout at the right point you could probably at least get a copy of the output to go somewhere else.
22:36:22 <jle`> hm
22:36:29 <jle`> like without going into the rts?
22:37:05 <lispy> I mean, stdout will still do what it always does, but you'd have a different handle that is yours.
22:37:12 <startling> jle`: take a look at hDuplicate: http://hackage.haskell.org/package/base-4.7.0.0/docs/GHC-IO-Handle.html
22:37:49 <startling> hDuplicateTo too
22:37:55 <jle`> :O
22:38:05 <jle`> so i could duplicate stdout
22:38:21 <startling> I'm not sure that's undoable though (but forking might work)
22:38:33 <jle`> and use hGetContents or something
22:38:37 <startling> jle`: yep
22:38:43 <jle`> that's neat
22:38:57 <jle`> i guess i it works with the actual file pointers on the os level?
22:39:17 <lispy> the C version, called dup and dup2, work at the level of file descriptors
22:39:27 <lispy> Not sure about hDuplicate
22:39:40 <lispy> dup/dup2 is how shells implement redirection/pipes
22:39:41 <startling> I assume it's runtime thing
22:39:54 <jle`> ty
22:40:02 <startling> Could also be a C thing though I guess
22:40:16 <startling> well, obviously it's both.
22:40:17 * startling tired
22:40:18 <lispy> the Haskell stuff is probably abstracting quite a bit as it works with Handles
22:40:22 <startling> yeah.
22:41:03 <lispy> The point is, you shouldn't be able to tell that it's doing more :)
22:41:13 <lispy> It should work just like dup
22:41:18 <jle`> is this what they call "abstraction"
22:41:23 <jle`> in the academic world
22:41:41 <jle`> i don't need none of this ivory tower stuff
22:42:16 <lispy> Well, Haskell's Handle type is actually a bad example of abstraction. file descriptors are actually more abstract.
22:43:02 <lispy> What I meant by absracting is that the RTS is doing a lot of fancy stuff in the io manager
22:43:52 <lispy> Much lie startling, I'm tired and I should go to bed before I confuse myself and others :)
22:43:56 <lispy> like*
23:04:17 * hackagebot fpco-api 1.1.1.2 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.1.1.2 (MichaelSnoyman)
23:06:21 <Zekka> Hey, sorry to bother folks -- my program is split into a library and an executable, and while the library builds succesfully, the build fails with cryptic linker errors. The program's pretty large and I'd rather not upload the whole thing, but does anyone have some pointers for debugging linker errors?
23:06:35 <Zekka> Development is in a cabal sandbox and I've tried running cabal clean
23:08:24 <supki> Zekka: that probably means you didn't list every module your library uses in exposed-modules: and/or other-modules: fields in .cabal file
23:08:35 <Zekka> Oh, I think you're right -- thanks
23:09:18 * hackagebot riff 0.1.0.0 - RIFF parser for Haskell  http://hackage.haskell.org/package/riff-0.1.0.0 (RobertMassaioli)
23:09:52 <pavonia> Wow, I didn't know you can define the type of multiple fields in one in a record, like Foo { x, y, z :: Int }. That's nice
23:12:09 <Zekka> supki - You were right, thanks. By the way, I've written a custom build script that automatically populates the module lists -- is there a recommended alternative?
23:12:09 <dmj`> pavonia: the same can be done with the types of functions
23:12:09 <pavonia> Yeah, I knew that
23:12:09 <Zekka> I don't plan to list all modules explicitly because that seems unsafe and tedious as well, but I'm curious if there's a standard solution to this problem.
23:16:54 <lispy> Zekka: you are supposed to list all of them either in exposed or other
23:17:16 <lispy> It's an error when cabal lets you omit them
23:17:52 <lispy> cabal doesn't specificalyl check if you listed them all. Since they use 'ghc --make' it's often possible for ghc to find them even if you leave them out.
23:17:54 <Zekka> lispy - I'm aware that it's an error and an artifact of ghc --make, but it's also useful given that cabal doesn't seem to give you a better way to specify what the modules in your project are
23:18:09 <Zekka> I meant to ask if there were other alternatives to automatically populate the lists
23:18:19 <lispy> oh, not that I know
23:18:29 <lispy> you might see if cabal check can at least report the missing ones?
23:18:42 <Zekka> either in the form of a custom build script that's presumably better-maintained than mine or some script that repopulates the cabal file
23:19:10 <Zekka> I think cabal check can do that but bear in mind that just offloads the problem to 'remember to run cabal check regularly' instead of 'remember to update the cabal file'
23:19:34 <lispy> if cabal check can do it, then you can probably automate it :)
23:19:42 <lispy> (automate with shell I mean..)
23:19:51 <lispy> anyway, I don't know of a *good* solution
23:19:53 <Zekka> I've already automated it although I haven't automated updating the cabal file
23:19:57 <lispy> good luck and good night!
23:20:00 <Zekka> Thanks, night.
23:20:18 <raphie> I know it's possible to call C functions with the FFI, but it is possible to call haskell functions from C/C++?
23:22:28 <Dtgr> raphie: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
23:26:09 <raphie> Dtgr: ahh, cool
23:27:28 <raphie> as a toy project, I'm trying to get haskell code call-able from a nodejs program
23:34:21 * hackagebot adblock2privoxy 1.1.0 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.1.0 (zubr)
23:39:22 * hackagebot adblock2privoxy 1.2.0 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.2.0 (zubr)
23:44:26 * hackagebot meep 0.1.0.0 - A silly container  http://hackage.haskell.org/package/meep-0.1.0.0 (MatveyAksenov)
23:47:19 <vermeille> How would you deal with an application which makes an extensive use of states and mutability, like an emulator?
23:49:16 <erisco> vermeille, there are mutable data structures, and you'll be generally working IO or ST ... but otherwise I think you need to be more specific
23:50:33 <vermeille> erisco: I don't see how to efficientcly represent the RAM of the emulated system, which could be several Mo, following the Haskell's paradigm
23:51:15 <erisco> vermeille, ah well you can use a mutable vector for example
23:51:17 <vermeille> Maybe I could use a tree instead of an array but the memory overhead would be monstruous
23:52:03 <erisco> vermeille, here are mutable unboxed vectors http://hackage.haskell.org/package/vector-0.9.1/docs/Data-Vector-Unboxed-Mutable.html
23:52:23 <vermeille> Hum, okay, not so Haskellish. Should we conclude that this is a field where Haskell is not adapted and another language should be chosen?
23:52:34 <vermeille> erisco: thx for the link!
23:52:55 <erisco> well I just gave you a module you can use... so I would think Haskell has adapted just fine
23:53:04 <jrmithdobbs> i think an explicit model like you want may be fairly painful in haskell, but i'm not so sure that's the best way to do it any how
23:53:57 <no-n> @hoogle msum
23:53:57 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
23:53:57 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
23:54:44 <Cale> vermeille: Well, just because you might want a mutable structure doesn't mean it's going to be any nicer in anything else.
23:56:10 <vermeille> Cale: I'm used to write emulators in other languages and there's nothing tricky in there
23:56:30 <Cale> I wouldn't expect it to be any more tricky in Haskell :)
23:57:42 <vermeille> I'll give it a try. Let's see if I can write a simple game in haskell
