00:00:16 <jle`> hm
00:00:27 <jle`> oh
00:00:30 <jle`> actually i don't know :)
00:00:38 <jle`> i had an idea but reading it over, it makes less sense
00:00:40 <jle`> my apologies
00:00:40 <mmachenry> I think he wants Bounded
00:01:44 <mgccl> mmachenry: I see thanks, that is also good to know. What I meant was something that takes a Ord and creates a new Ord. say BoundedOrd a = a | Largest | Smallest, such that Smallest <=a<=Largest for all elements a.
00:02:32 <mmachenry> mgccl: Not all Orderable sets are Bounded.
00:03:45 <jle`> oh yeah that was what i was thinking you wanted.
00:03:46 <mmachenry> How would you take Integer, which is of class Ord and automatically turn it into a Bounded type?
00:03:57 <jle`> he probably wants that
00:04:03 <ski> @unlambda ````s``s`ks``s``s`ks``s`kki``s`kk`k.i``s``s`ks``s``s`ks``s`kki``s`kk`k.k``s``s`ks``s``s`ks``s`kki``s`kk`k.s`ki``s``s`ks``s`kki`kii
00:04:04 <lambdabot>   ski
00:04:06 <jle`> when you wrap it, if you are out of the bounds, it goes to Largest/Smallest
00:04:36 <jle`> you need a type constructor on the first field btw
00:04:42 <jle`> *first constructor
00:05:47 <pavonia> You could clip th bas type at given elements
00:05:53 <pavonia> *the base
00:06:37 <mgccl> jle`: yeah that's what I want, it simplifies logic to have something that acts as infinity.
00:08:19 * hackagebot find-conduit 0.2.2 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.2.2 (JohnWiegley)
00:08:19 * hackagebot find-conduit 0.2.3 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.2.3 (JohnWiegley)
00:08:29 <ski> @unlambda ````s``s`ks``s``s`ks``s`kki``s`kk`k.a``s``s`ks``s``s`ks``s`kki``s`kk`k.i``s``s`ks``s``s`ks``s`kki``s`kk`k.n``s``s`ks``s``s`ks``s`kki``s`kk`k.o``s``s`ks``s``s`ks``s`kki``s`kk`k.v``s``s`ks``s``s`ks``s`kki``s`kk`k.a``s``s`ks``s``s`ks``s`kki``s`kk`k.p`ki``s``s`ks``s`kki`kii
00:08:29 <lambdabot>   pavonia
00:09:03 <pavonia> O.o
00:09:09 <jle`> heh
00:10:00 <nisstyre> ski: did that execute?
00:10:05 <nisstyre> oh it did
00:10:09 <pavonia> ski: How do you make it output I applied to x?
00:10:42 <nisstyre> how does one write ski programs by hand?
00:11:06 <ski> @unlambda ````s``s`ks``s``s`ks``s`kki``s`kk`k.y``s``s`ks``s``s`ks``s`kki``s`kk`k.r``s``s`ks``s``s`ks``s`kki``s`kk`k.n``s``s`ks``s``s`ks``s`kki``s`kk`k.e``s``s`ks``s``s`ks``s`kki``s`kk`k.h``s``s`ks``s``s`ks``s`kki``s`kk`k.c``s``s`ks``s``s`ks``s`kki``s`kk`k.a``s``s`ks``s``s`ks``s`kki``s`kk`k.m``s``s`ks``s``s`ks``s`kki``s`kk`k.m`ki``s``s`ks``s`kki`kii
00:11:06 <lambdabot>   mmachenry
00:11:22 <ski> nisstyre : with great care
00:11:30 <nisstyre> fair nuff
00:11:59 <jle`> @help unlambda
00:11:59 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
00:12:08 <pavonia> @unlamba .x
00:12:08 <lambdabot>  Done.
00:12:20 <pavonia> @unlamba `k.x
00:12:20 <lambdabot>  Done.
00:12:22 <nisstyre> @lazy-k
00:12:22 <lambdabot> Unknown command, try @list
00:12:25 <nisstyre> @lazyk
00:12:25 <lambdabot> Unknown command, try @list
00:12:27 <ski> @unlambda `.x.y
00:12:28 <lambdabot>   x
00:12:49 <pavonia> I don't understand :(
00:15:55 <ski> @unlambda ```````.g.r.o.n.k. .!i
00:15:55 <lambdabot>   gronk !
00:19:33 <pharaun> @hello
00:19:34 <lambdabot> Maybe you meant: tell help
00:19:35 <augur_> ski!
00:20:01 <augur_> ski: i discovered how to think about SKI :T
00:20:50 * ski isn't sure how to think about AUGUR
00:21:03 <augur_> ski: :D
00:21:08 <augur_> i mean of course the SKI calculus
00:21:55 <augur_> i should write a thing
00:26:23 <ion> Please do.
00:33:18 <chrisw_> Does regex-tdfa have lookahead?
00:40:58 <arrnas> any ideas why i'm getting this? the instance is almost the same as the default instance for Maybe.. http://lpaste.net/103183
00:41:53 <fizruk> arrnas: tabs?
00:43:38 <arrnas> thanks, but now its giving me kind mismatch, should be * -> *, and i have *
00:43:48 <remib> Hi, I'm trying to configure ghci via the file $HOME/.ghc/ghci.conf, but it doesn't seem to be taken into account by ghci, any idea why ?
00:44:07 <lieven_> arrnas: that's correct. Maybe is a type constructor. your MyInt isn't
00:44:23 <fizruk> arrnas: MyInt (type) takes no parameters, but any Monad should take one
00:44:38 <fizruk> arrnas: (>>=) :: m a -> (a -> m b) -> m b
00:44:51 <fizruk> arrnas: sybstitute m with MyInt in that type
00:47:40 <pavonia> remib: Does it work with a local .ghci file?
00:50:47 <arrnas> so if i substitume with MyInt i'd get (>>=) :: MyInt a -> (a -> MyInt b) -> MyInt b so that would be MyInt x >>= f = f x     right?
00:51:53 <remib> pavonia: No, it doesn't seem to
00:52:00 <lieven_> arrnas: except that Myint a isn't a type just like String a isn't a type
00:52:42 <arrnas> lieven_: so MyInt is the type and MyInt a is the data constructor?
00:52:58 <pavonia> remib: So what are you trying and what is the result/error?
00:53:08 <remib> pavonia: That's the file http://sprunge.us/RZBG , it's copied from some blog post.
00:54:08 <remib> For one, I don't get the pretty lambda as prompt, and when writing hoogle or hlint, ghci tells me that it is not in scope.
00:55:45 <pavonia> You could try "ghci -read-dot-ghci"
00:57:19 <ski> arrnas : .. i would have named the data constructor differently from the type constructor -- like `data MyInt = MkMyInt Int', e.g.
00:57:50 <ski> arrnas : also, brackets not needed in `(MyInt x) >>= f'
00:59:10 <remib> pavonia, it doesn't seem to be a recognized option
00:59:40 <pavonia> remib: What is your GHC version?
01:00:20 <remib> pavonia, 7.6.3
01:00:25 <arrnas> ski: like this? http://lpaste.net/103184
01:00:39 <pavonia> Hhm, I have no idea then
01:02:16 <remib> pavonia: ok, thanks anyway
01:04:55 <ski> arrnas : next time, "Annotate" the original paste wit updates
01:05:10 <ski> arrnas : yes, except you want `MkMyInt x >>= f = f x' (since you renamed it)
01:05:36 <ski> arrnas : and it's still a kind error, as lieven_ said
01:06:29 <arrnas> right, but if i use MkMyInt x >>= f = f x then i go back to The first argument of `Monad' should have kind `* -> *',
01:06:50 <ski> arrnas : a monad is a type *function*, together with implementations of `return' and `(>>=)' for it, satisfying a few reasonable laws
01:07:16 <ski> yes, since your `MyInt' type has kind `*', it's a concrete type, not a type function
01:07:30 <ski> `Maybe' and `IO' and `Either' and `Either String' are examples of type functions
01:07:34 <ski> @kind Int
01:07:34 <lambdabot> *
01:07:37 <ski> @kind Maybe Int
01:07:38 <lambdabot> *
01:07:39 <ski> @kind Maybe
01:07:40 <lambdabot> * -> *
01:07:44 <ski> @kind Either String Int
01:07:45 <lambdabot> *
01:07:45 <ski> @kind Either String
01:07:46 <lambdabot> * -> *
01:07:47 <ski> @kind Either
01:07:48 <lambdabot> * -> * -> *
01:07:58 <ski> @kind Tree Int
01:07:59 <lambdabot> *
01:07:59 <ski> @kind Tree
01:08:00 <lambdabot> * -> *
01:08:42 <ski> you can read `Tree Int' as "tree of integer", so `Tree' can be read as "tree of"
01:09:44 <makalu> does haskell have algebraic kinds?
01:09:44 <ski> if you want `MyInt' to be a monad, then it must be "of" something. iow it must be defined something like `data MyInt a = ..a..', with a (type) *parameter* `a'
01:09:57 <ski> makalu : try the `DataKinds' extension
01:10:17 <makalu> ski: thanks
01:12:13 <ski> arrnas : anyway, it's not clear what you're trying to do, so i can only attempt to point to why your snippet isn't accepted
01:13:21 * hackagebot clash-lib 0.3.0.2 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.3.0.2 (ChristiaanBaaij)
01:17:05 <arrnas> ski: thanks for the help, it still confused as ever as to what i need to do,"write an instance of a monad" still doesn't make any sense to me since i can't rewrite existing monads and have no idea what new type i could come up with... i guess ill just need to go and ask the lecturer to clarify
01:24:29 <haasn> Twey: Hmm, this kind signature thing is a lot, lot harder than I thought. Edge cases: A type is instantiated at a kind, but has no further parameters which would be affected by that, eg. Bar :: k -> * is instantiated with K and otherwise used as-is, we'd need to print (Bar :: K -> *), rather than applying the (:: K) signature to Bar's first parameter.
01:25:01 <ski> arrnas : hm .. "write an instance of a monad" sounds different to me than "write an instance of `Monad'" -- the latter being to implement a monad, te former maybe being to write a monadic action (a value) of some existing monad
01:25:28 <haasn> Also Foo :: * -> k -> * when instantiated to K *and* applied to one parameter, eg. (Foo Int :: K -> *)
02:06:42 <ocharles> Blimey, that's quite the lens discussion
02:23:29 * hackagebot snap-server 0.9.4.4 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.4.4 (GregoryCollins)
02:36:19 <QF-MichaelK> Do first class functions imply lambda closures?  Also, what about Haskell's functions makes them first class?
02:37:02 <Kinnison> functions are values
02:37:15 <Kinnison> they can be passed around
02:37:29 <Kinnison> that's what makes me think "first class"
02:37:32 <Kinnison> (simplistic, I know)
02:37:32 <QF-MichaelK> Kinnison: Don't they also need a referencing environment?
02:38:25 <Kinnison> In a pure situation, closures aren't really what you think of, I prefer to think of partially applied functions
02:38:48 * Kinnison notes he is a very VERY basic haskeller
02:38:58 <merijn> QF-MichaelK: Only if you allow partial application/capturing local variables
02:39:06 <merijn> QF-MichaelK: Both of which haskell allows, of course
02:40:07 <merijn> QF-MichaelK: Imagine "add n = \x -> x + n; f = add 10", clearly the lambda returned by "add 10" has to capture the "10" value to be used in 'f'
02:47:30 <QF-MichaelK> merijn: I don't know of a hsfiddle: http://jsfiddle.net/gas4J/1/ but f is declared in an environment when a is 4, shouldn't that it then return 4?  Would haskell also return 5?
02:51:05 <mmmm> :w
02:51:48 <quchen> QF-MichaelK: Translation here, http://lpaste.net/103190
02:53:34 <QF-MichaelK> mmmm: quchen is a bot and you were able to convert that with 'w'? (if so, that's amazing)
02:53:48 <Maior> lol
02:54:58 <QF-MichaelK> mmmm: You could do that with: http://www.haskell.org/haskellwiki/Mutable_variable
02:56:12 <mmmm> lol, I'm just missing xmonad that's all
02:58:14 <QF-MichaelK> :w
02:58:31 <quchen> … computing
02:59:56 <QF-MichaelK> quchen: Ah, so you're human, good one!  Thank you for the translation.
03:00:20 <QF-MichaelK> https://github.com/quchen
03:00:57 <quchen> :-þ
03:01:28 <quchen> You could use mutable variables for what you were doing in that JS snippet, but it would be highly unidiomatic Haskell.
03:01:51 <QF-MichaelK> Right, and it would return 5, right?
03:01:53 * Yuu_chan enjoys the article about writing unmaintainable code
03:02:04 <quchen> There are IORefs, which behave similar to C pointers.
03:02:38 <quchen> You can make it return 5, yes. But you'll have to use IO to do that.
03:03:01 <quchen> When you're abusing IORefs and IO in general, you can write code that is structured pretty similarly to imperative languages.
03:03:36 <quicksilver> that's merely using IORefs. That's what they're for.
03:04:35 <Yuu_chan> Where is RWST normally used?
03:04:47 <quchen> quicksilver: Sure, but using IORefs should be justified.
03:04:48 <quicksilver> the IO monad is full of implicit mutable state, which makes it fiddly. IORefs give you the perfectly reasonable capability to attach your own. They're no worse than all the implicit stuff, but they're no better. It's certainly more pleasant to program withou.
03:05:47 <quchen> Yuu_chan: It's simply Reader+Writer+State baked together to be more efficient.
03:07:18 <Yuu_chan> quchen: I understand that, but can't imagine a use case
03:07:57 <Yuu_chan> "pure IO"?
03:09:08 <QF-MichaelK> Do Haskell functions contain a referencing environment link?
03:09:09 <Yuu_chan> (tell ~ putStr, listen ~ readLn, put/get ~ write/readIORef)
03:10:08 <Yuu_chan> QF-MichaelK: sorry?
03:10:20 <kartoffelbrei> Yuu_chan: lets say you have a game with a config file, logging and internal state (like current points of players). Then you need a Reader, a Writer and State.
03:11:49 <Yuu_chan> kartoffelbrei: seems natural
03:13:04 <quchen> QF-MichaelK: When defining a Haskell value, everything on its inside will be filled with the values in scope. "f = a b c" will require a, b, c to be in f's parent environment, and f will be whatever "a b c" evaluates to from that point on, forever.
03:14:08 <quchen> "a b c" can be an integer, or a function, or any other Haskell value.
03:17:09 <miguel_> wt do I have to do in my .hs for it to be compilable?
03:17:15 <miguel_> without any output
03:17:25 <miguel_> I just wanna gauge how long it takes to run
03:17:26 <quchen> You mean without having a "main" function?
03:17:41 <miguel_> or a main that just runs but prints nothing
03:17:54 <QF-MichaelK> quchen: If "a b c" changes, would that change f or does the value of f forever contain what "a b c" was when f was defined?
03:18:02 <miguel_> something like " main = length [0..9] "
03:18:40 <Yuu_chan> miguel_: just do "ghc yourfile.hs"
03:19:10 <srhb> QF-MichaelK: a b c don't change.
03:19:23 <miguel_> Couldn't match expected type `IO t0' with actual type `[[a0]]'
03:19:37 <Yuu_chan> Er, sorry, I misunderstood the task.
03:19:43 <QF-MichaelK> srhb: thanks
03:20:00 <srhb> QF-MichaelK: Once a value is bound to a name, that name has that value forever.
03:20:05 <miguel_> Ive always used the ghci, but I wanted a compiled program to run
03:20:07 <srhb> QF-MichaelK: It may be shadowed locally, but the same rules apply.
03:20:16 <miguel_> this is my code http://pastebin.com/qHWgfV7p
03:20:30 <Yuu_chan> Well, that would be non-trivial to force computations with no demand of the result
03:21:00 <Yuu_chan> miguel_: can't you afford the output of a single value, for example?
03:21:05 <miguel_> yeah, ok
03:21:13 <miguel_> as long as it compiles and runs
03:21:25 <miguel_> but what do I have to do?
03:21:34 <miguel_> for it to print the result, for example?
03:21:45 <Yuu_chan> miguel_: or you can try smth like "main = length [0..9] `seq` return ()"
03:21:49 <quchen> a, b and c are immutable as well, QF-MichaelK. They cannot change. This works even in the presence of IO, but that might be a bit tricky to explain without knowing any Haskell. Anyway, an IORef is like a "constant pointer [to a memory location]". You cannot change where the pointer points to, that's the immutability of the IORef. However, when you're in IO, you can *perform* a read of that IORef, and you'll get back the value pointed to pac
03:21:49 <quchen> ked in IO.
03:22:23 <quchen> You can also write to a constant pointer (also using IO). The pointer doesn't change, the value pointed to does.
03:22:27 <Yuu_chan> miguel_: to print, just "main = print $ length [0..9]
03:22:30 <miguel_> but then it doesnt calculate anything, due to lazy evaluation
03:22:31 <miguel_> does it?
03:22:52 <miguel_> aah, print $ did the trick
03:22:59 <miguel_> thx Yuu_chan
03:23:00 <quchen> miguel_: You can use evaluate (force <expression>) to force evaluation of something in `main`, miguel_.
03:23:08 <Yuu_chan> AFAIR, seq forces the first argument to the WHNF, for a number it must be calculated
03:23:23 <quchen> force is from deepseq, evaluate is from Control.Exception, I believe.
03:23:34 <Yuu_chan> For lists, it will compute only the head.
03:24:02 <quchen> No, for lists it will only compute whether it has a head or is empty. It won't compute the head itself.
03:24:18 <Yuu_chan> Or you can use deepseq instead of seq
03:24:34 <quchen> > let x = [undefined, undefined] in x `seq` ()
03:24:35 <lambdabot>  ()
03:24:49 <Yuu_chan> quchen: thanks for the fixing
03:25:06 <Yuu_chan> Yes, WHNF ~ constructor, (:) in this case
03:25:07 <QF-MichaelK> quchen: Thank you for elaborating, is seems that immutability makes the need for a reference environment link useless.
03:25:40 <Kototama> hi, why does (flip id) type checks? and what does it mean?
03:25:58 <quchen> :t flip
03:25:59 <lambdabot> (a -> b -> c) -> b -> a -> c
03:26:11 <quchen> :t id :: a -> b -> c -- typechecks
03:26:12 <lambdabot>     Couldn't match type ‘a1’ with ‘b1 -> c1’
03:26:12 <lambdabot>       ‘a1’ is a rigid type variable bound by
03:26:12 <lambdabot>            an expression type signature: a1 -> b1 -> c1 at <interactive>:1:1
03:26:20 <quchen> Eh hold on ;-)
03:26:41 <BoR0> @src flip
03:26:41 <lambdabot> flip f x y = f y x
03:26:46 <Kototama> i have :t id :: a - > a
03:27:10 <Yuu_chan> So to flip id, a must be (b ->c)
03:27:15 <BoR0> :t (flip id)
03:27:15 <lambdabot> b -> (b -> c) -> c
03:27:34 <Yuu_chan> Just as I said :)
03:28:27 <srhb> QF-MichaelK: Exactly, that's the beauty of it :-)
03:28:31 <Kototama> not sure i get it
03:28:34 <Yuu_chan> QF-MichaelK: try to treat = in Haskell as "defining" rather than "assigning". In maths it corresponds to the identity relation which is "harder" than equality.
03:28:39 <Kototama> doesn't flip expect a function with three parameters?
03:28:41 <QF-MichaelK> srhb: Ah, thanks again
03:28:44 <Kototama> and id has two?
03:29:10 <srhb> Kototama: the 'a' might be c -> c
03:29:16 <srhb> etc.
03:29:20 <Yuu_chan> Kototama: no, flip expects a binary function
03:29:31 <Yuu_chan> (a -> b -> c) is a binary one.
03:29:36 <quchen> Kototama: Flip requires its argument to have type (a -> b -> c), therefore "flip id" requires id's type to unify with (a -> b -> c). id has type (a' -> a'), which unifies when you pick (a' = b -> c) and (a = b -> c). In other words, you can specialize id to "id :: (a -> b) -> a -> b", which can be plugged into flip.
03:29:49 <QF-MichaelK> Yuu_chan: Right, the issues is more about mapping what I know about RPAL's lambda closures to Haskell's first class functions.
03:30:21 <Yuu_chan> QF-MichaelK: what is RPAL?
03:30:31 <quchen> Fun fact, ($) = id.
03:30:35 <srhb> More generally flip f will unify iff f has two or more arguments.
03:30:39 <BoR0> Kototama, and id has one parameter
03:30:47 <quchen> :t [($), id)
03:30:48 <lambdabot> parse error on input ‘)’
03:30:50 <quchen> :t [($), id]
03:30:51 <QF-MichaelK> Yuu_chan: a pedagogic programming language
03:30:51 <lambdabot> [(a -> b) -> a -> b]
03:31:04 <QF-MichaelK> Yuu_chan:
03:31:04 <QF-MichaelK> http://en.wikipedia.org/wiki/Rpal
03:31:11 <Yuu_chan> QF-MichaelK: thanks
03:33:07 <augur_> im tempted to write an entire little DSL inside Agda that has fake dynamic types
03:33:37 * hackagebot chp 2.2.0.1 - An implementation of concurrency ideas from Communicating Sequential Processes  http://hackage.haskell.org/package/chp-2.2.0.1 (NeilBrown)
03:34:11 <srhb> augur_: ACME-php for Agda?
03:34:16 <quchen> type Type = String :-D
03:34:28 <QF-MichaelK> Yuu_chan: I implemented it for a class and the professor stated that Haskell, LISP, ML, RPAL have first class functions but Modula, Ada, C, C++, and Java do not...  I was curious about javascript, but the working definition of first-class functions most people have is that they can be passed by value.  I've been told it also needs a referencing environment.  So, I think javascript does not have first class functions but many seem to disagr
03:34:34 <augur_> srhb: lol. not quite, but close ;p
03:34:51 <quchen> (:) :: a -> Type -> b
03:35:10 <quchen> 1 : "String" ⇒ "1"
03:35:24 <Yuu_chan> QF-MichaelK: I wonder if it has somethind to do with mutable lambdas
03:35:31 <quchen> srhb: AGDA-php :-þ
03:36:46 <Kototama> is (a -> c) -> (d -> e) equivalent to (a -> c -> d) -> e ?
03:36:55 <augur_> Kototama: no
03:37:06 <Yuu_chan> QF-MichaelK: and I guess that without mutability, by-value and by-reference are equivalent
03:37:49 <augur_> Kototama: in general,   a -> b -> c   =   a -> (b -> c)   =/=   (a -> b) -> c
03:37:52 <Yuu_chan> Kototama: the first one is eq to (a -> c) -> d -> e, the second is to (a -> (c -> d) -> e)
03:38:07 <Yuu_chan> Kototama: -> is right-associative
03:38:07 <QF-MichaelK> Yuu_chan: Another version of the code I posted before: http://jsfiddle.net/gas4J/2/ seems to indicate that js does have first class functions and the mutation doesn't seem to mater after.
03:39:35 <QF-MichaelK> (sorry that this conversation of first-class / lambda-closures / js is so basic and off topic)
03:39:57 <ski> QF-MichaelK : cut off at "..  So, I think javascript does not have first class functions but many seem to disagr"
03:41:01 <merijn> QF-MichaelK: I think JS can properly capture local environment, but I'm not 100%, I don't really do JS
03:41:08 <augur_> srhb: im tempted to also like.. make a fancy website that looks like a site for a proglang
03:41:11 <pjdelport> QF-MichaelK: JS certainly has first-class functions by any reasonable definition; I can't think of anyone who'd disagree.
03:41:18 <Yuu_chan> QF-MichaelK: I like the more naïve definition of first-class functions: when they are like any other value
03:41:19 <QF-MichaelK> ski: luckily there wasn't much more: "many seem to disagree." was the end.
03:41:30 <merijn> QF-MichaelK: Another example, python didn't *really* have first-class functions until the nonlocal keyword was implemented
03:41:55 <augur_> srhb: and then prank people with it. like.. you scroll down and it's like "wah wah. you got pranked. this is a strictly typed language."
03:42:05 <srhb> augur_: Haha
03:42:20 <merijn> So, speaking of types and things
03:42:41 <QF-MichaelK> merijn: interesting...
03:43:26 <QF-MichaelK> Yuu_chan: do they not need a referencing environment then?
03:43:29 <merijn> I've been thinking about a statically typed, pure language with hot-swappable code. Now clearly I need to do some thinking because if I replace 'f' with a new implementation that's clearly not a pure operation. Is anyone aware of people playing around with this?
03:43:29 <Yuu_chan> QF-MichaelK: wow. Is that RPAL still used?
03:44:04 <Kototama> why does ghci display :t (flip id) with :: b -> (b -> c) -> c and not :: a -> (a -> b) -> b  ?
03:44:22 <QF-MichaelK> Yuu_chan: As a teaching tool, yes.  I implemented it in Java using the operational approach with a CSE machine.  It was a nice project.
03:44:33 <merijn> You'd have to version implementations and iteratively "update" all code with a new 'f' until all old code in the program has been replaced...
03:44:35 <Yuu_chan> QF-MichaelK: I don't know, I'd want to think over this interesting question in solitude
03:44:54 <augur_> srhb: oh and like.. the page would have an FAQ and the last thing in the FAQ would be the reveal, under the heading "Why dynamically typed?"
03:45:02 <Yuu_chan> QF-MichaelK: what university are you in?
03:45:03 <QF-MichaelK> Yuu_chan: fair enough...
03:45:07 <merijn> Kototama: Implementation detail of how the type checker assigns variable names during type checking
03:45:15 <pjdelport> merijn: Python's closures were fully-featured under the hood, at least, since they were introduced. Even without the nonlocal keyword, you could still access the closure cells using reflection, to mutate them.
03:45:21 <QF-MichaelK> Yuu_chan: University of Florida
03:45:35 <pjdelport> merijn: But that's a technical point. :)
03:45:40 <merijn> Kototama: In other words, the selection of 'b' and 'c' over 'a' and 'b' has no real significance
03:45:58 <srhb> augur_: It was a strange awakening for me when I realized that dynamically typed is just a special case of statically typed, but with only one type. Maybe just add "Because it's so easy to implement in a statically typed language" :P
03:46:07 <Kototama> is the unification algorithm the same as for prolog-like system?
03:46:12 <QF-MichaelK> pjdelport: what definition would you use of first-class?  I thought a link to a reference environment was a necessary component.
03:46:13 <augur_> srhb: actually its even better than that
03:46:34 <Freundlich> Kototama: Yes.
03:46:38 <merijn> Kototama: Should be close enough to provide a decent intuition, I don't dare claim it's exactly the same
03:46:46 <augur_> srhb: with dependent types, you can not only get just one type, but you can also get type-reflection like in so many languages that have a typeOf operator
03:46:56 <srhb> augur_: True :P
03:47:04 <Freundlich> Not exactly the same, of course. Prolog needs to unify terms while programming languages need to unify types.
03:47:06 <Yuu_chan> Kototama: this equivalence takes its roots in alpha conversion from lambda calculus, I think
03:47:16 <Freundlich> *functional programming languages
03:47:20 <augur_> srhb: your one type is something like this in agda:   data Tagged : Set where tagged : (tag : Tag) -> El tag -> Tagged
03:47:31 <srhb> augur_: Yeah :_
03:47:33 <srhb> :)*
03:48:09 <pjdelport> QF-MichaelK: Loosely speaking, "first-class" means that you can use something in all ways that a language allows similar things to be used, without any restrictions. So it's something that's actually a bit language-dependent.
03:48:24 <Yuu_chan> QF-MichaelK: why aren't they using something more contemporary?
03:48:45 <ocharles> newtype M1 i c f p
03:48:54 <ocharles> I wonder if that's intentional. kosmikus ? :)
03:49:14 <pjdelport> QF-MichaelK: For functions, it's generally accepted to mean that you can define and use functions just like any other value in a language.
03:49:18 <remdezx> Hello! Do you know any good haskell library to sync files with Amazon S3?
03:49:45 <Yuu_chan> pjdelport: I like this loose definition too
03:50:03 <QF-MichaelK> Yuu_chan: Probably because RPAL is very small and nobody has heard of it before.
03:50:09 <Yuu_chan> Moreover, it can be used not just for functions, but for any other language construction
03:50:32 <Yuu_chan> QF-MichaelK: smaller than Scheme?
03:50:32 <pjdelport> QF-MichaelK: So something like a "reference to an environment" does not really bear in on it: that's an implementation detail.
03:51:44 <zipper> Which is the best way to call say curl and recieve its output from a haskell program and output it on the terminal?
03:51:45 <pjdelport> The only question is whether you can define and use them without limitations, just like any other piece value: e.g., define them in a loop, shove them in a data structure, pass them around and have other code operate on it, etc.
03:51:57 <Yuu_chan> Anyway, I'd wish my university had had FP course in _any_ language when I studied there :(
03:52:03 <Iceland_jack>  zipper: readProcess
03:53:20 <QF-MichaelK> Yuu_chan: No idea, I don't know scheme.  The documentation for RPAL's grammar is 2 pages, the standardization is 1 page, the lexical spec is 1 page, and the cse rules could be condensed to 1-2 pages....  So, it's pretty tiny
03:53:46 <Yuu_chan> zipper: probably System.Process.readProcess
03:53:53 <Yuu_chan> Too slow =\
03:54:20 <pjdelport> QF-MichaelK: A good example of how language-dependent the definition is would be mutable bindings: in Haskell, closures don't have mutable bindings because *Haskell* doesn't have mutable bindings. They're not less first-class because of it.
03:54:49 <pjdelport> But in a language like Scheme that does have mutable bindings, closures would not be first-class if they lacked it.
03:55:05 <pjdelport> So "first-class" is relative to the surrounding language.
03:55:11 <kosmikus> ocharles: I see a highlight, but am very busy. what's the context?
03:55:45 <ocharles> kosmikus: I saw that newtype when reading about GHC.Generics and seeing 'i c f p' made me wonder if that was an intentional nod to ICFP or a happy accident. but don't let me distract you
03:55:53 <Yuu_chan> Hm. "First-class X means that X can be a value"?
03:55:53 <QF-MichaelK> pjdelport: that's a much more intuitive definition, thank you for elaborating
03:56:19 <dreixel> ocharles: I think it just worked out nicely :-)
03:56:34 <dreixel> something like... i for info, c for constructor, f for functor, p for parameter
03:56:59 <srhb> ICFP should stand for that anyway
03:57:01 <srhb> :P
03:57:13 <srhb> Maybe pluralized
03:57:22 <srhb> Infos, cunstroctors, functors, parameters. Best conference.
03:57:28 <srhb> .. constructors*
03:57:33 * Hafydd snorts.
03:57:37 <QF-MichaelK> Hmmm, you know, I think I'm getting lexical and dynamic scoping confused with first-class....
03:58:12 <srhb> I'm sad it's so expensive to come, but that's another story
03:58:14 <pjdelport> QF-MichaelK: Those are entirely separate things, really.
03:58:18 <Yuu_chan> My favourite ICFP abbreviation description is that one with "nucleotides" from some year contest
03:58:22 <srhb> Why do they need to take so much money for it? What are the costs?
03:58:57 <ski> merijn : hm, perhaps Lor's thesis "Types and Reflection" at <http://lambda-the-ultimate.org/node/219> might be interesting
03:59:24 <ocharles> dreixel: :)
03:59:52 <ocharles> I love working with GHC. I'm trying something crazy and I just got conflicting type family instances
04:00:01 <ocharles> If only there was a way to close them... oh yea - that already exists!
04:00:42 <srhb> ocharles: Only just though, right?
04:01:02 <srhb> 7.8 feature I think.
04:01:05 <merijn> ski: Ah, this sounds promising :)
04:01:06 <ciaranm> srhb: conference rooms aren't cheap
04:01:09 <ocharles> srhb: well sure, but it's funny when GHC HQ are always one step ahead of me
04:01:12 <kosmikus> ocharles: it's an accident, but it's been pointed out to me before ;)
04:01:16 <srhb> ocharles: Heh, right :P
04:01:27 <bennofs> ocharles: i feel the opposite. I always wait for the next release! :P
04:01:31 <merijn> Closed type families <3
04:01:37 <merijn> bennofs: Word.
04:01:38 <srhb> ciaranm: Seems like the perfect time to just borrow some university facilities.
04:02:01 <ciaranm> srhb: university facilities are even more expensive than hotels
04:02:05 <srhb> What!
04:02:11 <srhb> :|
04:02:32 <ciaranm> where i am, it's cheaper to fly us all overseas and book a hotel than it is to rent a room from the university
04:02:58 <srhb> Crazy.
04:03:19 <ciaranm> yeah, but we have business and engineering schools who hold events where attendees are prepared to pay that kind of money
04:04:13 <srhb> What are the prices this year anyway? The ICFP page has information scattered all over the place
04:04:32 <ciaranm> i'm guessing it'll be around the 400-500 euro or dollar mark. that's fairly standard.
04:04:49 <srhb> Ugh.
04:04:53 <merijn> And another question: What would be the prerequisite knowledge for "The Gentle Art of Levitation"? I tried reading it before, but I keep getting stuck and dunno what I should understand before I try again
04:05:10 <ski> merijn : <http://lambda-the-ultimate.org/node/856> also seems to have a little discussion. it might be interesting to also look into packages,pickling,components,distribution in Alice ML
04:05:12 <ocharles> merijn: type level append! \o/
04:05:24 <merijn> srhb: You might be able to drop that by 100-200 if you're a student
04:05:33 <ciaranm> eh, your funding body should be paying it anyway
04:05:33 <srhb> merijn: Yeah, that would help a bit I guess.
04:05:42 <srhb> ciaranm: Undergrads don't have that, generally. :P
04:05:47 <merijn> ocharles: My personal favorite example: https://gist.github.com/merijn/6130082
04:06:03 <ocharles> merijn: nice little error hack
04:06:26 <srhb> The volunteer program might be useful though
04:06:42 <ocharles> merijn: what are you using that for?
04:20:47 <augur_> srhb: oh man. we should totally do this
04:20:52 <augur_> we can definitely make it happen :D
04:28:44 * hackagebot chp-plus 1.3.1.1 - A set of high-level concurrency utilities built on Communicating Haskell Processes  http://hackage.haskell.org/package/chp-plus-1.3.1.1 (NeilBrown)
04:46:36 <ocharles> I wish there was a way to make GHC error messages fully evaluate type families :(
04:46:43 <ocharles> or normalize, whatever you wanna call it
05:02:37 <zipper> When I can use a monad or an applicative which is better to use?
05:03:15 <merijn> ocharles: Nothing atm, I was just playing around with closed type families and found it neat, I figured I'd put it up as an example "cool thing you can do with closed type families"-thing
05:03:25 <merijn> ocharles: There is in ghci!
05:03:35 <merijn> ocharles: ":kind!" evaluates type families!
05:03:39 <ocharles> merijn: yes, but you can't copy a multiple line error into :kind!
05:03:44 <merijn> True
05:03:48 * hackagebot passwords 0.1.0.0 - Password generation/validation functions  http://hackage.haskell.org/package/passwords-0.1.0.0 (mkulkin)
05:03:50 * hackagebot passwords 0.1.0.1 - Password generation/validation library  http://hackage.haskell.org/package/passwords-0.1.0.1 (mkulkin)
05:04:00 <ocharles> release faster mkulkin!
05:07:54 <quicksilver> ocharles: I think it's a feature, isn't it? Some APIs give clearer (hah!!!) error messages with unnormalised type families.
05:08:05 <quicksilver> ocharles: it would be nice to have some way to control it, though.
05:08:05 <ocharles> quicksilver: yes, that's the dilemma
05:08:17 <ocharles> for my work, I usually don't want the intermediate form
05:08:21 <ocharles> e.g., when you're working with generics and stuff
05:08:39 <ocharles> Though I've actually just found out that when a type instance doesn't exist the error is messy
05:08:49 * hackagebot chp-plus 1.3.1.2 - A set of high-level concurrency utilities built on Communicating Haskell Processes  http://hackage.haskell.org/package/chp-plus-1.3.1.2 (NeilBrown)
05:08:53 <ocharles> But if all the instances are then then it does do the right thing
05:08:59 <ocharles> So I may have been too hasty with my complaining!
05:10:59 <ski> zipper : i'd say applicative, since it's more general, you're not assuming as much power from it
05:12:56 * ski . o O ( <http://en.wikipedia.org/wiki/Principle_of_Least_Power> )
05:13:47 <ski> zipper : i suppose in some cases you may run into interface problems though, since instances of `Monad' aren't automatically instances of `Applicative'
05:13:58 <fizruk> zipper: if your structure is a monad - it’s great! if you only need applicative - it’s great!
05:14:06 * ski nods
05:14:25 <DR6> you can always make an applicative instance for a monad if it isn't there
05:14:31 <DR6> just don't do it in a library
05:14:38 <ski> DR6 : not if the monad is abstract ..
05:14:47 <DR6> like in which example?
05:15:07 <fizruk> (<*>) = ap, pure = return
05:15:08 <DR6> I don't see what you mean
05:15:22 <fizruk> ski: ^ no need to know internals there
05:15:28 <ski> DR6 : if you have `class Foo t were bar :: Monad m => ..t..m..', and you want to use some library operation on instances of `Applicative' on `m' in `bar'
05:16:02 <DR6> oh but that's different
05:16:08 <ski> yes :)
05:16:27 <DR6> you said it backwards then
05:16:48 <DR6> instances of monad *are* automatically instances of applicative
05:16:53 <DR6>  not the other way round
05:16:57 <DR6> which is the problem here
05:17:04 <ski> DR6 : you can't make an instance of `Applicative' for the `Monad' `m', inside a definition of `bar'
05:17:25 <merijn> DR6: In the future you won't have to make Applicative instances for Monad \o/
05:17:25 <DR6> ... nor would it make sense
05:17:33 <DR6> that's requiring a monad
05:17:37 <DR6> not being a monad
05:17:50 <DR6> things that are monads are automatically applicatives
05:18:02 <DR6> things that require monads can't be fed applicatives
05:18:16 <fizruk> merijn: but how close is that future?…
05:18:20 <merijn> 7.10
05:18:22 <DR6> GHC 7.10
05:18:25 <merijn> Probably a year or so
05:18:38 <fizruk> yeah, a whole year :)
05:18:49 <merijn> fizruk: You could always program using HEAD :p
05:18:50 * hackagebot shake 0.11.5 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.11.5 (NeilMitchell)
05:18:52 <DR6> in 7.8 instances of monad without applicative have a warning
05:19:29 <fizruk> merijn: no thanks :p
05:19:34 <ski> DR6 : you can't write `instance Foo MyT where { bar = ... where { instance Applicative m where { pure = return; (<*>) = ap } } }', where you bring `m' into scope by `ScopedTypeVariables' or something like that
05:20:06 <fizruk> ski: you can use WrappedMonad
05:20:08 <zipper> Uh how to handle failure in main? Like an invalid command line argument?
05:20:16 <DR6> you could wrap in a newtype
05:20:22 <DR6> it won't be fun
05:20:26 <ski> fizruk : iirc, it's sometimes not possible
05:20:39 <zipper> I'm starting to wish there was a GoTo in haskell
05:20:41 * zipper hides
05:20:42 <DR6> in the case you are making it is possible
05:20:52 <DR6> zipper: use continuations
05:20:59 <DR6> they are esentially gotos
05:21:08 <zipper> DR6: Continuations?
05:21:14 <fizruk> rather safe ones
05:21:28 <DR6> yeah like Control.Monad.Cont
05:21:29 <zipper> No I don't want to use go tos
05:21:36 <DR6> there's a tutorial on haskellwiki
05:21:37 <zipper> I want to use a Maybe.
05:21:56 <ski> DR6 : wouldn't that require that `m' only occurs in the type of `bar' in mappable positions ? (so that you can exchange it by `WrappedMonad m' and vice versa)
05:22:00 <zipper> If it's nothing outuput "invalid argument" and stop the program.
05:22:17 <zipper> Else just continue
05:22:21 <DR6> ah, like in a monad tranforrmer stack
05:22:27 <DR6> it would be trickier
05:22:35 <DR6> but in most cases you could do it too
05:22:40 <DR6> with something like mmorph
05:22:56 <zipper> I don't even understand what you guys are saying. FML.
05:22:57 <fizruk> DR6: and mmorph is not all-mighty :(
05:23:11 <DR6> that's why I said "something like"
05:23:27 <fizruk> ContT is not MFunctor
05:23:34 <ski> DR6 : well, in such a case, you can do something like `class FunctorFunctor t where tmap :: (Functor f,Functor g) => (forall a. f a -> g a) -> (forall a. t f a -> t g a)'
05:23:43 <ski> .. but i don't know of a general solution
05:23:51 * hackagebot passwords 0.1.0.2 - Password generation/validation library  http://hackage.haskell.org/package/passwords-0.1.0.2 (mkulkin)
05:24:03 <DR6> zipper: you can use MaybeT
05:24:45 * ski str that this `morph' was basically that ..
05:24:46 <DR6> it allows you to do what you want anywhere in a monadic computation
05:25:19 <DR6> yeah, morph is literally that
05:25:42 <fizruk> only there’s Monad constraint instead of Functor, iirc
05:26:14 <ski> ok
05:28:51 * hackagebot unix-memory 0.1.1 - Unix memory syscalls  http://hackage.haskell.org/package/unix-memory-0.1.1 (VincentHanquez)
05:36:46 <exicer> I've been struggling to set up client certificates using http-client. Anyone got any experience of doing so who could help me out ?
05:40:48 <merijn> Oh, cool! F* was open sourced
05:44:49 <bennofs> merijn: what is F*?
05:45:12 <quchen> bennofs: A dependently typed version of F#
05:45:19 <quchen> https://github.com/nikswamy/FStar
05:45:33 <merijn> bennofs: Dependently-typed version of F# that provides correctness proofs for distributed programs
05:45:43 <bennofs> quchen: ah thanks, hard to google F* :)
05:45:56 <merijn> bennofs: See https://research.microsoft.com/en-us/projects/fstar/
05:46:36 <merijn> "Probabilistic relational verification: An extension of F* called rF* adapts the type checker to verify properties of multiple programs, or properties of more than one execution of a program, i.e., so called "hyperproperties". We have used rF* to verify a number of interesting programs implementing various cryptographic constructions and protocols."
05:46:48 <merijn> quchen: Calling it dependently-typed F# is really selling it rather short
05:47:23 * quchen apologizes
05:50:56 <Kototama> how can i do something like  mconcat $  mapM readFile files ?
05:52:38 <quchen> :t fmap mconcat . mapM readFile
05:52:39 <lambdabot> [FilePath] -> IO String
05:54:07 <zipper> In bash I can pass a file to curl with say `curl ...< filename` How can I achieve the same in haskell?
05:54:43 <Maior> zipper: that's "redirecting stdin"
05:55:05 <zipper> Maior: Oookkay?
05:55:05 <quchen> RWH has a chapter on systems programming, I think it's covered there.
05:55:12 <quchen> Also have a look at System.Process.
05:55:14 <Maior> zipper: IO.readLn?
05:55:33 <zipper> quchen: I am using system.process to call curl
05:55:35 <merijn> zipper: "<fileName" basically just replaced curl's stdin to read from fileName, instead of from your terminal
05:55:48 <zipper> wait I have an idea
05:55:56 <Maior> zipper: system.process stuff lets you control stdin iir
05:55:57 <Maior> c
05:57:29 <ski> quchen : .. why is the star shape not rotationally symmetric :( ?
05:57:57 <ski> (i suppose that ought to have been directed to merijn)
05:59:02 <DR6> anyone familiar with wreq?
05:59:10 <DR6> particularly with sessions?
05:59:16 <quchen> ski: ★
05:59:33 <DR6> it seems weird to me how there is no way to use withSession with custom manager settings
05:59:46 <DR6> I am looking the source and it seems trivial
06:00:13 * ski thinks a more symmetric symbol, sortof more soviet-style, would have looked cooler
06:01:02 <DR6> I guess I'll just send a pull request and if there is something wrong with it, bos will tell me
06:02:43 <fizruk> ☭
06:12:59 <nclarke_> Has anyone tried running distributed-process on GHC 7.8? Seems to conflict with the version of template-haskell
06:13:00 <zipper> fizruk: How did you just
06:13:07 <zipper> OMG I know that symbol from somehwhere
06:13:10 <zipper> fizruk: ^
06:13:34 <fizruk> zipper: it’s hammer and sickle
06:13:42 <zipper> Turkey?
06:13:58 <fizruk> zipper: http://en.wikipedia.org/wiki/Hammer_and_sickle
06:14:24 <Kototama> why is fmap concat . mapM readFile not equivalent to fmap (concat . mapM) readFile but to (fmap concat) . (mapM readFile) ?
06:14:37 <fizruk> just got a quick association on ski’s thought
06:14:48 <Kototama> what is the priority of a normal function application?
06:14:48 <zipper> fizruk: I thought I'd seen it in the turkish flag but I was wrong.
06:15:03 <fizruk> Kototama: highest
06:15:05 <geekosaur> Kototama, function application is the highest precedence, and lies outside of user specifiable precedence
06:15:46 <zipper> fizruk: Jesus where am I likely to have seen it?
06:15:56 <zipper> wooooo the Tofus is on TV
06:15:57 <fizruk> zipper: USSR flag?
06:16:24 <zipper> My favourite environmental love cartoon
06:16:25 <nclarke> http://en.wikipedia.org/wiki/Flag_of_the_Soviet_Union
06:16:29 <geekosaur> also various (now former) Soviet republic flags
06:16:51 <merijn> Kototama: Haskell precedence in a nutshell: operators have precedence between 0-9 inclusive (left or right associative), function application has precedence 10 (left associative) and record update syntax has precedence 11 (left associative)
06:17:09 <zipper> fizruk: You're right
06:17:11 <geekosaur> that is, it isn't in any of the flags of the independent ones, but it was in their flags when they were part of the Union
06:17:22 <merijn> Kototama: If you wanna know the precedence of something, use ":i" in ghci which will print the fixity (not printed == default == infixl 9)
06:17:38 <BoR0> :i (+)
06:17:50 <merijn> BoR0: I said ghci for a reason :)
06:17:55 <BoR0> got it :)
06:18:18 <merijn> BoR0: lambdabot *only* implements ":t" none of the other commands for ghci work, afaik
06:18:21 <BoR0> what is infixl?
06:18:23 <merijn> :k Int
06:18:24 <lambdabot> *
06:18:30 <merijn> ok, so ":k" works too :p
06:18:42 <merijn> BoR0: Left associative
06:18:48 <merijn> BoR0: infixr is right associative
06:18:49 <quchen> BoR0: "as an infix operator, it associates to the 'l'eft with precedence 9"
06:18:59 <BoR0> is infixl a function of the Num class?
06:19:11 <merijn> It's not a function
06:19:23 <BoR0> how does it determine precedence? is it something internal of Haskell
06:19:27 <merijn> It's syntax for annotating precedence
06:19:37 <geekosaur> yes, it's wired into the langauge. (it would have to be...)
06:19:38 <merijn> BoR0: It doesn't determine precedence, it *specifies* precedence
06:19:52 <BoR0> ok
06:20:29 <merijn> BoR0: i.e. if you write "(*&*) a b = {- do something with a and b -}" then you can specify the precedence of your (*&*) function by writing "infixr 4 *&*"
06:20:30 <BoR0> can it be used for operators only?
06:20:32 <Ankhers> There is both infixl and infixr, which is left and right associative respectively.
06:20:48 <merijn> Nope, this works too: "infixl 4 `elem`"
06:21:04 <merijn> Precedence only applies to infix notation for functions, though
06:21:22 <BoR0> does it necesarrily have to be a binary function?
06:21:31 <merijn> Nope
06:21:37 <BoR0> ok, neat
06:21:49 <merijn> Although the result for non-binary operators is...confusing to say the least :p
06:22:17 <merijn> :t let (*&*) a b c = a + b * c in 2 *&* 3
06:22:18 <lambdabot> Num a => a -> a
06:22:37 <merijn> > let (*&*) a b c = a + b * c in 2 *&* 3 5 -- error, tries to apply '3' to '5'
06:22:38 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a))
06:22:38 <lambdabot>    arising from the ambiguity check for ‘e_123535’
06:22:38 <lambdabot>  from the context (GHC.Num.Num (a1 -> a),
06:22:38 <lambdabot>                    GHC.Num.Num a1,
06:22:38 <lambdabot>                    GHC.Num.Num a)
06:22:50 <klrr_> somebody have a the raw file for simon jones's lens talk? i need both create an account and install flash to view it :/
06:22:53 <merijn> > let (*&*) a b c = a + b * c in (2 *&* 3) 5 -- this works
06:22:55 <lambdabot>  17
06:23:07 <edwardk> klrr_: http://ftp.newartisans.com/pub/Lenses.mp4
06:23:09 <BoR0> so I can't use infix in ghci, but for .hs modules it would work?
06:23:16 <merijn> BoR0: yes
06:23:17 <klrr_> edwardk: thanks!
06:25:46 <quchen> BoR0, merijn: You can use infix* in GHCi,  > let infixl 3 +.; (+.) = (+)
06:26:02 <zipper> merijn: Are you Erik Meijer?
06:26:15 <quicksilver> whois merijn
06:26:27 <quicksilver> (with a slash at the beginning obv)
06:26:33 <quchen> whois /merijn
06:26:45 * quicksilver slaps quchen 
06:26:55 <zipper> whois never works
06:26:57 <BoR0> zipper, I also thought of that some time ago, but /whois says no :)
06:27:15 <quchen> Merijn's first name is Merijn.
06:27:28 <zipper> True
06:27:40 <zipper> but sometimes whois doesn't give one's name.
06:27:56 <zipper> Mine is unknown
06:28:17 <quicksilver> sometimes it doesn't, but in his case it does.
06:31:16 <zipper> I'll call my son Megatron so that people always think he's lying when he says his real name.
06:32:58 <merijn> I'm rather younger, less bald and less well-paid than Erik Meijer :p
06:40:54 <mrmatttodd> Hey guys I'm having a bit of trouble understanding GADTs I keep getting errors of the form  Expected kind `*', but `a' has kind `b k0' any clues?
06:41:21 <merijn> mrmatttodd: lpaste your code + error?
06:41:43 <mrmatttodd> data BinaryTree a where   Leaf   :: BinaryTree a   Branch :: a -> BinaryTree a -> BinaryTree a -> BinaryTree a  top :: BinaryTree a -> a top (Branch v l r) = v  data Tag a where  Empty :: Leaf   NonEmpty :: Branch
06:41:52 <mrmatttodd>     Kind mis-match     Expected kind `*', but `Leaf' has kind `BinaryTree k0'     In the type `Leaf'     In the definition of data constructor `Empty'     In the data declaration for `Tag'
06:42:03 <Ankhers> mrmatttod: don't paste code in here...
06:42:16 <merijn> @where lpaste -- I meant here
06:42:17 <lambdabot> http://lpaste.net/new/haskell
06:42:27 <mrmatttodd> oh sorry fairly new to this
06:43:25 <mrmatttodd> merijn: done
06:43:35 <erisco> he needs the link
06:43:39 <merijn> mrmatttodd: And paste the link here ;)
06:44:13 <mrmatttodd> http://lpaste.net/103196
06:44:18 <mrmatttodd> there we go
06:44:49 <ocharles> If I want to rewrite a tree-like structure and change the type of some nodes, what library should I use?
06:44:53 <merijn> mrmatttodd: Well, one immedaitely obvious error is that the constructors of your Tag datatypes don't have type Tag
06:45:00 <ocharles> uniplate doesn't seem suitable, as that's not really about type changing
06:45:19 <ocharles> Specifically, I have a Rep foo (GHC generics) and I want to replace some K1 nodes with my own node
06:45:21 <merijn> mrmatttodd: What did you expect the Tag datatype to do?
06:45:44 <ocharles> meh, maybe it's better to dispatch based on two K1 instances
06:46:11 <mrmatttodd> merijn: I want it to tell me  whether a given tree is empty or not
06:46:50 <merijn> mrmatttodd: Right, but datatype constructors can (obviously) only return values of the type they're constructors off :)
06:46:51 <vermeille> I want something like `repeatM readLn` to be able to read ad infinitum on the standard input. Infortunately, repeatM does not exists, how could I have the infinite list of lines read on stdin which actually reads things on demand?
06:47:31 <mrmatttodd> merijn: haha yes of course
06:47:36 <fizruk> vermeille: lines <$> getContents ?
06:47:46 <fizruk> :t lines <$> getContents
06:47:47 <lambdabot> IO [String]
06:47:49 <erisco> > let x = readLn >> x in x
06:47:50 <lambdabot>  No instance for (GHC.Read.Read a0)
06:47:50 <lambdabot>    arising from a use of ‘System.IO.readLn’
06:47:50 <lambdabot>  The type variable ‘a0’ is ambiguous
06:47:50 <lambdabot>  Note: there are several potential instances:
06:47:50 <lambdabot>    instance [safe] GHC.Read.Read
06:47:53 <erisco> :(
06:48:09 <fizruk> erisco: even if you make it typecheck it won’t work
06:48:22 <merijn> mrmatttodd: I suspect you want something like: http://lpaste.net/103196
06:48:32 <fizruk> > let x = (:) <$> readLn <*> x
06:48:33 <lambdabot>  not an expression: ‘let x = (:) <$> readLn <*> x’
06:48:45 <merijn> mrmatttodd: May want to read the GHC manual on DataKinds
06:48:48 <vermeille> fizruk: thanks, I won't have thought to that solution on my own!
06:48:55 <fizruk> :t let x = (:) <$> readLn <*> x in x
06:48:56 <lambdabot> Read a => IO [a]
06:49:07 <mrmatttodd> merijn: ah great thanks
06:49:19 <mrmatttodd> merijn: I'll take a look at that
06:49:29 <fizruk> erisco: ^ that will always take input and never return
06:49:59 <fizruk> erisco: you would need unsafeInterleaveIO to make it work like (lines <$> getContents)
06:50:03 <erisco> fizruk, I do not know what you are saying
06:50:32 <merijn> erisco: your example won't ever return
06:50:48 <erisco> of course not
06:50:52 <vermeille> fizruk: what does it say "IOException: <stdin>: hGetLine: illegal operation (handle is closed)"?
06:50:57 <erisco> I thought that was the point :)
06:51:01 <erisco> :t forever getLine
06:51:02 <lambdabot> IO b
06:51:08 <merijn> erisco: That means you can never do something with the result
06:51:12 <erisco> of course not
06:51:29 <erisco> I thought vermeille just wanted to read an infinite number of lines :P
06:52:07 <fizruk> vermeille: are you using Leksah?
06:52:14 <vermeille> fizruk: FPcomplete
06:53:48 <erisco> vermeille, I believe pipes (or conduit) is suited for this
06:54:03 * hackagebot scion-browser 0.3.1 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.3.1 (JeanPhilippeMoresmau)
06:56:22 <erisco> vermeille, I do not know about conduit but I have worked with pipes. You would use a Producer to yield read strings. Yielding suspends the Producer until the value is read (by a Consumer)
06:56:32 <erisco> so in effect you get the on-demand reading of lines you wanted
06:57:27 <erisco> actually the first example under "Producers" is exactly the example of reading an arbitrary number of strings http://hackage.haskell.org/package/pipes-4.0.0/docs/Pipes-Tutorial.html
06:57:44 <fizruk> vermeille: getLine/getContents do not work in ghci, and afaik in Leksah, but I have no idea what’s the problem with FPComplete (I just don’t use it)
06:58:26 <fizruk> vermeille: and yes, see what erisco is suggesting
06:58:44 <vermeille> Perfect, thanks!
07:00:39 <Kototama> thanks everyone, i did a funny first haskell program thanks to your help https://github.com/kototama/jp
07:07:13 <insitu> In emacs haskell-mode I am setting haskell-process-type to 'cabal-repl and keep getting an error "The Haskell process `yesod-split-testing' has died. Restart? (y or n)"
07:07:29 <insitu> cabal repl works perfectly on the command line though
07:08:26 <insitu> and I can run 'cabal build' from emacs using  'haskell-compile
07:09:29 <mmmm> What is the correct way to work with cabal and developing multiple packages which depend on each other?
07:10:35 <tristan__> mmmm: I use, cabal sandbox add-source /path/to/other/project, for including another package I'm developing
07:11:10 <tristan__> if that is what you mean by "mulitple packages"
07:11:20 <mmmm> yes
07:11:34 <mmmm> let me try deleting the sandbox and starting again
07:34:51 <fizbin> It would probably mess up RWST, so can't happen, but sometimes it would be nice to be able to treat a MonadState as a MonadReader, so that I could enforce with the type system that a certain action will only read the state and won't muck it up.
07:35:24 <fizbin> I guess if I really cared, I'd make this function non-monadic and just take the state as a separate argument. Hrm...
07:37:01 <fizruk> :t \m -> get >>= runReaderT m
07:37:02 <lambdabot> MonadState a m => ReaderT a m b -> m b
07:37:03 <ocharles> Can HSpec do IO in tests?
07:37:20 <nh2> ocharles: pretty sure yes
07:37:34 <ocharles> I can't quite see how, I don't see a MonadIO or liftIO like function anywhere
07:37:38 <fizruk> fizbin: does that help? ^
07:38:33 <noobelina> hi
07:38:39 <nh2> ocharles: the example on http://hspec.github.io/ is already IO, see where it uses `evaluate`
07:39:02 <fizbin> fizruk: Possibly. That's a pretty straightforward way to run a (MonadReader st m) => m ... action inside a (MonadState st m) => m
07:39:06 <ocharles> ahhh, it uses "Expectation" which is an "Assertion" which is "IO ()"
07:39:09 <nh2> ocharles: you can just do `it "bla" $ ioactionhere` and when it doesn't throw the test passes
07:39:12 <nh2> yes
07:39:40 <fizbin> Also, I can replace that "get" with a "gets viewFunc" if my read-only action really just needs a smaller bit to look at.
07:39:41 <fizruk> fizbin: note that you preserve other layers too
07:40:12 <noobelina> I want to make a function that takes two arguments and add them and add 5 to the result. What am I doing wrong?
07:40:13 <noobelina> add5 = (+5) / func = add5 $ (+) / main = print $ func 3 2
07:40:26 <noobelina> "/" means newline
07:40:56 <noobelina> add5 = (+5)
07:40:57 <noobelina> func = add5 $ (+)
07:40:57 <noobelina> main = print $ func 3 2
07:41:08 <noobelina> Sorry, that's easier to read.
07:41:10 <fizruk> :t (+5)
07:41:12 <lambdabot> Num a => a -> a
07:41:19 <fizruk> :t (+5) $ (+)
07:41:20 <lambdabot> (Num (a -> a -> a), Num a) => a -> a -> a
07:42:05 <fizruk> noobelina: add5 $ (+)  ==  add5 (+)  ==  (+5) (+)  ==  (+) + 5
07:42:24 <fizruk> noobelina: so you’re trying to add (+) and 5
07:45:52 <noobelina> fizruk ah, ok, that's not right
07:46:15 <noobelina> func = add5 . (+) also gave error
07:46:24 <fizruk> :t (+5) . (+)
07:46:25 <lambdabot> (Num (a -> a), Num a) => a -> a -> a
07:46:41 <fizruk> noobelina: that’s because (+) expects 2 arguments
07:47:09 <noobelina> whyis that a problem? can't I use the . operator with a function that expects 2 arguments?
07:47:38 <fizruk> noobelina: (+5) . (+)  ==  \x -> (+5) (x +)  ==  \x -> (x +) + 5
07:49:10 <noobelina> Im not able to understand this, is it possible to get this to work with a similar syntax?
07:49:24 <fizruk> :t ((+5) .) . (+)
07:49:25 <lambdabot> Num c => c -> c -> c
07:50:22 <fizruk> noobelina: (.) only composes function with respect to their first arguments: (f . g) x = f (g x)
07:50:45 <noobelina> ah that makes sense, automatic currying and stuff
07:50:49 <ski>   func x y = add5 (x + y)
07:51:00 <ski>            = add5 ((+) x y)
07:51:07 <ski>            = add5 (((+) x) y)
07:51:26 <ski>            = (add5 . (+) x) y
07:51:37 <ski>   func x = add5 . (+) x
07:51:54 <ski>          = (add5 .) ((+) x)
07:52:01 <ski>          = ((add5 .) . (+)) x
07:52:14 <ski>   func = (add5 .) . (+)
07:52:29 <noobelina> thanks ski
07:52:35 <ski> `add5 . (+) x' can also be written as `add5 . (x +)'
07:52:54 <ski> and `(add5 .) . (+)' can also be written as `(.) add5 . (+)'
07:53:03 <rafalio> @noobelina have a look at this question, it has some good answers regarding your type of question: http://stackoverflow.com/questions/5821089/haskell-function-composition-operator-of-type-cd-abc-abd
07:53:04 <lambdabot> Unknown command, try @list
07:54:01 <ski> further
07:54:12 <ski>   func = (.) add5 . (+)
07:54:28 <ski>        = (.) ((.) add5) (+)
07:54:41 <ski>        = ((.) . (.)) add5 (+)
07:54:45 <ski> @let infixr 9 .:; (.:) :: (c0 -> c1) -> (a -> b -> c0) -> (a -> b -> c1); (.:) = (.) . (.)
07:54:47 <lambdabot>  Defined.
07:54:52 <ski>        = (.:) add5 (+)
07:54:58 <ski>        = add5 .: (+)
07:55:16 <ski> noobelina : so, you could say `func = add5 .: (+)', if you wanted to
07:55:31 <ski> `(.:)' "passes along" two arguments to the right argument function
07:56:09 <noobelina> and (.::) passes along 3?
07:56:28 <ski> if you define it as `(.::) = (.) . (.) . (.)', yes
07:56:36 <ski> of course you can define them instead as
07:56:45 <ski>   (f .: g) a b = f (g a b)
07:56:50 <ski>   (f .:: g) a b c = f (g a b c)
07:56:56 <ski> and so on, if you want to
07:56:59 <ski> @src (.)
07:56:59 <lambdabot> (f . g) x = f (g x)
07:56:59 <lambdabot> NB: In lambdabot,  (.) = fmap
07:58:06 <ski> i chose the names `.:',`.::',`.:::',&c., both to have the same number of dots as the above `(.) . ... . (.)' compositions, and also so that the number of `:'s is the number of arguments "passed along" to the right argument function
07:58:13 <ski> so, note that we have
07:58:23 <ski>      (f . g) a b c
07:58:33 <ski>   =  f (g a) b c
07:58:35 <ski>  
07:58:40 <ski>      (f .: g) a b c
07:58:44 <ski>   =  f (g a b) c
07:58:45 <ski>  
07:58:50 <ski>      (f .:: g) a b c
07:58:54 <ski>   =  f (g a b c)
07:58:56 <ski> and so on
07:59:04 <ski> noobelina : makes sense ?
08:00:02 <honza> is there a way to check if a library uses unsafe io?
08:00:34 <noobelina> ski, it makes sense, I just got lost on how to define .:
08:01:06 <noobelina> is ; used for newline?
08:02:52 <noobelina> is there not an operator syntax for mod? such as % in C++
08:03:02 <zipper> Could I get help with https://gist.github.com/urbanslug/11292606 on line 15 ?
08:03:28 <mmmm> Can you use pattern synonyms in 7.8 to still be able to pattern match but completely hide the constructors?
08:03:32 <zipper> I really feel that my code on that line is ok but it won't typecheck
08:04:31 <fizruk> zipper: don’t use ==
08:04:43 <fizruk> zipper: use case value of Nothing -> …; Just m -> …
08:05:02 <alpounet_> or the 'maybe' function
08:05:07 <fizruk> zipper: note that Nothing == x needs Eq instance for x’s type
08:05:20 <zipper> fizruk: fizruk but x is a maybe
08:05:30 <fizruk> zipper: and your value :: Maybe (String -> IO ())
08:05:45 <zipper> Yes
08:05:52 <fizruk> zipper: Just (1+) == Just (+1) ?
08:06:21 <zipper> So now I assume there is no eq instance for maybe?
08:06:44 <fizruk> zipper: Maybe a has Eq *iff* a has Eq
08:06:45 <nclarke> There is no eq instance for Maybe (String -> IO ())
08:07:00 <nclarke> Because there is no Eq instance for String -> IO ()
08:07:24 <zipper> There is no eq instance for functions wrapped in maybes
08:07:45 <fizruk> zipper: and thus there is no Eq instance for Maybe (String -> IO ())
08:07:48 <zipper> because eq instance for maybe looks for the value wrapped in the just
08:07:58 <zipper> FML
08:08:02 <zipper> I get it
08:08:03 <Twey> noobelina: Rather, newline(-and-indent-to-same-level) is used for ;
08:08:43 <Twey> noobelina: The Haskell syntax is defined in terms of braces and semicolons, and then a translation is given from layout to braces-and-semicolons
08:09:41 <Twey> noobelina: Operators aren't magic syntax in Haskell.  You can define  (%) = mod  if you want.  But usually we just write  x `mod` y  or  mod x y
08:09:53 <ski> noobelina : yes, `;' can be used instead of a line break, for placing additional declaration items on a single line (we use that with lambdabot since she wouldn't accept those three declaration items one by one, since they belong together)
08:10:13 <ski> noobelina : you can use `mod' infix :
08:10:21 <ski> > 16 `mod` 7
08:10:23 <lambdabot>  2
08:10:32 <ski> > map (`mod` 7) [10 .. 20]
08:10:33 <lambdabot>  [3,4,5,6,0,1,2,3,4,5,6]
08:10:39 <Twey> noobelina: (%) is usually used for rational numbers, as the numerator/denominator separator.
08:10:44 <Twey> > 3 % 5
08:10:46 <lambdabot>  3 % 5
08:10:48 <ski> > map (`mod` 4) [-5 .. 5]
08:10:50 <lambdabot>  [3,0,1,2,3,0,1,2,3,0,1]
08:10:54 <ski> > map (`rem` 4) [-5 .. 5]
08:10:55 <lambdabot>  [-1,0,-3,-2,-1,0,1,2,3,0,1]
08:11:00 <ski> > map (`mod` (-4)) [-5 .. 5]
08:11:01 <Twey> > (3 % 5) * (5 % 3)
08:11:01 <lambdabot>  [-1,0,-3,-2,-1,0,-3,-2,-1,0,-3]
08:11:02 <lambdabot>  1 % 1
08:11:04 <ski> > map (`rem` (4-)) [-5 .. 5]
08:11:06 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
08:11:06 <lambdabot>    arising from a use of ‘M39253437548526252171574.show_M39253437548526252171...
08:11:06 <lambdabot>  The type variable ‘a0’ is ambiguous
08:11:06 <lambdabot>  Note: there are several potential instances:
08:11:06 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
08:11:09 <ski> > map (`rem` (-4)) [-5 .. 5]  -- err
08:11:10 <lambdabot>  [-1,0,-3,-2,-1,0,1,2,3,0,1]
08:11:28 <ankov> people just don't learn when xorg-server is recording ip-address list/database
08:12:03 <zipper> fizruk: nclarke alpounet_  Thank you guys. You are far too kind.
08:13:18 <ski> noobelina : if the divisor can be negative, you normally want to use `mod'; for positive divisor, `rem' and `mod' behave the same, but `rem' is what's usually implemented by processors, so that's possibly slightly more efficient in that case
08:14:48 <alpounet_> zipper: that's a "bad" habit we have around here yeah :)
08:15:55 <ski> noobelina : with `mod', the sign of the divisor decides the sign of the resulting remainder. with `rem', the sign of the dividend decides the sign of the resulting remainder. normally you more often know the sign of the divisor than the sign of the dividend, and so you more often want `mod' over `rem', so that you can easily predict the sign (if nonzero) of the resulting remainder
08:16:19 <ski> ankov ?
08:17:37 <jakex> is there a backdoor way of accessing unexported symbols from a module?
08:17:55 <ankov> the package, like tearing
08:18:13 <ski> > 5 % 6 + 3 % 10
08:18:15 <lambdabot>  17 % 15
08:20:21 <fizruk> jakex: if there’s no .Internal module, I guess not
08:22:34 <fizruk> > sum . take 100 $ map (\n -> 1 % 2^n) [1..]
08:22:36 <lambdabot>  1267650600228229401496703205375 % 1267650600228229401496703205376
08:23:00 <jakex> fizbin that is a bit unfortunate
08:23:35 <jakex> earlier today I had to resort to using toEnum because Gtk accidentally didn't export some symbols. if they didn't make that data of Enum type I couldn't get my code to work
08:23:39 <fizbin> jakex: The two people on here with names beginning in "fiz" are not identical.
08:23:58 <jakex> yeah I noticed as I typed enter
08:24:05 <jakex> pressed*
08:25:04 <fizruk> jakex: yeah that’s unfortunate when something is not exported in a library
08:25:22 <jakex> also unfortunate that haskell has no way around it
08:25:29 <jakex> as a practical language, it should
08:25:59 <nclarke> Well, that's not clear
08:26:08 <ski> i think for modules loaded from source in GHCi, you can access internal bindings interactively
08:26:38 <nclarke> If you allow people to get to unexported things, you run the risk that they come to rely on them
08:27:05 <ski> it's a two-edged sword
08:27:28 <dbelange> a dword
08:29:02 <vermeille> my first (serious) Haskell program https://github.com/Vermeille/HaskellExpr/tree/better-par-383301/src Feedback would be appreciated :)
08:30:40 <vermeille> It's just an interpreter of a minimalist languages which understands arithmetical expressions, simple functions, and basic IO
08:31:38 <ski> Postel's law "Be conservative in what you send, be liberal/lenient in what you accept." sometimes makes sense, but can run the risk of bugs not getting fixed (which can make errors harder to detect) or needless complexity which can be hard to get rid of
08:33:04 <fizruk> vermeille: commit message naming policy is fresh :p
08:33:54 <fizruk> vermeille: readme/feature overview would be great
08:35:02 <mmmm> did you deliberately avoid parsec?
08:43:15 <zipper> alpounet_: Which "bad" habit?
08:43:26 <zipper> alpounet_: Being kind :) ?
08:43:38 <alpounet_> yeah
08:45:53 <fizbin> When I'm writing the type of some piece in a "where" clause, how do I refer to type variables bound in the declared type of the top-level expression? I seem to remember there was a language extension that added that.
08:46:00 <vermeille> mmmm: Yes, I wanted to write my own, for learning sake
08:46:23 <mmmm> is it scoped type variables?
08:46:26 <vermeille> fizruk: haha :) no one actually cares, this project is just useless
08:46:29 <zipper> Anyone know something good I could use to send post data using haskell
08:46:31 <zipper> *?
08:46:40 <mmmm> it looked pretty good vermeille from a quick glance
08:46:42 <mmmm> gtg
08:46:53 <Maior> zipper: Network.HTTP?
08:47:02 <alpounet_> zipper: 'wreq' or 'http-client' would be good candidates
08:47:15 <nclarke> @zipper bos wrote a new library for that recently
08:47:15 <lambdabot> Unknown command, try @list
08:47:19 <nclarke> Yes, 'wreq'
08:47:21 <zipper> I'm looking for the easiest to use
08:47:28 <nclarke> Which uses http-client
08:47:28 <zipper> Maior: alpounet_ ^
08:47:51 <alpounet_> zipper: both should be pretty easy to use, sincerely
08:47:56 <nclarke> http://www.serpentine.com/wreq/
08:47:58 <fizruk> vermeille: you never know when a project becomes significant to someone
08:47:59 <alpounet_> that's why I recommended them
08:48:30 <zipper> nclarke: is wreq BOS' work?
08:48:37 <fizruk> vermeille: someone might learn by your example :)
08:48:43 <vermeille> fizruk: true.
08:48:44 <nclarke> Yes
08:49:15 <vermeille> Though I don't recommend learning Haskell with my code :D
08:50:42 <fizbin> Does anyone know how to get Scoped Type Variables to actually work? I added the Language pragma to my module, but the compiler is still apparently renaming the types inside "where" clauses so that constraints from the top level don't apply further down.
08:51:11 <erisco> fizbin, can you lpaste the code?
08:51:56 <bartavelle> vermeille, just something that I recently realized, when you have something like your Expr type, you can easily write IsString and Num instances, which helps writing nicer tests and experimenting in ghci
08:54:17 * hackagebot nanomsg-haskell 0.2.1.1 - Bindings to the nanomsg library  http://hackage.haskell.org/package/nanomsg-haskell-0.2.1.1 (IvarNymoen)
08:54:32 <fizbin> erisco: Yeah, okay, reducing to a minimal and non-proprietary test case first, then I'll paste...
08:54:43 <supki> fizbin: you need explicit foralls too
08:55:18 <supki> fizbin: i.e. type variables are only scoped when they are introduced by forall
08:55:26 <fizbin> Oh, really? If I have a constraint (MonadState s m) => , does that go after the forall then?
08:55:38 <supki> forall s m. MonadState s m
08:59:35 <Yuu_chan> I'm trying to do some profiling, and GHC says that "you haven't installed the profiling libraries", do I need to do that manually?
09:02:40 <erisco> to know in the general case what constructor was used in a sum type is the only answer lens?
09:03:08 <simukis_> Yuu_chan: yes. You have to have all dependencies compiled with profiling support. Easiest way to get profiling libraries now for you would be create a sandbox and install everything there with appropriate flags I guess.
09:03:12 <erisco> (which afaik uses code gen anyways)
09:05:28 <Yuu_chan> simukis_: :(
09:09:25 <Yuu_chan> simukis_: is it easy to update cabal itself? My 1.16, which comes with Hs Platform (Windows), doesn't support sandboxes.
09:10:24 <simukis_> cabal install cabal-install (and then use cabal binary from where cabal installs them)
09:11:11 <Nahiyan> haskell is pretty nice
09:11:16 <simukis_> i.e. either by changing your PATH (or whatever equivalent in Windows) or simply replacing the old binary with new one.
09:11:21 <klrr_> Nahiyan: indeed :D
09:11:57 <Yuu_chan> simukis_: hm, thanks. I do that regularly, seems it builds into another directory
09:12:20 <fizbin> Okay, following supki's suggestion that I needed to use an explicit forall fixed my scoped type variables issue.
09:12:51 <fizbin> But I'm wondering if anyone sees a way out of this compilation error _without_ using scoped type variables: http://lpaste.net/103199
09:13:02 <zipper> Oh man. I really don't know how I will send post data with wreq.
09:13:33 <zipper> More of not understanding post requests than not understanding wreq
09:14:08 <ryantrinkle> has anyone here used Shellac?
09:14:43 <Nahiyan> ryantrinkle, what is it?
09:14:58 <fizbin> zipper: What about post requests do you not understand?
09:14:58 <quicksilver> it's a kind of incredibly strong nail varnish, isn't it?
09:15:39 <TallerGhostWalt> Is there a way to create generic versions of something like catMaybes for any sumType using prisms perhaps?
09:16:15 <ryantrinkle> haha, it's on hackage
09:17:07 <ryantrinkle> i'm interested in putting together a GHCi-like thing but for a custom monad
09:17:15 <ryantrinkle> (i.e.: a stack of transformers over IO)
09:20:16 <wingrime> anyone can say what a best way for 2d array ?
09:21:17 <ryantrinkle> wingrime: you can just use pairs for your indices, i.e.: (1,1)
09:21:23 <Nahiyan> I'm very much a noob in haskell, but why does this yell out errors?
09:21:26 <Nahiyan> [(1 + (1/x))^x | x <- [1..]]
09:21:46 <jakex> you have an extra `)'
09:21:49 <Nahiyan> basically a list approximating e
09:21:54 <jakex> sorry, no you don't
09:22:10 <Nahiyan> hmm
09:22:15 <n-dolio> :t (^)
09:22:16 <lambdabot> (Num a, Integral b) => a -> b -> a
09:22:20 <jakex> > [(1 + (1/x))^x | x <- [1..]]
09:22:21 <wingrime> ryantrinkle: maybe you right
09:22:22 <lambdabot>  No instance for (GHC.Show.Show b0)
09:22:22 <lambdabot>    arising from a use of ‘M47513005194014202002535.show_M47513005194014202002...
09:22:22 <lambdabot>  The type variable ‘b0’ is ambiguous
09:22:22 <lambdabot>  Note: there are several potential instances:
09:22:22 <lambdabot>    instance [safe] GHC.Show.Show
09:22:28 <geekosaur> Nahiyan, (^) operates on Integral but you used (/) which is Fractional
09:22:36 <Nahiyan> ah
09:22:40 <Nahiyan> so I use `exp`?
09:22:57 <eacameron> anyone have a good tutorial for Trifecta? Reading the slides was a bit deep......I just need to drive the thing
09:23:03 <geekosaur> there are three exponentiation operators: (^), (^^), (**) with different requirements on their parameters
09:23:41 <Nahiyan> okay ** works
09:23:43 <Nahiyan> thank you
09:25:12 <Nahiyan> uh, why is this taking a long time to compute? [(1 + (1/x))**x | x <- [1..]] !! 10000000000
09:25:45 <Nahiyan> surely it should be fast?
09:25:52 <Nahiyan> or is it because of gmp?
09:26:01 <tromp_> > [0..]!!10000000000
09:26:05 <lambdabot>  mueval-core: Time limit exceeded
09:26:11 <wingrime> how I can hide type operations , and define simple operations for access, row, colomn bulk operations ?
09:26:22 <tromp_> that's a pretty big loop
09:26:35 <Nahiyan> loop?
09:27:07 <tromp_> yes, it has to loop to find what x is at that index
09:27:22 <Nahiyan> ah
09:27:56 <eacameron> Nahiyan: Haskell cannot deduce a single entry within the list comp
09:28:21 <Nahiyan> also I: let exp x = (1 + 1/x)**x and went exp 1000000000000000
09:28:36 <YayMe> What is the english name for >> ?
09:28:40 <Nahiyan> eacameron, because it's a linked list?
09:29:02 <Nahiyan> > (1 + 1/10000000000)**10000000000
09:29:03 <lambdabot>  2.7182820532347876
09:29:05 <tromp_> YayMe: maybe "then" ?!
09:29:07 <Nahiyan> huh
09:29:37 <eacameron> Nahiyan: I don't think being a linked list has much to with it....GHC is smart, but it not that smart
09:29:37 <YayMe> tromp_: That's what I was thinking... doesn't quite fit for what I'm doing, trying to come up with a good name for something... lemme think if I can define it in Haskell..
09:29:40 <Nahiyan> maybe there were some overflow errors in my bigger 0
09:29:53 <Nahiyan> eacameron, mm
09:30:03 <zipper> fizbin: Uh let me just show you what I am trying to achieve.
09:30:06 <Nahiyan> > (1 + 1/1000000000000000)**1000000000000000
09:30:07 <lambdabot>  3.035035206549262
09:30:11 <eacameron> Nahiyan: I actually asked about this on stack overflow once, let me dig it up
09:30:18 <Nahiyan> oh cool
09:31:10 <eacameron> Nahiyan: http://stackoverflow.com/questions/21103043/optimize-list-indexing-in-haskell
09:31:15 <YayMe> I'm going to implement something that's... something :: (a -> b) -> (b -> c) -> (b -> d) -> (a -> d)
09:31:45 <YayMe> it's going to behave sort of like sew, the resulting a -> d will execute b -> c then b -> d
09:31:48 <Maior> @djinn (a -> b) -> (b -> c) -> (b -> d) -> (a -> d)
09:31:48 <lambdabot> f a _ b c = b (a c)
09:32:57 <YayMe> you'll give it an initial function, two next functions, it will return a function that executes... f1 >>= \x -> (f2 x >> f3 x)
09:33:56 <YayMe> I guess the haskell implementation of what I'm trying to do would be something f1 f2 f3 = \x -> (f1 x >>= \y -> (f2 y >> f3 y))
09:34:07 <YayMe> what do I name that?
09:34:15 <YayMe> it's not really...then
09:34:28 <Maior> :t \x -> (f1 x >>= \y -> (f2 y >> f3 y))
09:34:29 <lambdabot>     Not in scope: ‘f1’
09:34:29 <lambdabot>     Perhaps you meant one of these:
09:34:29 <lambdabot>       ‘f’ (imported from Debug.SimpleReflect),
09:35:12 <Maior> :t \f1 f2 f3 x -> (f1 x >>= \y -> (f2 y >> f3 y))
09:35:13 <lambdabot> Monad m => (t -> m a) -> (a -> m a1) -> (a -> m b) -> t -> m b
09:35:20 <YayMe> it's like bind seq or something
09:35:30 <Maior> @hoogle Monad m => (t -> m a) -> (a -> m a1) -> (a -> m b) -> t -> m b
09:35:30 <lambdabot> No results found
09:36:23 <erisco> [Either a b] -> Either [a] [b]     if any value is Left then returned is Left, otherwise Right... suggestions? :)
09:36:24 <YayMe> shitty thing is I'm doing this in C# so I can't even use Haskell's more concise names... the Haskell terminology would just confuse colleagues, but "then" still doesn't seem right, maybe "also"
09:36:27 <zipper> fizbin: Here https://gist.github.com/urbanslug/11295526
09:36:40 <zipper> fizbin: I hope you're still around
09:36:56 <erisco> basically a series of operations that may return an error or may produce a result. I want to either collect all the error messages or, if there were no problems, collect all the results
09:37:03 <fizbin> zipper: Ah. So you want to send post data with curl.
09:37:26 <zipper> fizbin: No I can do it with curl
09:37:35 <zipper> but I want to use wreq
09:38:00 <zipper> I don't want to depend on curl I want to use haskell only :)
09:38:02 <erisco> (I have not figured out how to express this very well functionally yet)
09:38:14 <zipper> fizbin: http://hackage.haskell.org/package/wreq-0.1.0.1/docs/Network-Wreq.html#t:partFileSource
09:38:24 <fizbin> zipper: Ah. So this code works? I'm a tiny bit surprised.
09:38:40 <zipper> fizbin: LOL why are you surprised?
09:39:00 <erisco> it is okay with  Either a b -> Maybe a   and  Either a b -> Maybe b  plus mapMaybe
09:39:31 <augur_> PEOPLEES
09:40:42 <zipper> fizbin: Try it with `create <filePath> <pasteName>`
09:40:52 <zipper> as args
09:41:10 <fizbin> zipper: I'm surprised because you make no effort to percent-encode the data, and you don't try to encode your upload as a file upload.
09:41:40 <syao> hello, I was thinking on functions. then thought, function takes input, and returns output. but in most languages  function takes multiple arguments for the input. but only one out result. how come result is only one?
09:42:01 <syao> *theory question.
09:42:40 <Iceland_jack> syao: What's the difference between taking multiple inputs and taking a tuple of inputs?
09:42:54 <syao> the sintax
09:43:07 <syao> the syntax
09:43:14 <zipper> fizbin: Wow I hadn't thought about that
09:43:22 <zipper> fizbin: Now I'm surprised it works.
09:43:30 <zipper> The more reason I should use wreq
09:43:44 <Iceland_jack> The syntax doesn't change anything, the domain of binary functions in mathematics are cartesian products of the arguments
09:43:57 <zipper> fizbin: Because in this case spaces are sent as spaces
09:43:57 <fizbin> zipper: The percent-encoding is probably the only issue, really. If not encoding it as a file upload were an issue, it wouldn't work at all.
09:44:04 <augur_> so we know there's two ways of presenting applicative-y structure, right -- one as normal applicatives with
09:44:05 <augur_>    pure :: a -> f a
09:44:05 <augur_>    (<*>) :: f (a -> b) -> f a -> f b
09:44:11 <augur_> and another with pairs
09:44:12 <augur_>    pure :: a -> f a
09:44:15 <augur_>    pair :: f a -> f b -> f (a,b)
09:44:30 <augur_> (<*>) looks like ($) hit with f, and pair looks like (,) hit with f
09:44:37 <zipper> fizbin: Using wreq I can give it a filename and it will do the rest.
09:44:42 <augur_> and when f = Identity, then they are precisely those
09:44:47 <monochrom> syao: output a tuple
09:45:01 <fizbin> zipper: Okay, looked at the ix.io docs. They *don't* want you to encode it as a file attachment.
09:45:04 <augur_> is there a general name for this kind
09:45:14 <fizbin> Which is what you get using wreq in that fashion.
09:45:20 <augur_> is there a name for this kind of generalization?
09:45:33 <zipper> fizbin: So uh what do you say?
09:45:57 <syao> Iceland_jack, why we are talking on binary functions only?
09:46:21 <Iceland_jack> Same holds for n-ary functions
09:46:31 <augur_> that is to say, where you have some collection of operations, and lift the type to have f's in places, so that the special case of f = Identity is the normal case of the operations?
09:46:34 <syao> monochrom, but the result is not an input for a function with multiple arguments
09:47:11 <monochrom> that is sometimes unimportant. when it is important, have the next function input a tuple
09:47:20 <erisco> augur_, that is an interesting observation thanks
09:47:38 <augur_> erisco: which what huh
09:47:46 <syao> Iceland_jack, so this kind of thing is function theory limitation?
09:47:50 <hunt> hey guys
09:48:00 <erisco> augur_, your examples
09:48:02 <hunt> so im working on a web backend
09:48:09 <augur_> erisco: my examples?
09:48:10 <hunt> and im trying to use HDBC for SQL
09:48:13 <Iceland_jack> syao: I don't understand what that means
09:48:20 <Iceland_jack> I'm gone anyway, cheers
09:48:29 <hunt> in HDBC, when you get a row you get back a [SqlValues]
09:48:51 <hunt> i want to turn this into an appropriately sized tuple, so i thought i might be able to do somethign like:
09:48:54 <erisco> augur_, um nevermind :P
09:48:57 <augur_> erisco: :P
09:49:10 <augur_> erisco: i was just observing a certain pattern that i find interesting
09:49:15 <augur_> you can imagine other things like that
09:49:15 <hunt> let (a:b:c:_) = map fromSql myRow in (a :: Int, b :: String, c :: Char)
09:49:19 <hunt> but it errors
09:49:38 <syao> monochrom, I am thinking that it will will make more boilerplate in code.
09:49:39 <fizbin> zipper: So I'd try something like (post "http://ix.io" (pack "f:1" := fileContentsAsByteString))
09:49:45 <erisco> augur_, yes I find it interesting because now I can look at any function and observe what happens when I "hit it with f"
09:50:21 <hunt> anyone have any ideas?
09:50:33 <augur_> for instance, what is this type class:   pure :: ...  ;  inl :: f a -> f (Either a b)  ;  inr :: f b -> f (Either a b)   ?
09:50:52 <monochrom> hunt, it has to be "let (x:y:z:_) = myRow in (fromSql x, fromSql y, fromSql z)"
09:51:13 <hunt> monochrom: damn, frustrating that i have to call fromSql so many times
09:51:14 <erisco> augur_, and it is interesting because when you do that you're enabling one to override what otherwise happens in the Identity case ... Arrows come to mind
09:51:40 <augur_> erisco: er.. i dont know that you can just look at it and observe anything
09:51:44 <monochrom> to comfort you, they are 3 different "fromSql"s.
09:53:19 <erisco> augur_, *shrug* anyways I have to go, good luck
09:53:37 <monochrom> I also prefer case to let for this. case myRow of (x:y:z:_) -> (fromSql x, fromSql y, fromSql z)
09:57:08 <syao> monochrom, talking about http://en.wikipedia.org/wiki/Function_(mathematics)#Functions_with_multiple_inputs_and_outputs
09:57:19 <hunt> monochrom: why use case? in case the row is empty?
09:57:40 <monochrom> case is more eager. let is more lazy. do you want lazy for this one?
09:59:33 <hunt> monochrom: i dont have enough experience to really make that decision
10:00:02 <monochrom> my judgement is that this one doesn't need lazy
10:01:32 <FOOD_> with graphics drawing combinators, is it possible to wait for vsync, i guess by using opengl directly?
10:01:57 <FOOD_> or is the idea to busy loop the draw command to show animation
10:08:36 <zipper> fizbin: Is that the kind of pack I could get from Data.Bystring.Lazy?
10:08:59 <fizbin> zipper: Yes. I mean the pack that does String -> ByteString
10:09:14 <fizbin> Since wreq uses ByteStrings everywhere.
10:16:39 <zipper> fizbin: No pack I find has type String -> ByteString
10:16:45 <zipper> I'll hoogle
10:18:00 <fizbin> Not event http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/bytestring/Data-ByteString-Char8.html.pack ?
10:18:12 <fizbin> Ooops. Stupid copy-paste.
10:18:18 <zipper> I found that one
10:18:29 <fizbin> Ok
10:18:34 <zipper> I was using the one I learned to use in LYAH
10:19:41 <tapuu> Is there a way to use haskell to write a nodejs appplication?
10:19:54 <Maior> tapuu: what exactly do you mean?
10:20:12 <tapuu> Maior: haskell that compiles to javascript, or something like that
10:20:55 <Maior> tapuu: check out http://www.haskell.org/haskellwiki/The_JavaScript_Problem
10:21:05 <k00mi> why the hell would you compile haskell to js to run it as node.js
10:21:14 <zomg> k00mi: was just about to ask the same... =)
10:21:53 <zipper> fizbin: Now trying to make sense of the return type/value of `post'
10:22:02 <Maior> tapuu: what k00mi said
10:22:33 <tapuu> Maior: whats wrong with that?
10:23:22 <zomg> tapuu: if you're going to write a server-side app in haskell why not just... write it in haskell
10:23:30 <Maior> tapuu: given the (currently near-zero) context, it seems somewhat dod
10:23:32 <Maior> *odd
10:23:37 <tapuu> haskell is hard to deploy
10:24:04 <zomg> dunno, I deployed my haskell program to AWS by uploading the compiled binary...
10:24:28 * hackagebot criterion-plus 0.1.0 - Enhancement of the "criterion" benchmarking library  http://hackage.haskell.org/package/criterion-plus-0.1.0 (NikitaVolkov)
10:24:45 <Maior> tapuu: I do work on deployment infrastructure etc. for a bunch of companies, I _adore_ deploying Haskell, compared to today's Python
10:26:16 <fizbin> zipper: I'd go with something like do {r <- post ... ; return $ unpack (r ^. responseBody)}
10:27:00 <Maior> tapuu: by what metric do you find it hard?
10:29:29 * hackagebot uhttpc 0.1.0.0 - Minimal HTTP client library optimized for benchmarking  http://hackage.haskell.org/package/uhttpc-0.1.0.0 (HerbertValerioRiedel)
10:37:48 <ion> Curious https://github.com/i-tu/Hasklig/
10:40:19 <zipper> fizbin: Sorry I went offline
10:40:43 <zipper> fizbin: I had `reply <- post "http://ix.io" (S.pack "f:1" := contentsAsByteString )`
10:41:03 <zipper> fizbin: I tried the following but failed `r <- post "http://ix.io" (S.pack "f:1" := contentsAsByteString ); return $ unpack (r ^. responseBody)`
10:41:31 <fizbin> Use S.unpack there; what's the failure?
10:41:54 <carter> any lens experts in the house?
10:43:48 <nh2> carter: in #haskell-lens probably
10:43:52 <carter> no ones home
10:44:00 <augur_> https://gist.github.com/psygnisfive/11297501
10:44:01 <augur_> for fun
10:44:12 <zipper> fizbin: Probably caused by that
10:44:35 <zipper> fizbin: post with ix.io returns JSON
10:44:44 <zipper> I ran print on r
10:46:08 <fizbin> zipper: Oh, it does? Well then you can use the wreq example at http://hackage.haskell.org/package/wreq-0.1.0.1/docs/Network-Wreq.html#g:3
10:48:42 <zipper> fizbin: Where are ^? and ^. coming from?
10:48:59 <zipper> I googled but...
10:49:36 <zipper> They are out of scope
10:49:47 <fizbin> zipper: Control.Lens. Specifically, http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html
10:50:09 <fizbin> Doing an "import Control.Lens" should be enough to bring them into scope.
11:00:21 <zipper> fizbin: Yeah I did so what I thought was JSON is not. I was just opening it in a very small pane. When I called print on it it returned https://gist.github.com/urbanslug/11298017
11:02:17 <fizbin> zipper: Oh. In that case I'd try printing out (r ^. responseBody)
11:11:21 <chrizz__> simple OverloadedLists question, http://lpaste.net/103200 -- this isn't compiling
11:11:34 <chrizz__> do i need to grab the IsList instance from somewhere?
11:11:51 <chrizz__> i would expect a different error though
11:19:11 <edwardk> chrizz__: afaik they don't have an instance in containers yet
11:19:26 <syao> how can I apply partial argument on function to a ex. second argument?
11:19:52 <chrizz__> edwardk: oh ok, thanks. I was expecting some "no instance for IsList" error in that case, though
11:20:32 <chrizz__> syao what do you mean?
11:20:33 <edwardk> chrizz__: it didn't get that far. It needed the type instance Item  first
11:21:59 <syao> f     :: Int -> String -> Int
11:22:01 <syao> add x s = ...
11:22:02 <syao> addS = add _ "Some strinf"
11:22:22 <chrizz__> but since Item is an associated type of IsList, shouldnt the fact that there is no instance for IsList (Map k v) cause an error first?
11:22:40 <chrizz__> obviously I'm wrong but that seems more correct
11:22:44 <chrizz__> anyways thanks
11:23:20 <chrizz__> syao: addS s = add s "foo" ?
11:23:27 <chrizz__> or addS = flip add "foo"
11:24:36 * hackagebot loshadka 0.1 - Minecraft 1.7 server proxy that answers to queries when the server is offline  http://hackage.haskell.org/package/loshadka-0.1 (LnYnp6WCYyKG3yhdLDztVRuQjTFKEy)
11:24:36 <chrizz__> or addS = let x = (`add` "foo") in fst (x,y) where y = x
11:25:11 <chrizz__> the last one is idiomatic haskell
11:25:52 <zipper> Anyone know how I can convert such to string? `Data.ByteString.Lazy.Internal.ByteString'
11:26:00 <zipper> Data.ByteString.Lazy.Internal.ByteString -> String
11:26:13 <chrizz__> use OverloadedStrings or use unpack
11:26:16 <ReinH> :t BS.unpack
11:26:17 <lambdabot> BSC.ByteString -> [Word8]
11:26:30 <ReinH> it's the unpack in ByteString.Char8
11:26:34 <ReinH> specifically
11:26:43 <Clint> that doesn't work for utf-8
11:26:47 <chrizz__> I think you mean Data.ByteString.Char8
11:27:07 <zipper> No I don't mean Data.ByteString.Char8
11:27:18 <zipper> So no direct way to convert to String?
11:27:28 <Clint> what encoding is your bytestring in?
11:27:31 <zipper> Yes I did find that unpack will convert to word8
11:27:41 <solrize> haskell.org ??? :(
11:27:43 <chrizz__> zipper: no, the unpack from Data.Bytestring.Char8
11:28:01 <zipper> Clint: Clint utf-8
11:28:12 <Clint> zipper: then do NOT use unpack
11:28:31 <zipper> chrizz__: That one wont work for a bytestring from Data.ByteString.Lazy.Internal.ByteString
11:28:42 <solrize> @see First
11:28:42 <lambdabot> Maybe you meant: src let leet free
11:28:49 <zipper> Clint: What should I use I want to print
11:29:05 <Clint> print?
11:29:29 <zipper> lol print works in ghci
11:29:53 <chrizz__> zipper: Data.ByteString.Lazy.Char8, then
11:30:09 <Clint> you want to print a utf-8 bytestring as utf-8?
11:30:27 <zipper> chrizz__: I'm getting it from a server I don't think I have much control
11:30:38 <zipper> Clint: Ignore that part I am not very knowledgable
11:31:22 <chrizz__> zipper: I'm telling you what module to find the appropriate unpack in, not telling you the type of your bytestring. However the point is moot as your bytestring is not ascii
11:31:38 <zipper> chrizz__: :(
11:31:48 <Clint> zipper: you could hPut the bytestring to stdout
11:32:00 <zipper> :t hPut
11:32:01 <lambdabot>     Not in scope: ‘hPut’
11:32:01 <lambdabot>     Perhaps you meant one of these:
11:32:01 <lambdabot>       ‘BSC.hPut’ (imported from Data.ByteString.Char8),
11:32:13 <zipper> :t BSC.hPut
11:32:14 <lambdabot> GHC.IO.Handle.Types.Handle -> BSC.ByteString -> IO ()
11:32:21 <chrizz__> zipper: there is no meaningful String representation for utf-8 text, so you don't want to unpack it anyway. if all you want to do is print it, why not use print like Clint said?
11:32:45 <zipper> chrizz__: Let me try that
11:34:35 <nh2> with hmatrix equation solving facilities, how do I figure out if the equation can actually be solved? linearSolve says "raises an error if called on a singular system" but I'd really like a Maybe instead of an exception
11:37:54 <zipper> Well uh I figure that I need to convert it to string. Printing is not enough
11:38:47 <zipper> the unpack in brb
11:38:55 <zipper> brb
11:53:14 <zipper> :t BSC.unpack
11:53:15 <lambdabot> BSC.ByteString -> [Char]
11:55:10 <zipper> chrizz__: Thanks a ton mate
11:56:23 <TallerGhostWalt> toListOf (^..) is my new favorite lens thing
11:56:36 <edwardk> :t toListOf (^..)
11:56:37 <lambdabot>     Couldn't match type ‘[a1]’
11:56:37 <lambdabot>                   with ‘Const
11:56:37 <lambdabot>                           (Endo [a]) (Getting (Endo [a1]) (a -> Const (Endo [a]) a) a1)’
11:57:35 <TallerGhostWalt> its generic catMaybe! which is basically the best thing ever and now everyone should just use haskell already
12:00:00 <erisco> does lens rely on TH?
12:00:11 <sclv> it uses it, optionally
12:00:16 <edwardk> erisco: its optional
12:00:23 <erisco> what does not using it mean?
12:00:45 <joseph07> erisco: you get to experience the joy of making lenses by hand
12:00:46 <edwardk> means you write the lenses by hand
12:00:47 <chrizz__> no makeLenses
12:00:50 <joseph07> erisco: which is pretty easy
12:00:59 <joseph07> erisco: so easy a computer could do it
12:01:17 <TallerGhostWalt> is there a way to use TH to right the fully general Lens stab instead of Lens'?
12:01:27 <edwardk> yes
12:01:31 <edwardk> makeLenses will do the former
12:01:39 <edwardk> makeClassy makes Lens'
12:01:56 <TallerGhostWalt> is there a makeLenses_
12:02:01 <joseph07> why is it called makeClassy
12:02:13 <ReinH> because it also makes a typeclass
12:02:51 <edwardk> joseph07: makeLenses makes just lenses for your type. makeClassy is makes lenses as wel, but prepends a class to access your ype
12:03:01 <edwardk> e.g.
12:03:32 <edwardk> data Foo a = Foo { fooInt :: Int, blah :: a }     makeLenses ''Foo
12:03:33 <ReinH> joseph07: because it's suave and sophisticated.
12:03:45 <edwardk> er .. data Foo a = Foo { _fooInt :: Int, _blah :: a }     makeLenses ''Foo
12:03:57 <corgifex> > 0 :: Complex (Complex Double)
12:03:58 <lambdabot>  No instance for (GHC.Float.RealFloat
12:03:58 <lambdabot>                     (Data.Complex.Complex GHC.Types.Double))
12:03:58 <lambdabot>    arising from the literal ‘0’
12:04:03 <corgifex> shame
12:04:12 <edwardk> will make fooInt :: Lens (Foo a) (Foo a) Int Int; blah :: Lens (Foo a) (Foo b) a b
12:04:14 <edwardk> but
12:04:22 <edwardk> makeClassy ''Foo
12:05:17 <edwardk> will generate class HasFoo t a | t -> a where foo :: Lens' t (Foo a); fooInt :: Lens' t Int; blah :: Lens' t a; with the default definitions of those using foo to 'start' by getting down to the Foo.
12:05:34 <edwardk> and it'll make instance HasFoo (Foo a) a were foo = id
12:06:00 <edwardk> so its making lenses, but they are based on a class. it used to be makeClassyLenses, but we dropped the last word.
12:06:10 <edwardk> and it was a bit of a play on the naming of the "classy prelude" at the time
12:06:36 <joseph07> edwardk: that makes sense
12:06:45 <TallerGhostWalt> I love classy prelude
12:06:45 <edwardk> also i think mightybyte threatened that if we called it that he couldn't bring himslf to use it, so I took that as a challenge ;)
12:06:47 <ReinH> edwardk: so, if I have another data Bar a = Bar { barFoo :: Foo } and I makeLenses ''Bar
12:07:00 <ReinH> edwardk: iirc there's a conflict with using HasFoo
12:07:02 <ReinH> or maybe I did it wrong
12:07:20 <edwardk> you can make instance HasFoo (Bar a) a where foo = barFoo
12:07:38 <ReinH> right, but iirc I had some case where I tried to make lenses and there was a namespace conflict
12:07:45 <ReinH> But this is unhelpful as I can't remember the actual conditions so never mind
12:07:46 <edwardk> er assuming data Bar a = Bar { barFoo : Foo a } -- of course
12:07:54 <edwardk> er data Bar a = Bar { _barFoo : Foo a }
12:08:13 <ocharles> Does the type  (->) (Gen Char)  have any inhabitants?
12:08:23 <alpounet_> _barFoo :: Foo a
12:08:29 <edwardk> anyways my recommendation when you intend for this pattern is prefix your local one-off field name so you can just make the instance of HasFoo and use that
12:08:40 <ocharles> It's kind  * -> *  which I don't think is inhabited at the term level, right?
12:08:40 <edwardk> alpounet_: yeah i can't type =)
12:08:43 <erisco> gotta love the fmap fmap fmap fmap fmap
12:09:16 <ReinH> erisco: :)
12:09:27 <TallerGhostWalt> if I want makeLenses_ I need to use my own LensRules settings file right?
12:09:39 <ReinH> edwardk: "prefix your local one-off field name"?
12:09:50 <edwardk> you can just write it inline using a custom config
12:09:58 <erisco> ReinH, is it acceptable to not destroy minds and say fmap . fmap . fmap?
12:10:00 <ReinH> ocharles: Er, all values are of kind *?
12:10:13 <ocharles> ReinH: mmm
12:10:18 <edwardk> makeLensesWith ?? ''Foo $ defaultRules & lensField .~ \x -> Just (x ++ "_")
12:10:45 <chrizz__> erisco: fmap.fmap.fmap is the pattern that keeps generalizing to lens, edwardk begins there in his 2 hour lens talk
12:10:49 <ReinH> lenses for lenses... so meta
12:10:52 <ocharles> So maybe I want to construct (Gen Char -> ()) and then I can fmap extra stuff in later
12:11:27 <edwardk> I'll be running a 3 hour class on lenses at CUFP this year as well.
12:11:36 <alpounet_> fun
12:11:41 <chrizz__> will it be recorded?
12:11:58 <chrizz__> last year's were so i assume so
12:12:01 <TallerGhostWalt> edwardk: lenses making lenses
12:12:25 <edwardk> chrizz__: i am happy to have someone record it if they have equipment. the company we're talking to about recording CUFP in general expressed no interest in recording the tutorials though.
12:12:26 <carter> will there be mirrors of the talks? :)
12:12:33 <erisco> chrizz__, what is the basic idea? how do you more briefly state what you want to modify?
12:12:42 <alpounet_> edwardk: oh cool at zurihac it's about succint/cache oblivious structures
12:13:19 <chrizz__> edwardk: oh, bummer... hopefully someone steps up. it would be so awesome to see that talk
12:13:30 <edwardk> alpounet_: yeah the zurihac talk will focus more on the haskell-aspects of those topics than the other talks i'm giving in that area.
12:14:06 <TallerGhostWalt> same trick for makePrisms_ ?
12:14:13 <alpounet_> nice, i'm already familiar with a decent part of the material so I may get more out of this talk than out of the other one you gave about that topic
12:14:33 <TallerGhostWalt> edwardk: this has saved me hours btw, thanks!
12:16:38 <migimunz> Hello, I'm reading hackage, and it says that inits has the following strictness property: inits _|_ = [] : _|_. What does this mean?
12:17:23 <corgifex> which part is unclear?
12:18:30 <erisco> migimunz, _|_ is notation for "bottom" which you'll have to ask someone other than me about. the idea of what they are saying is that even if the argument to inits cannot be evaluated it still returns an empty list on the head
12:18:30 <edwardk> TallerGhostWalt: yeah there should be something in there for prisms. if not let me know and either i'll fix it or I'll shame glguy into it ;)
12:18:31 <migimunz> well, I'm quite new to haskell, and I'm not sure what a strictness property is. I've seen the _|_ symbol called a "bottom", and I sort of understood what that meant on the wiki, but I still don't understand what strictness property is?
12:18:57 <erisco> > head (inits undefined) -- for example
12:18:59 <lambdabot>  []
12:19:00 <chrizz__> migimunz: head (inits undefined) will not crash
12:19:09 <corgifex> a function f is called strict if f _|_ = _|_
12:19:21 <migimunz> thanks!
12:19:35 <edwardk> migimunz: haskell tries not to 'force' any values to evauate that don't have to. something that when evaluated crashes out with an error or spins forever is what we call a bottom.
12:19:39 <corgifex> > fix (head . inits)
12:19:39 <erisco> corgifex, interesting thanks
12:19:41 <lambdabot>  []
12:20:13 <migimunz> thanks, that makes sense
12:22:01 <TallerGhostWalt> edwardk: awesome makePrisms just does it, I think I knew that at one point.  thanks again
12:24:17 <ReinH> migimunz: undefined and error are (almost) bottom values, for instance.
12:24:47 <ReinH> well, error s for some string s
12:25:50 <migimunz> ReinH, hm, why almost :) ?
12:26:07 <erisco_> interesting... brown out takes down one of my two monitors and my router... but not my other monitor and PC
12:26:15 <jle`> i like using sum [1..] as my bottoms
12:26:23 <MagneticDuck> jle`: you are evil
12:26:56 <Nahiyan> hmm
12:27:02 <corgifex> __ = __
12:27:05 <corgifex> oleg style
12:27:27 <Nahiyan> sum [1..1000000] takes 0.39s
12:27:56 <Nahiyan> and 171197256 bytes
12:28:01 <Nahiyan> roughly 171MB
12:28:09 <erisco> @src sum
12:28:09 <lambdabot> sum = foldl (+) 0
12:28:15 <Nahiyan> :set +s
12:28:15 <zipper> What happened to haskell casts?
12:28:16 <erisco> they did not use the strict one. whoops
12:28:19 <chrizz__> well there's your problem
12:28:19 <zipper> I must know
12:28:30 <chrizz__> zipper: nothing happened
12:28:43 <ski> @type Data.Typeable.cast  -- zipper, this one ?
12:28:44 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
12:28:55 <zipper> chrizz__: Why is it taking so long for the next episode to come out?
12:29:01 <zipper> :/
12:29:24 <chrizz__> zipper: because santa and his elves are working very hard and if you are a good boy you will get presents come christmas
12:29:45 <chrizz__> but if you are a bad boy you wont get shit so shut your mouth
12:30:04 <zipper> chrizz__: Are you Chris Forno?
12:30:09 <chrizz__> no
12:30:14 <chrizz__> haha
12:30:25 <jle`> zipper: ReinH says to expect something amazing
12:30:41 <zipper> Oh does he
12:30:45 <zipper> I can't wait
12:31:10 <jle`> Nahiyan: sum on the lambdabor @src is different than the ghc sum
12:31:17 <jle`> just in case you weren't aware
12:31:17 <chrizz__> what could be more amazing than the guests so far?
12:31:23 <jle`> lambdabor
12:31:31 <zipper> chrizz__: More amaing guests
12:31:38 <chrizz__> i can't think of any
12:31:49 <jle`> how about haskell himself
12:32:02 <jle`> prof curry
12:32:13 <chrizz__> i think he's rotting in a grave somewhere
12:32:32 <Nahiyan> hmm
12:32:34 <zipper> A boxing match between Simon Peyton Jones and Linux Torvalds would be AWESOME!
12:32:39 <jle`> import Control.Monad.Tardis
12:32:48 <chrizz__> his name is linus lol
12:33:06 <zipper> chrizz__: I knew that
12:33:08 <zipper> :)
12:33:58 <ion> Linux Thornwalds
12:34:09 <merijn> PLT question time! What would be the prerequisite knowledge for "The Gentle Art of Levitation"? I tried reading it before, but I keep getting stuck and dunno what I should understand before I try again
12:34:58 <Twey> merijn: Just dependent types, I think
12:35:17 <Twey> But you probably want to have a pretty good understanding of the various uses of the sigma type
12:35:33 <ReinH> merijn: if you're stuck there's no hope for the rest of us :/
12:35:43 <merijn> ReinH: How so?
12:36:02 <chrizz__> he say u smart
12:36:05 <ReinH> he do
12:36:13 <merijn> Twey: I thought I grokked dependent types okayish, apparently not :p
12:36:36 <merijn> Maybe it's just the information density that's the problem
12:37:01 <merijn> I only got like a quarter into Jokers to the left, clown to the right too
12:37:20 <Twey> merijn: The theory used isn't particularly complex, but Conor (ab)uses sigma types in interesting ways that are kind of disconcerting on first read-through (to me, at least)
12:37:35 <merijn> I should pay someone to translate Conor into something mere mortals can understand :p
12:37:43 <merijn> Although his thesis was rather readable
12:38:11 <Twey> I like his style… he's never dry :þ
12:40:10 <erisco> what is the easiest way to map both values in Either?
12:40:22 <corgifex> :t join either
12:40:23 <lambdabot> (a -> c) -> Either a a -> c
12:40:41 <ReinH> merijn: hah
12:40:42 <erisco> wow interesting thanks
12:41:27 <ReinH> merijn: The applicatives paper was a pretty easy read. The 3rd time I tried.
12:42:12 <Twey> Either is a bifunctor, so you can also use http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html if you want to treat them both differently
12:43:34 <jle`> corgifex: neat
12:43:44 <merijn> ReinH: If you want a challenge, try "Elimination with a Motive", "The View from the Left" or "Clowns to the left of me, jokers to the right" :p
12:43:51 <erisco> Twey, ah that was the name of it... I was thinking "bimap" and not finding it. however, join either is exactly the type I need
12:44:41 <ReinH> merijn: I've tried clowns.
12:44:54 <corgifex> :t either id id
12:44:55 <lambdabot> Either c c -> c
12:45:01 <Twey> I'm halfway through ‘Outrageous but Meaningful Coincidences’ at the moment, which is nice
12:45:11 <jle`> :t join either id
12:45:12 <lambdabot> Either a a -> a
12:45:33 <jle`> :t join either id . return
12:45:34 <lambdabot> c -> c
12:45:41 <merijn> Kleisli Arrows of Outrageous Fortune is interesting *and* readable
12:45:45 <erisco> wait no it is not
12:45:46 <jle`> > (join either id . return) "hello"
12:45:47 <lambdabot>  "hello"
12:45:50 <ski> merijn : what's "The Gentle Art of Levitation" about ?
12:45:55 <ReinH> merijn: I actually need to read clowns again because it's relevant to my current interests
12:45:56 <TallerGhostWalt> oh, and then a little looking and toListOf could be generalized to toMonoidOf
12:46:04 <TallerGhostWalt> if...
12:46:09 <erisco> I need at least   (a -> b) -> Either a a -> Either b b
12:46:21 <TallerGhostWalt> there is a generic equivalent of (:) :: a -> [a] -> [a]
12:46:37 <Twey> ski: Representing data types as constructions of sigmas
12:46:39 <TallerGhostWalt> that isn't a monoid I guess
12:46:46 <jle`> erisco: you would need bimap i think in that case
12:46:51 <jle`> join bimap
12:47:07 <Twey> :t join bimap
12:47:08 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
12:47:16 <merijn> ski: Implementing inductive datatypes as an inductive datatypes, which means you do datatype-generic programming on all datatypes, including the datatype of datatypes
12:47:17 <Twey> :t join either
12:47:18 <lambdabot> (a -> c) -> Either a a -> c
12:47:25 <merijn> ski: Assuming I understood correctly xD
12:47:28 <TallerGhostWalt> is there a generic operation to add an element to any container of a certain typeclass
12:47:44 <TallerGhostWalt> like generic insert maybe?
12:47:47 <Drezil> hey! can someone help me with FFI? I need to parse some binary data and the data-type depends on an enum. I have the enum in a datatype "data enum = enum a | enum b | c| ...". Can i inherit instance Storable enum where (enum a) = Storable Word8?
12:48:03 <Twey> TallerGhostWalt: Check out the ‘containers’ package
12:48:14 <merijn> Drezil: No
12:48:23 <jle`> TallerGhostWalt: there is no 'de facto' "Container" typeclass
12:48:28 <Twey> TallerGhostWalt: Sorry, I meant ‘collections-api’
12:48:30 <Twey> http://hackage.haskell.org/package/collections-api-1.0.0.0/docs/Data-Collections.html
12:48:31 <jle`> i think people have tried
12:48:45 <jle`> oh well
12:48:47 <jle`> that is one
12:48:49 <jle`> >.>
12:48:50 <Drezil> so .. i have to do sizof (enum a) = sizeof Word8 etc. for all things i need for the instances?
12:48:52 <ski> merijn : is "Clowns to the left of me, jokers to the right" a Conor McBride paper ?
12:49:11 <merijn> ski: Yeah
12:49:24 <merijn> ski: POPL Pearl
12:50:29 <ReinH> merijn: needs more hole abstractions
12:52:58 <TallerGhostWalt> twey: I like the direction this is headed at least
12:53:09 <ReinH> merijn: which is to say, http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.62.7447&rep=rep1&type=pdf
12:53:39 <merijn> ReinH: Sounds like the fancy way of saying "zippers"?
12:53:52 <Twey> Hrm, is ‘Clowns’ related to that paper on containers that came out recently?  ‘Symmetric Containers’?
12:55:26 <merijn> Twey: Clowns is more "interruptable/resumable traversals"
12:55:27 <ReinH> merijn: well, iinm hole abstractions can replace derivative data structures
12:56:24 <ReinH> merijn: if nothing else they give you a calculus for zippers instead of an algebra.
12:56:47 <ReinH> sometimes having both is nice
12:56:50 <merijn> I have no clue what the difference between a calculus and an algebra of zippers would be :p
12:57:05 <ReinH> well, one lets you use the lambda calculus, the other lets you use category theory :p
12:57:45 <TallerGhostWalt> lens' foldMapOf is pretty darn close to what I want anyway, and no extra typeclasses so that is nice
12:57:56 <ReinH> merijn: basically you can represent the "data structure w/ a hole" as a lambda abstraction instead
12:57:58 <TallerGhostWalt> Is there a reason for the lack of Traversable on Set?
12:58:24 <merijn> TallerGhostWalt: Yes, Set isn't Traversable
12:58:34 <ReinH> it voilates some laws
12:58:38 <merijn> TallerGhostWalt: Traversing it and replacing elements would invalidate the internal ordering
12:58:44 <ReinH> ah right
12:59:07 <chrizz__> does anyone know of a list of useful haskelly research papers? i have a massive collection of them bookmarked from various blogposts and irc chats, but still
12:59:19 <ReinH> chrizz__: http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
12:59:21 <TallerGhostWalt> fair enough I just always forget!
12:59:52 <chrizz__> ReinH: sweet thanks, i'll add this to my massive collection of bookmarks
13:00:14 <ReinH> chrizz__: I actually just had it open :)
13:00:17 <shergill> chrizz__: next up, reading said papers? :P
13:00:29 <chrizz__> shergill: woah woah, slow down
13:00:39 <chrizz__> have you seen that show hoarders
13:00:46 <ReinH> hahaha
13:00:54 <chrizz__> yeah
13:01:34 <ReinH> pretty much
13:01:58 <chrizz__> i mean this brand new can opener is going to come in useful at some point
13:01:59 <shergill> haha
13:02:12 <chrizz__> once my other one breaks
13:02:55 <chrizz__> so i'll just toss it on my big pile of dead cats and dog shit and call it a day
13:04:25 <TallerGhostWalt> catAnyOf l insFcn  = L.foldMapOf (L.traverse.l) (\x -> insFcn x mempty)
13:04:38 <TallerGhostWalt> L is lens
13:04:40 <TallerGhostWalt> I love that
13:05:16 <TallerGhostWalt> two things I need to do all the time, pull out only certain members of a container based on matching a sum type, and trying out diff containers
13:05:19 <edwardk> you can use (folded.l) for a little bit less of a requirement
13:05:56 <edwardk> catAnyOf l f = foldMapOf (folded.l) (f ?? mempty)
13:06:28 <TallerGhostWalt> edwardk: oh man , that is great
13:07:54 <chrizz__> edwardk: you wouldnt happen to have a blog post or video related to that post on r/haskell would you...
13:07:54 <edwardk> catAnyOf l f s = s^.folded.l.to (f ?? mempty)
13:08:15 <chrizz__> the slides are good but some of them need explaining, like one that just says "gotchas"
13:08:20 <edwardk> chrizz__: not me. i don't know if they recorded it. but there are slides and code there at least
13:09:06 <merijn> ski: Unfortunately, I don't think the thesis you linked earlier doesn't seem to try and tackle reflection in a pure environment
13:09:08 <edwardk> :t views
13:09:09 <lambdabot> (Profunctor p, MonadReader s m) => Optical p (->) (Const r) s s a a -> p a r -> m r
13:09:18 <edwardk> so with that, we can go one last step
13:09:37 <merijn> There's a negative to much in there, but you get the gist
13:09:43 <jonnhy> hi there
13:09:59 <n-dolio> What a lovely type.
13:10:00 <edwardk> catAnyOf l f = views (folded.l) (f ?? mempty)  -- shaving a couple more chars, using the fact that when views is passed a traversal or fold it uses the monoid.
13:10:34 <TallerGhostWalt> That makes perfect sense
13:10:48 <edwardk> foldMapOf is probably clearer, but it and 'views' have the same meaning
13:10:59 <edwardk> (the latter works in monad transformer stacks though)
13:11:09 <TallerGhostWalt> I have been sort of figuring out that views had a lot to do with folding
13:11:17 <TallerGhostWalt> just cause I end up talking about it similarly
13:11:30 <TallerGhostWalt> it has that 'out of the structure' feel to it
13:13:23 <Nolrai66> grr, I want to program _something_ but I don't really have any projects I want to do.
13:13:45 <bennofs> Nolrai66: cabal and hackage both have a full issue tracker :p
13:14:02 <`^_^v> write a compiler, a game, an AI
13:14:22 <merijn> Compilers is probably the easiest of those 3 :p
13:14:30 <Nolrai66> bennofs.
13:14:38 <Nolrai66> bennofs: good point.
13:14:38 <chrizz__> Nolrai66: what do you like to do?
13:15:10 <edwardk> Nolrai66: resurrect https://github.com/ekmett/arcade and play with physics in javascript and haskell
13:15:19 <Nolrai66> A compiler could be fun. Hmm. Not sure I belive that its the easist though. Probobly the funnist.
13:15:22 <edwardk> plastic zombies
13:15:29 <`^_^v> it depends on the language
13:15:47 <dmj`> I'm trying to install cabal-1.20 from scratch on a Win64 system. Keep getting, "missing binary operator before token "(" -- Distribution\Client\Compat\Time.hs
13:15:52 <merijn> Nolrai66: Implementing a (simple) compiler is pretty easy
13:16:05 <`^_^v> you can write minesweeper and tetris AIs pretty easily, stuff like chess gets into more sophisticated methods but they are fun to learn about too
13:16:23 <merijn> Nolrai66: Don't try anything complicated, do a minimal language that compiles to C or JS for example
13:16:33 <dmj`> when I call ghc.exe on Main.hs of the unzipped cabal-install-1.20 pkg
13:16:47 <Nolrai66> edwark: Plastic zombies?
13:16:56 <edwardk> er that is probably better linked as http://ekmett.github.io/arcade/static/ (usable in chrome) wasd to move, 1-8 or so spawn things, 0 clears, mouse picks them up, q/e raise/lower.
13:17:38 <edwardk> Nolrai66: if you start the page there you can click 6 and spawn a bunch of plastic zombies that will try to eat your brain for fun.
13:17:59 <edwardk> though it only really works in chrome right now
13:18:12 <edwardk> unless someone goes and fixes the event handling hooks
13:18:30 <bennofs> For me, only was works (or some reason, d doesn't work)
13:19:17 <Nolrai66> <merijn>: I keep getting boged down writing the code to handle the _game_ part, not the ai part.
13:19:38 <edwardk> bennofs: interesting glitch. never seen that one before.
13:20:30 <edwardk> Nolrai66: well, that has a core physics engine and displays, it just needs some love, and i'm too busy to give it to it ;)
13:21:17 <edwardk> anyways, i just threw it out there because you said you were bored and wanted a project
13:22:21 <jonnhy> havent u and easiest project?
13:22:44 <Nolrai66> Hmm. Yeah thanks I think I might look at it.
13:23:07 <DR6> quick question
13:23:13 <DR6> I want to run an IO action
13:23:25 <DR6> so that if it take less than a given time t
13:23:34 <DR6> it waits until that time has passed
13:23:40 <DR6> how would I do that?
13:24:00 <quchen> DR6: You mean you want to make an IO action require "at least N seconds"?
13:24:05 <DR6> yes
13:24:15 <quchen> DR6: Run it concurrently with threadDelay and wait for both to finish
13:24:18 <DR6> so that I don't make too many http requests
13:24:30 <chrizz__> merijn: do you know of any tutorials or books on implementing a simple compiler? i believe you that it's simple but i'm not really sure where to start
13:24:34 <DR6> where is that?
13:24:55 <aloiscochard> edwardk: that arcade game is very hard to play on a dvorak keyboard
13:24:55 <chrizz__> i mean if it compiles to another high level language then what's all there to do... type check and "code gen"?
13:25:04 <edwardk> aloiscochard: aahahaha
13:25:06 <quchen> DR6: There's a simple function in async that does that for you, Control.Concurrent.Async.concurrently
13:25:18 <edwardk> aloiscochard: clearly you should submit a patch to make the keyboard configurable ;)
13:25:27 <aloiscochard> edwardk: that's exactly what I was thinking :-D
13:25:28 <dmj`> what C compiler does cabal need on windows to compile?
13:25:43 <bennofs> cabal needs a c-compiler? :O
13:25:45 <edwardk> jonnhy: i'm not a good source of easy projects. others can help more with that =)
13:25:48 <`^_^v> chrizz__, there is a coursera class on compilers, you should look into it if you want a good general encompassing overview
13:26:05 <dmj`> bennofs: ghc needs to build it to an executable right?
13:26:12 <`^_^v> it has you make a compiler for some toy OOP language
13:26:50 <jonnhy> dmj try code bloclks
13:27:10 <dmj`> johnnhy: what do you mean by code blocks
13:27:10 <Nolrai66> edwardk: will I need to understand javascript to fix it? Because I am pretty sure I've killed all the nerons I used to have that knew JS.
13:27:38 <jonnhy> dmj if you are serching a compiler
13:28:01 <edwardk> Nolrai66: well. there is a stub of a haskell server for it, but its not really wired up to the javascript much right now
13:28:15 <dmj`> jonnhy: I used to have the haskell platform installed, then I uninstalled it on windows, wanted to do everything from scratch, maybe that was a bad idea
13:29:02 <erisco> how can I have ghc only output errors to stderr instead of both stdout and stderr?
13:29:11 <jonnhy> dmj may be so
13:29:27 <chrizz__> what errors does ghc put to stdout?
13:29:50 * hackagebot sqlite-simple 0.4.6.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.6.0 (JanneHellsten)
13:29:54 <chrizz__> and what about 1>&2?
13:30:17 <erisco> chrizz__, is there a flag I can use instead?
13:30:31 <rovar> I have a question about utilizing multiple IO monads simultaneously..  I'm not really even sure how to phrase it
13:30:38 <chrizz__> i doubt it
13:30:49 <chrizz__> what's wrong with redirecting?
13:30:56 <geekosaur> I think if there are errors being send to stdout instead of stderr, that's a bug. stdout should only be status information (as with building multiple modules)
13:31:04 <rovar> but I've had issues with wanting to use, say, a DB IO Monad, and an HTTP IO monad at the same time.
13:31:08 <erisco> geekosaur, I could be wrong I was making a guess
13:31:09 <geekosaur> rovar, there is only one IO monad
13:31:14 <rovar> because I can't really  runMonad either of them
13:31:35 <erisco> I am not sure why I am seeing errors printed twice using the Shake build system
13:31:53 <erisco> :t sequence
13:31:54 <lambdabot> Monad m => [m a] -> m [a]
13:31:57 <chrizz__> rovar: you can't run IO, correct, but why do you want to?
13:31:59 <erisco> rovar, like that rovar?
13:32:30 <chrizz__> red rovar red rovar send rovar right ovar
13:32:48 <rovar> right.. well I guess the issue I have is, let's say I want to execute a query and serve that value as a web response
13:33:02 <chrizz__> query >>= respond ?
13:33:09 <rovar> so I'm running in the IO monad inside of an HTTP response monad.. but from there I can't issue a DB request
13:33:10 <jonnhy> have a question : Is the haskell language like C++ or Java language?
13:33:20 <joelteon> no it isn't
13:33:24 <hpc> jonnhy: it's like ML
13:33:24 <rovar> because the HTTP monad is expecting  somithing like an  IO HTTP Foo
13:33:25 <ReinH> rovar: do you have some code that expresses the problem?
13:33:29 <hpc> (quick, ask what ML is like!)
13:33:35 <joelteon> ML is like haskell
13:33:39 <jonnhy> ML?
13:33:42 <rovar> not at the moment
13:33:43 <erisco> rovar, you can nest monads with monad transformers, but it is difficult to give correct advice without more detail
13:33:51 <DR6> it's not even like lisp
13:33:54 <jonnhy> hpc : ahaha
13:33:55 <chrizz__> rovar: i would take a step back and study monad transformers before trying to tackle this problem
13:34:02 <ReinH> jonnhy: TL;DR: No, it isn't.
13:34:11 <monochrom> erisco, I don't think monad transformer is at hand here
13:34:20 * erisco shrugs
13:34:25 <rovar> erisco:  That seems to be the general solution.. but then I have to create a monad transformer for  IO HTTP MyDB Etc Etc
13:34:36 <rovar> erisco: rather, that is a solution, but its not a general solution..
13:34:48 <jonnhy> they have any common things?
13:34:48 <erisco> rovar, I do not think you understand monad transformers then
13:35:01 * monochrom walks away
13:35:31 <chrizz__> jonnhy: they are both programming languages invented by humans
13:35:55 <chrizz__> with them you can achieve intertubular flight
13:35:56 <dmj`> rovar: the kind of IO is (* -> *), there'd be no way IO HTTP MyDB would typecheck
13:36:02 <rovar> erisco:  maybe not, but looking at something like Yesod's monads,  I found it hard to, say, integrate a new DB because I had to write a transformer that included the 7 other monads in their Request..
13:36:10 <DR6> they have barely any significant similitudes
13:36:13 <Nolrai66> rovar: run the HTTP monad? that should get you a IO a.
13:36:18 <jonnhy> chrizz_ : ahaha mean that there is language programms by aliens?
13:36:45 <DR6> well, unless you count stephen wolfram as human, mathematica is
13:36:50 <DR6> but I'm pretty sure he isn't
13:36:54 <TallerGhostWalt> catAnyOf l f = L.views (L.folded.l) (f L.?? mempty) ... worked great for Set, Sequence and List now I am wondering about keyed stuff like Map
13:36:58 <rovar> Nolrai66:  I don't necessarily need to run the HTTP monad,  I need to run my own monad to issue a request to a DB inside the HTTP monad
13:37:12 <rovar> Nolrai66:  but I can't get such a thing to typecheck..
13:37:24 <chrizz__> rovar: nothing we say here can help you, you're clearly hitting a conceptual wall and need to study monads and monad transformers more, by yourself
13:37:26 <rovar> because the DB request itself is within its own IO monad
13:37:43 <Nolrai66> Well thats because that doesn't really make sense.
13:37:53 <rovar> well that's good to know..
13:38:10 <ReinH> rovar: I don't think you're beyond help, but we seem to be talking in circles.
13:38:19 <Nolrai66> chrizz__: Thats over harsh.
13:38:20 <bennofs> TallerGhostWalt: Map seems to have a Foldable instance, so it should just work
13:38:21 <ReinH> rovar: I think a concrete example would be helpful.
13:38:22 <monochrom> rovar, you have a serious typo when you say "IO HTTP Foo". it is hindering comprehension. everyone's answer is based on false assumptions.
13:38:32 <bennofs> TallerGhostWalt: it will fold over the values
13:38:45 <ReinH> rovar: If you can write a small program that demonstrates the problem I think we'll save a lot of time on misunderstandings.
13:39:02 <TallerGhostWalt> bennofs, yeah I can't get the insert function right
13:39:12 <rovar> ReinH:  that seems to be the best course of action at this point..
13:39:51 * hackagebot twitter-feed 0.1.1.0 - Client for fetching Twitter timeline via Oauth  http://hackage.haskell.org/package/twitter-feed-0.1.1.0 (jsl)
13:40:16 <chrizz__> rovar: didn't mean to discourage you, i remember getting really frustrated when trying to understand Yesod for the first time, as you are now. There's a great introductory paper on monad transformers that I read several times before returning
13:40:19 <ReinH> rovar: If you can convince the compiler to give you a meaningful error, you can probably convince us too. ;)
13:40:23 <chrizz__> rovar: yesod is particularly painful, by the way
13:40:59 <meretrix> Does HSDouble have less precision than Double?  I seem to be losing precision when I return a double from C using haskell's FFI.
13:41:28 <rovar> yea.. i first ran into this issue when trying to build MongoDB support (not sure why) into yesod.  I couldn't write a transformer that seemed to satisfy all of the "wrapped" monads in the handler
13:42:06 <rovar> 'ran into' is the correct phrase, because previously i'd been able to sidestep this issue..
13:44:49 <Phillemann> I have some code using the IO monad which (just for fun) I'd like to "port" to an applicative style.
13:44:52 * hackagebot codex 0.0.1.2 - Code Explorer for Cabal  http://hackage.haskell.org/package/codex-0.0.1.2 (aloiscochard)
13:44:53 <Phillemann> The code uses filterM
13:45:02 <ReinH> Phillemann: showus
13:45:09 <Phillemann> Am I correct that this is kind of a showstopper for applicative?
13:45:14 <monochrom> meretrix: this is compiler-specific. if your compiler is GHC, HSDouble = double, you can see it from the *.h files that come with GHC (starting from HsFFI.h)
13:45:29 <Phillemann> As filterM has the "decision making" property that monad has but applicative doesn't?
13:45:46 <ReinH> Phillemann: does filterM decide based on previous results?
13:45:49 <ReinH> I don't think so...
13:46:00 <monochrom> oh, you also want to know about HSDouble vs Double. OK, they are isomorphic.
13:46:39 <monochrom> that last part is actually general for all Haskell compilers
13:46:41 <ReinH> Phillemann: Ah, no, the predicate is a monadic action.
13:46:54 <Phillemann> ReinH: Hehe, I stumbled on that at first, too. ;)
13:47:25 <ReinH> wah wah
13:49:15 <dmj`> on windows when I run cabal install cabal-install I get, "cabal.exe data is not in tar format", did hackage change or something?
13:49:23 <dwcook> Phillemann, I believe the following rule holds and is relevant: do { a' <- a ; b' <- b ; return $ f a b } = f <$> a <*> b
13:50:22 <chrizz__> filterA f [] = pure []
13:50:36 <chrizz__> filterA f (x:xs) = (\b -> if b then (x:) else id) <$> f x <*> filterA f xs
13:50:54 <monochrom> which is also (f `liftM` a) `ap` b. ap inspired <*>
13:51:12 <meretrix> monochrom: Thanks, so if I lose precision by simply converting from double -> HSDouble -> Double, you would consider that a GHC bug?
13:51:17 <dwcook> Yep, was about to write something quite similar
13:51:22 <dwcook> to chrizz__'s
13:51:34 <dwcook> Using the transformation I mentioned
13:51:48 <dmj`> nevermind, it magically started working
13:51:57 <Phillemann> I think I understand. Thanks you guys
13:51:59 <monochrom> yes meretrix
13:52:15 <dwcook> Oh, I wrote my rule wrong
13:52:24 <dwcook> do { a' <- a ; b' <- b ; return $ f a' b' } = f <$> a <*> b
13:52:32 <monochrom> ah, I missed that typo too :)
13:53:06 <monochrom> for best results, every variable name must be a freshly created random UUID
13:53:41 <dwcook> I wonder if that would be more or less readable than just add primes everywhere
13:54:22 <monochrom> it depends on the reader's abstraction level
13:54:26 <dwcook> Granted I've only ever written up to like two, a''
13:59:55 * hackagebot loshadka 0.2 - Minecraft 1.7 server proxy that answers to queries when the server is offline  http://hackage.haskell.org/package/loshadka-0.2 (LnYnp6WCYyKG3yhdLDztVRuQjTFKEy)
14:11:31 <jle`> when i started i used to routinely do a''' >_>
14:11:48 <jle`> i try to avoid a'' now
14:12:03 <jonnhy> *a' ' '
14:12:18 <bennofs> jle`: what do you do instead?
14:12:46 <jle`> rethinking the names in general
14:12:52 <jle`> if i ever need a''
14:13:04 <quchen> @quote first.26
14:13:05 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
14:13:12 <jle`> lol
14:13:13 <bennofs> heh
14:13:29 <jle`> also i try to avoid a, b for data variables >.>
14:14:01 <jle`> oh if i ever go too prime (a'')...i might consider naming a0, a1, a2
14:14:04 <ReinH> Or use less points. ;)
14:14:14 <jle`> closer to how we do it in physics
14:14:20 <jle`> idk about you weird math peoples
14:14:22 <ReinH> One advantage of the pointfree style is not giving things names that don't deserve them.
14:14:49 <jle`> <ReinH> one advantage of pointfree style is not having points
14:14:53 <quchen> One disadvantage of the pointfree style is not giving things names that do deserve them.
14:15:23 <solrize> :t (.)(.)(.)(.)(.)
14:15:24 <lambdabot> (b1 -> c) -> (b -> b1) -> (a -> b) -> a -> c
14:15:45 <jle`> also i hope i am not the only one who thought "why is it point-free when you use more (.)'s" when first learning haskell >_>
14:16:09 <monochrom> I avoid "a" because it gets too close to English "a". I avoid "foo" because everyone already uses "foo".
14:16:19 <ReinH> quchen: That's true. It's almost like you're making a tradeoff and there aren't absolute answers. ;)
14:16:41 <jle`> sometimes i do x_, x__, x___
14:16:43 <bennofs> If there was a mode for emacs that colered a', a and a'' differently, that would be super helpful
14:16:43 <ReinH> jle`: Nope. Almost everyone.
14:16:45 <jle`> (just kidding, i don't)
14:16:56 <jle`> oh!
14:16:59 <jle`> i remember when i first started
14:17:03 <jle`> i did x, xx, xxx a lot
14:17:06 <jle`> i don't know where that came from
14:17:09 <ReinH> monochrom: also mixing `a's at the type level and `a's at the expression level is confusing
14:17:18 <ReinH> People already have enough trouble distinguishing those levels.
14:17:25 <quchen> Even though Haskell is independently typed.
14:17:27 <monochrom> I am the only one who did not think "why is it pointfree when there are many dots"
14:18:01 <ReinH> xsssss :: [[[[[a]]]]] ;)
14:18:14 <jle`> that actaully seems kind of fair
14:18:34 <enthropy> ReinH: doesn't it help to reuse names in cases like "data Foo = Foo" for you?
14:18:37 <quchen> I don't think [[[[[[[ is ever "kind of" fair.
14:18:42 <archblob> does anyone know why might ghc scream "parse error on input `import'" when doing a simple foreign import ?
14:18:43 <monochrom> indeed ReinH, I write like this: data Whee b = Ctor b; return :: b -> Whee b; return x = Ctor x.
14:18:54 <ReinH> monochrom: right
14:19:06 <quchen> archblob: Could you paste the code?
14:19:07 <quchen> @paste
14:19:07 <lambdabot> Haskell pastebin: http://lpaste.net/
14:19:08 <jle`> quchen: well, if i ever saw xsssss, i would know exactly and unambiguously what it was referring to :)
14:19:08 <archblob> other projects build just fine
14:19:15 <ReinH> monochrom: I used to write return b = Ctor b and then I hated it when I had to read it later
14:19:44 <ReinH> archblob: my money's on typo. :)
14:20:05 <ReinH> jle`: once you counted the `s's
14:20:15 <monochrom> enthropy: "data Foo = Foo" is great for industrial code. not educational code.
14:20:25 <quchen> Unary encoding is scaringly easy to reinvent.
14:20:40 <archblob> quchen, ReinH how else do you spell "import" ?
14:20:55 <bennofs> archblob: maybe you're missing {-# LANGUAGE ForeignFunctionInterface #-} ?
14:21:09 <archblob> quchen, ReinH http://lpaste.net/103209
14:21:18 <ion> archblob: Perhaps this helps. https://www.youtube.com/user/PronunciationManual
14:21:19 <monochrom> archblob: see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#haskell2010
14:21:39 <archblob> bennofs, there is no missing pragma, and i use a simple cabal executable build
14:21:47 <zq> archblob: >foreing< import ccall unsafe "fillString"
14:22:02 <ReinH> There it is.
14:22:19 <matematikaadit> I'm running this code http://lpaste.net/103208 using runhaskell and also ghc main.hs && ./main. The runhaskell version took 2 minutes to run, meanwhile the compiled version just took 8s (compilation phase included). Why such the difference?
14:22:20 <archblob> whoo i'm such a dumbass
14:22:28 <ReinH> archblob: you are definitely not a dumbass.
14:22:33 <ReinH> well, maybe, but this is not evidence.
14:22:52 <monochrom> I feel unsafe about the "unsafe" part, though :)
14:23:03 <ReinH> Will everyone in #haskell who has never made a typo please raise your hand?
14:23:06 <quchen> archblob: Aaaand that's why we insist in code pastes. This doesn't make you a "dumbass", it happens to everyone. But try to imagine how long we would have taken to debug this had you not pasted it. :-)
14:24:06 <zq> ReinH: o/
14:24:20 <monochrom> always show self-contained reproducible experiments
14:24:31 <archblob> quchen, ReinH, monochrom , zq well, thank you guys :-)
14:25:26 <quchen> monochrom: I vote to add "small" to that list
14:25:43 <ReinH> zq: :p
14:26:00 <ReinH> quchen: or even "minimal" :)
14:26:27 <quchen> ReinH: Back to absolute statements eh :-þ
14:26:33 <ReinH> quchen: :p
14:26:37 <ReinH> it's nice to have goals
14:26:52 <archblob> things is, something needs to be done about that error message :)
14:28:13 <monochrom> ideally, you are right to require small or minimal. but I am writing to humans. humans who are selective on what they read. if I have all of "small", "self-contained", "reproducible", then humans will just read "small".
14:28:44 <quchen> In GHC's defense, when you misspell something it often suggests the right thing already. Not on a parser level though (but for modules, values, ...)
14:29:08 <archblob> yes it usually does
14:30:15 <monochrom> along that line, I may cut it to "self-contained demonstration" next time
14:30:16 <ReinH> monochrom: maybe http://www.sscce.org/
14:30:32 <dmj`> I'm trying to install text-1.1.0.1 on windows-64. Fresh install of haskell platform. I get the following: http://lpaste.net/103210 "cannot satisfy -package-id array-0.5.0.0" when I try to install array it says it's already there
14:30:46 <monochrom> oh, that's a great page, but I will have problem remembering its url!
14:30:53 <ReinH> monochrom: heh
14:31:29 <ReinH> Short, Self Contained, Correct (Compilable), Example http://www.sscce.org/
14:31:34 <ReinH> for all your quoting needs
14:32:24 <monochrom> also we can't possibly require "compilable". obviously, some examples must be uncompilable, it's the whole point of those examples because the questions are about a type error.
14:33:17 <monochrom> dmj`: is your GHC 7.8.*?
14:33:41 <jle`> compilable is for languages where you can actually compile incorrect code
14:33:52 <jle`> hehe
14:38:02 <dmj`> monochrom: 7.6.3
14:38:02 <monochrom> oh, your GHC is 7.6.3. now I can't see why it wants array-0.5.0.0. because here I just have array-0.4.0.1 (comes with GHC) and text-1.1.0.1 is pretty happy with it
14:38:53 <monochrom> I recommend you stick to whichever array that comes with GHC and avoid newer versions
14:39:05 <monochrom> get rid of all new versions.
14:40:19 <dmj`> monochrom: ok sounds good. Does Cabal-1.20 mandate ghc-7.8.* ?
14:40:27 <skypers> where is thunk from?
14:40:29 <skypers> I mean the word
14:40:32 <skypers> is it from chunk?
14:40:37 <skypers> what would the t be?
14:40:53 <monochrom> I don't know
14:41:05 <dmj`> cabal install cabal-install (1.2 version) says base 4 -> 5.
14:41:26 <dmj`> I'm just going to overwrite all the ghc, runghc, ghci w/ the 7.8.2 versions
14:41:48 <dmj`> I think my package cache didn't get removed on uninstall, stay tuned!
14:42:21 <monochrom> well yeah, the "local" package db is untouched
14:44:52 <monochrom> eh? I just tried "cabal install --dry-run cabal-install" with ghc 7.6.3. totally nothing that says a newer base, a newer array, or a newer text.
14:45:01 <monochrom> Resolving dependencies...
14:45:01 <monochrom> In order, the following would be installed (use -v for more details):
14:45:01 <monochrom> Cabal-1.20.0.0
14:45:01 <monochrom> cabal-install-1.20.0.0
14:45:07 <monochrom> THE END
14:45:44 <bergmark> O_o
14:45:51 <monochrom> what is going on with your local package db? erase it. erase it all. http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
14:46:59 <dmj`> so me right now: http://i.imgur.com/4owJPOp.jpg
14:47:11 <chrisw_> Is there an "empty" parser in parsec? I would like to parse open/close brackets with nothing inside using Token.brackets, and it expects a parser as an argument.
14:47:34 <dmj`> monochrom: I wiped it, copied new 7.8.2 ghc's and am install 1.20
14:47:37 <monochrom> chrisw_: consider "return ()"
14:47:40 <dmj`> installing*
14:47:58 <chrisw_> monochrom, ok thanks
14:48:19 <monochrom> well, that is an overkill to get a new start, but it is a new start
14:49:14 <dmj`> I always forget the -j flag
14:49:19 <jle`> how about return undefined
14:49:52 <monochrom> dmj`: in the future, take a look at the directory %APPDATA%\ghc. there are further subdirectories, one for each ghc version.
14:50:16 <dmj`> monochrom: do you use cygwin?
14:50:22 <monochrom> I don't
14:50:27 <dmj`> mingw?
14:50:31 <chrisw_> monochrom, I just found parserZero, would that be of any use?
14:50:42 <monochrom> not directly. ghc uses mingw. I use ghc.
14:51:12 <dmj`> monochrom: I can't build network on anything but cygwin since it can find the C libs
14:51:17 <monochrom> parserZero requests a parse error
14:51:47 <monochrom> I haven't built network on windows. I just use the Haskell Platform installer and be done with it.
14:52:40 <dmj`> what terminal do you use, just a dos prompt?
14:53:11 <monochrom> I am also emphatically not a latest-version fiend
14:53:16 <monochrom> yes
14:53:41 <monochrom> "cabal-install 1.20 is out? cool, good for you. not going to bother"
14:54:37 <dmj`> monochrom: I was a sucker for the cabal freeze feature
14:54:54 <monochrom> well actually, sometimes I bother. (I have built 1.18.) but always "cabal install --dry-run" first to see how much trouble. if trivial, bother; if non-trivial, don't bother.
14:55:29 <dmj`> I think configuring haskell can be harder than actually writing haskell code :P
14:55:44 <monochrom> if grey area, build in a sandbox
14:56:03 <monochrom> well, if you use hugs, this will be trivial
14:56:19 <dmj`> monochrom: I'm sharing a sandbox across ubuntu, windows and osx w/ vagrant
14:56:45 <monochrom> not that kind of sandbox
14:56:51 <dmj`> it's flawless from ubuntu to osx, but cygwin ruins everything
14:56:59 <dmj`> oh, what kind
14:57:11 <monochrom> the "3rd package db for ghc" kind of sandbox
14:57:20 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
14:57:49 <monochrom> you may as well quit irc and read the whole article from start to finish, 3 times, starting now.
14:58:35 <dmj`> you see, links like this are gold.
14:58:40 <dmj`> think I will
14:58:56 <monochrom> unfortunately I'm too lazy to provide windows directory names. but change "$HOME" to "%APPDATA%" and other minor differences
14:59:23 <dmj`> "unsafeInterleaveInstall" ha
15:00:34 <dmj`> this guy is funny
15:00:44 <monochrom> that is me
15:00:51 <dmj`> you're quite humorous :P
15:01:01 <dmj`> that's a compliment !
15:01:07 <monochrom> thank you
15:15:04 <chrisdone> hai
15:15:22 <ski> hiya
15:16:43 <quchen> chrisdone: Wooo hello!
15:16:56 <chrisdone> hey quchen =)
15:17:08 <quchen> Nice to see you again! Internet blackout intermission? :-)
15:17:38 <chrisdone> yeah, i was wondering if anyone wanted to arrange a haskell hangout sometime
15:17:59 <chrisdone> we could get together and pair program or mess about with emacs or something
15:18:15 <chrisdone> swap tips
15:18:41 <chrisdone> IRC seems a bit quiet at the moment, tho
15:18:42 <pii> liftM2 (&&) f g -- it seems to me like g is run even if f is false, is that expected behaviour?
15:18:46 <quchen> I'm unfamiliar with that format of coding.
15:18:47 <monochrom> long time no see chrisdone. I want to congratulate you on lpaste exceeding 100000 pastes!
15:19:13 <quchen> pii: Yes it is. liftM2 always performs both actions given to it.
15:19:20 <quchen> @src liftM2
15:19:20 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:19:21 <pii> quchen: oh :/
15:19:30 <TallerGhostWalt> emacs
15:19:34 <pii> is there any function that will short-ciricut?
15:19:35 <TallerGhostWalt> it is so great
15:19:37 <TallerGhostWalt> lol
15:19:47 <TallerGhostWalt> I have converted everyone in the office
15:20:00 <chrisdone> monochrom: o/ haha, we're now a 100k paste site!
15:20:04 * hackagebot extensible-effects 1.4.1 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.4.1 (BenFoppa)
15:20:09 * chrisdone pops a beer 
15:20:15 <quchen> Cheers :-)
15:20:22 * quchen pops a couple of cashews
15:20:42 <chrisdone> the nut or the fruit?
15:20:59 <quchen> The nut. (There's a fruit? An edible one?)
15:21:05 <quchen> pii: None that I know of. You can easily write it yourself though.
15:21:53 <chrisdone> apparently you can get nice juice from the cashew apple. i've never tried it, honestly
15:22:12 * chrisdone blocks view of cashew-splattered blender
15:22:30 <pii> quchen: ok, thanks
15:22:46 <quchen> To come back to your hangout, I'd like to at least sit in, not sure whether I could contribute much. I haven't hung out yet.
15:23:02 <quchen> Worst case is I get to see some people from the channel face to face, FSVO face
15:23:19 <chrisdone> monochrom: i'm quite happy with the low level of spam on lpaste, people are quite diligent at reporting it
15:23:29 <quchen> (Wait, that came over somewhat offensively. Not intentional.)
15:24:08 <chrisdone> quchen: yeah, i was thinking a cam isn't even necessary, we could share screens. me and johnw do that a lot to show what we're hacking on and swap tips
15:24:26 <quchen> Oh right, you're both working for FPComplete (?)
15:24:54 <chrisdone> sure, well, we just hangout too
15:26:42 <quchen> pii: As a little background info, liftM2 is mostly there for historical reasons, it's the monadic equivalent to liftA2 for Applicative. Applicative on the other hand does not allow computations to take previous results into account, so it always has to perform all actions, regardless of intermediate results.
15:26:46 <chrisdone> i'm currently faffing about with an idea of pretty printing haskell data structures with typeable for consumption by emacs, web browser, etc
15:27:56 <chrisdone> my design is like: data Presentation = Integer !Integer | Floating !Double | Char !Char | Alg !Text ![ID] | None deriving (Show)
15:27:56 <quchen> chrisdone: Sounds related to typesafe Binary?
15:27:56 <chrisdone> and then: present :: Data a => a -> Maybe ID -> Presentation
15:27:56 <chrisdone> so the idea is to print lazily. so if you have an infinite list, the output will be: Alg "Prelude.(:)" [1] -- for example
15:28:35 <pii> quchen: makes sense
15:29:49 <quchen> chrisdone: Alg? ID?
15:29:51 <chrisdone> hm, well, let me choose a better example. present (Foo 'a' (1::Int)) Nothing → Alt "Foo" [1,2]. now the client will show Foo … …. when you click the first slots, it requests present (Foo 'a' (1::Int)) (Just 1) and you get back 'a'
15:29:57 <chrisdone> algebraic
15:30:05 * hackagebot refcount 0.0.0 - Container with element counts  http://hackage.haskell.org/package/refcount-0.0.0 (BenFoppa)
15:30:11 <chrisdone> the ID can be some list of integers or text, some unique id for a node in the tree
15:30:48 <chrisdone> the idea is you can have lazy expansion of data types. an infinite list should be printed immediately and let you expand evaluation gradually, or an infinite tree, etc
15:30:58 <chrisdone> the lazy printer haskell deserves, right? =p
15:31:12 <chrisdone> (i'm quoting mgsloan there)
15:32:04 <quchen> Ah, so a click is evaluation to WHNF then, and each thunk is clickable
15:32:11 <chrisdone> right!
15:32:54 <chrisdone> (the client could request some depth which it considers reasonable for displaying visually and decide when to stop forcing thunks, in maybe a breadth-first expansion)
15:33:57 <quchen> That sounds at least interesting. sprintf in GHCi is pretty much a very basic version of this.
15:34:14 <quchen> Fiddling around to just evaluate the thunk you want is quite tricky there :-)
15:34:17 <chrisdone> hmm, that's true actually
15:35:11 <chrisdone> how do you expand gradually with sprint?
15:35:18 <chrisdone> λ> let x = [1..]
15:35:19 <chrisdone> λ> :sprint x
15:35:19 <chrisdone> x = _
15:35:21 <chrisdone> how do i go further?
15:35:39 <chrisdone> i suppose it doesn't know where i want to deconstruct
15:35:46 <quchen> That's why I said 'tricky' :-)
15:35:54 <quchen> length (take 3 x)
15:36:01 <chrisdone> okay, then my idea is still cool =D
15:36:08 <quchen> Oh yes!
15:37:43 <chrisdone> we were thinking it could also display bitmaps and things, e.g. if there is a Diagram in the code it could render it. but that needs more design work
15:38:17 <chrisdone> do you have google hangouts?
15:38:26 <quchen> So the nice presentation is a key idea then
15:38:29 <quchen> Yep
15:40:05 <chrisdone> so adding you
15:41:20 <chrisdone> ring ring!
15:45:07 * hackagebot Tables 0.1.0.1 - A client for Quill databases  http://hackage.haskell.org/package/Tables-0.1.0.1 (NatePisarski)
16:31:58 <litb> hello all
16:32:18 <litb> is the notion "Weak Head Normal Form" general CS terminology, or a haskell specific term?
16:32:37 <litb> I haven't found scientific documents about it (i.e on university sites)
16:34:38 <dagle> litb: http://en.wikipedia.org/wiki/Beta_normal_form
16:34:47 <Nahiyan> hey uh, what's the math bot here? I saw it join ##math
16:35:00 <litb> dagle, i don't understand the expression on wikipedia
16:35:07 <litb> it seems to restrict what I found on other pages
16:35:33 <litb> contradict i mean
16:35:47 <dagle> "A term is in head normal form if there is no beta-redex in head position."
16:36:07 <litb> "A beta reduction is in head position if it is of the following form: ..."
16:36:29 <litb> and it goes on to say that it is in head position if the beta reduction reduces within a lambda body
16:37:06 <litb> but what I have found elsewhere is that beta-redex in head position means that we can't beta-reduce on the toplevel
16:39:00 <pavonia> Nahiyan: Not really a math bot, but there's lambdabot
16:39:13 <Nahiyan> ah
16:39:20 <Nahiyan> that's the one
16:39:33 <Nahiyan> @join ##programming
16:39:33 <lambdabot> Not enough privileges
16:39:36 <litb> or it uses the lambda abstraction as a non-greedy construct, i.e that \x.(x+1)10  does not mean \x.((x+1)10), but everywhere else, \x. goes to the very right all thr way through
16:39:37 <Nahiyan> ;_;
16:42:58 <DarkLinkXXXX> Is there something similar to haskell (or ghc), but little lighter?
16:45:33 <pavonia> Define lighter
16:46:28 <vermeille> Which editor IDE/do you use? I was using FPcomplete which is fairly good but my trial period just ended. Do you advise Leksah or vim (plugins? vim2hs sounds powerful but heavy)?
16:46:56 <DarkLinkXXXX> pavonia, for embedded purposes.
16:47:45 <pavonia> I don't know
16:51:01 <monochrom> I recommend paying for FPComplete
16:54:29 <Ralith> vermeille: many use emacs
16:54:50 <merijn> vermeille: I use vim with vim-hdevtools and that's about it
16:55:00 <DarkLinkXXXX> monochrom, but... mah freedumbs!
16:55:01 <merijn> Well, syntastic but that's not haskell specific
16:55:14 * hackagebot dynamic-cabal 0.3.1 - dynamic-cabal  http://hackage.haskell.org/package/dynamic-cabal-0.3.1 (BennoFuenfstueck)
16:55:25 <monochrom> pay for freedom.
16:58:19 <vermeille> monochrom: are you working for FPcomplete :D?
16:58:33 <monochrom> no. but I am a capitalist.
16:58:43 <vermeille> I am a poor student
16:58:59 <monochrom> then too bad
16:59:16 <monochrom> but FPComplete has a provision for students, no?
16:59:29 <edwardk> they have a thing where students/open source folks can use it somehow
16:59:30 <chrisdone> monochrom: i'll send you the cheque later ;)
17:00:19 <monochrom> I love cheques. they are so cashable. for the cashable ones.
17:00:31 <monochrom> (I love tautologies too.)
17:00:31 <ion> I don’t think i have ever seen a cheque IRL.
17:01:00 <monochrom> I write one cheque per year to my remote unix shell account provider.
17:01:23 <monochrom> it is also the only postal stamp I use every year
17:02:04 <vermeille> Hum, I didn't find any academic offer. Also I can't accept not being able to push on github (what an expired account disallows, if I'm not mistaken)
17:03:12 <chrisdone> http://hackage.haskell.org/package/frisby
17:04:03 <chrisdone> http://repetae.net/computer/frisby/
17:05:16 * hackagebot mvc 1.0.0 - Model-view-controller  http://hackage.haskell.org/package/mvc-1.0.0 (GabrielGonzalez)
17:08:09 <[swift]> it's kinda nifty that you can release a package on hackage without announcing it anywhere and people start downloading it
17:08:39 <[swift]> i guess people find these packages through search but the pessimist in me wonders if it's not all just bots =)
17:09:19 <benbangert> so uh, does anyone know what this means? user error (RTS doesn't support multiple OS threads (use ghc -threaded when linking))
17:09:22 <bennofs> [swift]: I think my download numbers are skewed by travis-ci downloading the package for each build
17:09:29 <benbangert> I added -threaded to my ghc-options, no help
17:09:30 <ion> My obscure package for which i expect very few users has been downloaded 70 times in the last month. It does sound like bots to me. :-P
17:09:54 <[swift]> bennofs: ahh, that's a good point i hadn't thought of
17:10:33 <[swift]> ion: heh, same. i'm up to 83 for a library for interfacing with bugzilla that i really wouldn't expect to be that popular
17:15:18 * hackagebot cereal-text 0.1.0.0 - Data.Text instances for the cereal serialization library  http://hackage.haskell.org/package/cereal-text-0.1.0.0 (ulikoehler)
17:33:17 <dmj`> question: Suppose hypothetically someone wanted to write bindings to some http api and wanted to use either http-streams or http-conduit. I know it's possible to write the code in such a way to be able to use one or the other, but can you make the backend a conditional dependency triggered by a flag. So like "cabal install mypkg -fconduit" vs "cabal install mypkg -fiostreams"
17:33:42 <dmj`> so not *both* are installed
17:34:02 <felixn> https://gist.github.com/munro/11308178 <-- hey there, I think I'm approaching monad transformers...  I'm trying to combine IO + State, I think I need to use lift... not really sure >_<
17:34:58 <dmj`> felixn: you need StateT
17:35:00 <dmj`> :k State
17:35:02 <lambdabot> * -> * -> *
17:35:05 <dmj`> :k StateT
17:35:06 <lambdabot> * -> (* -> *) -> * -> *
17:35:15 <dmj`> do you see the higher-kindedness?
17:35:35 <dmj`> you'll be able to embed IO as a base monad
17:35:52 <dmj`> type StackState = StateT [Integer] IO ()
17:35:57 <felixn> HMMMM
17:36:10 <dmj`> State s m a, m == IO... the Kind of IO is (* -> *)
17:36:39 <dmj`> StateT ([Int] :: *) (IO :: * -> *) (() :: *)
17:36:42 <dmj`> :k ()
17:36:43 <lambdabot> *
17:37:19 <felixn> thanks, I'm going to play around with this some more!
17:37:55 <dmj`> :t flip execStateT [1..10] $ get >>= liftIO . mapM_ print
17:37:56 <lambdabot> (MonadIO m, Show t, Num t, Enum t) => m [t]
17:38:23 <itsmonktastic> felixn: 'IO (StackState Integer)' essentially reads to me as an IO-ful computation that results in a StackState-ful computation. I presume you want an (IO & StackState)-ful computation? Which yeah, you'd want StateT as suggested above to build.
17:39:59 <felixn> itsmonktastic: yea, now make it work!
17:40:01 <enthropy> dmj`: in your cabal file you can have   if flag(conduit)\n build-depends: http-conduit\n else\n build depends: http-iostreams
17:40:09 <dmj`> felixn: something cool, modify is do { n <- get; put (f n); }
17:40:31 <dmj`> > flip evalState 5 $ modify (+1)
17:40:33 <lambdabot>  ()
17:40:43 <dmj`> > flip execState 5 $ modify (+1)
17:40:45 <lambdabot>  6
17:41:16 <enthropy> there's not really a way to express that only one of two flags can be enabled in a cabal file
17:41:16 <felixn> dmj`: ah ok, I'll clean it up
17:41:49 <dmj`> enthropy: interesting, can I check for those flags in the code?
17:42:28 <enthropy> yeah, check stuff in dist/build/autogen/
17:42:30 <dmj`> felixn: it's not dirty, put your push function could be push a = modify (a:)
17:42:33 <dmj`> but*
17:42:49 <enthropy> maybe you can do it with the Paths_yourPackageName
17:43:00 <enthropy> but for sure you can do it with the CPP macros
17:45:04 <dmj`> enthropy: interesting...
17:45:10 <dmj`> enthropy: I'll look into it
17:45:24 <dmj`> I really just need to read the ghc user guide in full
17:46:16 <enthropy> probably read cabal's manual instead
17:47:15 <dmj`> I did read that one lol. Shows my reading comprehension :P I have build-depends for conditional packages on windows, but haven't used CPP macros for code stuff yet. So you're saying cabal flags can be referenced via CPP macros?
17:50:53 <enthropy> hmm, maybe you have to add a cpp-options
17:51:31 <enthropy> as in,   if flag(conduit)\n cpp-options: -DUSE_CONDUIT
17:52:01 <enthropy> #if USE_CONDUIT -- can happen in your files that have the CPP extension enabled
17:52:06 <DarkLinkXXXX> monochrom, I'll pay for FP Complete with source code included. ;)
17:55:57 <felixn> https://gist.github.com/munro/11308178 <-- I think the functions are good, now to just unwrap the StateT in the main function ... I think I need something besides runState .. and to use a <- this time
17:58:42 <pavonia> felixn: use runStateT
18:00:08 <felixn> pavonia: I just found that... thanks a lot!! bwahahaha the things I can do now
18:04:30 <structuralist> I'm pretty new to performance optimizing; how would you optimize something like this? (More detailed question in comments) http://lpaste.net/103214
18:06:19 <napping> structuralist: why are you not sharing the result?
18:06:52 <structuralist> because I don't really know what sharing is :P
18:07:22 <felixn> sharing is caring
18:07:35 <napping> It's a bit odd to even pack the update function as a field, rather than having a separate function for the update
18:08:14 <structuralist> yeah I know it's odd but it's that way for a reason (simple model of a more complex situation)
18:08:26 <structuralist> how would sharing work in this case?
18:08:39 <napping> but the smallest change from your code is to change (and maybe reanme) mkT to take Expensive Int instead of a plain int
18:08:54 <napping> maybe rename it mkT' or something
18:08:54 <mm_freak> structuralist: not shared: (f x, f x);  shared:  let y = f x in (y, y)
18:09:07 <napping> and then mkT x y = mkT' (expensive x) (expensive y)
18:09:19 <mm_freak> structuralist: whenever something has a name, it likely refers to one object in memory as well
18:09:25 <napping> like, when you replace the x component, don't throw away and recompute the y component
18:10:06 <mm_freak> structuralist: in the nonshared variant you will find that 'f x' is actually calculated twice, while in the shared variant it's calculated once and then, well, shared =)
18:13:36 <chrisdone> i'mma going to bed, ciao guys!
18:15:24 <structuralist> great! okay, so now I have this: http://lpaste.net/103215
18:16:58 <structuralist> is there a slick way to avoid writing "expensive x" twice?
18:17:44 <structuralist> in my actual situation I have a lot of expensive fields with expressions I'd rather avoid having to make their own functions or write twice
18:18:11 <napping> Why don't you have more ordinary field updates?
18:18:29 <structuralist> conceptually T is supposed to model a self-contained interactive system
18:18:57 <napping> oh, so you want to allow crazy codata tuff
18:19:01 <structuralist> exactly :)
18:19:35 <napping> then it's not surprising you need to repeat things
18:19:38 <structuralist> I don't want to recompute the state of the entire system at every step
18:19:45 <dmj`> hs3 needs to use iteratees...
18:19:47 <structuralist> why not?
18:19:55 <napping> the fact that feeding (Left x) decides to call expensive on x is part of the description of that particular system
18:20:28 <napping> you could just as well make another value of type T that incremented x or y depending on whether the argument to Left was even
18:24:00 <napping> A good design will depend on just what sorts of behavior you want to program, but you can probably use record update syntax a bit more
18:24:38 <napping> like, define fieldUpdate t (Left x) = t { a = expensive x); fieldUpdate t (Right x) = t {b = expensive x}
18:25:02 <napping> and then withFieldUpdate t = let t' = t {(!) = fieldUpdate t'} in t'
18:25:53 <napping> er, you'd need some way to put more behavior
18:26:07 <napping> and then withFieldUpdate t = let t' = t {(!) = withFieldUpdate . fieldUpdate t'} in t'
18:26:21 <structuralist> this seems to work: Left  x' -> t { a = a (mkT x' y ) }
18:26:36 <structuralist> (for line 22 of the original version)
18:27:11 <napping> not quite, if you don't also change the (!) field then sequences of commands will all give you updates against the original record
18:27:38 <structuralist> oh you're right, didn't look closely enough
18:47:25 <Javran> Why reactive-banana-wx doesn't have a document on hackage but I do spot some haddock document in its source code?
18:49:06 <Axman6> Javran: some packages can't build on hackage because their (usually C based) dependencies don't compile or aren't installed on the server
18:49:27 <Axman6> so I'd guess WxWidgets isn;t installed on the server
18:50:41 <Javran> Axman6: I see, so can I find these documents somewhere else or I have to check the source code?
18:55:43 <flebron> Hey. Is a function called (-->) Haskell98?
18:58:09 <bergmark> i'd think so
18:58:30 <shachaf> No.
18:58:36 <bergmark> O_o
19:00:05 <shachaf> At first I read that as "Is there a function called (-->) in Haskell98?". The answer was no. Then I read that as "Is a function called (-->) in Haskell98?". The answer is still no -- the constructor for a function is called (->).
19:00:20 <shachaf> Now I actually looked at the question and I can't parse it at all.
19:00:36 <bergmark> haha same here :-D
19:00:53 <Rarrikins> @faq Hey. Is a function called (-->) Haskell98?
19:00:53 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
19:01:00 <geekosaur> --> is compatible with haskell98, yes
19:01:11 <bergmark> i read it as "is (-->) a legal function name in Haskell98?", which it is :-)
19:01:48 <geekosaur> (I'm guessing this is the xmonad ManageHook function...)
19:02:12 <geekosaur> hm, or does qc have one too?
19:03:32 <geekosaur> anyway that's why haddock makes you write e.g. -- |
19:03:34 <enthropy> Javran: you can probably poke the maintainer to upload docs
19:03:41 <geekosaur> --| would be an operator, not a comment
19:05:37 <conal> bergmark: i use that name fairly often: (f --> h) g = h . g . f
19:07:52 <Javran> enthropy: can maintainer upload the document? I thought they were generated from the server side.
19:08:52 <enthropy> yes they are normally generated, but you can upload docs you generated on your own machine
19:08:53 <geekosaur> upload is permitted as a fallback; they can't be generated on the server side if the server can't build the package, say because it's for windows (it's a linux box) or it requires C libraries not on the buildbot
19:10:34 <Javran> enthropy: how to do that? they are not included in the tarball generated from cabal sdist
19:10:40 <kmspriyatham> in ghc, I saw that H stands for heap size in the argument -with-rtsopts, likewise what does K mean?
19:11:50 <geekosaur> stacK?
19:11:57 <geekosaur> bad mnemonic...
19:12:27 <kmspriyatham> geekosaur, oh, thanks. Is the default 32m?
19:12:44 <geekosaur> ghc:   -K<size> Sets the maximum stack size (default 8M)  Egs: -K32k   -K512k
19:12:57 * geekosaur used: ghc +RTS --help
19:13:23 <geekosaur> cheap way to get an rts options summary :)
19:14:34 <vanila> hello
19:14:54 <vanila> how do I use cabal package that is sandboxed?
19:15:05 <kmspriyatham> ghc <myfile.hs> -with-rtsopts="-H256m -K64m" will this work as expected?
19:15:23 <enthropy> Javran: I use a script like http://lpaste.net/103218, there are some others around
19:16:27 <vanila> I also have a dist build (.zip), but I don't know how to install it
19:16:53 <geekosaur> kmspriyatham, it should
19:17:00 <enthropy> I think it's just adapted from http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html or maybe https://gist.github.com/stbuehler/7068764
19:17:11 <kmspriyatham> geekosaur, thank you very much
19:18:32 <Javran> enthropy: marked, thanks for the info!
19:21:20 <vanila> I've found out how, cabal repl
19:27:35 <flebron> shachaf: Can I define a function called (-->) in Haskell98?
19:28:58 <shachaf> Yes.
19:28:59 <dmj`> I'm trying to install snap on windows, but am running into a linking error w/ unix-compat here: http://lpaste.net/103219
19:29:19 <shachaf> Now I follow the phrasing, more or less.
19:29:50 <dmj`> didn't have this issue w/ 7.6.3
19:32:00 <kmspriyatham> geekosaur, I have tried this ghc patricia.hs -with-rtsopts="-K32m" but my program still stops at a stack size of 8M
19:33:11 <geekosaur> what I don't remember off the top of my head is whether -with-rtsopts implies -rtsopts (many RTS options don't work without it)
19:34:28 <kmspriyatham> The ghc guide mentions that it should work https://www.haskell.org/ghc/docs/7.6.3/html/users_guide/runtime-control.html
19:35:39 * hackagebot Tables 0.1.0.2 - A client for Quill databases  http://hackage.haskell.org/package/Tables-0.1.0.2 (NatePisarski)
19:35:45 <dmj`> kmspriyatham: why not just ghc Main.hs -rtsopts && ./Main +RTS -K32M
19:36:45 <kmspriyatham> dmj`, that doesn't work
19:37:15 <geekosaur> doens't work how? (this makes me wonder if something more fundamental is wrong)
19:38:26 <kmspriyatham> if I do ghc patricia.hs -with-rtsopts=-K32m followed by ./patricia , I get "Stack space overflow: current size 8388608 bytes. Use `+RTS -Ksize -RTS' to increase it." this error
19:43:05 <geekosaur> kmspriyatham, did you actually try what dmj` suggested though?
19:43:19 <Platz> hrm, judging from http://hackage.haskell.org/packages/top "free" seems much more popular than "operational"
19:43:37 <kmspriyatham> geekosaur, yes I did.
19:43:39 <Platz> (i think those providie some overlap in functionality)
19:44:47 <apples> is there a way to install a package into my cabal sandbox and add it to build-depends in my .cabal file at the same time? sort of like "npm install --save-dev" for node packages
19:53:35 <dmj`> it looks like network can't link on Windows
19:53:37 <dmj`> http://lpaste.net/103220
19:54:01 <dmj`> unknown symbold shutdownWinSock
19:54:10 <dmj`> :( :( :(
20:06:17 <Guest61369> my socks stink
20:10:55 <kmspriyatham> geekosaur, I had to upgrade from 7.6.3 to 7.8.2. It works now, thanks
20:16:00 <Guest61369> Is the latest version 7.8.2 and is it included in the windows platform download?
20:16:30 <geekosaur> 7.8.2 was released about 2 weeks ago; the platform has not caught up yet, nor has a significant chunk of hackage
20:16:40 <geekosaur> next platform release is expected next month
20:19:14 <c_wraith> Is 7.8.3 in progress?  istr there was more they wanted to get done in the 7.8 series
20:19:20 <Guest61369> ok, will wait till then, on a slow connection here so web is sloooww...thx
20:20:10 <dmj`> geekosaur: will it include 7.10? I want the new record stuff
20:20:23 <geekosaur> wat
20:20:39 <c_wraith> dmj`: you'll have to wait for that to be done
20:20:43 <geekosaur> I don't think 7.10 is even scheduled yet
20:21:00 <dmj`> ghc can disambiguate record fields w/ the same name from different constructors
20:21:08 <dmj`> I heard that'd be in 7.10
20:21:13 <geekosaur> (and if it is... well, 7.8 was uspposed to be out last september^Woctober^Wdecember, honest!
20:21:24 <newsham> does BayHac broadcast or record?
20:21:29 <Guest61369> also, been thinking of looking at erlang, has anybody here tried?
20:21:31 <c_wraith> dmj`: yes, that will be in 7.10.  But 7.8 is at least 8 months away
20:21:37 <c_wraith> err, 7.10 is
20:21:58 <Guest61369> the same name from different constructors?
20:22:03 <c_wraith> Guest61369: erlang as a language is nothing special, and I don't like its syntax much.  But the OTP platform is absolutely fantastic
20:22:16 <Platz> Guest61369: Might want to look into Elixir
20:22:29 <LordBrain> OTP stands for what?
20:22:30 <dmj`> Guest61369: like data P = P { m :: String } and data J = J { m :: String }
20:22:38 <Platz> ruby-ish syntax on on the erlang platform
20:22:45 <dmj`> normal haskell won't let you do that
20:22:57 <dmj`> unless it's in a different module
20:23:07 <LordBrain> Open Telecom Platform... google is my friend...
20:24:35 <Guest61369> ok, but thats for an upcoming upgrade..cool
20:25:04 <Platz> Are haskellers still interested in Cloud Haskell, or has that ship sailed?
20:25:17 <c_wraith> Cloud Haskell is definitely a work in progress.
20:25:27 <c_wraith> Work is progressing, but it's still got a lot to do.
20:25:33 <ion> I for one am certainly interested.
20:25:46 <dmj`> acid-state FTW
20:25:46 <Platz> I imagine it it isn't easy, yes
20:26:30 <Guest61369> and what progress are they making on getting it to run faster compiles and reduced core size?
20:26:31 <Platz> better right than broken
20:26:35 <dmj`> ion: have you looked at acid-state's remote module?
20:27:04 <newsham> class P_And_J_Like pj where   toP :: pj -> P;  toJ :: pj -> J
20:27:20 <ion> dmj: I have skimmed over it.
20:27:36 <Guest61369> haskell is getting fat like a cake hole stuffing fast food buterball :>
20:27:41 <ion> It doesn’t have any primitives for inter-process supervision, does it?
20:27:43 <Platz> I'm not sure if it's attempting to provide parity with Akka, but would be nice to take some of the incentive out of using scala
20:27:50 --- mode: ChanServ set +o shachaf
20:27:54 --- mode: shachaf set +b *!*kvirc@64.116.185.*
20:27:54 --- kick: Guest61369 was kicked by shachaf (Guest61369)
20:27:58 --- mode: shachaf set -o shachaf
20:30:04 <ion> instance P_And_J_Like SPJ where { toP = peyton; toJ = jones }
20:31:12 <newsham> instance Simon SPJ where
20:31:22 <dmj`> ion: multiple clients can connect to a centralized state, or multiple states. Suppose you could store 5 hash-tables in 5 remote processes and use one client to open up handles to all of them and perform operations, including map-reduce with monad-par
20:32:15 <dmj`> acid-state operations are pure, like the Par monad, so you can do rpc calls that map reduce in parallel
20:32:42 <ion> alright
20:33:29 <dmj`> sorry, I think it's like the coolest thing ever, so, yea
20:35:47 * hackagebot cookbook 2.3.4.3 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.3.4.3 (NatePisarski)
20:39:46 <newsham> class Dave d where -- these are the daves I know I know, these are thedaves i know
20:40:52 <mus1cb0x> would something written in haskell operate more quickly in C?
20:40:58 <mus1cb0x> pardon me if that's a stupid question
20:41:14 <ion> mu
20:41:46 <dmj`> mus1cb0x: it's possible yes, if you keep everything on the CPU, don't cross the bus to malloc up memory on the heap.
20:42:34 <dmj`> here: https://gist.github.com/dmjio/6166076
20:42:55 <mus1cb0x> wow cool ty
20:47:03 <mus1cb0x> is it practical to learn haskell if one is a proficient software developer, but untrained in math?
20:48:07 <geekosaur> math isn't generally necessary, beyond the usual for programming. I'm terrible at higher math
20:48:39 <geekosaur> (not real great at kitchen math eithetr, but what else are computers for? :p )
20:48:44 <mus1cb0x> is haskell practical for web/api app dev? or is that outside of its domain of intent?
20:49:05 <dmj`> mus1cb0x: haskell is the best thing to happen to web programming imo
20:49:38 <mus1cb0x> mm. what kind of programming is haskell /not/ well-suited for?
20:49:56 <Ralith> realtime control?
20:50:12 <Rarrikins> A duck!
20:53:48 <mus1cb0x> heh
20:54:30 <mus1cb0x> is there a channel more appropriate for haskell beginners or is this th oen?
20:54:34 <mus1cb0x> the one*
20:55:05 <Rarrikins> This is the one.
20:55:13 <geekosaur> this is the appropriate channel but I don't think many people are around right now
20:55:22 * geekosaur should probably not count as around, in fact...
20:55:38 <Rarrikins> It's more active around evening time in the US.
20:55:56 <Ralith> this is evening time in the US
20:56:13 <geekosaur> well, there's a fairly active european contingent but it's 0-dark-thirty for them
20:56:28 <geekosaur> about midnight for me
20:56:58 <geekosaur> and I'm only still up to watch some AFL :p
20:57:09 <mus1cb0x> you mean APL?
20:57:13 <Taneb> It's almost 5 AM here
20:57:14 <geekosaur> nope
20:57:14 <Taneb> Help
20:57:19 <mus1cb0x> what's AFL?
20:58:08 <geekosaur> it's offtopic for #haskell...
20:58:17 <mus1cb0x> oh
20:58:17 <geekosaur> http://www.afl.com.au/
21:00:27 <mus1cb0x> how portable is haskell?
21:00:32 <mus1cb0x> or it's compiler/vm
21:01:15 <dmj`> very portable I'd say, I'm using it on ubuntu, windows and osx.
21:02:01 <Rarrikins> People are working on compiling it to JavaScript as well.
21:02:23 <Aetherspawn> mus1cb0x: in terms of bsd/linux/osx I've heard it's pretty good
21:02:26 <jmcarthur> mus1cb0x: what platforms do you want to support?
21:02:29 <Aetherspawn> sometimes portability to Windows is ... hrnnng
21:02:41 <dmj`> ^ yes
21:02:56 <Aetherspawn> you won't get optimal performance from Windows by any rate, but most the time it does work if you're careful what libraries you choose
21:04:14 <dmj`> Aetherspawn: what do you mean by not optimal
21:04:51 <dmj`> Windows isn't optimal or ghc?
21:05:39 <Aetherspawn> ghc doesn't use iocp on windows
21:06:13 <Aetherspawn> which is kind of equivalent to not using select() on linux or kqueue on osx or etc.
21:06:46 <mus1cb0x> freebsd
21:06:48 <Aetherspawn> I think I saw a 3 year old patch in development on the tracker?
21:07:01 <mus1cb0x> that's all i care about really, as i'd just be doing server software
21:08:21 <dmj`> so what you're saying is that concurrency on windows sucks
21:08:22 <dmj`> https://www.mail-archive.com/cvs-libraries@haskell.org/msg10195.html
21:09:10 <dmj`> https://ghc.haskell.org/trac/ghc/ticket/7353
21:20:15 <Aetherspawn> mus1cb0x: with that being said, it's not that bad
21:20:41 <Aetherspawn> still likely faster than interpreted rubbish, but be aware, you'll get more concurrency on nix
21:20:54 <mus1cb0x> is haskell's concurrency comparable to C's concurrency?
21:21:08 <Aetherspawn> on nix it beats nginx at serving pages
21:21:12 <Aetherspawn> and nginx is written in C
21:21:37 <Aetherspawn> you may be interested: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
21:21:39 <Aetherspawn> benchmarks inside.
21:21:40 <dmj`> cabal init craps out on windows
21:21:56 <Aetherspawn> gotta go, bye
21:22:25 <dmj`> cabal.exe: git: does not exist
21:22:31 <dmj`> why would cabal need git
21:23:55 <shachaf> art thou comparable to a summer's day?
21:25:09 <dmj`> Thou art more lovely and more temperate.
21:29:16 <mm_freak> hi there
21:29:48 <mm_freak> are there package-specific RSS/∀tom feeds?  that would be really handy for distribution package maintainers
21:30:10 <mm_freak> *atom
21:31:58 <dmj`> mm_freak: There's twitter :) I dunno about package-specific. You mean like to get the latest version of pkg?
21:32:29 <mm_freak> dmj`: to be notified of updates to a specific package
21:33:17 <mm_freak> and i'm not too much of a fan of twitter…  i mainly rant there =)
21:37:18 <dmj`> yea, maybe github webhooks would be best
21:37:33 <dmj`> you could poll a list of commits: http://hackage.haskell.org/package/github-0.7.4/docs/Github-Repos-Commits.html
21:38:03 <mm_freak> so short answer: no =)
21:38:27 <dmj`> basically
21:38:29 <dmj`> :P
21:40:39 <dmj`> mm_freak: https://hackage.haskell.org/api
21:42:51 <mm_freak> dmj`: that's useful, thanks!
21:46:56 <mm_freak> dmj`: do you know how to get RSS out of that?  the documentation suggests that it's possible, but "Accept: application/rss+xml" doesn't work
21:53:45 <dmj`> mm_freak: hmmm let's see
21:56:38 <dmj`> mm_freak: http://hackage.haskell.org/packages/recent.rss
21:57:07 <mm_freak> d'oh
21:57:13 <mm_freak> thanks
21:57:22 <dmj`> np :P
22:29:39 <redtricycle> I have a list ["something", "awesome", "here"]
22:29:44 <redtricycle> How do I write this to a file, each word on a line?
22:29:50 <redtricycle> something\nawesome\nhere
22:30:07 <redtricycle> I'm using this: save f x = Prelude.appendFile "f" (show x)
22:30:26 <redtricycle> And using map gives me type error
22:32:00 <pavonia> > lines ["something", "awesome", "here"]
22:32:01 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
22:32:01 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match expected type ...
22:32:01 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match expected type ...
22:32:01 <lambdabot>              with actual type ‘[GHC.Types.Char]’
22:32:08 <pavonia> > unlines ["something", "awesome", "here"]
22:32:09 <lambdabot>  "something\nawesome\nhere\n"
22:32:10 <pjdelport> redtricycle: you might want unlines, instead of show
22:35:18 <redtricycle> ah, let me try.  i was using "show" because the list is actually not a list of strings
22:35:42 <mm_freak> redtricycle: are you mapping 'save'?  if yes, do you understand the type error?
22:38:01 <dmj`> @typ mapM_ (appendFile "hi.txt") ["hey\n", "you\n"]
22:38:02 <lambdabot> IO ()
22:38:26 <redtricycle> It worked!
22:38:29 <redtricycle> unlines was what I wanted
22:38:57 <mm_freak> i wish people here would be a bit more hesitant about writing out ready-made solutions
22:39:09 <redtricycle> I guess I didn't need "show"
22:39:23 <redtricycle> I originally thought I needed to use it because I was getting an XML list which wasn't a string
22:39:36 <redtricycle> so I had (Show a) => FilePath -> a -> IO()
22:39:58 <redtricycle> I just changed the type to save :: FilePath -> [String] -> IO()
22:41:52 <dmj`> mm_freak: me too :P
22:43:41 <mm_freak> <dmj`> @typ mapM_ (appendFile "hi.txt") ["hey\n", "you\n"]
22:44:49 <dmj`> imposter!
22:46:52 <dmj`> mm_freak: are you upset because it's bad code or because I didn't let him come to the solution or both
22:48:01 <SparkySparkyBoom> .
22:48:59 <mm_freak> dmj`: i'm not upset, but if i were, it would be both =P
22:49:10 <dmj`> :P
22:49:52 <joneshf-laptop> it seems whenever i set up a new cabal "installed packages db"? alex and happy don't get pulled in whendependencies need them
22:49:59 <joneshf-laptop> is there any reason these twoare special?
22:50:18 <mm_freak> joneshf-laptop: those packages depend on the binaries, not the packages themselves
22:50:35 <mm_freak> that's why they are not installed as dependencies
22:50:52 <joneshf-laptop> oh
22:52:52 <mm_freak> joneshf-laptop: you may want to install them through your distribution's package manager…  they aren't used as haskell libraries anyway
22:53:16 <mm_freak> (bad habit of mine…  assuming unix/linux)
23:20:01 <certainty> good morning. What's the most common way to do error reporting when my code runs in a stack of monads where the underlying monad is IO? (if my wording is off, please bear with me, I'm trying to wrap my head around this haskell thing :))
23:20:44 <dmj`> certainty: you can wrap your transformer stack with an ErrorT monad
23:21:03 <dmj`> :t ErrorT String (StateT Int IO) ()
23:21:04 <lambdabot> Not in scope: data constructor ‘String’
23:21:04 <lambdabot>     Not in scope: data constructor ‘Int’
23:21:04 <lambdabot>     Perhaps you meant one of these:
23:21:48 <dmj`> :k ErrorT String (StateT Int IO) ()
23:21:49 <lambdabot> *
23:22:12 <certainty> dmj`: allright, is that a common way? I read that there is probably not much consensus on what error reporting facility to use. Using the monad fail is considered bad?
23:23:12 <dmj`> https://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-Error.html
23:24:22 <dmj`> > do { Just 3 <- Nothing }
23:24:23 <lambdabot>  The last statement in a 'do' block must be an expression
23:24:24 <lambdabot>    Just 3 <- Nothing
23:24:38 <certainty> dmj`: thanks i've found that. I'll give it a try. Honestly I don't get how monad transformers work. I should read up on that once i've finished this thing
23:24:45 <dmj`> > do { Just x <- Nothing; return (Just x) }
23:24:46 <lambdabot>  Nothing
23:25:09 <dmj`> in the case of maybe fail returns Nothing
23:25:22 <dmj`> to be sure, check each monad instance
23:25:31 <dmj`> and how fail is implemented
23:25:52 <dmj`> certainty: are you familiar with kinds?
23:26:26 <dmj`> certainty: this paper helped me: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
23:26:38 <certainty> dmj`: i've read about them in LYAH, but it's been a while
23:27:03 <certainty> dmj`: thanks!
23:27:23 <dmj`> certainty: I don't think LYAH covers monad transformers
23:27:31 <certainty> dmj`: i mean kinds
23:27:38 <dmj`> oh yea sure
23:27:51 <dmj`> certainty: can I show you a hint
23:28:07 <certainty> please do
23:28:22 <dmj`> :k StateT
23:28:23 <lambdabot> * -> (* -> *) -> * -> *
23:28:25 <dmj`> :k ErrorT
23:28:25 <lambdabot> * -> (* -> *) -> * -> *
23:28:28 <dmj`> :k WriterT
23:28:29 <lambdabot> * -> (* -> *) -> * -> *
23:28:46 <certainty> look all the same. Have the same kind i suppose then
23:29:08 <dmj`> the (* -> *) is where you can nest arbitrary monad stacks
23:29:12 <dmj`> :k Maybe
23:29:13 <lambdabot> * -> *
23:29:14 <dmj`> :k IO
23:29:15 <lambdabot> * -> *
23:29:16 <dmj`> :k STM
23:29:17 <lambdabot>     Not in scope: type constructor or class ‘STM’
23:29:17 <lambdabot>     Perhaps you meant ‘ST’ (imported from Control.Monad.ST.Safe)
23:29:32 <dmj`> are all eligible
23:29:39 <dmj`> like take StateT
23:29:56 <dmj`> StateT (s :: *) (m :: * -> *) (a :: *)
23:30:33 <dmj`> now you know what types belong, m can only be inhabited by types constructors, or types with kinds greater than *
23:30:53 <dmj`> :k StateT Int
23:30:54 <lambdabot> (* -> *) -> * -> *
23:30:58 <dmj`> :k State Int IO
23:30:59 <lambdabot>     Expecting one more argument to ‘IO’
23:30:59 <lambdabot>     The second argument of ‘State’ should have kind ‘*’,
23:30:59 <lambdabot>       but ‘IO’ has kind ‘* -> *’
23:31:04 <dmj`> :k StateT Int IO
23:31:05 <lambdabot> * -> *
23:31:09 <dmj`> :k StateT Int IO Int
23:31:11 <lambdabot> *
23:31:17 <dmj`> now you have a stack :P
23:31:31 <dmj`> :k ErrorT
23:31:32 <lambdabot> * -> (* -> *) -> * -> *
23:31:59 <dmj`> :k ErrorT String (IO Int)
23:32:00 <lambdabot>     The second argument of ‘ErrorT’ should have kind ‘* -> *’,
23:32:00 <lambdabot>       but ‘IO Int’ has kind ‘*’
23:32:00 <lambdabot>     In a type in a GHCi command: ErrorT String (IO Int)
23:32:27 <dmj`> :k ErrorT String (StateT Int IO)
23:32:28 <lambdabot> * -> *
23:32:36 <dmj`> :k StateT Int IO
23:32:37 <lambdabot> * -> *
23:32:41 <dmj`> Ok you see that!!
23:32:51 <dmj`> :k ErrorT String
23:32:52 <lambdabot> (* -> *) -> * -> *
23:33:13 <dmj`> the first kind argument can be filled by (StateT Int IO :: * -> *)
23:33:19 <dmj`> that's how you nest em'
23:34:18 <certainty> i intuitively grasp that. But i certainly don't get the details. Thanks for the pointers. I'll read the paper
23:34:33 <dmj`> im not the best at explaining
23:34:35 <dmj`> :P
23:34:54 <certainty> i'm not the best at getting was is explained
23:34:59 <certainty> what is
23:36:32 <certainty> now i'm going to try to wrap my RWST monad with ErrorT
23:36:40 <certainty> rws
23:45:20 <no-n> @hoogle Last
23:45:20 <lambdabot> Data.Monoid Last :: Maybe a -> Last a
23:45:21 <lambdabot> Data.Monoid newtype Last a
23:45:21 <lambdabot> package Lastik
23:45:35 <no-n> :t WriterT
23:45:35 <lambdabot> m (a, w) -> WriterT w m a
23:46:23 <no-n> > (Last $ Just 1) >> (Last $ Just 2)
23:46:24 <lambdabot>  Could not deduce (GHC.Base.Monad Data.Monoid.Last)
23:46:24 <lambdabot>    arising from a use of ‘GHC.Base.>>’
23:46:24 <lambdabot>  from the context (GHC.Num.Num b)
23:46:24 <lambdabot>    bound by the inferred type of
23:46:24 <lambdabot>             it :: GHC.Num.Num b => Data.Monoid.Last b
23:46:35 <no-n> > (Last $ Just 1) `mappend` (Last $ Just 2)
23:46:36 <lambdabot>  Last {getLast = Just 2}
23:49:08 <no-n> > mconcat $ map (Last.Just) [0..15]
23:49:09 <lambdabot>  Not in scope: data constructor ‘Last.Just’
23:49:20 <no-n> > mconcat $ map (Last . Just) [0..15]
23:49:21 <lambdabot>  Last {getLast = Just 15}
23:49:38 <dmj`> :k StateT Int (StateT Int (StateT Int (StateT Int IO))) ()
23:49:39 <lambdabot> *
23:56:43 <no-n> > '\0'
23:56:44 <lambdabot>  '\NUL'
