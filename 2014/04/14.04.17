00:00:12 <Iceland_jack> I see that :) but you're not going to guess your way through Haskell
00:00:32 <Iceland_jack> If have something specific you want to try out with lambdabot you can ask how to do that
00:01:04 <tdammers> honestly, the best explanation of monads I've seen so far was pretty much just "a monad is something that provides >>= and return and fail"
00:01:33 <hattusili_III> or is anyone familiar with ghc-mod?
00:01:39 <FrankTominc> Iceland_jack: how do i get a list from 1 to 20 with the double of the values??
00:01:52 <Iceland_jack> > map (* 2) [1..20]
00:01:53 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40]
00:01:55 <tdammers> and then explaining what each of these "does"
00:03:38 <ZettaBlade> I prefer typeclassopedia's explanation of monads. Contexts and containers...
00:04:10 <hattusili_III> im trying to figure out what it means when i want ghc-mod to display an inferred type, and it gives the error "module should be specified" how should it be specified for what purpose?
00:04:36 <FrankTominc> Iceland_jack: oh, just like what you did before but with an infinite list and the square of the values...
00:04:48 <Iceland_jack> Yes
00:05:07 <Iceland_jack> You can also write
00:05:07 <Iceland_jack> > [ x*2 | x <- [1..20] ]
00:05:09 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40]
00:05:30 <Iceland_jack> That's often clearer to people from Python or those that are unfamiliar with higher-order functions
00:05:40 <tdammers> ZettaBlade: I find the "container" intuition too specific
00:06:07 <FrankTominc> Iceland_jack: cool :)
00:07:14 <FrankTominc> Iceland_jack: i see something like that on ruby
00:09:00 <FrankTominc> Iceland_jack: there is any difference behind the curtains between that 2 forms??
00:09:21 <tdammers> FrankTominc: no, not really
00:09:25 <Iceland_jack> They both desugar into effectively the same thing
00:10:43 * hackagebot purescript 0.4.19.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.19.1 (PhilFreeman)
00:10:43 * hackagebot logging 1.4.0 - Simplified logging in IO for application writers.  http://hackage.haskell.org/package/logging-1.4.0 (JohnWiegley)
00:11:42 <FrankTominc> thanks guys, it's 4 am here i'll get some sleep
00:11:56 <Iceland_jack> good luck FrankTominc
00:12:19 <Iceland_jack> Install GHC and read through LYAH and you'll be proficient in Haskell in no time
00:12:22 <Iceland_jack> gah
00:13:55 <tdammers> sleep is kind of crucial
00:14:11 <tdammers> I think Haskell has sleep deprivation protection built into it
00:14:27 <Iceland_jack> sleep is overrated
00:14:40 <tdammers> when you're too intoxicated or too sleep deprived to be allowed near your code, then it won't compile
00:14:40 <Iceland_jack> (okay not really)
00:16:23 <orion> How about this one: "Haskell without Monads is like an omelette without eggs."
00:16:45 <Iceland_jack> orion: ..why do you want to make those kind of analogies?
00:16:53 <shachaf> Haskell without monads would be fine.
00:17:14 <tdammers> shachaf: because you could just implement them yourself?
00:17:23 <Iceland_jack> Haskell without lists is like a cake without icing?
00:17:37 <shachaf> OK, Haskell without the abstraction Monad would be fine.
00:17:47 <shachaf> Most programming languages without monads wouldn't work.
00:17:54 <shachaf> Functions are pretty useful, for instance.
00:17:59 <orion> Iceland_jack: Because I'm drunk
00:18:03 <CindyLinz> Iceland_jack: I don't like cake with icing... XD
00:18:19 <Iceland_jack> orion: Alcohol and analogies don't mix
00:18:27 <Iceland_jack> I was about to make a dirty joke but I decided against it
00:18:37 <Iceland_jack> CindyLinz: But it's the best part!
00:18:37 <orion> What about Alcohol + Haskell?
00:19:21 <CindyLinz> Iceland_jack: List is good.. XD
00:21:59 <Iceland_jack> orion: Either Alcohol Haskell? :) don't you mean Alcohol × Haskell
00:22:48 <c_wraith> I did some of my best haskell work when drunk.  It's a language where I still felt OK about the code in the morning!
00:23:47 <Jafet> Haskell^{Alcohol}
00:24:24 <tdammers> unsafeConsumeEthanol
00:24:25 <CindyLinz> Alcohol drives the code going on, and Haskell makes the code going right..
00:24:39 <tdammers> I think drinking is a monad
00:24:55 <Iceland_jack> Because you can't get out?
00:25:41 <tdammers> instance Monad Drinking where { (>>=) = orderAnother; return = fill; fail = vomit }
00:25:57 <Iceland_jack> 'orderAnother' heh :)
00:26:07 <Iceland_jack> join = chug!
00:26:14 <Iceland_jack> or maybe 'join = mix'?
00:26:32 <tdammers> I think the semantics are a bit unclear
00:26:43 <Iceland_jack> that's to be expected
00:35:42 * hackagebot dataenc 0.14.0.6 - Data encoding library  http://hackage.haskell.org/package/dataenc-0.14.0.6 (GracjanPolak)
00:40:42 * hackagebot warp 2.1.4.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.1.4.1 (MichaelSnoyman)
00:40:44 * hackagebot warp-tls 2.0.4 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-2.0.4 (MichaelSnoyman)
01:01:39 <makalu> If I use a vector of a primitive type like Int, is there any difference between Data.Vector.Unboxed and Data.Vector.Storable?
01:02:40 <makalu> they will both be stored in memory sequentially and stream fusion will work?
01:14:48 <Saizan> makalu: i think Storable will be pinned memory while Unboxed can be moved by the garbage collector, don't know about fusion
01:15:16 <Jafet> Storable may incur overhead for serialization.
01:16:51 <makalu> Jafet: why?
01:18:11 <Jafet> Because it performs serialization
01:19:12 <ZettaBlade> Vectors do stream fusion?!
01:19:32 <ZettaBlade> I need to read more about this.
01:19:51 <Jafet> The vector package for vectors does stream fusion.
01:19:56 <Iceland_jack> ZettaBlade: Indeed
01:20:28 <Jafet> @hoogle force
01:20:28 <lambdabot> Control.DeepSeq force :: NFData a => a -> a
01:20:28 <lambdabot> package force-layout
01:20:29 <lambdabot> Graphics.UI.GLUT.DeviceControl forceJoystickCallback :: IO ()
01:22:07 <makalu> Jafet: and Unboxed doesn't serialize?
01:22:31 <Jafet> That's a good question
01:22:31 * ZettaBlade has never used vectors, just repa
01:23:13 <makalu> vector is a very nice package in my opinion
01:24:10 <makalu> but thanks anyway Jafet and Saizan. I think I will use Storable since I need to interact with a C++ library
01:24:23 <makalu> s/anyway//
01:24:32 <Jafet> That is a good reason to use Storable.
01:24:35 <BoR0> http://lpaste.net/102813 what's a neater way of writing this?
01:25:33 <fox_> has anyone written a pomodoro app in haskell?
01:25:47 <Jafet> I can't understand the source code for vector, but I imagine that the Unbox instance for Int just uses GHC arrays directly, without Storable
01:29:57 <mikeplus64> BoR0: fromMaybe (return "[]") (getStatus' <$> param1 <*> param2 <*> ...)?
01:31:49 <BoR0> excellent that it works :) now can you explain <$> and <*> to me? :)
01:40:27 <ZettaBlade> Well, <$> is just an infix version of fmap, which applies a function to the data in a functor and returns the result in a functor. <*> makes fmap look like a chump, and applies a function in a functor to a value in a functor, and returns the result in a functor.
01:41:24 <Jafet> Easy version: <$> lifts a function and <*> lifts an application
01:42:04 <makalu> your explanations are too short for beginners :)
01:42:07 <makalu> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
01:43:29 <Iceland_jack> BoR0: Do you understand fmap?
01:43:54 <BoR0> Iceland_jack, ZettaBlade, yeah, I just quickly ran through LYAH and saw what's it about. thanks
01:44:08 <Iceland_jack> okay :)
01:45:07 <BoR0> x <$> y is just a nice way of saying pure x <*> y, right?
01:45:59 <BoR0> or did it hold just for the example that I tried (with (+))
01:46:03 <eatman> BoR0: I Think so
01:46:35 <eatman> No, I'm reading lyah about it and it seems to be correct.
01:46:56 <supki> BoR0: it's a consequence of the Applicative laws
01:47:08 <Iceland_jack> Just like you can turn a function
01:47:08 <Iceland_jack>     f      :: a -> b
01:47:08 <Iceland_jack> into
01:47:08 <Iceland_jack>     fmap f :: F a -> F b
01:47:11 <Iceland_jack> for some Functor F
01:47:15 <Cale> BoR0: Well, yes, though it works even without an instance of Applicative (only needs Functor)
01:47:19 <Cale> It's just fmap
01:47:31 <Iceland_jack> you can turn
01:47:32 <Iceland_jack>     g :: a -> b -> c
01:47:32 <Iceland_jack> into
01:47:32 <Iceland_jack>     A a -> A b -> A c
01:47:47 <Iceland_jack> @ty liftA2
01:47:49 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
01:48:15 <BoR0> aha... time to read up on applicative functors some more then
01:48:29 <Iceland_jack> BoR0: If you want to append two inputs together you can do
01:48:29 <Iceland_jack>     (++) <$> getLine <*> getLine
01:48:49 <Iceland_jack> which is the same as
01:48:49 <Iceland_jack>     liftA2 (++) getLine getLine
01:48:59 <BoR0> neat!
01:49:01 <BoR0> is there a liftA3 ?
01:49:04 <Iceland_jack> sure is!
01:49:21 <BoR0> so this "result <- fromMaybe (return "[]") (getStatus' <$> param1 <*> param2 <*> param3)" can be even more beautiful?
01:49:51 <Iceland_jack> well you can write
01:49:51 <Iceland_jack>     liftA3 getState' param1 param2 param3
01:49:56 <BoR0> liftA3 getStatus' param1 param2 param3
01:49:56 <Iceland_jack> depends on what you find beautiful
01:50:37 <tdammers> beauty is not subjective
01:50:38 <tdammers> :D
01:50:45 <Iceland_jack> de gustibus
01:50:47 <Iceland_jack> > (+) <$> Just 5 <*> Just 10
01:50:49 <lambdabot>  Just 15
01:51:23 <tdammers> anyway, would be nice to have a way to do the <$> / <*> thing with infix operators
01:51:30 <BoR0> > liftA2 (+) (Just 5) (Just 6)
01:51:31 <tdammers> no idea what that would look like, syntax wise
01:51:32 <lambdabot>  Just 11
01:51:35 <BoR0> > liftA2 (+) (Just 5) Nothing
01:51:36 <lambdabot>  Nothing
01:51:43 <triliyn> tdammers: have you heard of idiom brackets?
01:51:47 <tdammers> no
01:51:53 <Iceland_jack> tdammers: ⟦ Just 5 + Just 10 ⟧
01:51:59 <tdammers> noice
01:52:02 <BoR0> Iceland_jack, can liftA2 and liftA3 be easily generalized to liftA(N) without creating a function with N params?
01:52:23 <Iceland_jack> BoR0: That's basically what you have with (<$>)/(<*>)
01:52:43 <BoR0> ok, yeah
01:52:54 <Iceland_jack> lifting a function
01:52:54 <Iceland_jack>     f a b c … z
01:52:54 <Iceland_jack> becomes
01:52:54 <Iceland_jack>     f <$> a <*> b <*> c <*> … <*> z
01:53:10 <Yuu_chan> I heard of idiom brackets in Idris
01:53:12 <BoR0> :t liftA3
01:53:13 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
01:53:14 <BoR0> :t liftA5
01:53:15 <lambdabot>     Not in scope: ‘liftA5’
01:53:15 <lambdabot>     Perhaps you meant one of these:
01:53:15 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
01:53:17 <BoR0> :t liftA4
01:53:18 <lambdabot>     Not in scope: ‘liftA4’
01:53:18 <lambdabot>     Perhaps you meant one of these:
01:53:18 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
01:53:27 <triliyn> hmm... I wonder if you could use the variable-argument-function trick to write liftAN?
01:53:55 <Iceland_jack> triliyn: You could but it would be more effort than it's worth
01:54:04 <triliyn> Iceland_jack: hmmm, okay
01:54:13 <BoR0> what's the variable-argument-function trick?
01:54:13 <triliyn> Might still be a fun exercise, but I think it's time for me to sleep
01:54:34 <Iceland_jack> BoR0: You can make variadic functions by abusing type classes or type families a bit
01:54:48 <Iceland_jack> liftA{,2,3} and liftM{,2,3} are mostly nice for partial application though
01:55:27 <Jafet> > text $ printf "%d %s" 1 "a"
01:55:29 <lambdabot>  1 a
01:55:43 <Iceland_jack> Yes, printf is the canonical example
01:55:45 <BoR0> :t printf
01:55:46 <lambdabot> PrintfType r => String -> r
01:55:47 <Iceland_jack> QuickCheck also uses that trick
01:55:55 <Iceland_jack> @ty quickCheck
01:55:56 <lambdabot> Testable prop => prop -> IO ()
01:56:10 <BoR0> how do you pass 1 "a" to printf when it accepts String only
01:56:21 <Jafet> :t printf "%d %s"
01:56:22 <lambdabot> PrintfType r => r
01:56:31 <Iceland_jack> BoR0: The first argument has to be string, the rest can be anything of PrintfType
01:56:36 <BoR0> ah
01:57:01 <Iceland_jack> If you search for 'haskell variadic functions' or 'haskell how the hell does printf work' you'll find some nice explanations
01:57:18 <BoR0> thx. I'll do that
02:20:54 * hackagebot influxdb 0.2.0.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.2.0.1 (MitsutoshiAoe)
02:25:48 <erisco> Bool -> Maybe ()   this could be useful inside MaybeT if I am not mistaken
02:25:56 <erisco> to short-circuit if a condition fails
02:32:51 <Kaidelong> @ty guard
02:32:52 <lambdabot> MonadPlus m => Bool -> m ()
02:33:00 <Kaidelong> erisco: is this not what you want?
02:33:12 <erisco> hm why would it require MonadPlus?
02:33:35 <erisco> I'm not quite sure what it is doing
02:33:42 <Kaidelong> presumably the implementation is True = return (); False = mzero
02:33:52 <Kaidelong> which in the case of Maybe is Just () and Nothing
02:34:03 <Kaidelong> mzero is a MonadPlus method
02:34:31 <Kaidelong> hence the MonadPlus requirement
02:34:41 <Kaidelong> > guard True :: Maybe ()
02:34:43 <lambdabot>  Just ()
02:34:48 <Kaidelong> > guard False :: Maybe ()
02:34:50 <lambdabot>  Nothing
02:34:59 <Kaidelong> > guard True :: [()]
02:35:00 <lambdabot>  [()]
02:35:06 <Kaidelong> > guard False :: [()]
02:35:08 <lambdabot>  []
02:35:22 <erisco> yes that should be fine
02:36:13 <erisco> thought it does not seem that MaybeT has a MonadPlus instance
02:38:41 <erisco> I guess I'll just stay with my  MaybeT . return . boolTomaybe  definition
02:38:44 <erisco> I think that is right
02:39:19 <Kaidelong> > guard True :: MaybeT Identity ()
02:39:21 <lambdabot>  Not in scope: type constructor or class ‘MaybeT’
02:39:21 <lambdabot>  Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
02:39:29 <Kaidelong> oh well
02:39:38 <erisco> I don't see it here http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-Trans-Maybe.html
02:39:55 <erisco> actually when I view source I see it there
02:40:05 <Kaidelong> Monad m => MonadPlus (MaybeT m)
02:40:15 <Kaidelong> that's right there in the haddock
02:40:27 <erisco> oh I guess it is
02:40:39 <erisco> I scanned that list multiple times and still missed it
02:40:46 <erisco> I vote it needs to be tabulated :P
02:49:03 <erisco> is the way to get a Maybe value into the MaybeT monad MaybeT . return? feel that I might be missing something
02:54:41 <Yuu_chan> erisco: lift?
02:54:59 <erisco> :t lift
02:55:00 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
02:55:26 <erisco> well, Maybe is a monad, but it is not the correct one
02:55:46 <erisco> hence the return
02:56:34 <Yuu_chan> What do you mean by "not the correct"?
02:57:35 <erisco> how do the transformers stack with respect to the types? I have a ReaderT under the MaybeT
02:57:42 <erisco> is it MaybeT (ReaderT ...) a?
02:59:50 <erisco> I am fairly sure I have to use MaybeT :: m (Maybe a) -> MaybeT m a  to 'extract' the maybe value
03:00:10 <erisco> so I have to have 'Maybe a' in whatever 'm' is, and in my case it is a ReaderT
03:03:26 <jakex> why does random call RandomGen.next twice?
03:03:32 <Yuu_chan> I may guess wrong, but I thought that the whole point of transformers was to avoid manual extracting and wrapping
03:04:20 <erisco> well they do hide stuff away but you need to somehow lift the values into the monad for it to work
03:04:36 <erisco> and that adds a lot of crufty stuff generally... just not sure if MaybeT . return is the best I could do
03:06:53 <Yuu_chan> jakex: how did you measure that?
03:08:35 <jakex> Yuu_chan I created a RandomGen instance. wait, I will paste
03:08:38 <quchen> 'MaybeT . return' sounds right.
03:10:44 <jakex> http://lpaste.net/102817
03:11:59 <jakex> should have pasted output.. it is DebugGen 0  DebugGen 2 DebugGen 4
03:13:04 <Yuu_chan> I'd consider using of Debug.Trace here
03:14:11 <jakex> didn't know about. looks useful
03:14:15 <jakex> about it*
03:14:56 <Yuu_chan> @hoogle trace
03:14:57 <lambdabot> Debug.Trace trace :: String -> a -> a
03:14:57 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
03:14:57 <lambdabot> package trace-call
03:16:39 <Phillemann> Is there a way to see which type classes a type (in my case "[a]") implements?
03:16:41 <exicer> Does anyone know if there is some way to rotate text lables using charts?
03:17:03 <jakex> Yuu_chan that confirms that it is called 4 times
03:17:31 <jcullen> Phillemann: try :info [] in ghci
03:17:31 <quchen> Random's Int instance may call next multiple times "to get enough randomness to cover the range", whatever that means, jakex.
03:17:43 <quchen> http://hackage.haskell.org/package/random-1.0.1.1/docs/src/System-Random.html#randomIvalInteger
03:18:01 <jakex> quchen ah ok, missed that
03:18:12 <Phillemann> jcullen: I mean more like "over all of hackage". I might be asking for too much, though :D
03:18:26 <jakex> man Debug.trace is neat.
03:18:39 <erisco> Phillemann, well there are some instances here https://hackage.haskell.org/package/base-4.3.0.0/docs/Prelude.html
03:18:54 <erisco> and there are instances for Traverse and Foldable and a bunch of other things
03:19:40 <erisco> problem is that type classes are not closed. ie a new instance can be added at any time, so you really would have to look through every module on hackage to know
03:20:23 <Phillemann> Yeah, that's what I thouguht.
03:22:12 <Yuu_chan> jakex: try to output produced results and it gets even weirder
03:22:38 <jakex> Yuu_chan yeah I did :).
03:23:29 <quchen> Having a list of all typeclasses of a type over all of Hackage would probably be a long list for some types. Keep in mind that TH-generated definitions are a regular part of the API as well.
03:23:47 <Phillemann> I'm just thinking abstraction in this function I wrote which joins a list of values given a separator: ["a","b"],"x" results in "axb". I currently have an explicit recursion and it's defined over Monoid a => a -> [a] -> a.
03:24:21 <quchen> > intercalate "x" ["a", "b"]
03:24:22 <lambdabot>  "axb"
03:24:23 <Yuu_chan> At first I thought Int instance of Random demands two calls to get enough bits of randomness... but then I delve into sources and there's nothing like that
03:25:10 <Phillemann> quchen: Damn, how did I not see that in Data.List? :D Thanks
03:25:41 <Phillemann> It _is_ defined over lists, though, so mine is more general :D
03:27:30 <Yuu_chan> jakex: oh, now I get it
03:27:46 <vanila> Phillemann, you could write it using foldr instead of recursion if you just split it into cases [] and (x:xs)
03:29:31 <Phillemann> vanila: Ahh, you mean pattern match over the second argument of the fold..."callback"?
03:29:38 <Yuu_chan> Seems my initial suggestion was quite right. Implementation of linear generator (used for integral instances) makes n calls of 'next', where n is the logarithm of type size by the prime number used in the generator
03:30:05 <quchen> We call callbacks "function" in Haskell ;-)
03:30:21 <vanila> intercalate sep (x:xs) = x `mplus` foldr (\y ys -> sep `mplus` y `mplus` ys) mzero xs
03:30:26 <jakex> Yuu_chan I see, interesting
03:30:49 <Yuu_chan> @google linear congruent generator
03:30:50 <lambdabot> http://en.wikipedia.org/wiki/Linear_congruential_generator
03:30:50 <lambdabot> Title: Linear congruential generator - Wikipedia, the free encyclopedia
03:31:51 <Yuu_chan> Yay.
03:32:20 <Phillemann> vanila: Ah yes, so I only need monoid and foldable
03:32:29 <vanila> foldable?
03:33:02 <Phillemann> Hmmm.
03:33:25 <vanila> what i wrote is for intercalate :: Monoid m => m -> [m] -> m
03:33:33 <Yuu_chan> (Monoid m, Foldable f) => m -> f m -> m :) For the great generality!
03:33:40 <quchen> You would also need a way of extracting the "head" of your data structure for the above, I think.
03:33:47 <vanila> although I used monid plus instead of moniod by mistake
03:34:09 <Phillemann> Yuu_chan: Yes, it's just an exercise in generalizing for me.
03:34:20 <Phillemann> I don't actually _need_ it to be that general.
03:34:43 <vanila> I don't think you should use Foldable f, just list
03:34:54 <Yuu_chan> Phillemann: that's a nice exercise IMO
03:35:05 <vanila> for generality make a "leaves" function that turns Foldable into list
03:35:46 <quchen> That's called 'Foldable.toList'
03:37:52 <Yuu_chan> What are types which are Foldable, but not Traversable?
03:39:08 <Phillemann> Ok, thanks
03:40:07 <erisco> :t traverse
03:40:08 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:40:21 <quchen> traverse = generalized mapM
03:40:28 <quchen> :t mapM
03:40:29 <erisco> Yuu_chan, good question I do not know
03:40:29 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
03:40:55 <erisco> :t mapA
03:40:56 <lambdabot>     Not in scope: ‘mapA’
03:40:56 <lambdabot>     Perhaps you meant one of these:
03:40:57 <lambdabot>       ‘mapM’ (imported from Control.Monad.Writer),
03:41:11 <quchen> traverse = "mapA".
03:41:37 <quchen> Or "fmapA" if you prefer :-)
03:42:07 <Yuu_chan> erisco: probably Set is an example
03:42:13 <Wizek> Good Morning!
03:43:09 <Wizek> What do you usually do when you realize that you need a function in your current project that you've written earlier in a previous project?
03:43:11 <Yuu_chan> Wizek: it's 2:40 PM for me :-P
03:43:43 <vanila> copy and paste
03:44:22 <Wizek> vanila: What do you do when in either project you need to change said function? Copy-paste the new version again?
03:44:49 <vanila> dont change the old one unless you want to test it all again to make sure that change doesnt break anything
03:45:50 <Wizek> Yuu_chan: According to UGT, the time is right after morning by a few minutes. :)
03:46:39 <Wizek> vanila: So you only change the new one, and continue doing this and have different versions scattered around?
03:46:50 <vanila> yes
03:47:48 <Wizek> vanila: Hmm. Am I the only one who is bothered by copy pasting code?
03:48:09 <tdammers> Wizek: no
03:48:38 <Wizek> tdammers: You do something other than c&p?
03:48:38 <tdammers> anyway, depends how complex the function is
03:48:45 <tdammers> sure
03:48:50 <tdammers> I hardly ever c^p
03:48:54 <Wizek> tdammers: That is?
03:48:56 <Yuu_chan> Wizek: didn't know about UGT %D
03:49:01 <tdammers> factor it out
03:49:14 <Wizek> tdammers: To where?
03:49:14 <tdammers> make it a library, or add it to an existing library
03:49:37 <Wizek> tdammers: and then publish it to hackage?
03:49:38 <Flonk> flonk-san says that everything that has to be copy-pasted should be something that should be abstracted away by either the user or the language
03:49:46 <tdammers> Wizek: yes, usually
03:49:59 <tdammers> Flonk: aye.
03:50:43 <Wizek> tdammers: Even if you don't really feel like writing much docs or don't think that others benefit too much of this piece of functionality?
03:50:56 <tdammers> yes
03:51:11 <Wizek> tdammers: Could you like me to some of your such packages?
03:51:15 <tdammers> and honestly, I document my stuff anyway, if only for my future self
03:54:10 <Wizek> s/like/link/
03:54:13 <tdammers> not right now
03:54:19 <tdammers>  @jorb
03:54:26 <tdammers> jorb /= haskell
03:54:28 <tdammers> :(
03:54:37 <Wizek> jorb == job?
03:54:41 <tdammers> yes
03:55:06 <jakex> @pl (\n acc -> acc + length n + 2)
03:55:06 <lambdabot> flip flip 2 . ((+) .) . (+) . length
03:55:35 <Wizek> jakex: Ehh, please don't use that. :D
03:55:36 <Flonk> flip flip ಠ_ಠ
03:56:21 <Wizek> tdammers: Maybe if you tell me your name on hackage I can look them up?
03:56:51 <jakex> :t flip flip
03:56:52 <Yuu_chan> Flonk: acme-lookofdisapproval
03:56:52 <lambdabot> b -> (a -> b -> c) -> a -> c
03:57:00 <Wizek> :t flip
03:57:01 <lambdabot> (a -> b -> c) -> b -> a -> c
03:57:31 <Wizek> :t flip flip flip
03:57:32 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
03:57:35 <Flonk> Yuu_chan: Hahaha that's awesome
03:57:45 <Wizek> :t flip flip flip flip -- ?
03:57:46 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
03:57:47 <vanila> :t flip (flip flip)
03:57:48 <lambdabot> (a1 -> a -> c) -> a -> a1 -> c
03:57:58 <Wizek> flippy bird.
03:58:04 <Flonk> Yuu_chan: I wasn't aware that ಠ_ಠ is even a valid function name
03:58:21 <Yuu_chan> Wizek: interesting. Do types cycle or converge?
03:58:50 <quchen> Set is not Traversable for the same reasons it's not a Functor, I think.
03:59:54 <Jafet> flip table
04:00:22 <quchen> ?
04:01:07 <Yuu_chan> :D
04:01:36 <Yuu_chan> quchen: I probably thought the same
04:02:26 <Yuu_chan> Flonk: two (kannadian) letters and an underscore, a perfectly valid identifier ;)
04:03:18 <Flonk> Yuu_chan: Is it like in javascript where practically half of utf-8 can be used as an identifier?
04:03:25 <Flonk> brb, implementing APL in Haskell
04:04:16 <Wizek> :t repeat
04:04:17 <lambdabot> a -> [a]
04:04:21 <Jafet> haskell doesn't do prefix operators.
04:04:47 <Wizek> @hoogle a -> Int -> [a]
04:04:48 <lambdabot> Prelude replicate :: Int -> a -> [a]
04:04:48 <lambdabot> Data.List replicate :: Int -> a -> [a]
04:04:48 <lambdabot> Prelude drop :: Int -> [a] -> [a]
04:05:08 <Wizek> > replicate flip 2
04:05:09 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
04:05:09 <lambdabot>              with actual type ‘(a0 -> b0 -> c0) -> b0 -> a0 -> c0’
04:05:16 <Flonk> Jafet: functions are kind of prefix operators
04:05:34 <Jafet> Also, I don't think half of utf-8 can be used as identifiers, because most codepoints are not yet even assigned.
04:05:36 <Wizek> map (replicate flip) [1..5]
04:05:40 <Wizek> > map (replicate flip) [1..5]
04:05:41 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
04:05:41 <lambdabot>              with actual type ‘(a0 -> b0 -> c0) -> b0 -> a0 -> c0’
04:05:42 * quchen wonders why Data.Set doesn't export its own "traverse" function
04:06:11 <Jafet> Yes, you can do that, but you will not be able to use any Punctuation or Symbols.
04:06:46 * Wizek thinks @hoogle command should be built-in for GHCi
04:06:51 <Flonk> Jafet: Well if ಠ works, that's symbol enough for me :P
04:07:16 <Yuu_chan> I think the first character must be isAlphaNum or like that
04:07:31 <Yuu_chan> Can't remember the grammar :(
04:07:40 <Jafet> > generalCategory 'ಠ'
04:07:41 <lambdabot>  OtherLetter
04:07:41 <Wizek> :t map (replicate flip) [1..5]
04:07:42 <lambdabot>     Couldn't match expected type ‘Int’
04:07:43 <lambdabot>                 with actual type ‘(a0 -> b0 -> c0) -> b0 -> a0 -> c0’
04:07:43 <lambdabot>     Probable cause: ‘flip’ is applied to too few arguments
04:07:50 <Jafet> Right, it's a decorated o.
04:08:10 <Jafet> Or not, it's a weird canadian letter
04:08:24 <Wizek> :t [flip, flip]
04:08:25 <lambdabot> [(a -> b -> c) -> b -> a -> c]
04:08:37 <Jafet> Indian, even
04:08:40 <Wizek> :t [flip, flip flip]
04:08:41 <lambdabot>     Occurs check: cannot construct the infinite type:
04:08:41 <lambdabot>       b ~ a -> (a -> b -> c) -> c
04:08:41 <lambdabot>     Expected type: (a -> b -> c) -> (a -> (a -> b -> c) -> c) -> a -> c
04:09:25 <Flonk> brb
04:09:47 <Wizek> Can the ':t' be used as a function?
04:10:04 <merijn> Wizek: :t is a GHCi command
04:10:09 <Jafet> > typeOf flip
04:10:10 <Wizek> colonT :: a -> String
04:10:11 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
04:10:11 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
04:10:11 <lambdabot>  The type variable ‘c0’ is ambiguous
04:10:13 <lambdabot>  Note: there are several potential instances:
04:10:13 <Yuu_chan> > isAlpha 'ಠ'
04:10:15 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
04:10:17 <lambdabot>  True
04:10:36 <Wizek> @hayoo a -> String
04:10:37 <lambdabot> Unknown command, try @list
04:10:44 <Wizek> @hoogle a -> String
04:10:45 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
04:10:45 <lambdabot> Prelude show :: Show a => a -> String
04:10:45 <lambdabot> Text.Show show :: Show a => a -> String
04:10:47 <merijn> Wizek: Why you you want this?
04:10:51 <Yuu_chan> Wizek: nope, but you can define infix constructors starting with :
04:11:36 <Wizek> > typeOf 4.4
04:11:36 <merijn> Wizek: And suppose you did have a ":t" function, what would you do with it?
04:11:38 <lambdabot>  Double
04:12:23 <Wizek> merijn: I could have a list of strings with the types of flips from 1 to n
04:13:07 <merijn> Wizek: For what?
04:14:31 <Wizek> merijn: For fun, obviously. But the possiblilities are endless. Isn't it a little strange that :t can only consume return values, and itself cannot be composed with other functions?
04:15:35 <Wizek> :t typeOf
04:15:37 <lambdabot> Typeable a => a -> TypeRep
04:15:49 <merijn> Wizek: No, because ':t' is not a function
04:15:53 <merijn> Wizek: It's not even haskell
04:16:22 <Wizek> @instances Typeable
04:16:23 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
04:16:42 <vanila> types can be completely erased from your program after they've been checked
04:16:48 <Wizek> > typeOf typeOf
04:16:49 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
04:16:49 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
04:16:50 <lambdabot>  The type variable ‘a0’ is ambiguous
04:16:50 <lambdabot>  Note: there are several potential instances:
04:16:50 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
04:16:54 <vanila> for executing the program I mean
04:17:30 <Wizek> vanila: That is true, so this function may only be defined/used in GHCi.
04:18:04 <Axman6> > typeOf id
04:18:05 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
04:18:05 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
04:18:05 <lambdabot>  The type variable ‘a0’ is ambiguous
04:18:05 <lambdabot>  Note: there are several potential instances:
04:18:05 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
04:18:07 <merijn> Wizek: Which function?
04:18:12 <Axman6> > typeOf (id :: Int -> Int)
04:18:14 <lambdabot>  Int -> Int
04:18:17 <Axman6> nice
04:18:25 <Wizek> Hmm!
04:18:46 <Wizek> > typeOf (*)
04:18:47 <lambdabot>  Integer -> Integer -> Integer
04:18:56 <Wizek> > :t typeOf (*)
04:18:57 <lambdabot>  <hint>:1:1: parse error on input ‘:’
04:18:58 <Axman6> > typeOf (typeOf `asAppliedTo` (1 :: Int))
04:19:01 <Wizek> :t typeOf (*)
04:19:02 <lambdabot>  Int -> TypeRep
04:19:02 <lambdabot> TypeRep
04:19:18 <Axman6> :t asAppliedTo
04:19:19 <lambdabot> (a -> b) -> a -> a -> b
04:19:23 <Wizek> > show $ typeOf (*)
04:19:24 <lambdabot>  "Integer -> Integer -> Integer"
04:19:27 <Wizek> !
04:19:31 <Wizek> There we go
04:20:04 <Wizek> merijn: the (show $ typeOf) one. :)
04:21:10 <Wizek> :t map (show . typeOf . replicate flip) [1..3]
04:21:11 <lambdabot>     Couldn't match expected type ‘Int’
04:21:11 <lambdabot>                 with actual type ‘(a1 -> b0 -> c0) -> b0 -> a1 -> c0’
04:21:11 <lambdabot>     Probable cause: ‘flip’ is applied to too few arguments
04:22:55 <Wizek> :t map (show . typeOf . (flip replicate) flip) [1..3]
04:22:57 <lambdabot>     No instance for (Typeable c0) arising from a use of ‘typeOf’
04:22:57 <lambdabot>     The type variable ‘c0’ is ambiguous
04:22:57 <lambdabot>     Note: there are several potential instances:
04:24:43 <Wizek> @hoogle asAppliedTo
04:24:44 <lambdabot> No results found
04:27:17 <Wizek> :t asTypeOf
04:27:18 <lambdabot> a -> a -> a
04:27:41 <Wizek> @hoogle asTypeOf
04:27:41 <lambdabot> Prelude asTypeOf :: a -> a -> a
04:28:02 <mietek> https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns - it seems like most of this isn't currently implemented by GHC, or XViewPatterns doesn't expose all syntactic features?
04:28:43 <mietek> Such as the implicit Maybe syntax  (fib np 2 => n)
04:28:56 <mietek> Or the implicit view function syntax  (-> Unit)
04:29:02 <Wizek> Axman6: Where does this `asAppliedTo` function come from?
04:29:12 <mietek> Is there another extension which I've missed?
04:29:49 <merijn> mietek: Read the GHC manual?
04:30:00 <merijn> mietek: The wiki is the original proposal for the feature, it's not documentation
04:30:16 <merijn> mietek: The GHC documentation should have examples and everything
04:30:22 <notdan> @src asAppliedTo
04:30:23 <lambdabot> Source not found.
04:30:47 <Wizek> @src asTypeOf
04:30:47 <lambdabot> asTypeOf = const
04:30:57 <Wizek> notdan: It is nowhere.
04:31:05 <Axman6> Wizek: not sure, could be part of the prelude
04:31:13 <Wizek> Axman6: It is not.
04:31:35 <merijn> Data.Typeable, presumably
04:31:51 <merijn> But asTypeOf is just const with a different type signature
04:31:53 <Axman6> could be a lambdabot thing, but as you can see, it's just type hackery over const
04:32:08 <merijn> lambdabot imports tons more than just prelude
04:32:17 <quchen> asAppliedTo = const :: (a -> b) -> a -> (a -> b)
04:40:42 <Wizek> How can I make GHCi to show functions isntead of saying "No instance for (Show (a0 -> a0)) arising from a use of `print'"?
04:41:51 <iota_> Wizek: you can define an instance of Show for functions, it won't be very helpful
04:41:56 <Axman6> what do you mean by "show functions"?
04:43:03 <iota_> instance Show (a -> b) where show _ = "Function" -- is close to the best you can do
04:43:03 <dv-> > show (+1)
04:43:05 <lambdabot>  "<Integer -> Integer>"
04:44:05 <iota_> > show (:)
04:44:06 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
04:44:06 <lambdabot>    arising from a use of ‘GHC.Show.show’
04:44:06 <lambdabot>  The type variable ‘a0’ is ambiguous
04:44:06 <lambdabot>  Note: there are several potential instances:
04:44:06 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
04:45:04 <jakex> > show putStrLn
04:45:06 <lambdabot>  "<[Char] -> IO ()>"
04:45:13 <jakex> how does lambda bot do it?
04:45:49 <dv-> https://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/Data-Typeable.html
04:45:49 <FreeFull> > show ((:) :: Int -> [Int] -> [Int])
04:45:50 <lambdabot>  "<Int -> [Int] -> [Int]>"
04:46:51 <Wizek> Axman6, iota_: Yes, something along the lines of what lambdtabot returns would be what I am looking for.
04:47:50 <Wizek> @src show
04:47:50 <lambdabot> show x = shows x ""
04:47:54 <Wizek> @src shows
04:47:54 <lambdabot> Source not found. Maybe you made a typo?
04:48:10 <dv-> Wizek: why don't you just use :t ?
04:48:12 <Axman6> @src shows (->)
04:48:12 <lambdabot> Source not found. That's something I cannot allow to happen.
04:48:46 <Axman6> @src Show (->)
04:48:47 <lambdabot> Source not found. Do you think like you type?
04:48:54 <Wizek> @src shows (->)
04:48:55 <lambdabot> Source not found. :(
04:48:56 <Axman6> @src Show (a -> b)
04:48:56 <lambdabot> Source not found. My pet ferret can type better than you!
04:49:00 <Wizek> @src shows (->)
04:49:00 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:49:14 <Wizek> @src shows (->)
04:49:14 <lambdabot> Source not found. :(
04:49:49 <Jafet> Isn't src just a text file with all the code snippets from the report in it
04:50:10 <Axman6> yeah... doesn't stop me trying though =)
04:50:26 <Axman6> it's a bit more intelligent than that I think, but not much
04:50:32 <Axman6> @src Functor Maybe
04:50:32 <lambdabot> Source not found. Sorry.
04:50:39 <Axman6> @src Maybe Functor
04:50:40 <lambdabot> Source not found. Maybe if you used more than just two fingers...
04:50:49 <Axman6> @src fmap Maybe
04:50:49 <lambdabot> Source not found. Are you typing with your feet?
04:51:11 <Wizek> @src shows (->)
04:51:11 <lambdabot> Source not found. Maybe you made a typo?
04:51:19 <Wizek> @src fmap
04:51:19 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:51:29 <Jafet> @src [] fmap
04:51:29 <lambdabot> fmap = map
04:51:45 <saml_> so i was thinking. given a list. i can't just split at first n element without traversing n elements
04:51:48 <Jafet> It's still a text file, though
04:51:53 <merijn> saml_: Right
04:52:02 <saml_> wait. i can with dropWhile and stuff, right?
04:52:15 <merijn> saml_: dropWhile still traverses n elements...
04:52:37 <Axman6> it's basically not possible to do anything with element n without traversing n elements
04:52:39 <Jafet> > split maxBound [0..] -- sure you can
04:52:39 <saml_> so that makes sense
04:52:40 <lambdabot>  No instance for (GHC.Show.Show a0)
04:52:41 <lambdabot>    arising from a use of ‘M5188104746788810573001.show_M5188104746788810573001’
04:52:41 <lambdabot>  The type variable ‘a0’ is ambiguous
04:52:41 <lambdabot>  Note: there are several potential instances:
04:52:41 <lambdabot>    instance [safe] GHC.Show.Show
04:52:48 <Jafet> > splitAt maxBound [0..]
04:52:49 <lambdabot>  ([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
04:52:49 <saml_> even for  head:tail,  you are traversing the first element
04:53:15 <merijn> Jafet: You can't access the second element of splitAt without recursing
04:53:21 <saml_> today i learned about linked list
04:53:32 <Jafet> Well, that is true.
04:53:52 <Wizek> dv-: Well, My brain is getting trained to ignore the "No instance for (Show ...)" error in GHCi, and treat it as a clunky success, but still, success shouldn't be presenmted as an error. This is especially confusing for new users.
04:53:57 <Jafet> > snd $ splitAt maxBound [0..] -- you should just post this though
04:54:01 <lambdabot>  mueval-core: Time limit exceeded
04:54:17 <Axman6> Wizek: well don't do wrong thengs then! :P
04:54:18 <merijn> Wizek: ghci tries to print the result, if the result is not printable, what do you want it to do?
04:54:35 <merijn> Wizek: The only thing it can do is tell you "this is not printable"
04:54:36 <Wizek> merijn: print the type.
04:54:50 <Axman6> it does
04:54:52 <merijn> Wizek: Why would it do that? That makes no sense
04:54:55 <Axman6> and much more!
04:55:21 <merijn> Wizek: Typing an expression into ghci means "evaluate this expression and show the result"
04:55:35 <merijn> Wizek: If you don't want to show the result, why are you typing it in ghci?
04:55:37 <Wizek> Axman6: Do you refer to the rest of the error message when you say "much more"?
04:55:56 <Axman6> yes
04:56:00 <Jafet> Wizek: if you want the type, then use the :type command
04:56:10 <Jafet> Is that too hard?
04:56:39 <Axman6> also :t is quite easy to type
04:56:48 <Axman6> it's a reflex you should learn
04:56:51 <int-e> how do you pronounce >>= in "IO, IO, it's off to (>>=) I go"?
04:56:56 <Wizek> merijn: Because I am experimenting with trying to compose something useful. And along the way, sometimes the end result is non-Show, like a function, which is okay, I plan on using it.
04:57:01 <Axman6> bind
04:57:19 <merijn> Wizek: Then type ":t" in front while experimenting? That's what I do
04:57:41 <merijn> Wizek: bonus is you get to see how the type changes as you add bits
04:58:17 <quchen> And if you want the type of a sub-expression, then GHC 7.8 to the rescue!  foo = bar baz (qux `asTypeOf` _)
04:58:27 <Axman6> type guided development
04:58:40 <Axman6> :o
04:58:45 <Jafet> int-e: according to tdammers' monadic theory of drinking, >>= is "order another round"
04:59:04 <Jafet> Type driven development
04:59:07 <Phillemann> lol
04:59:17 <quchen> <*> is "order another round, but in the same glass"
04:59:27 <int-e> Jafet: is that so.
05:00:26 <Jafet> Wizek: if this annoys you sufficiently, you can patch ghci
05:00:51 <Jafet> However, the only reason to do this is to get the result in it, and it is evil.
05:01:08 <tdammers> looks like I'm onto something
05:01:19 <Phillemann> Is there a way to integrate hlint into cabal, so that it is run before/after the source files are compiled?
05:01:30 <Wizek> merijn, Axman6, whoeverelse: What harm would it do if GHCi had a simple try...catch (or something equivalent) while evalating? try { expression } catch (e) { :t expression }
05:01:38 <Jafet> You should ask if the icfp has any "after-hours" conference slots
05:02:24 <tdammers> heh
05:02:26 <Axman6> Wizek: with i'm not sure how well that would work with the "it" mechanism
05:02:30 <merijn> Wizek: What would it catch?
05:02:37 <merijn> Wizek: Type errors don't throw exceptions
05:02:42 <merijn> Wizek: There's nothing to catch
05:02:57 <Jafet> Oh boy :set -XDeferTypeErrors
05:03:09 <Axman6> heh
05:03:11 <Jafet> (Someone please implement this)
05:03:26 <tdammers> Jafet: it exists. It's called Lisp.
05:03:37 <Wizek> merijn: Since GHCi doens't crash for user-type-errors, I'm positive it is able to detect and react to them.
05:03:44 <Jafet> Where I grew up, people call it python
05:03:48 <srhb> Don't we have -fdefer-type-errors?
05:04:03 <Wizek> Jafet: That is already implemented, isn't it?
05:04:06 <srhb> Indeed
05:04:26 <merijn> Wizek: ghci first has to compile your input, run it and show you the result
05:04:31 <Jafet> Can it be enabled with :set?
05:04:48 <Wizek> merijn: so?
05:05:14 <srhb> Jafet: :set -fdefer-type-errors
05:05:23 <merijn> Wizek: Hiding the compilation error makes it impossible for users to see, well, the compile error
05:05:27 <merijn> Wizek: Additionally
05:05:41 <merijn> Wizek: You can't use ':t' on code that is a compile error
05:05:50 <srhb> Jafet: Though naked expressions will still be errored immediately
05:06:08 <merijn> Wizek: So your suggestion would result that "if code doesn't compile, try using ':t' which won't do anything since your code doesn't compile"
05:07:00 <Wizek> merijn: Let's differentiate 3 phases: syntax-error, type-error, run-error
05:07:28 <Jafet> Huh, I didn't know -f options could be :set. I wonder how many of those are useful.
05:07:31 <Wizek> merijn: in the case of the first two, it doesn't matter, the code is still faulty, and the correct error is shown.
05:07:46 <merijn> Wizek: The show error you're getting is the second type
05:07:52 <merijn> Wizek: You're getting a type-error
05:08:11 <merijn> Wizek: So your suggestion doesn't remove the problem
05:08:37 <srhb> I just don't understand why one would care about such a construct
05:09:16 <Wizek> merijn: Well, how about a simple mechanism like this: IFF there is a type-error, attmpt `:type`. If that still errors, show the user the error.
05:09:17 <Wizek> ?
05:09:50 <Jafet> Sure, shouldn't be hard to patch that in to ghci.
05:10:04 * merijn still doesn't really see the point
05:10:39 <Wizek> merijn: You may not see the point, but can you see any harm if it was implemented?
05:10:56 <merijn> Wizek: Well, someone has to invest the time to implement it
05:11:06 <Wizek> merijn: other than that?
05:11:23 <srhb> As long as it were only a ghci thing, no.
05:11:32 <Wizek> Hooray!
05:11:59 <MP2E> Doesn't it show type errors right *now* though? What would be different? And what do you mean "if that still errors, show the user the error"
05:12:02 <MP2E> what error?
05:12:12 <Walther> syntax highlighting in ghci would be fun too
05:12:26 <Wizek> One step closer to (potentially) improving GHCi, we are! :D
05:12:26 <Walther> and shouldn't be too difficult as the interpreter probably already knows types etc
05:12:35 * MP2E doesn't see the point either
05:12:46 <Jafet> Walther: ghci isn't an editor, why would it do syntax highlighting.
05:13:08 <Walther> Jafet: because colors! :D (Could be optional, no need to force it.)
05:13:10 <Jafet> Most haskell editors can do syntax highlighting perfectly fine (sometimes with assistance from ghc or haskell-src)
05:13:11 <orion> Hi. When companies need to design a large Haskell application, how do they plan everything out? for example in C++ one might make a UML diagram.
05:13:17 <merijn> Wizek: Not really, the only step to improving ghci is to find someone that has to time to implement a feature
05:13:30 <MP2E> Yep.
05:13:33 <Walther> Jafet: I'm talking about ghci, the interactive repl
05:14:25 <Jafet> ghci is not an editor so why should it perform syntax highlighting.
05:14:26 <Wizek> merijn: That's why I carefully places "potentially" in there. If I wasn't too shy I might look into how to add this.
05:14:44 <Jafet> You can download ghc source and have at it.
05:14:58 <Wizek> Jafet: GHCi.
05:15:10 <Wizek> they are the same repo?
05:15:11 <MP2E> GHCi is part of GHC's source
05:15:39 <srhb> Walther: Hello again
05:15:48 <Walther> Hi there, how's life? :)
05:15:59 <srhb> Bit of a headache. :P
05:16:01 <Walther> recovered from yesterdays head-banging against desk? :P
05:16:02 <Walther> haha
05:16:05 <Walther> sorry about that
05:16:08 <srhb> Not from that!
05:16:17 <srhb> Had a little too much to drink last night.
05:16:23 <Walther> heh, happens
05:17:21 <Wizek> MP2E: Answering your question: The errors possible from executing an expression is a superset of `:t`'ing an expression, right?
05:17:24 <srhb> Walther: Reminds me, if you've changed the code such that there's a "main loop" now, I'd like to give it a go illustrating a few methods
05:17:57 <Walther> srhb: we have a couple ideas going on, we'll probably ask further questions later when we run into more walls :)
05:18:03 <srhb> Walther: OK :)
05:18:08 <MP2E> Ah, :t is a bit friendlier. I see
05:18:11 <Walther> Huge thanks again for all the help
05:18:19 <srhb> Walther: No problem :)
05:18:41 <Wizek> MP2E: So, my proposal is all about using :t for that friendly segment.
05:26:41 <Wizek> Hmm, interesting. I genuenly believe in the principle: "Only show error message to the user if they did something wrong." This is especially true for new users. I remember first using GHCi, it looked very scary to receive those "No instance" errors and thinking that I did something wrong. Now that I know all this, will I take the time to improve it for newcommers, or will I
05:26:42 <Wizek> just get used to the workaround that everyone else seem to do: if "No instance" then "prepend :t"?
05:29:37 <merijn> Wizek: I don't "prepend :t if I see No instance"
05:29:48 <merijn> Wizek: When I'm writing code I know what I expect it to do
05:30:02 <merijn> If I want to evaluate and print an expression, then I write it as normal
05:30:10 <merijn> If I want to see the type I write ':t'
05:30:24 <merijn> I don't see why you'd have to wait until you get an error to starting using ':t'?
05:30:43 <Wizek> merijn: How long have you been using GHCi?
05:30:55 <merijn> You said you were "playing around trying to construct an expression", well then you already know you want to use ':t' before you've even written a single character, no?
05:31:20 <merijn> The only time I *don't* use ':t' is when I already know the expression is correct and want it to run
05:31:36 <merijn> (well, sometimes I "know" wrongly, but still)
05:31:55 <merijn> Wizek: For a while now, but I don't remember ever having difficulty knowing what I wanted
05:32:23 <Wizek> merijn: let us quantify "for a while". :)
05:32:31 <merijn> Wizek: Where we differ in opinion is that you seem to believe that typing an unprintable expression "isn't wrong"
05:32:45 <merijn> While I believe that typing an unprintable expression in ghci *is* wrong
05:33:15 <merijn> Wizek: about 4 years?
05:34:15 <Wizek> merijn: That means that in about 2.5-3 years, I might get used to this behaviour if nothing changes until then.
05:35:01 <Wizek> merijn:Given your workflow, shouldnt `:t` be the default and a `>` prefix could signify execution?
05:35:02 <merijn> Wizek: Your implication is that I was initially confused by the behaviour too, but I wasn't
05:35:21 <merijn> Wizek: No, because most of the times I write expressions I want evaluated
05:35:34 <merijn> I use ':t' significantly less than evaluation
05:40:07 <tdammers> literate ghci, lol
05:57:16 <srhb> Especially now with typed holes being the default, I'd probably stick a _ in somewhere inside my expression instead
06:01:58 <thoughtp1lice> now that we have typed holes, i want PartialTypeSignatures, since they will allow the same thing in types, too.
06:02:30 <jakex> will this top-level code be calculated only once, the first time I use the variable? consonants = filter (`notElem` vowels) ['a'..'z']
06:03:12 <Jafet> Yes, CAFs are calculated only once.
06:03:24 <jakex> on first use?
06:04:27 <srhb> jakex: Depends. INlining might happen even before.
06:05:24 <gXen> I am enjoying learning haskell
06:05:38 <srhb> gXen: :-) Good!
06:07:50 <gXen> but I'd have to say... it isnt very different from the way I used python... so far at least
06:10:21 <srhb> gXen: That's interesting
06:10:30 <srhb> gXen: You're probably the first person in ever to feel like that :P
06:10:40 <christiaanb> I'm getting "500 Internal Server Error" when trying to upload documentation to hackage. Is that just me? or are others getting it too?
06:11:13 <jakex> gXen how far in LYAH are you?
06:11:37 <gXen> srhb: I used to write to code in python by basically just creating functions, and executing these functions... and I use mainly iterators... which is relatively the same as lazy eval
06:11:54 <gXen> jakex: chapter 2 :)
06:11:55 <srhb> gXen: Okay :)
06:12:30 <jakex> gXen exciting things to come :)
06:12:39 <gXen> i like so far that haskell is a bit more concise, without giving up readibilty if you get used to the notation
06:12:47 <bacon1989> I just need to wrap my head around monads and monoids
06:15:37 <BoR0> how can I do something like mapM (snd) [(1, getLine), (2, getLine)] but as a result to get [(1, "input"), (2, "input")] ? I tried something like (\x -> return (fst x, snd x)) but it didn't work
06:15:40 <jakex> I come from python too, and what impressed me the most at first is how haskell is able to deduce the type of (nearly) everything without any annotations.. it seemed like magic
06:16:02 <simon> inference is like magic.
06:19:15 <gowda> Hello! How do I install a package outside the sandbox? e.g. cabal install --global installs it in .cabal-sandbox, but I'd like it to go to ~/.cabal/bin or the systemwide cabal bin
06:19:15 <bennofs> in instance (C1 a, C2 b) => ..., can I tell ghc to always check C2 b first? Because checking 'C1 a' might give a context context reduction stack overflow
06:19:15 <Axman6> :t (\p -> snd p >>= (fst p,))
06:19:15 <lambdabot> Monad ((,) t) => (t, (t, b)) -> (t, b)
06:19:16 <dcoutts> gowda: simplest is just to cd to a different dir outside the sandbox
06:19:16 <supki> :t (traversed._2) id :: [(Int, IO String)] -> IO [(Int, String)]
06:19:16 <lambdabot> [(Int, IO String)] -> IO [(Int, String)]
06:19:16 <Axman6> :t (\p -> snd p >>= return . (fst p,))
06:19:16 <lambdabot> Monad m => (t, m a) -> m (t, a)
06:19:16 <bennofs> And I'd like to get the more readable error from failing to satisfy 'C2 b'
06:19:16 <lllll> >>= return . better written as <$>
06:19:16 <gowda> dcoutts: and run cabal install project-dir/?
06:19:17 <supki> :t (traverse._2) id :: [(Int, IO String)] -> IO [(Int, String)]
06:19:17 <lambdabot> [(Int, IO String)] -> IO [(Int, String)]
06:19:17 <lllll> :t \(v, m) -> (,) v <$> m
06:19:17 <lambdabot> Functor f => (a1, f a) -> f (a1, a)
06:19:17 <gowda> dcoutts: aha! Nice! Thank you!
06:19:44 <bennofs> :t _2 id `asTypeOf` \(v, m) -> (,) v <$> m
06:19:45 <lambdabot> Functor f => (a1, f a) -> f (a1, a)
06:22:09 <lllll> :t liftA2 fmap ((,) . fst) snd
06:22:10 <lambdabot> Functor f => (b, f a) -> f (b, a)
06:22:56 <lllll> :t liftA2 (<$>) ((,) <$> fst) snd
06:22:57 <lambdabot> Functor f => (a1, f a) -> f (a1, a)
06:22:59 <lllll> perfect
06:23:41 <orion> Please propose an alternative.
06:23:41 <orion> 08:15:29 <+orion> Is it possible to wrap I2NP in SSL or SSH?
06:23:44 <orion> oops
06:23:57 <orion> tokenize (c : cs) = ... : tokenize cs <-- What does the colon mean here?
06:24:01 <orion> The second colon
06:24:10 <simon> orion, the cons operator.
06:24:17 <orion> ahh ok
06:24:36 <simon> 1 : [2]  =  [1,2]
06:24:52 <jakex> orion in that context : is used for pattern matching. c is assigned the first element, cs all the other elements
06:24:55 <lllll> both colons mean the same thing :-)
06:25:05 <lllll> jakex: that's the first colon
06:25:31 <jakex> right, sorry, I didn't read the second part of the question
06:25:41 <gXen> is haskell compiled to C?
06:25:55 <lllll> gXen: that's not a language property
06:26:18 <lllll> in practice: no
06:27:14 <srhb> gXen: ghc used to compile down to C in the old old old code generator
06:27:38 <gXen> srhb: nowadays? straight to assembly?
06:27:55 <lllll> yes, or bytecode
06:27:58 <lllll> or javascript
06:28:06 <srhb> gXen: There's nothing straight about it, but yes, that's the default code generator in ghc
06:28:11 <srhb> gXen: There's also the llvm backend
06:31:25 <eizo> http://i.imgur.com/pFS9cUM.png what are those "historical reasons" they keep talking about?
06:32:45 <Ireneista> eizo: I would assume simply that it was like that in the Haskell98 report
06:33:02 <Ireneista> eizo: because people didn’t have enough experience with the language yet and/or using typeclasses in the Prelude was too controversial
06:33:40 <Jafet> There are genericized Preludes floating around somewhere
06:33:48 <Jafet> :t genericLength
06:33:49 <lambdabot> Num i => [a] -> i
06:37:30 <gXen> is haskell's memory footprint any good - and how about concurrency?
06:39:46 <bennofs> gXen: haskell has very nice concurrency features (async, stm, MVar)  and green threads (-> threads are cheap)
06:39:53 <notdan> .w 22
06:39:56 <notdan> oops, sorry
06:41:19 <gXen> is sharing state between threads/processes easy?
06:41:19 <lllll> depends on your definition of state
06:41:19 <gXen> I guess its a different thing in haskell
06:41:19 <gXen> :)
06:42:14 <Jafet> Why not write a concurrent program that needs a lot of memory, then you will find out how good it is.
06:42:16 <lllll> ghc has no issues spawning 100k threads
06:43:24 <jakex> fun read: http://stackoverflow.com/questions/1900165/how-long-does-it-take-to-create-1-million-threads-in-haskell
06:43:48 <Jafet> What a pointless\ question.
06:47:35 <tdammers> writing a piece of code that spawns one million threads takes approximately 10 seconds
06:48:33 <gXen> according to the webapge, thats also more or less the time it took on their hardware to spawn the threads :)
06:49:17 <tdammers> hmm, but then, they're green threads, so the overhead of "creating" them is kind of meaningless
06:49:21 <gXen> is there any good source code in haskell that I can read?
06:49:48 <tdammers> gXen: sure... hackage is full of source code
06:50:23 <Jafet> "good" is another matter. You can try the self proclaimed "functional pearls" papers
06:50:39 <Jafet> Or sigfpe's blog, etc.
06:53:17 <nh2> gXen: or you can read my code and tell me if it's good afterwards :)
06:53:23 <merijn_> gXen: I've heard good things about the Xmonad source
06:53:36 <gXen> nh2: whats it about?
06:55:49 <srhb> Both Xmonad and Pandoc are very readable.
06:56:26 * hackagebot syntactic 1.12.1 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.12.1 (EmilAxelsson)
06:56:28 * hackagebot clash-lib 0.3.0.1 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.3.0.1 (ChristiaanBaaij)
06:56:30 * hackagebot clash-ghc 0.3.0.2 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.3.0.2 (ChristiaanBaaij)
06:56:57 <nh2> gXen: I could offer a utility that takes data from the Emotiv EEG, decrypts it, and serves or saves it in different fashions: https://github.com/nh2/hemokit/blob/master/apps/Dump.hs
06:57:53 <gXen> nh2: thx, that looks very readable for a beginner
07:27:46 <cschneid> is there a blog post / tutorial that walks through the generalization of functions into the Category package? ie, the motivation & use of them?
07:27:54 <cschneid> I read the wikipedia page, but that doesn't really translate to the programming world for me well.
07:41:32 * hackagebot penny 0.32.0.10 - Extensible double-entry accounting system  http://hackage.haskell.org/package/penny-0.32.0.10 (OmariNorman)
07:51:33 * hackagebot http-reverse-proxy 0.3.1.6 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.3.1.6 (MichaelSnoyman)
08:01:35 * hackagebot hledger-web 0.22.7 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.22.7 (SimonMichael)
08:04:53 <byorgey> cschneid: I don't know of any such tutorial, and I'm not familiar with any particular uses of them, but they would be useful any time you want to talk about functors between categories other than Hask.
08:05:22 <cschneid> byorgey: I guess I want to see the practical use of Control.Category :)
08:05:24 <byorgey> some obvious examples of such categories you might want to talk about include  Hask x Hask  (where objects are pairs of types and morphisms are pairs of functions)
08:05:30 <cschneid> "how would I use this in programming stuff"
08:05:47 <byorgey> and also some 'subsets' of Hask like "only those types with an Ord instance, and order-preserving functions)
08:06:03 <cschneid> byorgey: that sounds like arrows? (a, b) -> (f1, f2) -> (a',b')
08:06:06 <tdammers> huh, this is weird
08:06:07 <cschneid> is &&& isn't it?
08:06:14 <fizruk> cschneid: to combine function-like objects with id and . ?
08:06:15 <byorgey> cschneid: it's ***, but yes
08:06:19 <cschneid> oh, ok
08:06:19 <cschneid> :)
08:06:30 <tdammers> I get an error that there is no Show instance for UTCTime, unless I import Network.Wai
08:07:04 <cschneid> fizruk: yeah, I got the technical definition :)  I was wondering a practical use of the typeclass to solve problems.
08:07:05 <fizruk> cschneid: e.g. lenses, pipes and some more stuff (I really do not use those, so may be wrong)
08:07:29 <monochrom> tdammers: you could also import Data.Time
08:07:35 <cschneid> fizruk: I feel like I should read the pipes source & really try to grok some of its internals. seems pretty well designed
08:07:38 <Freundlich> What's the best way to wrap C libraries that have ordering dependencies on resources? Would it be possible to use bracket for everthing (like RAII)?
08:08:02 <tdammers> monochrom: I have Data.Time.Clock
08:08:16 <monochrom> sure, the Show instance is not there
08:08:18 <tdammers> assumed that would also import the Show instance, but apparently it doesn't
08:08:30 <byorgey> tdammers: in that case you should have a Show instance fo UTCTime.  The other possibility is that this is a problem with package version mismatches.
08:08:39 <byorgey> tdammers: check whether you have two different versions of 'time' installed.
08:08:56 <edwardk> cschneid: data-lens uses Control.Category to compose, so do most of the non-lens lens lbraries. constraints uses to reason about entailment. eq uses it to transitively compose equalities. Data.Coerce uses it to transitively compose Coercible instances. Every Arrow is a Category so you can reuse id and (.) for them.
08:09:01 <monochrom> use :info UTCTime to discover which "precise" module the Show instance is in. then find out that you may as well give up and use Data.Time
08:09:04 <byorgey> monochrom: the Show instance is defined in Data.Time.Clock.
08:09:31 <byorgey> oh, wait, I am wrong.
08:10:10 <monochrom> the Show and Read instance are in a module nobody could educated-guess
08:10:31 <byorgey> but the Show instance is exported from Data.Time.Clock.
08:11:14 <tdammers> byorgey: apparently it's not
08:11:27 <tdammers> the one for NominalDiffTime is, but not the one for UTCTime
08:11:35 <byorgey> tdammers: what version of 'time' do you have?
08:11:38 <tdammers> importing Data.Time, however, works
08:11:41 <tdammers> 1.4 something
08:11:51 <tdammers> I forced >= 1.4 in the .cabal
08:12:08 <tdammers> checked the source, and the instance actually isn't in Data.Time.Clock
08:12:16 <cschneid> edwardk: sounds like the answer for lots of my questions is to wait for you to list a bunch of libraries, then just read their source and understand it. Thanks for the pointers to uses
08:12:22 <byorgey> tdammers: no, but it is exported from there.
08:12:51 <byorgey> at least it is in time-1.4.0.1.  In my ghci, I do   :m +Data.Time.Clock;  t <- getCurrentTime;  show t
08:13:09 <byorgey> with no error.
08:14:07 <edwardk> cschneid: The Mealy machines in my machines package form a category, Klesli and Cokeisli arrows.. there are a lot of them. =)
08:14:16 <fizruk> edwardk: btw, can you point me to free applicatives uses (aside from mentioned in free docs)?
08:14:19 <tdammers> I do the same, and it says "No instance for (Show UTCTime)..."
08:14:33 <tdammers> time 1.4.0.1
08:14:51 <tdammers> ghc 7.6.3
08:15:45 <fizruk> edwardk: I tried to use them for validation forms, but had some troubles with effectful validation
08:15:48 <byorgey> that is very odd.  I have the same versions.
08:16:17 <byorgey> tdammers: what is the output of 'ghc-pkg list time'?
08:16:29 <lllll> did you both restart ghci?
08:16:34 <tdammers> /var/lib/ghc/package.conf.d time-1.4.0.1
08:16:35 <tdammers> /home/tobias/.ghc/x86_64-linux-7.6.3/package.conf.d
08:16:45 <tdammers> lllll: yes. fresh ghci
08:16:54 <edwardk> fizruk: not sure what kinds of problems you've had, they should be pretty straightforward to use, though. i'm heading out the door at the moment, but am happy to pick this up later.
08:17:07 <tdammers> I get the same situation in a cabal sandbox
08:17:15 <tdammers> where I force time to >= 1.4
08:17:30 <fizruk> edwardk: okay, will try to catch you later
08:18:23 <tdammers> I have a few default imports in my ghci config, but AFAIK, this should only *add* instances, not *remove* them
08:19:06 <byorgey> tdammers: whoops, my mistake.  Apparently the Show UTCTime instance was getting transitively imported by something in my .ghci (not obvious which)
08:19:23 <byorgey> when I do  ghci -ignore-dot-ghci  I do get the 'no instance for Show UTCTime' error
08:20:35 <byorgey> the original reason I thought the instance was exported from Data.Time.Clock is that the Show instance is listed under UTCTime in the Haddock documentation for Data.Time.Clock.
08:20:46 <byorgey> I thought if an instance is listed then it is exported, but apparently that is wrong.
08:21:39 <tdammers> yeah, that's what tripped me up at first too
08:22:25 <byorgey> tdammers: sorry for the noise, glad you got it sorted out
08:23:31 <tdammers> np
08:23:37 <tdammers> glad it's not an actual bug
08:27:14 <Phillemann> There seems to be Data.Int, but no Data.Double. Why is that?
08:28:02 <Yuu_chan> There aren't many different Doubles :)
08:28:23 * Yuu_chan imagines Float8
08:29:05 <tdammers> brrrr... 4-bit mantissa, 3-bit exponent, 1-bit sign?
08:30:24 <Yuu_chan> Something like that :)
08:30:25 <mjrosenb> tdammers: nobody will ever use that.  you only have 14 NAN values.
08:31:40 * hackagebot sized-types 0.5.0 - Sized types in Haskell using the GHC Nat kind.  http://hackage.haskell.org/package/sized-types-0.5.0 (AndyGill)
08:31:42 * hackagebot Obsidian 0.1.0.0 - Embedded language for GPU Programming  http://hackage.haskell.org/package/Obsidian-0.1.0.0 (JoelSvensson)
08:33:01 <vanderson> Guys, I'm new in Haskell and I did a recursive solution to a problem. Now I want to mensure the performance of it. So I want to see how many times a recursion was taken, is there a easy way to that? To for example see the recursion tree.
08:33:28 <Yuu_chan> vanderson: trace from the Debug.Trace module
08:35:01 <Yuu_chan> It's probably the easiest, yet not versatile, method to add debug output into pure functions.
08:35:35 <vanderson> Hum.. trace don't return a monad?
08:35:40 <Yuu_chan> More complex solutions would include Writer or State monads, for example.
08:36:04 <Yuu_chan> No, it prints an arbitrary string and returns a (pure) value
08:36:11 <lllll> someFunction x y z | trace ("-> someFunction " ++ show x ++ show y ++ show z) False = undefined
08:36:11 <Yuu_chan> :t trace
08:36:12 <lambdabot> Not in scope: ‘trace’
08:36:19 <Yuu_chan> @hoogle trace
08:36:19 <lambdabot> Debug.Trace trace :: String -> a -> a
08:36:19 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
08:36:19 <lambdabot> package trace-call
08:36:27 <fizruk> vanderson: trace is a cheat
08:36:40 * hackagebot module-management 0.20 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.20 (DavidFox)
08:36:43 <vanderson> Oh.. that will be helpfull, because I tried with prints and would need to change all my code because of the monads
08:37:04 <lllll> for measuring performance I'd measure performance
08:37:19 <lllll> i.e. time execution
08:37:27 <lllll> I know ghc also supports some kind of profiling
08:37:42 <vanderson> So trace is exactly what I was looking for. Thank you guys.
08:37:48 <Yuu_chan> That's arguably not for beginners
08:38:01 <Yuu_chan> vanderson: you're welcome!
08:38:36 <lllll> hmm
08:38:54 <lllll> my sample code affects evaluation order
08:39:16 <Yuu_chan> vanderson: if you decide to measure execution some time, take a look at "criterion" package
08:39:22 <lllll> someFunction x y z | trace "someFunction _ _ _" False = undefined  -- probably better
08:42:30 <skypers> is there a way to do something like
08:42:34 <skypers> class Foo i a where
08:42:41 <skypers>   data Bar :: a -> *
08:42:44 <skypers> ?
08:42:48 <skypers> I thought it was PolyKinds
08:42:51 <skypers> but it’s not
08:43:12 <monochrom> TypeFamilies
08:43:47 <skypers> no monochrom I know
08:43:53 <skypers> I’m talking about the a -> *
08:43:54 <skypers>     Type variable `a' used in a kind
08:43:55 <skypers>     In the kind `a -> *'
08:44:11 <skypers> it might not even have any sense after all
08:44:14 <lechip> noob question
08:44:34 <lechip> anyone willing to help a haskell noob?
08:44:57 <skypers> I just want to express the fact that I want Foo to take a `a` and be a container
08:45:01 <Yuu_chan> A whole channel wouldn't mind
08:45:14 <lechip> im trying to make a function that you give a list of list of integer and gives back the first element of each, in a list
08:45:26 <Yuu_chan> map head?
08:45:29 <skypers> map head
08:45:30 <skypers> yeah
08:45:36 <skypers> or
08:45:39 <lechip> yeah but i want to make it on my own
08:45:49 <Yuu_chan> With explicit recursion?
08:45:51 <skypers> map headSafe
08:46:12 <lechip> i tried with recursion but i might not be understanding how to make the concatenation right
08:46:47 <Yuu_chan> Here it's possible to deal with no concatenation
08:47:17 <lechip> do enlighten me
08:47:26 <ion> “foo (x:xs) = x : foo xs; foo [] = []” recurses over a list without changing it. Can you think of how to modify this to apply a function into each element?
08:47:53 <Yuu_chan> Concatenation is '++', which glues two lists. Here we can build a list one-by-one with ':'.
08:48:27 <lechip> hmmm not too different from what i was trying, let me check
08:48:30 <lechip> ty so much btw
08:49:10 <monochrom> : should be enough for your purpose
08:49:23 <monochrom> take inspiration from how map is written
08:49:26 <monochrom> @src map
08:49:26 <lambdabot> map _ []     = []
08:49:27 <lambdabot> map f (x:xs) = f x : map f xs
08:49:46 <lechip> also quite useful!
08:50:07 <fizruk> skypers: class Test (a :: k) where data T :: k -> *
08:50:39 <skypers> huhu
08:50:43 <fizruk> skypers: there's no such thing as kind classes afaik :)
08:55:55 <leourbina> lechip: you may just want to implement your own version of map and head
08:56:46 <leourbina> lechip: instead of writing a more specific/less versatile function that does exactly your task
09:06:09 <lechip> how do i reffer to a list of list in a pattern?
09:06:26 <lechip> im trying something like listOfFirst [x:xs] = x : listOfFirst xs
09:06:32 <lechip> but apparently thats retarded
09:07:28 <bennofs> lechip: listOfFirst ((x:_):rest) = x : listOfFirst rest
09:07:52 <fizruk> > let (xs:xss) = [[1, 2], [3, 4], [5, 6]] in (xs, xss)
09:07:54 <lambdabot>  ([1,2],[[3,4],[5,6]])
09:08:04 <bennofs> lechip: remember that the head of the list is a list, so you can pattern match on that again (here I'm using the pattern (x:_))
09:08:22 <lechip> bennofs thtat makes total sense, i understand now
09:08:35 <lechip> let me see what i can do then
09:08:50 <Yuu_chan> lechip: this isn't retarded, this is actually a valid pattern for a case where argument is a list with exactly one element which is a nonempty list.
09:09:14 <ReinH> :t \[x:xs] -> (x,xs)
09:09:15 <lambdabot> [[t]] -> (t, [t])
09:09:35 <Yuu_chan> lechip: one of coolest features of patterns is that they can be arbitrarily nested
09:09:57 <lechip> Yuu_chan: I just noticed i can use the nesting yeah
09:10:06 <lechip> let me see what i can do
09:12:14 <albeit> @pl: \t -> read t :: Int
09:12:15 <lambdabot> (:: Int) . read
09:12:41 <Yuu_chan> > let ((a, _), (_, [c]), _, d) = [(1, []), (2, [3]), (4, [5, 6]), (7, [8, 9])] in (a, c, d)
09:12:43 <lambdabot>  Couldn't match expected type ‘((t8, t1), (t2, [t9]), t0, t7)’
09:12:43 <lambdabot>              with actual type ‘[(t3, [t4])]’
09:12:43 <lambdabot>  Relevant bindings include
09:12:43 <lambdabot>    a :: t8 (bound at <interactive>:1:7)
09:12:43 <lambdabot>    c :: t9 (bound at <interactive>:1:19)
09:13:07 <Yuu_chan> > let ((a, _): (_, [c]): _: d) = [(1, []), (2, [3]), (4, [5, 6]), (7, [8, 9])] in (a, c, d)
09:13:09 <lambdabot>  (1,3,[(7,[8,9])])
09:13:32 <Yuu_chan> Eww.
09:15:04 <albeit> Why does "map ((:: Int) . read) ["1", "2"]" give a parse error on "::"?
09:15:12 <ReinH> albeit: because it isn't valid syntax
09:15:17 <ReinH> pl is lying to you
09:15:28 <ReinH> :: isn't an operator and can't be sectioned
09:15:44 <Yuu_chan> pl parsing abilities are limited
09:15:48 <albeit> Is there a nice way to map read?
09:16:07 <Yuu_chan> > map read ["1", "2"] :: [Int]
09:16:08 <lambdabot>  [1,2]
09:16:22 <Yuu_chan> or
09:16:22 <albeit> Ah, thanks!
09:16:28 <skypers> @hoogle Int -> a -> [a] -> [a]
09:16:29 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
09:16:29 <lambdabot> Data.IntMap.Strict findWithDefault :: a -> Key -> IntMap a -> a
09:16:29 <lambdabot> Data.IntMap.Lazy findWithDefault :: a -> Key -> IntMap a -> a
09:16:33 <Yuu_chan> > map (read :: String -> Int) ["1", "2"]
09:16:34 <lambdabot>  [1,2]
09:17:25 <lechip> does this make sense at all? listOfFirst :: [[Int]]->[Int]; listOfFirst [[]] = []; listOfFirst ((x:_):rest) = x : listOfFirst rest
09:17:27 <Yuu_chan> Or don't define types if they can be inferred from the context. E.g., result of mapreading is used where Int's are necessary.
09:18:08 <bennofs> lechip: what should listOfFirst [] be?
09:18:11 <Yuu_chan> lechip: not really
09:18:29 <lechip> it should get a list of the first elements of a list of list
09:18:38 <bennofs> lechip: and listOfFirst [[], [3]]?
09:18:40 <Yuu_chan> lechip: we understand
09:18:57 <lechip> bennofs: just [3]
09:19:09 <lechip> bennofs: but im starting to see why the question
09:19:38 <Yuu_chan> Hm, so it's more like catMaybes . map safeHead
09:19:47 <srhb> > concat . map head $ [[1,2],[3,4]] -- this?
09:19:48 <lambdabot>  No instance for (GHC.Show.Show a0)
09:19:49 <lambdabot>    arising from a use of ‘M38492888547873473783565.show_M38492888547873473783...
09:19:49 <lambdabot>  The type variable ‘a0’ is ambiguous
09:19:49 <lambdabot>  Note: there are several potential instances:
09:19:49 <lambdabot>    instance [safe] GHC.Show.Show
09:19:57 <srhb> woop
09:20:08 <lechip> yes, its what map does but im trying to make it on my own
09:20:10 <lechip> map head*
09:20:24 <bennofs> > mapMaybe listToMaybe [[1,2,3], [], [4]]
09:20:26 <lambdabot>  [1,4]
09:20:26 <srhb> What the heck døs that error mean.
09:20:36 <srhb> does*
09:20:43 <Yuu_chan> Your implementation skips empty sublists, standard map can't
09:21:15 <lllll> foo [] = []; foo ([] : xs) = foo xs; foo ((x : _) : xs) = x : foo xs
09:21:33 <Yuu_chan> srhb: what is concat'ed here?
09:21:37 <srhb> :t concat
09:21:38 <lambdabot> [[a]] -> [a]
09:21:40 <srhb> orite
09:21:47 <srhb> Already happened.
09:21:47 <Yuu_chan> > concat [1, 3]
09:21:49 <lambdabot>  No instance for (GHC.Show.Show a0)
09:21:49 <lambdabot>    arising from a use of ‘M66772909827352818553594.show_M66772909827352818553...
09:21:49 <lambdabot>  The type variable ‘a0’ is ambiguous
09:21:49 <lambdabot>  Note: there are several potential instances:
09:21:49 <lambdabot>    instance [safe] GHC.Show.Show
09:21:52 <srhb> Yep, got it
09:22:02 <lllll> > concat [1, 3 :: String]
09:22:03 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
09:22:03 <lambdabot>    arising from the literal ‘1’
09:22:44 <Yuu_chan> > fromInteger 1 :: [a]
09:22:46 <lambdabot>  No instance for (GHC.Num.Num [a1])
09:22:46 <lambdabot>    arising from a use of ‘GHC.Num.fromInteger’
09:24:11 <lechip> awesome i got it, tnx guys, i get it now
09:24:49 <lechip> question, in essence is right to repeat the name of the variables in different patterns of one ufunction definition? I read somewhere that i should be careful with it
09:25:29 <lllll> lechip: huh?
09:26:21 <lechip> lllll: doing things like foo [] = []; foo ([] : xs) = foo xs; foo ((x : _) : xs) = x : foo xs for example
09:26:34 <lllll> nothing wrong with that
09:26:41 <lllll> but something like foo [x, x] won't compile
09:26:48 <lechip> that makes sense
09:26:50 <lllll> > case "hi" of [x, x] -> ()
09:26:52 <lambdabot>  Conflicting definitions for ‘x’
09:26:52 <lambdabot>  Bound at: <interactive>:1:15
09:26:52 <lambdabot>            <interactive>:1:18
09:27:52 <Jinusai> Hey, in the past I have been using hsenv to easily play around with some packages, i.e. (1) hsenv, (2) source .hsenv/bin/activate (3) cabal install interestingPackage (4) ghci. Is there some way to have the same smooth experience with cabal sandbox? Because (1) cabal sandbox init (2) cabal init (3) modify build-depends by hand (4) cabal repl seems annoying
09:29:30 <BeardedCoder> I'd be interested in hearing the answer to that. I just have a "play" cabal app that's a dumping ground for testing stuff out
09:30:17 <johnw> I'm not sure how the two experiences differ, Jinusai; they both require four commands
09:31:23 <Jinusai> johnw: the new (3) is quite different :)
09:31:31 <johnw> ah
09:33:04 <srhb> Jinusai: No, I don't think so. It's not that the sandbox couldn't allow it, but that the repl depends on the build-depends etc.
09:33:40 <ReinH> Jinusai: well, modifying build-depends is also... what you do to build a haskell package
09:33:51 <ReinH> seems like a reasonable alternative to installing packages ad hoc
09:34:01 <fizbin> What's the option to GHC to set some symbol for the C preprocessor? (I'm using {-# LANGUAGE CPP #-} )
09:34:27 <monochrom> it may be just -D again
09:34:46 <xunplini> Hello. I am trying to write a Haskell AI for 2048, which is definitely working. I am having some difficulty with getting enough search depth. A profiler showed the majority of time is spent in move generation.
09:35:00 <monochrom> yes, it's -D again
09:35:04 <fizbin> monochrom: Ah, yep.
09:35:07 <xunplini> I have this somewhat naive implementation of 2048 logic, am I making any obivous mistakes http://pastebin.com/jB4iDfXB ?
09:35:15 <ReinH> xunplini: sounds like fun.
09:36:01 <ReinH> xunplini: well, ++ is inefficient
09:36:14 <ReinH> xunplini: can we see your profiler report?
09:36:22 <ReinH> that would be better than guessing :)
09:36:32 <xunplini> Of course, let me make a fresh one.
09:36:37 <Jafet> Obvious mistake: caring about 2048
09:37:12 <Jinusai> ReinH: Maybe I just have to get used to this, but for playing around hsenv seemed more comfortable to me
09:37:29 <ReinH> xunplini: a lot of list transposing and reversing might become expensive even if the list size is 4
09:40:56 <lechip> question, when I see parenthesis in types, such as in foldr :: (a -> b -> b) -> b -> [a] -> b, what do the parenthesis mean?
09:41:17 <xunplini> http://pastebin.com/029DQXMp
09:41:45 <ReinH> xunplini: what is scorePos?
09:42:02 <Jinusai> lechip: the first argument to that function is a function (a -> b -> b)
09:42:09 <Yuu_chan> lechip: as with expressions, they group something
09:42:36 <lechip> AH! interesting, I understand better now
09:43:11 <pseudolio> (3 - 2) * 5
09:43:18 <Yuu_chan> lechip: -> is right associative (that means that rightmost parentheses can be omitted: a -> b -> c -> d is short for a -> (b -> (c -> d)))), so when you need ((a -> b) -> c) -> d, you have to do it manually
09:43:39 <xunplini> ReinH: if given a search depth of 0 it evaluates the position, if given a higher one it applies expectimax and calls itself recursively.
09:43:51 <xunplini> Shall I pastebin the entire thing? I tried to keep it to the relevant sections only.
09:43:58 <ReinH> xunplini: yeah, go ahead
09:44:02 <ReinH> xunplini: is this minmax?
09:44:06 <Yuu_chan> Or a -> (b -> c) -> d
09:44:38 <xunplini> I think it is called "expectimax" or spelt something like that. It takes the average of the potential opponent moves, not the best one for the opponent.
09:44:46 <ReinH> xunplini: getMoves is doing a *lot* of allocation. You should write the cases manually or memoize
09:45:14 <ReinH> xunplini: actually no it's moveDown and moveUp
09:45:29 <ReinH> xunplini: first suggestion: switch to an array
09:45:59 <Yuu_chan> You can (with certain simplifications) say that "a0 -> a1 -> ... -> an" is a n-ary functions which arguments have types a0, a1, etc, and result has type an
09:46:02 <ReinH> or an IntMap
09:46:11 <Jafet> Why use expectimax? Do you want it to win 50% of the time?
09:46:18 <xunplini> http://pastebin.com/mdmwjfR7
09:46:41 <xunplini> Jafet: because it's worth it taking a one in a million chance of defeat for greatly improving your position.
09:46:46 <Yuu_chan> So if there are parens in middle, it means some arguments are another functions, and a type inside them can be parsed the same way
09:47:00 <xunplini> Unlike an intelligent opponent, the RNG won't see what you are planning and stop it.
09:47:20 <ReinH> xunplini: oh expectiminmax, you said
09:47:48 <ReinH> win 24
09:49:28 <xunplini> ReinH: I am not sure I understand what you mean with "memoize"
09:50:12 <ReinH> xunplini: actually for a 4x4 grid you might just want to use the 4x4 matrix type from linear
09:51:45 <xunplini> That sounds a lot like what I want.
09:51:49 * hackagebot JunkDB 0.1.0.0 -   http://hackage.haskell.org/package/JunkDB-0.1.0.0 (seagull)
09:52:10 <xunplini> Would that reduce my allocations also?
09:54:15 <ReinH> xunplini: not directly
09:54:32 <ReinH> although it wouldn't be as easy to create all the lists you're creating
09:54:54 <Jafet> http://aj-r.github.io/Evil-2048
09:55:28 <ReinH> Jafet: lol
09:55:45 <klrr_> Jafet: nice gonna try
09:56:49 * hackagebot JunkDB-driver-gdbm 0.1.0.0 -   http://hackage.haskell.org/package/JunkDB-driver-gdbm-0.1.0.0 (seagull)
09:56:51 * hackagebot JunkDB-driver-hashtables 0.1.0.0 -   http://hackage.haskell.org/package/JunkDB-driver-hashtables-0.1.0.0 (seagull)
09:57:19 <lechip> Yuu_chan: you are very helpful sir, Thank you so much
09:57:30 <int-e> Jafet: http://phenomist.wordpress.com/2048-variants/ lists many more variants. (The evil one was quite cute. There is also one were *you* can place the pieces.)
09:57:38 <lechip> Jinusai: Thank you for your help!, it simplifies a lot my understanding
09:57:56 <Jafet> I should check if anyone has updated baset.
09:58:02 <Jafet> s/baset/bastet
09:58:05 <xunplini> ReinH: thank you for the help, I will try a matrix and see how that goes.
09:58:20 <Handyman> elementary question: I'm having trouble understanding function application precedence.
09:58:27 <Handyman> LYAH says: "Function application has the highest precedence of them all."
09:58:29 <klrr_> Jafet: screenie or didnt happen =O
09:58:32 <Handyman> However, ghci says: "let f x y = x (2*y) ; f (/) 4 2" is "4.0".
09:58:38 <Handyman> So f's x parameter is '/' and y is '4' instead of x being '(/) 4 2' and the result being a partial function application.
09:58:43 <Handyman> Why is this?
09:58:47 <Jafet> xunplini: game tree search pretty much requires arrays, because they allow fast backtracking
09:59:36 <magicman> Handyman: Function application has the highest precedence, and it is also left-associative.
09:59:53 <magicman> Handyman: So "f x y z" is "((f x) y) z".
10:01:48 <Handyman> magicman: ok, that does explain the situation in this case...
10:01:56 <xunplini> Jafet: I am not sure why I want to backtrack?
10:02:16 <Handyman> magicman: but then I dont get these examples from LYAH:
10:02:29 <zcd> hi, i'm reading through http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Introducing_State and was wondering how the get works here (rollDie doesn't take any arguments)
10:02:31 <Handyman> magicman: succ 9 + max 5 4
10:02:37 <mmachenry> I am trying to cabal install postgresql-simple but I am getting link errors because the default /usr/lib installed psql is 8.4. 9.2 is installed on this system in an alternate path. I need to change include-dirs in the cabal file but I don't own the package. Is there a recommended way to do this?
10:03:14 <dcoutts> mmachenry: you can use --extra-include-dirs= and --extra-lib-dirs=
10:03:19 <johnw> zcd: in fact, rollDie does take an argument, it's just not visible to you.  The type GeneratorState is really something like: GeneratorState -> ((Int, Int), GeneratorState) under the hood.  `get' is just accessing this hidden argument
10:03:44 <Handyman> magicman: which is identical to (succ 9) + (max 5 4)
10:03:50 <magicman> Handyman: Ahh, that's when you add infix operators. "f + x" is adding f and x together. "f (+) x" means passing addition and x to f.
10:04:25 <fizruk> Handyman: + is infix operator, (+) is expression
10:04:43 <Jafet> xunplini: don't you want to evaluate each possible move from a position?
10:04:51 <ReinH> Jafet: um, you don't need backtracking
10:05:00 <Handyman> magicman: yeah, I had thought that the deal with the example was that it was rewritten as (+) succ 9 max 5 4... but I just tried that in ghci and I was mistaken...
10:05:10 <zcd> johnw: but that function is hidden inside GeneratorState Int until runState is used to access
10:05:22 <fizruk> Handyman: (+) (succ 9) (max 5 4)
10:05:25 <xunplini> Jafet: I store position, and I call a function upon each a list of moves that that position can give.
10:05:31 <xunplini> The backtracing is done in the "stack".
10:05:38 <zcd> is the do notation "unwrapping" the state momnad implicitly?
10:05:39 <ReinH> you just need a BFS
10:05:42 <xunplini> Can you say "stack" for functions calling one another in Haskell?
10:05:55 <vanila> no
10:05:55 <Handyman> magicman: can you tell me how it decides that + should have lower precedence to succ and max in the example?
10:05:55 <johnw> zcd: the "do" notation desugars to calls to >>=.  It's >>= here which is performing the magic
10:05:56 <mmachenry> dcoutts: I suspect that is not using my new directories instead of the existing ones because I get the same link error.
10:05:56 <magicman> Handyman: Right. That is (((((+) succ) 9) max) 5) 4. I don't think you want that.
10:06:08 <Jafet> No, but here you do have a stack.
10:06:32 <geekosaur> xunplini, function call stacks are not particularly meaningful in haskell, since the function call /per se/ just immediately returns a closure
10:06:55 <fizruk> Handyman: x * 9 + y * 5 * 4  =  (x * 9) + (y * 5 * 4)
10:07:01 <geekosaur> what gets stacked and forces evaluation of those closures is pattern matching, so the pattern matching stack is much more important
10:07:17 <fizruk> Handyman: the same way: succ 9 + min 5 4 = (such 9) + (min 5 4)
10:07:20 <zcd> oh i see. the binding/do notation still seems foreign
10:07:47 <fizruk> Handyman: it's function application (whitespace) that has higher priority than +, not succ or min per se
10:08:06 <Jafet> xunplini: when you make a move, you modify the memory used to store the position. Then you un-modify the memory. That is backtracking.
10:08:32 <Handyman> fizruk: ok.  I'm trying to process that...
10:08:50 <ReinH> Jafet: what?
10:08:52 <mmachenry> Is there a way to tell cabal to favor my new extra-lib-dirs?
10:09:05 <ReinH> How does it make sense to talk about "modifying" and "unmodifying" memory in a Haskell program?
10:09:16 <Jafet> How does it not?
10:09:36 <Jafet> If you write Haskell code that runs on a computer, the resulting executable is going to modify memory.
10:09:38 <xunplini> Jafet: I don't do that?
10:09:43 <ReinH> Because users don't have any direct control over memory allocation?
10:09:45 <xunplini> I make a new piece of memory and keep the old.
10:09:54 <xunplini> And eventually the garbage collector takes it away.
10:10:11 <Jafet> That is slow, game search implementations do not do that.
10:10:18 <ReinH> Jafet: his does.
10:10:20 <xunplini> Good ones don't.
10:10:21 <xunplini> Mine does.
10:10:28 <Jafet> You wanted to make it fast.
10:11:05 <Jafet> ReinH: I can allocate an IOArray, and I don't control its memory allocation, and yet I can modify it in-place. What's the problem?
10:11:13 <Jafet> What is with this "Haskell can't modify things" shit
10:11:21 <ReinH> Jafet: that isn't even close to what I said
10:11:23 <ReinH> or what you said
10:11:52 <Handyman> fizruk: ok, I think the fog is starting to lift.  Big thanks to both of you.
10:11:52 <ReinH> I would never suggest that Haskell can't modify things
10:11:55 <ReinH> Nor did I
10:12:12 <xunplini> I suppose I can backtrack by modifying a single position, but at that point I can just as well give in the functional programming towel and use bitboards.
10:12:38 <ReinH> xunplini: walking a tree is not why your program is slow
10:12:47 <ReinH> xunplini: Haskell actually has an advantage there because it can walk the tree laxily
10:12:50 <ReinH> lazily
10:12:52 <ReinH> and only evaluate nodes it traverses
10:13:04 <ReinH> xunplini: so a pruning search will avoid evaluating some nodes
10:13:08 <ReinH> which is a win
10:13:20 <Jafet> What. Every search program only evaluates nodes it traverses, regardless of what language it is written in.
10:13:36 <ReinH> Jafet: I think you misunderstand.
10:13:51 <ReinH> When I say "evaluate", I mean the Haskell definition.
10:14:08 <ReinH> Not "score"
10:14:50 <c_wraith> Jafet: it's more about what the code looks like.  In haskell, you can compose search . prune . build, instead of having to combine the 3 together.  You know, the usual laziness win.
10:14:55 <ReinH> xunplini: the point is that you can construct a (potentially infinite) tree of game states lazily
10:15:33 <ReinH> rather than having to make decisions up front about how you allocate memory for your game tree
10:15:38 <Jafet> Yes, the code looks nicer in haskell. That is an actual benefit
10:15:42 <napping> but how do you forget them?
10:15:46 <Jafet> Not some crap about being lazy and functional
10:15:53 <ReinH> Jafet: ? The laziness is the point
10:15:56 <ReinH> it's not "some crap"
10:16:23 <tromp_> laziness allows this separation of concerns
10:16:35 <Handyman> Ok, magicman and fizruk helped me to get halfway but I guess I'm still lost on function application precedence wrt infix operators.  In "succ 9 + max 5 4", I get why "succ 9" is calculated as the LHS for '+' but why isn't the RHS 'max'?  In other words, why does it evaluate "max 5 4" instead of passing 'max' and producing a type error?
10:16:58 <ReinH> you can't do this in a strict language without extra work
10:17:05 <fizruk> Handyman: 2 * 3 + 4 * 5
10:17:06 <napping> If you're doing some kind of iterative deepening or "Test" pruning or whatever, you don't want to materialize the tree, even if it's only the bits that you visit
10:17:06 <ReinH> and you can't get it to compose without a lot of extra work
10:17:23 <Jafet> If you are building a game tree like this, by the way, prepare to have enough memory to store every single node you will ever evaluate, all at once
10:17:43 <ReinH> Jafet: not really. GC is a thing.
10:18:01 <fizruk> Handyman: can you see why that is not ((2 * 3) + 4) * 5 ?
10:18:18 <Jafet> You can't collect something that is still referenced by the game tree.
10:18:39 <fizruk> Handyman: it's just all the same with + and function application: we just don't write any operator for function application
10:19:07 <napping> You will release the root of the tree as the opponent responds, but still you'll probably hold onto every state visited evaluating a particular move
10:19:13 <Jafet> And I would totally write a haskell tree search with bitboards, there is no law against it
10:19:13 <Handyman> fizruk: I dont really see it.  I assumed you were trying to say that it is hardcoded to know arithmetic operator precedence.
10:19:42 <ReinH> There are functional data structures that allow you to "copy" the tree as you go with sharing so that no-longer-needed nodes can be GC'd
10:19:58 <napping> still far from a nice DFS
10:20:14 <Yuu_chan> Handyman: precedence isn't hardcoded, it's defined with the operator
10:20:18 <Jafet> Ok, could you name one for reference?
10:20:24 <napping> you're probably better off splitting things by making move generation a higher order function taking functions deciding how to expand
10:20:35 <ReinH> a finger tree?
10:20:59 <Handyman> fizruk: Are you saying that 2 + 3 * 4 + 5 = (2 + 3) * (4 + 5) by some function application rule I don't know?  (in other words, it has nothing to do with arithmetic rules)?
10:21:01 <ReinH> Okasaki has plenty of examples of data structures that use this kind of sharing
10:21:07 <Yuu_chan> All we know is that function application has the highest one (10) and unary minus has 6, IIRC
10:21:10 <napping> what kind of sharing?
10:21:23 <napping> I think the best you can do is release the root node and hang on to the current position
10:21:28 <ReinH> napping: for example, replacing the end of a list without re-allocating the beginning
10:21:32 <fizruk> Handyman: now, I was using * to replace function application
10:21:38 <Yuu_chan> @src (+)
10:21:39 <lambdabot> Source not found. Do you think like you type?
10:21:50 <fizruk> Handyman: 2 + succ 3 + 4  =  2 + (succ 3) + 4
10:21:51 <Handyman> Yuu_chan: Hmmm.. this is the first I've heard of precedence values.  Where is this documented?
10:22:01 <napping> or, I suppose you could make lots of fresh calls to the function for building a game tree
10:22:04 <ReinH> a -> b -> c -> d to a -> b' without creating a new a
10:22:23 <ReinH> no reason a tree can't do this
10:22:26 <Jafet> Also, ReinH, does that really even replace a transposition table?
10:22:34 <ReinH> Jafet: no?
10:22:51 <Jafet> Ok, I thought that was suggested.
10:23:15 <Yuu_chan> Handyman: it is strictly described in the Haskell report. If vaguely, you can define any precedence (from 0 to 9) and associativity (optionally) for any operator
10:23:28 <Yuu_chan> :info (+)
10:24:16 <ReinH> Also the complete search space of 2048 is something like 2^24 board positions, many of which are unreachable
10:24:19 <Yuu_chan> Heck, it's not GHCi. Well, predecence for plus is defined this way: "infixl 6 +"
10:24:35 <Jafet> > 11^16
10:24:35 <ReinH> It's not tic-tac-toe but it isn't chess either
10:24:37 <lambdabot>  45949729863572161
10:24:45 <Handyman> OK.  This is getting a little clearer.  I think I have a road of investigation.  Thanks to you both.
10:24:46 <Jafet> > log $ 11^16
10:24:47 <lambdabot>  38.36632436477393
10:25:07 <Jafet> I guess that's not a tight bound
10:25:09 <Yuu_chan> That means '+' is an 'l'eft-associative 'infix' operator with precedence '6'
10:25:24 <tromp_> why at most 2^24?
10:25:41 <ReinH> I've never seen a larger tile than 2^16, there are 2^8 squares
10:25:53 <Handyman> Yuu_chan: what precedence is "normal" function application?
10:26:02 <ReinH> I've never seen a larger tile than 2^12 but let's be generous
10:26:11 <Yuu_chan> You can actually define any alien rules for arithmetics. Standard Prelude definitions have more or less common :)
10:26:12 <Jafet> What
10:26:24 <Jafet> There are 16 tiles, each of which can assume 12 states
10:26:26 <Yuu_chan> Handyman: the highest, 10
10:26:31 <dbelange> does anyone here like coinduction
10:26:37 <Jafet> (well, 11 during the game)
10:26:41 <napping> ReinH: that's 2^64 states
10:26:46 <tromp_> i agree with 11^16
10:26:51 <Yuu_chan> So it applies first _before_ any neighbouring operators
10:26:52 <napping> makes a nice bitboard
10:26:53 <ReinH> sorry 2^4 tiles obv
10:26:58 <ReinH> 16 tiles
10:27:05 <Handyman> Yuu_chan: got it.  Amusingly, this is a simplified version of the spaghetti that is Prolog precedence, which I know well.  I just hadn't seen any of this before.  Thanks again!
10:28:01 <napping> 12 states is a bit smaller, but still not 2^24
10:28:02 <ReinH> Sorry I don't know what my brain is doing today
10:28:12 <Yuu_chan> Handyman: you're welcome :) Btw, how it is in Prolog?
10:28:26 <tromp_> i mean 12^16, to account for {empty,2^1,...2^11}
10:28:30 <jophish> If a function is tail-recursive in Haskell, will it be tail-recursive in Core?
10:28:36 <ReinH> 12^16 it is
10:29:01 <vanila> jophish, I don't think there is a notion of tail recursion i haskell - it's lazily evaluated
10:29:18 <napping> it's still relevant when forcing the result
10:29:41 <ReinH> napping: yeah I have no idea what my brain just did there :/
10:30:23 <Handyman> Yuu_chan: Its the 'op' operator, which has varying standard behavior between implementations.  Prolog is one of the earliest languages to support (what are now called) DSLs via operator overloading.  Its where the 'xfy' binary and 'fy' unary notations came from.  For more: http://www.cse.unsw.edu.au/~billw/cs9414/notes/prolog/op.html
10:30:27 <napping> jophish: I can't think of anything, except that the body of an exception handler isn't a tail position
10:30:33 <ReinH> anyway more relevant is that from any position there are exactly 4 moves, which result in 4 * (number of random choices of new piece) new positions
10:30:34 <napping> or may not be, anyway
10:31:06 <ReinH> well, the sum of the number of random choices for each move
10:31:29 <Yuu_chan> Handyman: 954 is an interesting value :)
10:31:37 <ReinH> which seems like a relatively small branching factor
10:31:37 <Jafet> ReinH: that gives you a terrible upper bound--the game has at least 500 moves
10:32:06 <ReinH> Jafet: right, but this is depth limited
10:32:17 <ReinH> so that gives your upper bound
10:32:25 <int-e> Theoretically one can get a 2^17 tile, but never 2^18.
10:32:33 <Handyman> Yuu_chan: Do not get me started ;)  Every implementation uses different values and the whole thing is zany.  '.' never works right, etc.  It looks like Haskell stole the idea and made it not suck.
10:33:02 <ReinH> All of this is less relevant than the profile xunplini did of their actual code though
10:33:05 <Jafet> Haskell's fixity system is from ML
10:33:12 <Jafet> (which might be from prolog, who knows)
10:34:17 <ReinH> xunplini: so, one thing that would help: how many cases are there for moving a row in a single direction?
10:34:44 <Jafet> Actually, since there are fewer than ~2^50 positions, I wonder if you could just solve it completely using bidirectional search.
10:35:44 <ReinH> xunplini: actually too many to enumerate easily because of shift + collapse options
10:35:48 <Yuu_chan> Btw, it's also possible to set fixity for any function in its infix form
10:35:48 <ReinH> :/
10:35:59 <ReinH> Yuu_chan: but doing so is madness :)
10:36:08 <ReinH> fixity is hard enough to remember as it is :p
10:36:24 <Jafet> There are a few word functions that have fixity declarations
10:36:30 <Jafet> I don't remember which
10:36:39 <Yuu_chan> fmap?
10:36:39 <ReinH> Jafet: still madness :p
10:36:47 <Jafet> elem is one
10:36:48 <ReinH> Yuu_chan: <$>?
10:36:59 <Jafet> fmap is not
10:37:05 <ReinH> oh god why
10:37:10 <Handyman> I assume that fixity changes are like they are in Prolog/ML - for DSLs.  Which does sound deadly...
10:37:36 <Yuu_chan> > Just 5 `fmap` (+ 1) `fmap` even
10:37:38 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool -> b’
10:37:38 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
10:37:45 <Jafet> Unlike in prolog, a fixity change usually causes a type error. But not always...
10:38:13 <Yuu_chan> Ew, other way
10:38:15 <Handyman> Ahh, yes, the type checker will save your soul.  In Prolog, it just causes tears.
10:38:52 <Yuu_chan> > even `fmap` (+ 1) `fmap` Just 5
10:38:53 <lambdabot>  Just True
10:39:02 <vanila> Handyman, what type checking?
10:39:05 <vanila> :P
10:39:25 <Jafet> Wait, why does `elem` have a fixity, but not !!
10:39:27 <Jafet> Why
10:39:43 <ReinH> Jafet: like I said. Madness.
10:39:54 <Yuu_chan> Madness?..
10:41:58 <Yuu_chan> (interrupting the joke) Well, I think Scala has much more madness in terms of DSL-ish text-like functions, operators, fixity...
10:42:06 <Jinusai> Is there a way to automatically add the .cabal-sandbox/bin directory to PATH when using cabal sandbox?
10:42:28 <ReinH> Yuu_chan: ... types
10:42:38 <ReinH> Scala types are madness.
10:42:48 <zq> what's wrong with scala types?
10:42:59 <Yuu_chan> Don't even start ©
10:43:24 <ReinH> Well, declaring them is an exercise in self-flagilation
10:43:30 <ReinH> Type inference works right up until you need it to
10:43:36 <Yuu_chan> @google scala trouble with types
10:43:37 <lambdabot> http://www.infoq.com/presentations/data-types-issues
10:43:37 <lambdabot> Title: The Trouble With Types
10:44:37 <ReinH> But this is #haskell, not #crapOnScala...
10:44:45 <Jafet> isabelle/hol lets you define custom production rules for syntax. They can overlap, and overlaps are resolved by generating every possible parse tree and type checking it
10:44:53 <Jafet> Haskell is pretty mild
10:45:06 <Sculptor> wild or mild
10:45:54 <Yuu_chan> мild
10:48:14 <ReinH> xunplini: anyway padl, padr, and moveLeftRow seem to be the main cause of slowness
10:48:28 <Hodapp> "this is madness!" "THIS... IS... SCALA!"
10:48:37 * Hodapp kicks ReinH into a well
10:49:07 <Jafet> This is mildness
10:50:27 <ReinH> xunplini: you don't need a separate pad if you pad when you collapse
10:50:57 <ReinH> for example, moveLeftRow (0:xs) = moveLeftRow (xs ++ [0])
10:51:30 <ReinH> (++) is usually a problem but here it operates in basically constant time
10:51:56 * hackagebot reverse-apply 2.0 - Standard version of the reverse apply operator.  http://hackage.haskell.org/package/reverse-apply-2.0 (HansHoglund)
10:53:14 <ReinH> xunplini: one advantage of switching to Linear is that the vector types are strict, which will help avoid thunk accumulation
10:53:19 <ReinH> also transpose is cheaper
10:53:29 <ReinH> as is reverse
10:56:16 <ReinH> xunplini: also I would suggest spaces instead of tabs
10:56:56 * hackagebot reverse-apply 2.0.1 - Standard version of the reverse apply operator.  http://hackage.haskell.org/package/reverse-apply-2.0.1 (HansHoglund)
11:00:59 <xunplini> ReinH: is that more common in Haskell?
11:01:21 <ReinH> xunplini: by a huge margin, yes
11:01:28 <ReinH> xunplini: tabs make it harder to use layout correctly
11:02:11 <ReinH> xunplini: so the 2048 rules are that shifting happens before combining, right?
11:02:30 <ReinH> i.e. [2, 0, 2, 0] -> [4,0,0,0]
11:02:49 <ReinH> I'm wondering if a couple folds might be more efficient
11:03:24 <ReinH> no, because you have to deal with padding
11:03:36 <ReinH> hmm
11:03:51 <ReinH> except padding is an artifact of choosing 0 to represent empty
11:04:57 <ReinH> there's something obvious I'm missing here :/
11:06:57 * hackagebot largeword 1.2.0 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.2.0 (DominicSteinitz)
11:14:32 <Guest31007> hi]
11:14:35 <vanila> hi
11:14:37 <happy0> hi
11:14:39 <klrr_> hi
11:16:58 * hackagebot largeword 1.2.1 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.2.1 (DominicSteinitz)
11:24:47 <xunplini> ReinH: I had the same feeling.
11:24:48 <xunplini> I tried using folds.
11:25:09 <xunplini> But I could not find a more elegant way.
11:25:19 <bahamas> :i MonadWriter
11:25:44 <bahamas> :t mapM
11:25:46 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
11:27:33 <bahamas> I'm trying to understand the Writer monad, but I don't know where to look exactly, because LYAH is a bit dated in this regard. I discovered the MonadWriter class, but I don't understand its definition. can anyone explain it?
11:27:54 <johnw> :t runWriter
11:27:55 <lambdabot> Writer w a -> (a, w)
11:28:05 <johnw> @unmtl WriterT
11:28:05 <lambdabot> Plugin `unmtl' failed with: `WriterT' is not applied to enough arguments, giving `/\A B C. B (C, A)'
11:28:13 <johnw> @unmtl WriterT s m a
11:28:13 <lambdabot> m (a, s)
11:29:12 <johnw> the Writer monad allows each function in that monad to produce values of some Monoid, like lists, strings, etc.; and the action of >>= for that monad mappend's these values together, so that at the end, the result of runWriter is the final monoid value
11:29:36 <bahamas> johnw: I get that part more or less
11:29:47 <johnw> MonadWriter simply abstracts the interface to Writer
11:29:48 <bahamas> johnw: I'm more confused about the MonadWriter type class
11:29:50 <johnw> so that you don't always have to "lift"
11:30:06 <bahamas> is it a type class that takes two parameters?
11:30:09 <johnw> also, it allows some things to behave like a Writer, which aren't specifically of the types Writer or WriterT
11:30:12 <johnw> yes
11:30:31 <johnw> MonadWriter w m | m -> w
11:30:32 <bahamas> it's definition is MonadWriter w m | m -> w where ..
11:30:47 <bahamas> s/it's/its/
11:31:08 <johnw> which says, "given some m, I'll give you a way to 'tell' me values of some w"
11:32:06 <StoneCypher> johnw: by turning it upside down
11:32:08 <StoneCypher> very crafty
11:32:19 <bahamas> johnw: so MonadWriter expects "w" and "m" or a function that takes "m" and returns "w"?
11:32:28 <bahamas> or how do I read that definition?
11:33:02 <johnw> foo :: MonadWriter w m => m Int; foo = do { tell "Hello"; return 10 }
11:33:06 <johnw> foo :: MonadWriter String m => m Int; foo = do { tell "Hello"; return 10 }
11:33:32 <johnw> MonadWriter is letting me use "tell" there
11:33:39 <johnw> but that's all it says, nothing more
11:33:57 <johnw> the implementor of a particular MonadWriter is the one who has to determine how to hold onto the told value
11:34:20 <bahamas> johnw: ok, but I'm trying to understand the syntax in the type class definition, because I haven't seen it before
11:34:54 <johnw> ah, it's a multi parameter type class, with a functional dependency
11:35:03 <johnw> both require GHC extensions
11:35:58 <johnw> without the functional dependency, my "return 10" up there would fail to type check, because it doesn't provide enough information to determine that "w ~ String" in that function
11:36:17 <johnw> I'm pretty sure, let me verify that
11:36:30 <bahamas> sorry, I don't know what "functional dependency" means
11:36:57 <johnw> "m -> w"
11:38:21 <johnw> no, the return 10 type checks fine even without the dependency
11:38:35 <johnw> it's "listen" that would fail
11:39:09 <johnw> consider this code: https://gist.github.com/11003577
11:39:16 <johnw> you need to uncomment the functional dependency for it to compile
11:39:50 <bahamas> johnw: yes, that's what I'm saying. I don't know how to interpret all this. I've gotten to the "For a Few Monads More" in LYAH. I don't know how to read that definition of MonadWriter
11:39:56 <johnw> otherwise, in the call to "listen" below, how can we know the type of "w"?  it's not used in the call to listen
11:40:11 <johnw> bahamas: in that case, I'd just shelve this for a little while
11:40:28 <johnw> it requires understanding a few other things, which are a bit beyond LYAH
11:40:36 <johnw> but definitely come back to it
11:40:59 <johnw> knowing why the functional dependency is necessary here will help you a great deal in understanding certain kinds of otherwise highly confusing type errors
11:57:29 <Platz> does MonadRandom use unsafePerformIO here?  trying to find out where it gets the randomGen from https://github.com/badamson/2048.hs/blob/master/src/HS2048.hs#L131
11:58:05 <Platz> obviously it's called from an IO () monad from main, but I don't see how it creates the MonadRandom instance
11:58:49 <monochrom> which package does MonadRandom come from, so I can read its doc and source code?
11:59:06 <johnw> it's named MonadRandom
11:59:10 <johnw> http://hackage.haskell.org/package/MonadRandom
11:59:59 <shachaf> A monad is a thing like IO, not a thing like x :: IO ().
12:00:13 <fragamus> is there a Pipes consumer that composes its input into an infinite list
12:00:34 <fragamus> knp
12:00:48 <monochrom> "instance MonadRandom IO" uses newStdGen and randomIO
12:01:00 <ReinH> (compare: A functor is a thing like Maybe, not a thing like x :: Just Int)
12:01:35 <shachaf> Just Int is not a type.
12:01:37 <monochrom> getRandomR becomes randomRIO
12:01:41 <Platz> shachaf: ah yes that's right
12:01:51 <ReinH> shachaf: yep, not a thing like x = Just 1 :: Maybe Int
12:02:45 <monochrom> you could say, randomRIO uses something created by unsafePerformIO
12:02:55 <fragamus> is there a Pipes consumer that composes its input into an infinite list
12:02:56 <akurilin> Quick question: is ther ea vim plugin out there that correctly indents the "comma first" style?
12:03:07 <ReinH> shachaf: I suppose it's "a thing like IO equipped with return and >>=" and "a thing like Maybe equipped with fmap"
12:03:40 <monochrom> Just Int Bieber :)
12:03:48 <ReinH> monochrom: stahp
12:03:49 <johnw> (and obeying the laws...)
12:03:58 <ReinH> johnw: yep
12:04:56 <ReinH> johnw: I suppose it's "Hask equipped with Maybe and an fmap that obeys the functor laws"
12:05:12 <shachaf> What?
12:05:22 <shachaf> I don't even care, actually.
12:05:25 <ReinH> but I suppose we all understood what shachaf said to begin with
12:05:41 <monochrom> aww, this gets too tangential. the original reminder was merely "the monad is IO, not IO Int"
12:05:49 <ReinH> monochrom: yep
12:06:04 <monochrom> I guess also "and not getLine"
12:06:39 <monochrom> in my http://www.vex.net/~trebla/haskell/IO.xhtml I say "getLine is an I/O action"
12:06:55 <fragamus> i need the dual of Pipes.each
12:06:58 <dmj`> can I do something like this "type A,B = Int" ?
12:07:01 <activeaspect> has anyone managed to install the ghc 7.8.2 mac os x binary? im getting an error "ghc-cabal: /usr/local/share/doc/ghc/html: does not exist"
12:07:02 <ReinH> shachaf: I guess what I meant is "the pair (Maybe, fmap) is a functor from Hask to Hask"
12:07:18 <monochrom> cannot, dmj`
12:07:33 <dmj`> monochrom: is there something similar ?
12:07:38 <monochrom> no
12:07:38 <ReinH> I suppose I shouldn't use tuple notation for something that mixes type and value level though
12:07:56 <monochrom> unless you say that "type A = B; type B = Int" is similar.
12:09:21 <monochrom> tuple is ok if you remark that it's math tuple not haskell tuple
12:10:06 <monochrom> if you try to avoid haskell notation, you will have no notation left :)
12:10:10 <ReinH> monochrom: phew :)
12:11:39 <dmj`> activateaspect: I have, I don't understand your error msg tho
12:12:57 <dmj`> activeaspect: I just did wget 7.8.2.xz && tar -xJf 7.8.2 && cd 7.8.2 && ./configure && make install and everything just worked
12:12:58 <activeaspect> dmj`: k, i think i have some left over files from 7.6.3. it thinks i still have a cabal installed
12:13:09 <dmj`> tar -xJf 7.8.2.xz
12:13:12 <activeaspect> thats my theory
12:13:20 <dmj`> how did you install 7.6.3?
12:13:22 <monochrom> having cabal installed should be of no consequence
12:13:23 <dmj`> platform or brew
12:14:07 <activeaspect> both at one time or another... tried to clean up brew before installing platform
12:14:35 <dmj`> if you want to start all over fresh: sudo /Library/Haskell/bin/uninstall-hs all --remove, to get rid of the platform, delete your ~/.cabal and ~/.ghc, and I think any ghc stuff in /usr/local/bin
12:15:22 <dmj`> no need to remove cabal though, unless you want latest
12:18:43 <fragamus> can a pipes effect have a function result
12:18:52 <activeaspect> k thanks. ill update when i figure something out
12:20:11 <fragamus> plugh
12:35:28 <Phlogistique> Hi
12:35:38 <Phlogistique> I want to write a simple parser for Aeson
12:35:44 <Phlogistique> somehow I can not figure it out
12:36:01 <Phlogistique> here is an attempt: http://lpaste.net/102839
12:37:09 <bitemyapp> Phlogistique: I've got some Aeson examples here: http://bitemyapp.com/ there are Aeson tutorials littered throughout the web as well.
12:37:13 <dmj`> why isn't this syntax allowed?
12:37:14 <dmj`> sum [ job { status = JobUnPaid _ } | job <- H.elems jobMap ]
12:37:45 <dmj`> I get type-hole stuff in ghc
12:39:45 <dmj`> like if I had data Thing = A | B String
12:40:00 <dmj`> things = [ A, B "hey", B "ok" ]
12:40:04 <dmj`> and I wanted a list of B's
12:40:18 <dmj`> sum [ t@(B _) | t <- things ]
12:40:46 <klugez> That pattern match should be on the right side of |
12:41:01 <klugez> Left side is not a pattern match, it's just a value that is placed in the list.
12:41:03 <dmj`> oh yea, its still invalid tho
12:42:28 <dmj`> klugez: maybe I should make it a monoid..
12:43:07 <jle`> dmj`: what are you trying to do?
12:43:15 <klugez> [ t | t@(B _) <- things ] is valid.
12:44:01 <Phlogistique> bitemyapp: I figured it out thanks to your article
12:44:50 <Phlogistique> http://lpaste.net/102841 here is what I ended up writing. It compiles OK, did I miss anything?
12:45:25 <refried_> newbie question — does some haskell implementation already parallelize unrelated expressions?
12:46:36 <napping> refried_: not as far as I know
12:46:44 <refried_> *nod* thanks
12:46:49 <mmachenry> refried_: No, you need to explicitely say what you want parallelized.
12:46:52 <napping> at least if you mean doing it completely automaticlly
12:47:00 <mmachenry> refried_: Take a look at par/seq
12:47:01 <napping> there's stuff like strategies that makes it pretty easy
12:47:11 <refried_> well, yeah i think i mean completely automatically
12:47:12 <napping> and maybe some research things like Reduceron try
12:47:54 <napping> The big problem is granularity
12:48:15 <refried_> i see.  hard to know in advance whether you'll waste more time spawning threads, i guess?
12:48:17 <napping> as cheap as sparks are, trying to run each addition in parallel would have too much overhead
12:48:49 <sm> has anyone other than me seen these intermittent "can't find section named ..." failures while linking things on windows ?
12:49:00 <dmj`> jle`: so if I have a Job type. data Job = Job { price :: Int, status :: JobStatus }, data JobStatus = Pending | Completed, it would be nice to have a two Monoid instances that could summarize a list of Jobs based on price and status. So if I had a list of jobs and wanted to get the status count I could have one that does mconcat :: [Job] -> (Int,Int), and another for price where mconcat :: [Job] -> Int
12:49:19 <napping> Threads are quite cheap in Haskell
12:49:24 <napping> at least with GHC
12:49:37 <napping> and par actualy uses some workstealling stuff that's even cheaper
12:49:52 <dmj`> jle`: if I wanted two monoid instances I'd have to use a newtype wrapper tho prob
12:50:07 <jle`> dmj`: i'm not sure how that would be monoidy
12:50:21 <jle`> mconcat can only be [a] -> a, right?
12:50:23 <jle`> :t mconcat
12:50:24 <lambdabot> Monoid a => [a] -> a
12:50:26 <napping> refried_: check out http://chimera.labs.oreilly.com/books/1230000000929
12:50:43 <refried_> napping: i will, thanks
12:51:11 <napping> Overall, it's pretty easy to get some parallelism, even if it's not completely automatic
12:51:56 <jle`> dmj`: or do you mean different instances that combine Job based on price and based on status
12:52:02 <dmj`> so I would need something like data Job = Job { price :: Int } | JobSummary Int
12:52:17 <klugez> dmj`: I think the correct version of your original should go something like: sum [ job | job@(Job {status = JobUnPaid _}) <- H.elems jobMap ]
12:53:01 <dmj`> klugez: yea I thnk you're right, but that's so ugly
12:53:18 <klugez> dmj`: True.
12:53:39 <dmj`> klugez: I'd like to hide the pattern matching part in an instance and expose a high level operator, It's just a fold really
12:54:28 <napping> refried_: are you just learning Haskell?
12:55:12 <refried_> napping: thinking about it :)    i know some of the concepts, but haven't ever written an application
12:55:20 <napping> have you used Erlang?
12:55:31 <refried_> i've read about it, but used it less than haskell ;-)
12:55:44 <refried_> an article about erlang is what brought me and my question here today
12:56:05 <napping> I don't know of anything else with similarly cheap threads
12:56:17 <refried_> like. to give an idea of where i'm at; i'm not sure if i have ghc installed on this computer, but i know i don't have any erlang stuff installed
12:56:43 <napping> I mean Erlang is the only language I know of that will actually use multiple cores, and has threads as cheap as Haskell
12:56:57 <refried_> oh, i do have ghc installed :)
12:57:05 <refried_> I see
12:57:10 <napping> even if you're not getting parallelism, just being able to do stuff like one thread per client is nice
12:57:26 <napping> Here's the latest work: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
12:57:51 <refried_> cool, thanks
12:58:45 <napping> The runtime system is basically exactly what you'd want for that kind of stuff - approximately one real OS thread per core, whenever one of your threads would block on IO the operation is instead tossed into a big epoll wait, and some other work is run (plus preempting at a timeout)
12:59:07 <refried_> yeah exactly
12:59:53 <sgregory_> Go has goroutines, Rust has tasks, and the JVM has java.util.concurrent Executors that *can* map to something similar.
13:00:51 <napping> Right, I should have remebered some of the java executor stuff
13:01:00 <napping> (though I doubt they handle IO so nicely)
13:01:10 <napping> does Go actually use multiple cores?
13:01:15 <sgregory_> yes
13:01:20 <sgregory_> simliar to haskell
13:01:21 <napping> oh, nice
13:01:25 <sgregory_> GOPROCS=X
13:01:42 <sgregory_> you tell it how many OS threads to use
13:01:46 <napping> A number of things provide a similar programming model but only on one real thread
13:01:59 <napping> or even worse, only after manually CPS transforming your code :(
13:02:09 <sgregory_> Java's IO scheduler is actually pretty good
13:02:10 * hackagebot music-util 0.10 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.10 (HansHoglund)
13:02:12 * hackagebot deka 0.4.0.4 - Decimal floating point arithmetic  http://hackage.haskell.org/package/deka-0.4.0.4 (OmariNorman)
13:02:16 <akurilin> ll
13:02:43 <akurilin> Wow the bot notifies the channel when a new package version is uploaded?
13:02:55 <napping> sgregory_: what IO scheduler?
13:03:05 <fizruk> edwardk: ping
13:03:11 <edwardk> pong
13:03:40 <fizruk> edwardk: how about cutoff for free monads? like cutoff for IterT
13:04:22 <sgregory_> napping: Java's IO got mapped over to a non-blocking mechanism around 1.5 or 1.6, so threads actually handle IO pretty efficiently
13:04:34 <fizruk> edwardk: I'm not sure this would be particularly useful, but perhaps can be used for limiting search spaces
13:05:16 <fizruk> edwardk: i just wrote it for fun for Free/FreeT/FT, would you like to have it?
13:05:20 <sgregory_> You can manually use NIO, but all of the oldschool-blocking stuff got mapped over to NIO and *should* cooperatively work well with the Exectutor framework
13:05:54 <napping> It doesn't tie up an OS thread?
13:06:07 <edwardk> fizruk: bang out a patch and throw it in
13:06:24 <fizruk> edwardk: ok, and for free applicatives I have this code: https://gist.github.com/fizruk/65b4ac64e9ab85772b33
13:07:00 <fizruk> edwardk: when using effectful validation function I immediately become unable to do non-trivial static analysis
13:07:23 <sgregory_> napping: NIO won't tie up an OS thread.  Naively using old stuff can tie up an os thread.
13:08:15 <napping> Do you have to explicitly use the NIO multiplexing stuff for it to work best?
13:08:25 <fizruk> edwardk: I have data Field = { ... fValidate :: s -> m a ... } where s is input type (String) and a – field type (e.g. int)
13:08:54 <fizruk> edwardk: type Form s m a = Ap (Field s m) a
13:09:22 <fizruk> edwardk: now when I want to get help message for a form, I can't do that for my sample form
13:10:07 <edwardk> so you're using, say, Form s (Either String) a or something?
13:10:08 <sgregory_> napping: napping it's been a while since I've lived in that world, but I don't think so.  For example servlet containers like Jetty abstract away all of that for you.  Clojure's http-kit is able to pull some crazy numbers
13:10:22 <Wizek> Does GHC attempt to figure out wheter some computations are possible at compile time? If so, does it compute them and inline their result?
13:10:32 <edwardk> or some kind of applicative either clone that accumulates the list of errors?
13:10:41 <fizruk> edwardk: yes, something like that
13:11:01 <Wizek> Example: `a = 1 + 2` or `b = "foo" ++ "bar"`
13:12:04 <fizruk> edwardk: actually m is abstracted to allow arbitrary validation requests, e.g. check if username is available in system
13:12:14 <edwardk> sure
13:12:20 <edwardk> so what is the problem?
13:12:57 <fizruk> edwardk: i'm not sure it's a problem I want to solve, but I want to write `help form` and get help message
13:13:15 <fizruk> edwardk: the problem however seems to be similar to this one:
13:13:18 <edwardk> help needs to be able to run `m` effects.
13:13:27 <fizruk> > fat (1, return 1)
13:13:28 <edwardk> without that you get no help
13:13:29 <lambdabot>  Not in scope: ‘fat’
13:13:29 <lambdabot>  Perhaps you meant one of these:
13:13:29 <lambdabot>    ‘fst’ (imported from Data.Tuple),
13:13:29 <lambdabot>    ‘cat’ (imported from Text.PrettyPrint.HughesPJ),
13:13:29 <lambdabot>    ‘at’ (imported from Control.Lens)
13:13:35 <fizruk> > fat (1, return 1)
13:13:36 <lambdabot>  Not in scope: ‘fat’
13:13:36 <lambdabot>  Perhaps you meant one of these:
13:13:36 <lambdabot>    ‘fst’ (imported from Data.Tuple),
13:13:37 <lambdabot>    ‘cat’ (imported from Text.PrettyPrint.HughesPJ),
13:13:39 <lambdabot>    ‘at’ (imported from Control.Lens)
13:13:52 <fizruk> sorry, my client is weird
13:14:02 <fizruk> > fst (1, return 1)
13:14:04 <lambdabot>  Could not deduce (GHC.Base.Monad m0)
13:14:04 <lambdabot>    arising from a use of ‘GHC.Base.return’
13:14:04 <lambdabot>  from the context (GHC.Num.Num a)
13:14:04 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num a => a at Top level
13:14:04 <lambdabot>  The type variable ‘m0’ is ambiguous
13:14:15 <fizruk> edwardk: ^
13:14:18 <edwardk> if you have a validator like Either, you can do that. if not you're out of luck. you can of course split the validation up into layers
13:14:58 <fizruk> edwardk: the question is: how to keep help message with Field but be able to get it without knowing how I validate fields
13:16:03 <edwardk> what keeps you from getting at fHelp: ts just a string in there.
13:16:16 <Elliott18>  Here some videos. I hope you like them! http://bitly.com/1gAh6Jy
13:16:21 <edwardk> you want help for all the fields or ust the ones that 'fail'?
13:16:52 <fizruk> edwardk: just all the field
13:17:00 <fizruk> *fields
13:17:24 <edwardk> ok, so define a natural transformation from Field s m -> Const [String]
13:17:29 <fizruk> edwardk: there seem to be a bit wrong help in that paste
13:18:16 <fizruk> help :: Form s m a -> String
13:18:17 <fizruk> help = unlines ∘ getConst ∘ runAp (Const ∘ fieldHelp)
13:18:32 <fizruk> edwardk: just without return and monad in result type
13:18:37 <edwardk> yes
13:18:55 <edwardk> or
13:19:20 <edwardk> wel, you need a return in there don't you? to make a singleton list for each fieldHelp
13:19:59 <edwardk> wouldn't it be something like unlines . getConst . runAp (Const . return . fieldHelp) ?
13:20:00 <fizruk> edwardk: now when evaluating `help form` I get the same error as in `fst (1, return 1)`
13:20:16 <edwardk> what error is that?
13:20:25 <fizruk> edwardk: no that line I wrote compiles
13:21:14 <fizruk> edwardk: http://lpaste.net/102843
13:21:37 <vivaldi> hello, I want to give a list whose length is 250 to a function, but I get an error. How can I fix it?
13:21:38 <fizruk> edwardk: fieldHelp makes singleton list, sorry for inconvenience
13:21:42 <edwardk> put a type sgnature in to pick 'm' or pull a yoneda trick so Field s m is a Functor even without knowing m
13:22:25 <fizruk> edwardk: so I really can do that without picking monad instance? great news!
13:22:26 <vivaldi> the error is    Couldn't match expected type `[Char]' with actual type `IO ()'
13:22:52 <edwardk> data BetterField s m a = forall b. Field { name :: String, validate :: s -> m b, tweak :: b -> a, help :: Strng }
13:22:59 <fizruk> vivaldi: could you paste some code?
13:23:01 <edwardk> that can be a Functor without knowing anything about b.
13:23:06 <edwardk> er about m
13:23:14 <edwardk> fmap modifies 'tweak'
13:23:18 <edwardk> not m
13:23:29 <edwardk> this is a trick i use in machines for Plan.
13:24:20 <fizruk> edwardk: hm... I can't see how this will fix `help form`
13:24:36 <corgifex> edwardk: so I heard you're giving a talk in munich
13:24:47 <edwardk> corgifex: thats the plan
13:25:15 <fizruk> edwardk: I'll give it a try though :p thanks!
13:25:26 <vivaldi> fizruk : code is basically like this : http://lpaste.net/102844
13:27:59 <caseof> Let's say I'm sending a request to a remote service. For each request I create a different TVar though - is this efficient or is the cost of creating/garbage collecting a TVar huge?
13:28:13 <fizruk> vivaldi: what are fhelper, list and putspace ?
13:30:01 <Cale> caseof: It's tiny
13:31:20 <Cale> caseof: It's essentially just a couple of pointers
13:31:54 <edwardk> fizruk: given te change i mentioned, now you can have instance Functor (Field s m)   rather than instance Functor m => Functor (Field s m) -- this means that you don't need to know the type of m to know how to fmap over Field.
13:32:39 <caseof> Cale: Ok, thanks.
13:33:00 <edwardk> fizruk: this percolates out. All of your free applicative code then starts to drop constraints on 'm'.
13:38:39 <Handyman> Beginner Mac question: I'm using the MacPorts version of ghc and I can't very far installing packages
13:38:45 <Handyman> (Specifically, I've uninstalled and reinstalled a few times with the ultimate goal of installing the Eclipse plugin)
13:38:49 <Handyman> I get a compiler error when I run "cabal install cabal-install" in the HTTP library.
13:38:56 <Handyman> It seems that cabal-install is requiring HTTP-4000.2.4 which is incompatible with the referenced
13:39:00 <Handyman> version of Network.URI due to a Network.URI API change ('relativeTo').
13:39:11 <Handyman> I'm very new to the Haskell Platform so I'm not sure if I've got everything right but my steps were:
13:39:19 <Handyman> 1. Install ghc (sudo port install ghc).  2. cabal update  3. cabal install cabal-install (this fails)
13:39:30 <fizruk> edwardk: I've updated the code, `help form` still need an explicit type signature   https://gist.github.com/fizruk/65b4ac64e9ab85772b33#file-eff-hs
13:39:50 <edwardk> int :: Monad m => String -> Form String m Int
13:39:56 <edwardk> that is forcing you to pick a Monad m
13:40:26 <fizruk> edwardk: I really can't get rid of it, can I?
13:40:35 <edwardk> not without more invasive surgery
13:40:41 <they> I don't think you really need to do cabal install cabal-install.
13:40:48 <they> It recommends that you do, but it's not necessary.
13:41:04 <fizruk> edwardk: what would that be?
13:42:27 <Handyman> they: Thanks.  I can't recall what I thought was forcing that but I'll try to proceed w/ Eclipse install and see what happens.
13:42:41 <edwardk> well, e.g. changing it so you can produce int, etc the majority of your constraints without constraints on `m`. but then exotic constraints would have to fix `m` anyways
13:42:50 <they> That said, I've had further problems with the Eclipse Haskell plugins that prevent me from ever using it.
13:42:59 <edwardk> someone has to pick m here
13:43:24 <they> So it may be worth saving yourself headaches down the road by looking into other options, like Leksah or Emacs, unless you have something specific with Eclipse in mind.
13:44:05 <edwardk> an explicit signature s one way, using a proxy argument is another, using this thing in another context so that picks m, whatever.
13:44:08 * edwardk shrugs.
13:44:18 <edwardk> This is like saying mempty == mempty
13:44:34 <they> I have a question. I'm working with a database, have: data Element a = List [a] | Table [(a,a)] deriving (Show)
13:44:59 <they> Is there a way where I can make an instance of functor where fmap for List is just fmap, but fmap for a Table ONLY applies a function to the snd of each of the tupples?
13:45:01 <edwardk> someone needs to pick the instance. Eq only has 'a' in negative position, and we only use mempty in positive, so it dosn't show up in the result
13:45:11 <they> It's a type error, obviously, but is there something I can force or wrap?
13:45:17 <Handyman> they: I was torn between Leksah and Eclipse and saw something recommending it.  I'll rethink if I can't get anywhere.
13:45:49 <they> Handyman: Leksah's good. Lots of enterprise features. I've had in crash in the past, though.
13:46:09 <they> Emacs and vim are by a wide margin the most widely used editors for Haskell. Sublime too. They all have IDE-like features.
13:46:21 <they> Ghci integration, autocomplete, decent indentation, etc.
13:46:56 <fizbin> Is there a flag to ghc to turn only certain warnings into errors?
13:47:18 <Handyman> I promised myself I'd never subject myself to vim again :)  I might try Emacs in the future.
13:47:47 <they> Poor IDE support holds Haskell back, in my opinion.
13:47:56 <they> The learning curve of a good Haskell editor is higher than Haskell itself.
13:48:01 <Sculptor> home row navigation is a deal breaker, Handyman
13:49:20 <Handyman> Update - no luck with the Eclipse plugin (again).  ghc-pkg check now reports a bunch of invalid packages.
13:50:30 <Handyman> I'm less concerned with things like debugger support -- I use noweb for literate programming (yeah...) so most of thats out the window anyway.
13:50:44 <Handyman> Haskell's literate programming isn't quite powerful enough for my needs.
13:51:01 <they> Ghci has good debugging support.
13:51:04 <fizruk> edwardk: I see, I'll think what I actually want, thanks!
13:51:09 <they> So, by extension Emacs does as well. Not sure about ivm.
13:51:15 <Handyman> I would, however, like documentation lookup, syntax highlighting and autocomplete
13:51:27 <carter> anyone have opionions on html parsing libs?
13:51:42 <they> Documentation support in Emacs opens in a browser, which kind of sucks. Leksah has it inline.
13:52:04 <Handyman> I'll take a look at Emacs.  I was never a big fan in the past but maybe the 100th time is the charm...
13:52:22 <sleepynate> man i haven't used leksah in years. has it gotten better in recent>
13:52:35 <they> I'm not sure how it was previously.
13:52:35 <Handyman> Leksah also sounding good.  I noticed that development seems to have stalled (last release was two years ago?).  Not sure if that matters.
13:53:04 <they> It's pretty good. Only problems I've had with it are crashes without saving and lack of color customization.
13:53:18 <sleepynate> it hasn't been updated in 2 years? :(
13:53:31 <they> I wish Yi would come along.
13:53:36 <fizruk> edwardk: btw, can that validation form example be placed in free docs?
13:53:53 <edwardk> go for it. we have an examples folder, right?
13:54:23 <edwardk> perhaps use just the one fixed to Either String or something?
13:54:33 <edwardk> that way its less hairy
13:54:44 <fizruk> edwardk: yes, there's a pure version in the same paste
13:55:02 <Cale> Handyman: Generally, any text editor which can convert tabs to spaces will do, as long as you keep ghci open alongside it. You can type :r in ghci to reload your file whenever you make a change, and then test those changes interactively.
13:55:06 <fizruk> edwardk: there's no examples/ in free repo though
13:56:06 <Handyman> Cale: Yeah, my initial instinct was to use BBEdit with it.  Of course, I don't get docs support / cabal support / etc that way but...
13:56:48 <carter> Handyman: egads
13:57:11 <fizruk> edwardk: would you like literate haskell in module or example folder?
13:57:14 <edwardk> fizruk: add one, then add the contents of it to extra-source-files. problem solved.
13:57:15 <Handyman> Should I be concerned that "ghc-pkg check" reports a couple dozen broken packages?  Should I try to figure out how to install ghc without macports (to get the latest)?  Last time, it was a disaster....
13:57:17 * hackagebot validation 0.3.4 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.3.4 (TonyMorris)
13:57:35 <edwardk> i tend to avoid literate haskell, but for examples? its your example. do as you will
13:58:49 <Cale> Handyman: you probably should ghc-pkg unregister those packages if you're not interested in using them, or reinstall them if you are.
13:59:24 <they> So, judging by no replies the consensus is there's no way to do what I asked about?
13:59:40 <they> Just making sure, because I have an absolutely monstrous way of doing it.
13:59:53 <Cale> What did you want to do?
14:00:15 <they> Make an fmap instance so that [(a,a)] is [(a,b)], or at least so 'a' is unchanged.
14:00:24 <Cale> wait, what?
14:00:25 <they> Since it's the lookup key of a database primitive.
14:00:55 <Cale> I don't understand what you mean by [(a,a)] is [(a,b)]
14:01:06 <they> I want to make "data Element a = List [a] | Table [(a,a)]" an instance of functor, but I only want the function applied to the snd of the Table tupples.
14:01:15 <Cale> can't do it
14:01:18 <hexagoxel> they: thats not possible
14:01:20 <they> Alright.
14:01:28 <they> Well, I have a workaround hack.
14:01:33 <they> It's just REALLY workaround, lol.
14:01:34 <Cale> What would the type of the function be?
14:01:53 <hexagoxel> because if f :: a -> b, then fmap would go from Element a to Element b
14:01:57 <Cale> If you write something like:
14:02:11 <they> fmap dictates it needs to be a -> b, but to staisfy that I'd need to change the fst and snd.
14:02:18 <they> Which is bad in a table.
14:02:36 <hexagoxel> they: do you maybe want Element a b = ...
14:02:38 <Cale> elementMap f (List xs) = List (map f xs); elementMap f (Table xs) = Table (map (second f) xs)
14:02:49 <joseph07> they: shouldn't it be data Element a b
14:02:51 <Cale> this has type  (a -> a) -> Element a -> Element a
14:03:24 <they> I guess so. I developed this with just strings in mind.
14:03:26 <joseph07> they: the suggestion is that if you want the key parametrized and the value parametrized, and they can be different types, then they should be different type parameters
14:03:27 <they> But that'd probably work.
14:04:48 <they> I didn't know data could do that, that's neat.
14:04:53 <dmj`> @def k :: (a -> b) -> [(a,b)] -> [(b,b)]; k = \f xs -> map (first f) xs
14:04:55 <lambdabot>  Defined.
14:04:58 <dmj`> @typ k
14:04:59 <lambdabot>     Ambiguous occurrence ‘k’
14:04:59 <lambdabot>     It could refer to either ‘L.k’,
14:04:59 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:150:1
14:05:03 <gilligan_> evening
14:05:10 <orion> What's the difference between "type" and "newtype"?
14:05:59 <dmj`> orion: type is an alias with no compile time guarantees, newtype has compile time checking but gets unboxed at runtime
14:06:00 <joseph07> orion: type defines a type synonym while newtype defines a... new type
14:06:24 <they> newtype is kind of like "data".
14:06:32 <they> type is more like a macro, really.
14:07:04 <corgifex> newtype is data in the front, type in the back
14:07:36 <dmj`> newtype is like data, but can only hold one type
14:11:56 <athan> Has anyone here ever run into the problem of kind matching when working with monad transformers?
14:13:17 <Elizabeth18>  Here some videos. I hope you like them! http://bitly.com/1gAh6Jy
14:13:46 <athan> http://lpaste.net/102847
14:13:58 <athan> Elizabeth18: Thank you!
14:14:16 <athan> lol
14:15:43 <k_bx> Hi everybody! Does anyone know why is constructorTagModifier not applied here? http://lpaste.net/102848
14:16:05 <athan> How could I coerce site0 and site_q?
14:16:11 <tapuu> Does cabal-install compile on ghc 7.8.2?
14:16:31 <tapuu> For me it's getting stuck on 'Compiling data.Text'
14:18:52 <pyon-fire> tapuu: It compiled just fine on my machine.
14:19:08 <pyon-fire> tapuu: I have edited bootstrap.sh to use more recent versions of some libraries, though.
14:19:26 <athan> k_bx: try { fieldLabelModifier = (map toLower) . (drop 4) }
14:19:27 <tapuu> pyon-fire: Are you using a different version of text?
14:19:40 <pyon-fire> tapuu: Let me check.
14:19:49 <tapuu> tetx is the one my compile gets stuck on
14:19:52 <pyon-fire> tapuu: text-1.1.0.1
14:20:07 <k_bx> athan: I guess that should work, thanks. I was just surprised, since this (similar) example is on aeson's doc
14:20:08 <tapuu> pyon-fire: thanks
14:20:22 <tapuu> Thats what I've got though, so it must be a problem on my end
14:20:51 <athan> k_bx: Haaa! Who knows man, sometimes documentation (sadly) gets outdated, even for serious projects, like Yesod. That's where intuition comes in I guess :)
14:21:18 <tapuu> Maybe I dont have enough ram, I have 4MB free...
14:23:57 <k_bx> athan: ah! I think I mis-understood the purpose of constructor tag modifier
14:23:58 <tapuu> Is there anywhere I can get a binary of the latest version of cabal-install for linux x86_64?
14:24:04 <athan> Is System FC technically GHC's Core, or does Core just implement System FC? Also, can other type systems be simulated on System FC?
14:24:20 <lunchtime> wow Haskell seems very popular
14:24:22 <k_bx> athan: it's for algebraic type's constructors, so I should do what you proposed in the first place
14:26:23 <geekosaur> measurements of free ram don't mean anything on modern systems
14:26:52 <athan> k_bx: Yeah I'm not sure man, you can get away with some bugs when you use template haskell. But aeson is very stable, you should definitely still use it
14:26:54 <erisco> geekosaur, because of caches?
14:27:00 <Rarrikins> Use all the RAM!
14:27:16 <athan> what about realtime systems?
14:27:32 <geekosaur> demand paging and unified memory management
14:27:35 <athan> or concurrent schedulers that have multiple threads in pages?
14:27:56 <geekosaur> athan, if that is aimed at me, show me one that runs ghc
14:29:03 <athan> geekosaur: *kneels* I surrender :)
14:30:05 <geekosaur> but yes, let us derail on pedantry yet again because that's always more important that trying to figure out why someone's having trouble compiling something
14:31:56 <geekosaur> truly "don't have enough memory" with ghc tends to show as the OOM killer outright killing it; high memory pressure may manifest as high paging rates but my experience (and observation of others) is ghc is more likely to outright get OOM-killed rather than thrash to a standstill. it could still happen, I suppose, but the metric to look for there is paging rates
14:32:15 <tapuu> How do I look for paging rates?
14:32:52 <tapuu> kswapd0 has used an hour of cpu time in about 5 minutes, is that a problem?
14:33:37 <geekosaur> now *that* sounds like thrashing is likely. on linux vmstat is useful to see paging information
14:34:41 <tapuu> heres the output of vmstat http://lpaste.net/1304382542752776192
14:35:01 <tapuu> I have no idea what these numbers mean :)
14:37:20 * hackagebot muon 0.1.0.4 - Static blog generator  http://hackage.haskell.org/package/muon-0.1.0.4 (kaashif)
14:37:22 * hackagebot muon 0.1.0.5 - Static blog generator  http://hackage.haskell.org/package/muon-0.1.0.5 (kaashif)
14:37:36 <geekosaur> something like "vmstat 1 5" is more useful, it takes 5 snapshots with a 1-second delay between, and it's the swap and to some extent io columns that are relevant
14:39:28 <geekosaur> the high-ish and nearly equal numbers under si and so are significant though and suggest the machine is paging a lot of stuff in and out, so yes more memory would probably help so it can keep a larger working set in ram
14:39:31 <tapuu> geekosaur: I'm looking at the si and so columns, they range from <500 to >3000
14:41:30 <geekosaur> the problem with "free memory" is that significant amounts mean either the system just booted recently or you forced everything out of memory somehow. normal operating allocates as much as possible to various things and reallocates a necessary; a running system rarely has much truly free, so much as it has allocated but inactive (which i much harder to track)
14:42:18 <geekosaur> and you can't really call allocated-but-inactive free because something might decide to use it again
14:42:55 <geekosaur> it gets quite complex and often confusing, but the main take-home is that traditional measures of how much memory is in use for what are extremely misleading on modern systems
14:43:01 <Jafet> "free memory" is just the memory that isn't used by any active working set
14:43:15 <Jafet> (after eliding a few decades of paging research, so sue me)
14:44:20 <tapuu> I cant really increase the ram on this machine, and I need a version of cabal-install thats newer than the one in the repos so i can use a cabal sandbox
14:44:34 <athan> geekosaur: can you see the inverse, related to a particular program? Say, how much RAM a program is occupying vs. swap space?
14:44:35 <geekosaur> if only it were tracked that way. but it's not; the most you can say is that it's allocated but hasn't been used in a long enough time that it's eligible to be recycled. unfortunately, tracking *that* means both making a guess about what counts as "long enough time" and walking potentially a lot of different LRU lists
14:44:53 <tapuu> I have no idea where to go from here
14:45:28 <Jafet> tapuu: what does "stuck on compile" mean?
14:45:30 <tapuu> Wait, it finished compiling data.text
14:45:39 <tapuu> It's moved onto Data.Text.Encoding
14:45:40 <geekosaur> athan: in a limited way. you can't usually measure how much actual swap is in use because process memory accounting doesn't track where a given page is pinned on disk (its executable, a shared object, swap, etc.)
14:45:45 <tapuu> After about an hour
14:45:51 <geekosaur> but you can get a rough guess by comparing SIZE vs. RSS
14:45:56 <Jafet> Ok, so your machine lacks RAM and you will need to wait.
14:45:59 <geekosaur> the latter being what's actually in core at the moment
14:46:19 <Jafet> (Or perhaps disable optimization?)
14:46:50 <athan> geekosaur: Ah! Thank you!
14:46:55 <geekosaur> you may also be able to tell ghc to limit its heap, but then you run the risk of it deciding it doesn't have enough memory to run
14:47:33 <dcoutts> tapuu: 512Mb or less is generally a problem for a standard build of ghc
14:47:34 <tapuu> I always laughed at people that said haskell was a bad language because it used too much ram...
14:47:37 <Jafet> ghc is probably already overflowing onto the disk, so that wouldn't make it work
14:47:50 <dcoutts> tapuu: in particular it tends to die in the linker
14:48:08 <dcoutts> I mean the linker ends up using loads of memory and the kernel kills it
14:48:12 <athan> Is it easy to cross compile?
14:48:13 <Jafet> Ah yes, the thousands-of-os problem
14:48:19 <Jafet> (if it is still a problem)
14:48:25 <geekosaur> it's apparently going into severe thrashing while compiling Data.Text in this case
14:48:54 <dcoutts> tapuu: this usually only comes up when building on VPS systems with small memories. In that case it's usually best to build on one machine and deploy to the server.
14:48:55 <tapuu> It's been on data.text.lazy for a while now
14:49:29 <StoneCypher> hey an article i read makes a claim i find starling about peoples' statistical intuition.  if anyone has a free minute, i'd like to provide three fake datapoints and request an intuitive result, and see if #haskell does better than medical doctors.  in /msg please to keep each others' results untainted.
14:49:31 <geekosaur> I have built smallish haskell programs on a 2GB netbook. it gets painful at times
14:49:53 <StoneCypher> they're at 1 in 6; surely you guys can beat that
14:49:57 <tapuu> dcoutts: This machine is a vps with 256 MiB of ram
14:50:14 <dcoutts> tapuu: oh forget it then, build on a different box and then deploy
14:50:22 <dcoutts> tapuu: you'll never make it past the linking stage
14:50:25 * hackagebot muon 0.1.0.4 - Static blog generator  http://hackage.haskell.org/package/muon-0.1.0.4 (kaashif)
14:50:25 * hackagebot muon 0.1.0.5 - Static blog generator  http://hackage.haskell.org/package/muon-0.1.0.5 (kaashif)
14:50:28 <MP2E> yeah.. 256MB ? rofl...
14:50:41 <MP2E> Not enough RAM for Haskell compiling :<
14:50:54 <geekosaur> wow, yeh, even after you get past this thrashing ld will get OOM-killed
14:50:57 <tapuu> Time to complain to the guy that provided the server
14:51:01 <Jafet> Does gold use less memory?
14:51:16 <tapuu> He won't be happy, I already had him move it because the ping was too high
14:51:30 <dcoutts> tapuu: can't build on another machine and deploy?
14:51:36 <dcoutts> that's best practice really
14:51:55 <tapuu> dcoutts: That is what I will end up doing probably
14:51:59 <dcoutts> Jafet: dynamic linking uses less memory (it doesn't use split objs)
14:52:14 <ReinH> Man, Tekmo's foldl library is nice
14:52:28 <dcoutts> tapuu: to build stuff you'd really want 3/4 of a Gb at least, even 512 is pushing it
14:52:53 <StoneCypher> two takers so far
14:53:02 <StoneCypher> i would like a bunch more if i can get them though :)
14:54:14 <Jafet> Maybe this is not the appropriate place to do a ridiculously biased survey. (A survey about poor statistics, no less...)
14:54:30 <shachaf> StoneCypher: This isn't the right place.
14:55:24 <StoneCypher> ok.  :(
14:55:28 <geekosaur> and wouldn't prove anything because about the only predictor that is relevant is whether they've been trained in statistics. "math" isn't nearly good enough
14:56:32 <geekosaur> (and how current it is. I took a course in stats back in college... meaning the early 1980s.)
14:57:29 <dcoutts> ReinH: mm, though note that it implements foldl in terms of Data.Foldable.foldr using the higher order trick. It's likely not efficient unless ghc's arity raising transform has been improved recently
14:58:11 <StoneCypher> well, that wasn't my goal, but if this isn't the place, i probably shouldn't waste time explaining
14:58:25 <ReinH> dcoutts: not efficient in which way?
14:59:01 <dcoutts> ReinH: a straightforward compilation of foldl implemented in terms of foldr will allocate a closure per iteration
14:59:28 <ReinH> dcoutts: so it leaks heap
14:59:34 <dcoutts> ReinH: a compile-time transformation is needed to turn it into the accumulating parameter recursion that you expect a foldl to be
14:59:43 <ReinH> ok
15:00:00 <dcoutts> ReinH: no, I don't think it retains any more, just generates more garbage and will be slow
15:00:23 <dcoutts> ReinH: find out by compiling a simple sum example and look at the core
15:00:23 <ReinH> dcoutts: makes sense
15:00:28 <ReinH> good plan
15:00:29 <shachaf> dcoutts: foldl' in terms of foldr is even better!
15:00:40 <dcoutts> shachaf: of course :-)
15:00:54 <dcoutts> ReinH: since ghc does now have a limited form of the required transformation
15:01:35 <dcoutts> shachaf: actually it does do it strictly, so it is foldl'
15:01:59 <shachaf> ?
15:02:19 <shachaf> What does it strictly?
15:03:16 <kosmikus> dcoutts doesn't distinguish anymore. he means foldl' whenever he talks about foldl.
15:03:35 <dcoutts> :-)
15:04:41 <dcoutts> shachaf: http://hackage.haskell.org/package/foldl-1.0.3/docs/src/Control-Foldl.html#fold
15:04:47 <dcoutts> note the use of $!
15:10:55 <super_teufel> Some know if  the Haskell platform is working  on ubuntu 14.10?
15:11:08 <monsieurp> of course not
15:11:25 <carter> super_teufel: use install ghc
15:11:26 <carter> :)
15:11:30 <carter> *just install ghc
15:11:35 <Rarrikins> sudo apt-fast install ghc
15:11:44 <Rarrikins> (first install apt-fast)
15:13:14 <super_teufel> why it's not working?
15:13:51 <super_teufel> what is the difference between ghc and haskell platform
15:14:32 <sellout> super_teufel: The latter contains the former, plus a bunch of other stuff.
15:14:52 <super_teufel> if I install ghc alone , I will not have cabal
15:14:59 <Rarrikins> It comes with cabal
15:15:06 <super_teufel> ha k nice
15:15:47 <super_teufel> I will try ubuntu 14.10 then .... thx
15:19:24 <dmj`> if I compile w/ -rtsopts -threaded and run w/ +RTS -N10 -RTS, but only have 8 cores, what happens?
15:19:29 <carter> Rarrikins: it doesnt.
15:19:35 <carter> but tis easy to boostrap a setup
15:19:48 <carter> you could do sudo apt-get install cabal-install probably
15:20:02 <carter> then add ~/.cabal/bin to your path
15:20:08 <carter> and then do cabal install cabal-install
15:20:09 <carter> or something
15:20:23 <Rarrikins> Ahh
15:20:42 <Jafet> It comes with cabal the library, but not cabal the program
15:21:06 <Rarrikins> super_teufel: `sudo apt-get install ghc cabal-install`
15:21:42 <carter> something like that
15:22:17 <Rarrikins> Then you can leave the evil world of apt behind.
15:24:01 <johnw> dmj`: it creates 10 capabilities, which will be assigned to cores in some scheduled fashion
15:24:20 <johnw> dmj`: you are essentially creating overhead for yourself by doing so, with no real gain; but it will work just fine
15:24:49 <thoughtpolice> dmj`: overusing cores, fwiw, will almost always result in a performance degration, practically speaking.
15:24:59 <thoughtpolice> this will likely be the case even without a fully saturated workload
15:25:25 <thoughtpolice> (for this reason, most people just specify +RTS -N, which autoselects based on the # of CPUs. you can also scale the # at runtime these days, as well)
15:26:00 <johnw> i wonder why -N isn't the default
15:26:16 <johnw> and in fact, why -threaded isn't the default as well
15:26:25 <johnw> let -no-threaded and -N1 be the optional settings
15:27:11 <thoughtpolice> -threaded has a small but noticeable impact over non-threaded for some workloads IIRC. also, you don't necessarily always want -N, because that also implies usage of the parallel GC, which may or may not actually also increase performance, depending on a range of factors
15:27:41 <thoughtpolice> but you also don't want to unconditionally turn it off, because in a majority of parallel cases it's probably a win. but there's an argument to rethink the defaults, sure
15:27:59 <thoughtpolice> i'm not sure what the overhead of -threaded is BTW, but I imagine it passes the Marlow Barrier unfortunately
15:29:01 <thoughtpolice> (for example, I suspect most people's non-parallel programs would see no benefit, but probably worse results from -threaded -N by default. if it's single threaded the parallel GC especially won't buy you anything as it maxes your cores)
15:29:16 <thoughtpolice> that behavior is also confusing as hell for users - "why does my single threaded program use 400% CPU?"
15:30:56 <johnw> true
15:31:07 <johnw> i guess it depends on what kinds of Haskell programs people write on average
15:31:36 <Jafet> I haven't quite figured out how to make haskell programs parallel. (Apart from the trivially parallel ones.)
15:33:50 <skinnr> hey guys
15:33:58 <johnw> hi skinnr
15:34:08 <skinnr> I have issues with xmonad
15:34:20 <johnw> #xmonad may be a better place
15:34:33 <skinnr> yes, I know
15:34:39 <johnw> ask away
15:34:48 <skinnr> unfortunately no replies
15:35:21 <skinnr> I'll provide you with a pastebin link to start:
15:35:46 <johnw> I don't know xmonad at all, but I can help if it's a Haskell problem
15:37:37 <skinnr> http://pastebin.com/phXDBH16
15:38:13 <skinnr> this is my xmonad configuration file
15:38:31 <sipa> try #xmonad
15:38:38 <skinnr> I appear to have problems spawning terminals
15:38:43 <corgifex> sipa: read up
15:39:07 <sipa> ok
15:39:38 <skinnr> I know the XMonad.Util.Run library has safeSpawn and unsafeSpawn in it
15:39:52 <skinnr> and i hoped I could import them
15:40:07 <skinnr> unfortunately I get errors when I do
15:40:42 <corgifex> what's the problem with spawning terminals?
15:40:54 <skinnr> I do: import XMonad.Util.Run(safeSpawn, unsafeSpawn, spawnPipe)
15:41:10 <geekosaur> uhhhh, I see a config file based on the "don't use this" which whacks all the defaults to defaults for a specific version. don't do that
15:41:11 <skinnr> I doesn't respond to keypresses
15:42:40 <skinnr> geekosaur, most of these settings have been manipulated
15:42:52 <skinnr> with the comments left in for future reference
15:44:12 <simon> will GHC fuse 'unzip . map', or will laziness sort of do this anyway?
15:44:30 <simon> sorry, 'unzip . map f'
15:44:59 <tikhon> > :t unzip
15:45:00 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:45:02 <Jafet> Fusion is about avoiding list creation, which laziness will not do (which is why we have fusion)
15:45:07 <tikhon> @ty unzip
15:45:08 <lambdabot> [(a, b)] -> ([a], [b])
15:45:36 <tikhon> laziness will be enough to interleave the mapping and unzipping, but won't prevent extra allocation
15:45:54 <simon> ok. thanks!
15:46:01 <tikhon> whereas fusion could save you the allocation as well, but I'm not sure if it would work in this case
15:46:14 <Cale> (however, that interleaving will result in constant space usage at least)
15:46:20 <tikhon> yes
15:46:39 <tikhon> so for most intents and purposes, the laziness makes this "good enough", especially since GHC's GC is pretty good
15:46:42 <Jafet> Just write a rule for unzip . map. Or does ghc already do this transformation automatically?
15:46:51 <skinnr> johnw: what do you think?
15:48:04 <skinnr> geekosaur: the default config file also came with the installation
15:49:49 <geekosaur> skinnr, if it came with the installation then it has a large comment at the top telling you why you should not use it
15:50:09 <geekosaur> unless it came with one of the linuxes that filed it off and got all their users to config the wrong way
15:50:41 <c_wraith> Jafet: doesn't look like the current base source supports any sort of fusion of unzip
15:50:43 <geekosaur> (which are, generally, the same ones that will upgrade xmonad quickly and trigger the problems caused by using that config directly)
15:51:06 <skinnr> I compiled it myself and running it on freebsd
15:51:56 <skinnr> the message said that for the sake of brevity you _may_ leave configurations to their defaults and leave them out of the configuration file
15:52:17 <skinnr> it is an option, not a requirement
15:52:41 <skinnr> besides, I've configured the hell out of it
15:52:53 <skinnr> and I know what I'm doing
15:52:55 <geekosaur> sounds like an older version then. I've had to help too many people who took that as "leave it all in" and then got broken when for example dmenu changed the way it is used
15:53:39 <skinnr> I don't use the dmenu library as you can see
15:54:02 <skinnr> I just spawn the application
15:54:59 <skinnr> I have removed the second XMonad.StackSet import
15:55:05 <skinnr> redundant
15:56:46 <skinnr> but thanks though
15:57:21 <skinnr> I'll guess I'll have to figure it out some other way
15:59:30 <albeit> What would be the best way to merge two lists with a provided function, and return the new list along with a list of indices that were selected from the second list? Type would be (a -> a -> a) -> [a] -> [a] -> ([a], [a])
16:00:17 <dibblego> indices? what is this?
16:00:27 * hackagebot ersatz 0.2.5 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.2.5 (EdwardKmett)
16:00:38 <hpc> so like
16:00:58 <Cale> The usual way to work with indices is to use zip [0..]
16:01:07 <albeit> Well not indices, but the value that selected from teh second list.
16:01:12 <dibblego> do you mean the return type to be [(a, Int)]?
16:01:27 <hpc> foo maximum [1, 2, 3] [5, 1, 8] -- outputs ([2], [5,8])?
16:01:53 <albeit> foo maximum [1,2,3] [5,1,8] -- outputs ([5,2,8], [5,8])
16:02:05 <hpc> ah
16:02:10 <corgifex> albeit: what about foo (+)?
16:02:13 <hpc> well in any event, your type is too general
16:02:14 <hpc> yeah, that
16:02:35 <hpc> instead of foo maximum, i'd suggest a type that admits foo (>)
16:03:01 <hpc> and probably have it return [Either a a]
16:03:19 <corgifex> ~ (Bool, a)
16:03:20 <hpc> that way the result is "list of choices"
16:03:22 <albeit> Yes that would make more sense. I was thinking of zipping the two lists, and then folding over that, with the accumulator holding the result pair
16:04:05 <hpc> :t \f -> zipWith (\a b -> (f a b, if f a b then a else b))
16:04:06 <corgifex> a + a = 2 * a  -- I can algebra!
16:04:06 <lambdabot> (t -> t -> Bool) -> [t] -> [t] -> [(Bool, t)]
16:04:09 <hpc> do that
16:04:15 <joneshf-laptop> i can't remember if i asked this already, but what's the status on enforcing laws in typeclasses? are we fundamentally borked in haskell and have to use a proof language, or is there some way that could work, but is infeasible?
16:04:43 <c_wraith> joneshf: it's fundamentally beyond the capabilities of haskell
16:04:54 <hpc> joneshf-laptop: it's getting better, but you can't do arbitrary proofs
16:05:06 <hpc> and the "proofs" you can make are contingent on not using unsafeCoerce and friends
16:05:33 <c_wraith> there are things like liquidhaskell that provide a lot of additional abilities, though
16:05:43 <hpc> you need to use a combination of type classes/families, data kinds, constraint kinds, GADTs, and more
16:05:46 <hpc> to pull it off well
16:06:05 <joneshf-laptop> c_wraith, shame that, do you know what we're missing?
16:06:13 <joneshf-laptop> hpc, hmm, sounds interesting
16:06:18 <c_wraith> joneshf: termination checking is the real issue
16:06:34 <hpc> :t fix id -- i have proved all things
16:06:35 <lambdabot> a
16:06:53 <corgifex> :t undefined
16:06:54 <lambdabot> a
16:07:02 <hpc> corgifex: mine's technically shorter ;)
16:09:24 <simon> hpc, are you sure that's not just one of your fixed ideas?
16:09:50 <orion> Is `data' like `enum' in C?
16:10:01 <corgifex> orion: data is struct+union+enum
16:10:02 <hpc> joneshf-laptop: the reason i don't say outright that it's not possible is that haskell doesn't support infinite types
16:10:16 <hpc> joneshf-laptop: meaning at the type level, things are strongly normalizing and you get some degree of soundness back
16:10:46 <hpc> but don't for a second think what you derive will actually be true at runtime, bottom always gets in the way
16:10:47 <simon> orion, if you derive/declare the typeclasses Ord, Eq, then more.
16:11:13 <corgifex> data T = C X1 X2 X3 X4  -- struct
16:11:17 <hpc> you can reason very well about the shape of defined values just fine though, and in practice say that bottoms are an error and should never occur
16:11:23 <corgifex> data T = C1 | C2 | C3 | C4  -- enum
16:11:45 <hpc> which most haskellers do to avoid going crazy
16:11:49 <joneshf-laptop> hpc, hmm
16:11:50 <hpc> we have a love/hate relationship with bottoms
16:11:54 <Jafet> If you keep your nose to the types when writing code, it's pretty easy to write bottoms though
16:18:21 <athan> Has anyone here ever run into the problem of kind matching when working with monad transformers? (Sorry, this is a duplicate question from earlier this morning)
16:18:44 <athan> Here is the error code: http://lpaste.net/102847
16:19:53 <albeit> Is there any way to add nothing to a list when using ":"? Something like "specialVal : xs" = xs
16:20:30 * hackagebot ersatz 0.2.5.1 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.2.5.1 (EdwardKmett)
16:21:55 <Jafet> [] ++
16:22:42 <athan> albeit: Well, you could see it like specialVal has an if statement where if a condition passes, some arbitrary amount of values are the result, or it is just []
16:23:17 <athan> like specialVal = if (someconditionInScope) then [results,added,in,scope] else []
16:23:50 <athan> so that information prepended to xs is conditional
16:27:34 <albeit> Okay. I was just trying to shorten "if f x then x:xs else xs", but i guess that may be the shortest
16:29:13 <albeit> Another question: If have my own datatype Vertex, and "x = Vertex val1 val 2", and I later say "y = x", does y point to x, or are x's values copied to y?
16:33:36 <Jafet> albeit: is there a difference? (Technically, it's the former.)
16:33:51 <Jafet> But there is really no difference
16:40:31 * hackagebot ersatz 0.2.6 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.2.6 (EdwardKmett)
16:40:40 <ScriptDevil> I can see lens-datetime 0.2.1 in hackage.haskell.org. But when I added build-deps: lens-datetime == 0.2.* in myProj.cabal, cabal install --only-dependencies said that it could only find 0.1.0 which it rejected. Why?
16:41:57 <ScriptDevil> I did do a cabal update as well. No change
16:43:41 <edwardk> ScriptDevil: you might have some other dependencies forcing you down to older versions of some dependencies if cabal update doesn't help
16:44:50 <atlasblade> hello everyone
16:44:54 <atlasblade> https://www.youtube.com/watch?v=sDXAeyOIR-A
16:45:01 <ScriptDevil> cabal list lens-datetime does not shows only 0.1.0
16:45:16 <ScriptDevil> edwardk: how do I find the offending package?
16:46:19 <dibblego> (if f x then x:xs else xs) ~ ((if f x then (x:) else id) xs)
16:46:28 <edwardk> you may need to grab more of a cabal dependency hell expert. i tend to go rummage through the list of dependencies, backtrack through hackage by hand, get lost, stare at it real hard. then go 'duh' 10 minutes later and fix it
16:46:33 <edwardk> hard to teach that approach =)
16:48:10 <ScriptDevil> edwardk: :D Ok. Looks like it is my turn to do so now. I have just started using sandboxes. I am thinking of nuking my ~/.cabal once and start using sandboxes for everything.
16:52:05 <ticktockman> Are most people now using 7.8 or is 7.6 still the most popular?
16:54:12 <edwardk> ticktockman: 7.6 is still in the current platform. 7.8 is mostly for library developers to get ahead of coming changes
16:54:50 <ticktockman> edwardk: Is 7.8's performance better by any significant amount?
16:55:00 <xpte> has anyone else had trouble installing cairo on mavericks? all i can find is https://github.com/gtk2hs/gtk2hs/issues/1
16:55:03 <edwardk> ticktockman: actually its a little bit worse really.
16:55:16 <geekosaur> besides which, 7.8 was only just released so it'll take a while
16:55:34 * hackagebot cookbook 2.3.3.1 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.3.3.1 (NatePisarski)
16:55:59 <ScriptDevil> I actually love some of the changes in 7.8. Still very green in Haskell, but the changes are pretty neat.
16:57:18 <stevejb> hello, does anyone have a moment to help me debug a probably simple cabal issue. I am trying to get my library + executable project set up to build with cabal. I have some details on the .cabal and the relevant files here. https://gist.github.com/stephenjbarr/6f1de2c4ff5d37c4d42b
16:57:30 <ScriptDevil> ticktockman: 7.8.1 includes MIO. I read the paper related to that and it should speed up heavily concurrent IO by an order of magnitude.
16:57:41 <ScriptDevil> Haven't used it in practice, though.
16:58:34 <ticktockman> ScriptDevil: From what I read, the llvm backend has been improved upon significantly too, right?
16:59:15 <geekosaur> stevejb, aside from the commented-out but necessary import being in the wrong place, what is the issue?
16:59:25 <geekosaur> (imports come *after* the module declaration)
16:59:53 <stevejb> geekosaur: I am new at this. *That* may be the issue.
17:00:01 <ScriptDevil> ticktockman: Not sure.
17:00:43 <stevejb> geekosaur: I think that that was it. Great....
17:00:46 <stevejb> geekosaur: :)
17:00:54 <stevejb> geekosaur: thanks
17:01:55 <stevejb> one other question, do I need to list the same list of build-depends for the library as for the executable. It seems to be giving me a set of errors suggesting that that is the case
17:02:04 <geekosaur> yes
17:02:23 <geekosaur> handling of that situation is less than optimal currently
17:02:25 <joelteon> where did Generic go?
17:02:36 <Rarrikins> @hoogle Generic
17:02:36 <lambdabot> Data.Text.Lazy.Builder.RealFloat Generic :: FPFormat
17:02:36 <lambdabot> Data.Generics.Aliases type Generic c = forall a. Data a => a -> c a
17:02:36 <lambdabot> Data.Generics module Data.Generics
17:02:40 <joelteon> it used to be GHC.Generics didn't it
17:02:53 <Rarrikins> lmhtfy ;)
17:03:14 <joelteon> but that's from syb
17:06:38 <ScriptDevil> Damn cabal install cabal-install failed because in HTTP 4000.2.4 Auth.hs:192 "Couldn't match expected type `Maybe URI' with actual type `URI'" :-/
17:07:20 <geekosaur> fwiw I show GHC.Generics still in 7.8's base
17:07:40 <geekosaur> ScriptDevil, that sounds familiar, there's a missing upper bound iirc
17:09:18 <ScriptDevil> geekosaur: So, how do I fix it?
17:09:34 <geekosaur> I'm looking for the details
17:11:59 <ScriptDevil> geekosaur: Found it https://github.com/haskell/HTTP/issues/55
17:12:07 <ScriptDevil> But I still do not know how to fix... :-/
17:17:15 <geekosaur> urgh, the message I remembered that had a constraint to make it work was about the cabal 1.20 prerelease. I don't know how to deal with this one
17:17:16 <ScriptDevil> This is completely counter-intuitive to me cabal-install's dependency is HTTP (>=4000.0.8 && <4001). Why not pick Network 4000.2.12 which actually installs/is-installed on my system?
17:17:19 <geekosaur> dcoutts,=?
17:17:40 <geekosaur> because the dependency in the HTTP package on network is broken
17:18:12 <geekosaur> and the HTTP package itself doesn't follow versioning rules and screws up cabal's ability to pick a compatible version
17:18:52 <ScriptDevil> geekosaur: Aah. Got it. I can see now. It adds a network <2.5 in all versions > 4000.2.4
17:19:34 <ScriptDevil> So what is the standard rule? Don't add upper-bounds?
17:20:00 <geekosaur> no
17:20:06 <Welkin> @pl --help
17:20:06 <lambdabot> (line 1, column 1):
17:20:07 <lambdabot> unexpected "-"
17:20:07 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
17:20:17 <ScriptDevil> I admit I sounded stupid there.
17:20:22 <geekosaur> a;though that is the one some devs prefer, because a little less work for them that screws over users even worse is clearly a good thing,,,
17:20:40 <geekosaur> the problem here is more that HTTP itself uses weird version numbers
17:20:53 <geekosaur> and that screws with what would otherwise be a minor issue
17:21:20 <geekosaur> but I don't know how to fix it. I think you want to talk to dcoutts but he's apparently not around at the moment
17:21:52 <ScriptDevil> Ok. Thanks!
17:30:36 * hackagebot propellor 0.3.1 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.3.1 (JoeyHess)
17:40:00 <sm> hmm.. how can I bootstrap alex on windows, without using the HP installer ?
17:45:27 <sm> does alex really require itself to build ? I can't see where
17:50:55 <dhaivat> Hi everyone. I'm a Haskell newbie and I'm writing a basic "weather getter" using a JSON api. So, I am getting the JSON as an IO String, but I'm not sure how to pass this IO String onto my "pure" set of functions which all accept [Char]'s or String's. Ideas?
17:51:12 <sm> on another note, is there any way to unpack the contents of the HP without admin rights ?
17:51:16 <sm> (on windows)
17:51:29 <dibblego> dhaivat: fmap
17:51:42 <geekosaur> dhaivat, have you read LYAH yet?
17:51:46 <geekosaur> @where lyah
17:51:46 <lambdabot> http://www.learnyouahaskell.com/
17:51:50 <dhaivat> geekosaur: not all of it
17:53:11 <dhaivat> dibblego: hmm.. I'm having some issues understanding what is going on
17:53:22 <dibblego> fmap theFunction theIOaction
17:54:49 <dhaivat> http://pastie.org/9088659
17:55:06 <geekosaur> dhaivat, an IO action is a promise to deliver a value at some point in the future. you can't force it. what you can do is wrap a pure function into the action with fmap, or bind a pure function to it with (>>=) (or <- in do notation)
17:55:29 <geekosaur> do notation is probably easiest because you can pretend you're working with the actual value
17:55:41 <cwvh> dhrosa: do { x <- getJSON; my_pure_function x; ... }
17:55:47 <cwvh> dhaivat: *
17:57:16 <dhaivat> cwvh: this does not work either: http://pastie.org/9088661
17:57:43 <cwvh> dhaivat: return (decode body)
17:58:04 <cwvh> you want to "lift" the value of the result of (decode body), not lift the function `decode' and then apply a pure value (that's your type mismatch)
17:58:16 <Welkin> or return $ decode body
17:58:51 <dhaivat> okay, that worked but I'm not sure why
17:59:03 <dhaivat> what is the difference between return decode body and return $ decode body
17:59:06 <Welkin> order of operation, dhaivat
17:59:09 <dhaivat> what does the first do?
17:59:15 <dhaivat> does it just return the function decode?
17:59:16 <Welkin> parens denote order
17:59:18 <cwvh> dhaivat: return decode s   ~>   (return decode) s
17:59:54 <Welkin> $ is an alternative way to write (), so that everything right of the "$" is evaluated before anything on the left
18:00:14 <dhaivat> Okay, got it
18:00:18 <dhaivat> Thank you all very much.
18:01:08 <sm> ha! easy sm, just answer the HP installer carefully to install somewhere unprivileged
18:10:40 * hackagebot haeredes 0.4.0 - Confirm delegation of NS and MX records.  http://hackage.haskell.org/package/haeredes-0.4.0 (MichaelOrlitzky)
18:33:27 <jtcwang> Hey people, anyone got a program they wrote that involves conduit and exception handling?
18:33:28 <xpte> anyone know how to get `cabal install cairo` to succeed on Mavericks? i get this when i try: http://hastebin.com/jewogefeji.vhdl
18:34:53 <albeit> Hey all, I have a function that performs correctly, but I don't think it looks very good / idiomatic. Is it okay if I paste a link to it and have whoever is willing review it?
18:35:03 <jtcwang> i can
18:35:03 <johnw> paste away
18:36:35 <albeit> Sweet, here we go: http://lpaste.net/102855
18:37:41 <johnw>  albeit: is the order of the output important?
18:38:08 <johnw> if (getDistance x) < (getDistance y) then -> if getDistance x < getDistance y then
18:39:11 <albeit> The order of the list of best vertices is important. The order of the list form teh first list is not important, nor is the order of the outputs in the output pair.
18:39:21 <johnw>  newToScan
18:39:22 <johnw>    | getDistance bestVertex /= getDistance y = bestVertex:toScan
18:39:22 <johnw>    | otherwise = toScanf
18:39:50 <johnw> i would suggest bestVertex:bestVertices, and then reverse it at the end
18:40:13 <jle`> you could do the same guard transformation for bestVertex but that is less of a dramatic difference
18:45:27 <albeit> Okay, so with the changes it looks like http://lpaste.net/102856
18:45:51 <albeit> The triple nested where's seem ugly... and is folding and the other high level ideas the best way to approach this function?
18:47:55 <johnw> albeit: I would have formatted it as: https://gist.github.com/11020710
18:47:58 <xpte> could you break those wheres in to lets?
18:48:05 <xpte> well, one let
18:48:54 <xpte> reading a single let from top to bottom might be nicer
18:49:02 <johnw> true
18:53:24 <albeit> If they were lets, wouldn't it still have be nested because the later clauses use variables in the previous variables patterns?
18:54:19 <tavoe> I'm on windows. I keep getting "To upgrade, run: cabal install cabal-install". I know I need to fiddle with my path to fix this, but I don'
18:54:27 <tavoe> t remember exactly what I have to jigger
18:56:52 <xpte> i'd be mildly surprised if there was really no way to turn your function in to a series of definitions
18:56:58 <srhb> albeit: Nope. :)
18:59:03 <xpte> you seem to be shadowing newToScan, you would just make one of those newToScan'
18:59:53 <albeit> Ya I realized that trying to make it into lets, changing some variable names around now
19:00:44 <xpte> i don't suppose you're running mac os mavericks, albeit =]
19:00:59 <albeit> No, I'm on Ubuntu
19:01:09 <xpte> rats, i was hoping for a guinea pig to try and install cairo
19:01:15 <athan> Hey guys, do the packages available in sandboxes depend on your installed environment, or are they downloaded version-specific each time? (depending on your ghc/base though, right?)
19:01:16 <xpte> maybe the error is just me :/
19:01:28 <albeit> Ha, sorry, I'd try if I was
19:02:18 <athan> would mac sell virtualbox images?
19:02:24 <athan> er apple?
19:12:44 <albeit> Okay everything is in a single let http://lpaste.net/102857. It looks a bit cleaner, but I have to call bestVertex x y in four different places, and that doesn't seem ideal.
19:16:20 <xpte> bestVertex x y is a single value, yes?
19:16:27 <xpte> just make that value a definition in the let as well
19:16:57 <albeit> x and y will be changing for each iteration of the fold
19:17:20 <xpte> oh i see, didnt read it properly
19:42:27 <albeit> Is using iterate discouraged in Haskell? It seems like a functional way of using a for/while loop?
19:42:50 <StoneToad> iterate?
19:43:25 <StoneToad> the prelude iterate?
19:43:30 <albeit> Yes
19:43:36 <StoneToad> don't see why not?
19:43:56 <StoneToad> it may not be the best solution mind you, but no reason not to use it
19:44:39 <copumpkin> > iterate (+1) 0
19:44:39 <copumpkin> it's not really a loop like that
19:44:39 <copumpkin> and it's not discouraged
19:44:40 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:45:37 <copumpkin> lambdabot so fast
19:46:01 <StoneToad> I love lazy eval
19:46:33 <ReinH> albeit: you can just give the result of bestVertex x y a binding
19:47:14 <albeit> How do you mean?
19:48:39 <ReinH> albeit: if it's called with the same values you can give it a binding to force sharing
19:48:45 <ReinH> if not then I'm not sure what's wrong with calling it more than once
19:50:17 <ReinH> also getVertex = min `on` getDistance, fwiw
19:52:27 <albeit> So I would have another let clause under the "step" definition to bind the bestVertex to. And I just tried `on` in ghci, and it says not in scope... is part of some module?
19:53:19 <ReinH> Data.Function
19:53:36 <ReinH> It's just a convenient way to do
19:53:38 <ReinH> @src on
19:53:38 <lambdabot> (*) `on` f = \x y -> f x * f y
19:54:17 <ReinH> I still with Data.Function exported the Num instance
19:54:39 <ReinH> *wish
19:57:50 <albeit> Wouldn't min `on` getDistance return a Float thought? I need it to return a Vertex
19:58:12 <ReinH> :t on
19:58:13 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
19:59:05 <ReinH> albeit: you're right
19:59:26 <ReinH> I'm thinking of minBy
19:59:37 <ReinH> no I'm not
19:59:40 <ReinH> never mind
20:00:49 <ReinH> oh, minBy is defined as part of minimumBy but isn't toplevel. I always thought that was weird.
20:01:13 <ReinH> albeit: what you can actually do is define an Ord instance for Vertex
20:01:26 <ReinH> and then just use min
20:01:48 <albeit> Ah that makes sense, perfect
20:02:08 <ReinH> instance Ord Vertex where compare = compare `on` getDistance
20:03:23 <ReinH> hmm, for the Eq requirement you probably want to do derive Eq and then use distance and index: compare x y = compare ((getDistance x, getIndex ) (getDistance y, getIndex y))
20:03:35 <ReinH> since you need some (arbitrary) way of ordering vertices with the same distance
20:04:48 <ReinH> :t compare `on` (getDistance &&& getIndex)
20:04:50 <lambdabot> Not in scope: ‘getDistance’
20:04:50 <lambdabot> Not in scope: ‘getIndex’
20:05:00 <ReinH> woops, but yeah that
20:05:37 <ReinH> braces can be removed
20:07:02 <albeit> Would Ord require a way of ordering vertices with the same distance?
20:17:43 <hiptobecubic> :t minBy
20:17:44 <lambdabot> Not in scope: ‘minBy’
20:17:48 <hiptobecubic> :t minimumBy
20:17:49 <lambdabot> (a -> a -> Ordering) -> [a] -> a
20:17:57 <carter> everythings a fold!
20:18:08 <carter> turtles or folds all the way down1
20:18:10 <hiptobecubic> minimumBy is lists only? Or is that just lambdabot
20:18:26 <hiptobecubic> you'd expect any foldable would work i'd think
20:19:33 <hiptobecubic> you could use foldMap with a min monoid
20:20:04 <hiptobecubic> oh
20:20:13 <hiptobecubic> The Foldable module also provides a large number of predefined folds, many of which are generalized versions of Prelude functions of the same name that only work on lists: concat, concatMap, and, or, any, all, sum, product, maximum(By), minimum(By), elem, notElem, and find.
20:20:14 <hiptobecubic> Ther eyou go
20:20:59 <albeit> If I have a bunch of tuples :: [(a,b)], and I want only one of every tuple where 'a' is the same (choose the one with minimum b), should I somehow use a Data.Set or a Data.Map keyed to 'a' and use insertBy when adding new tuples?
20:21:05 <David> I'm trying to do some HTML parsing (identifying tags and the like). Is there a library you guys can recommend to do that or should I just write my own parser with parsec?
20:21:25 <joneshf-laptop> hey
20:21:47 <joneshf-laptop> why can't we steal things from other languages?
20:21:50 <joneshf-laptop> compilers i mean
20:22:03 <joneshf-laptop> like steal dependent typing from idris or something
20:22:28 <joneshf-laptop> my question is not well formed
20:22:28 <hiptobecubic> albeit, if you don't need to remember old versions of (a, b), then a map would work nicely i think
20:22:49 <hiptobecubic> joneshf-laptop, we don't want dependent typing. We want to write programs :)
20:22:51 <albeit> Yep don't need to remember old versions, map it is. Thanks
20:23:31 <joneshf-laptop> hiptobecubic, note, I said idris, not agda ;P
20:23:51 <hiptobecubic> albeit, this is also a fold i guess. but you'll just be building a map as you go anyway
20:24:08 <pavonia> David: I guess there are several libraries for HTML parsing, tagsoup is quite nice for extracting data from tags/attributes
20:24:20 <joneshf-laptop> i think what's i'm asking is, are there any compilers that aren't so tightly bound to a specific language?
20:24:46 <joneshf-laptop> or rather, any static analysis tools
20:24:46 <David> pavonia: thanks, will investigate tagsoup
20:24:48 <joneshf-laptop> like a generalized type checker
20:25:24 <xpte> haha, a generalized type checker that could actually be plugged in to popular languages would be incredible
20:25:30 <hiptobecubic> :hoogle insertBy
20:25:39 <hiptobecubic> :t insertBy
20:25:40 <lambdabot> (a -> a -> Ordering) -> a -> [a] -> [a]
20:26:00 <xpte> i wonder if there's a sensible type system that could serve as a minimum common denominator for things like python/ruby/js though
20:26:22 <joneshf-laptop> lambda calc
20:26:29 * joneshf-laptop goes off to formulate this idea
20:26:34 <defanor> i'm looking for an array with fast (logarithmic) insertion/retrieval; modification would be nice, no deletion needed. any suggestions?
20:26:53 <dmwit> defanor: finger trees
20:27:02 <defanor> dmwit: will check, thanks
20:27:10 <dmwit> defanor: e.g. I think Data.Seq uses finger trees underneath
20:27:20 <pavonia> Why not Data.Map?
20:27:28 <hiptobecubic> indeed
20:27:36 <dmwit> Data.Map does not guarantee contiguous entries
20:27:58 <defanor> yep, i though that smth more specific could work better here
20:27:59 <hiptobecubic> defanor, do you need an actual array? in memory? What properties do you really care about
20:28:14 <dmwit> I think he was pretty clear about what properties he cared about.
20:28:55 <hiptobecubic> well I guess what i mean is do you explicitly mean "array" or is that just a colloquialism for "data structure with stuff in it"
20:29:10 <defanor> hiptobecubic: not necessary "real", and only those properties which i mentioned already
20:29:30 <pavonia> dmwit: How do you know he needs contiguous entries?
20:29:34 <hiptobecubic> defanor, so contiguous entries don't matter then?
20:29:39 <hiptobecubic> pavonia, because he said "array"
20:29:47 <hiptobecubic> which is why I asked
20:30:51 * hackagebot universe-base 1.0 - A class for finite and recursively enumerable types and some helper functions for enumerating them  http://hackage.haskell.org/package/universe-base-1.0 (DanielWagner)
20:30:53 * hackagebot universe-instances-base 1.0 - Universe instances for types from the base package  http://hackage.haskell.org/package/universe-instances-base-1.0 (DanielWagner)
20:30:55 * hackagebot universe-instances-extended 1.0 - Universe instances for types from select extra packages  http://hackage.haskell.org/package/universe-instances-extended-1.0 (DanielWagner)
20:30:57 * hackagebot universe-reverse-instances 1.0 - instances of standard classes that are made possible by enumerations  http://hackage.haskell.org/package/universe-reverse-instances-1.0 (DanielWagner)
20:30:59 * hackagebot universe-instances-trans 1.0 - Universe instances for types from the transformers and mtl packages  http://hackage.haskell.org/package/universe-instances-trans-1.0 (DanielWagner)
20:31:12 <hiptobecubic> Yes, thank you hackagebot. That'll do.
20:31:14 <defanor> hiptobecubic: nope
20:31:24 <dmwit> (sorry)
20:31:52 <hiptobecubic> dmwit, you were right, defanor just said some extra constraints that they didn't want.
20:32:05 <hiptobecubic> defanor, anyway map is O(1) for those things.
20:32:48 <hiptobecubic> I don't remember what the restrictions are though. Hashable i would assume?
20:33:08 <dmwit> err? Data.Map is not O(1) for insertion/retrieval.
20:33:24 <defanor> hiptobecubic: um, i actually just need numbers. it seems a little weird that map is most suitable thing for that
20:34:00 <defanor> though it should work anyway
20:34:02 <hiptobecubic> dmwit, it' snot? am i thinking of hashmap, then?
20:34:11 <Ralith> defanor: IntMap is good if your dataset is sparse
20:34:19 <Ralith> if it's not sparse just use an array
20:34:31 <defanor> Ralith: it's not sparse
20:34:38 <Ralith> then why is this even a question
20:34:50 <dmwit> Because updates are slow with (immutable) arrays.
20:34:52 <defanor> is there a way to insert a value into array fast?
20:35:18 <Ralith> depends on your requirements
20:35:30 <defanor> i need it for a graph
20:35:40 <defanor> which will only grow
20:35:42 <dmwit> Oh, what.
20:35:47 <dmwit> Why not just use a graph type, then.
20:35:49 <dmwit> ?hackage fgl
20:35:50 <lambdabot> http://hackage.haskell.org/package/fgl
20:36:01 * hackagebot universe 1.0 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-1.0 (DanielWagner)
20:36:07 <defanor> well, i need a DAG, but with some properties, and thought that it's too specific
20:36:19 <hiptobecubic> the XY problem strikes again I guess
20:36:27 <defanor> checked fgl, but probably just have not found what i was looking for
20:36:51 <defanor> i need to add elements there, but fast. and traverse it in both directions, and list "root" nodes fast
20:37:00 <dmwit> Okay. What operation are you hoping to do that only makes sense on DAGs that fgl doesn't offer?
20:38:07 <defanor> (fast = logarithmic)
20:38:45 <defanor> i mean, as fast as possible for a pure graph
20:39:21 <gamegoblin> If I define an infix function, the compiler yells at me if I do “a <?> b <?> c <?> d”. Something about precedence etc. The infix is defined as “infix 0 <?>”. How can I make a change so I can do that example? Some sort of left/right precedence?
20:39:50 <dmwit> Use infixr or infixl instead of infix.
20:40:11 <gamegoblin> which one will make it so `d` gets applied last?
20:40:27 <dmwit> I don't know what "gets applied last" means.
20:40:27 <shachaf> You should read the documentation on infix/infixr/infixl
20:40:42 <dmwit> infixr will cause it to be right associative: a <?> (b <?> (c <?> d))
20:40:57 <dmwit> infixl will cause it to be left associative: ((a <?> b) <?> c) <?> d
20:40:58 <gamegoblin> Which one would parse that statement as (((a <?> b) <?> c) <?> d)
20:41:00 <shachaf> It's a little bit complicated to type all the details in IRC, I think.
20:41:10 <gamegoblin> gotcha
20:41:13 <gamegoblin> infixl it is
20:41:50 <shachaf> Well, you could say that much.
20:45:52 <joelteon> Is there a library function to check whether a string is a valid Name?
20:46:13 <gamegoblin> What’s a Name
20:46:44 <joelteon> from TH
20:46:44 <joelteon> variable/constructor/operator/etc. name
20:46:48 <startling> What do you call the comma in in emacs lisp? Does haskell's quasiquotation have that?
20:48:09 <itsmonktastic> hi. is there a way to ``cabal install <package>'' and have the cabal file updated automatically?
20:48:26 <startling> itsmonktastic: nope.
20:48:36 <startling> You can move it somewhere else, install the thing, and then cabal init
20:48:38 <startling> but it sucks.
20:49:13 <itsmonktastic> startling: hmm okay. is there a way to dump the contents of a cabal sandbox?
20:49:32 <startling> "dump" meaning "turn into a .cabal file"? no.
20:49:42 <itsmonktastic> startling: well, just output in any way
20:49:55 <gamegoblin> Ugh gotta learn haddock comment syntax.
20:50:05 <startling> itsmonktastic: oh. cabal sandbox hc-pkg list
20:50:33 <itsmonktastic> startling: thanks, I'll give that a try
20:52:05 <itsmonktastic> startling: ah, that includes loads of stuff I don't need to add, I see :p
20:52:19 <startling> itsmonktastic: well, it's all the transitive dependencies as well
20:52:22 <itsmonktastic> yeah
20:53:29 <itsmonktastic> I guess I could reverse what I'm doing, start by editing the file, then cabal repl or w/e.
20:54:05 <itsmonktastic> too used to other tools where I tend to pip/bundle/npm install packages.
20:56:07 <itsmonktastic> startling: thanks for the info!
20:56:38 <startling> It's too bad there's not a way to cabal init after-the-fact.
21:22:50 <startling> I'm having trouble with haskell-process for emacs. I get "
21:22:56 <startling> The program ghc version >=6.4 is required but it could not be found."
21:23:16 <startling> There's a ghc 7.8 in my PATH (and exec-path) and cabal repl works in every shell I've tried.
21:23:40 <Cale> GHC 6.4 is much much older than cabal repl :P
21:24:00 <Cale> (but I don't know when haskell-process was written)
21:24:25 <startling> Cale: it says >=6.4. :)
21:24:31 <Cale> It's probably the case that it's doing something awkward to detect the GHC version and not recognising the result?
21:24:45 <startling> (haskell-process works for other projects I've tried with this GHC, fwiw)
21:30:58 <dmwit> startling: Perhaps emacs does not have the PATH you think it has.
21:31:06 <dmwit> Is there a way to ask it?
21:33:04 <startling> dmwit: yeah, that's exec-path.
21:34:07 <dmwit> bummer
21:34:28 <dmwit> I guess my next move would be to try to stare at the source of haskell-process, then.
21:35:43 <startling> (call-process "ghc") works, too.
21:35:44 <startling> man.
21:35:56 <startling> Not sure what else could be going on.
21:36:00 * startling updates haskell-mode
21:38:59 * startling bisection sorts his ~/.emacs.d/init.el
21:44:03 <startling> hm, seems to work if I don't have (setq haskell-process-type 'cabal-repl)
21:44:09 * startling uses ghci for the time being
21:45:53 * bacon1989 narrates startling with Morgan Freeman's voice
21:57:54 <Hafydd> I have for some concrete types i,e a newtype T = T{ unT::(Array i e) }, but I wish to use Array operators like // on values of type T. Is there a better solution than (1) writing an Applicative instance and using liftA versions of the operators, or (2) writing things like (T . (// u) . unT), or (3) using a type synonym instead. If not, what are some reasons to prefer one of the preceding solutions?
21:58:49 <Hafydd> Er... I suppose that (1) would not work.
22:01:51 <c_wraith> Hafydd: You should be able to use GND and derive IArray
22:02:14 <c_wraith> unless there's a kind error there
22:02:42 <Hafydd> Ah, so I can,.
22:04:08 <Hafydd> ...or can I?
22:04:19 <c_wraith> like I said, you need to look out for kind errors
22:04:39 <Hafydd> I don't with T to be polymorphic in i or e.
22:04:43 <Hafydd> *wish
22:04:52 <c_wraith> IArray seems to be (* -> * -> *) -> * -> Constraint
22:05:40 <Hafydd> I suppose I _could_ write a parameterised version, and then define a type synonym with the parameters fixed, but that seems roundabout.
22:10:10 <startling> pipes question: I've got a Proxy X () () Text m () and a Proxy b b' Text () m r. I want to compose them to get a Server Text Text. How do I do it?
22:11:43 <zq> any recommendations on a dimensional units verification lib?
22:13:11 <pavonia> What is that?
22:13:59 <zq> type level dimensional analysis?
22:14:16 <zq> meter / sec, hertz, so forth
22:14:36 <joelteon> why does reads return a list instead of a Maybe
22:14:46 <startling> :t reads
22:14:47 <lambdabot> Read a => ReadS a
22:15:36 <geekosaur> joelteon: there are some cases where it can produce multiple parses and it's up to the caller to disambiguate. (it's not that common in my experience)
22:15:51 <joelteon> can you give me one example of multiple parses
22:16:12 <geekosaur> mm, I've seen it but don't have any examples off the top of my head
22:16:22 <startling> I guess the better question is: how do I turn a Producer into a Producer'?
22:17:28 <pavonia> zq: Could you give an example of what exactly you want to verify? (Sorry if I sound stupid, I've never heard of this topic)
22:18:05 <zq> pavonia: something like https://hackage.haskell.org/package/units, but that one runs only on ghc 7.8+
22:18:31 <zq> pavonia: basically a way to attach quantities (values) with their dimensional units as a type
22:18:52 <startling> pavonia, you can e.g. prevent addition of inches and meters
22:19:03 <startling> usually with phantom types.
22:19:21 <startling> you can also do fancy things with derived units.
22:19:48 <pavonia> Ah, I see
22:20:31 <startling> :t Tagged
22:20:32 <lambdabot> Not in scope: data constructor ‘Tagged’
22:20:35 <startling> aw.
22:20:43 <startling> :t Data.Tagged.Tagged
22:20:44 <lambdabot> b -> Data.Tagged.Tagged s b
22:20:52 <startling> ah, cool.
22:20:57 <startling> @let data Inch
22:20:59 <lambdabot>  Defined.
22:21:00 <startling> @let data Meter
22:21:01 <lambdabot>  Defined.
22:21:23 <zq> startling: any suggestions on what to use for 7.6.3?
22:21:34 <startling> > (Data.Tagged.Tagged 1 :: Data.Tagged.Tagged Inch Int) + (Data.Tagged.Tagged 2 :: Data.Tagged.Tagged Inch Int)
22:21:36 <lambdabot>  Not in scope: type constructor or class ‘Data.Tagged.Tagged’Not in scope: da...
22:22:02 <startling> aw.
22:22:11 <startling> @unlet
22:22:11 <lambdabot>  Define what?
22:25:37 <geekosaur> I think you wanted @undefine?
22:25:58 <shachaf> @redefine
22:25:59 <lambdabot> Maybe you meant: undefine define
22:26:03 <shachaf> Hm.
22:27:15 <startling> pipes stuff is so hard to google for.
22:28:06 <pavonia> Err, the units documentation seems somewhat broken "file:///Users/rae/Library/Haskell/ghc-7.7.20131217/lib/singletons-0.9.3/doc/html/Data-Singletons-Bool.html#t:Sing"
22:34:50 <ticktockman> Is there a way to unpack certain types in a polymorphic data type? Like "{-# RULES "Val/GLfloat" forall a. Val a = Val {-# UNPACK#-} a #-}data Val a = Val a"
22:35:19 <Axman6> in that example, a newtype would be equivalent to the underlying representation
22:35:31 <Axman6> underlying type I guess
22:35:31 <ticktockman> It was an example
22:35:42 <Axman6> in general not that I know of
22:35:57 <ticktockman> type families are the closest I can find
22:36:14 <Axman6> yeah that wouldn't be a terrible way to do it
22:47:48 <Wizek> Good Morning!
22:48:15 <zRecursive> noon
22:49:13 <Wizek> zRecursive: Well, according to UGT, it is only morning yet. :)
22:50:16 <zRecursive> UGT not UTC ?
22:50:36 <Wizek> zRecursive: UGT, indeed.
22:50:48 <zRecursive> what is G ?
22:50:57 <Wizek> Greeting
22:51:15 <Wizek> zRecursive: http://www.total-knowledge.com/~ilya/mips/ugt.html
22:51:22 <Wizek> Does GHC make an effort to find declarations that are calculatable at compile time, and replace them with constant values?
22:51:44 <Wizek> Example: `a = 1 + 2` or `b = "foo" ++ "bar"`
22:51:54 <dolio> Not really.
22:52:38 <Wizek> dolio: Does that mean it does a little bit?
22:52:53 <dolio> It's possible that it will do 1 + 2.
22:53:10 <dolio> But it doesn't take very complex expressions before it doesn't do anything.
22:53:31 <Wizek> hmm, I see.
22:53:36 <mgccl> It's amazingly how difficult it is to create a purely functional implementation of the aho-corasick automaton... I spend an hour just to realize I need tying the knot like crazy...
22:53:37 <dolio> I'm not even sure that it does 1 + 2, though.
22:54:15 <dolio> If you compiled through llvm, that would probably do stuff like 1 + 2 even if GHC doesn't.
22:54:22 <Wizek> dolio: Is that because of a design decision, or just noone needed that optimization before?
22:54:26 <dolio> Although that's not going to catch more complicated stuff, either.
22:54:35 <shachaf> Yes, but recursive functions can be a problem.
22:54:50 <dolio> Well, 1 + 2 => 3 at compile time is not an interesting optimization.
22:54:56 <dolio> And big cases are hard.
22:57:34 <Wizek> Sorry, broken pipe.
22:57:51 <Wizek> Could you repeat, if you said anything?
22:58:09 <dolio> I said that 1 + 2 => 3 isn't really that interesting an optimization, and the interesting cases are hard.
23:03:23 <Wizek> I was thinking about this the other day, because being a functional language, we use functions rather extensively, sometimes for meta-programming porpuses, too. Take `flip`, for example. It does nothing interesting computationally, but the argument order can mean a big difference for the programmer. I was wondering, wouldn't it make sense for GHC to squash functions together
23:03:23 <Wizek> and avoid runtime costs for such transformations? Yet another example: `f = flip $ \a b = a ++ b` -> `f = \b a = a ++ b`
23:04:14 <dolio> GHC will do some optimizations like that.
23:05:03 <dolio> But it won't do things like statically computing the value of 'product [1..10000]'.
23:05:15 <Wizek> Is it possible for me to see the optimised code? Possibly in haskell format, but C wouldn't be too bad eaither.
23:05:17 <dolio> Even though that's possible.
23:05:19 <c_wraith> I'm pretty sure the simplifier nearly always removes flip when fully saturated
23:05:28 <shachaf> ghc -ddump-simpl -O2 foo.hs
23:05:29 <c_wraith> Wizek: install the ghc-core program
23:05:34 <shachaf> Or that.
23:05:46 <shachaf> You can expect GHC to inline flip, in general, yes.
23:06:06 * hackagebot beamable 0.1.1.0 - Generic serializer/deserializer with compact representation  http://hackage.haskell.org/package/beamable-0.1.1.0 (JohnLato)
23:06:06 <c_wraith> ..  when it's fully saturated. :P
23:09:29 <Wizek> Is it possible that ghc-core is incompatible with either ghc-7.8.1 or cabal-install-1.18.0.3? Or my cabal is messed up, because it is telling me "Base.hsc:103:10: fatal error: 'pcre.h' file not found"
23:09:30 <shachaf> Hmm, I guess flip is defined as flip f x y = f y x, not flip f = \x y -> f y x
23:10:42 <c_wraith> Wizek: what os?  on debian-likes, I'd say you need to install the pcre -dev package
23:10:49 <startling> hm, c2hs thinks my string.h has a syntax error (on OS X). help?
23:11:12 <Wizek> Mac OSX 10.9.2
23:11:19 <c_wraith> Wizek: in general, that error means that it can't find the header file it needs for pcre
23:12:23 <ReinH> braces can be removed
23:12:28 <ReinH> woops
23:13:09 <c_wraith> Wizek: http://mac-dev-env.patrickbougie.com/pcre/  ?  Dunno, not too sure about how you're configuring your system.  But this is certainly one way to get it to work.
23:14:27 <haasn> “System.IO.Unsafe.Really.IMeanIt.reallyReallyAbsurdlyUnsafePerformIOShameOnYou” great name
23:16:50 <Wizek> Text/Regex/PCRE/Light.hs:196:19:
23:16:50 <Wizek>     Not in scope: ‘unsafePerformIO’
23:16:52 <SrPx> Thoughts on mathematica/wolframlanguage?
23:17:07 <SrPx> Is that language similar to Haskell?
23:17:26 <Wizek> while compiling Compiling Text.Regex.PCRE.Light
23:17:47 <c_wraith> Wizek: oh, that one's the result of PCRE ignoring deprecation warnings for a while
23:17:59 <c_wraith> Wizek: it has been patched, but not released, I guess
23:18:26 <c_wraith> Wizek: for now, just go with the other approach, as shachaf suggested. :)
23:18:55 <shachaf> Uh oh.
23:19:02 <shachaf> I'm supposed to take care of that or something.
23:19:04 <startling> carter: I'm getting issues with c2hs because of OS X availability stuff. Google suggests you might know how to fix it?
23:19:04 <shachaf> Sigh.
23:19:23 <carter> startling: please be more concrete
23:19:30 <carter> and also i don't use c2hs
23:19:40 <carter> i can probably still cargo cult
23:19:40 <startling> carter: I'm trying to use a package that relies on it, alas.
23:19:49 <carter> startling: be less vague
23:19:53 <carter> did you update  c2hs?
23:19:59 <carter> is it old or new
23:20:01 <carter> what ghc version
23:20:05 <carter> what cabal version
23:20:10 <carter> what language-c version
23:20:13 <carter> what os version
23:20:16 <carter> what ghc --version
23:20:18 <carter> what gcc --version
23:20:25 <carter> what clang --version
23:20:27 <startling> carter: I installed the latest one on hackage. GHC 7.8. Error is "/usr/include/string.h:131: (column 90) [ERROR]  >>> Syntax error ! The symbol `=' does not fit here." when I try to install libssh2
23:20:28 <carter> what ghc --info
23:20:41 <carter> latest which of what
23:20:49 <carter> compile a gist with all the infos
23:20:51 <carter> of all the things
23:20:55 <carter> you're telling me pronounce
23:20:59 <carter> *pronounce
23:21:02 <carter> *pronouns
23:21:03 <startling> The latest c2hs, but also the latest everything else.
23:21:05 <carter> i need nouns
23:21:10 <carter> don't care
23:21:12 <carter> gist it all
23:21:15 <ticktockman> I have seen alot of complaints with 7.8 on Mac OSX
23:21:16 <carter> so i can read it
23:21:19 <startling> Sure.
23:21:25 <carter> ticktockman: thats because people use brew and shouldnt
23:21:28 <carter> and don't update their cabal config
23:21:36 <carter> and also clang
23:22:05 <ticktockman> carter: Yeah, clang seems to be mentioned in many of them
23:22:11 <carter> ticktockman: solution, use gcc
23:22:26 <carter> oh wait, that rquires using my unofficial build :)
23:22:30 <Wizek> Yay, managed to install!
23:23:29 <startling> carter: https://gist.github.com/startling/11027371
23:23:46 <startling> I should give you my string.h too
23:23:51 <c_wraith> Wizek: nice
23:24:00 <carter> startling: you're using non release ghc
23:24:11 <startling> carter, oh, forgot about that.
23:24:22 <carter> hence my pendatry
23:24:32 <startling> carter: I wasn't arguing!
23:24:37 <carter> :)
23:24:39 <carter> i wasnt either
23:24:43 <carter> i'm just pedantic
23:24:55 <startling> carter: I suppose you'll say I should install from the haskell.org/ghc?
23:25:01 <carter> what os
23:25:15 <startling> Mavericks
23:25:28 <carter> sure
23:25:37 <carter> use the official build
23:25:43 <carter> my build is cool and all
23:25:55 <carter> but.... i don't need to play support even MORE
23:25:55 <carter> :)
23:26:27 <startling> you have a build? sold.
23:27:14 <carter> it is 20% faster on average and plays nice with gcc or clang
23:27:23 <carter> because the gc is gcc built rather than clang
23:27:27 <ticktockman> 20% faster!?
23:27:43 <carter> ticktockman: thread local storage is slower on mac
23:27:50 <carter> and clang builds of the RTS need to use that
23:27:54 <carter> isntead of global registers
23:27:59 <ticktockman> carter: Oh, on mac
23:28:20 <carter> yes
23:28:53 <startling> carter: btw, we added 7.6.3 and 7.8.2 this week, and I'm told there's now enough disk space to build ghc (but remain skeptical)
23:29:12 <carter> hahahaha
23:29:30 <carter> i'll believe it when ./validate doesn't get killed :)
23:29:42 <startling> carter, do you have a repo I can try?
23:35:54 <carter> cabal update ; cabal install alex happy ; git clone -b ghc-7.8 git://git.haskell.org/ghc.git ; ./sync-all get -b ghc-7.8   ; ./validate
23:36:11 <carter> shoudl work if you ahve 7.6 or 7.8 handy
23:36:33 <carter> the real stress test would be ./validate --slow
23:37:14 <carter> startling: sound like fun?
23:39:12 <startling> you know it. :)
23:39:38 <carter> startling: i think i gave you teh "one liner"
23:39:41 <carter> oh
23:39:47 <carter> i forget the cd ./ghc
23:39:48 <carter> step
23:39:52 <startling> heh
23:44:10 <startling> carter, same deal with the 7.8 release and a new c2hs
23:44:18 <carter> startling: stop using clang
23:44:27 <startling> carter, how do I do that?
23:44:36 <carter> 1) what gcc do you have installed?
23:44:47 <startling> carter, the fake one
23:44:54 <carter> also do you ahve the ssl lib actually installed?
23:44:56 <carter> like actually
23:45:00 <startling> libssh2? yes.
23:45:41 <carter> in path?
23:46:23 <carter> how did you isntall it?
23:46:23 <startling> carter, pkg-config knows where it is
23:46:26 <startling> carter, brew
23:46:30 <carter> did you brew link?
23:46:40 <carter> whats the brew install name
23:46:44 <carter> and whats the haskell package
23:46:55 <startling> carter, there are libs where pkgconfig says there are, yes.
23:46:58 <carter> no
23:47:00 <carter> thats not what i ask
23:47:03 <startling> carter: haskell package is also called libssh2
23:47:10 <carter> whats the brew lib named
23:47:15 <startling> libssh2
23:47:24 <carter> try "brew link libssh2"
23:47:31 <startling> Warning: Already linked: /usr/local/Cellar/libssh2/1.4.3_1
23:47:34 <carter> ok cool
23:49:06 <carter> startling: https://gist.github.com/cartazio/11028065
23:49:11 <carter> i think its just not maintained period
23:49:29 <startling> heh.
23:49:34 <startling> that's farther than I got, anyhow !
23:49:41 <carter> point bein
23:49:46 <carter> patch the lib
23:49:53 <carter> i bet its bitwrotten
23:49:54 <carter> ooooo
23:49:59 <carter> do you have old alex and happy
23:50:18 <startling> uhh, I have them leftover from my 7.8 rc
23:50:31 <carter> ok cool
23:50:32 <carter> well
23:50:37 <startling> unless make install'ing ghc installed new ones
23:50:43 <carter> MAGIC
23:50:45 <carter> idk
23:50:46 <carter> i'mtired
23:51:03 <startling> anyway the second thing sounds easier to fix than the first thing, so thanks!
23:51:06 <startling> I'll try a new alex and ahppy
23:51:10 * hackagebot route-planning 0.0.3 - A library and utilities for creating a route  http://hackage.haskell.org/package/route-planning-0.0.3 (TonyMorris)
23:51:14 <carter> :P
23:52:14 <startling> heh, same error
23:52:18 <startling> (the string.h one)
23:53:47 <startling> ah well. thanks anyway!
