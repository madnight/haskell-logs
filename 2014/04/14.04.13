00:10:15 * hackagebot tianbar 0.4.0.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.4.0.0 (AlexeyKotlyarov)
00:10:15 * hackagebot tianbar 0.4.0.1 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.4.0.1 (AlexeyKotlyarov)
00:21:47 --- mode: holmes.freenode.net set +o ChanServ
00:46:27 <notadog> I need to convert a String to to a "HostAddress", which according to System.BSD docs is just an alias for Word32. if function x has type x :: HostAddress -> IO(), do I need to do `x (read "192.168.1.1")`? that isn't working so far....
00:47:08 <tikhon> that wouldn't work if HostAddress is just a synonym
00:47:22 <tikhon> check for a String -> HostAddress function somewhere in the package
00:48:30 <shachaf> Or perhaps HostAddress isn't really the type you want.
00:48:39 <notadog> by alias i mean in the docs it has `type HostAddress = Word32`
00:49:03 <tikhon> notadog: yeah, that means it uses all the same instances as Word32, which includes Read
00:49:13 <tikhon> so that fundamentally can't work
00:49:21 <startling> notadog: (Word32 is just a 32-bit unsigned integer, if that wasn't clear)
00:49:39 <Hermit> I'm having an error I have no clue about when building language-c (I need it for c2hs) http://lpaste.net/8744657159591034880  Any pointer to what may be the problem is welcome
00:50:20 <notadog> startling: so "Word32" isn't actually a word, its a number. Cool.
00:50:38 <startling> notadog: heh. :)
00:50:47 <shachaf> It's a machine word.
00:50:59 <notadog> yeah.
00:51:17 <Hermit> (instead of the moronic dword, qword, etc notation)
00:51:21 <shachaf> Anyway, what I said.
00:51:32 <startling> Hermit, I bet you're on 7.8? Lots of libraries aren't 7.8-compatible yet.
00:51:38 <tikhon> Hermit: oh boy did that terminology confuse me when I was starting out programming!
00:51:46 <Hermit> startling: worse yet, 7.9 git
00:52:20 <Hermit> tikhon: yeah, I never got used to it, I always keep forgetting what size was each
00:52:24 <startling> Hermit: heh. it looks like the type of some function has changed from Bool to Int#.
00:52:39 <startling> (==#), I guess.
00:52:51 <Hermit> startling: yeah but it seems to be in code generated by alex (the lexer). And I don't see the definition of >=# or ==# anywhere
00:52:53 <MP2E> Hermit: delete dist before building
00:52:55 <Hermit> it's puzzling me
00:52:59 <MP2E> there's a residual dist generated from an old GHC
00:53:12 <MP2E> it has TH generated already
00:53:15 <shachaf> ==# switching to Int# makes me kind of sad.
00:53:20 <MP2E> and it's not compatible with GHC-7.8
00:53:25 <shachaf> I vaguely remember the Trac thread about it.
00:53:39 <MP2E> I added rm -rf dist/ to the top of my ebuild for language-c and everything works fine now
00:53:42 <MP2E> latest git and 7.8
00:53:50 <Hermit> MP2E: I see, so I should get rid of alex and recompile (that and any other suspicios exe)
00:54:04 <startling> Hermit: they're the ones from GHC.Prim, probably
00:54:06 <MP2E> nah just download language-c's source as a tarball
00:54:11 <MP2E> delete the folder dist in it
00:54:13 <MP2E> then type cabal install
00:54:16 <MP2E> you should be good to go
00:54:33 <startling> shachaf: it is kind of strange.
00:54:43 <startling> I feel like there should at least be a new primitive Bool type.
00:55:15 <Hermit> MP2E: it seems to be working, now it complains about happy instead. Rebuilding... hope this solves it
00:55:56 <tikhon> I think the Int# thing is an interesting illustration of how the Haskell community is a bit divided
00:56:12 <tikhon> maybe into "high-level" and "low-level" people, although those labels don't feel accurate
00:56:20 <shachaf> There "should" be unboxed sums, but that's not happening in the near future.
00:56:27 <tikhon> but there's a definite division in philosophies
00:57:06 <shachaf> Yes.
00:57:14 <tikhon> Well, having a Bool# that's just a newtype (well, the moral equivalent of a newtype) over Int# would make sense to me
00:57:27 <Hermit> MP2E: worked!!! thank you very much. I was going nuts here trying to fix it
00:57:45 <MP2E> No problem :P Pretty sure it was a simple packaging mistake, but it was one that had me scratching my head for an hour or two...
00:57:46 <Hermit> I agree with the Bool# newtype of Int#
00:58:15 <shachaf> It would be an improvement, maybe, but hardly an optimal state.
00:58:23 <shachaf> Well, as long as we're willing to change it back once GHC is better.
00:58:23 <tikhon> oh yes
00:58:26 <startling> tikhon: yeah, that's how I feel too.
00:58:31 <tikhon> but optimality is, umm, far away?
00:58:38 <startling> I guess unboxed sums is the ideal solution.
00:58:47 <tikhon> how would unboxed sums work?
00:58:49 <Hermit> MP2E: an hour or two, given you knew what you were doing. I was cluelessly trying to track the change down to the types of who knows what to fix it
00:59:16 <startling> tikhon, same way tagged unions work in C, I guess.
00:59:26 <tikhon> I talked to Conal about his Haskell-to-hardware project a while ago, and representing sums was still a big open question
00:59:54 <notadog> I am trying to create a connection, and when I the code runs I get "prelude.read: no parse". the code is connect sock $ SockAddrInet port (read "127.0.0.1").
00:59:58 <tikhon> right, a struct containing a "normal" union
01:00:11 <shachaf> Here's an example: https://github.com/ghc/packages-base/blob/master/GHC/List.lhs#L113
01:00:14 <notadog> I think I a word. I meant "and when I run the code"
01:00:21 <startling> notadog, a Word32?
01:00:25 <startling> :<
01:00:26 <tikhon> notadog: what type are you trying to read *to*?
01:00:33 <sipa> :t SockAddrInet
01:00:34 <shachaf> Today, you can just write length on Int, without even thinking about Int# at all, and you end up with the same code.
01:00:35 <lambdabot> Not in scope: data constructor ‘SockAddrInet’
01:00:37 <tikhon> because if it's still just an alias for Word32
01:00:40 <notadog> Yeah, i am trying to read the string to a Word32. Am i missing something?
01:00:42 <startling> notadog, reading an IP string to a Word32 will not work
01:00:46 <shachaf> Due to fancy CPR optimization and what not.
01:01:01 <notadog> How come startling?
01:01:07 <tikhon> remember that Word32 is a very general number type
01:01:13 <corgifex> notadog: "127.0.0.1" is not valid syntax for a Word32
01:01:14 <startling> notadog, because that is not how Read for WOrd32 is defined.
01:01:16 <tikhon> so its read instance will take in normal integers, but not IP addresses
01:01:20 <startling> > read "2" :: Word32
01:01:21 <lambdabot>  2
01:01:24 <corgifex> that doesn't even look like a number
01:01:29 <startling> > read "127.0.0.1" :: Word32
01:01:30 <lambdabot>  *Exception: Prelude.read: no parse
01:01:43 <notadog> so I have to find out how ips are represented as word32's ?
01:01:45 <shachaf> notadog: You should look at the documentation of your module more carefully.
01:01:45 <corgifex> @hoogle connectTo
01:01:45 <lambdabot> Network connectTo :: HostName -> PortID -> IO Handle
01:01:45 <lambdabot> Network.CGI.Compat connectToCGIScript :: String -> PortID -> IO ()
01:01:49 <startling> notadog: yes, exactly.
01:02:07 <shachaf> There are functions that do what you want.
01:02:13 <notadog> corgifex: i need to connect via a configurable ip
01:02:16 <shachaf> But a good first step might be to figure out if it's what you really want.
01:02:32 <shachaf> Should GHC.List rely on this optimization and not explicitly use Int#?
01:02:55 <shachaf> I say yes, that's an improvement.
01:03:46 <corgifex> notadog: connectTo does that
01:04:14 <startling> shachaf, GHC.List uses Int#? :/
01:04:26 <shachaf> startling: See the link above.
01:04:40 <shachaf> I imagine that it made sense at the time, pre-CPR analysis and so on. But I don't actually know the history.
01:04:45 * shachaf gets off train.
01:04:47 <startling> ah, right.
01:05:03 <startling> shachaf, the GHC hate train?
01:05:16 <notadog> thanks corgifex:, I should learn to rtfm :)
01:06:00 <tikhon> oh neat, there are rewrite rules for lists in there
01:06:47 <corgifex> notadog: see also inet_addr, conveniently undocumented
01:13:16 <notadog> corgifex: undocumented functions are the most fun! if you play dwarf fortress you know what i mean.... ty :)
01:14:32 <corgifex> experts only: connect sock $ SockAddrInet port (unsafeCoerce "127.0.01")
01:15:22 <notadog> corgifex: yeah, i would prefer to stay away from unsafe. ty :)
01:15:29 <shiona> 12.700..1
01:16:26 <corgifex> ah, you're one of the experts :-)
01:19:25 <notadog> corgifex :P
01:21:34 <notadog> is this just because I am debugging very quickly and have reached a system imposed limit? ezchat: socket: resource exhausted (Too many open files)
01:21:36 <notadog> ezchat: accept: resource exhausted (Too many open files)
01:22:12 <notadog> or something else? I am closing sockets(well, I am closing the handle that I convert the socket to)
01:23:36 <corgifex> notadog: do you have strace?
01:23:36 <notadog> oh god what do i do? first time stack space overflow......
01:23:57 <notadog> corgifex: I actually wasn't closing a socket that i wasn't even using :P
01:24:11 * notadog is back in 5
01:41:26 <k_bx> Hi everybody! I wanted to try out new OverloadedLists extension, and I get this https://gist.github.com/k-bx/10574806
01:41:36 <k_bx> Can anyone help me where am I wrong?
01:45:07 <corgifex> k_bx: do you get a different error with let m :: Map Text Int; m = [("foo", 1), ("bar", 2)] ?
01:45:27 * hackagebot tianbar 0.4.1.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.4.1.0 (AlexeyKotlyarov)
01:46:00 <k_bx> corgifex: nope, same one
01:46:01 <Hermit> corgifex: nope
01:46:18 <identity> oh man. I didn't know about overloadedlists.
01:46:20 <identity> That's nice.
01:46:26 <k_bx> I removed OverloadedStrings and used String instead of Text -- same error
01:46:53 <k_bx> identity: there's also ViewPatterns I want to check out https://www.haskell.org/ghc/docs/7.8.1/html/users_guide/type-class-extensions.html#overloaded-lists
01:47:08 <k_bx> (to deconstruct maps/sets)
01:47:52 <shachaf> Is it really exactly the same error?
01:48:11 <shachaf> What if you use Char Bool instead or something like that?
01:48:35 <shachaf> I would suggest first making it work with fromList/fromListN manually and then trying for the extension.
01:48:47 <identity> k_bx: I had seen viewpatterns but had a hard time understanding how they worked. I'll have to take a better look
01:48:49 <shachaf> I mean Map Char Bool.
01:48:58 <identity> Is OverloadedLists 7.8.x?
01:49:11 <k_bx> identity: yes
01:49:21 <identity> ah. I'll have to upgrade then
01:49:34 <identity> but that extension alone makes it worth it
01:49:49 <k_bx> I'm pushing docker image with 7.8.2
01:50:46 <identity> ah, cool
01:51:48 <tikhon> ViewPatterns basically allow you to apply a funcion to something before matching on it
01:52:48 <corgifex> > case 4 of (even -> True) -> "why"
01:52:49 <lambdabot>  "why"
01:52:57 <tikhon> they're very useful, especially for working with abstract types
01:53:37 <corgifex> > Seq.fromList ""
01:53:39 <lambdabot>  fromList ""
01:54:11 <corgifex> > case Seq.fromList [1 .. 10] of (viewl -> x :< xs) -> (x, xs)
01:54:13 <lambdabot>  Not in scope: ‘viewl’
01:54:13 <lambdabot>  Perhaps you meant one of these:
01:54:13 <lambdabot>    ‘Seq.viewl’ (imported from Data.Sequence),
01:54:13 <lambdabot>    ‘view’ (imported from Control.Lens),
01:54:13 <lambdabot>    ‘views’ (imported from Control.Lens)Not in scope: data constructor ‘:<’
01:54:19 <corgifex> > case Seq.fromList [1 .. 10] of (Seq.viewl -> x :< xs) -> (x, xs)
01:54:20 <lambdabot>  Not in scope: data constructor ‘:<’
01:54:20 <lambdabot>  Perhaps you meant one of these:
01:54:21 <lambdabot>    ‘Seq.:<’ (imported from Data.Sequence),
01:54:21 <lambdabot>    ‘:+’ (imported from Data.Complex),
01:54:23 <lambdabot>    ‘Seq.:>’ (imported from Data.Sequence)
01:54:25 <corgifex> god dammit
01:54:47 <corgifex> oh well, I tried
01:55:14 <shachaf> Trying in /msg lambdabot first is often a good idea. :-)
01:56:04 <corgifex> > case Seq.fromList [1 .. 10] of (Seq.viewl -> x Seq.:< xs) -> (x, xs)
01:56:05 <lambdabot>  (1,fromList [2,3,4,5,6,7,8,9,10])
01:56:07 <tikhon> eww, qualified operators
01:56:24 <corgifex> > case Seq.fromList [1 .. 10] of (Seq.viewr -> xs Seq.:> x) -> (x, xs)
01:56:26 <lambdabot>  (10,fromList [1,2,3,4,5,6,7,8,9])
01:56:51 <aloiscochard> is there some helper package or something to help using Socket with haskell-machines?
01:57:06 <Hermit> k_bx: fixed it, let me push a gist
01:58:13 <aloiscochard> oh 7.8.2 is out!
02:00:27 <tibbe> I’m having some conceptual understanding issues with ImpredicatveTypes: http://lpaste.net/102652
02:01:11 <tibbe> I’m trying to write a function that projects some of the members of a data type out into a list. All members Are of type HashMap Text a, for some ‘a’.
02:01:41 <shachaf> ImpredicativeTypes don't really work, do they?
02:01:53 <Hermit> k_bx: shit, first time using gists, hang on a sec
02:02:04 <tibbe> shachaf: could be, I probably have a design problem
02:02:12 <shachaf> Also, that looks like an odd type.
02:02:12 <tibbe> shachaf: I just don’t know the right way to do this
02:02:45 <shachaf> What's the goal of the type "forall a. MetricMaps -> M.HashMap T.Text a"?
02:03:06 <k_bx> Hermit: no problem
02:03:12 <curious_troll> Is there any free haskell book in info format ?
02:03:15 <tibbe> shachaf: I want to project every map from the MetricMaps data type into a list and then use M.member on each of them
02:03:21 <shachaf> If you give me something of that type, it means I can choose anything for a -- say, Double -- and give you a MetricMaps, and you'll give me a Map from Text to Double.
02:03:26 <shachaf> Is that your intent?
02:03:34 <tibbe> shachaf: probably not ^^
02:03:45 <shachaf> Because it seems like that Map would have to be empty, since you don't know anything about what a is.
02:03:48 <shachaf> OK.
02:04:05 <tibbe> shachaf: I’m actually only interested in the keys, so not knowing ‘a’ is OK
02:04:40 <Hermit> k_bx: https://gist.github.com/Arm/10575474
02:04:47 <shachaf> OK, but the values would all have to be "undefined" this way.
02:04:53 <c_wraith> tibbe: impredicative types aren't really that different from rank n types.  You're allowed to put a forall inside any type constructor, instead of just inside of ->
02:05:12 <shachaf> c_wraith: Well, except that they don't really work in GHC. :-)
02:05:18 <c_wraith> shachaf: minor detail
02:05:37 <shachaf> Anyway, I think maybe you're going for an existential.
02:05:41 <corgifex> if you only care about keys ... Set?
02:05:45 <Hermit> k_bx: ah, forgot to update out.txt too
02:05:48 <shachaf> (Which also doesn't work in GHC.)
02:06:02 <tibbe> shachaf: so I have to create a data type just for the purpose of wrapping up the functions?
02:06:20 <shachaf> Well, a type might be overkill.
02:06:22 <tibbe> corgifex: I only care about the key in this particular function, I care about the values elsewhere
02:06:47 <shachaf> Oh, I missed some of the type definitions at the top.
02:06:57 <shachaf> Now what you're trying to do is more clear.
02:07:04 <k_bx> Hermit: that works!
02:07:47 <tibbe> shachaf: there are three call sites, each mentioning two different fields
02:08:21 <Hermit> forcing a HEAD push on a gist doesn't work, right?
02:08:29 <Hermit> (like it would on a normal repo)
02:08:38 <shachaf> So the closest approximation to what you're trying to do would probably be defining an existential type and then passing values of that type in the list.
02:08:54 <tibbe> shachaf: right, so I need a wrapper
02:08:58 <shachaf> It's very probably not the right solution, but it would work.
02:09:17 <tibbe> shachaf: data T a = C forall a. MetricMaps -> M.HashMap T.Text a
02:09:17 <shachaf> It would look like this: data T = forall a. T (MetricMaps -> M.HashMap T.Text a)
02:09:20 <tibbe> right
02:09:27 <Hermit> k_bx: ok, I did the evil stuff I wanted to do, refresh the gist
02:09:29 <shachaf> inUseBy [T userGauges, T userLabels]
02:09:40 <Hermit> aww... nevermind
02:10:01 <k_bx> Hermit: ok if I post link to your gist in haskell-cafe to update everyone on your fix?
02:10:02 <Hermit> I'm starting to like git so much better than hg
02:10:04 <shachaf> However, once you've given up on having [userGauges, userLabels] be the list, you don't really need to use a *constructor*.
02:10:19 <Hermit> k_bx: sure, it'd be a honor
02:10:27 <Hermit> ;¬)
02:10:44 <shachaf> I.e. if you can come up with a function foo such that you can write inUseBy [foo userGauges, foo userLabels], that'd be good enough.
02:10:53 <tikhon> Hermit: yeah, I've also been liking Git more. For whatever reason, I've had far more problems with hg.
02:11:08 <k_bx> Done.
02:11:09 <tikhon> I've heard good things about Darcs but haven't had the chance to use it yet :(
02:11:50 <Hermit> i've had a brief experience with darcs couple of hours ago, and it's slow as fuck, maybe it was this particular version?
02:12:11 <tikhon> no idea
02:12:22 <tikhon> I've mostly heard people praising its interface and general model
02:12:35 <tikhon> except apparently it sometimes takes exponential time :þ
02:12:56 <Hermit> surely it's cleaner and more consistent than git and hg, but the efficiency... that's a different story
02:12:58 <MP2E> Personally, any arguments I've heard that put darcs as better than git misunderstand the features and point of the features
02:13:17 <tibbe> shachaf: get type error, see bottom: http://lpaste.net/102652
02:13:20 <MP2E> I've learned both and while darcs was a step forward towards DVCS, imo it is a primitive one
02:13:21 <shachaf> Hmm, a simple foo might be something like: foo :: (MetricMaps -> HashMap Text a) -> MetricMaps -> Text -> Bool; foo getter emaps name = M.member name (getter maps)
02:13:24 <MP2E> somewhere between svn and hg
02:13:43 <shachaf> tibbe: I'm not recommending the existential approach. :-(
02:14:01 <tibbe> shachaf: ok, let me try to think about your above example
02:14:13 <shachaf> tibbe: But you have to use the constructor, as I mentioned above. inUseBy [Getter useGauges, Getter userLabels]
02:14:16 <tibbe> shachaf: the tricky part is that ‘maps’ is not in scope at the call site
02:14:39 <tibbe> shachaf: I did use the constructor, the type error is in the definition of inUseBy
02:14:54 <shachaf> Oh, the "call site" is just an example.
02:15:14 <tibbe> shachaf: yes, let me give you the real code
02:15:14 <shachaf> Yes, things get a little more complicated with existentials.
02:15:28 <shachaf> The type variable escapes, like it says.
02:16:05 <shachaf> You can use something like map (\(Getter g) -> M.member name (g maps))
02:16:28 <tibbe> shachaf: see bottom of http://lpaste.net/102652
02:16:33 <shachaf> Otherwise you sort of run into the same issue.
02:16:52 <shachaf> I think your small example has enough detail.
02:17:11 <tibbe> ok
02:17:27 <tibbe> the context is more in case the call site really needs changing
02:17:46 <tibbe> and also to see why the call site looks a bit awkward (it’s because we need to get the value out of an IORef some time later)
02:18:17 <shachaf> Do you see what I mean about moving the M.member inside the map?
02:18:56 <shachaf> Otherwise, after the map, you end up with a list like [exists a. M.HashMap T.Text a], which GHC can't represent (which was the original problem).
02:20:32 * hackagebot vcswrapper 0.0.4 - Wrapper for source code management systems  http://hackage.haskell.org/package/vcswrapper-0.0.4 (StephanFortelny)
02:20:34 * hackagebot vcsgui 0.0.4 - GUI library for source code management systems  http://hackage.haskell.org/package/vcsgui-0.0.4 (StephanFortelny)
02:20:50 <tibbe> shachaf: yeah, it compiles now using existentials
02:21:22 <shachaf> OK. So at least we have a working solution.
02:21:29 <tibbe> shachaf: I wonder if GHC could have anonymous wrappers, created by expressions such as [forall a. …]
02:21:34 <tibbe> shachaf: yes, thanks
02:21:35 <shachaf> But existentials aren't really necessary.
02:22:05 <Saizan> tibbe: stop using forall for existentials :)
02:22:11 <shachaf> Saizan++
02:22:23 <tibbe> shachaf: so what’s a better solution?
02:22:41 --- mode: holmes.freenode.net set +o ChanServ
02:22:46 <shachaf> All the existential is doing is wrapping the (MetricMaps -> HashMap Text a) function in a particular way, which you're always unwrapping by passing in a MetricMaps and then looking up a name in the HashMap.
02:23:27 <shachaf> So you could write a function like foo :: (MetricMaps -> HashMap Text a) -> MetricMaps -> Text -> Bool; foo getter maps name = M.member name (getter maps) as mentioned above.
02:23:30 <tibbe> shachaf: I was hoping that by giving you the whole context you’d see why this was neccesary
02:24:08 <shachaf> Which turns a function like yours into a function that takes a MetricMaps and a name and returns a Bool, which is what you're really using in the end.
02:24:29 <shachaf> I don't know whether it's actually a better solution. It doesn't use existentials, at any rate.
02:24:53 <shachaf> I didn't read the whole context so far, it's a lot of code. :-)
02:24:55 <notadog> I am trying to convert a string to a "PortNumber" and failing. GHCI tells me that it is defined in Network.Socket.Types as newtype PortNumber = PortNum Word16, I am currently stuck trying to use read to coerce it into a Word16, but then ghc complains that It wants a portnumber instead. How can I make it a port number?
02:25:28 <shachaf> I can have a look, maybe I'm missing something from the small example.
02:25:47 <tibbe> shachaf: the desire to use a function that takes a list is the getRef function, that I’m trying to keep generic. It look for a key in one particular map at the same time that it ensures it doesn’t exist in any other map
02:26:41 <tibbe> shachaf: I could try to change the call site that uses inUseBy to be ( \ maps -> … userCounters maps … && … userGauges maps …)
02:26:51 <gleber> How can I output result of expanding of template haskell code?
02:26:51 <tibbe> shachaf: and just give up on the list approach
02:26:58 <tibbe> shachaf: I will probably do that
02:27:10 <Saizan> notadog: PortNum :: Word16 -> PortNumber, but fromIntegral is probably better
02:27:10 <gleber> 'ghc -ddump-slices file.hs' doesn't work...
02:28:03 <shachaf> tibbe: In the end GHC can't *really* do the thing you want with the list approach, which is first-class existentials.
02:28:12 <tibbe> right
02:28:13 <Saizan> gleber: -ddump-splices
02:28:22 <tibbe> shachaf: I think the wrapper is not worth it
02:28:34 <gleber> Saizan: lol!
02:28:38 <gleber> stupid me
02:28:39 <gleber> thanks
02:28:57 <notadog> thanks Saizan, did you know that from previous networking experience or easily found it somehow?
02:29:12 <shachaf> I agree that the explicit existential type is not worth it.
02:29:29 <Saizan> notadog: http://hackage.haskell.org/package/network-2.2.1.7/docs/Network-Socket.html#t:PortNumber <- here's all the info on PortNumber
02:29:45 <hvr> can something like  ((,,) <$> (+1) <*> (+10) <*> (+314))  be generalized to a list, e.g. [(+1),(+10),(+314)] while exploiting the Applicative instance of ((->) r) ?
02:29:49 <shachaf> I can't really give you a satisfying answer. :-(
02:30:00 <Saizan> notadog: i guess it's more about familiarty with haskell in general, so you can tell the type of the constructor from the datatype definition, etc..
02:30:00 <notadog> Saizan: thanks, I am still getting used to understanding hackage docs, as I am still learning haskell. I thought functions are supposed to start with a lowercase letter though?
02:30:08 <notadog> how is "PortNum" valid?
02:30:15 <notadog> Oh is that a data accessor
02:30:18 <Saizan> notadog: data constructor
02:31:04 <Hermit> notadog: can be used to access the inner value through pattern matching, but it's a constructor
02:32:11 <Saizan> shachaf: what's so not worth it about an existential wrapper? i guess having sigma types would be nicer but sometimes you're just putting the type annotation somewhere else
02:32:22 <notadog> Hmmm ok, thanks Saizan and Hermit. It is a lot to take in at times. Was haskell as a first programming language a stupid choice?
02:32:23 <hvr> nevermind, found it: sequenceA
02:32:25 <shachaf> It's funny that people are making a big fuss over OverloadedLists but in the end it doesn't let you overload (:) and [] in such a way that you can express lists that you otherwise couldn't.
02:32:48 <Hermit> notadog: a brutal one I'd say...
02:32:53 <Saizan> notadog: nah, it's a great choice, but it does have a bit of a learning curve
02:33:09 <ion> Many languages have a bit of a learning curve.
02:35:00 <notadog> Hermit Saizan hmmmm. I have enjoyed it so far, only occasionally do I feel like pulling my hair out. I have a feeling I am kinda treating it too much as an imperative language, I am often in IO monad, but that is because I am creaeting desktop apps that I have use for.
02:35:21 <erisco> is there a variant of Haskell or a language like Haskell which has explicit memory management?
02:35:41 <Hermit> notadog: but if you overcome the learning curve, you'll be able to reach higher heights easily since you don't have your mind structured around other paradigms
02:36:35 <Hermit> notadog: switching to haskell has been a major source of grief for me, but I keep going, I know there must be something beyond this
02:36:59 <Hermit> notadog: I had to restructure the way I think about programs radically
02:37:19 <corgifex> my god, it's full of zygohistomorphic prepromorphisms
02:37:41 <Saizan> notadog: well, i do think that jumping into IO from the start is probably not the best way to get familiar with the language, but i guess if that's where your motivation is it can't be helped
02:38:12 <notadog> Hermit: that was close to my thinking, if I can learn Haskell as a first language, and therefore think differently to most programmers(and take that with me when learning other languages), that might make me more valuable to an employer.
02:38:18 * Hermit sometimes questions himself if it's really worth it, the advantages vs the insane complexity
02:38:32 <ion> The insane complexity?
02:38:51 <notadog> Saizan, possibly. Is it hard to break into using haskell for serverside stuff?
02:39:53 <erisco> complexity is a good thing. complication is a bad thing (for particular definitions of complex and complicated)
02:40:45 <ion> Insane anything is not a good thing, but i have yet to find insane anything in Haskell. Some historical baggage is not great, but not insane either. :-P
02:40:55 <Saizan> notadog: when i tried that i was already familiar with how datatypes and typeclasses work, so i wouldn't know how it is for a novice
02:41:26 <Hermit> ion: Take any non trivial library... the implementations are mind-blowing
02:41:34 <ion> Well, okay, this one is insane. http://hackage.haskell.org/package/gutenberg-fibonaccis-1.1.0/docs/src/Algorithm-Gutenberg-Fibonaccis.html
02:42:13 <ion> I especially like “lastFib”.
02:42:49 <Saizan> actually, haskell is the first language i could look at the implementation of libs and feel like i knew what was happening
02:43:15 <Saizan> but that might be saying more about me than haskell
02:44:03 <erisco> when does allocation need to happen in Haskell? my two thoughts are partial application and data constructors
02:44:18 <erisco> (heap allocation that is)
02:46:14 <srhb> notadog: I went into serverside stuff after reading LYAH -- it's great. :)
02:46:17 <erisco> well there is thunking ...
02:46:31 <erisco> assume everything is strict... what allocation is left?
02:46:59 <corgifex> do you count lambda as a constructor?
02:47:17 <erisco> corgifex, no
02:47:26 <corgifex> then lambda
02:48:04 <corgifex> map (\i -> \x -> x + i) [1 .. 10]
02:48:52 <notadog> ty srhb :) I learned with lyah and realworldhaskell.
02:49:12 <erisco> ah well that is partial application
02:49:12 <srhb> notadog: :)
02:49:36 <erisco> the lambda itself is an unnamed function, so I can just give it a random name and have the same thing
02:49:52 <hvr> notadog: the next generation will use those 2 books *and* also  Simon's Parallel&ConcurrentProgramming  :)
02:50:02 <corgifex> erisco: what about closures in general?
02:50:22 <erisco> the closed variables may be stack allocatable
02:50:45 <erisco> not sure in all cases... but is something to consider, yes
02:51:28 <erisco> corgifex, I know c++ has closures now so I can look at how it does them
02:52:31 <erisco> I think the biggest problem with explicit memory management is most of your functions will have to be written in IO
02:52:43 <erisco> because you'll be assigning to pre-allocated memory regions
02:53:30 <erisco> and reading from them
02:53:39 <erisco> so basically like using iorefs everywhere
02:55:06 <jakex> could you write your own monad that allowed memory allocation but not all the other things from IO?
02:55:07 <erisco> and with limited resources many of the algorithms you'll want to implement should operate in-place if possible
02:55:24 <identity> jakex: sure
02:55:28 <identity> similar things have been done
02:55:34 <erisco> so there goes the usage of many functional data structures =\
02:56:23 <erisco> I am feeling like the functional style is worth keeping but maybe purity has to be thrown out
02:59:20 <Hermit> erisco: have you checked linear types?
02:59:50 <erisco> Hermit, hm what is your thought with how they could help here?
03:01:14 <Hermit> they keep referential transparency, are pretty much functional and data is freed immediately when it's not needed anymore, reusing the space, equating to inplace update in terms of memory footprint
03:01:45 <Hermit> and they can do sequencing like monads, though can't be used for implementing coroutines/continuations
03:02:18 <erisco> Hermit, I will take a look at them then
03:03:42 <Hermit> erisco: the idea is, reading data destroys it's previous reference, and unless you return a new one, it's freed. Of course, this is just an idiom
03:04:05 <Hermit> (reference as in variable, not pointer)
03:05:38 <Hermit> this reduces the holes/data ratio, since the life-span of most values is really really short, compared with standard GC-centric approaches
03:06:13 <Hermit> and also helps data locality
03:06:29 <Hermit> so less memory page swaps are necessary
03:07:19 <erisco> and would reduce bugs on things such as file pointers
03:07:33 <Hermit> totally, resources are freed immediately
03:07:58 <Hermit> it's a different work flow though
03:08:13 <Hermit> but like everything... it's a matter of getting used to it
03:08:18 <erisco> sounds like a good starting point to try and salvage the functional paradigm
03:09:31 <erisco> when I search for "low level" fp languages I do not find anything
03:10:01 <Hermit> I have a few things in mind I'm planning to try in a pet language of my own aimed for embedded systems and up. See how well they play together, then publish if the result is worth it
03:10:26 <Hermit> linear types may be one of those things
03:10:33 <erisco> I'd be interested in seeing what you come up with
03:10:52 <Hermit> suscribed ;¬)
03:12:09 <erisco> I wonder if laziness is worth trying to keep
03:12:26 <erisco> I am not sure how often optimisations such as strictness analysis fail
03:12:34 <bernalex> I'm curious; how can I do this without do notation: do { a <- getChar; b <- getChar; putStrLn $ b : a : []; }
03:12:41 <MP2E> Heh, I like purity and laziness :< They do sacrifice fine grained resource management, but speed seems to be decent.
03:13:15 <pharaun> strict i/o and then laziness/purity seems like a decent balance
03:13:29 <jakex> getChar >>= \a -> getChar >>= \b -> putStrLn $ b : a : []
03:13:34 <MP2E> I'd agree with that, I try to keep within Strict IO whenever possible
03:13:35 <pharaun> i've been pipes, conduit, and others and have had good experience with them
03:14:11 <corgifex> @undo do { a <- getChar; b <- getChar; putStrLn $ b : a : []; }
03:14:11 <lambdabot> getChar >>= \ a -> getChar >>= \ b -> putStrLn $ b : a : []
03:14:12 <erisco> > ((,) <$> getChar <*> getChar) >>= \(x,y) -> putStrLn (show [x,y]) -- bernalex
03:14:14 <lambdabot>  <IO ()>
03:14:30 <pharaun> there can be place and time for lazy i/o but i generally stay away
03:14:57 <erisco> oh sorry I missed the fact a and b where chars...
03:15:16 <Hermit> bernalex: (\a b -> [a,b]) <$> getChar <*> getChar
03:15:31 <erisco> yeah that would be better
03:15:39 * hackagebot hwall-auth-iitk 0.1.0.0 - Initial version of firewall Authentication for IITK network.  http://hackage.haskell.org/package/hwall-auth-iitk-0.1.0.0 (satvikc)
03:15:53 <erisco> > (\a b -> [a,b]) <$> getChar <*> getChar >>= putStrLn
03:15:54 <lambdabot>  <IO ()>
03:15:58 <erisco> nice :)
03:16:33 <bernalex> yeah I like that one. should be [b,a] though. :-)
03:16:38 <erisco> oh
03:17:13 <bernalex> and maybe I'd prefer =<< to >>=, not sure though.
03:17:35 <erisco> I have never seen applicative used with IO so this was fun
03:17:54 <bernalex> I wouldn't call it nice, but definitely fun :-]
03:18:13 <Hermit> erisco: wait till you see applicative used with ((->) a)
03:18:29 <erisco> Hermit, I have and I still cannot intuit what it is doing
03:19:01 <Hermit> yeah, it's wacky. I prefer using the monad ((->) a) instead
03:19:10 <Hermit> but it's not very different either
03:19:28 <Hermit> just think of it as parameter broadcasting
03:19:54 <erisco> :t repeat
03:19:55 <lambdabot> a -> [a]
03:20:29 <corgifex> ap is the inverse of (=<<) in ((->) e)
03:20:33 <erisco> > putStrLn <-< sequence . take 2 . repeat $ getChar
03:20:35 <lambdabot>  Not in scope: ‘<-<’
03:20:35 <lambdabot>  Perhaps you meant one of these:
03:20:35 <lambdabot>    ‘<=<’ (imported from Control.Monad.Writer),
03:20:35 <lambdabot>    ‘<<<’ (imported from Control.Arrow),
03:20:35 <lambdabot>    ‘<-=’ (imported from Control.Lens)
03:20:43 <erisco> > putStrLn <=< sequence . take 2 . repeat $ getChar
03:20:44 <lambdabot>  <IO ()>
03:20:49 <erisco> perhaps even better
03:21:05 <corgifex> :t replicateM 2 getChar
03:21:06 <lambdabot> IO [Char]
03:21:10 <erisco> well, if you care about a variable number of chars to get
03:21:10 <matematikaadit> :t (<=<)
03:21:12 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
03:21:13 <erisco> ah nice :)
03:21:28 <Hermit> :t fmap reverse . replicateM 2 getChar
03:21:29 <erisco> replicate of course hehe
03:21:30 <lambdabot>     Couldn't match expected type ‘a -> f [a1]’
03:21:30 <lambdabot>                 with actual type ‘IO [Char]’
03:21:30 <lambdabot>     Possible cause: ‘replicateM’ is applied to too many arguments
03:21:30 <corgifex> @src replicateM
03:21:30 <lambdabot> replicateM n x = sequence (replicate n x)
03:21:35 <Hermit> err
03:21:36 <corgifex> @src replicate
03:21:36 <lambdabot> replicate n x = take n (repeat x)
03:21:47 <Hermit> :t fmap reverse $ replicateM 2 getChar
03:21:48 <lambdabot> IO [Char]
03:21:53 <erisco> > putStrLn (replicateM 2 getChar)
03:21:55 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘GHC.Types.Char’
03:21:55 <lambdabot>  Expected type: GHC.Base.String
03:21:55 <lambdabot>    Actual type: [[GHC.Types.Char]]Couldn't match type ‘GHC.Types.IO’ with ‘[]’
03:21:55 <lambdabot>  Expected type: [GHC.Types.Char]
03:21:55 <lambdabot>    Actual type: GHC.Types.IO GHC.Types.Char
03:22:00 <Hermit> bernalex: how about that last one?
03:22:04 <erisco> oops
03:22:10 <erisco> > putStrLn =<< replicateM 2 getChar
03:22:12 <lambdabot>  <IO ()>
03:22:22 <corgifex> > putStrLn . reverse =<< replicateM 2 getChar
03:22:23 <lambdabot>  <IO ()>
03:22:23 <erisco> wow so concise very functional
03:22:47 <bernalex> erisco: fail to reverse ;-)
03:22:57 <erisco> well corgifex was better than me
03:23:07 <bernalex> putStrLn . reverse =<< replicateM 2 getChar
03:24:40 <bernalex> oh right, that was exactly what corgifex did. didn't see ya there, buddy. :-)
03:25:10 <bernalex> that one is actually nicer than the do-notation. good job, #haskell!
03:28:36 <aloiscochard> how can I convert a Nat to an Int (using GHC.TypeLits)?
03:29:18 <aloiscochard> ah nm, fromSing
03:52:18 <aloiscochard> ... things changed in last GHC, anyone have an example which use `natVal`?
03:52:43 <skypers>     Can't make a derived instance of `MonadBaseControl IO GL'
03:52:46 <skypers> NOOOOOOOO
03:52:46 <skypers> :D
03:52:58 <skypers> it’s gonna be such a pain in the ass
03:59:28 <neumond|2> try to don't solve your tasks through the ass :P
04:14:33 <jakex> how can I quickly check the version of a module I have installed?
04:16:05 <EOKMNZI>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <FHDMXHN>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <ZZOPKEV>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <QWFYKPB>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <RIRKAQM>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <RUVZOOX>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <CIIJJVO>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <YJHSDBV>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <SQYOGKO>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <UXGBMIS>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <YASEDZB>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <LBSOHPJ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <WMGRPGI>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <ETNJFNE>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <IQQEVNQ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <GKCIWKQ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <ZMISTNE>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <KWRHHWK>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <EIHZYDO>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <KLXNVVJ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <GEASTLW>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <OYJVJUU>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <LWICZAS>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <EHMJWFR>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <OCAYMTB>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <FXBIMKM>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <FPHFJNS>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <SNERCJT>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <YKSZBVC>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <IZTCTTR>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <UHTNVBA>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <JGYYHQZ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <SAMIESE>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <JPRGTMC>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <UPEMZVQ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <TMDQFLK>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <SULNPYW>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <MWEYEEE>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <RGLXDOY>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <IVLCIPZ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:06 <GCWRITF>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:08 <SNVEDJQ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:08 <LXKADYO>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:08 <AOPGZQV>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:08 <BAXHGZE>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:08 <XJAYQPI>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:08 <VVKYYDD>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:08 <IKOETMG>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:08 <ZUYNRNH>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:15 <UAMIBFU>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:17 <HEDYSQZ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:17 <GIJLCOQ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:17 <JJGIVFV>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:17 <YRWOXUZ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:17 <KWKZGIG>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:17 <KXKXZJC>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:17 <CUYZUJB>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:17 <BARLUUI>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:17 <FIVJTEZ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:17 <QKLHSVX>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <KNZTFPP>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <JZEPLTG>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <BLQWRNM>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <UKOMJUU>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <GQLAOOA>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <AOOADZB>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <BPIUUTL>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <EARLEGC>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <ZJEJJHD>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <RMBQDKF>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <AEVZDPR>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <ZHQHIIC>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <BQLOSEA>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <YJGTINX>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <HTPUQJY>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <NBPZFBA>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:18 <PGLHKVV>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <ZPPKRRM>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <ZPPKRRM>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <ZPPKRRM>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <NLXLDPY>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <CECLHAY>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <DYWCPVZ>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <KNAVZHU>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <NBPZFBA>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <OBDTSVX>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <HTPUQJY>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <NBPZFBA>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <VPCSJDN>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <FHJEDQK>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <AEQQYWV>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <TXRFLKC>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <LFYCNXV>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <YJGTINX>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:19 <DGCUTWY>  THIS CHANNEL IS NOW RAN BY MMATON CHAT CREW BICHEZ
04:16:23 --- mode: tomaw set +r
04:16:39 <hpc> all hail our new spam overlords
04:16:40 <bernalex> short reign.
04:22:57 <Earnestly> He didn't use "RAN" correctly
04:23:33 <Earnestly> Made for somewhat pretty output though: http://a.pomf.se/stegfv.png
04:28:18 <pillar_Young> gays, Are <- and -> Function? if they are where i can find them
04:28:31 <glosoli> gays?
04:28:33 --- mode: tomaw set -r
04:28:44 <SwashBuckla> ...
04:28:44 <Rembane> :t (->)
04:28:44 <Rembane> Hm... nope
04:28:46 <SwashBuckla> question for gays only
04:28:47 <lambdabot> parse error on input ‘->’
04:29:06 <Axman6> pillar_Young: no
04:29:30 <glosoli> SwashBuckla: yeah, kinda weird imo
04:29:38 <hexagoxel> jakex: if by "module" you mean "package", "ghc-pkg list" (plus grep for specific package)
04:29:49 <pillar_Young> guys..
04:29:50 <Axman6> -> is part of the type system or the syntax to construct lambdas. <- is just the lambda -> backwards (plus a little more)
04:35:38 <pillar_Young> so how to understand <- 's behavior? i mean :type getChar get type IO Char, getChar and a <- getChar their type are same?
04:38:14 <corgifex> pillar_Young: you need to understand how do notation is desugared
04:38:22 <dv-> do a <- getChar; ... is the same as getChar >>= \a -> ...
04:38:27 <corgifex> @undo do { c <- getChar; putChar c }
04:38:28 <lambdabot> getChar >>= \ c -> putChar c
04:38:49 <corgifex> do { v <- X; ... } ==> X >>= \v -> do { ... }
04:39:09 <corgifex> do { X; ... } ==> X >> do { ... }
04:39:17 <corgifex> do { X } ==> X
04:39:31 <jakex> getChar >>= \ c -> putChar c can also be written as getChar >>= putChar
04:39:31 <corgifex> do { let v = X; ... } ==> let v = X in do { ... }
04:39:52 <gtrambly> i love hoogle
04:40:00 <gtrambly> it makes haskell so much easier
04:41:45 <jakex> pillar_Young did that make any sense? do and <- are syntactic sugar that desugar to >>=
04:41:54 <jakex> as shown above
04:42:09 <jakex> :t (>>=)
04:42:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:44:07 <pillar_Young> jakex: yes thanks , i just find this http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
04:44:33 <jakex> yeah. note that >> is implemented in terms of >>=
04:44:34 <jakex> @src (>>)
04:44:36 <lambdabot> m >> k      = m >>= \_ -> k
04:48:06 <samm> is it normal that runhaskell takes 0.8 seconds to run a hello world program? is there a way to speed the start up (besides compiling the program, obviously)?
04:48:32 <klarh> samm: run it a second time since everything is presumably cached now?
04:49:52 <samm> i see no difference between first and second run
04:50:24 <klarh> aww, hmm
04:51:17 <samm> (my mistake btw, it is 0.4 seconds. still, it would be nice if I could make it shorter)
04:54:16 <b0bbi10> hi, since Haskell is lazy and doesn't read all the contents of a file into memory, how is this behaviour implemented?
04:55:19 <OrangeDuck> hi all. I'm trying to abuse the TupleSections syntax for a different purpose. For this I'm making it instance a typeclass like "instance NDIndexable (a -> (a, Int))". Then inside the class definition I want to extract the "Int" value to use. But in doing so I have to evaluate the function, which binds some strict type to "a". Is there some way to get the "Int" value without binding "a" or making "a" have a typeclass - essentially leaving 
04:56:51 <Jafet> You're leaving something essential after "essentially leaving"
04:57:39 <b0bbi10> ;D
04:57:55 <aristid> OrangeDuck: very long sentences are cut short by some irc clients.
04:58:05 <OrangeDuck> opps
04:58:14 <OrangeDuck> "essentially leaving the type declaration as it is?"
04:58:25 <Jafet> :t snd . ($ undefined)
04:58:26 <lambdabot> (a1 -> (a, c)) -> c
04:58:36 <aristid> OrangeDuck: you could try passing in undefined, but really i think you should not do this at all.
04:58:45 <aristid> it sounds like one of the most horrible hacks
04:59:19 <OrangeDuck> haha
04:59:28 <OrangeDuck> I don't deny that
04:59:51 <aristid> i don't see any justification for it either, i'm sure there are reasonable ways to do what you want
05:00:08 <Jafet> bobbi: when the haskell implementation needs the rest of the file, it runs the thunk that fetches the rest of the file
05:00:33 <aristid> samm: runhaskell needs to compile first. to make it faster, compile yourself and then just invoke the binary.
05:00:41 <OrangeDuck> aristid - You're right. There are reasonable ways too. Its just a syntax hack.
05:00:53 <Jafet> This thunk needs to perform file IO, but the caller doesn't need to know that.
05:01:05 <aristid> OrangeDuck: how is (a,) nicer syntax than MyCon a?
05:01:42 <OrangeDuck> aristid - its more terse
05:02:07 <aristid> OrangeDuck: make it a short constructor name.
05:02:21 <OrangeDuck> I wont provide it as the only method to achieve things. Just an option for those who want it
05:03:23 <aristid> OrangeDuck: i can't prevent you from doing stupid things *shrug*
05:04:12 <OrangeDuck> aristid - Its just for some fun and curiousity, not production code or anything
05:04:24 <aristid> ok
05:05:23 <samm> aristid: the point was to make it a script, to avoid compiling each time I change something. I thought runhaskell interprets the code, rather than compiling it first?
05:05:57 <MagneticDuck> runhaskell is just an alias to ghc
05:06:07 <MagneticDuck> (builds the code in /tmp)
05:06:26 <MagneticDuck> OrangeDuck: omg I'm a duck too
05:06:30 <samm> ah
05:06:31 <MagneticDuck> go ducks
05:06:37 <aristid> samm: well, the difference between compiling and interpreting can be blurry. even "perl" compiles things first, all the time.
05:06:37 <OrangeDuck> MagneticDuck - \o/
05:06:49 <MagneticDuck> OrangeDuck: wooooo \_o<
05:07:34 <aristid> samm: but if it's just testing for now, a 0.4s delay should be fine, no?:D
05:08:11 <samm> it would be neat if runhaskell cached the program, and only recompiled if there were changes in source
05:09:41 <samm> aristid: my real program (only 10 lines) takes 0.8 s delay, which is noticable and a bit annoying
05:10:03 <aristid> samm: you can write a small bash loop that automatically compiles your program with ghc :P
05:10:16 <aristid> i bet there are even programs for that, but i don't know their names
05:11:31 <samm> caching sounds better IMO
05:11:39 <Jafet> Your 0.4s time is dominated by loading and linking, not compilation.
05:11:58 <corgifex> you can just build the caching (or rather recompiling) into your program
05:12:04 <corgifex> like what xmonad does
05:12:34 <samm> I think I will write runhaskell equivalent that caches compiled program
05:12:45 <samm> shouldnt be hard
05:13:00 <aristid> samm: i'm trying to help you solve problems in _possible_ ways, that do not involve hacking ghc. it's nice if you think that there are hypothetical unimplemented nicer options.
05:13:16 <aristid> ghc --make is that program.
05:13:27 <aristid> it caches the compiled program on disk.
05:15:08 <samm> then I am even more puzzled why runhaskell doesnt take advantage of that, instead of always recompiling
05:15:27 <corgifex> runhaskell doesn't compile
05:16:09 <samm> corgifex: I thought it was running ghci but was told that it uses ghc to compile to /tmp
05:16:36 <defanor> i'm looking for a web framework which allows to change and access some [shared] state for different users, without messing with db/storage. any suggestions?
05:16:36 <corgifex> I don't believe anything I read on the internet
05:17:44 <samm> corgifex: I was told this 5 minutes ago, in this channel. :)
05:18:48 <aristid> i don't know whether runhaskell does things the ghc or the ghci way, but both can be considered "compiling"
05:18:50 <MagneticDuck> corgifex: WHAT??
05:19:19 <MagneticDuck> well it obviously uses ghc
05:19:30 <MagneticDuck> uhh...
05:19:45 <aristid> samm: time (ghc --make foo.hs && ./foo) for the second run says 0.062 seconds here
05:20:38 <aristid> the first run is significantly slower than runhaskell though
05:20:41 <samm> aristid: yeah looks to be a better option than runhaskell
05:20:52 <samm> for me at least
05:21:07 <Jafet> The --make is unnecessary
05:21:24 <aristid> runhaskell needs 0.12s and the full compile needs 0.257s
05:21:29 <samm> so runhaskell probably runs ghci
05:21:50 <Jafet> I don't know why runghc/ghci take so long to load packages. It may be improvable.
05:23:22 <corgifex> now throw in some -O
05:23:59 <aristid> corgifex: 0.314s for the hello world with -O2:D
05:39:47 <Jafet> itt gcc -O3 -fwhole-program -flto -fprofile-use -fomit-frame-pointer -march=native -mavx2 -ffast-math -ftree-parallelize-loops=8 -s hello.c -o hello
05:55:58 * hackagebot cabal-db 0.1.9 - query tools for the local cabal database (revdeps, graph, info, search-by, license, bounds)  http://hackage.haskell.org/package/cabal-db-0.1.9 (VincentHanquez)
06:05:28 <merijn> Which ABI(s) does GHC use when linking with C code?
06:05:59 * hackagebot digestive-functors-scotty 0.2.0.0 - Scotty backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-scotty-0.2.0.0 (MartinsMacs)
06:08:55 <corgifex> merijn: what kind of answer are you looking for?
06:09:43 <merijn> corgifex: Well, the answer of "which ABI does GHC use when linking C code?" :)
06:09:57 <corgifex> I don't understand the question
06:09:58 <merijn> corgifex: I'm not really sure how that question is ambiguous?
06:10:05 <corgifex> what does it mean?
06:10:27 <merijn> ABI = Application Binary Interface, i.e. register usage, calling convention and memory layout
06:10:35 <corgifex> what does that have to do with linking?
06:11:27 <corgifex> register usage and memory layout seem irrelevant anyway
06:11:32 <merijn> corgifex: Because the FFI has to use the right ABI to link non-haskell code?
06:11:33 <corgifex> is this about the FFI?
06:11:43 <corgifex> apparently yes
06:12:15 <corgifex> merijn: ok, so is "the right one" an acceptable answer?
06:12:21 <merijn> I'm just unsure if the FFI supports multiple and if so which ones
06:12:27 <geekosaur> it does
06:13:11 <merijn> geekosaur: Right, is there any in-depth explanation of what GHC supports? Or is there just the Report + GHC source?
06:13:15 <geekosaur> on unixlikes there's typically only one platform ABI and it is used. on windows there are multiple ABIs and you can specify the one to use in the foreign import
06:13:42 <geekosaur> I've seen it somewhere, am poking
06:13:44 <int-e> merijn: http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1550008.4.1 and two extensions (https://www.haskell.org/ghc/docs/7.8.2/html/users_guide/ffi.html)
06:14:04 <int-e> in depth, I don't know.
06:14:20 <geekosaur> the details would not be part of the report, which is generic
06:14:49 <corgifex> "ccall - Calling convention of the standard C compiler on a system "
06:15:33 <merijn> int-e: Yeah, I know the report, but I'm trying to conjure GHC into low-level bit twiddling so that's not detailed enough for me :)
06:15:50 <corgifex> ah, an XY problem
06:16:24 <merijn> That's not an XY problem, though
06:17:47 <tpsinnem> hey, i have little info on the status of CMS-type web apps in statically typed FP. might it be that if you wanted to run one right now, clckwrks (clckwrks.com) could be a good or best option?
06:18:53 <merijn> Maybe this is more a #ghc question anyway
06:19:01 <tpsinnem> i do have the impression that it uses lazy IO rather than any of the recent advances in stream processing, but i'm not sure how relevant that is to what i would be doing
06:19:05 <geekosaur> sigh, i guess the report is the main one. and the answer is probably the source, yes.
06:19:17 <geekosaur> seems like the wrong place to put it
06:19:28 <merijn> geekosaur: Not the answer I wanted to hear, but the one I was expecting :)
06:19:54 <geekosaur> not the answer I wanted to find either :(
06:21:24 <bainikolaus> Xk
06:35:09 <sie> I want to know how State works and looks like MonadState's a big part of it. `get :: m s' If I've a `myfun :: State IntState CharResult', then how would the "get" receive the actual data?
06:42:09 <Dongyancai> hello, when I try to use System.getArgs, I got the error "It is a member of the hidden package `haskell98-2.0.0.2'.", and when I tried -hide-packagebase, I got "Could not find module `Prelude'", I am on a Gentoo Linux box, with haskell-7.6.3 installed with use flag +binary +gmp.
06:42:31 <absence> is there an xor for bools in some not-too-niche library?
06:42:46 <k00mi> absence: /=
06:43:06 <merijn> sie: The good news is: MonadState has pretty much zero to do with State so you can ignore all the complex stuff
06:43:36 <merijn> sie: It's a convenience wrapper that is completely orthogonal to what State does and how it's implemented
06:44:06 <absence> k00mi: it's so obvious when you say it :) thanks
06:45:57 <geekosaur> Dongyancai, System.getArgs (in that package specifically) is deprecated and only part of the old Haskell98 standard
06:46:06 <geekosaur> the modern location is System.Environment
06:46:15 <merijn> Really, all of State can be defined in the following few definitions: "newtype State s a = State { runState :: s -> (a,s) }", "get :: State s s", "put :: s -> State s ()" and "modify :: (s -> s) -> State s ()"
06:46:26 <geekosaur> (System was getting a bit full as new stuff was being added)
06:47:21 <geekosaur> you can't use both because (a) much of the moved stuff needs to be referenced by Prelude, so a specific Prelude is needed for each language standard (b) some types have changed in later versions of the language standard
06:48:26 <geekosaur> so you need to pick which standard you're working with (-XHaskell98, -XHaskell2010, or the default is ghc's current behavior which can be assumed to be the next official standard) and stick with it; you can't mix them
06:50:38 <geekosaur> (also note the official standards are quite conservative and as a result may limit the functionality of programs you write to them; this is why most programs aren't written strictly to the standards)
06:53:16 <Dongyancai> geekosaur, thank you. I tried System.Environment.getArgs, which doesn't work, then moved to import System.Environment (getArgs), this time it works.
06:53:41 <jmcarthur> I do wish I could just fully qualify a module without having to import it at all sometimes.
06:53:52 <jmcarthur> I think you can in GHCi, but not in a source file.
06:53:56 <corgifex> have I got an ocaml for you
07:00:27 <mgomes> hi... how can i install cabal in slackware?
07:03:27 <angerman> Does anyone have vty-ui using apps somewhere online where I could take a peek at the architecture?
07:07:24 <tristan__> dealing with an annoying warning I'd like to get rid of
07:07:43 <tristan__> I have a function
07:07:44 <tristan__> (<=>) :: (Show a) => B.ByteString -> a -> (B.ByteString, B.ByteString)
07:08:27 <tristan__> each time it is used in the code I get a warning, Defaulting the following constraint(s) to type `Integer`, depending on which type is used in that piece of code, so Integer, String, etc
07:11:25 <sie> merijn, Okay, well you still implement the get of MonadState. Where does it get the value from?
07:11:58 <sie> Like in this example of tick and plus(One) http://hackage.haskell.org/package/mtl-2.0.1.0/docs/Control-Monad-State-Lazy.html#g:4
07:12:20 <maltem> angerman, have you seen that there's a user manual for vty-ui?
07:12:26 <geekosaur> tristan__, I think you need {-# OPTIONS_GHC -fno-warn-type-defaults #-}
07:12:35 <merijn> sie: The MonadState type class uses functional dependencies and typeclass recursion to smuggle the 's' value in
07:12:56 <geekosaur> there is some question as to whether -Wall should include that one by default, since it's a bit obnoxious
07:13:04 <merijn> sie: MonadState won't make sense until you understand 1) State 2) monad transformers and 3) combining the two
07:13:13 <sie> I get state now.
07:13:24 <angerman> maltem: yes, that's very good. The demos are pretty nice as well. I'm looking for some more complex interaction.
07:13:31 <geekosaur> sometimes you do want it, quite often you specifically intend the type to be inferred and don't want to be warned about it all the time
07:13:47 <merijn> sie: Have you looked at StateT? i.e. the State monad transformer?
07:13:50 <maltem> angerman, maybe http://packdeps.haskellers.com/reverse/vty-ui
07:14:02 <tristan__> geekosaur: ah, thanks. so it is a warning that is, at lesat in this case, ignorable basically?
07:14:05 <maltem> (not sure if those are complex in any way)
07:14:14 <no-n> where can i read about how function calls work in haskell, as opposed to say C
07:14:15 <geekosaur> usually, yes
07:14:16 <angerman> maltem reverse search? whoa!
07:14:25 <tristan__> cool
07:14:27 <geekosaur> no-n, in what sense?
07:14:39 <merijn> tristan__: type defaulting == "this thing is polymorphic and I didn't realise which type you wanted, so I defaulted to this one"
07:14:45 <sie> merijn, Yah, but I should check some examples.
07:14:50 <maltem> angerman, yes it's very useful for… well, cases like this
07:14:57 <angerman> maltem: I'm working on my own here: https://github.com/angerman/HInvoice but I'm repeatedly thinking I'm doing something wrong :)
07:15:20 <sie> But does State w/o get really make have any use?
07:15:36 <tristan__> merijn: right, I thought amybe there was something in the definition I could do to make it happy
07:15:55 <merijn> tristan__: You can, you can annotate it with a type
07:16:37 <merijn> tristan__: I'm guessing it's complaining when you write something like "someBS <=> 5"?
07:16:40 <geekosaur> [13 14:04] <tristan__> (<=>) :: (Show a) => B.ByteString -> a -> (B.ByteString, B.ByteString)      looks like a type to me...
07:16:41 <tristan__> merijn: right, I don't wnat a type :), since I want anything that is showable
07:17:04 <tristan__> "a single type"
07:17:10 <merijn> tristan__: The problem is that in Haskell numeric literals are polymorphic
07:17:13 <merijn> :t 5
07:17:15 <lambdabot> Num a => a
07:17:26 <merijn> tristan__: There may be multiple Num types that are Show instance
07:17:38 <merijn> i.e. did you mean Int, Integer, Double, etc.
07:17:49 <tristan__> it says ht esame about String
07:17:52 <merijn> tristan__: You could solve it by writing "someBS <=> (5 :: Int)"
07:18:00 <merijn> tristan__: OverloadedStrings enabled? :)
07:18:00 <tristan__> oo
07:18:03 <tristan__> yea
07:18:07 <tristan__> ok
07:18:09 <tristan__> now it makes sense
07:18:29 <merijn> tristan__: OverloadedStrings turns string literals into "IsString a => a", same issue :)
07:18:32 <tristan__> that worked!
07:18:36 <tristan__> yup
07:18:37 <tristan__> makes sense
07:18:44 <tristan__> didn't htink about OverloadedStrings :)
07:18:52 <tristan__> thanks!
07:18:59 <tristan__> haskell making more and more sense, hehe
07:20:34 <merijn> tristan__: If you had used something other than literals it would've just properly inferred the type of whatever you gave it
07:21:45 <tristan__> yup, makes sense
07:22:04 <tristan__> since I'm mentioning this, is there a better way to do this code:
07:22:18 <tristan__> https://gist.github.com/tsloughter/10586031
07:23:11 <merijn> "B.pack . show" :(
07:23:32 <tristan__> no likey?
07:23:34 <merijn> This reeks of Data.ByteString.Char8
07:23:47 <tristan__> yea... :)
07:23:52 <merijn> A vile pox on programmers filled with lies
07:23:59 <tristan__> haha
07:24:07 <merijn> This code will silently truncate any non-ASCII values
07:24:34 <corgifex> when does show return non-ascii strings?
07:25:02 <merijn> corgifex: Show instance of Text?
07:25:08 <merijn> Show instance of Char?
07:25:15 <corgifex> not Char
07:25:20 <geekosaur> yes Char
07:25:29 <corgifex> show me
07:25:31 <merijn> > maxBound :: Char
07:25:33 <lambdabot>  '\1114111'
07:25:42 <merijn> > show (maxBound :: Char)
07:25:43 <geekosaur> Char is a unicode codepoint
07:25:44 <lambdabot>  "'\\1114111'"
07:26:06 <corgifex> geekosaur: irrelevant
07:26:15 <geekosaur> although I guess its Show instance does encode to avoid it by default, yeh
07:26:16 <merijn> > show 'λ'
07:26:17 <lambdabot>  "'\\955'"
07:26:25 <geekosaur> I still would not want to rely on it
07:26:51 <geekosaur> but then if you think Char8 is appropriate then you've already decided you like taking risks
07:26:55 <corgifex> Text does the same thing
07:27:10 <corgifex> the problem is that Haskell doesn't support ASCII well and show has the wrong type
07:27:12 <tristan__> merijn: is there a way to do it without losing unicode
07:27:26 <merijn> tristan__: The proper way from String -> ByteString is via Text
07:27:28 <geekosaur> it's 2014, we should not be constrained to a 1960s representation really
07:27:59 <tristan__> merijn: ah, so use show, then create text then bytestring?
07:28:14 <corgifex> merijn: isn't there a direct encode function?
07:28:37 <merijn> tristan__: Data.Text has "pack :: String -> Text" (which is safe) and Data.Text.Encoding has "encodeUtf8 :: Text -> ByteString"
07:28:45 <merijn> corgifex: Not that I'm aware of
07:28:57 <corgifex> there are probably several
07:29:02 <tristan__> yup, ok
07:29:06 <corgifex> this problem is older than Text
07:30:21 <merijn> tristan__: In general Text is what you want to deal with anyway, it's much more efficient than String
07:30:58 <merijn> tristan__: And by that I mean "String can have as much as 20 bytes of overhead *per character* on some platforms" :)
07:30:59 <tristan__> merijn: yea, I do everywhere, but needed show and snap needs bytestring, so didn't even think about the consequences :)
07:31:48 <merijn> tristan__: Probably "encodeUtf8 . T.pack . show" is the way to go then
07:32:01 <tristan__> yup, showBS = encodeUtf8 . T.pack . show is what I ended up with :)
07:33:58 <tristan__> at least dealing with strings in haskell makes me not feel as bad about the state of strings in Erlang , hehe
07:36:07 <merijn> tbh, people complain string in haskell are terrible, I write C, haskell Strings are "meh, could be nicer" at worst
07:37:22 <pyon> String should really be the name for the IsString type class.
07:37:53 <pyon> With instances [Char], ByteString, Text, Rope and whatnot.
07:38:12 <bennofs> pyon: instance String String where string = id :P
07:38:16 <corgifex> [Int]
07:38:40 <pyon> bennofs: Well, I would not define "type String = [Char]" to begin with.
07:39:14 <tristan__> rope?
07:39:29 <pyon> tristan__: http://en.wikipedia.org/wiki/Rope_%28data_structure%29
07:39:48 <tristan__> aah
07:44:36 <Maior> so I really don't like significant whitespace / Haskell's whitespace rules (possibly triggered by repeatedly failing with let/in) - am I a terrible person for being about to start using braces?
07:45:00 <corgifex> Maior: no
07:45:00 <merijn> Maior: Did you ever read the exact rules haskell uses?
07:45:04 <merijn> They're fairly simple
07:45:12 <merijn> But most people don't bother and then get confused
07:45:18 <merijn> Also, were you using tabs?
07:45:39 <Maior> merijn: I've read through https://en.wikibooks.org/wiki/Haskell/Indentation but I've failed to get a handle on where to put the "in" for let
07:45:42 <Maior> and yes tabs
07:46:08 <cwvh> Maior: you're going to have to give up your hard tabs
07:46:11 * hackagebot adblock2privoxy 1.2.4 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.2.4 (zubr)
07:46:12 <tristan__> I put 'in' lined up in the same column as 'let'...
07:46:21 <merijn> Maior: And your editor was set to anything other than 8 column tab stops?
07:46:22 <corgifex> "in" can be wherever you want
07:46:38 <corgifex> tabs are the first step towards failure
07:46:39 <tristan__> tabs are bad, mmkay
07:46:42 <Maior> merijn: I'm afraid I don't understand what you mean
07:47:01 <merijn> Maior: GHC parses tabs as jumping to the next column that is a multiple of 8
07:47:04 <jmcarthur> Maior: basically just avoid tabs
07:47:56 <Maior> merijn: ah that seems odd but interesting, thanks
07:48:13 <merijn> Maior: That's the common unix interpretation of tabs
07:48:21 <jmcarthur> Honestly, while I agree they take some getting used to at first, I think Haskell's whitespace sensitive syntax is really fantastic, leaps and bounds beyond Python's. It turns out to be very intuitive.
07:49:14 <Maior> merijn: I would argue that the sensible interpretation was "one tab is one level of indentation"...
07:49:29 <corgifex> Maior: haskell syntax isn't based on indentation levels
07:49:32 <jmcarthur> Maior: That's exactly where your mental model is wrong. Haskell is not concerned with "levels of indentation."
07:49:36 <corgifex> it's based on making things line up with other things
07:49:40 <jmcarthur> Maior: It's about "blocks"
07:49:40 <cwvh> Maior: Haskell is "indented" by column, where Python is indented by ... indentation
07:50:03 <Maior> "Code which is part of some expression should be indented further in than the beginning of that expression (even if the expression is not the leftmost element of the line)"
07:50:30 <Maior> cwvh: right ok that would make sense
07:50:51 <corgifex> ok, so here's the story
07:50:52 <jmcarthur> Maior: that quote even includes a hint in the parentheses there
07:51:30 <corgifex> haskell has several keywords that trigger "layout" (let, of, where, do, ... anything else?)
07:51:43 <corgifex> the important part is the next token
07:51:55 <corgifex> if the next token is '{', nothing magic happens.
07:52:22 <corgifex> if the next token is not '{', an implicit '{' is assumed and the base indentation level of the block is set to the column of the next token
07:53:02 <Maior> corgifex: ahhhh ok
07:53:29 <cwvh> Maior: If you haven't read this, it's a good starting point to Haskell style. Following the idioms in the document will keep you out of danger during the early days: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
07:54:43 <tanmaig> Hi! I'm using Persistent which has a way to specify a sort option when fetching rows from a table. selectList [] [Asc ModelId, Limit 0, OffsetBy 0]
07:54:56 <Maior> it really is explicitly "columns" that matter, thanks
07:54:58 <tanmaig> That could be Asc ModelId
07:55:17 <tanmaig> Or Asc ModelName, or Asc ModelCreated
07:55:27 <tanmaig> where id, name, created are columns Model has.
07:56:24 <tanmaig> The problem is, that if I do (sortOrder BicycleId)
07:56:29 <tanmaig> I'm sorry
07:56:51 <tanmaig> (sortOrder ModelId) where sortOrder is a function parameter that can be Asc or Desc
07:57:07 <tanmaig> that fails to typecheck
07:57:49 <tanmaig> myFunction sortOrder columnName = case columnName of { "id" -> sortOrder ModelId; "name" -> sortOrder modelName; }
07:57:55 <tanmaig> that doesn't type check
07:58:15 <tanmaig> but myFunction sortOrder columnName = case columnName of { "id" -> Asc ModelId; "name" -> Asc modelName; }
07:58:16 <tanmaig> does
07:58:19 <Maior> so, even with spaces, I'm still having issues with my "in" (and these really are spaces) https://gist.github.com/doismellburning/10587379
07:58:48 <Maior> oh it'll be the capitals
07:59:00 <Maior> they won't help
07:59:21 <merijn> Maior: Pretty sure in should be indented more than let, but a better question is: Why use let-in at all?
07:59:30 <merijn> Why not use 'where'?
07:59:38 <joseph07> Maior: I think the problem might be the line before in
07:59:41 <merijn> I can honestly say I don't remember the last time I wrote let-in
07:59:53 <merijn> oh wait
07:59:56 <Maior> joseph07: you're absolutely correct, I forgot the '
08:00:07 <Maior> thanks
08:00:11 <merijn> Maior: No, your if doesn't have an else/then
08:00:17 <merijn> oh
08:00:21 <merijn> it's the function, right
08:00:28 <Maior> thanks very much
08:00:48 <Maior> merijn: I'm not really seeing much meaningful difference between where/let
08:00:57 <joseph07> Maior: no problem
08:01:02 <Jafet> "where" creates definitions, "let" creates expressions
08:01:11 <Jafet> Perhaps you enjoy creating definitions more.
08:01:41 <merijn> Maior: There isn't one, other than that let/in tends to look really ugly
08:01:44 <merijn> like here
08:02:30 <cwvh> I never really thought about it before, but I think I avoided let/in early on for all these alignment and look-and-feel issues, too.
08:02:54 <Maior> the first FP I ever did was SML, I think it's a habit I acquired
08:20:45 <Maior> is there any nice way to do automated testing of things like the monad laws?
08:21:21 <Maior> I guess it's a bit QuickCheck like; something akin to "I have this typeclass, these things should hold, please test instances of it"
08:23:21 <Maior> (e.g. I have `FENable a` with `toFEN :: a -> String` and `fromFEN :: String -> Maybe a`; it should always hold that `fromJust $ fromFEN $ toFEN` === `id`
08:23:32 <Maior> )
08:24:12 <bennofs> Maior: I would write that property as fromFEN . toFEN = Just :)
08:24:49 <Maior> oh gp
08:24:56 <Maior> thanks
08:25:45 <bennofs> Maior: the way I usual do it is to write propertyGeneric ::(FENable a, Arbitrary a) => proxy a -> a -> a -> Bool; and then write prop_FENable_Int = propertyGeneric ([] :: [Int]), etc and do that for some types
08:26:08 <ReinH> Maior: if possible you should try to prove them rather than test them.
08:26:20 <Maior> bennofs: nifty thanks
08:26:33 <ReinH> (Not that testing isn't valuable)
08:26:36 <Maior> ReinH: I'm afraid I don't quite understand what you mean?
08:27:28 <ReinH> Maior: if you can prove that a certain law holds (via equational reasoning or structural induction, etc) then you don't need to test it
08:27:40 <ReinH> Maior: for example, http://www.haskellforall.com/2013/10/manual-proofs-for-pipes-laws.html
08:27:46 <Maior> how can I "prove" them, when anyone could come along and go `instance Monad MyThing where return = SomethingTotallyScrewy`
08:27:51 <bennofs> ReinH: but you'd need to repeat the proof each time your implementation changes
08:27:56 <ReinH> Maior: you can prove them for instances
08:27:59 <ReinH> bennofs: that's true
08:28:10 <ReinH> there are tradeoffs to consider, like always :)
08:28:27 <Maior> ah, hm, thanks
08:28:37 <Jafet> You can look into reversible grammars, where toX . fromX is true by construction.
08:28:41 <ReinH> A robust strategy includes proofs and testing :)
08:28:42 <bennofs> So testing could be useful to find out why you seem not be able to prove the laws :P
08:29:19 <ReinH> bennofs: :)
08:30:00 <monochrom> I don't understand the "but". re-proving is good, not bad. as good as re-testing.
08:30:00 <ReinH> Jafet: correct by construction is an excellent kind of correct :)
08:30:43 <monochrom> also as good as re-thinking.
08:31:01 <bennofs> monochrom: but re-proving needs more effort than just running automated tests :)
08:31:13 <ReinH> but it's a stronger guarantee :)
08:32:00 <Jafet> There is also automated re-proving, but that is a less well-trod area.
08:32:00 <ReinH> Jafet: I wish I could find more on correct-by-construction program design in Haskell :(
08:32:03 <monochrom> that, only, depends on whether "implementation changes" is by intelligent design or by random genetic mutation
08:32:27 <monochrom> suppose it's intelligent design. since you have to re-think anyway, that re-think already constitutes re-prove.
08:33:01 <monochrom> I agree that random genetic mutation requires a completely new proof.
08:33:32 <Jafet> Well, you could mutate the proof...
08:34:03 <Jafet> But proof-preserving random mutation seems much to ask of typical programming.
08:34:06 <monochrom> proving and intelligent programming are interleaved. not post-mortem as so many people wrongly teach
08:35:35 <skypers> am I the only one who thinks using MonadBase / MonadBaseControl is isomorph to doing it wrong?
08:35:50 <skypers> it seems to add a huge overload
08:35:50 <monochrom> yes
08:36:05 <skypers> I’m the only one, ok :D
08:36:27 <Jafet> Those are not the only ways to do something wrong, so they are not isomorphic
08:36:47 <skypers>     Can't make a derived instance of `MonadBaseControl IO GL'
08:36:51 <skypers> it makes me so so sad :D
08:36:56 <Maior> man this is fun
08:37:10 <skypers> MonadBaseControl is not really fun
08:37:39 <Maior> perhaps not
08:47:25 <skypers> ok hm
08:52:48 <Maior> @hoogle a -> [a] -> [[a]]
08:52:49 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
08:52:49 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
08:52:49 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
08:53:30 <skypers> hm
08:54:01 <skypers> if I want to implement MonadBaseControl for a newtype over EitherT, the StM is just Either e a, right ?
08:56:19 * hackagebot hsexif 0.1.0.0 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.1.0.0 (EmmanuelTouzery)
08:56:21 * hackagebot permutation 0.5.0 - A library for permutations and combinations.  http://hackage.haskell.org/package/permutation-0.5.0 (spacekitteh)
08:56:25 <hegge> C
09:00:23 <kqr> D
09:01:19 * hackagebot permutation 0.5.0.1 - A library for permutations and combinations.  http://hackage.haskell.org/package/permutation-0.5.0.1 (spacekitteh)
09:01:21 * hackagebot rainbox 0.4.0.0 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.4.0.0 (OmariNorman)
09:02:09 <joejev> are forgetful functors defined for large categories
09:09:21 <ReinH> Someone should write a "You Could Have Invented Yoneda!" post
09:09:49 <Jafet> You could have written it
09:09:53 <ReinH> Jafet: :p
09:10:05 <prophile> "ReinH Could Have Invented Yoneda!"
09:10:15 <prophile> oh, I see
09:10:19 <prophile> ahem
09:10:42 <djahandarie> I'm pretty sure there is one somewhere
09:10:49 <ReinH> I wouldn't be surprised
09:11:08 <quchen> Haskell needs a new fallacy. Maybe "you could have invented" is a good candidate.
09:11:16 <skypers> arf
09:11:17 <ReinH> Since people seem to prove special cases of yoneda all the time without knowing it
09:11:20 * hackagebot network-transport-zeromq 0.2 - ZeroMQ backend for network-transport  http://hackage.haskell.org/package/network-transport-zeromq-0.2 (AlexanderVershilov)
09:11:24 <skypers> I really don’t get how I should write liftBaseWith :(
09:11:45 <bennofs> @ty liftBaseWith
09:11:46 <lambdabot> Not in scope: ‘liftBaseWith’
09:11:46 <Maior> do you have a "Yoneda for someone mid-Sunday-beer" link?
09:11:53 <skypers> liftBaseWith :: (RunInBase m b -> m x) -> b x
09:12:09 <Maior> because while the Wikipedia page seems...thorough, it's a bit beyond me right now
09:12:13 <skypers> huh no
09:12:15 <skypers> liftBaseWith :: (RunInBase m b -> b α) -> m α
09:12:30 <bennofs> skypers: what's your m you're writing the instance for?
09:12:35 <skypers> IO
09:12:52 <skypers> oh wait
09:12:53 <skypers> no
09:13:03 <skypers> it’s a newtype over EitherT MyError IO a
09:13:13 <skypers> and I already have the StM type
09:13:14 <skypers> which is
09:13:42 <skypers> newtype StM GL a = StMGL { runStMGL :: Either MyError a }
09:14:03 <skypers> now, liftBaseWith f = ?
09:14:07 <skypers> what should I do with f?
09:14:08 <ReinH> skypers: people use MonadBase?
09:14:08 <ReinH> huh
09:14:19 <skypers> ReinH: I don’t know
09:14:27 <skypers> but MonadBaseControl is quite handy to me
09:14:40 <skypers> I use it especially with with
09:14:44 <skypers> (not a typo)
09:14:45 <skypers> or
09:14:47 <skypers> alloca
09:14:51 <skypers> or that kind of stuff
09:15:26 <ReinH> I've never seen it used but that doesn't mean much
09:15:47 <skypers> it’s a bit hard to me to directly write it
09:15:53 <skypers> I’m not get used to it enough
09:16:01 <skypers> got*
09:16:25 <skypers> so hm
09:17:11 <skypers> f is a function that takes another function that runs in the base monad and extract the state
09:17:29 <skypers> and outputs in the base monad the return value
09:17:37 <skypers> cryptic.
09:17:46 <ReinH> o_O
09:18:19 <ReinH> skypers: what do you want to do with MonadBase?
09:18:26 <skypers> not MonadBase
09:18:30 <skypers> MonadBaseControl*
09:18:32 <skypers> typically ReinH
09:18:34 <ReinH> abstract over non-IO-based monad transformers?
09:18:38 <skypers> no
09:18:44 <skypers> it’s a very simple task actually
09:18:55 <skypers> imagine you have a function that runs in… Foo
09:18:55 <ReinH> If you're not benefitting from the abstraction then why use it?
09:18:59 <skypers> and Foo is in MonadIO
09:19:06 <ReinH> you don't need mappend if you only ever work with strings
09:19:24 <skypers> now, you write some Foo glued functions, and end up using withForeignPtr
09:19:28 <ReinH> ok
09:19:33 <skypers> which expects IO
09:19:41 <ReinH> ok
09:19:52 <skypers> the idea is to be able to enter IO, and “resume“ the Foo
09:20:13 <skypers> control $ \run -> withForeignPtr p . run $ do
09:20:17 <skypers> something like that is great
09:20:42 <skypers> I just don’t understand how I should implement liftBaseWith
09:21:10 <Maior> @hoogle Int -> [a] -> [[a]]
09:21:10 <lambdabot> Prelude drop :: Int -> [a] -> [a]
09:21:10 <lambdabot> Data.List drop :: Int -> [a] -> [a]
09:21:11 <lambdabot> Prelude take :: Int -> [a] -> [a]
09:21:18 <bennofs> skypers: I think liftBaseWith f = liftBase $ f $ fmap StMGL . runEitherT
09:21:42 <bennofs> skypers: runEitherT needs to unwrap your GL newtype too
09:21:53 <skypers> gosh
09:21:57 <bennofs> skypers: so you need to change that to runEitherT . someGlUnwrapper
09:22:10 <skypers> is there any performance cost to all that ****
09:22:17 <absence> hm.. void :: Functor f => f a -> f () is defined in Control.Monad, but can't be used with monads. am i missing something?
09:22:30 <skypers> :t void
09:22:30 <bennofs> absence: every monad is a functor
09:22:31 <lambdabot> Functor f => f a -> f ()
09:22:44 <skypers> what bennofs said
09:23:05 <skypers> you can use void with Applicative as well
09:23:16 <bennofs> absence: so, for every Monad m, you have an instance Functor m. (You can implement fmap = liftM) This means that you can use void for all monads
09:23:18 <absence> bennofs: i thought that hadn't happened yet
09:23:19 <skypers> well, as applicative, I guess
09:24:19 <bennofs> absence: hmm, right, haskell allows monads that don't have functor instances iirc, but I think I've never seen a monad without a functor instance
09:24:33 <bennofs> absence: theoretically, there is always a possible functor instance
09:24:37 <bennofs> absence: (if you have monad)
09:24:52 <skypers> ok I got how I should implement liftBaseWith
09:24:54 <skypers> thank you
09:25:13 <skypers> I have a runGL
09:25:21 <skypers> which actually does the same thing as runEitherT
09:25:22 <skypers> :)
09:25:25 <bennofs> absence: but void is probably defined in Control.Monad because it doesn't make much sense to use it for functors (when would you want to discard the result of a functor?)
09:27:55 <absence> bennofs: i agree that it's probably only useful for monads, i just found it strange to be defined for Functor instead of Monad before the monad-applicative proposal was implemented :)
09:29:03 <bennofs> absence: Well, I think most people implement Functor. Applicative sometimes isn't implemented because you need to explictely import it, I think (and it's not as easy as Functor)
09:31:06 <skypers> bennofs:
09:31:07 <skypers>   liftBaseWith f   = liftBase $ f (fmap StMGL . runGL)
09:31:11 <skypers> works as a charm <3
09:35:16 <skypers> @hoogle (Monad a) => Either e a -> EitherT e m a
09:35:16 <lambdabot> Warning: Unknown type EitherT
09:35:16 <lambdabot> No results found
09:35:20 <skypers> @hoogle (Monad m) => Either e a -> EitherT e m a
09:35:21 <lambdabot> Warning: Unknown type EitherT
09:35:21 <lambdabot> No results found
09:35:30 <skypers> ok, I think it’s just EitherT . return
09:35:42 <bennofs> skypers: I think that's called hoistEither in the errors package
09:35:50 <skypers> indeed!
09:35:56 <skypers> I was looking that function in either
09:35:59 <skypers> it should be in either
09:36:01 <skypers> it’s handy
09:37:46 <acomar> hey, when working with the new TypeLits, are there any useful packages I should get comfortable with?
09:38:05 <acomar> (thinking about adding Nat size info to a container)
09:38:24 <ReinH> skypers: maybe you actually want mmorph?
09:38:46 <bennofs> ReinH: doesn't work for EitherT though
09:38:53 <ReinH> bennofs: ah
09:39:07 <bennofs> ReinH: it only works for transformers t where transformer Identity = base
09:39:24 <ReinH> right
09:40:02 <skypers> http://lpaste.net/102661 ReinH bennofs
09:40:20 <skypers> ti’s lovely[Bnow I think it’s lovely
09:40:47 <popx> I'm trying to install "digest-0.0.1.2" on freebsd from hackage using cabal, but it fails with "Missing (or bad) header file: zlib.h", anyone that knows what I could do about this?
09:43:49 <geekosaur> hrm, zlib should be in the freebsd base system, supposedly
09:43:51 <RPR> popx, Install the zlib (devel) package on your system.
09:43:58 <geekosaur> no devel packages
09:44:04 <geekosaur> it's freebsd
09:46:24 * hackagebot permutation 0.5.0.2 - A library for permutations and combinations.  http://hackage.haskell.org/package/permutation-0.5.0.2 (spacekitteh)
09:46:27 * hackagebot permutation 0.5.0.3 - A library for permutations and combinations.  http://hackage.haskell.org/package/permutation-0.5.0.3 (spacekitteh)
09:47:37 <alltom> How would I go about compiling, and getting type information for, Haskell expressions? I want to make a little type explorer.
09:47:45 <geekosaur> popx: I think we'd need to see more details of what's going wrong; you probably need -v3 to cabal and may need to install it manually (cabal unpack) to capture its config.log
09:47:57 <geekosaur> alltom, the hint package is probably easiest
09:48:10 <alltom> geekosaur: thanks, I'll check that out.
09:48:11 <bennofs> alltom: the hard way is to use the GHC api
09:48:24 <alltom> bennofs: really hard?
09:48:32 <geekosaur> it's a more complex interface
09:48:44 <bennofs> GHC API is not exactly nice to use
09:48:56 <geekosaur> for some things, it's the way to go because it provides more control and more detailed information. for many things, the simplified interface in hint is preferable
09:49:27 <alltom> ahh, understood. thank you.
09:51:11 <skypers> @hoogle await
09:51:12 <lambdabot> System.Posix.Signals awaitSignal :: Maybe SignalSet -> IO ()
09:55:07 <popx> geekosaur: thanks, will try that!
09:58:44 <popx> unpacking and running cabal build -v3 gives me this error "/usr/local/bin/gcc returned ExitFailure 64 with error message: ar: unrecognized option `--plugin'"
10:08:49 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml
10:09:40 <martingale> anyone having trouble install distributive under 7.8.2 osx 10.9
10:20:31 <unsymbol> quit
10:22:32 <quchen> Is there a reason not to use "cabal install -jN --ghc-opts=-jN" for parallel building?
10:22:55 <quchen> The first "j" would be for building packages, the second one for modules.
10:22:58 <Wizek_> Good Morning!
10:23:16 <c_wraith> quchen: probably not, though your choice of each N is going to need to be careful
10:24:02 <Ywen> c_wraith: do you need --ghc-opts=-jN though?
10:24:49 <c_wraith> Ywen: if there isn't enough parallelism available between packages, yes
10:25:03 <c_wraith> Ywen: I mean, if you're only installing 2 packages, and each has 100 modules...
10:25:15 <c_wraith> *cough*HXT*cough*
10:25:28 <Ywen> c_wraith: OK, I believed GHC parallelized by default modules build as from 7.8.1
10:25:50 <c_wraith> Ywen: not by default.  It has the option to do so, but it must be told to do so.
10:26:43 <Ywen> c_wraith: meh, ok so that's why I didn't noticed special improvements when I reinstalled my deps :)
10:26:59 <Wizek_> I have upgraded to GHC 7.8.1, and trying to run one of my programs that I have written for 7.6.3, but it is complaining: "Could not find module ‘Test.HUnit’    Perhaps you haven't installed the "dyn" libraries for package ‘HUnit-1.2.5.2’?" Could the package author need to update to support the new GHC?
10:27:34 <monochrom> c_wraith: hehe
10:27:36 <Ywen> Wizek_: if it's not too long, I think you will have to reinstalled (& rebuild, then) all your packages
10:27:43 <c_wraith> Wizek_: GHC should compile those automatically.  Unless HUnit has some options set that prevent the --dynamic-too library
10:29:12 <Wizek_> So I need to do a `cabal install hunit`?
10:29:21 <Wizek_> and that should solve it?
10:29:56 <c_wraith> GHC compiles packages seperately for each version of GHC.
10:30:10 <c_wraith> There should be no way for GHC 7.8.x to use packages from GHC 7.6
10:32:02 <Wizek_> c_wraith: Hmm. I am not sure wheter they do or not. How can I check?
10:33:06 <Wizek_> (if I run the program with `ghc-7.6.3` from bash it works fine.)
10:33:29 <Wizek_> Ywen: How should I do that?
10:33:39 <geekosaur> right, so you have the module installed for 7.6 but not 7.8, from the sound of it
10:34:16 <Maior> @pl rowToFEN r = snd $ rowToFEN' (0, "") r
10:34:16 <lambdabot> rowToFEN = snd . rowToFEN' (0, [])
10:34:54 <fragamus> > 2**2
10:34:56 <lambdabot>  4.0
10:36:17 <Wizek_> geekosaur: How can I install it specifically for the later version?
10:37:00 <Ywen> Wizek_: doesn't cabal always use the latest version available?
10:37:10 <ChongLi> hey
10:37:40 <ChongLi> is it okay to define instances of Eq and Ord over a record type which ignore some fields in their comparison?
10:37:53 <Iceland_jack> ChongLi: sure, if it makes sense for the comparison
10:37:55 <Wizek_> oh, it could be that my cabal is outdated
10:38:14 <ChongLi> Iceland_jack: I have a record type for email addresses that contains an optional name field
10:38:15 <Iceland_jack> ChongLi: If you, say, represent a set by a list you would 'ignore' duplicates and ordering when comparing
10:38:15 <geekosaur> Wizek_, it generally depends on whether cabal-install knows about the newer ghc or not
10:38:28 <Wizek_> I am trying `cabal install cabal cabal-install `, and it spits out a lot of warnings
10:38:41 <ChongLi> and I want to have a Set of emails that contains only unique email addresses but may contain duplicate names
10:38:47 <geekosaur> if it was installed under an older one, it will be using the Cabal library from the older one and can become quite confused if it encounters a newer ghc
10:39:11 <geekosaur> best is to get all the old stuff out of $PATH and use the bootstrap install to install a new cabal-install against the newer ghc
10:39:12 <Iceland_jack> ChongLi: why not just remove the name from the value?
10:39:27 <ChongLi> the name is pertinent info
10:39:34 <Ywen> Wizek_: What I always do when I update GHC is remove my .cabal & .ghc directories (making sure before my .cabal/config and the 'cabal' executable are saved elsewhere)
10:39:52 <Iceland_jack> You can still store it in a separate data type
10:39:57 <ChongLi> the Set itself is stored and managed by AcidState
10:39:58 <Ywen> then cabal will reinstall everything I need next time I lau
10:40:08 <ChongLi> I don't use the Set directly
10:40:18 <Ywen> Wizek_: next time I launch 'cabal install --only-dependencies'
10:40:38 <Jafet> You can create a newtype wrapper, to change the behaviour of Set.
10:40:41 <Ywen> Wizek_: (just don't forget the 'cabal update' before)
10:41:36 <ChongLi> Jafet: a newtype wrapper around what?
10:41:53 <ChongLi> around my record type?
10:42:17 <Jafet> You can then write whatever Ord instance you want for that wrapper.
10:42:19 <Maior> does anyone have nice refactoring suggestions for https://gist.github.com/doismellburning/10594063 perchance?
10:42:26 <ChongLi> Jafet: ahhh, that makes sense
10:43:08 <ChongLi> newtypes in conjunction with type classes are so cool
10:43:34 <Philonous> Very strange. I'm inside a sandbox, cabal install errors out with unsatisfiable dependencies, but when I run cabal install text first it goes through without a hitch
10:43:52 <Ywen> ChongLi: But they can be dangerous (if you're interested in more details, see GHC type roles for more safety)
10:44:14 <ChongLi> Ywen: oh yeah, GeneralizedNewtypeDeriving
10:44:26 <ChongLi> I will avoid that for the time being
10:44:44 <Ywen> ChongLi: Yep, type roles are meant to come with GeneralizedNewtypeDeriving. I assumed you implied its usage
10:45:50 <ChongLi> man, just had vim hard freeze
10:45:51 <monochrom> http://www.vex.net/~trebla/haskell/Monad.xhtml
10:45:55 <ChongLi> never happened to me before!
10:46:11 <Ywen> Maior: I'm just wondering why you use a tuple as 1st arg for rowToFEN'
10:46:32 * hackagebot network 2.5.0.0 - Low-level networking interface  http://hackage.haskell.org/package/network-2.5.0.0 (JohanTibell)
10:46:37 <ChongLi> probably related to all this ghc-mod, unite.vim and neocomplete.vim nonsense I got going on
10:46:48 <Ywen> Maior: You could just unpack it into 2 args
10:47:01 <Maior> Ywen: good point, habit, thanks
10:48:27 <ikhthiandor> Hi all, I'm having compile errors for this code
10:48:38 <ikhthiandor> http://lpaste.net/102662
10:49:05 <ikhthiandor> the error msgs are this
10:49:11 <ikhthiandor> Prelude> :l quicksort.hs
10:49:13 <ikhthiandor> [1 of 1] Compiling Main             ( quicksort.hs, interpreted )
10:49:17 <ikhthiandor> quicksort.hs:5:30: parse error on input `='
10:49:19 <ikhthiandor> Failed, modules loaded: none.
10:49:21 <ikhthiandor> Prelude> :l quicksort.hs
10:49:23 <ikhthiandor> [1 of 1] Compiling Main             ( quicksort.hs, interpreted )
10:49:27 <ikhthiandor> quicksort.hs:5:30: parse error on input `='
10:49:29 <ikhthiandor> Failed, modules loaded: none.
10:49:45 <ikhthiandor> Can anybody help?
10:49:54 <Ywen> ikhthiandor: looks like you biggerSorted is not aligned with smallerSorted
10:50:00 <Maior> ikhthiandor: you're using tabs with a visible width of 4, aren't you?
10:50:02 <Ywen> ikhthiandor: indentation matters in let blocks
10:50:28 <Maior> (and for anyone reminded of my conversation earlier, well, yeah)
10:50:30 <ikhthiandor> Maior: yes?
10:50:55 <Maior> ikhthiandor: let me see if it's logged anywhere; tl;dr don't do that, use spaces
10:51:05 <Maior> ikhthiandor: indentation is column based, not "level"-based
10:51:30 <geekosaur> ikhthiandor, the key point here is that your `biggerSorted` is further indented than `smallerSorted`, so Haskell thinks it is a continuation of `smallerSorted` instead of a separate binding
10:51:45 <geekosaur> it needs to start in the same column as `smallerSorted`
10:52:17 <Maior> ikhthiandor: and because it's column based, ^I is "align to nearest 8-column" ish
10:52:23 <Maior> (TL;DR don't use tabs)
10:53:02 <ikhthiandor> ok let me adjust the columns
10:53:03 <Maior> so I have some code, and I'm getting an undefined, what're recommended ways to play the "find where the undefined arises from" game?
10:53:41 <Wizek_> Okay, successfully updated cabal and cabal-install, now I am trying to install hspec, but it gives me this error --> https://gist.github.com/Wizek/259d89d617416c9a29bd
10:54:03 <Ywen> Maior: grep -R undefined . ???
10:54:47 <Maior> Ywen: arises from; I have lots of functions that are undefined, but none of them should be involved in these tests
10:55:02 <Maior> a simple grep tells me nothing of value
10:55:04 <Ywen> Maior: Ok
10:55:08 <ikhthiandor> Maior, geekosaur thanks :)
10:55:22 <ikhthiandor> adjusted the indentation using spaces
10:55:30 <ikhthiandor> problem solved now
10:56:01 <Ywen> Maior: undefined being a regular exception raise, you can try compile with profiling activated, so you get a stacktrace
10:56:09 <Maior> Ywen: ah ok, cheers
10:56:27 <ikhthiandor> btw, can you refer the standard way for indentation for haskell or some specification?
10:56:32 <Ywen> Maior: The runtime opt is '+RTS -xc' I believe
10:57:35 <Ywen> Maior: and to compile '-prof -fprof-auto' may be enough
10:58:22 <Maior> Ywen: thanks!
10:58:32 <Ywen> ikhthiandor: Easy: instruction or declaration in blocks should always be aligned
10:59:00 <Ywen> ikhthiandor: if you have a let or a where block, the names declared must be aligned
10:59:32 <Ywen> ikhthiandor: if you have a do block, the instructions should be aligned
10:59:58 <zcourts> Can I somehow coerce a Ptr CUint into an Addr# in order to use unsafePackAddressLen to construct a ByteString
11:00:12 <Ywen> ikhthiandor: each time, the keywork starting the block (let, do, where...) _does not_ matter, it's the _content_ of the block that does
11:01:10 <monochrom> don't coerce. the Ptr contains an Addr# already. but I forgot how to get it.
11:01:44 <zcourts> monochrom: I couldn’t find anything in the docs to extract it
11:02:25 <Jafet> GHC.Ptr exports Ptr(Ptr).
11:02:29 <Ywen> Maior: If that doesn't help, maybe the next step is to try the GHCi debugger
11:04:13 <monochrom> ah, yes, the 2nd Ptr is data constructor. so now you can use pattern matching to get the fields
11:06:56 <tar_> anyone know what happened to tracingDynFlags? I don't think it exists any more in 7.8.1, but I don't know where/how to find/generate docs for what's installed locally
11:08:30 <tar_> actually, I just checked the source (from the docs online) and I think I have been dissuaded from using it. :)
11:09:14 <Maior> @hoogle Int -> [a] -> Maybe a
11:09:15 <lambdabot> Prelude (!!) :: [a] -> Int -> a
11:09:15 <lambdabot> Data.List (!!) :: [a] -> Int -> a
11:09:15 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
11:09:19 <zcourts> Jafet: thanks, monochrom: yup, pattern matching now
11:09:32 <tar_> (but it's used in the examples here http://www.haskell.org/haskellwiki/GHC/As_a_library)
11:09:38 <Maior> do I need to write my own total!!?
11:12:17 <Wizek_> Have anyone run into this? "ld: library not found for -lHSsetenv-0.1.1.1-ghc7.8.1" on OS X 10.9.1 while `cabal install`-ing?
11:14:04 <geekosaur> http://hackage.haskell.org/package/setenv   do you have this sinstalled
11:14:05 <geekosaur> ?
11:15:12 <Ywen> Maior: Regarding your gist, I posted a comment on github
11:15:47 <Ywen> Maior: The only problem is the ugly layout of gihub comments
11:16:42 <Maior> Ywen: you didn't use format tags, that's why, but thanks!
11:19:33 <Ywen> Maior: Yep, I edited it ;)
11:21:34 <Maior> Ywen: thanks :)
11:25:24 <benzap> Hello guys, I was wondering. Can Haskell functions interoperate with C++ (C) at some level easily? Can you create .so / .DLLs from Haskell functions?
11:25:50 <benzap> or at least effectively reference haskell functions from within C?
11:26:11 <benzap> I'd like to write a parser in haskell, and pass the returned structure to within C
11:26:17 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi.html
11:27:40 <benzap> geekosaur: so if i'm getting this right, Haskell runs on it's own runtime, and I need to treat it as an embedded language?
11:27:50 <geekosaur> pretty much, yes
11:27:53 <benzap> ah ok
11:28:29 <geekosaur> although if you are parsing and returning a lump to thereafter be manipulated in C, you don't need to care that much; it's when you have haskell and c calling into each other that things get interesting
11:29:43 <benzap> Interesting, i've done interop between Lua and C, is it kind of the same? Do you just manipulate a stack?
11:36:38 * hackagebot patronscraper 0.0.0.0 - A webpage scraper for Patreon which dumps a list of patrons to a text file.  http://hackage.haskell.org/package/patronscraper-0.0.0.0 (Forkk)
11:46:50 <lucch> Hello.. Could someone please tell me how can I write a function using typeclasses to achieve similar behaviour of using an Interface in Java? I see why I keep getting the error: "Ambiguous type variables...", but I don't know how can I solve it without giving an explicit type signature, which I don't want to.. I'm a Haskell beginner ;)
11:47:32 <geekosaur> you may not be able to; while there are some similarities, haskell's type system is sufficiently different from java's that some things java would let you do won't work
11:50:15 <tibbe> Why is it so hard to get the current time as seconds since epoch in haskell?
11:51:05 <lucch> geekosaur: Right, but is there any alternative way to do that? I was reading about something called "Existential Types"... My problem in specific is: I have two different data types which are both instances of the same typeclass.. So I want to write a function that returns any value which is an instance of that typeclass... Any idea?
11:53:28 <pranz> lucch: f :: C a => ... -> a
11:54:07 <pranz> where C is your typeclass
11:57:12 <tar_> tibbe: I had to do it recently: realToFrac $ utcTimeToPOSIXSeconds time
11:57:40 <tar_> tibbe: took me ages to figure out how, though
11:58:59 <tibbe> tar_: yes, it’s more difficult than it should be
11:59:07 <nstdloop> Is there a binary available for ghc 7.8.2 on OS X?
11:59:13 <nstdloop> I've been trying to build it since last night
11:59:14 <tibbe> since posix time is by far the most commonly used time in my experience
11:59:22 <nstdloop> It really does take a Very Long Time
12:00:31 <tar_> tibbe: depends on your context? I haven't used epoch values directly since PHP.
12:01:03 <zaquest> tibbe: Data.Time.Clock.POSIX (getPOSIXTime)
12:01:23 <tibbe> zaquest: right, the annoying part is to get it to an int :)
12:01:40 <tibbe> zaquest: I figured it out, but it’s more annoying that it should be for such a common operation
12:01:59 <lucch> pranz: Thanks for answering.. I've already tried something similar to that.. Suppose you have two typeclasses (C1 and C2) instead of one and you have data types which are instances of both of them.. Now you have to write a generic function which needs to take any types which are instances of those typeclasses, perform computations based only in the functions defined within those typeclasses and return any value which is an instance of 
12:02:21 <lucch> I suppose the signature of such function would be: f :: (C1 a, C2 a) => ...
12:02:46 <lucch> pranz: Right? But I keep getting "ambiguous blah blah blah" :/
12:03:05 <pranz> lucch: yeah, that signature is right
12:03:28 <tar_> realToFrac was the part that took me forever to find, and I'm not sure what Haskell concepts I don't understand to explain that
12:04:52 <lucch> pranz: to be even more specific.. I have a data type which is an instance of FromJSON.. I want to write a function to parse it to some data type which is an instance of HasContract, because I need to call the function "contract" defined in HasContract so that I can decide what to return..
12:05:47 <pranz> hmm
12:06:01 <lucch> pranz: I tried defining the typeclass HasContract as follows:  class FromJSON a => HasContract a where contract a -> String
12:06:06 <zq> :t (`fmap fmap fmap`)
12:06:08 <lambdabot> parse error on input ‘fmap’
12:06:24 <zq> how do i infixerize triple fmap?
12:06:29 <zq> besides let/where
12:06:39 <lucch> pranz: and wrote the type signature of the function as: f :: HasContract a => ByteString -> IO (Maybe a)
12:07:00 <dwcook> zq, infixing can be applied to single identifiers, not to arbitrary expressions.
12:07:13 <pranz> lucch: can you paste the code?
12:07:14 <dwcook> zq, so one way is "define a new binding and infix that"
12:07:16 <pranz> and the error you get
12:07:24 <lucch> pranz: Yes
12:07:34 <dwcook> :t let fmap3 = fmap fmap fmap in fmap3
12:07:35 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:11:18 <lucch> pranz: you there?
12:11:59 <conal> In GHC 7.8.*, or maybe Cabal 1.18.*, a failing 'cabal build' yields "Last 10 lines of the build log ...", often cutting off the source position (filename & line & column #s). Emacs then can't jump directly to the error in the source. Are there solutions/workarounds?
12:12:53 <conal> I like the quiet when installing from Hackage, but when developing, I prefer the old behavior.
12:13:02 <dcoutts> conal: don't use -j
12:13:27 <conal> dcoutts: oh! thanks. it's in my .cabal/config.
12:13:42 <dcoutts> conal: you beat me to it, I was just going to suggest that
12:14:28 <conal> hm. it's very convenient to have -j in .cabal/config, so i don't have to specify it repeatedly.
12:15:06 <dcoutts> conal: the issue is that these days 'build' can also go and build other packages (e.g. deps in the same sandbox)
12:15:07 <conal> is there a flag to override -j?
12:15:19 <dcoutts> conal: perhaps -j1 but I'm not sure
12:15:46 <dcoutts> so even 'build' is potentially a multi-package install, so it uses the same -j behaviour as install
12:16:47 <conal> i see.
12:17:04 <conal> -j1 also does "Last 10 lines ...".
12:17:07 <che2000> can anyone recommend a good starting tutorial for haskell?
12:19:46 <Cale> @where lyah
12:19:46 <lambdabot> http://www.learnyouahaskell.com/
12:19:48 <Cale> che2000: ^^
12:19:54 <conal> dcoutts: isn't this -j behavior a problem for everyone developing packages, rather than just installing them? wouldn't people generally want -j for anything from hackage (including sandbox deps) but not for local source?
12:20:20 <dcoutts> conal: I agree
12:21:29 <che2000> thanks
12:21:37 <conal> dcoutts: who's involved in this policy? i'd like to raise the issue.
12:21:52 <conal> dcoutts: that is, if you know who.
12:22:43 <dcoutts> conal: I don't think it's a deliberate policy choice, rather a consequence of various impl decisions, and the right approach is to file a ticket and point out what the behaviour is and what you think most people want it to be
12:23:30 <conal> dcoutts: thx. do you think it's a ghc issue or cabal or both or ...?
12:23:42 <dcoutts> conal: oh definitely cabal
12:23:59 <conal> dcoutts: okay. thanks.
12:33:51 <nstdloop> After updating ghc cabal fails at everything. I'm probably doing something silly - what do I have to change?
12:34:09 <dcoutts> nstdloop: upgrade cabal too
12:34:37 <dcoutts> (probably)
12:34:41 <nstdloop> dcoutts: Trying, but that keeps failing with needs "--end=std"
12:34:47 <nstdloop> which it then says is an unrecognized option :/
12:35:02 * dcoutts has no idea what that refers to
12:35:14 <nstdloop> stuff like
12:35:15 <nstdloop> Resolving dependencies...
12:35:15 <nstdloop> Downloading HUnit-1.2.5.2...
12:35:15 <nstdloop> Configuring HUnit-1.2.5.2...
12:35:15 <nstdloop> The build-tool has reset ENV. --env=std required.
12:35:23 <nstdloop> for every package
12:35:27 <nstdloop> when doing cabal install cabal-install
12:35:43 <dcoutts> nstdloop: doesn't look like it's a message from cabal
12:35:59 <dcoutts> I certainly don't recognise it
12:36:08 <nstdloop> It comes up for every package after the configuring step
12:36:15 <che2000> q
12:36:19 <nstdloop> I think it might be a missing flag to ./configure?
12:36:40 <Maior> argh my type of Maybe [Maybe [Maybe x]] is making my head hurt
12:36:45 <dcoutts> nstdloop: most packages don't have a ./configure script
12:37:16 <nstdloop> dcoutts: What could it be?
12:37:22 <nstdloop> More importantly what do I do :)
12:37:50 <dcoutts> https://github.com/Homebrew/homebrew/blob/master/Library/ENV/4.3/cc#L277
12:37:57 <dcoutts> looks like a weird homebrew thing
12:38:18 <dcoutts> nstdloop: check you're running cabal directly
12:38:23 <dcoutts> not via some intermediate script
12:38:52 <dcoutts> oh, hmm, perhaps it's about calling cc/gcc
12:39:36 <nstdloop> uh.. how do I check that?
12:39:55 <dcoutts> nstdloop: no idea, I don't use homebrew/osx
12:40:04 <dcoutts> nstdloop: you can try bootstrapping cabal-install directly
12:40:34 <aristid> idris seems like a dialect of agda
12:40:49 <ruzu> everythings a dialect of everything
12:41:01 <dcoutts> nstdloop: or grab a binary, http://www.haskell.org/cabal/release/cabal-install-1.18.0.3/cabal-x86_64-apple-darwin-mavericks.tar.gz
12:41:06 <aristid> ruzu: no:P
12:42:35 <tar_> how come compiling a module with "a = 42" gives a type Integer, but the type of 42 in ghci is Num a => a?
12:43:12 <Philonous> tar_, The dreaded monomorphism restriction
12:43:24 <aristid> ah, idris has some interesting affordances though
12:43:30 <ruzu> casting through void pointers could be a manual form of structural typing... therefore c and haskell are more or less identical >:)
12:43:39 <tar_> Philonous: "most annoying and controversial feature" cool!
12:43:42 <nstdloop> dcoutts: Grabbed a binary from brew, so I now have the most up to date cabal but it still gives me the same error
12:44:10 <dcoutts> nstdloop: it looks like something weird with your cc/gcc from homebrew
12:44:27 <nstdloop> gcc is 4.8.2
12:44:58 <dcoutts> OSX maveriks doesn't ship gcc itself, and GHC-7.8 doesn't use gcc either now
12:45:21 <nstdloop> aha. It's trying to use /usr/local/Library/ENV/4.3/gcc instead of the gcc I get with which gcc
12:45:28 <nstdloop> let me try and change that in settings..
12:45:45 <Philonous> tar_, You can recover the polymorphic type of a by adding an explicit type annotation: a :: Num a => a; a = 42
12:45:56 <conal> dcoutts: I removed ghc-options:"-j"  from my ~/.cabal/config and am still getting the "Last 10 lines ..." message. Are you sure that message is tied to -j?
12:45:58 <nstdloop> done. that fixed it
12:46:20 <conal> dcoutts: Oh, hm. "cabal build" doesn't do it. Just "cabal install".
12:46:27 <dcoutts> conal: it's not the ghc options, it's cabal's own parallel build
12:46:34 <dcoutts> which is the jobs setting
12:46:36 <dcoutts> in the config
12:47:13 <tar_> Philonous: thank you! though my context is wanting to programmatically get the most general type with hint, so I'm going to try setting NoMonomorphismRestriction.
12:47:50 <conal> dcoutts: oh. thx.
12:48:20 <dcoutts> conal: I'm actually surprised that just removing ghc-options: -j changed anything
12:48:37 <dcoutts> conal: but I also think that newer cabal -j passes -j on to ghc as appropriate (iirc)
12:48:38 <conal> dcoutts: it didn't change anything.
12:49:19 <conal> dcoutts: oh. both flags are called "-j".
12:49:30 <nstdloop> tar_: Just be careful because that means your constants aren't actually constants
12:49:48 <conal> i hadn't noticed the cabal jobs flag.
12:50:32 <srhb> dcoutts: It doesn't yet, I think.
12:50:40 <srhb> dcoutts: You have to pass --ghc-options=-j
12:50:49 <conal> dcoutts: giving "-j1" to "cabal install" works, as you suggest (and I misunderstood).
12:50:54 <tar_> nstdloop: I'm making a toy so I think that's okay? the effect of that is that expressions might be evaluated multiple times, right?
12:51:08 <dcoutts> srhb: probably in the next release (I remember reviewing it)
12:51:15 <nstdloop> Yes. Since it can't tell the type is has to recompute every time.
12:51:21 <nstdloop> Num a => a is not concrete
12:51:23 <nstdloop> basically
12:51:36 <dcoutts> conal: ah right yes. Both mean parallel builds, but different meanings at different levels of the stack.
12:51:44 <conal> dcoutts: sure.
12:52:15 <tar_> got it, thanks
12:52:33 <srhb> dcoutts: That's what I've heard too. and some plans about automatic balancing between them (which sounds crazy nice)
13:00:28 <conal> dcoutts: thanks again for the help. i'm back in business with a tolerable work-around, and hopefully Cabal's behavior will get refined. Filed https://github.com/haskell/cabal/issues/1773 .
13:00:37 <dcoutts> conal: thanks
13:12:21 <ChongLi> anyone here use Snap.Snaplet.AcidState?
13:13:08 <ChongLi> I can't figure out how to nest this snaplet inside another snaplet; the HasAcid class requirement seems to confound me
13:25:34 <zcourts> Was here earlier, extracting an Addr# from a GHC.Ptr and getting “Couldn't match kind `#' against `*’” passing it to unsafePackAddressLen
13:32:32 <fragamus> hey I need cotangent and inverse hyperbolic cotangent   hoogle doesn't seem to have any clues
13:33:18 <Jafet> You probably want the bindings to glsl.
13:33:50 <fragamus> glsl?
13:34:08 <Cale> fragamus: cot x = 1 / tan x
13:34:13 <fragamus> yes
13:34:24 <fragamus> but what about...
13:34:37 <fragamus> ArcCoth
13:34:41 <Jafet> I don't know what a hyperbolic tangent or cotangent is, unless you can write it using exp.
13:34:41 <Cale> fragamus: arccoth x = (1/2) * (log (1 - 1/x) - log (1 + 1/x))
13:34:47 <Cale> er
13:34:49 <Jafet> Then you wouldn't need glsl.
13:34:55 <Cale> fragamus: arccoth x = (1/2) * (log (1 + 1/x) - log (1 - 1/x))  rather
13:34:58 <bincalc> I am writing a TCP abstraction layer, kind of, making it possible to declaratively define TCP application protocols. 2 problems that all TCP app protos need to solve are: 1. How to divide the bytestream into messages (by for example a delimiter sign or a message length). 2. Timeouts. So for problem (2), what construct do you recommend, Control.Concurrent.Timer?
13:35:20 <fragamus> dang dude lemme test that
13:36:15 <Cale> or arctanh (1/x)
13:36:19 <Cale> :D
13:36:26 <Cale> of course, haha
13:36:35 <Cale> :t atanh
13:36:36 <lambdabot> Floating a => a -> a
13:36:40 <Cale> yeah, that one's there
13:38:09 <Jafet> I sometimes wonder what all these "hyperbolic" functions are used for.
13:38:37 <enthropy> they are used for convenience
13:39:37 <enthropy> when you write programs you make up names for functions that come up often
13:39:55 <cdk> @pl \m f -> lift m >>= f
13:39:55 <lambdabot> (>>=) . lift
13:41:18 <Jafet> Ok, it seems that they are solutions to a handful of physical problems.
13:41:59 <maroloccio> using ghci, which gives me nice readline-like editing, but with no "history". how do i enable that? sorry if it's a FAQ
13:42:05 <Jafet> But if all you want is a rescaler, tanh seems arbitrary.
13:44:02 <bincalc> repeater = do
13:44:03 <bincalc>   print "hej"
13:44:03 <bincalc>   T.oneShotTimer repeater 5000
13:44:13 <bincalc> how do I achieve that?
13:45:03 <srhb> bincalc: replicateM 5000 putStrLn "hej"
13:45:10 <srhb> replicateM_ even
13:45:33 <startling> bincalc, what would that code do?
13:45:35 <srhb> bincalc: Alternatively, you take an argument that counts down each time your call your function recursively
13:45:47 <srhb> At least, if I understand what you mean :P
13:45:55 <Turl> hey guys
13:46:00 <keko_> I think 5000 is supposed to mean "5 seconds"
13:46:00 <startling> I think it's supposed to sleep.
13:46:03 <srhb> Oh
13:46:19 <keko_> and the code's supposed to print Hej, wait 5 seconds, print Hej again and terminate
13:46:35 <monochrom> threadDelay? threadDelay 5000 means 0.005 seconds :)
13:46:36 <jakex> it will not terminate
13:46:36 <keko_> or actually, keep repeating it
13:46:39 <Turl> can anyone help me wrap my mind around this? http://lpaste.net/102665
13:46:47 <keko_> because it sets the timer again, right
13:47:40 <Turl> trying to show print kind of gets stuck on a loop or something as well
13:47:46 <Turl> show tree*
13:48:40 <bincalc> it should keep repeating it forevetr
13:49:02 <srhb> bincalc: repeater = putStrLn "hej" >> threadDelay 5*10^6 >> repeater
13:49:17 <srhb> If that's microseconds and you want a 5 second delay
13:49:23 <srhb> I can never remember.
13:49:30 <monochrom> that is right
13:49:45 <srhb> bincalc: Oops, precedence
13:49:52 <srhb> bincalc: repeater = putStrLn "hej" >> threadDelay (5*10^6) >> repeater
13:49:56 <startling> alternatively "repeater = do { putStrln 'hej'; threadDelay whatever; repeater; }"
13:50:15 <ruzu> what does hej mean
13:50:18 <srhb> "hi"
13:50:22 <srhb> In Scandinavian.
13:50:32 <ruzu> scandi-what?
13:50:37 <Turl> any idea guys? :)
13:50:44 <ruzu> :P
13:50:46 <srhb> ruzu: Yes.. :P
13:50:56 <bincalc> why does not oneShotTimer work?
13:51:07 <srhb> bincalc: I don't know what oneShotTimer is
13:51:13 <srhb> bincalc: Where did you get it from?
13:51:14 <startling> Turl, I don't understand your question.
13:51:34 <Turl> startling: why does the type change when I run an a -> a function?
13:51:49 <startling> Turl: what type?
13:51:55 <Turl> startling: see the paste
13:51:59 <jakex> startling 'hey'? :)
13:52:05 <Turl> the tree type changes
13:52:09 <mm_freak_> hi there
13:52:14 <startling> Turl: I see the paste.
13:52:20 <startling> Turl, you're talking about delRoot?
13:52:20 <jakex> too much python
13:52:28 <mm_freak_> newtype ReaderT s m a = ReaderT { readerT :: m a }
13:52:32 <mm_freak_> ask :: forall e m s. (Monad m, Reifies s e) => ReaderT s m e
13:52:37 <mm_freak_> is this predefined somewhere?
13:52:39 <Turl> startling: after running delRoot, the type "breaks" or something
13:52:41 <srhb> bincalc: If it's from timers, I think you need to wrap your delay with the Delay constructor
13:52:42 <startling> Turl, "let tree = delRoot tree" this is a recursive binding. I don't think you want it to be.
13:52:46 <mm_freak_> TaggedT might work…
13:52:55 <Turl> startling: ah, that may be it
13:52:57 <srhb> bincalc: But threadDelay is the defacto standard here.
13:53:08 <Turl> startling: that kinda explains why it iterates infinitely when I want to show it
13:53:13 <startling> heh
13:53:32 <srhb> bincalc: It's in base, Control.Concurrent
13:53:45 <startling> Turl, () is the default Ord, so that's why it's being inferred like that
13:53:57 <Turl> startling: ah :)
13:53:58 <startling> Turl: (defaults are an old gross thing, don't worry about them)
13:54:09 <Turl> startling: yeah that was it, it works if I use tree2
13:54:16 <Turl> I really didn't expect it to define recursively
13:54:23 <startling> Turl: it's a common error.
13:54:27 * Turl is still thinking imperatively at times
13:54:44 <Turl> many thanks startling
13:54:46 <startling> Turl, -Wall will whine about it in compiled code. not sure if it will in ghci, though.
13:54:56 <startling> Turl: no problem! Let us know if there's anything else.
13:55:34 <monochrom> it is not so much imperativeness than abusing "="
13:55:39 <monochrom> s/than/as/
13:55:49 <mm_freak_> i have found a number of cases when MonadReader's insistence on 'local' was bad and no case so far, when it was good
13:55:55 <mm_freak_> please remove 'local' from MonadReader
13:56:18 <mm_freak_> and while we're at it, please remove 'pass' and 'listen' from MonadWriter
13:56:19 <startling> What's wrong with 'local'?
13:56:20 <srhb> mm_freak_: What's bad about it?
13:56:56 <mm_freak_> startling, srhb: pretty much no reader monad other than the traditional ReaderT and ((->) e) support it
13:57:11 <mm_freak_> but there are a number of useful monads that do support 'ask', like the one above
13:57:12 <monochrom> you're unlikely to cause any change by suggesting here. suggest on the libraries mailing list instead.
13:57:14 <haasn> magnify > local
13:57:30 <mm_freak_> monochrom: i don't believe that a suggestion there will help either =)
13:57:52 <mm_freak_> so i reduce it to useless ranting =)
13:57:53 <startling> mm_freak_: hm, I see.
13:57:59 <srhb> bincalc: Did you solve it? :)
13:58:29 <startling> I guess there's no reason you can't just run a Writer instead of using local.
13:58:36 <startling> Writer{,T}
13:58:46 <startling> er, Reader{,T}
13:58:49 * startling coffee
13:59:01 <mm_freak_> startling: i don't understand
14:00:40 <startling> mm_freak_, you can "ask >>= \r -> runReaderT (f r) a" rather than "local f a" if the type of that action is suitably polymorphic.
14:01:56 <startling> I think one of those parameters is backwards.
14:02:12 <startling> I always forget that the runXT functions use the stupid order.
14:02:17 <mm_freak_> startling: that's not the point
14:02:41 <startling> mm_freak_: my point is "local is not that useful anyhow, so there's no harm in getting rid of it"
14:02:45 <mm_freak_> i can't use lens' 'view' with that one, because i can't make it a MonadReader
14:03:01 <startling> haha
14:03:10 <benmachine> mm_freak_: I don't share your pessimism re: the libraries list
14:03:47 <edwardk> mm_freak_: i do kind of wish that MonadReader (and MonadWriter) had been split up originally
14:03:47 <mm_freak_> benmachine: i might be overpessimistic =)
14:03:47 <benmachine> mm_freak_: it would be a hard sell because you might break code, but changes have been made to the Monad* classes not so long ago
14:04:10 <edwardk> benmachine: all the changes so far have been monotonic improvements like adding state, etc.
14:04:21 <benmachine> edwardk: true
14:04:27 <monochrom> ghc has grown so huge so that we need the latest compressor (xz) to compress it :)
14:04:55 <mm_freak_> edwardk: perhaps it's time for a separate library of effect classes
14:05:12 <Eduard_Munteanu> Why in the world none of the HTTP libs exposes a parser?
14:05:27 <edwardk> we do probably have a breaking change in mtl's future to make it not export Control.Monad for you. that will be a major bump. exporting Control.Monad naked from each of them leads to all sorts of weird qualifications in user code
14:05:53 <edwardk> and with the new PVP stance on not exporting third party moduls without depending on minor versions is harder to defend these days, even than it already was
14:06:08 <exicer> I'm using hmatrix. I have a symmetric, invertable matrix. When I take the inverse, it is not longer symmetric. What is going on ?
14:06:10 <Eduard_Munteanu> I'm using 'HTTP' and it seems there's no header field parser (one that breaks it into tokens for things like Connection:)
14:08:06 <mm_freak_> in fact i don't see a reason to have a Monad constraint on MonadReader
14:08:16 <mm_freak_> class FunctorEnv e f where ask :: f e
14:08:24 <mm_freak_> class (Functor f) => FunctorEnv e f where ask :: f e
14:08:43 <zq> @hoogle MonadPlus m => (a -> Bool) _> m a
14:08:43 <lambdabot> Warning: Unknown type >
14:08:43 <lambdabot> No results found
14:08:46 <zq> @hoogle MonadPlus m => (a -> Bool) -> m a
14:08:46 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
14:08:47 <lambdabot> Test.QuickCheck.Gen suchThat :: Gen a -> (a -> Bool) -> Gen a
14:08:47 <lambdabot> Test.QuickCheck suchThat :: Gen a -> (a -> Bool) -> Gen a
14:08:56 <dcoutts> Eduard_Munteanu: Network.HTTP.Headers ?
14:09:22 <mm_freak_> zq: \f -> (>>= guard . f)
14:09:32 <meretrix> Eduard_Munteanu: I'm pretty sure you can inspect the headers with http-conduit.
14:09:33 <Eduard_Munteanu> dcoutts: that does give me a field value, but the field isn't split into tokens
14:10:01 <Eduard_Munteanu> Surely there's a parser somewhere in there, but they don't expose it.
14:10:04 <dcoutts> Eduard_Munteanu: I'm not sure it can be done generically though, isn't it different for different fields?
14:10:53 <Eduard_Munteanu> dcoutts: it is, but that's more of a reason to just expose the parsers, especially if it's a HTTP 'token'.
14:10:58 <zq> mm_freak_: danke schon
14:11:14 <mm_freak_> zq: gerne ;)
14:11:24 <zq> wait what no
14:11:30 <zq> guard returns m ()
14:11:32 <zq> i wanted m a
14:11:33 <mm_freak_> zq: it probably misses a (<$)
14:11:51 <zq> :t (>>= guard . (`elem` [1..4]))
14:11:52 <lambdabot> (MonadPlus m, Num a, Eq a, Enum a) => m a -> m ()
14:11:56 <mm_freak_> zq: you probably want this:  (a -> Bool) -> (a -> m a)
14:11:56 * hackagebot haskell-src-exts 1.15.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.15.0 (RomanCheplyaka)
14:12:30 <mm_freak_> zq: \p x -> if p x then pure x else empty
14:12:51 <dcoutts> Eduard_Munteanu: well it provides various functions from Request/Response that extract certain fields
14:12:58 <zq> :t \f x -> if f x then mzero else  return x
14:12:59 <lambdabot> MonadPlus m => (a -> Bool) -> a -> m a
14:13:05 <dcoutts> Eduard_Munteanu: in a structured form
14:13:20 <mm_freak_> zq: you've inverted the logic
14:13:45 <Eduard_Munteanu> dcoutts: yes, but there isn't one to extract e.g. the field*s* of the Connection header.
14:13:53 <zq> mm_freak_: didn't see yours before hitting enter
14:14:10 <zq> i'm guessing that there's no built-in haskellese brevity for that
14:14:22 <mm_freak_> zq: no worries…  Bool is extremely difficult to get right
14:14:45 <dcoutts> Eduard_Munteanu: no, it seems it's so simple it doesn't bother with a formal parser
14:14:48 <Eduard_Munteanu> Connection = "Connection" ":" 1#(connection-token)
14:14:54 <Eduard_Munteanu> connection-token  = token
14:15:05 <dcoutts> Eduard_Munteanu: the HTTP.Browser module for example just uses
14:15:05 <dcoutts> let doClose = any (== "close") $ map headerToConnType headers
14:16:57 * hackagebot haskell-names 0.3.3.1 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.3.1 (RomanCheplyaka)
14:17:07 <haasn> (a -> Maybe b) -> a -> m b
14:17:12 <haasn> actually, Maybe a -> m a
14:17:18 <haasn> that is the API I would suggest.
14:17:36 <zq> haasn: that for me?
14:17:43 <Eduard_Munteanu> dcoutts: ouch, that sounds unsafe
14:17:48 <haasn> :t maybe mzero pure
14:17:49 <lambdabot> (Applicative m, MonadPlus m) => Maybe a -> m a
14:17:57 <haasn> :t maybe mzero return
14:17:58 <lambdabot> MonadPlus m => Maybe a -> m a
14:18:05 <Eduard_Munteanu> I guess I should blame HTTP for being overly complex.
14:18:11 <haasn> zq: yes, rather than (a -> Bool)
14:18:16 <Eduard_Munteanu> (the protocol)
14:18:39 <haasn> Bonus points if it's a monad morphism
14:18:53 <zzzzzzzziiii> "because there is no way to apply an arrow that is itself yielded by another arrow" this is from the arrow calculus paper. Can anyone eloborate
14:19:05 <zzzzzzzziiii> *elaborate why?
14:20:06 <enthropy> @type app
14:20:08 <lambdabot> ArrowApply a => a (a b c, b) c
14:21:10 <Guest_> Is there an easy way to remove all the work done by a previous version of cabal working with a previous version of ghc?
14:21:10 <enthropy> pretty much they are saying that you can't write app in terms of methods of the other Arrow classes
14:21:27 <nstdloop> ^ was nstdloop
14:22:32 <monochrom> yes nstdloop, read my http://www.vex.net/~trebla/haskell/sicp.xhtml
14:22:55 <zzzzzzzziiii> enthropy, that's why they introduced a new constant 'app' for arrows with apply? ok
14:23:15 <haasn> I think “maybe mzero return” is a monad morphism due to the MonadZero laws
14:23:32 <haasn> Nothing is mzero
14:26:58 * hackagebot HueAPI 0.1.3 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0.1.3 (SjoerdVisscher)
14:28:14 <monochrom> dons has been sighted on haskell-cafe today! said "go ahead update this package I no long maintain" :)
14:28:28 <Eduard_Munteanu> Are there any comparisons between regexp vs combinator based parsers, performance-wise? How easy is it to optimize combinators rather than regexps?
14:28:31 <monochrom> we need a dons sighting club :)
14:29:43 <monochrom> "I saw dons and elvis together at this spa..." :)
14:30:03 <mm_freak_> zzzzzzzziiii: ArrowApply arrows are actually families of monads, and if your arrow is an ArrowApply you could just as well use the corresponding monad
14:31:06 <mm_freak_> Eduard_Munteanu: combinator parsers are thin layers around regular functions, so in general they are easier to get fast
14:32:27 <mm_freak_> Eduard_Munteanu: in fact you can "compile" a regular expression to a parser, although i guess the usual regex compiler compiles it to some form of bytecode
14:32:27 <zzzzzzzziiii> mm_freak_, yes i read about that, i just don't get why in arrow calculus i cannot write app
14:32:45 <mm_freak_> zzzzzzzziiii: because arrows aren't expressive enough
14:33:36 <Eduard_Munteanu> mm_freak_: hm, I suspected that, but given regexps can be minimized isn't that an advantage over parser combinators?
14:34:35 <Eduard_Munteanu> mm_freak_: AFAICT you can translate regexps to combinators but not every combinator is a (known) regexp thingy.
14:35:19 <mm_freak_> Eduard_Munteanu: regular expressions (real ones, not what perl and co. sell you as them) are regular languages
14:35:40 <mm_freak_> Eduard_Munteanu: parser combinators cover those as well as a number of other grammars:  context-free, context-sensitive, etc.
14:36:49 <Eduard_Munteanu> Parser combinators are pretty much arbitrary computations.
14:36:56 <Jafet> Heh "real regular expressions", as opposed to "perl regular expressions"
14:37:07 <mm_freak_> Eduard_Munteanu: but not for arbitrary grammars
14:37:17 <Eduard_Munteanu> Hm.
14:37:47 <mm_freak_> Eduard_Munteanu: i believe that every grammar that parsec can parse is decidable
14:38:12 <mm_freak_> but not every decidable grammar can be parsed by parsec…  for example you need to hack around left-recursion
14:38:48 <mm_freak_> and then of course there are undecidable grammars
14:39:09 <mm_freak_> generate a random number n between 0 and 3999, open RFC n
14:39:19 <mm_freak_> there is about a 9/10 probability that it defines an undecidable grammar =)
14:41:27 <Eduard_Munteanu> But could you ever optimize parser combinators like regexps are optimized? I suspect it might be possible to extract a regexp from Free Parser or something like that.
14:42:15 <mm_freak_> Eduard_Munteanu: you're dealing with regular functions…  parser combinators can be as fast as a functional parser can get
14:42:18 <joelteon> hey, anybody here super familiar with conduit?
14:42:36 <mm_freak_> Eduard_Munteanu: you can perform a Codensity/Yoneda transformation to speed it up
14:42:53 <mm_freak_> also you can use an applicative parser with builtin early failure
14:43:43 <mm_freak_> essentially what arrows were originally developed for =)
14:44:53 <mm_freak_> Eduard_Munteanu: in other words, if the regexp is faster, either your combinator library uses a slow representation or your parser sucks =)
14:46:44 <Eduard_Munteanu> mm_freak_: well, with attoparsec you usually try to backtrack as little as possible, which can lead to overly complex code.
14:47:05 <mm_freak_> Eduard_Munteanu: attoparsec's problem is that it has builtin backtracking
14:47:35 <mm_freak_> Eduard_Munteanu: you can use pipes-parse instead
14:48:17 <Eduard_Munteanu> Hm, I should try it. Also trifecta sometime.
14:48:37 <mm_freak_> trifecta will be about as fast as attoparsec, but has much nicer diagnostics
14:49:36 <mm_freak_> if you really need more speed, you should probably write your own small parser combinator library that only supports what you need
14:50:07 <Eduard_Munteanu> Nah, attoparsec is fast enough.
14:50:37 <mm_freak_> perhaps a Codensity/Yoneda-transformed version of this:  newtype Parser m a = forall r. Parser { runParser :: StateT (Producer ByteString m r) (MaybeT m) a }
14:51:04 <mm_freak_> (the transformation should make the existential go away)
14:51:21 <mm_freak_> and yeah, it's a data, not a newtype, but the transformed one is a newtype
14:52:27 <joelteon> never mind, I figured it out! thanks #haskell
14:52:45 <mm_freak_> joelteon: our pleasure =)
14:52:48 * ruzu pets joelteon
14:56:25 <srhb> trifecta is as fast as Attoparsec? I never knew.
14:56:48 <edwardk> attoparsec is faster because it doesn't have to do anything for error message tracking
14:56:59 <srhb> Ah.
14:57:42 <srhb> Guess I'll have to check it out. :-)
14:57:59 <bitemyapp> edwardk: was does "tracking" mean here?
14:58:05 <bitemyapp> knowing where the error came from in the original AST?
14:58:14 <startling> bitemyapp, source positions
14:58:26 <bitemyapp> gatcha.
14:58:29 <bitemyapp> startling: thanks.
14:58:30 <edwardk> bitemyapp: just that attoparsec gives you no real error messages. trifecta and parsec do, but they pay a price for it
14:58:39 <bitemyapp> Cool. TIL
14:58:41 <bitemyapp> edwardk: thank you :)
14:58:53 <edwardk> attoparsec backtracks all the time so 'blame' assignment for parse errors is well, basically impossible
14:59:32 <edwardk> parsec and trifecta have slightly different semantics for blame, but they can tell you what failed to parse and what could have been supplied instead
14:59:59 <edwardk> i tend to write to the 'parsers' API, then i can pick the instance later on
15:00:12 <bitemyapp> edwardk: I wondered if that was part of the point for it.
15:00:24 <bitemyapp> being able to flip a debug switch on/off is cool too.
15:00:29 <edwardk> yeah
15:00:42 <edwardk> it also lets me sanity check my parsers
15:03:16 <Peaker> could be nice if attoparsec could re-parse something more slowly if an error occurred, to give better messages
15:10:08 <tar_> Is there an IO () that doesn't do anything?
15:10:18 <Peaker> tar_: return ()
15:10:30 <Peaker> tar_: "return" generates monadic actions that don't "do" anything
15:10:32 <tar_> d'oh, that makes sense, thank you :)
15:11:08 <Eduard_Munteanu> tar_: one of the monad laws mandate 'return' to do nothing, btw.
15:11:11 <Peaker> tar_: the Monad laws say that if you bind "return" and a monadic action in any monad, it's like using the other action directly.  i.e: return is forced by the monad laws to do nothing.
15:11:16 <Eduard_Munteanu> Heh.
15:11:17 <Peaker> Eduard_Munteanu: 2 of them! :)
15:11:54 <Peaker> hmm.. it's probably enough to pick either of the first 2 laws to guarantee return does nothing?
15:12:04 <tar_> ahh, thank you!
15:12:54 <monochrom> it is trivial to conjoin 2 laws and call it 1 law.
15:13:13 <monochrom> this is why I can say things like "the average type class comes with 4.783 laws"
15:13:20 <joneshf-laptop> so if i want to check a file existing and do something based on that, but don't want the result tobe in IO, what are my options?
15:13:37 <Eduard_Munteanu> Hm, the (bilateral) "identity" law, I suppose.
15:14:26 <Eduard_Munteanu> joneshf-laptop: none... why not in IO?
15:15:00 <joneshf-laptop> im in Writer
15:15:44 <Eduard_Munteanu> joneshf-laptop: use the WriterT transformer then, e.g. WriterT w IO a
15:16:16 <Eduard_Munteanu> Assuming you're calling it from some IO function.
15:16:18 <monochrom> what do you "do based on that"?
15:17:11 <Eduard_Munteanu> Alternatively you may do the check somewhere else in IO, put the result somewhere inside a pure structure and hand that over to your pure Writer.
15:22:05 * hackagebot muon 0.1.0.0 - Static blog generator  http://hackage.haskell.org/package/muon-0.1.0.0 (kaashif)
15:29:17 <Taslem> How are you supposed to get around the fact that  hIsEOF  can block?
15:30:18 <Peaker> Taslem: async it?
15:30:45 <Eduard_Munteanu> Taslem: why would you use it on something that can block?
15:30:53 <Taslem> Good point
15:31:06 <Taslem> How can you tell if input is available on a handle?
15:31:27 <monochrom> perhaps you like hIsReady
15:31:38 <Eduard_Munteanu> Taslem: for what purpose?
15:32:06 * hackagebot muon 0.1.0.1 - Static blog generator  http://hackage.haskell.org/package/muon-0.1.0.1 (kaashif)
15:32:08 <Taslem> I'm writing a toy webserver-like project, and I want to be able to wait for client input, and in the meantime, do other tasks.
15:32:24 <Jafet> You do not use hIsEOF to tell whether there is input.
15:32:45 <Eduard_Munteanu> Taslem: use a separate thread that does blocking I/O on the handle
15:32:47 <monochrom> I would not even bother. I would use a thread to go ahead read. it may block, I intend it so. it may throw an exception for hitting EOF, I will catch it. that is how I know.
15:32:50 <Jafet> The easiest way to tell whether there is input is to try and read it.
15:32:53 <joelteon> is there a package that tries to assume MIME types from file extensions?
15:32:57 <hpc> you might also try the async package
15:33:06 <joelteon> maybe MIME
15:33:28 <hpc> joelteon: http://hackage.haskell.org/package/mime-types-0.1.0.4/docs/Network-Mime.html
15:33:37 <hpc> mimeByExt
15:33:48 <joelteon> cool, thanks
15:33:53 <joelteon> props to hpc
15:33:57 <joelteon> excellent tool
15:34:15 <Eduard_Munteanu> Taslem: the idea is to read from the handle and write the chunks to an MVar, Chan or something like that
15:34:43 <hpc> joelteon: if you mean haskell program coverage, that's an unfortunate name collision :P
15:34:53 <Eduard_Munteanu> The chunks or some parsed, self-contained messages.
15:35:10 <joelteon> hpc: well I like you both
15:35:17 <Taslem> That is essentially what I am doing, actually. I'm just concerned about the potential for the client to hang for a while, and wanted a way to tell if that happened.
15:35:26 <Eduard_Munteanu> (Of course, the MVar may be shared with other producers)
15:36:59 <Eduard_Munteanu> Taslem: you could attempt to do a nonblocking read, either on the handle or MVar, e.g. tryTakeMVar
15:37:06 * hackagebot muon 0.1.0.2 - Static blog generator  http://hackage.haskell.org/package/muon-0.1.0.2 (kaashif)
15:37:32 <Taslem> What happens if a nonblocking read fails?
15:37:41 <Eduard_Munteanu> @hoogle tryTakeMVar
15:37:41 <lambdabot> Control.Concurrent.MVar tryTakeMVar :: MVar a -> IO (Maybe a)
15:37:47 <Eduard_Munteanu> You get a Nothing.
15:38:31 <Jafet> Just create a new thread and let the thread block, what is the problem?
15:39:08 <Jafet> If you want a timeout, create another thread with a timer.
15:40:00 <Taslem> Yeah, I guess that makes sense.
15:44:12 <jakex> is there a forM_ equivalent that iterates through Map?
15:44:20 <jakex> or mapM
15:45:34 <srhb> Does Map not have a functor instance?
15:45:59 <Eduard_Munteanu> :t Data.Foldable.forM_
15:45:59 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
15:46:20 <Eduard_Munteanu> :t Data.Traversable.mapM
15:46:21 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:46:40 <jakex> thanks
15:46:41 <srhb> :t mapM
15:46:42 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:46:56 * srhb doesn't get it
15:47:00 <srhb> What's wrong with mapM?
15:47:15 <jakex> it accepts [a]
15:47:18 <srhb> oh, lol
15:47:20 * srhb is blind
15:47:22 <jakex> :)
15:47:23 <srhb> That's horrid.
15:47:35 <Eduard_Munteanu> jakex: you could mapM over toList's output though
15:48:46 <ReinH> Data.Map has instances for Foldable and Traversable
15:49:04 <jakex> Eduard_Munteanu I thought about doing that, I am just not sure what the overhead would be (for example, would the full list be allocated in memory?)
15:49:49 <Eduard_Munteanu> It could fuse away, but not sure in this particular case.
15:49:55 <Jafet> Yes, but each cell is collected as soon as it is created.
15:51:11 <Eduard_Munteanu> toList :: Map k a -> [(k, a)]  O(n). Convert the map to a list of key/value pairs. Subject to list fusion.
15:51:47 <Eduard_Munteanu> (but that depends on other fusion rules as well)
15:52:25 <flebron> Hey. If I don't need split, what's the recommended way to model randomness these days?
15:52:29 <Eduard_Munteanu> Likely it does happen for fromList . map f . toList and such.
15:53:00 <flebron> I don't need cryptographic security either. Speed is good, but easy-to-use API would be best.
15:55:23 <eyebloom> Are there any environments similar to Coq where one can work through reductions and various program transformations in a Haskell like syntax?
15:55:26 <ReinH> Eduard_Munteanu: can't you just use void and forM from Traversable?
15:55:31 <ReinH> > let forM_ xs f = void (forM xs f) in forM_ [1] return :: Identity ()
15:55:33 <lambdabot>  Identity {runIdentity = ()}
15:55:44 <Eduard_Munteanu> eyebloom: Agda?
15:56:30 <Eduard_Munteanu> ReinH: I'm not the OP :)
15:56:36 <ReinH> oh it's in Foldable
15:56:45 <ReinH> So... use that?
15:56:46 <ReinH> Eduard_Munteanu: true
15:56:55 <ReinH> just surprised no one was suggesting it
15:57:06 <ReinH> Eduard_Munteanu: oh you did
15:57:14 <ReinH> I go away now
15:57:15 <Eduard_Munteanu> ReinH: well, it works, but Foldable is weaker
15:57:51 <Jafet> eyebloom: so, basically every theorem prover ever?
15:58:17 <Eduard_Munteanu> Agda is probably the closest to Haskell. Idris too, perhaps.
15:58:36 <ReinH> Eduard_Munteanu: ah
15:58:59 <eyebloom_> I'm just curios if there is one that is a little more friendly if what I really want to do is take some Haskell statements and reduce them step by step
15:59:21 <Eduard_Munteanu> Oh, that's something else.
15:59:23 <eyebloom_> Haskell expressions I mean
15:59:27 <Jafet> For learning haskell, no. Though benm tried to write something
16:00:33 <eyebloom> I'm three years in on Haskell now so it's really about testing hypothesis about various supercompiler designs by looking at various cases.
16:03:05 <eyebloom> It could also be done with pretty simple lambda calculus terms, i.e. I don't need typeclasses or complex types.
16:03:37 <Jafet> applybot: lemma "dropWhile P (dropWhile P xs) = dropWhile P xs" by (induct xs) auto
16:03:37 <applybot>  *** Unrecognized command
16:03:53 <Jafet> applybot: lemma "dropWhile P (dropWhile P xs) = dropWhile P xs"
16:03:55 <applybot>  Proving: 1. dropWhile P (dropWhile P xs) = dropWhile P xs
16:04:09 <Jafet> applybot: apply (induct xs) by auto
16:04:13 <applybot>  QED: lemma dropWhile ?P (dropWhile ?P ?xs) = dropWhile ?P ?xs
16:04:29 <eyebloom> Nifty
16:04:30 * joseph07 applauds
16:05:44 <eyebloom> Jafet: What are you using?
16:07:22 <Jafet> That is isabelle, which is much closer to coq than haskell
16:07:58 <eyebloom> I see, would you prefer Isabelle to Coq
16:08:03 <eyebloom> ?
16:08:36 <eyebloom> And is there a way to see the reduction step by step?
16:08:53 <Jafet> Both are about as ugly as they are widely-used.
16:09:20 <Jafet> What "reduction" do you want to see, and why do you want to see it?
16:10:21 <Jafet> Reductions in lambda calculus are usually trivial (especially when all terms have normal forms)
16:11:01 <eyebloom> It's more about being able to force certain substitutions
16:11:36 <eyebloom> Essentially being able to decide which functions to unfold and when
16:12:12 <Jafet> If a term has a normal form, it doesn't matter which reduction you do first, the result is the same.
16:13:14 <eyebloom> applybot: lemma "map (\x->x) xs = xs"
16:13:35 <applybot>  *** Timed out
16:14:20 <Jafet> applybot: timeout 60 -- pff
16:14:20 <applybot>  Command timeout is 60 s.
16:14:34 <eyebloom> applybot: lemma *map (\x->x) xs = xs*
16:14:34 <applybot>  *** Unrecognized command
16:14:46 <Jafet> applybot: lemma "map (%x. x) xs = xs" try0
16:14:47 <applybot>  *** Outer lexical error: bad escape character in string at x->x) xs = ...  \  (During: 'lemma "map (%x. x) xs = xs" ')
16:15:03 <Jafet> Meh, you broke it
16:15:39 <eyebloom> It doesn't read \ as lambda
16:15:51 <Jafet> Regardless, what happens when you "decide to unfold" a different thing?
16:16:35 <eyebloom> I'm mostly concerned about when induction is attempted, not in the steps of normalizing reductions
16:18:09 <eyebloom> I used Isabelle with some success a few years ago via Proof General. I was just curious if there was something less automated and more haskell like.
16:20:39 <Jafet> There is not enough context for me to figure out what you are asking about
16:23:29 <eyebloom> Basically I'm working on transforming expression in GHCs core language. Sometimes it's helpful to see how various examples will react to various transformation strategies and it would be useful to work through those examples on a computer rather than on paper.
16:24:21 <eyebloom> But Coq and Isabelle are really very different from Haskell and have a lot of features more relevant to big proofs
16:24:33 <Jafet> I don't think you need a theorem prover for that, you just need a little program that understands core and how to evaluate core.
16:24:40 <Jafet> @where stepeval
16:24:41 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
16:27:28 <Jafet> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=foldr+%28%2B%29+0+[1%2C2%2C3]
16:28:59 <eyebloom> Does this include recursive let?
16:29:40 <Jafet> This is a toy program, it includes very few things.
16:29:50 <eyebloom> I think it does...
16:30:00 <eyebloom> Thanks very much for pointing this out.
16:30:09 <Jafet> (Value-sharing being not one of them)
16:30:43 <Jafet> Actually, ghc already implements this, as part of the ghci debugger. That should be authoritative.
16:57:16 * hackagebot prednote 0.22.0.2 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.22.0.2 (OmariNorman)
17:09:58 <pyon> @hoogle Arrow arr => (x1 -> y1) -> (x2 -> y2) -> arr x1 x2 -> arr y1 y2
17:09:58 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
17:10:26 <pyon> no, wait
17:10:42 <pyon> I entered the wrong thing and lambdabot gave me the right thing?
17:11:07 <pyon> @hoogle Arrow arr => (x1 -> y1) -> (x2 -> y2) -> (x1, x2) -> (y1, y2)
17:11:07 <lambdabot> Did you mean: (x1 -> y1) -> (x2 -> y2) -> (x1, x2) -> (y1, y2)
17:11:07 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
17:11:29 <bitemyapp> dalaing: improved the gist based your recommendation of Yorgey's course. https://gist.github.com/bitemyapp/8739525
17:11:30 <roconnor> hoogle has actually always done unifcationish searching
17:12:54 <pyon> :-O
17:13:18 <pyon> Anyway, Hoogle knew what I wanted much better than I knew myself. No idea if I should be happy or creeped out. :-|
17:13:37 <magicman> @hoogle Arrow arr => arr a b -> arr x y -> arr (a,x) (b,y)
17:13:37 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
17:14:05 <pyon> oh, that
17:14:08 <pyon> Thanks.
17:14:20 <pyon> I knew the truth was somewhere there.
17:14:20 <pyon>  
17:14:44 <nstdloop> How can I print Int#s in ghci?
17:16:13 <Jafet> Apply Int# to them.
17:20:28 <fragamus> hey any of you guys use linear?
17:20:36 <fragamus> I need to know the best way to take a v2 and rotate it around the origin by an angle
17:24:02 <carter> fragamus: matrix mult rotates
17:24:06 <carter> use math
17:24:07 <carter> :)
17:24:23 <fragamus> yeah
17:24:54 <saml_> rotate clockwise?
17:25:11 <saml_> @google how to rotate a vector by angle forumlar
17:25:13 <lambdabot> http://forum.unity3d.com/threads/18485-Rotating-a-Vector-by-an-eular-angle
17:25:13 <lambdabot> Title: Rotating a Vector by an eular angle?
17:25:31 <saml_> i think you need cosine and stuff
17:25:32 <fragamus> i know the math but I want my code to look like ed kmett wrote it
17:26:38 <saml_> @google who is ed kmett
17:26:38 <lambdabot> https://github.com/ekmett
17:27:00 <saml_> use lens then
17:27:06 <saml_> he invented lens theory
17:27:15 <fragamus> yeah i know lol
17:27:24 <edwardk> nah, i just borrowed it from others and refined it.
17:27:25 <fragamus> he also wrote linear
17:27:49 <saml_> edwardk is ed kmett!
17:27:55 <fragamus> OMG!
17:27:59 <augur> edwardk: i had occassion to suggest lens to someone earlier
17:28:23 <augur> http://www.reddit.com/r/dependent_types/comments/22y6wb/oh_my_even_human_linguists_are_using_dependent/cgrkroo
17:28:33 <saml_> i think it makes sense. you have a vector. but when you look at it through a lens, it is rotated
17:28:49 <fragamus> edwardk: any suggestions on creating an M2 rotation matrix
17:29:16 <mdxbhmt> Excuse me, is there a default place where people can put code for criticism? Or plain /r/haskell?
17:29:17 <fragamus> or other way to do that math without spelling it out
17:29:20 <edwardk> i don't think i have an angle -> V2 vector combinator in linear. we have euler angles for quaternions, just not something similar for V2. there are Complex instances though, so you can get the right complex number by using e^ix to get the rotation
17:29:32 <augur> mdxbhmt: hpaste
17:29:34 <augur> or is it lpaste
17:29:35 <edwardk> but that doesn't give you V2.
17:29:37 <augur> what do we call it these days
17:29:39 <augur> @where hpaste
17:29:40 <lambdabot> http://lpaste.net/new/haskell
17:29:54 <edwardk> i'd happily take a patch that added an angle combinator to Linear.V2 though
17:30:02 <augur> mdxbhmt: be sure to tell people about it tho!
17:30:05 <mdxbhmt> augur, oh right, I have the code on github already
17:30:17 <augur> mdxbhmt: oh, well then, reddit is probably good
17:30:23 <mdxbhmt> That's what I need! where to find the people D:
17:30:31 <mdxbhmt> Ok, thanks!
17:31:46 <edwardk> here let me just write it ;)
17:32:36 <edwardk> adding it to linear now
17:34:16 <edwardk> shipped 1.10.1 has 'angle'
17:34:36 <mm_freak_> i'm glad that i call angles 'ang' mostly =)
17:34:46 <edwardk> mm_freak_: heh
17:35:08 <mm_freak_> but fromAngle would probably be a better name anyway =)
17:36:01 <edwardk> possibly. not a big fan of fromFoo/toFoo, but id be open to changing it later if we decided to start making things to compute said angle, etc.
17:36:26 <edwardk> probably would rather just give you an isomorphism to complex then you can use all the Data.Complex.Lens tricks though
17:37:15 <mm_freak_> yeah
17:37:24 * hackagebot linear 1.10.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.10.1 (EdwardKmett)
17:38:09 <mm_freak_> "it makes sense…  you have a cigarette…  but when you look at it through a lens it looks like a teddybear"
17:38:41 <mm_freak_> oh, we're in the era of van laarhoven
17:38:47 <mm_freak_> "it makes sense…  you have a cigarette…  but when you look at it through a lens it looks like a hundred teddybears"
17:39:40 <edwardk> when you look at it through a traversal it looks like a hundred teddybears ;)
17:41:42 <mm_freak_> you ruined my joke =P
17:46:26 <augur> mm_freak_: i dont get your joke
17:47:25 * hackagebot simple-session 0.8.0.1 - Cookie-based session management for the Simple web framework  http://hackage.haskell.org/package/simple-session-0.8.0.1 (AmitLevy)
17:49:20 <fragamus> edwardk: can you point me to a combinator that I can use as a model for my v2 rotation
17:49:42 <edwardk> fragamus: i just added one in 1.10.1 for you. 'angle'
17:49:49 <mm_freak_> augur: egypt ~700 BC:  when you look at a tree through a lens you see a slightly bigger tree
17:49:50 <fragamus> lol
17:50:05 <mm_freak_> netherlands ~1500 AD:  when you look at a tree through a lens you see a leaf
17:50:31 <mdxbhmt> is there convex\concave lens?
17:50:34 <mdxbhmt> hahaha
17:50:38 <fragamus> thanks edwardk
17:50:53 <mm_freak_> glasgow ~2000 AD:  when you look at a tree through a lens you see a leaf
17:51:03 <edwardk> we thought about trying to distinguish prisms from pierce style lenses by making one concave and one convex, but decided against it
17:51:07 <mm_freak_> netherlands ~2010 AD:  when you look at a tree through a lens you see every leaf
17:52:13 <fragamus> by the way edwardk, i used some mathematica code to find common subexpressions and achieve a nice compact expression
17:52:42 <fragamus> http : // stoney.sb.org/wordpress/wp - content/cvt2c/
17:53:09 <edwardk> nice. =) i think someone was hacking on a CSE plugin for ghc you could enable, not sure what happened to it
17:53:39 <crocket> hi
17:53:40 <mm_freak_> GHC does CSE by itself, but only when it can guarantee that space behavior will not be worse
17:53:44 <crocket> Haskell is rising!!!
17:53:53 <bitemyapp> crocket: uh. hi.
17:54:20 <crocket> The haskell mark looks like a kanji character 入.
17:55:03 <fragamus> This thing tries 9 differect simplification strategies, then estimates the performance of each, and uses the fastest one
17:55:03 <bitemyapp> crocket: that's a lambda mate.
17:55:20 <crocket> bitemyapp, Can you see 入?
17:55:20 <bitemyapp> crocket: it's a greek symbol oft used in mathematics and CS.
17:55:22 <fragamus> so my source code is an integral in mathematica
17:55:26 <bitemyapp> crocket: I can see your kanji just fine.
17:55:32 <bitemyapp> crocket: but in Haskell you're thinking of a lambda.
17:55:38 <fragamus> and then I have a series of transformations that turns it into haskell
17:55:39 <bitemyapp> this guy: λ
17:55:41 <bitemyapp> that's a lambda.
17:56:00 <crocket> 入 λ
17:56:12 <crocket> It seems to be a universal symbol.
17:56:26 <mm_freak_> crocket: '>>=' + 'λ' = '>λ='
17:56:27 <crocket> 人　λ　入
17:56:49 <zq> that's chinese for "man"
17:57:11 <zq> does hurry-coward hold for type class constraints too?
17:57:24 <crocket> ㅋㅂ : 男人
17:57:25 <zq> curry-howard*
17:57:30 <Welkin> 从人入
17:57:31 <crocket> zq : 男人
17:57:48 <mm_freak_> zq: hurry-coward…  it doesn't hold at all for haskell
17:57:51 <zq> i'm impressed that my vterm can display chinese
17:58:05 <Welkin> it's unicode
17:58:08 <mm_freak_> zq: constraints are really just implicit values
17:58:17 <mm_freak_> so unrelated to curry-howard
17:58:34 <Welkin> crocket, he meant human, not "male"
17:58:43 <Jafet> @quote kmc Curry-Howard
17:58:43 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
17:58:44 <zq> mm_freak_: yeah, but constraints look a lot like proofs
17:58:48 <crocket> 人
17:58:52 <Welkin> universal "man"
17:58:57 <zq> rather, deductive inferences
17:59:01 <crocket> Can haskell be used as a system programming language?
17:59:10 <Welkin> sure, why not?
17:59:11 <mm_freak_> zq: "curry-howard" = "proof = value"
17:59:23 <BMeph> crocket: Can, and has.
17:59:27 <Jafet> That depends on what system you want to program.
17:59:30 <Welkin> there is an operating system written in haskell
17:59:40 <zq> sel4 is written in c
17:59:41 <geekosaur> someone wrote a sound driver for one of the bsds using ajhc; there's an os (house) written in haskell
17:59:46 <pyon> ZipList is not an Alternative, right?
17:59:48 <mm_freak_> zq: but you can't write many meaningful propositions in haskell, so C-H is in general not very useful in haskell
17:59:49 <crocket> Rust vs Haskell in system programming.
17:59:55 <zq> haskell was just an intermediate in the refinement process
18:00:15 <crocket> zq : If haskell was an intermediate, what is the destination?
18:00:18 <bitemyapp> crocket: Rust and Haskell are designed for different problem domains.
18:00:19 <pyon> crocket: Right now I am using Haskell (yes, a programming language, not English) to document my Rust project.
18:00:21 <Welkin> machine language
18:00:22 <Welkin> of course
18:00:29 <zq> mm_freak_: i meant something like, ToJSON a => ToJSON [a] |- ToJSON [a] => ToJSON [[a]]
18:00:34 <Welkin> everything is an intermediate to bits
18:00:56 <crocket> Welkin, Humans don't pretend to understand bits.
18:01:07 <crocket> Machines understand bits.
18:01:08 <Welkin> sure we can
18:01:11 <nstdloop> I keep getting this error:
18:01:13 <nstdloop> cabal: The package 'package' requires Cabal library version -any && >=1.10
18:01:17 <nstdloop> but no suitable version is installed.
18:01:26 <Welkin> it's just an equation you plug your inputs into
18:01:27 <nstdloop> even though I have cabal version "cabal-install version 1.18.0.3"
18:01:48 <mm_freak_> zq: sure, but if you view 'ToJSON a' as a proposition, then what's your interpretation of it?  what does an instance prove?
18:01:49 <Welkin> how do you think people design computers?
18:01:56 <bjz> pyon: how does that work?
18:02:08 <Welkin> people used to program solely in binary
18:02:20 <zq> mm_freak_: uh, tojson a wasn't theproposition
18:02:32 <pyon> bjz: The idea is that I use Haskell to identify algebraic structures of interest, and then translate them to Rust.
18:02:36 <Welkin> programming in machine code (hex, usually) is just as easy as assembly
18:02:40 <bjz> pyon: nice
18:02:44 <zq> mm_freak_: rather, it was 'if [a] is a tojson then [[a]] is as well'
18:02:51 <nstdloop> Anyone?
18:02:52 <bjz> pyon: but why not use somethinbg like agda for that?
18:02:53 <crocket> Is haskell better than C in system programming language-wise?
18:03:02 <fragamus> edwardk: thanks for doing that, but FYI, what I was trying to do is take an existing V2 and rotate it about the origin by a given angle
18:03:09 <Welkin> crocket, why are you asking non-questions?
18:03:10 <pyon> bjz: Because the point is to get immediate feedback.
18:03:12 <zq> mm_freak_: it's trivial but just an example; tojson has loads more interesting lemmas
18:03:17 <Welkin> of course haskell is much safer than C
18:03:23 <bitemyapp> Welkin: people like this crop up all the time.
18:03:35 <mm_freak_> zq: well, it's an instance of C-H, but you're not really proving anything meaningful w.r.t. C-H
18:03:43 <Welkin> "Can haskell walk my dog and make my breakfast!?"
18:03:51 <crocket> Welkin : What about performance?
18:03:54 <joelteon> @faq can haskell walk my dog?
18:03:55 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
18:03:57 <Welkin> it is as fast or faster
18:04:00 <joelteon> wait, that's not the one.
18:04:02 <Twey> @faq Can Haskell walk my dog and make my breakfast?
18:04:02 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
18:04:02 <joelteon> What's the command?
18:04:04 <srhb> joelteon: :< It's gone
18:04:06 <Welkin> there are no performance issues
18:04:08 <joelteon> Oh
18:04:09 <srhb> joelteon: It was faq indeed.
18:04:10 <joelteon> damn
18:04:13 <Twey> What?  A *useful* FAQ?
18:04:24 <crocket> Welkin : I'm surprised that haskell is as fast as C.
18:04:26 <zq> mm_freak_: maybe i should rephrase my original question: does c-h let us think of type class constraints as propositions?
18:04:27 <srhb> Yeah, I find it unacceptable too.
18:04:33 <Welkin> you are living in the 70's if you think that "you must use C to get practical performance"
18:04:37 <bjz> crocket: I'm sure opinions vary, but Haskell doesn't give you as much low level control as C. That can make some things easier or some things harder depending on the domain
18:04:59 <mm_freak_> zq: in a sense
18:05:00 <Jafet> zq: you can make a logic system out of instance resolution, but nobody really cares.
18:05:04 <zq> crocket: latency != throughput
18:05:07 <srhb> bjz: Well, then there's Atom etc.
18:05:15 <crocket> bjz : If I need low level control, I can use Rust instead of C.
18:05:26 <bjz> crocket: yes
18:05:28 <nstdloop> Can anyone help me with my cabal issue?
18:05:30 <mm_freak_> zq: think of the Monoid class as:  data Monoid a = Monoid { mappend :: a -> a -> a, mempty :: a }
18:05:30 <bjz> crocket: or ATS
18:05:33 <joelteon> Rust's performance is pretty crap right now
18:05:35 <zq> Jafet: the logic system is non-trivially useful
18:05:39 <lfairy> nstdloop: cabal-install (the executable) is orthogonal to Cabal (the library). What does `ghc-pkg list Cabal` say?
18:05:39 <mm_freak_> zq: then "Monoid a =>" becomes "Monoid a ->"
18:05:52 <Jafet> (As an extreme example, UndecidableInstances gives you an undecidable logic)
18:05:55 <Welkin> crocket, you can also use assembly
18:05:59 <Welkin> or forth
18:05:59 <bjz> joelteon: it is on the bignum stuff, but that is a library problem
18:06:04 <mm_freak_> zq: 'Monoid' is obviously a parametric proposition, but it takes a proposition as argument
18:06:05 <crocket> Is haskell useful for client-side programming?
18:06:12 <Welkin> or any other of the several dozen suitable low-level languages
18:06:14 <nstdloop>    Cabal-1.18.1.3
18:06:16 <srhb> crocket: Yes. Haskell is useful for all kinds of programming. :P
18:06:19 <mm_freak_> zq: the instance is then a proof of that proposition
18:06:19 <zq> mm_freak_: derp, i was asking for validity beyond a simple character substitution
18:06:29 <joelteon> Haskell is a general-purpose programming language.
18:06:52 <joelteon> It can often approach C's performance if you sacrifice idiomatic code. It's unlikely to be *faster* than C.
18:07:01 <joelteon> If you want to write Heartbleed, use C.
18:07:02 <mdxbhmt> Can haskell get me upvotes on reddit?
18:07:02 <bjz> joelteon: most of the other stuff is on par with C and C++, and there is nothing stopping the gap closing - those langs have had decades of work put into their compilers
18:07:05 <Welkin> it can be faster than C
18:07:10 <Welkin> C is not a benchmark
18:07:11 <mm_freak_> zq: the character substitution is what actually happens with type classes…  a class context really just means that there is an implicit argument that is selected by the compiler
18:07:13 <joelteon> mdxbhmt: Yes! Haskell can do that.
18:07:21 <johnw> bjz: decades of work and many, many millions of dollars too
18:07:23 <Welkin> everything is compiled down to assembly
18:07:24 <crocket> A client-side langauge needs to be compiled into javascript.
18:07:28 <monochrom> @quote monochrom faster
18:07:28 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
18:07:30 <nstdloop> lfairy: and cabal install cabal says I already have the latest
18:07:31 <srhb> crocket: See Fay.
18:07:33 <mdxbhmt> joelteon, :)
18:07:33 <Welkin> the assembly is the benchmark
18:07:43 <crocket> Welkin : Or interpreted.
18:07:47 <crocket> Fau
18:07:48 <crocket> Fay
18:08:01 <srhb> crocket: Or GHCJS
18:08:03 <bjz> johnw: indeed. but I think the langs make it difficult to make any further optimisations
18:08:06 <crocket> PureScript is also like Haskell.
18:08:11 <srhb> OK.
18:08:19 <mm_freak_> you don't need to sacrifice idiomatic code to be faster than C
18:08:32 <bjz> johnw: better type systems could help alot, like Rust's, or some future hypothetical lang
18:08:36 <mm_freak_> all you need is array operations or parallelism, which haskell+LLVM handles better than C =)
18:08:40 <Welkin> C as a pseudo-benchmark needs to go away
18:08:42 <bitemyapp> I'd recommend Purescript if you need to do JS for now.
18:08:55 <bjz> bitemyapp: Purescript looks super yummy
18:08:56 <bitemyapp> better options may arise later, but right now, it's the best available for most use-cases.
18:08:57 <bjz> :P
18:08:57 <lfairy> nstdloop: ghc-pkg check?
18:09:00 <joelteon> mm_freak_: Oh, that's news to me
18:09:01 <bitemyapp> bjz: it really is.
18:09:02 <crocket> bitemyapp, Is Fay immature?
18:09:03 <mm_freak_> for JS i recommend haste
18:09:08 <bitemyapp> bjz: it's also really easy to get started with.
18:09:10 <mm_freak_> or idris
18:09:11 <rasfar> nstdloop: maybe pass -v to your build and see if a different version is being used for some reason?
18:09:20 <bjz> bitemyapp: Elm too, but it looks to have a much heavier runtime
18:09:24 <bitemyapp> mm_freak_: I wouldn't. Haste is nigh-on fucking impossible to install.
18:09:28 <srhb> Fay is nice because of data type sharing, I don't think that is possible with purescript
18:09:36 <bitemyapp> srhb: 'ish?
18:09:39 <bjz> bitemyapp: is purescript lazy by default?
18:09:43 <srhb> bitemyapp: Oh?
18:09:49 <edwardk> fragamus: you can make a rotation matrix:   rotation phi = V2 (V2 c (negate s)) (V2 s c) where s = sin phi; c = cos phi
18:09:58 <edwardk> fragamus: then use matrix multiplication
18:10:19 <bjz> pyon: interesting
18:10:24 <fragamus> thanks!
18:10:28 <jakex> why isn't when's type `Monad m => Bool -> m a -> m ()'  or `Monad m => Bool -> m a -> m a'?
18:10:31 <jakex> :t when
18:10:32 <lambdabot> Monad m => Bool -> m () -> m ()
18:10:33 <bitemyapp> srhb: Fay's lack of typeclasses is crippling. You can share very basic data declarations and typeclasses in Purescript.
18:10:37 <edwardk> fragamus: assuming i remembered the formula for a 2d rotation matrix correctly
18:10:39 <nstdloop> lfairy: ghc-pkg check gives nothing
18:10:44 <bjz> pyon: just curious is all. unfrotunately Rust's syntax makes it harder to sketch out the types :(
18:10:46 <mm_freak_> joelteon: https://twitter.com/ertesx/status/449983416428396544
18:10:47 <fragamus> yes you did
18:10:53 <bitemyapp> srhb: no, it's not strict Haskell but if you use the shared intersecting subset of Purescript and Haskell it works fine for basic RPC conversations.
18:10:57 <srhb> bitemyapp: Alright :)
18:10:58 <Twey> jakex: How would you produce an m a in the false case?
18:10:58 <nstdloop> rasfar: You mean cabal install -v?
18:11:09 <Twey> jakex: It could be → m a → m (), though.
18:11:13 <rasfar> that would work I think, yes
18:11:27 <bjz> bitemyapp: does Fay have extensible records?
18:11:39 <jakex> Twey good point. but yeah, with  m a -> m ()   we could avoid void $ in some cases
18:11:40 <mm_freak_> bitemyapp: i found haste rather easy to install
18:11:42 <bjz> bitemyapp: ie. row polymorphism yumminess?
18:11:44 <bitemyapp> bjz: if you want extensible records, Fay is not for you.
18:11:51 <bjz> bitemyapp: ah ok
18:11:54 <bitemyapp> bjz: Fay is a subset of Haskell *only*
18:12:00 <bitemyapp> bjz: only purescript adds stuff.
18:12:07 <mm_freak_> bitemyapp: i really just cabal-installed it and it worked out of the box
18:12:13 <bitemyapp> GJCJS, Haste, and Fay are respectively shrinking subsets of Haskell.
18:12:17 <bitemyapp> GHCJS*
18:12:22 <bjz> bitemyapp: I heard those can help if you don't have type classes or a good module system
18:12:27 <crocket> huh
18:12:27 <bitemyapp> mm_freak_: you're like, the only person. Congrats.
18:12:30 <mm_freak_> i might write a nix expression for it soon so that you can install it easily as well =)
18:12:32 <crocket> bitemyapp, What do you recommend?
18:12:37 <bitemyapp> bjz: but you have type-classes in purescript anyway.
18:12:39 <edwardk> that could also probably be done with rotation phi = transpose $ V2 a (perp a) where a = angle phi  -- but that isn't as nice
18:12:42 <lfairy> jakex: but m a -> m () could throw away useful data
18:12:42 <bjz> bitemyapp: yep
18:12:46 <nstdloop> rasfar: I can't really do that
18:12:46 <bitemyapp> bjz: so why not just use that? I don't need laziness in JS anyway.
18:12:52 <bitemyapp> or at least, implicit/universal laziness.
18:12:58 <rasfar> nstdloop: how come?
18:13:03 <bjz> bitemyapp: I don't want laziness :)
18:13:06 <bitemyapp> bjz: welp.
18:13:11 <bjz> :)
18:13:12 <nstdloop> I'm working on trying to get Haste to compile on my machine and this happens during the execution of haste-boot, which does the build inside of... something
18:13:23 <mm_freak_> bitemyapp: i often do stuff with haskell that other think is impossible =P
18:13:24 <rasfar> ah
18:13:26 <nstdloop> and I can't just cabal install inside the source for this particular library
18:13:31 <nstdloop> because it's ghc-prim
18:13:34 <Jafet> lfairy: m () -> m () throws away useful programs.
18:13:37 <nstdloop> so cabal just says you can't do that
18:13:48 <rasfar> crap
18:13:50 <bitemyapp> mm_freak_: keep puffing yourself up like that and you might pop :)
18:13:58 <edwardk> the transpose is because we're row-based and we'd need the transformed angle as a column
18:14:00 * bitemyapp makes expanding hands gesture
18:14:09 <edwardk> heading off to watch cosmos. bbiab
18:14:11 <nstdloop> rasfar: Let me try one more thing.
18:14:56 <Jafet> http://i.imgur.com/j74SykU.gif
18:15:08 <mm_freak_> bitemyapp: come on, you gotta give me credit…  i even proved false…
18:15:38 <mm_freak_> and i decided and undecidable instance!
18:15:46 <Welkin> I forgot about the remake of cosmos
18:15:47 <crocket> Does GHCJS make javascript concurrent?
18:15:50 <Welkin> I should watch that
18:16:03 <Welkin> but tonight, Game of Thrones!
18:16:26 <mm_freak_> crocket: i think it does…  would be interesting to know if it can use web workers though
18:16:28 <bitemyapp> crocket: javascript is already concurrent.
18:16:33 <bitemyapp> mm_freak_: you don't want that.
18:16:44 <bitemyapp> mm_freak_: web workers are really slow for control-oriented use-cases.
18:16:51 <bitemyapp> using them automagically would be horrific.
18:17:02 <bjz> bitemyapp: at least, not laziness by default. idris is nice in that regard
18:17:04 <nstdloop> rasfar: Nope. Nothing. Does anyone know a lot about haste here?
18:17:10 <bitemyapp> web workers are like the opposite of what you want for "green threading"
18:17:14 <crocket> It seems GHCJS is buggy?
18:17:15 <mm_freak_> bitemyapp: even if you use a preallocated group of them?
18:17:26 <mm_freak_> bitemyapp: just like the usual linux RTS does
18:17:29 <bitemyapp> mm_freak_: yeah, it's communication threshold latency among other things.
18:17:33 <mm_freak_> i see
18:17:36 <bitemyapp> mm_freak_: it's pretty awful.
18:17:38 <bitemyapp> startup is bad too.
18:17:44 <bitemyapp> you can't use them for anything.
18:18:08 <bitemyapp> You need programmer directed yield semantics, which Haste and GHCJS don't accommodate.
18:18:13 <bjz> bitemyapp: but yeah, what I really want is not a js lang, but an embeddable scripting lang with an expressive, modern type system. can't really find one.
18:18:30 <rasfar> nstdloop: all i've got is, there seems to be possibly related issue here: https://github.com/valderman/haste-compiler/issues/129  although the error is different.
18:18:33 <bitemyapp> bjz: how is purescript not appropriate for you?
18:18:38 <mm_freak_> bjz: embeddable into what?
18:18:43 <lfairy> and has anyone brought up elm?
18:18:56 <bitemyapp> lfairy: yeah but it has issues.
18:19:14 <lfairy> bitemyapp: what are the issues? I'm curious.
18:19:23 <bjz> mm_freak_: in places where luajit is used, for example. like in a game engine for scripting
18:19:24 <mm_freak_> i don't like elm's reactive model
18:19:50 <mm_freak_> bjz: in a haskell game engine you can use haskell as your scripting language
18:19:50 <bitemyapp> lfairy: it has a baked in reactive model that isn't suitable for all cases. It's not really a proper full language and doesn't have the power a proper dialect of Haskell or something like Purescript would have.
18:19:58 <bjz> mm_freak_: I want to embed something in my native game (written in Rust)
18:20:01 <nstdloop> rasfar: that looks similar. The error he gets is what happens if I try to just to go the ghc-prim directory and cabal install
18:20:04 <rasfar> (so you could try exposing a different version of cabal-install to haste-boot with your path, maybe)
18:20:09 <nstdloop> but I have 1.18 anyway
18:20:12 <nstdloop> not 1.19
18:20:51 <conal> mm_freak_: i'm always suspicious of non-embedded domain-specific languages. too many places to go wrong, and not enough discipline to steer by.
18:20:53 <rasfar> nstdloop: ^ any old version kicking around?
18:20:55 <bjz> mm_freak_: I was working on a typed concatenative lang, like Cat
18:21:13 <bjz> mm_freak_: but I would rather not roll my own
18:21:18 <mm_freak_> conal: commenting on what?  elm?
18:21:19 <nstdloop> rasfar: Nope, I cleaned house earlier when updating to 7.8.2
18:21:28 <conal> mm_freak_: yes.
18:21:36 <jakex> how can i prevent cabal from trying to build documentation for my program (not a library)?
18:21:37 <rasfar> it'd be worth a try
18:21:45 <crocket> bitemyapp, How is it concurrent? webworkers?
18:21:46 <nstdloop> Is there something I could change in ghc-prim.cabal that might make this go away?
18:21:46 <conal> mm_freak_: plus abandoning continuous time :(
18:22:33 <mm_freak_> conal: elm's main issue is Signal…  somehow people think it's a good idea to unify behaviors and events into a single concept
18:23:15 <bitemyapp> crocket: event loop + callbacks
18:23:16 <conal> mm_freak_: yeah. i keep hearing that. but never while keeping the properties i care about. sigh.
18:23:40 <conal> mm_freak_: usually not keeping either (continuous & implementation-independent denotation).
18:23:46 <crocket> bitemyapp, They are actually synchronous.
18:23:49 <rasfar> nstdloop: there isn't much to tinker with is there? is that rts constraint too old? you could try ==1.* perhaps
18:23:51 <crocket> I mean they are asynchronous.
18:23:57 <crocket> I mean they are asynchronous but don't make threads.
18:24:18 <crocket> bitemyapp, event loops don't need additional threads.
18:24:38 <claudiyoh> why isn't integral also part of the show typeclass? when would you not be able to show an integral number as a string?
18:24:55 <nstdloop> "Warning: ghc-prim.cabal: A package using section syntax must specify at least
18:24:55 <nstdloop> 'cabal-version: >= 1.2'."
18:24:55 <mm_freak_> conal: the unification destroys the properties you want…  there is no way to unify behaviors and events /and/ be FRP
18:25:05 <rasfar> (nstdloop: I envy you; can't wait for the opportunity to upgrade my GHC too)
18:25:15 <nstdloop> rasfar: What platform are you on?
18:25:46 <mm_freak_> conal: but i remember being flamed in this very channel for saying that elm is not FRP =)
18:25:47 <conal> mm_freak_: not that i've found. and i don't think anyone else has either.
18:25:52 <rasfar> I forget the name of platform (2013 something) -- GHC 7.6.3 (i386)
18:26:21 <mm_freak_> conal: not sure what you mean
18:26:23 <conal> mm_freak_: it's one of many examples of what i call "functional, reactive programming", rather than "FRP".
18:26:37 <rasfar> built from source -- but this machine is on its last legs, so I thought I'd await a replacement before the next platform/ghc build!
18:27:22 <nstdloop> Ah. That makes sense.
18:27:30 <mm_freak_> conal: fair enough…  and it's probably still better than event callbacks
18:27:35 <conal> mm_freak_: I mean i haven't found a way to unify the two main types and keep the main properties of FRP. and i don't think anyone else has, but many who've tried don't  know or don't mind.
18:27:54 <conal> mm_freak_: sure. it's better than some things and worse than others.
18:27:55 <jakex> my cabal project is set as executable, why is cabal running haddock to build documentation for it? and how to prevent it from doing that?
18:28:01 <mm_freak_> conal: i think heinrich conclusively showed on stackoverflow that it's impossible
18:28:04 <conal> mm_freak_: which isn't saying much.
18:28:20 <conal> mm_freak_: oh? i think i missed that SO.
18:28:44 <mm_freak_> conal: http://stackoverflow.com/questions/22989253/frp-event-streams-and-signals-what-is-lost-in-using-just-signals
18:28:51 <conal> mm_freak_: thx.
18:29:38 <mm_freak_> conal: it's not a formal proof, but it shows the inherent incompatibility of the two concepts
18:30:15 <mm_freak_> and it shows why you have to give up continuous time semantics when you combine them
18:32:26 <conal> mm_freak_: do you follow John L's argument on that SO? Particularly "TX is the set of all times t at which Events are defined". I wonder what makes him think that TX is anything less than all of continuous time.
18:35:17 <mm_freak_> conal: john's viewpoint (he's a stream processing guy) probably ignores the existence of actually continuous behaviors
18:36:12 <conal> mm_freak_: maybe so. weird. haskellers routinely program with infinite structures. i wonder what makes continuity so big a leap?
18:36:38 <c_wraith> conal: disbelief that continuity is well-founded. :)
18:37:03 <crocket> Is GHCJS ready for web applications?
18:38:20 <conal> c_wraith: we've specifying continuous systems for hundreds of years, using finite formal systems.
18:38:22 <sjy> are we talking about continuity as in the epsilon-delta definition?
18:38:32 <mm_freak_> conal: with most FRP/RP frameworks defining something as simple as 'time :: Behavior Time' is anything from difficult to impossible, and i have found many people to disregard this well-defined concept because of that
18:38:54 <crocket> Yo?
18:39:01 <mm_freak_> but then in netwire and yampa 'time' is easy to define
18:39:29 <conal> mm_freak_: as if the concept doesn't make sense because some systems don't implement it?
18:39:52 <conal> mm_freak_: it might be because many programmers think operationally rather than abstractly & denotationally.
18:39:54 <mm_freak_> conal: "doesn't make sense", "is useless", "is too expensive", …
18:40:20 <conal> mm_freak_: ... "hurts to think about".
18:40:25 <mm_freak_> =)
18:40:52 <conal> mm_freak_: all of these statements are about the speaker rather than about (continuous) frp.
18:41:38 <conal> translates to "i don't understand", "i don't know how to use", "i don't know how to implement efficiently", ...
18:41:56 <mm_freak_> conal: to be honest i haven't found a way to get behaviors to be both continuous, first class and efficient at the same time yet
18:42:07 <mm_freak_> s/both/all of/
18:42:14 <augur> mm_freak_: lol i see
18:42:33 <mm_freak_> conal: my current compromise is to give up first classness
18:42:38 <pyon> conal: I am not very familiar with FRP. But, the idea behind continuous time is that "how stuff is discretized" is an implementation detail, right?
18:42:39 <mm_freak_> i.e. AFRP
18:42:41 <conal> mm_freak_: we didn't used to know how to do a lot of things, including efficient non-strict evaluation.
18:42:50 <mm_freak_> pyon: right
18:42:53 <conal> pyon: exactly.
18:43:09 <pyon> Sounds perfectly reasonable to me.
18:43:37 <conal> pyon: it's a post-composition sampling. just like rasterization after composing spatially continuous graphics (e.g., vector and Pan's model).
18:43:55 <mm_freak_> conal: and i'm not giving up anyway…  i'm happy to get rid of arrows as soon as possible =)
18:43:55 <pyon> In fact, in one of my first jobs I had to painstakingly implement simulations in C++, and often I would think to myself "I want to decouple the discretization from the continuous model".
18:43:58 <conal> it has the same sort of modularity benefits that laziness has.
18:44:04 <conal> mm_freak_: :)
18:44:13 <conal> pyon: glad to hear.
18:44:54 <conal> in time or in space, premature discretization thwarts composability and complicates semantics.
18:45:20 <rasfar> word
18:45:57 <rasfar> (although having per-frame barrier is sometimes convenient)
18:47:06 <mm_freak_> rasfar: the nice thing is that you can have that barrier without giving up continuous time semantics
18:47:24 <mm_freak_> all you have to do is to generalize continuity to the topological sense, and i'm working on it =)
18:48:04 <rasfar> Abstract Stone Duality?
18:49:00 <pyon> conal: Perhaps continuous-time FRP would be more attractive to a wider audience, especially a performance-sensitive one, if the API explicitly allowed the user to specify "discretization strategies".
18:49:10 <mm_freak_> you remind me that topology is the study of hilarious terminology
18:49:23 <mm_freak_> pyon: we already have that
18:49:34 <pyon> Oh, then, my bad!
18:49:45 <pyon> Then it is a no-brainer!
18:50:29 <rasfar> it's a nice idea in any case
18:52:13 <mm_freak_> pyon: currently there are two major approaches to FRP implementation:  one is the concurrent approach (reactive-banana/sodium), the other is the discrete-frames approach (netwire/yampa)
18:52:34 <mm_freak_> you would use the former for stuff like widget-based GUIs and the latter for simulations and real-time games
18:53:02 <mm_freak_> and in the latter strategy you choose the exact discretization method
18:53:39 <mm_freak_> (in the former the run-time system does that)
18:54:02 <Rodya_> if anyone has any experience with the book, "Haskell Road to Logic Programming, and Math", i've got a simple question about the first chapter http://lpaste.net/102670
18:54:50 <mm_freak_> Rodya_: read "(Integral a) => a" as "Integer" for now
18:56:24 <Rodya_> thanks
18:56:25 <mm_freak_> Rodya_: it really just means that 'a' is a type for which 'rem' (and a number of other functions) is defined
18:56:42 <mm_freak_> you will learn the precise meaning when you learn about type classes
18:57:33 * hackagebot fay 0.19.2.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.19.2.1 (AdamBergmark)
18:59:21 <Rodya_> i think i understand what you mean.
19:02:07 <conal> mm_freak_: i responded to John L's answer and posted one of my own on http://stackoverflow.com/questions/22989253/frp-event-streams-and-signals-what-is-lost-in-using-just-signals/23050799
19:05:54 <mm_freak_> conal: imaginary upvote from me =)
19:07:57 <conal> :)
19:09:58 <mm_freak_> 4 AM…  i forgot how addictive this channel is…  good night everyone =)
19:12:34 * hackagebot simple-templates 0.8.0.0 - A basic template language for the Simple web framework  http://hackage.haskell.org/package/simple-templates-0.8.0.0 (AmitLevy)
19:22:35 * hackagebot pipes 4.1.1 - Compositional pipelines  http://hackage.haskell.org/package/pipes-4.1.1 (GabrielGonzalez)
19:27:36 * hackagebot atomic-primops 0.6.0.5 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.6.0.5 (RyanNewton)
19:54:25 <benzrf> yo
19:54:49 <benzrf> anybody have a link to a tutorial on how to use the eventnetwork and framework stuff for reactive-banana
19:56:53 <carter> benzrf: ask mm_freak when hes online?
20:00:56 <benzrf> wait mm_freak is the reactive banana dude?
20:00:59 <benzrf> sweet
20:01:26 <carter> oh
20:01:32 <carter> hes the netwire dude
20:01:33 <carter> nevm :)
20:01:42 <carter> I mix up the FRP libs ;)
20:02:16 <benzrf> is netwire better than banana then
20:02:24 <benzrf> i am biased toward libs with amusing names o
20:02:26 <benzrf> * o=
20:02:40 * hackagebot happybara 0.0.1 - Acceptance test framework for web applications  http://hackage.haskell.org/package/happybara-0.0.1 (cstrahan)
20:02:42 * hackagebot esqueleto 1.3.11 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.11 (FelipeLessa)
20:12:42 * hackagebot happybara-webkit 0.0.1 - WebKit Happybara driver  http://hackage.haskell.org/package/happybara-webkit-0.0.1 (cstrahan)
20:27:43 * hackagebot happybara-webkit-server 0.0.1 - WebKit Server binary for Happybara (taken from capybara-webkit)  http://hackage.haskell.org/package/happybara-webkit-server-0.0.1 (cstrahan)
20:31:23 <gtrambly> would it be considered a code smell for there to be pages and pages of calculations under Reader monads in haskell?
20:33:06 <gtrambly> it strikes a worrying note with me because monads are essentially imperative
20:33:16 <bitemyapp> gtrambly: really?
20:33:17 <gtrambly> and it makes a lot of the code imperative, effectively
20:33:30 <bitemyapp> gtrambly: why'd you originally need the reader monad?
20:33:51 <Cale> gtrambly: Well, the reader monad isn't terribly imperative
20:33:52 <gtrambly> i had this massive parameterization
20:34:07 <Cale> It's just keeping track of a function parameter
20:34:08 <bitemyapp> gtrambly: my thoughts were what Cale said.
20:34:26 <Cale> However, I tend to avoid it and just write functions :P
20:34:28 <gtrambly> basically some parameters that get loaded dynamically but
20:34:36 <gtrambly> there are like dozens
20:34:38 <gtrambly> of parameters
20:35:32 <Cale> Well, what did you do? You presumably invented a record type with all those parameters as fields to serve as the Reader's environment type.
20:35:39 <gtrambly> right
20:35:44 <Cale> (but then you really only have one parameter)
20:36:12 <gtrambly> that's true i suppose, but i read somewhere that it was a good idea to use the reader monad for configuration or someting?
20:36:16 <gtrambly> so i was like OK RIGHT! reader monad!
20:38:30 <gtrambly> but the parameters are essentially loaded in by IO
20:38:33 <gtrambly> from a web page
20:39:54 <Platz> I think xmonad and git-annex both essentially use that pattern
20:40:15 <nisstyre> gtrambly: I don't see the problem
20:40:28 <gtrambly> hmmm, OK! thanks
20:41:59 <hamishmack> bitemyapp: What “programmer directed yield semantics” are lacking in GHCJS?
20:42:30 <gtrambly> oh web app programming
20:42:31 <gtrambly> cool
20:42:32 <Platz> I'm drawing a blank right now, but what is the advantage of using reader instead of passing in a param?  I think reader just inverts it so you 'return' a function which takes a parameter, as opposed to passing it in from the top
20:42:42 <gtrambly> i've been using Haste
20:42:45 <bitemyapp> hamishmack: you can't use forkIO with compiler inserted yield.
20:42:55 <bitemyapp> hamishmack: you have to set up the callbacks and yield yourself.
20:43:02 <bitemyapp> if you're performance/jitter/latency sensitive.
20:43:15 <bitemyapp> hamishmack: there's really nothing GHCJS can do about it.
20:43:15 <benzrf> Platz: Reader allows you to pipeline a bunch of readers without needing to manually thread the extra arg though
20:43:20 <benzrf> *through
20:43:35 <Platz> ahh, the composability.  yes that makes sense
20:43:43 <bitemyapp> hamishmack: unless JS runtimes start requiring green threads.
20:44:07 <hamishmack> GHCJS implements green threads
20:44:38 <bitemyapp> hamishmack: my point is they're "fake", they have compiler inserted automatic yield
20:44:46 <hamishmack> Every N itterations through the trampoline function it checks the time and preempts the thread if it has reached a threashold
20:44:48 <bitemyapp> hamishmack: and the yield isn't program/runtime aware.
20:44:49 <nisstyre> bitemyapp: there's really no impediment to implementing threads in javascript
20:44:50 <bitemyapp> sigh. yes.
20:44:52 <bitemyapp> that's my point.
20:44:55 <nisstyre> bitemyapp: they are most definitely NOT fake
20:45:13 <nisstyre> they're just as pre-emptive as any other kind of threads
20:45:23 <hamishmack> You can tune both N and the threashold
20:45:26 <Jafet> If that is fake, then ghc's native threads are also fake
20:45:28 <jmcarthur> if that's fake, so are GHC's threads
20:45:30 <bitemyapp> you cannot use automatic/threshold based yield in frontend JS apps if you're performance or latency sensitive.
20:45:52 <bitemyapp> you have to able to control when you're handing control back to the browser for rendering.
20:45:59 <Jafet> I will let jmc link the (decade-old?) bug ticket
20:46:19 <jmcarthur> no i don't feel like googling around
20:46:20 <nisstyre> bitemyapp: that sounds like a problem with GHCJS's scheduling then
20:46:27 <hamishmack> You can also use the normal haskell yeild function
20:46:31 <bitemyapp> nisstyre: er no, it's a problem with the semantics of the approach.
20:46:52 <nisstyre> bitemyapp: threads based on continuations?
20:46:54 <nisstyre> what's wrong with it?
20:47:06 <bitemyapp> nisstyre: some JS apps are going to require tuning of what work gets done in what batches of user code vs. browser time.
20:47:25 <nisstyre> bitemyapp: so you're saying it should not be fairly scheduled
20:47:34 <bitemyapp> nisstyre: I'm saying it should be programmer scheduled.
20:47:41 <bitemyapp> only the programmer knows what's needed in each case.
20:48:13 <bitemyapp> we're talking about a problem similar to GC where a lot of apps are fine with GC, but some projects will require human tuned/managed memory allocation. Often in latency sensitive applications.
20:48:44 <bitemyapp> the browser runtime is already a fairly messed up environment performance wise, you can't get away with as much if you're making a performance intensive SPA.
20:48:51 <startling> so don't use green threads?
20:49:19 <bitemyapp> startling: don't use green threads in a non-trivial project in the browser runtime unless you're willing to absorb the risk that a rewrite might come due.
20:49:38 <bitemyapp> if you're willing to absorb the risk and know the scheduling might ruin your day, then yeah, go for it.
20:49:44 <bitemyapp> but don't kid yourself that it's a free lunch.
20:49:44 <nisstyre> bitemyapp: GHCJS isn't production ready anyway afaik
20:50:01 <bitemyapp> nisstyre: I have repeatedly stated that the issue is design not refinement.
20:50:06 <nisstyre> bitemyapp: I wouldn't say it has anything to do with performance
20:50:13 <bitemyapp> nisstyre: I realize there's no other realistic alternative for GHCJS.
20:50:34 <startling> bitemyapp: I don't see how green threads exclude the possibility of what you're saying.
20:50:43 <bitemyapp> nisstyre: but if you're going to use GHCJS, you cannot write your code like vanilla Haskell. You'll have to do it like Fay/Purescript and handle concurrency in terms of how the browser works.
20:51:01 <bitemyapp> startling: manual yield?
20:51:03 <haasn> edwardk: is there a type of recursion scheme that corresponds to ‘scanl’, or more specifically, ‘fold f z . scanl g x’
20:51:26 <startling> bitemyapp, yes.
20:51:45 <bitemyapp> startling: where is that a thing outside of CSP-oriented systems?
20:52:04 <bitemyapp> startling: or ghetto generator oriented ones like the Python stuff?
20:52:15 <bitemyapp> I wasn't aware there was a way to directly yield to the scheduler in Haskell.
20:52:26 <bitemyapp> and if it is a thing, does GHCJS support it?
20:52:34 <hamishmack> yes
20:52:41 <bitemyapp> link?
20:52:49 <hamishmack> It also supports async exceptions https://github.com/ghcjs/ghcjs-examples/blob/master/ghcjs-hello/src/Main.hs#L139
20:52:50 <startling> that's not what I meant, but I guess it's true anyhow. :)
20:53:01 <jmcarthur> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/Control-Concurrent.html#v:yield
20:54:15 <jmcarthur> the documentation even talks about cooperative thread implementations
20:54:22 <bitemyapp> well, that solves that.
20:54:30 <nisstyre> I *really* don't see what the problem is
20:54:30 <bitemyapp> now GHCJS just needs to get the payload size down :)
20:54:38 <bitemyapp> nisstyre: there ain't one.
20:54:42 <nisstyre> like I said, you implement it in terms of continuations
20:54:52 <bitemyapp> that's besides the point.
20:54:57 <bitemyapp> the point is programmer control of yield.
20:55:11 <nisstyre> bitemyapp: I'm talking about the intermediate representation the compiler uses
20:56:01 <nisstyre> but yeah, you can just use co-operative threads if you need control
20:58:11 <Jafet> Clearly ghcjs should implement M/N scheduling via cross-tab scripting exploit to N tabs
20:58:59 <bitemyapp> Jafet: hahahahhaa
20:59:13 <nisstyre> Jafet: clickjacking might help there
20:59:27 <nisstyre> if you can get the user to click on an iframe that somehow runs the other thread
20:59:39 <bitemyapp> Jafet: actually, the funny thing is, operating systems managed to handle single threaded, preemptive threading just fine. They had native code though.
20:59:48 <bitemyapp> well, mostly fine anyway.
21:00:00 <nisstyre> bitemyapp: you have control at the level of the continuation here, which is good enough
21:00:06 <bitemyapp> I have many (fond?) memories of desktop Linux and windows being awful not so long ago.
21:00:08 <nisstyre> well, imo at least
21:00:21 <bitemyapp> nisstyre: yep, all I wanted. I just have to eyeball GHCJS build artifact sizes now.
21:00:24 <nisstyre> by continuation I mean like a + [] <- [] is a continuation
21:00:47 <nisstyre> so you can evaluate `a` and do a context switch or w/e
21:00:52 <nisstyre> and then go back and continue
21:00:56 <hamishmack> Jafet: We plan for web workers and other web pages to map to processes in native code.  So we need someone to get cloud haskell working.
21:04:00 <nisstyre> *  that should be [.]
21:04:05 <nisstyre> weird notation
21:04:54 <hamishmack> bitemyapp: We need to fix some small google closure compiler compatibility issues
21:05:26 <hamishmack> then we will put up some new minified samples
21:22:49 * hackagebot aws-sdk 0.12.4 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.12.4 (YusukeNomura)
21:28:42 <conal> Has anyone here worked with coercions & roles in Core? I'm getting an error message from Core Lint. (I'm working on a GHC plugin.) Error message at http://lpaste.net/102672 .
21:36:42 <carter> srhb: you found my github i see :)
21:37:10 <carter> if those projects seem cool, you should lurk on #numerical-haskell ('cause other people are hacking on even cooler things )
21:37:11 <carter> ish
21:40:14 <jakex_> is there a nicer way of writing this? (flip Map.lookup m) =<< maybeGetKey x
21:40:54 <jakex_> (other than omitting parenthesis, not sure why I typed them)
21:41:24 <lfairy> jakex_: if x is a parameter, then: flip Map.lookup m <=< maybeGetKey
21:41:35 <johnw> Map.lookup <$> maybeGetKey x <*> pure m
21:41:36 <lfairy> it's pretty close to optimal though
21:41:42 <jakex_> it isn't, it is part of case
21:42:05 <johnw> the original expression won't type check anyway
21:42:16 <jakex_> it compiled here
21:42:20 <johnw> oh, hmm
21:42:25 <johnw> ah, it's the Maybe monad
21:42:29 <jakex_> yes
21:48:22 <shachaf> Any way that doesn't involve flip is nicer than a way that does.
21:49:22 <shachaf> (`Map.lookup` m) =<< maybeGetKey x, for instance. Or (\x -> Map.lookup x m) =<< maybeGetKey x
21:50:02 <shachaf> Oh, the original is an error.
21:50:14 <jakex_> where?
21:50:37 <shachaf> Then you can use the Applicative laws to simplify the new version.
21:50:45 <shachaf> Oh, the original isn't an error.
21:51:00 <shachaf> OK, I don't even know what's going on anymore.
21:53:03 <AncientPC> Does anybody know of a good CLI program I can learn from / reference to learn packaging / argument handling?
21:53:21 <AncientPC> Most of the popular GitHub Haskell projects are frameworks or compilers.
21:54:24 <startling> AncientPC, optparse-applicative is nice but kinda hairy
21:54:44 <shachaf> whoa, fancy new haddock improvements
21:54:57 <haasn> :)
21:55:02 <shachaf> Now you can see the infixity of operators.
21:55:15 <haasn> Type and data family instances, too
21:55:25 <startling> oh, nice
21:56:30 <shachaf> haasn: Oh, you implemented that.
21:56:47 <jakex_> > let m = M.fromList [(0, 1)]; maybeGetKey _ = Just 0; x = undefined in (`M.lookup` m) =<< maybeGetKey x
21:56:49 <lambdabot>  Just 1
21:57:27 <jakex_> I don't think that can be improved, but who knows
21:57:54 * hackagebot foldl-incremental 0.1.0.0 - incremental folds  http://hackage.haskell.org/package/foldl-incremental-0.1.0.0 (tonyday)
21:59:00 * haasn .oO( (M.!) m <$> maybeGetKey x )
22:00:06 <haasn> jakex_: only thing I can think of is a possible eta-reduction as (`M.lookup` m) <=< maybeGetKey, depending on the context
22:00:14 <jakex_> I did not know about M.! :)
22:00:29 <haasn> jakex_: M.! is prone to crashing, though
22:00:59 <haasn> it calls “error” if it can't find the key
22:01:04 <jakex_> ah
22:02:00 <viper99> what version if haskell platform do I need to have oneShotTimer?
22:02:24 <viper99> or what version of ghc
22:02:52 <haasn> It doesn't matter as much what version of the platform or ghc you have as it matters whether or not you have the “timers” package (or whatever else implements that function) installed
22:04:07 <haasn> viper99: the Haskell platform does not include “timers”
22:04:16 <haasn> And neither does GHC
22:04:35 <viper99> ok :p
22:15:15 <lucidmb> list
22:15:31 <lucidmb> !list
22:15:32 <monochrom> lucidmb: http://hackage.haskell.org/packages/archive/pkg-list.html
22:19:33 <kazagistar> I have been trying to work my way though some online HoTT lectures, but they seem to be oriented at upper level math students, and assume you are familar with quite a lot of abstract algebra. Is there somewhere better to start?
22:22:57 * hackagebot language-c 0.4.5 - Analysis and generation of C code  http://hackage.haskell.org/package/language-c-0.4.5 (BenediktHuber)
22:22:59 * hackagebot foldl-incremental 0.1.0.1 - incremental folds  http://hackage.haskell.org/package/foldl-incremental-0.1.0.1 (tonyday)
22:25:24 <edwardk> haasn: foldl and scanl don't correspond to standard recursion schemes, first the 'l' part makes them not structural, second scanl changes the shape
22:27:16 <haasn> edwardk: my fold is associative; I think I would be fine with a scanl1
22:27:50 <edwardk> well, you still have the problem of 'l'. if you wanted a scanr1 we might be able to figure it out =)
22:27:57 * hackagebot conduit-extra 1.1.0.1 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.0.1 (MichaelSnoyman)
22:28:31 <haasn> edwardk: my scanning function commutes with list reversal, too :)
22:28:52 <haasn> Which I guess makes it scanr-friendly
22:29:09 <edwardk> what is it you are trying to compute?
22:31:45 <haasn> edwardk: The problem description is to find the longest subsequence of a list consistent only of a given value; a solution can be expressed in terms of foldr max 0 $ scanl (\c x' -> if x' == x then c+1 else 0) 0
22:32:09 <haasn> (and a bit shorter with some pointfree-reduction that I'm not going to repeat here)
22:32:27 <haasn> Although I just realized that's entirely incompatible with scanr1 due to the type change
22:32:32 <joelteon> @djinn \x f -> case x of Nothing -> return Nothing; Just t -> fmap f t
22:32:32 <lambdabot> Cannot parse command
22:32:38 <joelteon> oh right
22:32:44 <haasn> wait a minute.
22:33:14 <edwardk> what keeps you from just using a list catamorphism?
22:33:50 <edwardk> and then tweaking it at the end to get rid of the other result?
22:34:22 <haasn> Mainly just code shortness; I was just interested in seeing if “foldr f z . scanl g x” had a shorter name
22:34:26 <joelteon> oh, it's actually Just t -> fmap Just (f t)
22:34:31 <haasn> (This is for golf)
22:34:36 <joelteon> does anybody have any idea how to shorten that? I feel like it should be possible but I'm stupid
22:34:49 <edwardk> foldr down the list tracking he current run length and the max seen then merge the answers
22:35:08 <haasn> Ps. Here's one I hope you'll like: maximumOf $ to group.folded.folded x.asIndex.to (+1)
22:35:20 <edwardk> if you're golfing then stock recursion schemes are almost assuredly not going to give you the shortest solution =)
22:35:34 <haasn> err, that should be “folded.folded.only x”
22:35:55 <haasn> (This is why I was asking about indexed each!)
22:35:57 <edwardk> too bad to (+1) and to succ are the same length
22:36:08 <joelteon> to(+1) is shorter
22:36:12 <haasn> .adding 1
22:36:16 <haasn> :(
22:36:23 <edwardk> well you only need the second one of those indexed
22:36:38 <edwardk> each.folded ?
22:36:51 <edwardk> shaves you 2 chars
22:37:06 <haasn> My shortest is “maximum.scanl(\a->bool(a+1)0.(==x))0”
22:37:32 <edwardk> yeah not beating that here today with lens =)
22:38:33 <shachaf> Is bool an actual thing now?
22:38:49 <haasn> shachaf: Yes, in GHC 7.8.2
22:38:49 <joelteon> @hoogle t (f a) -> f (t a)
22:38:50 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
22:38:50 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
22:38:50 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
22:38:54 <haasn> joelteon: sequenceA
22:39:06 * haasn is blind
22:39:39 <haasn> shachaf: or, rather, base 4.7
22:39:42 <shachaf> If only there was a way to query Hoogle other than asking lambdabot in #haskell.
22:39:48 <shachaf> Hm.
22:40:02 <joelteon> Yeah, it's rough having a window that can only hold one line.
22:40:05 <shachaf> :t maximum.scanl(\a->bool(a+1)0.(==x))0
22:40:07 <lambdabot> (Ord c, Num c) => [Expr] -> c
22:40:09 <shachaf> What's this?
22:40:27 * shachaf looks up.
22:40:35 <haasn> > let x = 'x' in maximum.scanl(\a->bool(a+1)0.(==x))0 "abxdefxxhijkxxlmnopxqrs"
22:40:37 <lambdabot>  Couldn't match expected type ‘a -> [c]’ with actual type ‘[b0]’
22:40:42 <haasn> > let x = 'x' in maximum.scanl(\a->bool(a+1)0.(==x))0 $ "abxdefxxhijkxxlmnopxqrs"
22:40:44 <lambdabot>  5
22:40:56 <haasn> Oh, that is actually bugged. Hmm.
22:41:55 <haasn> That's odd, it works locally
22:41:57 <haasn> :t bool
22:41:58 <lambdabot> a -> a -> Bool -> a
22:42:52 <haasn> > bool 0 1 True
22:42:54 <lambdabot>  1
22:42:56 <haasn> Oh.
22:42:59 * hackagebot yesod-core 1.2.13 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.13 (MichaelSnoyman)
22:43:01 <shachaf> ?
22:43:01 * hackagebot yaml 0.8.8.2 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.8.2 (MichaelSnoyman)
22:43:14 <haasn> lambdabot's ‘bool’ and base-4.7's ‘bool’ are the other way around.
22:43:17 <haasn> This is why Bool is bad
22:43:20 <shachaf> bool in base 4.7 has the True case coming before False?!
22:43:43 <haasn> shachaf: yes, like “if x then a else b”
22:43:46 <shachaf> How did that ever get in?
22:43:48 <haasn> = bool a b x
22:43:50 <shachaf> That's horrible.
22:44:03 <shachaf> I'm fine with if' b x y = if b then x else y
22:44:07 <haasn> I never really thought about it, but now that you mention it; it would make more sense to have False first
22:44:09 <shachaf> But bool is a fold and it should behave like a fold.
22:44:15 <haasn> to correspond to Maybe, (<=), etc.
22:44:20 <shachaf> @src Bool
22:44:20 <lambdabot> data Bool = False | True deriving (Eq, Ord)
22:44:49 <shachaf> Who did this and why did I never hear about it until after the release?
22:44:56 * shachaf sighs.
22:45:05 <haasn> Let's ask git blame
22:45:45 <shachaf> I don't remember seeing a libraries@ proposal about it, not that I read them carefully these days.
22:46:03 <shachaf> But now base will have to be backwards-compatible forever. Great.
22:46:15 <kazagistar> Hmm, so Bool is of typeclass Ord? I guess that makes sense...
22:46:25 <haasn> shachaf: https://github.com/ghc/packages-base/commit/f404697486b1db27711be134fd65c6c5e60d7604
22:46:55 <haasn> kazagistar: (<=) is (→)!
22:47:04 <shachaf> :-(
22:47:06 <shachaf> https://ghc.haskell.org/trac/ghc/ticket/8302
22:47:29 <shachaf> Wait, that commit has bool ordered the right way.
22:47:41 <copumpkin> yeah
22:47:44 <copumpkin> so someone changed it?
22:48:00 * hackagebot conduit 1.1.0.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.1.0.1 (MichaelSnoyman)
22:48:01 <kazagistar> haasn: that definition does not mean much to numbers, the main domain I am used to seeing <= in...
22:48:02 * hackagebot resourcet 1.1.2 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.2 (MichaelSnoyman)
22:48:17 <shachaf> No, it's still that way in https://github.com/ghc/packages-base/blob/master/Data/Bool.hs
22:48:22 <haasn> Wait, no; it's correct in base-4.7 too
22:48:27 <haasn> Now I'm confused
22:48:33 <copumpkin> hrm
22:48:39 <shachaf> OK, that's good.
22:48:46 <copumpkin> </outrage>
22:48:54 <haasn> Oh. I was using a different version of ‘bool’. That's interesting!
22:49:04 <shachaf> copumpkin: Pft, as if.
22:49:12 <haasn> I wonder why I didn't get an “ambiguous name” error
22:49:14 <copumpkin> haasn: where was yours coming from
22:49:17 <copumpkin> shachaf :)
22:49:25 <haasn> copumpkin: ~/.ghci
22:49:31 <copumpkin> the horror!
22:49:35 <shachaf> If you shadow a Prelude definition in ghci it's just shadowed.
22:49:52 <startling> kazagistar, Enum, too
22:50:04 <haasn> Does the Prelude actually re-export bool?
22:50:17 <kazagistar> so, I assume Nothing is smaller in Maybe, and Left is smaller in Either?
22:50:30 <haasn> (Looks like the answer is no)
22:50:34 <shachaf> haasn: I mean an imported definition.
22:50:40 <startling> > Nothing < Just 2
22:50:42 <lambdabot>  True
22:50:48 <startling> > Left 1 < Right 2
22:50:49 <haasn> shachaf: Oh, okay - that's useful to know
22:50:50 <lambdabot>  True
22:51:05 <startling> kazagistar: (that's how the derived Ord instance works, yeah)
22:51:48 <haasn> I sometimes run into issues in GHCi when importing SomeModule.Prelude which conflicts with the actual Prelude; since neither :seti -XNoImplicitPrelude nor “import Prelude ()” seem to get GHCi to stop having the Prelude names in scope
22:52:04 <haasn> But with that trick I can just use “let (+) = (SomeModule.+)” etc.
22:52:04 <kazagistar> I mean, it could be defined either way, but it makes more sense that way I think, I like it :P
22:52:46 <shachaf> haasn: -XNoImplicitPrelude works fine in ghci
22:53:01 * hackagebot http-client 0.3.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.1 (MichaelSnoyman)
22:53:03 * hackagebot http-conduit 2.1.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.1 (MichaelSnoyman)
22:53:09 <shachaf> Or maybe I should say "with ghci". Pass it as a command-line flag.
22:54:37 <thrakcattack> :t fromJust
22:54:38 <lambdabot> Maybe a -> a
22:54:47 <thrakcattack> :i fromJust
22:55:06 <thrakcattack> :hoogle
22:55:12 <nisstyre> > fromJust Nothing
22:55:13 <lambdabot>  *Exception: Maybe.fromJust: Nothing
22:55:38 <haasn> How do I pass that to “cabal repl”? Neither “cabal repl -XNoImplicitPrelude” nor “cabal repl -- -XNoImplicitPrelude” nor “cabal repl --ghci-option=-XNoImplicitPrelude” work. The latter but with --ghc-option is accepted by cabal but then it gets passed to the compiler during the compilation stage
22:57:11 <prophile> haasn: will a hack be sufficient?
22:57:20 <haasn> Depends on the kind of hack
22:57:32 <prophile> put :set -XNoImplicitPrelude into ~/.ghci
22:57:49 <shachaf> I've never used cabal repl.
22:57:51 <haasn> or ./.ghci
22:58:01 * hackagebot cookie 0.4.1 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.4.1 (MichaelSnoyman)
22:58:06 <prophile> I did not know about ./.ghci
22:58:11 <startling> cabal repl is kind of gross.
22:58:15 <prophile> intriguing
22:58:19 <shachaf> ./.ghci is kind of awful.
22:58:47 <haasn> prophile: You should be aware of it, somebody could slip arbitrary code into it and make your PC blow up when you launch ghci inside that directory
22:59:07 <shachaf> I should start putting :!rm -rf ~ in .ghci files in random archives.
22:59:12 <shachaf> Maybe I can make it go away.
22:59:32 <shachaf> (This is not a thing I should actually do.)
23:01:16 <startling> shachaf, :!rm -rf ~/.ghc instead
23:01:38 <shachaf> But that's a thing you need to do on a regular basis anyway!
23:01:50 <startling> exactly !
23:01:53 <tsou> hmm i'm sorry, i didn't follow, what's wrong with .ghci?
23:01:59 <startling> can I redefine :! ?
23:02:46 <haasn> I would propose :!rm -rf ~/.cabal/lib/*.2.* in hopes of improving cabal's handling of broken packages while we're at it
23:04:48 <startling> ugh, apparently :def! ! ... doesn't work.
23:04:57 <startling> that's so bad.
23:05:13 <tsou> why are we against .ghci out of a sudden? :|
23:05:16 <klugez> tsou: They are objecting to ghci reading ./.ghci from the current directory. So the risk is that you go to a random directory and run ghci, then the contents of that file are executed.
23:05:33 <tsou> klugez: thanks for clarifying that
23:05:54 <tsou> i thought nobody would read ./.ghci in place of or inaddition to ~/.ghci...
23:06:13 <tsou> wait, so ghci actually does that by default?(!)
23:06:30 <Ralith> that's pretty bad
23:07:35 <klugez> tsou: https://www.haskell.org/ghc/docs/7.6.2/html/users_guide/ghci-dot-files.html - Yes.
23:07:49 <tsou> oh, thanks for pointing that out ;)
23:08:02 * hackagebot yesod-static 1.2.2.5 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.2.2.5 (MichaelSnoyman)
23:08:47 <augur> xplat: @krismicinski says Twelf lets you do all sorts of fancy logics, including custom type contexts
23:08:51 <haasn> I have actually used the feature a handful of times
23:09:06 <augur> xplat: so it might be a good alternative to Ott, for those purposes
23:09:15 <startling> I wonder what happens if i :set -ignore-dot-ghci
23:09:49 <haasn> startling: in .ghci?
23:09:50 <startling> oh, heh, doesn't matter, since the ~/.ghci is read last !
23:09:59 <startling> haasn: yeah.
23:10:09 <haasn> clearly it should ignore the instruction telling it to ignore itself
23:10:42 <startling> haasn, I thought it might prevent the rest of the .ghcis from being read
23:10:44 <startling> no such luck.
23:13:03 <ghhh> @pl \p -> x `rem` p /= 0
23:13:04 <lambdabot> (0 /=) . (x `rem`)
23:13:26 <startling> :t \x -> (/=) 0 . rem x
23:13:27 <lambdabot> Integral b => b -> b -> Bool
23:14:09 <haasn> I have often wished for a name for that, as (p `divides` x)
23:14:25 <haasn> Or (x `divisibleBy` p)
23:15:30 <startling> I've never written anything where you wouldn't immediately want the remainder if it's not zero.
23:17:56 <haasn> :t re (non 0)
23:17:58 <lambdabot> (Contravariant f, Num b, Functor f, Eq b) => (Maybe b -> f (Maybe b)) -> b -> f b
23:18:23 <haasn> :t non 0 # rem 10 4
23:18:24 <lambdabot> Integral b => Maybe b
23:18:31 <haasn> > non 0 # rem 10 4
23:18:33 <lambdabot>  Just 2
23:18:35 <haasn> > non 0 # rem 10 5
23:18:37 <lambdabot>  Nothing
23:18:43 <startling> :)
23:18:59 <haasn> I wonder if that would be a good example to add to the lens documentation
23:19:11 <startling> I always forget #
23:19:17 <haasn> (#) = review
23:19:40 <edwardk> haasn: might not be a bad idea
23:20:12 <startling> haasn: I know, but I never remember it when I need it.
23:21:37 <haasn> :t non' _Empty -- neat
23:21:38 <lambdabot> (AsEmpty a, Profunctor p, Functor f) => p a (f a) -> p (Maybe a) (f (Maybe a))
23:22:33 <haasn> edwardk: I think “non = anon . only” is supposed to be “non = non' . only”
23:28:05 * hackagebot hwall-auth-iitk 0.1.0.1 - Initial version of firewall Authentication for IITK network.  http://hackage.haskell.org/package/hwall-auth-iitk-0.1.0.1 (satvikc)
23:32:00 <haasn> edwardk: oh, that was fixed already in HEAD
23:51:48 <raphie_> what data structure would one use to represent a cyclical graph?
23:52:12 <haasn> Usually something equivalent to [(Node, [Node])]
23:54:15 <raphie_> haasn: what would each Node be?
23:54:36 <haasn> Int
23:54:42 <haasn> Sorry for not making that clear
23:56:52 <startling> It can be any type with Eq, and with enough members such that each node has a unique identifier.
23:56:56 <startling> Int is just convenient.
23:57:59 <raphie_> but then you lose some nice properties
23:58:02 <raphie_> like pattern-matching
23:58:08 <raphie_> how would you pattern-match against that?
23:59:39 <haasn> View patterns could come close. It depends on what you want to pattern match against, I guess
