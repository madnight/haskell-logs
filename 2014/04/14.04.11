00:00:32 <solidus-river> deathbird: oo, what lib? my first attempt and doing haskell stuff was trying to impliment Inverse Kinematics and all the matrix libs i found were less than awesome
00:01:14 <solidus-river> hit that road block 2 years ago and havent been back since... about a week ago
00:01:24 <deathbird> solidus-river: Its called GLMatrix. It's actually something I found on GitHub, I just made some modifications and asked the author for permission
00:02:00 <deathbird> http://hackage.haskell.org/package/GLMatrix
00:02:41 <deathbird> Not too efficient, but not terrible
00:03:31 <deathbird> solidus-river: Also a lot of extremely incorrect code.
00:04:00 <solidus-river> anyone here involved with lambdacube?
00:06:53 <solidus-river> deathbird: i'm still new so it looks like a great lib to start playing with from my end :)
00:08:56 <deathbird> solidus-river: Probably the best Haskell matrix library on Hackage. The others are nonexistant
00:09:25 <deathbird> *Opengl Matrix library
00:10:05 * hackagebot cereal-conduit 0.7.2.1 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.7.2.1 (MichaelSnoyman)
00:10:05 * hackagebot propellor 0.3.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.3.0 (JoeyHess)
00:16:54 <mzarella> I'm trying to use shelly and `run "git"` fails because run expects a FilePath
00:17:12 <mzarella> I don't know what a FilePath should consist of, would someone mind helping me?
00:17:17 <mzarella> http://hackage.haskell.org/package/shelly-0.9.2/docs/Shelly.html#t:ShIO
00:17:27 <mzarella> ignore the #t:ShIO portion of the uri
00:18:36 <deathbird> mzarella: type FilePath = String
00:19:31 <deathbird> mzarella: so it probably wants /usr/bin/git
00:19:56 <deathbird> mzarella: Or the equivalent on windows or mac
00:21:05 <mzarella> run "/usr/bin/git" produces the error: "Couldn't match expected type `FilePath' with actual type `[Char]'
00:21:08 <mzarella> "
00:21:31 <mzarella> deathbird: How'd you figure out FilePath is a String type?
00:22:01 <deathbird> mzarella: Oh... they made their own FilePath type. Usually FilePath is just a synonym for String.
00:23:15 <pavonia> try enabling {-# LANGUAGE OverloadedStrings #-}
00:23:37 <mzarella> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/System-IO.html
00:23:42 <deathbird> mzarella: You also might have to use "fromText"
00:27:03 <mzarella> What are the {#- foo -#} strings at the top of a file?
00:27:11 <opqdonut> pragmas
00:27:13 <mzarella> Can you utilize them in ghci?
00:27:26 <mzarella> {#- LANGUAGE OverloadedStrings #-} e.g.
00:27:33 <opqdonut> I think you need to give them on the command line, e.g. "ghci -X OverloadedStrings"
00:27:47 <opqdonut> no, it's not -X, hmm
00:27:50 <mgsloan> Or, you can do ":set -XOverloadedStrings" while in ghci
00:28:12 <opqdonut> oh, right
00:28:12 <deathbird> They don't work as in-file pragmas?
00:28:18 <opqdonut> ("ghci -XOverloadedStrings" is the right invocation)
00:28:26 <opqdonut> deathbird: they do
00:28:30 <mgsloan> {-# #-} pragmas work in source files, but not in ghci
00:28:32 <opqdonut> but the question was about ghci
00:29:18 <deathbird> opqdonut: LANGUAGE pragmas appear to work in ghci
00:30:28 <Saizan> deathbird: by in ghci we mean at the prompt, without a file
00:30:45 <deathbird> Saizan: I see
00:32:21 <mzarella> I'm confused, do they work?
00:32:35 <mzarella> :set -XOverloadedStrings ah
00:33:23 <eatman> Hello
00:34:03 <deathbird> eatman: Greetings
00:42:33 <cgag> I'm trying to run cabal repl and it just says "Preprocessing library <mylib>..." and then never runs a repl.  Anyone run into this before?
00:43:40 <solidus-river> given a cabal project how do you start up a ghci prompt that can import that projects libs etc
00:43:50 <solidus-river> jsut run ghci from the projects root dir?
00:45:39 <deathbird> solidus-river: In GHCi, just type ":m + <package>"
00:46:29 <deathbird> After installing the package, of course.
00:47:22 <pavonia> solidus-river: I think "cabal repl" is what you're looking for
00:51:43 <spacekitteh> if the maintainer of a package is no longer contactable, and i have a patch which makes the package work with 7.8.1, is there a way to get the patch added into a new version on hackage? :(
00:52:22 <pavonia> Send it to the mailing list
00:52:41 <spacekitteh> pavonia: alright, cool.
00:52:58 <merijn> spacekitteh: What is "no longer contactable"?
00:53:08 <spacekitteh> merijn: the email address bounces
00:53:17 <jle`> what about the issue tracker?
00:53:39 <spacekitteh> jle`: there isn't one
00:53:44 <jle`> :/
00:53:52 <spacekitteh> http://hackage.haskell.org/package/permutation
00:53:56 <klrr_> what library in qusetion?
00:53:58 <klrr_> oh, nvm
00:55:25 <jle`> that's the thing about using your university email address
00:56:45 <spacekitteh> alternatively, does anyone know of a package which tells you whether a given permutation is even or odd?
00:58:24 <andkore> I want to use CQRS/event sourcing in a project I'm going to be starting soon. Anyone have experience with CQRS/event sourcing in Haskell? I see that https://hackage.haskell.org/package/cqrs exists, but with 520 downloads and a last updated date of about a year ago, I'm not too hopeful...
00:59:15 <andkore> Or if someone thinks CQRS/event sourcing is a bad idea, I'd be interested in hearing that too
01:23:43 <spacekitteh> which mailing list should i send the sdist to?
01:26:19 <__mek__> Howdy folks, any idea why cabal may fail to install HueAPI-0.1.2 with dependency issues? https://gist.github.com/mekarpeles/bd6e7b65e61d39a228a4
01:27:10 <__mek__> HueAPI is here, btw: http://hackage.haskell.org/package/HueAPI-0.1.2
01:28:25 <aloiscochard> hey there, could anyone point me to some reference about how to integrate tests in a cabal project (structure/runner/...)?
01:29:21 <quchen> __mek__: GHC 7.8?
01:29:37 <aloiscochard> I'll follow this http://www.haskell.org/haskellwiki/Structure_of_a_Haskell_project but if someone have some tips
01:30:03 <__mek__> quchen: 7.4.1 actually. Could that be the problem?
01:30:06 <quchen> aloiscochard: The Cabal user's guide is often a useful reference, http://www.haskell.org/cabal/release/cabal-1.18.1.2/doc/users-guide/developing-packages.html#test-suites
01:30:26 <aloiscochard> quchen: awesome, ty!
01:31:11 <quchen> __mek__: What's your 'base' version?  Run `ghc-pkg list | grep base` to get it
01:31:32 <quchen> Oh, `ghc-pkg list base` is even better.
01:32:10 <__mek__> quchen: base-4.5.0.0 and cabal 1.18.1.3
01:32:28 <merijn> Base isn't the issue
01:32:41 <merijn> His dependency bound is incompatible with HueAPI-0.1.2
01:32:58 <merijn> __mek__: Your dependency list specifies base < 4.6
01:33:07 <quchen> HueAPI 0.1.2 has a dependency on Base >= 4.6
01:33:10 <quchen> So that's also an issue.
01:33:12 <merijn> __mek__: According to the error, HueAPI-0.1.2 demands >= 4.6
01:33:21 <merijn> __mek__: So clearly those two are incompatible
01:33:47 <__mek__> merijn: What is the preferred method of updating "Base"?
01:33:54 <quchen> Update your compiler
01:33:56 <merijn> __mek__: You can't
01:34:14 <merijn> __mek__: base is built into GHC
01:34:40 <merijn> So if it does indeed demand a newer base, you need a newer GHC
01:35:27 <__mek__> merijn: That sounds reasonable.
01:35:40 <__mek__> merijn, quchen: Thanks for the guidance.
01:36:06 <merijn> __mek__: You could cross your fingers and try if HueAPI works with an older base (i.e. the lowerbound is overconservative)
01:36:11 <merijn> Worst case it'll fail to compile
01:40:09 * hackagebot marmalade-upload 0.5.1 - Upload packages to Marmalade  http://hackage.haskell.org/package/marmalade-upload-0.5.1 (lunaryorn)
01:41:18 <__mek__> /home/mek/.cabal/bin/cabal install --constraint="base >= 3.0 installed" HueAPI-0.1.2
01:41:36 <__mek__> Something like that?
01:42:59 <__mek__> I tried lowering the constraint within the .cabal file but it doesn't seem it had any effect. Building a later version of GHC may be the best route.
01:45:10 * hackagebot keyring 0.1.0.2 - Keyring access  http://hackage.haskell.org/package/keyring-0.1.0.2 (lunaryorn)
01:45:44 <merijn> __mek__: Lowering it in the cabal file only works if you run "cabal install" (no package name) from the directory you edited it in
01:46:10 <merijn> __mek__: So you'd "cabal unpack HueAPI", edit the file, run "cabal install" and then try to "cabal install YourPackage"
01:50:53 <__mek__> merijn: Great success and glory. Thank you for helping me understand the problem and the workaround.
02:03:49 <winobes> q
02:15:28 <quchen> Is there a lens way to branch on Maybe? Something along the lines of  setMaybe foo l (Just x) = foo & l .~ x; setMaybe _ _ Nothing = mempty
02:23:15 <spacekitteh> with 7.8.1 typenats, how do i do the equivalent of fromSing (sing :: Sing p) ?
02:27:02 <spacekitteh> nevermind, got it
02:27:21 <fizruk> quchen: setMaybe foo l x = l (const x) foo ?
02:28:01 <fizruk> > _1 (const (Just 3)) (1, 2)
02:28:02 <lambdabot>  Just (3,2)
02:28:09 <merijn> spacekitteh: natVal
02:28:11 <fizruk> > _1 (const Nothing) (1, 2)
02:28:12 <lambdabot>  Nothing
02:28:40 <merijn> spacekitteh: "natVal :: forall n proxy. KnownNat n => proxy n -> Integer"
02:29:15 <merijn> @hoogle Integer -> Int#
02:29:15 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
02:29:15 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
02:29:15 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
02:29:17 <quchen> fizruk: That would do, I guess. Thanks
02:29:42 <spacekitteh> merijn: yeah, i couldn't figure out the Proxy bit
02:29:59 <merijn> spacekitteh: proxy is just a polymorphic variable
02:30:21 <spacekitteh> so i could do natVal (undefined :: 3)?
02:30:30 <spacekitteh> no
02:30:33 <merijn> spacekitteh: There's "data Proxy a = Proxy" so you can write "natVal (Proxy :: Proxy 5)"
02:30:34 <spacekitteh> undefined :: Proxy 3
02:30:38 <spacekitteh> yeah
02:30:58 <merijn> spacekitteh: The reason to make proxy a variable is so that [], Maybe, whatever you have lying around also works
02:31:03 <spacekitteh> ooooh, hopefully i don't need to include (SingI p, SingI q) constraints anymore
02:31:25 <merijn> "natVal (Nothing :: Maybe 5)" also works
02:31:32 <merijn> Actually
02:31:36 <merijn> I guess it doesn't :p
02:31:40 <spacekitteh> :v
02:31:43 <merijn> Since Maybe :: * -> *
02:31:51 <merijn> But you get the gist, I think :)
02:32:39 <spacekitteh> : 3
02:34:37 <joneshf-laptop> so you can define an instance in the same module as the class, or in the same module as the type, is either one more robust/less error prone? Does it make a difference? Which way generally gives the shortest stay in dependency hell?
02:34:56 <merijn> joneshf-laptop: Either should be fine
02:35:23 <merijn> joneshf-laptop: The difference is only in the order of dependencies
02:35:38 <joneshf-laptop> hmm?
02:35:47 <merijn> joneshf-laptop: Package with data depends on package with class -> define instance in package with data
02:36:04 <merijn> joneshf-laptop: Package with class depends on package with data -> define instance in package with class
02:36:42 <merijn> If both are in the same package, who cares?
02:37:00 <spacekitteh> oh damn
02:37:11 <spacekitteh> i still need the KnownNat instances infecting all my code :( :( :(
02:37:29 <merijn> spacekitteh: Yeah, although if you only work with Nat literals you're fine
02:38:05 <merijn> joneshf-laptop: The only thing considered wrong/unsafe are orphan instances (i.e. instances both not defined with the data AND not defined with the class)
02:38:17 <merijn> But GHC will warn you about those (at least with -Wall)
02:38:19 <spacekitteh> merijn: i'm using them to automatically derive the metric tensor for a manifold for my clifford algebra library :(
02:38:43 <joneshf-laptop> hmm
02:38:54 <joneshf-laptop> okay
02:39:05 <merijn> spacekitteh: The problem is that without KnownNat GHC has no way to reify the values at runtime, since types are erased
02:39:09 <spacekitteh> and since pretty much every operation depends on it in some way, all my functions need the constraints :/
02:39:28 <spacekitteh> indeed :C
02:39:45 <joneshf-laptop> thanks
02:40:09 <merijn> joneshf-laptop: Because with orphan instances if either the class or data author implements an instance your code will break
02:40:16 * hackagebot warp-tls-uid 0.1.0.1 - set group and user id before running server  http://hackage.haskell.org/package/warp-tls-uid-0.1.0.1 (YoshikuniJujo)
02:40:55 <pyon> is there any tool that helps verify laws associated with classes?
02:43:03 <merijn> pyon: Not really anything systematic, I think?
02:44:14 <spacekitteh> pyon: Agda :P
02:45:17 * hackagebot warp-tls-uid 0.1.0.2 - set group and user id before running server  http://hackage.haskell.org/package/warp-tls-uid-0.1.0.2 (YoshikuniJujo)
02:46:23 <fizruk> pyon: there's something here: http://hackage.haskell.org/package/ClassLaws
02:47:55 <merijn> 7.8's Typed TH doesn't included "kinded TH", does it?
02:48:23 <merijn> i.e. there only seems to be a [|| ||] quasiquoter for expressions?
02:50:17 * hackagebot warp-tls-uid 0.1.0.3 - set group and user id before running server  http://hackage.haskell.org/package/warp-tls-uid-0.1.0.3 (YoshikuniJujo)
02:51:36 <pyon> merijn: not really systematic, perhaps specialized for common laws
02:51:53 <pyon> spacekitteh: heh... short of having to write the proof myself :-P
02:52:00 <pyon> fizruk: gonna check that thanks!
02:52:24 <spacekitteh> The third argument of ‘Multivector’ should have kind ‘*’, but ‘Algebra.Field.C f’ has kind ‘Constraint’ <<<< does this mean that i should use constraintkinds?
02:55:18 * hackagebot smtps-gmail 1.2.0 - Gmail SMTP Client  http://hackage.haskell.org/package/smtps-gmail-1.2.0 (EnzoHaussecker)
03:00:51 <absence> when starting a new project i've always just copied the .cabal file from a different project and edited it. i recently read about cabal init and thought that would be a better way. i ran it, it asked a few questions, then "cabal: git: does not exist". no .cabal file is generated. what's wrong?
03:01:55 <absence> obviously it can't find git, but why is it looking for it?
03:02:20 <merijn> heh
03:02:31 <merijn> That doesn't seem right
03:02:41 <merijn> absence: Which cabal version?
03:03:15 <absence> merijn: cabal-install version 1.18.0.3
03:03:16 <absence> using version 1.18.1.3 of the Cabal library
03:03:26 <Rembane> absence: This might be of help: https://github.com/haskell/cabal/issues/1613
03:04:51 <absence> Rembane: ah a bug. thanks :)
03:05:19 * hackagebot hdocs 0.4.0.0 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.0.0 (AlexandrRuchkin)
03:05:21 * hackagebot warp-tls-uid 0.1.0.4 - set group and user id before running server  http://hackage.haskell.org/package/warp-tls-uid-0.1.0.4 (YoshikuniJujo)
03:06:18 <absence> closed 4 months ago though
03:08:37 <Rembane> absence: Yes, so it should work in new versions, or at least work differently.
03:10:20 * hackagebot hdocs 0.4.0.1 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.0.1 (AlexandrRuchkin)
03:14:45 <akegalj> is anyone participating in google code jam?
03:15:20 * hackagebot hdocs 0.4.0.2 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.0.2 (AlexandrRuchkin)
03:35:23 * hackagebot test-framework-quickcheck2 0.3.0.3 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.3.0.3 (JohanTibell)
03:40:16 <Nik05> damn im feeling stupid
03:40:24 * hackagebot c2hs 0.17.1 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.17.1 (IanRoss)
03:41:29 <Nik05> made haskell program to solve euler problem. takes 40 seconds to solve... in the thread there is a haskell program of 2 lines that solves it in less than 1 second :P
03:43:43 <johannesbodannes> why wouldn't all instances of Enum be instances of Eq?
03:44:29 <johannesbodannes> if any Enum maps to a datatype (Int) which implements Eq
03:44:32 <skypers> what to do to enable haddock in hackagedb?
03:44:34 <johannesbodannes> injectively
03:45:24 * hackagebot snap-cors 1.2.2 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.2.2 (OliverCharles)
03:48:35 <edwardk> quchen: you can us the fact tat a lens can plumb 'effects' in the maybe monad through for you
03:48:58 <edwardk> > _2 Just (1,2)
03:49:00 <lambdabot>  Just (1,2)
03:49:07 <edwardk> > _2 (const Nothing) (1,2)
03:49:08 <lambdabot>  Nothing
03:50:22 <edwardk> johannesbodannes: Enum is abused to make things like floats work with [1.54..] syntax. you could have an infinite precision floating point type ypu can't check for true equality
03:50:59 <edwardk> > pred 1.4
03:51:01 <lambdabot>  0.3999999999999999
03:51:01 <johannesbodannes> woah what, float is an Enum? that's outrageous
03:51:09 <edwardk> > fromEnum 1.4
03:51:11 <lambdabot>  1
03:51:20 <johannesbodannes> that's terrible!
03:51:25 <edwardk> and so the fromEnum/toEnum for float/double lie
03:51:27 <edwardk> yep
03:54:27 <quchen> edwardk: Oh, that seems to lead back to that I don't understand how (%%~) and id work with lenses.
03:54:35 <quchen> edwardk: But maybe this usage example helps.
03:55:31 <fizruk> :t (%%~)
03:55:32 <lambdabot> Optical p q f s t a b -> p a (f b) -> q s (f t)
03:55:56 <edwardk> quchen: think of how 'traverse' plumbs applicative side-effects through. a lens can do that for any Functor
03:56:09 <edwardk> :t both
03:56:10 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
03:57:02 <edwardk> :t traverse.traverse
03:57:02 <lambdabot> (Traversable t1, Traversable t, Applicative f) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
03:57:22 <edwardk> the compositon of traversals is a traversal that now plumbs the effects under 2 levels of structure
03:59:26 <dcoutts> absence: I see the bug...
04:02:02 <skypers> no one for the haddock on hackage issue?
04:02:43 <quchen> skypers: ?
04:02:56 <skypers> quchen: look
04:03:05 <skypers> http://hackage.haskell.org/package/monad-journal
04:03:11 <skypers> the haddock documentation is unavailable
04:03:41 <dario> so in uniplate, almost all examples have type "Uniplate on => on ...". is there a mnemonic for why it's called "on"?
04:04:50 <quchen> Hmm. No idea, Skypers. Sometimes the Haddock cronjob just hasn't run, but that package has no docs for all versions, not just the latest one.
04:05:21 <skypers> quchen: so what should I try then?
04:05:27 * hackagebot yi 0.8.0 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.8.0 (DmitryIvanov)
04:05:28 * hackagebot yi-contrib 0.8.0 - Add-ons to Yi, the Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-contrib-0.8.0 (DmitryIvanov)
04:05:51 <betaveros> anybody up for helping a newbie debug a cabal install?
04:06:04 <quchen> skypers: Does "cabal haddock" work on your machine?
04:06:17 <skypers> quchen: I guess so, wait
04:06:26 <dcoutts> absence: ah, it's been fixed already: https://github.com/haskell/cabal/issues/1613
04:06:50 <dcoutts> absence: so it'll be in the next release (fairly soon)
04:06:53 <skypers> arf
04:06:58 <skypers> I updated my ghc a few days ago
04:07:05 <skypers> everything is missing :D
04:07:11 <skypers> § RECOMPILING WORLD §
04:09:36 <betaveros> uh I’m new to this IRC thing but I’ll just start typing: installing lens-4.1.2 fails with lookupSymbol failed in relocateSection (relocate external) and unable to load package `void-0.6.1’
04:10:58 <edwardk> betaveros: whenever i've seen something like that it was that something managed to get corrupted in ~/.ghc try blowing that away and reinstalling
04:11:18 <betaveros> yeah i nuked .ghc once
04:11:24 <edwardk> ugh
04:11:36 <edwardk> which ghc?
04:12:14 <betaveros> 7.6.3
04:12:27 <betaveros> also, mac os x 10.9.2
04:12:54 <skypers> huh
04:12:55 <skypers> WHAT
04:12:56 <skypers> src/Haddock/InterfaceFile.hs:85:2: error: #error Unsupported GHC version
04:12:56 <skypers> Failed to install haddock-2.14.2
04:13:06 <merijn> betaveros: Which .ghc did you nuke?
04:13:10 <skypers> this is wrong, this is very wrong
04:13:12 <merijn> betaveros: ~/.ghc ?
04:13:16 <betaveros> yeah
04:13:17 <merijn> betaveros: And did you install the platform?
04:13:34 <betaveros> as in a full reinstall from the online thing?
04:13:37 <betaveros> no...
04:13:50 <merijn> betaveros: No I mean, before nuking did you install from the platform
04:14:09 <edwardk> betaveros: hrmm https://travis-ci.org/ekmett/lens/jobs/21567225 is the build log for travis on linux for 4.1.2, and i'm also on 10.9 personally
04:14:27 <edwardk> so i'm trying to figure out what could be wrong in your build env
04:14:53 <merijn> edwardk: If he installed the platform he nuked the wrong folder
04:15:27 <betaveros> wait I’m sorry, I’m not sure what platform is referring to
04:15:28 * hackagebot hdocs 0.4.0.3 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.0.3 (AlexandrRuchkin)
04:15:34 <edwardk> merijn: you seem to have a working hypothesis. i don't, i'll let you run with it =)
04:15:37 <merijn> @where platform
04:15:37 <lambdabot> http://hackage.haskell.org/platform/
04:15:59 <merijn> betaveros: "Haskell Platform" is a distribution of GHC plus a load of standard libraries
04:16:03 <betaveros> er yeah I think that’s what I installed
04:16:14 <betaveros> (are there major alternatives?)
04:16:27 <merijn> betaveros: No, the only alternative is installing GHC directly
04:16:57 <merijn> betaveros: On OSX platform installs to ~/Library/Haskell, not ~/.ghc, there is an uninstaller script in /Library/Frameworks/GHC.framework/Versions/Current/Tools/Uninstaller for getting rid of it
04:17:10 <merijn> May want to try running the Uninstaller, reinstalling and seeing if it works then
04:17:24 <betaveros> thanks, I’ll try that
04:17:31 <skypers> quchen: I can’t install haddock
04:17:36 <skypers> it’s weird
04:17:40 <merijn> skypers: Haddock should come with GHC
04:18:00 <skypers> I don’t have it
04:18:41 <lamefun> Why are GHC/packages still not digitally signed?
04:18:43 <Fuuzetsu> what's your GHC version skypers
04:18:46 <skypers> http://git.haskell.org/haddock.git/blob/HEAD:/src/Haddock/InterfaceFile.hs#l79
04:18:48 <skypers> issue here
04:18:51 <skypers> Fuuzetsu: 7.6.3
04:19:18 <Fuuzetsu> then you can't use 2.14.x
04:20:09 <skypers> Fuuzetsu: why?
04:20:53 <Fuuzetsu> we can't reasonably keep backwards compatibility due to (haddock) interface file changes and we need to keep track of GHC API changes
04:21:31 <Fuuzetsu> perhaps in the future when dcoutts' CBOR stuff goes into binary we can have a much saner compatibility system for interface file and any API changes we can just use CPP for
04:21:37 <Fuuzetsu> but not at the moment unfortunately
04:22:11 <skypers> ok, installing 2.13 then
04:22:32 <skypers> nice, installed
04:22:39 <Fuuzetsu> I think you should be installing 7.8 instead!
04:22:50 <skypers> Fuuzetsu: GHC?
04:23:01 <skypers> quchen: yes, cabal haddock works, though I have some warnings
04:23:02 <Fuuzetsu> oh yeah and it's my fault about even being able to beging 2.14 install, we forgot to change GHC version bounds in the cabal file for 2.14
04:23:17 <Fuuzetsu> skypers: yeah, 7.8 will work with 2.14
04:23:27 <Fuuzetsu> 7.8.2 is coming out about now
04:23:28 <skypers> hm, wait
04:24:44 <skypers> the latest version of GHC is 7.6.3 in my distro
04:24:59 <skypers> oh
04:25:00 <skypers> maybe not
04:25:24 <skypers> 7.6.3-9
04:25:27 <skypers> the latest one
04:25:44 * Fuuzetsu just updates Haskell stuff by hand
04:26:19 <skypers> Fuuzetsu: yeah I don’t like that :D
04:26:44 <skypers> it’s not that bad, I’ll get the 7.8 soon I guess
04:27:00 <skypers> Warning: Control.Monad.Trans.Journal: could not find link destinations for: Data.Monoid.Monoid GHC.Base.Monad Control.Monad.Trans.Class.MonadTrans GHC.Base.Functor Control.Applicative.Applicative Control.Monad.IO.Class.MonadIO
04:27:02 <Fuuzetsu> I don't like having to wait until someone packages stuff and then end up with a broken Haskell system because it didn't like 10 GHC versions at once
04:27:04 <skypers> what the.
04:27:20 <Fuuzetsu> skypers: looks like you don't have the docs for base
04:27:33 <skypers> hm
04:27:39 <Fuuzetsu> or GHC; I hear some distros distribute that separately
04:27:46 <skypers> ok
04:27:47 <skypers> thank you
04:27:49 <Clint> that's why i use debian
04:28:44 <skypers> I’m using debian
04:28:49 <skypers> with testing pinning
04:30:12 <Clint> skypers: then you'll have to wait for 7.8.2 to come out
04:30:25 <skypers> what is library-coverage ?
04:31:44 <skypers> -- documentation: False
04:31:48 <skypers> gonna turn that to True
04:31:55 <skypers> with all profiling stuff and so on
04:31:57 <skypers> it won’t hurt
04:33:15 <skypers>     Perhaps you haven't installed the profiling libraries for package `base'?
04:33:20 <skypers> I think I broke everything.
04:33:21 <skypers> :D
04:33:26 <b0bbi10> hello, if I have this tree data type deriving Eq, how are the trees compared to each other?
04:33:27 <b0bbi10> http://ideone.com/630bVE
04:34:08 <b0bbi10> or wait, Empty being smaller than Node a (BinTree a) (BinTree a), right?
04:34:32 <tikhon> smaller?
04:34:38 <fizruk> b0bbi10: you don't need to know which is smaller
04:34:38 <tikhon> oh, you mean for Ord?
04:34:54 <b0bbi10> tikhon: yeah, sorry, probably meant Ord
04:34:55 <fizruk> b0bbi10: for Eq that is
04:35:12 <tikhon> I think it does the constructors in order
04:35:19 <fizruk> b0bbi10: for Ord the constructor that comes first is considered smaller
04:35:40 <b0bbi10> what if both Tree are non-empty?
04:35:48 <tikhon> and then it just uses the appropriate Ord instances for the contents *within* each constructor
04:36:12 <tikhon> it'll compare the fields in the order that they're written, I believe
04:36:45 <tikhon> You have (Node a_1 treeL treeR) and (Node a_1 treeL treeR)
04:36:48 <b0bbi10> tikhon: I assume it's the first appearance which is "Ord-able", in this case 'a'? how is this being calculated?
04:36:57 <tikhon> yeah
04:36:58 <b0bbi10> tikhon: yes
04:37:19 <tikhon> the generated Ord instance only works if a is in Ord itself
04:37:24 <skypers>     Could not find module `Prelude'
04:37:27 <tikhon> so it just uses the Ord instance for a
04:37:28 * skypers dies
04:37:48 <tikhon> So given (Node a1 left1 right1) and (Node a2 left2 right2)
04:38:17 <tikhon> it'll first compare a1 to a2
04:38:27 <tikhon> if they're equal, it'll compare left1 to left2
04:38:36 <tikhon> and if those are equal, it'll compare right1 to right2
04:38:37 <Clint> rm -rf ~/.ghc ~/.cabal; sudo apt-get install ghc-prof
04:38:49 <fizruk> b0bbi10: perhaps you should try to implement those instances explicitly
04:39:15 <skypers> Clint: huhu
04:39:16 <b0bbi10> tikhon: not a1.1 and a.2.1 first? (recursively?)
04:39:33 <tikhon> right, when it gets around to comparing left1 to left2, it recurses
04:39:34 <skypers> I have some customizations in my .cabal/config
04:39:46 <tikhon> but the first thing it compares is just the node label that's there by itself
04:40:08 <b0bbi10> fizruk: what do you mean?
04:40:17 <b0bbi10> tikhon: ah ok
04:40:18 <skypers> ok, I fixed it
04:40:22 <fizruk> b0bbi10: instance Ord a => Ord (Tree a) where ...
04:40:44 <tikhon> b0bbi10: try it: take two trees and fiddle with the various parts, seeing how it changes the comparison
04:41:26 <b0bbi10> and say if the Node constructor is declared as (Node b left_includes_a right_includes_a) where a is Ord and b is not, will it compare the leaves instead of a?
04:41:49 <b0bbi10> fizruk: ah ok
04:42:25 <tikhon> b0bbi10: I don't think you can derive Ord if b is not comparable
04:42:33 <tikhon> unless I'm misunderstanding something
04:42:59 <merijn> b0bbi10: The derived instance will be defined "instance Ord a => Ord (Tree a)"
04:43:07 <merijn> b0bbi10: So Tree will only be Ord if 'a' is Ord
04:43:35 <b0bbi10> ah ok,
04:43:37 <b0bbi10> thanks guys
04:46:09 <b0bbi10> it's much like thinking laterally. I feel like I begin to understand Haskell veeeryy slowly and start to somehow like it ;)
04:46:20 <skypers> :)
04:47:54 <betaveros> while I’m waiting for cabal to install: what’s with all these “warning: missing terminating ' character [-Winvalid-pp-token]”?
04:48:09 <betaveros> is using apostrophes in identifiers considered ok or not nowadays
04:49:50 <merijn> betaveros: "invalid-pp-token" <- pp sounds like (C) preprocessor, the reason GHC broke on new OSX was that they dropped gcc for clang and clang's CPP mode is not quite identical to gcc's
04:50:55 <betaveros> oh that makes sense
04:51:51 <betaveros> i installed a version of actual g++ a while ago for a certain package, I think binary, but this fresh install doesn’t know about it I guess
04:53:12 <absence> using another language's preprocessor always struck me as a bit odd
04:54:30 <lieven_> it's kind of traditional in the unix world. the alternative is something like m4.
04:56:39 <absence> another alternative would be to add language extensions that fix whatever it it people use cpp for
04:57:02 <betaveros> lens installed!
04:57:06 <skypers> @index MonadIO
04:57:06 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:57:11 <skypers> @hoogle MonadIO
04:57:11 <lambdabot> Network.CGI class Monad m => MonadIO (m :: * -> *)
04:57:12 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
04:57:12 <lambdabot> package monadIO
04:57:23 <edwardk> betaveros: nice. what was the final resolution?
04:57:28 <Yuu_chan> What's currently known about Carmack's Wolfenstein.hs?
04:57:50 <betaveros> i just went with merijin’s instructions and nuked everything
04:57:52 <edwardk> oh, yeah 7.6.3 on osx without one of the shims
04:58:03 <edwardk> that'd cause pain
04:58:06 <absence> Yuu_chan: not much
04:58:08 <skypers> hey oh
04:58:09 <skypers> Warning: Control.Monad.Trans.Journal: could not find link destinations for: Control.Monad.Trans.Class.MonadTrans Control.Monad.IO.Class.MonadIO
04:58:13 <skypers> I reinstalled monadIO
04:58:24 <skypers> @hoogle MonadTrans
04:58:25 <lambdabot> Control.Monad.Trans.Class class MonadTrans t
04:58:25 <lambdabot> package monadtransform
04:58:25 <lambdabot> package STMonadTrans
04:58:37 <skypers> isn’t it transformers?
04:58:42 <edwardk> skypers: thats just haddocks, since you probably don't have cabal configured to build them to a central location
04:58:49 <edwardk> transformers
04:59:04 <pyon-loop> an iteratee can be considered a contravariant functor on the type of the chunk it must be fed, right?
04:59:09 <betaveros> although my original goal was actually installing Idris, so I don’t know if there’s more dependency hell around the corner
04:59:18 <absence> Yuu_chan: iirc he made it as an exercise to get familiar with the language, and some experienced haskellers offered to review it for him
04:59:22 <skypers> edwardk: this is quite annoying :D
04:59:36 <edwardk> pyon-loop: depends on the iteratee variant, most actualy put it in both positive and negative position to allow pushback
04:59:43 <skypers> ok hten
04:59:49 <pyon-loop> ah!
04:59:50 <skypers> quchen: my monad-journal haddock is quite okay
04:59:54 <edwardk> pyon-loop: if they don't and merely continue on with  number of items consumed then yes, it can be contravarant in the argumnt
05:00:03 <skypers> I don’t understand why the cronie job doesn’t build it in hackagedb then
05:00:04 <edwardk> er variant
05:00:55 <edwardk> pyon-loop: i don't know of any of the mainstream iteratee variants that actually do that though
05:01:56 <pyon-loop> an enumerator that yields enumerators of T can be "flattened" into an enumerator of Ts... i was wondering if something similar (or dual?) could be done to "extend" iteratees that take Ts into iteratees that take iteratees that take Ts
05:02:23 <pyon-loop> no wait i'm not even thinking properly
05:11:01 <Yuu_chan> absence: did he accept that? :) That's a pity the project status is still unknown, although it was revealed nearly a year ago.
05:13:46 <Yuu_chan> In discussions with imperativists, I consider a good point that both Carmack and Sweeney, well-known masters of low-level programming, still praise FP and Haskell.
05:15:45 <absence> Yuu_chan: i don't know, but i would guess so. i think carmack made some brief comments about the experience on twitter
05:21:12 <absence> Yuu_chan: sweeney even coauthored a paper: http://www.leafpetersen.com/leaf/publications/dtp2013/lambda-aleph-overview.pdf
05:21:51 <b0bbi10> fmap :: (a -> b) -> f a -> f b  LYAH says "we see that the f type variable is used as a type that takes one concrete type to produce a concrete type. We know it has to produce a concrete type because it's used as the type of a value in a function." which type is meant here? I don't see the concrete type the author is referring to. could you give me a hint?
05:23:38 <pyon-loop> b0bbi10: you know how (value-level) functions take input values and return output values, right? type-level functions are just like that, but at the type level - and f is a type-level function
05:24:29 <b0bbi10> so it takes a type (not type constructor) and returns a type (again, not type constructor)?
05:24:47 <tibbe> is it possible to include internal modules when building haddocks?
05:24:50 <merijn> betaveros: I really hate that sentence in LYAH
05:25:10 <Yuu_chan> absence: thanks for a link! I'm currently trying to delve into dependent types.
05:25:18 <merijn> betaveros: It keeps confusing newbies that come here to ask about it. Don't think too hard on what a "concrete type", there is no nice definition of the term
05:25:18 <b0bbi10> just when I thought I would understand how Functors work, I actually don't :/
05:25:19 <yorick>     Module `Control.Monad.Trans.Resource' does not export `ResourceIO' <-- am I crazy? I'm pretti sure it does?
05:25:24 <merijn> eh
05:25:27 <yorick> pretty*
05:25:28 <betaveros> that was meant for b0bbi10 right
05:25:30 <merijn> s/betaveros/b0
05:25:37 <merijn> argh
05:25:43 <merijn> I'm failing at tab-complete everywhere
05:25:49 <merijn> But yes, that was for b0bbi10
05:26:12 <yorick> I'm not crazy, am I?
05:26:13 <absence> Yuu_chan: i haven't read it myself, enjoy :)
05:26:22 <Yuu_chan> I can remember that Sweeney mentioned a lot of them in his presentation
05:26:23 <betaveros> w00t Idris just finished installing
05:26:24 <yorick> I thought this should work
05:26:28 <pyon-loop> b0bbi10: just like types classify values, there is a notion of kind, where kinds classify things that exist at the type level
05:26:32 <yorick> where do I import ResourceIO from then?
05:27:11 <yorick> hello, anyone?
05:27:28 <b0bbi10> pyon-loop: I get that abstract definition, but I don't get the "implementation"
05:27:40 <b0bbi10> I'll just read on, maybe it'll get cleared later
05:27:41 <b0bbi10> thanks
05:27:44 <Yuu_chan> absence: I probably won't have enough time and brain to read it completely, but it will be interesting at least to look from his pov
05:27:48 <pyon-loop> b0bbi10: ok :-) gl
05:29:30 <Yuu_chan> What are those massive reconnections last days?
05:29:41 <yorick> hello? how do I import ResourceIO?
05:29:59 <yorick> I thought it was in Control.Monad.Trans.Resource, but ghc says it isn't
05:30:03 <absence> @hoogle ResourceIO
05:30:03 <lambdabot> No results found
05:30:06 <absence> :(
05:30:14 <Clint> yorick: http://hackage.haskell.org/package/resourcet-1.1.1/docs/Control-Monad-Trans-Resource.html#t:MonadResourceBase
05:30:45 <yorick> I just want to be able to write ResourceIO m => Request -> Manager -> ResourceT m (Maybe String)
05:31:32 <Clint> and are you using a version of resourcet new enough to not have ResourceIO anymore?
05:31:42 <bennofs> is there a function to convert a type-level nat to a value-level nat?
05:31:44 <yorick> Clint: it was removed?
05:31:55 <yorick> yeah, I probably am
05:31:57 <Clint> yorick: did you not read the link above?
05:32:27 <yorick> Clint: oh, it says something about it
05:32:33 <Clint> hence its relevance
05:33:57 <Yuu_chan> bennofs: do you mean nats from new versions of GHC?
05:35:54 <bennofs> Yuu_chan: yes
05:41:11 <Yuu_chan> bennofs: please take a look at natVal from GHC.TypeLits
05:41:45 <bennofs> Yuu_chan: ah, thanks, that looks like what I've wanted
05:43:56 <b0bbi10> concerning fmap in Functor again: fmap :: (a -> b) -> f a -> f b "We know it has to produce a concrete type because it's used as the type of a value in a function" which variable is meant by "type of a value in a function"?
05:44:00 <b0bbi10> b?
05:44:25 <b0bbi10> or 'f b' (which is a concrete type)?
05:44:43 <pyon-loop> b0bbi10: b is a concrete type as well
05:44:45 <bennofs> b0bbi10: both must be concrete types (where concrete type means "something with kind *")
05:45:25 * merijn bans the term "concrete type"
05:45:34 <b0bbi10> ;D
05:45:49 <b0bbi10> which is the 'value' variable then?
05:46:15 <Yuu_chan> By «c**crete» here do you mean monomorphic?
05:46:30 <merijn> Yuu_chan: He means the term as used in LYAH which doesn't define it
05:46:31 <pyon-loop> Yuu_chan: no, simply "has kind *"
05:46:55 <merijn> LYAH seems to alternatingly use "concrete type" for either monomorphic types or types of kind *
05:46:56 <b0bbi10> I understand that a concrete type has a kind of '*'
05:47:00 <Yuu_chan> merijn: I didn't read LYAH, so I wondered
05:47:18 <b0bbi10> but I don't see how that fits together in that context
05:47:19 <Yuu_chan> Ok, thanks
05:47:41 <pyon-loop> merijn: in all fairness it's clear when either meaning is used from context
05:47:58 <merijn> pyon-loop: Not when people come here and think it has some well-defined meaning :)
05:48:36 <pyon-loop> but yea i agree it's better to say "that has kind *" or "monomorphic" based on what you actually mean
05:48:38 <merijn> b0bbi10: It probably helps to know the basics of "kinds"
05:49:17 <merijn> b0bbi10: kinds are the "types of types", so "5 :: Int" (5 has type Int) and "Int :: *" (Int has kind *)
05:49:17 <b0bbi10> :k Int := * and :k Maybe := * -> *
05:49:18 <lambdabot> parse error on input *
05:49:23 <b0bbi10> that enough merijn? ;D
05:49:25 <merijn> b0bbi10: Right
05:49:28 <Yuu_chan> Could someone briefly explain higher-kinded types?
05:49:48 <merijn> b0bbi10: So in this context I would read "concrete type" as "type with kind *"
05:50:00 <merijn> b0bbi10: Clearly the 'f' from Functor has kind "* -> *"
05:50:11 <merijn> b0bbi10: So "f a :: *"
05:50:32 <merijn> Yuu_chan: higher kinded is just "takes arguments of a kind other than *"
05:50:42 <merijn> Yuu_chan: For example, take StateT
05:50:55 <merijn> Yuu_chan: "StateT :: * -> (* -> *) -> * -> *
05:51:02 <Yuu_chan> What are kinds of types with constraints? (yeah, I know they are bad)
05:51:42 <b0bbi10> merijn: ok, that clear now, but where is it " used as the type of a value in a function"
05:51:43 <merijn> The constraint doesn't really change the kind of a type
05:51:58 <b0bbi10> I assume by function the author means contructor?
05:52:13 <merijn> b0bbi10: What he means is "(->) :: * -> * -> *"
05:52:29 <merijn> b0bbi10: So passing "f a" as argument to (->) means "f a :: *"
05:52:29 <Yuu_chan> Thank you merijn
05:52:58 <merijn> b0bbi10: Because otherwise giving "f a" to (->) would be a kind error
05:53:06 <Yuu_chan> AFAIR it's an extension, can monad transformers be defined without them?
05:53:22 <merijn> Higher kindedness doesn't require an extension in haskell
05:53:50 <Yuu_chan> Ok, so I remember wrong
05:53:51 <merijn> Neither do monad transformers
05:53:51 <b0bbi10> merijn: so the value (specifically, the variable that holds that value) he is talking about is "a"?
05:54:08 <b0bbi10> because that's used in a function
05:54:50 <merijn> "We know it has to produce a concrete type because it's used as the type of a value in a  function"
05:55:20 <Yuu_chan> Yay, so HKTs are somewhat like HOFs
05:55:27 <merijn> b0bbi10: To me that reads as "we know 'f a :: *' because 'f a' is the type of a function argument and function arguments must always be of kind *"
05:56:10 * Yuu_chan wonders about something like "higher-sorted kinds"
05:57:36 <b0bbi10> merijn: ok, that part is clear now, so the function which that argument is passed to is (a->b) (i. e. the function passed)?
05:58:21 <merijn> b0bbi10: What's the context?
05:58:41 <b0bbi10> maybe I'll do an FAQ with all the difficulties when reading LYAH when I am finishing it
05:59:22 <b0bbi10> merijn: still fmap :: (a -> b) -> f a -> f b     "f a :: *" is passed to (a -> b), right?
05:59:36 <merijn> No
05:59:47 <merijn> Why would it be?
06:00:18 <b0bbi10> because that's the only function I am seeing in there and you said "f a" is the type of a function argeument
06:00:31 <b0bbi10> argument*
06:00:50 <Axman6> function or functor?
06:01:57 <b0bbi10> function I guess, I am not sure
06:02:23 <augur> ugh wheres preflex
06:02:24 <merijn> b0bbi10: There's two function arguments "(a -> b)" and "f a"
06:02:24 <srhb> b0bbi10: Well, the type signature is really fmap :: Functor f => (a -> b) -> f a -> f b
06:02:41 <merijn> augur: It used to run on mauke's desktop and he told me his desktop died
06:03:28 <augur> merijn: horrible
06:03:59 <b0bbi10> ah ok guys
06:04:11 <b0bbi10> I think I have to digest what you said right now first :)
06:04:16 <b0bbi10> thanks so far
06:05:27 <peglong> !help
06:09:39 <srhb> peglong: *helps*
06:11:41 <augur> grr
06:11:45 <augur> wheres ski when i need him
06:12:45 <bwright> How do I deal with: cannot be used when making a shared object; recompile with -fPIC
06:12:56 <bwright> On a given program?
06:13:52 <Axman6> huh, peglong is here too? came into #macosx and did the same thing. bot?
06:15:21 <bwright> Can I get haskell to use aslr at all?
06:16:01 <bwright> When calling into something say for making xmonad, can I force ghc to accept extra flags?
06:16:04 <bwright> In any sane way?
06:18:18 <sleepynate> oh man i think my atomic will be here today <3
06:18:44 <b0bbi10> "Making Frank an instance of Tofu is pretty simple. We see that tofu takes a j a (so an example type of that form would be Maybe Int) and returns a t a j. So if we replace Frank with j, the result type would be Frank Int Maybe." that should probably mean "Frank with t", right? for anyone who has read LYAH (http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass)
06:19:44 <b0bbi10> as a side note: if you feel that my questions are inadequate in here, please let me know. I sometimes have the feeling that I am the only one asking newbie questions in here...
06:29:16 <Yuu_chan> b0bbi10: please don't worry for asking newbie questions! I've seen a lot of newcomers here and they always got definitive help.
06:30:46 * hackagebot diagrams-contrib 1.1.1.4 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.1.4 (jeffreyrosenbluth)
06:30:52 <quicksilver> bobobo1618: I think it should say "t with Frank" really
06:31:29 <rnd101010> Hi
06:31:37 <Yuu_chan> Hai
06:32:10 <b0bbi10> ok, thanks
06:32:39 <rnd101010> I've some trouble compiling xmonad.hs, it's complaining about a missing module. Point is the module is installed (xmonad-contrib) and the xmonad.hs will compile on my laptop. Any ideas on where to look?
06:40:54 <pillar_Young1> what to do to make getChar return when user put a char not untill a Enter put
06:43:48 <srhb> pillar_Young1: You need to handle buffering
06:44:00 <srhb> pillar_Young1: Something like hSetBuffering stdin NoBuffering
06:45:10 <srhb> Also note that that's not platform independent -- it won't work on Windows
06:45:48 * hackagebot scion-browser 0.3.0 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.3.0 (JeanPhilippeMoresmau)
06:45:50 * hackagebot diagrams-postscript 1.0.2.4 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.0.2.4 (jeffreyrosenbluth)
06:48:04 <pillar_Young1> srhb:it doesn't work , i'm work with windows.
06:49:30 <srhb> pillar_Young1: Then you need to google some of the workarounds (or give up)
06:49:36 <srhb> It's really messy on Windows.
06:49:45 <bennofs> in a `finally` b, is it valid that both a and b throw exceptions?
06:50:17 <srhb> pillar_Young1: http://stackoverflow.com/a/13370293/288913
06:50:29 <srhb> Sure.
06:50:38 <srhb> bennofs: You could presumably even chain them
06:52:04 <pillar_Young1> srhb: thanks
06:52:43 <srhb> bennofs: easy to test, do something like finally c (finally a b)
06:52:47 <aloiscochard> how do you guys install ghc 7.8.1 on archlinux?
06:52:53 <srhb> Raise an exception in a, see if you handle it in c
06:53:02 <srhb> aloiscochard: You might want to wait for 7.8.2
06:53:10 <srhb> aloiscochard: A lot of things are broken due to a silly bug in 7.8.1
06:53:23 <yorick> do a <- Maybe something. in that case a should be `something`, right?
06:53:37 <aloiscochard> srhb: oh I see, but still what the approach for such thing in general? compile from source?
06:53:40 <srhb> yorick: Ish
06:53:50 <srhb> yorick: a <- Just "foo"; a is "foo"
06:54:09 <srhb> aloiscochard: It's a lot faster to grab the binary amd64 package from ghc HQ
06:54:24 <srhb> aloiscochard: Then all you need is a working cabal-install, say the one from pacman, and you're good to go
06:54:33 <yorick> srhb: yeah. I have a thing that goes like do qs <- lookup (blah) $ blah, but according to ghc qs is still a Maybe ByteString
06:54:33 <srhb> aloiscochard: (Building GHC takes about two hours on my machine...)
06:54:38 <aloiscochard> srhb: that sound indeed much better! thank you very much :-)
06:54:48 <aloiscochard> srhb: (last time I tried it took more than 4hours!)
06:54:56 <srhb> yorick: Well lookup does return a Maybe something right?
06:55:01 <yorick> srhb: it does
06:55:11 <yorick> srhb: but that's what the do is for, right?
06:55:14 <srhb> yorick: So you need to handle either case, say with case
06:55:40 <yorick> srhb: my do is in another maybe block, so it should just return Nothing
06:55:43 <srhb> yorick: foo <- lookup ...; case foo of Just something -> ; Nothing -> ...
06:55:47 <srhb> Ah
06:55:49 * hackagebot edenskel 2.0.0.0 - Semi-explicit parallel programming skeleton library  http://hackage.haskell.org/package/edenskel-2.0.0.0 (MischaDieterle)
06:55:54 <srhb> but what does your do-block end with?
06:56:30 <yorick> srhb: parseURI $ qs
06:56:56 <srhb> yorick: What's the type of parseURI?
06:57:10 <yorick> srhb: ByteString -> Maybe URI
06:57:32 <srhb> yorick: I'm confused now -- can you maybe post your code? :)
06:57:57 <srhb> yorick: As I understand it you want to chain some Maybe computations, in which case all your need is blah >>= parseURI
06:58:06 <srhb> where blah is Maybe ByteString
06:58:17 <srhb> Nonsense
06:58:22 <srhb> er, no, that was right
06:58:25 * srhb gets coffee
06:58:34 <yorick> srhb: http://pastie.org/private/84ypxcnsbqhaiea90snaa
06:59:27 <Yuu_chan> pillar_Young1: I can help with windows workarounds
06:59:54 <srhb> yorick: What's the problem with that?
07:00:27 <yorick> srhb: Couldn't match expected type `ByteString` with actual type `Maybe ByteString` in first argument of `toArxivAPI`, namely `qs`
07:02:17 <srhb> yorick: I'm guessing the type of the right-hand-side of <- is not what you expect it to be
07:02:21 <srhb> Try constraining it with a signature
07:02:53 <srhb> Or try replacing it with Just (pack "test")
07:02:58 <yorick> srhb: you're right, the right hand side is actually Maybu Maybe ByteString
07:03:12 <srhb> Indeed.
07:05:07 <yorick> srhb: thank you! I added a join and now it's working
07:05:13 <srhb> yorick: Perfect. :)
07:05:37 <yorick> srhb: do you have any tips on how to deal with the whole mess of Network.URI using String and network.HTTP.Types.URI using ByteString?
07:05:59 <quchen> 7.8.2 just landed, it seems.
07:06:48 <srhb> quchen: just when I finally managed to build it, haha
07:06:51 <quchen> Can't wait to recompile *everything* again
07:06:54 <quchen> :>
07:06:59 <srhb> quchen: Where is it?
07:07:20 <quchen> https://github.com/ghc/ghc/commit/010941a40c2f005e83a96a5ae2d403c745cc0436
07:08:15 <bennofs> I have an expression in applicatibe style: (f :: a -> b -> c -> d -> e) <$> a <*> b <*> c <*> d. Now suppose that I want to change c to be of type f (c,x) instead of just f c, and I want f (e,x) to be the type of the whole expression. Is there an easy way to do that?
07:09:19 <srhb> quchen: Phew, no other changes
07:09:22 <srhb> No rebuilding for me. :3
07:10:22 <zwarn> i have a question regarding monad transformers
07:10:27 <srhb> [swift]: ask.
07:10:29 <srhb> ...
07:10:31 <srhb> zwarn: ASk :P
07:10:34 <klrr_> zwarn: just ask
07:10:35 <klrr_> :P
07:12:25 <zwarn> i want to supply a list of monadtransformers to a runTransformers methode to be stacked together
07:12:49 <zwarn> but i cant figure out the types
07:13:02 <dwcook> zwarn, I don't think that's actually what you want.
07:13:12 <dwcook> What is your goal?
07:13:48 <zwarn> i want to build something that lets me "lift by name"
07:14:26 <zwarn> i want to associate a name with each transformer and to lift an operation to the appropriate transformer
07:14:49 <dwcook> zwarn, you could easily write local bindings liftFoo = lift, liftBar = lift . lift, etc.
07:15:28 <zwarn> but if i change the stack i have to rewrite the bindings right?
07:15:37 <zwarn> that seems minor but...
07:15:49 <dwcook> Yeah
07:15:55 <corgifex> and you can't use the type class trick?
07:16:23 <absence> zwarn: it sounds like you want the effect system in idris
07:16:40 <corgifex> :t get
07:16:41 <lambdabot> MonadState s m => m s
07:18:30 <srhb> Indeed, the type class stuff should work as long as you're not layering the same transformer more than once
07:18:38 <srhb> Which probably is a sign you're doing something silly anyway
07:18:43 <srhb> At least rename them in that case. :)
07:18:47 <dwcook> ghci tells me it can't find Control.Monad.Trans when I try to import it, as well as: Perhaps you haven't installed the "dyn" libraries for package ‘mtl-2.1.3.1’? What should I do?
07:19:04 <dwcook> I recently installed ghc from binaries
07:19:13 <srhb> dwcook: Sounds like you need to build mtl with dyn :)
07:19:20 <zwarn> good i can live with that for now
07:19:21 <corgifex> which version of ghc?
07:19:22 <zwarn> thanks
07:19:22 <dwcook> How do I do that?
07:19:30 <dwcook> 7.8.1
07:19:34 <corgifex> don't bother
07:19:36 <srhb> dwcook: It's borken
07:19:40 <srhb> dwcook: Wait for 7.8.2
07:19:40 <dwcook> Ah
07:19:47 <srhb> The error is unrelated though
07:19:50 <srhb> Not sure what you did wrong
07:19:51 <dwcook> Oh, so the problem is just with ghci?
07:19:58 <srhb> Probably version mismatches
07:20:02 <thoughtpolice> dwcook: cabal --version
07:20:03 <merijn> I know what he did wrong :)
07:20:06 <absence> what platform is it broken for?
07:20:11 <merijn> absence: Everything
07:20:13 <thoughtpolice> dwcook: what does that say?
07:20:23 <merijn> absence: Some of Yesod doesn't compile due  a bug in type families
07:20:48 <dwcook> thoughtpolice, cabal-install version 1.18.0.3
07:21:01 <merijn> ghci requires dynamic libraries in 7.8 and if you have an old cabal and old cabal config it won't build dynamic libraries by default
07:21:21 <dwcook> I have the current cabal and a config for that
07:21:53 <srhb> thoughtpolice: If I change build.mk from the fast to the slow build, how far back do I need to go in the build process? Is make sufficient?
07:22:32 <dwcook> merijn, is there something I actually did wrong or is something just broken?
07:22:59 <srhb> dwcook: You did something wrong. The bug is unrelated.
07:23:18 <dwcook> Okay, any idea what I did wrong?
07:23:31 <dwcook> As far as I'm aware I built mtl with the latest cabal.
07:24:10 <thoughtpolice> srhb: you'll need to do a full rebuild due to the way build.mk works, since IIRC it'll be picked up at ./configure time roughly
07:24:28 <srhb> thoughtpolice: Thanks. :)
07:25:02 <srhb> so make distclean?
07:25:14 <thoughtpolice> that should be fine, yes
07:25:20 <thoughtpolice> generally i do make distclean && make maintainer-clean
07:25:34 <srhb> Gotcha
07:25:48 <dwcook> Oh, woops, my cabal config might have been old
07:25:56 <srhb> What's the point of building ghc itself with llvm by the way?
07:25:58 <thoughtpolice> dwcook: there could be other things in your config which prohibit shared libraries from building. the easiest way is just to start with a 'clean slate' and remove the old config files and .ghc stuff
07:26:14 <thoughtpolice> dwcook: but i imagine this is the likely cause. do try getting rid of your ~/.cabal/config and having cabal generate a new one
07:26:21 <thoughtpolice> then try --reinstall on mtl and see if that works
07:26:28 <Sculptor> hi! friday!
07:26:45 <tibbe> I need closed typed families. They would allow me to do C++ like template specifializations!
07:26:47 <thoughtpolice> srhb: some platforms don't have native code generator support, so LLVM is the only way to compile
07:27:02 <thoughtpolice> some people may tell you it's faster too, i don't really know. but it takes a whole lot longer to compile, i know that
07:27:03 <srhb> Ah
07:27:11 <thoughtpolice> so i never use it
07:27:13 <srhb> I'll stick to perf then
07:27:19 <dwcook> thoughtpolice, I figured out that I hadn't deleted my cabal file by nuking everything and retracing my steps
07:27:41 <dwcook> s/cabal/config/
07:27:54 <thoughtpolice> dwcook: OK, cool. just 'rm -f ~/.cabal/config; rm -rf ~/.ghc/*-7.8.1; cabal update && cabal install mtl' should do the trick, i think
07:28:00 <thoughtpolice> or something like that, you get the idea
07:28:07 <dwcook> Too late for that now, I'm re-upgrading cabal now :P
07:28:11 <dwcook> But thanks
07:37:36 * aloiscochard wonder what was that criticla bug in GHC 7.8.1 that srhb was referring too
07:38:12 <corgifex> aloiscochard: https://ghc.haskell.org/trac/ghc/ticket/8978
07:38:27 <aloiscochard> corgifex: ty!
07:39:40 <corgifex> does anyone know when 7.8.2 will come out?
07:40:18 <srhb> Any moment now, I bet. :P
07:41:42 <corgifex> I'm F5'ing the download page like crazy!!!
07:41:50 <srhb> Haha.
07:42:08 <srhb> I think you can safely assume we'll get a heads-up.
07:43:44 <thoughtpolice> it'll take a little while, there are still some things building
07:53:49 <aloiscochard> damn, that regression was not in the RC2, bad luck :-/
07:54:51 * geekosaur hopes this was added to the tests
07:55:11 <corgifex> the patch at least touched some tests
07:56:31 <hexagoxel> in mtl, why don't the classes have instances that lift over any MonadTrans? (more elaborate question at http://lpaste.net/102548)
07:57:34 <c_wraith> hexagoxel: that overlaps with nearly everything
07:57:35 <geekosaur> hexagoxel, as soon as you drag in IncoherentInstances you are in big trouble
07:57:44 <merijn> hexagoxel: IncoherentInstances is a disaster waiting to happen :)
07:57:54 <geekosaur> it's the compiler warning you that you are doing something very unsafe
07:58:11 <c_wraith> If you don't know what IncoherentInstances does, you shouldn't use it. :)
07:58:32 <merijn> hexagoxel: Basically, the reason not to do this is because it stops the compiler from concluding *anything* about your monad stack :)
08:00:57 * hackagebot edenskel 2.0.0.1 - Semi-explicit parallel programming skeleton library  http://hackage.haskell.org/package/edenskel-2.0.0.1 (MischaDieterle)
08:02:05 <hexagoxel> well the testcases worked.. even at runtime :)
08:02:23 <hexagoxel> can you point me to any good explanation about incoherentInstances?
08:04:06 <yorick> hey, what does -< do?
08:04:16 <yorick> that's pretty hard to google :/
08:04:28 <companion_cube> it's an arrow I think
08:04:31 <c_wraith> yorick: that's arrow syntax
08:04:46 <c_wraith> Unless someone defined an operator with that name just to maximize confusion
08:04:52 <yorick> I know that, it's used in xht examples at do foo <- stuff -< thing
08:04:53 <hexagoxel> and if that solution is bad, is there any other way to avoid the n*n instance definitions (or a totally different, and better approach to the problem)?
08:05:00 <c_wraith> yorick: so look up arrow syntax
08:05:34 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap mentions it (and some issues with it)
08:05:46 <c_wraith> yorick: All that arrow stuff was sort of a bad idea, and its special syntax is even worse.
08:06:06 <geekosaur> incoherent instances basically means that different parts of your program can make different choices about which instance to use; if they share data, the result is chaos
08:06:14 <Phillemann> c_wraith: How so?
08:06:27 <Phillemann> I've just learned how to use arrows (and what they are), so I'm wondering. :)
08:06:51 <geekosaur> Phillemann, it turns out that the useful parts of arrows are the parts missing the core (the "arr" combinator). applicatives evolved out of that idea
08:07:04 <c_wraith> Phillemann: it's a very complicated abstraction that gives you approximately the same power as combining category and applicative do.
08:07:10 <geekosaur> and applicatives don't need the weird syntax
08:07:39 <bennofs> geekosaur: i sometimes wish there were banana brackets or applicative do :|
08:07:39 <corgifex> "idiom brackets"
08:07:41 <c_wraith> Phillemann: Applicative is just plain easier to use.
08:07:43 <Phillemann> I see, so my time is better invested in applicative, then. ;)
08:07:52 <dwcook> geekosaur, I'm not sure I parsed that correctly – Are you saying the useful parts are everything but arr?
08:07:54 <Phillemann> I _did_ have some fun with HXT though.
08:08:04 <geekosaur> dwcook, pretty much, yes
08:08:15 * yorick is not having fun with HXT
08:08:16 <geekosaur> arr *does* have its uses, but you can get that back by using Category
08:08:25 <corgifex> arr is the one that embeds random haskell functions, right?
08:08:25 <geekosaur> and still without the weird added syntax
08:08:34 <dwcook> @type arr
08:08:35 <lambdabot> Arrow a => (b -> c) -> a b c
08:08:36 <merijn> geekosaur: I dunno, I kinda like arrow syntax
08:08:57 <geekosaur> but the arrow abstraction can be much more general than Arrows if you consider arr to be an add-on; this leads to applicatives
08:09:03 <dwcook> So, every arrow has to be at least as powerful as functions?
08:09:21 <c_wraith> dwcook: yeah..  You need a way to embed arbitrary functions, at the very least
08:09:40 <n-dolio> Which ruins a bunch of arrows you might want to make.
08:10:00 <yorick> runLA (xread >>> deep getElemName) ("xml document")) is returning an empty list.
08:10:05 <yorick> why would it return an empty list
08:10:28 <n-dolio> Also there are different directions you might want to go in that don't work with quite a few arrows.
08:10:49 <carter> whats the difference in n-dolio  and dolio ?
08:10:51 <n-dolio> But are probably more interesting for an arrow-like abstraction.
08:10:57 <c_wraith> carter: how many of him there are
08:11:09 <n-dolio> carter: Location.
08:11:11 <c_wraith> carter: when both are present, there are n+1
08:11:12 <Phillemann> So what do I use to dive into XML in Haskell (instead of the arrow-heavy HXT)?
08:11:23 <carter> @hackage xml ?
08:11:23 <lambdabot> http://hackage.haskell.org/package/xml ?
08:11:40 <c_wraith> That package needs some lenses
08:11:43 <bergmark> xml is simple but not very expressive
08:11:50 <c_wraith> Then it'd actually be expressive
08:12:00 <c_wraith> (prisms, I suppose, to be precise)
08:12:07 <bergmark> there's already something better than lenses for it! https://github.com/silkapp/xml-arrow
08:12:07 <skypers> what do you think is the best
08:12:16 <skypers> mapM (lift a)
08:12:17 <skypers> or
08:12:25 <skypers> lift (mapM a)
08:12:38 <c_wraith> bergmark: oh, you work for silk?
08:12:39 <carter> :t lift
08:12:40 <skypers> I guess extracting lift outside is better
08:12:40 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
08:12:40 <bergmark> i think xml is really slow too
08:12:41 <n-dolio> Man, I should have said "locale." That would have been a better pun.
08:12:53 <bergmark> c_wraith: yes :-)
08:13:11 <super_teufel> hi, why ghci give something  [Just "test" ,  ****Exception : Prelude.undefined                versus  runghc  main.hs : Prelude.undefined
08:13:15 <c_wraith> bergmark: where are you guys located, again?
08:13:36 <bergmark> c_wraith: amsterdam
08:13:46 <skypers> @let clamp :: (Ord a) => a -> a -> a -> a; clamp mn mx = max mn . min mx
08:13:55 <skypers> hello lambdabot ?
08:14:00 <c_wraith> @botsnack
08:14:01 <lambdabot> :)
08:14:07 <c_wraith> :t clamp
08:14:08 <lambdabot> Not in scope: clamp
08:14:11 <skypers> @let clamp :: (Ord a) => a -> a -> a -> a; clamp mn mx = max mn . min mx
08:14:17 <skypers> wat
08:14:22 <c_wraith> lambdabot just doesn't like you
08:14:26 <skypers> :(
08:14:34 <skypers> @let
08:14:34 <lambdabot>  Define what?
08:14:53 <skypers> @let clamp mn mx = max mn . min mx
08:15:01 <skypers> come on!
08:15:25 <skypers> lambdabot: can you be kind for once?
08:15:27 <int-e> hmm.
08:15:59 <c_wraith> int-e: your bot doesn't like skypers. :)
08:16:00 <corgifex> super_teufel: what's your code?
08:16:08 <int-e> @let clamp mn mx = max mn . min mx
08:16:21 <fizruk> > let clamp mn mx = max mn . min mx in clamp 10 20 43
08:16:21 <c_wraith> It knows he tried to define that originally. :)
08:16:22 <lambdabot>  20
08:16:24 <skypers> it’s the first step before skynet.
08:16:28 <int-e> it doesn't like anybody, it seems.
08:16:34 <int-e> @let one = 42
08:16:36 <int-e> ;-)
08:16:39 <corgifex> @lettuce
08:16:39 <lambdabot> Unknown command, try @list
08:16:43 <super_teufel> corgifex :   something like putStrln $ show [Just "test, undefined]
08:16:59 <int-e> probably something broke with the update to ghc 7.8.1
08:17:02 <corgifex> super_teufel: probably output buffering
08:17:12 <int-e> I'll look at it later, still at work.
08:17:48 <dmj`> am I the only person who has tried to compile acid-state on 7.8?
08:18:19 <corgifex> dmj`: no
08:18:25 <dmj`> corgifex: have you?
08:18:29 <corgifex> no
08:18:30 <int-e> (there is an error: [ERROR] : Main: caught (and ignoring) Enum.toEnum{Word8}: tag (8216) is outside of bounds (0,255))
08:18:42 <int-e> looks fun.
08:18:44 <dmj`> corgifex: so then how do you know
08:19:01 <corgifex> dmj`: someone else mentioned it here
08:19:11 <dmj`> who?
08:19:12 <skypers> @index max
08:19:12 <lambdabot> Prelude
08:19:19 <corgifex> dmj`: your questions seem pointless
08:19:27 <corgifex> is this a survey?
08:19:43 <c_wraith> int-e: you should probably tell it not to use unicode quotes in error messages, too
08:19:55 <c_wraith> int-e: that's definitely a new 7.8 thing
08:20:22 <int-e> Which is ‘ in Unicode. Probably some ghc warning or error that uses unicode. (As c_wraith is saying.)
08:20:30 <dmj`> corgifex: no, I use acid-state heavily and compiling w/ 7.8 breaks it, on both osx and ubuntu, and I want to be sure it's not just me.
08:20:49 <corgifex> dmj`: https://ghc.haskell.org/trac/ghc/ticket/8978
08:21:17 <corgifex> that's easy to answer. it's a known bug in 7.8.1; 7.8.2 is expected shortly
08:21:29 <c_wraith> int-e: ghc used to quote identifiers in error messages with ` and '.  it switched to unicode quotes in 7.8 if your locale supports them
08:21:57 <corgifex> dmj`: I recommend just asking your question instead of looking for specific people
08:22:18 <int-e> c_wraith: which it does because I have LC_CTYPE=en_US.UTF-8
08:22:38 <skypers> http://www.reddit.com/r/haskell/comments/22s7r2/clamp/
08:22:43 <skypers> tell what you think
08:22:49 <dmj`> corgifex: What does your link have to do w/ acid-state build errors?
08:22:53 <c_wraith> lambdabot's unicode support is only ever accidentally correct anyway
08:23:08 <int-e> anyway. it'll have to wait for now.
08:23:14 <corgifex> dmj`: it's the bug that prevents acid-state from building
08:23:22 <dmj`> corgifex: where do you see this?
08:23:28 <corgifex> see what?
08:23:40 <dmj`> what leads you to believe this is the bug that keeps acid-state from building
08:24:03 <corgifex> because acid-state uses associated types and a 'type' alias for them
08:24:34 <corgifex> and the acid-state error is about not being able to resolve a MonadState instance because it can't figure out that the alias is the same as the other type
08:26:44 <corgifex> dmj`: what leads you to believe this may be a different issue?
08:28:43 <dmj`> corgifex: I see, type MethodState ev is affected. Wasn't aware of this issue
08:29:31 <dmj`> corgifex: thank you
08:29:32 <otaner> ciao
08:31:58 <fizruk> is there a way to avoid this error? http://lpaste.net/102562
08:32:19 <fizruk> (without specifying any Monad)
08:33:38 <hexagoxel> c_wraith, geekosaur, merijn: i read up a bit on IncoherentInstances, and, as it turns out, i don't need those. But i still need (FlexibleInstances, UndecidableInstances, OverlappingInstances). Are these as "ugly"?
08:33:48 <c_wraith> OverlappingInstances is
08:33:56 <c_wraith> The other two are fine
08:34:27 <c_wraith> the real problem is that instance matches every type with a type constructor.
08:34:54 <c_wraith> Well.  Every type with a type constructor of kind * -> *
08:35:42 <c_wraith> fizruk: I suspect the monomorphism restriction
08:36:14 <fizruk> c_wraith: what exactly do you mean?
08:36:30 <corgifex> c_wraith: ?
08:36:32 <fizruk> also this is a bit strange: http://lpaste.net/102563
08:36:41 <c_wraith> fizruk: it just seems like something is forcing f to be monomorphic at a point when it doesn't need to be
08:37:29 <c_wraith> fizruk: you could fix it with an impredicative type.  But you really don't want to.
08:37:52 <corgifex> fizruk: that makes sense in context
08:38:21 <corgifex> fst x eliminates an ambiguous type variable, but snd x keeps it so it can appear in the type without problems
08:38:34 <corgifex> but you can't have something like fst x :: (Monad m0) => Int
08:39:38 <c_wraith> fizruk: if you wrote the type as (Int, Monad m => m Int), it would work.  But that'd probably tell you it needs ImpredicativeTypes
08:39:39 <skinnr> hello all!
08:40:07 <skinnr> I'm doing a haskell tutorial, but there is something I don't understand:
08:40:14 <srhb> skinnr: Hi :)
08:40:17 <fizruk> corgifex: i have a structure which is essentially a list of named actions, say `Monad m => [(String, m Int)]`
08:40:26 <fizruk> corgifex: I want to get a list of names
08:41:04 <skinnr> I've got a function recursively defined like this:
08:41:29 <corgifex> map fst (xs :: [(String, Maybe Int)])
08:41:34 <skinnr> length' :: (Num b) => [a] -> b
08:41:45 <skinnr> length' [] = 0
08:41:49 <enthropy> @type genericLength
08:41:50 <lambdabot> Num i => [a] -> i
08:42:05 <skinnr> length' (_xs) = 1 + length' xs
08:42:16 <srhb> skinnr: Missing a : there?
08:42:18 <c_wraith> you forgot a :
08:42:21 <corgifex> and some spaces
08:42:31 <skinnr> I mean:
08:42:54 <skinnr> length' (_:xs) = 1 + length' xs
08:42:58 <fizruk> corgifex: yeah, if I instantiate m, everything's fine, but I don't want to (because actual constraint is more complex and can vary)
08:42:59 <srhb> skinnr:
08:43:04 <srhb> Right, what aobut it? :)
08:43:22 <corgifex> fizruk: sorry, I have no good solution
08:43:35 <fizruk> corgifex: thanks anyway)
08:43:37 <skinnr> I don't understand how it initially splits the list in a head and a tail if you provide the list in the tail
08:43:39 <corgifex> hmm
08:43:44 <srhb> skinnr: Pattern matching
08:44:14 <skinnr> so how does ghci know how to split it?
08:44:16 <srhb> skinnr: You're matching on a list of at least one element with _:xs, throwing the head away (_, meaning "ignore what's here) and then calling recursively on the rest of the list xs
08:44:28 <corgifex> skinnr: "lists" don't really exist. a "list" is either the special value [] or a pair of an element and another list
08:44:40 <srhb> skinnr: Because of how pattern matching works. The : constructor takes a left hand argument which is an element, and a list on the right hand side
08:44:49 <skinnr> like 1:2:3:[]
08:44:52 <srhb> Yes
08:45:03 <corgifex> that is, it doesn't have to split the list because the list isn't a uniform sequence in the first place
08:45:15 <corgifex> [1,2,3] really means 1 : (2 : (3 : []))
08:46:08 <skinnr> but if i say _:xs, if I have a list [1,2,3], i read it like _:1:(2:(3:[]))
08:46:09 <lwm> ls
08:46:25 <corgifex> eh?
08:46:27 <srhb> skinnr: No, it's not acting as a constructor in the pattern
08:46:31 <corgifex> you're not building a new list
08:46:32 <lwm> woops... accidentally typed ><
08:46:45 <srhb> skinnr: It's saying "if we have something that CONTAINS that constructor, match on the left hand side and the right hand side"
08:46:58 <srhb> skinnr: In other words, you get xs = 1:2:3:[]
08:47:02 <srhb> Er sorry
08:47:05 <srhb> skinnr: In other words, you get xs = 2:3:[]
08:47:15 <skinnr> ok I understand now
08:47:18 <skinnr> thanks
08:47:22 <srhb> skinnr: It's simply the binding of names to the structure of the argument
08:47:28 <srhb> Ish.
08:47:48 <skypers> oh goad
08:47:59 <skinnr> another question: how come I can do "1 + length' xs" ?
08:48:05 <skypers> I enabled executable-stripping and split-objs
08:48:08 <srhb> because length' xs is a number
08:48:11 <srhb> and 1 is a number
08:48:14 <skypers> compilation time increeeeeeaaaasiiiiiing :D
08:48:31 <corgifex> > case [1,2,3] of (x : xs) -> (x, xs)
08:48:33 <lambdabot>  (1,[2,3])
08:48:51 <corgifex> > case [1,2,3] of (_ : xs) -> xs
08:48:52 <lambdabot>  [2,3]
08:48:58 <skinnr> ah, because length' :: (Num b) => [a] -> b
08:49:01 <skypers> 17:45 < corgifex> > case [1,2,3] of (x : xs) -> (x, xs)
08:49:04 <skypers> this is pure evil.
08:49:06 <yorick> this is weird, if I use XHT with readDocument and runX, it works, but if I use runLA with xread, it gives a parse error (on the same readfile'd string)
08:49:11 <corgifex> skypers: ?
08:49:21 <srhb> skinnr: Yeah
08:49:25 <skypers> corgifex: extracting (:) that way is hurh
08:49:42 <corgifex> skypers: I don't get it
08:49:55 <skinnr> because the function is defined with the Num type constraint
08:50:13 <srhb> skinnr: Yes. Would have worked for a concrete type that supports + too, though
08:50:20 <srhb> skinnr: Like length' :: [a] -> Int
08:51:00 <skinnr> ah I get it now
08:51:19 <skinnr> the syntax is playing tricks with my habits
08:51:46 <srhb> skinnr: :) Takes some relearning.
08:52:00 <skinnr> I've had the same fun when learning Lisp and Scheme back in college
08:52:10 <skinnr> thank you so much!
08:52:14 <corgifex> wait until you come across 'return'
08:52:20 <srhb> No problem
08:52:36 <srhb> corgifex: You mean pure, yes? *shifty*
08:53:01 <skinnr> bye guys! ttyl! thanks again, srhb!
08:53:13 <srhb> o/
08:59:09 <SwashBuckla> hi there -- I think what I want is subRegex :: Regex -> String -> String -> String, but I can't seem to get it to do what I want to achieve. Clearly I have misunderstood how it works. How do you replace a match with a different string?
08:59:51 <SwashBuckla> I want to do `subRegex (mkRegex "a") "b" "abcd"` and get "bbcd"
09:00:02 <corgifex> > subRegex
09:00:03 <lambdabot>  Not in scope: ‘subRegex’
09:00:12 <SwashBuckla> import Text.Regex
09:00:47 <SwashBuckla> what I actually get from running that is "b"
09:00:56 <SwashBuckla> > import Text.Regex
09:00:57 <lambdabot>  <hint>:1:1: parse error on input ‘import’
09:01:06 <SwashBuckla> hmm
09:01:28 <corgifex> SwashBuckla: that sounds like "b" is the input string
09:01:34 <corgifex> and it doesn't contain the pattern "a"
09:02:11 <mr-> SwashBuckla: the documentation says the first string is the input string ;-)
09:02:25 <SwashBuckla> oh, yes :)
09:02:29 <SwashBuckla> thanks corgifex and mr-
09:04:37 <Fuuzetsu> > let ★: = 7 in (★:)
09:04:39 <lambdabot>  <hint>:1:5: parse error on input ‘★:’
09:04:46 <Fuuzetsu> > let .: = 7 in (.:)
09:04:47 <lambdabot>  <hint>:1:5: parse error on input ‘.:’
09:04:51 <Fuuzetsu> ohh
09:04:55 <Fuuzetsu> > let (★:) = 7 in (★:)
09:04:56 <lambdabot>  7
09:04:59 <Fuuzetsu> pfft
09:12:52 <bennofs> Does GHC provide a way to SPECIALIZE data structures?
09:13:22 <glosoli> How does one use cabal repl under emacs ?
09:13:30 <Fuuzetsu> I hope none of you use the ⋆ character in your identifiers
09:14:03 <Fuuzetsu> glosoli: (setq haskell-program-name "cabal repl") is what I do
09:14:15 <glosoli> Fuuzetsu: and it will use sandboxed cabal repl ?
09:14:25 <glosoli> sorry for not mentioning sandbox thing
09:14:37 <Fuuzetsu> yes
09:15:04 <glosoli> Fuuzetsu: so it will depend in which dir the file I open exists and it will run in sandbox ?
09:15:04 <Fuuzetsu> I assumed that's what you wanted, just make sure you're in the same directory as the cabal file when you C-c C-l (M-x cd)
09:15:06 <thoughtpolice> bennofs: no, SPECIALIZE only applies to class instances. if you want something like that, you can use data families to specialize particular types to more efficient representations, see a package like adaptive-containers
09:15:27 <Fuuzetsu> glosoli: open the file you want, then M-x cd to the directory with the cabal file, then C-c C-l
09:15:43 <glosoli> Fuuzetsu: Thanks sir
09:16:02 <Fuuzetsu> I recommend you try cabal repl in the command line first because emacs is not good with potential failures
09:16:05 <thoughtpolice> or, well, SPECIALIZE only applies to things more polymorphic than the type you specify to specialize *to*. but it won't specialize an actual data type, AFAIK.
09:16:18 <Fuuzetsu> like having to run cabal configure first (so you'd end up having to C-c C-l twice on the first run)
09:16:43 <glosoli> Fuuzetsu: aaa, cli it is then hmm any other suggestions for the easier getting with developing Haskell under emacs ?
09:16:46 <corgifex> what would it mean to SPECIALIZE a type?
09:16:55 <glosoli> ls
09:17:32 <Fuuzetsu> glosoli: no no, don't get me wrong, it works very well
09:18:01 <bennofs> Well, I thought maybe I could SPECIALIZE [] for Int for example, and then GHC could maybe automatically unbox the int (GHC 7.8 does unbox automatically, doesn't it?)
09:18:05 <Fuuzetsu> just on the first run you need to have your project configured otherwise cabal repl says it needs to configure first and emacs gets confused
09:18:12 <Fuuzetsu> but once it does that it works fine
09:18:21 <corgifex> bennofs: only strict fields
09:18:32 <bennofs> corgifex: oh right, then replace [] by a strict list :)
09:18:39 <glosoli> Fuuzetsu: I am quite new, cabal sandbox init initialized cabal sandbox, how do I init cabal file? since whatever cabal init does when passing through all the questions doesn't allow me to cabal repl
09:18:49 <corgifex> bennofs: but that would break all code
09:19:39 <bennofs> corgifex: oh, I meant not to replace the haskell [], only in my description of what I'd want ([] was just an unfortunate example, because it doesn't have strict fields)
09:20:07 <Fuuzetsu> glosoli: do you have a cabal file for your project already?
09:20:14 <glosoli> Fuuzetsu: sorry, no
09:20:27 <Fuuzetsu> ok, first you should create a cabal file for your project
09:20:40 <Fuuzetsu> ‘cabal init’ helps to do that but it doesn't do all the work
09:20:58 <glosoli> If I may ask, what else is needed ?
09:21:11 <Fuuzetsu> then once you have your project set up and ready (for example, ‘cabal configure’ works), you should be able to cabal sandbox init and then cabal repl
09:21:20 <Fuuzetsu> glosoli: you need to tell it what modules you're exporting for example
09:21:30 <glosoli> ls
09:21:38 <Fuuzetsu> http://www.haskell.org/cabal/users-guide/developing-packages.html
09:21:38 <glosoli> ok" gonna try
09:23:22 <glosoli> Fuuzetsu: http://pastie.org/private/a1dhzjal4lp5s2wplf7xq that's what I did the other time when I failed starting cabal repl. if you have spare minute to check it
09:23:56 <glosoli> Ah I guess your link to docs is already an answer
09:26:48 <skypers> Raw_o_split:
09:26:48 <skypers> does not exist
09:26:59 <skypers> who knows what Raw_o_split is?
09:27:12 <skypers> (Raw is the name of the module, I guess)
09:30:09 <Fuuzetsu> glosoli: you're not telling cabal about any of your modules and things like that, I'm unsure what you'd expect cabal repl to give you
09:30:38 <Fuuzetsu> try running cabal repl again
09:30:53 <Fuuzetsu> “Re-configuring with most recently used options. If this fails, please run configure manually.” is what I was talking about.
09:30:55 <glosoli> Fuuzetsu: I might have some dumb concept in my mind of what repl is
09:30:59 <glosoli> Been using Clojure before
09:31:26 <Fuuzetsu> cabal repl is GHCi constrained to what's available in the sandbox (such as your own package).
09:31:59 <glosoli> I guess I should read the docs you pointed me to
09:32:01 <Fuuzetsu> it allows you to use GHCi with your package without having to install it globally
09:32:02 <skypers> [122 of 364], with profiling, splitting
09:32:07 <skypers> it’s gonna take a while :D
09:35:05 <yorick> is there something that does (a -> m b) -> a -> m (a, b) ?
09:35:59 <c_wraith> not directly.  You can be clever and get it, though
09:36:16 <c_wraith> Or not cleaver, and get a readable thing instead
09:36:19 <c_wraith> *clever
09:36:23 <yorick> I'm not clever! the only thing I can think of involves pattern matching
09:36:30 <c_wraith> No need for that
09:36:56 <c_wraith> :t \f x -> ((,) x) <$> f x
09:36:57 <lambdabot> Functor f => (a1 -> f a) -> a1 -> f (a1, a)
09:37:17 <yorick> okay, that's pretty clever
09:37:42 <c_wraith> nah, I was thinking of using ap in the (a ->) monad kinds of clever.
09:37:47 <c_wraith> that's just a simple fmap
09:38:18 <shapr> What's the fastest MD5 hashing lib for Haskell?
09:38:56 <shapr> nano-md5?
09:42:37 <nulldata> Hello!
09:43:06 <srhb> nulldata: o/
09:44:09 <Okasu> shapr: If you need speed check out https://blake2.net/. There is no haskell implementation or binding that I'm aware of but it's quite easy do build it on your own.
09:44:25 <shapr> Hm, I'd rather have an existing Haskell lib
09:45:20 <thoughtpolice> mmmm, i have BLAKE2 in my library but it's not on Hackage. :(
09:45:28 <thoughtpolice> you can copy it though if you'd like, shapr
09:45:42 <shapr> thoughtpolice: yes please! is it on github?
09:47:05 * thoughtpolice grabs it...
09:47:28 <shapr> thoughtpolice: is it https://github.com/thoughtpolice/hs-blake ?
09:47:55 <nulldata> I'm writing a generic function that takes two types( with two very long and required sets of typeclass memberships ) and I wanted to know if it was possible to do some kind of set-like intersection between the type-classes? Else I'll have to either leave out my  type signature or include the very long set of type class constraints.
09:48:11 <thoughtpolice> shapr: that's old and unmaintained now, i won't release that, but it works, yes
09:48:22 <thoughtpolice> shapr: here's the version in my 'better' library - https://github.com/thoughtpolice/hs-nacl/blob/master/src/Crypto/Hash/BLAKE2.hs
09:48:28 <shapr> yay! thanks!
09:48:34 <thoughtpolice> (they might still be the same code, mostly)
09:48:40 <thoughtpolice> shapr: you also need the C files in here https://github.com/thoughtpolice/hs-nacl/tree/master/src/cbits/blake2
09:48:43 <thoughtpolice> that's all
09:48:59 <shapr> so, grab the entire hs-nacl repo then
09:49:23 <thoughtpolice> yeah, and you can just copy the files out
09:49:32 <thoughtpolice> the BLAKE2 module has no intra-package dependencies on any other modules
09:49:35 <thoughtpolice> it just needs bytestring
09:50:03 <thoughtpolice> anyway i should actually release that library soon :P
09:51:04 <shapr> thoughtpolice: yes please!
10:02:54 <deweyvm> any tips refactoring this? http://lpaste.net/102568
10:05:37 <bergmark> deweyvm: well, you can factor out the duplication
10:06:56 <deweyvm> ahh i think i got it
10:07:07 <deweyvm> where rand f = (randoms . mkStdGen) $ f seed
10:07:54 <bergmark> or rand f = randoms . mkStdGen . f
10:08:28 <deweyvm> even nicer
10:09:35 <nulldata> I love refactoring in Haskell, it's like its own little brain-teaser.
10:10:16 <nulldata> Except when I find myself spending 2 hours on trying to get a function perfect.
10:11:44 <deweyvm> same
10:12:36 <bergmark> after a while you can distinguish between "i'm doing a useful refactor" and "i'm just having fun" ;)
10:13:06 <bergmark> @pl \f -> randoms . mkStdGen . f
10:13:06 <lambdabot> ((randoms . mkStdGen) .)
10:13:13 <nulldata> Well you have to. ( Unless you have to much free-time )
10:13:58 <bergmark> general rule of thumb for me is that partially applying (.) is too much
10:14:23 <john_not_jenny> Is there a library/package for dealing with time in a basic way?  I just need to be able to read/show/compare things like 2:27 AM and 4:48 PM.  Data.Time.Clock only seems to deal with UTC
10:15:11 <geekosaur> time is never as basic as people would like it to be :(
10:15:43 <dmj`> since 7.8.1 has a bug w/ type families does this mean it cannot be used to bootstrap 7.8.2?
10:15:50 <geekosaur> every time I've assumed I could get by with something that simple, I'vew been forced to tear it out and rewrite later. (consider DST / summer time changes, for one)
10:15:57 <john_not_jenny> I see.
10:16:02 <john_not_jenny> That's true.
10:16:14 <geekosaur> dmj`, if ghc itself used the buggy part then it would have been caught in the stage2 build
10:16:24 <c_wraith> dmj`: does GHC use type families?  I thought it used pretty conservative extensions to make bootstrapping easier
10:16:25 <geekosaur> and would never have made the release
10:16:40 <johnw> is there any reason why the haskell-platform package isn't on Hackage?
10:16:47 <johnw> it would make it much easier to fix constraint on the HP
10:17:05 <geekosaur> because depending on it directly is almost always wrong?
10:17:16 <c_wraith> You should depend on things you actually need.
10:17:24 <geekosaur> it would be a claim that your program used *eveyr* package in the platform
10:17:46 <geekosaur> (now imagine using ghc-mod to develop your package...)
10:17:48 <johnw> I wouldn't depend on it in a cabal file
10:17:59 <johnw> but I could put 'constraint == haskell-platform-2013.2.0.0' in my ~/.cabal/config
10:18:04 <geekosaur> no, but if it were on hackage then people would do so
10:18:06 <johnw> rather than listing out every constraint the way that monochrom recommends
10:20:49 <dmj`> geekosaur: I think it failed in stage2
10:20:50 <dmj`> http://lpaste.net/102571
10:21:19 <int-e> @let ä = 1
10:21:24 <dmj`> ghc-cabal: At least the following dependencies are missing: ghc == 7.9.*
10:21:26 <lambdabot>  .L.hs:48:1: Warning:
10:21:26 <geekosaur> dmj`, that's a different problem
10:21:32 <lambdabot>      Module ‘Control.Monad.Instances’ is deprecated:
10:21:33 <int-e> @undef
10:21:38 <lambdabot> Undefined.
10:21:40 <int-e> @let ä = 1
10:21:48 <lambdabot>  Defined.
10:21:52 <int-e> > ä
10:22:01 <geekosaur> are you actually building 7.8? that looks like you're trying to build HEAD
10:22:02 <lambdabot>  1
10:22:06 <dmj`> why would I need ghc-7.9? I'm building 7.8.2 via 7.8.1
10:22:26 <dmj`> I git cloned ghc from github then checked out the 7.8.2 release tag
10:22:46 <dmj`> ./sync-all, perl boot, ./configure make -j9 make install, etc
10:22:48 <geekosaur> I think you need to ask what's up in #ghc in that case
10:23:06 * geekosaur doesn't follow ghc devel quite *that* closely
10:23:31 <geekosaur> but it sounds like you are getting some HEAD stuff mixed in with the release
10:23:55 <Peaker> GHC miserably fails the Joel test: Have a 1-step build
10:24:24 <Peaker> I wish ghc used git submodules instead of the convoluted "sync-all" thing :(
10:24:52 <dmj`> geekosaur: when I check out the 7.8.2 tag it explicitly says HEAD is now set to 7.8.2
10:25:10 <c_wraith> dmj`: but what about for all the libraries?
10:25:29 <c_wraith> dmj`: you need to check out that tag for all libraries, instead of leaving them at HEAD
10:25:44 <c_wraith> and I've never managed to do that successfully
10:27:48 <geekosaur> dmj`: yes, the use of "HEAD" is confusing
10:28:05 <geekosaur> by convention, the tip of development is referred to as HEAD
10:28:16 <geekosaur> btu git there is saying that the tip of your branch is HEAD
10:28:27 <geekosaur> as opposed to the tip of the entire development tree
10:29:05 <geekosaur> (git should perhaps not be saying that, because if you use HEAD in a git search it refers to the tip of the entire tree; to get a specific branch, you use the branch tag in place of HEAD)
10:29:21 <geekosaur> (this is one of the places where git's user interface utterly sucks)
10:30:14 <kadoban> What would "tip of the entire development tree" even mean in git's model?
10:31:15 <dmj`> geekosuar: HEAD is now at 010941a... Set VERSION=7.8.2, RELEASE=YES is what shows
10:31:41 <dmj`> http://lpaste.net/102572
10:32:10 <thoughtpolice> dmj`: you didn't check the libraries out to the right revision
10:32:13 <geekosaur> right, that's git being confusing about how it uses HEAD
10:32:17 <thoughtpolice> just clone 7.8 into a new directory like i said in #ghc
10:32:31 <thoughtpolice> alternatively, just wait for the binary distributions. or use the source tarball if you're impatient
10:32:40 <geekosaur> because it means in some contexts the head of a branch and in other cases the unnamed default branch (which in still other places may be called "master")
10:32:47 <int-e> shouldn't ./sync-all checkout ghc-7.8 also do the job ...
10:32:57 <thoughtpolice> int-e: it's currently busted with submodules slightly
10:33:16 <Peaker> in git, HEAD is the checked out branch (which can be a temporary "(nobranch)" if you're in a "Detatched head" state, due to checkout of a non-branch).   That branch is a ptr to a specific commit.  So HEAD is a double-ptr to a commit
10:33:36 <thoughtpolice> int-e: which is a bug, but we'll be moving mostly everything to submodules anyway
10:33:48 <thoughtpolice> so it'll mostly become redundant
10:35:29 <dmj`> thoughtpolice: I'm currently building using your instructions, when are the binary distributions coming?
10:35:48 <thoughtpolice> later today, probably soon but the i386 builds take the longest
10:36:46 <dmj`> oh, awesome, well I can wait I guess. Will you link to them on reddit or set the topic on #ghc?
10:37:05 <thoughtpolice> the announcement will go to the mailing list and everything, of course
10:38:10 <quchen> If I have a TVar, is there some lens I can use to extract its contents and lens around on it? Something along the lines of   newTVar "hello" ^. to readTVar . monadicLensy . mapped toUpper . act putStrLn
10:38:29 <edwardk> quchen: sadly such a thing can't be made a proper lens
10:38:39 <edwardk> consider what happens when you have a chain of tvars that leads back to itself
10:38:48 <edwardk> e.g. a cyclic graph
10:38:54 <dmj`> thoughtpolice: awesome, awesome, thanks a ton!
10:39:08 <quchen> Hmm, I see. So there is no way I can access a TVar with lens? Not even improper evil ones?
10:39:21 <edwardk> quchen: so 'monadic lenses' are directly out of scope of lens. we do have some 'actions' that let you write monadc 'getters' and 'folds' though
10:39:22 <quchen> It's not really an issue, I was just wondering whether I can refactor my code this way.
10:39:36 <quchen> The *.Actions module, edwardk?
10:39:40 <edwardk> yeah
10:39:51 <edwardk> #haskell-lens can help further. I need to run
10:40:03 <quchen> Thanks anyway :-)
10:43:31 <mizu_no_oto> Is it possible to suffer from a buffer overflow exploit when using Safe Haskell if you don't use the FFI to call buggy C code?  There's a bet I want to settle with someone.
10:44:28 <benmachine> mizu_no_oto: so, there might be a bug in GHC which enables the answer to be yes
10:44:47 <benmachine> (but we don't know of any)
10:44:51 <benmachine> mizu_no_oto: moreover, you can lie to Safe Haskell and claim a module is trustworthy when it isn't
10:45:32 <glguy> The Trustworthy route would require someone to explicitly mark the package with that module as trusted, though
10:45:45 <benmachine> sure, but you can do that
10:46:09 <benmachine> I suspect that
10:46:29 <glguy> mizu_no_oto: Safe haskell doesn't stop you from reading off the end of pointers yourself
10:46:45 <stolaruk> When I try to "cabal install hlint", I get the following: "ld: library not found for -lHScpphs-1.18.4-ghc7.8.1" What can I do about this?
10:47:16 <Peaker> stolaruk: OS X?
10:47:23 <stolaruk> Peaker: Indeed
10:47:26 <benmachine> glguy: doesn't it? is Storable Trustworthy?
10:47:38 <glguy> http://hackage.haskell.org/package/base-4.7.0.0/docs/Foreign-Ptr.html
10:48:05 <glguy> Safe Haskell isn't intended to stop you from doing arbitrary IO, just from sneaking in arbitrary IO
10:48:11 <Peaker> stolaruk: Maybe you can try to unregister/remove-all-traces-of the cpphs package, reinstall it and then try to install hlint.  If that doesn't work, it sounds like "ld" is missing the library path referring to where cabal puts its libraries
10:48:28 <Guest77325> http://www.goaltycoon.com/bestfootballgame/galahad1st use this link to register on GoalTycoon, a free2play football manager online game, manage your team, improve your players and tactics to advance the leagues, upgrade your club park, all in order to earn profits and the virtual currency can be converted into real money. Join now! It's free:>
10:48:38 <stolaruk> Peaker: I'll try, thanks
10:49:02 * geekosaur wonders how long before that one gets klined
10:51:24 <Peaker> what Haskell exercises can anyone recommend, available online, I can give a student I'm teaching Haskell?
10:52:15 <benmachine> Peaker: I did these long ago https://www.fpcomplete.com/user/DanBurton/20-intermediate-exercises
10:52:27 <benmachine> I remember being fond of them
10:53:28 <Peaker> nice, thanks -- anything more practical-ish?  Involving IO, maybe concurrency, etc?
10:53:40 <kadoban> Peaker: http://exercism.io/ is kinda nice, but they're more for crowd-sourcing the feedback instead of giving it yourself (and they're quite easy)
10:56:20 <kadoban> Peaker: You can always just pick from some random programming competition problems too I suppose https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8 for example
10:56:22 * hackagebot creatur 5.2.11 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.11 (AmyDeBuitleir)
10:57:17 <Peaker> Debug.Trace has weird names for things in it. I don't get the usefulness of the ones that return the traced String, either
10:57:25 <Peaker> Also lacking so many useful things :(
10:58:16 <bergmark> it's a lot better since base 4.7
11:00:00 <Peaker> the traceM/traceShowM, for example, would be nicer as tracePutStrLn and tracePrint   (as it is analogous to those). And it really needs a tracer that shows the value flowing through it. It's what everybody needs
11:02:51 <sm> Peaker: what do you mean by that ?
11:04:10 <Peaker> sm: which part?
11:04:47 <Peaker> traceShow should have been:  traceShow label x = trace (label ++ ": " ++ show x) x
11:05:13 <sm> a tracer that shows the value flowing through it.. oh a labelled traceShow ?
11:05:25 <int-e> Peaker: I tend to use  traceShow ("label",x)
11:06:13 <sm> I use these: https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Utils.hs#L374
11:06:42 <sm> some similar stuff in http://hackage.haskell.org/package/DebugTraceHelpers
11:08:33 <Peaker> int-e: traceShow ("label", x) x ?
11:08:40 <Peaker> int-e: where x is a long expression?
11:09:16 <Peaker> sm: the important thing IMO is DRYing the repeated "x" there
11:09:21 <int-e> Peaker: eh. no. I missed the duplicated x (and I hardly ever want that anyway.)
11:09:24 <Peaker> (i.e: I usually want to show the same value I want to return)
11:09:48 <Peaker> e.g: in a pipe-line:   traceShow "result" . foo . traceShow "intermediate" . bar . traceShow "input"
11:09:57 <int-e> Peaker: in fact my most common use looks like this:   foo x y z | traceShow ("foo",x,y,z) False = undefined  [and then the real definition of `foo']
11:10:41 <bergmark> `traceWith :: Show b => (a -> b) -> a -> a' would be nice
11:11:24 * hackagebot yi 0.8.1 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.8.1 (DmitryIvanov)
11:11:26 * hackagebot yi-contrib 0.8.1 - Add-ons to Yi, the Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-contrib-0.8.1 (DmitryIvanov)
11:11:41 <bergmark> traceWith ("msg",) x
11:11:46 <Peaker> sm: strace/ltrace should have existed in Debug.Trace
11:13:11 <Peaker> Unqualified open imports strike again!   cabal install gtk   fails due to ambiguous imported names :(
11:13:23 <Peaker> oops, cabal install threadscope does
11:14:59 <Peaker> threadscope is mirrored in github.. will pull requests work? probably not :(
11:15:01 <c_wraith> Peaker: and fixing that when it happens is still way less churn than changing imports every time you use different code.
11:15:11 <c_wraith> Peaker: it's already been reported
11:15:23 <c_wraith> I discovered that when I ran into it months ago
11:15:39 <c_wraith> the problem is no one is releasing a new version of threadscope
11:15:43 <Peaker> c_wraith: fixing that is hard -- it's third party code. So it's way more churn.. It breaks all dependent packages indefinitely
11:15:59 <ReinH> Peaker: Debug.Trace has a weird interface that includes stuff I never need and doesn't include stuff I always want
11:15:59 <Peaker> c_wraith: and there you go -- I doubt maintaining the imports would have costed months of extra development
11:16:11 <Peaker> c_wraith: also, qualified imports are nice.. they make names short & sweet
11:16:18 <Peaker> ReinH: exactly
11:16:24 * hackagebot alsa-pcm 0.6.0.2 - Binding to the ALSA Library API (PCM audio).  http://hackage.haskell.org/package/alsa-pcm-0.6.0.2 (HenningThielemann)
11:16:26 * hackagebot alsa-seq 0.6.0.4 - Binding to the ALSA Library API (MIDI sequencer).  http://hackage.haskell.org/package/alsa-seq-0.6.0.4 (HenningThielemann)
11:16:56 <c_wraith> Peaker: and infix operators unusable
11:17:06 <ReinH> I absolutely want traceShow :: Show a => String -> a -> a; traceShow label thing
11:17:09 <ReinH> but nope
11:17:10 <Peaker> c_wraith: import just the operators by name
11:17:35 <bergmark> has anyone suggested this to libraries?
11:17:55 <ReinH> so I can say `traceShow "mapped foos: " . map f $ foos' or whatever
11:17:59 <Peaker> I import Applicative(..)   to get <* and *>    and Control.Lens.Operators open-unqualified (because I don't define my own operators, and never import packages that aren't lens dependencies anyways, so there can be no clashes)
11:18:16 <Peaker> ReinH: yeah, I have it in my TraceUtils package
11:18:21 <ReinH> Peaker: nice :)
11:18:35 <bergmark> never import packages that aren't lens dependencies? is this haskell-lens-platform or something? :-))
11:18:44 <ReinH> Debug.Trace.ThingsThatShouldHaveBeenHereAlready
11:18:52 <Peaker> bergmark: lens depends on everything :-)
11:18:57 <ReinH> and vice versa!
11:19:11 <ReinH> Welcome to Haskell2016
11:19:28 <bergmark> i think our code base actually doesn't pull in lens
11:19:44 <Peaker> In my current project I avoid lens because I'm trying to be beginner-friendly
11:19:52 <Peaker> and teaching them Haskell is a big enough obstacle
11:19:58 <Peaker> lens will come with time :)
11:19:58 <ReinH> heh true enough
11:20:04 <ReinH> Peaker: which project?
11:20:08 <Peaker> ReinH: buildsome
11:20:14 <Peaker> https://github.com/ElastiLotem/buildsome/
11:20:15 <bergmark> but it pulls in fclabels and data-lens ;o
11:20:54 <Peaker> fclabels has no polymorphic updates, right? :(
11:21:29 <bergmark> Peaker: http://hackage.haskell.org/package/fclabels-2.0.1/docs/Data-Label-Poly.html
11:21:32 <Peaker> if a new threadscope exists, what prevents someone from uploading it?
11:21:45 <ReinH> Peaker: buildsome looks cool
11:21:52 <ReinH> Peaker: and it's designed in some part as a learning vehicle?
11:22:14 <Peaker> bergmark: I see fclabels is evolving in the direction of lens
11:22:31 <Peaker> ReinH: nope, but others in my company need to be able to understand it and work on it
11:22:39 <ReinH> Peaker: cool :)
11:22:41 <Peaker> and currently nobody else really knows Haskell :) I'm piloting teaching one person
11:22:46 <Peaker> and if that works out, I'll teach others too
11:22:59 <Peaker> she really likes Haskell so far :)
11:23:05 <ReinH> Peaker: still, it might be an interesting tool for pedagogy. I really liked Chris Forno's haskell videos and they used a similar domain.
11:23:08 <Peaker> but we've only done very basic stuff yet
11:23:16 <ReinH> (So much that I decided to do a podcast with him ;)
11:23:40 <ReinH> Peaker: build systems definitely involve real world concerns like IO and (hopefully) concurrency ;)
11:24:17 <Peaker> threadscope is shiny!
11:24:25 <ReinH> Peaker: so shiny
11:24:36 <ReinH> does it work on OS X without finding the precompiled binary yet?
11:24:42 <Peaker> ReinH: yeah, got a lot of concurrency in buildsome.. using some async and a lot of atomicModifyIORef
11:24:46 <Peaker> I *love* atomicModifyIORef :)
11:24:49 <ReinH> Peaker: nice :D
11:25:34 <Peaker> it depends on 2 of Haskell's defining characteristics to achieve its nice power:  1) purity (to allow spinning around the atomic cmpxchg with known semantics) 2) laziness (to allow postponing heavy work outside of the spinning)
11:26:16 <Peaker> IME: atomicModifyIORef covers my needs for determinism so well that I don't ever reach out to STM
11:27:20 <monochrom> I like atomicModifyIORef and pure functional data structures too
11:27:48 <Clint> is mighttpd2 the only haskell web server than can do cgi?
11:28:58 <monochrom> such simple idea and almost as fast as the trickiest lockless mutable data structures
11:29:43 <c_wraith> sometimes locks are good.
11:30:01 <c_wraith> But that's rare.
11:31:40 <Kaidelong> https://ghc.haskell.org/trac/ghc/wiki/TypeNats/Basics is this a current feature?
11:33:51 <c_wraith> Kaidelong: it's existed experimentally since 7.6
11:34:09 <c_wraith> it's still not finished, and the GHC.TypeLits module changed significantly between 7.6 and 7.8
11:35:14 <c_wraith> Kaidelong: the stuff in that page (withSing, fromSing... everything about singletons) got removed from GHC.TypeLits in 7.8, and replaced with something much simpler
11:36:38 <ReinH> Peaker: nice :)
11:37:43 <Kaidelong> well, that's still great news
11:37:53 <ReinH> Peaker: another advantage of purity is that you spend less time in contention since purity prevents you from colliding with some other thread once you acquire the resource
11:38:25 <Kaidelong> although I guess since I use 7.6 right now
11:38:29 <mmachenry> I have a pretty vague question. I just hlint and it's really nice. I also just installed hoogle locally and made ghci interpret :doc and :search using a tutorial I found. I love it. Are there any other development tools and tricks Haskellers recommend to make you more productive?
11:38:35 <Kaidelong> anything I write using this feature will break with GHC 7.8
11:38:43 <Kaidelong> so it's really like the feature isn't there at all
11:39:00 <ReinH> mmachenry: get your editor to run hlint and syntax check if you can
11:39:16 <ReinH> syntax and type check, that is
11:40:09 <evincar> Does Cabal have a sane way of specifying a library with two modules X and Y, and a test-suite that depends on both, but only expose X?
11:40:37 <evincar> I vaguely recall something about how hierarchical modules work but am blanking on the specifics.
11:41:26 <monochrom> hierarchical module does not help
11:41:52 <mmachenry> ReiH	That's a good idea.
11:42:27 <benmachine> evincar: if you don't mind compiling things twice, you can do it
11:43:05 <benmachine> evincar: you can set it up so essentially your testsuite doesn't depend on your library, it just uses the same source files
11:43:49 <ReinH> Peaker: I love this trick from Parallel & Concurrent Haskell: let book' = Map.insert name number book; putMVarm book'; seq book' (return ())
11:44:13 <ReinH> evaluating the thunk after releasing the lock b/c referential transparency
11:46:28 * hackagebot creatur 5.3.0 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.3.0 (AmyDeBuitleir)
11:46:58 <identity> mmachenry: Which editor do you use?
11:47:48 <ReinH> Peaker: Reduce Lock Contention With This One Weird Trick
11:51:34 <mmachenry> identity:  I use vim
11:51:55 <ReinH> mmachenry: check out Syntastic and either ghc-mod or hdevtools
11:51:58 <identity> mmachenry: Then there's ghcmod-vim
11:52:02 <mmachenry> identity: I'm sure there's a tone of stuff available for integration. I should just search a vim/haskell tutorial
11:52:02 <identity> eah
11:52:26 <mmachenry> ReinH and identity Awesome, thanks.
11:52:38 <ReinH> I have to say I'm not super happy with the hdevtools vim plugin
11:52:43 <ReinH> but I absolutely hate writing VimL so...
11:52:53 <ReinH> it's not bad but it's missing a few simple features
11:53:09 <ReinH> but hdevtools is generally superior to ghc-mod imo
11:53:27 <identity> I seem to have them both installed and they are both enabled as checkers for syntastic
11:53:32 <mmachenry> Oh hdevtools looks really cool.
11:53:37 <identity> I'm not sure why that is / if that's smart
11:53:44 <ReinH> identity: heh :)
11:53:48 <ReinH> Let them fight it out
11:54:08 <identity> But I know one of them seems to dislike MultiWayIf
11:54:13 <identity> (e.g. parsing error)
11:54:35 <ReinH> well, I dislike MultiWayIf too...
11:54:54 <ReinH> MultiWayIf is your language's way of telling you that you need another name :p
11:54:54 <identity> I dislike having to use it, but sometimes there's almost no other way
11:55:50 <ReinH> if'WithAName | cond1 = a; | cond2 = b; | otherwise = c :p
11:56:23 <identity> which is almost identical to using MultiWayIf really.
11:58:10 <ReinH> except it doesn't require a langauge extension :p
12:02:28 <average> hi, how does someone usually go about reporting bugs in a hackage module ? for example on CPAN, there's the associated http://rt.cpan.org where every module has a bug queue
12:02:33 <average> is there such a thing for Haskell ?
12:02:45 <average> I've looked for one and I wasn't able to find a central place like that
12:02:58 <Peaker> ReinH: that trick is implemented inside atomicModifyIORef'
12:03:07 <ReinH> Peaker: oh right
12:03:12 <ReinH> Peaker: even more awesome :)
12:03:17 <shachaf> No central place. There's usually a maintainer email or a link to a project page with a bug database.
12:03:24 <ReinH> average: many hackage modules provide... right tht
12:03:54 <average> ah ok, and how about patchsets ?
12:04:07 <S11001001> xb
12:04:07 <average> same ? e-mail ?
12:04:22 <average> s/patchsets/patches/
12:04:27 <average> sorry, got stuck on gerrit terminology
12:04:55 <ReinH> average: some provide a git/github/vcs repo link. Others... do not.
12:05:04 <ReinH> In which case try contacting the maintainer
12:05:17 <average> ah, ok, thanks !
12:05:47 <ReinH> average: it'll be in the cabal file, which is shown on the contents page in hackage
12:16:31 * hackagebot action-permutations 0.0.0.1 - Execute a set of actions (e.g. parsers) in each possible order  http://hackage.haskell.org/package/action-permutations-0.0.0.1 (RossPaterson)
12:19:32 <bennofs> Does parsec support using text?
12:19:57 <geekosaur> Text.Parsec.Text module?
12:20:08 <bennofs> hmm ok, thanks
12:20:33 <davd> from parsec 3.1.2 according to http://stackoverflow.com/questions/4064532/using-parsec-with-data-text
12:21:14 <gamegoblin> If, in one module, I make type T an instance of MonadPlus, what do I need to export to use its mzero in another module?
12:21:19 <evincar> benmachine: Thanks, I think I can get around it in this case by just modifying the test suite.
12:21:30 <sai_> Hi :) I am new to haskell and I am looking for some open source projects which use haskell to contribute.
12:21:33 <evincar> benmachine: But that's a good idea for future reference.
12:22:17 <benmachine> gamegoblin: pretty much nothing
12:23:01 <benmachine> gamegoblin: instances are automatically and pervasively exported
12:23:10 <gamegoblin> benmachine: d’oh, I’d forgotten to import Control.Monad, that was the problem ;)
12:23:12 <davd> also see http://stackoverflow.com/questions/8728596/explicitly-import-instances
12:23:39 <davd> (open world assumption)
12:24:00 <orbital_> hi
12:26:18 <orbital_> question about functor ((->) r): why does it seem counterintuitive that f fmapped to g is (f . g) and not (g . f)
12:26:21 <orbital_> ?
12:26:52 <davd> sai_: Hey, that's great! One way of approaching this is to browse hackage and look for github repos with issue trackers. pull requests are nicely received in most cases.
12:28:24 <S11001001> orbital_: f . g is g fmapped with f
12:28:32 <davd> sai_: and there are also a few projects in the spotlight such as Elm, or various web servers.
12:28:40 <S11001001> orbital_: i.e. f <$> g
12:31:20 <sai_> Cool! I'll go check 'em out.
12:34:36 <srhb> Don't you just love it when in the process of solving a relatively benign bug start questioning why your program ever worked...
12:35:54 <deweyvm> or: somethings broke -> change it -> change it back -> not broken anymore
12:36:15 <deweyvm> never had that happen with haskell though :P
12:36:16 <nexx> oh I hate the last one
12:37:04 <quchen> orbital_: The easy but not-really-helping answer is "because the types don't match the other way round". Another way of looking at it is via the 2nd Functor law, `fmap f . fmap g ≡ fmap (f . g)`: if fmapping would apply things in reverse, the left hand side of this equation would do the reverse of the right hand side.
12:37:16 <nexx> IBM Dominio is very good to achieve it
12:38:01 <nexx> *Domino
12:39:22 <quchen> orbital_: To make this more explicit, left hand side with "reversed fmap":  (fmap' f . fmap' g) h = fmap' f (fmap' g h) = fmap f (h . g) = h . g . f.  On the other hand, the right hand side would result in fmap (f . g) h = h . f . g, which is not the same.
12:40:09 <quchen> Eh, all the "fmap" should be "fmap'" there.
12:40:40 <nexx> and all the "f" should be "f" there?
12:41:05 <nexx> oh fmap'
12:41:11 <quchen> fmap-prime, yes.
12:41:27 <quchen> To hint that fmap' is not fmap and not Functor-y.
12:41:34 * hackagebot adblock2privoxy 1.2.2 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.2.2 (zubr)
12:42:41 <quchen> orbital_: Note that there is the Contravariant class, which defines a functor with reversed order, so that cofmap f g = g . f. But that's something different from Functor (and non-standard, and much less used).
12:42:52 <quchen> @hackage contravariant
12:42:52 <lambdabot> http://hackage.haskell.org/package/contravariant
12:44:24 <bernalex> what's the shortest way of mapping putStrLn on a "foo bar" where foo bar returns IO [String]?
12:45:00 <deweyvm> @type sequence
12:45:01 <lambdabot> Monad m => [m a] -> m [a]
12:45:08 <deweyvm> oh thats not right heh
12:45:24 <fizruk> bernalex: mapM_ putStrLn $ foo bar
12:45:37 <quchen> :t \ioString -> ioString >>= mapM_ putStrLn
12:45:38 <lambdabot> IO [String] -> IO ()
12:45:39 <bernalex> fizruk: oh right of course, that's shorter than using forM_ the way I did
12:46:35 * hackagebot aeson 0.7.0.3 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.7.0.3 (BryanOSullivan)
12:46:46 <ReinH> fizruk: mapM_ putStrLn =<< foo bar
12:47:13 <fizruk> ReinH: right, silly me :(
12:47:17 <bernalex> ReinH: or the other way around
12:47:22 <ReinH> bernalex: yes
12:48:00 <ReinH> bernalex: that was just the shortest edit distance to fix fizruk's ;)
12:51:23 <fizruk> btw, is there a $-looking variant of =<< ?
12:51:42 <quchen> ...ish.
12:52:02 <quchen> Depends on what "$-looking" means.
12:52:07 <srhb> Low precedence I guess
12:52:11 <srhb> I know of none
12:52:16 <fizruk> like in $, <$>, <<$>>
12:52:25 <srhb> I haven't found a need for it either though, usually I end up with $ do ... if it's that long
12:52:56 <fizruk> :t ($)
12:52:57 <lambdabot> (a -> b) -> a -> b
12:52:58 <quchen> I'd like to have a Functor version of >>= often, to chain Functor and monadic effects left-to-right.  foo >>= return . bar >>= baz  -- meh
12:52:59 <srhb> <$> is not low precedence though, so I guess not
12:53:00 <fizruk> :t (<$>)
12:53:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:53:07 <fizruk> :t (=<<)
12:53:08 <lambdabot> Monad m => (a -> m b) -> m a -> m b
12:53:12 <srhb> well, how about <$> :-)
12:53:27 <quchen> srhb: Doesn't chain well with >>=
12:53:31 <ReinH> throw a join in there and bob's your uncle
12:53:31 <srhb> True enough
12:55:08 <fizruk> :t (<&>)
12:55:08 <lambdabot> Functor f => f a -> (a -> b) -> f b
12:55:36 <fizruk> :t \x y z -> x <&> y >>= z
12:55:37 <lambdabot> (Functor m, Monad m) => m a1 -> (a1 -> a) -> (a -> m b) -> m b
12:55:45 <fizruk> quchen: like that? ^
12:56:30 <quchen> What's the fixity of <&>?
12:58:03 <fizruk> infixl 1
12:58:19 <fizruk> according to lens sources on hackage
12:59:33 <quchen> Hmm, I might wanna start using that then. Not sure how it impacts readability, but it's surely worth a try.
12:59:41 <quchen> "return ." always feels a little dirty.
13:00:06 <ReinH> quchen: return (.) :p
13:00:31 <quchen> ReinH: ..?
13:00:45 <quchen> That doesn't look like anything remotely useful :-þ
13:00:51 <ReinH> quchen: it might be useful somewhere
13:00:52 <fizruk> quchen: i'm not sure it is defined outside of lens, but I guess you can always define it
13:01:03 <ReinH> quchen: but probably not
13:01:37 * hackagebot adblock2privoxy 1.2.3 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.2.3 (zubr)
13:02:27 <quchen> ReinH: 50 years ago nobody knew what to use lasers for, so who knows.
13:03:40 <ReinH> quchen: I don't know but it probably involves CoYoneda.
13:05:13 <quchen> @choose Yes. No.
13:05:13 <lambdabot> No.
13:05:41 <quchen> Lambdabot is probably more competent at understanding this than I am, so I'm going to go with it.
13:05:56 <ReinH> ha
13:06:48 <ReinH> quchen: a monoid in the category of endofunctors on Arr(Hask) something something something
13:06:59 <ReinH> Yeah probably useless :)
13:07:36 <fizruk> :t return (.)
13:07:37 <lambdabot> Monad m => m ((b -> c) -> (a -> b) -> a -> c)
13:08:10 <ReinH> Arr(Arr(Hask))?
13:08:13 <ReinH> anyway
13:10:55 <benmachine> quchen: x >>= return . y >>= z is x >>= z . y
13:11:11 <benmachine> quchen: you could write that as x >>= y >>> z
13:11:58 <benmachine> oh, no you can't because fixity
13:11:59 <benmachine> sigh
13:12:00 <benmachine> oh well
13:12:13 <benmachine> x >>= (y >>> z)
13:12:26 <quchen> Might as well fmap then.
13:12:42 <quchen> x >>= z . y  -- left-to-right-to-left order, eww
13:19:40 <benmachine> quchen: well that is what the >>> is for
13:19:41 <benmachine> moreover
13:19:46 <benmachine> that is what =<< is for
13:21:11 <heath> bernalex: an example of me trying to list the contents of the directory
13:21:23 <bernalex> heath: what?
13:21:28 <heath> of course, I know you had an example, I was just trying to figure it out myself
13:21:31 <heath> https://gist.githubusercontent.com/heath/2453782e6f8723d08bae/raw/b4de692060b1496472e8ed2aac26540bd41c5acd/gistfile1.txt
13:22:03 <heath> shapr: maybe this will help you help me one day :P
13:22:07 <bernalex> heath: please use a less... annoying site, like lpaste
13:23:13 <bernalex> heath: also lolwtf. the answer is "getDirectoryContents "." >>= mapM_ putStrLn".
13:23:23 <bernalex> heath: have you read LYAH? I suggest you do. :-)
13:23:37 <heath> of course!
13:23:47 <heath> i'm halfway through rwh
13:25:00 <srhb> heath: You understand the last error, right?
13:25:02 <bernalex> heath: well "print System.Directory.getDirectoryContents cwd" is just all kinds of wrong
13:25:24 <monochrom> if you want to use getCurrentDirectory there, it is: getCurrentDirectory >>= \cwd -> getDirectoryContents cwd >>= mapM_ putStrLn
13:25:36 <bernalex> heath: and leads me to think you need to reread LYAH, if you don't even understand that application associativity
13:25:52 <srhb> bernalex: To be fair LYAH really doesn't go into depth with that at all
13:26:00 <bernalex> monochrom: it does mention how currying works
13:26:11 <heath> bernalex: it's looking for a type of IO () but receiving a function of type IO FilePath -> t0
13:26:13 <bernalex> and probably associativity too IIRC
13:26:31 <bernalex> heath: f g x == ((f g) x)
13:26:40 <bernalex> heath: you want f (g x)
13:26:49 <gamegoblin> mmm I find myself wishing that prelude defined a “true = const True” function (and another for false)
13:27:09 <dwcook> heath, let cwd = System.Directory.getCurrentDirectory just creates an alias for getCurrentDirectory. It doesn't run it as you seem to expect.
13:27:39 <dwcook> heath, to run it, use do notation. ghci lets you also do things that are valid within do notation, such as cwd <- System.Directory.getCurrentDirectory
13:27:42 <bernalex> monochrom: IDR but I doubt that typechecks
13:27:49 <gamegoblin> Does anyone here know how to do structural induction?
13:28:00 <dwcook> Well, do notation doesn't "run" anything, it sequences
13:28:03 <bernalex> cwd is, what, CreateProcess -> Maybe FilePath?
13:28:16 <bernalex> @type cwd
13:28:17 <lambdabot> Not in scope: cwd
13:28:41 <monochrom> one day I really should write my IO tutorial. unfortunately, I have already written it: http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#I.2FO
13:28:44 <fizruk> gamegoblin: case by case?
13:28:55 <evincar> gamegoblin: I would almost rather have true = const, false = const id = flip const after the Church Booleans.
13:29:13 <shachaf> I'm not really sure what "sequencing" means, though people keep using that word.
13:29:27 <srhb> shachaf: Using >> presumably
13:29:29 <monochrom> bernalex, cwd is a local variable
13:29:30 <srhb> Don't we call that sequence?
13:29:32 <shachaf> [1,2,3] -- I have sequenced these numbers.
13:29:38 <gamegoblin> evincar: I’d like it the other way for things like “filter true xs”
13:29:55 <bernalex> monochrom: oh. yeah I read it now.
13:31:41 <bernalex> so just "mapM_ putStrLn =<< getDirectoryContents =<< getCurrentDirectory"
13:32:41 <srhb> Needs more fmap
13:40:39 <ReinH> srhb: well, there is also `sequence'...
13:41:03 <srhb> Which is a lot of >>!
13:41:27 <ReinH> gamegoblin: structural induction? What are you triyng to prove?
13:41:29 <ReinH> srhb: :p
13:41:40 <srhb> I think it makes sense. :P
13:41:42 <gamegoblin> ReinH: the monad laws for a monad I made
13:41:55 <bernalex> srhb: oh you mean <$> instead of mapM_?
13:42:30 <akurilin> Quick question: where does cabal dump expanded TH code if I add -ddump-splices to the cabal file?
13:43:00 <srhb> bernalex: Neh, won't do much good. :P
13:43:02 <ReinH> gamegoblin: maybe try proving them for a Maybe a first?
13:43:09 <bernalex> srhb: no would be terrible :->
13:43:44 <gamegoblin> ReinH: I’ve proved them for other stuff before. I’m trying to prove them for a fairly complex parser monad I’ve made.
13:45:40 <ReinH> gamegoblin: you don't necessarily need induction. You can use equational reasoning as well.
13:46:09 <gamegoblin> ReinH: It gets hairy with some recursive functions and polymorphism
13:46:34 <ReinH> gamegoblin: perhaps proving them for the kleisli category version of the laws would be easier?
13:47:13 <gamegoblin> ReinH: I was actually just looking into doing that, as I was reading the Pipes law proofs, that’s what tekmo does
13:47:14 <ReinH> gamegoblin: or perhaps put your monad definition in a paste and someone smarter than me can give you some more concrete advice? :)
13:47:51 <gamegoblin> I emailed Gabriel (tekmo) about them. He said he’d get back to me tomorrow. So we’ll see!
13:47:56 <ReinH> cool :)
13:50:17 <gamegoblin> the left identity wasn’t too troublesome, but the right identity calls for induction, and I’ve never used induction in a programatic sense
13:50:19 <davd> are there any public talks with Gabriel available? (I know of the 'cast)
13:50:35 <gamegoblin> I’ve only listened to the pipes vs conduit haskell cast =/
13:50:59 <gamegoblin> and I occasionally creep his comments on reddit
13:51:06 <gamegoblin> Usually has some interesting things to say
13:57:53 <chrisw_> What are my options for 3D geometry libraries? In particular, I'm looking for things like ray-triangle intersection and nearest point on a triangle to a given point.
13:57:59 <th3w4c0k1d> I've written some awful code but I'm not sure how to speed up this list comprehension: http://lpaste.net/102580 Is there an easier way to do this? Should I not be using lists?
13:58:21 <identity> th3w4c0k1d: you definitely should not be using lists.
13:58:44 <th3w4c0k1d> identity: Is it the concat that tells you that? Or the (++)?
13:59:03 <identity> th3w4c0k1d: I'm not sure what it's doing entirely, but you're indexing into the list as well and so on.
13:59:06 <davd> lpaste seems to broken on safari btw.. code extends throughout the white box.
13:59:08 <chrisw_> th3w4c0k1d, concat, ++, and !!
13:59:09 <identity> which is all in linear time.
13:59:41 <th3w4c0k1d> Ah, I see, thank you - so my best alternative would be a... Sequence, they are called?
13:59:45 <gamegoblin> th3w4c0k1d: remeber that haskell lists are linked lists. That means calling the Nth index takes N operations, rather than being virtually instant as in C or something
13:59:56 <chrisw_> Check out the Vector package
14:00:00 <davd> th3w4c0k1d: Data.Vector.Unboxed is sutitable for most non-abstract types. provides overloading of most operations in Data.List.
14:00:31 <davd> s/sutitable/suitable/
14:00:36 <identity> If you're doing 2D arrays or some such, the repa package is rather nice
14:01:02 <th3w4c0k1d> Awesome, this has been very helpful, thanks.
14:02:38 <chrisw_> th3w4c0k1d, in particular, check out Vector.backpermute. It might be very convenient for what you're trying to do.
14:15:09 <Bor0> when I have data Test = A | B | C, and I use deriving Show, or deriving Eq, how does it know to show "A" for A, or that A == A is true?
14:15:17 <Bor0> how does it automatically define the instances
14:15:56 <petrie> I don't know why but I am having the hardest time writing more than a single expression in a function.
14:16:14 <geekosaur> Bor0, http://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18200011
14:16:56 <shachaf> You're one step ahead of me -- I don't even know what "writing more than a single expression in a function" means!
14:17:09 <shachaf> Unless you mean an expression made of smaller expressions.
14:17:18 <geekosaur> it's all single expressions
14:17:40 <bitemyapp> shachaf: they might mean a do block, but that implies a particular interface.
14:17:49 <petrie> hmm
14:17:54 <geekosaur> and it still turns into a single expression in the end
14:17:58 <bitemyapp> of course.
14:18:05 <bitemyapp> I'm just trying to be less obtuse.
14:18:09 <petrie> I dunno, I am dumbfounded by quchen's variance function compared to mine
14:18:12 <bitemyapp> and intuit what they actually want.
14:18:35 <Bor0> geekosaur, so we can only derive from classes specified in 1 (Eq, Ord, Enum, Bounded, Show, or Read) ? or this isn't true
14:18:45 <petrie> shachaf: maybe it is my "noobness" coming in to play using wrong terminology.
14:19:08 <geekosaur> Bor0, there are extensions which can derive some other things, but basically that is it
14:19:10 <shachaf> You're referring to things I can't see, like your code and quchen's variance function. So it's hard to help you.
14:19:22 <Bor0> got it. thanks.
14:19:37 <smiller2> Why can attoparsec parsers only be used as Producers, rather than Pipes?
14:19:41 <petrie> Oh sorry, hold on Ill post it.
14:19:55 <srhb> petrie: lpaste.net  :)
14:20:03 <geekosaur> you can also derive stuff "through" a newtype (again, with an extension), but that's just making something else visible by automatically wrapping/unwrapping; it can't create ex nihilo
14:20:49 <lispy> smiller2: is that true? I'm familiar with attoparsec but not Pipes/Produces.
14:20:58 <petrie> http://lpaste.net/3711902395823816704
14:21:24 <petrie> Maybe I am just not understanding how to write stuff using where and let properly
14:21:37 <lispy> smiller2: intuitively, it seems like it should fit iteratees as it can produce results and lets you know when more input is required.
14:22:22 <shachaf> What's the question about your version?
14:23:24 <petrie> well I am not understanding how he was able to have 4 lines after his where, anytime I try doing it I just am only able to define functions and call to them on the first line.
14:23:32 <shachaf> I think quchen's !s do not help him because he didn't use foldl'. Though maybe the strictness analyzer can make it OK.
14:24:00 <shachaf> petrie: You aren't asking questions in such a way that people can figure out your problem. :-(
14:24:20 <shachaf> A good way to ask a question is to say: what you did; what you expected would happen; what actually happened.
14:24:31 <shachaf> This means full code and full compiler error message, at least.
14:25:10 * lispy doubts the strictness analyzer would find the strictness here.
14:25:10 <petrie> Well its not really an error... It's more of me not understanding it.
14:25:15 <petrie> I am phrasing it horribly though, sorry.
14:25:27 <Renderwahn> what's the <$> and <*> used with aeson called? it's somewhat hard to google for that
14:25:33 <shachaf> You said "anytime I try doing it I just am only able to define functions and call to them on the first line"
14:25:39 <lispy> Renderwahn: Applicative
14:25:41 <shachaf> What does "able" mean?
14:25:43 <srhb> Renderwahn: first is fmap..
14:25:52 <shachaf> Renderwahn: Use Hoogle!
14:25:53 <shachaf> @where hoogle
14:25:53 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:25:54 <srhb> Renderwahn: Second is.. ap?
14:26:00 <lispy> @hoogle <$>
14:26:00 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
14:26:01 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
14:26:26 <Renderwahn> ohha, this is more advanced stuff than i thought
14:26:46 <petrie> shachaf: To my knowledge I guess?
14:26:55 <shachaf> petrie: It sounds to me like "I tried to do it and I got a compiler error message that I didn't understand".
14:27:20 <shachaf> [so I gave up and went and asked a vague question in #haskell and hoped someone would guess what I was trying to do]
14:27:30 <petrie> lol no
14:27:34 <lispy> Renderwahn: if you want to understand it fully, then yeah maybe it's advanced. Understading it what it does in a concrete usage shouldn't require advanced knowledge
14:27:35 <shachaf> If you mean that you didn't know what you want to type in the first place, that's different.
14:27:37 <petrie> but I can see where you get that from
14:28:22 <lispy> Renderwahn: If you link the code you're reading, I'm sure folks here could help you understand it.
14:28:27 <srhb> Isn't it just the confusion over coming from some language where functions are lines of instructions on what the machine should do?
14:29:09 <smiller2> lispy: Hmm.  The two packages that integrates attoparsec with pipes are pipes-attoparsec (only exported the module http://hackage.haskell.org/package/pipes-attoparsec-0.5.0/docs/Pipes-Attoparsec.html) and pipes-parser (http://hackage.haskell.org/package/pipes-parse-3.0.1/docs/Pipes-Parse.html#t:Parser), but with their API I think you have to have an existing Producer, which means you can't use the libraries to convert a Parser to a P
14:29:09 <petrie> srhb: Yeah that is a lot more what I was trying to say lol
14:29:40 <smiller2> lispy: Hence my confusion, because I would expect the API to maintain Pipes' composibility.
14:29:43 <petrie> Its just interesting trying to figure out how to write a function that says how to solve the problem than just write the statements to do it.
14:30:06 <Renderwahn> lispy: i'm just browsing through the aeson doc trying to figure out basic usage, since my haskell-fu is weak i'll just haggle along unknown concepts until I find something I can understand :D
14:30:22 <lispy> smiller2: your message got cut off (too long), at "...to convert a Parser to a P"
14:30:40 <srhb> petrie: Definitely. :)
14:31:19 <smiller2> lispy: with their API I think you have to have an existing Producer, which means you can't use the libraries to convert a Parser to a Pipe to compose it with other Pipes
14:31:22 <petrie> I guess that will just come in time :|
14:31:34 <lispy> smiller2: I understand iteratees at a high level, but I'm unfamiliar with the libraries you're using. So, as much as I want to be helpful I can only speculate :(
14:31:56 <chrisw_> Has anyonen else had trouble installing criterion? I'm getting type errors during the compilation of "cabal install criterion".
14:32:20 <shachaf> petrie: OK, I see.
14:33:07 <lispy> chrisw_: I'd say put the details (compiler version, cabal error, your installed packages, etc) on lpaste.net and see if anyone knows what's going on.
14:34:03 <srhb> petrie: Well if you have specific issues, it helps bringing them up :)
14:34:14 <lispy> chrisw_: in particular, if you're on anything other than 7.6.x, it could be a ghc compat issue
14:34:29 <srhb> I think it's mostly an issue when "imagining how to solve problems" and not so much when you actually solve a _specific_ problem
14:34:30 <caseof> Is it possible to write a class Queue m v that can have instances working in the State monad and the IO monad? Methods would be push/pop, standard for a queue.
14:35:04 <caseof> One instance working in the State monad and another in the IO monad I mean
14:35:23 <petrie> yeah I have been sitting here for like 10 minutes trying to figure out how to write my own version of a polish notation function, and just feel "constrained" by so many of haskells concepts.
14:35:39 <petrie> Mind you its because I am still new to all this, heh.
14:35:43 <smiller2> lispy: *nod*, thanks for your help anyway =).  I'll probably try to write a attoparsec Parser -> Pipe library myself (rather than Producer -> Parser -> (r, Producer for leftovers)), and if I run into obstacles than I'll have at least learned why.
14:36:03 <lispy> smiller2: seems reasonable :)
14:36:41 <quchen> shachaf: In my function, shouldn't the tuple be evaluated to check whether the pattern matches?
14:36:59 <chrisw_> Anybody know what's up with this cabal install criterion failure? http://lpaste.net/102582
14:37:00 <quchen> I agree that if I had used an irrefutable pattern, I would have needed foldl'
14:37:08 <lispy> caseof: Are you asking because you tried it and had issues?
14:37:16 <caseof> lispy: Yes
14:37:23 <lispy> caseof: what happened?
14:37:39 <davd> smiller2: you could turn to the pipes mailing list with questions, Gabriel and others are very helpful over there
14:37:56 <petrie> Is there any other material I should read besides lyah and rwh to help think more functional?
14:38:05 <c_wraith> petrie: let me guess..  You're not really comfortable with recursion, are you?
14:38:16 <davd> petrie: functional pearls is commonly recommended
14:38:22 <smiller2> davd: Aha, thanks for pointing me in the right direction!
14:38:25 <srhb> petrie: Not really. MJust start coding ;)
14:38:33 <caseof> lispy: don't know how to write it, I wasm write it in a form that matches both IO and State. Any pointer to an example?
14:38:34 <petrie> c_wraith: I understand the concept I believe.. to a basic standard.
14:38:40 <srhb> I find it's usually just a question of "doing stuff" instead of deliberating on it
14:38:49 <caseof> tlispy: don't know how to write it, I wasn't able to write it in a form that matches both IO and State. Any pointer to an example?
14:39:04 <srhb> No amount of reading will help if you try to reify it on an abstract level only
14:39:11 <c_wraith> petrie: no, "comfortable with".  Like, you think it's trivial to convert any loop to recursion.
14:39:27 <pyon> Is it possible to define a Contravariant instance for this type or something similar to it? "data Foo l a = Bar (a -> Foo l a) | Baz l"
14:40:10 <petrie> c_wraith: I am not sure, I haven't written anything that used recursion except like 1 function..
14:40:16 <petrie> If I am understanding you correctly
14:40:39 <lispy> chrisw_: that is weird.
14:40:48 <lispy> chrisw_: you might try the latest version of criterion
14:40:56 <lispy> chrisw_: looks like you're using the second to latest
14:41:00 <c_wraith> petrie: once you think that for and while loops are just boring special cases of recursion, you'll have a good grip on it. :)
14:41:37 <c_wraith> pyon: Yeah, it should be able to make that an instance of Contravariant.
14:41:47 <lispy> caseof: What are the type signatures of things in Queue m v? push :: ??
14:42:21 <lispy> caseof: something you can try: Write pushIO :: ... and pushState :: ..., implement both.
14:42:33 <lispy> caseof: then once you have them, can you see how to generalize them?
14:42:44 <petrie> Ah :)
14:43:02 <chrisw_> lispy, fixed. I did cabal update then cabal install criterion to get the newest version (8.0.2). Thanks =)
14:43:02 <lispy> chrisw_: I don't see how Text is coming into the picture
14:43:10 <lispy> chrisw_: yay!
14:43:38 <shachaf> quchen: I don't think so.
14:44:06 <caseof> lispy: For instance --> http://lpaste.net/102583
14:44:06 <lispy> caseof: I'd start with the version for State. I'm not sure where you're going to store the state of the queue when you use IO
14:44:31 <caseof> lispy: I would store the queue state in an IORef
14:44:33 <c_wraith> pyon: contramap f (Bar b) = Bar $ \x -> contramap f (b x), or something like that.
14:44:55 <caseof> lispy: my question at the point is -- can this be done at all?
14:45:23 <c_wraith> pyon: whoops.  forgot to actually use f inside the parens.  You can figure it out. :)
14:45:25 <pyon> c_wraith: oh, yes, I was being dumb
14:45:37 <lispy> caseof: that code you just showed me works, right?
14:45:58 <pyon> c_wraith: f `contramap` Bar b = Bar $ (contramap f . g) . f -- I missed this
14:46:07 <caseof> lispy: Yes but only with State. How can I implement the same with IO, I don't know
14:46:14 <pyon> c_wraith: Thanks!
14:46:34 <c_wraith> pyon: was it the recursive call to contramap that you missed?
14:46:44 <pyon> Yeah. :-|
14:46:49 <c_wraith> that'll do it
14:47:06 <pyon> whoa, the parentheses are superfluous
14:47:09 * pyon is super-dumb today
14:47:13 <da-gp__> Which of the functions head,tail,last,init are slow/fast?
14:47:24 <da-gp__> (Compared to : being fast and ++ slow)
14:47:30 <lispy> caseof: What type of IORef do you want to use?
14:47:43 <pyon> Is there anything like Applicative, but for Contravariant functors?
14:48:00 <srhb> da-gp__: How is ++ slow?
14:48:05 <c_wraith> pyon: if there is, it's in an edwardk library
14:48:13 <caseof> lispy: IORef ([v],[v]) or something like that
14:48:15 <da-gp__> srhb: in the sense that ++ has to run through the whole first list
14:48:26 <srhb> da-gp__: is take 1 $ as ++ bs slow?
14:48:49 <lispy> caseof: okay, so instead of `(i,o) <- get`, you'd need to say `(i,o) <- readIORef ref`.
14:49:04 <lispy> caseof: Where will ref come from?
14:49:08 <da-gp__> srhb: no, just if you have to actually append it and the first list is long
14:49:12 <da-gp__> u get the point
14:49:47 <evincar> pyon: What types do you expect? contrap :: f (b -> a) -> f a -> f b; contrapure :: ?
14:49:56 <srhb> da-gp__: Fine. In that case "last" is slow.
14:50:16 <da-gp__> srhb: head/tail are always fast?
14:50:24 <caseof> lispy: I'll have a method to create the queue somewhere (equivalent to runState creating the IORef ([],[]) )
14:50:24 <pyon> evincar: Not even sure yet... But that sounds reasonable.
14:50:34 <srhb> da-gp__: well, they're both O(1)
14:50:46 <da-gp__> srhb: ok, and last is O(n) ?
14:50:50 <srhb> No
14:51:07 <da-gp__> what is it
14:51:09 <srhb> It's complicated, imagine if you're writing all but the last element to a file
14:51:16 <caseof> lispy: just found http://stackoverflow.com/questions/3640120/combine-state-with-io-actions
14:51:28 <srhb> And then doing something else with that
14:51:41 <srhb> If you're using it only to find the very last element, then yes, it's O(n)
14:52:00 <evincar> pyon: I think you want something almost, but not quite, exactly unlike coapplicative: copure :: f a -> a; coap :: (f a -> f b) -> f (a -> b)
14:52:01 <srhb> After all you need to traverse each cell to find the next one
14:52:13 <da-gp__> srhb: is init in the same sense O(n) - if the whole thing is needed?
14:52:22 <srhb> da-gp__: Init is all but last, right?
14:52:25 <da-gp__> yeah
14:52:42 <srhb> da-gp__: Then in some sense it's O(1)
14:52:56 <pyon> evincar: http://lpaste.net/102584 -- This is my code right now. I came up with the Functor/Applicative/Monad instances for Source pretty quickly. I want to know if there is anything simlar for Sink.
14:53:01 <da-gp__> oh, interesting
14:53:11 <srhb> da-gp__: Well, if you're using every element anyway you still have to do the traversal
14:53:21 <srhb> da-gp__: The only place where init comes into play is at the end of the list
14:53:37 <srhb> da-gp__: Which is why it's really not as simple as saying "fast" vs "slow"
14:53:57 <da-gp__> srhb: but interestingly, tail is always fast, isn't it?
14:54:06 <da-gp__> even if we need the whole tail
14:54:12 <srhb> da-gp__: Well sure, the only thing it does is chop off the head
14:54:44 <srhb> da-gp__: if you
14:54:58 <srhb> da-gp__: If you try to analyze them all in terms of a program that generates a list of a certain length
14:54:59 <da-gp__> Ok, so basically, head/tail are "fast" in the same sense as : is "fast".  And init/last are "slow" in the same sense that ++ is "slow".
14:55:15 <srhb> da-gp__: And then compared the complexity between deepseqing each list with either of the functions applied
14:55:17 <c_wraith> da-gp__: it's a little more subtle than that.
14:55:43 <lispy> caseof: oh, so you wanted to use State with IO? I'm sorry. I thought you wanted to make separate State and IO instances for Queue m v, like Queue IO V AND Queue State v
14:56:04 <srhb> da-gp__: I don't really see how ++ is eer slow
14:56:10 <lispy> caseof: I was actually just getting ready to explain that for the IO version you probably want something like StateT :)
14:56:22 <srhb> da-gp__: Not in the sense that i scales with list length, as you seem to imply
14:56:24 <c_wraith> da-gp__: both head and tail have to evaluate the first constructor of the list.  They're as fast as pattern-matching on the list would be.  But how fast that is depends on how the list was generated
14:57:23 <da-gp__> oh..
14:57:52 <srhb> let a = head [1..] in "somestring"
14:57:59 <srhb> \o/
14:58:23 <c_wraith> da-gp__: on the other hand, using the (:) constructor to stick an element is just one allocation, no matter what its arguments are.
14:58:30 <da-gp__> srhb: I get this whole idea of mine from here: http://learnyouahaskell.com/starting-out#an-intro-to-lists   Search for the paragraph starting with "Watch out"
14:58:34 <c_wraith> to stick an element at the head of a new list, that is
14:58:43 <da-gp__> rather, "Watch out when repeatedly"
14:59:19 <srhb> dp_wiz: I think the paragraph is misleading.
14:59:21 <srhb> oop
14:59:24 <srhb> da-gp__: ^^
14:59:55 <lispy> caseof: Actually, if you're using State to store the state of the Queue, I doubt IORefs will give you anything.
15:00:35 <caseof> lispy: say that later the queue will be stored in a remote DB - then I need to do some IO actions to retrieve the state
15:00:47 <srhb> da-gp__: How much more expensive is [1] ++ [2] ++ [3] vs. 1:2:3:[] ?
15:01:04 <srhb> The cost is that of replacing [] with a Cons cell for each element, as far as I can see
15:01:18 <caseof> lispy: I want to use either IO or State (depending on where the queue lives - IORef is just to mimic IO operations).
15:01:23 <lispy> caseof: Right, but you probably don't want to start storing the intermediate state in an IORef because of that.
15:01:25 <da-gp__> ok, but the point is a    longList ++ [a]
15:01:35 <srhb> da-gp__: No, it isn't
15:01:46 <srhb> da-gp__: again, if you're traversing the list anyway, the cost is constant
15:02:07 <lispy> caseof: It sounds like you want to be monadic in your accesses, but polymorphic about the monad.
15:02:11 <evincar> pyon: Try getting an applicative for free from Control.Applicative.Free? :P
15:02:25 <srhb> da-gp__: Remember that it won't even be _evaluated_ if you don't need the first element of [a]
15:02:40 <evincar> pyon: I doubt it'll work, but it's worth a shot.
15:03:29 <caseof> lispy: if you say so :-) Is this easy to do?
15:03:31 <srhb> (That's not the whole story)
15:03:40 <lispy> caseof: I'm thinking out loud at the moment.
15:03:48 <da-gp__> hmok
15:03:52 <da-gp__> :S
15:04:52 <pyon> evincar: Gonna try that. :-)
15:05:11 <srhb> da-gp__: But really if you're doing "stuff with the end of a list" you're probably doing something wrong anyway :)
15:05:38 <lispy> caseof: type Queue v a = StateT ([v],[v]) IO a
15:05:44 <da-gp__> srhb: the point seems to be that if i have a choice of the two, in a recursion, i should use : instead of ++
15:05:50 <da-gp__> to collect data for instance
15:05:57 <srhb> da-gp__: yeah
15:06:01 <da-gp__> ok good
15:06:17 <lispy> caseof: If you're just going to do all this over IO, that's probably the type you want.
15:06:30 <lispy> caseof: it fixes you to IO, but it gives you the state.
15:06:32 <da-gp__> are there similar rules of thumb I can keep in mind for the head/tail/init/last functions?
15:06:39 <da-gp__> i guess that's what i was thinking about
15:06:53 <srhb> da-gp__: Never use any of them
15:06:58 <da-gp__> lol
15:06:58 <srhb> Would be my opinion :P
15:07:02 <da-gp__> wtf
15:07:03 <da-gp__> why
15:07:05 <srhb> Certainly not head
15:07:07 <srhb> It's unsafe.
15:07:12 <lispy> caseof: https://hackage.haskell.org/package/mtl-2.1.3.1/docs/Control-Monad-State-Strict.html#t:StateT
15:07:23 <srhb> Same for last
15:07:30 <srhb> > init []
15:07:31 <lambdabot>  *Exception: Prelude.init: empty list
15:07:32 <srhb> > head []
15:07:33 <lambdabot>  *Exception: Prelude.head: empty list
15:07:36 <srhb> > last []
15:07:37 <lambdabot>  *Exception: Prelude.last: empty list
15:07:41 <srhb> etc.
15:07:43 <caseof> lispy: Ok, thx. I will try to write my code using StateT
15:07:50 <caseof> Will let you know :)
15:07:51 <srhb> da-gp__: We don't like exceptions :)
15:07:54 <da-gp__> > tail []
15:07:56 <lambdabot>  *Exception: Prelude.tail: empty list
15:07:58 <caseof> :t StateT
15:07:59 <lambdabot> (s -> m (a, s)) -> StateT s m a
15:07:59 <da-gp__> heh
15:08:01 <da-gp__> ok
15:08:34 <stolaruk> On Mac, is there a way to uninstall everything that came with the Haskell Platform?
15:09:03 <srhb> stolaruk: Yes (no) -- well almost
15:09:09 <srhb> stolaruk: sudo uninstall-hs I believe
15:09:19 <stolaruk> ok
15:09:21 <stolaruk> thx
15:09:36 <srhb> da-gp__: I'm sorry if this is all a bit confusing. :P
15:09:50 <srhb> da-gp__: The real story is that it's not as much of an issue as you might imagine
15:09:56 <lispy> caseof: I tend to think in terms of mtl transformers but then not use the library in actual code.
15:10:32 <da-gp__> srhb: ok, i'll just stop worrying about it
15:10:35 <lispy> caseof: either way, you'll need to lift the IO operations into this StateT
15:10:43 <srhb> da-gp__: WEll think about it once you are doing something concrete with them
15:10:48 <da-gp__> yeah
15:10:53 <srhb> da-gp__: And if unsure then, ask. You'll gain intuition :)
15:11:15 <srhb> da-gp__: non-strict semantics are fun. :P
15:11:58 <lispy> caseof: if you're not already familiar with lift/liftIO you might take a minute to read up on it. It's how you layer operations from different monads into one computation.
15:12:09 <da-gp__> thanks
15:15:34 <Cr0s> hi
15:19:27 <Algebr> Presumably /libraries/ghc-prim/GHC, the prim stands for primitives?
15:21:56 <bitemyapp> how do I collapse the boilerplate here? http://lpaste.net/102587
15:22:13 <bitemyapp> I have a Maybe value I am pattern-matching on and I'd like to remove the redundancy.
15:22:46 <bitemyapp> I guess I could case boost, generate either an empty list or one with the key-value pair, and then mappend that with the termValue one...
15:22:58 <bitemyapp> yeah I'm doing that.
15:23:26 <Algebr> What do the #s mean in Types.hs? example: data {-# CTYPE "HsChar" #-} Char = C# Char#
15:23:50 <kakos> Is it possible to make custom prefix operators?
15:23:53 <tikhon> They usually mean it's a primitive constructor of some sort in GHC
15:23:59 <bitemyapp> kakos: functions?
15:24:15 <shachaf> kakos: Yes, for instance "foo" is a prefix operator.
15:24:16 <kakos> Yes, but with symbols and without the ()
15:24:29 <tikhon> kakos: you generally don't need the () for function application
15:24:31 <shachaf> Ah. Then no.
15:24:39 <shachaf> The only prefix operator is -
15:24:45 <tikhon> which is a terrible hack!
15:24:50 <shachaf> It is.
15:25:05 <shachaf> Well, a hack, anyway.
15:25:10 <Algebr> tikhon: Primitive constructor means something implemented in C?
15:25:11 <kakos> tikhon: It seems to be needed if there are symbols in the function.
15:25:41 <tikhon> Algebr: well, it's something handled specially by the compiler
15:25:52 <tikhon> ie Char# is never defined in a Haskell library or anything
15:25:52 <shachaf> I should have been more careful.
15:25:58 <tikhon> often, it means "unboxed"
15:26:02 <deathbird> Yeah the compiler is self-hosted
15:26:06 <shachaf> If it's an operator, then it can't be prefix (with the exception of -).
15:26:39 <tikhon> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/primitives.html
15:26:49 <tikhon> erm, that's a bit of an old link
15:26:52 <TallerGhostWalt> I have a template haskell question...
15:26:53 <tikhon> but it shouldn't matter, I hope
15:27:04 <Algebr> tikhon: So I can do :i Char, but I can't do :i Word, even though both are defined in Types.hs
15:27:09 <tikhon> so Char#, Int# and so on are unboxed
15:27:13 <TallerGhostWalt> I have a function f a b = does some stuff
15:27:14 <shachaf> # doesn't have any intrinsic meaning, though.
15:27:21 <shachaf> It just happens that Int# is the name of a primitive type.
15:27:22 <tikhon> Algebr: no, you can do :i Word too
15:27:50 <TallerGhostWalt> I am trying to use TH to define a function: g b = f (someConstantA) b
15:27:51 <Algebr> tikhon: hmm, craps out for me in ghci
15:27:58 <tikhon> :i Word?
15:28:00 <Algebr> says not in scope: data constructor.
15:28:02 <TallerGhostWalt> but I keep getting an error about types being lifted
15:28:09 <Algebr> tikhon: yes.
15:28:10 <tikhon> oh, you need to import it
15:28:13 <tikhon> import Data.Word
15:28:26 <Algebr> Oh, I guess its not part of the prelude.
15:28:30 <tikhon> right
15:28:50 <tikhon> but yeah, as shachaf said, the foo# thing is just a naming convention
15:28:51 <TallerGhostWalt> maybe stack would be a better format for the question but it just seems like something that should be simpler
15:29:09 <tikhon> it's often used for unboxed types and primitive operations
15:29:10 <TallerGhostWalt> maybe not though
15:29:38 <shachaf> You need to enable the GHC extension MagicHash to use # names.
15:30:12 <shachaf> There are many special functions and non-functions that have # names.
15:30:32 <shachaf> tagToEnum# is pretty special, for instace.
15:31:09 <tikhon> my favorite one is reallyUnsafePtrEquality#
15:31:48 <shachaf> It really is really unsafe.
15:31:55 <shachaf> You can get both false positives and false negatives.
15:32:03 <Algebr> I see. So is Alex ghc's lexer and Happy is the parser?
15:32:42 <shachaf> It is an error to write tagToEnum# not applied to an Int#
15:32:48 <shachaf> :t GHC.Prim.tagToEnum#
15:32:49 <lambdabot>     tagToEnum# must appear applied to one argument
15:32:49 <lambdabot>     In the expression: GHC.Prim.tagToEnum#
15:33:22 <corgifex> :t \x -> GHC.Prim.tagToEnum# x
15:33:23 <lambdabot>     Bad call to tagToEnum# at type t_a8eG
15:33:23 <lambdabot>       Specify the type by giving a type signature
15:33:23 <lambdabot>       e.g. (tagToEnum# x) :: Bool
15:33:46 <shachaf> :t \x -> GHC.Prim.tagToEnum# x :: Bool
15:33:47 <lambdabot> GHC.Prim.Int# -> Bool
15:33:57 <corgifex> this is like ocaml all over again
15:34:02 <shachaf> A special function.
15:34:14 <shachaf> unsafeCoerce# is also pretty special.
15:34:16 <Algebr> So crazy how much of Haskell is implemented in haskell..
15:35:00 <[swift]_> has anyone else been having problems with snap and ghc 7.8?
15:35:35 <shachaf> You'd think from the type that unsafeCoerce# is the same as unsafeCoerce, but it's not.
15:35:51 <[swift]_> the problem seems to be that snap-load-static requires template-haskell <2.9, but ghc 7.8 comes with template-haskell 2.9
15:35:57 <[swift]_> sorry, snap-loader-static
15:36:11 <shachaf> Perhaps the folks in #snapframework would know.
15:36:25 <[swift]_> heh, fair enough
15:36:31 <[swift]_> i always forget that channel exists
15:37:43 <corgifex> still no 7.8.2 :-(
15:39:55 <petrie> Reading these functional pearl papers are great whoever said for me to read them. Thanks! :)
15:40:40 <quchen> corgifex: https://github.com/ghc/ghc/releases
15:40:58 <quchen> It's probably not announced yet because the binaries aren't built.
15:41:13 <quchen> If you've got problems with the bug in .1, you can use that one already.
15:41:20 <corgifex> oh, nice
15:46:50 <syao> hello, how could I implement similar to clojure's "with-meta" function in haskell http://clojuredocs.org/clojure_core/clojure.core/with-meta
15:47:01 * hackagebot snap-loader-static 0.9.0.2 - Snap: A Haskell Web Framework: static loader  http://hackage.haskell.org/package/snap-loader-static-0.9.0.2 (DougBeardsley)
15:47:17 <syao> I feel that it would be monad, but then the usage would be changed
15:48:20 <syao> *I will be forced to use bind operato
15:48:40 <corgifex> so this lets you attach things to other things?
15:48:50 <quchen> Sounds like a tuple to me.
15:49:46 <syao> yes, but the original is not changed in any way.
15:49:56 <quchen> A hidden sneaky tuple. You probably don't want to do that in Haskell.
15:50:37 <syao> in fact yes, its the sneaky tuple, but I can't think how I could implement it
15:50:41 <tikhon> as I understand it, meta just adds some hidden state keyed on a value
15:50:45 <tikhon> right?
15:50:49 <syao> yes
15:50:51 <xunie-laptop> Question: What is meant by 'Strict' in this context?: http://hackage.haskell.org/package/HDBC-2.4.0.0/docs/Database-HDBC.html#v:quickQuery-39-
15:51:44 <tikhon> you can definitely do it by making it into a monad that manages the map for you: you could start with State or something
15:51:55 <pyon> Is there something like Monad, but just with join, no return?
15:52:02 * hackagebot git-annex 5.20140412 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140412 (JoeyHess)
15:52:14 <tikhon> pyon: not as a standard class
15:52:29 <tikhon> pyon: what do you need it for?
15:53:02 <tikhon> generally, most interesting structures end up having some sort of "identity" like return
15:53:04 <quchen> xunie-laptop: Probably that it will fully evaluate the query result before returning.
15:53:06 <syao> tikhon, but how about the usage? If I use monad I will be forced to use bind operator instead normal ones, yes?
15:53:08 <pyon> tikhon: I have something like "Monoid r => Monad (Foo r)", and it would also make sense to say "Semigroup r => ??? (Foo r)".
15:53:09 <shachaf> pyon: edwardk has a class for it.
15:53:29 <tikhon> syao: yeah, you'd have to change the usage somewhat
15:53:39 <shachaf> http://hackage.haskell.org/package/semigroupoids-4.0.1/docs/Data-Functor-Bind.html#t:Bind
15:53:45 <tikhon> syao: but since you're adding extra structure to the code, I think that's fine
15:54:10 <pyon> shachaf: Whoa, thanks!
15:54:11 <shachaf> pyon: Yep, it has that instance.
15:54:11 <tikhon> pyon: I guess that makes sense. But how often do people use Semigroups that aren't Monoids?
15:54:23 <shachaf> Non-empty lists are nice.
15:54:25 <syao> tikhon, In fact no, I dont like the idea that the usage changes :/
15:55:01 <tikhon> well, you're adding a bunch of hidden behavior to your code, which goes against the Haskell ethos
15:55:06 <deathbird> Are DLists really any faster? Looking at the source, it seems like it just postpones all the operations until fromList is called.
15:55:13 <pyon> tikhon: Well, right now I was interested in "Monoid or Void", but I am sure other interesting semigroups could also arise.
15:55:37 <syao> Ok, thank you for all your answers :)
15:55:39 <pyon> tikhon: It is often true, at least in my experience, that "one pops up, many more will pop up later!"
15:55:49 <shachaf> deathbird: The trick is this: Evaluating ((a ++ b) ++ c) traverses a twice. But evaluating (((a ++) . (b ++)) . (c ++)) [] traverses a only once.
15:55:51 <tikhon> pyon: hmm, fair enough
15:56:18 <shachaf> It is not a question of being "faster" or "slower", though. They're fast or slow for different operations.
15:56:25 <deathbird> shachaf: Ah, I see. Very clever
15:56:49 <shachaf> deathbird: By composing these functions the actual appends are always right-associative, even if the compositions aren't.
15:56:57 <shachaf> This trick is more general than lists, of course.
15:57:04 <tikhon> and I definitely like the idea of specifying the *minimum* amount of structure you need—ie Semigroup rather than Monoid
15:57:20 <tikhon> as long as it's still very easy to pass a Monoid into it of course!
15:57:35 <tikhon> I'd expect that same for the FunctorBind class or whatever it's called
15:58:35 <tikhon> I guess it's called Apply?
15:58:58 <pyon> Apply and Bind.
15:59:08 <pyon> For pure-less Applicative and Monad. :-)
15:59:20 <tikhon> I guess ideally we could work with a lattice of typeclasses exposing various capabilities in different combinations
15:59:30 <tikhon> but I think the typeclass system makes that a bit of a pain in practice?
15:59:37 <shachaf> Yep.
16:00:14 <tikhon> It seems a lot of this stuff is moving in the same direction as structural sub-typing
16:00:15 <shachaf> Particular adding type classes after a hierarchy is established.
16:00:19 <petrie> Is however many elements you add before xs IE: (x:y:xs), bind x and y to the first 2 elements of the list?
16:00:41 <shachaf> petrie: The pattern is the same as the expression. > 1:2:[3,4] -- [1,2,3,4]
16:00:47 <tikhon> shachaf: yeah, that's actually my main worry about Apply and Bind
16:01:01 <tikhon> if you have a Bind m => constraint, could somebody use it with a normal monad?
16:01:03 <petrie> Ah yes ok thanks :)
16:01:17 <shachaf> tikhon: It's the same situation as, say, Monad and Functor.
16:01:18 <tikhon> I guess you could do instance Monad m => Bind m where ...
16:01:23 <tikhon> but that has its own problems
16:01:32 <shachaf> No, if you did that then every other instance would overlap and so on.
16:01:50 <tikhon> but that feels like a problem very specific to Haskell's typeclasses and instance rules
16:01:55 <shachaf> There is no good solution to this problem that I know of, and it would make so many things better if there was.
16:02:05 <shachaf> There have been lots of proposals.
16:02:21 <tikhon> it's more evidence that typeclasses really are a bit anti-modular
16:02:27 <petrie> I am not seeing how the operators are being matched? http://lpaste.net/8375977484729974784
16:02:43 <skypers> is there a way to derive Default?
16:02:48 <skypers> (implicitely)
16:03:04 <skypers> there’s no extension in GHC for that
16:03:11 <tikhon> skypers: maybe something with generics?
16:03:22 <skypers> DeriveGeneric?
16:03:40 <skypers> I don’t want something complicated, the instance is just stupid
16:03:42 <skypers> something like
16:03:54 <skypers> def = SceneState def def def def def def def def def def … def def
16:04:00 <pjdelport> did John Meacham's type class alias proposal ever get anywhere?
16:04:01 <tikhon> aah
16:04:04 <pjdelport> http://repetae.net/recent/out/classalias.html
16:04:17 <tikhon> pjdelport: I think it's been subsumed by ConstraintKinds?
16:04:20 <skypers> yeah
16:04:43 <skypers> type WriterError = (MonadError String m,MonadWriter Int m)
16:04:46 <skypers> + m
16:04:52 <skypers> type WriterError m = (MonadError String m,MonadWriter Int m)
16:05:02 <skypers> with ConstraintKinds, that’s correct
16:05:15 <stevely> what do people recommend these days for mysql libraries?
16:05:29 <skypers> the thing I’d LOVE to see changed is the type keyword to alias
16:05:38 <skypers> alias is a much better keyword imho
16:05:53 <corgifex> #define alias type
16:05:59 <skypers> D uses it and it’s <3
16:06:02 <skypers> corgifex: :D
16:06:06 <pjdelport> hmm, neat
16:06:08 <tikhon> oh yes, everything is better with a bit of CPP thrown in
16:06:11 * pjdelport has reading to do
16:06:17 <skypers> tikhon: what?
16:06:23 <tikhon> C preprocessor
16:06:29 <skypers> yeah, it’s awful…
16:06:29 <pordan30> petrie: the reducing function pattern matches against it's input; "*", say, matches any string xs such that xs = '*':[]
16:06:36 <tikhon> which, in hindsight, might be confused with C++ :þ
16:06:54 <tikhon> pjdelport: I thought this blog post was good: http://jeltsch.wordpress.com/2013/02/14/the-constraint-kind/
16:06:56 <skypers> I read in some mtl’s source macro to write instances faster
16:07:00 <skypers> I still think it’s a bad idea
16:07:04 <tikhon> yeah
16:07:18 <tikhon> if only typeclasses were more firstclass...
16:07:20 <petrie> pordan30: Arn't the only available variables to the list x, y and ys
16:07:22 <orbital_> quchen: thanks! Completely forgot about IRC for a while... So in this context (i.e., thinking of fmap as of applying a function inside a containing context), a function "contains" its result, not argument - correct?
16:07:25 <skypers> :)
16:07:32 <pjdelport> tikhon: Thanks!
16:07:37 <petrie> I dont see where they are being matched though
16:07:38 <corgifex> petrie: there is more than one list
16:08:18 <skypers> today a friend of my mine extoled the null-coalesce operator from C#
16:08:19 <petrie> Wait what
16:08:22 <skypers> it made me laugh
16:08:27 <skypers> because it’s just a restricted maybe :)
16:08:28 <petrie> foldingFunction [], isnt that only one list?
16:08:37 <tikhon> ??
16:08:40 <skypers> yes
16:08:42 <corgifex> petrie: that's not what the code says
16:08:46 <skypers> ??, that one
16:08:53 <tikhon> does it have one for field accesses too?
16:08:57 <corgifex> petrie: the code is foldl foldingFunction []
16:09:03 <pjdelport> orbital_: that's one way of thinking about it, but you shouldn't read too much into "contains"
16:09:04 <skypers> it’s less powerful tool than maybe
16:09:08 <skypers> tikhon: I don’t know
16:09:10 <tikhon> I used a language that had something like .? for field accesses that was nice
16:09:18 <mgsloan> tikhon: Yeah, I'd like to have (Dict :: Constraint -> *), and have these dict types be constructable as values (maybe just record / tuple syntax)
16:09:19 <corgifex> petrie: i.e. foldingFunction is the first argument to foldl ([] is the second argument)
16:09:21 <skypers> lens from Haskell maybe?
16:09:35 <petrie> Ohhhh
16:09:43 <tikhon> mgsloan: first-class modules!
16:09:47 <pjdelport> orbital_: It's more just that the function's result type happens to be the part that gets operated on by the (e ->) functor
16:09:50 <pordan30> petrie: foldl foldingfunction [] :: Num n => [String] -> [n]
16:10:01 <tikhon> typeclasses can't quite be normal records since they can contain types and stuff
16:10:13 <corgifex> pordan30: it's more restricted than Num
16:10:17 <corgifex> probably Fractional
16:10:24 <skypers> what the…
16:10:27 <skypers> :t Vector
16:10:28 <lambdabot> Not in scope: data constructor Vector
16:10:31 <skypers> :i Vector
16:10:38 <skypers> hm
16:10:40 <petrie> I'm starting to see it now
16:10:42 <pordan30> corgifex: oh, i didn't see the case for (/)
16:10:44 <tikhon> having a way to control scoping and such would be good too: I don't like how typeclass instances are always magically globally scoped
16:10:52 <skypers> > Data.Vector.fromList [1..5] :: Vector Int
16:10:53 <lambdabot>  Not in scope: type constructor or class ‘Vector’Not in scope: ‘Data.Vector.f...
16:11:00 <tikhon> but then you get the problem that you might have different Ord instances for the same type in different scopes...
16:11:00 <skypers> what a pity.
16:11:03 <mgsloan> tikhon: Fair point, you'd need to introduce a bit of extra machinery for associated type families
16:11:08 <skypers> @let import Data.Vector
16:11:08 <lambdabot>  .L.hs:145:32:
16:11:08 <lambdabot>      Ambiguous occurrence ‘indexed’
16:11:08 <lambdabot>      It could refer to either ‘Lens.indexed’,
16:11:08 <lambdabot>                               imported from ‘Control.Lens’ at .L.hs:40:1-43
16:11:08 <lambdabot>                               (and originally defined in ‘Control.Lens.Intern...
16:11:15 <skypers> dammit edwardk !!
16:11:17 <pjdelport> orbital_: But it gets more interesting when you consider contravariant functors, where contramap changes the *input* type.
16:11:24 <skypers> :)
16:11:26 <tikhon> mgsloan: exactly, but I think much of it would be machinery that languages like OCaml have already developed
16:11:28 <corgifex> @undefine
16:11:28 <lambdabot> Undefined.
16:11:32 <skypers> @let import qualified Data.Vector
16:11:33 <lambdabot>  .L.hs:108:1:
16:11:33 <lambdabot>      Data.Vector: Can't be safely imported!
16:11:33 <lambdabot>      The module itself isn't safe.
16:12:10 <skypers> I still wonder why I still try to use lambdabot where I have several sessions of ghci on my own machine
16:12:22 <skypers> when*
16:15:26 <mgsloan> tikhon: I think I remember seeing a paper where ocaml style module functors are converted to a newtype / typeclass.  Certainly, it's a bit more verbose and these "modules" can't contain typeclasses or instances
16:16:23 <mgsloan> Ahah, here it is! http://www.stefanwehr.de/publications/Wehr_ML_modules_and_Haskell_type_classes.pdf
16:16:38 <tikhon> mgsloan: I haven't seen the paper, but I know how to do it anyhow
16:16:41 <tikhon> it's pretty annoying
16:16:52 <mgsloan> Indeed
16:16:58 <tikhon> more importantly though, it doesn't really address some of the issues with typeclasses
16:17:42 <tikhon> at the same time though, it also means typeclasses aren't quite as limited as some ML programmers seem to believe  :)
16:17:46 <edwardk> skypers: i was testing a function to show someone that used lens indexed
16:18:14 <mgsloan> Yeah, I agree, there are major "issues".  After thinking about it for a while and writing up my "instance-templates" proposal, I decided that for now having abstractions atop the typeclass system is probably too many layers of abstraction :)
16:19:21 <tikhon> yeah
16:19:44 <tikhon> that's part of the problem: typeclasses are so ingrained as is, it'd be hard to change them significantly without heavily affecting Haskell
16:19:47 <skypers> edwardk: :)
16:19:50 <mgsloan> Not recommending reading the whole thing, but this section is kinda interesting: https://github.com/mgsloan/instance-templates#module-envy
16:19:56 <skypers> anyway, Vector won’t be imported
16:20:08 <skypers> so it doesn’t matter if it’d clash with indexed
16:20:12 <skypers> :t indexed
16:20:12 <lambdabot> Indexable i p => p a b -> i -> a -> b
16:20:18 <skypers> duh my goad.
16:20:20 <skypers> :D
16:20:45 <edwardk> indexed is used when defining your own indexed lenses/traversals
16:20:55 <edwardk> the idiom is straighforward once you see it
16:21:35 <tikhon> mgsloan: yeah, looks neat
16:21:55 <edwardk> instead of     foo f (a,b,c) = (,,) <$> f a <*> f b <*> f c     -- you'd use    foo f (a,b,c) = (,,) <$> indexed f "key 1" a <*> indexed f "key 2" b <*> indexed f "key 3" c -- or some such if those were the keys you wanted
16:22:55 <skypers> edwardk: so it’s a generalization of indexing stuff, right?
16:23:00 <skypers> like !!, ! and at
16:23:45 <edwardk> well, once you have an indexed traversal you can compose it with lots of combinators. in general in lens if foo does something with a lens, then ifoo does something with the indexed version and gives you access to the index.
16:23:57 <edwardk> e.g. the keys in the map you are traversing
16:24:03 <skypers> yep
16:24:05 <skypers> got it ;)
16:24:35 <skypers> do you have an equivalent for (!?) ?
16:24:38 <edwardk> indexed is used while writing the traversal,    index, indices let you apply predicates to filter based on the index
16:24:41 <ReinH> Ok, I've got an ByteString containing manually escaped unicode characters... like "Drac\\u014d" instead of "Dracō"
16:24:56 <ReinH> Easiest way to convert those into their unicode encoded equivalents?
16:24:57 <edwardk> :t (^@?!)
16:24:58 <lambdabot> s -> IndexedGetting i (Endo (i, a)) s a -> (i, a)
16:25:06 <edwardk> wait
16:25:06 <skypers> :–––––––’
16:25:07 <edwardk> :t (?!)
16:25:08 <lambdabot>     Not in scope: ?!
16:25:08 <lambdabot>     Perhaps you meant one of these:
16:25:08 <lambdabot>       $! (imported from Prelude), !! (imported from Data.List),
16:25:12 <skypers> (!?) :: Vector a -> Int -> Maybe a
16:25:15 <edwardk> i thought you meant for (^?!)
16:25:16 <edwardk> oh
16:25:25 <skypers> :t indexed
16:25:26 <lambdabot> Indexable i p => p a b -> i -> a -> b
16:25:26 <ReinH> or, to make it simpler, how can I go from "\\u014d" to "dex
16:25:29 <ReinH> er
16:25:32 <edwardk> yeah thats easy. just use ^?ix i
16:25:35 <lispy> Has the "cabal repl exits when you hit Ctrl-C" bug come back?
16:25:44 <skypers> “easy” :D
16:25:44 <edwardk> that one isn't using the index machinery i mentioned though
16:25:49 <ReinH> or, to make it simpler, how can I go from "\\u014d" to "ō"?
16:25:51 <lispy> It was fixed for a while, but my cabal is having that bug again
16:25:53 <edwardk> > "hello"^?ix 3
16:25:55 <lambdabot>  Just 'l'
16:25:57 <edwardk> > "hello"^?ix 10
16:25:58 <lambdabot>  Nothing
16:26:08 <skypers> wait wait wait
16:26:09 <edwardk> > "hello"^?traverse. Lens.index 3
16:26:11 <lambdabot>  Couldn't match type ‘Control.Lens.Internal.Indexed.Indexed
16:26:11 <lambdabot>                         i0 a (Control.Applicative.Const (Data.Monoid.First a)...
16:26:11 <lambdabot>                with ‘GHC.Types.Char
16:26:11 <lambdabot>                      -> Control.Applicative.Const (Data.Monoid.First a) GHC.T...
16:26:11 <lambdabot>  Expected type: (a
16:26:16 <edwardk> > "hello"^?traversed. Lens.index 3
16:26:18 <lambdabot>  Just 'l'
16:26:22 <skypers> :t (^?ix)
16:26:23 <lambdabot>     Couldn't match type m -> f m
16:26:23 <lambdabot>                   with Const (First a) (IxValue m -> f (IxValue m))
16:26:23 <lambdabot>     Expected type: Getting (First a) (IxValue m -> f (IxValue m)) a
16:26:30 <skypers> :t (ix))
16:26:30 <ReinH> generally it's "\\uXXXX" where XXXX is the hexidecimal unicode value
16:26:30 <lambdabot> parse error on input )
16:26:31 <skypers> :t (ix)
16:26:32 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
16:26:32 <edwardk> ^?    (ix 3)
16:26:34 <skypers> ok
16:26:59 <lispy> (I'm now making sure I have the latest version of Cabal and reinstalling cabal-install)
16:27:12 <edwardk> (^?) takes any fold, traversal, etc. and gives back a Just of the first result if it matches, or Nothing if it doesn't.
16:27:20 <skypers> yeah
16:27:29 <skypers> I know that ^stuff is for getter
16:27:36 <skypers> and suff~ is for setter
16:27:38 <shachaf> "Contravariant" meaning Getter/Fold is kind of confusing.
16:27:44 <skypers> might be the only thing I know from lens :D
16:27:45 <edwardk> ix n    is a traversal of some key n in some kind of container.
16:27:48 <lispy> ah, that fixed it.
16:27:51 <lispy> phew.
16:27:53 <skypers> I had fun using <>~
16:27:58 <skypers> because it looks like a…
16:28:00 <shachaf> I wonder whether it's worth it to have a type class for phantom phunctors, like we used to.
16:28:01 <skypers> you know… :D
16:28:04 <shachaf> (In some package other than lens.)
16:28:39 <glguy> shachaf: Rather than implying it with Functor and Contravariant?
16:28:50 <shachaf> Yes.
16:28:53 <edwardk> shachaf: i'd rather not go back to making up names. the benefit of the current approach is that it doesn't require spurious imports and ensures the widest possible compatibility profile
16:28:54 <orbital_> pjdelport: not trying to read too hard :) It was just odd after all the other "map as application inside a containing structure" explanations
16:29:03 <shachaf> I sometimes wish Haskell had a better mechanism for talking about variance.
16:29:27 <shachaf> When you get to Profunctor/Bifunctor you start needing so many classes to express everything you want.
16:29:53 <skypers> woh!
16:29:54 <shachaf> And then we start using hacks instead of defining new classes because having a lot of classes isn't fun.
16:29:58 <skypers> Vector is not in Default
16:30:03 <skypers> this is really surprising
16:30:12 <edwardk> skypers: that bit me today too
16:30:22 <c_wraith> it's a Monoid, though
16:30:31 <skypers> yeah
16:30:37 <shachaf> I hear languages with subtyping let you specify variance for things in all sorts of ways.
16:30:44 <skypers> I don’t need monoid here
16:30:49 <edwardk> c_wraith: the thing i was using it in needed the default constraint. rewrote around it
16:30:53 <skypers> I need a default value
16:30:57 <skypers> which is empty for Vector
16:31:06 <skypers> yeah
16:31:08 <skypers> what edwardk said
16:31:22 <skypers> the implementation is quite stupide :(
16:31:24 <skypers> def = empty
16:32:01 <skypers> hm btw
16:32:09 <skypers> data-default-instances-*
16:32:23 <skypers> aren’t that packages supposed to hold orphan instances?
16:32:52 <skypers> shouldn’t they be in their “hosting” package?
16:32:57 <edwardk> skypers: it is situations like that i point people to when they complain about the # of dependencies for lens ;) remember that for later when you're griping ;)
16:33:44 <dolio> Scala lets you specify variance. But lots of people argue against doing that because it all works out so poorly.
16:34:15 <tikhon> I haven't used much Scala, but variance seemed to work pretty well in OCaml
16:34:16 <edwardk> which is a terrible shame, because its the only point to using the language
16:34:16 <skypers> does lens have a lot of dependencies?
16:34:25 <skypers> edwardk: dep?
16:34:27 <edwardk> skypers: it has just enough
16:36:31 <shachaf> Constraints like (Profunctor p, Bifunctor p) to mean "p a b is contravariant in a and phantom in b" make me sad.
16:37:48 <dolio> I'm quite prepared to suggest that in Scala's case, it's due to the implementation quality and other design choices in the language.
16:37:52 <skypers> edwardk: so what do you think it’s the best? orphan instances, or some more deps?
16:38:09 <edwardk> i am very very strongly anti-orphan
16:38:21 <Eduard_Munteanu> Bleh, how do you safely close a Socket that may have been converted to a Handle?
16:38:22 <skypers> yeah
16:38:27 <tikhon> dolio: that's my impression, but I'm not a big fan of Scala. It feels like too much of a compromise.
16:38:31 <skypers> I can understand why
16:38:38 <edwardk> with limited exceptions for applications mostly
16:38:45 <skypers> and btw ghc whines with a warning about them
16:39:20 <tikhon> yeah, using orphan instances in a library can cause horrible problems for users of your package in the future
16:39:24 <edwardk> and for very static dependencies that will never be fixed, but in general, i believe if you don't own the type and you don't own the class you shouldn't be writing an instance for it, pay the newtype tax as the price of being able to use the third party thing
16:39:49 <Eduard_Munteanu> I'm thinking of doing socketToHandle myself and catching the exception if one is thrown, or perhaps 'close' and catching that.
16:41:37 <skypers> edwardk: :)
16:41:38 <skypers> sure
16:43:36 <jmcarthur> woohoo, ghc 7.8 hit arch linux today
16:43:49 <haasn> wait till 7.8.2!
16:44:09 <jmcarthur> all i am aware of that went wrong was some breakage in yesod packages, no?
16:44:21 <haasn> breakage in all packages involving type synonyms and TFs
16:44:26 <jmcarthur> (of course that's just how it was found out and probably broke more)
16:44:28 <jmcarthur> oh
16:44:31 <jmcarthur> that's no good
16:44:49 <haasn> specifically, type Foo a = ... Fam a ... where Fam is a TF does not get expanded
16:44:58 <jmcarthur> yuck!
16:45:27 <haasn> anyhow, if you update to 7.8.1 now you'll end up having to rebuild everything a second time for 7.8.2!
16:45:37 <haasn> It shouldn't be long, hopefully
16:45:48 <athan> what's new with 7.8.2?
16:45:48 <jmcarthur> hope not. my hopes were up already
16:45:52 <haasn> :)
16:45:56 <haasn> I know the feeling
16:45:56 <jmcarthur> athan: over 7.8.1? major bug fix
16:46:06 <athan> oh
16:46:16 <athan> ><
16:46:17 <haasn> Okay, if you're like me, you can update to 7.8.1 now and then to 7.8.2 a second time ;)
16:46:20 <jmcarthur> athan: over 7.6.*? much harder to explain
16:46:26 <athan> hahaha
16:46:29 <jmcarthur> haasn: i am indeed like you
16:46:53 <orzo> an OO interface can be done up in haskell as a monad transformer on IO where state is implicit in the monad.  Does doing that sort of thing without giving it a lot of thought have serious drawbacks?
16:47:00 <haasn> If you don't mind some trickery, depending on your environments, you could also build the 7.8.2 release snapshot from git
16:47:09 <skypers> oh god
16:47:10 <jmcarthur> orzo: i don't see how that's especially "OO"
16:47:15 <skypers> I planned to write the Default instance for vector
16:47:22 <skypers> and push a pull request
16:47:25 <orzo> what
16:47:25 <skypers> I’m writing the patch
16:47:38 <skypers> it’s actually a huge library :D
16:47:39 <orzo> i mean the interfacde is conceived of in OO terms and then implemented as haskell state monad
16:47:58 <orzo> its only OO becaues the programmer's habit of mind i guess
16:48:02 <jmcarthur> orzo: i think it's unwise to blindly do things you know are not exactly idiomatic haskell style
16:48:30 <jmcarthur> orzo: i find that unnecessary use of State leads to unnecessary state
16:48:35 <jmcarthur> :)
16:48:55 <orzo> well, the fact that the monad is state could be hidden
16:49:13 <jmcarthur> i don't know exactly what kind of abstraction you're going for then
16:49:14 <orzo> a stateless interface could implement monad as easily as a stateful one
16:49:26 <skypers> night
16:49:34 <jmcarthur> maybe you could explain what you're doing?
16:50:10 <orzo> what im doing is too straight forward
16:50:22 <orzo> it would interfere with waisting time or exploring
16:50:34 <orzo> heh
16:51:08 <orzo> my interface is used for updating state on the disk
16:51:22 <orzo> so its IO at some point
16:51:57 <orzo> but in practice i load it form the disk into a fairly pure structure and manipulate that and the write it back
16:52:49 <orzo> i was really just looking for OO -> haskell discussion
16:52:56 <jmcarthur> ah
16:53:12 <edwardk> skypers: the problem with a Default instance for Vector is lukas mai will probably want it out in a separate http://hackage.haskell.org/package/data-default-instances-dlist package providing the half dozen or so instances it needs.
16:53:24 <edwardk> er http://hackage.haskell.org/package/data-default-instances-dlist style
16:54:36 <jmcarthur> orzo: it's pretty straightforward to translate a lot of OO ideas into codata. model an object as a record where the methods are the fields of the record, and the private data is just captured in closures (not exposed as other fields)
16:55:13 <jmcarthur> orzo: so a method that "mutates" an object would just return a new record in this encoding
16:55:37 <thoughtpolice> edwardk: i have no idea what's up with the packaging for data-default, it feels terrible even using it
16:56:06 <edwardk> thoughtpolice: i'm slowly eradicating use of it from my projects, the cure it offers is worse than the disease in my eyes
16:56:29 <jmcarthur> orzo: that, being a nice, pure way of doing it, is probably my favorite way to translate a lot of concepts from OO to haskell
16:56:50 <edwardk> thoughtpolice: on the plus side, this NoOrphans thing solves its packaging problem too
16:57:01 <jmcarthur> orzo: there are other encodings involving real state or encouraging you to use some monad or something, but the nice thing about just using records is they don't require any of that
16:57:03 <thoughtpolice> edwardk: what's the NoOrphans thing, exactly?
16:57:09 * thoughtpolice must have missed something
16:58:21 <edwardk> thoughtpolice: something i've been going back and forth with goldfire about. make an extension "Orphans" for the current behavior, defaulted on, then when a module is compiled with NoOrphans make it so no class defined in that module can have orphan instances defined for it. in exchange OverlappingInstances for those classes become legal Safe haskell.
16:59:22 <jmcarthur> ooh, i like that tradeoff
16:59:31 <edwardk> thoughtpolice: now you can define {-# LANGUAGE NoOrphans, OverlappingInstances #-}  class Semigroup m where (<>) :: a -> a -> a  -- put in any new instances for base types, etc.     and add instance Monoid m => Semigroup m where (<>) = mappend     !!!!
16:59:37 <jmcarthur> gladly would sacrifice "convenient" the ability to make orphans for that
16:59:51 <jmcarthur> *the "convenient"
16:59:54 <edwardk> this gives a _safe_ way to get a default 'catch-all'
17:00:07 <Peaker> could be nice if you could say: "instance Class Data in Foo.Bar" (one of "Class" or "Data" may be unimported, but fully qualified. "Foo.Bar" is not in this package
17:00:28 <thoughtpolice> edwardk: ah, i see. interesting! sounds like it wouldn't be too difficult on the GHC side, either
17:00:35 <jmcarthur> would be nice to have much control over the scopes  at all :\
17:00:35 <Peaker> then Foo.Bar's instance is not an orphan and this package doesn't add a dependency!
17:00:41 <jmcarthur> *of various definitions
17:00:42 <edwardk> and then semigroups sheds almost all deps but base, data-default can do the same, semigroupoid classes like Apply and Bind become virtual superclasses of Monad for free, etc.
17:01:11 <Peaker> jmcarthur: that's a different ball game though...   orphans are currently the only good solution for package dependencies for instances -- we can bless that solution in a safe way
17:01:17 <edwardk> Peaker: i don't follow what that would mean
17:01:17 <tikhon> jmcarthur: I've thought it would be nice to have typeclasses that behave like modules that can be inferred most of the time
17:01:23 <tikhon> aren't some OCaml people working on that?
17:01:27 <tikhon> inferring modules, I mean
17:01:48 <Peaker> edwardk: if package   "foo"  does not want to depend on package "class" only to provide the instance.  So "foo-class" exists, but then "foo-class" necessarily defines an orphan instance
17:01:58 <jmcarthur> tikhon: i've had exactly the same idea (i think)
17:02:04 <Peaker> edwardk: the idea is that "foo" can bless "foo-class"s instance without depending on it
17:02:13 <jmcarthur> tikhon: no, i don't there there are any ongoing attempts for type class like things
17:02:14 <Peaker> edwardk: so that it isn't an orphan
17:02:17 <edwardk> Peaker: oh, what you are proposing is a lot like the mixin stuff i've pointed out something like backpack would need for sanity
17:02:34 <tikhon> hmm, I heard some talk about it, but can't remember the details
17:02:44 <jmcarthur> tikhon: at least, they would want to come up with cheaper ways to make types injective, etc.
17:02:47 <Peaker> edwardk: what the mixin stuff?
17:03:14 <Peaker> s/what/what's
17:04:02 <tikhon> I think that's also vaguely how Scala implicits work, but I haven't really used Scala so I can't say
17:04:21 <edwardk> Peaker: long story, painfully complicated, not energetic enough to go through it now. but ultimately if you kill orphans system-wide whch seems to be necessary for something lke backpack you need a way to say the lub of two packages isn't just the two packages, but also some kind of set of mixin instances. there are various ways to handle it, the best would require a lot of work in cabal, etc.
17:04:27 <jmcarthur> tikhon: roughly, my (and i think your) idea is to use type classes as signatures and instances as modules (with good scoping rules, etc.)
17:04:37 <tikhon> jmcarthur: yep
17:04:41 <edwardk> tikhon: scala implicits make me sad
17:05:03 <Peaker> edwardk: ah, but my suggestion is really simple all around, I think
17:05:05 <tikhon> edwardk: why? I've heard some bad things, but they seem more flexible than typeclasses in a lot of ways
17:05:14 <jmcarthur> not all good ways
17:05:21 <edwardk> tikhon: flexibility there comes at a HUGE price.
17:05:22 <Peaker> edwardk: it just needs to disallow all orphans except the blessed one, for the class-type pair
17:05:37 <Peaker> edwardk: and you get all the consistency guarantees and the fine-grained dependencies
17:05:52 <jmcarthur> tikhon: imagine (Map String) not having just one canonical Ord constraint on the String
17:06:04 <tikhon> jmcarthur: yeah, that's one worry
17:06:17 <tikhon> how does it work in OCaml with normal modules?
17:06:37 <jmcarthur> in Core we just store the comparator in the map itself
17:06:40 <tikhon> ah
17:06:42 <jmcarthur> and that's what they really should do in scala
17:06:47 <jmcarthur> but then you lose something else
17:06:49 <edwardk> if you can vary behavior based on the provenance of an instance you _always_ have to care about said provenance. this requires you to have a vocabulary for it. this means monad transformers cease to always do the right thing, means you have to bundle the Ord instance in the Set, have to give hedge unions for them... scalaz lives a carefully crafted lie where it pretends coherence properties that don't exist in scala's type system
17:06:49 <edwardk>  because of implicits
17:07:12 <tikhon> hmm
17:07:27 <tikhon> do you think there's a way to make typeclasses more scopable without giving up on all that?
17:07:32 <edwardk> tikhon: er have to give up hedge unions
17:07:35 <edwardk> i use reflection
17:07:36 <edwardk> done
17:07:37 <edwardk> solved
17:07:48 <tikhon> reflection?
17:07:55 <edwardk> @hackage reflection
17:07:55 <lambdabot> http://hackage.haskell.org/package/reflection
17:07:58 <tikhon> oh
17:07:59 <shachaf> That's the package I talked to you about that one time.
17:08:00 <tikhon> in Haskell
17:08:07 <tikhon> I thought you were still talking about Scala
17:08:08 <edwardk> yes, in scala you're screwed
17:08:33 <shachaf> edwardk: Are you still talking about type classes?
17:09:06 <edwardk> typeclasses vs. implicits was what i was asked about, so yes, but the statement about scala is parametric enough to cover many other features ;)
17:09:40 <mgsloan> "Blessed Orphans" is a great name for a language extension, I think we should do that
17:10:04 <haasn> -XNoAccursedOrphans
17:10:49 <edwardk> anyways, the NoOrphans thing is pretty straightforward. there are some extensions to the idea that could help with packages like categories, which can't use it directly with the simple implementation i just described
17:10:58 <gamegoblin> What’s the syntax for importing some functions from a module, and hiding some others?
17:11:09 <edwardk> gamegoblin: import Foo (x,y,z)
17:11:15 <tikhon> jmcarthur: It seems that the typeclass-as-module idea would also have coherence issues, wouldn't it?
17:11:43 <haasn> gamegoblin: there's no point in hiding some if you're selectively importing
17:11:51 <gamegoblin> Just realized that. I am an idiot.
17:12:01 <ktt3ja> I have a whole bunch of functions with signature `[String] -> (a, [String])` that take in a list of lines, read in some of them to construct `a`, and return `a` and the rest of the lines. But I keep having to call `(a, rest) = func input`. Is there a way I can avoid repeating `rest` and `input` so much?
17:12:06 <ktt3ja> example: http://pastebin.com/dnHHhVLx
17:12:22 <jmcarthur> tikhon: why?
17:12:32 <haasn> ktt3ja: sounds like the State monad could be a useful abstraction
17:12:42 <haasn> @unmtl State [String] a
17:12:42 <lambdabot> [String] -> (a, [String])
17:12:46 <edwardk> tikhon: typeclasses aren't modules, both are useful tools for organizing code, but neither subsumes the other when talking about a system written by multiple agents. its easy to make global decisions using modules, that are hard to make with typeclasses. its easy to get nicely overloaded syntax with typeclasses that are hard with the explicit vocabulary of modules
17:13:02 <tikhon> jmcarthur: well, if you can scope an Ord instance, couldn't you have two different ones with Map in different places?
17:13:12 <jmcarthur> tikhon: maybe we have different ideas after all
17:13:17 <tikhon> maybe
17:13:18 <haasn> ktt3ja: have you had a look at http://learnyouahaskell.com/for-a-few-monads-more#state yet?
17:13:30 <ktt3ja> haasn: no I have not
17:13:52 <haasn> you may wish to read that plus the chapters before it
17:14:01 <jmcarthur> tikhon: my idea is fairly conservative, really. just add the ability to write local definitions into an instance which are not "exposed" by the type class (the "signature")
17:14:15 <ktt3ja> haasn: k, thanks :)
17:14:37 <tikhon> oh, is that what you meant by "good scoping rules"?
17:14:51 <tikhon> I thought you meant scoping *for* instances
17:14:52 <jmcarthur> tikhon: gives you a kind of local modules feature, and you qualify the module via newtype wrappers (with all the downsides that implies)
17:15:05 <jmcarthur> tikhon: basically it just gives you local (and parameterized) module-ish things
17:15:35 <tikhon> hmm
17:16:41 <gtrambly> is there a cleaner way to express chains of boolean logic like this in Haskell?:
17:16:43 <gtrambly> http://screencloud.net/v/B3Pv
17:16:44 <jmcarthur> tikhon: it also adds value to nullary type classes!
17:17:07 <gtrambly> keeping in mind that the dates i refer to aren't actually fixed dates, but all vary wildly according to year and can sometimes apply to several days inconsistently
17:17:09 <haasn> gtrambly: guards
17:17:21 <gtrambly> hm!
17:17:28 <gtrambly> that's a good idea actually
17:17:29 <haasn> gtrambly: oh, in this case, you could just chain them all with (||)
17:17:37 <haasn> or use the ‘or’ function
17:17:39 <haasn> :t or
17:17:39 <lambdabot> [Bool] -> Bool
17:18:05 <gtrambly> ok thanks
17:18:43 <haasn> or [dateIsNewYearsDay d, dateIsChristmasDay d, d == goodFriday... ] -- with the list elements on separate lines
17:18:54 <haasn> You could go further by merging the (d == x || d== y || ...) cases
17:19:04 <haasn> d `elem` [x, y, z, ...]
17:19:17 <acowley> Is there any way to put a constraint on a function type returned by a type family?
17:19:22 <haasn> And since those are almost all functions of the form [f d, g d, h d, ...] you could use ‘any’
17:19:22 <acowley> I keep running into: Illegal polymorphic or qualified type:
17:19:27 <gtrambly> ah, that's a great idea too
17:19:27 <haasn> any ($d) [f, g, h, ...]
17:21:24 <jmcarthur> :o
17:21:33 <jmcarthur> I just learned that you can pass a URL to cabal-install.
17:21:37 <jmcarthur> That is amazing.
17:22:05 <jmcarthur> Link to tarball? Don't download and untar yourself. Just pass directly to cabal-install.
17:22:11 <tikhon> woah
17:22:22 * haasn .oO( down the rabbit hole: move goodFriday, newYears etc. to a record, use lenses for access+traversal )
17:22:34 <haasn> You could get this down to a handful of lines, with some of the logic moved out to helpers
17:22:35 <tikhon> the Go people always go on about how go get allows them to do that...
17:22:46 <jmcarthur> Go is different.
17:22:53 <tikhon> yeah, you have no choice
17:23:01 <acowley> jmcarthur: Can it take a repository?
17:23:01 <tikhon> and the URL is actually the full package name
17:23:03 <haasn> jmcarthur: how long until we get “cabal install https://github.com/ekmett/lens”? :)
17:23:04 <jmcarthur> You can specify the URL directly in a source file instead of just a module name.
17:23:10 <jmcarthur> in Go
17:23:16 <acowley> racket can take a repo URL, I believe
17:23:21 <acowley> well, raco
17:23:21 <tikhon> which is, umm, not the best idea, methinks
17:23:30 <jmcarthur> it doesn't download just because you build
17:23:32 <tikhon> but who needs versioned packages anyhow?
17:23:35 <jmcarthur> it's a separate step
17:23:47 <jmcarthur> it's a magical "get my dependencies" command
17:23:56 <edwardk> haasn: clearly the reference should be by tag
17:24:04 <jmcarthur> i imagine (but don't know for sure) that you can constrain it to stable versions etc. as well
17:24:16 <haasn> edwardk: tag, head or commit ID ;)
17:24:25 <tikhon> I think you have to do that by explicitly using a tag in your repo or something. I'm not sure exactly how it works, really.
17:25:31 <haasn> The only thing that confuses me: Doesn't that mean the distribution method is part of the namespace? What if Github goes down or the project gets moved to a newer and greater website or gets taken down for political reasons etc.?
17:26:02 <haasn> Would absolutely everybody worldwide have to update their files from “import github.com/ekmett/lens” to “import gitnexus.com/ekmett/lens” or whatever?
17:27:21 <edwardk> haasn: clearly what is needed is a canonical uri server ;)
17:27:52 <tikhon> yeah, I think they actually expect you to depend on the URI directly
17:27:56 <tikhon> ie, from their docs:
17:27:59 <tikhon> import "code.google.com/p/go.example/newmath"
17:28:36 <c_wraith> that's especially fun when the person updates code on their server.
17:35:29 <[swift]_> do i understand correctly that 7.8.2's release will happen very soon?
17:36:04 <intrados> [swift] That's what it looked like from the Trac
17:36:38 <[swift]_> sounds good. i guess i will just hold off on fixing code that triggers ghc bug 8978, then
17:37:34 <acowley> It's interesting when you have case a tuple rather than pattern match at the top level to get the necessary type equalities in scope
17:37:50 <acowley> I wish the type checker was smarter
17:41:07 <intrados> When would an MVar me better than a TMVar?
17:42:18 <c_wraith> intrados: when you want to lock.
17:42:25 <haasn> TMVar?
17:42:53 <haasn> oh, I see, STM version of MVar
17:43:25 <c_wraith> intrados: if you have 30 threads waiting on an MVar take, and something is put into it, 1 thread wakes up.  If you have 30 threads waiting on a TMVar take and something is put in, 30 threads wake up, thrash for a while, then 29 of them retry.
17:43:47 <quchen> STM also doesn't guarantee any fairness in general.
17:44:31 <c_wraith> intrados: under heavy contention, the difference is that the STM version grinds to a halt, as the time taken by transactions is proportional to the contention.  the non-STM version may back up a bunch, but it doesn't slow down.
17:53:41 <intrados> Hm, thanks.
17:53:50 <artyomkazak> How do I create a tarball after I've done `make`?
17:55:20 <intrados> artyomkazak: `tar -cvzf foo.tar foo/`?
17:55:35 <tadni_> So I'm assuming "Learn You A Haskell" is probably the best introductory text out there? I'm starting with very little background knowledge in-regards to programming.
17:57:16 <tsou> tadni_: check hutton's programming in haskell (too)
18:00:41 <artyomkazak> intrados: apparently it was `make binary-dist`
18:15:14 <petrie> Anyone doing the google code jam?
18:27:21 * hackagebot xml-lens 0.1.6 - Lenses, traversals, prisms for xml-conduit  http://hackage.haskell.org/package/xml-lens-0.1.6 (FumiakiKinoshita)
18:27:51 <artyomkazak> I made a build of GHC 7.8.2 (Linux, x86_64), if anybody is interested, it's here: http://files.artyom.me/ghc/
18:28:13 <srhb> artyomkazak: The gmp version is relevant too, is it not?
18:30:53 <artyomkazak> srhb: gmp 6.0.0a
18:32:22 * hackagebot xml-lens 0.1.6.1 - Lenses, traversals, prisms for xml-conduit  http://hackage.haskell.org/package/xml-lens-0.1.6.1 (FumiakiKinoshita)
19:02:49 <andkore> So I asked about this yesterday but no one answered, so I'm going to spam it again. Does anyone have experience doing CQRS/event sourcing in Haskell? There's a CQRS package on Hackage, but it doesn't look very complete or usable. Does anyone think CQRS/event sourcing is a bad idea?
19:03:40 <AncientPC> I don't understand why this is throwing an exception: map read $ words "1 2 3 4"
19:04:04 <andkore> To me event sourcing seems like it's fundamentally the correct way to work with data/databases. Which is why I've been a little surprised not to see more about it in the Haskell world.
19:04:17 <acowley> AncientPC: An exception?
19:04:48 <Axman6> AncientPC: have you told it what type you expect back?
19:04:57 <Axman6> > map read $ words "() () () ()"
19:04:59 <lambdabot>  [(),(),(),()]
19:05:09 <Axman6> > map read $ words "1 2 3 4" :: [Int]
19:05:10 <lambdabot>  [1,2,3,4]
19:05:13 <chrisw_> AncientPC, you have to fix the result type to [Int] or [Integer] or something
19:05:16 <Axman6> > map read $ words "1 2 3 4"
19:05:17 <lambdabot>  [*Exception: Prelude.read: no parse
19:05:36 <acowley> I don't think I appreciate how event sourcing is distinct from logging
19:05:36 <pordan30> or make the result type evident from context
19:06:11 <acowley> That's just defaulting getting you
19:06:15 <prophile> > sum $ map read $ words "1 2 3 4"
19:06:16 <lambdabot>  10
19:06:21 <Axman6> > map (read :: String -> Integer) $ words "1 2 3 4"
19:06:22 <lambdabot>  [1,2,3,4]
19:06:26 <pordan30> @pl \f g (a, b) -> f a . g b
19:06:26 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (.)) .)
19:06:33 <AncientPC> ahh thanks, didn't know how you had to specify type (or use it somewhere to infer type)
19:06:47 <andkore> acowley: I'm definitely not an expert in these matters, but I usually think of logging as supplementing a normal current state data model.
19:07:03 <prophile> pordan30: (***)
19:07:07 <andkore> In event sourcing, your current state only exists as the "calculation" of all the stored events
19:07:44 <Axman6> AncientPC: right, it's impossible to infer the result type from the textual input
19:07:59 <Axman6> so it defaults to the Read () instance
19:08:31 <acowley> andkore: In any case, I can't answer your question. I don't see why one would need much ceremony to do this.
19:09:06 <acowley> I'm sure scaling to big, high latency distributed systems makes it harder
19:09:52 <andkore> acowley: I want something like NCQRS. I don't view what it does as ceremony.
19:10:19 <aheller> andkore: is there a simple example of what you're interested in.  Fowler's page on cqrs is…. long.
19:11:20 <prophile> andkore: so it's an initial state and then a series of state deltas?
19:11:35 <prophile> what's the advantage?
19:11:43 <andkore> prophile: In a sense, but there's not even really an "initial state". Everything is just an event.
19:11:46 <acowley> andkore: The problem is that the notion of making descriptions of state change first class is like breathing in Haskell
19:12:00 <pordan30> prophile: something like \f g (a, b) -> (f *** g) (a, b) would have a type like (a -> b) -> (c -> d) -> (a, c) -> (b, d), right? i'm just not familiar enough with the arrow class to intuitively construct these pipelines :/ i'll play around with your suggestion, though
19:12:24 <aheller> acowley: but if you call it a free monad, you can get a blog post out of it.
19:12:27 <prophile> pordan30: no, I mean the value you put through @pl is precisely (***) for (->)
19:12:55 <prophile> so the point-free version of it is (***) :)
19:12:56 <acowley> aheller: Yes, and that blog post will be much more concise then the enterprise verbiage on cqrs
19:13:07 <pordan30> prophile: i see, that's pretty cool
19:13:14 <andkore> I think there are some huge benefits. For one, you get a complete history of your data.
19:13:15 <acowley> andkore: Have you tried sending a message to haskell-cafe?
19:13:21 <andkore> acowley: Nope
19:13:47 <acowley> andkore: I don't think anyone here would question the benefits
19:13:48 <prophile> andkore: it reminds me a little of operational transformations
19:14:23 <acowley> andkore: as aheller suggested, you can see this style of development suggested in all the free monad articles
19:14:30 <acowley> or as prophile said, in the operational package
19:14:53 <prophile> acowley: an interesting point, but that's actually not at all what I said :)
19:14:59 <andkore> acowley: OK, I'll look at that.
19:15:01 <prophile> I'm referring to http://en.wikipedia.org/wiki/Operational_transformation
19:15:17 <acowley> The reason I mentioned the mailing list is that there might be some folks who work at big corporations who have a similar specific need
19:15:34 <acowley> i.e. to interoperate with a Java or .NET system that works in this fashion
19:16:13 <andkore> http://vimeo.com/28457510 <-- not perfect, and quite long, but gives you a pretty good idea of what event sourcing is and the potential benefits
19:16:14 <acowley> prophile: Oh, whoops! But you're right, they are related!
19:16:59 <leroux> Hi. Is there anyone here that has experience with using ajhc for FFI? And is there a better haskell channel to lurk on for help regarding it?
19:17:21 <leroux> I'm currently wrapping an embedded library that uses ChibiOS.
19:18:32 <andkore> I appreciate the fact that this idea can be expressed with stuff like free monads, but that by itself isn't going to help anyone get an event sourcing system set up. I think a library is really what's needed.
19:19:36 <andkore> At some point you need to actually communicate with databases
19:19:48 <aheller> andkore: I wasn't really saying that free monads subsume the problem.  But I'm not sure what the library would actually do.
19:22:17 <aheller> it seems like what's going on in the video is that they store a trace of UI actions, and then eval them.
19:22:56 <andkore> aheller: That's basically the idea of event sourcing, yes. You might want to skip ahead to the point when he actually breaks out some code.
19:23:13 <aheller> time offset?
19:23:30 <andkore> 51:00 ish
19:30:08 <aheller> what am I looking for here?
19:32:54 <andkore> aheller: haha, maybe the stuff before he got to the code was better. Sorry if it was a waste of your time. Do you work with databases a lot?
19:33:03 <aheller> A bit.
19:33:29 <aheller> All this stuff he's explaining seems a bit convoluted.
19:34:00 <zzo38> Would it common a use of continuation monads something like, you have:   data InOut = In (Char -> InOut) | Out Char InOut | Stop; input = cont In; stop = cont $ const Stop;    and so on. ?
19:34:06 <andkore> How do you record changes to your data? Just update rows?
19:35:34 <aheller> Depends on the situation.  I'll do things log-structured if I care at all about auditability.  If it's all silly crud, probably just the update.
19:35:52 <bitemyapp> anybody recommend a good format to generating PDFs such as for cheat-sheets?
19:35:57 <acowley> The answer to every question tonight is free monads.
19:36:02 <acowley> zzo38: Take a look at machines
19:36:22 <acowley> zzo38: You can see how it uses a CPS of the usual free monad approach in the Plan type
19:36:29 <tikhon> bitemyapp: there are probably some LaTeX templates around; I remember using one for math classes
19:36:46 <bitemyapp> tikhon: was trying to avoid that :)
19:36:51 <bitemyapp> tikhon: thanks though.
19:36:55 <tikhon> http://tex.stackexchange.com/questions/8827/preparing-cheat-sheets
19:36:59 <tikhon> but LaTeX is fun!
19:37:14 <acowley> LaTeX is awesome
19:37:16 <bitemyapp> tikhon: I don't write LaTeX often enough for it not to be error prone.
19:37:17 <tikhon> You could also use it as an excuse to try HaTeX, which I still haven't
19:37:19 <tikhon> http://hackage.haskell.org/package/HaTeX
19:37:26 <acowley> You could use a HaTeX!
19:37:27 <acowley> oh
19:37:28 <bitemyapp> okay, that's intriguing.
19:37:29 <tikhon> it's a nice Haskell DSL for doing LaTeX
19:37:30 <acowley> darn I'm slow
19:37:38 <bitemyapp> yeah, that's interesting to me.
19:37:41 <andkore> aheller: How do you run through the history to get to current state if you're doing things log-structured?
19:37:45 <bitemyapp> if I can at least get help from the compiler :)
19:37:48 <tikhon> acowley: like minds think alike ;)
19:38:03 <bitemyapp> s/] like/\ great/g
19:38:06 <tikhon> help from the compiler and *abstraction that doesn't suck*
19:38:06 <acowley> likely
19:38:12 <bitemyapp> tikhon: right!
19:38:29 <bitemyapp> but, with that in mind, are there any alternative suggestions that aren't TeX?
19:38:33 <tikhon> I think abstraction is the single most important thing, which is why I'm generally a major proponent of DSLs like this
19:38:38 <andkore> The idea of CQRS is that you have a read store that can reflect current state. So you don't have to manually recreate current state directly from the event store.
19:38:41 <acowley> I've not tried HaTeX either
19:38:49 <tikhon> no idea: I've literally never made a PDF with anything but TeX
19:38:53 <acowley> bitemyapp: I honestly assumed you would use LaTeX for this before anyone even mentioned it
19:38:54 <bitemyapp> andkore: I think just having an append log of events is cleaner and easier than CQRS
19:38:57 <acowley> haha
19:39:04 <bitemyapp> andkore: CQRS also ignores the reality of read/write atomic transactions.
19:39:04 <acowley> Okay, tikhon can speak for me tonight
19:39:08 <acowley> I am redundant
19:39:16 <zzo38> I myself don't like LaTeX and I use Plain TeX.
19:39:17 <bitemyapp> acowley: I've used LaTeX plenty before, I just don't *enjoy* it.
19:39:22 <andkore> bitemyapp: I don't know what an append log of events means.
19:39:53 <aheller> andkore: ad hoc-edly, usually. If the db schema is going to be any use at all, the table usually has structure I need to know about.
19:39:57 <zzo38> But I have written a Haskell library to generate DVI files directly; no need for TeX, LaTeX, PDF, PostScript, etc
19:40:26 <aheller> andkore: I think he means "when an event happens, add it to the end of the list of events"
19:40:32 <zzo38> acowley: O, what does "a CPS of the usual free monad approach" mean?
19:41:09 <andkore> aheller: In the video, he has a read store with all the normal structure tables have, but he doesn't have to access current state in an ad hoc way.
19:41:18 <bitemyapp> zzo38: I don't think I'm going to do that.
19:41:50 <acowley> zzo38: I think looking at the types will explain it better than I will here and now.
19:41:55 <aheller> andkore: it's a long video :).  What's the schema for the tables storing the events?
19:42:45 <acowley> zzo38: This is what I'm referring to, btw: http://hackage.haskell.org/package/machines-0.2.5/docs/Data-Machine-Plan.html
19:42:46 <bitemyapp> I should just use pandoc.
19:42:56 <bitemyapp> pandoc can generate PDFs right?
19:43:07 <aheller> via latex
19:43:09 <bitemyapp> aaarrrrgh
19:43:11 <bitemyapp> just saw that
19:43:20 <andkore> aheller: That's the thing. Only one table stores events.
19:43:25 <aheller> you could write an xsl-fo backend
19:43:48 <aheller> andkore: right, but what do events look like?
19:44:12 <andkore> I think it stores a timestamp, a command name, source ID, and then the actual event data.
19:44:26 <bitemyapp> Why do I want to generate a PDF? Fuck this, I'll generate HTML.
19:44:32 <andkore> I'll find the point in the video where he shows that
19:44:38 <aheller> "actual event data" sounds a bit sketchy to me.
19:44:46 <zzo38> There is a Haskell library to generate PDF directly though; maybe it should use that. There is also a Haskell library to generate DVI; you should add that into pandoc too.
19:45:03 <andkore> 55:50
19:45:14 <bitemyapp> zzo38: nah./
19:45:20 <bitemyapp> HTML.
19:46:04 <zzo38> OK use HTML.
19:46:14 <zzo38> But, I want DVI.
19:48:20 <aheller> andkore: he's using json.  so effectively, he's got a bunch of different types of events.  He keeps a list of them.  When he wants to find out something, he reads them, evaluating the events on some ephemeral representation of the state, and then says "haha! event sourcing"
19:48:50 <andkore> aheller: I think it's brilliant...
19:49:06 <aheller> andkore: It's not a horrible idea.  It's just an interpreter though.
19:49:15 <acowley> andkore: You'll love Haskell!
19:49:32 <andkore> acowley: ? I don't follow
19:49:37 <AncientP1> I'm trying to find the intersection of two sets but I don't understand the compiler error: http://lpaste.net/8884406736748806144
19:49:56 <acowley> andkore: This is a very natural thing to do in Haskell
19:50:13 <aheller> andkore: because instead of having a scary framework for evaluating all the state, you'll just say: currentState = fold events
19:50:24 <aheller> and it will all magically work :)
19:50:29 <tikhon> AncientP: You're using <- for something that *isn't* in IO
19:51:20 <tikhon> use let set = ... instead
19:51:54 <AncientP1> tikhon: ahh ok, thx
19:51:56 <andkore> acowley: Ah. Yeah I think there's some affinity between functional programming and event sourcing.
19:52:05 <tikhon> the other problem is that row1 and row2 are strings, not numbers
19:52:36 <andkore> aheller: Hmm, OK. So you don't think I need to find/build a library for this.
19:52:40 <acowley> andkore: It's what aheller said and that languages like Haskell make creating new data types a very simple affair
19:52:44 <tikhon> AncientP: you can just use read on them, but there's actually a standard function called readLn which combines getLine and read
19:52:59 <tikhon> the fact that it isn't called readLine is just absurd though
19:53:07 <acowley> andkore: Which is why interpreters are such a good fit
19:53:19 <andkore> I don't really know what an "interpreter" is in this context
19:55:05 <shachaf> readLn isn't quite fmap read getLine
19:55:17 <shachaf> It gives you IO exceptions rather than _|_
19:55:19 <acowley> andkore: I have to run now, but I trust there are many folks here who can answer that quite well!
19:55:29 <andkore> acowley: Thanks for the help!
19:55:34 <tikhon> shachaf: ah, didn't know that
19:55:39 <andkore> aheller: Thank you very much too
19:55:41 <acowley> np!
19:55:41 <aheller> andkore: I think the essence of what you're interested in is representing the changes to your data model as a series of commands.  The hard part is deciding what the commands should be, and how they should be understood.  Representing those commands as json and shoving them into a database table is an implementation detail, in some sense.
19:57:42 <andkore> aheller: Hmm, yeah. I guess this will be my Haskell baptism by fire.
19:57:52 <aheller> andkore: what I mean by "interpreter" here is that each command is like a statement in a(n extremely) domain specific language.  finding the current state means interpreting those statements just like it were a program.
19:58:16 <andkore> Ah.
19:58:32 <aheller> andkore: flaming baptismal fonts are always fun.
19:59:00 <andkore> It just seems to me that there's a good amount here that could be factored into a reusable library.
19:59:05 <aheller> andkore: the simple example of the same idea would be event sourcing a calculator.
20:06:45 <meretrix> If maintaining precision of fractional numbers is important in my application, but I'm only doing very simple operations (reading from string, writing to string, averaging two numbers and rounding, etc.) on numbers with a mantissa of 4-6, is there any reason to prefer Decimal over Double?
20:07:02 <tikhon> you could use Rational
20:07:52 <tikhon> given my understanding of Decimal, I think the only advantage would be that it can represent the numbers you write directly
20:07:58 <c_wraith> meretrix: as simple of a number as 0.1 can't be represented exactly by a Double
20:08:12 <tikhon> > 0.1 + 0.2 + 0.3
20:08:13 <lambdabot>  0.6000000000000001
20:08:20 <tikhon> > (0.1 + 0.2) + 0.3
20:08:21 <lambdabot>  0.6000000000000001
20:08:22 <c_wraith> meretrix: so if you *really* want to be accurate, don't use Double
20:08:29 <tikhon> > 0.1 + (0.2 + 0.3)
20:08:30 <lambdabot>  0.6
20:08:42 <meretrix> Right, but I'll always be rounding my output to a mantissa of 4-6.
20:09:10 <tikhon> do you really need much performance?
20:09:17 <tikhon> because that's the most compelling reason to use Double
20:10:02 <meretrix> Probably not, but anything that lowers the latency will help.
20:11:08 <meretrix> If I always round with something like "1e-6 * floor $ 0.5 + 1e6 * x", I think I should be fine.
20:13:21 <pyon> In GHC 7.8.1, is it possible to give an explicit type signature with holes? Or do holes only work at the value level?
20:14:37 <roconnor> > 0.1 + 0.2 + 0.3 :: Fixed E6
20:14:38 <lambdabot>  Ambiguous occurrence ‘Fixed’
20:14:38 <lambdabot>  It could refer to either ‘Data.Fixed.Fixed’,
20:14:38 <lambdabot>                           imported from ‘Data.Fixed’ at L.hs:74:1-17
20:14:38 <lambdabot>                        or ‘Test.QuickCheck.Modifiers.Fixed’,
20:14:38 <lambdabot>                           imported from ‘Lambdabot.Plugin.Haskell.Eval.Truste...
20:14:47 <roconnor> > 0.1 + 0.2 + 0.3 :: Data.Fixed.Fixed Data.Fixed.E6
20:14:49 <lambdabot>  can't find file: L.hs
20:28:12 <pyon> Is there any way to do a "type-level let"?
20:28:43 <pyon> I have type signatures that would be significantly shortened using a type-level let.
20:29:06 <aheller> pyon: there's always "type".
20:29:07 <tikhon> could you just use type?
20:29:56 <tikhon> do you have a specific example of a type signature like that?
20:29:58 <pyon> It is like "type Foo a b c d = ... (Bar a b) ... (Bar a b) ... (Bar a b) ..."
20:30:11 <tikhon> ah
20:30:28 <tikhon> hmm
20:30:41 <monochrom> that's too bad.
20:30:48 <tikhon> I wonder if you could hack something together using type equality?
20:31:32 <aheller> type Foo' ab c d = … ab … ab … ab …
20:31:47 <aheller> type Foo a b c d = Foo' (Bar a b) c d
20:32:24 <pyon> Ah!
20:32:33 <pyon> Thanks!
20:32:40 <aheller> :)
20:47:01 <jle`> pyon: what about those typenats
20:47:08 <jle`> oh type level let
20:47:11 <jle`> i thought yousa d type level int
20:47:22 <jle`> oh yeah i definitely have always wanted a type level let
20:47:24 <jle`> :/
20:47:29 <jle`> butre is a trick
20:47:42 <jle`> there's a trick that i think edwardk did on a reddit thread?
20:47:51 <pyon> :-O
20:48:28 <edwardk> use a type equality. a ~ Big Long Type => a -> a
20:48:33 <jle`> oh hi
20:50:21 <AncientPC> Is there list / tuple unpacking like: let a, b, c = [1, 2, 3]?
20:50:36 <joelteon> let [a,b,c] = [1,2,3]
20:50:40 <joelteon> let (a,b,c) = (1,2,3)
20:50:42 <joelteon> pattern matching
20:51:09 <AncientPC> ahh that's right, thx joelteon
20:51:22 <jle`> be sure to handle the other cases
20:51:32 <jle`> or accept that your function is partial
20:51:33 <joelteon> yeah, the compiler will warn you :)
20:51:39 <joelteon> love the compiler
20:53:13 <flamingspinach> question about using the state monad: http://lpaste.net/102589
20:54:06 <jle`> flamingspinach: do you know what the state monad is?
20:54:10 <jle`> (what the newtype wrapper wraps)
20:56:31 <flamingspinach> jle`: nope
20:56:42 <jle`> flamingspinach: ah
20:56:58 <jle`> you can think of State as a newtype wrapper over a function s -> (a, s)
20:57:11 <jle`> so you can imagine (>>), i'm sure
20:57:28 <jle`> you take an s -> (a, s)
20:57:33 <jle`> and an s -> (b, s)
20:57:48 <jle`> can you imagine how you would sequence them?
20:57:52 <jle`> do one, then the next?
21:00:01 <flamingspinach> hmm. Well, a trivial way to satisfy the type I would want out of (>>) would be to take an s, pass it to the first thing, get out an (a, s), throw away the a, pass the new s to the second thing
21:01:34 <flamingspinach> I guess I don't understand what the s, a, and b represent, exactly...
21:01:52 <jle`> oh yeah
21:01:58 <jle`> s represents your state
21:02:03 <jle`> s -> (a, s) represents a computation
21:02:03 <flamingspinach> a function s -> (a, s) is something that starts with some state, produces an a out of nowhere and a modified state, I guess
21:02:05 <jle`> that takes a state
21:02:12 <jle`> returns an output (a), and a modified state s
21:02:42 <jle`> so if we say (s -> (a,s)) sequenced with (s -> (b,s)), we say, sequence these two state-transformers-with-results
21:02:50 <jle`> do the first, then the second
21:02:59 <jle`> and we return a new s -> (b, s)
21:03:05 <flamingspinach> hm, so I guess that really is the right way to satisfy the type of (>>), odd as it seems to throw away the a
21:03:29 <jle`> yeah, but that's like monads :) (>>) throws away the result
21:03:49 <flamingspinach> derp, yes of course haha
21:03:57 <jle`> if we take an s -> (a,s), and an s -> (b, s)
21:04:02 <jle`> we can >> them and return a new s -> (b,s)
21:04:05 <flamingspinach> sorry, as you can see I'm still not very fluent with monads :)
21:04:12 <jle`> no worries, it's a bit disorienting at first :)
21:04:35 <jle`> now that new s -> (b,s)...it'll take a state, feed it into the first function, get that resulting state, feed it into the second function, and return the (b,s) at the end
21:04:57 <flamingspinach> yup, I think I see now
21:05:01 <jle`> if you know about monoids
21:05:09 <jle`> it's "sort of like" a monoid over s -> (a, s)'s
21:05:17 <jle`> you can take two and combine them into a giant s -> (b,s)
21:05:26 <jle`> (it's not really a monoid but humor me)
21:05:33 <jle`> so, we can say
21:05:40 <flamingspinach> I do not know about monoids, other than the meaning in abstract algebra
21:05:47 <jle`> (>>) :: (s -> (a,s)) -> (s -> (b,s)) -> (s -> (b,s))
21:05:51 <jle`> right?
21:05:54 <flamingspinach> yup
21:06:01 <jle`> oh, monoids are things that have a combining (<>) :: a -> a -> a
21:06:12 <jle`> take two alike things, make a new thing of the same type
21:06:17 <jle`> (with some laws of course)
21:06:24 <prophile> laws like gravity
21:06:26 <jle`> so here, we take two s -> (a,s)'s, and return a new s -> (a,s), sorta
21:06:29 <flamingspinach> similar to the laws of a monoid in abstract algebra I imagine :)
21:06:36 <jle`> yup
21:06:49 <jle`> the main thing to realize is that we are building up a giant s -> (a, s)
21:06:55 <jle`> from small s -> (a, s)'s
21:07:02 <bitemyapp> flamingspinach: yeah. Haskell is one of the proglang communities that realized the building material of programming is math :)
21:07:09 <jle`> okay, now
21:07:13 <bitemyapp> fortunately, it's fairly straight-forward math. high-school stuff.
21:07:18 <jle`> let's say we want to keep the a
21:07:41 <flamingspinach> I think I see what needs to happen now. My s needs to be a product type, and then I need to define push2 and pop1 (as in my example) as... functions that accept a value and return a monadic *value*
21:07:43 <jle`> there are a few ways to arrive at the conclusion
21:07:50 <flamingspinach> which is a state transforming function that acts on one coordinate of the product type s
21:08:02 <jle`> but you have (>>=) :: m a -> (a -> m b) -> m b
21:08:36 <jle`> so in our language, ti'd be (>>=) :: (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b,s))
21:08:51 <jle`> we combine a state transformer, a function that returns a state transformer, into a new state transformer
21:09:49 <jle`> so i your case, let's call your state PushPop, a tuple possibly, or some product type
21:09:50 <flamingspinach> yup, so I guess the way to define (>>=) would be, have a function f :: s -> (a, s) and a function g :: a -> s -> (b, s), and a state s, and I want to produce a (b, s), so I run f on my s and get an (a, s), then I pass the a into g to get a thing that will accept the s I now have, which I give it, and now I have a (b, s), which I return
21:09:58 <jle`> ^^ yup
21:10:04 <jle`> in your case, you specialise s to PushPop
21:10:07 <flamingspinach> great :)
21:10:18 <jle`> so your state transformers would be PushPop -> (a, PushPop)
21:10:44 <jle`> if you use Control.Monad.Trans.State, from transformers package
21:10:55 <jle`> then you use the "constructor"
21:11:10 <jle`> to wrap your function into the wrapper type, where the monad instance is defined
21:11:30 <jle`> because we can't define a monad instance on s -> (a, s), directly
21:11:42 <jle`> for a few reasons
21:12:07 <flamingspinach> hmm
21:12:25 <jle`> the "constructor" (in quotes, because it's sort of a fake constructor) is state
21:12:32 <jle`> state :: (s -> (a, s)) -> State s a
21:12:40 * hackagebot pipes-extras 1.0.0 - Extra utilities for pipes  http://hackage.haskell.org/package/pipes-extras-1.0.0 (GabrielGonzalez)
21:12:43 <athan> Hey, does anyone know of any good data store api's like persistent, but maybe without the TH?
21:12:46 <jle`> but for most intents and purposes it can be called a constructor
21:12:54 <jle`> like a newtype wrapper
21:13:06 <athan> hola everyone
21:13:14 <jle`> and you can imagine newtype State s a = State (s -> (a, s))
21:13:22 <jle`> the actual implementation is a little different but
21:13:55 <flamingspinach> I guess there's probably a bunch of further abstraction somewhere in a library that causes this complexity?
21:14:08 <jle`> it's actually not necessary
21:14:10 <jle`> and you can do it yourself
21:14:13 <jle`> the normal way
21:14:19 <flamingspinach> well, it's good to use the standard library :)
21:14:26 <jle`> the main reason is because tansformers actually uses a StateT
21:14:28 <jle`> monad transformer
21:14:36 <jle`> if oyu know anything about monad transformers
21:14:46 <jle`> and StateT ==== State, if the transformed monad is Identity
21:15:00 <jle`> but you don't need to know that :)
21:15:08 <jle`> for now, you can just write your state transforming functions
21:15:14 <Hafydd> That's some intense equality.
21:15:14 <jle`> use state to wrap them in State s a
21:15:23 <jle`> yes it is quadruple equality
21:15:56 <jle`> one equals sign for all of the elements
21:16:42 <jle`> so if you wrap them in State s a using the 'state' function, you can sequence them in a do block
21:16:51 <jle`> and also use all of the monad combinators in Control.Monad
21:16:53 <jle`> etc.
21:17:13 <jle`> and they will be sequenced using the sensible semantics we desfined earlier
21:17:36 <jle`> the only thing is...remember, at the end, you build up a giant s -> (a, s)
21:17:51 <flamingspinach> so now I know how to create monadic values like the push2 and pop1 I wanted, but do I need to use fake constructors to deal with the rest of the function I'm trying to write? (I guess I'll find out)
21:17:52 <jle`> so when all is said and done, you actually have to 'run' it, provide the s, and it'll crunch through everything
21:18:10 <flamingspinach> ah, right. "runState" is described on the haskell wiki page about the state monad.
21:18:14 <jle`> yeah
21:18:21 <jle`> runState takes a State s a
21:18:28 <jle`> and unwraps it
21:18:40 <jle`> back into an s -> (a, s)
21:18:54 <jle`> it's the inverse of 'state'
21:19:12 <jle`> which takes an s -> (a, s) and wraps it in a State s a
21:20:01 <jle`> it's mostly to handle the annoying newtype wrapper stuff
21:20:09 <jle`> but cest la vie
21:20:09 <zcd> how convenient i was just aobut to ask about the state monad
21:20:14 <zcd> thanks
21:20:15 <flamingspinach> oh, that's a cool way to look at it
21:20:45 <flamingspinach> I was thinking of it as a function that takes a State s a and an s and runs the computation, but it seems more natural to think about it partially applied as you did :)
21:20:49 <jle`> it's actually how it more or less literally is
21:20:56 <jle`> back in the old days
21:21:25 <jle`> newtype State s a = State { runState :: s -> (a, s) }
21:21:31 <jle`> things were simpler back then
21:25:02 <dmj`> /msg jle` you ever used acid-state?
21:25:03 <dmj`>  
21:25:10 <dmj`> sorry :)
21:25:26 <Fuuzetsu> now we all know about your secret acid-state gossip
21:25:58 <flamingspinach> thanks for your help jle` :) I'll see if I can make this work with what I've learned.
21:25:58 <dmj`> the shame
21:26:06 <dmj`> :P
21:26:35 <srhb> mmm, acid-state. So acidic.
21:26:47 <bitemyapp> I prefer basic libraries.
21:27:00 <dmj`> all I was going to say is that I think people who use acid-state should be calling seq or deepseq more often when performing updates, there I said it
21:27:03 <srhb> bitemyapp: pH-ist.
21:27:17 <srhb> dmj`: >:/
21:27:25 <prophile> scandalous
21:27:33 <dmj`> srhb: I profiled acid-state w/ ekg and it's pretty revealing
21:27:40 <dmj`> "profiled"
21:27:46 <prophile> stern letters to the editor of the monad.reader will be written
21:27:53 <jle`> flamingspinach: the transformers library actually offers some useful "primitives"
21:28:01 <athan> is there an easy way to log TH outputs?
21:28:06 <jle`> flamingspinach: that might be of use to you
21:28:12 <srhb> --ddump-splices?
21:28:17 <srhb> Or something to that extent
21:28:18 <bitemyapp> srhb: god dammit
21:28:20 <bitemyapp> yes, that's it.
21:28:24 <bitemyapp> beaten to the punch
21:28:26 <srhb> :-)
21:28:34 <jle`> flamingspinach: there is "get = state (\st -> (st, st))"
21:28:34 <srhb> athan: That was for you
21:29:01 <jle`> flamingspinach: there is "put x = state (\_ -> ((), st)"
21:29:20 <zcd> jle`: piggybacking along, is the intuition that the state monad is a wrapper for state transitions correct?
21:29:20 <jle`> flamingspinach: there is "modify f = state (\st -> ((), f st))"
21:29:38 <flamingspinach> now that I'm writing my push and pop functions, they look kind of horrible...
21:29:38 <flamingspinach> push a = state $ \ (xs, ys) -> ((), (xs, a : ys))
21:29:38 <flamingspinach> pop = state $ \ (x : xs, ys) -> (x, (xs, ys))
21:29:40 <jle`> flamingspinach: using these three, you rarely have to write your own state transformers
21:29:47 <flamingspinach> I guess those things are exactly what I need to make them look pretty :)
21:30:00 <jle`> using those three and "sequencing them" with >>, etc.
21:30:07 <jle`> but rolling your own is a nice way to learn
21:30:18 <jle`> and also they are possibly more performant :)
21:30:36 <jle`> modify can also be defined as modify f = put . f =<< get
21:30:41 <jle`> for funsies
21:30:51 <athan> srhb: Sorry, phone. Hmm, I'll try it. I think I tried piping it to a file a while ago and it didn't work. But i think this was a long while, so idk.
21:30:53 <athan> thanks
21:31:02 <athan> bitemyapp: Haha.
21:31:11 <srhb> What on earth..
21:31:22 <jle`> zcd: the state monad (the non-transformer version) can be implemented as literally a newtype wrapper for s -> (a, s)
21:31:32 <srhb> "The function unless' is applied to two arguments, but its type ... has only three"
21:31:38 <srhb> o_o
21:31:55 <bitemyapp> existential quantification or force my user to scaffold up sum types?
21:32:04 <zcd> that's the definition that lyah is using
21:32:29 <zcd> i'm trying to wrap my head around it; it's not actually holding onto a state but a transition between states?
21:32:50 <Fuuzetsu> yes
21:33:06 <jle`> zcd: consider f :: s -> (a, s)
21:33:06 <Fuuzetsu> once it's ran with the initial state, it simply executes the transitions
21:33:10 <jle`> and g :: s -> (b, s)
21:33:22 <jle`> can you imagine composing them into one "giant" s -> (b, s) ?
21:33:27 <dmj`> > flip execState 5 $ modify (+1)
21:33:28 <lambdabot>  6
21:33:31 <jle`> i mentioned earlier that the whole thing is "monoid-like"
21:33:41 <jle`> where monoids combine two a's to get a "big" a
21:33:49 <zcd> yeah i was skimming through the above conversation
21:33:50 <jle`> for State, you combine two s -> (a, s)'s to get a "big" s -> (a, s)
21:34:10 <jle`> for all intents and purposes, State s a is a type synonym for (s -> (a, s))
21:34:26 <jle`> except for tricky implementation details
21:34:43 <srhb> Should I be able to get that error at all?
21:36:08 <zcd> so the mappend deal with f,g is for the (>>) operation or do notation?
21:36:12 <jle`> (>>) and (>>=) does exactly what you would expect; the only thing to remember is that in the end the result is always an (s -> (a, s))
21:36:37 <jle`> the monoid-like-ness is (>>) for the binary operator, but it's a loose analogy
21:36:45 <jle`> it is a bit apparent form the type siganture of (>>)
21:36:50 <jle`> (>>) :: m a -> m b -> m b
21:37:37 <jle`> which is "kind of like" mappend :: b -> b -> b if you squint hard enough
21:37:59 <bitemyapp> I can't squint that hard.
21:38:05 <bitemyapp> a is not necessarily b >:)
21:38:14 <aheller> but it can be.
21:38:28 <jle`> squint harder
21:38:35 <jle`> the first lesson of haskell: you can always squint harder
21:38:56 <srhb> Now it looks like a specialization of id
21:38:57 <srhb> :)
21:39:06 <aheller> jle`: if you squint hard enough at >>, it might start looking like <>
21:39:11 <srhb> Maybe I should squint less.
21:39:12 <bitemyapp> :t (<>)
21:39:13 <lambdabot> Monoid m => m -> m -> m
21:39:17 <bitemyapp> welp.
21:39:29 <tikhon> are you talking about how monads are like monoids?
21:40:10 <jle`> well, (>>) is technically more in the domain of applicatives
21:40:22 <tikhon> I think >> is the wrong place to look: the "monoidal" operation is actually join.
21:40:23 <bitemyapp> :t (*>)
21:40:24 <lambdabot> Applicative f => f a -> f b -> f b
21:40:27 <flamingspinach> pop = get >>= return . head . fst
21:40:27 <flamingspinach> hahah!
21:40:34 <bitemyapp> tikhon: that's what I was thing.
21:40:36 <bitemyapp> thinking*
21:40:48 <flamingspinach> do I need the "return" in there, or is there a different combinator I could use to get rid of it?
21:40:56 <jle`> tikhon: that's a monoid over the functorness at the type level
21:41:01 <jle`> but there are "horizontal" monoids too
21:41:05 <jle`> like <|>
21:41:11 <jle`> flamingspinach: um
21:41:20 <bitemyapp> :t return
21:41:21 <jle`> well, if you use (>>=) and (.) together
21:41:21 <lambdabot> Monad m => a -> m a
21:41:28 <tikhon> >>= return is like fmap, generally
21:41:28 <ruzu> |>
21:41:35 <srhb> How is this possible: ... bar <- get foo; unless bar baz -- works, but: ... unless' (get foo) baz where unless' = liftM -- generates a funky error
21:41:38 <jle`> it is a little odd because your eyes jump back and forth
21:41:38 <srhb> oo
21:41:39 <bitemyapp> :t (|>)
21:41:40 <lambdabot> Snoc s s a a => s -> a -> s
21:41:51 <jle`> it's generally recommended to use =<<
21:41:58 <jle`> return . head . fst =<< get
21:42:04 <jle`> see, easier on the eyes :)
21:42:08 <jle`> and from there it's easier to recognize
21:42:12 <jle`> that it's the same as
21:42:19 <jle`> (head . fst) <$> get
21:43:25 <zcd> how do you recognize that equivalence so quickly?
21:43:38 <jle`> um
21:43:41 <jle`> so
21:43:44 <srhb> unctors and stuff. :-)
21:43:44 <prophile> terminator vision
21:43:46 <srhb> ...
21:43:53 <shachaf> srhb: Monomorphism restriction?
21:43:57 <zcd> literally voodoo magic
21:43:59 <srhb> shachaf: Turned it off.
21:44:08 <jle`> it's all sorts of "composition"
21:44:20 <jle`> sometimes you want to compose an impure function onto an impure value
21:44:23 <shachaf> OK.
21:44:24 <srhb> Oh and I meant liftM unless of course
21:44:27 <jle`> that's =<<
21:44:28 <srhb> But you guessed as much
21:44:29 <aheller> zcd: there comes a time when you get sick of writing (… >>= return . stuff).
21:44:32 <shachaf> Actually, why are you expecting it to work?
21:44:41 <jle`> sometimes you want to compose a pure function onto an impure value, use <$>
21:44:41 <shachaf> Ah.
21:44:52 <shachaf> I don't think you want liftM
21:44:57 <shachaf> There's no return on the left side.
21:45:04 <srhb> derp, oh right
21:45:14 <shachaf> When in doubt, inline.
21:45:28 <jle`> i actually think head . fst <$> get will work
21:45:32 <srhb> Yeah.
21:45:40 <shachaf> A good language-aware Haskell editing environment would let you inline definitions easily so you don't have to do it by hand.
21:45:41 <jle`> zcd: think of it like head . fst ???? get
21:45:51 <shachaf> Partial evaluation of sorts, just to see what's going on.
21:45:51 <jle`> if it's pure function - impure value, <$>
21:45:54 <srhb> shachaf: Indeed, that would be nice.
21:45:57 <jle`> if it's impure function - pure value, =<<
21:45:58 <heatsink> @src liftM
21:45:58 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:46:04 <zcd> impure function as in the result is impure?
21:46:08 <shachaf> Inlining is the cure to all ills.
21:46:24 <shachaf> Also, you should probably use fmap instead of liftM when you use liftM.
21:46:36 <bitemyapp> you probably want to avoid lifting in general.
21:46:37 <jle`> by impure i mean it returns an m b
21:46:46 <srhb> shachaf: Aye
21:46:48 <bitemyapp> whenever possible/sensible.
21:46:50 <jle`> a -> b is pure, a -> m b is "impure"
21:47:02 <zcd> right
21:47:13 <jle`> you can also generalize it
21:47:16 <zcd> i hadn't thought about it that way, thanks
21:47:17 <jle`> to pure/impure values too
21:47:27 <srhb> are we calling m b impure now? :|
21:47:37 <jle`> it's a figure of speech
21:47:42 <bitemyapp> I'll figure yer speech.
21:47:48 <jle`> pure func $ pure val
21:47:58 <jle`> impure func =<< impure val
21:48:04 <jle`> pure func <$> impure val
21:48:06 <srhb> Conflates things a bit though, but oh well.
21:48:06 <bitemyapp> can we ditch the purity stuff?
21:48:09 <shachaf> I rarely call anything impure.
21:48:28 <jle`> should we call it monadic?
21:48:32 <bitemyapp> ...yes.
21:48:33 <jle`> value wrapped in a monad?
21:48:38 <srhb> Monadic.
21:48:43 <bitemyapp> wrapped in a type that implements a monad.
21:48:47 <bitemyapp> monadic.
21:48:48 <jle`> and...non-monadic?
21:48:49 <srhb> => monadic
21:48:50 <srhb> :P
21:48:53 <srhb> Yeah
21:48:58 <bitemyapp> what's non-monadic?
21:49:02 <jle`> a vs m a
21:49:08 <bitemyapp> but what if a is a monad too?
21:49:25 <jle`> well in this context i am describing things that use both a and m a
21:49:28 <bitemyapp> I'd call it "wrapped" vs. "not wrapped" in the original type under discussion.
21:49:30 <jle`> so monadic relative to a :)
21:49:38 <srhb> "monadicer"
21:49:43 <jle`> i don't like monadic because the ideas are stronger than monads to me
21:49:43 <bitemyapp> srhb: no.
21:49:49 <bitemyapp> stronger?
21:49:55 <jle`> it is more general than monads
21:49:57 <srhb> bitemyapp: :(
21:50:01 <zcd> bitemyapp: as a newcomer to monads that's the stuff of nightmares
21:50:03 <jle`> i think just "wrapped" works
21:50:04 <bitemyapp> jle`: that's why I said wrapped in a type.
21:50:09 <aheller> bitemyapp: if we're struggling to make this nomenclature work, then: a = m c and m b = m' (m c)
21:50:17 <bitemyapp> jle`: it's just a constructor.
21:50:19 <srhb> zcd: Sorry, the "pure" thing made this problematic :P
21:50:24 <jle`> but how would we contrast (a -> m b) and (a -> b) ?
21:50:42 <srhb> All we know for sure is that the first one is monadic
21:50:56 <bitemyapp> jle`: first func returns a new value wrapped in type m which implements a typeclass we care about. second func just returns a new value.
21:50:58 <flamingspinach> jle`: ah, thanks :D
21:51:05 <flamingspinach> head . fst <$> get is much nicer looking
21:51:09 <jle`> it's quite a mouthful, bitemyapp
21:51:09 <bitemyapp> srhb: actually, we don't know that unless we're implicitly assuming Monad m =>
21:51:16 <bitemyapp> jle`: so use wrapped/unwrapped
21:51:18 <srhb> We are
21:51:26 <jle`> a -> m b is a "wrapped function" ?
21:51:29 <bitemyapp> no
21:51:31 <bitemyapp> the result is wrapped in m
21:51:41 <zcd> wouldnt a wrapped function be better used in context of <*>
21:51:45 <bitemyapp> a wrapped function would be f (a -> b) or m (a -> b)
21:51:50 <jle`> yes, exactly
21:51:54 <jle`> hm
21:51:58 <bitemyapp> I don't think I
21:52:03 <bitemyapp> have been inconsistent here :)
21:52:06 <shachaf> I try not to use "monadic" when talking about values, either.
21:52:09 <shachaf> What does it mean?
21:52:12 <jle`> function returning wrapped value =<< wrapped value
21:52:15 <bitemyapp> shachaf: not much.
21:52:22 <jle`> is a bit more of a mouthful than
21:52:29 <jle`> impure function =<< impure value
21:52:37 <bitemyapp> sigh. USE THE TYPES
21:52:48 <deathbird> I see no problem with pure/impure...
21:52:48 <bitemyapp> (a -> m b) =<< (m a)
21:52:50 <srhb> Using pure just causes serious confusion
21:52:56 <bitemyapp> pure/impure is lying and confusing.
21:52:58 <jle`> using the types is...a bit weird
21:53:00 <srhb> "pure 2" >>= ... ?
21:53:03 <bitemyapp> Use the freakin' types.
21:53:12 <jle`> because you're mixing types with value functions/operators
21:53:19 <bitemyapp> also, pure is a function, which makes pure/impure nomenclature *worse* than it usually would be.
21:53:19 <dmj`> > do 4 + 5
21:53:20 <lambdabot>  9
21:53:25 <jle`> (f :: a -> m b) =<< (g :: m a)
21:53:32 <bitemyapp> jle`: fine, that. yes.
21:53:36 <bitemyapp> perfect.
21:53:39 <bitemyapp> but don't lie!
21:53:50 <deathbird> That's not very useful for teaching / explaining
21:53:55 <bitemyapp> is it not?
21:54:04 <srhb> Lies to children is not the same as something that is definitely misleading. And wrong.
21:54:07 <bitemyapp> you can follow up with examples, but that quite neatly and truthfully condenses the matter.
21:54:08 <tikhon> Using pure/impure for teaching is just going to be confusing. Is Maybe really impure?
21:54:13 <deathbird> If I saw that my first day of learning haskell I would be lost
21:54:31 <bitemyapp> deathbird: how long have you been teaching Haskell?
21:54:33 <jle`> i would probably only use pure/impure after establishing exactly what i meant by it
21:54:35 <jle`> but
21:54:38 <jle`> i do see how it would be confusing
21:54:40 <deathbird> I dont teach
21:54:42 <bitemyapp> jle`: don't use pure/impure, for the love of all that is unholy.
21:54:50 <tikhon> I usually say "in the monad" or something
21:55:07 <bitemyapp> again, pure is a distinct function that might actually be relevant, and it's seriously misleading nomenclature. And irrelevant even if it wasn't inaccurate/misleading.
21:55:24 <tikhon> But yeah, I think using "pure/impure" is at least partly responsible for people broadly misunderstanding what role monads play in Haskell.
21:55:24 <bitemyapp> jle`: I like tikhon's "in the monad" because it makes the type-constructory nature of it more apparent.
21:55:33 <shachaf> In addition to explaining exactly what you mean by something -- which is important -- you should make sure that your meanings are good.
21:55:48 <shachaf> Words have all sorts of associations.
21:55:54 <jle`> i can see how it would contribute to the widespread misunderstanding of monads
21:55:56 <jle`> hm
21:56:01 <bitemyapp> jle`: yes. don't be one of those people.
21:56:13 <tikhon> I mean, it's a difficult problem just from an education and outreach perspective
21:56:20 <srhb> We don't really have a good way to talk about monads aside from the types, but some are definitely less bad compared to others. :P
21:56:26 <tikhon> but also pretty important to think about
21:56:33 <bitemyapp> there isn't a long tradition of pedagogy established around these topics so to some degree we're hammering it out as we go.
21:56:36 <srhb> Some lead to burrito-iss.
21:56:39 <aheller> tikhon: failure (Maybe) isn't an implicit effect in haskell like nontermination or pattern match failures.  So if you conflate the simulation of the effect with the effect itself (which is often a useful way to think) then yes, computations in Maybe are impure.
21:56:43 <bitemyapp> but avoiding pure/impure nonsense is pretty much a given.
21:57:10 <shachaf> Yay. id is impure. "hello" is impure.
21:57:34 <bitemyapp> aheller: wut
21:57:37 <jle`> how about
21:57:44 <jle`> monadic function =<< monadic value
21:57:51 <heatsink> Do you say that [1] is in the list monad?
21:57:55 <jle`> normal function <$> monadic value
21:57:59 <bitemyapp> jle`: I liked the type signatures better.
21:58:04 <tikhon> aheller: I'm not sure that's a useful way to think about it. I mean, the sort of failure Maybe provides is very different from the sort that can be implicit in Haskell.
21:58:07 <shachaf> I rarely say "in the X monad".
21:58:13 <bitemyapp> jle`: the type signatures provided more information.
21:58:18 <srhb> shachaf: You rarely say anything but the types, I think? :P
21:58:19 <shachaf> I might say "[1] is a []-action".
21:58:30 <shachaf> If I'm thinking of it in that way.
21:58:32 <bitemyapp> Monad m => (f :: a -> m b) =<< (m a)
21:58:45 <tikhon> I usually reserve "action" for describing IO, so that I have a good word to call "IO-things"
21:58:54 <tikhon> either that or "procedure"
21:58:56 <shachaf> Oh, but it's such a great word. :-(
21:58:59 <bitemyapp> I use "action" for IO stuff too.
21:59:00 <heatsink> "computation" is good
21:59:16 <bitemyapp> if it's not in IO, I don't really bother because then it's an actual function.
21:59:18 <tikhon> heatsink: that sort of gives the opposite impression that I want for IO though
21:59:45 <aheller> tikhon: my point is that purity is relative, and what constitutes an effect often has more to do with the point you're trying to make than anything else.
21:59:46 <tikhon> the most important part is the distinction between "doing" something vs just "computing" something
22:00:12 <tikhon> honestly, I'm not a big fan of the "pure/impure" terminology in pretty much any context
22:00:18 <deathbird> bitemyapp: So would you say IO is "impure"?
22:00:19 <tikhon> but it is often convenient!
22:00:25 <srhb> deathbird: Argh, stop! :P
22:00:40 <bitemyapp> aheller: it's not relative at all.
22:00:40 <zcd> tikhon: could you elaborate more about the difference between computing and doing?
22:00:51 <aheller> bitemyapp: this will be fun :)
22:00:53 <bitemyapp> aheller: things are either functions or they're not. If they are functions then they are definitionally pure.
22:01:02 <tikhon> well, whenever you have a + b and you need its result, it takes some computation to get it
22:01:32 <bitemyapp> deathbird: you can't even define what impure is, so why bother attaching it to something?
22:01:37 <tikhon> it's purely a matter of evaluation, and its only real result is the value you've computed
22:01:49 <bitemyapp> deathbird: that's like those people that get themselves stamped with tattoos in chinese ideograms they don't understand. Senseless.
22:02:00 <tikhon> on the other hand, writing to the screen, using a printer, sending off a web request, launching the missiles: those are all actions
22:02:10 <aheller> bitemyapp: presumably mathematical functions are all and only the things which are pure is what you're saying?
22:02:20 <tikhon> we can't really think of them as computations because they involve doing something beyond just calculating and evaluating
22:02:34 <tikhon> and they don't even have to give you a meaningful result to be useful
22:02:34 <deathbird> bitemyapp: I just wasn't sure if you were against the word in general
22:02:50 <zcd> oh okay that makes sense
22:02:52 <bitemyapp> deathbird: it's more that it doesn't matter and it doesn't lead to 1. enlightenment 2. good conversation
22:02:58 <bitemyapp> deathbird: it's radioactive whether it means something or not.
22:03:19 <deathbird> bitemyapp: I agree
22:04:10 <bitemyapp> deathbird: actions in IO can shoot your dog; functions cannot.
22:04:28 <bitemyapp> aheller: do you think State is impure?
22:04:28 <tikhon> aside from the debate about what "pure" and "impure" mean, I think it's also important to think about whether they'd be useful pedagogically—I don't think they are
22:04:45 <tikhon> in my experience, they've led to more confusion than enlightenment
22:04:49 <bitemyapp> that's what I meant by radioactive/not leading to enlightenment. I don't think they are good pedagogically.
22:04:50 <deathbird> I would say state is pure
22:04:58 <tikhon> both back when I was learning and when I've tried to explain things to others
22:05:08 <bitemyapp> deathbird: that would indicate you understand the State monad.
22:05:19 <shachaf> I agree.
22:05:34 <aheller> bitemyapp: I don't mean relative in the sense of "a matter of opinion", but as a matter of perspective.
22:05:35 <deathbird> bitemyapp: I wouldn't say I "understand" anything in haskell
22:05:45 <deathbird> but I use the state monad
22:05:47 <bitemyapp> deathbird: well, you're pointed in the right direction so far at least on that topic.
22:05:54 <bitemyapp> deathbird: just keep writing code :P
22:06:06 <tikhon> the State monad is a really cool one to work out on your own
22:06:21 <tikhon> it's a great exercise and will help you understand both the State monad specifically and monads in general
22:06:22 <bitemyapp> aheller: perspectives are opinions possibly attached to some idea of 'experience'
22:06:24 <aheller> bitemyapp: is `last` pure?
22:06:35 <shachaf> And adjunctions*!
22:06:45 <shachaf> * Not really. But it's the best you can do in Haskell.
22:07:02 <shachaf> I do like the adjunctiony way of making State.
22:07:33 <bitemyapp> aheller: plenty of folk with an axe to grind about bottom.
22:07:43 <bitemyapp> aheller: I don't think it really matters or means much.
22:08:16 <bitemyapp> aheller: the only useful or meaningful delineation is actions vs. functions. Bottom is a separate and possibly unpleasant issue, depending how you've been writing your code.
22:08:32 <bitemyapp> aheller: it's pretty well known you're supposed to write total functions.
22:08:34 <aheller> bitemyapp: I would argue that there are valid arguments on either side of the question, and what you want out of the notion of purity constitutes the perspective from which you'd ascribe the term.
22:08:45 <bitemyapp> aheller: you're focusing on the wrong thing
22:08:59 <aheller> bitemyapp: what?
22:09:07 <bitemyapp> aheller: you're worrying about where to place a particular piece on the board. I'm more concerned with useful delineations of the board that lead to clear thinking.
22:09:30 <bitemyapp> aheller: if you start calling bottom-inhabited-types impure, you've slathered the concept over *everything* and that turns it into meaning *nothing*
22:09:54 <aheller> bitemyapp: You're arguing that the term leads to a lack of clarity.  I'm arguing that the term is used to connote reasonably coherent ideas.
22:09:55 <bitemyapp> so ditch the pointless and imprecise terminology.
22:10:00 <bitemyapp> aheller: nope.
22:10:16 <bitemyapp> aheller: your own attempt to advance the point proved it was meaningless and could be variously applied to everything, nothing, and some things.
22:10:26 <bitemyapp> just drop the terminology.
22:10:34 <bitemyapp> It's too overloaded.
22:10:39 <bitemyapp> Be more precise.
22:11:03 <srhb> This discussion has been had in this channel umpteen million times.
22:11:08 <srhb> Let's do something fun instead. :3
22:11:16 <bitemyapp> srhb: yeah but everybody likes their opinions.
22:11:31 <bitemyapp> srhb: so everybody has to be the special snowflake to bring up the subject for the 100,000th time even after people say it's a pointless subject.
22:11:51 <bitemyapp> "Clearly I'm the first person to think of this! I have to make this point or nobody will share in this BRILLIANT insight I've had!"
22:12:23 <bitemyapp> srhb: I'm working on a library. What are you up to?
22:12:43 <aheller> "When everyone knows that the real answer is....."
22:12:44 <shachaf> Let's talk about adjunctions!
22:12:44 <bitemyapp> srhb: I'm still battling the decision of user-defined sum types vs. existentially quantified types.
22:12:49 <srhb> bitemyapp: Procrastinating from doing a project by writing an ASCII clone of flappy bird, which was a challenge on dailyprogrammer :P
22:13:13 <bitemyapp> srhb: that's ridiculous, haha. What difficulty did it get rated?
22:13:22 <srhb> bitemyapp: Hard, strangely. :P
22:13:45 <bitemyapp> srhb: I'd call it intermediate or hard.
22:13:46 <srhb> Though I must say I'm unhappy with how I place the actual characters in an ascii grid. Maybe my data types are wrong.
22:14:01 <bitemyapp> srhb: pulling animation frames and the like together can be annoying. Are you using a termlib of some sort?
22:14:03 <shachaf> @let type Contt r a = (a -> r) -> r
22:14:04 <lambdabot>  Defined.
22:14:12 <bitemyapp> srhb: what are your types?
22:14:26 <srhb> bitemyapp: Oh, it's easier than that, it's essentially turn based, movements depend on how much you decide to flap (0-4)
22:14:31 <srhb> Nothing happens between that.
22:14:33 <bitemyapp> ohhhh
22:14:33 <shachaf> @let cont_fmap :: (a -> b) -> Contt r a -> Contt r b; cont_fmap f = (. (. f))
22:14:34 <lambdabot>  Defined.
22:14:47 <srhb> I did manage to write a live snake clone in the terminal without a termlib though, it's really not that hard.
22:14:53 <bitemyapp> srhb: I thought it was real-time + termwindow based which justified the "hard" in my head even if it's not necessarily enlightening.
22:14:58 <tikhon> srhb: doesn't that take away some of the challenge from the original game?
22:15:06 <srhb> tikhon: Yeah, I guess that is not the point
22:15:09 <srhb> And it's also trivial to add
22:15:10 <shachaf> @let cont_return :: a -> Contt r a; cont_return x = ($ x)
22:15:11 <lambdabot>  Defined.
22:15:13 <bitemyapp> tikhon: the continuous nature of the original required a lot of precision.
22:15:21 <bitemyapp> precision in timing, so yeah.
22:15:29 <tikhon> if you want a fun challenge, try making a more realistic clone with FRP
22:15:36 <srhb> Myeah.
22:15:42 <shachaf> @let cont_join :: Contt r (Contt r a) -> Contt r a; cont_join = (. cont_return)
22:15:42 <lambdabot>  Defined.
22:15:44 <tikhon> it would be a learning experience!
22:15:48 <srhb> Right now I'm happy with the bit that it makes me think of data types
22:15:54 <srhb> Although I'm dissatisfied. :P
22:16:01 <tikhon> fair enough
22:16:07 <srhb> But one day for sure!
22:16:10 <shachaf> cont_join = (. cont_return)! It's the best.
22:16:10 <tikhon> well, at least consider FRP for something to learn in the near future
22:16:13 <bitemyapp> srhb: what are your types?
22:16:33 <srhb> bitemyapp: World Obstacles Bird
22:16:43 <srhb> Where Obstacles have a column, a size and are Top/Bottom
22:16:49 <srhb> And Bird is a row in column 2
22:16:56 <srhb> Ie. it only has a height
22:17:47 <srhb> A simpler way would be to just represent every tile directly, but it feels so wasteful to do that when I scroll a column off each turn, and there's so much "empty"
22:18:55 <bitemyapp> srhb: where does the trouble come in?
22:19:21 <srhb> Converting the representation of obstacles and their positions into a [String] to be shown on screen
22:19:38 <srhb> It's not trouble really, just ugly.
22:20:10 <ruzu> :t life
22:20:11 <lambdabot>     Not in scope: life
22:20:11 <lambdabot>     Perhaps you meant lift (imported from Control.Monad.Writer)
22:20:15 <srhb> http://lpaste.net/102591
22:20:41 <sgronblo> bah, still couldnt install yesod
22:20:49 <srhb> sgronblo: With 7.8.2?
22:20:55 <sgronblo> https://gist.github.com/pyrtsa/6213784 having the same problem as this guy
22:21:04 <sgronblo> no 7.6.3 I think
22:21:12 <srhb> Oh.
22:21:19 <srhb> Unrelated then.
22:22:35 <srhb> bitemyapp: The more I think about it, the more the core representation as a matrix seems wiser
22:22:47 <srhb> Maybe if I could have a sparse matrix...
22:23:56 <bitemyapp> srhb: uh, you could do that. Is it going to make your life easier?
22:24:14 <srhb> bitemyapp: Well checking of colissions will be easier for instance.
22:24:36 <srhb> bitemyapp: When I scroll and move the bird I just have to check if it's actually trying to stand on a cell that is occupied
22:24:44 <flamingspinach> whoops, my pop function forgot to modify the state! :) I guess it's not that easy to one-liner it after all.
22:25:14 <sgronblo> so i guess what goes wrong is the preprocessor stage for me
22:25:53 <srhb> Actually since I generate the matrix anyway, what I'm doing now is completely stupid
22:26:08 <srhb> The abstract representation does not help me compute anything, and computationally I _still_ do all the matrix shuffling
22:26:11 <srhb> Derp
22:26:56 <sgronblo> But this guy is talking about homebrew formulas but im not using homebrew now
22:27:53 <sgronblo> hmm, seems like its the upgrade to mavericks that changed the gcc
22:28:31 <sgronblo> so maybe i need to install gcc using homebrew and change this "c compiler command"
22:31:20 <dmj`> sgronblo: http://www.haskell.org/platform/mac.html
22:31:25 <dmj`> scroll down a few inches
22:32:09 <dmj`> is angular js worth learning?
22:34:01 <sgronblo> dmj`: I think its pretty cool
22:34:13 <sgronblo> Especially for single page apps in a browser
22:34:32 <luite> nh
22:34:34 <sgronblo> I dont want to go back to manually maintaining state with jquery spagetti
22:34:36 <luite> i mean neh
22:42:39 <deathbird> How do Haskell updates work on hackage? Do hackage packages just gradually update, or is there a way for a package to have both versions?
22:43:13 <tikhon> you compile things from hackage locally
22:43:36 <tikhon> so most packages should work with no intervention whatsoever
22:43:49 <deathbird> Yeah. Oh the new compilers are backwards compatible
22:43:53 <tikhon> otherwise, people will have to upload new versions
22:45:33 <bitemyapp> tikhon: may I ask you for a pointer?
22:45:55 <tikhon> pointer?
22:46:01 <bitemyapp> advice
22:46:03 <bitemyapp> not char*
22:46:21 <tikhon> okay
22:47:01 <bitemyapp> tikhon: I have a data type that can either: 1. wrap a plain old parametric type, which will force a sum type from users of the library. 2. Use an existentially quantified type, which will allow variance in the [BulkOperation a] type 3. Ask the users for bytestrings that happen to already be JSON
22:47:07 <bitemyapp> tikhon: I have to generate
22:47:21 <bitemyapp> \n separated JSON documents that form an overall stream that isn't technically proper JSON.
22:47:30 <bitemyapp> but will be a bytestring when I'm done with it.
22:47:49 <bitemyapp> #3 is the most appealing so far.
22:47:50 <tikhon> hmm, I'm a bit confused by what you mean by forcing a sum type
22:48:04 <bitemyapp> tikhon: it's a data type for bulk operations against a search engine (data store)
22:48:26 <bitemyapp> tikhon: the type parameter has to be a sum type if you're doing bulk operations against different types of documents.
22:49:12 <tikhon> so you would have something like BulkOperation SumType where SumType contains the different possible documents?
22:49:23 <bitemyapp> tikhon: right. and the alternative is existential quantification
22:49:37 <bitemyapp> because I have a function that accepts ToJSON a => [BulkOperation a]
22:49:42 <tikhon> ah
22:49:44 <tikhon> right
22:49:51 <bitemyapp> and all I actually care about is getting the bytestrings out and intercalating with \n
22:50:17 <tikhon> existential quantification sounds good except it's pretty awkward in Haskell
22:50:17 <bitemyapp> so I could just ask for the bytestrings and let the users do it. that spares the weird tension with variance in the types.
22:50:34 <bitemyapp> tikhon: yeah, it's forcing me to write a bunch of instances that are annoying.
22:50:37 <tikhon> on the other hand, asking for bytestring might make it easy to accidentally pass in a wrong sort of bytestring
22:50:38 <bitemyapp> I'm leaning towards bytestring.
22:50:48 <tikhon> would that be an issue?
22:50:55 <bitemyapp> it's unlikely.
22:51:05 <bitemyapp> there aren't many unwrapped bytestring parameters in the API
22:51:13 <tikhon> I mean, it sounds like existential types are the *right* solution, but it might be a bit of a pain
22:51:22 <bitemyapp> another reason I'm leaning towards bytestring is that the data types bulk operation expects are different from the vanilla document types
22:51:35 <bitemyapp> the updates can be partial definitions of what gets updated.
22:52:22 <tikhon> from an API standpoint, the annoying thing about existential types is that the user would have to wrap all the items in the list
22:52:39 <bitemyapp> tikhon: and write a ToJSON instance.
22:52:40 <tikhon> but if you ask for bytestrings directly, they'd still have to transform the BulkOperation a into the bytestring
22:52:52 <tikhon> wouldn't the existential type take care of that?
22:52:58 <bitemyapp> nope.
22:53:11 <bitemyapp> I implement the outer bit, they implement in the inner bit.
22:53:28 <bitemyapp> generics won't work if it's existentially quantified, I'm pretty sure.
22:53:44 <bitemyapp> tikhon: no, I do the transform.
22:53:50 <tikhon> data MyOp = forall a. Show a => MyOp a
22:53:52 <bitemyapp> tikhon: they only give me document bytestrings, not the whole stream.
22:53:54 <tikhon> umm, except with ToJson
22:54:05 <bitemyapp> tikhon: I handle the \n separation and metadata attachment.
22:54:13 <bitemyapp> the metadata attachment would be well-typed.
22:54:58 <tikhon> so what about
22:54:58 <tikhon> data JsonOp = forall a. ToJson a => JsonOp a
22:55:04 <tikhon> and asking for BulkOperation JsonOp?
22:55:07 <bitemyapp> the typed version means they're less likely to pass something that I can't get a valid JSON bytestring out of, but I don't think it's necessarily worth it.
22:55:13 <tikhon> or am I missing something
22:55:14 <shachaf> Why is that existential type ever the right solution?
22:55:38 <shachaf> Instead of storing a JsonOp, just store a JSON value.
22:55:39 <bitemyapp> shachaf: multiple options are under discussion.
22:55:57 <tikhon> hmm, probably depends on what ToJson returns—I was assuming it was just a bytestring or something
22:56:09 <bitemyapp> actually, I think the Aeson Value type might be the way to go here.
22:56:14 <tikhon> yeah
22:56:16 <shachaf> The class I found with a name like that has a function :: a -> Value
22:56:23 <bitemyapp> it's better typed than bytestring, but less hassle than the existentially quantified version.
22:56:33 <bitemyapp> shachaf: tikhon thanks the both of you!
22:56:39 <tikhon> I think having proper existential types would be nice
22:56:44 <shachaf> Anyway, it doesn't matter what it is -- ByteString might be too general a type, but just because you want your own type doesn't mean you want it to be existential.
22:56:48 <bitemyapp> tikhon: it breaks so much stuff.
22:56:53 <jle`> tikhon: oh yeah, wanted to take a chance to thank you for your fgl article
22:56:57 <tikhon> one of the other compilers has it
22:56:57 <jle`> tikhon: so...thanks
22:56:59 <jle`> :)
22:57:02 <tikhon> heh, welcome :)
22:57:07 <bitemyapp> shachaf: it doesn't have to be existential. I suggested an option that involved my own data type with no existential quantification
22:57:14 <shachaf> You can make newtype JsonOp = JsonOp ByteString and let users construct it in particular ways.
22:57:25 <bitemyapp> shachaf: but I also said it would mean forcing the user to define all possible variants of their bulk operations in a sum type which is a bit much to ask.
22:57:32 <shachaf> UHC has first-class existentials, but not with type classes.
22:57:41 <tikhon> hmm
22:57:44 <tikhon> I haven't played around with it
22:57:55 <shachaf> I like the idea of first-class existentials in theory, but in practice I'm not even sure how it should behave.
22:58:04 <bitemyapp> If I went the "raw bytestring" route I would probably newtype it sure, but I think Aeson Value/Object is actually the way to go.
22:58:10 <tikhon> so you wouldn't be able to say something like [∃x. ToJson x => BulkOperation x]?
22:58:18 <shachaf> It wouldn't be =>
22:58:40 <bitemyapp> it has to be ToJSON, how else would it work?
22:58:42 <tikhon> hmm?
22:58:48 <shachaf> Since "c => x" means that the consumer of the value is giving the constraint.
22:58:58 <shachaf> But really, here, the producer of the value is giving you both the type and the dictionary.
22:59:11 <shachaf> So you need a dual of =>. ski calls it *>, so I call it that too.
22:59:17 <tikhon> hmm
22:59:26 <shachaf> [exists x. ToJson x *> BulkOperation x]
22:59:28 <tikhon> I think about => as implication
22:59:43 <shachaf> OK, but it's not implication in this case.
22:59:55 <bitemyapp> hrm. yeah. I knew existentials inverted that but it hadn't occurred to me at that particular point.
23:00:00 <shachaf> The consumer has no idea what x is.
23:00:28 <tikhon> hmm
23:00:40 <bitemyapp> types are hard lets go shopping?
23:00:42 <shachaf> You can think of (forall x. Foo x => x) as a function with two arguments, as in (x :: *) -> FooDict x -> x
23:00:56 <shachaf> When you turn it into an existential, you get a tuple: ((x :: *), FooDict x, x)
23:01:16 <shachaf> The person who's making the value has to tell you both the type and the "proof" that it's actually an instance of Foo.
23:01:48 <tikhon> right, makes sense
23:02:00 <bitemyapp> Aeson doesn't make it very easy to ask for an object variant of Value specifically, does it?
23:02:12 <tikhon> that's more or less what I was desugaring ∃x. Foo x => ... to in my head
23:02:16 <bitemyapp> that's annoying. I want to make certain the user is passing {...} and not any other kind of JS type.
23:02:23 <tikhon> but it makes sense not to reuse => for that
23:02:40 <bitemyapp> the hashmap object type is a little awkward. I don't think anybody is used to returning that.
23:02:41 <shachaf> Note that with GHC existentials, you do use =>, just like you use forall.
23:02:45 <shachaf> Because it's on the outside.
23:02:55 <shachaf> data T = forall x. Foo x => T x
23:03:02 <shachaf> data T = T (exists x. Foo x *> x)
23:03:28 <shachaf> I think it's a pretty important distinction to keep in mind.
23:04:36 <shachaf> Anyway, how should type inference for existential types work? Certainly you don't want ['a', True] to infer as [exists x. x] Or [exists x. (Show x, Read x) *> x] or something.
23:04:49 <tikhon> oh, I wouldn't expect inference for it at all
23:04:56 <shachaf> You can say that you only get existentials when you specify a type explicitly, but how does that work exactly?
23:05:33 <tikhon> type inference could just treat it as if it was a normal concrete type, couldn't it?
23:05:44 <tikhon> I mean, it would just be a somewhat prettier version of what we have now
23:05:53 <shachaf> list :: [exists x. Show x *> x]; list = ['a', True] should type-check.
23:06:05 <shachaf> Presumably list = xs where xs = ... wouldn't.
23:06:20 <tikhon> yeah, that does get a bit confusing
23:06:26 <shachaf> How do you decide whether that list type-checks correctly?
23:06:46 <shachaf> Also, suddenly the values aren't values anymore, they're (dictionary, value) tuples.
23:06:47 <tikhon> then again, if xs is full of random stuff, I think it should have an explicit signature
23:06:58 <shachaf> Which is kind of odd.
23:07:13 <shachaf> I don't really know the answers to these questions, by the way, I'm just mentioning why I'm not sure that it would work.
23:07:14 <bitemyapp> shachaf: "Certainly you don't want ['a', True] to infer as [exists x. x]" you should tell Scala users that.
23:07:22 <tikhon> well, that's not a big deal any more than having an extra hidden dictionary parameter is
23:07:30 <shachaf> I guess so.
23:07:33 <shachaf> Existentials are closely related to rank-n types so probably you'd end up with many of the same answers.
23:07:59 <tikhon> which mostly involves not inferring them, right?
23:08:06 <shachaf> Right.
23:08:16 <shachaf> Hmm, I think GHC not supporting impredicativity makes it a lot simpler.
23:09:08 <shachaf> (But makes the kind of thing you want to do not really possible.)
23:10:07 <shachaf> What's the rank-2 way to encode that kind of list?
23:10:24 <shachaf> I guess it would be a type for list k = [k 'a', k True] or something like that.
23:11:30 <tikhon> hmm, yeah
23:11:31 <shachaf> E.g. list :: forall r. (forall x. Show x => x -> r) -> [r]; list k = [k 'a', k True]
23:11:44 <tikhon> which looks almost the same as the existential version, doesn't it?
23:11:53 <tikhon> with current existential types, I mean
23:11:59 <shachaf> Right.
23:12:11 <shachaf> It's the same idea.
23:13:00 <shachaf> data T where { T :: forall x. Show x => x -> T }; list :: [T]; list = [T 'a', T True]
23:13:49 <shachaf> Anyway, given that T is isomorphic to String, String is just about always the right answer in this case for this kind of list.
23:14:20 <tikhon> well, the typeclass also—ideally—comes with laws
23:14:32 <shachaf> (T isn't actually isomorphic to String because of showsPrec and showList nonsense. But that's the general idea.)
23:14:45 <tikhon> of course, those aren't tracked by the type system
23:14:45 <shachaf> A type can also come with laws. :-)
23:15:00 <tikhon> right
23:15:20 <tikhon> in this case, I was thinking of the hypothetical ToJson class that had toJson :: a -> String
23:15:29 <tikhon> or ByteString or whateve
23:15:31 <tikhon> r
23:15:54 <codygman> I have a very small patch for the pcre-light library so it works with ghc 7.8.1. How would I submit that? http://hackage.haskell.org/package/pcre-light (dons email doesn't work anymore)
23:16:00 <shachaf> Fortunately the real class has toJSON :: a -> JSON, which sounds like a better design anyway. :-)
23:16:06 <tikhon> yes
23:16:15 <shachaf> The dual of the T above is a universal, by the way: newtype R = R { forall a. Read a => a }
23:16:30 <shachaf> R is also isomorphic to String, if you pretend Read is nice and simple.
23:17:06 <shachaf> An advantage of String over (exists x. Show x *> x) is that you get sharing -- the String is only evaluated once.
23:17:45 <tikhon> codygman: did you use the email address from his website?
23:17:56 <tikhon> it's possible the package wasn't updated but his website was
23:17:56 <shachaf> I think type classes actually complicate most discussions of existential types, so I prefer to think about them without classes first.
23:18:16 <codygman> tikhon: No I used the one on the pcre-light page. What is his website?
23:18:41 <tikhon>  http://donsbot.wordpress.com/about/
23:18:51 <tikhon> says his email is dons00@gmail.com
23:19:18 <shachaf> I hear the best way to contact him is Twitter or something.
23:20:33 <tikhon> you just have to say his name three times on a crossroads at midnight
23:20:59 <bitemyapp> say "Haskell sucks" on Hacker News 2 years ago and he'd pop up like a gopher out of the ground.
23:21:47 <lispy> bitemyapp: now I just say, "HN sucks"
23:22:12 <zRecursi`> Lisp sucks ?
23:22:39 <tikhon> Eh, I think HN's pretty good, especially for Haskell content recently
23:23:02 <tikhon> I thought the discussion about the Haskell TLS implementation was interesting
23:24:30 <lispy> All the comment threads I've seen on HN have put reddit to shame for being vituperous, mean, and generally just expressing attitudes that I find unpleasant.
23:25:47 <lispy> There might be some good content in there, but I gave up on the site before finding it.
23:26:10 <tikhon> hmm, I think that's unfortunate, but this is really morphing into something for #haskell-blah
23:27:15 <codygman> is there a list of ifdefs for haskell? For instance if I wanted to add code for a specific ghc version how would I do that?
23:27:36 <shachaf> I think the GHC User's Guide answer that question.
23:27:51 <codygman> shachaf: Okay, I'll check it out. Thanks.
23:31:51 <lispy> codygman: and cabal provides CPP to check the cabal version.
23:34:30 <srhb> shachaf: Is there a transformer-aware version of .= somewhere?
23:35:07 <srhb> foo >>= (lens .=) --eek
23:35:15 <shachaf> help
23:35:19 <shachaf> Why me and not #haskell-lens?
23:35:32 <srhb> Fiiine
23:35:56 <shachaf> It seems to me that (.=) is already transformer-aware.
23:35:56 <tikhon> ...because you're probably the one who's going to answer over on #haskell-lens anyhow? ;)
23:53:28 <pyon> @pl (c -> d) -> (a -> b -> c) -> (a -> b -> d)
23:53:28 <lambdabot> (line 1, column 6):
23:53:28 <lambdabot> unexpected '>'
23:53:28 <lambdabot> expecting operator
23:53:46 <pyon> @djinn (c -> d) -> (a -> b -> c) -> (a -> b -> d)
23:53:46 <lambdabot> f a b c d = a (b c d)
23:54:13 <pyon> @pl \a b c d -> a (b c d)
23:54:13 <lambdabot> (.) . (.)
