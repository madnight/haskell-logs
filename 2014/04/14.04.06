00:00:50 <vivaldi> :)
00:22:19 * hackagebot resourcet 1.1.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.1 (MichaelSnoyman)
00:59:23 * nick1234abcd says hi
01:02:08 <nick1234abcd> whats the best way to handle json data in haskell?
01:03:51 <erisco> nick1234abcd, what does "handle" mean?
01:04:05 <nick1234abcd> i want to fetch some data over http and parse it to use in a script
01:04:39 <erisco> well getting the data over http is probably going to be a different package
01:04:44 <erisco> but for json.. there seem to be plenty http://hackage.haskell.org/packages/search?terms=json
01:04:57 <nick1234abcd> example: GET https://www.bitstamp.net/api/order_book/
01:06:17 <nick1234abcd> yeah it returns multiples packages and i was wondering which one was best
01:06:41 <nick1234abcd> "json library: Support for serialising Haskell to and from JSON (bsd3, library)"
01:06:55 <erisco> *shrug* I dunno which is best
01:07:20 <nick1234abcd> ok
01:10:51 <jle`> nick1234abcd: the typical solution is aeson
01:12:28 <nick1234abcd> jle`: ok thanks~~
01:14:52 <DogeHayashi> does the latest haddock only support ghc7.8?
01:22:43 <startling> nick1234abcd: seconding aeson
01:27:04 <nick1234abcd> startling: ok thanks I'm trying it out
01:27:20 <nick1234abcd> just found out i have to install another package to handle https data
01:28:03 <startling> yep, making requests is orthagonal to parsing json
01:28:17 <Jeanne-Kamikaze> is there some way to magically get cabal-install to update everything it can and ghc-unregister / delete / whatever old packages ?
01:29:43 <startling> Jeanne-Kamikaze, you can rm -rf ~/.ghc
01:30:05 <startling> Jeanne-Kamikaze: there's also --force-reinstalls, but the former is more reliable
01:31:18 <Jeanne-Kamikaze> alright thanks, that solves the second problem
01:31:57 <Zolomon> Is it possible to floor a float?
01:32:02 <Zolomon> > :t floor
01:32:03 <lambdabot>  <hint>:1:1: parse error on input `:'
01:32:12 <Yaniel> :t floor
01:32:13 <lambdabot> (Integral b, RealFrac a) => a -> b
01:32:38 <Zolomon> The RealFrac constraint confuses me, a can't be of type Float?
01:32:53 <Zolomon> > floor 2.5
01:32:54 <lambdabot>  2
01:33:07 <Yaniel> :t RealFrac
01:33:08 <lambdabot> Not in scope: data constructor `RealFrac'
01:33:11 * Zolomon blushes
01:33:34 <Yaniel> well the "Real" part does sound like float could be one
01:33:53 <startling> Zolomon, Float satisfies the RealFrac constraint, yeah
01:34:13 <Yaniel> also, wouldn't be a very useful function if it couldn't handle floats :D
01:37:52 <GAS> Hi, all!
01:39:42 <Jeanne-Kamikaze> yo
01:42:29 <nick1234abcd> can someone help me with my code? http://pastebin.com/TddR65vC
01:42:46 <nick1234abcd> i want to modify it so that it can fetch data over https
01:42:52 <nick1234abcd> right now it can only do http
02:11:56 <ZWJ> whats a standalone deriving clause?
02:12:08 <ZWJ> *declaration
02:20:43 <pordan30> ZWJ: you can look at the ghc documentation here (it provides a good discussion of the motivation for standalone deriving declarations, also) <http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html>
02:41:59 <dibblego> is this even sensible? http://lpaste.net/102324
02:44:00 <ion> @tell amalloy asTypeIn :: a -> (a -> b) -> a; a `asTypeIn` f = a where { _ = f a }; infixl 0 `asTypeIn`; asAppliedTo :: (a -> b) -> a -> a -> b; f `asAppliedTo` x = f `asTypeIn` ($ x); infixl 0 `asAppliedTo`
02:44:01 <lambdabot> Consider it noted.
03:17:41 * hackagebot sign 0.3.0 - Arithmetic over signs and sets of signs  http://hackage.haskell.org/package/sign-0.3.0 (MasahiroSakai)
03:18:56 <crodjer> Is it possible to get hlint's output in a single line (for integration with editors).
03:19:26 <crodjer> I could use sed, but if there was something like custom templates which hlint supported.
03:24:30 <dinkarganti> My app is crashing on mac and core doesnt show the trace. otool has some info...will that help?
03:25:02 <dinkarganti> osx 10.9.2
03:25:10 <startling> dinkarganti, gdb might help
03:25:30 <dinkarganti> startling: i tried lldb..
03:25:41 <startling> dinkarganti: what'd you get?
03:25:43 <dinkarganti> stortling: there is no stack trace.
03:25:53 <dinkarganti> let me paste it.
03:26:12 <startling> that's weird. can you give us the source code? how did you compile it?
03:26:48 <dinkarganti> startling: sure..i have a cabal file.
03:27:07 <dinkarganti> it works on windows and fedora
03:27:20 <startling> dinkarganti: you're not cross-compiling or anything?
03:27:40 <dinkarganti> nope..straight compilation.
03:27:59 <dinkarganti> i can past the otool output if that helps.
03:28:19 <startling> I think it's out of my depth at this point.
03:28:28 <startling> Someone else might be able to help.
03:29:01 <dinkarganti> thank you. I was at a hackathon (still am)..will try to find out there this afternoon.
03:37:43 * hackagebot hspec-meta 1.9.2 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.9.2 (SimonHengel)
03:38:50 <dinkarganti> here is the otool output
03:38:51 <dinkarganti> http://lpaste.net/102326
03:39:00 <dinkarganti> is this a known issue on mac?
03:42:44 * hackagebot hspec 1.9.2 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.9.2 (SimonHengel)
03:44:22 <no-n> @src get
03:44:22 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:44:50 <Kaidelong> @ty get
03:44:51 <lambdabot> MonadState s m => m s
03:45:04 <Kaidelong> yeah I thought so
03:45:17 <Kaidelong> I forgot how to look up method implementations, lambdabot did have a way
03:45:31 <athan> :t fmap (get) runState
03:45:32 <lambdabot> MonadState s ((->) (s1 -> (a, s1))) => State s1 a -> s
03:46:18 <athan> :t fmap (get >>= put "foo") $ runState $ pure "bar"
03:46:19 <lambdabot>     Couldn't match type `()' with `([Char], s0) -> b0'
03:46:19 <lambdabot>     Expected type: a0 -> ([Char], s0) -> b0
03:46:19 <lambdabot>       Actual type: a0 -> ()
03:46:35 <athan> :t fmap (get >>= put "foo") $ runState
03:46:36 <lambdabot>     Couldn't match type `()' with `(s0 -> (a1, s0)) -> b0'
03:46:36 <lambdabot>     Expected type: a0 -> (s0 -> (a1, s0)) -> b0
03:46:36 <lambdabot>       Actual type: a0 -> ()
03:47:27 <athan> :t fmap (get >>= put "foo") $ runState (>>=)
03:47:27 <lambdabot>     Couldn't match type `()' with `(a1, s0) -> b0'
03:47:27 <lambdabot>     Expected type: a0 -> (a1, s0) -> b0
03:47:27 <lambdabot>       Actual type: a0 -> ()
03:47:44 * hackagebot hakyll 4.5.0.2 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.5.0.2 (JasperVanDerJeugt)
03:48:14 <athan> :t fmap (get >>= put) $ runState (>>=)
03:48:14 <lambdabot>     Couldn't match type `m0 a2 -> (a2 -> m0 b0) -> m0 b0'
03:48:15 <lambdabot>                   with `StateT s0 Identity a1'
03:48:15 <lambdabot>     Expected type: State s0 a1
03:48:24 <dinkarganti> A question on declaring data types: Do we have to always have an Empty variant?
03:48:32 <Kaidelong> no
03:49:03 <athan> that's interesting
03:49:13 <dinkarganti> the issue is that when I implement arbitrary instances i need to handle non empty variants?
03:49:17 <athan> I wonder if the type system forces a constraint
03:49:18 <dinkarganti> How do I do that.
03:49:46 <athan> non empty?
03:49:59 <athan> :S
03:50:09 <dinkarganti> For example data Foo = Empty | Foo {x :: String}
03:50:24 <athan> you shouldn't have to
03:50:33 <athan> oh
03:50:38 <athan> but if you're writing a function
03:50:48 <athan> you should try to handle both variants
03:50:50 <dinkarganti> The issue is that if i implement arbitrary instance: i either have to throw an exception (not recommended) or
03:51:03 <dinkarganti> create an empty variant: so the arbitrary is hapy.
03:51:06 <dinkarganti> happy*
03:51:18 <athan> hmm I see what you're saying
03:51:45 <athan> I mean, I don't know exceptions well, but I think they break the logic behind the program
03:51:47 <Kaidelong> well adding an empty value to a type is what Maybe does
03:52:03 <Kaidelong> so you might be able to just wrap your data structure in that
03:52:23 <Kaidelong> how is the Arbitrary typeclass supposed to be used?
03:52:30 <athan> are you getting an error, dinkarganti?
03:52:31 <dinkarganti> So implement Maybe Foo instead of Foo arbitrary?
03:52:45 <athan> if you wanted to account for failure, I would
03:52:57 <dinkarganti> no errors..but quick check fails because I want to disallow invalid coordinates or company name for example.
03:53:25 <athan> I think basic exception or error codes would be encoded like data Errable a = ErrCde1 | ErrCde2 String | AllGood a
03:53:35 <Kaidelong> @ty arbitrary
03:53:36 <lambdabot> Arbitrary a => Gen a
03:53:54 <athan> o.O?
03:54:15 <jophish> Why isn't (a->a) an instance of monoid, with mempty = id and mappend = (.)?
03:54:42 <athan> jophish: :)
03:54:52 <athan> jophish: I'm pretty sure that's a category as well
03:54:55 <Kaidelong> jophish: because it'd overlap with the more useful Reader monoid, but there is a monoid like that
03:55:24 <athan> jophish: it's associative
03:55:34 <dinkarganti> Ok..so arbitrary instance can return Errable or Foo?
03:55:37 <Kaidelong> there was a newtype that got it for you, kind of like Sum and Product
03:55:42 <dinkarganti> need to run..but will be back shortly.
03:55:47 <jophish>  athan, oh yes, pretty much by definition!
03:55:58 <athan> jophish: i think it's a political thing right now
03:56:02 <athan> hahaha
03:56:17 <jophish> ah I see
03:56:21 <athan> ...maybe
03:56:25 <athan> idk honestly
03:56:33 <athan> I think a lot is gonna happen with 7.10
03:56:39 <jophish> looking forward to it
03:56:45 <athan> me too
03:57:00 <Kaidelong> jophish: there is an instance (Monoid t) => Monoid (p -> t) that's generally more useful
03:57:12 <Kaidelong> the two can overlap
03:57:13 <athan> dinkarganti: Your function should only return one type
03:57:21 <jophish> athan: http://www.haskell.org/pipermail/haskell-cafe/2014-April/113373.html
03:57:23 <Kaidelong> what if you have a type Monoid t => t -> t?
03:57:25 <Kaidelong> which instance is it?
03:57:41 <jophish> Kaidelong: yeah, I just spotted that
03:57:54 <athan> wait, nevermind, I'm sorry I misread dinkarganti
04:06:41 <Frokost> Hi
04:09:13 <Frokost> exit
04:16:20 <seanparsons> Can anyone tell me why I can see a big chunk of individual time in this profiling that I can't trace down to anything: https://gist.github.com/seanparsons/519fffaa3399d6e33184
04:16:26 <seanparsons> From this offending line: https://github.com/argonaut-io/argonaut-hs/blob/master/src/Data/Argonaut/Parser.hs#L311
04:16:29 <athan> Hey guys, what's the monomorphism restriction? :S
04:21:19 <ion> athan: A top-level definition without a type signature such as ‚Äúa = 5‚Äù will be monomorphized from ‚Äúa :: Num a => a‚Äù to ‚Äúa :: Integer‚Äù when the monomorphism restriction is active.
04:24:27 <Kaidelong> athan: the monomorphism restriction says that top level functions aren't allowed to have polymorphic argument types unless they explicitly have them. There is some defaulting on this, helped along by typeclasses
04:25:24 <Kaidelong> so with the monomorphism restriction you cannot make id a top level binding without also giving it a type signature
04:25:32 <Kaidelong> well
04:25:34 <Kaidelong> not sure about id
04:25:44 <Kaidelong> the rules were a bit more complicated
04:25:59 <athan> ahh I think i get it
04:26:02 <Kaidelong> but basically so long as you give top level bindings type signatures you shouldn't run into the monomorphism restriction
04:26:11 <athan> is that why division through let statements kinda fails?
04:26:24 <athan> huh
04:26:27 <athan> that's strange
04:26:31 <athan> I'll have to look into that
04:26:33 <Kaidelong> the monomorphism restriction should only affect bindings at the top level
04:26:51 <athan> can you explain it categorically?
04:27:05 <athan> please? :)
04:28:18 <Kaidelong> okay "id" would work because there is only one possible function "id", the problem comes in when typeclasses mess up that kind of parametricity
04:29:04 <athan> ahhh i see
04:29:08 <Kaidelong> I guess I don't actually understand the monomorphism restriction
04:29:10 <Kaidelong> http://www.haskell.org/haskellwiki/Monomorphism_restriction
04:29:14 <athan> thank you!
04:29:15 <athan> lol
04:29:33 <Kaidelong> I thought I did, hopefully someone else here can give you a correct answer
04:30:31 <Kaidelong> this looks kind of like ML's ? types to prevent an implementation of a -> b
04:30:40 <Kaidelong> but since haskell is pure that can't be the reason why
04:48:32 <randomclown> @pl \x -> (W x, 1)
04:48:32 <lambdabot> flip (,) 1 . W
04:48:53 <randomclown> eh probably better to zip
04:57:15 <ion> What‚Äôs wrong with \x -> (W x, 1)?
05:04:51 <ocharles> > W &&& const 1 $ x
05:04:52 <lambdabot>  Not in scope: data constructor `W'
05:04:56 <ocharles> meh.
05:18:59 <seanparsons> Anyone with a reasonable amount of experience with the profiling support?
05:19:56 <ion> > (f &&& const 1) x
05:19:58 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr c0)
05:19:58 <lambdabot>    arising from a use of `e_11'
05:19:58 <lambdabot>  The type variable `c0' is ambiguous
05:19:58 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
05:19:58 <lambdabot>  Note: there are several potential instances:
05:20:05 <ion> > ((f :: Expr -> Expr) &&& const 1) x
05:20:06 <lambdabot>  (f x,1)
05:22:59 * hackagebot music-util 0.9.2 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.9.2 (HansHoglund)
05:23:01 * hackagebot ixset-typed 0.2 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-typed-0.2 (AndresLoeh)
05:30:51 <iron_houzi> I'm still stuck with school assignments but now that I have the skill and time to look at real world applications I want to make, I always start with: "Can I use Haskell for this?". My first project was GUI/multi-platform, so I had to use Python. Now I need to create a webapp that distributes tokens to authorized users to get access to file downloads. Can I do the following in Haskell: Build a webapp with a
05:30:53 <iron_houzi> postgres/mariadb backend, that can utilize something like this: https://code.google.com/p/mod-auth-token/ ?
05:32:45 <iron_houzi> ..If so, what libs/frameworks should I be using?
05:45:17 <jmcarthur> iron_houzi: haskell is a general purpose language. you can do anything in it that you can do in Python or C or whatever
05:46:15 <jmcarthur> iron_houzi: so that link you gave is an apache module, so i take it you want to use apache as the web server?
05:46:58 <jmcarthur> iron_houzi: there are tons of libraries you could use on hackage. db bindings, web app libraries, etc.
05:47:19 <jmcarthur> so many i don't think i even want to really take the time to explain what's out there
05:50:14 <Algebr> When in ghci, is there a difference between just importing a module and doing : +m <module>?
05:53:56 <iron_houzi> jmcarthur: I'm currently using the LAMP stack on my server. Does any of the haskell webapp frameworks do something similar to Django, where the db-integration works out of the box and the developer using it can just define the database structure and build other functionalites on top of that?
05:54:17 <HugoDaniel> Algebr: no, but with import you can import qualified
05:55:06 <HugoDaniel> iron_houzi: yes
05:55:23 <iron_houzi> HugoDaniel: Which one?
05:55:37 <HugoDaniel> persistent
05:55:50 <HugoDaniel> yesod uses persistent, but you can use it where you might seem fit
05:56:10 <iron_houzi> OK. Haven't heard of that one. Thanks .. ahh, I've heard of yesod
05:56:26 <HugoDaniel> iron_houzi: http://hackage.haskell.org/package/persistent
05:56:42 <HugoDaniel> there are probably more
05:57:09 <iron_houzi> HugoDaniel: Do you know how I can use haskell to communicate with mod-auth-token?
05:58:39 <iron_houzi> Also, PHP is very easy to integrate into a webserver, and Python uses WSGI, what do I need on my Apache server to communicate with a Haskell webapp?
05:59:02 <bennofs> iron_houzi: there is a cgi package for haskell
05:59:11 <bennofs> @hackage cgi
05:59:11 <lambdabot> http://hackage.haskell.org/package/cgi
05:59:21 <bennofs> I haven't used it though
05:59:56 <HugoDaniel> or fastcgi
06:00:11 <iron_houzi> ..but this is what every webapp developer using haskell is using on their web servers?
06:00:15 <HugoDaniel> or just do reverse proxy to the webapp
06:00:21 <HugoDaniel> no
06:00:29 <HugoDaniel> there are many dif. use cases
06:01:07 <yitz> iron_houzi: if you want to do something low-level like cgi, use wai instead.
06:01:21 <HugoDaniel> lets do a ghc 7.6.3 birthday party ?
06:01:42 <bennofs> HugoDaniel: i'd rather do a GHC 7.8 release party, if it ever gets released
06:02:14 <HugoDaniel> 21st of april :D
06:02:48 <Algebr> iron_houzi: Maybe this stack q could help? http://stackoverflow.com/questions/1975331/how-do-i-write-cgi-scripts-using-haskell
06:14:30 <ion> CGI is evil and FastCGI is nasty, too.
06:15:31 <ion> iron_houzi: http://www.haskell.org/haskellwiki/Web/Frameworks
06:17:21 <yitz> iron_houzi: just to be clear - i agree with ion. wai is only if you really want to deal with requests and response manually, like in cgi.
06:19:44 <ion> If you use WAI, you should be able to just use http://hackage.haskell.org/package/warp to make your stuff accessible over HTTP. Then you can make Apache forward the requests to your service without transforming them to a weird protocol that‚Äôs kinda HTTP but not quite.
06:20:30 <techtangents> Hi! Does anyone know if Hackage has an "alternating list" data structure? e.g. data ABList a b = ABNil | a :/ ABList b a. I can't seem to find one. If there isn't one, I might write one for fun.
06:23:07 <iron_houzi> Thanks for the insight .. now that I think about it, I just need a database for the users and a webapp that will take the users email as input and send an email with a download token, iff the email is authorized. Does any of the web frameworks provide hooks to sendmail or OpenSMTPd - preferrably OpenSMTPd.
06:23:13 <iron_houzi> ?
06:25:48 <techtangents> Don't know if you need a "hook" per se. You just need to send an SMTP message when handling a HTTP request. There seems to be a few SMTP clients on Hackage.
06:26:41 <techtangents> Can't see any that directly pass to sendmail or OpenSMTPd. You could always launch a process.
06:27:35 <iron_houzi> techtangents: Do you know if I could do it through a gmail-account or something similar?
06:28:07 <techtangents> Sending email doesn't require an email address, just an SMTP server.
06:28:57 <techtangents> See, something like this: http://hackage.haskell.org/package/HaskellNet-0.3.1/docs/Network-HaskellNet-SMTP.html
06:28:57 <techtangents> you connect to an SMTP server. That SMTP server could be gmail.
06:29:05 <iron_houzi> I know, I'm just unclear as to how I can get haskell to programatically utilize SMTP
06:29:08 <iron_houzi> Ahh.
06:29:29 <iron_houzi> I'd prefer to use my own SMTP server. Thanks for the link.
06:29:35 <techtangents> http://hackage.haskell.org/package/smtps-gmail
06:29:52 <iron_houzi> Great!
06:30:17 <iron_houzi> This is going to be fun!
06:30:43 <techtangents> :) Good to hear.
06:31:13 <techtangents> I haven't used any of those libraries, btw - just searching hackage :)
06:32:46 <notdan> Is there a recusrion scheme that is like `map`, but which also uses the rest of the list/structure as helper?
06:34:37 <bennofs>  notdan what type should that have?
06:35:18 <Rarrikins> Probably ([a] -> b) -> [a] -> [b]
06:35:35 <bennofs> Or maybe like (([a], a, [a]) -> b) -> [a] -> [b]?
06:35:54 <notdan> (a -> [a] -> b) -> [a] -> [b]
06:35:57 <ion> rarrikins: Looks like Control.Comonad.extend
06:36:08 <iron_houzi> I'm just a bit unclear about how to use mod-auth-token with haskell - Do I use WAI for this?
06:36:09 <techtangents> The second one looks like a list zipper.
06:36:20 * iron_houzi like zipping lists
06:36:52 <Rarrikins> notdan: a -> [a] -> b there is equivalent to [a] -> b
06:37:16 <notdan> hm
06:37:38 <notdan> anyway, the function I want is a special case of paramorphism apparantly
06:39:23 <bennofs> :t \f -> zipWith f <*> iterate (drop 1)
06:39:24 <lambdabot> (a -> [a] -> c) -> [a] -> [c]
06:39:30 <Thra11> Hello. I am wondering why Data.Set doesn't have any "With" functions (insertWith, unionWith, etc.)
06:39:46 <bennofs> @let mapWithRest f = zipWith f <*> iterate (drop 1)
06:39:47 <lambdabot>  Defined.
06:39:59 <bennofs> > mapWithRest show [1,2,3,4,5]
06:40:01 <ion> > zip (iterate (drop 1) "foobar") (tails "foobar")
06:40:01 <lambdabot>  Couldn't match type `[GHC.Types.Char]' with `[a0] -> c0'
06:40:01 <lambdabot>  Expected type: a0 -> [a0] -> c0
06:40:01 <lambdabot>    Actual type: a0 -> GHC.Base.String
06:40:02 <lambdabot>  [("foobar","foobar"),("oobar","oobar"),("obar","obar"),("bar","bar"),("ar","...
06:40:18 <bennofs> > mapWithRest (,) [1,2,3,4,5]
06:40:21 <lambdabot>  [(1,[1,2,3,4,5]),(2,[2,3,4,5]),(3,[3,4,5]),(4,[4,5]),(5,[5])]
06:40:41 <bennofs> @let mapWithRest' f = zipWith f <*> tail . iterate (drop 1)
06:40:41 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
06:40:49 <bennofs> @let mapWithRest' f = zipWith f <*> (tail . iterate (drop 1))
06:40:51 <lambdabot>  Defined.
06:40:57 <bennofs> > mapWithRest' (,) [1,2,3,4,5]
06:40:59 <lambdabot>  [(1,[2,3,4,5]),(2,[3,4,5]),(3,[4,5]),(4,[5]),(5,[])]
06:41:24 <bennofs> > inits [1,2,3,4,5]
06:41:25 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
06:41:34 <bennofs> > tails [1,2,3,4,5]
06:41:35 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
06:42:42 <bennofs> :t \f -> map (f <$> head <*> tail) . tails
06:42:43 <lambdabot> (a -> [a] -> b) -> [a] -> [b]
06:43:18 <ion> @type \f xs -> [ f y ys | (y:ys) <- tails xs ]
06:43:19 <lambdabot> (a -> [a] -> t) -> [a] -> [t]
06:56:30 <iron_houzi> Sorry if the answer was already given to me. Either way I'm still confused about how I can get haskell to work with mod-auth-token: https://code.google.com/p/mod-auth-token/
06:57:25 <iron_houzi> ..or be able to do something similar without using this mod..
07:00:33 <remib> Hi!
07:01:16 <remib> Not really a haskell question but: What's a way to define fibonacci without "double" recursion and without playing with lists ?
07:03:33 <WarzoneCommand> remib: you can tuple the two values I guess
07:03:41 <ClaudiusMaximus> remib: powers of a matrix
07:05:16 <sleuth> you can also get a Fib generating function
07:09:16 <davd> which traversal is implemented when using deriving Foldable? is there only one valid assuming some laws?
07:13:21 <nh2> Cale: I worte a benchmark for what we discussed yesterday: http://lpaste.net/102328 unfortunatly it seems to be n*logn
07:13:43 <jmcarthur> i just discovered that SPECIALISE pragmas on recursive functions over GADTs can for some call sites make the functions inlinable (by specializing away all the cases that actually have the recursive calls). unfortunately, GHC gives you a warning that you're SPECIALISING non-overloaded functions, even though it's actually helpful.
07:14:32 <jmcarthur> i'm actually thinking that adding such specializations automatically when they would make something inlinable might be a worthwhile optimization
07:18:12 * hackagebot learn-physics 0.3.1 - Haskell code for learning physics  http://hackage.haskell.org/package/learn-physics-0.3.1 (ScottWalck)
07:19:09 <remib> Yeah, but how to define it ?
07:20:36 <heatsink> You could have rules like forall x y a b. f x y (C1 a b) = f1 x y a b; forall x y c. f xy (C2 c) = f2 x y c
07:21:20 <heatsink> As long as f1 and f2 call f, and f calls itself, you can get GHC to inline f1 and f2
07:22:08 <anon_555> hi
07:22:08 <anon_555> does anyone have the list of lab exercise to perform on haskell
07:22:08 <anon_555> such as we do in lab such as making functions
07:23:53 <anon_555> hey
07:31:53 <ThatTreeOverTher> in gtk2hs, how do I receive buttonPressEvents from EventBoxes?
07:33:39 <HugoDaniel> ThatTreeOverTher: i never used gtk2hs sorry :(
07:34:12 <HugoDaniel> have you seen the hello world example ?
07:34:22 <ThatTreeOverTher> yep, I somehow just got it to work
07:34:42 <ThatTreeOverTher> I have no idea what I did, but this did it:   eb `on` buttonPressEvent $ tryEvent $ do    liftIO $ putStrLn "cheese"
07:35:00 <ThatTreeOverTher> what's liftIO? couldn't tell you, but it makes things work
07:35:22 <HugoDaniel> https://github.com/gtk2hs/gtk2hs-hello/blob/master/src/hello.hs
07:35:33 <prophile> :t liftIO
07:35:34 <lambdabot> MonadIO m => IO a -> m a
07:35:34 <HugoDaniel> ahah
07:35:38 <HugoDaniel> yes yes
07:35:48 <HugoDaniel> whenever you are working in a monad
07:35:56 <HugoDaniel> if that monad has a MonadIO instance declared
07:35:59 <HugoDaniel> you can do IO in it
07:36:04 <HugoDaniel> by "lifting" the IO function
07:36:37 <HugoDaniel> liftIO reads something like this: lift this IO function so that it works in the current monad im working in
07:36:56 <HugoDaniel> im not sure if thats a clear explanation to you or not :/
07:38:14 * hackagebot yesod-recaptcha 1.2.2 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-1.2.2 (FelipeLessa)
07:40:55 <randomclown> I have a function f :: x -> x
07:41:10 <randomclown> can somebody remind me how do I execute it until I get the fixed point for a particular x?
07:41:38 <prophile> fix f
07:41:52 <prophile> or more explicitly let x = f x in x
07:43:16 * hackagebot chuchu 0.4.5 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.4.5 (FelipeLessa)
07:43:18 * hackagebot Hipmunk 5.2.0.13 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.13 (FelipeLessa)
07:43:43 <randomclown> prophile: but fix f is of type x
07:44:08 <prophile> randomclown: yeah...
07:44:17 <prophile> the fixed point of a function from x to x is an x
07:44:24 <prophile> *the least fixed point
07:44:33 <jophish> yo
07:44:36 <ClaudiusMaximus> randomclown: 'iterate f x0' then check the resulting list for convergence to a fixed point (there are at least two meanings of fixed point - one is related to definedness like prophile's example, another is numerical where you might want to have some measure of approximate equality)
07:44:44 <anon_555> hi
07:44:47 <anon_555> does anyone have the list of lab exercise to perform on haskell
07:44:50 <anon_555> such as we do in lab such as making functions
07:45:53 <heatsink> There is a list of exercises in Project Euler.  They are algorithm exercises, but you can use them to practice Haskell.
07:46:10 <bennofs> anon_555: there is 99 haskell problems
07:46:25 <jophish> I have a class Pretty a where pretty :: a -> Doc. Doc is a type used for pretty printing values. I'd like to add an instance for Show for every Pretty instance, but obviously this can't be done in vanilla Haskell. What techniques are there for doing this besides adding an instance manually for each pretty type
07:46:27 <SpaceWizard> but a monoid ain't one.
07:46:41 <bennofs> anon_555: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
07:46:55 <anon_555> ok thank you guys
07:46:57 <anon_555> and
07:46:59 <anon_555> main = putStrLn "Hello World!"
07:47:06 <anon_555> i have saved it to hh.hs
07:47:21 <anon_555> and when i open it in windows i only get
07:47:30 <heatsink> jophish: You can use template haskell to create Show instances for a list of types
07:47:31 <bennofs> jophish: write a newtype wrapper, like newtype WrappedPretty a = WrappedPretty a, and then add instance Pretty a => Show (WrappedPretty a)
07:47:33 <anon_555> main>
07:47:45 <bennofs> anon_555: type :main
07:48:01 <jophish> bennofs: that'll require FlexibleInstances, right?
07:48:16 * hackagebot crypto-conduit 0.5.3 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.5.3 (FelipeLessa)
07:48:21 <flebron> Is every free theorem the coherence condition of some natural transformation derived from the polymorphism of the function?
07:48:27 <jophish> heatsink: I've not played about with TH yet
07:48:44 <bennofs> jophish: I don't think it does
07:48:45 <anon_555> why we have to type :main. Isn't that main is to suppose to load at beginning as like in python
07:49:20 <bennofs> anon_555: it's because you opened the ".hs" file. A ".hs" source file will be loaded with GHCi, the interactive haskell environment
07:49:35 <klugez> anon_555: Haskell is a compiled language, so you would first compile to file into an executable. Running that executable would start execution in the main action.
07:49:42 <bennofs> anon_555: if you want to create an executable file, you'll have to compile your source hs first
07:50:00 <klugez> anon_555: As bennofs said, now you opened the interpreter with hh.hs loaded.
07:52:20 <bernalex> are functions... a type?
07:53:13 <jophish> bennofs: functions are values
07:54:07 <bernalex> jophish: yes, obviously. but prelude says "These built-in types are defined in the Prelude [...]: List type, Tuple types, Trivial type, Functions.
07:54:34 <Saizan_> i guess it should have said "Function types"
07:54:36 <jophish> it may be referring to the type constructor (->)
07:54:46 <bernalex> jophish: it is
07:55:20 <Algebr> I'm confused about point free style, for example, how can `f = (+ 1)` work when the left side has no parameters?
07:55:25 <Saizan_> A -> B is a type
07:55:42 <srhb> Algebr: That's a case of operator sections
07:55:42 <bernalex> Saizan_: I see
07:55:49 <bernalex> Algebr: it's a partially applied function.
07:55:56 <srhb> Algebr: It's quite simply translated to \x -> x + 1
07:56:02 <Algebr> Ah, got it.
07:56:04 <srhb> Algebr: Vice versa if you move the operand.
07:58:54 <Krakarn> > (-2) 2
07:58:55 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
07:58:55 <lambdabot>    arising from the ambiguity check for `e_122'
07:58:55 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
07:58:55 <lambdabot>    bound by the inferred type for `e_122':
07:58:55 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
07:59:02 <FireFly> "Trivial type", huh?
07:59:12 <Krakarn> > (()2) 2
07:59:13 <lambdabot>  Couldn't match expected type `a0 -> a1 -> t0' with actual type `()'
07:59:26 <Krakarn> oh right it doesn't work because of the minus sign
07:59:27 <srhb> Minus is a bit special
07:59:31 <srhb> Right
08:03:10 <Flonk> I don't quite understand why I can even apply things to an arrow
08:03:19 <Flonk> It's as if " " (function application) was overloaded
08:03:36 <Flonk> > (arr id) 2
08:03:37 <lambdabot>  2
08:03:49 <bennofs> Flonk: it's because (->) is an instance of Arrow
08:04:19 <bennofs> Flonk: so in (arr id) 'c', ghc inferes that arr id must be of type Char -> Char
08:05:17 <bennofs> Flonk: So it tries to match Arrow a => a b b with (Char -> Char). (Char -> Char) is the same as (->) Char Char, so it infers that a must be (->) and b must be Char
08:05:42 <srhb> Flonk: You can make it clearer to yourself by making some (->) instances of your own
08:05:45 <bennofs> Flonk: now it checks that there exists an instance Arrow (->), which there indeed is
08:05:53 <Flonk> bennofs: Ah yes, that makes sense
08:06:44 <Flonk> bennofs: That cleared it up, thanks!
08:08:20 * hackagebot diagrams-qrcode 1.1 - Draw QR codes to SVG, PNG, PDF or PS files.  http://hackage.haskell.org/package/diagrams-qrcode-1.1 (FelipeLessa)
08:13:40 <jophish> Is there a nice way to get a stack trace when error or undefined is evaluated?
08:13:42 <jophish> using GHC
08:14:03 <jophish> internet trawling hasn't uncovered any really useful answers
08:14:11 <heatsink> You can compile with profiling and then run with +RTS -xc
08:17:35 <jophish> hmm, that doesn't seem to give me much useful information. I'll look a little further
08:19:16 <heatsink> GHC's stack is not as informative as in most other languages
08:19:27 <schlegel> jophish: Try compiling with -auto-all -caf-all to include all definitions in the cost centre stack
08:19:52 <heatsink> Oh, I forgot about that
08:20:03 <schlegel> np
08:21:04 <jophish> schlegel: ah, much better
08:21:21 <jophish> Thanks, heatsink, schlegel
08:22:06 <schlegel> Just for reference, the first link when you Google `ghc stack trace` tells you both these things :P : http://www.haskell.org/haskellwiki/Debugging
08:24:53 <jophish> schlegel: ah, egg and my face were in alignment
08:25:00 <jophish> I swear I googled this!
08:27:05 <Algebr> General Question: How exactly does a program get a handle on stdin and friends? Presumably the operating system gives the program a handle on it?
08:28:15 <merijn> Algebr: Pretty much
08:28:23 * hackagebot edenmodules 1.2.0.0 - Semi-explicit parallel programming library  http://hackage.haskell.org/package/edenmodules-1.2.0.0 (JostBerthold)
08:28:45 <merijn> Algebr: Although, if you wanna know the details of stuff like this, you'll want to get a unix programming book
08:28:58 <Algebr> merijn: But how does that happen? Is there like a convetional memory address that everyone just calls stdin?
08:29:13 <Algebr> merijn: ah, so like stdin is different on say windows?
08:29:32 <merijn> Algebr: Well, maybe, it depends :p
08:29:44 <merijn> Algebr: In general, there is no such thing as a "handle" on unix
08:30:00 <randomclown> I missed printf so much I put IO in my monad transformer stack
08:30:04 <merijn> Algebr: Handles are a library abstraction wrapping the underlying notion of a file descriptor
08:30:12 <schlegel> In Unix stdin is just a special file descriptor
08:30:27 <merijn> Algebr: File descriptors are numbers that correspond to an entry into a process' file descriptor table
08:30:38 <merijn> Algebr: i.e. the kernel maintains a table of all files a process has opened.
08:30:56 <merijn> Algebr: By convention, entry 0 is stdin, 1 is stdout and 2 is stderr
08:31:29 <Algebr> So when I print something, the Haskell runtime asks the operating system for stdout?
08:31:37 <merijn> stdin, stdout and stderr can in fact be files instead of your terminal
08:32:07 <merijn> (i.e. when you run "cat foo >bar" you're changing stdout to be the file "bar", instead of your terminal)
08:32:25 <Algebr> much appreciated.
08:32:39 <merijn> Algebr: stdout in the haskell libraries is a wrapper for file descriptor 1, whatever that happens to be
08:33:20 <merijn> Algebr: A good in-depth book on these details and more is "Advanced Programming in the Unix Environment"
08:33:35 <Algebr> Ah, have that on the shelf ;p
08:33:58 <merijn> Algebr: In windows, *some* things are the same as windows implements several posix standards, but not all of them
08:39:54 <no-n> how can I find out if my ghc installation is 32-bit or 64?
08:40:24 <schlegel> ghc --info
08:40:32 <no-n> ty
08:41:54 <RPR> Is it possible to compile the 7.8  branch (head) with a ghc 7.8 binary install?
08:45:14 <schlegel> RPR: Of course!
08:45:41 <schlegel> In general building is supported with the two previous major releases
08:46:12 <schlegel> Take a look at https://ghc.haskell.org/trac/ghc/wiki/Building as you'll need a couple more things than just GHC to build it though
08:46:25 <RPR> Well the binary was bootstrapped off 7.4 and I'm bootstrapping from 7.8 is failing for me.
08:46:31 <RPR> Ok I'll look.
08:49:23 <schlegel> RPR: What exactly is failing?
08:49:42 <bjorkintosh> likely Fail is failing.
08:49:47 <bjorkintosh> budumtshhh!
08:50:18 <schlegel> *chirp chirp chirp*
08:50:19 <RPR> libraries/ghc-prim/cbits/popcnt.c:15:16:
08:50:19 <RPR>      error: conflicting types for ëhs_popcnt8í
08:50:19 <RPR>      extern StgWord hs_popcnt8(StgWord8 x);
08:51:19 <bjorkintosh> haha
08:51:52 <schlegel> You know, I may be wrong. I think I have a habit of putting my foot in my mouth
08:52:39 <RPR> Their was a recent commit on this mid-Feb.  Looking into it now.
08:54:06 <RPR> schlegel, FWIW I'm attempting to build HEAD origin/ghc-7.8 and not origin/master
08:57:27 <schlegel> Strange how recent is your working copy?
08:58:22 <RPR> fresh pull of the ghc repo.
08:58:57 <dinkarganti> I am having some issues on the mac : here is the error using otool : http://lpaste.net/102326
08:59:17 <RPR> commit  on 2/13 for issue #8748 addressed hd_popcnt and friends.
09:00:21 <schlegel> And commit on 3/24 changed the type signature https://ghc.haskell.org/trac/ghc/changeset/0e3a5514288ee37da185b58199f4684c6f2efa01/ghc
09:01:05 <Vincam> There is no haskell talking here...
09:01:09 <RPR> schlegel, Ok let me review everything to make sure I'm not missing something.
09:02:23 <favetelinguis> noob question: getting Could not find module 'TicTac.Essential' when running this cabal file and Tasty.hs file http://lpaste.net/102330
09:03:05 <RPR> schlegel, https://gist.github.com/anonymous/10007975  conflicting includes
09:06:00 <goldenwest> I'm using readProcess from System.Process inside ghci and getting some confusing results
09:06:43 <goldenwest> when I use readProcess "echo" ["hi"] "" => "hi\n" (which is what it should be)
09:06:59 <goldenwest> when I use readProcess "echo" ["-n", "hi"] "" => "hi" (which is what it should be)
09:07:20 <goldenwest> when I use readProcess "sed" [""] "hi" => "hi" (where is the trailing newline?)
09:07:55 <monochrom> does sed add more newlines than you give it?
09:08:31 <goldenwest> monochrom: on the command-line when you execute sed '' <<<"hi" then it prints hi and a newline
09:08:52 <goldenwest> monochrom: oh... maybe I'm wrong
09:09:14 <monochrom> how do you enter the hi part without newline and still have the shell know that you're done entering
09:09:15 <goldenwest> no... no I don't think I'm wrong
09:10:07 <goldenwest> monochrom: I might be mistaken, but I don't believe the carriage return you use to issue the command is included in the input that you give the command
09:10:39 <goldenwest> monochrom: my real question is why echo "hi" and sed '' <<<"hi" have different results in readProcess
09:10:41 <monochrom> how about you test with a file that definitely contains no newline so you don't have to theorize
09:11:13 <goldenwest> monochrom: well, that example definitely contains no newlines
09:11:34 <goldenwest> monochrom: I'm not even using the command-line in that example, I'm using readProcess from within ghci
09:11:59 <monochrom> I am talking about testing sed, not testing readProcess
09:12:42 <goldenwest> well, sed '' <<<"hi" definitely contains no newlines
09:12:54 <schlegel> RPR: Looks like your ghc-prim is behind
09:15:14 <schlegel> RPR: see this changeset https://ghc.haskell.org/trac/ghc/changeset/84d7b7dd2d91ec9cce154602669b97a084412cf2/ghc-prim
09:15:30 <RPR> schlegel, I noticed a git clean -xfd does not completely reset.  Maybe make maintainer-clean is leaving a dropping.    I'm going to clone the repo fresh.
09:15:34 <schlegel> RPR: Disclaimer - I've never built GHC from source, just trying to help
09:16:02 <schlegel> RPR: Make sure you're doing it like they do here https://ghc.haskell.org/trac/ghc/wiki/Building/GettingTheSources
09:16:20 <monochrom> I created a file of exactly two bytes, the h and the i, no newline. sed '' < myfile outputs no newline either.
09:16:57 <monochrom> therefore I impeach the shell's <<< as wrong
09:17:16 <monochrom> and the test sed '' <<<"hi" as invalid
09:17:24 <goldenwest> monochrom: when I do the same thing.... with sed '' <myfile | cat -A
09:17:29 <goldenwest> monochrom: I get hi$
09:17:47 <goldenwest> monochrom: for there to not be a newline would mean that you command-line would be on the same line as the output
09:17:53 <goldenwest> monochrom: as in echo -n "hi"
09:18:05 <goldenwest> monochrom: echo -n "hi" | cat -A gives just "hi" not "hi$"
09:18:32 <monochrom> that $ is the shell's prompt
09:19:28 <goldenwest> monochrom: no it's not... my shell prompt is ~:
09:19:39 <goldenwest> monochrom: cat -A uses that to specify the end of the line
09:19:55 <goldenwest> monochrom: thanks for listening and the attempt at helping... I'll look into it more and get back to you
09:20:05 <monochrom> I get no $
09:20:31 <goldenwest> are you piping to cat -A?
09:20:38 <monochrom> my prompt is trebla@albert-book:~/tmp$ and I get hitrebla@albert-book:~/tmp$
09:20:40 <goldenwest> cause then we could be getting different results based on versions
09:20:42 <monochrom> yes
09:21:08 <goldenwest> hm, interesting
09:21:17 <schlegel> for me `sed '' <<< "hi" | cat -A` prints `hi$`
09:21:30 <goldenwest> me too
09:21:55 <goldenwest> sed '' <myfile | cat -A prints `hi$` for me too though
09:22:11 <schlegel> What is the issue here
09:22:12 <monochrom> how many bytes are there in myfile?
09:22:31 <monochrom> what does ls -l say?
09:22:45 <tlevine> In attoparsec, how do I ask for all of the characters until the next space
09:22:45 <monochrom> in fact, what does od say too?
09:23:04 <tlevine> so like /^\(.*\) /
09:23:09 <goldenwest> monochrom: gah, you're right - my bad
09:25:27 <schlegel> tlevine: I would imagine `takeWhile . notInClass " "`
09:25:55 <schlegel> Actually that's not the fastest way
09:27:28 <schlegel> Try `takeWhile . (==20)`
09:27:46 <schlegel> I mean `takeWhile . (!=20)`
09:28:18 <schlegel> gah I need sleep
09:28:40 <schlegel> s/!=//=/
09:38:46 <tlevine> heh schlegel it was even simpler
09:38:52 <tlevine> takeWhile (/=' ')
09:38:55 <tlevine> thanks
09:39:51 <tlevine> i guess the regex i gave was wrongn
09:40:25 <tlevine> it should have been more like /^([^ ]*) /
09:42:53 <__zeratul__> Hey, I'm writing a simple tic-tac-toe program as a learning exercise, and need help constructing the data
09:43:06 <__zeratul__> Anyone around?
09:43:41 <__zeratul__> I've got: data Board = Board Move Move Move Move Move Move
09:43:52 <__zeratul__> And: data Move = Move Maybe String
09:44:01 <__zeratul__> But I get the error: Expecting one more argument to `Maybe'
09:44:14 <monochrom> data Move = Move (Maybe String)
09:44:41 <c_wraith> Probably shouldn't use String, though.  Should use like (Int, Int), or something.
09:44:44 <monochrom> but why use String?
09:44:59 <__zeratul__> Hm.. was thinking of storing 'x' and 'o'
09:45:37 <__zeratul__> So each Move, (or maybe I should call it position) could be 'x', 'o', or Nothing
09:45:48 <monochrom> since there are only two possibilities, String is ill-fit
09:45:51 <c_wraith> __class__: that's not very helpful information
09:45:53 <c_wraith> err
09:45:56 <c_wraith> __zeratul__:
09:46:00 <c_wraith> (sorry __class__ )
09:46:26 <c_wraith> __zeratul__: moves always alternate between x and o.  You seem to be keeping them in order, so why do you need to know which was which?
09:46:48 <c_wraith> __zeratul__: on the other hand, that representation contains no information about where the player actually moved, which is.. kind of important
09:47:00 <schlegel> tlevine: For regex I would have done /(.*?) /
09:47:52 <monochrom> when you only have two possibilities, you create a data type for exactly those two possibilities.
09:47:59 <__zeratul__> How would that look
09:48:14 <monochrom> data Whee = FirstCase | SecondCase
09:49:19 <joeyh> hackage used to have a tarball of all the sources of every package on it. I can't see to find that on the new hackage, anyone know?
09:50:06 <monochrom> in fact, since the only way you use those two possibilities is to put it under Maybe, you may as well create 3 possibilities and skip Maybe.
09:50:16 <monochrom> data Move = FirstCase | SecondCase | Blank
09:50:36 <__zeratul__> So like: data Position = X | O | Nothing
09:50:51 <monochrom> you cannot use the word Nothing
09:50:57 <__zeratul__> Oh okay
09:51:27 <__zeratul__> Then this Move/Position data needs to also know about the position on the board. So how would also store that
09:51:39 <schlegel> Does it?
09:52:14 <__zeratul__> How else would you store that?
09:52:21 <schlegel> In the Board
09:53:13 <__zeratul__> Okay, so: data Board = Board Position Position Position Position Position Position
09:53:27 <__zeratul__> First Position being top-left, second being top-center, etc.?
09:53:30 <monochrom> data XOB = X | O | Blank; data John = J XOB Int Int
09:54:09 <schlegel> Or data Symbol = X | O; data Square = Either Int Symbol
09:58:27 <__zeratul__> How would I store the six squares? Just keep them in a list?
09:58:34 <__zeratul__> *9 squares
10:01:22 <schlegel> You could either do: data Board = Board Square Square Square Square Square Square Square Square Square
10:01:30 <schlegel> or data Board = Board [[Square]]
10:01:36 <__zeratul__> Oh cool
10:02:04 <schlegel> And once GHC 7.8 comes out you can do data Board = List 3 (List 3 Square)
10:02:41 <schlegel> Where List uses TypeLits to do some dependent typing
10:02:59 <__zeratul__> That looks great
10:03:06 <__zeratul__> More explicit than just [[Square]]
10:03:08 <c_wraith> schlegel: there are enough problems with that in 7.8 that I wouldn't recommend it yet.
10:03:19 <schlegel> ah alright
10:03:28 <c_wraith> schlegel: the current problem in 7.8 is that you can't define an Eq instance for that type
10:03:55 <c_wraith> schlegel: because GHC doesn't know that (n + 1) == (m + 1) implies n =m m
10:04:02 <c_wraith> err.  n == m
10:04:07 <schlegel> Ah yeah I saw that
10:04:17 <c_wraith> In theory, it'll know that in 7.10
10:04:18 <migimunz> given a function f :: a -> b -> c, what would be the best way to partially apply it with a 'b' type value, so that I get a -> c? I could write a lambda, but I was wondering if there was a more concise way.
10:04:33 <schlegel> flip f b
10:04:38 <c_wraith> But it's getting into the realms of proof searches, and those aren't fun
10:05:08 <schlegel> :t flip
10:05:09 <lambdabot> (a -> b -> c) -> b -> a -> c
10:05:21 <migimunz> schlegel, actually my problem involves a function with three parameters, I suppose I could apply it to the first one and then flip, but at that point a lambda would be more elegant. Thanks!
10:05:22 <schlegel> c_wraith: Yeah I see what you mean
10:05:44 <guesting> Does anyone have any experience with threepenny-gui? I need a listbox but the syntax is very confusing and the examples are not helping me. Can anyone explain it better?
10:06:13 <schlegel> migimunz: You still want to apply the second parameter though?
10:06:29 <schlegel> because c in that case can be d -> e
10:06:51 <migimunz> all except the second one. I have a -> b -> c -> d, and I'd like to get b -> d
10:07:40 <schlegel> Yeah I'd just write it out
10:07:59 <favetelinguis> could someone plz explain why module TicTac.Essential is not found in this code http://lpaste.net/102330
10:08:03 <migimunz> yeah, looks like I'm overcomplicating it :) Thanks
10:08:12 <khyperia> @pl (\x -> f a x b) -- 'cause this will probably blow up
10:08:12 <lambdabot> flip (f a) b
10:08:36 <khyperia> yeah, that's confusing
10:08:56 <migimunz> are there docs of some kind for the lambdabot?
10:09:22 <joe9> Is there a better way of understanding this the "Partially ordered sets" section of http://en.wikiversity.org/wiki/Introduction_to_Category_Theory/Products_and_Coproducts_of_Sets
10:09:39 <vlatkoB> Is there a function to unpack ByteString Word8 to String?
10:09:44 <joe9> especially the line "A partial order is a binary relation "‚â§" over a set P which is reflexive, antisymmetric, and transitive, "
10:10:04 <joe9> why use "<="? Isn't there any other operator?
10:10:29 <schlegel> Because that's precisely the use of that operator :P
10:10:49 <monochrom> I don't understand your objection. is it simply you don't like that symbol?
10:10:56 <joe9> schlegel: Is "<=" still "less than equal to"?
10:11:44 <__zeratul__> Ok, I think I've got my data setup. But how would I initialize this board:
10:11:48 <joe9> monochrom: not from my personal preference. but, does the operator still mean "less than equal to.".
10:11:49 <schlegel> yes, just since it's a partial order you don't necessarily have forall a, b either a <= b or b <= a
10:11:55 <__zeratul__> data Move = X | O deriving (Eq, Show)
10:11:56 <__zeratul__> data Square = Either Int Move
10:11:57 <__zeratul__> data Board = Board [[Square]]
10:12:14 <schlegel> It's not the 'standard' lte but it's still lte
10:12:16 <monochrom> that is a trick question. I'll just say yes and move on.
10:12:21 <__zeratul__> this throws an error: initialBoard = Board [[1,2,3],[4,5,6],[7,8,9]]
10:12:48 <schlegel> __zeratul__: You need to create Squares
10:13:12 <__zeratul__> Is there a succinct way to map Square constructor across this?
10:13:27 <schlegel> oh uh make Square and Board type synonyms
10:13:43 <schlegel> So type Square = .., type Board = ..
10:13:57 <schlegel> Then you can (map (map Left) [[1,2,3],[4,5,6],[7,8,9]])
10:14:33 <FireFly> joe9: it's "just a variable", but that particular symbol is used because it carries an intuition of what it means, I suppose
10:15:25 <joe9> FireFly: ok, thanks.
10:15:42 <__zeratul__> schlegel: Make square and board type synonyms of what exactly?
10:15:57 <schlegel> Just what you already have
10:16:09 <joe9> What does "partiall ordered" in the word "partiall ordered set" mean? What is "partially ordering"?
10:16:18 <joe9> s/partiall/partially/
10:16:26 <__zeratul__> So I would have:
10:16:27 <__zeratul__> data Square = Either Int Move
10:16:27 <__zeratul__> type Square = Either Int Move
10:16:33 <schlegel> yes
10:16:36 <__zeratul__> that seems repetitive
10:16:39 <tac> joe9: partial ordered means that your ordering is reflexive, transitive, anti-symmetric, but not neccesarily total
10:16:40 <schlegel> oh no
10:16:44 <schlegel> replace data Square
10:17:05 <__zeratul__> Use type instead of data
10:17:08 <schlegel> yes
10:17:15 <tac> Everything is less than or equal to itself, that if a <= b <= c, then a <= c, and that a <= b <= a, then a = b.
10:17:30 <tac> But you can't necessarily compare two elements. You might have a and b where neither a <= b nor b <= a.
10:17:47 <schlegel> __zeratul__: data creates a new type,  type introduces a synonym for a type and uses the same data constructors. newtype introduces a renaming of a type and
10:17:47 <schlegel> requires you to provide new constructors.
10:18:25 <__zeratul__> Oh okay
10:18:35 * hackagebot quantities 0.2.0 - Unit conversion and manipulation library.  http://hackage.haskell.org/package/quantities-0.2.0 (jdreaver)
10:18:40 <schlegel> joe9: a partially ordered set is a set combined with a partial order on that set
10:19:00 <schlegel> joe9: Where a partial order is defined precisely as you previously mentioned
10:23:31 <schlegel> joe9: An example would be the set of natural numbers with the relation of divisibility, we'll call that relation '|'. Then for all distinct a, b, c: a | a, a | b => not (b | a), a | b | c => a | c
10:23:40 <schlegel> So | is a partial order
10:24:18 <schlegel> But it's not the case that forall a,b: a | b or b | a so it's not a total order (ex a=3, b = 7)
10:29:32 <jophish> yo yo yo
10:29:40 <jophish> Does anyone use YouCompleteMe with neco-ghc
10:29:52 <joe9> schlegel: tac, thanks.
10:29:54 <jophish> I like YCM a lot more than NeoComplete
10:30:12 <joe9> jophish: using vim?
10:30:16 <jophish> joe9: yeah
10:30:39 <joe9> interested in emacs + evil?
10:30:52 <jophish> joe9: sorry, not a chance :)
10:31:34 <schlegel> joe9: BTW that example is on the page you linked hehe
10:32:11 <joe9> schlegel: I am reading it too. tHanks.
10:32:44 <Algebr> What does the (->) in `instance Functor ((->) r)` mean?
10:33:03 <Sinion> Hey, if I include {-# OPTIONS_GHC -hide-package monads-tf #-} at the top of my source file I get an error temp.hs:1:16:
10:33:05 <Sinion>     unknown flag in  {-# OPTIONS_GHC #-} pragma: -hide-package
10:33:07 <Sinion> temp.hs:1:16:
10:33:09 <Sinion>     unknown flag in  {-# OPTIONS_GHC #-} pragma: monads-tf
10:33:16 <monochrom> Algebr: it means function
10:33:39 <Sinion> Why is this and is there a way to hide that package with a pragma?
10:33:44 <Algebr> monochrom: That's what I thought initially, but then why can't I do :t (->)
10:33:56 <schlegel> Because (->) is a type constructor
10:34:01 <schlegel> :k (->)
10:34:02 <lambdabot> * -> * -> *
10:34:11 <monochrom> it is already a type. you don't bloody do :t on a type. you do :kind
10:34:32 <shachaf> schlegel: Perhaps the better way is {-# LANGUAGE PackageImports #-}
10:34:38 <shachaf> By schlegel I mean Sinion.
10:34:49 <Algebr> schlegel: neat, thansk
10:34:50 <Algebr> thanks
10:37:42 <Sinion> shachaf: Thanks, that works! But why does the hide-package version fail?
10:40:39 <monochrom> have you read the GHC user's guide about this?
10:41:04 <monochrom> I have. it says: OPTIONS_GHC accepts "dynamic" flags only. and -hide-package is not a dynamic flag.
10:42:34 <schlegel> Sinion: See section 4.2.2 in the GHC Users Guide and section 4.19 for the flag reference table
10:43:32 <Sinion> monochrom, schlegel: Thanks!
10:44:11 <RPR> hmmm,   8 cores/16 gig /SSD and the ghc build is still going and going and ...
10:44:52 <schlegel> RPR: Oh yay you got it to run. What was the fix/
10:45:12 <RPR> schlegel, oh that was 2 issues ago.  Just hit #3.
10:45:46 <schlegel> ?
10:46:38 <RPR> #2 was the util/haddock in the was bumped to depend on 7.9 (sigh)
10:46:59 <RPR> #3 is under investigation
10:50:24 <RPR> schlegel, For #1 I  purged everything out ruthlessly and the prim include issue went away.
11:18:57 <ReinH> edwardk: ping
11:19:56 <RPR> schlegel, some Template Haskell TH.ClassP import failure.  Punting for now and hitting the pool.
11:21:27 <dshad> Is it possible in Haskell to create a function that at first gets n (any natural number) of arguments of type a and than gets n arguments of type b?
11:22:32 <sipa> dshad: that would make its type dependant on the value passed...
11:22:34 <c_wraith> dshad: Well, you could fake it, but it'd be so fragile that it's easier to just say "no"
11:22:50 <Iceland_jack> sipa: It can be done using singleton naturals
11:23:10 <ReinH> dshad: why not make a function f :: [a] -> [b] -> c
11:23:12 <heatsink> Why not pass it a list of tuples?
11:23:14 <sipa> Iceland_jack: what would the type of that function be?
11:23:20 <c_wraith> sipa: it'd involve a class
11:23:33 <sipa> sure you could do something like printf
11:23:36 <copumpkin> ReinH: that function won't be very interesting
11:23:36 <c_wraith> sipa: the class definition would be recursive on the natural type
11:23:37 <heatsink> Using [(a, b)] ensures that there are n as and n bs
11:23:38 <ReinH> sipa: look at what printf does.... heh right
11:23:50 <sipa> but that would mean it would for example ignore extra arguments
11:24:02 <ReinH> heatsink: I wasn't sure that the n's were meant to be the same, but that makes sense
11:24:14 <copumpkin> ClaudiusMaximus: cool, thanks :) was trying to figure out if you'd explicitly excluded them or it was some oddity in my system that caused my build to fail without them
11:24:28 <copumpkin> I'd already added them back locally to get it working again
11:24:29 <ReinH> dshad: to avoid an XY problem, what do you want to use such a function for?
11:25:15 <dshad> I need so strange function because I using library(argParser) that need contructor with certain arguments order
11:25:30 <ReinH> So is there any recent work on invertible parsers? Perhaps leveraging lens for Iso, and edwardk's Contravariant?
11:25:54 <copumpkin> ReinH: I've been playing with related topics
11:26:01 <ReinH> I'm referring to stuff like http://camlunity.ru/swap/Library/Computer%20Science/Parsers/Invertible%20Syntax%20Descriptions.%20Unifying%20Parsing%20and%20Pretty-Printing.pdf
11:26:03 <copumpkin> mostly around binary parsing
11:26:04 <ReinH> copumpkin: cool
11:26:17 <ReinH> copumpkin: anything I can look at?
11:26:38 <ReinH> copumpkin: I'm also thinking of bytestream-based protocols like custom UDP payloads, etc
11:27:13 <heatsink> dshad, what type does the library require?
11:27:25 <ReinH> Hmm this one is relatively recent http://hackage.haskell.org/package/boomerang-1.4.2/docs/Text-Boomerang.html
11:27:42 <copumpkin> ReinH: https://github.com/copumpkin/java/blob/master/src/Java/Bytecode/Encoding.hs#L78 was a first attempt, but I didn't like how it ended up for more complex stuff (if you look at the classfile format in the same package, for example) and the types were getting ridiculous
11:28:04 <copumpkin> ReinH: more recent direction is guided by https://gist.github.com/copumpkin/90eabf3e033129ef9f48 and am experimenting with using something like this https://gist.github.com/copumpkin/9967290
11:28:16 <SwashBuckla> Is it possible to do IO things inside a MonadSnap ()? I would like to write to a file depending on the contents of `html': http://lpaste.net/102334
11:28:20 <ReinH> dshad: not a direct answer but you might want to look at optparse-applicative
11:28:34 <ReinH> copumpkin: oh you're working on JVM bytecode? Cool.
11:28:50 <copumpkin> ReinH: it was more out of curiosity about how the JVM worked and wanting to test my picklers :)
11:29:00 <ReinH> copumpkin: nice
11:29:14 <ReinH> SwashBuckla: well, what is MonadSnap?
11:29:41 <copumpkin> ReinH: I assume you've seen the original picklers paper that I complain about?
11:30:06 <copumpkin> (http://research.microsoft.com/pubs/64036/picklercombinators.pdf)
11:30:08 <SwashBuckla> ReinH: http://hackage.haskell.org/package/snap-core-0.3.1.1/docs/Snap-Types.html#t:MonadSnap
11:30:37 <dshad> heatsink, the library becomes really useful only if there is any good way to reorder function arguments.
11:30:42 <ReinH> copumpkin: I hadn't thanks
11:30:46 <schlegel> SwashBuckla: You can use liftIO
11:30:52 <ReinH> SwashBuckla: well it's a MonadIO
11:30:57 <dinkarganti> @SwashBuckla: We should be able to?? because MonadSnap is derived from MonadIO among others?
11:30:57 <lambdabot> Unknown command, try @list
11:31:00 <copumpkin> ReinH: ah, I think that was the first attempt at it, but I don't like the result much
11:31:09 <SwashBuckla> oh that's wicket
11:31:11 <SwashBuckla> wicked*
11:31:14 <SwashBuckla> I will try some things
11:31:19 <ReinH> SwashBuckla: the docs tell you how to do IO :)
11:31:27 <SwashBuckla> thank you schlegel, ReinH and dinkarganti
11:31:31 <copumpkin> ReinH: there's also a bit more here, if you want to see how it might be done in Agda: http://www.cse.chalmers.se/~nad/publications/danielsson-correct-pretty.pdf
11:31:36 <ReinH> although they fail at numbering the list correctly, it's number 6 ;)
11:31:41 <ReinH> copumpkin: thanks :)
11:31:55 <schlegel> SwashBuckla: I suggest completely reading the page you linked
11:32:30 <SwashBuckla> reading... ::rolleyes::
11:32:45 <SwashBuckla> I am a little trigger happy I suppose
11:32:55 <schlegel> You're not alone haha
11:32:58 <ReinH> copumpkin: "No guarantees are
11:33:01 <ReinH> woops
11:33:06 <ReinH> I hate it when line breaks get copied
11:33:12 <copumpkin> :)
11:33:12 <ReinH> copumpkin: No guarantees are made about ‚Äúprettiness‚Äù.
11:33:23 <ReinH> lol
11:33:34 <schlegel> Does anyone know of any Haskell shops in South Florida?
11:33:36 <copumpkin> :)
11:33:41 <ReinH> a correct-by-construction possibly-pretty-printer
11:33:43 <ReinH> I like it
11:34:22 <schlegel> I'm graduating with a Math/CS degree in Summer of next year and I'm trying to find something around me that isn't just PHP/ASP/Python
11:34:54 <SwashBuckla> programming language isn't everything :P
11:35:06 <heatsink> You can reorder function arguments with combinators like flip, uncurry, or unzip.  I still don't understand why you requie the arguments to be passed separately.
11:35:07 <SwashBuckla> but if you can get a job doing Haskell -- way cool
11:35:10 <heatsink> dshad ^
11:36:08 <schlegel> SwashBuckla: Yeah but the places that use Haskell tend to do things I'm interested in :P
11:36:17 <ThatTreeOverTher> How do I take the returned tuple of a function and put it into the arguments of another function?
11:37:00 <schlegel> ThatTreeOverTher: There's uncurry for 2-tuples
11:37:10 <heatsink> @djinn (a -> (b, c)) -> (b -> c -> d) -> (a -> d)
11:37:10 <lambdabot> f a b c =
11:37:11 <lambdabot>     case a c of
11:37:11 <lambdabot>     (d, e) -> b d e
11:37:24 <heatsink> @. pl djinn (a -> (b, c)) -> (b -> c -> d) -> (a -> d)
11:37:24 <lambdabot> (line 3, column 14):
11:37:24 <lambdabot> unexpected '>'
11:37:24 <lambdabot> expecting operator
11:37:26 <monochrom> case f1 x of (a,b,c) -> f2 a b c
11:37:39 <heatsink> There must be a way to compose djinn and pl
11:37:44 <ReinH> heh
11:39:00 <dshad> heatsink, the library combinators need contructor with certain order of arguments. But I have only one contructor and many different orders, that's why I need way to reorder arguments/
11:39:50 <heatsink> dshad, you can use functions like flip to reorder arguments
11:40:03 <heatsink> or you can use lambda expressions
11:40:45 <ReinH> There's that ridiculous package that gives you operators like $$$ $%% $%^ $^^ etc but no one uses it
11:41:17 <dshad> heatsink, flip, unzip, uncurry etc.. is too weak for me because contructor have about 20 arguments
11:41:21 <heatsink> Those look like censored curse words
11:41:45 <schlegel> @heatsink To be fair I wouldn't use what djinn output
11:41:45 <lambdabot> Unknown command, try @list
11:41:50 <schlegel> Whoops lol
11:41:56 <ThatTreeOverTher> I want to get the (x, y) from a gtk2hs eventCoordinates but it's of type "Control.Monad.Trans.Reader.ReaderT (GHC.Ptr.Ptr t0) IO (Double, Double)"... what do I do
11:42:06 <schlegel> :t (\f g -> uncurry g . f)
11:42:07 <lambdabot> (a -> (a1, b)) -> (a1 -> b -> c) -> a -> c
11:42:27 <ThatTreeOverTher> i'd like to unpack it into another function's arguments
11:42:42 <heatsink> dshad, your original problem only involved two fixed-length lists.  Now there are another 18 arguments.  I still don't understand the real problem.
11:43:10 <heatsink> There are lots of ways to make it easier to pass many arguments to a function or constructor, depending on what the real problem is.
11:43:51 <ReinH> dshad: do you have some code you could put in an lpaste?
11:43:59 <ReinH> A concrete example will be easier for us to work with
11:44:26 <ReinH> ThatTreeOverTher: how much do you know about monads?
11:44:37 <ThatTreeOverTher> ReinH, what's a monad
11:44:59 <schlegel> ThatTreeOverTher: Are you using do or >>=
11:45:07 <ThatTreeOverTher> schlegel, do
11:45:11 <ReinH> ThatTreeOverTher: have you written Haskell like do { line <- getLine; putStrLn line } ?
11:45:53 <ThatTreeOverTher> ReinH, this is my code (where eb is a gtk2hs EventBox) http://lpaste.net/102337
11:46:32 <ReinH> ThatTreeOverTher: if you have a value with the type you gave us before
11:46:34 <ReinH> That's a lot like:
11:46:37 <ReinH> :t getLine
11:46:37 <lambdabot> IO String
11:46:50 <schlegel> You can do (x, y) <- eventCoordinates
11:47:00 <ReinH> so you can do that, yes
11:47:46 <schlegel> "Control.Monad.Trans.Reader.ReaderT (GHC.Ptr.Ptr t) IO (Double, Double)" is "EventM t (Double, Double)"
11:47:52 <ThatTreeOverTher> so this would work: "    layoutMove layt eb ((x,y) <- eventCoordinates)"?
11:48:19 <ReinH> ThatTreeOverTher: no, that wouldn't be valid syntax. Put the (x,y) <- eventCoordinates on its own line.
11:48:41 <ReinH> ThatTreeOverTher: what's the type of layoutMove?
11:48:45 * hackagebot HStringTemplate 0.7.3 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.7.3 (SterlingClover)
11:49:18 <ThatTreeOverTher> ReinH, layoutMove :: (LayoutClass self, WidgetClass childWidget) => self -> childWidget -> Int -> Int -> IO ()
11:49:53 <ReinH> ThatTreeOverTher: ok then you'd use x and y there
11:50:14 <pavonia> You'll need liftIO then too: liftIO $ layoutMove widget x y
11:50:16 <ThatTreeOverTher> apparently the mouse has double locations, and I need ints
11:50:21 <schlegel> The way do { (x, y) <- eventCoordinates; blah x y } works is that it uses the function >>= defined in the EventM Monad instance to turn do { (x, y) <- eventCoordinates; blah x y }  into eventCoordinates >>= (\x y -> blah x y)
11:51:04 <benmachine> eventCoordinates >>= (\(x, y) -> blah x y)
11:51:16 <schlegel> Sorry yeah
11:51:54 <schlegel> ..damn brain
11:52:27 <ThatTreeOverTher> how do I convert doubles to ints?
11:53:04 <heatsink> floor, ceiling, truncate, or round
11:53:05 <pyon> Is there any name for "(a -> Either b c) -> [a] -> ([b], [c])" ?
11:53:28 <heatsink> It's a combination of map and partition
11:53:42 <pyon> Ah!
11:53:42 <heatsink> :t (\f -> partition . map f)
11:53:43 <lambdabot>     Couldn't match type `[b0]' with `a0 -> Bool'
11:53:43 <lambdabot>     Expected type: [a0] -> a0 -> Bool
11:53:43 <lambdabot>       Actual type: [a0] -> [b0]
11:53:51 <benmachine> :t partitionEithers
11:53:52 <lambdabot> [Either a b] -> ([a], [b])
11:53:57 <benmachine> :t partition
11:53:58 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
11:54:05 <pyon> Yeah, that.
11:54:14 <schlegel> :t (\f -> partitionEithers . map f)
11:54:15 <lambdabot> (a1 -> Either a b) -> [a1] -> ([a], [b])
11:55:00 <pyon> Thanks all!
11:55:05 <schlegel> I wish it would turn [a1, a, b] into [a..c]
11:55:39 <jophish> identity: here?
11:55:39 <schlegel> Is there a reason it doesn't?
11:55:46 <pyon> schlegel: Heh, we would need type-level programming facilities for building record / variant types.
11:55:49 <benmachine> schlegel: I don't understand the question
11:56:31 <schlegel> Having type return (a -> Either b c) -> [a] -> ([b], [c]) instead of (a1 -> Either a b) -> [a1] -> ([a], [b])
11:56:45 <pyon> Oh, you meant that.
11:56:46 <benmachine> schlegel: ohh, you just mean type variable names
11:56:59 <schlegel> Yeah sorry idk why I used that notation haha
11:57:28 <benmachine> schlegel: so the reason for that is I think GHC tries to keep type variables the same
11:57:32 <benmachine> so, like
11:57:34 <benmachine> :t map
11:57:34 <lambdabot> (a -> b) -> [a] -> [b]
11:57:39 <benmachine> you've got a's and b's there
11:57:42 <jophish> identity: I read in the logs that you were playing with YouCompleteMe. I've not got this working quite how I want with neco-ghc. Are you using it still?
11:57:43 <benmachine> :t partitionEithers
11:57:43 <lambdabot> [Either a b] -> ([a], [b])
11:57:45 <schlegel> Ah yeah that makes sense
11:57:48 <schlegel> Thanks
11:57:49 <benmachine> more a's and b's
11:58:12 <jophish> The issue is that it works fine when I prompt vim for the completions, however just typing doesn't seem to use neco-ghc's suggestions
11:58:14 <benmachine> so it turns one of the a's into an a1 to prevent ambiguity but otherwise leaves everything alone
11:58:38 <schlegel> Yeah I get it
11:58:48 <schlegel> Makes sense now
11:58:52 <benmachine> I noticed you got it but I'd started so I thought I might as well finish :P
11:59:12 * schlegel zips lip..er fingers
11:59:45 <benmachine> > zip "lip..er" "fingers"
11:59:46 <lambdabot>  [('l','f'),('i','i'),('p','n'),('.','g'),('.','e'),('e','r'),('r','s')]
12:00:00 <benmachine> (this is not intended to make sense)
12:01:03 * Fuuzetsu was reading into it
12:01:33 <Fuuzetsu> > zip "hlo" "el!"
12:01:34 <lambdabot>  [('h','e'),('l','l'),('o','!')]
12:02:02 <bakibour> Greetings is there any text editor tool that allows me to replace a function with the actual implementation?
12:02:15 <Fuuzetsu> bakibour: no
12:02:30 <Fuuzetsu> source isn't always available anyway
12:02:41 <bakibour> Is that just not useful or just not implemented?
12:02:50 <bakibour> Suppose it was.
12:03:50 <Fuuzetsu> it is not useful enough for anyone to bother with implementing it which would be a hassle (finding source, avoiding variable capture, properly inserting the function so that syntax still makes sense‚Ä¶)
12:04:57 <benmachine> bakibour: I think it's not a crazy idea, it might be quite cool, but it does sound like a lot of work and I can't think of any obvious uses for it
12:05:25 <bakibour> Well i often struggle when i see code to expand it conceptually.
12:05:56 <bakibour> I find it quite useful to do so when you want to explore what a function really does.
12:06:07 <benmachine> I wrote a tool once that would step-by-step compute an expression
12:06:12 <benmachine> and show you the steps as it did so
12:06:13 <bakibour> Also it would be totally awesome if you could do the same with the unification
12:06:16 <benmachine> unfortunately it didn't really work
12:06:25 <benmachine> oh, that's another of my project ideas :P
12:06:35 <bakibour> The unification thingy?
12:07:10 <benmachine> yes
12:07:26 <bakibour> How does Haskell unify anyway?
12:07:38 <benmachine> umm
12:07:46 <benmachine> the GHC type checker is... sophisticated
12:08:04 <benmachine> possibly many papers of cleverness have gone into it
12:08:05 <monochrom> Hindley-Milner type inference requires unification
12:08:13 <benmachine> but most of what it does most of the time isn't that hard
12:08:17 <heatsink> There is a difference between understanding unification, and understanding how to implement it efficiently.
12:08:27 <nicoo> s/sophisticated/so complicated only SPJ understands it nowadays/
12:08:29 <heatsink> You really should do the first part before getting to the second.
12:08:29 <nicoo> ftfy
12:08:57 <bakibour> Im just interested in how it works in general.
12:09:24 <bakibour> I did some stuff back then when i had a Prolog class, is it just the same or are there any substantial differences?
12:10:16 <heatsink> It's generally presented as solving a bunch of equations by reducing them to simpler equations, until you eventually get the form (VARIABLE = EXPRESSION) for everything
12:10:46 <dshad> http://lpaste.net/102338
12:10:59 <heatsink> To solve (a -> b) = (c -> d), you get the simpler equations a = b and c = d
12:11:14 <heatsink> I mean, a = c and b = d
12:11:21 <bakibour> heh just was about to ask :)
12:11:31 <bakibour> Ok i guess its the same then.
12:11:31 <heatsink> Then you substitute back.
12:11:42 <bakibour> As in Prolog i mean
12:11:52 <heatsink> That's first-order unification
12:12:19 <heatsink> There are also constraints, type families, and first-class polymorphism to make things complicated
12:12:28 <bakibour> :)
12:12:53 <bakibour> It would be really cool as i stated earlier to be able to inspect what the compiler does there.
12:13:18 <benmachine> it would certainly complicate the compiler to make that information directly available
12:13:19 <bakibour> Once you do a lot of stuff in the type system your "debugging" is on type level too.
12:14:00 <jonsterling> Can anyone think of a good name for this type? newtype T f g a = T { runT :: f a -> g a }. This is not a natural transformation.
12:14:49 <copumpkin> unnatural transformation
12:14:50 <enferex> I have a ByteString.  I just want to increment its ascii value by one.
12:14:55 <monochrom> transformation
12:15:01 <copumpkin> type NT f g = forall a. T f g a
12:15:05 <copumpkin> that makes it natural again
12:15:19 <copumpkin> immoral transformation?
12:15:33 <jonsterling> copumpkin: Lol yeah... I can't quantify the a though...
12:15:53 <copumpkin> more seriously, it looks like the natural extension of the usual functor product/coproduct stuff
12:15:59 <pavonia> enferex: map succ?
12:16:04 <NikolajK1> is there generally a notion of negating a type judgement? "\neg(x:A)"
12:16:06 <jonsterling> copumpkin: Do you have a link where I can read up on this?
12:16:16 <heatsink> dshad: Generally the way to handle this is to make each flag parser modify the options
12:16:23 <copumpkin> newtype Coproduct f g a = Coproduct (Either (f a) (g a))
12:16:29 <heatsink> that is, each parser returns a (CmdLnOptions -> CmdLnOptions)
12:16:39 <copumpkin> newtype Product f g a = Product (f a, g a)
12:16:52 <jonsterling> copumpkin: Oh, I see! That's interesting... So exponent?
12:16:57 <copumpkin> jonsterling: hrm, not that I can think of
12:17:12 <copumpkin> jonsterling: yeah, perhpas? not actually sure whether the parallel continues
12:17:19 <jonsterling> newtype g :^: f a = ...
12:17:33 <heatsink> if it detects an invalid combination of options, it saves the error message in the options.  The error can be checked and printed after parsing is complete.
12:17:45 <mirpa> dshad: do you know System.Console.CmdOpt?
12:17:50 <copumpkin> jonsterling: if you look at Ulf's original Agda tutorial, he has a small universe of functors like that
12:17:57 <jonsterling> Oh cool...
12:17:59 <copumpkin> he doesn't include exponentials, but I'm not sure if that's fundamental
12:18:07 <benmachine> jonsterling: that'd have to be (g :^: f) a
12:18:28 <benmachine> I'm not sure if the categorical exponent of functors is pointwise
12:18:38 <benmachine> I have a feeling it might not be
12:19:14 <copumpkin> yeah
12:19:35 <dshad> mirpa,: yes, but as I know it can't parse something like this 'utilite check -f -x all'
12:19:42 <enferex> Is there a function to convert a String into a series of Bits.  I did not see any 'Bits->String' in hoogle.
12:19:48 <benmachine> but this is really dredging the depths of my memory of my ill-fated attempt to learn topos theory
12:20:10 <jonsterling> benmachine: What does it mean for the exponent to be pointwise?
12:20:24 <benmachine> jonsterling: as in, G^F(x) = G(x)^F(x)
12:20:30 <jle`> enferex: what would an example of what you wanted to do be?
12:20:36 <jonsterling> benmachine: Oh, I see...
12:21:18 <enferex> jle`: Simply: I want to take a string, and treat it on the bit level, and just increment the string.
12:22:01 <jle`> a utf-8 string?
12:22:05 <enferex> yep
12:22:15 <copumpkin> Product (f :^: g) g -> f
12:22:17 <copumpkin> can you write that?
12:22:26 <copumpkin> err
12:22:33 <enferex> In more simple words, I want to iterate through the entire character space of a string
12:22:34 <jle`> well I guess you could convert it to a ByteString, which is a series of bytes
12:22:35 <copumpkin> a natural transformation
12:22:59 <pavonia> enferex: Have you tried "map succ"?
12:23:07 <copumpkin> I think you should be able to
12:23:29 <jle`> > succ 'a'
12:23:30 <lambdabot>  'b'
12:23:44 <enferex> pavonia: No, thank you!
12:23:50 <enferex> jle`: thanks as well!
12:24:02 <jle`> > succ '\123'
12:24:03 <lambdabot>  '|'
12:24:19 <dshad> heatsink, parser imported from library, so I can't modify it
12:24:20 <jonsterling> copumpkin: You mean is a natural transformation Product (f :^: g) g ~> f?
12:24:21 <pavonia> > pred '\0'
12:24:22 <lambdabot>  *Exception: Prelude.Enum.Char.pred: bad argument
12:24:29 <copumpkin> jonsterling: yeah, that'
12:24:43 <jonsterling> Lemme see... If there is, does that mean that :^: is well-behaved or something?
12:24:58 <copumpkin> that's one of the big pieces of being an exponential
12:25:04 <copumpkin> having an "evaluator"
12:25:09 <copumpkin> (x -> y, x) -> y
12:25:28 <copumpkin> pretty sure it just works for yours
12:25:35 <c_wraith> isn't (x -> y, x) more or less Store?
12:25:47 <copumpkin> that's not all that's needed, but I feel like some (all) of the rest of the stuff is given by parametricity
12:26:17 <heatsink> dshad: The library should have parser combinators for applying functions to the result of the parser.
12:26:22 <copumpkin> c_wraith: yep, I guess
12:26:33 <jonsterling> copumpkin: Cool, I'll try it out... What other properties are required for this to be a proper exponential?
12:26:38 <copumpkin> Cale: O Master of all that is CT
12:26:50 <heatsink> dshad: Is the return type of boolFlag "--verbose" a monad value?
12:26:53 <Cale> lol
12:26:59 <copumpkin> Cale: we summon thee
12:27:10 <benmachine> I can do this one :P
12:27:22 <benmachine> you basically need curry and uncurry
12:27:24 <copumpkin> I wanted him to just skip ahead
12:27:36 <copumpkin> and figure out if this thing made sense or not so I could move on :P
12:28:24 <Algebr> When I do `import foo (bar)`, that's same as `import foo bar`, right? Like when doing deriving, both `deriving Show` and `deriving (Show)` are the same thing
12:28:48 <Cale> wat
12:29:04 <jonsterling> copumpkin: Oh, I think it's going to have to be  (g :^: f) :*: f ~> g instead, right?
12:29:15 <benmachine> Cale: we want to know if the exponential of functors is pointwise
12:29:41 <Kron> Algebr: I don't think that second import statement is syntactically correct
12:29:47 <Cale> Algebr: The stuff in the parens in an import declaration are the specific symbols you would like to import. The parens are not optional in that case if you want to list any names at all.
12:29:52 <Kron> import foo (bar) isn't importing foo and bar
12:29:55 <dshad> heatsink: no, it isn't monad value
12:30:00 <Kron> it's importing the bar symbol from inside the foo module
12:30:12 <Cale> (They're both syntactically incorrect, because "foo" is not a valid module identifier)
12:30:25 <Cale> benmachine: ah
12:30:26 <Kron> well, yeah, but I assumed it to be a metasyntactica variable for some module
12:30:36 <Algebr> ah, yea, so looks like () is needed
12:30:50 <Kron> that would import nothing at all
12:30:55 <Kron> at that point, why import the module?
12:30:56 <heatsink> Is it applicative, dshad?  What type does andBy have?
12:31:05 <Kron> "import Foo" imports all of it
12:31:15 <Kron> "import Foo ()" imports none of it, as far as I know
12:31:23 <Algebr> Kron: Sorry, I mean looks like the parenethesises are needed
12:31:26 <Algebr> meant*
12:31:28 <Kron> ah yes, true
12:31:39 <Kron> also you can do this:
12:31:44 <Kron> "import Foo hiding (...)"
12:31:52 <Kron> which will import everything /but/ the bits in parentheses
12:31:54 <Kron> sometimes useful
12:32:25 <Algebr> Kron: Kind of annoying that only one module can be imported per import.
12:32:27 <enthropy> Kron: when has that worked?
12:32:40 <Algebr> would like to do `import Data.Char, Data.Array`
12:32:54 <enthropy> oh don't mean using a literal ...
12:33:11 <enthropy> Algebr: import Data.Char; import Data.Array -- is not much longer
12:33:13 <Cale> benmachine: I believe it's not quite pointwise...
12:33:22 <benmachine> Cale: right, that's roughly what I recall
12:33:24 <Kron> Algebr, one of the general ideas behind indentation-based--scope languages is to kind of force a single standardized way to code? I think?
12:33:28 <benmachine> not sure why though
12:33:43 <Kron> I've found a lot of somewhat rigid syntactic structures in haskell
12:33:49 <Cale> In that if you have functors F and G, then (F^G)(X) = (FX)^(GX) won't work
12:33:57 <Cale> (it's not functorial in X)
12:33:57 <benmachine> right
12:34:02 <benmachine> ah!
12:34:04 <benmachine> of course :P
12:34:11 <benmachine> duh
12:34:13 <copumpkin> good point
12:34:23 <copumpkin> jonsterling: sorry man
12:34:28 <jonsterling> Cale: Hmmm, OK... Is there a name for the operation T(F,G) := F(X)^G(X) then, if it's not proper exponentiation?
12:34:39 <Kron> enthropy: when has what worked?
12:34:48 <jonsterling> Or, that is, T(F,G,x) I mean
12:34:52 <benmachine> I remember functor exponentiation being vulnerable to some trick involving the Yoneda lemma
12:34:54 <Cale> Well, we can apply Yoneda to try to work out what the exponential ought to be
12:34:57 <enthropy> "import Foo hiding (...)"
12:35:08 <Kron> I used it here: https://github.com/AshleyMoni/QuadTree/blob/master/Data/QuadTree.hs
12:35:09 <enthropy> as an alternative to   "import Foo ()"
12:35:19 <Kron> oh, it's not an alternative
12:35:25 <benmachine> Nat(C(A,-),G^F) =~ G^F(A)
12:35:26 <Cale> We would have: (G^F)(X) = Hom(yX, G^F)
12:35:29 <Kron> it's just extra syntax I think people should know about
12:35:33 <Algebr> Kron: I guess, but it sure makes for tons of lines for imports.
12:35:41 <Kron> hah, so true
12:35:57 <benmachine> but Nat(C(A,-),G^F) is by definition Nat(C(A,-) x F, G)
12:36:05 <Cale> yes
12:36:11 <Algebr> So is a .hi like a dll?
12:36:12 <benmachine> or naturally isomorphic, anyway
12:36:21 <Cale> yeah, naturally isomorphic
12:36:27 <Kron> I think an .hi is more like an .o
12:36:33 <Kron> though I'll be honest I don't know
12:36:54 <benmachine> so you can just decide that G^F(A) is that thing
12:37:01 <Algebr> Hmm, so I presumably can't get the source code that produced the .hi
12:37:17 <benmachine> but I suppose that only works when G and F are C^op -> Set
12:37:24 <benmachine> er
12:37:27 <benmachine> C -> Set
12:37:47 <benmachine> I hope I did the Yoneda the right way, I learnt it the other way around
12:37:51 <Kron> hmmmm
12:38:01 <Kron> googling around, it seems that .hi files are like dynamically generated header files
12:38:06 <Kron> for the purpose of linking. TIL
12:38:30 <Kron> so yes, trivially you lose a lot of information in an hi file, it's just an extra
12:38:43 <jonsterling> benmachine: Yeah... I wonder what this thing is then?
12:39:39 <Algebr> When a hackage package says that it is "Stability provisional", what does that mean? That its basically good enough?
12:39:57 <benmachine> Algebr: the Stability field never really had a standardised meaning
12:40:02 <benmachine> it can usually be ignored
12:40:13 <benmachine> well, it can always be ignored, it's not usually helpful to do anything else :P
12:40:29 <Cale> jonsterling: I missed some stuff, what are you wondering about?
12:40:30 <Kron> Algebr: not a clue :D
12:40:48 <Kron> I just know that the word "provisional" is an example in the haddock docs
12:40:51 <Kron> so I guess people use it a lot
12:41:07 <jonsterling> Cale: So I've got a type cryptically named "T" like this: newtype T f g a = T { runT :: f a -> g a }. And I'm trying to figure out what it ought to be called...
12:41:51 <Algebr> One last thing, hehe for now, a Functor is basically anything that can have a function be applied to it and the result preserves the structure of the original thing?
12:42:15 <ClaudiusMaximus> copumpkin: glad it works better now
12:42:17 <Kron> not necessarily preserving structure
12:42:20 <Cale> jonsterling: Well, if a were not a parameter, then you could call it NatTrans or something :)
12:42:21 <benmachine> Algebr: that's a bit vague
12:42:34 <copumpkin> ClaudiusMaximus: thanks for the patches! still working on getting it back up and running but I'll get there :)
12:42:35 <jonsterling> Cale: Indeed! Unfortunately, I need it to be a parameter...
12:42:40 <Kron> it's more that it in some way holds a smaller type inside it and you can manipulate that type with direct type conversion functions (a -> b)
12:42:41 <Algebr> benmachine: I didn't want to say container because Maybes are functors, right?
12:42:55 <benmachine> Algebr: Maybes are containers, too! but indeed some functors are not containers
12:42:58 <Kron> in a way you can think of functors as anything that it's sane to use fmap on
12:43:07 <copumpkin> jonsterling: the clear solution is to rework your program so that you don't need it to be
12:43:08 <benmachine> Kron speaks sense
12:43:24 <Kron> fmap :: Functor f => (a -> b) -> f a -> f b
12:43:30 <Algebr> Kron: So does no one really use map, just fmap?
12:43:34 <Kron> all sorts of things hold an 'internal type' that can be manipulated
12:43:37 <Kron> well, I use map
12:43:39 <benmachine> I use map frequently
12:43:43 <_ikke_> Algebr: map is fmap on lists
12:43:44 <benmachine> you don't ever *need* to as such
12:43:50 <benmachine> you can always use fmap instead
12:43:51 <Kron> I like to be moer stringent when possible to make the type system work better in my favor
12:43:53 <Cale> Algebr: People use map when they're using lists. But you could get away with only ever using fmap if you wanted.
12:43:57 <Kron> but yeah, fmap is awesome
12:44:00 <benmachine> but if you use map you can see immediately you're talking about lists
12:44:01 <Kron> right
12:44:06 <Algebr> and fmap is the same thing as <$>?
12:44:08 <benmachine> and, yes, so can the typechecker
12:44:09 <benmachine> yes
12:44:10 <Kron> yes, it is
12:44:14 <jonsterling> copumpkin: That would be nice, but I'm not sure it's plausible in this case. Will think about it some though...
12:44:22 <Algebr> as always, thanks all!!
12:44:34 <Cale> I sort of still wish for a return to how it was in Haskell 1.4 where the method of Functor was simply called 'map'
12:44:36 <Kron> though, for sanity's sake, I think fmap has a special rule
12:44:45 <Kron> "fmap id thingy" should give you thingy
12:44:49 <_ikke_> Do things like <*> and <$> have a name?
12:44:52 <Cale> i.e. we just had  map :: Functor f => (a -> b) -> f a -> f b
12:44:57 <_ikke_> Kron: It has two
12:45:00 <Kron> it shouldn't contort on the very application of a function
12:45:05 <Cale> <*> is pronounced "ap"
12:45:07 <Kron> I forget the second one then
12:45:20 <benmachine> Kron: the second one is fmap (f . g) = fmap f . fmap g
12:45:26 <Kron> ah, right
12:45:36 <benmachine> Kron: in fact it follows from the first one by parametricity, I'm told
12:45:45 <Kron> Algebr: you can learn a lot about what a type is like purely from its defeinition / sanity contracts
12:46:09 <Kron> http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:fmap
12:46:13 <Kron>  fmap id  ==  id
12:46:14 <Kron>  fmap (f . g)  ==  fmap f . fmap g
12:46:14 <Kron> right
12:46:42 <Averell> i liked the section in LYAH, it also has a good example of what violates this rule
12:46:51 <Algebr> Kron: Yea, been looking over the prelude's source code, modules it references. ITs really just a convience meta header file, kind of.
12:47:12 <Kron> when I learned haskell I found it kind of shocking how much of haskell is... written in haskell
12:47:12 <_ikke_> Averell: Only the first rule, not the seccond
12:47:16 <copumpkin> ReinH: btw, in that java thing, I wrote some justification of my (ugly, imo) design in the root README.md of that repo
12:47:18 <Kron> even the GHC is compiled using the GHC
12:47:23 <Kron> a lot of shaped-like-itself going on here
12:47:27 <Averell> pretty sure second is broken by that too. some internal counter
12:47:33 <_ikke_> yeah
12:47:45 <Algebr> Kron: Yea, that's blowing my mind too.
12:47:45 <_ikke_> Kron: How do you think it works for gcc?
12:48:06 <Kron> _ikke_: point taken, but I'm used to everything ultimately being written in C
12:48:24 <Kron> I'm not used to seeing a compiler written in a high level programming language
12:48:54 <heatsink> dshad: It looks like you're using argparser.  Its parsers are applicative.  You can make the parsers return functions like I was describing.  It is not convenient, though.  You may want to consider using a different parser library.
12:49:22 <Algebr> Kron: I'm actually unclear how the run-time of a haskell program works, like I do `./myProg` and it runs, but what program is managing it? Surely not directly the OS since of the particulars of haskell's memory management and whatnot.
12:49:38 <Kron> there is something called "The haskell runtime"
12:49:55 <copumpkin> it's linked into every program and the native compiled Haskell code calls into it
12:50:07 <copumpkin> (and gets called from it)
12:50:09 <benmachine> it's written in C :(
12:50:10 <Kron> and, this took me ages to fully grok and figure out, the haskell runtime simply evaluates the symbol "main" which becomes a series of IO actions and then "runs" it
12:50:16 <copumpkin> benmachine: not all of it
12:50:22 <benmachine> copumpkin: oh, I didn't know that
12:50:26 <Kron> all of your haskell program is definining what main is, like a big variable
12:50:28 <Algebr> Where is it though? I'm not even sure where to look for it in the ghc source code
12:50:32 <benmachine> copumpkin: what's the rest?
12:50:33 <copumpkin> Algebr: rts
12:50:36 <copumpkin> benmachine: cmm
12:50:44 <benmachine> oh right, makes snse
12:50:48 <benmachine> *makes snes
12:50:50 <Kron> treating it like an imperative procedural section is a mistake that the do notation can confuse you into doing
12:50:57 <Algebr> copumpkin: oh duh, thanks!
12:50:57 <copumpkin> Algebr: (run-time system)
12:52:52 <Algebr> Kron: Yea, the do notation makes me think, oh this is the C-like part of my code
12:53:13 <_ikke_> Kron: How should it be treated then?
12:53:48 <Rufflewind> is it allowed to import methods from a class without using the Class(method1, ...) syntax?  i.e. if I just write method1 would it work?
12:54:45 <tlevine> Is there a decent way to write spreadsheet functions in Haskell (like rather than VBA)
12:55:05 <Rufflewind> what I found is that for it works in 99% of the cases, but then for some reason it refuses to work for fromInteger, so I had to explicitly write Num(fromInteger).  is this "unspecified behavior" or something?
12:55:15 <heatsink> What are spreadsheet functions?
12:56:17 <tlevine> Functions you can call from a program like Excel
12:56:39 <heatsink> Such as SQRT?
12:56:44 <tlevine> i think so
12:56:50 <heatsink> > sqrt 3
12:56:51 <lambdabot>  1.7320508075688772
12:56:58 <Kron> _ikke_: not sure what you mean
12:57:33 <Kron> I used to get confused because I'd place "getLine"s and stuff in extraneous functions not quite in main and expect them to do the thing they're supposed to do when they're evaluated, like a lisp
12:58:06 <Kron> but getLine simply returns a static object that only does anything when it exits out of your program via evaluating main
12:58:17 <heatsink> It takes some getting used to
12:58:21 <Kron> it does, yeah
12:58:23 <gamegoblin> Man, I didn‚Äôt understand monads for the longest time. The only way I got to know them was by coding a whooooole lot of haskell.
12:58:37 <gamegoblin> There was no eureka moment. Just a very slow understanding.
12:58:42 <Kron> to be honest, you don't need to know monads to get the haskell IO system
12:58:45 <Kron> but it helps
12:58:51 <Kron> same, slow understanding here too
12:59:11 <enk0> i still wonder if i understand them
12:59:16 <yogert> Just to be clear, I should ignore cabals warnings about my package list being old‚Ä¶ right?
12:59:17 <enk0> i think i do
12:59:19 <heatsink> Part of the niceness of do-notation is that you can reason procedurally about do blocks in the IO monad
12:59:51 <Kron> I've only finally started to "get" monads by learning about and tinkering with xmonad
13:00:21 <gamegoblin> I just coded a my own parser library using monadic parsing (a la parsec, attoparsec), so I think I have a decent grasp on them now
13:00:24 <Kron> the X () monad, specifically
13:00:25 <Kron> it's like an I-can't-believe-it's-not-IO and it's a nice practice target
13:02:18 <gamegoblin> Going to post my parser lib on hackage once I clean it up. It‚Äôs called polyparsec since it finds all possible parses rather than just a greedy one
13:02:50 <gamegoblin> e.g. ` many (token ‚Äòa‚Äô) ` on the string ‚Äúaaa‚Äù will return the results ‚Äú‚Äù, ‚Äúa‚Äù, ‚Äúaa‚Äù, ‚Äúaaa‚Äù
13:04:23 <benmachine> gamegoblin: you know there's already a package called polyparse, right? :P
13:04:33 <gamegoblin> I did not know that‚Ä¶
13:04:37 <gamegoblin> What‚Äôs it do?
13:04:39 <benmachine> gamegoblin: I mean, that's not necessarily a problem, but something to be aware of
13:04:46 <benmachine> eerr, parsing
13:04:59 <benmachine> I haven't actually used it
13:05:01 <benmachine> it's quite old
13:05:03 <gamegoblin> looking it up now
13:05:27 <gamegoblin> Mmmm I could always rename it to kiloparsec or something (to play on attoparsec)
13:05:36 <benmachine> heh
13:05:37 <gamegoblin> is haskell.org down again?
13:05:44 <benmachine> hackage definitely isn't
13:05:51 <benmachine> nor is haskell.org
13:05:51 <identity> Kron: xmonad seems really nicely architectured
13:06:01 <identity> it seems like anything you might want to do ever is in a library somewhere
13:06:11 <gamegoblin> huh‚Ä¶ not loading for me‚Ä¶
13:06:27 <Kron> identity: I'm actually working on my fadewindows loghook right now
13:06:32 <identity> gamegoblin: isup.me
13:06:34 <Kron> it's... confusingly half monoidic half monadic
13:06:40 <identity> Kron: fadewindows?
13:06:42 <identity> What does that do?
13:06:57 <Kron> http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Hooks-FadeWindows.html
13:07:02 <gamegoblin> isup.me tells me haskell.org is down for everyone
13:07:15 <Kron> it's basically a more elaborate way of building your own fade hook with your own rules
13:07:20 <benmachine> gamegoblin: I'm browsing it right now
13:07:23 <Kron> like fade inactive windows, but you get to customize it
13:07:34 <gamegoblin> Well I am not >.< and neither is isup.me apparently
13:07:36 <identity> gamegoblin: definitely not down for me.
13:07:37 <walpen`> Does anyone know if there is, in cabal, a os(*) for Arch Linux?
13:07:57 <identity> gamegoblin: isup.me tells me it is up as well
13:08:01 <walpen`> Does anyone know if there is, in cabal, a os(*) for Arch Linux?
13:08:02 <gamegoblin> whaaaaat
13:08:17 <gamegoblin> Try just: http://www.haskell.org/haskellwiki/Polyparse
13:08:21 <benmachine> walpen`: no, they tend not to be that specific
13:08:33 <benmachine> gamegoblin: loads for me
13:08:38 <identity> Kron: so it makes inactive windows somewhat transparent or some such?
13:08:39 <gamegoblin> What is this nonsense.
13:08:41 <gamegoblin> Let me try it on my phone
13:08:43 <benmachine> isn't terribly useful, mind :P
13:08:44 <Kron> yeah, basically
13:08:44 <identity> Why is that useful?
13:08:53 <benmachine> "polyparse is a collection of alternative parser combinator libraries. Please edit this page to add any useful information you can think of."
13:08:56 <Kron> because it makes my system pretty! :D
13:08:57 <walpen`> benmachine Thank you
13:08:59 <gamegoblin> Yeah it loads on my phone
13:09:01 <gamegoblin> What the hell
13:09:05 <benmachine> gamegoblin: http://code.haskell.org/~malcolm/polyparse/docs/
13:09:11 <Kron> identity: http://imgur.com/a/vC9H2?gallery#0
13:10:11 <identity> Kron: wow, that looks pretty nice. is that xmobar at the top?
13:10:32 <Kron> sadly, no!
13:10:35 <Kron> I had to resort to dzen
13:10:45 <Kron> I tried xmobar, but dzen gives me mouse click functionality
13:10:49 <Kron> and the pretty workspace graphics
13:10:53 <benmachine> walpen`: have a look at System.Info.os
13:10:59 <identity> I figured. Didn't think it supported things like the volume control thing
13:11:07 <identity> (well, it does, but not nicely rendered like that)
13:11:16 <Kron> identity: https://github.com/AshleyMoni/dotfiles/tree/master/.xmonad
13:11:19 <identity> as for mouse click functionality, I definitely don't need that
13:11:20 <benmachine> walpen`: that's pretty much what cabal uses, except that it also decides that e.g. minge32 and cygwin32 are both windows
13:11:26 <benmachine> *mingw32
13:11:37 <benmachine> and some other things
13:11:38 <gamegoblin> mmm well polyparse doesn‚Äôt do the same thing as my parser, so that‚Äôs good I guess
13:11:46 <Kron> I picked up a lot of inspiration from two other xmonad setups
13:11:51 <Kron> http://www.reddit.com/r/unixporn/comments/21spxp/archxmonad_navi/
13:11:56 <Kron> I talk about them here
13:11:56 <gamegoblin> Mine returns all possible parses (and allows for partial results, like attoparsec)
13:11:58 <identity> f**k the mouse, man. it keeps puttin' the little man down
13:12:05 <identity> yeah? I'll have to take a look
13:12:15 <identity> Kron: The gaps between the windows, how is that accomplished?
13:12:27 <identity> That looks really nice.
13:12:34 <Kron> smartspacing
13:12:37 <identity> I think tonight will be .xmonad hacking night.
13:12:59 <Kron> lines 147 to 149
13:13:07 <Kron> ††††layoutHook = smartSpacing 6 . avoidStruts . noBorders†††††††††††††††††$ layoutHook defaultConfig
13:16:37 <identity> Kron: Thanks! I'll have to try some of this stuff out
13:16:50 <Kron> I've tried quite hard to make it readable
13:17:12 <Kron> I replaced all the horrid 80 character dzen strings with "wrappedIn" and the like
13:18:45 <jonsterling> Cale/copumpkin/benmachine: Sorry to bother everyone again, but I had a few more questions. So it's clear to me that whatever this thing is that I'm doing, though inputs may be functors, the output won't be unless some conditions are met (I believe, if f is a presheaf and g is a functor, then I think we have that g :^: f is a functor). But in my use-case, it
13:18:46 <jonsterling> doesn't actually matter to me that these things be functors: I am only plumbing and doing computations on type constructors, some of which will be functors, and others of which will not. When they turn out to be functors, certain operations become available: but it's not necessary in general...
13:19:09 <schlegel> Kron: Have you seen Quassel?
13:19:18 <Kron> no! I haven't
13:19:27 <Kron> oh wait, that's an irc client?
13:19:32 <schlegel> Yeah
13:20:30 <identity> irssi > *
13:20:31 <identity> i'm afraid
13:20:40 <Undeterminant> @pf f (g x) (h x)
13:20:40 <lambdabot> Maybe you meant: pl bf
13:20:42 <Undeterminant> hmm
13:20:55 <Undeterminant> @pf \x -> f (g x) (h x)
13:20:55 <lambdabot> Maybe you meant: pl bf
13:20:58 <Undeterminant> :|
13:20:58 <Kron> I'm using xchat at the moment since it lets me synchronize with the xchat on my windows partition
13:21:02 <schlegel> You mean @pl
13:21:09 <Undeterminant> ...yes
13:21:12 <Undeterminant> @pl \x -> f (g x) (h x)
13:21:12 <lambdabot> liftM2 f g h
13:22:28 <Kron> f <$> g <*> h
13:23:04 <Undeterminant> I was trying to compile the binary myself on Arch but gave up after it failed three times
13:23:24 <schlegel> what binary
13:23:29 <Undeterminant> the pointfree binary
13:23:59 * hackagebot DAV 0.6.2 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.6.2 (ClintAdams)
13:25:48 <johnw> fourth times the charm ;)
13:28:59 <schlegel> Just installed it and it works
13:30:28 <Undeterminant> schlegel: it's because I had to use an old version of haskell-src-exts, and the PKGBUILD script on the AUR doesn't seem to work properly
13:30:43 <Undeterminant> I'm too impatient for that to compile multiple times :P
13:33:03 <schlegel> uh
13:33:16 <schlegel> IMO use cabal not Aur
13:33:42 <Undeterminant> the last time that I tried using cabal I couldn't find any documentation anywhere
13:33:45 <flebron> Is there a centralized or canonical resource for category theory as pertaining to Hask?
13:34:00 * hackagebot pointfree 1.0.4.6 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-1.0.4.6 (BenMillwood)
13:35:02 <johnw> flebron: it's generally called The Web
13:35:14 <sclv> ?src all
13:35:15 <lambdabot> all p =  and . map p
13:35:22 <flebron> johnw: Well that's kind of the antithesis of "centralized" :p
13:35:22 <sclv> ?src and
13:35:22 <lambdabot> and   =  foldr (&&) True
13:35:34 <identity> Undeterminant: hmm? So "cabal update && cabal install pointfree" doesn't just work?
13:38:10 <Undeterminant> identity: last time that I tried doing something like that, I ended up with some weird errors
13:38:32 <Undeterminant> I would try it now but I have to leave in a few minutes
13:39:51 <identity> Well, if you do decide to try later, you could just ask peeps in here
13:40:02 <identity> they are in the know when it comes to such things
13:42:46 <Undeterminant> I probably will
13:49:29 <pordan30> is there an idiomatic way to express the function f a m = case m of {Nothing -> Just a; Just a -> Nothing} without writing a case statement or (something like) f itself?
13:50:43 <walpen`> pordan30 f a m = Data.Maybe.Maybe m (const Nothing) (Just a)
13:50:43 <bergmark> @type maybe -- pordan30
13:51:03 <walpen`> prodan30 whoops that second Maybe should be maybe
13:51:45 <schlegel> Uh guys
13:51:51 <schlegel> Where did lambdabot go
13:51:52 <dwcook> I think lambdabot has been split from us
13:52:28 <pordan30> thanks, walpen and bergmark -  i think an explicit case might be clearer in my (use) case, but thanks :)
13:52:47 <dwcook> lambdabot is back
13:52:49 <Cale> * lambdabot has quit (*.net *.split) <-- yes
13:52:50 <dwcook> @pl f a m = case m of {Nothing -> Just a; Just a -> Nothing}
13:52:57 <lambdabot> (line 1, column 19):
13:53:00 <Cale> (It was split)
13:53:03 <lambdabot> unexpected '{'
13:53:11 <dwcook> Heh, silly lambdabot
13:53:14 <johnw> @pl \a m -> case m of {Nothing -> Just a; Just a -> Nothing}
13:53:21 <lambdabot> (line 1, column 19):
13:53:22 <Cale> The @pl command doesn't understand case expressions
13:53:25 <schlegel> oh weird split was hidden
13:53:27 <lambdabot> unexpected '{'
13:53:45 <johnw> maybe (Just a) (const Nothing) is really the best I think
13:54:02 * hackagebot xlsx 0.1.0.1 - Simple and incomplete Excel file parser/writer  http://hackage.haskell.org/package/xlsx-0.1.0.1 (KirillZaborsky)
13:54:04 <dwcook> Yeah, I didn't expect good output from @pl for this case
13:57:21 <Paradoxic> Hello. What is the best book to start learning Haskell if you have limited progreamming experience?
13:57:43 <intrados`> Apparently, hashable relies on C and so can't be used with Haste. I assume the same is true for GHCJS. Are there known workarounds?
13:57:54 <walpen`> Paradoxic Probably Learn You a Haskell http://learnyouahaskell.com/
13:58:52 <Paradoxic> walpen`: How much time do you think it would take a beginner to work through that?
13:59:02 * hackagebot HueAPI 0.1.2 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0.1.2 (SjoerdVisscher)
13:59:42 <flebron> mfw reading edwardk's note on right Kan extensions and come across (what seems to be) a prof in my university, who teaches category theory
14:00:04 <flebron> (Eduardo Dubuc)
14:04:14 <Algebr`> How can I write a really long string? I tried \ but that doesn't work, apparently.
14:04:24 <Algebr`> Like a hard-coded really long string.
14:04:37 <johnw> I like the 'here' package for doing that
14:04:41 <johnw> Data.String.Here
14:04:49 <johnw> you write [here|really really long literal string|]
14:04:57 <johnw> it can have newlines, special characters, etc.
14:05:14 <dwcook> Algebr`, what problem are you running into writing this really long string?
14:05:24 <Algebr`> Imaging a SQL string
14:05:33 <davean> intrados`: It looks like it would be fairly easy to make it optionally pure
14:05:38 * dwcook generally tries not to imagine such things
14:05:57 <Algebr`> my_query = "select asdasdasdasd" (too long on one line),
14:06:17 <dwcook> So the problem isn't actually writing a *long* string, it's separating it over lines?
14:06:21 <Algebr`> dwcook: yes.
14:06:22 <johnw> Algebr`: \ will work, but you have to use it correctly
14:06:33 <johnw> "This is a\
14:06:36 <johnw> \really long line."
14:07:25 <Algebr`> johnw: ah, I didn't think that a \ would be needed on the second line.
14:07:28 <Algebr`> Works now, thanks!
14:08:38 <Cale> Algebr`: Yeah, that's so that you don't have to break the indentation of the program. It ignores all the whitespace between the \'s.
14:10:21 <heatsink> Is there a library of ST-based mutable and pure immutable hash tables?
14:13:06 <Algebr`> Can I import modules at run-time?
14:14:08 <intrados`> davean: Yeah, it looks as though GHCJS does have a patch for it.
14:14:09 <Algebr`> I guess I'm unclear as to what exactly import means, its not a function call, right, its like a declaration that creates a thunk?
14:15:00 <heatsink> import permits access to entities declared in other files
14:15:05 <heatsink> s/declared/defined/
14:15:13 <johnw> Algebr`: you cannot, unless you use a runtime interpreter like "hint"
14:15:28 <johnw> but the "import" declaration is for the compiler, not the runtime
14:17:07 <Algebr`> johnw: so say I do `import foo`, the functions that foo exports aren't loaded into memory right, they only get loaded into memory when needed, right? So until then all those exported functions are thunks?
14:18:09 <heatsink> If the program has been compiled, all global functions are loaded when the program starts running
14:18:40 <heatsink> imports don't do anything when the program runs
14:19:47 <johnw> Algebr`: it's a fairly complex picture, actually
14:20:20 <johnw> since the functions you import could live in the same module, in another module, could be dynamic, could be in a split obj, etc.
14:20:32 <johnw> better just to know that you use import to be able to call a function :)
14:20:42 <felixn> hey, is it possible to pattern match a list or function type?  myFilter fn@(Int -> Bool) list@[Int] = [1..4] -- this gets all sorts of angry
14:21:07 <johnw> that's done with a type signature
14:21:31 <johnw> myFilter :: (Int -> Bool) -> [Int]; myFilter _fn = [1..4]
14:21:42 <khyperia> or do you mean dependant types, or whatever it's called?
14:22:03 <felixn> what if I want it to be polymorphic and do something else "otherwise"?  like just apply the standard Prelude.filter
14:22:11 <felixn> err, not what if, that's what I want :D !
14:22:12 <johnw> ahh
14:22:20 <johnw> no, you can't "specialize" for a function at certain typse
14:22:33 <davean> heatsink: not neccissarily, they're probbly mmaped but they're not neccissarily read off disk
14:22:51 <felixn> johnw: ah thanks, I'm trying to make a cute little DSL without jumping into template haskell
14:23:25 <felixn> I was thinking I could then pass into myFilter a monad that keeps a running total of all the operations applied to it >_<
14:25:26 <haasn> Is there a good, high-performance implementation of WHOIS functionality somewhere? the ‚Äúwhois‚Äù package only seems to provide String, throws weird exceptions (I don't understand) and fails on inputs that my `whois` command works just fine with
14:25:45 <haasn> It also provides two different outputs for some reason; I couldn't understand what the difference is just by looking at the source code
14:26:04 <skypers> I‚Äôm reading the documentation of Dynamic
14:26:20 <skypers> and: A Dynamic may only represent a monomorphic value
14:26:25 <skypers> what is a ‚Äúmonomorphic value‚Äù?
14:26:39 <skypers> I never understood what a monomorphism is‚Ä¶
14:26:39 <heatsink> A monomorphic value has one type
14:26:49 <heatsink> A polymorphic value can have many types
14:26:52 <skypers> so it‚Äôs the opposite of polymorphic
14:26:53 <skypers> ok
14:27:01 <skypers> quite straight-forward :D
14:27:02 <skypers> thank you
14:27:23 <heatsink> For example, id can have the polymorphic type (forall a. a -> a).  It can also be instantiated to the monomorphic type Int -> Int.
14:27:40 <skypers> sure
14:27:43 <skypers> and hm
14:28:04 <skypers> and ADT like Maybe Int is monomorphic?
14:28:13 <heatsink> yes
14:28:15 <skypers> ok
14:28:22 <skypers> then, something like
14:28:41 <skypers> fromDyn (3 :: (Num a) => a) will fail
14:28:45 <skypers> toDyn*
14:28:49 <bitemyapp> skypers: what do you think a polymorphic variation of that would look like?
14:29:05 <skypers> of what?
14:29:27 <heatsink> Yes, you'll get an ambiguous type error
14:29:31 <skypers> of Maybe Int?
14:29:40 <skypers> Maybe a, I guess
14:29:52 <bitemyapp> skypers: yeppers.
14:30:03 <heatsink> (Nothing :: forall a. Maybe a) is polymorphic
14:30:41 <skypers> or
14:30:42 <skypers> 3
14:30:46 <skypers> is also polymorphic
14:31:10 <skypers> :t 3
14:31:11 <lambdabot> Num a => a
14:31:17 <heatsink> It is polymorphic, but it implicitly gets instantiated to a monomorphic type when you pass it to a function.
14:31:32 <skypers> yes
14:31:34 <heatsink> Except if you enable ImpredicativeTypes.  Then, who knows what happens.
14:31:37 <skypers> the typesystem does that for us
14:31:43 <skypers> :D
14:32:06 <skypers> something I _never_ really understood is the NoMonomorphism stuff extension
14:32:56 <haasn> skypers: http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:33:42 <skypers> @let huh = \x -> show x
14:33:43 <lambdabot>  .L.hs:150:14:
14:33:43 <lambdabot>      No instance for (Show a0) arising from a use of `show'
14:33:43 <lambdabot>      The type variable `a0' is ambiguous
14:33:43 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
14:33:43 <lambdabot>        huh :: a0 -> String (bound at .L.hs:150:1)
14:33:45 <haasn> you don't need impredicative types in haskell since we have newtype wrappers
14:33:48 <haasn> same as recursive types
14:33:48 <skypers> hm.
14:34:50 <joneshf-laptop> how is `Functor` a superclass of `Foldable` in http://hackage.haskell.org/package/semigroupoids ?
14:35:08 <joneshf-laptop> meaning what extra restriction is it imposing that isn't being done in base?
14:35:32 <joneshf-laptop> or is this a different kind of `Foldable` than in base?
14:35:54 <haasn> good question; I sort of think that's an error in documentation
14:36:20 <haasn> I don't think there's anything to justify Foldable being a subclass of Functor
14:36:21 <heatsink> I think it's just saying that any type that's a member of Foldable can be made a member of Functor too
14:36:55 <joneshf-laptop> heatsink, how so? i thoght foldable would always get rid of the structure?
14:37:13 <joneshf-laptop> but `Functor` is supposed to preserve the structure
14:38:09 <heatsink> foldMap g (fmap f x) = foldMap (g . f) x
14:38:31 <skypers> ‚Äúsupposed‚Äù?
14:38:32 <skypers> it does
14:38:49 <skypers> btw, I always wonder why Functor is called Functor
14:38:55 <haasn> heatsink: yes, but that doesn't let you implement ‚Äúfmap‚Äù
14:38:59 <skypers> it‚Äôs more an Endofunctor that a Functor, right?
14:39:02 <skypers> than*
14:39:19 <haasn> heatsink: unless you can find a ‚Äòg‚Äô such that foldMap g = id
14:39:53 <joneshf-laptop> skypers, "supposed to" in the sense that it's a valid implementation
14:40:01 <rusk101> Why am I getting this error? http://lpaste.net/102342
14:40:45 <haasn> skypers: most likely just convenience, so you don't have to type the full name. Every Endofunctor is a Functor, so it's justified in one direction
14:40:55 <haasn> representing arbitrary functors in Haskell seems non-trivial, though
14:40:59 <skypers> rusk101: you flipped the argument
14:41:09 <heatsink> haasn: I suspect that you could make a newtype FunctorFoldable t a and an instance Foldable t => Functor (FunctorFoldable t)
14:41:21 <skypers> haasn: yeah, but it‚Äôs possible
14:41:24 <skypers> like
14:41:36 <skypers> class Functor f a g b where
14:41:37 <heatsink> That is, write a new type that has both Functor and Foldable behavior
14:41:51 <rusk101> Thanks. sorry for the dumb question
14:41:56 <haasn> heatsink: you mean with Foldable f => f a -> FunctorFoldable f a -- but no FunctorFoldable f a -> f a ?
14:42:08 <skypers> or Functor f a where emap :: (Functor g b) => (a -> b) -> f a -> g b
14:42:28 <skypers> rusk101: no problem :)
14:42:41 <haasn> skypers: only for functors between subcategories of Hask, I guess
14:42:50 <skypers> rusk101: something important though, GHC‚Äôs error are always cute to me
14:42:56 <skypers> rusk101: In the first argument of `pscale', namely `(Poly 3 [- 1, 2, - 3, 4])'
14:43:01 <skypers> it‚Äôs quite straight forward :)
14:43:10 <rusk101> gotcha.. I was looking at the 3 like it was the scale
14:43:34 <haasn> skypers: http://hackage.haskell.org/package/categories-1.0.6/docs/Control-Categorical-Functor.html
14:43:53 <skypers> yeah, it‚Äôs the Poly the error :)
14:44:02 <skypers> holy **** haasn
14:44:17 <Algebr`> So applicative programming is when you apply a function on a functor, right? What is non-applicative programming? for loops?
14:44:33 <bitemyapp> Algebr`: wut.
14:44:43 <bitemyapp> Algebr`: applicatives are a specific typeclass in Haskell.
14:44:44 <haasn> Algebr`: applicative programming is when you use functions that have Applicative constraints, no more, no left
14:44:49 <haasn> no less*
14:44:50 <bitemyapp> :t (<*>)
14:44:50 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:44:55 <bitemyapp> vs.
14:44:57 <bitemyapp> :t (fmap)
14:44:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:44:59 <haasn> eg. f <$> x <*> y <*> z
14:45:02 <joneshf-laptop> eh
14:45:04 <skypers> 23:42 < Algebr`> So applicative programming is when you apply a function on a functor,  right? What is non-applicative programming? for loops?
14:45:23 <copumpkin> granted, there is at least one other meaning of the term, so let's not steamroll: http://en.wikipedia.org/wiki/Applicative_programming_language
14:45:23 <rusk101> Is haskell an old language?
14:45:24 <skypers> you can see Applicative in a first way by a way to hide variable bindings from monads
14:45:26 <joneshf-laptop> note the lowecase a in applicative
14:45:29 <heatsink> haasn: yeah, you'd want to convert values into FunctorFoldable like that too
14:45:31 <Algebr`> I got that from here"12.1 Introduction to Applicative Programming
14:45:34 <Algebr`> Applicative programming is a technique that allows a function to be applied to each element of a list. A simple example of applicative programming is to add 2 to every element of a list. For example, the list (0 1 2 4) becomes (2 3 4 6). Applicative programming is a very simple yet powerful way to transform lists."
14:45:40 <haasn> rusk101: wikipedia says it's 24 years old
14:45:41 <Algebr`> http://quod.lib.umich.edu/s/spobooks/bbv9810.0001.001/1:15?rgn=div1;view=fulltext
14:45:59 <ziman> I'd call it applicative if it "looks like an application", which (f <$> x <*> y) does but (do { x' <- x; y' <- y; return $ f x' y'}) does not
14:46:14 <haasn> ﬁ
14:46:32 <bitemyapp> Algebr`: Lispers use terminology differently and the material you're looking at is old.
14:46:33 <copumpkin> [
14:46:37 <bitemyapp> Algebr`: this isn't a Haskell question really.
14:46:51 <bitemyapp> Algebr`: also the demonstration mentioned is basically just fmap, which is a functor.
14:47:08 <skypers> rusk101: some folks say it‚Äôs too ‚Äúfuture‚Äù to be understand by the rest ahah
14:47:12 <bitemyapp> Algebr`: there are like 4 different definitions of "applicative" in programming if you went rooting around but only one of them is agreed upon in Haskell
14:47:18 <skypers> but the latest implementation is quite young
14:47:35 <bitemyapp> I don't know about young. 2010 was a very conservative change from 98
14:47:55 * bitemyapp grumbles about pure and return
14:48:01 <Algebr`> bitemyapp: So what's the haskell one? What hassn said? Algebr`: applicative programming is when you use functions that have
14:48:02 <Algebr`> 1716        Applicative constraints, no more, no left
14:48:03 <skypers> grumble?
14:48:04 <skypers> why?
14:48:13 <bitemyapp> Algebr`: me and haasn already defined it for you.
14:48:20 <bitemyapp> :t (<*>)
14:48:21 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:48:24 <bitemyapp> :t fmap
14:48:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:48:27 <skypers> :t fap
14:48:27 <heatsink> Usually they only have one applicative constraint
14:48:27 <lambdabot>     Not in scope: `fap'
14:48:27 <lambdabot>     Perhaps you meant one of these:
14:48:27 <lambdabot>       `fmap' (imported from Control.Monad.Writer),
14:48:30 <bitemyapp> Algebr`: see the difference above?
14:48:36 <bitemyapp> skypers: please no.
14:48:39 <skypers> bitemyapp: :D
14:48:50 <bitemyapp> skypers: makes it harder to read.
14:48:58 <skypers> makes it funnier
14:49:02 <bitemyapp> Algebr`: f (a -> b) vs. (a -> b)
14:49:10 <Algebr`> bitemyapp: aye, got it now.
14:49:18 <skypers> especially when composing ;)
14:49:20 <bitemyapp> Algebr`: I'm not convinced. lets talk about it.
14:49:25 <bitemyapp> Algebr`: [] implements applicative and functor. Do you know what fmap does on a list?
14:49:34 <Algebr`> bitemyapp: its just regular map
14:49:36 <skypers> 23:46 < lambdabot>       `fmap' (imported from Control.Monad.Writer),
14:49:41 <skypers> what?!
14:49:45 <bitemyapp> Algebr`: fmap is the regular one. map is an abomination. Anyway
14:49:48 <skypers> imported from Control.Monad.Writer?
14:49:54 <skypers> isn‚Äôt fmap in Prelude?
14:49:58 <bitemyapp> Algebr`: fmap takes (a -> b), but <*> takes f (a -> b)
14:50:10 <bitemyapp> Algebr`: what's f in the specific case we're talking about?
14:50:19 <Algebr`> bitemyapp: a type constructor?
14:50:26 <bitemyapp> Algebr`: yes but who is the type constructor?
14:50:34 <bitemyapp> Algebr`: I just brought up a specific type that implements applicative and functor.
14:50:51 <bitemyapp> Algebr`: I asked you to explain what that type's implementation of fmap did.
14:50:59 * Algebr` feeling dumb.
14:51:02 <bitemyapp> :t (<*>)
14:51:03 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:51:06 <bitemyapp> Algebr`: I asked you about lists.
14:51:09 <bitemyapp> Algebr`: so what's f?
14:51:15 <Algebr`> bitemyapp: map?
14:51:21 <haasn> bitemyapp: how is ‚Äòmap‚Äô an abomination?
14:51:23 <bitemyapp> Algebr`: map is a function. I asked you about lists.
14:51:25 <bitemyapp> haasn: not right now.
14:51:31 <bitemyapp> haasn: for the love of god, not right now.
14:51:38 <haasn> I'm not convinced what you're doing is helping
14:51:48 <bitemyapp> Algebr`: [] is a type constructor for lists.
14:51:56 <bitemyapp> so when you have
14:51:58 <bitemyapp> :t fmap
14:51:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:52:07 <bitemyapp> the f is the type implementing Functor
14:52:13 <bitemyapp> if we're talking about the Functor instance for lists, f is []
14:52:17 <bitemyapp> Algebr`: comprende so far?
14:52:41 <Algebr`> wait, the f is something that has `instance Functor f` defined?
14:52:50 <bitemyapp> haasn: there is a file description on every POSIX compliant operating system where complaints can be filed.
14:52:53 <bitemyapp> descriptor*
14:53:02 <davd> @djinn Functor f => a -> f a
14:53:02 <lambdabot> Error: Class not found: Functor
14:53:05 <bitemyapp> Algebr`: well, it would be Functor f though, it'd be Functor Maybe or Functor []
14:53:20 <copumpkin> bitemyapp: steamrolling.
14:53:25 <bitemyapp> @djinn Applicative f -> a -> f a
14:53:25 <lambdabot> Error: Undefined type Applicative
14:53:31 <bitemyapp> really?
14:53:32 <bitemyapp> ;t pure
14:53:36 <bitemyapp> :t pure
14:53:37 <lambdabot> Applicative f => a -> f a
14:53:37 <davd> extending djinn would be nice
14:53:42 <skypers> > (,,) <$> Just 3 <*> Just 5 <*> Nothing
14:53:43 <lambdabot>  Nothing
14:53:43 <Algebr`> :t <*>
14:53:44 <lambdabot> parse error on input `<*>'
14:53:48 <skypers> > (,,) <$> Just 3 <*> Just 5 <*> Just 2
14:53:49 <lambdabot>  Just (3,5,2)
14:53:50 <davd> (just playing around)
14:53:52 <skypers> :)
14:53:53 <rusk101> Whats the best way to do convolution of two lists? e.g. [a0, a1, a2, ..., ai] * [b0, b1, b2, .., bj] = [a0*b0, a1*b0+b1*a0, a0*b2+a1*b1*a2*b0, ...]
14:53:53 <Algebr`> :t (<*>)
14:53:54 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:54:01 <bitemyapp> Algebr`: so if we're talking about the applicative instance for lists, f is []
14:54:15 <bitemyapp> Algebr`: so the type signature turns into [(a -> b)] -> [a] -> [b]
14:54:29 <bitemyapp> Algebr`: this is different from fmap where it'd be (a -> b) instead of [(a -> b)]
14:54:47 <bitemyapp> Algebr`: what do you think changes about the semantics when you're applying a list of functions instead of a single function to the values of [a]?
14:55:16 <skypers> > (*) <$> [1..] <*> []
14:55:20 <lambdabot>  mueval-core: Time limit exceeded
14:55:28 <bitemyapp> skypers: something that terminates perhaps? :)
14:55:48 <skypers> > takes 5 $ (*) <$> [1..] <*> pure 10
14:55:49 <lambdabot>  Not in scope: `takes'
14:55:49 <lambdabot>  Perhaps you meant one of these:
14:55:49 <lambdabot>    `take' (imported from Data.List),
14:55:49 <lambdabot>    `Seq.take' (imported from Data.Sequence),
14:55:49 <lambdabot>    `BSLC.take' (imported from Data.ByteString.Lazy.Char8)
14:55:50 <bitemyapp> skypers: also, try it with an [a] that has values in it so Algebr` can see what I'm getting at.
14:55:55 <skypers> > take 5 $ (*) <$> [1..] <*> pure 10
14:55:56 <lambdabot>  [10,20,30,40,50]
14:56:10 <dibblego> fyi there are a couple of useful [] applicative instances
14:56:11 <bitemyapp> skypers: [a] with multiple values instead of pure please.
14:56:25 <bitemyapp> dibblego: gotta link?
14:56:26 <skypers> > take 5 $ (*) <$> [1,2,3] <*> [10,20]
14:56:27 <lambdabot>  [10,20,20,40,30]
14:56:30 <Algebr`> bitemyapp: if I'm applying a list of functions onto one value, I'm not even sure what I should get back, would I get back a single value?
14:56:31 <dibblego> @type ZipList
14:56:31 <lambdabot> [a] -> ZipList a
14:56:43 <bitemyapp> dibblego: handy.
14:57:06 <skypers> it‚Äôs the same thing is [x*y | x <- [1,2,3], y <- [10,20]]
14:57:06 <bitemyapp> Algebr`: you have multiple functions that can provide results for each member of the list instead of a single 1 -> 1 mapping.
14:57:20 <bitemyapp> Algebr`: what skypers just said is the semantics of the default Applicative instance for []
14:57:30 <bitemyapp> there are alternatives to those semantics as dibblego just mentioned.
14:57:46 <dibblego> there is no possible monad for ZipList
14:57:54 <skypers> > (*) <$> ZipList [1,2,3] <*> ZipList [10,20,30]
14:57:55 <lambdabot>  No instance for (GHC.Show.Show (Control.Applicative.ZipList b0))
14:57:55 <lambdabot>    arising from a use of `M57378453037107983129192.show_M57378453037107983129...
14:57:55 <lambdabot>  Possible fix:
14:57:55 <lambdabot>    add an instance declaration for
14:57:55 <lambdabot>    (GHC.Show.Show (Control.Applicative.ZipList b0))No instance for (GHC.Num.N...
14:57:59 <bitemyapp> Algebr`: it's important to remember that typeclasses are just their types and their laws, which often leaves open the possibility of multiple valid instances/implementations for a given type.
14:58:11 <dibblego> > getZipList ((*) <$> ZipList [1,2,3] <*> ZipList [10,20])
14:58:11 <haasn> rusk101: I would probably use an Array/Vector and just use a naive approach that just generates index lists like [(1,1)], [(2,1),(1,2)], [(3,1),(2,2),(1,3)], etc.
14:58:12 <lambdabot>  [10,40]
14:58:17 <bitemyapp> Algebr`: what implementation gets used has mostly to do with how nice or useful it is.
14:58:18 <Rarrikins> I hate it when people use M57378453037107983129192.show_M57378453037107983129...
14:58:23 <davd> rusk101: read this? http://www.blaenkdenum.com/posts/naive-convolution-in-haskell/
14:58:32 <skypers> ZipList is like an applicative zip
14:58:33 <rusk101> Thanks!
14:58:39 <Algebr`> bitemyapp: Oh, so I could just get back say a tuple where each entry is the result of each function called per item in the input data?
14:58:44 <skypers> > zip (*) [1,2,3] [10,20]
14:58:45 <lambdabot>  Couldn't match expected type `[t1] -> t0'
14:58:45 <lambdabot>              with actual type `[(a0, b0)]'Couldn't match expected type `[a0]'
14:58:45 <lambdabot>              with actual type `a1 -> a1 -> a1'
14:58:49 <skypers> > zipWith (*) [1,2,3] [10,20]
14:58:50 <lambdabot>  [10,40]
14:59:04 <bitemyapp> Algebr`: well you've got a -> b
14:59:13 <bitemyapp> Algebr`: b can be a tuple I guess :P
14:59:18 <skypers> I never used ZipList, I wonder who does use that
14:59:34 <bitemyapp> Algebr`: anyway I think you're in good hands here. I'll go back to my code.
14:59:35 <startling> I used it in a job interview once.
14:59:45 <skypers> a very handy thing:
14:59:52 <skypers> > let a = [1..5] in zip a (tail a)
14:59:53 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
15:00:21 <Algebr`> bitemyapp: Thank you, I need to reread your replies like 100 times.
15:00:34 <skypers> :)
15:00:50 <skypers> Applicative style is, at first, very magic and weird
15:01:08 <bitemyapp> Algebr`: so it goes.
15:01:15 <skypers> when you‚Äôll use it with a ctor and a bunch of actions, you‚Äôll get into it :)
15:01:39 <bitemyapp> Algebr`: the only real difference is that <*> is using functions that are contained within the type that implements applicative itself, rather than being standalone.
15:01:41 <skypers> it‚Äôs also very convenient to make the code lighter
15:01:53 <bitemyapp> Algebr`: I use Applicative most often to get rid of some Maybe just/nothing case ugliness.
15:02:04 <skypers> bitemyapp: you can use maybe for that
15:02:08 <Algebr`> I feel Iike I'm missing out on its use-case.
15:02:14 <bitemyapp> I just gave you one.
15:02:17 <skypers> Algebr`: that‚Äôs totally normal
15:02:26 <skypers> don‚Äôt try to learn how to use it
15:02:29 <skypers> just write some code
15:02:31 <Algebr`> well, besides the ones given to me.
15:02:36 <bitemyapp> also it's a de-sugared list comprehension (sometimes. list monad comes in stoo)
15:02:39 <skypers> and some day, ‚Äúoh!‚Äù :)
15:02:58 <bitemyapp> Algebr`: well, someday (soon?) you're going to want to do something that fmap can't do.
15:03:08 <skypers> imagine you want to prompt the user for input, get the input, thank him, and get back the result
15:03:11 <skypers> the monadic way would be
15:03:16 <bitemyapp> Algebr`: then you'll realize you want function(s) inside the type you're working with.
15:03:32 <skypers> :t do { putStrLn "go for it; r <- getLine; putStrLn "thank you"; return r }
15:03:33 <lambdabot>     lexical error in string/character literal at end of input
15:03:39 <bitemyapp> Algebr`: makes you feel any better, ??? is a common reaction to applicative where functors were immediately understood.
15:03:42 <skypers> :t do { putStrLn "go for it"; r <- getLine; putStrLn "thank you"; return r }
15:03:42 <lambdabot> IO String
15:03:51 <haasn> Algebr`: http://www.haskell.org/haskellwiki/Typeclassopedia
15:03:52 <skypers> the Applicative, much more elegant, would be:
15:04:06 <skypers> :t putStrLn "go for it" *> getLine <* putStrLn "thankyou"
15:04:07 <lambdabot> IO String
15:04:09 <skypers> :)
15:04:23 <Algebr`> Wat, *> is a thing??
15:04:27 <skypers> yes
15:04:39 <bitemyapp> :t (*>)
15:04:40 <lambdabot> Applicative f => f a -> f b -> f b
15:04:42 <bitemyapp> :t (<*)
15:04:42 <Algebr`> ugh, why can't we use wordsss
15:04:42 <lambdabot> Applicative f => f a -> f b -> f a
15:04:47 <Algebr`> lol
15:04:49 <skypers> it discards the left return value
15:04:56 <haasn> Applicative is a generalization of liftA*
15:04:59 <bitemyapp> Algebr`: "shake it to the left, shake it to the right. Get dowwwwwnnnn"
15:05:12 <haasn> liftA0, liftA1, liftA2, liftA3, etc.
15:05:15 <skypers> :t (*>)
15:05:16 <lambdabot> Applicative f => f a -> f b -> f b
15:05:19 <skypers> :t (>>)
15:05:20 <lambdabot> Monad m => m a -> m b -> m b
15:05:23 <skypers> ;)
15:05:58 <skypers> > Nothing *> Just 3
15:05:59 <lambdabot>  Nothing
15:06:05 <bitemyapp> skypers: want to show where your example stops working for applicative?
15:06:26 <skypers> bitemyapp: well, if I want to combine two results
15:06:27 <skypers> like
15:06:32 <jophish> bitemyapp: as a matter of style, do people generally use Either for sum types, or create a synonym for Either as per your examples yesterday?
15:06:36 <bitemyapp> skypers: precisely. Please demonstrate :)
15:06:47 <skypers> do { a <- f t; g; b <- h t; return . foo a b }
15:06:57 <startling> jophish: it depends a lot.
15:07:01 <skypers> doing that in Applicative might be a lot of pain
15:07:02 <dwcook> jophish, often neither; they might make an entirely new type: data Foo = Bar | Baz | Quux
15:07:10 <dwcook> Sprinkle type parameters to taste
15:07:15 <bitemyapp> jophish: what startling said. It's all contextual and depends on the semantics of what I'm doing.
15:07:26 <bitemyapp> jophish: I use Either as a signal that I've got a good case and a bad case.
15:07:35 <startling> jophish: it's common to use Either (or generalizations like MonadError) in code that other people may use, and a domain-specific type for your code.
15:07:40 <bitemyapp> and usually the bad case is a sum type of error conditions.
15:07:53 <bitemyapp> so it's a sum type of a sum type and a good thing, whatever that good thing is.
15:08:30 <skypers> but Algebr`, Functor is quite fast to learn, so is Monad
15:08:37 <jophish> Ah, in this case I'll use a custom one, as neither of the types represents anything like an error
15:08:37 <skypers> Applicative is a bit harder to get into IMHO
15:08:40 <skypers> so don‚Äôt worry ;)
15:09:10 * hackagebot ipopt-hs 0.4.2.0 - haskell binding to ipopt and nlopt including automatic differentiation  http://hackage.haskell.org/package/ipopt-hs-0.4.2.0 (AdamVogt)
15:09:13 <skypers> another call thing with IO as Applicative:
15:09:14 <startling> jophish: if I just have two cases, I do tend to use Either as well
15:09:24 <skypers> :t (,,) <$> getLine <*> getLine <*> getLine
15:09:25 <lambdabot> IO (String, String, String)
15:09:40 <bitemyapp> skypers: Applicative isn't something with quite as clear of a corresponding concept to other languages except for some forms of comprehensions.
15:09:47 <haasn> Either can be used for plenty of things other than errors/good values
15:09:50 <skypers> bitemyapp: sure
15:09:56 <haasn> For example, things with directionality (left vs right)
15:10:16 <bitemyapp> haasn: just speaking to what I have done, rather than what I might do.
15:10:20 <haasn> or something like Stream (Either a b)
15:10:40 <haasn> The trade-off is usually whether you prefer clarity and safety or ease of use
15:10:51 <haasn> this is something you have to decide for yourself
15:12:24 <gammaraid> How can I use state monad to keep track of variable values when I don't know what the value types will be?
15:13:17 <gammaraid> The only way I know how to kind of do that is make a data type for the state that is a list of pairs (var, value), but I don't know how to set up that data type when I don't know what type value will be
15:13:19 <geekosaur> not knowing that will cause problems later anyway. usually the answer is a wrapper type which lets you work by constructor
15:13:35 <geekosaur> data MyValue = MyInt Int | MyString [Char] | ...
15:14:40 <gammaraid> Hmmm the thing is I have an data class for expression trees ExpTree a f = V a | Op f (ExpTree a F) (ExpTree a F) | Get String | Set String (ExpTree a f)
15:15:03 <gammaraid> where V a is like a is a value (leaf so to speak), and the get and set get or set teh variable with the variable name of hte string
15:15:09 <startling> skypers: one interesting thing about Applicative is that Applicative parsers can only describe context-free grammars whereas monadic parsers can be context-sensitive.
15:15:33 <skypers> startling: yes :)
15:15:37 <bitemyapp> startling: I always really liked that result.
15:15:42 <gammaraid> I basicalyl want it so when "Set String (expTree a f)" is in an expression tree for all further down/to the right expressions that variable will hold the value
15:15:44 <startling> bitemyapp: yeah, it's really neat.
15:15:45 <skypers> I love using Applicative whithin Parsec
15:15:48 <skypers> with Alternative
15:15:57 <bitemyapp> startling: it also makes a ton of sense when you compare the Applicative and Monad instances in IO
15:16:15 <startling> yeah. Applicative in general doesn't let you choose an action based on a result.
15:16:16 <bitemyapp> startling: I love symmetry like that. I dunno if it's strictly meaningful but it was neat to me.
15:16:33 <gammaraid> so I know the value will be of type (ExpTree a f) but I don't know how to put that in my type Variabes = [(Var, val)]
15:17:13 <gammaraid> because if I try variables=[(var,ExpTree)] I get an error about ExpTree expecting two parameters, and If I say variables=[(var,(ExpTree x y)] I get an error htat x and y aren't set
15:19:42 <davd> any suggestion on implementing cataM :: (Functor f, Monad m) => (f r -> m r) -> Fix f -> m r ?
15:20:14 <shachaf> It's a good exercise.
15:20:18 <davd> I'm getting stuck in the types..
15:20:24 <shachaf> So my suggestion is if you can't figure it out, save it for later.
15:20:49 <lispy> startling: do you have a citation for that? I'd like to learn more about that result.
15:20:57 <davd> honestly I don't know if it is the right generalization of cata
15:21:31 <startling> lispy: let me see if I can find it.
15:22:08 <startling> lispy, Control.Applicative says "it is sufficient for many uses, e.g. context-free parsing"
15:22:18 <hexagoxel> gammaraid: any reason not to add parameters to the Variables type?
15:22:44 <lispy> startling: I've heard the result before and passed it on myself, but lately couldn't find a good reference that explains the idea
15:23:21 <haasn> davd: doesn't that need MonadFix m?
15:23:59 <lispy> gammaraid: is your tree encoded as the fixed point of a functor? I'm reading the example for ExpTree above and I think you put F where you meant f?
15:24:07 <startling> lispy: the Applicative paper cites some stuff about parsing.
15:24:13 <lispy> startling: thanks, i'll look
15:24:13 * davd takes a look at MonadFix
15:24:18 <haasn> Hmm, no, let me take that back
15:24:29 <davd> okay :)
15:24:32 <haasn> rather, it seems like you need a way to distribute ‚Äòm‚Äô out of ‚Äòf‚Äô
15:24:38 <gammaraid> lispy I did mean f not F sorry
15:24:59 <davd> yeah, one attempt left an extra functor layer
15:25:17 <startling> lispy: "One situation where the full power of monads is not always required is parsing, for
15:25:20 <startling> which R¬®ojemo (1995) proposed a interface including the equivalents of pure and ‚Äò~‚Äô
15:25:23 <startling> as an alternative to monadic parsers (Hutton & Meijer, 1998)."
15:25:37 <haasn> davd: is that type from somewhere?
15:25:37 <startling> I can't find that paper though.
15:26:19 <startling> lispy, there's more right after that, too.
15:26:40 <davd> haasn: I've just added the m's in order to generalize the regular 'cata'. not sure if it's the right approach.
15:28:16 <lispy> startling: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.54.8088&rep=rep1&type=pdf
15:28:24 <haasn> davd: Okay. I looked up the name ‚ÄòcataM‚Äô on hayoo and I found a handful of functions that have a similar shape but different constraints. I suspect your type is impossible to implement (in a sane way), I propose modifying the constraints. I won't tell you what the new constraint should be, to avoid spoiling it :)
15:29:10 <davd> haasn: thanks! great to have some feedback.
15:29:21 <stolaruk> Can someone please help me understand how the "Right results" pattern in the "case" statement is matched in this monadic style algorithm? http://lpaste.net/102343
15:29:53 <stolaruk> I can't wrap my mind around how the recursion works here
15:29:56 <startling> stolaruk: data Either l r = Left l | Right r
15:30:09 <stolaruk> Yes
15:30:23 <startling> stolaruk: that code can be a lot nicer using (>>=) fwiw
15:30:44 <startling> stolaruk: I guess I'm clear on what your question is.
15:30:58 <lispy> startling: the paper I just linked to you seems short
15:31:15 <startling> lispy: I was looking specifically for Hutton & Meijer
15:31:18 <lispy> ah
15:31:27 <lispy> I wouldn't be surprised if the result I'm seeking is due to Wadler
15:31:28 <startling> they're the Functional Pearls paper, but I think that's a different reference?
15:31:33 <mingus> lispy: which paper I am curious :D
15:31:57 <lispy> mingus: we're currently trying to find a reference for the idea that applicative parsers correspond to context-free and monadic to context-sensitive
15:32:10 <startling> lispy: fwiw the Applicative paper touches on it
15:32:19 <lispy> Hutton, Graham, & Meijer, Erik. (1998). Monadic parsing in Haskell. Journal of functional
15:32:22 <lispy> programming, 8(4), 437‚Äì444.
15:32:25 <haasn> stolaruk: this is not a ‚Äúmonadic style algorithm‚Äù
15:32:28 <lispy> mingus: that's the paper we want to find next
15:32:29 <haasn> At least, I would not call it anything like that
15:32:56 <startling> lispy: " Several ingenious
15:32:57 <startling> non-monadic implementations have been developed by Swierstra and colleagues
15:32:57 <startling> (Swierstra & Duponcheel, 1996; Baars et al., 2004). Because the structure of these
15:32:59 <startling> parsers is independent of the results of parsing, these implementations are able to
15:33:02 <startling> analyse the grammar lazily and generate very eÔ¨Écient parsers."
15:33:03 <startling> ugh, sorry for the ridiculous pastes
15:33:04 <mingus> lispy: oh I see
15:33:42 <lispy> startling: ah, so it could be in there as well
15:34:13 * hackagebot octopus 0.0.2.0 - Lisp with more dynamism, more power, more simplicity.  http://hackage.haskell.org/package/octopus-0.0.2.0 (ZankokuOkuno)
15:34:17 <stolaruk> startling: In the first two function bodies there is a Right value for the empty list case, and a Left value for the div by 0 case. I don't clearly understand how the third function body works. I can see how the third function body's case statement will be Left if there is a div by 0, but how can the Right part be matched?
15:35:55 <startling> stolaruk: "divBy _ [] = Right []" <- this is just the base case.
15:36:17 <stolaruk> That terminates the recursion right?
15:36:20 <startling> stolaruk, yeah.
15:36:39 <stolaruk> I see
15:36:55 <startling> stolaruk: "divBy numerator (denom:xs) = case divBy numerator xs of ..." <- this says "run again on the rest of the numbers we're dividing by"
15:37:14 <stolaruk> ok so that will build up thunks for every step
15:37:26 <startling> stolaruk: don't think of it as "building up thunks"
15:37:55 <haasn> thunks are an implementation detail in GHC.
15:37:56 <startling> stolaruk: stolaruk: "... Left x -> Left x" says "if we running it again got an error, this step is an error too"
15:38:52 <startling> stolaruk: "Right results -> Right $ (numerator `div` denom) : results" <- and this one says "If running it again didn't get an error, divide the numerator by the head of the list and prepend the result"
15:38:56 <startling> stolaruk: is that clear?
15:40:03 <startling> lispy: I think it's got to be http://www.staff.science.uu.nl/~swier101/Papers/1996/DetErrCorrComPars.pdf
15:40:06 <stolaruk> Yes it's getting clearer. I guess I am confused bcus the actual dividing is done inside where we are "running it again"?
15:40:26 <startling> stolaruk: yeah, that's odd
15:41:01 <stolaruk> startling: I'm kinda glad to hear you say that. :)
15:41:09 <stolaruk> This is from the RWH chapter on error handling, btw
15:41:09 <startling> stolaruk, I would write the third case as "(:) (numerator `div` denom) `liftM` divBy numerator xs
15:41:28 <startling> stolaruk, ah, they're about to show you a nicer way to do it. :)
15:41:33 <stolaruk> oh ok
15:42:03 <startling> lispy: they even define (<*>)!
15:42:29 <stolaruk> startling: Thank you for your help
15:48:23 <lispy> startling: I'm starting to think the result is obtained by mapping the ideas of <*> and <|> on to BNF
15:48:45 <lispy> I think with just those two you get context-free languages
15:48:50 <startling> lispy: it's possible. I don't see an explicit formulation.
15:49:32 <lispy> startling: http://ps2pdf.com/tgetfile/parsers.pdf?key=1396823892&name=parsers.pdf
15:49:45 <lispy> startling: that's one of the references for the paper youe were just talking about
15:49:51 <startling> Conversion Error
15:49:52 <lispy> and the author makes mention of it
15:49:52 <startling> Unable to find converted file
15:49:55 <lispy> ah
15:50:01 <startling> (I can read postscript, anyhow)
15:50:09 <lispy> startling: http://www.staff.science.uu.nl/~fokke101/article/parsers/index.html
15:51:13 <lispy> startling: in the monadic case, bind allows you to inspect an intermediate value of the computation so that the rest of the computation depends on it. Thus context-sensitive.
15:51:21 <startling> lispy: yeah.
15:52:38 <startling> lispy: "Although in principle you can build parsers for any context-free language using the combinators <*> and <|>..."
15:52:45 <startling> (From the paper you just linked)
15:52:50 <lispy> yeah
15:52:57 <startling> seems like nobody thinks it's worth an explicit proof, heh
15:53:34 <startling> it is really interesting that <*> and <|> predate Applicative itself by quite a bit though
15:55:41 <bitemyapp> I've got to be missing something, where's the arbitrary instance for Text?
15:55:51 <bitemyapp> I can't bring it up on the FPComplete Hoogle nor via Googling.
15:56:01 <bitemyapp> the Test.QuickCheck.Text module is something else.
15:56:24 <bitemyapp> I don't see anything in the text package on Hackage either.
15:56:26 <startling> bitemyapp: quickcheck-instances or something
15:56:41 <startling> yeah.
15:56:55 <RPR> Ok I surrender.  Give its are RC level I don't know what I'm missing to fail to get ghc 7.8 to compile.
15:57:30 <bitemyapp> startling: yep, thanks.
15:57:34 <lispy> RPR: sorry. What?
15:57:36 <bitemyapp> yeesh that was annoying.
15:58:06 <startling> bitemyapp: (it's just pack <$> arbitrary if you don't want the dependency, anyhow)
15:58:07 <lispy> RPR: you can't compile 7.8 or you can't fail to compile 7.8?
15:59:00 <startling> I think RPR means "I don't know what I'm missing [that would cause me] to fail to get ghc 7.8 to compile."
15:59:01 <stolaruk> bitemyapp: "import Test.QuickCheck.Instances()"
15:59:13 <RPR> ghc 7.9 branch builds fine.  But template-haskell 2.8 etc fails.  The 2.8 branch doens't even build with some missing TH.ClassP issue.  Again from Template Haskell.
15:59:56 <lispy> startling: in the wadler paper they cite, wadler says that category theory is not needed to understand this stuff, but the structure it provides helped them put all the pieces together. So I can kind of see how <|> and <*> would predate it.
16:00:10 <startling> yeah.
16:01:16 <RPR> Sorry .. the 7.8 branch doesn't even build ...
16:01:16 <lispy> RPR: You might ask in #ghc. Perhaps you missed a sync-all step.
16:01:35 <lispy> RPR: or did you get a tarball?
16:02:07 <bitemyapp> stolaruk: yeah, already got it.
16:02:13 <bitemyapp> startling: stolaruk thanks :)
16:02:13 <RPR> From git with sync-all
16:02:19 <bitemyapp> unGen'ing my way to valhalla now.
16:02:42 <stolaruk> bitemyapp: I wasn't fast enough :)
16:03:06 <lispy> RPR: in that case, definitely ask in #ghc. They will probably need to know what steps you took to get to where you ar.
16:03:46 <lispy> (and I see that you have asked)
16:11:35 <Rastus_Vernon> Seems the Haskell Wikibook has just taught me the word 'desugared'.
16:16:17 <Rastus_Vernon> And I just learned the word sacrosanct from that very same book.
16:21:52 <lispy> desugared is a word we use a lot :)
16:39:20 * hackagebot cao 0.1 - CAO Compiler  http://hackage.haskell.org/package/cao-0.1 (tfaoliveira)
16:48:43 <super_teufel> hi  I got this problem I need to use Either with Writer so I'm not sure what is best : Either a (Writer b c) or Writer a (Either b c)
16:49:45 <startling> super_teufel: why do you need to use Either with Writer?
16:50:02 <startling> super_teufel, (congratulations, you just invented monad transformers!)
16:50:40 <super_teufel> I need to log and handle pure error
16:50:58 <startling> super_teufel, those two have different semantics -- Writer a (Either b c) writes and then gives you an error or a result. Either a (Writer b c) gives you an error or a result + writing.
16:51:24 <startling> super_teufel, in any case, you probably want WriterT a (Either b) c or EitherT a (Writer b) c.
16:51:44 <super_teufel> ok thank
16:51:59 <startling> super_teufel: so, the question is: does it make sense to have logged data and also an error?
16:52:25 <startling> super_teufel: if so, you want WriterT a (Either b) c.
16:53:52 <super_teufel> startling, thank you I will look for WriterT , I don't know about Monad Transformer  , so  I learn the theory than thank a lot!
16:57:22 <pordan30> this is probably a dumb question, but what's the preferred method for abstracting multiply-parameterized structures into classes? for instance, suppose i have a 'data G i k b a', is is preferred to have a 'class m here f :: m i k b a', or to use associated types and data families, or multi-parameter type classes, or something else? there are lots of solutions, and i'm not sure which is best. for reference, in my case, the i, k, b,
16:57:22 <pordan30> and a should be able to vary across the same instance.
17:00:20 <startling> pordan30: it's a complicated thing and I don't think you've given enough context for an answer
17:00:23 <startling> pordan30: what typeclasses?
17:03:53 <pordan30> i want to abstract a series of graph representations, where the i and k are node and edge indices, and the a and b are node and edge attributes. i would like to define different implementations for different graphs depending on their index type in order to take advantage of more efficient data structures like intmaps and arrays
17:04:36 <startling> pordan30: aha
17:04:55 <startling> profmakx, ok, so type families (especially associated types) will probably be the nicest thing
17:05:06 <startling> profmakx, otherwise multiparamtypeclasses work
17:05:14 <pordan30> my usual approach would be multi-parameter type classes, but associated type families look like a good solutions
17:05:15 <pordan30> yeah
17:05:17 <startling> profmakx: I wrote a similar thing once, let me find it
17:05:50 <startling> profmakx: https://github.com/startling/coatl/blob/master/Language/Coatl/Extra/Graph.hs
17:06:21 <startling> I use a Map directly, which I think is a little more concrete than what you're asking.
17:08:44 <startling> profmakx: but representing a graph as a handful of folds (traversals?) is another option
17:08:49 <startling> errrr
17:08:50 <pordan30> your representation of 'arc' is interesting
17:08:54 <startling> pordan30 ^
17:08:58 <startling> profmakx: sorry.
17:11:04 <pordan30> ah, Fold is from Control.Lens
17:11:09 <startling> yeah.
17:12:23 <pordan30> i really need to work on understanding the more advanced feature of that library :/
17:12:43 <pordan30> in any case, i think some combination of multi-param type classes and associated types should work in my case
17:13:57 <startling> Is there a class like Functor with pure? I want to prove (via parametricity, a la lenses) that a given function is applied at most once.
17:16:17 <yogert> Would there be a way to generalize this? Perhaps with type families or something...?
17:16:17 <yogert> http://lpaste.net/102344
17:16:47 <pordan30> like a pointed functor?
17:18:16 <startling> yeah, I guess that's (Functor f, Pointed f).
17:18:38 <startling> I guess I was thinking of one with Functor as a superclass, but that works too.
17:26:20 <dibblego> what's the latest on pointed functors? still taboo?
17:26:43 <c_wraith> they still lack useful laws
17:26:44 <startling> I don't think they're taboo, other than "there's no laws about them but the free ones"
17:26:58 <dibblego> yeah, but that doesn't sit very comfortably with me
17:27:13 <copumpkin> class MyUsefulClass a where myUsefulMethod :: a
17:27:14 <dibblego> I ask because I wonder if having type-classes inherit others is a good idea, and if not, what about point?
17:27:22 <copumpkin> or how about
17:27:30 <copumpkin> class True a where true :: a
17:27:59 <ion> instance True Void
17:29:10 <jmcarthur> i push against Pointed not because it has no laws but because it has no point
17:29:26 <jmcarthur> i can't think of any case where it's a *useful* overloading
17:29:27 * hackagebot octopus 0.0.2.1 - Lisp with more dynamism, more power, more simplicity.  http://hackage.haskell.org/package/octopus-0.0.2.1 (ZankokuOkuno)
17:29:37 <jmcarthur> (this is related to it having no laws, but i think more directly argues the point)
17:29:49 <startling> why isn't "class Functor f => Pointed f where point :: a -> f a" useful? you could say "fmap f (point a) = point (f a)".
17:30:25 <copumpkin> that's a free law
17:30:28 <copumpkin> from parametricity
17:30:43 <copumpkin> so there's pretty much no way to write an instance that doesn't obey that law
17:30:45 <startling> is it?
17:30:56 <startling> oh, because of the functor laws.
17:30:57 <startling> I see.
17:33:45 <copumpkin> @free point :: a -> F a
17:33:45 <lambdabot> $map_F f . point = point . f
17:35:42 <startling> ah, neat.
17:44:52 <gammaraid> If I have "data PolyType = PT_Int Int |
17:45:15 <gammaraid> If I have "data PolyType = PT_Int Int | PT_Str String" how can I lift a function into PolyType
17:45:49 <gammaraid> I've read over liftM and don't get how I can do a similar thing, or even really how liftM is working
17:50:12 <flebron> What do you mean by "lift a function into PolyType"?
17:52:01 <gammaraid> Flebron make the function and it's parameters PolyTypes? I think...
17:52:07 <gammaraid> same idea as what liftM does...
17:52:11 <copumpkin> @ask ClaudiusMaximus do you think the .rename is actually necessary? It's not as if anyone will be able to link against a regular MPFR anyway. And objcopy isn't available on Mac OS :(
17:52:11 <lambdabot> Consider it noted.
17:52:51 <flebron> gammaraid: What do you mean by "the function"? Which function? Any function? You want to take any function whatsoever and make it """"work"""" (for some definition of that word) with PolyTypes?
17:53:05 <gammaraid> flebron any function with one parameter
17:53:14 <gammaraid> same way liftm works
17:53:25 <flebron> So if I give you f :: Bool -> Bool, what would you do with it?
17:53:43 <gammaraid> Me? Probably cry.
17:54:00 <gammaraid> I'm guessing it'll only really work for ints and strings, I don't know.
17:54:05 <flebron> What would you want to do with this f? What would you mean by "lifting" f?
17:54:16 <flebron> OK, so it's not like liftM then.
17:54:59 <gammaraid> I don't knwo if it would only work for ints and strings... I'm severely confused here
17:55:12 <gammaraid> just seems like I don't see how it would work for bools considering PolyType is defined as ust ints and strings
17:55:29 <flebron> I don't think you're clear on what exactly it is you want to do :)
17:55:34 <gammaraid> No, I'm really not.
17:55:41 <gammaraid> "Given a function f, can you write a function that lifts it into PolyType? "
17:55:55 <gammaraid> that's a study question given to me, and clearly i'm not prepared for my test.
17:55:55 <flebron> "lifting" only makes sense when you have a type constructor that is a Functor (at least).
17:57:12 <flebron> The question doesn't make much sense, don't worry.
17:58:07 <gammaraid> Okay, now can I somehow add to the PolyType data type funcitonality for <, > and =, or do I have to write outside functions for that?
17:58:30 <gammaraid> the same way I'd like override it for C
17:59:51 <flebron> < and > work if you make your type an instance of the Ord typeclass.
18:00:00 <flebron> = works if you make your type an instance of the Eq typeclass.
18:00:09 <flebron> Well, == does.
18:02:30 <gammaraid> flebron but can I write my own? Like I basically want to make it do lexico on the strings, and integer on the ints, and then I'd decide something for whath appens between strings and ints
18:02:59 <flebron> Sure. That's what "making it an instance of Ord" means, you write exactly what "<" means for each pair of elements of your type.
18:03:26 <gammaraid> flebron oh I didn't know that I thought Ord was the set of all like number types
18:04:04 <geekosaur> > 'c' < 'e'
18:04:05 <lambdabot>  True
18:04:09 <geekosaur> where's the number?
18:04:09 <flebron> Nah, that's Num.
18:04:21 <gammaraid> oh... so order probably means like orderable then...
18:04:22 <geekosaur> > "abc" < "def"
18:04:23 <flebron> geekosaur: In the "fromEnum" :p
18:04:24 <lambdabot>  True
18:05:12 <geekosaur> if you can define a meaningful total order on your type, and presuming that you can define the notion of equality on your type beforehand, then you can make it an instance of Ord
18:05:43 <gammaraid> is there any link with like the syntax for doing that?
18:05:44 <geekosaur> note the flip side of Ord vs. Num is that not all "numbers" have total orders.
18:05:51 <gammaraid> I saw it once and have been trying too find it again
18:06:00 <geekosaur> (specifically, complex numbers do not have a meaningful Ord instance)
18:08:20 <geekosaur> (and it's even worse if you consider quaternions, for which there's at least one package available)
18:08:45 <ampharmex> What would the 3537254737455273993th number of this sequence be? http://oeis.org/A053818
18:10:02 <flebron> ampharmex: Really? Here too?
18:10:36 <ampharmex> flebron, I heard Haskell is good for this?
18:10:47 <ampharmex> From the link in the other channel
18:10:57 <flebron> I already gave you the answer in #algorithms, 9813101963883753103128739197863978547234755030454632160
18:11:02 <jmcarthur> ampharmex: the language might be, but that doesn't mean #haskell is a place to ask such questions. this channel is about the language Haskell
18:11:23 <pavonia> Is that an Euler problem?
18:11:31 <ampharmex> No.
18:12:19 <ampharmex> flebron, How about factorize the large number first, then note  sum{P}x = sum{True}x - sum{not P}x
18:12:35 <flebron> ... huh?
18:12:40 <ThatTreeOverTher> how do I use IORefs?
18:12:54 <jmcarthur> ThatTreeOverTher: do you know how to use IO?
18:13:00 <ThatTreeOverTher> nope
18:13:02 <Cale> ThatTreeOverTher: There's not much to it, just the stuff in http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
18:13:12 <jmcarthur> ThatTreeOverTher: i would recommend learning to use IO first
18:13:14 <Cale> and even most of that can be ignored
18:13:35 <Cale> newIORef / readIORef / writeIORef  are usually sufficient
18:13:42 <jmcarthur> ThatTreeOverTher: http://learnyouahaskell.com/input-and-output
18:14:02 <pavonia> ThatTreeOverTher: Seriously, start with a monad tutorial first :p
18:14:35 <jmcarthur> i think monad tutorials tend to be too general. just an IO tutorial would be sufficient :)
18:14:37 <Cale> I don't think you need to know anything about monads to use IO
18:15:00 <pavonia> He's using other monads too
18:15:19 <Cale> Oh, is he? I don't know anything about ThatTreeOverTher's project :)
18:15:23 <flebron> Say that I already """understand""" the categorical notions of applicative and monad. What is a decent path to Kan extensions?
18:15:28 <ThatTreeOverTher> pavonia, I don't get monads though
18:15:53 <ThatTreeOverTher> http://www.haskell.org/haskellwiki/Monad_tutorials_timeline this makes me giggle
18:16:24 <Cale> flebron: Kan extensions as specialised to Haskell, or in general?
18:16:37 <pavonia> ThatTreeOverTher: Awesome! :D
18:16:59 <flebron> Cale: Well, specialized to haskell to start, but also general (perhaps later if that's pedagogically better?)
18:17:00 <Cale> flebron: Almost all of the structure of Kan extensions is obliterated when you smush them down into something which fits entirely in Haskell
18:17:42 <ThatTreeOverTher> pavonia, can you link me to a monad tutorial? there's like 200
18:17:51 <flebron> Would (Co)Yoneda be more useful? Those are just two terms which I've seen in many places and I don't really know much about :)
18:18:06 <Cale> http://comonad.com/reader/category/kan-extensions/
18:18:29 <pavonia> ThatTreeOverTher: Unfortunately, I don't know which is a good one
18:18:32 <Cale> Those are in reverse order :P
18:18:39 <Cale> Start with the one at the bottom
18:19:06 <jle`> there's that original one
18:19:16 <jle`> ThatTreeOverTher: you don't need to 'get' monads
18:19:18 <jle`> :)
18:19:22 <jle`> you just use individual monads
18:19:29 <jle`> as their own separate self-contained things
18:19:32 <ThatTreeOverTher> ok
18:19:32 * hackagebot route-planning 0.0.1 - A library and utilities for creating a route  http://hackage.haskell.org/package/route-planning-0.0.1 (TonyMorris)
18:19:40 <jle`> and one day you will start noticing conceptual patterns yourself
18:20:09 <flebron> Cale: Alright, thanks :)
18:20:10 <jle`> the usage of every monad is different, and their usefulness often time extends from the actual thing, not from the monad
18:20:15 <jle`> *times
18:20:22 <jle`> for example, Maybe
18:20:40 <jle`> Maybe is useful because we can have optional data
18:20:42 <ThatTreeOverTher> jle`, sounds good to me! so how do I create an IORef that doesn't contain anything at first?
18:21:11 <ThatTreeOverTher> like, I want an IORef that stores a gtk2hs EventBox, but I don't have one to fill it with at first
18:21:29 <geekosaur> Maybe
18:21:33 <jle`> maybe
18:21:48 <ThatTreeOverTher> so... moveObject <- newIORef Maybe ?
18:21:49 <jle`> you can make it have a Nothing at first, and a Just EventBox later
18:21:55 <geekosaur> no
18:22:01 <Cale> flebron: I really don't know what a good way to start understanding this stuff is, because I'm not sure about how well I comprehend it myself. (I've read those blog posts, and I "understand" the more general categorical definition of Kan extension, but they're not really integrated properly yet into my picture of how everything fits together.
18:22:07 <geekosaur> that's a type constructor, not a value
18:22:22 <geekosaur> its type would be IORef (Maybe EventBox) or whatever
18:22:24 <ThatTreeOverTher> oh a Nothing is a Maybe? and a Just is a Maybe that contains a thing that isn't nothing?
18:22:27 <geekosaur> and newIORef Nothing
18:22:32 <jle`> ThatTreeOverTher: yeah
18:22:37 <ThatTreeOverTher> whoa
18:22:43 <jle`> kind of like how Bool is either False or True
18:22:48 <jle`> Int is either 0 or 1 or 2 or ...
18:22:54 <jle`> Maybe is either Nothing or Just x
18:22:59 <jle`> er
18:23:05 <jle`> `Maybe a`
18:23:13 <flebron> Cale: I'm taking a course on cat theory starting this friday, so I still don't know a bunch of terms like (co)limits, adjoints, pullbacks/pushforward, (co)equalizers, and the list is cofinite :s
18:23:14 <jle`> is either Nothing or Just x, where x is of type a
18:23:30 <jle`> :t Just 'c'
18:23:31 <lambdabot> Maybe Char
18:23:32 <Cale> flebron: Yeah, usually you save Kan extensions for well after all that stuff
18:23:45 <Cale> flebron: They generalise pretty much all of that
18:23:46 <cdk> What's preventing the overly lazy Writer in mtl from being strictified so as not to cause stack overflows? Are there any cases where old code is depending on the current lazy behaviour?
18:23:50 <jle`> Maybe is a type (like Bool, Int, etc.)
18:23:57 <jle`> Just x and Nothing are data
18:24:03 <jle`> (like True, 13, etc.)
18:24:15 <Cale> (but they do it in a way which still feels a bit awkward to me)
18:24:17 <pavonia> ThatTreeOverTher: It's a bit like a pointer in imperative languages, where Nothing is a null pointer and Just x is a legit pointer pointing to an object x
18:24:21 <jle`> also this doesn't have anything to do with monads
18:24:30 <jle`> unless i didn't read back far enough
18:25:01 <ThatTreeOverTher> yeah that makes sense
18:25:03 <Cale> I'm satisfied enough by adjoint functors :)
18:25:06 <flebron> Cale: Damn. Well, the guy who's teaching it is Eduardo Dubuc, who's apparently an academic son of MacLane
18:25:19 <ThatTreeOverTher> it's basically like a nullable type or something
18:25:30 <jle`> yeah
18:25:35 <jle`> in haskell there is no implicit nulls
18:25:39 <jle`> all nulls are explicit
18:25:50 <ThatTreeOverTher> that makes me happy
18:25:54 <jle`> and are indicated in the type
18:26:06 <flebron> Cale: Is any category other than Hask ever used when doing Haskell cat theory related stuff? Or can I replace every category by Hask when I see it?
18:26:08 <jle`> it's a neat side-effect of haskell's type system that types sometimes serve as annotations on how things can behave
18:26:09 <ThatTreeOverTher> i was just thinking about this in another context today
18:26:10 <jle`> :)
18:26:10 <ThatTreeOverTher> and here it is
18:26:20 <jle`> for example, Maybe Int can be thought of as a nullable int
18:26:36 <jle`> IO Int can be thought of as an int taht can be produced impurely
18:26:41 <jle`> (not really, but...)
18:27:03 <pavonia> jle`: What do you mean by implicit null?
18:27:05 <jle`> Either Exception Int can be thought of as an Int that might also fail with an Exception when you get it
18:27:14 <Cale> flebron: Well, you can consider the Kleisli category for any particular monad
18:27:24 <jle`> pavonia: in Java, for example, a Foo actually is a Null | Foo
18:27:26 <flebron> Oh yeah, that thing. The only other instance of Arrow haha
18:27:35 <jle`> every Foo type is inhabited by null, implicitly
18:27:42 <jle`> and you have to check before you do anything with any Foo
18:27:44 <jle`> that it's not a null
18:27:52 <Cale> Actually, I'm of the opinion that Kleisli m *shouldn't* be an instance of Arrow
18:27:57 <jle`> Cale: :O
18:27:59 <tnks> flebron: Cale: there's a dual category for Hask too, right?  (but that one confuses me still. . . I think there's an ezyang post on it)
18:28:02 <pavonia> Ah, I see
18:28:03 <Cale> (It breaks a law which I think ought to hold of Arrow instances)
18:28:11 <jle`> in Haskell, if you have a Foo, it's a Foo
18:28:17 <Cale> tnks: Well, there's the opposite category, sure.
18:28:18 <jle`> it isn't 'null or Foo'
18:28:39 <ThatTreeOverTher> jle`, writeIORef (Just eventBox) isn't working... what do I do?
18:28:41 <jle`> if something is 'nullable', we can explicitly annotate it as so, in its type
18:28:49 <SrPx> is there something like LambdaCube for webgl?
18:28:50 <jle`> ThatTreeOverTher: it isn't working?
18:28:53 <jle`> what does that mean?
18:28:56 <Cale> Oh, and you can actually think of each individual type as a category, if you want
18:28:59 <flebron> I also don't have a particularly good understanding of Arrow
18:29:00 <jle`> maybe you should consider raising its wages?
18:29:07 <Cale> and the Haskell-definable functions as functors :)
18:29:18 <geekosaur> ThatTreeOverTher, "isn't working" isn't an error report. actual code, full error
18:29:30 <Cale> (but this is really just because each type has a definedness order, and category theory is a generalisation of order theory)
18:29:36 <ThatTreeOverTher> jle`, geekosaur: http://lpaste.net/102345
18:29:58 <ThatTreeOverTher> wow I'm silly, I forgot the actual ref
18:30:13 <ThatTreeOverTher> ignore me
18:30:16 <Cale> There are easy categorical extensions of many results in the recursion theory of DCPOs.
18:30:18 <jle`> :t writeIORef
18:30:19 <lambdabot>     Not in scope: `writeIORef'
18:30:19 <lambdabot>     Perhaps you meant `writeSTRef' (imported from Data.STRef)
18:30:24 <jle`> er well, yeah, you're right
18:30:45 <flebron> Is there a good resource on the link between PLT and cat theory?
18:30:46 <jle`> missing argument error messages are kinda silly actually, to someone who is new to haskell
18:31:06 <geekosaur> yeh, I omitted the ioref in my example
18:31:09 <jle`> 'can't match b with a -> b'
18:31:11 <ThatTreeOverTher> jle`, credit to Haskell for telling me that "Probable cause: `writeIORef' is applied to too few arguments
18:31:11 <Cale> flebron: Well, the book I'm reading right now is sort of such a thing
18:31:11 <ThatTreeOverTher> "
18:31:15 <pavonia> I'm alsways wondered why eventCoordinates yields floating point coordinates
18:31:24 <jle`> ThatTreeOverTher: ah i didn't see that
18:31:24 <pavonia> *I've always
18:31:29 <jle`> that's nice
18:31:36 <Cale> It's Bart Jacobs' Categorical Logic and Type Theory
18:31:38 <ThatTreeOverTher> pavonia, maybe one day i'll move my mouse half a pixel
18:31:42 <ThatTreeOverTher> what then
18:31:52 <jle`> Cale: why don't you think Kleisli m should be an Arrow instance?
18:31:55 <jle`> oh
18:31:58 <jle`> i see your parenthetical
18:32:04 <jle`> what law are you talking about?
18:32:11 <Cale> But even Awodey explains the connection between lambda calculus and Cartesian closed categories
18:32:34 <Cale> jle`: Interchange: (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
18:32:50 <jle`> hm
18:33:05 <Cale> jle`: This fails for Kleisli of any noncommutative monad, because the effects of g and h happen in the opposite order.
18:33:21 <jle`> ah
18:33:27 <jle`> well
18:33:33 <Cale> But it's *critical* to understanding what's going on if you start writing complicated Arrow computations.
18:33:46 <Cale> It's what lets you draw the circuit diagrams and have them be meaningful.
18:33:47 <jle`> oh i see it now
18:33:56 <jle`> that's sort of grave
18:34:06 <jle`> how would you even differentiate those circuit diagrams
18:34:15 <Cale> explicit boxes
18:34:26 <jle`> hm.
18:34:30 <Cale> showing which combinators are being used to paste things together
18:34:34 <jle`> yeah
18:34:36 <Cale> But that sucks
18:34:41 <jle`> it's kind of ew.
18:34:43 <jle`> but
18:34:54 <Cale> But this law holds for essentially any arrowy FRP library
18:34:59 <jle`> yeah
18:35:04 <jle`> but fails for any noncommutative monad
18:35:08 <Cale> yeah
18:35:15 <Fuuzetsu> is there better way for removing a single element from a list than ‚Äòxs \\ x‚Äô?
18:35:15 <Cale> It allows you to have "local" state
18:35:18 <Fuuzetsu> oops
18:35:23 <Fuuzetsu> ‚Äòxs \\ [x]‚Äô?
18:35:30 <Cale> But you can't have invisible state connections between things
18:35:40 <pavonia> :t delete
18:35:41 <lambdabot> Eq a => a -> [a] -> [a]
18:35:46 <Fuuzetsu> awesome
18:36:22 <jle`> Cale: but this is a problem for any arrow instance that is a monad transformer
18:36:26 <jle`> er
18:36:28 <jle`> that wraps a monad
18:36:58 <Cale> Not sure what you mean there
18:37:09 <jle`> hm.  well there's the netwire Wire
18:37:12 <jle`> Wire m a b
18:37:21 <Cale> Yeah, that might fail
18:37:26 <jle`> but
18:37:27 <Cale> Unless m is just a plain Reader
18:37:39 <jle`> the m parameter is mostly there for performance hacks, as i have gathered
18:37:44 <Cale> yeah
18:37:48 <Cale> I'd imagine
18:37:54 <Fuuzetsu> when are we going to get automatic type resolution for ‚Äòambiguous‚Äô function names? Say, ‚Äòdelete‚Äô from both Data.List and Data.Map, it should be easy to tell which one we want to use be the things we use it on. Agda does this ;(
18:37:56 <jle`> and i think it is expected that it will break analysis
18:38:20 <jle`> still, it is useful to have it as an Arrow instance
18:38:33 <c_wraith> Fuuzetsu: when you manage to convince enough people that's not a net negative
18:39:02 <jle`> are there any useful unlawful monads?
18:39:18 <Cale> jle`: I suppose you might consider ListT useful
18:39:19 <Fuuzetsu> c_wraith: I can't see what there is to be convincing people about, if GHC can't tell which one is the good one to use then just print the error it does now. Are there any downsides I can't see?
18:39:33 <Cale> jle`: Though, there's LogicT which creates real monads
18:40:26 <jle`> Cale: ah
18:40:49 <jle`> well perhaps kleisli should just be prefaced with some sort of annotation
18:40:56 <jle`> and other non-interchange arrows
18:41:44 <geekosaur> Fuuzetsu, there's stuff on type-directed name resolution on the haskell wiki
18:41:55 <geekosaur> including discussion of the downsides, iirc
18:42:28 <Fuuzetsu> got a link?
18:44:15 <jle`> Fuuzetsu: would you let people define multiple functions with the same name at the global space, but with different types? that'd be kinda neat but horrifying
18:46:10 <geekosaur> http://www.haskell.org/haskellwiki/TypeDirectedNameResolution
18:46:25 <geekosaur> (sorry for delay, local network is acting up)
18:48:00 <Fuuzetsu> jle`: I'd basically allow what Agda does, whatever doesn't clash with types is fine but once something clashes you have to start clarifying. FYI top-level names are not allowed but things like field names are (due to nice side effect that Agda records are modules of their own). So I guess I would not allow top-level names to be the same in the same module.
18:48:25 <Fuuzetsu> geekosaur: > Simon PJ (I wrote the proposal)
18:48:31 <Fuuzetsu> well that's sorted, when can we expect it ;)
18:49:20 <Cale> Fuuzetsu: Well, look at the arguments against as well...
18:49:21 <organmeat> is this code formatting going to work, or should I change it?
18:49:22 <organmeat> http://imgur.com/feq03xk
18:49:44 <Cale> Fuuzetsu: It's not *obviously* a good thing. It's convenient in some ways, but can result in very confusing behaviour in others.
18:49:45 <gamegoblin> is there a way I can rewrite \s -> f s ++ g s , with some sort of applicative nonsense or arrow or something?
18:50:11 <ion> gamegoblin: Yes but what‚Äôs wrong with the original?
18:50:22 <gamegoblin> Nothing at all. Just curious.
18:50:33 <Cale> Oh, right, also the syntax in that version of the proposal is a bit of an abomination
18:50:34 <byorgey> gamegoblin: liftA2 (++) f g
18:50:48 <gamegoblin> mmm gotcha
18:50:53 <jle`> gamegoblin: (++) <$> f <*> g
18:51:02 <Cale> We really don't need to overload '.' any more than it already is. Using it as a module path separator in the first place was questionable enough :)
18:51:29 <jle`> [Foo..] being broken is kinda annoying too
18:51:32 <Fuuzetsu> Cale: it seems that pretty much all complaints are about the '.' syntax; I say split that off into it's own proposal depending on this one and people can fight over that later.
18:51:35 <ion> Let‚Äôs make ‚Äú.‚Äù the DWIM token.
18:51:47 <Fuuzetsu> Let's not have the DWIM token.
18:51:51 <Cale> Fuuzetsu: They're not all about that though
18:52:43 <gamegoblin> I have a list of functors. If I want to apply a function to my list of functors, is the best way to do it ‚Äúmap (fmap f) myList‚Äù
18:53:43 <bitemyapp> gamegoblin: have yeh heard of applicative laddie?
18:54:01 <ion> gamegoblin: Or (map . fmap) f myList
18:54:05 <gamegoblin> bitemyapp: Not super good at applicative yet
18:54:06 <Cale> Fuuzetsu: It's a really nice property of the language as it exists now that one can always type  :t foo  in ghci and get a type signature, rather than a complaint about ambiguity.
18:54:07 <jle`> or (fmap . fmap)
18:54:09 <Fuuzetsu> Cale: Certainly a majority. If we were to split off the proposal into ‚Äòsimple stuff‚Äô (regular application), ‚Äòmore advanced stuff‚Äô (GADTs, TFs) and the ‚Äò. syntax‚Äô then I think the majority of people would vote positively for the simple stuff and then we could spend time fighting about the rest.
18:54:09 <jle`> :P
18:54:15 <bitemyapp> gamegoblin: consider it an opportunity to learn.
18:54:22 <gamegoblin> That‚Äôs why I‚Äôm asking ;)
18:54:45 <jle`> i wonder if there is a common alias for fmap . fmap
18:54:55 <jle`> you can also do fmap f <$> myList
18:54:56 <bitemyapp> jle`: ffmap
18:55:05 <jle`> or (f <$>) <$> myList
18:55:06 <Fuuzetsu> Oh look, yet another day where someone is in need of fmap fmap fmap alias
18:55:07 <jle`> hehe
18:55:14 <bitemyapp> Fuuzetsu: t'was me the other day.
18:55:16 <ion> gamegoblin: Btw, it‚Äôs not a list of functors. [], Maybe and IO are Functors. "hello", Nothing and getLine are not.
18:55:18 <bitemyapp> fffmap
18:55:30 <Fuuzetsu> bitemyapp: and me like billion other times along with tens of others ;)
18:55:36 * bitemyapp shrug
18:55:44 <bitemyapp> Fuuzetsu: I regretted the code a little :)
18:55:49 <gamegoblin> ion: It‚Äôs a [Result] where Result is a functor
18:55:52 <jle`> > let ffmap = fmap.fmap in ffmap (*2) [[1,2,3],[4,5,6]]
18:55:53 <lambdabot>  [[2,4,6],[8,10,12]]
18:55:55 <Fuuzetsu> I regret not having the shorthands in Prelude
18:56:13 <ion> gamegoblin: That‚Äôs a type error.
18:56:22 <ion> @type undefined :: [Maybe]
18:56:23 <lambdabot>     Expecting one more argument to `Maybe'
18:56:23 <lambdabot>     In an expression type signature: [Maybe]
18:56:23 <lambdabot>     In the expression: undefined :: [Maybe]
18:56:31 <gamegoblin> errr yes
18:56:41 <gamegoblin> a list of [Result a] ;)
18:56:45 <Cale> Fuuzetsu: Also, with type directed name resolution in general, you make it substantially less likely that it's a valid refactoring to snip out a subexpression and put it into a 'where' clause without at the same time giving an explicit type signature.
18:56:52 <gamegoblin> I see what you mean now
18:58:12 <Cale> Fuuzetsu: and on top of that, we do have type classes, which cover similar ground in a way that plays better with type inference.
18:58:17 <jle`> what should the proper terminology be
18:58:26 <flebron> What does cabal mean when it says "oeis-0.3.5 (reinstall) changes: HTTP-4000.2.12 -> 4000.2.10, network-2.4.2.2 -> 2.4.2.0"? I already have HTTP-4000.2.12, but it fails to install oeis-0.3.5 because it can't find Network.HTTP (I can "import Network.HTTP" just fine in GHCi)
18:58:26 <jle`> i actually asked this
18:58:29 <jle`> a while ago
18:58:59 <jle`> i noticed that for Category cat, an actual value of type cat a b has a neat name already
18:59:09 <jle`> but for Functor f, an actual value of type f a doesn't really have a neat name
18:59:14 <jle`> 'mappable data'
18:59:31 <gamegoblin> Mmm that‚Äôs not too bad
18:59:34 <jle`> idk
18:59:35 <gamegoblin> ‚ÄúI have a list of mappable data"
18:59:37 <gamegoblin> sounds fine
18:59:42 <jle`> i have a list of fmappable
18:59:49 <byorgey> flebron: it means for some reason it thinks it needs to build oeis against older versions of HTTP and network
19:00:02 <byorgey> flebron: which is unlikely to end well.
19:00:22 <byorgey> flebron: but to know WHY it thinks it needs to do that, you need to look at the output of  cabal install --dry-run -v3
19:00:29 <jle`> also Monad m => m a doesn't really have a good name either
19:00:30 <Rastus_Vernon> The Haskell Wikibook is amazingly good at teaching words‚Ä¶ I just learned a third word from it today: rote. The two others I learned are desugared and sacrosanct.
19:00:40 <jle`> Rastus_Vernon: haha
19:00:42 <ion> I have heard people talk about monadic values but i‚Äôm not sure ‚Äúfunctoric‚Äù is something anyone says. :-P
19:00:50 <jle`> monadic value, yeah
19:00:58 <jle`> i remember that was what people came up with :| and functoric too
19:00:59 <Rastus_Vernon> It seems to me like an excellent vocabulary textbook.
19:01:17 <gamegoblin> functoral values ;D
19:01:23 <Cale> "Functorial" is the adjective relating to "functor"
19:01:28 <gamegoblin> I was close
19:01:30 <Cale> But that means something different
19:01:31 <ion> cale: thanks
19:01:36 <ion> heh
19:01:40 <byorgey> names I have heard for  Monad m => m a:  monadic value, action, mobit
19:01:48 <ion> Some people also advocate ‚Äúmote‚Äù, so‚Ä¶ fute? :-P
19:01:48 <jle`> mobit
19:01:48 <shachaf> I like the word "action".
19:01:51 <Fuuzetsu> Cale: I don't understand, there should be no cases where nowadays something works and after TDNR we're forced to add a type signature. I haven't read the proposal linked on the page carefully but I was under the impression that it would simple reduce number of ambiguity errors that we get today, and never increase it.
19:01:54 <byorgey> oh, mote too.
19:02:02 <jle`> mote is cute
19:02:02 <gamegoblin> I don‚Äôt like action, because a monadic value isn‚Äôt always an action, no?
19:02:03 <flebron> byorgey: Here's the.. kind of weird thing. If I "cabal install oeis", I install it (0.3.5) fine. If I cabal install lambdabot, it fails while installing oeis-0.3.5: http://lpaste.net/102347
19:02:03 <byorgey> I have never wanted a term for   Functor f => f a
19:02:08 <byorgey> because those are not very useful.
19:02:08 <gamegoblin> For instance, the Free monad is just data
19:02:09 <jle`> mote, fote, aote
19:02:17 <shachaf> byorgey: You mean Functor f *> f a :-)
19:02:41 <jle`> what is :-), is that a postfix operator
19:02:42 <Fuuzetsu> flebron: it might be passing in different flags
19:02:56 <ion> > ("hello" :-)
19:02:57 <shachaf> (The f is existential -- you're not asking the reader for the Functor constraint,  you're saying that f is a Functor instance yourself.)
19:02:58 <lambdabot>  Not in scope: data constructor `:-'
19:02:58 <lambdabot>  Perhaps you meant one of these:
19:02:58 <lambdabot>    `Seq.:>' (imported from Data.Sequence),
19:02:58 <lambdabot>    `:+' (imported from Data.Complex),
19:02:58 <lambdabot>    `Seq.:<' (imported from Data.Sequence)
19:03:03 <byorgey> shachaf: *> is an existential constraint?
19:03:04 <shachaf> "action" makes a lot of sense for Monad, a fair amount of sense for Applicative, and some sense for Functor.
19:03:05 <byorgey> right, ok
19:03:18 <shachaf> byorgey: There's no official syntax for it but it's the one ski uses.
19:03:23 <flebron> Fuuzetsu: How would I 1) debug, 2) fix that?
19:03:26 <byorgey> right, I think I've seen it before
19:03:43 <jle`> i will call them motes
19:03:56 <jle`> until the end of my days
19:04:07 <Fuuzetsu> flebron: 1) run cabal with -v2 or -v3 and stare at it a lot 2) Depends on what the actual problem turns out to be, probably pestering someone who knows what they are doing
19:04:07 <Cale> Fuuzetsu: If you snip out some bit of code and put it into its own declaration, then the generalisation step happens at the top of that new declaration, and if TDNR were around, the type involved in a particular name might be ambiguous, whereas at present, that code would already have been qualified, or another name would have been used, such that there would be no ambiguity to begin with.
19:04:09 <shachaf> It's slightly pedantic but seeing => used that way irks me a little bit.
19:04:18 <shachaf> I think it's an important distinction to make.
19:04:26 <k4r1m> This is a follow up to gammaraid's question earlier. What's wrong with this?  http://lpaste.net/102348 error: "The first argument of `Functor' should have kind `* -> *' but PolyType has *"
19:04:30 <flebron> "[106] next goal: HTTP (dependency of lambdabot-4.3.0.1)" => ""[106] rejecting: HTTP-4000.2.12/installed-5ac... (conflict: wai => network==2.4.2.0/installed-a05..., HTTP => network==2.4.2.2/installed-022...)"
19:04:38 <byorgey> shachaf: you have a point. I am chastened.
19:05:00 <ion> Œª> ("hello" :-)
19:05:03 <ion> (:-) "hello"
19:05:15 <byorgey> k4r1m: have you learned about kinds?
19:05:17 <gamegoblin> Functored values ;)
19:05:29 <jle`> fotes
19:05:35 <jle`> they are totes fotes
19:05:39 <byorgey> k4r1m: Functor only applies to things of kind * -> *, that is, "types that take a type argument"
19:05:58 <Fuuzetsu> Cale: But there's no case where this is actually a problem. With new code you get ambiguity error whether you have TNDR or not. With old code it's already qualified so there's no issue at all with taking it out of the expression. The proposal doesn't suddenly drop any qualifications we currently have.
19:06:18 <k4r1m> byorgey: so types with no arguements are not applicable ?
19:06:25 <byorgey> k4r1m: correct.
19:06:41 <byorgey> k4r1m: also, fmap is supposed to be able to take a function of *any* type and map it over the structure, so there is no guarantee you will be able to apply it to an Int or a String
19:06:41 <Fuuzetsu> If it doesn't work today, it might work in the future. If it doesn't work in the future, it wouldn't have worked today either.
19:06:52 <ion> Btw, would it be especially difficult to add ‚Äúexists‚Äù and ‚Äú*>‚Äù into GHC Haskell?
19:07:16 <shachaf> ion: So I'm told.
19:07:21 <k4r1m> byorgey: how do you suggest I achieve the desired result then?
19:07:30 <shachaf> ion: UHC (I think?) has "exists" but no existential constraints.
19:07:36 <ion> shachaf: ok
19:07:38 <byorgey> k4r1m: what is your desired result?
19:07:38 <jle`> k4r1m: well, what do you want to make a Functor?
19:07:39 <geekosaur> ion: exists as the "opposite" of forall, you mean? IIRC there are complications with that
19:07:52 <geekosaur> wrt ghc's internals
19:07:53 <k4r1m> that is allow a function of *any* map over a list of PolyType
19:08:10 <shachaf> ion: I don't care about existential constraints as much -- just exists on its own would be nice -- but even then I'm not quite sure how it should behave.
19:08:18 <jle`> k4r1m: well
19:08:24 <jle`> you can't
19:08:33 <byorgey> k4r1m: so you mean it will have no effect if the type of the function does not match?
19:08:37 <shachaf> Is it inferrable at all? Is type-checking "local"?
19:08:41 <k4r1m> byorgey: yes
19:09:03 <shachaf> I guess a lot of the answers to the same questions about rank-2 types can apply to existentials.
19:09:22 <jle`> what would fmap (== 3) (PT_Int 4) be?
19:09:43 <byorgey> k4r1m: you could accomplish that with a Typeable constraint on the function being passed as an argument, like  mapPoly :: Typeable a => (a -> a) -> PolyType -> PolyType.  You can use the 'cast' function to see if the type matches.
19:09:50 <k4r1m> jle`: []
19:09:52 <byorgey> k4r1m: I don't particularly recommend this, however.
19:10:03 <Rastus_Vernon> Eh, GHCi‚Äôs :edit is great! I just discovered it and I can edit .hs files with nano without leaving GHCi since it automatically reloads it after I have edited it.
19:10:13 <byorgey> k4r1m: most likely, there is a much simpler way to achieve whatever your higher-level goal is.
19:10:16 <jle`> k4r1m: [] ... of what type?
19:10:19 <Rastus_Vernon> Perfect for following Haskell tutorials that require editing files and loading them into GHCi.
19:10:33 <Cale> Rastus_Vernon: For the most part I would recommend leaving your editor open *alongside* ghci though
19:10:34 <k4r1m> jle`: PolyType
19:10:34 <Fuuzetsu> Rastus_Vernon: I imagine most people just use GHCi inside their editors.
19:10:42 <shachaf> Oh, maybe existential types wouldn't be impredicative.
19:10:45 <Cale> Rastus_Vernon: (in a separate window)
19:10:48 <jle`> k4r1m: [] has to be a list of something
19:10:52 <jle`> it can't be a PolyType
19:10:52 <shachaf> By which I actually mean that things like [exists a. a] wouldn't be allowed.
19:10:57 <Cale> Rastus_Vernon: You can use :r in ghci to reload the current file
19:11:05 <jle`> [] :: [Int], or [] :: [Bool] ...
19:11:07 <jle`> :t []
19:11:08 <lambdabot> [a]
19:11:15 <shachaf> That sounds like it'd make inference much simpler.
19:11:27 <k4r1m> let me rephrase the desired goal.. I think
19:11:30 <byorgey> jle`: you can imagine this working like I outlined above, but you have to pass a function of type  (a -> a)
19:11:30 <Cale> Fuuzetsu: I tend to prefer keeping ghci in its own window, even when I'm using emacs :)
19:11:31 <Rastus_Vernon> Cale: Well, this allows me to not have to change applications at all.
19:11:39 <byorgey> jle`: so  (== 3) would not be allowed
19:11:48 <shachaf> Or s/inference/checking/, whatever.
19:11:55 <Rastus_Vernon> Cale: I have my web browser open and my terminal shows in an overlay at the bottom of the screen.
19:11:57 <Fuuzetsu> Each to their own.
19:11:58 <jle`> yeah
19:12:05 <jle`> so Functor isn't waht he is looking for
19:12:08 <Cale> Rastus_Vernon: I usually want to be able to see both at once.
19:12:12 <Fuuzetsu> but you don't get things like jump to error/warning that way
19:12:39 <k4r1m> fmap (== 3) [PT_Int 4, PT_Int 3])  return [PT_Int 3]
19:13:05 <jle`> functor is specifically for things that can hold things of any type and can map using any function
19:13:26 <tapuu> I'm getting socketclosed from both ends of a tcp connection, and nothing seems to be closing the socket
19:13:28 <tapuu> great
19:13:48 <jle`> k4r1m: do you mean map (fmap (== 3)) ?
19:13:53 <jle`> (but it wouldn't work that way either)
19:14:03 <jle`> Functors are for things that can hold things of any time and that you can map over using any function
19:14:03 <k4r1m> yeah oops
19:14:37 <k4r1m> Okay hmm I don't think that's whats wanted then. This is really just a for a class.
19:14:38 <jle`> there is the MonoTraversable typeclass which are things that can hold only one type and can only be mapped over using (a -> a)'s
19:14:49 <jle`> but it's a bit complicated for a new person
19:16:04 <k4r1m> the question is really ambiguous "Given a function f, can you write a function that lifts it into PolyType?"
19:16:04 <jle`> there is also a possible hacky typeclass based solution
19:16:20 <jle`> k4r1m: well, the answer is no :)
19:16:23 <jle`> i would think.
19:16:46 <k4r1m> so I didn't misinterpret it ?
19:16:54 <jle`> it's a yes or no question, right?
19:17:12 <jle`> you can't apply any arbitrary function to the thing inside a PolyType...for example, consider (const False)
19:17:21 <k4r1m> He usually doesn't ask no questions haha typically wants to code something up
19:18:30 <jle`> well there's a first time for everything :)
19:19:10 <k4r1m> so what if the data type had an arguement ?
19:19:37 <k4r1m> argument*
19:19:39 * hackagebot exception-mailer 0.4.1 - Catch all runtime exceptions and send an email  http://hackage.haskell.org/package/exception-mailer-0.4.1 (DavidPowell)
19:19:52 <jle`> k4r1m: if you mean like PolyType a
19:19:58 <k4r1m> yes
19:19:59 <jle`> then you can
19:20:01 <jle`> but only if
19:20:03 <jle`> your mapping function
19:20:06 <jle`> does not have any constraints
19:20:22 <k4r1m> what do you mean?
19:20:46 <jle`> for example byorgey's earlier mapPoly
19:21:07 <jle`> was mapPoly :: (Typeable a, Typeable b) => (a -> b) -> PolyType a -> PolyType b
19:21:08 <jle`> or well
19:21:10 <jle`> not exactly
19:21:22 <jle`> you needed a constraint to map it
19:21:32 <k4r1m> wasn't that using a Typeable though?
19:21:41 <jle`> i mean, that's just an example
19:21:48 <jle`> there is also Data.Set's "map" function
19:21:59 <jle`> mapSet :: Ord b => (a -> b) -> Set a -> Set b
19:22:03 <k4r1m> Okay, I'll try to writing it quickly
19:22:19 <jle`> you can only 'map' over elements of a set if the thing you are mapping to is an instance of Ord
19:22:26 <jle`> so Set can't be a Functor
19:35:07 <k4r1m> what's ::: used for?
19:35:22 <k4r1m> (triple colons)
19:37:34 <jle`> it's just a normal ol data constructor i think
19:51:22 <johan_> I've try finding what Just means but achieved nothing. Could anybody tell me something about it?
19:52:05 <Cale> johan_: Just is one of the two data constructors for Maybe
19:52:08 <startling> johan_, data Maybe a = Just a | Nothing
19:52:19 <Cale> Nothing :: Maybe a
19:52:27 <Cale> Just :: a -> Maybe a
19:52:38 <Cale> So for example,  Just 5 :: Maybe Integer
19:52:44 <Cale> and  Just "hello" :: Maybe String
19:52:52 <startling> and Nothing :: Maybe String
19:53:50 <Cale> This is a useful data type to indicate that some parameter is optional, or that some operation may fail to produce a result.
19:54:14 <Cale> Nothing indicates the absence of a value, while Just x indicates the presence of the value x.
20:02:32 <jmcarthur> "I've try finding what Just means but achieved nothing." Well, at least you found Nothing. That's something!
20:03:49 <bitemyapp> jmcarthur: where was this?
20:04:13 <monochrom> haha pun
20:05:42 <shachaf> @djinn Maybe (a -> Maybe a)
20:05:42 <lambdabot> f = Nothing
20:05:46 <shachaf> Boring.
20:06:55 <startling> haha
20:07:12 <flebron> There's a buddhist quote somewhere in there
20:07:17 <bitemyapp> sometimes I feel like the bot's answers are it being a smart-ass.
20:07:18 <startling> @djinn (a -> Maybe b) -> Maybe a -> Maybe b
20:07:19 <lambdabot> f a b =
20:07:19 <lambdabot>     case b of
20:07:19 <lambdabot>     Nothing -> Nothing
20:07:19 <lambdabot>     Just c -> a c
20:07:56 <startling> it's surprising that that works and the other thing doesn't.
20:07:58 <flebron> bitemyapp: I think that every time I forget a "let" in GHCi. "parse error on input `='". You know very well what I mean. I know you don't have state, let's pretend you do for a session :/
20:08:19 <bitemyapp> flebron: I've gotten to point where I don't forget that anymore.
20:08:40 <bitemyapp> just baked in. Only get yelled at so many times before I dun know any better :)
20:08:45 <flebron> I think I'll patch GHCi to accept "Simon says" instead of "let":
20:08:55 * bitemyapp laughs
20:08:58 <flebron> (Or, really, SPJ says)
20:09:11 <bitemyapp> I legitimately remember it's a do block.
20:09:25 <bitemyapp> flebron: 80% of my programming happens in ghci, which might explain why I've adapted.
20:09:38 <bitemyapp> even when it doesn't, I'm saving in Emacs and then :r'ing
20:27:36 <chrisw__> How do I install the profiling library for "base"? I would like to use profiteur but I get an error about not finding "Prelude" and the profiling library for "base".
20:27:57 <Fuuzetsu> chrisw__: that comes with profiled compiler, you can't recompile it yourself
20:28:00 <geekosaur> how did you install ghc?
20:28:08 <chrisw__> apt-get install ghc
20:28:43 <geekosaur> so you need to install ghc-prof
20:28:45 <chrisw__> I see there is ghc-prof - do I want that one?
20:28:48 <chrisw__> ok
20:35:32 <chrisw__> Is it a particularly good or bad idea to use an IORef to store mouse button state between mouse drag events in GTK?
20:36:43 <pavonia> Heh, I had the same problem recently and haven't found any other solution yet
20:38:33 <Rastus_Vernon> Uh‚Ä¶ at the moment, I use a rather crude way to unload all modules from GHCi. I have an error.hs file that contains invalid code. When I load it with :load, GHCi raises an error and unloads all modules.
20:38:45 <Rastus_Vernon> Any suggestion on a better way to do this?
20:39:06 <pavonia> ":load" doesn't work?
20:39:17 <Rastus_Vernon> It loads modules.
20:39:20 <Rastus_Vernon> I want to do the opposite.
20:39:27 <Rastus_Vernon> (unless it actually does both?)
20:39:40 <pavonia> Yes, I mean literally just ":load"
20:39:50 <Rastus_Vernon> That unloads the modules?
20:40:03 <pavonia> I think so
20:40:28 <Rastus_Vernon> It does! :o
20:40:47 <Rastus_Vernon> Where is this stuff documented? I use :h, but that only provides limited help.
20:42:41 <schlegel> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/ghci-commands.html
20:42:43 <chrisw__> :m will unload all modules as well, with the advantage that you can do :r to reload the file
20:44:32 <Rastus_Vernon> Ah, thanks.
20:45:12 <Rastus_Vernon> What is :m an alias of? (if it is one)
20:45:38 <pavonia> :module
20:50:56 <mindleyhilner> any cabal gurus around?
20:58:12 <startling> I'm not sure such a thing exists.
20:59:50 <pavonia> chrisw__: Re your gtk question, can you elaborate what exactly you are doing and what mouse button state you mean?
21:00:39 <chrisw__> I need to be able to click and drag on a window which displays an image and store the pixel values in one list if it's the left mouse, and another list if it's the right mouse button.
21:01:05 <sgronblo> Is there some known problem with haskell-platform on brew atm? I get to make install for haskell-platform-2013.2.0.0 but judging by the output of htop the make process doesnt seem to do anything,
21:01:44 <k4r1m> jle` byorgey: not sure if you're still around but I just discovered "pure" it looks like it can potentially solve the earlier problem we discussed earlier
21:02:27 <pavonia> chrisw__: I've just found that the Button* modifieres are set when you use eventModifierAll (but not with eventModifier)
21:03:32 <chrisw__> pavonia, awesome, I'll check it out right now
21:06:03 <chrisw__> pavonia, it works, thanks for making me aware of this!
21:06:17 <pavonia> no problem
21:06:57 <pavonia> Fell free to hang out in #gtk2hs too :p
21:08:29 <chrisw__> ah, I hadn't heard of the channel
21:16:52 <Fuuzetsu> me neither, seems new
21:17:56 <Fuuzetsu> pavonia: I don't imagine you know much about pango? See https://github.com/yi-editor/yi/issues/478 for our problem.
21:18:57 <pavonia> Hhm, no
21:19:53 * hackagebot competition 0.2.0.0 - Helpers and runners for code competitions  http://hackage.haskell.org/package/competition-0.2.0.0 (yanatan16)
21:28:30 <sgronblo> Are you supposed to update cabal-install manually with cabal install cabal-install?
21:29:02 <startling> sgronblo: yeah.
21:29:33 <startling> sgronblo: note that that will install the new executable in ~/.cabal/bin, so that should be in your path before wherever the system cabal lives
21:30:51 <sgronblo> that sounds a bit unexpected
21:31:04 <sgronblo> anyway, i cant get it to compile correctly anyway
21:31:14 <startling> sgronblo: cabal installs things per-user.
21:31:36 <startling> sgronblo, can you paste the error to e..g lpaste.net?
21:31:41 <sgronblo> And now todays Haskell lunch break ends before me writing a single line of code
21:32:56 <arboris> startling: depends on how your path is aranged
21:38:04 <startling> arboris, everything depends on how your path is arranged
21:43:13 <sgronblo> startling: http://lpaste.net/1528304081523703808 if you got the time, here is the output of cabal install cabal-install
21:43:48 <startling> sgronblo: I think you're on an unsupported ghc version. what's ghc --version?
21:48:36 <sgronblo> i already put away my private laptop, but one odd thing was that i had ghc installed but brew said i didnt have haskell-platform installed, so i dont remember where my orphaned ghc could come from. havent had time to try haskell in a long time.
21:49:48 <startling> sgronblo, you might have installed it from the package. I think that comes with a ghc-uninstall executable or something.
21:50:05 <startling> sgronblo: also note that the haskell-platform and ghc are different things.
21:54:22 <sgronblo> but ghc is contained in hp
21:54:46 <geekosaur> it is, but it can be installed without the platform
21:55:13 <sgronblo> yeah, cant say for sure how i installed it originally any more. but i dont see why i wouldnt have used brew.
22:08:17 <joneshf-laptop> how do you annotate a type with an instance?
22:08:31 <joneshf-laptop> like ifyou wanted to say :t (<*>) as List
22:08:33 <joneshf-laptop> or something
22:09:43 <jle`> :t [] (<*>)
22:09:44 <lambdabot>     Couldn't match expected type `(f0 (a1 -> b0) -> f0 a1 -> f0 b0)
22:09:44 <lambdabot>                                   -> t0'
22:09:44 <lambdabot>                 with actual type `[a0]'
22:09:52 <jle`> @src [] (<*>)
22:09:52 <lambdabot> (<*>) = ap
22:10:01 <apples> :t (<*>) :: [a -> b] -> [a] -> [b]
22:10:02 <lambdabot> [a -> b] -> [a] -> [b]
22:10:09 <jle`> oh you'd use asTypeOf i think
22:10:13 <jle`> :t asTypeOf
22:10:14 <lambdabot> a -> a -> a
22:10:21 <jle`> hm
22:10:35 <jle`> nvm i'm not sure
22:10:56 <joneshf-laptop> i remember someone doing it in here the other day
22:11:03 <geekosaur> :t [] <*> ?f
22:11:04 <lambdabot> (?f::[a]) => [b]
22:11:50 <geekosaur> oh
22:11:57 <geekosaur> :t ?f <*> []
22:11:58 <lambdabot> (?f::[a -> b]) => [b]
22:12:01 <geekosaur> there we go
22:12:18 <geekosaur> or even
22:12:26 <geekosaur> :t ?f <*> [?a]
22:12:27 <lambdabot> (?f::[a -> b], ?a::a) => [b]
22:12:27 <athan> was that a type hole?
22:12:34 <geekosaur> implicit parameter
22:12:37 <jle`> :t [] <*> []
22:12:38 <lambdabot> [b]
22:12:38 <athan> hmm!
22:12:50 <geekosaur> which makes a nice typechecking hack, but is not quite the same a sa type hole
22:12:54 <geekosaur> it''s a "value hole"
22:12:57 <jle`> :t \f xs ->f <*> xs
22:12:58 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:13:10 <jle`> :t \f -> f <*> []
22:13:11 <lambdabot> [a -> b] -> [b]
22:13:19 <athan> ahh, so is this an extension?
22:13:22 <geekosaur> yes
22:13:27 <athan> This reminds me a lot of dependent types
22:13:28 <athan> ahh okay
22:13:29 <geekosaur> ImplicitParameters
22:13:45 <athan> that's really cool!
22:13:45 <jle`> :t \f xs -> f <*> (xs :: [b])
22:13:46 <lambdabot>     Couldn't match expected type `t' with actual type `[b1]'
22:13:46 <lambdabot>       `t' is a rigid type variable bound by
22:13:46 <lambdabot>           the inferred type of it :: [a -> b] -> t -> [b] at Top level
22:14:02 <joneshf-laptop> :t (<*>) as []
22:14:02 <lambdabot>     Not in scope: `as'
22:14:02 <lambdabot>     Perhaps you meant one of these:
22:14:02 <lambdabot>       `abs' (imported from Prelude),
22:14:27 <copumpkin> :t (<*>) `asTypeIn` \f -> f <*> []
22:14:28 <lambdabot>     Couldn't match expected type `[a1 -> b1]'
22:14:28 <lambdabot>                 with actual type `f0 (a0 -> b0) -> f0 a0 -> f0 b0'
22:14:28 <lambdabot>     In the first argument of `(<*>)', namely `f'
22:14:30 <copumpkin> oh well
22:14:41 <jle`> oh
22:14:46 <copumpkin> oh duh
22:14:52 <jle`> :t \f (xs :: [a]) -> f <*> xs
22:14:53 <lambdabot> [a -> b] -> [a] -> [b]
22:15:09 <jle`> :t \f (xs :: Maybe a) -> f <*> xs
22:15:10 <lambdabot> Maybe (a -> b) -> Maybe a -> Maybe b
22:15:23 <jle`> :t \f (xs :: (a -> b)) -> f <*> xs
22:15:23 <lambdabot> (a -> b -> b1) -> (a -> b) -> a -> b1
22:17:08 <joneshf-laptop> hmm
22:17:32 <Javran> a question regarding basic category theory: "every directed graph can be made into a category" ... then what is the identity?
22:17:35 <jle`> any way i can see what dependency is causing everything to break?
22:17:43 <joneshf-laptop> that works, but it's not quite it
22:18:33 <jle`> i'm trying to install http://hackage.haskell.org/package/fastirc but one of the dependencies is calling me to back-install arrays
22:18:38 <jle`> downgrade
22:18:50 <jle`> can i find out which one is doing that?
22:21:45 <jle`> how i found it
22:21:45 <jle`> --constraint
22:21:45 <jle`> *oh i found it
22:21:45 <c_wraith> Javran: depends on how the morphisms are defined.  I'd probably define it as the no movement morphism.
22:21:46 <c_wraith> Javran: that is, staying at the same node without following an edge.
22:22:14 <Javran> c_wraith: its says "the arrows are paths in the graph"
22:22:17 <c_wraith> Javran: since morphism composition implies that the morphisms aren't *just* the edges.  Rather, they're paths of length n through the graph.
22:22:30 <c_wraith> Javran: So the identity morphism is the path of length 0
22:22:44 <Javran> c_wraith: I see
22:23:04 <jle`> why does cabal update still take so long :/
22:24:10 <startling> jle`: because it downloads the entire package index
22:24:50 <jle`> oh
22:24:53 <jle`> so it's all io-bound?
22:25:17 <startling> jle`: I think so.
22:25:40 <startling> jle`: there was a gross bug that was fixed a while ago but I think you were referring to that?
22:26:02 <joneshf-laptop> :t (<*>) `asAppliedTo` []
22:26:03 <lambdabot> [a -> b] -> [a] -> [b]
22:26:05 <joneshf-laptop> there it is
22:26:22 <joneshf-laptop> where the heck is that defined?
22:26:31 <joneshf-laptop> @src asAppliedTo
22:26:31 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:26:45 <joneshf-laptop> :i asAppliedTo
22:26:54 <joneshf-laptop> guess she doesn't have that
22:27:27 <startling> joneshf-laptop asAppliedTo? it's just const with a more restrictive type signature
22:27:47 <jle`> Not in scope: ‚ÄòunsafeForeignPtrToPtr‚Äô
22:27:51 <startling> joneshf-laptop: or are you talking about (<*>) for lists?
22:28:03 <jle`> could this be a 7.8 compatibility issue?
22:28:42 <joneshf-laptop> startling, is it in a  package somewhere
22:28:52 <startling> joneshf-laptop: not afaik
22:28:57 <joneshf-laptop> just in lambdabot?
22:29:02 <startling> yeah.
22:29:04 <jle`> :t asAppliedTo
22:29:05 <lambdabot> (a -> b) -> a -> a -> b
22:29:20 <startling> :t asTypeOf -- this is in Prelude
22:29:21 <lambdabot> a -> a -> a
22:29:57 <startling> :t let aat = const :: (a -> b) -> a -> a -> b in aat
22:29:58 <lambdabot> (a -> b) -> a -> a -> b
22:30:09 <startling> @free (a -> b) -> a -> a -> b
22:30:10 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
22:30:17 <startling> :<
22:30:21 <jle`> that's a cute trick
22:30:56 <startling> :t let ato = const :: a -> a -> a in ato -- this too
22:30:57 <lambdabot> a -> a -> a
22:31:19 <jle`> already saw ato but still neat
22:31:28 <shachaf> @free foo :: (a -> b) -> a -> a -> b
22:31:28 <lambdabot> g . h = k . f => g . foo h x = foo k (f x) . f
22:32:30 <startling> oh, I meant to @djinn
22:32:36 <startling> @djinn (a -> b) -> a -> a -> b
22:32:37 <lambdabot> f a b _ = a b
22:32:45 <startling> not quite.
22:34:01 <c_wraith> startling: aren't there only two (total) implementations of that type, and the one lambdabot picked is as good as the other?
22:34:02 <jle`> is that even the right type?
22:34:12 <jle`> :t \a b _ -> a b
22:34:13 <lambdabot> (t2 -> t1) -> t2 -> t -> t1
22:34:42 <startling> jle`: sure.
22:34:54 <startling> c_wraith: yeah, but it's not *exactly* the same. >.>
22:35:30 <Maxdamantus> :t let (int, double, (~>)) = undefined :: (Int, Double, a -> b -> a -> b) in map (second fromIntegral) `asTypeOf` ([int] ~> [double])
22:35:31 <lambdabot>     Couldn't match type `(d0, b0)' with `Double'
22:35:31 <lambdabot>     Expected type: Int -> Double
22:35:31 <lambdabot>       Actual type: (d0, a0) -> (d0, b0)
22:36:14 <Maxdamantus> :t let (int, double, (~>)) = undefined :: (Int, Double, a -> b -> a -> b) in map (second fromIntegral) `asTypeOf` ([(int, int)] ~> [(int, double)])
22:36:15 <lambdabot> [(Int, Int)] -> [(Int, Double)]
22:55:16 <please_apply_me> Hello all, would it be alright if I asked a question about Parsec?
22:57:01 <jle`> yes
23:00:25 <please_apply_me> I'm trying to parse an expression like "f a b c" where f, a, b, and c are expressions, i.e. function application. I'd like it to be left associative. Since I've used a lexer, I don't have the white space to separate the expressions. How would you guys recommend that I set up a parser for this kind of situation so that I don't run into infinite recursion?
23:04:09 <pavonia> please_apply_me: What library are you using for parsing?
23:04:23 <please_apply_me> pavonia: Parsec
23:05:35 <pavonia> Gah, there's a combinator ... I forgot the name
23:05:53 <c_wraith> chainl?
23:06:10 <pavonia> Yes, that's it!
23:06:20 <pavonia> I had scanl in mind
23:06:42 <please_apply_me> thanks guys, I'll check it out
23:25:08 <please_apply_me> So currently my parser for expressions is build up from the Parsec Token lexer. How should I do something like this: chainl1 expr (Token.whiteSpace >> return Appl)? Currently it loops endlessly
23:28:16 <kazagistar> please_apply_me: I am not sure I understand... could you lpaste your code?
23:31:36 <please_apply_me> (https://github.com/burz/chalice/blob/master/Parser.hs) It's on line 59
23:33:47 <pavonia> :t Text.Parsec.chainl
23:33:48 <lambdabot> Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m (a -> a -> a) -> a -> Text.Parsec.Prim.ParsecT s u m a
23:34:50 <pavonia> I think havind cappl again in the chain is wrong
23:34:52 <kazagistar> I am confused by your grammer, sorry
23:37:19 <please_apply_me> pavonia: you mean the constructor?
23:38:08 <metzger> hi!
23:39:08 <jle`> is there a way to use those modifyMVar etc. type families with MonadIO m instead of IO?
23:39:54 <jle`> instead of modifyMVar :: MVar a -> (a -> IO (a,b)) -> IO b
23:40:10 <jle`> modifyMVar :: MonadIO m => MVar a -> (a -> m (a,b)) -> m b
23:40:54 <metzger> is there a way to compose parsers in attoparsecs to re-parse a piece of data? when using attoparsec, I'll often do something like this code: do { x <- tabDelimitedField; y <- tabDelimitedField; z <- tabDelimitedField; let a = parseOnly field1 x; let b = parseOnly field2 y; let c = parseOnly field3 z; }, however I think it could be prettier.
23:41:51 <eatman> Hello
23:42:03 <sjy> hello
23:42:40 <ampharmex> What would the 3537254737455273993th number of this sequence be(in Haskell, how would you solve it)? https://oeis.org/search?q=6578&start=40
23:44:34 <Cale> ampharmex: Where'd you get that problem?
23:44:56 <jle`> i think i asked about this before probably a month or two back
23:45:00 <ampharmex> Cale, I made it up, by searching oeis for random sequences.
23:47:41 <kadoban> I'm using readFile to read a few files, and then outputting them as part of my program output, and it seems like they're getting cut off.  Is this a laziness problem somehow, and is there a general way to fix it?
23:48:46 <Cale> The elements of that sequence grow exponentially, so I'd expect the number you ask for to be very very large.
23:50:21 <ampharmex> Cale, Yes
23:50:39 <Cale> I estimate that it will require about 4.83 * 10^18 bytes to record.
23:50:44 <ampharmex> it looks like he generates A by starting with 1 + x, and then updating it according to the  formula A=1+x*A^3+x^5*A^13 +x*O(x^n), so that the first n coefficients are correct
23:51:28 <kazagistar> metzger: I am still pretty much a haskell noob, but are you looking for something like (Int -> m a -> (a -> m b) -> m [b]) ?
23:52:02 <ampharmex> Cale, 4.18935719 exabytes :L
23:52:49 <metzger> kazagistar: I am not - not sure how you got this idea?
23:53:13 <ampharmex> Cale, Ok lets make it the 3546th number
23:54:25 <Cale> ampharmex: That's much more reasonable :)
23:57:18 <kazagistar> metzger: my bad, I misread it... I thought you had an entirely different problem
