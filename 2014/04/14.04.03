00:01:19 <startling> ghost355: for what?
00:01:23 <solidus-1iver> evenin all
00:01:33 <solidus-1iver> how do i tell cabal to install builddepends for my test suites
00:01:44 <solidus-1iver> when i try to configure --enable-tests it complains there are unsatisfied depends
00:01:49 <solidus-1iver> but i dont want to have to install them manually
00:02:00 <solidus-1iver> is there a way to tell it to just go get all the unresolved depends for my tests?
00:02:02 <startling> solidus-1iver, cabal install --enable-tests --dependencies-only
00:02:06 <kadoban> Sigh...now some of the old packages I was using won't install.  :-/ :-/
00:02:32 <startling> ghost355, you should be able to use them in strings as-is, you probably need that extension to use them for identifiers
00:02:55 <solidus-1iver> startling dependencies-only is unrecognized
00:03:16 <phaer> Is there a way to load hidden modules in ghci for inspection?
00:03:41 <startling> solidus-1iver: I don't believe you.
00:03:55 <startling> solidus-1iver: (maybe you're using an old cabal-install?)
00:04:06 <solidus-1iver> startling: very possible
00:04:41 <solidus-1iver> startling: http://lpaste.net/102176
00:05:04 <startling> solidus-1iver: what's cabal --version?
00:05:20 <startling> phaer: there's a flag but I forget it
00:05:34 <solidus-1iver> startling: 1.16.0.2
00:06:50 <phaer> solidus-1iver: 1.18.1.3 is the most recent one.
00:06:56 <startling> phaer: there's also an extension that lets you specify versions -- :set -XPackageImports, import My.Module from "library-1.2"
00:07:01 <startling> solidus-1iver: works for me on 1.18
00:07:44 <solidus-1iver> startling: got it, heh, they changed the flag from --dependencies-only to --only-dependencies
00:08:19 <startling> solidus-1iver: haha
00:09:02 <startling> phaer: (the flag is -package whatever-1.2
00:09:05 <startling> )
00:12:53 <phaer> startling: Thanks, but i don't understand how i could pass a ghci flag to cabal repl
00:13:13 <startling> phaer: that's not what you asked. :/ :\
00:13:24 <solidus-1iver> i'm confused by their test setup here https://github.com/ekmett/lens/blob/master/tests/properties.hs
00:13:32 <phaer> startling: Ah, yes. But a follow up question.
00:13:36 <solidus-1iver> where are they getting the main = $defaultMainGenerator from?
00:13:43 <solidus-1iver> I've never seen that
00:13:44 <startling> phaer: I don't think you can.
00:14:15 <startling> solidus-1iver, I think that's Template Haskell
00:14:33 <phaer> startling: You already answered the first one, at least i think so. The thing is also that i can import some parts of the package Hakyll, but not Hakyll.Core.Store
00:31:07 <ast_> anyone using protobuf with haskell? Trying to compile .proto files and get parsing error in msg extentions. Native compiler works OK.
00:38:28 <pavonia> ast_: Extension fields are not supported yet
00:40:05 <ast_> pavonia: i see, thanks
00:40:20 <ast_> back to python then
00:42:16 <pavonia> ast_: There's also a protocol-buffers package that seems to support these
00:43:11 <ast_> pavonia: looks like it is from the same author
00:43:32 <augur> if i have   f x = x + bigComplicatedExpressionWithoutX   and i run   map f xs   with the big complicated expression be optimized out so it only runs once, or will it be run each time f is applied?
00:43:48 <ast_> pavonia: do you mean this one http://hackage.haskell.org/package/protocol-buffers-2.0.14
00:43:51 <ast_> ?
00:44:00 <pavonia> yeah
00:44:16 <ast_> looks like it is the same thing
00:46:12 <pavonia> augur: I guess it will be evaluated over and over again
00:50:43 <makalu> if I :l in ghci, the functions that are not exported from that module will not be in scope but I would like to use them for testing. Is there any way to load everything from a file in ghci?
00:52:27 <makalu> oh, it seems a '*' in front of the file name helps but then tab-completion doesn't work
01:03:13 * hackagebot process-conduit 1.1.0.0 - Conduits for processes  http://hackage.haskell.org/package/process-conduit-1.1.0.0 (HideyukiTanaka)
01:03:13 * hackagebot mighttpd2 3.0.5 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.0.5 (KazuYamamoto)
01:19:16 <b0bbi10> why can't I pattern match a two-element list with [a, b] = a ? do I have to use the non-suger syntax?
01:20:06 <b0bbi10> LYAH says "But since [1,2,3] is just syntactic sugar for 1:2:3:[], you can also use the former pattern."
01:21:11 <b0bbi10> my bad, declared the wrong type...
01:29:33 <byorgey> makalu: tab-completion should still work, not sure why it wouldn't
01:30:29 <makalu> I can tab-complete the filename and then add * in front but if I start with * it doesn't work for some reason. No problem though, not a real issue for me.
01:37:14 <b0bbi10> how do I make a function with "optional" parameters? is the keyword partial function here?
01:38:13 <solidus-1iver> if you are making an executable with cabal, is there a way to chunk out portions of logic into modules to import? i'm having trouble defining modules in my cabal file that i can import in my main for the executable
01:38:18 <solidus-1iver> do i have to make a library def and an executable def?
01:40:14 <lieven_> b0bbi10: take an argument of Maybe a instead of an optional argument of type a
01:40:50 <b0bbi10> ok
01:42:30 <jle`> b0bbi10: partial function refers to functions that are not defined on all possible inputs
01:42:47 <jle`> for example, digitToInt, which turns a digit char like '9' into an integer
01:53:13 * hackagebot hoogle 4.2.31 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.31 (NeilMitchell)
01:53:15 * hackagebot ixset-typed 0.1.4 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-typed-0.1.4 (AndresLoeh)
01:56:32 <pavonia> solidus-1iver: Yes, make the modules a library and the binary an additional executable section
01:58:14 * hackagebot digestive-functors-blaze 0.6.0.4 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.6.0.4 (JasperVanDerJeugt)
01:58:28 <b0bbi10> since recursion is such an important concept in Haskell, I am wondering how efficient that is? I mean, calling a function again has to save the stack and provide memory for the variables/ parameters, right?
01:59:59 <solidus-1iver> pavonia aye, i've been diving into cabal packaging, it looks like i can get away with just making a binary with toher-modules and adding it to my hs-source-dir definition for tests untill things get more seriouse. Its taking me a while to understand the organization / process for using cabal
02:00:04 <solidus-1iver> pretty cool so far
02:06:38 <bartavelle> b0bbi10, the compiler should be smart enough to convert many uses of recursion into a loop. you can lookup "tail call optimization"
02:09:05 <b0bbi10> bartavelle: I see, thanks
02:13:02 <tdammers> also, lazy evaluation
02:18:21 <lieven_> also a lot of recursion can be written with higher order functions like fold, map etc
02:28:18 * hackagebot yesod-core 1.2.11 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.11 (MichaelSnoyman)
02:32:04 <solidus-1iver> thanks for the help with cabal! i'm sure i'll be back in the coming weeks, time for sleep here
02:47:49 <gr8> hi. I am not that much of a programmer yet; is Yi a real alternative to Emacs already? or is it still too buggy to be used as an everyday text editor?
02:49:44 <GWils> Hi #haskell. If it's not too much to ask, could somebody please explain the problems I'm having installing Data Parallel Haskell and its examples?
02:49:48 <GWils> http://lpaste.net/102181
02:51:32 <supki> GWils: where did you get your ghc?
02:51:32 <GWils> dph-lifted-vseg-0.7.0.1 has a package dependency called ghc. "ghc" isn't a package on Hackage...?
02:51:46 <supki> no, "ghc" package comes with GHC
02:51:52 <GWils> The Fedora repository - sorry; should have mentioned that.
02:52:22 <supki> oh, then you need to find fedora package that provides it
02:52:24 <pearson> why do I not need (x:xs) when implementing sum with  foldl and why the + in parenthesis?
02:54:17 <supki> GWils: from the look of https://apps.fedoraproject.org/packages/ghc-ghc it's either ghc-ghc or ghc-ghc-devel
02:54:26 <iota_> pearson: because foldl takes care of deconstructing the list
02:54:41 <GWils> Supki: Cheers, those are both currently installing.
02:55:13 <iota_> :t (+) -- pearson: the + operator used as a function
02:55:14 <lambdabot> Num a => a -> a -> a
02:55:24 <jle`> @src foldl
02:55:25 <lambdabot> foldl f z []     = z
02:55:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:55:46 <pearson> iota_: I see, that's very neat.
02:55:51 <GWils> Supki: Thanks, it's working now; how exciting.
02:56:12 <pdpi> @src foldl'
02:56:12 <lambdabot> foldl' f a []     = a
02:56:12 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:57:16 <pdpi> foldl' only ensures the accumulator is in WHNF right?
02:58:21 * hackagebot mime-mail 0.4.5.1 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.5.1 (MichaelSnoyman)
02:59:20 <alpounet> pdpi: right
03:00:06 <pdpi> alpounet: cool, thanks. Beginner here. Was looking at that @src foldl and that reminded me of the laziness issues with it
03:00:10 <alpounet> but this covers the basic case of sum and friends, where you usually just need whnf, as the accumulator is a Double/Int/...
03:00:21 <pdpi> yeah, exactly
03:00:24 <pdpi> cool.
03:01:44 <gr8> oh there is #yi. I'll ask there
03:01:51 <alpounet> i tried to cover these topics in <http://alpmestan.com/posts/2013-10-02-oh-my-laziness.html> -- don't know how useful it can be to you, just giving the url just in case
03:02:47 <pdpi> alpounet: looks like it ought to be pretty useful
03:02:49 <pdpi> saved for later!
03:10:10 <vozz_> If I'm getting a negative index error, how do I track down what line it's coming from
03:10:30 <vivaldi> Hello, why is :t foldl and :t foldr are different?
03:11:01 <ion> Because they do different folds.
03:11:30 <peteretep> vivaldi: If you look at the implementation of them
03:11:32 <vozz_> Because the function you fold with takes the arguments the other way round
03:11:42 <peteretep> vivaldi: And also consider the implications of it
03:11:49 <peteretep> vivaldi: That will probably tell you much better than we will
03:12:01 <vivaldi> ok thanks
03:18:57 <vivaldi> I think I understand the type of foldr but I can't understand foldl. I checked the implementation, I think it should be same as foldr.
03:19:01 <vivaldi> I mean
03:19:04 <vivaldi> :t foldl
03:19:06 <lambdabot> (a -> b -> a) -> a -> [b] -> a
03:19:30 <vivaldi> it should be (a -> b -> b) not (a-> b -> a)
03:19:43 <shiona> vivaldi: it takes the accumulator and list element in the different order in the function
03:21:05 <vivaldi> ok I guess I get it now, thanks.
03:27:10 <flebron> Is it reasonable to think Applicative is so called because (|f x1 x2 ... xn|) = pure f <*> x1 <*> x2 <*> ... <*> xn is evaluated in applicative order, as opposed to normal order? In the sense that to reduce that expression, one first runs the effects of every single xi, and only then can one apply the pure function f to the pure results of the xi. In normal order, whether or not to "evaluate" (in this case
03:27:12 <flebron> "run the effects of") an argument could depend on who f is (say, \xy.x never evaluates y in normal order).
03:31:16 <grohne> kosmikus: could you look into this lhs2tex spacing issue? http://tex.stackexchange.com/q/169054/47729
03:34:26 <augur> flebron: no
03:34:49 <augur> its called it because the word "applicative" means "function-y" in many contexts
03:35:00 <augur> and applicative functors have such function-y behavior
03:35:17 <flebron> But it'd seem that's a reasonable analogy
03:35:27 <augur> flebron: a reasonable, but false, analogy, perhaps
03:36:20 <augur> at any rate, (| f x1 x2 ... |) is not evaluated in applicative order in any sense, afaik
03:36:59 <flebron> Well, the effects of each of the arguments will be run before the whole thing is reduced to a value
03:37:35 <flebron> And the notation means that f there is pure, so it has no side effects itself
03:38:24 <augur> mm.. xn's effects can block evaluation of xn+k afaik
03:38:43 <augur> this of course is due solely do the fact that application is left-nested
03:39:52 <flebron> Oh, you mean "if one fails, then I don't look at the others", in the Maybe applicative for example
03:39:57 <augur> yes
03:40:07 <flebron> Still, I'd think that's just evaluating every effect, it's just it stops beforehand :p
03:40:38 <augur> flebron: but thats kind of importantly different from applicative order
03:40:39 <flebron> (As opposed to reducing the function first, which is normal order)
03:40:51 <augur> (| f Nothing (fix id) |) = Nothing
03:41:17 <augur> applicative order would have this spin forever
03:42:13 <augur> > pure (\x y -> y) <$> Nothing <*> (fix id)
03:42:14 <flebron> Well I consider it similar to (\xy.y)((\x.x x)(\x.x x))(\x.x)
03:42:15 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
03:42:15 <lambdabot>    arising from a use of `M70424079011111577053205.show_M70424079011111577053...
03:42:15 <lambdabot>  The type variable `t0' is ambiguous
03:42:15 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
03:42:15 <lambdabot>  Note: there are several potential instances:
03:42:18 <augur> :|
03:42:29 <flebron> The first one already dies before you can evaluate the second one, if in applicative order
03:42:52 <augur> flebron: sure. but my example still exists
03:43:08 <flebron> I think it's different interpretations of what "failure" means :)
03:43:15 <augur> its a proof by construction that Applicative functors do not behave the same as applicative order evaluation
03:43:19 <augur> and therefore they are simple different
03:44:00 <augur> are they similar in some regards? sure
03:44:03 <augur> but they're not the same
03:44:12 <flebron> Well if you're interpreting the Maybe applicative as supporting failure, the only failure in the lambda calculus would be failure to reduce to a value, which is the UU case above
03:44:36 <flebron> I'm def not saying they're the same, just that it's a useful way to think about them initially :)
03:44:55 <augur> the pure LC can code maybe and applicative functors without any difficulty
03:45:02 <flebron> They behave similar to an implementation of applicative order that scans left-to-right
03:45:52 <augur> probably in a language without non-termination they would be the same
03:46:05 <flebron> But thanks for the examples that show they're not exactly the same :)
03:46:14 <augur> the only way to make my example work is to use haskell's own non-termination to define the naughty proof term
03:46:43 <augur> if you were implementing an object language with applicative order, they might be equivalent
03:47:11 <augur> at least, a terminating object language
03:47:25 <augur> since then `fix id` would not be the value of any program
03:53:27 * hackagebot aeson-utils 0.2.1 - Utilities for working with Aeson.  http://hackage.haskell.org/package/aeson-utils-0.2.1 (ErikHesselink)
03:56:37 <Robin_NL> hi, guys. I have list of my own datatypes and i want to filter on a certain datatype is there any way to use filter to do so?
04:00:28 <haasn> Robin_NL: every element of a list has to have the same type
04:00:31 <haasn> am I misunderstanding you?
04:02:16 <Robin_NL> data Color = Red | Blue | Yellow deriving (Show)
04:02:16 <Robin_NL> data Geofig = Square Color Float | Rectangle Color Float Float | Triangle Color Float | Circle Color Float deriving (Show)
04:02:50 <haasn> Robin_NL: something like filter isSquare where isSquare (Square _ _) = True; isSquare _ = False -- ?
04:03:05 <Robin_NL> I want to make a list of geofig and filter only on square
04:03:23 <Robin_NL> maybe .. let me try
04:03:51 <haasn> (but there might be a better way than just using ‘filter’. What are you doing with the list after that?)
04:05:00 <pavonia> [ sq | sq@Square {} <- list ]
04:05:11 <Robin_NL> Just playing around and learning Haskell
04:08:06 <haasn> pavonia's is nice, too
04:11:29 <ast_> hmm, got hprotoc working with my proto files, anyone with experience in extensions?
04:15:13 <Robin_NL> @ haasn: Thnx, I have this now and it works
04:15:14 <Robin_NL> getSquares :: [Geofig] -> [Geofig]
04:15:14 <Robin_NL> getSquares x = filter (isSquare) x
04:15:14 <Robin_NL> isSquare :: Geofig -> Bool
04:15:14 <Robin_NL> isSquare (Square _ _) = True
04:15:14 <Robin_NL> isSquare _ = False
04:16:59 <haasn> I think I'd prefer [ s | s@Square{} <- x ] for a one-time usage
04:18:30 * hackagebot stm-conduit 2.4.0 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.4.0 (ClarkGaebel)
04:25:32 <Yuu_chan> Which requirements are for a type to be used in unboxed containers?
04:27:45 <byorgey> Robin_NL: yep, that looks good
04:28:01 <byorgey> Robin_NL: note that getSquares can also be written like this:   getSquares = filter isSquare
04:28:12 <byorgey> Robin_NL: in other words you don't need the x's or the parentheses
04:28:38 <haasn> and (Square _ _) can be rewritten as Square{}
04:29:09 <vozz_> If I have a tree of numbers, and I want to return the biggest number, how do I do this?
04:29:27 <alpounet> Yuu_chan: it must implement the Unbox class, for Vector. for UArray, you can see the list of unboxable types at http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-Unboxed.html -- and so on for the other implementations, often handled through a typeclass
04:30:06 <nicoo> Where can bugs in LYAH be reported ?
04:30:11 <vozz_> Can I fold a tree?
04:30:24 <byorgey> vozz_: sure
04:30:29 <nicoo> vozz_: Of course
04:30:42 <byorgey> vozz_: is this your own tree type?  Or are you using Data.Tree?
04:30:51 <vozz_> Data.Tree
04:31:14 <byorgey> vozz_: OK, in that case  Data.Tree  already has a Foldable instance
04:31:35 <byorgey> vozz_: so you can just   import qualified Data.Foldable as F  and then use   F.maximum  to find the biggest number in your tree
04:31:57 <Yuu_chan> alpounet: thank you! I particularly wanted to use sets from unboxed-containers package, but it lacks documentation.
04:32:32 <vozz_> thanks so much!
04:33:54 <byorgey> nicoo: you can email the author, bonus at learnyouahaskell dot com
04:34:10 <nicoo> byorgey: Great, thanks
04:35:26 <ast_> getExt :: Key c msg v -> msg -> Either String (c v)
04:35:32 <ast_> what is c and v here?
04:35:47 <ast_> Key :: (ExtKey c, ExtendMessage msg, GPB v) => FieldId -> FieldType -> Maybe v -> Key c msg v
04:35:59 <ast_> v is just any type?
04:36:05 <byorgey> ast_: they are type variables.  What is the context?
04:36:19 <ast_> http://hackage.haskell.org/package/protocol-buffers-2.0.12/docs/Text-ProtocolBuffers-Extensions.html#t:Key
04:36:24 <b0bbi10> why can't I curry an infix function like this? let a = `elem` [1, 2, 3]
04:36:40 <ast_> i'm trying to use getExt and need to specify its return type
04:36:54 <kosmikus> grohne: done
04:37:26 <byorgey> ast_: you're trying to use it but you don't know what return type you want it to have?
04:37:37 <vozz_> How would I filter a tree? What typeclass is it that lets you filter?
04:37:44 <alpounet> Yuu_chan: yeah there you have to write a USet instance
04:37:51 <byorgey> ast_: also, I don't know why you would need to specify its return type, unless you are doing this at the ghci prompt
04:37:58 <alpounet> the source code for these instances makes everything clearer
04:38:05 <tomejaguar> Why is UNPACK not called UNBOX?
04:38:18 <byorgey> vozz_: there is no type class for filtering.  what would it mean to filter a tree?
04:38:42 <vozz_> Can I flatten it to a list and filter it?
04:38:46 <ast_> byorgey: without type I get:     No instance for (ExtKey c0) arising from a use of `getExt'
04:38:49 <ast_>     The type variable `c0' is ambiguous
04:38:51 <ast_>     Possible fix: add a type signature that fixes these type variable(s)
04:38:55 <byorgey> vozz_: sure
04:39:05 <byorgey> vozz_: to flatten you can use  F.toList
04:39:49 <vozz_> Thanks a lot
04:40:24 <byorgey> ast_: OK, so yes, you need to specify a type.  From the perspective of the language, c can be any type.  From the perspective of the protocol-buffers library, probably there are only certain types that make sense, but there I cannot help you.
04:41:12 <ast_> byorgey: thank you, I suppose it should be a member of ExtKey?
04:41:30 <predator117> ls
04:41:32 <Yuu_chan> b0bbi10: use the section syntax: let a = (`elem` [1, 2, 3])
04:42:00 <Yuu_chan> Infix operators are curried (both by the first and the second argument) this way, with parentheses.
04:42:21 <ast_> byorgey:     No instance for (ExtKey c0) arising from a use of `getExt'
04:42:21 <ast_>     The type variable `c0' is ambiguous
04:42:21 <ast_>     Possible fix: add a type signature that fixes these type variable(s)
04:42:40 <ast_> byorgey: sorry for multiple paste, i've figured it out
04:43:01 <b0bbi10> Yuu_chan: got it, thanks
04:43:44 <Yuu_chan> tomejaguar: good question :)
04:53:34 * hackagebot esqueleto 1.3.9 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.9 (FelipeLessa)
05:03:35 * hackagebot basic-prelude 0.3.8 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.8 (MichaelSnoyman)
05:08:35 * hackagebot yesod-auth-fb 1.6.2.1 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.6.2.1 (FelipeLessa)
05:12:50 <ast_> i have a function returning Maybe t, how do I return just t or make an error? Sorry for basic stuff.
05:13:36 * hackagebot classy-prelude 0.8.3 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.8.3 (MichaelSnoyman)
05:13:51 <ion> Either return “Just something” or “Nothing”.
05:13:53 <ion> @src Maybe
05:13:54 <lambdabot> data Maybe a = Nothing | Just a
05:14:21 <Yuu_chan> @src IO
05:14:21 <lambdabot> Source not found.
05:15:06 <quchen> Yuu_chan: https://github.com/quchen/articles/blob/master/fbut.md#where-is-io-defined
05:16:34 <Yuu_chan> quchen: okay, I suggested the Lambdabot could show some made-up definition as it does with []
05:17:01 <MP2E> huh thanks for that link, interesting topics covered for me
05:18:31 <ast_> ion: thanks, got it
05:18:53 <Yuu_chan> Argh, I use ByteString.Char8 all the time and now I'm restricted to!
05:19:30 <quchen> I think there's a verb missing at the end of your.
05:19:41 <MP2E> ByteString was particularly interesting for me as well :P
05:19:43 <quchen> Or a nound.
05:20:03 <MP2E> err ByteString.Char8*
05:21:15 <blue``> I'm going through the NICTA exercises but am hitting some symbol I'm not familiar with: ":."
05:21:36 <blue``> for example: data List t = Nil | t :. List t
05:21:50 <blue``> could someone help me understand this or point me in the right direction?
05:22:04 <dv-> that's the definition of :.
05:22:28 <b0bbi10> hi, LYAH (again) says "One big difference is that right folds work on infinite lists," how come right folds work on infinite lists if there is no 'starting' point?
05:22:39 <Yuu_chan> quchen: sorry, I still haven't mastered English ellipsis and hanging prepositions.
05:23:01 <quchen> b0bbi10: LYAH's section on foldr is awful. foldr does not start on the right side of the list.
05:23:19 <Yuu_chan> blue``: binary data constructors can be operators too, but in this case they should start with a colon.
05:23:35 <b0bbi10> quchen: ok, good to know!
05:23:36 <b0bbi10> thanks
05:24:02 <quchen> b0bbi10: foldr, like foldl, consumes a list from left to right. What the author tries to say there is that foldr can be lazy, but foldl always has to traverse the entire list to produce a result.
05:24:17 <quchen> foldr on the other hand can short-circuit.
05:24:23 <Yuu_chan> blue``: another example is the standard Complex datatype
05:24:26 <Yuu_chan> @src Complex
05:24:26 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
05:24:50 <blue``> thanks, let me check it out
05:25:10 <Yuu_chan> It's the same as "Complex !a !a", but more readable
05:32:52 <anon_555> i am learning haskell
05:33:07 <anon_555> and i am defining the function in ghci>
05:33:19 <anon_555> i get error while defining function type
05:33:38 <anon_555> factor :: Integer -> Integer
05:34:26 <Yuu_chan> anon_555: better to define multiline functions in a separate source file, and then load it into ghci
05:34:55 <Yuu_chan> anon_555: another way is to define both type and body in the same line:
05:34:59 <anon_555> Yuu_chan i am begineer
05:35:06 <anon_555> <Yuu_chan> i am begineer
05:35:19 <Yuu_chan> > let factor :: Integer -> Integer; factor x = product [1 .. x]
05:35:20 <lambdabot>  not an expression: `let factor :: Integer -> Integer; factor x = product [1 ...
05:35:23 <anon_555> i am just learning in ghci command line
05:35:41 <anon_555> ok i will try that thanks
05:35:48 <chrra> A third way is to start the multiline expression with :{ and end with :}
05:36:26 <Yuu_chan> A fourth one is to leave the type for the smart inferring mechanism :)
05:37:21 <merijn> Yuu_chan: And then get screwed by the DMR
05:37:24 <anon_555> yeaah the fourth one is good but learning would be fun if defined the ttype :)
05:38:35 <Yuu_chan> merijn: I often got confused by the DMR and defaulting while showing some code examples to my students
05:39:46 <Yuu_chan> merijn: «This one works, and this one wouldn't work because it won't be able to infer types... heck, a number again»
05:40:50 <anon_555> guys
05:40:57 <anon_555> sayMe 1 = "One"
05:41:03 <anon_555> sayMe 2 = "Two"
05:41:12 <vozz_> If I have a Data.Tree of Ints, and I want to add some children to all the zeros, how do I do that? fmap doesn't do the job as I can't return the new children nodes, only modify the value of the node
05:41:13 <anon_555> sayMe x = "Not in range"
05:41:25 <anon_555> giving me only the last one when provided 2
05:41:28 <anon_555> in ghci
05:41:40 <bartavelle> anon_555, did you define all 3 cases in that order ?
05:41:47 <anon_555> yes in ghci
05:41:53 <anon_555> interpreter
05:41:55 <iota_> anon_555: by default in ghci, definitions are one-liners, so the last one overrides the others
05:42:09 <anon_555> yeah that is the problem may be
05:42:27 <anon_555> @iota_
05:42:28 <lambdabot> Unknown command, try @list
05:43:54 <Yuu_chan> anon_555: that's why I recommended to write multiline functions in a file ;)
05:44:39 <anon_555> Yuu_chan ok
05:44:46 <anon_555> Yuu_chan: ok
05:45:28 <anon_555> what is the procedure of writing in the file
05:45:29 <anon_555> please
05:45:55 <Yuu_chan> anon_555: just write your file in any text editor, save it into a .hs file and loat it with a ghci
05:46:10 <iota_> the command in ghci is :load yourfile.hs
05:46:11 <anon_555> sudeep hi
05:46:33 <b0bbi10> how is '($ 3) (4+)' == 4 + 3 == (+) 4 3? the $ function changes the parameter?
05:46:38 <Yuu_chan> If you installed Haskell platform, it probably associated .hs files to autoload them into the interpreter
05:46:56 <b0bbi10> 'swaps' may be more appropriate
05:47:14 <iota_> b0bbi10: ($) is the function application operator
05:47:17 <iota_> :t ($)
05:47:18 <lambdabot> (a -> b) -> a -> b
05:47:45 <Yuu_chan> b0bbi10: ($ 3) = "apply a function to the 3", (4 +) = "add 4 to a number", ($ 3) (4 +) = "apply (adding of 4) to 3"
05:47:49 <iota_> and ($ 3) is a shorthand for \x -> x $ 3
05:47:53 <b0bbi10> iota_: I don't see how that applies to '($3) (4+)'
05:48:02 <b0bbi10> ah ok
05:48:29 <iota_> just like (4+) is \x -> 4 + x
05:48:51 <Yuu_chan> ($ 3) (4 +) also identical to (4 +) $ 3
05:48:56 <b0bbi10> Yuu_chan, iota_: thanks
05:49:06 <b0bbi10> so does $ takes two parameters?
05:49:10 <Yuu_chan> Yes.
05:49:41 <sudeep_> anon_555 hi
05:49:55 <b0bbi10> ok, got it, thank you guys
05:50:01 <sudeep_> anon_555: hi
05:50:11 <Yuu_chan> b0bbi10: it's also often used in a pipe-style calculations
05:50:22 <SwashBuckla> can anyone help me with this cabal install error? I am on Ubuntu Precise 12.04.3 LTS with haskell-platform, and I get the error `ExitFailure 247: cabal-install-1.18.0.3 depends on Cabal-1.18.1.3 which failed to install' when I run cabal install cabal-install
05:50:34 <Yuu_chan> > abs $ (+ 10) $ negate $ (2 ^) $ 5
05:50:35 <lambdabot>  22
05:53:13 <SwashBuckla> It's SIGKILL, meaning Ubuntu killed the cabal install process due to running out of RAM. Is there anything I can do to get cabal install to run through to completion?
06:06:26 <SwashBuckla> http://lpaste.net/100127
06:12:26 <New2Haskell> Hello guys, im practising with data types atm. I have a color Red,Blue,Yellow and a Shape Square retangle Circle triangle. The shapes also save their dimensions saved. I have made a function that extracts a certain shape from a list of figures, i solved it using filter and isSquare, IsTriangle etc. However im trying to extract the figures given a certain color but I cant use the same solution
06:12:26 <New2Haskell> because the shapes have a different set of attributes. The rectangle has Rectangle float float color and the circle has Circle radius color so I cant use a general isRed, isBlue isYellow function. Does anybody have a clue how I can fix this
06:13:44 <Yuu_chan> New2Haskell: data Shape = Rectangle {width, height :: Float, color :: Color} | Circle {radius :: Float, color :: Color}
06:14:26 <Yuu_chan> Then filter (\figure -> color figure == Red) [Rectangle 1 1 Red, Circle 2 Yellow, Circle 3 Red], etc
06:15:11 <Yuu_chan> But if some shapes can be colorless, it will b0rk.
06:15:15 <New2Haskell> so basicly you give names to your fields?
06:15:22 <New2Haskell> is what the :: does in the shape
06:15:55 <New2Haskell> Because I dont have that atm I just did it with isSquare (Square _ _ _) = True
06:16:04 <New2Haskell> and isSquare _ = False
06:16:21 <bennofs> New2Haskell: another solution: data Shape = Rectangle Float Float | Circle Float; data Figure = Figure Color Shape
06:16:29 <Yuu_chan> :: means "has type", as with the rest of language.
06:17:19 <zq> is there a generalized method to determine whether a given function is strict?
06:17:21 <New2Haskell> data Geofig = Vierkant Float Kleur | Rechthoek Float Float Kleur | Driehoek Float Kleur | Cirkel Float Kleur deriving (Show)
06:17:25 <Yuu_chan> But yes, it's so called record syntax which gives names to the data fields.
06:17:25 <New2Haskell> thats how I have it now
06:18:07 <New2Haskell> ill try to look into the type
06:18:12 <New2Haskell> type classification
06:18:35 <Yuu_chan> names are essentially functions which can get a corresponding field from some value, and can be used in special syntax of creating and updating of records.
06:19:10 <bennofs> zq: just pass it bottom and check if it returns something different from bottom?
06:19:21 <Yuu_chan> > data Foo {bar :: Int}
06:19:22 <lambdabot>  <hint>:1:1: parse error on input `data'
06:19:49 <ion> bennofs: Yeah, just solve the halting problem first.
06:19:53 <bennofs> That "check if it returns something different from bottom" is not really possible though
06:19:58 <Yuu_chan> Aww. Well, after that bar :: ("will have type") Foo -> Int
06:20:17 <zq> bennofs: you mean undefined?
06:20:22 <bennofs> But you can pass it something that throws an exception and then `seq` the result of the function, and check if the exception gets thrown
06:20:31 <zq> hm
06:20:49 <zq> undefined && False
06:20:51 <zq> ? undefined && False
06:20:54 <zq> > undefined && False
06:20:55 <lambdabot>  *Exception: Prelude.undefined
06:20:59 <zq> > False && undefined
06:21:01 <lambdabot>  False
06:21:04 <ion> > fix id && False
06:21:08 <lambdabot>  mueval-core: Time limit exceeded
06:21:09 <zq> (&&) is lazy
06:22:14 <zq> i guess @src is the most reliable way, but i was hoping for a shortcut
06:23:46 * hackagebot dns 1.2.1 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.2.1 (KazuYamamoto)
06:23:49 * hackagebot yesod-platform 1.2.9.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.9.1 (MichaelSnoyman)
06:23:52 <SwashBuckla> can anyone help me with this cabal install error? I am on Ubuntu Precise 12.04.3 LTS with haskell-platform, and I get the error `ExitFailure 247: cabal-install-1.18.0.3 depends on Cabal-1.18.1.3 which failed to install' when I run cabal install cabal-install http://lpaste.net/100127
06:24:56 <SwashBuckla> What is the difference between Happstack, Yesod and Snap?
06:25:28 <SwashBuckla> do they achieve the same main-objective of being web frameworks (like Yesod)?
06:25:38 <SwashBuckla> or are the others trying to achieve something else?
06:27:02 <srhb> SwashBuckla: They are all web frameworks in some sense, but Snap and Happstack are much more lightweight than Yesod, and my experience is that they "try to do less things for you"
06:27:11 <srhb> SwashBuckla: Happstack even less than Snap, in my experience.
06:27:34 <tdammers> happstack is more like a loose collection of building blocks for a web app
06:28:26 <peteretep> happstack seemed a solid base for an API
06:28:47 * hackagebot pool-conduit 0.1.2.3 - Resource pool allocations via ResourceT. (deprecated)  http://hackage.haskell.org/package/pool-conduit-0.1.2.3 (MichaelSnoyman)
06:28:49 * hackagebot json2yaml 0.3.2.3 - Utility to convert a file from JSON to YAML format. (deprecated)  http://hackage.haskell.org/package/json2yaml-0.3.2.3 (MichaelSnoyman)
06:30:16 <quchen> zq: @src searches a text file, it doesn't necessarily have anything to do with Haskell. Lambdabot @src database: https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
06:31:30 <mr-> SwashBuckla: that error is weir. Is it running out of memory while compiling?
06:31:36 <SwashBuckla> mr-: yes
06:31:47 <SwashBuckla> It's SIGKILL, meaning Ubuntu killed the cabal install process due to running out of RAM. Is there anything I can do to get cabal install to run through to completion?
06:32:11 <quchen> How much RAM do you have?
06:32:13 <bennofs> SwashBuckla: how much RAM do you have?
06:32:17 <SwashBuckla> :P
06:32:28 <SwashBuckla> Urm, lemme check (it's a cheap VPS, so not much)
06:32:58 <mr-> I don't know if there's a way to make ghc use less memory
06:33:11 <SwashBuckla> 512MB
06:33:35 <tdammers> why do you compile on a vps?
06:33:47 <SwashBuckla> tdammers: is there another way?
06:33:51 <tdammers> of course there is
06:33:59 <tdammers> compile on your own machine, copy the binary to the vps
06:34:06 <SwashBuckla> I do have the same arch
06:34:15 <tdammers> eve neasier
06:34:17 <SwashBuckla> tdammers: how do I achieve that then
06:34:57 <tdammers> well
06:35:00 <SwashBuckla> like, I'll need ghc, ghci, anything else?
06:35:05 <tdammers> that's about it
06:35:10 <tdammers> build locally
06:35:14 <quchen> GHCi is part of GHC.
06:35:18 <tdammers> then take the binary, upload it to the vps server
06:35:19 <vermeille> How can it be a problem? The OS should just use more swap
06:35:32 <bennofs> vermeille: that gets SLOOOOWWWWWWW....
06:35:40 <tdammers> all you need to install on the vps then is libgmp (for Integer)
06:35:52 <tdammers> and any C libraries that any haskell packages may depend on
06:37:07 <merijn> I don't suppose cabal has a way of checking/enforcing dependencies on non-haskell things?
06:37:21 <bennofs> merijn: it has pkg-config-depends
06:37:39 <bennofs> merijn: and extra-libraries
06:38:09 <merijn> bennofs: extra-libraries just tells it to link a C library, no?
06:38:14 <vermeille> bennofs: yes, but that shouldn't make the compilation crash
06:38:15 <bennofs> I think, yes
06:38:18 <merijn> Basically, I have the following issue
06:38:26 <bartavelle> merijn, it also checks it exists at the configure step
06:38:40 <merijn> I have three versions of a package, each depending on a different C library version
06:38:57 <merijn> Now, suppose a package Foo can build using any of my three versions
06:39:13 <merijn> How do I ensure that cabal selects a version that can actually build given the available C library version
06:39:24 <bennofs> i wonder if automatic flag selection works for that
06:39:33 <bartavelle> merijn, https://github.com/bartavelle/hruby/blob/master/Setup.hs
06:39:48 <bartavelle> this is pretty convoluted, but you'll have to write a specific Setup.hs
06:40:10 <merijn> bartavelle: Right, but then everyone package depending on me would have to do that, no?
06:40:18 <bartavelle> nope
06:40:25 <merijn> bartavelle: No?
06:40:30 <bartavelle> I don't see why
06:40:31 <bennofs> merijn: so the API that you provide is different, depending on the C lib version?
06:40:36 <merijn> bennofs: Yes
06:40:38 <bartavelle> except if they also need to depend on the sub packages
06:40:43 <bartavelle> OH
06:40:50 <bartavelle> oh this sucks then :)
06:40:52 <merijn> bartavelle: Basically
06:41:11 <merijn> I'm working on hopencl, so I expose have OpenCL 1.0, 1.1 and 1.2 version
06:41:19 <bennofs> I don't think that the dependency checker takes native dependencies into account
06:41:43 <merijn> Which, obviously, need to have a C OpenCL version greater than my bindings
06:41:56 <merijn> i.e. OpenCL 1.2 would work with my 1.1 bindings
06:42:57 <merijn> I'm just unsure how I can let people that only need the common core depend on any of the three packages (so that they're not tied to any specific OpenCL version)
06:43:27 <bennofs> merijn: doesn't your hopencl 1.0 package work with any of OpenCL 1.0, 1.1 and 1.2?
06:43:45 <merijn> bennofs: Hopefully it will
06:44:05 <bennofs> merijn: then people that need a common core can just depend on hopencl-1.0, no?
06:44:10 <merijn> I'm not sure if I can get that to work, I adopted the package from someone else and maybe it turns out that's unfeasible
06:44:51 <merijn> bennofs: What if you *can* work with 1.0, but have a more efficient implementation for 1.2?
06:45:11 <merijn> Anyway, maybe I should just give up and force people to depend explicitly on a specific OpenCL version
06:46:02 <bennofs> merijn: if you can work with opencl 1.0, but have a more efficient implementation with 1.2, then you need to check for the opencl version anyhow (as user), no? Or do you mean that an user could then use the cabal version macros?
06:46:19 <bartavelle> merijn, I think that's a sensible idea
06:46:29 <bartavelle> as the exposed api is distinct
06:46:46 <merijn> bennofs: I was thinking of version macro's, yeah
06:46:59 <merijn> They're not so much distinct as I think 1.1 and 1.2 are supersets of 1.0
06:47:53 <bartavelle> 1.2 specs was released in 2011
06:47:59 <bartavelle> just support 1.2 and avoid success
06:48:31 <SwashBuckla> I need someone to just host a well-maintained ghc and cabal environment
06:48:41 <SwashBuckla> I have run into dependency hell many times :/
06:48:52 <bennofs> SwashBuckla: there is stackage
06:49:01 <SwashBuckla> I know fp-complete do something like this
06:49:03 <SwashBuckla> bennofs: oh ok
06:49:06 <merijn> bartavelle: I'm not doing this to be nice, I have several machines stuck on older opencl versions
06:49:28 <bartavelle> oh :/ I expected this was the kind of things when only the latest drivers / library worked in any way
06:49:32 <merijn> Well, for some value of "I" and "have"
06:49:51 <bennofs> Is opencl version only restrained by software, or does it also depend on the hardware?
06:50:08 <merijn> bartavelle: No, even the compute clusters with newer versions installed let you run using the old versions
06:50:09 <bartavelle> contrary to ruby versions which all equaly suck, and thus are all available to all users
06:50:21 <merijn> bennofs: "mu"
06:50:29 <merijn> bennofs: It depends on your vendor
06:50:43 <merijn> They could provide software workarounds for missing features, conceptually
06:50:52 <merijn> bennofs: Also, OpenCL is not just for GPU but also CPU
06:54:06 <bartavelle> merijn, I wouldn't be socked to have to explicitely decide which version of opencl I'd want to use. But I don't write software that needs to run on heterogenous compute clusters, so ...
06:54:30 <bartavelle> (well in that case I'll just choose 1.0 probably)
06:57:26 <pyon> How do I "statefully" (take|drop)While(L|R) from a Data.Sequence.Seq? I want something with type "(s -> a -> Maybe s) -> s -> Seq a -> Seq a".
06:58:51 * hackagebot scotty-hastache 0.2.1 - Easy Mustache templating support for Scotty  http://hackage.haskell.org/package/scotty-hastache-0.2.1 (DaniilFrumin)
07:03:15 <srhb> pyon: If you already have a State, check Control.Monad.Loops?
07:04:42 <jophish> Yo yo yo
07:05:05 <jophish> I'd like to implement something similar as specified here: http://lesswrong.com/lw/hmx/prisoners_dilemma_with_visible_source_code/
07:05:22 <jophish> a prisoner's dilemma, where each prisoner has access to the other prisoner's program
07:05:51 <jophish> data Decision = Cooperate | Defect
07:06:05 <jophish> type Prisoner = Prisoner -> Decision
07:06:16 <jophish> but obviously that type doesn't work
07:07:05 <pyon> srhb: Presumably, what I would run in a loop is a function that extracts a single element from the Seq, right?
07:08:28 <quchen> You may also want to have a look at the Traversable/Foldable instances of Seq, pyon
07:11:25 <c_wraith|N10> jophish: do programs need white-box or black-box access to the other programs?
07:13:33 <c_wraith|N10> jophish: and are programs allowed to keep internal state?
07:13:58 <yitz> quchen: that will work for the L versions. but anyway, Seq is a red herring here. You start by changing the Seq to a list from the left or right, and solve that problem.
07:17:25 <c_wraith|N10> jophish: is this an iterated prisoner's dilemma where there's a sequence of interactions? There are a ton of questions that are open but affect the representation choices
07:18:11 <pyon> quchen: I do not want to traverse the whole sequence - I just want to take or drop the first elements, using a function that takes a state parameter, and may produce a next state (if we want to take/drop the current element) or not (if we want to stop taking/dropping at the current element).
07:18:43 <quchen> pyon: So fold?
07:18:51 <yitz> pyon: the function argument is equivalent to a -> State s Bool, where the Bool tells whether the state changed.
07:18:53 * hackagebot influxdb 0.0.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.0.0 (MitsutoshiAoe)
07:18:58 <tdammers> c_wraith|N10: white-box
07:20:08 <tdammers> and it's not iterated. your code plays every opponent exactly once
07:20:25 <tdammers> but because it has access to the source code, and it's scheme, you can execute the opponent code with any input you like
07:20:55 <c_wraith|N10> tdammers: that's what the linked version does, but that doesn't mean something "like" it has to work that way.
07:21:05 <tdammers> ah, yeah... sure
07:21:08 <yitz> pyon: the solution (for regular lists) is then takeWhileS f s xs = map snd . takeWhile fst $ zip (evalState (mapM f xs) s) xs
07:21:37 <yitz> pyon: this assumes the *lazy* state monad
07:24:14 <yitz> @type \ f s xs -> map snd . takeWhile fst $ zip (evalState (mapM f xs) s) xs -- pyon
07:24:15 <lambdabot> (b -> StateT s Identity Bool) -> s -> [b] -> [b]
07:30:51 <yitz> @type \ f s xs -> let f' x = gets (f x) >>= maybe (pure False) ((pure True <*) . put) in map snd . takeWhile fst $ zip (evalState (mapM f' xs) s) xs -- pyon
07:30:52 <lambdabot> (b -> s -> Maybe s) -> s -> [b] -> [b]
07:31:09 <pyon> yitz: Okay, so you are zipping the original sequence with another sequence of functions, so that you can use takeWhile on the functions component, but then you return the component that was drawn from the original sequence, right?
07:31:36 <pyon> Errr... my phrasing was not really fortunate.
07:32:00 <yitz> pyon: i'm zipping it with a list of booleans that say whether the state transition took place at each position of the list.
07:33:06 <yitz> pyon: then just taking the initial part of that list where the boolean is True.
07:33:11 <pyon> Oh, right, "mapM f xs" produces a list of booleans in a State context, and evalState gets rid of the State context.
07:33:16 <pyon> Right?
07:33:17 <yitz> right
07:33:34 <flebron> What was the definition of Applicative that goes something like "natural transformation that respects exponentiation"?
07:33:52 <pyon> Yeah, now the thing is making something like mapM, but which works on Seq. :-|
07:34:00 <pyon> Rather than lists.
07:35:40 <pyon> Oh, that is why Data.Traversable was mentioned!
07:36:18 <quchen> :-)
07:36:30 * pyon thinks veeery slowly.
07:36:43 <pyon> yitz: quchen: Thanks!
07:36:46 <Hafydd> pyon, is your name one or two syllables?
07:36:53 <petrie> I am not understanding completely x:xs that x is binded to the rest of the list xs so if there is only one element xs is empty?
07:37:09 <quchen> petrie: Yes, a one-element list looks like (x:[])
07:37:31 <merijn> > 1:[]
07:37:32 <lambdabot>  [1]
07:37:38 <merijn> > 1:(2:[])
07:37:39 <lambdabot>  [1,2]
07:37:40 <pyon> Hafydd: dunno, most likely one syllable, who knows how many morae
07:37:57 <petrie> Hmm
07:38:10 <jophish> c_wraith|N10: Sorry, was away for a while. In the link they had white box access, but I'd like to see how it could be done with black boxes.
07:38:46 <jophish> Quite a lot of the fun bots did rely on IO-like functionality
07:39:11 <quchen> TIL: foldrM is a foldl, foldlM is a foldr
07:39:16 <quchen> (In Foldable)
07:39:25 <jophish> c_wraith|N10: It's not quite an iterated prisoner's dilemma. More similar to a 'fixed point' prisoner's dilemma
07:39:45 <jophish> Some state will need to be kept to prevent things from diverging
07:40:18 * pyon thinks he would have been a lot less confused if there were no overspecific mapM in the Prelude.
07:40:37 <jophish> tdammers: How would a White-Box style system work in Haskell?
07:41:44 <quchen> pyon: Same thing for Prelude.sequence while we're at it.
07:41:46 <Hafydd> pyon: does it sound like this? https://www.youtube.com/watch?v=Mmu465hTNMc
07:42:05 <c_wraith|N10> jophish: the simplest case is something like newtype Prisoner = Prisoner (Prisoner -> Decision)
07:42:22 <c_wraith|N10> jophish: but.. that has severe issues.
07:42:37 <yitz> c_wraith|N10: i was going to say ... :)
07:42:48 <pyon> quchen: Yes!
07:43:16 <tdammers> jophish: tricky
07:43:18 <c_wraith|N10> jophish: in particular, there are only two implementations of that which are guaranteed to not diverge
07:43:42 <tdammers> jophish: well, obviously the source code could be provided, but that would require parsing and compiling
07:43:48 <tdammers> scheme is kind of neat that way
07:43:51 <pyon> Hafydd: I took it from here - https://www.youtube.com/watch?v=DvzGIYOpsmU (and it'd probably be a good idea to take this to PM)
07:44:05 <jophish> Prisoner -> IO Decision -- Perhaps
07:44:11 <jophish> not without it's problems either
07:44:21 <Hafydd> pyon: okay, I see. I'm finished.
07:44:34 <c_wraith|N10> That only introduces more problems. :)
07:44:49 <jophish> tdammers: looking at the solutions for the Scheme version. Most of the looking at the source code was grepping for the string "Defect"
07:45:14 <jophish> But then people started to defeat that by not mentioning the string directle
07:45:15 <jophish> y
07:45:54 <tdammers> I wonder whether the best strategy might actually be to wait for 9.99999 seconds and then return a random result
07:46:28 <tdammers> such that anyone who samples you (or more than once, at least) would time out
07:46:36 <tdammers> and rest is statistics
07:47:06 <jophish> tdammers: The winning bot cooperated 20% of the time randomly
07:47:16 <tdammers> ah, I see
07:47:30 <jophish> A little disappointing
07:47:41 <tdammers> I thought 50% were the magic number for human opponents, but 20% makes sense
07:47:50 <vektor> does [[Tile]] make sense, guys? for, let's say a Game Of Life-like scenario.
07:47:54 <Yuu_chan> I tried to read the article about codata and comonads and don't understand how comonadic IO doesn't break the referential transparency...
07:48:03 <vektor> as a container for the map
07:48:09 <tdammers> vektor: sort of, but there are better containers IIRC
07:48:10 <c_wraith|N10> I think the percentage changes with the reward scheme
07:48:44 <vektor> I figured. Using a list random-access-y constant-length stuff seems like a bit of overhead
07:48:46 <tdammers> c_wraith|N10: yes, but I think this is the "classic" scheme
07:49:03 <tdammers> vektor: more like a big-O problem
07:49:14 <tdammers> vektor: random access on a linked list is O(n)
07:49:18 <vektor> yeah
07:49:22 <edwardk> Yuu_chan: comonadic io doesn't work in any category even remotely like set/hask. the kieburtz article just doesn't make sense in an implementable language.
07:49:23 <Yuu_chan> For example, consider coPutChar :: Char -> OI Handle -> (). This looks like a constant function and can be optimized out with its value, can't it?
07:49:26 <edwardk> Yuu_chan: so your inability to understand it doesn't reflect poorly on you ;)
07:49:31 <flebron> What's the monoidal structure of Hask? (And how does an Applicative preserve it?)
07:50:01 <edwardk> Yuu_chan: this is one of the many problems with OI.
07:50:10 <Yuu_chan> edwardk: oh, I see
07:50:13 <tdammers> vektor: haven't tried it myself, but this looks like it could work:
07:50:15 <tdammers> http://hackage.haskell.org/package/grid-6.1
07:50:25 <Yuu_chan> But it looked so intriguing...
07:50:59 <edwardk> Yuu_chan: yes. now. nanevski has a bunch of nice things for talking about comonadic handeable effects that is viable
07:51:03 <c_wraith|N10> jophish: I think this problem is a lot more interesting white-box. And while you could write that up in haskell, it'd necessarily involve an interpreter, making haskell a kind of clumsy language in relation to something like scheme.
07:51:09 <edwardk> but 'co-effects' and effects are different for very things
07:51:11 <vektor> are you guys aware of any array-style containers?
07:51:49 <tdammers> vektor: also, http://hackage.haskell.org/package/vector
07:51:56 <edwardk> given how limited Set is for comonoids it isn't surprising that comonads are less powerful here. move to a space like Vect where you can have an interesting comonoid and comonads abound
07:52:23 <vektor> my favourite type of container =)
07:52:26 <tdammers> vektor: http://hackage.haskell.org/package/array
07:52:30 <jophish> c_wraith|N10: I'm inclined to agree with you there
07:52:55 <flebron> And in an Applicative, what is the "strength" transformation \sigma_{A, B} : F(A) \oplus B \to F (A \oplus B)?
07:52:56 <edwardk> every comonad in hask gives rise not just to a monad but a monad _transformer_ so consider any monad you can't make a transformer and that kind of monad won't translate nicely to a comonad. (that is just for intuitive thinking, not rigor, but it holds up remarkably well)
07:53:07 * edwardk has to run
07:53:23 <edwardk> flebron: every Functor in Hask is strong like that
07:53:42 <flebron> With \oplus = (,)?
07:53:49 <edwardk> :t \ (as , b)  -> fmap (,b) as
07:53:50 <lambdabot> Functor f => (f a, t) -> f (a, t)
07:54:02 <flebron> Ah, nice :)
07:54:24 <edwardk> flebron: http://comonad.com/reader/2008/deriving-strength-from-laziness/
07:54:36 <flebron> Arbitrarily many thanks :)
07:54:36 <edwardk> there are a few articles i wrote on topics in that area before/after that one
07:54:42 <vektor> thanks, tdammers, I'll look into it
07:54:46 <edwardk> ok, really leaving now =)
07:56:59 <yitz> pyon: this can also be done as an unfold:
07:57:02 <yitz> @type \f s xs -> let g (y:ys, t) = (,) y <$> ((,) ys <$> f y t); g _ = Nothing in unfoldr g (xs, s)
07:57:03 <lambdabot> (a -> t -> Maybe t) -> t -> [a] -> [a]
08:02:15 <yitz> vektor: for a Game of Life kind of thing, you don't really need full random access; just local random access of a neighborhood. so lists can work out just fine for that.
08:03:33 <vektor> you think so? Would be hacky to make it work. Also, I think since I have some more complex features than GoL in mind, I'll go for random access?
08:05:26 <yitz> vektor: also, another neat trick is to build a rigid graph with "tying the knot", providing each node with links to its neighbors. you number the nodes with fixed ints and use an IntMap or other container to store the current value at each node.
08:05:52 <vektor> IntMap -> log(n)?
08:05:57 <yitz> vektor: i think building random access is hacky if you don't need it.
08:06:03 <yitz> vektor: right
08:06:12 <vektor> so basically, a fakie linked 2d list?
08:06:21 <vektor> reverse and crosswise linked as well that is
08:06:29 <yitz> vektor: not fake - real. but immutable.
08:06:54 <vektor> well, yeah... I mean, it's not really pointers, so to a c++/java guy it's no linked list
08:07:24 <vektor> yeah, immutable doesn't bother me. I'm going all Carmack on my state change.
08:07:47 <yitz> vektor: actually it's the opposite. in haskell it looks like each node actually contains its neighbors. but ghc implements it using pointers.
08:08:17 <vektor> waaat? I thought we were looking the actual nodes up in a separate container, and each node only has the index?
08:10:16 <_d0t> hi. Is there a way to check whether toEnum call will succeed without catching an exception?
08:10:19 <yitz> vektor: each node "contains" all of its neighbors. you use that for navigation. you look up the state of a node in the other container.
08:10:49 <yitz> _d0t: it depends on the particular Enum instance
08:10:58 <vozz_> How would I get the list of all tree nodes with no children?
08:11:10 <yitz> vozz_: flatten
08:11:26 <_d0t> yitz: i'm using derived instance
08:11:33 <vozz_> yitz: thanks :)
08:11:37 <yitz> @type Data.Tree.flatten
08:11:38 <lambdabot> Tree a -> [a]
08:12:04 <vozz_> Wait
08:12:09 <vozz_> that just gives me all the nodes
08:12:28 <yitz> _d0t: without telling us what specific types you are using, we can't know why toEnum might fail
08:12:50 <yitz> vozz_: it gives all the labels
08:13:06 <vozz_> Yeah, I need to be able to filter it for labels with no children
08:13:11 <_d0t> yitz: the code is like this: data T = A | B | C deriving (Enum)
08:14:03 <quicksilver> _d0t: derive Bounded as well
08:14:15 <quicksilver> and compare to (fromEnum minBound) and (fromEnum maxBound)
08:14:20 <yitz> _d0t: oh - just a nullary type, with no other type referenced in it?
08:14:21 <quicksilver> before calling toEnum.
08:14:34 <yitz> _d0t: quicksilver++
08:14:35 <_d0t> quicksilver: that might help, thanks
08:15:49 <quicksilver> safeToEnum :: (Enum a, Bounded a) => Int -> Maybe a; safeToEnum x | x < fromEnum minBound = Nothing | x > fromEnum maxBound = Nothing | otherwise = toEnum x
08:15:54 <quicksilver> bah, missed out the Just
08:16:01 <quicksilver> safeToEnum :: (Enum a, Bounded a) => Int -> Maybe a; safeToEnum x | x < fromEnum minBound = Nothing | x > fromEnum maxBound = Nothing | otherwise = Just (toEnum x)
08:16:16 <_d0t> yeah, i got it already
08:19:01 * hackagebot music-util 0.8 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.8 (HansHoglund)
08:24:01 * hackagebot music-util 0.8.1 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.8.1 (HansHoglund)
08:26:23 <flebron> Is there a place to find exercises to test understanding of Functor?
08:28:41 <benj-> here are a few: https://github.com/NICTA/course/blob/master/src/Course/Functor.hs
08:29:44 <awestroke> why do so many functions in Prelude (base package) have two declarations, and what is USE_REPORT_PRELUDE?
08:30:56 <flebron> benj-: Thank yoU!!
08:30:58 <flebron> *u
08:31:09 <pyon> Is there any example of an Alternative that is not a Monad?
08:32:51 <thrakcattack> :t Field
08:32:52 <lambdabot> Not in scope: data constructor `Field'
08:33:05 <supki> pyon: validation
08:33:10 <mwhitfield> awestroke: I believe Report prelude is basically for demonstration purposes, i.e. has the same functionality as the "real" implementation but with performance optimizations left out for clarity
08:33:14 <benj-> pyon, (Semigroup err, Monoid err) => Alternative (AccValidation err) from Data.Validation
08:33:42 <pyon> supki: benj-: Ah!
08:34:00 <pyon> Wait, Monoid is not derived from Semigroup? :-O
08:34:19 <Clint> pyon: you summoned edwardk
08:35:30 <awestroke> mwhitfield: ah, ok. What's "Report" referencing?
08:36:07 <quicksilver> awestroke: the haskell report
08:36:26 <quicksilver> http://www.haskell.org/onlinereport/ or http://www.haskell.org/onlinereport/haskell2010/
08:39:36 <yitz> mwhitfield: more than just for demonstration, it defines how libraries that conform to the standard must behave.
08:40:31 <Darwin226> Challenge of the day: Make a Haskell program that keeps outputing "nothing" until the user presses a button on the keyboard. Then, output the character pressed and continue outputing nothing. The catch: make it work on Windows
08:40:51 <Darwin226> Has anyone had any experience with something like this? Because I can't get it working to save my life
08:41:08 <yitz> > fix ("nothing " ++)
08:41:10 <lambdabot>  "nothing nothing nothing nothing nothing nothing nothing nothing nothing not...
08:41:25 <yitz> that's the first part
08:41:32 <hiptobecubic> heh
08:41:43 <indigo> Maybe Experience
08:41:52 <prophile> system "yes nothing"
08:41:54 <Darwin226> Yeah. It needs to be a console application. That's where the problem is
08:42:22 <hiptobecubic> Darwin226, without doing the "Nothing" part, do you know how to grab keys at all?
08:42:32 <Darwin226> I'll show you what I've got
08:44:06 <Darwin226> http://lpaste.net/102190
08:44:42 <srhb> I'd make one thread catch input and queue it for the other thread
08:44:47 <srhb> But I like threads. :3
08:45:08 <Darwin226> The symptoms: It outputs nothing at first. It stops as soon as you press any button but it doesn't output anything. If you then press enter it starts outputing the characters you press. Very strange. It also doesn't start writing "nothing" again
08:45:10 <yitz> Darwin226: hah you really did mean literally to print the string "nothing" repeatedly!
08:45:29 <Darwin226> Yeah. That's why I didn't get the joke :D
08:46:48 <Zhuangzi> Darwin226: This program sounds like a torture device.
08:46:58 <srhb> Darwin226: Here's one way that avoids doing magic that might be system specific: Have an MVar or something that's Maybe Char, one thread continually peeks there and prints nothing if it's Nothing, then have another thread getChar continuously and push them into the MVar
08:47:12 <srhb> I love it, it sounds like a really useful program.
08:47:16 <srhb> :P
08:47:20 <S11001001> Would you say this is an unlawful Functor instance? http://lpaste.net/102191
08:47:33 <Darwin226> The issue is that getChar doesn't actual get the char.. It blocks until you enter something and press enter
08:47:36 <geekosaur> Darwin226, you are probably operating in line mode (not sure how that works on Windows)
08:47:59 <srhb> Darwin226: Hence the other thread
08:48:06 <geekosaur> on Unix the default is line mode which behaves as you describe; I am assuming Windows is emulating that and you need to do something to defeat it. possibly setBuffering
08:48:16 <Darwin226> geekosaur: That's a part of the problem. hSetBuffering stdin NoBuffering is supposed to fix that but it doesn't on Windows. That's why I need to do that getHiddenChar thing
08:48:39 <geekosaur> yeh, there islikely more to it but I am not sufficiently familiar with Windows
08:48:53 <geekosaur> on Unix it'd be terminal ioctls / POSIX termios handling
08:49:02 <geekosaur> but Windows doesn't have tty/pty devices like that
08:49:11 <Darwin226> srhb: How would that help? Wouldn't I still need to press enter?
08:49:46 <srhb> Darwin226: Oh, yes, if it blocks already on getChar.
08:49:50 <srhb> I missed that part
08:50:27 <yitz> Darwin226: this SO seems to imply that you can't do it: http://stackoverflow.com/questions/3385427/disable-buffering-on-redirected-stdout-pipe-win32-api-c
08:50:43 <Darwin226> srhb: But you see, getHiddenChar hack is supposed to remedy that. It's a workaround. The issue there is that it doesn't seem to actually empty the stdin so hReady stdin keeps returning True even though I've read the char
08:50:58 <Darwin226> and since stdin is an input stream, I can't flush it or anything
08:51:07 <srhb> Darwin226: Funtimes.
08:51:17 <Darwin226> Indeed
08:52:31 <Darwin226> I'd love to hear ANY alternative. I've even tried several curses libraries but I couldn't get them to install. Supposedly a windows thing again. Is there something that actually works on Windows?
08:53:54 <yitz> Darwin226: you could create a regular Windows program, not a console program, with a window that looks like a console window.
08:54:07 <srhb> Darwin226: If the hReady is causing the problem even in your example, my solution would solve it (if getHiddenChar blocks, at least)
08:54:16 <srhb> OTherwise, no, no idea
08:54:17 <yogert> Hey all,  I have a question about design I was hoping you my comment on. In a nutshell, is it a bad idea to use TypeRep values as keys in a Map and use the map as a function lookup table of sorts? The context is a bit complicated, but I could go into that further if you wish
08:54:47 <S11001001> n/m
08:56:00 <Darwin226> yitz: Making a regular windows program. How would I go about doing that?
08:56:38 <Darwin226> srhb: Actually, that might work. Anything you can point me to? I have barely done threading in imperative code, let alone haskell
08:57:00 <srhb> Darwin226: Test that getHiddenChar really works (and continues to work) and blocks
08:57:21 <Darwin226> It does as far as I can tell
08:57:22 <srhb> Darwin226: Something like forever (getHiddenChar >>= print)
08:57:27 <srhb> If that works, my solution would work
08:58:02 <srhb> Darwin226: OK, then your program starts by creating an empty MVar m and forkIO writer m
08:58:08 <yitz> Darwin226: you could use the win32 package to get low-level access to the win32 api. in particular, i see that the Console API is included.
08:58:26 <srhb> Darwin226: writer m checks if m is empty, if it is just putStrLn "nothing" otherwise print the contents
08:58:36 <srhb> Darwin226: then writer m calls itself
08:58:54 <srhb> Darwin226: The main thread then has a reader loop that continuously getHiddenChar and puts it into the MVar
08:59:02 <srhb> A queue would be better here, but you get the drift
08:59:13 <srhb> (..or?) :)
08:59:23 <Darwin226> Awesome. I'll see if I can get that working
08:59:26 <Darwin226> Thanks
09:20:33 <yogert> Okay, well how about this? I'm doing some parsing of webpages and I want to feed the data into a persist database. At the moment, I've designed it such that my parser will return a PersistEntity that will get fed into the database elsewhere.
09:20:41 <yogert> It seems natural for my parser to return a list of the PersistEntities that have been extracted from the page, but I can't of course have a heterogenous list. So my question is, should I resort to things like Existential Quantification? Because I am only inserting the results of this list into a database it seems to me that a heterogenous list is typesafe in this case
09:22:57 <awestroke> yogert: what different kinds of things are you inserting? It sounds like you could define each thing as a constructor of the same record type
09:23:40 <yogert> awestroke: you mean make a new sumtype to represent them all?
09:25:08 <yogert> yeah i was considering doing that. The only problem with that approach is that Persistent relies heavily on TH and creates a lot of boilerplate representing the database types. I could do it that way, but I was wondering if it was a bad idea to be lazy here : )
09:26:53 <awestroke> yogert: It's very hard to reason about it with this little information, but I'd go with type constructors
09:29:05 <yogert> okay. thanks
09:29:25 <awestroke> yogert: I don't know what's possible with TH, but the optimal solution would be to make TH generate that type too
09:30:53 <yitz> awestroke: persistent generates record types, representing the fields of a table record. not sum types.
09:32:55 <awestroke> generateSumType ''PersistentType1 ''PersistentType2 ''PersistentType3
09:33:11 <yogert> yitz: so would you say creating a sumtype to encompass them all would be the best approach?
09:33:34 <yogert> awestroke: is that a hypothetical TH function to do it for me?
09:34:18 <awestroke> yogert: very hypothetical
09:34:26 <yogert> ha okay
09:36:00 <yogert> well i'd have to learn TH to do that, but I figure its better to write normal haskell, and then make things more convenient with TH later
09:36:55 <Darwin226> So srhb was helping me with my console thing with this being the final code http://lpaste.net/102195 It still doesn't work but I was suggested to ask here. So the problem is that the writer should be constantly outputting something but it isn't. The reader seems to be blocking it because when the call to reader is replaced with threadDelay 1000000000, the writer starts constantly outputing "Nothing"
09:37:49 <nh2> johnw: ping
09:38:00 <yitz> yogert: i think so. that's how i would start out.
09:41:12 <srhb> Darwin226: Just curious as I saw your Haskeline import -- did you try with their getChar function?
09:41:23 <srhb> I think it uses the proper win32 api
09:42:10 <Darwin226> I tried messing with it but the result was the same so I just removed haskeline code
09:42:38 <Darwin226> I'm not comfortable with monads so the fact that I wasn't just in an IO one kind of freaked me out :D
09:42:56 <srhb> Alright.
09:43:37 <srhb> Either way I think you're fighting an uphill battle with GHC having broken Windows terminal support here. It's possible we could find a workaround, but it might be simpler to switch to writing a graphical application, sadly.
09:43:51 <srhb> The GHC bug is so old that I doubt it's going to get any attention any time soon.
09:44:04 <srhb> Lack of Windows users I guess.
09:44:56 <Darwin226> My thoughts exactly. So I tried getting SDL to work. Basically, the resources for making it work with Haskell on windows is one webpage that you need to access through archive.org that has an outdated solution that no longer works..
09:46:07 <srhb> That sounds fun! How about trying something very lightweight to start out with, I'm trying to remember the library I wrote a simple graphical Snake clone with..
09:46:25 <srhb> Darwin226: gloss!
09:47:02 <Darwin226> I was checking that out and it seemed great but I didn't really see any input handling at first glance
09:47:02 <Yuu_chan> Gloss +1
09:47:18 <Yuu_chan> Lack of input handling?!
09:47:19 <dmwit> How does cabal init know my email address? I don't see a setting for it in .cabal/config.
09:47:24 <srhb> Darwin226: It has a looot of input handling
09:47:38 <Darwin226> Great. I'll give it a try
09:47:55 <srhb> I know it works, because I did that exact thing. :-)
09:48:24 <Yuu_chan> By the way, I managed to deal with Windows terminal by adding a bit of FFI hackery.
09:48:29 <Darwin226> Were you on windows though. That's the question :D
09:48:47 <Yuu_chan> Yes
09:48:58 <srhb> Darwin226: Well no, but I know it will work. :P
09:49:11 * hackagebot classy-prelude 0.8.3.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.8.3.1 (MichaelSnoyman)
09:49:13 <srhb> Yuu_chan: Please show us the trickery :)
09:49:16 <Darwin226> fingers crossed
09:49:34 <Darwin226> Holy crap it installed without a problem
09:49:45 <Yuu_chan> As for the Gloss, I wrote small games succesfully working both in Win and Mac.
09:51:04 <Caztiel> I just wanted to check out Haskell's documentation on 'on' (http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/src/Data-Function.html#on) but that really looks frightening O
09:51:05 <Yuu_chan> Darwin226: Ah, you've already discussed getHiddenChar. Sorry, I missed a part of the discussion
09:51:06 <srhb> dmwit: It grabs it from .gitconfig
09:51:09 <srhb> dmwit: Very funky.
09:51:58 <Yuu_chan> But it worked to me (with NoBuffering and so on)
09:52:14 <srhb> Yuu_chan: It's weird that it borked out for us.
09:52:15 <dmwit> srhb: ...huh
09:52:19 <dmwit> thanks
09:52:33 <srhb> dmwit: For the record, I did not know that until I grep -IR .*'ed my address and tried changing it :P
09:53:02 <athan> hmm, can someone explain the universal mapping property to me (from CT)?
09:53:34 <dmwit> srhb: Hm. I changed .gitconfig, but cabal init is still using the other address.
09:53:35 <athan> i see that if you have a product P:    A <---- P ------> B
09:53:46 <athan> it's the cartesian product
09:53:59 <athan> but what troubles me, is that the lecturur I'm learning from
09:54:02 <srhb> dmwit: Must be using more than one source then. Time to check the source :P
09:54:05 <Yuu_chan> >  If you then press enter it starts outputing the characters you press
09:54:08 <lambdabot>  <hint>:1:8: parse error on input `then'
09:54:09 <dmwit> srhb: But your tip made me look in ~/.darcs.
09:54:16 <Yuu_chan> Did you try hSetEcho stdin False?
09:54:20 <dmwit> srhb: And after changing ~/.darcs/author it now seems to catch the right address.
09:54:29 <Darwin226> So I can't install gloss-raster because it can't figure out the LLVM version and suggests I install LLVM. To avoid more confusion, where and how do I install LLVM?
09:54:30 <athan> says there's another element X that also has arrows to A and B, and creates a mapping from X -----> P
09:54:43 <srhb> dmwit: Such an adventure. :P
09:54:51 <athan> Can you create arbitrary objects in CT? to create proofs?
09:54:54 <srhb> Yuu_chan: Yes, we did try that.
09:55:02 <mr-> athan: That question is more appropriate in ##categorytheory
09:55:14 <athan> gah, sorry! Thanks mr-!
09:55:15 <Yuu_chan> Could you please re-explain the current task? I'll try to implement that.
09:55:22 <Darwin226> Yuu_chan: It does that, but it blocks until the next char.
09:55:32 <srhb> Yuu_chan: http://lpaste.net/905993397989277696
09:55:46 <srhb> Yuu_chan: Print "Nothing" constantly, unless a key has been pressed, then print that
09:55:49 <Yuu_chan> Darwin226: I wrote a console Snake game and managed the input with that trickery, it worked
09:55:53 <athan> mr-: There's nobody there :D
09:56:03 <srhb> Constantly as in "every xth of a second"
09:56:16 <mr-> athan: I'm there ;-P
09:56:23 <Yuu_chan> srhb: I'm afraid it would be hard to notice a single letter
09:56:35 <srhb> Yuu_chan: Just increase the threadDelay in writer
09:57:17 <srhb> It works flawless with getChar on my Linux machine.
09:57:20 <Yuu_chan> Oh, yes, my bad. Well, that looks like the Snake.
09:57:23 <Darwin226> Yuu_chan: Do you maybe have the source to that? I could try running it here.
09:58:28 <charmander> How can I define a foreign C function that returns a struct (and not a pointer to one)?
09:59:09 <Yuu_chan> http://lpaste.net/102196
09:59:26 <Guest77325> http://www.marketglory.com/strategygame/galahad1st for online gamers, if you didn't already, use this link to register on MerketGlory: a free2play financial strategy game where virtual currency can be converted into real money. It starts out slow but in time you can turn a good profit that is if you have the necessary patience to grow a little bit every day :P
09:59:36 <athan> mr-: Are you sure? I don't see anyone :(
10:00:02 <dmwit> Apparently lists work even with -XNoImplicitPrelude?
10:00:07 <dmwit> Isn't that a bit weird?
10:00:36 <Yuu_chan> dmwit: isn't list and tuple syntax hardwired?
10:00:42 <srhb> Yuu_chan, Darwin226: Looks like keyboardHit may be the trick
10:01:45 <dmwit> Yuu_chan: If it were, would that make it less weird?
10:02:36 <dmwit> I mean, what you're saying is "NoImplicitPrelude prevents the use of Prelude stuff except for the bits that GHC happens to implement by such-and-such a parsing scheme".
10:02:49 <srhb> dmwit: Yes, isn't that the case?
10:03:03 <dmwit> Whether it's the case is not in question. Whether it's weird is in question. =P
10:03:07 <srhb> Ah.
10:03:11 <srhb> Yes, it is weird.
10:03:19 <Darwin226> srhb: So it seems. I'd still like to try and get gloss running.
10:03:29 <srhb> Darwin226: Right. I don't have Windows I'm afraid.
10:03:30 <Darwin226> The snake example runs well on my machine btw
10:03:43 <Darwin226> No worries, that was just me talking with myself
10:04:03 <srhb> Actually I may have a VirtualBox somewhere...
10:04:08 <dmwit> So, what's even more weird is that this package which uses lists can be compiled without having "base" as a dependency.
10:04:19 <dmwit> In fact it has no dependencies. So what's really happening there?
10:04:25 <dmwit> I mean, there still has to be some linking to actual code, right?
10:04:43 <bartavelle> not if it's hardwired ?
10:04:54 <dmwit> um
10:05:04 <skypers> hey
10:05:12 <dmwit> Just because the syntax is hardwired doesn't mean there's no "data" declaration lying around somewhere that it's hardwired to.
10:05:18 <skypers> does newForeignPtr insert a free in the finalizer?
10:05:23 <skypers> or do I have to do it myself?
10:05:48 <bartavelle> I mean hardwired as in hardwired : I suppose the list type is hardwired in the RTS
10:05:58 <dmwit> oh
10:06:09 <dmwit> That... sounds awful.
10:06:16 <bartavelle> I have no clue about this, but given how prevalent lists are, that might be possible
10:06:24 * dmwit nods
10:07:04 <Yuu_chan> Darwin226: Gloss is very nice and convenient as long as you don't need pretty graphics. It also works (almost) flawlessly with Windows.
10:07:18 <geekosaur> I thought libHSrts was part of the base packages, maybe it's not
10:07:36 <Darwin226> Yuu_chan: What do you mean by pretty graphics?
10:07:49 <geekosaur> that does suggest that there can't be a difference between lists in base vs. standards; I guess they assume it won't happen
10:08:24 <Yuu_chan> Darwin226: smooth scaling, anti-aliased lines, etc
10:08:50 <Darwin226> Yuu_chan: Who needs anti-aliasing. retro is all the rage
10:09:32 <Yuu_chan> Darwin226: I still want a way to enable texture interpolation
10:14:43 <dmwit> What does "other-extensions" do in a cabal file? cabal init generated such a line, but it's not in the documentation.
10:16:11 <int-e> I believe it declares extensions that are used through {-# LANGUGAE #-} pragmas in *some* modules, but not enabled by cabal.
10:16:30 <dmwit> Okay. But what does it *do*?
10:16:36 <bartavelle> dmwit, I think it's just to give you an idea of the kind of extensions that are used in the source
10:16:41 <bartavelle> it doesn't seem to do anything
10:17:11 <int-e> dmwit: I also don't see it being used, but it could be used to check whether a haskell implementation supports a package.
10:17:30 <bartavelle> the problem is that it's entirely indicative
10:18:44 <Yuu_chan> Darwin226: also the text capabilities of Gloss are rudimentary
10:19:15 * hackagebot classy-prelude-yesod 0.8.1 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.8.1 (MichaelSnoyman)
10:19:52 <tommd> Put the word 'capabilities' in quotes when you say something like that!  Gloss has no text capabilities, only text "capabilities"... or perhaps "text" capabilities is more accurate.
10:20:11 <Darwin226> Yuu_chan: I'd love to be able to at least install the examples :/ gloss-raster doesn't want to install because it claims I don't have llvm installed. This doesn't seems to be a gloss thing but a GHC thing. Any idea how to make it work?
10:20:39 <srhb> Darwin226: Installing llvm I guess
10:20:46 <srhb> Darwin226: Which may or may not be a pain on Windows
10:20:54 <tommd> Darwin226: Just 'cabal unpack gloss-raster'
10:21:02 <tommd> and remove the '-fllvm' line from the .cabal
10:21:08 <tommd> Then give installing a try (cabal install)
10:21:15 <srhb> Oh, that sounds simpler. :-)
10:21:22 <Yuu_chan> Darwin226: you don't need gloss-examples to run gloss examples
10:21:30 <Yuu_chan> Just copy-paste some code and run it :)
10:21:37 <Darwin226> I assume I need gloss-raster at least
10:21:37 <bartavelle> (on second thought it doesn't make much sense to have list have a meaning in the RTS, but there probably is some special support in the compiler)
10:21:40 <srhb> Darwin226: Yes
10:21:40 <Darwin226> that sounds important
10:22:01 <Yuu_chan> Darwin226: nope
10:22:38 <Yuu_chan> I installed only "gloss" itself and it worked with no problems.
10:23:29 <Yuu_chan> In Windows, if that matters.
10:23:35 <Darwin226> Well, I'll try what tommd suggested anyways. If that doesnt work I'll just ignore it
10:23:47 <srhb> You lose some functionality, of course, but I assume the rest will try to build with llvm as well
10:23:49 <Darwin226> Oh wow. It actually did
10:24:02 <Darwin226> No, I installed gloss without a rpoblem
10:24:08 <srhb> Oh really? Funky.
10:24:14 <Darwin226> Yeah. Strange
10:24:19 <Darwin226> Something about performance
10:24:23 <Darwin226> https://groups.google.com/forum/#!topic/haskell-cafe/R94t1_jYnHc
10:24:26 <srhb> Ah, I see.
10:29:16 * hackagebot modelicaparser 0.1.0.0 - A parser for the modelica language  http://hackage.haskell.org/package/modelicaparser-0.1.0.0 (fphh)
10:36:59 <nh2> when using bindings-dsl, how do I tell hsc2hs where bindings.dsl.h is?
10:38:41 <mT37m> hi guys! I'm pretty new to haskell and downloaded the haskell for windows on the website and tried to install SublimeHaskell. The docs said I need to run 'cabal install haddock' but it just said: 'Unsupported GHC version'. Now my GHC version is 7.6.3. I'd expect it to work with the version from the haskell site... Thanks for any help :)
10:38:47 <nh2> carter: when dealing with numeric haskell things, have you every used one of the BFGS implementations or can you recommend one otherwise?
10:39:08 <carter> nh2: i've not used any in haskell yet
10:39:14 <carter> been buried in the weeds
10:39:27 <carter> nh2: whats the problem you're wanting to solve?
10:39:58 <geekosaur> mT37m, haddock is kinda weird, you need to use a constraint to install the right version. (ghc 7.8 is expected out shortly and the haddock package was just updated to work with it)
10:40:01 <nh2> carter: do the gsl bindings have good reputation? I want to implement a paper that needs BFGS as a tool so I'd like a proven implementation of that
10:40:21 <carter> nh2: ive not touched the gsl ones 'cause they've gpl
10:40:26 <geekosaur> ...haddock uses ghc's innards to understand types so it is very closely tied to ghc versions
10:40:28 <carter> but they *should work* ok
10:40:36 <carter> nh2: that said, AD migth be worth checking out too
10:40:48 <carter> though it has not lbfgs yet
10:40:59 <carter> nh2: whats the paper?
10:41:38 <geekosaur> mT37m, cabal install haddock-2.13.2.1
10:41:41 <nh2> mT37m: haddock haddock-2.13.2.1 works for me
10:42:09 <nh2> mT37m: cabal install haddock --constraint=haddock==2.13.2.1
10:42:44 <nh2> carter: http://scholar.google.com/scholar?cluster=340160251959314634&hl=en&as_sdt=0,5&sciodt=0,5
10:42:57 <peddie> nh2: the hmatrix bindings to GSL's BFGS solver should be fine
10:42:59 <nh2> point cloud alignment
10:43:01 <carter> yeah
10:43:04 <mT37m> geekosaur & nh2: Thanks a lot, that works!
10:43:05 <carter> *should be*
10:43:12 <carter> nh2: #numerical-haskell is a thing too now :)
10:43:26 <peddie> carter: what do you mean by emphasizing it?
10:43:45 <carter> peddie: 'cause i've never used it
10:43:49 <carter> and wont because gpl
10:44:03 <peddie> carter: I'm all for you and other people writing lots of numerical haskell code, but just because you can't use it due to the license doesn't mean the code isn't well-tested or high-quality :)
10:44:16 * carter peddie: i'm saying I can't evaluate it :) 
10:44:44 <peddie> you said that above, and I wanted to reassure him that I've used the GSL minimizers from haskell with no trouble, and they worked fine
10:44:49 <carter> ok cool
10:44:50 * peddie shrugs
10:45:02 <carter> i wasn' implying anything
10:45:08 <carter> merely remarking i' personally don't know :)
10:45:26 <ndaincjai> Any idea, Haskell Wizards?
10:45:27 <ndaincjai> https://stackoverflow.com/questions/22844785/identification-in-a-distributed-p2p-network
10:45:37 <carter> nh2: the paper doesnt mention bfgs afaict
10:45:45 <peddie> fair enough :)
10:47:02 <carter> peddie: nh2  fun thing: a suitably generalized multi dim array api really should have array allocation/generation be a different type class than reading/writing
10:48:37 <nh2> mT37m: thanks! https://github.com/SublimeHaskell/SublimeHaskell/commit/a56857171a6a843ad0a7b7e273a9d22c4c7445ad?short_path=04c6e90#diff-04c6e90faac2675aa89e2176d2eec7d8
10:50:18 <peddie> carter: can you explain in more depth what you mean?
10:50:22 <Fuuzetsu> nh2: there's no problem, we simply require 7.8 for 2.14.x Haddock version
10:50:26 <peddie> carter: that sound sinteresting
10:50:40 <carter> peddie: so heres a simple observation
10:50:49 <carter> peddie: nh2  lets switch to #numerical-haskell and i'll explain there :)
10:50:56 <carter> ping me when you've switched
10:51:33 <carter> nh2: you can join too :)
10:52:15 <nh2> cater: ok, but I go to dinner now
10:52:21 <carter> k
10:52:23 <carter> :)
10:52:23 <carter> enjoy!
10:52:27 <nh2> thanks :)
10:52:35 <carter> invite still stands for lurking
10:53:17 <nh2> Fuuzetsu: hang on, why did he have a problem with the latest haddock in the first place?
10:53:34 <nh2> the ghc constraint should have made sure he gets the right one, shouldn't it?
10:54:05 <ast_> what is the best way to run some prebuild script with cabal? I want to build some files with hprotoc before compiling the package.
10:54:18 <Fuuzetsu> nh2: yes but it waas just pointed out to me that the constraint is too loose
10:54:33 <ReinH> So I guess it's time to figure out how to get Haskell Platform / GHC working on OS X Mavericks
10:54:39 <Fuuzetsu> it's like GHC 7.4 to 7.10
10:55:11 <nh2> Fuuzetsu: oh, I see. Is that editable on hackage2?
10:55:48 <Fuuzetsu> nh2: NOTE: This is work in progress. It's not currently actually possible to publish new revisions (see Issue 52).
10:55:55 <ReinH> luite: ping
10:56:08 <skypers> @hoogle fromBool
10:56:09 <lambdabot> Foreign.Marshal.Utils fromBool :: Num a => Bool -> a
10:56:13 <Fuuzetsu> I _think_ what we could do is to release 2.14.3 with the versions updated and deprecate 2.14.1 and .2
10:59:30 <[swift]_> so i frequently find myself writing code like this: hasPendingFlags = any (\f -> flagStatus == "?" && (flagName f == "review" || flagName f == "feedback"))
10:59:39 <[swift]_> are there any standard combinators i can use to make that pointfree?
11:00:18 <[swift]_> i wrote myself (.&&.) and (.||.) operators to do so at one point but i'm not sure if i was missing something in the standard library - maybe arrows could be used?
11:01:07 <eacameron> anyone have any convincing resources on why to avoid mutable state?
11:01:11 <[swift]_> i find these sorts of things visually much nicer without the explicit lambda
11:04:48 <[swift]_> with my combinators, that hasPendingFlags function would've looked something like this: any $ (== "?") . flagStatus .&&. ((== "review") . flagName .||. (== "feedback") . flagName)
11:05:11 <[swift]_> hmm, looking at it now i wonder if Control.Lens might be able to do this for me somehow...
11:06:23 <johnw> nh2: pong
11:06:40 <nh2> [swift]_: seems more difficult to understand in the first place and hinder quickly skimming the code. Maybe an `or` + list comp with NamedFieldPuns would look nicer?
11:07:00 <nh2> johnw: I have a question about c2hsc and bindings-dsl
11:07:06 <johnw> fire away
11:08:04 <nh2> first: how is c2hsc supposed to find bindings.dsl.h in my cabal folder (assuming that my binding is not in your git repo of those many bindings-*)?
11:08:55 <johnw> it's supposed to be in your ~/.cabal/lib directory
11:09:00 <[swift]_> nh2: i think the problem is just that i should define helper functions for the components of the check. this looks pretty good i think: any $ flagRequested .&&. (isReviewFlag .||. isFeedbackFlag)
11:09:12 <[swift]_> nh2: still need those combinators, though
11:11:33 <nh2> [swift]_: I was thinking about `or [ flagStatus == "?" && flagName `elem` ["review", "feedback"] | Flag{..} <- flags ]` (here using RecordWildCards
11:11:57 <[swift]_> nh2: hmm, that's interesting... i didn't think of using that!
11:12:11 <nh2> johnw: I have this: ~/.cabal/lib/x86_64-linux-ghc-7.6.3/bindings-DSL-1.0.21/include/bindings.dsl.h
11:12:19 <nh2> but I don't think c2hsc manages to use that
11:14:35 <nh2> johnw: sorry, I meant "I don't think hsc2hs manages to use that" - how should it know about it?
11:14:38 <nh2> I get Myfile.hsc:2:26: fatal error: bindings.dsl.h: No such file or directory
11:17:26 <exicer> I'm working through the lens tutorial at: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial#okay--that-makes-sense--didn-t-you-say-we-can-compose-lenses-
11:17:40 <exicer> But I'm getting a type error at the meetupLat step
11:17:49 <exicer> Something about The type variable `f1' is ambiguous
11:17:50 <johnw> nh2: hmm... I haven't seen this problem before
11:19:42 <exicer> Any ideas ?
11:21:37 <nh2> there is a lens irc channel
11:21:43 <Fuuzetsu> #haskell-lens
11:21:45 <exicer> Oh ?
11:21:57 <exicer> Ah, yeah I actually just found that
11:22:46 <edwardk> exicer: you probaby need to write meetupLat :: Lens' Meetup Latitute; meetupLat = location._1   -- rather than try with th annotation on the end
11:22:56 <edwardk> i don't think the author actually tried that line =)
11:23:30 <exicer> Ah :P
11:24:35 <exicer> edwardk: Yep, it works now. Thanks!
11:29:25 * hackagebot trifecta 1.4.2 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.4.2 (EdwardKmett)
11:29:27 * hackagebot hexpr 0.0.0.0 - A framework for symbolic, homoiconic languages.  http://hackage.haskell.org/package/hexpr-0.0.0.0 (ZankokuOkuno)
11:39:31 <ReinH> edwardk: hai
11:44:42 <glosoli> Why is it suggested to to use ghci as prompt and not Prelude ?
11:44:47 <glosoli> At least according to LYAH book
11:45:10 <Rufflewind_> what do you mean prompt?
11:45:16 <mwhitfield> glosoli: i think just so the prompt doesn't get overlong as you import modules
11:45:28 <jrmithdobbs> because after you have like 6 modules loaded the prompt gets retarded
11:45:31 <nh2> johnw: my generated .hsc file contains `#include <bindings.dsl.h>`. How should hsc2hs know where to look for that?
11:45:34 <glosoli> Rufflewind_: :set prompt gchi
11:45:56 <Rufflewind_> ah that's what you mean
11:45:57 <glosoli> mwhitfield: I still don't get how is it different from Prelude hmm
11:46:19 <mwhitfield> glosoli: try "import Data.List" with and without changing the prompt and see what happens
11:46:24 <Fuuzetsu> glosoli: it just stops the prompt from growing to massive sizes when you import
11:46:26 <jrmithdobbs> glosoli: because the prompt isn't "Prelude" it's a space separated list of all imported modules
11:46:35 <johnw> nh2: can you run hsc2hs yourself with the --verbose flag?
11:46:45 <kadoban> glosoli: it's just what is displayed when it's waiting for your next line of input, if that helps.  ghci doesn't care what it's set to
11:47:02 <glosoli> so many different answers
11:47:02 <glosoli> hmm
11:47:02 <jle`> glosoli: you can set the prompt to whatever you want, it's just a text string and it doesn't actually mean anything
11:47:03 <Rufflewind_> isn't the prompt just a visual thing so it doesn't really matter what you set it do
11:47:16 <mwhitfield> no, one answer said many different ways
11:47:16 <Rufflewind_> s/do/to/
11:47:25 <jle`> it's like setting $PS1 in bash
11:47:28 <glosoli> Aaa
11:47:37 <glosoli> So why would someone suggest setting it to ghci :D
11:47:45 <jrmithdobbs> because the default sucks
11:47:49 <jrmithdobbs> for the nth time
11:47:50 <mwhitfield> so it doesnt get annoying with a lot of modules imported
11:47:50 <kadoban> glosoli: try without and you'll see, yeah the default is pretty bad
11:48:00 <jle`> i set mine to λ :)
11:48:23 <kadoban> that does seem like a good idea really, heh
11:48:27 <glosoli> Is there some config of Prelude where I can set it to be displayed as λ all the time  ?
11:48:29 <glosoli> :D
11:48:34 <glosoli> or some other symbol
11:48:41 <jrmithdobbs> i set mine to "> "
11:48:45 <mwhitfield> yeah i think it's ~/.ghci
11:49:01 <mwhitfield> just make that file and add ":set prompt {whatever}"
11:49:19 <jrmithdobbs> in fact, i set it to "> " in all repls, $ == sh, > == some random repl, easier to distinguish tmux windows that way
11:49:36 <glosoli> thanks folks
11:49:44 <nh2> johnw: Executing: /usr/bin/gcc -c Bindings/OpenNI2/OniCTypes_hsc_make.c -o Bindings/OpenNI2/OniCTypes_hsc_make.o -fno-stack-protector -I/usr/lib/ghc/include/
11:49:44 <nh2> OniCTypes.hsc:2:26: fatal error: bindings.dsl.h: No such file or directory
11:50:08 <johnw> that's really odd that it's not specifying the path under ~/.cabal
11:50:10 <ReinH> Hmm, is this a paramorphism? https://gist.github.com/lenary/61dbfc6e6c91899a0828#file-tr-hs-L61-L64
11:50:29 <jrmithdobbs> nh2: -I./ ?
11:50:30 <Fuuzetsu> note that if you use GHCi in emacs, changing the prompt might break it, read up on it online
11:51:07 <nh2> johnw: I'm using hsc2hs version 0.67
11:51:18 <johnw> ReinH: paramorphism has type: para :: (a -> [a] -> b -> b) -> b -> [a] -> b
11:51:30 <ReinH> johnw: I know. What I mean is: can it be written as a paramorphism.
11:51:55 <nh2> jrmithdobbs: I could give it the absolute path, but I don't think that's how the tool is meant to work (and also it would break on other people's setups)
11:51:58 <ReinH> of type (a -> [a] -> [a] -> [a]) -> [a] -> [a] -> [a]
11:51:58 <johnw> i bet you could write it with just scanl and map
11:52:04 <ReinH> johnw: ah hmm
11:52:37 <glosoli> Fuuzetsu: I do, did change it to ghci in config, did not break it
11:53:01 <johnw> nh2: when I run it I get: /usr/bin/gcc -c ./PosixFile_hsc_make.c -o ./PosixFile_hsc_make.o -m64 -fno-stack-protector -I/usr/local/Cellar/ghc/7.6.3/lib/ghc-7.6.3/include
11:53:17 <johnw> but my bindings.dsl.h isn't in that directory either
11:53:35 <johnw> nh2: trycommenting out that include
11:55:58 <ReinH> johnw: Hmm, I'm not seeing how scanl helps :/
11:56:06 <johnw> maybe not
11:56:12 <johnw> :)
11:56:26 <ReinH> :)
11:58:06 <nh2> johnw: then I'm getting syntax errors: OniCTypes.hsc: In function ‘main’:
11:58:06 <nh2> OniCTypes.hsc:10:20: error: expected expression before ‘OniBool’
11:58:33 <johnw> can you paste the file anywhere?
11:58:43 <johnw> c2hsc can be somewhat imprecise
11:58:53 <johnw> it's a "best guess" type of tool
11:59:19 <Fuuzetsu> glosoli: cool, maybe it was since fixed
11:59:28 * hackagebot octopus 0.0.1.0 - A 100-year language inspired by Kernel, JSON, Clojure, Arc and science.  http://hackage.haskell.org/package/octopus-0.0.1.0 (ZankokuOkuno)
11:59:32 <glosoli> Fuuzetsu: Ah nah it wasn't heh w/e I will just use Terminal
12:00:33 <nh2> johnw: already happens for me if I just do: `c2hsc --prefix=Wait /usr/include/wait.h && hsc2hs Wait.hsc`
12:01:09 <ReinH> johnw: isn't there a simple way to turn [1,2,3] into 123 using a fold? By composing (*10) somewhere?
12:01:25 <johnw> ReinH: I seem to recall that being asked here in the channel before
12:01:36 <ReinH> johnw: and I seem to recall seeing it in some code somewhere
12:01:40 <johnw> read . concat . map show :)
12:01:54 <ReinH> johnw: ok, not do it in octal ;)
12:01:57 <ReinH> *now
12:02:04 <srhb> Why, that wouldn't scale very well.
12:02:06 <srhb> :P
12:02:33 <jrmithdobbs> ReinH: iterate' f start (a:rest) = a : (foldr f (iterate' f a rest)
12:02:35 <jrmithdobbs> ReinH: ?
12:02:53 <jrmithdobbs> ReinH: without leaving off the last args to foldr obviousl
12:02:56 <ReinH> jrmithdobbs: is it really that simple :/
12:03:14 <ReinH> I thought it was a fold but my haskell brain isn't working today
12:03:37 <johnw> ah, I thought he wanted the map for some reason
12:03:48 <nh2> ReinH: did you mean foldl' (\a x -> a*10+x) 0 [1,2,3]
12:04:05 <ReinH> nh2: I think so
12:05:12 <nh2> johnw: clearly that include path is created by your hsc2hs but not by mine
12:05:36 <ReinH> nh2: as an aside, isn't (+) strict in its first argument?
12:06:13 <nh2> ReinH: you mean I could have used foldl?
12:07:51 <johnw> @src foldl
12:07:52 <lambdabot> foldl f z []     = z
12:07:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:08:02 <nh2> johnw: shall we move this to #ghc?
12:08:14 <johnw> nh2: I don't see how this is an issue for the GHC developers
12:08:41 <nh2> johnw: maybe there's somebody around who knows how hsc2hs picks its include paths
12:08:42 <ReinH> nh2: I think so, but I also think foldl' should be the default so...
12:09:01 <ReinH> nh2: or, "when in doubt use foldl'"
12:09:06 <johnw> you may not need bindings.dsl.h
12:09:11 <johnw> that's why I'd like to see your file
12:09:26 <nh2> ReinH: yes, I think keeping foldl and sum is a trolling on the community
12:09:58 <jrmithdobbs> nh2: they're useful ocassionally but which versions have ' appended is pretty backwards atm ;p
12:10:03 <ReinH> @src sum
12:10:03 <lambdabot> sum = foldl (+) 0
12:10:08 <ReinH> oh. oh my.
12:10:23 <nh2> johnw: run `c2hsc --prefix=Wait /usr/include/wait.h && hsc2hs Wait.hsc` to get the file yourself, and compare with mine: http://lpaste.net/102199
12:10:24 <ReinH> nh2: well it doesn't actually matter b/c (+) is strict enough, but yeah
12:10:34 <ReinH> iirc
12:10:57 <srhb> ReinH: That's not the actual source for sum
12:10:58 <johnw> ok
12:11:00 <nh2> ReinH: it does matter: if you use `sum` from the prelude in ghc, you have O(n) memory
12:11:11 <johnw> except I don't have that include file
12:11:18 <ReinH> srhb: ah
12:11:22 <nh2> srhb: that's not the actual source for sum??
12:11:23 <ReinH> I forget that @src lies
12:11:28 <srhb> nh2: No.
12:11:36 <srhb> But it would be optimized anyway iirc
12:11:39 <srhb> to foldl'
12:11:43 <srhb> (Basically.)
12:11:44 <nh2> srhb: where is the actual source for sum
12:11:53 <nh2> srhb: in ghci it blows up
12:11:56 <johnw> nh2: i'm using cabal to build my hsc bindings
12:12:02 <johnw> and I have #include <bindings.dsl.h> in all my bindings files
12:12:27 <srhb> nh2: ghci is different.
12:12:32 <ReinH> srhb: er. http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#sum
12:12:39 <srhb> nh2: The source is in base, Data.List
12:12:48 <geekosaur> nh2: http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/src/Data-List.html#sum
12:12:59 <ReinH> Ah.
12:13:15 <geekosaur> the @src database is cribbed from the Report Prelude, whose code is largely more tutelary than practical
12:13:20 <ReinH> when is USE_REPORT_PRELUDE true?
12:13:29 <glosoli> Fuuzetsu: it got me bothered, nay ideas if there is any way to just use w/e I want in .ghci for a prompt  and make emacs haskell mode handle it properly ?
12:13:34 <jle`> nh2: hoogle usually helps you find it well
12:13:35 <srhb> ReinH: When you don't use the GHC Prelude
12:13:44 <ReinH> ah
12:14:08 <jle`> i wonder why the report prelude has sum as a foldl instead of a foldr
12:14:19 <jle`> anyone from the report here?
12:15:05 <nh2> no matter if USE_REPORT_PRELUDE or not, `sum` still breaks in ghci
12:15:08 <geekosaur> glosoli, probably not, emacs interaction modes need to know how to detect a prompt to work right and it's up to the user to ensure the prompt is compatibel or update the prompt regex
12:15:15 <monochrom> the report is not meant to be optimized
12:15:30 <glosoli> geekosaur: ah crapppp :) thanks
12:15:32 <geekosaur> but ghci doesn't optimize
12:15:38 <monochrom> the report is meant to communicate "what answer is right" not "how to optimize code"
12:16:06 <jrmithdobbs> so the 'right' answerto sum should accossionally be stack overflow? ;p
12:16:11 <monochrom> so for example why don't you also pick on the report advertising insertion sort? that's a more worthy war, if you're looking for a war
12:16:27 <srhb> One kind of explosion traded for another? :P
12:16:28 <nh2> yes, ghci doesn't optimize, but that shouldn't mean that the sum function should blow up the only real-world interpreter
12:16:48 <srhb> nh2: No, a lot of people want to simply swap foldl for foldl'
12:17:05 <nh2> yes, that'd be great
12:17:44 <monochrom> what is stack overflow?
12:18:03 <nh2> johnw: ah, you mean that cabal might add that -I ?
12:18:10 <johnw> yes, it's very possible
12:18:24 <johnw> it's knows that you have a dependency on Bindings-DSL, for example
12:18:27 <monochrom> I am serious. a popular compiler hardcodes stack size to 8MB. that is the stack overflow.
12:18:52 <johnw> monochrom: still don't understand your question
12:19:00 <monochrom> let us be fair. suppose a popular compiler hardcoded heap size to 8MB as well. then you would be talking about heap overflow all the time.
12:19:20 <geekosaur> johnw: the point is that ghc defaults to what is arguably a stupidly small stack
12:19:34 <monochrom> but clearly 8MB is going to cause heap overflow for reasonable programs with reasonable input
12:19:45 <johnw> and yet, it's a limit I run into so rarely, that running into it is a good sign of other problems
12:19:53 <monochrom> the same is true of the 8MB stack
12:19:58 <srhb> Indeed, it should be an indicator that something is wrong.
12:20:40 <swtail> Hello and been learning Haskell depues some time and this experience I wonder, you need to have a very advanced level in math to be a Haskell developer, no matter what area're working (web development)? or experience and perseverance could come to dominate everything with some basic notions of mathematics?
12:20:58 <johnw> you really don't need any math at all, in fact
12:21:18 * geekosaur is generally lousy at higher math but manages fairly well
12:21:28 <DR6> yes, all "math" in haskell is self-contained
12:21:51 <DR6> that is, you learn it while learning haskell and you don't have to know the general principles behind it
12:22:01 <vozz_> How on earth do I compile a file with profiling? It complains I haven't installed the profiling libraries for the dependencies, but I have profiling enabled in my cabal file
12:22:08 <srhb> No one* really knows that kind of math anyway. :-)
12:22:15 <geekosaur> if you want to understand the "why" behind some aspects of library design then you might want to know some higher math. this is not necessary to *use* them
12:22:16 <johnw> vozz_: you need to rebuild everything you depend on with profiling
12:22:45 <ReinH> jrmithdobbs: hmm, your foldl isn't quite the same...
12:22:45 <vozz_> johnw: I tried doing that with cabal-dev but it doesnt seem to make a difference :(
12:22:57 <monochrom> my point is this. you raise that one piece of code in the report uses more than O(1) stack. and you don't raise that all other pieces of code in the report use more than O(1) heap. are you being consistent?
12:23:17 <geekosaur> in particular, you don't have to know anything at all about category theory to use monads; from the point of view of a programmer, they're just a design pattern
12:23:17 <johnw> vozz_: that is interesting, that should have worked
12:23:37 <geekosaur> and you don't need to care about where that pattern came from
12:23:52 <johnw> monochrom: what argument are you trying to make?
12:24:15 <monochrom> I am arguing against "so stack overflow is the right answer?"
12:24:17 <vozz_> How exactly am I supposed to rebuild it with profiling enabled?
12:24:37 <vozz_> I literally just rebuilt lens and it still complains it isnt installed with profiling
12:24:42 <johnw> cabal-dev install --enable-library-profiling world
12:24:52 <johnw> you need *everything* rebuilt with profiling
12:24:57 <johnw> all the way down to the base libraries
12:25:06 <johnw> a GHC install should have installed profiling variants
12:25:10 <johnw> but everything else you've built since then did not
12:26:28 <nh2> johnw: ah, now we are getting there. So it only works out of the box if I'm using cabal and if I have bindings-DSL in the build-depends. That should go somewhere in the beginning of the docs :)
12:26:45 <johnw> nh2: that's a very good point, I'll make a note of that
12:32:53 <nh2> johnw: ok, now I have another practical problem: c2hsc generates some things twice, namely:
12:33:02 <nh2> struct OniCallbackHandleImpl;
12:33:02 <nh2> typedef struct OniCallbackHandleImpl* OniCallbackHandle;
12:33:10 <johnw> yep, just delete the wrong one :)
12:33:16 <johnw> it has problems with typedefs sometimes
12:33:29 <johnw> i think I have a patch for that that I haven't uploaded to Hackage yet, one sec
12:33:29 <nh2> generates:
12:33:29 <nh2> {- struct OniCallbackHandleImpl; -}
12:33:29 <nh2> #opaque_t struct OniCallbackHandleImpl
12:33:29 <nh2> {- typedef struct OniCallbackHandleImpl * OniCallbackHandle; -}
12:33:29 <nh2> #opaque_t struct OniCallbackHandleImpl
12:34:16 <nh2> johnw: I would prefer to use c2hsc in such a way that I always *generate* the bindings from the C files (as opposed to doing that once and then keeping them up to date by hand)
12:34:22 <johnw> i'm pushed up 0.6.5 now
12:34:28 <pavonia> Say I have a library that is a bit tricky to test but I'm pretty sure, there are still some bugs hidden that could possibly make the whole library useless in that certain use case. Do I release the library as "experimental" and wait for bug reports arriving, or is there a better way for handling such pre-releases?
12:34:28 <nh2> is that an uncommon use-case?
12:34:38 <johnw> nh2: it's not uncommon, it just may be beyond the ability of c2hsc
12:34:58 <nh2> johnw: how do you do it for all the other bindings?
12:35:14 <johnw> i massage them after generation
12:35:23 <johnw> and use the diff against the last version to guide me
12:35:24 <a3gis> hey! I've a quick question: what do you guys think about clojure versus haskell for functional programming?
12:35:41 <joseph07> a3gis: haskell obvs
12:35:43 <johnw> a3gis: if you're asking in #haskell, what else can we say?
12:35:58 <geekosaur> that strikes me as an odd question to ask here (or #clojure for that matter)
12:36:17 <a3gis> well you might have constructive opinions; on #clojure I asked the same question and they trolled haskell for 10min
12:36:33 <kadoban> haha
12:36:37 <monochrom> I am willing to write more Haskell for free than Clojure for free
12:36:57 <johnw> what does trolling Haskell look like?
12:37:04 <joseph07> a3gis: my knowledge on clojure is somewhat limited, but I think it's a lisp dialect that runs on the jvm
12:37:10 <geekosaur> in all seriousness I'd say it is worth knowing both, as they take different approaches
12:37:26 <johnw> I don't like being bound to the JVM; it limits what I can use Haskell for
12:37:27 <kadoban> a3gis: Try both, see what you think.  Haskell seems more difficult to learn, but I use it way more often, but that's probably just my personal experience.
12:37:29 <dysinger> one is the wrong approach
12:37:32 <dysinger> :)
12:37:34 <geekosaur> (I haven't worked with Clojure specifically but I know it's a Scheme dialect on the JVM)
12:37:46 <dysinger> I kid
12:37:59 <monochrom> does clojure have pattern matching?
12:37:59 <vendethiel> "bu-but the jvm erases types"
12:38:12 <vendethiel> monochrom, I believe it does
12:38:16 <geekosaur> so does haskell :p
12:38:19 <oubiwann> monochrom: Rich Hickey is not a fan of pattern matching
12:38:28 <jrmithdobbs> f# is fun for CLR interop stuff
12:38:30 <oubiwann> he feels that it makes things too complex, iirc
12:38:38 <vendethiel> geekosaur: that's the joke !
12:38:45 <jrmithdobbs> you don't really seem to get that same fun with clojure and the jvm from what i've seen
12:38:46 <joseph07> I feel like from an educational perspective the thing to do would be to learn scheme and haskell
12:38:47 <oubiwann> however, there is a pattern matching library for Clojure, should you want to play
12:38:48 <Eduard_Munteanu> Pattern-matching is complex?
12:39:11 <a3gis> johnw: a lot of jokes on static type systems ending up with a link to v
12:39:13 <geekosaur> for scheme I can see that
12:39:14 <a3gis> johnw: https://www.destroyallsoftware.com/talks/useing-youre-types-good *
12:39:24 <Eduard_Munteanu> I suppose that depends on how rich your types are, though.
12:39:33 * hackagebot c2hsc 0.6.5 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.6.5 (JohnWiegley)
12:39:39 <johnw> nh2: ^^
12:39:40 <oubiwann> Eduard_Munteanu: I *think* his point is that it introduces complexity into programs... I'm obviously hazy on the details
12:39:48 <nh2> johnw: installing it at the moment
12:39:50 <haasn> Eduard_Munteanu: yes, we should clearly be using isJust and fromJust
12:39:58 <monochrom> well, basically, if a language doesn't have pattern matching, it blows. see my http://www.vex.net/~trebla/haskell/crossroad.xhtml
12:40:10 <oubiwann> Eduard_Munteanu: in the same way that regex's do
12:40:21 <awestroke> is there a way to automaticallt export all record getters? if I have "data T = TA { getA :: Int, getB :: Int }" , I want to be able to do something like "module X (TA, TA.*)" instead of "module X (TA, getA, getB)"
12:40:22 <oubiwann> monochrom: that's my opinion as well :-)
12:40:26 <geekosaur> meh. the problem with pattern matching is you're operating on the structure of a type.
12:40:32 <geekosaur> what, in scheme, is a type?
12:40:42 <Eduard_Munteanu> What about having eliminators without explicit pattern matching? :P
12:41:05 <monochrom> I accept eliminators as well. I don't make a distinction there.
12:41:08 <pavonia> awestroke: TA (..) I think
12:41:15 <pmade> awestroke: TA (..)
12:41:22 <pmade> pavonia: Beat me!
12:41:36 <pavonia> :p
12:41:37 <glosoli> With no  customisations to Haskell prompt, any ideas why would entering something in inferior haskel under emacs would fail to execute anything even succ 8
12:41:41 <awestroke> pavonia, pmade: thanks
12:41:45 <monochrom> anyway the last thing I want is encoding a simple algebraic data type as a class hierarchy
12:42:38 <monochrom> but what the hell, I'll show you how: http://www.vex.net/~trebla/humour/Nightmare.java
12:43:24 <nh2> johnw: it now generates:
12:43:24 <nh2> {- struct OniCallbackHandleImpl; -}
12:43:24 <nh2> #opaque_t struct OniCallbackHandleImpl
12:43:24 <nh2> {- typedef struct OniCallbackHandleImpl * OniCallbackHandle; -}
12:43:24 <nh2> #opaque_t struct OniCallbackHandleImpl
12:43:24 <nh2> #synonym_t OniCallbackHandle , <struct OniCallbackHandleImpl>
12:43:31 <nh2> so still a duplicate #opaque_t struct OniCallbackHandleImpl
12:44:09 <johnw> can you file a bug at https://github.com/jwiegley/bindings-dsl with a reproducible case that I can try here?
12:44:22 <nh2> johnw: ok
12:45:07 <johnw> thanks!  I'll have some time to fix it this weekend maybe, as part of NYC Hac
12:45:37 <johnw> and since I want to upgrade hlibgit2 to libgit2 0.20 also, improving c2hsc would help
12:45:39 <jrmithdobbs> monochrom: the number of times i've written almost exactly that in various OO languages before finding languages that solve adt/pattern matching sanely makes me kind of sick looking back =/
12:46:04 <vozz_> johnw: I did cabal-dev install --enable-library-profiling world and it installed things I don't need for this package, and failed on something... how do I ignore those?
12:46:07 <nh2> johnw: but I should file it for c2hsc, not bindings-dsl, right?
12:46:24 <johnw> vozz_: Perhaps not world then, but just --only-dependencies?
12:46:30 <johnw> nh2: right
12:46:34 <johnw> sorry about that, bad link :)
12:46:42 <nh2> vozz_: in my experience the easiest way is to mv away your ~/.ghc folder, and then install the stuff you want
12:46:49 <nh2> the world reinstall broke for me in the past as well
12:47:02 <vozz_> It says all the requested packages are installed
12:47:40 <vozz_> How do I compile my program with profiling now?
12:48:04 <vozz_> cabal-dev install --enable-library-profiling --enable-executable-profiling works, but then running the executable with +RTS -p fails
12:48:19 <vozz_> it says I need to recompile with -prof
12:48:33 <nh2> johnw: https://github.com/jwiegley/c2hsc/issues/15
12:48:38 <johnw> thanks!
12:48:54 <glosoli> Any ideas why would Emacs be failing at executing anything in Prelude prompt ? no error reported it just doesn't do anything
12:49:13 <jrmithdobbs> no helpful ideas, just: "emacs"
12:49:14 <Eduard_Munteanu> glosoli: did you change the ghci prompt?
12:49:26 <glosoli> Eduard_Munteanu: I did, but then I removed the change
12:49:30 <monochrom> yes jrmithdobbs, it is why when someone asks how I compare Haskell with most other languages, I can point out that and pretty much conclude :)
12:49:31 <nh2> vozz_: does it say something more specific, e.g. for what it is missing debugging symbols?
12:49:34 <Eduard_Munteanu> haskell-mode is confused by non-standard prompts.
12:49:40 <glosoli> Eduard_Munteanu: it has default prompt
12:49:45 <glosoli> and still does not function
12:50:11 <monochrom> of course, in principle, I could just point out http://www.vex.net/~trebla/haskell/prerequisite.xhtml#leibniz and be done, but that's too easy.
12:50:29 <petrie> How would I go from IO [String] to String?
12:50:42 <monochrom> please don't do that!
12:50:44 <johnw> petrie: you wouldn't
12:51:02 <Eduard_Munteanu> petrie: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
12:51:04 <levi> You might go from IO [String] to IO String, though.
12:51:23 <jrmithdobbs> peterhil: wrong question, the correct question is oriented on the function not the value, you really want to know how to go from String -> a to IO String -> IO a
12:51:25 <vozz_> nh2: "the flag -p requires the program to be built with -prof" and then some stuff about usage
12:51:42 <petrie> thanks Ill look into it
12:52:27 <jrmithdobbs> petrie*
12:52:42 <nh2> vozz_: can you try `cabal-dev configure --enable-library-profiling --enable-executable-profiling && cabal build` and then see if it works with the executable in `dist/build/...`?
12:53:39 <petrie> well basicaly I am reading lines in from a file and returning a list and its a IO [String] and in the function to randomly select an index its giving me an error
12:53:41 <vozz_> nh2: Doesn't work :(
12:53:49 <petrie> I am assuming the one getting the index is a pure function so its messing it up because of IO?
12:53:59 <vozz_> it compiles but same error when trying to run with +RTS -p
12:55:13 <petrie> http://pastebin.com/TYdX0FWv
12:55:29 <nh2> vozz_: can you try with plain cabal (or cabal sandboxes) instead of cabal-dev
12:55:30 <geekosaur> petrie: you need to use fmap or (>>=) to apply something to an IO action
12:56:11 <Eduard_Munteanu> petrie: given some 'IO A', you may only combine it with an 'A -> IO B' function. That's what (>>=) does.
12:56:23 <geekosaur> (an IO action is in effect a program that will run at some point not specified by you; you don't do things to the result, you register callbacks to be applied when the value becomes available)
12:57:13 <petrie> so I would [xs] >>= readQuotes?
12:57:31 <Eduard_Munteanu> If 'action :: IO A', 'action >>= \x -> ...' has 'x :: A' and the entire thing has 'IO Something' as the type.
12:58:01 <glosoli> Damn even reinstalled modes in Emacs
12:58:06 <glosoli> Still can't get prelude to spit out anything
12:58:07 <vozz_> nh2: What would be the command for just plain cabal?
12:58:10 <Eduard_Munteanu> That's the only meaningful way you can "get 'A' out".
12:58:15 <petrie> Hmm
12:58:27 <nh2> vozz_: replace `cabal-dev` by `cabal`
12:59:12 <vozz_> it builds but the exact same error. Is the binary the same one in dist/build/..?
12:59:22 <nh2> vozz_: yes
12:59:26 <Eduard_Munteanu> petrie: think about it... if you have an IO action producing some A (hence IO A), any combination of that and some other function must also be an IO action.
12:59:29 <nh2> vozz_: which package is it
12:59:43 <vozz_> It's something I wrote myself
13:00:05 <nh2> vozz_: is it uploaded somewhere so that I can try?
13:00:18 <petrie> Yeah makes sense
13:00:24 <Eduard_Munteanu> petrie: is that bit above clear enough?
13:00:25 <vozz_> No but I'll upload it somewhere
13:00:45 <petrie> just seems complicated for me to now get those lines returned from that function to my other one
13:01:27 <srhb> petrie: If you just want the lines, do { xs <- readQuotes ... } and manipulate xs in your do block.
13:01:40 <monochrom> >>= does that for you. it is not complicated.
13:01:44 <Eduard_Munteanu> petrie: 'getLinesFunction >>= \ls -> ...' has 'ls :: [String]' if 'getLinesFunction :: IO [String]'.
13:02:10 <monochrom> the do-notation also does the same. it can be translated to >>=
13:02:25 <rschulman> I want to take the result from getPOSIXTime and pass it to posixSecondsToUTCTime, but getPOSIXTime is in IO. Is there a way to get the value out of an IO monad and pass to a function in one?
13:02:31 <rschulman> <- doesn't seem to work in this situation
13:02:36 <Eduard_Munteanu> @undo { a <- x; f a }
13:02:37 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
13:02:42 <Eduard_Munteanu> @undo do { a <- x; f a }
13:02:43 <lambdabot> x >>= \ a -> f a
13:02:47 <shachaf> There is no "value in IO" so you can't "get it out".
13:02:52 <shachaf> But you can do what Eduard_Munteanu wrote.
13:03:03 <Eduard_Munteanu> @quote /bin/ls contains
13:03:04 <lambdabot> No quotes for this person.
13:03:05 <shachaf> Or you can use (fmap posixSecondsToUTCTime getPOSIXTime)
13:03:10 <Eduard_Munteanu> @quote shachaf /bin/ls
13:03:10 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:03:36 <vozz_> nh2: https://github.com/ollieh/bilgebot
13:03:51 <nh2> petrie: http://learnyouahaskell.com/input-and-output has some nice examples and explanations about what you are trying to do
13:04:17 <geekosaur> rschulman, ^^ you also should look at that
13:04:59 <petrie> thanks reading it now :)
13:05:00 <Eduard_Munteanu> shachaf: you should @quote yourself, seems quite appropriate for these questions :)
13:05:12 <rschulman> Yeah, I know about <- but I'm just seeing if there's a way to do it in one line without assigning to an intermediate variable. Looks like fmap might be what I'm looking for. Thanks!
13:05:14 <shapr> @quote Eduard_Munteanu
13:05:15 <lambdabot> Eduard_Munteanu says: [In response to "GHC can go jump out a window" and "GHC has already jumped out a window and flied and left you behind"] Yes, GHC even implements optimizations such as defenestration.
13:05:21 * shapr laughs
13:05:34 * monochrom always quotes himself
13:05:49 <srhb> My only quote has a spelling error. :<
13:06:13 <haasn> rschulman: (>>=)
13:06:19 <haasn> oh, or fmap, yes
13:06:50 <nh2> vozz_: what, on earth, there is a `ghc-prof-options`?? Why did nobody tell me
13:06:52 <shachaf> @quote monochrom quote
13:06:52 <lambdabot> monochrom says: * monochrom rubs @quote, and shachaf appears! he says, "what is your wish?"
13:06:56 <Eduard_Munteanu> (<$>) is often nice.
13:07:03 <shachaf> @quote monochrom quote
13:07:03 <lambdabot> monochrom says: Please quote me!
13:07:09 <srhb> Haha
13:07:13 <Eduard_Munteanu> :)
13:07:50 <vozz_> nh2: I found it from tons of googling trying to solve this :D
13:08:16 <ReinH> Ok, looks like getting ghc working on Mavericks was easier than I feared. Awesome.
13:08:59 <jrmithdobbs> ReinH: ya it builds fine, there's some rough edges on the shared lib stuff in 7.8 but not mavericks specific
13:09:12 <Kiryx> Hey, has anyone used haskell for programming competitions like Google Code Jam, Codeforces and such ?
13:09:34 <nh2> Kiryx: yes, code jam
13:09:37 <haasn> Kiryx: I'm sure plenty of people have
13:10:10 <Kiryx> I tried using python for some (Codeforces) and I stumbled into few problems which were flagged as "tough" for Python/Ruby and alike
13:10:39 <glosoli> Haskell Platform 7.8  not released yet ?
13:10:41 <Kiryx> i.e. C++ implementations ran faster for obvious reasons, thus Python users really had to take care of some optimizations to even compete
13:10:56 <Kiryx> resulting code wasn't really resembling python anymore
13:10:56 <Eduard_Munteanu> glosoli: you mean GHC 7.8?
13:10:59 <glosoli> yeah
13:11:12 <Eduard_Munteanu> Not last time I checked,
13:11:24 <Kiryx> nh2: I'm wondering whether you have similar experience with Haskell (I know it's faster Ruby/Python)
13:12:13 <glosoli> Eduard_Munteanu: any ideas what else could I do, to get  Prelude working in Emacs ?
13:12:22 <glosoli> Eduard_Munteanu; Reinstalled platform and all emacs modes
13:12:46 <glosoli> Pressing Return key just adds new line instead of executing anything
13:13:07 <Eduard_Munteanu> glosoli: does the ghci window have focus?
13:13:18 <glosoli> it does
13:13:34 <Eduard_Munteanu> glosoli: are you using Evil or some other vim emulation mode by chance?
13:13:45 <glosoli> No
13:14:05 <nh2> vozz_: seems to work for me; I do `cabal configure --enable-executable-profiling; cabal build; dist/build/bilgebot/bilgebot +RTS -p` and get "unable to load the image", so it's running
13:14:55 <nh2> vozz_: when you do a `cabal clean` and do what I wrote again, do you get the output `[1 of 1] Compiling Main             ( Main.hs, dist/build/bilgebot/bilgebot-tmp/Main.p_o )` ?
13:15:37 <vozz_> .o not .p_o but yeah
13:16:29 <vozz_> Still the same error with those exact commands
13:16:30 <monochrom> .o does not contain profiling stuff. .p_o does. if you don't find .p_o anywhere, you get no profiling
13:16:48 <nh2> Kiryx: never had a problem with performance in the code jam; if the algorithm is right, then even Ruby implementations will easily finish before the time runs out
13:17:01 <vozz_> ah.
13:17:03 <nh2> vozz_: it should say .p_o
13:17:20 <vozz_> So the configure step isnt working right?
13:17:30 <nh2> that means something like your cabal doesn't really call ghc with the options it should when getting --enable-executable-profiling
13:17:36 <nh2> vozz_: cabal --version
13:17:39 <glosoli> Yeah setting up emacs to function as something proper takes more time than reading a book.. damn that thing
13:17:43 <fizbin> @pl \f -> (\(y,z) -> f y z)
13:17:43 <lambdabot> (`ap` snd) . (. fst)
13:17:52 <vozz_> 1.16.0.2
13:17:56 <fizbin> I am disappointed, @pl
13:18:04 <fizbin> That's obviously uncurry.
13:18:31 <fizbin> @pl \f (x, y) -> f x y
13:18:31 <lambdabot> (`ap` snd) . (. fst)
13:18:34 <nh2> vozz_: try installing a newer cabal, `cabal install cabal-install` <- no kidding
13:18:39 <fizbin> At least it's consistent.
13:18:57 <srhb> fizbin: In what world is uncurry more readable than (`ap` snd) . (. fst)?
13:19:31 <fizbin> ...
13:19:34 <haasn> that's quite hässlich
13:19:47 <jrmithdobbs> fwiw neither is particularly legible
13:19:49 <jrmithdobbs> tbqh
13:21:39 <fizbin> @pl \f -> (\x (y,z) -> f x y z)
13:21:39 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .)
13:21:47 <fizbin> Okay, that's just silly.
13:21:54 <vozz_> nh2: Now it wont build again :D Could not find module `Data.Tree.Lens' Perhaps you haven't installed the profiling libraries for package `lens-4.1.2'?
13:22:13 <fizbin> @type flip flip snd . (ap .) . flip flip fst . ((.) .)
13:22:14 <lambdabot> (a -> a1 -> a2 -> b) -> a -> (a1, a2) -> b
13:22:18 <fizbin> @type (uncurry .)
13:22:20 <lambdabot> (a -> a1 -> b -> c) -> a -> (a1, b) -> c
13:26:23 <vozz_> nh2 any ideas?
13:27:11 <nh2> vozz_: ah, now we seem to get to the proper errors
13:27:49 <nh2> so now you are in the problem for that the people earlier on described solutions; apparently your older cabal just did things wrong with that --enable-executable-profiling flag
13:29:02 <nh2> vozz_: now you should do the following: mv ~/.ghc ~/.ghc.old, make sure that in ~/.cabal/config you have `library-profiling: True` (it is also useful te set `documentation: True`) and then do `cabal install --only-dependencies` in your project
13:29:15 <nh2> that should build all your deps with profiling enabled
13:29:39 * hackagebot libnvvm 1.0.0 - FFI binding to libNVVM, a compiler SDK component from NVIDIA  http://hackage.haskell.org/package/libnvvm-1.0.0 (seanprime7)
13:29:54 <nh2> vozz_: also, do you use ghc from the downloaded binary or from some linux distribution's package manager?
13:30:00 <vozz_> binary
13:30:19 <vozz_> and I just realised I had changed it from False to True but not uncommented it in the config file
13:30:22 <vozz_> wow.
13:31:05 <nh2> vozz_: happened to me as well
13:34:40 * hackagebot jsonrpc-conduit 0.2.4 - JSON-RPC 2.0 server over a Conduit.  http://hackage.haskell.org/package/jsonrpc-conduit-0.2.4 (GabrieleSales)
13:36:04 <skypers> hey
13:36:17 <Eduard_Munteanu> skypers: hi
13:36:33 <johnw> skypers: howdy
13:36:49 <skypers> :)
13:37:19 <skypers> it’s a soft night here, coding by the window, with a sweet wind :)
13:37:48 <bitemyapp> skypers: just got reading on a deck chair in front of the beach. I might open a door and code on the patio. :)
13:38:19 <skypers> I envy you
13:38:56 <jrmithdobbs> i wish it wasn't rainy over by the coast today or i'd go home and do the same ;p
13:38:58 <Eduard_Munteanu> Might explain why finance businesses are interested in Haskell. :)
13:39:18 <bitemyapp> skypers: Panama is nice, but I'm not here forever or anything.
13:39:29 <skypers> you’re there now
13:39:37 <skypers> you should be happy :)
13:39:40 * hackagebot purescript 0.4.13.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.13.1 (PhilFreeman)
13:40:50 <nh2> has anybody implemented something like Eclipse's "call hierarchy" for Haskell?
13:41:01 <nh2> finding the tree of all functions that call your function
13:41:12 <nh2> and finding the tree of all functions that are called by your function
13:41:41 <nh2> or, even more useful and what I want: finding all possible call paths between two functions
13:41:47 <Cale> nh2: It's not function level, but there's http://www.cas.mcmaster.ca/~kahl/Haskell/HsDep.lhs
13:41:50 <vozz_> nh2: it worked! thank you so so much
13:41:56 <Cale> (That's just module dependencies)
13:42:54 <nh2> vozz_: welcome
13:43:20 <nh2> Cale: thanks, but module level isn't enough in my case (one big file)
13:43:24 <Cale> http://hackage.haskell.org/package/SourceGraph
13:43:28 <Cale> seems to do what you want
13:43:44 <Cale> (I didn't know this existed before I just googled it)
13:45:12 <awestroke> I'm getting tired of juggling String, Text, ByteStrings and FilePath...
13:45:38 <Cale> FilePath is the same thing as String
13:45:51 <shachaf> One of these is not like the others.
13:46:02 <nh2> johnw: https://github.com/jwiegley/c2hsc/issues/15#issuecomment-39502466
13:46:03 <awestroke> Cale: o rly? http://lpaste.net/783182643565953024
13:46:04 <fizbin> Is there a command in ghci for "show me the definition of this instance"? For example, suppose I want to see the definition of Applicative for (->)
13:46:12 <shachaf> (That's ByteString, which isn't a sequence of characters.)
13:46:21 <jrmithdobbs> fizbin: :i
13:46:33 <shachaf> Prelude FilePath is a type synonym for String, but this is arguably a bug for POSIX.
13:46:41 <shachaf> fizbin: No. The best you can do is :i.
13:46:41 <Cale> Oh, I see
13:46:42 <Cale> yeah
13:46:50 <Cale> That wasn't the FilePath I was expecting :)
13:47:05 <nh2> Cale: i've used that in the past, isn't that only module deps as well?
13:47:11 <fizbin> jrmithdobbs: That doesn't show me the definition, unless there's something else I'm supposed to type.
13:47:12 <jrmithdobbs> shachaf: how is it a bug? because / isn't valid?
13:47:24 <johnw> nh2: if you can make a test case and fix it, you would be my hero :)
13:47:26 <Cale> no, the sample reports seem to include function level dependency graphs
13:47:32 <Cale> though, they can be quite a mess
13:48:19 <Cale> (just sticking a gigantic graph through dot tends to result in lots of unfollowable curves that get bunched up and cross at awkward angles)
13:48:28 <zipper> Uh I am getting a type related error while building the bittorrent cabal package. Here is the error and problematic file https://gist.github.com/urbanslug/9962533
13:48:50 <zipper> Haskell library code is always breaking, smh. GHC
13:49:26 <nh2> johnw: not sure if I can "fix" it since I have literally no understanding of what exactly is supposed to happen (I could delete that line being emitted of course, but no clue if that'll break anything)
13:49:44 <johnw> there's the rub
13:49:49 <johnw> i'll look into it
13:50:03 <nh2> Cale: yeah I just ran that thing on a 400 module code base, not nice to look at (nor useful)
13:51:01 <Cale> zipper: uh, are you sure that's the problematic file?
13:51:17 <Cale> zipper: The code which appears in the error message doesn't seem to appear in the file
13:52:04 <Cale> Actually, there's analogous code, but it doesn't match the error message
13:52:23 <Cale> Are you sure the version you're compiling is the version you pasted?
13:52:41 <zipper> Cale: The error pointed to that file
13:53:02 <zipper> Cale: lol I am not sure that the version I compiled is the version I pasted.
13:53:14 <jrmithdobbs> first step then: upgrade!
13:53:15 <jrmithdobbs> ;p
13:53:23 <zipper> I got that file from github and I couldn't see where the issue was because that was a data decalration.
13:53:41 <zipper> I was running a cabal install bittorrent
13:53:50 <zipper> jrmithdobbs: I should upgrade?
13:53:54 <nh2> johnw: I think we can't just delete it because people write things like standalone `typedef struct MyTypeImpl {...} MyType`
13:54:17 <nh2> johnw: but that's a different case from using an already declared struct like `typedef struct MyTypeImpl* MyType;`
13:55:18 <zipper> jrmithdobbs: You mean cabal update
13:55:25 <jrmithdobbs> zipper: yes
13:56:47 <zipper> jrmithdobbs: Yeah I got a warning that my list was 15 days old and I should update. I hope that fixes it.
13:57:17 <awestroke> anyone know what I can do about this? http://lpaste.net/783182643565953024 (expected Filesystem.Path.Internal.FilePath, got [Char])
13:57:44 <Cale> awestroke: Figure out how to construct a value of type Filesystem.Path.Internal.FilePath
13:57:50 <Cale> awestroke: which library is that?
13:58:31 <ReinH> I guess I should understand this whole Codensity thing. What should I read?
13:58:31 <awestroke> Cale: FSNotify, trying to use the eventPath method to extract path from an Event ---> http://hackage.haskell.org/package/fsnotify-0.0.11/docs/System-FSNotify.html#v:eventPath
13:58:45 <ReinH> Cale: halp?
13:59:01 <Cale> Edward has some articles in his blog
13:59:12 <johnw> nh2: so we'll need to remember which types we've omitted, and prefer the most defined one
13:59:23 <ReinH> Cale: of course he does: it has "co" in the name.
13:59:26 <dwcook> Is there any general notion of a difference type? e.g., where you would have diff :: T -> T -> Difference T and applyDiff :: T -> Difference T -> T where applyDiff a (diff a b) = b?
13:59:26 <ReinH> Cale: thanks
13:59:29 <jrmithdobbs> ReinH: edward's blog posts about it are the most coherent thing i've found
13:59:39 <user_> `12``1`2`1`h`j`jj`j`k
13:59:47 <Cale> http://hackage.haskell.org/package/system-filepath-0.4.7/docs/Filesystem-Path-CurrentOS.html
13:59:49 <ReinH> This is pretty good motivation for trying to understand codensity http://www.reddit.com/r/haskell/comments/224ogh/restricted_monads_for_free_using_codensity/
13:59:50 <nh2> johnw: or maybe it's enough to check if it is an actual struct declaration or just referencing its name
14:00:03 <johnw> nh2: true
14:00:19 <Cale> user_: ... meow?
14:00:55 <ReinH> I believe he is speaking to us in the ancient language of vim registers
14:01:15 <Cale> haha
14:01:18 <jrmithdobbs> too many `
14:01:20 <user_> tmux flipping
14:01:23 <ReinH> Although that doesn't seem to do anything interesting
14:02:20 <yogert> Hi, I'm using the Text.Regex.Posix package, and with the (=~~) operator i'd like to return an Either. This resulted in errors being thrown when a pattern didn't match
14:02:23 <awestroke> Cale: yay! thank you!
14:02:38 <yogert> I found this thread http://osdir.com/ml/haskell-cafe@haskell.org/2011-12/msg00851.html and I was wondering if anything has changed since then?
14:04:59 <jrmithdobbs> yogert: no that's still the current behaviour afaik
14:05:08 <Cale> yogert: I've begun to wonder whether regex-base and its children are an elaborate joke of some sort.
14:05:23 <yogert> ha why is that?
14:05:36 <yogert> things like this?
14:06:19 <Cale> Well, I feel that it really abuses type classes
14:07:00 <Cale> It's more perly than perl even attempts to be
14:07:13 <quchen> Is regex-base the thing that has overloaded return types?
14:07:18 <Cale> yeah
14:07:40 <Cale> Like, 20 or so different possible types for the result of a match
14:07:48 <hiptobecubic> Cale, it sucks.
14:08:06 <yogert> What would be a better design?
14:08:18 <Cale> The thing is, nobody actually uses regular expressions, so there's not much cause for people to fix it.
14:08:37 <quchen> They probably thought "overloading things with everything there is was a good idea in other languages, let's emulate that".
14:08:39 <Cale> (If you're a self-respecting Haskell programmer, you use parser combinators)
14:08:52 <hiptobecubic> yogert, return match types or something? Just pick a type.
14:09:32 <ReinH> Cale: also I assume many non-self-respecting haskell programmers do so as well
14:09:38 <Cale> heh
14:09:42 <silasm> Cale: I was thinking of making an ed clone. What would I do in that case?
14:09:42 <hiptobecubic> list of (Matchable a => Maybe a) where elements represent groups or something
14:09:44 * hackagebot HaRe 0.7.2.2 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.2.2 (AlanZimmerman)
14:10:02 <ReinH> Cale: I realize that's not how your implication worked but jokes
14:10:08 <nh2> Cale: but that is just because parser combinators are more expressive; when actually parsing a regular language, I can imagine that sticking to non-context-free (or even context-sensitive with what we have moste of the time) might be a better choice
14:10:09 <srhb> silasm: interact $ \_ -> "?"
14:10:27 <zipper> "Note: there is a new version of cabal-install available. To upgrade, run: cabal install cabal-install"
14:10:34 <zipper> I thought that that was funny
14:10:51 <ReinH> zipper: it is funny. We've all just seen it before. ;)
14:10:52 <Cale> silasm: Well, okay, if part of the specification of your program is to allow the user to provide regular expressions as input, then you need to look a bit harder
14:10:52 <silasm> srhb: heh, that took me a second. Good one.
14:11:05 <srhb> silasm: :-)
14:11:19 <ReinH> srhb: interact (const "WTF")
14:11:20 <[Coke]> Hello. I'm not a haskell developer, but pop in occasionally to try to keep Pugs (an older perl 6 implementation that targets haskell) running enough so we can keep running the spec test with it. Getting a runtime error after trying to switch to a new machine, was hoping someone could help me out: "this version of PCRE is compiled without UTF support". not sure how to interrogate cabal to find out what module I'm using here, or how to ask for one with utf sup
14:11:50 <srhb> ReinH: Only if you enable the longer error messages, and no one can remember the right incantation for that!
14:11:52 <[Coke]> (just saw the log URL, checking there...)
14:12:03 <silasm> srhb: H
14:12:04 <ReinH> srhb: indeed
14:12:07 <zipper> ReinH: haha props for that self contained-ness of cabal. It's like some guy who ran rm on rm and had major issues reinstalling rm
14:12:11 <srhb> silasm: Wow.
14:12:19 <bitemyapp> [Coke]: this is like getting a request on how to refuel a 1950s Cessna from a WWII vet living in the south pacific. Have you considered a walk on the wild(ly typed) side? :)
14:12:29 <bitemyapp> [Coke]: what distro is this?
14:12:30 <ReinH> zipper: also fun is `/bin/chmod -x /bin/chmod'
14:12:32 <Cale> [Coke]: it's unclear whether that's even necessarily a Haskell message
14:12:49 <[Coke]> https://github.com/perl6/Pugs.hs
14:13:08 <zipper> ReinH: lol how does one undo that? In a chroot?
14:13:10 <Cale> (or a message about a Haskell library anyway)
14:13:16 <[Coke]> bitemyapp: yah, it's getting on in years. I just hate to send the old girl to the farm.
14:13:35 <[Coke]> Cale: yes, I agree.
14:13:51 <bitemyapp> [Coke]: compile PCRe from scratch, include `--enable-utf8` in the configure line.
14:13:57 <bitemyapp> [Coke]: but you should learn Haskell :)
14:14:14 <bitemyapp> such as: ./configure --enable-utf8
14:14:15 <ReinH> zipper: by calling chmod() or you can invoke the loader directly, /lib/lb-linux.so /bin/chmod +x /bin/chmod
14:14:18 <[Coke]> bitemyapp: I'm still learning Perl 6. :P
14:14:24 <ReinH> (modulo its path on your platform)
14:14:33 <bitemyapp> [Coke]: Haskell will give you superpowers.
14:14:38 <geekosaur> [Coke] note that this is the C PCRE library.
14:14:41 <[Coke]> I learned barely enough haskell to make some minor changes to pugs, but that's as far as it's gone.
14:15:00 <[Coke]> ah, so I may just need to complain to my sysadmin. excelllllent.
14:15:14 <levi> The commit history of that Pugs repository has more recent activity than I'd have suspected.
14:15:25 <ReinH> zipper: also the loader used to be a way for exploiters to execute things in /tmp when it was mounted noexec. That has since been fixed in the kernel.
14:15:34 <geekosaur> audrey still keeps an eye on it to some extent, yes
14:15:50 <geekosaur> but there's no active development, just maintenance
14:16:09 <levi> Still, that's more love than a lot of old projects get.
14:16:12 * geekosaur keeps trying and bouncing; his haskell is apparently well behind audrey's
14:16:24 <zipper> ReinH: I don't know what the loader is. Describe the loader in more words so that I can at least google it.
14:16:50 <ReinH> zipper: http://linux.die.net/man/8/ld-linux
14:17:11 <bbloom> tinkering with :k in ghci: i grok the "*" kind, but I saw some mention of "?" and "??" and can't find that any more... what are those called? where should i look?
14:17:17 <Cale> What are people working on instead? A dependently typed perl implementation called pigs? :)
14:17:40 <geekosaur> rakudo, mostly, which targets parrot vm, jvm, and moarvm
14:17:57 <Cale> bbloom: They're certain unions of various unboxed kinds and *
14:18:03 <geekosaur> there's also a slowly bitrotting implementation called niecza which targets the CLR (.Net / mono)
14:18:04 <Cale> Let me dig up the chart
14:18:07 <bbloom> Cale: thanks
14:18:17 <geekosaur> bbloom, that sounds like an old ghc from before the BOX changes
14:18:21 <artyomkazak> bbloom: https://ghc.haskell.org/trac/ghc/wiki/IntermediateTypes#KindsareTypes
14:18:38 <bbloom> ah # makes sense immediately :-)
14:18:42 <geekosaur> they're magic kinds for unboxed values
14:18:49 <geekosaur> er, unboxed types
14:18:59 <geekosaur> (types of unboxed values, pedantically)
14:19:29 <bbloom> cool, thanks guys
14:19:30 <Cale> http://stackoverflow.com/questions/3034264/haskell-weird-kinds-kind-of-is
14:19:34 <Cale> found a copy of it here
14:19:48 <Cale> my train is stopping, bbiab
14:23:36 <bbloom> random, not-so-obviously-related follow up question: what would you call the kind of a non-type value, ie in a dependently typed setting?
14:26:17 <pavonia> bbloom: What is a non-type value?
14:26:46 <bbloom> i'm thinking like what would be the kind of some dependently typed thing where you had, for example, an integer in the type
14:27:17 <silasm> the kind of a type which depends on a term?
14:27:20 <pavonia> Nat probably
14:27:21 <geekosaur> a type level Integer is a type
14:28:03 <pavonia> :k 1
14:28:04 <lambdabot>     Illegal literal in type (use -XDataKinds to enable): 1
14:28:10 <[Coke]> rakudo may eventually target haskell or mono, also.
14:28:28 <bbloom> tried locally, i get:             1 :: GHC.TypeLits.Nat
14:28:28 <[Coke]> I'll assume this is a system pcre issue and see how far I get that way. Thanks, folks!
14:28:34 <bbloom> hm ok thanks
14:28:50 <pavonia> > {-# LANGUAGE DataKinds #-}
14:28:52 <lambdabot>  not an expression: `{-# LANGUAGE DataKinds #-}'
14:28:57 <pavonia> dammit :)
14:28:58 <[Coke]> and if anyone is interested in hacking on pugs, I'm happy to find some tasks that I expect are LHF for anyone who actually knows haskell. :)
14:29:30 <geekosaur> sadly I keep trying and failing :(
14:29:58 <geekosaur> considering how much work I do on xmonad, I think I can claim some Haskell chops even if I'm not really an expert
14:30:42 <[Coke]> you already know the LHF. :)
14:34:11 <ReinH> if I have a list of functions with disjoint domains, can I "union" them together so that the resulting function's domain is the union of all the individual funcitons?
14:34:49 <ReinH> like if I have f1 'a' = 'b'; f2 'b' = 'c'; and f3 _ = 'd', can I get a function g such that g 'a' = b'; g 'b' = 'c'; g _ = 'd'?
14:35:27 <shachaf> What's f1 'b'?
14:36:06 <ReinH> shachaf: er, these weren't disjoint, right. Let's say that they are accumulated "left to right" in the same way that haskell definitions are top to bottom.
14:36:12 <ReinH> so it would be 'c'
14:36:25 <shachaf> f1 'b' is 'c'?
14:36:28 <shachaf> Or an error?
14:36:28 <silasm> ReinH: you might be able to do it using a typeclass. I got linked a thread in #idris the other day where a guy was talking about union types though; that might interest you; I could try and find it again if you want.
14:36:34 <ReinH> shachaf: oh sorry, f1 'b' is an error
14:36:38 <ReinH> g 'b' is 'c', not 'd'
14:36:41 <ReinH> shachaf: I misread you
14:36:46 <shachaf> OK.
14:36:55 <shachaf> Then no, there's no way to do it, functions are opaque.
14:37:02 <shachaf> If you're willing to do evil spoon magic then it's easy.
14:37:03 <tapuu> If tryputtmvar returns false, does that guarantee that there was something in the tmvar?
14:37:12 <ReinH> shachaf: right, but I could do it with the codom being Maybe Char
14:37:13 <shachaf> But it's probably not the right answer.
14:37:19 <ReinH> by folding up with <|> or something?
14:41:25 <ReinH> oh sequence
14:43:41 <cdk> is there any way to see what Rep is generated by a derived GHC.Generics instance? for example on the wiki page http://www.haskell.org/haskellwiki/GHC.Generics it states that "data UserTree a = Node a (UserTree a) (UserTree a) | Leaf" becomes "type Rep a = U1 :+: a :*: UserTree a :*: UserTree a"
14:44:44 <cdk> for example, I'm interested in what "data T3 = X | Y | Z" becomes, I assume it's "type Rep a = U1 :+: U1 :+: U1" but I'd like to be able to see it, and other instances, for myself.
14:45:43 <shachaf> cdk: cd: You can use :kind! Rep T3 or something like that.
14:46:14 <haasn> Newer versions of Haddock can generate this information in the HTML output
14:46:20 <cdk> shachaf: awesome, that works!
14:46:33 <haasn> But I'm not sure if ‘Rep’ is actually visible, due to hidden types and stuff
14:47:06 <bergmark> ah cool, didn't know that
14:50:19 <haasn> Ah, yeah, the right hand side of ‘Rep’ is hidden in Haddock HEAD
14:51:20 <haasn> bergmark: How is ‘Rep’ actually used? Is the right hand side of it important to end users?
14:51:26 <haasn> (I've never used Rep)
14:52:13 <ReinH> shachaf: what is this "evil spoon magic" you speak of, out of morbid curiosity?
14:54:49 * hackagebot purescript 0.4.14 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.14 (PhilFreeman)
15:03:08 <BeardedCoder> Trying to install lifted-base into a sandbox and having issues with "Missing (or bad) header file: inlinable.h". Any ideas?
15:03:34 <bergmark> haasn: i'm using it in a few places but i can't remember the details :-( https://github.com/silkapp/generic-aeson/blob/master/src/Generics/Generic/Aeson.hs#L93
15:04:02 <flebron> Hi. So join . return = id, but return . join isn't it (i.e. []). Should I be thinking of join . fmap return = id?
15:05:16 <petrie> sorry for the million questions what is "Couldn't match expected type `[b0]' with actual type `IO [String]'" trying to say about my code http://pastebin.com/2wMqbSCx
15:06:13 <prophile> petrie: annotate main and getQuote with types and I suspect things will become clearer :)
15:06:14 <pavonia> petrie: What is hte type of getQuotes?
15:06:15 <geekosaur> you are again trying to treat an IO thing as a thing instead of using >>= to get at thing
15:07:14 <prophile> flebron: join . return = id and join . fmap return = id are both monad laws
15:07:22 <tapuu> If tryputtmvar returns false, does that guarantee that there was something in the tmvar?
15:07:29 <prophile> the other one being join . join = join . fmap join
15:07:29 <petrie> prophile: by adding the types?
15:07:32 <prophile> plus the laws for fmap
15:07:33 <flebron> prophile: But are they enough to, together with associativity of join, define a monad?
15:07:38 <petrie> geekosaur: like readQuotes >>= getQuote
15:07:39 <petrie> ?
15:07:40 <prophile> flebron: yup
15:07:44 <flebron> Thanks :)
15:07:57 <haasn> bergmark: Hmm, okay. I wonder if hiding the right hand side of ‘Rep’ instances in haddock is the right behavior
15:07:58 <flebron> The actual monoid is (>=>, return . id), correct?
15:08:08 <prophile> it's not a monoid
15:08:10 <prophile> it's a category
15:08:19 <prophile> and it's (>=>) and return :)
15:08:21 <flebron> (Where the objects are M Hask, i.e. the image of Hask under the monad
15:08:28 <flebron> Oh yes, return. Haha, .id. :)
15:08:35 <prophile> yurs
15:08:45 <geekosaur> petrie, roughly yes
15:08:48 <prophile> from what I recall (though I don't have an immediate source) it turns into five laws with return, join and fmap
15:08:54 <flebron> Well it'd still be a monoid right? I mean, there's an operation >=> which is associative with identity return.
15:08:55 <prophile> and two of them are free theorems
15:09:08 <petrie> Think I am going to have an aneurysm when it comes to IO
15:09:09 <petrie> :|
15:09:13 <prophile> flebron: no, because a monoid is a binary operation on one type
15:09:16 <haasn> flebron: (>=>) and (return) certainly form a Monoid, though
15:09:27 <flebron> Well the "type" here is the objects of Kleisli Hask
15:09:40 <prophile> then no
15:09:45 <prophile> because the types have to "line up"
15:09:51 <flebron> Oh, that's right.
15:09:55 <flebron> I can't >=> whatever I want.
15:10:04 <prophile> f >=> g where f is Int -> [Face] and g is Face -> [Horseman] doesn't make sense
15:10:10 <cdk> can I use generics to generate instances for class Cyclic g where
15:10:28 <haasn> newtype KleisliM m a = KleisliM (a -> m a)
15:10:41 <prophile> ^
15:11:06 <prophile> I'm surprised Endo isn't generalised to any category
15:11:25 <prophile> I'm guessing it's just that it's older than Data.Category being in base
15:11:42 <cdk> can I use generics to generate instances for class Cyclic g where gen :: g; rot :: g -> g, satisfying these semantics: data T3 = A | B | C; instance Cyclic T3 where gen = A; rot A = B; rot B = C; rot C = A?
15:12:09 <cdk> I've tried to work out the generic machinery myself, but I don't know how to write a generic rot.
15:13:04 <flebron> haasn: Is that used anywhere?
15:13:23 <petrie> ah works now geekosaur thanks!!
15:13:41 <haasn> flebron: I made it up. I don't know
15:14:04 <cdk> my base case (for U1) is rot U1 = U1, then if I recurse for (:+:), (:*:), M1 like rot (M1 a) = M1 (rot a), or (a :*: b) = rot a :*: rot b, eventually I hit the U1 base case, which gives results like rot A == A when I'd like rot A == B.
15:16:00 <shachaf> flebron: That's a monad law, yes.
15:16:04 <shachaf> flebron: Oops, was scrolled up.
15:16:38 <shachaf> haasn: (>=>) and return form many monoids, one for each type.
15:16:48 <flebron> Right, KleisliM as haasn wrote
15:17:30 <prophile> uh
15:17:30 <prophile> hm
15:17:35 <prophile> hrrm
15:17:50 <flebron> Is F C a common notation for the image of C under the functor F, where C is a category?
15:17:52 <prophile> shachaf: I'm not certain that's true actually
15:17:57 <flebron> Or should it be F_C?
15:18:10 <prophile> Identity Void for instance
15:18:19 <prophile> is uninhabited, so it can't possibly have an identity element
15:18:20 <cdk> here's a paste which should explain better than I can: http://lpaste.net/102211
15:18:30 <prophile> right?
15:18:38 <prophile> oh, wait, no, ignore me
15:18:56 <prophile> it'd be Void -> Identity Void which is clearly inhabited
15:19:09 <flebron> By exactly one function, right?
15:19:16 <prophile> yup
15:21:36 <shachaf> prophile: That's OK. Still a monoid, because of what you said.
15:22:08 <prophile> isomorphic to the monoid for () if I'm not mistaken
15:23:23 <shachaf> Since Void -> Identity Void has just one inhabitant, yes.
15:23:27 <benmachine> note that Endo Void has a monoid instance
15:24:29 <benmachine> flebron: I don't think I've seen that, though I'd understand what it meant if I did (re: F C)
15:24:35 <benmachine> flebron: however I'd be inclined to prefer im F
15:24:44 <benmachine> F C is too overloady
15:24:47 <Taneb> Also see Data.Monoid.Endomorphism in monoid-extras, makes an Endo-like monoid from any category
15:24:59 <benmachine> you have to work out what operation is going on by what kind of thing C is
15:25:10 <shachaf> newtype Endo k a = Endo (k a a)
15:25:31 <flebron> benmachine: How would you write {f \in C | A \in C, B \in C, f :: a -> m b}?
15:25:46 <flebron> i.e. Hom_{Kleisli_m}
15:25:49 <shachaf> benmachine: Or you can just define functors to map arrows and forget about objects.
15:26:05 <benmachine> shachaf: yeah but that's kind of silly
15:26:16 <shachaf> I'm not sure what conversation you're talking about so I'm probably just saying things.
15:26:23 <shachaf> It's only moderately silly.
15:26:35 <benmachine> shachaf: that is also my technique
15:26:42 <shachaf> I like these kinds of definitions. You can do a similar thing for natural transformations.
15:26:50 <shachaf> (Define components for arrows rather than for objects.)
15:27:01 <benmachine> shachaf: the reason I think it's silly is because you can't really get by without thinking about objects
15:27:08 <benmachine> you can not make them a separate thing and just talk about identities
15:27:11 <lispy> cdk: I think you have to do something differently in the M1 case
15:27:16 <haasn> augur: Was it you who was really interested in ImplicitParams not too long ago? I just found http://www.nand.wakku.to/base/src/GHC-IP.html which I thought was really curious, I did not know IP is implemented that way
15:27:28 <benmachine> but that seems to me like just a different way of talking about objects
15:27:49 <benmachine> flebron: hmm. not sure that it's come up much
15:27:59 <haasn> prophile: ignoring _|_
15:28:22 <benmachine> flebron: sets are overrated, after all :)
15:28:24 <flebron> And (sorry for the dumb notation question) how do people usually denote the identity functor?
15:28:25 <cdk> lispy: I forgot the M1 instance in my paste, please refresh.
15:28:42 <benmachine> flebron: there is an annoying amount of variation
15:28:51 <benmachine> id_C where C is a category, is one way
15:28:55 <benmachine> also 1_C
15:29:16 <lispy> cdk: thanks.
15:29:17 <shachaf> benmachine: Yes, it's all just different ways of talking or thinking about things.
15:29:18 <lispy> cdk: grot (M1 a) = M1 (grot a)
15:29:23 <benmachine> which is extra fun when you take C to be the terminal category, sometimes written 1
15:29:29 <flebron> :s
15:29:38 <lispy> cdk: that needs to do something differently, because that's where you have access to the data constructor
15:29:50 <benmachine> and then once you have 1_1 the identity functor on it, there is of course the identity natural transformation on that...
15:30:10 <benmachine> i.e. 1_{1_1}
15:30:19 <benmachine> flebron: I do not defend this notation, merely inform you of it :P
15:30:31 <benmachine> I think id is probably a better idea
15:30:41 <shachaf> "I do not defend this notation, merely find edge cases in it to confuse you with."
15:30:47 <flebron> Haha
15:30:49 <benmachine> yes, precisely
15:31:39 <benmachine> shachaf: I think there are better and worse ways of talking/thinking about things
15:31:44 <ReinH> benmachine: is it 1's all the way down?
15:31:58 <lispy> cdk: something like grot (M1 a) = M1 (next a), where next a looks at the constructor details (like conName) and goes to the next one
15:32:03 <benmachine> ReinH: that was as far as I ever got, never did higher category theory
15:32:07 <ReinH> benmachine: seeing as how functors form a category?
15:33:11 <benmachine> ReinH: homotopy gives you categories with structure like that which goes all the way down
15:33:16 <benmachine> homotopies between homotopies, etc.
15:33:24 <ReinH> benmachine: that's a thing I don't know yet but I believe you :)
15:33:32 <shachaf> benmachine: Right, exactly.
15:33:32 <benmachine> ReinH: I only barely know it :P
15:33:37 <cdk> lispy: how to I access the constructor details with M1? I don't see an instance of Constructor for M1.
15:33:45 <cdk> s/to/do
15:34:23 <lispy> cdk: I'm not very good with Generics, but I think you need type C1 = M1 C
15:34:50 <lispy> cdk: then i think you use conName . unM1
15:36:30 <lispy> cdk: I also suspect you'll need to map the constructors to integers (and back) to get the cycling to work
15:37:39 <lispy> cdk: Otherwise, I don't know how you can tell which constructor is "next"
15:44:35 <flebron> Say I told you a functor F has a n.t. sigma :: (F a, F b) -> F (a, b). What do you need to ask additionally for F to be an applicative?
15:45:11 <shachaf> Does "(x,y)" mean a categorical product?
15:45:19 <shachaf> (Or are you just talking about Haskell, or what?)
15:45:22 <flebron> Err, sorry, that's not the sigma I wanted. I meant sigma :: F (B^A) -> (F_B)^(F_A).
15:45:41 <flebron> That is, say I told you there's a sigma that shows how F behaves wrt exponents in a cartesian closed category.
15:45:53 <flebron> What else do you need to ask (of sigma or otherwise) to conclude F is applicative?
15:46:41 <flebron> (I'm trying to see what the easiest way for a math guy to understand applicative is :))
15:51:54 * flebron is seeing the diagrams and finding they're not _terrible_, at least when it's an endofunctor and the monoidal operation is just (,) :p
15:57:41 <mizu_no_oto> I'm currently have some trouble cabal installing lens; here is the error I'm getting: http://lpaste.net/102214
15:58:55 <mizu_no_oto> edwardk is offline, but has anyone else had trouble with lens?
16:02:42 <zipper> Uh how come cabal update tells me to update cabal and does so successfully but when I do and run cabal update again it's like it still tells me to run cabal install cabal-install
16:02:52 <indigo> zipper: Put ~/.cabal/bin in your PATH.
16:03:41 <erisco> mizu_no_oto, I do not have lens installed so I'll give it a go
16:05:10 <zipper> indigo: It is bruh
16:05:12 <erisco> mizu_no_oto, try 'cabal update' because lens it at 4.0.5
16:05:34 <zipper> indigo: I'm going to try update the system itself
16:05:44 <zipper> indigo: pacman -Syu
16:06:35 <srhb> zipper: It has to be before the global one
16:06:48 <srhb> Or is it after.
16:06:53 <srhb> The opposite of what you have now. :P
16:08:44 <zipper> srhb: Uh yeah ~/.cabal/bin path for executables in my path
16:08:51 <srhb> zipper: Before the global one.
16:09:06 <zipper> I shall put it at the beginning and try again
16:09:20 <geekosaur> also don't actually use ~
16:09:43 <zipper> with PATH=~/.cabal/bin:$PATH
16:09:53 <zipper> geekosaur: ~ has never given me issues before
16:10:00 <zipper> but I'll take your advise
16:10:10 <geekosaur> zipper, it behaves ... strangely
16:10:18 <geekosaur> specifically it works in bash. ONLY.
16:10:26 <geekosaur> non-shells won't handle it
16:10:37 <geekosaur> this leads to weird failures
16:11:24 <geekosaur> (unless bash has finally been changed to expand it before setting it in the environment)
16:11:49 <zipper> geekosaur: Works in bash for me
16:12:01 <zipper> geekosaur: Are you one of those zsh users? :)
16:12:05 <geekosaur> I see I spoke over your head
16:12:19 <geekosaur> let me repeat. it works in bash, it works ONLY in bash
16:12:24 <geekosaur> ~ is a SHELL construct
16:12:34 <geekosaur> arbitrary programs do not know what to do with it
16:12:47 <geekosaur> this means everything works until you need a random program to pay attention to it and then it fails
16:13:13 <zipper> geekosaur: I get it now
16:14:31 <zipper> Should I permanently change the position of ~/.cabal/bin in my path?
16:14:44 <geekosaur> if you want it to be used before other stuff, yes
16:26:56 <DarkFox> How do you view a number without eNN?
16:27:27 <zipper> How do you guys update your ~/.cabal/bin binaries?
16:28:12 <DarkFox> zipper: rm -rf .cabal .ghc; cabal update; cabal install A B C D. :D
16:28:15 <DarkFox> zipper: One method
16:28:39 <seanparsons> Mine's pretty similar to that.
16:28:49 <DarkFox> zipper: I also suggest using cabal-dev so you can use whatever versions you need in whereever you need any specific thing.
16:29:03 <DarkFox> seanparsons: install -j A B C D ? :P
16:29:19 <seanparsons> I've got E as well.
16:29:27 <DarkFox> Ah
16:29:28 <DarkFox> :P
16:30:08 <DarkFox> Cabal: Cabal is not a package manager!
16:30:10 <zipper> DarkFox: That's crazy
16:30:14 <DarkFox> zipper: :D
16:30:22 <DarkFox> zipper: There has to be a better way
16:30:30 <zipper> Maybe I now have an idea for next years GSoC
16:30:33 <DarkFox> Just not as publically known as the rm alternative. :P
16:30:40 <DarkFox> zipper: Hehehe
16:30:51 <zipper> DarkFox: Gentoo finds a way to update using the latest sources
16:30:52 <srhb> Isn't cabal-dev basically replaced by the new sandboxing in cabal?
16:31:00 <zipper> So I guess haskell can to
16:31:00 <DarkFox> srhb: Probally
16:31:02 <zipper> *too
16:31:12 <DarkFox> srhb: I wasn't aware of this update. I guess it was merged in then.
16:31:28 <athan> srhb: I think so, it think that it's a superset of functionality
16:31:40 <athan> Hey yall, what's "deamortization" mean?
16:31:41 <athan> :P
16:31:42 <DarkFox> Indeed
16:32:01 <DarkFox> By chance does it take anything from ~/.cabal in the case the version you're compiling is exact?
16:32:15 <DarkFox> I.e. same compile flags and version -> don't re-download and re-compile!
16:32:17 <seanparsons> In my case I have a script that installs all the binaries and then annihilates all the dependencies so that I have no libraries installed into my home folders.
16:32:35 <DarkFox> seanparsons: Nice
16:32:35 <athan> DarkFox: Yeah, I've heard use portage > cabal
16:32:43 <zipper> athan: lol
16:32:44 <DarkFox> portage?
16:33:03 <zipper> DarkFox: It's gentoos package manager
16:33:04 <athan> gentoo's package manager
16:33:06 <athan> yeah
16:33:07 * DarkFox reads that and thinks either FreeBSD or Gentoo, but neither sound right.
16:33:15 <athan> it's a decendant!
16:33:15 <DarkFox> Yea; hat. :P
16:33:18 <zipper> athan: but cabal is not a package manager you know.
16:33:23 <athan> mhmmm
16:33:23 <zipper> So unfair comparison
16:33:27 <DarkFox> I was thinking of portmaster for FBSD
16:33:29 <athan> it's hard to describe what it is
16:33:32 <DarkFox> pkg-ng \o/
16:33:42 <athan> it's more of a computer-setter-up-er
16:33:51 <athan> or a development tool
16:33:55 <athan> for a unified environment
16:34:03 <athan> *in a unified environment
16:34:22 <zipper> I got some old packages that is making it impossible for me to build a package.
16:34:32 <zipper> I am thinking cabal clean might help
16:34:36 <athan> but... sorry to change the subject... what's amortization mean? :P
16:34:38 <athan> anyone know?
16:34:49 <athan> I have a feeling it has to deal with the descrete caching of a program
16:34:53 <athan> discrete*
16:35:03 <athan> zipper: good idea!
16:35:07 <zipper> I ran cabal install bittorrent but even after running cabal update I am still getting the old error before I ran cabal update
16:35:10 <athan> I'm always in that issue haha
16:35:15 <DarkFox> Cabal is a partial package manager that will allow you to install / compile libraries and binaries; but it doesn't handle update-trees.
16:35:26 <athan> hmm!
16:35:33 <athan> I feel like it could be interpreted
16:35:34 <athan> like
16:35:43 <athan> if the entire working program was determinable
16:35:47 <athan> and measureable
16:36:03 <athan> it could orchestrate a working program out of dependant libraries
16:36:13 <athan> isn't that what nix is like?
16:36:17 <athan> but pure?
16:39:28 <zipper> Could anyone help with the following cabal install issue: https://gist.github.com/urbanslug/9962533
16:42:08 <zipper> Cale: Hey you around?
16:42:23 <fizbin> There isn't any common infixl abbreviation for \a b -> a <*> pure b, is there?
16:42:49 <hpc> :t \a b -> a <*> pure b
16:42:50 <lambdabot> Applicative f => f (a -> b) -> a -> f b
16:43:00 <hpc> @hoogle f (a -> b) -> a -> f b
16:43:01 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
16:43:02 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
16:43:02 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
16:43:10 <hpc> :(
16:43:50 <Cale> zipper: hey, yeah, I'm just writing an email
16:43:54 <shachaf> There's an Applicative law for it.
16:44:03 <fizbin> Right, so technically that doesn't even need Applicative; you can write it as (\a b -> fmap ($ b) a) and just use Functor.
16:44:04 <shachaf> u <*> pure y = pure ($ y) <*> u
16:44:11 <shachaf> Which in turn is what you wrote.
16:44:17 <fizbin> Right.
16:44:33 <zipper> Cale: I updated cabal-install and ran cabal update but I still get the same error
16:44:38 <fizbin> But no common abbreviation. Okay; bummer.
16:45:08 <zipper> Cale: The error with installing the bittorrent package
16:45:27 <zipper> A most weird error that shows up in a data decaration
16:45:57 <fizbin> I don't suppose there's a language extension that allows you to stick a infixl declaration in a where clause, is there?
16:47:52 <fizbin> Or wait. Is that maybe always allowed?
16:48:00 <shachaf> No extension.
16:48:02 <shachaf> > let (+) :: Int -> Int -> Int; (+) = (-); infixr + in 5 + 3 + 2
16:48:04 <lambdabot>  4
16:48:44 <Cale> zipper: hmm
16:49:08 <Cale> zipper: and the code in the error message still doesn't match the code you're compiling?
16:55:44 <zipper> Cale: Yeah I shall add the whole error just in case anyone wants to see it
16:55:56 <zipper> I shall start an issue on github
17:00:14 <fizbin> Is there a canonical data type with multiple (say, four or more) constructors that people use in examples?
17:07:28 <schlegel> Hey everyone, how are you today?
17:13:14 <zRecursive> fine, and you ?
17:15:06 * hackagebot purescript 0.4.15 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.15 (PhilFreeman)
17:21:29 <sinelaw> miao
17:26:09 * fizbin just figured out that in this function where he needs two infixl operators with different precedence, he's not doing any math and therefore can just redefine + and * in a where clause...
17:34:06 <meretrix> How much memory do you think it should take to compile a 100K line module?
17:41:44 <south> Is there a way to add a monoid constraint to (>>=)?
17:42:04 <south> i.e. (>>=) :: Monoid b => m a -> (a -> m b) -> m b
17:42:26 <south> I have a situation where I need the monoid instance for the Monad instance to work
17:43:08 <prophile> no, because the monad needs to work on all types
17:43:17 <Iceland_jack> This is a known problem called the ‘constrained-monad problem’
17:43:19 <prophile> but you can do a trick using the codensity monad to work around that
17:43:40 <south> Damn. I'll look into that Iceland_jack
17:43:52 <south> Any writing about that approach prophile?
17:44:15 <prophile> http://hackage.haskell.org/package/kan-extensions-4.0.2/docs/Control-Monad-Codensity.html
17:44:28 <prophile> the basic idea is you turn your type from m a to (forall b. (a -> m b) -> m b)
17:44:43 <prophile> which is always a monad, for any m
17:45:01 <south> Sort of like a Free monad?
17:45:06 <ReinH> Because Kan extensions. Or something.
17:45:12 <ReinH> I'm still reading that part.
17:45:33 <south> (without the Functor constraint)
17:45:38 <prophile> south: I can see what you mean, but actually no
17:45:45 <ReinH> prophile: Er... yes?
17:45:47 <benzrf> the tyrrant of the javascripters has gone on long enough!!!
17:45:49 <ReinH> south: http://comonad.com/reader/2011/free-monads-for-less/
17:45:49 <c_wraith> more like Coyoneda converts any type into a functor.
17:45:53 <benzrf> today is the day that i propose HSDSN:
17:45:57 <benzrf> haskell data structure notation!!!
17:45:59 <c_wraith> err.  Any type with the correct kind.
17:46:04 <benzrf> screw json its WEAKLY TYPED
17:46:08 <prophile> what c_wraith said
17:46:12 <benzrf> *dynamically
17:46:13 <ReinH> c_wraith: but that gets you a free functor, not a free monad?
17:46:28 <c_wraith> ReinH: it's not free.  It's just a functor.
17:46:29 <south> c_wraith: I don't know what that means, but I can see the parallel
17:46:40 <ReinH> c_wraith: right
17:46:58 <c_wraith> It's like..  the obvious silly way to convert *anything* into a functor.
17:47:30 <c_wraith> data Coyoneda f a where Coyoneda :: (b -> a) -> f b -> Coyoneda f a
17:47:40 <c_wraith> Pack the value up with a conversion function!
17:47:44 <c_wraith> instance Functor!
17:47:46 <ReinH> heh
17:47:51 <south> Neat
17:47:51 <south> !
17:48:01 <c_wraith> *instant* Functor, even
17:48:06 <south> This is frustrating because I'm *so close* to a true Monad
17:48:08 <prophile> combine it with free monads and you get operational
17:48:53 <prophile> ReinH: when's the next haskellcast coming up?
17:49:40 <bitemyapp> prophile: "how's that phD thesis of yours coming along?"    "you done with that novel yet?"
17:50:27 <prophile> bitemyapp: :)
17:51:10 <bitemyapp> prophile: I don't like bumming out people that do creative/intellectual work so I try to avoid asking pointed questions
17:51:34 <bitemyapp> prophile: and instead exhibit enthusiasm for their work and offer feedback if it seems desired
17:52:04 <prophile> a fair approach, I withdraw the question
17:52:15 <bitemyapp> prophile: reminds me of the George RR Martin tweet, where two days after he had released one of his (typically long) books somebody had already finished it and sent him an email asking when the next one was coming along.
17:52:56 <bitemyapp> years of work consumed in 48 hours followed by an email asking for more. Which is flattering in a way, but yeah, people that do work like that are usually under a lot of internal pressure already to produce :)
17:53:13 <bitemyapp> prophile: unless you've gone through it yourself, it's hard to empathise/know.
17:53:21 <prophile> that's true, but the haskellcast has been at ~1 month intervals previously
17:53:26 <prophile> and it's been about a month since the last one
17:53:44 <bitemyapp> I don't think it has a guaranteed schedule.
17:53:50 <prophile> of course not
17:57:14 <south> Is there a way to put a constraint on a data type?
17:57:22 <haasn> prophile: in the case of Set, isn't that pretty inefficient?
17:57:24 <south> Like only permit Binary Search Trees
17:57:24 <haasn> re: codensity monad
17:57:26 <haasn> c_wraith: instant instance!
17:57:28 <haasn> south: yes no sort of
17:57:29 <south> with actual orderable data
17:57:35 <prophile> haasn: yeah, it is
17:58:06 <haasn> prophile: http://www.haskell.org/pipermail/haskell-cafe/2013-April/107607.html
17:58:09 <haasn> oleg gave an efficient implementation, though
17:58:15 <prophile> oh, swish
17:59:59 <south> haasn: Same thing, Codensity Monad?
18:00:27 <haasn> south: what are you asking?
18:00:55 <south> haasn: In order to place a constraint on a full data type, the approach is the same?
18:01:18 <south> i.e. I should use Codensity?
18:01:38 <haasn> south: depends on what you want
18:01:46 <haasn> do you want the constraint because you want (>>=) to be constrained?
18:02:14 <south> haasn: In the case of a Binary Search Tree, you need Ords to populate it, so what about in that case?
18:02:21 <south> haasn: Maybe that's too vague
18:02:37 <bitemyapp> south: you'd constraint the functions.
18:02:41 <bitemyapp> constrain*
18:02:51 <south> bitemyapp: But you can't do that if you want a Monad instance
18:03:01 <south> bitemyapp: Which is blatantly clear if Ord was implicit
18:03:34 <haasn> there's no way out without a construction like the construction like SetMonad provides
18:04:03 <haasn> you can't put a constraint on the data type itself
18:04:13 <haasn> just on the constructor, but then you can't implement monad because you don't have the constraint available
18:04:17 <haasn> (still)
18:04:46 <south> haasn: Ah okay, thanks
18:04:54 <flebron> So, bibliography suggested to understand functor, applicative, and monad? So far I have the typeclassopedia, LYAH, mcbride & wadler's papers, and dan piponi's "you could have invented monads". Am I missing anything big?
18:05:16 <haasn> (there is a deprected and removed feature that did actually allow you to put a constraint on the data type itself, but that *still* required a dictionary to actually even mention the type in a type signature)
18:05:19 <south> haasn: I guess it makes sense, it's not exactly a real Monad if it has a constraint
18:05:23 <haasn> (which simply doesn't unify with (>>=))
18:05:38 <haasn> not unify
18:05:45 <haasn> but.. I can't think of a better word for it
18:05:49 <haasn> south: yeah
18:05:53 <haasn> south: return id -- ?
18:07:34 <south> Thanks for your help haasn
18:07:48 <south> Gonna head out for the night, see you guys later
18:11:26 <ReinH> prophile: soonish
18:11:36 <prophile> cool
18:15:01 <t4nk626> @pl \a b->(3*)$a+b
18:15:01 <lambdabot> ((3 *) .) . (+)
18:16:48 <t4nk626> @pl \k x-> let r = f k x in if r == reverse r then k else 0
18:16:49 <lambdabot> ap ((.) . flip flip 0 . flip (if' . ap (==) reverse)) f
18:18:23 <t4nk626> @pl \k x-> let r = f x k in if r == reverse r then k else 0
18:18:24 <lambdabot> ap ((.) . flip flip 0 . flip (if' . ap (==) reverse)) (flip f)
18:27:22 <mm_freak> hi there
18:27:38 <mm_freak> i have a constructor of this form:  X (f a)
18:27:45 <mm_freak> where most of the type f = (,) b
18:28:00 <mm_freak> is there a way to tell GHC to rewrite this to:  X b a?
18:28:25 <mm_freak> for every instance where it is statically known that f = (,) b
18:28:42 <mm_freak> oh, btw, it's X !(f a)
18:30:15 * hackagebot pipes-safe 2.1.0 - Safety for the pipes ecosystem  http://hackage.haskell.org/package/pipes-safe-2.1.0 (GabrielGonzalez)
18:40:16 * hackagebot elm-repl 0.2.2 - a REPL for Elm  http://hackage.haskell.org/package/elm-repl-0.2.2 (EvanCzaplicki)
18:44:26 <haasn> How does safe haskell interact with GHC_OPTIONS (or whatever that's called)?
18:44:44 <haasn> like can I use {-# GHC_OPTIONS -XEnableAllTheUnsafeThings #-}
19:10:19 * hackagebot thyme 0.3.2.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.2.0 (LiyangHu)
19:15:51 <[swift]> haasn: i was curious so i googled and wound up here: https://ghc.haskell.org/trac/ghc/wiki/SafeHaskell/SafeCompilation
19:16:42 <haasn> [swift]: ah okay, cool
19:20:04 <ezrios> is there some way to negate a match in parsec?
19:20:31 <ezrios> I want to say that a message body is a number of lines, ended by EOL, where each line does not begin with "commit"
19:23:06 <mm_freak> ezrios: consume "commit", then fail
19:23:23 <mm_freak> string "commit" *> empty <|> p
19:23:29 <mm_freak> where p is the succeeding parser
19:23:43 <mm_freak> oh…
19:23:47 <mm_freak> try (string "commit") *> empty <|> p
19:23:49 <mm_freak> that way
19:23:59 <mm_freak> notice that the 'empty' is outside of the 'try'
19:24:00 <erisco> is it possible to declare infix constructors that are not all symbols?
19:24:09 <erisco> sorry, infix types
19:24:27 <mm_freak> > Left 3 :: Int `Either` String
19:24:28 <lambdabot>  Left 3
19:24:37 <erisco> oh thanks
19:25:21 <pavonia> mm_freak: Is it necessary to have empty outside of try?
19:25:47 <mm_freak> pavonia: yes:  if the string matches only partly, then it should fail without consuming, so that (<|>) tries p
19:26:06 <mm_freak> but if it matches in full, it should be consumed, so the 'empty' fails /after/ consumption
19:26:12 <mm_freak> then parsec's (<|>) will not try p
19:27:40 <pavonia> Ah, right
19:34:15 <ezrios> @hoogle empty
19:34:16 <lambdabot> Control.Applicative empty :: Alternative f => f a
19:34:17 <lambdabot> Data.Text.Array empty :: Array
19:34:17 <lambdabot> Text.Html.BlockTable empty :: BlockTable a
19:34:20 <ezrios> hum
19:43:00 <tapuu> Why doesnt ContT have a monadcatch instance?
19:46:55 <ezrios> "couldn't match expected type ByteString with actual type Bystring"
19:47:01 <ezrios> s/Bystring/ByteString
19:47:02 <ezrios> woo
19:49:19 <kfish> ezrios, different bytestrings?
19:50:28 <ezrios> kfish: yeah, one was lazy :/
19:53:55 <pavonia> Is GHC.Word.Word16 different from Data.Word.Word16?
19:56:02 <tapuu> Is there a way to catch an IO exception in a ContT () IO ?
19:57:02 <ezrios> woo it works
20:00:25 * hackagebot free-game 1.0.5 - Create games for free  http://hackage.haskell.org/package/free-game-1.0.5 (FumiakiKinoshita)
20:05:26 * hackagebot elm-get 0.1.1 - Tool for sharing and using Elm libraries  http://hackage.haskell.org/package/elm-get-0.1.1 (EvanCzaplicki)
20:09:36 <tapuu> Why doesnt cont have a monadwriter instance?
20:10:56 <athan> tapuu:  :)
20:11:05 <athan> tapuu: this is a sign of progress
20:11:28 <athan> I think there was a recent change in base's api
20:12:33 <athan> for instance, I can't get usb-safe installed because it depends on Control.Monad.IO.Control, which doesn't exist in base 4.6.x
20:12:43 <athan> which is drastic, in my opinion
20:12:49 <athan> :/
20:13:06 <athan> but! It doesn't mean that we can't still catch up!
20:13:27 <athan> what version are you using, tapuu?
20:15:26 <tapuu> I'm using GHC 7.8 RC2 and the latest version of mtl
20:15:26 <tapuu> Latest version of all libraries really
20:15:26 <tapuu> Monadlib has writer instances for contt, why doesnt mtl
20:15:26 <athan> :/
20:15:29 <athan> go for it!
20:15:36 <athan> pull request it-up!
20:15:41 <athan> yo!
20:15:43 <tapuu> It has a monadstate, surely if monadstate is possible then monadwriter cant be too hard?
20:15:52 <athan> I agree
20:16:00 <tapuu> I thought WriterT was a subset of StateT or something like that
20:16:13 <athan> @src cont
20:16:14 <lambdabot> Source not found.
20:16:26 <athan> I don't think it is yet
20:16:39 <tapuu> I have no idea how @src works :)
20:16:39 <athan> 7.8's big feat was Functor a => Applicative a
20:16:49 <athan> :)
20:17:01 <tapuu> Isn't Applicative a => Monad a goign to happen soon?
20:17:06 <athan> what are you making? If you don't mind me asking :P
20:17:14 <athan> it might already be
20:17:16 <copumpkin> athan: no it wasn't :P
20:17:20 <tapuu> athan: a server for a multiplayer game
20:17:30 <athan> copumpkin: BLAST
20:17:34 <athan> copumpkin: WHYYYYYYYY
20:17:40 <athan> HELL YEAH!
20:17:42 <athan> me too!
20:17:58 <copumpkin> athan: Functor f => Applicative f has always been the case
20:17:58 <athan> I'm trying to use the web + websockets for mine
20:17:59 <flebron> So not to start a flame war or anything, but, if I'm already somewhat comfortable with Haskell, will OCaml add stuff to my brain repertoire? Or should I learn a lisp instead?
20:18:10 <copumpkin> flebron: yes it will
20:18:22 <copumpkin> good modules/functors/etc.
20:18:34 <athan> it's gonna be !
20:18:37 <copumpkin> polymorphic variants might be interesting but I'm not as enthusiastic about those
20:18:37 <athan> lol
20:18:39 <athan> whoops
20:18:43 <flebron> Is there a canonical morphism Hask -> OCaml in the category of learning materials?
20:18:53 * copumpkin has no clue :)
20:18:55 * oubiwann whispers "also learn a lisp" ...
20:19:01 <copumpkin> yeah, also learn a lisp
20:19:06 <copumpkin> except not elisp
20:19:11 <athan> hahaha
20:19:13 * oubiwann chuckles
20:19:13 <flebron> I was thinking Scheme?
20:19:22 <oubiwann> Racket's definitely nice
20:19:25 <jle`> tapuu: 7.10 or so
20:19:26 <athan> sicp
20:19:26 <flebron> Though I'm not sure - is Scheme used seriously nowadays?
20:19:33 <flebron> Or is it mainly educational?
20:19:39 <tautologico> scheme/racket is cool, read EOPL (2nd ed. is best)
20:19:43 <athan> jle: :)
20:20:01 <athan> it's mainly educational in my opinion
20:20:04 <oubiwann> you could always hit Erlang and Lisp in one go with LFE ;-)
20:20:10 <copumpkin> flebron: chez scheme is pretty hardcore
20:20:11 <tapuu> jle`: I thought it might be that
20:20:17 <oubiwann> Shen's kinda interesting
20:20:18 <athan> but I bet you obuiwann's got it down
20:20:22 * flebron is opening ~20 tabs
20:20:34 <tautologico> there's a lot of stuff that you can do with racket
20:20:42 <jle`> tapuu: but 7.8 already has compiler warnings if your Monads aren't applicatives
20:20:51 <athan> obuiwann: LFE??
20:21:05 <oubiwann> http://lfe.github.io/
20:21:18 <athan> :O!
20:21:28 <flebron> copumpkin: It seems it hasn't been updated in ~4 years?
20:21:30 <athan> racket?
20:21:48 <athan> jle`!
20:22:07 <jle`> athan: ?
20:22:20 <copumpkin> flebron: it's a pretty solid product. The compiler is fast and can compile itself in a few seconds
20:22:27 <athan> so a cont is a monadState, though, tapuu
20:22:30 <athan> ?
20:22:40 <copumpkin> flebron: cisco hired the creator to do proprietary scheme work for them
20:23:09 <athan> jle`: I just think it's interesting that it influences the design of your programs - that the guys up top were willing to make the decision!
20:23:13 <tapuu> I can't replace mtl with anything because a lot of the libraries I'm using use mtl...
20:23:40 <athan> :/
20:23:45 <athan> symlinks!
20:24:11 <tapuu> athan: I mean in the type signatures of exported functions
20:24:11 <jle`> the compiler warnings are just to make sure that nothing breaks too much at 7.10 ... but on the end-developer's end it doesn't fix too much for now v.v
20:24:25 <athan> that would be cool - map alternative library versions/authors by internally spoofing them
20:24:35 <athan> :/
20:24:49 <athan> double :/
20:24:50 <tapuu> Now that I think about it, I could just use StateT and <> instead of WriterT
20:25:02 <athan> when do you think 7.10 will be born?
20:25:16 <athan> tapuu: :O!
20:25:31 <athan> thats badass haha
20:27:13 <jle`> athan: i think i have heard within the next two years thrown around
20:28:13 <athan> v.v NOOOOOOOO!
20:29:12 <tapuu> Converting to stateT fixed it
20:29:37 <tapuu> I really don't get why there is a stateT but no writerT
20:30:45 <tapuu> Now to deal with my second problem: the lack of a monadCatch instance :/
20:32:50 <tapuu> I'd replace my throwIOs with errorT functions but ContT doesn't have a MonadError instance either...
20:35:43 <erisco> in reactive-banana how would you formulate   until :: Event t Bool -> Event t a -> Event t a   that is, cull occurrences of the second event after the first event is 'True'
20:37:07 <erisco> ah I guess you use accumulators to remember things, that's right
20:51:13 <jle`> anyone read my reddit post?  looking back now it is actually pretty long winded and verbose for a question v.v
20:51:30 <jle`> i could have probably presented it in half the length
20:51:40 * jle` sighs
20:54:01 <pavonia> Where is it?
20:54:43 <jle`> pavonia: http://blog.jle.im/entry/a-dead-end-arrowized-dataflow-parallelism-interface-attempt
20:55:03 <jle`> i'll add a summary in the abstract or something
20:55:26 <hyuke> does anyone here know anything about high-performance computing or numerical analysis using Haskell?
20:56:12 <pavonia> jle`: Oh well, tl;dr :p
20:57:29 <pavonia> hyuke: perhaps in #numerical-haskell
20:57:42 <hyuke> pavonia, I did not know that existed :D
20:57:53 <hyuke> thanks
20:58:04 * hyuke hugs pavonia
20:58:11 <pavonia> heh
20:59:13 <jle`> pavonia: added a 4-point tl;dr
20:59:18 <jle`> probably should have done this in the first place
21:05:31 <erisco> jle`, that is the pain of 'arr' because you have no control over what functions end up in your Arrow... it is a weakness of Arrow in some respects
21:07:50 <jle`> erisco: heh
21:07:58 <jle`> but
21:08:10 <jle`> i could possibly be able to handle something like arr (\(x,y) -> (y,x))
21:08:17 <jle`> because it makes complete sense in the semantics
21:08:27 <jle`> just "wait" for the other fork
21:08:34 <copumpkin> :t snd *** fst
21:08:35 <lambdabot> ((a, b), (a1, b1)) -> (b, a1)
21:08:40 <jle`> same for something like arr (\(x,y) -> (x,x))
21:08:50 <copumpkin> hm
21:08:57 <erisco> but the general arrow (a,b) (c, d)  ?
21:09:11 <jle`> the general arrow (a,b) (c,d) already works
21:09:14 <jle`> er
21:09:16 <jle`> not in general
21:09:18 <erisco> no it does not :P
21:09:18 <jle`> but for the most part
21:09:23 <jle`> the only failing case is cross-data
21:09:29 <jle`> when one end depends on the other
21:09:33 <erisco> you cannot tell if it is the parallel operations a -> c and c -> d or if there is cross-talk
21:09:52 <jle`> i could maybe use talking MVars
21:10:01 <dmj`> if I have DirA/A.hs and DirB/B.hs, and cabal repl was invoked from Dir/A.hs and A.hs imports the module from B.hs, how can I get cabal repl to find B.hs? Should I just cd to a higher directory?
21:10:07 <jle`> so if a branch sees that it needs the other branch
21:10:09 <jle`> it'll patiently wait on it
21:10:15 <jle`> if it doesn't, then it will move right along
21:10:19 <dmj`> find the module* from B.hs
21:10:29 <athan> hey quick question.... what kind of type systems do adga and idris use?
21:12:09 <erisco> jle`, also you have a more basic problem that you are relying on usage of *** and &&&
21:12:42 <augur> haasn: oh hey, yeah
21:12:51 <jle`> erisco: ideally i would be able to get rid of that relyingness
21:13:10 <jle`> and have everything be based on arr and first :/
21:13:11 <erisco> hm, how might you do that?
21:13:39 <jle`> or
21:13:50 <jle`> well, i could retain *** and &&&
21:13:55 <jle`> but make sure swap-like functions work
21:14:01 <jle`> wouldn't that fix it and make it equivalent?
21:16:39 <erisco> jle`, well you might instead define arr, ***, and &&&, and define first and second in terms of those
21:16:51 <jle`> that's what i'm doing now, actaully
21:17:50 <erisco> not quite sure how you'd do that
21:18:47 <jle`> well, the obvious definition of first and second, heh
21:18:57 <jle`> first f = (f *** id)
21:19:00 <jle`> unless that's not what you mean
21:19:23 <jle`> https://github.com/mstksg/inCode/blob/master/code-samples/pararrow/ParArrow.hs#L24-29
21:19:31 <erisco> no that is what I mean. I just couldn't think of the definition
21:19:45 <jle`> oh heh
21:19:52 <jle`> interestingly enough hlint yells at me when i do f *** id
21:19:55 <jle`> saying "use first f"
21:20:07 <erisco> shutup hlint :D
21:20:50 <erisco> of course now you have the weakness that 'first' does 'id' in parallel, but alas
21:21:13 <jle`> well
21:21:17 <jle`> that part is fused away
21:21:29 <jle`> er well
21:21:34 <jle`> yea,h there's an extra call to id in that fork
21:22:08 <jle`> but sequential branches are fused into one branching with sequenced pure functions
21:22:25 <jle`> it's just kind of frustrating because i feel like it almost works v.v
21:22:55 <erisco> so after rewriting in terms of arr, ***, &&&, what is still the hiccup?
21:26:13 <jle`> the swapping
21:26:20 <jle`> er well
21:26:26 <jle`> the proc/do notation
21:26:35 <jle`> the desugaring never uses ***, &&&, second
21:26:44 <jle`> it always uses arr, first, and arr swap
21:26:57 <erisco> well it does if you rewrite first and second in terms of *** and &&&
21:27:17 <jle`> well
21:27:19 <jle`> the problem is arr swap
21:27:46 <erisco> not sure how that is
21:27:56 <jle`> if i have ParArrow (a,b) (c,d) and ParArrow (c,d) (e,f)
21:28:07 <jle`> it fuses it into a ParArrow (a,b) (e,f) internally
21:28:14 <jle`> using only one fork
21:28:27 <jle`> and if there is a "pure" function in between the two
21:28:34 <jle`> it is all fused together too
21:28:40 <jle`> hm that wasn't explained very well
21:28:54 <erisco> nope :P
21:29:59 <jle`> so i have a ParArrow a c, a ParArrow b d, a ParArrow (c,d) (e,f), a ParArrow e g, and a ParArrow f h
21:30:09 <jle`> it will perform the first two in parallel
21:30:09 <erisco> your problem is that the desugared code will never make use of your parellism?
21:30:19 <jle`> run it through the ParArrow (c,d) (e,f)
21:30:25 <jle`> and then perform the last two in parallel
21:30:39 <erisco> (which seems to be the case because everything is sequenced by composition)
21:31:01 <jle`> it'll actually compose all of those five
21:31:13 <jle`> into a ParArrow a f and ParArrow c h
21:31:18 <jle`> and fork those, in separate threads
21:31:20 <jle`> those two ParArrows
21:31:36 <jle`> normally, if that 'middle' ParArrow (c,d) (e,f) does not have any cross-talk
21:31:38 <jle`> it should work
21:31:39 <erisco> the desugared code cannot be paralleised
21:31:51 <jle`> and you should be able to think of ParArrow a f and ParArrow c h as separate, standalone threads
21:32:10 <jle`> but if there is cross-talk....like for arr swap
21:32:18 <jle`> then you can't, and everything falls apart :/
21:32:21 <jle`> actaully sorry, have to go
21:32:21 <erisco> the only thing it can parallelise is the 'id' operation when it uses 'first'
21:32:27 <erisco> which is useless
21:32:30 <jle`> but thanks for taking the time to entertain
21:34:51 <erisco> you would be seeking to rewrite the dataflow into something parallelisable, but that would require knowing that   (Arrow a) => a (x,y) (y,x)   is in fact a swap, but you cannot know that
21:35:36 <erisco> as far as I can tell you should complain to the extension writers to desugar to *** and &&& where possible
21:38:07 <erisco> or perhaps easier would be to add 'flip' to the Arrow class and for the desugar to use 'flip' instead of 'arr (\(x,y) -> (y,x))'
21:38:44 <erisco> (though then you would be charged with refactoring the dataflow)
21:45:57 <carlosgaldino> is there a way to make a Char work as an Int? to use with (!!) function, for example
21:47:08 <carlosgaldino> smth like, [1..10] !! 'C' -- the output would be `3`
21:47:33 <carlosgaldino> I know, it's crazy, but this is not for actual code
21:48:37 <carlosgaldino> maybe it's impossible because `Int` is not a typeclass?!
21:49:21 <Sgeo> Would it be reasonable or unreasonable to use libffi even if I know the functions I want statically, but rather just want to be able to abstract over some boilerplate comfortably?
21:50:03 <Sgeo> :t (!!)
21:50:04 <lambdabot> [a] -> Int -> a
21:50:08 <Sgeo> Int is indeed not a typeclass
21:50:13 <Sgeo> It's a concrete type
21:50:38 <Sgeo> :t genericIndex
21:50:39 <lambdabot> Integral a => [b] -> a -> b
21:50:55 <jle`> carlosgaldino: look into ord from Data.Char
21:52:07 <jle`> erisco: that would be nice, but I would be hoping to work around that :) I'll give it some more thought. but even if flip was a member of Arrow, I would still have to handle flips done by hand :/
21:52:34 <erisco> jle`, but you cannot handle flips done by hand, ever. I do not see how you would be able to do so
21:52:52 <erisco> unless you inspected the machine code at runtime or something
21:53:14 <EponymicCycloid> Could you guys critique my code? It’s a simple spell checker. It loads a dictionary file of valid words. You then type in a word, and if the word is not a valid word, it offers you similar suggestions from the list.
21:53:16 <EponymicCycloid> http://pastebin.com/tLuUyqW6
21:53:39 <jle`> > ord 'C' - ord 'A'
21:53:40 <lambdabot>  2
21:54:02 <erisco> jle`, if there is some way to force ghc to rewrite certain expressions after the desurgaring is done then you might have luck
21:54:42 <jle`> erisco: maybe you could handle all sequencing with MVars instead of using normal pure function composition
21:54:49 <jle`> that's a lot of overhead though
21:57:17 <flebron> Is there a "most general" applicative? In a similar way to Cont being a "most general" monad (although I suppose that'd be the free monad...)
21:57:19 <erisco> jle`, how does that help?
21:58:09 <ParahSailin> > 'C' - 'A'
21:58:10 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
21:58:10 <lambdabot>    arising from a use of `GHC.Num.-'
21:58:10 <lambdabot>  Possible fix:
21:58:10 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Char)
22:01:21 <Sonarpulse> is there anything i can derive like an eleminator, so i can do something for one varient, and mutualy recur for the others?
22:02:39 <Sonarpulse> like ((a -> a) -> a -> a) -> a -> a ?
22:03:29 <tertl3> hi
22:03:35 <tertl3> whats up?
22:04:51 <EponymicCycloid> Sonarpulse: That signature matches the y combinator.
22:04:59 <EponymicCycloid> Not sure what you’re asking for though :)
22:05:48 <Sonarpulse> now that you mention it, it does lol, but that is not what I want
22:06:10 <Sonarpulse> for data DerpList x = Empty | Link (DerpList x)
22:08:27 <Sonarpulse> I think it would be f _ Empty = Empty; f u (Link x) = f (f u) x
22:14:05 <roboguy_> Sonarpulse: isn't that (DeroList t -> DerpList a) -> DerpList t -> DerpList a?
22:15:06 <Sonarpulse> yeah sorry, a was supposed to be type we derived, not parametric polymorphism
22:15:44 <Sonarpulse> ie things like that 'f' should be derivable for all types, but can't use same definition
22:17:04 <roboguy_> I'm still not sure I follow... what would be an example usage?
22:17:47 <flebron> Also, is there an actual formalism for (deriving Functor), or is it just "most instances of Functor we've seen behave in the following way..."? Is there any theorem saying "A given type (meeting such and such) has at most one Functor instance"?
22:18:12 <roboguy_> flebron: yeah
22:18:45 <roboguy_> the functor laws make it impossible to have more than one possible instance
22:18:48 <shachaf> Yes.
22:19:15 <flebron> Is that easy to show? Or is it a free theorem on fmap?
22:19:56 <Sonarpulse> roboguy, my usecase is I have an ADT, and I want to rewrite on one varient, and just recur doing nothing on the others
22:20:04 <shachaf> Note that e.g. Traversable instances are not unique, but can still be derived by GHC.
22:20:13 <roboguy_> flebron: it is a result of the free theorem of fmap
22:20:31 <flebron> Really interesting!
22:20:51 <shachaf> Moderately interesting. You have to pick an order.
22:21:09 <flebron> http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
22:21:13 <Sonarpulse> it is a lot of boilerplate so i was hoping i could derive a "noop recursor combintaor thing"
22:21:23 <Sonarpulse> iterestingly if insteead of having a recursive type
22:21:44 <Sonarpulse> i had data ADT expr, data ADT' = ADT ADT'
22:21:54 <roboguy_> Sonarpulse: what about something like: f = fmap f'; f' (TheCaseYouWant x) = doSomething x; f' otherCase = otherCase?
22:22:17 <Sonarpulse> fmap for ADT world be perfect
22:22:20 <shachaf> Yes, that's the usual proof.
22:23:05 <Sonarpulse> *if I had
22:23:06 <roboguy_> Sonarpulse: so that works?
22:23:21 <Sonarpulse> I am using haskell-src (not haskell-src-exts as I don't need extensions)
22:24:20 <Sonarpulse> so the tying the loop seperately + using fmap trick won't work
22:24:43 <Sonarpulse> I am writing a dirty haskell->pyret (another lang) converter, so my pyret compiler in a subset of haskell will eventually be self-hosting
22:25:22 <roboguy_> Sonarpulse: so you don't have Functor?
22:26:09 <Sonarpulse> No. there is no type variable.
22:27:01 <Sonarpulse> I made derplist with phantom variable so I could at least try deriving functor, but then I realized that wouldn't help.
22:30:34 <EponymicCycloid> Would someone mind telling me how I can improve this code or make it more idiomatic? http://pastebin.com/tLuUyqW6
22:31:31 <EponymicCycloid> There is definitely room for improvement
22:33:35 <roboguy_> Sonarpulse: treating the adt as a fixed point of a adt that has a type variable would be more likely to be useful than using a phantom type, but I'm still not sure if that'd actually help any
22:33:57 <Sonarpulse> i realized my definition of f was wrong too
22:34:14 <user> is class Functor f => Applicative f a recent thing?
22:34:34 <user> i don't know why i'm remembering having read somewhere that it's new in 7.8
22:34:37 <Sonarpulse> I think i'll take 5 minutes to write one exactly correct. should help clarify my thoguhts
22:34:37 <roboguy_> user: what do you mean by recent?
22:34:40 <roboguy_> user: no
22:35:09 <copumpkin> no
22:35:15 <Sonarpulse> user: you might be thinking of planned Applicative m => Monad m ?
22:35:15 <roboguy_> you might be thinking of AMP, which affects Monad and won't come into effect until 7.10
22:35:24 <user> amp?
22:35:25 <Sonarpulse> haha
22:35:41 <roboguy_> Applicative-Monad Proposal
22:35:55 <user> 7.10,
22:36:30 <user> i'm tired.
22:36:45 <roboguy_> user: 7.8 isn't officially out yet, so 7.10 is a while off
22:37:05 <roboguy_> Sonarpulse: this seems like something that plated might help with
22:38:07 <Sonarpulse> plated?
22:38:48 <roboguy_> Sonarpulse: Control.Lens.Plated
22:38:56 <Sonarpulse> thanks
22:40:45 * hackagebot resourcet 1.1.0.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.0.1 (MichaelSnoyman)
22:41:57 <dmwit> EponymicCycloid: I'll comment as I read.
22:42:06 <dmwit> EponymicCycloid: openFile/hGetContents better spelled readFile
22:43:01 <dmwit> EponymicCycloid: Sometimes, do { v <- foo; let v' = f v; bar } is more readable as do { v' <- f <$> foo; bar }
22:44:11 <dmwit> EponymicCycloid: Personally, I'd be tempted to replace your entire main with 'main = readFile "dict.txt" >>= interactiveCheck . fromList . lines'
22:44:52 <dmwit> EponymicCycloid: For "interactiveCheck", you might like to use the "forever" function.
22:45:09 <erisco> or more sane directionally, main = interactiveCheck . fromList . lines =<< readFile "dict.txt"
22:45:10 <roboguy_> dmwit, EponymicCycloid: or maybe interact
22:45:46 <dmwit> EponymicCycloid: interactiveCheck's "case" could be an "if/then/else", though that's an aesthetic choice more than anything else.
22:47:10 <dmwit> EponymicCycloid: You might consider writing a function to decrease the repetition in "suggestions".
22:47:36 <dmwit> For example, "suggestionsFor f = filter (...) (f [] word)", so that "swaps = suggestionsFor swapChars" or some such thing.
22:47:57 <dmwit> EponymicCycloid: Also, I find your prominent use of [Char] instead of String a bit odd.
22:48:43 <EponymicCycloid> Could you explain “do { v <- foo; let v' = f v; bar } is more readable as do { v' <- f <$> foo; bar }”?
22:48:50 <Sonarpulse> +1 for =<< !
22:49:01 <dmwit> EponymicCycloid: Sure. Take the example in interactiveCheck.
22:49:16 <dmwit> EponymicCycloid: You have "do { rawWord <- getLine; let word = map toLower rawWord; case ... of ...".
22:49:32 <Sonarpulse> haskell exprs are best read right to left, and where decls bottom to top!
22:49:33 <dmwit> EponymicCycloid: What about "do { word <- map toLower <$> getLine; case ... of ... }" instead?
22:49:37 <erisco> Sonarpulse, and <-< :)
22:49:47 <Sonarpulse> indeed
22:49:57 <EponymicCycloid> What is <$>? Is that some kind of lift?
22:50:08 <roboguy_> EponymicCycloid: it's fmap
22:50:10 <erisco> oh sorry I mean <=<
22:50:12 <dmwit> EponymicCycloid: In your swap, undelete, delete, and replace functions, appending to the end of a list is usually a bad idea.
22:50:13 <EponymicCycloid> Oh cool
22:50:26 <dmwit> EponymicCycloid: It's just a more convenient infix name for fmap.
22:50:46 * hackagebot propellor 0.2.2 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.2.2 (JoeyHess)
22:51:21 <erisco> EponymicCycloid, typically <$> is used when you're working with Applicative, ie <*>
22:51:35 <EponymicCycloid> I don’t know what <*> is either
22:51:41 <erisco> that is okay :)
22:51:59 <dmwit> EponymicCycloid: So one trick you could try using to avoid some of the list appends is the standard "accumulate at the front instead of the back, then reverse as appropriate" trick.
22:52:25 <EponymicCycloid> Yeah, I felt uncomfortable with all the appends. Could you explain that?
22:52:35 <dmwit> EponymicCycloid: Another thing I notice is a lot of extra parentheses. That's good for readability when you're a beginner, but you might want to practice noticing when they're unnecessary.
22:52:46 <dmwit> EponymicCycloid: Yes, sure.
22:52:49 <roboguy_> EponymicCycloid: the short answer is, if you want to fmap over two things, you can do this (if it's an instance of Applicative): f <$> a <*> b
22:52:50 <EponymicCycloid> dmwit: I’ve been doing that. Deleting them and seeing if it still compiles
22:53:17 <erisco> roboguy_, fairly crude! :)
22:53:56 <roboguy_> erisco: haha, well, that's how I thought of it when it started making sense to me
22:55:18 <dmwit> How do I annotate pastes on this site?
22:55:27 <dmwit> ah, got it
22:55:50 <dmwit> So, here's one step of a refactoring of swapChars.
22:56:24 <dmwit> That is aimed at removing the "appending to the end of a list at each recursive step" kind of thing.
22:56:35 <dmwit> However, I think ultimately I would write this function very differently.
22:56:57 <dmwit> One way might be to use inits and tails; another would be to write a function that returns every possible list split and map over that.
22:57:16 <dmwit> Oh, forgot to put the link in-channel. whoops, hehe http://pastebin.com/b2fMUSgC
22:58:35 <dmwit> ?let safeInit xs = zipWith const xs (drop 1 xs)
22:58:37 <lambdabot>  Defined.
22:58:38 <dmwit> > safeInit []
22:58:40 <lambdabot>  []
22:58:41 <dmwit> > safeInit [1..10]
22:58:42 <lambdabot>  [1,2,3,4,5,6,7,8,9]
22:59:31 <jle`> se
23:00:12 <dmwit> > let swaps xs = do (xs, y:y':ys) <- zip (inits xs) (tails xs); return (xs ++ [y', y] ++ ys) in swaps "abcd"
23:00:13 <lambdabot>  ["bacd","acbd","abdc"]
23:00:41 <erisco> ?let (.) = undefined
23:00:41 <lambdabot>  .L.hs:150:20:
23:00:41 <lambdabot>      Ambiguous occurrence `.'
23:00:41 <lambdabot>      It could refer to either `L..', defined at .L.hs:147:1
23:00:41 <lambdabot>                            or `Data.Function..',
23:00:41 <lambdabot>                               imported from `Data.Function' at .L.hs:78:1-20
23:00:44 <dmwit> That would be another possible refactoring.
23:00:53 <erisco> haha lambdabot is smart :)
23:01:20 <EponymicCycloid> Isn’t it bad to use “do” notation in places that don’t really need the use of monads at all?
23:01:35 <dmwit> Define "bad".
23:01:45 <EponymicCycloid> Bad style. Wasteful?
23:01:56 <dmwit> It's not at all bad style.
23:01:59 <EponymicCycloid> Like, isn’t the whole idea of haskell to use the lambda calculus?
23:02:00 <erisco> EponymicCycloid, if you do not need monads then, yes, using do-notation would be superfluous, but I am not sure if that is what you meant
23:02:02 <dmwit> I'm not sure exactly what it would be wasting.
23:02:05 <EponymicCycloid> Do notation is kind of a way around that
23:02:21 <EponymicCycloid> I feel like it’s kind of against the spirit of the language
23:02:24 <dmwit> You should use the tool that most accurately reflects your thoughts.
23:02:33 <dmwit> Here, I'm thinking of this as a non-deterministic choice of a splitting of the list.
23:02:39 <dmwit> So using the nondeterminism monad is the right tool.
23:02:47 <EponymicCycloid> Why is it non-deterministic?
23:03:05 <dmwit> Well.
23:03:23 <dmwit> I'm thinking of it as non-deterministic. That doesn't mean it *is* non-deterministic. =)
23:03:30 <EponymicCycloid> I see.
23:03:51 <EponymicCycloid> Does do notation/monad use have overhead?
23:03:53 <erisco> EponymicCycloid, main = do putStrLn "foo"  is bad in the sense that 'do' is unneeded
23:04:00 <dmwit> Have you practiced thinking of lists as a nondeterministic value?
23:04:10 <dmwit> If not, it's a fun exercise, and one we'd love to help you with. =)
23:04:13 <EponymicCycloid> dmwit: I am not familiar with that line of thinking
23:04:19 <EponymicCycloid> I will come back another day and ask for help with that
23:04:24 <dmwit> Sure.
23:04:36 <EponymicCycloid> For now, I’m off to bed
23:04:40 <EponymicCycloid> I will think on what you’ve told me
23:04:41 <EponymicCycloid> thanks
23:04:48 <dmwit> Good luck!
23:04:54 <dmwit> Looks like you've made a great start.
23:09:35 <erisco> hm... if liftIOLater defers to compilation time in reactive-banana, then there is still the issue of what happens between compilation and actuation
23:10:06 <erisco> assuming your IO action fires events (reactive-banana)
23:10:25 <erisco> I'll hope that it is a bit smarter and waits for the actuate :P
23:25:12 <ReinH> dmwit: hmm, `swaps' is making me think about computing the trace of a word in Haskell
23:26:53 <ReinH> And also some combinatorics problems with partial words
23:30:13 <Heather> hi
23:30:29 <Heather> I'm getting Couldn't match type `IO' with `[]' and can't understand where I fail
23:31:08 <Heather> here is code https://gist.github.com/Heather/9969234
23:32:02 <Dtgr> what
23:32:02 <Heather> it returns IO FilePath just fine but when I try to un-IO it I'm getting this error
23:32:23 <Dtgr> what does un-IOing mean?
23:32:29 <Heather> <-
23:32:37 <Heather>     Expected type: [FilePath]      Actual type: IO FilePath
23:32:52 <Heather> in f <- fn line
23:32:56 <Dtgr> if you functions returning IO in your function the return type needs to be in IO as well
23:33:04 <Dtgr> derp
23:33:11 <Dtgr> *if you use
23:34:08 <Heather> Dtgr: I want to return FilePath without IO
23:34:19 <shachaf> Heather: You can't. Sorry. :-(
23:34:21 <Dtgr> you can't, if you need to use getExecutablePath
23:34:27 <Heather> shachaf: why
23:34:29 <shachaf> If you do IO, you have to have IO in the type.
23:34:31 <jle`> Heather: yeah, that's actually not really how it works :/
23:34:32 <shachaf> That's how IO works.
23:34:42 <jle`> it's sort of actually illogical, if you consider how IO works in haskell
23:34:48 <shachaf> @where faq -- the FAQ has some good information on it, I think.
23:34:48 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
23:36:00 <Heather> I still don't get it
23:36:09 <Heather> why error is saying  Expected type: [FilePath]      Actual type: IO FilePath
23:36:21 <Heather> what expects [FilePath]
23:36:22 <erisco> heath, what line?
23:36:27 <Heather> f <- fn
23:36:42 <Heather> where fn is IO Filepath
23:36:59 <shachaf> OK, there are a few different issues.
23:37:11 <shachaf> The first issue is even before that line.
23:37:23 <shachaf> The two branches of the if don't have the same type.
23:37:31 <erisco> Heather, fn cannot be IO FilePath... consider the 'otherwise' case
23:37:54 <Heather> shachaf: yes, second line should have return ""
23:37:56 <erisco> it seems the type inference is confused and not giving you a terribly helpful error message
23:38:14 <shachaf> OK.
23:38:38 <Heather> but it doesn't cahnge error
23:38:52 <Heather> I still get the same...
23:38:56 <shachaf> I recommend taking a step back and spending some time on figuring out how IO works in Haskell.
23:39:05 <erisco> :t (</>)
23:39:06 <lambdabot>     Not in scope: `</>'
23:39:06 <lambdabot>     Perhaps you meant one of these:
23:39:06 <lambdabot>       `<>' (imported from Data.Monoid),
23:39:31 <erisco> :t \f g -> (<> "foo") <$> f <$> g
23:39:31 <lambdabot> Functor f => (a -> [Char]) -> f a -> f [Char]
23:39:41 <Heather> shachaf: and then I will understand why it wants [FilePath] ?
23:40:16 <erisco> oh right, <$> is just . in this case
23:41:11 <shachaf> Maybe. Your program has other errors in it, so I don't think there's that much of a point of tracking down the exact cause of that specific one.
23:41:32 <erisco> Heather, what is the types of getExecutablePath and takeDirectory?
23:41:52 <Heather> erisco: IO I think
23:42:01 <oppopp> -h 100
23:42:18 <erisco> > if | True -> "true"; | otherwise -> "false"
23:42:19 <lambdabot>  <hint>:1:1: Multi-way if-expressions need -XMultiWayIf turned on
23:42:36 <erisco> ah okay it is an extension... had never seen that before
23:42:51 <ReinH> Wait. `if | predicate -> value' is valid Haskell?
23:43:00 <ReinH> oh
23:43:04 <erisco> Heather, no it has to be something like...  getExecutablePath :: FilePath -> IO FilePath   or something
23:43:13 <Heather> it's one of my favorite extensions
23:43:22 <Sonarpulse> ok
23:43:24 <ReinH> I've never seen it used before.
23:43:24 <Heather> it solves if elseif problem
23:43:25 <Sonarpulse> https://pastee.org/wwxe8
23:43:39 <ReinH> Heather: you could have used a guard on fn instead
23:43:53 <Sonarpulse> after thinking about function I want to derive, I think I have some examples
23:43:58 <erisco> well, fn is not needed at all if you look at its usage
23:44:04 <ReinH> erisco: also that
23:44:11 <Heather> ReinH: yes but I'm bad with guards still
23:44:28 <ReinH> erisco: I was trying to go one step at a time and I think guarding fn would at least improve the error?
23:44:28 <Sonarpulse> a b should basically be respectively related to a' b'
23:44:38 <erisco> *shrug*
23:44:42 <ReinH> also shrug
23:44:48 <erisco> it would help to know the types of getExecutablePath and takeDirectory
23:45:12 <Sonarpulse> a and b I can write with fmap, because I tie the recursive not seperately
23:45:21 <Heather> well in case when this code returns IO Filepath it works, I tested it
23:45:24 <ReinH> I'm going to guess IO FilePath and FilePath -> FilePath, respectively, but let's see
23:45:25 <Sonarpulse> a' b' I just use a recursive type, so I cann't derive fmap
23:46:31 <luite> ReinH: pong. i'm here, but rather tired after hiking for 11 hours (6 in the rain), so answers might be delayed a bit
23:46:31 <Sonarpulse> is there anything I can derive to write a' and b' without the boilerplate?
23:46:50 <ReinH> luite: sounds like fun-ish
23:46:58 <ReinH> luite: mind if I pm?
23:47:07 <luite> ReinH: the hot shower was the best part :)
23:47:17 <ReinH> heh
23:47:33 <luite> go ahead
23:47:33 <ReinH> luite: I once spent a month going without one so I can relate
23:48:38 <Heather> weird
23:48:45 <erisco> Heather, I commented with my closest guess for what you are looking for
23:48:53 <Heather> if I will write let a = return "" ; b <- a it will work
23:49:19 <Heather> so it's pretty unclear where is my mistake
23:51:00 <Heather> erisco: thanks but multiwayIf is better, I can more than just if else, I can have elseif cases... and I still want to get why I can't have just String in out
23:51:37 <erisco> well use multiwayif if you want.. my point was just to try and fix the type error
23:52:32 <erisco> Heather, if your question is why you cannot do  IO a -> a   it is because IO operations are impure, and thus it is semantically invalid to do so
23:53:02 <Heather> erisco: but I can let a = return "" ; b <- a it will work
23:53:17 <erisco> Heather, post your complete example where it works
23:53:20 <Heather> erisco: or return "" is not IO ?
23:53:27 <erisco> I don't know post your example
23:53:40 <Heather> erisco:  let a = return "" ; b <- a
23:54:01 <erisco> I don't think that will compile
23:54:29 <erisco> show me the complete example please :)
23:54:33 <Heather> :t do { let a = return "" ; b <- a; b }
23:54:34 <lambdabot> parse error on input `<-'
23:55:18 <Heather> what :S
23:55:54 * hackagebot purescript 0.4.15.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.15.1 (PhilFreeman)
23:55:58 <Heather> :t do let a = return "" ; b <-  a; b
23:55:59 <lambdabot> parse error on input `<-'
23:56:22 <Heather> how to write inline do :S
23:57:52 <Heather> > do let a = return "" ; b <-  a; b
23:57:54 <lambdabot>  <hint>:1:26: parse error on input `<-'
23:58:55 <Heather> > do let a = return "" ; b >= \b ->  b
23:58:56 <lambdabot>  <hint>:1:37:
23:58:56 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:58:59 <supki> :t do { let { a = return "" }; b <- a; b }
23:59:00 <Heather> > do let a = return "" ; b >>= \b ->  b
23:59:00 <lambdabot> [Char]
23:59:01 <lambdabot>  <hint>:1:38:
23:59:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:59:13 <Heather> erisco: ^
23:59:15 <supki> :t do { let { a = return "" }; join a }
23:59:16 <lambdabot> [Char]
23:59:36 <mceier> :t let a = return "" in do { b <- a; b }
23:59:37 <lambdabot> [Char]
