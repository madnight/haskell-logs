00:00:34 <Arcsech> Alright, I installed ghc-ghc (what the fuck) and now it errors on a different package at least
00:00:42 <Arcsech> thanks for the help, supki and pavonia
00:03:07 <akurilin> With persistent, how do I print out the id of the entity in addition to all the other attributes? It seems to be omitted from show.
00:18:06 <dmj`> whoever put setEnv and unsetEnv in base-4.7 is a hero
00:21:01 <athan> dmj`: Why?
00:24:31 <SrPx> What is the right way to install 7.8.2 on OSX? Should I use homebrew? Install the Haskell platform (does it include 7.8.2?) Or just download GHC and Cabal separately ?
00:25:48 <athan> SrPx: First, recreate the universe in it's own form, as itself, whilst still bearing it's product, then install the haskell platform
00:26:26 <SrPx> athan: how do I compile the universe without ghc
00:26:28 <dmj`> SrPx: HP doesn't include 7.8.2 AFAIK, I just got the binaries from ghc's website
00:27:01 <dmj`> you can bootstrap 7.8.2 w/ 7.6.3 from HP
00:27:22 <SrPx> HP?
00:27:38 <dmj`> haskell platform
00:28:02 <athan> SrPx: Well, you could create it's existence after the fact, then deduce how the compiler should exist from the perception of it's remnants
00:28:38 <athan> or you could make a working implementation of it's operational semantics, but that's not fun
00:28:47 <athan> and boring
00:29:08 <dmj`> SrPx: download ghc-7.8.2.xz then tar -XJf ghc-7.8.2.xz, cd ghc-7.8.2; ./configure && make, should do everything for you
00:29:15 <dmj`> tar -xJf
00:29:37 <athan> You could give it really cool like, subfolders, too!
00:30:24 <SrPx> so that installs cabal too? dmj`
00:30:41 <dmj`> SrPx: just ghc
00:30:49 <athan> SrPx: I've actually found myself at a loss to the origin of cabal
00:31:07 <SrPx> but I have to update the cabal? or I can use the old one I have here?
00:31:07 <dmj`> SrPx: is your cabal > 1.18?
00:31:21 <SrPx> yes 1.18.1.3
00:32:04 <dmj`> that will work w/ 7.8.2, but 1.20 just came out so you can cabal update && cabal install cabal-install, then replace the installed binary w/ whatever is at ~/.cabal/bin/cabal
00:32:44 <athan> I like to prepend ~/.cabal/bin to my PATH
00:33:11 <tdammers> I'd like to prepend the current cabal sandbox's /bin to my PATH
00:33:24 <tdammers> not sure how to do that system-wide though
00:33:26 <athan> tdammers: Ahhh!!!!
00:33:40 <SrPx> dmj`: okay! Done all that. Thanks
00:34:04 <SrPx> now I guess I could try compiling GHCJS again, maybe that will work this time
00:34:12 <tdammers> athan: right?
00:34:21 <tdammers> so far, what I do is I have a little script that I source
00:34:54 <tdammers> it adds the current sandbox /bin to the PATH, changes the PROMPT, and creates an alias to undo itself
00:35:20 <tdammers> I source that when I start working on a project
00:35:25 <tdammers> works, mostly
00:35:31 <athan> tdammers: Any public ones?
00:36:04 <tdammers> public what? projects?
00:36:24 <athan> Sorry, yes! I thought you were reffering to a script :)
00:36:37 <SrPx> oh a quick question, what makes Haskell different from a dependently typed language, considering GADTs?
00:36:43 <tdammers> yes, I was. It's just a bit of shell voodoo
00:36:51 <tdammers> lots of gotchas, too
00:37:13 <tdammers> e.g., don't call it twice, or you won't be able to undo
00:37:27 <athan> So how many shells
00:37:29 <athan> make a shell?
00:37:40 <tdammers> just one shell
00:37:43 <athan> and how can you make a shell, out of shells?
00:37:53 <tdammers> that script doesn't run in its own shell
00:37:54 <athan> all percieving your mechanism of trust?
00:37:58 <athan> :P
00:38:07 <athan> woah
00:38:11 <tdammers> wait what?
00:38:32 <athan> yeah like, different clients
00:38:45 <dmj`> SrPx: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.2636
00:38:49 <tdammers> I don't think I follow
00:39:14 <athan> Are there any scripts that run their own shells?
00:39:51 <tdammers> well, duh
00:40:09 <athan> :(
00:40:11 <tdammers> if you invoke a script rather than sourcing it, it'll run in its own shell
00:40:18 <athan> I have been on the search for eons
00:40:32 <athan> oh okay
00:41:11 <tdammers> and obviously you can start other scripts from inside your script, which will fire up more shells
00:41:41 <athan> hmm
00:42:02 <athan> so... invocation...
00:42:29 <athan> a shell is an interpreter
00:42:40 <athan> what is an invocation of a shell?
00:42:42 <tdammers> pretty much, yes
00:42:51 <athan> or sorry, all the other baggage, too
00:42:55 <tdammers> hehe
00:43:01 <athan> that's a good one!!!!!!!
00:43:04 <tdammers> I think you need to read up on unix basics :D
00:43:08 <athan> I really do
00:43:20 <athan> Or is it zsh basics now?
00:43:45 <franklin> athan: nope, just UNIX :)
00:43:59 <ninegrid> athan: sorry I just glanced in here and I'm wondering if perhaps you mean you want something like the screen or tmux commands to run multiple terminals within a single terminal
00:44:02 <tdammers> nah
00:44:05 <tdammers> this stuff pretty much goes for all shells
01:06:36 <insitu> hi all. Does anyone know if/how haskell mode supports automatic addition of source directories from cabal file when launching inferior haskell ?
01:10:29 <danilo2> Hello! Some people told me, that arrows in Haskell are lot slower than monads (resulting for example ins slow xml parsing in the hsml library). Is it true? Are there any reasons arrows would produce slower machine code than monads?
01:13:07 <Kaidelong> I've implemented an in-place fischer-yates shuffle on mutable arrays, again, but I've run into the problem that I don't know how to refine it's type
01:13:42 <Kaidelong> I'd like Vector -> RVar Vector but using RVarT ST all I can manage to think up is Vector -> randomsource -> Vector
01:14:23 <Dongyancai> Hello, I'm learning Haskell, and found this:   http://lpaste.net/103064 . Is there any rules here? and is there any reason for this?
01:15:06 <Kaidelong> you've found the defaulting behavior
01:15:09 <Kaidelong> it's a bit ugly
01:15:18 <Maior> cute
01:15:22 <Kaidelong> GHC is defaulting to integer because it doesn't know what kind of Num you want
01:15:55 <Kaidelong> :t doesn't actually compile the code so it doesn't run into that
01:15:57 <lambdabot> Not in scope: ‘doesn't’
01:15:57 <lambdabot> Not in scope: ‘actually’
01:15:57 <lambdabot>     Not in scope: ‘compile’
01:16:08 <Kaidelong> sorry lambdabot
01:17:08 <Kaidelong> generally the way to prevent GHC from doing this kind of early binding to a default type is to explicitly say you want the constrained polymorphic type
01:18:46 <Kaidelong> http://www.haskell.org/ghc/docs/6.6/html/users_guide/ch03s04.html#extended-default-rules
01:19:09 <Kaidelong> oh wrong section
01:19:10 <Kaidelong> hang on
01:21:02 <iota_> you can also disable monomorphism restriction
01:21:20 <iota_> set -XNoMonomorphismRestriction -- in ghci
01:22:01 <iota_> (sorry, forgot the colon in front of :set)
01:24:07 <Maior> why might you want to do that / why might it not be the default?
01:24:44 <shachaf> There's all sorts of explanations of the monomorphism restriction on the wiki and other Internet places.
01:24:55 <shachaf> (Including the Report.)
01:24:58 <Maior> ah ok, cheers
01:25:12 <Kaidelong> the way GHC handles polymorphic functions gives them some overhead over monomorphic ones
01:25:28 <Dongyancai> well, I'm in a discussion, and we got confused about this behaviour.
01:25:51 * hackagebot influxdb 0.2.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.2.1 (MitsutoshiAoe)
01:29:46 <Dongyancai> thank you all.
01:38:34 <pavonia> Is there a monad transformer that can terminate prematurely with a result, but without indicating an failure situation (like EitherT/ErrorT)?
01:45:53 * hackagebot ffmpeg-light 0.3.1 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.3.1 (AnthonyCowley)
01:48:55 <suppi> Hi, can anybody help me with hssdl?
01:49:43 <suppi> I'm trying to use SDL.Image's load and SDL's displayFormat but I get this error:
01:49:44 <suppi> http://codepad.org/TpWuNSm5
01:52:10 <pavonia> Am I right that using WriterT with a list monoid is very inefficient? If so, what alternative should I use to get a list as result?
01:52:56 <pavonia> suppi: Do you have different versions of SDL and SDL-image installed?
01:53:19 <suppi> It is possible. I installed both using apt-get
01:53:30 <fizruk> pavonia: have you considered IterT transformer?
01:53:59 <pavonia> fizruk: Not yet
01:54:15 <merijn> pavonia: There is both a lazy and a strict WriterT
01:54:21 <fizruk> pavonia: http://hackage.haskell.org/package/free-4.7.1/docs/Control-Monad-Trans-Iter.html
01:54:26 <merijn> Not sure whether that's sufficient to solve your issue
01:56:08 <pavonia> merijn: I want to append elements step-by-step to build a resulting list, but if I understand correctly, lists are inefficient here because Iit builds a structure like ((a ++ b) ++ c) ++ d
01:57:03 <suppi> pavonia, http://pastebin.com/5RRfWSt0
01:58:12 <suppi> do I need to downgrade libghc-sdl-dev to a version that will match libghc-sdl-image-dev ?
01:58:32 <pavonia> suppi: What does "ghc-pkg list SDL SDL-image" give you?
01:59:14 <pavonia> suppi: Err, you have to run it for each package individually
01:59:51 <merijn> pavonia: Is each step an entire list or is each step one element?
02:00:08 <suppi> pavonia, http://pastebin.com/1xHzGxPP
02:00:11 <pavonia> One element
02:01:01 <merijn> pavonia: hmm, I had a simple idea but then realised it failed on WriterT wanting a monoid
02:01:02 <pavonia> suppi: Aha, so I guess SDL-image is built against another SDL version than the one you're using in your program
02:01:17 <merijn> pavonia: Have you considered simply using StateT and building the list in reverse order?
02:01:31 <suppi> how can I fix that then?
02:02:04 <fizruk> merijn: why not just use Dual then?
02:02:07 <merijn> So instead of "((a ++ b) ++ c) ++ d" do "d : (c : (b : (a : [])))" and then call reverse at the end?
02:02:32 <merijn> How does Dual help?
02:02:35 <suppi> pavonia, should I just remove both using apt-get and try to install SDL-image only?
02:02:43 <pavonia> merijn: Hhm, that an idea, as I'm already using StateT
02:02:55 <fizruk> merijn: makes it (a ++ (b ++ (c ++ d)) ?
02:03:11 <merijn> fizruk: Except that the problems is that ++ is really inefficiently building up thunks there :)
02:03:23 <merijn> fizruk: My suggestion of using (:) to add single elements is not
02:03:49 <merijn> But adding single elements onto a list is not a monoid
02:03:53 <fizruk> merijn: `[a] ++ xs` is as efficient as `a : xs`, isn't it?
02:03:53 <pavonia> suppi: I'm not sure what's the best way if you're using a global and user database, I would unregister all packages and build again using cabal install
02:03:55 <int-e> > 1
02:03:58 <lambdabot>  1
02:04:06 <suppi> hmmm...
02:04:10 <suppi> ok, I'll try that
02:04:18 <suppi> thank you for your help pavonia!
02:04:32 <pavonia> No problem
02:04:36 <pjdelport> As a cheap hack, maybe you can always just use the Dual monoid wrapper?
02:04:57 <b0bbi10> morning, in a type declaration like 'data List a = Empty | Cons a (List a)' what does the 'a' on the left hand side mean?
02:05:13 <pavonia> pjdelport: What does Dual do to a list monoid?
02:05:16 <davean> b0bbi10: a variable type
02:05:32 <pjdelport> pavonia: Dual just flips mappend
02:05:34 <davean> "a List containing things of type a"
02:05:46 <pavonia> > Dual "foo" <> Dual "bar"
02:05:51 <lambdabot>  mueval-core: Time limit exceeded
02:05:52 <pjdelport> so the Dual of the list monoid prepends instead of appends
02:05:57 <pavonia> O.o
02:06:07 <davean> b0bbi10: though one can have more then one variable type
02:06:10 <b0bbi10> davean: can't I just omit the 'a' on the left hand side?
02:06:25 <b0bbi10> i. e. data List = Empty | Cons a (List a)
02:06:32 <davean> Of course not
02:06:39 <davean> then how would you know what the list contained?
02:06:43 <b0bbi10> Cons a is the constructor with the type
02:06:58 <davean> Cons is a function
02:06:59 <b0bbi10> through the type in the constructor
02:07:01 <davean> not a type
02:07:18 <davean> The type is the thing on the left
02:07:19 <b0bbi10> right, List is a type
02:07:24 <b0bbi10> ok, got it
02:07:25 <b0bbi10> thanks :)
02:07:45 <Heather> :t when
02:07:47 <lambdabot> Monad m => Bool -> m () -> m ()
02:08:09 <merijn> fizruk: "[a] ++ b" is not as inefficient as doing it right associative, but still it means first wrapping a, then unwrapping it and then adding it in front of b
02:08:26 <Heather> :t (flip when)
02:08:28 <lambdabot> Monad m => m () -> Bool -> m ()
02:08:49 <merijn> b0bbi10: Actually, this may become clearer if you use GADT syntax for datatypes
02:09:19 <merijn> b0bbi10: Using GADT syntax your datatype would become: "data List where Empty :: List; Cons :: a -> List -> List"
02:09:25 <Maior> @hoogle (a -> Bool) -> [Maybe a] -> [a]
02:09:26 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
02:09:26 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
02:09:26 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
02:09:40 <merijn> b0bbi10: Versus the "standard" definition, which would be "data List a where Empty :: List a; Cons :: a -> List a -> List a"
02:10:30 <b0bbi10> merijn: actually, it's not clearer for me :/ I'll stick with the standard notation for now ;)
02:10:38 <merijn> Question: Why don't we first teach newbies to write ADTs using GADT syntax? This seems like it'd avoid a lot of the values vs types difference
02:10:58 <tac-tics> Haskell is really a poor language from a pedagogical standpoint.
02:11:07 <tac-tics> Maybe no worse than any industry language.... but still
02:11:11 <merijn> b0bbi10: That notation says it's defining a type "List a" which has two constructors (Empty and Cons) and then lists the types of these constructors
02:11:27 <merijn> tac-tics: Ha, I've taught OCaml, I'd much rather teach haskell to people :)
02:11:41 <tac-tics> heh
02:11:59 <Maior> does anyone have suggestions for a nicer way to write lines 282-286 in https://github.com/doismellburning/hess/commit/e5e338e7e5efeef4a6a882d99c13102523dcfb1f#diff-5f76336e0cba6b9165e163fc890317d1R282 please?
02:12:02 <merijn> But I think the way ADTs are generally taught doesn't emphasise enought the difference between which parts are types and which parts are values
02:12:05 <tac-tics> The little things add up. The quirks of the syntax. The monomorphism restriction. The lazy evaluation and having to explain bottom.
02:12:09 <Maior> that "filter then map fromJust" feels a bit grim
02:12:12 <tac-tics> No other language teaches about bottom :X
02:12:26 <merijn> Maior: fromJust is evil...
02:12:46 <Maior> merijn: yes
02:12:51 <tac-tics> The lack of a built-in natural type that forces newbies to use if-then statement for basic numerical functions :X :X :X
02:12:53 <Maior> merijn: but I filtered with a function where Nothing -> False
02:12:59 <tac-tics> the numeric tower from hell
02:13:03 <merijn> Maior: uh, why not use catMaybes?
02:13:06 <Maior> merijn: (I agree it's evil, hence I'd like to remove it)
02:13:09 <merijn> :t catMaybes
02:13:10 <lambdabot> [Maybe a] -> [a]
02:13:14 <Maior> that works, thanks
02:13:56 <davean> tac-tics: what numeric tower *isn't* hellish?
02:14:11 <davean> tac-tics: doing proofs about numbers is *hard*, ask godel
02:14:14 <merijn> tac-tics: Sure, but I don't think any of this makes haskell worse than any other real world language
02:14:18 <davean> tac-tics: types are proofs
02:14:29 <davean> tac-tics: you're fairly immediately limited in how nice you can make them
02:14:30 <merijn> I used to think Haskell's fromIntegral everywhere was a stupid pain, for example
02:14:36 <pavonia> merijn: Thinking about it, I could also use a WriterT Seq
02:14:49 <davean> also, we have Word
02:14:56 <b0bbi10> in this BinTree type declaration http://ideone.com/QDSb3X the Eq typeclass considers two trees equal if their constructors are equal and the Ord orders the BinTrees by the order the constructors were defined. what if both BinTrees are non-Empty? how is the ordering carried out?
02:15:07 <merijn> But you know what, I've hacked C. I've literally wasted WEEKS finding bugs due to silent type coercion. I would pick *any* number of fromIntegral's over silent type coercion
02:15:22 <tac-tics> Didn't godel make lots of people's lives much easier?
02:15:46 <tac-tics> He gave them a reason to consider giving up.
02:16:57 <tac-tics> also, the main issue with the number tower has nothing to do with godel
02:17:13 <tac-tics> and everything to do with the fact that "number" is a completely amorphous, ill-defined concept.
02:17:32 <davean> tac-tics: well, most of the concepts are well defined,
02:17:38 <davean> and there are plenty of ways to break it up
02:17:44 <tac-tics> but "Num" isn't a legitimate way to do so.
02:17:46 <davean> but consider what you get when you try to start making that
02:18:04 <tac-tics> Num is a hack because the original Haskell spec didn't want to get fancy about operator overloading :X
02:18:37 <merijn> Num isn't ideal, but it's much better than many alternatives I've seen
02:19:02 <merijn> I've never seen an actually ideal implementation of numeric data/overloading, so I'm not necessarily convinced one exists
02:19:35 <tac-tics> I'm convinced there's something much closer to the ideal
02:19:40 <tac-tics> But it's a hard problem for social reasons
02:19:58 <tac-tics> Languages are hard to write. And every language needs the number system specified fairly early on in its life
02:20:37 <tdammers> tac-tics: not necessarily - you could just spec out your language semantics sans numbers first and play with it
02:20:43 <tac-tics> They end up solidified so early on and they are impossible to tweak without breaking everyone's code
02:20:43 <tdammers> tac-tics: but it'd be in a vacuum
02:20:50 <tac-tics> yeah
02:21:28 <tac-tics> I don't think that's such a bad approach for an FPL. Even if you had to resort to ugly function calls for arithmetic, you could delay your design for a little while
02:21:37 <mjrosenb> just use church encodings on lambdas wcpgw?
02:21:40 <merijn> tac-tics: Well, I'd be very curious about a detailed proposal on a better solution
02:22:10 <tdammers> tac-tics: I'd err on the side of "first things first"
02:22:22 <tdammers> decide on the language's distinctive core feature, and implement that first
02:22:40 <tac-tics> I'd like to see a language that takes an algebraic approach. Make Monoid, Semiring, and Ring the basic classes of the numeric tower.
02:22:59 <tac-tics> And beat anyone who dares call a floating point number any of those things >___>
02:23:18 <tac-tics> Well, monoid maybe...
02:24:02 <mjrosenb> tac-tics: doesn' monoid imply associative?
02:24:34 <tac-tics> are FP numbers not associative :X :X
02:24:37 <tac-tics> oh god
02:24:52 <Iceland_jack> tac-tics: FP numbers aren't many things :)
02:24:57 <merijn> tac-tics: Welcome to IEEE754
02:25:07 <mjrosenb> tac-tics: hahahha
02:25:08 <Iceland_jack> but that's a good thing! it gives you many other properties
02:25:17 <Iceland_jack> It's not like it was an oversight
02:25:25 <tac-tics> This is pure opinion, but I feel like floating points are too quirky to deserve their own syntax accomodations.
02:25:29 <Iceland_jack> Things were much, much worse before the standardization
02:25:31 <mjrosenb> also, there isn't an identity.
02:25:55 <tac-tics> unsafeMultiplyFloatingPoint 2.999999999 3.9999999999
02:25:55 <Iceland_jack> trichotomy doesn't hold either, NaN and inf/-inf mess most things up :)
02:25:56 * mjrosenb thinks monoids have an identity element?
02:26:08 <merijn> tac-tics: floating points aren't quirky, their design is just optimised for a different group of people than "average programmer"
02:26:09 <tac-tics> Floating points don't deserve to be Eq either.
02:26:15 <Iceland_jack> tac-tics: Why not?
02:26:23 <tac-tics> And even though there is hardware supported ==, you almost never want to actually use it
02:26:24 <Iceland_jack> equality is well defined for floating point numbers
02:26:27 * mjrosenb has never even heard of trichotomy
02:26:38 <Iceland_jack> whether it's useful is a different thing :)
02:26:42 <tac-tics> merijn: Of course. I am looking at this through the eyes of a functional programmer.
02:26:49 <merijn> > read "NaN" :: Double == read "NaN"
02:26:50 <lambdabot>  <hint>:1:30:
02:26:50 <lambdabot>      Illegal literal in type (use DataKinds to enable): "NaN"
02:26:56 <Iceland_jack> > 0/0 == 0/0
02:26:57 <lambdabot>  False
02:27:03 <merijn> Yeah, that one
02:27:04 <Iceland_jack> > let a = 0/0 in a == a
02:27:06 <lambdabot>  False
02:27:35 <tac-tics> I don't want to live in a world where reflexivity doesn't hold!
02:27:39 <Iceland_jack> haha
02:27:41 <mjrosenb> Iceland_jack: the compiler writers need to have lots and lots of fun with it if they're on pre-sse2 systems.
02:28:12 <tac-tics> I also think operators ought to come in "sets"
02:28:19 <Iceland_jack> tac-tics: How so?
02:28:20 <merijn> Floating point was designed for engineers and scientific computing people who want deterministic and predictable accuracy/drift, it just a shame there's not more language with proper rational support like haskell
02:28:32 <tac-tics> With pre-perscribed precedence levels and associativity
02:28:43 <Iceland_jack> mjrosenb: Compiler writers drift between having amazingly fun problems and hair-pullingly difficult ones
02:29:13 <mjrosenb> Iceland_jack: yeah, when I said fun, I meant "hair pullingly difficult"
02:29:16 <Iceland_jack> haha
02:29:18 <tac-tics> With traditional ML-style "define precedence however" operators, it becomes very difficult for a maintainer to reason about code that mixes multiple kinds of operators at once.
02:29:51 <Iceland_jack> yes, I actually think the complexity of fixity goes against Haskell's desire for correctness
02:29:52 <tac-tics> And the actual precedent levels don't matter.... only their relative levels are important.
02:29:57 <Iceland_jack> but I'm in the minority
02:30:29 <Iceland_jack> Outside of scientific computing, people generally want something like decimal data types rather than floating-point numbers
02:30:40 <tac-tics> yeah
02:30:48 <ChongLi> oooh
02:30:51 <mjrosenb> Iceland_jack: you mean 'accounting'?
02:30:58 <Iceland_jack> haha, yes
02:30:58 <ChongLi> just saw the GSOC page
02:31:00 <Barnabe> What do I have to import to get GHC 7.8.2's IsList into scope?
02:31:04 <ChongLi> list of accepted projects
02:31:11 <Iceland_jack> Barnabe: GHC.Exts
02:31:16 <Barnabe> thanks
02:31:24 <Iceland_jack> > -0.0 == 0.0
02:31:26 <lambdabot>  True
02:31:27 <Iceland_jack> > show -0.0 == show 0.0
02:31:28 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘a0 -> GHC.Base.String’
02:31:28 <lambdabot>  Expected type: a0 -> GHC.Base.String
02:31:28 <lambdabot>    Actual type: GHC.Base.String
02:31:33 <Iceland_jack> pf
02:31:36 <Iceland_jack> > show (-0.0) == show 0.0
02:31:37 <lambdabot>  False
02:31:42 <mjrosenb> > (-0.0) + 0.0
02:31:43 <lambdabot>  0.0
02:31:49 <Iceland_jack> > abs (-0.0)
02:31:50 <lambdabot>  -0.0
02:31:55 <Iceland_jack> > abs (minBound :: Int)
02:31:56 <lambdabot>  -9223372036854775808
02:32:02 <mjrosenb> -- what, you wanted 0.0 to be the ideniy?
02:32:09 <mjrosenb> *identity
02:32:36 <mjrosenb> speaking of ieee754, does haskell suppor any rounding mode other than tie-towards-even?
02:32:43 <Barnabe> (-0.0) + 0.0 == (-0.0)
02:32:46 <Barnabe> > (-0.0) + 0.0 == (-0.0)
02:32:47 <lambdabot>  True
02:32:47 <Iceland_jack> no
02:32:53 <Iceland_jack> you'll have to use libraries for that
02:33:22 <Iceland_jack> Speaking of rounding, most people aren't aware that there are +10 ways of rounding
02:33:56 <Iceland_jack> and it should obviously be stochastic rounding
02:33:56 <Iceland_jack>     round :: (RealFrac a, Integral b) => a -> IO b
02:33:58 <Iceland_jack> :)
02:34:07 <Iceland_jack> By default in Haskell
02:34:17 <mjrosenb> tie toward zero, tie towards infinity, tie towards -infinity, tie towards even, what am I missing?
02:34:56 <mjrosenb> Iceland_jack: just take the lowest bit in the crc32 of the number, and use that to determine if you want to round up or down :-p
02:35:00 <Iceland_jack> (ugh)
02:35:14 <Iceland_jack> mjrosenb: So there are variations both with the direction in which to round and also in how to break ties
02:35:58 <mjrosenb> Iceland_jack: "direction in which to round", that sounds like floor,ceil or truncate, rather than round.
02:36:01 <Iceland_jack> rounding towards -∞ is floor in Haskell, …
02:36:08 <Iceland_jack> yes those are rounding functions
02:36:14 <mjrosenb> oh, ok.
02:36:39 * mjrosenb never considered them to be rounding for some reason.
02:36:47 <davean> mjrosenb: you missed at least away-from-zero
02:36:59 * tac-tics advocates exact real arithmetic 
02:37:07 <mjrosenb> davean: I don't think I've seen that mentioned anywhere.
02:37:07 <Iceland_jack> Kmett wrote a package for rounding modes
02:37:09 * tac-tics does not advocate practicality ;)
02:37:26 <Iceland_jack> https://github.com/ekmett/rounded/blob/master/src/Numeric/Rounded/Rounding.hs
02:37:30 <mjrosenb> Iceland_jack: what is it called?efb.
02:37:35 <Iceland_jack> I'm not sure if it's on Hackage though
02:37:52 <Iceland_jack> >>> pi :: Rounded TowardZero Double
02:37:53 <Iceland_jack> 3.141592653589793
02:38:16 <tac-tics> what was that one easy-to-write floating point num that doens't come out right?
02:38:19 <tac-tics> > 1/5.0
02:38:21 <lambdabot>  0.2
02:38:23 <tac-tics> err
02:38:30 <Iceland_jack> You need data kinds though which is a bit heavy weight for rounding imo :)
02:38:33 <mjrosenb> > 0.1 + 0.2
02:38:34 <lambdabot>  0.30000000000000004
02:38:37 <tac-tics> that's it!
02:38:58 <tac-tics> > 0.2 + 0.1
02:39:00 <lambdabot>  0.30000000000000004
02:39:20 <Iceland_jack> mjrosenb: https://en.wikipedia.org/wiki/Rounding#Rounding_to_integer
02:40:23 <Iceland_jack> 'alternative tie-breaking' implemented using TVars would be hilarious :)
02:42:12 <mjrosenb> oh, I guess I was just thinking of the ieee-754 rounding modes
02:42:18 <mjrosenb> and I mis-remembered a couple of them.
02:42:47 <Iceland_jack> Most people aren't aware that 754 is 'round-to-even'
02:43:01 <mjrosenb> is '>>>' different from '>>'?
02:43:13 <merijn> mjrosenb: Yes
02:43:32 <merijn> mjrosenb: >>> is "flip (.)" where (.) is the one exported by Control.Category
02:43:39 <merijn> >> is from the monad typeclass
02:43:44 <mjrosenb> merijn: err, I meant at the beginning of the line
02:43:45 <merijn> :t (>>>)
02:43:46 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
02:43:48 <mjrosenb> e.g.
02:44:00 <mjrosenb> >>> pi :: Rounded TowardZero double
02:44:04 <mjrosenb> but now that I look again
02:44:12 <mjrosenb> Iceland_jack: replied to that, not lambdabo.
02:44:17 <mjrosenb> *lambdabot
02:44:20 <Iceland_jack> haha
02:44:24 <Iceland_jack> yes, I was just copying from github :)
02:44:27 <merijn> Lambdabot only ever responds to "> " as start of a line
02:44:53 <Iceland_jack> Or alternatively, when someone writes '>>> ' I get summoned and evaluated the expression :)
02:45:00 <Iceland_jack> -d
03:01:27 <athan> Hey guys, how many mmand line arguments am I supposed to pass to cabal sandbox? It keeps running amock, not taking orders
03:09:12 <Arjunax> Hi Guys,   is there some equvalent to getLine which can be used to enter a password at the console? (meaning it will register what is being written without showing it on screen)?
03:09:12 <Iceland_jack> Arjunax: did you try searching for something like 'Haskell enter password'?
03:09:12 <Iceland_jack> http://stackoverflow.com/questions/4064378/prompting-for-a-password-in-haskell-command-line-application
03:09:12 <Arjunax> thanks :)
03:10:36 <Iceland_jack> to make it extra secure, replace 'return pass' with 'return (map (const '*') pass)' :)
03:11:03 * hackagebot STMonadTrans 0.3.2 - A monad transformer version of the ST monad  http://hackage.haskell.org/package/STMonadTrans-0.3.2 (JosefSvenningsson)
03:26:18 <palo_> I'm new to Haskell and its libs, I search for a good ncurses lib, i'm on vty-ui now and have a problem with Color, I can't import it don't know in what package that should be. Also maybe there is another easier to use ncurses lib you can recomment.
03:29:06 <pavonia> palo_: Have you tried the Haskell package ncurses?
03:29:12 <pavonia> @hackage ncurses
03:29:12 <lambdabot> http://hackage.haskell.org/package/ncurses
03:29:51 <palo_> pavonia: I've tried hscurses.
03:30:57 <palo_> pavonia: I'll take a look at ncurses package
03:31:01 <palo_> pavonia: thx
03:32:25 <pavonia> palo_: Maybe your problem is easy to fix, could you paste a small code example showing the problem you run into?
03:33:26 <palo_> pavonia: I want to create a newList in the Vty package. I think the vty lib is to complicated for me. I just use ncurses or hscurses.
03:34:21 <pavonia> Hhm, okay
03:36:23 <palo_> pavonia: https://gist.github.com/mrVanDalo/dcffb268a0f3c5a04efe
03:36:29 <palo_> pavonia: here the gist, of that code
03:44:10 <pavonia> palo_: What's the problem with that?
03:44:29 <palo_> I don't find green and blue
03:44:40 <Kaidelong> Maybe the solution I'm looking for is to change RVarT ST to RVarT (IdentityT ST)
03:45:09 <Kaidelong> lift . lift is a little inconvenient though
03:45:57 <pavonia> palo_: It's from package vty: http://hackage.haskell.org/package/vty-4.7.3/docs/Graphics-Vty-Attributes.html#t:Color
03:45:59 <Kaidelong> oh no that doesn't help
03:46:59 <Kaidelong> http://hackage.haskell.org/package/STMonadTrans-0.2/docs/Control-Monad-ST-Trans.html oh here we go
03:49:10 <Kaidelong> the problem is that I'm not sure STT behaves appropriately for random variables
03:49:19 <Kaidelong> hmm well
03:49:24 <Kaidelong> actually I should be fine
03:50:08 <palo_> pavonia: I put vty not to the dependencies and add that package. now it says its somehow hidden.
03:58:44 <Kaidelong> @hoogle newSTRef
03:58:45 <lambdabot> Data.STRef.Lazy newSTRef :: a -> ST s (STRef s a)
03:58:45 <lambdabot> Data.STRef newSTRef :: a -> ST s (STRef s a)
04:06:03 <quchen> I'm not sure using ST as a transformer is such a good idea. Are you sure ST at the base of your transformer stack isn't enough?
04:06:21 <quchen> (Came in late, apologies if this has been discussed earlier)
04:23:12 <allsystemsarego> Hi all, I have a Haskell program that works, can you point out how to make it more idiomatic? http://lpaste.net/103070
04:26:28 <vermeille> allsystemsarego: well... check_if_between_10_and_50 is... well. why do make a comparison which is very cheap to a list traversal which is highly inefficient?
04:26:41 <Axman6> allsystemsarego: first thing that jumps out of me is the_use_of_underscores, haskell programs are ususally written in camelCase
04:27:15 <Axman6> allsystemsarego: I'd also use a guard in checkIfeven
04:29:55 <joneshf-laptop> allsystemsarego, also, for future reference, `maybe` does what your where clauses are doing
04:30:04 <joneshf-laptop> :t maybe -- allsystemsarego
04:30:05 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:30:25 <allsystemsarego> oh ok, thanks guys
04:32:04 <vermeille> check_result is not composable, I'd rather do check_result = check_if_between_10_and_50 >=> check_if_even >=> blabla
04:33:26 <skypers> @hoogle trans
04:33:27 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
04:33:27 <lambdabot> package transactional-events
04:33:27 <lambdabot> package transf
04:34:29 <Axman6> allsystemsarego: which languages are you used to by the way?
04:35:45 <allsystemsarego> Axman6, Python mainly, hence the_underscores :D
04:35:55 <Axman6> and the odd indentation :P
04:36:08 <allsystemsarego> why is it odd?
04:36:53 <tdammers> the cascading series of >>-
04:36:55 <tdammers> >>=
04:37:01 <Axman6> allsystemsarego: http://lpaste.net/103070 some edits to show (hopefully) more idiomatic code
04:37:02 <allsystemsarego> oh
04:37:19 <allsystemsarego> Axman6, thanks, I'll have a look
04:37:28 <Axman6> I got bored though...
04:38:06 <skypers> @let newtype ID a = ID Int
04:38:08 <lambdabot>  Defined.
04:38:21 <skypers> @let trans :: ID a -> ID b; trans (ID a) = ID a
04:38:22 <lambdabot>  Defined.
04:38:29 <skypers> is there a similar function in Prelude?
04:38:44 <skypers> :t id
04:38:45 <lambdabot> a -> a
04:38:52 <Axman6> what do you need it for?
04:38:53 <skypers> something like id, but a -> b
04:39:01 <skypers> Axman6: transtyping indexed values
04:39:05 <vermeille> That's still a huge lot of boilerplate code
04:39:10 <Axman6> i mean, there's plenty of stuff out there using phantom types, but not much in the prelude
04:39:26 <skypers> I have an ID on a type, refering to the index of Vector Foo
04:39:27 <skypers> for instance
04:39:47 <skypers> and there’s _exactly_ the same Vector of Foo representations
04:39:54 <skypers> FooRepr, for instance
04:40:00 <skypers> if I want to get a Foo
04:40:06 <skypers> I can use an ID Foo as lookup
04:40:11 <skypers> if I want its representation
04:40:23 <skypers> I pass trans myFooID to the represantation Vector
04:41:11 <skypers> :t let myFooID = ID 3 :: ID Int in trans myFooID :: ID Float
04:41:12 <lambdabot> ID Float
04:41:42 <skypers> I’ll make something stronger with typeclasses later for that kind of things
04:41:49 <skypers> like Transtypable
04:41:52 <skypers> or something like that
04:41:55 <skypers> and hide the typeclass
04:44:07 <byorgey> @tell fizbin there won't be a hac phi in the summer.  There might be one in the fall sometime.
04:44:07 <lambdabot> Consider it noted.
04:45:05 <shahidh> Hello
04:45:36 <shahidh> I was starting on Haskell
04:46:42 <Yaniel> good
04:47:09 <vermeille> allsystemsarego: http://lpaste.net/103072
04:48:04 <allsystemsarego> vermeille, thanks, I'll take a look
04:49:03 <allsystemsarego> this one is extremely concise, I like it
04:49:34 <vermeille> Ooops, I accidentaly erased testE
04:50:33 <vermeille> allsystemsarego: http://lpaste.net/103072 HERE IT IS
04:50:37 <vermeille> Here it is*
04:52:12 <allsystemsarego> cool, I was about to hoogle testE :)
04:52:34 <vermeille> I'm pretty sure there's a function already defined which does that
04:53:30 <vermeille> Looks like there is not. Sad.
04:55:02 <vermeille> Does someone have an exemple of monadic function composition which are not associative?
04:55:13 <vermeille> (and thus fails to be a monad)
04:56:48 <vermeille> allsystemsarego: as you can see, the code here is way more composable and reusable
05:00:27 <Jaak> check_result actually looks overly complicated. i would write it without the chain of kleisli compositions
05:01:45 <byorgey> vermeille: what do you mean by "monadic function composition which is not associative"?
05:02:14 <merijn> vermeille: The monad laws require kleisli composition (i.e. composition of monadic functions) to be associative
05:02:30 <byorgey> oh, do you mean some bogus implementation of (>>=) such that (>=>) is not associative?
05:03:01 <merijn> byorgey: That's how I interpreted it, at least
05:12:40 <vermeille> byorgey: exactly
05:14:17 <vermeille> byorgey: in the monad law it is said that (>>=) has to be associative, but I can't figure an example where it is not
05:15:26 <Maior> vermeille: do you mean "how to construct one that isn't?
05:15:28 <Maior> "
05:15:50 <vermeille> Maior: Absolutely
05:16:17 * hackagebot rados-haskell 3.0.1 - librados haskell bindings  http://hackage.haskell.org/package/rados-haskell-3.0.1 (ChristianMarie)
05:17:30 <byorgey> vermeille: there are surely very simple counterexamples, but I'm having trouble constructing one too.  The problem is that most of the things you think of tend to be "reasonable" and hence associative
05:19:39 <byorgey> vermeille: ah, here's one for m = []:   xs >>= k = drop (length xs) (concatMap k xs)
05:20:22 <byorgey> I leave you the exercise of proving this is not associative.  I used QuickCheck.
05:20:22 <fizruk> i guess you could take any non-associative operation and perform it in the background to violate this law
05:20:49 <vermeille> fizruk: I like this recursive reasonning
05:20:51 <fizruk> e.g. having Int as part of context and subtracting them on >>=
05:20:52 <byorgey> fizruk: right, which is how I came up with the above (based on subtraction)
05:21:20 <byorgey> well, you can't assume you have Int, it has to be polymorphic
05:21:40 <fizruk> byorgey: I can have data X a = X Int a
05:21:43 <byorgey> oh, wait, I see what you mean, using something like State
05:21:45 <byorgey> right, OK
05:22:25 <byorgey> right, ((,) m)  is a Monad iff m is a Monoid
05:23:22 <byorgey> so if you use some non-associative operation on m it will necessarily give you non-associative (>>=)
05:25:51 <fizruk> why do we have those ((,) m) and ((->) e) instead of (m,) and (e ->) ? is it because we don't want (,m) and (-> e) ?
05:26:18 <quchen> There are no type-level operator sections.
05:26:29 <quchen> (For no fundamental reason, it's just not been done.)
05:26:55 <fizruk> quchen: that's what I thought, thanks
05:27:11 <c_wraith> Took forever to get value-level tuple sections!
05:31:31 <joneshf-laptop> why is that?
05:31:46 <joneshf-laptop> is it just the mass of the community?
05:32:51 <quchen> I don't think they're tremendously useful.
05:33:08 <quchen> You rarely use 3-tuples anyway, and for a 2-tuple a lambda is fine.
05:33:31 <joneshf-laptop> i suppose that's true
05:33:35 <quchen> Typing the language pragma is usually more work than implementing the operator yourself.
05:34:22 <c_wraith> :t (,"foo",,,5,)
05:34:23 <lambdabot> Num t3 => t -> t1 -> t2 -> t4 -> (t, [Char], t1, t2, t3, t4)
05:34:36 <c_wraith> (things like that show up all the time)
05:35:07 <c_wraith> Also, last time I checked, lambdabot didn't have tuplesections turned on.  So that's handy
05:36:07 <quchen> 6-tuples show up all the time!?
05:36:50 <quchen> (Plus I don't think tuple sections make this any more readable than \a c d e g -> (a, "foo", c, d, e, 5, g)
05:36:52 <quchen> )
05:37:56 <fizruk> quchen: i prefer (a,) <$> x to (\y -> (a, y)) <$> x or to (,) a <$> x
05:38:21 <fizruk> quchen: not 6-tuples, though :)
05:38:38 <merijn> quchen: Do you have a reason to believe there's no fundamental reason?
05:39:02 <merijn> quchen: AFAIK it's not possible without breaking the type system
05:39:46 <fizruk> i think allowing (,a) at type level might break something
05:40:05 <fizruk> and allowing (a,) but not (,b) seems inconsistent
05:40:09 <merijn> "(,a)" and "(-> e)" would be equivalent to adding type level lambda, which breaks things
05:40:45 <merijn> "(,a)" just being eta reduction of "\x -> (x,a)" and I now type level lambda's *definitely* break things
05:41:12 <merijn> So unless you have reason to belive (,a) and (-> e) won't break things, I'm fairly confident they *will* break things
05:41:27 <quchen> merijn: Type-level lambdas break things?
05:41:34 <merijn> quchen: Yes
05:41:43 <quchen> I hadn't considered that.
05:41:45 <merijn> quchen: There's a reason we don't have them
05:42:25 <ocharles> hey folks, any tips on debugging MVar-y stuff?
05:42:36 <ocharles> I have a feeling some code is getting blocked on withMVar... but I'm not getting an exception or anything
05:43:10 <ocharles> It'd be good if I could log mvar accesses, but I'm not sure that can be done. they don't show up in the eventlog, do they?
05:45:51 <Yuu_chan> merijn: are type level lambdas linked with the monomorphism restriction?
05:46:20 * hackagebot ZipperAG 0.5 - An implementationg of Attribute Grammars using Functional Zippers  http://hackage.haskell.org/package/ZipperAG-0.5 (prmartins)
05:48:03 <c_wraith> Yuu_chan: no.
05:48:09 <c_wraith> Yuu_chan: they actually break inference
05:48:46 <Yuu_chan> c_wraith: where is a type-level lambda in \x -> (x,a)?
05:49:04 <c_wraith> Yuu_chan: the assumption was that entire expression was at the type level
05:49:44 <c_wraith> Oh, I see.  The thing type-level lambdas obviously break is instance selection, because they permit ambiguous instances
05:50:29 * Yuu_chan still doesn't understand
05:50:58 <orion> http://ideone.com/7vezCK <-- c2hs is crashing on me. :(
05:51:41 <orion> Is this a bug in GHC?
05:54:32 <joneshf-laptop> where does the intuition come from for using `intesectWith`: http://hackage.haskell.org/package/semigroupoids-4.0.1/docs/src/Data-Functor-Bind.html#line-189 ?
05:54:53 <joneshf-laptop> or is this the only valid instance of Apply for Data.Map?
05:54:57 <Yuu_chan> Could someone please explain why type lambdas are equivalent to tuple sections?
05:55:16 <merijn> Yuu_chan: We were talking about *type level* tuple section
05:55:48 <merijn> i.e. being able to write "instance Functor (e,) where" instead of "instance Functor ((,) e) where"
05:57:32 <quchen> merijn: Can you explain those reasons against type-level lambda?
05:57:56 <quchen> merijn: Something along those lines of "can have non-terminating types"?
05:58:15 <Yuu_chan> merijn: Oh, I'm sorry, missed the real beginning of the discussion
05:58:39 <iross_> orion: Never seen that!  Doesn't happen on Linux, GHC 7.6.3, C2HS 0.17.2 (or HEAD).  I've never tested C2HS on FreeBSD...
06:01:13 <orion> iross_: C->Haskell Compiler, version 0.16.4 Crystal Seed, 24 Jan 2009 build platform is "x86_64-freebsd" <1, True, True, 1>
06:06:39 <vermeille> I can't exaplain what >>= means in cattheory with a simple sentence, any help?
06:07:27 <prophile> vermeille: it's kleisli composition with the first morphism having 1 as the domain
06:09:04 <Benzi-Junior> hey is there a way to have haskell call another program with a command line argument in linux
06:09:15 <prophile> Benzi-Junior: yes
06:09:43 <orion> Is the Haskell Platform dead?
06:09:58 <quchen> No, the next release is in the workings, featuring 7.8.
06:09:59 <prophile> orion: perchance it is not dead, but sleepeth
06:10:26 <quchen> Benzi-Junior: See System.Process
06:10:38 <prophile> Benzi-Junior: http://hackage.haskell.org/package/process
06:10:55 <vermeille> prophile: okay, let me study Kleisli composition. I never studied cattheory before Haskell
06:10:56 <Benzi-Junior> quchen: k thanks will look into it
06:11:08 <orion> ok
06:11:42 <prophile> vermeille: kleisli composition is >=> if you know the monad operators
06:11:47 <prophile> with return, it forms a category
06:11:52 <prophile> and the monad laws are just the category laws
06:12:10 <prophile> :t (>=>)
06:12:11 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:12:15 <prophile> ^
06:12:23 <prophile> >>= you can think of as just a special case of that, with a set to ()
06:13:04 <vermeille> prophile: I see >=> as . for monadic function, is that too approximative?
06:13:25 <prophile> vermeille: no, that's an extremely good approximation
06:13:35 <prophile> (.) and id also form a category
06:13:54 <prophile> it's a category usually called Hask
06:14:40 <vermeille> Hmmm, make sense
06:15:05 <vermeille> Can I think of it as a monoid with the composition function being . and the neutral element being id?
06:16:30 <vermeille> Hmmm, no, if I'm not mistaken, it wouldn't be stable
06:16:54 <prophile> vermeille: no, because it's not closed
06:17:10 <vermeille> Yeah, okay, got it
06:17:11 <pjdelport> vermeille: The monoid would be Endo
06:17:27 <prophile> as pjdelport points out, if you restrict it to one type you get a monoid
06:17:44 <prophile> otherwise it's a "monoid when the types line up", which is a category
06:17:55 <vermeille> OH OKAY
06:18:07 <prophile> (a category with one object is a monoid, and the category laws in that case are precisely the monoid laws)
06:18:21 <vermeille> A category is just a monoid with a "relaxed" composition operator?
06:18:31 <prophile> more or less
06:18:34 <vermeille> \o/
06:18:43 <prophile> it's probably more useful to think of monoids as a special case of categories
06:19:30 <vermeille> prophile: I seeeeee !
06:21:15 <vermeille> So (id, (.)) in Hask is exactly the same as (return, (>=>)) in Kleisli
06:21:26 <prophile> basically, yes
06:21:28 * hackagebot props 0.1 - Properties of functions and relations, perhaps for use with quickcheck  http://hackage.haskell.org/package/props-0.1 (AlecHeller)
06:21:41 <prophile> in fact if you use the Identity monad they really are the same up to the newtype wrapper
06:21:44 <yoeight> Hi, does cabal use flags when fetching dependencies ? for Instance in, cabal install -ffeature --only-dependencies. Do dependencies can see that feature flag is toggled ?
06:22:15 <vermeille> Great. So, what is >>= exactly ? I can't word it in a mathematical sense
06:22:32 <vermeille> and how does >>= relates to >=>
06:22:57 <prophile> okay, so
06:23:14 <prophile> a value of type a is isomorphic to a value of type () -> a, right?
06:23:25 <vermeille> true
06:23:30 <prophile> so
06:23:33 <prophile> :t (>=>)
06:23:34 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:23:52 <prophile> if you substitute in () for a, it's (() -> m b) -> (b -> m c) -> () -> m c
06:23:59 <prophile> use that isomorphism and the () -> disappears
06:24:06 <prophile> which gives you m b -> (b -> m c) -> m c
06:24:10 <prophile> which is what >>= is
06:24:23 <vermeille> wooow !
06:24:44 <vermeille> Super great
06:24:50 <merijn> vermeille: The main reason haskell uses >>= over >=> is that it's usually easier to implement >>= than >=>
06:25:20 <vermeille> and sometimes join is even easier to implement, IMHO
06:25:46 <merijn> Perhaps
06:25:49 <merijn> Actually
06:25:57 <merijn> Isn't join becoming part of the Monad class with AMP?
06:26:12 <vermeille> AMP?
06:26:14 <prophile> apparently so
06:26:22 <prophile> vermeille: the proposal to make Applicative a superclass of Monad
06:26:49 <vermeille> Good.
06:26:49 <mietek> Is it possible to specify in a Cabal package description file that alex and/or happy should be installed before building this package?
06:26:51 <prophile> brb, pie calls my name
06:27:11 <mietek> I know I can specify "Build-Tool: alex, happy", but this only looks for already installed tools
06:27:24 <merijn> mietek: Nope
06:28:06 <merijn> mietek: Because cabal is not a package manager and has no way of knowing whether tools are already installed
06:28:21 <merijn> vermeille: Applicative Monad Proposal
06:28:38 <merijn> in 7.10 we'll *finally* have a Applicative as superclass of Monad :)
06:28:55 <mietek> merijn: Cabal already looks for installed tools, https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/Builtin.hs
06:28:57 <geekosaur> more specifically, cabal doesn't track packages, it defers that to ghc-pkg. which tracks *libraries* not executables.
06:29:19 <fizbin> @type (join .) . (flip fmap)
06:29:21 <lambdabot> (Functor m, Monad m) => m a1 -> (a1 -> m a) -> m a
06:29:25 <merijn> mietek: It "looks" for tools in the sense that it checks if they are on your PATH
06:29:28 <mietek> I know.
06:29:30 <fizbin> @type (>>=)
06:29:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:29:55 <mietek> What I don't know is, what exactly happens when I specify both "Build-Depends: alex, happy" and "Build-Tools: alex, happy"
06:30:02 <fizbin> @type (join .) . (flip liftM)
06:30:03 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
06:30:06 <quchen> "join to Monad" was discussed in the AMP, but opinions about it were split. My gut tells me it's going to be added, but you can't be sure right now.
06:30:22 <mietek> What appears to happen is, Cabal installs alex and happy in ./.cabal-sandbox/bin
06:30:22 <quchen> (Split with a bias towards "yes, add it to Monad", with a couple of concerns raised.)
06:30:22 <bennofs> Is it possible to have criterion run some benchmarks only once? For example, I'd like to have a benchmark for an IO action, but already one run of that action takes pretty long
06:30:30 <merijn> mietek: Then it will *always* try to install alex and happy and potentially fail because it can't detect whether they have been installed
06:30:34 <mietek> But then fails, saying the dependencies are missing
06:30:37 <fizbin> @src join
06:30:37 <lambdabot> join x =  x >>= id
06:30:47 <mietek> This appears to be completely ridiculous
06:31:19 <merijn> mietek: Well, how would it detect whether they were succesfully installed? As mentioned build-depends relies on ghc-pkg which can only track libraries
06:32:10 <vermeille> @src (>>=)
06:32:10 <lambdabot> Source not found. Sorry.
06:32:21 <fizbin> cabal may not be a package manager, but it's very nearly 80% of a package manager. It would be nice if someone could finish it.
06:32:28 <merijn> mietek: Until someone bothers to build a full-blown package manager based on cabal (and do we actually want that? We already have like 15 billion package managers...) it can't do this
06:32:31 <prophile> vermeille: it's part of the typeclass, so you need to specify which instance you want
06:32:41 <prophile> I think the syntax is @src <value> <typeclass>
06:32:45 <prophile> @src (>>=) Maybe
06:32:45 <lambdabot> Source not found.
06:32:53 <merijn> prophile: @src really just is a text lookup into a file
06:32:59 <quchen> Lambdabot @src database: https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
06:33:02 <vermeille> prophile: I believed join was implemented in terms of >>= and >>= in terms of join
06:33:07 <prophile> merijn: I'm disappointed but not surprised
06:33:07 <merijn> prophile: So it depends on whether someone bothered to specify it
06:33:21 <prophile> vermeille: currently no, >>= is in the typeclass and join is just in terms of >>=
06:33:26 <merijn> and so @src is also filled with lies and wishful thinking
06:33:31 <quchen> join = (>>= id),  m >>= f = join (fmap f m)
06:33:41 <mietek> merijn: I really don't see why becoming a package manager is necessary here.  If with Build-Tools alone cabal can look for alex/happy in the PATH, and with Build-Depends alone cabal can install alex/happy in the PATH, then why does it fail?
06:33:56 <vermeille> thanks quchen
06:34:10 <quchen> merijn: It's not so much lies rather than readable implementations.
06:34:15 <merijn> mietek: That means generalising build-depends to distinguish libraries and executable and checking paths for executables
06:34:21 <fizbin> vermeille: No, (>>=) is unimplemented. (>>=) can be implemented in terms of join and fmap/liftM (liftM is just fmap for the current pre-AMP world)
06:34:32 <fizbin> But it isn't, in general.
06:34:49 <prophile> fizbin: >>= can't be implemented in terms of liftM surely?
06:34:53 <prophile> because liftM is in terms of >>=
06:34:57 <mietek> OK, so Build-Depends currently is broken for executable-only packages, as it can build them, but not verify that the build succeeded?
06:35:07 <merijn> mietek: Right
06:35:11 <mietek> I see. Thanks.
06:35:25 <merijn> mietek: Well, not so much broken as it was never designed to think about executables
06:35:31 <vermeille> Okay, I understood what "means" >>= thanks to its implementation in terms of join/fmap
06:36:01 <merijn> mietek: And given that cabal is maintained by like 2 people who are already swamped it's not clear whether turning cabal into a proper package manager is the best use of their time
06:36:07 <fizbin> vermeille: That is not the majority path to understanding (>>=), but it's not an overly uncommon one.
06:36:08 <mietek> Well, if it's possible to create a Cabal package which only contains executables, then it should be possible to pull in this package using Cabal as a dependency.
06:36:22 <mietek> Fair point about time.
06:36:26 <merijn> mietek: Although, if you're willing to help fix things you can always help brainstorm in #hackage
06:36:33 * hackagebot antisplice 0.15.0.1 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.15.0.1 (implementation)
06:36:35 * hackagebot ironforge 0.1.0.29 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.29 (implementation)
06:36:37 <mietek> I am actively trying to help fix things.
06:36:40 <sm> maybe alex & happy should have a stub library added so they can be managed usefully ?
06:36:51 <merijn> mietek: Lots of cabal warts are just "no one has time to do it yet"
06:36:56 <mietek> I was hoping to fix deployment first.
06:37:04 <vermeille> fizbin: I didn't managed to give a sense to the wrapping / unwrapping in the Monad which happens in >>=
06:38:45 <vermeille> Hum, the biggest lie about Haskell is "you don't need to know cattheory"
06:38:54 <fizbin> vermeille: Well, some implementations of (>>=) aren't best understood as "wrap again, then unwrap once". [] is perhaps best understood that way, but I don't think it quite works for IO.
06:39:06 <quchen> vermeille: That's wrong.
06:39:22 <quchen> You need category theory to write Haskell the same way you need automaton theory to write C.
06:40:05 <fizbin> vermeille: I think it is perfectly possible to learn haskell without understanding category theory. I think it's however very difficult to try to understand haskell from a purely mathematical point of view while simultaneously avoiding knowledge of category theory.
06:40:22 <Maior> I do not know category theory, to my knowledge
06:40:24 <fizbin> But the purely mathematical path is not the only path to using Haskell.
06:40:29 <vermeille> Well, you can't just ignore functor, monads, applicative, etc if you want to write good Haskell
06:40:42 <quchen> Yes you can. You can't ignore Functor, Monad, Applicative though.
06:41:33 * hackagebot influxdb 0.2.1.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.2.1.1 (MitsutoshiAoe)
06:41:59 <quchen> When you're doing research to finding entirely new ways of representing things, cats may be useful. To write a program that analyzes logfiles it's probably useless.
06:42:01 <fizbin> You can easily use Functor and understand fmap as a generalized version of "map" without ever dealing with the CT-specific definition of "functor".
06:42:11 <Maior> granted I suspect I've picked up bits of category theory by loitering in here
06:42:17 <vermeille> Well, maybe, you're more experienced in Haskell than me, but I keep crowling wikipedia on cattheory articles to understand Haskell
06:42:20 <Maior> fizbin: seconded (because I do)
06:42:24 <fizbin> In fact, the CT-theory definition may lead you down the wrong path.
06:42:33 <Maior> vermeille: I personally recommend not doing that
06:42:58 <fizbin> Sorry, the "CT" definition. I didn't just invoke Category Theory-theory.
06:43:27 <vermeille> Maior: why?
06:43:53 <fizbin> In fact, when I was first learning a bit of CT, I tried to connect this "functor" concept with Functor, and had trouble.
06:44:09 <vermeille> I'd like to be able to answer something else that "a burrito" when someone asks me what a monad is.
06:44:15 <DR6_> the problem is that the ct concept of a functor is way too general
06:44:15 <fizbin> Because the CT version is in some ways much, much more general.
06:44:24 <Maior> vermeille: let me rephrase - if I correctly read the implicit "and it doesn't really help" in your statement, I recommend against it
06:44:49 * quchen wonders whether Haskell would still "require" category theory if we had named Functor/Monad Mappable/Pipeable.
06:44:52 <DR6_> all haskell "functors" are actually just a specific class of endofunctors in a specific category
06:45:15 <Maior> vermeille: because not-doing-so has worked perfectly well for me so far (obviously it's all anecdotal, but the implication I read from your statement was "I keep crowling wikipedia on cattheory articles to understand Haskell [because I believe that to be the right way to learn more, but it isn't working for me])
06:45:21 <Maior> if my reading is incorrect, please let me know
06:45:31 <pjdelport> Haskell doesn't require category theory; it just rhymes with it nicely.
06:46:04 <prophile> category theory is quite interesting but far from necessary
06:46:13 <fizbin> Right. In haskell, a Functor is a kind of type constructor, and you can only go from a type "a" to a type of the form "something a", whereas the first thing you do with CT is imagine functors just going between nearly random, contextless categories.
06:46:17 <Maior> vermeille: meanwhile "a monad is a typeclass and some laws"
06:46:44 <prophile> it can be a useful shovel if you get embedded in deep kmettian horror but other than that it's just an interesting distraction
06:46:49 <quchen> "The term monad comes from a branch of mathematics known as category theory. From the perspective of a Haskell programmer, however, it is best to think of a monad as an abstract datatype." -- Haskell Report
06:47:28 <vermeille> Maior: So, I'm just mistaken because of my complete lack of understanding of CT, and the little bit of CT I can understand "resonnates" with Haskell for me
06:47:54 <prophile> category theory resonates with a lot of things
06:48:08 <prophile> topology to string theory
06:48:10 <fizbin> I actually think that once you learn enough about haskell to start looking up deeper bits of CT to try to understand it, your understanding would be better served by reading the Typeclassopedia.
06:48:20 <prophile> but it's not actually *necessary* per se
06:49:00 <fizbin> vermeille: So, seriously, get of wikipedia CT articles and read http://www.haskell.org/haskellwiki/Typeclassopedia
06:49:03 <Barnabe> "You don't need to know category theory" is a lie all right. It has nothing to do with Haskell, though.
06:49:09 <fizbin> "get off", rather.
06:49:16 <fizbin> Can't type today.
06:49:49 <vermeille> Thanks for the link fizbin !
06:50:40 <pjdelport> vermeille: The other useful observation is that many other languages contain the same things as Functor, Monad, etc.; they're just obscured more, and named different things.
06:51:09 <vermeille> Thank you all for your advices and POV, it's nice to have my opinions destroyed and reconstructed in a better way :)
06:51:13 <pjdelport> hence what quchen said about "if we had named Functor/Monad Mappable/Pipeable"
06:51:35 * hackagebot happstack-static-routing 0.3.2 - Support for static URL routing with overlap detection for Happstack.  http://hackage.haskell.org/package/happstack-static-routing-0.3.2 (GracjanPolak)
06:51:45 <int-e> Warm/Fuzzy
06:51:47 <merijn> I'd consider profunctor/arrow more of a "pipeable"
06:51:58 <merijn> Monad is more of a sequenceable
06:52:02 <pjdelport> vermeille: e.g. in Python and JavaScript you have Deferred, which is the same as the Either monad
06:52:04 <merijn> Except not really
06:52:06 <int-e> A Necklace
06:52:13 <fizbin> Barnabe: After delving a bit into CT I don't necessarily feel this way completely, but CT (especially when people wax enthusiastically about how it explains and unites everything) always reminds me of "Smurf Theory".
06:52:23 <pjdelport> vermeille: but no one says you need to understand category theory to understand that
06:52:36 <pjdelport> (even though they resonate, once you do understand some of the CT)
06:52:38 <fizbin> "Smurf Theory": Everything is smurf.
06:53:07 <prophile> fizbin: but cartesian closed smurfs are so useful in practice
06:53:13 * pjdelport thinks of Monad is a collapsible
06:53:13 <merijn> vermeille: The thing with category theory is that it inspired lots of ideas, but understanding category theory and how the individual ideas relate to it is not really necessary
06:53:23 <Maior> pjdelport: I think that's an incredibly unhelpful analogy (Deferred / Either)
06:53:40 <Maior> but I may be missing something?
06:53:56 <merijn> Deferred is more comparable to a blocking IO operation
06:53:59 <int-e> pjdelport is a containerian monadist.
06:54:00 <fizbin> Proof using all Smurf Theory: Proposition: All sets are smurf. Proof: Let _s_ be a set. By the Fundamental Axiom of Smurf Theory (FAST), _s_ is smurf. Therefore, all sets are smurf.
06:54:01 <orion> hm
06:54:13 <merijn> The entire concept of a Deffered doesn't really make sense in haskell, you'd just use blocking IO and threads
06:54:16 <pjdelport> Maior: Well, they're isomorphic; whether it's helpful or not is probably anyone's guess.
06:54:29 <vermeille> You can speak about Rust and the Option<T> type, but having an Option does not mean having the associated monad and stuff
06:54:59 <merijn> vermeille: Right, it just happens that stuff like Monad suddenly becomes very easy to use in the presence of typeclasses :)
06:55:07 <c_wraith> vermeille: though Rust does have the monad operations available for Option<T>, because they're really useful
06:55:09 <pjdelport> merijn: Either is useful in Haskell.
06:55:19 <c_wraith> vermeille: what Rust doesn't have is an abstraction for those operations
06:55:36 <merijn> pjdelport: Sure, but Either is only like deferred if you completely ignore deferred's operational semantics
06:55:38 <pjdelport> merijn: Deferred does the same thing, and doesn't necessarily have anything to do with IO
06:55:40 <fizbin> prophile: Individual cartesian closed categories are useful, but they're useful because of other properties about those categories, not because of the handwavy spider-webs of CT.
06:55:52 <pjdelport> merijn: Its operation semantics are exactly the same as the Either monad.
06:55:57 <pjdelport> operational, even
06:56:41 <prophile> fizbin: all the handwavy spider-webs of CT do is give us a box of useful terminology to apply in a wide range of different situation
06:56:48 <merijn> No, deferreds (at least python's Twisted style deferreds) work with asynchronous IO operations to hide the asynchrony
06:56:53 <orion> cabal is reporting a failure in locating a specific library, but --verbosity 3 doesn't help me at all figure out where it's looking.
06:56:53 <vermeille> So, if I read the mathematical definition of a functor, it's not the true definition of Functor?
06:57:09 <merijn> vermeille: Haskell Functor's are endofunctors
06:57:24 <merijn> vermeille: So really the haskell names are only loosely correlated with math
06:57:28 <randomclown> by endo he means same category to same cateogry
06:57:32 <vermeille> Which means they map a category to this same category, right?
06:57:35 <randomclown> which is not very mathmaticallly interesting
06:57:47 <c_wraith> Honestly, it's really hard for Haskell's functors to not be endofunctors.  It's really hard for a construction in the type system to leave the category of haskell types
06:57:48 <merijn> vermeille: Right
06:57:54 <fizbin> prophile: Right, it gives us terminology. So I can say to someone "I've proved X a category" and they then know what that means. But what else? I never found taxonomy a particularly compelling subject.
06:57:59 <orion> Where does cabal search for libraries?
06:58:04 <randomclown> category theory is overrated
06:58:10 <randomclown> orion: hackage I'd assume
06:58:13 <merijn> randomclown: I disagree
06:58:17 <quicksilver> fizbin: theorem transfer.
06:58:22 <merijn> randomclown: It's just not very interesting if your goal is to program haskell
06:58:27 <orion> randomclown: No, I meant system libraries.
06:58:48 <randomclown> orion: ghc-pkg -l
06:58:49 <merijn> fizbin: If you've proven "X is a category" you've also succesfully proven "every theorem proven for categories is proven for X"
06:58:53 <quicksilver> fizbin: certain theorems proved in one domain turn out to apply generally to all "categories-with-X,Y,Z" which includes various other not obviously related domain.
06:58:55 <orion> I *specifically* gave it --extra-lib-dirs and --extra-include-dirs and it still fails.
06:58:59 <pjdelport> merijn: That's a very common misconception about Twisted: Deferreds don't do anything special about I/O: they're purely the same as Either.
06:59:20 <quicksilver> fizbin: there are some good examples in fields like classical topology, algebraic topology, etc.
06:59:36 <merijn> fizbin: Same reason monoids are useful, any proof about monoids is directly applicable once you prove something a monoid
06:59:37 <pjdelport> merijn: Twisted uses them to handle async operations, but that's only because they happen to be useful for that. Deferred is identical to Either, otherwise.
06:59:53 * merijn gets all his theorems for free
07:00:29 <randomclown> in my experience haskell programming, Haskell's like a high functioning autism kid, sometimes he comes up with something really elegant, but most of the time he's just slow
07:00:30 <merijn> fizbin: In fact, this applies to any algebraic object
07:00:46 <fizbin> quicksilver: I hear people saying that, but I've never seen it in action. I may have to learn miles more CT first, but I get lost in an abstract mess of "prove X is a adjective1-adjective2 category" and never get to anything that's actually any more than a set of terminology for talking in extremely general ways about certain structures.
07:00:49 <merijn> randomclown: Slow compared to what?
07:01:19 <randomclown> merijn: you know what
07:01:28 <merijn> randomclown: Not really
07:01:35 <fizbin> So extremely general, in fact, that you can't actually prove anything true about categories in general beyond "they are categories"
07:01:47 <randomclown> merijn: most imperative lanugages
07:01:48 <merijn> randomclown: Nowadays everyone is hyping programming in JavaScript everywhere, so clearly speed isn't a goal
07:01:55 <merijn> randomclown: I highly doubt that
07:02:12 <c_wraith> randomclown: really?  I've heard people use ruby
07:02:16 <merijn> randomclown: In fact, most imperative languages are much slower, I can think of maybe a handful languages faster than haskell
07:02:19 <c_wraith> randomclown: and ruby is *sloooooooooow*
07:02:28 <randomclown> c_wraith: scripting languages don't count :)
07:02:30 <merijn> C, D, C++, Rust, maybe LuaJIT
07:02:39 <randomclown> merijn: + java
07:02:41 <fizbin> merijn: There exist though actual, interesting proofs about monoids. I have never seen such about categories.
07:02:42 <c_wraith> randomclown: define "scripting"
07:02:46 <randomclown> I'm personally hyped for java 8
07:02:49 <merijn> randomclown: Java isn't much faster than haskell
07:02:54 <merijn> If at all
07:03:03 <randomclown> merijn: it sure is, jvm's one hell of a drug
07:03:04 <DR6_> isn't java slower than haskell?
07:03:06 <c_wraith> Java's often slower than haskell, due to poor control over memory use.
07:03:30 <merijn> Anyway, this sounds isomorphic to trolling, so I'm gonna do something productive
07:03:34 <prophile> JVM languages can be faster, but only if you take rather dramatic steps to control memory usage
07:03:35 <fizbin> c_wraith: As though we don't have poor control over memory use in haskell too.
07:03:43 <quchen> Oh look, it's that discussion again. Did the world start writing large matrix diagonalization algorithms exclusively again? Haskell's screwed!
07:03:45 <c_wraith> fizbin: strangely, we have more control than java
07:04:03 <merijn> quchen: Not really, carter's working on high performance matrix stuff in haskell :)
07:04:22 <randomclown> nah high performan matrix stuff is written in cuda/opencl
07:04:39 <quchen> merijn: Well then pick another fastest-lib-consists-of-hand-optimized-ASM-C function
07:04:44 <fizbin> I'll agree that with bang patterns we can do some interesting memory flattening, but it's trivial in haskell to accidentally wind up somewhere trailing a gigantic chain of thunks.
07:04:58 <randomclown> fizbin: then spend a few ours profiling
07:05:02 <randomclown> hours*
07:05:23 <c_wraith> fizbin: bad java code is just as bad as bad haskell code.  Good haskell code is usually better than good java code.
07:05:28 <fizbin> And I'd argue that finding the memory leak in Java - painful as that is - is easier to do than in haskell.
07:05:43 <c_wraith> I have never had a problem finding a memory leak in haskell
07:05:53 <c_wraith> I don't understand complaints that it's hard.
07:06:16 <quchen> c_wraith: I don't understand how it's *always* easy. Write a tutorial about how you do it? I'm serious.
07:06:23 <randomclown> java's memory usage can be really bad sometimes, but it's scores on the benchmark game is pretty good
07:06:38 <randomclown> 2x c is in the really-decent tier
07:07:11 <c_wraith> quchen: sadly, it isn't something I can really explain.  I only understand it at the level I understand arithmetic.  1 + 1 *is* 2.  I can't explain why, it just is.
07:07:19 <randomclown> or even 1x c
07:07:35 <prophile> but my minecraft is laggy, qed
07:07:37 <DR6_> randomclown: GHC haskell is faster there though
07:07:38 <vermeille> How does Haskell deals with asynchronicity of evenemential programming?
07:07:54 <vermeille> OR*
07:07:55 <c_wraith> vermeille: what's evenemential?
07:08:02 <fizbin> For certain types of benchmarks, it's essentially impossible to beat mutable state. Mutable state is bad because managing it slowly become intractable for mere mortals, but it's really damn fast for those things where mutable state is useful.
07:08:11 <nicoo> vermeille: Lookup FRP
07:08:14 <randomclown> DR6_: not on average
07:08:24 <randomclown> haskell's ranked behind scala
07:08:38 <pjdelport> fizbin: Good thing Haskell has good support for mutable state. :)
07:08:55 <vermeille> c_wraith: something like a button on a GUI, some data received on the network, a thread just finishing its computation etc
07:09:08 <Maior> vermeille: quite well ime
07:09:21 <fizbin> Right, but haskell's mutable state support is deliberately cumbersome and a special case, and not just "the way everything is always", as with C.
07:09:49 <vermeille> Haha, I don't ask how does it do in terms of quality, but in terms of style / theory / internal representation
07:09:50 <DR6_> as it should be
07:09:52 <c_wraith> vermeille: oh, "event-based" in english?
07:09:58 <randomclown> fizbin: nah, it should be way easier, typing IORef gets tiring after a while
07:10:03 <fizbin> This means that for certain benchmarks, it becomes much, much harder to write a particular speed algorithm in haskell than in C.
07:10:09 <vermeille> c_wraith: that. Apologies.
07:10:28 <fizbin> But that's okay. I'm fine with haskell not being C.
07:10:41 <randomclown> I think it's clear for a lot of cases of programming (i.e. DP stuff) mutatable state is a huge win
07:10:42 <pjdelport> fizbin: On the flip side, the apparent ease with which you can do something in C often just means you're doing it wrong.
07:10:44 <quchen> Being like C would make Haskell quite redundant.
07:10:59 <randomclown> quchen: you get all that function stuff as a bonus
07:11:11 <pjdelport> Haskell does a better job of not hiding the pitfalls, and forcing you to be correct from the outset.
07:11:12 <fizbin> pjdelport: Right, which is one of the reasons I'm fine with haskell not being C.
07:11:15 <japesinator> is there a good general purpose division function in haskell?
07:11:29 <c_wraith> vermeille: GHC's IO system is entirely event-driven at a low level.  But it chose to not force users to deal with that explicitly, since it becomes nearly impossible to reason about (see node.js for an example of that).
07:11:35 <japesinator> (/) doesn't work on integers, and div doesn't work on anything else
07:11:37 * hackagebot antagonist 0.1.0.16 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.16 (implementation)
07:11:49 <pjdelport> So some would say that's just an observation that you can write bugs easier and faster in C. :)
07:11:51 <randomclown> japesinator: I think you need to fromIntegral to convert to double
07:11:54 <randomclown> then (/) on double
07:11:56 <Maior> japesinator: what do you mean "doesn't work"?
07:11:56 <randomclown> then (/) on double
07:12:06 <c_wraith> japesinator: there isn't such a function because it doesn't make logical sense
07:12:23 <c_wraith> japesinator: the two different division operators mean different things.
07:12:32 <c_wraith> japesinator: you can't just pretend they mean the same thing.
07:12:40 <orion> What flag do I need to pass to ghc to have it link in an external C library?
07:12:41 <vermeille> c_wraith: That's interesting, where could I find some interesting articles about that?
07:12:51 <randomclown> orion: are you building with cabal?
07:12:55 <c_wraith> vermeille: look for anything about the GHC IO Manager
07:12:58 <orion> randomclown: no
07:13:01 <orion> by hand
07:13:08 <merijn> @quote who.do.you.call
07:13:09 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
07:13:12 <deweyvm> is there a way to express "If you have Bar and Baz instances you get Foo for free, but otherwise you can define a Foo instance yourself without the other two"
07:13:20 <randomclown> orion: you should use cabal it's really easy
07:13:28 <japesinator> I'm trying to write a scheme interpreter that can deal with complexes, rationals, floats, and integers
07:13:29 <orion> randomclown: I will, but later.
07:13:34 <deweyvm> or does that clash with open world assumption?
07:13:37 <orion> For now I want to compile by hand.
07:13:46 <randomclown> orion: (no idea how to add it manually)
07:13:46 <merijn> vermeille: Basically, haskell's runtime system has lightweight threads, similar to Go's "goprocesses" or erlang processes
07:13:46 <japesinator> this should ideally have a general-purpose division function
07:14:04 <Earnestly> libgreen
07:14:10 <c_wraith> japesinator: and what does it do if different arguments have different types?
07:14:21 <mornfall> merijn: that rhyme is a bit of a stretch ;-)
07:14:28 <merijn> vermeille: i.e. thousands (on a normal desktop you can probably handle >100k threads) of lightweight threads that the runtime system multiplexes on a set of OS threads (usually you'd have like 1 OS thread per core)
07:14:31 <fizbin> japesinator: I suggest then that you make your own typeclass and add a generalizedDiv to it.
07:14:35 <DR6_> deweyvm: that's not possible
07:14:49 <japesinator> but when I try to add a case for parsing (/) I get "could not deduce (Fractional a) arising from a use of /"
07:14:49 <DR6_> you can use a newtype to provide the "free" instance however
07:15:02 <merijn> deweyvm: DR6_ is not quite right
07:15:03 <pjdelport> japesinator: In Scheme terms, Haskell's (/) is Scheme's /, and Haskell's div is Scheme's quotient
07:15:13 <merijn> deweyvm: You can probably get away with a default function using DefaultSignatures
07:15:18 <c_wraith> japesinator: you don't need a general-purpose division algorithm.  You need simple and sane rules for handling type coercion.
07:15:39 <DR6_> why?
07:15:39 <vermeille> merijn: I'm asking that because a friend of mine wants to write some distributed code, and I just wondered how a computation unit (more or less equivalent to a server) can notify the master that its computation finished
07:15:47 <merijn> deweyvm: Although then someone still has to write a standalone "deriving" clause
07:16:12 <mornfall> c_wraith: type coercion is apparently a huge can of worms
07:16:19 <merijn> vermeille: Distributed across multiple machines?
07:16:23 <vermeille> merijn: yes
07:16:28 <randomclown> "fromIntegral" is a massive eyesore though, is there a shorter name alias?
07:16:29 <deweyvm> *looks up DefaultSignatures*
07:16:30 <c_wraith> mornfall: But that *is* what the problem calls for.
07:16:47 <pjdelport> You have to implement Scheme type coercion to implement Scheme, though. It's part of the language.
07:16:50 <c_wraith> mornfall: you can either hide it with a terrible type class, or make it explicit
07:17:07 <randomclown> double :: fromIntegral, then you can do c style casts! (double) myint
07:17:10 <merijn> deweyvm: DefaultSignatures lets you provide a default implementation with a less general type signature than the actual function. Users still need to derive an instance for their types, though
07:17:17 <randomclown> double = fromIntegral*
07:17:25 <pjdelport> (and it won't just be fromIntegral; Scheme has a bunch of rules)
07:17:47 <deweyvm> that sounds handy, thanks
07:18:06 <merijn> deweyvm: i.e. imagine a class "class Pretty a where pretty :: a -> String" you could use default signatures to define a default implementation of "pretty :: Show a => a -> String"
07:18:22 <merijn> deweyvm: But that doesn't "magically" work, you still need "instance Pretty MyType"
07:18:28 <c_wraith> pjdelport: are scheme's coercion rules at least sane?  Like no implicit conversions from String to numeric types?
07:18:31 <quicksilver> fizbin: yes, tehre isn't much you can say about categories in complete generalities. It's always categories-with-X,Y,Z. It's still a useful general gramework.
07:18:40 <pjdelport> c_wraith: Oh, yeah.
07:18:47 <deweyvm> sounds like just what i want
07:18:50 <pjdelport> It's mostly to do with exact vs. inexact number types.
07:18:54 <pjdelport> and stuff like that
07:19:52 <deweyvm> thanks :)
07:20:25 <japesinator> what about declaring an instance of (/) int int?
07:20:33 <japesinator> would that be an option?
07:20:48 <pjdelport> c_wraith: If you're interested, http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.2
07:20:52 <prophile> the (/) operator doesn't make sense for integers
07:21:12 <fizbin> quicksilver: I'll grant that it's a common language. I'm not sold though on the idea that CT provides any particular insight by itself. At best it seems an occasionally convenient way to summarize some non-CT result that actually proved something.
07:21:15 <prophile> how would you define recip?
07:21:32 <c_wraith> japesinator: the semantics of (/) require that if a / b = c, then c * b = a
07:21:45 <c_wraith> japesinator: you cannot implement that operation for Int
07:21:57 <japesinator> c_wraith: why not?
07:22:02 <merijn> fizbin: Category theory isn't meant to have insight by itself
07:22:18 <merijn> fizbin: Category theory attempts to generalise different fields of mathematics into a common language
07:22:20 <c_wraith> japesinator: find me a c for which that's true if a = 5 and b = 3
07:22:33 <fizbin> merijn: Hence my conclusion that it's basically Smurf Theory.
07:22:33 <merijn> fizbin: I had a nice set of slides, let me see if I can find them again
07:22:38 <DR6_> japesinator: because integer division has remainders
07:22:54 <japesinator> can't my instance return values that aren't Ints?
07:23:05 <japesinator> for instance 5/3 for the problem you gave?
07:23:09 <c_wraith> japesinator: then you're doing type coercion
07:23:09 <prophile> :t (/)
07:23:10 <lambdabot> Fractional a => a -> a -> a
07:23:21 <c_wraith> japesinator: if you're doing type coercion, do it *correctly*
07:23:35 <japesinator> what would be the correct way of doing type coercion?
07:23:36 <pjdelport> > let a // b = fromIntegral a / fromIntegral  b in (5 :: Int) // (3 :: Int)
07:23:38 <lambdabot>  1.6666666666666667
07:23:39 <merijn> fizbin: http://homepages.inf.ed.ac.uk/jcheney/presentations/ct4d1.pdf especially slide 6
07:23:51 <c_wraith> japesinator: that is, *before* applying arithmetic operations, and according to the rules for scheme
07:23:56 <pjdelport> japesinator: That's not necessarily "correct" or useful, but you can do it.
07:24:14 <japesinator> :t fromIntegral
07:24:15 <lambdabot> (Num b, Integral a) => a -> b
07:24:36 <pjdelport> japesinator: It probably won't help you implement Scheme, though; you'll have to implement Scheme's coercion rules.
07:25:19 <japesinator> won't that not work for complexes/floats?
07:25:33 <japesinator> do I need to do something weird with Data.Typeable?
07:25:50 <merijn> japesinator: No, you need to reconsider your approach to the problem :)
07:25:54 <pjdelport> japesinator: No; you'll be working explicitly with types.
07:26:20 <pjdelport> japesinator: Your implementation of Scheme's / will take two Scheme numbers, and will do various different things depending on the exact types of those numbers.
07:26:27 <japesinator> merijn: how would you suggest approaching the problem?
07:26:41 <japesinator> pjdelport: yeah, that's the plan
07:26:42 <merijn> japesinator: Implement it separately from Haskell's typeclass framework
07:26:50 <merijn> Then you can write whatever you like
07:26:53 <c_wraith> japesinator: and you well know what types things are by what constructors they used
07:27:09 <merijn> Judging from the mention of Scheme I'm assuming you're attempting to implement a simple Scheme?
07:27:21 <japesinator> merijn: yeah, that's the plan
07:27:27 <pjdelport> japesinator: For example, if you get two Scheme exact integers, you should always return an exact integer of the same type, unless the result is fractional, in which case you'll return a Scheme rational or real, etc.
07:27:54 <c_wraith> *will* know
07:27:56 <merijn> japesinator: Instead of trying to directly emulate Scheme in haskell, implement scheme's functionality as functions and call to the "right" functions
07:28:19 <japesinator> merijn: what would be a good way to do that?
07:28:45 <c_wraith> stop thinking you can treat scheme values uniformly.  You can't.  You need to discriminate based on their constructors
07:28:50 <pjdelport> japesinator: How do you represent Scheme's number tower at the moment?
07:28:52 <merijn> japesinator: Parse scheme, construct AST, write functions that can evaluate ASTs with the correct Scheme behaviour and do that
07:29:36 <merijn> japesinator: I frequently see newbies trying to implement Scheme or other languages as EDSL in haskell, it almost always backfires as haskell semantics usually don't quite allow what the EDSL needs
07:29:52 <merijn> japesinator: Have you read "Write Yourself a Scheme in 48 Hours"?
07:30:13 <pjdelport> japesinator: Have you read through http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.2 too?
07:30:53 <japesinator> https://gist.github.com/11181374
07:31:05 <japesinator> merijn: that's the basis of what I'm trying to do
07:31:17 <carter> quchen: for those hand asm innner loops, FFI has me covered //cc  merijn
07:31:29 <japesinator> I implemented the full number tower earlier and now it's making it tough to write the evaluator
07:32:43 <quchen> carter: Hey! How advanced is the project Merijn was talking about? Is it publically available yet, does it have a readme?
07:33:13 <japesinator> I'm not opposed to changing my implementation though
07:33:20 <pjdelport> japesinator: You'll need some more work, there; e.g. division doesn't always give you an Integer
07:33:27 <japesinator> that was just what seemed most logical to me
07:33:28 <carter> the read me currently included the phrase "less stable than an undwatter sandcastle in a hurrican"
07:33:38 <japesinator> of that makes sense
07:33:59 <pjdelport> japesinator: And you'll probably need to introduce a notion of exact vs. inexact numbers
07:34:00 <quchen> carter: So I'm assuming that's a "no" then :>
07:34:02 <merijn> huricane have very little underwater influence :p
07:34:03 <japesinator> what if I change the last Integer on line 29 to a Rational?
07:34:12 <carter> quchen: i'll be cutting an alpha this week i hope
07:34:17 <carter> that'll be very bare bones
07:34:21 <carter> i'm very pleased with the design though
07:34:34 <pjdelport> (unless you're not really worried about implementing Scheme that faithfully)
07:34:51 <quchen> carter: Why did you start this project? I'm assuming out of curiosity?
07:34:51 <carter> the goal for the alpha is to have high level code thats with 10-20x of the hand tuned asm/fortran
07:35:00 <carter> quchen: 'cause I wanted nice things
07:35:09 <carter> i've been iterating on the api design for 2 years...
07:35:14 <japesinator> I'm doing this more to learn haskell than to write the best possible scheme
07:35:31 <quchen> carter: Sounds really interesting!
07:35:51 <quchen> carter: So it's Haskell plus ASM via FFI? Or did you write C bits?
07:35:57 <quchen> Maybe I should just want for that readme ;-)
07:36:00 <carter> nope
07:36:05 <carter> thats not the key  bit
07:36:16 <carter> key bit is memory locality
07:36:18 <pjdelport> japesinator: R5RS gives the full details, but if you have exact inputs, you should generally give exact outputs, as far as possible.
07:36:29 <carter> if you dont got good mem locality, your inner loop dont matter none
07:36:42 <pjdelport> Unless the result is not expressible as an exact number, in which case you can fall back to an inexact type.
07:36:53 <quchen> Unfortunately I don't know much about memory locality :-(
07:37:13 <merijn> Oh god yes! It looks like 7.10 will have partial type signatures!
07:37:34 <quchen> merijn: You mean holes in type sigs?
07:37:38 <merijn> quchen: Yeah
07:37:52 <quchen> I read about that too, sounds exciting
07:38:16 <pjdelport> japesinator: so (/ 6 3) gives you an exact integer 2; (/ 5 3) may give you either an exact rational, or an inexact real (float)
07:38:30 <merijn> It'll make working with fancy type family stuff less annoying, not having to specify ridiculously long type signatures for complex types
07:39:07 <quchen> It will also help writing functions taking Lens parameters: just leave the lens blank and let the compiler infer which one is required.
07:39:24 <quchen> "Hide the cumbersome but inferrable types", basically.
07:40:01 <c_wraith> Or functions written on GADTs
07:41:08 <_d0t> hi. I want to make use of constants defined in system headers (/usr/include/blah-blah). What is the best way to do that?
07:41:24 <c_wraith> _d0t: probably hsc2hs
07:41:56 <orion> hm
07:42:03 <_d0t> c_wraith: so I just #include them in a hsc file, use hsc2hs and then proceed as usual?
07:42:08 <pjdelport> japesinator: The key change you'll have to make is that your lispMath shouldn't take a *Haskell* function as parameter; it should take the desired Scheme operation as parameter, and decide the appropriate implementation based on that (and the parameter types)
07:42:21 <c_wraith> _d0t: well, you'll need to bind them to a haskell name that the module exports.
07:42:50 <c_wraith> _d0t: but then, yes.  also, cabal handles running hsc2hs for you automatically, which is nice
07:43:06 <orion> I have a function with this sig: box :: PublicKey -> SecretKey -> Nonce -> ByteString -> ByteString -- I am trying to call it from IO (), but I get this error: Couldn't match expected type `IO t0' with actual type `B.ByteString'
07:43:33 <_d0t> c_wraith: how exactly do I "bind" them?
07:43:49 <c_wraith> _d0t: name = #CONSTANT
07:44:12 <c_wraith> _d0t: where "name" is the haskell name for the value that will be exported by the module
07:44:13 <quchen> orion: What do you mean with "call from IO"?
07:44:28 <geekosaur> orion: most likely you have to fmap it over the IO thing. and read the stuff in LYAH about how IO works again
07:44:47 <pjdelport> orion: Are you saying "foo <- box [...]" instead of "let foo = box [...]" ?
07:44:51 <orion> Ah yes
07:44:54 <quchen> Your function does not involve IO, there is no need to have it in IO. If you want to use the resulting BS in an IO block, you can give it a name with "let".
07:44:54 <orion> You're right
07:45:10 <orion> Thank you. That's right.
07:45:13 * orion forgot :<
07:45:29 <c_wraith> _d0t: I believe the hsc2hs docs have more information about doing stuff like this.  It's a relatively common thing to do.
07:45:31 <japesinator> pjdelport: what would be the best way to do that?
07:45:37 <_d0t> c_wraith: ok, thank you
07:45:46 <carter> quchen: the point of my work is to make it easy to not know the locality stuff
07:46:02 <carter> though it basically boils down to "do sequential scans for everything"
07:47:17 <pjdelport> japesinator: Your LispNumber type is a reasonable; I would start by defining Scheme's exact? and inexact? for each of the cases.
07:47:48 <c_wraith> _d0t: http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html#id654451 is a good place to get examples
07:48:25 <pjdelport> japesinator: Your first level of matching for the operators will probably be on exactness: you'll have an exact implementation of most of the operators, and an inexact one.
07:49:35 <_d0t> c_wraith: #const pragma is what i was looking for. Thanks for your help.
07:52:40 <pjdelport> japesinator: So you can start with e.g. lispDivExact, and lispDivInexact: the inexact variant should always just return inexact results (e.g. float), while the exact variant should should first try to return exact results.
07:55:58 <tdammers> ah, working through "write yourself a scheme"?
07:59:56 <remib> Hi
08:02:51 <remib> In this code http://lpaste.net/4174714134471901184 . First I hadn't written the type signature for show. ghci told me "No instance for (Show a) arrising ...". Then I added the signature and it now tells "Illegal type signature...". I guess the error comes from expecting the type "a" to being an instance of "Show". What should I do then ?
08:04:11 <pjdelport> remib: You'll probably want a (Show a) constraint on BinaryTree itself.
08:04:45 <pjdelport> remib: or on the instance
08:05:41 <prophile> remib: get rid of the type signature for "show" in the instance
08:05:45 <prophile> and add a (Show a) => constraint
08:09:43 <remib> where exactly should I add this constraint ?
08:10:15 <pjdelport> remib: Reload the paste; I added an annotation.
08:11:20 <remib> mmh, interesting
08:11:26 <remib> didn't know this notation
08:12:25 <remib> If that's adding the constraint to the instance, how would you add it to the type itself ?
08:12:39 <pjdelport> remib: Basically, you're saying that you can only show trees whose leaf type is showable too.
08:14:23 <remib> Thanks for the help !
08:14:56 <pjdelport> Adding it to the type itself is actually not a good idea; forget I suggested that. :)
08:16:40 <remib> ok, forgotten!
08:17:10 <pjdelport> http://www.haskell.org/haskellwiki/Data_declaration_with_constraint if you want the full story
08:18:59 <nulldata> Hello
08:22:31 <remib> ok
08:23:07 <remib> It actually seems cleaner to put the constraint on the instance, as you said.
08:24:10 <allsystemsarego> hi all, how do I tell quickcheck to generate 10000 random inputs instead of the default 100? "defaultConfig" that the Haskell wiki talks about has been deprecated
08:26:11 <pjdelport> remib: It allows you to declare a Show instance for trees of non-showable types, too
08:26:17 <DR6_> use quickCheckWith
08:26:23 <hexagoxel_> remib: there is a ghc language extension (InstanceSigs) that allows type signatures in instances
08:26:37 <DR6_> http://hackage.haskell.org/package/QuickCheck-2.7.3/docs/Test-QuickCheck.html
08:26:48 <pjdelport> remib: You just won't be able to show the values, in that case, but you can show the structure of the tree with value placeholders (for example).
08:28:35 <c_wraith> allsystemsarego: use quickCheckWith stdArgs { maxSuccess = 1000 } properties
08:28:58 <c_wraith> err, 10000 instead of 1000.  but whatever
08:30:00 <allsystemsarego> c_wraith, thanks, I'll try it
08:30:29 <edvo> I have written a reimplementation of wc in two versions, one with String and one with ByteStrings. I expected the ByteString version to perform faster but in fact they are equally fast. Could you have a quick look over the code to see, if I had missed something? https://gist.github.com/anonymous/987f6ac6bbef8c431ce4
08:30:36 <remib> hexagoxel_ : thanks, I'll check that!
08:40:00 <pjdelport> edvo: The way that's implemented, they'll probably be comparable (with ByteString using less memory, maybe)
08:40:43 <pjdelport> edvo: String performance will probably start to suffer as soon as you do more than just processing the whole input char-by-char in one pass
08:41:01 <pjdelport> that's basicaly a best-case-scenario for String
08:41:42 <edvo> pjdelport: i suspected that. so in that case, fusion will take place?
08:44:08 <pjdelport> edvo: it probably doesn't make a major difference, in this case
08:44:55 <pjdelport> you could always look at the generated core, to see exactly what's happening
08:45:04 <c_wraith> foldl doesn't fuse
08:45:12 <c_wraith> at least with lists
08:45:23 <edvo> oh of course, you are right
08:45:25 <c_wraith> So there's no opportunity for benefit there
08:46:10 <edvo> i just thought that String, being a linked list, should be slower and wondered, if i had missed an optimization opportunity for the ByteString version
08:48:04 <shachaf> ByteString isn't a String competitor.
08:48:17 <shachaf> ByteString is like [Word8].
08:48:19 <tdammers> Text is
08:48:29 <tdammers> ByteString is pretty much a byte array
08:48:33 <shachaf> Data.Text is a String competitor, yes.
08:48:48 <edvo> yes, but than ByteString should be even faster, because it doesn't have to deal with unicode decoding
08:48:57 <edvo> *then
08:49:27 <pjdelport> edvo: well, you're doing (fromIntegral . ord)
08:49:31 <tdammers> depends on the context... if you need to maintain utf-8 well-formedness, decoding and encoding might actually be the fastest way
08:49:37 <shachaf> If you "don't have to deal with unicode decoding" then you probably shouldn't be using String in the first place.
08:49:46 <shachaf> But I don't know what you're doing.
08:49:55 <shachaf> Oh, counting words.
08:50:02 <pjdelport> edvo: if you left it as Char, and wrote a separate step, the Char isSpace would probably make it noticeably slower
08:50:40 <edvo> pjdelport: Data.Char.isSpace is much slower, but if I use it with both versions, both are again equally slow
08:50:42 <tdammers> counting words "works" because utf-8 was designed as a superset of ascii
08:50:43 * shachaf sighs
08:50:59 <merijn> quchen: Join is indeed part of Monad in the new patch, so that part of the proposal is going through too
08:50:59 <carter> point being: for human text, use Text
08:51:02 <pjdelport> edvo: right
08:51:03 <carter> for binary data use bytestring
08:51:04 <edvo> pjdelport: i just used Data.Word8.isSpace to be faster than wc
08:51:10 <magicman> What is the recommended library for command line argument handling? Any consensus, or should I just System.Console.GetOpt it?
08:51:11 <carter> merijn: join is awesome
08:51:13 <quchen> merijn: "the new patch"?
08:51:18 <carter> opt parse applicative
08:51:23 <quchen> Did Austin push it already?
08:51:28 <magicman> Cheers!
08:51:35 <merijn> quchen: It's linked on r/haskell, so presumably yes :p
08:51:43 <tdammers> come to think of it, if all you know is that your input is encoded in some superset of ascii, then bytestrings might actually be the "correct" choice
08:52:42 <quchen> merijn: Oh, it's on its own branch. Anyway, join is in, great.
08:55:02 <edvo> hm, actually, it might be an optimization of ghc
08:55:04 <edvo> 7.8
08:55:14 <edvo> with 7.6 the String version is considerably slower
08:55:22 <pseudolio> magicman: getopt isn't great. optparse applicative is okay. Nothing is truly great, I think.
08:55:31 <pseudolio> I haven't done an exhaustive study, though.
08:55:54 <tdammers> for option parsers, I actually use parsec or something similar these days
08:56:38 <carter> pseudolio: how many irc hanles do you have?
08:57:12 <pseudolio> cmdargs is popular, too. But unless you use its unsafe interface, I think it's an inferior API to optparse applicative, and using the unsafe api has its downsides.
08:57:24 <pseudolio> carter: Three for home and three for work, at least.
08:57:24 <Earnestly> tdammers: Out of passing curiosity, would you mind sharing an example of using parsec for that?
08:57:47 <carter> pseudolio: are they all active?
08:57:54 <pseudolio> They're registered.
08:57:54 <carter> just device dependent?
08:58:15 <pseudolio> They rotate when ghosting happens.
09:00:18 <magicman> Hrm. I'm not sure if I like the dependency on ansi-wl-pprint and process, but the rest looks neat. I'll take a look :)
09:05:59 <orion> How do I force cabal to pass extra arguments to ghc?
09:07:14 <BeardedCoder> orion: ghc-options?
09:09:00 <orion> BeardedCoder: Do you know if that is that the proper place to stick -optl-Wl,-rpath,'..."?
09:09:38 <arkoriex> When I run ghc-pkg check, every package shows this message: <package-name>.haddock doesn't exist or isn't a file. How can I fix this?
09:09:44 <BeardedCoder> orion: no idea sorry. I've only written a handfull of Haskell apps and used flags such as -threaded and -Wall
09:13:21 <pbostrom> hello, I'm just getting started with Haskell - when I quit emacs with ghc running in inferior haskell, it crashes my macbook: https://gist.github.com/pbostrom/11184737 this is ghc 7.6.3 from the Haskell Platform binaries
09:14:53 <bennofs> Does anyone have an idea what could cause this: http://hydra.nixos.org/build/10389247/log/tail-reload ? Is it a bug in haddock?
09:16:40 <thoughtpolice> bennofs: i can't make any assumptions unless i actually see how it faulted
09:17:10 <thoughtpolice> i.e. you'd probably need to drop to nix-shell and manually build, i think, which might actually give the output you want
09:17:32 <bennofs> thoughtpolice: the problem is "Not a data constructor: `forall'"
09:17:42 <bennofs> thoughtpolice: it's an error from haddock
09:18:28 <bennofs> thoughtpolice: The file in question does have {-# LANGUAGE ..., ExistentialQuantification, ... #-} at the top
09:19:05 <thoughtpolice> bennofs: oh, i just completely missed that error, sorry
09:40:54 <Ainieco> hello
09:41:55 <Ainieco> i have a World { history :: History, people :: People, relations :: Relations} record type
09:42:59 <Ainieco> also i have function which takes old relations and returns new relations
09:43:17 <Ainieco> i want that functio to log changes into world history
09:43:55 <bennofs> thoughtpolice: seems to be a bug in ghc 7.6.2's haddock. If I place the language pragma on a new line, everything works fine
09:44:07 <Ainieco> could you please give me insight on how can i accomplish it? i'm fine with changing architecture
09:44:27 <vermeille> Writer monad!
09:44:28 <Ainieco> i.e replace "function which takes old relations and returns new relations" with something else
09:45:33 <bennofs> thoughtpolice: s/GHC 7.6.2/GHC 7.4.2/
09:45:58 <thoughtpolice> bennofs: hm, bizarre. hadn't heard of that one, otherwise i might've suggested it
09:46:24 <bennofs> thoughtpolice: yeah, googling for the error message didn't find it either
09:59:13 <joneshf-laptop> where does the intuition come from for using `intesectWith`: http://hackage.haskell.org/package/semigroupoids-4.0.1/docs/src/Data-Functor-Bind.html#line-189 ?
09:59:20 <joneshf-laptop> instead of something like `unionWith`?
09:59:33 <joneshf-laptop> is `intersectWith` the only valid instance for Data.Map
09:59:35 <joneshf-laptop> ?
10:00:47 <bennofs> @ty Data.Map.unionWith
10:00:49 <lambdabot> Ord k => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
10:00:54 <bennofs> @ty Data.Map.intersectionWith
10:00:56 <lambdabot> Ord k => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
10:01:08 <bennofs> joneshf-laptop: unionWith wouldn't typecheck
10:01:48 <bennofs> joneshf-laptop: in a <.> b, a is of type M.Map k (a -> b) and b is of type M.Map k b
10:02:09 <mm_freak> hi there
10:03:18 <mm_freak> i'm preparing a bunch of lenses for a crypto workshop, and here is one of them:  asciiLetter :: (Applicative f) => (Int -> f Int) -> Char -> f Char
10:03:39 <mm_freak> it views ASCII letters as their respective 0-indexed value (e.g. 'C' becomes 2)
10:03:44 <albeit> If I derive Eq on a data type defined with record syntax, will the "==" it generates just check if every field is equal?
10:04:12 <pavonia> albeit: Yes
10:04:14 <orion> I am using a library which defines this: newtype CombinedKey = CK ByteString deriving (Eq, Ord) -- but does not expose CK. How do I extract the ByteString out of this type;
10:04:23 <mm_freak> i noticed that i can do this with a Functor constraint by just passing the mapping function a bogus index…  it seems to be a wrong thing to do, but what would be the implications?
10:04:26 <fizruk> mm_freak: why is there Applicative and not Functor?
10:04:40 <mm_freak> fizruk: because it doesn't map non-letters at all
10:04:50 <pavonia> orion: If the isn't any accessor function, you don't
10:04:55 <mm_freak> so i can write rot-13 as:  traverse . asciiLetter +~ 13
10:05:22 <fizruk> mm_freak: then why not Prism?
10:05:46 <joneshf-laptop> bennofs, but is there anything about Data.Map that suggests that `intersectionWith` is the way to go for `<*>`?
10:05:58 <mm_freak> fizruk: mostly because i haven't defined my own prisms yet and Applicative seems to do exactly what i need
10:06:03 <mm_freak> let me paste the code
10:06:06 <bennofs> joneshf-laptop: what would the alternative be?
10:06:36 <joneshf-laptop> bennofs, I'm not entirely sure
10:06:55 <pavonia> joneshf-laptop: You would need default values with union for the values that are in only either of the maps
10:07:01 <mm_freak> fizruk: http://lpaste.net/103085
10:07:05 <orion> pavonia: If the library exposed the constructor (CK), would that be considered an accessor?
10:07:07 <fizruk> for prisms you need Choice profunctor, that might be unwanted dependency, I guess
10:07:31 <pavonia> orion: Kind of, youc could pattern match on it then
10:07:44 <mm_freak> fizruk: i don't really need a prism, because i don't need to construct letters by index
10:08:14 <pavonia> orion: By accessor function I mean something like toByteString :: CombinedKey -> ByteString
10:08:24 <orion> I see
10:08:27 <mm_freak> fizruk: anyway, that doesn't really answer my question
10:08:52 <fizruk> mm_freak: so how are you going to pass a bogus index?
10:09:04 <mm_freak> in many cases lenses like that can be constructed by passing the mapping function a bogus value and then ignoring its result
10:09:06 <bennofs> mm_freak: if you'd defined it as a lens, it would fail the lens laws.
10:09:22 <mm_freak> bennofs: ah, that makes sense
10:09:24 <mm_freak> thanks
10:09:32 <mm_freak> fizruk: otherwise = fmap (const c) (l 0)
10:09:47 <bennofs> mm_freak: view asciiLetter (set asciiLetter 3 'a') /= 3
10:09:49 <mm_freak> that's the Functor version, but yeah, it would be an improper lens
10:10:08 <joneshf-laptop> bennofs, so it's throwing away anything that doesn't match the "key" part of the Map. I would think the idea would be to preserve everything already in the Map and modify  just the ones of the left of `<*>`
10:10:18 <bennofs> oops, s/3/1000/
10:10:26 <fizruk> mm_freak: okay, then what bennofs said :)
10:10:43 <mm_freak> but the Applicative version is correct, isn't it?
10:12:22 <joneshf-laptop> i mean, the Functor preserves the shape of the Map, I thought Applicatives also had to preserve the shape of the Map
10:12:47 <joneshf-laptop> or i guess that's not true
10:12:47 <fizruk> mm_freak: seems correct to me
10:12:54 <pavonia> joneshf-laptop: What would be the result of "fromList [(1, succ), (2, pred)] <*> fromList [(0, 0), (1, 1)]" if you wouldn't use intersection on keys?
10:12:55 <joneshf-laptop> since [] is an easy counter example
10:13:34 <joneshf-laptop> pavonia, `fromList [(0, 0), (1, succ 1)]` I would imagine
10:13:35 <mm_freak> an Applicative/(->) optic is called a traversal, right?
10:13:42 <bennofs> mm_freak: yes
10:13:46 <bennofs> mm_freak: http://hackage.haskell.org/package/lens-4.1.2/docs/Control-Lens-Traversal.html
10:13:53 <mm_freak> alright, thanks
10:15:34 <pavonia> joneshf-laptop: Hhm, that would be a possible alternative version, one would have to check if the Applicative laws allow this version
10:16:23 <joneshf-laptop> I think i see where it fails
10:16:32 <bennofs> is data T = forall a. C a => T a the same as data T where T :: C a => a -> T ?
10:16:48 <mm_freak> joneshf-laptop: are you trying to write a Map applicative/monad?
10:16:58 <joneshf-laptop> fromList [(1, (+)), (2, (*))] <.> fromList [(1, 3), (2, 7)] <.> fromList [(1, 5)]
10:17:01 <bennofs> joneshf-laptop: what would "fromList [(1, even), (2, odd)] <*> fromList [(0,0), (1,1)]" be?
10:17:12 <joneshf-laptop> that would give you back someting with different types
10:17:33 <joneshf-laptop> bennofs, yeah, i see it
10:17:57 <pavonia> Ah, that's an even better example
10:17:59 <joneshf-laptop> mm_freak, nope, just trying to understand why `intersectionWith` was chosen for the Apply instance
10:18:21 <joneshf-laptop> bennofs, pavonia thanks
10:18:37 <KatZilla1> Hi there.
10:18:56 <KatZilla1> How to run hDevTools in cabal-sandbox environment ?
10:19:42 <bennofs> KatZilla1: https://github.com/dan-t/cabal-cargs
10:19:45 <KatZilla1> I have a project, and when Sublime tries to check syntax of file, it cant find import modules/libs, because I installed them in
10:19:50 <KatZilla1> sanndbox
10:19:55 <KatZilla1> bennofs: thx !
10:27:12 <vermeille> What is ~(x, y) ?
10:27:27 <shachaf> Hoogle will tell you what ~ means.
10:27:46 <vermeille> I tried a :t in ghci and I get insulted :D
10:28:11 <CindyLinz> vermeille: irrefutable pattern
10:28:46 <eiro> vermeille, http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching
10:31:23 <mm_freak> > case undefined of (x, y) -> ()
10:31:25 <lambdabot>  *Exception: Prelude.undefined
10:31:28 <mm_freak> > case undefined of ~(x, y) -> ()
10:31:29 <lambdabot>  ()
10:32:50 <vermeille> thanks eiro, that was helpful
10:33:27 <shachaf> Another resource that is helpful is Hoogle, which would have given you the same link.
10:34:40 <vermeille> I didn't try Hoogle because it seemed not to be a regular function (which is the case) but hoogle documents it anyway, my bad.
10:35:21 <bergmark> didn't know hoogle did that either
10:38:35 <bennofs> thoughtpolice: turns out that it's enough to just build, run haddock (-> error message), slightly change the file (for example, add a comment) and then run haddock again (-> no error message now)
10:43:32 <JordiGH> I wanted to make a Snake game as an exercise. I'd like to begin by picking some sort of library for displaying the game, perhaps ncurses, perhaps something else. Any suggestions?
10:44:16 <Cale> JordiGH: Maybe gloss?
10:44:36 <Cale> http://hackage.haskell.org/package/gloss
10:45:18 <JordiGH> Looks like hackage it will be, since Debian doesn't package it.
10:45:34 * JordiGH wishes each programming language didn't have its own package manager.
10:46:12 <ReinH> JordiGH: You should definitely be using cabal/hackage
10:46:56 <JordiGH> ReinH: And gems and pip and easy_install and macports and homebrew...
10:46:59 <JordiGH> I wish I could just use apt.
10:47:13 <ReinH> JordiGH: yep, but that's how it is
10:47:29 <JordiGH> Normally I do. I've managed to figure out how to turn other languages into debs, hopefully there's something similar for Haskell.
10:47:32 <ReinH> until someone makes the one package manager to rule them all
10:48:57 <KatZilla1> Hi there. Is there any 	`yesod --dev devel` alternative for SCOTTY webserver??  I want to reload server after changing source files
10:49:26 <Cale> I suppose it's possible that someone could write something to automatically produce .deb packages from cabal packages, and then apply it to all of hackage, but the main issue with just relying on debian's packages for things is that the process for getting packages into debian is a bit involved compared to just sticking some code on hackage.
10:50:29 <Cale> Also, there's the fact that package+version isn't enough to completely specify what has been built
10:50:54 <Cale> Sometimes it's important to know the versions of the dependencies it was built against.
10:51:05 <JordiGH> Cale: The involvement is good, I like people taking care to make sure the code works.
10:51:12 <JordiGH> That it works in the overall OS.
10:51:15 <sgregor__> I think its probably good that packages used for development aren't in distro package managers.. I've tried using package manager packaged gems, and its horrible.
10:51:50 <JordiGH> sgregor__: That's mostly because Ruby is or was horrible. I think they've gotten better about where to install stuff and not put everything under /usr/share
10:52:20 <mm_freak> just noticed that a prism doesn't even work for this…  it has to be a traversal
10:52:23 <sgregor__> JordiGH: I think its general problem when in order to share libraries, you have to share the source
10:54:19 <Cale> JordiGH: Well, if it would mean that about 80% of what's there would not be, and instead just be on some guy's computer, or github or something, then that also wouldn't be good.
10:54:59 <Cale> JordiGH: I like having an easy way to install easily-user-contributed code
10:55:15 <JordiGH> And I don't trust most people to get it right.
10:55:23 <Cale> (and I'll decide if it's suitable for my purposes or not)
10:55:35 <JordiGH> Conan trusts nothing but cold, Cimmerian, Debian policy!
10:57:00 <ReinH> Well, do you want a large number of less-trusted libraries or a smaller number of highly-trusted libraries like OpenSSL?
10:57:17 <mm_freak> ReinH: OpenSSL highly trusted?
10:57:23 <ReinH> mm_freak: thatsthejoke.jpg
10:57:29 <mm_freak> ah
10:57:49 <ReinH> A long, involved process that places a large barrier to entry doesn't necessarily solve the trust problem
10:57:53 <ReinH> is my point
10:58:09 <ReinH> For anything critical you had best be doing your own due diligence anyway
10:58:22 <haasn> ReinH: Are the extremes “infinite number of completely untrusted libraries” and “zero amount of completely trusted libraries”? I think I'll take both
10:58:35 <ReinH> haasn: I suppose so :)
10:58:37 <aloiscochard> so, what's the recommend way to deal with exception potentially thrown by an IO? /cc monochrom
10:58:52 <Cale> aloiscochard: Control.Exception
10:58:53 <aloiscochard> I was going to use `try` to transform my IO with an Either e in it
10:58:58 <ReinH> aloiscochard: catching it in IO with, e.g., stuff from Control.Exception
10:59:01 <Cale> any of the stuff in there
10:59:06 <Cale> try is fine
10:59:10 <aloiscochard> cool, thanks folks :)
10:59:12 <Cale> or catch/handle
10:59:40 <haasn> Control.Exception.Lens
10:59:44 <haasn> That's what I recommend.
10:59:52 <Cale> Why?
10:59:58 <haasn> I think it's much easier to work with
11:00:13 <haasn> You don't need to mess around with ScopedTypeVariables or extra signatures on your lambdas, for example
11:00:27 <haasn> It's easier to match only certain types of exceptions (eg. File not found exceptions) while re-throwing others
11:00:29 <trism> JordiGH: there is cabal-debian in the repos, don't know how well it works in general but it just built a deb for a tiny project here without much issue
11:00:39 <aloiscochard> I should really get into that lens library
11:00:52 <aloiscochard> haasn: oh I see exactly what you mean
11:01:00 <Cale> Why would you need to mess around with ScopedTypeVariables?
11:01:01 <aloiscochard> haasn: not a big deal if I want to catch 'all' though?
11:01:05 * shapr imports Control.Freak
11:01:16 <haasn> Cale: I think \(_ :: IOException) -> ...  -- requires it
11:01:24 <ReinH> haasn: the exception lens stuff is great but maybe start with Control.Exception so you can understand it first?
11:01:27 <Cale> You don't need to ever do that
11:01:28 <haasn> aloiscochard: I don't think you ever want to catch ‘all’ (ie. SomeException)
11:01:32 <Cale> Just pattern match normally
11:01:35 <JordiGH> trism: Great, thanks.
11:01:40 <CindyLinz> aloiscochard: If you want to build your own Monad library that support exceptions. I'll recommend package 'exceptions' http://hackage.haskell.org/package/exceptions-0.3.1/docs/Control-Monad-Catch.html
11:01:52 <aloiscochard> haasn: that's right, I just do it to print the exception to know how to have the right granularity
11:02:03 <haasn> ReinH: Yes, that's the right pedagogical approach. I just figured that's what the “recommended” way to catch exceptions is, at least for my own personal opinion
11:02:11 <ReinH> Ah.
11:02:22 <haasn> Cale: What do you mean?
11:02:27 <Cale> Ah, right, IOException doesn't export any constructors. Well, that's solvable :)
11:02:29 <aloiscochard> good to know haasn, I'll look into it once more familiar with lens
11:02:56 <haasn> Cale: Yeah, you can work around it for sure, by finding other places to put the type signature
11:03:00 <Cale> haasn: I mean just match on the actual constructor
11:03:18 <Cale> In most cases, the exception you're catching is an algebraic type with one or more constructors
11:03:22 <haasn> Cale: But the lens API makes this easier and it's not that much more confusing - assuming lens understanding as a prerequisite. It also allows you to do some really fancy things that get more complex with the normal API :)
11:03:40 <Cale> and just casing on that type will be enough to determine which type it is
11:03:52 <haasn> The only reasons I see to not use it is “1. lens is too confusing” and “2. lens is a big dependency”
11:04:07 <aloiscochard> do you guys have some particular materials to recommend when it comes to diving into lens?
11:04:13 <haasn> These are not issues I worry about; if they are, my advice may be considered void :)
11:04:14 <Cale> Well, it does seem like a lot of machinery to pull in if you're only using exceptions in a trivial way
11:04:35 <ReinH> Cale: you don't auto-import lens in everything? :p
11:05:20 <Cale> ReinH: No, I only use lens when it really makes a big difference.
11:05:30 <CindyLinz> lens depend on the hackage.. (flee)
11:05:31 <ReinH> Cale: me neither, but I do seem to end up using it anyway
11:06:14 <Cale> I also pretend that all its infix operators don't exist
11:06:34 <ReinH> hah
11:06:56 <ReinH> CindyLinz: on pretty much all of hackage, yes ;)
11:07:04 * hackagebot ffmpeg-light 0.4 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.4 (AnthonyCowley)
11:08:21 <CindyLinz> XD
11:08:52 <bennofs> thoughtpolice: :O I noticed that if I run haddock before running build, it works
11:09:35 <ReinH> ooh acowley has an ffmpeg binding. Cool.
11:11:36 <bennofs> Is there a difference between 'Setup build; Setup haddock' and 'Setup haddock; Setup build' ?
11:12:39 <nschoe> Hi fellow Haskellers, I'm reading Simon Marlow's book about Concurrency in Haskell and I'm having troubles understanding and grasping the asynchronous exceptions. I think I understood the main differences between the two, but when I was playing around with some basic tests, I could not explain this difference : http://lpaste.net/103087 . I simply fork a thread to perform some dumb printing and the I have the main thread throwTo some exception to
11:12:39 <nschoe>  that thread and I look at the output.
11:13:18 <nschoe> Why 'ThreadKilled' and 'MyException' don't bhave the same on the forked thread ?
11:17:14 <nschoe> Nobody can give it a clue?
11:20:01 <Cale> nschoe: That is a little odd
11:20:40 <Cale> nschoe: Well, I can imagine why it would treat ThreadKilled as a special case with respect to printing exceptions
11:21:11 <Cale> nschoe: (because it's how killThread is implemented)
11:21:30 <nschoe> Cale, yeah but I never instructed it to. That was my goal in the beginning actually : I am trying to catch some asynchronous excpetions, and I just ran this littel test to check...
11:21:42 <Cale> nschoe: However, I wouldn't have expected to get anything at all after the main thread terminates
11:22:14 <nschoe> Cale, yeah I found it odd too. Any chance it is buffering-related ?
11:22:57 <Cale> It might just be managing to print just in the nick of time
11:23:20 <mm_freak> nschoe: when the main thread exits, all threads die instantly
11:23:53 <nschoe> mm_freak, precisely, so why does the child thread manages to print somethiign to screen ?
11:23:54 <mm_freak> nschoe: add an artificial delay to the main thread just before it exits to see the effect
11:24:01 <nschoe> mm_freak, doing it right now ^^
11:24:29 <skypers> hey, I have an issue with that .cabal https://github.com/skypers/OpenGLRaw/blob/master/OpenGLRaw.cabal#L26
11:24:33 <skypers> cabal: OpenGLRaw.cabal:26: Parse of field 'exposed-modules' failed.
11:24:35 <skypers> any idea?
11:25:26 <nschoe> mm_freak, I've got the exact same output
11:25:30 <mm_freak> nschoe: note also that killThread/throwTo wait for the exception to be /delivered/, not /handled/
11:25:36 <eren> is there any guide like "Haskell for Scheme (Racket) programmers?"
11:25:51 <eren> I'm reading PLAI and "Lazy Evaluation" cchapter is solely dedicated to Haskell
11:26:02 <nschoe> mm_freak, okay, but how does it play a role here ?
11:26:13 <mm_freak> nschoe: maybe i'm misunderstanding your question…  let me read again
11:26:18 <eren> I'm used to Racket, now I need a guide for Haskell that connects Scheme concepts with it
11:27:05 <quchen> Haskell is usually approached with a mindset as clean as possible, I don't think Scheme helps a lot learning it.
11:27:27 <mm_freak> nschoe: ThreadKilled and MyException should behave exactly the same except for printing the exception…  since you don't catch exceptions in your secondary thread it will use the default handler:  print MyException, but not ThreadKilled
11:27:38 <eren> quchen: why not?
11:27:43 <supki> skypers: remove commas
11:27:56 <nschoe> mm_freak, well it's normal : another question spawned actually. My first question is : why do I have the output  "simpleThrow : MyException" when I throwTo "MyException" and why don't I when I throwTo "ThredKilled". And the second question is : why in the case of printing, does it occur after the main thread exists
11:27:58 <quchen> Scheme got you used to using lambdas etc, but that's part of the very basic basics of Haskell anyway, so I don't think there's much benefit here. It'll be covered in the first 3 chapters and then you're on the same level as anyone else (coming from C, Python, ...)
11:28:53 <nschoe> mm_freak, yes that is what I seem to have understood, but why MyException *does* get printed while ThreadKilled does not ? From what I understand, ThredKilled is no different that MyException, it's just a named provided by Haskell to make things clean, no ?
11:28:54 <pjdelport> eren: They're quite different. The key thing to keep in mind, probably, is that Haskell is all about values, and transforming them: forget about set! and friends.
11:29:12 <quchen> eren: Haskell doesn't share many concepts with Scheme. It's statically typed, it's non-strict, there are no macros, typeclasses allow a giant range of abstractions not present in Scheme, …
11:29:21 <eren> pjdelport: sure, you're referring mutable data structure, generally
11:29:29 <quchen> ("Not present" as in "wouldn't be very fruitful even if implemented")
11:29:42 <mm_freak> nschoe: exactly because ThreadKilled is handled specially
11:30:04 <pjdelport> eren: IOW, you'll be think less about how processes should work, and more about how information should be represented.
11:30:21 <mm_freak> nschoe: killThread is implemented as a throwTo of ThreadKilled, and the default exception handler just ignores it and exits the thread
11:31:12 <pjdelport> eren: Well, Haskell has mutable data structures, too (and Scheme has pure functional programming); I'm just trying to describe the difference in style.
11:31:39 <nschoe> mm_freak, okay. But I did not call killThread I only called throwTo and gave it ThreadKilled as an argument, and I have not specified any exception handler for the thread I forked. So how come it uses one ? And which one does he use ?
11:31:54 <pjdelport> eren: But dive in and enjoy. :)
11:32:00 <eren> pjdelport: okay :)
11:32:14 <eren> my whole course is dedicated to programing languages in general (PLAI)
11:32:29 <eren> until now, we used Racket to implement simple interpreter with first class, multi valued functions
11:32:36 <mm_freak> nschoe: that's how killThread is implemented…  killing thread = throwing ThreadKillled at a thread
11:32:46 <mm_freak> nschoe: there is no special "kill thread" operation
11:32:47 <eren> as well as tackled with substitution based interpreter and environment based
11:33:06 <eren> now the whole lazy evaluation chapter is written in Haskell, need to dive into a bit :)
11:33:15 <eren> so, which book should I choose here? http://www.haskell.org/haskellwiki/Tutorials
11:35:09 <nschoe> mm_freak, okay. And now, when I send it MyException, why is the "simpleThrow : MyException" message printed *after* the "Main exits." message ? That sounds ... not possible since the threads should be terminated when the main terminates
11:36:05 <pjdelport> eren: It sounds like you're more interested in the theoretical properties of Haskell? You can probably skim through all of those, and pick the interesting bits off.
11:37:14 <mm_freak> nschoe: it's a game of chance
11:37:30 <pjdelport> eren: Laziness should be a side attraction, though; types and purity / non-strictness are the heart of Haskell.
11:37:30 <mm_freak> nschoe: although the non-threaded runtime may make this deterministic
11:37:46 <quchen> eren: The usual Haskell beginner books are Hutton (http://www.cs.nott.ac.uk/~gmh/book.html), LYAH (Free to read at http://learnyouahaskell.com/) and RWH (Free to read at http://book.realworldhaskell.org/).
11:37:50 <quchen> I recommend starting with Hutton or LYAH. If you need exercises, RWH provides some in each chapter; solve these while reading the first two books. Implementing functions from Prelude and Data.List is also a good exercise.
11:38:01 <mm_freak> nschoe: you could compile using -threaded to see if it makes a difference, but whatever you do, do not count on thread-specific cleanup handlers
11:38:07 <pjdelport> eren: You'll probably want to grok type classes, first.
11:38:16 <nschoe> mm_freak, okay I'll try that
11:38:37 <eren> quchen: thanks for the links
11:38:40 <shachaf> Type classes are overrated.
11:39:01 <eren> pjdelport: yeah, a little theoretical aspect would be nice like you said: types, purity, non-strictness etc
11:39:20 <johnw> I've come to agree with shachaf on that point.
11:39:21 <eren> I would love to first learn the concepts as my course requires some theory about the programming language
11:39:27 <mm_freak> nschoe: to make threading deterministic you should use helper abstractions like 'async' and STM
11:39:28 <l0cust> Hey, I have a program, hlint is giving me a warning, without a suggestion. No idea what the problem is
11:39:46 <l0cust> http://pastebin.com/nNkWigJ9
11:39:46 <eren> later, I will actually implement a basic interpreter in Haskell for a simple grammar
11:39:46 <johnw> l0cust: show us?
11:39:54 <l0cust> johnw: http://pastebin.com/nNkWigJ9
11:40:05 <nschoe> mm_freak, yes, I think I understood this. I was just trying to graps the concept of asynchronous examples and try to understand howto catch them...
11:40:05 <johnw> we'd need to see the code also
11:40:20 <nschoe> mm_freak, funny things happen when I compile wiht -threaded :
11:40:25 <l0cust> one minute, pushing
11:40:58 <l0cust> https://github.com/pharpend/tropical
11:41:02 <mm_freak> nschoe: try this: forkIO (threadDelay 1000000 `finally` putStrLn "Killed") >>= killThread
11:41:04 <nschoe> http://lpaste.net/103088
11:41:17 <mm_freak> nschoe: sometimes you will see the "Killed" message, sometimes you won't
11:41:52 <nschoe> mm_freak, http://lpaste.net/103088 : is that the same thing that is happening here ?
11:42:08 * hackagebot dataenc 0.14.0.7 - Data encoding library  http://hackage.haskell.org/package/dataenc-0.14.0.7 (GracjanPolak)
11:42:15 <bennofs> l0cust: i think hlint can't parse the explicit type signature
11:42:24 <bennofs> l0cust: you don't need a type signature in instances
11:42:44 <l0cust> bennofs: I know, I just put it there for readability
11:42:46 <eren> real world haskell seems nice, btw
11:42:50 <l0cust> I suppose a comment would work just as nice
11:43:04 <mm_freak> nschoe: no, what you're seeing there is simple output interleaving, because the threaded runtime gives threads a lot more opportunities for interleaving =)
11:43:07 <l0cust> eren: eh. I liked Learn You a Haskell better
11:43:17 <bennofs> l0cust: 'parse error' means hlint can't parse it. (HLint uses haskell-source-exts, so it's a bug in haskell-source-exts)
11:43:36 <l0cust> bennofs: ah, okay - so not an actual bug in my code
11:43:47 <bennofs> l0cust: I didn't know you could give type signatures like that in instances, btw :P
11:43:49 <mm_freak> nschoe: you can get rid of the interleaving by using another thread for output:  forkIO (forever $ takeMVar logVar >>= putStrLn)
11:43:52 <mm_freak> something like that
11:43:57 <mm_freak> where logVar :: MVar String
11:44:07 <l0cust> bennofs: Yeah, use -XInstanceSigs
11:44:11 <mm_freak> then instead of using 'putStrLn' you use 'putMVar logVar'
11:44:22 <bennofs> l0cust: ah, that's probably unsupported by haskell-source-exts then :)
11:44:38 <nschoe> mm_freak, okay. I will experiment with that. Thank you
11:45:13 <mm_freak> nschoe: however, try this:  main = do logVar <- newEmptyMVar; forkIO (forever $ takeMVar logVar >>= putStrLn); putMVar logVar "blah"
11:45:20 <mm_freak> nschoe: most likely you won't see the message
11:45:37 <nschoe> mm_freak, okay, I'll try.
11:47:00 <skypers> 20:26 < supki> skypers: remove commas
11:47:03 <skypers> which one(s)?
11:47:48 <b0bbi10> hi, if I have this BinTree type http://ideone.com/FPcida how is ordering carried out if I have two non-Empty trees?
11:48:53 <CindyLinz> b0bbi10: compare the Node's value first, then the left branch, and then the right branch
11:50:50 <b0bbi10> so it's left to right and recursively?
11:50:59 <b0bbi10> is there any rule to that?
11:51:16 <b0bbi10> type constructors are ordered by their definition
11:51:30 <shachaf> Yes, there's a rule.
11:51:40 <shachaf> You can see the exact definition in the Haskell Report.
11:51:52 <albeit> I have a function that operates on a Control.Monad.State. The datatype of the State has multiple fields. The function only modifies one of the fields. Do I have to read in all the other fields and then create a new data type instance with all the unchanged fields and the one new field?
11:52:14 <albeit> Or is there a shortcut to reading and writing all the fields?
11:52:33 <fizbin> albeit: Have you ever user Control.Lens?
11:52:46 <albeit> No
11:52:54 <albeit> I'll take a look though!
11:53:01 <supki> skypers: oh, actually I don't think commas are the problem, but modules that have a component that start with a number are
11:53:07 <fizbin> albeit: In short, Control.Lens provides shortcuts, but you can also do something like this:
11:53:13 <supki> skypers: e.g. Graphics.Rendering.OpenGL.Raw.3DFX
11:53:20 <mm_freak> b0bbi10: if you need to control the ordering, you should probably not derive Ord
11:53:33 <fizbin> modify (\st -> st{oneFieldIWannaChange = newValue})
11:53:37 <fizbin> albeit: ^^
11:53:56 <mm_freak> the derived ordering depends on your definition, which is fine, if you need Ord only for data structures, but bad if you actually want the ordering to be meaningful
11:53:59 <b0bbi10> mm_freak: just wondering how the standard ordering provided by ord works
11:54:02 <b0bbi10> Ord*
11:54:07 <fizbin> That assumes that your state is using a data type you defined with record syntax.
11:54:24 <albeit> fizbin: What if the newValue depends on the old value of that field?
11:54:39 <mm_freak> b0bbi10: i think the best idea is to assume "some arbitrary ordering"
11:54:52 <skypers> 20:52 < supki> skypers: e.g. Graphics.Rendering.OpenGL.Raw.3DFX
11:54:55 <mm_freak> but to answer your question:  what shachaf said
11:54:59 <skypers> hm, so the format changed?
11:55:12 <b0bbi10> ok, thank you guys
11:55:13 <skypers> I thought we have to put a comma between exposed modules
11:55:23 <fizbin> albeit: modify (\st@StateStructure{oneFieldIWannaChange=oldVal} -> st{oneFieldIWannaChange=computeNewVal oldVal})
11:55:55 <albeit> fizbin: Aha, that looks great. Thanks!
11:56:05 <supki> skypers: well, that's the first time I saw command in exposed-modules: actually, but apparently cabal thinks that's ok
11:56:19 <supki> s/command/commas/
11:57:10 * hackagebot text-normal 0.2.1.0 - Unicode-normalized text  http://hackage.haskell.org/package/text-normal-0.2.1.0 (JoelTaylor)
11:57:19 <skypers> supki: ok
11:57:23 <skypers> I’ll try to remove them then
11:58:50 <skypers> supki: removed
11:58:54 <skypers> still not working…
11:59:06 <kaeluka> please don’t hate on me. i’m trying to implement “objects” with subtype-polymorphism. my approach is that I have a ‘data Dyn = forall t . Foo t => Dyn t` that models subtyping
11:59:08 <supki> skypers: yeah, you need to rename 3DFX thing to something
11:59:17 <kaeluka> https://gist.github.com/kaeluka/11190403
11:59:49 <skypers> why?
12:00:10 <kaeluka> because i want to figure out haskell and learn something about subtyping on the way
12:00:15 <skypers> arf
12:00:33 <skypers> I should open a ticket on OpenGLRawgen then
12:00:39 <cschneid> is there a list of "normal" extentions? Stuff like bangpatterns, record wild cards, and similar syntax enhancements? What's good to use, vs what's not?
12:01:29 <supki> skypers: well, the report specifies module names as {conid.}conid where conid starts with a upper case letter
12:01:50 <kaeluka> i’m using typeclasses as interfaces and suspect that they’re not really what i need here. the question is: what is?
12:01:56 <skypers> supki: yeah
12:02:05 <skypers> I’m reporting the error on the bugtracker
12:02:06 <skypers> thank you
12:05:25 <bergmark> cschneid: that's subjective... haven't seen such a list
12:05:53 <cschneid> bergmark: there are a few combos that can cause actual problems, but for most - I have have no good feel of what's normal vs. what's not used very much
12:06:03 <cschneid> recordwildcards for instance seems just nice in the right situations
12:06:12 <cschneid> and it's 100% opt in when to use it, ie, it doesn't change anything else afaik
12:06:19 <bergmark> i don't like recordwildcards
12:06:34 <bergmark> it introduces name shadowing without you being able to tell
12:07:12 <bergmark> for pattern matching at least, maybe construction is not as bad, but i'd rather be explicit
12:07:22 <cschneid> yeah, valid.
12:07:47 <cschneid> I'm trying to write some stuff for people who have read RWH/LYAH and move them forward on actual useful tasks. "How to read JSON" type stuff
12:08:03 <cschneid> totally practical and pragmatic - but not advanced enough to know 100% on when to recommend some of the edges of the langauge
12:09:09 <nschoe> Cale, (hi back). This is weird. I tried your code and whether I compile with -threaded or not, I see the "blah" message
12:15:05 <aloiscochard> how I can I see in my module definition that I want to re-export one type (Foo) and all the module itself?
12:15:09 <aloiscochard> say*
12:15:40 <aloiscochard> I tried something like: module Bar (Foo(..), ..) where
12:16:49 <joelteon> aloiscochard: module Bar (Foo(..), module Bar) where
12:17:40 <aloiscochard> joelteon: oh thanks
12:17:44 <aloiscochard> but I crashed GHC :-/
12:17:58 <aloiscochard> I were using the same name for Foo and Bar, but that should be fine really with namespaces
12:18:07 <aloiscochard> let's clean and see
12:18:56 <aloiscochard> damn, no it really crash GHC, it's official it's my first bug
12:22:05 <pavonia> If patterns in a case are non-overlapping, does the order matter in terms of efficency in GHC?
12:23:03 <bennofs> Can I use a newer haddock with an old GHC version?
12:26:33 <l0cust> Well, I just have to say that GitHub sucks.
12:26:42 <klrr_> gitlab
12:27:14 <l0cust> klrr_: What are the advantages over GitHub
12:28:28 <klrr_> l0cust: no idea what why you dislike github (just joined so missed the context), ive also just started using it so cant really compare, the only advantage so far is its open source and their hosting solution provide gratis private repos :)
12:29:22 <l0cust> klrr_: hm. I was complaining about how GitHub renders HTML
12:29:30 <l0cust> or rather, refuses to
12:30:10 <quchen> I doubt Github devs read this channel, maybe you should send them a feature request elsewhere.
12:30:18 <l0cust> Yes
12:30:21 <l0cust> I should, good idea
12:31:37 <dwat3r> hi guys,i have a bit of a problem. I've implemented network protocol headers as data-s, wrote them functions for coding them to bytestring and vica versa,and now I would like to write a function which gets a raw package with pcap from the wire,then decodes it. the problem is that I don't know how to express this "pattern matching" on types.
12:32:18 <dwat3r> the raw package is a bytestring, but the function has to decide what kind of headers it has.
12:32:39 <Barnabe> pavonia, No. The order of case alternatives does not matter.
12:32:48 <Barnabe> pavonia, Not for performance concerns, that is.
12:33:01 <identity> dwat3r: You want a parser, then
12:33:22 <identity> something like attoparsec
12:33:27 <pavonia> Barnabe: Okay, thanks
12:34:26 <l0cust> klrr_: I suppose I could just figure out how to use darcs
12:43:36 <sm> l0cust: there ya go!
13:05:18 <l0cust> You know, I was just on Reddit, reading someone's post asking for help in Java. I can't believe I used to program in that language
13:06:11 <l0cust> I still have to use Clojure from time to time
13:07:22 <FreeFull> Clojure isn't as bad
13:08:17 <gilligan_> l0cust, for every haskell coder there are like 10000 java programmers and that proportion isn't going to change
13:08:34 <gilligan_> (not anytime soon anyhow)
13:09:56 <Phillemann> Why Clojure, specifically? Is it closest to Haskell when it comes to real world JVM languages?
13:10:21 <pjdelport> Hmm, people estimate there are about ~10 million Java programmers in the world.
13:10:37 <pjdelport> hopefully there are more than 1000 Haskell programmers in the world. :)
13:10:37 <Taneb> Phillemann, I believe Scala is closer, but Clojure is quite a good lisp
13:10:51 <Taneb> Whereas from what I've heard Scala isn't that great a Haskell
13:11:22 <gilligan_> pjdelport, the number of people who have a full time haskell programming job is probably not exactly high
13:11:31 <Phillemann> Surely we'd have to define some distance metric first, but let's just say we can "feel" the distance. ;)
13:11:36 <dashster18> Sorry to jump in late, but Java is depressing. Namely Enterprise Java.
13:11:54 <l0cust> pjdelport: Scala is probably closer. Clojure is a dialect of Lisp, and Lisp is pretty similar to Haskell
13:11:56 <gilligan_> clojure is a lisp dialect and therefor completely different than haskell
13:12:08 <solrize> ???????
13:12:11 <l0cust> gilligan_: why do you say Lisp is so different from haskell?
13:12:25 <l0cust> gilligan_: They are both abstract functional languages
13:12:29 <Phillemann> dashster18: With Spring and JSF and such? ;)
13:12:35 <dashster18> I'm guessing things like static vs dynamic typing, type inference, lazy vs eager evaluation.
13:12:37 <companion_cube> l0cust: typing?
13:12:38 <l0cust> The type systems are completely different
13:12:52 <solrize> clojure is haskell-like in the sense that it uses persistent data structures extensively and isn't big on mutation
13:13:00 <joseph07> I recently wrote a haskell program that generates java source for a particular problem
13:13:16 <solrize> traditional lisp is ugly and imperative and uses setf all over the place, or worse, LOOP
13:13:17 <FreeFull> Lisps also focus more strongly on metaprogramming than Haskell, although I think Clojure doesn't as much
13:13:37 <l0cust> Clojure feels like lispy java
13:13:46 <gilligan_> l0cust, ...what everyone said
13:13:50 <solrize> scheme is a more functional take on lisp
13:13:59 <l0cust> solrize: Yeah
13:14:02 <dashster18> Clojure IS a lispy java
13:14:12 <Earnestly> There is a typed racket, fwiw
13:14:14 <l0cust> dashster18: good point
13:14:19 <tapuu> I have a question about the async library
13:14:35 <l0cust> Yay! a real question
13:14:39 <tapuu> Can I call wait on the same async object from 2 threads?
13:14:57 <tapuu> Will they both return the same result?
13:15:05 <dashster18> Scheme (I guess Racket now) is nice. Lisp in general is a great way to sink your teeth into functional programming.
13:15:24 <l0cust> tapuu: I haven't even heard of async, so I can't help you there
13:15:25 <dashster18> I started functional programming due to an AI class at uni where we spent the first 8 weeks learning lisp.
13:15:30 <dashster18> IT definitely made learning much, much simpler.
13:16:08 <l0cust> dashster18: Lisp is a really nice language, I agree. It doesn't have nearly the learning curve of Haskell, which is why I recommend it to my
13:16:09 <dashster18> What's ironic though is at the time I thought lisp was very mathy and that's why it appealed to me. That's also a reason some people don't like it.
13:16:11 <l0cust> Java friends
13:16:22 <dashster18> Yet looking back, lisp doesn't seem mathy after learning haskell.
13:16:29 <l0cust> dashster18: lol yeah
13:16:58 <dashster18> I'm new to irc, for targetting a message to the user do you just type their name and a colon?
13:17:04 <l0cust> yep
13:17:05 <solrize> if you're interested in lisp i'd start with scheme or clojure and skip the legacy lisps entirely
13:17:18 <dashster18> lols
13:17:19 * hackagebot cuda 0.6.0.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.6.0.0 (TrevorMcDonell)
13:17:19 <gilligan_> dashster18, yep :)
13:17:20 <Earnestly> solrize: "scheme" is a spec
13:17:21 <l0cust> dashster18: You can type the first couple letters, and press TAB, and most will complete it
13:17:21 <identity> dashster18: their name in whatever way is sufficient for most irc clients
13:17:23 <afleck> what does the (Int -> a) mean in data ITree a = Leaf (Int -> a) | Node [Itree a]?
13:17:26 <Earnestly> Which scheme?
13:17:31 <pseudolio> Racket.
13:17:36 <Earnestly> Fair enough
13:17:36 <pseudolio> Racket is the best lisp.
13:17:41 <dashster18> solrize: I started with common lisp in my AI class, then in my PL class we used Racket.
13:17:46 <geekosaur> afleck, it's a function
13:17:48 <shachaf> afleck: A function from Int to a.
13:17:52 <l0cust> dashster18: you can also use a comma, I think
13:17:56 <solrize> racket seems nice... i've been using guile scheme which is more minimalistic
13:18:01 <quchen> tapuu: I think they should, yes. If you look at the source, 'wait' calls 'waitSTM'. 'waitSTM' in turn extracts the result of an Async, and rethrows its exeption, or returns the value the Async evaluated to.
13:18:12 <quchen> tapuu: I have no proper proof of this though.
13:18:13 <dashster18> l0cust, thanks. I prefer commas, more grammatically familiar.
13:18:20 <solrize> racket has a type extension which is pretty clever though limited since part of its mission is to accept untyped scheme code
13:18:22 <Earnestly> solrize: racket is a lisp that tends to be used a lot more in education
13:18:26 <quchen> Everyone else: you're offtopic.
13:18:45 <afleck> shachaf: does it take an Int, like 3, or does it take the actual type Int itself?
13:18:45 <gilligan_> nod.
13:18:46 <quchen> afleck: "Int -> a" is an ordinary function type.
13:18:49 * identity suggests #haskell-blah
13:18:58 <quchen> Oh, I missed shachaf's comment.
13:19:20 <shachaf> afleck: It takes a value of type Int.
13:19:33 <shachaf> afleck: It's the same as e.g. "foo :: Int -> Char"
13:19:45 <l0cust> pseudolio: I had never even heard of Racket, thank you for mentioning it
13:19:57 <pseudolio> It used to be called PLT Scheme.
13:20:04 <afleck> shachaf: Thanks, i was getting Int confused with Integral
13:20:22 <l0cust> afleck: Isn't Integer more efficient than Int?
13:20:34 <Taneb> l0cust, no.
13:20:35 <dashster18> afleck, I thought it was the other way around.
13:20:37 <solrize> so what's happening with haskell platform, will there be a release with ghc 6.8 anytime soon?
13:20:41 <pseudolio> Integer supports arbitrary precision.
13:20:43 <solrize> integer is slower but int is evil
13:20:44 <Taneb> l0cust, Int is machine-words, Integer is bignum
13:20:56 <solrize> int is integers mod 2**wordsize
13:20:58 <l0cust> Taneb: Ah, thank you
13:21:02 <quchen> solrize: Next Platform is being worked on.
13:21:11 <solrize> quchen, nice, thanks
13:21:23 <dashster18> solrize, do you know what version of ghc they're putting in it?
13:21:27 <quchen> 7.8.
13:21:32 <dashster18> Ooh nice
13:21:36 <identity> IIRC it's may sometime for next platform
13:21:45 <dashster18> Aww :()
13:21:49 <quchen> The entire point of delaying the Platform (skipping the Fall release) was to ship it together with 7.8, which wasn't available them.
13:21:55 <dashster18> Oh emacs. That parens complete.
13:21:55 <quchen> then
13:21:56 <quchen> *
13:22:51 <dashster18> After working through LYAH and Write Yourself A Scheme in 48 Hours, is RWH the next recommendation?
13:23:10 <solrize> probably, but it's sort of a dated book now
13:23:18 <l0cust> dashster18: I never really thought RWH was any good
13:23:24 <quchen> solrize, dashster18: See this mailing list thread. http://projects.haskell.org/pipermail/haskell-platform/2014-March/002843.html
13:23:46 <DR6_> lyah is also dated
13:24:13 * quchen can't think of anything in LYAH that is not up to date.
13:24:34 <shachaf> () is more efficient than Int.
13:24:54 <solrize> https://github.com/mezzohaskell/mezzohaskell   i haven't looked at this yet but the concept was promising
13:25:18 <dashster18> So is it not worth working through RWH?
13:25:36 <solrize> i guess mezzo haskell is out of date too
13:25:48 <quchen> I thought RWH was well worth it. Part to learn, part as a practical reference manual.
13:25:52 <solrize> dashster18, i like reading rwh
13:25:54 <solrize> liked
13:26:14 <solrize> oh man, no updates in 2 years
13:26:29 <solrize> ok that project is dead
13:26:43 <solrize> i heard about a 2nd edition of rwh in progress or at least planned or at least contemplated
13:27:31 <dashster18> Ooh, that'd be useful.
13:27:46 <dashster18> Is a lot of RWH out of date though? Or only in some places?
13:28:23 <quchen> Parsec and Control.Concurrent have had some updates, the code there won't necessarily compile anymore.
13:28:49 <geekosaur> also exception handling and mtl
13:28:52 <quchen> It's not been a full-blown revolution though -- the updated version would be conceptually the same, and probably look quite similar.
13:29:15 <quchen> At least from what I remember when I read it.
13:29:37 <stolaruk> dashster18: it's worth reading RWH
13:29:44 <dashster18> Yeah that's what I'm thinking.
13:30:01 <dashster18> After finals are done I'll get started with it.
13:30:07 <dashster18> Well more like resume.
13:30:08 <stolaruk> I don't have a very high opinion of the book but I still learned a lot from it and I'm glad I read it
13:30:24 <stolaruk> It's a good read after LYAH
13:31:01 <dashster18> This is a little tangent, but you do you do dynamic programming in haskell?
13:32:15 <l0cust> dashster18: what exactly do you mean by dynamic programming?
13:32:20 * hackagebot haskell-names 0.3.3.2 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.3.2 (RomanCheplyaka)
13:32:29 <solrize> dashster18, i think rwh no longer delivers on its mission of filling the gap between tutorial level haskell, and being able to use the stuff that goes into production code.  there's been a bunch of new stuff since the book came out
13:32:40 <dashster18> Let's say you're trying to solve the 0-1 knapsack problem.
13:33:23 <napping> Simon Marlow's book almost certainly replaces anything RWH said about concurrency
13:33:31 <solrize> yeah good point
13:33:32 <dashster18> http://en.wikipedia.org/wiki/Knapsack_problem#0.2F1_knapsack_problem
13:34:10 <solrize> dashster18, if i understand what you're getting at re dynamic programming, in some cases lazy evaluation handles it for you automatically
13:34:43 <solrize> if you can write your data structure in a way that the cases get evaluated in the right order
13:34:56 <solrize> look at conal's memotrie package
13:35:53 <dashster18> solarize, thanks!
13:36:53 <Phillemann> This is driving me crazy. I have a function "a -> b -> c" and a function "c -> d" and I want to create a function "a -> b -> d" from it. So basically (\a b -> g (f a b)). How do I do that?
13:37:36 <Phillemann> I mean, I just showed you how, but isn't there some combination of operators and/or lifts to avoid the lambda?
13:37:46 <Taneb> @djinn (a -> b -> c) -> (c -> d) -> a -> b -> d
13:37:46 <lambdabot> f a b c d = b (a c d)
13:37:55 <apples> :t (.) . (.)
13:37:55 <Flonk> :t (\f g -> (f.).g)
13:37:57 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:37:57 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:38:00 <Flonk> :D
13:38:03 <Taneb> @@ @pl @djinn (a -> b -> c) -> (c -> d) -> a -> b -> d
13:38:03 <lambdabot>  f = flip ((.) . (.))
13:38:13 <quchen> Phillemann: Not really, no. There's nothing standard to do this at least. I recommend the lambda.
13:38:21 <Phillemann> Interesting...
13:38:32 <Phillemann> Well, thanks
13:38:32 <Flonk> Phillemann: I usually define f.:g = (f.).g
13:38:36 <quchen> The dotdotdot operator is hardly more readable.
13:38:37 <geekosaur> mommy, the bot is flipping sleep-dep eyes at me
13:38:57 <Phillemann> Flonk: It's tempting
13:39:17 <Phillemann> I remember reading an article about this operator, but it seem I forgot it.
13:39:23 <Phillemann> *seems
13:39:57 <Flonk> I've seen the guys in #haskell use it before, and now I end up using it in pretty much all of my projects
13:43:01 <pjdelport> http://hackage.haskell.org/package/composition
13:43:36 <solrize> @pl f a b c d = b (a c d)
13:43:37 <lambdabot> f = flip ((.) . (.))
13:43:46 <solrize> lol
13:43:51 <Anarchos> lambdabot boob syntax ?
13:44:32 <solrize> @pl  (\a b -> g (f a b))
13:44:33 <lambdabot> (g .) . f
13:44:53 <solrize> that's not too bad
13:45:07 <mjrosenb> :t (.) . (.)
13:45:09 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:45:14 <mjrosenb> :t (.) (.) (.)
13:45:16 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:45:27 <mjrosenb> ok, clearly the proper tri-boob is better.
13:45:31 * shapr blinks
13:45:38 <shapr> @src swap
13:45:38 <lambdabot> Source not found. I am sorry.
13:46:01 <Earnestly> hah, I never saw "I am sorry" before now
13:51:17 <identity> It seems cabal(in a sandbox) is picking up a package that is installed non-sandboxed when it's not instaleld in my sandbox, and it's just ignoring --reinstall. I would very much like it to download a newer version of the package into the sandbox and use that
13:51:21 <identity> how do I go about this?
13:51:57 <geekosaur> that should only happen if it's a global package
13:52:23 <geekosaur> in which case you should probably not be trying to reinstall it in the sandbox; consider using hsenv instead so you can sandbox global packages
13:53:09 <identity> geekosaur: It's most likely because I made the mistake of installing it outside a sandbox at some point in time, I reckon
13:53:48 <geekosaur> right, but the sandbox replaces the normal local package database so anything in that should not be visible
13:54:15 <identity> huh. I see. Does running ghc-pkg inside the sandbox use the sandbox?
13:54:27 <geekosaur> no. cabal sandbox hc-pkg
13:54:29 <geekosaur> iirc
13:55:01 <geekosaur> if you want to use ghc-pkg directly with a sandbox, you need to provide parameters to point it to the sandbox package database
13:55:38 <identity> Aah, oh, I'm simply mistaken. THe package must've been a dependency of something else, because it's installed in the sandbox already
13:55:42 <geekosaur> (although I think if something you are running in the sandbox does it, say as part of cabal install in the sandbox, it should get the sandbox's db)
13:55:50 <identity> and moreover, the only newer version is just a bump for 7.8, so it doesn't matter
13:56:05 <identity> geekosaur: thanks!
14:05:27 <magthe> anyone know of a way to get Shelly to echo text in colour?
14:08:23 <identity> I really, truly find it hard sometimes to split modules up in a 'logical' manner without running into cyclic imports
14:12:26 * hackagebot buildwrapper 0.8.0 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.0 (JeanPhilippeMoresmau)
14:16:14 <Peaker> why are "cabal configure" and "cabal build" so slow?
14:18:32 <bennofs> Hmm, compiling Cabal + Lens takes ages :|
14:19:58 <afleck> in the lambda (\l@(x:xs)->x), I get that the @ kind of equates l and (x:xs). Is there a more formal definition, and is it used elsewhere?
14:20:29 <companion_cube> it's an alias
14:20:36 <companion_cube> l is an alias for the pattern (x:xs)
14:21:38 <quchen> afleck: They're called "as-patterns", and they're formally defined in the Haskell Report.
14:22:27 <afleck> quchen&companion_cube: thank you
14:23:16 <quchen> afleck: The section is called "Formal Semantics of Pattern Matching"
14:23:47 <quchen> The section before is "informal" though, and is probably more approachable.
14:24:19 <heaumer_> bens: afleck (someone had to.)
14:31:36 <afleck> alright, another question. Is it faster to add a bunch of elements to a list using (:) and then sort it, or use insert?
14:31:56 <dmj`> @src insert
14:31:56 <lambdabot> insert e ls = insertBy (compare) e ls
14:32:09 <dmj`> @src insertBy
14:32:10 <lambdabot> insertBy _   x [] = [x]
14:32:10 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
14:32:10 <lambdabot>                                  GT -> y : insertBy cmp x ys'
14:32:10 <lambdabot>                                  _  -> x : ys
14:32:16 <quchen> You probably don't want a list for that. Set sounds like a much better fit.
14:33:31 <Saizan> afleck: using insert is insertion-sort which is not as good as what's implemented in sort
14:34:11 <akurilin> With persistent, how do I get hold of a PersistUnique monad? Seems like what I have is PersistStore and functions like insertUnique don't actually do what they're supposed to.
14:48:05 <felix89> hi!
14:48:51 <dwat3r> hi guys, I dont understand this:
14:49:13 <dwat3r> (150::Word8) `shiftR` 4 `shiftL` 4
14:49:39 <dwat3r> lambdabot!
14:49:50 <merijn> dwat3r: Clear the lower four bits?
14:49:54 <dwat3r> ahh, it's 144,and i can't figure out why
14:50:07 <davean> dwat3r: consider the bit pattern, work it out by hand
14:51:14 <dwat3r> merijn: i'm trying to "pack" two word8-s to one, for ip protocol header
14:51:48 <merijn> Define pack
14:51:50 <davean> You can't put 2 into 1, that isn't what you're trying to do
14:52:11 <dwat3r> packvh::Word8->Word8->Word8
14:52:12 <dwat3r> packvh v h = (v .&. 15) .|. (h `shiftR` 4)
14:52:40 <dwat3r> v and h is the version and hlen field of the IPv4, they are 4 bit fields
14:53:14 <dwat3r> however i'm storing them in Word8-s for easy access.
14:53:19 <davean> right, you're trying to take PART of one and PART of the other
14:53:31 <dwat3r> davean: exactly
14:53:32 <davean> So, work out that code you din't understand by hand
14:53:37 <davean> you'll see it immediately
14:54:29 <dwat3r> davean: thanks,i'll try
14:55:39 <davean> dwat3r: do it in binary though, pay attention to the bits
14:55:42 <davean> that is the important part
14:57:09 <identity> When it comes to MVars vs TVars / TMVars, is it advisable to simply drop the first in favor of the latter for almost all scenarios?
14:57:38 <identity> Perhaps just STM in general vs Control.Concurrent.*
14:57:59 <Peaker> I avoid STM because every time I saw a benchmark involving STM, it was unfavorable :P
14:58:21 <Peaker> And atomicModifyIORef covers almost all my needs pretty well.   careful use of mask+mvars  covers the rest :)
15:08:15 <nisstyre> Peaker: you mean you don't lovingly hand optimize machine code (making use of undocumented features) for every different CPU your program will run on?
15:08:46 <Peaker> atomicModifyIORef does that for me :)
15:09:04 <bitemyapp> funny, jfischoff mentioned aMIR not long ago.
15:11:55 <dashster18> If I want to learn category theory, what are the prerequisites?
15:12:06 <nisstyre> dashster18: "mathematical maturity"
15:12:30 <nisstyre> dashster18: might want to check this out http://youtu.be/o6L6XeNdd_k
15:12:55 <ReinH> dashster18: and https://www.youtube.com/watch?v=ZKmodCApZwk
15:13:43 <nisstyre> dashster18: some of the examples might not make so much sense though, if you don't know the domains very well
15:14:17 <dashster18> What do you mean specifically by domains in this case?
15:14:37 <dashster18> And what kind of background do I need to make sense of it?
15:14:45 <dashster18> By it, I mean category theory.
15:14:48 <nisstyre> dashster18: I mean the different area of math
15:14:51 <nisstyre> or not even math
15:14:56 <nisstyre> anything really
15:15:08 <nisstyre> *different areas of math
15:15:31 <nisstyre> dashster18: watch the video I linked, it explains category theory
15:15:52 <dashster18> Ah ok, so there are domain specific examples. Not domain and co-domain of functions.
15:16:04 <nisstyre> no, I meant it in a non mathematical sense
15:17:04 <nisstyre> dashster18: you could say category theory is the art of leaving out details
15:17:26 <ReinH> ehhh
15:17:43 <nisstyre> by that I mean category theorists try to make everything very general
15:17:51 <nisstyre> but it's a bit stricter than that, watch the video
15:18:24 <ReinH> heh
15:19:02 <ReinH> dashster18: Basically if you are familiar with the set theoretic definition of a function and willing to work at it you should be ok
15:20:01 <nisstyre> category theory is probably a lot like vim, you shouldn't try learning it all at once or your head will explode, so maybe learn what you need for specific things
15:20:11 <nisstyre> or even don't learn it
15:20:16 <nisstyre> you don't actually need it for anything
15:20:27 <enthropy> hmm, the old logo https://ghc.haskell.org/images/HaskellLogo_2.jpg is still used in the haskell' wiki
15:21:44 <b0bbi10> evening, does anyone know what the author of Haskell Fast & Hard meant by this comment http://ideone.com/emaZAn (getting a value from an IO)
15:22:53 <[swift]> argh, i swear my cabal install hook just is not getting called =(
15:23:01 <merijn> b0bbi10: I always think the best way to understand is to understand the "normal" monad operators (like >>= and >>) and then learn how do notation desugares to those, which should clarify what happens
15:23:07 <merijn> b0bbi10: For example
15:23:22 <merijn> @undo do { b <- foo; bar; baz b }
15:23:22 <lambdabot> foo >>= \ b -> bar >> baz b
15:24:00 <JagaJaga> Hi! Do smone know some kind of translator from functional lang to imper? :)
15:24:10 <nisstyre> JagaJaga: yes, it's called a compiler
15:24:14 <b0bbi10> merijn: I believe you really want to help me here, but I think I haven't learned all that what you're talking of :/
15:24:17 <merijn> b0bbi10: Now, if you look at "(>>=) :: Monad m => m a -> (a -> m b) -> m b" you see that an "unwrapped" 'a' is passed to the function, so the 'b' inside the lambda is not inside IO
15:24:48 <quchen> JagaJaga: There are transpilers from Haskell to Javascript and C, but the output is often far from readable.
15:24:56 <merijn> b0bbi10: do-notation like the "value <- action2" is syntactic sugar for the several monad operators, mostly >>= and >>
15:25:20 <merijn> b0bbi10: My usual beginner advice is to learn how to use >>= and >> and once you feel you understand those, THEN learn how do-notation works
15:25:25 <ReinH> merijn: "mostly"?
15:25:41 <merijn> ReinH: let desugares to let-in
15:25:46 <ReinH> ah ofc
15:25:49 <merijn> s/desugares/desugars
15:25:57 <b0bbi10> merijn: noted :)
15:26:39 <merijn> ReinH: Also, lambda's
15:27:11 <dashster18> nisstyre, thanks for the category theory videos. They look really interesting. I'll finish them up later.
15:27:17 <quchen> inb4 someone mentioning the f-word in conjunction with monads
15:27:19 <merijn> b0bbi10: I was referring to how my small examples translates to >>= and >> to show how 1) <- appears to let you escape IO and 2) while really not letting you do that ;)
15:27:45 <bitemyapp> WHEEEE
15:27:55 <merijn> quchen: I actually forgot about it :(
15:27:59 <merijn> quchen: Now you made me sad
15:28:21 <quchen> merijn: There there.                  I of course meant "free". I was talking about free monads. lalala
15:31:44 <JagaJaga> quchen: thx, man :)
15:40:41 <mmachenry> quchen: Is someone giving out free monads?
15:43:31 <pjdelport> The first one's free!
15:54:30 <danilo2> Good evening everyone! :) I've got a little question to you, If I might :) So I was looking at the StateT definition and I saw, that the Functor instance uses lazy pattern matching: " ... fmap (\ ~(a, s') -> (f a, s')) $ runStateT m s ..." (https://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-Trans-State-Lazy.html#State). Why is it needed? what will happen if we do not use lazy pattern matching there?
15:56:06 <FreeFull> danilo2: Might be to avoid evaluating s', not sure though
15:58:05 <danilo2> FreeFull: Hmm, why s would be evaluated? Is it not just a binding to first or second tuple component without evaluation when we use normal tuple pattern match? I'm asking because I really want to understand why and when should we use lazy pattern match :)
15:58:37 <FreeFull> danilo2: I really have no clue why the lazy match is used either
15:58:57 <FreeFull> My theory about s' is definitely wrong, thinking about it
15:59:23 <FreeFull> The only explanation is that the function itself is being applied lazily?
15:59:26 <heatsink> danilo2: In lambda and case, patterns are strict.  They are matched before the body executes.
15:59:32 <heatsink> In let, patterns are lazy.
16:00:03 <heatsink> > let (x, y) = undefined in 1
16:00:04 <lambdabot>  1
16:00:19 <heatsink> > (\(x, y) -> 1) undefined
16:00:21 <lambdabot>  *Exception: Prelude.undefined
16:00:29 <heatsink> > (\ ~(x, y) -> 1) undefined
16:00:30 <lambdabot>  1
16:01:19 <heatsink> Sometimes state-based code uses mfix.  In that case, laziness matters.
16:02:17 <danilo2> heatsink: Oh, that is very interesting! Ok, so I've got 2 further questions: 1) why pattern match in lambdas is not lazy as well. Would it perfrom worse / make make some ugly things If we woudl always use lazy pattern match? 2) In the case of fmap, does it help us to work with situations like undefined, or the lazy pattern has also other meaning there?
16:03:44 <nicoo> away
16:03:47 <nicoo> Oops
16:03:47 <heatsink> I don't know.  Maybe the reason is so that lambdas will behave the same as function definitions.
16:04:05 <quchen> FreeFull: Are patterns in 'where' irrefutable as well?
16:04:28 <FreeFull> where behaves the same as let in Haskell
16:04:37 <heatsink> It would be weird if (\ (x, y) -> ...) was different from let f (x, y) = ... in ...
16:04:41 <FreeFull> heatsink: They don't though, let behaves the same as definitions
16:05:06 <FreeFull> I suppose it does behave the same if you only have one pattern match for f
16:05:32 <FreeFull> Actually, no
16:05:35 <danilo2> heatsink, FreeFull: Ok, but could I ask again - why? Why lambdas with lazy pattern matching (behaving just simmilar to functions) is something wrong?
16:05:47 <FreeFull> f (x,y) = 1  behaves different from f = \(x,y) -> 1
16:06:23 <danilo2> heatsink: Ah, wait - I misunderstood your answer
16:06:31 <heatsink> FreeFull: What is the difference?
16:06:58 <FreeFull> heatsink: in the first case, f undefined is 1, while in the second case it is undefined
16:07:41 <heatsink> > let f (x, y) = 1 in f undefined
16:07:42 <lambdabot>  *Exception: Prelude.undefined
16:10:59 <danilo2> heatsink, FreeFull: Anyway is there any reason behind the situation, that patterns in functions AND lambdas are not lazy by default? Will it affect the final binary performance, or what is the difference?
16:11:00 <quchen> FreeFull: Are you sure about the first case?
16:11:25 <FreeFull> > let f (x,y) = 1 in f undefined
16:11:26 <lambdabot>  *Exception: Prelude.undefined
16:11:31 <FreeFull> Huh, I was wrong
16:11:36 <quchen> f (x,y) = 1 ⇒ f undefined  has to evaluate "undefined" enough to decide whether the tuple pattern matches
16:11:43 <FreeFull> Yeah, I see now
16:11:48 <FreeFull> Sorry
16:12:01 <FreeFull> f _ = 1 would have worked
16:12:07 <quchen> > let f ~(x,y) = 1 in f undefined
16:12:08 <lambdabot>  1
16:12:25 <FreeFull> > let f = \_ -> 1 in f undefined
16:12:26 <lambdabot>  1
16:12:38 <heatsink> danilo2, A function definition can have multiple equations.  To decide which equation to use, patterns have to be matched eagerly.
16:13:23 <danilo2> heatsink: Ok, that is a good point. But what if function has only one definition? Would it make any difference?
16:14:11 <pjdelport> That just means the function is partial; it must still match to see if the definition should be used.
16:14:47 <Peaker> lambdas only support 1 anyway
16:15:00 <heatsink> Suppose I have defined f (x:xs) = 1 : xs
16:15:25 <quchen> FreeFull: That reminds me of an issue I've had a couple of days ago: http://lpaste.net/103093
16:15:33 <quchen> Does that leak for long lists?
16:15:36 <heatsink> Later I add a new equation f [] = [].  It would be bad if the first equation switches from lazy to strict pattern matching, because I didn't modify it at all
16:16:01 <quchen> FreeFull: It uses "foldl", but the pattern matching on the tuple should force the first argument to WHNF, no
16:16:01 <quchen> ?
16:16:02 <heatsink> So for consistency, pattern matching in function definitions is strict
16:17:46 <Peaker> quchen: try it on a long list and see if you get a stack overflow? :)
16:17:48 <heatsink> > foldl (+) (0,0) [x, y, z]
16:17:50 <lambdabot>  Couldn't match expected type ‘(t, t1)’
16:17:50 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
16:17:50 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
16:17:50 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
16:17:54 <heatsink> > foldl (+) w [x, y, z]
16:17:55 <lambdabot>  w + x + y + z
16:18:23 <heatsink> > foldl f w [x, y, z]
16:18:24 <lambdabot>  can't find file: L.hs
16:18:30 <heatsink> ???
16:18:31 <heatsink> > foldl f w [x, y, z]
16:18:32 <lambdabot>  f (f (f w x) y) z
16:19:15 <FreeFull> quchen: You really need to use foldl', because foldl will create thunks either way
16:19:18 <danilo2> heatsink: Hmm, I think I understand the design decisions now. Thank you very much for this clarification! :)
16:19:37 <quchen> FreeFull: Indeed it leaks. Source: my swapfile
16:19:41 <ReinH> heh
16:20:41 <quchen> FreeFull: Ah, my overflow will be nested "go" calls, not from nested (+) operations, right?
16:20:58 <danilo2> One last question if I might - Does lazy / strict pattern match affect performance in any way? Or it just affects the execution logic ?
16:21:20 * quchen really wishes he could run programs in sandboxes that just kill -9 any spawned processes when they allocate more than X memory
16:21:53 <ReinH> quchen: (+) is already strict in its first argument, iinm.
16:22:09 <FreeFull> quchen: You could turn off swap and rely on OOM
16:23:08 <quchen> ReinH: Yeah, I somehow thought the standard overflow "foldl (+) 0" had something to do with (+). Silly me.
16:23:18 <quchen> Anyway, lesson learned.
16:23:21 <ReinH> e:)
16:23:23 <ReinH> er :)
16:23:38 <quchen> Is that still a typo or is "er" what you wanted to say? :-s
16:23:50 <ReinH> the 'e' was a typo :p
16:23:59 <heatsink> danilo2: Too much strictness can mean that a program does not terminate.  Too much laziness can produce space leaks.  Incorrect use of laziness or strictness can produce a stack overflow.
16:24:00 <akurilin> Ok so apparently PersistUnique typeclass kicks in when you have a uniqueness constraint somewhere in your persistent type declaration, coolio
16:24:07 <akurilin> If anybody was wondering.l
16:24:21 <heatsink> s/Incorrect/Bad/
16:24:23 <pjdelport> quchen: ulimit -v !
16:24:36 <quchen> pjdelport: Doesn't help :-(
16:25:12 <pjdelport> quchen: Why not?
16:25:20 <quchen> Puzzles me
16:25:25 <quchen> @quote monochrom ulimit
16:25:25 <lambdabot> No quotes match. Where did you learn to type?
16:25:34 <ReinH> danilo2: http://www.haskell.org/haskellwiki/Performance/Strictness and friends :)
16:25:38 <quchen> @remember monochrom linux's ulimit for main memory will not help because linux kernel's allocator is a lazy yes-man (think irrefutable pattern)
16:25:38 <lambdabot> Okay.
16:25:50 <quchen> Source: http://ircbrowse.net/browse/haskell?id=17880063&timestamp=1397143454#t1397143454
16:26:50 <danilo2> heatsink, FreeFull, ReinH: Thank you! :)
16:27:03 <heatsink> np
16:27:03 <danilo2> ReinH: Thanks for the article! I think this is something I was looking for! :)
16:28:05 <magicman> Is there any way to use hint with cabal sandboxes? I tried using unsafeSetGhcOption "-package-db path/to/packages/arch-os-ghc-version-packages.conf.d", but it won't help.
16:28:24 <magicman> For the record, starting ghci with that same -package-db option, and the sandboxed modules are accessible.
16:28:46 <pjdelport> quchen: Are you sure about that? It works for me. (Ubuntu)
16:28:46 <magicman> (as in actually running ghci, not cabal repl)
16:30:11 <quchen> magicman: Is Hint aware of the GHC library path environment variables? Cabal 1.20 introduced 'cabal exec' that takes care of everything for you
16:30:58 <quchen> The env variable is called "GHC_PACKAGE_PATH"
16:31:25 <quchen> So running a sandbox-aware GHCi is as easy as "cabal exec ghci" now
16:31:35 <magicman> Ooh, cool.
16:32:16 <quchen> Well, for running GHCi, there's also "cabal repl". But invoking GHC sandbox-aware is "cabal exec ghc -- <ghc-args>" now.
16:32:57 <magicman> *nodnod*, I only included running ghci to make sure I got the flag right.
16:34:22 <magicman> ... damn Windows. "cabal exec ghci" goes "can't find package database at C:\Users\etc\etc\etc\.cabal-sandbox\stuff-packages.conf.d:C:\Program Files (x86)\more\stuff\package.conf.d".
16:34:39 <magicman> Path separator fail, I guess?
16:34:48 <quchen> etc\etc\etc?
16:35:13 <magicman> The path right up until the directory in which I once did a cabal sandbox init, and from which I call cabal exec ghci.
16:35:21 <quchen> I don't remember how Windows' $PATH looks like, but I'm sure the colons in C:\ are not good.
16:35:46 <quchen> Well, the colons cabal adds aren't good, C:\ is alright
16:35:58 <magicman> Separated by semicolons. Probably to avoid ambiguity with the drive letter separator.
16:37:37 <magicman> (incidentally, \more\stuff is the path to my Haskell Platform installation and its package.conf.d)
16:48:00 <magicman> Ah. I see the line in the cabal source code. The ':' is hardcoded, and should probably be System.FilePath.searchPathSeparator .
16:51:31 <quchen> magicman: Submit a patch?
16:52:10 <magicman> First rebuild locally to see if it fixes the problem. And then figure out what the patch-submitting-workflow is.
16:52:33 <magicman> I must admit I'm a newbie at githubbing <_<
16:53:07 <quchen> Are you familiar with using Github just for yourself?
16:53:39 <magicman> Yeah, and some small projects that I can just directly push to. Probably a bad idea to do that to the main cabal repo.
16:55:09 <quchen> magicman: In that case, fork the Cabal repo (by clicking on "fork"). You'll get your own private copy of the repo. Clone that, edit code, push changes to your fork. Then click the green "pull request" button.
16:55:48 <quchen> That's it in a nutshell.
16:56:05 <quchen> A non-test-compiling nutshell you should sugar with best practices :-)
16:56:39 <magicman> Cheers!
16:57:28 <quchen> magicman: Note that not all Haskell-related repos are hosted primarily on Github. GHC for example is only mirrored there, so the patching process is a little different. Always read the repo description on Github.
16:57:55 <magicman> *nod*
17:03:51 <orion> Ok, here's a puzzle: I write a program which generates random bytes using a C library (which reads /dev/urandom). I generate 4 sets of random ByteStrings and print them to stdout in hex. If the code is compiled by hand (ghc), all four ByteStrings are different, as I would expect. If I use cabal, they are all the same.
17:04:56 <orion> http://lpaste.net/1810193513988489216 <-- code
17:04:58 <koala_man> orion: what if hand compile with optimization?
17:05:23 <magicman> Woo! cabal exec ghci works, and I get different errors when using hint :) (symbols not in scope, instead of module not found, which means the sandbox is found, yay!)
17:06:22 <orion> koala_man: -O2 to GHC, and the random strings are different, as I expect.
17:12:31 <orion> Any idea what could be going wrong? :s
17:19:38 <orion> Are there any other things I could try?
17:21:37 <akurilin> I have a newbie question: I'm calling a persistent function in its own function outside of the SqlPersistT block, the types don't match, and I'm sure what to do :| http://lpaste.net/98103585685897216
17:23:11 <akurilin> Calling insertUnique inside of the runSqlPersistMPool works fine, just not when I take it out
17:24:37 <sm> how do I combine the two monadic predicates in filterM (isFile <something> isExecutable) ... ?
17:24:59 <sm> I want both to be true
17:25:03 <fragamus> ok…… I am using pipes…. and they're great… and all my code is in the identity monad so it's pure as the driven monadic snow...
17:27:47 <tristan__> hm, getting confused by hedis and mempty http://hackage.haskell.org/package/hedis-0.5/docs/Database-Redis.html#g:20
17:28:41 <tristan__> for me 'return mempty' causes Not in scope: `mempty'
17:29:01 <geekosaur> Data.Monoid
17:29:27 <BeardedCoder> @hoogle parseUrl +http-client
17:29:28 <lambdabot> Could not find some databases: http-client
17:29:28 <lambdabot> Searching in:
17:29:28 <lambdabot>   .
17:30:00 <pjdelport> (tristan__: You need to import Data.Monoid to get mempty, in case that wasn't clear.)
17:31:49 <orion> hm, could my RNG problem have to do with strictness?
17:32:33 <orion> err, laziness?
17:32:53 * hackagebot yesod-auth-account 1.2.4 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-1.2.4 (JohnLenz)
17:33:59 <tristan__> geekosaur: doh! thanks
17:34:11 <BeardedCoder> I need a bit of help converting an exception to an either. I have minimized example here. https://gist.github.com/ccarter/11199103
17:34:35 <tristan__> odd the suggestions didn't have that..
17:34:42 <structuralist> Sort of an ill-posed question, but are there any guides on how to balance elegant types and efficient implementation? Like I have something that's conceptually a function of time, but is discretely integrated, and passing around a function of t that uses (!!) to grab "f(t)" seems like a bad idea if I need all values of t, but passing around lists seems less nice.
17:36:29 <structuralist> Should I have a new type of "functions of time but that can also sample ranges of time efficiently"?
17:37:06 <structuralist> (I know little to nothing about optimizing for performance in Haskell)
17:37:53 * hackagebot group-with 0.2.0.1 - Classify objects by key-generating function, like SQL GROUP BY  http://hackage.haskell.org/package/group-with-0.2.0.1 (ulikoehler)
17:41:55 <SrPx> How could I make this faster? http://lpaste.net/103096
17:42:54 * hackagebot group-with 0.2.0.2 - Classify objects by key-generating function, like SQL GROUP BY  http://hackage.haskell.org/package/group-with-0.2.0.2 (ulikoehler)
17:48:31 <meretrix> @hoogle 'Monad m => [m a] -> m [a]'
17:48:31 <lambdabot> Parse error:
17:48:31 <lambdabot>   'Monad m => [m a] -> m [a]'
17:48:31 <lambdabot>   ^
17:49:01 <meretrix> Is there a function that does that?
17:49:09 <BeardedCoder> :t sequence
17:49:10 <lambdabot> Monad m => [m a] -> m [a]
17:49:19 <meretrix> Ah that's right, thanks.
17:51:41 <BeardedCoder>     Couldn't match type `HttpException'
17:51:42 <BeardedCoder>                   with `GHC.Exception.SomeException'
17:51:42 <BeardedCoder>  
17:52:05 <BeardedCoder> can someone give me some insight. There is a function using Failure and I'm trying to turn it into an Either
17:52:55 * hackagebot wreq 0.1.0.0 - An easy-to-use HTTP client library.  http://hackage.haskell.org/package/wreq-0.1.0.0 (BryanOSullivan)
17:53:22 <SrPx> How can I tell GHC to pre-compute all constants?
17:56:14 <micrypt> @hoogle Monad m => [m a] -> m [a]
17:56:15 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
17:56:15 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
17:56:15 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
17:56:16 <Twey> How would I encode a fixpoint in reactive-banana?  Say if I had two GUI elements, the change of the value of either one of which should affect the other
17:56:36 <ReinH> SrPx: you can use template haskell to "lift" a given value but there's no general way to accomplish this.
17:56:43 <zoomshorts> hi
17:57:14 <zoomshorts> I am getting errors on line 78 of http://pastebin.com/TpFesRgu
17:57:19 <zoomshorts> I don't know why
17:57:26 <zoomshorts> do I just suck at whitespace??
17:57:39 <Twey> Repeated in case conal wants to chip in, because apparently I have the worst timing: How would I encode a fixpoint in reactive-banana?  Say if I had two GUI elements, the change of the value of either one of which should affect the other
17:57:53 <ReinH> zoomshorts: please include the error
17:58:21 <zoomshorts> parse error -- incorrect indentation or misplaced brackets
17:58:24 <dwcook> zoomshorts, line 74 has an incomplete infix expression
17:58:24 <Twey> zoomshorts: You have a trailing operator ++ on line 68
17:58:26 <heatsink> zoomshorts: The last symbol before line 78 is ++, which is an infix operator
17:58:34 <Twey> And others
17:58:53 <dwcook> Line 68's not trailing, it's just confusingly laid out
17:58:58 <zoomshorts> yah I don't know haskell :P
17:59:13 <zoomshorts> as in... what is a trailing operator 0_0
17:59:14 <Twey> Er, yes.  Just 74.
17:59:17 <orion> Is it possible to expose a type but not its constructor?
17:59:18 <geekosaur> also lines 99--100 are misplaced
17:59:19 <SrPx> ReinH: why!?!?
17:59:23 <SrPx> That is horrible
17:59:28 <ReinH> SrPx: ?
17:59:30 <geekosaur> zoomshorts, you have an expression ending in ++
17:59:35 <zoomshorts> I'm so sorry XP
17:59:37 <geekosaur> which is followed by a new definition
17:59:46 <zoomshorts> do I just remove the ++'s?
17:59:49 <zoomshorts> all of them?
17:59:52 <geekosaur> that one only
17:59:55 <geekosaur> on line 74
17:59:57 <zoomshorts> which line?
17:59:59 <zoomshorts> okay
18:00:08 <Twey> orion: Yes: module YourModule (YourType ()) where …
18:00:20 <geekosaur> but then you have the other problem later on with a chunk of ManageHook dangling in the aie
18:00:22 <geekosaur> *air
18:00:25 <byorgey> orion: yes
18:00:36 <SrPx> ReinH: that is really terrible, I programmed a static list which does not depend on any external variable. It can be perfectly computed in compile time. But accessing one of its value takes seconds instead of being instant, because GHC is not calculating those values on compile time!
18:01:03 <zoomshorts> now line 98 has a parse error input {
18:01:05 <byorgey> orion: given  data Type = C1 | C2,  if you put  Type  by itself in the export list that exports Type but not C1 and C2.  In order to export Type and its constructors you have to write   Type(C1,C2)  or  Type(..)
18:01:08 <zoomshorts> err, [
18:01:18 <geekosaur> [23 00:59] <geekosaur> but then you have the other problem later on with a chunk of ManageHook dangling in the aie
18:01:44 <ReinH> SrPx: like I said, there is template haskell machinery to accomplish this
18:01:56 <SrPx> ReinH: that is not elegant at all... what would it look like?
18:02:35 <SrPx> I don't see why I would need a library supposed to deal with syntax when all I need is the compiler to calcule a static value in compile time. What the ...
18:02:59 <SrPx> That is really disappointing \:
18:03:05 <joelteon> is it a number?
18:03:10 <SrPx> It is a list.
18:03:14 <joelteon> of what?
18:03:19 <geekosaur> zoomshorts, also you're missing a bunch of commas in the config record at the end of the file
18:03:37 <sclv> its an infinite list, no?
18:03:38 * ReinH shrugs
18:03:43 <sclv> how much should it precompute?
18:03:44 <zoomshorts> I found the issue with line 100
18:03:57 <SrPx> of 200000 integers. Yes, almost a MB. But I **do** want my program to have 1mb and 0ms response time, not 1kb and 3s response time per request. That is absurd.
18:04:00 <zoomshorts> misiing an x = x type line
18:04:01 <zoomshorts> expression
18:04:05 <zoomshorts> whatever you call it
18:04:08 <zoomshorts> I should learn haskell
18:04:24 <geekosaur> http://lpaste.net/103098
18:04:26 <SrPx> The program is simple, you can take a look http://lpaste.net/103097
18:05:19 <zoomshorts> where do I put the commas in the final structure?
18:05:25 <geekosaur> (note that I have not actually compiled it, don't have xmonad on the machine I am IRCing from and the other machine is busy at the moment)
18:05:29 <sclv> yeah you need to lift that
18:05:35 <zoomshorts> geekosaur: behind terminal, focus etc?
18:05:39 <sclv> a supercompiler could precompute it all for you
18:05:46 <geekosaur> zoomshorts, I just pasted the corrected one
18:05:51 <geekosaur> http://lpaste.net/103098
18:06:00 <zoomshorts> geekosaur: ty vm :3
18:06:08 <joelteon> SrPx, I don't think that can be precomputed
18:06:20 <geekosaur> but as I said I have not actually compiled it, just corrected the obvious problems
18:06:24 <zoomshorts> geekosaur: no comma begind terminal?
18:06:25 <joelteon> or maybe it can
18:06:32 <zoomshorts> geekosaur: mistake or am I clueless?
18:06:36 <geekosaur> no, it's the first item
18:06:40 <SrPx> joelteon: of course that can be computed. I could pre compute it myself, store on disk and access from the program.
18:06:44 <joelteon> So do that
18:06:47 <zoomshorts> geekosaur: gotchya
18:06:50 <joelteon> It can't be *precomputed*
18:06:53 <joelteon> that's not what I said
18:06:54 <geekosaur> does {, 1, 2, 3} make sense to you?
18:07:01 <joelteon> iterate (...) (0,1) is polymorphic, for a start
18:07:07 <SrPx> joelteon: how could it not be precomputed? What is stopping it from? It has no free variables.
18:07:13 <sclv> yes
18:07:24 <sclv> a supercompiler is a compiler that “runs as much as possible” at compile time
18:07:25 <SrPx> It does not depend on any external value. Seriously...
18:07:29 <sclv> it is a _hard_ problem
18:07:38 <sclv> one would do what you want
18:07:43 <sclv> alternately you could just compile it, run it
18:07:48 <sclv> then put the result into a file
18:07:51 <sclv> and call that your program
18:07:54 * ReinH shrugs
18:08:08 <sclv> this is a nonproblem :-P
18:08:18 <SrPx> No, it is NOT what a supercompiler is for. A supercompiler does things like folding recursive functions - with free variable - which is hard. What I want is absolutely ridiculous, just call it.
18:08:22 <joelteon> SrPx: what language do you normally use that can precompute that list?
18:08:26 <joelteon> compiler/language
18:08:48 <SrPx> joelteon: unfortunately there is something wrong with humanity because, indeed, none.
18:08:57 <SrPx> but that *is* trivial to precompute
18:09:01 <joelteon> indeed
18:09:11 <joelteon> well, you can go to #ghc to look into becoming a contributor to GHC
18:09:23 <SrPx> well
18:09:40 <sclv> i have a compiler that will do this
18:10:03 <sclv> runghc > newprogram.hs
18:10:39 <heatsink> SrPx: Put 'solutions' in a TH splice
18:10:47 <heatsink> the RHS I mean
18:10:51 <sclv> i call it… bash
18:11:16 <ReinH> There are some things that ghc can "pre-compile", like vector-fused computations targetted to LLVM
18:11:20 <ReinH> for everything else, there is template haskell
18:12:50 <ReinH> Among perhaps other reasons, pre-compiling like this is not generally safe because of bottom
18:13:02 <ReinH> even though it might be trivial for a specific case, it is not at all trivial in the general case
18:13:25 <ccc> sudo unmount /home/ron/download/Fedora-20-x86_64-netinst.iso /mnt/iso_image/
18:13:31 <ReinH> But if you want to tell the compiler that you're smarter than it, you can include a module and write a template haskell splice.
18:13:41 <zoomshorts> geekosaur: but wait! there's moer!
18:13:55 <geekosaur> I did say I had not compiled it...
18:14:28 <zoomshorts> lines 57-59 error: must be enclosed in parenthesis
18:14:29 <zoomshorts> http://pastebin.com/F0JF4T7N
18:15:34 <joelteon> right, ".|. controlMask xK_j" is a section and must be in parentheses
18:15:37 <ReinH> And yes, supercompilation has been approached by haskell folks. It's not trivial. http://research.microsoft.com/en-us/um/people/simonpj/papers/supercompilation/design-space.pdf
18:16:05 <zoomshorts> geekosaur: okay do i get rid of the double parenthesis at the start of the line and replace it with a single then?
18:16:07 <SrPx> heatsink: pardon?
18:16:24 <SrPx> sclv: hmm
18:16:50 <geekosaur> zoomshorts, the commas on lines 57-59 should be *after* controlMask
18:16:51 <sclv> ccc: file not found
18:16:55 <geekosaur> not before the .|.
18:17:16 <geekosaur> modm .|. controlMask, ...
18:17:28 <zoomshorts> holy crap the default xmonad.hs in the manpages is completely wrong then
18:17:43 <zoomshorts> this is all mostly copied from it
18:17:44 <heatsink> SrPx: Are you familiar with Template Haskell?
18:18:06 <geekosaur> what? (although I'm still whacking problems, like that is not actually the default and should not be used at all, just read to see how stuff works)
18:18:10 <zoomshorts> geekosaur: there are commas before and after now
18:18:13 <geekosaur> the defualt is two lines
18:18:16 <geekosaur> import XMonad
18:18:18 <zoomshorts> geekosaur: do I remove the first ones?
18:18:22 <geekosaur> main = xmonad defaultConfig
18:18:41 <zoomshorts> the manpages geeko
18:18:42 <geekosaur> also I see missing commas on lines 43 and 50
18:18:44 <SrPx> heatsink: nope
18:18:54 <ReinH> sclv: a previous attempt at this sort of thing ran against YHC core to output haskell for GHC :)
18:20:25 <heatsink> SrPx: See http://www.hyperedsoftware.com/blog/entries/first-stab-th.html for how to use TH
18:20:28 <geekosaur> my xmonad manpage has no "default" xmonad.hs
18:20:45 <heatsink> It builds Haskell expressions at compile time.
18:20:56 <zoomshorts> it's in /usr/share/xmonad/man/xmonad.hs
18:21:57 <zoomshorts> lookit this disgrace
18:21:57 <zoomshorts> http://pastebin.com/QTtxewbT
18:22:06 <zoomshorts> that's in the stable package I swear
18:22:25 <zoomshorts> it's what I used to make mine
18:22:55 <ReinH> what's wrong with it?
18:22:57 <geekosaur> commas look in the right place in there
18:23:08 <zoomshorts> b-b-but
18:23:14 <zoomshorts> I copied and pasted
18:23:15 <zoomshorts> wut
18:23:20 <zoomshorts> QQ
18:23:21 <geekosaur> really does `modm .|. shiftMask,` look like `modm, .|. shiftMask` to you?
18:23:39 <zoomshorts> I guess XD
18:23:45 <zoomshorts> fixin'
18:23:55 <ReinH> never attribute to the stupidity of others that which can be adequately explained by your own :)
18:24:13 <geekosaur> http://lpaste.net/103100 see also http://lpaste.net/diff/103098/103100
18:24:15 <ReinH> not that you're stupid, but generally the first place to look is for your own mistakes
18:24:25 <ReinH> not in a file that's been around for probably years with plenty of review
18:24:31 <geekosaur> I think I got all of them
18:24:36 <zoomshorts> I shall do this m'lord
18:24:47 <zoomshorts> together we may sperad the gloriouse haskell masterrace
18:24:59 <geekosaur> ReinH, that file is still a bit old since it's missing the huge comment it's had for the past close to a year saying DON'T USE THIS
18:25:11 <ReinH> geekosaur: :)
18:25:22 <ReinH> geekosaur: but it's syntactically valid
18:25:24 <geekosaur> but, "stable" --- I take it Debian? gonna be a while before they catch up
18:25:37 <geekosaur> ReinH: for now
18:25:41 <ReinH> yep
18:26:05 <geekosaur> the problem with it is a long term maintenance one: if we change something, this config will never know because it's slapping all the defaults from the version it came from on top of it
18:26:33 <geekosaur> I have spent the past year trying to track down and stomp out everything suggesting that is in any way, shape, or form a good idea
18:26:40 <geekosaur> yet people keep using that so called default
18:27:22 <geekosaur> it's not a default, it's an example, and using it basically means "never upgrade xmonad because if you're lucky you won't see the updates and if you're not it'll break"
18:27:59 <zoomshorts> so geekosaur how am I to create a config without the template
18:28:16 <geekosaur> zoomshorts, you're supposed to read it to see how things work
18:28:52 <zoomshorts> so I did the right thing but with shitty near-dyslexic brainfarts?
18:28:55 <geekosaur> if you insist on starting from that, then you should REMOVE anything you are not specifically adding or modifying, because you get it from defaultConfig
18:29:25 <zoomshorts> I did
18:29:27 <zoomshorts> I think
18:29:38 <zoomshorts> but how would I do anything not starting from that?
18:29:40 <geekosaur> a better idea is to look at http://www.haskell.org/haskellwiki/Xmonad/Config_archive/John_Goerzen%27s_Configuration which guidesyou through building a config
18:29:47 <zoomshorts> I don't insist, it's the only option I know of
18:30:08 <zoomshorts> HOW DID THIS PAGE ESCAPE ME DAMNIT
18:30:09 <zoomshorts> ty
18:30:09 <geekosaur> you still havea biunch of default keybindings in there
18:30:20 <zoomshorts> oh those
18:30:28 <zoomshorts> I left them in for future changing
18:30:46 <zoomshorts> also I think some are controlmasks instead of shiftmasks
18:30:51 <zoomshorts> and the modkey is mod4
18:30:53 <geekosaur> that's been a problem in the past because the binding for dmenu had to be changed to accommodate their change in how to run it a couple years ago
18:30:58 <savanni> Having written many different configurations in a variety of languages over the years, I look forward to Someone Else's idea of How It Should Be Done.
18:31:17 <geekosaur> and everyone using that "default config" had to fix it manually because they stomped over our correction with the old one that no longer worked
18:32:35 <geekosaur> hm, actually you can't just remove keybindings, you also need to change how they're hooked in. Goerzen's tutorial should show how to do that right
18:32:58 <mm_freak> hi again…  i started to define my lenses in terms of Strong instead of (->), but i noticed that the Lens type is defined in terms of (->)
18:33:00 <geekosaur> we generally recommend not even using that style of keybinding any more, though; additionalKeysP is easier to use and understand
18:33:02 <mm_freak> is there a reason for that?
18:33:08 <mm_freak> _fst :: (Functor f, Strong p) => p a (f b) -> p (a, c) (f (b, c))
18:33:09 <mm_freak> _fst = rmap (\(x, y) -> fmap (, y) x) . first'
18:33:37 <geekosaur> and you don't need the glob of wtf that digs your modifier out of the config record
18:34:24 <zoomshorts> okay one error left
18:34:33 <SrPx> joelteon: great reception at #ghc...
18:34:52 <zoomshorts>   chellMouseBindings (XConfig {XMonad.modMask = modm}) = M.fromList $
18:35:00 <zoomshorts> something about a missing parenthesis
18:35:01 <zoomshorts> where
18:35:02 <carter> SrPx: sorry, i'm deep in benchmarking today.. so i'm a bit ocd today
18:35:05 <zoomshorts> >:O
18:36:08 <carter> SrPx: didn't meant to be antagonistic
18:36:14 <zoomshorts> gee0geekosaur
18:36:15 <zoomshorts> pls
18:36:32 <zoomshorts> Ill giff u techies if u giff me parenthesis
18:36:46 <geekosaur> oh I forgot to remove that ++ when I copied it too, sigh
18:37:02 <geekosaur> and I suppose I have to transfer this to the other system and compile it because yoi're not providing full compiler errors
18:37:09 <copumpkin> SrPx: there is effort going on along the lines of what you were asking. Mostly called supercompilation (I'd tell you more but am only half paying attention, on the phone; google will help though)
18:37:16 <geekosaur> the one that's busy and going to be a PITA
18:37:18 <zoomshorts>   chellMouseBindings (XConfig {XMonad.modMask = modm}) = M.fromList $
18:37:20 <zoomshorts> oopse
18:37:24 <zoomshorts> copy paste not working
18:37:25 <zoomshorts> sry
18:37:26 <geekosaur> no that line won't be it by itself
18:38:21 <carter> copumpkin: oh yeah
18:38:28 <ticktockman> http://www.well-typed.com/blog/90/ Is this still true?
18:38:58 <carter> ticktockman: it was written like this month wasn't it?
18:39:05 <carter> so yeah, use foldl'  instead of foldl
18:39:07 <SrPx> copumpkin: I have read pretty much all papers on supercompilation, thank you
18:39:20 <zoomshorts> geekosaur: what did the ++'s do anyway? if they were in the manpage I would kinda think that they are important...
18:39:30 <ticktockman> carter: Cool. Thanks!
18:39:41 <geekosaur> you keep talking about this manpage, it's not in any manpage I can find
18:39:46 <carter> SrPx: have you seen max's thesis?
18:39:59 <geekosaur> but what it *did* was there was an additional set of things that you somehow managed to delete, the screen focus bindings
18:40:16 <SrPx> carter: probably, why?
18:40:18 <zoomshorts> I don't even
18:40:19 <geekosaur> that set of bindings vanished but the ++ that appends it to the other keybindings is still there
18:40:44 <zoomshorts> I probably moved it thinking the problem was their placemeant in relation to the ++
18:41:55 <zoomshorts> I was probably wrong
18:42:00 <carter> SrPx: i have a copy of it locally, but its really hard to find online
18:42:14 <carter> "Call-by-need supercompilation" by Max BolingBroke
18:42:20 <carter> *Bolingbroke
18:42:33 <carter> i can upload a link
18:42:47 <carter> also, c++ has BigInt support?
18:43:18 <carter> SrPx: found it http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-835.pdf
18:43:23 <SrPx> if that is the case probably not, you could send me if you have time. what is special about it?
18:43:36 <carter> its pretty much the state of the art
18:43:41 <geekosaur> zoomshorts, if you're interested, the missing chunk is more or less http://xmonad.org/xmonad-docs/xmonad/src/XMonad-Config.html#line-219
18:44:16 <SrPx> Oh.
18:44:21 <SrPx> I was reading that yesterday, not kidding
18:44:28 <carter> cool
18:44:41 <carter> SrPx: just to contextualize, i'm working on writing HPC numerical code in haskell
18:44:50 <carter> like, thats been my focus for ~ 1-2 years now
18:44:50 <zoomshorts> geekosaur: how can it be missing? didn't you say defaults would just replace it?
18:45:20 <geekosaur> ticktockman, this is a difference in opinion between the language committee, which is notoriously conservative, and the Haskell community. I am not sure it will easily be changed, especially since there *are* a (very few) uses where the standard foldl makes sense
18:46:06 <geekosaur> it is missing syntactically (because you left the ++ in), and it is missing semantically because I had forgotten this config slaps the whole keybinding into place instead of adding to it
18:46:19 <geekosaur> which requires a tweak later on
18:46:25 <zoomshorts> okay then
18:47:10 <geekosaur> (same overwrite-the-world problem in a different place)
18:47:15 <geekosaur> it's a pain
18:47:39 <cjenkin1> I'm having trouble installing scion-lib, seems to be related to this issue: http://code.google.com/p/scion-lib/issues/detail?id=54
18:48:02 <cjenkin1> Anyone here install scion successfully and can give me some advice?
18:48:18 <geekosaur> anyway if I were doing this, most of the outside bindings would be inside the config record and all the keybindings would be done with additionalKeysP instead of the old style used by that example config
18:48:47 <zoomshorts> see how did you learn how to do that
18:48:50 <zoomshorts> without configs
18:50:34 <geekosaur> well, I learned it because I've been using xmonad since 0.2 :) but we don't tend to point people to that bad config, we tell people to use the Goerzen tutorial that I pointed you to. what random linux distros tell people to do is not under our control, sadly
18:50:43 <dashster18> Is this an inappropriate place to discuss category theory?
18:50:47 <geekosaur> arch linux used to recommend some batshit things...
18:52:33 <zoomshorts> like what
18:52:37 <zoomshorts> tell me the stroies
18:52:39 <carter> dashster18: i think theres a ##category-theory channel
18:52:47 <geekosaur> and again, the manpage *we* provide makes no reference to that config. it points you to our documentation page which tells you to start from Goerzen's tutorial
18:53:19 <zoomshorts> you're a maintainer of the pacman package I expect?
18:53:24 <geekosaur> no
18:53:24 <dashster18> carter: Do you know if that channel is from a mathematician's point of view or a computer scientist's point of view?
18:53:31 <carter> go an ask?
18:53:34 <zoomshorts> ... whose we
18:53:39 <geekosaur> I'm an xmonad developer, I don't maintain any distribution packages
18:53:52 <zoomshorts> you have some teeth to kick in
18:54:02 <geekosaur> and "we" is the folks who maintain and develop xmonad, who mostly hang out in #xmonad
18:54:13 <zoomshorts> .tar.gz clearly contains /usr/share/man/xmonad.hs
18:54:18 <zoomshorts> grab your pitchforks
18:54:21 <geekosaur> that's not a "manpage"
18:54:30 <dashster18> carter: Is it supposed to have 2 #'s or 1?
18:54:37 <carter> i think two
18:54:40 <carter> i don't know
18:54:48 <zoomshorts> okay it's a shady file in a man directory
18:54:52 <geekosaur> and our version has a big comment at the top explaining that you are supposed to read it to see how things work, but not to use it
18:54:55 <dashster18> No one in either
18:55:04 <mm_freak> dashster18: /list #category-theory
18:55:07 <carter> i might be spelling it wrong
18:55:13 <mm_freak> if you want to see what it is without joining =)
18:55:20 <zoomshorts> would you version ahppen to be xmonad-darcs?
18:55:26 <mm_freak> the one with one # is pretty much empty
18:55:30 <geekosaur> and if it's actually in /usr/share/man then (a) debian has it in entirely the wrong place (b) and it wouldn't be found by the man command since .hs is not a manpage extension
18:55:35 <hattusili_III> I am writing a haskell web client library, and im wondering how to handle errors in deserializing JSON data. Right now i'm returning `Either String b`s, but this is getting very unwieldy, with nested Either types and Maybes coming up due to the API I'm consuming
18:55:42 <dashster18> mm_freak: Thanks!
18:55:49 <geekosaur> if you meant /usr/share/examples then it's in the right place but still missing our documentation comment at the top
18:56:03 <mm_freak> dashster18: CT questions are fine here, btw
18:56:21 <geekosaur> btw one of us has already worked over the arch stuff, which is why I said "used to"
18:56:24 <dashster18> Ah nice
18:56:28 <mm_freak> in fact i often get better answers to math questions here than in ##math =)
18:56:36 <dashster18> Haha that's pretty sweet
18:57:06 <dashster18> I like the theory side of CS. I get my math fix and can do actual math while still getting a CS paycheck. :P
18:57:08 <mm_freak> well, at least to algebra questions
18:57:26 <mm_freak> "I get my math fix"…  welcome to CS =)
18:58:14 <dashster18> Ah so you might be able to answer a question I had earlier. Worth learning Abstract Algebra for CS? I mean I'd learn it because it's cool and it's dsicrete math, but does it apply to CS?
18:59:46 <geekosaur> other problems with the arch wiki's documentation (still I think uncorrected) include an almost completely incorrect discussion of how to use scrot with window managers (including xmonad)
18:59:46 <mm_freak> dashster18: absolutely
18:59:46 <mm_freak> if you ask a haskell programmer =)
18:59:46 <geekosaur> as for debian, there's this little problem that debian's rate of change is glacial. "stable" is like the biologist's definition: dead
18:59:46 <dashster18> Cool, I found some pretty good vids (at least I think they're good) on yt.
18:59:46 <zoomshorts> well I just scrapped the old config entirely
18:59:46 <zoomshorts> not worth saving anyways
18:59:46 <mm_freak> dashster18: when people ask me what's the best web framework, i usually answer: "algebra" =)
18:59:46 <dashster18> And I also was linked to a great video series covering category theory, type theory, and proof theroy.
18:59:46 <dashster18> Haha
18:59:46 <zoomshorts> since arch wont giff me the right shit to learn is there anything else I should see geekosaur ??
18:59:46 <mornfall> geekosaur: c'mon, glacial can be a positive property :-)
18:59:46 <mornfall> dashster18: abstract algebra, go for it
18:59:46 <zoomshorts> or is http://www.haskell.org/haskellwiki/Xmonad/Config_archive/John_Goerzen%27s_Configuration enough
18:59:46 <yac> I'm not a math whiz and looking into homomorphisms and it looks like homomorphism is basicly a function that takes `a` and turns into other `a`. Correct [y/n]?
18:59:58 <mm_freak> yac: n
19:00:15 <geekosaur> zoomshorts, it should be enough although it may be helpful to do some intro-to-Haskell first
19:00:16 <mornfall> yac: homomorphism is an operation-preserving map
19:00:17 <geekosaur> @where lyah
19:00:17 <lambdabot> http://www.learnyouahaskell.com/
19:00:19 <geekosaur> ^
19:00:25 <hattusili_III> does anyone have any advice?
19:00:30 <mornfall> yac: (for some value of operation-preserving)
19:00:32 <zoomshorts> geekosaur: I will return when I know what ++ does
19:00:43 <geekosaur> it just concatenates lists
19:00:45 <zoomshorts> geekosaur: until then oniichan
19:00:47 <dashster18> zoomshorts: ++ is list append
19:00:52 <geekosaur> ...
19:01:00 <bitemyapp> geekosaur: I don't like LYAH.
19:01:01 <geekosaur> wanted to tell them to return to #xmonad
19:01:06 <bitemyapp> It's a nice reference.
19:01:08 <geekosaur> since this channel is a bit busy
19:01:25 <dashster18> bitemap: how come?
19:01:32 <dashster18> bitemyapp: how come?
19:01:44 <mm_freak> dashster18: type "bi" and hit tab
19:01:57 <dashster18> I'm in emacs
19:02:04 <mornfall> might still work
19:02:07 <mm_freak> then it's probably C-tab =)
19:02:07 <dashster18> Ah, it works
19:02:10 <mm_freak> ah
19:02:14 <dashster18> I just had to complete more characters
19:02:21 <dashster18> Tab, not C-Tab
19:02:33 <mm_freak> Tab Tab might give you a list of nicks
19:02:37 <dashster18> Yep
19:02:48 <dashster18> Ooh, and a list of '/' commands
19:02:50 <mornfall> I like the magical mistabbing feature in irssi.
19:03:11 <mornfall> Most of the time it DWIMs.
19:03:12 <mm_freak> tabbing in irssi is really awkward, when you're used to shell-style completion
19:03:20 <mornfall> Only when it doesn't.
19:04:07 <Clint> depends which shell-style completion you're used to
19:04:31 <dna_> hey, does anyone know if implicit params can be added to existing typeclass functions? I'd like a param to pass through to my definition of show. I've tried forcing it with InstanceSigs, but it doesn't like that the overridden signature doesn't match.
19:04:51 <mornfall> dna_: sounds like a really bad idea to me
19:05:03 <bitemyapp> dashster18: https://gist.github.com/bitemyapp/8739525
19:06:23 <dashster18> bitemyapp: Ah I was just curious. I've already worked through LYAH and WYS48.
19:06:32 <dashster18> The first time I tried LYAH it was boring.
19:06:41 <dashster18> That was because it was slow at the beginning.
19:06:49 <dna_> mornfall: I don't doubt that, just curious if it's at all possible. You could argue that ImplicitParams are an overall bad idea.
19:06:52 <yac> lets try something simpler. return is also known as unit [y/n] ?
19:06:58 <bitemyapp> dashster18: that's what I say in the gist.
19:07:08 <dashster18> But then I tried again, but this time I powered through it in a week and a half.
19:07:15 <bitemyapp> dna_: don't use ImplicitParams
19:07:16 <dashster18> And I found that to be the right pace.
19:07:20 <mm_freak> Clint: "ambiguous from here, please keep typing"
19:07:29 <mm_freak> the usual bash style
19:07:31 <dashster18> But I was moving fast. I found that after chapter 6, it picks up.
19:07:40 <dashster18> And I did the first 6 chapters in a day or two.
19:08:03 <mm_freak> yac: y
19:08:49 <mm_freak> dna_: see the reflection library
19:09:02 <dashster18> Why did haskell choose to name the function return?
19:09:17 <srhb> dashster18: Mazimize confusion potential
19:09:21 <srhb> We have to avoid success at all costs.
19:09:30 <mm_freak> dashster18: there isn't really a good name for it
19:09:32 <dna_> bitemyapp: ok, what's the best way to thread an environment map throughout my code then? I've tried a reader transformer in the past. Took a lot of effort / made doing IO complicated.
19:09:38 <dna_> mm_freak: taking a look, thanks!
19:09:42 <mm_freak> dashster18: i like to call it 'singleton' sometimes
19:09:43 <yac> cool. Then bind, aka >>= is also known as join function [y/n] ?
19:09:48 <mm_freak> other times i like to call it 'pure'
19:09:55 <mm_freak> and sometimes i actually like the name it has
19:10:02 <geekosaur> because back in the day someone thought it was similar enough to return in imperative languages to be an easier mnemonic for beginners
19:10:13 <mm_freak> yac: n
19:10:20 <geekosaur> by the time it was realized that that was a dumb idea, it was kinda too late to change it
19:10:26 <srhb> I've come to like the name now, sadly.
19:10:28 <mm_freak> yac: compare the type signatures of (>>=) and 'join'
19:10:49 <geekosaur> yac: join is *half* of (>>=)
19:10:58 <dashster18> Heh, I like srhb's answer.
19:11:32 <dashster18> geekosaur: Oh well, every language has a few missteps. At least haskell only has a few that I've seen so far.
19:12:00 <srhb> return isn't really a misstep, not as much as fail being a part of Monad at least.
19:12:21 <srhb> The naming of return makes sense for _some_ ways of approaching monads.
19:12:44 <dashster18> srhb: misstep was too strong of a word.
19:12:55 <mm_freak> dashster18: haskell has a bunch of historical mistakes we have to work around, but fortunately they make the language "less beautiful" rather than "wrong"
19:13:32 <dashster18> mm_freak: Yeah, it's not wrong. Misstep was too strong of a word. I guess maybe unclean? Or like you said less beautiful.
19:13:46 <danclien> yac: >>= could be implemented as using `join` and `map` (I think)
19:13:51 <srhb> dmwit said on Reddit that non-exhaustive patterns will cause your value to get a MonadFail constraint in the future -- that's an absolutely fantastic solution to fail I think. I'd never even considered that possibility.
19:14:03 <danclien> Er... `fmap`
19:14:24 <srhb> non-exhaustive patterns in a do-block*
19:14:32 <mm_freak> dashster18: it's like finding a good name for (>=>)
19:14:46 <dashster18> mm_freak: What is the name for that operator anyway?
19:14:49 <ReinH> mm_freak: flip compose? :p
19:14:53 <mm_freak> dashster18: you could call it flip compose =)
19:15:11 <srhb> :t (>=>)
19:15:12 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:15:17 <geekosaur> srhb: no? it's just renamed MonadZero as has been proposed for about as long as people have been complaining about fail
19:15:32 <mm_freak> but more intuitively you could call it sometimes "and then", sometimes "followed by", sometimes "forwarded to", …
19:15:43 <geekosaur> or maybe backwards MonadZero depending
19:15:43 <dashster18> mm_freak: Heh, most people I know don't do haskell so at least I don't have to worry about saying >=> out loud. However, not knowing people who are into haskell leads to it's own problems..
19:15:45 <mm_freak> but then "and then" is often a good name for (>>)
19:16:07 <srhb> "and then-ish"
19:16:21 <ReinH> mm_freak: meanwhile, at least one introduction to free monads calls >>= "Then" :)
19:16:24 <metaldart> is there an IRC channel or place that I can get 1-on-1 help with haskell? I have a hw assignment Id like help with and not spam here
19:16:31 <mm_freak> hehe
19:16:37 <srhb> metaldart: I have time
19:16:50 <mm_freak> metaldart: it's probably best to spam here =)
19:16:55 <srhb> Or that :)
19:17:08 <hattusili_III> I am writing a haskell web client library, and im wondering how to handle errors in deserializing JSON data.
19:17:17 <hattusili_III> Right now i'm returning `Either String b`s, but this is getting very unwieldy, with nested Either types and Maybes coming up due to the API I'm consuming
19:17:37 <mm_freak> hattusili_III: you could use regular IO exceptions
19:17:53 <yac> is it possible "join" has multiple meanings?
19:17:54 <dashster18> metaldart: this channel is for beginner haskell help too
19:17:56 <mm_freak> alternatively you can use your favorite error transformer like EitherT
19:18:01 <cjenkin1> Does someone have a moment to help me configure haskell-mode for emacs?
19:18:02 <mm_freak> yac: n
19:18:05 * hackagebot husk-scheme 3.17 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.17 (JustinEthier)
19:18:09 <mm_freak> yac: it has one meaning per monad
19:18:11 <yac> https://en.wikibooks.org/wiki/Haskell/Category_theory#Monads here it seems defined just as bind
19:18:15 <srhb> cjenkin1: "a moment" is very optimistic.
19:18:15 <ReinH> mm_freak: beat me to it
19:18:18 <cjenkin1> heh
19:18:20 <srhb> cjenkin1: What's the problem?
19:18:29 <mm_freak> ReinH: ?
19:18:33 <cjenkin1> srhb: ghc-merge-keywords: Wrong type argument: listp, it
19:18:43 <ReinH> mm_freak: the "one meaning per monad"
19:18:44 <cjenkin1> That's the error I'm getting when I try to load a Haskell file with emacs
19:18:45 <srhb> Hm, haven't experienced that.
19:18:47 <ReinH> mm_freak: I was typing that
19:18:50 <ReinH> :p
19:18:53 <mm_freak> ah =)
19:18:55 <hattusili_III> mm_freak, do you think acceptions would be appropriate? how can one decide when to use exceptions vs. Either/Maybe
19:19:08 <dashster18> Can you write your own typeclasses in haskell?
19:19:13 <ReinH> yac: how does that link define join?
19:19:23 <mm_freak> hattusili_III: when something depends on IO anyway, i tend to use IO exceptions
19:19:36 <mm_freak> hattusili_III: otherwise i usually prefer Either/Maybe
19:19:49 <mm_freak> dashster18: of course
19:19:49 <cjenkin1> srhb, and above it: File mode specification error: (wrong-type-argument listp it
19:20:22 <mm_freak> dashster18: your first haskell programs will be full of type classes…  after a few months/years of experience you will only define a type class when it's absolutely necessary =)
19:20:40 <structuralist> is there a Haskell class for types with a metric?
19:20:44 <dashster18> mm_freak: How do you define your own?
19:20:53 <mm_freak> structuralist: see the 'linear' library
19:21:11 <ReinH> mm_freak: assuming that's what is meant by "metric"
19:21:14 <mm_freak> dashster18: class Semigroup a where (<>) :: a -> a -> a
19:22:01 <dashster18> Ah cool
19:22:12 <mm_freak> ReinH: i'm pretty sure it is that =)
19:22:17 <ReinH> ok :)
19:22:48 <mm_freak> metric is one of the few math terms that is almost unique when you add the "makes sense/can be done in a programming language" constraint =)
19:23:44 <structuralist> is there one for things that aren't vector spaces?
19:23:54 <yac> ReinH: hm, not sure.
19:24:12 <yac> So, monad is a structure that must have two operations, right?
19:24:34 <mm_freak> structuralist: the Additive constraint doesn't make sense in your case?
19:25:01 <mm_freak> yac: that's the definition haskell uses
19:25:05 <yac> And those operations are unit and bind - http://www.haskell.org/haskellwiki/What_a_Monad_is_not#Monads_are_not_about_strictness , right?
19:25:26 <mm_freak> yac: the mathematical definition usually requires three:  fmap, join, return
19:25:32 <ReinH> yac: the two most common formulations are (return, bind) or (return, fmap, join)
19:25:36 <ReinH> they are equivalent
19:25:37 <structuralist> mm_freak: it does but I'm just wondering
19:25:42 <yac> and bind can be constructed with join and fmap, right?
19:25:47 <ReinH> and vice versa, yes
19:26:49 <mm_freak> structuralist: the linear library is in terms of functors, so you always have the 'f a' vs. 'a' distinction, and you can interpret 'f a' as "vector" and 'a' as "scalar"
19:27:28 <mm_freak> structuralist: there is also conal's 'vector-space' library, which gives you a bit more freedom, but uses more ad hoc definitions rather than categorical ones
19:27:56 <dna_> mm_freak: looking at the example here (https://github.com/ekmett/reflection/blob/master/examples/ReaderLike.hs), threading a config environment is going to wreak havoc on my type signatures... this is better than implicit params?
19:28:17 <mm_freak> structuralist: but it actually requires it to be an inner product space
19:28:55 <metaldart> so as said before I have a hw question. Im supposed to write selection sort with the following type signature: selection_sort::(Eq a)=>(a->a->Bool)->[a]->[a]
19:29:13 <mm_freak> dna_: yes
19:29:16 <structuralist> I see
19:29:17 <structuralist> thanks!
19:29:21 <metaldart> the gut feeling is to use Ord a, but I HAVE to use this type signature
19:29:32 <mm_freak> dna_: really all it adds is the Reifies constraint
19:29:40 <ReinH> metaldart: you can't use Ord
19:30:00 <metaldart> example code used Ord so that was one reason I guessed I would have to
19:30:02 <fragamus> mm_freak: I have been worrying a bit about Mathematica
19:30:19 <ReinH> I'm not sure how you write a sort without being able to compare elements
19:30:36 <mm_freak> metaldart: what's the first argument?  less-than?
19:30:45 <dashster18> mm_freak: yeah
19:30:53 <fragamus> mm_freak: why am I worried about mathematica you ask?
19:31:05 <mm_freak> metaldart: f (<) xs = …;  does that help?
19:31:11 <metaldart> it can be > or <, we should be able to sort in either order
19:31:23 <ReinH> mm_freak: that would have an Ord constraint
19:31:24 <mm_freak> fragamus: do tell
19:31:28 <mm_freak> ReinH: nope
19:31:37 <ReinH> :t (<)
19:31:38 <lambdabot> Ord a => a -> a -> Bool
19:31:39 <ReinH> no?
19:31:42 <mm_freak> ReinH: nope
19:31:46 <dwcook> ReinH, (<) shadows Ord's (<)
19:31:48 <mm_freak> ReinH: it's not Ord's (<)
19:31:51 <fragamus> mm_freak: here's why: As a language Haskell is bitchen, and blows away the typeless blight that is mathematica, BUT...
19:31:51 <ReinH> huh
19:32:08 <mm_freak> > let f (+) x y = x^2 + y^2 in f (*) 3 4
19:32:09 <lambdabot>  3433683820292512484657849089281
19:32:11 <dwcook> > let (<) = const True in (1 < 2, 2 < 2, 3 < 2)
19:32:12 <lambdabot>  Couldn't match expected type ‘a0 -> t’
19:32:12 <lambdabot>              with actual type ‘GHC.Types.Bool’Couldn't match expected type ‘a...
19:32:12 <lambdabot>              with actual type ‘GHC.Types.Bool’Couldn't match expected type ‘a...
19:32:12 <lambdabot>              with actual type ‘GHC.Types.Bool’
19:32:27 <metaldart> mm_freak: so youre saying for any function f if I pass it < on a list do some work
19:32:37 <fragamus> mm_freak: Mathematica has hundreds of man years in its symbolic manipulation code
19:32:53 <mm_freak> metaldart: you're just calling the first argument (<) and pretending that it's a less-than
19:33:00 <dwcook> Woops >_<
19:33:09 <fragamus> Some problems, like one I encountered recently, are best expressed in their pure mathematical form…
19:33:11 <mm_freak> metaldart: you could equivalently write:  f lessThan xs = …
19:33:14 <dwcook> > let (<) = const (const True) in (1 < 2, 2 < 2, 3 < 2)
19:33:15 <lambdabot>  (True,True,True)
19:33:20 <ReinH> ah
19:33:58 <metaldart> mm_freak, okay thats good to know
19:34:04 <fragamus> Like a certain integral I dealt with recently….  I asked mathematica to do the integration, and it produced a huge expression which I analyzed for common subexpressions...
19:34:06 <mm_freak> metaldart: rather "assuming" than "pretending" =)
19:34:25 <fragamus> and finally emitted haskell code
19:34:37 <mm_freak> fragamus: is there a reason why you're addressing me specifically?  i have no mathematica experience at all =)
19:34:41 <fragamus> but haskell is like a back end in this picture
19:34:45 <metaldart> mm_freak: haha. thanks for all the help, it's appreciated
19:34:57 <fragamus> mm_freak: I dunno
19:35:29 <dashster18> :t sortPred pred (x:xs) = sortPred pred [a | a <- xs, pred a x] ++
19:35:29 <dashster18>                      [x] ++
19:35:29 <dashster18>                      sortPred pred [a | a <- xs, not (pred a x)]
19:35:29 <dashster18>  
19:35:30 <lambdabot> parse error on input ‘=’
19:35:47 <dashster18> :t sortPred pred (x:xs) = sortPred pred [a | a <- xs, pred a x] ++ [x] ++ sortPred pred [a | a <- xs, not (pred a x)]
19:35:47 <dashster18>  
19:35:48 <lambdabot> parse error on input ‘=’
19:35:53 <dashster18> Fml
19:35:59 <fragamus> anyhow, I think that haskell needs some kind of symbolic math engine in order to keep up with the Wolframs
19:36:38 <fragamus> because they can easily catch up to haskell
19:36:44 <mm_freak> fragamus: haskell is a programming language…
19:36:49 <fragamus> regarding functional programming
19:37:09 <mm_freak> if you need it, you can write a symbolic math EDSL
19:37:22 <fragamus> yes, and now mathematica is one too…  it's called wolfram…    it sucks in many many ways, but
19:37:23 <dashster18> Man, ghci is awesome. It has emacs key bindings. In PowerShell on Windows.
19:37:37 <fragamus> we need symbolic math that isn't controlled by them
19:37:39 <monochrom> they can, but they won't
19:37:41 <mm_freak> but i tend to just fire up maxima, when i need to integrate
19:38:01 <fragamus> yes we can start with maxima
19:38:20 <yac> It seems the meaning of "return" depends on where it is used, "inside" which monad it is used. Is it the unit for the monad it's used in?
19:38:26 <fragamus> but we have a lot of catching up to do
19:38:37 <mm_freak> yac: y
19:38:51 <monochrom> everyone can catch up to haskell. yet everyone won't.
19:38:58 <fragamus> I want my code to look like the original problem...
19:39:33 <fragamus> well, if our goal is to make our code the most concise expression
19:39:39 <dashster18> I didn't catch this earlier, but can haskell even symbolically integrate?
19:39:40 <mm_freak> fragamus: symbolic integration is an AST operation…  a rather simple but tedious one in fact
19:39:49 <cwvh> fragamus: have you played around with automatic differentiation?
19:39:50 <mm_freak> so i'm not sure what you're comparing
19:39:53 <fragamus> we need to think about the expressivity of mathematica
19:40:06 <fragamus> yes for many years
19:40:31 <fragamus> I used macsyma from symbolics back in the early 80s at NASA
19:40:40 <mm_freak> dashster18: symbolic math expressions are ASTs, haskell can easily represent and manipulate ASTs…  does that answer your question?
19:40:44 <cwvh> macsyma did automatic differentiation?
19:40:50 <fragamus> yes
19:40:51 <monochrom> symbolic math belongs to a library, when we talk about haskell
19:40:57 <dashster18> mm_freak: Yeah. That'd be a cool project. Write an integrator.
19:41:08 <cwvh> I thought macsyma only did symbolic differentiation.
19:41:19 <fragamus> right
19:41:21 <dashster18> cwvh: It did integration as well as an MIT freshmen.
19:41:31 <mm_freak> dashster18: it's a lot of laborious work if you want something that is actually useful
19:41:34 <fragamus> I suppose your automatic differentiation is something else then
19:41:41 <yac> Good. Why I found these things difficult to learn: 1. I had to figure out that return is unit, am I just a bad reader? 2. join is much easier to understand than bind and it seems to me that some articles about monads are confusing these two too maybe?
19:41:45 <cwvh> fragamus: very much so and I highly suggest you look into it  :-)
19:42:05 <heatsink> Mathematica's documentation rubs me the wrong way.  It gives you lots of examples of how to use functions, but handwaves about what the functions actually _do_.
19:42:13 <fragamus> yes this is the kind of thing that can eat up hundreds of man years and you're still nowhere
19:42:22 <carter> heatsink: yesss
19:42:28 <carter> "how does it work"
19:42:28 <heatsink> haha
19:42:39 <mm_freak> yac: 1. i understand your confusion, and it's not you at all, 2. 'join' is easier to understand, but often (>>=) is easier to define
19:42:42 <carter> "how do i verify its not lying"
19:42:48 <heatsink> yeah
19:42:57 <monochrom> yac: join is easier than bind in some cases, harder in other cases. when I explain IO, I don't know how to describe join, but I know how to describe bind.
19:43:23 <heatsink> Or, how does it choose whether to behave like example 2 or example 1, which aren't the same thing?
19:43:25 <monochrom> while I am at it, advertisement: my I/O tutorial at http://www.vex.net/~trebla/haskell/IO.xhtml
19:43:30 <cwvh> fragamus: auto diff gives you the ability to take derivatives of, say, a Haskell function with a forM_ in it. The derivatives are exact and not numerical approximations. Quite interesting stuff. Check out Ed Kmett's "ad" library.
19:43:42 <fragamus> Anyhow, I want to try to at least raise awareness about the problem that I perceive
19:43:48 <fragamus> Will do
19:43:51 <monochrom> in fact, when I explain IO, CPS is even easier to describe than bind, haha
19:44:02 <yac> actually, the 1. point is probably general issue with the notation of operators.
19:44:47 <yac> While I got most of my understanding about monads from http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf I don't think it explains the infix notation for the operators
19:45:05 <mm_freak> yac: some names could have been better, but those are historical mistakes that are hard to fix without breaking a lot of stuff
19:45:12 <yac> and that's something I still don't know how to work with
19:45:39 <mm_freak> while we're at it…  "baastad"…  what an unfortunate name…
19:46:07 <monochrom> hehe
19:47:01 <monochrom> hmm, only one operator is infix, right?
19:47:47 <mm_freak> yac: i haven't read it, but most monad tutorials assume some basic knowledge about haskell syntax
19:48:00 <monochrom> he uses a 5-point star for >>=
19:48:20 <mm_freak> and we're back to unfortunate names
19:48:30 <fragamus> lol dude
19:48:44 <yac> for example the book uses example: type M a = a ; (*) :: M a -> (a -> M b) -> M b ; a * k = k a
19:49:08 <yac> I used ; instead of \n and the * is bind function, right?
19:49:15 <mm_freak> yac: yes
19:49:20 <monochrom> the star-spangled monad tutorial :)
19:49:44 <mm_freak> yac: it also seems to use a common convention:  'k' for "kontinuation"
19:50:00 <yac> so now I have implementation like "a * k", well a >>= k
19:50:06 <mm_freak> yes, it should be c, but we have only 26 single-letter variable names…
19:50:55 <mm_freak> yac: note also that the monad defined there is called the "identity" monad, but can't be defined the same way in haskell
19:51:04 <yac> which is a little weird to me, because it takes M a, not a
19:51:05 <mm_freak> yac: newtype Identity a = Identity a
19:51:18 <mm_freak> yac: as defined:  M a = a
19:51:26 <mm_freak> so 'M a' and 'a' are identical
19:51:43 <monochrom> but writing "M a" helps you see the parallel with other examples
19:51:58 <yac> and mainly I had no idea how to use it outside the definition. It came to me now only because I realize it's >>= and I've seen that used in the code as a something that reminds me of shell pipe
19:52:46 <yac> mm_freak: so that's only for the purpose of defining the operations for type M a  ?
19:54:06 <mm_freak> yac: the identity monad is one of the simplest monads, and it's precisely the one where 'M a' and 'a' are isomorphic (read: "alter egos of each other")
19:54:13 <mm_freak> in the tutorial they are actually identical
19:54:41 <mm_freak> it's commonly one of the first examples
19:54:53 <yac> right
19:55:29 <yac> that's where the data M a = unit1 b | unit2 c comes in for non-identities, right?
19:55:48 <mm_freak> that type doesn't make sense to me
19:56:09 <yac> example: data M a = Raise Exception | Return a ... do I understand right that Raise and Return are different unit functions?
19:56:22 <mm_freak> no, only Return is unit
19:56:28 <mm_freak> 'unit' is unique
19:56:56 <yac> so in case of Maybe monad, what is Nothing and what is Just ?
19:57:09 <mm_freak> Just is unit, and Nothing is something monad-specific
19:57:17 <mm_freak> we would call it a "Maybe effect"
19:57:41 <mm_freak> it is not captured by the monadic interface other than that (>>=) deals with it
19:58:13 <yac> so it's a hack inside the implementation of >>= ?
19:58:19 <mm_freak> no
19:58:51 <mm_freak> the monadic interface understands Maybe's effects (the potential absence of a value) and deals with them, but doesn't allow you to /construct/ them
19:58:51 <fragamus> I thought Nothing would be unit
19:59:01 <mm_freak> you have Maybe-specific functions for that
19:59:16 <mm_freak> for example Nothing itself:  Nothing :: Maybe a
19:59:39 <yac> so it's basicly Maybe with a = undefined?
19:59:46 <mm_freak> no
19:59:51 <fragamus> got it, so Just as a wrapper doesn't really add anything
20:00:03 <mm_freak> yac: look at it this way:  you cannot construct a Nothing using purely the monadic interface
20:00:07 <yac> and some syntactic sugar around in the form of "Maybe effect" ?
20:00:11 <monochrom> Nothing cannot be a unit.
20:00:16 <mm_freak> you cannot construct a Nothing by using 'return' and (>>=)
20:00:26 <fragamus> got it
20:00:30 <mm_freak> but if you construct a Nothing by other means, then (>>=) will know how to deal with it
20:00:31 <yac> right, so Nothing is not a unit but it is a Maybe constructor
20:00:35 <fragamus> Just ()
20:00:46 <fragamus> that's a unit wrapping a unit
20:01:13 <fragamus> > Just ()
20:01:15 <lambdabot>  Just ()
20:01:18 <mm_freak> yac: say "the unit", not "a unit"
20:01:23 <mm_freak> yac: each monad has a unique unit
20:01:27 <yac> right
20:01:58 <yac> I'm thinking this is chicken and egg problem
20:02:11 <yac> to understand monads, you need to understand the notation/syntax
20:02:19 <yac> to understand notation you need to understand monads
20:02:26 <mm_freak> the former is true, the latter is not
20:02:41 <mm_freak> monads are not a language feature
20:02:48 <johnw> also, when people say "understand monads", they can mean many different things
20:03:02 <johnw> "know how to use effectively" is not very hard
20:03:14 <yac> is there a guide to the notation/syntax that deals with monads? I don't remember seeing such
20:03:37 <mm_freak> yac: any introduction to haskell basics should give you most of what you need
20:04:04 <mm_freak> yac: try to ignore the Monad type class…  it may be overcomplicating things for you right now
20:04:20 <yac> mm_freak: today I found I wrote https://github.com/yaccz/jsmin-hs/blob/master/jsmin.hs already 4 years ago but only now I think I'm starting to understand what monads are about
20:04:52 <mm_freak> yac: listUnit x = [x], and bind is predefined…  you know it as concatMap (which is bind with arguments reversed)
20:06:12 <mm_freak> similarly:  maybeUnit = Just;  maybeBind Nothing f = Nothing;  maybeBind (Just x) f = f x
20:06:14 <cwvh> once C++14/17 has its async monad, then new Haskell programmers will have an analogy to draw from and all will be well.. I think
20:07:04 <monochrom> you are saying, to understand "x+y", you must first learn ring theory.
20:07:04 <mm_freak> yac: as you see they are just utility functions…  but they have a similar interface and follow similar laws…  those happen to be exactly the laws of monads
20:07:15 <orion> Thay're already working on C++17!?
20:07:42 <monochrom> while math enthusiasists would like the world to work that way, it has been disproved empirically
20:07:43 <yac> I realize bind is defined "on" the monad, so it can deal with the Nothing
20:08:02 <mm_freak> yac: bind (along with unit) /defines/ the monad
20:08:06 <mm_freak> it's a defining feature
20:08:19 <johnw> orion: and C++22
20:08:21 <fragamus> C++17 is like C ++  ++  ++  ++  ++  ++  ++  ++  ++  ++  ++  ++  ++  ++  ++  ++  ++
20:08:32 <yac> yes, I knew it but did not realize when I thought about how >>= deals with the Nothing
20:08:38 <orion> When is Haskell going to be updated? Does it even need to be?
20:09:15 <yac> mm_freak: thanks, this been lot of help
20:09:19 <monochrom> I can describe Maybe's specific >>= to you, and I won't be telling you the general monad story.
20:09:26 <monochrom> I can describe []'s specific >>= to you, and I won't be telling you the general monad story.
20:09:45 <fragamus> inp
20:10:16 <monochrom> etc etc. If you want to hear the general story, I can tell it. but if you can't afford to hear the general story yet, I also know how to keep to concrete specific stories.
20:11:06 <monochrom> If you want to hear general ring theory, I can tell you. But if you just want to know "1+2" for the purpose of tax, I can do that too, and you won't need hear general ring theory.
20:11:08 <StoneCypher> cwvh: johnw: any news on c++ concepts being readmitted?  i've fallen out of touch with that language and it sounds like you two have not
20:11:23 <johnw> yeah, there's constantly news about that, at every standards meeting
20:11:28 <johnw> what will come of it, we've yet to see
20:11:35 <cwvh> StoneCypher: there's a reduced thing called "concepts lite" that, I think, are slated for C++17
20:11:37 <monochrom> You were effectively claiming that every accountant knew ring theory because they knew the "1+2" notation.
20:11:42 <StoneCypher> cwvh: aha
20:11:58 <yac> one of the monad constructors is the unit. [y/n] ?
20:12:10 <mm_freak> yac: /
20:12:34 <napping> "constructors" sounds like data constructor
20:12:35 <mm_freak> yac: you could call it "constructor", but there is some overlap in terminology, so you should probably call it "feature" instead
20:12:51 <fragamus> Can someone please add Linear to hoogle
20:13:02 <cwvh> yac: do you look at "Monad" and think of it as a Java interface class? Would it help if you did?
20:13:21 <yac> monochrom: everytime you go "up" two dimensions, you lose one operation. right? :)
20:13:38 <yac> cwvh: no
20:14:12 <monochrom> I don't know what you're talking about.
20:14:12 <yac> cwvh: don't you (haskellers) call things like Nothing and Just a a constructor?
20:14:21 <cwvh> I'm probably going to have objects thrown at me, but I think it's acceptable to start with the "monad is just an interface class" analogy for some people
20:14:36 <napping> sure, Nothing and Just are constructor
20:15:08 <napping> "return" is what is sometimes called the "unit" in math, but it doesn't have to be implemented as a constructor
20:15:31 <monochrom> IO has no constructor.
20:15:54 <yac> monochrom: neither do I realy. This from history of how people learned about properties of numbers in higher dimensions
20:16:04 <yac> napping: ah, that's interesting. Do you have an example?
20:16:09 <monochrom> but if you're pointing at all those other examples that have constructors, then you are only look at:
20:16:22 <yac> well, besides IO :)
20:16:27 <monochrom> "every monad instance written with constructors is written with constructors"
20:16:29 <gaze__x> Hey folks. Any GTKhs/hsCairo people here? I'm getting a problem with "user error (out of memory)" when calling showtext
20:16:34 <napping> well, the State monad could be just newtype State s a = State (s -> (a,s))
20:16:47 <napping> and it's instance says return x = State (\s -> (x,s))
20:16:47 <monochrom> I hate to break it to you, but STM has no constructor either.
20:16:58 <napping> monochrom: what do you mean "no constructor"?
20:17:01 <mm_freak> yac: what you call monad constructors do not always map to data constructors
20:17:16 <monochrom> data constructors are not available
20:17:25 <napping> I don't see how any sense in which that's true is useful
20:17:27 <monochrom> (->) has no constructor either
20:17:32 <napping> constructors are not exposed, sure
20:17:34 <mm_freak> yac: for example Reader has only one constructor, but neither 'unit' nor 'bind' do map to it
20:17:34 <yac> monochrom: I'm exploring boundaries of things that seem true to me right now
20:17:49 <mm_freak> yac: return x = Reader (const x)
20:17:53 <monochrom> no, it is not a useful thing to know. it's useful for refuting wrong intuitions.
20:18:00 <mm_freak> where newtype Reader e a = Reader (e -> a)
20:18:03 <napping> yac: even list doesn't have a constructor that corresponds exactly to Return
20:18:07 <napping> return x = (:) x []
20:18:14 * hackagebot vinyl-gl 0.1.3 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://hackage.haskell.org/package/vinyl-gl-0.1.3 (AnthonyCowley)
20:19:38 <akurilin> What does it mean when it says "Constructor 'Foo' does not have the required strict field(s): bar" ? I was under the assumption that you could partial record syntax. Is there a way to disable that functionality?
20:19:56 <akurilin> In my case this is a constructor generated through persistent's TH routines.
20:20:00 <napping> all that matters in general is having some correct definition of return and >>= on your type
20:20:16 <c_wraith> akurilin: you can't leave a field undefined if it's declared as a strict field
20:20:18 <mm_freak> akurilin: data X = X { x :: !Int, y :: Int }
20:20:35 <mm_freak> akurilin: X undefined _ ≃ undefined
20:20:41 <johnw> how come there is no Alternative for IO?
20:21:00 <monochrom> is there MonadPlus for IO
20:21:00 <mm_freak> akurilin: so if you leave a strict field undefined, the whole record is undefined…  hence the error
20:21:18 <mm_freak> (or warning?)
20:21:24 <akurilin> c_wraith, mm_freak ok makes sense, thanks for clarifying.
20:21:42 <mm_freak> johnw: what would 'empty' be?
20:22:04 <johnw> return mempty?
20:22:18 <mm_freak> johnw: that's a type error
20:22:32 <johnw> pure mempty?
20:22:38 <mm_freak> also a type error
20:22:43 <johnw> :t empty
20:22:45 <lambdabot> Alternative f => f a
20:22:49 <johnw> :t pure mempty
20:22:50 <lambdabot> (Monoid a, Applicative f) => f a
20:22:57 <johnw> i see
20:22:59 <mm_freak> notice that 'a' is fully polymorphic
20:23:02 <johnw> right
20:23:41 <napping> what would you want an Alternative to do?
20:23:46 <napping> fail over on exceptions?
20:23:49 <johnw> exactly
20:23:51 <johnw> the way STM does with retries
20:24:09 <monochrom> eh? "v = X undefined 'c'" is not a static error, but "v = X{y=0}" is
20:24:13 <mm_freak> then you would have to define an arbitrary "no specific error" exception
20:24:16 <napping> catching all exceptions is a bad idea
20:24:21 <napping> ThreadKilled?
20:24:22 <mm_freak> and make sure that it is properly handled by (<|>)
20:24:29 <monochrom> well I guess "undefined" is never a static error :)
20:25:05 <mm_freak> monochrom: since 'undefined' is a library definition… =)
20:25:54 <yac> monochrom: oh, it's actually doubling of dimensions
20:25:56 <yac> monochrom: http://books.google.cz/books?id=2QYSAAAAQBAJ&pg=PA113&lpg=PA113&dq=universe+in+zero+words+dimension+higher+lose+operation&source=bl&ots=l_xe68fB_K&sig=3bQ9COeboNHXfvG3usdKCzOoYZQ&hl=en&sa=X&ei=YzJXU92bBoaEO6v0gHA&ved=0CC0Q6AEwAA#v=onepage&q=universe%20in%20zero%20words%20dimension%20higher%20lose%20operation&f=false
20:27:20 <mm_freak> johnw: the trouble is in 'x <|> y' when both x and y throw exceptions…  you need to make sure that 'x <|> empty' is actually 'x', respecting the fact that 'x' might throw a different exception than 'empty'
20:27:55 <mm_freak> the straightforward definition would cause x <|> empty = empty, when x throws an exception
20:28:04 <johnw> ah, true
20:28:28 <mm_freak> it's possible, but rather ad hoc
20:28:37 <napping> that's not actually hard, I think it would just be a horrible idea to make catching SomeException a standard instance
20:29:07 <mm_freak> indeed
20:29:27 <mm_freak> that would cause all kinds of terrible behavior, especially with async exceptions
20:29:34 <napping> Actually an unexported exception type might not do it, if you could get your hands on it with try mempty and then rethrow it
20:29:46 <johnw> well, there's a way around the async exception problem
20:30:16 <johnw> using the same trick as http://hackage.haskell.org/package/enclosed-exceptions
20:30:22 <mm_freak> johnw: the terrible behavior remains…  consider this:  x <|> y, where x throws ThreadKilled
20:30:28 <mm_freak> the thread keeps running with y
20:30:34 <heatsink> The arbitrary instance for my recursive data structure tends to not terminate.  How can I ensure that it terminates?
20:30:45 <johnw> the ThreadKilled should be honored
20:30:49 <johnw> otherwise, "timeout" would be impossible
20:30:54 <johnw> which is partly why 'enclosed-exceptions' got created
20:31:25 <yac> is join an indentity functions?
20:31:39 <monochrom> what is an identity function?
20:32:01 <mm_freak> heatsink: make sure you use induction and coinduction…  in other words:  recursion should always either eat or create one layer of data constructors
20:32:05 <yac> when you give it identity elemnt it will give you the same thing
20:32:18 <napping> what identity element?
20:32:31 <mm_freak> johnw: that seems to make things even more ad hoc
20:33:07 <mm_freak> i think Alternative for IO would be a bad idea, because no matter what you do, you need to define some rather arbitrary ad hoc semantics
20:33:47 <monochrom> everyone can make IO MonadPlus and Alternative. everyone will define a different semantics for it.
20:33:57 <yac> erm. Identity map is a function that always returns the same value that was used as argument
20:34:03 <mm_freak> yac: it's "the identity function", not "an identity function"
20:34:04 <dashster18> Hmm, looks like I don't have the background for the category theory video
20:34:11 <dashster18> I don't know enough of the Algebra.
20:34:13 <napping> well, then join has the wrong type for that
20:34:26 <monochrom> if you're asking "true or false: for all x, join x = x", the answer is mostly no.
20:34:57 <monochrom> I think you need to sleep.
20:35:20 <yac> well, is it true that "monad is a monoid in category of endofunctors" or is it just something funny?
20:35:29 <mm_freak> yac: both
20:35:29 <johnw> it's very true
20:35:34 <johnw> and quite funny :)
20:35:43 <yac> When I look at monoids and endofunctors it looks possible
20:35:47 <mm_freak> sorry
20:35:48 <mm_freak> yac: yes
20:35:49 <mm_freak> =)
20:35:52 <monochrom> that still doesn't give you "join x = x"
20:36:36 <akurilin> There's no easy way of manually generating a FooId in persistent (Foo being one of the TH-generated types), is there? As in, I just want to manually pass in a FooId as FK of Bar
20:36:57 <akurilin> the kosher way according to the docs is to always fetch from DB first and use those Id values
20:37:07 <akurilin> but I'm just testing in the repl here.
20:37:18 <yac> is the (a -> b) in map a functor?
20:37:27 <heatsink> mm_freak: 'arbitrary' isn't inductive or coinductive.  It generates a new value using RNG input.
20:38:26 <heatsink> Generating a T constructor that contains more Ts involves recursion, possibly growing without bound
20:40:21 <yac> oh well, endofunctor is an identity function, right?
20:41:44 <napping> yac: what all are you trying to figure out here? I missed the original question
20:41:52 <mm_freak> heatsink: you might be interested in smallcheck
20:42:10 <shouya> hi, folks.
20:42:33 <napping> If you're after a pretty general understanding of monads as used in Haskell, I can recommend a good paper
20:42:51 <shouya> i have a small question about idiomatic combination of monads.
20:42:55 <mm_freak> yac: you seem to suffer from a huge confusion of terminology…  i recommend giving it a break and trying again later
20:43:22 <shouya> is there a simpler way to do this? check on: https://gist.github.com/shouya/9969363#file-bfsolver-hs-L59-L62
20:43:26 <johnw> mm_freak: https://gist.github.com/11202118
20:43:29 <yac> yeah, probably. mm_freak can you recommend a book on category theory for complete newb?
20:43:50 <yac> or journal or paper or w/e
20:44:03 <napping> you want to learn category theory too?
20:44:07 <mm_freak> yac: let all the new information sink in and give your subconcious some time to process it…  it will help…  my recommendation is not to learn category theory, but write some actual code
20:44:17 <shouya> yup i'm also looking for that. category theory tutorial.
20:44:37 <napping> There's quite a lot of stuff there, most of which has very little to do with programming
20:44:46 <monochrom> great, an accounting student now wants to learn universal algebra...
20:44:56 <napping> I think classical examples of monads there come from fibrations over topological spaces or something
20:45:04 <yac> wow, google for "category theory for dummies", it exists
20:45:15 <heatsink> It says smallcheck exahustively tests values smaller than a bound
20:45:31 <carter> heatsink: yah
20:45:34 <carter> you pick the bound
20:45:49 <napping> anyway, Wadlers "The essence of functional programming": http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps.gz gives a nice explanation and covers most everyday kinds of monads
20:45:49 <mm_freak> heatsink: more interestingly smallcheck is not probabilistic, but understands the /structure/ of the problem to some extent
20:46:26 <shouya> yac: thanks.
20:46:31 <napping> shouya: that highlighet bit seems reasonable enough
20:46:33 <mm_freak> in particular it allows you to generate candidates inductively or coinductively
20:46:43 <johnw> mm_freak: that gist shows the IO Alternative semantics I would like
20:46:50 <shouya> napping: i am wondering if there's some way like:
20:46:56 <yac> shouya: I have no idea what it is, just found it myself
20:47:00 <mm_freak> johnw: you can have those semantics without Alternative
20:47:01 <shouya> parseBF input >>= xxx?
20:47:16 <johnw> mm_freak: you mean, just define some other operator?
20:47:20 <mm_freak> johnw: yeah
20:47:31 <mm_freak> johnw: this is one of the cases where it's really useful to remind yourself that instances are global
20:47:34 <johnw> well, but I like being able to have these semantics with all the other functions that can play with Alternatives
20:47:37 <shouya> yac: i'd read it later.
20:48:32 <johnw> I may just propose this as an Alternative for Shelly, since right now >> has the same meaning as && in the shell, but we have no equivalent for ||
20:48:36 <napping> you could try some things like that, but that code looks like it finishes doing stuff in the parser, then goes on to do just some IO stuff
20:49:00 <mm_freak> johnw: you would be forcing your Alternative on anyone who uses shelly…  remember that it's a library and instances are always exported
20:49:15 <johnw> I wouldn't define Alternative IO there
20:49:18 <johnw> but rather Alternative Sh
20:49:31 <mm_freak> that's different
20:49:44 <johnw> right, I realize adding an instance to IO is probably verboten by now
20:49:47 <heatsink> I think I need to read the smallcheck paper first.
20:50:18 <napping> shouya: it looks at least as clear as either runBF (const (return ()) (parseBF input)
20:50:20 <shouya> napping: for example, like this: http://lpaste.net/103107#line14
20:50:31 <napping> and messing around with ErrorT would probably be worse
20:51:32 <shouya> napping: hmm.
20:51:38 <napping> I think it would be something like runErrorT $ ErrorT (return (parseBF input)) >>= liftIO . runBF
20:51:43 <napping> but the case you have is way clearer
20:51:43 <mm_freak> johnw: even then you may want to consider making exceptions explicit effects of your Sh monad rather than implicit in IO
20:51:59 <mm_freak> johnw: it seems somewhat unclean to define Alternative in terms of IO exceptions, even for a custom monad
20:52:01 <napping> In this case, I think it's best to just consider the Either plain data you should inspect
20:52:17 <johnw> mm_freak: how do you mean, exactly?
20:52:36 <mm_freak> johnw: well, you would inherit all the terrible async behavior, unless you work around it
20:52:38 <napping> If you're doing a sequence of things which each might fail in Either, then using a monad for it might pay off
20:53:00 <stolaruk> When I catch an IO-related exception and I want to know what kind of exception it is, do I need to use the methods like "isDoesNotExistError" which take an "IOError" type? Or is there something I can do with a "IOException" type?
20:53:20 <shouya> napping: (nodding)
20:53:46 <napping> shouya: also, I expect you'd want to do something in the error case two if the program gets even a little fancier, like at least printing the parse error
20:53:49 <codygman> Why do I always get "Nothing" for the date? "clicks" are appending correctly and min works with Just UTCTime as... hmm maybe that is it
20:54:09 <shouya> napping: yup it's in the plan.
20:54:10 <johnw> stolaruk: you just case analyze your exception as if it were a certain type, and then your catch handler will only fire if it is of that typ
20:54:35 <mm_freak> stolaruk: you would use is* functions, perhaps together with catchJust
20:55:12 <napping> stolaruk: System.IO.Error says it's an opaque type
20:55:19 <mm_freak> stolaruk: or rather most likely with catchJust
20:55:29 <bmelcher84> hola
20:55:43 <stolaruk> hmm ok
20:55:50 <shouya> napping: btw could you explain to me why doesn't the code "return (parseBF input >>= return . runBF)"  work?
20:55:51 <mm_freak> when you use isDoesNotExistError inside a 'catch' handler it's already too late, because the exception is already caught, even if it's not a does-not-exist error
20:55:55 <napping> stolaruk: though there is an ErrorType key that might be a touch more convenient, depending exactly what you want to do
20:55:58 <johnw> mm_freak: you know, except for the "<|> empty" case, I can get the behavior I want from `onException` I think
20:56:09 <napping> stolaruk: what do you mean "work"?
20:56:10 <shouya> napping: as in here http://lpaste.net/103107#line14
20:56:41 <napping> It gets a type something like (Monad m) => m (Either (IO ()) ParseError)
20:56:46 <napping> if you consider that working
20:56:47 <mm_freak> johnw: one thing i often do is to use a monad-specific exception constructor with a polymorphic exception type
20:56:58 <mm_freak> johnw: then:  instance (Monoid e) => Alternative (MyMonad e)
20:56:59 <napping> parseBF input >>= is in the Either monad
20:57:00 <johnw> can you show me an example?
20:57:11 <mm_freak> johnw: netwire is an example of that
20:57:15 <johnw> cool, thanks
20:57:18 <napping> so return . runBF will end up like Right (runBF <parse result>)
20:57:27 <napping> rather than actually running that IO action
20:57:42 <mm_freak> johnw: you can find another example in the 'continue' library
20:57:45 <mm_freak> @hackage continue
20:57:45 <lambdabot> http://hackage.haskell.org/package/continue
20:57:52 <mm_freak> it's maybe easier to digest
20:57:53 <shouya> napping: so is it delayed to execute?
20:58:07 <napping> well, it doesn't do at all the same thing as your original code
20:58:20 <mm_freak> johnw: the idea is as simple as this:  Failed e1 <|> Failed e2 = Failed (e1 <> e2)
20:58:21 <bmelcher84> what chall talkin about?
20:58:24 <napping> it wouldn't execute until you got it out and actually ran it in IO
20:58:42 <shouya> napping: oh, i see.
20:58:46 <napping> ErrorT e m a = ErrorT (m (Either e a))
20:59:10 <shouya> napping: "ErrorT e m a = ErrorT (m (Either e a))" this seems to be good.
20:59:20 <johnw> ah, I remember reading about continue, nifty library
20:59:36 <napping> that's the monad transfomer for running a bunch of things in a monad m that all return an Either, and then stopping early whenever one returns a Left
20:59:56 <mm_freak> =)
21:00:09 <shouya> napping: hmm, yup.
21:00:11 <napping> so yeah, that's one thing to consider if you get into a case where using a monad for the error handling makes sense
21:00:23 <napping> That "Error e" constraint is a little annoying
21:00:37 <shouya> napping: i just thought that XD
21:00:48 <napping> You can define it yourself, it's just a bit silly
21:00:49 <mm_freak> johnw: i found that whenever you have trouble deciding between two values, simply require it to be a monoid =)
21:01:10 <carter> o// johnw
21:01:10 <johnw> haha, sounds good!
21:01:14 <mm_freak> or sometimes a semigroup
21:01:22 <johnw> hiya carter!
21:01:39 <napping> Is a comonad good for tagging parsed stuff with source locations for nice error reporting?
21:01:40 <shouya> napping: sounds okay, i don't want to define it, at least in this small project.
21:01:51 <mm_freak> here is a really interesting example of that:  newtype Collection a = Collection { applyCollection :: forall r. (Semigroup r) => (a -> r) -> r }
21:01:52 <shouya> napping: thank you. lunch time. bbl.
21:02:05 <napping> If you've only got a single choice like this, not worth lifting in and out anyway
21:02:05 <fragamus> hey guys is there a function that takes a (a->b) and makes a pipe out of it
21:02:11 <mm_freak> napping: comonads don't take, they give
21:02:22 <fragamus> ala Pipes library
21:02:26 <johnw> napping: I think what you mean to ask is where a Comonad is a good interface for interacting with tagged parsed stuff?  The Comonad itself isn't going to provide you with a data structure
21:02:39 <mm_freak> fragamus: see 'map' in Pipes.Prelude
21:02:55 <napping> Right, I was thinking of something like make a "Located a" which is an environment comonad carrying a source location or set of source locations or something
21:03:02 <fragamus> I love it
21:03:13 <mm_freak> napping: alternatively a writer monad =)
21:03:23 <napping> how does that help?
21:03:38 <mm_freak> napping: it doesn't…  it's both
21:03:57 <mm_freak> you can define a comonad instance for it, but it's one of the less useful comonads
21:04:09 <napping> Hmm, I suppose it is
21:04:21 <mm_freak> in fact i found that mostly the only useful comonads look a lot like stores or bazaars
21:04:49 <napping> store s a is s * (s -> a)?
21:04:56 <mm_freak> yeah
21:05:19 <napping> I'm not really looking for it to be too useful
21:05:20 <johnw> store looks a heck of a lot like coyoneda
21:05:46 <mm_freak> blur :: Picture RGB -> RGB
21:05:52 <mm_freak> extend blur :: Picture RGB -> Picture RGB
21:06:35 <mm_freak> type Picture a = Store (V2 Int) a
21:11:43 <codygman> Why do I always get "Nothing" for the date? "clicks" are appending
21:11:43 <codygman>     correctly and min works with Just UTCTime: http://lpaste.net/103108 What am I overlooking?
21:12:55 <Javran> @hoogle either
21:12:56 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
21:12:56 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
21:12:56 <lambdabot> package either
21:13:20 * hackagebot schedevr 0.1.0.0 - Marge schedules and show EVR  http://hackage.haskell.org/package/schedevr-0.1.0.0 (YoshikuniJujo)
21:13:26 <Javran> shouya: `either` might do the trick IMHO
21:15:52 <Adeon> can I somehow tell cabal to (install in|use) a sandbox when my current directory is not in the sandbox
21:15:59 <Javran> shouya: something like `parseRunBF = either (const (return ())) runBF . parseBF`
21:16:21 <Javran> @hoogle void
21:16:22 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
21:16:22 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
21:16:22 <lambdabot> package void
21:16:39 <Adeon> oh right, it's a command line option
21:16:41 <Adeon> nevermind me
21:17:38 <monochrom> codygman: mconcat = foldr mappend mempty. mconcat [x,y] = (...) `mappend` mempty
21:18:21 * hackagebot schedevr 0.1.0.1 - Marge schedules and show EVR  http://hackage.haskell.org/package/schedevr-0.1.0.1 (YoshikuniJujo)
21:18:45 <monochrom> err, x `mappend` (y `mappend mempty). but same principle.
21:18:59 <Javran> shouya: `parseRunBF = either (void . print) runBF . parseBF` if you want to print out the error.
21:19:58 <Javran> ops void . print === print
21:29:39 <fragamus> having some trouble converting a function from lazy lists to pipe
21:29:54 <fragamus> foo = xs >>= xss
21:31:38 <fragamus> foo = xs >>= xBecomesXs
21:31:42 <fragamus> that^^^
21:32:16 <fragamus> I tried P.concat
21:32:33 <AfC> Having a hard time running tests. Seems like it worked in Cabal 1.18 but not now in Cabal 1.20. The error we get is
21:32:48 <fragamus> but flattens structure beyond the shallow level
21:32:48 <AfC> trying: projectname-2.0.0 (user goal)
21:32:48 <AfC> rejecting: projectname-2.0.0:!test (global constraint requires opposite flag selection)
21:32:52 <AfC> anyone know what to make of that?
21:33:16 <AfC> when we try to `cabal configure --enable-tests`
22:11:35 <johnw> i've not seen that before
22:27:37 <killy9999> I upgraded to latest cabal and my testsuite freezes when I run it with 'cabal test'
22:28:01 <killy9999> but it runs perfectly fine when run with 'cabal test --show-details=streaming'
22:28:12 <killy9999> anyone else experiencing the same issue?
22:31:13 <fragamus> having some trouble converting a function from lazy lists to pipe
22:31:25 <fragamus> foo = xs >>= xBecomesXs
22:35:50 <btubbs> i just did a 'cabal install cabal-install' so I could get the latest version.  It successfully installed to /Users/brent.tubbs/Library/Haskell/ghc-7.6.3/lib/cabal-install-1.20.0.0/bin, but there's still a 1.16.0.2 versionon my PATH, at /Users/brent.tubbs/Library/Haskell/bin/cabal.  What's the recommended way to get rid of the old version?
22:37:04 <carter> fix your path to have the cabal stuf in front
22:37:08 <carter> ummm
22:37:11 <carter> yeah
22:37:13 <carter> that
22:37:47 <johnchen902> @help
22:37:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:38:21 <johnchen902> @pl (\a b -> (!! ((liftA2 (-) head (!!1).map read.words) a)) ((sort.map read.words) b))
22:38:21 <lambdabot> (. (sort . map read . words)) . flip (!!) . liftA2 (-) head (!! 1) . map read . words
22:38:26 <carter> btubbs: actually
22:38:31 * hackagebot schedevr 0.1.0.2 - Marge schedules and show EVR  http://hackage.haskell.org/package/schedevr-0.1.0.2 (YoshikuniJujo)
22:39:10 <carter> btubbs: do the following "rm ~/.cabal/config ; cabal update ; cabal install cabal-install ; " then add ~/.cabal/bin to your path
22:39:18 <carter> (your haskel platform config file is wrong)
22:39:19 <carter> :)
22:39:33 <carter> and doesnt have the full magic / power of 1.18 / 1.20
22:40:02 * btubbs debates whether to save a copy of .cabal/config or throw caution to the wind
22:40:08 <carter> cure
22:40:09 <carter> *sure
22:40:22 <carter> cp ~/.cabal/config ~/.cabal/old-stale-config
22:40:28 <carter> you'll never go back :)
22:40:38 <orion> How much better is it?
22:40:47 <carter> 7.8 doesnt cry and error out
22:40:55 <carter> you get parallel package builds
22:41:06 <carter> and you can tell haddock to hyper linke sources
22:41:16 <carter> basically life gets better and you have more friends
22:41:24 <carter> and spend less time getting help on irc
22:41:25 <carter> :)
22:42:13 <cwvh> fragamus: do you want to `yield' values from your function `foo'?
22:42:22 <carter> orion: so much better :)
22:42:25 <fragamus> yes
22:43:35 <btubbs> parallel package builds sound pretty nice
22:44:15 <cwvh> I'm confused where bind is coming from... couldn't you do something like:     foo xs = for (each xs)    ;     runEffect $ foo [1..4] (lift . print)
22:44:24 <johnw> carter: hasn't haddock been able to hyperlink sources for a long time?
22:44:36 <carter> johnw: yes, but cabal install didn't pass the right flags
22:44:39 <btubbs> carter: your advice implies that updating cabal would have left something in ~/.cabal/bin, but I'm not seeing anything there
22:44:54 <johnw> carter: so what will I notice as being different?
22:44:56 <carter> btubbs: do another cabal install
22:44:59 <johnw> I have "Source" links in all modules
22:44:59 <carter> johnw: hyper links!
22:45:14 <btubbs> i've done two now.  a third one?
22:45:25 <carter> http://blog.johantibell.com/2014/04/announcing-cabal-120.html
22:45:30 * kfish sends carter a coffee
22:45:36 <carter> kfish:? :)
22:45:42 <carter> btubbs: where is you cabal
22:45:49 <carter> btubbs: ls ~/.cabal/bin
22:45:50 <kfish> carter, you seem very awake!
22:45:55 <carter> kfish: yeah
22:46:00 <carter> ish
22:47:29 <btubbs> there's no 'bin' in there, http://lpaste.net/103111, but I'm now doing a 'cabal install cabal-install' and forcing it to be done by the 1.20 version instead of the 1.16
22:47:31 <carter> johnw: point being, you'll have the nice source hyper links like hackage does
22:47:40 <johnw> but I have those
22:47:41 <carter> btubbs: did you RM the config file
22:47:43 <carter> and do the update?
22:47:48 <btubbs> yes and  yes
22:47:54 <carter> btubbs: and you're on a mac right?
22:48:07 <btubbs> and it left me with two cabals in two places, as i had in the original question
22:48:09 <carter> btubbs: show me your current config file
22:48:25 <btubbs> there's also a config.platform in ~/.cabal
22:48:28 <carter> ohhh
22:48:32 <btubbs> should wipe that too?
22:48:37 <carter> btubbs: i know what happeend
22:49:08 <carter> rm ~/.cabal/config ; /Users/brent.tubbs/Library/Haskell/ghc-7.6.3/lib/cabal-install-1.20.0.0/bin update ; /Users/brent.tubbs/Library/Haskell/ghc-7.6.3/lib/cabal-install-1.20.0.0/bin install  cabal-install
22:49:30 <carter> after that, put ~/.cabal/bin in the FRONT of your path
22:49:36 * btubbs tries that
22:57:02 <cjenkin1> I seem to have a search conflict: Prelude is visible from both the base package and haskell98-2.0.0.2, not sure how to solve this
22:57:55 <johnw> "ghc-pkg hide haskell98"?
22:59:02 <cjenkin1> johnw, can this be done from with Emacs?
22:59:13 <cjenkin1> *from within
22:59:16 <johnw> M-! ?
23:00:06 <cjenkin1> Thanks. I'm both new to Haskell and emacs...
23:03:56 <cwvh> fragamus: did you figure out your pipes problem? Here's an example of 'pipifying' a pure function of a list type: http://lpaste.net/2389802086477856768
23:04:41 <btubbs> carter: worked!  thank you
23:04:58 <carter> btubbs: notice how i didn't need to know ANYTHING about your machine for the directions to work?
23:05:08 <carter> i try very hard to give obliviously correct directions
23:05:23 <carter> note that your docs will now be in ~/.cabal/share
23:05:27 <carter> when you build them
23:05:37 <carter> are you using gcc or clang?
23:06:29 <carter> ghc --info is how
23:07:13 <carter> i'm crashing
23:07:16 <carter> happy hacking all
23:07:17 <AfC> johnw: found out what the problem was
23:07:52 <carter> AfC: i think that cabal should also do spell check
23:07:53 <AfC> for everyone's benefit: if you see
23:08:27 <AfC> $ cabal bench
23:08:27 <AfC> rejecting: vaultaire-2.0.0:!bench (global constraint requires opposite flag selection)
23:08:34 * hackagebot antigate 2.0.1 - Interface for antigate.com captcha recognition API  http://hackage.haskell.org/package/antigate-2.0.1 (MikhailKuddah)
23:08:35 <AfC> and a whole bunch more lines of goop
23:08:49 <carter> AfC: you needed to clean and configure for tests right?
23:08:54 <AfC> it is because `cabal configure --enable-tests` is failing
23:09:18 <carter> you mean cabal test in a sandbox doesn't imply cabal install --only-dep --enable-test ?
23:09:19 <carter> jah
23:09:20 <AfC> carter: [no, that didn't fix it. Went all the way to full blow-away and still not. Thought it might have been sandboxes. Wasn't]
23:09:29 <AfC> carter: right. You HAVE TO
23:09:31 <AfC> do
23:09:32 <carter> yup
23:09:41 <carter> thts gonna get fixed in 1.22 i think
23:09:44 <AfC> `cabal install --only-dependencies --enable-tests --enable-benchmarks`
23:09:48 <carter> jah
23:09:52 <AfC> THEN you can do `cabal test`
23:09:53 <AfC> or whatever
23:09:55 <carter> jup
23:10:02 <carter> my shell auto completes to that now :)
23:10:10 <AfC> it turns out the next lines were the issue,
23:10:12 <AfC> next goal: criterion (dependency of vaultaire-2.0.0:*bench)
23:10:12 <AfC> fail (unknown package: criterion)
23:10:18 <AfC> ie, dependencies were missing.
23:10:38 <AfC> in this case our friend Criterion
23:10:43 <carter> ja
23:10:45 <AfC> anyway
23:10:48 <carter> AfC: you could have pinged me :)
23:10:58 <AfC> carter: I saw your name on the bug we just commented on
23:11:02 <carter> yup
23:11:11 <carter> i've hit most known bugs
23:11:15 <carter> and some unknown ones
23:11:16 <carter> :)
23:11:19 <AfC> heh
23:11:35 <carter> some are unknown because no one does the crazy shit i do
23:11:47 <carter> some are unknown because testing betas :)
23:13:30 <carter> and some are unknown because i make mistakes when tired :)
23:13:30 <carter> ok
23:13:32 <carter> i'm crashing
23:13:34 <carter> happy hacking!
23:33:37 * hackagebot soap 0.2.2.2 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.2.2 (AlexanderBondarenko)
