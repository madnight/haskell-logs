00:00:06 <augur> so:   (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
00:00:27 <Iceland_jack> well explained augur
00:01:14 <augur> aviraldg: this is not to say that a -> a _is_ a Num -- it probably cant be made to be one -- but thats the requirement. some requirements cant be met
00:01:52 <urbanslug> ddere: A better question would be can I get runhaskell to run the file?
00:02:03 <augur> aviraldg: i hope that helps. im off to bed :P
00:02:15 <aviraldg> So Num (a -> a) is the type deduced by Haskell's type system (from the way it's used in the expression) but not necessarily something that can actually exist?
00:02:39 <Iceland_jack> aviraldg: You _can_ define functions to be numbers, but they aren't by default
00:03:06 <Iceland_jack> http://www.haskell.org/haskellwiki/Num_instance_for_functions http://hackage.haskell.org/package/NumInstances
00:04:30 <Iceland_jack> so it allows you to write
00:04:30 <Iceland_jack>     (succ + succ) 10
00:04:30 <Iceland_jack> to mean
00:04:30 <Iceland_jack>       succ 10 + succ 10
00:04:33 <Iceland_jack>     = 11 + 11 = 22
00:04:34 <aviraldg> Still, not numbers ;) Just like them
00:04:42 <Iceland_jack> with instance Num b => Num (a->b)
00:04:49 <Iceland_jack> aviraldg: What are numbers?
00:04:56 <ddere> urbanslug: i dont know about using runhaskell. however i think the more standard step in the yesod workflow to do what you are thyinking is to run `yesod devel`
00:05:18 <ddere> urbanslug: that will build the source and start running the development server so that you can test it out
00:05:50 <urbanslug> ddere: Ok
00:06:22 <aviraldg> According to GHC, Integer, Int, Float and Double. In this case, anything that implements all the functions of the Num typeclass.
00:06:42 <urbanslug> ddere: What did cabal build do when I ran it? I ran it when you said "< ddere> urbanslug: it runs ghci with some extra flags, `cabal build` would do what runhaskell was doing before i suppose"
00:07:10 <Iceland_jack> I was speaking a bit more philosophically :) but functions are certainly numbers if that's the only requirement
00:07:23 <Iceland_jack> with op = liftA{,2} op
00:07:34 <ddere> urbanslug: ah that built your web app executable, `yesod devel` will run `cabal build` and then run the resultant binary
00:07:52 <edwardk> @remember pdxleif see s.p. jones & h.p. lovecraft's paper on the subject: "generic programming with lenses, barbed wire, and the fibres of sanity"
00:07:53 <lambdabot> Good to know.
00:09:12 <Iceland_jack> edwardk: Is the paper out?
00:09:23 <urbanslug> ddere: Yeah I thought so but I didn't see an executable.
00:09:23 <Iceland_jack> sounds interesting
00:09:54 <ddere> urbanslug: the executable goes into `./dist/build/<executablename>/bin`
00:10:09 <ddere> urbanslug: or something along those lines anyway
00:12:05 <urbanslug> ddere: Found it thanks.
00:12:20 <urbanslug> ddere: You've been more than patient with me.
00:12:24 <urbanslug> ddere: Thank you.
00:12:26 <ddere> urbanslug: :)
00:12:59 <ddere> urbanslug: no worries, learning yesod can really be like banging your head against a wall, happy to answer any questions to speed it up, its really worth learning
00:13:40 <ddere> urbanslug: if the book/docs/tutorials leave you confused ask questions to actual people, *do not* start looking through the code to figure it out
00:13:43 <aviraldg> I think I finally got it. Thanks a lot Iceland_jack and augur!
00:14:05 <Iceland_jack> aviraldg: You're welcome :) if you're ever confused, just unfold the definitions!
00:14:39 <ddere> urbanslug: the guy who wrote it does some really awesome stuff with haskell, but reading through his code as a beginner really is a rabbit hole
00:14:51 <ezyang> Aw, GHC doesn't support impredicative types in GADTs
00:15:08 <ezyang> So no Constr :: TyCon (forall a. a -> a)
00:15:18 <urbanslug> ddere: Really ask people instead of looking at the code?
00:15:32 * hackagebot uhc-util 0.1.3.2 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.3.2 (AtzeDijkstra)
00:16:03 <urbanslug> ddere: My first days on IRC I got so many RTFM replies I try to ask people when I have given up solving it myself.
00:16:27 <Iceland_jack> urbanslug: ##c is the worst in that regard :)
00:16:58 <ddere> urbanslug: well looking through the code is a good exercise, theres some amazing stuff in there really, but its an exercise in itself, you dont want to be doing it as a "subgoal" to learning yesod
00:17:23 <ddere> urbanslug: I'd be happy to answer any questions you might have, i remember how hard was for me to pick up
00:17:35 <urbanslug> I was thinking of learning yesod in a VM to avoid the cabal related pitfalls but I figured it will make me lose my 1337 archlinux user reputation.
00:17:48 <ddere> haha
00:18:04 <urbanslug> Iceland_jack: Are you from Iceland?
00:18:08 <Iceland_jack> I am
00:18:22 <urbanslug> Iceland_jack: I would never have guessed.
00:18:31 <Iceland_jack> Guess what my name is?
00:18:34 <MP2E> ahahah
00:18:39 <urbanslug> Iceland_jack: Jack
00:18:41 <urbanslug> haha
00:18:42 <Iceland_jack> Names can be deceiving
00:18:59 <Iceland_jack> Case in point, you asked for confirmation :)
00:19:03 <urbanslug> ddere: Uh so I shouldn't read the code that's in the book?
00:19:10 <Iceland_jack> (my name isn't Jack)
00:19:11 <urbanslug> ddere: How will I learn it?
00:19:30 <urbanslug> Iceland_jack: Don't tell us your name on IRC
00:19:39 <ddere> urbanslug: oh no no, the code in the book is fine, i mean the actual source code for the yesod library
00:19:42 <MP2E> yeah the NSA might be watching
00:19:43 <MP2E> oh noes
00:19:44 <MP2E> :P
00:19:52 <Iceland_jack> urbanslug: I have no issue with people knowing my name, but I only told you waht it's not
00:19:53 <urbanslug> Iceland_jack: The FBI is always lurking in IRC channels.
00:20:00 <Iceland_jack> *what
00:20:03 <urbanslug> MP2E: Yeah plus that
00:20:14 <urbanslug> ddere: Oh I see what you mean.
00:20:51 <urbanslug> Iceland_jack: The number of names is an uncountable infinity.
00:21:03 <urbanslug> So you didn't help :(
00:21:33 <urbanslug> One can have their name being made of just a repeated infinitely. That way we don't start on 'ab'
00:21:40 <urbanslug> So names are infinite
00:21:53 <urbanslug> uncountable infinity lol
00:22:00 <urbanslug> I watch numberphile
00:23:54 <ezyang> The set of finite strings is countably infinite.
00:29:09 <pordan30> Is there something like this <http://lpaste.net/102762> floating around the standard library (or standardized libraries)?
00:31:14 <urbanslug> ezyang: but there is an infinite set of inifinite strings.
00:33:54 <ezyang> Well, you have to define what you mean by "infinite string", but yes, generally speaking this is true
00:50:14 <PudgePacket> I keep trying "cabal update" "cabal install cabal-install" but cabal version doesn't change. On windows, any ideas?
00:52:31 <PudgePacket> Wait I think that's the latest version, never mind... :)
00:53:13 <cwvh> PudgePacket: should be 1.18 ish
00:53:28 <PudgePacket> Yea, that's what i'm on, thanks !
00:53:42 <PudgePacket> When i typed cabal update it kept telling me to cabal install the latest
00:53:43 <PudgePacket> misleading
00:54:31 <cwvh> PudgePacket: do you have the user-specific cabal directory in your path? On unix-like systems this would be $HOME/.cabal/bin. That is where 'cabal install cabal-install' would put the new cabal binary.
00:55:26 <PudgePacket> Yup, it's set up properly, I googled around and it does look like i'm on the latest version
01:10:40 * hackagebot plugins-multistage 0.4.0.1 - Dynamic linking for embedded DSLs with staged compilation  http://hackage.haskell.org/package/plugins-multistage-0.4.0.1 (AndersPersson)
01:17:30 <tomboy65> is it possible to make a function that takes 2 different inputs?
01:17:32 <Wizek> Good morning still!
01:17:36 <Wizek> http://stackoverflow.com/questions/23103654/how-can-a-function-be-transparently-augmented-in-haskell
01:17:55 <tomboy65> e.g. a function frst that takes (a,b,c) as well as (a,b,c,d)?
01:18:11 <tomboy65> i tried defining two functions with the same name, but ghc bugs out then
01:18:37 <bezirg> can I ask a cloud haskell-related question?
01:19:46 <yezariaely> how can I serialize a basic data type using cereal? I don't think I have to manually map it to integer values or something. e.g. http://pastebin.com/69DEBHze
01:23:26 <quicksilver> yezariaely: https://hackage.haskell.org/package/cereal-derive
01:24:34 <insitu> tomboy65 it is possible but using type classes
01:25:35 <Wizek> Updated http://stackoverflow.com/questions/23103654/how-can-a-function-be-transparently-augmented-in-haskell with a working example from another language.
01:27:59 <joneshf-laptop> tomboy65, alternatively, using data types
01:28:50 <joneshf-laptop> or to be pretty gross you could muck around with ()
01:29:26 <jle`> tomboy65: since haskell doens't have tdnr, you can't meaningfully have two functions with the same name.  either the call is ambiguous, or one shadows the other
01:29:33 <jle`> tomboy65: the typical solution would be to have a sum type
01:30:03 <jle`> data FuncArg a b c d = This (a,b,c) | That (a,b,c,d)
01:30:13 <jle`> myFunc :: FuncArg a b c d -> something
01:30:38 <jle`> and then pattern match
01:30:47 <jle`> myFunc (This a b c) = ...
01:30:52 <jle`> myFunc (That a b c d) = ...
01:31:24 <jle`> you can also have a function take an "optional" fourth parameter
01:31:33 <jle`> myFunc :: a -> b -> c -> Maybe d -> ...
01:31:37 <merijn> jle`: That pattern match doesn't match your definition, though :p
01:31:44 <jle`> merijn: yeah i was hoping nobody noticed ^.^
01:32:09 <jle`> but the sanest solution would be to have two different functions with two different names
01:32:19 <jle`> because that's actually what you really have
01:32:32 <jle`> however way you write it, it's going to be two different functions either way
01:32:37 <joneshf-laptop> i think that depends on what the function is doing
01:33:13 <jle`> hm yeah, i was probably being a bit overeager
01:33:28 <jle`> the most hacky way would be using typeclasses.
01:33:37 <jle`> this is generally not recommended
01:33:44 <joneshf-laptop> if it's `project_a :: FuncArg a b c d -> a` then you'd likely want it to be general enough to work
01:34:08 <jle`> yeah, it does depend on what the actual function is doing
01:34:11 <jle`> :/
01:34:23 <joneshf-laptop> i wish that were a thing though
01:34:35 <jle`> what were a thing?
01:34:37 <joneshf-laptop> i was reading a paper on generalized pattern matching earlier tonight
01:34:46 <joneshf-laptop> first class patterns
01:34:53 <jle`> sometimes i close my eyes and imagine a world with tdnr as well
01:35:00 <joneshf-laptop> tdnr?
01:35:12 <jle`> type directed name resolution
01:35:26 <jle`> where you can have multiple functions foo with different type signatures
01:35:32 <jle`> and ghc will infer only the one which matches the desired type
01:35:56 <jle`> so i don't have to do M.fromList, IM.fromList, S.fromList
01:36:34 <joneshf-laptop> ah
01:36:43 <Wizek> jle`: +1, please make it happen. :D
01:36:48 <joneshf-laptop> well
01:36:52 <jle`> it works in idris because all type signatures must be explicit
01:36:54 <joneshf-laptop> can't you do that with lense?
01:37:11 <jle`> as in, define multiple functions foo in the same module?
01:37:24 <joneshf-laptop> and if not, can't you get pretty close with row polymorphism?
01:37:27 <joneshf-laptop> ala purescript
01:38:47 <jle`> can you do that in haskell?
01:41:11 <Flonk> > concatMap (replicate 3) [1,2,3]
01:41:13 <lambdabot>  [1,1,1,2,2,2,3,3,3]
01:41:15 <Flonk> > let mconcatAp = (mconcat.).ap in mconcatAp [replicate 3] [1,2,3]
01:41:17 <lambdabot>  [1,1,1,2,2,2,3,3,3]
01:41:34 <Flonk> concatMap is way too mainstream, the future is all about mconcatAp
01:41:52 <jle`> what about just >>=
01:42:06 <jle`> > [1,2,3] >>= replicate 3
01:42:07 <lambdabot>  [1,1,1,2,2,2,3,3,3]
01:42:28 <jle`> kinda mainstream as well i guess
01:42:32 <Iceland_jack> > [1,2,3] >>= \x->[x,x,x]
01:42:34 <lambdabot>  [1,1,1,2,2,2,3,3,3]
01:42:36 <Iceland_jack> same length
01:42:36 <joneshf-laptop> jle`, row polymorphism? i don't think so
01:42:38 <Iceland_jack> hm
01:43:21 <Flonk> jle`: I just thought it was kind of funny how the types are similar
01:43:21 <jle`> what a world we live in that \x->[x,x,x] has the same number of letters as replicate 3
01:43:43 <jle`> :t \x -> mconcat . ap x
01:43:44 <lambdabot> Monoid c => [a -> c] -> [a] -> c
01:43:47 <Iceland_jack> jle`: quit amazing :)
01:43:48 <urbanslug> jle`: lol
01:43:49 <jle`> :t concatMap
01:43:50 <lambdabot> (a -> [b]) -> [a] -> [b]
01:43:55 <Iceland_jack> I personally tried implementing list sections
01:43:58 <Iceland_jack> like tuple sections
01:44:31 <jle`> oic that's cute Flonk
01:44:48 <Iceland_jack>     [,2,2,] ∷ Num a ⇒ a → a → [a]
01:44:48 <jle`> Iceland_jack: how did that go
01:45:04 <Iceland_jack> jle`: It went okay but there didn't really seem to be much desire for it
01:45:30 <Iceland_jack> [,] was the coolest example imo :)
01:45:32 <jle`> i guess not worth the addition of complexity to ghc?
01:45:47 <garretraziel> Hi, is there someone who knows how to use Parsec? I want to use "many", but more like "foldl", I want to accumulate all defined functions so far and give them to next definitions, for semantic analysis...
01:45:56 <joneshf-laptop> jle`, but that's all the more reason to use purescript :D
01:45:59 <Iceland_jack> maybe not? it did nicely mirror other sections, especially tuple sections of course
01:46:07 <Iceland_jack>     [,] ∷ a → a → [a]
01:46:23 <Iceland_jack> but yes, not the most important thing you could have
01:46:35 <tdammers> garretraziel: Parsec parsers are monads, so you can use the usual suspects from Control.Monad
01:47:13 <jle`> feels like it could possibly be interpreted as feature creep
01:47:21 <jle`> but i do think [,] is worth having
01:47:39 <Iceland_jack> jle`: Agreed on both accounts :)
01:47:58 <Iceland_jack> it's quite a small addition though
01:48:34 <garretraziel> tdammers: Ok, thanks, I will look at it. I have found "putState" and "updateState" in Parsec, but couldn't find any examples on how to use them.
01:48:46 <pordan30> For uniformity, how would the singleton case be dealt with? [] :: a -> [a] is already taken, and [,[]] breaks the pattern.
01:49:05 <Iceland_jack> it wouldn't be sadly
01:49:12 <jle`> presumably the smae as the case of ()
01:49:17 <Iceland_jack> just like with tuple sections
01:49:22 <jle`> () is not interpreted as a -> (a)
01:49:31 <jle`> (...whatever hat would mean)
01:49:32 <Iceland_jack> You'd have to bite the bullet and write (:[])
01:49:33 <jle`> hm
01:49:39 <jle`> () = id :)
01:49:41 <Iceland_jack> or return :)
01:49:43 <jle`> same amount of letters
01:49:47 <haasn> pure
01:50:13 <Iceland_jack> jle`: If nothing else, we've discovered that equal functions should have the same number of characters
01:50:30 <jle`> sounds like it's time to write a paper
01:50:48 <tdammers> garretraziel: you probably don't want to use Parsec's state monad parts for this
01:50:49 <Iceland_jack> hah
01:51:03 <jle`> what is Parsec's state monad even for?
01:51:05 <haasn> > comparing length "(:[])" "point"
01:51:06 <lambdabot>  EQ
01:51:19 <jle`> isn't it already ParsecT ?
01:51:20 <tdammers> garretraziel: it usually helps to write out the signatures of the thing you want
01:51:30 <tdammers> jle`: yes. Parsec's state functions are kind of pointless
01:51:32 <haasn> jle`: efficiency perhaps
01:51:46 <jle`> tdammers: is there some kind of semantic purpose for them?
01:51:54 <quicksilver> jle`: it didn't used to be parsecT. And the direct implementation is probably slightly faster.
01:52:00 <jle`> or is it just a convenient/performant state stuff
01:52:12 <jle`> in case you wanted ParsecT over State s
01:52:20 <Iceland_jack> haasn: I think you just proved that (:[]) isn't pointless
01:52:20 <quicksilver> stateful parsers suck anyway :)
01:52:22 <jle`> or is it reserved for special semantic usage
01:53:01 <jle`> i just asked A or B or A, so i could use boolean algebra and infer A
01:53:06 <jle`> wait is that how it works
01:53:16 <jle`> A || B || A = A || B, huh
01:53:20 <jle`> i can't go any further
01:53:20 <tdammers> I think the original idea was to facilitate stateful parsers, and parsec was not a transformer yet
01:53:46 <jle`> ah. so nothing more special than wrapping a State, just more convenient/performant
01:53:46 <tdammers> and I agree that stateless parsers are much nicer
01:53:51 <tdammers> yeah
01:53:57 <jle`> it tripped me up when i was first starting to use Parsec
01:54:04 <jle`> before i understood State or monads or anything
01:54:10 <tdammers> mtl might not even have been around when Parsec was designed
01:54:31 <jle`> it made me think that all parsers used state somehow
01:54:36 <jle`> to do anything
01:54:46 <jle`> so i structured my parsers around that
01:55:25 <tdammers> ewww
01:55:38 <tdammers> but yeah
01:55:41 <tdammers> that's how you learn :D
01:55:44 <jle`> it was literally my second project heh
02:00:16 <tdammers> fair enough
02:00:30 <tdammers> I don't even dare go anywhere near *my* second Haskell project
02:00:49 <jle`> also using the source of Pandoc as my only Parsec reference was less of a good idea than i had been lead to believe
02:05:42 <Flonk> Wouldn't it be cool to have an Empty or Default typeclass to designate types that can be empty? I think it's kind of awkward to have mzero, mempty and empty floating around
02:07:06 <sjy> isn't that what Maybe is for?
02:07:17 <Axman6> Flonk: what is empty :: Integer?
02:07:43 <pyon> Axman6: empty :: Sum Integer could be Sum 0
02:08:03 <Axman6> yeah I did think of that after I said it
02:08:10 <pyon> basically, the relation between default and monoid would be similar to the relation between pointed and applicative :-p
02:08:15 <Axman6> there is a Default class, which I guess could be abused for that
02:08:16 <pyon> errr pointed and monad
02:08:58 <Axman6> pointed is basically just return/pure right
02:08:59 <Axman6> ?
02:09:30 <pyon> yep
02:11:40 <kazagistar> I just love that ^@?! is not a swear word but an operator in a popular library... haskell is silly sometimes :P
02:12:06 <Flonk> Axman6: hah yeah, seems like I'm not the only one to have this idea.
02:12:35 <Dongyancai> Hello, is there a way to show a STArray in a runSTArray context?
02:12:59 <Axman6> Flonk: you'll find that in the Haskell world, ideas like that are usually examined from a mathematical point of view to find out if it really makes sense to have
02:13:32 <Axman6> Dongyancai: I think it is, I think there's an undafeIOtoST somewhere, but in general you probably shouldn't do that
02:13:55 <pyon> perhaps he means "show" as in "convert to string"
02:13:59 <Axman6> @hoogle unsafeIOtoST
02:13:59 <lambdabot> Control.Monad.ST unsafeIOToST :: IO a -> ST s a
02:14:00 <lambdabot> Control.Monad.ST.Lazy unsafeIOToST :: IO a -> ST s a
02:14:00 <lambdabot> GHC.Conc.Sync unsafeIOToSTM :: IO a -> STM a
02:14:08 <Dongyancai> Axman6, I just do this for debug... I'll watch into it.
02:14:44 <Dongyancai> pyon, yes, I mean this.
02:14:46 <Axman6> Dongyancai: also Debug.Trace might be useful (though also a hack)
02:15:12 <Dongyancai> I can show an Array, but not a STArray.
02:15:49 <pyon> Dongyancai: you could freeze the array and then show it
02:16:15 <pyon> errr
02:16:20 <pyon> runSTArray seems to be the correct name
02:20:48 * hackagebot stylish-haskell 0.5.10.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.10.0 (JasperVanDerJeugt)
02:40:00 <Dongyancai> pyon, i had a try, but seems not working.  http://pastebin.com/sVHtG3RL  why the real type is Array Integer (b0 Integer Integer)?
02:40:13 <bezirg> i use getArgs :: IO [String] to read actually a encoded Binary. Is it safe to pass it to decode :: Binary a => ByteString -> a ?
02:41:10 <shachaf> No, it's a type error
02:43:50 <bezirg> shachaf: I mean I am gonna pack it before passing it
02:44:01 <shachaf> What is packing?
02:44:24 <bezirg> Data.ByteString.Lazy.Char8.pack :: String -> ByteString
02:45:08 <shachaf> No, Data.ByteString.*.Char8 is an evil module that you shouldn't use unless you know what you're doing.
02:45:16 <pyon> Dongyancai: "runSTArray $ newArray (0,9) 1" worked just fine on my machine :-|
02:45:25 <bezirg> shachaf: :( ooo didn't know that
02:45:34 <bezirg> shachaf: should I use utf8-string instead?
02:45:40 <shachaf> Now you know. ByteString is for a list of bytes, not characters.
02:45:48 <Dongyancai> well, I want to show its content
02:45:51 <shachaf> You can use utf8-string to encode characters as bytes.
02:46:15 <shachaf> Anyway, in particular, this will fail in practice in all sorts of situations, since the command line is going to be decoded as a Unicode String (probably with UTF-8).
02:46:30 <shachaf> That's lossy -- there's no way to recover the original bytes back.
02:46:39 <bezirg> shachaf: so with utf8-string.fromString will probably work, right?
02:47:15 <kazagistar> shachaf: if you actually wanna deal with bytes then char8 is fine, right?
02:47:16 <pyon> Is there any way to index a UTF-8 string *by byte*?
02:47:29 <merijn> kazagistar: Char8 is fine for only *1* single use case
02:47:34 <shachaf> kazagistar: No, Char8 is a lie that pretends bytes are characters.
02:47:50 <shachaf> kazagistar: If you want to deal with bytes, use Data.ByteString[.Lazy], which deals with actual bytes.
02:47:59 <pyon> Dongyancai: http://lpaste.net/102764
02:48:02 <shachaf> The GHC name for an unsigned byte is Word8.
02:48:17 <pyon> Dongyancai: the contents of the array were shown just fine
02:48:22 <shachaf> bezirg: Absolutely. Everything I said about how it wouldn't work for the last couple of sentences was a lie meant to fool you into doing extra work.
02:48:27 <merijn> kazagistar: The following use case: I have a network protocol (i.e. bytes, so ByteString), which has pseudo text commands (think like HTTP with it's "GET", "POST", etc.) commands
02:48:33 <shachaf> (The answer is no, it won't work.)
02:49:09 <merijn> kazagistar: Char8 exports an IsString instance for converting string literals to ByteString, BUT it silently discards any non-ASCII values!!!
02:49:19 <shachaf> merijn: :-(
02:49:44 <merijn> kazagistar: So really, it only makes sense for specifying ascii literals for network protocols and you should forget it even exists for any other usecase
02:50:07 <kazagistar> shachaf: somehow, hoogle and documentation guided me towards Char8... I wanted to count byte frequency and char8 was the only way I found to load a file and access it byte by byte
02:50:14 <shachaf> Char8 is expert-only. If you don't know what's wrong with it you should just not use it.
02:50:19 <merijn> I wholely support renaming Data.ByteString.Char8 to Data.ByteString.Unsafe.NoReally.DontFuckingUseThis.YouAskedForIt.Char8
02:50:27 <shachaf> kazagistar: Just use Data.ByteString[.Lazy]
02:50:30 <shachaf> Forget Char8.
02:51:33 <kazagistar> cool, ill keep that in mind
02:51:36 <merijn> kazagistar: Data.ByteString and Data.ByteString.Char8 are literally identical, except that Char8 is filled with lies and broken functions like "pack :: [Char] -> ByteString" instead of "pack :: [Word8] -> ByteString"
02:51:39 <Jafet> We can't do that, merijn. That would break all the code out there that depends on Char8.
02:51:46 <merijn> Jafet: Well, good
02:51:52 <merijn> Jafet: That'll teach 'em
02:51:56 <merijn> :)
02:52:22 <yoeight> Hi, is there a package similar to java.util.Locale ?
02:52:24 <Jafet> E2BIG2FAIL
02:52:41 <Dongyancai> pyon, I mean I want to show the content in a runSTArray context. because I need to debug in a large runSTArray context...
02:53:10 <yoeight> like java.util.Locale.getDefault
02:53:33 <haasn> yoeight: what kind of Locale stuff do you want to do?
02:53:53 <yoeight> hassn: system default language
02:54:33 <kazagistar> it would be really helpful to have some kind of opinionated listings about libraries... some stuff that is hidden in some library with unclear type signatures is really useful, and some stuff that you run into right away has serious problems. Its too easy to make mistakes unless someone guides you the right way
02:54:35 <Jafet> unsafePerformIO . unsafeSTToIO . unsafeFreeze -- as a bonus, you will remember to remove this after debugging
02:55:07 <Jafet> The Char8 haddock should have a warning telling you not to use it.
02:55:09 <yoeight> hassn: I need get the default system language
02:56:19 <Jafet> Ok, it still does not have a warning.
02:56:43 <Jafet> "The Char8 interface to bytestrings provides an instance of IsString for the ByteString type, enabling you to use string literals, and have them implicitly packed to ByteStrings." my foot, shoot it now
02:57:13 <Dongyancai> Jafet, unsafeFreeze makes strange message. as http://pastebin.com/sVHtG3RL , I know I can have a type of `Array Integer Integer', but what is a type of `Array Integer (b0 Integer Integer)' ?
03:00:30 <kazagistar> Jafet: so maybe the better solution would be something that lets you String -> Maybe [Word8]
03:00:33 <haasn> merijn: let's get rid of FilePath while we're at it
03:02:33 <haasn> yoeight: hmm, I can't find anything
03:02:51 <haasn> but maybe you could just query for $LANG as a workaround or something
03:04:05 <lpsmith> hmm, is there an unsafeLiftIO :: IO a -> STM a ?
03:04:12 <tdammers> this may seem obvious, but the ByteString modules have overloaded IO functions in them
03:04:32 <tdammers> for doing byte-wise / binary IO instead of string IO
03:04:34 <tdammers> just saying
03:07:10 <kazagistar> Dongyancai: I think that means an Array, indexed by integers, that takes a "something" parameterized with Integer Integer at the end?
03:07:26 <Phillemann> Can I somehow start ghci with a .cabal file, similar to opening a program via "ghci Program.hs"?
03:07:42 <tdammers> Phillemann: with newer cabals, you can use cabal repl
03:08:06 <Phillemann> Ah, that worked. Thanks! :)
03:11:35 <kazagistar> Dongyancai: so, like, an array of (Integer, Integer) tuples would work, but an array of IO String would not
03:11:41 <bezirg> I have a strange behaviour. When I build my code with cabal everything is fine, when I load a module locally the error is No instance for (Binary P.ProcessId) arising from a use of `decode
03:11:57 <bezirg> cabal repl also works fine for the module
03:12:30 <tdammers> you have to import the module that defines the instance, too
03:12:50 <bezirg> but why cabal does not require this?
03:13:05 <bezirg> only ghci complains, cabal builds fine
03:13:58 <tdammers> it does, but my guess is that wherever you're using that instance, you have imported it
03:14:02 <tdammers> in the code, that is
03:18:33 <bezirg> tdammers: I am gonna blow up! I include the module that defines the instance, but still ghci complains!
03:18:42 <bezirg> tdammers: really strange behaviour :/
03:21:18 <tdammers> hard to remote debug :D
03:21:33 <bezirg> tdammers: y I understand :)
03:23:30 <Phillemann> A do-notation statement discarded a result of type IO ().
03:23:35 <Phillemann> Is that a proper warning? o_O
03:23:54 <tdammers> yes
03:24:13 <Phillemann> But...it's (). Why wants to process that further? :)
03:24:16 <tdammers> you probably have something of type `IO (IO ())`
03:24:19 <Phillemann> s/Why/Who/
03:24:28 <Phillemann> tdammers: Ah.
03:24:30 <tdammers> :t return $ print "Hello"
03:24:31 <lambdabot> Monad m => m (IO ())
03:24:46 <quicksilver> so it's warning you that you never actually ran that action
03:24:46 <Phillemann> I actually wrote putStrLn <$> someIoAction
03:24:52 <quicksilver> probably a pretty good warning
03:25:03 <tdammers> yeah, definitely a good warning
03:25:13 <tdammers> you probably mean someIoAction >>= putStrLn
03:25:14 <Phillemann> Yes, I see that now.
03:25:15 <Walther> hmm. I need a function that uses either the only data it's supplied or the last two if it's supplied a list of data
03:25:19 <tdammers> (or the =<< variant)
03:25:20 <quicksilver> putStrLn =<< someIoActions
03:25:56 <tdammers> isn't it great how Haskell even makes mind reading possible?
03:26:21 <Walther> Or rather, I need a function call that works for a list of data, and typechecks and silently fails when it is only supplied a single value :|
03:26:56 <Kinnison> Walther: what should it do if given an empty list?
03:27:00 <pyon> Dongyancai: sorry for the delay -- http://lpaste.net/102764 -- you can freeze the array inside the ST do block -- although the type signatures are rather hairy
03:27:22 <tdammers> Walther: you mean you want type-level list lengths?
03:27:32 <silasdavis> I'm trying to use attoparsec to parse a binary file format
03:27:41 <tdammers> no wait, I read that wrong
03:28:05 <tdammers> you could just use some simple pattern matching
03:28:13 <tdammers> f (x:y:_) = whatever x y
03:28:27 <silasdavis> it feels like I might be able to reverse the structure of the parser to help me generate files of the format I am parsing
03:28:27 <tdammers> f _ = failSilently
03:28:36 <Kinnison> tdammers: he wants *last two*
03:28:39 <silasdavis> has anyone come across this sort of duality with parser combinator libraries?
03:28:49 <tdammers> Kinnison: ah right yes
03:28:55 <Walther> Namely, I get json data elements from a server, and I want to change my responses according to the data i get. I need to use a delta of angles between last two data elements given; but I don't want it to fail when the whole thing starts and I'm just given the initial single data
03:29:13 <Ywen> cschneid: I wrote a little lib to ease the use of the "transformers only" pattern, it's here: https://github.com/YPares/MonadPointer (I got the idea from your question of yesterday)
03:29:22 <erisco> silasdavis, you can construct the files using the syntax tree
03:29:30 <tdammers> Walther: how about a good old-fashioned list length check in an if?
03:29:38 <kazagistar> Walther: you could do pattern matching on the reversed list?
03:29:42 <Walther> tdammers: but but but
03:29:59 <tdammers> f xs = if length xs < 2 then failSilently else doTheThing (takeLastTwo xs)
03:30:12 <Kinnison> Walther: http://lpaste.net/102768 is my dodgy nasty idea
03:31:54 <tdammers> http://lpaste.net/102769
03:31:59 <tdammers> that should work too
03:32:43 <Ywen> ocharles: I'd be interesting in knowing your opinion about it too
03:33:50 <bezirg> tdammers: I put a small code that fails with ghci and works with cabal http://lpaste.net/102770
03:34:38 <tdammers> that is strange
03:34:43 <tdammers> no clue, really
03:34:46 <tdammers> someone else might
03:35:53 <srhb> bezirg: How do you load it with ghci?
03:36:04 <srhb> And what's the error?
03:36:30 <srhb> I assume you have some modules available in your sandbox, but not in your user packages
03:36:50 <silasdavis> erisco, yes that's true, I wonder if I can get the parser to help me build a tree of the right shape
03:37:05 <erisco> silasdavis, why would the parser have to help with that?
03:37:16 <erisco> the syntax tree should already describe the correct shape
03:38:05 <silasdavis> if I want to create a new file, I would need to build the syntax tree
03:38:19 <erisco> sure. is that not what you want?
03:38:28 <tdammers> erisco: the tree shape of the AST doesn't have to be the same as that of the syntax
03:38:55 <silasdavis> yeah I'm just wondering what enforces that structure, should I be defining a type for the syntax tree
03:39:20 <tdammers> the typical approach is to define data structures for an *abstract* syntax tree
03:39:21 <erisco> I would define types for the syntax tree, yes
03:39:40 <tdammers> i.e., the conceptual syntax minus sugar
03:40:04 <silasdavis> perhaps what I am after is to provide sufficient information to one structure that would allow me to specify the syntax tree and produce a parser at the same time
03:40:08 <silasdavis> ah ok
03:40:16 <erisco> if the types you are using are weaker than the tree described by your grammar then I could see where you'd want something more
03:41:07 <silasdavis> yeah presumably they're weaker, like if I have the possibility of repeated elements, I don't think I can bound cardinality in the type system
03:41:28 <erisco> enforcing a particular construction of a weaker tree would have to be done at the type level
03:41:49 <erisco> and to that I think there is possibility but it would probably not be simplistic
03:42:40 <erisco> I did something similar for parsing and generating web routes. The format of the route is expressed as a type and by using meta-programming either a parser or a builder can be generated for the format
03:43:38 <erisco> a more practical solution may be to define helper functions
03:44:06 <erisco> for your particular grammar, rather than for parser combinators in general
03:46:01 <erisco> silasdavis, I think that is an interesting idea though
03:52:01 <Dongyancai> pyon, thank you very much, but it seems not working in debugging mode in another ST monad context. I have given up and remove the code afterwards and see the outputs.
03:53:40 <pyon> Dongyancai: oh well, best of luck :-)
03:54:59 <Peaker> Show instances that are not valid Haskell syntax are supposedly bad practice -- but so common in the stdlib!
03:55:43 <erisco> why should Show be Haskell syntax? I thought the purpose was for debug printing
03:56:53 <Cale> erisco: It is, which is why valid Haskell syntax for reconstructing the structure is a good thing
03:57:11 <haasn> Yeah, usually at least so you can sort of know what it's equivalent to / how to pattern match on it
03:57:12 <bergmark> yes it's very confusing when it prints something 'clever'
03:57:26 <Peaker> Control.Exception is based around the idea of exceptions whose Show is a user-friendly string :(
03:57:51 <erisco> *shrug*
03:57:51 <Peaker> it should probably have had a simple String inside it instead of having the Show thing
03:58:22 <Peaker> instead of SomeException e   have SomeException String e,  and don't require a Show instance, only a Typeable=>Exception instance
03:58:56 <Peaker> also Data.Time's DiffTime/etc have clever Show instances
04:01:19 <BoR0> how do I go for converting a IO [SQLValue] to a ByteString?
04:01:41 <Peaker> BoR0: You can't, but you might be able to convert [SQLValue] into a ByteString and that ought to do
04:01:51 <BoR0> how can I do that?
04:02:07 <Peaker> BoR0: Depending on what kind of ByteString you want from that? Which package's SQLValue are you talking about?
04:02:23 <BoR0> SqlValue, sorry. it's HDBC.ODBC, the result of quickQuery'
04:03:35 <Peaker> what kind of ByteString do you want?
04:03:43 <Cale> BoR0: Note that an IO [SQLValue] isn't in any sense a list of SQLValues, it's an action which if executed would produce such a list.
04:04:01 <BoR0> yes, I get that
04:04:27 <silasdavis> erisco, ok, well I'll have a go
04:04:31 <BoR0> well, I want to pass the result to Snap, so I guess Data.ByteString.Internal.ByteString since that's what writeBS accepts
04:04:40 <Cale> There's unfortunately not really any good way to serialise actions, though that would be cool.
04:06:35 <Peaker> BoR0: SqlValue and ByteString need some sort of explicit conversion
04:06:39 <Walther> Hmm. Can't get this to compile, keep getting "can't match expected type '[carposition]' with actual type 'carposition' http://pastebin.com/57EHsqF2
04:06:44 <Peaker> BoR0: what kind do you want?
04:07:05 <BoR0> what do you mean by what kind?
04:07:23 <bezirg> srhb: I loaded it to ghci with: ghci -package-db ../.cabal-sandbox/x86_64-linux-ghc-7.6.3-packages.conf.d
04:07:23 <bezirg>  
04:07:29 <BoR0> I want to be able to pass a result from SQL to       writeBS  :: MonadSnap m => Data.ByteString.Internal.ByteString -> m ()
04:07:41 <bezirg> srhb: also ghc-mod complains besides ghci
04:07:51 <erisco> Walther, your pattern does not make sense  (_:(CarPosition _ angle1 _):(CarPosition _ angle2 _))
04:08:07 <Cale> Walther: You could try (_:(CarPosition _ angle1 _):(CarPosition _ angle2 _):_) as your pattern
04:08:15 <Cale> Why are you ignoring the first element of the list?
04:08:57 <Cale> also, the first binding for selectSpeed will always match, so even if you fix this pattern, it won't ever get used
04:09:09 <Cale> (though you can move that case below)
04:10:13 <Peaker> BoR0: an SqlValue contains either some integer, or time, or string, or ...   do you want to just "show" them into a String and then convert that to a ByteString?
04:10:20 <Peaker> BoR0: or do you want an efficient marshalling into binary format inside the ByteString?
04:10:26 <BoR0> ah, that could work, showing them to a string
04:10:34 <Peaker> BoR0: or maybe a custom format for the HTTP response to snap?
04:10:45 <Cale> Walther: It's also possible you wanted the pattern to be ((CarPosition _ angle1 _):(CarPosition _ angle2 _):_)
04:14:55 <BoR0> Peaker, showing it to a String would work
04:15:31 <srhb> bezirg: I just tried ghci -package-db .cabal-sandbox/... src/Main.hs -- works as expected
04:15:47 <Walther> Cale: I want to match the last two angles
04:15:57 <Walther> ignore the previous data elements
04:16:07 <Walther> well, angles of last two received data elements*
04:16:55 <Peaker> BoR0: so if you have:  mkSqls :: IO [SqlValue]    then you can write:   import qualified Data.ByteString.UTF8 as UTF8 ... do { sqlValues <-- mkSqls ; let asByteString = UTF8.fromString (show sqlValues) }
04:16:57 <Cale> Walther: Ah, in that case, you should probably just reverse the list first
04:17:24 <Cale> (so that those are the first two elements)
04:18:29 <Walther> Why does that matter?
04:18:52 <erisco_> you can only pattern match on the front of the list
04:19:01 <Walther> Huh.
04:19:27 <Walther> would be useful to be able to pattern match from the end as well
04:19:33 <kazagistar> Walther: lists are linked lists, with pointers in only one direction
04:19:53 <kazagistar> Walther: so matching on the end would have to go through the length of the list anyways
04:20:04 <Cale> Matching on the end is an inherently costly thing to do (it might even require an infinite amount of time!)
04:20:18 <Cale> (you have to walk all the way down the list)
04:20:53 <kazagistar> > last [1..]
04:20:56 <lambdabot>  mueval-core: Time limit exceeded
04:21:03 * hackagebot snap-server 0.9.4.3 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.4.3 (GregoryCollins)
04:21:05 <tdammers> I'd argue that pattern-matching on the end of a list would fundamentally change what pattern matching even *is* in haskell
04:21:11 <kazagistar> (sorry lambdabot, I had to)
04:21:38 <Cale> You could use the ViewPatterns extension along with an appropriate function (which computes both init and last) to match on the end of a list
04:21:53 <Cale> But it wouldn't usually be very wise :)
04:22:07 <kazagistar> in any case pattern matching is generally constant time, that is the expectation
04:22:50 <BoR0> Peaker, ok, how about when mkSqls returns a SqlByteString "test" ?
04:23:02 <kazagistar> Cale: plus, to match the last two elements in your view patterns extension might require going through the list twice?
04:23:12 <Peaker> BoR0: you mean [SqlByteString "test"] ?
04:23:16 <Cale> kazagistar: yes
04:23:29 <Cale> (unless you had a special function for that)
04:23:30 <bezirg> srhb: I fixed it. In my global package.conf I hade binary>0.7 . I removed it. I reinstalled the cabal sandbox. It seems that the distributed-process does not work with binary>0.7  , and that was what was picked off by ghci and ghc-mod
04:23:43 <BoR0> Peaker yeah, but I can get to the first element by doing return $ head quickQuery' ...
04:23:45 <srhb> bezirg: Odd.
04:23:55 <bezirg> srhb: y it is odd.
04:24:19 <bezirg> srhb: anywayz, I removed binary>0.7 from global then I reinstalled cabal sandbox dependencies
04:24:31 <Iceland_jack> <Walther> would be useful to be able to pattern match from the end as well
04:24:31 <Iceland_jack> You can pattern match on the end of a list using new extensions but you need to understand that pattern matching follows the value constructors
04:24:36 <bezirg> srhb: thx very much for your help!
04:24:39 <jakex> > map read (words "10 20 30") :: [Int]
04:24:40 <lambdabot>  [10,20,30]
04:25:38 <Peaker> BoR0: I don't understand your question.. what do you want to do?
04:26:03 * hackagebot io-streams 1.1.4.3 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.4.3 (GregoryCollins)
04:26:13 <Cale> Well, I suppose you could use view patterns with reverse :)
04:26:14 <Cale> heh
04:26:23 <Iceland_jack>     pattern Last x = (last -> a)
04:26:25 <Cale> Which would only involve traversing the list once
04:26:49 <Iceland_jack> then if you do
04:26:50 <Iceland_jack>     foobar (Last a) = a
04:26:50 <Iceland_jack> you get
04:26:50 <Iceland_jack>     ghci> foobar [1..10]
04:26:53 <Iceland_jack>     10
04:26:53 <BoR0> Peaker, consider I have a function mkSql that returns SqlByteString "test" (not a list, just that value). I want to "convert" it to ByteString
04:27:01 <Iceland_jack> but this is morally dubious :)
04:27:17 <Cale> > let (reverse -> (x : y : zs)) = [1..10] in (x,y,zs)
04:27:18 <Iceland_jack> sorry,
04:27:19 <Iceland_jack>     pattern Last x <- (last -> a)
04:27:19 <lambdabot>  (10,9,[8,7,6,5,4,3,2,1])
04:27:37 <Cale> > let f (reverse -> (x : y : zs)) = (x,y) in f [1..10]
04:27:39 <lambdabot>  (10,9)
04:27:53 <Fernandos> hi
04:28:14 <Fernandos> Do you have a simple example for the visitor pattern?
04:28:17 <Peaker> BoR0: you want it to become ("test" :: ByteString) (via UTF8)?
04:28:24 <BoR0> yes, that will work
04:28:24 <Fernandos> I mean in haskell of course .)
04:29:00 <Fernandos> Just started learning Haskell, but haven't seen any examples on how such patterns are implemented..
04:29:03 <Peaker> BoR0: you can pattern-match on the sql value:  case myVal of SqlByteString x -> x ; _ -> error "Expecting an SqlByteString"
04:29:15 <Iceland_jack> Fernandos: Have you had a need for it?
04:29:39 <tdammers> Fernandos: haskell is not OOP, so OOP patterns are of limited usefulness
04:29:40 <nomeata> scanl f z l = let r = z : zipWith f z l -- would this definition have any advantage over http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-List.html#zipWith ?
04:29:51 <Iceland_jack> It's sometimes good to leave baggage at the door :)
04:30:07 <tdammers> Fernandos: you probably want to step up and look at the problem you're solving at a higher level
04:30:08 <nomeata> I mean "scanl f z l = let r = z : zipWith f r l in r"
04:30:13 <Fernandos> Iceland_jack: yep, I want to run a "process" and let it send a heartbeat every 2secs and kill it, if there is no response within 2.5secs
04:30:15 <Peaker> Fernandos: the Visitor pattern is a horrible work-around for the lack of sum types and pattern-matching. In Haskell you can just do sum types + pattern matching directly
04:30:30 <jtcwang> I have some funny things going on here: http://lpaste.net/102773
04:30:53 <Fernandos> tdammers: ew.. that throws most of what I know out of the window :) haha
04:31:03 <Iceland_jack> Are you talking about an actual process or a thread or OS thread or...?
04:31:08 <jtcwang> type signature of ByteString.Char8.unpack is ByteString -> [Char]
04:31:20 <Fernandos> Iceland_jack: a thread
04:31:20 <Peaker> Fernandos: most of what you know is workarounds for OOP language deficiencies? :)
04:31:20 <merijn> jtcwang: Don't use Char8
04:31:30 <jtcwang> but suddenly compiler is talking about Word8
04:31:40 <Fernandos> Peaker: I guess, what you say may have some merit and truth in it
04:31:49 <merijn> jtcwang: Char8 is filled with lies, voodoo and not-so-subtle bugs waiting to happen
04:31:55 <jtcwang> merijn, what should I use instead?
04:31:59 <tdammers> to be fair, some of the design patterns are just the result of applying common sense to OOP
04:32:00 <merijn> jtcwang: Data.ByteString
04:32:06 <tdammers> insofar as that is possible
04:32:17 <jtcwang> just do explicit conversions myself i guess?
04:32:21 <Peaker> "Design patterns are bug reports against the language"
04:32:25 <tdammers> :D
04:32:27 <tdammers> yeah
04:32:34 <merijn> jtcwang: If you want to encode unicode data to ByteString you want to go via Text
04:32:49 <Fernandos> Peaker: I only want to keep the heartbeat sample code compact and not blow it to 400crazy lines, that's why I wanted to get that pattern in here :)
04:33:00 <merijn> jtcwang: Text.Encoding has encoding functions for Text -> ByteString and Data.Text has "pack :: [Char] -> Text"
04:33:16 <jtcwang> merijn, right, in this case it's 100% word8 since I'm dealing with binary here
04:33:29 <jtcwang> so i should stick with ByteString
04:33:32 <jtcwang> ?
04:33:42 <tdammers> Fernandos: so you have one thread that does stuff and sends some sort of signal every 2 seconds, and another thread that checks on it?
04:33:42 <merijn> jtcwang: If you have Word8 then just use Data.ByteString.pack which has "pack :: [Word8] -> ByteString"
04:34:09 <Peaker> Fernandos: a watchdog like that fits in a few lines, probably
04:34:29 <Peaker> Fernandos: do you want a new "process" as in unix child process, or a Haskell thread?
04:34:52 <tdammers> (btw, the Visitor Pattern part is actually pretty irrelevant at this level)
04:35:08 <Walther> Cale: kazagistar: in this case, i need to traverse the entire list anyway, because i'll always need the last two of newest returned list, reversing it manually or using some extensions to pattern match from the end
04:35:25 <Fernandos> tdammers: Only try to keep it as lean as possible, without too much fiddling. That means, yes it's a thread that sends. "I'm here" every 2s and, the other thread, loop or timer only needs to check, if it's equal or exceed 2.5secs.
04:35:30 <markp> Is there a library which does randomized testing of two programs which should have the same output?
04:35:36 <jtcwang> merijn, rightio, I'll dig the docs, thx :)
04:35:39 <merijn> jtcwang: Oh, wait you're just trying to add 1 to every byte?
04:35:46 <Iceland_jack> Walther: There is no need to pattern match here
04:35:46 <jtcwang> yeah haha
04:35:48 <Iceland_jack> just use 'last'
04:35:50 <jtcwang> just playing around with conduit
04:35:51 <merijn> jtcwang: You're making your lift so difficult using Char8...
04:35:53 <markp> Something like quickcheck, except then something which can handle I/O.
04:36:01 <tdammers> Fernandos: yes, but which of the sub-problems are we solving? The threading thing, thread state synchronization, or dispatching the incoming heartbeat event in the consumer thread?
04:36:05 <Fernandos> tdammers: to cause some anomaly, I mean to let the program actually exceed 2.5s in 10% of the time, I'd need to write a function or something
04:36:13 <Iceland_jack> markp: yes :) QuickCheck
04:36:17 <merijn> jtcwang: Data.ByteString.unpack is "ByteString -> [Word8]" and Word8 is an instance of Num
04:36:26 <Fernandos> I've done in Scala earlier, but that was pretty long and not really readable
04:36:32 <tdammers> Fernandos: sure, but I don't see how a Visitor would make that any easier
04:36:34 <Iceland_jack> or monadic QuicCheck to be precise
04:36:40 <jtcwang> merijn, well that makes it easy doesn't it? I'll try that
04:36:46 <merijn> jtcwang: But more importantly, ByteString already has "BS.map :: (Word8 -> Word8) -> ByteString -> ByteString"
04:36:53 <Iceland_jack> QuickCheck*
04:37:00 <Fernandos> tdammers: gotcha, would probably only make sense in Java, which I also implemented. But that code was twice as long as the scale code
04:37:02 <merijn> jtcwang: So you're entire function is "BS.map (+1)"
04:37:13 <merijn> s/you're/your
04:37:17 <jtcwang> merijn, can't complain about that
04:37:26 <merijn> jtcwang: Note that that code will wrapp 255 to 0
04:37:29 <tdammers> oh right, a typical Java solution would probably mash it all up into one horrible ball of goo
04:37:32 <merijn> > 255 + 1 :: Word8
04:37:34 <lambdabot>  0
04:37:40 <quchen> merijn: Is that standardized?
04:37:47 <Iceland_jack> markp:
04:37:47 <Iceland_jack>     import Test.QuickCheck.Monadic
04:37:47 <Iceland_jack>     prop_test = monadicIO $ do
04:37:47 <Iceland_jack>         a <- run $ ioAction
04:37:48 <jtcwang> merijn, yeap I am aware
04:37:50 <Iceland_jack>         b <- run $ ioAction
04:37:53 <Iceland_jack>         assert (a == b)
04:37:59 <jtcwang> merijn, just a test function :)
04:38:11 <merijn> quchen: Yes, Word just behaves like machine words
04:38:14 <markp> thx
04:38:16 <merijn> quchen: Which overflow to 0
04:38:28 <merijn> I'm not sure whether Int8's behaviour is defined
04:38:46 <merijn> > maxBound + 1 :: Int8
04:38:47 <lambdabot>  -128
04:39:03 <quchen> Good to know.
04:39:09 <Jafet> QED
04:39:28 <aviraldg> Is there a way to check if a type is an instance of a typeclass?
04:39:33 <Iceland_jack> aviraldg: :info
04:39:43 <merijn> quchen: Well, actually I guess overflow on Word is defined to be "whatever the machine does for words of that size"
04:39:51 <Iceland_jack>     ghci> :info Char
04:39:51 <Iceland_jack>     instance Eq Char ...
04:40:00 <merijn> Iceland_jack: Won't work if the class/instance isn't in scope :)
04:40:01 <Iceland_jack> (or :i)
04:40:19 <tdammers> alternatively, call a function that requires the instance to exist
04:40:23 <tdammers> write one if you have to
04:40:24 <Iceland_jack> well sure, it won't work with packages you haven't installed and instances that will be written in the future :)
04:41:05 * hackagebot yesod-core 1.2.13.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.13.1 (MichaelSnoyman)
04:41:54 <Fernandos> tdammers: do you have an idea on how I would realize that with Haskell?
04:42:02 <quchen> merijn: All [Word*] arithmetic is performed modulo 2^n, where n is the number of bits in the type. (First paragraph of the Report on Word*)
04:42:04 <tdammers> Fernandos: which part?
04:42:16 <tdammers> Fernandos: Control.Concurrent is probably an important building block
04:42:23 <k00mi> Fernandos: have a look at MVars
04:42:34 <tdammers> MVars, STM, IORefs
04:42:41 <quchen> merijn: Same thing for Int*
04:43:01 <Fernandos> checking a thread for responsivity every 2s and let it cause hickups in some percent of the cases, to restart the unresponsive thread
04:43:26 <merijn> Fernandos: That doesn't even really make sense in a lightweight threaded environment
04:43:38 <Fernandos> merijn: hmm what would you suggest?
04:43:38 <merijn> Is there someone who can explain some Core to me?
04:44:48 <quchen> merijn: “It's just a simple functional language” is an unregisterised trademark of Peyton Jones Enterprises, plc. -- The GHC manual
04:45:36 <merijn> Core + core: http://lpaste.net/102776
04:45:42 <merijn> eh, Code + core
04:45:58 <merijn> Line 19 confuses
04:46:04 <merijn> +me
04:46:28 <merijn> To the point where I can't type anymore, apparently. Anyway, clearly __pkg_ccall is responsible for the call to C
04:46:45 <merijn> But I don't understand why there seems to be a typed mixed into that term line?
04:46:59 <quicksilver> what typed where?
04:47:17 <merijn> s/typed/type
04:47:21 <merijn> On line 19
04:47:29 <Peaker> hah,  I wrote   async $ forever threadDelay 10000      (forgot parens around threadDelay) and it type-checked into an infinite-loop runtime bug in the (->) monad
04:47:58 <quicksilver> oh the State# RealWorld part?
04:48:20 <quchen> Peaker: As opposed to the infinite-loop runtime bug in the IO monad?
04:48:22 <merijn> quicksilver: Yeah, that looks like a type annotation without an actual annotation/cast symbol?
04:48:24 <quicksilver> that does look funku
04:48:30 <quicksilver> looks like a :: got swallowed somehow
04:48:38 <merijn> Maybe ghc-core is broken
04:48:47 <merijn> I'll have ghc dump it itself to check
04:48:48 <Peaker> quchen: Bugs slipping through the type-checker are annoying!
04:49:15 <Peaker> quchen: had another one recently, w.r.t putting a _|_ inside an IORef when it wasn't supposed to be used, but then it was used, but nobody was forcing it :(
04:49:36 <quchen> Peaker: Sure, but you would just have gotten a different infinite loop with parentheses. It's still a funny example though.
04:49:52 <BoR0> Peaker, I managed to show it. next, how can I parse SqlByteString to String? :) I get "[SqlByteString \"test\"]" which is great, but how can I get just "test" out of that?
04:50:08 <Peaker> quchen: it wasn't another bug -- it was the intended behavior.. I'm testing why my "Async.cancel" is not killing my threads in "Async.wait" state
04:50:19 <Peaker> quchen: so wrote a little test program to validate "cancel" does cancel "wait"ing threads
04:50:51 <Peaker> BoR0: why parse it?  Just extract it with pattern-matching
04:51:01 <quicksilver> you might want to decode it
04:51:08 <quchen> Ah. (I think 'cancel' throws an exception in the target thread, which should be unaffected by whether something waits for it.)
04:51:10 <quicksilver> if you know what encoding your DB is using
04:51:19 <christiaanb> hi, how does one haddock document code fragments containing pragma's? the generated html shows the code, but not the pragma.
04:51:22 <Peaker> quchen: I know -- I'm having a weird bug I still haven't figured out
04:51:33 <BoR0> Peaker, is that how it's supposed to be done?
04:51:53 <BoR0> show then pattern match? is that the conventional style of doing it?
04:52:20 <Peaker> BoR0: no -- if you want the value, just pattern match it without show
04:52:26 <BoR0> oh, right!
04:52:33 <BoR0> okay. thanks!
04:53:19 <merijn> quicksilver: -ddump-simpl has the same output, so this seems to be the "right" output
04:53:26 <merijn> However, I'm still confused >.>
04:53:33 <quchen> Peaker: I think I was once bitten by 'wait' rethrowing an exception, I'm not sure whether it was by calling 'cancel' on the thread (or throwing something else). Maybe your issue is related?
04:53:47 <BoR0> ah, I finally managed it! wuhuu
04:54:15 <Peaker> quchen: not sure yet.. playing with lots of debug prints (Haskell debugging sucks :( )
04:55:07 <BoR0> Peaker, so basically do { sqlValues <- mkSql ; return $ do conversion ... } is executing the IO x and stores just x in sqlValues, then we can play around with x and "pack" it into whatever we want? or did I get everything wrong
04:55:29 <christiaanb> I'm trying to generate html for http://lpaste.net/102778, but the generated html does not show the NOINLINE pragma in the code. Do I need to escape it somehow?
04:55:50 <vermeille> <stupid question>In `Just 42 >>= ??? (+1)` what is the name of the function noted "???"? it should be some kind of lifting or something of type (a -> b) -> (a -> m b)</stupid question>
04:56:13 <erisco_> vermeille, Just 42 >>= return . (+1)
04:56:25 <BoR0> it's unit?
04:56:26 <Peaker> BoR0: "do { ... }" doesn't execute things -- it only "binds" the actions together to form a larger action
04:56:30 <Peaker> BoR0: ?
04:56:33 <Fernandos> brb
04:56:45 <BoR0> Peaker, understood
04:56:47 <Peaker> BoR0: it's sugar
04:56:56 <erisco_> vermeille, or fmap (+1) (Just 42)
04:57:22 <vermeille> erisco_: I thought about that, but I thought that `Just 42 >>= return . (+1) >>= return . (*2) >>= ...` wasn't really pretty
04:57:56 <erisco_> > fmap ((+1) . (*2)) (Just 42)
04:57:58 <lambdabot>  Just 85
04:58:00 <quchen> The Monad police says: m >>= return . f ≡ fmap f m
04:58:57 <vermeille> erisco_: I know it's more a functor than a monad that I want to use, but I'm writing some slides for a talk in my school, and I don't find a really simple and stupid example of the maybe monad :(
04:59:14 <kazagistar> vermeille: just use do notation or something if you want to chain things like that
04:59:35 <Peaker> BoR0: do { sqlValues <- mkSql ; return $ do conversion ... }   desugars to:   mkSql >>= \sqlValues -> return $ do conversion ...
04:59:35 <Peaker> BoR0: so you get an action that is composed of "mkSql"   and-then   \sqlValues -> ...
04:59:35 <Peaker> vermeille: foo >>= return . f         is    f <$> foo
04:59:40 <Peaker> (+1) . (*2) <$> Just 42
04:59:46 <erisco_> well the Maybe monad can be used to sequence operations which may fail
04:59:53 <erisco_> I guess that is moreso MaybeT
05:00:05 <BoR0> Peaker, great! was just checking that in GHCI, and I think I finally understand what's happening behind
05:00:14 <BoR0> basically I have this:     db >>= \x -> return $ dbMatch $ head x
05:00:29 <Peaker> BoR0: "head" is evil :)
05:00:33 <BoR0> (db is mkSql, dbMatch is pattern matcher)
05:00:42 <erisco_> @hoogle a -> Maybe a
05:00:43 <lambdabot> Prelude Just :: a -> Maybe a
05:00:43 <lambdabot> Data.Maybe Just :: a -> Maybe a
05:00:43 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
05:00:49 <BoR0> Peaker, what do you propose?
05:00:50 <Peaker> BoR0: if you >>= into a function that just "returns", you can use "fmap" instead
05:00:56 <Peaker> BoR0: explicit-pattern matching
05:01:09 <BoR0> Peaker, so you mean, dbMatch should match on lists?
05:01:10 <vermeille> Peaker: I know that <$> is an alias of fmap. I don't want to write that piece of code "the good way", I'm trying to have a really simple and stupid code snippet to write in my slides
05:01:16 <Peaker> BoR0: what's dbMatch?
05:01:21 <BoR0> dbMatch (SqlByteString x) = x
05:01:44 <erisco_> vermeille, ah I got one
05:02:01 <Peaker> BoR0: I'd write (in >>= form):     db >>= \x -> case x of [SqlByteString x] -> x ; _ -> error ("Expected a single SqlByteString, got " ++ show x)
05:02:04 <erisco_> vermeille, how about if you want to lookup multiple elements in a Set and do something with them all?
05:02:10 <kazagistar> vermeille: I mean, you shouldnt use an example that does not meet the purpose. if you need to, define two things that might fail, and then compose them
05:02:19 <erisco_> vermeille, the lookup may fail, and therefore it would be convenient to use the maybe monad
05:02:25 <Peaker> BoR0: A) I wouldn't write dbMatch just to extract a simple pattern-match outside
05:02:41 <erisco_> :t S.lookup
05:02:42 <lambdabot>     Not in scope: ‘S.lookup’
05:02:42 <lambdabot>     Perhaps you meant one of these:
05:02:42 <lambdabot>       ‘M.lookup’ (imported from Data.Map),
05:02:47 <BoR0> Peaker, okay, got it
05:02:50 <Peaker> BoR0: B) I would match the list-of-1 pattern and the SqlByteString pattern in the same "case" -- and errorize informatively if mismatch
05:03:02 <quchen> vermeille: Think of converting a String to a number between 0 and 255. First, you have to convert the String to a number, then you have to check whether it's in range. If one step fails, the result is Nothing, otherwise it's the parsed number.  `read255 str = readMaybe str >>= \n -> if 0 <= n && n <= 255 then return n else Nothing` pipes those two together.
05:03:25 <vektor> "No instance for (Read ZonedTime) arusing from the 'deriving' clause of a data type declaration." - Am I getting this right? Does ghci think ZonedTime is no instance of Read?
05:03:28 <BoR0> I'll do what you suggested, but first I wanna play with my current code and convert it to fmap as you suggested :)
05:04:07 <kazagistar> vermeille: the list monad is pretty neat and understandable imho. it represents non-determinism, and lets you compose a -> [b] type things
05:04:09 <vermeille> erisco_: Yeah, why not. I thought as div as the operation which may fail, but yeah, it makes strange code to lift usual arithmetic functions
05:04:21 <vermeille> kazagistar: I already have an example about the list monad :)
05:04:23 <BoR0> wow. fmap (dbMatch.head) db    is equivalent to    db >>= \x -> return $ dbMatch $ head x. that is really cute.
05:05:00 <quchen> vermeille: Or if you have a nested Map, i.e. "foo :: Map k (Map k' v)", you can use Maybe to do lookups:  `lookup i >=> lookup j` will be either Just the (i,j)-th entry, or Nothing if there is none.
05:05:49 <erisco_> in any case you have to use the Maybe monad in a non-degenerate way otherwise you are not really demonstrating the usefulness of it
05:05:50 <vermeille> quchen: I like your first example, it does not introduce datastructure and is threrefore appropriate for a Haskell-virgin audience
05:07:06 <vermeille> erisco_: That's true, I'm quite surprised that there's not something similar as StateT's modify for Maybe
05:15:39 <kazagistar> liftM2 nodeCombine (state deleteFindMin) (state deleteFindMin) >>= flip (uncurry insert) get    -- I just noped my own code
05:19:15 <Peaker> Is killThread just sends ThreadKilled, right? How come it kills a "mask"ed thread?
05:21:18 <Peaker> I have a bracket allocator, in it I print the masking state (which is MaskedInterruptible), and then a killThread of that thread raises an exception during MaskedInterruptible..  Is this supposed to happen?
05:23:39 <int-e> Peaker: well, is there a blocking operation in there?
05:23:49 <Peaker> a wait on an MVar, I think
05:24:01 <int-e> Peaker: right, that's blocking.
05:26:31 <Peaker> hmm.. so "mask" doesn't do what I thought it does
05:29:15 <Peaker> "Asynchronous exceptions may still be received while in the masked state if the masked thread blocks in certain ways; see "Control.Exception#interruptible"." <-- this is what I missed
05:29:43 <Peaker> http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Exception.html#g:13 <-- good to know
05:31:14 <merijn> Peaker: If that couldn't happen it'd be very easy to deadlock
05:31:26 <merijn> Peaker: But that's what you have uninterruptibleMask for :)
05:31:33 <Fernandos> Is there a compact and minimal paxos or accruel failure detction implementation in haskell that you know of?
05:31:36 <Peaker> merijn: well, you'd have to "restore" when you block
05:31:44 <merijn> Peaker: Although getting your code correct with uninterruptibleMask is a bit of a pain
05:32:16 <quchen> Simon Marlow warns about uninterruptibleMask in his book as well, "should be treated with the utmost suspicion"
05:36:02 <Peaker> merijn, quchen: In a bracket, the "release" operation might block -- if it does, and gets an async exception, resources will leak. I think this might be a good place to use uninterruptible mask
05:36:19 <merijn> Peaker: yes
05:36:44 <merijn> Peaker: If you have any non-atomic resource allocation/freeing you will have to
05:37:10 <Peaker> resource-allocation is fine to "cancel" and force out of via exception handlers or such
05:39:05 <int-e> And now I'm wondering about the safety of  bracket (openFile "foo" ReadMode) hClose (\h -> ...)  idiom. hClose does a 'takeMVar'. Which I suppose always succeeds unless the handle is passed on to another thread in the {...} part.
05:40:48 * int-e decides not to worry too much
05:42:34 <Peaker> int-e: well, if the mvar is in use, there is an invariant violation anyway -- handle used outside the bracket
05:42:55 <Peaker> instead of "closed handle error", though, you get a leaked handle
05:47:12 <int-e> it's a small surprise that killing threads may break some invariants inside that thread.
05:47:42 <Phillemann> I've got a program which connects to a server via ssh and does "stuff" while connected. I currently have a lot of functions with the signature: f :: Session -> OtherParameters -> IO Result. Should I pursue using the Reader monad instead? If so, do I have to stack it on top of IO in my use case?
05:48:03 <Phillemann> I've never done anything with either Reader or mtl.
05:48:21 <Peaker> Phillemann: one option is to make your own monad (which uses Reader inside it, but hides that fact so you can later add more stuff)
05:48:33 <Peaker> Phillemann: another is to group all the parameters into a single record so you only have to pass around one thing
05:49:03 <Phillemann> Yes, I'd put this new record structure into the Reader.
05:49:43 <Phillemann> I guess I'm just asking if using Reader would be useful and easy for a beginner.
05:50:10 <Phillemann> Or if it should continue with my "dumb" approach of passing the session to each function.
05:51:13 * hackagebot mzv 0.1.0.2 - Implementation of the "Monads, Zippers and Views" (Schrijvers and Oliveira, ICFP'11)  http://hackage.haskell.org/package/mzv-0.1.0.2 (IsmaelFigueroa)
05:56:14 * hackagebot effective-aspects-mzv 0.1.0.1 - A monadic embedding of aspect oriented programming, using "Monads, Zippers and Views" instead of mtl.  http://hackage.haskell.org/package/effective-aspects-mzv-0.1.0.1 (IsmaelFigueroa)
05:58:38 <merijn> Wait, so if I read things right "foo :: IO CInt" is treated as a function "int foo(void);" and top level variables can only be defined as pointers?
05:59:30 <quchen> Phillemann: I think as an exercise it's worth doing. On the other hand, using Reader often replaces easier type signatures with lots of calls to "lift", so the code may not actually get easier. You don't know until you've tried though.
06:05:49 <Phillemann> quchen: I think I understand. Thank you for your assessment. :)
06:09:32 <merijn> Are the any tutorials on STG syntax?
06:11:54 <roconnor> @type fromLeft
06:11:56 <lambdabot>     Not in scope: ‘fromLeft’
06:11:56 <lambdabot>     Perhaps you meant one of these:
06:11:56 <lambdabot>       ‘IM.fromList’ (imported from Data.IntMap),
06:33:46 <BoR0> so I have this application that connects to SQL db and runs queries and all is fine. but how can I "store" the connection string somehow so that for each db execution I don't read the file that contains the query string?
06:34:01 <BoR0> something tells me to look into State monad but I have no idea what to do
06:34:20 <BoR0> s/query string/connection string/
06:36:48 <jakex> query string doesn't change during the runtime of the program?
06:37:24 <BoR0> connection string does not
06:40:05 <jakex> then I don't see why would you need a State monad, just store it as a String. or am I missing something
06:40:19 <fizbin> Is RankNTypes a strict superset of the capabilities of Rank2Types?
06:40:22 <BoR0> how can I store it? :)
06:40:26 <merijn> fizbin: Yup
06:40:40 <merijn> fizbin: Actually, I believe that they're technically synonyms in GHC :)
06:41:00 <fizbin> Then is there some reasonable scenario in which one would say Rank2Types instead of RankNTypes?
06:41:26 <jakex> connectionString <- readFile path; then pass connectionString around
06:41:32 <merijn> fizbin: In the hypothetical scenario of a non-GHC compiler implementing that one and not the other and you wanting to support it
06:41:38 <fizbin> That is, is there some use in restricting to only rank 2? I guess since ghc has them as synonyms it doesn't matter...
06:42:01 <merijn> fizbin: So for all practical purposes at the moment? Not really
06:44:42 <Guest11132> yep
06:44:49 <Guest11132> anyone here?
06:51:22 <haskell-newbie> Guest11132: http://a.gifb.in/052011/1304618376_tumbleweed-gif.gif
06:51:32 <Guest11132> hello
06:51:51 <vanila> hi
06:51:59 <vanila> hows it going
06:56:28 <TheDutchKiddo> Hello
06:56:50 <TheDutchKiddo> I'm having trouble lately.
06:57:39 <vanila> with what?
06:58:06 <TheDutchKiddo> I''m trying to change my Ip adress serveral times a second
06:58:17 <TheDutchKiddo> But it isn't working out for me
06:59:16 <vanila> in haskell??
06:59:22 <merijn> TheDutchKiddo: I'm unsure how that is related to Haskell (also, that's a terrible idea as it means you're disconnecting your internet access several times a second)
07:00:20 <TheDutchKiddo> I know what it means, Just searching for someone whos pretty good with dns-ddos-ipconfigs-scripts-writing codes
07:00:40 <vanila> lol
07:01:09 <TheDutchKiddo> Whats so funny?
07:22:08 <fizbin> @type let recM x y z = case z of { [] -> y; (hz:zs) -> do { q <- recM x y zs; x hz q}} in recM
07:22:09 <lambdabot> Monad m => (t -> t1 -> m t1) -> m t1 -> [t] -> m t1
07:22:39 <fizbin> @hoogle (t -> t1 -> m t1) -> m t1 -> [t] -> m t1
07:22:40 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
07:22:41 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
07:22:41 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
07:23:01 <fizbin> Okay, good. Someone else already thought of foldrM
07:26:25 * hackagebot quickspec 0.9.3 - Equational laws for free  http://hackage.haskell.org/package/quickspec-0.9.3 (NickSmallbone)
07:28:03 <aviraldg> Why doesn't Hoogle have event debouncing in instant mode? (just curious)
07:36:09 <Rodya_> if anyone has time a free minute.. http://pastebin.com/bZN2KDbM
07:36:26 * hackagebot stm-firehose 0.2.1 - Conduits and STM operations for fire hoses.  http://hackage.haskell.org/package/stm-firehose-0.2.1 (SimonMarechal)
07:37:21 <deweyvm> Rodya_: you may get a more helpful error message if you give rangeSum a type declaration
07:38:22 <merijn> hmmm
07:38:46 <merijn> I just realised that c2hs' support for enums is so utterly broken it's not even funny...
07:39:25 <merijn> It generates Enum instances but relies on the built-in definitions for enumFromTo and succ/pred
07:39:47 <merijn> But for a large numbers of C enums with non-contiguous enum values these will crash...
07:40:03 <deweyvm> Rodya_: i can give a bigger hint if needed tho
07:40:21 <Rodya_> deweyvm: thanks... it says i'm passing in [[a]] when i'm expecting to pass in a list
07:40:55 <Rodya_> so foldl is getting too few arguments
07:41:05 <merijn> Rodya_: I can fix your problem in two steps :) 1) Write down the type signature for rangeSum
07:41:13 <merijn> 2) compare that signature with your code and:
07:41:16 <merijn> :t foldl
07:41:17 <lambdabot> (b -> a -> b) -> b -> [a] -> b
07:41:27 * hackagebot http-client 0.3.1.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.1.1 (MichaelSnoyman)
07:41:29 * hackagebot puzzle-draw-cmdline 0.1.0.1 - Creating graphics for pencil puzzles, command line tools.  http://hackage.haskell.org/package/puzzle-draw-cmdline-0.1.0.1 (vollmert)
07:42:30 <deweyvm> the fold part is correct i think?
07:42:39 <deweyvm> unless im misunderstanding what the function should be doing
07:43:15 <vanila> just write sum instead of foldl (+)
07:43:18 <vanila> and for rangeSum [] = [] write 0
07:46:27 * hackagebot influxdb 0.2.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.2.0 (MitsutoshiAoe)
07:46:56 <deweyvm> im a haskell noob, what should i put for "portablility" in my haddocks?
07:47:20 <merijn> deweyvm: Whatever you like, I don't think it's currently used
07:47:29 <deweyvm> okay, thanks
07:47:31 <merijn> deweyvm: If it's correct, what's the initial value used in the fold?
07:48:06 <deweyvm> oh hehe
07:48:20 <deweyvm> my bad
07:48:33 <merijn> While a list *could* be a legal initial value, but in all likelihood that's not what Rodya_ intended
07:49:11 <aviraldg> foldl1
07:49:23 <AngryRam> nf n = n : nf (n+1)
07:49:23 <vanila> just use sum
07:49:26 <deweyvm> foldl1 is evil :P
07:49:32 <AngryRam> *Main> :t nf
07:49:32 <AngryRam> nf :: Num a => a -> [a]
07:49:39 <AngryRam> what is the meaning of => ??
07:50:00 <vanila> on the left of => is typeclass constraints, on the right is the actual type
07:50:03 <AngryRam> how does one read the type of nf ?
07:50:14 <merijn> AngryRam: You can read that type as "IF 'a' is an instance of the 'Num' typeclass, THEN 'nf' has type "a -> [a]""
07:50:23 <AngryRam> ah thank you!
07:50:24 <aviraldg> deweyvm, ?
07:50:40 <deweyvm> aviraldg: its not total
07:51:11 <haasn> > foldl1 (+) []
07:51:13 <lambdabot>  *Exception: Prelude.foldl1: empty list
07:51:20 <vanila> > sum []
07:51:21 <lambdabot>  0
07:51:28 * hackagebot puzzle-draw-cmdline 0.1.0.2 - Creating graphics for pencil puzzles, command line tools.  http://hackage.haskell.org/package/puzzle-draw-cmdline-0.1.0.2 (vollmert)
07:51:36 <merijn> AngryRam: Basically anything on the left of '=>' means "this type is only valid if these type restrictions are met"
07:52:46 <haasn> or “given a Num a instance, I can give you a value of type a -> [a]”
07:52:51 <merijn> haasn: Right
07:52:59 <haasn> hence the arrow-like appearance of =>
07:53:16 <fizruk> is there something like class MonadReaderWithIndex i e m where ask :: i -> m e ?
07:53:57 <merijn> fizruk: Just "Reader (f i e)" + lens?
07:54:22 <merijn> "f i e" being some type that's indexed by 'i' to retrieve 'e'
07:55:51 <haasn> Profunctor p => p i e
07:56:25 <fizruk> haasn: how do I get monad there?
07:57:20 <haasn> I was mainly making a pun on “pie” and lens type variables. I'm not really sure what you need the abstraction for
07:57:28 <fizruk> merijn: I want a constraint on `m` which will allow me to do `ask :: i -> m e`, I don't get what exactly does your answer mean
07:58:03 <merijn> fizruk: Lens has convenient indexing operations into Reader, State, etc.
07:58:04 <fizruk> haasn: I just don't want to write MonadReader [(k, v)] m or MonadReader (Map k v) m or etc.
07:59:23 <fizruk> merijn: where should I look? I can't find anything relevant in Control.Lens.Indexed
08:00:24 <merijn> fizruk: Stateful column of https://github.com/ekmett/lens/wiki/operators
08:00:26 <q456y> How does pattern matching really work? For example here: https://pastee.org/rgn29
08:00:26 <q456y> My intuition tells me that it relies on equality, ==, Eq
08:00:26 <haasn> > comparing length "MonadReader (Map k v) m" "MonadReaderWithIndex k v m"
08:00:28 <lambdabot>  LT
08:00:31 <q456y> am i correct?
08:00:35 <haasn> q456y: yes
08:00:42 <fragamus> seeking an example of a stateful pipe
08:00:43 <haasn> q456y: it's a special case for numeric literals (and some other overloaded literals)
08:01:00 <q456y> So in this sense, == is really not just another operator, but really an integral part of Haskell itself?
08:01:15 <haasn> q456y: yes, but it's not used for pattern matching in general
08:01:30 <fizruk> haasn: it's not length, it's abstraction over actual indexing structure
08:01:43 <q456y> haasn: how's it done in general then?
08:01:47 <q456y> if not with ==
08:01:55 <merijn> q456y: By identity on constructors
08:01:56 <haasn> q456y: implementation detail
08:02:04 <haasn> q456y: you can match against constructors
08:02:18 <haasn> that's pretty much all the Haskell report says about this
08:02:25 <q456y> merijn: and this is independent of the == ?
08:02:28 <q456y> (and Eq)
08:02:28 <merijn> q456y: I can give you an example implementation, with the caveat that there are many possible implementations and GHC does not use mine
08:02:29 <haasn> q456y: correct
08:02:42 <merijn> q456y: Are you familiar with C?
08:02:43 <haasn> q456y: you can pattern match on types which do not have an Eq instance, or which have == implementations that are nonsensical
08:03:03 <fizruk> merijn: thanks!
08:03:24 <q456y> merijn: yeah i know c, but maybe it's not a good idea to get bogged down with it
08:03:31 <haasn> fizruk: if you want to abstract over structures that can be indexed, you can still use something like lens' Ix type class
08:03:38 <haasn> (inside the ReaderT)
08:03:54 <tac> q456y: equality exists beyond what == gives you.
08:04:06 <tac> q456y: == allows you to decide when two *decidably* equal things are equal.
08:04:13 <q456y> so it uses == for numeric types because that's how they happen to be constructed? is that the idea?
08:04:14 <merijn> q456y: A more abstract view is the following: Imagine simply assigning every constructor a unique Int identifier
08:04:31 <tac> But some types (most famously, many types of functions) are not Eq beacuse they have no decidable equality
08:04:34 <haasn> q456y: it uses == for numeric types because there's no way in general to know what the constructors of an arbitrary numeric type will look like
08:04:42 <merijn> q456y: Since the compiler knows all possible constructors in your program and their unique identifiers it can trivially compare those
08:04:44 <haasn> since the user can just write any data type and make it an instance of Num
08:05:31 <haasn> q456y: eg. data Nat = Zero | Succ Nat -- how is the compiler to know how precisely to change “lucky 7” into “luck (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))” or whatever?
08:05:33 <merijn> haasn: The more fundamental reason to use == for numeric literals is that there are no constructors for unboxed integers
08:05:54 <haasn> merijn: that's a special case of my rule, I guess
08:05:56 <merijn> haasn: "data Int = I# Int#" <- can't pattern match on unboxed values like Int#
08:06:09 <haasn> (and also an implementation detail)
08:06:15 <fizruk> haasn: you mean Indexed?
08:06:18 <haasn> actually, 1, 2, 3 etc. are supposed to be constructors of Int
08:06:25 <merijn> haasn: Naah, because your explanation is an implementation detail. It's trivial to implement the expansion
08:06:27 <haasn> (and in GHC, 1#, 2#, 3# etc constructors of Int#)
08:06:36 <merijn> haasn: In fact, Template Haskell already lets you do this, so GHC could do this too
08:06:42 <haasn> fizruk: yes
08:06:53 <haasn> merijn: I don't follow; how does GHC infer how my Num instance works?
08:07:03 <haasn> merijn: oh, you mean compute “fromIntegral x” at compile time?
08:07:12 <merijn> haasn: Right, because literals are fixed anyway
08:07:25 <merijn> haasn: However you can't get away with that for unboxed int
08:07:27 <haasn> what if fromIntegral x is _|_?
08:07:39 <haasn> should the compiler fail to terminate?
08:07:41 <merijn> haasn: Then your compilers saves you time by crashing :)
08:07:51 <merijn> And you deserve it! :p
08:07:51 <haasn> so the compiler is required to solve the halting problem?
08:08:07 <merijn> haasn: See, we should just program Agda :(
08:08:11 <q456y> lol...
08:08:15 <haasn> Maybe this works in Agda, not in Haskell though
08:08:15 <q456y> getting too complex
08:08:22 <q456y> i'll stop worrying about it
08:08:24 <merijn> q456y: Right, back to the topic at hand
08:09:01 <haasn> merijn: even better question: what happens if I write Num b => Num (a -> b) ?
08:09:12 <merijn> q456y: As I said, the compiler knows every single constructor that can possibly exist. Therefore assigning each a unique id and comparing constructors by comparing id's is trivial. This does not require an '==' instance
08:09:21 <haasn> and then pattern match on a numeric literal at this type?
08:09:45 <merijn> q456y: And this pattern matching can be done even on types that are not comparable for equality.
08:10:07 <merijn> q456y: Anyway as haasn points out, numeric literals work differently because they're a bit special
08:10:14 <haasn> (there are, of course, other implementations that require no IDs or equality checking)
08:10:26 <haasn> (eg. church encoding into the lambda calculus)
08:10:45 <merijn> There's even really ugly languages that compare constructors by string comparison of their names :)
08:10:59 <q456y> merijn: so basically, it's not really using ==. it knows all the constructors for everything, such as   2  65  2342   342.432, etc.
08:10:59 <haasn> it's just a fundamental thing; the ability to pattern match on constructors is built into Haskell the way the ability to call a method is built into C
08:11:21 <merijn> q456y: Like I said, that's one possible implementation, but there are others
08:11:27 <haasn> It could be that method calling is implemented with call stacks and instruction pointers internally, we do not know this from the point of view of the language
08:11:30 * hackagebot puzzle-draw-cmdline 0.1.0.3 - Creating graphics for pencil puzzles, command line tools.  http://hackage.haskell.org/package/puzzle-draw-cmdline-0.1.0.3 (vollmert)
08:11:31 <q456y> merijn: ok
08:11:38 <q456y> merijn: others could well use ==
08:11:40 <q456y> who knows
08:11:50 <yoeight> Is there a cross plarform way to detect the system language during runtime
08:11:54 <yoeight> ?
08:11:56 <haasn> q456y: When pattern matching against a numeric literal it will with certainty use the actual == function, though
08:12:07 <merijn> yoeight: Query the locale, but that may not be portable to Windows
08:12:13 <haasn> Again, this is a special case for numeric literals (and string literals with OverloadedStrings and list literals with OverloadedLists)
08:12:28 <haasn> merijn: I could not find a locale package on Hackage :(
08:12:45 <merijn> Should be trivial to just call the C locale functions, though
08:12:45 <yoeight> hassn: old-locale
08:12:48 <geekosaur> for hysterical raisins it's old-locale
08:12:55 <haasn> yoeight: only includes time formatting
08:13:08 <haasn> (and date)
08:13:17 <yoeight> hassn:  I know that why I'm asking :-)
08:13:18 <haasn> Look at the sad export list: http://hackage.haskell.org/package/old-locale-1.0.0.6/docs/System-Locale.html
08:13:29 <yoeight> gge
08:13:37 <q456y> Ok, thanks all. Some food for thought
08:13:49 <yoeight> geekosaur: my program is cross platform
08:14:29 <geekosaur> yeh, as already mentioned, there's nothing cross platform. I don't even know how you'd check on Windows
08:14:32 <yoeight> geekosaur: I agree but I'd like to know if there's already something done elsewhere
08:15:03 <magicman> @type foldr map
08:15:04 <lambdabot> [a] -> [a -> a] -> [a]
08:15:09 <haasn> q456y: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
08:15:10 <yoeight> geekosaur: I know how but it make distribution a mess
08:16:16 <q456y> haasn: i'll stick to lyah for now :)
08:16:36 <yoeight> thanks anyway guys
08:17:43 <haasn> q456y: there's just one formal rule I'd like to point out
08:17:45 <haasn> (h)  case v of { k -> e; _ -> e′ } = if (v==k) then e else e′
08:17:47 <haasn>  where k is a numeric, character, or string literal
08:18:35 <q456y> interesting
08:18:51 <q456y> so it indeed uses == for numeric, char, string
08:22:05 <haasn> indeed, I thought it actually pattern matches against the list literals in the usual style for strings, that's new to me
08:25:02 <merijn> haasn: It can't, because string literals are using a different representation
08:25:10 <merijn> haasn: i.e. densely packed
08:25:25 <haasn> that is again an implementation detail :P
08:25:28 <merijn> That's how the OverloadedString instance for Text can actually be efficient
08:25:41 <haasn> it makes sense for OverloadedString, absolutely
08:26:23 <q456y> But having the knowledge that Num, Char, String uses == for pattern matching is hardly an "implementation detail", is it? Sounds like pretty useful information to me
08:26:37 <q456y> s/Num/numbers
08:28:01 <haasn> q456y: Yeah, it's useful at least if you're defining your own Num instance
08:28:11 <q456y> ok
08:28:12 <haasn> (Since it means you need to write an Eq instance, too, if you want to pattern match on it)
08:28:17 <haasn> (Which is no longer a superclass of Num)
08:28:25 <merijn> haasn: It is
08:28:34 <merijn> haasn: GHC is just incompatible with the report
08:28:39 <haasn> fair enough
08:28:48 <haasn> Wouldn't be the first time :)
08:29:12 <merijn> AFAIK the two only places where GHC doesn't conform to the report (not counting extensions) is the superclasses of Num and lack of recursive imports
08:29:28 <haasn> There are a lot of extremely subtle differences
08:29:33 <joelteon> recursive imports? importing yourself?
08:29:35 <haasn> Mostly stuff to do with _|_
08:29:44 <n-dolio> Mutual recursion.
08:29:45 <merijn> joelteon: A imports B, B imports A
08:29:48 <joelteon> oh
08:30:01 <joelteon> and the report says that should be possible?
08:30:04 <merijn> Yes
08:30:04 <shergill> doesn't that require those boot files or whatever
08:30:07 <n-dolio> There are some parsing differences if you read the report very strictly, too.
08:30:15 <haasn> shergill: not in the report, only in GHC and they're an ugly hack
08:30:15 <n-dolio> Unless they've been fixed.
08:30:16 <joelteon> I don't understand how that *could* be possible without hs-boot
08:30:22 <haasn> and, I believe, not capable of hacking around everything
08:30:23 <merijn> shergill: It does in GHC, but the report specifies it should work without the hack
08:30:29 <shergill> haasn: gotcha
08:30:36 <merijn> joelteon: Why not? The compiler could dynamically figure out and generate the boot files
08:30:46 <haasn> joelteon: merge them into a single “supermodule” in memory and type check both at the same time
08:30:47 <joelteon> oh ok
08:30:57 <joelteon> that's why I'm not a GHC dev
08:31:00 <merijn> There you go, two solutions :)
08:31:01 <haasn> you can, after all, trivially have every single name go into a single big module
08:31:02 <joelteon> that and several other reasons
08:31:16 <merijn> joelteon: GHC code is surprisingly readable
08:31:23 <haasn> GHC API, not so much
08:31:37 <merijn> Although I've now started twitching and am slowly losing my mind in a downward spiral
08:31:44 <merijn> But hey, can't win 'em all
08:37:07 <Walther> Hmm. Is it possible to, within a Main loop to append something to a list and then use contents of that list in a later iteration of the loop, without running into lots of pure/impure/IO problems?
08:37:24 <Walther> i.e. a global "variable" list
08:37:37 <joelteon> just use recursion and pass the list as a parameter
08:37:44 <vanila> main = loop [] where loop list = do ... and recurse with more things on the list
08:38:20 <Walther> vanila: the problem is, not everything within the main loop needs that list as input
08:38:33 <joelteon> well you don't have to use it every time
08:38:42 <joelteon> just pass it to the next iteration
08:38:43 <vanila> why is that a problem?
08:38:45 <Walther> (And yes, I'm new to haskell)
08:38:59 <deweyvm> theres no way to document constructor arguments in haddock?
08:39:12 <joelteon> deweyvm: -- ^ documentation here
08:39:42 <deweyvm> gives parse error
08:39:51 <deweyvm> i mean the individual arguments of the constructor
08:39:55 <joelteon> oh
08:39:58 <deweyvm> MyType A B C
08:40:12 <deweyvm> or in my case MyType A A B
08:40:15 <deweyvm> and i want to say which A is what
08:41:34 * hackagebot digestive-functors-aeson 1.1.7 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.7 (OliverCharles)
08:41:35 <deweyvm> arguably thats a deficiency in the design :P
08:42:19 <john_not_jenny> I'm lost! I've just created a mini-language using Attoparsec, but decided I wanted to try going a different route: Alex + Parsec.  I've completed my Alex lexer, but now I'm lost as to how to parse the tokens Alex produces.  Do I have to manually create the equivalent for my language of (oneOf 'c') except using my Token datatype (case t of (TokenType t) -> ...) ?
08:46:10 <lpsmith> is there an unsafe function to run an arbitrary IO action in STM?
08:46:45 <lpsmith> I suppose you could write  unsafeLiftIO m = return $! unsafePerformIO m
08:46:56 <lpsmith> just curious if there's a better way
08:47:19 <slashus2> In GHC.Conc there is a function called unsafeIOToSTM
08:47:36 <lpsmith> ahh, thanks slashus2
08:48:27 <lpsmith> (not that I have a specific use case in mind yet,  but I could see how it can be useful,  e.g. to run a postgres transaction inside of an STM transaction.)
08:49:13 <lpsmith> I suppose you can't really commit STM and postgres together atomically though,  which could be a problem.
08:49:55 <slashus2> The transaction may retry, which can be a problem for IO that you don't want to run more than once.
08:49:59 <q456y> http://learnyouahaskell.com/syntax-in-functions#pattern-matching
08:50:13 <q456y> Search for the text "Should a pattern match fail"
08:50:20 <q456y> It says "Should a pattern match fail, it will just move on to the next element."
08:51:01 <q456y> But when I actually try making a pattern fail, it doesn't just "move on to the next element", it gives me an error:
08:51:02 <q456y> let xs = [(1,3), (2,4), (5,6)]
08:51:03 <q456y> [a+b | (a,b,_) <- xs]
08:51:13 <q456y> So is the book wrong or did I understand it incorrectly?
08:51:31 <n-dolio> That's not even type correct.
08:51:44 <lpsmith> slashus2, right, but you can always retry the postgres transaction too
08:52:00 <n-dolio> It's talking about failing matches for multi-constructor data types.
08:52:18 <n-dolio> Not about matches that would 'fail' because the type is wrong.
08:52:39 <q456y> n-dolio: Okay, but the example provided is a catch-all pattern so it will never skip, correct?
08:52:44 <q456y> only if you'd have like (2,b)
08:52:46 <q456y> or whatever
08:52:50 <q456y> then it could skip
08:53:24 <n-dolio> Yeah, that would work.
08:53:56 <n-dolio> > let xs = [(1,3), (2,4), (5,6)] in [ b | (2, b) <- xs ]
08:53:58 <lambdabot>  [4]
08:54:02 <Walther> Hmpf. What is the *easiest* way to, in a main loop that does a lot of things, in one of the function calls, to append stuff to a "log" list, call a function with that log as a parameter, continue to some other stuff within the loop, at other part get more stuff to append to a log, etc
08:54:10 <Walther> because there are no global variables
08:54:16 <q456y> ok
08:54:19 <q456y> thanks
08:54:57 <joneshf-laptop> Walther, Writer?
08:55:24 <Walther> joneshf-laptop: it doesn't need to be a file explicitly, it could be just in-memory
08:55:37 <joneshf-laptop> Walther, correct
08:55:48 <quchen> Writer has nothing to do with files.
08:56:11 <Walther> Neat. Aaaaand a short example on how to use it?
08:59:07 <joneshf-laptop> Walther, i usually like Adit's explanations: http://adit.io/posts/2013-06-10-three-useful-monads.html
09:00:01 <joneshf-laptop> the mtl packages gives some fairly intuitively sounding names http://hackage.haskell.org/package/mtl-2.0.1.0/docs/Control-Monad-Writer-Lazy.html
09:00:48 <fragamus> guys I need  some help with pipes
09:01:48 <fragamus> I have an infinite list in hand, and I want to suck values out of it and maintain some state where the values get "paired up"
09:02:09 <Walther> joneshf-laptop: This is quite complicated for a beginner ._.
09:02:44 <fragamus> so sometimes the value will not have a match (until later when it's match shows up)
09:02:56 <Walther> I just simply want to append data that i get from a server to an "input" list, and e.g. send the server some messages that are based on the newest arrived message, or last three messages, etc
09:03:41 <joneshf-laptop> Walther, sure, it's usually the type signatures that mess with people. I know that's wht threw mine (and still does)
09:04:05 <joneshf-laptop> Walther, but basically, that's what `tell` does
09:04:07 <joneshf-laptop> :t tell
09:04:09 <lambdabot> MonadWriter w m => w -> m ()
09:04:58 <joneshf-laptop> you give `tell` the data you want to append to the list, and it keeps track of that
09:06:48 <Walther> joneshf-laptop: I'm still rather lost. What do I actually need to have in the code, so that I can write server messages to a log and read from the log when needed? As compared to, say, "putStrLn | show carPositions" which is currently in my code, printing all received messages to stdout
09:06:50 <quchen> fragamus: Sucking elements out of lists is done using `each`. For the state part you can stack pipes onto a State, or give more detailed information.
09:07:09 <Peaker> having concurrent code with lots of async exception throwing going on is very dangerous due to the partial-mask of the bracket finalizer
09:07:53 <quchen> Peaker: As long as your finalizers don't block you should be fine though, no?
09:09:02 <quchen> From what I understand the release is masked as well, the only thing that breaks it is if the release blocks, at which point the mask becomes brittle
09:09:02 <jle`> I'm not sure that you can access what you have already logged using Writer
09:09:07 <jle`> you might need State for that
09:09:23 <fragamus> well, here's a canonical example (simplified way way super much): my infinite list has integers, each unique in no particular order…
09:09:24 <jle`> although admittedly there is nothing about Writer that would inherently prohibit it, I don't think
09:09:32 <joneshf-laptop> ah, yeah
09:09:45 <quchen> You can use the Writer API functions to get the logs out.
09:09:46 <joneshf-laptop> it'd be easier with State if you wanted to periodically peek into there
09:09:47 <quchen> :t listen
09:09:48 <lambdabot> MonadWriter w m => m a -> m (a, w)
09:09:56 <fragamus> each odd number has a mate which is one less than it
09:10:03 <jle`> quchen: you can only do that with a standalone m a, right?
09:10:20 <jle`> you can't access the underlying log of the current monadic chain?
09:10:21 <quchen> What's a "standalone" m a?
09:10:26 <quchen> Oh.
09:10:33 <fragamus> the numbers get sucked using each...
09:10:39 <quchen> Something like "logSoFar"? Hm. Probably not, sounds very staty.
09:10:48 <jle`> > tell ["hello"] >> someFunctionToGetHello
09:10:50 <lambdabot>  Not in scope: ‘someFunctionToGetHello’
09:11:05 <fragamus> sometimes a number finds its mate, and they are both yielded
09:11:15 <jle`> yeah, it'd be something for state, but i don't think it is inherently a property of Writer that it couldn't exist
09:11:19 <jle`> it just isn't offered in the API
09:11:40 <jle`> well i guess you could write your own
09:11:48 <fragamus> but sometimes the mate is not present, so the number is remembered for future pairing
09:11:52 <jle`> wait
09:11:53 <jle`> no, you can't
09:11:58 <jle`> it is inherently against Writer v.v
09:12:15 <Walther> ._.
09:12:34 <jle`> Walther: is there a part of the adit article that you don't understand in particular?
09:12:39 <quchen> You can also use an IORef if you're in IO, of course.
09:12:41 <jle`> Walther: how much of Haskell do you know?
09:12:47 <jle`> have you finished, say, LYAH?
09:13:21 <Walther> jle`: I'm very much taking my first steps. I've read most of LYAH a couple times, but especially IO stuff and (advanced) monad stuff get me confused
09:13:57 <quchen> fragamus: So it's like when you're playing Memory, looking at one card at a time, and picking the partner card as soon as you find a pairing?
09:14:07 <Walther> State monad is probably what I should be looking at.
09:14:12 <fragamus> yes
09:14:38 <jle`> Walther: State monad would probably suit you for this specific case
09:14:49 <jle`> but
09:15:07 <jle`> hm
09:15:29 <jle`> is your entire thing in IO?
09:15:49 <vanila> Walther: I asked earlier: why is that a problem?
09:16:14 <Walther> vanila: what is?
09:16:26 <vanila> <Walther> vanila: the problem is, not everything within the main loop needs that list as input
09:17:49 <Walther> vanila: So i have no idea how to have recursion for the whole main loop while still not needing the list for the entire loop / all the functions within. Also my usecase resembles more like iteration instead of recursion, as there will be messages received from server, and I need to respond based on that message (and other previous messages)
09:18:07 <quchen> I would probably handwrite that sort of pipe, fragamus, like http://lpaste.net/102780
09:18:21 <fragamus> nifty
09:18:32 <njsg> is there any kind of "haskell for lispers" page/book/text?
09:18:37 <vanila> Walther, would it work like this? main = loop [] where loop list = do ...
09:19:17 <Walther> vanila: no idea
09:20:13 <fragamus> quchen: actually my list is not infinite
09:20:34 <quchen> fragamus: Delete the 'forever' in my code, that's nonsense. But apart from that it should work.
09:20:47 <quchen> Pipes doesn't really care whether your list is finite or not.
09:20:55 <fragamus> that's awesome
09:21:19 <quchen> Your memory does care though, so if you're trying to build a Set containing all Integers you'll have a bad time :-)
09:21:27 <fragamus> lol
09:21:46 <fragamus> my problem is way way more complex
09:21:55 <jle`> i care
09:21:56 <fragamus> but less infinte
09:22:11 <ion> >a bad time
09:22:14 <jle`> infinite / 2
09:22:15 <quchen> jle`: Luckily, you're not a streaming library.
09:22:18 <ion> Also a bad memory
09:22:40 <jle`> quchen: one day when i am a real boy :)
09:22:51 <fizbin> Has anyone ever had this problem? I have two functions defined at the top level of my module. They're both in the export list of this module. When I modify the first of those to refer to the second one, I get a compilation error: "Not in scope: `secondSymbolName'"
09:23:03 <quchen> ion: You don't actually need infinite memory, you just need arbitrarily much. If you can hot-plug new swap drives faster than your OS can allocate, you can create the Set of all Integers. :-D
09:23:18 <joneshf-laptop> Walther, your best bet is to try and tackle `State` it might seem daunting at first, but check out Adit's blog post there, ask questions here, etc.
09:23:35 <quchen> fizbin: Paste the code
09:23:47 <joneshf-laptop> Walther, it will help you understand monads better, help you become more well versed in haskell, and make the code much cleaner and maintainable
09:24:04 <ion> quchen: I’d call that a bad space usage. ;-)
09:24:32 <joneshf-laptop> Walther, if there's something in particular about that post that you don't get (no matter how trivial), feel free to ask
09:24:58 <fizbin> quchen: Yeah, no; it's proprietary. I'll try to reduce it to a paste-able test case then...
09:24:58 <Walther> Thanks for the support. Looking at IORef atm, as it was suggested elsewhere as potentially more noob-friendly
09:25:07 <joneshf-laptop> Walther, most folks here don't look down on others if the question might seem trivial (as opposed to some other communities)
09:25:19 <Walther> Nod, that I have experienced, <3 this channel
09:25:24 <fizbin> quchen: I was just hoping someone knew off the top of their heads "Oh, that's because <STUFF>"
09:25:25 <jakex> Walther this may or may not be helpful. http://lpaste.net/102781
09:26:39 * hackagebot diagrams-haddock 0.2.2.7 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.7 (BrentYorgey)
09:27:06 <jle`> Walther: i also wrote a short State tutorial myself (http://u.jle.im/1m7MXtl) if you are bored ever
09:33:28 <BoR0> I have a function executeQuery that returns IO [[SqlValue]] as a result. I have another function that does getStuffById id = executeQuery id. but I want getStuffById to return something other instead of IO (i.e. Maybe String), how is this achievable?
09:34:01 <BoR0> or should I end up with something like IO (Maybe String)
09:35:55 <quchen> What happens in IO stays in IO.
09:36:21 <BoR0> so I need IO (Maybe String) ? or does it not make much sense to have such a function
09:36:34 <quchen> It makes a lot of sense to have such a function.
09:36:39 <BoR0> great!
09:36:42 <ion> Note that you can have [[SqlValue]] -> Maybe String and use fmap to apply that to the result of an IO [[SqlValue]]
09:37:09 <jle`> it is an IO action that returns a Maybe String
09:37:15 <jle`> makes perfect sense
09:37:20 <quchen> BoR0: IO = can access the database. Maybe = there could be a result, or not. String = The result is a String.
09:37:34 <quchen> So together, it means you're accessing a database and maybe you get a String out of it.
09:37:39 <BoR0> so I'm on the right way! great. ion, I'll try what you suggested
09:38:18 <fizbin> quchen: http://lpaste.net/102783
09:38:40 <vektor> "No instance for (Read ZonedTime) arusing from the 'deriving' clause of a data type declaration." - Am I getting this right? Does ghci think ZonedTime is no instance of Read?
09:38:51 <fizbin> Or, rather, anyone. I can't figure out why http://lpaste.net/102783 won't compile. The error message is there in a comment on line 38.
09:39:10 <quchen> vektor: Yes, that's what it sounds like.
09:39:43 <ion> fizbin: I haven’t studied *why* GHC works like this, but the problem seems to be “it’s on the other side of a Template Haskell expression”.
09:40:04 <fizbin> ion: Wait, what?
09:40:18 <fizbin> Seriously? That's.... That's messed up, is what that is.
09:40:56 <quchen> Oh wow, I haven't even seen the TH part.
09:41:19 <fizbin> ion: Does a TH expression form a 2-way barrier? That is, could I refer to optimizeStatements from optOtherThing ?
09:43:21 <ion> fizbin: I don’t remember.
09:44:56 <srhb> fizbin: http://stackoverflow.com/questions/20876147/haskell-template-haskell-and-the-scope
09:45:25 <vektor> quchen: according to the docs, that shouldn't be the case....?
09:46:00 <srhb> vektor: Maybe you are not importing the instances?
09:46:15 <vektor> where would they be?
09:46:16 <srhb> Someone might be doing some weird stuff with their own ZonedTime constructor
09:46:26 <srhb> vektor: Where did you get ZonedTime from?
09:46:36 <quchen> Maybe the ZonedTime instance is an orphan, defined in another module you're not importing.
09:46:45 <srhb> Indeed
09:46:46 <vektor> Data.Time.LocalTimew
09:46:51 <vektor> *LocalTime
09:47:04 <srhb> vektor: Hm, no, the instances are there.
09:47:15 <srhb> vektor: Time to show some code if you didn't already?
09:47:45 <vektor> import Data.Time.LocalTime
09:47:48 <quchen> The LocalTime module defines no Read instance.
09:48:10 <quchen> There are a few orphans in the library, I recommend you import Data.Time as a whole, and not the submodules individually.
09:48:10 <vektor> data Event = Event {... created :: ZonedTime, ...}
09:48:27 <vektor> deriving (Show, Read)
09:48:36 <vektor> is basically what will cause the behaviour on my end.
09:48:59 <quchen> Add "import Data.Time ()" to your import list and see whether the error persists.
09:49:02 <vektor> full paste here: http://lpaste.net/102784
09:49:23 <vektor> import Data.Time () imports all modules of that namespace?
09:49:28 <albeit> How can I filter over a Data.Array? I was something like "filter (\(k,v) -> k==1) (array (1,2) [(1,'a'), (2,'b')])", but it returns a type error.
09:49:38 <quchen> No, it imports nothing except instances.
09:49:51 <quchen> It's the same as "import Data.Time hiding EVERYTHING" :-)
09:50:10 <vektor> lol
09:50:13 <vektor> well, it worked
09:51:10 <Walther> Does writeIORef overwrite the existing IORef or append it?
09:51:20 <quchen> Overwrite.
09:51:32 <BoR0> quchen: what you said, "what happens in IO stays in IO". does the same work for any monad? for instance if I have (Maybe Int) and I want to "convert" it to (SomethingElse Int)
09:51:37 <quchen> albeit: Array has a pretty small API. What kind of container do you need? Vector is often a better option.
09:51:41 <joelteon> albeit: I'm not sure you can filter an Array liyke that
09:51:42 <dario> Walther: it's like pointer assignment in C/C++
09:51:48 <joelteon> like8
09:51:50 <joelteon> *
09:52:21 <albeit> I'm trying to filter the results from a dynamic programming problem where I used to a Data.Array as lazy evaluator of intermediate results...
09:52:25 <quchen> BoR0: For some Monads, there are "take value out" functions. For Maybe, there's 'maybe' or 'fromMaybe'. State has runState, Writer has runWriter. But there is no "runIO :: IO a -> a".
09:52:52 <BoR0> quchen: aha, I understand. so not every Monad can have take value of, and IO is such example
09:53:45 <albeit> Is there any way to get a subset of a Data.Array?
09:55:02 <joelteon> albeit: I think Arrays are a lot like C arrays
09:55:06 <quchen> BoR0: Yes. Maybe is quite clearly a container type, as is List. But the "take value out of" analogy begins to break down when you consider Reader and State, where you would be "taking values out of functions". It gets even worse for other monads.
09:55:10 <joelteon> like quchen said, you might want to try Vector
09:55:18 <srhb> albeit: Only by accessing elements individually and creating a new array. Sounds like your should use a different data type
09:55:25 <monochrom> even State, there is no take out per se, until you supply an initial value first
09:55:29 <quchen> BoR0: So the more accurate way of saying it would be "there is no general function 'Monad m => m a -> a'".
09:55:38 <BoR0> gotcha. thanks!
09:56:34 <srhb> albeit: Particularly Vector, which was already recommended.
09:57:25 <albeit> Okay, thanks. Is there a reason why Data.Array is used in a lot of dynamic programming examples for memoization instead of other stuctures?
09:57:36 <quchen> I sometimes combine Ix and Vector manually if I need multidimensional data.
09:58:07 <quchen> albeit: Maybe they're old. I think Array predates Vector.
09:58:34 <albeit> Ah, the Data.Array I'm trying to filter is 3D, and I only want the values where the third dimension is equal to some value
09:58:37 <quchen> For everything I've done so far, Array is like Vector with the Ix typeclass baked in, but a much worse API in general.
09:58:44 <geekosaur> yes, Vector is actually fairly young and a lot of the memoization stuff was written before it existed
09:58:50 <Walther> Is there a way to check if an ioref exists? Like, "if positionLog doesn't exist, let templog = newIORef [] else foo"
09:59:01 <JakeE> Is there a complete combinator basis for system F? what about system F-omega?
09:59:06 <flebron> The concepts of DP should translate transparently between Array and Vector.
09:59:42 <geekosaur> Walther, how could it not exist? remember that you can't make a mutable reference (except by using newIORef)...
10:00:00 <geekosaur> maybe what you want is to create it with a Maybe type, initialized to Nothing
10:00:01 <quchen> Walther: You can't reference something that doesn't exist. In order to call a function "exists ioRef :: IORef a -> Bool" you have to specify an existing IORef.
10:00:10 <quchen> In other words, "exists ioRef = True" :-þ
10:00:11 <shergill> to anyone in montreal: if you're interested in typed edsl's i'll be presenting oleg and ken shan's paper on final tagless interpreters at the montreal haskell meetup next month
10:00:22 <albeit> Okay, I'll check out Vector. Some quick googling showed some people recommended repa for multi-dimensional arrays. Anybody have experience with it / recommend it?
10:00:23 <merijn> quchen: "exists undefined" :p
10:00:30 <prophile> ahem
10:00:34 <monochrom> it is interesting how the container intuition is tautological and therefore informationless. you look at Maybe, [] being containers. you may even argue that R->A is a container of A, and I would even agree. then you extrapolate that every Monad is a container. ah, but you're only referring to examples of the form "newtype MyMonad a = Ctor (some container type here)". container types are containers, of course.
10:00:35 <prophile> ARGH, CABAL
10:00:37 <prophile> that is all
10:00:47 <quchen> merijn: That's True, because 'undefiend' is defined.
10:01:01 <Walther> quchen: geekosaur: I'm getting "not in scope" if I define it earlier in main loop and try tro read or write to the ioref within another function. However, if I create the ioref within the function, it would reset every single time >_>
10:01:11 <Walther> I just want a mutable list that I can append and read from
10:01:13 <merijn> Walther: Well, is it in scope?
10:01:21 <quchen> Walther: Pass the IORef as a parameter to the "another function"
10:01:33 <merijn> Walther: IORef's are not magically global, they obey scoping rules like everything else
10:01:34 <geekosaur> no, what you want is a global variable, which means you're not thinking in Haskell
10:01:54 <srhb> Readear monad + IORef = global scope (ish)!
10:01:56 <flebron> albeit: Repa will be useful if you're doing parallel stuff.
10:01:56 <geekosaur> if you need it in multiple places, you need to pass it around, either explicitly or via a monad that carries it for you (e.g. State)
10:02:04 <geekosaur> or StateT IO in this case
10:02:17 <srhb> Why would you want StateT for an IORef?
10:02:17 <merijn> srhb: Naah, unsafePerformIO + NOINLINE abuse = global scope (ish) :p
10:02:23 <srhb> merijn: :|
10:02:36 <merijn> srhb: I'm a vile person :)
10:02:37 <quchen> merijn: ish?
10:02:40 <flebron> For example, in bottom-up DP you could traverse an entire row in parallel, updating that row at once.
10:02:47 <geekosaur> well, ReaderT IO
10:03:11 <Walther> geekosaur: thing is, i'm getting messages from a server, and I need to log those. Then I need to send response messages based on last message, or last n messages, or whatever. So essentially, I need to be able to read and write to a global mutable list
10:03:18 <merijn> geekosaur: Why bother with "ReaderT IO"? Just do "Reader r (IO a)"
10:03:20 <srhb> Walther: But it sounds like you might not even want an IORef
10:03:25 <srhb> Walther: No, you don't need that.
10:03:32 <Walther> So far I've been pointed to State and Writer, and both have seemed awfully complicated
10:03:36 <merijn> Walther: You can just pass IORef as an argument to your server and client?
10:03:43 <srhb> Walther: They're not and they're probably the right solution.
10:04:10 <srhb> Walther: If you try to shoehorn the idea of global mutable variables into Haskell, you're going to have a bad time. :)
10:04:19 <srhb> You should try to do it right instead, even if that takes some relearning.
10:04:22 <geekosaur> they're "complicated" if you want to force Haskell to be a strict langiuage with global mutable variables
10:04:32 <geekosaur> because it isn't
10:04:43 <albeit> felbron: Not that advanced yet, but when using repa for doing an entire row in parallel, does it do it "automatically" or do you specify that it should be performed parallel?
10:04:52 <Walther> I'm trying to log messages that I get in, and respond based on earlier messages that i can read from the log, not shoehorn mutables to haskell :|
10:04:55 <merijn> Sounds like wants "StateT [a] IO" anyway
10:05:03 <srhb> Walther: You can do that with State
10:05:12 <srhb> Or well, yes, StateT foo IO
10:05:29 <geekosaur> except that every way you are tring to do it involves a mutable global variable. You;re thinking about it wrong and calling the right way too complicated
10:05:58 <srhb> Walther: But if you want to follow through on your IORef (don't) all you need is main = do { a <- newIORef ...; foo a }; foo ref = do ... ref ...
10:06:22 <savanni> albeit: I'm starting in with Repa and it seems pretty nice
10:06:26 <srhb> Walther: You should really learn to ues StateT. :)
10:06:27 <Walther> geekosaur: Feel free to try and explain me how to achieve the end result i need in the more "correct" way
10:06:38 <geekosaur> have you been reading what others have been telling you?
10:06:39 <savanni> albeit: I'm working with imaging data, and that's inherently multidimensional, and I like how Repa seems to manage that.
10:06:41 <srhb> Walther: Well, you fill your state with the stuff you get from the server
10:06:47 <srhb> Walther: Then all your functions operate on that state
10:06:56 <srhb> Walther: By using "get".
10:07:21 <albeit> Okay great I'll check it out.
10:10:41 <savanni> Although, does Repa have an ST or some other destructive update interface?  I'm not sure that I will need it, but...
10:12:11 <Walther> srhb: I'm confused; that's very abstract
10:12:21 <srhb> Walther: I've written you an example
10:12:52 <srhb> Walther: http://lpaste.net/102786
10:13:22 <srhb> Walther: Try to see if you get the gist of it, then ask about it.
10:14:06 <alpounet> savanni: nope, not AFAIK
10:15:26 <njsg> srhb: so evalStateT needs to be used for the whole thing to work?
10:15:26 <Walther> srhb: I'm sorry for being a bit slow, but I really have a hard time comprehending any of this.
10:15:48 <srhb> njsg: evalStateT or execStateT or runStateT -- depending on what you need
10:16:39 <srhb> Walther: Take it line by line. in foo, we read a line from stdin. If that line is equal to "q", we quit. Otherwise, we append the line to the state and run foo again
10:17:06 <srhb> Walther: In bar, we get the state (the list of Strings collected in foo), then print that we're quitting and then print all the collected strings
10:17:08 <savanni> alpounet: then I'll ask here or on Stack Overflow if I run into a real case in which that gets in my way.  I'm hard pressed to think of one right now, though.
10:17:13 <srhb> Walther: I think that's pretty close to your logging example, no?
10:17:54 <srhb> njsg: Consider foo and bar actions in the StateT monad, we need to execute them somehow, and evalStateT døs that.
10:18:04 <srhb> does*
10:18:31 <Wizek__> Good morning!
10:20:13 <srhb> Wizek: o/
10:20:44 <alpounet> savanni: what's your use case? repa can be really really fast, so hopefully you won't need to drop down to ST
10:20:57 <Wizek> Is there a Function typeclass? And why isn't there?
10:21:17 <srhb> Wizek: What would it do?
10:22:04 <Wizek> srhb: It could implement the isFunction function as a start :)
10:22:06 <ion> Category? :-P
10:22:23 <ion> isFunction :: (a -> b) -> Bool; isFunction = const True
10:22:29 <srhb> Wizek: But that's already in the types.
10:22:40 <savanni> alpounet: before I discovered repa I was parsing images into an unboxed vector.  I wasn't able to figure out how to express that as a generator, so I needed in-place destructive updates to get up to a good speed.
10:22:44 <srhb> Wizek: There's no reason to overload since there's only one constructor for function types
10:22:50 <srhb> Wizek: Namely (->_
10:22:52 <srhb> er
10:22:54 <savanni> For that particular use case, though, repa-devil is already going to have it solved, so I can read that code.
10:22:54 <srhb> (->)
10:23:03 <njsg> srhb: ok, sorry for the stupid question, but I'm so new to this that I'm having trouble with the declarations. does it mean that foo returns something of the type StateT (which in turn deals with strings) and does I/O?
10:23:13 <savanni> (in fact, I already know I'm going to have to add to that code, but I don't have to worry about it now)
10:23:16 <srhb> njsg: Not stupid at all. :)
10:23:18 <Wizek> srhb: So if I give you a variable a, you can return a bool based on wheter it was a function or not?
10:23:29 <srhb> Wizek: Yes, see ions answer
10:23:34 <alpounet> savanni: have you seen JuicyPixels? maybe that will be enough
10:23:50 <savanni> Didn't discover JuicyPixels until after I'd started to retool to Repa.
10:23:50 <alpounet> it performs decently
10:23:57 <srhb> njsg: I think of values of the type StateT a IO () as recipes for stateful, IO-y actions
10:24:07 <savanni> I'll know before the day is over, though, how fast repa loads files.
10:24:11 <alpounet> savanni: i think there even is a JuicyPixels-repa package or something
10:24:27 <njsg> srhb: so the [String] actually means "list of strings"?
10:24:32 <alpounet> savanni: http://hackage.haskell.org/package/JuicyPixels-repa
10:24:38 <srhb> njsg: Yes, and it's the type of the "internal state"
10:24:39 <Wizek> ion: Can that be made to return False otherwise? :)
10:24:56 <srhb> njsg: Which we can manipulate with get, put and modify
10:25:01 <njsg> srhb: would it be mandatory to specify the "a" or could I just go with StateT IO?
10:25:02 <alpounet> savanni: i don't think you will have a lot of these stuffs to rewrite, or maybe even nothing at all. worst case, just patches if you need more functions or smth
10:25:16 <srhb> njsg: That would be an incomplete type, StateT takes three type arguments
10:25:24 <alpounet> savanni: i even added mmap'ing in JuicyPixels at some point
10:25:35 <srhb> njsg: You could conceivably leave the type of the state polymorphic for some applications, but I think that will be pretty rare
10:25:47 <srhb> njsg: (That is, how would you know how to operate on your state if you don't know its type?)
10:25:52 <njsg> srhb: ah, () is haskell for nil, then?
10:26:01 <srhb> njsg: Or irrelevant type.
10:26:08 <srhb> njsg: nil is [] in Haskell parlance
10:26:23 <alpounet> savanni: https://github.com/Twinside/Juicy.Pixels/blob/master/JuicyPixels.cabal#L32 <- when enabled, it really provides a smoking fast loading
10:26:58 <srhb> njsg: Do you have the example open still?
10:27:05 <njsg> srhb: being also synonymous with empty list?
10:27:09 <srhb> njsg: No, not at all
10:27:10 <njsg> srhb: yes, still open
10:27:31 <srhb> njsg: If you add a last line in bar, return . length $ st -- the type of bar would be StateT [String] IO Int
10:27:46 <srhb> njsg: Because now evaluating the entire stateful computation returns an IO Int
10:28:06 <srhb> That is, an int we produced from our stateful computations and from IO (the length depends on how many lines we read)
10:28:15 <savanni> alpounet: Load time is no longer a problem, but I'll look into JuicyPixels for blitting data to a GTK.  Looks like you've already done some of that with OpenGL.
10:28:54 <alpounet> savanni: i've done something that lets one load JuicyPixels 'Picture's  in gloss
10:29:03 <njsg> srhb: but wait, the example has no bar
10:29:05 <alpounet> it's just converting to the 'bmp' package's format, used by gloss
10:29:10 <njsg> srhb: just foo and quit
10:29:13 <srhb> njsg: Sorry, I meant quit
10:29:25 <srhb> That's what I get from being pedagogical where I wouldn't normally be. :-)
10:29:32 <njsg> srhb: ah, your previous comment about foo and bar in the monad makes more sense now :-)
10:29:39 <srhb> Derp, so sorry.
10:30:22 <njsg> no worries
10:30:29 <srhb> njsg: So with that final line added, the type of quit is StateT [String] IO Int. [String] is the type of the internal state and IO Int is the type of our final value
10:30:55 <njsg> I think I've seen some declarations with "->" in them, what's the difference?
10:31:05 <srhb> njsg: They take an argument that they use
10:31:20 <srhb> njsg: Let's make the example even more absurd
10:32:48 <srhb> njsg: http://lpaste.net/102786 -- see annotation
10:33:00 <njsg> side question, if I want to keep the state, the whole computation that is intended to use the same state must be encapsulated in evalStateT?
10:33:08 <srhb> njsg: That's right
10:33:26 <srhb> njsg: Which is no different than all your IO stuff being somehow encapsulated in main
10:34:11 <njsg> but then the entire chain of functions I call has to be of type StateT, or can I use get in a function which is not StateT?
10:34:14 <savanni> Well, except that you could save that state off to feed into a later StateT computation.
10:34:18 <njsg> as far as it was called from some StateT function
10:34:33 <srhb> njsg: If a function døs not need the state, it does not need to be in State of any kind
10:34:39 <srhb> njsg: Notice that I use length in quit
10:34:51 <srhb> njsg: Surely that doesn't have a StateT type
10:35:26 <srhb> njsg: But all parts that need to get the state will have State in their type, yes.
10:35:32 <srhb> (That's rather the beauty of it)
10:35:35 <njsg> srhb: what if foo called bar that calls quit, when quitting, would bar need to be StateT, or could it be something else as far as foo and quit are StateT?
10:36:16 <srhb> njsg: If you wanted quit to operate on the same state as foo, then bar too would need to be StateT
10:36:35 <Walther> So in the "evil" nonstrict mutable world of say, python, I could just have in the main loop "when receivemessage, log append(message)" and somewhere else "speed = difference in position of last two messages from log". State should help us get this sort of a log, but I really, even with your example open, can't figure out how
10:36:47 <srhb> njsg: I get the feeling that you think this is somehow problematic, but it's entirely unproblematic and nice. :-)
10:37:07 <njsg> srhb: nah, not problematic, I'm just trying to cover all bases before I try to use this
10:37:08 <srhb> Walther: Which part is causing you trouble?
10:37:44 <srhb> Walther: In StateT you would still have getMessage >>= put
10:37:50 <srhb> Walther: Er or rather
10:38:02 <srhb> Walther: getMessage >>= \m -> modify (m:)
10:38:05 <bernalex> njsg: good to see you are finally becoming pure of heart. :-)
10:38:10 <Walther> srhb: "which part" -> applying this to practice
10:38:14 <njsg> srhb: I am just not used to haskell at all, so really asking about stuff step by step
10:38:20 <srhb> njsg: That's fine :)
10:38:24 <njsg> bernalex: ohai
10:38:26 <srhb> njsg: Just trying to not scare you off :)
10:38:38 <srhb> Walther: given a function getMessage which is a lifted IO Message
10:38:54 <Walther> And also what njsg said, we're both new to haskell (and if it weren't already obvious, sitting next to each other and trying to tackle the same problem)
10:39:03 <srhb> Walther: OK :)
10:39:17 <bernalex> njsg: have you read LYAH? it's sort of the holy grail of haskell tutorials.
10:39:26 <srhb> Walther: No need for apologies I'm just trying to figure out which part is confusing you really. "in practice" doesn't help me much because my example is in fact working code
10:39:47 <srhb> Walther: In fact, in order for my program to become your program, you would only have to replace getLine with getMessage
10:40:01 <srhb> fsvo getMessage :: IO Message
10:40:07 <monochrom> No! My tutorials are the holy grail :)
10:41:35 <njsg> bernalex: the book has been suggested to me, our local CS department library has a book on haskell
10:41:47 <bernalex> njsg: lyah is gratis
10:41:50 <srhb> njsg: LYAH really is great, my recommendation for sure
10:41:53 <njsg> bernalex: I'd not mind something that is aimed at people who know lisp
10:42:15 <bernalex> njsg: lyah isn't. but that just means you skim the parts that are familiar and focus on the parts that are different.
10:42:31 <srhb> The main focus is types anyway, which is the relevant bit.
10:44:04 <bernalex> njsg: I don't know any, actually. all the lisp guys I talk to insist that learning haskell is pointless... because lisp.
10:44:48 <srhb> If I were forced to work on the JVM I'd probably go all lispy. :P
10:45:06 <savanni> I once programmed in Lisp.  I eventually returned to Haskell.
10:45:27 <mmachenry1> bernalex: I'm a lisp guy who would encourage you to learn Haskell :)
10:45:46 <catalyst> I'd rather know both
10:46:02 <seanparsons> Oddly I think learning lisp is pointless because Haskell.
10:46:02 <njsg> srhb: what does make foo recursive?
10:46:10 <srhb> njsg: It calls itself in the else part
10:46:16 <srhb> njsg: After modifying the state
10:46:34 <njsg> hmm, what does ">>" do?
10:46:35 <monochrom> learn both haskell and scheme. lisp is not functional enough, and too many strange corners
10:46:36 <mmachenry1> seanparsons: I think learning Lisp is very valuable even if you know Haskell
10:46:39 <Ywen> Is there a way to make GHC check instances of a class in some order? (so that I may avoid OverlappingInstances)
10:46:39 <srhb> njsg: Sequences too actions
10:46:48 <srhb> njsg: It's the same as a newline in a do block
10:46:52 <njsg> ah!
10:46:54 <srhb> njsg: two*
10:47:40 <srhb> njsg: else do { modify (l:); foo }
10:47:52 <monochrom> lisp is very true to its name. the emphasis has always been on "everything is a cons cell". functional programming is an afterthought.
10:48:49 <mmachenry1> monochrom: That's definitely a common misconception.
10:48:51 <njsg> yeah, most of what I know in using lisp comes more from how it revolves around lists and lambdas, not because of functional programming
10:49:05 <njsg> it's not even like common lisp has any specific paradigm
10:49:07 <quchen> Oh yes! Let's have a discussion about what Lisp is!
10:49:08 <monochrom> the biggest value of learning lisp today is as preparation for javascript. lisp says "every name has a value binding and a function binding". javascript generalizes that.
10:50:22 <srhb> quchen: D:
10:52:31 <njsg> srhb: how do I lift something other than IO?
10:52:36 <srhb> njsg: "lift"
10:52:43 <srhb> njsg: But it needs to be in the transformer stack
10:53:06 <srhb> njsg: Right now we only have StateT and IO monads, nothing else will make sense.
10:53:50 <srhb> njsg: And because State is on top of the stack, you don't need to lift get, put, modify and friends
10:54:05 <srhb> (And because of clever tricks, you won't have to explicitly lift most other things either)
10:54:33 <Walther> srhb: Just curious, you mentioned earlier "just use getMessage instead ofgetLine" earlier, how's that work (getMessage not in scope, am I getting something wrong or...)
10:54:46 <njsg> I think srhb said liftMessage
10:54:52 <srhb> Walther: That's the hypothetical IO Message-typed value you have
10:54:57 <srhb> Walther: The one that reads a message from the server
10:55:05 <njsg> but that's not in the scope either
10:55:20 <srhb> Well no, you have to write getMessage, and then lift it (since it's an IO-typed thing)
10:55:42 <Walther> Well, we have "carPositions" that is in the current scope the newest received message itself
10:55:52 <Walther> do we need to lift that somehow or?
10:55:59 <srhb> Walther: What is its type?
10:56:24 <Walther> carPositions is [CarPosition], and CarPosition is a data type properly defined elsewhere
10:56:33 <srhb> That can't be right.
10:56:44 <Walther> json :)
10:56:47 <srhb> How would carPositions get a message from a server if it doesn't have IO in its type?
10:57:02 <srhb> Hint: It cannot.
10:57:16 <njsg> srhb: at this point, it's not a message to be received, it's the translation of the received JSON
10:57:23 <Walther> Oh, the actual receive-message/parse-message thingy is elsewhere, this is already where the message has been parsed and is just a ...uh, parsed message
10:57:27 <Walther> What njsg said.'
10:57:37 <njsg> srhb: so this is effectively a normal object, I'd suppose, dunno what's the right name for that in haskell
10:57:46 <srhb> It's not. It's a list of CarPosition
10:57:50 <njsg> but in this state, at least the way the code is right now, the IO happened before
10:58:11 <srhb> Well then I don't even understand the initial need for an IORef
10:58:13 <njsg> well, wait, haskell *is* lazy, so I don't know to which extent I am even correct
10:58:27 <srhb> It sounds like you're correct, but I no longer understand the problem you're trying to solve.
10:58:30 <njsg> srhb: I think that was one of the things Walther found when he was trying to figure out how to do it
10:58:53 <Walther> srhb: the original need is that we need a log of all messages received instead of just functionally handling the last one received as fifo
10:58:55 <njsg> srhb: a function is going to be called with different arguments and we want to keep a list of the different arguments
10:59:09 <njsg> in a way that another function can use
10:59:15 <Walther> srhb: and we need to be able to append that list on the fly, as well as read n last messages, etc
10:59:30 <srhb> Well, you can take n from a list
10:59:30 <Walther> think: we get position data, want to evaluate current speed and adjust throttle
10:59:36 <srhb> And you can append with value:list
10:59:51 <njsg> srhb: so it's possible to modify a list in-place?
10:59:58 <srhb> Yes/no
11:00:05 <srhb> Technically it's a new list, with a shared tail, probably
11:00:05 <Walther> srhb: which is the problem :P
11:00:24 <srhb> Alright, then just append to the as in my example :)
11:00:29 <srhb> to the state*
11:00:40 <njsg> srhb: but the reference, as in "variable name" in c-speak is still the same?
11:00:51 <srhb> Forget about references for now.
11:01:10 <njsg> wait, better question to ask
11:01:13 <njsg> is append destructive?
11:01:27 <vanila> in lisp?
11:01:29 <savanni> Not in a normal list.
11:01:32 <srhb> Oops, I did not mean append
11:01:34 <njsg> vanila: in haskell
11:01:39 <srhb> prepend*
11:01:43 <vanila> but haskell is purely functional
11:01:48 <vanila> so nothing is destructive
11:01:57 <ion> writeIORef
11:02:47 <srhb> njsg: The prepending bit is in the else clause
11:03:06 <BoR0> could anyone briefly explain to me what liftIO does? I had problems with calling IO function on Snap() but with liftIO it magically worked
11:03:13 <ReinH> :t liftIO
11:03:15 <lambdabot> MonadIO m => IO a -> m a
11:03:31 <BoR0> I looked at that already, so it converts IO monad to some other monad? I don't get it
11:03:33 <srhb> BoR0: It lifts an IO action into the monad on top of the stack
11:03:33 <njsg> srhb: so wait, modify is something that's not specific to StateT?
11:03:35 <ReinH> BoR0: liftIO takes an IO action and turns it into an action on some other monad, as long as that monad is a MonadIO instance.
11:03:37 <BoR0> @src liftIO
11:03:37 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:03:39 <srhb> njsg: Nono
11:03:42 <geekosaur> many useful monads are stackable on top of IO
11:03:43 <srhb> njsg: It IS specific to state
11:03:43 <pooya72> hi guys
11:03:51 <geekosaur> you often want a quick way to get at the IO at the bottom
11:03:52 <srhb> njsg: It takes a function to modify the current state with
11:03:53 <geekosaur> that's liftIO
11:04:03 <ReinH> geekosaur: but it isn't :)
11:04:07 <geekosaur> (note that IO can only be at the bottom of a stack)
11:04:09 <ReinH> it's the opposite
11:04:09 <srhb> njsg: (carpos:) would be such a function
11:04:12 <BoR0> so Snap is a MonadIO instance?
11:04:18 <srhb> njsg: ie. it would prepend a carpos to the current state
11:04:33 <ReinH> BoR0: it must be :)
11:04:38 <urbanslug> I have set up a VM to develop yesod in. The book I am reading advises I install the haskell platform but I know better. I am thinking of installing ghc and cabal through my package manager then installing the rest using cabal. Is this a good approach?
11:04:39 <geekosaur> are we talking from oppposite sides or ar you claiming it's for IOT SomeMonad?
11:04:48 <BoR0> is there a way to look at the source code of liftIO? or is it something internal
11:04:50 <ReinH> geekosaur: I'm claiming that litIO doesn't "get to the IO"
11:05:02 <ReinH> it does the opposite
11:05:06 <ReinH> :t liftIO
11:05:07 <lambdabot> MonadIO m => IO a -> m a
11:05:12 <geekosaur> it relays a function call to the IO and get s the reuslt back
11:05:17 <BoR0> @src liftIO
11:05:18 <lambdabot> Source not found. Maybe you made a typo?
11:05:18 <ReinH> no, it doesn't
11:05:34 <ReinH> it takes an IO a and turns it into a m a for some MonadIO m
11:05:45 <geekosaur> ...
11:05:54 <pooya72> I had a question about HPC. How to you get it create the test coverage data (.tix .mix) from cabal-dev? I know you can do it when you build via GHC: ghc -fhpc Run.hs --make , but how do you do it from cabal-dev?
11:05:58 <geekosaur> you are being pedantic in the "who needs to be comprehensible" sense, yes?
11:06:02 <imalsogreg> BoR0: https://hackage.haskell.org/package/snap-core-0.9.6.2/docs/Snap-Core.html#t:MonadSnap  Yep - there is a MonadIO instance for the Snap monad, and that's the source you probably want to look at - that instance.
11:06:22 <ReinH> geekosaur: I don't think I am
11:06:23 <geekosaur> whatever, listen to the pedanticism, if you do not understand it then I guess thats' intended
11:06:25 <ReinH> I think it's an important distinciton
11:06:45 <ReinH> because monad morphisms are important
11:07:32 <imalsogreg> BoR0: Here is Snap monad's liftIO implementation: https://hackage.haskell.org/package/snap-core-0.9.6.2/docs/src/Snap-Internal-Types.html#Snap
11:08:15 <ReinH> geekosaur: I think that what liftIO *actually* does is far more interesting than the hand-wavey explanation
11:08:28 <vanila> ReinH, liftIO is very much trivial
11:08:33 <ReinH> vanila: I know
11:08:36 <BoR0> what's $! do
11:08:55 <davean> if geekosaur was correct, catch would be liftable?
11:09:00 <banister> BoR0 most recent exception
11:09:13 <njsg> srhb: I think I finally understood you, yeah, just using "modify" directly now
11:09:30 <vanila> BoR0, all that liftIO does is let you easily use IO actions inside a monad transformer stack which includes IO
11:09:31 <quchen> @src $!
11:09:32 <lambdabot> f $! x = x `seq` f x
11:09:32 <srhb> njsg: If it makes more sense you can get the state, and then put the modified sense
11:09:42 <njsg> srhb: I'm having some trouble with the function declarations, what can go in there? I suppose StateT is the type of the function, not the type of the return value?
11:09:44 <srhb> njsg: do { s <- get; put (carpos:s) }
11:09:47 <BoR0> I am very confused. what should I read about? is this monad transformers?
11:09:49 <vanila> you don't need to get bogged down with things like $!
11:10:05 <Walther> srhb: But like you said earlier, this *could* potentially be doable with just a list - i just have no idea how to make that persist yet be modifiable throughout the loop
11:10:14 <srhb> njsg: Well every "line" in the do-block must have type StateT [String] IO a
11:10:27 <albeit> If I need to feed a functions return value back into that function say three times, is the best way to do this folding over a list like [0..2], where the accumulator is the initial value that is fed into the function?
11:10:31 <srhb> Walther: I'm sorry, I don't understand the problem well enough to be sure it can be.
11:10:40 <vanila> BoR0, yes, basically imagine if you created a new monad Foo which was able to do IO as well as some other things - then to use some IO action like print :: IO () you need a way to "lift" from IO to Foo
11:11:03 <srhb> Walther: For one thing I have absolutely no idea how you can have a [CarPos] anywhere if you have to communicate with the outside world in order to get a CarPos.
11:11:27 <srhb> Which is how I understood the problem initially. But now I'm starting to think there's no IO going on at all.
11:11:29 <vanila> BoR0, does that help at all?
11:11:42 <Walther> srhb: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
11:11:45 <Walther> ermmm
11:11:47 <njsg> srhb: the function where I want to add this already has different return types and input types
11:11:48 <Walther> wrong pastebuffer
11:12:01 <Walther> respond :: ServerMessage -> IO [ClientMessage]
11:12:07 <gXen> since people keep saying on hackernews how awsome and mindopening haskell is, I decided to learn it... my q: what sources to use to leanr haskell?
11:12:14 <srhb> Walther: So _you're_ the server?
11:12:19 <Walther> No.
11:12:23 <srhb> gXen: lyah
11:12:25 <srhb> @where lyah
11:12:25 <lambdabot> http://www.learnyouahaskell.com/
11:12:39 <srhb> njsg: I don't understand, sorry.
11:12:43 <BoR0> vanila: why do we need lift at all? why simply can't Foo call IO
11:12:45 <gXen> thats a clear answer :) ty
11:12:49 <monochrom> I ignore hackernews. but I am glad you want to know haskell. what srhb says.
11:13:12 <gXen> should I ignore hackernews for toher reasons it breaks my productivity?
11:13:38 <gXen> is the writer of lyah inhere?
11:13:43 <shelf> think of HN as woody allen. would you hang out with woody allen
11:13:46 <monochrom> tryhaskell.org lets you play a bit
11:14:03 <pooya72> I had a question about member:HPC. How to you get it create the test coverage data (.tix .mix) from cabal-dev? I know you can do it when you build via GHC: ghc -fhpc Run.hs --make , but how do you do it from cabal-dev?
11:14:24 <Walther> srhb: http://pastebin.com/4th93Wfd
11:14:26 <alphonse23> how is Hn like woody allen? and is that a rhetorical question?
11:14:31 <pooya72> hpc as in test coverage
11:14:32 <njsg> srhb: ghc says "add an instance declaration for (MonadState [[CarPosition]] IO)", [[CarPosition]] being what the StateT should be, I guess
11:14:36 <bernalex> gXen: not atm, apparently. he's called BONUS on Freenode.
11:14:36 <vanila> BoR0, well Foo is not IO even though it includes those functions, it's like a wrapper around it - that's why you need to use liftIO
11:15:09 <BoR0> so liftIO is like using parent's methods (in OOP) in context of where IO is the parent? or is this complete nonsense what I said
11:15:11 <gXen> yeah, i read it frequents here... I was wondering if he is a nice guy, if so, i would buy the book
11:15:20 <BoR0> (@ vanila)
11:15:27 <vanila> BoR0, yeah kind of!
11:15:30 <ReinH> BoR0: I wouldn't suggest making analogies to OOP :)
11:15:32 <srhb> njsg: Yes, you don't want to do that. What exactly are you trying to do?
11:15:33 <ReinH> BoR0: you're working in some monad
11:15:52 <ReinH> BoR0: if it's an instance of MonadIO then it is a monad transformer with IO at the base
11:16:04 <ReinH> for instance, StateT SomeState IO a
11:16:10 <ReinH> that type is your m a
11:16:17 <vanila> BoR0, if you want something to read on page 11 of http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf it goes into some detail about why liftIO is done
11:16:19 <ReinH> you have an IO action, some IO a, for instance
11:16:23 <ReinH> :t putStrLn
11:16:24 <lambdabot> String -> IO ()
11:16:30 <ReinH> er
11:16:33 <ReinH> :t putStrLn "hello"
11:16:34 <lambdabot> IO ()
11:16:37 <ReinH> in this case a is ()
11:16:43 <bernalex> BoR0: you lift a function to deal with monads. it's like promoting it.
11:16:45 <ReinH> you want to run putStrLn with *your* monad
11:16:46 <bernalex> :t lift
11:16:47 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
11:16:55 <bernalex> :t liftA
11:16:56 <lambdabot> Applicative f => (a -> b) -> f a -> f b
11:16:59 * hackagebot penny 0.32.0.8 - Extensible double-entry accounting system  http://hackage.haskell.org/package/penny-0.32.0.8 (OmariNorman)
11:17:00 <srhb> Walther: There are several issues here
11:17:13 <ReinH> which means you need to do something to putStrLn to give it the type StateT SomeState IO ()
11:17:19 <ReinH> BoR0: does that make sense?
11:17:24 <gXen> is haskell any usefull for cryptography?
11:17:45 <ReinH> gXen: yes, although there are some issues
11:17:54 <BoR0> ReinH: will putStrLn behaviour be kept, or we need to override it? do we do it just to make the return type of it to match?
11:17:54 <srhb> Walther: For one, I don't think respond does what you think it does. Running it will always yield a length-one list
11:18:05 <gXen> Reinh: which issues? are the libraries any good?
11:18:07 <tac> gXen: in theory, yes, in practice, probably not
11:18:25 <ReinH> BoR0: so we have an IO action, putStrLn "hello"
11:18:43 <vanila> ReinH, Typeclass dispatch works very similar to OO
11:18:43 <Walther> srhb: Yes indeed, which is why in "respond" is a perfect chance to append to the magical log list that we need
11:18:52 <ReinH> that's your IO a, or in this case, IO ()
11:19:01 <gXen> tac: sounds like: it is the capabilities, but not the existing libs... which sounds awsome, since I could develop some...
11:19:06 <gXen> has*
11:19:13 <ReinH> :t liftIO (putStrLn "hello)
11:19:14 <vanila> ReinH, it's purpose in haskell is allow open world assumption based programming, similar to OO classes
11:19:14 <lambdabot>     lexical error in string/character literal at end of input
11:19:19 <ReinH> :t liftIO (putStrLn "hello")
11:19:20 <lambdabot> MonadIO m => m ()
11:19:26 <njsg> srhb: the function will sometimes be called with an argument which is a list of carPosition, so [carPosition], I want to keep all [carPosition]s in a list to search later
11:19:46 <BoR0> ReinH: so it magically matches the return type putStrLn
11:19:56 <srhb> Walther, njsg: Ok
11:20:03 <ReinH> BoR0: it "magically" changes it from an IO action to an action for your monad stack
11:20:08 <ReinH> as long as it's an instance of MonadIO
11:20:10 <srhb> njsg: Remind me where this list gets created or should get created?
11:20:14 <Wizek> ion:ping :)
11:20:17 <ReinH> BoR0: but actually not magically at all
11:20:20 <Walther> srhb: that's the problem
11:20:22 <BoR0> ReinH: ok. will putStrLn behave for any MonadIO instance? or do they all override it
11:20:25 <srhb> Hehe, well you have to decide
11:20:29 <Wizek> To those who are interested: http://stackoverflow.com/questions/23103654/how-can-a-function-be-transparently-augmented-in-haskell
11:20:30 <ReinH> BoR0: that's the thing
11:20:33 <ReinH> :t liftIO
11:20:35 <lambdabot> MonadIO m => IO a -> m a
11:20:35 <Walther> srhb: we want that kind of a list, but as you don't have global variables or mutables
11:20:36 <srhb> Walther: What information do you need to generate those positions?
11:20:37 <njsg> srhb: outside of the scope of the function, some json parser hands us the list
11:20:39 <urbanslug> Does installing ghci come with runhaskell? If not how can I get runhaskell?
11:20:43 <ReinH> BoR0: liftIO CANNOT know what `a' is
11:20:50 <srhb> njsg: And the json comes from where?
11:20:52 <ReinH> BoR0: so it cannot possibly modify the a
11:20:55 <BoR0> ReinH: so every MonadIO instance has an instance of liftIO as well?
11:21:05 <njsg> srhb: we can probably change how that list is passed, but I'd prefer to start with a not-so-wide code change
11:21:07 <ReinH> BoR0: MonadIO is a typeclass that provide liftIO
11:21:10 <ReinH> *provides
11:21:12 <BoR0> got it
11:21:19 <Walther> srhb: again, from what we read in each call for function respond as the input, we want to push that into a list of received messages as a side-effect
11:21:22 <ReinH> BoR0: so your IO action is guaranteed to be exactly the same
11:21:23 <njsg> srhb: another process, over tcp
11:21:34 <ReinH> all liftIO does is move it from being an IO action to being an action in some other monad
11:21:37 <Walther> srhb: and the actual effect is the response message, of course, but it needs the side-effect of logging received messages
11:21:46 <Walther> srhb: huge thanks btw for bearing with us
11:21:51 <srhb> No worries.
11:21:52 <BoR0> ok! thank you ReinH and vanila for the help. I have some basic sense of what it does now, but I'd like to read some more into it. I'll look into LYAH to see if there is something regarding this
11:21:56 <ReinH> BoR0: each instance of MonadIO has to define liftIO to Do The Right Thing
11:22:06 <vanila> BoR0, check page11 of the PDF if you like
11:22:13 <BoR0> vanila: yeah just opened it
11:22:33 <srhb> njsg, Walther: Let me just get this straight. respond should be able to read one (new?) carposition from the tcp + parser, and have access to all the old ones, yes?
11:22:43 <ReinH> BoR0: monad morphisms, of which this is a rather trivial example, are interesting because they can be used to (e.g.) control access to effects within a stack
11:23:17 <njsg> srhb: no, respond already gets the parsed carposition
11:23:25 <sdegutis> is a string a function that returns itself?
11:23:30 <ReinH> BoR0: for instance if you have a monad transformer stack with both ReaderT and StateT, you can use a monad morphism from Reader a to your stack to guarantee that your monadic action can't access or modify state
11:23:32 <vanila> sdegutis, no it's a value
11:23:36 <sdegutis> Thanks!
11:23:38 <BoR0> ReinH: liftIO is a monad morphism, right?
11:23:42 <Walther> srhb: respond gets the newest message as input, magically given by other functions. We want to log that input message as a side-effect. Then we want some AI logic to read the log of last messages, e.g. calculate current speed, and adjust our throttle accordingly, and send a throttlemessage as the output
11:23:46 <ReinH> BoR0: in the same way, your IO a can't access any of the other parts of the monad stack.
11:23:49 <vanila> lol did i just solve a mutiple choice quiz
11:23:49 <ReinH> BoR0: yes
11:23:59 <ReinH> BoR0: the other reason that this is important is that if you have, e.g.
11:24:06 <njsg> srhb: ... or so I think, that's my idea. there may be some lazyness I don't know about
11:24:15 <Walther> Well, actually respond also gets all the other messages like Join and GameInit as you can see, but we're currently just interested in the CarPositions branch
11:24:21 <srhb> Walther, njsg: OK, I say make the sweeping change and actually use modify (newmessage:) in respond
11:24:23 <ReinH> do { liftIO (putStrLn "hello"); liftIO (putStrLn "world") }
11:24:37 <ReinH> BoR0: because of the rules for monad morphisms, you know this is equivalent to
11:24:57 <ReinH> do { liftIO (putStrLn "hello" >> putStrLn "world") }
11:25:08 <Walther> srhb: how does that help us towards the goal of keeping a list of all received carPositions?
11:25:15 <ReinH> BoR0: in other words, you can take two liftIOs in sequence and combine them
11:25:20 <srhb> Walther: Well is that not the received carPosition?
11:25:24 <njsg> srhb: sweeping change?
11:25:25 <BoR0> so >> combines lifts
11:25:34 <ReinH> BoR0: so this is why I prefer to introduce monad morphisms to explain liftIO
11:25:43 <ReinH> also it's the explanation that actually works with the type of liftIO
11:25:52 <srhb> Walther: Otherwise: Where do all new messages get handled? Then we'll do it there
11:26:14 <BoR0> ok, I'll look into "monad morphisms" and transfomers. btw, what do transformers present in that context? is it just another fancy word for morphisms?
11:26:19 <srhb> Walther: handleMessage?
11:26:26 <srhb> handleMessages*
11:26:27 <Walther> srhb: nod, but how does that require changing the logic of sending messages?
11:26:42 <srhb> Walther: If it wants access to the state, it will need to be in StateT
11:26:53 <vanila> BoR0, a monad transformer stack is how you build a new monad with the features of several others, in your case the Snap monad is a stack which includes IO
11:26:55 <srhb> Really it;s just a type change
11:26:56 <Walther> I'm *really* thinking we should be able to stick this to respond, within CarPositions
11:27:07 <ReinH> BoR0: monad transformers are a way to "stack" different monads
11:27:10 <srhb> Walther: So respond is called for each carPosition?
11:27:11 <ReinH> BoR0: iirc LYAH talks about them a bit
11:27:23 <Walther> srhb: respond is called each time we receive a message
11:27:25 <BoR0> ah, right. so when I'm liftIO-ing I'm building this stack?
11:27:25 <gdoteof> can anyone give me some hints on compiling haskell for distribution on osx?
11:27:36 <Walther> srhb: and we currently respond just based on the newest message
11:27:42 <njsg> srhb: yeah, respond is called for every single message
11:27:49 <ReinH> BoR0: you build the stack at the type level
11:27:55 <srhb> Walther: Right. I think it's wrong that respond should be responsible for storing the newest message, but you can do that if you want
11:27:57 <ReinH> so StateT SomeState IO a is a monad transformer stack
11:28:01 <Walther> srhb: while for the car logic, we definitely want to influence the sent client message by previous messages as well
11:28:06 <gdoteof> compiling with -static doesn't work; but the dynamically linked executable is failing with libcrt0.o not being on the client machine
11:28:11 <Walther> srhb: currently nothing is stored
11:28:17 <ReinH> BoR0: where StateT SomeState "tranforms" the base monad, IO, to give you one that can also do State stuff
11:28:34 <srhb> njsg, Walther What you want is for some top-level place to run execStateT loop []
11:28:38 <Walther> currently, respond is a fifo function that reads newest message, applies functions to it, and responds with a client message
11:28:45 <ReinH> BoR0: monad tranformers are sort of like type-level monad morphisms. StateT SomeState is a type constructor that takes some base monad and turns it into a new one
11:28:53 <srhb> njsg, Walther: loop takes care of receiving messages, storing them in the log and calling respond for each new one
11:28:54 <BoR0> ReinH: aha, I see. so the instance of MonadIO is the transformer (stack), and we use liftIO to "execute" stuff within the transformer?
11:29:11 <Walther> we want that to stay, but we want it to also as a side-effect save the just-got newest message, and while deciding what to send back, read a couple last messages as well
11:29:13 <ReinH> BoR0: right, MonadIO (like all typeclasses) is just a way of giving liftIO more than one definition
11:29:19 <BoR0> ok
11:29:21 <srhb> njsg, Walther: respond has access to that state, being a message -> StateT YourLog IO ()
11:29:22 <ReinH> BoR0: you are actually using the definition of liftIO for your stack
11:29:26 <Walther> there is no need for respond to actually have the list as a parameter or anything
11:29:49 <ReinH> so in our case you actually have liftIO instantiated at liftIO :: IO a -> StateT SomeState IO a
11:30:00 <Walther> srhb: again; isn't there a way to do this without state?
11:30:04 <srhb> Walther, njsg: OK. You're doing it wrong, but if you really insist, stick it in an IORef
11:30:09 <srhb> It's very much against my will
11:30:11 <srhb> I'm almost crying
11:30:12 <BoR0> ReinH: got it
11:30:14 <srhb> :-)
11:30:15 <srhb> But feel free
11:30:19 <Walther> srhb: Or without ioref
11:30:21 <BoR0> thanks a lot :)
11:30:27 <Walther> srhb: i mean, couldn't we just do this with a updating list
11:30:27 <ReinH> BoR0: np :)
11:30:31 <Walther> srhb: we just have no idea how
11:30:32 <ReinH> BoR0: so "moprhism" in this case just means funciton
11:30:34 <ReinH> *function
11:30:53 <srhb> Walther: You can do it with either with IORef or with StateT, or with simple recursion passing the log in a parameter all the way through your program
11:31:15 <ReinH> BoR0: but we call it a morphism because it behaves in a predictable way (based on the definition of morphism in category theory)
11:31:38 <srhb> Walther: Those are basically your options.
11:32:11 <ReinH> BoR0: and liftIO is indeed a function, just one with some nice properties.
11:32:29 <njsg> srhb: the loop is doing by using two mutually recursive functions, so I'm already hacking there, but I still need to fix their types
11:32:40 <Walther> srhb: so you're saying there's no way we can just say in a similar way as the current putStrLn line, that somelist ++ [carPositions] and be happy
11:32:46 <ReinH> BoR0: hope that hels
11:32:48 <ReinH> helps
11:32:52 <BoR0> ahh so many stuff that came to my mind now, since you mentioned category theory. could you explain e : 1 -> M to me? what does the '1' represent in that context?
11:33:01 <srhb> Walther: Well you want to keep the information for the next round, you need to pass it back somehow
11:33:05 <njsg> srhb: it seems to be complaining about the first line in a do loop, you said something about every line needing to have a StateT, how does that go?
11:33:08 <BoR0> someone mentioned it is a terminal object but I have no idea what that means
11:33:31 <srhb> njsg: Now I'm confused, I thought you weren't going the StateT route
11:33:50 <ReinH> BoR0: I assume you're talking about return?
11:33:53 <srhb> Walther, njsg: Either way, I have a date so I need to go shower now. If you're still struggling much later or another day, feel free to poke me.
11:34:00 <Walther> srhb: we are actively trying all possible options
11:34:05 <Walther> Huge thanks for the help.
11:34:10 <srhb> o/
11:34:12 <Walther> sorry for being so dumb :P
11:34:19 <njsg> srhb: it goes like this, Walther was now exploring something else, I was still trying to use StateT
11:34:44 <savanni> I'm still around and have been silently watching the conversation.  I'm not necessarily up to speed, but I may still be able to help, and I'm not leaving for a few hours.
11:35:01 <ReinH> BoR0: if M is a monad, 1 -> M is a natural transformation from the identity functor to the monad (which is also a functor)
11:35:02 <vanila> BoR0, it's a zero morphism
11:35:03 <njsg> one "function declaration" is "handleServerMessage :: Handle -> ServerMessage -> IO ()", and I see it takes a Handle and a ServerMessage as parameters, so where do I fit the StateT there? :-\
11:35:06 <ReinH> BoR0: that didn't quite help, did it :)
11:35:17 <njsg> srhb: have a good date, then!
11:38:09 <imalsogreg> njsg, Walther: Like savanni I've been listening, happy to give some more thoughts about your architecture issue if you need
11:38:32 <savanni> njsg: if I assume correctly, you want to have [CarPosition] available to handleServerMessage, tohugh I don't see you changing the state there.
11:39:08 <savanni> But, you could redefine handleServerMessage to `handleServerMessage :: Handle -> ServerMessage -> StateT [CarPosition] IO ()"
11:39:45 <savanni> That's going to trigger some more changes that I'm tracing now.
11:39:45 <vanila> BoR0, oops, or unit of an adjunction
11:40:36 <savanni> The print messages in `respond`: are those just debugging traces?
11:40:55 <Walther> savanni: yes, and those are also the things we would gladly instead put to the log
11:40:56 <ReinH> vanila: it's a zero morphism?
11:41:06 <vanila> no
11:41:09 <ReinH> vanila: ok good
11:41:37 <savanni> Hmmm.  There is something I could recommend that would make the type for respond simpler, but it only works if you intended to eliminate those messages completely.
11:41:43 <vanila> :/
11:41:54 <ReinH> vanila: I thought I was confused for a second :)
11:42:33 <savanni> Oh.  Wait.  Walther, is [CarPosition] your starte, or are those log messages your state?
11:42:34 <lispy> srhb: in this context, 'go all lispy' means make a Haskell -> JVM compiler? Because that's what I would probably do.
11:42:58 <Walther> savanni: wouldn't probably work as respond always receives a ServerMessage as input and needs to output a IO [ClientMessage], we just need some magic side-effects to save previous messages that affect what we output within the IO [ClientMessage]
11:43:25 <BoR0> sorry, was afk. no, I was talking in context of category theory, if we have f : A -> B then we can view A and B as sets, but what is up with f : 1 -> B? what is 1?
11:43:27 <njsg> savanni: imalsogreg: right now, I've moved a bit up in the call chain, and I'm trying to apply it at a higher level, even then I get one complaint from ghc
11:43:47 <njsg> "No instance for (MonadState [ServerMessage] IO) arising from a use of `modify'"
11:44:08 <ReinH> BoR0: f is a natural transformation, a morphism between functors that preserves their structure.
11:44:15 <lispy> srhb: I'd probably do it the way ghcjs is written.
11:44:36 <ReinH> 1 is an identity functor
11:44:37 <njsg> the function has no 'prototype' so to speak (the :: line), and ghc suggests adding an "instance declaration" -- is there some simple fix for this?
11:44:47 <savanni> njsg: could you post an updated version?
11:44:55 <imalsogreg> njsg: I did miss any link you gave to the code you're looking at.
11:45:12 <BoR0> ReinH: is "identity functor" the same as "terminal object"?
11:45:13 <lispy> srhb: that way you get all of ghc's frontend goodness. You still have to implement a gmachine on the JVM (slow), write a run-time, and figure out an FFI, but at least you'd get all the fancy type checking and extensions.
11:45:53 <albeit> In a fold, does the accumulator contain the thunks of the previous accumulator? Or is the previous accumulator evaluated?
11:46:04 <imalsogreg> njsg: A very general comment - it sounds like different types of logic are coupled a little funny in your functions.
11:46:32 <njsg> what is an instance declaration?
11:46:33 <imalsogreg> njsg: I'd suggest trying to get a function like:   getMessage :: Handle -> IO CarPosition
11:46:38 <ReinH> BoR0: no
11:46:48 <savanni> njsg: think of that as declaring an interface in Java.
11:47:08 <njsg> savanni: can I have more than one?
11:47:08 <savanni> In this case, it would look something like `instance MonadState [CarPositions] where`, followed by some function definitions.
11:47:11 <jle`> instance declaration would be more analogous to implementing an interface
11:47:11 <ReinH> BoR0: first of all, what category are we in?
11:47:22 <savanni> Oh, yes.  Many useful things have a lot of instances.
11:47:28 <srhb> njsg: You stick that on the return type of the function
11:47:31 <savanni> And, jle` is right.  "implementing" is the right word.
11:47:32 <BoR0> ReinH: pick any :) I am just trying to get a general sense of it
11:47:33 <srhb> njsg: No writing instances for now
11:47:33 <lispy> albeit: it depends on how lazy the fold is in the accumulator
11:47:49 <jfischoff> Am I correct that a broadcast TChan can support multiple writers and readers?
11:47:55 <albeit> Wondering because if the fold's step takes a accumulator :: [a] and creates a new accumulator :: [a], are all the previous accumulator lists still stored in memory?
11:48:01 <savanni> Anyway, I think this is what you'll want to do
11:48:11 <lispy> albeit: if the fold is just adding to the accumulator, but not forcing it, then the current thunk will have pointers to the previous accumulator
11:48:15 <vanila> BoR0: 1 is probably just a set with one element, so f : 1 -> B names an element of B
11:48:16 <jle`> albeit: it depends on the compiler
11:48:25 <jle`> albeit: that's an implementation detail :)
11:48:28 <ReinH> BoR0: if the identity functor is to be a terminal object then it has to be an object in some categorty
11:48:30 <albeit> lispy: Ah so if I use something like foldl' it would non-lazy and thus evaluate the accumulator?
11:48:36 <ReinH> BoR0: so in order to answer the question we need to know what category we're in
11:48:37 <savanni> Change handleServerMessage to `handleServerMessage :: Handle -> ServerMessage -> StateT [CarPosition] IO ()`
11:48:44 <savanni> Do the same thing with `respond`
11:48:56 <jle`> albeit: remember that all data structures in haskell are technically "persistent"
11:49:13 <lispy> albeit: That's the motivation behind foldl', but keep in mind you can still be too lazy with foldl'
11:49:14 <savanni> And then in `respond`, you'll use the `modify` call that srhb posted.  It would probably be...
11:49:23 <jle`> meaning that copies of it are available forever, and that the are never edited in-place, only copied and modified
11:49:33 <jle`> in reality, garbage collection and smart compilers make that less of a reality
11:49:43 <njsg> srhb: in this case, the one I'm looking at now doesn't even have a "declaration", but if it does have a return type "a", what do I do to make it so that it complies with StateT?
11:49:47 <lispy> albeit: did you read dcoutt's post about foldl?
11:50:00 <albeit> Hmm... I'm trying to implement an algorithm that is O(n^3) for space, but I can modify it so that it is O(n^2) if I use fold and the accumulators are discarded.
11:50:06 <albeit> lispy: No I have not
11:50:17 <srhb> njsg: Basically your return type should (must) be of type StateT YourState IO Something
11:50:28 <srhb> njsg: So you need your evalState to wrap the main loop of your program
11:50:29 <albeit> lispy: Do you have a link?
11:50:30 <ReinH> BoR0: let me correct an assumption by asking if f : 1 -> M is meant to refer to the unit for some monad M
11:50:43 <lispy> albeit: http://www.well-typed.com/blog/90/
11:50:52 <njsg> srhb: it seems to be complaining that, inside a StateT function, some lines in a "do" sequence aren't of that type
11:51:02 <robb> I'm coming from an imperative background to haskell - is there a resource which is targeted to this transition?
11:51:03 <srhb> njsg: Are they of type IO Something?
11:51:03 <lispy> albeit: It's a long read and posted on april 1st, but it's legit
11:51:10 <Walther> srhb: we *don't* want the return type of respond to change
11:51:17 <srhb> Walther: Then you can't make it StateT.
11:51:17 <savanni> njsg: that's a very common error
11:51:19 <Walther> srhb: we just want a secret side-effect of logging there
11:51:22 <albeit> lispy: Thanks
11:51:27 <jle`> all lines of a do block have to be of the same monad; note
11:51:29 <lispy> albeit: and there is also a reddit thread: http://www.reddit.com/r/haskell/comments/21wvk7/foldl_is_broken/
11:51:29 <jle`> :t (>>=)
11:51:29 <srhb> Yes, that's why you want StateT
11:51:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:51:41 <ReinH> BoR0: btw we might want to move this to ##categorytheory, quieter and other people can correct me when I'm wrong ;)
11:52:19 <srhb> Walther: If you want to not change the return type, you have to do it wrong, either by passing the state through a parameter of every function in you program or by making an IORef and passing that through every function that needs it.
11:52:42 <lispy> robb: Not that I know of.
11:52:59 <njsg> savanni: how do I work around it, then?
11:53:15 <njsg> srhb: nope, just another object, which seems to be the return value of whatever function call is in there
11:53:18 <Walther> srhb: welll- we can't change the returntype of response as the server expects to receive the messages in a certain fashion
11:53:19 <lispy> robb: If you haven't done much functional programming you might try one of the more traditional texts about Haskell. Like School of Expression.
11:53:21 <savanni> njsg: it's going to depend on the data type of the line.  What is the line?
11:53:34 <srhb> Walther: surely responding involves using IO somehow
11:53:38 <Walther> nod
11:53:45 <srhb> Walther: Using IO is permitted in StateT YourState IO Something
11:53:51 <srhb> So just make it actually respond to the server.
11:53:52 <Walther> repond :: ServerMessage -> IO [ClientMessage]
11:53:55 <robb> lipsy: Not to worry, then. There's great documentation on the web to keep me occupied.
11:54:04 <BoR0> ReinH: ok :)
11:54:13 <Walther> srhb: and that's what njsg and I are trying to get working but run into weird issues
11:54:15 <srhb> Walther: respond :: ServerMessage -> StateT YourLog IO ()
11:54:29 <savanni> Walther: is there an outside requirement that `respond` have that specific data type?
11:54:51 <jle`> note that you can turn any IO () into a StateT YourLog IO () with the function liftIO :: IO () -> StateT YourLog IO ()
11:54:59 <jle`> ( type signature simplified :) )
11:54:59 <Walther> savanni: well, we definitely don't want to send some weird states with the message
11:55:15 <srhb> Walther: So make respond send the actual message.
11:55:16 <jle`> Walther: the client message is just the message, [ClientMessage]
11:55:17 <savanni> Okay, yeah, you won't have to.
11:55:33 <lispy> robb: some people find that it helps to spend some time getting to know the lambda calculus. I think it really depends on a) your level of mathematical comfort/maturity b) whether you're the type that learn best by starting at the primitives
11:55:37 <jle`> remember that when you use State, you are building a "future function to be run"
11:55:38 <fizruk> :t \f -> F.foldr ((<|>) . f) empty   -- is there such function anywhere?
11:55:39 <lambdabot> (Foldable t, Alternative f) => (a -> f a1) -> t a -> f a1
11:55:41 <savanni> njsg: ?
11:55:52 <jle`> @unmtl StateT a IO ()
11:55:53 <lambdabot> a -> IO ((), a)
11:56:08 <jle`> @unmtl StateT s IO ()
11:56:08 <lambdabot> s -> IO ((), s)
11:56:20 <jle`> StateT is only a convenient wrapper over a function s -> IO ((), s)
11:56:32 <jle`> @unmtl StateT s IO a
11:56:32 <lambdabot> s -> IO (a, s)
11:56:39 <lispy> robb: if your goal is just to get some working haskell programs and you don't care about the theoretical aspects, try real-world haskell. (freely available online)
11:56:42 <jle`> so you are actually building up a giant s -> IO (a, s)
11:56:52 <jle`> your "state" isn't a part of your return value
11:56:56 <jle`> it is only used in the computation
11:56:58 <jle`> of the return value
11:57:51 <fizruk> :t \f -> asum . fmap f
11:57:52 <lambdabot>     Not in scope: ‘asum’
11:57:52 <lambdabot>     Perhaps you meant one of these:
11:57:53 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
11:57:54 <jle`> your ClientMessage is still just a client message, with nothing special attached to it
11:58:00 <fizruk> :t \f -> F.asum . fmap f
11:58:01 <lambdabot> (Foldable t, Functor t, Alternative f) => (a1 -> f a) -> t a1 -> f a
11:58:04 <jle`> your State is just used to compute the ClientMessage
11:58:18 <jle`> that's what StateT s IO ClientMessage means
11:58:26 <fizruk> ah, foldable is not always functor...
11:58:41 <Walther> jle`: Ok.
11:58:54 <jle`> "a function that creates an IO ClientMessage, when you give it something of state s)
11:58:57 <jle`> it's a *function*
11:59:14 <jle`> it's actually literally just a type synonym :)
11:59:29 <jle`> StateT s IO ClientMessage =====> s -> IO (ClientMessage, s)
11:59:34 <lispy> robb: Some of the things that trip up imperative folks learning Haskell are: a) we use recursion to bind a value instead of mutable update, b) because of higher-order functions we write things "inside out", c) types
11:59:42 <aviraldg> Is there a nice guide on optimizing to tail recursive functions (using higher order functions) somewhere? (maybe something like a few examples?)
11:59:49 <defanor> trying to install ghc 7.8 on centos 6.5, but it can't see libgmp.so.3 (though it is in /usr/lib64/). "--with-gmp-libraries /usr/lib64/" does not help. is there any known solution?
12:00:23 <jle`> by literally i mean basically :)
12:00:50 <quchen> defanor: Did you download the generic binaries? They're linked against another version of libgmp.
12:00:58 <quchen> http://www.haskell.org/ghc/download_ghc_7_8_2#binaries
12:01:00 <lispy> aviraldg: Not sure what you mean. Like the trick you do in scheme/lisp where you turn a non-tail recursive function into a tail-recursive function?
12:01:12 <quchen> There are centos builds specifically because of this issue there
12:01:13 <njsg> srhb, savanni, imalsogreg, bernalex, probably going to take a break from this soon and look again after dinner
12:01:17 <lispy> aviraldg: if so, that's not such an obvious win in Haskell so we talk about it less often.
12:01:27 <defanor> quchen: nope, downloaded those for centos 6.5
12:02:01 <defanor> quchen: oh, i've downloaded binaries for i386
12:02:03 <savanni> njsg: cool.  I might take a half-hour break, but I'm basically around for another five hours.  Ping me.  I want to help and I think I've got some ideas.
12:02:11 <aviraldg> I have a function that works properly and does what it's meant to for small values of x, y, but for larger values I get stack overflows.
12:02:27 <jle`> try making it stricter
12:02:33 <jle`> it sounds like a laziness issue
12:02:58 <lispy> aviraldg: Ah right. So, making it a tail recursive function will probably make it worse until you understand what is happening.
12:03:15 <monochrom> aviraldg: read my http://www.vex.net/~trebla/haskell/lazy.xhtml for the general. for the specific, you have to paste actual code.
12:03:31 <lispy> monochrom++
12:03:37 <jle`> because of haskell's evaluation model, tail recursive functions don't really correspond to the change in evaluation that you might expect from a traditional assignment/statement-based language
12:03:41 <monochrom> note that foldl (+) is not an improvement over foldr (+). my article shows how.
12:10:14 <jakex> all this talk about State made me play with it a bit.. is it ok to turn on -XRankNTypes or XRank2Types to get `type RandomState a = (RandomGen g, Random a) => State g a' to work? which one should I use?
12:11:39 <monochrom> I don't trust such complicated type synonyms. I would write "(RandomGen g, Random a) => State g a" explicitly.
12:12:24 <lispy> jakex: if you put the g on the LHS I think you wouldn't need the extension?
12:12:38 <geekosaur> that type won't do what you want, it's implicitly "forall" --- that is, your g and a constraints will not unify across multiple uses of the type in a signature. (which is also why it wants rank 2 for that g)
12:12:40 <lispy> type RandomState g a = (RandomGen g, Random a) => State g a, untested though
12:13:36 <monochrom> after all, sometimes I need "RandomGen g => Int -> State g Int". is that equivalent to "Int -> RandomState g Int"? no matter what the answer is, it's too subtle to be worth it
12:15:29 <jakex> lispy I am not sure what the type of stateful version of random would be with that..  with explicit State declaration it is random :: (RandomGen g, Random a) => State g a
12:16:20 <monochrom> programmers conflate abbreviations with abstractions
12:16:21 <Wizek> Can lambdabot's @undo be used online for longer pieces of code?
12:17:08 <jakex> monochrom well.. what do you find easier to read? `random :: RandomState a' or `random :: (RandomGen g, Random a) => State g a' ?
12:17:20 <monochrom> my distinction: if every time I use it I have to know its definition, it is not an abstraction.
12:17:49 <monochrom> the longer one is easier to read. it tells me real information
12:17:58 <monochrom> the shorter one is harder to read. it tells me nothing.
12:18:27 <monochrom> if every time I use it I have to know its definition, it is not an abstraction.
12:18:44 <corgifex> this applies to all words
12:19:16 <monochrom> "State g a" is an abstraction. I do not have to know its newtype definition. I only need a few axioms about how its "put" and "get"
12:19:23 <Wizek> @undo do { a <- b; print 1; print a}
12:19:24 <lambdabot> b >>= \ a -> print 1 >> print a
12:19:28 <jakex> you have to know what State is to read State g a..
12:19:53 <monochrom> have you written a few axioms for so-called RandomState g a?
12:19:54 <lispy> I'm with monochrom on this one. The type alias I gave was just to make the point that the g needed to be moved.
12:20:32 <quchen> Is there a way to run TH optimized? If I use it to compute an Integer at compile time it takes quite some time to do so.
12:21:00 <quchen> So what I want is pretty much an optimization pass over the code that is fed to TH, if that makes sense
12:21:31 <corgifex> yes, write your code to a temp file, invoke ghc -O2, run it, and insert the result
12:21:42 <jakex> can this be handled some other way? by defining a new monad, or something similar? maybe it is because I am not too used to using State but I find random :: (RandomGen g, Random a) => State g (a, a) really ugly and hard to read.
12:21:52 <haasn> quchen: TH runs through the interpreter (shared with GHCi)
12:22:01 <haasn> It isn't even like -O0
12:22:22 <haasn> But:
12:22:36 <haasn> You could probably factor the code out to a separate package, compile that with -O2 and import it
12:22:47 <haasn> That should use the optimized versions even when dynamically interpreting, right?
12:22:49 <jakex> I am only interested in this: (a, a), but (RandomGen g, Random a) => State g  completely drowns the useful information in the declaration
12:23:12 <merijn> jakex: I disagree with that observation
12:23:19 <merijn> That part is the interesting bit
12:23:25 <merijn> The (a, a) is fairly boring
12:23:36 <quchen> haasn: Yeah that's a workaround that would do. I just wondered whether I'm missing a -XOptimizeTH flag or something.
12:24:09 <haasn> -ffinally-fast
12:24:27 <merijn> jakex: The typeclass stuff is what tells you what it's actually doing
12:24:47 <albeit> What is likely to be faster: allocating a [m x n] Data.Array and filling n points over m iterations, or foldl'ing over a [n] list m times, wherethe accumulator is a new [n] list each time?
12:24:50 <merijn> jakex: Without you just know "it's a tuple", god knows where it came from and what it means
12:25:55 <lispy> albeit: For now, I'd focus on a correct implementation that is readable.
12:26:05 <jakex> merijn I just wish there was a more concise way to say "this is a State with tuple as result and RandomGen as state". but I guess not
12:26:08 <lispy> albeit: once you have that, you can start to think about the performance of it.
12:26:11 <jakex> is there?
12:26:58 <merijn> jakex: Not very many, it's nearly impossible to hide the constraints in an easy way and the "State g" doesn't really take up that much space
12:27:26 <merijn> jakex: I would probably just linewrap the signature and call it a day
12:27:30 <albeit> lispy: I have both implementations working, and readable (I think). I'm just starting on profiling them, but am wondering if one way is typically better to use?
12:27:32 <lispy> albeit: For example, In the list version you might be able to exploit fusion and avoid actually building the intermediate lists.
12:27:49 <monochrom> jakex, build a real abstraction, not a mere abbreviation
12:28:05 <jakex> monochrom such as?
12:28:25 <merijn> jakex: Maybe annotating the type like this helps readability? http://lpaste.net/102796
12:28:50 <lispy> albeit: I find that both lists and Data.Vector can be faster than Data.Array for lots of things but it really depends on how you access the elements. Haskell lists are really more like streams and not at all good as arrays.
12:29:25 <quchen> In Haskell, lists are a lot like singly linked lists. That is because they are singly linked lists.
12:29:26 <monochrom> I am too lazy to give a 2nd example. but I have already said the distinction and a 1st example.
12:29:31 <jakex> merijn it does a bit. I kind of wish we could type State RandomGen Random
12:29:46 * quchen forces monochrom 
12:29:59 <merijn> jakex: You can just write "Random a => State StdGen (a, a)"
12:30:33 <corgifex> did you mean: State RandomGen (Random, Random)
12:30:36 <merijn> Assuming StdGen is a sufficiently random generator and you don't care to use others
12:31:22 <jakex> that choice sucks, making the declaration more readable or more generic
12:31:37 <Wizek> Is there an online sevice for simplifying haskell code?
12:32:03 <monochrom> I have also already disagreed with "shorter => readable". but I guess you don't want to hear it.
12:32:03 <merijn> Wizek: I'm willing to simplify haskell code for money :p
12:32:08 <lispy> albeit: Profiling is really good. You should definitely do that. You might also want to use criterion to help with that. It's good for doing timings in a microbenchmark setting.
12:32:08 <quchen> Wizek: HLint is a Haskell linter. It suggests certain improvements, but nothing big.
12:32:13 <quchen> cabal install hlint
12:32:26 <quchen> (It's also what LPaste uses when it displays suggestions at the bottom.)
12:32:27 <merijn> quchen: Shush, don't ruin my up and coming business! :p
12:33:15 <lispy> albeit: you have you figured out if both of your algorithms are in the same complexity class?
12:33:18 <quchen> HLint is pretty outdated though, you may want to consider using Merijn.
12:33:18 <jakex> why aren't typeclasses first class types, anyway?
12:33:36 <merijn> monochrom: I think that''s a lesson everyone has to figure out for themselves by trying to use libraries that use shorter over readable. That cured my disease :)
12:33:36 <lispy> for one, they're not types :)
12:33:37 <saml> what's first class types?
12:33:40 <corgifex> jakex: they are
12:33:41 <saml> yah
12:33:42 <merijn> jakex: What do you mean by that?
12:33:57 <jakex> corgifex then why can't I have a list of Show?
12:34:04 <Wizek> import Merijn (codeSimplifierFreeOfCharge)
12:34:09 <saml> i don't think types are first class in haskell
12:34:10 <corgifex> jakex: but if you're talking about the State RandomGen Random thing, because that would reduce their power
12:34:14 <albeit> lispy: Do you mean in terms of speed and space?
12:34:20 <corgifex> jakex: you can; it's called [String]
12:34:28 <merijn> Wizek: "missing symbol error"
12:34:31 <lispy> albeit: yeah. Do they have the same big-O
12:34:54 <merijn> jakex: How does a list of Show differ from a list of String?
12:34:54 <albeit> lispy: I think (!) the one with folding is O(n^2) for space, and with Data.Array O(n^2). Both O(n^3) for speed
12:35:16 <albeit> Oops with Data.Array O(n^3)
12:35:19 <monochrom> "why aren't type classes first-class types" = "why aren't panda gardens first-class pandas"
12:35:39 <saml> > [3.4, 1] :: [Show Numeric]
12:35:40 <lambdabot>  Not in scope: type constructor or class ‘Numeric’
12:35:58 <jakex> merijn if we could have a list of Show we could also have a list of other things that don't have just one method
12:36:04 <monochrom> I be damned if a garden became a panda, even if that garden were full of pandas.
12:36:04 <lispy> albeit: okay, in that case you should see a difference in how much work the gc does for one than the other
12:36:26 <albeit> lispy: Meaning the one with folding should show more work gc?
12:36:26 <lispy> albeit: as in, the scaling of the work should be different
12:36:38 <saml> jakex, Show is a type class
12:36:53 <saml> > [1,2] :: [Show Int]
12:36:53 <jakex> saml yes
12:36:54 <lispy> albeit: the one that is O(n^3) for space should have to gc more, right?
12:36:55 <lambdabot>  Expected kind ‘*’,
12:36:55 <lambdabot>    but ‘GHC.Show.Show GHC.Types.Int’ has kind ‘Constraint’
12:36:56 <monochrom> but you can say, my analogy is broken, all analogies are. ok, write down a type system in which type classes are types too, and prove its soundness. (I won't hold my breath.)
12:37:10 <saml> jakex, what are you trying to do?
12:37:13 <jakex> > ["foo", 2] :: [Show]
12:37:15 <merijn> jakex: The ori
12:37:17 <saml> why?
12:37:18 <lambdabot>  Expecting one more argument to ‘GHC.Show.Show’
12:37:20 <lambdabot>  Expected kind ‘*’, but ‘GHC.Show.Show’ has kind ‘* -> Constraint’
12:37:20 <corgifex> jakex: you can do that with existentials
12:37:23 <jakex> why not?
12:37:24 <merijn> hmm, why did irssi write that?
12:37:29 <saml> this is not javascript
12:37:29 <merijn> corgifex: Please don't bring those up
12:37:30 <triliyn> monochrom: in idris, typeclasses are types whose inhabitants are dictionaries of methods
12:37:38 <merijn> corgifex: You'll get people to think that's a good idea
12:37:48 <monochrom> that's good news.
12:37:53 <shergill> monochrom: i'm ok as long as gardens of panda gardens are kept distinct as well and this is carried on up till omega. and there's a way to specify this tower of panda gardens distinctly and in one go from the tower of lemur gardens
12:37:56 <albeit> lispy: I was thinking the one that is O(n^2) would clean up the lists it no longer needs, and so would garbage collect more. The one with O(n^3) wouldn't garbage collect, just at the very end. Is that the right way of thinking abou tit?
12:38:04 <shergill> *tower of pandas
12:38:29 <lispy> albeit: That could be. I haven't seen the code :)
12:38:51 <merijn> jakex: Basically, everyone is trying to save you time, because most newcomers go through this phase, spend a lot of time trying to make what you want happen and then realise that it was a colossal waste of time
12:39:33 <saml> merijn, Num Int is not a type, right?
12:39:36 <saml> it's a predicate
12:39:46 <corgifex> :k Num Int
12:39:47 <lambdabot> Constraint
12:39:51 <merijn> jakex: If you insist on finding it out yourself we can give you plenty of rope to accidentally hang yourself with, but we don't want to unnecessarily waste your time
12:40:02 <merijn> saml: In GHC "Num Int" is a type of the kind Constraint
12:40:05 <saml> what's Constraint?
12:40:08 <corgifex> a kind
12:40:16 <merijn> Although in Haskell2010 it's not necessarily defined to be
12:40:18 <lispy> albeit: if you really wanted to be hardcore about this, you could learn to read GHC Core and then look at the generated core to see which version optimizes better too.
12:40:19 <saml> i thought kinds are only *, ->
12:40:29 <merijn> saml: In GHC you can now add your own kinds
12:40:33 <lispy> albeit: That's fairly advanced
12:40:38 <saml> > 1 :: Num Int   -- not sure why i can't do this
12:40:39 <lambdabot>  Expected a type,
12:40:39 <lambdabot>    but ‘GHC.Num.Num GHC.Types.Int’ has kind ‘Constraint’
12:40:43 <merijn> saml: Ooh, you have so much fun stuff to learn!
12:40:57 <merijn> saml: Because in haskell all terms have types of kind *
12:41:00 <lispy> > 1 :: Num Int => Int
12:41:02 <lambdabot>  1
12:41:03 <merijn> and Num Int is a type of kind Constraint
12:41:07 <robb> lipsy: Sorry, I went afk for a while. In regards to learning haskell from an imperative background - would starting with scheme (ie: SICP) first be any use? My level of maths is integeral calculus and differential calculus. I have not studied lambda calculus.
12:41:37 <saml> >  [1] :: [Num Int => Int]  -- lispy  why can't i do this ?
12:41:38 <lambdabot>  Illegal polymorphic or qualified type:
12:41:38 <lambdabot>    GHC.Num.Num GHC.Types.Int => GHC.Types.Int
12:41:38 <lambdabot>  Perhaps you intended to use ImpredicativeTypes
12:41:56 <merijn> saml: If you wanna see cool stuff you can do in GHC check out the DataKinds extension and TypeFamilies (I recommend the "Fun with Type Functions" paper
12:41:59 <triliyn> robb: the calculus in lambda calculus is unrelated to the one in differential/integral calculus
12:41:59 <lispy> robb: I came to Haskell from lisp, so I would be a hypocrite to say it doesn't help :) OTOH, it's certainly not necessary. If you want to learn Haskell, just start with Haskell.
12:42:18 <merijn> Why does GHC still suggest ImpredicativeTypes, considering the extension is broken? :\
12:42:18 <triliyn> Lambda calculus is a formalization of computation based on argument substitution, basically
12:42:24 <Wizek> jakex: What do you need the list of showables for?
12:42:25 <triliyn> It's pretty simple to understand
12:43:03 <robb> triliyn: Is there a recommend textbook on lambda calculus?
12:43:06 <saml> :k (Num Int => Int)
12:43:07 <lambdabot> *
12:43:07 <lispy> saml: Put the type class constraint on the outside of the list
12:43:16 <lispy> > [1] :: Num Int => [Int]
12:43:18 <lambdabot>  [1]
12:43:39 <saml> hrm doesn't work on my ghci. maybe i need to enable something
12:43:44 <lispy> saml: when you put it inside the list it changes the way it's quantified.
12:43:55 <triliyn> robb: hmmm, I'm not really the best source for textbook recommendations, but I'm sure someone in here can suggest one
12:44:03 <Wizek> jakex: Am I correct to guess you want to `putStrLn $ unword list`?
12:44:16 <Wizek> :t unword
12:44:18 <lambdabot>     Not in scope: ‘unword’
12:44:18 <lambdabot>     Perhaps you meant one of these:
12:44:18 <lambdabot>       ‘unwords’ (imported from Data.List),
12:44:26 <Wizek> +s, then.
12:44:30 <monochrom> robb: how much lambda calculus do you really need to know?
12:44:50 <lispy> saml: this is all kind of cheating though. We're just explicitly stating a constraint that is already satisfied.
12:45:09 <saml> yah i think it's a good blog post to scare people
12:45:15 <triliyn> > 'a' :: RandomGen StdGen => Char
12:45:17 <lambdabot>  'a'
12:45:19 <saml> WAT? type of presentation
12:45:23 <saml> let me write the blog post quick
12:45:33 <lispy> triliyn, monochrom: robb is asking about lc because I mentioned that if he likes to learn the theory he might study it a bit. Totally optional though.
12:45:59 <monochrom> oh, the theory is a rabbit hole.
12:46:05 <jakex> Wizek a list of Show, specifically? not too useful. now imagine a ShowOnSteroids class, that has a dozen different methods. if we took the time to write instances of that class for a lot of types it would be nice if we could store and handle a list of those objects in a generic way
12:46:58 <corgifex> jakex: why?
12:46:59 <merijn> jakex: And what would you do with them?
12:47:02 <albeit> @pl: (\i -> ((i,i), 0))
12:47:03 <lambdabot> flip (,) 0 . join (,)
12:47:10 <Wizek> jakex: What do you mean by ShowOnSteroids?
12:47:27 <monochrom> and even then, "the theory" consists of many aspects. some aspects don't even care about that part of a lamda calculus book on confluence.
12:47:31 <jakex> merijn call the methods that class contains
12:47:53 <jakex> that that class contains*
12:48:00 <merijn> jakex: The only way to implement this is by storing the dictionary containing the method with every value in the list
12:48:25 <robb> monochrom: what kind of maths background is needed to understand lambda calculus?
12:48:27 <Wizek> albeit: If I were you, I would use the unpointfree version. :)
12:48:30 <lispy> jakex: I wanted to do stuff like that when I first learned Haskell. Now it seems like a bad idea. I don't know how to convince you other than to say, try it :) (Yes there are ways to do this, but again it's really a last resort, not a good design)
12:48:39 <merijn> jakex: And you can just do this by doing "data Foo = forall a . Foo { value :: a, doSomething :: a -> String, doSomethingElse :: a -> Int }"
12:48:43 <albeit> @Wizek: Ha yep, that was not as pretty as I was hoping it might be.
12:48:44 <lambdabot> Unknown command, try @list
12:48:53 <merijn> jakex: Now create a list of Foo and you can do the same thing
12:48:54 <monochrom> basic logic.
12:49:15 <albeit> @pl: (\(i,j) -> ((i,j), d a i j x))
12:49:16 <lambdabot> uncurry (ap (ap . ((,) .) . (,)) (flip flip x . d a))
12:49:20 <lispy> jakex: For example, if you use existentials to do the encoding, one of the technical issues that it raises is how to get back to the original type.
12:49:25 <thoughtpolice> lispy: i'm almost certain 100% of people have gone down the road of ExistentialTypes for these kinds of things at one point or another, i surely did not long after I found Haskell.
12:49:34 <Wizek> albeit: Is there only one pointfree representation of any given function?
12:49:38 <merijn> jakex: Do you have any deadlines/work that you need to finish?
12:49:44 <robb> monochrom: I found this browsing online: http://www.jetcafe.org/~jim/lambda.html -- this should get me started.
12:49:55 <albeit> Wizek: I do not know...
12:50:20 <quchen> thoughtpolice: Struggling with the Exceptions module scared me way before I knew about existential types :-)
12:50:22 <monochrom> I should just tell you how much lambda calculus you need to know for haskell.
12:50:50 <merijn> jakex: If not, google ExistentialQuantification and Data.Typeable, we'll see you back in a week when you realise this wasn't such a good idea as it first seemed :p
12:50:51 <quchen> monochrom: 80%?
12:50:54 <merijn> jakex: See also
12:51:00 <merijn> @where existential-antipattern
12:51:00 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
12:51:05 <monochrom> it consists of only 3 rules. first: (\x -> ... x ...) = (\y -> ... y ...). you can rename local variables consistently.
12:51:12 <jakex> merijn I did not know this was possible, good that it is and I will try it next time I need it
12:51:28 <monochrom> second: (\x -> ... x ...) e = ... e ...  you can plug in
12:51:34 <merijn> jakex: I apologise in advance for the mess those will get you in
12:51:42 <merijn> jakex: I highly recommend the blog post I just linked
12:51:51 <monochrom> third: (\x -> f x) = f. you can get rid of redundant lambdas.
12:51:59 <jakex> merijn I just wish the syntax could have been as simple as: [Show]
12:52:03 <saml> i blogged, too  http://www.webscale.info/2014/04/haskell-wat-type-stuff.html
12:52:11 * hackagebot connection 0.2.1 - Simple and easy network connections API  http://hackage.haskell.org/package/connection-0.2.1 (VincentHanquez)
12:52:22 <ReinH> merijn: sometimes the best direction on the abstraction ladder is down ;)
12:52:25 <thoughtpolice> quchen: right, i was going to say I can't even think of the last time I legitimately used ExistentialQuantification or anything else that did, but Exception is a good counter example.
12:52:33 <monochrom> that is all. the 3 rules are, like, one short paragraph in a 1000-page textbook on lambda calculus. I hope you see how little you really need.
12:52:43 <jakex> merijn I will read it
12:52:56 <monochrom> so, call it 0.1%
12:53:01 <merijn> saml: Oh, wanna see more "wat" type stuff in haskell?
12:53:08 <merijn> @hackage acme-php
12:53:08 <lambdabot> http://hackage.haskell.org/package/acme-php
12:53:15 <robb> monochrom: Thanks, you've helped me a lot.
12:53:24 <ReinH> merijn: lmao
12:53:37 <quchen> thoughtpolice: I wasn't joking. Exceptions seemed to have a really weird type initially, so that made me cautious of existential types. Now that I think Exceptions is alright, I don't feel the need to use existentials elsewhere much.
12:53:49 <ion> saml, merijn: http://hackage.haskell.org/package/gutenberg-fibonaccis-1.1.0/docs/src/Algorithm-Gutenberg-Fibonaccis.html
12:53:51 <savanni> merijn: wat!!!
12:53:52 <saml> php is too advanced
12:54:08 <srhb> Truly, where else can you get such complexity in equality.
12:54:16 <merijn> savanni: That package is filled with hilariously terrible ideas and typeclass abuse :)
12:54:27 <monochrom> because, to answer a question quchen may ask, the other 99.9% is about giving 3 different operational semantics, 5 different denotational semantics, and 8 different variations regarding type systems.
12:54:30 <merijn> savanni: In fact, just search hackage for "acme"
12:54:39 <nawal> hello
12:54:50 <nawal> does anyone know how to use import Text.Regex.Posix from Fay
12:54:51 <saml> hello nawal finally you came
12:54:51 <nawal> ?
12:54:51 <steveo_> hello. can I declare more than one module per file?
12:54:55 <savanni> My "wat" is kinda in agreement as I look at this and start to see dawning horror.
12:55:04 <merijn> savanni: http://hackage.haskell.org/packages/#cat:ACME
12:55:08 <quchen> steveo_: Unfortunately no.
12:55:10 <nawal> saml, were you waiting for me?
12:55:20 <merijn> savanni: ACME is filled with joke packages and horrible ideas :)
12:55:21 <saml> yah
12:55:30 <quchen> merijn: So is PHP
12:55:36 <quchen> Which is why there's acme-php :-D
12:55:41 <merijn> quchen: PHP is less funny and more sad :\
12:56:02 <savanni> steveo_: I don't think so, no.
12:56:22 <c_wraith> quchen: acme-php isn't really bad until you look at the source.  Just the haddocks don't expose its true nature
12:56:27 <quchen> Now that I think of it, having everything typed as String internally is kind of like an existential type. Hides types, hides implementation.
12:56:38 <joneshf-laptop> steveo_, curiously, what's your reason for wanting multiple modules in one file?
12:56:40 <albeit> lispy: Just thinking through a new method... I could have a Data.Map, and perform some function on that map multiple times, altering it each function call. Is that advisable? It feels more imperative and not "good" Haskell...
12:56:50 <quchen> c_wraith: foldl' is golden :-)
12:56:52 <c_wraith> quchen: read Robert Harpers blog posts about "unityped" languages
12:57:39 <monochrom> I don't know whether "every value is a string" is existential typing or non-existential typing :)
12:57:55 <steveo_> jonathanj: definitions in each of the modules are short, and they are all very related, so it would have been convenient to put them all in a single file. no big deal though, I will just use multiple files
12:57:57 <c_wraith> that sounds more like a pun than wisdom
12:58:06 <quchen> ಠ_ಠ     … that Fibonacci module
12:58:23 <ReinH> c_wraith: hmm, do you have a link lying around? Or a better google search phrase?
12:58:41 <monochrom> 60% pun, 40% wisdom. can we agree on that much? :)
12:58:51 <quchen> monochrom: You can Show the TypeRep of what you're wrapping to get stron stratic typing
12:59:09 <joneshf-laptop> steveo_, ah, i was hoping there was something groundbreaking for the reason :D
12:59:20 <steveo_> no :)
12:59:23 <quchen> 1 = "(Int, 1)" :-D
12:59:26 <lispy> albeit: updating the map creates a new map that shares (key,value) pairs with the old one. I don't see any reason to discourage that.
12:59:41 <nawal> saml, how come?
12:59:44 <c_wraith> ReinH: http://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/ I think
12:59:54 <monochrom> using strings for "(Int, 1)" is very sick
12:59:55 <saml> nawal, why not
13:00:02 <nawal> ok
13:00:41 <lispy> albeit: if your keys are indices you may want to consider IntMap
13:01:18 <saml> http://hackage.haskell.org/package/acme-php-0.0.3/src/Prelude/PHP.hs  this looks okay. not too crazy
13:02:03 <albeit> lispy: Ah okay. So creating a map from a list of N elements would be way faster than creating an empty map and inserting N elements because in the latter we would wind up making N different maps?
13:03:06 <lispy> albeit: maybe? I've never checked. Perhaps fromList just inserts a bunch of times? I tend to focus more on which one expresses my intent better.
13:03:16 <ReinH> c_wraith: thanks!
13:03:17 <aviraldg> Weird. Running my code on FP Complete gives me a stack overflow, but locally it just runs out of memory before that happens.
13:03:31 <lispy> aviraldg: they probably set a maximum steap
13:03:33 <lispy> er, stack
13:03:46 <c_wraith> steap = stackheap
13:03:54 <ReinH> aviraldg: running out of memory on a multi-tenant system is a pretty bad idea
13:04:00 <ReinH> c_wraith: I'll buy it
13:04:08 <aviraldg> And the example from: http://www.haskell.org/haskellwiki/Stack_overflow doesn't give me a stack overflow on my machine either
13:04:13 <c_wraith> ReinH: yours for the low, low cost of $2500
13:04:15 <aviraldg> Have they changed the defaults or something?
13:04:23 <ReinH> c_wraith: I'll buy it for a dollar.
13:05:42 <lispy> c_wraith: yeah :) It's all just address space to me!
13:06:05 <c_wraith> aviraldg: yes, actually.  I think around GHC 7.6, the default changed to making stacks grow dynamically
13:06:29 <c_wraith> aviraldg: so it's much harder to run out of stack space.  Doesn't make code that uses stack space like that good, though. :P
13:06:31 <albeit> Lispy: That sounds like a good idea. I just am having trouble determining what expresses my intent the best... any hints?
13:06:47 <albeit> (in general, not for this problem)
13:07:13 * hackagebot pem 0.2.2 - Privacy Enhanced Mail (PEM) format reader and writer.  http://hackage.haskell.org/package/pem-0.2.2 (VincentHanquez)
13:07:13 <lispy> albeit: that's a very board question :) It's the sort of thing you figure out from experience/mentoring.
13:07:37 <albeit> lispy: Ha fair enough. Thanks for the help today!
13:07:52 <lispy> albeit: in general, I don't think operational things express intent very clearly.
13:08:18 <albeit> lispy: What do you mean by "operational" things?
13:08:44 <lispy> constructs that express how to compute something. like a for loop
13:09:10 <lispy> essentially, the things imperative languages focus on
13:12:14 <ReinH> albeit: one general suggestion I think I can make is to try to separate the structure of a computatiom from the data being computed over
13:12:51 <shapr> #haskell's thirteen year anniversary is in twelve days! at least, according to chanserv
13:13:33 <ReinH> shapr: nice!
13:13:48 <shapr> ReinH: I think this calls for a virtual code party.
13:14:09 <ReinH> party!!
13:14:10 <shapr> Perhaps we can invite such luminaries as edwardk and dons and bos
13:14:38 <ReinH> heh
13:14:53 <shapr> and of course Cale !
13:15:09 <shapr> maybe even lambdabot will be there!
13:15:16 <ReinH> This is all very exciting
13:16:03 <bitemyapp> Cale: May I ask you for some pointers on how to improve my library? I was told you'd be a good person to ping.
13:16:08 <nschoe> shapr, is one could write a anniversary mod for lambda bot, that would be awesome ^^
13:16:21 <shapr> nschoe: do it!
13:16:22 <bitemyapp> perhaps a bot that spews ASCII confetti?
13:16:45 <peer2cx> http://learnyouahaskell.com/syntax-in-functions#let-it-be
13:16:45 <peer2cx> Search for "Just like any construct in Haskell" please
13:16:55 <peer2cx> It says, "Just like any construct in Haskell that is used to bind values to names, let bindings can be used for pattern matching. "
13:17:07 <nschoe> shachaf, ah ^^
13:17:09 <peer2cx> "Just like any construct"
13:17:17 <peer2cx> Can you name me all the other examples of such constructs?
13:17:29 <merijn> peer2cx: Where, case, top level definitions
13:17:53 <merijn> lambda's
13:17:55 <peer2cx> merijn: what about pattern matching for functions?
13:18:10 <merijn> peer2cx: I counted those under top level definitions, so yeah
13:18:14 <peer2cx> ok
13:18:24 <merijn> peer2cx: But you can define functions in where and let too
13:18:36 <merijn> peer2cx: So really top level functions aren't very special
13:18:41 <peer2cx> ok
13:19:12 <corgifex> LHS of <-
13:19:18 <corgifex> do/list comprehension
13:20:30 <bitemyapp> ReinH: any ideas for bribing more experienced Haskellers into offering advice on improving a library?
13:20:51 <bitemyapp> Best idea I have so far is a stack of ale.
13:21:05 <vhz> bitemyapp: a stack of money maybe ?
13:21:47 <bitemyapp> vhz: I think we're talking a 5-15 minute perusal.
13:22:00 <bitemyapp> less time than it often takes to talk somebody through how >>= works in IRC.
13:22:46 <vhz> bitemyapp: you can use nigerian dollar stack then ;)
13:24:14 <bitemyapp> paid code reviews would be kinda cool.
13:24:46 <nschoe> I've just heard about record wildcard patterns (myFunction MyDataType{..}). It seems "magical" (no need to list all fields anymore). Can anyone tell me if there is something behind this like heavy payload ? Why is it not more used ?
13:25:01 <Cale> bitemyapp: Which library is this?
13:25:51 <bitemyapp> Cale: https://github.com/bitemyapp/bloodhound/
13:26:32 <lispy> nschoe: It's really just about name reuse so it should be cheap. I'm not sure why more people don't use it. I like it and my co-workers use it too.
13:26:58 <lispy> shapr: awesome!
13:27:13 <nschoe> lispy, okay. Well I'll use it too then, cause it sure is handy
13:29:19 <savanni> Is there a metaphore or typeclass or some such that looks like Functor, but operates on types of kind *?
13:29:23 <Cale> This code looks very reasonable. Have you run into any problems with using it?
13:29:46 <bitemyapp> Cale: no, I just want more prettiness/awesomeness.
13:29:48 <monochrom> savanni: can you write down the type sigs of the methods you want it to have?
13:30:00 <bitemyapp> Cale: 'tis my first Haskell library.
13:30:20 <Cale> You have an unconventional way to write where clauses :)
13:30:32 <bitemyapp> Cale: I do?
13:30:41 <savanni> Well, actually... `(a -> b) -> Image -> b`
13:31:00 <savanni> Where "Image" has six constructors, and a->b is an operation that can work on any of them.
13:31:10 <savanni> Oh, wait...
13:31:23 <Cale> Usually, people will put 'where' at the beginning of the next line and hang things off of it, rather than leaving it at the end of a line
13:31:40 <bitemyapp> Cale: do you think my approach harms readability?
13:31:52 <savanni> What I said is true, even though the various constructors inside Image have different types.
13:31:52 <Cale> With github's highlighting it doesn't
13:31:53 <vhz> Cale: It's not that uncommon, I see this style every now and then
13:32:08 <Cale> In plaintext, it would be a bit weird, because you'd have to look for the 'where' at the end of the line
13:32:26 <bitemyapp> hrm, I'll keep that in mind.
13:32:31 <quchen> I use in-line 'where' when the definition is very short and relies on a lot of stuff in the 'where'. When the main definition is large, the hanging version is more readable.
13:32:33 <bitemyapp> Cale: anything else I could improve?
13:32:52 <bitemyapp> quchen: that's more or less the case (former) for my code.
13:33:38 <monochrom> savanni: then there is no type class for that. except maybe you can create it yourself. but I doubt that it is worth the effort. since only one instance, Image, benefits from it.
13:35:16 <savanni> Lookin glike it, really.  It may not even be as easy as I expected, anyway.
13:36:51 <ReinH> bitemyapp: It buries the lead
13:37:01 <ReinH> bitemyapp: (putting the where at the end of the line)
13:37:21 <lispy> savanni: I think you're describing a fold
13:37:23 <ReinH> I like the introduction of new scopes to be as clear as possible
13:37:30 <bitemyapp> ReinH: lede
13:37:33 <ReinH> and the indentation isn't quite enough for me
13:37:44 <ReinH> bitemyapp: both are used, lead actually gets me less "corrections" :)
13:38:04 <ReinH> (http://en.wiktionary.org/wiki/bury_the_lede)
13:38:06 <bitemyapp> lede's more specific.
13:38:11 <ReinH> ok :)
13:38:15 <bitemyapp> English doesn't need more homonyms.
13:38:21 <bitemyapp> ReinH: Convincing argument.
13:38:23 <lispy> savanni: and each data type tends to need a different fold
13:38:29 <bitemyapp> ReinH: but is there anything more substantial that could be improved?
13:38:44 <lispy> savanni: the exception being Foldable/Traversable
13:39:35 <ReinH> (lede is an intentional  misspelling (or reversion to an anachronistic spelling) of lead to avoid confusion with its homograph, the heavy grey metal)
13:40:01 <ReinH> bitemyapp: I try to provide code review in order of important. Everything else looks pretty ok. :)
13:40:09 <ReinH> *importance
13:40:20 <AngryRam> is there a more concise way to do this ?? concat ["X" | n <- [1..10]]
13:40:29 <bitemyapp> ReinH: the code base cannot possibly be so good as to make the where clause placement the most important thing :P
13:40:36 <ReinH> > replicate 10 "X"
13:40:36 <lispy> :t repeate
13:40:37 <lambdabot>     Not in scope: ‘repeate’
13:40:37 <lambdabot>     Perhaps you meant one of these:
13:40:37 <lambdabot>       ‘repeat’ (imported from Data.List),
13:40:37 <lambdabot>  ["X","X","X","X","X","X","X","X","X","X"]
13:40:40 <ReinH> woops
13:40:44 <lispy> doh
13:40:48 <bitemyapp> > replicateM 10 "X"
13:40:49 <lambdabot>  ["XXXXXXXXXX"]
13:40:49 <ReinH> > replicate 10 'X'
13:40:51 <lambdabot>  "XXXXXXXXXX"
13:40:53 <lispy> yeah, that
13:41:06 <ReinH> you're replicating the Char not the [Char], doh
13:41:10 <lispy> I always mix up repeat and replicate
13:41:13 <AngryRam> replicate and repeat give array, not string
13:41:19 <ReinH> bitemyapp: dunno, on a cursory glance it seemed pretty ok
13:41:22 <AngryRam> i want "XXXX" ... N times
13:41:27 <vanila> :t repeat
13:41:28 <lambdabot> a -> [a]
13:41:29 <vanila> :t replicate
13:41:30 <ReinH> AngryRam: a string is an array
13:41:31 <lambdabot> Int -> a -> [a]
13:41:33 <bitemyapp> ReinH: I need to turn on the more magic switch.
13:41:34 <vanila> > replicate 3 'X'
13:41:35 <lambdabot>  "XXX"
13:41:35 <ReinH> well, a list
13:41:53 <lispy> :t replicate 10 'X' :: String
13:41:54 <lambdabot> String
13:42:03 <AngryRam> hmmm why  replicate 3 "X"  =>  ["X","X","X"]
13:42:12 <monochrom> array of array
13:42:12 <vanila> AngryRam, "X" is ['X']
13:42:14 <AngryRam> but replicate 3 'X' => "XXX"
13:42:14 <bitemyapp> AngryRam: "" is [Char]
13:42:14 <lispy> :t replicate 10 "X"
13:42:15 <lambdabot> [[Char]]
13:42:36 <AngryRam> go it! ty
13:42:39 <AngryRam> *got
13:42:41 <lispy> AngryRam: list of chars (aka String) vs. list of strings
13:43:29 <ReinH> bitemyapp:  a few consistency things. You have some functions of type Server -> IndexName -> b and some of type Server -> a -> IndexName -> b
13:43:37 <ReinH> bitemyapp: I would make the latter of type Server -> IndexName -> a -> b
13:44:12 <ReinH> bitemyapp: I would also make joinPath take a Server and an IndexName since the only thing you do with the pattern matching on those types is to send them to joinPath
13:44:57 <ReinH> bitemyapp: Ah, I see. You want joinPath to take multiple "arguments" so it takes a list
13:45:35 <bitemyapp> ReinH: homogenizing the types is required unless I want to get myself into some muck.
13:45:38 <ReinH> bitemyapp: I'd probably write helpers get, put, post, delete for get = dispatch methodGet and etc
13:45:47 <bitemyapp> ReinH: sensible.
13:46:04 <aviraldg> monochrom, I read the page you linked me to earlier.
13:46:23 * bitemyapp takes notes
13:46:27 <bitemyapp> ReinH: this is very good advice, thank you.
13:46:36 <bitemyapp> ReinH: any suggestions on the multi-arity path squashing thing?
13:47:01 <ReinH> bitemyapp: I'd also make dispatch take the url last
13:47:03 <aviraldg> http://lpaste.net/102798 is what I was referring to earlier
13:47:12 <ReinH> so delete = methodDelete Nothing
13:47:16 <bitemyapp> ReinH: oh right, better order of variance.
13:47:18 <ReinH> can be partially applied to
13:47:24 <aviraldg> solve'' should be more efficient than solve, correct?
13:47:31 <ReinH> since delete never has a payload
13:47:53 <ReinH> and if useful you can define post_ = methodPost Nothing for POSTs that don't have a body, etc
13:47:54 <aviraldg> (because of tail-recursion?)
13:48:08 <ReinH> dispatch methodPost Nothing, but yeah
13:48:13 <aviraldg> (And indeed, running both shows the same)
13:48:33 <bitemyapp> ReinH: well, post will have to take a body argument.
13:48:37 <bitemyapp> ReinH: it wouldn't be Nothing
13:48:44 <aviraldg> What's confusing though is that as solve'' runs ghc does tend to allocate more memory -- why?
13:49:16 <ReinH> bitemyapp: not all posts require a body
13:49:21 <monochrom> aviraldg: both build up, without evaluating, a lot of "1 + (1 + ..." and "... + 2) + 2"s
13:49:22 <lispy> aviraldg: I think it's faster for other reasons like worker/wrapper or spec constr optimizations
13:49:25 <ReinH> bitemyapp: but that's not important
13:49:44 <bitemyapp> ReinH: ohhh you're right.
13:49:46 <ReinH> bitemyapp: I think you can extract the equipment for generating URLs a bit better, perhaps with a typeclass
13:50:00 <lispy> (actually, not sure if ghc can do the worker/wrapper here or not)
13:50:04 <aviraldg> sorry, not faster
13:50:04 <bitemyapp> ReinH: I did briefly considered a typeclass but wanted to be cautious about it.
13:50:10 <bitemyapp> ReinH: how do you think that would look, roughly?
13:50:11 <ReinH> bitemyapp: always calling joinPath in methods that call dispatch is a smell
13:50:14 <aviraldg> solve uses a lot more memory than solve''
13:50:15 <bitemyapp> Right.
13:50:19 <lispy> aviraldg: ah, that is what I would expect
13:50:22 <ReinH> bitemyapp: it depends on how many variations of joinPath you have
13:50:35 <aviraldg> that's what I should've said
13:50:37 <aviraldg> :)
13:50:42 <aviraldg> Why?
13:50:53 <aviraldg> And how should I optimise this?
13:51:00 <bitemyapp> ReinH: it's hypothetically n-ary.
13:51:11 <lispy> aviraldg: did you read monochrom's article about laziness?
13:51:44 <ReinH> bitemyapp: right, that's a problem :)
13:51:47 <lispy> aviraldg: once you understand laziness just a tiny bit better, then the behavior here will start to make sense.
13:51:48 <aviraldg> I did. Shouldn't the version with the accumulator fix that?
13:52:07 * monochrom should just walk away. solve is analogous to the foldr example. solve' is analogous to the foldl example. enough said already.
13:52:11 <ReinH> bitemyapp: but you can write a path monoid
13:52:33 <ReinH> and join with (the moral equivalent of) <> rather than concat
13:52:56 <aviraldg> sorry, I'll go through it again
13:52:58 <ReinH> (</>) :: PathElement a => a -> a -> a
13:53:16 <aviraldg> (I'll admit I only skimmed through -- so that's my fault!)
13:53:27 <monochrom> also it has an explicit sentence "So-called “tail call” is utterly irrelevant. After reading this example, please do me a favour: never ask about “tail call” again.".
13:53:42 <lispy> aviraldg: Something you might try is writing out the terms you get from plugging in some numbers
13:53:43 <monochrom> Please do me a favour: never ask about "tail call" again.
13:53:57 <lispy> aviraldg: pay attention to long sequences of operations that build up but are never demanded
13:54:22 <ReinH> bitemyapp: for example: indexDocument s ix name doc = put (root </> s </> ix </> name </> doc) (Just encode doc)
13:54:44 <ReinH> bitemyapp: not exactly a monoid, but you know what I mean
13:54:50 <lispy> aviraldg: monochrom was trying to show you such an exmaple when he wrote: < monochrom> aviraldg: both build up, without evaluating, a lot of "1 + (1 + ..." and "... + 2) + 2"s
13:56:57 <mgccl> Is there a way, depend on the different type class of input, the function does something different? say a function "removeDuplicate" that behaves differently if the input is Ord or Eq.
13:57:05 <athan> Do any language extensions include or load any other language extensions by default? Or, really, can their functionality be expressed in a heirarchy, even if one language pragma doesn't actually expose another literally?
13:57:08 <jle`> is there a non associative monoid typeclasses
13:57:12 <jle`> typeclass
13:57:27 <tac> I think Num does that >__>
13:58:07 <ReinH> jle`: does it have identity?
13:58:28 <jle`> ReinH: suppose yes
13:58:52 <ReinH> jle`: not afaik, but if there's a Magma class then Maybe (Magma a) is that.
13:58:53 <Eduard_Munteanu> mgccl: class Nubbable a where nub :: [a] -> [a]; newtype ByOrd a = ByOrd a; instance (Ord a) => Nubbable (ByOrd a) where nub = ...
13:58:56 <jle`> and then suppose no :)
13:59:04 <jle`> ah I see
13:59:05 <ReinH> I don't know if there's a Magma class.
13:59:05 * aviraldg realizes he didn't read that far. :(
13:59:11 <jle`> Magma
13:59:23 <ReinH> well, if the set is already equipped with an identity element then that's not what you want
13:59:31 <ReinH> jle`: so afaik there isn't one
13:59:41 <jle`> ty
13:59:51 <ReinH> magmas and are not very useful genereally afaik, even with identities
13:59:54 <ReinH> s/and //
14:00:00 <ReinH> bitemyapp: does any of that make sense
14:00:00 <Eduard_Munteanu> athan: there are a few cases of LANGUAGE pragmas that subsume others, like Rank2Types < RankNTypes.
14:00:34 <mgccl> Eduard_Munteanu: thanks, so I do have to create a new typeclass for this...
14:00:36 <bitemyapp> ReinH: somewhat?
14:00:45 <quchen> Isn't Rank2Types identical to RankNTypes in GHC, Eduard_Munteanu?
14:00:52 <ReinH> bitemyapp: what you'd actually have is probably (</>) :: Pathable a => a -> a -> Path, where Path instantiates Pathable as well. And then your dispatch would turn the Path into a URL
14:00:55 <quchen> (Conceptually there's a difference, of course.)
14:01:05 <ReinH> bitemyapp: it's not quite a monoid but it is morally similar
14:01:16 <bitemyapp> ReinH: well it's a semigroup right?
14:01:25 <ReinH> bitemyapp: no, because it isn't a -> a -> a
14:01:28 <Eduard_Munteanu> quchen: hm, is it? I'd expect Rank2Types to reject rank 3 types, that'd be a simple check.
14:01:32 <bitemyapp> ReinH: oh right.
14:01:39 <ReinH> bitemyapp: but it's composable in the way you want a semigroup to compose
14:01:45 <bitemyapp> ReinH: so a magma like you mentioned then?
14:01:49 <athan> Eduard_Munteanu: I'm mainly concerned with FlexibleContexts and TypeFamilies. In TypeFamilies, I see a lot of functionality included - type/data synonyms and the "family" keyword are included, but would it also include MultiParameterTypeClasses for simple instance-based type "functions"/bijections?
14:01:52 <ReinH> bitemyapp: no, it's still associative :)
14:01:58 <bitemyapp> gahhhhh
14:01:58 <Eduard_Munteanu> mgccl: there's no adhoc overloading in Haskell, no
14:02:29 <Eduard_Munteanu> athan: it doesn't subsume MPTCs, no
14:02:30 <quchen> Eduard_Munteanu: "[...] -XRank2Types are synonyms for -XRankNTypes." http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification
14:02:34 <ReinH> Eduard_Munteanu: unless you want to have an argument about whether typeclasses are ad hoc
14:02:38 <Eduard_Munteanu> Ah.
14:02:39 <bitemyapp> ReinH: I think there is a Monoid here.
14:02:44 <ReinH> bitemyapp: there can't be. :)
14:02:48 <ReinH> there is a category though
14:02:59 <bitemyapp> ReinH: separate a -> Path/URL function
14:03:28 <bitemyapp> wait, the identity doesn't make a ton of sense. I'd have to think about it.
14:03:32 <ReinH> a -> a -> a isn't realizable, a -> a -> Path is.
14:03:33 <athan> Eduard_Munteanu: So there's no general taxonomy or classification of language pragmas?
14:03:34 <bitemyapp> because it's server specific.
14:03:37 <Eduard_Munteanu> ReinH: it's less adhoc than whatever C++ lets you do to normal functions
14:03:50 <athan> Eduard_Munteanu: Thank you for your help too :)
14:03:51 <ReinH> bitemyapp: actually it's (Pathable a, Pathable b) => a -> b -> Path
14:03:58 <ReinH> bitemyapp: and *that's* why it isn't a monoid
14:04:05 <ReinH> bitemyapp: because a and b can be different types
14:04:10 <ReinH> (or a semigroup)
14:04:28 <Eduard_Munteanu> athan: no, they just happen to overlap a bit
14:04:57 <ReinH> Eduard_Munteanu: the original paper called it, basically, "better ad hoc polymorphism", which was wrong but useful characterization :)
14:05:10 <ReinH> Eduard_Munteanu: which is I think why it keeps coming up that typeclasses are ad hoc
14:05:22 <ReinH> (purposefully wrong, as in a lie told to children)
14:05:24 <bitemyapp> ReinH: oh I see, you're not assuming the destructuring into strings.
14:05:52 <ReinH> bitemyapp: Pathable a => a -> a -> Path would not let you combine a Server with a MappingName
14:05:53 <Eduard_Munteanu> Perhaps it is adhoc polymorphism as opposed to parametric polymorphism.
14:05:55 <bitemyapp> ReinH: I don't know if that's nicer or not. I'd have to refine it. I don't know if I want ad-hoc destructuring to happen in the typeclass as opposed to the function fronting it.
14:06:03 <bitemyapp> ReinH: right, but again, I was assuming a was string.
14:06:16 <Eduard_Munteanu> But I sort of literally meant that as "adhoc overloading". :)
14:06:26 <ReinH> bitemyapp: the point is that you're only pattern those types to do exactly one thing in a repeatable way
14:06:39 <ReinH> Eduard_Munteanu: ah sorry :)
14:06:43 <bitemyapp> yeah, and I do need to kill that redundancy.
14:06:47 <ReinH> bitemyapp: ok :)
14:06:54 <ReinH> *pattern matching
14:07:00 <bitemyapp> ReinH: I've got to bebop over to a coffeeshop for working, I think you've got me on the right path for improving this. Thank you very much :)
14:07:05 <ReinH> bitemyapp: no prob :)
14:07:05 <bitemyapp> ReinH: also, what'd you think of the Seminearring? :)
14:07:07 <deweyvm> typeclasses arent ad-hoc polymorphism?
14:07:16 <ReinH> bitemyapp: also you could write a Free REST monad
14:07:36 <Eduard_Munteanu> deweyvm: they are FSVO adhoc
14:07:39 <bitemyapp> ReinH: I'm not sure what I'd be nesting.
14:07:50 <ReinH> bitemyapp: clever :)
14:08:01 <bitemyapp> ReinH: what is?
14:08:04 <ReinH> bitemyapp: RESTful requests and responses
14:08:07 <ReinH> bitemyapp: the seminearring
14:08:17 <bitemyapp> ReinH: I'm glad you like it.
14:08:20 <bitemyapp> I was quite proud of it.
14:08:23 <deweyvm> fsvo?
14:08:35 <ReinH> for some value of
14:08:39 <deweyvm> oh haha
14:09:07 <ReinH> bitemyapp: Here's a free REST monad for your perusal https://github.com/supki/libjenkins/blob/master/src/Jenkins/Rest/Internal.hs
14:09:20 <ReinH> I'm thinking about extracting it and generalizing
14:09:22 <dwat3r> hi guys,i can't figure out what is the problem with my code,can you help me? http://pastebin.com/Tv4xPzgM
14:09:50 <bitemyapp> ReinH: oh, there's a reason specific to elasticsearch I don't do this.
14:09:54 <ReinH> bitemyapp: also check out the lenses for manipulating requests
14:10:17 <bitemyapp> ReinH: there are specific multi-get/multi-search/bulk-operation APIs and I don't want to mislead people into thinking any Free monadic DSL would be doing that automagically for them.
14:10:27 <ReinH> bitemyapp: I extracted some of the lenses here http://hackage.haskell.org/package/http-client-lens
14:10:33 <ReinH> they might be useful to you
14:10:45 <Eduard_Munteanu> dwat3r: you seem to have indentation issues
14:10:57 <ReinH> bitemyapp: ah but it might if you define the right interpreter :)
14:11:03 <bitemyapp> ReinH: they will be when I clean up the error cases. Thank you.
14:11:14 <ReinH> bitemyapp: see also HAXL
14:11:23 <ReinH> (which is, iirc, free applicative though?)
14:11:31 <Eduard_Munteanu> dwat3r: likely you're using tabs and you have configured your editor to display them as something else than 8 spaces.
14:11:32 <bitemyapp> ReinH: yeah, applicative.
14:11:34 <bitemyapp> bbiab.
14:12:23 <dwat3r> Eduard_Munteanu: yes,i pasted it wrong,sorry,but if you fix it,you'll see a type error,and I'm sitting before it for hours now
14:12:47 <Eduard_Munteanu> dwat3r: what is the error?
14:12:57 <ReinH> ooh http://paolocapriotti.com/assets/applicative.pdf awesome
14:13:38 <ReinH> shame it wasn't accepted
14:13:59 <dwat3r> Eduard_Munteanu: http://pastebin.com/0g9jKtYk
14:14:04 <dwat3r> this
14:16:21 <Eduard_Munteanu> dwat3r: you can never write a getf given its type
14:17:39 <damn_connection> I am very new to haskell and something which I do not understand is when to use . and $. To me "f . g . h $ x" does exactly the same thing as "f $ g $ h x". When should you use each?
14:18:00 <dwat3r> Eduard_Munteanu: can you give me a hint,what should I correct?
14:18:27 <Rarrikins> damn_connection: Use . when possible
14:18:30 <Eduard_Munteanu> dwat3r: the problem is 'b' is unconstrained, it can be *any* type.
14:18:45 <Eduard_Munteanu> dwat3r: likely you intended to make a class parametrized by both a and b
14:19:02 <damn_connection> Rarrikins: what is the advantage of doing that?
14:19:24 <Rarrikins> damn_connection: It gives more information.
14:20:13 <ReinH> damn_connection: it might be instructive to use parentheses to show the evaluation order of both expressions
14:20:20 <Eduard_Munteanu> dwat3r: also notice setf must ignore its b-typed argument, by a similar reasoning as above
14:20:23 <ReinH> er not evaluation order
14:20:30 <dwat3r> Eduard_Munteanu: i see,so this is not the way for writing getters and setters
14:20:31 <ReinH> word my brain has forgotten
14:21:02 <damn_connection> Rarrikins: Forgive me but I am new to this. What extra information does it give?
14:21:18 <ReinH> damn_connection: f . g . h $ x = (f . g . h) x, which hints that f' = (f . g . h) might be some useful thing.
14:21:28 <dwat3r> Eduard_Munteanu: I suppose i could check bounds with lenses
14:21:44 <Eduard_Munteanu> dwat3r: check bounds?
14:21:58 <ReinH> damn_connection: whereas f $ g $ h $ x does not give the same intent
14:22:06 <Eduard_Munteanu> dwat3r: 'lens' does address the same issue, yes.
14:22:34 <owlglass>  /join #raspberrypi
14:22:37 <owlglass> oops
14:23:52 <dwat3r> Eduard_Munteanu: yes,this whole type class is about to make a setter which ensures that the user doesn't change the field's value to an invalid one,you know, for example if a BitField Word8 is 4 bits long,then it can't store a value like 255
14:24:10 <damn_connection> ReinH: So you couldn't define a function f' = f $ g $ h?
14:24:29 <dwat3r> Eduard_Munteanu: and I also want it to be generalized between these two datatypes, BitField and StringField
14:24:54 <ReinH> damn_connection: f $ g $ h $ x = f (g (h x)), which is equivalent, but doesn't inform the programmer that the intent is for the composition f, g, and h to be a meaningful thing on its own
14:25:24 <ReinH> damn_connection: also if you see go x = f . g . h $ x then you can immediately eta reduce to go = f . g . h, yes
14:25:29 <ReinH> damn_connection: which favors a compositional style
14:26:04 <dwat3r> Eduard_Munteanu: maybe I could just put these two data-s into one, like: data Field a = BitField a | StringField
14:26:12 <Eduard_Munteanu> dwat3r: your classes only address a value given its type... how are you going to make different getters/setters for, say, a pair of BitFields?
14:26:40 <Eduard_Munteanu> dwat3r: I think 'lens' covers that case too.
14:26:46 <ReinH> damn_connection: I actually prefer (f . g . h) x to f . g . h $ x for that reason
14:26:53 <ReinH> and I prefer both to f $ g $ h $ x
14:27:36 <dwat3r> Eduard_Munteanu: i see. thanks for your advice :)
14:27:39 <ReinH> and also in very small part because (f . g . h) is easier to extract with my text editor ;)
14:27:46 <damn_connection> ReinH: (f . g . h) x being equivalent to f(g(h(x))) right?
14:27:51 <ReinH> damn_connection: right
14:28:01 <ReinH> damn_connection: well, \x -> (f . g . h) x to be precise
14:28:13 <ReinH> which can be immediately eta reduced
14:28:27 <Eduard_Munteanu> dwat3r: however I think setter failure could be addressed separately, e.g. make a  newtype Word4 = Word4 Word8  and only allow construction through a function that checks the value, e.g. mkWord4 :: Integer -> Maybe Word4
14:28:30 <aviraldg> lispy, I read through the page again, in detail and completely this time. I do understand why they're inefficient now. Shouldn't they allocate memory at approximately the same rate, though?
14:28:41 <jle`> sometimes f . g $ h x is used too
14:28:45 <ReinH> damn_connection: then I see that thing in brackets and wonder "Can I give that a meaningful name instead?"
14:29:01 <ReinH> jle`: right, it depends on whether the more generally composable thing is f . g or f . g . h
14:29:05 <ReinH> at least for me
14:29:10 <Eduard_Munteanu> dwat3r: then the user would not be able to set that field because they would not be able to make a malformed Word4.
14:29:22 <jle`> ReinH: yeah, that is a good rule
14:29:24 <ReinH> this is again why I prefer brackets to ($)
14:29:42 <ReinH> it lets me be explicit about what things I intend to compose
14:29:58 <ReinH> and is a smell that maybe I should introduce a new name
14:30:11 <damn_connection> ReinH: Ah okay, thanks. I'm messing around with Project Euler at the moment and keep coming across patterns like this.
14:30:17 <ReinH> and is an easier to execute editor transformation to extract
14:30:52 <ReinH> damn_connection: you might want to look at some of Richard Bird's stuff. It really demonstrates the expressiveness of that style
14:31:02 <ReinH> a bunch of $'s would just look out of place and ugly
14:31:20 <damn_connection> Whilst I'm here and you are being very helpful, can somebody explain to me what the heck a fold is?
14:31:30 <ReinH> damn_connection: maybe start with http://www.cs.dartmouth.edu/~cs8/F2011/notes/11/Sudoku.lhs
14:32:01 <ReinH> damn_connection: a fold takes a list of things and a way to combine two things and uses that to combine ALL THE THINGS
14:32:10 <dwat3r> Eduard_Munteanu: wow,thats a very good idea!
14:32:10 <ReinH> (it can be generalized to structures other than lists but let's start there)
14:32:17 <Eduard_Munteanu> damn_connection: generally it refers to reducing a larger structure to a single value
14:32:33 <ReinH> > foldl (+) 0 [1..4] :: Expr
14:32:34 <lambdabot>  0 + 1 + 2 + 3 + 4
14:32:35 <ReinH> > foldl (+) 0 [1..4]
14:32:37 <lambdabot>  10
14:32:38 <Eduard_Munteanu> (although that value can be another structure)
14:33:04 <ReinH> Eduard_Munteanu is also (more) correct.
14:33:30 <Eduard_Munteanu> > foldr (:) [] [1,2,3,4] -- is reducing a list to the same list :)
14:33:31 <lambdabot>  [1,2,3,4]
14:33:32 <ReinH> there are different folds for different ways of grouping the operations
14:33:57 <Eduard_Munteanu> > foldr (:) [] [a,b,c,d] :: Expr
14:33:58 <lambdabot>  Couldn't match type ‘[Debug.SimpleReflect.Expr.Expr]’
14:33:58 <lambdabot>                with ‘Debug.SimpleReflect.Expr.Expr’
14:33:58 <lambdabot>  Expected type: Debug.SimpleReflect.Expr.Expr
14:33:58 <lambdabot>                 -> Debug.SimpleReflect.Expr.Expr -> Debug.SimpleReflect.Expr....
14:33:58 <lambdabot>    Actual type: Debug.SimpleReflect.Expr.Expr
14:34:07 <ReinH> damn_connection: http://en.wikipedia.org/wiki/Fold_(higher-order_function) is a nice introduction with pictures :)
14:34:13 <Eduard_Munteanu> > foldr (:) [] [a,b,c,d :: Expr]
14:34:15 <lambdabot>  [a,b,c,d]
14:34:30 <ian_mi> has anyone considered generalizing recursion schemes the other way (i.e. with monads instead of comonads or vice versa)?
14:34:56 <ian_mi> e.g. gcata' ∷ (Foldable t, Monad m) ⇒ (Base t (m a) → m (Base t a)) → (Base t a → m a) → t → m a
14:35:09 <Eduard_Munteanu> > foldr (:) e [a,b,c,d :: Expr]
14:35:10 <lambdabot>  Couldn't match expected type ‘[Debug.SimpleReflect.Expr.Expr]’
14:35:10 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
14:35:28 <Eduard_Munteanu> (Ignore all these.)
14:35:30 <ReinH> Eduard_Munteanu: the identity list homomorphism? :)
14:35:58 <ReinH> ian_mi: probably edwardk has but I dunno
14:36:05 <ReinH> I just assume he's already thought of everything
14:36:44 <Eduard_Munteanu> I figured I'd start with corner cases first. :P
14:37:24 <ReinH> Eduard_Munteanu: actually the identity one is a nice jumping off point :)
14:38:07 <ReinH> Eduard_Munteanu: since it's easy to get to "map is a fold" and some of the fold fusion laws
14:39:59 <damn_connection> ReinH: Speaking of map, is this an efficient function? I find myself using it far more than it appears I should.
14:40:43 <ReinH> damn_connection: Well, it operates in O(n).
14:40:54 <monochrom> it is efficient
14:41:01 <ReinH> it's as efficient as it can be
14:41:38 <ReinH> if you're doing a lot of map f (map g xs) then you might be interested to know that this is equivalent to map (f . g) xs
14:42:01 <ReinH> and also to know that GHC will usually perform that optimization for you
14:42:08 <ReinH> (if you compile with optiizations enabled)
14:42:10 <Eduard_Munteanu> @free map
14:42:11 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
14:42:31 <damn_connection> ReinH: I guess I mean sometimes I am probably replicating functionality provided by built in functions but using a ton of maps due to me having little knowledge of how to use them
14:42:32 <Eduard_Munteanu> Free advice!
14:42:33 <Eduard_Munteanu> :P
14:42:35 <ReinH> Eduard_Munteanu: :D
14:42:53 <ReinH> damn_connection: Perhaps you are. Do you have any examples?
14:42:58 <aviraldg> Hey, monochrom
14:43:04 <aviraldg> I read your page again
14:43:45 <damn_connection> ReinH: Ah unfortunately I'm on the wrong computer. I'll have a flick through my dropbox to see if I have any examples on there
14:44:10 <aviraldg> according to it, solve and solve' should take the same space on the stack, correct? (any difference in the allocation rate is due to a difference in speed?)
14:45:51 <monochrom> yes
14:46:14 <aviraldg> thanks then :)
14:46:14 <Kiryx> Hey, How can I easily turn a string "1.0 2.0 3.0" into a list of integers or a tuple ?
14:46:26 <Kiryx> sorry, a list of float
14:46:26 <aviraldg> sorry for wasting your time earlier (by not reading it properly)
14:46:33 <monochrom> > words "1.0 2.0 3.0"
14:46:34 <lambdabot>  ["1.0","2.0","3.0"]
14:46:39 <monochrom> that's the first step
14:46:51 <monochrom> > map read ["1.0","2.0","3.0"]
14:46:52 <lambdabot>  [*Exception: Prelude.read: no parse
14:46:58 <monochrom> err, need type annotation
14:47:03 <Kiryx> ah
14:47:03 <monochrom> > map read ["1.0","2.0","3.0"] :: [Double]
14:47:04 <lambdabot>  [1.0,2.0,3.0]
14:47:06 <Kiryx> :)
14:47:09 <monochrom> that's the second step
14:47:10 <Kiryx> Beautiful
14:47:17 <Kiryx> Thanks
14:48:23 <ReinH> (if you don't want a runtime exception while handling untrusted data then you might want something other than read)
14:48:47 <ReinH> like readMaybe
14:49:35 <ReinH> but you said "easily", not "correctly"... ;)
14:49:37 <Kiryx> I see. I'm certain of input, but thanks :)
14:49:41 <ReinH> ok :)
14:50:57 <napping> I'd like a monad with some common functionality, but access to varying local state. Is something with a free Reader-style parameter a good way to go?
14:51:26 <damn_connection> ReinH: Well as a solution to projecteuler.net/problem=17 I am doing "sum . map length . concat . map intToString $ [1..1000]" where intToString is another map (takes an integer and outputs that integer in words e.g. 107 -> "one hundred and seven").
14:51:49 <damn_connection> ReinH: could this be rewritten more readably/concisely
14:52:30 <monochrom> it can be rewritten more concisely and unreadably
14:52:41 <ReinH> well, sum . map length = length . concat, right?
14:52:48 <ReinH> how do I quickcheck that here?
14:52:50 <monochrom> it can't be rewritten more readably
14:52:58 <ReinH> damn_connection: but there's nothing wrong with it
14:53:30 <quchen> @check \xs -> reverse (reverse xs) == xs
14:53:33 <lambdabot>  +++ OK, passed 100 tests.
14:53:35 <Rarrikins> @quickcheck \xs -> (sum . map length) xs == (length . concat) xs
14:53:36 <lambdabot> Unknown command, try @list
14:53:39 <monochrom> @check (\x -> (sum . map length) x == (length . concat) x)
14:53:41 <Rarrikins> @check \xs -> (sum . map length) xs == (length . concat) xs
14:53:41 <lambdabot>  +++ OK, passed 100 tests.
14:53:43 <lambdabot>  +++ OK, passed 100 tests.
14:53:44 <ReinH> thanks
14:54:03 <napping> damn_connection: what's the type of intToString? I see one more concat than I would expect
14:54:05 <ReinH> so you could say length . concat . concat . map intToString if you think that's better
14:54:08 <ReinH> or not
14:54:10 <monochrom> @type length . concat
14:54:11 <lambdabot> [[a]] -> Int
14:54:31 <monochrom> then it uses [[()]] -> Int for the tests :)
14:54:37 <jle`> hi, anyone here use pipes-parse
14:54:41 <ReinH> monochrom: well that's fine :p
14:54:46 <ReinH> the contents don't matter
14:54:58 <jle`> i'm sure there must be some shorthand for this common idiom
14:55:02 <ReinH> and length :: [()] is isomorphic to sum so it makes sense
14:55:06 <ReinH> er
14:55:08 <damn_connection> napping: Int -> [String]
14:55:17 <napping> oh, it gives you a list of words.
14:55:21 <ReinH> I think you know what I mean despite my notational failure
14:55:27 <napping> and you want the total number of characters, not counting spaces?
14:55:56 <napping> well, it's pretty good already, but it might read a bit more clearly as summing the sizes of the string representations
14:56:07 <ReinH> [()] ~ Nat, length [()] ~ sum
14:56:07 <napping> like sum . map (length . concat . intToString) $ [1..1000]
14:56:11 <damn_connection> napping: yes but there are no spaces at any point, I should have made that clear, sorry.
14:56:24 <jle`> parserToProducer :: Parser a m b -> Producer a m r -> Producer b m r
14:56:36 <napping> well, you'd probably do unwords . intToString if you actually wanted to print the value
14:57:07 <jle`> parserToProducer parser producer = do { (res,lov) <- lift (runStateT parser producer); yield res; parserToProducer parser lov }
14:57:28 <jle`> there must be some identity somewhere i am missing :|
14:57:36 <jle`> or some common utility function
14:58:37 <ReinH> still not quite right but whatever
14:59:23 <kallisti> algorithm question: let's say I have a rectangle that's NxM, and I want to divide it into N subrectangles. What would be the best way to do this so that every point of the original rectangle lies within a subrectangle and all the subrectangles are as equally divided as possible?
14:59:34 <napping> damn_connection: have you seen http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/
14:59:38 <kallisti> oops, let's say R rectangles instead, since N is taken.
15:00:02 <jle`> kallisti: "best" ?
15:00:03 <damn_connection> napping: I'll take a look now. Thanks
15:00:13 <jle`> can't you just slice it N times along a direction
15:00:16 <kallisti> jle`: yes, in terms of the criteria given
15:00:30 <kallisti> you could
15:00:33 <jle`> R, sorry
15:01:12 <kallisti> I suppose that would work for most situations
15:01:17 <kallisti> just split along the largest dimension
15:01:29 <Rarrikins> Lack of brains.
15:01:36 <jle`> it satisfies your criteria...all the subrectangles are of equal area
15:01:38 <jle`> but
15:01:43 <jle`> it sounds like you might want something more?
15:01:45 <kallisti> except 1 in the case of a remainder
15:01:52 <kallisti> which is fine
15:01:59 <Rarrikins> Brains.
15:02:06 <Rarrikins> kallisti needs your brains.
15:02:06 <BoR0> http://lpaste.net/7682713387414847488 how can I make this code more elegant (besides the warning that lpaste gave)?
15:02:14 <ReinH> kallisti: the problem is different and more interesting if you want the width/height ratio of the subrectangles to be as close to N/M as possible :)
15:02:18 <jle`> M and N are "real"/rational, right?
15:02:25 <ReinH> i.e. for the subrectangles to be self-similar with the original rectangle
15:02:28 <jle`> they can be divided between integers
15:02:46 <Rarrikins> N is obviously an integer.
15:03:01 <jle`> do you mean R
15:03:58 <kallisti> oh I forgot to specify it's a discrete plane, so everything is natural numbers and everything is divided via modular arithmetic.
15:04:32 <Rarrikins> Brains!
15:05:01 <monochrom> microchips are immune to brain-eaters
15:05:35 <kallisti> I guess the "pick the largest dimension, divide along that dimension, with potentially one subrectangle accepting the remainder" algorithm.
15:05:38 <jle`> oh that makes a difference
15:05:42 <kallisti> would work for my purposes
15:06:04 <kallisti> but it would be nice to have the ratio of each subrectangle to be as close to the original as possible.
15:06:15 <jle`> that might also not be optimal
15:06:21 <kallisti> If you're curious, the algorithm is for a distributed game of life implementation.
15:06:37 <jle`> in the sense of finding the best packing
15:06:50 <jle`> do you know anything about R?
15:06:51 <Rarrikins> I bet there's a line-drawing algorithm that does it.
15:06:55 <kallisti> so we're splitting up a grid into subgrids to be partitioned between nodes on a network.
15:07:17 <kallisti> jle`: not really
15:07:54 <kallisti> R would correspond with the number of distributed nodes so it could be any natural number.
15:08:00 <ReinH> kallisti: er, don't you just want a quadtree?
15:08:27 <ReinH> the speed of light in GoL creates a square fustrum
15:08:38 <ReinH> so the typical optimization is to use a (modified) quadtree
15:08:42 <ReinH> it's called Hashlife
15:09:19 <ReinH> @google Hashlife
15:09:20 <lambdabot> http://en.wikipedia.org/wiki/Hashlife
15:09:20 <lambdabot> Title: Hashlife - Wikipedia, the free encyclopedia
15:09:30 <ReinH> *frustrum
15:09:50 <kallisti> so just build a balanced quadtree with R leaves?
15:09:51 <ReinH> *frustum
15:09:55 <ReinH> I never could spell that thing
15:09:57 <ReinH> kallisti: basically yes
15:10:12 <ReinH> but you need a few more squares
15:10:33 <napping> BoR0: any particular reason you are encoding the pid@(Just _) rather than what you get out?
15:12:01 <BoR0> napping: I came down to http://lpaste.net/7682713387414847488 (refresh). still trying to make it more elegant
15:12:01 <ReinH> kallisti: this explains it with nice ASCII art http://recursiveuniver.se/docs/universe.html
15:12:18 <kallisti> ReinH: I knew there was some data structure that could help me, but I couldn't remember what it was. :P
15:12:31 <ReinH> kallisti: basically you need an extra square for the "center" iirc
15:12:33 <ReinH> or maybe not
15:12:41 <napping> The only way to cut the nesting would be to use MaybeT, not sur if that's actually nicer
15:12:43 <ReinH> anyway that hashlife implementation is quite easy to follow
15:13:23 <napping> But I'd probably pull out something returning Snap (Maybe Pid), to separate the lookup from actually writing it into the result
15:13:37 <napping> and it seems a bit odd to take the "odbc" as a string, if it's actually some kind of connection handle
15:13:43 <[swift]> hmm, is there any way i can import a module unqualified, hiding a certain symbol, and then import it qualified for only that symbol? i tried the obvious thing and it didn't work
15:13:48 <BoR0> it's a connection string
15:13:48 <napping> instead of also fetching that out of your snap state
15:14:13 <BoR0> I read it in main from file db.config and then pass through all functions
15:14:49 <napping> That's what I guessed, so wouldn't it be nicer to thread it around in the monad?
15:14:56 <BoR0> how? :)
15:15:08 <napping> I haven't used snap much, but I thought it had some way to provide user application state, something about snaplets?
15:15:23 <BoR0> yeah this is my first day with Snap but I read something about snaplets
15:15:25 <kallisti> ReinH: so I think I found something that might help me. It's called a k-d tree.
15:16:11 <napping> well that's fine then, the only thing I
15:16:14 <ReinH> kallisti: it's not as useful as a quadtree
15:16:30 <napping> I'd definitely suggest spliting out the lookup as a Maybe result, from encoding and printing it
15:16:42 <napping> that would also let you collapse the return "[]" cases
15:16:43 <kallisti> ReinH: it would deal with remainders more cleanly, I think?
15:17:06 <ReinH> kallisti: but you don't get the main benefit of a quadtree
15:17:31 * hackagebot ratio-int 0.1.1 - Fast specialisation of Data.Ratio for Int.  http://hackage.haskell.org/package/ratio-int-0.1.1 (RaphaelJavaux)
15:17:43 <kallisti> ReinH: but I'm not talking about actually computing the GoL transitions. I agree a quadtree is better for that.
15:17:59 <ReinH> which is that a quadtree caches the generation of a 2^(k-1) square from a 2^k square
15:18:04 <ReinH> kallisti: oh, what do you want to do then?
15:18:48 <ReinH> (it also stores this 2^(k-1) square 2^(k-2) generations into the future)
15:18:49 <ReinH> it's pretty magic
15:18:53 <kallisti> I'm subdividing the GoL grid into R subgrids, and then allocating each subgrid to a node in a distributed system.
15:19:02 <ReinH> kallisti: what does this node then do with them?
15:19:11 <ReinH> with it
15:19:30 <napping> BoR0: I think there are snaplets for holding a database connection, though
15:19:31 <kallisti> compute the next generation with that information (it has to fetch boundary cells from other nodes)
15:19:38 <napping> like premade ones
15:19:55 <ReinH> kallisti: but it can still compute that most efficiently if its subgrid is a square
15:20:19 <ReinH> kallisti: especially if the nodes share the quadtree cache
15:21:44 <ReinH> it can compute its 2^k sided grid 2^(k-1) generations into the future by making 8 requests to its neighbors for boundary cells and then checking the distributed quadtree
15:22:28 <ReinH> and the quadtree is append-only so it's pretty easy to distribute. Until you run out of memory.
15:22:51 <kallisti> ReinH: ah, yes I'm currently performing a naive implementation. But I think I should be able to switch to hashlife rather simply once I implement the basic distributed infrastructure.
15:23:33 <ReinH> even a GC'd quadtree is easy to distribute since it's deterministic
15:23:37 <ReinH> kallisti: sounds like a fun project :)
15:24:03 <kallisti> ReinH: oh I was thinking the quadtree would be centralized to one node. Distributing it like that sounds like an entire problem in itself.
15:24:03 <ReinH> and if you don't distribute the quadtrees you'd lose out on sharing but perhaps not by very much
15:24:23 <ReinH> kallisti: it would be :)
15:25:03 <ReinH> quadtree states form a semilattice so it should be easy to distribute as there's a trivial merge operation
15:25:07 <ReinH> but anyway
15:25:44 <ReinH> a centralized quadtree would be fine, federated quadtrees per node would be fine
15:26:01 <kallisti> heh, federated is an interesting word for it.
15:26:28 <ReinH> I don't know the word
15:26:30 * ReinH shrugs
15:27:25 <ReinH> And this channel is now about quadtrees
15:27:28 <kallisti> No it's an accurate description, it just makes me think of nations. the Quadtree Confederation :D
15:27:32 <ReinH> heh
15:28:25 <kallisti> yeah, sorry I could find a quadtree channel filled with 1244 bright minds.
15:28:34 <bitemyapp> ReinH: I wasn't keen on RSpec, but I do like HSpec a fair bit. How did you find HSpec?
15:28:45 * geekosaur must be tired, is managing to mentally conflate quadtrees and quatloos >.>
15:29:27 <ReinH> bitemyapp: I like it.
15:29:36 <ReinH> but I'm familiar with BDD so it seems natural for me
15:29:50 <ReinH> testframework is also nice
15:30:16 <ReinH> kallisti: I guess everyone is just listening to our quadtree discussion :)
15:31:11 <eacameron> anyone working on edwardk's machines with him?
15:31:33 <eacameron> and/or has anyone tried working with it as is?
15:32:07 <napping> BoR0: looks like snaplet-hdbc might be what you want
15:32:23 <BoR0> I will check that out, thx
15:33:01 <napping> I think you can pretty much just swap out the specific Snap in types for a MonadSnap m constraint, and maybe something else for the db
15:33:23 <BoR0> napping: can you help me with converting lines 8 9 and 10 to "maybe x y z" format? http://lpaste.net/7682713387414847488 my issue is that in Nothing case I do return and in the other case I don't do return so I can't just convert that case to maybe
15:34:01 <napping> BoR0: at least if you're using hdbc, there are other snaplet-* packages on hackage
15:34:01 <BoR0> should I use join or something, because I end up with Maybe (Maybe)) (I think)
15:34:15 <napping> what's the trouble? (return "[]") is the result of the case expression
15:34:36 <Feuerbach> BoR0: maybe (return "[]") (sqlToJson odbc getProfesorById) param
15:34:39 <napping> maybe (return "[]") (sqlToJson odb getProfessorById)
15:34:40 <Feuerbach> it's very mechanical
15:34:44 <BoR0> I want something like maybe [] (sqlToJson odbc getProfesorById) param
15:34:53 <BoR0> I tried that... I think....
15:35:28 <BoR0> right
15:35:46 <BoR0> is there something I can do to sqlToJson so that I don't need to do maybe (return ...) (...) and instead just do maybe (...) (...) ?
15:36:06 <napping> you could just return the maybe
15:37:03 <monochrom> "return it, maybe" :)
15:37:20 <napping> I was suggesting something like getProfessor odbc = runMaybeT $ do param <- lift (getParam "id"); liftIO (getProfessorById odbc (unpack param)
15:37:33 * hackagebot remotion 0.1.0 - A library for client-server applications based on custom protocols  http://hackage.haskell.org/package/remotion-0.1.0 (NikitaVolkov)
15:37:55 <monochrom> http://www.youtube.com/watch?v=-qTIGg3I5y8 :)
15:38:29 <BoR0> how do I return just the maybe? :)
15:39:00 <napping> then your main function would be do mbPid <- getProfessor odbc; writeBS (maybe "[]" (toStrict . encocde) mbPid)
15:40:53 <savanni> Um... does anybody happen to know whether devIL, or repa-devil, have a thread safety issue?
15:41:46 <napping> BoR0: does the first code I wrote typecheck?
15:42:13 <BoR0> I don't understand what it does. runMaybeT, lift is new to me
15:42:27 <napping> well, that's just for chaining the case
15:42:34 * hackagebot hashtables-plus 0.1.0 - Extensions for a "hashtables" library  http://hackage.haskell.org/package/hashtables-plus-0.1.0 (NikitaVolkov)
15:43:04 <napping> getProfessor odbc = do param <- getParam "id"); case param of Nothing -> Nothing; Just param -> liftIO (getProfessorById odbc (unpack param)
15:43:08 <savanni> nm.  Found the answer.  devIL-1 is *not* thread-safe.  devIL-2 supposedly will be, but that was announced five years ago.
15:43:11 <napping> er, return Nothing at the first
15:45:11 <sm> hi all. I'm trying to install GHC and cabal on locked-down windows pc, so can't use the HP installer
15:45:16 <lispy> aviraldg: It depends on two factors: a) what they look like after optimization b) the second one builds up all the intermediate values of the first one *plus* the accumulator. So I would expect it to allocate more (give or take optimizations)
15:45:35 <sm> GHC and cabal windows binaries don't work in a mingw shell, and need missing unix libs (zlib.h etc) in a regular windows shell. Can anyone suggest a way to do it ?
15:46:05 <lispy> sm: I use ghc/cabal from a mingw shell and mintty
15:46:15 <lispy> sm: you might try to diagnose that specific issue further
15:47:14 <lispy> sm: how did you get ghc/cabal on the machine? Are these binaries copied there from another machine?
15:47:33 <lispy> You might need to manually recreate the steps of the installer
15:49:38 <sm> lispy: I have mintty here.. do you use the win64 binaries from GHC and cabal pages ? They both seem to run well enough but cabal install anything fails, I suspect because it's trying to deal with windows backslash paths
15:50:55 <sm> but both of them should handle those, shouldn't they
15:53:45 <sm> here's failure: https://gist.github.com/simonmichael/5302a1c8daf6a71935c5
15:57:21 <BoR0> @src runMaybeT
15:57:22 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:58:17 <davidfetter> > take 5 "dave brubeck"
15:58:19 <lambdabot>  "dave "
15:58:23 <davidfetter> hrm
15:59:30 <Axman6> damn, now that's stuck in my head
15:59:39 <Axman6> not a terrible thing though
15:59:41 <lispy> sm: When I tried the 64bit stuff I couldn't get it to work either. I don't know if the newer 7.8 stuff works better. I tried it with 7.6. Definetly busted.
16:00:27 <lispy> sm: here is our hint: C:\Users\MARINE~1\AppData\Local\Temp\4948.o: file not recognized: File format
16:00:29 <lispy> not recognized
16:00:33 <lispy> sm: do you have file installed?
16:00:38 <lispy> sm: or readelf?
16:00:59 <lispy> sm: I suspect that part of your install works on 32bit and parts works on 64bit and they are conflicting.
16:01:29 <lispy> sm: if you could run file on one of those .o files we could see what it is. readelf would give us similar details.
16:02:37 * hackagebot yesod-routes-typescript 0.3.0.0 - generate TypeScript routes for Yesod  http://hackage.haskell.org/package/yesod-routes-typescript-0.3.0.0 (GregWeber)
16:02:39 <geekosaur> elf? on windows?
16:03:13 <sm> lispy: thanks for the hints, let me see
16:03:19 <lispy> sm: also, do you have ld installed in C:/mingw/msys/1.0/local/ghc-7.8.2/bin
16:03:47 <lispy> geekosaur: Oh right. I was thinking unix tools and so elf naturally :)
16:03:52 <lispy> geekosaur: what should it be PE?
16:04:48 <lispy> sm: I just ran file on a .o file that ghc generated on windows (32bit ghc) and it says: MS Windows COFF Intel 80386 object file
16:05:12 <lispy> that's for a library mind, you
16:07:05 <Fernandos> hi
16:07:07 <sm> lispy: I don't have ld there, I have it in c:\mingw\bin and c:\mingw\msys\1.0\bin
16:07:42 <sm> the .o file mentioned is removed by when the command exits
16:09:03 <Judy18>  You can find funny videos here. http://bit.ly/1gAh6Jy
16:11:40 <sm> while true; file ... to the rescue.
16:12:19 <lispy> sm: yeah, running it on the intermediate files requires extra steps. I can never remember what they are. You might even be able to tell cabal not to delete them?
16:12:29 <jakex> @hoogle Monad m => m a -> m [a]
16:12:30 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
16:12:30 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
16:12:30 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
16:13:25 <lispy> @hoogle unfoldM
16:13:26 <lambdabot> No results found
16:14:30 <sm> I couldn't find that in the usuall wall-of-flags. Instead I copied *.o from a while loop. file says it's "ACB archive data", readelf says it's not and ELF
16:15:12 <jakex> :t (sequence . repeat) -- is there a function like this?
16:15:13 <lambdabot> Monad m => m a -> m [a]
16:15:40 <sm> ACB.. america online.. this does not sound good :)
16:17:14 * sm wonders if anyone has run cabal & ghc 7.8 on windows
16:18:15 <sm> I installed the 64bit ghc, maybe the cabal binary is 32bit ?
16:20:47 <athan> are * and Constraint different kinds of the same sort? So that (theoretically) `sort Kind = * | Constraint`?
16:22:05 <dario> is sort something like the thing one meta-layer above kinds?
16:23:00 <quchen> dario: Not in Haskell, but the "type of kinds" is called "sort" sometimes.
16:23:19 <quchen> Eh, misread the question.
16:23:46 <merijn> athan: Haskell has only one sort, called BOX
16:24:01 <merijn> athan: So by definition all kinds are the same sort in haskell
16:24:16 <shachaf> :t sort -- another sort
16:24:17 <lambdabot> Ord a => [a] -> [a]
16:24:20 <merijn> Actually, this may even only apply to GHC haskell
16:24:29 <merijn> Not sure whether the report mentions sorts at all
16:24:46 <shachaf> Doesn't.
16:24:57 <athan> merijn: Awesome, thank you :)
16:25:16 <athan> yeah I don't think it would
16:27:40 * hackagebot QuickCheck-GenT 0.1.3 - A GenT monad transformer for QuickCheck library.  http://hackage.haskell.org/package/QuickCheck-GenT-0.1.3 (NikitaVolkov)
16:33:00 <jle`> did some algebra in class today, caught myself calling it equations reasoning in my head
16:34:38 <Eduard_Munteanu> "Sort" also refers to universe levels in type systems with an infinite hierarchy of types. kinds, sorts etc.
16:36:22 <Eduard_Munteanu> e.g. if * is Set 0, BOX is Set 1 and so on, k in Set k is sometimes referred to as the sort.
16:37:18 <Eduard_Munteanu> At least that's what I've heard.
16:37:35 <haasn> There are a lot of things the report doesn't have
16:37:50 <haasn> Especially on the type and kind level
16:37:55 <Fernandos> How do I instantiate a "controller class" in Haskell?
16:38:00 <vozz> Having difficulty with Gtk2Hs. It seems you define the GUI mainloop in the IO monad, but once you start the GUI, that loop is fixed and I can't figure out how to get it to interact with the rest of my haskell code. If my code is calculating something and wants to display it, then calculate something else and display that, how do I do that without making completely new windows? I.e. how do i update an existing window?
16:38:15 <haasn> Haskell doesn't have (OOP) classes and instantiation
16:38:33 <haasn> (It has “class instances” but those are different usages of the words)
16:38:35 <Eduard_Munteanu> vozz: normally it's event-driven
16:38:50 <Fernandos> haasn: I know, that's why I ask how this is done equivalently in Haskell.
16:39:04 <haasn> Probably by specifying the problem first
16:39:14 <Eduard_Munteanu> vozz: you set up handlers for GUI events and do the work there. But you can also fork threads for long computations.
16:39:27 <Eduard_Munteanu> Fernandos: what is a controller class?
16:39:28 <Fernandos> haasn: I'd like to do this: Controller = new Controller("Appname")
16:39:46 <vozz> Ah, so my code has to be inside the GUI loop? I think I get it
16:40:18 <Eduard_Munteanu> vozz: not really, you just set up event handlers, you don't write the loop yourself.
16:40:25 <Fernandos> Eduard_Munteanu: oh it could be anything, I just wanted to instantiate a class's contructor with an object actually.
16:40:51 <Eduard_Munteanu> Fernandos: can you translate that to something that doesn't involve OOP?
16:40:52 <haasn> But Haskell doesn't have OOP classes, constructors, instantiation or objects
16:41:19 <Eduard_Munteanu> i.e. what abstraction / behavior do you expect?
16:41:51 <Fernandos> Eduard_Munteanu: I'm afraid, I'm just learning Haskell :(
16:42:37 <vozz> Eduard_Munteanu: How do I create an event?
16:42:38 <haasn> I recommend solving problems as they come up, not in advance
16:42:59 <davidfetter> is there anything in ghc 7.8 that makes it worth installing instead of 7.6 for the haskell n00b?
16:43:16 <haasn> davidfetter: new IO manager, for example
16:43:29 <davean> davidfetter: Depends on the n00b
16:43:33 <Eduard_Munteanu> Fernandos: try doing stuff the straightforward way if you come from an OOP background, instead of calling upon OOP abstractions
16:43:34 <haasn> But there are lots of general improvements at various levels
16:43:54 <davidfetter> davean, first use of a functional language unless you count SQL
16:43:57 <haasn> davidfetter: see http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/release-7-8-1.html
16:44:50 <haasn> typed holes, for example
16:44:52 <davidfetter> "Applicative will become a superclass of Monad" sounds kinda important
16:45:05 <davidfetter> not that i really understand either of those just yet
16:45:12 <Fernandos> Eduard_Munteanu: To be honest, I'm trying to complete an assignment in Scala, I already have solved it in java, but doing it in Haskell makes some headaches, as I'm new to this and wanted to impress my tutor a bit :)
16:45:17 <haasn> davidfetter: it's mainly just a utility thing
16:45:22 <bezirg> can I make manually a Typeable instance of Control.Monad.Coroutine ? Deriving it does not work
16:45:32 <haasn> davidfetter: there are basically no Monad instances that aren't Applicative already except in very legacy and bitrotten libraries
16:45:35 <Fernandos> Eh sorry, I mean I have completed it in Scala and Java, but not Haskell
16:46:03 <Eduard_Munteanu> vozz: there are those on* functions for specific widgets, but I don't remember what's the standard way to do it now, those were deprecated
16:46:13 <davidfetter> haasn, i have just demonstrated some of the depth of my ignorance, then
16:46:16 <haasn> But this change can make constraints etc. smaller since now GHC can actually infer Monad :- Applicative
16:46:17 <Eduard_Munteanu> vozz: you might want to Google for signals
16:46:19 <Fernandos> I'm not asked to do it in Haskell, but I'd like to, in order to get familiar with Haskell a bit more
16:47:20 <Eduard_Munteanu> Fernandos: Haskell is different enough that it might take longer to get comfortable to work with
16:47:37 <vozz> What about signals/events that aren't something the user does? Like instead of making something happen when they click a button, I want to make something happen when my code detects something else happen
16:47:43 * hackagebot shared-buffer 0.1.0.6 - A circular buffer built on shared memory  http://hackage.haskell.org/package/shared-buffer-0.1.0.6 (JohnLato)
16:47:43 <haasn> Scala and Haskell are not very related
16:48:04 <Eduard_Munteanu> vozz: how does your code detect stuff? What would it detect?
16:48:31 <Fernandos> Eduard_Munteanu: Not at all, except the functional part. Would you mind helping me to understand how instantiation and "object passing" is done in Haskell?
16:48:41 <haasn> it isn't
16:48:47 <haasn> Is that a valid answer?
16:48:51 <vozz> Eduard_Munteanu: It's taking screenshots in a forever loop and processing the images to look for stuff. If it sees certain things I want it to display an output in the GUI, and keep it updated
16:49:46 <Eduard_Munteanu> Fernandos: those aren't really there as Haskell concepts... instead of objects, in Haskell you tend to pass the stuff you're interested in around directly.
16:50:07 <haasn> Haskell has functions and constructor applications
16:50:20 <haasn> You pass around those types of values
16:50:28 * davidfetter wonders what a formalized dysfunctional programming would look like
16:50:36 <haasn> davidfetter: PHP
16:50:41 <davidfetter> haasn, LOL!
16:50:51 <haasn> except that's cheating because it fails “formalized”
16:50:52 <Eduard_Munteanu> Fernandos: for instance, instead of a file object, you may pass around a handle directly or even its actual contents!
16:51:08 <davidfetter> http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html ;)
16:51:18 <haasn> Or part of its contents and an action to produce the rest
16:51:46 <Eduard_Munteanu> vozz: you might want to set up a timer, or fork a separate thread for heavy work
16:52:08 <haasn> I guess I need to expand my definition of “functions” and “constructor applications” by “primitive values”
16:52:23 <haasn> or: values of abstract data types
16:52:52 <Fernandos> I mean, I'm surely not the first person to ask this, so can you make a minimal example that shows how this java concept Controller c = Controller(); App myapp = new App(c) can be translated?
16:52:55 <haasn> but almost all haskell types are of the first two varieties
16:53:03 <haasn> values*
16:53:12 <Fernandos> that's puzzling me.
16:53:30 <Peaker> Fernandos: that doesn't do anything (yet)
16:54:06 <Fernandos> Peaker: ok, then let myapp print hello world, if the "c" is passed.
16:54:09 <Peaker> Fernandos: you could have:   data Controller = Controller ;  data App = App Controller     and then :   c = Controller ; myapp = App c ; but it doesn't mean anything
16:54:39 <Eduard_Munteanu> Fernandos: perhaps an exagerrated example, but how do you do that in, say, Brainfuck or x86 assembly?
16:54:39 <Peaker> Fernandos: printHelloWorld :: Controller -> IO () ; printHelloWorld _ = putStrLn "Hello world!"
16:54:40 <haasn> data Controller = HelloWorld; app Controller = print "Hello World"
16:55:06 <haasn> err
16:55:09 <haasn> app HelloWorld = *
16:55:50 <haasn> Eduard_Munteanu: or LazyK? :)
16:56:12 <Eduard_Munteanu> Mm, that's closer I suppose.
16:57:34 <haasn> Fernandos: of course, the real way to translate that program into Haskell would be:  main = putStrLn "Hello, world!"
16:57:50 <Fernandos> Is this right? data Controller = Controller; data  App = App Controller;  c = Controller ; myapp = App c = putStrLn "App instantiated with controller" ;
16:58:26 <haasn> Fernandos: you have two ='s in the same declaration there, that's a syntax error
16:59:18 <Fernandos> k, haskell seems to be entierely different from scala then also
16:59:41 <haasn> The syntax is “<pat> = <expr>” or “<var> <args> = <expr>” and that is what a declaration looks like
16:59:51 <haasn> declarations are not expressions and vice versa
17:08:44 <Fernandos> Is a shorthand data type declartion possible? data Controller = Controller { msg :: String }, App = App { name :: String }
17:09:10 <Eduard_Munteanu> No.
17:09:11 <haasn> no, you need two separate lines starting with ‘data’ to introduce two data types
17:09:19 <Fernandos> ok
17:09:43 <haasn> (or newtype, before somebody gets pedantic)
17:21:48 <sm> lispy: ha! that seems to have been it. With the 32-bit windows ghc, cabal works better
17:23:22 <pozori> I'm having problems with haskell mode in emacs. it often starts freezing out of nowhere. what should I disable?
17:28:26 <Fernandos> This is how far I could get by and I'm not sure if it's right. Can you help me with this? http://bpaste.net/show/FhmMEo0NAZwbKZJBTxAI/
17:32:56 <hae> Make sure you have proper bounds checking for that heartbeat function. :D
17:33:44 <Fernandos> aha?..
17:35:40 <hae> But seriously, you passed the wrong arguments to the Application constructor.
17:35:53 <hae> There's no need for the && operator.
17:36:33 <Fernandos> hae: I'm a total beginner with haskell and that's my first program in it :/
17:37:11 <hae> Yeah to be honest you're going about it all wrong.
17:38:10 <Fernandos> hae: ok, that's better.. what should I do?
17:38:50 <hae> I think you need to throw away what you've written and start over.
17:39:19 <hae> PM me if you want more help.
17:40:45 <mmaruseacph2> Fernandos: if you need to do input/output your function must be in the IO monad
17:41:01 <mmaruseacph2> reading LYAH will really help you approach this faster
17:41:07 <mmaruseacph2> http://learnyouahaskell.com/
17:41:21 <mmaruseacph2> (I forgot how to ask lambdabot about where some links point to)
17:41:53 <Fernandos> mmaruseacph2: I already do that in parallel, but I want to complete this task asap, since I've been awake for to long for this already :/
17:44:03 <mmaruseacph2> Fernandos: you want threads and concurrency in your app, you cannot do that even if you finished reading LYAH
17:44:30 <mmaruseacph2> for concurrency you have to read the chapter in real world haskell or in the other book (forgot it's name)
17:47:42 <Fernandos> mmaruseacph2: oh.. well.. that's sort of a surprise I'd probably have had, after reading it... thanks for revealing it
17:48:40 <hae> Real World Haskell does indeed have a chapter on concurrency.
17:49:09 <maroloccio> i have heard a few times: learn you a haskell, it'll make you a better programmer when coding in "any" language.. can somebody share an insight into "how" if you went back to, say, java?
17:49:10 <hae> And I-
17:49:15 <hae> (•_•)
17:49:20 <hae> ( •_•)>⌐■-■
17:49:24 <hae> (⌐■_■)
17:49:28 <hae> concur.
17:50:38 <maroloccio> specifically, if you had plenty of time to implement your next project in java, would you "stop and learn you some haskell" with the realistic hope it'll make your next project better?
17:51:29 <hae> My question is why would you go back to Java?
17:51:39 <hae> Just use a Haskell-like JVM language.
17:55:07 <Fernandos> like Jaskell, heh
17:56:20 <tristan__> but the JVM is SOOOOO GRRRRREEEAAATTT
17:57:06 <maroloccio> the next project will have an android front-end (i did many of those) and an "undefined" back-end
17:58:15 <maroloccio> so are most of the benefits to be had if one sticks with haskell or are a good portion of the "principles" applicable elsewhere? (i only read LYAH)
17:58:22 <gamegoblin> \join #statistics
17:58:29 <gamegoblin> whoops
17:58:45 <c_wraith> I always wonder when people tell me they have to use the JVM because of libraries, if they've ever *used* those libraries.  Every time I think there's some JVM library for what I need, I find it only works 20% of the time, and has a terrible API.
17:59:11 <maroloccio> is there an imap library in haskell?
17:59:34 <c_wraith> I think WASH did imap, but I wouldn't use it if it did.
17:59:43 <Clint> zing
18:00:19 <LordBrain> https://hackage.haskell.org/packages/search?terms=imap
18:00:47 <asmyers> Has anyone here read The Algebra of Programming by Richard Bird?
18:01:47 <c_wraith> hah.  Looking at HaskellNet.  The last upload was by shapr.  But he's not listed as maintainer or author.  (I also know the maintainer, and am not surprised if he's been nonresponsive recently)
18:02:52 * hackagebot hledger-lib 0.22.2 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.22.2 (SimonMichael)
18:02:54 * hackagebot hledger 0.22.2 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.22.2 (SimonMichael)
18:03:34 <c_wraith> IMAP is one of those protocols where it's easier to write a bad library for handling the specific things you need to do than it is to use someone else's bad library that was written for only their needs.
18:03:40 <maroloccio> are there a couple of snippets that show how java might look like written before and after knowing a decent amount of haskell? (i.e. show the positive influence haskell had on java code..)
18:08:17 <Anastasia18>  Hi! I give you some videos. I hope you like! http://bitly.com/1gAh6Jy
18:08:52 <maroloccio> @where ops
18:08:52 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
18:08:58 --- mode: ChanServ set +o copumpkin
18:09:02 --- mode: copumpkin set +b *!~Anastasia@95.141.20.196
18:09:02 --- kick: Anastasia18 was kicked by copumpkin (no)
18:09:08 --- mode: copumpkin set -o copumpkin
18:09:45 <imalsogreg> maroloccio: I don't know of any. But if you're still looking for specific examples of where LYAHing could help you in java,
18:10:35 <imalsogreg> maroloccio: Being forced to minimize my use of mutable state has helped me keep things from spiraling into complexity, in my other languages.
18:10:41 <maroloccio> imalsogreg: my reality is that i will still need to code in java but i want to "learn stuff and bring it back to what i do every day" until i'll be able to "do haskell every day"?
18:11:01 <imalsogreg> maroloccio: Absolutely yes. No question.
18:12:15 <imalsogreg> maroloccio: The only downside I've found is that I end up wanting very Haskell-like things in MATLAB, and I end up paying a big price when I get too literal with bringing Haskell ways there, because things like recursion and sharing aren't worked out as well.
18:12:44 <imalsogreg> maroloccio: So, you have to know your java pretty well, to know when doing it "right" will cost you in performance.
18:12:57 <maroloccio> sounds intriguing, makes me wanna look at some "java under haskell influence" even more :)
18:13:15 <imalsogreg> maroloccio: I should also mention the psychological impact.
18:13:20 <gamegoblin> When I code Java after doing a lot of functional, I put static methods EVERYWHERE
18:13:42 <imalsogreg> maroloccio: I no longer derive any pleasure in MATLAB programming, honestly. It's painful. Hopefully that effect isn't so strong in java.
18:13:43 <maroloccio> imalsogreg: please do
18:13:45 <sgronblo> http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
18:14:15 <maroloccio> sgronblo: i read that before logging in, part of question is also based on that read
18:14:27 <maroloccio> * part of my question
18:15:20 <imalsogreg> maroloccio: sgronblo: I think the effect in that post is absolutely true. But I wouldn't draw the conclusion that you'll be a worse python programmer, in the net.
18:15:49 <c_wraith> You'll just hate python more.
18:16:10 <imalsogreg> imalsogreg: Python, AND your old python code. :)
18:16:34 <hae> Python 2.7 FTW?
18:16:37 <c_wraith> talking to yourself again?
18:16:51 <imalsogreg> c_wraith: I'm so embarrassed that you remember that.
18:16:56 <imalsogreg> c_wraith: hahaha
18:17:00 <p0a> What would be the recommended learning material for a person who is mathsy? thanks
18:17:16 <p0a> [to learn haskell in and out]
18:17:17 <c_wraith> I did some work in python after learning haskell.  I kept thinking "why is there so much *syntax* in this language?"
18:18:34 <imalsogreg> maroloccio: Improvement in your python, demoralization, whatever - will all happen in proportion to how much haskell you learn. So just get a taste an you aren't risking much.
18:19:06 <maroloccio> well, you know, a small example would help me understand what you mean more..
18:19:46 <imalsogreg> maroloccio: Let's see if others like this one... in python I would have a for loop,
18:19:48 <maroloccio> especially: would i start using python differently? more of feature X? less of feature Y? long for feature Z which isn't there? write with an "accent"? with no examples is hard to say..
18:20:07 <imalsogreg> maroloccio: I'd realize I have to transform every element in the list some way,
18:20:08 <monochrom> I use more resistance to mutation in Java. I mean: if my object keeps track of a width and a height, I have a method to give you a record of those two fields, but that method always gives you a newly created copy. whatever you do to mutate the record fields you receive, it affects my object nilch.
18:20:21 <maroloccio> btw, the original question was re: java but since i know both, you can make your example in python :)
18:20:31 <imalsogreg> maroloccio: and later realize - Oh I gotta drop some of these elements out. So, put that conditional deletion into the for loop.
18:20:39 <monochrom> I guess s/nilch/zilch/
18:21:05 <imalsogreg> maroloccio: Now, I would never do that. mapping and filtering are two totally different jobs. I'd compose the mapping and the filtering, instead of let my loop get confusing.
18:21:34 <monochrom> fusing can be confusing :)
18:21:51 <sgronblo> I guess that article is written kind of as a joke, but I think the title could have been why learning functional programming makes you miserable.
18:22:31 <sgronblo> Or in my case why learning about proper statically typed languages makes you miserable
18:22:51 <monochrom> yes, knowing how to do things better makes you miserable when you are in the world of people who insist that "real world" must mean doing things badly.
18:22:54 * hackagebot hledger-web 0.22.6 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.22.6 (SimonMichael)
18:23:09 <maroloccio> i would argue that a "typical java book" (effective java) has a chapter (Item 15: Minimize mutability) on minimising mutability already..
18:23:28 <p0a> monochrom: what are you talking about?
18:23:30 <imalsogreg> maroloccio: Different level when you have no choice :)
18:23:43 <monochrom> I am talking about what sgronblo is talking about
18:23:50 <sgronblo> the rage i feel when i have to refresh a browser to discover that i typoed something has multiplied over the years
18:25:22 <sgronblo> i think most "normal programmers" (ruby/javascript guys) accept it as a normal part of programming
18:25:36 <maroloccio> btw i understand the for loop / mapping / filtering analogy from python. is there a way in which a haskell "composition" of those would be different from the same thing in python?
18:26:03 <p0a> I feel that I have to repeat my question, What would be the recommended learning material for a person who is mathsy to learn Haskell in and out? thanks
18:26:09 <geekosaur> dpesn't require stupid amounts of extra syntax?
18:26:10 <sgronblo> and then they can somehow at the same claim that "static typing is verbose" and "just write lots of tests"
18:26:16 <c_wraith> maroloccio: just the brevity
18:26:36 <c_wraith> maroloccio: it becomes trivial to write it as composition.
18:26:58 <monochrom> I was mathsy. I hold a BSc in math. I learned Haskell from A Gentle Introduction to Haskell.
18:27:01 <maroloccio> p0a: http://learnyouahaskell.com/ + 2008-12-01 | Real World Haskell | O'Reilly Media | 714p | by Bryan O'Sullivan | ISBN-0596514980 + 2012-05-02 | Developing Web Applications with Haskell and Yesod | O'Reilly Media | 298p | by Michael Snoyman | ISBN-1449316972 + 2013-08-16 | Parallel and Concurrent Programming in Haskell | O'Reilly Media | 322p | by Simon Marlow | ISBN-1449335942 ?
18:27:58 <monochrom> I have not used "the haskell road to logic, maths, and programming", but you may like the title
18:27:58 <p0a> looks too noob friendly, that first link and the others are too specialized
18:28:03 <maroloccio> c_wraith: so you are talking about convenience rather than capability there..
18:28:14 <akurilin> Quick question: is it possible to use the .: operators on an aeson Object outside of the instance FromJSON implementation? I'm just trying to get my head around the combinators used in the recommended implementations and it'd be great if I could get there step by step
18:28:32 <ddere> p0a: Categories for the Working Mathematician by Saunders Mac Lane is a great text for Category Theory, but it doesnt touch Haskell at all, but its great for seeing the inspiration for most of the Functor/Monad concepts etc...
18:28:39 <geekosaur> maroloccio, quite a lot of haskell is less about capability than about making it easy to say stuff like that
18:28:40 <akurilin> I already put together a HashMap vaguely resembling what FromJSON would be called with.
18:28:58 <p0a> ddere: Yes but that is a hard book that I intend to read probably after I have learned haskell :)
18:29:04 <monochrom> yes you can use .: outside
18:29:06 <geekosaur> they're both turning equivalent; if you're willing to do the work, both languages can do the same things
18:29:17 <ddere> p0a: Category Theory by Steve Awodey is also good
18:29:26 <geekosaur> but what they can express conveniently differs
18:29:29 <maroloccio> geekosaur: both = which ones?
18:29:36 <p0a> ddere: :P
18:29:45 <geekosaur> you were comparing python and haskell
18:29:49 <geekosaur> both can do the same things
18:29:52 <c_wraith> maroloccio: yeah. It's really about "what does the language make easy" as much as anything else.  It turns out that in most cases, the things haskell makes easy pay off in terms of design in the long term.
18:30:00 <geekosaur> each has things it can express more easily/conveniently
18:30:02 <ddere> p0a: in that case, any Haskell resource is good :)
18:30:08 <akurilin> monochrom: the error I'm seeing in the repl is that it says no instance for (FromJSON a0) is arising form a use of '.:'
18:30:24 <akurilin> If I just try to run something like v .: "id"
18:30:28 <p0a> Maybe I just need to stop being lazy and read the resources :)
18:30:32 <maroloccio> geekosaur: gotcha. no actually i was comparing java and haskell then an example was provided in python and i said "sure, go ahead, i can program in python as well.." and it "mutated" ;) into a python thing..
18:30:52 <c_wraith> maroloccio: the visible differences in java code won't be at the small scale.
18:30:55 <geekosaur> same applies (more so in terms of stupid amounts of syntax) to that comparison
18:31:11 <geekosaur> you can do the same things, haskell makes certain programming styles extremely convenient
18:31:12 <byorgey> ddere: seriously? CftWM is a TERRIBLE textbook for category theory.
18:31:29 <c_wraith> maroloccio: the differences will be at large scale, mostly.  You'll design things differently.  Objects will be less about behavior and more about dumb data.
18:31:33 <byorgey> it's like learning how to swim by getting thrown in the middle of the Pacific Ocean, during a hurricane.
18:31:52 <p0a> byorgey: what would you recommend instead?
18:31:55 <gamegoblin> Pacific Ocean has cyclones, not hurricanes ;)
18:31:56 <ddere> byorgey: I dunno, I didnt find it that bad, thought it flowed pretty naturally
18:32:04 <gamegoblin> or typhoons, if you prefer
18:32:23 <gamegoblin> tomayto tomahto, really. Pedantic.
18:32:23 <byorgey> gamegoblin: good point =)
18:32:43 <byorgey> p0a: for learning Haskell? or category theory?
18:32:46 <maroloccio> i have already read LYAH, i am temped to try to implement some euler/topcoder style programs to try my hand and use what i read before it fades away yet.. i wonder.. is there a repo somewhere with that king of stuff already written?
18:33:04 <gamegoblin> You should maybe check out Real World Haskell
18:33:06 <p0a> byorgey: I'm interested in both so you can't go wrong but I was particularly asking for cat. theory since you said maclanes book is terrible
18:33:14 <gamegoblin> just doing project euler will not help much.
18:33:22 <byorgey> p0a: Awodey is indeed good
18:33:41 <p0a> okay noted, thanks
18:33:43 <sgronblo> Yeah Euler is better for learning math than programming
18:33:48 <c_wraith> maroloccio: program design will be more about creating chunks of functionality that alter data without internal state, and then connecting them together to build up a full program.
18:33:50 <byorgey> p0a: as for Haskell, I'd say read just enough of the basic resources to get the basics down, then start reading Functional Pearls
18:33:50 <akurilin> monochrom: actually looks like it just needs to know what type Parser is to wrap, so I can do (v .: "id") :: Data.Aeson.Types.Parser MyType
18:34:06 <c_wraith> maroloccio: Of course, java makes it pretty syntax heavy to work that way, you you don't end up with very granular chunks
18:34:15 <monochrom> well, MyType still needs a FromJSON instance
18:34:24 <ddere> byorgey: well i definitely agree that awodeys book is good, but apart from the font used, i didnt find one particularly easier to read than the other
18:34:36 <byorgey> p0a: http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
18:34:39 <maroloccio> c_wraith: i agree
18:34:52 <ddere> p0a: only haskell book i would recommend against is Real World Haskell
18:34:53 <akurilin> monochrom: it's true, I guess I had defined it earlier in that module (even though it's not working as intended yet)
18:34:59 <p0a> byorgey: thank you
18:35:18 <p0a> ddere: I think last time I was reading a mix of tutorials + gentle introduction
18:35:55 <monochrom> it is futile to settle questions like "is this mathy book terrible". Dijkstra says that most mathematicians' presentations are terrible. most mathematicians say that Dijkstra's presentations are terrible. whom do you listen to? (I happen to side with Dijkstra. disclosure...)
18:36:03 <c_wraith> p0a: write code. No matter what you read, it's not going to really sink in unless you also do a bunch of writing.
18:36:19 <hae> Dijkstra is best stra.
18:36:28 <hae> ^ ddere
18:36:44 <c_wraith> I side with SPJ when he says "comic sans is fine for presentations"
18:36:59 <c_wraith> But that's mostly because typography maniacs get on my nerves.
18:37:01 * heatsink has strong opinions about fonts
18:37:09 <hae> I didn't understand Haskell. Then I read RWH. Now I do. Were the two related? Maybe.
18:37:30 <heatsink> I don't understand why people like Arial in presentations.  And especially Arial Narrow.
18:37:43 <gamegoblin> I didn’t understand haskell until I tried and failed to learn it around 3 times. Persistence, I guess.
18:37:54 <monochrom> I don't understand why people dislike any font at all. :)
18:38:02 <c_wraith> monochrom: not even wingdings? :P
18:38:09 <ddere> hae: I just dont like how little attention it gets w.r.t edits, if you look at the online version, there are corrections from people in the comments for nearly every paragraph but theres no response from the authors, no one pays attention
18:38:20 <hae> Some would argue that nobody can understand all of Haskell any more than one person can intuitively understand all of mathematics.
18:38:20 <gamegoblin> Everything should be in Ubuntu Regular or Ubunto Monospace, end of story. I am right everyone else is wrong lalalala.
18:38:38 <heatsink> I don't think there's a discrete moment when you transition from not-understanding to understanding.
18:38:50 <hae> ddere, I know, I guess the authors just got tired of making tiny incremental improvements.
18:38:54 <sw17ch> Is there a pretty-printing library on Hackage that supports Data.Text?
18:39:34 <gamegoblin> sw17ch: define pretty printing library
18:39:37 <ddere> hae: Still if it helped you (or anyone) learn haskell then the outcome is still good, im not going to argue with that
18:39:41 <maroloccio> Data::Dumper
18:39:42 <heatsink> monochrom: Try editing code in Didot :)
18:39:45 <maroloccio> import pprint
18:39:59 <sw17ch> gamegoblin: https://hackage.haskell.org/package/pretty-1.1.1.0
18:40:03 <maroloccio> this kind of functionality?
18:43:11 <monochrom> didot looks fine. what can possibly go wrong?!
18:47:39 <maroloccio> thanks for your views guys
18:47:57 * hackagebot ez-couch 0.7.0 - A high level static library for working with CouchDB  http://hackage.haskell.org/package/ez-couch-0.7.0 (NikitaVolkov)
18:47:58 <monochrom> I think it is not too bad to use any common pretty-printing library, which outputs String, and pack it to Text.
18:47:59 * hackagebot ncurses 0.2.8 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.2.8 (JohnMillikin)
18:50:51 <heatsink> monochrom: Eyestrain, mainly.  Didot is designed to look elegant at large sizes with its high contrast between thin and thick strokes.  At small sizes, the thin strokes are nearly invisible.
18:51:58 <monochrom> I see. that is a problem. I have only looked at big examples.
18:57:22 * monochrom has a cunning plan!
18:57:45 <monochrom> don't read any book to learn Haskell. listen to a book. a hypnotic audio book.
18:58:41 <monochrom> one that keeps saying "it is true that you know Haskell. there is no question that you know Haskell". a la Somewhere in Time. :)
18:59:20 <hae> ^
18:59:47 <Jaood> you'll need hypnotic coding sessions too ;)
18:59:59 <hae> Sounds like it would work just as well as Baby Mozart.
18:59:59 <maroloccio> "i know Kung Fu"
19:01:18 <Jaood> the best way to learn a language is to quit the internetz :P
19:01:50 <hae> I want to learn Japanese the same way.
19:02:07 <hae> I legitly bought an English-Japanese dictionary and everything.
19:02:39 <monochrom> you need to buy an interactive Japanese teacher robot.
19:02:59 * hackagebot cookbook 2.3.3.0 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.3.3.0 (NatePisarski)
19:03:23 <c_wraith> ...  I have no clue what that package description means
19:03:32 <monochrom> after learning Japanese, buy also an interactive Japanese Haskell teacher robot :)
19:03:52 <monochrom> general-purpose library is general-purpose :)
19:04:31 <monochrom> I think "everything application that I make, I add its functions to Cookbook" says it all
19:04:48 <monochrom> my question is why is it not called "the kitchen sink" instead :)
19:05:12 <geekosaur> "emacs", surely? :p
19:05:32 <monochrom> haha you win
19:05:35 <hae> ^ monochrom
19:05:51 <hae> There should be a language-learning-mode or something.
19:05:51 <lispy> "The claim-to-fame for the library is its use of overloaded typeclasses, called Continuities." <-- What?
19:06:20 <monochrom> at least it is called Continuities, not TimeCube.
19:06:21 <lispy> I wonder what an overloaded type class is
19:07:16 <monochrom> I think it's just redundant wording and means type class.
19:07:50 <hae> Overloading is just a fancy term for polymorphism lol.
19:08:50 <akurilin> If I'm exporting everything within a module with module MyModule where, should I still be seeing "x is not a (visible)) field of constructor" ?
19:09:18 <monochrom> should not
19:09:20 <akurilin> When I define a data type in the repl it works just fine, but not so much when I try to produce a curried constructor function
19:09:36 <akurilin> with record syntax
19:09:54 <akurilin> so M.MyThing {id=1}
19:11:43 <monochrom> I think a self-contained reproducible example is in order
19:11:49 <akurilin> sure, sec
19:11:54 <lispy> I can't find the Continuities in the cookbook
19:12:04 <monochrom> it may be Continuous instead
19:12:54 <monochrom> perhaps Continuities is the next TimeCube
19:12:58 <lispy> in that case, the author probably means https://github.com/natepisarski/Cookbook-hs/blob/master/Cookbook/Essential/Continuous.hs#L23
19:13:39 <copumpkin> argh
19:13:42 <lispy> I don't see where it's used
19:14:48 <lispy> ah, in this module: https://github.com/natepisarski/Cookbook-hs/blob/master/Cookbook/Project/Preprocess/Preprocess.hs
19:15:19 <lispy> I don't understand this code
19:15:42 <akurilin> monochrom: http://lpaste.net/3226475300720214016
19:15:48 <akurilin> I'm 100% sure I'm doing something derpy.
19:17:20 <heatsink> akurilin: the field names are also qualified
19:18:28 <monochrom> oh! yes, DB.shortName
19:18:35 <akurilin> so do BD.MyConstr {BD.id = 1} instead?
19:18:40 <monochrom> yes
19:18:52 <akurilin> Still getting same error :(
19:19:14 <akurilin> updated lpaste
19:19:29 <monochrom> no error here. well, except for "missing field", but it's deliberate
19:20:50 <akurilin> Rebooted the repl, seems to work now
19:21:01 <akurilin> *shrug*
19:24:31 <akurilin> I'm trying to understand the combinator style used in aeson's parseJSON examples, would appreicate is someone would spot my reasoning. So it looks like the first step is to use MyConstr <$> v .: "foo" to apply the constructor function to whatever's inside the Parser returned by the .: operation, yes?
19:25:07 <akurilin> (to clarify, v being the parameter (Object v))
19:25:38 <lispy> .: is non standard but when I've seen it used in the past it's like (.) but for functions with two parameters
19:25:46 <c_wraith> lispy: not in aeson
19:26:10 <c_wraith> lispy: aeson defines its own .: that does map building.
19:26:11 <lispy> c_wraith: ah, glad you corrected me.
19:26:26 <c_wraith> err, map unbuilding.
19:26:27 <c_wraith> One of those
19:27:10 <lispy> in that case, it's probably meant to be MyConstr <$> (v .: "foo")
19:27:25 <lispy> But, I don't really know the fixity of .:
19:27:29 <akurilin> so it seems that each <*> invocation runs the curried constructor function against the next parsed key/value pair within the Parser context
19:28:01 <akurilin> lispy: that's fair, I made a fixity assumption there
19:28:35 <hae> Lol I was about to tell that guy don't forget my tip.
19:28:56 <akurilin> So does the above more or less sound sane?
19:29:08 <hae> He was under the impression that introductory Haskell advice warrants Bitcoin if you can believe it.
19:31:21 <jle`> akurilin: you can think of something like f x y z working on normal values, f <$> x <*> y <*> z working on "wrapped" values x, y, and z
19:32:41 <akurilin> jle`: oh I see, I guess that also explains why the ordering is important there
19:32:55 <Cale> Though "wrapped" is really loose terminology.
19:33:26 <Cale> They could be computations which produce the values which f is going to be applied to
19:33:56 <akurilin> Cale: that's fair
19:34:00 <jle`> to speak in types
19:34:18 <jle`> in the first case, you are applying f :: a -> b -> c -> d to x :: a, y :: b, and z :: c
19:34:24 <Cale> Or they could be things like whole lists of values, and all possible combinations of entries of those lists will be used
19:34:36 <jle`> in the second case, you are applying the same f :: a -> b -> c -> d to x :: m a, y :: m b, and z :: m c
19:34:47 <jle`> and returning m d
19:34:52 <Cale> > (\x y z -> x + y + z) <$> [1,2,3] <*> [40,50,60] <*> [700,800,900]
19:34:53 <lambdabot>  [741,841,941,751,851,951,761,861,961,742,842,942,752,852,952,762,862,962,743...
19:36:00 <jle`> > (+) 5 7
19:36:01 <lambdabot>  12
19:36:05 <jle`> > (+) <$> Just 5 <*> Just 7
19:36:07 <lambdabot>  Just 12
19:36:10 <jle`> > (+) <$> Nothing <*> Just 7
19:36:11 <lambdabot>  Nothing
19:36:30 <hae> ?
19:36:30 <akurilin> I think I get the gist.
19:36:53 <jle`> in the case of Parsers though, you are applying it to Parser a, Parser b, etc., to create a new parser that "runs" the x, y, z parsers, and essentially "fmaps" the function onto all of the results
19:37:13 <jle`> if you are used to monadic notation/do notation, it'd be like do { x' <- x; y' <- y; z' <- z; return (f x' y' z') }
19:38:00 <jle`> i've heard of Applicatives being introduced as basically motivated by the search of a solution to the generic liftN function
19:38:37 <lispy> That seems like one ap-plication.
19:38:54 <lispy> er, <*>-plication?
19:39:13 <jle`> :P
19:39:30 <jle`> i'm not sure if that was historically the case. does anyone know?
19:40:17 <lispy> My impression is that monads stole the show for quite some time and when the dust settled the other concepts finally caught on. applicatives being one of those other concepts.
19:40:45 <akurilin> So on a related note, has anybody had to parse a tree-like structure with Aeson? I haven't been able to find examples of it being used recursively anywhere. I have a key "children" in my hashmap which is just an array of the same node type, so I imagine I'd want to run a "decode" of sorts on it, except I already have the hashmap ready, so decode won' quite work.
19:42:47 <lispy> jle`: I think people had discovered applicative parsers before monad had its own syntax. Not certain though.
19:52:57 <ReinH> akurilin: you might like Data.Aeson.Lens
19:53:05 * hackagebot treeviz 0.0.7 - Visualization of computation decomposition trees.  http://hackage.haskell.org/package/treeviz-0.0.7 (DavidBanas)
19:57:56 <akurilin> ReinH: could you be more specific about the use case?
19:58:07 <ian_g> o/ Haskell!  I'm curious if anybody knows the difference between the bound and unbound libraries?
19:58:18 <akurilin> It seems like Aeson can parse a tree recursively pretty well as long as the node types are the same
19:58:51 <akurilin> I have an extra complication in place with having a couple of node types
19:59:25 <ReinH> akurilin: well, lenses generally are good at navigating complex structures
19:59:35 <ReinH> as are the aeson lenses
20:01:28 <zcd> is there a nice clean way to pattern match record syntax?
20:01:48 <zcd> all my expressions end up very long due to the accessor functions inside
20:01:59 <zq> zcd: (Constructor{..})
20:02:20 <zq> you'll need a -XLanguageExtension, but i don't recall which
20:02:37 <ReinH> well, they can be matched as non-record syntax data types
20:02:46 <vozz> Does anyone know how to do input masks in Gtk2Hs? I'm trying to mask a completely blank input mask, i.e. all the clicks go straight through the window to the window below.
20:02:58 <zcd> zq: is that the exact syntax?
20:03:03 <intrados> -XNamedFieldPuns
20:03:04 <ReinH> data Foo = Foo { thing :: Bar } can be matched as f (Foo bar) = bar
20:03:18 <intrados> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/syntax-extns.html
20:03:26 <zq> zcd: -XRecordPuns
20:03:41 <shachaf> NamedFieldPuns and RecordWildCards, or whatever those are called, are kind of evil.
20:03:59 <zcd> ReinH: does this work with multiple elements? if so i assume that it's matched by order?
20:04:06 <ReinH> zcd: yes and yes
20:04:20 <ReinH> zcd: record syntax is just sugar for defining the projections
20:04:43 <ReinH> they still behave like normal data types
20:04:55 <zcd> oh nifty
20:04:55 <pavonia> vozz: What do you mean by mask here?
20:07:10 <ian_g> zcd: You can do something like "fun Foo{thing=bar} = bar"
20:07:55 <vozz> pavonia: http://hackage.haskell.org/package/gtk-0.12.5.6/docs/Graphics-UI-Gtk-Abstract-Widget.html ctrl+f inputshape, I want my window to ignore all input and let it pass to the window below
20:08:06 <ian_g> zcd: if you want to update something you can say something like fun foo@(Foo{thing=bar}) = let bar' = ...bar... in foo {thing=bar'}
20:09:14 <vozz> pavonia: I tried this but it gave an error http://lpaste.net/102803
20:09:35 <pavonia> vozz: Oh, I don't know about this, sorry
20:09:39 <zcd> ian_g: does that exact line work (updating a single element) if Foo has multiple elements?
20:09:46 <vozz> This is the error: http://lpaste.net/102804
20:09:49 <vozz> Okay, thanks anyway
20:09:50 <ian_g> zcd: yes, you don't have to worry about the other elements
20:10:07 <zcd> oh nice
20:10:26 <zcd> my only gripe is that the { } braces arent very aesthetically pleasing hehe
20:10:33 <ian_g> zcd: yup it's pretty handy
20:10:44 <ian_g> zcd: Yeah, that's the only drawback.  { } seem foreign to the rest of Haskell
20:12:40 <ReinH> zcd: you might want to try lens
20:13:25 <ian_g> ReinH: zcd: Lenses are a good next step if you find your stuff mired in record syntax, but if you're just using it here and there it may not be worth the trouble
20:13:40 <ian_g> ReinH: <3 lenses tho
20:14:11 <zcd> the hackage page looks quite intimidating
20:15:08 <lispy> zcd: it really is, but the library is less so
20:15:19 <lispy> zcd: There have been some great recorded talks about lens.
20:15:28 <lispy> zcd: two by edwardk and one by spj
20:16:44 <ian_g> zcd: the Simon Peyton Jones talk on Skills Matter is pretty good
20:17:03 <ian_g> zcd: also a lot of good intros on FPComplete's site
20:17:30 <zcd> oh found a video. looks like a powerful tool well worth learning
20:17:48 <ian_g> :)
20:17:49 <lispy> ian_g: I can't view the one on skillsmatter, is there a trick?
20:17:51 <zcd> thanks for the tips
20:18:06 <ian_g> lispy: you gotta make an account first....sigh...I gave in
20:18:10 <lispy> I found this thread, but the URL doesn't have a video: http://www.reddit.com/r/haskell/comments/1o1z8x/simon_peyton_jones_on_lenses_at_the_haskell/
20:18:14 <ian_g> lispy: I thought it was worth it, though.
20:19:11 <lispy> But, the hassle, security, and privacy implications...
20:19:53 <nisstyre> it used to be available for free/without handing over your info
20:20:00 <nisstyre> I should've downloaded it then
20:20:11 <nisstyre> they should CC license this stuff
20:22:08 <lispy> There are some good SO posts about lens too
20:22:43 <shachaf> I'll be doing some sort of lens class thing at bayhac next month.
20:24:27 <srhb> shachaf: Did you change timezone recently?
20:24:44 <shachaf> srhb: Not since the DST change.
20:24:49 <srhb> Hm.
20:25:03 <srhb> I must have just been awake more in the middle of the night here.
20:27:19 <shachaf> http://ircbrowse.net/nick/shachaf?recent=false
20:27:58 <srhb> Well, it was probably a year ago since I were really active in this channel.
20:28:56 <lispy> zcd: if you don't want to signup at skillsmatter you might try this: http://www.reddit.com/r/functionalprogramming/comments/1xmaop/simon_peyton_jones_on_adventures_with_types_video/
20:32:55 <carter> geekosaur: i didn't know you were brandon!
20:34:17 <Seabasschan> Did the people who wrote this [http://hackage.haskell.org/package/list-tries-0.5.1/docs/Data-ListTrie-Patricia-Map.html] only barely understand big-O notation?
20:34:47 <Seabasschan> What are they measuring? Worst case, best case, or average case time complexity?
20:35:40 <carter> i assuem worst case bounds
20:35:58 <carter> ?
20:36:00 <Seabasschan> Right... so what's O(min(m,s)) then?
20:36:36 <carter> well, what are m and s?
20:36:54 <carter> pick the smaller
20:36:55 <Seabasschan> This seems a little too specific to be worst case.
20:36:55 <napping> It's defined at the top
20:36:59 <napping> seems reasonable to me
20:37:21 <carter> m == max length of list
20:37:33 <napping> max length of a key in the trie
20:37:41 <carter> yes
20:37:42 <carter> that
20:37:53 <carter> "Worst-case complexities are given in terms of n, m, and s. n refers to the number of keys in the map and m to their maximum length. s refers to the length of a key given to the function, not any property of the map."
20:38:05 <dolio> Sometimes complexity of an operation has more than one independent parameter.
20:38:07 <napping> seems entirely reasonable to say it takes no more steps than the length of the key you give it, and also no more than the longest existing key
20:38:22 <carter> yup
20:38:24 <napping> now there is something tricky about complexities of a lookup on the underlying map
20:38:53 <carter> dolio: dont forget the crazy tilde O(n) complexities
20:39:24 <carter> some complexity theorists are assholes who hide their poly log terms
20:39:32 <carter> by putting a Tilde on top of the BigOh
20:40:16 <akurilin> Is there a quick and hacky way of getting right out of an either if I'm just playing around in the repl?
20:40:21 <dolio> Like, O(n * log log n) is ~O(n)?
20:40:24 <akurilin> as opposed to making a fn with pattern matching
20:40:35 <carter> dolio: yeah
20:41:18 <luite> carter: some hide polynomial terms :)
20:41:20 <carter> i think poly log even hides log terms
20:41:27 <carter> luite: sound like assholes
20:41:31 <dolio> I guess there's some argument you could make for that.
20:41:32 <carter> who does that
20:41:40 <carter> yeah
20:41:48 <dolio> log n is debatable.
20:42:00 <dolio> But if you care about log log n,  you should probably care about constant factors, too.
20:42:32 <carter> oh
20:42:33 <dolio> Or something like that.
20:42:34 <carter> maybe it was log log
20:42:35 <carter> idn't
20:42:40 <carter> poly(log n) was what i think about i
20:42:40 <carter> tyeah
20:42:43 <carter> dolio: i'm chewing on figuring out the most minimal api possible that can be shared by dense and sprse matrices
20:42:43 <carter> *parse
20:42:43 <carter> *sparse
20:42:55 <carter> any thoughts?
20:43:05 <dolio> Ed's probably the one to talk to about that.
20:43:10 <carter> fair
20:43:24 <carter> i think i have the "right answer"
20:43:26 <carter> which is that a given array needs to provide its left fold
20:43:33 <carter> and a Maybe'd read write
20:45:03 <luite> carter: well it makes sense if you're doing exponential time analysis, say you have p(n)*c^n and you compute your c, then any rounding up in the computation will drop your p(n) term anyway
20:46:09 <carter> yeah
20:46:09 <carter> fair
20:46:09 <carter> i was kinda thinking that
20:46:09 <carter> otoh, as dolio  says, it can be a nontrivial "constant factor"
20:46:35 <carter> http://arxiv.org/pdf/1305.1922v1.pdf is probably a good nontrival example of a log factors afoot
20:46:40 <carter> less crazy than others i'v seen
20:48:04 <carter> oh http://arxiv.org/abs/1102.4842 has the O tilde notation
20:48:44 <carter> "The O˜ notation hides a (log log n)^2 factor"
20:48:47 <carter> dolio: you're right
20:58:59 <Seabasschan> There's no "min" in worst-case analysis, as far as I'm aware.
20:59:12 <Seabasschan> It doesn't go that far into detail.
20:59:42 <carter> Seabasschan: nope
20:59:48 <carter> i've TAed algorithms classes
20:59:50 <carter> min is valid
21:00:02 * carter doesn't like arguing from authoritiy
21:00:10 <Seabasschan> As did I... and I think we got given different information.
21:00:17 <carter> umm
21:00:23 <carter> the bound is the less of these two numbers
21:00:26 <carter> is a valid upper bound
21:00:52 <Seabasschan> According to which reputable resource?
21:01:00 <carter> any computer scientist
21:01:06 <Seabasschan> Please show me your citation.
21:01:13 <carter> hush you
21:01:23 <carter> this isn't constructive
21:01:32 <Seabasschan> It's the worst case!
21:01:36 <carter> yes
21:01:43 <carter> min (x,y) can be valid upper bound
21:01:53 <carter> a tight upper bound is better than a loose one
21:01:57 <jle`> Data.Map.Strict's insertWith appears to be the main bottleneck in my computation. any options?
21:02:07 <carter> jle`: whats the algorithm you're tryign to do?
21:02:10 <Seabasschan> Ugh...
21:02:35 <carter> Seabasschan: will you agree that min(x,y) is less than max(x,y) ?
21:02:39 <napping> Seabasschan: whyever not?
21:02:56 <carter> and that min(x^2,x^5) is less than max(x^2,x^5) ?
21:02:59 <Seabasschan> Well, I'm no Haskell expert... Do you know what the classical definition for a patricia trie is, carter?
21:03:08 <carter> i can look it up
21:03:11 <jle`> um just using Pipes and Pipes.Prelude.fold to build a streamingly build a frequency table of the bytes of a large file
21:03:14 <jle`> actually...i should profile better
21:03:31 <napping> Isn't O(f(x,y)) a reasonable form for a worst-case bound when you need several parameters to characterize the input?
21:03:32 <carter> Seabasschan: we're not talkign about the library, we're talking about big oh notation
21:03:34 <Seabasschan> carter: Any information you find on the internet will likely be inaccurate. It's specified by TAOCP.
21:03:41 <jle`> it could be either the IO or the breaing of ByteString into Word8's
21:03:41 <carter> nope
21:03:53 <carter> jle`: benchmark
21:04:01 <jle`> yea, on it.
21:04:02 <carter> napping: you're correct
21:04:46 <jle`> is there a modern/up to date guide to benchmarking using the latest sexy libraries
21:04:56 <carter> jle`: use criterion
21:05:19 <jle`> mk
21:06:03 <carter> criterion is great for measuring individual operations
21:06:16 <carter> ohhh
21:06:24 <carter> jle`: do you need an exact frequence count
21:06:26 <carter> or?
21:06:40 <carter> have you tried IntMap?
21:06:42 <carter> or ummm
21:06:44 <carter> hrmmmm
21:06:56 <carter> heck, an array :)
21:07:18 <carter> jle`: you're using 8 bit bytes right?
21:07:32 <carter> just make an unboxed array and count them!
21:08:05 <carter> jle`: right?
21:10:28 <carter> http://courses.csail.mit.edu/6.042/fall13/asymptotic-notation.pdf  http://courses.csail.mit.edu/6.042/fall13/asymptotic-properties.pdf and  http://courses.csail.mit.edu/6.042/fall13/asymptotic-blunders.pdf
21:10:39 <carter> are good basic defns of big oh
21:10:49 <Seabasschan> carter: Would you consider Robert Sedgewick to be an expert?
21:10:55 <carter> yup
21:11:12 <carter> so you're admitting i'm right? :)
21:11:17 <Seabasschan> Well, his worst-case definitions for a patricia trie are different to those in the docs I linked to.
21:11:21 <carter> oh
21:11:22 <Seabasschan> That's my problem.
21:11:26 <carter> i wasn't tlaking about that
21:11:33 <Seabasschan> No, you weren't.
21:11:40 <carter> ok)
21:11:43 <carter> you didn't make that clear :)
21:11:57 <Seabasschan> I apologise... You were right, but that doesn't help my problem.
21:12:01 <carter> ok
21:12:11 <carter> i assume that the functional trie has an extra log factor right?
21:12:18 <Seabasschan> My problem is that I'm not sure if the trie library I linked to is a classical Patricia trie implementation or not.
21:12:23 <carter> oh
21:12:24 <carter> well
21:12:29 <carter> classical tries are probably mutable
21:12:39 <carter> i'd assume the one you linked to is a persistent/functional one
21:12:42 <napping> this one is parameterize over a map type used inside each node, for one
21:13:00 <carter> yeah
21:13:10 <carter> and most functional maps have a log n
21:13:16 <carter> or log log n for certain special ones
21:13:33 <napping> well, that's the comment at the start saying all the time complexities are actually in terms of number of underlying-map lookups
21:13:38 <carter> yeah
21:13:52 <carter> which is pretty sloppy / lazy :)
21:14:01 <carter> so they're all missing a log factor
21:14:08 <Seabasschan> carter: Sedgewick said "Insertion or search for a random key in a patricia trie built from N random bitstrings requires ... about 2 lg N bit comparisons in the worst case. The number of bit comparisons is never more than the length of the key"
21:14:22 <carter> yeah
21:14:44 <carter> the big Oh in this module is supressing an * f(n) factor
21:15:18 <carter> multiply everything you see by log n
21:15:22 <carter> and the numbers are less bonkers
21:15:24 <carter> :)
21:15:36 <napping> I think that's a bit tighter of a bound actually, if it's accurate here
21:15:39 <lispy> jle`: if insertWith isn't cutting it and you have some optimization in mind, you can try mergeWithKey.
21:15:54 <carter> lispy: he's counting bytes
21:15:59 <carter> theres < 256 of them
21:16:02 <Seabasschan> Yes. I presume they're assuming the key length is constant... Which could be fair enough, really, since a classical trie is harder to implement using varying-sized keys than fixed-size.
21:16:04 <carter> he should use an ST array
21:16:12 <carter> are they
21:16:13 <napping> I don't see where either assumes that
21:16:28 <lispy> ah, yeah ST array should be optimal
21:16:38 <napping> rather, if you are talking about bit strings, the length of the longest string in the trie must be at least lg N
21:16:46 <carter> jle`: use an ST array
21:16:47 <napping> otherwise you wouldn't have that many distinct strings
21:17:14 <carter> counting / information theory!
21:17:22 <carter> lispy: array apies are HARD to design
21:17:23 <carter> ok
21:17:24 <carter> i'm off
21:17:25 <carter> night alll
21:17:40 <lispy> s/array//
21:17:41 <Seabasschan> So the worst case for union, O(min(n1 m1,n2 m2))
21:17:48 <Seabasschan> That should have an extra log...
21:18:36 <Seabasschan> I think I'll just look for a better resource.
21:18:54 <napping> what kind of data structure are you looking for anyway?
21:19:40 <Seabasschan> Well, I'm writing my own, but trying to gather stats about how the algorithms should actually perform in worst case.
21:20:29 <Seabasschan> The language I'm using isn't Haskell, though I am familiar with Haskell... Hence, I wanted to use this resource. Most PATRICIA-related resources are garbage.
21:21:15 <carter> Seabasschan: you should look at some of edwardk's libs :)
21:21:29 <carter> http://hackage.haskell.org/package/heaps is a neat one
21:21:47 <carter> http://hackage.haskell.org/package/unordered-containers is pretty nice
21:38:17 * hackagebot purescript 0.4.19 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.19 (PhilFreeman)
21:39:59 <jle`> carter: yeah in C land I would have used an array and allocated 256 slots
21:40:21 <Seabasschan> Where does 256 come from?
21:40:39 <jle`> i'm building a frequency table of bytes
21:40:49 <jle`> oh sorry
21:40:53 <jle`> unrelated to your question i think
21:40:55 <Seabasschan> Ahh... Then you might want to use UCHAR_MAX.
21:43:24 <jle`> ty
21:59:39 <napping> Is there a good way to make optimization optional in a cabal file?
21:59:50 <napping> or to temporarily turn it off while working?
22:00:05 <johnw> napping: --disable-optimization
22:00:12 <napping> ah, I didn't see that in the --help
22:00:17 <johnw> and just don't specify it at all in your .cabal file
22:00:25 <johnw> -O is the default
22:00:33 <johnw> if you specify it manually, you can't disable it with that option
22:00:38 <napping> oh
22:00:41 <napping> I guess that works
22:01:03 <napping> I put -O2 but I'm not sure if it really makes any difference
22:01:09 <johnw> it usually doesn't
22:01:21 <johnw> in fact, it's recommended to use -O until you've proven that -O2 is worth the compile time
22:01:51 <napping> Well, I'll just drop it entirely for now so that option works
22:03:51 <napping> what if you do have ghc-options?
22:04:01 <johnw> that's OK
22:04:06 <napping> ok,
22:04:17 <napping> I'm using that on a test program to get -threaded -eventlog -rtsopts
22:04:27 <johnw> makes sense
22:08:07 <napping> my 18.0.3 doesn't seem to take that flag
22:08:21 * hackagebot yesod-core 1.2.14 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.14 (MichaelSnoyman)
22:09:50 <johnw> "'ghc-options: -O' is not needed. Cabal automatically adds the '-O' flag. Setting it yourself interferes with the --disable-optimization flag."
22:09:55 <johnw> that's a string from within my cabal executable
22:11:14 <napping> what version are you using?
22:11:21 <johnw> 1.18.0.3
22:11:27 <napping> I think I've turned optimization off in my cabal config
22:11:32 <johnw> ah
22:11:42 <napping> can you actually run cabal build --disable-optimization
22:11:51 <johnw> ah, no
22:11:55 <johnw> you specify that at the configure step
22:12:41 <napping> ah okay
22:14:17 <napping> that should help. I'm trying to tidy up git history before sharing some code, and want to do things like check that all revisions actually still build
22:28:24 * hackagebot conduit 1.1.0.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.1.0.2 (MichaelSnoyman)
22:38:25 * hackagebot yesod-platform 1.2.10 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.10 (MichaelSnoyman)
22:38:26 <gamegoblin> Not haskell: what’s the mathematical notation of applying a function to every element of a matrix? i.e. if I have matrix A, can I say tan(A) and mean “the matrix returned by applying tan() to every element of A”
22:39:59 <lispy> gamegoblin: this is a place where mathematicians are notorious for abusing notation.
22:40:11 <shachaf> It sounds like you answered your own question.
22:40:15 <shachaf> lispy: ?
22:41:22 <lispy> shachaf: Would you prefer, defining overloaded notation?
22:41:31 <lispy> shachaf: (I'm not sure what you're asking me)
22:41:46 <shachaf> I'm not sure what you mean.
22:42:40 <gamegoblin> Mmm ok then. Well then here is an algorithms question for anyone who wants it. I have matrices A and B. I want to find a vector x such that B*sigmoid(A*x) maximizes a particular element in the vector output by that expression. Any ideas?
22:43:12 <lispy> shachaf: math books and lectures will define tan(A), where A is a container (Set, or matrix, or ...) to be tan applied at each element.
22:44:16 <lispy> gamegoblin: this sounds like machine learning homework :)
22:44:31 <Jafet> This sounds like machine learning gone wrong
22:44:36 <gamegoblin> lispy: Not homework, just hobby.
22:44:44 <gamegoblin> Jafet: not gone wrong
22:44:51 <shachaf> lispy: Oh, I thought you meant "this" as in #haskell.
22:45:05 <lispy> shachaf: ah, I can see the confusion now.
22:45:15 <gamegoblin> I have an autoencoder and I want to find which pattern maximizes the activation of a particular hidden neuron
22:46:01 <gamegoblin> When the hidden neuron is in the layer adjecent to the input layer, it’s easy
22:46:15 <lispy> gamegoblin: I don't have the exact form memorized, but isn't this a case where people use jacobi iterations?
22:46:33 <gamegoblin> I am not familiar with jacobi iterations. Will look up, thanks.
22:46:59 <gamegoblin> Mmmm looks like it’ll work
22:47:06 <lispy> gamegoblin: https://www.coursera.org/course/ml
22:47:29 <Jafet> This problem doesn't look linear.
22:48:12 <monochrom> this sounds like human learning homework :)
22:48:26 * hackagebot purescript 0.4.19.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.19.1 (PhilFreeman)
22:49:14 <gamegoblin> I’ll go ask a numerical linear alg professor about it tomorrow, I guess
22:50:12 <Jafet> "When we write programs that 'learn', it turns out that we do and they don't."
22:50:47 <gamegoblin> Ha. That’s clever.
22:51:14 <gamegoblin> But hey my network can currently recognize handwritten digits with 98% accuracy
22:51:18 <stevejb> I am trying to install holy-project. I have ghc 7.8.2 installed, and I am getting the following error http://ix.io/bJG
22:51:20 <lispy> gamegoblin: I no longer remember the details, but I took the machine learning course I linked you and it covers this. For instance, I don't remember if jacobi would have problems with your non-linear problem but there are methods that can handle it.
22:52:29 <peddie> gamegoblin: http://ufldl.stanford.edu/wiki/index.php/Visualizing_a_Trained_Autoencoder
22:53:01 <gamegoblin> peddie: that only applies to the first hidden layer, which is pretty trivial
22:53:58 <peddie> gamegoblin: oh, you said that above; sorry :)
22:53:59 <gamegoblin> I’m trying to visual the center layer of deep autoencoders. The example I gave was 5 layers, but I assume the method would generalize to N layers. I have a 7 layer one training right now on a GPU cluster.
22:54:51 <gamegoblin> So that would require minimizing a particular element of C*sig(B*sig(A*x)) ;D
22:54:58 <lispy> gamegoblin: with traditional neural networks you can't train very deep. Are you using the deep learning stuff?
22:55:08 <Jafet> The sigmoid is monotonic, so you can try a gradient search.
22:55:27 <gamegoblin> lispy: yes, I’m a grad student who researches very modern methods.
22:55:50 <shachaf> I research methods so modern, they haven't been invented yet.
22:55:56 <shachaf> (Which is why I need to research.)
22:56:03 <gamegoblin> No no see Hinton et al 2006
22:56:11 <lispy> shachaf: Speaking of which, so did you make up the term profunctor or did you find it elsewhere?
22:56:50 <lispy> shachaf: SPJ's slides about lenses attributes profunctors to you and someone else (who's name I forget)
22:57:18 <shachaf> I didn't make up profunctors.
22:57:36 <corgifex> http://en.wikipedia.org/wiki/Profunctor
22:57:44 <shachaf> Oh, I did make up profunctor optics. SPJ attributes something to me?
22:58:40 <lispy> shachaf: I sent you a link
23:04:09 <gamegoblin> lispy: along with using deep belief stuff (restricted boltzmann machines, etc), in my lab we are working on various competing methods to solve the disappearing gradient problem. I tend towards the AI side of things rather than the ML side of things. That is, I am more interested in things like cognitive architecture, so I wire up networks in clever ways rather than spend most of my time developing new techniques.
23:05:53 <lispy> gamegoblin: cool.
23:05:54 <shachaf> edwardk introduced Profunctor to lens after I introduced a class which was trying to be a particular sort of profunctor
23:09:47 <lispy> gamegoblin: if the coursera website lets you look at specific lectures that class might still interest you. It does a good job of covering the material and you implement all this stuff, much like your question above.
23:09:51 <lispy> Now I must sleep.!
23:10:16 * lispy >=> bed
23:10:44 <erisco> (lispy >=> bed) now
23:13:14 <stevejb> Does anyone have a moment to look at my cabal error here: http://ix.io/bJG
23:13:32 <stevejb> This is trying to install holy-project from a completely clean 7.8.2
23:15:33 <shachaf> He named an illegal traversal. :-(
23:16:32 <corgifex> stevejb: ok, now what?
23:17:18 <stevejb> corgifex: I guess I am curious about how to go about fixing this sort of thing.
23:17:43 <corgifex> well, first you patch MonadCatchIO-transformers
23:18:01 <corgifex> then you're either a maintainer or you submit the patch to a maintainer
23:18:58 <stevejb> corgifex: oh, it seems like this package is being deprecated (https://github.com/ekmett/lens/issues/301)
23:19:32 <shachaf> Profunctor is a perfectly justified abstraction for lens. :-(
23:19:45 <shachaf> It's so much better than the ridiculous things we had before.
23:20:39 <Wizek> Good Morning!
23:26:48 <dmp1ce> I'm trying to write a program using HDBC and cabal.  When I run "cabal install" to install dependencies I get "ghc: out of memory (requested 1048576 bytes)" after Compiling Data.Text.Lazy.Builder.RealFloat  What should I do to resolve this?
23:31:36 <dmp1ce> I'm using Arch Linux, but I'm really not sure how to get the up-to-date GHC and cabal-install.  What is recommended?
23:32:32 <FrankTominc> Hi guys, i'm new on the field of the functional languages, from where i should start??
23:32:54 <pavonia> @where lyah
23:32:54 <lambdabot> http://www.learnyouahaskell.com/
23:33:04 <Iceland_jack> FrankTominc: Learn You a Haskell ↑
23:33:13 <Iceland_jack> Install GHC and get going
23:33:32 * hackagebot logging 1.4.0 - Simplified logging in IO for application writers.  http://hackage.haskell.org/package/logging-1.4.0 (JohnWiegley)
23:33:41 <pavonia> dmp1ce: Do you have some memory usage restrictions for processes enabled on your system?
23:34:09 <FrankTominc> Thanks Iceland_jack
23:34:55 <Iceland_jack> Feel free to ask questions here if you run into trouble, LYAH is available freely online
23:35:10 <Iceland_jack> (with the link pavonia provided)
23:38:57 <FrankTominc> should i buy a printed copy of the book??
23:39:34 <Iceland_jack> If you want to, certainly
23:39:39 <ddere> FrankTominc: Its a great book
23:39:47 <Iceland_jack> Yes, I have a copy
23:40:23 <ddere> i dont really look back on it as a reference i suppose, but a physical copy is a great thing to have around when a friend or co worker expresses interest in haskell
23:40:58 <Iceland_jack> Yes, I've lent mine to friends but it's also a way of supporting the author if you appreciate the work
23:42:09 <ddere> yup!
23:42:45 <dmp1ce> pavonia: I don't think so, but possibly.  It is a fresh installation of Arch Linux on a VirtualBox VM.
23:42:59 <ZettaBlade> I bought a copy, its just great. Lots of love went into lyah
23:43:57 <FrankTominc> seems like a great book, although a little expensive for me
23:44:18 <FrankTominc> i'm from Brazil, so the price is something like the double of the original value
23:44:32 <ddere> ah :(
23:44:51 <Iceland_jack> FrankTominc: Well the author put it up online for anyone to read, free of charge!
23:45:44 <zRecursive> FrankTominc: How much do 100 US$ exchange your native money ?
23:46:14 <pavonia> dmp1ce: I'm asking because running out of memory with a request of 1MB is really unlikely even on dated systems ;)
23:46:48 <Jafet> pavonia: try requesting 1MB a few thousand times
23:46:53 <FrankTominc> zRecursive: let me see
23:47:24 <FrankTominc> zRecursive: 224 BRL
23:47:32 <pavonia> Jafet: I think ghc would yield another message then, no?
23:47:43 <Jafet> Nope
23:47:47 <zRecursive> FrankTominc: ok
23:48:23 <Jafet> That is probably what happened. dmp1ce should check how much memory ghc was using at the time.
23:49:25 <pavonia> Hhm, I'm pretty sure GHC reported the overall heap usage to me when crashing once
23:50:03 <FrankTominc> zRecursive: The problem is i'm just a student and this is like half of my month bucket haha
23:50:09 <Iceland_jack> FrankTominc: Note that you can evaluate simple Haskell expressions here
23:50:13 <Iceland_jack> > [1..]
23:50:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:50:18 <Jafet> Maybe ghc does, but the runtime prints only that message
23:50:48 <FrankTominc> Iceland_jack: Oh, that's fun
23:50:53 <FrankTominc> [1 .. 20]
23:51:00 <Iceland_jack> You need a '> ' in front
23:51:01 <Iceland_jack> > map (^2) [1..]
23:51:02 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
23:51:15 <FrankTominc> > [1 .. 20]
23:51:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
23:51:22 <orion> Would it be correct to say that writing a Haskell is like designing a series of highways, and Monads allow you to actually drive a vehicle down them?
23:51:30 <orion> a Haskell program*
23:51:55 <Jafet> No, it is not advised to drive down a highway in a spacesuit.
23:52:12 <Iceland_jack> something something burrito
23:52:14 <FrankTominc> > map (^3) [1 .. 20]
23:52:15 <lambdabot>  [1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,...
23:52:16 <johnw> orion: I would really never use that analogy
23:52:20 <Jafet> > (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
23:52:22 <lambdabot>  "314159265358979323846264338327950288419716939937510582097494459230781640628...
23:52:46 <peddie> depends . . . is the highway an endofunctor?
23:53:05 <FrankTominc> what is an endofunctor?
23:53:10 <peddie> :P
23:53:39 <Iceland_jack> FrankTominc: I suggest you start with LYAH first
23:54:00 <peddie> FrankTominc: I'm just making a dumb joke; it's probably not relevant
23:54:03 <Iceland_jack> You need to know what a functor is before endofunctors make any sense
23:54:26 <zRecursive> FrankTominc: it is expensive for me too
23:54:55 <tdammers> best analogy I have found so far is "A Monad is like a Monad"
23:55:18 <tdammers> the highway analogy, in any case, is completely and utterly wrong
23:55:30 * Iceland_jack feels monad analogies (meta or otherwise) should be a bannable offense
23:55:35 <Jafet> It's less than wrong
23:55:52 <Iceland_jack> That's tongue in cheek …kind of
23:55:57 <Jafet> I'm not even sure how highways form a category
23:55:58 <tdammers> is it? it's misleading in any case
23:56:00 <Saizan> tdammers: "a Monad is just a 2-Monad in Cat"
23:56:18 <Jafet> @quote 2-category
23:56:18 <lambdabot> <danharaj> says: arrows are just strong monads in the 2-category of profunctors. what's the problem?
23:56:19 <peddie> Jafet: you compose them with the cloverleaf operator
23:56:49 <FrankTominc> > x | x * x
23:56:50 <lambdabot>  <hint>:1:3: parse error on input ‘|’
23:58:24 <FrankTominc> > double[1 ..]
23:58:26 <lambdabot>  Couldn't match expected type ‘GHC.Types.Double’
23:58:26 <lambdabot>              with actual type ‘[t0]’
23:58:36 <Iceland_jack> FrankTominc: You should learn the language first
23:59:14 <FrankTominc> Iceland_jack: Ok
23:59:41 <hattusili_III> hey is anyone here familiar with using haskell-mode and ghc plugin with emacs?
23:59:48 <FrankTominc> Iceland_jack: i'm just playing with the interpreter :P
