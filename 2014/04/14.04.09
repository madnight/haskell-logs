00:02:35 <erisco> hey great the closed type family worked perfectly for concatenating tuples
00:09:49 * hackagebot adblock2privoxy 1.2.0 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.2.0 (zubr)
00:09:49 * hackagebot meep 0.1.0.0 - A silly container  http://hackage.haskell.org/package/meep-0.1.0.0 (MatveyAksenov)
00:11:15 <bartavelle> let's say I want to build a quasiquoter that for a type that has a Regex (from pcre-builtin) in it. Regex isn't typeable nor data. Am I screwed ?
00:11:31 <bartavelle> it seems like typeable can't be defined as an orphan instance
00:13:33 <johnw> why wouldn't you be able to?
00:13:56 <bartavelle> it seems it's only deriveable now
00:14:02 <bartavelle> ghc doesn't let me
00:14:09 <bartavelle> or perhaps I didn't try hard enough ...
00:15:01 <bartavelle> "Typeable instances can only be derived; replace the following instance:"
00:16:23 <johnw> interesting
00:16:28 <jrmithdobbs> http://stackoverflow.com/questions/20896098/writing-an-instance-declaration-for-typeable-without-deriving
00:16:50 <jrmithdobbs> and there's a good explanation as to why
00:17:39 <bartavelle> oh I understand how it's bad, it's just that I find it troublesome I can't find my quasiquoter :(
00:17:44 <bartavelle> erm, write
00:19:09 <jrmithdobbs> but ya that's expected with 7.8
00:19:50 <bartavelle> well, I'll just have to bug the author and hope he/she cares
00:21:30 <raphie> I'd like to write a library that auto-generates an RPC system using template haskell
00:21:56 <raphie> I've looked at TH tutorials, but I don't get how you'd create a template that takes in a value of an arbitrary type
00:22:54 <bartavelle> raphie, the lens package has some (makeLens and co)
00:23:24 <mgsloan> bartavelle: Does it work if you use standalone deriving?
00:23:39 <bartavelle> oh
00:23:51 <bartavelle> didn't think of that
00:24:46 * hackagebot adblock2privoxy 1.2.1 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.2.1 (zubr)
00:25:19 <true_haskell> Hello, haskell guys
00:25:35 <mgsloan> raphie: What do you mean a "template"?  In the case of splices, which use syntax like $(spliceFunction arg1), then having arg1 be arbitrary type is just having spliceFunction be polymorphic
00:25:38 <true_haskell> I have joined into your community and I want to make our true GAME
00:25:42 <true_haskell> What can you recommend to me?
00:26:12 <alpounet> true_haskell: are you familiar with OpenGL in C, C++ or another language that lets you write OpenGL programs?
00:27:51 <raphie> mgsloan: well, for example, say I wanted to write a function (or I guess a template?) that would convert a function to take only Strings as arguments, which it would then read
00:27:54 <raphie> and then apply normally
00:28:27 <raphie> as in, if we had a function of type Int -> Int, it would convert it to String -> Int
00:29:26 <bartavelle> mgsloan, Can't make a derived instance of ‘Data Regex’:  The data constructors of ‘Regex’ are not all in scope so you cannot derive an instance for it
00:30:05 <bartavelle> but I can probable write this one by hand
00:30:22 <mgsloan> raphie: I see!  One way to do that would be to use ($(readArguments 'f) :: String -> Int) - it's possible to write such a function readArguments by using reify
00:30:37 <mgsloan> bartavelle: Ah, darn :/
00:30:43 <raphie> mgsloan: reify?
00:30:48 <bartavelle> mgsloan, nah it's ok, I can derive typeable
00:30:55 <mgsloan> bartavelle: I guess that's just the deriving mechanism honoring the user's right to make a datatype truly abstract
00:30:57 <raphie> and what's the difference between 'f and f?
00:30:58 <bartavelle> I'll just have to look at how Data instance are created
00:31:04 <mgsloan> bartavelle: Ahh of course
00:31:04 <erisco> I am trying to generically concatenate tuples... I have used a closed type family to unambiguously resolve the concatenated type. however, I am not sure how to implement the concatenation http://lpaste.net/102476
00:31:17 <no-n> :t put
00:31:19 <lambdabot> MonadState s m => s -> m ()
00:31:24 <erisco> instance on line 19 errors ... presumably because 'c' might be (c,d), for instance
00:31:25 <mgsloan> raphie: (f :: Int -> Int), whereas ('f :: Name)
00:31:57 <raphie> mgsloan: oh, so ' extracts the name of the variable, basically?
00:32:02 <raphie> wrapped in what I assume is a monad?
00:32:08 <mgsloan> raphie: So, reify takes a Name and tells you stuff about it.  In the case of values, it will tell you the type
00:32:39 <mgsloan> raphie: Nope, not wrapped in a monad.  The results of "reify" is, though, since it needs to consult information that GHC has collected during compilation
00:32:43 <bartavelle> mgsloan, except Data instances seem to be extremely complicated :)
00:34:02 <erisco> is there perhaps a way to have a negative constraint? ie to say that 'c' cannot be (x,y) ?
00:34:08 <mgsloan> bartavelle: Indeed.  Sometimes deriving can really slow down compilation.  For example, iirc, haskell-src-exts with deriving takes 40 seconds to compile, vs 5 seconds without
00:34:26 <erisco> it would be nice to have closed instances for a class too which were tried in order...
00:34:29 <raphie> mgsloan: ok, so I use reify to grab the function's type, yes? then how do I "wrap" it with my string-adder?
00:34:32 <bartavelle> I'll just hack the original module, and look at what -ddump-deriv says
00:36:33 <mgsloan> raphie: You'll want to recurse down the type peeling off (l ->) and generating an expression that applies the function that number of times
00:37:21 <mgsloan> (err, applies "read" that number of times)
00:37:34 <mgsloan> (or rather, to that number of arguments)
00:38:35 <bartavelle> ok I'm gonna give up "No instance for (Data CInt)"
00:38:56 <johnw> mgsloan!
00:39:22 <mgsloan> johnw, how's it going!?
00:39:40 <johnw> doing well, how are things over there?
00:39:50 * mgsloan switched back to irsii, which turns out to make him more likely to talk on IRC
00:40:02 <bitemyapp> irssi
00:40:12 <johnw> I use a second Emacs app for my ERC
00:40:20 <johnw> having it be in the same Emacs as my editing sessions was too disruptive
00:40:46 <mgsloan> Yeah, I used a second emacs for that as well.  Kept on missing notifications and such, though
00:40:54 <johnw> ah, yeah, you have to set that up
00:41:25 <mgsloan> Overall it's going good, though.  I've moved out to live with friends in seattle for a couple months!
00:42:10 <johnw> (taking this off channel)
00:46:49 <mgsloan> raphie: If that doesn't make sense, I can try to look around a bit for some example code that might be relevant
00:47:08 <raphie> mgsloan: yeah I think that' be helpful!
00:50:48 <raphie> mgsloan: a really simple example that would help a lot is, a template that returns the type of the input as a string
00:50:56 <raphie> just to see how it works
00:58:21 <erisco> I do not see what else to do.. I think I have to wrap parameters in a bogus type
00:58:32 <erisco> and use the bogus type as the assumption that the parameter is a non-tuple
00:58:36 <erisco> then unwrap
01:01:13 <mgsloan> raphie: https://gist.github.com/mgsloan/2a822ba82f6570be7650
01:02:17 <mgsloan> Sorry for the delay!  Anyway, the results of reify are shown there multiple times since ghci runs the compiletime code a few times, for example, once for typechecking. A little surprised it's happening 4 times, but hey
01:04:20 <bartavelle> I have derived Data for CInt, and I get "Data.Data.dataTypeOf _ = (Text.Regex.PCRE.Wrap.$tCInt)"
01:04:24 <bartavelle> what is $tCInt ?
01:06:33 <erisco> unfortunately I cannot seem to unwrap due to the same problem... grr
01:06:43 <mgsloan> raphie: A possibly nicer way to do it (though requires th-orphans): https://gist.github.com/mgsloan/81b17df1f6f24545dcfb
01:09:35 <mgsloan> raphie: One thing that might be confusing about the types is that (a -> b) is cleverly represented as (AppT (AppT ArrowT ...) ...)
01:10:23 <tdammers> I'm having a little trouble with bytestrings in hdbc-postgresql
01:10:45 <tdammers> round-tripping a bytestring through a BYTEA doesn't work
01:11:07 <tdammers> the bytestring goes into the database correctly, but what I get back remains hex-quoted
01:15:07 <Sonarpulse> so I really really want to derive more functors!
01:15:52 <Sonarpulse> in sane terms, I want to deriving a functor for all (kind *) paramaters to my type
01:16:08 <erisco> hrm, though I do not need the type family at all... guess I still do not know their purpose
01:28:37 <m_> What's the best way to learn haskell? "Real World Haskell" or "Learn You a Haskell for Great Good"?
01:28:48 <m_> srry for the noobness
01:29:02 <yitz> m_: the answer is: yes!
01:29:27 <m_> any preference of one over the other?
01:29:34 <corgifex> judging by the titles I'm going to guess RWH isn't for beginners
01:29:47 <shachaf> The answer is probably neither.
01:32:12 <yitz> m_: there's also http://www.apress.com/9781430262503
01:32:25 <alpounet> m_: both are okay, learn you a haskell for great good may be better if you don't have any experience with functional languages I guess. LYAH is smoother, but RWH makes you write a lot of programs that actually do useful things
01:32:31 <quchen> Hutton, LYAH, RWH are the usual introductory Haskell books. There's also the "gentle introduction to Haskell" if you're hardcore.
01:32:31 <yitz> m_: and some older titles, like hutton and thompson
01:32:53 <yitz> shachaf: a lot of people do like them, but not everyone.
01:32:56 <m_> Thanks guys!
01:33:08 <shachaf> yitz: I think they're fine, but probably not "the best".
01:33:11 <johnw> erisco: type families are like type functions: someone gives you a type, and you use the type family to obtain another type.  For example, "Element ByteString" would map to Word8 if you had: type family Element a :: * -> *; type family Element ByteString = Word8.
01:33:38 <yitz> m_: here's is a good list (except it's still missing the newest one): http://www.haskell.org/haskellwiki/Books
01:33:39 <erisco> johnw, well I used it like that, but ultimately I needed to give an implementation for the function
01:33:48 <johnw> hmm?
01:33:53 <yitz> shachaf: write one!
01:34:03 <yitz> shachaf: you'll become rich and famous
01:34:03 <alpounet> shachaf: which one did you start learning haskell with, if any?
01:34:22 <erisco> johnw, http://lpaste.net/102478 I used to have a type family to calculate 'r'
01:34:23 <alpounet> yitz: haha, "Learning Haskell through lenses"
01:34:28 <jtcwang> hey guys, i'm trying to generate a finite list (< 256 items) for quickcheck. I'm a bit lost as to how i'd achieve that
01:34:29 <jtcwang> http://lpaste.net/102477
01:34:29 <erisco> johnw, but there is no need because I can do so by the instance
01:34:34 <jtcwang> can someone guide me?
01:34:35 <shachaf> I think _Programming in Haskell_
01:34:46 <shachaf> At any rate that's a good book to learn from.
01:34:50 <johnw> I don't see a type family there
01:34:51 <Sonarpulse> sometimes, i think it might be easier to learn agda first :D
01:34:54 <shachaf> The others mentioned are also good.
01:35:06 <erisco> johnw, because I took it out... was not needed, which is what I am saying
01:35:08 <yitz> shachaf: that's hutton?
01:35:14 <shachaf> Yes.
01:35:14 <erisco> johnw, so I have not found the case to need one yet
01:35:16 <johnw> erisco: I can't help if I don't know what you tried
01:35:23 <alpounet> shachaf: that's the only one I haven't at least skimmed over. maybe I should get a copy
01:35:34 <corgifex> :t arbitrary
01:35:35 <lambdabot> Arbitrary a => Gen a
01:35:44 <shachaf> My view of books like LYAH is probably distorted because my main exposure to them is people asking questions in here about the parts that confuse them.
01:35:50 <erisco> johnw,  type family ConcatedTuple a b where ConcatedTuple a () = a; ConcatedTuple () b = b; ConcatedTuple (a,b) (c,d) = (a,b,c,d)   and so on
01:36:11 <erisco> johnw, then   class ConcatTuple a b where concatTuple :: a -> b -> ConcatedTuple a b
01:36:14 <yitz> shachaf: like, "what is that big purple elephant supposed to mean?"
01:36:18 <johnw> and the problem you had was what?
01:36:38 <corgifex> jtcwang: my guess is: generate a random number between 0 and 255, then replicateM n arbitrary
01:36:51 <erisco> johnw, the problem I had is the type family seemed unecessary
01:37:42 <shachaf> Like "functors are like boxes" or something. I don't know.
01:37:51 <m_> Thank you for pointing out the elephant in the room
01:38:10 <corgifex> boxes are like functors
01:38:30 <joshi> I am tyring to get inf-haskell working in emacs. I installed the platform from macports and the haskell mode from the package.el in emacs 24. I've checked that ghci is in my path. its located at /opt/local/bin/ghci and /opt/local/bin/ is in my path
01:38:41 <jtcwang> corgifex, i'll give that a try, ty
01:38:47 <joshi> any one has any ideas on what i can try to get it working ?
01:39:23 <shiona> corgifex: but I can't lift myself into a box to do the stuff I'm supposed to
01:39:28 <johnw> joshi: you haven't said why you think it isn't working
01:39:45 <joshi> emacs is complaining that it can't load
01:39:47 <corgifex> shiona: you're not supposed to! you push transformations into the box
01:39:55 <joshi> the inf-haskell file
01:40:07 <johnw> joshi: as with erisco, unless you share some real information, I can offer no help
01:40:10 <corgifex> use the slot marked "insert function here"
01:40:27 <johnw> is inf-haskell.er on your load-path?
01:40:30 <johnw> .el
01:40:38 <joshi> @johnw
01:40:39 <lambdabot> Not enough privileges
01:40:39 <shiona> :D
01:40:57 <erisco> johnw, well the information is as real as it gets. I was just saying that for my case the type family was not necessary and so I have yet to find a case for type families. I was able to perform a function on types without them
01:41:13 <joshi> @johnw yes it is, hang on will give u the stack trace from emacs error
01:41:14 <lambdabot> Not enough privileges
01:41:23 <joshi> @ johnw yes it is, hang on will give u the stack trace from emacs error
01:41:31 <johnw> joshi: on IRC we prefer you to use "johnw: " instead of "@johnw"
01:41:33 <corgifex> joshi: just remove the @
01:41:56 <yitz> jtcwang: a quick look at the haddocks for quickcheck reveals a wide range of combinators for creating Arbitrary instances that have specified maximum sizes. none of those work for you?
01:42:33 * haasn .oO( What is that @johnw being interpreted as? @join? )
01:42:49 <corgifex> yes
01:43:27 <internet> hello
01:44:22 <corgifex> internet: omg I love you
01:44:30 <internet> I'm trying out programming in haskell for the first time right now. Is this the correct place to be?
01:44:40 <internet> corgifex: thank you
01:44:42 <johnw> aren't you yourself the place to be?
01:44:52 <internet> usually
01:45:03 <corgifex> ghci is also a correct place
01:45:28 <joshi> johnw: Debugger entered--Lisp error: (file-error "Cannot open load file" "inf-haskell") \n  require(inf-haskell) \n eval-buffer(#<buffer  *load*> nil "/Users/user-name/.emacs" nil t)  ; Reading at buffer position 1263
01:45:39 <joshi> johnw: does that help ?
01:45:44 <johnw> joshi: it means that the directory containing inf-haskell.el is not in your load-path variable
01:45:46 <corgifex> > 2 + 2
01:45:47 <lambdabot>  4
01:45:59 <johnw> see http://www.emacswiki.org/emacs/LoadPath
01:47:08 <m_> 9 + 9
01:48:02 <joshi> johnw: hmm some more bg I guess, I got the haskell mode package from elpa and it used to work before, when I had two versions of haskell one installed form macports and one long ago . I removed ghci 7.4 which was what was called up when i invoked C-c C-l
01:48:19 <joshi> johnw: thnks for your help so far btw ( and patience )
01:49:05 <johnw> you might also find some good help in #emacs
01:49:18 <johnw> though there are plenty of Emacs people here too
01:50:20 <yitz> jtcwang: oh i see, most of those are for controlling how far QC goes when testing, not for defining what range is valid.
01:53:02 <joshi> johnw: I added  '(add-to-list (quote load-path) /path/to/dir/) to my .emacs and still the same bug.
01:53:24 <johnw> did you put a single quote at the beginning?
01:53:32 <johnw> '(add-to-list ...)
01:53:35 <joshi> yes
01:53:37 <johnw> if so, remove that
01:53:42 <johnw> and quote the directory name
01:53:51 <johnw> "/path/to/dir/"
01:54:50 <corgifex> isn't (quote load-path) the same as just 'load-path?
01:54:55 <johnw> it is
01:56:53 <internet> May I ask a novice question? What is the connection between Category Theory and haskell?
01:57:29 <internet> This is my first time trying to learn a programming language, but I know a bit of CT
01:57:45 <joshi> johnw: this is the exact line I added now ;  (add-to-list 'load-path "~/.emacs.d/elpa/haskell-mode-13.7/")
01:57:57 <joshi> johnw: the error is : Wrong type argument: symbolp, ~/.emacs.d/elpa/haskell-mode-13.7/
01:58:18 <corgifex> does load-path allow "~"?
01:58:40 <joshi> i may hav edone something stupid
01:58:56 <corgifex> looks like it does
01:59:22 <corgifex> internet: I knew a few programming languages but no CT
01:59:57 <joshi> corgifex: replaced ~ with the absolute path; same error
02:00:01 <corgifex> haskell has a few concepts inspired by math, like type classes for Monoid, Functor, Monad, etc
02:00:11 <corgifex> joshi: that had nothing to do with your error message
02:00:46 <corgifex> and apparently there's a category of haskell types called HASK
02:01:22 <johnw> it sounds like you are missing double quotes
02:01:55 <joshi> johnw: i have them
02:03:12 <internet> corgifex: I guess my question is 'what are the categories haskell is working with'?
02:03:47 <corgifex> from what I've heard: haskell types
02:04:20 <corgifex> I've also heard haskell's Functor is really endofunctors
02:04:33 <Kinnison> internet: http://www.haskell.org/haskellwiki/Category_theory and http://www.haskell.org/haskellwiki/Hask may help you relate CT to Haskell
02:08:02 <johnw> joshi: did you perhaps byte-compile your .emacs file?
02:08:15 <johnw> if so, then re-byte-compile it, or remove the byte-compiled file and restart
02:09:12 <joshi> johnw: nope didn't byte compile it.
02:09:27 <johnw> then your error makes no sense to me, sorry
02:09:27 <joshi> didn't know what that was till you mentioned it and I just looked it up.
02:09:51 <joshi> johnw: well thanks for trying to help me figure it out
02:10:18 <johnw> I have lines in my init.el like: (add-to-list 'load-path "~/.emacs.d/site-lisp/ghc-mod/elisp")
02:10:36 <johnw> I'd ask in #emacs at this point
02:10:40 <johnw> they are a helpful bunch
02:11:32 <johnw> corgifex: Hask is the category of Haskell types and functions between those types, with "id" as the identity and "." as associative composition respecting identity
02:11:46 <joshi> johnw: thanks ! will do that
02:11:50 <johnw> corgifex: and yes, Haskell's Functors are endofunctors
02:15:29 <pi1> exit
02:15:37 <johnw> no, we will not let you go
02:16:14 <Kinnison> <fx: guitars>
02:22:07 <identity> I'm looking to do some image manipulation(using repa) and then displaying the images on the screen(some cellular automata). So I need a library that will let me hand it an image buffer and show it on the screen with minimal effort.
02:22:25 <identity> I haveb een looking at GLFW-b and GL, but those require a lot of boilerplate, it seems
02:22:31 <identity> do you guys have any suggestions?
02:22:48 <identity> If it can work with repa arrays that would be even better.
02:25:00 * hackagebot riff 0.2.0.0 - RIFF parser for Haskell  http://hackage.haskell.org/package/riff-0.2.0.0 (RobertMassaioli)
02:34:21 <erisco> wow sweet I think I did it :D meta-programming for two-way routing
02:35:39 <erisco> line 132-139 for the example if anyone is interested http://lpaste.net/102481
02:39:55 <erisco> build' :: (UnArity r r', SegmentBuilder s r) => s -> r'   makes sense
02:40:37 <erisco> I'd *really* like to get rid of the 'Id' in  Maybe (Id Int, String)   but I have no idea how
02:40:59 <erisco> unless I explicitly list every case...  Id a = a; (a, b) = (a, b); (a,b,c) = (a,b,c)  etc
02:41:33 <erisco> guess I'll just do that
02:45:03 * hackagebot websockets 0.8.2.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.2.1 (JasperVanDerJeugt)
02:57:11 <no-n> is there a way around the mutually recursive imports thing?
02:58:20 <corgifex> yes
02:59:40 <haasn> Haskell allows mutually recursive imports
03:00:20 <no-n> I get "Module imports for a cycle:"
03:00:25 <no-n> form *
03:00:45 <bezirg> can I write a Haskell program that takes as input a Haskell source module and fills it back with type signatures of all the types inferred? (not just the types of top-level identifiers)
03:01:03 <bezirg> I was looking at the GHC api
03:01:38 <corgifex> no-n: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
03:02:05 <Okasu> haasn: Haskell - yes, GHC - via ugly cludges named boot files.
03:04:58 <no-n> ty, corgifex
03:12:34 <Eduard_Munteanu> bezirg: that would mean literally everything
03:12:48 <Eduard_Munteanu> bezirg: what's the purpose?
03:13:15 <no-n> @src undefined
03:13:15 <lambdabot> undefined =  error "Prelude.undefined"
03:15:06 * hackagebot puzzle-draw 0.1.0.1 - Creating graphics for pencil puzzles.  http://hackage.haskell.org/package/puzzle-draw-0.1.0.1 (vollmert)
03:15:24 <mr-> @src error
03:15:24 <lambdabot> error s = throw (ErrorCall s)
03:15:57 <mr-> @src throw
03:15:57 <lambdabot> throw exception = raise# exception
03:19:51 <Okasu> @src raise#
03:19:51 <lambdabot> Source not found. You untyped fool!
03:20:04 <Okasu> D:
03:20:09 <MP2E> lol lambdabot
03:20:21 <dagle> @src lambdabot
03:20:21 <lambdabot> Source not found. That's something I cannot allow to happen.
03:21:11 <Taneb> Can GHC 7.4 compile GHC 7.8?
03:24:04 <Malar> Ambiguous module name `Control.Monad.State':       it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2
03:24:07 <Malar> any fix?
03:25:37 <Malar> found a hide-pkg flag.
03:25:44 <Malar> nvmnd
03:30:38 <identity> @src @src
03:30:38 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
03:30:43 <identity> no, I don't.
03:49:52 <erisco> hrm is there a trie-like package with an operation  String -> Trie a -> Maybe (a, String)   such that it matches the longest prefix of the string and returns the remainder?
03:51:04 <erisco> I see Data.Trie has 'submap' which is close but not what I need
03:51:36 <hpc> erisco: i think that module exports the constructors, so you can write it yourself
03:51:44 <hpc> i can't imagine it being a tremendously long function
03:52:10 <erisco> it exports  Trie()
03:52:15 <hpc> oh :(
03:53:32 <erisco> yeah it is a shame
03:53:56 <erisco> well I can build a simpler structure really
03:54:21 <erisco> any overlap I have between two keys is likely to be that the keys are equivalent
03:54:31 <erisco> I guess a Trie is not equipped to deal with that anyways
03:55:41 <erisco> not sure why I was thinking Trie :) well I guess what I need is close to a Trie but not quite
03:57:10 <dv-> https://github.com/vincenthz/hs-tls/blob/master/core/Network/TLS/MAC.hs is there some reason hmacIter has 4 levels of let ... in ... ?
03:58:33 <byorgey> identity: try gloss-raster, I think it even interfaces specifically with repa
03:58:45 <t7> @hoogle intersperse
03:58:46 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
03:58:46 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
03:58:46 <lambdabot> Data.ByteString.Lazy.Char8 intersperse :: Char -> ByteString -> ByteString
03:58:52 <erisco> dv-, hm that is an interesting way of using let .. in
03:59:13 <erisco> makes it look a bit like do-notation
03:59:47 <haasn> ‘let’ can take multiple declarations even when using it as a line of do-notation.
04:00:53 <DogeHayashi> Woo, when I try to compile GHC7.8.1, I get '    Not in scope: data constructor ‘TH.ClassP’
04:00:57 <bezirg> how can I easily remove all my user-install Haskell packages? Should I just remove the folder ~/.ghc/x86_64-linux-7.6.3/package.conf.d ?
04:01:00 <DogeHayashi> Damned enter key, I wasn't finished there =/
04:01:01 <erisco> if I have a function (k -> Ord) can I lookup a value in a Map? ie I want to predicate my key search
04:02:08 <byorgey> erisco: what does (k -> Ord) mean?
04:02:11 <identity> byorgey: thanks!
04:02:53 <byorgey> bezirg: yes
04:02:56 <erisco> byorgey, well ideally there would be a function   lookupBy :: (k -> Ord) -> Map k v -> Maybe v
04:03:01 <bezirg> byorgey: thx
04:03:10 <byorgey> bezirg: in fact you can just remove  ~/.ghc/x86_64-linux-7.6.3, it will be recreated
04:03:26 <DogeHayashi> Hmm, my template-haskell is 2.8.0.0, which is old
04:03:27 <erisco> byorgey, the predicate function compares the key to whatever it is looking for
04:03:38 <DogeHayashi> And trying to upgrade to 2.9.0.0 initiates Cabal Hell
04:03:43 <bezirg> byorgey: oops, I removed ~/.ghc . It is still fine right?
04:03:45 <byorgey> erisco: (k -> Ord) is a kind error
04:03:52 <byorgey> bezirg: yes, that's OK
04:03:54 <erisco> oh sorry
04:03:57 <erisco> (k -> Ordering)
04:04:17 <byorgey> bezirg: it only matters if you have multiple versions of GHC installed and only want to remove the package DB for one of them
04:04:46 <bezirg> byorgey: got it , ty!
04:04:50 <byorgey> erisco: oh, ok
04:05:06 <erisco> hm, although upon further thought I do not think I can write that function for my case
04:05:14 <byorgey> erisco: I still don't quite understand what this function is supposed to do.
04:05:46 <DogeHayashi> nope, that isn't it, 2.9.0.0 wants ghc7.8, and 2.8.0.0 has ClassP...
04:05:49 <erisco> well maybe...
04:06:12 <byorgey> DogeHayashi: do not upgrade template haskell!  It is intimately tied to the version of GHC you have installed
04:06:43 <DogeHayashi> byorgey: figures >_>
04:07:25 <DogeHayashi> byorgey: the template haskell version being old was a red herring anyway, I'm not entirely sure why my build of ghc7.8.1 has bombed with being unable to find bits of it that seemingly exist in 2.8.0.0
04:07:25 <erisco> byorgey, my keys might be "duck" and "cow" .. I have a lookup string such as "cowsheep" and I want to find the first key/value where the key is a prefix of the search string
04:07:38 <byorgey> DogeHayashi: yes, that's strange
04:08:57 <erisco> byorgey, the idea would be to take n characters out of the search string where n is the length of the key, then compare
04:09:00 <DogeHayashi> the bit of code in question is importing all of Language.TH qualified as TH, so TH.ClassP should be there =/
04:10:13 <byorgey> erisco: perhaps you want 'split' and 'findMin'/'findMax'.
04:10:51 <byorgey> erisco: the type you gave does not make much sense, because there is no guarantee that the Ordering returned by the predicate has any relation to the ordering on keys, making it rather difficult to search the Map
04:11:46 <erisco> byorgey, that is true... I am presuming that Map uses 'compare' and so I will do the same
04:12:22 <erisco> I mean, that is what Ord gives anyways isn't it?
04:12:57 <erisco> I dunno.. tired.. not sure how the ordering could mess up.. suppose it would if I used 'compare' and then swapped GT for LT or something... but I simply won't :)
04:14:01 <byorgey> erisco: yes, but my point is that it would be impossible to implement  (k -> Ordering) -> Map k v -> Maybe v,  because the implementation cannot assume anything about the  (k -> Ordering)  function
04:14:20 <erisco> fair enough
04:14:34 <byorgey> erisco: if you are just going to use 'compare' anyway, then you might as well just have the Map do it for you... which I why I suggested using 'split' and then 'findMin' or 'findMax' on one of the resulting two Maps
04:14:48 <erisco> yeah splitLookup might work
04:15:15 <erisco> not completely sure though... can't think how I would discover the key which is the prefix
04:16:16 <erisco> :t M.fromList
04:16:17 <lambdabot> Ord k => [(k, a)] -> M.Map k a
04:17:09 <erisco> > let m = M.fromList [("cow",()), ("duck",())] in splitLookup "cowsheep" m
04:17:11 <lambdabot>  Not in scope: `splitLookup'
04:17:11 <lambdabot>  Perhaps you meant one of these:
04:17:11 <lambdabot>    `IM.splitLookup' (imported from Data.IntMap),
04:17:11 <lambdabot>    `M.splitLookup' (imported from Data.Map)
04:17:16 <erisco> > let m = M.fromList [("cow",()), ("duck",())] in M.splitLookup "cowsheep" m
04:17:17 <lambdabot>  (fromList [("cow",())],Nothing,fromList [("duck",())])
04:18:00 <erisco> > let m = M.fromList [("cow",()), ("duck",()),("cowdog",())] in M.splitLookup "cowsheep" m
04:18:01 <lambdabot>  (fromList [("cow",()),("cowdog",())],Nothing,fromList [("duck",())])
04:18:12 <erisco> see then I do not know what I'd do
04:18:54 <erisco> with this approach it seems the best I get is one split... then I have to do a sequential search
04:19:16 <byorgey> erisco: ok, I see.  The problem is that having a Map is not really helping you, because the ordering on the keys has nothing to do with how you want to do lookups.  You might as well serialize the Map into a list and then just do a linear search.
04:21:23 <erisco> byorgey, well if I do findMin on the LHS, I will get back either the smallest prefix or not a prefix
04:21:29 <erisco> I think
04:21:52 <erisco> no wait... letters before 'c'
04:21:54 <erisco> damn :P
04:22:35 <erisco> yeah if I was more awake I'd likely see the uselessness of the map like you do byorgey
04:27:48 <int-index> I have two lenses, and I perform the same operation over them, so it makes sense to compose them.
04:27:52 <int-index> Now I do it like so
04:27:57 <exicer> Is it possible to use parmap (and similar things) within the state monad, where the mapped function depends on the state?
04:28:14 <int-index> (lens1 %~ f) . (lens 2 %~ f) $ object
04:28:33 <int-index> But I would like something like (lens1 + lens2) %~ f $ object
04:28:47 <int-index> What would this (+) operator would be?
04:30:04 <NikolajK> What is join in the Maybe monad?
04:30:20 <Iceland_jack_> @ty join :: Maybe (Maybe a) -> Maybe a
04:30:21 <lambdabot> Maybe (Maybe a) -> Maybe a
04:30:23 <Taneb> > join (Just Nothing)
04:30:24 <Malar> I'm trying to use Data.Lens to access a Maybe value using _Just like this.
04:30:24 <lambdabot>  Nothing
04:30:26 <Malar>  > view _Just (Just 1)
04:30:33 <Taneb> > join (Just (Just 2))
04:30:34 <lambdabot>  Just 2
04:30:40 <Taneb> > join Nothing
04:30:41 <lambdabot>  Nothing
04:30:41 <Malar> it throws a Monoid instance not found
04:30:57 <erisco> I happened to had just been typing 'join' for the Maybe monad :o
04:31:12 <int-index> Because it's not a lens, it's a prism! You need preview, not view
04:31:43 <int-index> but preview _Just == id, for obvious reasons
04:31:49 <ocharles> int-index: I think you can use the Reified stuff with an applicative interface to combine lenses
04:31:54 <Malar> :S
04:32:10 <NikolajK> okay, it's obvious to me now ^^
04:33:50 <Malar> int-index: but > view _Just (Just "Hello") < works
04:34:28 <int-index> because of heavy type magic underneath the lens library
04:35:14 <int-index> and because String is a monoid
04:35:31 <int-index> try something like: view _Just (Just 1)
04:35:43 <int-index> no wait
04:36:10 <int-index> view _Just (Just (1 :: Int))
04:36:21 <int-index> Int is not a monoid, so you get the same error.
04:36:29 <Malar> ok
04:37:14 <int-index> It's actually explained here
04:37:14 <int-index> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
04:37:28 <int-index> see the "What is Monoid doing here?" section
04:37:47 <Malar> ok
04:38:15 <int-index> ocharles, sounds like too much trouble
04:38:36 <int-index> I thought there might be a standard operator in the lens library I was not aware of
04:40:01 <int-index> but it makes sense that there's no such operator, because what would be ^. for the composed lens?
04:40:17 * hackagebot curves 1.1.0 - Library for drawing curve based images.  http://hackage.haskell.org/package/curves-1.1.0 (UlfNorell)
04:42:36 <k00mi> would that even be a legal lens?
04:43:05 <k00mi> maybe a traversal
04:44:19 <ocharles> You can have setters that you can't read from, no?
04:44:38 <ocharles> ah no, a setter is a traversal, is a lens
04:45:29 <int-index> a traversal would be fine too, actually
04:50:00 <kuribas> Is it better to have large monolitic packages on hackage which do many things, or small packages that do one thing good.
04:50:31 <kuribas> Especially I am thinking about scientific and mathematical algorithms, for example multivariate polynomial GCD.
04:50:57 <bergmark> a lot of people seem to start out with small packages and then merge them once they become stable
04:52:01 <kuribas> merge with existing packages?
04:54:20 <bartavelle> kuribas, it's nice to have a large monolitic package that does many things well too :)
04:54:34 <bergmark> kuribas: for instance http://www.yesodweb.com/blog/2014/04/consolidation-progress
04:54:40 <kuribas> bartavelle: yeah, true :)
04:54:45 <edwardk> kuribas: that is the sort of thing i would normally build inside something like my algebra package
04:54:49 <bergmark> but i think this is mostly from a maintenance perspective
04:55:14 <edwardk> and yeah, like snoyman i also recently went and consolidated a bunch of smaller packages
04:55:53 <edwardk> mostly because maintaining them as small isolated packages gets harder, and it gets harder for users to figure out where what they want is located
04:56:38 <kuribas> edwardk: I am writing a simple symbolic algebra package, but I need to do a multivariate polynomial GCD, to simplify expressions.
04:56:54 <edwardk> makes sense
04:57:11 <kuribas> edwardk: So I am wondering if I should make that algorithm a separate package, or integrate it with something that exists?
04:57:19 <edwardk> you may want to look at https://hackage.haskell.org/package/constructive-algebra-0.3.0/docs/Algebra-Structures-BezoutDomain.html#t:BezoutDomain but its use of instances is.. unfortunate.
04:57:45 <edwardk> if you wanted to fold it into algebra i'd be happy to take the patches, or you could do it in isolation
04:58:35 <edwardk> http://hackage.haskell.org/package/algebra
04:59:30 <kuribas> edwardk: Yeah, if I can find a way to make it fit in...
05:00:19 * hackagebot language-guess 0.1.2 - Guess at which language a text is written in using  trigrams.  http://hackage.haskell.org/package/language-guess-0.1.2 (ChristianRoedliAmble)
05:00:23 <t4nk193> f mx (i, n) = mx >>= (\x -> g x i n)
05:00:32 <t4nk193> @pl f mx (i, n) = mx >>= (\x -> g x i n)
05:00:33 <lambdabot> f = (`ap` snd) . (. fst) . (. (flip . flip g)) . (.) . (>>=)
05:03:07 <kuribas> edwardk: I am definitely not an expert in abstract algebra.  I am still studying the algorithm in Knuth TACP part 2.
05:16:39 <NikolajK> The arrow image of a function f::A->B in the Maybe monad, just maps "Just x" to "Just (f x)" and Nothing to Nothing, right?
05:27:59 <haasn> NikolajK: yes
05:28:09 <zipper> I am watching the avengers and this lead of bad guys lead by red skull is called. Guess it
05:28:12 <zipper> Guess it
05:28:14 <zipper> The Cabal
05:28:27 <zipper> Cabal :)
05:28:32 <haasn> wow, cabal is a word? stop the presses
05:29:16 <zipper> haasn: lol did you know this before?
05:29:25 <haasn> yes
05:30:12 <zipper> haha I googled the word. It makes sense that the bad guys are called the cabal.
05:30:32 <zipper> Anyway I think it is very cool that the avengers have an enemy called the cabal
05:32:59 <NikolajK> http://mortalkombat.wikia.com/wiki/Kabal
05:33:31 <NikolajK> http://magiccards.info/tr/en/51.html
05:33:38 <NikolajK> get your stuff together ;)
05:33:38 <zipper> NikolajK: Even better lol
05:34:04 <NikolajK> I did play magic semi-professionally
05:34:19 <haasn> Are you going to start posting pictures of indian food and admiring the connection to Haskell Curry?
05:34:22 <zipper> Ok ok I still wish you guys had at least pretended to be surprised
05:34:51 * Hodapp looks at haasn
05:37:20 <haskellnoob889> hi, i'm doing a hw assignment to write property checks for binary trees. for the property "does not change other elements during a delete", i've written prop_delete deleteFunction integer newInteger =  (searchTree newInteger tree) ==> searchTree newInteger (deleteFunction integer tree)
05:38:10 <haskellnoob889> my concern is that quickCheck does 100 tests by default, so would a lot of those 100 tests be wasted on trying to randomly create a tree with newInteger in it?
05:38:47 <tdammers> zipper: #haskell probably has the highest percentage of language geeks in all the programming channels on freenode
05:43:24 <zipper> tdammers: So it seems. Language geeks who cannot feighn surprise. :(
05:46:21 <deweyvm> is there a better way to write this? list indexing makes me unhappy: iterate f x !! n
05:50:56 <FireFly> zipper: I learned a new word today :)
05:51:39 <zipper> FireFly: Thanks :)
05:53:18 <fizruk> :t \n f x -> foldr (.) id (replicate n f) x
05:53:18 <lambdabot> Int -> (b -> b) -> b -> b
05:53:25 <Madarc> FireFly, supercalifragilisticexpialidocious ?
05:54:42 <fizruk> :t \n f x -> ala Endo foldMap (replicate n f) x
05:54:43 <lambdabot> Int -> (a -> a) -> a -> a
05:54:49 <deweyvm> fizruk: aha, didnt think to fold the function
05:55:44 <Madarc> FireFly, also, if you mean "feighn", it is spelt "feign" <- zipper
05:55:46 <fizruk> deweyvm: `iterate f x !! n` seems prettier to me here, though
05:56:03 <FireFly> Madarc: ...I meant cabal
05:56:15 <deweyvm> still helpful to see the alternative :)
05:56:37 <Madarc> ahh
05:56:41 <deweyvm> what is "ala Endo" ?
05:56:59 <haasn> I would probably write foo 0 _ x = x; foo n f x = f (foo (n-1) f x) -- or similar
05:57:10 <kuribas> zipper: The cabal are the bad guys in Sanctuary too.
05:57:35 <fizruk> deweyvm: it's like  ala Endo f == getEndo . f Endo
05:57:56 <deweyvm> ah okay
05:58:21 <haasn> Actually, you could write Numeric.Natural.natural x f n
05:58:22 <fizruk> deweyvm: http://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html
05:58:29 <haasn> since that's just the church encoding
05:58:40 <haasn> (assuming n can be any Num instance here)
05:58:48 <haasn> (or fromIntegral otherwise)
05:58:59 <deweyvm> neat
05:59:16 <deweyvm> thanks
05:59:46 <haasn> http://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-Natural.html this thing could use an eliminator, too
06:01:00 <fizruk> deweyvm: perhaps there's also a way to use (e ->) monad
06:01:29 <deweyvm> i think eventually it will be a list of functions rather than the same function a fixed number of times
06:01:36 <deweyvm> though maybe it will be function, Int pairs
06:03:11 <kuribas> If I make an instance for a specific purpose, but not export the instance from the module, will it behave as if there is no instance?
06:03:34 <fizruk> :t \n f x -> execState (replicateM n (modify f)) x   -- deweyvm
06:03:35 <lambdabot> Int -> (s -> s) -> s -> s
06:04:09 <kuribas> For example to get a particular ordering in a Map.
06:04:28 <kuribas> So I define an Ord instance for my datatype, but make it local to the module.
06:04:44 <benj_> does there already exist something like: multiply n = fold . replicate n
06:07:43 <supki> benj_: timesN/times1p from semigroups
06:07:57 <haasn> :t \n f -> replicate n (Endo f) ^. folded._Wrapping Endo
06:07:58 <lambdabot>     Not in scope: `_Wrapping'
06:07:58 <lambdabot>     Perhaps you meant `wrapping' (imported from Control.Lens)
06:08:03 <haasn> :t \n f -> replicate n (Endo f) ^. folded.wrapping Endo
06:08:04 <lambdabot>     Couldn't match type `a1 -> a1' with `Endo a0'
06:08:04 <lambdabot>     Expected type: (Endo a1 -> Accessor (Endo a1) (Endo a1))
06:08:04 <lambdabot>                    -> Endo a0 -> Accessor (Endo a1) (Endo a0)
06:08:27 <fizruk> @hoogle [a -> a] -> a -> a
06:08:28 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
06:08:28 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
06:08:28 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
06:09:50 <fizruk> hm... hayoo gives better response: http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=[a%20-%3E%20a]%20-%3E%20a%20-%3E%20a&start=0
06:09:59 <edwardk> sadly lambdabot is on an old version of lens
06:11:28 <talin> hello. are there any interesting projects where haskell is being used in some production environment? like a popular webserver or dns server or something?
06:13:34 <iota_> talin: darcs is quite widespread
06:14:40 <fizruk> talin: you can find something interesting on the wiki page: http://www.haskell.org/haskellwiki/Haskell_in_practice
06:15:06 <talin> iota_: hmm, that looks cool. to me, haskell seems like an amazing programming language, and with no big performance issues? i just wonder why it isn't "taking over" for more ancient stuff written in C... like postfix, bind, nginx etc
06:17:15 <talin> fizruk: oh, there's already a postfix-like program here
06:17:17 <talin> there*
06:17:30 <Hodapp> talin: because people love their C.
06:17:46 <talin> Hodapp: yeah, creatures of habbit. perhaps that's one of the reasons
06:17:55 <Hodapp> there's no "perhaps" there.
06:17:55 <Yaniel> and haskell looks scary to people who are used to java
06:18:08 <Hodapp> Yaniel: so does ANY LANGUAGE that is remotely concise.
06:18:14 <Yaniel> (or pretty much anything else)
06:18:25 <talin> the more i read about haskell, the more i like it. the problem is that there are very few jobs and likeminded people unless you live in a huge place
06:18:41 <Yaniel> there are surprisingly many
06:18:48 <Yaniel> but they don't talk much about it
06:19:19 <talin> it's a frustrating situation
06:19:58 <talin> i hope someone comes along and writes something in haskell that knocks some of the ancient pillars of the internet out of the water... such as bind (which is currently being rewritten in python/c++ from c)
06:21:46 <iota_> talin: something like OpenSSL ? :D
06:22:05 <talin> iota_: hehe, for example. oh wait, i saw some alternative written in haskell earlier today
06:22:33 <Adeon> I had a game server thing written in haskell and one of the complaints I received was that they don't want to download a large compiler to use it and I should have used something else
06:22:59 <talin> Adeon: unix-users?
06:23:07 <Yaniel> that's what prebuilt binaries are for
06:23:40 <Adeon> at the moment I don't offer binaries for linux because it doesn't work properly in there
06:23:49 <Adeon> it interacts with some hacky software that causes complications
06:23:51 <Adeon> anyway
06:23:53 <talin> the BSDs are actually going to remove bind from the default install because it's going to require python. anything not C is detested in those environments
06:25:56 <dv-> i doubt they'd like haskell any better
06:26:36 <talin> perhaps if someone write something better and presented some benchmarks showing that on hacker news or something, then it would raise interest
06:26:44 <talin> wrote*
06:27:18 <iota_> talin: mass inertia is much higher
06:27:22 <iota_> ... sadly
06:31:16 <talin> mass inertia?
06:32:22 <iota_> when you have a group of people, it's hard to make them all change their minds
06:32:33 <iota_> the more people, the harder
06:32:50 <Yaniel> a linux distro focusing on haskell could be interesting
06:33:10 <mniip> rewrite coreutils in haskell!
06:33:12 <Taneb> Yaniel, I think nix is trying to go that way
06:33:33 <Yaniel> might be fun to see how many packages one can ditch in favour of cabal on e.g. arch
06:35:25 <Hodapp> for a lot of system programming I'd expect Rust might gain more of a foothold than Haskell.
06:38:59 <no-n> @hoogle bracket
06:39:00 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:39:00 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:39:00 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:45:56 <no-n> @pl \x y -> unwords [x,y]
06:45:56 <lambdabot> (unwords .) . (. return) . (:)
06:49:34 <no-n> @pl \(x,y)->[x,y]
06:49:34 <lambdabot> uncurry ((. return) . (:))
06:51:23 <tdammers> eh... isn't being language-independent kind of a *nix hallmark?
06:52:21 <tdammers> as in, bit of javascript here, some C libraries there, an erlang storage engine maybe, some python, and a bunch of shell scripts to glue them together
06:52:24 <tdammers> that kind of thing
06:52:31 <tdammers> (and frankly, I love it)
06:54:38 <gamegoblin> quchen: lol saw you on hackernews
06:56:13 <gal_bolle> what is the status of ghcjs? is it going to be released, with ghc 7.8 coming soon?
06:58:44 <talin> tdammers: hmm, in a sense. that's the freedom of the developer, but nearly all the things you use on a unix system, are C... nginx, git, apache, svn, cvs, named, postfix, userland, kernel, bash, zsh, ksh
07:00:35 * hackagebot tf-random 0.5 - High-quality splittable pseudorandom number generator  http://hackage.haskell.org/package/tf-random-0.5 (MichalPalka)
07:05:36 * hackagebot semigroups 0.13 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.13 (EdwardKmett)
07:10:36 * hackagebot active 0.1.0.11 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.11 (BrentYorgey)
07:14:03 <thoughtpolice> 7.8.1 is out
07:16:37 <fizruk> hooray!
07:17:03 <d3lxa> I have a function f :: SomeInstance a => a -> Text, and I need to pass it a function that uses it in a specialized form, it uses it for some a which is in the class, but it says a ~ mytype
07:17:05 <kuribas> What's new in 7.8.1?
07:17:15 <tdammers> talin: actually, many things aren't
07:17:19 <acomar> kuribas: http://www.haskell.org/pipermail/haskell/2014-April/024137.html
07:17:26 <tdammers> talin: the ones that are, are either legacy, or low-level libs
07:17:45 <tdammers> like, apache is C because back when it started out, C was the only viable choice
07:17:52 <kuribas> hm, type naturals...
07:17:55 <tdammers> anything else would have been too slow or too complex or both
07:18:17 <tdammers> most of the stuff that is in C today started back then, and kept going
07:18:57 <thoughtpolice> kuribas: the release notes are pretty long http://www.haskell.org/ghc/docs/7.8.1/html/users_guide/release-7-8-1.html
07:19:14 <thoughtpolice> the "Highlights" section alone is like 1/3rd of the page
07:19:20 <kuribas> Using type naturals, could I make a class "Dim n", and a instance "coord :: Int -> Int" where the first argument of coord is smaller or equal to n?
07:21:11 <talin> tdammers: right, and why has none of the "better" languages replaced them?
07:21:47 <talin> tdammers: git it not extremely old, for example. there's darcs (haskell) and mercurial (python), but most of the world is using git/svn
07:21:51 <fizruk> What for is this? "The Control.Category module now has the PolyKinds extension enabled, meaning that instances of Category no longer need be of kind * -> * -> *."
07:22:26 <talin> tdammers: nginx is not extremely old either, and its author chose C
07:22:51 <acomar> talin: how many languages can interface directly with C++ vs. how many languages can interface with C? The better languages haven't replaced C because of the interfacing problem and inertia.
07:23:08 <tdammers> yeha
07:23:13 <tdammers> the interfacing thing, mainly
07:23:34 <kuribas> talin: It probably also has to do with the maturity of the compiler.
07:23:46 <tdammers> for the kind of people who write things like git, C isn't significantly more difficult than, say, Python or Haskell or whatever
07:23:50 <talin> acomar: hmm, i don't understand the interface part
07:24:08 <d3lxa> how can I use this function getMessageRender :: (MonadHandler m, RenderMessage (HandlerSite m) message) => m (message -> Text) multiple times without it being bind to a certain m type? GHC tries to bind to the first type, then throw an error on the 2nd saying 1st != 2nd
07:24:20 <tdammers> talin: if there is one language that you can use to write libraries that every other language can link against, C is pretty much the only choice
07:24:39 <kuribas> tdammers: I can imagine it's more difficult to debug than haskell.
07:24:41 <talin> tdammers: ah, right. that's a good point
07:24:55 <tdammers> kuribas: yes, but not enough to make a decisive difference
07:25:17 <tdammers> if you want to expose a Haskell library to any other language, you will have a lot more trouble than what you win, usually
07:25:26 <tdammers> and then there's the platform support
07:25:27 <talin> tdammers: the problem is that i see new things being adopted, like git, which are huge successes and they are usually written in C. there's not that much python, java etc, for example
07:25:42 <tdammers> also, tooling
07:25:46 <talin> i'm not talking about the microsoft universe of course, i have no idea how things are there
07:25:48 <tdammers> everyone has a c compiler
07:25:53 <kuribas> that's an important point, C can be interfaced easily with other languages, the opposite is not true.
07:26:14 <tdammers> plus with C, all you need to ship is the binary
07:26:32 <tdammers> this is really an important point in itself
07:26:38 <kuribas> It has grown so because most of the libraries were already in C, not because C is particularly a good language.
07:26:42 <tdammers> you can provide C binaries with zero external dependencies
07:27:02 <kuribas> You can do that with any compiled language?
07:27:03 <tdammers> kuribas: not really - it's because C produces "vanilla" binaries
07:27:19 <tdammers> and yes, any compiled language can do this, at least theoretically
07:27:25 <tdammers> but for python or Java, you can't
07:27:56 <kuribas> And shipping binaries on linux can still be a big mess, due to dynamic libraries.
07:28:34 <tdammers> yeah, sure, but at least you aren't depending on a few hundred megs of a runtime
07:28:34 <acomar> anyone know how the rust team is planning to handle calling conventions? can you call into a rust binary with the same calling conventions as in C?
07:29:04 <tdammers> but anyway, theoretically speaking, as long as you can produce vanilla binaries, any compiled language will do
07:29:26 <tdammers> I just haven't seen any language that can do that, so far - at least none with sufficient traction
07:29:41 <tdammers> and frankly, I believe that being truly high-level kind of rules that out, really
07:30:52 <dwcook> I'm trying to build a pipe from client input onto output to the client. Included in the pipeline is a parser, which can fail to parse the user input. I would like to be able to write a pipe that takes successfully parsed user commands onto user output but then I would also need a pipe taking errors onto user output. How might I compose pipes sideways? Or am I approaching this wrong?
07:31:06 <dwcook> (using the pipes package in case that was unclear)
07:31:27 <kuribas> C still has benefits for raw speed, such as for video filters or so.
07:31:53 <tdammers> you could get the same kind of speed out of D or C++
07:31:59 <kuribas> yes
07:32:01 <tdammers> but you'll lose the interop
07:32:17 <talin> doesn't sound like C is going away any time soon
07:32:29 <acomar> talin: nope :/
07:32:33 <kuribas> C++ is also quite popular for apps.
07:32:44 <tdammers> yes
07:32:53 <tdammers> for application programming, you get most of the benefits of C, and then some
07:32:58 <kuribas> tdammers: Don't you think that developping in haskell is faster and more robust than in C?
07:33:05 <tdammers> kuribas: absolutely
07:33:30 <tdammers> kuribas: but you have to realize that 1) the available developer pool is smaller, so it's harder to gain traction
07:33:53 <tdammers> 2) setting up a build infrastructure is a bigger hassle
07:34:03 <tdammers> 3) C++ supports more platforms
07:34:44 <tdammers> 4) using C libraries is a no-brainer in C++, whereas in Haskell you have to learn how to use the FFI
07:35:24 <tdammers> 5) C++ is imperative, and so are most C libraries, so C++ is a more natural fit in a way
07:35:38 <tdammers> (the last one is actually not a big deal really)
07:36:05 <kuribas> Using a FFI isn't that dificult.
07:36:28 <tdammers> no, but still more effort than calling C functions from C++
07:36:34 <acomar> tdammers: the FFI in haskell is actually very straight forward as long as its C you want to interface with
07:36:40 <tdammers> acomar: yes, I know
07:36:46 <tdammers> it's still a nonzero effort
07:37:29 <tdammers> it's kind of impossible to beat C++ on this one without *being* C++ (or something horribly similar)
07:37:46 <kuribas> I personally think that using a higher-level language for apps is a good idea, even considering your points.
07:38:04 <Kron> is the new GHC out her? D:
07:38:05 <companion_cube> well, rust might be a candidate for replacing C++
07:38:08 <Kron> *yet?
07:38:19 <tdammers> kuribas: agree
07:38:19 <Kron> I do like the idea of Rust, ATS etc. supplanting C
07:38:32 <tdammers> just trying to explain why a different choice is often made
07:38:40 <kuribas> Even python, scheme, lisp, or anything other that C, but static typing is an added benefit.
07:39:24 <kuribas> And that haskell avoids popularity at all costs :-)
07:39:45 <c_wraith> Eh.  There is a need for a bare-metal language with a real type system.  I'm hoping Rust manages to be that.
07:40:01 <tdammers> well, the dynamic bunch introduces the extra downside that you depend on an interpreter at run time
07:40:02 <deweyvm> bummed about the lack of proper TCO
07:40:13 <Sculptor> hi!
07:40:17 <srhb> How can I make C-c C-l create a window like C-c C-c does even when the haskell-process already exists?
07:40:23 <srhb> In haskell-mode, that is
07:40:33 <tdammers> which means 1) you have an extra unavoidable dependency, and 2) there's suddenly a whole zoo of issues that can sneak in at run time
07:40:39 <Kron> doesn't it already, srhb ?
07:40:40 * hackagebot data-bword 0.1 - Extra operations on binary words of fixed length  http://hackage.haskell.org/package/data-bword-0.1 (MikhailVorozhtsov)
07:41:03 <tdammers> rust could be a welcome solution, yes
07:41:08 <tdammers> definitely keeping an eye on that one
07:41:22 <c_wraith> I hope Haskell keeps avoiding success a while longer.  There are more breaking changes to be made.
07:41:53 <srhb> Kron: The first time I run it, yes. But now say I make the editor buffer the only visible window, if I call C-c C-l again now, it stays that way. The haskell-process reloads in the background
07:42:08 <Kron> it doesn't for me, srhb
07:42:10 <Kron> I just tried it
07:42:14 <srhb> Kron: Are you using inferior-haskell?
07:42:20 <Kron> I wonder if I've got something subtly different than you
07:42:25 <Kron> I... think so?
07:42:31 <Kron> Inf-Haskell:run Compilation
07:42:40 <Kron> *it does for me
07:42:45 <srhb> Kron: Right, my C-c C-l is bound to haskell-process-load-file
07:42:48 <Kron> it reloads properly and opens the new window where I want it
07:42:49 <srhb> In order to work with sandboxes
07:43:03 <Kron> gotcha
07:43:18 <srhb> I guess I'll have to compared those functions. Grr.
07:44:41 <srhb> I'm not happy with my workflow really. It seems a bit painful still for larger projects
07:45:41 * hackagebot data-dword 0.3 - Stick two binary words together to get a bigger one  http://hackage.haskell.org/package/data-dword-0.3 (MikhailVorozhtsov)
07:50:36 <Kron> <MP2E> Any tips on integrating haskell with emacs? :D
07:50:36 <Kron> <tac> Step 1) Download haskell-mode
07:50:36 <Kron> <tac> Step 2) Try not to cry.
07:50:36 <Kron> <tac> Step 3) Cry alot.
07:50:45 <srhb> Indeed.
07:50:56 <Kron> makes me laugh every time
07:51:06 <c_wraith> You know, I think I've been underestimating pattern synonyms.
07:52:30 <c_wraith> I need to play with them a bit, and see if they can do any of the things I'm envisioning.  (mostly in terms of integration with view patterns for finally making pattern matching on views syntactically lightweight)
07:54:38 <corgifex> pattern Prime <- n | isPrime n  -- does this work?
07:55:28 <no-n> what's a better monoid than list for concatenating to Writer?
07:55:56 <k00mi> no-n: dlist
07:56:09 <corgifex> @hoogle DList
07:56:09 <lambdabot> Text.Html dlist :: Html -> Html
07:56:09 <lambdabot> Text.XHtml.Strict dlist :: Html -> Html
07:56:09 <lambdabot> Text.XHtml.Frameset dlist :: Html -> Html
07:56:15 <corgifex> :-(
07:56:27 <bstrie> acomar: rust has its own calling convention, but it can expose a C interface so that you can call it via any C FFI
07:56:30 <no-n> k00mi thanks I'll take a look
07:56:31 <dwcook> Difference list
07:56:41 <dwcook> is what dlist stands for
07:57:50 <no-n> are there drawbacks to DList?
07:58:31 <sclv_> @remember edwardk waiting for sclv to start going around door to door passing out little copies of the homotopy type theory book, and asking people if they have yet had the geometric realization that the simplicial sets are homotopically equivalent to their Lord and Savior.
07:58:31 <lambdabot> Good to know.
07:59:14 <edwardk> =)
07:59:27 <no-n> :>
07:59:34 <c_wraith> no-n: in some cases, yes.  converting a DList to a list doesn't share.  If your use pattern is something like a stack, DList is going to be *way* worse than []
08:00:07 <no-n> what is meant by share?
08:00:18 <srhb> @tell chrisdone How does one make the existing haskell-process buffer get a window even if it's hidden when calling haskell-process-load-file?
08:00:18 <lambdabot> Consider it noted.
08:00:42 <srhb> We need Yi to get awesome. :(
08:01:05 <c_wraith> no-n: it creates new (:) constructors every time, even if it doesn't actually need two, because two lists have the same tail.
08:01:08 <sclv_> "Dear Friend... have you heard the good news about the higher spheres."
08:01:14 <c_wraith> err, *need to*
08:01:27 <acomar> bstrie: does that apply to the whole language or some restricted subset?
08:01:36 <acomar> bstrie: (like C++)
08:02:01 <sclv_> edwardk: you don't even want to know the speculation about homotopy theory and hegelian foundations i've been mulling over...
08:02:23 <no-n> c_wraith: every time what?
08:03:02 <c_wraith> no-n: for instance..  if you do x <> y and z <> y, then convert each to [], they don't share (:) constructors anywhere - even though they theoretically could share constructors for the portion from y
08:03:45 <c_wraith> no-n: and if you were using [] instead of DList, the constructors would be shared.
08:04:26 <no-n> :t (<>)
08:04:27 <lambdabot> Monoid m => m -> m -> m
08:04:30 <bstrie> acomar: well the mechanism is like C++ in that you have certain functions defined with C interfaces, then do all the rest of your code as normal. but unlike C++, rust doesn't have exceptions, so that makes things a bit easier
08:04:32 <c_wraith> <> is mappend
08:04:36 <no-n> ahh
08:05:09 <bstrie> acomar: and doing this at all implies that you're running without a runtime, so you don't have to worry about green threads or anything. but maybe this would be better in a dedicated rust channel :P
08:05:16 <no-n> c_wraith: so, no drawbacks if you're not converting to ist?
08:05:19 <no-n> list *
08:05:24 <acomar> bstrie: fair enough, thanks!
08:05:43 * hackagebot yesod-auth-hashdb 1.3 - Authentication plugin for Yesod.  http://hackage.haskell.org/package/yesod-auth-hashdb-1.3 (paulrouse)
08:06:51 <c_wraith> no-n: if your work has a write phase and a read phase, in that order, DList is a good choice.  If your work has lots of reads and writes mixed together, DList is a poor choice.
08:07:19 <no-n> okay. it has the latter.
08:07:39 <pordan30> sclv_: do you have a good reference? i recall reading several papers in an anthology some time ago that mentioned recent attempts to formalize the argumentation in the science of logic using category or type-theoretic notions, but haven't really discovered a canonical reference.
08:07:55 <corgifex> no-n: how do you have lots of reads with Writer?
08:07:59 <no-n> I suppose (++) is only bad on huge lists
08:08:24 <c_wraith> no-n: corgifex raises a very good question
08:08:57 <sclv_> pordan30: as far as i know the page on nlab is the best reference, but it was reputedly a project of urs while he was not doing "real work" b/c he just had a kid
08:09:02 <no-n> it's for an IRC bot. I thought Writer was a good choice to make a lot of functions pure.
08:09:06 <sclv_> it seems rather complex and goofy to me
08:09:22 <corgifex> no-n: how do you have lots of reads with Writer?
08:09:26 <sclv_> something simpler seems more appropriate, but that's just my own speculation
08:09:51 <sclv_> also lawvere of course wrote about this a lot, but later lawvere which i find very dense and hard to follow, because he assumes you are familiar with all of mathematics :-P
08:10:17 <sclv_> pordan30: if you have any references i'd appreciate that too :-)
08:10:48 <no-n> corgifex: I'm not sure if I know what you mean by reads
08:11:13 <corgifex> no-n: I mean the same thing as c_wraith
08:11:37 <no-n> I don't know what he means either :p
08:11:54 <corgifex> then why did you say "it has the latter"?
08:12:14 <Kron> makes me laugh every time
08:12:29 <Kron> err, sorry, wrong channel
08:12:30 <no-n> corgifex: because on 2nd thought
08:13:03 <c_wraith> no-n: if I go up a couple steps, I think there's a better way to purify actions an IRC bot can take than using Writer.  I'd put together some AST construction based on free monads.  (personally, via an operational approach)
08:13:09 <corgifex> ooh, ghc 7.8.1 comes with an 'if' function
08:13:27 <c_wraith> corgifex: is it in Prelude?
08:13:38 <corgifex> Data.Bool.bool :: a -> a -> Bool -> a
08:13:39 <no-n> c_wraith: hmm.
08:13:55 <no-n> I don't know what any of that stuff is. Would Writer be a /terrible/ way to do it, or just a not as good way?
08:14:08 <c_wraith> corgifex: oh.  Hasn't that been around for a while?  I guess being distributed with GHC is new.
08:15:13 <c_wraith> no-n: Writer will work, it just forces you do deal with these sorts of things up front - and makes it more work to change your mind later
08:15:32 <no-n> all right
08:16:05 <no-n> btw, what's the right way to "clear" the logs of a Writer?
08:16:11 <serutsubi> I'm thinking of studying mathematics, would haskell be a good choice. I've already read most of LYAH :)
08:16:15 <no-n> I'm using RWS actually
08:17:54 <c_wraith> no-n: There really isn't a way to clear the logs, based on the definition of (>>)
08:18:17 <c_wraith> no-n: since (>>) just calls mappend
08:18:28 <no-n> I guess I'm kind of abusing Writer then
08:18:48 <c_wraith> no-n: you'd need to be working over a monoid with an element that absorbs to the left, but not the right.  Which is certainly not [] or DList
08:19:01 <ocharles> You need a group to do clearing
08:19:08 <ocharles> Or not Writer
08:19:22 <no-n> as a stub I just used clear = mapRWS $ (\x,y,_) -> (x,y,mempty)
08:19:43 <acomar> yikes, trying to install wai-app-static (for yesod) and just got http://lpaste.net/102485
08:19:43 <no-n> but maybe that's bad if done a lot?
08:20:23 <c_wraith> no-n: I bet it doesn't even work.
08:21:05 <c_wraith> no-n: did you try tell "foo" >> clear  ?
08:21:15 <pordan30> sclv_: thanks for the reference; it appears that lawvere (and secondary sources on hegel and lawvere) are the canonical references, and the nlab page looks promising. i went searching for the papers i mentioned to look up their references, but don't seem to have them anymore. it's not my area of expertise, though, so i don't have a large collection to begin with :)
08:21:34 <no-n> no. (clear $) works though
08:22:02 <c_wraith> no-n: that nests Writers.  You can ignore the logs from a nested writer, sure
08:22:18 <c_wraith> no-n: But that's not the same as clearing the log from the current context
08:22:19 <no-n> is it bad to nest?
08:22:35 <c_wraith> No, there's no problem with it.  It's just doing something different than you asked about
08:22:44 <no-n> hmm
08:22:52 <c_wraith> it's not removing things already logged at the current level
08:23:22 <no-n> this is probably telling me that I'm not using Writer for its intended purpose
08:23:44 <no-n> I want logs to die as soon as the've been sent to IRC
08:23:52 <corgifex> :t censor (const mempty)
08:23:53 <lambdabot> MonadWriter w m => m a -> m a
08:24:06 <c_wraith> I was just going to mention censor
08:24:11 <no-n> hmm
08:24:21 <c_wraith> That does the same thing as your clear function
08:25:21 <c_wraith> no-n: I'd really recommend looking into stuff like http://apfelmus.nfshost.com/articles/operational-monad.html
08:25:45 <c_wraith> no-n: that approach lets you design the DSL you want to work in independently from how it's implemented.
08:25:58 <no-n> DSL?
08:26:04 <c_wraith> domain-specific language
08:26:12 <no-n> ok
08:26:18 <no-n> okay I'll give it a read :)
08:27:15 <no-n> c_wraith: to make things (maybe) more complicated, I'm using not Writer alone, but RWS because I have some other stuff to pass around
08:27:34 <no-n> c_wraith: dunno if that will make this solution still suitable?
08:27:48 <c_wraith> no-n: in operational's terms, that's an implementation detail.
08:28:01 <no-n> okay
08:28:09 <c_wraith> no-n: something you hide away in the guts of the interpreter, not make part of the interface.
08:28:22 <no-n> c_wraith: I will read your link! :)
08:28:29 <no-n> thanks
08:28:41 <c_wraith> I really should write the rest of my article on operational, just to have a second thing I could point to.
08:30:51 <ZioCrocifisso> what are the advantages of using frp instead of functions like "play" of gloss?
08:34:08 <jle`> ZioCrocifisso: have not used gloss, but from looking at the type signature, it seems perfectly possible to use FRP w/ the 'play' of glass?
08:34:10 <jle`> *gloss
08:34:41 <jle`> but a naive usage of play (step the world at every time step) sort of looks like it encourages a global state
08:35:23 <jle`> which frp mght have things to offer
08:35:48 <c_wraith> ZioCrocifisso: ideally, with FRP, you'd define lots of behaviors independently, and the way they work together would be an emergent property.  With something like Gloss's play, you're encouraged to take a monolithic view of what's going on.
08:35:49 * hackagebot quickcheck-instances 0.3.8 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.3.8 (AntoineLatter)
08:35:51 * hackagebot hssqlppp 0.4.1 - SQL parser and type checker  http://hackage.haskell.org/package/hssqlppp-0.4.1 (JakeWheat)
08:36:58 <quchen> WOOOO 7.8.1!
08:37:02 <ZioCrocifisso> yes, but in applications like games, usually everything depends on everything.
08:37:02 <quchen> Sorry if I'm late :-)
08:37:28 <c_wraith> quchen: a little.
08:38:49 <haasn> Oh darn, now I missed the big release :)
08:39:20 <tristan__> new ghc and new erlang/otp! what a week
08:39:38 <bergmark> i'm so slow our devops guy noticed the release before me
08:40:12 <joelteon> Is there a way to load cabal tests in cabal repl?
08:40:39 * quchen thinks the /topic should be updated.
08:40:44 <c_wraith> ZioCrocifisso: depends. Consider something like Asteroids. Each Asteroid is independent behavior. It only cares about its direction, speed, and when a bullet hits it. The alien ship doesn't care about asteroids, it just needs to know when to go and how to create bullets and how to act when player bullets hit it.  The ship cares about collisions with asteroids and alien bullets and how to create its own
08:40:45 <c_wraith>  bullets and user input, but it doesn't care in the slightest what its bullets do after it creates them.
08:41:53 <quchen> Why is the source so small this time? 7.6 had 100+ MiB, now it's around 10
08:42:03 <quchen> Did compression algorithms make a leap? :-D
08:42:46 <thoughtpolice> previously, the 7.8.1 source tarball bundled extra tools needed only for Windows. so the src tarball went from 100MB to 10MB or so
08:42:54 <thoughtpolice> as for the binary distribution - xz just kicks ass vs bzip2, is all.
08:43:07 <ZioCrocifisso> are there complete games written in a good frp style?
08:43:21 <thoughtpolice> it does anywhere from 50 to 70% better savings vs bzip in the experiments I ran for the binary dists
08:43:28 <haasn> awesome, I'm glad to see my wish made it in - though probably not just because of me wishing it :)
08:43:29 <ZioCrocifisso> i would learn from them.
08:43:41 <c_wraith> ZioCrocifisso: I know there's actually an asteroids clone out there, somewhere.
08:44:08 <k00mi> ZioCrocifisso: http://ocharles.org.uk/blog/posts/2013-08-18-asteroids-in-netwire.html
08:44:21 <absence> are there binaries for cabal that go with the new ghc?
08:44:41 <ZioCrocifisso> thanks.
08:44:55 <thoughtpolice> i did not get around to making cabal binaries. i might later
08:45:05 <thoughtpolice> as long as you just have Cabal 1.18 however, it'll work fine.
08:45:26 <thoughtpolice> (Windows users can download a binary distribution from http://haskell.org/Cabal if that's your particular case)
08:45:33 <quchen> thoughtpolice: Just to be sure, the 40 hour old "ghc-7.8-release" tag is the actual release, no? The only reason that wasn't announced as an official release is because the pre-built binaries weren't done yet?
08:45:54 <absence> thoughtpolice: that is my particular case :) that url doesn't work though
08:46:13 <quchen> thoughtpolice: In other news, thanks for the release and everything. Also the GHC team etc.
08:46:16 <thoughtpolice> absence: my bad http://www.haskell.org/cabal/download.html
08:46:26 <thoughtpolice> there's a 1.18.0.2 binary down there
08:46:41 <thoughtpolice> quchen: it's not announced until there are official binaries and I send the email, yes.
08:47:06 <haasn> How do typed holes interact with lens _Prisms?
08:47:20 <ZioCrocifisso> in your opinion, if i make a 3d version of gloss, should i include an frp engine?
08:47:33 <quchen> haasn: Only unbound names generate hole warnings
08:47:36 <Fuuzetsu> haasn: how?
08:47:37 <thoughtpolice> haasn: type holes only kick in as a warning if the name is unbound anyway.
08:47:46 <haasn> quchen: Okay, thanks
08:47:52 <absence> thoughtpolice: if i don't have any version of ghc/hp installed, will the ghc release along with the cabal.exe on that site be enough to compile and install packages?
08:47:58 <thoughtpolice> absence: yes
08:48:00 * dwcook forgets which Haskeller was talking about making something like FRP but better
08:48:04 <absence> thoughtpolice: awesome, thanks!
08:48:43 <ZioCrocifisso> like in helm.
08:49:01 <haasn> Do closed data families exist? I guess that is not very useful since GADTs can be used to imitate them
08:49:12 <thoughtpolice> not in GHC, no.
08:52:47 <haasn> aaw, [a,b,c] with OverloadedLists doesn't actually get desugared into a `cons` b `cons` c `cons` nil ?
08:53:32 <haasn> I guess that would break for toList anyhow
08:53:38 <quchen> haasn: aaw, 4 is not actually desugared to one `plus` one `plus` `plus` zero ?
08:53:38 <haasn> I was thinking of stuff like vectors with static lengths
08:53:46 <quchen> Plus some ones ;-)
08:53:51 <haasn> or HLists, etc.
08:54:24 <dwcook> haasn, wouldn't that be super inefficient on types that aren't represented with cons?
08:55:20 <haasn> dwcook: great point
08:55:20 <dwcook> quchen, closer analogy would be succ (succ (succ (succ zero))), I'd say :P
08:55:45 <dwcook> Still terrible but not quite as terrible
08:57:07 <k00mi> for most such types fromList would be similar to folding cons/insert, wouldn't it?
08:57:18 <k00mi> so it has similar horrible performance
08:57:36 <n-dolio> No.
08:57:45 <dwcook> Say you're using an array represented as contiguous memory
08:57:52 <dwcook> Then on every cons you need to reallocate
08:57:55 <n-dolio> You can build a vector in far better ways than that.
08:58:33 <k00mi> true, I was thinking of something like Set
08:58:39 <quchen> n-dolio: Do you know how Vector does it? My semi-naive way would be using ST.
08:58:46 <n-dolio> Or if you have a snoc list, you can push elements on with foldl.
08:59:07 <n-dolio> quchen: MVector in ST and then freeze, roughly.
08:59:33 <quchen> n-dolio: Oh. I thought maybe there's an amazingly smart solution that relies only on laziness without mutable updates.
08:59:36 <n-dolio> It might not actually freeze; I think there's a lot of fancy stuff that it does.
09:01:25 <c_wraith> Eh.  It's like creating a constructor.  It does actually mutate memory a bunch before it returns the constructor.  But that's never visible because there's no pointer to it outside the RTS during that time.
09:01:38 <c_wraith> well, creating a constructor with a bunch of fields
09:02:11 <n-dolio> quchen: Nah. But foldr with cons is going to do several rounds of allocating, copying, then freezing.
09:02:29 <n-dolio> And throwing away things that it just built.
09:03:10 <haasn> wait what? GHC can build in parallel now?
09:03:28 <n-dolio> Yeah. That was a GSOC project last year.
09:05:13 <joelteon> I know that this is a bad idea. but it compiles on 7.6, but not on 7.8. Can someone explain why exactly? http://lpaste.net/102487
09:05:33 <joelteon> Specifically 7.8 doesn't like it because there's no instance for Eq (Qux a)
09:05:57 * hackagebot simple-sql-parser 0.3.1 - A parser for SQL queries  http://hackage.haskell.org/package/simple-sql-parser-0.3.1 (JakeWheat)
09:05:58 * hackagebot yesod-auth-hashdb 1.3.0.1 - Authentication plugin for Yesod.  http://hackage.haskell.org/package/yesod-auth-hashdb-1.3.0.1 (paulrouse)
09:06:06 <n-dolio> joelteon: Is line 6 a typo?
09:06:15 <joelteon> What makes you think that
09:06:22 <c_wraith> joelteon: where is Foo defined?
09:06:24 <n-dolio> The context is after Eq.
09:06:31 <c_wraith> Oh, I see
09:06:32 <vermeille> How can the knowledge I get learning Haskell & category theory can be used when programming in non-functionnal languages?
09:06:33 <joelteon> Foo is defined in the class body of Bar
09:06:39 <joelteon> associated type
09:06:49 <haasn> “GHC now uses Unicode left/right single quotation marks (i.e. U+2018 and U+2019) in compiler messages if the current locale supports Unicode characters.” <- what happens now when I have an identifier named foo'?
09:06:56 <haasn> Do I still get just a plain foo' or do I get ‘foo'’
09:07:07 <c_wraith> you'll get foo'
09:07:17 <joelteon> The reason I ask is for the purposes of fixing a library that uses this pattern.
09:07:35 <joelteon> Also because I genuinely don't understand why it doesn't compile anymore
09:07:36 <c_wraith> haasn: at the moment, GHC error messages quote things like identifeir names with `'
09:07:36 <n-dolio> Oh, I was reading it wrong.
09:07:40 <quchen> haasn: There's a special function in the GHC prettyprinter that adds quotes, it's not "sed replacement".
09:07:52 <c_wraith> haasn: the change is to that quoting
09:09:17 <n-dolio> joelteon: I don't really understand why that wouldn't compile anymore.
09:09:23 <joelteon> Me neither.
09:10:37 <absence> thoughtpolice: cabal install cabal-install gives me a bunch of "setup-Cabal-1.18.1.3-x86_64-windows-ghc-7.8.1.exe: does not exist"
09:11:13 <ij> What's the point of State?
09:11:19 <ij> And/or StateT.
09:11:43 <sclv_> the point is to keep state
09:11:45 <c_wraith> ij: to simplify passing a current state around between a bunch of functions.
09:12:00 <sclv_> it simulates having a mutable store
09:12:02 <c_wraith> ij: you could do it manually, but there's a bunch of boilerplate.  And abstraction is good for removing that.
09:12:07 <sclv_> in a local environment
09:12:28 <ij> Could you write an exampe in human language of a simpest usecase?
09:12:35 <ij> the
09:12:46 <n-dolio> joelteon: I don't get any errors on 7.8 rc2.
09:12:58 <joelteon> What about on the 7.8.1 release?
09:13:01 <joelteon> I haven't tried rc2 yet
09:13:14 <n-dolio> I haven't built the release.
09:13:29 <joelteon> Ok, I'll try rc2 now
09:13:30 <c_wraith> ij: Every time you want to pass a value with a name like "current" to a function and have that function return a tuple including something named "new".
09:13:44 <c_wraith> ij: there, I just covered all use cases.
09:13:48 <quchen> Does Cabal's -j# flag automatically use 7.8's -j# flag to build modules in parallel? (7.6 only built packages in parallel this way, due to the lack of parallel compilation in GHC)
09:13:55 <joelteon> n-dolio: If it works on rc2 but not on the release, would you say this qualifies as a bug?
09:13:56 <ij> :) Thanks, I will check the code then.
09:13:59 <n-dolio> quchen: No, they are unrelated.
09:14:05 <joelteon> Is there any reason it *shouldn't* compile? I don't think there is
09:14:11 <n-dolio> joelteon: I think so.
09:14:12 <sgregory_> :-/ can't build cabal-install on a fresh 7.8.1 right now  HTTP depends on base >=3 && <4.7
09:14:16 <joelteon> Ok, I'll check
09:14:26 <haasn> “Template Haskell declarations, types, patterns, and untyped expressions are no longer typechecked at all. This is a backwards-compatible change since it allows strictly more programs to be typed.” I don't understand this change
09:14:27 <n-dolio> What I mean is, I think there is no reason for it to not compile. :)
09:14:29 <quchen> n-dolio: Is there a way to relate them? It seems like that would be a useful increase in granularity
09:14:32 <sgronblo> I'm trying to sort out my haskell-platform installation through brew
09:14:44 <joelteon> I hope I don't have to wait until 7.8.2 for this
09:14:46 <n-dolio> quchen: No. Someone will have to write that.
09:15:00 <n-dolio> Dunno if it's being worked on.
09:15:27 <absence> thoughtpolice: false alarm, my path was silly and made 32-bit mingw visible to 64-bit ghc
09:15:38 <thoughtpolice> quchen: they're unrelated. Cabal 1.20 will use both -j in GHC and -j in Cabal
09:15:53 <thoughtpolice> right now 'cabal install -j' only affects package-level parallelism
09:15:55 * hackagebot classy-prelude 0.9.0 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.9.0 (MichaelSnoyman)
09:15:57 * hackagebot classy-prelude-conduit 0.9.0 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.9.0 (MichaelSnoyman)
09:15:59 * hackagebot classy-prelude-yesod 0.9.0 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.9.0 (MichaelSnoyman)
09:16:01 <thoughtpolice> absence: ah, OK, good.
09:16:30 <johnw> thoughtpolice: congrats on 7.8.1!!!
09:17:15 <monochrom> \∩/ 7.8 is finally out of intensive care err I mean beta!
09:17:43 <quchen> thoughtpolice: Thanks for mentioning it, I was crunching the multitude of open "cabal+parallel" issues on Github already. :-D
09:18:13 <quchen> monochrom: \n/  ←  what is that? I've seen it multiple times here.
09:18:27 <thoughtpolice> haasn: TL;DR previously things like ExpQ were 'untyped' in the sense the type tells you nothing, but the typechecker still type-checks bracketed forms like [| True |] :: ExpQ. now, those forms are no longer type-checked, only parsed
09:18:33 <ij> quchen, I think it might be a man with hands in the air.
09:18:38 <thoughtpolice> and there are now Typed expressions along the lines of TExpQ
09:18:47 <monochrom> it is \o/ except with a robot's head instead of a human's head
09:18:56 <ij> \o/
09:19:05 <haasn> thoughtpolice: ah, I guess that makes sense; it will still be type-checked where it's actually inlined though, correct?
09:19:11 <n-dolio> The truth about monochrom finally comes out.
09:19:14 <monochrom> it expresses that the robot rejoices
09:19:15 <thoughtpolice> haasn: yes, correct
09:19:31 <arboris> i just tried to compile the release version of ghc and got a large number of warnings of the form Warning: TcHsSyn: could not find link destinations for:
09:20:03 <arboris> i found a bug report that suggests it is related to a LOCALE setting
09:20:18 <thoughtpolice> the new TH is actually a pretty nice step up in power. i wonder when how long before we see people doing more staged programming
09:20:25 <thoughtpolice> s/when//
09:20:27 <arboris> has anyone else encountered this problem?
09:22:24 <athan> Hey guys, does (,) . (,) ~ (,,)? ie: Does (a, (b, c)) ~ (a,b,c)?
09:22:25 <arboris> the bug is https://ghc.haskell.org/trac/ghc/ticket/8825
09:23:03 <fizruk> :t (,) . (,)
09:23:05 <vermeille> Is there any use of category theory, monads, monoids, functors etc, in a non-Haskell context?
09:23:05 <lambdabot> a -> b -> (b1 -> (a, b1), b)
09:23:13 <johnw> vermeille: you mean, like a math context? :)
09:23:21 <c_wraith> athan: nested pairs are not the same as larger tuples
09:23:28 <haasn> arboris: that looks like a warning Haddock would output, what's the rest?
09:23:31 <vermeille> johnw: I was more thinking about a programming context, I'm not a mathematician
09:23:31 <fizruk> :t ((,) .) . (,)
09:23:32 <lambdabot> a -> a1 -> b -> ((a, a1), b)
09:23:56 <johnw> vermeille: they get used, just not recognized as such
09:23:57 <nexx> vermeille scalaz
09:24:08 <johnw> see Bartosz Milewski talk on "C++: I see a Monad in your future"
09:24:08 <vermeille> Is there a way to use this knowledge, say,  to write C++ or more common languages?
09:24:16 <athan> c_wraith: Darn. I looked at the definition of a list from the point of view of free monads, and it's functor is just (,) - it just gave me the intuition that it might reduce
09:24:21 <athan> thanks for clearing that up!
09:24:26 <DR6> monads are used in C# too
09:24:32 <DR6> only not with that name
09:24:52 <DR6> monoids show up pretty much everywhere
09:24:53 <DR6> etc
09:25:15 <dwcook> athan, keep in mind that _|_ exists
09:25:29 <vermeille> DR6: Yes, now I can recognize them, but is there an "active" way to write better code thanks to this knowledge?
09:25:37 <dwcook> Although many people like to neglect it when doing proofs about Haskell
09:25:41 <DR6> monoids?
09:25:42 <thoughtpolice> arboris: that doesn't necessarily mean anything FWIW - it just means Haddock couldn't find the appropriate thing to hyperlink to
09:25:48 <athan> dwcook: That's a very good point...
09:25:50 <athan> hmm
09:25:51 <thoughtpolice> arboris: so it could for example just be an out-of-date comment or something
09:25:56 <DR6> well, whenever you need a "default" for something
09:26:04 <athan> very easy to look past
09:26:08 <DR6> if there is a relevant monoidal operation
09:26:13 <arboris> thoughtpolice: oh ok, make there is the message <no location info>:
09:26:14 <arboris>     Warning: Couldn't figure out linker information!
09:26:17 <arboris>              Make sure you're using GNU gcc, or clang
09:26:18 <DR6> the correct "default" will probably be the identity
09:26:28 <thoughtpolice> arboris: ah! yes, that is that ticket. sorry, couldn't get around to fixing that one just yet
09:26:33 <arboris> which sounded worrying
09:26:34 <DR6> that's nice and shows up on every programming language
09:26:49 <athan> dwcook: Would (,(,))'s _|_ structure look different from (,,)'s?
09:27:05 <athan> ie the nested tuple could have it's own bottom?
09:27:09 <athan> Or is my intuition off?
09:27:11 <arboris> thoughpolice: just fyi it is independent of the RUS locale, it also does not work with DE
09:27:14 <vermeille> DR6: That's interesting! What about monads? Return looks like an object ctor, but what about Bind?
09:27:51 <DR6> monads show up a bit less because most languages don't have enough type structure to represent them well
09:28:16 <DR6> and using them in languages that don't have syntax for them tends to be cumbersome
09:28:29 <dwcook> athan, yes, in (a, (b, c)), the (b, c) is inhabited by _|_
09:28:29 <arboris> thoughtpolice: for the time being i've just rebuild with LANG=C, and that seems to fix the issue
09:28:47 <vermeille> DR6: like, using way too much lambdafunctions or function pointers?
09:28:56 <athan> dwcook: That clears up mountains of confusion! Thank you!!!
09:29:05 <athan> MOUNTAINS
09:29:06 <dwcook> No problem
09:29:07 <DR6> yes
09:29:21 <DR6> think what you get when desugaring do syntax
09:29:33 <vermeille> Yeah I know...
09:29:34 <thoughtpolice> arboris: yes, again sorry. probably will be fixed in 7.8.2 i believe
09:29:35 <DR6> only the lambda syntax tends to be even worse
09:29:41 <thoughtpolice> (i know what's wrong, anyway, as I wrote that code :)
09:29:57 <DR6> functors on the other hand can be more useful
09:30:15 <DR6> and the functor pattern in general
09:30:27 <arboris> thoughtpolice: no problem, the warning messages probably make it sound worse than it is.
09:30:36 <vermeille> DR6: do you have an example?
09:31:28 <DR6> well, to use that you still need a kinda functional language
09:31:37 <DR6> preferably something dynamic
09:31:44 <no-n> :t splitOn
09:31:45 <lambdabot> Eq a => [a] -> [a] -> [[a]]
09:31:46 <arboris> how far along is the simd support? I've been thinking about implementing optimized an optimized low dimensional vector library?
09:31:49 <DR6> read this: http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
09:31:53 <DR6> it's for haskell
09:32:08 <DR6> but the main gist is language agnostic
09:32:35 <DR6> the problem with using cattheory concepts outside of haskell is that other languages are not really done with that in mind
09:33:26 <nexx> DR6 why a dynamic language?
09:33:32 <no-n> @hoogle splitOn
09:33:33 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
09:33:33 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
09:33:43 <athan> is there a cofree (co)monad?
09:34:03 <DR6> because type systems that are not ML-like tend to get in the way IMO
09:34:06 <DR6> specially OO ones
09:34:20 <DR6> C# is a honorable exception
09:34:27 <bergmark> athan: in the free package
09:34:40 <nexx> oh
09:34:54 <vermeille> DR6: yeah, I tried to implement a monad in C++, it was... well.. "funny". But I was hoping that this cattheory could be useful at a conception/design level
09:34:55 <DR6> it's just data Cofree f a = a :> f (Cofree f a)
09:34:58 <athan> bergmark: Thanks!
09:36:03 <haasn> DR6: CT is a royal pain in C#
09:36:19 <DR6> advanced CT yes
09:36:29 <DR6> but it's still better than most
09:37:01 <Jesin> "In GHC 7.10, Applicative will become a superclass of Monad"
09:37:03 <Jesin> is this true?
09:37:28 <DR6> Jesin: yes
09:37:37 <Jesin> ahh finally
09:38:38 <vermeille> the thing I struggle with, when learning categories, is to understand the "intent" (or use case) behind a category
09:39:22 <DR6> i think categories are more useful in math than in programming really
09:39:42 <Jesin> hmm
09:39:47 <vermeille> But this point of view might even be completely wrong since you implement categories that are properties of your structure, rather than you implement a category because you need it
09:39:53 <Jesin> is "fail" still going to be part of the Monad typeclass?  <_<
09:40:10 <dmj`> is MIO in the 7.8.1 release?
09:40:36 <thoughtpolice> dmj`: yes
09:40:43 <thoughtpolice> you don't need to do anything to use it
09:40:49 <thoughtpolice> your applications should just magically scale better
09:40:50 <nexx> Once I wrote monads in Python. I found it hard to write the code correct without a decent type system
09:40:52 <dmj`> thoughtpolice: yes awesome!
09:42:59 <c_wraith> nexx: also, the type signature for return doesn't really work in python.  It has no way to know how to create the right class.
09:43:09 <Jesin> More importantly
09:43:13 <dmj`> i love magic
09:43:42 <dmj`> thoughtpolice: what is the outlook on windows? Was 7.8.1 released w/ known bugs in Win64?
09:44:21 <thoughtpolice> Windows 64bit and Windows 32bit should be stable. there are no shared libraries for Windows yet (they had to be pulled), but that will probably be fixed for 7.8.2
09:44:30 <thoughtpolice> all things considered, the Win64 port got some important bugfixes too
09:44:38 <thoughtpolice> so it may even be considered more stable than 7.6 :P
09:45:02 <Jesin> DR6: when that happens, I hope "join" will become part of the Monad typeclass as well, so that implementations can optionally define fmap, join, return instead of (>>=), return
09:45:27 <johnw> I'd like join to be in Monad too
09:47:19 <c_wraith> Jesin: the details of what 7.8 warns on (use of join as a local identifier, specifically) suggest that might happen.
09:51:22 <prinsen> type APIT = forall m. (MonadIO m) => RWST (Map Text Text) [Text] (Map Text Text) m has kind *, why?
09:51:24 <shergill> i'd like to be able to use alternative formulations of some of the typeclasses (monad, applicative) without needing newtype wrappers everywhere
09:51:42 <prinsen> if i change m to IO it has kind * -> * as I want
09:52:25 <Jesin> http://www.reddit.com/r/haskell/comments/22awqn/why_does_map_even_exists/cglnnz9 I must say I agree with this.
09:53:29 <c_wraith> prinsen: what version of GHC?  also, if you work around by adding the type parameter (type APIT a = ... a), does it work right?
09:54:07 <nexx> Just looked at my implementation. I already stopped with Functor. But had a similar problem with mconcat on monoids
09:54:39 <c_wraith> I would have thought it would be mempty
09:56:26 <nexx> Err, I stopped with Applicative, but for some reason I didn't publish it.
09:56:56 <nexx> c_wraith the problem was getting mempty in case of an empty list
09:58:21 <nexx> c_wraith I used pythons single dispatch which comes with 3.4
09:59:13 <nexx> also mempty is a cheat in my code
09:59:18 <c_wraith> nexx: I haven't used it..  But I assume it still dispatches based on properties of a value at runtime, rather than a type at compile time.
09:59:31 <athan> Why are free monads called "free"?
09:59:39 <athan> or is that a CT question?
10:00:12 <dmj`> athan: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
10:00:28 <xico> athan: actually a standard algebra question
10:00:29 <athan> I just finished it!!!
10:00:35 <dmj`> oh
10:00:37 <athan> hahaha
10:00:45 <athan> :)
10:01:01 <athan> xico: Can you explain? o.o
10:01:28 <athan> to me it feels similar to "free-wheeling"
10:01:34 <athan> because it's recursive
10:01:53 <nexx> c_wraith of course
10:02:38 <athan> derp, I just saw that link at the bottom - Free Object
10:08:30 <amf> cabal is giving me linking errors like this one: ld: cannot find -lHSrandom-1.0.1.1-ghc7.8.1
10:09:10 <amf> anyone know how to fix it?
10:10:35 <ReinH> athan: a free monad arises from a functor that is left-adjoint to a forgetful functor
10:12:31 <shergill> where a monad is nothing more than a monoid in the category of endofunctors
10:12:44 <ReinH> and a free monad is a free monoid in the category of endofunctors
10:12:45 <pavonia> This is weird, if I run GHCi with -M128M it crashes at about 180MB used memory, if I run it with -M200M it goes up to about 266MB and stays there. Any ideas why it's still using 60MB more that requested?
10:13:04 <athan> ahh!
10:13:13 <athan> ReinH: Thank you!
10:13:13 <shergill> precisely. simples.
10:13:26 <ReinH> athan: :)
10:13:53 <athan> I still need to learn left-adjoint / forgetful functor
10:14:06 <athan> but the monoid relation really makes sense to me
10:14:10 <athan> Thank you!!
10:14:19 <ReinH> athan: TheCatsters on youtube have some videos on adjoints
10:14:37 <xico> doesn't explain why they are called free :)
10:14:52 <pavonia> Apparently -M only sets the maximum heap size, maybe I have to set another size too?
10:15:05 <ReinH> xico: they're called free because someone chose the word and it stuck :p
10:15:22 <ReinH> (for free functors and free objects)
10:15:41 <xico> for free groups in fact
10:15:54 <xico> because they are the simplest ones
10:16:01 <shergill> the ever-pervasive anthropic principle
10:16:02 * hackagebot yesod-persistent 1.2.2.3 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.2.2.3 (MichaelSnoyman)
10:16:20 <athan> ReinH: I'll check it out!!
10:16:46 <ReinH> xico: aren't free monoids simplest?
10:16:56 <ReinH> xico: free groups require an additional equivalence relation for inverses
10:17:00 <xico> simplest of groups actually
10:18:10 <xico> monoids where not really studied in the 19th century
10:20:52 <ReinH> that's as may be :p
10:21:50 <maxcan> is cabal-install's bootstrap.sh broken on ghc 7.8.1 for anyone else?
10:25:35 <dmj`> is there a strict update in lens?
10:26:03 * hackagebot groundhog 0.4.2.2 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.4.2.2 (BorisLykah)
10:26:06 * hackagebot groundhog-th 0.4.2.2 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.4.2.2 (BorisLykah)
10:26:07 * hackagebot groundhog-sqlite 0.4.2.2 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.4.2.2 (BorisLykah)
10:26:09 * hackagebot groundhog-postgresql 0.4.2.2 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.4.2.2 (BorisLykah)
10:26:11 * hackagebot groundhog-mysql 0.4.2.2 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.4.2.2 (BorisLykah)
10:27:36 <makalu> does anyone know of a good book/website/article/tutorial to learn ML when you already know Haskell?
10:28:11 <WraithM> makalu: Ed Yang made a thing recently. http://blog.ezyang.com/2010/10/ocaml-for-haskellers/
10:28:27 <artyomkazak> Recently?
10:28:51 <ReinH> artyomkazak: for some value of
10:28:55 <artyomkazak> Ah
10:29:13 <WraithM> lfjdsklajf
10:29:17 <WraithM> lol, not recently
10:29:55 <makalu> how useful is it for learning ML?
10:30:06 <ReinH> artyomkazak: (which unifies with "not recently")
10:30:07 <WraithM> It at least shows you the syntax.
10:30:21 <haskell-newbie> hello
10:30:58 <WraithM> The Coq thing was recent, right?
10:31:07 <WraithM> I think that's what I was thinking of as recent.
10:31:12 <makalu> thanks WraithM
10:31:29 <ReinH> haskell-newbie: hello
10:31:38 <haskell-newbie> are there any typesafe sql libraries without so much template haskell like in persistent rather with much of abstraction to eliminate need in th?
10:31:40 <makalu> I will not write ML but I might need to be able to read ML
10:31:41 <WraithM> Np :) Real World OCaml might be good too!
10:31:50 <dmj`> haskell-newbie: try groundhog
10:33:01 <WraithM> makalu: I've found that reading and writing OCaml isn't so bad after you learn some of the differences. I took a class in OCaml while only knowing Haskell, and it went really well.
10:33:48 <haskell-newbie> dmj`: https://github.com/lykahb/groundhog there is still sprkkles of TH all around
10:34:05 <haskell-newbie> are there at least *less* th than in presistent?
10:34:10 <makalu> isn't so bad? I assume it's fantastic when compared to writing PHP/C++/Java/whatever?
10:34:28 <haskell-newbie> snoyman seems to be obsessed with th
10:34:54 <dmj`> haskell-newbie: It's an ORM
10:35:05 <srhb> If you just want sql, neither are what you should be looking at
10:35:13 <haskell-newbie> dmj`: there is no objects in haskell
10:35:23 <dmj`> there doesn't need to be
10:35:25 <WraithM> makalu: :) Fantastic is the right word.
10:35:48 <haskell-newbie> dmj`: ORM -Object relational mapping
10:36:02 <pordan30> haskell-newvie: <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.106.772&rep=rep1&type=pdf>
10:36:05 * hackagebot meep 0.1.1.0 - A silly container  http://hackage.haskell.org/package/meep-0.1.1.0 (MatveyAksenov)
10:36:08 <haskell-newbie> dmj`: ORM with ot object is RM :D
10:36:13 <geekosaur> object request manager, a protocol for talking to remote objects
10:36:19 <geekosaur> doesn't matter what you have locally
10:36:22 <dmj`> haskell-newbie: TH isn't evil. It sucks only in that it makes the order of you top level function declarations of your file actually matter. TH is nice to remove boilerplate instance declarations
10:36:27 <dmj`> your*
10:36:48 <srhb> Though deriving mechanisms feel better when possible.
10:36:53 <haskell-newbie> dmj`: it is evil since it's not made it's way to Safe haskell.
10:37:12 <haskell-newbie> geekosaur: ah, i see, thanks for clarifiaction
10:37:20 <srhb> haskell-newbie: That's because of compile time IO.
10:37:25 <srhb> Well, mostly.
10:37:34 <srhb> Which is sort of the point of TH.
10:38:29 <haskell-newbie> pordan30: ha-ha, Oleg Kiselyov is known for his mostly useless crazyness in CS field
10:39:07 <dmj`> haskell-newbie: iteratees are not useless
10:39:42 <ReinH> iteratees are the basis for two very useful libraries, pipes and conduit
10:39:48 <haskell-newbie> dmj`: are not craziness either
10:40:04 <ReinH> haskell-newbie: you seem to have a lot of negative opinions that aren't what I would call well founded
10:40:35 <haskell-newbie> ReinH: Your opinion is not well founded too I must say.
10:41:00 <srhb> Dis gun' be good. *gets popcorn*
10:41:08 * ReinH shrugs
10:41:11 <srhb> :-)
10:41:11 <thoughtpolice> Oleg still has the best delimited continuations tutorial in my opinion, i loved that paper.
10:41:12 <dmj`> haskell-newbie: your opinion of ReinH's opinion of your opinion is neither well-founded. q.e.d.
10:41:52 <thoughtpolice> for the intrigued: http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf
10:41:55 <srhb> Would be nice if something happened with the module system too, a la translucent functors
10:41:57 <haskell-newbie> yeah, it's not constructive and childish to make such statements without argumentation
10:42:12 <thoughtpolice> (the examples use 'OchaCaml' which is a variant of Caml Light, but you can translate this all to Haskell with Rank2Types)
10:42:25 <haskell-newbie> so okay, groundhog, got it
10:42:31 <ReinH> haskell-newbie: this isn't really a place for such aggression and negativitiy
10:42:33 <thoughtpolice> i even have a library to play around: https://github.com/thoughtpolice/hs-asai
10:42:41 <haasn> lib/Numeric/ContainerBoot.hs:515:15:
10:42:43 <haasn>     Conflicting family instance declarations:
10:42:45 <haasn>       BoundsOf (a -> a) -- Defined at lib/Numeric/ContainerBoot.hs:515:15
10:42:47 <haasn>       BoundsOf (a -> a -> a)
10:42:49 <haasn> Why do these conflict in 7.8.1 but not 7.6.2?
10:43:05 <haskell-newbie> ReinH: seeing aggression in everything you don't like is mental issues i don't want to deal with, sorry
10:43:30 <ReinH> haskell-newbie: and now you've claimed that I have mental issues. Please stop with the personal insults.
10:44:35 --- mode: ChanServ set +o geekosaur
10:46:36 <haskell-newbie> ReinH: it wasn't an insult but you just proved it, get lost, like I said i don't want to continue this non constructive discussion with you
10:46:38 <srhb> Any general idea of how far 7.8.1 integration is along?
10:46:44 <srhb> I'm dying for them typed holes.
10:47:02 <haskell-newbie> dmj`: thanks
10:47:16 <ReinH> haskell-newbie: I don't think I'll be getting lost. Please stop being abusive to people in this channel.
10:47:19 <haasn> srhb: rolling it out on my system as we speak, I encountered a handful of packages that were broken, mainly old ones that I just removed from my system to compensate
10:47:35 <haasn> srhb: the most major breakage so far for me has been timezone-series and hmatrix, both of which have patched versions not yet on haddock
10:47:35 <srhb> haasn: Sounds good!
10:49:42 <ReinH> haasn: well that's not too bad.
10:50:29 <klrr_> ReinH: any new haskellcast coming soon? :)
10:50:38 <ReinH> klrr_: yes soon :)
10:50:42 <bergmark> \o/
10:50:42 <klrr_> nice :D
10:50:53 <ReinH> just have to get it scheduled, recorded, edited, and published :D
10:51:02 <srhb> How does one find out which version of gmp is installed?
10:51:46 <srhb> Eh, find does the tric
10:52:04 <haasn> Oh no, oh no oh no oh no
10:52:07 <haasn> acme-schoenfinkel is broken
10:52:16 <haasn> This will simply not do
10:54:36 <ReinH> lol
10:55:23 <haasn> I don't understand the error, either
10:57:06 --- mode: geekosaur set -o geekosaur
10:57:54 <thoughtpolice> haasn: as long as acme-colosson is OK, we're fine
10:58:45 <shachaf> There's no superclass for categories with products? :-(
10:58:46 <ReinH> @seen bos
10:58:46 <lambdabot> 8O$
10:59:01 <nh2> is there a change regarding unsafePerformIO in 7.8? I can't build XHB with it
10:59:08 <ReinH> well that didn't do what I expected
10:59:09 <ReinH> oh well
10:59:20 <geekosaur> there is no @seen
10:59:25 <ReinH> indeed
10:59:30 <geekosaur> (it edit corrected to @leet aka @elite)
10:59:34 <haasn> Oh, I understand the error now; it's using GeneralizedNewtypeDeriving and the new Role breaks it
10:59:42 <ReinH> geekosaur: how does that even happen?
10:59:57 <geekosaur> huh?
11:00:04 <ReinH> nearest by edit distance?
11:00:05 <nh2> ah, there we go: It was removed from `Foreign`
11:00:24 <geekosaur> up to 3 edit corrections allowed, only if it produces a single match
11:00:26 <monoidal> haasn: https://ghc.haskell.org/trac/ghc/ticket/8162
11:00:32 <haasn> srhb: gloss and acid-state are also broken; the latter has a fix on git
11:00:37 <haasn> no idea about the former
11:00:47 <geekosaur> a correction being a single letter change, single letter insertion, single letter deletion
11:01:04 <haasn> monoidal: thanks
11:01:09 * hackagebot aws 0.9 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.9 (AristidBreitkreuz)
11:01:10 <shachaf> Up to and not including 3.
11:01:15 <ReinH> geekosaur: ah ok
11:02:56 <gamegoblin> quchen: you around?
11:09:58 <popx> is there a recommended way to install ghc on freebsd?
11:10:06 <popx> should i use the "haskell-platform" port?
11:10:14 <popx> or install ghc and cabal separately?
11:10:40 <geekosaur> in general you're better off using the target's official platform package(s)
11:11:14 <popx> I would be installing it using the official ports
11:11:21 <popx> (either way)
11:12:36 <deweyvm> how does one do a case expression on one line?
11:13:04 <popx> case ABC of { PAT aaa -> asdasd; ... }
11:13:19 <Saizan> popx: some prefer just ghc and cabal because they don't use many libs from haskell-platform, i don't know of anything specific to freebsd though
11:13:48 <Okasu> > case Just 1 of { Just n -> n; Nothing -> undefined }
11:13:50 <lambdabot>  1
11:13:57 <Okasu> deweyvm: ^
11:14:07 <deweyvm> thanks
11:14:17 <deweyvm> must be some other reason lambdabot doesnt like this then
11:14:54 <dwcook> deweyvm, what did you observe that made you think that lambdabot didn't like one-line case expressions?
11:15:04 <geekosaur> if you're also using let or do, note that you need extra braces to terminate those
11:15:27 <geekosaur> in particular, if you're doing it all on one line, you need let { a = 5; b = 6 } in ...
11:16:11 * hackagebot test-pkg 0.1.0.0 - Just tests Hackage  http://hackage.haskell.org/package/test-pkg-0.1.0.0 (IavorDiatchki)
11:16:14 <deweyvm> @pl (\(pt, m) -> case m of {Nothing -> False ; Just e -> f (pt, e)})
11:16:14 <lambdabot> (line 1, column 24):
11:16:14 <lambdabot> unexpected "{"
11:16:14 <lambdabot> expecting variable, "(", operator or ")"
11:16:32 <magicman> So the guy who runs this machine just did a huge update to the system.
11:16:38 <magicman> And now ghc --version is crashing with:
11:16:38 <deweyvm> thats the one
11:16:39 <magicman> /usr/lib64/ghc-7.6.3/ghc: error while loading shared libraries: libffi.so.4: cannot open shared object file: No such file or directory
11:16:56 <geekosaur> oh
11:17:05 <magicman> Anything I can do from non-admin-land?
11:17:14 <geekosaur> that's because @pl doesn't know how to de-point a case expression
11:17:27 <deweyvm> ahh okay
11:17:46 <deweyvm> i was having trouble getting rid of it too :P
11:18:35 <geekosaur> you need an extension
11:18:58 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#lambda-case
11:19:24 <deweyvm> oh i just meant simplifying it to not need the case expression
11:19:29 <dwcook> deweyvm, that's just the pl extension not being aware of case.
11:19:29 <deweyvm> with all somehow maybe
11:19:43 <geekosaur> yeh, @pl doesn't even try, it just errors out if it sees case
11:19:46 <dwcook> Oh, I was late
11:20:44 <monochrom> please do not work too hard to eliminate "case"
11:21:14 * hackagebot test-pkg 0.2.0.0 - Just tests Hackage  http://hackage.haskell.org/package/test-pkg-0.2.0.0 (IavorDiatchki)
11:21:14 <deweyvm> fair enough
11:21:29 <deweyvm> i think ill just split what i want into a function for now
11:21:43 <deweyvm> the cases will be in the definitino itself
11:21:47 <dwcook> Often a case analysis function will be available (e.g., maybe, either, bool) but case can often be clearer
11:22:20 <dwcook> Well, in the latter case if would be preferable
11:22:58 <monochrom> using a case analysis function like maybe does not make things shorter or conceptually different
11:23:25 <monochrom> well, s/shorter/substantially shorter/
11:25:24 <monochrom> some of those cases (pun!) can be rolled up by suitably designed monads, functors, or applicatives. those are substantially shorter and conceptually better. but some other cases cannot be treated this way.
11:25:58 <haasn> @tell mm_freak http://bpaste.net/show/199832/
11:25:58 <lambdabot> Consider it noted.
11:26:12 * hackagebot criterion 0.8.0.2 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.8.0.2 (BryanOSullivan)
11:26:14 * hackagebot test-pkg 0.3.0.0 - Just tests Hackage  http://hackage.haskell.org/package/test-pkg-0.3.0.0 (IavorDiatchki)
11:27:09 <benbangert> if the Haskell Platform is on a 6-month release schedule (its website says it is), aren't we a bit overdue for a few versions?
11:27:26 <deweyvm> oh if i do (a, Maybe b) -> Maybe (a, b) then i dont need this at all
11:27:33 <geekosaur> the last one was skipped entirely because of the long delays in the release of ghc 7./8
11:27:36 <bergmark> benbangert: yes, they were waiting for 7.8
11:27:43 <monochrom> the Haskell Platform is always overdue. every time.
11:27:49 <haasn> @tell mm_freak Ps. I think this means we actually could have used acme-schoenfinkel to implement unsafeCoerce
11:27:50 <lambdabot> Consider it noted.
11:27:51 <geekosaur> the original plan was in October... it just came out today
11:27:53 <bergmark> i think they decided to release one very soon
11:28:00 <benbangert> awesome
11:28:10 <bergmark> check the libraries mailing list
11:28:17 <bergmark> ehm, the platform mailing list i mean
11:28:25 <edwardk> fun: contramap f = fmap (Dual f)   works.    contramap f = id fmap (id Dual f)   does not ;)
11:28:29 <geekosaur> so the HP plan currently is to release in May and they're hammering out details now
11:28:36 <edwardk> remove either id and it works
11:28:38 <bergmark> oh it's in both :-)
11:28:53 <geekosaur> (this is all happening on libraries@haskell.org, as mentioned --- you may want to subscribe)
11:29:01 <monochrom> it is rather like me taking cold/flu pills. the direction says "every 6 hours". I always miss the schedule.
11:29:21 <haasn> :t id fmap
11:29:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:29:45 <haasn> oh!
11:29:56 <haasn> I was thinking of id `asTypeOf` fmap
11:30:03 <geekosaur> (the big problem here is Mac support, which should finally be nailed down properly in 7.8; nobody wanted to release a hack that would be superseded and potentially broken when 7.8 did finally come out)
11:30:09 <Qfwfq> "There is a new extension, EmptyCase, which allows to write a case expression with no alternatives case ... of {}." What's the result type?
11:30:16 <monoidal> Qfwfq: a
11:31:10 <Qfwfq> monoidal: Where does the value come from? Is the case like expression identity, and so require the ... to be of a? Does a need to have a Default instance?
11:31:26 <monochrom> the value is bottom
11:31:27 <geekosaur> :t undefined
11:31:28 <lambdabot> a
11:31:31 <geekosaur> ^ think abotu this
11:31:33 <monoidal> Qfwfq: essentially, empty case is the same as a call to error
11:31:59 <monoidal> Qfwfq: however, you can use it to mark cleanly you're deconstructing a value with no constructors
11:32:44 <Qfwfq> Oh, I follow. Thanks for the explanation.
11:33:10 <srhb> Wow, lambdacase removes a lot of foo <- bar; case foo of ...
11:33:10 <augur_> man what
11:33:22 <augur_> System.Random is just dying on me
11:33:29 <srhb> Less silly names I have to invent.
11:33:31 <bitemyapp> augur_: stop making it mad.
11:33:47 <monochrom> srhb: how is that done?
11:33:52 <benbangert> geekosaur: thanks
11:34:15 <ReinH> srhb: naming things is good for you :p
11:34:20 <ReinH> builds character
11:34:37 <bitemyapp> srhb: it's one of the hard things in CS, so avoiding it could be wise or unwise, depending.
11:34:40 <monochrom> is that why God made Adam name all animals?
11:34:58 <augur_> bitemyapp: all i did was   do { ns <- sequence . repeat . getStdRandom $ randomR (1,10) ; putStr . show . take 10 $ ns }
11:34:59 <bitemyapp> I happen to be awesome at naming things. Especially projects. My favorite source of names is Ancient Babylonia
11:35:01 <Qfwfq> srhb: I think you can use it in place of any unary function, not just in the context of Monad (though I often `runEitherT main' >>= \case`. You could write `head = \case { [] = error []; x:_ = x }` or so.
11:35:05 <ReinH> bitemyapp: the other three being cache invalidation and off-by-one errors
11:35:14 <augur_> and its spinning my cpu like crazy, and consuming half my memory, before telling me it had an allocation error
11:35:15 <bitemyapp> augur_: it's punishing you for being a do-syntax-using quiche-eater.
11:35:19 <bitemyapp> ReinH: right.
11:35:25 <augur_> bitemyapp: :P
11:35:28 <augur_> quiche is delicious
11:35:37 <bitemyapp> so is do syntax.
11:35:59 <ReinH> monochrom: I guess foo >>= \case ... ?
11:36:31 <ReinH> augur_: isn't System.Random not very good at performance or randomness anyway?
11:36:40 <augur_> ReinH: apparently, but this is ridiculous
11:36:50 <augur_> i mean, its not merely not very good
11:36:54 <monochrom> @type getStdRandom
11:36:55 <lambdabot> (StdGen -> (a, StdGen)) -> IO a
11:36:55 <augur_> its unusable
11:37:00 <joneshf-laptop> do the monoid laws apply to structural equality, semantic equality, both, or is it undefined which?
11:37:06 <haasn> augur_: sequence . repeat -- is bad in general, isn't it?
11:37:10 <joneshf-laptop> or some other interpretation of equality
11:37:23 <augur_> haasn: possible :)
11:37:24 <haasn> oh, wait, that's just forever
11:37:31 <joneshf-laptop> is it implementation dependent maybe?
11:37:37 <ReinH> joneshf-laptop: Well, the monoid for diagrams uses semantic equality
11:37:38 <monochrom> augur_, your problem is the same problem as "sequence (repeat getLine)"
11:37:39 <augur_> it actually worked for 10 for one or two iterations
11:37:41 <augur_> then it died
11:37:41 <srhb> ReinH: Yeah exactly
11:37:50 <srhb> monochrom: foo >>= \case ...
11:37:53 <augur_> monochrom: cant be, it worked briefly
11:38:00 <ReinH> joneshf-laptop: but usually structural
11:38:09 <monochrom> I agree to disagree.
11:38:14 <haasn> augur_: it seems expected to me
11:38:27 <augur_> monochrom: you disagree that it worked. or that thats not the problem?
11:38:28 <joneshf-laptop> ReinH, hmm, have there been any issues going with semantic equality?
11:38:37 <haasn> it seems like the only way to make that work as-is would be to add unsafeInterleaveIO
11:38:45 <monochrom> I diagree with "cant be".
11:38:53 <ReinH> joneshf-laptop: you'd have to ask byorgey ;)
11:39:02 <augur_> monochrom: well then explain to me why it worked once, and then stopped working!
11:39:09 <ReinH> joneshf-laptop: diagrams seems to work well enough though
11:39:37 <augur_> anyway, i need a stream of random ints. is that possible?
11:39:50 <haasn> augur_: ‘randoms’
11:39:51 <monochrom> yes. newStdGen, then randomRs
11:39:54 <ReinH> There's a corrolary to Hanlon's Razor, right? "Never attribute to computer error that which can be attributed to human error"
11:40:29 <augur_> monochrom: ah, that seems reasonable!
11:44:21 <joneshf-laptop> ReinH, thanks
11:44:32 <joneshf-laptop> byorgey, any comments?
11:44:48 <joneshf-laptop> byorgey, re semantic equality vs structural equality for monoids
11:45:12 <byorgey> joneshf-laptop: well, if you want to use some equivalence relation other than structural equality, you need to be a bit more careful in constructing your API
11:45:21 <byorgey> so that ideally users can't observe the difference
11:45:48 <monochrom> Haskell's Data.Ratio may be a good example
11:46:35 <ReinH> joneshf-laptop: byorgey has the best comments
11:47:01 <byorgey> as a gratuitous aside, it would be a joy to do this kind of thing if we had a programming language based on homotopy type theory.
11:47:14 <byorgey> for now I will just dream.
11:47:25 <djahandarie> Has anyone read "The Lambda Calculus, its Syntax and Semantics" by Barendregt?
11:47:36 <byorgey> djahandarie: I've read parts of it
11:47:51 <monochrom> I read the first few pages, then gave up.
11:48:16 <byorgey> yes, it seems good as a reference, but I would not want to read the whole thing.
11:48:29 <djahandarie> Hmm. I was thinking of going through it as my next book to read through, but apparently that may not be a great idea. :)
11:48:42 <monochrom> it depends on what you're interested in
11:48:42 <byorgey> one of those seminal works that everyone cites but very few people have actually read.
11:48:52 <djahandarie> I did notice there was quite a bit of theorem-proof-theorem-proof going on
11:49:17 <djahandarie> monochrom, to learn a lot of the formal stuff which I've just been ignoring this whole time.
11:49:33 <monochrom> me, I am uninterested in all the technical details of all possible ways of giving semantics to lambda calculus.
11:49:40 <byorgey> djahandarie: do you know about pure type systems and the lambda cube?
11:49:47 <djahandarie> I do.
11:49:58 <byorgey> ok. well, I was going to say that section is worth reading.
11:50:38 <djahandarie> There's a section on that?
11:50:47 * shapr registers #haskell-embedded for systems that are too small for a GHC runtime
11:50:48 <djahandarie> I thought this was mostly about untyped lambda calculus.
11:51:22 <byorgey> djahandarie: I'm pretty sure, unless I am remembering something else
11:53:38 <byorgey> hmm, perhaps I am misremembering after all.  I can't find it.
11:53:51 <ReinH> byorgey: like Hagel?
11:54:12 <byorgey> ReinH: huh?
11:54:40 <ReinH> byorgey: like this but replace Hagel with HoTT http://pervegalit.wordpress.com/2012/06/09/how-to-fake-your-way-through-hegel/
11:54:45 <ReinH> Hegel
11:56:16 * hackagebot classy-prelude-yesod 0.9.0.1 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.9.0.1 (MichaelSnoyman)
11:56:18 * hackagebot semigroups 0.13.0.1 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.13.0.1 (EdwardKmett)
11:56:28 <byorgey> ReinH: hahaha
11:56:49 <ReinH> Rule 1: Never (ever) actually read HoTT
11:57:04 <shapr> Oh, it's fun!
11:57:11 <shapr> my brain is always numb afterwards, but it's so much fun!
11:57:17 <shapr> It's like academic alcohol!
11:57:29 <ReinH> Rule 2: If you do make a mistake of reading HoTT, use my personal technique of “carefully phrased selective emphasis” on certain aspects of HoTT.
11:57:50 <ReinH> shapr: ha
12:00:31 <dinosaurs> why is it after compiling and running on windows 8 I keep getting all of these dos prompts popping up and my internet connection fails?
12:00:39 <dinosaurs> somebody came into our windows support channel on efnet asking about this
12:00:46 <dinosaurs> and we can't figure out what is going on
12:00:56 <dinosaurs> is haskell compatible with windows?
12:01:14 <dinosaurs> this is what he keeps getting
12:01:15 <dinosaurs> http://imgur.com/feq03xk
12:01:16 * hackagebot hmatrix 0.15.2.1 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.15.2.1 (AlbertoRuiz)
12:01:23 <sgregory_> wah wah wah porn
12:01:32 <NikolajK> how far away is ghci's "it" form Haskells philosophy?
12:01:52 --- mode: ChanServ set +o geekosaur
12:01:56 <c_wraith> thanks geekosaur
12:01:57 --- mode: geekosaur set +b *!*EOD@*.fecalsmear.powerbrownie.com.br
12:01:57 --- kick: dinosaurs was kicked by geekosaur (dinosaurs)
12:02:13 <c_wraith> NikolajK: Kinda far.
12:02:27 <NikolajK> cute emos?
12:02:29 <monoidal> NikolajK: it's just a convenient shortcut
12:02:38 --- mode: geekosaur set -o geekosaur
12:03:49 <monoidal> NikolajK: you can think that everytime you type an expression to ghci, it prepends it with "let it = ..." or "it <- ..."
12:03:59 <augur_> geekosaur: only room for one dinosaur in this channel, huh
12:04:06 <NikolajK> let it = be
12:04:37 <joneshf-laptop> byorgey, monochrom thanks
12:04:41 <ReinH> geekosaur: if it's an imgur link it's probably porn 99% of the time.
12:04:42 <geekosaur> it's a common pattern, the imgur link starts out as a terminal and turns into porn
12:04:49 <augur_> c_wraith: is it that far?? it doesnt seem like it!
12:04:56 <geekosaur> with an antagonistic-at-outset story
12:05:01 <ReinH> Also if it's accompanied with a ridiculous description of the problem
12:05:02 <NikolajK> what would we lose if I/O wouldn't be implemented monadically. I don't quite see how >== return and join are strictly necessary there
12:05:14 <augur_> geekosaur: haha what
12:05:15 <monoidal> NikolajK: note that "it" is not mutated (maybe that's what it is confusing); it is rebound to a different term.
12:05:16 <c_wraith> augur_: I suppose it's not.  It's just rebinding a name implicitly
12:05:16 <geekosaur> I am not quite ready to autokickban on that kind of thing, but close
12:05:16 <DR6> geekosaur: what makes you think the terminal window isn't porn itself?
12:05:19 <augur_> geekosaur: now im curious!
12:05:30 <geekosaur> because my network is slow enough that I can watch it load
12:05:39 <monoidal> NikolajK: >>= is used for sequencing
12:05:46 <NikolajK> mutated/rebound? is "it" always overwritten?
12:05:57 <c_wraith> NikolajK: IO isn't *implemented* monadically.  It's implemented with the IO type, which happens to provide a monadic interface (among many others)
12:06:02 <augur_> geekosaur: oh man it does! and it looks like good porn too. \o/
12:06:04 <monoidal> NikolajK: not in the sense that in C, x = 2; x = 3 modifies x to 3
12:06:17 * hackagebot algebraic-classes 0.5.2 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0.5.2 (SjoerdVisscher)
12:06:20 <monoidal> NikolajK: you can think it was first it0, then it1, then it2 etc
12:06:47 <NikolajK> c_wraith: okay that makes sense. But people say we need the monad to marry I/O with functional programming, right?
12:06:56 <c_wraith> NikolajK: those people are wrong
12:07:06 <c_wraith> NikolajK: many people say wrong things about monads.
12:07:15 <NikolajK> monoidal: okay, so it's another expression, but ghci doesn't show us this
12:07:36 <c_wraith> NikolajK: the only correct things to say about monads are the ones about them being a pattern of abstraction.
12:07:41 <NikolajK> how is join interpreted for the monad?
12:07:42 <colDrMcBeardman> NikolajK, haskell used to use something called a lazy list for IO
12:07:44 <monoidal> NikolajK: it's bit like "let x = 1 in let x = True in x" - the first 1 is not overriden with True, but it is shadowed
12:08:27 <NikolajK> I "get" monads via hom-class adjunctions, but >>= is a weird construction (taking an arrow which is diagonally from a to mb)
12:08:48 <monochrom> monad is one way to have effects. there are many other ways.
12:08:50 <monoidal> NikolajK: do you know Kleisli category of a monad?
12:08:52 <c_wraith> NikolajK: >>= is a very operational viewpoint.
12:09:10 <NikolajK> I know the Kleisli operator is mapping even more diagonally
12:09:14 <ReinH> NikolajK: arguably, >>= mainly exists to make do notation exist.
12:09:15 <monoidal> the composition is (a -> IO b) -> (b -> IO c) -> (a -> IO c). now, eliminate a, and you get IO b -> (b -> IO c) -> IO c
12:09:42 <ReinH> NikolajK: the CT description of a monad just uses return, fmap and join
12:10:02 <ReinH> but do notation is pretty useful
12:10:10 <augur_> monoidal: ELIMINATE a?!
12:10:12 <augur_> horrible
12:10:16 <augur_> maybe just pick a = ()
12:10:47 <monoidal> augur_: meaning, it's clear that that function can use "a" in only one way - to pass it to a -> IO b
12:11:18 * hackagebot free-functors 0.6.2 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.6.2 (SjoerdVisscher)
12:11:27 <augur_> monoidal: probably true, but that doesnt make it non-existent!
12:12:37 <NikolajK> the return, fmap and join version is easiest to visualize, because return and join is natural and fmap is functorial. the combinations just mix things up. I get the (a -> IO b) -> (b -> IO c) -> (a -> IO c) to b -> (b -> IO c) -> IO c manipulation, thanks for that. But I have no mathematical exmaples in my mind for the Kleisli gadgets
12:14:36 <ReinH> NikolajK: well, the Kleisli gadgets make it more clear that the monad laws are a special case of the category laws
12:14:57 <c_wraith> NikolajK: ...  darn it, ReinH beat me to it.  The Kleisli stuff just shows that a monad is a category.
12:15:19 <monoidal> a -> IO b is like a C function that takes a value of type a and returns a value of type b
12:15:30 <ReinH> c_wraith: :)
12:15:33 <NikolajK> that a monad is a category? if <T,f,g> is a monad, then the domain of T is necessarily a category anyway
12:17:22 <NikolajK> what is set: good for in ghci? I know set: +t gives type information with output.
12:17:28 <gdoteof> can anyone help me understand System.IO.readFile would not get anything from a namedPipe?  i am creating the named pipe, running a process that writes to it, and then attempting to read from it; but readFile is coming back with an empty string
12:17:42 <c_wraith> NikolajK: you can also use it to set command-line arguments without restarting ghci
12:17:51 <dwcook> I am reading the GHC 7.8.1 release notes with a smile on my face
12:17:58 <gdoteof> i am not sure if that is because i cannot guarantee the order which things are executed, or if it's because of something idiosyncratic about readFile and pipes
12:18:08 <geekosaur> gdoteof, named pipes don't behave anything like people assume they do; you can generally expect them to behave oddly especially with lazy I/O
12:18:20 <monoidal> NikolajK: :set -X<language extension>
12:18:25 <ReinH> NikolajK: or lang... yeah
12:18:51 <BeardedCoder> I'm trying to wrap my head around IO exceptions and monad transformers. I've gone down the path of Control.Monad.Trans.Error and Control. I just noticed the exceptions package by Ed Kmett that appears to do similar stuff. What should I be reading about and using when it comes to properly handling exceptions specifically in IO with transformers?
12:19:16 <gdoteof> http://lpaste.net/102493
12:20:04 <gdoteof> geekosaur: geekosaur ^ i am porting a ghetto php script that handled this before.  can you recommend how i might get things to behave in a way i can predict =D
12:21:04 <ReinH> BeardedCoder: you might want to look at errors, which wraps up EitherT and such in a nice package
12:21:07 <ReinH> @hackage errors
12:21:07 <lambdabot> http://hackage.haskell.org/package/errors
12:21:12 <constantius> hi. can anyone help me out with debugging my module inside of cabal sandbox? when I try 'cabal repl' and then ':break 51' it says "No modules are loaded with debugging support"
12:21:18 <gdoteof> can i somehow sequence the theree IO functions to unlazy them?
12:21:19 * hackagebot haskintex 0.4.1.0 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.4.1.0 (DanielDiaz)
12:21:44 <ReinH> BeardedCoder: ah, for IO exceptions specifically?
12:22:16 <BeardedCoder> ReinH: I'm reading this article. http://www.yesodweb.com/book/monad-control .
12:22:21 <geekosaur> actually I think there is a known issue with the ghc runtime where it treats the blocking open as a failure
12:22:32 <BeardedCoder> ReinH: Trying to understand that as well as if that style is still correct.
12:23:14 <geekosaur> named pipes and ghc's I/O manager don't get along especially well, since they're not special cased but they need to be because they are strange
12:24:34 <gdoteof> geekosaur: hm.  it seems there should be a way i can explicitly force the order of operations?
12:24:48 <augur_> haskell the hard way is _awful)
12:24:57 <augur_> awful awful awful
12:25:04 <augur_> if any of you are responsible for it, you should be ashamed
12:25:27 <ReinH> c_wraith: this is the only blog post on monads that I now recommend http://www.stephendiehl.com/posts/monads.html
12:25:39 <ReinH> augur_: it's a thing?
12:25:50 <augur_> ReinH: whats a thing
12:25:56 <geekosaur> the only thing I can think of offhand is make sure the writer is running (blocked on its open), or drop readFile entirely, open the pipe explicitly ReadWriteMode, and then it's up to you to try to figure out when eof happens
12:25:57 <ReinH> augur_: "Haskell The Hard Way"? Where?
12:25:57 <augur_> http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ i mean
12:26:05 <augur_> even worse, its confusingly titled!
12:26:12 <geekosaur> otherwise I think you trip over the I/O manager mishandling things
12:26:20 * hackagebot charade 0.1.1.1 - Rapid prototyping websites with Snap and Heist  http://hackage.haskell.org/package/charade-0.1.1.1 (DougBeardsley)
12:26:29 <geekosaur> and no order of operations will help because the I/O manager sabotages you :(
12:26:32 <ReinH> augur_: what do you like about it?
12:26:38 <ReinH> augur_: *dislike
12:26:46 <augur_> ReinH: its just horrible as a whole
12:26:50 <ReinH> augur_: oh just that
12:26:54 <augur_> :P
12:26:54 <c_wraith> I still don't understand why the IO manager treats filesystem IO as blocking.
12:27:20 <augur_> the formatting is a pain in the ass, it has weird, stupid falsities, misleading bits, and explanations that dont help
12:27:35 <gdoteof> geekosaur: alright.  i don't control the writer so i will try the ReadWriteMode
12:27:39 <geekosaur> named pipes *are* blocking. in ways the I/O manager doesn't really know how to deal with
12:28:10 <geekosaur> as for treating files as blocking... does that even work? select()/poll() consider them always ready (even when they're remote files, sigh)
12:28:39 <c_wraith> I really wish you could tell the filesystem you'd like a notification when there's data in RAM as the result of a read.
12:29:09 <c_wraith> That's what select/poll are kind of sort of like.  Except apparently they don't actually do that.
12:30:27 <c_wraith> Huh.  That's actually nearly entirely the opposite of how select/EWOULDBLOCK/etc work
12:30:40 <c_wraith> Ok, that entire system is a design error.  Let's throw it out. :)
12:31:19 <osa1> interesting. f' = runST . f fails with type error but f' i = runST (f i) is accepted. why is that?
12:31:24 <geekosaur> c_wraith, that'd be posix aio. which is broken in other ways
12:31:44 <c_wraith> osa1: the really odd thing is that f' i = runST $ f i  works
12:31:47 <ReinH> osa1: I'm going to guess the DMR
12:31:51 <c_wraith> osa1: that's the part that makes no sense at all
12:32:07 <osa1> c_wraith: what?
12:32:12 <c_wraith> osa1: it doesn't work because it'd require GHC to infer a polymorphic type for (.)
12:32:22 <ReinH> c_wraith: so yes the DMR :)
12:32:29 <osa1> what is DMR?
12:32:30 <c_wraith> ReinH: nothing like the DMR
12:32:36 <thoughtpolice> it's not the monomorphism restriction
12:32:36 <pavonia> Is there an opposite to lift, i.e. push an action down in the monad stack?
12:32:40 <ReinH> c_wraith: oh. yeah.
12:32:49 <thoughtpolice> osa1: "Dreaded Monomorphism Restriction"
12:32:51 <ReinH> never mind
12:32:56 <monochrom> runST uses a rank-2 type. it is why runST `op` f cannot enjoy type inference, for all op. except for $, because GHC special-case it.
12:32:58 <osa1> ah ok
12:32:59 <ReinH> pavonia: yes, in mmorph
12:33:02 <ReinH> @hackage mmorph
12:33:02 <lambdabot> http://hackage.haskell.org/package/mmorph
12:33:12 <osa1> interesting
12:33:16 <thoughtpolice> and yes, it's probably due to the rank2 type of runST that you see things like this
12:33:21 <thoughtpolice> ($) is particularly special in the type inferencer
12:33:25 <c_wraith> osa1: it doesn't work because GHC would need to infer a type with (forall s. stuff) in it for (.)
12:33:35 <thoughtpolice> (and as a result kind of a hack, too)
12:33:35 <pavonia> ReinH: Thanks!
12:33:38 <ReinH> pavonia: np
12:33:42 <c_wraith> osa1: and GHC will never infer a type with a forall in it
12:33:43 <shachaf> ?
12:33:54 <shachaf> What does "push an action down in the monad stack" mean?
12:33:56 <osa1> c_wraith: is it undecidable or something?
12:34:02 <c_wraith> osa1: I believe so.
12:34:14 <monochrom> I forgot whether rank-2 type inference is possible. at any rate, GHC's inferer doesn't do it.
12:34:40 <ReinH> shachaf: I suppose the dual of lift?
12:34:59 <c_wraith> in general, it'd be impredicative inference, which is *definitely* not decideable.
12:35:04 <ReinH> Monad m => t m a -> m a ?
12:35:22 <c_wraith> ReinH: very few transformers support that operation.
12:35:41 <monoidal> or maybe it's return + newtype e.g. t' a -> t m a
12:35:43 <ReinH> :t squash
12:35:44 <lambdabot> Not in scope: `squash'
12:35:53 <ReinH> squash :: (Monad m, MMonad t) => t (t m) a -> t m a
12:35:59 <ReinH> is about as close as you'll get in practice, I suppose
12:36:07 <ion> reinh: Oh, nice, the Haskellcast feed works now. :-)
12:36:10 <ReinH> ion: woo!
12:36:39 <shachaf> That's completely different, though.
12:37:20 <ReinH> shachaf: even if m is a monad transformer?
12:37:31 <ReinH> i.e. m = t n
12:37:57 <ReinH> Ah.
12:38:14 <ReinH> you aren't squashing t m -> m, you're squashing the t's together
12:41:22 * hackagebot mailgun 0.1.0.1 - Connector to Rackspace's Mailgun Service  http://hackage.haskell.org/package/mailgun-0.1.0.1 (andrewrademacher)
12:47:34 <raphie> can anyone give me some guidance on template haskell? what I'd like to do is take in an arbitrary function and convert it to one that takes each argument as a string, which it reads
12:48:55 <gdoteof> geekosaur: i got this working by using 'cat'.. fyi.  http://lpaste.net/diff/102493/102500
12:49:19 <Cale> raphie: Is there a point to this?
12:51:23 * hackagebot HTF 0.11.3.1 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.3.1 (StefanWehr)
12:51:26 <c_wraith> there's no IsList instance for Data.Set.Set?  :(
12:53:57 <bergmark> c_wraith: i think there aren't any in containers
12:54:01 <bergmark> for any type i mean
12:54:14 <raphie> Cale: experimenting with creating an autogenerated RPC framework
12:54:33 <c_wraith> bergmark: I figured that's what you meant.  For the keyed containers, that makes sense.  But for Seq and Set, IsList instances would work.
12:55:00 <bergmark> hmm i assumed it could work for keyed containers too
12:55:12 <c_wraith> I haven't looked at the class definition.  Maybe it can.
12:55:37 <c_wraith> Ah, indeed.  It will work for keyed containers
12:55:44 <c_wraith> It uses an associated type synonym
12:55:52 <bergmark> yay
12:56:23 * hackagebot mailgun 0.1.0.2 - Connector to Rackspace's Mailgun Service  http://hackage.haskell.org/package/mailgun-0.1.0.2 (andrewrademacher)
12:57:10 <c_wraith> Wow.  After 10 minutes playing with mixing PatternSynonyms with ViewPatterns, I totally want to change :< and :> in Data.Seq to be pattern synonyms.
12:57:34 <c_wraith> It would make them 100x more natural to use
12:58:11 <Cale> Well, of course, that's like *the* use case for PatternSynonyms :)
12:58:18 <bergmark> is it a breaking change to do so?
12:58:43 <c_wraith> It is a breaking change, yes
12:58:48 <c_wraith> But it's *so* much better
12:59:01 <c_wraith> and we're not afraid of breaking changes!
13:02:01 <c_wraith> I just put together my own versions of :< and :> for Data.Set.  So amazing.
13:02:58 <monochrom> what do your :< and :> do?
13:03:12 <c_wraith> pattern x :< m <- (minView -> Just (x, m))
13:03:41 <monochrom> oh! it is a name for a pattern
13:03:45 <c_wraith> yep!
13:04:01 <NikolajK> exit
13:04:04 <c_wraith> This is a fantastic usability improvement
13:04:13 <c_wraith> IE, what view patterns needed.
13:04:50 <felixn> I'm following GHC/As a library, but I can't find any definition of "typecheckedSource" or data constructor "TypeCheckedSource" on the web >_<  more importantly I can't find how to use TypeCheckedSource, or where it's defined
13:05:25 <c_wraith> felixn: is that part of the new typed template haskell stuff?
13:05:42 <c_wraith> felixn: also, are you sure you didn't mean to ask that in #ghc ?
13:06:08 <felixn> ah I can ask #ghc, I'm following #4 at http://www.haskell.org/haskellwiki/GHC/As_a_library and trying to step through the type checked ast
13:06:13 <c_wraith> felixn: oh, wait.  That's probably something old.
13:06:22 <c_wraith> felixn: GHC as a library changes quite a lot
13:06:48 <c_wraith> felixn: that page is probably several GHC versions out of date
13:07:03 <felixn> ahhh, is there a fresher place to go to?  or just look at source?
13:07:18 <felixn> I'm using GHC  7.6.3
13:08:59 <matematikaadit> It's my third time "getting started" with Haskell. Almost finished LYAH. Currently at the last chapter. And I'm amazed after reading the topic of Applicative, Monad, Writer Monad, State Monad and friends.
13:09:55 <felixn> c_wraith: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/GHC.html#t:TypecheckedSource <-- thanks, I got it!
13:10:46 <felixn> woah.. now it's 404ing, haha
13:26:00 <zerokarmaleft> matematikaadit: your perseverence seems to have paid off
13:26:13 <grozamorei> hi guys. anyone using sublimeHaskell on linux here? I have trouble with ghc mod. "SublimeHaskell: ghc-mod was not found" totally new to all this, could not found solution to fix that warning
13:28:47 <joelteon> What's a one-equation type family?
13:31:13 <thoughtpolice> joelteon: one with a single equation? type family Foo a :: *; type family Foo a where Foo Int = Bool
13:31:21 <joelteon> oh
13:31:23 <joelteon> lol ok
13:31:26 <thoughtpolice> i don't understand the context (although it would be closed if you truly wanted it to be only one equation)
13:31:38 <thoughtpolice> 'truly'
13:31:43 <joelteon> so a closed type family?
13:32:00 <thoughtpolice> a closed type family is not a single-equation type family. it just means people can't add equations later
13:32:20 <joelteon> a closed type family with one equation?
13:33:18 <thoughtpolice> joelteon: yes. that would be the 'right way' to do it if i understand you. any open or closed type family can have many, or one equation. it's just a matter of if you can add cases later
13:33:34 <thoughtpolice> which i presume you don't want (which is common, and the whole motivation behind closed type families)
13:34:54 <joelteon> correct, I can't use a closed family
13:35:01 <joelteon> it was proposed as a workaround for a GHC bug, so I can wait until the bug's fixed
13:35:06 <joelteon> thanks for the help
13:42:48 <ldrndll> grozamorei: have you installed the ghc-mod package?
13:43:26 <grozamorei> ldrndll: yes I did. I installed all the packages that pointed in the readme for plugin
13:43:59 <grozamorei> ldrndll: looks like a bug to me. I think I need to add path to ghc-mod to "add_to_PATH" in settings, but not sure
13:45:19 <ldrndll> okay; sorry, I’m not a sublime user, but I figured I’d try the obvious :)
13:46:05 <grozamorei> ldrndll: too bad :(
13:46:17 <jfischoff> the ghc-7.8.1-x86_64-unknown-linux-deb7.tar.bz2 binaries failed to complete configure for me
13:46:30 <grozamorei> is anyone here using sublime? I really could use a tip
13:46:38 <grozamorei> ldrndll: btw what do you use?
13:46:43 <jfischoff> I think I am on debian lucid, anyone else having trouble?
13:46:50 <ldrndll> emacs
13:47:15 <thoughtpolice> jfischoff: what the hell is Debian lucid?
13:47:27 <thoughtpolice> jfischoff: also, if you need an older glibc/gmp, try the -centos65 tarball, perhaps
13:47:35 <geekosaur> I would imagine that if sublime is started from a GUI, it won't see $PATH
13:47:54 <thoughtpolice> jfischoff: really, the -deb7 and -centos65 suffix have no impact on where it can run - just the environment it was built in, which implies different glibc/gmp versions
13:48:27 <jfischoff> thoughtpolice: the source build worked
13:48:46 <geekosaur> lucid sounds like ubuntu...
13:48:53 <jfischoff> oh yeah
13:48:54 <grozamorei> geekosaur: okay I started from console now. warning seems to be gone. how can I check that what it do is works?
13:49:26 <thoughtpolice> jfischoff: well, i'm not really sure what the problem is so i'm just spitballing. i'd need to see an actual error or something
13:49:46 <thoughtpolice> if you're actually talking about Ubuntu Lucid, I'm surprised you even have a recent-enough GHC to build GHC 7.8
13:49:54 <geekosaur> simplest answer is a wrapper script which does ". ~/.profile" (or "source ~/.profile" if you must be bash specific) and then exec-s the real sublime text executable
13:49:57 <thoughtpolice> but if it *is* Lucid, it's also not surprising the binary distributions doesn't work
13:50:08 <thoughtpolice> it's likely your glibc, binutils, gmp etc are all ridiculously ancient and incompatible
13:50:18 <geekosaur> getting the gui to set your $PATH properly tends to be painful on modern linux
13:50:33 <jfischoff> thoughtpolice: the error was it could not find the libgmp.so.10 I think
13:50:43 <thoughtpolice> jfischoff: right, try the -centos tarball
13:50:43 <jfischoff> I have libgmp.so.3 I think
13:50:46 <thoughtpolice> it's built against older GMP
13:50:48 <thoughtpolice> that's what you want
13:50:52 <ldrndll> grozamorei: try doing thisg
13:50:53 <jfischoff> okay good to know
13:50:54 <thoughtpolice> that should work just fine
13:50:55 <ldrndll> > To show inferred types use Show type (ctrl-k ctrl-h ctrl-t) command.
13:50:56 <lambdabot>  <hint>:1:33: parse error on input `type'
13:51:03 <thoughtpolice> jfischoff: this is the particular reason I offered two versions, FWIW
13:51:07 <ldrndll> that should use ghc-mod
13:51:25 <thoughtpolice> because right now there are lots of people who use things like CentOS 6.5, but many others who use e.g. Debian 7 and beyond, which is much more modern
13:51:37 * jfischoff nods
13:51:52 <thoughtpolice> the Debian 7 version can't work on CentOS - but the CentOS build has one drawback to the Debian build in comparison
13:52:00 <jroesch_> Is anyone working on bumping the version for the GHC homebrew recipe?
13:52:23 <thoughtpolice> which is that the CentOS build cannot offer a side-channel resistant version of modular exponentation
13:52:32 <thoughtpolice> but few people will be hurt by that, I imagine. it's a new API anyway
13:53:04 <grozamorei> ldrndll: oh I see now, it's still not working. I think I need to make it see PATH somehow, as geekosaur said
13:54:15 <ldrndll> grozamorei: try setting add_to_PATH to whatever which ghc-mod outputs
13:54:34 <ldrndll> so /Users/grozamorei/.cabal/bin/ or whatever
13:55:17 <grozamorei> ldrndll: I tried that already, actually, I can't do 'which ghc-mod', there is no command for ghc-mod
13:55:35 <geekosaur> uhhh
13:55:40 <grozamorei> but there is ghc-mod in my .cabal directory
13:55:43 <geekosaur> did you add $HOME/.cabal/bin to $PATH?
13:55:53 <geekosaur> in ~/.profile?
13:56:21 <geekosaur> (did you make sure not to use ~ in setting $PATH, because that behaves ... weirdly. specifically it will work inside bash and nowhere else, including from emacs)
14:00:51 <grozamorei> geekosaur: I did that just now. do I need to reboot something after? still looks like it's not working.
14:01:15 <grozamorei> I added like so: PATH="$HOME/.cabal/bin/ghc-mod:$PATH", hope it's correct
14:01:25 <geekosaur> changes to dotfiles take effect in the next shell; running shells, you'll need to manually update $PATH.
14:01:27 <geekosaur> but that is wrong
14:01:32 <geekosaur> $PATH contains directories not files
14:01:43 <geekosaur> so remove the `/ghc-mod`
14:02:38 <grozamorei> did it. launched from next terminal. still got error that ghc-mod not found.
14:05:03 <geekosaur> wonder if you're on one of those syste,s that don't default terminals to +ls because everyoen knows you put everything in ~/.bashrc (and then find out that rvm, hsenv, perlbrew, virtualenv, etc. won't work right...)
14:05:26 <geekosaur> there is a lot of stupid in dotfile handling in the linux community
14:05:39 <c_wraith> there's a lot of very wrong documentation about how they're used
14:05:45 <geekosaur> oh, also.
14:06:06 <geekosaur> put "export" in front of that setting (although if you aren't seeing it in a shell then you haven't gotten that far yet)
14:06:11 <geekosaur> that is, export PATH=...
14:06:14 <grozamorei> hm. acutally, putting bin folder in settings file made that stuff work, s
14:06:33 * hackagebot hxt-pickle-utils 0.1.0.1 - Utility functions for using HXT picklers.  http://hackage.haskell.org/package/hxt-pickle-utils-0.1.0.1 (AdamBergmark)
14:06:43 <grozamorei> so I guess I don't really need to fix path, at least it works.
14:08:32 <grozamorei> yes I did
14:08:57 <grozamorei> thanks for help
14:10:22 * hackagebot mailgun 0.1.0.2 - Connector to Rackspace's Mailgun Service  http://hackage.haskell.org/package/mailgun-0.1.0.2 (andrewrademacher)
14:10:22 * hackagebot hxt-pickle-utils 0.1.0.1 - Utility functions for using HXT picklers.  http://hackage.haskell.org/package/hxt-pickle-utils-0.1.0.1 (AdamBergmark)
14:10:24 <gamegoblin> I am trying to do some trace debugging. I want to print something that, in my test, is showable, but by type signature might not be
14:10:32 <gamegoblin> Is there an unsafe method to allow me to do this?
14:12:07 <c_wraith> gamegoblin: there's always unsafeCoerce
14:12:26 <gamegoblin> How would that work in my Show statement?
14:12:40 <gamegoblin> basically I have (show stuff) where stuff may or may not be show-able
14:12:49 <gamegoblin> but I know it is showable
14:13:00 <monoidal> gamegoblin: for showing unsafely, use Debug.Trace
14:13:02 <c_wraith> If you know it's showable, you must know what type it is.
14:13:12 <c_wraith> unsafeCoerce it to that type
14:13:20 <monoidal> gamegoblin: but that does not address the may-not-showable issue
14:13:32 <gamegoblin> It’s a function that typically does not need showing ability
14:13:41 <gamegoblin> but I am trying to debug
14:13:46 <gamegoblin> so I am giving it a string
14:13:51 <gamegoblin> but in general it takes a much more general type
14:13:54 <gamegoblin> that may not be showable
14:14:04 <c_wraith> traceShow (unsafeCoerce foo :: TypeYouKnowItIs) blah
14:14:14 <gamegoblin> Gotcha thanks
14:14:44 <c_wraith> that will do all kinds of bad things if you're wrong.  Be sure to remove it after testing. :)
14:18:26 <monoidal> or, define f2 :: RestrictedType; f2 x = traceShow x (f x) and call f2 in appropriate places
14:18:29 <jfischoff> is there a way to tell cabal to ignore version contraints when installing?
14:18:55 <jfischoff> I am having trouble building a package with 7.8.1 because of the base upper bounds on some packages
14:19:17 <c_wraith> monoidal: that doesn't solve the problem of it being polymorphic in the top-level signature
14:19:59 <merijn> jfischoff: There will be, soon
14:20:20 <merijn> jfischoff: Right now the easiest solution is "cabal get package", delete version bound "cabal install"
14:20:20 <monoidal> c_wraith: I mean, f2 would be less polymorphic and called in a place where the argument is known to be showable
14:20:39 <jfischoff> merijn: is the new way in cabal HEAD?
14:20:47 <merijn> jfischoff: No clue
14:20:53 <c_wraith> monoidal: the problem is that doesn't describe the use case.  The use case was "I know", not "the compiler knows"
14:20:59 <merijn> jfischoff: I just noticed it mentioned in the PVP bikeshed discussion :p
14:21:09 <jfischoff> ah
14:21:23 <c_wraith> gamegoblin: by the way, you could do things a lot more safely using cast from Data.Typeable
14:21:37 <jfischoff> PVP is a bikeshed
14:21:51 <c_wraith> gamegoblin: that won't explode all over the place if you're wrong.  It'll just print Nothing
14:21:57 <gamegoblin> mmmm
14:22:03 <gamegoblin> I just had something explode all over the place ;D
14:22:09 <gamegoblin> Luckily it just printed a whole lot of random integers
14:22:13 <gamegoblin> heh
14:22:26 <c_wraith> gamegoblin: Err, nevermind, cast needs a Typeable constraint at the top level
14:22:33 <gamegoblin> ahhh
14:22:35 <gamegoblin> oh well
14:22:56 <gamegoblin> That is my one complaint with haskell I guess. It makes print debugging very very difficult.
14:23:07 <MP2E> Seen the Writer monad?
14:23:18 <MP2E> It's not all that difficult :P
14:23:27 <gamegoblin> Mmmm in my current situation it is
14:24:23 <jfischoff> I'll add my coat to the PVP bikeshed. No bounds. You can list versions you know work, and versions that don't optionally. Hackage maintains a database of versions that work based on crowdsourced info from cabal
14:24:43 <merijn> jfischoff: I use JIT in time upperbounds on my stuff ;)
14:25:14 <merijn> jfischoff: i.e. assume it works, fix when someone complains. Because most of it is experimental and I just arbitrarily pick whatever I have installed as lower bound >.>
14:25:43 <jfischoff> merijn: I follow the PVP, but I don't know why, habit I guess.
14:26:05 <merijn> Completely unrelated
14:26:25 <jfischoff> oh
14:26:39 <merijn> jfischoff: I was going to ask a question, hence that remark >.>
14:27:01 <jfischoff> I just realized I actually don't really know what the PVP says exactly
14:27:03 <merijn> Is there a way to conveniently lift numeric literals to types? Preferably at compile time
14:28:36 <merijn> i.e. so users don't have to write "undefined :: Proxy 5" or something similarly ugly in their code
14:37:46 <prinsen> type APIT = forall m. (MonadIO m) => RWST (Map Text Text) [Text] (Map Text Text) m has kind *, why?
14:37:51 <prinsen> if i change m to IO it has kind * -> * as I want
14:38:38 <merijn> prinsen: You can't partially apply within a constraint like that
14:38:52 <merijn> prinsen: Try making it "type APIT a =" and add 'a' at the end?
14:39:31 <prinsen> merijn: But why does it work with IO instead of m?
14:39:43 <prinsen> merijn: Ill try it
14:39:51 <merijn> prinsen: Did you remove the constraint when you tried it with IO?
14:39:59 <skypers> is there a clamp function in Haskell?
14:40:35 <prinsen> merijn: yes then it was APIT = RWST ... IO
14:40:39 <skypers> @hoogle(Ord a) => a -> a -> a -> a
14:40:40 <lambdabot> Unknown command, try @list
14:40:44 <skypers> @hoogle (Ord a) => a -> a -> a -> a
14:40:45 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Color3 :: a -> a -> a -> Color3 a
14:40:45 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
14:40:45 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
14:41:04 <merijn> prinsen: Right, but that makes sense :)
14:41:04 <prinsen> merijn: when I do type APIT a .. m a I get Type synonym `APIT' should have 1 argument, but has been given none when i do :k APIT
14:41:12 <prinsen> merijn: why?
14:41:45 <skypers> @let clamp :: (Ord a) => a -> a -> a -> a; clamp mn mx x = max mn (min mx x)
14:41:45 <merijn> prinsen: Try ":k APIT Int"?
14:41:46 <lambdabot>  Defined.
14:41:59 <skypers> > clamp 0 1 0.2
14:42:00 <lambdabot>  mueval-core: GhcException "cannot satisfy -package lens\n    (use -v for mor...
14:42:07 <skypers> what?
14:42:16 <skypers> > clamp 0 10 11
14:42:17 <lambdabot>  mueval-core: GhcException "cannot satisfy -package lens\n    (use -v for mor...
14:42:20 <skypers> huh…
14:42:24 <merijn> @undefine
14:42:24 <lambdabot> Undefined.
14:42:25 <prinsen> merijn: that has kind * as expected
14:42:33 <prinsen> merijn: ill try it with pipes
14:42:36 <merijn> prinsen: It's the constraint that's messing with you
14:42:50 <skypers> @let clamp :: (Ord a) => a -> a -> a -> a; clamp mn mx x = max mn (min mx x)
14:42:51 <lambdabot>  Defined.
14:42:56 <skypers> :t clamp
14:42:57 <lambdabot> Ord a => a -> a -> a -> a
14:43:08 <skypers> > clamp 0 1 0.2 :: Float
14:43:09 <lambdabot>  mueval-core: GhcException "cannot satisfy -package lens\n    (use -v for mor...
14:43:12 <merijn> prinsen: type aliases get expanded with implicit parenthesis around them
14:43:18 <monoidal> prinsen: The fact that "type APIT = forall m. (MonadIO m) => RWST (Map Text Text) [Text] (Map Text Text) m" is accepted is a GHC bug, fixed in 7.8
14:43:25 <skypers> I might have broken something.
14:43:40 <merijn> monoidal: Right, that seemed weird to me, yeah
14:43:52 <monoidal> prinsen: if you do something more complicated with it, you'll likely get a compiler panic.
14:44:12 <monoidal> (trivia: GHC 7.6 accepts "f :: Int => Int; f = id"
14:44:21 <monoidal> )
14:44:29 <shachaf> monoidal: GHC 7.6 accepts much stranger things than that.
14:44:49 <monoidal> indeed
14:44:54 <shachaf> :t let foo :: (Int => Show Char) => Bool; foo = undefined in foo
14:44:55 <lambdabot> (Int -> Show Char) -> Bool
14:45:08 <ReinH> @pl clamp x = max mn (min mx x)
14:45:08 <lambdabot> clamp = max mn . min mx
14:45:21 * hackagebot mailgun 0.1.0.3 - Connector to Rackspace's Mailgun Service  http://hackage.haskell.org/package/mailgun-0.1.0.3 (andrewrademacher)
14:45:45 <ReinH> skypers: clamp mn mx = max mn . min mx is rather nice
14:46:07 <skypers> ReinH: sure
14:46:12 <skypers> it doesn’t actually matter
14:46:18 <ReinH> I know. I just think it's nice. :)
14:46:37 <ReinH> take the max of the min and the min of the max
14:50:21 * hackagebot hsb2hs 0.2 - Preprocesses a file, adding blobs from files as string literals.  http://hackage.haskell.org/package/hsb2hs-0.2 (JohnMacFarlane)
14:51:51 <prinsen> merijn: now this wont work yqlPipe     :: (MonadPlus mp) => Pipe Dynamic Dynamic APIT (mp r)
14:52:08 <merijn> prinsen: That's bracketed wrong
14:52:42 <merijn> prinsen: Did you intend the MonadIO in APIT to be the same monad as 'mp'?
14:52:52 <prinsen> merijn: no
14:53:26 <merijn> prinsen: Anyway, the simplest answer is "don't put your constraint into the type synonym"
14:53:41 <merijn> prinsen: Because it doesn't do what you expect it to, as evidenced by this breaking
14:55:17 <skypers> guys
14:55:41 <skypers> > 0.99999999 == 1
14:55:41 <lambdabot>  mueval-core: GhcException "cannot satisfy -package lens\n    (use -v for mor...
14:55:46 <skypers> OH COME ON
14:55:49 <skypers> well
14:55:52 <skypers> if it’s Float
14:55:56 <skypers> it’s True
14:55:59 <skypers> and it’s not normal
14:56:09 <skypers> it should be different
14:56:20 <skypers> since 0.99999999 == 0x7fffffea
14:56:27 <skypers> and 1 == 7fffffec
14:56:30 <skypers> any idea?
14:57:08 <merijn> skypers: Float uses rounding equality I think?
14:57:26 <TheKing42> When will ghc 7.8.1 start coming in through the channels?
14:57:40 <skypers> merijn: it’s not a binary equalité?
14:57:42 <merijn> TheKing42: Which channe;s?
14:57:44 <skypers> equality*
14:57:49 <merijn> skypers: Don't think so
14:57:54 <skypers> why?
14:57:58 <TheKing42> like, sudo apt-get update
14:58:51 <Clint> you can get a snapshot from debian experimental right now
14:59:18 <TheKing42> what about the normal update channels?
14:59:42 <dagle> Debian being up to date. Is this the first of april?
15:00:00 <TheKing42> I'm on Ubuntu 13.10 by the way.
15:00:02 <prinsen> merijn: type APIT = forall m. RWST (Map Text Text) [Text] (Map Text Text) m
15:00:17 <prinsen> merijn:  Illegal polymorphic or qualified type: APIT
15:00:23 <TheKing42> Also, is it in Haskell Platform yet?
15:00:28 <prinsen> merijn: Perhaps you intended to use -XLiberalTypeSynonyms
15:00:30 <merijn> prinsen: Why not "type APIT m = RWST (Map Text Text) [Text] (Map Text Text) m"?
15:00:39 <Clint> TheKing42: then when you upgrade to the forthcoming ubuntu release i assume
15:00:39 <merijn> Or
15:00:50 <merijn> "type APIT = RWST (Map Text Text) [Text] (Map Text Text)"
15:00:56 <TheKing42> Is it in the haskell platform yet?
15:01:04 <MP2E> no
15:01:16 <TheKing42> Do you know when it will?
15:01:32 <MP2E> *sigh*
15:02:00 <geekosaur> next HP update is expected in May
15:02:12 <prinsen> merijn: because then I get Expecting one more argument to `APIT'
15:02:23 <prinsen> In the type `MonadPlus mp => Pipe Dynamic Dynamic APIT (mp r)
15:03:08 <dagle> What killer feature does even 7.8.1 even have?
15:03:25 <TheKing42> Typed Holes
15:03:56 <TheKing42> It allows you to make things that act like undefined, but tell you its type when it is compiled.
15:04:12 <TheKing42> So that you don't have to guess at the type something should be deep in an expression.
15:04:17 <merijn> prinsen: So you write "Pipe Dynamic Dynamic (APIT m) (mp r)"?
15:04:21 <merijn> prinsen: What's the problem?
15:05:12 <TheKing42> also, new synatic sugar for sets and maps
15:05:20 <prinsen> merijn: just unused to the syntax, thanks
15:05:45 <merijn> prinsen: Basically, the way constraints expand within type synonyms is...usually not what you want
15:06:31 <merijn> prinsen: Parameterising your type synonym means you can "lift" the constraint outside the synonym so, you can write: "(MonadIO m, MonadPlus mp) => Pipe Dynamic Dynamic (APIT m) (mp r)"
15:07:47 <merijn> prinsen: Due to the type synonym taking an argument you can now put the MonadIO constraint in the "right" place (outside the synonym), writing it the way you originally wrote it would be treated as: "MonadPlus mp => Pipe Dynamic Dynamic (forall m . MonadIO m => APIT m) (mp r)", which is not what you wanted to happen
15:09:03 <skypers> is there a class to compare Bits?
15:09:13 <skypers> @hoogle (Bits a) => b -> b -> Bool
15:09:14 <lambdabot> Did you mean: b -> b -> Bool
15:09:14 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
15:09:14 <lambdabot> Data.Ord (<) :: Ord a => a -> a -> Bool
15:12:52 <TheKing42> @hoogle (Bits b) => b -> b -> Bool
15:12:52 <lambdabot> Could not find some databases: default
15:12:52 <lambdabot> Searching in:
15:12:52 <lambdabot>   .
15:13:56 <skypers> ok so there’s no way to compare two Float bit-to-bit in Haskell?
15:19:48 <int-e> @hoogle (Bits b) => b -> b -> Bool
15:19:55 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
15:20:01 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
15:20:33 <int-e> I've updated lambdabot, using ghc 7.8.1 now; what else did I break, besides hoogle?
15:20:58 <skypers> int-e: Float is not in Bits :(
15:21:15 <int-e> skypers: it shouldn't be.
15:21:21 <skypers> why?
15:21:30 <skypers> what if I want to test bits equality of Floats?
15:24:42 <skypers> int-e: ?
15:24:57 <int-e> what's the 3rd bit of a float?
15:25:25 <skypers> int-e: we don’t care, we just want to test binary equality
15:25:26 * hackagebot haskell-modbus 0.3.1 - A cereal-based parser for the Modbus protocol  http://hackage.haskell.org/package/haskell-modbus-0.3.1 (JasonHickner)
15:27:27 <ReinH> floating point is sort of incompatible with bitwise comparison
15:27:52 <Benzi-Junior> I'm looking for a clever way to extract a filename from a filepath
15:28:00 <ReinH> what's the difference between binary equality and regular equality?
15:28:42 <int-e> > let nan = 0/0 in nan == nan
15:28:44 <lambdabot>  False
15:28:59 <Benzi-Junior> so from /home/stuff/mix/funny/pic.jpg it would return pic.jpg
15:30:01 <ReinH> int-e: what are the bits in NaN?
15:30:54 <pordan30> is there a more concise or idiomatic way to write '\a f -> maybe (Just a) (Just . f)'?
15:31:16 <shachaf> :t \a f -> maybe (Just a) (Just . f)
15:31:17 <lambdabot> a1 -> (a -> a1) -> Maybe a -> Maybe a1
15:31:37 <int-e> ReinH: it's unspecified. The exponent is maximal (like in infinity) but the mantissa is nonzero.
15:31:37 <cdk> > reverse (takeWhile (/= '/') (reverse "/home/stuff/funny/pic.jpg")) -- Benzi-Juni, it's the simplest thing I can think of
15:31:39 <lambdabot>  "pic.jpg"
15:31:49 <thoughtpolice> Benzi-Junior: good for you, nothing clever needed! you can use 'filepath' (which comes with GHC) and use takeFileName - http://hackage.haskell.org/package/filepath-1.3.0.2/docs/System-FilePath-Posix.html
15:31:57 <ReinH> int-e: right, so you can't necessarily bitwise compare NaNs either
15:32:02 <thoughtpolice> (unless of course being clever is the point!)
15:32:08 <shachaf> Don't be clever with functions like that. :-(
15:32:09 <int-e> ReinH: I was comparing the same nan, and still got false.
15:32:17 <shachaf> You'll surely get them wrong.
15:32:20 <int-e> ReinH: because that's what IEE 7754 says.
15:32:29 <cdk> Benzi-Junior: ah, use thoughtpolice's link if correctness/robustness is at all important to you
15:32:40 <thoughtpolice> shachaf: most likely
15:32:41 <ReinH> int-e: fair enough
15:32:46 <glguy> Prelude System.FilePath> takeFileName "/home/stuff/funny/pic.jpg"
15:33:09 <glguy> Oh, thoughtpolice already got that :)
15:33:17 <shachaf> :t \a f -> Just . maybe a f -- pordan30
15:33:18 <lambdabot> b -> (a -> b) -> Maybe a -> Maybe b
15:33:28 <merijn> int-e, ReinH: "can't necessarily" -> "definitely can't compare NaN"
15:33:42 <merijn> IEEE754 defines *all* NaN values to be unequal to themselves
15:33:48 <ReinH> merijn: I know.
15:34:01 <Benzi-Junior> cdk: clever
15:34:15 <shachaf> Even GHC gets filepaths wrong.
15:34:26 <shachaf> Which is why that package exists, I suppose.
15:34:29 <thoughtpolice> a ridiculous amount of software does, really.
15:34:45 <shachaf> It's not easy to do correctly cross-platform.
15:34:47 <int-e> merijn: I never said anything differently?
15:34:54 <thoughtpolice> shachaf: no joke
15:35:03 <skypers> > fix ((+) (pi + sin pi))
15:35:07 <lambdabot>  mueval-core: Time limit exceeded
15:35:10 <pordan30> shachaf: that's actually somewhat nicer
15:35:11 * thoughtpolice fondly remembers reimplementing most of boost::filepath or whatnot in a prior C++-filled life
15:35:21 <merijn> int-e: Oh, I was just clarifying ReinH's remark
15:35:22 <thoughtpolice> and by 'fondly' i mean 'it was terrible'
15:35:47 <lispy> thoughtpolice: the good ole days
15:36:28 <pavonia> pordan30: using the composition packages it's just "Just .:. maybe"
15:36:59 <thoughtpolice> this was back at a time when that boost library didn't even correctly handle symlinks (v2, I think, v3 is far superior). of course, we ended up eating it later once we had to deal with other cross platform issues like filename encoding in the library
15:37:14 <ReinH> merijn: we were talking about bitwise comparisons of floating points and why they might be useful (instead of the more usual comparison)
15:37:29 <ReinH> merijn: int-e pointed out that bitwise comparison would give a different result for identical NaNs
15:37:37 <ReinH> which is certainly true
15:37:56 <ReinH> but I don't think it's particularly useful :p
15:38:02 <Benzi-Junior> thoughtpolice: thanks
15:39:40 <pordan30> pavonia: i never realized that there was a composition package! it saves the trouble of definition .:, ,.::, etc., over and over again :)
15:40:28 * hackagebot fay 0.19.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.19.2 (AdamBergmark)
15:41:08 <Algebr> Does ghc statically link everything by default because we don't expect people to have haskell libraries installed?
15:42:16 <jrmithdobbs> Algebr: dynamic linking by default on supported platforms as of 7.8
15:42:17 <geekosaur> mostly it's because (a) it took a long time for stuff to properly support dynamic (b) one of the more importabt "stuff" that didn't was ghci
15:42:25 <jrmithdobbs> Algebr: to my understanding it was more "the dynamic linker sucked"
15:43:28 <jrmithdobbs> Algebr: works quite well in 7.8 in my usage though
15:44:13 <pdxleif> The dynamic linker is a semi-recent innovation for GHC.
15:44:15 <thoughtpolice> dynamic linking is *not* on by default in GHC 7.8. compiled applications always default to static linking.
15:44:22 <thoughtpolice> it is only GHC *itself* which is compiled dynamically
15:44:41 <thoughtpolice> (admittedly, this is a mildly confusing point for users I think)
15:44:46 <Algebr> I see. Different question, why can't getters created by record syntax know that I'm referring to different Values Contructors?
15:45:32 <merijn> I would say that another reason to default to static linking is: 1) dynamic linking is harder and 2) dynamic linking is not all that useful anyway
15:45:42 <thoughtpolice> Algebr: know that the question you're asking has literally caused so much debate and bloodshed it's unreal. right now, it's just because Haskell records are rather simplistic - 'getters' are just regular functions in the same namespace
15:45:51 <thoughtpolice> hence why they are not 'overloaded' on the field they refer to
15:46:07 <Algebr> For example I do data Car = Car{model::String} and data Laptop = Laptop{model::String}, model doesn't know which one to pick, but clearly I would be passing it either a Car or Laptop
15:46:21 <merijn> thoughtpolice: How is the GSoC/SPJ project in that space coming along? Does anyone know?
15:46:27 <Algebr> thoughtpolice: I see, then I'll step back.
15:46:29 <thoughtpolice> Algebr: however, my excellent colleague Adam implemented a GHC extension which should hopefully land in HEAD soon
15:46:33 <thoughtpolice> which will allow you to do what you want
15:46:36 <thoughtpolice> (and some other cool stuff)
15:46:43 * thoughtpolice needs to poke Adam to commit that soon
15:47:17 <thoughtpolice> Algebr: no worries :) it's just a contentuous topic - the bloodshed bit was just a little tongue-in-cheek. it's a regular complaint and hopefully we'll soon have something better on our hands
15:47:27 <Algebr> thoughtpolice: Are we avoid dot syntax like the plague or something?
15:48:00 <thoughtpolice> Algebr: now you see why it's contentuous :) (.) semantics are a pretty heavily debated part of the whole thing
15:49:00 <thoughtpolice> Algebr: here's a blog post which gives an overview of the new records extension and what it will look like, since i'm sure you're curious
15:49:03 <thoughtpolice> http://www.well-typed.com/blog/84/
15:49:10 <merijn> Algebr: . already has two meaning already
15:49:24 <merijn> Algebr: i.e. import/qualified names and function composition
15:49:42 <merijn> Algebr: Adding "record syntax" would make it really confusing which dot people are using
15:50:08 <Algebr> Re another contentious topic, at the NYC haskell hackathon, some people were glad to have haskell be unstable or rather not used in industry. I don't understand that at all, I mean I would love to have a full time job in Haskell.
15:50:55 <Algebr> merijn: good point, err reasoning.
15:51:17 <davidfetter> hackagebot, books
15:51:31 <merijn> Algebr: Who was glad about that?
15:51:41 <davidfetter> hrm. perhaps that wasn't quite the right query
15:51:44 <Algebr> merijn: I don't remember names.
15:51:50 <thoughtpolice> merijn: people who already write Haskell and don't want competition ;)
15:52:13 <merijn> Algebr: Seems odd, now that big companies that aren't banks are starting to hire Haskellers :p
15:52:55 <merijn> Man, I should set up a rule that sends any email with subject "PVP" to my junk mail... >.>
15:53:42 <jrmithdobbs> after playing with f#, I have to say, i really dislike the idea of dual usage for '.', it feels weird even in f# where (.) is (|>)
15:54:30 <jfischoff> Algebr: There is an argument that if Haskell was very popular, more bugs would be fixed but the language would not evolve as fast
15:56:43 <jrmithdobbs> jfischoff: i don't get that, a) sure it evolves "quickly" compared to c and such but not ruby/python/etc when you count their stdlib as "part" of the language b) who cares if it evolves if noone's using it ;p
15:56:47 * davidfetter suspects if it were more popular, some substantial fraction of current haskellers would go off and fork it somehow
15:57:11 <Algebr> jfischoff: Well, like at the hackathon, those same people were talking about 7.10 and how it would break existing code. I don't know the specifics of what it would break, but I have to say that there is something to stability. Like my day job is still python2.6, for industry, programming languages aren't academic playgrounds.
15:58:11 <jrmithdobbs> Algebr: they can be both, and your specific examplee falls apart just by mentioning python 3 ...
15:58:12 <thoughtpolice> they're probably referring to the Applicative-Monad changes
15:58:27 <thoughtpolice> i only hope that the warnings we put into 7.8 will actually help take care of that
15:58:39 <merijn> davidfetter: That has already happened :p
15:58:56 <davidfetter> merijn, my point exactly. some people need to feel special.
15:59:10 <merijn> davidfetter: augusts has a strict haskell dialect going at his company ;)
15:59:23 <davidfetter> merijn, i'm not criticizing. just observing.
15:59:46 <merijn> Although, to be fair he did a major amount of work in implementing the first haskell implementation, so he knows what he's doing :p
15:59:55 <thoughtpolice> well, Mu isn't exactly a fork because they're displeased, either. to my knowledge it's fairly special in some ways for their needs
16:00:10 <thoughtpolice> that said, Lennart has definitely implemented Haskell more times than anyone else. or maybe FP langauges in general
16:00:18 <merijn> I heard they have about 50% Mu, 50% haskell atm
16:00:29 <jfischoff> Lennart wants to get rid of Mu and use GHC
16:00:38 <jfischoff> I forget what is standing in the way there
16:01:29 <jfischoff> They made Haskell by accident. First they have a small expression language then they expanded it
16:01:38 <merijn> Applicative-Monad is totally worth however many things it breaks :)
16:02:16 <jfischoff> refactoring Haskell code is not such a big deal. Its not python
16:02:55 <jrmithdobbs> merijn: agreed
16:03:20 <ion> Mu?
16:03:39 <ion> <http://www.tweaksoftware.com/static/documentation/rv/current/doc/mu.pdf>?
16:03:49 <thoughtpolice> ion: 'Mu Haskell' is the Haskell variant used at Standard Chartered Bank
16:04:06 <ion> oh
16:04:07 <thoughtpolice> it's an interesting spin on the design, with some solid improvements in some places
16:04:15 <jfischoff> ion: https://www.youtube.com/watch?v=hgOzYZDrXL0
16:04:17 <thoughtpolice> (e.g. String being abstract)
16:04:23 <ion> jfischoff: Thanks
16:04:54 <jfischoff> thoughtpolice: honest question, why do you see that as better
16:05:03 <jfischoff> String being abstract
16:05:06 <merijn> ion, thoughtpolice: Although technically I believe Mu is the name of the compiler and the language itself doesn't really have a name
16:05:33 <cgag> I compiled and ran helloworld program locally, but when I copy it to my server and try to run it i get "-bash: ./hello: No such file or directory", does this mean it's being interpreted as a bash script? anyone seen this before?
16:06:39 <jfischoff> cgag: bash can't find the file. the path is wrong. Not a haskell issue per say
16:07:09 <thoughtpolice> jfischoff: personally I've seen it as a bit odd Haskell directly exposed String as a [Char] as opposed to some abstract type, which may use some otherwise optimized representation (e.g. fusion-based like Text). that said, [Char] has its advantages too
16:07:24 <srhb> cgag: Probably not executable?
16:07:39 <srhb> Some shells have weird error messages.
16:07:59 <geekosaur> cgag: either the file is not where you think it is, or its executable stub is incorrect (different stubs on build host vs. server)
16:08:15 <srhb> Hm no, bash does say permission defnied.
16:08:21 <thoughtpolice> realistically, these days, I just see [Char] kinda like StringBuilder or whatever in Java i guess - just the intermediate buffer from which I may render other types like Text
16:08:23 <merijn> thoughtpolice: Having taught newbies ocaml, a non-list String is a pain >.>
16:08:23 <cgag> it's there and executable (-rwxr-xr-x) :\
16:09:02 <thoughtpolice> merijn: pedagogy and the fact lists are so damn convenient in Haskell are some advantages [Char] has, I think.
16:09:05 <geekosaur> can also mean you copied a 32-bit binary onto a 64-bit server without the 32-bit stuff installed
16:09:11 <geekosaur> try running ldd on it on the server
16:09:44 <cgag> "not a dynamic executable"
16:10:10 <cgag> output locally is a bunch of things like "linux-vdso.so.1 =>  (0x00007fff...)"
16:10:28 <geekosaur> ok, it's not being recognized properly by the server
16:10:39 <geekosaur> 64 bit executable on a 32 bit server?
16:11:09 <jfischoff> thoughtpolice: IMO the current approach leads to more experimentation, but it is not beginner friendly (i.e. first advice is usually don't use String, use Text)
16:11:16 <cgag> uname -a from server:  x86_64 x86_64 x86_64 GNU/Linux, from laptop: x86_64 x86_64 x86_64 GNU/Linux
16:11:41 <thoughtpolice> jfischoff: yeah i sort of hate that too.
16:11:49 <thoughtpolice> (the beginner friendly part)
16:11:54 <merijn> Does the server have libgmp installed?
16:12:04 * jfischoff nods
16:12:25 <geekosaur> "not a dynamic executable" from ldd on the server, when the build host thinks it is dynamic, means we're not getting far enough for that to be an issue
16:12:47 <merijn> geekosaur: Yeah, I wasn't paying attention >.>
16:20:32 * hackagebot yesod-pagination 0.5.1.0 - Pagination in Yesod  http://hackage.haskell.org/package/yesod-pagination-0.5.1.0 (JoelTaylor)
16:22:20 <AshyIsMe> what library does liftIO come from?
16:22:35 <shachaf> @hoogle liftIO
16:22:36 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
16:22:36 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
16:22:36 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
16:23:08 <AshyIsMe> hmm, so are they the same liftIO?
16:23:25 <AshyIsMe> i guess my real question is: http://hackage.haskell.org/package/hedis-0.6.5/docs/Database-Redis.html
16:23:36 <AshyIsMe> in the example up the top there it uses liftIO, which one is that?
16:26:43 <pavonia> Is there already a function to check if a floating number represents an integer?
16:26:51 <cgag> geekosaur:  would the server running a different (newer) version of the linux kernel matter?  At first the problem was definitely that I was running a 32 bit server, so I switched it to the latest 64 bit kernel, which is newer than the version I'm compiling on
16:27:46 <thoughtpolice> cgag: newer kernel is no prob
16:28:59 <geekosaur> AshyIsMe, Network.CGI just reexports the second one
16:29:07 <geekosaur> but where most people get it is Control.Monad.Trans
16:29:31 <geekosaur> @index liftIO
16:29:32 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
16:30:33 * hackagebot text-normal 0.2.0.0 - Unicode-normalized text  http://hackage.haskell.org/package/text-normal-0.2.0.0 (JoelTaylor)
16:30:37 <BeardedCoder> AshyIsMe: The Redis monad has an instance for MonadIO and I believe that's where liftIO is coming from in that example. <- somewhat newb haskeller
16:43:13 <cgag> i just statically linked the binary and it worked, does that give any clues as to what's wrong when I build it dynamically?
16:43:59 <geekosaur> it suggests that the 64 bit ld-linux.so may be missing or not executable
16:44:04 <cgag> i have basically no real experience with compiled languages if you can't tell, if anyone has a good resource about this let me know
16:44:41 <geekosaur> if you were running a 32 bit kernel before, nothing would have noticed because the installed userspace is all 32 bit
16:48:19 <nh2> does glib work with ghc 7.8? I get Linking dist/setup-wrapper/setup ... unrecognized option `--sysconfdir=/home/niklas/.cabal/etc'
16:49:16 <Algebr> Anyone know which directory is used when doing alt-tab on debian for the images?
16:50:00 <Algebr> I'm in /usr/share/icons/hicolor but there are quite a few directories.
16:53:14 <Algebr> oh haha, thought this was #emacs, oops.
16:53:23 <monochrom> heh
17:00:37 * hackagebot hopfield 0.1.0.2 - Hopfield Networks, Boltzmann Machines and Clusters  http://hackage.haskell.org/package/hopfield-0.1.0.2 (NiklasHambuechen)
17:10:00 <djapo> can users be queryied filtered based on what permissions they have?
17:10:21 <djapo> wrong channel, ignore
17:12:21 <flebron> Are there any other "canonical" uses of dependent typing in Haskell than (Nat using XDataKinds)?
17:13:17 <shachaf> Haskell doesn't have dependent types.
17:13:24 <shachaf> Not even with GHC extensions.
17:15:15 <schell> is there a quick and easy cotangent?
17:15:20 <schell> (operator)
17:16:42 <monochrom> what is cotangent? is it \x -> 1 / tan x ?
17:17:09 <schell> monochrom: i’m not sure, it’s been a while
17:17:19 <schell> that might explain why i can’t seem to find one
17:17:39 <schell> yeah - seems like it is
17:17:58 <monochrom> the standard lib only has sin, cos, tan, their inverses, the hyperbolic versions, and their inverses
17:18:13 <monochrom> doesn't have cot, sec, csc
17:19:08 <shachaf> "inverses" not meaning in the (1 /) sense. :-)
17:20:47 <ion> 23% [========>                              ] 16,947,083  80.1KB/s  eta 8m 16s
17:21:01 <ion> I wish haskell.org provided torrents for GHC releases. :-P (First world problems)
17:21:44 <monochrom> recip . tan is a slick way to get cot
17:22:22 <joelteon> I see that cabal repl still exits early in 7.8
17:22:45 <monochrom> what ESR says, exit early, exit often
17:23:59 <joelteon> I wouldn't be annoyed if I could at least open ghci with the sandbox package db
17:24:02 <joelteon> but I don't remember how to do that :(
17:24:26 <ion> ghci -package-db .cabal-sandbox/…-packages.conf.d
17:24:43 <schell> thanks monochrom
17:24:55 <ion> thonochrom
17:26:07 <monochrom> consider sandboxing by hand (or a few shell aliases): http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
17:26:09 <joelteon> there we go
17:31:14 <Samoi> reverseOrdered (x : y : xs) = x >= y && reverseOrdered (y : xs), would x be of type a, y of type a, and xs of type [a] ?
17:31:37 <monochrom> yes
17:31:52 <Samoi> thanks :)
17:32:11 <shachaf> And reverseOrdered would be of type Ord a => [a] -> Bool
17:32:41 <Samoi> sigh still so newb at this
17:33:02 <Samoi> what does the 'Ord a' bit mean?
17:33:07 <nh2> can I get anything wrong with instance Applicative (Mymonad e) where { pure = return; (<*>) = ap }, or only possibly lose out on performance gains I could get with an Applicative?
17:33:12 <Samoi> I understand after that
17:33:22 <monochrom> it means you're using >= on x and y
17:33:29 <nh2> when porting my code to not get the Monad-Applicative warning for 7.8
17:34:34 <monochrom> nothing wrong
17:35:41 * hackagebot persistent-odbc 0.1.2.0 - Backend for the persistent library using ODBC  http://hackage.haskell.org/package/persistent-odbc-0.1.2.0 (gbwey)
17:40:09 <Cale> Samoi: The (Ord a) bit is a constraint which expresses the idea that whichever type a is, it must be one for which ordering operations (such as (>=), (<), compare) have been defined.
17:41:11 <Samoi> ah right
17:42:51 <nh2> with AMP, are Alternative and MonadPlus exactly identical?
17:43:11 <ion> nh2: MonadPlus will have a Monad constraint, Alternative will have an Applicative constraint.
17:43:55 <nh2> ion: with AMP, every monad is an applicative
17:44:07 <ion> Yes, but not every Applicative is a Monad.
17:45:17 <nh2> ion: what I mean is, if we have AMP, does MonadPlus become obsolete / can we just use Alternative?
17:45:17 <nh2> and also, with AMP, is empty == mempty and <|> == mplus, always?
17:45:34 <Cale> It depends on the instances which are available, and probably not?
17:45:51 <ion> You’ll want to consider MonadPlus whenever you end up with x :: (Monad f, Alternative f) => …
17:46:17 <nh2> Cale: I cannot come up with how I'd write different instances for the two
17:47:44 <Cale> Well, since MonadPlus insists on a monad, you can expect instances of that to behave in some nice way with respect to the monad operations
17:48:47 <Cale> However, it's never really been clear what the laws ought to be, and at various points it's been proposed that MonadPlus be split into two classes to indicate the (at least) two major sorts of behaviour the instances have
17:49:02 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
17:49:02 <copumpkin> @ask ClaudiusMaximus any opinions on me removing the symbol renames? I don't see it being very likely that any rounded users would ever link against MPFR, and if they did I'd expect more things to go wrong than that
17:49:03 <lambdabot> Consider it noted.
17:49:10 <nh2> Cale: assuming a MonadPlus instance is law-abiding, can I get anything wrong with `instance Alternative Mymonad where { empty = mzero;  (<|>) = mplus }`?
17:49:39 <Cale> The meaning of <|> and empty is even more vague.
17:49:54 <nh2> Cale: seems fine from the law side then :D
17:50:07 <Cale> So, you'll probably not "go wrong", as long as you ensure that it's *some* monoid
17:50:14 <Cale> (for each type a)
17:50:16 <shachaf> A monoid in the category of endofunctors!
17:50:20 <Cale> no
17:50:30 <shachaf> Yes, where your product is (:*:).
17:50:35 <Cale> Just an endofunctor which creates monoids
17:50:49 <Cale> Yeah, I suppose something like that would work
17:51:11 <nh2> how's it with my `instance Applicative (Mymonad e) where { pure = return; (<*>) = ap }`? The laws are more strict here, aren't they? But I think this is always correct
17:51:12 <Cale> But the standard monoidal structure on the category of endofunctors is the one with composition :)
17:51:17 <shachaf> You have (f :*: f) ~> f and (Proxy ~> f).
17:51:51 <Cale> nh2: You can always do that when you have a monad instance, and it's perfectly valid.
17:51:55 <shachaf> nh2: Yes, that always works.
17:52:00 <nh2> great.
17:52:01 <shachaf> Sometimes an Applicative instance can be more efficient.
17:52:24 <Cale> (Or even behave really differently)
17:52:25 <shachaf> Sometimes there are multiple possible Applicative instances (but the one you use should agree with return/ap from the Monad instance).
17:52:38 <Cale> Do you think so?
17:52:39 <Cale> I'm not sure
17:53:15 <shachaf> Yes, I think so.
17:53:16 <nh2> shachaf: yes, but my implementation means that in the worst case, I just miss on potential optimisations, right?
17:53:21 <Cale> There certainly have been subtle cases where I had an applicative structure which was more useful than the best monad structure I could give, but wouldn't agree with any monad structure.
17:53:27 <shachaf> nh2: Right. It's fine.
17:54:06 <Cale> (Especially when working on FRP stuff)
17:54:10 <shachaf> Cale: I will switch from return to pure or from liftM2 to liftA2 and consider the change correct if it type-checks.
17:54:27 <shachaf> If you want a different Applicative instance you should use a newtype or something, like ZipList.
17:54:31 <Cale> I'm not sure that's always a good idea?
17:54:36 <shachaf> (Either for the Applicative or the Monad.)
17:54:39 <monochrom> there is no conflict between "it is a correct way" and "there are other correct ways"
17:55:16 <Cale> monochrom: The idea is whether if you have both Applicative F and Monad F, should (<*>) = ap semantically?
17:55:42 <Cale> (Is that something we want to guarantee?)
17:56:16 <monochrom> I don't know. but I have not heard anyone said "yes"
17:57:06 <Cale> Well, shachaf says yes. I would have thought so too, but then I ran into some cases which made me consider whether perhaps we shouldn't make such a guarantee.
18:03:36 <stian> Trying to do a very simple example with attoparsec - result compiles, but hangs. Could anyone take a look? https://gist.github.com/houshuang/7498b631e76a313bcf3e thanks
18:09:23 <Cale> stian: btw, your editor doesn't seem to be configured to replace tabs with spaces, you might want to set it to do that
18:10:29 <Cale> Not really sure why this would hang...
18:10:45 * hackagebot network-house 0.1.0.1 - data and parsers for Ethernet, TCP, UDP, IPv4, IPv6, ICMP, DHCP, TFTP  http://hackage.haskell.org/package/network-house-0.1.0.1 (NiklasHambuechen)
18:11:02 <stian> Cale: I first tried it in IHaskell, and it spun up the CPU to 100%. Thought it was an IHaskell issue :)
18:13:50 <pavonia> stian: The CPU goes up to 100% if you run that example?
18:14:23 <Cale> It's the many1 plainValue, apparently
18:14:34 <Cale> ah, right
18:14:49 <Cale> plainValue will match the empty string
18:14:56 <Cale> if the next character is a space
18:15:11 <Cale> So it's stuck matching an infinite sequence of empty strings
18:15:37 <pavonia> Ah
18:15:46 * hackagebot diagrams-core 1.1.0.2 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.1.0.2 (jeffreyrosenbluth)
18:15:51 <stian> Cale: Ah... I'm just getting started with Haskell... in Python, I would have just done " ".split(str), but I wanted to get all fancy :)
18:16:14 <stian> So much for copying and pasting from tutorials.
18:16:16 <Cale> plainValue `sepBy` space  should work
18:16:35 <Cale> Or perhaps you'd want sepBy1
18:16:52 <Cale> (which insists on one or more occurrences of the left parser)
18:17:52 --- mode: ChanServ set +o Cale
18:18:44 <stian> Cale: Thanks, now it doesn't crash. Of course, it returns "Nothing", so I still need to work on it, but improvement nevertheless :)
18:18:55 --- mode: Cale set +b *!*@90.174.1.162
18:18:55 --- kick: kolvos was kicked by Cale (kolvos)
18:19:02 --- mode: Cale set -o Cale
18:20:35 <Cale> hmm
18:23:27 <Cale> stian: try parseOnly
18:24:57 <Cale> stian: Since attoparsec parsers are meant to be applicable to partial input (and inform you when it's possible to feed them more), it's possible to get a Partial result, which you will be getting in this case, because there could always be more events at the end.
18:25:37 <Cale> stian: So it's necessary to explicitly indicate that there will be no further input. maybeResult treats Partial as failure for some reason.
18:25:47 * hackagebot persistent-odbc 0.1.2.1 - Backend for the persistent library using ODBC  http://hackage.haskell.org/package/persistent-odbc-0.1.2.1 (gbwey)
18:29:02 <stian> Cale: That worked almost perfectly. Except it only parses one word. Basically I just want to apply "words" to the rest of the string (split by space into list of words)
18:29:20 <Cale> What?
18:29:33 <Cale> Doesn't plainValue `sepBy1` space  do what you want?
18:29:36 <stian> Cale: Sorry, I'll just figure it out. I think sepBy is what I'm looking for.
18:30:10 <stian> Cale: Indeed. I'm in idiot :)
18:31:07 <pavonia> I think  plainValue `sepBy1` space fails for the last string
18:31:21 <Cale> It should pick up the last one
18:31:28 <stian> pavonia: Works for my example.
18:31:47 <stian> Now to apply it to 28MB of text, and then figure out how to extract info from it :)
18:32:55 <pavonia> Hhm, shouldn't it fail for the last string because there isn't any more space after it?
18:54:34 <boccato> Is there an easy uninstall of 7.8.1 rc1? Im on a mac?
18:55:23 <ion> Depends on where you installed it. I always install GHC to ~/.ghc so uninstallation is just a matter of rm -fr ~/.ghc
18:56:45 <boccato> The default, its in /usr/local/lib/ghc-7.8.20140130/ and /usr/local/bin/, im wondering if there is something else or only those.
19:05:57 <Algebr> I'm getting a rigid type error and have no idea what that means, can someone take a look at this? http://lpaste.net/102510
19:07:16 <ion> In the instance declaration you’re promising your makeAndModel implementation will return a value for any type of “first”. But there’s no such thing as “read :: forall first. first -> String”.
19:07:33 <ion> You’ll need to add a constraint matching your code to the declaration.
19:08:23 <ion> I’m not sure what read is useful for here, though.
19:10:56 <Algebr> ion: I don't understand your first two replies, I need to rewrite my last instance for makeAndModel? read was for expilictly converting the model, which I was gonna do as a number, to a string.
19:11:16 <ion> What’s what show is for.
19:12:31 <ion> Are you sure you want to use type classes for this? What other instances of Machine would you create?
19:12:35 <Algebr> Hmm, k, will use show, but I still don't understand...what does rigid type variable even mean?
19:12:55 <Algebr> was gonna have like data Car = Ford | Chevy
19:13:32 <geekosaur> a rigid type variable is one whose meaning can't be changed by the way it is used, as would normally happen with type inference
19:13:50 <ion> You’re declaring you accept any “first” of the caller’s choice but your code can’t fulfill that promise. It (as of now) requires first to be an instance of Read.
19:13:57 <geekosaur> in this case, the type signature says something specific about it (it is a type that the caller specifies)
19:14:10 <ion> Oh, sorry. It (as of now) requires first to be a String.
19:14:29 <ion> s/be a/be/
19:14:33 <geekosaur> so when you later try to give it a type, it complains that "type is specified by the caller" is rigidly specified and your function cannot override that by specifying a type
19:16:40 <Algebr> I don't understand why that matters, the type class says that makeAndModel returns MakeAndModel which is typedeffed to a String. Aren't I just fulfilling the process of the typeclass Machine?
19:17:29 <Algebr> promise*
19:18:36 <monochrom> you are saying, for the case of Electronics, makeAndModel :: Electronics first second -> String
19:18:42 <geekosaur> actually, hm, now that I load this, the problem is not quite that
19:18:55 <monochrom> ok, but that type does not say that you may use read.
19:19:23 <geekosaur> yes
19:19:35 <monochrom> "instance Read first => Machine (Electronics first second)" would allow you to use read
19:20:26 <geekosaur> actually I am not clear on why those need to be type variables
19:20:53 <Algebr> =/ doesn't compile with that instance Read first...
19:21:49 <ion> See my “Oh, sorry”. instance (first ~ String) => Machine (Electronics first second)
19:22:29 <ion> Or you could switch to show and then try to get the code to compile.
19:22:42 <ion> because that’s apparently what you actually want.
19:23:05 <monochrom> I see, ion is right
19:24:00 <Algebr> What I wanted to do was makeAndModel (Sony first second) = "your model is: " ++ first ++ " " ++ second
19:24:17 <Algebr> at least originally...
19:24:41 <monochrom> yeah, it's show, not read. and so it's instance (Show first, Show second) => Machine (Electronics first second)
19:25:10 <monochrom> and then it's "your model is: " ++ show first ++ ...
19:25:19 <ion> Perhaps get rid of the type variables altogether. data Electronics = Sony String Integer | …
19:25:53 <monochrom> nah, model is a number, and year is a string. Sony Integer String :)
19:26:07 <ion> heh
19:26:50 <ion> data Electronics = Device { manufacturer :: String, model :: String, year :: Integer }
19:26:52 <Algebr> When are type variables a good idea then? And whoa, I didn't know about the multiple...I guess that they called constraints?...for the (show first, Show second) => ..
19:26:56 <ion> or data Electronics = Device { manufacturer :: Manufacturer, model :: String, year :: Integer }
19:27:16 <Algebr> (Show first...)
19:27:47 <ion> algebr: “data List a = Nil | Cons a” lets the user of the list pick what type of elements to put into it.
19:28:01 <Algebr> ha, yea, I guess that's the canonical example.
19:28:01 <ion> Algebr: “data List = Nil | Cons Integer” forces the user of the list to use Integers only.
19:28:31 <ion> uh, “Cons a (List a)” and “Cons Integer List”
19:28:34 <erisco> I was hoping that template haskell would help with dependent types but it does not seem so... from what I can tell it is exclusive to manipulating syntax trees
19:28:56 <Algebr> thank you all :)
19:29:34 <erisco> some extensions help attain some features desired with dependent types ... are there plans for a more comprehensive extension?
19:30:47 <erisco> I desire stronger meta-programming capabilities :)
19:30:58 <monochrom> "I don't know what type to use for model, so I'll use a type variable" is a poor reason to use a type variable. unfortunately, most people do that.
19:31:58 <monochrom> "I know what types to use for model, in fact I know at least two, I will sometimes use one and sometimes use the other, and still I want to treat them somewhat uniformly, FSVO uniformly" is a valid reason to use a type variable.
19:34:11 <monochrom> this holds for every mechanism of generalization. for example, "I don't know, therefore I will use an OOP abstract class" is bad, "I know, but there are 5 possibilities, therefore I will use an OOP abstract class" is good.
19:34:57 <Algebr> What does FSVO mean?
19:35:05 <monochrom> for some version of
19:35:39 <bitemyapp> is there a seminearring typeclass that's nice?
19:36:14 <Algebr> monochrom: I've never actual had a case in rl that I've used an abstract base class, maybe I'm missing out on something.
19:39:10 <erisco> monochrom, is this to stop oneself from recursively generalizing all the assumptions you make?
19:39:37 <monochrom> no, it is to stop pulling generalizations out of one's ass
19:41:35 <monochrom> "I don't know, therefore I'll invent an abstract class" means that the abstract class is pulled out of one's ass, completely unsubstantiated. like, tautologically, "I don't know" = "if I emit something, it's out of my ass".
19:42:25 <monochrom> "I know these 5 possibilities" means that you will design your abstract class by referring to what's common among those 5 possibilities. it will be exactly right.
19:42:29 <erisco> well, is there necessarily harm in defining an abstract class versus a non-abstract class when you are not sure which is needed?
19:42:35 <erisco> why is one default better than the other?
19:44:21 <monochrom> yes, there is necessarily harm. any invention under not knowing how it will be used is almost surely be unfit for what it will be used.
19:45:28 <erisco> but if you are so unsure that you cannot say whether the class should be abstract or not, are you really protecting yourself against making an unfit design merely by choosing a non-abstract class?
19:45:47 <monochrom> think this. I ask you to write a program for me. I am not telling you what I want this program to do for now. you finish it first, then I'll tell. you. any chance you'll get my requirement right?
19:45:52 <erisco> in this vague hypothetical it would seem better to just go back to the drawing board and refrain from writing any code at all
19:46:37 <monochrom> no, you should invent neither an abstract class nor a concrete class. you should find out what are the possibilities.
19:47:54 <erisco> if I am understanding you now, we are agreeing that allowing for variability in your design is not a substitute for knowing the correct design in the first place?
19:48:06 <monochrom> yes
19:49:49 <bitemyapp> Alternative vs. a custom Seminearring typeclass: thoughts?
19:50:08 <monochrom> apples vs oranges
19:50:13 <bitemyapp> Alternative is too big.
19:50:18 <bitemyapp> my problem is just 0, +, *
19:50:24 <bitemyapp> and I guess R. Kind of.
19:50:43 <monochrom> here is why. Alternative has kind *->*. Seminearring has kind *.
19:50:46 <petrie> If I needed to do multiline string, I know I could use unlines but how could I go about concating a string to one of those lines in unlines?
19:51:11 <bitemyapp> monochrom: it's a grammar of And and Or in a rose-tree.
19:51:35 <erisco> petrie, you can use a backslash at the end of a line and a backslash at the start of the next line
19:51:42 <monochrom> does that refute my claim that Seminearring has kind *?
19:51:49 <erisco> petrie, (to define a multiline string)
19:52:11 <petrie> http://lpaste.net/1292470807439605760
19:52:16 <petrie> basically was trying to do something like this
19:52:42 <bitemyapp> monochrom: no, I'm providing input to try to figure out what makes sense for my problem.
19:52:49 <bitemyapp> details*
19:53:10 <bitemyapp> also why is Seminearring *?
19:53:18 <erisco> petrie, okay so first of all you do not need "do". that is only used for do-notation which is only relevant when you are interested in Monads (which are you not in this case)
19:53:26 <monochrom> similar to: Monoid is kind *
19:53:47 <bitemyapp> follow-up: Why is Alternative * -> *?
19:53:52 <petrie> Oi, hmm ok
19:54:03 <erisco> petrie, secondly, to call a function you do not use parentheses
19:54:12 <bitemyapp> I see that it iterally is * -> *
19:54:13 <monochrom> similar to: Applicative, Functor, Monad are all kind *->*
19:54:13 <erisco> ie  getContents(fp)  is just  getContents fp
19:54:45 <monochrom> here is what I mean. in "instance Functor x", x has kind *->*. in "instance Monoid y", y has kind *
19:54:50 <zRecursive> :k (->)
19:54:51 <lambdabot> * -> * -> *
19:54:59 <petrie> Ah, yes. Sorry I am not entirely sure why I had that.
19:55:06 <bitemyapp> Yeah.
19:55:11 <bitemyapp> I get your meaning now.
19:55:14 <erisco> petrie, as for your question, you can concatenate strings using ++, which you are already doing, so I am not sure what the difficulty is
19:55:19 <bitemyapp> I'm not using Alternative, my type is kind *
19:55:30 <bitemyapp> monochrom: that was instructive, thank you.
19:56:28 <petrie> I am getting some type mismatch errors and not entirely sure why
19:57:30 <erisco> petrie, I cannot tell because I do not know the definitions of strLn, getContents, and getFilename .. however if I was to guess, getContents returns in IO, so that would be a problem
19:58:05 <erisco> petrie, if you can post a more complete code sample plus the type errors we could help more
19:58:21 <petrie> Ah ok, yeah. Will do one moment.
19:58:23 <petrie> Thanks appreciate it
19:59:16 <petrie> http://lpaste.net/1668757973188476928
19:59:18 <petrie> all I have so far
20:02:16 <pavonia> petrie: Think about what the types of strLn and getFContents are, and why "strLn $ getFContents fp" fails then
20:02:40 <petrie> Sorry forgot to add the errors, added them.
20:04:02 <petrie> readFile just returns a String right? so strLn should return an Integer of the length of that string? no?
20:04:12 <pavonia> :t readFile
20:04:13 <lambdabot> FilePath -> IO String
20:04:39 <petrie> :|
20:04:57 <petrie> IO is becoming my worst enemy each time I try to make something >:|
20:06:01 <jmcarthur> You will eventually see that IO is your best friend.
20:06:41 <petrie> I hope so, right now we are not on very good terms.
20:07:51 <pavonia> Btw, strLn = length, but I guess that's for learning purpose?
20:09:02 <[swift]_> what's the meaning of the '<-' in this code? "getLibName [(_,clbi,_)] | LibraryName lname <- componentLibraries clbi !! 0 = pref </> mkStaticLib lname"
20:09:16 <carter> guess
20:09:20 <carter> bind
20:10:11 <[swift]_> so that code calls "componentLibraries clbi !! 0" and binds the result to "LibraryName lname"?
20:10:20 <[swift]_> didn't realize you could do that
20:12:17 <[swift]_> jeez it was hard to figure out the term for that feature
20:12:21 <[swift]_> looks like it's "pattern guards"
20:12:30 <pavonia> yes
20:13:22 <petrie> oops
20:14:05 <natefaubion> Hey, looking for some help getting cabal installed with a fresh ghc 7.8.1 install. rm'ed ~/.cabal and ~/.ghc but bootstrap.sh still complains trying to install parsec that it can't find libs even though the check at the beginning listed most things as being there
20:14:55 <natefaubion> maybe because ghc is in a custom location. bootstrap.sh seems partial to /usr/local/lib (i put ghc in /usr/local/ghc)
20:15:09 <natefaubion> tried setting prefix anyway I could (even hacked the file) and it still complains
20:16:11 <natefaubion> btw on mavericks with latest xcode command line tools
20:24:21 <srhb> Is there a pragma to hide a certain package?
20:25:10 <jfischoff> is there a new version of repa? Something built with repa-series maybe
20:26:30 <cwvh> srhb: yes, you can hide a package, or more cleanly (in my opinion) specify a package import
20:27:33 <cwvh> hiding => {-# OPTIONS_GHC -hide-package mtl #-}      specifying import =>  {-# LANGUAGE PackageImports #-} import "mtl" Control.Monad.Cont
20:28:02 <shachaf> I don't think you can do the former.
20:28:15 <cwvh> good
20:28:30 <srhb> Indeed, it does not like the former.
20:29:44 <srhb> The manual says that only dynamic flags can appear there.
20:30:21 <srhb> monads-tf keeps messing up my Flychecker
20:30:57 <shachaf> You could just uninstall monads-tf.
20:31:04 <shachaf> It will most likely do you no good.
20:31:17 <srhb> Must have been pulled in as a dependency somewhere..
20:33:18 <roboguy_> shachaf: wasn't monads-tf supposed to be the wave of the future at one point?
20:38:26 <srhb> Hm, how do I figure out which package pulled in monads-tf anyway?
20:44:09 <mindleyhilner> srhb: uninstall it
20:44:17 <mindleyhilner> srhb: threaten to uninstall it, rather
20:46:20 <om-foxy> I just installed ghc-7.8.1.  When I try and install the vector library, I get:
20:46:22 <om-foxy> Loading package primitive-0.5.2.1 ... <command line>: can't load .so/.DLL for: libHSprimitive-0.5.2.1.so (libHSprimitive-0.5.2.1.so: cannot open shared object file: No such file or directory)
20:46:33 <srhb> mindleyhilner: How do I do that in a sandbox?
20:46:40 <om-foxy> package primitive installs fine
20:47:00 <nh2> om-foxy: do you have `shared: False` in ~/.cabal/config?
20:47:22 <luite> om-foxy: you might be running a very old cabal-install, check cabal --version
20:48:21 <om-foxy> luite:
20:48:23 <om-foxy> # cabal --version
20:48:25 <om-foxy> cabal-install version 0.14.0
20:48:25 <om-foxy> using version 1.14.0 of the Cabal library
20:48:49 <nh2> om-foxy: then what luite says, upgrade to 1.18 or 1.19
20:48:55 <om-foxy> nh2:  I'm installing this package as root, where does the config file live in this case?
20:49:55 <srhb> Ah, figured it out. cabal sandbox hc-pkg unregister monads-tf -- apparently all of Snap seems to depend on it
20:50:02 <nh2> om-foxy: in the home of the user who runs cabal
20:50:22 <nh2> om-foxy: but the issue is what luite says in this case so no need to care about ~/.cabal/config yet
20:51:26 <om-foxy> ok, I've "cabal install cabal-install"ed 1.18.0.3 but I still get
20:51:27 <om-foxy> # cabal --version
20:51:29 <om-foxy> cabal-install version 0.14.0
20:51:30 <om-foxy> using version 1.14.0 of the Cabal library
20:51:57 <srhb> om-foxy: fix your path / hash -r
20:52:28 <srhb> om-foxy: You need $HOME/.cabal/bin to be before your system version.
20:53:10 <om-foxy> srhb: # echo $PATH
20:53:11 <om-foxy> /home/vivian/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
20:53:37 <om-foxy> I'm installing --global as root and "which cabal" gives me /usr/local/bin
20:53:45 <srhb> om-foxy: Don't do that.
20:54:41 <srhb> It tends to lead to all kinds of trouble
20:56:35 <srhb> om-foxy: If you really (really!) want to do that, you're probably better off grabbing some fresh ghc / cabal-install packages off the interwebs and frying your existing installation completely first.
20:56:53 <srhb> Then you can toss it all in /usr/local and things should work fine
20:58:28 <om-foxy> luite, nh2, srhb: thanks for your help!
20:58:39 <kfish> nh2, carter, what's the issue with haskell-src?
20:59:09 <carter> kfish: just cabal sdist with new happy / alex
20:59:21 <srhb> om-foxy: o/
20:59:28 <carter> 7.8.1 onwards has a Int# as Bool thingy
20:59:33 <carter> and new happy  / alex use it
20:59:42 <carter> for code when run on 7.8
20:59:48 <kfish> carter, can you upload a fixed version?
20:59:51 <carter> i could
21:00:02 <carter> but i'm about to get off my computer for 8+ hours
21:00:06 <nh2> kfish: ah hei!
21:00:07 <kfish> only cos nh2 mentioned you
21:00:14 <carter> cabal install happy alex
21:00:21 <carter> cd $haskell-src-dir
21:00:25 <carter> cabal sdist
21:00:28 <carter> cabal upload
21:00:38 <nh2> carter: he's offering to do the stuff for you in case you don't want to do it just on top of my post
21:00:46 <carter> nh2: i have admin acls
21:00:52 <carter> but i only use them if the maintainers can't
21:01:00 <nh2> carter: sorry I meant to write this to kfish
21:01:09 <nh2> kfish: he's offering to do the stuff for you in case you don't want to do it just on top of my post
21:01:09 <mindleyhilner> srhb: ghc-pkg unregister monads-tf
21:01:31 <srhb> mindleyhilner: cabal sandbox hc-pkg unregister monads-tf in fact -- but thanks, you led me on the right track. :)
21:01:35 <mindleyhilner> blah
21:01:38 <mindleyhilner> hc-pkg, yeah
21:01:41 <kfish> i have a good friend named alex, who is always happy
21:01:51 <carter> kfish: nh2  i just walked yah through all thats needed to do a good upload
21:01:53 <kfish> so i like doing "cabal install happy alex"
21:02:03 <srhb> I see in Github that they're killing off the monad-tf dependencies, so presumably it's gone soon.
21:02:04 <carter> oh and bump the minor minor number before you sdist
21:02:07 <srhb> Won't bother with it at least.
21:02:51 <nh2> kfish: is that happy alex alang? :D
21:02:56 <kfish> carter: ok, onto it
21:03:00 <carter> cool
21:03:15 <carter> all i know is pandoc works and has for months
21:03:16 <carter> :)
21:03:19 <kfish> nh2, ah, i have two always-happy friends called alex
21:03:20 <carter> i'm off to sleep
21:03:27 <mindleyhilner> night
21:03:31 <kfish> thanks carter
21:03:36 <carter> np
21:03:41 <carter> kfish: i did nothing
21:03:46 <carter> i just told you what to literally do!
21:04:12 <carter> enjoy :)
21:05:26 <nh2> kfish: I pinged in the thread because xhb depends on it and without it I can't brain-control my cursor with my EEG :D
21:09:04 <sgronblo> For a few days now I've been trying to figure out why I cant do cabal instal cabal-install
21:09:31 <carter> sgronblo: spellcheck!
21:10:11 <sgronblo> Trust me I did spell it correctly in the terminal
21:10:15 <kfish> carter, nh2 uploaded haskell-src-1.0.1.6
21:10:37 <carter> sgronblo: add ~/.cabal/bin to your path
21:11:06 * hackagebot haskell-src 1.0.1.6 - Support for manipulating Haskell source code  http://hackage.haskell.org/package/haskell-src-1.0.1.6 (ConradParker)
21:11:46 <srhb> We need a bot to recognize that problem :P
21:11:53 <carter> ?
21:11:56 <kfish> nh2, thanks for the ping
21:12:00 <srhb> Just a constant issue.
21:12:10 <sgronblo> carter: I dont have anything in ~/.cabal/bin yet
21:12:16 <carter> well
21:12:18 <carter> oh
21:12:21 <carter> are you on a mac?
21:12:33 <carter> did you install haskell platform at some point?
21:12:58 <kfish> nh2, can you confirm that haskell-src-1.0.1.6 builds with 7.8.1? then we can close that ticket
21:13:18 <nh2> kfish: builds
21:13:24 <sgronblo> which cabal -> /usr/local/bin/cabal
21:13:33 <carter> sgronblo: you didn't answer my question
21:13:36 <sgronblo> carter: and yeah im on a mac unfortunately
21:13:39 <carter> sgronblo: ok
21:13:43 <carter> do exactly the words i say
21:14:08 <Hermit> how can I find out which package is forcing a downgrade? http://lpaste.net/8361166122505994240
21:14:28 <kfish> nh2, carter thanks, closed #4
21:14:37 <nh2> kfish: thanks lah
21:14:53 <sgronblo> carter: yeah i did install haskell-platform through brew
21:14:55 <carter> rm ~/.cabal/config ; cabal install cabal-install ; cabal update ;  add ~/.cabal/bin to path ;  cabal install cabal-install
21:14:58 <carter> sgronblo: NO BREW
21:15:01 <carter> NO BREW
21:15:03 <carter> NO NONONONON
21:15:08 <carter> they do dumb shit
21:15:13 <kfish> nh2, np, how's the EEG?
21:15:19 <carter> i may have donated to their kick starter, but they do dumb shit
21:15:22 <sgronblo> carter: oh didnt know
21:15:33 <carter> soke
21:15:42 <carter> do what i say and you can move past that
21:15:51 <nh2> kfish: quite good, I recently gave a talk about it at Facebook at the Haskell "Fun in the afternoon" and some people quite liked it
21:16:03 <carter> sgronblo: anyways
21:16:11 <carter> first add ~/.cabal/bin to your path
21:16:24 <sgronblo> carter: but before that i should brew uninstall haskell-platform and then manually install haskell platform using some downloadable installer?
21:16:25 <carter> then rm ~/.cabal/config , then cabal install cabal-install
21:16:31 <carter> STOP
21:16:33 <kfish> nh2, great, just what we need: facebook monitoring our brain waves
21:16:35 <nh2> I still have to get around to the actual machine learning; can't do that quite yet because I'm working on my masters project but I took a really inspiring course so after the project I'm ready
21:16:43 <carter> why the hell does brew have haskell platform
21:16:47 <carter> you don't need haskell platform
21:16:49 <carter> you just need cabal
21:17:03 <sgronblo> i only need cabal?
21:17:09 <carter> and ghc
21:17:11 <carter> and stuff
21:17:22 <nh2> carter: where you are, is it also 5 am?
21:17:29 <carter> 1215am
21:17:40 <nh2> oh so convenient
21:17:51 <carter> sgronblo: so do literally the things i say
21:17:55 <carter> a) addd ~/.cabal/bin to path
21:18:01 <carter> b) rm ~/.cabal/config
21:18:05 <carter> c) cabal update
21:18:10 <carter> d) cabal install-cabal install
21:18:32 <carter> e) killl the brew stuff, dl an official ghc-hq binary install
21:18:34 <carter> open it
21:18:35 <carter> cd in
21:18:41 <carter> make install
21:18:47 <carter> you'll have cabal already
21:18:48 <carter> in path
21:18:59 <carter> and be abel to add whatever you need
21:19:08 <sgronblo> but its installed through brew right? is that still ok?
21:19:11 <carter> what is
21:19:15 <carter> do what i say
21:19:21 <sgronblo> cabal?
21:19:28 <carter> the directions i gave you
21:19:34 <srhb> sgronblo: No, your new cabal-install will be installed by cabal-install
21:19:37 <srhb> And yes, that is fine
21:19:48 <carter> ie srhb  is sayign "do what carter says"
21:19:50 <carter> :)
21:19:56 <srhb> I am, but with explamations ;)
21:19:59 <carter> yes
21:20:38 <carter> sgronblo: doing it?
21:20:59 <sgronblo> well yeah but the cabal that goes into my home would be installed by brews cabal, and that cabal seems to be having problems?
21:21:12 <carter> no, do what we say
21:21:26 <carter> and then use lpaste.net to share youre errors when things act funny
21:21:30 <sgronblo> carter: i really appreciate your help, but i would also like to understand why it needs to be installed a certain way.
21:21:33 <carter> nope
21:22:02 * carter has to walk too many ppeople through this to care :)
21:22:18 <srhb> sgronblo: Your broken installation can install a cabal-install that will work on your fixed installation after you fry everything but ~/.cabal and install a fresh GHC from GHC HQ
21:22:26 <carter> yes that
21:22:28 <carter> thanks srhb
21:22:41 <srhb> sgronblo: The point in doing it this way is such that you don't have to manually grab a cabal-install from the interwebs, which can be involving to build at times
21:22:54 <carter> yes that
21:23:10 <carter> a) addd ~/.cabal/bin to path
21:23:10 <nh2> carter: thanks for helping with the haskell-src, good night!
21:23:14 <carter> nh2: np
21:23:21 <sgronblo> ah so frying ~/.cabal/config should make it work?
21:23:24 <carter> yes
21:23:33 <srhb> sgronblo: well, that and all the other directions carter gave you
21:23:33 <carter> sgronblo: literally following my directions exactly
21:23:36 <carter> EXACTLY
21:23:39 <carter> no creativity
21:23:42 <carter> none
21:23:46 <srhb> carter: A bit of creativity in d)
21:23:48 <srhb> ;-)
21:23:59 <carter> oh
21:24:00 <carter> heheh
21:24:02 <carter> install-cabal
21:24:06 <carter> cabal install cabal-install
21:24:46 <srhb> Urgh, it's morning. I best go shower. bbiab
21:24:46 <sgronblo> but who screwed up the brew installation and why?
21:24:51 <carter> brew
21:24:52 <srhb> sgronblo: Probably Homebrew
21:24:55 <carter> srhb: we have to yell at them
21:24:57 <srhb> For god knows what reasons
21:25:08 <carter> sgronblo: we have to yell at them regularly
21:25:15 <carter> it helps i donated monay to them
21:25:24 <roboguy_> what's the problem with brew again?
21:25:29 <carter> they're ghetto
21:25:33 <sgronblo> maybe you need to send them pull requests instead?
21:25:37 <carter> nope
21:25:44 <carter> thats not the problem
21:25:51 <carter> its that they get creative
21:25:55 <carter> and add dumbshit
21:26:08 <tnks> I don't use a Mac, but Brew looked disgusting last I peered under the hood.
21:26:17 <carter> and every fucking time, i have to organize a fucking quorum to get them to change their stance
21:26:31 <carter> for really really realy basic stuff brew is great
21:26:41 <carter> but i will never trust them to bundle ghc / haskel lright
21:26:50 <tnks> makes sense.
21:26:54 <carter> haskell platform doesn't make sense decoupled from GHC
21:26:56 <carter> but thats how they do it
21:27:09 <carter> GHC + Cabal  + happy and alex is all you need
21:27:30 <carter> sgronblo: are you following my directions
21:27:34 <carter> what letter are you at
21:27:42 <mindleyhilner> such enthusiasm
21:28:08 <carter> mindleyhilner: i hate doing support
21:28:10 <carter> :)
21:28:26 <carter> mindleyhilner: you can take over for the rest of the week :)
21:28:29 <carter> deal?
21:29:26 <sgronblo> ok, cabal install cabal-install worked, by "offical ghc-hq binary install" you mean binary install of haskell-platform?
21:29:35 <carter> nOOOOOOO
21:29:40 <carter> google ghc haskell
21:29:42 <carter> first page
21:29:51 <sgronblo> I tried googling ghc-hq
21:29:52 <carter> got to the "donwlaod ghc 7.8"
21:29:54 <carter> nope
21:29:55 <carter> ghc haskell
21:30:01 <carter> not haskell platform
21:30:06 <carter> why haskell platform?
21:30:09 <sgronblo> arent people saying you should be installing the platform?
21:30:12 <carter> nope
21:30:14 <carter> i'm not
21:30:18 <carter> i'm saying do this
21:30:22 <carter> do you want 7.6 or 7.8?
21:30:26 <carter> lets do 7.8
21:30:28 <roboguy_> the official website says to install the platform. maybe that's not ideal though
21:30:35 <carter> its old
21:30:37 <carter> and weird
21:30:50 <carter> and the only point of HP is having cabal
21:30:52 <carter> which he has now
21:31:04 <carter> sgronblo: what do you hope to hack on?
21:31:21 <carter> runtime code gen compilation tools work better in 7.8
21:31:41 <sgronblo> i just wanted to try to follow a yesod tutorial and see what making a simple website using haskell is like
21:31:46 <carter> oh
21:31:50 <carter> get 7.6 then
21:32:00 <carter> i disagree with snoyman a bit, but he's nice
21:32:05 <carter> i favor snap and such
21:32:27 <sgronblo> what will i be missing out on by not installing the platform?
21:32:30 <carter> nothing
21:32:36 <carter> cabal install covers the rest
21:32:39 <sgronblo> i guess everything can be installed by cabal
21:32:54 <carter> honestly i prefer ghc 7.8
21:33:01 <carter> which i've been using for a few months
21:33:10 <carter> but i write math and compiler code gen stuff
21:33:25 <sgronblo> for everyday unsophisticated usage i probably wont notice that big a difference between 7.6 and 7.8?
21:33:33 <carter> for web stack tooling, whatever lib, 7.6 is slightly better if you wanna mess with webapps THIS WEEK
21:33:40 <carter> in a month, i'd say "go 7.8"
21:33:45 <carter> once the web stacks have stabilized
21:33:53 <sgronblo> i see, thanks for the advice
21:33:56 <carter> because 7.8 has MUCH better scaling on heavy workloads
21:34:03 <carter> i do give good advice
21:34:05 <luite> carter: bleh math and compiler code gen, boring ;)
21:34:08 <carter> luite: yes
21:34:24 <carter> luite: you do math and compiler codegen, IN haskell targetting js
21:34:30 <sgronblo> im just interested in what the workflow is like when you develop a webapp using haskell
21:34:43 <sgronblo> i work on nodejs/angular on a daily basis which make me sad
21:34:47 <carter> oh
21:34:48 <carter> purescript
21:35:06 <carter> sgronblo: if you dislike rales style, you'll get annoyed with yesdo
21:35:20 <carter> theres 3 choices yesod (the rails of haskell), happstack, and snap
21:35:24 <carter> they're all nice
21:35:27 <sgronblo> not sure i dislike rails style that much, but i despise dynamic typing.
21:35:28 <carter> and you can mix and match
21:35:32 <carter> well
21:35:42 <carter> if you want types and haskell and js
21:35:53 <carter> ghcjs ( luite's project)
21:35:56 <carter> or purescript
21:35:58 <carter> are boht nice
21:36:08 <carter> i'm tired
21:36:08 <sgronblo> theres so many of these projects now
21:36:11 <carter> yes
21:36:14 <carter> all using haskell!
21:36:15 <carter> :P
21:36:19 <carter> dont use haste
21:36:21 <carter> you'll get sad
21:36:24 <luite> hehe
21:36:24 <sgronblo> what about fay and umm what was it called
21:36:29 <carter> dont' care
21:36:31 <sgronblo> oh yeah haste! :)
21:36:32 <carter> i'm right
21:36:38 <sgronblo> haste makes you sad?
21:36:40 <carter> haste doesn't have tail calss
21:36:48 <carter> YOU'll get sad tryign to write tail call code
21:36:55 <carter> it has fake no tail call haskell
21:37:10 <luite> i'm working on updating the ghcjs-boot stuffs to work with the ghc 7.8.1 release atm
21:37:16 <carter> yay
21:37:41 <carter> sgronblo: i'm writing what i hope to beome defacto "Numerical Haskell"
21:37:43 <luite> and also some gnarly recursive top-level data init bug
21:37:49 <carter> FUN
21:38:00 <sgronblo> math is hard
21:38:03 <carter> nope
21:38:05 <carter> feelings are
21:38:06 <carter> :P
21:38:32 <carter> math is just frustratingly complex and inflexible in intellectually neat ways
21:38:45 <carter> and simple
21:38:53 <carter> math isn't hard
21:39:00 <carter> fixing ignorance is though
21:39:04 <carter> and i'm very very ignroant :)
21:39:11 <carter> and tired
21:39:59 <carter> sgronblo: part of why i'm writing numerical haskell is to make it easier to write super computer performance grade math in a high level way
21:40:05 <carter> sgronblo: did you finish following my directions?
21:40:47 <srhb> carter: What is this numerical haskell called?
21:40:57 <carter> numerical haskell
21:40:59 <carter> not on hackage yet
21:41:05 <srhb> Ah. :)
21:41:09 <carter> hope to announce alpha if i can focus for the next few days
21:41:10 * hackagebot yesod-auth 1.3.0.4 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.0.4 (MichaelSnoyman)
21:41:12 * hackagebot yesod-form 1.3.8.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.8.2 (MichaelSnoyman)
21:41:27 <sgronblo> carter: im DLing the ghc "bindist" right now
21:41:32 <carter> which version #
21:41:42 <sgronblo> i nuked haskell-platform and ghc using brew uninstall
21:41:55 <carter> did you add ~/.cabal/bin to path?
21:42:03 <carter> does cabal --version say "1.18"
21:42:13 <sgronblo> ghc-7.6.3-x86_64-apple-darwin.tar.bz2
21:42:17 <carter> srhb: if i don't help anyone on IRC for th next week, AT ALL, i might get stuff in public alpha
21:42:30 <srhb> carter: Exciting. I'll be watching. :)
21:42:44 <carter> srhb: you have to help the next newb :)
21:43:03 <srhb> Deal. :P
21:43:32 <carter> sgronblo: you too
21:43:35 <carter> share the knowledge
21:43:43 <bitemyapp> I'm getting a difference in results based on whether I run the main function of my hspec tests
21:43:44 <carter> so that i don't have to do grumpy 1am stuff
21:43:51 <bitemyapp> that breaks with a weird issue
21:43:51 <carter> bitemyapp: vs
21:43:52 <sgronblo> I seem to have some old cabal messing up things
21:44:01 <bitemyapp> but if I copy and paste the code into ghci, it works fine.
21:44:01 <srhb> sgronblo: Find it with which? :)
21:44:02 <carter> sgronblo: 'which cabal "
21:44:06 <carter> and KILL IT
21:44:14 <carter> bitemyapp:7.8 or 7.6
21:44:16 <bitemyapp> 7.8
21:44:20 <carter> c ffi or no?
21:44:20 <sgronblo> its /usr/bin/cabal
21:44:25 <carter> sgronblo: KIL IT
21:44:27 <sgronblo> why is it there???
21:44:29 <bitemyapp> carter: no FFI
21:44:29 <srhb> sgronblo: Homebrew is obviously not well.
21:44:35 <srhb> sgronblo: rm for the win
21:44:52 <srhb> I'm glad I don't have to deal with broken OS X stuff anymore.
21:45:06 <carter> srhb: its not broken when people don't use brew for haskell
21:45:10 <sgronblo> ok, there we go
21:45:23 <sgronblo> 1.18.03
21:45:28 <sgronblo> 1.18.0.3
21:45:31 <srhb> True enough, but I remember when they decided to completely mess up the entire build system because "lol, our paths are funnier than the standardized ones"
21:45:32 <carter> GOOOD
21:45:36 <srhb> That was painful.
21:45:40 <carter> srhb: which ones?
21:45:40 <bitemyapp> I think the error centers on: let queryFilter = BoolFilter (MustMatch (Term "user" "bitemyapp") False) <&&> IdentityFilter
21:45:47 <bitemyapp> or: let search = Search Nothing (Just queryFilter)
21:45:49 <srhb> carter: The entire XCode bundle, c compilers and all
21:45:51 <bitemyapp> in a do block.
21:45:55 <srhb> A few years ago now.
21:46:01 <carter> srhb: oh i ignore that
21:46:07 <carter> :)
21:46:20 <carter> helps that i have no clue how to write a gui  app
21:46:35 <sgronblo> oh man gotta head back to work
21:46:47 <sgronblo> thank you very much for the help and patience
21:46:55 <srhb> sgronblo: o/
21:47:00 <sgronblo> gotta continue this later tonight
21:47:11 <srhb> carter: Back then I don't think you could easily get a build system without installing XCode.
21:47:15 <srhb> It wasn't factored out until later.
21:47:24 <carter> CLI tools are nice
21:47:25 <carter> yeah
21:47:28 <carter> i remember
21:47:46 <bitemyapp> carter: search returns no hits if I invoke main or cabal test, returns the result in ghci if I copy and paste the code.
21:47:52 <bitemyapp> carter: if I invoke main from ghci, it doesn't work.
21:47:54 <bitemyapp> only works if I copy-paste.
21:48:17 <carter> HAI HEISENBUG
21:48:34 <Clint> the wonders of heisenbug
21:48:46 <bitemyapp> but seriously I have no idea how in the fuck this is happening.
21:49:05 <kfish> carter: didn't you go to sleep an hour ago?
21:49:16 <carter> kfish: i got sucked into playing support grunt
21:49:40 <carter> kfish: i'm going to be a dumbass on the libraries thread that snoymans on, then go to sleep
21:49:42 <carter> ngiht all
21:49:48 <carter> :)
21:51:16 <carter> ok, i explained to snoyman on the mailing list "CAs let you MITM SSL, -2"
21:51:56 <carter> i'm done
21:52:01 <carter> bitemyapp: happy bug smashing
21:52:06 * bitemyapp grumbles
21:52:10 <bitemyapp> this is a dumb bug.
21:52:14 <bitemyapp> it doesn't even make sense.
21:54:44 <bitemyapp> jfischof1: ever use Hspec?
21:57:57 <bitemyapp> code and problem description for what I think is an hspec problem: https://gist.github.com/bitemyapp/10343626
21:59:28 <augur_> hahaha
22:00:00 <augur_> this dope teaching berkeley's CS61C class for this one lecture said, in all seriousness, that higher order functions are good for map, filter, and not much else
22:00:25 <roconnor> :/
22:00:43 <bitemyapp> augur_: who the?
22:00:46 <bitemyapp> augur_: who is that?
22:01:03 <roconnor> augur_: also good for exhastively searching infinite compact spaces in finite time.
22:01:21 <augur_> alan christopher
22:01:27 <augur_> roboguy_: lol
22:02:15 <roboguy_> augur_: ?
22:02:22 <srhb> bitemyapp: Can you stick a type on the queryTweet?
22:02:22 <augur_> damnit
22:02:26 <augur_> roconnor*
22:02:36 <roconnor> Great Ideas in Computer Architecture
22:03:02 <srhb> I wouldn't dare mocking any of my CS profs for fear that they are.. Well, here.
22:03:05 <srhb> :-)
22:03:10 <roconnor> *l*
22:04:02 <roconnor> oh, alan is just a TA.
22:04:02 <augur_> srhb: fortunately hes not one of my profs :)
22:04:09 <augur_> im watching the CS61C videos
22:04:19 <Hermit> how can I find out which package is forcing a downgrade? http://lpaste.net/8361166122505994240
22:04:30 <Hermit> or how to solve this to keep the latest bytestring
22:05:23 * Hermit has been inspecting the .cabal of a couple of them, but they don't seem to force such downgrade
22:06:03 <roconnor> new kernel built
22:06:06 <roconnor> time to reboot.
22:07:03 <augur_> are there any low level VMs that can JIT compile to the actual machine?
22:08:58 <Hermit> llvm?
22:09:06 <Hermit> dynasm?
22:09:24 <zq> oh wow there's a new base
22:09:33 <zq> does this mean 7.8 is out
22:09:45 <augur_> zq: yeah havent you heard?
22:09:47 <zq> yes it does whoop
22:09:55 <zq> someone should update /topic
22:09:56 <dmj`> zq: yes
22:10:04 <augur_> Hermit: h,,
22:10:06 <augur_> hmm
22:10:19 <srhb> Hermit: I'm a bit puzzled as well
22:10:42 <Hermit> srhb: regarding the packages problem? Found a hint
22:10:44 <Hermit> trying to fix
22:11:01 <srhb> Hermit: Do share, if it works. :)
22:11:11 <dmj`> does anyone here use cabal sandboxes *and* haskell-mode?
22:11:19 <dmj`> for emacs
22:11:20 <srhb> dmj`: Yes
22:11:57 <dmj`> srhb: does C-c C-l (send file to inferior haskell) work well for you?
22:12:18 <srhb> dmj`: No, I use haskell-process-load-file for sandboxed projects
22:13:09 <srhb> None of it is particularly impressive, lots of bugs. But it sorta works most of the time. Ish.
22:13:21 <zq>  The monomorphism restriction is now turned off by default in GHCi.
22:13:25 <zq> how do i turn it back on
22:14:05 <dmj`> srhb: what is the benefit of haskell-process-load-file
22:14:06 <klugez> :set -XMonomorphismRestriction, I think.
22:14:11 <srhb> zq: Tried -XMonomorphismRestriction?
22:14:37 <srhb> dmj`: It has some sessioning stuff, keeping separate projects in separate cabal repl-instances
22:14:43 <srhb> dmj`: And, uh, it works with sandboxes.
22:14:48 <bitemyapp> can somebody tell me why this is behaving as if it were concurrent or something? https://gist.github.com/bitemyapp/10343626
22:15:01 <dmj`> I used to C-c C-l on any file back when I used hsenv and since ghci and my cabal dir were "global" to that directory, it worked fine
22:15:02 <shachaf> NomOnomOrphismRestriction
22:15:16 <srhb> shachaf++
22:15:46 <srhb> dmj`: Well, lots of breakage. The entire mode is rather ad-hoc.
22:16:19 <dmj`> srhb: the issue is that C-c C-l now loads ghci from the location of the file buffer. So sibling modules won't be loaded.
22:16:21 <schell> has anyone done a structured-haskell-mode for vim?
22:16:37 <bitemyapp> maybe this is laziness? that would be really strange though.
22:16:42 <zq> haskell.org/ghc/docs/7.8.1/html/users_guide/flag-reference.html it's there
22:16:53 <jle`> what does the lax in lax monoidal functors refer to
22:16:58 <jle`> for the definition of applicative
22:17:10 <srhb> dmj`: I can't help you with inferior-haskell. I tried to get it to work with sandboxes with all manner of hacks with no luck.
22:17:37 <jle`> oh is it that they are not invertible
22:18:19 <dmj`> srhb: going back to plain old ghci and reloading is like the dark ages
22:18:31 <srhb> dmj`: Then swith to haskell-process
22:20:02 <zq> @hoogle catchioerror
22:20:02 <lambdabot> No results found
22:20:18 <zq> why's hoogle not searching system.io.error?
22:21:16 <startling> shachaf, O no, orphism
22:21:37 <dmj`> srhb: what is the difference between that and inferior?
22:21:45 <startling> dmj`, srhb: I'd love a compelling solution too
22:21:47 <srhb> dmj`: I think I already said that
22:21:56 <srhb> dmj`: It has sessioning and works with sandboxes.
22:22:18 <srhb> startling: Short of rewriting haskell-mode from scratch I don't think any are forthcoming.
22:22:22 <dmj`> srhb: they both work with sandboxes, I'm unfamiliar with sessioning though
22:22:37 <srhb> dmj`: Er.. Okay. Then I must have misunderstood your problem
22:22:44 <srhb> dmj`: Please explain it again
22:22:46 <startling> dmj`, haskell-inf-mode works with sandboxes?
22:23:03 <srhb> News to me, too.
22:23:51 <startling> srhb, haskell-process-load-file looks good, thanks !
22:23:54 <dmj`> startling: If I invoke emacs at my root directory where the cabal file is located and C-c C-l it will attempt to run ghci using "cabal repl"
22:24:05 <startling> dmj`, how'd you manage that?
22:24:08 <srhb> dmj`: How'd you get it to do that?
22:24:10 <bitemyapp> I really need help with this.
22:24:13 <srhb> Mine certainly does not.
22:24:14 <bitemyapp> I'm not getting any traction on it.
22:24:20 <bitemyapp> this hspec test is behaving really strangely.
22:24:35 <bitemyapp> startling: would you be willing to take a look?
22:24:38 <dmj`> startling, srhb: It only works at the root, and doesn't respect the project
22:24:47 <srhb> dmj`: It doesn't even do that to me.
22:24:52 <startling> bitemyapp: are you using the threaded runtime?
22:24:58 <bitemyapp> startling: it's cabal repl.
22:25:13 <srhb> dmj`: Anyway, haskell-process-load-file does solve those issues.
22:25:15 <bitemyapp> so, not as far as I know.
22:25:16 <startling> bitemyapp: it works in ghci but not cabal repl?
22:25:24 <bitemyapp> startling: no, let me explain
22:25:37 <bitemyapp> startling: I can get the main tests to work properly if I remove insertData from the test stanza
22:25:42 <bitemyapp> startling: if I pre-insert the data myself.
22:25:44 <startling> ugh, cabal isn't in my path somehow
22:25:50 <startling> *emacs path
22:25:54 <bitemyapp> startling: separately, in the repl.
22:26:01 <startling> bitemyapp: oh, I see.
22:26:03 <bitemyapp> startling: but if insertData is in the test stanza or main anywhere, the test breaks.
22:26:21 <bitemyapp> it's behaving as if it was executing only half of insertData, but not the rest (data missing)
22:26:22 <startling> bitemyapp: what is the bad behavior you're seeing?
22:26:40 <bitemyapp> startling: it's behaving as if insertData deleted the index, but didn't insert the new data.
22:26:51 <startling> bitemyapp, what is the bad behavior you're seeing?
22:27:10 <bitemyapp> startling: search results are empty, a json []
22:27:33 <bitemyapp> they aren't if I pre-insert the data and rerun without the insertData invocation.
22:27:39 <bitemyapp> on line 29.
22:27:56 <dmj`> srhb: do you get, "Can't find the prompt" ever?
22:27:57 <bitemyapp> I can just push what i have to github.
22:28:11 <startling> bitemyapp: might try sticking Debug.trace.trace everywhere. I could probably give more feedback if I could run it.
22:28:14 <srhb> dmj`: With haskell-process, no
22:28:20 <srhb> dmj`: With inferior-haskell yes.
22:28:30 <bitemyapp> startling: github.com/bitemyapp/bloodhound/
22:28:42 <srhb> dmj`: Maybe you should just try it out and see for yourself. :)
22:28:59 <bitemyapp> startling: I added a print "test" right before the end of insertData and it printed.
22:29:02 <bitemyapp> test still failed.
22:29:18 <bitemyapp> startling: it executes the entirety of insertData, but seemingly not until after the test assertion fails.
22:29:32 <dmj`> srhb: I am trying it out, do you call haskell-process-load-file on each new file buffer?
22:29:42 <srhb> dmj`: Yes.
22:29:47 <bitemyapp> startling: so the data *does* get inserted, but the test query executes against an empty search index.
22:29:59 <srhb> dmj`: And then choose the existing session if appropriate
22:30:34 <startling> bitemyapp: I don't know any of these libraries well enough to know what to debug, sorry
22:30:47 <bitemyapp> startling: is it possible laziness could somehow induce this behavior?
22:30:55 <bitemyapp> startling: I know hspec has a scheduler of some sort.
22:31:12 <startling> I'm not comfortable answering that question.
22:31:15 * hackagebot language-c 0.4.4 - Analysis and generation of C code  http://hackage.haskell.org/package/language-c-0.4.4 (BenediktHuber)
22:31:40 <bitemyapp> startling: well thanks for taking a look.
22:31:56 <bitemyapp> startling: it doesn't involve hspec.
22:32:01 <bitemyapp> startling: I removed hspec and repro'd the problem
22:32:11 <bitemyapp> startling: so we're only really talking about http-conduit.
22:32:15 <bitemyapp>   _ <- insertData
22:32:15 <bitemyapp>   myTweet <- queryTweet
22:32:15 <bitemyapp>   print myTweet
22:32:19 <bitemyapp> that reproduces the problem.
22:32:26 <bitemyapp> in a plain old main = do
22:32:39 <bitemyapp> removing insertData fixes it again.
22:33:42 <dmj`> srhb: shouldn't locally defined .ghci files override the global .ghci file? My idea is to include my project root directory into ghci's load path, then when cabal repl is invoked on inferior-haskell it will still load everything, not just the current file buffer
22:34:26 <dmj`> well well
22:34:26 <dmj`> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/ghci-dot-files.html
22:34:35 <srhb> dmj`: I have no idea.
22:34:46 <startling> bitemyapp: that is a lot of dependencies
22:35:01 <Hermit> srhb: Fixed! \o/  Problem was my own wacky installation (build latest git ghc a couple of weeks ago, under windows). In detail, there were two Win32-2.3.0.2, the builtin one that deppended on bytestring 0.10.2.0, and the later installed one that deppended on 0.10.4.0. Why the hell it would not override the builtins with the cabal-installed ones, is something that I've yet to find an answer for
22:35:16 <srhb> Hermit: Aha, okay. :)
22:36:01 <bitemyapp> startling: only http-conduit and Aeson are relevant at the moment, but http-conduit and my code itself are the likely candidates.
22:36:16 * hackagebot cabal-db 0.1.8 - query tools for the local cabal database (revdeps, graph, info, search-by, license, bounds)  http://hackage.haskell.org/package/cabal-db-0.1.8 (VincentHanquez)
22:36:17 <startling> bitemyapp: I'm just double-checking that I get the same behavior here
22:36:55 <startling> srhb, I get a lot of "The Haskell process `...' has died. Restart? (y or n)" when I haskell-process-load-file
22:37:01 <bitemyapp> startling: do you have elasticsearch installed?
22:37:10 <srhb> startling: Does cabal repl actually work in that project?
22:37:13 <bitemyapp> startling: it's going to smash index twitter, type tweet.
22:37:36 <startling> bitemyapp: ah, I think that's a little more effort than I feel like putting in. sorry. :(
22:37:45 <bitemyapp> startling: you don't have to configure it
22:37:57 <bitemyapp> startling: just download, unpack the zip, run ./bin/elasticsearch
22:38:02 <startling> bitemyapp, I can recommend a certain CI solution, though ...
22:38:06 <bitemyapp> startling: I know you have java installed already.
22:38:28 <dmj`> startling: I don't blame you
22:38:35 <bitemyapp> startling: http://www.elasticsearch.org/overview/elkdownloads/
22:38:48 <startling> bitemyapp, sorry, I've got a little too much to do tonight.
22:38:58 <bitemyapp> startling: well. thanks anyway.
22:39:41 <startling> srhb: oh, heh, I don't have a cabal file here
22:39:46 <srhb> startling: :-)
22:40:01 <srhb> startling: It's for them sandboxes.
22:40:32 <startling> I wonder if I can make it work with "ghci -package-db ..."
22:41:20 <srhb> Why oh why would you. :P
22:41:32 <srhb> cabal repl is the greatest thing since.. Well, real sandboxes.
22:41:35 <srhb> :-)
22:42:58 <startling> srhb, right, that still uses sandboxes, it just doesn't do hiding and doesn't break horribly if parts of the project don't compile
22:44:06 <srhb> Hadn't thought of that. I guess my projects are sufficiently small that I just throw undefined at it till it plays nice. :P
22:46:41 <bitemyapp> startling: adding a threadDelay made it work.
22:46:51 <bitemyapp> there's something about http-conduit I am not grokking here.
22:47:08 <startling> bitemyapp: I guess so.
22:50:25 <startling> srhb: this is nice. why isn't this better-publicized?
22:50:43 <bitemyapp> startling: sandboxes or cabal repl?
22:50:54 <startling> bitemyapp, haskell-process-load-file in emacs
22:51:02 <startling> the ordinary haskell emacs thing doesn't work with cabal repl
22:51:28 <bitemyapp> startling: which mode is haskell-process-load-file in? inferior-haskell?
22:51:39 <srhb> startling: Well, the breakage I guess. chrisdone did actually publicize it quite a bit at the time.
22:51:48 <startling> bitemyapp, haskell-mode
22:51:56 <startling> ah, chrisdone
22:52:07 * startling adds to the list of things he uses written by chrisdone
22:52:58 <srhb> startling: indeed. :-)
22:54:07 <dmj`> startling: when you call haskell-process-load-file are you specifying your global cabal at ~/.cabal/bin/ ?
22:54:33 <startling> dmj`: (setq exec-path (append exec-path '("~/.cabal/bin")))
22:57:09 <startling> I wonder why I don't have haskell-process-insert-type
22:57:11 <startling> https://github.com/haskell/haskell-mode/blob/master/haskell-process.el#L285
22:57:51 <srhb> startling: Old version?
22:58:38 <startling> srhb: I'm using the newest version of haskell-mode on melpa
22:58:46 <srhb> startling: Hm.
22:59:21 <srhb> Not sure if mine is from Marmelade.
22:59:43 <startling> I think melpa uses github anyhow?
22:59:49 <srhb> Ah.
22:59:57 <srhb> I never knew.
23:00:02 <srhb> You should have it for sure then
23:00:45 <srhb> startling: Ah wait, it's haskell-process-do-type now, isn't it
23:01:12 <srhb> I have a (lambda () (interactive) (haskell-process-do-type t))
23:01:19 * hackagebot thyme 0.3.3.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.3.0 (LiyangHu)
23:01:24 <srhb> Which I guess should really be haskell-process-insert-type... :-)
23:02:01 <startling> srhb: ah, apparently it's (haskell-process-do-type t)
23:02:29 <startling> I wonder if there's some keybindings out there for this
23:02:29 <srhb> Indeed.
23:02:34 <srhb> Not by default
23:02:39 <srhb> You have to set those yourself
23:03:24 <startling> @tell chrisdone do you have some keybindings for haskell-process I can copy?
23:03:24 <lambdabot> Consider it noted.
23:04:09 <srhb> startling: http://haskell.github.io/haskell-mode/manual/latest/#haskell_002dinteractive_002dmode
23:04:17 <srhb> startling: https://github.com/chrisdone/chrisdone-emacs/blob/master/config/haskell.el
23:04:27 <startling> :)
23:04:46 <dmj`> inferior haskell would work if it knew how to find the projects root directory
23:05:07 <srhb> dmj`: That's what I thought, so I adviced it with a root-finding bit and it was still horribly broken
23:05:28 <dmj`> :(
23:05:46 <srhb> Anyway, I don't really see the appeal of it over the other mode.
23:05:53 <srhb> I only use it for standalone .hs-files
23:08:07 <bitemyapp> AFAICT, my issue is insertData running requests concurrently.
23:09:24 <startling> bitemyapp: I think your issue is that you don't know how to block until a request finishes succeeds
23:10:09 <dmj`> srhb: the only appeal is C-c C-l is quicker than M-x haskell-load-process-file
23:10:24 <dmj`> I guess I could rebind..
23:10:31 <srhb> dmj`: That's what I have
23:10:32 <startling> dmj`: http://haskell.github.io/haskell-mode/manual/latest/#haskell_002dinteractive_002dmode
23:10:53 <srhb> dmj`: C-u C-c C-l for inferior haskell, C-c C-l for haskell-load-process-file
23:11:25 <zRecursive> How to upgrade haskell-mode ?
23:11:43 <bitemyapp> startling: possible.
23:11:56 <bitemyapp> startling: but I can print the result
23:11:59 <zRecursive> which installed by 'package-install
23:12:07 <dmj`> where do links like this come from? kind of angry... C-h m, and haskell-customize don't help much
23:12:17 <bitemyapp> startling: I tried seq'ing to no avail.
23:12:18 <startling> dmj`: they come from srhb
23:12:23 <dmj`> ah I see :P
23:12:44 <startling> C-h m is sadly useless
23:12:58 <srhb> zRecursive: package-list-packages, U x
23:13:00 <bitemyapp> wait a tick
23:13:10 <srhb> zRecursive: If a new version is available
23:13:11 <bitemyapp> I think I got it?
23:13:17 <dmj`> this can't be latest, I have 13.10 installed
23:13:29 <dmj`> unless the docs are just old
23:13:30 <bitemyapp> yeah, I got it.
23:13:41 <srhb> bitemyapp: What was the issue? Too much lazy?
23:14:08 <startling> I don't think laziness is the thing.
23:14:21 <startling> well, it's not the whole thing.
23:14:46 <bitemyapp> srhb: I just re-expanded the example, it breaks again.
23:14:56 <zRecursive> srhb: what's "U x" ?
23:15:14 <srhb> zRecursive: U is mark all packages with newer versions for installation, x is execute the marked actions
23:15:31 <srhb> zRecursive: I think it says as much in the minibuffer.
23:15:58 <dmj`> its like a new haskell-mode comes out everyday
23:15:59 <dmj`> haskell-mode-20140408.116
23:16:14 <startling> dmj`, it's checks github
23:16:48 <zRecursive> srhb: you mean pressing U in the output of 'package-list-packages ?
23:18:29 <dmj`> oh emacs lisp
23:18:51 <srhb> zRecursive: Yes
23:20:04 <zRecursive> In *packages*, pressing U seems no effect ?
23:20:28 <srhb> Maybe you have an older version.
23:20:37 <srhb> C-h k U ?
23:20:57 <zRecursive> U is undefined
23:21:02 <srhb> Indeed, older version then
23:22:33 <srhb> :t sans
23:22:34 <lambdabot> At m => Index m -> m -> m
23:22:49 <srhb> What on earth does that do...
23:23:19 <srhb> Oh, removes that one item?
23:23:36 <supki> > sans 1 (M.fromList [(1,2), (3,4)])
23:23:38 <lambdabot>  fromList [(3,4)]
23:23:42 <srhb> Aye, got it
23:24:18 <el_monad> @pl zipWith (\x (y, z) -> (x, y, z))
23:24:18 <lambdabot> zipWith ((`ap` snd) . (. fst) . (,,))
23:25:12 <ecrireducafe> @pl \a b -> g (f a) (f b)
23:25:12 <lambdabot> (. f) . g . f
23:27:34 <startling> > view (sans 1) (M.fromList [(1, 2), (3, 4)])
23:27:35 <lambdabot>  No instance for (GHC.Show.Show a0)
23:27:35 <lambdabot>    arising from a use of ‘M471640849744286722316702.show_M4716408497442867223...
23:27:35 <lambdabot>  The type variable ‘a0’ is ambiguous
23:27:35 <lambdabot>  Note: there are several potential instances:
23:27:35 <lambdabot>    instance [safe] GHC.Show.Show
23:29:24 <srhb> > view (at 1) $ M.fromList [(3,2),(1,7)]
23:29:26 <lambdabot>  Just 7
23:29:30 <srhb> That reads so nicely
23:29:52 <startling> yeah.
23:31:31 <quchen> Does the ":shows" command work for anyone else? GHCi tells me it's an unknown command. Should I file a bug report?
23:31:35 <quchen> (7.8)
23:32:52 <c_wraith> I've never heard of that command
23:33:26 <quchen> c_wraith: New in 7.8,  "The new :shows paths command shows the current working directory and the current search path for Haskell modules."
23:33:41 <c_wraith> no wonder I've never heard of it
23:33:50 <startling> quchen: doesn't work for me
23:34:04 <srhb> It's so new it isn't even in yet!
23:34:06 <startling> quchen: looks like a type tbh
23:34:34 <startling> quchen: aha, it's :show paths
23:34:40 <quchen> startling: Ah, there's a "showi" command
23:35:11 <startling> *typo, ironically
23:36:11 <quchen> Hm you're right, the 's' is simply too much. I guess I should just file a patch. Of one character. Weee
23:36:18 <startling> :D
23:36:23 * hackagebot fedora-packages 0.0.3 - Haskell interface to the Fedora Packages webapp API.  http://hackage.haskell.org/package/fedora-packages-0.0.3 (RickyElrod)
23:36:29 <quchen> On the other hand you can't even patch that because it changes the entire release haha
23:36:41 <quchen> Nevermind. I have no idea how to proceed.
23:37:01 <quchen> 7.8.2: fixed a type in the docamentation
23:37:19 <dmj`> srhb: when interactive process asks for cabal dir is it asking for the cabal file dir or the executable ir
23:37:19 <dmj`> dir
23:37:34 <srhb> dmj`: Your project's cabal dir.
23:37:48 <srhb> dmj`: It should already have figured it out if you just press enter
23:37:50 <startling> quchen, then I get to
23:37:57 <startling> release 7.8.3!
23:38:48 <dmj`> srhb: Ok, it still says it can't find some modules, yet cabal install works
23:39:19 <srhb> Sounds odd. I have no issues with it
23:39:35 <dmj`> my directory structure is pretty flat
23:39:56 <dmj`> hold on, I'll paste stuff
23:40:20 <srhb> view (at i ??? foo) ps -- what do I put in for ??? foo if I want to dive into a lensy record field that may be returned at that index?
23:40:41 <startling> srhb, .
23:40:57 <startling> > view (at 1 . _1) $ M.fromList [(1, (2, 3))]
23:40:58 <lambdabot>  Could not deduce (Control.Lens.Tuple.Field1
23:40:59 <lambdabot>                      (Data.Maybe.Maybe (t0, t1)) (Data.Maybe.Maybe (t0, t1)) ...
23:40:59 <lambdabot>    arising from the ambiguity check for ‘e_111123’
23:40:59 <lambdabot>  from the context (Control.Lens.Tuple.Field1
23:40:59 <lambdabot>                      (Data.Maybe.Maybe (t, t2)) (Data.Maybe.Maybe (t, t2)) a a,
23:41:07 <startling> sigh.
23:41:21 <shachaf> The trouble is that there might not be a value at i.
23:41:23 <startling> oh, right
23:41:33 <startling> > preview (at 1 . traverse _1) $ M.fromList [(1, (2, 3))]
23:41:34 <lambdabot>  Couldn't match type ‘Control.Applicative.Const
23:41:34 <lambdabot>                         (Data.Monoid.First a) (a0 -> Data.Maybe.Maybe t0)’
23:41:34 <lambdabot>                with ‘a -> Control.Applicative.Const (Data.Monoid.First a) a’
23:41:34 <lambdabot>  Expected type: (a
23:41:34 <lambdabot>                  -> Control.Applicative.Const (Data.Monoid.First a) a)
23:41:36 <shachaf> So there are two changes you need to make.
23:41:38 <srhb> shachaf: Can't it just pretend Maybe is a Monad? :-)
23:41:49 <shachaf> Monads have nothing to do with it.
23:41:55 <srhb> Nothing >>= ...
23:41:56 <startling> > preview (at 1 . traverse . _1) $ M.fromList [(1, (2, 3))]
23:41:58 <lambdabot>  Just 2
23:42:07 <startling> there's probably a better way.
23:42:10 <shachaf> startling: (at i . traverse) is called (ix i)
23:42:17 <startling> shachaf: ah, right
23:42:27 <startling> shachaf: (I don't believe you. :) )
23:42:37 <shachaf> ?
23:43:04 <shachaf> > preview (ix 1 . traverse) $ M.fromList [(1, ('a', 'b'))]
23:43:06 <lambdabot>  Just 'b'
23:43:12 <startling> :t ix 1
23:43:13 <lambdabot> (Ixed m, Applicative f, Num (Index m)) => (IxValue m -> f (IxValue m)) -> m -> f m
23:43:19 <startling> :t (at 1 . traverse)
23:43:20 <lambdabot> (At m, Applicative f, Num (Index m)) => (IxValue m -> f (IxValue m)) -> m -> f m
23:43:20 <shachaf> Er, . traverse wasn't what I meant to say.
23:43:40 <shachaf> startling: There's an Ixed law that they must be equal.
23:43:50 <startling> shachaf: ah, I didn't know about that.
23:43:57 <dmj`> srhb: oh snap, it worked
23:44:01 <shachaf> You'll notice how they both use IxValue.
23:44:06 <startling> yeah.
23:44:12 <dmj`> srhb: I needed my project dir to be ~/Project/src
23:44:24 <shachaf> When answering lens questions please double-check your answer in /msg lambdabot to make sure there isn't a type error.
23:44:25 <srhb> dmj`: Isn't that specified in the cabal file?
23:45:05 <bitemyapp> startling: refresh
23:45:15 <shachaf> srhb: You should know what a traversal is to use that solution, though.
23:45:38 <startling> shachaf, will do
23:45:47 <srhb> shachaf: Indeed. I won't. Better to use a case for my usage. I was hoping there was a nicer way to "do something" if there was a Just foo in there.
23:45:53 * startling 's lenses are rusty
23:45:57 <dmj`> srhb: yes
23:46:04 <srhb> dmj`: Righto. :)
23:46:04 <shachaf> startling: (That was a sort of a joke about lens.)
23:46:05 <startling> srhb: what do you want to do?
23:46:24 * hackagebot copr 1.1.1 - Haskell interface to the Fedora Copr system  http://hackage.haskell.org/package/copr-1.1.1 (RickyElrod)
23:46:46 <dmj`> srhb: I don't have any .hs files at the root directory where the cabal file is
23:46:50 <dmj`> everything is in src
23:47:09 <dmj`> I'm assuming I need to invoke M-x haskell-interactive-mode at the root tho...
23:47:11 <srhb> startling: fromMaybe someString (view (at i) someMap ??? stringyLensyField)
23:47:42 <srhb> dmj`: I just use haskell-process-load-file on whichever source file in a given project I'm visiting
23:48:20 <bitemyapp> startling: t'was index refresh.
23:48:37 <startling> > fromMaybe "srhb" $ preview (ix 1 . _1) (M.fromList [(1, ("string", False))])
23:48:39 <lambdabot>  "string"
23:48:50 <srhb> Oh.
23:49:04 <srhb> I need to look up preview.
23:49:16 <startling> srhb: it's like view but for things that may not only have one target
23:49:20 <pharaun> @pl foo a b = a == bar b
23:49:20 <lambdabot> foo = (. bar) . (==)
23:49:25 <pharaun> gross
23:49:29 <srhb> I see.
23:49:35 <startling> srhb: (or may not have have any target)
23:49:38 <shachaf> You need to look up traversals.
23:49:41 <startling> ^
23:49:43 <srhb> Roger.
23:49:47 <shachaf> Traversal might be the most important type in lens.
23:49:54 <dmj`> srhb: I'm so happy, muchas gracias
23:50:04 <srhb> dmj`: Thank chrisdone :)
23:50:17 <dmj`> always wondered what that whole haskell-interactive-business was about
23:50:36 <dmj`> he's not online :P
23:50:53 <dmj`> haskell-interactive-mode business*
23:55:27 <jle`> pharaun: if you can reverse it
23:55:34 <jle`> (== a) . bar
23:55:37 <jle`> might be ok
23:56:08 <pharaun> that version is alright
23:56:11 <jle`> *if you're willing to keep a point
23:56:49 <srhb> > fromMaybe "404" $ (M.fromList [(1,("someString",2))] ^? ix 1 . _1
23:56:51 <lambdabot>  <hint>:1:66:
23:56:51 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:56:51 <jle`> i think dropping more than one point is, except for some trivial cases, pretty hard to read
23:56:52 <srhb> baw
23:56:55 <jle`> mostly because of the nature of (.)
23:56:59 <srhb> > fromMaybe "404" $ (M.fromList [(1,("someString",2))]) ^? ix 1 . _1
23:57:01 <lambdabot>  "someString"
23:57:08 <srhb> Huzzah!
23:57:23 <srhb> so ^? is basically preview
23:57:35 <c_wraith> it's exactly preview
23:57:51 <srhb> modulo flip
23:57:55 <ReinH> maybe flip preview?
23:58:52 <dmj`> @typ flip maybe preview
23:58:53 <lambdabot> MonadReader s m => m (Maybe a) -> Maybe (Getting (First a) s a) -> m (Maybe a)
23:59:37 <srhb> Hmm
