00:02:49 <Total_1mmersion> Is it even possible to construct a parameterized data type which allows nesting of itself in the parameter? For example, a data type "Tag", where each of these are valid: Tag Nothing; Tag (Just $ Tag Nothing); Tag []; Tag [Tag []]
00:05:34 <solrize>  Iavor Diatchki is working on utilizing an off-the-shelf SMT solver in GHC's constraint solver. Currently, the main focus for this is improved support for reasoning with type-level natural numbers,
00:05:36 <solrize> !@
00:05:50 <solrize> anyone know which solver?
00:09:30 <Feuerbach> Total_1mmersion: data Tag a = Tag (Tag a) | V a
00:09:42 <Feuerbach> Tag (Tag (V Nothing))
00:10:01 <Feuerbach> (this is a free monad over the identity functor)
00:10:31 <Feuerbach> or data Tag a = Tag a
00:10:37 <Feuerbach> (the identity functor itself)
00:10:51 <Feuerbach> in the former case the type will remain the same independent of the nestedness
00:10:59 <Feuerbach> in the latter case it'll grow
00:14:54 <Total_1mmersion> Feuerbach, I don't think that supports Tag (Just $ Tag Nothing), nor Tag [Tag []]
00:16:20 <Mon_Ouie> Do you just want data Tag m = Tag (m (Tag m)) ?
00:16:29 <Feuerbach> Tag (Just $ Tag Nothing) :: Tag (Maybe (Tag (Maybe a)))
00:16:34 <supki> Total_1mmersion: see Fix from recursion-schemes
00:16:35 <Feuerbach> with Tag a = Tag a
00:17:50 <Feuerbach> Total_1mmersion: what type do you want such a value to have?
00:18:24 <Feuerbach> and, most importantly, what are you trying to achieve? ;)
00:19:59 <Total_1mmersion> I'm trying to make a list of assembly instructions which can refer to each other through the ST monad. For example, the Add instruction might be something like Add (STRef s Instruction) (STRef s Instruction)
00:20:58 <Total_1mmersion> I also want to be able to convert that list of Instructions of STRefs to Instructions of Integers (to pull it out of the ST monad and print it)
00:22:17 <Total_1mmersion> Where each Integer represents the index in the list, or some index which is contained in the Instruction data type. Something like: data Instruction ref = Add ref ref
00:22:34 <Total_1mmersion> It would be cool if I could have Add 3 4 as well
00:23:12 <Total_1mmersion> But I can't figure out how to get the types to work with both ref=STRef s Instruction and ref=Int
00:24:18 <Total_1mmersion> Because Instruction must be parameterized, it seems to be infinitely recursive: Instruction (STRef s (Instruction (STRef s .. )))
00:27:45 <Feuerbach> so, write it in the form data Instruction a = Add a a | ...
00:28:08 <Feuerbach> then the integer instantiation is Instruction Int
00:28:18 <Feuerbach> and recursive instantiation is Fix Instruction
00:28:41 <Feuerbach> where newtype Fix f = Fix (f (Fix f))
00:29:10 <Feuerbach> or, more directly, newtype Instruction' = Instruction' (Instruction Instruction')
00:51:38 <Total_1mmersion> Hmm, I'm not sure how to actually use Fix now. I am getting an infinite type error with this code:
00:51:41 <Total_1mmersion> data Instruction a = Instruction Int (Op a)
00:51:46 <Total_1mmersion> data Op a = Literal Int | Add a a
00:51:55 <Total_1mmersion> mapI f (Instruction i (Literal v)) = Instruction (succ i) (Literal v)
00:52:01 <Total_1mmersion> mapI f (Instruction i (Add a b)) = Instruction (succ i) (Add (mapI f a) (mapI f b))
00:53:02 <Total_1mmersion> Error: cannot construct infinite type: a0 = Instruction a0 In the return type of a call of `mapI' (mapI f a)
00:53:17 * hackagebot tn 0.1.0.1 - A journaling program for Linux  http://hackage.haskell.org/package/tn-0.1.0.1 (pharpend)
01:01:26 <pavonia> Total_1mmersion: You have to wrap it in Fix, unwrap in the pattern match and re-wrap in the result, I think
01:20:32 <Feuerbach> Total_1mmersion: pavonia is right. Fix is an ordinary data type. Pay attention to what types you pattern match on. GHC's typed holes can be of great help here, too.
01:21:55 <Total_1mmersion> I am really confused =/ I don't understand how this allows me to have Instructions of STRefs of Instructions of ..
01:23:15 <Total_1mmersion> So far I have only gotten it to work for Instructions of Instructions .. using pattern matching
01:27:01 <dreixel> ocharles: yes, but UndecidableInstances are fine. In my world, at least. If you're not doing anything undecidable at the type level, you're not doing anything interesting :P
01:28:18 <mikusp> hi. i'm trying to write a dependency resolver in haskell and i need an idea how to make it work.
01:28:58 <Feuerbach> Total_1mmersion: something like newtype Instr'' s = Instr'' (Instruction (STRef s Instr''))
01:28:59 <mikusp> basic idea is as follows: each package has multiple versions and each version can depend on some range of versions of other package
01:29:01 <Feuerbach> (untested)
01:30:00 <Feuerbach> Total_1mmersion: or newtype Instr'' s = Instr'' (forall s . Instruction (STRef s Instr''))
01:30:03 <mikusp> an algorithm should resolve dependencies whenever a solution exists
01:30:12 <Feuerbach> Total_1mmersion: er, Instr'' = Instr'' (forall s . Instruction (STRef s Instr''))
01:30:18 <ocharles> dreixel: right, I'm OK with it too, but it does mean users of your library need it too
01:30:34 <ocharles> So as long as we're OK with that, I can carry on :)
01:30:51 <Feuerbach> and the first option should be Instr'' s = Instr'' (Instruction (STRef s (Instr'' s)))
01:34:14 <dreixel> ocharles: for GHC.Generics, I'd be more worried. but instant-generics is just playing ground, more or less.
01:34:50 <ocharles> OK, cool. I'll move on to TH now then and see what happens.
01:39:56 <alpounet> dreixel: the instant-generics approach looks interesting
01:40:32 <simukis_> is there any guidelines on how to throw compile-time errors from TH? `error` will instantly halt the compilation process without writing out other errors.
01:45:17 <dreixel> ocharles: good luck, let me know if you run into trouble
01:45:34 <dreixel> alpounet: it's very similar to GHC.Generics anyway, but easier to experiment with
01:46:23 <Total_1mmersion> Feuerbach, thanks, I got it to work using Instr''
01:48:23 * hackagebot passwords 0.1.0.3 - Password generation/validation library  http://hackage.haskell.org/package/passwords-0.1.0.3 (mkulkin)
01:50:23 <Total_1mmersion> Feuerbach/pavonia, how might I rewrite Instr'' s -> ST s (Instr'' Int) using Fix, and remove Instr''?
01:52:31 <Feuerbach> smth like Instr'' s = Fix (Compose Instruction (STRef s))
01:52:57 <Feuerbach> where Compose comes from Data.Functor.Compose from the transformers package
01:53:31 <Feuerbach> not sure such rewrite will be a win, though
01:57:13 <Total_1mmersion> Do you think this implementation is overly complicated? What I'm trying to do is traverse a list of Instructions, computing and checking the types of them along the way.
01:57:43 <Total_1mmersion> I wonder if there is a simpler, perhaps less mutation-intensive way to type check a list of instructions.
01:59:47 <ocharles> If I have something with  'data Foo a = Foo Int (String -> a)'  -- what are my options for writing  Eq (Foo ()) ? It feels like it does make sense, because there is only one value for (String -> ()) - const ()
02:00:17 <ocharles> What I've been playing with at the moment is a "EqUpToFunctions" type class that does a generic traversal and simply considers (a -> b) to be true, but that feels sloppy
02:00:57 <ocharles> I also considered parameterising Foo on p, so it would be Foo p a = Foo Int (p String Int), and maybe I can fix p to have an Eq instance for a ~ ()
02:00:57 <statusfailed> I have a timestamp in the format "2014-01-02 03:04:05.678", what's the best way to parse it? I'm looking at Thyme's "timeParser" but I can't figure out what the arguments are
02:01:53 <statusfailed> I have a parser that breaks it down into year, month, day, etc., but I don't know how to turn that into (any) time-like type
02:02:30 <Kinnison> Data.Time.Format.parseTime ?
02:03:17 <statusfailed> Kinnison: What are the two strings supposed to be? what if I have Text? how do I get a TimeLocale?
02:03:29 <statusfailed> oops, was looking at Thyme
02:04:11 <Kinnison> http://hackage.haskell.org/package/time-1.4.2/docs/Data-Time-Format.html
02:04:17 <Kinnison> that probably has plenty of docs for you
02:04:45 <Kinnison> As for Text, not sure
02:04:51 * Kinnison is just finding options for you
02:05:11 <statusfailed> Ah I think thyme is supposed to be API compatible with this, that answers a lot :)
02:05:16 <statusfailed> Not sure how to get a UTC locale though
02:05:37 <merijn> statusfailed: Note that Text can be trivially converted to String using unpack if needed :)
02:05:51 <statusfailed> merijn: true!
02:06:07 <centrinia> I was trying to make myself a Scheme in 48 hours: http://codepad.org/GazgmS1w
02:06:42 <centrinia> It can evaluate primitives.
02:07:03 <merijn> centrinia: I'm not really sure how a C++ implementation of Scheme relates to haskell? :)
02:07:50 <centrinia> I was doing ad hoc combinatory parsing in C++.
02:08:06 <Trickster23> hello
02:08:12 <centrinia> I was essentially following Write Yourself A Scheme In 48 Hours in C++.
02:10:24 <ldrndll> I’m hoping someone can help me figure out what I’m doing wrong with generics. I’m implementing a generic show type class (http://lpaste.net/7078580019089375232) but can’t figure out the instance for K1
02:12:05 <pavonia> :t K1
02:12:05 <lambdabot> Not in scope: data constructor ‘K1’
02:12:18 <pavonia> :t GHC.Generics.K1
02:12:19 <lambdabot> c -> GHC.Generics.K1 i c p
02:12:26 <m09> is there a way to obtain modules info at runtime? Kinda like what the hint package does but for already compiled stuff (the equivalent of reflection in let's say Java where we can get class info while they're compiled)
02:13:21 <pavonia> ldrndll: You're missing a parameter type in the instance declaration
02:13:27 <alpounet> m09: what exactly would you like to get?
02:14:07 <m09> alpounet: a list of modules that are compiled in the executable and a plus would also be some API to see if they have a certain method and run it
02:14:40 <m09> I'm not sure this info is still present in the compiled code so it might not be possible if that's not the case
02:15:50 <alpounet> m09: so you have a decent amount of information in the "interface files", i.e the .hi files that get generated
02:15:57 <ldrndll> pavonia: forgive me for being slow, but can you point me in the right direction on how to fix that?
02:16:02 <alpounet> m09: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/IfaceFiles
02:16:15 <alpounet> aside from this and the cabal file (for the list of modules etc), well...
02:16:30 <pavonia> ldrndll: try "GShow a => GShow (K1 i a p)"
02:18:49 <m09> alpounet: that's interesting. Do you know if those .hi files are retrievable in the runnable or if they only serve during compilation so that not everythin is re-compiled?
02:18:59 <ldrndll> pavonia: okay, that makes sense. sadly it doesn’t work though :/
02:18:59 <m09> everything*
02:19:27 <pavonia> ldrndll: What's the error now?
02:19:52 <alpounet> m09: it serves during compilation only. you can do reflection in Java because there's Object, in Haskell it's trickier. what's your overall goal here, that you'd like to achieve through reflection?
02:19:55 <pavonia> :t GHC.Generics.unK1
02:19:56 <lambdabot> GHC.Generics.K1 i c p -> c
02:20:12 <ldrndll> pavonia: it remains the same
02:20:47 <ldrndll> the error that is
02:20:54 <pavonia> :k GHC.Generics.K1
02:20:55 <lambdabot> * -> * -> * -> *
02:21:23 <m09> alpounet: I have a bunch of modules with a common interface. I'd like to retrieve the list of the defined modules at runtime to avoid duplication of the update effort each time I add a new module
02:21:43 <pavonia> Ahh, GShow wants (* -> *)
02:21:58 <m09> and still I'd like to access them from my main program
02:23:18 <pavonia> ldrndll: So you need something like GShow (Λa -> K1 i a p) :S
02:23:45 <alpounet> m09: sounds a bit hacky, so either you're looking for some kind of plugin system, or you're doing smth in a not-so-clean way
02:25:00 <m09> alpounet: indeed it is a bit hacky. And it does resemble a plugin system. Is there an example of a (simple) plugin system considered good style?
02:26:51 <alpounet> m09: there are a couple, but it's really about literally plugging things in at runtime, so you're losing quite some safety on the way. But we have a couple of solutions for this, i'd suggest ctrl+f "plugin" on the hackage package list
02:27:07 <alpounet> i don't know what's the current "most-maintained" plugin library
02:27:42 <ldrndll> pavonia: okay, I’ll have to play around with that. I’m at the limit of what I currently understand in Haskell, so it takes me a while :)
02:27:55 <m09> alpounet: thanks, I'll have a look to see if anything is a fit :)
02:28:21 <alpounet> m09: out of curiosity, what exactly will you put in these "pluggable" modules?
02:28:45 <m09> alpounet: each module is an euler problem
02:28:59 <merijn> m09: I used to have a paper on plugin systems for haskell (by dons, I think), however, the lik went dead and I haven't managed to find it since
02:29:06 <merijn> I dunno if anyone else has a copy
02:29:21 <m09> oh that'd be interesting
02:29:24 <pavonia> ldrndll: As Haskel doesn't have type level lambdas, you could try the Flip type from package TypeCompose, "GShow (Flip (K1 i) p)" or something like that
02:29:29 <alpounet> m09: hah, then i'd definitely qualify your solution as overkill :]
02:29:42 <alpounet> but go ahead, you'll probably learn a couple of things along the way
02:29:52 <merijn> m09: FWIW, I think Project Euler is a pretty terrible way to practice programming. It's neat as a puzzle and playing with numerical theory, but not great for programming
02:30:16 <Maior> merijn: do you know of anything similar but _actually_ intended as "programming practice" btw?
02:30:29 <merijn> m09: The main objection is that Project Euler problems are not like real programming problems and they are disproportionaley likely to make you run into warts like teh numeric tower
02:30:36 <merijn> Maior: Yes! that's why I added
02:30:40 <merijn> @where exercises
02:30:40 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
02:30:50 <Maior> merijn: cheers!
02:31:02 <merijn> (feel free to add more if you run into more/better sites/lists)
02:31:07 <m09> merijn: yy I do not use them to practice programming, only for the algorithmic and fun of it
02:31:48 <m09> alpounet: I actually do know it's overkill. It's just that I've coded a similar hack in Java and wanted to see if it was easily doable in Haskell or not out of curiosity : ]
02:31:54 <merijn> m09: If you want to be ghetto you could just use the FFI and compile every "plugin" to a dynamic library and use dlopen to open and call them :)
02:31:55 <issimus> i think project euler has merit if you try to meet the performance goals, it taught me how to profile and make the correct optimizations
02:32:32 <m09> merijn: I think I'll give up before that :D
02:33:02 <merijn> oooh!
02:33:30 <merijn> I was looking for the paper, but apparently dons thesis was on dynamically extending typed languages, score, I've been reading up on that :)
02:34:06 <m09> oh, dons = the guy who wrote XMonad or am I mixing it up? I'll have a look :)
02:34:14 <merijn> m09: I think dons' plugins package is most likely to be what you want, but the paper link seems dead
02:34:15 <issimus> m09: for my euler executable i just used hackish template haskell solution.
02:34:15 <Axman6> yes
02:34:30 <merijn> m09: dons is the guy who wrote tons of big haskell libaries ;)
02:34:39 <Axman6> has plugins been maintained?
02:34:44 <m09> ok ok I'll have a look :)
02:34:44 <alpounet> not sure
02:34:53 <merijn> Axman6: No clue
02:35:27 <merijn> m09: I know Simon Marlow has been working on dynamic code loading/unloading in GHC, but this is all still rather experimental, afaik
02:36:01 <alpounet> loading has been working for a while
02:36:06 <alpounet> unloading got added very recently
02:36:12 <l0cust> Hey, newbie question. So, I have a class, and I want it to be a subclass of another class
02:36:13 <bergmark> merijn: sounds like "Dynamic typing in type-driven programming" http://repository.ubn.ru.nl/handle/2066/92736
02:36:29 <l0cust> Do I just use an instance declaration for my class?
02:36:48 <shachaf> No, that almost certainly won't do what you want.
02:36:50 <shachaf> What do you want?
02:37:07 <merijn> l0cust: Is your goal to say that "any instance of Foo *must* be an instance of Bar"?
02:37:11 <Axman6> l0cust: if you need all elements of class Foo to also be elements of class Bar, then you can write class (Bar a) => Foo a where ...
02:37:21 <l0cust> No
02:37:48 <merijn> Ok, let's backtrack further: What do you mean by "subclass of another class"?
02:38:10 <l0cust> I'm writing a library for Tropical geometry. Tropical numbers have certain operations, and form a semiring. I want to say that the tropical operations refer to standard semiring operations
02:38:19 <l0cust> In other words, I want to use http://hackage.haskell.org/package/weighted-regexp-0.1.0.0/docs/Data-Semiring.html
02:39:23 <merijn> l0cust: That's not really possible, I think
02:39:45 <l0cust> and say that, in the context of tropical numbers, one = 1, zero = Infinity, etc
02:40:07 <l0cust> I think I'll make a data type
02:40:09 <l0cust> hm
02:41:04 <nclarke> instance SemiRing Tropical where zero = Infinity; one = One ...
02:42:25 <tdammers> tropical numbers... sound hot :P
02:42:30 <nclarke> Assuming tropical is some kind of type/newtype around another ring
02:42:49 <l0cust> Yeah, see this https://en.wikipedia.org/wiki/Tropical_geometry
02:44:46 <Trickster23> Is there a way to flatten something with type: IO [IO [String]] into something like IO [String]?
02:45:18 <Rembane> Trickster23: Try join
02:45:21 <merijn> Trickster23: Sounds like you want sequence and join
02:45:24 <merijn> :t sequence
02:45:25 <lambdabot> Monad m => [m a] -> m [a]
02:45:27 <merijn> :t join
02:45:28 <lambdabot> Monad m => m (m a) -> m a
02:45:53 <merijn> Actually, just sequnce maybe sufficient
02:46:38 <merijn> :t (>>= fmap concat . sequence)
02:46:39 <lambdabot> (Functor m, Monad m) => m [m [a]] -> m [a]
02:47:11 <merijn> :t (>>= sequence)
02:47:12 <lambdabot> Monad m => m [m a] -> m [a]
02:47:38 <merijn> The fmap concat is just to collapse the double list
02:48:02 <merijn> I guess join instead of concat would work too
02:49:23 <pjdelport> list join == concat
02:51:15 <Trickster23> hm, I'm haskell very beginner and I'm trying to apply your advices, although I've encountered problem
02:53:16 <Trickster23> http://lpaste.net/9168136987901689856 and something like this gives mi type error
02:55:07 <ion> Please see mapM
02:55:17 <nclarke> l0cust: Something like http://lpaste.net/103394 maybe what you want?
02:55:46 <ion> (instead of map getDesktopFiles)
02:56:21 <nclarke> Says that for an ordered semiring A you can derive a semiring for the tropical numbers over A
02:57:07 <l0cust> nclarke: Similar
02:57:22 <l0cust> I have something in the works. I'll post it when I get it to build
02:57:53 <Trickster23> ion, thanks, it worked as it should
03:00:11 <ion> Note that mapM f xs = sequence (map f xs)
03:02:15 <l0cust> Alright, the semiring package I want is in some hellish unmaintained regex package
03:02:26 <l0cust> so i'm going to copy it, make it its own package
03:02:28 <NinjaPenguin> How'd you check if something is in an array?
03:02:41 <NinjaPenguin> elem? I completely forgot about that.
03:03:33 * hackagebot blaze-html 0.7.0.2 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.7.0.2 (JasperVanDerJeugt)
03:05:19 <ion> ninjapenguin: Browsing through the array documentation is helpful.
03:05:33 <ion> @hackage array
03:05:33 <lambdabot> http://hackage.haskell.org/package/array
03:09:27 <nclarke> l0cust - you might want to make it extend Monoid
03:11:25 <zipper> Is there a way to get the element number of the item currently being computed on in a list like in a forM implicit loop?
03:13:21 <Rembane> zipper: You could zip the list with a counter
03:13:28 <nclarke> zip list [0..]
03:13:55 <supki> :t iforM
03:13:55 <lambdabot> (TraversableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m (t b)
03:15:02 <nclarke> supki: Where's that from?
03:15:44 <supki> lens
03:15:49 <nclarke> Ah :-)
03:19:20 <ocharles> I think it's in keyed too
03:20:01 <ocharles> zipper: http://hackage.haskell.org/package/keys-3.10/docs/Data-Key.html#v:forWithKeyM
03:20:10 <ocharles> If you want a lighter dependency
03:23:39 <deni> bitemyapp: really liked the "slow down" part....no i must write a webapp now! :D
03:28:12 <zipper> wow I wanted something more like a counter.
03:29:00 <zipper> State monad is recommended in google searches
03:31:08 <l0cust> oh the fucking mit people and their fucking linguistics took the name "semiring"
03:31:52 <zipper> l0cust: LOL
03:32:52 <nclarke> Although their 'weightedSemiring' is exactly what you want here
03:33:11 <Fuuzetsu> l0cust: actual-semiring ;^)
03:33:36 * hackagebot semiring-simple 0.1.0.0 - A module for dealing with semirings.  http://hackage.haskell.org/package/semiring-simple-0.1.0.0 (pharpend)
03:33:50 <Fuuzetsu> heh
03:34:17 <nclarke> See latest commit message
03:34:26 <nclarke> "Apparently, the name 'semiring' is taken"
03:34:36 <Fuuzetsu> https://github.com/pharpend/semiring/blob/master/Data/Semiring.hs#L48 spurious parenthesis detected!
03:35:06 <l0cust> Sorry if the source code sucks. I just took the weighted semiring, and deleted all the crap I didn't need
03:35:13 * zipper is on some maaaaddddddddddd reggae chunes!
03:35:19 <l0cust> It compiled, that's what important
03:35:28 <zipper> I keep posting in wrong channel
03:37:33 <l0cust> You know, I love programming in Haskell, but things take forever to compile
03:37:56 <l0cust> pandoc takes like 10 minutes
03:37:56 <zipper> I kinda like long compile times.
03:38:01 <l0cust> zipper: lol
03:38:13 <zipper> Makes me feel like I am doing serious work. Also I get a break.
03:38:15 <zipper> :)
03:39:20 <quchen> Compiling Pandoc is a one-time thing. It has lots of dependencies, it's a lot of code itself.
03:41:23 <ocharles> l0cust: why compile it?
03:41:38 <ocharles> Doesn't your distribution provide binaries?
03:41:47 <l0cust> Last I checked, no
03:41:50 <l0cust> I use Arch
03:41:52 <ocharles> Ah
03:42:00 <l0cust> You can get a build file, but that just uses cabal-install
03:42:07 <ocharles> sure, I know how the AUR works :)
03:42:10 <l0cust> So, might as well use cabal
03:42:26 * ocharles enjoys having binaries available
03:50:59 <zipper> ocharles: You gotta compile for OPTIMIZATION!
03:51:42 <Taneb> Is there a more sensible abstraction that TMVar (Map UUID (TQueue ByteString))? My instincts are telling me that maps are bad here
03:53:28 <quchen> Maps aren't bad, and your type seems fine. I can't tell whether it makes sense to use a TMVar instead of a TVar there, but that's just a detail.
03:54:11 <orion> hmm
03:54:24 <orion> How can I make an executable depend on a library that is built within the same cabal file?
03:54:38 <bergmark> orion: just put the library in build-depends
03:55:22 <Taneb> quchen, thanks
03:55:34 <Taneb> I am fairly sure that a TMVar is what I want here
03:57:15 <orion> bergmark: thank you
03:57:37 <ocharles> Taneb: there's nothing "wrong" with it, but I think you end up with a lot of contention that way
03:57:42 <ocharles> which means a lot of retrying
03:58:34 <ocharles> Sometimes you can avoid the problem by directly passing the TQueue's around, and avoiding a deep embedding of the routing in a Map
03:58:52 <Taneb> ocharles, that's not really an option here, I'm afraid
03:58:54 <l0cust> Alright, it's 5:00 AM, and so far everything compiles. So, I'm going to bed
03:59:01 <ocharles> Taneb: ok, you know better :)
03:59:03 <bergmark> if you use TVars , using readTvarIO where possible also helps a lot
03:59:11 <Taneb> ocharles, but it should (hopefully) be low traffic
03:59:36 <Taneb> ocharles, if you know any other ways round that problem, that'd be a great help :)
03:59:42 <Taneb> STMMap or something
03:59:58 <ocharles> Taneb: nothing obvious, just clever tricks depending on the problem at hand
03:59:59 <quchen> Or use MVars instead of TMVars. Much less traffic, but you have to be careful about using them.
04:00:13 <merijn> I don't understand why this quasiquote produces a syntax error: http://lpaste.net/103395
04:01:06 <merijn> Parse error, even
04:01:10 <sgronblo> l0cust: 10 minutes is only for a cold compile or?
04:02:55 <merijn> sgronblo: The thing is, cabal/GHC already automatically do incremental compilation so after the initial compile you're not likely to do it again even if you are hacking on it
04:03:58 <Taneb> Hmm, TVars seem a better fit than TMVars
04:04:41 <merijn> Taneb: Yeah, especially given that Map already has an "empty" value that you can trivially use
04:04:46 <sgronblo> merijn: not likely to do "it" again?
04:04:54 <merijn> sgronblo: Recompile entirely
04:05:08 <merijn> sgronblo: Because of incremental compilation it will only recompile files you changed
04:05:09 <sgronblo> ah
04:05:16 <sgronblo> yeah thats what i wanted to confirm
04:05:44 <merijn> sgronblo: You'd only have to rebuild after a "cabal clean", which is not something you do often (certainly a factor 50 less than I use "make clean" in C)
04:06:10 <sgronblo> so it doesnt sound like a big problem
04:06:14 <merijn> sgronblo: So on the one hand 10 minutes for pandoc is kinda annoying, on the other hand, it's not *that* big a deal in practice
04:06:33 <merijn> sgronblo: Also, note that compiling without optimisation drops compile times a ton
04:06:59 <merijn> sgronblo: I tend to build with -O0 when compiling "to see if everything works" vs -O2 to actually use
04:08:19 <merijn> No one has a clue about my template haskell quoting issue? I'm kinda stumped on why it's not parsing...
04:11:17 <sopvop> Is there a name for such thing, so I can google it: User can specify certain queries to retrieve a subset of data from a data structure. Like all subfields from "foo" field, not the description field, all kids named "baz" anywhere in structure. And the get a filtered out tree. Like an xpath thing.
04:11:39 <merijn> sopvop: uniplate/biplate ?
04:12:30 <sopvop> merijn: Well that's for haskell, and I want to make a filter for responses from web service. So if user wants any fields of foo, I'll have to get foo from db and the like.
04:13:05 <merijn> This sounds like "magical querying fairy dust", so I'm not sure something like that exists
04:13:13 <sopvop> xpath exists
04:13:14 <sopvop> :)
04:13:49 <sopvop> I just don't want to implement before checking out how other people do it.
04:14:59 <sgronblo> is this something that lenses are used for?
04:15:24 <alpounet> they could be used for that yeah
04:15:30 <alpounet> but you'd still have quite some work to do
04:15:56 <alpounet> also, sopvop is interested in having this in a more general setting than haskell data types
04:18:42 * hackagebot MFlow 0.4.5 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.5 (AlbertoCorona)
04:23:43 * hackagebot MFlow 0.4.5.1 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.5.1 (AlbertoCorona)
04:24:52 <orion> What's the best way to represent a unsigned 64 bit integer in haskell?
04:25:04 <luite> orion: use Word64
04:25:17 <orion> Thank you
04:36:39 <issimus> im trying to compile parconc-examples, the source code for parallel and concurrent haskell. cabal install --only-dep is failing because accelerate won't compile because of "unknown symbol __imp_Sleep". it depends on hashtables which is importing Sleep. i'm on 64bit windows btw. how do i get the linker to see kernel32 has the import?
04:40:50 <issimus> and shouldn't this error happen earlier in the compilation anyway? why isn't hashtables library linked against kernel32 to prevent this error in accelerate?
04:48:18 <orion> What namespace do functions within "instance"s go in?
04:49:02 <thewonderer111> cabal hell has been driving me insane... https://gist.github.com/robstewart57/195f93123d2e00cd00c8
04:49:27 <thewonderer111> Why does it insist one reinstalling these packages, when they are clearly already installed (see second command)
04:49:41 <Feuerbach> orion: you can't define new fns inside instances, only implement class methods
04:50:54 <arj> thewonderer111: because they were built using a different hashtable version
04:51:05 <arj> see first output: "changes: ..."
04:51:49 <thewonderer111> arj: so the solution is to reinstall hashtables?
04:52:40 <grayling_> Anyone can get me started on how to translate this rather verbose piece of java into haskell: http://lpaste.net/103396
04:52:47 <thewonderer111> arj: what is the solution, actually?
04:52:52 <arj> thewonderer111: yes/no: the solution is to compile accelerate and the others with the version of hashtable you actually need
04:53:04 <arj> do you understand the actual problem?
04:53:44 <pjdelport> grayling_: Can you summarize what it does?
04:53:56 <thewonderer111> Not fully. How am I supposed to know which version of hashtables that I need?
04:54:07 <pjdelport> grayling_: How are threads involved, or is that not relevant?
04:55:10 <grayling_> It takes a number, that's last, and divides 0..number into [[]] where the number of lists in the list is thread.
04:55:43 <grayling_> thread is just the part the function divides the number into.
04:56:07 <grayling_> confusing name I know but it's out of context.
04:56:09 <arj> thewonderer111: origin is often the following: Package A says "I require B-1.2.*" then, when you install package A, cabal installs some version of B-1.2.* it currently finds (let. Now, you have another package C, that requires A AND B-1.2.3
04:56:21 <funfunctor> Hi
04:56:30 <arj> thewonderer111: I write it again, that was sent to fast, gimme a second.
04:56:52 <grayling_> pjdelport: I gueass I'm asking how to generate the lists in the list.
04:56:56 <funfunctor> so i've been thinking about xmonad and porting to wayland, we do have a binding yet?
04:57:02 <thewonderer111> Thanks. Concretely, how might I resolve the problem I face, detailed on that gist?
04:57:15 <grayling_> When it's dynamically defined.
04:57:30 <arj> origin is often the following: Package A says "I require B-1.2.*" then, when you install package A, cabal installs some version of B-1.2.* it currently finds (let's assume B-1.2.1 is installed). Now, you have another package C, that requires A AND B-1.2.3. However, A is linked to B-1.2.1, but the other package C requires B-1.2.1 -> conflict.
04:57:56 <arj> solutions: do not write explicit version numbers (if you do, you have to know which version numbers you use).
04:58:09 <arj> simply try a reinstall in your case. it might work
04:58:48 <arj> to get back to the example: A will be recompiled using B-1.2.3 then. This might lead to other conflicts in the same way as just described.
04:58:49 <merijn> Although reinstalling will break anything else that happens to use B-1.2.1
04:58:53 <thewonderer111> Reinstall of which package, though?
04:59:03 <thewonderer111> Also, I don't have /any/ explicit version numbers in my package
04:59:07 <grayling_> I've been looking at different data.array but can't seem to crack it.
04:59:32 <thewonderer111> So it might be the version numbers specified by one of the packages I depend on.. sigh.
04:59:46 <arj> exactly.
05:00:28 <arj> thewonderer111: maybe just try: cabal install --reinstall. But you have been warned, this might crash other packages!
05:00:53 <arj> consider working with cabal sandbox or cabal dev. Then you can use the packages locally
05:01:35 <thewonderer111> Bah, this is a clean Haskell platform install. I run `cabal install` in my project which is not at all specific about any version numbers, and this happens.
05:01:44 <thewonderer111> The angst :-/
05:01:50 <arj> welcome to the hell ;-)
05:02:00 <arj> s/hell//
05:05:05 <sopvop> http://lpaste.net/103397 well, query interpreter of sorts
05:05:51 <pjdelport> > let partitioned n xs = chunksOf (ceiling $ genericLength xs / n) xs in partitioned 3 "abracadabra"
05:05:52 <lambdabot>  ["abra","cada","bra"]
05:06:31 <pjdelport> grayling_: Something like that?
05:06:44 <pjdelport> (chunksOf is from Data.List.Split, by the way)
05:06:49 <grayling_> pjdelport: Thank you so much!
05:07:13 <pjdelport> grayling_: There are probably other ways to approach it too, if this is part of a bigger program.
05:07:15 <grayling_> I did thy chunksOf but never went as far as you just did.
05:07:48 <manuel__> what ide / editor do you guys use?
05:07:51 <manuel__> is emacs common?
05:08:00 * pjdelport uses Vim
05:08:02 <grayling_> pjdelport: I'll give it a spin. Thanks again.
05:08:18 <grayling_> I use emacs.
05:08:51 <sopvop> manuel__: emacs has very good haskell-mode, vim has something, also some vim users I know have switched to Yi
05:10:11 <tero-> is IntelliJ Idea haskell plugin any good?
05:10:35 <tero-> hmm. last version from 2012
05:10:42 <Maior> tero-: not what I want it to be, but not terrible
05:11:08 <merijn> How do I make cabal run multiple preprocessors on a file in a row?
05:11:20 <merijn> Or is that completely impossible?
05:11:21 <bulters> pjdelport: what's - in your opinion - the best vim plugin to start with?
05:12:14 <arj> evil :-p
05:12:27 <pjdelport> bulters: syntastic with hdevtools / hlint etc. is not bad to start with
05:13:23 <pjdelport> The Vim haskellmode is probably the next thing to try
05:13:48 <pjdelport> (I don't actively use it at the moment, though; not doing enough Haskell, sadly)
05:15:26 <bulters> pjdelport: I'm actually just browsing the haskell site for the first time in a serious manner
05:15:41 <bulters> was thinking on giving this haskell thing a serious spin tonight ;-)
05:16:22 <tdammers> if you're new to Haskell, I suggest you just use plain vim
05:16:34 <tdammers> no extensions needed, really, until you start building larger stuff
05:16:36 <tdammers> and even then...
05:16:38 <quchen> If you're new to Haskell, I suggest whatever editor you like
05:17:01 <bulters> quchen: being a vimmer for the past 10+ years... I'm not really privy on learning AND haskell AND emacs :P
05:17:12 <tdammers> vim will be fine
05:17:25 <merijn> bulters: I write haskell in vim without a lot of extensions...
05:17:30 <bulters> tdammers: will stick to my comfy environment
05:17:33 <Maior> bulters: I use nothing more than vim2hs
05:17:47 <merijn> I use syntastic/hdevtools nowadays, but even those are mostly redundant
05:17:54 <tdammers> I don't use any vim plugins at all for haskell, except the standard ftplugin
05:18:05 <tdammers> and hasktags to generate tag files
05:18:21 <bulters> Reason I ask, typical workflows for e.g. clojure don't really work well in vim (i.e. clojure is much more emacs 'centered')
05:18:34 <tdammers> clojure is a lisp, sort of
05:18:34 <bulters> will probably not need any plugins for the next few weeks
05:18:58 <bulters> tdammers: yeah, and idiomatic workflows in lisp involve a lot of repl work/iterative development
05:18:58 <tdammers> and as such, benefits from a tighter integration between the editor and a REPL
05:19:20 <tdammers> haskell has a REPL too, but you don't typically integrate it as tightly with the editor
05:19:35 <eizo> pjdelport: for the "get unique" problem of yesterday, i finally wrote: let histogram = M.fromListWith (pure . pure $ False) . (`zip` repeat True); is there a nicer way?
05:19:35 <bahamas> tdammers: common lisp seems to be pretty well supported on vim though. at least, that's what I read. I didn't actually try it
05:19:40 <tdammers> I tend to write some code, get it to compile, and then load it into the repl
05:19:47 <tdammers> bahamas: idk, I don't do much lisp
05:20:23 <tdammers> bahamas: but from what I've tried, if I would, I would really really want tighter integration than what vim can offer, I think
05:20:26 <bahamas> tdammers: me neither. I just read the intro to "practical common lisp" out of curiosity
05:20:35 <tdammers> I've played with scheme a bit
05:20:41 <tdammers> wrote a little toy web server and such
05:20:55 <pjdelport> eizo: It's not quite a histogram if you're not counting them...
05:21:17 <tdammers> didn't really go much further though, because at the end of the day, it's still a dynamic language, with all the problems this brings
05:21:36 <eizo> pjdelport: sure
05:21:48 <bahamas> tdammers: I played with racket as well. the flexibility was pretty nice: macros, etc.
05:21:55 <eizo> you could say it's a bounded histogram, or the abstraction of a histogram
05:22:07 <tdammers> bahamas: yes, sure, flexibility is the single biggest selling point of dynamic languages
05:22:26 <tdammers> bahamas: I just happen to think that it's not usually worth the danger, and it doesn't scale well
05:23:11 <pjdelport> eizo: What benefit does it give, though?
05:23:31 <pjdelport> M.fromListWith (+) is simpler :)
05:23:49 <pjdelport> and there shouldn't be any noticeable performance difference
05:24:37 <bahamas> tdammers: since learning haskell, I started to see more and more the benefits of a good type system
05:25:07 <bahamas> now we need to get more people to use it
05:25:28 <eizo> pjdelport: it's just nice because then i can write  let singles = map fst . filter snd . M.assocs . histogram $ myList, but you're right it's a useless optimization
05:26:40 <pjdelport> eizo: Well, the only difference would be saying filter ((1 ==) . snd)
05:26:47 <tero-> bahamas: programming in Haskell forces you to think, and in general people don't like to think... mission impossible to get people to use it?
05:27:05 <eizo> true
05:27:11 <Rembane> bahamas: That's one of the side effects of using Haskell. :)
05:27:25 <bulters> thanks, and workd on some kind of seminal introductory works? Learn you a haskell still 'the best'?
05:28:22 <merijn> Right, I want to at compile time splice a String into my haskell source file. Any suggestions? First person to suggest Template Haskell or a preprocessor gets stabbed with extreme prejudice.
05:28:46 <bahamas> tero-: I wouldn't be so cynical.
05:28:53 <pjdelport> eizo: The other reason would be that it generalizes more easily in more directions; for example, you could easily do filter ((< 3) . snd), or any other condition.
05:28:55 <quchen> merijn: CPP?
05:29:04 <quchen> Or do you want to calculate the string
05:29:10 <merijn> quchen: If you can tell me how to make CPP run arbitrary haskell code to generate my string
05:29:22 <eizo> yes makes sense
05:29:24 <bahamas> tero-: people are just scared of all the impenetrable terminology
05:29:26 <quchen> Use TH to write it to a file, then use CPP to import it? :>
05:29:46 <merijn> quchen: You know what's fucking awful?
05:29:57 <merijn> quchen: That's probably the most reasonable solution you could've suggested
05:30:10 <quchen> Oh my.
05:30:20 <quchen> This is madness.
05:30:23 <merijn> I'm open to anything better
05:30:28 <merijn> But I might actually just do this
05:30:44 <quchen> Still having the TH+pattern problem?
05:30:44 <merijn> oh, godfuckingdammit
05:30:56 <merijn> quchen: TH can't produce CPP includes...
05:31:00 <merijn> quchen: Yes
05:31:20 <merijn> quchen: I wrote a preprocessor to do it for me, but I can't make cabal call my preprocessor on my source file
05:31:37 <RchrdB> merijn, does GHC's API not include a function from a String to a TH splice?
05:31:40 * quchen uses makefiles to call Cabal. For reasons like this.
05:31:56 <merijn> RchrdB: What good does that do?
05:32:06 <merijn> RchrdB: My entire problem is that there's no way to construct a valid TH splice
05:32:09 <quchen> Makefiles can't be used for Hackage though :-(
05:32:14 <quchen> (Which is probably a good thing)
05:34:54 <merijn> RchrdB: The point is, I want to produce a String using TH and then splice that String into my source file 'as-is'
05:35:43 <merijn> Like expanding a CPP define, except using TH to generate the value in the define
05:36:08 <merijn> quchen: Right, so even your horrible idea won't work :(
05:36:15 <merijn> I'm becoming sadder by the minute
05:38:51 * hackagebot sloane 1.7.1 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-1.7.1 (AndersClaesson)
05:40:09 <roconnor> what's a good name for the functor ((x -> a) -> b)  as a functor in x?
05:40:55 <erisco> http://lpaste.net/103398 is the reason it cannot unify is because in my usage I expect a particular 't' rather than forall t?
05:41:27 <roconnor> @pl (\h -> g (h . f))
05:41:27 <lambdabot> g . (. f)
05:42:06 <erisco> roconnor, does that work as a Functor?
05:43:22 <erisco> roconnor, ah yes it does, I see now
05:44:40 <roconnor> I'm currently calling it "DoubleNegative" because I am terrible at making up names
05:46:45 <erisco> LeftArrow? I dunno that is weird
05:46:55 <merijn> quchen: Any other terrible suggestions?
05:48:06 <quchen> *that* left you out for wanting more? Hold on, I need to come up with a new sarcastic solution and present it as serious :-þ
05:48:52 * hackagebot ghc-mod 4.1.0 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-4.1.0 (KazuYamamoto)
05:48:57 <arjen-jonathan> Can I find anyone here with knowledge about GHD's internals?
05:49:04 <arjen-jonathan> *ghc's
05:49:21 <merijn> quchen: This issue is *really* blocking my progress and there's no work around to heinous for me to implement and just go "fuck it, I'll worry about that later"
05:49:56 <quchen> Could you maybe do some evil hackery using literal strings in TH to get the #define in the source?
05:50:18 <merijn> Once I've literally considered creating a file from TH and #include'ing the result back, do you really think there's any line I won't cross :p
05:51:06 <merijn> quchen: You can't produce literal strings from TH, that's my problem
05:51:10 <merijn> at least, not afaik
05:51:18 <merijn> If you could my entire would disappear within a blink
05:51:42 * erisco blinks
05:51:49 <merijn> If I could insert a #define from TH I could also just insert an arbitrary string and be done
05:51:58 <erisco> guess there isn't a way
05:53:47 <erisco> I do not understand when 't' can be unified with forall t and when it cannot
05:53:59 <quchen> merijn: I'm not sure what you want anymore, TH can generate string literals for you after all. I guess your problem runs much deeper.
05:54:03 <erisco> it seems I have near identical use cases and one works and the other does not
05:54:39 <quchen> IIRC you want to read a literal String from a file, and splice it in your code in verbatim?
05:55:21 <erisco> unless.. it must be because of MaybeT.. that is a data type after all, and if its field is not quantified with forall then it would not unify with forall
05:55:41 <erisco> (I guess? I would think that would be the same as with impredicative types)
05:55:52 <merijn> quchen: I don't want to insert a String literal
05:56:02 <merijn> quchen: I want to just splice in a piece of source text
05:56:40 <merijn> quchen: Like, I want TH to splice "pattern Foo = Just 1" into my source text
05:57:58 <merijn> None of this fancy quasiquoted, semi safe operations, just "run code, produce string, pretend string was written in the source file all along"
06:00:19 <merijn> Like I said, I wrote a preprocessor that can do this, but there's no sane way to get cabal to call my preprocessor
06:00:40 <quchen> The problem here is that pattern synonyms are just a preview feature, so I'm not surprised it has no support in other libraries.
06:00:48 <c_wraith> merijn: not even with the flags that let you call a custom preprocessor?
06:00:55 <FreeFull> You could use the C preprocessor potentially
06:01:39 <c_wraith> merijn: https://www.haskell.org/ghc/docs/7.0.4/html/users_guide/options-phases.html
06:02:00 <merijn> FreeFull: No, because CPP isn't powerful enough to the code generation I need
06:02:24 <merijn> c_wraith: I can get cabal to call *1* preprocessor for a file, but if my file needs both my own plus another preprocessor I'm boned
06:03:09 <quchen> Call a preprocessor that launches two other preprocessors?
06:03:18 <c_wraith> merijn: you mean if you need your preprocessor, and another one that isn't CPP?
06:03:29 <c_wraith> merijn: because -F and -pgmF don't interfere with the CPP extension
06:03:44 <merijn> c_wraith: I didn't know -pgmF, that might work
06:03:45 <c_wraith> merijn: or the deliterate preprocessor
06:03:52 <merijn> c_wraith: If it does I will <3 you forever
06:04:00 <merijn> c_wraith: Does that called after CPP?
06:04:02 <c_wraith> yes
06:04:04 <merijn> +get
06:04:26 <c_wraith> according to the docs on -F, anyway
06:08:54 * hackagebot clash-lib 0.3.0.4 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.3.0.4 (ChristiaanBaaij)
06:08:56 * hackagebot clash-prelude 0.5.0.1 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.5.0.1 (ChristiaanBaaij)
06:09:59 <quchen> Is there a fundamental reason `fix` unifies with continuations, or is that just coincidence?
06:10:24 <quchen> I can see how it's like feeding a continuation to itself over and over, but is that important in some way?
06:10:43 <fizruk> :t fix
06:10:43 <lambdabot> (a -> a) -> a
06:12:10 <fizruk> > (\f -> f []) (1:)
06:12:12 <lambdabot>  [1]
06:12:15 <fizruk> > fix (1:)
06:12:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:12:50 <fizruk> :t sequence . forever
06:12:51 <lambdabot> Monad m => [a1] -> m [a]
06:13:24 <klrr_> :t seq
06:13:25 <lambdabot> a -> b -> b
06:21:39 <roconnor> oh of course, it is the parameterized continuation monad.
06:23:32 <quchen> ?
06:24:09 <roconnor> [08:38] <roconnor> what's a good name for the functor ((x -> a) -> b)  as a functor in x?
06:24:26 <merijn> c_wraith: Partial success \o/
06:24:33 <quchen> Aah.
06:24:38 <merijn> c_wraith: It does indeed run a program and after CPP, *but*
06:24:55 <merijn> GHC's CPP is failing in braindead ways
06:25:10 <merijn> i.e. not finding system include files
06:26:26 <merijn> Or rather, GHC doesn't seem to define standard CPP values like __APPLE__, which I guess is easily remedied
06:28:56 <merijn> quchen, c_wraith: Oh, ffs, GHC's CPP implementation is ridiculously broken so now it's failing on CPP so I'm still no closer to a working solution >.>
06:29:01 <merijn> I'm gonna take a break before I cry
06:30:54 <quchen> GHC has a custom CPP?
06:31:03 <quchen> I thought it used the external one.
06:32:31 <c_wraith> 7.8 moved to cpphs (or a fork of it) because the clang's CPP choked on files gcc's CPP worked just fine with
06:32:43 <c_wraith> the clang.  Sure, why not.
06:33:12 <c_wraith> the dirty secret is that CPP isn't a standard, or even close to one.
06:33:25 <c_wraith> GCC and Clang do things differently, and neither is wrong
06:35:29 <c_wraith> So GHC has it own not-wrong version of CPP now.  But at least it's consistent between different operating systems
06:39:00 * hackagebot creatur 5.4.0 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.4.0 (AmyDeBuitleir)
06:39:24 <erisco> I have boiled down the problem as much as I can... if someone could please help me with this blocking issue I'd be greatful http://lpaste.net/103404
06:41:42 <ocharles> dreixel: type checks with TH :)
06:42:01 <erisco> referential transparency appears broken
06:42:48 <oio> has anyone worked with chemical reaction types?
06:43:17 <dreixel> ocharles: great! and does it work too? :P
06:43:27 <ocharles> dreixel: what, I have to do more than make it type check?!
06:43:30 <dreixel> :P
06:43:54 <ocharles> dreixel: not sure yet, but for my example GADT it at least generates valid to/from functions and Rep. next step is to see if I can use this to generate a Functor instance
06:44:46 <dreixel> ocharles: that already sounds pretty good.
06:45:01 <ocharles> dreixel: yea, the fact that to and from works makes me think I'm in a good position
06:45:35 <dreixel> yep
06:50:46 <ephemeron> (Beginner here.) Trivial setup question: is there a common practice for installing global packages (e.g. Pandoc, Idris) without incurring into dependency hell?
06:51:36 <erisco> wtf... I am trying to report a bug to ghc and I am asked this captcha
06:51:40 <erisco> "four plus four multiplied by four"
06:52:07 <erisco> is it 32 or 20?
06:52:15 <FreeFull> Have you tried writing 32?
06:52:19 <FreeFull> Oh
06:52:26 <FreeFull> Yeah, good point
06:52:48 <erisco> well it was not 32 lol
06:53:02 <erisco> seven minus nine plus two
06:53:05 <erisco> fuck this thing man
06:53:19 <c_wraith> ephemeron: just nuke the global package db (~/.ghc) if you end up with trouble installing global stuff.  Assuming you didn't make the mistake of using the OS package manager to install anything
06:54:06 <erisco> got it wrong again using the same associativity as the previous one... lol
06:54:23 <erisco> zero plus three minus four... well at least we have the additive identity! degenerate problem! woo got it correct
06:54:27 <ocharles> dreixel: https://github.com/ocharles/instant-generics/commit/f3dd1c77fc16b72ada12bb001ae7aec2b4f58743?w=1 that's what I've done, btw
06:55:09 <ocharles> heh, looks like I have few bits of debugging to remove from that :)
06:55:23 <erisco> okay now the server is giving me an auth prompt and my username/pass does not work and I have no email
06:55:36 <erisco> if anyone can submit a bug to ghc my replication is http://lpaste.net/103404
06:55:51 <erisco> alternatively if anyone can explain to me why http://lpaste.net/103404 is expected behaviour I'd appreciate that too
06:57:03 <dreixel> ocharles: nice. but I was hoping k could replace p and q too
06:57:23 <ocharles> dreixel: oh, I see. That should be possible, I can look into that
06:57:27 <ephemeron> c_wraith: Doing that does seem to remove the warning and cause the installation to proceed; however, is it actually a solution, i.e. things will not be broken?
06:57:35 <dreixel> ocharles: it's just cleanup anyway, what you have now will work
06:57:36 <ocharles> dreixel: so k has p ~ q?
06:57:47 <ocharles> or something to capture the equality, anyway
06:57:49 <dreixel> ocharles: yes, k would also encode those types of constraints
06:58:21 <dreixel> ocharles: this shouldn't be too hard, I think. it might actually even be easier than what's being done atm, because we're getting the constraints and splitting them into p and q, whereas now we can just take the constraint as is...
06:58:30 <ocharles> right
06:58:31 <c_wraith> ephemeron: ghc will no longer try to use an inconsistent set of packages. I'm pretty sure that counts as "actually solving"
06:58:48 <ocharles> dreixel: now that I think about this though... can instant-generics actually derive functor? Doesn't that need a * -> * representation?
06:59:12 <dreixel> ocharles: well, yeah, probably. is that a problem? :P
06:59:13 <ephemeron> c_wraith: I see. Much appreciated.
06:59:26 <ocharles> dreixel: not sure I follow
06:59:34 <dreixel> ocharles: is that what you wanted?
06:59:54 <ocharles> dreixel: the problem I have is a gadt with 50 constructors that is a functor, and I want something to derive that instance for me
07:00:06 <ocharles> ghc.generics is out of the question, because it can't do gadts. so I went for instant-generics
07:00:11 <dreixel> ocharles: ok, then yes, it's a problem. I kinda forgot that small detail.
07:00:14 <ocharles> but now I'm wondering if that is also not going to work :)
07:00:45 <dreixel> ocharles: you have 2 options now: adapt this TH code to generate GHC.Generics reps instead, or come up with a way to write Functor generically in instant-generics
07:01:02 <dreixel> ocharles: or perhaps 3 options, the third being changing GHC.Generics to have these constraints in it.
07:01:14 <ocharles> the last seems the most useful in the long run
07:01:24 <ocharles> but certainly the most work :)
07:01:38 <dreixel> ocharles: yes, but it's the one that requires the most thinking in terms of whether this actually works in general, and doesn't break existing code.
07:01:50 <ocharles> indeed, that too
07:01:52 <dreixel> ocharles: so far it looks good.
07:02:20 <ocharles> I'll be with kosmikus in person on friday, maybe he has some thoughts on it too
07:02:40 <dreixel> ocharles: yes, do talk to him about this.
07:02:50 <dreixel> are you taking his course?
07:02:52 <ocharles> yea
07:02:55 <dreixel> cool
07:03:18 <ocharles> looking forward to having some slightly less adhoc knowledge for this type magic stuff :)
07:03:50 <dreixel> :-)
07:04:42 <ocharles> dreixel: for writing a functor instance with instant-generics, it would seem the only option is to introduce a family of rep constructor for * -> *. there's no way to get a functor out of just a * representation, is there?
07:05:21 <dreixel> ocharles: I'm thinking about it... :P
07:05:22 <ocharles> I wonder if I can fudge it by recursing into U with Const U or something
07:05:27 <ocharles> ok :) I'll have a fiddle
07:08:39 <dreixel> ocharles: I'm afraid this won't be easy...
07:10:02 <dreixel> ocharles: perhaps lets just go the right way, and think how to get this into GHC.Generics. That will mean you'll have to wait until at least 7.10 for it, of course.
07:10:25 <ocharles> No rush. with this fix to instant generics I can write out Functor by hand and at least derive Eq and Show
07:10:27 <dreixel> ocharles: in the meantime, these changes could be tried on the generic-deriving package, which has TH code, I believe, so you could try adapting that.
07:10:49 <ocharles> Don't I have to change the types in GHC.Generics to have (k :: Constraint) though?
07:11:20 <dreixel> ocharles: you would, yes. only one, though, I think.
07:11:42 <dreixel> ocharles: btw, did you try Generics.Instant.Functions.Empty? does it still work?
07:12:17 <merijn> c_wraith: I know CPP isn't completely standardised but GHC's CPP (and also c2hs) support is broken to the extend of not even supporting very basic things
07:12:32 <merijn> c_wraith: Case in point, GHC chokes and dies on indented CPP directives
07:12:59 <ocharles> dreixel: hmm, no - not right now it doesn't
07:13:16 <dreixel> ocharles: generators are tricky.
07:13:37 <ocharles> It doesn't work due to a missing instance though, so I may have missed something obvious
07:15:06 <ocharles> anyway, this is getting quite far away from actual paid work, so I should probably get back to that now :)
07:15:10 <ocharles> thanks for the help so far!
07:15:33 <ocharles> i'll keep plugging away in my free time and see what I can get
07:21:38 <zipper> Which is the easiest way to split a string at the last dot (.) in haskell?
07:21:57 <zipper> I was told here that regex is overkill
07:22:12 <haskellephant> zipper: yes regex is way overkill
07:22:43 <prophile> try takeExtension from System.FilePath.Posix
07:22:52 <quchen> If by "string" you mean "String", then look at Data.List.Split, zipper
07:23:40 <zipper> quchen: I mean String
07:23:55 <haskellephant> zipper: I think prophile uderstood what you wanted more than I did :D, takeExtension should be correct if you are working with files
07:24:02 * hackagebot type-unary 0.2.16 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.2.16 (ConalElliott)
07:24:36 <zipper> FileName is a type synonym for string
07:25:18 <haskellephant> zipper: Yes, but takeExtension certainly has a certain use in mind of its Strings
07:25:22 <hunt> can i lift an io action in some other monad and have it work?
07:26:11 <td123> zipper: a simple do it yourself function could involve the partition and reverse functions
07:26:42 <jmcarthur> hunt: it depends on the other monad
07:26:53 <hunt> jmcarthur: ActionM i think
07:27:03 <hunt> its for scotty
07:27:06 <jmcarthur> hunt: if it's the result of a monad transformer that has been applied to IO at some point, you can probably use liftIO
07:27:34 <jmcarthur> hunt: that would live in Control.Monad.Trans, iirc
07:28:00 <jmcarthur> hunt: if this is doable, the documentation would say that there is a MonadIO instance for ActionM
07:28:20 <td123> oh wait, partition doesn't do what I think it did :)
07:28:56 <FreeFull> :t partition
07:28:57 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
07:29:15 <FreeFull> > partition (>10) [1,2,3,4,10,4,102,42,0]
07:29:16 <lambdabot>  ([102,42],[1,2,3,4,10,4,0])
07:29:28 <hunt> jmcarthur: i dont really understand this, i guess i just need to understand monads better
07:29:59 <td123> yup
07:30:39 <ocharles> hunt: You need to understand monad transformers, but to give you a little intuition - you know that the IO monad lets you do arbitrary IO
07:30:46 <td123> findIndex/splitAt will work though
07:30:49 <ocharles> and you may also know that the "Maybe" monad lets you model computations with failure
07:31:04 <ocharles> so it follows that we should be able to have "IO computations that might fail" - which is failure on top of IO
07:31:06 <heath> http://lpaste.net/103409
07:31:11 <ocharles> this is a monad, and we can certainly do IO in it
07:31:21 <ocharles> and that's what liftIO is about
07:31:26 <jmcarthur> hunt: if it works, you should be able to just pretend:   liftIO :: IO a -> ActionM a
07:32:17 <zipper> prophile: takeExtension worked just fine thank you.
07:32:29 <prophile> zipper: no worries!
07:32:36 <jmcarthur> heath: all those things you were tab completing on the import line were actually other modules, not things defined in System.IO
07:32:58 <jmcarthur> heath: they don't live in the System.IO namespace. they are just other possible completions of the prefix "System.IO"
07:33:25 <jmcarthur> heath: in particular, they are things you could have imported instead of System.IO
07:33:54 <jmcarthur> heath: the tab completion isn't showing you stuff in the System.IO namespace, is the point
07:34:11 <heath> Yeah, that's a surprise
07:34:15 <jmcarthur> heath: since that wouldn't be valid to "import". hGetChar is not a module
07:34:38 <jmcarthur> heath: i think you just have a different mental model of what haskell modules are like. it's not surprising to me
07:35:01 <jmcarthur> heath: the point is that the tab completion is only showing you what would be valid to do *right there*
07:35:04 <heath> jmcarthur: if you don't mind me asking what's your workflow for determining what's contained in a module?
07:35:25 <heath> :hoogle IO () -> IO ()
07:35:36 <heath> i'm doing things like this to search for stuff to bring in
07:35:48 <jmcarthur> heath: :browse, if you want to do it in GHCi
07:36:10 <jmcarthur> heath: i typically just use the html documentation though
07:36:53 <jmcarthur> heath: e.g.    :browse System.IO
07:38:31 <heath> nifty
07:39:33 <merijn> Anyone know which GHC code is responsible for calling cpp?
07:45:20 <dmwit> Okay, I want something like a conjugation but with some monad stuff thrown in the middle.
07:45:29 <dmwit> Which is annoying because it doesn't look symmetric.
07:45:41 <dmwit> fmap fromAscList . mapM processEachEntry . toAscList
07:46:12 <dmwit> How can I make it pretty?
07:47:47 <steshaw> if I want to sandbox to avoid cabal hell do I need to sandbox my first update of cabal `cabal install cabal-install`? I’ve installed the haskell-platform on Mac.
07:49:23 <zq> whoa
07:49:31 <zq> rank N is useful
07:49:45 <dmwit> steshaw: I'm not sure, but I don't think sandboxing applies to executables at all.
07:49:55 <bitemyapp> deni: :)
07:49:56 <dmwit> Your shell is still in charge of PATH, not cabal.
07:51:21 <nclarke> steshaw: I have a policy of installing cabal-install only in the user DB, and everything else in sandboxen
07:52:00 <steshaw> dmwit: Also leave the Cabal Library is installed when I do ‘cabal install cabal-install’ and I think a text library too.
07:52:24 <steshaw> nclarke: and that’s working for you without any hell?
07:52:55 <dmwit> steshaw: Yes, but executables are statically linked (by default).
07:53:02 <nclarke> steshaw: So far. Although I only got this computer last week, so it hasn't had much time to get tangled
07:53:21 <dmwit> steshaw: So the cabal-install executable will be using the Cabal library it was built with, not the one in your sandbox.
07:53:34 <nclarke> I have an additional ~/.cabal-sandboxes directory which has any 'global' sandboxes
07:53:43 <steshaw> nclarke: ok, I might try it that way since I already did ‘cabal install cabal-install’ :)
07:54:20 <nclarke> E.g. one containing alex+happy, one with warp-static, one with idris, one with the sublime plugins
07:54:26 <steshaw> dmwit: executables might be statically linked but cabal is downloading and building library code when I `cabal install cabal-install`
07:55:00 <nclarke> I was going to write a little program to handle loading a particular sandbox's bin dir into PATH
07:55:00 <steshaw> nclarke: Yes, I was told to do the same tonight at a local hack night
07:55:02 <nclarke> And unloading
07:55:04 <dmwit> steshaw: Sure. But why are you installing cabal-install if all you care about is the libraries?
07:55:11 <nclarke> Haven't done that yet, though!
07:55:18 <steshaw> nclarke: good to see you installing Idris
07:55:21 <dmwit> steshaw: If all you care about is the libraries, install the libraries. =)
07:56:01 <steshaw> dmwit: after `cabal update`, cabal tells you to run `cabal install cabal-install` but it doesn’t say anything about sandboxing it or not..
07:57:06 <dmwit> Okay, I get it.
07:57:15 <nclarke> steshaw: You can set require-sandbox: True in your ~/.cabal/config to get it to complain if you're not in a snadbox
07:57:30 <dmwit> This is an issue I hadn't considered: when building an executable that you actually want, do you sandbox the build or not?
07:57:37 <dmwit> I don't know the answer to that, because I don't sandbox anything yet. =P
07:57:39 <steshaw> nclarke: thanks, that sounds like a good idea
07:57:49 <migimunz> Hello. I needed a function that, given two Maybe instances, returns either one if they're both Just and equal, and Nothing in all other cases. I implemented it like this https://gist.github.com/migimunz/4a2f2e5c86a0dca6db5b , but I think I'm probably overdoing it, I was wondering if there was a simpler way to do this.
07:57:59 <nclarke> dmwit: I do - see above comment about having multiple 'global' sandboxes
07:58:20 <nclarke> And the planned construction of something to manage moving them in+out of PATH
07:58:41 <dmwit> nclarke: (Have you looked at stow, by the way? It sounds a lot like your "move in and out of PATH" thing.)
07:59:07 * hackagebot loop 0.2.0 - Fast loops (for when GHC can't optimize forM_)  http://hackage.haskell.org/package/loop-0.2.0 (NiklasHambuechen)
07:59:09 * hackagebot reinterpret-cast 0.1.0 - Memory reinterpretation casts for Float/Double and Word32/Word64  http://hackage.haskell.org/package/reinterpret-cast-0.1.0 (NiklasHambuechen)
07:59:38 <steshaw> ncclarke: I have a little script that I use already to do PATH munging.\
07:59:55 <dmwit> migimunz: That looks okay. You could also equalM ma mb = do { a <- ma; b <- mb; guard (a == b); return a }
08:00:00 <dmwit> migimunz: Depends what you think is readable.
08:00:15 <steshaw> ncclarke: https://github.com/steshaw/shelly/blob/master/bin/app-path
08:00:53 <steshaw> nclarke: you might find it helpful
08:01:23 <migimunz> dmwit, thanks, I haven't seen equalM yet. I'm still new to haskell, and applicatives especially, so I tend to overcomplicate things with applicatives now :) .
08:02:03 <dmwit> migimunz: I'm not sure what "I haven't seen equalM yet" means. Didn't you (and I, afterwards) just implement it?
08:02:24 <nclarke> steshaw: Thanks!
08:02:31 <dmwit> migimunz: By the way, you might like a function that I find myself using a lot: ensure p x = x <$ guard (p x)
08:02:38 <migimunz> ah, sorry, I misread your example. things are not pretty-formatted in the irc client.
08:02:57 <dmwit> migimunz: Then you could also write equalM ma mb = do { a <- ma; b <- mb; ensure (a==) b }
08:03:19 <FreeFull> @pl equalM ma mb = do { a <- ma; b <- mb; ensure (a==) b }
08:03:19 <lambdabot> (line 1, column 19):
08:03:19 <lambdabot> unexpected '{'
08:03:19 <lambdabot> expecting variable, "(", operator or end of input
08:03:20 <migimunz> dmwit, which module is ensure from?
08:03:21 <dmwit> migimunz: Which comes closer to the spirit of your implementation, but has a reusable part (ensure) in place of retOne.
08:03:29 <dmwit> migimunz: Prelude.Dmwit ;-)
08:03:30 <jmcarthur> :t \a b -> guard (a == b) >> a
08:03:31 <lambdabot> (MonadPlus m, Eq (m b)) => m b -> m b -> m b
08:03:39 <FreeFull> @. pl undo equalM ma mb = do { a <- ma; b <- mb; ensure (a==) b }
08:03:39 <lambdabot> (line 1, column 59):
08:03:39 <lambdabot> unexpected ';'
08:03:39 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
08:03:46 <FreeFull> @undo equalM ma mb = do { a <- ma; b <- mb; ensure (a==) b }
08:03:46 <lambdabot> equalM ma mb = ma >>= \ a -> mb >>= \ b -> ensure (a ==) b;
08:03:55 <dmwit> jmcarthur: clever =)
08:04:01 <FreeFull> @pl  equalM ma mb = ma >>= \ a -> mb >>= \ b -> ensure (a ==) b
08:04:01 <lambdabot> equalM = (. ((. (ensure . (==))) . (>>=))) . (>>=)
08:04:32 <migimunz> the hell was that
08:04:42 <migimunz> haha awesome
08:04:58 <jmcarthur> i wish there was a guard for Alternative
08:05:05 <migimunz> jmcarthur, awesome solution, thanks!
08:05:22 <prophile> jmcarthur: presumably after the AMP gets in guard can move to Alternative
08:05:48 <dmwit> :t let ensure p x = x <$ guard p x in join . liftA2 $ ensure . (==)
08:05:49 <lambdabot>     Couldn't match type ‘f2 b0’ with ‘()’
08:05:49 <lambdabot>     Expected type: a1 -> f2 b0
08:05:49 <lambdabot>       Actual type: a1 -> ()
08:05:55 <jmcarthur> prophile: the AMP includes Alternative => MonadPlus?
08:06:03 <dmwit> :t let ensure p x = x <$ guard (p x) in join . liftA2 $ ensure . (==)
08:06:04 <lambdabot> (Applicative f, MonadPlus f1, Functor f1, Eq b) => f b -> f (f1 b)
08:06:04 <prophile> jmcarthur: I... think so?
08:06:11 <prophile> it would make sense, right?
08:06:21 <dmwit> :t let ensure p x = x <$ guard (p x) in (join .) . liftA2 $ ensure . (==)
08:06:22 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f b)
08:06:22 <lambdabot>     Expected type: (b -> b -> f1 b) -> f b -> f b -> f b -> f1 b
08:06:22 <lambdabot>       Actual type: (b -> b -> f1 b) -> f b -> f b -> f (f1 b)
08:06:22 <jmcarthur> it would. i just don't recall if that is a part of it
08:06:25 <dmwit> ugh
08:07:09 <prophile> http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
08:07:16 <dmwit> :t let ensure p x = x <$ guard (p x) in (join .) . liftA2 (ensure . (==))
08:07:17 <prophile> "Alternative becomes a superclass of MonadPlus"
08:07:17 <lambdabot> (Applicative m, MonadPlus m, Eq a) => m a -> m a -> m a
08:07:22 <jmcarthur> woohoo!
08:07:25 <dmwit> FreeFull: How about that alternative point-free version?
08:07:42 <FreeFull> Better
08:07:52 <FreeFull> I bet it could be shorter still
08:08:09 <jmcarthur> :t \f -> (join .) . liftA2 f
08:08:10 <dmwit> Oh, maybe. I was shooting for readable over short.
08:08:10 <lambdabot> (Applicative m, Monad m) => (a1 -> b -> m a) -> m a1 -> m b -> m a
08:09:14 <jmcarthur> i think i should finally propose bind, bind2, bind3, bind4   (e.g. bind2 :: (a -> b -> m c) -> m a -> m b -> m c )
08:10:00 <dmwit> jmcarthur: The problem is that there's an exponential number of such functions (exponential in the number of arguments).
08:10:13 <jmcarthur> but this pattern is fairly common
08:10:16 <jmcarthur> at least for me
08:10:32 <will___> hey what's a good resource for learning haskell?
08:10:40 <jmcarthur> it's just the monad-ish version of liftA
08:10:46 <haskellephant> will__: LYAH
08:10:58 <jmcarthur> it also subsumes a lot of the other patterns (you can get them by wrapping the arguments in return)
08:11:00 <haskellephant> will___: LYAH
08:11:01 <will___> http://learnyouahaskell.com/ this?
08:11:07 <haskellephant> will___: yes
08:11:10 <will___> thanks
08:11:27 <dmwit> jmcarthur: yeah
08:11:33 <dmwit> jmcarthur: I've wanted them before, too, for sure.
08:11:37 <jmcarthur> it doesn't compose quite as nicely as liftA2 does though, although it still does *something*
08:12:02 <jmcarthur> :t let bind2 x y z = x >>= \a -> y >>= \b -> z a b in bind2.bind2.bind2
08:12:03 <lambdabot> Monad m => m a2 -> ((m a3 -> a1) -> a) -> (((((a2 -> a3 -> m b2) -> m b2) -> a1 -> m a3 -> b1) -> m a3 -> b1) -> a -> (m a3 -> a1) -> b) -> (m a3 -> a1) -> b
08:12:12 <jmcarthur> is that even what i meant to do
08:12:15 <jmcarthur> :t let bind2 x y z = x >>= \a -> y >>= \b -> z a b in bind2
08:12:16 <lambdabot> Monad m => m a -> m a1 -> (a -> a1 -> m b) -> m b
08:12:19 <jmcarthur> no
08:12:27 <jmcarthur> :t let bind2 z x y = x >>= \a -> y >>= \b -> z a b in bind2.bind2.bind2
08:12:28 <lambdabot> Monad m => (a -> a1 -> m b) -> m (m (m a)) -> m (m (m a1)) -> m b
08:12:30 <jmcarthur> there
08:12:34 <dmwit> let bind2 = (join .) . liftM2
08:12:35 <dmwit> ;-)
08:12:42 <jmcarthur> yeah yeah
08:14:09 * hackagebot tagged-transformer 0.6.3 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.6.3 (MatveyAksenov)
08:26:17 <erisco> @pl \(x',y') (x,y) -> (x' ++ x, y' ++ y)
08:26:17 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (++)) . flip . (((.) . (,)) .) . (++))
08:26:26 <erisco> is there a nicer way to make it pointless? :)
08:26:56 <fizruk> erisco: <>
08:27:04 <erisco> hm?
08:27:13 <fizruk> > (“hi”, “as”) <> (“asdf”, “xcv”)
08:27:15 <lambdabot>  <hint>:1:2: lexical error at character '\8220'
08:27:20 <fizruk> wut?
08:27:23 <c_wraith> fizruk: please use real quotes
08:27:36 <fizruk> oh, that’s my client…
08:27:47 <erisco> > ("hey","foo") <> ("you","bar")
08:27:48 <lambdabot>  ("heyyou","foobar")
08:27:52 <fizruk> > ([1, 2], [3, 4]) <> ([5, 6], [7, 8])
08:27:52 <erisco> ah, simple, thanks
08:27:53 <lambdabot>  ([1,2,5,6],[3,4,7,8])
08:28:02 <c_wraith> standing out there in the cold, always doing what you're told?
08:28:03 <fizruk> erisco: pair of monoids is a monoid :)
08:29:10 <dp_wiz> @pl forM_ [0..h-1] $ \i -> new w >>= unsafeWrite arr i
08:29:10 <lambdabot> forM_ [0..h - 1] ((new w >>=) . unsafeWrite arr)
08:29:19 <nclarke> :t (<>)
08:29:20 <lambdabot> Monoid m => m -> m -> m
08:32:23 <jle`> erisco: there are various other combinators if you want to combine only the first or the second values too
08:32:51 <fizruk> :t (++) *** (++)
08:32:52 <lambdabot> ([a], [a1]) -> ([a] -> [a], [a1] -> [a1])
08:32:53 <jle`> nclarke: it's just mappend
08:45:56 <bananushka> hey, i'm kinda new to haskell and i'm trying to create a new type, and i want one of the fields to be an int, but with bounds that i define (like a meal data type, that has a price between min to max). how should i go about doing it?
08:47:44 <pavonia> YOu could hide the constructor from being exported and only provide construction functions to build values of that type that check for the correct range
08:47:56 <BeardedCoder> bananushka: I'll take a shot as another new haskeller. Don't expose the constructors, instead expose functions that create values in the right range
08:48:07 <BeardedCoder> pavonia beat me =)
08:49:50 <bananushka> pavonia, BeardedCoder: ok, and how should i define a global constant for MIN_PRICE and MAX_PRICE?
08:50:00 <seye> you'll have to jump through some extra hoops if you want to pattern match on your type if the constructor doesn't get exported though
08:50:26 <zipper> I am running cabal-init for the first time and came across a question on the base language I am using.
08:50:32 <zipper> I should assume haskell1010
08:50:40 <zipper> *haskell2010
08:50:49 <zipper> being on arch and all
08:51:16 <pavonia> bananushka: "minPrice = some value here"
08:51:53 <pavonia> bananushka: Constants are just like functions without parameters in Haskell
08:52:07 <bananushka> pavonia: oh, didn't think about using a function as a constant, i guess that's more haskelly
08:53:45 <bananushka> pavonia: what should my construction return? i mean, it should be able to fail for invalid prices, so should it be something like Maybe Meal?
08:54:36 <pavonia> That an option, yes
08:54:39 <pavonia> 's
08:55:04 <pavonia> e.g. "mkMeal :: Double -> Maybe Meal"
08:57:25 <bananushka> pavonia: is that something people do in haskell, or am i looking at the whole thing the wrong way?
08:58:28 <pavonia> I think that's what people would do
08:58:56 <cschneid> bananushka: the general pattern as I've heard it called is "smart constructor" - you'd make a Meal package that doesn't export the default constructors of that type, and instead has a mkMeal :: Double -> Maybe Meal function exported
08:59:08 <cschneid> so you can be 100% sure elsewhere in the code that any Meal object you have is valid
09:01:14 <bananushka> cschneid: so if i have a function that uses meal it should get Maybe Meal and pattern match against Just Meal and Nothing?
09:01:40 <cschneid> bananushka: perhaps.  More likely, you have some input (Double), and some output (Meal), and that spot should do the error handling.
09:01:47 <philipdexter> pavonia: "Constants are just like functions without parameters in Haskell" ,, are they? http://conal.net/blog/posts/everything-is-a-function-in-haskell
09:01:49 <gdoteof> I am not sure if I need posix support or haskell support.  I am using System.Posix.Semaphore  I have two functions, lock and unlock both use semOpen to open a semaphore and semWait & sendPost respectively.  the sem.whatever is being created in /dev/shm, but after the initial file is created all calls to semOpen with name="whatever" return permission denied
09:02:14 <cschneid> bananushka: or use something like the Maybe or Either monads to allow errors to get wired through cleaner. I wrote about it here: http://watchchrislearn.com/blog/2013/12/01/working-entirely-in-eithert/
09:02:20 <vanila> constants are not functions
09:02:40 <gdoteof> so if i start with a "clean" /dev/shm then the first call to "lock" works, but unlock gives permission denied http://lpaste.net/103412
09:02:46 <cschneid> bananushka: basically the monad lets you define the whole workflow, and the monad >>= operator handles the early-exit in case of failure.
09:02:47 <fizruk> vanila: I consider them functions
09:02:55 <vanila> fizruk, Why?
09:02:56 <fizruk> > mempty :: String
09:02:58 <lambdabot>  ""
09:02:58 <philipdexter> Read the link I posted
09:03:03 <fizruk> > mempty :: Sum Int
09:03:05 <lambdabot>  Sum {getSum = 0}
09:03:05 <philipdexter> fizruk: Read the link I posted
09:03:32 <vanila> fizbin, What about cases where are isn't any typeclass dispatch
09:03:44 <fizbin> ?
09:03:58 * fizbin /= fizruk
09:04:00 <cschneid> bananushka: but that's really just style differences - Maybe monad would be cool for a lot of perhaps-failing things (read in a list of Doubles, make a bunch of meals and present the menu), doing the pattern match against Just & Nothing would be cool for a thing that made one Meal
09:04:12 <vanila> fizruk, What about cases where there isn't any typeclass dispatch
09:04:12 <pavonia> philipdexter: I'm to lazy to read, what's his point?
09:04:36 <fizruk> vanila: why differ between them?
09:05:03 <vanila> fizruk, because you can desugar typeclass dispatch into dictionary passing
09:05:40 <fizruk> vanila: and you can desugar no context to empty list of dictionaries
09:05:52 <vanila> no
09:06:15 <corgifex> if constants are functions, what do they return?
09:06:16 <philipdexter> pavonia: point is that they aren't functions, and he goes through possibly reasons why people might believe they are
09:06:39 <fizruk> vanila: anyway it’s not only about contexts
09:07:16 <fizruk> > x = mempty :: (Int -> String)
09:07:17 <lambdabot>  <hint>:1:3: parse error on input ‘=’
09:08:13 <vanila> I think that this idea about "values are functions" is mixing up two meanings of function
09:08:17 <vanila> and this can cause confusion
09:08:38 <FreeFull> fizruk: Is it monoidal on the String, or on both?
09:08:45 <fizruk> FreeFull: String
09:08:47 <vanila> you could say "values are thunks" maybe
09:09:06 <fizruk> FreeFull: instance Monoid b => Monoid (a -> b)
09:09:10 <pavonia> philipdexter: I consider them as nullary functions
09:09:15 <FreeFull> > mempty :: (Int -> String)
09:09:17 <lambdabot>  <Int -> [Char]>
09:09:24 <FreeFull> fizruk: I see
09:09:43 <fizruk> vanila: i don’t usually think about thunks
09:10:32 <philipdexter> pavonia: he treats that argument as well, read the article if you want
09:11:58 <angerman> so, if I clone a repo of a haskell library to /foo/bar, and want to use that source instead of the one i installed with cabal install?
09:12:33 <thrakcattack> :t and
09:12:34 <lambdabot> [Bool] -> Bool
09:12:41 <fizruk> angerman: cd into repo then “cabal install”
09:13:13 <fizruk> angerman: “cabal install” without arguments that is
09:13:27 <fizruk> angerman: it will use local .cabal
09:13:29 <angerman> fizruk: and if i want to hack on the source as well? hack -> cabal install -> test -> hack -> cabal install -> test?
09:14:02 <fizruk> angerman: smth like that, but for testing you don’t need to install it I guess
09:14:14 <fizruk> angerman: also you might want to do all that in a sandbox
09:14:27 <cschneid> angerman: to hack on a single project - cabal sandbox works well. keeps your changes localized to your directory
09:15:31 <angerman> fizruk, cschneid: let me elaborate a little: so I have my project X that depends on library Y, but Y is lacking some functionality that I'd like to put in Y and contribute back instead of hacking it in X ontop of Y.
09:15:50 <cschneid> angerman: yeah, cabal can do that, I don't remember the syntax.
09:16:21 <cschneid> angerman: this seems to do it : http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
09:16:28 <cschneid> under the Usage headline
09:16:32 <angerman> fizruk, cschneid: now if this was one of the langauges I was more acustomned to (say objc), I'd tell the build system I use for running the code, to use the source of the library Y and hack away.
09:17:05 <cschneid> angerman: yep, in ruby, the gemfile would say something like `gem 'my-dep', :path => '/home/cschneid/my_forked_my-dep/'
09:17:06 <angerman> cschneid, thanks, will take a look.
09:17:08 <cschneid> that's what that link does
09:17:09 <pavonia> philipdexter: I can't really see an argument against that view. Sure, a constant is a definition but why can't it be a nullary function too?
09:17:29 <cschneid> your cabalfile would still reference the project it needs, and then the sandbox hint with add-source says where to find it
09:18:17 <fizruk> pavonia: i guess nullary functions conflict with “any function is actually 1-ary” :)
09:18:21 <philipdexter> pavonia: I think the answer is simply "because it's not". It could possibly be thought of as one, but why promote it to a function when it's simply not a function?
09:18:58 <pavonia> That brings us to the question what a function actually is
09:19:16 <fizruk> philipdexter: sometimes you can’t tell if it is or not
09:19:48 <bananush1a> is it possible to pattern match a range in haskell?
09:19:53 <philipdexter> fizruk: that what is what?
09:20:16 <fizruk> philipdexter: is mempty a function or not?
09:21:07 <fizruk> :t isPrefixOf
09:21:08 <lambdabot> Eq a => [a] -> [a] -> Bool
09:21:16 <angerman> ohh, I need cabal-dev... alright.
09:21:19 <simukis_> bananush1a: you want to use guards instead.
09:21:19 <pavonia> bananush1a: What does it mean to match on a range?
09:21:25 <pjdelport> fizruk: There's not a strong distinction between values and "nullary functions" in Haskell.
09:21:37 <fizruk> angerman: you don’t, why did you think you do?
09:21:51 <angerman> err, I ment cabal develop version.
09:22:04 <fizruk> angerman: why?
09:22:06 <angerman> I only have 1.16.0
09:22:18 <angerman> sandboxes are 1.18+ as far as I understand.
09:22:36 <fizruk> cabal updatecabal install cabal-install
09:23:05 <fizruk> cabal update; cabal install cabal-install
09:23:10 <fizruk> sorry for mess
09:23:31 <angerman> fizruk: let's see :)
09:23:54 <philipdexter> fizruk: if you count dictionary passing after a transformation, then I'm guessing you would count it as a function, however I don't think the answer to that would affect an argument as to whether i in `i = 7' is a function
09:24:31 <fizruk> philipdexter: 7 is actually fromIntegral 7 :: Num a => a, so…
09:24:36 <fizruk> :t 7
09:24:38 <lambdabot> Num a => a
09:24:52 <bananush1a> simukis_: thanks!
09:28:36 <fizruk> philipdexter: in addition: is this a function?  inc :: State Int ()
09:29:40 <philipdexter> fizruk: good catch, what about `7 :: Int' or `"hi"'?
09:30:31 <fizruk> philipdexter: i prefer to think of all those as functions just to simplify thing for myself :)
09:30:51 <fizruk> philipdexter: also don’t forget about OverloadedStrings ;)
09:31:37 <philipdexter> fizruk: hah, yeah
09:31:49 <zipper> Is there a command one can run that will tell them the build dependencies for their package?
09:32:02 <philipdexter> fizruk: I probably don't know enough to have strong opinions either way
09:32:43 <zipper> Can I get a bit of help with identifying the build dependencies and if possible reducing them in the following https://bitbucket.org/urbanslug/ix-client
09:33:06 <fizruk> philipdexter: I just don’t think the answer matters that much to argue about - there is no superclear answer :)
09:33:32 <philipdexter> fizruk: truth
09:39:57 <epta> Is there any cabal-graphdeps analog that could be used for local .cabal files?
09:46:32 <augur> anyone have a link discussing row polymorphism in haskell? i cant find the one i remember :\
09:47:37 <tommd> Augur: You are probably looking for a Mark Jones paper
09:47:45 <augur> i found it, actually. :D
09:48:08 <corgifex> rowly poly
09:48:23 <tommd> ... was it by Jones?
09:56:05 <gdoteof> http://lpaste.net/103412  still trying to figure out how to use semaphores correctly.  the linked code gives me permission denied errors if the semaphore already exists
09:57:22 <kludgy> Hi all, taking a dive into HXT, and I'm wondering: does anyone know why (Text.XML.HXT.Parser.XmlParsec.xread "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>") fails to parse? Result is: [NTree (XError 2 "\"string: \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\"\" (line 1, column 6):\nunexpected xml\nexpecting legal XML name character\n") []]
09:57:43 <exicer> How can one use catch within an EitherT a IO b monad ?
09:59:26 <kludgy> Here's the failing HXT parse: http://lpaste.net/103416
09:59:28 <pavonia> exicer: Wild guess: liftIO $ catch ...
10:01:44 <exicer> pavonia: That is what I tried, but no luck
10:02:08 <pavonia> What is the error message?
10:02:42 <kludgy> Nvm I just found the answer here: https://github.com/UweSchmidt/hxt/issues/4   ... readDocument or parseXmlDocument must be used to handle XML declarations
10:03:07 <exicer> It expects the error handler to be IO b!
10:05:24 <mmachenry> gdoteof: Not sure what the semaphore name does, but it looks like a filename. I think you're just not able to write to the file system.
10:05:28 <geekosaur> gdoteof, POSIX IPC semaphores are usually not the right tool... they have lots of weird gotchas. were you looking for pthread semaphores?
10:05:32 <geekosaur> mmachenry, no
10:05:37 <geekosaur> it's a horrid hack
10:06:10 <geekosaur> hm, actually it might well have a write error since ftok() requires an existing file
10:06:10 <kludgy> @exicer Can you bring your error handler result into IO with return or evaluate? (http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Exception-Base.html#v:evaluate)
10:06:10 <lambdabot> Unknown command, try @list
10:06:11 <mmachenry> gdoteof: Does this need to use Posix instead of something like Software Transactional Memory? Will this semaphore be shared with another process?
10:06:40 <geekosaur> (also to be confusing there are two different kinds of POSIX semaphores; one is associated with pthreads, the other with POSIX IPC)
10:07:24 <hunt> is there any function that takes Monad m => m a -> m a -> m [a]?
10:08:09 <fizruk> :t liftA2 (,)
10:08:10 <lambdabot> Applicative f => f a -> f b -> f (a, b)
10:08:25 <hunt> :t (,)
10:08:26 <lambdabot> a -> b -> (a, b)
10:08:28 <fizruk> :t liftM2 (\x y -> [x, y])
10:08:28 <bennofs> hunt: what is that function supposed to do? Create a 2-element list?
10:08:29 <lambdabot> Monad m => m t -> m t -> m [t]
10:08:43 <fizruk> hunt: ^ ?
10:08:44 <hunt> bennofs: well id like to take 3 and make a 3 element list actually
10:09:11 <bennofs> hunt: maybe you're looking for sequenceM
10:09:14 <bennofs> @ty sequence
10:09:14 <lambdabot> Monad m => [m a] -> m [a]
10:09:19 <fizruk> hunt: why not `sequence [m1, m2, m3]` ?
10:09:21 <bennofs> oops, s/sequenceM/sequence
10:09:22 <hunt> yea i am thanks bennofs
10:09:35 <hunt> sequenceM or sequence?
10:09:38 <hunt> :t sequenceM
10:09:39 <lambdabot>     Not in scope: ‘sequenceM’
10:09:39 <lambdabot>     Perhaps you meant one of these:
10:09:39 <lambdabot>       ‘sequence’ (imported from Control.Monad.Writer),
10:09:45 <hunt> ok sequence
10:09:46 <hunt> thanks
10:10:11 <mmachenry> gdoteof: Does this need to share with an outside process?
10:10:45 <epta> 033[4~033[4~033[4~033[4~033[4~033[4~
10:10:56 <geekosaur> meow to you too :p
10:11:07 <epta> Sorry for that :[
10:13:57 <hunt> monad fold like mapM_?
10:14:27 * hackagebot http-client 0.3.2.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.2.1 (MichaelSnoyman)
10:15:55 <geekosaur> mapM is not a fold, it's a map :)
10:15:57 <geekosaur> :t foldM
10:15:58 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
10:16:11 <gilligan_> hi
10:19:00 <corgifex> @src map
10:19:00 <lambdabot> map _ []     = []
10:19:00 <lambdabot> map f (x:xs) = f x : map f xs
10:19:06 <corgifex> @src sequence
10:19:06 <lambdabot> sequence []     = return []
10:19:06 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:19:06 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
10:20:22 <corgifex> :t \f -> foldr (liftM2 (:) . f) (return [])
10:20:23 <lambdabot> Monad m => (a -> m a1) -> [a] -> m [a1]
10:22:30 <pavonia> exicer: Sorry, missed your message. Yes, EitherT treats errors differently than catch does. I think you have to catch the errors after evaluating runEitherT
10:22:45 <vanila> :t mapM
10:22:46 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
10:22:56 <pavonia> exicer: You might also want to have a look at ErrorT
10:36:45 <gdoteof> mmachenry: no it doesn't
10:37:43 <geekosaur> if that was an answer to "does this need to be shared with another process" then you are not using the right kind of semaphore
10:37:48 <geekosaur> IPC semaphores are weird
10:37:57 <geekosaur> (gdoteof ^^)
10:37:58 <gdoteof> mmachenry: so i am definitely able to write to it.  it fails if the file is there already
10:38:20 <gdoteof> if it isn't there the it is opened correctly, but subsequent calls fail
10:38:41 <mmachenry> gdoteof: Can you use SafeSemaphore instead? https://hackage.haskell.org/package/SafeSemaphore
10:38:55 <geekosaur> I also would not be surprised if the interface wrapper does the wrong thing in that case through someone not understanding what's up with the ftok() stuff, which is weird even by the standards of SysV IPC
10:39:32 <mmachenry> You're getting errors because you're writing to files and perhaps the user you're running as has no permission or cannot overwrite it. But it might be simpler to just avoid the OS.
10:39:34 <gdoteof> geekosaur: i will look at pthread semaphore..  generally i have a 'dumb' outside process i need to talk to through a single named pipe; i need to lock requests to that process/resource
10:39:58 <geekosaur> hm, that would require something like ipc semas then
10:40:33 <mmachenry> gdoteof: Oh, so it does need to communicate with an outside process.
10:40:44 <gdoteof> mmachenry: the semaphore itself doesn't
10:40:46 <geekosaur> in theory if you are forking that other process then you can use pthread semas --- but in practice some platforms do not implement that case (linux, last I heard) and if you were doing that then you wouldn't need to use a fifo, you could use an ordinary pipe
10:42:03 <geekosaur> I would suggest that something simpler might be worth using, like a lockfile. simple implementatin is to just try to link the named pipe to a lock ame in the same directory, if it succeeds you have the lock, if it fails then something else has it locked
10:42:08 <geekosaur> unlink the lock name when done
10:42:12 <gdoteof> my_haskell_prorgram <--pipes--> blackbox resource  my haskell process is a webapp that without hte semaphore will sometimes make a second call to the blackbox before the first one has returned; which results in brokenlogic
10:42:44 <gdoteof> geekosaur: that was originally what i was going to do; then i saw the semaphore implementation and tried to use it.. which is still essentially just a lockfile
10:42:56 <geekosaur> IPC semas look simple but have annoying issues, like you typically need a second semaphore in an array to lock the first...
10:43:36 <gdoteof> then i was also thinking i didn't have permissions, but the webapp is creating the lockfile; but subsequent calls to semOpen to it always fail; like i have write access but not read, or something
10:44:23 <geekosaur> right, you might need to strace/truss/kytace/dtruss/whatever-per-platform to see where it's failing, because it could be the ftok() or the actual semaphore operation
10:46:24 <geekosaur> (quick summary: IPC semaphores do not live in the filesystem, but by convention you generate a distinct IPC key to name it by using an existing file as a reference. ftok() does this mapping. but the file must exist, so wrappers may create it if needed. or may remove and recreate it if the coder didn't understand what the whole ftok() business is about.)
10:46:32 <geekosaur> (the latter will break things pretty well.)
10:50:43 <gdoteof> geekosaur: alright.  so if i am understanding you correctly there is just a possibility that System.Posix.Semaphore is broken either generally or I'm finding a bug
10:50:48 <pyon> ParsecT is a monad transformer, right? Is there any way to make the underlying monad provide the stream of tokens?
10:50:55 <geekosaur> it is possible, yes
10:51:22 <geekosaur> because the interface you showed in your test suggests that the author didn't really understand IPC semaphores
10:53:04 <Twey> pyon: http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-ParserCombinators-Parsec-Prim.html#v:setInput
10:54:28 <pyon> Twey: Ah, thanks!
10:54:32 <Twey> pyon: lift inputGettingAction >>= setInput
10:54:57 <pyon> Yeah.
10:57:08 <Twey> What's a nice library for numeric integration?
10:57:51 <Twey> There's some stuff in hmatrix but I don't really want to pull that in when all I want is the integration functions, if I can avoid it.  Also it only works on Double, so I'd have to constrain everything.
10:58:04 <Twey> (I'm actually working on complex values, anyway)
11:00:51 <Taneb> Twey, try http://hackage.haskell.org/package/integration ?
11:00:59 <Taneb> I don't know much about it, though
11:02:08 <Twey> It's Double everywhere again
11:02:41 <Twey> Oh, there's a complex-integrate package
11:03:48 <umib0zu> anyone up?
11:04:24 <Twey> ‘import Data.Complex -- We will work with complex numbers’ but it doesn't x.x
11:04:47 <Twey> umib0zu: It's early evening in the UK; I should hope so :þ
11:05:56 <umib0zu> I see I see. I had some question about type theory but this chat room is always hit or miss
11:06:24 <Twey> Really?  It's usually quite active
11:07:44 <pavonia> Chances to get an answer are even higher if you ask an actual question
11:09:56 <umib0zu> I'm wondering about closure and this concept of extensional and intensional equality. I'm kind of not understanding what the difference is between extensional and intensional.
11:10:42 <c_wraith> extensional is an external view.  Two sets are extensionally equal if they contain the same elements.
11:11:03 <c_wraith> intentional is an internal view.  Two sets are intensionally equal if they have the same definition.
11:11:28 <c_wraith> Or so a mathematician told me. :)
11:11:36 <umib0zu> ahh
11:11:37 <umib0zu> ok
11:11:41 <Twey> umib0zu: Intensional equality ≈ syntactic equality
11:12:14 <Twey> umib0zu: Though it's often extended with things like α-equivalence or η-equivalence
11:12:27 <umib0zu> that makes more sense. the book was hinting at the fact that extensional equality is used to help show two lambda expressions are equal even if they don't actually have the same program.
11:12:42 <umib0zu> but its obvious extensional functions can be substituted
11:13:05 <umib0zu> so wait hang on. what's the point of closure then?
11:13:18 <umib0zu> I'm seeing its related in the reading, but I don't see why.
11:13:54 <Twey> umib0zu: Closure of what?
11:14:09 <umib0zu> closure of an expression with free variables
11:14:43 <umib0zu> I'm hoping this is the same "closure" people talk about in javascript and haskell as well
11:14:54 <dmj`> The forkOn function in Control.Concurrent lets you specify on which processor the thread will run. If a child process is spawned via a forked thread will it use the same processor that the original thread was specified on as well?
11:15:05 <Twey> umib0zu: I don't know whether it is or not.  You'd need to give some context
11:15:14 <c_wraith> dmj`: I wouldn't count on it
11:15:58 <dmj`> c_wraith: hmmmm, wonder why
11:16:34 <umib0zu> Twey its kind of weird. This book defines a closure exactly as taking an expression with free variables, then adding binding constructs to make it a function that will bind the free variables. maybe I'll take another read at this and see what it has to do with extensional equality, but its related.
11:16:49 <Twey> umib0zu: A ‘closed expression’ is one that contains no free variables.  The ‘closure of an expression’ is some sort of context that makes the expression closed.
11:17:22 <c_wraith> dmj`: I expect forkIO to not care how the thread that calls it was created.
11:18:11 <Twey> umib0zu: Imagine the functions let x = 3 in (\ y → x) vs. let x = 3 in (\ y → x)
11:18:12 <umib0zu> actually while we're on the topic, I'm actually wondering what the point of closures are. I'm from javascript and python, and for some reason people say lambda expressions and the function definition are binding constructs for closures
11:18:15 <umib0zu> is this right?
11:18:52 <Twey> umib0zu: Even though both of these functions have the same syntactic form, ‘(\ y → x)’, they're not the same function because the ‘x’ to which they refer is different
11:19:22 <Twey> umib0zu: So if you want to perform intensional equality checking on them, you need access to their closures in order to substitute the x first/when you encounter it
11:20:04 <dmj`> c_wraith: If I tids :: IO [TheadId] <- mapM (\x -> forkOn x action) [1..10] and inside each action I call "runInteractiveProcess ls -lah" you're saying the process by which runInteractiveProcess uses is up for grabs since the execution of a sub process is out of ghc's control now
11:20:33 <dmj`> processor* not process
11:20:51 <umib0zu> Twey ahh they mentioned this. functions are intensionally equal depending on their context.
11:21:03 <c_wraith> dmj`: well, you're talking about FFI calls now, which are an entirely different topic.
11:21:33 <Twey> umib0zu: The ‘point’ is kind of hard to express, since they have a lot of uses in programming.  But in general, if you don't have closures (like in standard C) you can't ‘create’ functions according to local variables.  In C you can take function pointers as arguments, store them, and pass them around, but it's not usually considered ‘functional’ because of this inability to *create* functions
11:21:49 <augur> Twey: uh...
11:21:50 <augur> what
11:21:52 <c_wraith> dmj`: all FFI calls marked safe are performed from native threads created specifically for the purpose of making native calls
11:22:20 <Twey> Yeah, that didn't go quite where I expected it to
11:22:21 <umib0zu> so Twey, by create you mean provide binding constructs and the expression with free variables?
11:22:41 <c_wraith> dmj`: if you want control over what native threads are making FFI calls, you need to a) be careful and b) use forkOS
11:22:56 <augur> Twey: you realize you used the same value for x there, right
11:23:04 <Twey> augur: >.<
11:23:05 <augur> Twey: so consequently those _are_ the same function... :x
11:23:27 <Twey> umib0zu: Please substitute 5 or something for one of the RHSes of ‘x’ in the above example :þ
11:24:00 <Twey> umib0zu: Having closures is what allows a function to have different behaviours depending on the things in scope in the function where it was created
11:24:19 <umib0zu> that's fine. so my friend was telling me because I know javascript, I don't understand this. I think its because function definition and inline callback functions are closures. in python there's actually a syntactic difference between a function definition and a lambda expression. is that right?
11:24:40 <augur> Twey: may i try explaining a different way?
11:24:44 <Twey> Please do
11:24:54 <umib0zu> well that's another thing. examples on wiki show a function with a really really free variable. like I don't see its definition anywhere.
11:24:57 <augur> umib0zu: consider the two functions   \y -> 3   and   \y -> 5
11:25:02 <augur> we agree these are different, right?
11:25:02 <corgifex> python distinguishes between named and anonymous functions ("lambda"). a lambda can only contain a single expression
11:25:17 <umib0zu> augur yeah
11:25:45 <augur> umib0zu: ok
11:25:56 <augur> umib0zu: so, in the LC, there are two equivalent ways of interpreting lets
11:26:34 <augur> umib0zu: method one is like this:   let x = 3 in \y -> x   is just a way of saying \y -> 3, but with some more convenient syntax
11:27:05 <augur> umib0zu: eg if you use x multiple times, its nice to factor out the definition of x so you can see it in all its places, but really, when you ask what this is, its just \y -> 3
11:27:13 <augur> because we just substitute 3 for x in the scope of the let
11:27:16 <augur> does that make sense?
11:27:23 <umib0zu> yup
11:27:53 <augur> an alternative, completely equivalent way, is to keep a big list of variable bindings. a big dictionary saying x is 3, z is whatever, yadda yadda
11:28:36 <augur> umib0zu: the alternative is generally better for efficiency, because substitution means you have to dig down through the entire bit of code for every let
11:29:03 <corgifex> what about (\x -> \y -> x) 3?
11:29:27 <augur> umib0zu: does that make sense still?
11:29:40 <umib0zu> yeah
11:29:42 <augur> (corgifex: same thing)
11:30:14 <dmj`> c_wraith: I'd like to have 10 threads running, one for each core, and they each to spawn sub processes that execute on the same core. Sounds like forkOS is what I need but System.Process doesn't to allow me to choose what core to run on... should I make my own ffi bindings to the given process?
11:30:20 <augur> umib0zu: ok, so notice that if you do the alternative, you cant just have bare terms. you need to somehow keep track of these bindings somehow
11:30:49 <umib0zu> yeah. binding construct?
11:31:08 <augur> umib0zu: one way of handing that is to bundle code with its environment. so when you compute    let x = 3 in \y -> x    you secretly bundle up the environment
11:31:20 <augur> it computes to \y -> x + the env that says x = 3
11:31:24 <c_wraith> dmj`: If I just accept your stated requirements as set in stone, my solution is to do something else, because that's not really a reasonable request.
11:31:37 <c_wraith> dmj`: You may not have as much flexibility as me. :)
11:31:39 <augur> umib0zu: does that still make sense?
11:31:55 <corgifex> augur: holy shit, you're explaining ploki
11:32:02 <augur> corgifex: ploki?
11:32:11 <corgifex> esoteric language I wrote
11:32:33 <augur> corgifex: uh.. ok. im just describing the standard environment model of evaluation, but whatever floats your boat!
11:32:40 <augur> umib0zu: ?
11:32:44 <umib0zu> sort of. so you're saying the language compiler takes let expressions and creates an environment?
11:32:51 <corgifex> it doesn't have real functions or lexical environments or lambda, but it has a "substitute x by its value in this expression and freeze it" kind of operator
11:33:29 <augur> umib0zu: right. when you compute the value of that bit of code, it says, here's the value: \y -> x (secretly with the environment x = 3)
11:33:38 <umib0zu> ok
11:33:56 <augur> umib0zu: closures = lambda's with their environment
11:34:11 --- mode: corgifex set -o corgifex
11:34:18 <dmj`> c_wraith: sounds like you might know what I'm trying to do :) I guess an alternative would be to have 10 haskell executables running, no forking of threads necessary, but then no guarantee on processor allocation either
11:34:33 <dmj`> core* allocation
11:34:37 * hackagebot cassava 0.4.0.0 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.4.0.0 (JohanTibell)
11:36:48 <umib0zu> so like a python "lambda y : ( ( lambda x : x) 2 )" is the same as "let x = 2; (/y -> x)
11:37:07 <augur> eh
11:37:19 <augur> its more like
11:37:31 <augur>    x = 3
11:37:36 <augur>    lamda y: x
11:37:58 <corgifex> that looks messed up
11:38:06 <augur> but keep in mind: stateful languages like python _dont_ let you equate those two things like i did
11:38:11 <LordBrain> i joined #python?
11:38:17 <corgifex> did you mean: (lambda x: lambda y: x)(2)
11:38:30 <umib0zu> LordBrain just trying to find out what a closure is
11:38:32 <augur> also yes, what corgifex said
11:38:42 <cschneid> ohh, finally updated to ghc 7.8 on my mac - nice to see the end of those crazy preprocessing warnings
11:38:50 <umib0zu> corgifex yeah
11:39:24 <corgifex> there's, like, secretly an array [3] bundled with a function lambda y: @0
11:39:35 <corgifex> the @0 means "index 0 in the array"
11:39:37 <LordBrain> basically, closures make use of identifiers which are bound because they are in scope, but they were not passed in as parameters to the function
11:40:02 <umib0zu> so ok, but now my issue is this "environment". the wiki for closure has a function with a free variable. but how can I use this function in two separate environments and have it bind? and what's the binding construct? or is it done automatically by the compiler?
11:40:25 <corgifex> binding happens automatically (in all languages I know)
11:40:27 <augur> umib0zu: im not sure i understand what you mean
11:41:03 <corgifex> when the function definition is executed, its free variables connect to the surrounding scope
11:41:05 <corgifex> or something
11:41:11 <LordBrain> umib0zu, say you return that function to a calling function in a different scope
11:41:19 <pjdelport> umib0zu: It's done automatically, yeah.
11:41:28 <augur> ok ok too many cooks in the kitchen
11:41:29 <LordBrain> its automatic yes
11:41:46 <umib0zu> http://en.wikipedia.org/wiki/Closure_(computer_programming)#First-class_functions
11:41:50 <augur> umib0zu: can you clarify your question a bit?
11:42:04 <umib0zu> ^^ in this thing for javascript, booklist is free
11:42:26 <corgifex> right
11:42:38 <augur> umib0zu: its free, but somewhere else it was defined
11:42:43 <augur> like with the let
11:42:44 <corgifex> it's assumed to be global or something
11:43:02 <augur> these definitions are done in the scope of some definition
11:43:16 <corgifex> the focus of the example is 'threshold'
11:43:29 <augur> umib0zu: that page is misleading because it doesnt show you the whole program
11:43:52 <umib0zu> yeah I didn't even know threshold was the focus
11:44:26 <corgifex> function make_counter() { var i = 0; return function () { return i++; }; }  // standard imperative closure example
11:44:42 <corgifex> var f = make_counter(), g = make_counter();
11:45:12 <corgifex> [ f(), f(), g(), f(), g() ]  // [ 0, 1, 0, 2, 1 ]
11:45:16 <LordBrain> in side-effecting languages, you can use a closure to simulate objects, you just return the 'method' functions from a function and now all those method functions can treat the environment of the original function like their own little private data area.
11:46:05 <umib0zu> that makes a bit more sense actually
11:46:32 <augur> :)
11:46:48 <augur> the key is that you're always secretly bundling the environment with the value
11:46:55 <LordBrain> i think that's actually idiomatic if you are doing oo in lisp or scheme, but it's been a long time so i'm not sure if it is still the recommended practice.
11:47:03 <umib0zu> idk I'm so used to doing things like this and I haven't really done anything else in a language like java, so I haven't really separated the difference.
11:47:21 <augur> umib0zu: you might want to watch SICP
11:47:41 <umib0zu> watch?
11:47:50 <augur> there are videos!
11:48:04 <corgifex> function make_counter(i) { return function () { return i++; }; }  var f = make_counter(0), g = make_counter(20); [ f(), g(), f(), g(), g(), f() ]  // [ 0, 20, 1, 21, 22, 2 ]
11:48:18 <augur> umib0zu: http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
11:48:23 <corgifex> I fucking love counters
11:49:13 <augur> umib0zu: https://www.youtube.com/watch?v=2Op3QLzMgSY&list=PL8FE88AA54363BC46
11:50:42 <sahadev> hello haskellers, I am trying to rewrite a function in point-free style. the original function is: f xs ys = all (== 0) $ zipWith (*) xs ys, which I rewrote as: f = (all (== 0)) . (zipWith (*))
11:51:07 <corgifex> @pl f xs ys = all (== 0) $ zipWith (*) xs ys
11:51:08 <lambdabot> f = (all (0 ==) .) . zipWith (*)
11:51:08 <sahadev> it does not typecheck in ghci
11:51:27 <corgifex> f (g x y) is not the same as (f . g) x y
11:51:32 <augur> sahadev: because zipWith has two arguments you need to give, you need to compose twice, not just once!
11:51:33 <corgifex> the latter is f (g x) y
11:51:47 <sahadev> i see. thanks.
11:52:05 <pjdelport> There's a common trick for this: (.) . (.)
11:52:16 <corgifex> did you mean: fmap fmap fmap
11:52:21 <augur> :t (.:)
11:52:22 <lambdabot>     Not in scope: ‘.:’
11:52:22 <lambdabot>     Perhaps you meant one of these:
11:52:22 <lambdabot>       ‘.’ (imported from Data.Function),
11:52:26 <augur> shame :(
11:52:46 <pjdelport> :t let (.:) = (.).(.); foo = (all (0 ==)) .: zipWith (*) in foo
11:52:47 <augur> @hoogle (a -> b) -> (c -> d -> a) -> c -> d -> b
11:52:48 <lambdabot> (Num a, Eq a) => [a] -> [a] -> Bool
11:52:49 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
11:52:49 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
11:52:49 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
11:52:56 <augur> :\
11:53:27 <augur> i guess theres no standard form for this. thats really a shame. we should have standard compositions up to a certain length
11:53:34 <augur> with dependent types you could do this!
11:54:01 <corgifex> just add fmap
11:54:06 <augur> :P
11:54:31 <augur> there are other ways of course. liftA's for instance. but thats nasty cause you need applicative in scope
11:54:37 <augur> better to have a prelude function
11:54:48 <augur> or better to have a generic compose with dependent types! :x
11:55:02 <corgifex> I don't see how a generic compose could work
11:55:21 <corgifex> functions don't have a specific arity in general
11:55:34 <augur> corgifex: dependent types are nice that way :)
11:56:01 <pjdelport> augur: There's http://hackage.haskell.org/package/composition-1.0.1.0/docs/Data-Composition.html
11:58:19 <augur> pjdelport: sure. still, importing mroe things, blegh
11:58:48 <augur> pjdelport: i'd rather write f o[ 2 ] g
11:59:15 <thrakcattack> :t (&&&)
11:59:16 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
12:00:40 <j0ni> hi, i have a n00b question about foldr and something i read in learn you a haskell, hope someone can shed some light
12:00:45 <j0ni> here is the line:
12:00:47 <j0ni> "One big difference between the two types of folds is that right folds work on infinite lists, whereas left ones don’t!"
12:01:03 <j0ni> my question: what does it mean to begin with the right-most element of an infinite list?
12:01:08 <corgifex> nothing
12:01:13 <corgifex> but that's not what foldr does
12:01:22 <corgifex> @src foldr
12:01:22 <lambdabot> foldr f z []     = z
12:01:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:01:40 <corgifex> the point is that for a non-empty list, foldr immediately calls f
12:01:52 <corgifex> if f doesn't use its second argument, the rest of the list is never examined
12:02:27 <corgifex> > foldr (\x _ -> x) 0 [1 ..]
12:02:28 <lambdabot>  1
12:02:54 <corgifex> > foldr (\x _ -> x) "" (repeat "hello")
12:02:55 <lambdabot>  "hello"
12:03:01 <j0ni> ok, thank you, i need to digest this a bit
12:03:43 <corgifex> (also crucial: lazy evaluation proceeds from the outside in, not inside out)
12:03:56 <corgifex> that is, f x (foldr ...) does not call foldr first, but f
12:12:21 <augur> umib0zu: for type theory, try
12:12:26 <augur> @where oplss2012
12:12:26 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
12:12:41 <augur> umib0zu: watch pfenning first, then harper
12:13:54 <seye_> j0ni: i seem to remember that LYAH drops that on you and lets you stew for a few pages then picks up again with an example of how this works
12:15:14 <quchen> j0ni: LYAH is wrong in its description of foldr.
12:15:33 <quchen> Both foldr and foldl walk a list from beginning to end, none of them do it in reverse.
12:16:41 <cschneid> With Lens, given a structure like this, how would I get all keys inside the default key? (result ["pool", "adapter", "timeout"]): Object fromList [("default",Object fromList [("pool",Number 5.0),("adapter",String "sqlite3"),("timeout",Number 5000.0)])]
12:16:58 <cschneid> Getting any value is easy enough  yml ^? key "default" . key "pool"
12:17:00 <c_wraith> quchen: it's.. kind of more subtle than that, if you look at evaluation order details.  foldr is a mess to explain to someone who doesn't grasp laziness thoroughly.
12:17:41 <albeit> I'm getting a stack overflow in this code (http://lpaste.net/103429), but I can't tell why. I'm forcing evaluation of the nested values that would be lazy... any ideas?
12:17:45 <corgifex> @where diagrams
12:17:45 <lambdabot> http://projects.haskell.org/diagrams/
12:18:22 <c_wraith> albeit: often forcing evaluation of nested values causes stack overflows.  Don't just do that blindly. :P
12:19:23 <albeit> c_wraith: Okay. Are there good rules of thumb to follow for when to do it? I'm just having trouble determining what is causing stack overflows, and forced evaluation (used to) solve most of them.
12:20:15 <edwardk> c_wraith: you want the keys or the values?
12:20:26 <jmitePlus> Could somebody help me with an encoding problem? I'm trying to install QuickCheck, but I get the following error: "tf-random-0.5 failed during the final install step. The exception was:
12:20:27 <jmitePlus> /tmp/pkgConf-tf-random-01570.5: hGetContents: invalid argument (invalid byte
12:20:29 <jmitePlus> sequence) "
12:20:31 <c_wraith> edwardk: I think I sniped your tab-complete
12:20:40 <jmitePlus> My $LANG is "en_CA.UTF-8"
12:20:53 <edwardk> cschneid: you want the keys or the values?
12:21:00 <cschneid> edwardk: the list of keys.
12:21:15 <cschneid> although presumably the answer would be easy enough to translate to the list of values too. :-/
12:21:33 <c_wraith> albeit: a rule of thumb would be that you want to force evaluation when it results in using less memory.
12:22:07 <edwardk> xs^..key "default"._Object.itraversed.asIndex
12:22:32 <c_wraith> albeit: that's not just blindly facile advice.  I mean to actually think of the memory structures, and the use pattern for your algorithm.
12:22:39 <edwardk> _Object gets you out the HashMap for the object
12:22:39 <l0cust> Is there some reason hackage doesn't have an option for the BSD2 license?
12:22:54 <cschneid> edwardk: awesome.
12:22:58 * geekosaur eyes cabal config for tf-random, wonders what encoding it is using
12:23:02 <c_wraith> albeit: When you're folding a big structure into a result of some sort? forcing evaluation instead of letting thunks build up is a big win.
12:23:02 <edwardk> itraversed walks all of its elements with the key as the index, asIndex replaces the answers with the indices
12:23:12 <cschneid> edwardk: the lens lib is so easy when you see it... but hard to get it lined up right. :)
12:23:13 <cschneid> thank you
12:23:36 <c_wraith> albeit: when you're generating a big structure, you should prefer to do it lazily, to minimize memory use
12:26:48 <athan> Does anyone know of an "openFile" implementation that returns a handle to stdin if a file wasn't found?
12:27:21 <c_wraith> albeit: also, you should understand exactly what bang patterns do and do not do.  putting one an argument of type [a] for any a is pretty useless.  It'll just force it to determine whether the list is empty or not, not evaluate the whole list.
12:28:11 <jmitePlus> @geekosaur, where would I look at that? I'm using a cabal sandbox, if that makes a difference
12:28:11 <lambdabot> Unknown command, try @list
12:28:28 <jmitePlus> geekosaur, where would I look at that? I'm using a cabal sandbox, if that makes a difference
12:29:22 <c_wraith> albeit: also, those big messages at the bottom of the paste from hlint are correct - those bang patterns do nothing at all, because you're already matching on a specific constructor.
12:29:23 <geekosaur> I pulled it up from hackage ("Package description" link at the bottom of the page) and then used "cabal unpack tf-random" to get the actual file. it *is* using UTF8
12:30:10 <geekosaur> this may be a bug in either cabal-install or possibly ghc-pkg
12:30:39 <jmitePlus> Interesting. I'm using cabal 1.20, I'll see if 1.18 is different
12:30:56 <c_wraith> albeit: and it looks like the real, underlying problem is that despite making many random things strict, you didn't make the important part strict - the accumulator.
12:31:09 <geekosaur> there is a comment in the file containing a UTF8 character (ł)
12:31:24 <jmitePlus> Huh, works on Cabal 1.18, I'll have to file a bug report. Thanks!
12:32:02 <c_wraith> albeit: when foldl' forces the intermediate values, it forces them to WHNF.  Since the intermediate value is of type (whatever,whatever), WHNF on it is the (,) constructor
12:32:19 <c_wraith> albeit: and your code generates the (,) constructor without doing any other evaluation at all
12:35:10 <c_wraith> albeit: maybe start here http://book.realworldhaskell.org/read/profiling-and-optimization.html
12:41:23 <b2coutts> is there a nice way of handling several separate cases in a do block (i.e., reading a line, then doing something different based on whether the line was "foo", "bar", or "baz")? I'm ideally looking for something like cond from scheme
12:41:51 <b2coutts> in the actual case I'm dealing with, case ... of doesn't suffice
12:41:55 <albeit> c_wraith: Thanks for all that, I'll give it a read
12:42:14 <jle`> b2coutts: depends on what you are doing, case usually should work for you
12:42:18 <jle`> can you be more specific?
12:42:44 <jle`> if you are just matching on whether the stirng was literally "foo" or "baz" or "bar", you can just case line of "foo" ->
12:43:18 <b2coutts> jle`: in this case I also have to do more complicated things, like checking if the string is in a list
12:43:40 <jle`> you can use guards
12:43:48 <jle`> or multi way ifs
12:44:14 <jle`> if your thing gets complicated enough you might want to consider parser combinators and your own command data type, which isn't that difficult at all
12:46:07 <enthropy> getLine >>= \case { "foo" -> action1; "bar" -> action2 }
12:46:50 <quchen> _else -> defaultAction
12:46:52 <enthropy> b2coutts: in what way does case fail?
12:47:22 <b2coutts> jle`: woah, parsec actually looks really useful/interesting
12:47:25 <quchen> Oh, that was a response. Ooops
12:47:32 <enthropy>  getLine >>= \ln -> case ln of { "foo" -> action1; "bar" -> action2; _ | ln `elem` someList -> blah }
12:47:33 <quchen> My linter went off ;-)
12:47:50 <jle`> b2coutts: yeah, haskell makes first-class parser combinators a snap
12:47:54 <b2coutts> enthropy: I realized after that the example I gavce worked fine for case
12:48:12 <jle`> or at least, working with them
12:48:33 <b2coutts> but in my actual program I need to test whether the input is contained in another list
12:48:54 <corgifex> enthropy's example does that
12:49:02 <enthropy> the first example doesn't
12:50:17 <bddy> Hello. Are there any comprehensive books about haskell? I know real world haskell and learn you a haskell, but err, I tried reading them 3 years ago, are they still actual?
12:50:57 <jle`> actual?
12:51:06 <Rarrikins> They are actual!
12:51:07 <bitemyapp> bddy: LYAH and RWH are reasonably representative of Haskell knowledge, but I don't think they're the best way to learn Haskell when you're brand new.
12:51:27 <cschneid> bddy: they are still the best books for learning. I am not aware of deep dives into haskell, beyond the narrower book "Parallel and Concurrent Programming in Haskell" which is a good look at how things actually get evaled
12:51:29 <b2coutts> enthropy: ah; yeah, I suppose that would work, though it feels a bit dirty :P
12:51:32 <bitemyapp> bddy: This is the gist I use to teach people: https://gist.github.com/bitemyapp/8739525 linked therein is the Yorgey course which should get you started.
12:51:34 <bitemyapp> cschneid: I disagree.
12:51:49 <bitemyapp> bddy: once you've completed the Yorgey course, you can use RWH and LYAH as references, which I think they serve well for.
12:52:11 <cschneid> bitemyapp: interesting. I have not seen that lecture series - checking it out.
12:52:25 <bitemyapp> cschneid: it's a lot better for getting people started and comfortable.
12:52:43 <bitemyapp> cschneid: it's not a Kmett factory, but it works a lot better than LYAH/RWH/HF&H
12:52:50 <bitemyapp> easier than the NICTA course too.
12:53:19 <edwardk> The Kmett factory has strict export controls.
12:53:45 <dmwit> HF&H?
12:53:48 <cschneid> bitemyapp: cool - I'm slowly working on a set of docs / book / cookbook that attempts to be a super-practical view of haskell post LYAH. So edwardk answering my lens question earlier was in relation to the "how the hell do I do json" chapter.
12:53:48 <dmwit> "have fun and hope"
12:53:52 <jle`> kmett factory, is that a mathematical object
12:53:59 <bitemyapp> edwardk: a really long gist called the Kmett factory of everything you've ever read or practiced would be an incredible resource.
12:54:06 <bitemyapp> dmwit: Haskell Fast & Hard
12:54:29 <bitemyapp> cschneid: I don't think LYAH is the best way to introduce Haskell to most people anymore.
12:54:35 <bitemyapp> cschneid: personal experience as a learner and a teacher bears this out.
12:54:48 <bddy> bitemyapp: Thanks, course looks pretty, I think I'd start with it.
12:54:50 <edwardk> jle`: nah, its a dirty hack I built back when i was a java programmer. helps with maintaining throughput though. ;)
12:54:56 <bitemyapp> LYAH works well for *some* people, I'll admit, but it's too slow/thin for many.
12:54:58 <cschneid> bitemyapp: sure - but that level of knowledge. A lot of tutorials drop the learner off at the end with a solid, but not complete view of monads / functors / etc. and no practical tools
12:55:15 <jle`> fwiw i am a product of lyah
12:55:17 <cschneid> bitemyapp: I personally read LYAH and RWH and then mucked around for a few years. Still on that step.
12:55:19 <jle`> take that for what it may mean
12:55:21 <bitemyapp> cschneid: I believe Yorgey's course communicates applicatives/monads more intuitively than LYAH.
12:55:36 <bitemyapp> cschneid: I think RWH's monad introduction is more thorough, but this is cherry-picking. Overall, Yorgey's course is superior and faster.
12:55:43 <bitemyapp> bddy: ping me if you need help. I'm on twitter under the same handle too.
12:55:45 <paintcan> isn't a monad some kind of burrito?
12:55:51 <bitemyapp> paintcan: no, it's a fish taco.
12:55:52 <intrados`> > fromList [(1, (3, 4))] ^.. itraversed . withIndex . to (id *** snd)
12:55:53 <cschneid> bitemyapp: I did like RWH's functor->applicative->monad flow.
12:55:53 <lambdabot>  Not in scope: ‘fromList’
12:55:53 <lambdabot>  Perhaps you meant one of these:
12:55:53 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
12:55:53 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
12:55:53 <lambdabot>    ‘S.fromList’ (imported from Data.Set)
12:55:53 <dmwit> You Could Have Invented Monads is my favorite, followed closely by All About Monads. But I have no data on Brent's course.
12:56:02 <bitemyapp> paintcan: but you're only allowed to eat the taco with boxing gloves.
12:56:07 <jle`> i invented monads
12:56:09 <intrados`> I assume there's a lensier version of that?
12:56:14 <RightMinded> Thanks biteymyapp, will look into this, currently running through LYAH, it's been helping me ease into the language, I find RWH a bit more hardcore for just jumping in
12:56:16 <edwardk> I'm a product mostly of old Wadler monad papers and TaPL with some Cale thrown in.
12:56:28 <bitemyapp> dmwit: both those articles are good, but I think they make reasonable follow-ups to Yorgey's course, not first-timer intros.
12:56:35 <edwardk> > M.fromList [(1, (3, 4))] ^.. itraversed . withIndex . to (id *** snd)
12:56:37 <lambdabot>  [(1,4)]
12:56:41 <bitemyapp> edwardk: I like my salad with Kale.
12:56:41 * geekosaur learned from "Gentle Introduction" + diving into xmonad, fwiw
12:56:45 <djahandarie> @remember edwardk I'm a product mostly of old Wadler monad papers and TaPL with some Cale thrown in.
12:56:45 <lambdabot> Done.
12:56:54 <vamega> Hi.
12:56:57 <edwardk> > M.fromList [(1, (3, 4))] ^@.. itraversed <._2
12:56:58 <lambdabot>  [(1,4)]
12:56:58 <monochrom> naw, Erik Meijer's "the curse of the excluded middle" is now the most-read monad tutorial :)
12:56:59 <jle`> hi vamega
12:57:04 * dmwit posts another vote for the Gentle Intro
12:57:10 <intrados`> edwardk: Thanks
12:57:11 <vamega> I'm looking for a function of this shape
12:57:21 <dmwit> vamega: Hi!
12:57:29 <cschneid> bitemyapp: you posted that heavily edited irc chat log post, right?
12:57:34 <edwardk> yeah i waded through the gentle intro as well at the time
12:57:35 <vamega> Monad m => (a -> b) -> (a -> m b)
12:57:43 <dmwit> :t (return .)
12:57:43 <lambdabot> Monad m => (a -> b) -> a -> m b
12:57:49 <bitemyapp> cschneid: that was me.
12:58:09 <dmwit> :t fmap pure
12:58:10 <lambdabot> (Applicative f1, Functor f) => f a -> f (f1 a)
12:58:13 <dmwit> Just for fun. =)
12:58:23 <cschneid> bitemyapp: I liked it - I want to look into the mechanical transform aspect more - seems like an interesting way to write programs. Do you know anything that expounds on that workflow?
12:58:28 <jle`> his apps are also regularly bitten
12:58:38 <vamega> :t return (\x -> intercalate "," $ lines x)
12:58:39 <lambdabot> Monad m => m (String -> [Char])
12:58:45 <vamega> Not quite what I want.
12:58:50 <vamega> I did look at return.
12:58:59 <bitemyapp> cschneid: a micro-example might be how polymorphism can be used to 'fix' invariants.
12:59:02 <vamega> But when I saw the resulting signature I thought I must have gotten something wrong.
12:59:04 <dmwit> vamega: Read again.
12:59:07 <dmwit> vamega: I didn't suggest return.
12:59:17 <vamega> Oh.....
12:59:22 <djahandarie> :t return
12:59:23 <lambdabot> Monad m => a -> m a
12:59:24 <bitemyapp> cschneid: Look at Kmett's comment here after reading the article: http://www.reddit.com/r/haskell/comments/24cq0u/the_identity_monad_trick/
12:59:26 <djahandarie> :t (return .)
12:59:27 <lambdabot> Monad m => (a -> b) -> a -> m b
12:59:40 <bitemyapp> cschneid: read the Wadler paper as well: http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
12:59:45 <dmwit> :t (return .) (\x -> intercalate "," $ lines x)
12:59:46 <lambdabot> Monad m => String -> m [Char]
12:59:52 <dmwit> :t return . intercalate . lines
12:59:53 <lambdabot> Monad m => String -> m ([[String]] -> [String])
12:59:58 <bitemyapp> cschneid: well specifically, parametric polymorphism.
12:59:59 <dmwit> :t return . intercalate "," . lines
13:00:00 <lambdabot> Monad m => String -> m [Char]
13:00:08 <djahandarie> @unpl (return .)
13:00:08 <lambdabot> (\ a d -> return (a d))
13:00:16 <bitemyapp> cschneid: which this article explains nicely: http://swizec.com/blog/week-20-making-ad-hoc-polymorphism-less-ad-hoc/swizec/6564
13:00:28 <edwardk> bitemyapp: notice the edit ;)
13:00:44 <jle`> vamega: what are you trying to do?
13:00:51 <bitemyapp> cschneid: you're somewhat fortunate in that you asked me a question I just got done posting links about.
13:00:56 <cschneid> bitemyapp: :)
13:00:57 <edwardk> bitemyapp: my trick was an attempt at adapting something similar i used elsewhere, but it doesn't work here.
13:01:16 <bitemyapp> edwardk: nuts.
13:01:26 <bitemyapp> cschneid: well anyway, that should get you going.
13:01:32 <karshan> anyone familiar with warp and wai-app-static who can help me out here ? When they work together warp returns 2 copies of the Content-Length header in the response which makes chrome unhappy
13:01:35 <cschneid> bitemyapp: yeah, I have run across that paper, but not yet read it
13:01:38 <edwardk> bitemyapp: i dashed off the reply too quickly on my way out the door.
13:01:42 <bitemyapp> cschneid: but the distinction between parametric and ad-hoc polymorphism is critical here and a big distinction to make.
13:01:56 <cschneid> ok - will be careful there - thanks for the link dump
13:01:57 <bitemyapp> cschneid: you could use Swizec's article as a primer for intuition in reading Wadler's paper.
13:02:10 <vamega> dmwit.
13:02:11 <vamega> Thanks
13:02:19 <vamega> That makes sense
13:02:39 <vamega> I was trying to write something that added characters between lines
13:02:45 <vamega> to use as one part of a bash pipeline
13:04:21 <felixn> sort of a design question... but why do all Language.*.Parser libraries implement their own parser?  instead of using parsec?  it makes me sad :(
13:05:08 <felixn> JavaScript's was just a fork of Python's parser
13:05:11 <pavonia> Fast and less overhead, I guess
13:05:15 <pavonia> *Faster
13:06:32 <geekosaur> felixn: I think Python used its own because there are difficulties parsing its version of significant whitespace with parsec. not sure about others
13:07:29 <edwardk> felixn: mostly to induce sadness
13:08:42 <felixn> heh thanks, I could see parsing Python being hard...  I actually am thinking about prototyping a language, and forking the haskell parser, then I got weirded out by look at all these parsers
13:12:34 <augur> haskell's insistence on using "forall" for its existential types is really unfortunate
13:13:00 <bitemyapp> augur: is it time?
13:13:11 <augur> bitemyapp: time?
13:13:21 <bitemyapp> Time for you to complain about things that are in the realm of "least concern"
13:13:24 <haasn> data Dynamic = exists a. Typeable a => Dynamic a -- would have been nicer, I think
13:13:38 <augur> bitemyapp: you're very grumpy
13:13:43 <haasn> but data Dynamic where Dynamic :: forall a. Typeable a => a -> Dynamic -- certainly makes sense
13:13:51 <bitemyapp> augur: you should form a Haskell-Complaining Voltron with Jon Sterling and Harper.
13:13:59 <bitemyapp> augur: your powers will be stronger if you combine.
13:14:04 <augur> bitemyapp: :P
13:14:16 <augur> haasn: that actually is tricky in the same way
13:14:39 <corgifex> shouldn't that be Dynamic (exists a. Typeable a => a)?
13:14:53 <augur> haasn: what you really want is to have the exists as the argument
13:14:53 <shachaf> corgifex: (exists a. Typeable a *> a)
13:15:05 <augur> abolish all of those darned pre-constructor quantifiers
13:15:09 <shachaf> => is like a function -- it asks the consumer to provide the dictionary.
13:15:16 <shachaf> Which doesn't make sense in a case like this.
13:15:23 <augur> bitemyapp: i bring it up because that use of forall has lead a lot of people to confusion about existential types in haskell
13:15:24 <haasn> oh, yes
13:15:31 <haasn> data Dynamic = exists a. Typeable a *> Dynamic a
13:15:33 <haasn> another motivating example:
13:15:47 <shachaf> haasn: ?
13:15:50 <augur> bitemyapp: plenty of people thing that this is existential:   data Foo = Foo (forall a. ...)
13:16:05 <shachaf> That syntax seems confusing. The forall outside the constructor makes sense to me.
13:16:05 <corgifex> learn them some CPS
13:16:06 <haasn> data Dict (a :: Constraint) = a *> Dict
13:16:12 <haasn> this, to me, makes sense
13:16:23 <augur> bitemyapp: the placement of the forall is crucial, but unfortunately it's non-obvious
13:16:34 <bitemyapp> I don't like the tricky placement either, so we agree on that.
13:16:40 <bitemyapp> but it's not in my top-10.
13:17:02 <augur> bitemyapp: well, my complaints arent the same as yours :p
13:17:04 <shachaf> "data Dynamic = forall a. Typeable a => Dynamic a" and "data Dynamic = Dynamic (exists a. Typeable a *> a)" both make sense to me.
13:17:19 <augur> shachaf: i think the latter is best
13:17:35 <shachaf> data Foo = MkFoo Int means that (MkFoo (x :: Int)) :: Foo
13:17:48 <shachaf> data Foo = forall a. MkFoo a means that for all a, (MkFoo (x :: a)) :: Foo
13:17:56 <haasn> shachaf: I guess the motivation for my syntax would be that the “data X = Foo” syntax describes *what* Foo actually is, not how you construct one; we have (Foo Int Int), it's a constructor with two Ints; along this line of reasoning I think it makes sense to say that “C *> Foo Int Int” means we have a Foo with two Ints and a C constraint
13:18:12 <augur> shachaf: indeed. im not saying there isnt a logic to it. just that its kind of tricky when thinking about these as existentials
13:18:19 <carter> lets flip that around, what does this all look like in core
13:18:38 <haasn> whereas “data X where Foo :: C => Int -> Int -> X” describes, to me, how you'd construct one - fields become function parameters, and existential constraints become contexts
13:18:42 <bitemyapp> it's a fair point, we are talking about glorified porcelain.
13:18:44 <shachaf> carter: Let's not.
13:18:49 <carter> k :)
13:19:04 <augur> bitemyapp: you do things with haskell that raise very different issues, no doubt
13:19:22 <corgifex> the difference between "correlated" and "corelated"
13:19:25 <augur> haasn: i agree again. GADT syntax is arguably optimal
13:19:34 <shachaf> (What code GHC ends up generating shouldn't have too much to do with how we want the syntax to work.)
13:19:56 <haasn> sorry, I meant “existential contexts become constraints”. or whatever
13:20:05 <bitemyapp> augur: yes, I'm a grubby blue collar coder, I know.
13:20:22 <augur> i bring this up, btw, because of the Identity monad post to the sub, where some people are confused about what edwardk's fancy type is doing
13:20:55 <bitemyapp> I don't think everything ekmett posts should be immediately accessible to literally everyone subscribed to /r/haskell.
13:20:58 <augur> bitemyapp: indeed. im lucky to not have to worry about actually important development issues :D
13:21:08 <bitemyapp> this includes sub-ideal expressions of existential types.
13:21:24 <augur> bitemyapp: no of course it shouldnt, but in this case it was accessible, and someone just mistakenly thought it was existential when it wasnt
13:21:54 <augur> namely:   data Secret a = Secret { runSecret :: forall m. Monad m => m a }
13:22:17 <bitemyapp> augur: it's one of those things where you just have to read a tutorial/article about "forall"
13:22:22 <bitemyapp> because it's somewhat specific to GHC/Hugs
13:23:02 <augur> i agree, but it arguably would be better pedagogically to have greater distinction between universal and existential quantification
13:23:02 <bitemyapp> honestly, anytime you see an unfamiliar keyword in a language you use after completing a basic tutorial should cause you to research it.
13:23:22 <bitemyapp> augur: we're fully agreed with different tiers of give-a-fuck-ness then.
13:23:27 <augur> :)
13:23:36 <bitemyapp> what you shouldn't do when you see an unfamiliar keyword is make assumptions.
13:23:46 <bitemyapp> Because even Haskell will fool you.
13:23:49 <augur> bitemyapp: well i dont think there's an issue with unfamiliar keywords here
13:24:18 <augur> i think the person in question is familiar with `forall`. its just that it gets used in two importantly distinct ways
13:24:29 <bitemyapp> I do think it's the problem.
13:24:34 <bitemyapp> they don't fully understand forall
13:24:42 <bitemyapp> they're just making assumptions based on previous, limited contexts.
13:24:49 <augur> indeed
13:25:01 <exicer> How come there isn't a FromJSON instance for ByteString in Aeson ?
13:25:11 <augur> i think shachaf's comment about what forall means to the left of a constructor might be a good argument that there are actually two `forall`s, actually
13:25:25 <nh2> exicer: there once was one, but it was removed for good reason; I'll link youi
13:25:37 <haasn> How feasible would it be to actually get a general-purpose “exists n. T” type into GHC? Like, say, [exists a. a]. This seems similar to [forall a. a] to me, which as I understand is very difficult to get working properly, hence GHC resigning to have use package both behind data types
13:25:49 <bitemyapp> exicer: huh?
13:25:59 <nh2> exicer: https://github.com/bos/aeson/issues/126 <- look its even my fault :)
13:26:00 <bitemyapp> exicer: there is no [byte] type in JSON.
13:26:10 <roconnor> haasn: there is such a keyword in UHC.
13:26:13 <S11001001> haasn: existentials are lame, blah
13:26:15 <augur> haasn: it ought to be trivial, since its just a syntactic issue
13:26:27 <n-dolio> haasn: It's yet another complication in an already very complicated type system.
13:26:48 <augur> haasn:   forall a. a -> b   ~   (exists a. a) -> b
13:27:07 <n-dolio> People have worked on systems with such a thing, but not with all the other features that GHC has.
13:27:23 <augur> (forall a. ... a ...) -> b   ~   exists a. ... a ... -> b
13:27:26 <augur> iinm
13:27:30 <augur> maybe not the second one
13:28:05 <nicolaum> When defining a record syntax for a type of data. data Something = Something {a :: A, subsetOFa :: A} is there a way to make sure that subsetOFa is actually a subset of a when Something is defined?
13:28:12 <augur> i have a hunch that `exists` could perfectly well be used as sugar for foralls like that
13:29:47 <karshan> is it possible to write a function of type Network.Wai.Response -> Response that filters content-length headers from its input ?
13:29:59 <n-dolio> And there are subtle things to think about with regard to how existentials work that are often not worried about, I think.
13:30:40 <bitemyapp> n-dolio: don't the typeclasses get smushed into the objects when you use existentials instead of getting statically resolved in the environment?
13:30:41 <augur> n-dolio: really we should just revamp haskell's type system to be dependent. :x
13:30:48 <haasn> augur: Interesting, the latter is a bit harder to grok than the former, but I can see it working in one direction
13:31:05 <enthropy> haasn: seems a little bit like https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures
13:31:07 <augur> haasn: yeah, there's one direction that works. i done know if the other works tho
13:31:22 <haasn> augur: that is, I can see it working for mimicking “exists” using “forall”
13:31:35 <augur> haasn: actually i dont think the forward direction is true, so
13:31:35 <n-dolio> Well, yes. If you want type classes to work, then (exists t. Show t *> t) contains a Show dictionary.
13:32:07 <augur> actually no, the forward direction is true too
13:32:14 <augur> in infinitely many ways
13:32:18 <n-dolio> So 5 :: Int is represented differently than (5 :: Int) :: exists t. Show t *> t
13:32:40 <haasn> enthropy: I'm not sure how that relates, to be honest; partial signatures just mean a hole there should be inferred, it doesn't say anything about how general or not that hole should actually be
13:32:45 <bitemyapp> augur: that would no longer be Haskell if it had DTs.
13:32:53 <hexagoxel> is there a way to make ghci always print only the first error encountered? because i find my workflow often is "fix stuff, switch to repl, :r, scroll up to next problem, switch to editor"
13:32:55 <n-dolio> UHC just doesn't let you use type classes this way, last I checked, so for instance, that's one thing that no one has actually worked out in practice.
13:32:56 <bitemyapp> I'm not opposed to DTs, just saying.
13:33:21 <bitemyapp> the changes from 1998 to 2010 kinda give me the flavor for how likely Haskell is to change drastically and I'm going to put low odds on it.
13:33:22 <carter> i think n-dolio  is probably one of the more DT expert folks on irc
13:33:38 <carter> bitemyapp: a LOT of DT like things are landing into ghc in the next 2 years
13:33:43 <exicer> nh2: Ah. I don't really understand text encoding that well, but I'm trying to use aeson to parse an api that is returning what looks like \163 when I print the raw responsebody, but is \xa3 when aeson attempts to parse it (which it can't).
13:33:44 <augur> haasn: given   f :: exists a. a -> b   you can derive   \g -> f g :: (forall a. a) -> b
13:33:46 <bitemyapp> carter: but is the piecemeal approach worth it?
13:33:50 <exicer> nh2: Any idea what I should be doing ?
13:33:53 <carter> bitemyapp: lets flip it around
13:33:56 <bitemyapp> carter: at what point do we need proof machines?
13:34:02 <carter> oh"
13:34:06 <carter> you can do proofs already :)
13:34:08 <carter> and sometimes you ahve to
13:34:11 <n-dolio> Also, you have to be really careful about things like size-annotated vectors. Vec a n.
13:34:15 <carter> yup
13:34:16 <n-dolio> Where n is the size.
13:34:19 <bitemyapp> carter: do you mean the type-level computation hack you were doing?
13:34:31 <carter> well, my stuff is boring
13:34:36 <carter> what n-dolio  is thinking of is a bit more intricate
13:34:39 <bitemyapp> n-dolio: yeah but it's ephemeral and unproven, you have to empirically test that you're not changing the vector sizes.
13:34:44 <YayMe> Anybody here very familiar with C# and monads?
13:34:50 <carter> bitemyapp: ?
13:34:50 <bitemyapp> n-dolio: unless there's some type-level way to prove it in Haskell I'm not aware of.
13:34:52 <n-dolio> If you do (exists n. Vec a n), you'd expect to get finite lists.
13:34:54 <enthropy> nicolaum: export a function   mkSomething a b | b `isSubset` a = Something a b | otherwise = error "not subset!"
13:34:57 <carter> bitemyapp: n-dolio  is kinda experty :)
13:35:04 <bitemyapp> I've only seen dependently typed Vector/Matrix dimensions in Agda/Idris/etc
13:35:11 <YayMe> I know this isn't the place to talk about C# but Iduno anywhere else to find people who can answer questions about monads
13:35:12 <n-dolio> But, if you're not careful with how existentials are evaluated, you actually get infinite lists.
13:35:14 <augur> haasn: oh no, the reverse direction isnt possible. doh.
13:35:19 <bitemyapp> YayMe: don't ask about monads.
13:35:25 <augur> bitemyapp: i agree, it wouldnt be haskell anymore. it'd be new haskell!
13:35:26 <bitemyapp> YayMe: learn about FP instead.
13:35:30 <haasn> n-dolio: except in a language with a non-strict type system? ;)
13:35:30 <bitemyapp> YayMe: you'll pick up monads on the way.
13:35:42 <haasn> (or infinite types, I guess)
13:35:44 <augur> bitemyapp: i think you could preserve a lot of current haskell with it tho. it would certainly simplify a bunch of things
13:35:46 <bitemyapp> YayMe: This is my recommended guide: https://gist.github.com/bitemyapp/8739525
13:35:46 <YayMe> bitemyapp: I'm comfortable with Haskell, I have a specific question though regarding something that's appearing to me
13:35:49 <n-dolio> haasn: Which isn't Haskell. :)
13:35:55 <bitemyapp> YayMe: then jump to the last 3 chapters.
13:35:55 <haasn> n-dolio: sadly :( :(
13:36:04 <carter> YayMe: whats your question
13:36:08 <enthropy> haasn: yeah it's barely related
13:36:15 <n-dolio> Not sure that's sad. Ruling out infinite types catches a lot of bugs.
13:36:34 <YayMe> Could C#'s Expression trees be seen as a crude form of a Cont monad (if used as such) ?
13:36:57 <bitemyapp> n-dolio: what's the best/nicest/most-type-safe way to do sized Vect types in Haskell at present?
13:37:01 <erisco> I need to maintain a cache local to the client which is synchronized periodically with a server. What RAM-based databasing package would be ideal?
13:37:01 <augur> i wonder if anyone has looked at what parts of haskell would be simplified by using DTs and how, and which parts would actually need to change
13:37:15 <carter> bitemyapp: mine are pretty darn type safe
13:37:21 <YayMe> I'm creating some compositional APIs with the expression trees so I can serialize and send over the wire the expression trees for execution remotely, but the way I build them is using what is basically like kleisli
13:37:26 <n-dolio> bitemyapp: There's type-level naturals now, right?
13:37:27 <augur> like, type families could be simplified greatly, but we'd need, perhaps, to distinguish between codes for types and actual types?
13:37:27 <bitemyapp> carter: what mechanisms are used to ensure that safety?
13:37:34 <carter> bitemyapp: they type check
13:37:35 <bitemyapp> n-dolio: typenats, yeah.
13:37:47 <erisco> augur, why? =\
13:37:48 <carter> and i don't use unsafe coerce
13:37:49 <bitemyapp> carter: but do the types catch invalid programs ?
13:37:53 <carter> yup
13:37:54 <augur> erisco: why what?
13:38:03 <haasn> augur: I guess the Idris/Agda camps could provide insight into answering that
13:38:12 <bitemyapp> carter: so if I write a function that takes a vector and appends to it, changing the dim/size, the type system would catch that?
13:38:18 <erisco> augur, "codes for types vs actual types"
13:38:18 <carter> yup
13:38:20 <bitemyapp> carter: without using the obvious bad escape hatches.
13:38:22 <augur> haasn: maybe
13:38:27 <bitemyapp> carter: what do you use to design the API thusly?
13:38:32 <n-dolio> bitemyapp: You won't really find me suggesting that GHC's features are ever going to really catch up to dependently typed languages. They're currently clunky, and I think there are things they fundamentally can't do.
13:38:32 <carter> proofs
13:38:33 <carter> hangon
13:38:35 <bitemyapp> carter: I've seen you kick around type families
13:38:36 <haasn> I'm personally not sure how to really unify and/or replace type classes, but I barely understand DT. I intend to study it in greater detail this semester
13:38:42 <n-dolio> Sized vectors are easy, though. So you can do those.
13:39:01 <bitemyapp> n-dolio: I've used enough Idris to know it's clunky, but that's why I don't really try to stretch Haskell's type system too aggressively.
13:39:01 <carter> bitemyapp: the type for append woudl be  liek Shape n a -> Shape m a -> Shape (n+m) a
13:39:07 <augur> erisco: type families in haskell have to be able to match on types. being able to do that breaks parametricity, so you have to work around that by having a code for types instead
13:39:11 <carter> its not that hard to do
13:39:12 <bitemyapp> also because I don't feel I understand it well enough to trust myself in such an attempt.
13:39:14 <carter> havne't bother
13:39:14 <YayMe> though my kleisli also does a Maybe-like thing treating nulls as nothing and forwarding null through the pipeline instead of executing composed expressions, I'm curious if my intution is correct that the expression trees feel like a cont monad and as such I should break apart the maybe part and the expression tree part with a transformer implementation to defien the interleaving
13:39:21 <bitemyapp> carter: so you're using type nats?
13:39:31 <augur> carter: why Shape? why not Vec? :(
13:39:32 <zacts> haskell
13:39:48 <augur> carter: and why do people put the indices first? thats kinda gross
13:39:49 <carter> i'm using my own data Nat = S Z | Z
13:39:53 <carter> augur: functors
13:39:55 <erisco> augur, hrm, I do not understand what that means. What does it mean that type families breaks parametricity?
13:40:04 * enthropy prefers   append :: Add n m nm => Vec n a -> Vec m a -> Vec nm a
13:40:07 <augur> carter: oh right, you want nice functor syntax
13:40:22 <carter> augur: yeah, my use case is a bunch of computations for doing array indexing
13:40:28 <enthropy> since then you can infer an `n' given the other two
13:40:29 <carter> so being able to have foldables and friends
13:40:32 <augur> erisco: if you can pattern match on types, then you lose the ability to say you're parametricity polymorphic
13:40:34 <carter> erisco: oh yeah, thats better
13:40:38 <augur> erisco: parametrically*
13:40:42 <n-dolio> bitemyapp: The problem is that the dependently typed languages don't have 20 years of engineering behind them. So you have to choose between clunkiness and immaturity.
13:40:43 <carter> * enthropy yup, thats better
13:40:52 <carter> i agree with dolio
13:40:52 <bitemyapp> n-dolio: right.
13:40:53 <enthropy> but it's uglier
13:40:56 <bitemyapp> n-dolio: I'm with you on that.
13:40:58 <enthropy> so you can't win
13:41:03 <haasn> augur: I guess type families break parametricity in the same way “forall a. Typeable a => T” breaks parametricity
13:41:09 <bitemyapp> n-dolio: thing is, I came to Haskell from Clojure - no type system at all.
13:41:14 <erisco> augur, what does parametrically polymorphic mean?
13:41:21 <carter> enthropy: yeah, but more inferency
13:41:37 <bitemyapp> n-dolio: so, being able to hide value constructors and force users to run data through mkType arg -> Maybe MyType is a win for me.
13:41:43 <nh2> exicer: \163 and \xa3 are the same thing, right?
13:41:44 <carter> enthropy: i'm trying to balance good inference vs human friendly types in a bnch of my code
13:41:46 <augur> erisco: polymorphic types that behave the same for all instantiations (like, say, id, or map, or whatever) as opposed to behaving differently (like type classes)
13:41:54 <roconnor> > \163 == \xa3
13:41:55 <lambdabot>  <hint>:1:6: parse error on input ‘==’
13:42:03 <roconnor> > '\163' == '\xa3'
13:42:04 <lambdabot>  True
13:42:20 <n-dolio> bitemyapp: Yeah. Haskell lets you do plenty.
13:42:38 <Yoctogon> welp, i think i've settled on a project to do in haskell: ray tracer using GPipe or something, with an emphasis on 3D plotting capabilities
13:42:40 <augur> haasn: might do, yeah. i dont know what this Typeable business is about. tho it might not
13:42:42 <jmcarthur> augur: i wouldn't say type families destroy parametricity. it's not like they allow you to inspect the type and behave differently based on what the type is
13:42:45 <exicer> nh2: Right. I clearly don't understand text encoding properly, but when this character falls into a Text field, decode from aeson fails.
13:42:49 <augur> jmcarthur: no no, im not saying they do
13:42:56 <haasn> augur: instance Typeable Int where typeOf _ = "Int" -- roughly
13:42:58 <jmcarthur> i misunderstood then i guess
13:43:07 <augur> haasn: yes i know how it works
13:43:09 <haasn> oh
13:43:10 <erisco> augur, so, a function like 'id' is parametrically polymorphic? what is a function such as '>>=' called?
13:43:15 <hexagoxel> or a slightly different question: what kind of workflow do you use when you have source-code with multiple compile-time errors? fix the last displayed first? ..?
13:43:50 <augur> jmcarthur: im saying that matching on types does. so to preserve parametricity in a dependent haskell, you cant let type families be mere functions * -> *, they have to be codes -> * or something like that
13:43:52 <bitemyapp> n-dolio: especially if you're willing to lift non-determinism into functions that check data at runtime.
13:43:54 <haasn> erisco: (>>=) :: Monad m => m a -> (a -> m b) -> m b -- is parametrically polymorphic in ‘a’ and ‘b’
13:43:57 <haasn> I don't know about ‘m’
13:44:04 <exicer> nh2: If I remove all such characters it decodes correctly.. why is this? I thought Text was utf-8, so shouldn't it be fine with this character ?
13:44:13 <augur> erisco: yes. bind is also parametrically polymorphic. anything with (outermost) forall is
13:44:14 <bitemyapp> haasn: it's not for m, different monads could do different things.
13:44:28 <c_wraith> haas, erisco: It's either "bounded" or "ad-hoc" polymorphism in m
13:44:28 <quchen> hexagoxel: No, fix the first one first. Errors often trigger secondary errors, fixing the ones at the top is most efficient.
13:44:32 <augur> bitemyapp: no, its parametrically polymorphic there too
13:44:41 <erisco> haasn, well it seemed that augur was holding functions such as 'id' and '>>=' apart in some way, because he said "opposed to behaving differently like type classes"
13:44:43 <nh2> exicer: first check out if it's like http://stackoverflow.com/questions/14080659/why-do-library-designers-use-bytestring-where-text-seems-to-be-appropriate/14084097#14084097
13:44:44 <bitemyapp> augur: really?
13:44:59 <augur> bitemyapp: oh, well, no, you're right
13:45:07 <augur> there are two (>>=)s at work tho, really
13:45:07 <quchen> hexagoxel: If you get the type of a definition wrong, the definition may not typecheck, and neither its use site. Fixing the definition often fixes the use site as well.
13:45:13 <haasn> I guess it's “parametric” in a different way, in that (>>=) still can't affect what your choice of ‘m’ chooses to do with its Monad instance - the function (>>=) is still forced to use the same Monad methods in the exact same way, regardless of what your actual value of ‘m’ is - its body can't discriminate
13:45:26 <bitemyapp> yeah I said "m" not >>=
13:45:27 <erisco> augur, okay, so anyways, how does pattern matching on types prevent you from saying a function is parametrically polymorphic?
13:45:41 <jmcarthur> bitemyapp: (>>=) doesn't behave differently by inspecting the type. it's a different (>>=) for different types.
13:45:41 <bitemyapp> erisco: you're changing behavior based on values.
13:45:43 <hexagoxel> quchen: yeah true, so back to my first question :D
13:45:50 <YayMe> bitemyapp: you get my question?
13:46:04 <haasn> oh, I guess I meant to use something like (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c -- as my example
13:46:06 <erisco> bitemyapp, how is behaviour being changed?
13:46:06 <YayMe> carter: or you?
13:46:13 <bitemyapp> YayMe: kinda. I don't know how to get fmap and join out of C# expression trees though. Do you?
13:46:14 <augur> bitemyapp: what i mean tho is, since (>>=) is 'really' an accessor, it's actually parametric in m, but only because you're secretly supplying the actual bind in the instance record
13:46:25 <carter> @google C# expression trees
13:46:27 <haasn> since (>>=) is in an unfortunate position of actually being a method itself
13:46:27 <lambdabot> http://msdn.microsoft.com/en-us/library/bb397951.aspx
13:46:27 <lambdabot> Title: Expression Trees (C# and Visual Basic)
13:46:34 <augur> erisco: you could do this:
13:46:39 <quchen> hexagoxel: Attempt to fix error, reload module. Repeat until errors are gone. Run tests.
13:46:50 <carter> YayMe: might they bee only an applicative?
13:46:54 <bitemyapp> YayMe: does C# even have functors/lawful visitors?
13:46:55 <augur> erisco: f Bool x = not x ; f Int x = x + 1
13:47:00 <jmcarthur> haasn: i don't see why (>=>) would be any different. it just passes the dictionary to (>>=)
13:47:05 <bitemyapp> YayMe: I haven't used C# since 2008.
13:47:20 <haasn> jmcarthur: I don't like to think of dictionaries as a fundamental language thing, personally, but as an implementation detail
13:47:29 <erisco> augur, hm I thought this was about type families? I do not recognize that kind of code
13:47:40 <haasn> For example, what if GHC inlines the actual definition of (>>=) for a sufficiently known type?
13:47:55 <jmcarthur> haasn: i agree that dictionary passing isn't fundamental to what type classes mean, but they do serve as a pretty decent model in practice
13:48:08 <augur> erisco: type families would do the same thing, but instead of returning values, they'd return types:   f Bool = Int ; f Int = String
13:48:13 <jmcarthur> haasn: if it inlines it then it inlines it. it doesn't change behavior.
13:48:27 <erisco> augur, I do not see the problem. I am confused
13:48:36 <augur> erisco: to do that, you need to match on types!
13:48:41 <erisco> so?
13:48:42 <YayMe> bitemyapp: 2008 is when it got Expression trees; they're just what they sound like, AST's that the .NET framework has a compiler for allowing you to manually construct computations in trees and then execute them as a delegate
13:48:51 <augur> erisco: so, you would break parametricity
13:48:54 <savanni> Off the top of yall's heads: how much work am I looking at to bind a Fortran function up into Haskell?  I'm assuming, since I'm on Linux, that the Fortran library was compiled with GCC.
13:48:57 <bitemyapp> YayMe: I don't think they're intrinsically "anything" other than what they say they are.
13:49:07 <erisco> well, seems that we have come full circle and I do not understand what is being broken :(
13:49:14 <jmcarthur> savanni: probably not much. make a C wrapper and the bind to the C function.
13:49:14 <bitemyapp> YayMe: you might be able to mimic lawful typeclasses *with* them, but that's contingent not intrinsic to how  expression trees are used.
13:49:16 <gilligan_> I could use some help with a simple problem, my brain is stuck: http://lpaste.net/103433 -- I am failing at handling Maybe values from a lookup correctly. Could someone suggest me how I should do this ? intent should be clear from the code/comments
13:49:17 <jmcarthur> *then
13:49:18 <haasn> (also, I think :: Dict a => [a]  is provably distinct from :: Dict' a -> [a], due to _|_
13:49:25 <haasn> and seq)
13:49:36 <augur> erisco: you understand how this works, right:   f Bool x = not x ; f Int x = x + 1
13:49:41 <savanni> jmcarthur: Cool.  I suspected that.  Did Fortran and C end up using the same memory layout?
13:49:48 <augur> erisco: you see how its looking at the type and then deciding what to do based on that, right?
13:49:52 <carter> YayMe: can you write down a bind for expression trees?
13:49:58 <YayMe> bitemyapp oh - no, C# can't do typeclasses. not really. You can fake up type-class like behaviour, but moreover you can do monad like behaviour in the composition
13:50:00 <bitemyapp> carter: that's why I asked for fmap/join.
13:50:09 <jmcarthur> savanni: i don't really know, but either way, haskell expects bindings to be with C
13:50:11 <erisco> augur, no, not really. is this Haskell code? pseudo-code?
13:50:12 <bitemyapp> carter: I think any such thing would be an individual's contrivance, not a real thing.
13:50:13 <carter> bind would be "eval and apply"
13:50:25 <jmcarthur> savanni: the language has direct support for binding to C functions, that is.
13:50:28 <augur> erisco: fictional dependent haskell that would let you match on types
13:50:29 <exicer> nh2: It looks like it is a similar problem, but not exactly. I'm still unclear about why a Text field can't parse \xa3 or \163.
13:50:30 <n-dolio> haasn: There's actually a bottom and non-bottom Dict a => [a], I think.
13:50:38 <savanni> jmcarthur: Yep.  I've done a tiny bit of FFI work.  Thanks!
13:50:42 <augur> erisco: brb
13:50:45 <n-dolio> Terrible as that is.
13:50:48 <carter> like bind :: Expression<a> -> (a -> Expression <b>) ->  Expression<b>
13:50:49 <YayMe> carter: that's why I'm wondering how similar they are to the Cont monad, I sort of *did* (kleisli, not bind), here have a read of this snipper of code: https://stackoverflow.com/questions/23223996/expression-lambda-error-argument-types-do-not-match/23224654#23224654
13:50:58 <haasn> YayMe/bitemyapp: comparing interfaces and type classes is comparing apples and orange because the former is a statement about object methods, and Haskell doesn't have objects or their methods
13:51:05 <n-dolio> Or, bottom and const bottom equivalent.
13:51:13 <erisco> augur, so is 'f' a binary function? is it a unary function that expects an argument of type Bool or Int?
13:51:28 <carter> YayMe:.... hard to say, i think its been shown that in some sense, you can build ANY monad out of the Cont Monad
13:51:43 <bitemyapp> carter: it's literally true but not really how you want to go about it.
13:51:46 <YayMe> what I did there is sort of maybe behaviour, but it feels like I did it out of Cont
13:51:49 <carter> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
13:51:58 <enthropy> savanni: you probably don't have to make a c wrapper
13:52:08 <bitemyapp> carter: but I've seen people implement monads *with* Expression Trees, but my point was it wasn't clear to me it was intrinsic to how you interface with ETs.
13:52:14 <savanni> enthropy: oh?
13:52:15 <carter> well
13:52:18 <carter> bitemyapp: not my problem
13:52:19 <carter> :)
13:52:20 <bitemyapp> carter: I guess my point is, "being able to use lambdas isn't necessarily a monad"
13:52:30 <YayMe> carter: interesting, that might explain why I always find myself doing cont-like compositional stuff whenever doing monad-like code in C#, I normally use funcs directly, but in this case I had to generate something that goes over the wire
13:52:30 <carter> bitemyapp: why are you explaing it to me
13:52:30 <haasn> erisco: if f :: (t :: *) -> (a :: t) -> (a :: t) then f could have any number of parameters, really, depending on your choice of ‘t’
13:52:35 <bitemyapp> they're building blocks, but the monad comes from the interface and the laws and ETs don't appear to have that structure.
13:52:38 <bitemyapp> I don't know.
13:52:39 <bitemyapp> YayMe: ^^
13:52:57 <bitemyapp> no structure, no interface, no laws - no monad.
13:53:06 <haasn> Haskell's Monad has no laws
13:53:10 <carter> :)))) true
13:53:11 <erisco> haasn, hm, I do not follow. does this relate to augur's hypothetical example?
13:53:24 <savanni> enthropy: Oh, do you mean that I can probably call the function directly from C?  That's what I'm hoping for.  Then it's only the C binding I have to do, and that will be pretty easy.
13:53:26 <haasn> Except, of course, for stuff like parametricity and maybe a bit of purity
13:53:28 <intrados`> gilligan_: Your commented example doesn't have the same type as your function. The example is of type String -> [(String, Srting)] -> String
13:53:30 <bitemyapp> haasn: http://www.haskell.org/haskellwiki/Monad_laws
13:53:38 <intrados`> Is that the type you wanted?
13:53:55 <carter> bitemyapp: my strict identity monad is a monad, but its not legal in a lazy sense
13:54:00 <haasn> bitemyapp: Those are agreed upon by convention, not enforced in the language
13:54:02 <YayMe> bitemyapp: fair point, but in C# I find myself emulating the *interface* because it's so nice, even though you can't create the same structure and as such won't be able to properly fully meet the laws
13:54:10 <carter> YayMe: go for it
13:54:22 <bitemyapp> haasn: stop it, if I roll my eyes that hard again I'll cramp the muscles in my eye sockets.
13:54:22 <carter> if ithelps you engineer
13:54:22 <carter> use it
13:54:23 <haasn> bitemyapp: Or maybe I'm misunderstanding the point you were making
13:54:46 <gilligan_> intrados`, err indeed
13:54:53 <carter> YayMe: Joinn would be   Expression<Expression<a>>->Expression<a> right?
13:54:55 * hackagebot web-routes-th 0.22.2 - Support for deriving PathInfo using Template Haskell  http://hackage.haskell.org/package/web-routes-th-0.22.2 (JeremyShaw)
13:54:58 <YayMe> carter: it does, back to my question though is - should I break apart the expression tree part from the maybe part that halts on failure
13:55:04 <carter> idk
13:55:18 <carter> YayMe: i'm busy writing array code right now and getting distracted
13:55:19 <n-dolio> haasn: http://lpaste.net/7930939265645543424
13:55:20 <enthropy> savanni: http://lpaste.net/99834 is an example with libffi, but you can also do the standard  foreign import "f" f :: Ptr Double -> Ptr Double -> Ptr Double -> IO ()
13:55:22 <gilligan_> intrados`, http://lpaste.net/103433 better now?
13:55:27 <bitemyapp> YayMe: in Cont, any failure would be a specific implementation continuation wouldn't it?
13:55:35 <augur> erisco: ok so
13:55:37 <bitemyapp> YayMe: you're describing the same mistake as "fail" was in Haskell to me.
13:55:55 <gilligan_> intrados`, append_ids "abc" table == Just "123"
13:56:05 <jmcarthur> haasn: Laws in Haskell are just like laws in real life. You are supposed to obey them, but nothing about the world fundamentally prevents you from breaking them other than fear of havoc and penalties.
13:56:05 <augur> erisco: that function f would have the type   f :: (a :: *) -> a -> a
13:56:07 <YayMe> carter: my apologies, go forth and do work. I'm still in prototyping phase...
13:56:11 <haasn> n-dolio: I remember running into that
13:56:18 <augur> erisco: like the identity function, except the type is now an explicit argument that you can pass in
13:56:19 <carter> bitemyapp: i think YayMe  understands what  a monad is
13:56:22 <bitemyapp> YayMe: does what I say make sense?
13:56:23 <carter> he's just trying to pretend to have one
13:56:30 <bitemyapp> carter: I've gotten to that point. Now we're on details.
13:56:30 <carter> in a language which can't have the "real thing"
13:56:32 <haasn> n-dolio: I wonder what the hell it means, given that matching on newtype constructors is supposed to be “free”, semantically
13:56:33 <bitemyapp> carter: continue with thy work.
13:56:36 <intrados`> gilligan_: The first parameter in append_ids needs to be either String or [Char] to match your example
13:56:41 <erisco> augur, okay, so (a :: *) means that the argument is a type?
13:56:58 <augur> erisco: yes, and also, the argument is `a`
13:57:10 <haasn> n-dolio: Oh, never mind; that still works: case (undefined :: Bad Int) of Bad _ -> ()
13:57:29 <augur> erisco: its just like forall, except the argument is explicitly passed, not merely present only at the type level
13:57:35 <oio> any idea how to load only a function on emacs haskell-mode?
13:57:40 <nh2> exicer: can you make me a small example I can try?
13:57:47 <erisco> augur, okay, so  f :: * -> a -> a  would be different than  f :: (a :: *) -> a -> a
13:57:50 <YayMe> perhaps I shouldn't sweat it, I'll just leave the Maybe and Cont portions bungled together and not care
13:57:58 <gilligan_> intrados`, crap sorry. i failed at extracting the code from context properly.. hold on
13:58:12 <augur> erisco: sure, lets pretend the first one doesnt exist at all right now
13:58:32 <res22> is there a function like zip but instead of pairing elements it passes an element from one list as a parameter to the other?
13:58:32 <erisco> augur, and so the type becomes a value? so this is inherently different than type classing?
13:58:36 <augur> erisco: so   f Bool x = not x ; f Int x = x + 1   behaves differently depending on what a is
13:58:38 <haasn> augur: Or that it's a syntax error due to ‘a’ being free
13:58:42 <augur> erisco: yes, this is dependent types!
13:58:54 <savanni> enthropy: thanks.  lpaste seems to be inaccessible to me at the moment, but I'll also look into foreign import.
13:58:55 <erisco> augur, yes, okay just checking :)
13:58:58 <n-dolio> haasn: seq is magic.
13:59:06 <augur> erisco: so given that f, you see how it behaves differently depending on a
13:59:10 <gilligan_> intrados`, http://lpaste.net/103433 .. slowly getting there now i hope ;)
13:59:14 <erisco> augur, so how does this relate to type families?
13:59:20 <exicer> nh2: Sure, one sec.
13:59:23 <augur> erisco: well lets just go one step at a time
13:59:34 <augur> erisco: you see how this behaves differently depending on a?
13:59:44 <erisco> augur, okay, yes, I see that f has different behavior depending on the type 'a'
14:00:09 <augur> erisco: ok, so: because we can match on `a`, we can have non-uniform (ie non-parametric) behavior
14:00:14 <gilligan_> intrados`, or not really.. now the ids function is broken. sigh
14:00:19 <haasn> gilligan_: If all else fails, try by pattern matching on the parameters and thinking about what to do in each case
14:00:38 <erisco> augur, is there any extra meaning to non-uniform or non-parametric or is that the definition?
14:00:50 <augur> erisco: no, not really
14:00:53 <haasn> (or on ‘ids’)
14:02:05 <intrados`> gilligan_: Think about the type from `fmap`ing over a string and the type you need for lookup
14:03:09 <hexagoxel> so.. does any beginner want to write a simple program that might actually be useful? write a parser for the output from a build (via stdin) and print only the first error to stdout! :D
14:03:25 <hexagoxel> (assuming that such feature really does not exist already..)
14:03:45 <exicer> nh2: http://lpaste.net/103438
14:04:02 <augur> erisco: so type families in Dependent Haskell would just be a function like any other
14:04:07 <exicer> nh2: the value of a is directly taken from this API I'm trying to interface with..
14:04:50 <erisco> augur, indeed, but with type families in regular Haskell, is parametricity broken?
14:05:28 <jle`> do groups just happen to not be as useful as monoids are in programming contexts
14:05:52 <carter> jle`: they are useful
14:05:57 <carter> just not widely
14:06:29 <jle`> indeed very few of the commonly used Monoids in haskell can also be Groups
14:06:31 <carter> most use cases can in wide application can get away with an commutative monoid asaict
14:06:32 <augur> erisco: no, because they're not true functions
14:06:44 <jle`> but i'm trying to think of applications where Groups would be handy
14:07:46 <erisco> augur, okay. so were you originally suggesting that type functions be separated from normal types in order to maintain parametricity when possible?
14:08:00 <augur> erisco: no :)
14:08:15 <intrados`> gilligan_: Do you see the mismatch?
14:08:21 <enthropy> savanni: http://dpaste.com/2P99MET/ is the same paste
14:08:29 * jle` ponders
14:09:15 <savanni> enthropy: Oh, that is *really* cool!
14:09:29 <augur> erisco: a code for a type would be a new type, call it Code, and we'd have a function  decode :: Code -> *  and that's how we'd match on types: by actually matching on Code
14:09:35 <savanni> And now, i disappear
14:09:48 <jle`> there is no edward kmett hackage package involving groups or rings so i am totally lost
14:10:04 <jle`> my usually road for relating mathematical structures ot haskell is gone
14:10:17 <enthropy> savanni: some day I will package up http://lpaste.net/50837 , which hides most of that stuff in a quasiquote
14:10:44 <erisco> augur, is that meaning   f (Code Bool) x = not x; f (Code Int) x = x + 1  ?
14:10:54 <enthropy> so that you have  [fortran| subroutine fn  .... |]; -- and below fn is callable from haskell
14:10:54 <jle`> *usual
14:11:57 <augur> erisco: no
14:12:31 <augur> erisco: more like   f :: (c : Code) -> decode c -> decode c   f BoolCode x = not x ; f IntCode x = x + 1
14:13:26 <erisco> oh, that seems strange
14:13:45 <erisco> so these data constructors are magically generated by the compiler?
14:13:49 <erisco> what is the motivation exactly?
14:14:27 <augur> erisco: yes, theyd have to be generated, but thats easy. the motivation is to preserve parametricity
14:14:56 <augur> erisco: here, because we're using codes and have to decode, we're fine since we're not matching on codes. and any time we take an actual type as arg, we cant match, so we're safe
14:15:13 <zerkzerkzerk> I would like to use Repa on fpcomplete.com. How should I do that?
14:15:42 <johnw`> zerkzerkzerk: it's not supported in the unstable package set?
14:15:53 <gilligan_> intrados`, sorry back now..  yeah i see it's wrong
14:16:13 <johnw`> I know they did a demo using GPU instances in EC2; if you mail them, they might set that up under a professional license of some kind
14:16:26 <erisco> augur, is the decoding not problematic? I am not understanding the rules of parametricity I imagine
14:16:51 <augur> erisco: no, because you're not actually polymorphic at all in that example
14:17:17 <augur> erisco: at least not in the relevant way
14:17:20 <zerkzerkzerk> johnw` Oh! I didn't know that was a thing. It seems that it is, thank you!
14:17:56 <erisco> augur, so I would call the function in a way such as  f IntCode 5  and get back 6?
14:18:03 <augur> erisco: right
14:18:09 <c_wraith> I don't see that type families would automatically break parametricity.  It seems like in order to do something useful with a type family, you need a class too, and *that* is what breaks parametricity.
14:18:24 <erisco> augur, and f in that case would instantiate to f :: Code -> Int -> Int ?
14:18:54 <augur> erisco: no
14:19:03 <augur> erisco: f is always (c : Code) -> decode c -> decode c
14:19:12 <augur> erisco: but f IntCode :: Int -> Int
14:20:07 <erisco> augur, it seems like we can already get this behaviour, minus the autogeneration of Code
14:20:19 <intrados`> gilligan_: It seems you should either pass in and return [String], or your table should be [(Char, Char)]
14:21:25 <erisco> augur, I suppose I am not seeing how this gets us dependant types... I suppose if you had  g :: Code -> Code ?
14:21:46 <nh2> exicer: http://lpaste.net/103438
14:21:50 <augur> erisco: it doesnt get us dependent types, it _uses_ dependent types
14:22:22 <erisco> augur, hm, I do not see how now =\ it just looks like we're passing around an ordinary ADT and pattern matching on constructors
14:22:23 <nh2> exicer: the problem *might* be that what you declare to be a ByteString there isn't a Bytestring
14:23:00 <augur> erisco: the type of f is dependent!
14:23:44 <exicer> nh2: Hm, interesting. Thanks for that! I will do a bit of reading to see if I can properly understand encoding.
14:23:45 <nh2> exicer: eitherDecode takes a ByteString that is UTF8
14:23:48 <erisco> augur, ah, I guess Code is just one type... I was thinking of a way to do the decode thing in normal Haskell but it would only work if IntCode, BoolCode, and so on were types instead of constructors
14:24:01 <augur> right
14:24:06 <nh2> exicer: I believe that if you declare it as a ByteString just like that, it is not encoded as what json allows
14:24:19 <nh2> exicer: but don't take it as 100% correct what I'm saying here
14:24:41 <exicer> nh2: fair enough
14:24:55 <steshaw> I’m having a bit of trouble with `cabal configure` for https://github.com/maxpow4h/lens-inference
14:24:58 <nh2> exicer: I recommend you file an issue at aeson's github now, then you can try to make your work in parallel until you get a real explanation there
14:25:17 <erisco> augur, but I do not see how  f :: (a :: *) -> a -> a  differs from  f :: (c : Code) -> decode c -> decode c
14:25:23 <nh2> exicer: ping me when you've created the issue so that I can subscribe pls
14:25:37 <augur> erisco: Code is a boring old AST
14:25:43 <erisco> augur, what significant difference is there in pattern matching on Code constructors than pattern matching on the type name?
14:25:45 <steshaw> Cabal could not resolve dependencies https://gist.github.com/steshaw/60813256a58cb25256dd
14:26:15 <johnw`> steshaw: cabal install --only-dependencies
14:26:24 <augur> erisco: we wouldnt be violating parametricity!
14:26:25 <johnw`> you don't have lens installed
14:26:41 <gilligan_> intrados`, actually all of this boils down to a completely different question that i've been coding around in circles : foldl (++) "" ["1","2"]  versus  foldl (++) Just ["1","2"] - the latter obviously doesn't work but i'm not sure how i should be doing this
14:27:01 <johnw`> gilligan_: what do you want to have happen?
14:27:03 <steshaw> johnw`, hmm I thought cabal would install dependencies I didn’t have. What’s happening there?
14:27:12 <johnw`> steshaw: cabal configure doesn't install anything
14:27:23 <tobiasgw> Does anyone know of a tool that can draw "dependency tree/graph" from Haskell data types? (I'm not sure dependency graph is the correct term)
14:27:31 <erisco> augur, well so far parametricity was defined to me merely as not pattern matching on types. this seems like a trivial side-step that does nothing other than appeasing the definition
14:27:33 <dmwit> steshaw: You can "cabal install --only-dependencies"
14:27:56 <dmwit> tobiasgw: What would the edges mean?
14:27:58 <erisco> augur, what benefit is there to keeping parametricity? it does not look like anything changes but the notation
14:28:16 <steshaw> johnw`: so, I should always `cabal install --only-dependencies` prior to `cabal configure && cabal install`?
14:28:24 <dmwit> steshaw: nah
14:28:27 <johnw`> or just cabal install
14:28:28 <dmwit> steshaw: Just "cabal install".
14:28:33 <steshaw> johnw`: it’s busy installing things btw. Thanks
14:28:46 <dmwit> steshaw: "cabal install" will grab dependencies, and moreover ignores what "cabal configure" does.
14:28:49 <johnw`> also, if you have a new enough cabal, abort that and run: cabal install -j
14:28:50 <steshaw> dmwit: no need for the configure step?
14:29:13 <dmwit> steshaw: Well. Not if you plan on running "cabal install" afterwards. But yes if you plan on doing other things.
14:29:18 <steshaw> johnw`, yeah I’ve got the latest cabal and could -j...
14:29:23 <augur> erisco: all sorts of nice proof properties, such as free theorems
14:29:36 <gilligan_> johnw`, what i am actually trying to do is take a list of strings as input. the strings are keys to an associative list and i want to return the values returned via lookup as a single concatenated String
14:29:37 <steshaw> Only got a Macbook Air here though and it’s already whirring :)
14:30:00 <gilligan_> johnw`, does that make any sense?
14:30:03 <tobiasgw> dmwit: edges would mean "is-of-type" or something like that. So "Data URL = String" would result in a graph like so: URL -> String
14:30:56 <johnw`> gilligan_: I think you want: foldl' (++) (\acc x -> lookup x xs <> acc) (Just "") keys
14:31:01 <gilligan_> johnw`, something along the lines of this: http://lpaste.net/103440 - but this is broken
14:31:01 <erisco> augur, why can those properies not be applied to  f :: (a :: *) -> a -> a? it looks literally identical to the Code version. Why can one not observe that 'a' is * just as one can observe that 'c' is Code?
14:31:15 <augur> erisco: they can, as long as we cant look at a
14:31:28 <johnw`> gilligan_: I think you want: foldMap (flip lookup xs) keys
14:31:44 <dmwit> tobiasgw: I don't know of such a tool, and moreover I'm suspicious of it. For example, how would you differentiate between sum and product edges? What would you do with polymorphic recursion?
14:31:54 <steshaw> Is there any work happening on binary packages for hackage/cabal?
14:31:55 <johnw`> (ignore that foldl' line)
14:31:58 <intrados`> gilligan_: If there's a missing item, do you want the whole thing to fail or for that just to be omitted?
14:32:16 <erisco> augur, I suppose I'd have to know more about free theorems to understand why this subtle difference is a difference at all
14:32:18 <dmwit> steshaw: I think the Haskell Platform is pretty much what we've got in that direction.
14:32:27 <steshaw> dmwit: ok
14:32:30 <gilligan_> intrados`, everything should fail
14:32:33 <augur> erisco: its just about what you can do
14:32:40 <johnw`> ah, then my foldMap won't do
14:32:46 <augur> erisco: _if_ you can inspect, then you're not parametric, so no free theorems
14:33:05 <steshaw> dmwit: feels a bit “Gentoo” to me. I ran Gentoo for a few years before going back to Debian-based distro.
14:33:40 <johnw`> gilligan_: foldl' (\acc x -> lookup x xs >>= (<> acc)) (Just "") xs
14:33:48 * dmwit nods agreeably at steshaw
14:34:02 <johnw`> make that fmap mappend acc, not ((<>) acc)
14:34:08 <johnw`> liftM2
14:34:09 <dmwit> So, are you volunteering to start a project to address this niche? =)
14:34:11 <johnw`> ok, I'm just going to stop trying
14:34:34 <gilligan_> johnw`, intrados` : in fact i wanted to code this python script to haskell: http://pastebin.com/ppFFg88L
14:34:41 <dmwit> steshaw: Oh, there's another step in that direction, I guess: many packages are available from the common distros, and the Hackage page says what package name to apt-get or yum install or whatever.
14:34:46 <erisco> what package is ideal for a ram db?
14:35:14 <dmwit> steshaw: But it is not recommended that you install packages from your package manager after already having installed some packages via cabal-install to your user's package database.
14:35:26 <erisco> augur, okay, well thanks for your explanation
14:35:31 <steshaw> dmwit: interesting, I didn’t know that
14:35:33 <dmwit> There are some nasty shadowing subtleties that can get you in trouble.
14:35:39 <johnw`> > foldl' (\acc x -> lookup x [("foo", "a"), ("bar", "b")] >>= \y -> fmap (y <>) acc) (Just "") ["foo", "bar"]
14:35:41 <lambdabot>  Just "ba"
14:35:44 <johnw`> > foldl' (\acc x -> lookup x [("foo", "a"), ("bar", "b")] >>= \y -> fmap (y <>) acc) (Just "") ["foo", "bar", "baz"]
14:35:45 <lambdabot>  Nothing
14:35:47 <gilligan_> johnw`, intrados` : the python script was just a little hack that i needed to generate some sql statements at work..  so i thought i'd try how i could best write that in haskell
14:36:04 <steshaw> dmwit: don’t like my MBA to whir like this. Poor thing :)
14:36:14 <dmwit> steshaw: Since you're on debian, try "apt-cache search libghc". =)
14:36:34 <gilligan_> johnw`, ah i see
14:36:55 <steshaw> dmwit: actually I’m on Mac right now but I still got my old Ubuntu laptop in a VM
14:37:11 <johnw`> /msg lambdabot @pl \acc x -> lookup x [("foo", "a"), ("bar", "b")] >>= \y -> fmap
14:37:11 <johnw`>           (y <>) acc
14:37:12 <steshaw> dmwit: trying to do things without spinning up too many VirtualBoxes
14:37:18 <dmwit> oops, Mac
14:37:23 <dmwit> outside of my expertise, sorry
14:37:39 <albeit> I have a variable "foo = bar ++ map f baz" that I need to be evaluated strictly as it results in a stack overflow. How can I make both the map and append be evaluated strictly?
14:37:40 <gilligan_> johnw`, I don't know about <>
14:37:46 <steshaw> dmwit: I guess, i could see if brew has haskell libraries
14:38:46 <dmwit> :t foldr
14:38:47 <lambdabot> (a -> b -> b) -> b -> [a] -> b
14:38:48 <johnw`> albeit: you could use (bar ++) $! map (f $!) baz
14:39:01 <johnw`> but that won't force the evaluation of every member of baz
14:39:21 <dmwit> :t foldr seq
14:39:22 <lambdabot> b -> [a] -> b
14:39:25 <johnw`> for that you'd need (bar ++) $!! map (f $!) baz
14:39:32 <dmwit> :t foldl' seq
14:39:33 <lambdabot> b -> [b] -> b
14:39:40 <dmwit> nooo
14:39:47 <johnw`> in which case (f $!) is redundant
14:40:02 <johnw`> I guess it all depends on how deep you want the evaluation to go
14:40:04 <erisco> :t ($!!)
14:40:05 <lambdabot>     Not in scope: ‘$!!’
14:40:05 <lambdabot>     Perhaps you meant one of these:
14:40:05 <lambdabot>       ‘$!’ (imported from Prelude), ‘!!’ (imported from Data.List),
14:40:05 <johnw`> $!! is generally bad form
14:40:11 <johnw`> it's in Control.Deepseq
14:41:06 <johnw`> albeit: do you want to force the "spine" of the list, evaluate the spine and each element to WHNF, or go all the way to Normal Form for everything?
14:42:06 <gilligan_> johnw`, sorry for asking the obvious but what module do i need to import for <> ?
14:42:14 <albeit> I'm not sure. foo is being built up of too many thunks and is overflowing, so I was thinking of evaluation it as deep as possible.
14:42:22 <johnw`> gilligan_: Data.Monoid
14:42:42 <johnw`> albeit: are you sure that's why your stack is overflowing?
14:42:57 <gilligan_> johnw`, thanks. it's a pretty misearble google search term ;]
14:42:58 <johnw`> albeit: the expression you wrote will be lazily evaluated; I bet there's more going on
14:43:06 <johnw`> gilligan_: Hoogle is your better friend :)
14:43:24 <gilligan_> johnw`, yeah but hoogle won't return anything for <> either
14:43:27 <albeit> 90%. I should have written it as "foo' = foo ++ map f baz". If I change it to "foo' = map f baz", it doesn't overflow.
14:43:38 <dwcook> @hoogle (<>)
14:43:39 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
14:43:39 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
14:43:39 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
14:43:50 <albeit> So I'm guessing it is lazyness of ++ that is breaking it.
14:44:13 <niez> hi, which library should I use for low level binary data manipulation?
14:44:15 <albeit> Because it is being called tens of thousands of times.
14:44:24 <gilligan_> johnw`, dwcook : well does return something. but not the <> from Data.Monoid
14:44:37 <johnw`> albeit: you may want something else to solve this, like different lists; but I'd need to see more context
14:44:38 <tobiasgw> dmwit: http://lpaste.net/103443
14:44:49 <dwcook> gilligan_, yeah I just tried that because I was curious. Odd
14:45:47 <dwcook> niez, bytestring perhaps
14:47:18 <johnw> gilligan_: <> is just the operator form of mappend, btw
14:48:42 <gilligan_> johnw, ok
14:49:48 <albeit> Some more context, if it helps: http://lpaste.net/103444. The general idea is I'm folding over a list, running a function that may output something each step, and appending that output to (a part of) the accumlator.
14:50:20 <corgifex> scanl?
14:50:26 <johnw> yes, difference lists would help you tremendously here
14:51:11 <albeit> Ah okay, I'll check it out. I thought you just meant something different than lists, haha
14:51:43 <johnw> instead of a ++ b, use (a ++) . b
14:51:54 <johnw> then, at the end, call (complete [])
14:52:14 <johnw> ++ copies the list to its left each time
14:52:51 <tobiasgw> Does anyone know of a tool that can draw graphs from Haskell data types like so: http://lpaste.net/103443
14:53:11 <johnw> ah, you'll need:
14:53:14 <johnw> (a ++) . (b ++)
14:53:35 <c_wraith> albeit: johnw's advice is solid.  And it's the opposite of making things stricter.
14:53:39 <stack> hello, I'm not into haskell but have found those operators there and need that info elsewhere, what does inl and inr stands for?
14:54:15 <johnw> yes, strictness is really not going to solve the performance problems with repeated use of ++ on ever-growing lists
14:55:03 <c_wraith> stack: you mean infixl and infixr?
14:55:47 <stack> c_wraith: mh no inl is mean to be left injection I suppose, but I'm trying to understand its application purpose
14:56:08 <albeit> Thanks!
14:56:24 <c_wraith> stack: left injection...  you mean foldl?
14:56:33 <c_wraith> stack: inl and inr aren't standard names for anything in haskell
14:56:52 <apples> those are common names for injections into sum types, yeah. like in data types a la carte iirc
14:58:40 <stack> apples: that is exactly the context where I found them, how do I found a better definition ?
14:59:13 <apples> stack: they correspond to the "Left" and "Right" value constructors for the Either type, if you're familiar with that
15:00:16 <stack> apples: so commonly speaking it's something like a destructor for couples that takes the left or right element, right?
15:00:26 <johnw> it's something like a constructor
15:01:14 <johnw> "inl 10" injects 10 into a sum, marking it as a "left 10" so to speak, since inl 10 and inr 10 are distinguished (being the whole point of sums)
15:01:23 <johnw> but there are many more sum types than just Either
15:02:01 <stack> johnw: I know practically nothing of haskell :)
15:02:19 <johnw> stack: do you know much math?
15:02:26 <apples> it's similar to the idea of a disjoint union, if you're familiar with that
15:02:28 <johnw> sums are also called "coproducts"
15:02:59 <johnw> any text on set theory or category theory will have a whole lot to say about them (though in set theory they'll be called disjoint unions, as apples pointed out)
15:03:54 <johnw> in C++, for example, sums are called variants
15:05:03 * hackagebot hs-blake2 0.0.1 - A cryptohash-inspired library for blake2  http://hackage.haskell.org/package/hs-blake2-0.0.1 (tsuraan)
15:05:34 <stack> I'm familiar with disjoint union, and it's also something that I'm encountering before reading about inl and inr, but yeah I'm still not confident about them
15:05:50 <\-d6z7r> hi
15:06:40 <niez> can I understund conduit/pipes/iteratee as explicit lazy IO ?
15:06:40 <\-d6z7r> Is there any accepted convention for naming your modules?
15:07:08 <johnw> niez: it's like explicit lazy I/O with effects, resource management, and proper exception handling
15:07:10 <\-d6z7r> for instance COMGeometry (first three letters of the Company) or PROGeometry (first three letters of Project name)
15:07:21 <apples> stack: if you have the disjoint union A U B, then inl is like the canonical injection A -> A U B, and inr is like the canonical injection B -> A U B
15:07:21 <\-d6z7r> to avoid name collisions
15:08:19 <johnw> usually I'd do: Company.Geometry, or Company.Project.Geometry, or just Project.Geometry
15:08:37 <\-d6z7r> johnw: oh, you can use a dot?!
15:08:46 <jle`> hierarchical module system
15:08:48 <johnw> sure!
15:08:50 <jle`> or what ever it is called
15:09:12 <\-d6z7r> johnw: you mean that . is actually a part of the module name?
15:09:25 <albeit> Oh beautiful, the difference lists worked great!
15:09:27 <johnw> it's a module name separator
15:09:41 <jle`> \-d6z7r: it's not, it's sort of like a / in a filesystem between folders
15:09:42 <johnw> albeit: great, and you've still got the benefits of lazyness! (incremental consumption)
15:09:53 <jle`> filepath
15:09:53 <\-d6z7r> hmm
15:10:04 * hackagebot hs-blake2 0.0.2 - A cryptohash-inspired library for blake2  http://hackage.haskell.org/package/hs-blake2-0.0.2 (tsuraan)
15:10:09 <jle`> Control.Monad
15:10:12 <jle`> Data.Char
15:10:27 <jle`> Data.Text.Lazy
15:12:52 <\-d6z7r> ok
15:13:04 <johnw> albeit: take 10 $ ([1..] ++) . ([1..] ++) $ []
15:13:26 <johnw> > take 10 $ ([1..] ++) . ([1..] ++) $ []
15:13:29 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:13:42 <felixn> https://gist.github.com/munro/488bdf888644ed58edc0 <-- I'm autogenerating haskell code... except for some reason using "let" causes the next statement to fail to parse...  I'm using { } and ; to assemble haskell code
15:14:28 <albeit> johnw: Looks good. Now I just need to investigate whether I really need bangs where I thought I did.
15:14:36 <albeit> In other places
15:15:02 <johnw> bangs are often called for where math expression are being passed around, or if you're returning stuff inside tuples
15:15:24 <johnw> because evaluating the tuple to WHNF will not evaluate its components
15:15:50 <johnw> in fact, tuples are the most common cause of stack woes I see here in this channel
15:16:34 <hexagoxel> felixn: let { (VMObject hello) = (VMObject 123); };
15:16:59 <albeit> Woah, I just removed my bangs, and instead of having a bung of text output once the program finished, I see lines get output one by one as they're incrementally found... cool.
15:17:08 <hexagoxel> (as there might be multiple clauses in the let)
15:17:19 <johnw> albeit: yes, laziness is a good thing
15:17:44 <johnw> it's not "as they're found", though; it's more like "as you're asking for them"
15:18:01 <johnw> rather than waiting until youv'e computed all the results before returning anything
15:18:23 <felixn> hexagoxel: you rock!
15:18:41 <\-d6z7r> jle`: so basically, you can just name your module What.Ever.Foo without first worrying about "creating" What and Ever ?
15:18:48 <\-d6z7r> so it's basically free form
15:18:56 <felixn> hexagoxel: some things in haskell are really hard to google >_<
15:19:16 <johnw> just google for "let"!  Oh, wait.. ;)
15:19:37 <johnw> \-d6z7r: they just have to be directories on the filesystem
15:19:42 <johnw> src/What/Ever/Foo.hs
15:19:42 <hexagoxel> :)
15:19:49 <\-d6z7r> johnw: ah ok, thanks
15:20:50 <albeit> I need to break a line into words, and then assign some of the words to variables. Doing a bunch of "a = tokens !! 5" gets slow as it has to iterate the list multiple times. Is the best way to do it to convert the tokens into an IntMap and then lookup by index?
15:21:30 <johnw> albeit: that's probably how I'd do it
15:21:43 <koala_man> can you do it by plain pattern matching?
15:22:13 <johnw> he means: let [a,b,_,c,_] = ["HI',"There","My","Friend","Albeit"]
15:22:40 <albeit> Aha! good call
15:22:53 <tremon> can I ask a simple question on rwh here? one of the examples won't compile and I don't feel like skipping ahead 10 chapters
15:22:55 <Iceland_jack> > [a,b,_,c,_] = "good idea!" in (a, b, c)
15:22:56 <lambdabot>  <hint>:1:13: parse error on input ‘=’
15:23:00 <johnw> tremon: sure
15:23:00 <Iceland_jack> > let [a,b,_,c,_] = "good idea!" in (a, b, c)
15:23:02 <lambdabot>  (*Exception: <interactive>:3:5-30: Irrefutable pattern failed for pattern [a...
15:23:16 <koala_man> use a case
15:23:21 <johnw> Iceland_jack: (a:b:_:c:_)
15:23:22 <tremon> thx. it's about chapter 8 ( http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html ), the definition of listMatches
15:23:25 <shachaf> tremon: Just ask, don't ask to ask. :-)
15:23:41 <Iceland_jack> johnw: :) maybe that's a good idea, for actual code I avoid such things
15:23:47 <johnw> ah, an example close to my heart today
15:23:48 <johnw> go on
15:23:50 <awestroke> > let a:b:c:d:e = [1,2,3,4,5,6] in a
15:23:51 <lambdabot>  1
15:24:04 <tremon> it contains a catch() {} -like construct, "handle (const (return []))", but my current ghc doesn't like it
15:24:17 <Iceland_jack> tremon: there is a new exception library, things are a bit different
15:24:23 <tremon> it says "type variable e0 is ambiguous"
15:24:26 <johnw> you need to provide a type signature for e
15:24:46 <johnw> handle (const (return []) :: SomeException -> IO [])
15:24:53 <\-d6z7r> Iceland_jack: u from iceland?
15:25:03 <Iceland_jack> \-d6z7r: sure
15:25:09 <\-d6z7r> ok, is auroracoin being used there at all?
15:25:11 <\-d6z7r> or is it dead?
15:25:19 <\-d6z7r> (if you've heard of it)
15:25:22 <Iceland_jack> tremon: This is also an option
15:25:22 <Iceland_jack>     handle (\(SomeException _) -> return [])
15:25:28 <tremon> ok thx, will try that. Is there some "Exception" base type?
15:25:36 <johnw> SomeException is the base type
15:25:38 <johnw> Exception is the type class
15:25:42 <tremon> oh cool :)
15:25:52 <tremon> didn't see that one coming
15:25:58 <johnw> there is also IOException, which is probably more appropriate here in fact
15:26:02 <Iceland_jack> \-d6z7r: I don't live there but it had some commotion, many people are interesting in it but I'm not sure that it made a big splash
15:26:12 <\-d6z7r> ok
15:26:14 <johnw> since if you use SomeException, you'll run afoul of timeout, thread cancellation, etc.
15:26:20 <tremon> thx, will try IOException first
15:26:54 <Iceland_jack> Yes, SomeException is generally something you use for throw-away code
15:27:05 <awestroke> Iceland_jack: why not _ then?
15:27:13 <Iceland_jack> but Haskell's exceptions can be a bit cumbersome
15:27:25 <awestroke> Iceland_jack:   handle (\_ -> return [])
15:27:31 <Iceland_jack> awestroke: That's the same as the original
15:27:41 <Iceland_jack> i.e. handle (const (return []))
15:27:50 <awestroke> ah
15:27:57 <Iceland_jack> where the 'e' type variable is ambiguous
15:31:06 <tremon> the const (return []) :: SomeException -> IO [] gives me "expecting one more argument to []". Can't it infer the list element type?
15:31:33 <Iceland_jack> tremon: Wrong kind of []
15:31:40 <awestroke> :t const
15:31:41 <lambdabot> a -> b -> a
15:31:46 <dwcook> :k []
15:31:47 <lambdabot> * -> *
15:31:50 <Iceland_jack> You can avoid it using my version above tremon
15:31:53 <dwcook> :k IO
15:31:54 <lambdabot> * -> *
15:32:08 <awestroke> :k MonadIO
15:32:09 <lambdabot> (* -> *) -> Constraint
15:32:10 <dwcook> [] :: * -> * doesn't match up with the *
15:32:10 <Iceland_jack> :t (\(SomeException _) -> return [])
15:32:11 <lambdabot> Monad m => SomeException -> m [t]
15:33:26 <awestroke> :t Constraint
15:33:27 <lambdabot> Not in scope: data constructor ‘Constraint’
15:33:29 <Iceland_jack> I sometimes write auxiliary functions for handling exceptions, it often ends up very clean
15:33:32 <awestroke> :k Constraint
15:33:32 <Iceland_jack> :k Constraint
15:33:33 <lambdabot>     Not in scope: type constructor or class ‘Constraint’
15:33:33 <lambdabot>     Perhaps you meant ‘Contains’ (imported from Control.Lens)
15:33:33 <lambdabot>     Not in scope: type constructor or class ‘Constraint’
15:33:33 <lambdabot>     Perhaps you meant ‘Contains’ (imported from Control.Lens)
15:33:58 <Iceland_jack> :k Num
15:33:59 <lambdabot> * -> Constraint
15:34:02 <Iceland_jack> Anyway
15:35:46 <Gurkenglas> What is a recommendable way to distinguish between coordinate values of different axes?
15:36:37 <Gurkenglas> Assuming that there is no upper limit to the number of axes. Recommendable meaning that it keeps with the spirit of most errors appearing at compilation time
15:37:36 <oio`> can this be done ?or with let ? main = do x x x x x where x = do y q w
15:40:01 <koala_man> oio`: main = do { x; x; x; } where x = do { putStrLn "foo"; }
15:40:56 <Iceland_jack> oio`: Do you want to repeat the same action 5 times?
15:41:00 <Iceland_jack> :t replicateM 5
15:41:01 <lambdabot> Monad m => m a -> m [a]
15:41:03 <Iceland_jack> :t replicateM_ 5
15:41:04 <lambdabot> Monad m => m a -> m ()
15:41:13 <Jaood> are there any monads tutorials out there?
15:41:20 <[swift]> lol
15:41:21 <Iceland_jack> Jaood: :)
15:41:21 <Jaood> I kid I kid
15:41:26 <Jaood> ;)
15:41:30 <oio`> ok
15:41:46 <Iceland_jack> One thing I never expected to hear ;)
15:41:53 <oio`> Iceland_jack: more like a goto
15:42:19 <Iceland_jack> oio`: What are you referring to?
15:42:57 <Iceland_jack> I assumed you mean
15:42:57 <Iceland_jack>     main = do x; x; x; x; x where x = do y; q; w
15:42:57 <Iceland_jack> rather than
15:42:57 <Iceland_jack>     main = do x x x x x where x = do y q w
15:43:09 <oio`> Iceland_jack: yes
15:43:25 <Iceland_jack> in which case you could do
15:43:25 <Iceland_jack>     main = let x = do y; q; w
15:43:25 <Iceland_jack>             in replicateM_ 5 x
15:43:58 <Iceland_jack> or just
15:43:58 <Iceland_jack>     main = replicateM_ 5 (do y; q; w)
15:45:08 <oio`> Iceland_jack: main do q w question case question fail -> question  r t y where question = do z x c v
15:45:31 <Iceland_jack> I'm not sure what you're asking
15:46:18 <oio`> Iceland_jack: repeat the same procedura if an invalid key has been press
15:46:46 <Iceland_jack> Okay, you want something like 'ask user until you get a valid answer'?
15:47:01 <Iceland_jack> Something of that ilk
15:47:08 <oio`> Iceland_jack: yes
15:48:17 <Iceland_jack> right, you can have
15:48:17 <Iceland_jack>     askUser :: IO Response
15:48:17 <Iceland_jack>     askUser = do
15:48:17 <Iceland_jack>       line <- getLine
15:48:20 <Iceland_jack>       case map toLower line of
15:48:26 <Iceland_jack>         "yes" -> YES
15:48:29 <Iceland_jack>         "no"  -> NO
15:48:31 <Iceland_jack>         _     -> askUser
15:48:34 <Iceland_jack>                 
15:49:00 * Rarrikins drowns in a flood.
15:50:09 <oio`> Iceland_jack: indeed but idont like to pass around to many functions
15:50:35 <Iceland_jack> We're not passing any functions around there
15:50:36 <identity> could just as well use Bool there, no? Isn't that hypothetical YES | NO type what they call isomorphic to Bool?
15:51:02 <Iceland_jack> identity: Sure, but a lot of things are isomorphic :)
15:51:25 <oio`> Iceland_jack: there are things at the top of the function that dont need to be done twice
15:51:47 <Iceland_jack> oio`: Top of the function?
15:53:12 <Iceland_jack> identity: I very often create data types that are isomorphic to Bool or Maybe for clarity of intent
15:53:12 <Iceland_jack>     data Status = Dead | Alive
15:53:12 <Iceland_jack> is much more clear than something like
15:53:12 <Iceland_jack>     type Dead = Bool
15:53:15 <oio`> Iceland_jack: askUser = do readfile load parse
15:53:40 <Iceland_jack> oio`: You can pass that value to the function if you want
15:54:02 <oio`> <oio`> Iceland_jack: indeed but idont like to pass around to many functions
15:54:02 <oio`>  
15:54:22 <Iceland_jack> You would be passing values, also if you don't like passing around functions you're using the wrong language :)
15:54:36 <Iceland_jack> non-function values, depending on your use case
15:55:08 <johnw> Iceland_jack: I like having a superfluity of data types too
15:55:08 <oio`> Iceland_jack: trust me i like but not for trivial things
15:55:20 <identity> Iceland_jack: Yes, you are right. I do the same, to be honest, when I think about it
15:55:28 <oio`> Iceland_jack: though already solved
15:56:19 <Iceland_jack>     data ServerStatus = NoResponse | Response SomeSillyDetails
15:56:54 <Iceland_jack> but with the new PatternSynonyms and ViewPatterns you can avoid this a lot of the time
15:57:03 <Iceland_jack> I'm wondering if I should write a tutorial about that
15:57:27 <johnw> indeed you should
15:57:34 <identity> You should
15:58:44 <Iceland_jack> One of the cool examples is a quick IRC bot that I wrote where you could do
15:58:44 <Iceland_jack>     MSG chan Cat -> msg chan "Someone said cat!"
15:58:44 <Iceland_jack> where Cat is a pattern that matches every string containing 'cat' in any case
15:59:04 <Iceland_jack> The resulting logic was quite elegant
15:59:21 <identity> oh, that's pretty nice
15:59:40 <identity> so that was a combination of a pattern synonym and a view pattern?
15:59:48 <Iceland_jack> You could also write
15:59:48 <Iceland_jack>     MSG chan (CMD cmd) -> .. execute cmd ...
15:59:48 <Iceland_jack> yes
16:00:09 * hackagebot swagger 0.1 - Implementation of swagger data model  http://hackage.haskell.org/package/swagger-0.1 (ToralfWittner)
16:00:13 <Iceland_jack> (where (CMD ...) matches every line starting with '> ' and assigns the following command to 'cmd')
16:00:47 <Gurkenglas> Isn't Maybe the standard thing to use for :53:53? (Just starting out with Haskell, therefore stupid questions)
16:01:05 <identity> i'm actually writing an irc bot as a small hobby project -- that sounds like a really cool idea. I'll have to look into that
16:01:18 <palo> I don't get PatternSynonyms (yet :D)
16:01:20 <identity> Gurkenglas: :53:53?
16:01:28 <Gurkenglas> <Iceland_jack>     data ServerStatus = NoResponse | Response SomeSillyDetails
16:01:30 <Iceland_jack> identity: I think I'll write that post :) I'll post it on r/haskell and some other places
16:01:38 <identity> Iceland_jack: Do it!
16:01:51 <identity> The Simons will be pleased.
16:02:00 <Gurkenglas> That was written at 00:53:53 says my client, but timezones therefore I omit the hour value
16:02:27 <identity> Gurkenglas: Aah. Of course.
16:02:39 <identity> Gurkenglas: Yes, that type is isomorphic to maybe.
16:02:41 <identity> Maybe*
16:02:42 <Iceland_jack> Gurkenglas: It's up to you really
16:02:50 <erisco> if I want to maintain a global state as my program is running, is an ioref suitable?
16:03:04 <johnw> erisco: it can be, but you have several other options
16:03:19 <identity> erisco: Sure, if you don't want to be dealing with State and you don't care about being in the IO monad
16:03:19 <johnw> least among them being finding a way to avoid maintaining a global state...
16:03:25 <Gurkenglas> So minimizing the amount of stuff you have to define yourself as opposed to using library stuff is not a common paradigm?
16:03:30 <Iceland_jack> defining a custom data type means more hassle, I usually do it if all I intend to do is pattern match on it
16:03:33 <johnw> I discovered in my code yesterday that StateT was much faster than using IORef
16:03:42 <Gurkenglas> (Merely read most of http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ )
16:03:42 <Iceland_jack> Gurkenglas: So it depends, did you see my example above?
16:04:14 <Gurkenglas> Which one are you refering to? You said many things. Timestamp :3
16:04:17 <erisco> johnw, I am not sure how State is applicable. I need to update data from multiple threads and in reaction to various events, such as user input or network activity
16:04:36 <erisco> johnw, ie there is no single path to thread the state through
16:04:40 <identity> Using your own types, even if they're isomorphic to something standard like Maybe or Either is a way of having self-documenting code
16:04:59 <Iceland_jack> Gurkenglas: If you have a server and you want to store its status, you could use Bools
16:05:00 <Iceland_jack>     type ServerUp = Bool
16:05:00 <Iceland_jack> or you could define your own data type
16:05:00 <Iceland_jack>     data ServerStatus = ServerUp | ServerDown
16:05:07 <identity> and also providing guarantees using the type system. Passing a ServerStatus to a function that deals with ServerStatus makes more sense than passing a Maybe.
16:05:18 <Iceland_jack> Gurkenglas: Basically what identity said
16:05:28 <Gurkenglas> The second one of course, for less error pronity
16:05:36 <identity> and that, yes
16:05:38 <johnw> erisco: ah, then I'd use a ReaderT (TVar SharedState)
16:05:53 <Iceland_jack> Also if you end up pattern matching on something
16:05:53 <Iceland_jack>     stat ← getServerStatus
16:05:53 <Iceland_jack>     case stat of
16:05:53 <Iceland_jack>       ServerUp   → …
16:05:56 <Iceland_jack>       ServerDown → …
16:06:03 <Iceland_jack> which is much clearer than something like, True/False
16:06:04 <johnw> identity: and even better than documentation, they let you "opt-in" for the instances that actually make sense for your data
16:06:24 <identity> johnw: true
16:06:26 <johnw> newtype CityName = CityName Text, does not have a meaningful Monoid instance, even though Text does
16:06:49 <Iceland_jack> johnw: Yes that's a bonus, you may want your own monoid or serialization  instances
16:07:16 <Gurkenglas> Hmmmmmm so there should be a construct that allows you to modify any construct that works like Maybe to specify its purpose via a parameter
16:07:18 <Iceland_jack> It gets worse for other isomorphic types like
16:07:18 <Iceland_jack>     data ServerStatus = ServerUp | ServerDown | StatusUnknown
16:07:22 <johnw> I found a bug that way, just by switching to a newtype and learning that the default Monoid was being chosen in a place I never expected
16:07:42 <Iceland_jack> Gurkenglas: You're basically talking about allowing you to operate uniformly on isomorphic types
16:07:54 <johnw> Gurkenglas: lens gets very close to that
16:08:02 <johnw> has _Just foo, has _ServerUp foo, etc.
16:08:11 <identity> johnw: that's a good point. I hadn't really thought about it like that (wrt CityName). I should probably use less type synonyms
16:08:17 <erisco> johnw, what is the advantage of this?
16:08:20 <identity> fewer*
16:08:26 <johnw> erisco: of what?
16:08:37 <erisco> johnw, ReaderT (TVar SharedState)
16:08:38 <Gurkenglas> I think so, jack. John, Probs gonna look at that lens thing at some point
16:09:10 <Iceland_jack> Using the extension I mentioned above (PatternSynonyms) you could also pattern match on isomorphic datatypes
16:09:10 <Iceland_jack>     pattern ServerDown = False
16:09:10 <Iceland_jack>     pattern ServerUp   = True
16:09:10 <Iceland_jack> but I wouldn't
16:09:12 <btcNeverSleeps> how can I use a fast "mod pow" function in Haskell?
16:09:14 <johnw> erisco: it's just a thread-friendly way of sharing a global state; you can do it with IORef too, if you use atomicModifyIORef and atomicWriteIORef
16:09:38 <identity> Gurkenglas: 1. Buy bottle of alcohol. 2. Pour a drink. 3. Look at lens. 4. Drink. 5. Go to 3.
16:09:58 <user___> are there any programming languages or levels of math you should know if you're going to try to learn haskell?
16:10:08 <identity> btcNeverSleeps: Modular exponentiation is really simple to implement recursively, so it shouldn't be very difficult to implement
16:10:18 <Iceland_jack> user___: Not really, you can learn Haskell without any background
16:10:23 <johnw> user___: I knew zero math when I started
16:10:29 <user___> thanks guys
16:11:04 <erisco> johnw, after you have read the tvar, is it possible for another thread to mutate the value before you write your changes?
16:11:08 <btcNeverSleeps> identity: oh I see... I thought there would be ready to use: I can multiply gigantic numbers and found "exp" and "mod", so I thought modular exponentiation would be in it too :)
16:11:14 <johnw> erisco: no
16:11:21 <Gurkenglas> Category theory synergizes well I think, but that one is so far up you shouldn't bother unless you've already heard of it
16:11:22 <johnw> erisco: that is the beauty of the TVar
16:11:31 <identity> btcNeverSleeps: There is almost certainly one on hackage
16:11:50 <Iceland_jack> identity: Look at lens library: Drink every time you don't understand a type signature. Remember to notify medical professionals before attempting this :)
16:12:27 <erisco> johnw, okay, so I presume it re-runs the transaction if the data was invalidated
16:12:32 <johnw> correct
16:12:39 <johnw> and it does so in a pretty intelligent way
16:13:20 <erisco> great. that'll remove a lot of headache for me
16:13:34 <identity> Iceland_jack: Hah. I like to think I can hold my liquor, but I'm pretty sure I would die by alcohol poisoning pretty fast there.
16:14:00 <Iceland_jack> I wonder if I should print out some modules and take them to the pub :)
16:14:32 <btcNeverSleeps> I'm very very new to Haskell... I'd need "shiftR", and I see this on hackage: http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Bits.html#v:shiftR   I've got a working Haskell (ghc) + Cabal + Emacs setup, how do I "add" Data-Bits / shiftR to, say, my Main.hs?
16:14:55 <johnw> import Data.Bits
16:15:03 <identity> Data.Bits is in base
16:15:04 <btcNeverSleeps> and it's going to be d/l'ed automatically?
16:15:13 <identity> (as you can see on the package name)
16:15:22 <identity> btcNeverSleeps: It's in the 'standard library'
16:15:26 <identity> so no need to download anything.
16:15:29 <btcNeverSleeps> ah it's in base, so it means I already have it and only need the import?:
16:15:32 <btcNeverSleeps> cool ^ ^
16:15:34 <Iceland_jack> yes
16:17:28 <identity> btcNeverSleeps: There seems to be a package called 'arithmoi' that implements modular exponentiation -- but it probably wouldn't be a bad exercise to implement it yourself since you're new to haskell
16:17:35 <identity> it's a pretty nice recursive function
16:17:58 <btcNeverSleeps> identity: you're right, that would be a cool first exercice...
16:19:57 <btcNeverSleeps> but curiosity is killing the cat: first I'd like to quickly time a "big" (1536 bits) modular exponentation and see how many ms it takes... I got the modpow working by taking some code and the result is correct. How can I "time" it at the repl? (I know it's going to be a crude approx, that's not a problem)
16:20:22 <shachaf> :set +s
16:21:45 <btcNeverSleeps> shachaf: thanks... That is interesting. I was expecting a function to which I'd pass another function (something a bit like Clojure's "time" function)
16:21:59 <shachaf> That sort of thing also exists.
16:22:00 <Iceland_jack> btcNeverSleeps: Take care that code run in GHCi is very different from compiled and optimized code
16:22:13 <Iceland_jack> If you want actual speed, use Criterion
16:22:30 <Iceland_jack> *If you want to _compare_ the actual speed
16:24:15 <erisco> johnw, what is the reason for ReaderT?
16:25:55 <oio`> is there any haskell online compiler that will give you the executable? for windows?
16:25:56 <jxv> erisco, for completeness (?)
16:28:27 <zcd> what are benefits of installing haskell-platform/cabal from source rather than through binary?
16:29:25 <dwcook> zcd, for everyday usage, not really
16:29:40 <dwcook> If you're hacking on GHC or cabal, then yes
16:29:43 <c_wraith> oio`: making one available would be potentially dangerous.  ghc has several ways of letting you execute arbitrary code at compile time
16:30:00 <arboris> zcd: the backend code generator might be able to create marginally faster code
16:30:02 <c_wraith> oio`: if you're feeding it full source files or command line options, that is
16:30:26 <dwcook> Oh, I misread as "Are there benefits"
16:30:48 <zcd> thanks, i'll stay with binary to keep it simpler
16:31:03 <oio`> c_wraith: can ghc crosscompile?
16:31:18 <zcd> what about ghc? freebsd only has pkg up to 7.4.2, but 7.8.2 has some nifty new features
16:31:25 <oio`> c_wraith: i think nope
16:31:33 <c_wraith> oio`: sort of.  More than it used to be able to.  But not perfectly.
16:31:36 <dwcook> zcd, you still don't have to install from source. 7.8.2 binaries are available.
16:31:40 <identity> zcd: Building the haskell platform with a newer version is pretty easy
16:31:50 <identity> using 7.8.2 binaries
16:32:01 <identity> well, I haven't tried with binaries
16:32:04 <dwcook> zcd, if your question is whether you should use distro packages or not, that's another question
16:32:09 <identity> with 7.8.2, that is
16:32:31 <c_wraith> oio`: there are issues with library compatibility between platforms.  Most libs that depend on C code aren't designed to work on windows.
16:32:39 <zcd> dwcook: i think that question matches what i mean more closely
16:33:11 <zcd> identity: does that mean boostrapping the build from source with binaries or using the 7.8.2 binaries available on the site?
16:33:16 <btcNeverSleeps> Iceland_jack: gotcha... That said from the look of it, I basically get the same speed with ghci as Clojure's BigInt (really Java's BigInteger AFAICT). So it's not, say, an order of magnitude slower or faster in this modular exponentiation example : )
16:33:19 <dwcook> zcd, 7.8.2 has some nice features but not all packages have caught up yet. You may run into problems until there's heavier adoption
16:33:23 <Gurkenglas> Does one of the functions (\l -> (l,r)) or (\r -> (l,r)) have a cleaner way to express it?
16:33:44 <c_wraith> Gurkenglas: how do you feel about using GHC extensions?
16:33:51 <oio`> c_wratih: yes
16:33:52 <Iceland_jack> Gurkenglas: (, r) and (l, )
16:34:00 <Iceland_jack> using TupleSections
16:34:12 <Iceland_jack> a very light-weight and harmless extension
16:34:14 <dwcook> zcd, this is pretty much the list of neat new things: https://www.haskell.org/ghc/docs/7.8.2/html/users_guide/release-7-8-1.html
16:34:26 <erisco> otherwise  ((,) l) and (flip (,) r)
16:34:27 <shachaf> ((,) l) for the second one.
16:34:42 <shachaf> With GHC extension TupleSections, (,r) and (l,).
16:34:50 <dwcook> zcd, alternatively you can install both 7.8.2 and 7.6.3 by using a configure prefix and add whichever you like to your PATH
16:34:57 <Iceland_jack> > (, 5) 'a'
16:34:58 <lambdabot>  ('a',5)
16:35:00 <Iceland_jack> > ((,) 5) 'a'
16:35:02 <lambdabot>  (5,'a')
16:35:25 <erisco> > flip (,) 5 'a'
16:35:26 <lambdabot>  ('a',5)
16:35:32 <zcd> dwcook: sounds good, thanks
16:35:45 <Gurkenglas> How do I include TupleSections? (I am currently working on compileonline.com)
16:35:56 <Iceland_jack> Gurkenglas: {-# LANGUAGE TupleSections #-} at the top
16:36:07 <btcNeverSleeps> I come with another very noobish question: in Emacs' inferior-haskell-mode, is there an easy way to get back the last line that I did input at the REPL? (e.g. for Clojure / cider-mode  <up> runs cider-previous-input).  When I do, say, arrow up, the cursor move up one line...
16:36:29 <Iceland_jack> if you're working in GHCi you can do
16:36:29 <Iceland_jack>     ghci> :set -XTupleSections
16:36:42 <Iceland_jack> btcNeverSleeps: M-p
16:37:27 <btcNeverSleeps> Iceland_jack: very custom setup here, can you tell me which function it is bound too? (M-x describe-key ...)
16:37:58 <Iceland_jack> comint-previous-input
16:38:02 <Gurkenglas> Werks :D @{}. GHCi is an IDE? There are arguments against using these extensions?
16:38:22 <btcNeverSleeps> Iceland_jack: thanks a lot
16:38:29 <erisco> johnw, I have to create something that resembles a database but in-memory only, as a client cache of data that is synced with the server
16:38:31 <identity> ghci is the ghc REPL.
16:38:34 <Iceland_jack> GHCi is the interactive mode
16:38:50 <Gurkenglas> Oh that thing, the learningthehardway mentioned that
16:38:58 <erisco> johnw, my thought at this time is that each object type would be maintained as a  TVar (Map String ObjectType)  which is a map from the id to the object data
16:39:01 <Iceland_jack> Some extensions are very pleasant, other extensions are meh, other extensions can be nasty :)
16:39:06 <Gurkenglas> I just started reading it when not at home and simply kept working on compileonline
16:39:15 <erisco> johnw, but I have not done mutability in Haskell much. do you have some thoughts?
16:39:15 <Iceland_jack> most of the syntax extensions are harmless
16:39:55 <BeardedCoder> btcNeverSleeps: C-up ?
16:40:54 <Iceland_jack> C-up or M-p or <menu-bar> <inout> <previous-history> here :)
16:41:17 <BeardedCoder> Speaking of haskell and emacs. Did you guys see the new release of ghc-mod?
16:45:32 <Jaood> does a hello world example has a binary size of 1.2MB because the ghc runtime is included in the resulting binary?
16:45:37 <bitemyapp> BeardedCoder: newer than 4.0.1?
16:45:50 <btcNeverSleeps> BeardedCoder: I've got a *very* special/custom keyboard setup and Emacs shortcut setup. I won't go into the details (unless you ask me) but it's safe to say I'm very probably the person who has put the most time configuring his keyboard / X / Emacs shortcuts ; )
16:46:17 <bitemyapp> oh, 4.1.0 now.
16:46:25 <BeardedCoder> ya, https://twitter.com/kazu_yamamoto/status/461487945665363969
16:46:43 <bitemyapp> BeardedCoder: that's pretty cool, but I've never once gotten ghc-mod to work for me.
16:46:46 <bitemyapp> even with assistance from others.
16:46:57 <bitemyapp> not in emacs or with all functionality, anyway.
16:47:09 <BeardedCoder> what. I can't imagine writing Haskell without it. I'm using Emacs
16:47:09 <bitemyapp> I'm a plague-carrier for bugs or something.
16:47:16 <bitemyapp> BeardedCoder: software hates me :(
16:47:22 <bitemyapp> that's why I write Haskell :)
16:47:52 <btcNeverSleeps> is ghc-mod something that you can use in addition to structured-haskell-mode?
16:48:31 <bitemyapp> yep.
16:48:35 <bitemyapp> orthogonal.
16:48:55 <BeardedCoder> Well since you weren't using it. The pain was if your code wouldn't compile, you got 0 type information out of ghc-mod. Now it will still give you types even with errors. Seems to work well. Also, my largest project went from like 2 seconds to instant to get type information.
16:49:29 <btcNeverSleeps> bitemyapp: great
16:49:43 <bitemyapp> BeardedCoder: that's incredible, I understand how ghc-mod works and can appreciate how big of an improvement that is.
16:49:48 <bitemyapp> BeardedCoder: I just never got it to work in a cabal sandbox.
16:50:41 <BeardedCoder> bitemyapp: Hum, I borrowed someone elses code to make it work with cabal. Though, a lot of work has been put in since, so that might not be necessary.
16:52:42 <BeardedCoder> bitemyapp: Whenever your in the office for a meetup or something, maybe I can help you with the setup. I'm not doing anything too fancy.
16:53:16 <akurilin> Random question: what's the recommended way to interpolate a prelude String? I hear quasiquoting is a good option here, but I want to double-check
16:54:58 <Iceland_jack> akurilin: Just using regular functions, yes: you can use quasi-quoting but KISS
16:55:25 <akurilin> Iceland_jack: what's the regular functions approach? I've stumbled on a dozen different recommended libraries for this on SO
16:55:40 <Iceland_jack> First of all what are you looking to do?
16:56:02 <Iceland_jack> It's possible to use Text.Printf.printf if you want to emulate the C-style formatter
16:56:02 <akurilin> I have a DB conn string that I want to interpolate with a bunch of values from environment variables
16:56:36 <bitemyapp> BeardedCoder: you underestimate my power to cause software to be have errantly, but if I haven't fixed it by then, I'd love to.
16:56:42 <bitemyapp> behave*
16:56:52 <BeardedCoder> cool
16:57:40 <bitemyapp> akurilin: don't want to use a simple template library?
16:57:44 <bitemyapp> akurilin: if not, I'd just ++
16:58:03 <bitemyapp> akurilin: I use a function for this in bloodhound, joinPath.
16:58:19 <bitemyapp> akurilin: joinPath = intercalate "/"
16:58:27 <bitemyapp> akurilin: [hostname, path, etc etc]
16:58:49 <bitemyapp> > intercalate "" $ fmap show $ [1, 2, 3]
16:58:51 <lambdabot>  "123"
16:59:12 <bitemyapp> akurilin: anything else I can do for you sir?
16:59:13 <Iceland_jack> > concatMap show [1,2,3] -- :)
16:59:14 <lambdabot>  "123"
16:59:26 <Iceland_jack> > [1,2,3] >>= show -- NO DON'T DO I…
16:59:28 <lambdabot>  "123"
16:59:32 <bitemyapp> LOL
16:59:52 <bitemyapp> Iceland_jack: I used intercalate because I'm "/" separating the elements in my own function, but yeah.
17:00:05 <Iceland_jack> yeah I was just dorking around :)
17:00:07 <bitemyapp> Iceland_jack: he's using db params, he might need to separate the args by & or something.
17:00:22 <jin_jin> Iceland_jack: You're here!
17:00:29 <Iceland_jack> Oh jin_jin! You're here!
17:00:30 <bitemyapp> akurilin: if you're creating URLs, consider using a URL builder/parser.
17:00:39 <Iceland_jack> Are you in Finland with fry as well?
17:00:46 <jin_jin> no
17:01:07 <jin_jin> going to sleep now. Good night. =)
17:01:12 <Iceland_jack> good night :)
17:10:16 <intrados`> Do the new pattern synonyms support infix pattern synonyms?
17:11:10 <Iceland_jack> No sadly not
17:11:17 <Iceland_jack> well, it does binary ones
17:11:22 <Iceland_jack> but not n-ary
17:11:45 <intrados`> Okay, thanks
17:11:51 <Iceland_jack> You can do
17:11:52 <Iceland_jack>     pattern a :+ b = Plus a b
17:11:52 <Iceland_jack> and use it as you'd expect, but something like
17:11:52 <Iceland_jack>     pattern (a :• b) c = Foo a b c
17:11:54 <augur> anyone know of any (hopefully introductory) literature on geometries that let you describe relative locations, but not absolute locations?
17:11:55 <Iceland_jack> won't work
17:11:56 <augur> ideally in a non-analytical fashion
17:20:17 <dwcook> augur, you talking about affine spaces?
17:20:18 * hackagebot lifted-async 0.2.0 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.2.0 (MitsutoshiAoe)
17:21:04 <Gurkenglas> What's the name of the canonical function that turns a a->b->c into a b->a->c?
17:21:14 <dwcook> @type flip
17:21:15 <lambdabot> (a -> b -> c) -> b -> a -> c
17:21:20 <Gurkenglas> kthx
17:24:08 <akurilin> bitemyapp: back, sorry, was messing around with it
17:24:48 <bitemyapp> akurilin: whatevs. Do yo thing.
17:25:00 <bitemyapp> akurilin: I'm futzing around with Clojure. time spent giving Haskell advice is 1000x more fun.
17:25:01 <akurilin> printf worked fine, but am I losing some form of safety here?
17:25:16 <bitemyapp> I've never used printf so I'm not a good person to ask.
17:25:29 <bitemyapp> akurilin: I guess it's probably a partial function, if I had to guess?
17:25:38 <bitemyapp> akurilin: try using it in an invalid way. Does it give a type error or throw an exception?
17:25:46 <Ptival> is it me or does http://hackage.haskell.org/package/xml-conduit-1.2.0.1/docs/src/Text-XML-Stream-Parse.html not expose the relevant bits to use decodeHtmlEntities in ParseSettings?
17:27:31 <akurilin> bitemyapp: yeah it compiles just fine if I do > printf "%s" (1 :: Int)
17:27:34 <peddie> akurilin: you can use the 'formatting' package to do printf stuff in a type-safe way; printf can throw an exception if you give the wrong format string
17:27:36 <akurilin> exception in repl
17:28:20 <pyon> Is there any implementation of a prefix tree with String or Text keys in Hackage?
17:28:21 <akurilin> peddie: that's good to know, it was frequently mentioned in reponses
17:28:23 <Gurkenglas> Is there a good automated way to find library functions that fit a given type? Like "@type^-1 (x -> y -> z) -> y -> x -> z" to get a list that contains flip
17:28:58 <pyon> @hoogle (a -> b -> c) -> (b -> a -> c)
17:28:58 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
17:28:59 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
17:28:59 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
17:29:03 <pyon> ^ Gurkenglas
17:29:07 <Gurkenglas> Wee
17:29:48 <Gurkenglas> @hoogle (x -> y -> z) -> y -> x -> z
17:29:48 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
17:29:48 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
17:29:48 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
17:29:54 <bitemyapp> akurilin: I meant arity, actually.
17:30:03 <bitemyapp> akurilin: not implicit coercion
17:30:05 <Gurkenglas> (Just checking whether its up to isomorphism)
17:30:13 <bitemyapp> >printf "%d %s" 1
17:30:18 <bitemyapp> > printf "%d %s" 1
17:30:20 <lambdabot>  No instance for (GHC.Show.Show a0)
17:30:20 <lambdabot>    arising from a use of ‘M90408130007404963575191.show_M90408130007404963575...
17:30:20 <lambdabot>  The type variable ‘a0’ is ambiguous
17:30:20 <lambdabot>  Note: there are several potential instances:
17:30:20 <lambdabot>    instance [safe] GHC.Show.Show
17:30:21 <pyon> Gurkenglas: up to alpha-renaming
17:30:26 <bitemyapp> > printf "%d %s" (1 :: Int)
17:30:27 <lambdabot>  No instance for (GHC.Show.Show a0)
17:30:27 <lambdabot>    arising from a use of ‘M1391733366242651575204.show_M1391733366242651575204’
17:30:27 <lambdabot>  The type variable ‘a0’ is ambiguous
17:30:28 <lambdabot>  Note: there are several potential instances:
17:30:28 <pyon> alpha-equivalence*
17:30:30 <lambdabot>    instance [safe] GHC.Show.Show
17:30:31 <Gurkenglas> Sure why not
17:30:43 * bitemyapp gives up, flips table, walks out the door
17:30:47 <FreeFull> > printf "%d %s" 1 :: String
17:30:48 <lambdabot>  "1 *Exception: printf: argument list ended prematurely
17:31:07 <bitemyapp> akurilin: there. see. Exception.
17:31:27 <bitemyapp> so arity can cause exceptions if you dont check out what peddie said.
17:36:20 <haasn> there's also something like Text.Printf.Mauke.TH which does TH-level parsing of the string to generate the right type signature
17:36:55 <haasn> And as far as “pure formatting” is concerned, I thought xformat does a good job of reifying layout structures as first class values. Disclaimer: I haven't looked at “formatting”
17:37:24 <Guest42919> hey guys im doing the LYAH thing and I'm at the point where I've made a function thing and saved it. Now when I try to run it in command prompt(after entering the ghci thing) it says the file isn't a module or a source file. Next I tried opening a new command prompt, use cd to get to the folder that the designated file is in, then entering ghci and attempting to run the file, and it still doesn't work
17:37:37 <akurilin> bitemyapp: that's a good point, so many different ways for that to blow up at runtime
17:37:43 <Guest42919> and I tried using cd in ghci but I didn't really understand how to use it
17:37:54 <bitemyapp> akurilin: if your surface area is minimal and you're going to test it, it's not a big deal to use vanilla printf
17:38:12 <haasn> but it looks like “formatting” does a good job, although I haven't dismantled and understood the types involved yet
17:38:14 <bitemyapp> akurilin: if you're going to use it prolifically or not have a centralized arity/point of entry...consider using something that runs at compile-time.
17:38:27 <bitemyapp> or however "formatting" works.
17:38:28 <Iceland_jack> Guest42919: you can use
17:38:28 <Iceland_jack>     ghci> :cd /di/ectory/
17:38:28 <Iceland_jack> to navigate to the correct place
17:38:39 <Iceland_jack> Guest42919: What does your saved file look like?
17:39:15 <Guest42919> It's  doubleMe x = x + x which was just taken from the example on the LYAH
17:39:37 <Iceland_jack> Does it include leading spaces?
17:40:37 <Guest42919> What are leading spaces?
17:40:45 <Guest42919> Probably not, it didn't mention those
17:40:50 <Iceland_jack> Guest42919: Here's an example of my shell session
17:40:50 <Iceland_jack>     $ cat > test.hs
17:40:50 <Iceland_jack>     double x = x + x
17:40:50 <Iceland_jack>     ^D
17:40:53 <Iceland_jack>     $ ghci test.hs
17:40:56 <Iceland_jack>     *Main> double 5
17:41:00 <Iceland_jack>     10
17:41:04 <Iceland_jack> omitting some noise
17:41:15 <Iceland_jack> Guest42919: Leading spaces are spaces at the front of the function for example
17:41:45 <haasn> interesting, formatting is based on indexed monads and category composition
17:41:54 <Iceland_jack> Another way to test it is to run GHCi (preferably in the same directory) and then loading the file via ':load' (or :l)
17:42:22 <Iceland_jack>     $ ghci
17:42:22 <Iceland_jack>     Prelude> :load file.hs
17:42:22 <Iceland_jack>     *Main> double 5
17:42:22 <Iceland_jack>     10
17:42:34 <Iceland_jack> does that help Guest42919?
17:42:38 <Guest42919> to run GHCi in the directory would you just use cd /directory/ while in regular command prompt, then type ghci?
17:42:45 <Iceland_jack> yes for example
17:42:45 <Guest42919> yeah I'm trying it right now
17:42:49 <Iceland_jack> You acn also do that within GHCi
17:42:52 <Iceland_jack> *can
17:42:52 <Iceland_jack>     
17:43:35 <Gurkenglas> How do I temporarily define names when talking to the bot?
17:43:43 <Iceland_jack> lambdabot?
17:43:47 <Guest42919> is there anything like dir once you're in GHCi so I can make sure I'm in the right directory?
17:43:48 <haasn> Gurkenglas: @let id x = x
17:43:57 <Gurkenglas> kthx
17:44:03 <Iceland_jack> Guest42919: You can do
17:44:04 <Iceland_jack>     ghci> :! pwd
17:44:41 <haasn> Gurkenglas: but note that if you're using lambdabot privately, you could most likely also just fire up GHCi and get pretty much the same behavior, perhaps sans some dependencies and useful functions - unless, of course, you're IRCing from a platform in which you can't run GHCi
17:45:56 <Gurkenglas> I'm changing platforms frequently and having to set that up each time is mehzy enough that having a steady IRC line might be easier
17:45:58 <haasn> Guest42919: silly question but does your file end with .hs ?
17:46:09 <Gurkenglas> Although, maybe there is some web ghci...
17:46:15 <Guest42919> Yeah haasn I realized that right before you said that
17:46:24 <Guest42919> I feel really stupid now
17:46:25 <Guest42919> thanks for helping guys
17:46:31 <haasn> (Or with .lhs, but that has slightly different semantics)
17:46:57 <Iceland_jack> you're welcome Guest42919 :) there are also non-guys here
17:47:00 <haasn> Guest42919: Don't worry, I get tripped up by GHCi's filename-sensitivity from time to time, too
17:47:17 <Guest42919> When I was saving it, I set the file type as haskell so I assumed it would add .hs but it didn't
17:47:31 <Gurkenglas> How do I enable an extension in a bot query?
17:47:40 <haasn> Gurkenglas: I don't think you can
17:47:50 <Gurkenglas> Welp time to set up ghci
17:48:10 <haasn> > if | True -> ()
17:48:11 <lambdabot>  <hint>:1:1: Multi-way if-expressions need MultiWayIf turned on
17:48:18 <haasn> @let {-# LANGUAGE MultiwayIf #-}
17:48:19 <lambdabot>  Parse failed: Parse error: EOF
17:48:21 <haasn> Ah, okay
17:48:32 <haasn> @let {-# LANGUAGE MultiWayIf #-}
17:48:32 <lambdabot>  Parse failed: Parse error: EOF
17:49:17 <Gurkenglas> @let {-# LANGUAGE MultiWayIf #-} Gurkenglas_5_1_2014_2_46_18=5
17:49:17 <lambdabot>  Parse failed: Parse error: Gurkenglas_5_1_2014_2_46_18
17:49:19 <akurilin> bitemyapp: makes total sense
17:49:41 <Gurkenglas> @let {-# LANGUAGE MultiWayIf #-} \n Gurkenglas_5_1_2014_2_46_18=5
17:49:41 <lambdabot>  Parse failed: Parse error: \
17:50:28 * btcNeverSleeps thanks everybody and is off to sleep
17:50:48 <prototrout> but I thought btcNeverSleeps!
17:51:00 <Iceland_jack> They're not btc apparently!
17:55:23 * hackagebot Omega 1.0.2 - Integer sets and relations using Presburger arithmetic  http://hackage.haskell.org/package/Omega-1.0.2 (ChristopherRodrigues)
18:09:49 <Guest42919> how do you register a nickname?
18:10:11 <Gurkenglas> You do /nick Name for the name you want, then /ns register ... something.
18:10:18 <Gurkenglas>  /ns help should help
18:10:24 <Guest42919> thanks
18:10:28 <Gurkenglas> (I think /ns help register)
18:10:39 <Guest42919> yeah that's it
18:12:13 <Egads> After I've loaded a script into ghci with :l, how do I go back to the normal Prelude> prompt
18:13:12 <roboguy_> Egads: :set prompt "..."
18:13:30 <Egads> does that unload the script too?
18:13:34 <roboguy_> Egads: I have something in my .ghci that prevents it from showing all the modules in the prompt int he first place
18:13:44 <roboguy_> no, it just sets the prompt
18:13:58 <wjad> Is there any way to permanently set the prompt while in ghci?
18:14:21 <Egads> I guess the question I was really asking is how to unload a script
18:14:27 <roboguy_> wjad: yeah, put :set prompt "..." in your ghci.conf file
18:14:36 <roboguy_> and :set prompt2 "..." to set the prompt for multiline stuff
18:14:45 <wjad> alright thanks
18:15:36 <roboguy_> Egads: this will unload all the imported modules: +m
18:15:40 <roboguy_> I mean :m
18:17:40 <Egads> Awesome, thanks
18:17:41 <oio`> any good physical units implementation?
18:21:24 <wjad> is there any way to make the terminal colored like in the examples on LYAH?
18:25:26 * hackagebot cassava-streams 0.1.0.0 - io-streams interface for the cassava CSV library.  http://hackage.haskell.org/package/cassava-streams-0.1.0.0 (PeterJones)
18:33:47 <roboguy_> wjad: there's some information about that here http://www.haskell.org/haskellwiki/GHCi_in_colour
18:37:33 <rtpg> do people use Haskell with RDBMSs at all? all the interfaces on haskell.org seem to be very inactive
18:37:40 <imalsogreg> @pl \a b -> compare (fromIntegral a) (fromIntegral b)
18:37:40 <lambdabot> (. fromIntegral) . compare . fromIntegral
18:37:58 <[swift]> rtpg: did you look at the *-simple ones?
18:38:25 <davidthomas> rtpg: I like Esqueleto
18:38:29 <roboguy_> imalsogreg: I'd use comparing fromIntegral
18:39:00 <imalsogreg> roboguy_: Thanks!!
18:39:16 <imalsogreg> roboguy_: That one's been bugging me.
18:41:09 <imalsogreg> roboguy_: Oh, and it makes sortBy read so nicely...  sortBy (comparing spikeTimes) spikes
18:41:51 <roboguy_> imalsogreg: it can be shortened more with GHC.Exts: sortWith spikeTimes
18:42:52 <imalsogreg> roboguy_: Seems like a strange module for that fn. I guess there's some GHC-specific shortcut in it?
18:43:28 <roboguy_> imalsogreg: I agree, it's a strange place. nope, the source code is: sortWith f = sortBy (\x y -> compare (f x) (f y))
18:43:57 <imalsogreg> roboguy_: Shrug. No complaints :)
18:45:08 <ReinH> roboguy_: sortBy . comparing
18:45:40 <roboguy_> ReinH: I know, but for some reason the source code is "sortWith f = sortBy (\x y -> compare (f x) (f y))"
18:46:23 <ReinH> that ought to be the same as `sortWith = sortBy . comparing'
18:46:33 <ReinH> unless something something polymorphism
18:47:06 <imalsogreg> ReinH: I don't know the principles behind the organization. Any guess why sortWith is in GHC.Exts?
18:47:49 <ReinH> I'm not sure.
18:48:02 <ReinH> Often you want to do that with a schwartzian transform anyway
18:48:18 <ReinH> well, you do if f is expensive
18:49:11 <ReinH> :t \f -> map fst . sortBy (comparing fst) . map (id &&& f)
18:49:12 <lambdabot> Ord a => (a -> b) -> [a] -> [a]
18:49:48 <ReinH> woops, make that `comparing snd'
18:49:52 <imalsogreg> ReinH: I'm confused by that type!
18:50:01 <ReinH> :t sortBy . comparing
18:50:02 <lambdabot> Ord a1 => (a -> a1) -> [a] -> [a]
18:50:09 <ReinH> :t \f -> map fst . sortBy (comparing snd) . map (id &&& f)
18:50:09 <lambdabot> Ord a => (b -> a) -> [b] -> [b]
18:50:11 <ReinH> it's the same
18:51:01 <imalsogreg> ReinH: Following along on wikipedia, that's how you'd do this Schwartzian trick?
18:51:21 <ReinH> right
18:52:01 <ReinH> it's useful if it's more important to minimize the number of times the comparison function is used relative to the number of times the list is traversed
18:52:19 <imalsogreg> ReinH: Very cool thanks. I'm sorting by a record field now, but my bag of tricks is now bigger for next time. :-)
19:04:40 <YellowOnion> How do I use bernoulli distribution with random-fu?
19:05:01 <l0cust> YellowOnion: good question
19:05:08 <l0cust> YellowOnion: I have no clu
19:05:12 <l0cust> e
19:06:34 <YellowOnion> I though I could just replace "uniform" with "boolBernoulli" and everything would work but the errors are opaque to me.
19:08:38 <l0cust> YellowOnion: show us the code?
19:09:52 <YellowOnion> l0cust: I don't really have any code I'm using ghci
19:10:12 <l0cust> Nonetheless, what are the specific error messages
19:10:27 <l0cust> and what is the code you are trying
19:10:31 <c_wraith> more usefully, what are the types of uniform and boolBernoulli?
19:10:31 * hackagebot elm-get 0.1.1.3 - Tool for sharing and using Elm libraries  http://hackage.haskell.org/package/elm-get-0.1.1.3 (EvanCzaplicki)
19:11:10 <l0cust> :t uniform
19:11:11 <lambdabot> Not in scope: ‘uniform’
19:11:15 <imalsogreg> l0cust: Whatever line you're typing at ghci, paste in here: http://lpaste.net/
19:11:35 <c_wraith> ok, I looked at random-fu.  Those types aren't really similar
19:11:58 <c_wraith> well, similar.  But uniform takes more arguments
19:12:01 <YellowOnion> l0cust: http://lpaste.net/103450
19:12:09 <c_wraith> so obviously they can't be interchangeable
19:13:14 <l0cust> YellowOnion: what c_wraith said
19:13:24 <YellowOnion> c_wraith: I'm not litterally interchanging them...
19:14:53 <imalsogreg> If anyone knows about random-fu, interrupt me, b/c I'm guessing, but - from the second error it looks like you might make some headway by adding some type annotations.
19:15:55 <c_wraith> YellowOnion: Oh, I think imalsogreg is right
19:16:14 <c_wraith> YellowOnion: say that the argument to boulBernoulli is of type Double, or whatever
19:20:32 * hackagebot Elm 0.12.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.12.1 (EvanCzaplicki)
19:21:26 <YellowOnion> c_wraith: I guess that is a step in the right direction, now I'm only getting the Lift section of the error
19:22:36 <gamegoblin> Let’s say I have two haskell programs running that are both using the same datatype X. Is there any way I can make an exact copy of an object of X from one program to the other (other than going over sockets or something)
19:23:07 <c_wraith> YellowOnion: try adding an IO Bool annotation to the whole line
19:23:19 <wjad> on an example from LYAH,
19:23:24 <wjad> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
19:23:30 <imalsogreg> YellowOnion: Can you tell me what this mwc value you have is?
19:23:45 <wjad> I understand the if else stuff, but I don't understnad what the x <- xs does
19:24:13 <wjad> I know that odd x filters it so that only odd values of x are used
19:24:21 <c_wraith> YellowOnion: oh, nevermind, you're not using sample with the IO instance of MonadRandom
19:24:24 <wjad> but I don't really get what the x <- xs does
19:24:27 <YellowOnion> imalsogreg: https://github.com/mokus0/random-fu#usage This is the example I based my code off its the random source
19:24:39 <imalsogreg> wjad: Can read it like, "the x in the left expression, fill in that with each value of xs, in turn"
19:24:40 <gamegoblin> wjad: Have you used a program language that has a “for each” loop?
19:24:53 <Welkin> for each x in xs
19:25:04 <Welkin> it is just extracting values from the list xs
19:25:13 <wjad> ohh I get it
19:25:17 <c_wraith> gamegoblin: well, what options do any programs have for moving data between processes?
19:25:27 <gamegoblin> c_wraith: tbh I’ve never done it before
19:25:34 <wjad> thanks for clearing it up imalsogreg and Welkin
19:26:18 <c_wraith> gamegoblin: in all cases, it comes down to serializing it to some sequence of bytes, then making that sequence of bytes available to the other process...  Socket, pipe, shared file...  something.
19:26:37 <Welkin> you can read "x <- xs" as "x from xs"
19:27:11 <gamegoblin> c_wraith: Does haskell have any deep voodoo to allow me to grab the underlying byte representation of some data, then I can unsafeCoerce it on the other side
19:28:25 <c_wraith> gamegoblin: you can't just copy the in-memory representation.  It has a lot of implicit context.
19:29:31 <gamegoblin> c_wraith: didn’t know that… shoot… Because doing any sort of `show` or `read` on this data is going to murder performance (very large, very complex datatype)
19:29:59 <c_wraith> gamegoblin: however, both the binary and cereal packages include ways of automatically generating instances for serializing and deserializing values of your types.
19:30:19 <gamegoblin> c_wraith: i’ll look into it, thanks
19:30:33 * hackagebot Elm 0.12.1.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.12.1.1 (EvanCzaplicki)
19:30:37 <imalsogreg> YellowOnion: Still there?
19:31:32 <imalsogreg> YellowOnion: Randomly adding type annotations helped.   create >>= flip sampleFrom (bernoulli (0.2 :: Double)) :: IO Double
19:33:20 <imalsogreg> YellowOnion: Seems that the library is very general with the types you use to query a PDF, and with the type of the value you want to get back. So if you aren't using the values elsewhere in the code, you have to specify which types you want.
19:36:23 <YellowOnion> ahh putting IO Bool at the end returns a bool
19:46:11 <YellowOnion> imalsogreg: thanks for your help.
19:48:11 <Algebr> How can I get something to work that captures this idea: myFunc (word <-otherFunc getLine) (word2 <- otherThingThatReturnsIO)
19:48:37 <heatsink> what does myFunc do?
19:50:11 <Algebr> it takes two strings
19:50:51 <heatsink> Okay.  You can use a do block to sequence the actions.  Each statement does one action.
19:51:15 <heatsink> do {word <- otherFunc getLine; word2 <- otherThing; myFunc word word2}
19:51:28 <heatsink> That's assuming that otherFunc, otherThing, and myFunc return IO actions
19:52:08 <Algebr> Right, and I know I could do that, but I wanted to know if I could done a one line solution for this.
19:52:28 <Algebr> do a *
19:53:10 <apples> there's always applicative style, with <*>
19:53:12 <zeiris> myFunc <$> otherFunc getLine <*> otherThingThatReturnsIO
19:54:04 <roboguy_> zeiris, apples: if myFunc returns an IO action, you need a join as well
19:55:58 <Algebr> roboguy_: myFunc return IO ()
19:56:02 <Algebr> returns
19:56:32 <roboguy_> Algebr: you could use join $ myFunc <$> otherFunc <*> otherThing
19:58:41 <Algebr> @hoogle join
19:58:42 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
19:58:42 <lambdabot> package join
19:58:42 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
20:02:45 <roboguy_> :t join $ (undefined :: IO Int -> IO Int -> IO Int) <$> ?otherFunc <*> ?otherThing
20:02:46 <lambdabot> (?otherThing::IO (IO Int), ?otherFunc::IO (IO Int)) => IO Int
20:03:14 <roboguy_> Algebr: why does the function take two IO arguments? usually that isn't necessary
20:03:30 <roboguy_> oh nevermind
20:03:48 <roboguy_> :t join $ (undefined :: Int -> Int -> IO Int) <$> ?otherFunc <*> ?otherThing
20:03:49 <lambdabot> (?otherThing::IO Int, ?otherFunc::IO Int) => IO Int
20:05:54 <Algebr> roboguy_: its for my small sms app. I'm taking two IO String, the phone number typed in and the message and I pass the two strings to my function that using curl to send the sms.
20:06:11 <orion> hmm. I am trying to convert a ByteString to a Word64. What's the best way to go about this?
20:06:17 <Algebr> the io strings are coming from gtk
20:06:26 <roboguy_> Algebr: ah, ok
20:06:27 <Algebr> the join also worked, which is nice.
20:06:55 <roboguy_> orion: you want to put an entire ByteString into a Word64?
20:06:58 <orion> yes
20:07:19 <orion> I can guarantee that the ByteString is 8 bytes.
20:07:43 <copumpkin> use Data.Binary.Get
20:07:46 <copumpkin> and specify the endianness
20:07:57 <roboguy_> copumpkin: aw you *just* beat me
20:08:03 * copumpkin beats roboguy_ harder
20:08:28 <copumpkin> :)
20:09:19 <roboguy_> haha
20:10:49 <orion> hmm
20:11:29 <orion> So, I am trying to do: runGet getWord64le v -- where v :: Data.ByteString.ByteString. But runGet is expecting Data.ByteString.Lazy.Internal.ByteString
20:11:39 <orion> This confuses me.
20:11:55 <copumpkin> yeah, so you have a strict bytestring and it wants a lazy one
20:12:02 <copumpkin> there's a simple conversion function
20:12:31 <dmj`> runGetLazy
20:12:59 <copumpkin> fromStrict :: ByteString -> ByteString
20:13:04 <copumpkin> that's strict -> lazy
20:13:14 <copumpkin> in Data.ByteString.Lazy
20:13:41 <mhr> I'm trying to understand monads, and I understand >> and >>=, but the last hurdle for me is return. So it takes in a value and turns it into a monad containing that value... but what kind of monad? How does it know what kind of monad that value has to become?
20:15:09 <tromp_> by type inference
20:15:18 <dmj`> mhr: you define return when you make an instance of the Monad class, for a given datatype
20:15:21 <tromp_> but it can be polymorphic too
20:15:28 <tromp_> :t return 0
20:15:29 <lambdabot> (Num a, Monad m) => m a
20:15:34 <dmj`> > return 4 :: Maybe Int
20:15:35 <lambdabot>  Just 4
20:15:43 <dmj`> > return [] :: [String]
20:15:44 <lambdabot>  [""]
20:16:03 <dmj`> > return 1 :: Identity Int
20:16:04 <lambdabot>  Identity {runIdentity = 1}
20:21:43 <mhr> dmj`: okay, thanks, that helps a bunch
20:28:47 * maybefbi ** SysInfo ** Client: HexChat 2.9.6 (x64) ** OS: Microsoft Windows 7 Home Premium  ** CPU: Intel(R) Core(TM) i7-3517U CPU @ 1.90GHz (1.00 GHz) ** RAM: 16264 MB Total (13353 MB Free) ** VGA: AMD Radeon HD 7570M ** Uptime: 2.47 Hours **
20:36:24 <mhr> By the way, what does "=>" mean?
20:36:53 <orion> "in the context of" ?
20:37:20 <maybefbi> I need help with this error: https://github.com/haskell/cabal/issues/1698#issuecomment-41875793
20:37:28 <jle`> mhr: in practice you can think of it has (Constraints) => type signature
20:37:45 <jle`> Monad m => m a means that m is constrained to be an instance of the Monad typeclass in "m a"
20:38:53 <mhr> why couldn't you just do :: Monad Num as the type of return 0? Why are constraints necessary?
20:39:03 <jle`> mhr: because Monad is not a type
20:39:05 <jle`> and Num is not a type
20:39:11 <jle`> they are typeclasses
20:39:19 <jle`> have you learned about typeclasses?
20:39:25 <mhr> not yet
20:39:28 <jle`> ah
20:39:32 <roboguy_> is there magic in the Show instance for String?
20:39:53 <jle`> well it's a fairly integral part of understanding Monads, because Monad in haskell is a typeclass :)
20:40:05 <jle`> if you've ever used an OOP language like Java, typeclasses are like interfaces
20:40:19 <jle`> and saying Monad m => m a is like saying that m implements the Monad interface.  kinda.
20:40:39 <jle`> another practical reason is that it's common to have more than one constraint on the same type
20:40:47 <dmj`> (=>) in the context of classes means super class of, like Applicative m => Monad m
20:40:52 <jle`> :t \x -> show (x + 5)
20:40:53 <lambdabot> (Show a, Num a) => a -> String
20:41:41 <jle`> if you want to show an (x + 5), x has to be a Number (that is, it has to implement the Num typeclass which specifies the "+" operator) and also a Showable thing (it imeplements the Show typeclass, which specifies a "toString"-ish function)
20:41:51 <steshaw> @pl \f a = fmap ($ a) f
20:41:51 <lambdabot> (line 1, column 6):
20:41:51 <lambdabot> unexpected "="
20:41:51 <lambdabot> expecting pattern or "->"
20:42:09 <steshaw> @pl \f a -> fmap ($ a) f
20:42:09 <lambdabot> flip (fmap . flip id)
20:42:13 <jle`> :t fmap ($ a) f
20:42:14 <lambdabot> (FromExpr (f (Expr -> b)), Functor f) => f b
20:42:25 <bitemyapp> FromExpr?
20:42:26 <jle`> :t \f a -> fmap ($ a) f
20:42:27 <lambdabot> Functor f => f (a -> b) -> a -> f b
20:42:33 <jle`> bitemyapp: it's a part of lambdabot's reflection stuff >_>
20:42:48 <monochrom> mhr: return 0 has type (Num a, Monad m) => m a
20:42:49 <jle`> :t \f a -> f <*> pure a
20:42:50 <lambdabot> Applicative f => f (a -> b) -> a -> f b
20:42:58 <jle`> ^^ steshaw
20:43:16 <jle`> there's also the slightly uglier
20:43:29 <jle`> :t \f a -> pure a <**> f
20:43:30 <lambdabot> Applicative f => f (a -> b) -> a -> f b
20:43:34 <jle`> but why would you want to do that >_>
20:43:41 <mhr> Just up what typeclasses are, and damn is that cool.
20:43:42 * jle` was just playing around
20:43:52 <mhr> *Just looked
20:44:11 <jle`> mhr: yup, and it only gets cooler the more you use it
20:44:33 <monochrom> I like type class too. great invention.
20:44:33 <jle`> it contributes a lot preventing bugs, as well
20:44:35 <jle`> more than you'd expect
20:44:39 <jle`> (at first)
20:44:51 <mhr> Monads are typeclasses and Nums are typeclasses, then. Is every type I might interact with in Haskell a typeclass?
20:44:56 <mhr> jle`: like what?
20:44:59 <jle`> typeclasses aren't types
20:45:03 <jle`> they are classes of types
20:45:09 <jle`> Num is a typeclass, and Int is a type
20:45:15 <mhr> ah
20:45:15 <jle`> Int happens to belong to many typeclasses
20:45:17 <shachaf> Monad is a type class and Num is a type class. Monads are not type classes.
20:45:29 <jle`> if you open up ghci, you can say :i Int
20:45:32 <monochrom> yes, most types you use are instances of some type classes.
20:45:35 <jle`> and you'll see all the typeclasses that Int "implements"
20:45:46 <jle`> (that it is an instance of)
20:46:25 <jle`> um someone here can probably point you to a good read explaining why typeclasses are great at bug prevention, but i have to run
20:47:04 <jle`> the main idea is that if you make your function polymorphic on members of a typeclass instead of on a concrete type, then anyone who uses your function will know "oh, this function will only ever be able to use x y and z functions/operators on it, and nothing more."
20:47:10 <Tordek> is it possible/where can I read up on how to make make .dll's or .so's in haskell?
20:47:37 <monochrom> my http://www.vex.net/~trebla/haskell/so.xhtml talks about *.so
20:47:51 <monochrom> I don't know how to do *.dll
20:47:54 <jle`> (x y and z being functions in that typeclass)
20:47:59 <Tordek> alright, thanks!
20:48:05 <heatsink> Usually you would make a cabal package to build a dynamic library
20:49:24 <dmj`> Tordek: the ghc user guide has info on how to make windows .dll's I believe
20:49:29 <mhr> I can see that typeclasses are a very powerful feature. Super cool. I've actually got to run too. Thanks for the help guys!
20:51:42 <ion> monochrom: I take it hs_init and hs_exit can be called multiple times (in case multiple Haskell .so files are being linked to)?
20:52:06 <monochrom> yes. consider them open parenthesis and close parenthesis, respectively
20:52:34 <ion> Ah, it “refcounts”
20:53:54 <sgronblo> every time i try do some haskell programming it ends before it starts with me staring at some cabal download that doesnt finish or a compile that errors out
20:56:36 <pharaun> how exactly does lambda bot support a open union of type, i'm still not quite for sure how it does it
20:56:46 <pharaun> i don't see a existional qualification or typeable casting
20:57:04 <pharaun> (re state for its plugin) i've been reading the source code and i'm not sure i quite grok it yet
20:57:46 <ion> What do you mean by an open union of type?
20:59:05 <ion> (In any case, lambdabot doesn’t do anything special. Anything it does can happen in ghc and ghci.)
20:59:08 <monochrom> lambdabot doesn't support an open union of types.
21:00:38 <pharaun> http://hackage.haskell.org/package/lambdabot-4.3.0.1/docs/Lambdabot-Plugin-Karma.html <- i'm just trying to figure out how it can allow modules have its own "state"
21:00:46 <mmachenry> ion: An open union is a notion from polymorphism that essentially supports an interface of having more unspecified operations.
21:00:52 <mmachenry> It's supported in OCaml
21:01:19 <mmachenry> Not in Haskell.
21:01:22 <pharaun> monochrom: i'm just trying to figure out how the heck does it store the state/how without having to in the end have some sort of sum-type
21:01:27 <ion> mmachenry: Ok, thanks
21:01:34 <l0cust> quit
21:01:35 <mmachenry> Row polymorphism I think is another name.
21:01:51 <pharaun> been reading through and i got some ideas but i'm still not quite for sure how it all comes together
21:01:58 <monochrom> ok, I am too lazy to study lambdabot, but since you know where to read its source code, you will find its answer.
21:02:21 <pharaun> well that's the thing i've been reading a bit and i'm still not sure i even know where/how its even being glued together
21:02:27 <monochrom> the trick is to actually read and refrain from speculating
21:02:39 <ion> http://hackage.haskell.org/package/lambdabot-4.3.0.1/docs/Lambdabot-Plugin.html “moduleSerialize” “If the module wants its state to be saved, this function should return a Serial.”
21:02:51 <ion> It serializes the state somewhere.
21:03:08 <pharaun> ion: so it serialize and deserialize it for every single message?
21:03:22 <ion> I don’t know. Not necessarily.
21:03:27 <pharaun> and as far as i can tell that's for storing to disk i think
21:03:38 <pharaun> upon shutdown/startup but for normal operation i'm still not sure
21:04:33 <pharaun> ion: i've found the parameterized type - st which is passed around.. but yeah i'm still at a loss as of "where" that state is being held exactly
21:05:58 <pharaun> I've found out how xmonad does it (typeable and casting + ExistentialQuantification but i don't see that yet in lambdabot :)
21:07:26 <pharaun> ion: moduleSerialize is only used w/ - writeGlobalState and readGlobalState
21:08:19 <pharaun> which i think is only on module unload/loading
21:09:43 <orion> createDirectory (head . getArgs) -- Couldn't match type `a0 -> c0' with `[Char]' hmm
21:10:24 <ion> You shouldn’t use head. It can crash with an unhelpful message.
21:10:26 <enthropy> @type createDirectory . head =<< getArgs
21:10:27 <lambdabot> Not in scope: ‘createDirectory’
21:10:27 <lambdabot> Not in scope: ‘getArgs’
21:10:52 <orion> ion: What should I use instead?
21:11:06 <ion> orion: Usually pattern matching.
21:11:38 <orion> ah
21:11:59 <ion> > let (x:_) = [4,5,6] in x  -- When you compile with -Wall, you will even get a nice warning about the case i forgot in this code.
21:12:00 <lambdabot>  4
21:12:17 <sgronblo> cabal help sandbox didnt do much to explain what a sandbox is
21:13:02 <monochrom> is "cabal sandbox --help" better?
21:13:16 <monochrom> orion: see my http://www.vex.net/~trebla/haskell/IO.xhtml
21:13:43 <sgronblo> monochrom: same text
21:14:29 <monochrom> alright, then somewhere in tibbe's blog has information about cabal's sandboxing
21:14:59 <pingu> Important question: Why is a thunk called a thunk?
21:15:08 <monochrom> is it important?
21:15:14 <pingu> To me.
21:15:39 <ion> The most important question in the history of humankind: why is that an important question?
21:15:39 <copumpkin> 'cause nobody thunk up a better name
21:16:23 <dmj`> :P
21:16:38 <pharaun> ouch
21:17:14 <ion> http://dictionary.reference.com/browse/thunk
21:17:25 <dmj`> sgronblo: a sandbox kind of is what it sounds like
21:18:42 <pingu> ion: so the onomatopoeic use or as a past tense think?
21:18:43 <sgronblo> dmj`: Yeah by some googling it was what I expected. I just thought the help could have dedicated at least a single line of text to describe it
21:18:59 <sgronblo> Whats the difference between cabal and cabal-dev?
21:19:14 <ion> cabal-dev is more or less deprecated now that cabal has builtin sandboxes.
21:19:56 <pingu> Ah. I se. It's in the jargon file. http://www.retrologic.com/jargon/T/thunk.html
21:20:03 <orion> getArgs returns IO [String]. Is there a way I can put "getArgs" directly in a case expression?
21:20:21 <sgronblo> ion: ah yeah thats what this page im checking indicates too
21:21:25 <monochrom> orion: no, but see my http://www.vex.net/~trebla/haskell/IO.xhtml , there is a similar example
21:21:59 <ion> do { args <- getArgs; … args … }. For one-off hacks nobody else is going to use, do { (arg:_) <- getArgs; … } will suffice, but i wouldn’t call that nice argument processing.
21:22:33 * geekosaur mutters something about lambdacase
21:22:55 <geekosaur> admittedly that;s not *quite* the same thing
21:23:17 <dmj`> orion: I like this trick "mapM_ go =<< getArgs", go :: String -> IO ()
21:23:29 <ion> geekosaur is referring to “arg <- getArgs >>= \case of arg:_ -> …; [] -> …” if you’re using LambdaCase.
21:23:47 <monochrom> since we got do-if-then-else, I think it's reasonable to ask for do-case
21:24:31 <monochrom> wait a second, last time do-if-then-else was accepted because they explicitly agreed "we won't discuss do-case"
21:24:41 <ion> Huh, i hadn’t noticed.
21:25:19 <orion> thank you monochrom, dmj`
21:37:56 <orion> Is TypeSynonymInstances dangerous?
21:40:51 * hackagebot Elm 0.12.1.2 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.12.1.2 (EvanCzaplicki)
21:45:37 <techtangents> Hello all. See https://gist.github.com/techtangents/37e4f79c6dc167e11979
21:45:37 <techtangents> I was wondering if it's possible to generalise this. fmap ties it to functor, but the $ ties it to (->). I was wondering if the (->) type could be generalised here somehow.
21:45:57 <pagerboy> Hi I have a query regarding the solveRPN code in The book LYAH , specifically the last line of the complete code which can be found here ( http://lpaste.net/103456), I do understand if `read x:[1,2,3]` would result in the code being trying to read x as an Int , but why should 'x:[]' be read as an Int ?
21:46:06 <shachaf> :t distribute
21:46:07 <lambdabot>     Not in scope: ‘distribute’
21:46:07 <lambdabot>     Perhaps you meant ‘distrib’ (imported from Control.Lens)
21:46:14 <shachaf> :t Data.Distributive.distribute
21:46:15 <lambdabot> (Data.Distributive.Distributive g, Functor f) => f (g a) -> g (f a)
21:46:30 <shachaf> techtangents: That's a generalization of flip. It's called (??) in lens.
21:46:42 <dmj`> orion: no
21:46:43 <shachaf> Distributive is even more general.
21:47:14 <shachaf> Except g is Distributive iff there's an r such that g a ~~ r -> a, so it's only sort of a generalization.
21:47:30 <techtangents> Wow. Thank you!
21:47:31 <carter> Category?
21:47:37 <carter> errr
21:47:39 <carter> not quite
21:57:40 <j0ni> hey, is there documentation for building and installing lambdabot for a modern ghc anywhere?
21:58:22 <j0ni> cabal install worked in the sense that i now have a lambdabot, but it starts with an error:
21:58:26 <j0ni> [ERROR] Plugin.djinnPlugin: Djinn command failed: fd:9: hClose: resource vanished (Broken pipe)
21:58:37 <pharaun> oh you need to install like djinn binary and etc
21:58:40 <j0ni> and it won't do things like @src
21:58:53 <j0ni> lambdabot> @src foldr
21:58:53 <j0ni> Plugin `sourcePlugin' failed with: state not initialized
21:59:52 <j0ni> thanks pharaun, that disposed of the startup error
22:00:07 <j0ni> what's "and etc"?
22:00:31 <j0ni> and do you know how i can get @src working?
22:09:54 <pharaun> j0ni: oh there's few binary you need like bf, djinn etc..
22:10:00 <pharaun> and as of @src i'm not sure :\
22:11:54 <peddie> j0ni: my experience with lambdabot is that your only option is to dive in and read the code
22:12:33 <ivanm> pharaun: pretty sure @src is a hard-coded list
22:13:12 <j0ni> peddie: ah fair enough, i guess we have a bootstrapping problem (for my brain)
22:13:40 <j0ni> though i can just message it on freenode i guess
22:13:40 <peddie> j0ni: don't be scared; I have always found that code pretty readable
22:13:55 <peddie> j0ni: you can /query her to ask questions without spamming the whole channel
22:14:02 <j0ni> yeah i have been :)
22:14:18 <j0ni> was hoping for some in-emacs love though
22:14:19 <pharaun> ivanm: oh?
22:14:20 <pharaun> good to know
22:14:36 <peddie> j0ni: you could use erc :P
22:14:42 <ivanm> j0ni: what were you hoping to do with lambdabot in emacs?
22:14:45 <j0ni> trus say
22:14:48 <j0ni> true say
22:14:57 <j0ni> GOA
22:15:01 <ivanm> I have the pointless tool configured in ghci with :pl
22:15:04 <j0ni> ivanm: ^^
22:15:15 <ivanm> you can probably do the same with djinn
22:15:22 * ivanm never had much luck with GOA, even in plain ghci
22:15:37 <ivanm> haskell-mode for emacs also has its own hoogle support
22:15:54 <j0ni> ivanm: oh that's interesting, i will look for that
22:15:55 <ivanm> that's the things I most want from lambdabot when actually writing code, and you don't need lambdabot herself to use them
22:16:03 <j0ni> in case it is not obvious, i am n00b
22:39:24 <j0nii> peddie: j0nii@erd
22:39:26 <j0nii> erc
22:40:51 <flebron> @free fmap
22:40:52 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
22:41:01 <peddie> j0nii: ?
22:41:03 <flebron> How can I ask lambdabot for the free theorem for fmap?
22:41:20 <peddie> flebron: I'm not sure it works for things with type class constraints
22:41:25 <flebron> (I'm trying to prove that f id = id => f (g . h) = f g . f h)
22:42:03 <j0nii> peddie: erc, inferior-haskell, haskell-mode
22:42:15 <peddie> j0nii: glad to hear it
22:42:27 <j0nii> now i just need learn you a haskell in as info doc
22:44:03 <j0nii> s/in//
22:46:05 * hackagebot Elm 0.12.1.3 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.12.1.3 (EvanCzaplicki)
22:47:10 <dmj`> fg
23:03:41 <orion> When should I use Data.ByteString, and when should I use Data.ByteString.Char7?
23:03:43 <orion> When should I use Data.ByteString, and when should I use Data.ByteString.Char8?
23:04:06 <l0cust> @time nclarke
23:04:20 <l0cust> @time orion
23:04:21 <lambdabot> Local time for orion is Thu May  1 02:02:51 2014
23:05:02 <mmachenry> Hey Orion, we're neighbors.
23:05:04 <mjrosenb> hey, that's my timezone!
23:05:10 * mjrosenb waves at orion 
23:05:10 <mmachenry> Well… maybe.
23:05:21 <l0cust> It's a bit sick that so many people are on #haskell at 2 AM
23:05:31 <mmachenry> mjrosenb where in −5 are ya?
23:05:55 <orion> I am near Boston.
23:05:59 <mjrosenb> mmachenry: you are 24 times more likely to be neighbors with him than with a random person in the channel!
23:06:03 <mmachenry> orion: Me too!
23:06:03 * mjrosenb is in PA.
23:06:38 <mmachenry> I go to PA all the time. Including next weekend. Near Allentown. I live in Boston.
23:06:56 <l0cust> Any fellow Utahns here?
23:06:56 <orion> I'm from NJ.
23:07:04 <mjrosenb> mmachenry: that's a bit of a drive.
23:07:09 <mmachenry> Yep
23:07:19 <mmachenry> orion: Where near Boston are you?
23:07:30 <mjrosenb> l0cust: does "Utahn" rhyme with "yawn"?
23:07:36 <l0cust> mjrosenb: yes
23:07:37 <orion> mmachenry: NH
23:07:38 <mmachenry> Are you going to the Boston meetup this month? I think I will. It'll be my first.
23:09:04 <l0cust> How's the northeast this time of year?
23:09:26 <mmachenry> Pretty decent.
23:10:01 <mjrosenb> a tad rainy, but personally, I like the rain.
23:10:29 <mjrosenb> mmachenry: did it dip below freezing last week for you as well?
23:12:18 <mmachenry> Nah
23:12:20 <orion> http://lpaste.net/1461037325935968256 <-- Is there a better way to do this?
23:12:22 <mmachenry> Well… maybe
23:12:47 <orion> I feel like Haskell offers a really elegant way to accomplish this
23:13:39 <mmachenry> orion: Yeah at first glance I think you want to use of the fact that Maybe is a monad
23:14:36 <mjrosenb> orion: can you paste a raw link? I want to look at it, but I currently lack a browser.
23:14:59 <orion> http://lpaste.net/raw/1461037325935968256
23:15:39 <mjrosenb> orion: danke.
23:16:52 <mjrosenb> orion: you can use maybe if you just want to avoid the cases.
23:16:55 <mjrosenb> :t maybe
23:16:56 <lambdabot> b -> (a -> b) -> Maybe a -> b
23:17:12 <mjrosenb> hrmm. no, there's something simpler than maybe that does it.
23:17:48 <mjrosenb> but maybe (fail "foo") id (decode pkBytes) /should/ work.
23:19:17 <mrb_> http://lpaste.net/103459   any idea why I can't    match expected type `DotStatements [Char]'          with actual type `Seq (DotStatement [Char])'
23:19:28 <mjrosenb> oh, but I bet you're both unpacking from Maybe, and re-packing as IO... aren't you.
23:19:35 <orion> indeed
23:20:03 <mjrosenb> orion: did you write decode?
23:20:44 <orion> yes
23:21:25 <mjrosenb> orion: I'd probably re-write it to take a failure string, and not return a Maybe
23:21:30 <mjrosenb> or at least write a wrapper that does that.
23:21:34 <orion> ok
23:22:00 <mmachenry> orion: I'd write this as a MaybeT IO KeySet
23:22:36 <mjrosenb> oh, or why even a MaybeT
23:22:36 <orion> Not a IO Maybe KeySet?
23:22:38 <mjrosenb> ErrorT
23:22:42 <mmachenry> And then you can just do { sk <- decode skBytes; nkBytes <- decode nkBytes}
23:23:11 <mjrosenb> mmachenry: that doesn't let you attach an error message to a failure at any given stage.
23:23:38 <mmachenry> Yes, I lose that.
23:24:41 <mjrosenb> orion: note: MaybeT IO KeySet, not MaybeT (IO KeySet).  monad transformers can be weird.
23:25:28 <orion> What would the body of the function look like>
23:25:42 <orion> If I switch it to MaybeT
23:25:58 <mmachenry> orion: It's late and this is an unchecked rewrite but this is what I'm thinking
23:25:58 <mmachenry> http://lpaste.net/103461
23:26:10 <mmachenry> Just to get something to you quickly.
23:26:24 <orion> @src liftIO
23:26:24 <lambdabot> Source not found. I am sorry.
23:26:29 <orion> :t liftIO
23:26:29 <lambdabot> MonadIO m => IO a -> m a
23:26:32 <orion> hmm
23:26:47 <orion> This is relevant to my interests.
23:27:11 <mmachenry> lifts an IO action into the monad you're in… which in this case is MaybeT IO
23:27:28 <napping> orion: you don't need anything fancy to just abstract out that readFile + decode + case pattern you have going
23:27:52 <orion> mmachenry: I do lose the ability to attach a fail message though.
23:28:12 <mmachenry> Yeah, as mjrosenb pointed out.
23:28:21 <orion> If I switch to ErrorT, will that alleviate it?
23:28:30 <mmachenry> If you do need that I like his suggestion of ErrorT
23:28:34 <mmachenry> Yep
23:29:12 <orion> Do I use "strMsg" to fail?
23:29:13 <mmachenry> Mine's a little simplistic but pretty nice for that reason.
23:29:49 <orion> Or do I use throwError?
23:30:03 <corgifex> :t strMsg
23:30:04 <lambdabot> Error a => String -> a
23:30:07 <napping> orion: the simple thing is just something like decodeKey file msg = do k <- fmap decode (BS.readFile file); case k of Just x -> return x; Nothing -> fail msg
23:30:14 <corgifex> :t throwError
23:30:15 <lambdabot> MonadError e m => e -> m a
23:30:36 <corgifex> looks like strMsg just creates an error object; it doesn't throw it
23:30:46 <orion> I see.
23:30:48 <orion> interesting
23:31:46 <napping> Are there any general solutions for nice error messages?
23:31:56 <mjrosenb> mmachenry: but he's really wants to be in Error, not in Maybe.
23:33:04 <mmachenry> mjrosenb: Yeah I guess that's true.
23:33:19 <mmachenry> Just figured I'd show what I was thinking.
23:33:53 <mmachenry> Never know when seeing a different perspective will make someone want to change direction.
23:34:03 <orion> mmachenry: thank you
23:34:49 <napping> MonadError gives you throw and catch, but are there any especially nice designs for keeping some kind of context to more easily make nice errors?
23:36:07 <mmachenry> orion: np
23:38:17 <pharaun> finally
23:38:35 <YellowOnion> Is there a strict sum function? (why does adding 'sum' to my dynamic list cause a stack space overflow?)
23:38:38 <pharaun> figured out how the CommandRef worked in lambda bot, cute
23:43:07 <dmj`> @typ foldl' (+) 0
23:43:08 <lambdabot> Num a => [a] -> a
23:43:14 <dmj`> @typ sum
23:43:15 <lambdabot> Num a => [a] -> a
23:43:20 <dmj`> @src sum
23:43:20 <lambdabot> sum = foldl (+) 0
23:43:32 <dmj`> @def sum' = foldl' (+) 0
23:43:33 <lambdabot>  Defined.
23:43:38 <dmj`> > sum' [1..10]
23:43:40 <lambdabot>  55
23:43:41 <mjrosenb> YellowOnion: if you compile with -O2, the sum will most likely be made into something that doesn't eat stack like air.
23:44:04 <mjrosenb> >sum1 [1..10^7]
23:44:12 <mjrosenb> > sum' [1..10^7]
23:44:14 <lambdabot>  50000005000000
23:44:15 <mjrosenb> I can type, I swear.
23:44:27 <mjrosenb> > sum [1..10^7]
23:44:31 <lambdabot>  mueval-core: Time limit exceeded
23:44:36 <dmj`> :P
23:44:48 <pavonia> @src sum
23:44:48 <lambdabot> sum = foldl (+) 0
23:44:50 <mjrosenb> that was not what I was expecting
23:44:53 <mjrosenb> but not unexpected.
23:45:29 <dmj`> mjrosenb: what were you expecting
23:45:43 <mjrosenb> dmj`: an error relating to running out of stack?
23:46:06 <dmj`> mjrosend: do you know what the seq function does?
23:46:16 <mjrosenb> although I guess mueval is interpreting something or other, so it isn't using the stack in the same way that ghc would.
23:47:12 <mjrosenb> dmj`: yeah, also, thank you for informing me that changing the b to a d in my nick turns it into 'send'
23:47:31 <mjrosenb> well, approximately.
23:47:42 <mrb_> (answering my own q for Google: it's because Data-GraphViz-Types-Canonical shadows Data-GraphViz-Types-Generalised. Ugh.
23:50:13 <fitzgen__> hey guys, I'm just learning haskell and I can't figure out why ghc doesn't like my module declaration. can someone help me out? module: http://lpaste.net/103463 error: http://lpaste.net/103464
23:50:18 <fitzgen__> thanks in advance
23:50:52 <pavonia> Imports have to come after the "module" line
23:51:02 <fitzgen__> pavonia: ah! thanks :)
23:51:12 <dmj`> fitzgen__: imports come after a module declaration, not before
23:51:47 <fitzgen__> pavonia: dmj`: thanks! now I have some more errors to work with :)
23:52:16 <fitzgen__> and these make much more sense to me
23:53:12 <pavonia> Are you writing a console game or so?
23:53:45 <fitzgen__> pavonia: yes, I am porting stevelosh.com/blog/2012/07/caves-of-clojure-01/ to haskell as a way to learn haskell
